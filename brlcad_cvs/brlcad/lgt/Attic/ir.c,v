head	11.10;
access;
symbols
	ansi-20040405-merged:11.7.2.1
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.7
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.7.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.7
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.2
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.17.48.15;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.08.09.16.42.52;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	2001.08.08.21.02.04;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.22.55.51;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.06.03.21.40.50;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.50;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.24.13.35.18;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.06;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	89.05.22.12.43.07;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.14;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.05.12.23.27.31;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	89.03.31.16.10.13;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.51.55;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	87.12.09.13.42.11;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.12;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.10.29.08.51.43;	author moss;	state Exp;
branches;
next	6.2;

6.2
date	87.10.15.10.26.03;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.15.46;	author mike;	state Rel;
branches;
next	5.2;

5.2
date	87.07.01.13.37.49;	author moss;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.47.19;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.31.26;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.27.09;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.14.56;	author moss;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.01.03;	author morrison;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.10
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/ir.c,v 11.9 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./tree.h"
#define IR_DATA_WID	512
#define Avg_Fah(sum)	((sum)/(sample_sz))
#define Kelvin2Fah( f )	(9.0/5.0)*((f)-273.15) + 32.0
#define S_BINS		10
#define HUE_TOL		0.5

static RGBpixel	black = { 0, 0, 0 };
static int	ir_max_index = -1;
RGBpixel	*ir_table = (RGBpixel *)RGBPIXEL_NULL;

STATIC void	temp_To_RGB(unsigned char *rgb, int temp);

int
ir_Chk_Table(void)
{
	if( ir_table == (RGBpixel *)PIXEL_NULL )
		{
		get_Input( input_ln, MAX_LN, "Enter minimum temperature : " );
		if( sscanf( input_ln, "%d", &ir_min ) != 1 )
			{
			prnt_Scroll( "Could not read minimum temperature." );
			return	0;
			}
		get_Input( input_ln, MAX_LN, "Enter maximum temperature : " );
		if( sscanf( input_ln, "%d", &ir_max ) != 1 )
			{
			prnt_Scroll( "Could not read maximum temperature." );
			return	0;
			}
		if( ! init_Temp_To_RGB() )
			return	0;
		}
	return	1;
	}

STATIC int
adjust_Page(int y)
{	int	scans_per_page = fbiop->if_ppixels/fbiop->if_width;
		int	newy = y - (y % scans_per_page);
	return	newy;
	}

#define D_XPOS	(x-xmin)
void
display_Temps(int xmin, int ymin)
{	register int	x, y;
		register int	interval = ((grid_sz*3+2)/4)/(S_BINS+2);
		register int	xmax = xmin+(interval*S_BINS);
		register int	ymax;
		fastf_t		xrange = xmax - xmin;

	/* Avoid page thrashing of frame buffer.			*/
	ymin = adjust_Page( ymin );
	ymax = ymin + interval;

	/* Initialize ir_table if necessary.				*/
	if( ! ir_Chk_Table() )
		return;

	for( y = ymin; y <= ymax; y++ )
		{
		x = xmin;
		if( fb_seek( fbiop, x, y ) == -1 )
			{
			bu_log( "\"%s\"(%d) fb_seek to pixel <%d,%d> failed.\n",
				__FILE__, __LINE__, x, y
				);
			return;
			}
		for( ; x <= xmax + interval; x++ )
			{	fastf_t	percent;
				static RGBpixel	*pixel;
			percent = D_XPOS / xrange;
			if( D_XPOS % interval == 0 )
				{	int	temp = AMBIENT+percent*RANGE;
					register int	index = temp - ir_min;
				pixel = (RGBpixel *) ir_table[Min(index,ir_max_index)];
					/* LINT: this should be an &ir_table...,
						allowed by ANSI C, but not current
						compilers. */
				(void) fb_wpixel( fbiop, (unsigned char *) black );
				}
			else
				{
				(void) fb_wpixel( fbiop, (unsigned char *) pixel );
				}
			}
		}
	if( ! get_Font( (char *) NULL ) )
		{
		bu_log( "Could not load font.\n" );
		fb_flush( fbiop );
		return;
		}
	y = ymin;
	for( x = xmin; x <= xmax; x += interval )
		{	char	tempstr[4];
			fastf_t	percent = D_XPOS / xrange;
			int	temp = AMBIENT+percent*RANGE;
			int	shrinkfactor = fb_getwidth( fbiop )/grid_sz;
		(void) sprintf( tempstr, "%3d", temp );
		do_line(	x+2,
				y+(interval-(12/shrinkfactor))/2,
				tempstr
/*,shrinkfactor*/
				);
		}
	fb_flush( fbiop );
	return;
	}

STATIC int
get_IR(int x, int y, int *fahp, FILE *fp)
{
	if( fseek( fp, (long)((y*IR_DATA_WID + x) * sizeof(int)), 0 ) != 0 )
		return	0;
	else
	if( fread( (char *) fahp, (int) sizeof(int), 1, fp ) != 1 )
		return	0;
	else
		return	1;
	}
int
read_IR(FILE *fp)
{	register int	fy;
		register int	rx, ry;
		int		min, max;
	if(	fread( (char *) &min, (int) sizeof(int), 1, fp ) != 1
	     ||	fread( (char *) &max, (int) sizeof(int), 1, fp ) != 1
		)
		{
		bu_log( "Can't read minimum and maximum temperatures.\n" );
		return	0;
		}
	else
		{
		bu_log(	"IR data temperature range is %d to %d\n",
			min, max
			);
		if( ir_min == ABSOLUTE_ZERO )
			{ /* Temperature range not set.			*/
			ir_min = min;
			ir_max = max;
			}
		else 
			{ /* Merge with existing range.			*/
			ir_min = Min( ir_min, min );
			ir_max = Max( ir_max, max );
			bu_log(	"Global temperature range is %d to %d\n",
				ir_min, ir_max
				);
			}
		(void) fflush( stdout );
		}
	if( ! init_Temp_To_RGB() )
		{
		return	0;
		}
 	for( ry = 0, fy = grid_sz-1; ; ry += ir_aperture, fy-- )
		{
		if( fb_seek( fbiop, 0, fy ) == -1 )
			{
			bu_log( "\"%s\"(%d) fb_seek to pixel <%d,%d> failed.\n",
				__FILE__, __LINE__, 0, fy
				);
			return	0;
			}
		for( rx = 0 ; rx < IR_DATA_WID; rx += ir_aperture )
			{	int	fah;
				int	sum = 0;
				register int	i;
				register int	index;
				RGBpixel	*pixel;
			for( i = 0; i < ir_aperture; i++ )
				{	register int	j;
				for( j = 0; j < ir_aperture; j++ )
					{
					if( get_IR( rx+j, ry+i, &fah, fp ) )
						sum += fah < ir_min ? ir_min : fah;
					else	/* EOF */
						{
						if( ir_octree.o_temp == ABSOLUTE_ZERO )
							ir_octree.o_temp = AMBIENT - 1;
						display_Temps( grid_sz/8, 0 );
						return	1;
						}
					}
				}
			fah = Avg_Fah( sum );
			if( (index = fah-ir_min) > ir_max_index || index < 0 )
				{
				bu_log( "temperature out of range (%d)\n",
					fah
					);
				return	0;
				}
			pixel = (RGBpixel *) ir_table[index];
			(void) fb_wpixel( fbiop, (unsigned char *)pixel );
			}
		}
	}

/*	t e m p _ T o _ R G B ( )
	Map temperatures to spectrum of colors.
	This routine is extracted from the "mandel" program written by
	Douglas A. Gwyn here at BRL, and has been modified slightly
	to suit the input data.
 */
STATIC void
temp_To_RGB(unsigned char *rgb, int temp)
{	fastf_t		scale = 4.0 / RANGE;
		fastf_t		t = temp;
		fastf_t		hue = 4.0 - ((t < AMBIENT ? AMBIENT :
					      t > HOTTEST ? HOTTEST :
					      t) - AMBIENT) * scale;
		register int	h = (int) hue;	/* integral part	*/
		register int	f = (int)(256.0 * (hue - (fastf_t)h));
					/* fractional part * 256	*/
	if( t == ABSOLUTE_ZERO )
		rgb[RED] = rgb[GRN] = rgb[BLU] = 0;
	else
	switch ( h )
		{
	default:	/* 0 */
		rgb[RED] = 255;
		rgb[GRN] = f;
		rgb[BLU] = 0;
		break;
	case 1:
		rgb[RED] = 255 - f;
		rgb[GRN] = 255;
		rgb[BLU] = 0;
		break;
	case 2:
		rgb[RED] = 0;
		rgb[GRN] = 255;
		rgb[BLU] = f;
		break;
	case 3:
		rgb[RED] = 0;
		rgb[GRN] = 255 - f;
		rgb[BLU] = 255;
		break;
	case 4:
		rgb[RED] = f;
		rgb[GRN] = 0;
		rgb[BLU] = 255;
		break;
/*	case 5:
		rgb[RED] = 255;
		rgb[GRN] = 0;
		rgb[BLU] = 255 - f;
		break;
 */
		}
/*	bu_log( "temp=%d rgb=(%d %d %d)\n", temp, rgb[RED], rgb[GRN], rgb[BLU] );
 */
	return;
	}

/*	i n i t _ T e m p _ T o _ R G B ( )
	Initialize pseudo-color mapping table for the current view.  This
	color assignment will vary with each set of IR data read so as to
	map the full range of data to the full spectrum of colors.  This
	means that a given color will not necessarily have the same
	temperature mapping for different views of the vehicle, but is only
	valid for display of the current view.
 */
int
init_Temp_To_RGB(void)
{	register int	temp, i;
		RGBpixel	rgb;
	if( (ir_aperture = fb_getwidth( fbiop )/grid_sz) < 1 )
		{
		bu_log( "Grid too large for IR application, max. is %d.\n",
			IR_DATA_WID
			);
		return	0;
		}
	sample_sz = Sqr( ir_aperture );
	if( ir_table != (RGBpixel *)RGBPIXEL_NULL )
		/* Table already initialized presumably from another view,
			since range may differ we must create a different
			table of color assignment, so free storage and re-
			initialize.
		 */
		free( (char *) ir_table );
	ir_table = (RGBpixel *) malloc( (unsigned)(sizeof(RGBpixel)*((ir_max-ir_min)+1)) );
	if( ir_table == (RGBpixel *)RGBPIXEL_NULL )
		{
		Malloc_Bomb(sizeof(RGBpixel)*((ir_max-ir_min)+1));
		fatal_error = TRUE;
		return	0;
		}
	for( temp = ir_min, i = 0; temp <= ir_max; temp++, i++ )
		{
		temp_To_RGB( rgb, temp );
		COPYRGB( ir_table[i], rgb );
		}
	ir_max_index = i - 1;
	return	1;
	}

int
same_Hue(register RGBpixel (*pixel1p), register RGBpixel (*pixel2p))
{	fastf_t	rval1, gval1, bval1;
		fastf_t	rval2, gval2, bval2;
		fastf_t	rratio, gratio, bratio;
	if(	(*pixel1p)[RED] == (*pixel2p)[RED]
	    &&	(*pixel1p)[GRN] == (*pixel2p)[GRN]
	    &&	(*pixel1p)[BLU] == (*pixel2p)[BLU]
		)
		return	1;
	rval1 = (*pixel1p)[RED];
	gval1 = (*pixel1p)[GRN];
	bval1 = (*pixel1p)[BLU];
	rval2 = (*pixel2p)[RED];
	gval2 = (*pixel2p)[GRN];
	bval2 = (*pixel2p)[BLU];
	if( rval1 == 0.0 )
		{
		if( rval2 != 0.0 )
			return	0;
		else /* Both red values are zero. */
			rratio = 0.0;
		}
	else
	if( rval2 == 0.0 )
		return	0;
	else /* Neither red value is zero. */
		rratio = rval1/rval2;
	if( gval1 == 0.0 )
		{
		if( gval2 != 0.0 )
			return	0;
		else /* Both green values are zero. */
			gratio = 0.0;
		}
	else
	if( gval2 == 0.0 )
		return	0;
	else /* Neither green value is zero. */
		gratio = gval1/gval2;
	if( bval1 == 0.0 )
		{
		if( bval2 != 0.0 )
			return	0;
		else /* Both blue values are zero. */
			bratio = 0.0;
		}
	else
	if( bval2 == 0.0 )
		return	0;
	else /* Neither blue value is zero. */
		bratio = bval1/bval2;
	if( rratio == 0.0 )
		{
		if( gratio == 0.0 )
			return	1;
		else
		if( bratio == 0.0 )
			return	1;
		else
		if( AproxEq( gratio, bratio, HUE_TOL ) )
			return	1;
		else
			return	0;
		}
	else
	if( gratio == 0.0 )
		{
		if( bratio == 0.0 )
			return	1;
		else
		if( AproxEq( bratio, rratio, HUE_TOL ) )
			return	1;
		else
			return	0;
		}
	else
	if( bratio == 0.0 )
		{
		if( AproxEq( rratio, gratio, HUE_TOL ) )
			return	1;
		else
			return	0;
		}
	else
		{
		if(	AproxEq( rratio, gratio, HUE_TOL )
		    &&	AproxEq( gratio, bratio, HUE_TOL )
			)
			return	1;
		else
			return	0;
		}
	}

int
pixel_To_Temp(register RGBpixel (*pixelp))
{
#ifdef CRAY2 /* Compiler bug, register pointers don't always compile. */
		RGBpixel	*p;
		RGBpixel	*q = (RGBpixel *) ir_table[ir_max-ir_min];
#else
		register RGBpixel *p;
		register RGBpixel *q = (RGBpixel *) ir_table[ir_max-ir_min];
#endif	
		register int	temp = ir_min;
	for( p = (RGBpixel *) ir_table[0]; p <= q; p++, temp++ )
		{
		if( same_Hue( p, pixelp ) )
			return	temp;
		}
/*	prnt_Scroll( "Pixel=(%d,%d,%d): not assigned a temperature.\n",
		(int)(*pixelp)[RED],
		(int)(*pixelp)[GRN],
		(int)(*pixelp)[BLU]
		);*/
	return	ABSOLUTE_ZERO;
	}
int
f_IR_Model(register struct application *ap, Octree *op)
{	fastf_t		octnt_min[3], octnt_max[3];
		fastf_t		delta = modl_radius / pow_Of_2( ap->a_level );
		fastf_t		point[3]; /* Intersection point.	*/
		fastf_t		norml[3]; /* Unit normal at point.	*/
	/* Push ray origin along ray direction to intersection point.	*/
	VJOIN1( point, ap->a_ray.r_pt, ap->a_uvec[0], ap->a_ray.r_dir );

	/* Compute octant RPP.						*/
	octnt_min[X] = op->o_points->c_point[X] - delta;
	octnt_min[Y] = op->o_points->c_point[Y] - delta;
	octnt_min[Z] = op->o_points->c_point[Z] - delta;
	octnt_max[X] = op->o_points->c_point[X] + delta;
	octnt_max[Y] = op->o_points->c_point[Y] + delta;
	octnt_max[Z] = op->o_points->c_point[Z] + delta;

	if( AproxEq( point[X], octnt_min[X], EPSILON ) )
		/* Intersection point lies on plane whose normal is the
			negative X-axis.
		 */
		{
		norml[X] = -1.0;
		norml[Y] =  0.0;
		norml[Z] =  0.0;
		}
	else
	if( AproxEq( point[X], octnt_max[X], EPSILON ) )
		/* Intersection point lies on plane whose normal is the
			positive X-axis.
		 */
		{
		norml[X] = 1.0;
		norml[Y] = 0.0;
		norml[Z] = 0.0;
		}
	else
	if( AproxEq( point[Y], octnt_min[Y], EPSILON ) )
		/* Intersection point lies on plane whose normal is the
			negative Y-axis.
		 */
		{
		norml[X] =  0.0;
		norml[Y] = -1.0;
		norml[Z] =  0.0;
		}
	else
	if( AproxEq( point[Y], octnt_max[Y], EPSILON ) )
		/* Intersection point lies on plane whose normal is the
			positive Y-axis.
		 */
		{
		norml[X] = 0.0;
		norml[Y] = 1.0;
		norml[Z] = 0.0;
		}
	else
	if( AproxEq( point[Z], octnt_min[Z], EPSILON ) )
		/* Intersection point lies on plane whose normal is the
			negative Z-axis.
		 */
		{
		norml[X] =  0.0;
		norml[Y] =  0.0;
		norml[Z] = -1.0;
		}
	else
	if( AproxEq( point[Z], octnt_max[Z], EPSILON ) )
		/* Intersection point lies on plane whose normal is the
			positive Z-axis.
		 */
		{
		norml[X] = 0.0;
		norml[Y] = 0.0;
		norml[Z] = 1.0;
		}

	{	/* Factor in reflectance from "ambient" light source.	*/
		fastf_t	intensity = Dot( norml, lgts[0].dir );
		/* Calculate index into false-color table.		*/
		register int	index = op->o_temp - ir_min;
	if( index > ir_max_index )
		{
		bu_log( "Temperature (%d) above range of data.\n", op->o_temp );
		return	-1;
		}
	if( index < 0 )
		/* Un-assigned octants get colored grey.		*/
		ap->a_color[0] = ap->a_color[1] = ap->a_color[2] = intensity;
	else	/* Lookup false-coloring for octant's temperature.	*/
		{
		intensity *= RGB_INVERSE;
		ap->a_color[0] = (fastf_t) (ir_table[index][RED]) * intensity;
		ap->a_color[1] = (fastf_t) (ir_table[index][GRN]) * intensity;
		ap->a_color[2] = (fastf_t) (ir_table[index][BLU]) * intensity;
		}
	}
	return	1;
	}
int
f_IR_Backgr(register struct application *ap)
{
	VMOVE( ap->a_color, bg_coefs );
	return	0;
	}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/ir.c,v 11.8 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 5
a16 1
#include "conf.h"
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/ir.c,v 11.5 2001/08/09 16:42:52 jra Exp $ (BRL)";
d38 1
a38 1
STATIC void	temp_To_RGB();
d41 2
a42 2
ir_Chk_Table()
	{
d64 2
a65 3
adjust_Page( y )
int	y;
	{	int	scans_per_page = fbiop->if_ppixels/fbiop->if_width;
d72 2
a73 3
display_Temps( xmin, ymin )
int	xmin, ymin;
	{	register int	x, y;
d140 2
a141 5
get_IR( x, y, fahp, fp )
int	x, y;
int	*fahp;
FILE	*fp;
	{
d151 2
a152 3
read_IR( fp )
FILE	*fp;
	{	register int	fy;
d237 2
a238 4
temp_To_RGB( rgb, temp )
RGBpixel	rgb;
int		temp;
	{	fastf_t		scale = 4.0 / RANGE;
d297 2
a298 2
init_Temp_To_RGB()
	{	register int	temp, i;
d332 2
a333 3
same_Hue( pixel1p, pixel2p )
register RGBpixel	*pixel1p, *pixel2p;
	{	fastf_t	rval1, gval1, bval1;
d427 2
a428 3
pixel_To_Temp( pixelp )
register RGBpixel	*pixelp;
	{
d450 2
a451 4
f_IR_Model( ap, op )
register struct application	*ap;
Octree				*op;
	{	fastf_t		octnt_min[3], octnt_max[3];
d549 2
a550 3
f_IR_Backgr( ap )
register struct application *ap;
	{
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/ir.c,v 11.7 2002/08/20 17:07:34 jra Exp $ (BRL)";
d38 1
a38 1
STATIC void	temp_To_RGB(unsigned char *rgb, int temp);
d41 2
a42 2
ir_Chk_Table(void)
{
d64 3
a66 2
adjust_Page(int y)
{	int	scans_per_page = fbiop->if_ppixels/fbiop->if_width;
d73 3
a75 2
display_Temps(int xmin, int ymin)
{	register int	x, y;
d142 5
a146 2
get_IR(int x, int y, int *fahp, FILE *fp)
{
d156 3
a158 2
read_IR(FILE *fp)
{	register int	fy;
d243 4
a246 2
temp_To_RGB(unsigned char *rgb, int temp)
{	fastf_t		scale = 4.0 / RANGE;
d305 2
a306 2
init_Temp_To_RGB(void)
{	register int	temp, i;
d340 3
a342 2
same_Hue(register RGBpixel (*pixel1p), register RGBpixel (*pixel2p))
{	fastf_t	rval1, gval1, bval1;
d436 3
a438 2
pixel_To_Temp(register RGBpixel (*pixelp))
{
d460 4
a463 2
f_IR_Model(register struct application *ap, Octree *op)
{	fastf_t		octnt_min[3], octnt_max[3];
d561 3
a563 2
f_IR_Backgr(register struct application *ap)
{
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d38 1
a38 1
STATIC void	temp_To_RGB(unsigned char *rgb, int temp);
d41 2
a42 2
ir_Chk_Table(void)
{
d64 3
a66 2
adjust_Page(int y)
{	int	scans_per_page = fbiop->if_ppixels/fbiop->if_width;
d73 3
a75 2
display_Temps(int xmin, int ymin)
{	register int	x, y;
d142 5
a146 2
get_IR(int x, int y, int *fahp, FILE *fp)
{
d156 3
a158 2
read_IR(FILE *fp)
{	register int	fy;
d243 4
a246 2
temp_To_RGB(unsigned char *rgb, int temp)
{	fastf_t		scale = 4.0 / RANGE;
d305 2
a306 2
init_Temp_To_RGB(void)
{	register int	temp, i;
d340 3
a342 2
same_Hue(register RGBpixel (*pixel1p), register RGBpixel (*pixel2p))
{	fastf_t	rval1, gval1, bval1;
d436 3
a438 2
pixel_To_Temp(register RGBpixel (*pixelp))
{
d460 4
a463 2
f_IR_Model(register struct application *ap, Octree *op)
{	fastf_t		octnt_min[3], octnt_max[3];
d561 3
a563 2
f_IR_Backgr(register struct application *ap)
{
@


11.5
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/ir.c,v 11.4 2001/08/08 21:02:04 jra Exp $ (BRL)";
d38 1
a38 1
STATIC void	temp_To_RGB();
d41 2
a42 2
ir_Chk_Table()
	{
d64 2
a65 3
adjust_Page( y )
int	y;
	{	int	scans_per_page = fbiop->if_ppixels/fbiop->if_width;
d72 2
a73 3
display_Temps( xmin, ymin )
int	xmin, ymin;
	{	register int	x, y;
d140 2
a141 5
get_IR( x, y, fahp, fp )
int	x, y;
int	*fahp;
FILE	*fp;
	{
d151 2
a152 3
read_IR( fp )
FILE	*fp;
	{	register int	fy;
d237 2
a238 4
temp_To_RGB( rgb, temp )
RGBpixel	rgb;
int		temp;
	{	fastf_t		scale = 4.0 / RANGE;
d297 2
a298 2
init_Temp_To_RGB()
	{	register int	temp, i;
d332 2
a333 3
same_Hue( pixel1p, pixel2p )
register RGBpixel	*pixel1p, *pixel2p;
	{	fastf_t	rval1, gval1, bval1;
d427 2
a428 3
pixel_To_Temp( pixelp )
register RGBpixel	*pixelp;
	{
d450 2
a451 4
f_IR_Model( ap, op )
register struct application	*ap;
Octree				*op;
	{	fastf_t		octnt_min[3], octnt_max[3];
d549 2
a550 3
f_IR_Backgr( ap )
register struct application *ap;
	{
@


11.4
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/ir.c,v 11.3 2000/08/24 22:55:51 mike Exp $ (BRL)";
d304 1
d459 1
a459 1

d560 1
a560 1

@


11.3
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/ir.c,v 11.2 1999/06/03 21:40:50 mike Exp $ (BRL)";
d155 1
a155 1

@


11.2
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/ir.c,v 11.1 1995/01/04 10:17:50 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/ir.c,v 10.2 94/08/24 13:35:18 gdurf Exp $ (BRL)";
d94 1
a94 1
			rt_log( "\"%s\"(%d) fb_seek to pixel <%d,%d> failed.\n",
d120 1
a120 1
		rt_log( "Could not load font.\n" );
d165 1
a165 1
		rt_log( "Can't read minimum and maximum temperatures.\n" );
d170 1
a170 1
		rt_log(	"IR data temperature range is %d to %d\n",
d182 1
a182 1
			rt_log(	"Global temperature range is %d to %d\n",
d196 1
a196 1
			rt_log( "\"%s\"(%d) fb_seek to pixel <%d,%d> failed.\n",
d225 1
a225 1
				rt_log( "temperature out of range (%d)\n",
d291 1
a291 1
/*	rt_log( "temp=%d rgb=(%d %d %d)\n", temp, rgb[RED], rgb[GRN], rgb[BLU] );
d309 1
a309 1
		rt_log( "Grid too large for IR application, max. is %d.\n",
d543 1
a543 1
		rt_log( "Temperature (%d) above range of data.\n", op->o_temp );
@


10.2
log
@Made includes explicit
Put in appropriate casts to RGBpixel *
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/ir.c,v 10.1 1991/10/12 06:50:06 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/ir.c,v 9.2 89/05/22 12:43:07 moss Exp $ (BRL)";
d12 2
d15 10
d36 1
a36 1
RGBpixel	*ir_table = RGBPIXEL_NULL;
d43 1
a43 1
	if( ir_table == PIXEL_NULL )
d110 1
a110 1
				(void) fb_wpixel( fbiop, (RGBpixel *) black );
d114 1
a114 1
				(void) fb_wpixel( fbiop, pixel );
d231 1
a231 1
			(void) fb_wpixel( fbiop, pixel );
d315 1
a315 1
	if( ir_table != RGBPIXEL_NULL )
d323 1
a323 1
	if( ir_table == RGBPIXEL_NULL )
@


9.2
log
@Changed the 2nd arg to fb_[rw]pixel to be a ptr. rather than just an
	RGBpixel.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 9.1 89/05/19 06:13:14 moss Locked $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 8.3 89/05/12 23:27:31 moss Exp $ (BRL)";
d98 1
a98 1
				(void) fb_wpixel( fbiop, black );
@


8.3
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 8.1 88/10/05 00:51:55 moss Locked $ (BRL)";
@


8.2
log
@Removed local declarations of input_ln since the global copy is available.
@
text
@d13 1
a13 4
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
a14 1
#include "./lgt.h"
a15 1
#include "./extern.h"
d26 1
a26 1
_LOCAL_ void	temp_To_RGB();
d51 1
a51 1
_LOCAL_ int
d129 1
a129 1
_LOCAL_ int
d230 1
a230 1
_LOCAL_ void
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 7.2 87/12/09 13:42:11 moss Locked $ (BRL)";
d37 1
a37 1
		{	char	input_ln[MAX_LN];
@


7.2
log
@Improvements to IR modeling interface.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 7.1 87/11/03 00:25:12 moss Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 6.3 87/10/29 08:51:43 moss Exp $ (BRL)";
a10 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) ir.c	2.1
		Modified: 	12/10/86 at 16:03:25	G S M
		Retrieved: 	2/4/87 at 08:53:25
		SCCS archive:	/vld/moss/src/lgt/s.ir.c
*/
d25 1
d33 23
d61 1
a61 1
	return	newy < grid_sz / 2 ? grid_sz / 2 : newy;
d66 2
a67 2
display_Temps( xmin, ymax )
int	xmin, ymax;
d71 1
a71 1
		register int	ymin;
d75 2
a76 2
	ymax = adjust_Page( ymax );
	ymin = ymax - interval;
d78 2
a79 3
	if( ir_table == RGBPIXEL_NULL )
		{
		rt_log( "IR table not initialized.\n" );
d81 1
a81 1
		}
a153 4
	if( ! fb_Setup( fb_file, IR_DATA_WID ) )
		return	0;
/*	fbiop->if_debug = FB_DEBUG_BIO | FB_DEBUG_BRW | FB_DEBUG_RW;*/
	fb_Zoom_Window();
d182 1
d184 1
d210 1
a210 2
						display_Temps( grid_sz/8, fy );
						close_Output_Device();
d331 99
a429 2
pixel_To_Temp( pixel )
register RGBpixel	*pixel;
d431 3
a433 2
#ifdef CRAY2
		RGBpixel	*p, *q = (RGBpixel *) ir_table[ir_max-ir_min];
d435 2
a436 1
		register RGBpixel	*p, *q = (RGBpixel *) ir_table[ir_max-ir_min];
d441 1
a441 4
		if(	(int) (*p)[RED] == (int) (*pixel)[RED]
		    &&	(int) (*p)[GRN] == (int) (*pixel)[GRN]
		    &&	(int) (*p)[BLU] == (int) (*pixel)[BLU]
			)
d444 5
@


6.3
log
@Ready for release 2.1 of BRL CAD.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 6.2 87/10/15 10:26:03 moss Locked $ (BRL)";
@


6.2
log
@Minor fixes in porting to Cray-2.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 5.1 87/06/24 22:47:19 mike Rel $ (BRL)";
d84 3
d302 1
a302 1
	ir_table = (RGBpixel *) malloc( sizeof(RGBpixel)*((ir_max-ir_min)+1) );
@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 5.2 87/07/01 13:37:49 moss Exp $ (BRL)";
d44 1
a44 1
	return	newy < grid_sz / 2 ? y : newy;
a65 5
	if( ! get_Font( (char *) NULL ) )
		{
		rt_log( "Could not load font.\n" );
		return;
		}
d92 6
d193 1
a193 1
						display_Temps( grid_sz/8, grid_sz * 3 / 4);
d317 6
a322 1
	{	register RGBpixel	*p, *q = (RGBpixel *) ir_table[ir_max-ir_min];
@


5.2
log
@Fixes to IR module resulting from changes in LIBFB and the restructuring
of the gridding loop for parallel architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 5.1 87/06/24 22:47:19 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 1.3 87/06/23 12:31:26 moss Exp $ (BRL)";
a57 1
	rt_log( "ymax=%d\n", ymax );
a59 1
	rt_log( "adjusted ymax=%d ymin=%d interval=%d\n", ymax, ymin, interval );
d167 1
a167 1
 	for( ry = 0, fy = grid_sz-1; ; ry += aperture_sz, fy-- )
d176 1
a176 1
		for( rx = 0 ; rx < IR_DATA_WID; rx += aperture_sz )
d182 1
a182 1
			for( i = 0; i < aperture_sz; i++ )
d184 1
a184 1
				for( j = 0; j < aperture_sz; j++ )
d283 1
a283 1
	if( (aperture_sz = fb_getwidth( fbiop )/grid_sz) < 1 )
d290 1
a290 1
	sample_sz = Sqr( aperture_sz );
d320 3
a322 3
		if(	(int) p[RED] == (int) pixel[RED]
		    &&	(int) p[GRN] == (int) pixel[GRN]
		    &&	(int) p[BLU] == (int) pixel[BLU]
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 1.2 87/02/06 12:27:09 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes, pulled prnt_* functions out into module "prnt.c".
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: ir.c,v 1.1 87/02/04 15:14:56 moss Locked $ (BRL)";
a31 5
#define S_INTERVAL	(length/(S_BINS+2))
#define S_XMAX		(xmin+(S_INTERVAL*S_BINS))
#define S_XRANGE	(S_XMAX-xmin)
#define S_XPOS		(x-xmin)
#define S_YMAX		(ymin+S_INTERVAL)
d42 3
a44 2
	{	int	scans_per_page = 32;/* (_pagesz / sizeof(RGBpixel)) / IR_DATA_WID;*/
	return	y + scans_per_page - (y % scans_per_page);
d47 1
d49 2
a50 2
display_Temps( xmin, ymin, length )
register int	xmin, ymin, length;
d52 5
d58 4
a61 1
	ymin = adjust_Page( ymin );
d73 1
a73 1
	for( y = ymin; y <= S_YMAX; y++ )
d83 1
a83 1
		for( ; x <= S_XMAX + S_INTERVAL; x++ )
d86 2
a87 2
			percent = S_XPOS / (fastf_t)(S_XRANGE);
			if( S_XPOS % S_INTERVAL == 0 )
d94 1
d96 1
a96 1

d99 2
a100 1
	for( x = xmin; x <= S_XMAX; x += S_INTERVAL )
d102 1
a102 1
			fastf_t	percent = S_XPOS / (fastf_t)(S_XRANGE);
d107 3
a109 3
				y-(S_INTERVAL-(12/shrinkfactor))/2,
				tempstr,
				shrinkfactor
d138 1
d169 1
a169 1
	for( ry = 0, fy = 0; ; ry += aperture_sz, fy++ )
d194 1
a194 4
						display_Temps(	grid_sz/8,
								fy + 10,
								(grid_sz*3+2)/4
								);
d331 1
a331 1
do_IR_Model( ap, op )
d334 1
a334 1
	{	fastf_t		octant_min[3], octant_max[3];
d342 6
a347 6
	octant_min[X] = op->o_points->c_point[X] - delta;
	octant_min[Y] = op->o_points->c_point[Y] - delta;
	octant_min[Z] = op->o_points->c_point[Z] - delta;
	octant_max[X] = op->o_points->c_point[X] + delta;
	octant_max[Y] = op->o_points->c_point[Y] + delta;
	octant_max[Z] = op->o_points->c_point[Z] + delta;
d349 1
a349 1
	if( AproxEq( point[X], octant_min[X], EPSILON ) )
d359 1
a359 1
	if( AproxEq( point[X], octant_max[X], EPSILON ) )
d369 1
a369 1
	if( AproxEq( point[Y], octant_min[Y], EPSILON ) )
d379 1
a379 1
	if( AproxEq( point[Y], octant_max[Y], EPSILON ) )
d389 1
a389 1
	if( AproxEq( point[Z], octant_min[Z], EPSILON ) )
d399 1
a399 1
	if( AproxEq( point[Z], octant_max[Z], EPSILON ) )
d432 1
a432 1
do_IR_Backgr( ap )
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d20 6
a25 6
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
#include <fb.h>
#include <vecmath.h>
#include <lgt.h>
@
