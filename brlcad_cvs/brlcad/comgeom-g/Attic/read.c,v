head	11.12;
access;
symbols
	ansi-20040405-merged:11.7.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.6.2
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.7.2.1
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.7.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.6
	phong-branch:11.8.0.4
	photonmap-branch:11.8.0.2
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.3
	offsite-5-3-pre:11.5
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.24.04.16.29;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.07.49.45;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.38.59;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2003.01.31.16.11.34;	author jra;	state Exp;
branches
	11.8.6.1;
next	11.7;

11.7
date	2002.08.20.17.07.20;	author jra;	state Exp;
branches
	11.7.2.1
	11.7.4.1;
next	11.6;

11.6
date	2002.08.15.20.54.32;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2000.11.01.21.37.49;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.10.23.50.09;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	98.09.14.15.57.50;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	96.07.15.18.35.39;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.51;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.23.18.53.08;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.19.08.30;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.49;	author mike;	state Rel4_0;
branches;
next	1.11;

1.11
date	89.12.29.22.36.15;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	89.11.28.02.47.14;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	89.11.27.23.29.42;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	89.11.03.04.13.37;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	89.11.03.03.44.39;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.11.03.01.25.58;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.11.02.23.07.46;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.11.02.16.58.02;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.10.31.17.40.12;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.10.31.16.52.24;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.31.15.19.36;	author mike;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.00.34;	author morrison;	state Exp;
branches;
next	11.7.2.2;

11.7.2.2
date	2004.03.17.21.15.53;	author morrison;	state Exp;
branches;
next	;

11.7.4.1
date	2004.03.11.23.40.28;	author morrison;	state Exp;
branches;
next	;

11.8.6.1
date	2004.02.12.19.40.44;	author erikg;	state Exp;
branches;
next	11.8.6.2;

11.8.6.2
date	2004.03.15.14.06.06;	author erikg;	state Exp;
branches;
next	;


desc
@read.c
@


11.12
log
@moved to src/comgeom-g
@
text
@/*
 *			R E A D . C
 *
 * This module contains all of the routines necessary to read in
 * a COMGEOM input file, and put the information into internal form.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Original Version -
 *	March 17, 1980
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/comgeom-g/read.c,v 11.11 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"

extern FILE	*infp;

extern char name_it[16];		/* argv[3] */

void	namecvt(register int n, register char *cp, int c);

/*
 *			G E T L I N E
 */
int
getline(register char *cp, int buflen, char *title)
{
	register int	c;
	register int	count = buflen;

	while( (c = fgetc(infp)) == '\n' ) /* Skip blank lines.		*/
		;
	while( c != EOF && c != '\n' )  {
		*cp++ = c;
		count--;
		if( count <= 0 )  {
			printf("getline(x%lx, %d) input record overflows buffer for %s\n",
			       (unsigned long)cp, buflen, title);
			break;
		}
		c = fgetc(infp);
	}
	if( c == EOF )
		return	EOF;
	while( count-- > 0 ) 
		*cp++ = 0;
	return	c;
}

/*
 *			G E T I N T
 */
int
getint(char *cp, int start, int len)
{
	char	buf[128];

	if( len >= sizeof(buf) )  len = sizeof(buf)-1;

	strncpy( buf, cp+start, len );
	buf[len] = '\0';
	return atoi(buf);	
}

/*
 *			G E T D O U B L E
 */
double
getdouble(char *cp, int start, int len)
{
	char	buf[128];

	if( len >= sizeof(buf) )  len = sizeof(buf)-1;

	strncpy( buf, cp+start, len );
	buf[len] = '\0';
	return atof(buf);	
}

/*		N A M E C V T	 */
void
namecvt(register int n, register char *cp, int c)
{
	char str[16];

	sprintf( str, "%c%d%.13s", (char)c, n, name_it );
	*cp = bu_strdup( str );
}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/comgeom-g/read.c,v 11.10 2004/04/05 07:49:45 morrison Exp $ (BRL)";
@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.8 2003/01/31 16:11:34 jra Exp $ (BRL)";
d44 1
a44 1
void	namecvt();
d50 1
a50 4
getline( cp, buflen, title )
register char *cp;
int	buflen;
char	*title;
d78 1
a78 4
getint( cp, start, len )
char	*cp;
int	start;
int	len;
d93 1
a93 4
getdouble( cp, start, len )
char	*cp;
int	start;
int	len;
d106 1
a106 4
namecvt( n, cp, c )
register char **cp;
register int n;
char c;
d110 1
a110 1
	sprintf( str, "%c%d%.13s", c, n, name_it );
@


11.8
log
@Mods to handle long names
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.7 2002/08/20 17:07:20 jra Exp $ (BRL)";
@


11.8.6.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.9 2004/02/02 17:38:59 morrison Exp $ (BRL)";
@


11.8.6.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.8.6.1 2004/02/12 19:40:44 erikg Exp $ (BRL)";
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.5 2000/11/01 21:37:49 mike Exp $ (BRL)";
d38 1
d116 1
a116 1
register char *cp;
d118 1
d120 1
a120 1
	static char str[32];
d122 2
a123 2
	sprintf( str, "%c%d%s", c, n, name_it );
	strncpy( cp, str, 16 );		/* truncate str to 16 chars.*/
@


11.7.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/comgeom-g/read.c,v 11.9 2004/02/02 17:38:59 morrison Exp $ (BRL)";
a37 1
#include "bu.h"
d115 1
a115 1
register char **cp;
a116 1
char c;
d118 1
a118 1
	char str[16];
d120 2
a121 2
	sprintf( str, "%c%d%.13s", c, n, name_it );
	*cp = bu_strdup( str );
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.7 2002/08/20 17:07:20 jra Exp $ (BRL)";
d43 1
a43 1
void	namecvt(register int n, register char *cp, int c);
d49 4
a52 1
getline(register char *cp, int buflen, char *title)
d80 4
a83 1
getint(char *cp, int start, int len)
d98 4
a101 1
getdouble(char *cp, int start, int len)
d114 3
a116 1
namecvt(register int n, register char *cp, int c)
@


11.7.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a37 1
#include "bu.h"
d107 1
a107 1
	char str[16];
d109 2
a110 2
	sprintf( str, "%c%d%.13s", (char)c, n, name_it );
	*cp = bu_strdup( str );
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 1
a43 1
void	namecvt(register int n, register char *cp, int c);
d49 4
a52 1
getline(register char *cp, int buflen, char *title)
d80 4
a83 1
getint(char *cp, int start, int len)
d98 4
a101 1
getdouble(char *cp, int start, int len)
d114 3
a116 1
namecvt(register int n, register char *cp, int c)
@


11.5
log
@
lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.4 2000/07/10 23:50:09 mike Exp $ (BRL)";
d43 1
a43 1
void	namecvt();
d49 1
a49 4
getline( cp, buflen, title )
register char *cp;
int	buflen;
char	*title;
d77 1
a77 4
getint( cp, start, len )
char	*cp;
int	start;
int	len;
d92 1
a92 4
getdouble( cp, start, len )
char	*cp;
int	start;
int	len;
d105 1
a105 3
namecvt( n, cp, c )
register char *cp;
register int n;
@


11.4
log
@
lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.3 1998/09/14 15:57:50 bparker Exp $ (BRL)";
d30 5
@


11.3
log
@*- fix typos
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/read.c,v 11.2 1996/07/15 18:35:39 jra Exp $ (BRL)";
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/read.c,v 11.1 1995/01/04 10:06:51 mike Rel4_4 jra $ (BRL)";
d58 2
a59 1
			printf("getline(x%x, %d) input record overflows buffer for %s\n", cp, buflen, title);
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/read.c,v 10.3 94/08/23 18:53:08 gdurf Exp $ (BRL)";
d38 2
d107 1
@


10.3
log
@Added missing include of machine.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/read.c,v 10.2 1994/08/09 19:08:30 gdurf Exp gdurf $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/read.c,v 10.1 1991/10/12 06:44:49 mike Rel4_0 gdurf $ (BRL)";
d30 2
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: read.c,v 1.11 89/12/29 22:36:15 mike Exp $ (BRL)";
d26 1
@


1.11
log
@Added "externs.h" for atof().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


1.10
log
@Moved getint and getdouble here.
Used for reading FORTRAN style input
@
text
@d1 3
a3 1
/*			R E A D . C
d6 15
a20 3
 * Ballistic Research Laboratory
 * U. S. Army
 * March 17, 1980
d22 3
d26 1
d29 1
@


1.9
log
@Changed getline() to take extra args.
@
text
@d10 1
d46 35
@


1.8
log
@This version works nicely
Fast, too
@
text
@d19 1
a19 1
getline( cp )
d21 2
d25 1
a25 1
	register int	count = 80;
d33 1
a33 1
			printf("input buffer (80) overflow\n");
@


1.7
log
@This version uses in-memory region membership lists,
and seems to work.
@
text
@a7 2
extern double atof();
extern char *malloc();
d11 1
a11 2
#include "./ged_types.h"
#include "./3d.h"
d13 1
a13 3
extern int sol_total, sol_work;
extern int	reg_total;
extern int	version;
a14 6
extern long regionpos;
extern long endpos;

extern FILE	*infp;
extern FILE	*outfp;		/* Output only fd */

d49 1
a49 2
	static char str[16];
	extern char name_it[16];		/* argv[3] */
a52 10
}


/*		M O V E N A M E
 * Ensure that name field is null padded */
movename( from, to )
register char *from, *to;
{ register int i;
	for( i=0; i<16; i++ )		to[i] = 0;
	while( *to++ = *from++ );
@


1.6
log
@More improvements
@
text
@d12 1
a12 1
#include <ctype.h>
a15 5
#define DOWN 0
#define UP   1
#define NCARDS	30	/* Number of cards in 1 region */

extern union record record;
d17 1
d20 2
a21 6
struct scard {
	char	sc_num_and_type[10];
	char	sc_fields[6][10];
	char	sc_remark[16];
} 
scard;
a22 58
struct rcard  {
	char	rc_num[5];
	char	rc_null;
	struct	rcfields  {
		char	rcf_null;
		char	rcf_or;
		char	rcf_solid[5];
	}  
	rc_fields[9];
	char	rc_remark[11+3];
} 
rcard;

struct idcard  {
	char	id_foo[80];
#if 0
#ifdef GIFT5
	char	id_region[5];
	char	id_rid[5];
	char	id_air[5];
	char	id_mat[5];
	char	id_los[5];
	char	id_waste[55];
#else
	char	id_region[10];
	char	id_rid[10];
	char	id_air[10];
	char	id_waste[44];
	char	id_mat[3];	/* use any existing material code */
	char	id_los[3];	/* use any existing los percentage */
#endif
#endif
} 
idcard;

int ncards[] =  {
	0,
	1,	/* RPP */
	2,
	2,
	2,
	3,
	3,
	4,
	4,	/* ARB8 */
	2,	/* ELL */
	2,	/* ELL1 */
	1,	/* SPH */
	2,	/* RCC */
	2,	/* REC */
	2,	/* TRC */
	3,	/* TEC */
	2,	/* TOR */
	3,	/* TGC */
	0,	/* GENTGC, 18 */
	2,	/* ELLG, 19 */
};

a24 1
extern int updfd;		/* Update fd */
a25 12
trim_trail_spaces( cp )
register char	*cp;
{
	register char	*ep;

	ep = cp + strlen(cp) - 1;
	while( ep >= cp )  {
		if( *ep != ' ' )  break;
		*ep-- = '\0';
	}
}

a26 613
 *			G E T S O L I D
 *
 *  Returns -
 *	0	done, or EOF
 *	1	non-ARS done
 *	2	ARS done
 */
getsolid( solidp )
register struct solids *solidp;
{
	static int i,j,n,jj,m,mx;
	static float *fp;
	int cd,cds,M,N,Nb_strcx,Nb_strsl,nst,structn,rmcx,cdcx;
	static char nbuf[6];
	static float xmax, ymax, zmax;
	static float xmin, ymin, zmin;
	static float ibuf[10];
	static float jbuf[10];
	struct ars_rec *arsap;
	union record *b;
	char	cur_solid_num[16];
	char	solid_type[16];
	int	cur_type;


	if( sol_work == sol_total )	/* processed all solids */
		return( 0 );

	if( (i = getline( &scard )) == EOF )  {
		printf("getsolid: unexpected EOF\n");
		return( 0 );
	}

	if( version == 5 )  {
		strncpy( cur_solid_num, ((char *)&scard)+0, 5 );
		cur_solid_num[5] = '\0';
		strncpy( solid_type, ((char *)&scard)+5, 5 );
		solid_type[5] = '\0';
	} else {
		strncpy( cur_solid_num, ((char *)&scard)+0, 3 );
		cur_solid_num[3] = '\0';
		strncpy( solid_type, ((char *)&scard)+3, 7 );
		solid_type[7] = '\0';
	}
	/* Trim trailing spaces */
	trim_trail_spaces( cur_solid_num );
	trim_trail_spaces( solid_type );

	/* another solid - increment solid counter
	 * rather than using number from the card, which may go into
	 * pseudo-hex format in version 4 models (due to 3 column limit).
	 */
	sol_work++;

	if( (cur_type = lookup(solid_type)) <= 0 )  {
		printf("getsolid: bad type\n");
		return -1;
	}

	if( cur_type == ARS){
		/*
		 * PROCESS ARS SOLID
		 */
		arsap = (struct ars_rec *) solidp;
		arsap->a_id = ARS_A;
		arsap -> a_type = ARS;
		namecvt( sol_work, arsap -> a_name, 's');
		col_pr( arsap->a_name );

		/*  init  max and min values */
		xmax = ymax = zmax = -10000.0;
		xmin = ymin = zmin = 10000.0;
		/* read   N  M values    ->     convert ASCII to integer  */
		nbuf[10] = '\0';
		for (i=0; i<10; i++)
			nbuf[i]=scard.sc_fields[0][i];

		M = atoi(nbuf);
		arsap -> a_m = M;
		for(i=0; i<10; i++)
			nbuf[i]=scard.sc_fields[1][i];
		N=atoi(nbuf);
		arsap->a_n = N;

		/*
		 *   the number of b type structures needed to store 1
		 * cross section is equal to N/8;  if N modulo 8 is not
		 * equal to 0 then 1 more structure is needed.
		 */
		Nb_strcx = N/8;
		if(( N % 8) !=0)
			Nb_strcx++;
		rmcx = N % 8;

		/*
		 * (8 - rmcx) required # of unused storage locations for the
		 * last structure associated with a cross section.
		 */
		arsap->a_curlen=Nb_strcx;

		/*
		 * number of b type structures calculated above multiplied
		 * by the total number of cross sections equals the total
		 * amount of storage required.
		 */
		Nb_strsl = Nb_strcx * M;
		arsap->a_totlen = Nb_strsl;

		/*
		 * the number of b type structures is used here
		 * to allocate proper storage dynamically
		 */
		if( (b =
		    (union record *)
		    malloc( (unsigned) Nb_strsl*sizeof record )
		    ) == (union record *) NULL
			) {
			(void) fprintf( stderr, "Getsolid(): Malloc() failed!\n" );
			exit( 1 );
		}

		/* calculate number of ARS data cards that have to be read in */
		/*   as given in GIFT users manual  */
		cd = M*((N+1)/2);

		/*    number of data cards per cross section calculated here */
		cdcx = (N+1)/2;

		/*  2 sets of xyz coordinates for every data card
		 *  set up counters to read in coordinate points and load into 
		 *       b structures created above
		 */
		cds = 0;	/* number of data cards read in (1-> cd) */
		nst = -1;	/* b type structure number currently loaded */

		structn = 0;	/* granule # within a cross secton  */
		for(m=1; m < (M+1); m++)  {
			structn=0;
			for(n=1; n <(cdcx+1); n++)  {
				if( getline(&scard) == EOF)
					{
					printf("read of ARS granule failed\n");
					return	0;
					}
				cds++;
				if((j=(n % 4)) == 1)  {
					structn++;   /* increment granule number   */
					nst++;    /*increment structure number */
					b[nst].b.b_id = ARS_B;
					b[nst].b.b_type = ARSCONT;
					b[nst].b.b_n = m;  /*  save cross section number  */
					b[nst].b.b_ngranule = structn;  /* save granule number  */
				}
				for(i=5; i>=0; i--) {
					scard.sc_fields[i][10] = '\0';
					ibuf[i] = atof(scard.sc_fields[i]);
				}
				if(cds == 1){ /* save 1st point coordinate */
					for(i=0; i<3; i++)
						jbuf[i] = ibuf[i];
				}
				switch( j ) {
				case 1:
					b[nst].b.b_values[0]=ibuf[0];
					b[nst].b.b_values[1]=ibuf[1];
					b[nst].b.b_values[2]=ibuf[2];
					b[nst].b.b_values[3]=ibuf[3];
					b[nst].b.b_values[4]=ibuf[4];
					b[nst].b.b_values[5]=ibuf[5];
					break;
				case 2:
					b[nst].b.b_values[6]=ibuf[0];
					b[nst].b.b_values[7]=ibuf[1];
					b[nst].b.b_values[8]=ibuf[2];
					b[nst].b.b_values[9]=ibuf[3];
					b[nst].b.b_values[10]=ibuf[4];
					b[nst].b.b_values[11]=ibuf[5];
					break;
				case 3:
					b[nst].b.b_values[12]=ibuf[0];
					b[nst].b.b_values[13]=ibuf[1];
					b[nst].b.b_values[14]=ibuf[2];
					b[nst].b.b_values[15]=ibuf[3];
					b[nst].b.b_values[16]=ibuf[4];
					b[nst].b.b_values[17]=ibuf[5];
					break;
				case 0:
					b[nst].b.b_values[18]=ibuf[0];
					b[nst].b.b_values[19]=ibuf[1];
					b[nst].b.b_values[20]=ibuf[2];
					b[nst].b.b_values[21]=ibuf[3];
					b[nst].b.b_values[22]=ibuf[4];
					b[nst].b.b_values[23]=ibuf[5];

				}
			}

			/* calculate  min and max values associated with ARS data points */
			/*   save in A type structure */
			for(j=0; j < Nb_strsl; j++)   {
				for(i=0; i<8; i++){
					if(b[j].b.b_values[i*3] > xmax)
						xmax = b[j].b.b_values[i*3];
					else if(b[j].b.b_values[i*3] < xmin)
						xmin = b[j].b.b_values[i*3];
					else if(b[j].b.b_values[(i*3)+1] > ymax )
						ymax = b[j].b.b_values[(i*3)+1];
					else if(b[j].b.b_values[(i*3)+1] < ymin)
						ymin = b[j].b.b_values[(i*3)+1];
					else if(b[j].b.b_values[(i*3)+2] > zmax)
						zmax = b[j].b.b_values[(i*3)+2];
					else if(b[j].b.b_values[(i*3)+2] < zmin)
						zmin = b[j].b.b_values[(i*3)+2];
				}
			}
			/* save max's and min in atype structure */
			arsap->a_xmax=xmax;
			arsap->a_xmin=xmin;
			arsap->a_ymax=ymax;
			arsap->a_ymin=ymin;
			arsap->a_zmax=zmax;
			arsap->a_zmin=zmin;
		}

		/*    subtract base vector from  each vector in description */
		for(j=0; j<Nb_strsl; j++)  {
			for(i=0; i<8; i++){
				b[j].b.b_values[(i*3)] -= jbuf[0];
				b[j].b.b_values[(i*3)+1] -= jbuf[1];
				b[j].b.b_values[(i*3)+2] -= jbuf[2];
			}
		}

		/* restore base vector to original value */
		b[0].b.b_values[0] = jbuf[0];
		b[0].b.b_values[1] = jbuf[1];
		b[0].b.b_values[2] = jbuf[2];

		/*  write out A and B type records  */
		fwrite( arsap, sizeof(union record), 1, outfp );
		fwrite( &b[0], sizeof(union record), Nb_strsl, outfp );

		/* free dynamic storage alloated for ARS */
		free (b);
		return(2);

	}  else   {
		/* solid type other than ARS */

		solidp->s_id = SOLID;
		solidp->s_type = cur_type;
		solidp->s_num = sol_work;

		namecvt( solidp->s_num, solidp->s_name, 's' );

		for(i=0; i<24; i++)
			record.s.s_values[i] = 0.0;

		for( cd=1; cd <= ncards[solidp->s_type]; cd++ )  {
			if( cd != 1 )  {
				if( getline( &scard ) == EOF )  {
					printf("too few cards for solid %d\n",
						solidp->s_num);
					return	0;
				}
				/* continuation card
				 * solid type should be blank 
				 */
				if( (version==5 && ((char *)&scard)[5] != ' ' ) ||
				    (version==4 && ((char *)&scard)[3] != ' ' ) )  {
					printf("solid %d continuation card solid type non-blank, ='%s'\n",
						solidp->s_num, solid_type);
					return 0;
				}
			}

			fp = &solidp->s_values[cd*6-1];
			for(i=5; i>=0; i--)   {
				scard.sc_fields[i][10] = '\0';	/* null OFF END */
				*fp-- = atof( scard.sc_fields[i] );
			}
		}
		convert( solidp );
		return(1);		/* input is valid */
	}
}

/*
 *			G E T R E G I O N
 */
getregion()
{
	union record	rec;
	register union record *rp;
	static union record mem[9*NCARDS];	/* Holds WHOLE Combination */
	register struct members *mp;		/* Pointer to current member */
	int i, j;
	int card;
	int count;
	int n;
	int reg_reg_flag;
	char *cp;

	rp = &rec;

top:
	reg_reg_flag = 0;
	rp->c.c_id = COMB;
	count = 0;		/* count of # of solids in region */

	if( getline( &rcard ) == EOF )  {
		printf("getregion: premature EOF\n");
		return( -1 );
	}

	rcard.rc_null = 0;
	rp->c.c_num = atoi( rcard.rc_num );

	/* -1 region number terminates table */
	if( rp->c.c_num < 0 ) 
		return( 0 );		/* Done */

	/* Build name from region number, set region flag */
	namecvt( rp->c.c_num, rp->c.c_name, 'r' );
	rp->c.c_flags = 'R';		/* Region flag */
	rp->c.c_material = 0;
	rp->c.c_los = 100;

	for( card=0; card<NCARDS; card++ )  {
		if( card != 0 )  {
			if( getline( &rcard ) == EOF )
				{
				printf("getregion: read of continuation card failed\n");
				return(0);
				}
			rcard.rc_null = 0;
			if( atoi( rcard.rc_num ) != 0 )  {
				/* finished with this region */
				break;
			}
		}

		cp = (char *) rcard.rc_fields;

		/* Scan each of the 9 fields on the card */
		for( i=0; i<9; i++ )  {
			cp[7] = 0;	/* clobber succeeding 'O' pos */

			/* check for "-    5" field which atoi will
			 *	return a zero
			 */
			if(cp[2] == '-' || cp[2] == '+') {
				/* remove any followin blanks */
				for(j=3; j<6; j++) {
					if(cp[j] == ' ') {
						cp[j] = cp[j-1];
						cp[j-1] = ' ';
					}
				}
			}

			n = atoi( cp+2 );

			/* Check for null field -- they are to be skipped */
			if( n == 0 )  {
				cp += 7;
				continue;	/* zeros are allowed as placeholders */
			}

			mp = &(mem[count++].M);
			if( version == 5 )  {
				/* Region references region in Gift5 */
				if(rcard.rc_fields[i].rcf_or == 'g' ||
				   rcard.rc_fields[i].rcf_or == 'G')
					reg_reg_flag = 1;

				if( cp[1] == 'R' || cp[1] == 'r' ) 
					mp->m_relation = UNION;
				else {
					if( n < 0 )  {
						mp->m_relation = SUBTRACT;
						n = -n;
					}  else  {
						mp->m_relation = INTERSECT;
					}
				}
			} else {
				/* XXX this may actually be an old piece of code,
				 * rather than the V4 way of doing it. */
				if( cp[1] != ' ' )  {
					mp->m_relation = UNION;
				}  else  {
					if( n < 0 )  {
						mp->m_relation = SUBTRACT;
						n = -n;
					}  else  {
						mp->m_relation = INTERSECT;
					}
				}
			}

			mp->m_id = MEMB;
			mp->m_num = n;
			mat_idn( mp->m_mat );

			/* In Gift5, regions can reference regions */
			if( reg_reg_flag )
				namecvt(n, mp->m_instname, 'r');
			else
				namecvt( n, mp->m_instname, 's' );
			reg_reg_flag = 0;

			cp += 7;
		}
	}

	rp->c.c_length = count;

	fwrite( rp, sizeof(union record), 1, outfp );
	fwrite( mem, sizeof(union record), count, outfp );

	col_pr( rp->c.c_name );

	/* Region was just created;  add it to appropriate group too */

	goto top;
}

/*
 *			G E T I D
 *
 * Load the region ID information into the structures
 */
getid( rp )
register union record *rp;
{
	register int	i;
	int reg;
	int id;
	int air;
	int mat= -1;
	int los= -2;
	char buff[11];
	int	buflen;

	if( getline( (char *) &idcard ) == EOF ||
	    ((char *) &idcard)[0] == '\n' )
		return( 0 );

	/* XXX needs to handle blanked out fields */
	if( version == 5 )  {
		sscanf( &idcard, "%5d%5d%5d%5d%5d",
			&reg, &id, &air, &mat, &los );
	} else {
		sscanf( &idcard, "%10d%10d%10d%*44s%3d%3d",
			&reg, &id, &air, &mat, &los );
	}
printf("reg=%d,id=%d,air=%d,mat=%d,los=%d\n", reg,id,air,mat,los);

#if 0
	if( version == 5 )
		buflen = 5;
	else
		buflen = 10;
	buff[buflen] = '\0';

	for(i=0; i<buflen; i++)
		buff[i] = idcard.id_region[i];
	reg = atoi( buff );

	for(i=0; i<buflen; i++)
		buff[i] = idcard.id_rid[i];
	id = atoi( buff );

	for(i=0; i<buflen; i++)
		buff[i] = idcard.id_air[i];
	air = atoi( buff );

	if( version == 5 )  {
		for(i=0; i<5; i++)
			buff[i] = idcard.id_mat[i];
		mat = atoi( buff );

		for(i=0; i<5; i++)
			buff[i] = idcard.id_los[i];
		los = atoi( buff );
	} else {
		idcard.id_mat[2] = '\0';
		mat = atoi( idcard.id_mat );

		for( i=0; i<3; i++ )
			buff[i] = idcard.id_los[i];
		buff[3] = '\0';
		los = atoi( buff );
	}
#endif

	if( (i = read( updfd, (char *) rp, sizeof(union record) ))
		!= sizeof(union record)
		)
		{
		if( i == -1 )
			perror( "read" );
		printf("read error...STOP\n");
		exit(10);
		}
	/* Back up */
	if( lseek( updfd, -(long)(sizeof(union record)), 1 ) == -1 )
		{
		perror( "lseek" );
		exit(10);
		}
	if( rp->c.c_id != COMB )  {
		printf("Record ID was not COMB...STOP\n");
		exit( 10 );
	}

	if( rp->c.c_num > reg )  {
		/* Must have been a null region */
		return(1);	/* try again with next input card */
	}

	if( rp->c.c_num != reg )  {
		printf("MISMATCH: region table region is %d  ident table region is %d\n",rp->c.c_num,reg);
		printf("STOP\n");
		exit( 10 );
	}

	/* Write out the enhanced Comb (header) record */
	rp->c.c_regionid = id;
	rp->c.c_aircode = air;
	rp->c.c_material = mat;
	rp->c.c_los = los;

	write( updfd, rp, sizeof record );

	/* skip over member records */
	lseek( updfd, rp->c.c_length * ((long)sizeof record), 1 );
	return( 1 );
}

/*
 * Table to map names of solids into internal numbers.
 *
 * NOTE that the name field is expected to be four characters
 * wide, right blank filled, null terminated.
 */
struct table  {
	int	t_value;
	char	t_name[6];
}  
table[] =  {
	RPP,	"rpp",
	BOX,	"box",
	RAW,	"raw",
	ARB8,	"arb8",
	ARB7,	"arb7",
	ARB6,	"arb6",
	ARB5,	"arb5",
	ARB4,	"arb4",
	GENELL,	"ellg",
	ELL1,	"ell1",
	ELL,	"ell",		/* After longer ell entries */
	SPH,	"sph",
	RCC,	"rcc",
	REC,	"rec",
	TRC,	"trc",
	TEC,	"tec",
	TOR,	"tor",
	TGC,	"tgc",
	GENTGC,	"cone",
	ARS,	"ars",
	0,	""
};

/*
 *			L O O K U P
 */
int
lookup( cp )
register char	*cp;
{
	register struct table *tp;
	register char	*lp;
	register char	c;
	char	low[32];
	

	/* Reduce input to lower case */
	lp = low;
	while( (c = *cp++) != '\0' )  {
		if( !isascii(c) )  {
			*lp++ = '?';
		} else if( isupper(c) )  {
			*lp++ = tolower(c);
		} else {
			*lp++ = c;
		}
	}
	*lp = '\0';

	tp = &table[0];
	while( tp->t_value != 0 )  {
		if( strcmp( low, tp->t_name ) == 0 )
			return( tp->t_value );
		tp++;
	}

	printf("ERROR:  bad solid type '%s'\n", low );
	return(0);
}

/*
d68 7
a74 43

/*
 *			G E T _ T I T L E
 */
get_title()
{
	char ctitle[80];
	int i;

	if( (i = getline( ctitle )) == EOF ) {
		printf("Empty input file\n");
		exit(10);
	}
	/* First 2 chars are units */
	printf("Units: %2.2s  Title: %s\n",ctitle, ctitle+2);

	mk_id( outfp, ctitle+2 );
}



/*
 *			G E T _ C O N T R O L
 */
get_control()
{
	int i;
	char ch[80];
	int	reg_total=0;

	if( (i = getline( ch )) == EOF ) {
		printf("No control card .... STOP\n");
		exit(10);
	}

	if( version == 5 )  {
		sscanf( ch, "%5d%5d", &sol_total, &reg_total );
	} else {
		ch[20] = 0;
		sol_total = atoi( ch+10 );
	}

	printf("Expecting %d solids, %d regions\n", sol_total, reg_total);
@


1.5
log
@Progress is being made
@
text
@d89 3
a91 2
int outfd;		/* Output only fd */
int updfd;		/* Update fd */
d107 5
d128 1
d134 4
a137 2
	if( (i = getline( &scard )) == EOF )
		return( 0 );	/* end of file */
a152 1
printf("cur_solid_num='%s', solid_type='%s'\n", cur_solid_num, solid_type );
d160 9
a168 4
	/*
	 * PROCESS ARS SOLID
	 */
	if( lookup(solid_type) == ARS){
d173 1
a173 1
		printf("%s \t",arsap->a_name);
d345 2
a346 2
		write( outfd, arsap, sizeof record);
		write(outfd, &b[0], (Nb_strsl * sizeof (record)));
a354 1

d356 1
a356 1
		solidp->s_type = lookup( solid_type );
d361 3
d366 1
a366 2
				if( getline( &scard ) == EOF )
					{
d370 1
a370 1
					}
d388 1
a392 2
int noreadflag = DOWN;

d396 1
a396 2
getregion( rp )
register union record *rp;
d398 2
d406 1
a406 1
	int reg_reg_flag = 0;
d409 4
d416 3
a418 3
	if( noreadflag == DOWN )  {
		if( getline( &rcard ) == EOF ) 
			return( 0 );		/* EOF */
a419 1
	noreadflag = DOWN;
d426 1
a426 1
		return( 0 );
a433 4
/*
	rcard.rc_fields[0].rcf_or = 'R';
*/

d438 1
a438 1
				printf("read of card failed\n");
a443 1
				noreadflag = UP;
a521 13
	if(card == NCARDS) {
		/* check if NCARDS is large enough */
		if(getline(&rcard) == EOF )
			return(0);
		rcard.rc_null = 0;
		if(atoi(rcard.rc_num) == 0) {
			printf("STOP: too many lines for region %d\n",rp->c.c_num);
			printf("must change code (read.c)  NCARDS = %d\n",NCARDS);
			exit(10);
		}
		noreadflag = UP;
	}

d524 2
a525 2
	write( outfd, rp, sizeof record );
	write( outfd, mem, count * sizeof record );
d527 5
a531 1
	return( 1 );		/* success */
d546 2
a547 2
	int mat;
	int los;
d555 1
d557 1
a557 1
		sscanf( idcard, "%5d%5d%5d%5d%5d",
d560 1
a560 1
		sscanf( idcard, "%10d%10d%10d%*44s%3d%3d",
d728 1
a728 1
	while( (c = getchar()) == '\n' ) /* Skip blank lines.		*/
d737 1
a737 1
		c = getchar();
d751 4
a754 9
{ static char str[16], s[16];
  extern char name_it[16];		/* argv[3] */
#if 0
	str[0] = c;			/* record type letter.*/
	str[1] = '\0';			/* terminate string.*/
	f2a( (float)n, s, 12, 0 );	/* get string for 'n'.*/
	strcat( str, s );		/* append 'n'string.*/
	strcat( str, name_it );	/* append argv[3].*/
#else
a755 1
#endif
d774 3
a776 2
	printf("Units  Title: %s\n",ctitle);
	return;
@


1.4
log
@Modified to use ordinary string library routines
@
text
@d12 1
d22 1
d25 1
a25 7
#ifdef GIFT5
	char	sc_num[5];
	char	sc_type[5];
#else
	char	sc_num[3];
	char	sc_type[7];
#endif
d45 2
d62 1
d92 4
d97 7
d120 2
d130 20
a149 1
	/* another solid - increment solid counter */
a151 2
	scard.sc_type[4] = '\0';

d155 1
a155 1
	if( lookup(scard.sc_type) == ARS){
d158 1
a158 1
		arsap -> a_type = lookup(scard.sc_type);
d234 1
a234 1
					printf("read of granule failed\n");
d344 1
a344 1
		solidp->s_type = lookup( scard.sc_type );
d353 2
a354 1
					printf("too few cards for solid %d\n",solidp->s_num);
d360 5
a364 3
				if(scard.sc_type[0] != ' ') {
					printf("too few cards for solid %d\n",solidp->s_num);
					exit(10);
d464 5
a468 4
#ifdef GIFT5
			if(rcard.rc_fields[i].rcf_or == 'g' ||
			   rcard.rc_fields[i].rcf_or == 'G')
				reg_reg_flag = 1;
d470 9
a478 8
			if( cp[1] == 'R' || cp[1] == 'r' ) 
				mp->m_relation = UNION;
			else {
				if( n < 0 )  {
					mp->m_relation = SUBTRACT;
					n = -n;
				}  else  {
					mp->m_relation = INTERSECT;
d480 5
a484 8
			}
#else
			if( cp[1] != ' ' )  {
				mp->m_relation = UNION;
			}  else  {
				if( n < 0 )  {
					mp->m_relation = SUBTRACT;
					n = -n;
d486 6
a491 1
					mp->m_relation = INTERSECT;
d494 1
a494 1
#endif
d499 1
a499 1
#ifdef GIFT5
d505 1
a505 3
#else
			namecvt( n, mp->m_instname, 's' );
#endif
d546 1
d552 8
a559 6
#ifdef GIFT5
#	define BUFLEN	5
#else
#	define BUFLEN	10
#endif
	buff[BUFLEN] = '\0';
d561 8
a568 1
	for(i=0; i<BUFLEN; i++)
d572 1
a572 1
	for(i=0; i<BUFLEN; i++)
d576 1
a576 1
	for(i=0; i<BUFLEN; i++)
d580 4
a583 4
#ifdef GIFT5
	for(i=0; i<5; i++)
		buff[i] = idcard.id_mat[i];
	mat = atoi( buff );
d585 6
a590 6
	for(i=0; i<5; i++)
		buff[i] = idcard.id_los[i];
	los = atoi( buff );
#else
	idcard.id_mat[2] = '\0';
	mat = atoi( idcard.id_mat );
d592 5
a596 4
	for( i=0; i<3; i++ )
		buff[i] = idcard.id_los[i];
	buff[3] = '\0';
	los = atoi( buff );
d654 3
a656 3
	RPP,	"rpp ",
	BOX,	"box ",
	RAW,	"raw ",
d662 1
a662 1
	ELL,	"ell ",
d664 10
a673 29
	SPH,	"sph ",
	RCC,	"rcc ",
	REC,	"rec ",
	TRC,	"trc ",
	TEC,	"tec ",
	TOR,	"tor ",
	TGC,	"tgc ",
	GENELL,	"ellg",
	GENTGC,	"CONE",
	ARS,  "ars ",
	RPP,	"RPP ",	/* sometimes COMGEOM files are uppercase */
	BOX,	"BOX ",
	RAW,	"RAW ",
	ARB8,	"ARB8",
	ARB7,	"ARB7",
	ARB6,	"ARB6",
	ARB5,	"ARB5",
	ARB4,	"ARB4",
	ELL,	"ELL ",
	ELL1,	"ELL1",
	SPH,	"SPH ",
	RCC,	"RCC ",
	REC,	"REC ",
	TRC,	"TRC ",
	TEC,	"TEC ",
	TOR,	"TOR ",
	TGC,	"TGC ",
	GENELL,	"ELLG",
	ARS,  "ARS ",
d681 3
a683 1
lookup( cp )  {
d685 4
d690 13
a703 1

d705 1
a705 1
		if( strcmp( cp, tp->t_name ) == 0 )
d710 1
a710 1
	printf("ERROR:  bad solid type '%s'\n", cp );
d717 1
d721 1
a721 1
	register char	c;
d729 4
d749 1
d755 3
d796 6
a801 6
#ifdef GIFT5
	sscanf( ch, "%5d%5d", &sol_total, &reg_total );
#else
	ch[20] = 0;
	sol_total = atoi( ch+10 );
#endif
@


1.3
log
@Merged CVT4 and CVT5
@
text
@d654 1
d661 1
a661 1
		if( strcmp( cp, tp->t_name ) != 0 )
a670 26
 *			S T R C M P
 */
strcmp( s1, s2 )
register char *s1, *s2;
{
	while( *s1++ == *s2 )
		if( *s2++ == '\0' )
			return(1);
	return(0);
}

/*
 * Buffer for GETC
 */
/*
struct buf  {
	int	fildes;
	int	nunused;
	char	*xfree;
	char	buff[512];
} 
inbuf = { 
	0, 0, };
*/

/*
d703 2
a704 2
	strappend( str, s );		/* append 'n'string.*/
	strappend( str, name_it );	/* append argv[3].*/
d722 1
d736 1
d744 1
a744 2
	ch[5] = 0;
	sol_total = atoi( ch );
d750 1
a750 2
	return;

a751 3



@


1.2
log
@Cake header locations
@
text
@d17 1
a17 1
#define NCARDS	29	/* Number of cards in 1 region */
d23 4
d29 1
d49 8
d63 1
d115 1
a115 1
	if( (i = getline( &scard )) == 0 )
d127 1
a127 4
		arsap = solidp;
/*
		b = solidp;
*/
d137 1
a168 5
		if( (b = (union record *) malloc( (unsigned) Nb_strsl*sizeof record )) == (union record *) NULL ) {
			(void) fprintf( stderr, "getsolid(): malloc() failed!\n" );
			exit(1);
		}

d176 8
a183 1
		b = malloc( (unsigned)(Nb_strsl * sizeof record) );
d203 5
a207 1
				getline(&scard);
d322 5
a326 1
				getline( &scard );
d356 1
a356 1
	int i;
d360 1
d367 1
a367 1
		if( getline( &rcard ) < 0 ) 
d391 3
a393 2
/*
			if( getline( &rcard ) < 0 ) 
d395 1
a395 2
*/
			getline( &rcard );
d404 1
a404 1
		cp = &rcard.rc_fields;
d409 14
d432 4
d437 11
d458 1
d461 1
a461 1
			mat_idn( &mp->m_mat );
d463 7
d471 1
d478 1
a478 1
		if(getline(&rcard) < 0)
d492 1
a492 1
	write( outfd, &mem, count * sizeof record );
d505 1
a510 1
	int i;
d513 2
a514 1
	if( getline( &idcard ) < 0 )
d517 6
a522 1
	buff[10] = '\0';
d524 1
a524 1
	for(i=0; i<10; i++)
d528 1
a528 1
	for(i=0; i<10; i++)
d532 1
a532 1
	for(i=0; i<10; i++)
d536 9
d552 1
d554 15
a568 6
	if( read( updfd, rp, sizeof record ) != sizeof record ) {
		printf("read error....STOP\n");
		exit( 10 );
	}
	lseek( updfd, -(long)(sizeof record), 1 );		/* Back up */

d666 1
a666 1
	exit(10);
d701 2
a702 2
	register char c;
	register int count;
d704 3
a706 2
	count = 80;
	while( (c = getchar()) > 0 && c != '\n' )  {
d709 1
d711 3
a713 2

	while( count-- >= 0 ) 
d715 1
a715 2

	return( c );
d743 1
a743 1
	if( (i = getline( ctitle )) == 0 ) {
d747 1
a747 1
	printf("Title: %s\n",ctitle);
d761 1
a761 1
	if( (i = getline( ch )) == 0 ) {
d766 4
a769 3
	for(i=0;i<10;i++)
		ch[i] = ' ';

d771 2
a772 1
	sol_total = atoi( ch );
@


1.1
log
@Initial revision
@
text
@d12 2
a13 2
#include "ged_types.h"
#include "3d.h"
@
