head	11.5;
access;
symbols
	ansi-20040405-merged:11.3.2.1
	postmerge-20040405-ansi:11.4
	premerge-20040404-ansi:11.3
	postmerge-autoconf:11.3
	autoconf-freeze:11.3
	premerge-autoconf:11.3
	ansi-20040316-freeze:11.3.2.1
	postmerge-20040315-windows:11.3
	premerge-20040315-windows:11.3
	windows-20040315-freeze:11.3
	autoconf-20031203:11.3
	autoconf-20031202:11.3
	autoconf-branch:11.3.0.10
	phong-branch:11.3.0.8
	photonmap-branch:11.3.0.6
	rel-6-1-DP:11.3
	windows-branch:11.3.0.4
	rel-6-0-2:11.1
	ansi-branch:11.3.0.2
	rel-6-0-1-branch:11.1.0.4
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.1
	rel-6-0-1:11.1
	rel-6-0:11.1
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:1.2;
locks; strict;
comment	@ * @;


11.5
date	2004.05.24.04.16.29;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2004.04.05.07.49.44;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	2002.08.20.17.07.20;	author jra;	state Exp;
branches
	11.3.2.1;
next	11.2;

11.2
date	2002.08.15.20.54.32;	author hartley;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.50;	author mike;	state Rel4_4;
branches;
next	1.2;

1.2
date	89.10.31.17.40.09;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.31.15.16.25;	author mike;	state Exp;
branches;
next	;

11.3.2.1
date	2002.09.19.18.00.33;	author morrison;	state Exp;
branches;
next	;


desc
@mat.c
@


11.5
log
@moved to src/comgeom-g
@
text
@/*
 *			M A T . C
 *
 * 4 x 4 Matrix manipulation functions..............
 *
 *	mat_zero( &m )			Fill matrix m with zeros
 *	mat_idn( &m )			Fill matrix m with identity matrix
 *	mat_copy( &o, &i )		Copy matrix i to matrix o
 *	mat_mul( &o, &i1, &i2 )		Multiply i1 by i2 and store in o
 *	vecXmat( &ov, &iv, &m )		Multiply vector iv by m and store in ov
 *	matXvec( &ov, &m, &iv )		Multiply m by vector iv and store in ov
 *	mat_print( &m )			Print out the 4x4 matrix - calls printf
 *	mat_hscale( &m, hscale )	Homogenious scale of input matrix
 *	mat_inv( &om, &im )		Invert matrix im and store result in om
 *
 *
 * Matrix array elements have the following positions in the matrix:
 *
 *				|  0  1  2  3 |		| 0 |
 *	  [ 0 1 2 3 ]		|  4  5  6  7 |		| 1 |
 *				|  8  9 10 11 |		| 2 |
 *				| 12 13 14 15 |		| 3 |
 *
 *     preVector (vect_t)	 Matrix (mat_t)    postVector (vect_t)
 *
 */

#include "./ged_types.h"


/*
 *			M A T _ Z E R O
 *
 * Fill in the matrix "m" with zeros.
 */
mat_zero(register matp_t m)
{
	register int i = 0;

	/* Clear everything */
	for(; i<16; i++)
		*m++ = 0;
}


/*
 *			M A T _ I D N
 *
 * Fill in the matrix "m" with an identity matrix.
 */
mat_idn(register matp_t m)
{
	/* Clear everything first */
	mat_zero( m );

	/* Set ones in the diagonal */
	m[0] = m[5] = m[10] = m[15] = 1;
}


/*
 *			M A T _ C O P Y
 *
 * Copy the matrix "im" into the matrix "om".
 */
mat_copy(register matp_t om, register matp_t im)
{
	register int i = 0;

	/* Copy all elements */
	for(; i<16; i++)
		*om++ = *im++;
}


/*
 *			M A T _ M U L
 *
 * Multiply matrix "im1" by "im2" and store the result in "om".
 * NOTE:  This is different from multiplying "im2" by "im1" (most
 * of the time!)
 */
mat_mul(register matp_t om, register matp_t im1, register matp_t im2)
{
	register int em1;		/* Element subscript for im1 */
	register int em2;		/* Element subscript for im2 */
	register int el = 0;		/* Element subscript for om */
	register int i;			/* For counting */

	/* For each element in the output matrix... */
	for(; el<16; el++) {

		om[el] = 0;		/* Start with zero in output */
		em1 = (el/4)*4;		/* Element at right of row in im1 */
		em2 = el%4;		/* Element at top of column in im2 */

		for(i=0; i<4; i++) {
			om[el] += im1[em1] * im2[em2];

			em1++;		/* Next row element in m1 */
			em2 += 4;	/* Next column element in m2 */
		}
	}
}


/*
 *			V E C X M A T
 *
 * Multiply the vector "iv" by the matrix "im" and store the result
 * in the vector "ov".  Note this is pre-multiply.
 */
vecXmat(register vectp_t ov, register vectp_t iv, register matp_t im)
{
	register int el = 0;		/* Position in output vector */
	register int ev;		/* Position in input vector */
	register int em;		/* Position in input matrix */

	/* For each element in the output array... */
	for(; el<4; el++) {

		ov[el] = 0;		/* Start with zero in output */
		em = el;		/* Top of column in input matrix */

		for(ev=0; ev<4; ev++) {
			ov[el] += iv[ev] * im[em];
			em += 4;	/* Next element in column from im */
		}
	}
}


/*
 *			M A T X V E C
 *
 * Multiply the matrix "im" by the vector "iv" and store the result
 * in the vector "ov".  Note this is post-multiply.
 */
matXvec(register vectp_t ov, register matp_t im, register vectp_t iv)
{
	register int eo = 0;		/* Position in output vector */
	register int em = 0;		/* Position in input matrix */
	register int ei;		/* Position in input vector */

	/* For each element in the output array... */
	for(; eo<4; eo++) {

		ov[eo] = 0;		/* Start with zero in output */

		for(ei=0; ei<4; ei++)
			ov[eo] += im[em++] * iv[ei];
	}
}


/*
 *			M A T _ P R I N T
 *
 * Print out the 4x4 matrix addressed by "m".
 */
mat_print(register matp_t m)
{
	register int i;

	for(i=0; i<16; i++) {
		printf("%f%c", m[i], ((i+1)%4) ? '\t' : '\n');
	}
}


/*
 *			M A T _ H S C A L E
 *
 * The matrix pointed at by "m" is homogeniously scaled by the
 * variable "hscale".  NOTE that the input matrix is ALSO the output
 * matrix.
 */
mat_hscale(register matp_t m, float hscale)
{
	m[0] *= hscale;
	m[5] *= hscale;
	m[10] *= hscale;
}


/*
 *			M A T _ I N V
 *
 * The matrix pointed at by "im" is inverted and stored in the area
 * pointed at by "om".
 */
double abs(double foo);
#define EPSILON	0.000001

/* 
 * Invert a 4-by-4 matrix using Algorithm 120 from ACM.
 * This is a modified Gauss-Jordan alogorithm
 * Note:  Inversion is done in place, with 3 work vectors
 */
void
mat_inv(register matp_t output, matp_t input)
{
	register int i, j;			/* Indices */
	static int k;				/* Indices */
	static int	z[4];			/* Temporary */
	static float	b[4];			/* Temporary */
	static float	c[4];			/* Temporary */

	mat_copy( output, input );	/* Duplicate */

	/* Initialization */
	for( j = 0; j < 4; j++ )
		z[j] = j;

	/* Main Loop */
	for( i = 0; i < 4; i++ )  {
		static float y;				/* local temporary */

		k = i;
		y = output[i*4+i];
		for( j = i+1; j < 4; j++ )  {
			static float w;			/* local temporary */

			w = output[i*4+j];
			if( abs(w) > abs(y) )  {
				k = j;
				y = w;
			}
		}

		if( abs(y) < EPSILON )  {
			printf("mat_inv:  error!\n");
			return;
		}
		y = 1.0 / y;

		for( j = 0; j < 4; j++ )  {
			static float temp;		/* Local */

			c[j] = output[j*4+k];
			output[j*4+k] = output[j*4+i];
			output[j*4+i] = - c[j] * y;
			temp = output[i*4+j] * y;
			b[j] = temp;
			output[i*4+j] = temp;
		}

		output[i*4+i] = y;
		j = z[i];
		z[i] = z[k];
		z[k] = j;
		for( k = 0; k < 4; k++ )  {
			if( k == i )  continue;
			for( j = 0; j < 4; j++ )  {
				if( j == i )  continue;
				output[k*4+j] = output[k*4+j] - b[j] * c[k];
			}
		}
	}

	/*  Second Loop */
	for( i = 0; i < 4; i++ )  {
		while( (k = z[i]) != i )  {
			static int p;			/* Local temp */

			for( j = 0; j < 4; j++ )  {
				static float w;		/* Local temp */

				w = output[i*4+j];
				output[i*4+j] = output[k*4+j];
				output[k*4+j] = w;
			}
			p = z[i];
			z[i] = z[k];
			z[k] = p;
		}
	}
	return;
}

double abs(double foo)
{
	if( foo < 0 )
		return( -foo );
	else
		return( foo );
}

/*
 *			V T O H _ M O V E
 *
 * Takes a pointer to a [x,y,z] vector, and a pointer
 * to space for a homogeneous vector [x,y,z,w],
 * and builds [x,y,z,1].
 */
vtoh_move(register float *h, register float *v)
{
	*h++ = *v++;
	*h++ = *v++;
	*h++ = *v;
	*h++ = 1;
}

/*
 *			H T O V _ M O V E
 *
 * Takes a pointer to [x,y,z,w], and converts it to
 * an ordinary vector [x/w, y/w, z/w].
 * Optimization for the case of w==1 is performed.
 */
htov_move(register float *v, register float *h)
{
	static float inv;

	if( h[3] == 1 )  {
		*v++ = *h++;
		*v++ = *h++;
		*v   = *h;
	}  else  {
		inv = 1 / h[3];

		*v++ = *h++ * inv;
		*v++ = *h++ * inv;
		*v   = *h   * inv;
	}
}
@


11.4
log
@merge of ansi-6-0-branch into HEAD
@
text
@@


11.3
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d36 1
a36 2
mat_zero( m )
register matp_t m;
d51 1
a51 2
mat_idn( m )
register matp_t m;
d66 1
a66 3
mat_copy( om, im )
register matp_t om;
register matp_t im;
d83 1
a83 4
mat_mul( om, im1, im2 )
register matp_t om;
register matp_t im1;
register matp_t im2;
d113 1
a113 4
vecXmat(ov, iv, im)
register vectp_t ov;
register vectp_t iv;
register matp_t im;
d139 1
a139 4
matXvec(ov, im, iv)
register vectp_t ov;
register matp_t im;
register vectp_t iv;
d161 1
a161 2
mat_print( m )
register matp_t m;
d178 1
a178 3
mat_hscale( m, hscale )
register matp_t m;
float hscale;
d192 1
a192 1
double abs();
d201 1
a201 3
mat_inv( output, input )
matp_t input;
register matp_t output;
d281 1
a281 2
double abs( foo )
double foo;
d296 1
a296 2
vtoh_move( h, v )
register float *h, *v;
d311 1
a311 2
htov_move( v, h )
register float *v, *h;
@


11.3.2.1
log
@Initial ANSIfication
@
text
@d36 2
a37 1
mat_zero(register matp_t m)
d52 2
a53 1
mat_idn(register matp_t m)
d68 3
a70 1
mat_copy(register matp_t om, register matp_t im)
d87 4
a90 1
mat_mul(register matp_t om, register matp_t im1, register matp_t im2)
d120 4
a123 1
vecXmat(register vectp_t ov, register vectp_t iv, register matp_t im)
d149 4
a152 1
matXvec(register vectp_t ov, register matp_t im, register vectp_t iv)
d174 2
a175 1
mat_print(register matp_t m)
d192 3
a194 1
mat_hscale(register matp_t m, float hscale)
d208 1
a208 1
double abs(double foo);
d217 3
a219 1
mat_inv(register matp_t output, matp_t input)
d299 2
a300 1
double abs(double foo)
d315 2
a316 1
vtoh_move(register float *h, register float *v)
d331 2
a332 1
htov_move(register float *v, register float *h)
@


11.2
log
@Converted from K&R to ANSI C - RFH
@
text
@d36 2
a37 1
mat_zero(register matp_t m)
d52 2
a53 1
mat_idn(register matp_t m)
d68 3
a70 1
mat_copy(register matp_t om, register matp_t im)
d87 4
a90 1
mat_mul(register matp_t om, register matp_t im1, register matp_t im2)
d120 4
a123 1
vecXmat(register vectp_t ov, register vectp_t iv, register matp_t im)
d149 4
a152 1
matXvec(register vectp_t ov, register matp_t im, register vectp_t iv)
d174 2
a175 1
mat_print(register matp_t m)
d192 3
a194 1
mat_hscale(register matp_t m, float hscale)
d208 1
a208 1
double abs(double foo);
d217 3
a219 1
mat_inv(register matp_t output, matp_t input)
d299 2
a300 1
double abs(double foo)
d315 2
a316 1
vtoh_move(register float *h, register float *v)
d331 2
a332 1
htov_move(register float *v, register float *h)
@


11.1
log
@Release_4.4
@
text
@d36 1
a36 2
mat_zero( m )
register matp_t m;
d51 1
a51 2
mat_idn( m )
register matp_t m;
d66 1
a66 3
mat_copy( om, im )
register matp_t om;
register matp_t im;
d83 1
a83 4
mat_mul( om, im1, im2 )
register matp_t om;
register matp_t im1;
register matp_t im2;
d113 1
a113 4
vecXmat(ov, iv, im)
register vectp_t ov;
register vectp_t iv;
register matp_t im;
d139 1
a139 4
matXvec(ov, im, iv)
register vectp_t ov;
register matp_t im;
register vectp_t iv;
d161 1
a161 2
mat_print( m )
register matp_t m;
d178 1
a178 3
mat_hscale( m, hscale )
register matp_t m;
float hscale;
d192 1
a192 1
double abs();
d201 1
a201 3
mat_inv( output, input )
matp_t input;
register matp_t output;
d281 1
a281 2
double abs( foo )
double foo;
d296 1
a296 2
vtoh_move( h, v )
register float *h, *v;
d311 1
a311 2
htov_move( v, h )
register float *v, *h;
@


1.2
log
@Merged CVT4 and CVT5
@
text
@@


1.1
log
@Initial revision
@
text
@d28 1
a28 1
#include "ged_types.h"
@
