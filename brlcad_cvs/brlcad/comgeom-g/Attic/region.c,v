head	11.15;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.6.2
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.6
	phong-branch:11.11.0.4
	photonmap-branch:11.11.0.2
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.7
	rel-5-4:11.1
	offsite-5-3-pre:11.4
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.24.04.16.29;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.07.49.45;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.38.59;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2003.01.31.16.11.34;	author jra;	state Exp;
branches
	11.11.6.1;
next	11.10;

11.10
date	2002.08.20.17.07.20;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1;
next	11.9;

11.9
date	2002.08.15.20.54.32;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2002.05.28.19.10.25;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2001.11.20.13.52.33;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	2001.05.16.21.37.11;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2001.04.12.14.40.20;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.24.04.56.48;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.07.20.18.36.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.07.10.23.50.09;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.52;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.10.21.20.09.49;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.18.53.35;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.19.08.37;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.49;	author mike;	state Rel4_0;
branches;
next	1.16;

1.16
date	90.12.05.19.24.48;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.12.05.05.59.45;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	90.12.04.23.15.59;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	90.10.16.21.07.44;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.02.27.20.11.04;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.02.10.02.35.09;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	89.12.29.22.40.58;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	89.11.30.03.40.45;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	89.11.30.02.39.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	89.11.30.02.23.08;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.11.30.00.28.28;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.11.29.23.55.40;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.11.28.02.47.36;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.11.27.23.31.35;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.11.03.04.13.40;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.11.03.03.44.42;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.00.34;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.15.53;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.40.28;	author morrison;	state Exp;
branches;
next	;

11.11.6.1
date	2004.02.12.19.40.44;	author erikg;	state Exp;
branches;
next	11.11.6.2;

11.11.6.2
date	2004.03.15.14.06.06;	author erikg;	state Exp;
branches;
next	;


desc
@Code to handle creation of regions
@


11.15
log
@moved to src/comgeom-g
@
text
@/*
 *			R E G I O N . C
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/comgeom-g/region.c,v 11.14 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "wdb.h"

/* defined in read.c */
extern int getline(register char *cp, int buflen, char *title);
extern int getint(char *cp, int start, int len);
extern void namecvt(register int n, register char *cp, int c);

/* defined in cvt.c */
extern void col_pr(char *str);

extern char	name_it[];

extern struct wmember	*wmp;	/* array indexed by region number */

extern FILE		*infp;
extern struct rt_wdb	*outfp;

extern int	reg_total;
extern int	version;
extern int	verbose;

char	rcard[128];

void	region_register(int reg_num, int id, int air, int mat, int los);
void	group_init(void);
void	group_register(char *name, int lo, int hi);
void	group_add(register int val, char *name);
void	group_write(void);

/*
 *			G E T R E G I O N
 *
 *  Use wmp[region_number] as head for each region.
 *
 *  Returns -
 *	-1	error
 *	 0	done
 */
int
getregion(void)
{
	int i, j;
	int card;
	int	op;
	int	reg_reg_flag;
	int	reg_num;
	char	*inst_name=NULL;
	int	inst_num;
	char *cp;

	reg_num = 0;		/* safety */

	/* Pre-load very first region card */
	if( getline( rcard, sizeof(rcard), "region card" ) == EOF )  {
		printf("getregion: premature EOF\n");
		return( -1 );
	}
	if( getint( rcard, 0, 5 ) != 1 )  {
		printf("First region card not #1\ncard='%s'\n", rcard);
		return(-1);
	}

top:
	reg_reg_flag = 0;

	for( card=0; ; card++ )  {
		if( card == 0 )  {
			/* First card is already in input buffer */
			reg_num = getint( rcard, 0, 5 );

			/* -1 region number terminates table */
			if( reg_num < 0 ) 
				return( 0 );		/* Done */

			if( reg_num > reg_total )  {
				printf("%d regions is more than claimed %d\n",
					reg_num, reg_total );
				return(-1);
			}

			namecvt( reg_num, &(wmp[reg_num].wm_name), 'r' );
		} else {
			if( getline( rcard, sizeof(rcard), "region card" ) == EOF )  {
				printf("getregion: premature EOF\n");
				return( -1 );
			}
			if( strcmp( rcard, "  end" ) == 0 ||
			    strcmp( rcard, "  END" ) == 0 )  {
			    	/* Version 1, DoE/MORSE */
			    	reg_total = reg_num;
			    	return(0);	/* done */
			}
			if( getint( rcard, 0, 5 ) != 0 )  {
				/* finished with this region */
				break;
			}
		}

		if( version == 1 )  {
			cp = rcard + 10;
		} else {
			cp = rcard + 6;
		}

		op = WMOP_UNION; /* default */

		/* Scan each of the 9 fields on the card */
		for( i=0; i<9; i++, cp += 7 )  {
			char	nbuf[32];
			char	*np;

			/* Remove all spaces from the number */
			np = nbuf;
			for( j=2; j<7; j++ )  {
				if( !isascii( cp[j] ) ) *np++ = '?';
				else if( isspace( cp[j] ) )  continue;
				*np++ = cp[j];
			}
			*np = '\0';

			/* Check for null field -- they are to be skipped */
			if( (inst_num = atoi(nbuf)) == 0 )  {
				/* zeros are allowed as placeholders */
				continue;
			}

			if( version == 5 )  {
				/* Region references region in Gift5 */
				if( cp[1] == 'g' || cp[1] == 'G' ) {
					reg_reg_flag = 1;
				} else if( cp[1] == 'R' || cp[1] == 'r' )  {
					/* 'OR' */
					op = WMOP_UNION;
				} else {
					if( inst_num < 0 )  {
						op = WMOP_SUBTRACT;
						inst_num = -inst_num;
					}  else  {
						op = WMOP_INTERSECT;
					}
				}
			} else {
				/* XXX this may actually be an old piece of code,
				 * rather than the V4 way of doing it. */
				if( cp[1] != ' ' )  {
					op = WMOP_UNION;
				}  else  {
					if( inst_num < 0 )  {
						op = WMOP_SUBTRACT;
						inst_num = -inst_num;
					}  else  {
						op = WMOP_INTERSECT;
					}
				}
			}

			/* In Gift5, regions can reference regions */
			if( reg_reg_flag )
				namecvt(inst_num, &inst_name, 'r');
			else
				namecvt( inst_num, &inst_name, 's' );
			reg_reg_flag = 0;

			(void)mk_addmember( inst_name, &wmp[reg_num].l, NULL, op );
			bu_free( inst_name, "inst_name" );
		}
	}

	if(verbose) col_pr( wmp[reg_num].wm_name );

	/* The region will be output later in getid(), below */

	goto top;
}

/*
 *			G E T I D
 *
 * Load the region ID information into the structures
 */
void
getid(void)
{
	int reg_num;
	int id;
	int air;
	int mat= -1;
	int los= -2;
	char	idcard[132];

	while(1)  {
		if( getline( idcard, sizeof(idcard), "region ident card" ) == EOF )  {
			printf("\ngetid:  EOF\n");
			return;
		}
		if( idcard[0] == '\n' )
			return;

		if( version == 5 )  {
			reg_num = getint( idcard, 0, 5 );
			id =	getint( idcard, 5, 5 );
			air =	getint( idcard, 10, 5 );
			mat =	getint( idcard, 15, 5 );
			los =	getint( idcard, 20, 5 );
		} else {
			reg_num = getint( idcard, 0, 10 );
			id =	getint( idcard, 10, 10 );
			air =	getint( idcard, 20, 10 );
			mat =	getint( idcard, 74, 3 );
			los =	getint( idcard, 77, 3 );
		}

		if( reg_num <= 0 )  {
			printf("\ngetid:  region_id %d encountered, stoping\n", reg_num);
			return;
		}

		region_register( reg_num, id, air, mat, los );
	}
}

/*
 *			R E G I O N _ R E G I S T E R
 */
void
region_register(int reg_num, int id, int air, int mat, int los)
{
	register struct wmember	*wp;

	wp = &wmp[reg_num];
	if( RT_LIST_IS_EMPTY( &wp->l ) )  {
		if( verbose )  {
			char	paren[32];

			/* Denote an empty region */
			sprintf( paren, "(%s)", wp->wm_name );
			col_pr( paren );
		}
		return;
	}
	mk_lrcomb( outfp, wp->wm_name, wp, 1,
		"", "", (unsigned char *)0, id, air, mat, los, 0 );
		/* Add region to the one group that it belongs to. */
	group_add( id, wp->wm_name );

	if(verbose) col_pr( wp->wm_name );
}

#define NGROUPS	21
struct groups {
	struct wmember	grp_wm;
	int		grp_lo;
	int		grp_hi;
} groups[NGROUPS];
int	ngroups;

void
group_init(void)
{
	group_register( "g00", 0, 0 );
	group_register( "g0", 1, 99 );
	group_register( "g1", 100, 199);
	group_register( "g2", 200, 299 );
	group_register( "g3", 300, 399 );
	group_register( "g4", 400, 499 );
	group_register( "g5", 500, 599 );
	group_register( "g6", 600, 699 );
	group_register( "g7", 700, 799 );
	group_register( "g8", 800, 899 );
	group_register( "g9", 900, 999 );
	group_register( "g10", 1000, 1999 );
	group_register( "g11", 2000, 2999 );
	group_register( "g12", 3000, 3999 );
	group_register( "g13", 4000, 4999 );
	group_register( "g14", 5000, 5999 );
	group_register( "g15", 6000, 6999 );
	group_register( "g16", 7000, 7999 );
	group_register( "g17", 8000, 8999 );
	group_register( "g18", 9000, 9999 );
	group_register( "g19", 10000, 32767 );

}

void
group_register(char *name, int lo, int hi)
{
	char	nbuf[32];
	register struct wmember	*wp;

	if( ngroups >= NGROUPS )  {
		printf("Too many groups, ABORTING\n");
		exit(13);
	}
	wp = &groups[ngroups].grp_wm;

	sprintf( nbuf, "%s%s", name, name_it );
	wp->wm_name = bu_strdup( nbuf );

	RT_LIST_INIT( &wp->l );

	groups[ngroups].grp_lo = lo;
	groups[ngroups].grp_hi = hi;
	ngroups++;
}

void
group_add(register int val, char *name)
{
	register int	i;

	for( i=ngroups-1; i>=0; i-- )  {
		if( val < groups[i].grp_lo )  continue;
		if( val > groups[i].grp_hi )  continue;
		goto add;
	}
	printf("Unable to find group for value %d\n", val);
	i = 0;

add:
	(void)mk_addmember( name, &groups[i].grp_wm.l, NULL, WMOP_UNION );
}

void
group_write(void)
{
	register struct wmember	*wp;
	struct wmember		allhead;
	register int	i;

	RT_LIST_INIT( &allhead.l );

	for( i=0; i < ngroups; i++ )  {
		wp = &groups[i].grp_wm;
		/* Skip empty groups */
		if( RT_LIST_IS_EMPTY( &wp->l ) )  continue;

		/* Make a non-region combination */
		mk_lfcomb( outfp, wp->wm_name, wp, 0 );

		/* Add it to "all.g" */
		(void)mk_addmember( wp->wm_name, &allhead.l, NULL, WMOP_UNION );

		if(verbose) col_pr( wp->wm_name );
	}
	/* Make all-encompasing "all.g" group here */
	mk_lfcomb( outfp, "all.g", &allhead, 0 );
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/comgeom-g/region.c,v 11.13 2004/04/05 07:49:45 morrison Exp $ (BRL)";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d19 5
a23 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.11 2003/01/31 16:11:34 jra Exp $ (BRL)";
d36 3
a38 3
extern int getline();
extern int getint();
extern void namecvt();
d41 1
a41 1
extern void col_pr();
d56 5
a60 5
void	region_register();
void	group_init();
void	group_register();
void	group_add();
void	group_write();
d72 1
a72 1
getregion()
d214 1
a214 1
getid()
d258 1
a258 1
region_register( reg_num, id, air, mat, los )
d290 1
a290 1
group_init()
d317 1
a317 2
group_register( name, lo, hi )
char	*name;
d339 1
a339 3
group_add( val, name )
register int	val;
char		*name;
d356 1
a356 1
group_write()
@


11.11
log
@Mods to handle long names
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1989 by the United States Army.
d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.10 2002/08/20 17:07:20 jra Exp $ (BRL)";
@


11.11.6.1
log
@merge from HEAD
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.12 2004/02/02 17:38:59 morrison Exp $ (BRL)";
@


11.11.6.2
log
@merge from head
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.11.6.1 2004/02/12 19:40:44 erikg Exp $ (BRL)";
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.8 2002/05/28 19:10:25 morrison Exp $ (BRL)";
d79 1
a79 1
	char	inst_name[32];
d113 1
a113 1
			namecvt( reg_num, wmp[reg_num].wm_name, 'r' );
d191 1
a191 1
				namecvt(inst_num, inst_name, 'r');
d193 1
a193 1
				namecvt( inst_num, inst_name, 's' );
d197 1
a261 4
#if 0
printf("reg_num=%d,id=%d,air=%d,mat=%d,los=%d\n", reg_num,id,air,mat,los);
#endif

a272 1

d330 1
a330 1
	strncpy( wp->wm_name, nbuf, sizeof(wp->wm_name) );
@


11.10.4.1
log
@sync to HEAD...
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/comgeom-g/region.c,v 11.12 2004/02/02 17:38:59 morrison Exp $ (BRL)";
d79 1
a79 1
	char	*inst_name=NULL;
d113 1
a113 1
			namecvt( reg_num, &(wmp[reg_num].wm_name), 'r' );
d191 1
a191 1
				namecvt(inst_num, &inst_name, 'r');
d193 1
a193 1
				namecvt( inst_num, &inst_name, 's' );
a196 1
			bu_free( inst_name, "inst_name" );
d261 4
d276 1
d334 1
a334 1
	wp->wm_name = bu_strdup( nbuf );
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.10 2002/08/20 17:07:20 jra Exp $ (BRL)";
d36 3
a38 3
extern int getline(register char *cp, int buflen, char *title);
extern int getint(char *cp, int start, int len);
extern void namecvt(register int n, register char *cp, int c);
d41 1
a41 1
extern void col_pr(char *str);
d56 5
a60 5
void	region_register(int reg_num, int id, int air, int mat, int los);
void	group_init(void);
void	group_register(char *name, int lo, int hi);
void	group_add(register int val, char *name);
void	group_write(void);
d72 1
a72 1
getregion(void)
d213 1
a213 1
getid(void)
d257 1
a257 1
region_register(int reg_num, int id, int air, int mat, int los)
d294 1
a294 1
group_init(void)
d321 2
a322 1
group_register(char *name, int lo, int hi)
d344 3
a346 1
group_add(register int val, char *name)
d363 1
a363 1
group_write(void)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d79 1
a79 1
	char	*inst_name=NULL;
d113 1
a113 1
			namecvt( reg_num, &(wmp[reg_num].wm_name), 'r' );
d191 1
a191 1
				namecvt(inst_num, &inst_name, 'r');
d193 1
a193 1
				namecvt( inst_num, &inst_name, 's' );
a196 1
			bu_free( inst_name, "inst_name" );
d261 4
d276 1
d333 1
a333 1
	wp->wm_name = bu_strdup( nbuf );
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d36 3
a38 3
extern int getline(register char *cp, int buflen, char *title);
extern int getint(char *cp, int start, int len);
extern void namecvt(register int n, register char *cp, int c);
d41 1
a41 1
extern void col_pr(char *str);
d56 5
a60 5
void	region_register(int reg_num, int id, int air, int mat, int los);
void	group_init(void);
void	group_register(char *name, int lo, int hi);
void	group_add(register int val, char *name);
void	group_write(void);
d72 1
a72 1
getregion(void)
d213 1
a213 1
getid(void)
d257 1
a257 1
region_register(int reg_num, int id, int air, int mat, int los)
d294 1
a294 1
group_init(void)
d321 2
a322 1
group_register(char *name, int lo, int hi)
d344 3
a346 1
group_add(register int val, char *name)
d363 1
a363 1
group_write(void)
@


11.8
log
@missed the mk_addmember commit for this file
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.7 2001/11/20 13:52:33 jra Exp $ (BRL)";
d36 3
a38 3
extern int getline();
extern int getint();
extern void namecvt();
d41 1
a41 1
extern void col_pr();
d56 5
a60 5
void	region_register();
void	group_init();
void	group_register();
void	group_add();
void	group_write();
d72 1
a72 1
getregion()
d213 1
a213 1
getid()
d257 1
a257 1
region_register( reg_num, id, air, mat, los )
d294 1
a294 1
group_init()
d321 1
a321 2
group_register( name, lo, hi )
char	*name;
d343 1
a343 3
group_add( val, name )
register int	val;
char		*name;
d360 1
a360 1
group_write()
@


11.7
log
@Corrected call to mk_lrcomb()
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.6 2001/05/16 21:37:11 morrison Exp $ (BRL)";
d196 1
a196 1
			(void)mk_addmember( inst_name, &wmp[reg_num].l, op );
d359 1
a359 1
	(void)mk_addmember( name, &groups[i].grp_wm.l, WMOP_UNION );
d380 1
a380 1
		(void)mk_addmember( wp->wm_name, &allhead.l, WMOP_UNION );
@


11.6
log
@PRODUCTION optimizations
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.5 2001/04/12 14:40:20 bparker Exp $ (BRL)";
d277 1
a277 1
	mk_lrcomb( outfp, wp->wm_name, wp, reg_num,
@


11.5
log
@*- provide extern declarations for functions
   that need them
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.4 2000/08/24 04:56:48 mike Exp $ (BRL)";
d136 2
@


11.4
log
@
mk_addmember
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.3 2000/07/20 18:36:36 mike Exp $ (BRL)";
d34 8
@


11.3
log
@
Some lint.  New libwdb conversion
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.2 2000/07/10 23:50:09 mike Exp $ (BRL)";
d186 1
a186 1
			(void)mk_addmember( inst_name, &wmp[reg_num], op );
d349 1
a349 1
	(void)mk_addmember( name, &groups[i].grp_wm, WMOP_UNION );
d370 1
a370 1
		(void)mk_addmember( wp->wm_name, &allhead, WMOP_UNION );
@


11.2
log
@
lint
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/region.c,v 11.1 1995/01/04 10:06:52 mike Rel4_4 $ (BRL)";
d22 5
d39 2
a40 2
extern FILE	*infp;
extern FILE	*outfp;
@


11.1
log
@Release_4.4
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 10.4 94/10/21 20:09:49 mike Exp $ (BRL)";
d27 1
a27 1
#include "rtlist.h"
d58 1
@


10.4
log
@rgb is unsigned char
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 10.3 94/08/23 18:53:35 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@Put includes in proper order
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 10.2 1994/08/09 19:08:37 gdurf Exp gdurf $ (BRL)";
d262 1
a262 1
		"", "", (char *)0, id, air, mat, los, 0 );
@


10.2
log
@Added include of conf.g
conf.h, that is
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 10.1 1991/10/12 06:44:49 mike Rel4_0 gdurf $ (BRL)";
d24 1
a25 1
#include "machine.h"
@


10.1
log
@Release_4.0
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 1.16 90/12/05 19:24:48 mike Exp $ (BRL)";
d18 2
@


1.16
log
@Added ultimate top-level group "all.g".
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 1.15 90/12/05 05:59:45 mike Exp $ (BRL)";
@


1.15
log
@lint
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 1.14 90/12/04 23:15:59 mike Exp $ (BRL)";
d348 1
d351 2
d361 3
d366 2
a367 1
	/* Could make all-encompasing "all.g" group here */
@


1.14
log
@mk_addmember() has an "op" arg now!
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 1.13 90/10/16 21:07:44 mike Exp $ (BRL)";
d41 6
d235 4
d275 1
d302 1
d325 1
d344 1
@


1.13
log
@Converted to new linked lists and rtlist.h
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/region.c,v 1.12 90/02/27 20:11:04 mike Exp $ (BRL)";
a116 1
			struct wmember	*membp;
d172 1
a172 2
			membp = mk_addmember( inst_name, &wmp[reg_num] );
			membp->wm_op = op;
d328 1
a328 1
	(void)mk_addmember( name, &groups[i].grp_wm );
@


1.12
log
@Cleaned up some lint
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: region.c,v 1.11 90/02/10 02:35:09 mike Locked $ (BRL)";
d25 1
d240 1
a240 1
	if( wp->wm_forw == wp )  {
d308 1
a308 1
	wp->wm_forw = wp->wm_back = wp;
d341 1
a341 1
		if( wp->wm_forw == wp )  continue;
@


1.11
log
@Added code to support version 1 files.
Eliminated rcard structure;  now everything is handled more neatly.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: region.c,v 1.10 89/12/29 22:40:58 mike Locked $ (BRL)";
d22 1
d189 1
a191 1
	register int	i;
a196 2
	char buff[11];
	int	buflen;
d202 1
a202 1
			return(0);
d205 1
a205 1
			return( 0 );
d223 1
a223 1
			return(0);
@


1.10
log
@Added header.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d37 1
a37 11
struct rcard  {
	char	rc_num[5];
	char	rc_null;
	struct	rcfields  {
		char	rcf_null;
		char	rcf_or;
		char	rcf_solid[5];
	}  
	rc_fields[9];
	char	rc_remark[11+3+100];
} rcard;
d43 4
d53 1
a53 1
	int reg_reg_flag;
d62 1
a62 1
	if( getline( &rcard, sizeof(rcard), "region card" ) == EOF )  {
d66 2
a67 2
	if( getint( &rcard, 0, 5 ) != 1 )  {
		printf("First region card not #1\ncard='%s'\n", &rcard);
d77 1
a77 1
			reg_num = getint( &rcard, 0, 5 );
d91 1
a91 1
			if( getline( &rcard, sizeof(rcard), "region card" ) == EOF )  {
d95 7
a101 1
			if( getint( &rcard, 0, 5 ) != 0 )  {
d107 5
a111 1
		cp = (char *) rcard.rc_fields;
d114 1
a114 1
		for( i=0; i<9; i++ )  {
d116 2
d119 6
a124 13
			cp[7] = 0;	/* clobber succeeding 'O' pos */

			/* check for "-    5" field which atoi will
			 *	return a zero
			 */
			if(cp[2] == '-' || cp[2] == '+') {
				/* remove any followin blanks */
				for(j=3; j<6; j++) {
					if(cp[j] == ' ') {
						cp[j] = cp[j-1];
						cp[j-1] = ' ';
					}
				}
d126 1
a127 2
			inst_num = atoi( cp+2 );

d129 3
a131 3
			if( inst_num == 0 )  {
				cp += 7;
				continue;	/* zeros are allowed as placeholders */
d136 1
a136 2
				if(rcard.rc_fields[i].rcf_or == 'g' ||
				   rcard.rc_fields[i].rcf_or == 'G')
d138 2
a139 2

				if( cp[1] == 'R' || cp[1] == 'r' ) 
d141 1
a141 1
				else {
a172 2

			cp += 7;
a197 1
	register struct wmember	*wp;
d226 9
d239 3
a241 2
		wp = &wmp[reg_num];
		if( wp->wm_forw == wp )  {
d243 1
a243 1
			if( !verbose)  continue;
a246 1
			continue;
d248 2
d251 2
a252 3
		mk_lrcomb( outfp, wp->wm_name, wp, reg_num,
			"", "", (char *)0, id, air, mat, los, 0 );

d254 1
a254 1
		group_add( id, wp->wm_name );
d256 1
a256 2
		if(verbose) col_pr( wp->wm_name );
	}
@


1.9
log
@Added some sanity checking.
Honored verbose flag
@
text
@d3 11
d15 4
@


1.8
log
@Added check to see if running off end of array.
@
text
@d20 1
d50 2
d57 4
d68 1
a68 2
			rcard.rc_null = 0;	/* Null terminate rc_num */
			reg_num = atoi( rcard.rc_num );
d86 1
a86 2
			rcard.rc_null = 0;	/* Null terminate rc_num */
			if( atoi( rcard.rc_num ) != 0 )  {
d166 1
a166 1
	col_pr( wmp[reg_num].wm_name );
d224 1
d237 1
a237 1
		col_pr( wp->wm_name );
d328 1
a328 1
		col_pr( wp->wm_name );
@


1.7
log
@The groups should be non-region combinations.
@
text
@d68 6
@


1.6
log
@Stop reading region ids when they hit zero or negative.
@
text
@d313 2
a314 1
		mk_lfcomb( outfp, wp->wm_name, wp, -1 );
@


1.5
log
@Allowed a little extra space for comments on end of region card
@
text
@d201 5
@


1.4
log
@moved getint into read.c
@
text
@d30 1
a30 1
	char	rc_remark[11+3];
@


1.3
log
@changed getcard() to have extra args
@
text
@a313 15

int
getint( cp, start, len )
char	*cp;
int	start;
int	len;
{
	char	buf[128];

	if( len >= sizeof(buf) )  len = sizeof(buf)-1;

	strncpy( buf, cp+start, len );
	buf[len] = '\0';
	return atoi(buf);	
}
@


1.2
log
@This version works nicely
Fast, too
@
text
@d50 1
a50 1
	if( getline( &rcard ) == EOF )  {
d70 1
a70 1
			if( getline( &rcard ) == EOF )  {
a161 21
struct idcard  {
	char	id_foo[80];
#if 0
#ifdef GIFT5
	char	id_region[5];
	char	id_rid[5];
	char	id_air[5];
	char	id_mat[5];
	char	id_los[5];
	char	id_waste[55];
#else
	char	id_region[10];
	char	id_rid[10];
	char	id_air[10];
	char	id_waste[44];
	char	id_mat[3];	/* use any existing material code */
	char	id_los[3];	/* use any existing los percentage */
#endif
#endif
} idcard;

d178 1
d181 1
a181 1
		if( getline( (char *) &idcard ) == EOF )  {
d185 1
a185 1
		if( ((char *) &idcard)[0] == '\n' )
d189 5
a193 5
			reg_num = getint( &idcard, 0, 5 );
			id =	getint( &idcard, 5, 5 );
			air =	getint( &idcard, 10, 5 );
			mat =	getint( &idcard, 15, 5 );
			los =	getint( &idcard, 20, 5 );
d195 5
a199 5
			reg_num = getint( &idcard, 0, 10 );
			id =	getint( &idcard, 10, 10 );
			air =	getint( &idcard, 20, 10 );
			mat =	getint( &idcard, 74, 3 );
			los =	getint( &idcard, 77, 3 );
@


1.1
log
@Initial revision
@
text
@a149 1
col_pr( inst_name);
d200 7
a206 3
	if( getline( (char *) &idcard ) == EOF ||
	    ((char *) &idcard)[0] == '\n' )
		return( 0 );
d208 14
a221 8
	/* XXX needs to handle blanked out fields */
	if( version == 5 )  {
		sscanf( &idcard, "%5d%5d%5d%5d%5d",
			&reg_num, &id, &air, &mat, &los );
	} else {
		sscanf( &idcard, "%10d%10d%10d%*44s%3d%3d",
			&reg_num, &id, &air, &mat, &los );
	}
d223 1
d225 8
a232 6
#if 0
	if( version == 5 )
		buflen = 5;
	else
		buflen = 10;
	buff[buflen] = '\0';
d234 2
a235 3
	for(i=0; i<buflen; i++)
		buff[i] = idcard.id_region[i];
	reg_num = atoi( buff );
d237 2
a238 3
	for(i=0; i<buflen; i++)
		buff[i] = idcard.id_rid[i];
	id = atoi( buff );
d240 1
a240 20
	for(i=0; i<buflen; i++)
		buff[i] = idcard.id_air[i];
	air = atoi( buff );

	if( version == 5 )  {
		for(i=0; i<5; i++)
			buff[i] = idcard.id_mat[i];
		mat = atoi( buff );

		for(i=0; i<5; i++)
			buff[i] = idcard.id_los[i];
		los = atoi( buff );
	} else {
		idcard.id_mat[2] = '\0';
		mat = atoi( idcard.id_mat );

		for( i=0; i<3; i++ )
			buff[i] = idcard.id_los[i];
		buff[3] = '\0';
		los = atoi( buff );
a241 15
#endif

	wp = &wmp[reg_num];
	if( wp->wm_forw == wp )  {
		printf("Region %s is empty\n", wp->wm_name );
		return(1);	/* empty region */
	}

	mk_lrcomb( outfp, wp->wm_name, wp, reg_num,
		"", "", (char *)0, id, air, mat, los, 0 );

	/* Add region to the one group that it belongs to. */
	group_add( id, wp->wm_name );

	return( 1 );
d333 15
@
