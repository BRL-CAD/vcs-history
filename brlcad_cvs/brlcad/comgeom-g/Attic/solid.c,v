head	11.14;
access;
symbols
	ansi-20040405-merged:11.9.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.6.2
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.9.2.1
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.9.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.6
	phong-branch:11.10.0.4
	photonmap-branch:11.10.0.2
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.3
	offsite-5-3-pre:11.6
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.24.04.16.29;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.07.49.45;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.38.59;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2003.01.31.16.11.34;	author jra;	state Exp;
branches
	11.10.6.1;
next	11.9;

11.9
date	2002.08.20.17.07.20;	author jra;	state Exp;
branches
	11.9.2.1
	11.9.4.1;
next	11.8;

11.8
date	2002.08.15.20.54.32;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.12.14.40.20;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.25.18.43.18;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.20.18.36.37;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.10.23.50.09;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.07.15.18.35.39;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.12.04.15.00.56;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.52;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.12.08.16.02.33;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.10.20.00.12.54;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.23.18.54.16;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.09.19.08.48;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.02.14.15.39.36;	author mmark;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.50;	author mike;	state Rel4_0;
branches;
next	1.36;

1.36
date	91.08.25.05.57.59;	author butler;	state Exp;
branches;
next	1.35;

1.35
date	91.07.17.21.04.11;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	91.07.16.00.28.36;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	91.07.02.03.32.58;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	91.07.02.03.11.13;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	91.06.23.00.40.31;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	91.06.13.03.03.20;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	91.02.07.00.50.33;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	90.12.07.01.22.42;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	90.12.04.23.25.02;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	90.10.17.23.58.40;	author sue;	state Exp;
branches;
next	1.25;

1.25
date	90.02.27.20.11.09;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	90.02.10.02.33.42;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	89.12.29.22.39.08;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	89.12.09.01.56.42;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	89.12.08.06.05.31;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	89.11.30.03.46.36;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	89.11.30.03.41.19;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	89.11.30.03.01.23;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	89.11.30.02.30.52;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	89.11.30.02.13.09;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	89.11.30.00.53.29;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	89.11.29.23.56.16;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	89.11.29.22.28.48;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	89.11.28.02.53.31;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	89.11.28.01.40.28;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	89.11.28.00.10.38;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	89.11.27.23.55.41;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	89.11.27.23.31.45;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	89.11.03.04.34.49;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.11.03.04.22.12;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.11.03.03.44.50;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.11.03.01.25.49;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.11.02.23.07.34;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.10.31.17.39.56;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.31.15.19.21;	author mike;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.00.34;	author morrison;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.17.21.15.53;	author morrison;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.11.23.40.28;	author morrison;	state Exp;
branches;
next	;

11.10.6.1
date	2004.02.12.19.40.44;	author erikg;	state Exp;
branches;
next	11.10.6.2;

11.10.6.2
date	2004.03.15.14.06.06;	author erikg;	state Exp;
branches;
next	;


desc
@convert.c
@


11.14
log
@moved to src/comgeom-g
@
text
@/*
 *			S O L I D . C
 *
 *  Subroutine to convert solids from
 *  COMGEOM card decks into GED object files.  This conversion routine
 *  is used to translate between COMGEOM solids, and the
 *  more general GED solids.
 *
 *  Authors -
 *	Michael John Muuss
 *	Susanne L. Muuss, J.D.
 *
 *  Original Version -
 *	March, 1980
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/comgeom-g/solid.c,v 11.13 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "rtlist.h"
#include "raytrace.h"
#include "wdb.h"

/* defined in read.c */
extern int getline(register char *cp, int buflen, char *title);
extern int getint(char *cp, int start, int len);
extern void namecvt(register int n, register char *cp, int c);

/* defined in cvt.c */
extern void col_pr(char *str);

/* defined in solid.c */
extern int read_arbn(char *name);

extern struct rt_wdb	*outfp;
extern int	version;
extern int	verbose;

extern double	getdouble(char *cp, int start, int len);
extern int	sol_total, sol_work;

char	scard[132];			/* Solid card buffer area */

void	trim_trail_spaces(register char *cp);
void	eat(int count);

/*
 *			G E T S O L D A T A
 *
 *  Obtain 'num' data items from input card(s).
 *  The first input card is already in global 'scard'.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
getsoldata(double *dp, int num, int solid_num)
{
	int	cd;
	double	*fp;
	int	i;
	int	j;

	fp = dp;
	for( cd=1; num > 0; cd++ )  {
		if( cd != 1 )  {
			if( getline( scard, sizeof(scard), "solid continuation card" ) == EOF )  {
				printf("too few cards for solid %d\n",
					solid_num);
				return(-1);
			}
			/* continuation card
			 * solid type should be blank 
			 */
			if( (version==5 && scard[5] != ' ' ) ||
			    (version==4 && scard[3] != ' ' ) )  {
				printf("solid %d (continuation) card %d non-blank\n",
					solid_num, cd);
				return(-1);
			}
		}

		if( num < 6 )
			j = num;
		else
			j = 6;

		for( i=0; i<j; i++ )  {
			*fp++ = getdouble( scard, 10+i*10, 10 );
		}
		num -= j;
	}
	return(0);
}

/*
 *			G E T X S O L D A T A
 *
 *  Obtain 'num' data items from input card(s).
 *  All input cards must be freshly read.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
getxsoldata(double *dp, int num, int solid_num)
{
	int	cd;
	double	*fp;
	int	i;
	int	j;

	fp = dp;
	for( cd=1; num > 0; cd++ )  {
		if( getline( scard, sizeof(scard), "x solid card" ) == EOF )  {
			printf("too few cards for solid %d\n",
				solid_num);
			return(-1);
		}
		if( cd != 1 )  {
			/* continuation card
			 * solid type should be blank 
			 */
			if( (version==5 && scard[5] != ' ' ) ||
			    (version==4 && scard[3] != ' ' ) )  {
				printf("solid %d (continuation) card %d non-blank\n",
					solid_num, cd);
				return(-1);
			}
		}

		if( num < 6 )
			j = num;
		else
			j = 6;

		for( i=0; i<j; i++ )  {
			*fp++ = getdouble( scard, 10+i*10, 10 );
		}
		num -= j;
	}
	return(0);
}

/*
 *			T R I M _ T R A I L _ S P A C E S
 */
void
trim_trail_spaces(register char *cp)
{
	register char	*ep;

	ep = cp + strlen(cp) - 1;
	while( ep >= cp )  {
		if( *ep != ' ' )  break;
		*ep-- = '\0';
	}
}

/*
 *			G E T S O L I D
 *
 *  Returns -
 *	-1	error
 *	 0	conversion OK
 *	 1	EOF
 */
int
getsolid(void)
{
	char	given_solid_num[16];
	char	solid_type[16];
	int	i;
	double	r1, r2;
	vect_t	work;
	double	m1, m2;		/* Magnitude temporaries */
	char	*name=NULL;
	double	dd[4*6];	/* 4 cards of 6 nums each */
	point_t	tmp[8];		/* 8 vectors of 3 nums each */
	int	ret;
#define D(_i)	(&(dd[_i*3]))
#define T(_i)	(&(tmp[_i][0]))

	if( (i = getline( scard, sizeof(scard), "solid card" )) == EOF )  {
		printf("getsolid: unexpected EOF\n");
		return( 1 );
	}

	switch( version )  {
	case 5:
		strncpy( given_solid_num, scard+0, 5 );
		given_solid_num[5] = '\0';
		strncpy( solid_type, scard+5, 5 );
		solid_type[5] = '\0';
		break;
	case 4:
		strncpy( given_solid_num, scard+0, 3 );
		given_solid_num[3] = '\0';
		strncpy( solid_type, scard+3, 7 );
		solid_type[7] = '\0';
		break;
	case 1:
		/* DoE/MORSE version, believed to be original MAGIC format */
		strncpy( given_solid_num, scard+5, 4 );
		given_solid_num[4] = '\0';
		strncpy( solid_type, scard+2, 3 );
		break;
	default:
		fprintf(stderr,"getsolid() version %d unimplemented\n", version);
		exit(1);
		break;
	}
	/* Trim trailing spaces */
	trim_trail_spaces( given_solid_num );
	trim_trail_spaces( solid_type );

	/* another solid - increment solid counter
	 * rather than using number from the card, which may go into
	 * pseudo-hex format in version 4 models (due to 3 column limit).
	 */
	sol_work++;
	if( version == 5 )  {
		if( (i = getint( scard, 0, 5 )) != sol_work )  {
			printf("expected solid card %d, got %d, abort\n",
				sol_work, i );
			return(1);
		}
	}

	/* Reduce solid type to lower case */
	{
		register char	*cp;
		register char	c;

		cp = solid_type;
		while( (c = *cp) != '\0' )  {
			if( !isascii(c) )  {
				*cp++ = '?';
			} else if( isupper(c) )  {
				*cp++ = tolower(c);
			} else {
				cp++;
			}
		}
	}

	namecvt( sol_work, &name, 's' );
	if(verbose) col_pr( name );

	if( strcmp( solid_type, "end" ) == 0 )  {
		/* DoE/MORSE version 1 format */
		bu_free( name, "name" );
		return(1);		/* END */
	}

	if( strcmp( solid_type, "ars" ) == 0 )  {
		int		ncurves;
		int		pts_per_curve;
		double		**curve;

		ncurves = getint( scard, 10, 10 );
		pts_per_curve = getint( scard, 20, 10 );

		/* Allocate curves pointer array */
		if( (curve = (double **)malloc((ncurves+1)*sizeof(double *))) == ((double **)0) )  {
			printf("malloc failure for ARS %d\n", sol_work);
			return(-1);
		}
		/* Allocate space for a curve, and read it in */
		for( i=0; i<ncurves; i++ )  {
			if( (curve[i] = (double *)malloc(
			    (pts_per_curve+1)*3*sizeof(double) )) ==
			    ((double *)0) )  {
				printf("malloc failure for ARS %d curve %d\n",
					sol_work, i);
				return(-1);
			}
			/* Get data for this curve */
			if( getxsoldata( curve[i], pts_per_curve*3, sol_work ) < 0 )  {
				printf("ARS %d: getxsoldata failed, curve %d\n",
					sol_work, i);
				return(-1);
			}
		}
		if( (ret = mk_ars( outfp, name, ncurves, pts_per_curve, curve )) < 0 )  {
			printf("mk_ars(%s) failed\n", name );
			/* Need to free memory; 'ret' is returned below */
		}

		for( i=0; i<ncurves; i++ )  {
			free( (char *)curve[i] );
		}
		free( (char *)curve);
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "rpp" ) == 0 )  {
		double	min[3], max[3];

		if( getsoldata( dd, 2*3, sol_work ) < 0 )
			return(-1);
		VSET( min, dd[0], dd[2], dd[4] );
		VSET( max, dd[1], dd[3], dd[5] );
		ret = mk_rpp( outfp, name, min, max );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "box" ) == 0 )  {
		if( getsoldata( dd, 4*3, sol_work ) < 0 )
			return(-1);
		VMOVE( T(0), D(0) );
		VADD2( T(1), D(0), D(2) );
		VADD3( T(2), D(0), D(2), D(1) );
		VADD2( T(3), D(0), D(1) );

		VADD2( T(4), D(0), D(3) );
		VADD3( T(5), D(0), D(3), D(2) );
		VADD4( T(6), D(0), D(3), D(2), D(1) );
		VADD3( T(7), D(0), D(3), D(1) );
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "raw" ) == 0 ||
	    strcmp( solid_type, "wed" ) == 0		/* DoE name */
	)  {
		if( getsoldata( dd, 4*3, sol_work ) < 0 )
			return(-1);
		VMOVE( T(0), D(0) );
		VADD2( T(1), D(0), D(2) );
		VMOVE( T(2), T(1) );
		VADD2( T(3), D(0), D(1) );

		VADD2( T(4), D(0), D(3) );
		VADD3( T(5), D(0), D(3), D(2) );
		VMOVE( T(6), T(5) );
		VADD3( T(7), D(0), D(3), D(1) );
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "rvw" ) == 0 )  {
		/* Right Vertical Wedge (Origin: DoE/MORSE) */
		double	a2, theta, phi, h2;
		double	a2theta;
		double	angle1, angle2;
		vect_t	a, b, c;

		if( getsoldata( dd, 1*3+4, sol_work ) < 0 )
			return(-1);
		a2 = dd[3];		/* XY side length */
		theta = dd[4];
		phi = dd[5];
		h2 = dd[6];		/* height in +Z */

		angle1 = (phi+theta-90) * rt_degtorad;
		angle2 = (phi+theta) * rt_degtorad;
		a2theta = a2 * tan(theta * rt_degtorad);

		VSET( a, a2theta*cos(angle1), a2theta*sin(angle1), 0 );
		VSET( b, -a2*cos(angle2), -a2*sin(angle2), 0 );
		VSET( c, 0, 0, h2 );
		
		VSUB2( T(0), D(0), b );
		VMOVE( T(1), D(0) );
		VMOVE( T(2), D(0) );
		VADD2( T(3), T(0), a );

		VADD2( T(4), T(0), c );
		VADD2( T(5), T(1), c );
		VMOVE( T(6), T(5) );
		VADD2( T(7), T(3), c );
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "arw" ) == 0) {
		/* ARbitrary Wedge --- ERIM */
		if( getsoldata( dd, 4*3, sol_work ) < 0)
			return(-1);
		VMOVE( T(0), D(0) );
		VADD2( T(1), D(0), D(2) );
		VADD3( T(2), D(0), D(2), D(3) );
		VADD2( T(3), D(0), D(3) );

		VADD2( T(4), D(0), D(1) );
		VMOVE( T(5), T(4) );

		VADD3( T(6), D(0), D(1), D(3) );
		VMOVE( T(7), T(6) );
		ret = mk_arb8( outfp, name, &tmp[0][X]);
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "arb8" ) == 0 )  {
		if( getsoldata( dd, 8*3, sol_work ) < 0 )
			return(-1);
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "arb7" ) == 0 )  {
		if( getsoldata( dd, 7*3, sol_work ) < 0 )
			return(-1);
		VMOVE( D(7), D(4) );
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "arb6" ) == 0 )  {
		if( getsoldata( dd, 6*3, sol_work ) < 0 )
			return(-1);
		/* Note that the ordering is important, as data is in D(4), D(5) */
		VMOVE( D(7), D(5) );
		VMOVE( D(6), D(5) );
		VMOVE( D(5), D(4) );
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "arb5" ) == 0 )  {
		if( getsoldata( dd, 5*3, sol_work ) < 0 )
			return(-1);
		VMOVE( D(5), D(4) );
		VMOVE( D(6), D(4) );
		VMOVE( D(7), D(4) );
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "arb4" ) == 0 )  {
		if( getsoldata( dd, 4*3, sol_work ) < 0 )
			return(-1);
		ret = mk_arb4( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "rcc" ) == 0 )  {
		/* V, H, r */
		if( getsoldata( dd, 2*3+1, sol_work ) < 0 )
			return(-1);
		ret = mk_rcc( outfp, name, D(0), D(1), dd[6] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "rec" ) == 0 )  {
		/* V, H, A, B */
		if( getsoldata( dd, 4*3, sol_work ) < 0 )
			return(-1);
		ret = mk_tgc( outfp, name, D(0), D(1),
			      D(2), D(3), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "trc" ) == 0 )  {
		/* V, H, r1, r2 */
		if( getsoldata( dd, 2*3+2, sol_work ) < 0 )
			return(-1);
		ret = mk_trc_h( outfp, name, D(0), D(1), dd[6], dd[7] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "tec" ) == 0 )  {
		/* V, H, A, B, p */
		if( getsoldata( dd, 4*3+1, sol_work ) < 0 )
			return(-1);
		r1 = 1.0/dd[12];	/* P */
		VSCALE( D(4), D(2), r1 );
		VSCALE( D(5), D(3), r1 );
		ret = mk_tgc( outfp, name, D(0), D(1),
			      D(2), D(3), D(4), D(5) );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "tgc" ) == 0 )  {
		/* V, H, A, B, r1, r2 */
		if( getsoldata( dd, 4*3+2, sol_work ) < 0 )
			return(-1);
		r1 = dd[12] / MAGNITUDE( D(2) );	/* A/|A| * C */
		r2 = dd[13] / MAGNITUDE( D(3) );	/* B/|B| * D */
		VSCALE( D(4), D(2), r1 );
		VSCALE( D(5), D(3), r2 );
		ret = mk_tgc( outfp, name, D(0), D(1),
			D(2), D(3), D(4), D(5) );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "sph" ) == 0 )  {
		/* V, radius */
		if( getsoldata( dd, 1*3+1, sol_work ) < 0 )
			return(-1);
		ret = mk_sph( outfp, name, D(0), dd[3] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strncmp( solid_type, "wir", 3 ) == 0 )  {
		int			numpts;		/* points per wire */
		int			num;
		int			i;
		double			dia;
		double			*pts;		/* 3 entries per pt */
		struct	wdb_pipept	*ps;
		struct	bu_list		head;		/* allow a whole struct for head */

		/* This might be getint( solid_type, 3, 2 ); for non-V5 */
		numpts = getint( scard, 8, 2 );
		num = numpts * 3 + 1;			/* 3 entries per pt */
		
		/* allocate space for the points array */
		if( (pts = ( double *)malloc(num * sizeof( double)) ) == NULL )  {
			printf("malloc failure for WIR %d\n", sol_work);
			return(-1);
		}

		if( getsoldata( pts, num, sol_work ) < 0 )  {
			return(-1);
		}
		dia = pts[num-1] * 2.0;	/* radius X 2.0 == diameter */

		/* allocate nodes on a list and store all information in
		 * the appropriate location.
		 */
		RT_LIST_INIT( &head );
		for( i = 0; i < numpts; i++ )  {
			/* malloc a new structure */
			if( (ps = (struct wdb_pipept *)malloc( 
			 sizeof( struct wdb_pipept)) ) == (struct wdb_pipept *)NULL )  {
			   	printf("malloc failure for WIR %d\n", sol_work);
			   	return(-1);
			 }
			ps->l.magic = WDB_PIPESEG_MAGIC;
			VMOVE( ps->pp_coord, &pts[i*3]);	/* 3 pts at a time */
			ps->pp_id = 0;				/* solid */
			ps->pp_od = dia;
			ps->pp_bendradius = dia;
			RT_LIST_INSERT( &head, &ps->l );
		}

		if( mk_pipe( outfp, name, &head ) < 0 )
			return(-1);
		mk_pipe_free( &head );
		bu_free( name, "name" );
		return(0);		/* OK */
	}

	if( strcmp( solid_type, "rpc" ) == 0 )  {
		/* V, H, B, r */
		if( getsoldata( dd, 3*3+1, sol_work ) < 0 )
			return(-1);
		ret = mk_rpc( outfp, name, D(0), D(1),
			D(2), dd[9] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "rhc" ) == 0 )  {
		/* V, H, B, r, c */
		if( getsoldata( dd, 3*3+2, sol_work ) < 0 )
			return(-1);
		ret = mk_rhc( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "epa" ) == 0 )  {
		/* V, H, Au, r1, r2 */
		if( getsoldata( dd, 3*3+2, sol_work ) < 0 )
			return(-1);
		ret = mk_epa( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "ehy" ) == 0 )  {
		/* V, H, Au, r1, r2, c */
		if( getsoldata( dd, 3*3+3, sol_work ) < 0 )
			return(-1);
		ret = mk_ehy( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10], dd[11] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "eto" ) == 0 )  {
		/* V, N, C, r, rd */
		if( getsoldata( dd, 3*3+2, sol_work ) < 0 )
			return(-1);
		ret = mk_eto( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
	}

			
	if( version <= 4 && strcmp( solid_type, "ell" ) == 0 )  {
		/* Foci F1, F2, major axis length L */
		vect_t	v;

		/*
		 * For simplicity, we convert ELL to ELL1, then
		 * fall through to ELL1 code.
		 * Format of ELL is F1, F2, len
		 * ELL1 format is V, A, r
		 */
		if( getsoldata( dd, 2*3+1, sol_work ) < 0 )
			return(-1);
		VADD2SCALE( v, D(0), D(1), 0.5 ); /* V is midpoint */

		VSUB2( work, D(1), D(0) );	/* work holds F2 -  F1 */
		m1 = MAGNITUDE( work );
		r2 = 0.5 * dd[6] / m1;
		VSCALE( D(1), work, r2 );	/* A */

		dd[6] = sqrt( MAGSQ( D(1) ) -
			(m1 * 0.5)*(m1 * 0.5) );	/* r */
		VMOVE( D(0), v );
		goto ell1;
	}

	if( (version == 5 && strcmp( solid_type, "ell" ) == 0)  ||
	    strcmp( solid_type, "ell1" ) == 0 )  {
		/* V, A, r */
	    	/* GIFT4 name is "ell1", GIFT5 name is "ell" */
		if( getsoldata( dd, 2*3+1, sol_work ) < 0 )
			return(-1);

ell1:
		r1 = dd[6];		/* R */
		VMOVE( work, D(0) );
		work[0] += rt_pi;
		work[1] += rt_pi;
		work[2] += rt_pi;
		VCROSS( D(2), work, D(1) );
		m1 = r1/MAGNITUDE( D(2) );
		VSCALE( D(2), D(2), m1 );

		VCROSS( D(3), D(1), D(2) );
		m2 = r1/MAGNITUDE( D(3) );
		VSCALE( D(3), D(3), m2 );

		/* Now we have V, A, B, C */
		ret = mk_ell( outfp, name, D(0), D(1), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "ellg" ) == 0 )  {
		/* V, A, B, C */
		if( getsoldata( dd, 4*3, sol_work ) < 0 )
			return(-1);
		ret = mk_ell( outfp, name, D(0), D(1), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "tor" ) == 0 )  {
		/* V, N, r1, r2 */
		if( getsoldata( dd, 2*3+2, sol_work ) < 0 )
			return(-1);
		ret = mk_tor( outfp, name, D(0), D(1), dd[6], dd[7] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "haf" ) == 0 )  {
		/* N, d */
		if( getsoldata( dd, 1*3+1, sol_work ) < 0 )
			return(-1);
		ret = mk_half( outfp, name, D(0), -dd[3] );
		bu_free( name, "name" );
		return(ret);
	}

	if( strcmp( solid_type, "arbn" ) == 0 )  {
		ret = read_arbn( name );
		bu_free( name, "name" );
	}

	/*
	 *  The solid type string is defective,
	 *  or that solid is not currently supported.
	 */
	printf("getsolid:  no support for solid type '%s'\n", solid_type );
	return(-1);
}

int
read_arbn(char *name)
{
	int	npt;			/* # vertex pts to be read in */
	int	npe;			/* # planes from 3 vertex points */
	int	neq;			/* # planes from equation */
	int	nae;			/* # planes from az,el & vertex index */
	int	nface;			/* total number of faces */
	double	*input_points = (double *)0;
	double	*vertex = (double *)0;	/* vertex list of final solid */
	int	last_vertex;		/* index of first unused vertex */
	int	max_vertex;		/* size of vertex array */
	int	*used = (int *)0;	/* plane eqn use count */
	plane_t	*eqn = (plane_t *)0;	/* plane equations */
	int	cur_eq = 0;		/* current (free) equation number */
	int	symm = 0;		/* symmetry about Y used */
	register int	i;
	int	j;
	int	k;
	register int	m;
	point_t	cent;			/* centroid of arbn */
	struct rt_tol	tol;

	/* XXX The tolerance here is sheer guesswork */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	npt = getint( scard, 10+0*10, 10 );
	npe = getint( scard, 10+1*10, 10 );
	neq = getint( scard, 10+2*10, 10 );
	nae = getint( scard, 10+3*10, 10 );

	nface = npe + neq + nae;
	if( npt < 1 )  {
		/* Having one point is necessary to compute centroid */
		printf("arbn defined without at least one point\n");
bad:
		if(npt>0) eat( (npt+1)/2 );	/* vertex input_points */
		if(npe>0) eat( (npe+5)/6 );	/* vertex pt index numbers */
		if(neq>0) eat( neq );		/* plane eqns? */
		if(nae>0) eat( (nae+1)/2 );	/* az el & vertex index? */
		return(-1);
	}

	/* Allocate storage for plane equations */
	if( (eqn = (plane_t *)malloc(nface*sizeof(plane_t))) == (plane_t *)0 )  {
		printf("arbn plane equation malloc failure\n");
		goto bad;
	}
	/* Allocate storage for per-plane use count */
	if( (used = (int *)malloc(nface*sizeof(int))) == (int *)0 )  {
		printf("arbn use count malloc failure\n");
		goto bad;
	}

	if( npt >= 1 )  {
		/* Obtain vertex input_points */
		if( (input_points = (double *)malloc(npt*3*sizeof(double))) == (double *)0 )  {
			printf("arbn point malloc failure\n");
			goto bad;
		}
		if( getxsoldata( input_points, npt*3, sol_work ) < 0 )
			goto bad;
	}

	/* Get planes defined by three points, 6 per card */
	for( i=0; i<npe; i += 6 )  {
		if( getline( scard, sizeof(scard), "arbn vertex point indices" ) == EOF )  {
			printf("too few cards for arbn %d\n",
				sol_work);
			return(-1);
		}
		for( j=0; j<6; j++ )  {
			int	q,r,s;
			point_t	a,b,c;

			q = getint( scard, 10+j*10+0, 4 );
			r = getint( scard, 10+j*10+4, 3 );
			s = getint( scard, 10+j*10+7, 3 );

			if( q == 0 || r == 0 || s == 0 ) continue;

			if( q < 0 )  {
				VMOVE( a, &input_points[((-q)-1)*3] );
				a[Y] = -a[Y];
				symm = 1;
			} else {
				VMOVE( a, &input_points[((q)-1)*3] );
			}

			if( r < 0 )  {
				VMOVE( b, &input_points[((-r)-1)*3] );
				b[Y] = -b[Y];
				symm = 1;
			} else {
				VMOVE( b, &input_points[((r)-1)*3] );
			}

			if( s < 0 )  {
				VMOVE( c, &input_points[((-s)-1)*3] );
				c[Y] = -c[Y];
				symm = 1;
			} else {
				VMOVE( c, &input_points[((s)-1)*3] );
			}
			if( rt_mk_plane_3pts( eqn[cur_eq], a,b,c, &tol ) < 0 )  {
				printf("arbn degenerate plane\n");
				VPRINT("a", a);
				VPRINT("b", b);
				VPRINT("c", c);
				continue;
			}
			cur_eq++;
		}
	}

	/* Get planes defined by their equation */
	for( i=0; i < neq; i++ )  {
		register double	scale;
		if( getline( scard, sizeof(scard), "arbn plane equation card" ) == EOF )  {
			printf("too few cards for arbn %d\n",
				sol_work);
			return(-1);
		}
		eqn[cur_eq][0] = getdouble( scard, 10+0*10, 10 );
		eqn[cur_eq][1] = getdouble( scard, 10+1*10, 10 );
		eqn[cur_eq][2] = getdouble( scard, 10+2*10, 10 );
		eqn[cur_eq][3] = getdouble( scard, 10+3*10, 10 );
		scale = MAGNITUDE(eqn[cur_eq]);
		if( scale < SMALL )  {
			printf("arbn plane normal too small\n");
			continue;
		}
		scale = 1/scale;
		VSCALE( eqn[cur_eq], eqn[cur_eq], scale );
		eqn[cur_eq][3] *= scale;
		cur_eq++;
	}

	/* Get planes defined by azimuth, elevation, and pt, 2 per card */
	for( i=0; i < nae;  i += 2 )  {
		if( getline( scard, sizeof(scard), "arbn az/el card" ) == EOF )  {
			printf("too few cards for arbn %d\n",
				sol_work);
			return(-1);
		}
		for( j=0; j<2; j++ )  {
			double	az, el;
			int	vert_no;
			double	cos_el;
			point_t	pt;

			az = getdouble( scard, 10+j*30+0*10, 10 ) * rt_degtorad;
			el = getdouble( scard, 10+j*30+1*10, 10 ) * rt_degtorad;
			vert_no = getint( scard, 10+j*30+2*10, 10 );
			if( vert_no == 0 )  break;
			cos_el = cos(el);
			eqn[cur_eq][X] = cos(az)*cos_el;
			eqn[cur_eq][Y] = sin(az)*cos_el;
			eqn[cur_eq][Z] = sin(el);

			if( vert_no < 0 )  {
				VMOVE( pt, &input_points[((-vert_no)-1)*3] );
				pt[Y] = -pt[Y];
			} else {
				VMOVE( pt, &input_points[((vert_no)-1)*3] );
			}
			eqn[cur_eq][3] = VDOT(pt, eqn[cur_eq]);
			cur_eq++;
		}
	}
	if( nface != cur_eq )  {
		printf("arbn expected %d faces, got %d\n", nface, cur_eq);
		return(-1);
	}

	/* Average all given points together to find centroid */
	/* This is why there must be at least one (two?) point given */
	VSETALL(cent, 0);
	for( i=0; i<npt; i++ )  {
		VADD2( cent, cent, &input_points[i*3] );
	}
	VSCALE( cent, cent, 1.0/npt );
	if( symm )  cent[Y] = 0;

	/* Point normals away from centroid */
	for( i=0; i<nface; i++ )  {
		double	dist;

		dist = VDOT( eqn[i], cent ) - eqn[i][3];
		/* If dist is negative, 'cent' is inside halfspace */
#define DIST_TOL	(1.0e-8)
#define DIST_TOL_SQ	(1.0e-10)
		if( dist < -DIST_TOL )  continue;
		if( dist > DIST_TOL )  {
			/* Flip halfspace over */
			VREVERSE( eqn[i], eqn[i] );
			eqn[i][3] = -eqn[i][3];
		} else {
			/* Centroid lies on this face */
			printf("arbn centroid lies on face\n");
			return(-1);
		}
		
	}

	/* Release storage for input points */
	free( (char *)input_points );
	input_points = (double *)0;


	/*
	 *  ARBN must be convex.  Test for concavity.
	 *  Byproduct is an enumeration of all the verticies.
	 */
	last_vertex = max_vertex = 0;

	/* Zero face use counts */
	for( i=0; i<nface; i++ )  {
		used[i] = 0;
	}
	for( i=0; i<nface-2; i++ )  {
		for( j=i+1; j<nface-1; j++ )  {
			double	dot;
			int	point_count;	/* # points on this line */

			/* If normals are parallel, no intersection */
			dot = VDOT( eqn[i], eqn[j] );
			if( !NEAR_ZERO( dot, 0.999999 ) )  continue;

			point_count = 0;
			for( k=j+1; k<nface; k++ )  {
				point_t	pt;

				if( rt_mkpoint_3planes( pt, eqn[i], eqn[j], eqn[k] ) < 0 )  continue;

				/* See if point is outside arb */
				for( m=0; m<nface; m++ )  {
					if( i==m || j==m || k==m )  continue;
					if( VDOT(pt, eqn[m])-eqn[m][3] > DIST_TOL )
						goto next_k;
				}
				/* See if vertex already was found */
				for( m=0; m<last_vertex; m++ )  {
					vect_t	dist;
					VSUB2( dist, pt, &vertex[m*3] );
					if( MAGSQ(dist) < DIST_TOL_SQ )
						goto next_k;
				}

				/*
				 *  Add point to vertex array.
				 *  If more room needed, realloc.
				 */
				if( last_vertex >= max_vertex )  {
					if( max_vertex == 0 )   {
						max_vertex = 3;
						vertex = (double *)malloc( max_vertex*3*sizeof(double) );
					} else {
						max_vertex *= 10;
						vertex = (double *)realloc( (char *)vertex, max_vertex*3*sizeof(double) );
					}
					if( vertex == (double *)0 )  {
						printf("arbn vertex realloc fail\n");
						goto bad;
					}
				}

				VMOVE( &vertex[last_vertex*3], pt );
				last_vertex++;
				point_count++;

				/* Increment "face used" counts */
				used[i]++;
				used[j]++;
				used[k]++;
next_k:				;
			}
			if( point_count > 2 )  {
				printf("arbn: warning, point_count on line=%d\n", point_count);
			}
		}
	}

	/* If any planes were not used, then arbn is not convex */
	for( i=0; i<nface; i++ )  {
		if( used[i] != 0 )  continue;	/* face was used */
		printf("arbn face %d unused, solid is not convex\n", i);
		return(-1);
	}

	/* Write out the solid ! */
	i = mk_arbn( outfp, name, nface, eqn );

	if( input_points )  free( (char *)input_points );
	if( vertex )  free( (char *)vertex );
	if( eqn )  free( (char *)eqn );
	if( used )  free( (char *)used );

	return(i);
}

/*
 *			E A T
 *
 *  Eat the indicated number of input lines
 */
void
eat(int count)
{
	char	lbuf[132];
	int	i;

	for( i=0; i<count; i++ )  {
		(void)getline( lbuf, sizeof(lbuf), "eaten card" );
	}
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/comgeom-g/solid.c,v 11.12 2004/04/05 07:49:45 morrison Exp $ (BRL)";
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d29 5
a33 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.10 2003/01/31 16:11:34 jra Exp $ (BRL)";
d48 3
a50 3
extern int getline();
extern int getint();
extern void namecvt();
d53 1
a53 1
extern void col_pr();
d56 1
a56 1
extern int read_arbn();
d62 1
a62 1
extern double	getdouble();
d67 2
a68 2
void	trim_trail_spaces();
void	eat();
d81 1
a81 4
getsoldata( dp, num, solid_num )
double	*dp;
int	num;
int	solid_num;
d131 1
a131 4
getxsoldata( dp, num, solid_num )
double	*dp;
int	num;
int	solid_num;
d174 1
a174 2
trim_trail_spaces( cp )
register char	*cp;
d194 1
a194 1
getsolid()
d732 1
a732 2
read_arbn( name )
char	*name;
d1042 1
a1042 2
eat( count )
int	count;
@


11.10
log
@Mods to handle long names
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1989 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.9 2002/08/20 17:07:20 jra Exp $ (BRL)";
@


11.10.6.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.11 2004/02/02 17:38:59 morrison Exp $ (BRL)";
@


11.10.6.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.10.6.1 2004/02/12 19:40:44 erikg Exp $ (BRL)";
@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.7 2001/04/12 14:40:20 bparker Exp $ (BRL)";
d209 1
a209 1
	char	name[16+2];
d212 1
d279 1
a279 1
	namecvt( sol_work, name, 's' );
d284 1
a291 1
		int		ret;
d326 1
d337 3
a339 1
		return( mk_rpp( outfp, name, min, max ) );
d354 3
a356 1
		return( mk_arb8( outfp, name, &tmp[0][X] ) );
d373 3
a375 1
		return( mk_arb8( outfp, name, &tmp[0][X] ) );
d409 3
a411 1
		return( mk_arb8( outfp, name, &tmp[0][X] ) );
d428 3
a430 1
		return( mk_arb8( outfp, name, &tmp[0][X]) );
d436 3
a438 1
		return( mk_arb8( outfp, name, dd ) );
d445 3
a447 1
		return( mk_arb8( outfp, name, dd ) );
d457 3
a459 1
		return( mk_arb8( outfp, name, dd ) );
d468 3
a470 1
		return( mk_arb8( outfp, name, dd ) );
d476 3
a478 1
		return( mk_arb4( outfp, name, dd ) );
d485 3
a487 1
		return( mk_rcc( outfp, name, D(0), D(1), dd[6] ) );
d494 4
a497 2
		return( mk_tgc( outfp, name, D(0), D(1),
			D(2), D(3), D(2), D(3) ) );
d504 3
a506 1
		return( mk_trc_h( outfp, name, D(0), D(1), dd[6], dd[7] ) );
d516 4
a519 2
		return( mk_tgc( outfp, name, D(0), D(1),
			D(2), D(3), D(4), D(5) ) );
d530 4
a533 2
		return( mk_tgc( outfp, name, D(0), D(1),
			D(2), D(3), D(4), D(5) ) );
d540 3
a542 1
		return( mk_sph( outfp, name, D(0), dd[3] ) );
d591 1
d599 4
a602 2
		return( mk_rpc( outfp, name, D(0), D(1),
			D(2), dd[9] ) );
d609 4
a612 2
		return( mk_rhc( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] ) );
d619 4
a622 2
		return( mk_epa( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] ) );
d629 4
a632 2
		return( mk_ehy( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10], dd[11] ) );
d639 4
a642 2
		return( mk_eto( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] ) );
d693 3
a695 1
		return( mk_ell( outfp, name, D(0), D(1), D(2), D(3) ) );
d702 3
a704 1
		return( mk_ell( outfp, name, D(0), D(1), D(2), D(3) ) );
d711 3
a713 1
		return( mk_tor( outfp, name, D(0), D(1), dd[6], dd[7] ) );
d720 3
a722 1
		return( mk_half( outfp, name, D(0), -dd[3] ) );
d726 2
a727 1
		return( read_arbn( name ) );
@


11.9.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/comgeom-g/solid.c,v 11.11 2004/02/02 17:38:59 morrison Exp $ (BRL)";
d209 1
a209 1
	char	*name=NULL;
a211 1
	int	ret;
d278 1
a278 1
	namecvt( sol_work, &name, 's' );
a282 1
		bu_free( name, "name" );
d290 1
a324 1
		bu_free( name, "name" );
d335 1
a335 3
		ret = mk_rpp( outfp, name, min, max );
		bu_free( name, "name" );
		return(ret);
d350 1
a350 3
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
d367 1
a367 3
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
d401 1
a401 3
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
d418 1
a418 3
		ret = mk_arb8( outfp, name, &tmp[0][X]);
		bu_free( name, "name" );
		return(ret);
d424 1
a424 3
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d431 1
a431 3
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d441 1
a441 3
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d450 1
a450 3
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d456 1
a456 3
		ret = mk_arb4( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d463 1
a463 3
		ret = mk_rcc( outfp, name, D(0), D(1), dd[6] );
		bu_free( name, "name" );
		return(ret);
d470 2
a471 4
		ret = mk_tgc( outfp, name, D(0), D(1),
			      D(2), D(3), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
d478 1
a478 3
		ret = mk_trc_h( outfp, name, D(0), D(1), dd[6], dd[7] );
		bu_free( name, "name" );
		return(ret);
d488 2
a489 4
		ret = mk_tgc( outfp, name, D(0), D(1),
			      D(2), D(3), D(4), D(5) );
		bu_free( name, "name" );
		return(ret);
d500 2
a501 4
		ret = mk_tgc( outfp, name, D(0), D(1),
			D(2), D(3), D(4), D(5) );
		bu_free( name, "name" );
		return(ret);
d508 1
a508 3
		ret = mk_sph( outfp, name, D(0), dd[3] );
		bu_free( name, "name" );
		return(ret);
a556 1
		bu_free( name, "name" );
d564 2
a565 4
		ret = mk_rpc( outfp, name, D(0), D(1),
			D(2), dd[9] );
		bu_free( name, "name" );
		return(ret);
d572 2
a573 4
		ret = mk_rhc( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
d580 2
a581 4
		ret = mk_epa( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
d588 2
a589 4
		ret = mk_ehy( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10], dd[11] );
		bu_free( name, "name" );
		return(ret);
d596 2
a597 4
		ret = mk_eto( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
d648 1
a648 3
		ret = mk_ell( outfp, name, D(0), D(1), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
d655 1
a655 3
		ret = mk_ell( outfp, name, D(0), D(1), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
d662 1
a662 3
		ret = mk_tor( outfp, name, D(0), D(1), dd[6], dd[7] );
		bu_free( name, "name" );
		return(ret);
d669 1
a669 3
		ret = mk_half( outfp, name, D(0), -dd[3] );
		bu_free( name, "name" );
		return(ret);
d673 1
a673 2
		ret = read_arbn( name );
		bu_free( name, "name" );
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.9 2002/08/20 17:07:20 jra Exp $ (BRL)";
d48 3
a50 3
extern int getline(register char *cp, int buflen, char *title);
extern int getint(char *cp, int start, int len);
extern void namecvt(register int n, register char *cp, int c);
d53 1
a53 1
extern void col_pr(char *str);
d56 1
a56 1
extern int read_arbn(char *name);
d62 1
a62 1
extern double	getdouble(char *cp, int start, int len);
d67 2
a68 2
void	trim_trail_spaces(register char *cp);
void	eat(int count);
d81 4
a84 1
getsoldata(double *dp, int num, int solid_num)
d134 4
a137 1
getxsoldata(double *dp, int num, int solid_num)
d180 2
a181 1
trim_trail_spaces(register char *cp)
d201 1
a201 1
getsolid(void)
d685 2
a686 1
read_arbn(char *name)
d996 2
a997 1
eat(int count)
@


11.9.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d202 1
a202 1
	char	*name=NULL;
a204 1
	int	ret;
d271 1
a271 1
	namecvt( sol_work, &name, 's' );
a275 1
		bu_free( name, "name" );
d283 1
a317 1
		bu_free( name, "name" );
d328 1
a328 3
		ret = mk_rpp( outfp, name, min, max );
		bu_free( name, "name" );
		return(ret);
d343 1
a343 3
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
d360 1
a360 3
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
d394 1
a394 3
		ret = mk_arb8( outfp, name, &tmp[0][X] );
		bu_free( name, "name" );
		return(ret);
d411 1
a411 3
		ret = mk_arb8( outfp, name, &tmp[0][X]);
		bu_free( name, "name" );
		return(ret);
d417 1
a417 3
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d424 1
a424 3
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d434 1
a434 3
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d443 1
a443 3
		ret = mk_arb8( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d449 1
a449 3
		ret = mk_arb4( outfp, name, dd );
		bu_free( name, "name" );
		return(ret);
d456 1
a456 3
		ret = mk_rcc( outfp, name, D(0), D(1), dd[6] );
		bu_free( name, "name" );
		return(ret);
d463 2
a464 4
		ret = mk_tgc( outfp, name, D(0), D(1),
			      D(2), D(3), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
d471 1
a471 3
		ret = mk_trc_h( outfp, name, D(0), D(1), dd[6], dd[7] );
		bu_free( name, "name" );
		return(ret);
d481 2
a482 4
		ret = mk_tgc( outfp, name, D(0), D(1),
			      D(2), D(3), D(4), D(5) );
		bu_free( name, "name" );
		return(ret);
d493 2
a494 4
		ret = mk_tgc( outfp, name, D(0), D(1),
			D(2), D(3), D(4), D(5) );
		bu_free( name, "name" );
		return(ret);
d501 1
a501 3
		ret = mk_sph( outfp, name, D(0), dd[3] );
		bu_free( name, "name" );
		return(ret);
a549 1
		bu_free( name, "name" );
d557 2
a558 4
		ret = mk_rpc( outfp, name, D(0), D(1),
			D(2), dd[9] );
		bu_free( name, "name" );
		return(ret);
d565 2
a566 4
		ret = mk_rhc( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
d573 2
a574 4
		ret = mk_epa( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
d581 2
a582 4
		ret = mk_ehy( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10], dd[11] );
		bu_free( name, "name" );
		return(ret);
d589 2
a590 4
		ret = mk_eto( outfp, name, D(0), D(1),
			D(2), dd[9], dd[10] );
		bu_free( name, "name" );
		return(ret);
d641 1
a641 3
		ret = mk_ell( outfp, name, D(0), D(1), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
d648 1
a648 3
		ret = mk_ell( outfp, name, D(0), D(1), D(2), D(3) );
		bu_free( name, "name" );
		return(ret);
d655 1
a655 3
		ret = mk_tor( outfp, name, D(0), D(1), dd[6], dd[7] );
		bu_free( name, "name" );
		return(ret);
d662 1
a662 3
		ret = mk_half( outfp, name, D(0), -dd[3] );
		bu_free( name, "name" );
		return(ret);
d666 1
a666 2
		ret = read_arbn( name );
		bu_free( name, "name" );
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d48 3
a50 3
extern int getline(register char *cp, int buflen, char *title);
extern int getint(char *cp, int start, int len);
extern void namecvt(register int n, register char *cp, int c);
d53 1
a53 1
extern void col_pr(char *str);
d56 1
a56 1
extern int read_arbn(char *name);
d62 1
a62 1
extern double	getdouble(char *cp, int start, int len);
d67 2
a68 2
void	trim_trail_spaces(register char *cp);
void	eat(int count);
d81 4
a84 1
getsoldata(double *dp, int num, int solid_num)
d134 4
a137 1
getxsoldata(double *dp, int num, int solid_num)
d180 2
a181 1
trim_trail_spaces(register char *cp)
d201 1
a201 1
getsolid(void)
d685 2
a686 1
read_arbn(char *name)
d996 2
a997 1
eat(int count)
@


11.7
log
@*- provide extern declarations for functions
   that need them
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.6 2000/07/25 18:43:18 mike Exp $ (BRL)";
d48 3
a50 3
extern int getline();
extern int getint();
extern void namecvt();
d53 1
a53 1
extern void col_pr();
d56 1
a56 1
extern int read_arbn();
d62 1
a62 1
extern double	getdouble();
d67 2
a68 2
void	trim_trail_spaces();
void	eat();
d81 1
a81 4
getsoldata( dp, num, solid_num )
double	*dp;
int	num;
int	solid_num;
d131 1
a131 4
getxsoldata( dp, num, solid_num )
double	*dp;
int	num;
int	solid_num;
d174 1
a174 2
trim_trail_spaces( cp )
register char	*cp;
d194 1
a194 1
getsolid()
d678 1
a678 2
read_arbn( name )
char	*name;
d988 1
a988 2
eat( count )
int	count;
@


11.6
log
@
libwdb lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.5 2000/07/20 18:36:37 mike Exp $ (BRL)";
d47 10
@


11.5
log
@
Some lint.  New libwdb conversion
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.4 2000/07/10 23:50:09 mike Exp $ (BRL)";
d508 1
a508 1
		struct	wdb_pipept	head;		/* allow a whole struct for head */
d528 1
a528 1
		RT_LIST_INIT( &head.l );
d541 1
a541 1
			RT_LIST_INSERT( &head.l, &ps->l );
@


11.4
log
@
lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/solid.c,v 11.3 1996/07/15 18:35:39 jra Exp $ (BRL)";
d32 5
d48 1
a48 1
extern FILE	*outfp;
d190 1
d674 1
@


11.3
log
@Minor Mods for IRIX 6.2
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 11.2 1995/12/04 15:00:56 jra Exp jra $ (BRL)";
@


11.2
log
@Mods for new pipe solid definition.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 11.1 1995/01/04 10:06:52 mike Rel4_4 jra $ (BRL)";
d52 3
d164 1
d978 1
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 10.6 94/12/08 16:02:33 mike Exp $ (BRL)";
d497 2
a498 2
		struct	wdb_pipeseg	*ps;
		struct	wdb_pipeseg	head;		/* all ow a whole struct for head */
d519 1
a519 1
		for( i = 0; i < numpts - 1; i++ )  {
d521 2
a522 2
			if( (ps = (struct wdb_pipeseg *)malloc( 
			 sizeof( struct wdb_pipeseg)) ) == WDB_PIPESEG_NULL )  {
d526 5
a530 4
			VMOVE( ps->ps_start, &pts[i*3]);	/* 3 pts at a time */
			ps->ps_id = 0;				/* solid */
			ps->ps_od = dia;
			ps->ps_type = WDB_PIPESEG_TYPE_LINEAR;
a533 12
		/* make the end plate */
		if( (ps = ( struct wdb_pipeseg *)malloc( sizeof(
	          struct wdb_pipeseg)) ) == WDB_PIPESEG_NULL )  {
	               	printf("malloc failure for WIR %d\n", sol_work);
	               	return(-1);
	        }
		VMOVE( ps->ps_start, &pts[3 * (numpts-1)] );
		ps->ps_type = WDB_PIPESEG_TYPE_END;
		ps->ps_id = 0;
		ps->ps_od = dia;
		RT_LIST_INSERT( &head.l, &ps->l );
		
@


10.6
log
@PI is found in math.h on Linux, use rt_*** constants instead.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 10.5 94/10/20 00:12:54 mike Exp Locker: mike $ (BRL)";
@


10.5
log
@mk_arb8() function prototype
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 10.4 94/08/23 18:54:16 gdurf Exp Locker: mike $ (BRL)";
a49 3
#define PI		3.14159265358979323846264	/* Approx */
#define	DEG2RAD		0.0174532925199433

d364 3
a366 3
		angle1 = (phi+theta-90) * DEG2RAD;
		angle2 = (phi+theta) * DEG2RAD;
		a2theta = a2 * tan(theta * DEG2RAD);
d627 3
a629 3
		work[0] += PI;
		work[1] += PI;
		work[2] += PI;
d830 2
a831 2
			az = getdouble( scard, 10+j*30+0*10, 10 ) * DEG2RAD;
			el = getdouble( scard, 10+j*30+1*10, 10 ) * DEG2RAD;
@


10.4
log
@Put includes in proper order
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 10.3 1994/08/09 19:08:48 gdurf Exp gdurf $ (BRL)";
d333 1
a333 1
		return( mk_arb8( outfp, name, (CONST point_t *)tmp ) );
d350 1
a350 1
		return( mk_arb8( outfp, name, (CONST point_t *)tmp ) );
d384 1
a384 1
		return( mk_arb8( outfp, name, (CONST point_t *)tmp ) );
d401 1
a401 1
		return( mk_arb8( outfp, name, (CONST point_t *)tmp) );
d407 1
a407 1
		return( mk_arb8( outfp, name, (CONST point_t *)dd ) );
d414 1
a414 1
		return( mk_arb8( outfp, name, (CONST point_t *)dd ) );
d424 1
a424 1
		return( mk_arb8( outfp, name, (CONST point_t *)dd ) );
d433 1
a433 1
		return( mk_arb8( outfp, name, (CONST point_t *)dd ) );
d439 1
a439 1
		return( mk_arb4( outfp, name, (CONST point_t *)dd ) );
@


10.3
log
@Added include of conf.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 10.2 1992/02/14 15:39:36 mmark Exp gdurf $ (BRL)";
d35 1
a36 1
#include "machine.h"
@


10.2
log
@added erim solids
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.36 91/08/25 05:57:59 butler Exp $ (BRL)";
d28 2
@


10.1
log
@Release_4.0
@
text
@d551 41
a591 1
	         		
@


1.36
log
@changed wire solid conversion to interpret last parameter as radius, and
pipe solid "od" as a diameter.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.35 91/07/17 21:04:11 mike Exp $ (BRL)";
@


1.35
log
@Fix from JRA for wire solid
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.34 91/07/16 00:28:36 mike Exp $ (BRL)";
d496 1
a496 1
		double			rad;
d514 1
a514 1
		rad = pts[num-1];
d529 1
a529 1
			ps->ps_od = rad;
d543 1
a543 1
		ps->ps_od = rad;
@


1.34
log
@GIFT HAF uses d consistent with dot product,
we presently use d of opposite sign.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.33 91/07/02 03:32:58 mike Exp $ (BRL)";
d502 1
a502 1
		numpts = getint( scard, 9, 2 );
@


1.33
log
@ANSI lint
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.32 91/07/02 03:11:13 mike Exp $ (BRL)";
d621 1
a621 1
		return( mk_half( outfp, name, D(0), dd[3] ) );
@


1.32
log
@ANSI lint
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.31 91/06/23 00:40:31 mike Exp $ (BRL)";
d422 1
a422 1
		return( mk_arb8( outfp, name, (point_t *)dd ) );
d431 1
a431 1
		return( mk_arb8( outfp, name, (point_t *)dd ) );
d437 1
a437 1
		return( mk_arb4( outfp, name, (point_t *)dd ) );
@


1.31
log
@Changed mk_trc to mk_trc_h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.30 91/06/13 03:03:20 mike Exp $ (BRL)";
d331 1
a331 1
		return( mk_arb8( outfp, name, tmp ) );
d348 1
a348 1
		return( mk_arb8( outfp, name, tmp ) );
d382 1
a382 1
		return( mk_arb8( outfp, name, tmp ) );
d399 1
a399 1
		return( mk_arb8( outfp, name, (point_t *)tmp) );
d405 1
a405 1
		return( mk_arb8( outfp, name, (point_t *)dd ) );
d412 1
a412 1
		return( mk_arb8( outfp, name, (point_t *)dd ) );
@


1.30
log
@Added tol
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.29 91/02/07 00:50:33 butler Exp $ (BRL)";
d459 1
a459 1
		return( mk_trc( outfp, name, D(0), D(1), dd[6], dd[7] ) );
@


1.29
log
@added ERIM's "arw" (ARbitrary Wedge)
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.28 90/12/07 01:22:42 mike Exp $ (BRL)";
d37 1
d657 1
d659 7
d744 1
a744 2
			/* XXX The tol_sq here is sheer guesswork */
			if( rt_mk_plane_3pts( eqn[cur_eq], a,b,c, 0.00001 ) < 0 )  {
@


1.28
log
@fixed memory leak
lint
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.27 90/12/04 23:25:02 mike Exp $ (BRL)";
d382 17
@


1.27
log
@Added tolerance to rt_mk_plane_3pts
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/solid.c,v 1.26 90/10/17 23:58:40 sue Exp $ (BRL)";
d191 1
a191 1
	double	tmp[3*8];	/* 8 vectors of 3 nums each */
d193 1
a193 1
#define T(_i)	(&(tmp[_i*3]))
d387 1
a387 1
		return( mk_arb8( outfp, name, dd ) );
d394 1
a394 1
		return( mk_arb8( outfp, name, dd ) );
d404 1
a404 1
		return( mk_arb8( outfp, name, dd ) );
d413 1
a413 1
		return( mk_arb8( outfp, name, dd ) );
d419 1
a419 1
		return( mk_arb4( outfp, name, dd ) );
d528 4
a531 1
		return( mk_pipe( outfp, name, &head ) );
@


1.26
log
@Added support for "wire solid", solid type WIR.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: solid.c,v 1.25 90/02/27 20:11:09 mike Exp $ (BRL)";
d715 2
a716 1
			if( rt_mk_plane_3pts( eqn[cur_eq], a,b,c ) < 0 )  {
@


1.25
log
@Cleaned up some lint
@
text
@d9 1
a9 1
 *  Author -
d11 1
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: solid.c,v 1.24 90/02/10 02:33:42 mike Locked $ (BRL)";
d36 2
d39 1
d469 1
a469 1
		if( getsoldata( dd, 1*3+2, sol_work ) < 0 )
d474 58
@


1.24
log
@Added support for WED (aka RAW), and RVW (new).
Also added support for END keyword.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: solid.c,v 1.23 89/12/29 22:39:08 mike Locked $ (BRL)";
d32 1
d249 1
a249 1
				*cp++;
d696 1
a696 1
			int	vertex;
d702 2
a703 2
			vertex = getint( scard, 10+j*30+2*10, 10 );
			if( vertex == 0 )  break;
d709 2
a710 2
			if( vertex < 0 )  {
				VMOVE( pt, &input_points[((-vertex)-1)*3] );
d713 1
a713 1
				VMOVE( pt, &input_points[((vertex)-1)*3] );
d862 1
a862 1
		getline( lbuf, sizeof(lbuf), "eaten card" );
@


1.23
log
@Added header.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d42 2
a43 2
#define PI	3.14159265358979323846264	/* Approx */
#define	DEG2RAD	0.0174532925199433
d195 2
a196 1
	if( version == 5 )  {
d201 2
a202 1
	} else {
d207 11
d256 5
d328 3
a330 1
	if( strcmp( solid_type, "raw" ) == 0 )  {
d342 34
@


1.22
log
@Added some additional checking for ARBNs
@
text
@a0 1
#
d4 4
a7 4
 *	Conversion subroutine for CVT program, used to convert
 * COMGEOM card decks into GED object files.  This conversion routine
 * is used to translate between COMGEOM object types, and the
 * more general GED object types.
d9 2
a10 3
 * Michael Muuss
 * Ballistic Research Laboratory
 * March, 1980
d12 11
a22 6
 *		R E V I S I O N   H I S T O R Y
 *
 *	Feb, 1981 Chuck Stanley	Added code to process TORUS (TOR)
 *
 *	02/26/81  MJM	Fixed bug in TORUS code...(PI,PI,PI) was being
 *			added to F1, and put in the file.
d24 3
@


1.21
log
@Initial ARBN support
@
text
@a517 1
printf("npt=%d, npe=%d, neq=%d, nae=%d\n", npt, npe, neq, nae);
d622 1
a622 1
		eqn[cur_eq][3] = eqn[cur_eq][3] * scale;
d711 1
d717 1
d757 1
d764 3
@


1.20
log
@ELLG existed in version 4, it seems.
@
text
@a27 1
#include "db.h"
d37 1
d39 1
a39 1
char	scard[132];
d41 109
d481 1
a481 14
		int	a,b,c,d;
		/* 4 counts: a, b, c, d */
		a = getint( scard, 10+0*10, 10 );
		b = getint( scard, 10+1*10, 10 );
		c = getint( scard, 10+2*10, 10 );
		d = getint( scard, 10+3*10, 10 );

		/* I'm not sure what these cards are for yet */
		if(a>0) eat( (a+1)/2 );		/* vertex points */
		if(b>0) eat( (b+5)/6 );		/* vertex pt index numbers */
		if(c>0) eat( c );		/* plane eqns? */
		if(d>0) eat( (d+1)/2 );		/* 2 nums & vertex index? */

		return(-1);
d492 2
a493 2
eat( count )
int	count;
d495 18
a512 1
	int	i;
d514 16
a529 2
	for( i=0; i<count; i++ )  {
		getline( scard, sizeof(scard), "eaten card" );
a530 1
}
d532 10
a541 20
/*
 *			G E T S O L D A T A
 *
 *  Obtain 'num' data items from input card(s).
 *  The first input card is already in global 'scard'.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
getsoldata( dp, num, solid_num )
double	*dp;
int	num;
int	solid_num;
{
	int	cd;
	double	*fp;
	int	i;
	int	j;
d543 33
a575 7
	fp = dp;
	for( cd=1; num > 0; cd++ )  {
		if( cd != 1 )  {
			if( getline( scard, sizeof(scard), "solid continuation card" ) == EOF )  {
				printf("too few cards for solid %d\n",
					solid_num);
				return(-1);
d577 7
a583 8
			/* continuation card
			 * solid type should be blank 
			 */
			if( (version==5 && scard[5] != ' ' ) ||
			    (version==4 && scard[3] != ' ' ) )  {
				printf("solid %d (continuation) card %d non-blank\n",
					solid_num, cd);
				return(-1);
d585 16
d602 1
d604 22
a625 4
		if( num < 6 )
			j = num;
		else
			j = 6;
d627 6
a632 2
		for( i=0; i<j; i++ )  {
			*fp++ = getdouble( scard, 10+i*10, 10 );
d634 24
a657 1
		num -= j;
d659 123
a781 1
	return(0);
d785 1
a785 1
 *			G E T X S O L D A T A
d787 1
a787 6
 *  Obtain 'num' data items from input card(s).
 *  All input cards must be freshly read.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
d789 2
a790 5
int
getxsoldata( dp, num, solid_num )
double	*dp;
int	num;
int	solid_num;
d792 1
a792 2
	int	cd;
	double	*fp;
a793 1
	int	j;
d795 2
a796 28
	fp = dp;
	for( cd=1; num > 0; cd++ )  {
		if( getline( scard, sizeof(scard), "x solid card" ) == EOF )  {
			printf("too few cards for solid %d\n",
				solid_num);
			return(-1);
		}
		if( cd != 1 )  {
			/* continuation card
			 * solid type should be blank 
			 */
			if( (version==5 && scard[5] != ' ' ) ||
			    (version==4 && scard[3] != ' ' ) )  {
				printf("solid %d (continuation) card %d non-blank\n",
					solid_num, cd);
				return(-1);
			}
		}

		if( num < 6 )
			j = num;
		else
			j = 6;

		for( i=0; i<j; i++ )  {
			*fp++ = getdouble( scard, 10+i*10, 10 );
		}
		num -= j;
a797 1
	return(0);
@


1.19
log
@Added solid number sanity check for version 5 files.
Added the first part of ARBN handling;  for now,
just eat the cards and pass on.
@
text
@d350 1
a350 1
	if( version == 5 && strcmp( solid_type, "ellg" ) == 0 )  {
@


1.18
log
@Added verbose flag and halfspace handling
@
text
@d100 7
d371 17
d394 10
@


1.17
log
@Well, in version 5, "ell1" can still be used for the V A r ellipsoid.
@
text
@d32 1
d119 1
a119 1
	col_pr( name );
d355 7
@


1.16
log
@Removed vestiges of old ARS code.
mk_ars() is now part of libwdb.
Eliminated convert() subroutine;  all work is done in getsolid().
Fixed problem with ELLG in version 5 input decks.
@
text
@d297 2
a298 2
		 * For simplicity, we convert ELL to ELLG, then
		 * fall through to ELLG code.
d300 1
a300 1
		 * ELLG format is V, A, r
d317 2
a318 2
	if( (version <= 4 && strcmp( solid_type, "ell1" ) == 0) ||
	    (version == 5 && strcmp( solid_type, "ell" ) == 0) )  {
@


1.15
log
@This version uses libwdb-style mk_ars() routine.
It seems to work.
@
text
@d38 1
a39 6
struct scard {
	char	sc_num_and_type[10];
	char	sc_fields[6][10];
	char	sc_remark[16];
} scard;

d56 3
a58 3
 *	0	done, or EOF
 *	1	non-ARS done
 *	2	ARS done
d65 8
d74 1
a74 4
	if( sol_work == sol_total )	/* processed all solids */
		return( 0 );

	if( (i = getline( &scard, sizeof(scard), "solid card" )) == EOF )  {
d76 1
a76 1
		return( 0 );
d80 1
a80 1
		strncpy( given_solid_num, ((char *)&scard)+0, 5 );
d82 1
a82 1
		strncpy( solid_type, ((char *)&scard)+5, 5 );
d85 1
a85 1
		strncpy( given_solid_num, ((char *)&scard)+0, 3 );
d87 1
a87 1
		strncpy( solid_type, ((char *)&scard)+3, 7 );
d117 3
d121 2
a122 12
		static int j,n,jj,m,mx;
		static float *fp;
		int cd,cds;
		int	ncurves;
		int	pts_per_curve;
		int	Nb_strcx,Nb_strsl,nst,structn,rmcx,cdcx;
		static char nbuf[6];
		static float ibuf[10];
		static float jbuf[10];
		struct ars_rec *arsap;
		union record *b;
		union record	rec;
d124 1
d126 2
a128 15
		/*
		 * PROCESS ARS SOLID
		 */
		arsap = &rec.a;
		arsap->a_id = ID_ARS_A;
		arsap->a_type = ARS;
		namecvt( sol_work, arsap->a_name, 's');
		col_pr( arsap->a_name );

		/* ncurves is # of curves, pts_per_curve is # of points per curve */
		ncurves = getint( &scard, 10, 10 );
		pts_per_curve = getint( &scard, 20, 10 );
		arsap->a_m = ncurves;
		arsap->a_n = pts_per_curve;

d150 3
a152 3
		if( mk_ars( outfp, arsap->a_name, ncurves, pts_per_curve, curve ) < 0 )  {
			printf("mk_ars(%s) failed\n", arsap->a_name );
			return(-1);
a154 1
		/* Free memory */
d159 1
a159 143
		/* DONE */
#if 0
		/*
		 *   the number of b type structures needed to store 1
		 * cross section is equal to pts_per_curve/8;  if pts_per_curve modulo 8 is not
		 * equal to 0 then 1 more structure is needed.
		 */
		Nb_strcx = pts_per_curve/8;
		if(( pts_per_curve % 8) !=0)
			Nb_strcx++;
		rmcx = pts_per_curve % 8;

		/*
		 * (8 - rmcx) required # of unused storage locations for the
		 * last structure associated with a cross section.
		 */
		arsap->a_curlen=Nb_strcx;

		/*
		 * number of b type structures calculated above multiplied
		 * by the total number of cross sections equals the total
		 * amount of storage required.
		 */
		Nb_strsl = Nb_strcx * ncurves;
		arsap->a_totlen = Nb_strsl;

		/*
		 * the number of b type structures is used here
		 * to allocate proper storage dynamically
		 */
		if( (b =
		    (union record *)
		    malloc( (unsigned) Nb_strsl*sizeof(union record) )
		    ) == (union record *) NULL
			) {
			(void) fprintf( stderr, "Getsolid(): Malloc() failed!\n" );
			exit( 1 );
		}

		/*    number of data cards per cross section calculated here */
		cdcx = (pts_per_curve+1)/2;

		/* calculate number of ARS data cards that have to be read in */
		/*   as given in GIFT users manual  */
		cd = ncurves*(cdcx);

		/*  2 sets of xyz coordinates for every data card
		 *  set up counters to read in coordinate points and load into 
		 *       b structures created above
		 */
		cds = 0;	/* number of data cards read in (1-> cd) */
		nst = -1;	/* b type structure number currently loaded */

		structn = 0;	/* granule # within a cross secton  */
		for(m=1; m < (ncurves+1); m++)  {
			structn=0;
			for(n=1; n <(cdcx+1); n++)  {
				if( getline(&scard, sizeof(scard), "ars solid card") == EOF)
					{
					printf("read of ARS granule failed\n");
					return	0;
					}
				cds++;
				if((j=(n % 4)) == 1)  {
					structn++;   /* increment granule number   */
					nst++;    /*increment structure number */
					b[nst].b.b_id = ID_ARS_B;
					b[nst].b.b_type = ARSCONT;
					b[nst].b.b_n = m;  /*  save cross section number  */
					b[nst].b.b_ngranule = structn;  /* save granule number  */
				}
				for(i=5; i>=0; i--) {
					scard.sc_fields[i][10] = '\0';
					ibuf[i] = atof(scard.sc_fields[i]);
				}
				if(cds == 1){ /* save 1st point coordinate */
					for(i=0; i<3; i++)
						jbuf[i] = ibuf[i];
				}
				switch( j ) {
				case 1:
					b[nst].b.b_values[0]=ibuf[0];
					b[nst].b.b_values[1]=ibuf[1];
					b[nst].b.b_values[2]=ibuf[2];
					b[nst].b.b_values[3]=ibuf[3];
					b[nst].b.b_values[4]=ibuf[4];
					b[nst].b.b_values[5]=ibuf[5];
					break;
				case 2:
					b[nst].b.b_values[6]=ibuf[0];
					b[nst].b.b_values[7]=ibuf[1];
					b[nst].b.b_values[8]=ibuf[2];
					b[nst].b.b_values[9]=ibuf[3];
					b[nst].b.b_values[10]=ibuf[4];
					b[nst].b.b_values[11]=ibuf[5];
					break;
				case 3:
					b[nst].b.b_values[12]=ibuf[0];
					b[nst].b.b_values[13]=ibuf[1];
					b[nst].b.b_values[14]=ibuf[2];
					b[nst].b.b_values[15]=ibuf[3];
					b[nst].b.b_values[16]=ibuf[4];
					b[nst].b.b_values[17]=ibuf[5];
					break;
				case 0:
					b[nst].b.b_values[18]=ibuf[0];
					b[nst].b.b_values[19]=ibuf[1];
					b[nst].b.b_values[20]=ibuf[2];
					b[nst].b.b_values[21]=ibuf[3];
					b[nst].b.b_values[22]=ibuf[4];
					b[nst].b.b_values[23]=ibuf[5];

				}
			}
		}

		/*    subtract base vector from  each vector in description */
		for(j=0; j<Nb_strsl; j++)  {
			for(i=0; i<8; i++){
				b[j].b.b_values[(i*3)] -= jbuf[0];
				b[j].b.b_values[(i*3)+1] -= jbuf[1];
				b[j].b.b_values[(i*3)+2] -= jbuf[2];
			}
		}

		/* restore base vector to original value */
		b[0].b.b_values[0] = jbuf[0];
		b[0].b.b_values[1] = jbuf[1];
		b[0].b.b_values[2] = jbuf[2];

		/*  write out A and B type records  */
		fwrite( arsap, sizeof(union record), 1, outfp );
		fwrite( &b[0], sizeof(union record), Nb_strsl, outfp );

		/* free dynamic storage alloated for ARS */
		free (b);
		return(2);
#endif
	}  else   {
		/* solid type other than ARS */
		convert( sol_work, solid_type );

		return(1);		/* input is valid */
a160 1
}
a161 130
/*
 *			G E T S O L D A T A
 *
 *  Obtain 'num' data items from input card(s).
 *  The first input card is already in global 'scard'.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
getsoldata( dp, num, solid_num )
double	*dp;
int	num;
int	solid_num;
{
	int	cd;
	double	*fp;
	int	i;
	int	j;

	fp = dp;
	for( cd=1; num > 0; cd++ )  {
		if( cd != 1 )  {
			if( getline( &scard, sizeof(scard), "solid continuation card" ) == EOF )  {
				printf("too few cards for solid %d\n",
					solid_num);
				return(-1);
			}
			/* continuation card
			 * solid type should be blank 
			 */
			if( (version==5 && ((char *)&scard)[5] != ' ' ) ||
			    (version==4 && ((char *)&scard)[3] != ' ' ) )  {
				printf("solid %d (continuation) card %d non-blank\n",
					solid_num, cd);
				return(-1);
			}
		}

		if( num < 6 )
			j = num;
		else
			j = 6;

		for( i=0; i<j; i++ )  {
			*fp++ = getdouble( &scard, 10+i*10, 10 );
		}
		num -= j;
	}
	return(0);
}

/*
 *			G E T X S O L D A T A
 *
 *  Obtain 'num' data items from input card(s).
 *  All input cards must be freshly read.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
getxsoldata( dp, num, solid_num )
double	*dp;
int	num;
int	solid_num;
{
	int	cd;
	double	*fp;
	int	i;
	int	j;

	fp = dp;
	for( cd=1; num > 0; cd++ )  {
		if( getline( &scard, sizeof(scard), "x solid card" ) == EOF )  {
			printf("too few cards for solid %d\n",
				solid_num);
			return(-1);
		}
		if( cd != 1 )  {
			/* continuation card
			 * solid type should be blank 
			 */
			if( (version==5 && ((char *)&scard)[5] != ' ' ) ||
			    (version==4 && ((char *)&scard)[3] != ' ' ) )  {
				printf("solid %d (continuation) card %d non-blank\n",
					solid_num, cd);
				return(-1);
			}
		}

		if( num < 6 )
			j = num;
		else
			j = 6;

		for( i=0; i<j; i++ )  {
			*fp++ = getdouble( &scard, 10+i*10, 10 );
		}
		num -= j;
	}
	return(0);
}

/*
 *			C O N V E R T
 *
 *  This routine is expected to write the records out itself.
 *  The first card has already been read into 'scard'.
 */
convert( sol_num, solid_type )
int	sol_num;
char	*solid_type;
{
	double	r1, r2;
	vect_t	work;
	double	m1, m2;		/* Magnitude temporaries */
	static int i;
	char	name[16+2];
	double	dd[4*6];	/* 4 cards of 6 nums each */
	double	tmp[3*8];	/* 8 vectors of 3 nums each */

	namecvt( sol_num, name, 's' );
	col_pr( name );

#define D(_i)	(&(dd[_i*3]))
#define T(_i)	(&(tmp[_i*3]))

d165 1
a165 1
		if( getsoldata( dd, 2*3, sol_num ) < 0 )
d173 1
a173 1
		if( getsoldata( dd, 4*3, sol_num ) < 0 )
d188 1
a188 1
		if( getsoldata( dd, 4*3, sol_num ) < 0 )
d203 1
a203 1
		if( getsoldata( dd, 8*3, sol_num ) < 0 )
d209 1
a209 1
		if( getsoldata( dd, 7*3, sol_num ) < 0 )
d216 1
a216 1
		if( getsoldata( dd, 6*3, sol_num ) < 0 )
d226 1
a226 1
		if( getsoldata( dd, 5*3, sol_num ) < 0 )
d235 1
a235 1
		if( getsoldata( dd, 4*3, sol_num ) < 0 )
d242 1
a242 1
		if( getsoldata( dd, 2*3+1, sol_num ) < 0 )
d249 1
a249 1
		if( getsoldata( dd, 4*3, sol_num ) < 0 )
d257 1
a257 1
		if( getsoldata( dd, 2*3+2, sol_num ) < 0 )
d264 1
a264 1
		if( getsoldata( dd, 4*3+1, sol_num ) < 0 )
d275 1
a275 1
		if( getsoldata( dd, 4*3+2, sol_num ) < 0 )
d287 1
a287 1
		if( getsoldata( dd, 1*3+2, sol_num ) < 0 )
d292 3
a294 3
	if( strcmp( solid_type, "ell" ) == 0 )  {
		if( version == 4 )  {
			vect_t	v;
d296 9
a304 9
			/*
			 * For simplicity, we convert ELL to ELL1, then
			 * fall through to ELL1 code.
			 * Format of ELL is F1, F2, len
			 * ELL1 format is V, A, r
			 */
			if( getsoldata( dd, 2*3+1, sol_num ) < 0 )
				return(-1);
			VADD2SCALE( v, D(0), D(1), 0.5 ); /* V is midpoint */
d306 4
a309 4
			VSUB2( work, D(1), D(0) );	/* work holds F2 -  F1 */
			m1 = MAGNITUDE( work );
			r2 = 0.5 * dd[6] / m1;
			VSCALE( D(1), work, r2 );	/* A */
d311 4
a314 8
			dd[6] = sqrt( MAGSQ( D(1) ) -
				(m1 * 0.5)*(m1 * 0.5) );	/* r */
			VMOVE( D(0), v );
			goto ellcom;
		}
		/* NO ELL's in gift5  -  handle as ELL1? */
		printf("No ELL in version 5??\n");
		return(-1);
d317 2
a318 2
	if( strcmp( solid_type, "ell1" ) == 0 ||
	    strcmp( solid_type, "ellg" ) == 0 )  {
d320 2
a321 2
	    	/* GIFT4 name is "ell1", GIFT5 name is "ellg" */
		if( getsoldata( dd, 2*3+1, sol_num ) < 0 )
d324 1
a324 1
ellcom:
d342 7
d351 1
a351 1
		if( getsoldata( dd, 2*3+2, sol_num ) < 0 )
d360 1
a360 1
	printf("convert:  no support for solid type '%s'\n", solid_type );
d365 1
a365 1
 *			M K _ A R S
d367 2
a368 5
 *  The input is an array of pointers to an array of fastf_t values.
 *  There is one pointer for each curve.
 *  It is anticipated that there will be pts_per_curve+1 elements per
 *  curve, the first point being repeated as the final point, although
 *  this is not checked here.
d372 1
a372 1
 *	-1	Fail
d375 4
a378 6
mk_ars( filep, name, ncurves, pts_per_curve, curves )
FILE	*filep;
char	*name;
int	ncurves;
int	pts_per_curve;
fastf_t	**curves;
d380 4
a383 4
	union record	rec;
	vect_t		base_pt;
	int		per_curve_grans;
	int		cur;
d385 18
a402 1
	bzero( (char *)&rec, sizeof(rec) );
d404 4
a407 5
	rec.a.a_id = ID_ARS_A;
	rec.a.a_type = ARS;			/* obsolete? */
	NAMEMOVE( name, rec.a.a_name );
	rec.a.a_m = ncurves;
	rec.a.a_n = pts_per_curve;
d409 7
a415 5
	per_curve_grans = (pts_per_curve+7)/8;
	rec.a.a_curlen = per_curve_grans;
	rec.a.a_totlen = per_curve_grans * ncurves;
	if( fwrite( (char *)&rec, sizeof(rec), 1, filep ) != 1 )
		return(-1);
d417 20
a436 3
	VMOVE( base_pt, &curves[0][0] );
	/* The later subtraction will "undo" this, leaving just base_pt */
	VADD2( &curves[0][0], &curves[0][0], base_pt);
d438 18
a455 4
	for( cur=0; cur<ncurves; cur++ )  {
		register fastf_t	*fp;
		int			npts;
		int			left;
d457 4
a460 5
		fp = curves[cur];
		left = pts_per_curve;
		for( npts=0; npts < pts_per_curve; npts+=8, left -= 8 )  {
			register int	el;
			register int	lim;
d462 2
a463 16
			bzero( (char *)&rec, sizeof(rec) );
			rec.b.b_id = ID_ARS_B;
			rec.b.b_type = ARSCONT;	/* obsolete? */
			rec.b.b_n = cur+1;	/* obsolete? */
			rec.b.b_ngranule = (npts/8)+1; /* obsolete? */

			lim = (left > 8 ) ? 8 : left;
			for( el=0; el < lim; el++ )  {
				vect_t	diff;
				VSUB2( diff, fp, base_pt );
				/* XXX converts to dbfloat_t */
				VMOVE( &(rec.b.b_values[el*3]), diff );
				fp += ELEMENTS_PER_VECT;
			}
			if( fwrite( (char *)&rec, sizeof(rec), 1, filep ) != 1 )
				return(-1);
d465 1
@


1.14
log
@minor cleanups
@
text
@d120 4
a123 1
		int cd,cds,M,N,Nb_strcx,Nb_strsl,nst,structn,rmcx,cdcx;
d130 1
d142 5
a146 5
		/* M is # of curves, N is # of points per curve */
		M = getint( &scard, 10, 10 );
		N = getint( &scard, 20, 10 );
		arsap->a_m = M;
		arsap->a_n = N;
d148 33
d183 1
a183 1
		 * cross section is equal to N/8;  if N modulo 8 is not
d186 2
a187 2
		Nb_strcx = N/8;
		if(( N % 8) !=0)
d189 1
a189 1
		rmcx = N % 8;
d202 1
a202 1
		Nb_strsl = Nb_strcx * M;
d219 1
a219 1
		cdcx = (N+1)/2;
d223 1
a223 1
		cd = M*(cdcx);
d233 1
a233 1
		for(m=1; m < (M+1); m++)  {
d316 1
a316 1

d379 53
d443 1
a443 1
	double	m1, m2;	/* Magnitude temporaries */
d668 2
a669 2
mk_ars( fp, name, ncurves, pts_per_curve, curves )
FILE	*fp;
d678 1
a678 1
	int		i;
d691 1
a691 1
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
d698 1
a698 1
	for( i=0; i<ncurves; i++ )  {
d701 1
d703 4
a706 3
		fp = curves[i];
		for( npts = pts_per_curve; npts > 0; npts -= 8 )  {
			register int	i;
d712 2
a713 2
			rec.b.b_n = i;		/* obsolete? */
			rec.b.b_ngranule = pts_per_curve - npts; /* obsolete? */
d715 6
a720 4
			lim = (npts > 8 ) ? 8 : npts;
			for( i=0; i < lim; i++ )  {
				/* XXX also converts to dbfloat_t */
				VSUB2( &(rec.b.b_values[i*3]), fp, base_pt );
d723 1
a723 1
			if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
@


1.13
log
@Solid types now checked by direct strcmp(), rather than
using intermediate type number.
@
text
@a44 71
/*
 * Table to map names of solids into internal numbers.
 *
 * NOTE that the name field is expected to be four characters
 * wide, right blank filled, null terminated.
 */
struct table  {
	int	t_value;
	char	t_name[6];
}  
table[] =  {
	RPP,	"rpp",
	BOX,	"box",
	RAW,	"raw",
	ARB8,	"arb8",
	ARB7,	"arb7",
	ARB6,	"arb6",
	ARB5,	"arb5",
	ARB4,	"arb4",
	GENELL,	"ellg",
	ELL1,	"ell1",
	ELL,	"ell",		/* After longer ell entries */
	SPH,	"sph",
	RCC,	"rcc",
	REC,	"rec",
	TRC,	"trc",
	TEC,	"tec",
	TOR,	"tor",
	TGC,	"tgc",
	GENTGC,	"cone",
	ARS,	"ars",
	0,	""
};

/*
 *			L O O K U P
 */
int
lookup( cp )
register char	*cp;
{
	register struct table *tp;
	register char	*lp;
	register char	c;
	char	low[32];
	

	/* Reduce input to lower case */
	lp = low;
	while( (c = *cp++) != '\0' )  {
		if( !isascii(c) )  {
			*lp++ = '?';
		} else if( isupper(c) )  {
			*lp++ = tolower(c);
		} else {
			*lp++ = c;
		}
	}
	*lp = '\0';

	tp = &table[0];
	while( tp->t_value != 0 )  {
		if( strcmp( low, tp->t_name ) == 0 )
			return( tp->t_value );
		tp++;
	}

	printf("ERROR:  bad solid type '%s'\n", low );
	return(0);
}

d67 1
a67 1
	char	cur_solid_num[16];
a68 1
	int	cur_type;
d80 2
a81 2
		strncpy( cur_solid_num, ((char *)&scard)+0, 5 );
		cur_solid_num[5] = '\0';
d85 2
a86 2
		strncpy( cur_solid_num, ((char *)&scard)+0, 3 );
		cur_solid_num[3] = '\0';
d91 1
a91 1
	trim_trail_spaces( cur_solid_num );
a116 5
	if( (cur_type = lookup(solid_type)) <= 0 )  {
		printf("getsolid: bad type\n");
		return -1;
	}

d139 2
a140 2
		M = getint( scard, 10, 10 );
		N = getint( scard, 20, 10 );
d181 3
d186 1
a186 1
		cd = M*((N+1)/2);
a187 3
		/*    number of data cards per cross section calculated here */
		cdcx = (N+1)/2;

d282 1
a282 1
		convert( cur_type, sol_work, solid_type );
d347 1
a347 2
convert( cur_type, sol_num, solid_type )
int	cur_type;
d562 72
@


1.12
log
@Now all solids know how much input each has to read.
Beginning of ARS cleanup
@
text
@d172 17
d194 1
a194 1
	if( cur_type == ARS){
d443 2
a444 1
	switch( cur_type )  {
a445 1
	case RPP:
d448 4
a451 2
		{
			double	min[3], max[3];
d453 1
a453 6
			VSET( min, dd[0], dd[2], dd[4] );
			VSET( max, dd[1], dd[3], dd[5] );
			return( mk_rpp( outfp, name, min, max ) );
		}

	case BOX:
d466 1
d468 1
a468 1
	case RAW:
d481 1
d483 1
a483 1
	case ARB8:
d487 1
d489 1
a489 1
	case ARB7:
d494 1
d496 1
a496 1
	case ARB6:
d504 1
d506 1
a506 1
	case ARB5:
d513 1
d515 1
a515 1
	case ARB4:
d519 1
d521 1
a521 1
	case RCC:
d526 1
d528 1
a528 1
	case REC:
d534 1
d536 1
a536 1
	case TRC:
d541 1
d543 1
a543 1
	case TEC:
d552 1
d554 1
a554 1
	case TGC:
d564 1
d566 1
a566 1
	case SPH:
d571 1
d573 1
a573 1
	case ELL:
a595 2
		} else {
			/* NO ELL's in gift5  -  fall through to ELL1 */
d597 4
a600 1
		/* Fall through */
d602 2
a603 2
	case ELL1:		/* GIFT4 name */
	case GENELL:		/* GIFT5 name */
d605 1
d625 1
d627 1
a627 1
	case TOR:
d635 2
a636 1
	 * We should never reach here
d638 1
a638 1
	printf("convert:  no support for solid %d\n", cur_type );
@


1.11
log
@convert() now uses libwdb routines exclusively
@
text
@d26 3
a28 2
#include "./ged_types.h"
#include "./3d.h"
a29 4
#define VADD2SCALE( o, a, b, s )	o[X] = ((a)[X] + (b)[X]) * (s); \
					o[Y] = ((a)[Y] + (b)[Y]) * (s); \
					o[Z] = ((a)[Z] + (b)[Z]) * (s);

d33 2
a34 1
extern int sol_total, sol_work;
a44 23
int ncards[] =  {
	0,
	1,	/* RPP */
	2,
	2,
	2,
	3,
	3,
	4,
	4,	/* ARB8 */
	2,	/* ELL */
	2,	/* ELL1 */
	1,	/* SPH */
	2,	/* RCC */
	2,	/* REC */
	2,	/* TRC */
	3,	/* TEC */
	2,	/* TOR */
	3,	/* TGC */
	0,	/* GENTGC, 18 */
	2,	/* ELLG, 19 */
};

a137 11
	register struct solids *solidp;
	static int i,j,n,jj,m,mx;
	static float *fp;
	int cd,cds,M,N,Nb_strcx,Nb_strsl,nst,structn,rmcx,cdcx;
	static char nbuf[6];
	static float xmax, ymax, zmax;
	static float xmin, ymin, zmin;
	static float ibuf[10];
	static float jbuf[10];
	struct ars_rec *arsap;
	union record *b;
d141 1
a141 1
	union record	rec;
a142 2
	solidp = &rec.s;

d178 11
d192 4
a195 4
		arsap = (struct ars_rec *) solidp;
		arsap->a_id = ARS_A;
		arsap -> a_type = ARS;
		namecvt( sol_work, arsap -> a_name, 's');
d198 4
a201 13
		/*  init  max and min values */
		xmax = ymax = zmax = -10000.0;
		xmin = ymin = zmin = 10000.0;
		/* read   N  M values    ->     convert ASCII to integer  */
		nbuf[10] = '\0';
		for (i=0; i<10; i++)
			nbuf[i]=scard.sc_fields[0][i];

		M = atoi(nbuf);
		arsap -> a_m = M;
		for(i=0; i<10; i++)
			nbuf[i]=scard.sc_fields[1][i];
		N=atoi(nbuf);
d268 1
a268 1
					b[nst].b.b_id = ARS_B;
a315 26

			/* calculate  min and max values associated with ARS data points */
			/*   save in A type structure */
			for(j=0; j < Nb_strsl; j++)   {
				for(i=0; i<8; i++){
					if(b[j].b.b_values[i*3] > xmax)
						xmax = b[j].b.b_values[i*3];
					else if(b[j].b.b_values[i*3] < xmin)
						xmin = b[j].b.b_values[i*3];
					else if(b[j].b.b_values[(i*3)+1] > ymax )
						ymax = b[j].b.b_values[(i*3)+1];
					else if(b[j].b.b_values[(i*3)+1] < ymin)
						ymin = b[j].b.b_values[(i*3)+1];
					else if(b[j].b.b_values[(i*3)+2] > zmax)
						zmax = b[j].b.b_values[(i*3)+2];
					else if(b[j].b.b_values[(i*3)+2] < zmin)
						zmin = b[j].b.b_values[(i*3)+2];
				}
			}
			/* save max's and min in atype structure */
			arsap->a_xmax=xmax;
			arsap->a_xmin=xmin;
			arsap->a_ymax=ymax;
			arsap->a_ymin=ymin;
			arsap->a_zmax=zmax;
			arsap->a_zmin=zmin;
d367 1
d369 1
d388 2
a389 3
		fp = &dp[cd*6-1];
		if( num <= 6 )
			i = num-1;
d391 4
a394 4
			i = 5;
		for(; i>=0; i--,num--)   {
			scard.sc_fields[i][10] = '\0';	/* null OFF END */
			*fp-- = atof( scard.sc_fields[i] );
d396 1
d405 1
d421 1
a424 2
	if( getsoldata( dd, ncards[cur_type]*6, sol_num ) < 0 )
		return(-1);
a425 2
	col_pr( name );

d429 2
d440 2
d454 2
d468 2
d473 2
d479 2
d488 2
d496 2
d501 3
d507 3
a509 1
		/* base height, a, b, c, d */
d514 3
d521 2
d531 2
d542 2
d549 1
d556 2
d568 1
d572 1
a572 1
		/* fall through */
d577 2
d580 1
d599 2
@


1.10
log
@Created getsoldata()
@
text
@d29 4
a460 1

a461 33
 * Input Vector Fields
 */
#define Fi	iv+(i-1)*3
#define F1	iv+(1-1)*3
#define F2	iv+(2-1)*3
#define F3	iv+(3-1)*3
#define F4	iv+(4-1)*3
#define F5	iv+(5-1)*3
#define F6	iv+(6-1)*3
#define F7	iv+(7-1)*3
#define F8	iv+(8-1)*3
/*
 * Output vector fields
 */
#define Oi	ov+(i-1)*3
#define O1	ov+(1-1)*3
#define O2	ov+(2-1)*3
#define O3	ov+(3-1)*3
#define O4	ov+(4-1)*3
#define O5	ov+(5-1)*3
#define O6	ov+(6-1)*3
#define O7	ov+(7-1)*3
#define O8	ov+(8-1)*3
#define O9	ov+(9-1)*3
#define O10	ov+(10-1)*3
#define O11	ov+(11-1)*3
#define O12	ov+(12-1)*3
#define O13	ov+(13-1)*3
#define O14	ov+(14-1)*3
#define O15	ov+(15-1)*3
#define O16	ov+(16-1)*3

/*
d466 1
a466 1
convert( cur_type, sol_work, solid_type )
d468 1
a468 1
int	sol_work;
d471 3
a473 9
	struct solids	in;
	static struct solids out;
	register float *iv;
	register float *ov;
	static float r1, r2;
	static float work[3];
	static float m1, m2, m3, m4;	/* Magnitude temporaries */
	static float m5, m6;	/* TOR temporaries */
	static float r3,r4; /* magnitude temporaries */
d477 1
d479 1
a479 3
	in.s_id = SOLID;
	in.s_type = cur_type;
	in.s_num = sol_work;
d481 3
a483 6
	namecvt( in.s_num, name, 's' );
	NAMEMOVE( name, in.s_name );

	for(i=0; i<24; i++)
		dd[i] = 0.0;
	if( getsoldata( dd, ncards[in.s_type]*6, in.s_num ) < 0 )
a484 2
	for(i=0; i<24; i++)
		in.s_values[i] = dd[i];
d488 1
a488 2
	iv = &in.s_values[0];
	ov = &out.s_values[0];
a489 2
	switch( in.s_type )  {

d494 3
a496 4
			VSET( min, iv[0], iv[2], iv[4] );
			VSET( max, iv[1], iv[3], iv[5] );
			mk_rpp( outfp, name, min, max );
			return;
d500 4
a503 9
		VMOVE( O1, F1 );
		VADD2( O2, F1, F3 );
		VADD3( O3, F1, F3, F2 );
		VADD2( O4, F1, F2 );
		VADD2( O5, F1, F4 );
		VADD3( O6, F1, F4, F3 );
		VADD4( O7, F1, F4, F3, F2 );
		VADD3( O8, F1, F4, F2 );
		goto ccommon;
d505 6
d512 4
a515 15
		VMOVE( O1, F1 );
		VADD2( O2, F1, F3 );
		VMOVE( O3, O2 );
		VADD2( O4, F1, F2 );
		VADD2( O5, F1, F4 );
		VADD3( O6, F1, F4, F3 );
		VMOVE( O7, O6 );
		VADD3( O8, F1, F4, F2 );
	ccommon:
		VMOVE( F1, O1 );
		for( i=2; i<=8; i++ )  {
			VSUB2( Fi, Oi, O1 );
		}
		in.s_type = GENARB8;
		break;
d517 6
d524 1
a524 6
	arb8common:
		for(i=2; i<=8; i++)  {
			VSUB2( Fi, Fi, F1 );
		}
		in.s_type = GENARB8;
		break;
d527 2
a528 3
		VMOVE( F8, F5 );
		in.s_type = ARB8;
		goto arb8common;
d531 5
a535 6
		/* Note that the ordering is important, as data is in F5, F6 */
		VMOVE( F8, F6 );
		VMOVE( F7, F6 );
		VMOVE( F6, F5 );
		in.s_type = ARB8;
		goto arb8common;
d538 4
a541 5
		VMOVE( F6, F5 );
		VMOVE( F7, F5 );
		VMOVE( F8, F5 );
		in.s_type = ARB8;
		goto arb8common;
d544 1
a544 8
		/* Order is important, data is in F4 */
		VMOVE( F8, F4 );
		VMOVE( F7, F4 );
		VMOVE( F6, F4 );
		VMOVE( F5, F4 );
		VMOVE( F4, F1 );
		in.s_type = ARB8;
		goto arb8common;
d547 1
a547 3
		r1 = iv[6];	/* R */
		r2 = iv[6];
		goto trccommon;		/* sorry */
d550 3
a552 4
		VMOVE( F5, F3 );
		VMOVE( F6, F4 );
		in.s_type = GENTGC;
		break;
a553 8
		/*
		 * For the TRC, if the V vector (F1) is of zero length,
		 * a divide by zero will occur when scaling by the magnitude.
		 * We add the vector [PI, PI, PI] to V to produce a unique
		 * (and most likely non-zero) resultant vector.  This will
		 * do nicely for purposes of cross-product.
		 */

d555 1
a555 10
		r1 = iv[6];	/* R1 */
		r2 = iv[7];	/* R2 */
	trccommon:
		VMOVE( work, F1 );
		work[0] += PI;
		work[1] += PI;
		work[2] += PI;
		VCROSS( F3, work, F2 );
		m1 = MAGNITUDE( F3 );
		VSCALE( F3, F3, r1/m1 );
a556 9
		VCROSS( F4, F2, F3 );
		m2 = MAGNITUDE( F4 );
		VSCALE( F4, F4, r1/m2 );

		VSCALE( F5, F3, r2/r1 );
		VSCALE( F6, F4, r2/r1 );
		in.s_type = GENTGC;
		break;

d558 6
a563 5
		r1 = iv[12];	/* P */
		VSCALE( F5, F3, (1.0/r1) );
		VSCALE( F6, F4, (1.0/r1) );
		in.s_type = GENTGC;
		break;
d566 7
a572 6
		r1 = iv[12] / MAGNITUDE( F3 );	/* A/|A| * C */
		r2 = iv[13] / MAGNITUDE( F4 );	/* B/|B| * D */
		VSCALE( F5, F3, r1 );
		VSCALE( F6, F4, r2 );
		in.s_type = GENTGC;
		break;
d575 2
a576 7
		{
			double	center[3], radius;
			VMOVE( center, iv );
			radius = iv[3];		/* R */
			mk_sph( outfp, name, center, radius );
			return;
		}
d580 1
d583 2
a584 2
			 * fall through to ELL1 code.  Format of ELL is
			 * F1, F2, l
d587 1
a587 3
			r1 = iv[6];		/* length */
			VADD2( O1, F1, F2 );
			VSCALE( O1, O1, 0.5 );	/* O1 holds V */
d589 4
a592 4
			VSUB2( O3, F2, F1 );	/* O3 holds F2 -  F1 */
			m1 = MAGNITUDE( O3 );
			r2 = 0.5 * r1 / m1;
			VSCALE( O2, O3, r2 );	/* O2 holds A */
d594 3
a596 3
			iv[6] = sqrt( MAGSQ( O2 ) - (m1 * 0.5)*(m1 * 0.5) );	/* r */
			VMOVE( F1, O1 );	/* Move V */
			VMOVE( F2, O2 );	/* Move A */
d604 4
a607 3
		/* GENELL is V, A, B, C */
		r1 = iv[6];		/* R */
		VMOVE( work, F1 );
d611 3
a613 3
		VCROSS( F3, work, F2 );		/* See the TRC comments */
		m1 = MAGNITUDE( F3 );
		VSCALE( F3, F3, r1/m1 );
d615 3
a617 5
		VCROSS( F4, F2, F3 );
		m2 = MAGNITUDE( F4 );
		VSCALE( F4, F4, r1/m2 );
		in.s_type = GENELL;
		break;
d619 3
d623 2
a624 18
		{
			double	center[3], norm[3], r1, r2;

			VMOVE( center, &iv[0] );
			VMOVE( norm, &iv[3] );
			r1=iv[6];	/* Dist from end of V to center of (solid portion) of TORUS */
			r2=iv[7];	/* Radius of solid portion of TORUS */

			mk_tor( outfp, name, center, norm, r1, r2 );
			return;
		}

	default:
		/*
		 * We should never reach here
		 */
		printf("convert:  no support for type %d\n", in.s_type );
		return;
d627 5
a631 3
	/* Common code to write out the record */
	/* XXX error checking? */
	fwrite( (char *)&in, sizeof(union record), 1, outfp );
@


1.9
log
@Code shuffle
@
text
@d406 19
d426 32
a510 2
	int	cd;
	float	*fp;
d512 1
d522 5
a526 26
		in.s_values[i] = 0.0;

	for( cd=1; cd <= ncards[in.s_type]; cd++ )  {
		if( cd != 1 )  {
			if( getline( &scard, sizeof(scard), "solid continuation card" ) == EOF )  {
				printf("too few cards for solid %d\n",
					in.s_num);
				return	0;
			}
			/* continuation card
			 * solid type should be blank 
			 */
			if( (version==5 && ((char *)&scard)[5] != ' ' ) ||
			    (version==4 && ((char *)&scard)[3] != ' ' ) )  {
				printf("solid %d continuation card solid type non-blank, ='%s'\n",
					in.s_num, solid_type);
				return 0;
			}
		}

		fp = &in.s_values[cd*6-1];
		for(i=5; i>=0; i--)   {
			scard.sc_fields[i][10] = '\0';	/* null OFF END */
			*fp-- = atof( scard.sc_fields[i] );
		}
	}
@


1.8
log
@changed getcard() to have extra args
@
text
@a398 1

d400 1
a401 34
		solidp->s_id = SOLID;
		solidp->s_type = cur_type;
		solidp->s_num = sol_work;

		namecvt( solidp->s_num, solidp->s_name, 's' );

		for(i=0; i<24; i++)
			solidp->s_values[i] = 0.0;

		for( cd=1; cd <= ncards[solidp->s_type]; cd++ )  {
			if( cd != 1 )  {
				if( getline( &scard, sizeof(scard), "solid continuation card" ) == EOF )  {
					printf("too few cards for solid %d\n",
						solidp->s_num);
					return	0;
				}
				/* continuation card
				 * solid type should be blank 
				 */
				if( (version==5 && ((char *)&scard)[5] != ' ' ) ||
				    (version==4 && ((char *)&scard)[3] != ' ' ) )  {
					printf("solid %d continuation card solid type non-blank, ='%s'\n",
						solidp->s_num, solid_type);
					return 0;
				}
			}

			fp = &solidp->s_values[cd*6-1];
			for(i=5; i>=0; i--)   {
				scard.sc_fields[i][10] = '\0';	/* null OFF END */
				*fp-- = atof( scard.sc_fields[i] );
			}
		}
		convert( solidp, solidp->s_name );
d445 4
a448 3
convert( in, name )
struct solids *in;
char	*name;
d450 1
d460 3
d464 35
d501 1
a501 1
	iv = &in->s_values[0];
d504 1
a504 1
	switch( in->s_type )  {
d541 1
a541 1
		in->s_type = GENARB8;
d549 1
a549 1
		in->s_type = GENARB8;
d554 1
a554 1
		in->s_type = ARB8;
d562 1
a562 1
		in->s_type = ARB8;
d569 1
a569 1
		in->s_type = ARB8;
d579 1
a579 1
		in->s_type = ARB8;
d590 1
a590 1
		in->s_type = GENTGC;
d619 1
a619 1
		in->s_type = GENTGC;
d626 1
a626 1
		in->s_type = GENTGC;
d634 1
a634 1
		in->s_type = GENTGC;
d686 1
a686 1
		in->s_type = GENELL;
d706 1
a706 1
		printf("convert:  no support for type %d\n", in->s_type );
d712 1
a712 1
	fwrite( (char *)in, sizeof(union record), 1, outfp );
@


1.7
log
@rpp and torus now made with libwdb
@
text
@d180 1
a180 1
	if( (i = getline( &scard )) == EOF )  {
d291 1
a291 1
				if( getline(&scard) == EOF)
d413 1
a413 1
				if( getline( &scard ) == EOF )  {
@


1.6
log
@First conversion to libwdb:  the sphere
@
text
@a440 7
#define Xmin	iv[0]
#define Xmax	iv[1]
#define Ymin	iv[2]
#define Ymax	iv[3]
#define Zmin	iv[4]
#define Zmax	iv[5]

d501 2
a502 9
		VSET( O1, Xmax, Ymin, Zmin );
		VSET( O2, Xmax, Ymax, Zmin );
		VSET( O3, Xmax, Ymax, Zmax );
		VSET( O4, Xmax, Ymin, Zmax );
		VSET( O5, Xmin, Ymin, Zmin );
		VSET( O6, Xmin, Ymax, Zmin );
		VSET( O7, Xmin, Ymax, Zmax );
		VSET( O8, Xmin, Ymin, Zmax );
		goto ccommon;
d504 6
d684 2
a685 4
		r1=iv[6];	/* Dist from end of V to center of (solid portion) of TORUS */
		r2=iv[7];	/* Radius of solid portion of TORUS */
		r3=r1-r2;	/* Radius to inner circular edge */
		r4=r1+r2;	/* Radius to outer circular edge */
d687 4
a690 8
		/*
		 * To allow for V being (0,0,0), for VCROSS purposes only,
		 * we add (PI,PI,PI).  THIS DOES NOT GO OUT INTO THE FILE!!
		 */
		VMOVE(work,F1);
		work[0] +=PI;
		work[1] +=PI;
		work[2] +=PI;
d692 3
a694 25
		m2 = MAGNITUDE( F2 );	/* F2 is NORMAL to Torus, with Radius length */
		VSCALE( F2, F2, r2/m2 );

		/* F3, F4 are perpendicular, goto center of Torus (solid part), for top/bottom */
		VCROSS(F3,work,F2);
		m1=MAGNITUDE(F3);
		VSCALE(F3,F3,r1/m1);
 
		VCROSS(F4,F3,F2);
		m3=MAGNITUDE(F4);
		VSCALE(F4,F4,r1/m3);

		m5 = MAGNITUDE(F3);
		m6 = MAGNITUDE( F4 );

		/* F5, F6 are perpindicular, goto inner edge of ellipse */
		VSCALE( F5, F3, r3/m5 );
		VSCALE( F6, F4, r3/m6 );

		/* F7, F8 are perpendicular, goto outer edge of ellipse */
		VSCALE( F7, F3, r4/m5 );
		VSCALE( F8, F4, r4/m6 );
 
		in->s_type=TOR;
		break;
@


1.5
log
@This version uses in-memory region membership lists,
and seems to work.
@
text
@d435 1
a435 1
		convert( solidp );
d486 1
a486 1
convert( in )
d488 1
d500 2
d640 7
a646 6
		r1 = iv[3];		/* R */
		VSET( F2, r1, 0, 0 );
		VSET( F3, 0, r1, 0 );
		VSET( F4, 0, 0, r1 );
		in->s_type = GENELL;
		break;
a742 2

	col_pr( in->s_name );
@


1.4
log
@More improvements
@
text
@d3 1
a3 1
 *			C O N V E R T . C
d23 1
d25 1
d32 2
d35 405
@


1.3
log
@Progress is being made
@
text
@d27 1
d72 5
d132 1
a132 1
		return;
d140 1
a140 1
		return;
d181 1
a181 1
		return;
d210 1
a210 1
		return;
d217 1
a217 1
		return;
d225 1
a225 1
		return;
d233 1
a233 1
		return;
d276 1
a276 1
		return;
d317 1
a317 1
		return;
d320 5
a324 1
		break;
d327 5
a331 4
	/*
	 * We should never reach here
	 */
	printf("convert:  no support for type %d\n", in->s_type );
@


1.2
log
@Merged CVT4 and CVT5
@
text
@d27 1
a27 1
 double sqrt();
d230 10
a239 12
#ifdef GIFT5
		/* NO ELL's in gift5  -  fall through to ELL1 */
#else
		/*
		 * For simplicity, we convert ELL to ELL1, then
		 * fall through to ELL1 code.  Format of ELL is
		 * F1, F2, l
		 * ELL1 format is V, A, r
		 */
		r1 = iv[6];		/* length */
		VADD2( O1, F1, F2 );
		VSCALE( O1, O1, 0.5 );	/* O1 holds V */
d241 4
a244 4
		VSUB2( O3, F2, F1 );	/* O3 holds F2 -  F1 */
		m1 = MAGNITUDE( O3 );
		r2 = 0.5 * r1 / m1;
		VSCALE( O2, O3, r2 );	/* O2 holds A */
d246 6
a251 3
		iv[6] = sqrt( MAGSQ( O2 ) - (m1 * 0.5)*(m1 * 0.5) );	/* r */
		VMOVE( F1, O1 );	/* Move V */
		VMOVE( F2, O2 );	/* Move A */
a252 1
#endif
d254 2
a255 1
	case ELL1:
@


1.1
log
@Initial revision
@
text
@d24 2
a25 2
#include "ged_types.h"
#include "3d.h"
d230 3
d252 1
d313 1
a313 1
		return;
d319 1
a319 1
	printf("convert:  fell out of loop\n");
@
