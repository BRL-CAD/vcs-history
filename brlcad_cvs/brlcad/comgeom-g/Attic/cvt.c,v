head	11.15;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.6.2
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.6
	phong-branch:11.11.0.4
	photonmap-branch:11.11.0.2
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.2
	offsite-5-3-pre:11.5
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.24.04.16.29;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.07.49.44;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.38.59;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2003.01.31.16.11.33;	author jra;	state Exp;
branches
	11.11.6.1;
next	11.10;

11.10
date	2002.08.20.17.07.20;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1;
next	11.9;

11.9
date	2002.08.15.20.54.32;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.11.05.21.20.05;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2001.05.16.21.37.11;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.12.14.40.20;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.20.19.40.57;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.20.18.36.36;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.07.10.23.48.31;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.15.18.35.39;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.06.49;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.09.19.08.21;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.48;	author mike;	state Rel4_0;
branches;
next	1.22;

1.22
date	91.06.13.02.57.59;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.06.12.22.28.50;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	90.10.17.23.20.18;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	90.10.17.22.57.35;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.10.16.21.07.34;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.02.27.20.10.54;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.02.10.02.34.25;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.02.08.00.27.58;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	89.12.29.22.40.18;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	89.12.08.05.20.28;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	89.11.30.03.57.37;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	89.11.30.03.51.38;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	89.11.30.03.40.20;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	89.11.30.02.40.21;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	89.11.27.23.29.18;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	89.11.03.04.13.28;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.11.03.03.44.15;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.11.03.01.25.55;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.11.02.23.07.40;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.11.02.16.57.50;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.10.31.17.40.06;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.31.15.19.27;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.00.33;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.15.53;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.40.28;	author morrison;	state Exp;
branches;
next	;

11.11.6.1
date	2004.02.12.19.40.42;	author erikg;	state Exp;
branches;
next	11.11.6.2;

11.11.6.2
date	2004.03.15.14.06.06;	author erikg;	state Exp;
branches;
next	;


desc
@cvt
@


11.15
log
@moved to src/comgeom-g
@
text
@/*
 *			C V T . C
 *
 *	This is the mainline for converting COM-GEOM
 * cards to a GED style database.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Original Version -
 *	February, 1980
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/comgeom-g/cvt.c,v 11.14 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "wdb.h"

/* defined in region.c */
extern void group_init(void);
extern int getregion(void);
extern void region_register(int reg_num, int id, int air, int mat, int los);
extern void group_write(void);

/* defined in read.c */
extern int getline(register char *cp, int buflen, char *title);

/* defined in solid.c */
extern void trim_trail_spaces(register char *cp);
extern int getsolid(void);

struct wmember	*wmp;	/* array indexed by region number */

int	version = 5;	/* v4 or v5 ? */
int	verbose = 0;	/* verbose = print a message on every item read */

char name_it[16];	/* stores argv if it exists and appends it
			to each name generated.*/

int	cur_col = 0;

FILE		*infp;
struct rt_wdb	*outfp;		/* Output file descriptor */

int	sol_total, sol_work;	/* total num solids, num solids processed */
int	reg_total;

extern void	getid(void);

void		col_pr(char *str);

static char usage[] = "\
Usage: comgeom-g [options] input_file output_file\n\
Options:\n\
	-v input_vers#		default is 5 (cg5)\n\
	-d debug_lvl\n\
	-s name_suffix\n\
";

int
get_args(int argc, register char **argv)
{
	register int	c;
	char		*file_name;

	while ( (c = getopt( argc, argv, "d:v:s:" )) != EOF )  {
		switch( c )  {
		case 'd':
			verbose = atoi(optarg);
			break;
		case 's':
			strncpy( name_it, optarg, sizeof(name_it) );
			break;
		case 'v':
			version = atoi(optarg);
			break;

		default:		/* '?' */
			return(0);
		}
	}

	if( optind+2 > argc )
		return(0);		/* FAIL */

	/* Input File */
	if( optind >= argc )  {
		return(0);		/* FAIL */
	} else {
		file_name = argv[optind++];
		if( (infp = fopen(file_name, "r")) == NULL )  {
			perror(file_name);
			return(0);
		}
	}

	/* Output File */
	if( optind >= argc )  {
		return(0);		/* FAIL */
	} else {
		file_name = argv[optind++];
		if( (outfp = wdb_fopen(file_name)) == NULL )  {
			perror(file_name);
			return(0);
		}
	}

	if ( argc > ++optind )
		(void)fprintf( stderr, "comgeom-g: excess argument(s) ignored\n" );

	return(1);		/* OK */
}


/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	register int i;
	char	ctitle[132];
	char	*title;
	char	units[16];

	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	if( version != 1 && version != 4 && version != 5 )  {
		fprintf(stderr,"version %d not supported\n", version );
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	printf("Reading version %d COMGEOM file\n", version );

	if( verbose )  {
		printf("COMGEOM input file must have this format:\n");
		switch(version)  {
		case 1:
			printf("     1.  title card\n");
			printf("     2.  solid table\n");
			printf("     3.  END\n");
			printf("     4.  region table\n");
			printf("     5.  END\n");
			break;
		case 4:
			printf("     1.  units & title card\n");
			printf("     2.  solid & region count card\n");
			printf("     3.  solid table\n");
			printf("     4.  region table\n");
			printf("     5.  -1\n");
			printf("     6.  blank\n");
		   	printf("     7.  region ident table\n\n");
			break;
		case 5:
			printf("     1.  units & title card\n");
			printf("     2.  solid & region count card\n");
			printf("     3.  solid table\n");
			printf("     4.  region table\n");
			printf("     5.  -1\n");
		   	printf("     6.  region ident table\n\n");
			break;
		}
	}

	group_init();

	/*
	 *  Read title card
	 */
	if( getline( ctitle, sizeof(ctitle), "title card" ) == EOF ) {
		printf("Empty input file:  no title record\n");
		exit(10);
	}

	title = NULL;
	switch( version )  {
	case 1:
		title = ctitle;
		strcpy( units, "in" );
		break;
	case 4:
	case 5:
		/* First 2 chars are units */
		units[0] = ctitle[0];
		units[1] = ctitle[1];
		units[2] = '\0';
		title = ctitle+3;
		break;
	}

	/* Drop leading blanks in title */
	while( isspace( *title ) )  title++;
	trim_trail_spaces( title );
	trim_trail_spaces( units );

	/* Convert units to lower case */
	{
		register char	*cp = units;
		while( *cp )  {
			if( isupper(*cp) )
				*cp = tolower(*cp);
			cp++;
		}
	}

	printf("Title: %s\n", title);
	printf("Units: %s\n", units);

	/* Before converting any geometry, establish the units conversion
	 * factor which all mk_* routines will apply.
	 */
	if( mk_conversion( units ) < 0 )  {
		printf("WARNING:  unknown units '%s', using inches\n", units);
		strcpy( units, "in" );
		(void)mk_conversion( units );
	}

	/* Output the MGED database header */
	if( mk_id_units( outfp, title, units ) < 0 )  {
		printf("Unable to write database ID, units='%s'\n", units);
		exit(1);
	}

	/*
	 *  Read control card, if present
	 */
	sol_total = reg_total = 0;
	switch( version )  {
	case 1:
		sol_total = reg_total = 9999;	/* Reads until 'END' rec */
		break;

	case 4:
		if( getline( ctitle, sizeof(ctitle), "control card" ) == EOF ) {
			printf("No control card .... STOP\n");
			exit(10);
		}
		sscanf( ctitle, "%20d%10d", &sol_total, &reg_total );
		break;
	case 5:
		if( getline( ctitle, sizeof(ctitle), "control card" ) == EOF ) {
			printf("No control card .... STOP\n");
			exit(10);
		}
		sscanf( ctitle, "%5d%5d", &sol_total, &reg_total );
		break;
	}

	if(verbose) printf("Expecting %d solids, %d regions\n", sol_total, reg_total);


	/*
	 *  SOLID TABLE
	 */
	if(verbose) printf("Primitive table\n");
	sol_work = 0;
	while( sol_work < sol_total ) {
		i = getsolid();
		if( i < 0 )  {
			printf("error converting primitive %d\n", sol_work);
			/* Should we abort here? */
			continue;
		}
		if( i > 0 ) {
			printf("\nprocessed %d of %d solids\n\n",sol_work,sol_total);
			if( sol_work < sol_total && version > 1 )  {
				printf("some solids are missing, aborting\n");
				exit(1);
			}
			break;		/* done */
		}
	}

	/* REGION TABLE */

	if(verbose)printf("\nRegion table\n");

	i = sizeof(struct wmember) * (reg_total+2);
	if( (wmp = (struct wmember *)bu_calloc(reg_total+2, sizeof( struct wmember ), "wmp")) == (struct wmember *)0 )  {
		printf("malloc(%d) failed\n", i );
		exit(42);
	}
	for( i=reg_total+1; i>=0; i-- )  {
		RT_LIST_INIT( &wmp[i].l );
	}

	cur_col = 0;
	if( getregion() < 0 )  exit(10);

	if( version == 1 )  {
		for( i=1; i < reg_total; i++ )  {
			region_register( i, 0, 0, 0, 0 );
		}
	} else {
		if( version == 4 )  {
			char	dummy[88];
			/* read the blank card (line) */
			(void)getline( dummy, sizeof(dummy), "blank card" );
		}

		if(verbose) printf("\nRegion ident table\n");
		getid();
	}

	if(verbose) printf("\nGroups\n");
	cur_col = 0;
	group_write();
	if(verbose) printf("\n");

	return(0);		/* exit(0) */
}

/*
 *			C O L _ P R
 */
void
col_pr(char *str)
{
	printf("%s", str);
	cur_col += strlen(str);
	while( cur_col < 78 && ((cur_col%10) > 0) )  {
		putchar(' ');
		cur_col++;
	}
	if( cur_col >= 78 )  {
		printf("\n");
		cur_col = 0;
	}
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/comgeom-g/cvt.c,v 11.13 2004/04/05 07:49:44 morrison Exp $ (BRL)";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.11 2003/01/31 16:11:33 jra Exp $ (BRL)";
d44 4
a47 4
extern void group_init();
extern int getregion();
extern void region_register();
extern void group_write();
d50 1
a50 1
extern int getline();
d53 2
a54 2
extern void trim_trail_spaces();
extern int getsolid();
d72 1
a72 1
extern void	getid();
d74 1
a74 1
void		col_pr();
d85 1
a85 2
get_args( argc, argv )
register char **argv;
d143 1
a143 2
main( argc, argv )
char **argv;
d345 1
a345 2
col_pr( str )
char	*str;
@


11.11
log
@Mods to handle long names
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.10 2002/08/20 17:07:20 jra Exp $ (BRL)";
@


11.11.6.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.12 2004/02/02 17:38:59 morrison Exp $ (BRL)";
@


11.11.6.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.11.6.1 2004/02/12 19:40:42 erikg Exp $ (BRL)";
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.8 2001/11/05 21:20:05 morrison Exp $ (BRL)";
d309 1
a309 1
	if( (wmp = (struct wmember *)malloc(i)) == (struct wmember *)0 )  {
@


11.10.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/comgeom-g/cvt.c,v 11.12 2004/02/02 17:38:59 morrison Exp $ (BRL)";
d309 1
a309 1
	if( (wmp = (struct wmember *)bu_calloc(reg_total+2, sizeof( struct wmember ), "wmp")) == (struct wmember *)0 )  {
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.10 2002/08/20 17:07:20 jra Exp $ (BRL)";
d44 4
a47 4
extern void group_init(void);
extern int getregion(void);
extern void region_register(int reg_num, int id, int air, int mat, int los);
extern void group_write(void);
d50 1
a50 1
extern int getline(register char *cp, int buflen, char *title);
d53 2
a54 2
extern void trim_trail_spaces(register char *cp);
extern int getsolid(void);
d72 1
a72 1
extern void	getid(void);
d74 1
a74 1
void		col_pr(char *str);
d85 2
a86 1
get_args(int argc, register char **argv)
d144 2
a145 1
main(int argc, char **argv)
d347 2
a348 1
col_pr(char *str)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d307 1
a307 1
	if( (wmp = (struct wmember *)bu_calloc(reg_total+2, sizeof( struct wmember ), "wmp")) == (struct wmember *)0 )  {
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 4
a47 4
extern void group_init(void);
extern int getregion(void);
extern void region_register(int reg_num, int id, int air, int mat, int los);
extern void group_write(void);
d50 1
a50 1
extern int getline(register char *cp, int buflen, char *title);
d53 2
a54 2
extern void trim_trail_spaces(register char *cp);
extern int getsolid(void);
d72 1
a72 1
extern void	getid(void);
d74 1
a74 1
void		col_pr(char *str);
d85 2
a86 1
get_args(int argc, register char **argv)
d144 2
a145 1
main(int argc, char **argv)
d347 2
a348 1
col_pr(char *str)
@


11.8
log
@Solid to Primitive naming convention conversions
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.7 2001/05/16 21:37:11 morrison Exp $ (BRL)";
d44 4
a47 4
extern void group_init();
extern int getregion();
extern void region_register();
extern void group_write();
d50 1
a50 1
extern int getline();
d53 2
a54 2
extern void trim_trail_spaces();
extern int getsolid();
d72 1
a72 1
extern void	getid();
d74 1
a74 1
void		col_pr();
d85 1
a85 2
get_args( argc, argv )
register char **argv;
d143 1
a143 2
main( argc, argv )
char **argv;
d345 1
a345 2
col_pr( str )
char	*str;
@


11.7
log
@PRODUCTION optimizations
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.6 2001/04/12 14:40:20 bparker Exp $ (BRL)";
d285 1
a285 1
	if(verbose) printf("Solid table\n");
d290 1
a290 1
			printf("error converting solid %d\n", sol_work);
@


11.6
log
@*- provide extern declarations for functions
   that need them
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.5 2000/07/20 19:40:57 mike Exp $ (BRL)";
d205 1
@


11.5
log
@
Missed part of LIBWDB conversion
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.4 2000/07/20 18:36:36 mike Exp $ (BRL)";
d42 13
@


11.4
log
@
Some lint.  New libwdb conversion
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.3 2000/07/10 23:48:31 mike Exp $ (BRL)";
d100 1
a100 4
		if( isatty(fileno(stdin)) )
			return(0);
		infp = stdin;
		optind++;
d111 1
a111 4
		if( isatty(fileno(stdout)) )
			return(0);
		outfp = stdout;
		optind++;
d114 1
a114 1
		if( (outfp = fopen(file_name, "w")) == NULL )  {
@


11.3
log
@
lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/comgeom-g/cvt.c,v 11.2 1996/07/15 18:35:39 jra Exp $ (BRL)";
d53 2
a54 2
FILE	*infp;
FILE	*outfp;		/* Output file descriptor */
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 11.1 1995/01/04 10:06:49 mike Rel4_4 jra $ (BRL)";
d40 1
a40 1
#include "rtlist.h"
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 10.2 94/08/09 19:08:21 gdurf Exp $ (BRL)";
d61 1
d338 1
@


10.2
log
@Factored ifdefs
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 10.1 1991/10/12 06:44:48 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 1.22 91/06/13 02:57:59 mike Exp $ (BRL)";
d26 2
d30 1
a30 1
#ifdef SYSV
@


1.22
log
@Changed to use new units support
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 1.21 91/06/12 22:28:50 mike Exp $ (BRL)";
@


1.21
log
@lint
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 1.20 90/10/17 23:20:18 mike Exp $ (BRL)";
d198 1
a198 1
		strcpy( units, "in" );		/* XXX is this right? */
d215 10
d233 2
a234 1
		(void)mk_conversion( "inches" );
d238 4
a241 2
	mk_id( outfp, title );

@


1.20
log
@Trimmed spaces from title card
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 1.19 90/10/17 22:57:35 mike Exp $ (BRL)";
d28 5
a32 1
#include <string.h>
d35 1
a36 1
#include "machine.h"
a39 4

extern int	getopt();
extern char	*optarg;
extern int	optind;
@


1.19
log
@Modified usage message
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 1.18 90/10/16 21:07:34 mike Exp $ (BRL)";
d212 2
@


1.18
log
@Converted to new linked lists and rtlist.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/comgeom-g/RCS/cvt.c,v 1.17 90/02/27 20:10:54 mike Exp $ (BRL)";
d61 6
a66 2
Usage: comgeom-g [-d debug_lvl] [-v version#] [-s name_suffix]\n\
	input_file output_file\n";
@


1.17
log
@Cleaned up some lint
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: cvt.c,v 1.16 90/02/10 02:34:25 mike Locked $ (BRL)";
d34 1
d284 1
a284 1
		wmp[i].wm_forw = wmp[i].wm_back = &wmp[i];
@


1.16
log
@Added support for "version 1" comgeom files,
which are the DoE/MORSE format, which I believe to be the
original MAGIC format (although I have not checked).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: cvt.c,v 1.15 90/02/08 00:27:58 mike Locked $ (BRL)";
d31 1
d56 1
d58 1
d63 1
d128 1
a132 1
	register float *op;
a289 1
		register int i;
d297 1
a297 1
			getline( dummy, sizeof(dummy), "blank card" );
d309 1
a309 1
	exit(0);
@


1.15
log
@Added call to mk_conversion(), to establish global units conversion
down in libwdb.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: cvt.c,v 1.14 89/12/29 22:40:18 mike Locked $ (BRL)";
d27 1
d130 1
d138 1
a138 1
	if( version != 4 && version != 5 )  {
d148 14
a161 6
		printf("     1.  title card\n");
		printf("     2.  control card\n");
		printf("     3.  solid table\n");
		printf("     4.  region table\n");
		printf("     5.  -1\n");
		if( version == 4 )
d163 11
a173 1
	   	printf("     7.  region ident table\n\n");
d179 1
a179 1
	 *  Read title
d186 14
a199 3
	/* First 2 chars are units */
	printf("Units: %2.2s\n", ctitle);
	printf("Title: %s\n", ctitle+2);
d201 6
d210 4
a213 5
	units[0] = ctitle[0];
	units[1] = ctitle[1];
	units[2] = '\0';
	if( mk_conversion( units ) < 0 )
		printf("WARNING:  unknown units '%s', using MM\n", units);
d216 1
a216 1
	mk_id( outfp, ctitle+3 );
d220 1
a220 1
	 *  Read control card
d222 5
a226 1
	sol_total = 0;
d228 14
a241 3
	if( getline( ctitle, sizeof(ctitle), "control card" ) == EOF ) {
		printf("No control card .... STOP\n");
		exit(10);
a243 5
	if( version == 5 )  {
		sscanf( ctitle, "%5d%5d", &sol_total, &reg_total );
	} else {
		sscanf( ctitle, "%20d%10d", &sol_total, &reg_total );
	}
d261 1
a261 1
			if( sol_work < sol_total )  {
d285 14
a298 4
	if( version == 4 )  {
		char	dummy[88];
		/* read the blank card (line) */
		getline( dummy, sizeof(dummy), "blank card" );
a299 3

	if(verbose) printf("\nRegion ident table\n");
	getid();
@


1.14
log
@Added header.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d128 2
a129 1
	char ctitle[132];
d170 11
a180 1
	mk_id( outfp, ctitle+2 );
@


1.13
log
@Default is now to be quiet;  verbose debugging can be enabled with
the -d flag.
@
text
@d1 3
a3 1
/*			C V T . C
d6 15
a20 13
 * Ballistic Research Laboratory
 * February, 1980
Date	Name	REVISION HISTORY
March 81  CAS	Added processing for ARS
09/22/81  MJM	Converted to matrix transformations.
8205.20	Bob S.	Fixed the name generation.  It seems that when a zero
			is encountered CVT skips the rest of the digits
			when converting from an integer to a string.
			I am useing F2A to do the conversion.
			Also Keith wants a string appended to the
			output name. QED
8205.21 Bob S.	Appending the string to the g recoreds.
			I did this one the hard way.
d22 4
@


1.12
log
@Printing neatened
@
text
@d33 1
a33 1
int	verbose = 1;	/* verbose = print a message on every item read */
d48 1
a48 1
Usage: comgeom-g [-q] [-v version#] [-s name_suffix]\n\
d57 1
a57 1
	while ( (c = getopt( argc, argv, "qv:s:" )) != EOF )  {
d59 2
a60 2
		case 'q':
			verbose = 0;
@


1.11
log
@Slightly nicer printing
@
text
@d179 1
a179 1
	printf("Expecting %d solids, %d regions\n", sol_total, reg_total);
d185 1
a185 1
	printf("processing solid table\n");
d206 1
a206 1
	printf("\nProcessing region table\n");
d226 1
a226 1
	printf("\nProcessing region ident table\n");
d229 1
a229 1
	printf("\nProducing groups\n");
d232 3
a234 1
	printf("\n");
@


1.10
log
@Added -q (quiet) flag to suppress the normally verbose output.
@
text
@d133 1
a133 4
	if( version == 5 )
		printf("\n**** CVT5: 12Jun84 ****\n\n");
	else
		printf("\n**** CVT4: 12Jun84 ****\n\n");
d135 11
a145 9
	printf("COMGEOM input file must have this format:\n");
	printf("     1.  title card\n");
	printf("     2.  control card\n");
	printf("     3.  solid table\n");
	printf("     4.  region table\n");
	printf("     5.  -1\n");
	if( version == 4 )
		printf("     6.  blank\n");
   	printf("     7.  region ident table\n\n");
d158 2
a159 1
	printf("Units: %2.2s  Title: %s\n",ctitle, ctitle+2);
@


1.9
log
@Changed to new return codes from getsolid().
@
text
@d33 1
d48 1
a48 1
Usage: comgeom-g [-v version#] [-s name_suffix]\n\
d57 1
a57 1
	while ( (c = getopt( argc, argv, "v:s:" )) != EOF )  {
d59 3
@


1.8
log
@Changed to using getopt().
Changed getline() to take extra args.
@
text
@d183 8
a190 2
	while(1) {
		if( (i = getsolid()) == 0 ) {
d192 4
@


1.7
log
@This version works nicely
Fast, too
@
text
@d26 4
d32 1
a32 1
int	version;	/* v4 or v5 ? */
d45 63
d116 1
a116 1
	char ctitle[80];
d118 3
a120 4
	if( ! (argc == 3 || argc == 4) )
	{
		printf(	"Usage:  comg-g [opts] input_file output_file [name_suffix]\n" );
		exit(10);
d123 4
a126 10
	version = 5;	/* XXX should be -v option */

		/* get postfix, else use it as a null string.*/
	if( argc == 4 )		strncpy( name_it, argv[3], 16 );
	else			strncpy( name_it, "", 16 );
	

	if( (infp = fopen( argv[1], "r" )) == NULL )  {
		perror( argv[1] );
		exit(10);
a127 4
	if( (outfp = fopen( argv[2], "w" )) == NULL )  {
		perror( argv[2] );
		exit( 10 );
	}
d149 1
a149 1
	if( getline( ctitle ) == EOF ) {
d165 1
a165 1
	if( getline( ctitle ) == EOF ) {
d209 1
a209 1
		getline( dummy );
@


1.6
log
@This version uses in-memory region membership lists,
and seems to work.
@
text
@a31 1
long tell();
d33 1
a33 2
#define NUMPERCOL 8
int	nclm = 0;
d38 1
a38 1
int sol_total, sol_work;	/* total num solids, num solids processed */
d41 3
a43 3
long regionpos;
long endpos;

d136 1
a136 1
	printf("processing region table\n");
a138 1
printf("malloc for %d\n", i);
d147 1
a147 1
	nclm = 0;
a149 3

	/* REGION IDENT TABLE */

d156 2
a157 1
	printf("\nprocessing region ident table\n");
d159 2
a160 7
	while( 1 ) {
		if( (i = getid()) == 0 )   /* finished */
			break;
	}

	printf("producing groups\n");
	nclm = 0;
d165 3
d171 7
a177 2
	printf("%s \t", str);
	if( ++nclm  >= NUMPERCOL ) {
d179 1
a179 1
		nclm = 0;
@


1.5
log
@More improvements
@
text
@a19 1
#include <signal.h>
a20 2
#include "./ged_types.h"
#include "./3d.h"
d22 6
a38 1
int updfd;		/* Update file descriptor */
d41 1
a42 2
union record record;

d51 1
a69 6
	/* The two separate opens here are necessary to get us
	 * file descriptors with independent file pointers.
	 * This will be very important when the summary combinations
	 * are to be produced.  updfd will be used to read the
	 * processed file, and outfp will be used to append to it.
	 */
a73 1
	updfd = open( argv[2], 2 );
d90 1
a90 2
	/* read title */
	get_title();
d92 17
a108 1
	/* read control card */
a109 1
	get_control();
d111 4
a114 1
	printf("Number Solids: %d\n\n",sol_total);
d116 11
a128 1
	/* SOLID TABLE */
d130 1
a130 1
		if( (i = getsolid(&record.s)) == 0 ) {
a135 4
	/* Record the region position */
	fflush(outfp);
	regionpos = tell( fileno(outfp) );

d139 11
a154 2
	fflush( outfp );
	lseek( updfd, regionpos, 0 );
d157 1
d159 1
a159 1
		getline( &record );
d165 1
a165 1
		if( (i = getid( &record )) == 0 )   /* finished */
d169 4
a172 47
	fflush(outfp);
	endpos = tell(fileno(outfp));

	/* Grouping time
	 * outfp is extended sequentially past endpos,
	 * while updfd is used to scan region combinations,
	 * and update group headers.
join( &record, "g00", 0, 0 );	join( &record, "g0", 1, 99 );
join( &record, "g1", 100, 199)	join( &record, "g2", 200, 299 );
join( &record, "g3", 300, 399 );join( &record, "g4", 400, 499 );
join( &record, "g5", 500, 599 );join( &record, "g6", 600, 699 );
join( &record, "g7", 700, 799 );join( &record, "g8", 800, 899 );
join( &record, "g9", 900, 999 );join( &record, "g10", 1000, 1999 );
join( &record, "g11", 2000, 2999 );join( &record, "g12", 3000, 3999 );
join( &record, "g13", 4000, 4999 );join( &record, "g14", 5000, 5999 );
join( &record, "g15", 6000, 6999 );join( &record, "g16", 7000, 7999 );
join( &record, "g17", 8000, 8999 );join( &record, "g18", 9000, 9999 );
join( &record, "g19", 10000, 32767 );		**************/

printf("producing groups\n");
	{ static int i,k,n;	  static char str[12], st[12];
		strcpy( str, "g00");
		strcat( str, name_it );
		join( &record, str, 0,0 );

		strcpy( str, "g0" );
		strcat( str, name_it );
		join( &record, str, 1, 99 );

		n = 100;
		for( i=1, k=100; i <= 9; ++i, k += n)
		{
			sprintf( str, "g%d%s", i, name_it );
			join( &record, str, k, (k + n -1) );
		}
		n = 1000;
		for( ; i <= 18; ++i, k += n)
		{
			sprintf( str, "g%d%s", i, name_it );
			join( &record, str, k, (k + n -1) );
		}

		strcpy( str, "g19" );
		strcat( str, name_it );
		join( &record, str, 10000, 32767 );

	}
a182 78
}

/*	J O I N			 */
join( rp, name, low, high )register union record *rp;
{ static struct members M;  static struct combination header;
  int count;  long joinpos;		/* where we joined in */
	int numb = 0;

  	printf("group(%s)  items(%d -> %d)\n",name,low,high);

	fflush( outfp );
	joinpos = tell( fileno(outfp) );
	lseek( updfd, regionpos, 0 );
	movename( name, header.c_name );
	header.c_id = COMB;	header.c_flags = 0;
	header.c_regionid = -1;	header.c_aircode = 0;
	header.c_length = 1;	header.c_num = 0;
	header.c_material = 0;
	header.c_los = 0;
	count = 0;
	while( tell( updfd ) < endpos )  {
		read( updfd, rp, sizeof record );
		if(		rp->c.c_regionid >= low
			&&	rp->c.c_regionid <= high )
		{
			M.m_id = MEMB;
			M.m_relation = UNION;
			mat_idn( M.m_mat );

			movename( rp->c.c_name, M.m_instname );
			M.m_brname[0] = 0;

			/* If this is first entry, write header */
			if( count++ == 0 )  {
				fwrite( &header, sizeof record, 1, outfp );
			}
			fwrite( &M, sizeof record, 1, outfp );

			printf("%s\t", M.m_instname );
			if( ++numb >= NUMPERCOL ) {
				printf("\n");
				numb = 0;
			}
		}

		/* Seek over the member elements of this
					(input) combination */
		lseek(	updfd,
			rp->c.c_length * ((long) sizeof record),
			1 );
	}

	/* If no members, we are done -- nothing has been written yet */
	if( count == 0 )
	{
		return;
	}

		/* go back to the COMB header and insert
					the proper length */
	lseek( updfd, joinpos, 0 );
	read( updfd, rp, sizeof record );
	rp->c.c_length = count;

	lseek( updfd, joinpos, 0 );
	write( updfd, rp, sizeof record );

	printf("\n");

}

/*		M O V E N A M E
 * Ensure that name field is null padded */
movename( from, to )
register char *from, *to;
{ register int i;
	for( i=0; i<16; i++ )		to[i] = 0;
	while( *to++ = *from++ );
@


1.4
log
@Progress is being made
@
text
@d32 1
d34 2
a35 1
int outfd;		/* Output file descriptor */
a49 1
	int nclm = 0;
d63 2
a64 3
	close( 0 );		/* Want input as std in */
	if( open( argv[1], 0 ) != 0 )
	{
d72 1
a72 1
	 * processed file, and outfd will be used to append to it.
d74 1
a74 1
	if( (outfd = creat( argv[2], 0644 )) < 0 )  {
a107 3
		for(i=0; i<24; i++)
			record.s.s_values[i] = 0.0;

a111 20

		if( i == 1 ) {
			/* solid type other than ARS */
			convert( &record.s );
			write(outfd, &record.s, sizeof record);
			printf("%s \t",record.s.s_name);
			if( ++nclm  >= NUMPERCOL ) {
				printf("\n");
				nclm = 0;
			}
		}
		if( i == 2 ) {
			/* ARS solid */
			if( ++nclm >= NUMPERCOL ) {
				printf("\n");
				nclm = 0;
			}
		}


d115 2
a116 1
	regionpos = tell( outfd );
d122 1
a122 9
	while(1) {
		if( getregion( &record.c ) == 0 )
			break;
		printf("%s \t",record.c.c_name);
		if( ++nclm  >= NUMPERCOL ) {
			printf("\n");
			nclm = 0;
		}
	}
d124 1
d126 1
d141 2
a142 1
	endpos = tell(outfd);
d145 1
a145 1
	 * outfd is extended sequentially past endpos,
d172 2
a173 4
		{	str[1] = '\0';
			f2a( (float)i, st, 12, 0 );
			strcat( str, st );
			strcat( str, name_it );
d178 2
a179 4
		{	str[1] = '\0';
			f2a( (float)i, st, 12, 0 );
			strcat( str, st );
			strcat( str, name_it );
d190 10
d208 2
a209 1
	joinpos = tell( outfd );
d231 5
a235 3
			if( count++ == 0 )
				write( outfd, &header, sizeof record );
			write( outfd, &M, sizeof record );
d243 2
a244 2
			/* Seek over the member elements of this
						(input) combination */
@


1.3
log
@Modified to use ordinary string library routines
@
text
@d25 2
a30 24
char *titles[] = {
	"holder",
	"RPP",		/* 1 */
	"BOX",
	"RAW",
	"ARB4",
	"ARB5",
	"ARB6",
	"ARB7",
	"ARB8",
	"ELL",
	"ELL1",
	"SPH",
	"RCC",
	"REC",
	"TRC",
	"TEC",
	"TOR",
	"TGC",
	"CONE",
	"ELLG",
	"8888",		/* 20 */
};

a42 2
int digits;

d52 1
a52 2
		printf(	"Usage:  comg-g [opts] input_file output_file" );
		printf(		" [ name_postfix ]\n");
d55 3
d80 4
a83 5
#ifdef GIFT5
	printf("\n**** CVT5: 12Jun84 ****\n\n");
#else
	printf("\n**** CVT4: 12Jun84 ****\n\n");
#endif
d91 2
a92 3
#ifndef GIFT4
	printf("     6.  blank\n");
#endif
d157 4
a160 4
#ifndef GIFT5
	/* read the blank card (line) */
	getline( &record );
#endif
@


1.2
log
@Merged CVT4 and CVT5
@
text
@d18 1
d214 1
a214 1
		strappend( str, name_it );
d218 1
a218 1
		strappend( str, name_it );
d225 2
a226 2
			strappend( str, st );
			strappend( str, name_it );
d233 2
a234 2
			strappend( str, st );
			strappend( str, name_it );
d239 1
a239 1
		strappend( str, name_it );
a317 14
}

/*			P U T C H A R
 * This is a special version of putchar which buffers
 * output a line-at-a-time.  Especially useful with
 * programs which only write lines, on DMA terminals. */
putchar( c )
register char c;
{ static char buffer[140];
 static char *bp = &buffer[0];
	if( (*bp++ = c) == '\n' || bp >= &buffer[140] )  {
		write( 1, buffer, bp-buffer );
		bp = &buffer[0];
	}
@


1.1
log
@Initial revision
@
text
@d21 2
a22 2
#include "ged_types.h"
#include "3d.h"
a53 2
int bang();

d75 1
a75 1
		printf(	"Usage:  cvt4 input_file output_file" );
d101 3
a103 5
/*
	setexit();
*/
	signal( 8, &bang );

d105 1
d107 1
a107 1
	printf("COMGEOM file must be as input to GIFT4:\n");
d113 1
d115 1
d179 2
d183 2
a243 9
bang()  {
	signal( 8, &bang );
	printf("floating point error!\n");
	exit(10);
/*
	reset();
*/
}

d268 1
a268 1
			mat_idn( &M.m_mat );
@
