head	14.15;
access;
symbols
	rel-7-10-4:14.13
	STABLE:14.13.0.2
	stable-branch:14.5
	rel-7-10-2:14.13
	rel-7-10-0:14.13
	rel-7-8-4:14.8
	rel-7-8-2:14.8
	rel-7-8-0:14.8
	trimnurbs-branch:14.7.0.2
	help:14.7
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.6
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.6
	rel-7-6-0:14.6
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.4
	bobWinPort:14.6.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.5
	rel-7-2-2:14.5
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:11.12
	rel-7-0-branch:11.12.0.2
	rel-7-0:11.12
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.8.10.3
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.2
	offsite-5-3-pre:11.6
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


14.15
date	2007.10.14.05.21.20;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.09.14.15.20.53;	author erikgreenwald;	state Exp;
branches;
next	14.13;

14.13
date	2007.02.15.21.46.51;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.02.15.19.40.54;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.02.14.09.37.55;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.23.01.13.19;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.20.14.36.39;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.04.05.17.09.53;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.10;	author brlcad;	state Exp;
branches
	14.7.2.1;
next	14.6;

14.6
date	2005.05.18.12.41.09;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.01.30.20.30.08;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.18.06.50.48;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.17.22.18.01;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.17.21.16.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.08;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.08.02.23.01.46;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.03.03.19.50.24;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.38.58;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.07.19;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.54.13;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2000.10.19.19.19.44;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	2000.10.18.18.10.32;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.07.05.18.00;	author cjohnson;	state Exp;
branches;
next	11.3;

11.3
date	2000.07.05.22.11.19;	author cjohnson;	state Exp;
branches;
next	11.2;

11.2
date	98.01.07.06.47.47;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.50.54;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.2;

10.2
date	94.08.11.13.14.48;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.16;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.05.45.13;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.24.57;	author mike;	state Rel3_0;
branches;
next	1.2;

1.2
date	88.10.03.14.01.10;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.10.01.00.48.33;	author kermit;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.26.16;	author mike;	state Rel4_5;
branches;
next	;

11.8.2.1
date	2002.09.19.18.00.32;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.15.49;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.40.26;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.19.40.40;	author erikg;	state Exp;
branches;
next	11.8.10.2;

11.8.10.2
date	2004.03.10.13.16.35;	author erikg;	state Exp;
branches;
next	11.8.10.3;

11.8.10.3
date	2004.03.15.14.06.04;	author erikg;	state Exp;
branches;
next	;

14.7.2.1
date	2006.04.07.19.24.49;	author jlowenz;	state Exp;
branches;
next	;


desc
@Program like pixdiff to compare images.
Only output is a message to stderr, and an exit code.
Used for benchmark scripts
@


14.15
log
@delint
@
text
@/*                        P I X C M P . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file pixcmp.c
 *
 *  Compute the difference between two .pix files.
 *  To establish context, a monochrome image is produced when there
 *  are no differences;  otherwise the channels that differ are
 *  highlighted on differing pixels.
 *
 *  This routine operates on a pixel-by-pixel basis, and thus
 *  is independent of the resolution of the image.
 *
 *  Author -
 *	Christopher Sean Morrison
 *	Charles M. Kennedy
 *	Michael John Muuss
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef _WIN32
#  include <unistd.h>
#endif

/* exit codes for argument processing errors */
#define OPTS_ERROR 127
#define FILE_ERROR 126

/* exit codes for normal operation */
#define OFF_BY_NONE 0
#define OFF_BY_ONE  1
#define OFF_BY_MANY 2


void
usage(const char *name)
{
    const char *unknown = "pixcmp";
    if (!name) {
	name = unknown;
    }
    fprintf(stderr, "Usage: %s [OPTIONS] FILE1 [FILE2 [SKIP1 [SKIP2]]]\n%s", name,
	    "Compare two PIX image files pixel by pixel.\n\n"
	    "  -l   List pixel numbers and values for all pixels that differ.\n"
	    "  -b   Output and process by bytes instead of pixels.\n"
	    "  -i SKIP\n"
	    "       Skip the first SKIP pixels of input (for FILE1 and FILE2)\n"
	    "  -i SKIP1:SKIP2\n"
	    "       Skip the first SKIP1 pixels in FILE1 and SKIP2 pixels in FILE2.\n"
	    "  -s   Silent output.  Only return an exit status.\n\n"
	    "If FILE is `-' or is missing, then input is read from standard input.\n"
	    "If the `-b' option is used, SKIP values are bytes instead of pixels.\n"
	    "Pixel numbers and bytes are indexed linearly from one.\n");
    return;
}


void
handle_i_opt(const char *arg, long *skip1, long *skip2)
{
    const char *endptr = arg;
    if ((arg == NULL) || ((skip1 == NULL) && (skip2 == NULL))){
	/* nothing to do */
	return;
    }
    while ((endptr != NULL) && (endptr[0] != ':') && (endptr[0] != '\0')) {
	endptr++;
    }
    if (endptr == arg) {
	/* probably empty string */
	if (skip2) {
	    endptr++;
	    *skip2 = strtol(endptr, NULL, 10);
	}
    } else if ((endptr == NULL) || (endptr[0] == '\0')) {
	/* no : found */
	if (skip2) {
	    *skip2 = strtol(arg, NULL, 10);
	}
	if (skip1) {
	    *skip1 = *skip2;
	}
    } else if (endptr[0] == ':') {
	/* found : */
	if (skip1) {
	    *skip1 = strtol(arg, NULL, 10);
	}
	if (skip2) {
	    endptr++; /* skip over : */
	    *skip2 = strtol(endptr, NULL, 10);
	}
    } else {
	fprintf(stderr, "Unexpected input processing [%s]\n", arg);
	exit(OPTS_ERROR);
    }
}

int
main(int argc, char *argv[])
{
    FILE *f1 = NULL;
    FILE *f2 = NULL;

    long matching = 0;
    long off1 = 0;
    long offmany = 0;

    int c;
    int list_pixel_values = 0;
    int print_bytes = 0;
    int silent = 0;
    long f1_skip = 0;
    long f2_skip = 0;

    long int bytes = 0;

    /* process opts */
    while ((c = getopt(argc, argv, "lbi:s")) != EOF) {
	switch (c) {
	    case 'l':
		list_pixel_values = 1;
		break;
	    case 'b':
		print_bytes = 1;
		break;
	    case 'i':
		handle_i_opt(optarg, &f1_skip, &f2_skip);
		break;
	    case 's':
		silent = 1;
		break;
	    default:
		fprintf(stderr, "\n");
		usage(argv[0]);
		exit(OPTS_ERROR);
	}
    }
    argc -= optind;
    argv += optind;

    /* validate what is left over */
    if( argc < 1 || argc > 4)  {
	fprintf(stderr, "ERROR: incorrect number of arguments provided\n\n");
	usage(argv[0]);
	exit(OPTS_ERROR);
    }
    if ((argc > 0 && !argv[0]) || (argc > 1 && !argv[1])) {
	fprintf(stderr, "ERROR: bad filename\n\n");
	usage(argv[0]);
	exit(OPTS_ERROR);
    }
    if ((argc > 2 && !argv[2]) || (argc > 3 && !argv[3])) {
	fprintf(stderr, "ERROR: bad skip value\n\n");
	usage(argv[0]);
	exit(OPTS_ERROR);
    }

    /* handle optional SKIP1 and SKIP2 following filenames */
    if (argc > 2) {
	char range[64] = {0};
	if (argc > 3) {
	    snprintf(range, 64, "%s:%s", argv[2], argv[3]);
	} else {
	    snprintf(range, 64, "%s", argv[2]);
	}
	handle_i_opt(range, &f1_skip, &f2_skip);
    }

    /*    printf("Skip from FILE1: %ld and from FILE2: %ld\n", f1_skip, f2_skip); */

    if (strcmp(argv[0], "-") == 0 ) {
	f1 = stdin;
    } else if ((f1 = fopen(argv[0], "r")) == NULL)  {
	perror(argv[1]);
	exit(FILE_ERROR);
    }
    if ((argc < 2) || (strcmp(argv[1], "-") == 0)) {
	f2 = stdin;
    } else if ((f2 = fopen(argv[1], "r")) == NULL) {
	perror(argv[1]);
	exit(FILE_ERROR);
    }

    if (!print_bytes) {
	f1_skip *= 3;
	f2_skip *= 3;
    }

    /* skip requested pixels/bytes in FILE1 */
    if (f1_skip && fseek(f1, f1_skip, SEEK_SET)) {
	fprintf(stderr,
		"ERROR: Unable to seek %ld %s%s in FILE1\n",
		f1_skip,
		print_bytes?"byte":"pixel",
		f1_skip==1?"":"s");
	perror("FILE1 fseek failure");
	exit(FILE_ERROR);
    }

    /* skip requested pixels in FILE2 */
    if (f2_skip && fseek(f2, f2_skip, SEEK_SET)) {
	fprintf(stderr,
		"ERROR: Unable to seek %ld %s%s in FILE2\n",
		f1_skip,
		print_bytes?"byte":"pixel",
		f1_skip==1?"":"s");
	perror("FILE2 fseek failure");
	exit(FILE_ERROR);
    }

    /* iterate over the pixels/bytes in the files */
    while ((!feof(f1) && !feof(f2)) &&
	   (!ferror(f1) && !ferror(f2))) {
	register int r1 , r2, g1, g2, b1, b2;
	r1 = r2 = g1 = g2 = b1 = b2 = -1;

	r1 = fgetc( f1 );
	r2 = fgetc( f2 );
	if (feof(f1) || feof(f2)) break;
	bytes++;
	if (!print_bytes) {
	    g1 = fgetc( f1 );
	    g2 = fgetc( f2 );
	    if (feof(f1) || feof(f2)) break;
	    bytes++;
	    b1 = fgetc( f1 );
	    b2 = fgetc( f2 );
	    if (feof(f1) || feof(f2)) break;
	    bytes++;
	}

	if ((r1 == r2) && (g1 == g2) && (b1 == b2)) {
	    matching++;
	    continue;
	}

	/* tabulate differing pixels */
	if (((r1 != r2) && (g1 == g2) && (b1 == b2)) ||
	    ((r1 == r2) && (g1 != g2) && (b1 == b2)) ||
	    ((r1 == r2) && (g1 == g2) && (b1 != b2))) {
	    /* off by one channel */
	    if (r1 != r2) {
		if ((r1 > r2 ? r1 - r2 : r2 - r1) > 1) {
		    offmany++;
		} else {
		    off1++;
		}
	    } else if (g1 != g2) {
		if ((g1 > g2 ? g1 - g2 : g2 - g1) > 1) {
		    offmany++;
		} else {
		    off1++;
		}
	    } else if (b1 != b2) {
		if ((b1 > b2 ? b1 - b2 : b2 - b1) > 1) {
		    offmany++;
		} else {
		    off1++;
		}
	    }
	} else {
	    /* off by many */
	    offmany++;
	}

	/* they're different, so print something */
	if (list_pixel_values) {
	    if (print_bytes) {
		printf("%ld %3d %3d\n", bytes, r1, r2);
	    } else {
		printf("%ld\t( %3d, %3d, %3d )\t( %3d, %3d, %3d )\n", bytes / 3, r1, g1, b1, r2, g2, b2);
	    }
	}
    }

    /* print summary */
    if (!silent) {
	fprintf(stdout,
		"pixcmp %s: %8ld matching, %8ld off by 1, %8ld off by many\n",
		print_bytes?"bytes":"pixels",
		matching, off1, offmany );
    }

    /* check for errors */
    if (ferror(f1) || ferror(f2)) {
	perror("pixcmp file error");
	return FILE_ERROR;
    }

    /* if files were of different lengths, consider it an error */
    if (feof(f1) != feof(f2)) {
	return FILE_ERROR;
    }

    /* indicate how many differences there were overall */
    if (offmany) {
	return OFF_BY_MANY;
    }
    if (off1) {
	return OFF_BY_ONE;
    }

    /* Success! */
    return OFF_BY_NONE;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.14
log
@removed trailing whitespace
@
text
@a35 3
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.13 2007/02/15 21:46:51 brlcad Exp $ (BRL)";
#endif
@


14.13
log
@initialize counter vars
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.12 2007/02/15 19:40:54 brlcad Exp $ (BRL)";
d222 1
a222 1
    
@


14.12
log
@major rewrite, almost from scratch.  now supports all of the new options (-b, -l, -s, -i) and behaves more closely to cmp.  supports processing over files byte-by-byte or pixel-by-pixel, comparing values, tabulating results, and reporting them in the format requested.
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.11 2007/02/14 09:37:55 brlcad Exp $ (BRL)";
d124 2
a125 1
    FILE *f1, *f2;
d127 3
a129 3
    long matching;
    long off1;
    long offmany;
@


14.11
log
@major rewrite, add support for -s, -l, and -i options for silent, verbose output (ala cmp's -l option), and support for skipping input.  make the return/error codes more uniform as well as more detail on the usage.  still need to actually add the print statement for -l, but everything else should be done.  basic operation and previous use remains unaffected.
@
text
@d32 1
a34 1
 *	Christopher Sean Morrison
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.10 2007/01/23 01:13:19 brlcad Exp $ (BRL)";
d61 4
d68 1
d75 2
a76 1
	    "Pixel numbers are indexed linearly from zero.\n");
d85 1
a85 2
    if ((arg == NULL) ||
	((skip1 == NULL) && (skip2 == NULL))){
d132 1
d137 2
d140 1
a140 1
    while ((c = getopt(argc, argv, "li:s")) != EOF) {
d145 3
a149 1
		argc--; argv++;
a158 1
	argc--;	argv++;
d160 2
d164 1
a164 1
    if( argc < 2 || argc > 5)  {
d169 10
d181 1
a181 1
    if (argc > 3) {
d183 5
a187 1
	snprintf(range, 64, "%s%s%s", argc>3?argv[3]:"", argc>4?":":"", argc>4?argv[4]:"");
d191 1
a191 1
    /* printf("Skip from FILE1: %ld and from FILE2: %ld\n", f1_skip, f2_skip); */
d193 1
a193 1
    if (strcmp( argv[1], "-" ) == 0 ) {
d195 1
a195 1
    } else if ((f1 = fopen( argv[1], "r" )) == NULL)  {
d199 1
a199 1
    if ((argc < 3) || (strcmp(argv[2], "-") == 0)) {
d201 2
a202 2
    } else if ((f2 = fopen( argv[2], "r" )) == NULL) {
	perror(argv[2]);
d206 12
a217 3
    /* skip requested pixels in FILE1 */
    if (fseek(f1, f1_skip * 3, SEEK_SET)) {
	fprintf(stderr, "ERROR: Unable to seek %ld pixels (%ld bytes) in FILE1\n", f1_skip, f1_skip*3);
d223 6
a228 2
    if (fseek(f2, f2_skip * 3, SEEK_SET)) {
	fprintf(stderr, "ERROR: Unable to seek %ld pixels (%ld bytes) in FILE2\n", f2_skip, f2_skip*3);
d233 5
a237 3
    while(1)  {
	register int r1, g1, b1;
	int r2, g2, b2;
a239 2
	g1 = fgetc( f1 );
	b1 = fgetc( f1 );
d241 25
a265 11
	g2 = fgetc( f2 );
	b2 = fgetc( f2 );
	if( feof(f1) || feof(f2) )  break;

	if( r1 != r2 || g1 != g2 || b1 != b2 )  {
	    register int i;

	    /* Highlight differing channels */
	    if( r1 != r2 )  {
		if( (i = r1 - r2) < 0 )  i = -i;
		if( i > 1 )  {
d270 2
a271 6
	    } else {
		matching++;
	    }
	    if( g1 != g2 )  {
		if( (i = g1 - g2) < 0 )  i = -i;
		if( i > 1 )  {
d276 2
a277 6
	    } else {
		matching++;
	    }
	    if( b1 != b2 )  {
		if( (i = b1 - b2) < 0 )  i = -i;
		if( i > 1 )  {
d282 10
d293 1
a293 1
		matching++;
a294 3
	}  else  {
	    /* Common case:  equal.  Give B&W NTSC average */
	    matching += 3;
d297 2
d300 3
a302 2
	fprintf(stderr,
		"pixcmp pixels: %8ld matching, %8ld off by 1, %8ld off by many\n",
d306 7
a312 1
    /* If files were of different lengths, that is an error */
@


14.10
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d34 1
a34 4
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.9 2007/01/20 14:36:39 brlcad Exp $ (BRL)";
d44 12
a55 3
long	matching;
long	off1;
long	offmany;
a56 1
char usage[] = "Usage: pixcmp f1.pix f2.pix\n";
d58 16
a73 1
int main(int argc, char **argv);
d75 40
d117 1
a117 1
main(int argc, char **argv)
d119 1
a119 1
	register FILE *f1, *f2;
d121 116
a236 66
	if( argc != 3 )  {
		fprintf(stderr, "%s", usage);
		exit(0);
	}

	if( strcmp( argv[1], "-" ) == 0 )
		f1 = stdin;
	else if( (f1 = fopen( argv[1], "r" ) ) == NULL )  {
		perror( argv[1] );
		exit(1);
	}
	if( strcmp( argv[2], "-" ) == 0 )
		f2 = stdin;
	else if( (f2 = fopen( argv[2], "r" ) ) == NULL )  {
		perror( argv[2] );
		exit(1);
	}
	while(1)  {
		register int r1, g1, b1;
		int r2, g2, b2;

		r1 = fgetc( f1 );
		g1 = fgetc( f1 );
		b1 = fgetc( f1 );
		r2 = fgetc( f2 );
		g2 = fgetc( f2 );
		b2 = fgetc( f2 );
		if( feof(f1) || feof(f2) )  break;

		if( r1 != r2 || g1 != g2 || b1 != b2 )  {
			register int i;

			/* Highlight differing channels */
			if( r1 != r2 )  {
				if( (i = r1 - r2) < 0 )  i = -i;
				if( i > 1 )  {
					offmany++;
				} else {
					off1++;
				}
			} else {
				matching++;
			}
			if( g1 != g2 )  {
				if( (i = g1 - g2) < 0 )  i = -i;
				if( i > 1 )  {
					offmany++;
				} else {
					off1++;
				}
			} else {
				matching++;
			}
			if( b1 != b2 )  {
				if( (i = b1 - b2) < 0 )  i = -i;
				if( i > 1 )  {
					offmany++;
				} else {
					off1++;
				}
			} else {
				matching++;
			}
		}  else  {
			/* Common case:  equal.  Give B&W NTSC average */
			matching += 3;
d238 6
d245 2
d248 1
a248 1
		"pixcmp bytes: %8ld matching, %8ld off by 1, %8ld off by many\n",
d250 1
d252 12
a263 7
	/* If files were of different lengths, that is an error */
	if( feof(f1) != feof(f2) )
		exit(2);

	/* If any pixels were off by more than +/- 1, that is an error */
	if( offmany)
		exit(1);
d265 2
a266 2
	/* Success! */
	exit(0);
@


14.9
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.8 2006/04/05 17:09:53 brlcad Exp $ (BRL)";
@


14.8
log
@missing string.h
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.7 2006/01/18 06:46:10 brlcad Exp $ (BRL)";
@


14.7
log
@update copyright to 2006
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.6 2005/05/18 12:41:09 brlcad Exp $ (BRL)";
d46 1
@


14.7.2.1
log
@update from HEAD
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.7 2006/01/18 06:46:10 brlcad Exp $ (BRL)";
a45 1
#include <string.h>
@


14.6
log
@doesn't need string.h or common.h yet
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.5 2005/01/30 20:30:08 brlcad Exp $ (BRL)";
@


14.5
log
@update copyright to 2005
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/bench/pixcmp.c,v 14.4 2004/12/18 06:50:48 morrison Exp $ (BRL)";
a43 2
#include "common.h"

a46 4
#ifdef HAVE_STRING_H
#include <string.h>
#endif

@


14.4
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/bench/pixcmp.c,v 14.3 2004/12/17 22:18:01 morrison Exp $ (BRL)";
@


14.3
log
@output the title on the first line instead of the second line
@
text
@d21 2
a22 1
 **//** @@file pixcmp.c
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/bench/pixcmp.c,v 14.2 2004/12/17 21:16:27 morrison Exp $ (BRL)";
@


14.2
log
@assignment of copyright and GPL license
@
text
@d1 1
a1 2
/*
 *                        P I X C M P . C
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/bench/pixcmp.c,v 14.1 2004/11/16 19:42:08 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d2 21
a22 1
 *			P I X C M P . C
a38 5
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/bench/pixcmp.c,v 11.12 2004/08/02 23:01:46 morrison Exp $ (BRL)";
@


11.12
log
@replace the wrapped config.h block with common.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/bench/pixcmp.c,v 11.11 2004/05/10 15:30:41 erikg Exp $ (BRL)";
d135 10
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/bench/pixcmp.c,v 11.10 2004/03/03 19:50:24 morrison Exp $ (BRL)";
d29 1
a29 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


11.10
log
@premptime ansification
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.9 2004/02/02 17:38:58 morrison Exp $ (BRL)";
d29 3
a31 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.8 2002/08/20 17:07:19 jra Exp $ (BRL)";
d44 3
d48 1
a48 2
main(argc, argv)
char **argv;
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1988 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.6 2000/10/19 19:19:44 butler Exp $ (BRL)";
@


11.8.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/bench/pixcmp.c,v 11.10 2004/03/03 19:50:24 morrison Exp $ (BRL)";
a43 3
int main(int argc, char **argv);


d45 2
a46 1
main(int argc, char **argv)
@


11.8.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.9 2004/02/02 17:38:58 morrison Exp $ (BRL)";
@


11.8.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.10 2004/03/03 19:50:24 morrison Exp $ (BRL)";
a43 3
int main(int argc, char **argv);


d45 2
a46 1
main(int argc, char **argv)
@


11.8.10.3
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.8.10.2 2004/03/10 13:16:35 erikg Exp $ (BRL)";
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.8 2002/08/20 17:07:19 jra Exp $ (BRL)";
d45 2
a46 1
main(int argc, char **argv)
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a42 3

int main(int argc, char **argv);

@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d45 2
a46 1
main(int argc, char **argv)
@


11.6
log
@Changes to compile under RedHat 7.0
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.5 2000/10/18 18:10:32 butler Exp $ (BRL)";
d45 1
a45 2
main(argc, argv)
char **argv;
@


11.5
log
@Patches for compiling under RedHat 7.0
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.4 2000/07/07 05:18:00 cjohnson Exp $ (BRL)";
d32 1
@


11.4
log
@LINT
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.3 2000/07/05 22:11:19 cjohnson Exp $ (BRL)";
d32 4
@


11.3
log
@Lint.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/bench/pixcmp.c,v 11.2 1998/01/07 06:47:47 mike Exp $ (BRL)";
@


11.2
log
@IRIX64 issue of %ld
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/bench/RCS/pixcmp.c,v 11.1 1995/01/04 09:50:54 mike Rel4_4 mike $ (BRL)";
d39 1
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/bench/RCS/pixcmp.c,v 10.2 94/08/11 13:14:48 gdurf Exp $ (BRL)";
d113 1
a113 1
		"pixcmp bytes: %7d matching, %7d off by 1, %7d off by many\n",
@


11.1.1.1
log
@Release_4.5
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad4.5/RCS/pixcmp.c,v 11.2 1998/01/07 06:47:47 mike Exp $ (BRL)";
d113 1
a113 1
		"pixcmp bytes: %8ld matching, %8ld off by 1, %8ld off by many\n",
@


10.2
log
@Added include of conf.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/bench/RCS/pixcmp.c,v 10.1 1991/10/12 06:36:16 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: pixcmp.c,v 9.1 89/05/19 05:45:13 mike Rel3_5 $ (BRL)";
d28 2
@


9.1
log
@Release_3.5
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: pixcmp.c,v 8.1 88/10/05 00:24:57 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: pixcmp.c,v 1.2 88/10/03 14:01:10 mike Exp $ (BRL)";
@


1.2
log
@Added different-length check.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: pixcmp.c,v 1.1 88/10/01 00:48:33 mike Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: pixdiff.c,v 7.1 87/11/03 00:08:29 mike Rel $ (BRL)";
d113 7
a119 1
	if( offmany) {
d121 2
a122 1
	}
@
