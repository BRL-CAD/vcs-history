head	14.53;
access;
symbols
	rel-7-10-4:14.51
	STABLE:14.51.0.2
	stable-branch:14.4
	rel-7-10-2:14.49
	rel-7-10-0:14.40
	rel-7-8-4:14.36
	rel-7-8-2:14.36
	rel-7-8-0:14.36
	trimnurbs-branch:14.36.0.2
	help:14.36
	temp_tag:14.34
	bobWinPort-20051223-freeze:14.25
	postmerge-20051223-bobWinPort:14.34
	premerge-20051223-bobWinPort:14.34
	rel-7-6-6:14.33
	rel-7-6-4:14.31
	rel-7-6-2:14.25
	rel-7-6-branch:14.25.0.4
	rel-7-6-0:14.25
	rel-7-4-2:14.24.2.1
	rel-7-4-branch:14.24.0.2
	bobWinPort:14.25.0.2
	rel-7-4-0:14.24
	rel-7-2-6:14.24
	rel-7-2-4:14.6
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.20
	rel-7-0-branch:1.20.0.2
	rel-7-0:1.20
	ansi-20040405-merged:1.11.4.1
	postmerge-20040405-ansi:1.13
	premerge-20040404-ansi:1.13
	postmerge-autoconf:1.13
	autoconf-freeze:1.12.6.3
	premerge-autoconf:1.13
	ansi-20040316-freeze:1.11
	postmerge-20040315-windows:1.13
	premerge-20040315-windows:1.13
	windows-20040315-freeze:1.11.6.1
	autoconf-20031203:1.12.6.1
	autoconf-20031202:1.12
	autoconf-branch:1.12.0.6
	phong-branch:1.12.0.4
	photonmap-branch:1.12.0.2
	rel-6-1-DP:1.11
	windows-branch:1.11.0.6
	rel-6-0-2:1.11
	ansi-branch:1.11.0.4
	rel-6-0-1-branch:1.11.0.2
	hartley-6-0-post:1.11
	hartley-6-0-pre:1.11
	rel-6-0-1:1.11
	rel-6-0:1.11
	rel-5-4:1.8
	offsite-5-3-pre:1.8
	rel-5-3:1.8
	rel-5-2:1.8
	rel-5-1-branch:1.8.0.2
	rel-5-1:1.8
	rel-5-0:1.8
	rel-5-0-beta:1.8
	rel-4-5:1.7
	ctj-4-5-post:1.7
	ctj-4-5-pre:1.7
	rel-4-4:1.6
	rel-4-0:1.5
	rel-3-5:1.5
	rel-3-0:1.3;
locks; strict;
comment	@# @;


14.53
date	2007.10.02.15.23.50;	author erikgreenwald;	state Exp;
branches;
next	14.52;

14.52
date	2007.09.15.18.02.54;	author lbutler;	state Exp;
branches;
next	14.51;

14.51
date	2007.09.11.18.40.02;	author erikgreenwald;	state Exp;
branches;
next	14.50;

14.50
date	2007.09.11.18.34.56;	author erikgreenwald;	state Exp;
branches;
next	14.49;

14.49
date	2007.06.27.09.57.08;	author brlcad;	state Exp;
branches;
next	14.48;

14.48
date	2007.05.27.06.26.17;	author brlcad;	state Exp;
branches;
next	14.47;

14.47
date	2007.05.27.05.55.07;	author brlcad;	state Exp;
branches;
next	14.46;

14.46
date	2007.05.27.04.27.28;	author brlcad;	state Exp;
branches;
next	14.45;

14.45
date	2007.05.27.04.21.23;	author brlcad;	state Exp;
branches;
next	14.44;

14.44
date	2007.05.26.22.40.53;	author brlcad;	state Exp;
branches;
next	14.43;

14.43
date	2007.05.26.20.17.22;	author brlcad;	state Exp;
branches;
next	14.42;

14.42
date	2007.05.26.19.59.26;	author brlcad;	state Exp;
branches;
next	14.41;

14.41
date	2007.05.15.06.49.39;	author brlcad;	state Exp;
branches;
next	14.40;

14.40
date	2007.03.13.18.04.37;	author brlcad;	state Exp;
branches;
next	14.39;

14.39
date	2007.02.15.21.49.41;	author brlcad;	state Exp;
branches;
next	14.38;

14.38
date	2007.01.27.01.41.28;	author brlcad;	state Exp;
branches;
next	14.37;

14.37
date	2007.01.20.14.36.39;	author brlcad;	state Exp;
branches;
next	14.36;

14.36
date	2006.02.27.04.08.20;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2006.01.18.06.46.10;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2005.12.21.04.10.52;	author brlcad;	state Exp;
branches;
next	14.33;

14.33
date	2005.12.12.23.14.43;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2005.12.07.22.27.28;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2005.11.11.21.34.28;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2005.11.04.12.34.02;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2005.11.04.12.14.28;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2005.11.04.10.56.18;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2005.11.01.08.47.46;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2005.10.23.04.24.41;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2005.07.16.21.39.36;	author brlcad;	state Exp;
branches
	14.25.4.1;
next	14.24;

14.24
date	2005.06.01.21.54.59;	author brlcad;	state Exp;
branches
	14.24.2.1;
next	14.23;

14.23
date	2005.06.01.21.29.54;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2005.06.01.19.58.56;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2005.05.28.17.02.16;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2005.05.28.02.09.53;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2005.05.18.05.02.56;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2005.05.17.22.47.19;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2005.05.17.06.24.23;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.05.17.05.48.14;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.05.17.04.08.46;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.05.17.03.26.34;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.05.16.23.38.42;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.05.16.19.05.10;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.05.16.16.09.40;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.05.16.01.36.30;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.05.16.00.07.12;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.05.15.04.27.20;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.05.15.04.25.01;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.04.23.16.54.49;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.04.22.20.17.39;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.02.21.18.04.09;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.30.08;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.17.21.16.11;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.08;	author morrison;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.07.16.49.48;	author morrison;	state Exp;
branches;
next	1.19;

1.19
date	2004.10.07.13.42.29;	author morrison;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.21.19.44.24;	author morrison;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.21.19.26.36;	author morrison;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.21.18.03.44;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.13.13.18.11;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.13.12.47.58;	author morrison;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.19.23.58.39;	author morrison;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.25.14.47.27;	author morrison;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2001.07.16.18.05.18;	author morrison;	state Exp;
branches
	1.11.4.1
	1.11.6.1;
next	1.10;

1.10
date	2001.05.16.21.36.48;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.27.22.36.28;	author morrison;	state Exp;
branches;
next	1.8;

1.8
date	98.12.31.08.15.18;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	97.01.08.01.02.28;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.09.22.03.56.29;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.05.19.05.21.11;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.04.29.02.50.55;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.10.03.14.06.58;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.10.01.06.56.28;	author kermit;	state Exp;
branches;
next	1.1;

1.1
date	88.09.12.01.08.03;	author mike;	state Exp;
branches;
next	;

1.11.4.1
date	2004.03.17.21.15.49;	author morrison;	state Exp;
branches;
next	;

1.11.6.1
date	2004.03.11.23.40.26;	author morrison;	state Exp;
branches;
next	;

1.12.6.1
date	2003.12.03.17.44.53;	author erikg;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2004.02.12.19.40.40;	author erikg;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2004.03.15.14.06.04;	author erikg;	state Exp;
branches;
next	;

14.24.2.1
date	2005.08.16.21.03.44;	author brlcad;	state Exp;
branches;
next	;

14.25.4.1
date	2005.11.13.13.46.08;	author brlcad;	state Exp;
branches;
next	;


desc
@Script to run the BRL-CAD Benchmark
@


14.53
log
@Add another path for RT.
Search for 'moss.g' in $DB and cull (so if the .g's are in a different dir than $(top_srcdir)/db, the right path is used).
@
text
@#!/bin/sh
#                          R U N . S H
# BRL-CAD
#
# Copyright (c) 2004-2007 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
###
#
# This shell script runs the BRL-CAD Benchmark.  The benchmark suite
# will test the performance of a system by iteratively rendering
# several well-known datasets into 512x512 images where performance
# metrics are documented and fairly well understood.  The local
# machine's performance is compared to the base system (called VGR)
# and a numeric "VGR" mulitplier of performance is computed.  This
# number is a simplified metric from which one may qualitatively
# compare cpu and cache performance, versions of BRL-CAD, and
# different compiler characteristics.
#
# The suite is intended to be run from a source distribution of
# BRL-CAD after the package has been compiled either directly or via a
# make build system target.  There are, however, several environment
# variables that will modify how the BRL-CAD benchmark behaves so that
# it may be run in a stand-alone environment:
#
#   RT - the rt binary (e.g. ../src/rt/rt or /usr/brlcad/bin/rt)
#   DB - the directory containing the reference geometry (e.g. ../db)
#   PIX - the directory containing the reference images (e.g. ../pix)
#   LOG - the directory containing the reference logs (e.g. ../pix)
#   CMP - the name of a pixcmp tool (e.g. ./pixcmp or cmp)
#   ELP - the name of an elapsed time tool (e.g. ../sh/elapsed.sh)
#   TIMEFRAME - the minimum number of seconds each trace needs to take
#   MAXTIME - the maximum number of seconds to spend on any test
#   DEVIATION - the minimum sufficient % deviation from the average
#   AVERAGE - how many frames to average together
#   VERBOSE - turn on extra debug output for testing/development
#   QUIET - turn off all printing output (writes results to summary)
#
# The TIMEFRAME, MAXTIME, DEVIATION, and AVERAGE options control how
# the benchmark will proceed including how long it should take.  Each
# individual benchmark run will consume at least a minimum TIMEFRAME
# of wallclock time so that the results can stabilize.  After
# consuming at least the minimum TIMEFRAME, additional frames may be
# computed until the standard deviation from the last AVERAGE count of
# frames is below the specified DEVIATION.  When a test is run and it
# completes in less than TIMEFRAME, the raytrace is restarted using
# double the number of rays from the previous run.  If the machine is
# fast enough, the benchmark may accelerate the number or rays being
# fired.  These additional rays are hypersampled but without any
# jitter, so it's effectively performing a multiplier amount of work
# over the initial frame.
#
# Plese send your BRL-CAD Benchmark results to the developers along
# with detailed system information to <devs@@brlcad.org>.  Include at
# least:
#
#   0) Compiler name and version (e.g. gcc --version)
#   1) CPU configuration (e.g. cat /proc/cpuinfo or hinv or sysctl -a)
#   2) Cache (data and/or instruction) details for L1/L2/L3 and system
#      (e.g. cat /proc/cpuinfo or hinv or sysctl -a)
#   3) All generated log files (i.e. *.log* after benchmark completes)
#   4) Anything else you think might be relevant to performance
#
# Authors -
#  Mike Muuss
#  Susan Muuss
#  Christopher Sean Morrison
#
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.52 2007/09/15 18:02:54 lbutler Exp $ (BRL)


# Ensure /bin/sh
export PATH || (echo "This isn't sh."; sh $0 $*; kill $$)

# save the precious args
ARGS="$*"
NAME_OF_THIS=`basename $0`
PATH_TO_THIS=`dirname $0`
THIS="$PATH_TO_THIS/$NAME_OF_THIS"

# sanity check
if [ ! -f "$THIS" ] ; then
    echo "INTERNAL ERROR: $THIS does not exist"
    if [ ! "x$0" = "x$THIS" ] ; then
	echo "INTERNAL ERROR: dirname/basename inconsistency: $0 != $THIS"
    fi
    exit 1
fi

# force locale setting to C so things like date output as expected
LC_ALL=C

# commands that this script expects
for __cmd in echo pwd ; do
    echo "test" | $__cmd > /dev/null 2>&1
    if test ! x$? = x0 ; then
	echo "INTERNAL ERROR: $__cmd command is required"
	exit 1
    fi
done
echo "test" | grep "test" > /dev/null 2>&1
if test ! x$? = x0 ; then
    echo "INTERNAL ERROR: grep command is required"
    exit 1
fi
echo "test" | tr "test" "test" > /dev/null 2>&1
if test ! x$? = x0 ; then
    echo "INTERNAL ERROR: tr command is required"
    exit 1
fi
echo "test" | sed "s/test/test/" > /dev/null 2>&1
if test ! x$? = x0 ; then
    echo "INTERNAL ERROR: sed command is required"
    exit 1
fi

# determine the behavior of echo
case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
    *c*,-n*) ECHO_N= ECHO_C='
' ECHO_T='	' ;;
    *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
    *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
esac

# where to write results
LOGFILE=run-$$-benchmark.log
touch "$LOGFILE"
if test ! -w "$LOGFILE" ; then
    if test ! "x$LOGFILE" = "x/dev/null" ; then
	echo "ERROR: Unable to log to $LOGFILE"
    fi
    LOGFILE=/dev/null
fi

VERBOSE_ECHO=:
ECHO=:
if [ "x$QUIET" = "xyes" ] ; then
    if [ "x$VERBOSE" = "xyes" ] ; then
	echo "Verbose output quelled by quiet option.  Further output disabled."
    fi
else
    ECHO=log
    if [ "x$VERBOSE" = "xyes" ] ; then
	echo "Verbose output enabled"
	VERBOSE_ECHO=echo
    fi
fi


#######################
# log to tty and file #
#######################
log ( ) {

    # this routine writes the provided argument(s) to a log file as
    # well as echoing them too.

    echo "$*" >> "$LOGFILE"
    echo "$*"
}


$ECHO "B R L - C A D   B E N C H M A R K"
$ECHO "================================="


# recognize a cleanup command
case "x$1" in
    xclean)
	CLEAN=1
	;;
    xclobber)
	CLEAN=1
	CLOBBER=1
	;;
esac

if test "x$CLEAN" = "x1" ; then
    ECHO=echo
    rm -f "$LOGFILE"
    $ECHO
    if test "x$CLOBBER" = "x1" ; then
	$ECHO "About to wipe out all benchmark images and log files in `pwd`"
	$ECHO "Send SIGINT (type ^C) within 5 seconds to abort"
	sleep 5
    else
	$ECHO "Deleting most benchmark images and log files in `pwd`"
    fi
    $ECHO

    for i in moss world star bldg391 m35 sphflake ; do
	$ECHO rm -f $i.log $i.pix $i.log.[0-9]* $i.pix.[0-9]*
	rm -f $i.log $i.pix $i.log.[0-9]* $i.pix.[0-9]*
    done
    if test "x$CLOBBER" = "x1" ; then
	# NEVER automatically delete the summary file, but go ahead with the rest
	for i in run-[0-9]*-benchmark.log ; do
	    $ECHO rm -f $i
	    rm -f $i
	done
    fi

    printed=no
    for i in summary run-[0-9]*-benchmark.log ; do
	if test -f "$i" ; then
	    if test "x$printed" = "xno" ; then
		$ECHO
		$ECHO "The following files must be removed manually:"
		printed=yes
	    fi
	    $ECHO $ECHO_N "$i " $ECHO_C
	fi
    done
    if test "x$printed" = "xyes" ; then
	$ECHO
    fi

    $ECHO
    if test "x$CLOBBER" = "x1" ; then
	$ECHO "Benchmark clobber complete."
    else
	$ECHO "Benchmark clean complete."
    fi
    exit 0
fi

$ECHO "Running $THIS on `date`"
$ECHO "Logging output to $LOGFILE"
$ECHO "`uname -a 2>&1`"
$ECHO

########################
# search for resources #
########################
look_for ( ) {

    # utility function to search for a certain filesystem object in a
    # list of paths.

    look_for_type="$1" ; shift
    look_for_label="$1" ; shift
    look_for_var="$1" ; shift
    look_for_dirs="$*"

    if test "x$look_for_label" != "x" ; then
	$VERBOSE_ECHO  "Looking for $look_for_label"
    fi

    # get the value of the variable
    look_for_var_var="echo \"\$$look_for_var\""
    look_for_var_val="`eval ${look_for_var_var}`"

    if test "x${look_for_var_val}" = "x" ; then
	for look_for_dir in $look_for_dirs ; do

	    opts="-r"
	    case "x$look_for_type" in
		xfile)
		    opts="$opts -f"
		    ;;
		xdir*)
		    # should work without read bit
		    opts="-d -x"
		    ;;
		xexe*)
		    opts="$opts -x"
		    ;;
		xscr*)
		    opts="$opts -x"
		    ;;
	    esac
	    look_for_failed=no
	    for opt in $opts ; do
		if test ! $opt "${look_for_dir}" ; then
		    look_for_failed=yes
		    break
		fi
	    done
	    if test "x$look_for_failed" = "xno" ; then
		if test "x$look_for_label" != "x" ; then
		    $VERBOSE_ECHO "...found $look_for_type ${look_for_dir}"
		fi
		look_for_var_var="${look_for_var}=\"${look_for_dir}\""
		eval $look_for_var_var
		export $look_for_var
		break
	    fi
	done
    else
	if test "x$look_for_label" != "x" ; then
	    $VERBOSE_ECHO "...using $look_for_var_val from $look_for_var variable setting"
	fi
    fi
}

look_for executable "the BRL-CAD raytracer" RT \
    ${PATH_TO_THIS}/rt \
    ${PATH_TO_THIS}/../bin/rt \
    ${PATH_TO_THIS}/../src/rt/rt \
    ${PATH_TO_THIS}/src/rt/rt \
    ./rt \
    ../src/rt/rt

look_for file "a benchmark geometry directory" DB \
    ${PATH_TO_THIS}/../share/brlcad/*.*.*/db/moss.g \
    ${PATH_TO_THIS}/share/brlcad/*.*.*/db/moss.g \
    ${PATH_TO_THIS}/../share/brlcad/db/moss.g \
    ${PATH_TO_THIS}/share/brlcad/db/moss.g \
    ${PATH_TO_THIS}/../share/db/moss.g \
    ${PATH_TO_THIS}/share/db/moss.g \
    ${PATH_TO_THIS}/../db/moss.g \
    ${PATH_TO_THIS}/db/moss.g \
    ./db/moss.g \
    ../db/moss.g
DB=`echo $DB | sed 's,/moss.g$,,'`

look_for directory "a benchmark reference image directory" PIX \
    ${PATH_TO_THIS}/../share/brlcad/*.*.*/pix \
    ${PATH_TO_THIS}/share/brlcad/*.*.*/pix \
    ${PATH_TO_THIS}/../share/brlcad/pix \
    ${PATH_TO_THIS}/share/brlcad/pix \
    ${PATH_TO_THIS}/../share/pix \
    ${PATH_TO_THIS}/share/pix \
    ${PATH_TO_THIS}/../pix \
    ${PATH_TO_THIS}/pix \
    ./pix

look_for directory "a benchmark reference log directory" LOG \
    $PIX \
    ${PATH_TO_THIS}/../share/brlcad/*.*.*/pix \
    ${PATH_TO_THIS}/share/brlcad/*.*.*/pix \
    ${PATH_TO_THIS}/../share/brlcad/pix \
    ${PATH_TO_THIS}/share/brlcad/pix \
    ${PATH_TO_THIS}/../share/pix \
    ${PATH_TO_THIS}/share/pix \
    ${PATH_TO_THIS}/../pix \
    ${PATH_TO_THIS}/pix \
    ./pix

look_for executable "a pixel comparison utility" CMP \
    ${PATH_TO_THIS}/pixcmp \
    ${PATH_TO_THIS}/../bin/pixcmp \
    ${PATH_TO_THIS}/../bench/pixcmp \
    ./pixcmp

look_for script "a time elapsed utility" ELP \
    ${PATH_TO_THIS}/elapsed.sh \
    ${PATH_TO_THIS}/../bin/elapsed.sh \
    ${PATH_TO_THIS}/sh/elapsed.sh \
    ${PATH_TO_THIS}/../sh/elapsed.sh \
    ./elapsed.sh


#####################
# output parameters #
#####################

# sanity check, output all the final settings together
if test "x${RT}" = "x" ; then
    $ECHO "ERROR:  Could not find the BRL-CAD raytracer"
    exit 1
else
    $ECHO "Using [$RT] for RT"
fi
if test "x${DB}" = "x" ; then
    $ECHO "ERROR:  Could not find the BRL-CAD database directory"
    exit 1
else
    $ECHO "Using [$DB] for DB"
fi
if test "x${PIX}" = "x" ; then
    $ECHO "ERROR:  Could not find the BRL-CAD reference images"
    exit 1
else
    $ECHO "Using [$PIX] for PIX"
fi
if test "x${LOG}" = "x" ; then
    $ECHO "ERROR:  Could not find the BRL-CAD reference logs"
    exit 1
else
    $ECHO "Using [$LOG] for LOG"
fi
if test "x${CMP}" = "x" ; then
    $ECHO "ERROR:  Could not find the BRL-CAD pixel comparison utility"
    exit 1
else
    $ECHO "Using [$CMP] for CMP"
fi
if test "x${ELP}" = "x" ; then
    $ECHO "ERROR:  Could not find the BRL-CAD time elapsed script"
    exit 1
else
    $ECHO "Using [$ELP] for ELP"
fi

# utility function to set a variable if it's not already set to something
set_if_unset ( ) {
    set_if_unset_name="$1" ; shift
    set_if_unset_val="$1" ; shift

    set_if_unset_var="echo \"\$$set_if_unset_name\""
    set_if_unset_var_val="`eval ${set_if_unset_var}`"
    if test "x${set_if_unset_var_val}" = "x" ; then
	set_if_unset_var="${set_if_unset_name}=\"${set_if_unset_val}\""
	$VERBOSE_ECHO $set_if_unset_var
	eval $set_if_unset_var
	export $set_if_unset_name
    fi

    set_if_unset_var="echo \"\$$set_if_unset_name\""
    set_if_unset_val="`eval ${set_if_unset_var}`"
    $ECHO "Using [${set_if_unset_val}] for $set_if_unset_name"
}

# determine the minimum time requirement in seconds for a single test run
set_if_unset TIMEFRAME 32

# approximate maximum time in seconds that a given test is allowed to take
set_if_unset MAXTIME 300
if test $MAXTIME -lt $TIMEFRAME ; then
    $ECHO "ERROR: MAXTIME must be greater or equal to TIMEFRAME"
    exit 1
fi

# maximum deviation percentage
set_if_unset DEVIATION 3

# maximum number of iterations to average
set_if_unset AVERAGE 3

# end of settings, separate the output
$ECHO


##########################
# output run-time status #
##########################

# determine raytracer version
$ECHO "RT reports the following version information:"
versions="`$RT 2>&1 | grep BRL-CAD`"
if test "x$versions" = "x" ; then
    $ECHO "Unknown"
else
    cat <<EOF
$versions
EOF
fi
$ECHO

# if expr works, let the user know about how long this might take
if test "x`expr 1 - 1 2>/dev/null`" = "x0" ; then
    mintime="`expr $TIMEFRAME \* 6`"
    $ECHO "Minimum run time is `$ELP $mintime`"
    maxtime="`expr $MAXTIME \* 6`"
    $ECHO "Maximum run time is `$ELP $maxtime`"
    estimate="`expr $mintime \* 3`"
    if test $estimate -gt $maxtime ; then
	estimate="$maxtime"
    fi
    $ECHO "Estimated   time is `$ELP $estimate`"
    $ECHO
else
    $ECHO "WARNING: expr is unavailable, unable to compute statistics"
    $ECHO
fi


#################################
# run and computation functions #
#################################

#
# run file_prefix geometry hypersample [..rt args..]
#   runs a single benchmark test assuming the following are preset:
#
#   RT := path/name of the raytracer to use
#   DB := path to the geometry file
#
# it is assumed that stdin will be the view/frame input
#
run ( ) {
    run_geomname="$1" ; shift
    run_geometry="$1" ; shift
    run_hypersample="$1" ; shift
    run_args="$*"
    run_view="`cat`"

    $VERBOSE_ECHO "DEBUG: Running $RT -B -M -s512 -H${run_hypersample} -J0 ${run_args} -o ${run_geomname}.pix ${DB}/${run_geomname}.g ${run_geometry}"

    $RT -B -M -s512 -H${run_hypersample} -J0 ${run_args} \
	-o ${run_geomname}.pix \
	${DB}/${run_geomname}.g ${run_geometry} 1>&2 <<EOF
$run_view
EOF
    retval=$?
    $VERBOSE_ECHO "DEBUG: Running $RT returned $retval"
    return $retval
}


#
# average [..numbers..]
#   computes the integer average for a set of given numbers
#
average ( ) {
    average_nums="$*"

    if test "x$average_nums" = "x" ; then
	$ECHO "ERROR: no numbers provided to average" 1>&2
	exit 1
    fi

    total=0
    count=0
    for num in $average_nums ; do
	total="`expr $total + $num`"
	count="`expr $count + 1`"
    done

    if test $count -eq 0 ; then
	$ECHO "ERROR: unexpected count in average" 1>&2
	exit 1
    fi

    echo "`expr $total / $count`"
    return 0
}


#
# getvals count [..numbers..]
#   extracts up to count integer values from a set of numbers
#
getvals ( ) {
    getvals_count="$1" ; shift
    getvals_nums="$*"

    if test "x$getvals_count" = "x" ; then
	getvals_count=10000
    elif test $getvals_count -eq 0 ; then
	echo ""
	return 0
    fi

    if test "x$getvals_nums" = "x" ; then
	echo ""
	return 0
    fi

    # get up to count values from the nums provided
    getvals_got=""
    getvals_counted=0
    for getvals_num in $getvals_nums ; do
	if test $getvals_counted -ge $getvals_count ; then
	    break
	fi
	# getvals_int="`echo $getvals_num | sed 's/\.[0-9]*//'`"
	getvals_int=`echo $getvals_num | awk '{print int($1+0.5)}'`
	getvals_got="$getvals_got $getvals_int"
	getvals_counted="`expr $getvals_counted + 1`"
    done

    echo "$getvals_got"
    return $getvals_counted
}


#
# variance count [..numbers..]
#   computes an integer variance for up to count numbers
#
variance ( ) {
    variance_count="$1" ; shift
    variance_nums="$*"

    if test "x$variance_count" = "x" ; then
	variance_count=10000
    elif test $variance_count -eq 0 ; then
	$ECHO "ERROR: cannot compute variance of zero numbers" 1>&2
	exit 1
    fi

    if test "x$variance_nums" = "x" ; then
	$ECHO "ERROR: cannot compute variance of nothing" 1>&2
	exit 1
    fi

    # get up to count values from the nums provided
    variance_got="`getvals $variance_count $variance_nums`"
    variance_counted="$?"

    if test $variance_counted -eq 0 ; then
	$ECHO "ERROR: unexpected zero count of numbers in variance" 1>&2
	exit 1
    elif test $variance_counted -lt 0 ; then
	$ECHO "ERROR: unexpected negative count of numbers in variance" 1>&2
	exit 1
    fi

    # compute the average of the nums we got
    variance_average="`average $variance_got`"

    # compute the variance numerator of the population
    variance_error=0
    for variance_num in $variance_got ; do
	variance_err_sq="`expr \( $variance_num - $variance_average \) \* \( $variance_num - $variance_average \)`"
	variance_error="`expr $variance_error + $variance_err_sq`"
    done

    # make sure the error is non-negative
    if test $variance_error -lt 0 ; then
	variance_error="`expr 0 - $variance_error`"
    fi

    # echo the variance result
    echo "`expr $variance_error / $variance_counted`"
}


#
# sqrt number
#   computes the square root of some number
#
sqrt ( ) {
    sqrt_number="$1"

    if test "x$sqrt_number" = "x" ; then
	$ECHO "ERROR: cannot compute the square root of nothing" 1>&2
	exit 1
    elif test $sqrt_number -lt 0 > /dev/null 2>&1 ; then
	$ECHO "ERROR: square root of negative numbers is only in your imagination" 1>&2
	exit 1
    fi

    sqrt_have_dc=yes
    echo "1 1 + p" | dc >/dev/null 2>&1
    if test ! x$? = x0 ; then
	sqrt_have_dc=no
    fi

    sqrt_root=""
    if test "x$sqrt_have_dc" = "xyes" ; then
	sqrt_root=`echo "$sqrt_number v p" | dc`
    else
	sqrt_have_bc=yes
	echo "1 + 1" | bc >/dev/null 2>&1
	if test ! "x$?" = "x0" ; then
	    sqrt_have_bc=no
	fi

	if test "x$sqrt_have_bc" = "xyes" ; then
	    sqrt_root=`echo "sqrt($sqrt_number)" | bc`
	else
	    sqrt_root=`echo $sqrt_number | awk '{print sqrt($1)}'`
	fi
    fi

    echo `echo $sqrt_root | awk '{print int($1+0.5)}'`

    return
}


#
# bench test_name geometry [..rt args..]
#   runs a series of benchmark tests assuming the following are preset:
#
#   TIMEFRAME := maximum amount of wallclock time to spend per test
#
# is is assumed that stdin will be the view/frame input
#
bench ( ) {
    bench_testname="$1" ; shift
    bench_geometry="$1" ; shift
    bench_args="$*"

    if test "x$bench_testname" = "x" ; then
	$ECHO "ERROR: argument mismatch, bench is missing the test name"
	return 1
    fi
    if test "x$bench_geometry" = "x" ; then
	$ECHO "ERROR: argument mismatch, bench is missing the test geometry"
	return 1
    fi
    $VERBOSE_ECHO "DEBUG: Beginning bench testing on $bench_testname using $bench_geometry"

    bench_view="`cat`"

    $ECHO +++++ ${bench_testname}
    bench_hypersample=0
    bench_frame=0
    bench_rtfms=""
    bench_percent=100
    bench_start_time="`date '+%H %M %S'`"
    bench_overall_elapsed=0

    while test $bench_overall_elapsed -lt $MAXTIME ; do

	bench_elapsed=0
	while test $bench_elapsed -lt $TIMEFRAME ; do

	    if test -f ${bench_testname}.pix; then mv -f ${bench_testname}.pix ${bench_testname}.pix.$$; fi
	    if test -f ${bench_testname}.log; then mv -f ${bench_testname}.log ${bench_testname}.log.$$; fi

	    bench_frame_start_time="`date '+%H %M %S'`"

	    run $bench_testname $bench_geometry $bench_hypersample $bench_args 2> ${bench_testname}.log << EOF
$bench_view
start $bench_frame;
end;
EOF
	    retval=$?

	    if test -f ${bench_testname}.pix.$bench_frame ; then mv -f ${bench_testname}.pix.$bench_frame ${bench_testname}.pix ; fi

	    # compute how long we took, rounding up to at least one
	    # second to prevent division by zero.
	    bench_elapsed="`$ELP --seconds $bench_frame_start_time`"
	    if test "x$bench_elapsed" = "x" ; then
		bench_elapsed=1
	    fi
	    if test $bench_elapsed -eq 0 ; then
		bench_elapsed=1
	    fi
	    if test "x$bench_hypersample" = "x0" ; then

		# just finished the first frame
		$VERBOSE_ECHO "DEBUG: ${bench_elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $bench_elapsed` pixels/s (inexact wallclock)"
		bench_hypersample=1
		bench_frame="`expr $bench_frame + 1`"
	    else
		$VERBOSE_ECHO "DEBUG: ${bench_elapsed}s real elapsed,	`expr $bench_hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $bench_hypersample + 1 \) / $bench_elapsed \)` pixels/s (inexact wallclock)"


		# increase the number of rays exponentially if we are
		# considerably faster than the TIMEFRAME required.
		if test `expr $bench_elapsed \* 32` -le ${TIMEFRAME} ; then
		    # 32x increase, skip four frames
		    bench_hypersample="`expr $bench_hypersample \* 32 + 31`"
		    bench_frame="`expr $bench_frame + 5`"
		elif test `expr $bench_elapsed \* 16` -le ${TIMEFRAME} ; then
		    # 16x increase, skip three frames
		    bench_hypersample="`expr $bench_hypersample \* 16 + 15`"
		    bench_frame="`expr $bench_frame + 4`"
		elif test `expr $bench_elapsed \* 8` -le ${TIMEFRAME} ; then
		    # 8x increase, skip two frames
		    bench_hypersample="`expr $bench_hypersample \* 8 + 7`"
		    bench_frame="`expr $bench_frame + 3`"
		elif test `expr $bench_elapsed \* 4` -le ${TIMEFRAME} ; then
		    # 4x increase, skip a frame
		    bench_hypersample="`expr $bench_hypersample \* 4 + 3`"
		    bench_frame="`expr $bench_frame + 2`"
		else
		    # 2x increase
		    bench_hypersample="`expr $bench_hypersample + $bench_hypersample + 1`"
		    bench_frame="`expr $bench_frame + 1`"
		fi
	    fi

	    # save the rtfm for variance computations then print it
	    bench_rtfm_line="`grep RTFM ${bench_testname}.log`"
	    bench_rtfm="`echo $bench_rtfm_line | awk '{print int($9+0.5)}'`"
	    if test "x$bench_rtfm" = "x" ; then
		bench_rtfm="0"
	    fi
	    bench_rtfms="$bench_rtfm $bench_rtfms"
	    if test ! "x$bench_rtfm_line" = "x" ; then
		$ECHO "$bench_rtfm_line"
	    fi

	    # did we fail?
	    if test $retval != 0 ; then
		$ECHO "RAYTRACE ERROR"
		break
	    fi

	    # see if we need to break out early
	    bench_overall_elapsed="`$ELP --seconds $bench_start_time`"
	    if test $bench_overall_elapsed -ge $MAXTIME ; then
		break;
	    fi
	done

	if test "x$bench_rtfm" = "x" ; then
	    bench_rtfm="0"
	fi
	if test "x$bench_rtfms" = "x" ; then
	    bench_rtfms="0"
	fi

	# outer loop for variance/deviation testing of last AVERAGE frames
	bench_variance="`variance $AVERAGE $bench_rtfms`"
	bench_deviation="`sqrt $bench_variance`"
	if test $bench_rtfm -eq 0 ; then
	    bench_percent=0
	else
	    bench_percent=`echo $bench_deviation $bench_rtfm | awk '{print int(($1 / $2 * 100)+0.5)}'`
	fi

	if test "x$VERBOSE" != "x" ; then
	    bench_vals="`getvals $AVERAGE $bench_rtfms`"
	    bench_avg="`average $bench_vals`"
	    if test $bench_avg -eq 0 ; then
		bench_avgpercent=0
	    else
		bench_avgpercent=`echo $bench_deviation $bench_avg | awk '{print $1 / $2 * 100}'`
	    fi
	    $VERBOSE_ECHO "DEBUG: average=$bench_avg ; variance=$bench_variance ; deviation=$bench_deviation ($bench_avgpercent%) ; last run was ${bench_percent}%"
	fi

	# early exit if we have a stable number
	if test $bench_percent -le $DEVIATION ; then
	    break
	fi

	bench_overall_elapsed="`$ELP --seconds $bench_start_time`"

	# undo the hypersample increase back one step
	bench_hypersample="`expr \( \( $bench_hypersample + 1 \) / 2 \) - 1`"
    done

    # the last run should be a relatively stable representative of the performance

    if test -f gmon.out; then mv -f gmon.out gmon.${bench_testname}.out; fi
    ${CMP} ${PIX}/${bench_testname}.pix ${bench_testname}.pix
    ret=$?
    if test $ret = 0 ; then
	# perfect match
	$ECHO ${bench_testname}.pix:  answers are RIGHT
    elif test $ret = 1 ; then
	# off by one, acceptable
	$ECHO ${bench_testname}.pix:  answers are RIGHT
    elif test $ret = 2 ; then
	# off by many, unacceptable
	$ECHO ${bench_testname}.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
    else
	# some other failure
	$ECHO ${bench_testname}.pix:  BENCHMARK COMPARISON FAILURE
    fi

    $VERBOSE_ECHO "DEBUG: Done benchmark testing on $bench_testname"
    return $retval
}


#
# perf test_name geometry [..rt args..]
#
perf ( ) {
    perf_tests="$1" ; shift
    perf_args="$*"

    if test "x$perf_tests" = "x" ; then
	$ECHO "ERROR: no tests specified for calculating performance" 1>&2
	exit 1
    fi

    # figure out what machine this is
    perf_host=$HOSTNAME
    if test "x$perf_host" = "x" ; then
	perf_host="`hostname`"
    fi
    if test "x$perf_host" = "x" ; then
	perf_host="`uname -n`"
    fi
    if test "x$perf_host" = "x" ; then
	perf_host="unknown"
    fi

    # when did we do this thing
    perf_date="`date`"

    # make sure the log files exist
    perf_ref_files=""
    perf_cur_files=""
    for perf_test in $perf_tests ; do
	perf_ref_log=${LOG}/${perf_test}.log
	perf_cur_log=${perf_test}.log
	for perf_log in "$perf_cur_log" "$perf_ref_log" ; do
	    if test ! "x$perf_log" = "x" ; then
		if test ! -f "$perf_log" ; then
		    $ECHO "ERROR: file $perf_log does not exist" 1>&2
		fi
	    fi
	done
	perf_ref_files="$perf_ref_files $perf_ref_log"
	perf_cur_files="$perf_cur_files $perf_cur_log"
    done

    # extract the RTFM values from the log files, use TR to convert
    # newlines to tabs.  the trailing tab is signficant in case there
    # are not enough results.
    #
    # FIXME: should really iterate one file at a time so we don't
    # just zero-pad at the end
    perf_VGRREF=`grep RTFM $perf_ref_files | sed -n -e 's/^.*= *//' -e 's/ rays.*//p' | tr '\012' '\011' `
    perf_CURVALS=`grep RTFM $perf_cur_files | sed -n -e 's/^.*= *//' -e 's/ rays.*//p' | tr '\012' '\011' `

    # if there were no reference values, we cannot compute timings
    if test "x$perf_VGRREF" = "x" ; then
	$ECHO "ERROR: Cannot locate VGR reference values" 1>&2
    fi

    # report 0 if no RTFM values were found in the current run (likely
    # crashing), values are tab-delimited.
    if test "x$perf_CURVALS" = "x" ; then
	perf_CURVALS="0	0	0	0	0	0	"
    fi

    # Trick: Force args $1 through $6 to the numbers in $perf_CURVALS
    # This should be "set -- $perf_CURVALS", but 4.2BSD /bin/sh can't
    # handle it, and perf_CURVALS are all positive (ie, no leading
    # dashes), so this is safe.

    set $perf_CURVALS

    while test $# -lt 6 ; do
	$ECHO "WARNING: only $# RTFM times found, adding a zero result." 1>&2
	perf_CURVALS="${perf_CURVALS}0	"
	set $perf_CURVALS
    done

    # see if we have a calculator
    perf_have_dc=yes
    echo "1 1 + p" | dc >/dev/null 2>&1
    if test ! x$? = x0 ; then
	perf_have_dc=no
    fi

    for perf_ref in $perf_VGRREF ; do
	perf_cur=$1
	shift

	if test "x$perf_have_dc" = "xyes" ; then
	    perf_RATIO=`echo "2k $perf_cur $perf_ref / p" | dc`
	else
	    # presume bc as an alternate (tsk tsk)
	    perf_RATIO=`echo "scale=2; $perf_cur / $perf_ref" | bc`
	fi
	# Note: append new value and a trail TAB to existing list.
	perf_RATIO_LIST="${perf_RATIO_LIST}$perf_RATIO	"
    done

    # The number of plus signs must be one less than the number of elements.
    if test "x$perf_have_dc" = "xyes" ; then
	perf_MEAN_ABS=`echo 2k $perf_CURVALS +++++ 6/ p | dc`
	perf_MEAN_REL=`echo 2k $perf_RATIO_LIST +++++ 6/ p | dc`
    else
	perf_expr="scale=2; ( 0"
	for perf_val in $perf_CURVALS ; do
	    perf_expr="$perf_expr + $perf_val"
	done
	perf_expr="$perf_expr ) / 6"
	perf_MEAN_ABS=`echo $perf_expr | bc`

	perf_expr="scale=2; ( 0"
	for perf_val in $perf_RATIO_LIST ; do
	    perf_expr="$perf_expr + $perf_val"
	done
	perf_expr="$perf_expr ) / 6"
	perf_MEAN_REL=`echo $perf_expr | bc`
    fi

    # Note: Both perf_RATIO_LIST and perf_CURVALS have an extra
    # trailing tab.  The question mark is for the mean field.

    echo "Abs  ${perf_host} ${perf_CURVALS}${perf_MEAN_ABS}	$perf_date"
    echo "*vgr ${perf_host} ${perf_RATIO_LIST}${perf_MEAN_REL}	$perf_args"
}


########################
# Run the actual tests #
########################

start="`date '+%H %M %S'`"
$ECHO "Running the BRL-CAD Benchmark tests... please wait ..."
$ECHO

bench moss all.g $ARGS << EOF
viewsize 1.572026215e+02;
eye_pt 6.379990387e+01 3.271768951e+01 3.366661453e+01;
viewrot -5.735764503e-01 8.191520572e-01 0.000000000e+00 0.000000000e+00
	-3.461886346e-01 -2.424038798e-01 9.063078165e-01 0.000000000e+00
	7.424039245e-01 5.198368430e-01 4.226182699e-01 0.000000000e+00
	0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00 ;
EOF

bench world all.g $ARGS << EOF
viewsize 1.572026215e+02;
eye_pt 6.379990387e+01 3.271768951e+01 3.366661453e+01;
viewrot -5.735764503e-01 8.191520572e-01 0.000000000e+00 0.000000000e+00
	-3.461886346e-01 -2.424038798e-01 9.063078165e-01 0.000000000e+00
	7.424039245e-01 5.198368430e-01 4.226182699e-01 0.000000000e+00
	0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00 ;
EOF

bench star all $ARGS << EOF
viewsize 2.500000000e+05;
eye_pt 2.102677960e+05 8.455500000e+04 2.934714650e+04;
viewrot -6.733560560e-01 6.130643360e-01 4.132114880e-01 0.000000000e+00
	5.539599410e-01 4.823888300e-02 8.311441420e-01 0.000000000e+00
	4.896120540e-01 7.885590550e-01 -3.720948210e-01 0.000000000e+00
	0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00 ;
EOF

bench bldg391 all.g $ARGS << EOF
viewsize 1.800000000e+03;
eye_pt 6.345012207e+02 8.633251343e+02 8.310771484e+02;
viewrot -5.735764503e-01 8.191520572e-01 0.000000000e+00 0.000000000e+00
	-3.461886346e-01 -2.424038798e-01 9.063078165e-01 0.000000000e+00
	7.424039245e-01 5.198368430e-01 4.226182699e-01 0.000000000e+00
	0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00;
EOF

bench m35 all.g $ARGS <<EOF
viewsize 6.787387985e+03;
eye_pt 3.974533127e+03 1.503320754e+03 2.874633221e+03;
viewrot -5.527838919e-01 8.332423558e-01 1.171090926e-02 0.000000000e+00
	-4.815587087e-01 -3.308784486e-01 8.115544728e-01 0.000000000e+00
	6.800964482e-01 4.429747496e-01 5.841593895e-01 0.000000000e+00
	0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00 ;
EOF

bench sphflake scene.r $ARGS <<EOF
viewsize 2.556283261452611e+04;
orientation 4.406810841785839e-01 4.005093234738861e-01 5.226451688385938e-01 6.101102288499644e-01;
eye_pt 2.418500583758302e+04 -3.328563644344796e+03 8.489926952850350e+03;
EOF

$ECHO
$ECHO "... Done."
$ECHO
$ECHO "Total testing time elapsed: `$ELP $start`"


##############################
# compute and output results #
##############################


performance="`perf 'moss world star bldg391 m35 sphflake' $ARGS`"
if test $? = 0 ; then
    cat >> summary <<EOF
$performance
EOF
fi

$ECHO
$ECHO "The following files have been generated and/or modified:"
$ECHO "  *.log ..... final log files for each individual raytrace test"
$ECHO "  *.pix ..... final pix image files for each individual raytrace test"
$ECHO "  *.log.* ... log files for previous frames and raytrace tests"
$ECHO "  *.pix.* ... pix image files for previous frames and raytrace tests"
$ECHO "  summary ... performance results summary, 2 lines per run"
$ECHO

$ECHO "Summary:"
cat <<EOF
$performance
EOF

### this confuses /bin/sh on solaris
#vgr="`cat <<EOF | grep vgr | awk '{print int($9+0.5)}'
#$performance
#EOF`"
vgr="`echo "$performance" | grep vgr | awk '{print int($9+0.5)}'`"

if test ! "x$vgr" = "x" ; then
    $ECHO
    $ECHO "#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#"
    $ECHO "Benchmark results indicate an approximate VGR performance metric of $vgr"
    ln=`echo $vgr | awk '{printf "%.2f", log($1)}'`
    lg=`echo $vgr | awk '{printf "%.2f", log($1) / log(10)}'`
    $ECHO "Logarithmic VGR metric is $lg  (natural logarithm is $ln)"
    $ECHO "#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#"
    $ECHO
    $ECHO "These numbers seem to indicate that this machine is approximately $vgr times"
    $ECHO "faster than the reference machine being used for comparison, a VAX 11/780"
    $ECHO "running 4.3 BSD named VGR.  These results are in fact approximately $lg"
    $ECHO "orders of magnitude faster than the reference."
    $ECHO

    $ECHO "Here are some other approximated VGR results for perspective:"
    $ECHO "   120 on a 200MHz R5000 running IRIX 6.5"
    $ECHO "   250 on a 500 MHz Pentium III running RedHat 7.1"
    $ECHO "   550 on a dual 450 MHz UltraSPARC II running SunOS 5.8"
    $ECHO "  1000 on a dual 500 MHz G4 PowerPC running Mac OS X 10.2"
    $ECHO "  1500 on a dual 1.66 GHz Athlon MP 2000+ running RedHat 7.3"
    $ECHO "  9000 on an 8 CPU 1.3 GHz Power4 running AIX 5.1"
    $ECHO " 65000 on a 512 CPU 400 MHz R12000 Running IRIX 6.5"
    $ECHO
fi


encourage_submission=yes
options=""
if test -f "${PATH_TO_THIS}/Makefile" ; then
    # See if this looks like an optimized build from a source distribution
    optimized=`grep O3 "${PATH_TO_THIS}/Makefile" | wc | awk '{print $1}'`
    if test $optimized -eq 0 ; then
	$ECHO "WARNING: This may not be an optimized compilation of BRL-CAD."
	$ECHO "Performance results may not be optimal."
	$ECHO
	options="$options --enable-optimized"
	encourage_submission=no
    fi
fi

if test -f moss.log ; then
    # See if this looks like a run-time disabled compilation
    runtime=`grep "debugging is disabled" moss.log | wc | awk '{print $1}'`
    if test $runtime -gt 0 ; then
	$ECHO "WARNING: This appears to be a compilation of BRL-CAD that has run-time"
	$ECHO "debugging disabled.  While this will generally give the best"
	$ECHO "performance results and is useful for long render tasks, it is"
	$ECHO "generally not utilized when comparing benchmark performance metrics."
	$ECHO
	options="$options --enable-runtime-debug"
	encourage_submission=no
    fi

    # See if this looks like a compile-time debug compilation
    runtime=`grep "debugging is enabled" moss.log | wc | awk '{print $1}'`
    if test $runtime -gt 0 ; then
	$ECHO "This appears to be a debug compilation of BRL-CAD."
	$ECHO
	options="$options --disable-debug"
    fi
fi

if test "x$encourage_submission" = "xno" ; then
    $ECHO "Official benchmark results are optimized builds with all run-time"
    $ECHO "features enabled and optionally without compile-time debug symbols."
    $ECHO
    if test -f "${PATH_TO_THIS}/Makefile" ; then
	$ECHO "For proper results, run 'make clean' and recompile with the"
	$ECHO "following configure options added:"
    else
	$ECHO "For proper results, you will need to install a version of the"
	$ECHO "benchmark that has been compiled with the following configure"
	$ECHO "options added:"
    fi
    $ECHO " $options"
    $ECHO
fi

# tell about the benchmark document
look_for file "" BENCHMARK_TR \
    ${PATH_TO_THIS}/../share/brlcad/*.*.*/doc/benchmark.tr \
    ${PATH_TO_THIS}/share/brlcad/*.*.*/doc/benchmark.tr \
    ${PATH_TO_THIS}/share/brlcad/doc/benchmark.tr \
    ${PATH_TO_THIS}/share/doc/benchmark.tr \
    ${PATH_TO_THIS}/doc/benchmark.tr \
    ${PATH_TO_THIS}/../doc/benchmark.tr \
    ./benchmark.tr

$ECHO "Read the benchmark.tr document for more details on the BRL-CAD Benchmark."
if test "x$BENCHMARK_TR" = "x" ; then
    $ECHO "The document should be available in the 'doc' directory of any source"
    $ECHO "or complete binary distribution of BRL-CAD."
else
    $ECHO "The document is available at $BENCHMARK_TR"
fi
$ECHO

# if this was a valid benchmark run, encourage submission of results.
if test "x$encourage_submission" = "xyes" ; then
    $ECHO "You are encouraged to submit your benchmark results and system"
    $ECHO "configuration information to benchmark@@brlcad.org"
    $ECHO
fi

$ECHO "Output was saved to $LOGFILE from `pwd`"
$ECHO "Benchmark testing complete."

# Local Variables:
# mode: sh
# tab-width: 8
# sh-indentation: 4
# sh-basic-offset: 4
# indent-tabs-mode: t
# End:
# ex: shiftwidth=4 tabstop=8
@


14.52
log
@just a commit test
@
text
@d97 1
a97 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.51 2007/09/11 18:40:02 erikgreenwald Exp $ (BRL)
d329 2
a330 1
    ./rt
d332 12
a343 10
look_for directory "a benchmark geometry directory" DB \
    ${PATH_TO_THIS}/../share/brlcad/*.*.*/db \
    ${PATH_TO_THIS}/share/brlcad/*.*.*/db \
    ${PATH_TO_THIS}/../share/brlcad/db \
    ${PATH_TO_THIS}/share/brlcad/db \
    ${PATH_TO_THIS}/../share/db \
    ${PATH_TO_THIS}/share/db \
    ${PATH_TO_THIS}/../db \
    ${PATH_TO_THIS}/db \
    ./db
@


14.51
log
@setting a log variable confuses some shells (solaris /bin/sh) and kills the log function, so rename the var to lg
@
text
@d97 2
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.50 2007/09/11 18:34:56 erikgreenwald Exp $ (BRL)
@


14.50
log
@fix parsing bit that confused /bin/sh on solaris
@
text
@d97 1
a97 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.49 2007/06/27 09:57:08 brlcad Exp $ (BRL)
d1099 2
a1100 2
    log=`echo $vgr | awk '{printf "%.2f", log($1) / log(10)}'`
    $ECHO "Logarithmic VGR metric is $log  (natural logarithm is $ln)"
d1105 1
a1105 1
    $ECHO "running 4.3 BSD named VGR.  These results are in fact approximately $log"
@


14.49
log
@say where the log file is
@
text
@d97 1
a97 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.48 2007/05/27 06:26:17 brlcad Exp $ (BRL)
d1088 6
a1093 3
vgr="`cat <<EOF | grep vgr | awk '{print int($9+0.5)}'
$performance
EOF`"
@


14.48
log
@differentiate between clean and clobber, allowing clean to remove files without being prompted while clobber also deletes the (new) benchmark.log files (but still not the summary file)
@
text
@d97 1
a97 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.47 2007/05/27 05:55:07 brlcad Exp $ (BRL)
d1196 1
a1196 1
$ECHO "Output was saved to $LOGFILE"
@


14.47
log
@add support for automatic logging of benchmark results to a file.  this is so users don't have to rerun and/or manually capture output if they want to review the output in detail.  also included is the date/time and uname of the system running the analysis.  make the file path searching output verbose-only now.  docs updated to reflect all these changes.
@
text
@d97 1
a97 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.46 2007/05/27 04:27:28 brlcad Exp $ (BRL)
d195 11
a205 1
if test "x$1" = "xclobber" ; then
d207 1
d209 7
a215 3
    $ECHO "About to wipe out all pictures and binary files in `pwd`"
    $ECHO "Send SIGINT (type ^C) within 5 seconds to abort"
    sleep 5
d217 1
d222 23
d246 5
a250 1
    $ECHO "Benchmark clobber complete."
@


14.46
log
@use VERBOSE_ECHO instead of testing DEBUG
@
text
@d85 3
a87 4
#   0) Operating system type and version (e.g. uname -a)
#   1) Compiler name and version (e.g. gcc --version)
#   2) CPU configuration (e.g. cat /proc/cpuinfo or hinv or sysctl -a)
#   3) Cache (data and/or instruction) details for L1/L2/L3 and system
d89 2
a90 3
#   4) Output from this script (e.g. ./run.sh > run.sh.log 2>&1)
#   5) All generated log files (e.g. *.log* after running run.sh)
#   6) Anything else you think might be relevant to performance
d97 1
a97 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.45 2007/05/27 04:21:23 brlcad Exp $ (BRL)
d152 10
d169 1
a169 1
    ECHO=echo
d177 13
d196 1
d203 1
a203 1
	echo rm -f $i.log $i.pix $i.log.[0-9]* $i.pix.[0-9]*
d211 4
d230 1
a230 1
	$ECHO  "Looking for $look_for_label"
a239 3
	    $VERBOSE_ECHO "searching ${look_for_dir}"
	    $VERBOSE_ECHO "`ls -lad ${look_for_dir}`"

d265 1
a265 1
		    $ECHO "...found $look_for_type ${look_for_dir}"
d275 1
a275 1
	    $ECHO "...using $look_for_var_val from $look_for_var variable setting"
a333 3
# end of searching, separate the output
$ECHO

d1153 1
@


14.45
log
@gnu sed apparently doesn't read from stdin, so make a custom test for it.
@
text
@d99 1
a99 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.44 2007/05/26 22:40:53 brlcad Exp $ (BRL)
d214 3
a216 4
	    if test "x$DEBUG" != "x" ; then
		$ECHO "searching ${look_for_dir}"
		ls -lad ${look_for_dir}
	    fi
d366 1
a366 3
	if test "x$DEBUG" != "x" ; then
	    $ECHO $set_if_unset_var
	fi
d450 1
a450 3
    if test "x$DEBUG" != "x" ; then
	$ECHO "DEBUG: Running $RT -B -M -s512 -H${run_hypersample} -J0 ${run_args} -o ${run_geomname}.pix ${DB}/${run_geomname}.g ${run_geometry}"
    fi
d458 1
a458 3
    if test "x$DEBUG" != "x" ; then
	$ECHO "DEBUG: Running $RT returned $retval"
    fi
d647 1
a647 3
    if test "x$DEBUG" != "x" ; then
	$ECHO "DEBUG: Beginning bench testing on $bench_testname using $bench_geometry"
    fi
d690 1
a690 3
		if test "x$DEBUG" != "x" ; then
		    $ECHO "DEBUG: ${bench_elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $bench_elapsed` pixels/s (inexact wallclock)"
		fi
d694 1
a694 3
		if test "x$DEBUG" != "x" ; then
		    $ECHO "DEBUG: ${bench_elapsed}s real elapsed,	`expr $bench_hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $bench_hypersample + 1 \) / $bench_elapsed \)` pixels/s (inexact wallclock)"
		fi
d762 1
a762 1
	if test "x$DEBUG" != "x" ; then
d770 1
a770 1
	    $ECHO "DEBUG: average=$bench_avg ; variance=$bench_variance ; deviation=$bench_deviation ($bench_avgpercent%) ; last run was ${bench_percent}%"
d803 1
a803 3
    if test "x$DEBUG" != "x" ; then
	$ECHO "DEBUG: Done benchmark testing on $bench_testname"
    fi
@


14.44
log
@saying 'this' sounds quirky when running through make, use pwd instead
@
text
@d99 1
a99 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.43 2007/05/26 20:17:22 brlcad Exp $ (BRL)
d123 1
a123 1
for __cmd in echo sed pwd ; do
d140 5
@


14.43
log
@add support for a clobber command argument so the benchmark tool can clean up after itself no matter where it's run from
@
text
@d99 1
a99 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.42 2007/05/26 19:59:26 brlcad Exp $ (BRL)
d123 1
a123 1
for __cmd in echo sed ; do
d171 1
a171 1
    $ECHO "About to wipe out all pictures and binary files in this directory"
@


14.42
log
@add sanity checks for commands that are required, add ability to quell output entirely via QUIET and verbosely with VERBOSE.
@
text
@d99 1
a99 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.41 2007/05/15 06:49:39 brlcad Exp $ (BRL)
d168 17
@


14.41
log
@look a little harder for resources, in case db resources are installed in more conventional share dir, for example.
@
text
@d64 2
a65 1
#   DEBUG - turn on extra debug output for testing/development
d99 1
a99 2
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.40 2007/03/13 18:04:37 brlcad Exp $ (BRL)

a102 2
name_of_this=`basename $0`
path_to_this=`dirname $0`
d104 14
a117 3

echo "B R L - C A D   B E N C H M A R K"
echo "================================="
d122 18
a139 2
# save the precious args
ARGS="$*"
d141 20
a160 4
# allow a debug hook, but don't announce it
if test "x${DEBUG}" = "x" ; then
#    DEBUG=1
    :
d164 4
d171 4
a175 2
# utility function to search for a certain filesystem object in a list of paths
look_for ( ) {
d182 1
a182 1
	echo  "Looking for $look_for_label"
d193 1
a193 1
		echo "searching ${look_for_dir}"
d221 1
a221 1
		    echo "...found $look_for_type ${look_for_dir}"
d231 1
a231 1
	    echo "...using $look_for_var_val from $look_for_var variable setting"
d237 4
a240 4
    ${path_to_this}/rt \
    ${path_to_this}/../bin/rt \
    ${path_to_this}/../src/rt/rt \
    ${path_to_this}/src/rt/rt \
d244 8
a251 8
    ${path_to_this}/../share/brlcad/*.*.*/db \
    ${path_to_this}/share/brlcad/*.*.*/db \
    ${path_to_this}/../share/brlcad/db \
    ${path_to_this}/share/brlcad/db \
    ${path_to_this}/../share/db \
    ${path_to_this}/share/db \
    ${path_to_this}/../db \
    ${path_to_this}/db \
d255 8
a262 8
    ${path_to_this}/../share/brlcad/*.*.*/pix \
    ${path_to_this}/share/brlcad/*.*.*/pix \
    ${path_to_this}/../share/brlcad/pix \
    ${path_to_this}/share/brlcad/pix \
    ${path_to_this}/../share/pix \
    ${path_to_this}/share/pix \
    ${path_to_this}/../pix \
    ${path_to_this}/pix \
d267 8
a274 8
    ${path_to_this}/../share/brlcad/*.*.*/pix \
    ${path_to_this}/share/brlcad/*.*.*/pix \
    ${path_to_this}/../share/brlcad/pix \
    ${path_to_this}/share/brlcad/pix \
    ${path_to_this}/../share/pix \
    ${path_to_this}/share/pix \
    ${path_to_this}/../pix \
    ${path_to_this}/pix \
d278 3
a280 3
    ${path_to_this}/pixcmp \
    ${path_to_this}/../bin/pixcmp \
    ${path_to_this}/../bench/pixcmp \
d284 4
a287 4
    ${path_to_this}/elapsed.sh \
    ${path_to_this}/../bin/elapsed.sh \
    ${path_to_this}/sh/elapsed.sh \
    ${path_to_this}/../sh/elapsed.sh \
d291 1
a291 1
echo
d300 1
a300 1
    echo "ERROR:  Could not find the BRL-CAD raytracer"
d303 1
a303 1
    echo "Using [$RT] for RT"
d306 1
a306 1
    echo "ERROR:  Could not find the BRL-CAD database directory"
d309 1
a309 1
    echo "Using [$DB] for DB"
d312 1
a312 1
    echo "ERROR:  Could not find the BRL-CAD reference images"
d315 1
a315 1
    echo "Using [$PIX] for PIX"
d318 1
a318 1
    echo "ERROR:  Could not find the BRL-CAD reference logs"
d321 1
a321 1
    echo "Using [$LOG] for LOG"
d324 1
a324 1
    echo "ERROR:  Could not find the BRL-CAD pixel comparison utility"
d327 1
a327 1
    echo "Using [$CMP] for CMP"
d330 1
a330 1
    echo "ERROR:  Could not find the BRL-CAD time elapsed script"
d333 1
a333 1
    echo "Using [$ELP] for ELP"
d346 1
a346 1
	    echo $set_if_unset_var
d354 1
a354 1
    echo "Using [${set_if_unset_val}] for $set_if_unset_name"
d363 1
a363 1
    echo "ERROR: MAXTIME must be greater or equal to TIMEFRAME"
d374 1
a374 1
echo
d382 1
a382 1
echo "RT reports the following version information:"
d385 1
a385 1
    echo "Unknown"
d391 1
a391 1
echo
d396 1
a396 1
    echo "Minimum run time is `$ELP $mintime`"
d398 1
a398 1
    echo "Maximum run time is `$ELP $maxtime`"
d403 2
a404 2
    echo "Estimated   time is `$ELP $estimate`"
    echo
d406 2
a407 2
    echo "WARNING: expr is unavailable, unable to compute statistics"
    echo
d432 1
a432 1
	echo "DEBUG: Running $RT -B -M -s512 -H${run_hypersample} -J0 ${run_args} -o ${run_geomname}.pix ${DB}/${run_geomname}.g ${run_geometry}"
d442 1
a442 1
	echo "DEBUG: Running $RT returned $retval"
d456 1
a456 1
	echo "ERROR: no numbers provided to average" 1>&2
d468 1
a468 1
	echo "ERROR: unexpected count in average" 1>&2
d526 1
a526 1
	echo "ERROR: cannot compute variance of zero numbers" 1>&2
d531 1
a531 1
	echo "ERROR: cannot compute variance of nothing" 1>&2
d540 1
a540 1
	echo "ERROR: unexpected zero count of numbers in variance" 1>&2
d543 1
a543 1
	echo "ERROR: unexpected negative count of numbers in variance" 1>&2
d575 1
a575 1
	echo "ERROR: cannot compute the square root of nothing" 1>&2
d578 1
a578 1
	echo "ERROR: square root of negative numbers is only in your imagination" 1>&2
d583 1
a583 1
    echo "1 1 + p" | dc 2>&1 >/dev/null
d593 1
a593 1
	echo "1 + 1" | bc 2>&1 >/dev/null
d625 1
a625 1
	echo "ERROR: argument mismatch, bench is missing the test name"
d629 1
a629 1
	echo "ERROR: argument mismatch, bench is missing the test geometry"
d633 1
a633 1
	echo "DEBUG: Beginning bench testing on $bench_testname using $bench_geometry"
d638 1
a638 1
    echo +++++ ${bench_testname}
d678 1
a678 1
		    echo "DEBUG: ${bench_elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $bench_elapsed` pixels/s (inexact wallclock)"
d684 1
a684 1
		    echo "DEBUG: ${bench_elapsed}s real elapsed,	`expr $bench_hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $bench_hypersample + 1 \) / $bench_elapsed \)` pixels/s (inexact wallclock)"
d721 1
a721 1
		echo "$bench_rtfm_line"
d726 1
a726 1
		echo "RAYTRACE ERROR"
d761 1
a761 1
	    echo "DEBUG: average=$bench_avg ; variance=$bench_variance ; deviation=$bench_deviation ($bench_avgpercent%) ; last run was ${bench_percent}%"
d782 1
a782 1
	echo ${bench_testname}.pix:  answers are RIGHT
d785 1
a785 1
	echo ${bench_testname}.pix:  answers are RIGHT
d788 1
a788 1
	echo ${bench_testname}.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d791 1
a791 1
	echo ${bench_testname}.pix:  BENCHMARK COMPARISON FAILURE
d795 1
a795 1
	echo "DEBUG: Done benchmark testing on $bench_testname"
d809 1
a809 1
	echo "ERROR: no tests specified for calculating performance" 1>&2
d837 1
a837 1
		    echo "ERROR: file $perf_log does not exist" 1>&2
d848 3
d856 1
a856 1
	echo "ERROR: Cannot locate VGR reference values" 1>&2
d873 1
a873 1
	echo "WARNING: only $# RTFM times found, adding a zero result." 1>&2
d880 1
a880 1
    echo "1 1 + p" | dc 2>&1 >/dev/null
d932 2
a933 2
echo "Running the BRL-CAD Benchmark tests... please wait ..."
echo
d986 4
a989 4
echo
echo "... Done."
echo
echo "Total testing time elapsed: `$ELP $start`"
d1004 8
a1011 8
echo
echo "The following files have been generated and/or modified:"
echo "  *.log ..... final log files for each individual raytrace test"
echo "  *.pix ..... final pix image files for each individual raytrace test"
echo "  *.log.* ... log files for previous frames and raytrace tests"
echo "  *.pix.* ... pix image files for previous frames and raytrace tests"
echo "  summary ... performance results summary, 2 lines per run"
echo
d1013 1
a1013 1
echo "Summary:"
d1022 3
a1024 3
    echo
    echo "#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#"
    echo "Benchmark results indicate an approximate VGR performance metric of $vgr"
d1027 18
a1044 18
    echo "Logarithmic VGR metric is $log  (natural logarithm is $ln)"
    echo "#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#"
    echo
    echo "These numbers seem to indicate that this machine is approximately $vgr times"
    echo "faster than the reference machine being used for comparison, a VAX 11/780"
    echo "running 4.3 BSD named VGR.  These results are in fact approximately $log"
    echo "orders of magnitude faster than the reference."
    echo

    echo "Here are some other approximated VGR results for perspective:"
    echo "   120 on a 200MHz R5000 running IRIX 6.5"
    echo "   250 on a 500 MHz Pentium III running RedHat 7.1"
    echo "   550 on a dual 450 MHz UltraSPARC II running SunOS 5.8"
    echo "  1000 on a dual 500 MHz G4 PowerPC running Mac OS X 10.2"
    echo "  1500 on a dual 1.66 GHz Athlon MP 2000+ running RedHat 7.3"
    echo "  9000 on an 8 CPU 1.3 GHz Power4 running AIX 5.1"
    echo " 65000 on a 512 CPU 400 MHz R12000 Running IRIX 6.5"
    echo
d1050 1
a1050 1
if test -f "${path_to_this}/Makefile" ; then
d1052 1
a1052 1
    optimized=`grep O3 "${path_to_this}/Makefile" | wc | awk '{print $1}'`
d1054 3
a1056 3
	echo "WARNING: This may not be an optimized compilation of BRL-CAD."
	echo "Performance results may not be optimal."
	echo
d1066 5
a1070 5
	echo "WARNING: This appears to be a compilation of BRL-CAD that has run-time"
	echo "debugging disabled.  While this will generally give the best"
	echo "performance results and is useful for long render tasks, it is"
	echo "generally not utilized when comparing benchmark performance metrics."
	echo
d1078 2
a1079 2
	echo "This appears to be a debug compilation of BRL-CAD."
	echo
d1085 6
a1090 6
    echo "Official benchmark results are optimized builds with all run-time"
    echo "features enabled and optionally without compile-time debug symbols."
    echo
    if test -f "${path_to_this}/Makefile" ; then
	echo "For proper results, run 'make clean' and recompile with the"
	echo "following configure options added:"
d1092 3
a1094 3
	echo "For proper results, you will need to install a version of the"
	echo "benchmark that has been compiled with the following configure"
	echo "options added:"
d1096 2
a1097 2
    echo " $options"
    echo
d1102 6
a1107 6
    ${path_to_this}/../share/brlcad/*.*.*/doc/benchmark.tr \
    ${path_to_this}/share/brlcad/*.*.*/doc/benchmark.tr \
    ${path_to_this}/share/brlcad/doc/benchmark.tr \
    ${path_to_this}/share/doc/benchmark.tr \
    ${path_to_this}/doc/benchmark.tr \
    ${path_to_this}/../doc/benchmark.tr \
d1110 1
a1110 1
echo "Read the benchmark.tr document for more details on the BRL-CAD Benchmark."
d1112 2
a1113 2
    echo "The document should be available in the 'doc' directory of any source"
    echo "or complete binary distribution of BRL-CAD."
d1115 1
a1115 1
    echo "The document is available at $BENCHMARK_TR"
d1117 1
a1117 1
echo
d1121 3
a1123 3
    echo "You are encouraged to submit your benchmark results and system"
    echo "configuration information to benchmark@@brlcad.org"
    echo
d1126 1
a1126 1
echo "Benchmark testing complete."
@


14.40
log
@pixcmp now reports non-zero code for off-by-one results. handle the new/expected return values.
@
text
@d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.39 2007/02/15 21:49:41 brlcad Exp $ (BRL)
d199 1
d201 1
d210 1
d212 1
d222 1
d224 1
@


14.39
log
@mention cmp
@
text
@d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.38 2007/01/27 01:41:28 brlcad Exp $ (BRL)
d722 1
a722 1
    # hopefully the last run is a stable representative of the performance
d726 3
a728 1
    if test $? = 0 ; then
d730 6
d737 2
a738 1
	echo ${bench_testname}.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
@


14.38
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d58 1
a58 1
#   CMP - the name of a pixcmp tool (e.g. ./pixcmp)
d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.37 2007/01/20 14:36:39 brlcad Exp $ (BRL)
@


14.37
log
@update copyright to 2007
@
text
@d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.36 2006/02/27 04:08:20 brlcad Exp $ (BRL)
d137 1
a137 1
    
d623 1
a623 1
	        # just finished the first frame
d635 2
a636 2
	        # increase the number of rays exponentially if we are
	        # considerably faster than the TIMEFRAME required.
d823 1
a823 1
	
d830 1
a830 1
        # Note: append new value and a trail TAB to existing list.
@


14.36
log
@doesn't test the compiler, tests a system
@
text
@d5 1
a5 1
# Copyright (c) 2004-2006 United States Government as represented by
d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.35 2006/01/18 06:46:10 brlcad Exp $ (BRL)
@


14.35
log
@update copyright to 2006
@
text
@d39 6
a44 6
# will test the performance of a given compiler by iteratively
# rendering several well-known datasets into 512x512 images where
# performance metrics are documented and fairly well understood.  The
# local machine's performance is compared to the base system (called
# VGR) and a numeric "VGR" mulitplier of performance is computed.
# This number is a simplified metric from which one may qualitatively
d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.34 2005/12/21 04:10:52 brlcad Exp $ (BRL)
@


14.34
log
@protect against division by negative numbers and returning a negative variance, fixes benchmark output complaining about trying to take a square root of a negative number
@
text
@d5 1
a5 1
# Copyright (C) 2004-2005 United States Government as represented by
d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.33 2005/12/12 23:14:43 brlcad Exp $ (BRL)
@


14.33
log
@report the LOG setting
@
text
@d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.32 2005/12/07 22:27:28 brlcad Exp $ (BRL)
d487 4
a490 1
	echo "ERROR: unexpected zero count in variance" 1>&2
d504 5
@


14.32
log
@the perf.sh script is completely absorbed into run.sh as the function perf() allowing utilization of run.sh's existing search techniques for locating resources.  This fixes a problem/bug where perf.sh was incorrectly searching the right directory for reference logs.  by bringing the functionality internal, run.sh now gets to control righting to summary and there is no need to blindly tail the summary file for results.
@
text
@d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.31 2005/11/11 21:34:28 brlcad Exp $ (BRL)
d264 6
@


14.31
log
@more consistency between the tail/head checking for the functionality of -n.  check for head and tail separately
@
text
@d57 1
d95 1
d98 1
a98 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.30 2005/11/04 12:34:02 brlcad Exp $ (BRL)
d103 1
d214 10
d352 3
a354 3
#########################
# run and compute stats #
#########################
d725 126
a850 1
# Run the actual tests
a916 7
HOST="`hostname`"
if test $? != 0 ; then
    HOST="`uname -n`"
    if test $? != 0 ; then
	HOST="unknown"
    fi
fi
d918 5
a922 16
case "x`echo 'tail' | tail -n 1 2>&1`" in
    *xtail*) TAIL_N="n " ;;
    *) TAIL_N="" ;;
esac

if test -f "$path_to_this/perf.sh" ; then
    PERF="$path_to_this/perf.sh"
elif test -f "$path_to_this/../bench/perf.sh" ; then
    PERF="$path_to_this/../bench/perf.sh"
else
    # see if it is in our path
    PERF="perf.sh"
    $PERF > /dev/null 2>&1
    if test "x$?" != "x1" ; then
	PERF="false"
    fi
a923 2
sh "$PERF" "$HOST" "`date`" "$*" >> summary
perf_ret=$?
d932 1
d934 4
a937 7
if test $perf_ret != 0 ; then
    tail -${TAIL_N}1 summary
    exit $perf_ret
else
    echo
    tail -${TAIL_N}2 summary
fi
d939 3
a941 1
vgr="`tail -${TAIL_N}1 summary | awk '{print int($9+0.5)}'`"
@


14.30
log
@it's not _really_ necessary that there be no debug symbols, just make a note of it in the output.  inform about the benchmark.tr document regardless.
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.29 2005/11/04 12:14:28 brlcad Exp $ (BRL)
d787 4
a790 4
TAIL="tail -"
if test "x`echo 'tail' | tail -n 1 2>&1`" = "xtail" ; then
    TAIL="tail -n "
fi
d816 1
a816 1
    ${TAIL}1 summary
d820 1
a820 1
    ${TAIL}2 summary
d823 1
a823 1
vgr="`${TAIL}1 summary | awk '{print int($9+0.5)}'`"
@


14.29
log
@add support to look for specific types of files, executables, dirs, scripts as well as cleaning up detection and output of whether this is a 'valid' benchmark run.  if it does seem to be valid, inform about the documentation and encourage submission of results.
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.28 2005/11/04 10:56:18 brlcad Exp $ (BRL)
d851 1
d857 3
d861 1
d869 5
d875 1
d881 2
d887 1
a887 22
for opt in $options ; do
    case "x$opt" in 
	x--enable-optimized)
	    echo "WARNING: This may not be an optimized compilation of BRL-CAD."
	    echo "Performance results may not be optimal."
	    echo
	    ;;
	x--enable-runtime-debug)
	    echo "WARNING: This appears to be a compilation of BRL-CAD that has run-time"
	    echo "debugging disabled.  While this will generally give the best"
	    echo "performance results and is useful for long render tasks, it is"
	    echo "generally not utilized when comparing benchmark performance metrics."
	    echo
	    ;;
	x--disable-debug)
	    echo "WARNING: This appears to be a debug compilation of BRL-CAD."
	    echo "Performance results may not be optimal."
	    echo
	    ;;
    esac
done
if test "x$options" != "x" ; then
d889 1
a889 1
    echo "features enabled and compile-time debugging disabled."
d903 23
a925 22
# if this was a valid benchmark run, tell about the benchmark document
# and encourage submission of results.
if test "x$options" = "x" ; then
    look_for file "" BENCHMARK_TR \
	${path_to_this}/../share/brlcad/*.*.*/doc/benchmark.tr \
	${path_to_this}/share/brlcad/*.*.*/doc/benchmark.tr \
	${path_to_this}/share/brlcad/doc/benchmark.tr \
	${path_to_this}/share/doc/benchmark.tr \
	${path_to_this}/doc/benchmark.tr \
	${path_to_this}/../doc/benchmark.tr \
	./benchmark.tr

    echo "Read the benchmark.tr document for more details on the BRL-CAD Benchmark."
    if test "x$BENCHMARK_TR" = "x" ; then
	echo "The document should be available in the 'doc' directory of any source"
	echo "or complete binary distribution of BRL-CAD."
    else
	echo "The document is available at $BENCHMARK_TR"
    fi
    echo
    echo "You are encouraged to submit your benchmark results along with"
    echo "system configuration information to benchmark@@brlcad.org"
@


14.28
log
@refactor the resource searching into a look_for function so that it's clear exactly what directories are being searched for which resources.  remove the compiling and automatic conversion of encountered ascii files for now too.  resources are searched for presuming first that we're a binary install and failing that, we're being run from a source distribution after a make or make benchmark.  identify the major sections with comment labels, and rename the benchmark function to bench in order to not be confused with the tool of the same name.  this fixes a bug in the run-time identification of resources in the share/brlcad/VERSION directory.
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.27 2005/11/01 08:47:46 brlcad Exp $ (BRL)
d126 1
d131 3
a133 1
    echo  "Looking for $look_for_label"
d146 27
a172 2
	    if test -x "${look_for_dir}" ; then
		echo "...found ${look_for_dir}"
d180 3
a182 1
	echo "...using $look_for_var_val from $look_for_var variable setting"
d186 1
a186 1
look_for "the BRL-CAD raytracer" RT \
d193 1
a193 1
look_for "a benchmark geometry directory" DB \
d202 1
a202 1
look_for "a benchmark reference image directory" PIX \
d211 1
a211 1
look_for "a pixel comparison utility" CMP \
d217 1
a217 1
look_for "a time elapsed utility" ELP \
d679 1
a679 1
		bench_avgpercent=`echo $bench_deviation $bench_avg | awk '{print $1 / $2 * 100}"`
d775 3
a777 1
# Compute and output the results
d850 19
a868 3
# See if this looks like a run-time disabled build
if test -f moss.g ; then
    runtime=`grep "debugging is disabled" moss.g | wc | awk '{print $1}'`
d870 1
a870 11
	echo "WARNING: This appears to be a compilation of BRL-CAD that has run-time"
	echo "debugging disabled.  While this will generally give the best"
	echo "performance results and is useful for long render tasks, but it is"
	echo "generally not considered when comparing benchmark performance metrics."
	echo "Official benchmark results are optimized builds with all run-time"
	echo "features enabled."
	echo
	echo "For proper results, run 'make clean' and recompile using the"
	echo "following configure options:"
	echo "    --enable-runtime-debug  --enable-optimized"
	echo
d874 55
a928 11
# See if this looks like an optimized build
if test -f "$path_to_this/Makefile" ; then
    optimized=`grep O3 "$path_to_this/Makefile" | wc | awk '{print $1}'`
    if test $optimized -eq 0 ; then
	echo "WARNING: This may not be an optimized compilation of BRL-CAD."
	echo "Performance results may not be optimal."
	echo
	echo "For proper results, run 'make clean' and recompile using the"
	echo "following configure options:"
	echo "    --enable-optimized"
	echo
d930 4
d936 1
a936 2
echo "Testing complete."
echo "Read the benchmark.tr document for more details on the BRL-CAD Benchmark."
@


14.27
log
@accept a modified version of Stefan Fiedler's tail/head patch for -n # instead of -# as the line option.  this conforms to _POSIX2_VERSION 200112 and tools compiled against said posix version too.
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.26 2005/10/23 04:24:41 brlcad Exp $ (BRL)
d113 4
a116 17
echo Looking for RT...
# find the raytracer
# RT environment variable overrides
if test "x${RT}" = "x" ; then
    # see if we find the rt binary
    if test -x "$path_to_this/../src/rt/rt" ; then
	echo ...found $path_to_this/../src/rt/rt
	RT="$path_to_this/../src/rt/rt"
    elif test -x "$path_to_this/rt" ; then
	echo ...found $path_to_this/rt
	RT="$path_to_this/rt"
    elif test -x "$path_to_this/../bin/rt" ; then
	echo ...found $path_to_this/../bin/rt
	RT="$path_to_this/../bin/rt"
    fi
else
    echo ...using $RT from RT environment variable setting
a118 52
echo Looking for benchmark geometry ...
# find geometry database directory if we do not already know where it
# is. DB environment variable overrides
if test "x${DB}" = "x" ; then
    if test -f "$path_to_this/../db/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_this/../db
	DB="$path_to_this/../db"
    elif test -f "$path_to_this/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_this
	DB="$path_to_this"
    elif test -f "$path_to_this/../share/brlcad/db/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_this/../share/brlcad/db
	DB="$path_to_this/../share/brlcad/db"
    elif test -f "sphflake.g" ; then
	echo ...found .g geometry files in .
	DB="."
    elif test -f "$path_to_this/../db/sphflake.asc" ; then
	echo ...found ascii geometry files in $path_to_this/../db

	echo Looking for asc2g converter ...
	if test "x${ASC2G}" = "x" ; then
	    ASC2G="asc2g"
	    if test -x "$path_to_this/../src/conv/asc2g" ; then
		echo ...found $path_to_this/../src/conv/asc2g
		ASC2G="$path_to_this/../src/conv/asc2g"
	    elif test -f "$path_to_this/../src/conv/asc2g.c" ; then
		echo ...need to compile asc2g

		for compiler in $CC gcc cc ; do
		    COMPILE="$compiler"

		    if test "x$COMPILE" = "x" ; then
			continue
		    fi

		    $COMPILE -o asc2g "$path_to_this/../src/conv/asc2g" -I"$path_to_this/../include" -DHAVE_CONFIG_H -L/usr/brlcad/lib -L"$path_to_this/../src/libwdb/.libs" -L"$path_to_this/../src/librt/.libs" -L"$path_to_this/../src/libbu/.libs" -L"$path_to_this/../src/libbn/.libs" -L"$path_to_this/../src/other/libtcl/.libs" -lwdb -lrt -lbu -lbn -ltcl
		    if test "x$?" = "x0" ; then
			break
		    fi
		    if test -f "asc2g" ; then
			break
		    fi
		done

		if test -f "asc2g" ; then
		    echo ...compiled asc2g with $COMPILE -o asc2g src/conv/asc2g.c
		    ASC2G="./asc2g"
		fi
	    fi
	else
	    echo ...using $ASC2G from ASC2G environment variable setting
	fi
d120 29
a148 9
	failed=no
	for geometry in moss world star bldg391 m35 sphflake ; do
	    echo ... creating ${geometry}.g
	    $ASC2G "$path_to_this/../db/${geometry}.asc" ${geometry}.g
	    if test "x$?" != "x0" ; then
		if test ! -f ${geometry}.g ; then
		    failed=yes
		    break;
		fi
d151 2
a152 4
	if test "x$failed" = "xno" ; then
	    DB="."
	    echo ...using $DB for geometry database directory
	fi
d154 1
a154 3
else
    echo ...using $DB from DB environment variable setting
fi
d156 37
a192 17
echo Looking for benchmark images ...
# find pix reference image directory if we do not already know where
# it is.  PIX environment variable overrides
if test "x${PIX}" = "x" ; then
    if test -f "$path_to_this/../pix/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_this/../pix
	PIX="$path_to_this/../pix"
    elif test -f "$path_to_this/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_this
	PIX="$path_to_this"
    elif test -f "$path_to_this/../share/brlcad/pix/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_this/../share/brlcad/pix
	PIX="$path_to_this/../share/brlcad/pix"
    fi
else
    echo ...using $PIX from PIX environment variable setting
fi
d194 2
a195 13
echo Checking for pixel comparison utility...
# find pixel comparison utility
# CMP environment variable overrides
if test "x${CMP}" = "x" ; then
    if test -x $path_to_this/pixcmp ; then
	echo ...found $path_to_this/pixcmp
	CMP="$path_to_this/pixcmp"
    else
	if test -f "$path_to_this/pixcmp.c" ; then
	    echo ...need to build pixcmp

	    for compiler in $CC gcc cc ; do
		COMPILE="$compiler"
a196 3
		if test "x$COMPILE" = "x" ; then
		    continue
		fi
d198 3
a200 8
		$COMPILE -o pixcmp "$path_to_this/pixcmp.c"
		if test "x$?" = "x0" ; then
		    break
		fi
		if test -f "pixcmp" ; then
		    break;
		fi
	    done
d202 1
a202 29
	    if test -f "pixcmp" ; then
		echo ...built pixcmp with $COMPILE -o pixcmp pixcmp.c
		CMP="./pixcmp"
	    fi
	fi
    fi
else
    echo ...using $CMP from CMP environment variable setting
fi

echo Checking for time elapsed utility...
# find time elapsed script
# ELP environment variable overrides
if test "x${ELP}" = "x" ; then
    if test -x $path_to_this/../sh/elapsed.sh ; then
	echo ...found $path_to_this/../sh/elapsed.sh
	ELP="$path_to_this/../sh/elapsed.sh"
    elif test -x $path_to_this/elapsed.sh ; then
	echo ...found $path_to_this/elapsed.sh
	ELP="$path_to_this/elapsed.sh"
    elif test -x $path_to_this/../bin/elapsed.sh ; then
	echo ...found $path_to_this/../bin/elapsed.sh
	ELP="$path_to_this/../bin/elapsed.sh"
    fi
else
    echo ...using $ELP from ELP environment variable setting
fi

# print results or choke
d234 21
d256 1
a256 4
if test "x${TIMEFRAME}" = "x" ; then
    TIMEFRAME=32
fi
echo "Using [$TIMEFRAME] for TIMEFRAME"
d259 1
a259 3
if test "x${MAXTIME}" = "x" ; then
    MAXTIME=300
fi
a263 1
echo "Using [$MAXTIME] for MAXTIME"
d266 1
a266 4
if test "x${DEVIATION}" = "x" ; then
    DEVIATION=3
fi
echo "Using [$DEVIATION] for DEVIATION"
d269 3
a271 4
if test "x${AVERAGE}" = "x" ; then
    AVERAGE=3
fi
echo "Using [$AVERAGE] for AVERAGE"
d274 5
d291 15
a305 8
# let the user know about how long this might take
mintime="`expr $TIMEFRAME \* 6`"
echo "Minimum run time is `$ELP $mintime`"
maxtime="`expr $MAXTIME \* 6`"
echo "Maximum run time is `$ELP $maxtime`"
estimate="`expr $mintime \* 3`"
if test $estimate -gt $maxtime ; then
    estimate="$maxtime"
a306 1
echo "Estimated   time is `$ELP $estimate`"
a307 6
# allow a debug hook, but don't announce it
if test "x${DEBUG}" = "x" ; then
#    DEBUG=1
    :
fi
echo
d309 3
d318 1
a318 1
#   DB :+ path to the geometry file
d502 1
a502 1
# benchmark test_name geometry [..rt args..]
d509 4
a512 4
benchmark ( ) {
    benchmark_testname="$1" ; shift
    benchmark_geometry="$1" ; shift
    benchmark_args="$*"
d514 2
a515 2
    if test "x$benchmark_testname" = "x" ; then
	echo "ERROR: argument mismatch, benchmark is missing the test name"
d518 2
a519 2
    if test "x$benchmark_geometry" = "x" ; then
	echo "ERROR: argument mismatch, benchmark is missing the test geometry"
d523 1
a523 1
	echo "DEBUG: Beginning benchmark testing on $benchmark_testname using $benchmark_geometry"
d526 1
a526 1
    benchmark_view="`cat`"
d528 7
a534 7
    echo +++++ ${benchmark_testname}
    benchmark_hypersample=0
    benchmark_frame=0
    benchmark_rtfms=""
    benchmark_percent=100
    benchmark_start_time="`date '+%H %M %S'`"
    benchmark_overall_elapsed=0
d536 1
a536 1
    while test $benchmark_overall_elapsed -lt $MAXTIME ; do
d538 2
a539 2
	benchmark_elapsed=0
	while test $benchmark_elapsed -lt $TIMEFRAME ; do
d541 2
a542 2
	    if test -f ${benchmark_testname}.pix; then mv -f ${benchmark_testname}.pix ${benchmark_testname}.pix.$$; fi
	    if test -f ${benchmark_testname}.log; then mv -f ${benchmark_testname}.log ${benchmark_testname}.log.$$; fi
d544 1
a544 1
	    benchmark_frame_start_time="`date '+%H %M %S'`"
d546 3
a548 3
	    run $benchmark_testname $benchmark_geometry $benchmark_hypersample $benchmark_args 2> ${benchmark_testname}.log << EOF
$benchmark_view
start $benchmark_frame;
d553 1
a553 1
	    if test -f ${benchmark_testname}.pix.$benchmark_frame ; then mv -f ${benchmark_testname}.pix.$benchmark_frame ${benchmark_testname}.pix ; fi
d557 3
a559 3
	    benchmark_elapsed="`$ELP --seconds $benchmark_frame_start_time`"
	    if test "x$benchmark_elapsed" = "x" ; then
		benchmark_elapsed=1
d561 2
a562 2
	    if test $benchmark_elapsed -eq 0 ; then
		benchmark_elapsed=1
d564 1
a564 1
	    if test "x$benchmark_hypersample" = "x0" ; then
d568 1
a568 1
		    echo "DEBUG: ${benchmark_elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $benchmark_elapsed` pixels/s (inexact wallclock)"
d570 2
a571 2
		benchmark_hypersample=1
		benchmark_frame="`expr $benchmark_frame + 1`"
d574 1
a574 1
		    echo "DEBUG: ${benchmark_elapsed}s real elapsed,	`expr $benchmark_hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $benchmark_hypersample + 1 \) / $benchmark_elapsed \)` pixels/s (inexact wallclock)"
d580 1
a580 1
		if test `expr $benchmark_elapsed \* 32` -le ${TIMEFRAME} ; then
d582 3
a584 3
		    benchmark_hypersample="`expr $benchmark_hypersample \* 32 + 31`"
		    benchmark_frame="`expr $benchmark_frame + 5`"
		elif test `expr $benchmark_elapsed \* 16` -le ${TIMEFRAME} ; then
d586 3
a588 3
		    benchmark_hypersample="`expr $benchmark_hypersample \* 16 + 15`"
		    benchmark_frame="`expr $benchmark_frame + 4`"
		elif test `expr $benchmark_elapsed \* 8` -le ${TIMEFRAME} ; then
d590 3
a592 3
		    benchmark_hypersample="`expr $benchmark_hypersample \* 8 + 7`"
		    benchmark_frame="`expr $benchmark_frame + 3`"
		elif test `expr $benchmark_elapsed \* 4` -le ${TIMEFRAME} ; then
d594 2
a595 2
		    benchmark_hypersample="`expr $benchmark_hypersample \* 4 + 3`"
		    benchmark_frame="`expr $benchmark_frame + 2`"
d598 2
a599 2
		    benchmark_hypersample="`expr $benchmark_hypersample + $benchmark_hypersample + 1`"
		    benchmark_frame="`expr $benchmark_frame + 1`"
d604 8
a611 8
	    benchmark_rtfm_line="`grep RTFM ${benchmark_testname}.log`"
	    benchmark_rtfm="`echo $benchmark_rtfm_line | awk '{print int($9+0.5)}'`"
	    if test "x$benchmark_rtfm" = "x" ; then
		benchmark_rtfm="0"
	    fi
	    benchmark_rtfms="$benchmark_rtfm $benchmark_rtfms"
	    if test ! "x$benchmark_rtfm_line" = "x" ; then
		echo "$benchmark_rtfm_line"
d621 2
a622 2
	    benchmark_overall_elapsed="`$ELP --seconds $benchmark_start_time`"
	    if test $benchmark_overall_elapsed -ge $MAXTIME ; then
d627 2
a628 2
	if test "x$benchmark_rtfm" = "x" ; then
	    benchmark_rtfm="0"
d630 2
a631 2
	if test "x$benchmark_rtfms" = "x" ; then
	    benchmark_rtfms="0"
d635 4
a638 4
	benchmark_variance="`variance $AVERAGE $benchmark_rtfms`"
	benchmark_deviation="`sqrt $benchmark_variance`"
	if test $benchmark_rtfm -eq 0 ; then
	    benchmark_percent=0
d640 1
a640 1
	    benchmark_percent=`echo $benchmark_deviation $benchmark_rtfm | awk '{print int(($1 / $2 * 100)+0.5)}'`
d644 4
a647 4
	    benchmark_vals="`getvals $AVERAGE $benchmark_rtfms`"
	    benchmark_avg="`average $benchmark_vals`"
	    if test $benchmark_avg -eq 0 ; then
		benchmark_avgpercent=0
d649 1
a649 1
		benchmark_avgpercent=`echo $benchmark_deviation $benchmark_avg | awk '{print $1 / $2 * 100}"`
d651 1
a651 1
	    echo "DEBUG: average=$benchmark_avg ; variance=$benchmark_variance ; deviation=$benchmark_deviation ($benchmark_avgpercent%) ; last run was ${benchmark_percent}%"
d655 1
a655 1
	if test $benchmark_percent -le $DEVIATION ; then
d659 1
a659 1
	benchmark_overall_elapsed="`$ELP --seconds $benchmark_start_time`"
d662 1
a662 1
	benchmark_hypersample="`expr \( \( $benchmark_hypersample + 1 \) / 2 \) - 1`"
d667 2
a668 2
    if test -f gmon.out; then mv -f gmon.out gmon.${benchmark_testname}.out; fi
    ${CMP} ${PIX}/${benchmark_testname}.pix ${benchmark_testname}.pix
d670 1
a670 1
	echo ${benchmark_testname}.pix:  answers are RIGHT
d672 1
a672 1
	echo ${benchmark_testname}.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d676 1
a676 1
	echo "DEBUG: Done benchmark testing on $benchmark_testname"
d682 1
a682 1
# Run the tests
d688 1
a688 1
benchmark moss all.g $ARGS << EOF
d697 1
a697 1
benchmark world all.g $ARGS << EOF
d706 1
a706 1
benchmark star all $ARGS << EOF
d715 1
a715 1
benchmark bldg391 all.g $ARGS << EOF
d724 1
a724 1
benchmark m35 all.g $ARGS <<EOF
d733 1
a733 1
benchmark sphflake scene.r $ARGS <<EOF
@


14.26
log
@trailing ws
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.25 2005/07/16 21:39:36 brlcad Exp $ (BRL)
d812 5
d841 1
a841 1
    tail -1 summary
d845 1
a845 1
    tail -2 summary
d847 2
a848 1
vgr="`tail -1 summary | awk '{print int($9+0.5)}'`"
@


14.25
log
@use the more generic path_to_this instead of path_to_run_sh so the var can be consistent across scripts
@
text
@d15 1
a15 1
# 2. Redistributions in binary form must reproduce the above 
d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.24 2005/06/01 21:54:59 brlcad Exp $ (BRL)
d175 1
a175 1
		
d249 1
a249 1
	    
d367 1
a367 1
echo 
d464 1
a464 1
    
d489 1
a489 1
    
d600 1
a600 1
	    
d611 1
a611 1
	
d731 1
a731 1
    
d766 3
a768 3
viewrot -6.733560560e-01 6.130643360e-01 4.132114880e-01 0.000000000e+00 
	5.539599410e-01 4.823888300e-02 8.311441420e-01 0.000000000e+00 
	4.896120540e-01 7.885590550e-01 -3.720948210e-01 0.000000000e+00 
d784 3
a786 3
viewrot -5.527838919e-01 8.332423558e-01 1.171090926e-02 0.000000000e+00 
	-4.815587087e-01 -3.308784486e-01 8.115544728e-01 0.000000000e+00 
	6.800964482e-01 4.429747496e-01 5.841593895e-01 0.000000000e+00 
@


14.25.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d15 1
a15 1
# 2. Redistributions in binary form must reproduce the above
d96 1
a96 1
#  @@(#)$Header$ (BRL)
d113 17
a129 4
# allow a debug hook, but don't announce it
if test "x${DEBUG}" = "x" ; then
#    DEBUG=1
    :
d132 52
d185 19
a203 10
########################
# search for resources #
########################

# utility function to search for a certain filesystem object in a list of paths
look_for ( ) {
    look_for_type="$1" ; shift
    look_for_label="$1" ; shift
    look_for_var="$1" ; shift
    look_for_dirs="$*"
d205 13
a217 2
    if test "x$look_for_label" != "x" ; then
	echo  "Looking for $look_for_label"
d219 24
a242 32
    
    # get the value of the variable
    look_for_var_var="echo \"\$$look_for_var\""
    look_for_var_val="`eval ${look_for_var_var}`"

    if test "x${look_for_var_val}" = "x" ; then
	for look_for_dir in $look_for_dirs ; do

	    if test "x$DEBUG" != "x" ; then
		echo "searching ${look_for_dir}"
		ls -lad ${look_for_dir}
	    fi
	    opts="-r"
	    case "x$look_for_type" in
		xfile)
		    opts="$opts -f"
		    ;;
		xdir*)
		    # should work without read bit
		    opts="-d -x"
		    ;;
		xexe*)
		    opts="$opts -x"
		    ;;
		xscr*)
		    opts="$opts -x"
		    ;;
	    esac
	    look_for_failed=no
	    for opt in $opts ; do
		if test ! $opt "${look_for_dir}" ; then
		    look_for_failed=yes
d245 3
d249 4
a252 8
	    if test "x$look_for_failed" = "xno" ; then
		if test "x$look_for_label" != "x" ; then
		    echo "...found $look_for_type ${look_for_dir}"
		fi
		look_for_var_var="${look_for_var}=\"${look_for_dir}\""
		eval $look_for_var_var
		export $look_for_var
		break
a253 4
	done
    else
	if test "x$look_for_label" != "x" ; then
	    echo "...using $look_for_var_val from $look_for_var variable setting"
d256 3
a258 1
}
d260 17
a276 40
look_for executable "the BRL-CAD raytracer" RT \
    ${path_to_this}/rt \
    ${path_to_this}/../bin/rt \
    ${path_to_this}/../src/rt/rt \
    ${path_to_this}/src/rt/rt \
    ./rt

look_for directory "a benchmark geometry directory" DB \
    ${path_to_this}/../share/brlcad/*.*.*/db \
    ${path_to_this}/share/brlcad/*.*.*/db \
    ${path_to_this}/share/brlcad/db \
    ${path_to_this}/share/db \
    ${path_to_this}/../db \
    ${path_to_this}/db \
    ./db

look_for directory "a benchmark reference image directory" PIX \
    ${path_to_this}/../share/brlcad/*.*.*/pix \
    ${path_to_this}/share/brlcad/*.*.*/pix \
    ${path_to_this}/share/brlcad/pix \
    ${path_to_this}/share/pix \
    ${path_to_this}/../pix \
    ${path_to_this}/pix \
    ./pix

look_for executable "a pixel comparison utility" CMP \
    ${path_to_this}/pixcmp \
    ${path_to_this}/../bin/pixcmp \
    ${path_to_this}/../bench/pixcmp \
    ./pixcmp

look_for script "a time elapsed utility" ELP \
    ${path_to_this}/elapsed.sh \
    ${path_to_this}/../bin/elapsed.sh \
    ${path_to_this}/sh/elapsed.sh \
    ${path_to_this}/../sh/elapsed.sh \
    ./elapsed.sh

# end of searching, separate the output
echo
d278 1
a278 6

#####################
# output parameters #
#####################

# sanity check, output all the final settings together
a309 21
# utility function to set a variable if it's not already set to something
set_if_unset ( ) {
    set_if_unset_name="$1" ; shift
    set_if_unset_val="$1" ; shift

    set_if_unset_var="echo \"\$$set_if_unset_name\""
    set_if_unset_var_val="`eval ${set_if_unset_var}`"
    if test "x${set_if_unset_var_val}" = "x" ; then
	set_if_unset_var="${set_if_unset_name}=\"${set_if_unset_val}\""
	if test "x$DEBUG" != "x" ; then
	    echo $set_if_unset_var
	fi
	eval $set_if_unset_var
	export $set_if_unset_name
    fi

    set_if_unset_var="echo \"\$$set_if_unset_name\""
    set_if_unset_val="`eval ${set_if_unset_var}`"
    echo "Using [${set_if_unset_val}] for $set_if_unset_name"
}

d311 4
a314 1
set_if_unset TIMEFRAME 32
d317 3
a319 1
set_if_unset MAXTIME 300
d324 1
d327 4
a330 1
set_if_unset DEVIATION 3
d333 4
a336 3
set_if_unset AVERAGE 3

# end of settings, separate the output
a338 5

##########################
# output run-time status #
##########################

d351 8
a358 15
# if expr works, let the user know about how long this might take
if test "x`expr 1 - 1 2>/dev/null`" = "x0" ; then
    mintime="`expr $TIMEFRAME \* 6`"
    echo "Minimum run time is `$ELP $mintime`"
    maxtime="`expr $MAXTIME \* 6`"
    echo "Maximum run time is `$ELP $maxtime`"
    estimate="`expr $mintime \* 3`"
    if test $estimate -gt $maxtime ; then
	estimate="$maxtime"
    fi
    echo "Estimated   time is `$ELP $estimate`"
    echo
else
    echo "WARNING: expr is unavailable, unable to compute statistics"
    echo
d360 1
d362 6
a368 3
#########################
# run and compute stats #
#########################
d375 1
a375 1
#   DB := path to the geometry file
d464 1
a464 1

d489 1
a489 1

d559 1
a559 1
# bench test_name geometry [..rt args..]
d566 4
a569 4
bench ( ) {
    bench_testname="$1" ; shift
    bench_geometry="$1" ; shift
    bench_args="$*"
d571 2
a572 2
    if test "x$bench_testname" = "x" ; then
	echo "ERROR: argument mismatch, bench is missing the test name"
d575 2
a576 2
    if test "x$bench_geometry" = "x" ; then
	echo "ERROR: argument mismatch, bench is missing the test geometry"
d580 1
a580 1
	echo "DEBUG: Beginning bench testing on $bench_testname using $bench_geometry"
d583 1
a583 9
    bench_view="`cat`"

    echo +++++ ${bench_testname}
    bench_hypersample=0
    bench_frame=0
    bench_rtfms=""
    bench_percent=100
    bench_start_time="`date '+%H %M %S'`"
    bench_overall_elapsed=0
d585 7
a591 1
    while test $bench_overall_elapsed -lt $MAXTIME ; do
d593 1
a593 2
	bench_elapsed=0
	while test $bench_elapsed -lt $TIMEFRAME ; do
d595 2
a596 2
	    if test -f ${bench_testname}.pix; then mv -f ${bench_testname}.pix ${bench_testname}.pix.$$; fi
	    if test -f ${bench_testname}.log; then mv -f ${bench_testname}.log ${bench_testname}.log.$$; fi
d598 4
a601 1
	    bench_frame_start_time="`date '+%H %M %S'`"
d603 3
a605 3
	    run $bench_testname $bench_geometry $bench_hypersample $bench_args 2> ${bench_testname}.log << EOF
$bench_view
start $bench_frame;
d610 2
a611 2
	    if test -f ${bench_testname}.pix.$bench_frame ; then mv -f ${bench_testname}.pix.$bench_frame ${bench_testname}.pix ; fi

d614 3
a616 3
	    bench_elapsed="`$ELP --seconds $bench_frame_start_time`"
	    if test "x$bench_elapsed" = "x" ; then
		bench_elapsed=1
d618 2
a619 2
	    if test $bench_elapsed -eq 0 ; then
		bench_elapsed=1
d621 1
a621 1
	    if test "x$bench_hypersample" = "x0" ; then
d625 1
a625 1
		    echo "DEBUG: ${bench_elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $bench_elapsed` pixels/s (inexact wallclock)"
d627 2
a628 2
		bench_hypersample=1
		bench_frame="`expr $bench_frame + 1`"
d631 1
a631 1
		    echo "DEBUG: ${bench_elapsed}s real elapsed,	`expr $bench_hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $bench_hypersample + 1 \) / $bench_elapsed \)` pixels/s (inexact wallclock)"
d637 1
a637 1
		if test `expr $bench_elapsed \* 32` -le ${TIMEFRAME} ; then
d639 3
a641 3
		    bench_hypersample="`expr $bench_hypersample \* 32 + 31`"
		    bench_frame="`expr $bench_frame + 5`"
		elif test `expr $bench_elapsed \* 16` -le ${TIMEFRAME} ; then
d643 3
a645 3
		    bench_hypersample="`expr $bench_hypersample \* 16 + 15`"
		    bench_frame="`expr $bench_frame + 4`"
		elif test `expr $bench_elapsed \* 8` -le ${TIMEFRAME} ; then
d647 3
a649 3
		    bench_hypersample="`expr $bench_hypersample \* 8 + 7`"
		    bench_frame="`expr $bench_frame + 3`"
		elif test `expr $bench_elapsed \* 4` -le ${TIMEFRAME} ; then
d651 2
a652 2
		    bench_hypersample="`expr $bench_hypersample \* 4 + 3`"
		    bench_frame="`expr $bench_frame + 2`"
d655 2
a656 2
		    bench_hypersample="`expr $bench_hypersample + $bench_hypersample + 1`"
		    bench_frame="`expr $bench_frame + 1`"
d661 8
a668 8
	    bench_rtfm_line="`grep RTFM ${bench_testname}.log`"
	    bench_rtfm="`echo $bench_rtfm_line | awk '{print int($9+0.5)}'`"
	    if test "x$bench_rtfm" = "x" ; then
		bench_rtfm="0"
	    fi
	    bench_rtfms="$bench_rtfm $bench_rtfms"
	    if test ! "x$bench_rtfm_line" = "x" ; then
		echo "$bench_rtfm_line"
d678 2
a679 2
	    bench_overall_elapsed="`$ELP --seconds $bench_start_time`"
	    if test $bench_overall_elapsed -ge $MAXTIME ; then
d684 2
a685 2
	if test "x$bench_rtfm" = "x" ; then
	    bench_rtfm="0"
d687 2
a688 2
	if test "x$bench_rtfms" = "x" ; then
	    bench_rtfms="0"
d692 4
a695 4
	bench_variance="`variance $AVERAGE $bench_rtfms`"
	bench_deviation="`sqrt $bench_variance`"
	if test $bench_rtfm -eq 0 ; then
	    bench_percent=0
d697 1
a697 1
	    bench_percent=`echo $bench_deviation $bench_rtfm | awk '{print int(($1 / $2 * 100)+0.5)}'`
d701 4
a704 4
	    bench_vals="`getvals $AVERAGE $bench_rtfms`"
	    bench_avg="`average $bench_vals`"
	    if test $bench_avg -eq 0 ; then
		bench_avgpercent=0
d706 1
a706 1
		bench_avgpercent=`echo $bench_deviation $bench_avg | awk '{print $1 / $2 * 100}'`
d708 1
a708 1
	    echo "DEBUG: average=$bench_avg ; variance=$bench_variance ; deviation=$bench_deviation ($bench_avgpercent%) ; last run was ${bench_percent}%"
d712 1
a712 1
	if test $bench_percent -le $DEVIATION ; then
d716 1
a716 1
	bench_overall_elapsed="`$ELP --seconds $bench_start_time`"
d719 1
a719 1
	bench_hypersample="`expr \( \( $bench_hypersample + 1 \) / 2 \) - 1`"
d724 2
a725 2
    if test -f gmon.out; then mv -f gmon.out gmon.${bench_testname}.out; fi
    ${CMP} ${PIX}/${bench_testname}.pix ${bench_testname}.pix
d727 1
a727 1
	echo ${bench_testname}.pix:  answers are RIGHT
d729 1
a729 1
	echo ${bench_testname}.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d731 1
a731 1

d733 1
a733 1
	echo "DEBUG: Done benchmark testing on $bench_testname"
d739 1
a739 1
# Run the actual tests
d745 1
a745 1
bench moss all.g $ARGS << EOF
d754 1
a754 1
bench world all.g $ARGS << EOF
d763 1
a763 1
bench star all $ARGS << EOF
d766 3
a768 3
viewrot -6.733560560e-01 6.130643360e-01 4.132114880e-01 0.000000000e+00
	5.539599410e-01 4.823888300e-02 8.311441420e-01 0.000000000e+00
	4.896120540e-01 7.885590550e-01 -3.720948210e-01 0.000000000e+00
d772 1
a772 1
bench bldg391 all.g $ARGS << EOF
d781 1
a781 1
bench m35 all.g $ARGS <<EOF
d784 3
a786 3
viewrot -5.527838919e-01 8.332423558e-01 1.171090926e-02 0.000000000e+00
	-4.815587087e-01 -3.308784486e-01 8.115544728e-01 0.000000000e+00
	6.800964482e-01 4.429747496e-01 5.841593895e-01 0.000000000e+00
d790 1
a790 1
bench sphflake scene.r $ARGS <<EOF
d802 1
a802 3
##############################
# compute and output results #
##############################
a811 5
case "x`echo 'tail' | tail -n 1 2>&1`" in
    *xtail*) TAIL_N="n " ;;
    *) TAIL_N="" ;;
esac

d836 1
a836 1
    tail -${TAIL_N}1 summary
d840 1
a840 1
    tail -${TAIL_N}2 summary
d842 1
a842 2

vgr="`tail -${TAIL_N}1 summary | awk '{print int($9+0.5)}'`"
d869 3
a871 18

encourage_submission=yes
options=""
if test -f "${path_to_this}/Makefile" ; then
    # See if this looks like an optimized build from a source distribution
    optimized=`grep O3 "${path_to_this}/Makefile" | wc | awk '{print $1}'`
    if test $optimized -eq 0 ; then
	echo "WARNING: This may not be an optimized compilation of BRL-CAD."
	echo "Performance results may not be optimal."
	echo
	options="$options --enable-optimized"
	encourage_submission=no
    fi
fi

if test -f moss.log ; then
    # See if this looks like a run-time disabled compilation
    runtime=`grep "debugging is disabled" moss.log | wc | awk '{print $1}'`
d875 4
a878 2
	echo "performance results and is useful for long render tasks, it is"
	echo "generally not utilized when comparing benchmark performance metrics."
d880 3
a882 8
	options="$options --enable-runtime-debug"
	encourage_submission=no
    fi

    # See if this looks like a compile-time debug compilation
    runtime=`grep "debugging is enabled" moss.log | wc | awk '{print $1}'`
    if test $runtime -gt 0 ; then
	echo "This appears to be a debug compilation of BRL-CAD."
a883 1
	options="$options --disable-debug"
d887 11
a897 11
if test "x$encourage_submission" = "xno" ; then
    echo "Official benchmark results are optimized builds with all run-time"
    echo "features enabled and optionally without compile-time debug symbols."
    echo
    if test -f "${path_to_this}/Makefile" ; then
	echo "For proper results, run 'make clean' and recompile with the"
	echo "following configure options added:"
    else
	echo "For proper results, you will need to install a version of the"
	echo "benchmark that has been compiled with the following configure"
	echo "options added:"
a898 2
    echo " $options"
    echo
d901 1
a901 10
# tell about the benchmark document
look_for file "" BENCHMARK_TR \
    ${path_to_this}/../share/brlcad/*.*.*/doc/benchmark.tr \
    ${path_to_this}/share/brlcad/*.*.*/doc/benchmark.tr \
    ${path_to_this}/share/brlcad/doc/benchmark.tr \
    ${path_to_this}/share/doc/benchmark.tr \
    ${path_to_this}/doc/benchmark.tr \
    ${path_to_this}/../doc/benchmark.tr \
    ./benchmark.tr

a902 16
if test "x$BENCHMARK_TR" = "x" ; then
    echo "The document should be available in the 'doc' directory of any source"
    echo "or complete binary distribution of BRL-CAD."
else
    echo "The document is available at $BENCHMARK_TR"
fi
echo

# if this was a valid benchmark run, encourage submission of results.
if test "x$encourage_submission" = "xyes" ; then
    echo "You are encouraged to submit your benchmark results and system"
    echo "configuration information to benchmark@@brlcad.org"
    echo
fi

echo "Benchmark testing complete."
@


14.24
log
@mention what files have been created/modified and explain what they are
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.23 2005/06/01 21:29:54 brlcad Exp $ (BRL)
d101 1
a101 1
path_to_run_sh=`dirname $0`
d118 9
a126 9
    if test -x "$path_to_run_sh/../src/rt/rt" ; then
	echo ...found $path_to_run_sh/../src/rt/rt
	RT="$path_to_run_sh/../src/rt/rt"
    elif test -x "$path_to_run_sh/rt" ; then
	echo ...found $path_to_run_sh/rt
	RT="$path_to_run_sh/rt"
    elif test -x "$path_to_run_sh/../bin/rt" ; then
	echo ...found $path_to_run_sh/../bin/rt
	RT="$path_to_run_sh/../bin/rt"
d136 9
a144 9
    if test -f "$path_to_run_sh/../db/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_run_sh/../db
	DB="$path_to_run_sh/../db"
    elif test -f "$path_to_run_sh/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_run_sh
	DB="$path_to_run_sh"
    elif test -f "$path_to_run_sh/../share/brlcad/db/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_run_sh/../share/brlcad/db
	DB="$path_to_run_sh/../share/brlcad/db"
d148 2
a149 2
    elif test -f "$path_to_run_sh/../db/sphflake.asc" ; then
	echo ...found ascii geometry files in $path_to_run_sh/../db
d154 4
a157 4
	    if test -x "$path_to_run_sh/../src/conv/asc2g" ; then
		echo ...found $path_to_run_sh/../src/conv/asc2g
		ASC2G="$path_to_run_sh/../src/conv/asc2g"
	    elif test -f "$path_to_run_sh/../src/conv/asc2g.c" ; then
d167 1
a167 1
		    $COMPILE -o asc2g "$path_to_run_sh/../src/conv/asc2g" -I"$path_to_run_sh/../include" -DHAVE_CONFIG_H -L/usr/brlcad/lib -L"$path_to_run_sh/../src/libwdb/.libs" -L"$path_to_run_sh/../src/librt/.libs" -L"$path_to_run_sh/../src/libbu/.libs" -L"$path_to_run_sh/../src/libbn/.libs" -L"$path_to_run_sh/../src/other/libtcl/.libs" -lwdb -lrt -lbu -lbn -ltcl
d188 1
a188 1
	    $ASC2G "$path_to_run_sh/../db/${geometry}.asc" ${geometry}.g
d209 9
a217 9
    if test -f "$path_to_run_sh/../pix/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_run_sh/../pix
	PIX="$path_to_run_sh/../pix"
    elif test -f "$path_to_run_sh/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_run_sh
	PIX="$path_to_run_sh"
    elif test -f "$path_to_run_sh/../share/brlcad/pix/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_run_sh/../share/brlcad/pix
	PIX="$path_to_run_sh/../share/brlcad/pix"
d227 3
a229 3
    if test -x $path_to_run_sh/pixcmp ; then
	echo ...found $path_to_run_sh/pixcmp
	CMP="$path_to_run_sh/pixcmp"
d231 1
a231 1
	if test -f "$path_to_run_sh/pixcmp.c" ; then
d241 1
a241 1
		$COMPILE -o pixcmp "$path_to_run_sh/pixcmp.c"
d264 9
a272 9
    if test -x $path_to_run_sh/../sh/elapsed.sh ; then
	echo ...found $path_to_run_sh/../sh/elapsed.sh
	ELP="$path_to_run_sh/../sh/elapsed.sh"
    elif test -x $path_to_run_sh/elapsed.sh ; then
	echo ...found $path_to_run_sh/elapsed.sh
	ELP="$path_to_run_sh/elapsed.sh"
    elif test -x $path_to_run_sh/../bin/elapsed.sh ; then
	echo ...found $path_to_run_sh/../bin/elapsed.sh
	ELP="$path_to_run_sh/../bin/elapsed.sh"
d812 4
a815 4
if test -f "$path_to_run_sh/perf.sh" ; then
    PERF="$path_to_run_sh/perf.sh"
elif test -f "$path_to_run_sh/../bench/perf.sh" ; then
    PERF="$path_to_run_sh/../bench/perf.sh"
d888 2
a889 2
if test -f "$path_to_run_sh/Makefile" ; then
    optimized=`grep O3 "$path_to_run_sh/Makefile" | wc | awk '{print $1}'`
@


14.24.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.25 2005/07/16 21:39:36 brlcad Exp $ (BRL)
d101 1
a101 1
path_to_this=`dirname $0`
d118 9
a126 9
    if test -x "$path_to_this/../src/rt/rt" ; then
	echo ...found $path_to_this/../src/rt/rt
	RT="$path_to_this/../src/rt/rt"
    elif test -x "$path_to_this/rt" ; then
	echo ...found $path_to_this/rt
	RT="$path_to_this/rt"
    elif test -x "$path_to_this/../bin/rt" ; then
	echo ...found $path_to_this/../bin/rt
	RT="$path_to_this/../bin/rt"
d136 9
a144 9
    if test -f "$path_to_this/../db/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_this/../db
	DB="$path_to_this/../db"
    elif test -f "$path_to_this/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_this
	DB="$path_to_this"
    elif test -f "$path_to_this/../share/brlcad/db/sphflake.g" ; then
	echo ...found .g geometry files in $path_to_this/../share/brlcad/db
	DB="$path_to_this/../share/brlcad/db"
d148 2
a149 2
    elif test -f "$path_to_this/../db/sphflake.asc" ; then
	echo ...found ascii geometry files in $path_to_this/../db
d154 4
a157 4
	    if test -x "$path_to_this/../src/conv/asc2g" ; then
		echo ...found $path_to_this/../src/conv/asc2g
		ASC2G="$path_to_this/../src/conv/asc2g"
	    elif test -f "$path_to_this/../src/conv/asc2g.c" ; then
d167 1
a167 1
		    $COMPILE -o asc2g "$path_to_this/../src/conv/asc2g" -I"$path_to_this/../include" -DHAVE_CONFIG_H -L/usr/brlcad/lib -L"$path_to_this/../src/libwdb/.libs" -L"$path_to_this/../src/librt/.libs" -L"$path_to_this/../src/libbu/.libs" -L"$path_to_this/../src/libbn/.libs" -L"$path_to_this/../src/other/libtcl/.libs" -lwdb -lrt -lbu -lbn -ltcl
d188 1
a188 1
	    $ASC2G "$path_to_this/../db/${geometry}.asc" ${geometry}.g
d209 9
a217 9
    if test -f "$path_to_this/../pix/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_this/../pix
	PIX="$path_to_this/../pix"
    elif test -f "$path_to_this/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_this
	PIX="$path_to_this"
    elif test -f "$path_to_this/../share/brlcad/pix/sphflake.pix" ; then
	echo ...found .pix image files in $path_to_this/../share/brlcad/pix
	PIX="$path_to_this/../share/brlcad/pix"
d227 3
a229 3
    if test -x $path_to_this/pixcmp ; then
	echo ...found $path_to_this/pixcmp
	CMP="$path_to_this/pixcmp"
d231 1
a231 1
	if test -f "$path_to_this/pixcmp.c" ; then
d241 1
a241 1
		$COMPILE -o pixcmp "$path_to_this/pixcmp.c"
d264 9
a272 9
    if test -x $path_to_this/../sh/elapsed.sh ; then
	echo ...found $path_to_this/../sh/elapsed.sh
	ELP="$path_to_this/../sh/elapsed.sh"
    elif test -x $path_to_this/elapsed.sh ; then
	echo ...found $path_to_this/elapsed.sh
	ELP="$path_to_this/elapsed.sh"
    elif test -x $path_to_this/../bin/elapsed.sh ; then
	echo ...found $path_to_this/../bin/elapsed.sh
	ELP="$path_to_this/../bin/elapsed.sh"
d812 4
a815 4
if test -f "$path_to_this/perf.sh" ; then
    PERF="$path_to_this/perf.sh"
elif test -f "$path_to_this/../bench/perf.sh" ; then
    PERF="$path_to_this/../bench/perf.sh"
d888 2
a889 2
if test -f "$path_to_this/Makefile" ; then
    optimized=`grep O3 "$path_to_this/Makefile" | wc | awk '{print $1}'`
@


14.23
log
@don't presume that the benchmark.tr document is available/installed or that this is a source distribution
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.22 2005/06/01 19:58:56 brlcad Exp $ (BRL)
d825 11
a835 2
ret=$?
if test $ret != 0 ; then
d837 1
a837 1
    exit $ret
a839 1
    echo "Summary Details:"
@


14.22
log
@modify the benchmark to not assume it's in a source tree allowing it to work when installed.  added PIX and ELP environment options for setting the location of the pixmap directory and the time elapsed script.
@
text
@d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.21 2005/05/28 17:02:16 brlcad Exp $ (BRL)
d894 1
a894 1
echo "Read $path_to_run_sh/../doc/benchmark.tr for more details on the BRL-CAD Benchmark."
@


14.21
log
@fix capture of output when rt crashes so that it includes the shell error message in the log too
@
text
@d55 4
a58 2
#   DB - the directory to the database geometry (e.g. ../db)
#   CMP - the path to a pixcmp tool (e.g. ./pixcmp)
d79 3
a81 2
# Plese send your BRL-CAD Benchmark results to the developers along with
# detailed system information to <devs@@brlcad.org>.  Include at least:
d85 1
a85 1
#   2) CPU configuration(s) (e.g. cat /proc/cpuinfo or hinv or sysctl -a)
d96 1
a96 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.20 2005/05/28 02:09:53 brlcad Exp $ (BRL)
d118 1
a118 1
    if test -x "$path_to_run_sh/../src/rt" ; then
d121 6
d133 2
a134 2
# find geometry database directory if we do not already know where it is
# DB environment variable overrides
d139 6
d205 18
d260 18
d291 6
d303 6
d353 1
a353 1
echo "Minimum run time is `$path_to_run_sh/../sh/elapsed.sh $mintime`"
d355 1
a355 1
echo "Maximum run time is `$path_to_run_sh/../sh/elapsed.sh $maxtime`"
d360 1
a360 1
echo "Estimated   time is `$path_to_run_sh/../sh/elapsed.sh $estimate`"
d614 4
a617 1
	    benchmark_elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $benchmark_frame_start_time`"
d678 1
a678 1
	    benchmark_overall_elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $benchmark_start_time`"
d716 1
a716 1
	benchmark_overall_elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $benchmark_start_time`"
d725 1
a725 1
    ${CMP} $path_to_run_sh/../pix/${benchmark_testname}.pix ${benchmark_testname}.pix
d799 1
a799 1
echo "Total testing time elapsed: `$path_to_run_sh/../sh/elapsed.sh $start`"
d812 13
a824 1
sh $path_to_run_sh/../bench/perf.sh "$HOST" "`date`" "$*" >> summary
@


14.20
log
@don't really need to recommend that debug be disabled
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.19 2005/05/18 05:02:56 brlcad Exp $ (BRL)
d329 1
a329 2
	${DB}/${run_geomname}.g ${run_geometry} \
	2> ${run_geomname}.log <<EOF
d540 1
a540 1
	    run $benchmark_testname $benchmark_geometry $benchmark_hypersample $benchmark_args << EOF
d546 1
a548 5
	    if test $retval != 0 ; then
		echo "RAYTRACE ERROR"
		break
	    fi
	
d605 6
d618 7
d692 3
a694 4
	-3.461886346e-01 -2.424038798e-01 9.063078165e-01 
0.000000000e+00 7.424039245e-01 5.198368430e-01 4.226182699e-01 
0.000000000e+00 0.000000000e+00 0.000000000e+00 0.000000000e+00 
1.000000000e+00 ;
@


14.19
log
@try a lot harder to allow running the benchmark before brl-cad is even compiled (we just need an rt from somewhere).  compile pixcmp and asc2g if we have to, and try to generate the .g databases if they don't exist.
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.18 2005/05/17 22:47:19 brlcad Exp $ (BRL)
d789 1
a789 1
	echo "    --enable-runtime-debug  --enable-optimized  --disable-debug"
d803 1
a803 1
	echo "    --enable-optimized  --disable-debug"
@


14.18
log
@improve the summary output, emphasize the actual results
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.17 2005/05/17 06:24:23 brlcad Exp $ (BRL)
d123 1
a123 1
echo Looking for geometry database directory...
d128 1
a128 1
	echo ...found $path_to_run_sh/../db
d130 55
d202 5
a206 1
		CC=$compiler
d208 1
a208 1
		$CC "$path_to_run_sh/pixcmp.c" >& /dev/null
d212 1
a212 1
		if test -f "$path_to_run_sh/pixcmp" ; then
d217 3
a219 3
	    if test -f "$path_to_run_sh/pixcmp" ; then
		echo ...built pixcmp with $CC
		CMP="$path_to_run_sh/pixcmp"
@


14.17
log
@See if this looks like a run-time disabled build
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.16 2005/05/17 05:48:14 brlcad Exp $ (BRL)
d693 1
d698 1
d727 5
a731 1
	echo "(configure with --enable-runtime-debug and --enable-optimized)"
d740 5
a744 1
	echo "Performance results may not be optimal. (configure with --enable-optimized)"
@


14.16
log
@er, optimized is > 0
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.15 2005/05/17 04:08:46 brlcad Exp $ (BRL)
a703 10
    # See if this looks like an optimized build
    if test -f "$path_to_run_sh/Makefile" ; then
	optimized=`grep O3 "$path_to_run_sh/Makefile" | wc | awk '{print $1}'`
	if test $optimized -eq 0 ; then
	    echo "WARNING: This may not be an optimized compilation of BRL-CAD."
	    echo "Performance results may not be optimal. (configure with --enable-optimized)"
	    echo
	fi
    fi

d715 24
@


14.15
log
@stick to portable awk (solaris threw a tantrum).  makes it more consistent and less quote-tricky too.
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.14 2005/05/17 03:26:34 brlcad Exp $ (BRL)
d707 1
a707 1
	if test $optimized -gt 0 ; then
@


14.14
log
@make sure the rtfms being computed and tested on the fly are indeed integer.  output a more informative summary including an explanation of the results and approximated past VGR results for comparison.  if this doesn't look like an optimized build, say something too.
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.13 2005/05/16 23:38:42 brlcad Exp $ (BRL)
d339 1
a339 1
	getvals_int=`awk "BEGIN {print int($getvals_num+0.5)}"`
d427 1
a427 1
	    sqrt_root=`awk "BEGIN {print sqrt($sqrt_number)}"`
d431 1
a431 1
    echo `awk "BEGIN {print int($sqrt_root+0.5)}"`
d564 1
a564 1
	    benchmark_percent=`awk "BEGIN {print int(($benchmark_deviation / $benchmark_rtfm * 100)+0.5)}"`
d573 1
a573 1
		benchmark_avgpercent=`awk "BEGIN {print $benchmark_deviation / $benchmark_avg * 100}"`
d694 2
a695 2
    ln=`awk "BEGIN {printf \"%.2f\", log($vgr)}"`
    log=`awk "BEGIN {printf \"%.2f\", log($vgr) / log(10)}"`
@


14.13
log
@more error checking to prevent bad behavior if a bad RT is provided, also fix timing when an rtfm isn't found, and finally, report the version information of RT before we start and VGR average when we're done
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.12 2005/05/16 19:05:10 brlcad Exp $ (BRL)
a497 1
	    echo "elapsed is $benchmark_elapsed"
d542 1
a542 1
	    benchmark_rtfm="`echo $benchmark_rtfm_line | awk '{print $9}'`"
d690 1
a690 1
vgr="`tail -1 summary | awk '{print int($9)}'`"
d693 29
a721 1
    echo "Benchmark computations indicate an approximate VGR performance metric of $vgr"
d725 2
a726 1
echo Testing complete, read $path_to_run_sh/../doc/benchmark.tr for more details on the BRL-CAD Benchmark.
@


14.12
log
@document the new MAXTIME, DEVIATION, and AVERAGE options that lets users set a maximum amount of ttime per test, set a minimum deviation percentage to consider the results stable, and an average number of prior raytraces to use for the deviation population.
@
text
@d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.11 2005/05/16 16:09:40 brlcad Exp $ (BRL)
d198 1
a198 1
if test $MAXTIME -le $TIMEFRAME ; then
d215 13
d290 1
a290 1
	echo "ERROR: no numbers provided to average"
d302 1
a302 1
	echo "ERROR: unexpected count in average"
d360 1
a360 1
	echo "ERROR: cannot compute variance of zero numbers"
d365 1
a365 1
	echo "ERROR: no numbers provided to compute variance for"
d374 1
a374 1
	echo "ERROR: unexpected zero count in variance"
d401 1
a401 1
	echo "ERROR: cannot compute the square root of nothing"
d404 1
a404 1
	echo "ERROR: square root of negative numbers is only in your imagination"
a464 1
    benchmark_overall_elapsed=0
d469 2
d480 1
a480 1
	    benchmark_start_time="`date '+%H %M %S'`"
d497 2
a498 1
	    benchmark_elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $benchmark_start_time`"
d544 3
d548 9
a556 1
	    echo "$benchmark_rtfm_line"
d559 1
a559 1
	# outer loop for variance/deviation testing of last AVERAGE runs
d562 5
a566 1
	benchmark_percent=`awk "BEGIN {print int(($benchmark_deviation / $benchmark_rtfm * 100)+0.5)}"`
d571 5
a575 1
	    benchmark_avgpercent=`awk "BEGIN {print $benchmark_deviation / $benchmark_avg * 100}"`
d584 1
a584 1
	benchmark_overall_elapsed="`expr $benchmark_overall_elapsed + $benchmark_elapsed`"
d688 1
a688 1
    echo "Summary:"
d691 7
a697 1
echo
@


14.11
log
@add variance/deviation checks to the benchmarks so that after we reach a minimum timeframe per run, it may continue rendereing extra frames until the numbers on the performance results of the last run are within some deviation percentage of the average previous N frames.  initial testing shows that this results in a MUCH more stable/repeatable rtfm than before.
@
text
@d58 3
d63 13
a75 6
# The TIMEFRAME option was added after several years to ensure that
# each individual benchmark run will consume at least a minimum amount
# of wallclock time to be considered useful/stable.  When a test is
# run and it completes in less than TIMEFRAME, the raytrace is
# restarted using double the number of rays from the previous run.
# These additional rays are hypersampled but without any jitter.
d93 1
a93 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.10 2005/05/16 01:36:30 brlcad Exp $ (BRL)
@


14.10
log
@output time estimates and a time summary before and after the tests are run
@
text
@d83 1
a83 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.9 2005/05/16 00:07:12 brlcad Exp $ (BRL)
d184 10
d196 1
a196 1
    DEVIATION=10
d200 3
a202 3
# approximate maximum time in seconds that a given test is allowed to take
if test "x${MAXTIME}" = "x" ; then
    MAXTIME=300
d204 1
a204 1
echo "Using [$MAXTIME] for MAXTIME"
d224 1
d258 156
d442 1
a442 1
    benchmark_elapsed=0
d445 2
a446 1
    while test $benchmark_elapsed -lt $TIMEFRAME ; do
d448 1
a448 2
	if test -f ${benchmark_testname}.pix; then mv -f ${benchmark_testname}.pix ${benchmark_testname}.pix.$$; fi
	if test -f ${benchmark_testname}.log; then mv -f ${benchmark_testname}.log ${benchmark_testname}.log.$$; fi
d450 2
a451 1
	benchmark_start_time="`date '+%H %M %S'`"
d453 6
a458 1
	run $benchmark_testname $benchmark_geometry $benchmark_hypersample $benchmark_args << EOF
d463 2
a464 2
	retval=$?
	if test -f ${benchmark_testname}.pix.$benchmark_frame ; then mv -f ${benchmark_testname}.pix.$benchmark_frame ${benchmark_testname}.pix ; fi
d466 4
a469 4
	if test $retval != 0 ; then
	    echo "RAYTRACE ERROR"
	    break
	fi
d471 5
a475 17
	# compute how long we took, rounding up to at least one second
	# to prevent division by zero
	benchmark_elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $benchmark_start_time`"
	if test $benchmark_elapsed -eq 0 ; then
	    benchmark_elapsed=1
	fi
	if test "x$benchmark_hypersample" = "x0" ; then

	    # just finished the first frame
	    if test "x$DEBUG" != "x" ; then
		echo "DEBUG: ${benchmark_elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $benchmark_elapsed` pixels/s (inexact wallclock)"
	    fi
	    benchmark_hypersample=1
	    benchmark_frame="`expr $benchmark_frame + 1`"
	else
	    if test "x$DEBUG" != "x" ; then
		echo "DEBUG: ${benchmark_elapsed}s real elapsed,	`expr $benchmark_hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $benchmark_hypersample + 1 \) / $benchmark_elapsed \)` pixels/s (inexact wallclock)"
d477 1
d479 6
a484 18
	    # increase the number of rays exponentially if we are
	    # considerably faster than the TIMEFRAME required
	    if test `expr $benchmark_elapsed \* 32` -le ${TIMEFRAME} ; then
		# 32x increase, skip four frames
		benchmark_hypersample="`expr $benchmark_hypersample \* 32 + 31`"
		benchmark_frame="`expr $benchmark_frame + 5`"
	    elif test `expr $benchmark_elapsed \* 16` -le ${TIMEFRAME} ; then
		# 16x increase, skip three frames
		benchmark_hypersample="`expr $benchmark_hypersample \* 16 + 15`"
		benchmark_frame="`expr $benchmark_frame + 4`"
	    elif test `expr $benchmark_elapsed \* 8` -le ${TIMEFRAME} ; then
		# 8x increase, skip two frames
		benchmark_hypersample="`expr $benchmark_hypersample \* 8 + 7`"
		benchmark_frame="`expr $benchmark_frame + 3`"
	    elif test `expr $benchmark_elapsed \* 4` -le ${TIMEFRAME} ; then
		# 4x increase, skip a frame
		benchmark_hypersample="`expr $benchmark_hypersample \* 4 + 3`"
		benchmark_frame="`expr $benchmark_frame + 2`"
d486 28
a513 3
		# 2x increase
		benchmark_hypersample="`expr $benchmark_hypersample + $benchmark_hypersample + 1`"
		benchmark_frame="`expr $benchmark_frame + 1`"
d515 23
d539 5
a543 1
	grep RTFM ${benchmark_testname}.log
d546 2
d555 1
a555 1

d624 1
a624 1
echo "Total time spent testing: `$path_to_run_sh/../sh/elapsed.sh $start`"
@


14.9
log
@increase the number of rays exponentially if we are considerably faster that the minimum TIMEFRAME required, add the beginnings of deviation and max timeframe checks.
@
text
@d83 1
a83 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.8 2005/05/15 04:27:20 brlcad Exp $ (BRL)
d194 12
d361 4
d417 5
@


14.8
log
@oh yeah, added DEBUG flag on that last change too that will output extra run-time information for testing/debugging/development
@
text
@d83 1
a83 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.7 2005/05/15 04:25:01 brlcad Exp $ (BRL)
d178 1
a178 1
# determine the minimum time requirement for a single test run
d180 1
a180 1
    TIMEFRAME=60
d184 11
d286 2
a287 1
	# compute how long we took, rounding up to at least one second to prevent division by zero
d293 2
d299 1
d304 24
a327 1
	    benchmark_hypersample="`expr $benchmark_hypersample + $benchmark_hypersample + 1`"
a328 1
	benchmark_frame="`expr $benchmark_frame + 1`"
@


14.7
log
@refactor the benchmarks into a functional form to ensure consistency across all the tests as the testing becomes more complicated (e.g. for adding variance/deviation checks and superscaling).  this should be posix shell compliant, hopefully most all platform /bin/sh these days are minimally compliant too.  function form happens to shave a couple hundred lines off the file too.. ;)
@
text
@d58 1
d83 1
a83 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.6 2005/04/23 16:54:49 brlcad Exp $ (BRL)
@


14.6
log
@orignal gangstas use consistent style
@
text
@d82 1
a82 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.5 2005/04/22 20:17:39 brlcad Exp $ (BRL)
d96 3
d183 5
d190 59
a248 1
# Run the tests
d250 14
a263 23
echo +++++ moss
elapsed=0
hypersample=0
frame=0
while test $elapsed -lt $TIMEFRAME ; do

if test -f moss.pix; then mv -f moss.pix moss.pix.$$; fi
if test -f moss.log; then mv -f moss.log moss.log.$$; fi

START_TIME="`date '+%H %M %S'`"
$RT -B -M -s512 -H${hypersample} -J0 $* \
  -o moss.pix \
  $DB/moss.g all.g \
  2> moss.log \
  << EOF
viewsize 1.572026215e+02;
eye_pt 6.379990387e+01 3.271768951e+01 3.366661453e+01;
viewrot -5.735764503e-01 8.191520572e-01 0.000000000e+00 
0.000000000e+00 -3.461886346e-01 -2.424038798e-01 9.063078165e-01 
0.000000000e+00 7.424039245e-01 5.198368430e-01 4.226182699e-01 
0.000000000e+00 0.000000000e+00 0.000000000e+00 0.000000000e+00 
1.000000000e+00 ;
start $frame;
d266 41
a306 2
ret=$?
if test -f moss.pix.$frame ; then mv -f moss.pix.$frame moss.pix ; fi
a307 4
if test $ret != 0 ; then
    echo "RAYTRACE ERROR"
    break
fi
d309 1
a309 19
elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $START_TIME`"
if test "x$hypersample" = "x0" ; then
#    echo "${elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $elapsed` primary rays/s (inexact wallclock)"
    hypersample=1
else
#    echo "${elapsed}s real elapsed,	`expr $hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $hypersample + 1 \) / $elapsed \)` primary rays/s (inexact wallclock)"
    hypersample="`expr $hypersample + $hypersample + 1`"
fi
frame="`expr $frame + 1`"
grep RTFM moss.log
done

if test -f gmon.out; then mv -f gmon.out gmon.moss.out; fi
${CMP} $path_to_run_sh/../pix/moss.pix moss.pix
if test $? = 0 ; then
    echo moss.pix:  answers are RIGHT
else
    echo moss.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
fi
d311 8
d320 1
a320 15
echo +++++ world
elapsed=0
hypersample=0
frame=0
while test $elapsed -lt $TIMEFRAME ; do

if test -f world.pix; then mv -f world.pix world.pix.$$; fi
if test -f world.log; then mv -f world.log world.log.$$; fi

START_TIME="`date '+%H %M %S'`"
$RT -B -M -s512 -H${hypersample} -J0 $* \
  -o world.pix \
  $DB/world.g all.g \
  2> world.log \
  << EOF
d323 2
a324 2
viewrot -5.735764503e-01 8.191520572e-01 0.000000000e+00
0.000000000e+00 -3.461886346e-01 -2.424038798e-01 9.063078165e-01 
a327 2
start $frame;
end;
a328 28
ret=$?
if test -f world.pix.$frame ; then mv -f world.pix.$frame world.pix ; fi

if test $ret != 0 ; then
    echo "RAYTRACE ERROR"
    break
fi

elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $START_TIME`"
if test "x$hypersample" = "x0" ; then
#    echo "${elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $elapsed` primary rays/s (inexact wallclock)"
    hypersample=1
else
#    echo "${elapsed}s real elapsed,	`expr $hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $hypersample + 1 \) / $elapsed \)` primary rays/s (inexact wallclock)"
    hypersample="`expr $hypersample + $hypersample + 1`"
fi
frame="`expr $frame + 1`"
grep RTFM world.log
done

if test -f gmon.out; then mv -f gmon.out gmon.world.out; fi
${CMP} $path_to_run_sh/../pix/world.pix world.pix
if test $? = 0 ; then
    echo world.pix:  answers are RIGHT
else
    echo world.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
fi

d330 1
a330 15
echo +++++ star
elapsed=0
hypersample=0
frame=0
while test $elapsed -lt $TIMEFRAME ; do

if test -f star.pix; then mv -f star.pix star.pix.$$; fi
if test -f star.log; then mv -f star.log star.log.$$; fi

START_TIME="`date '+%H %M %S'`"
$RT -B -M -s512 -H${hypersample} -J0 $* \
  -o star.pix \
  $DB/star.g all \
  2> star.log \
  <<EOF
d334 3
a336 5
5.539599410e-01 4.823888300e-02 8.311441420e-01 0.000000000e+00 
4.896120540e-01 7.885590550e-01 -3.720948210e-01 0.000000000e+00 
0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00 ;
start $frame;
end;
a337 28
ret=$?
if test -f star.pix.$frame ; then mv -f star.pix.$frame star.pix ; fi

if test $ret != 0 ; then
    echo "RAYTRACE ERROR"
    break
fi

elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $START_TIME`"
if test "x$hypersample" = "x0" ; then
#    echo "${elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $elapsed` primary rays/s (inexact wallclock)"
    hypersample=1
else
#    echo "${elapsed}s real elapsed,	`expr $hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $hypersample + 1 \) / $elapsed \)` primary rays/s (inexact wallclock)"
    hypersample="`expr $hypersample + $hypersample + 1`"
fi
frame="`expr $frame + 1`"
grep RTFM star.log
done

if test -f gmon.out; then mv -f gmon.out gmon.star.out; fi
${CMP} $path_to_run_sh/../pix/star.pix star.pix
if test $? = 0 ; then
    echo star.pix:  answers are RIGHT
else
    echo star.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
fi

d339 1
a339 15
echo +++++ bldg391
elapsed=0
hypersample=0
frame=0
while test $elapsed -lt $TIMEFRAME ; do

if test -f bldg391.pix; then mv -f bldg391.pix bldg391.pix.$$; fi
if test -f bldg391.log; then mv -f bldg391.log bldg391.log.$$; fi

START_TIME="`date '+%H %M %S'`"
$RT -B -M -s512 -H${hypersample} -J0 $* \
  -o bldg391.pix \
  $DB/bldg391.g all.g \
  2> bldg391.log \
  <<EOF
d342 4
a345 7
viewrot -5.735764503e-01 8.191520572e-01 0.000000000e+00 
0.000000000e+00 -3.461886346e-01 -2.424038798e-01 9.063078165e-01 
0.000000000e+00 7.424039245e-01 5.198368430e-01 4.226182699e-01 
0.000000000e+00 0.000000000e+00 0.000000000e+00 0.000000000e+00 
1.000000000e+00 ;
start $frame;
end;
a346 27
ret=$?
if test -f bldg391.pix.$frame ; then mv -f bldg391.pix.$frame bldg391.pix ; fi

if test $ret != 0 ; then
    echo "RAYTRACE ERROR"
    break
fi

elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $START_TIME`"
if test "x$hypersample" = "x0" ; then
#    echo "${elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $elapsed` primary rays/s (inexact wallclock)"
    hypersample=1
else
#    echo "${elapsed}s real elapsed,	`expr $hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $hypersample + 1 \) / $elapsed \)` primary rays/s (inexact wallclock)"
    hypersample="`expr $hypersample + $hypersample + 1`"
fi
frame="`expr $frame + 1`"
grep RTFM bldg391.log
done

if test -f gmon.out; then mv -f gmon.out gmon.bldg391.out; fi
${CMP} $path_to_run_sh/../pix/bldg391.pix bldg391.pix
if test $? = 0 ; then
    echo bldg391.pix:  answers are RIGHT
else
    echo bldg391.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
fi
d348 1
a348 16

echo +++++ m35
elapsed=0
hypersample=0
frame=0
while test $elapsed -lt $TIMEFRAME ; do

if test -f m35.pix; then mv -f m35.pix m35.pix.$$; fi
if test -f m35.log; then mv -f m35.log m35.log.$$; fi

START_TIME="`date '+%H %M %S'`"
$RT -B -M -s512 -H${hypersample} -J0 $* \
  -o m35.pix \
  $DB/m35.g all.g \
  2> m35.log \
  << EOF
d352 3
a354 5
-4.815587087e-01 -3.308784486e-01 8.115544728e-01 0.000000000e+00 
6.800964482e-01 4.429747496e-01 5.841593895e-01 0.000000000e+00 
0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00 ;
start $frame;
end;
a355 28
ret=$?
if test -f m35.pix.$frame ; then mv -f m35.pix.$frame m35.pix ; fi

if test $ret != 0 ; then
    echo "RAYTRACE ERROR"
    break
fi

elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $START_TIME`"
if test "x$hypersample" = "x0" ; then
#    echo "${elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $elapsed` primary rays/s (inexact wallclock)"
    hypersample=1
else
#    echo "${elapsed}s real elapsed,	`expr $hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $hypersample + 1 \) / $elapsed \)` primary rays/s (inexact wallclock)"
    hypersample="`expr $hypersample + $hypersample + 1`"
fi
frame="`expr $frame + 1`"
grep RTFM m35.log
done

if test -f gmon.out; then mv -f gmon.out gmon.m35.out; fi
${CMP} $path_to_run_sh/../pix/m35.pix m35.pix
if test $? = 0 ; then
    echo m35.pix:  answers are RIGHT
else
    echo m35.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
fi

d357 1
a357 16
echo +++++ sphflake
elapsed=0
hypersample=0
frame=0
while test $elapsed -lt $TIMEFRAME ; do

if test -f sphflake.pix; then mv -f sphflake.pix sphflake.pix.$$; fi
if test -f sphflake.log; then mv -f sphflake.log sphflake.log.$$; fi

START_TIME="`date '+%H %M %S'`"
$RT -B -M -s512 -H${hypersample} -J0 $* \
  -o sphflake.pix \
  $DB/sphflake.g \
  "scene.r" \
  2> sphflake.log \
  << EOF
a360 2
start $frame;
end;
a361 19
ret=$?
if test -f sphflake.pix.$frame ; then mv -f sphflake.pix.$frame sphflake.pix ; fi

if test $ret != 0 ; then
    echo "RAYTRACE ERROR"
    break
fi

elapsed="`$path_to_run_sh/../sh/elapsed.sh --seconds $START_TIME`"
if test "x$hypersample" = "x0" ; then
#    echo "${elapsed}s real elapsed,	1 ray/pixel,	`expr 262144 / $elapsed` primary rays/s (inexact wallclock)"
    hypersample=1
else
#    echo "${elapsed}s real elapsed,	`expr $hypersample + 1` rays/pixel,	`expr \( 262144 \* \( $hypersample + 1 \) / $elapsed \)` primary rays/s (inexact wallclock)"
    hypersample="`expr $hypersample + $hypersample + 1`"
fi
frame="`expr $frame + 1`"
grep RTFM sphflake.log
done
d364 1
a364 7
if test -f gmon.out; then mv -f gmon.out gmon.sphflake.out; fi
${CMP} $path_to_run_sh/../pix/sphflake.pix sphflake.pix
if test $? = 0 ; then
    echo sphflake.pix:  answers are RIGHT
else
    echo sphflake.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
fi
d366 6
a371 4
if test x$UNIXTYPE = xBSD ; then
    HOST=`hostname`
else
    HOST=`uname -n`
@


14.5
log
@major reworking of the benchmark to iteratively double the number of rays being fired until the individual test requires takes at least a minimum predetermined amount of wallclock time (currently set to 60 seconds per test).  the number of rays is doubled via hypersampling 1+N hypersample rays with jitter disabled.  the amount of time may be specified via the TIMEFRAME environment variable.  having the longer run time will help the rtfm numbers stabilize better and lets the benchmark scale better to faster machines.  an interesting addition for the future might be to compute the mean error deviation between frames and use that as well to get a stable rtfm metric.
@
text
@d78 1
a78 1
# Original Authors:
d82 1
a82 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.4 2005/02/21 18:04:09 brlcad Exp $ (BRL)
@


14.4
log
@force locale setting to C so things like date output as expected
@
text
@d37 46
a82 2
# A Shell script to run the BRL-CAD Benchmark Test
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.3 2005/01/30 20:30:08 brlcad Exp $ (BRL)
a83 4
# set RT, DB, and/or CMP environment variables to override default locations

echo "B R L - C A D   B E N C H M A R K"
echo "================================="
d89 4
d100 5
a104 6
  # see if we find the rt binary
  if test -x "$path_to_run_sh/../src/rt" ; then
    echo ...found $path_to_run_sh/../src/rt/rt
    RT="$path_to_run_sh/../src/rt/rt"
    LD_LIBRARY_PATH="$path_to_run_sh/../src/rt:$LD_LIBRARY_PATH"
  fi
d106 1
a106 1
  echo ...using $RT from RT environment variable setting
d113 4
a116 4
  if test -f "$path_to_run_sh/../db/sphflake.g" ; then
    echo ...found $path_to_run_sh/../db
    DB="$path_to_run_sh/../db"
  fi
d118 1
a118 1
  echo ...using $DB from DB environment variable setting
d125 23
a147 13
  if test -x $path_to_run_sh/pixcmp ; then
    echo ...found $path_to_run_sh/pixcmp
    CMP="$path_to_run_sh/pixcmp"
  else
    if test -f "$path_to_run_sh/pixcmp.c" ; then
      echo ...need to build pixcmp

      for compiler in $CC gcc cc ; do
	CC=$compiler

	$CC "$path_to_run_sh/pixcmp.c" >& /dev/null
	if test "x$?" = "x0" ; then
	  break
a148 9
	if test -f "$path_to_run_sh/pixcmp" ; then
	  break;
	fi
      done
      
      if test -f "$path_to_run_sh/pixcmp" ; then
        echo ...built pixcmp with $CC
        CMP="$path_to_run_sh/pixcmp"
      fi
a149 1
  fi
d151 1
a151 1
  echo ...using $CMP from CMP environment variable setting
d156 2
a157 2
  echo "ERROR:  Could not find the BRL-CAD raytracer"
  exit 1
d159 1
a159 1
  echo "Using [$RT] for RT"
d162 2
a163 2
  echo "ERROR:  Could not find the BRL-CAD database directory"
  exit 1
d165 1
a165 1
  echo "Using [$DB] for DB"
d168 2
a169 2
  echo "ERROR:  Could not find the BRL-CAD pixel comparison utility"
  exit 1
d171 6
a176 1
  echo "Using [$CMP] for CMP"
d178 1
a178 1
export LD_LIBRARY_PATH
d185 5
d192 3
a194 1
time $RT -B -M -s512 $* \
d206 1
a206 1
start 0;
d209 20
d232 1
a232 1
  echo moss.pix:  answers are RIGHT
d234 1
a234 1
  echo moss.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d237 1
d239 5
d246 3
a248 1
time $RT -B -M -s512 $* \
d260 1
a260 1
start 0;
d263 20
d286 1
a286 1
  echo world.pix:  answers are RIGHT
d288 1
a288 1
  echo world.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d291 1
d293 5
d300 3
a302 1
time $RT -B -M -s512 $* \
d313 1
a313 1
start 0;
d316 20
d339 1
a339 1
  echo star.pix:  answers are RIGHT
d341 1
a341 1
  echo star.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d344 1
d346 5
d353 3
a355 1
time $RT -B -M -s512 $* \
d367 1
a367 1
start 0;
d370 20
d393 1
a393 1
  echo bldg391.pix:  answers are RIGHT
d395 1
a395 1
  echo bldg391.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d398 1
d400 5
d407 3
a409 1
time $RT -B -M -s512 $* \
d420 1
a420 1
start 0;
d423 20
d446 1
a446 1
  echo m35.pix:  answers are RIGHT
d448 1
a448 1
  echo m35.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d451 1
d453 5
d460 3
a462 1
time $RT -B -M -s512 $* \
d471 1
a471 1
start 0;
d474 21
d498 1
a498 1
  echo sphflake.pix:  answers are RIGHT
d500 1
a500 1
  echo sphflake.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d504 1
a504 1
  HOST=`hostname`
d506 1
a506 1
  HOST=`uname -n`
d511 7
a517 7
if ! test $ret = 0 ; then
  tail -1 summary
  exit $ret
else
  echo
  echo "Summary:"
  tail -2 summary
d520 1
a520 1
echo Testing complete, check times against reference files in $path_to_run_sh/../pix/.
@


14.3
log
@update copyright to 2005
@
text
@d38 1
a38 1
#  @@(#)$Header: /cvsroot/brlcad/brlcad/bench/run.sh,v 14.2 2004/12/17 21:16:11 morrison Exp $ (BRL)
d49 2
@


14.2
log
@assignment of copyright and BSD license
@
text
@d5 2
a6 2
# Copyright (c) 2004 United States Government as represented by the
# U.S. Army Research Laboratory.
d38 1
a38 1
#  @@(#)$Header: /cvs/brlcad/bench/run.sh,v 14.1 2004/11/16 19:42:08 morrison Exp $ (BRL)
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d2 35
d38 1
a38 1
#  @@(#)$Header: /cvs/brlcad/bench/run.sh,v 1.20 2004/10/07 16:49:48 morrison Exp $ (BRL)
@


1.20
log
@decouple from machinetype.sh .. and remove the ancient alliant nfs hack that relied on the machine type value.
@
text
@d3 1
a3 1
#  @@(#)$Header: /cvs/brlcad/bench/run.sh,v 1.19 2004/10/07 13:42:29 morrison Exp $ (BRL)
d269 8
a276 8
# Local Variables: ***
# mode: sh ***
# tab-width: 8 ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# indent-tabs-mode: t ***
# End: ***
# ex: shiftwidth=2 tabstop=8
@


1.19
log
@sneaky test command name missing
@
text
@d3 1
a3 1
#  @@(#)$Header: /cvs/brlcad/bench/run.sh,v 1.18 2004/06/21 19:44:24 morrison Exp $ (BRL)
a13 14
# sets MACHINE, UNIXTYPE, HAS_TCP
eval `machinetype.sh -b 2> /dev/null`	

if test "x$MACHINE" = "x" ; then
  echo Looking for machinetype.sh...
  eval `$path_to_run_sh/../sh/machinetype.sh -b 2> /dev/null`
  if test "x$MACHINE" = "x" ; then
    echo WARNING: could not find machinetype.sh
    # try _something_, linux is pretty popular
    MACHINE="li"
  else
    echo ...found local machinetype.sh
  fi
fi
a71 8
fi

# Alliant NFS hack
if test "x${MACHINE}" = "xfx" ; then
  cp ${RT} /tmp/rt
  cp ${CMP} /tmp/pixcmp
  RT=/tmp/rt
  CMP=/tmp/pixcmp
@


1.18
log
@M-x indent region formatting and style consistency
@
text
@d3 1
a3 1
#  @@(#)$Header: /cvs/brlcad/bench/run.sh,v 1.17 2004/06/21 19:26:36 morrison Exp $ (BRL)
d70 1
a70 1
	if $? = 0 ; then
@


1.17
log
@update the script to the new directory structure removing cakeisms too
@
text
@d3 1
a3 1
#  @@(#)$Header: /cvs/brlcad/bench/run.sh,v 1.16 2004/06/21 18:03:44 morrison Exp $ (BRL)
d292 1
a292 1
# mode:sh ***
@


1.16
log
@add a format block and M-x indent-region
@
text
@d3 1
a3 1
#  @@(#)$Header: /cvs/brlcad/bench/run.sh,v 1.15 2004/05/13 13:18:11 morrison Exp $ (BRL)
d30 2
a31 1
# find RT (environment variable overrides)
d33 5
a37 14
  echo ...checking for NFS or local build...
  echo "pwd is `pwd`  and $0"
  # check for NFS build
  if test -x $path_to_run_sh/../.rt.$MACHINE/rt ; then
    echo ...found NFS build
    RT=$path_to_run_sh/../.rt.$MACHINE/rt
    if test x${DB} != x ; then DB=$path_to_run_sh/../.db.$MACHINE ; fi
    LD_LIBRARY_PATH=$path_to_run_sh/../.libbu.$MACHINE:$path_to_run_sh/../.libbn.$MACHINE:$path_to_run_sh/../.liboptical.$MACHINE:$path_to_run_sh/../.libitcl3.2.$MACHINE:$path_to_run_sh/../.libtcl8.3.$MACHINE:$path_to_run_sh/../.librt.$MACHINE:$path_to_run_sh/../.libfb.$MACHINE:$path_to_run_sh/../.libpkg.$MACHINE:$path_to_run_sh/../.libsysv.$MACHINE:$LD_LIBRARY_PATH
  # check for local build
  elif test -f $path_to_run_sh/../rt/rt ; then
    echo ...found local build
    RT=$path_to_run_sh/../rt/rt
    if test x${DB} != x ; then DB=$path_to_run_sh/../db ; fi
    LD_LIBRARY_PATH=$path_to_run_sh/../libbu:$path_to_run_sh/../libbn:$path_to_run_sh/../liboptical:$path_to_run_sh/../libitcl3.2:$path_to_run_sh/../libtcl8.3:$path_to_run_sh/../librt:$path_to_run_sh/../libfb:$path_to_run_sh/../libpkg:$path_to_run_sh/../libsysv:$LD_LIBRARY_PATH
d39 2
d47 3
a49 11
  echo ...checking for NFS or local build...	
  # check for NFS build
  if test -f $path_to_run_sh/../.db.$MACHINE/sphflake.g ;	then 
    echo ...found NFS build
    DB=$path_to_run_sh/../.db.$MACHINE
    LD_LIBRARY_PATH=$path_to_run_sh/../.libbu.$MACHINE:$path_to_run_sh/../.libbn.$MACHINE:$path_to_run_sh/../.liboptical.$MACHINE:$path_to_run_sh/../.libitcl3.2.$MACHINE:$path_to_run_sh/../.libtcl8.3.$MACHINE:$path_to_run_sh/../.librt.$MACHINE:$path_to_run_sh/../.libfb.$MACHINE:$path_to_run_sh/../.libpkg.$MACHINE:$path_to_run_sh/../.libsysv.$MACHINE:$LD_LIBRARY_PATH
  # check for local build
  elif test -f $path_to_run_sh/../db/sphflake.g ; then
    echo ...found local build
    DB=$path_to_run_sh/../db
    LD_LIBRARY_PATH=$path_to_run_sh/../libbu:$path_to_run_sh/../libbn:$path_to_run_sh/../liboptical:$path_to_run_sh/../libitcl3.2:$path_to_run_sh/../libtcl8.3:$path_to_run_sh/../librt:$path_to_run_sh/../libfb:$path_to_run_sh/../libpkg:$path_to_run_sh/../libsysv:$LD_LIBRARY_PATH
d51 2
a52 1

d59 3
a61 7
  echo ...checking for NFS of local build...
  if test -x $path_to_run_sh/../.bench.$MACHINE/pixcmp ; then
    echo ...found NFS build
    CMP=$path_to_run_sh/../.bench.$MACHINE/pixcmp
  elif test -x $path_to_run_sh/pixcmp ;	then
    echo ...found local build
    CMP=$path_to_run_sh/pixcmp
d63 12
a74 11
    echo ...need to build pixcmp
    cake >& /dev/null
    if test "x$?" = "x0" ; then
      echo ...building pixcmp with cake	
      cake pixcmp
    else
      if test "x${CC}" = "x" ; then
	CC=gcc
	$CC >& /dev/null
	if ! test "x$?" = "x1" ; then
	  CC=cc
d76 5
a82 3
    echo ...building pixcmp with $CC
    $CC -o pixcmp -I$path_to_run_sh/../h pixcmp.c
    CMP=$path_to_run_sh/pixcmp
d84 2
a95 1

d98 1
a98 1
  echo "ERROR:  Could not find RT"
d104 1
a104 1
  echo "ERROR:  Could not find database directory"
d110 1
a110 1
  echo "ERROR:  Could not find pixel comparison utility"
@


1.15
log
@allow the benchmark to run from other directories
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.14 2004/05/13 12:47:58 morrison Exp $ (BRL)
d14 3
a16 1
eval `machinetype.sh -b 2> /dev/null`	# sets MACHINE, UNIXTYPE, HAS_TCP
d18 9
a26 9
    echo Looking for machinetype.sh...
    eval `$path_to_run_sh/../sh/machinetype.sh -b 2> /dev/null`
    if test "x$MACHINE" = "x" ; then
        echo WARNING: could not find machinetype.sh
        # try _something_, linux is pretty popular
        MACHINE="li"
    else
    	echo ...found local machinetype.sh
    fi
d32 15
a46 15
	echo ...checking for NFS or local build...
	echo "pwd is `pwd`  and $0"
	# check for NFS build
	if test -x $path_to_run_sh/../.rt.$MACHINE/rt ;	then
		echo ...found NFS build
		RT=$path_to_run_sh/../.rt.$MACHINE/rt
		if test x${DB} != x ; then DB=$path_to_run_sh/../.db.$MACHINE ; fi
		LD_LIBRARY_PATH=$path_to_run_sh/../.libbu.$MACHINE:$path_to_run_sh/../.libbn.$MACHINE:$path_to_run_sh/../.liboptical.$MACHINE:$path_to_run_sh/../.libitcl3.2.$MACHINE:$path_to_run_sh/../.libtcl8.3.$MACHINE:$path_to_run_sh/../.librt.$MACHINE:$path_to_run_sh/../.libfb.$MACHINE:$path_to_run_sh/../.libpkg.$MACHINE:$path_to_run_sh/../.libsysv.$MACHINE:$LD_LIBRARY_PATH
	# check for local build
	elif test -f $path_to_run_sh/../rt/rt ;	then
		echo ...found local build
		RT=$path_to_run_sh/../rt/rt
		if test x${DB} != x ; then DB=$path_to_run_sh/../db ; fi
		LD_LIBRARY_PATH=$path_to_run_sh/../libbu:$path_to_run_sh/../libbn:$path_to_run_sh/../liboptical:$path_to_run_sh/../libitcl3.2:$path_to_run_sh/../libtcl8.3:$path_to_run_sh/../librt:$path_to_run_sh/../libfb:$path_to_run_sh/../libpkg:$path_to_run_sh/../libsysv:$LD_LIBRARY_PATH
	fi
d53 12
a64 12
	echo ...checking for NFS or local build...	
	# check for NFS build
	if test -f $path_to_run_sh/../.db.$MACHINE/sphflake.g ;	then 
		echo ...found NFS build
		DB=$path_to_run_sh/../.db.$MACHINE
		LD_LIBRARY_PATH=$path_to_run_sh/../.libbu.$MACHINE:$path_to_run_sh/../.libbn.$MACHINE:$path_to_run_sh/../.liboptical.$MACHINE:$path_to_run_sh/../.libitcl3.2.$MACHINE:$path_to_run_sh/../.libtcl8.3.$MACHINE:$path_to_run_sh/../.librt.$MACHINE:$path_to_run_sh/../.libfb.$MACHINE:$path_to_run_sh/../.libpkg.$MACHINE:$path_to_run_sh/../.libsysv.$MACHINE:$LD_LIBRARY_PATH
	# check for local build
	elif test -f $path_to_run_sh/../db/sphflake.g ; then
		echo ...found local build
		DB=$path_to_run_sh/../db
		LD_LIBRARY_PATH=$path_to_run_sh/../libbu:$path_to_run_sh/../libbn:$path_to_run_sh/../liboptical:$path_to_run_sh/../libitcl3.2:$path_to_run_sh/../libtcl8.3:$path_to_run_sh/../librt:$path_to_run_sh/../libfb:$path_to_run_sh/../libpkg:$path_to_run_sh/../libsysv:$LD_LIBRARY_PATH
	fi
d72 19
a90 25
	echo ...checking for NFS of local build...
	if test -x $path_to_run_sh/../.bench.$MACHINE/pixcmp ; then
		echo ...found NFS build
		CMP=$path_to_run_sh/../.bench.$MACHINE/pixcmp
	elif test -x $path_to_run_sh/pixcmp ;	then
		echo ...found local build
		CMP=$path_to_run_sh/pixcmp
	else
		echo ...need to build pixcmp
		cake >& /dev/null
		if test "x$?" = "x0" ; then
			echo ...building pixcmp with cake	
			cake pixcmp
		else
			if test "x${CC}" = "x" ; then
				CC=gcc
				$CC >& /dev/null
				if ! test "x$?" = "x1" ; then
					CC=cc
				fi
			fi
		fi
		echo ...building pixcmp with $CC
		$CC -o pixcmp -I$path_to_run_sh/../h pixcmp.c
		CMP=$path_to_run_sh/pixcmp
d92 6
d102 4
a105 4
	cp ${RT} /tmp/rt
	cp ${CMP} /tmp/pixcmp
	RT=/tmp/rt
	CMP=/tmp/pixcmp
d111 2
a112 2
	echo "ERROR:  Could not find RT"
	exit 1
d114 1
a114 1
	echo "Using [$RT] for RT"
d117 2
a118 2
	echo "ERROR:  Could not find database directory"
	exit 1
d120 1
a120 1
	echo "Using [$DB] for DB"
d123 2
a124 2
	echo "ERROR:  Could not find pixel comparison utility"
	exit 1
d126 1
a126 1
	echo "Using [$CMP] for CMP"
d138 4
a141 4
	-o moss.pix \
	$DB/moss.g all.g \
	2> moss.log \
	<< EOF
d155 1
a155 1
	echo moss.pix:  answers are RIGHT
d157 1
a157 1
	echo moss.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d164 4
a167 4
	-o world.pix \
	$DB/world.g all.g \
	2> world.log \
	<< EOF
d181 1
a181 1
	echo world.pix:  answers are RIGHT
d183 1
a183 1
	echo world.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d190 4
a193 4
	-o star.pix \
	$DB/star.g all \
	2> star.log \
	<<EOF
d206 1
a206 1
	echo star.pix:  answers are RIGHT
d208 1
a208 1
	echo star.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d215 4
a218 4
	-o bldg391.pix \
	$DB/bldg391.g all.g \
	2> bldg391.log \
	<<EOF
d232 1
a232 1
	echo bldg391.pix:  answers are RIGHT
d234 1
a234 1
	echo bldg391.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d241 4
a244 4
	-o m35.pix \
	$DB/m35.g all.g \
	2> m35.log \
	<< EOF
d257 1
a257 1
	echo m35.pix:  answers are RIGHT
d259 1
a259 1
	echo m35.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d266 5
a270 5
	-o sphflake.pix \
	$DB/sphflake.g \
	"scene.r" \
	2> sphflake.log \
	<< EOF
d280 1
a280 1
	echo sphflake.pix:  answers are RIGHT
d282 1
a282 1
	echo sphflake.pix:  WRONG WRONG WRONG WRONG WRONG WRONG
d286 1
a286 1
	HOST=`hostname`
d288 1
a288 1
	HOST=`uname -n`
d294 2
a295 2
    tail -1 summary
    exit $ret
d297 3
a299 3
    echo
    echo "Summary:"
    tail -2 summary
d303 9
@


1.14
log
@if ; then
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.13 2003/11/19 23:58:39 morrison Exp $ (BRL)
d12 1
d17 1
a17 1
    eval `../sh/machinetype.sh -b 2> /dev/null`
d31 1
d33 1
a33 1
	if test -x ../.rt.$MACHINE/rt ;	then
d35 3
a37 3
		RT=../.rt.$MACHINE/rt
		if test x${DB} != x ; then DB=../.db.$MACHINE ; fi
		LD_LIBRARY_PATH=../.libbu.$MACHINE:../.libbn.$MACHINE:../.liboptical.$MACHINE:../.libitcl3.2.$MACHINE:../.libtcl8.3.$MACHINE:../.librt.$MACHINE:../.libfb.$MACHINE:../.libpkg.$MACHINE:../.libsysv.$MACHINE:$LD_LIBRARY_PATH
d39 1
a39 1
	elif test -f ../rt/rt ;	then
d41 3
a43 3
		RT=../rt/rt
		if test x${DB} != x ; then DB=../db ; fi
		LD_LIBRARY_PATH=../libbu:../libbn:../liboptical:../libitcl3.2:../libtcl8.3:../librt:../libfb:../libpkg:../libsysv:$LD_LIBRARY_PATH
d53 1
a53 1
	if test -f ../.db.$MACHINE/sphflake.g ;	then 
d55 2
a56 2
		DB=../.db.$MACHINE
		LD_LIBRARY_PATH=../.libbu.$MACHINE:../.libbn.$MACHINE:../.liboptical.$MACHINE:../.libitcl3.2.$MACHINE:../.libtcl8.3.$MACHINE:../.librt.$MACHINE:../.libfb.$MACHINE:../.libpkg.$MACHINE:../.libsysv.$MACHINE:$LD_LIBRARY_PATH
d58 1
a58 1
	elif test -f ../db/sphflake.g ; then
d60 2
a61 2
		DB=../db
		LD_LIBRARY_PATH=../libbu:../libbn:../liboptical:../libitcl3.2:../libtcl8.3:../librt:../libfb:../libpkg:../libsysv:$LD_LIBRARY_PATH
d71 1
a71 1
	if test -x ../.bench.$MACHINE/pixcmp ; then
d73 2
a74 2
		CMP=../.bench.$MACHINE/pixcmp
	elif test -x ./pixcmp ;	then
d76 1
a76 1
		CMP=./pixcmp
d93 2
a94 2
		$CC -o pixcmp -I../h pixcmp.c
		CMP=./pixcmp
d151 1
a151 1
${CMP} ../pix/moss.pix moss.pix
d177 1
a177 1
${CMP} ../pix/world.pix world.pix
d202 1
a202 1
${CMP} ../pix/star.pix star.pix
d228 1
a228 1
${CMP} ../pix/bldg391.pix bldg391.pix
d253 1
a253 1
${CMP} ../pix/m35.pix m35.pix
d276 1
a276 1
${CMP} ../pix/sphflake.pix sphflake.pix
a282 4

echo
echo Testing complete, check times against reference files in ../pix/.

d289 12
a300 1
sh ../bench/perf.sh "$HOST" "`date`" "$*" >> summary
@


1.13
log
@benchmarks should try to run even if machinetype.sh isn't in path
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.12 2003/01/25 14:47:27 morrison Exp $ (BRL)
d14 1
a14 2
if test "x$MACHINE" = "x"
then
d17 1
a17 2
    if test "x$MACHINE" = "x"
    then
d28 1
a28 2
if test "x${RT}" = "x"
then
d31 1
a31 2
	if test -x ../.rt.$MACHINE/rt
	then
d37 1
a37 2
	elif test -f ../rt/rt
	then
d48 1
a48 2
if test "x${DB}" = "x"
then
d51 1
a51 2
	if test -f ../.db.$MACHINE/sphflake.g 
	then 
d56 1
a56 2
	elif test -f ../db/sphflake.g
	then
d67 1
a67 2
if test "x${CMP}" = "x"
then
d69 1
a69 2
	if test -x ../.bench.$MACHINE/pixcmp
	then
d72 1
a72 2
	elif test -x ./pixcmp
	then
d78 1
a78 2
		if test "x$?" = "x0"
		then
d82 1
a82 2
			if test "x${CC}" = "x"
			then
d85 1
a85 2
				if ! test "x$?" = "x1"
				then
d97 1
a97 2
if test "x${MACHINE}" = "xfx"
then
d106 1
a106 2
if test "x${RT}" = "x"
then
d112 1
a112 2
if test "x${DB}" = "x"
then
d118 1
a118 2
if test "x${CMP}" = "x"
then
d150 1
a150 2
if test $? = 0
then
d176 1
a176 2
if test $? = 0
then
d201 1
a201 2
if test $? = 0
then
d227 1
a227 2
if test $? = 0
then
d252 1
a252 2
if test $? = 0
then
d275 1
a275 2
if test $? = 0
then
d285 4
a288 3
if test x$UNIXTYPE = xBSD
then	HOST=`hostname`
else	HOST=`uname -n`
a291 4




@


1.12
log
@Added support to check whether or not cake is available when generating pixcmp.  If cake is not available, it now tries to find a compiler and compile itself.
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.11 2001/07/16 18:05:18 morrison Exp $ (BRL)
d13 14
a26 1
eval `machinetype.sh -b`	# sets MACHINE, UNIXTYPE, HAS_TCP
@


1.12.6.1
log
@updates from HEAD
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.13 2003/11/19 23:58:39 morrison Exp $ (BRL)
d13 1
a13 14
eval `machinetype.sh -b 2> /dev/null`	# sets MACHINE, UNIXTYPE, HAS_TCP
if test "x$MACHINE" = "x"
then
    echo Looking for machinetype.sh...
    eval `../sh/machinetype.sh -b 2> /dev/null`
    if test "x$MACHINE" = "x"
    then
        echo WARNING: could not find machinetype.sh
        # try _something_, linux is pretty popular
        MACHINE="li"
    else
    	echo ...found local machinetype.sh
    fi
fi
@


1.12.6.2
log
@merge from HEAD
@
text
@@


1.12.6.3
log
@merge from head
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.12.6.2 2004/02/12 19:40:40 erikg Exp $ (BRL)
@


1.11
log
@wrapped tests in quotes to protect commands with args
e.g. export RT="../.rt.li/rt -T 0.0000001 -s1024"
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.10 2001/05/16 21:36:48 morrison Exp $ (BRL)
d75 18
a92 1
		cake pixcmp
@


1.11.4.1
log
@sync branch with HEAD
@
text
@d3 1
a3 1
#  @@(#)$Header$ (BRL)
d13 1
a13 14
eval `machinetype.sh -b 2> /dev/null`	# sets MACHINE, UNIXTYPE, HAS_TCP
if test "x$MACHINE" = "x"
then
    echo Looking for machinetype.sh...
    eval `../sh/machinetype.sh -b 2> /dev/null`
    if test "x$MACHINE" = "x"
    then
        echo WARNING: could not find machinetype.sh
        # try _something_, linux is pretty popular
        MACHINE="li"
    else
    	echo ...found local machinetype.sh
    fi
fi
d75 1
a75 18
		cake >& /dev/null
		if test "x$?" = "x0"
		then
			echo ...building pixcmp with cake	
			cake pixcmp
		else
			if test "x${CC}" = "x"
			then
				CC=gcc
				$CC >& /dev/null
				if ! test "x$?" = "x1"
				then
					CC=cc
				fi
			fi
		fi
		echo ...building pixcmp with $CC
		$CC -o pixcmp -I../h pixcmp.c
@


1.11.6.1
log
@sync to HEAD...
@
text
@d3 1
a3 1
#  @@(#)$Header: /n/cad/c/CVS/brlcad/bench/run.sh,v 1.13 2003/11/19 23:58:39 morrison Exp $ (BRL)
d13 1
a13 14
eval `machinetype.sh -b 2> /dev/null`	# sets MACHINE, UNIXTYPE, HAS_TCP
if test "x$MACHINE" = "x"
then
    echo Looking for machinetype.sh...
    eval `../sh/machinetype.sh -b 2> /dev/null`
    if test "x$MACHINE" = "x"
    then
        echo WARNING: could not find machinetype.sh
        # try _something_, linux is pretty popular
        MACHINE="li"
    else
    	echo ...found local machinetype.sh
    fi
fi
d75 1
a75 18
		cake >& /dev/null
		if test "x$?" = "x0"
		then
			echo ...building pixcmp with cake	
			cake pixcmp
		else
			if test "x${CC}" = "x"
			then
				CC=gcc
				$CC >& /dev/null
				if ! test "x$?" = "x1"
				then
					CC=cc
				fi
			fi
		fi
		echo ...building pixcmp with $CC
		$CC -o pixcmp -I../h pixcmp.c
@


1.10
log
@updated to include better checking for benchmark tools, including using environment variables to override
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.9 2001/04/27 22:36:28 morrison Exp $ (BRL)
d17 1
a17 1
if test x${RT} = x
d40 1
a40 1
if test x${DB} = x
d62 1
a62 1
if test x${CMP} = x
d81 1
a81 1
if test x${MACHINE} = xfx
d91 1
a91 1
if test x${RT} = x
d98 1
a98 1
if test x${DB} = x
d105 1
a105 1
if test x${CMP} = x
@


1.9
log
@Added a cake clean to wipe out just pixcmp and *.o files for nfs benchmarkers who try to use the ./pixcmp tool

Updated run.sh to handle a lot more build cases and error conditions, plus the option to override settings with environment variables for RT, DB, and CMP
Thus, I can compare a remrt run to vger stats.
@
text
@d3 1
a3 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.8 1998/12/31 08:15:18 morrison Exp $ (BRL)
d26 1
a26 1
		LD_LIBRARY_PATH=../.libbu.$MACHINE:../.libbn.$MACHINE:../.librt.$MACHINE:../.libfb.$MACHINE:../.libpkg.$MACHINE:../.libsysv.$MACHINE:$LD_LIBRARY_PATH
d33 1
a33 1
		LD_LIBRARY_PATH=../libbu:../libbn:../librt:../libfb:../libpkg:../libsysv:$LD_LIBRARY_PATH
d48 1
a48 1
		LD_LIBRARY_PATH=../.libbu.$MACHINE:../.libbn.$MACHINE:../.librt.$MACHINE:../.libfb.$MACHINE:../.libpkg.$MACHINE:../.libsysv.$MACHINE:$LD_LIBRARY_PATH
d54 1
a54 1
		LD_LIBRARY_PATH=../libbu:../libbn:../librt:../libfb:../libpkg:../libsysv:$LD_LIBRARY_PATH
@


1.8
log
@updated the benchmark tools to run the benchmark for
the sphere flake
@
text
@d3 6
a8 1
#  @@(#)$Header: /c/CVS/brlcad/bench/run.sh,v 1.7 1997/01/08 01:02:28 mike Exp $ (BRL)
d14 27
a40 1
if test -f ../.rt.$MACHINE/rt
d42 9
a50 5
	RT=../.rt.$MACHINE/rt
	DB=../.db.$MACHINE
	LD_LIBRARY_PATH=../.libbu.$MACHINE:../.libbn.$MACHINE:../.librt.$MACHINE:../.libfb.$MACHINE:../.libpkg.$MACHINE:../.libsysv.$MACHINE:$LD_LIBRARY_PATH
else
	if test ! -f ../rt/rt
d52 3
a54 2
		echo "Can't find RT"
		exit 1
d56 1
a56 3
	RT=../rt/rt
	DB=../db
	LD_LIBRARY_PATH=../libbu:../libbn:../librt:../libfb:../libpkg:../libsysv:$LD_LIBRARY_PATH
a57 1
export LD_LIBRARY_PATH
d59 4
a62 2
CMP=./pixcmp
if test ! -f $CMP
d64 14
a77 1
	cake pixcmp
d89 27
d136 1
d163 1
d189 1
d216 1
d242 1
d266 1
@


1.7
log
@Added libbu and libbn
@
text
@d3 1
a3 1
#  @@(#)$Header: /m/cad/bench/RCS/run.sh,v 1.6 1994/09/22 03:56:29 mike Exp mike $ (BRL)
d171 24
d204 4
@


1.6
log
@Fixed bug with stupid SGI Irix 5 shared libraries.
@
text
@d3 1
a3 1
#  @@(#)$Header: /m/cad/bench/RCS/run.sh,v 1.5 89/05/19 05:21:11 mike Exp Locker: mike $ (BRL)
d13 1
a13 1
	LD_LIBRARY_PATH=../.librt.$MACHINE:../.libfb.$MACHINE:../.libpkg.$MACHINE:../.libsysv.$MACHINE:$LD_LIBRARY_PATH
d22 1
a22 1
	LD_LIBRARY_PATH=../librt:../libfb:../libpkg:../libsysv:$LD_LIBRARY_PATH
@


1.5
log
@Improved
@
text
@d3 1
a3 1
#  @@(#)$Header: run.sh,v 1.4 89/04/29 02:50:55 mike Locked $ (BRL)
d13 1
d15 1
a15 1
	if test -f ../rt/rt
a16 3
		RT=../rt/rt
		DB=../db
	else
d20 3
d24 1
@


1.4
log
@Improved version, with Alliant support
@
text
@d3 1
a3 1
#  @@(#)$Header: run.sh,v 1.3 88/10/03 14:06:58 mike Locked $ (BRL)
d42 2
a43 2
mv -f moss.pix moss.pix.$$
mv -f moss.log moss.log.$$
d62 1
a62 1
	echo moss.pix:  RIGHT answers
d64 1
a64 1
	echo moss.pix:  WRONG WRONG WRONG
d68 2
a69 2
mv -f world.pix world.pix.$$
mv -f world.log world.log.$$
d88 1
a88 1
	echo world.pix:  RIGHT answers
d90 1
a90 1
	echo world.pix:  WRONG WRONG WRONG
d94 2
a95 2
mv -f star.pix star.pix.$$
mv -f star.log star.log.$$
d113 1
a113 1
	echo star.pix:  RIGHT answers
d115 1
a115 1
	echo star.pix:  WRONG WRONG WRONG
d119 2
a120 2
mv -f bldg391.pix bldg391.pix.$$
mv -f bldg391.log bldg391.log.$$
d139 1
a139 1
	echo bldg391.pix:  RIGHT answers
d141 1
a141 1
	echo bldg391.pix:  WRONG WRONG WRONG
d145 2
a146 2
mv -f m35.pix m35.pix.$$
mv -f m35.log m35.log.$$
d164 1
a164 1
	echo m35.pix:  RIGHT answers
d166 1
a166 1
	echo m35.pix:  WRONG WRONG WRONG
@


1.3
log
@../bench/perf.sh
@
text
@d3 1
a3 1
#  @@(#)$Header: run.sh,v 1.2 88/10/01 06:56:28 mike Locked $ (BRL)
d6 1
a6 1
export PATH || (echo "This isn't sh.  Feeding myself to sh."; sh $0 $*; kill $$)
d24 15
a39 1
set -x
d41 1
d59 1
a59 1
./pixcmp ../pix/moss.pix moss.pix
d67 1
a67 1

d85 1
a85 1
./pixcmp ../pix/world.pix world.pix
d93 1
a93 1

d110 1
a110 1
./pixcmp ../pix/star.pix star.pix
d118 1
a118 1

d136 1
a136 1
./pixcmp ../pix/bldg391.pix bldg391.pix
d144 26
@


1.2
log
@changed from CMP to pixcmp
@
text
@d3 1
a3 1
#  @@(#)$Header: run,v 1.1 88/09/12 01:08:03 kermit Locked $ (BRL)
d136 1
a136 1
sh perf.sh "$HOST" "`date`" "$*" >> summary
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
#  @@(#)$Header: perf.sh,v 1.2 88/09/12 00:44:32 mike Exp $ (BRL)
d44 1
a44 1
cmp ../pix/moss.pix moss.pix
d70 1
a70 1
cmp ../pix/world.pix world.pix
d95 1
a95 1
cmp ../pix/star.pix star.pix
d121 1
a121 1
cmp ../pix/bldg391.pix bldg391.pix
d136 1
a136 1
sh perf.sh $HOST "`date`" "$*" >> summary
@
