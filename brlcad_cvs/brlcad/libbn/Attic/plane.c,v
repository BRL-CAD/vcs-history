head	11.37;
access;
symbols
	ansi-20040405-merged:11.34.2.1
	postmerge-20040405-ansi:11.35
	premerge-20040404-ansi:11.34
	postmerge-autoconf:11.34
	autoconf-freeze:11.34
	premerge-autoconf:11.34
	ansi-20040316-freeze:11.34.2.1
	postmerge-20040315-windows:11.34
	premerge-20040315-windows:11.34
	windows-20040315-freeze:11.34
	autoconf-20031203:11.34
	autoconf-20031202:11.34
	autoconf-branch:11.34.0.10
	phong-branch:11.34.0.8
	photonmap-branch:11.34.0.6
	rel-6-1-DP:11.34
	windows-branch:11.34.0.4
	rel-6-0-2:11.32
	ansi-branch:11.34.0.2
	rel-6-0-1-branch:11.32.0.2
	hartley-6-0-post:11.33
	hartley-6-0-pre:11.32
	rel-6-0-1:11.32
	rel-6-0:11.32
	rel-5-4:11.26.2.2
	offsite-5-3-pre:11.30
	rel-5-3:11.26.2.2
	rel-5-2:11.26.2.2
	rel-5-1-branch:11.26.0.2
	rel-5-1:11.26
	rel-5-0:11.17
	rel-5-0-beta:11.16
	rel-4-5:11.15
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.14
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.37
date	2004.05.21.18.06.22;	author morrison;	state dead;
branches;
next	11.36;

11.36
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.35;

11.35
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2002.08.20.17.07.36;	author jra;	state Exp;
branches
	11.34.2.1;
next	11.33;

11.33
date	2002.08.15.20.54.48;	author hartley;	state Exp;
branches;
next	11.32;

11.32
date	2001.04.05.19.35.27;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2001.03.31.01.56.48;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2000.10.24.18.25.31;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.30.23.35.51;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.08.25.13.04.39;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	2000.07.11.23.30.39;	author cjohnson;	state Exp;
branches;
next	11.26;

11.26
date	2000.05.11.19.17.57;	author mike;	state Exp;
branches
	11.26.2.1;
next	11.25;

11.25
date	2000.05.11.03.21.05;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.05.10.00.55.03;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.03.29.02.06.57;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.02.28.21.03.31;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2000.01.07.20.01.07;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.12.29.20.21.42;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	99.12.09.19.19.53;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	99.12.06.20.35.15;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	99.07.02.19.11.25;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.03.06.16.06.05;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.09.17.20.32.54;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.07.23.06.54.22;	author gdurf;	state Exp;
branches;
next	11.13;

11.13
date	97.07.02.21.16.10;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	97.01.07.23.09.38;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.01.07.22.57.23;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.12.31.02.50.16;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.12.23.21.38.24;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.10.03.00.29.25;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.09.13.04.27.35;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.04.19.15.28.06;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.04.12.14.56.26;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.03.02.04.47.39;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.28.23.45.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.02.01.48.04;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.23;	author mike;	state Rel4_4;
branches;
next	10.36;

10.36
date	95.01.04.07.56.00;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.11.28.13.26.47;	author jra;	state Exp;
branches;
next	10.34;

10.34
date	94.11.04.05.54.06;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	94.10.11.19.36.09;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.09.16.20.19.52;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	94.08.10.19.20.21;	author gdurf;	state Exp;
branches;
next	10.30;

10.30
date	94.07.01.23.36.01;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	94.04.22.05.28.14;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.04.21.07.00.33;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	94.04.20.00.43.22;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	94.04.19.07.17.16;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.04.18.06.06.01;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	94.04.18.01.46.03;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	94.04.17.19.45.34;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	94.04.12.22.39.26;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	94.03.09.22.03.45;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	94.03.04.18.38.18;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.03.04.18.26.03;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	94.03.04.11.09.53;	author jra;	state Exp;
branches;
next	10.17;

10.17
date	94.03.04.04.30.01;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.03.02.17.07.08;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.01.27.05.23.59;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.01.22.05.17.40;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.01.12.02.50.10;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.08.12.22.26.31;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.05.20.17.10.48;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.05.19.20.44.59;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	93.03.25.18.05.02;	author mm;	state Exp;
branches;
next	10.8;

10.8
date	93.03.24.22.23.22;	author mm;	state Exp;
branches;
next	10.7;

10.7
date	93.03.17.01.18.29;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.03.17.00.28.34;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.03.16.01.18.43;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.02.11.21.58.11;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.02.06.04.25.53;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.25.00.01.46;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.53;	author mike;	state Rel4_0;
branches;
next	1.23;

1.23
date	91.06.19.21.22.45;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	91.06.14.06.26.08;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.05.25.01.35.40;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	91.05.18.03.03.32;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.04.01.18.36.07;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	91.02.27.22.58.08;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.12.07.00.45.46;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.12.06.19.58.25;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.12.06.19.44.43;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	90.11.01.04.49.14;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	90.05.16.07.41.24;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	90.05.13.11.29.09;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.05.13.11.22.40;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	90.05.10.08.43.14;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	90.05.10.05.15.56;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	90.03.14.23.10.38;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.03.05.22.23.57;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.03.03.05.59.21;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.10.18.14.31.13;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.10.16.10.16.44;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.10.13.22.02.16;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.10.13.20.38.35;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.10.16.05.53;	author mike;	state Exp;
branches;
next	;

11.26.2.1
date	2000.08.24.13.29.28;	author jra;	state Exp;
branches;
next	11.26.2.2;

11.26.2.2
date	2000.08.25.12.59.59;	author jra;	state Exp;
branches;
next	;

11.34.2.1
date	2002.09.19.18.01.09;	author morrison;	state Exp;
branches;
next	;


desc
@Useful routines for dealing with planes.
@


11.37
log
@moved to src/
@
text
@/*
 *			P L A N E . C
 *
 *  Some useful routines for dealing with planes and lines.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited
 */
#ifndef lint
static const char RCSplane[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/plane.c,v 11.36 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"

#define		UNIT_SQ_TOL	1.0e-13

/*
 *			B N _ D I S T _ P T 3 _ P T 3
 *
 *  Returns distance between two points.
 */
double
bn_dist_pt3_pt3(const fastf_t *a, const fastf_t *b)
{
	vect_t	diff;

	VSUB2( diff, a, b );
	return MAGNITUDE( diff );
}

/*
 *			B N _ P T 3 _ P T 3 _ E Q U A L
 *
 *  Returns -
 *	1	if the two points are equal, within the tolerance
 *	0	if the two points are not "the same"
 */
int
bn_pt3_pt3_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
{
	vect_t	diff;

	BN_CK_TOL(tol);
	VSUB2( diff, b, a );
	if( MAGSQ( diff ) < tol->dist_sq )  return 1;
	return 0;
}

/*
 *			B N _ P T 2 _ P T 2 _ E Q U A L
 *
 *  Returns -
 *	1	if the two points are equal, within the tolerance
 *	0	if the two points are not "the same"
 */
int
bn_pt2_pt2_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
{
	vect_t	diff;

	BN_CK_TOL(tol);
	VSUB2_2D( diff, b, a );
	if( MAGSQ_2D( diff ) < tol->dist_sq )  return 1;
	return 0;
}

/*
 *			B N _ 3 P T S _ C O L L I N E A R
 *
 *  Check to see if three points are collinear.
 *
 *  The algorithm is designed to work properly regardless of the
 *  order in which the points are provided.
 *
 *  Returns (boolean) -
 *	1	If 3 points are collinear
 *	0	If they are not
 */
int
bn_3pts_collinear(fastf_t *a, fastf_t *b, fastf_t *c, const struct bn_tol *tol)
{
	fastf_t	mag_ab, mag_bc, mag_ca, max_len, dist_sq;
	fastf_t cos_a, cos_b, cos_c;
	vect_t	ab, bc, ca;
	int max_edge_no;

	VSUB2(ab, b, a);
	VSUB2(bc, c, b);
	VSUB2(ca, a, c);
	mag_ab = MAGNITUDE(ab);
	mag_bc = MAGNITUDE(bc);
	mag_ca = MAGNITUDE(ca);

	/* find longest edge */
	max_len = mag_ab;
	max_edge_no = 1;

	if( mag_bc > max_len )
	{
		max_len = mag_bc;
		max_edge_no = 2;
	}

	if( mag_ca > max_len )
	{
		max_len = mag_ca;
		max_edge_no = 3;
	}

	switch( max_edge_no )
	{
		default:
		case 1:
			cos_b = (-VDOT( ab , bc ))/(mag_ab * mag_bc );
			dist_sq = mag_bc*mag_bc*( 1.0 - cos_b*cos_b);
			break;
		case 2:
			cos_c = (-VDOT( bc , ca ))/(mag_bc * mag_ca );
			dist_sq = mag_ca*mag_ca*(1.0 - cos_c*cos_c);
			break;
		case 3:
			cos_a = (-VDOT( ca , ab ))/(mag_ca * mag_ab );
			dist_sq = mag_ab*mag_ab*(1.0 - cos_a*cos_a);
			break;
	}

	if( dist_sq <= tol->dist_sq )
		return( 1 );
	else
		return( 0 );
}


/*
 *			B N _ 3 P T S _ D I S T I N C T
 *
 *  Check to see if three points are all distinct, i.e.,
 *  ensure that there is at least sqrt(dist_tol_sq) distance
 *  between every pair of points.
 *
 *  Returns (boolean) -
 *	1	If all three points are distinct
 *	0	If two or more points are closer together than dist_tol_sq
 */
int
bn_3pts_distinct(const fastf_t *a, const fastf_t *b, const fastf_t *c, const struct bn_tol *tol)
{
	vect_t	B_A;
	vect_t	C_A;
	vect_t	C_B;

	BN_CK_TOL(tol);
	VSUB2( B_A, b, a );
	if( MAGSQ( B_A ) <= tol->dist_sq )  return(0);
	VSUB2( C_A, c, a );
	if( MAGSQ( C_A ) <= tol->dist_sq )  return(0);
	VSUB2( C_B, c, b );
	if( MAGSQ( C_B ) <= tol->dist_sq )  return(0);
	return(1);
}

/*
 *			B N _ M K _ P L A N E _ 3 P T S
 *
 *  Find the equation of a plane that contains three points.
 *  Note that normal vector created is expected to point out (see vmath.h),
 *  so the vector from A to C had better be counter-clockwise
 *  (about the point A) from the vector from A to B.
 *  This follows the BRL-CAD outward-pointing normal convention, and the
 *  right-hand rule for cross products.
 *
 *
 *			C
 *	                *
 *	                |\
 *	                | \
 *	   ^     N      |  \
 *	   |      \     |   \
 *	   |       \    |    \
 *	   |C-A     \   |     \
 *	   |         \  |      \
 *	   |          \ |       \
 *	               \|        \
 *	                *---------*
 *	                A         B
 *			   ----->
 *		            B-A
 *
 *  If the points are given in the order A B C (eg, *counter*-clockwise),
 *  then the outward pointing surface normal N = (B-A) x (C-A).
 *
 *  Explicit Return -
 *	 0	OK
 *	-1	Failure.  At least two of the points were not distinct,
 *		or all three were colinear.
 *
 *  Implicit Return -
 *	plane	The plane equation is stored here.
 */
int
bn_mk_plane_3pts(fastf_t *plane, const fastf_t *a, const fastf_t *b, const fastf_t *c, const struct bn_tol *tol)
{
	vect_t	B_A;
	vect_t	C_A;
	vect_t	C_B;
	register fastf_t mag;

	BN_CK_TOL(tol);

	VSUB2( B_A, b, a );
	if( MAGSQ( B_A ) <= tol->dist_sq )  return(-1);
	VSUB2( C_A, c, a );
	if( MAGSQ( C_A ) <= tol->dist_sq )  return(-1);
	VSUB2( C_B, c, b );
	if( MAGSQ( C_B ) <= tol->dist_sq )  return(-1);

	VCROSS( plane, B_A, C_A );

	/* Ensure unit length normal */
	if( (mag = MAGNITUDE(plane)) <= SMALL_FASTF )
		return(-1);	/* FAIL */
	mag = 1/mag;
	VSCALE( plane, plane, mag );

	/* Find distance from the origin to the plane */
	/* XXX Should do with pt that has smallest magnitude (closest to origin) */
	plane[3] = VDOT( plane, a );

#if 0
	/* Check to be sure that angle between A-Origin and N vect < 89 degrees */
	/* XXX Could complain for pts on axis-aligned plane, far from origin */
	mag = MAGSQ(a);
	if( mag > tol->dist_sq )  {
		/* cos(89 degrees) = 0.017452406, reciprocal is 57.29 */
		if( plane[3]/sqrt(mag) < 0.017452406 )  {
			bu_log("bn_mk_plane_3pts() WARNING: plane[3] value is suspect\n");
		}
	}
#endif
	return(0);		/* OK */
}

/*
 *			B N _ M K P O I N T _ 3 P L A N E S
 *
 *  Given the description of three planes, compute the point of intersection,
 *  if any.
 *
 *  Find the solution to a system of three equations in three unknowns:
 *
 *	Px * Ax + Py * Ay + Pz * Az = -A3;
 *	Px * Bx + Py * By + Pz * Bz = -B3;
 *	Px * Cx + Py * Cy + Pz * Cz = -C3;
 *
 *  or
 *
 *	[ Ax  Ay  Az ]   [ Px ]   [ -A3 ]
 *	[ Bx  By  Bz ] * [ Py ] = [ -B3 ]
 *	[ Cx  Cy  Cz ]   [ Pz ]   [ -C3 ]
 *
 *
 *  Explitic Return -
 *	 0	OK
 *	-1	Failure.  Intersection is a line or plane.
 *
 *  Implicit Return -
 *	pt	The point of intersection is stored here.
 */
int
bn_mkpoint_3planes(fastf_t *pt, const fastf_t *a, const fastf_t *b, const fastf_t *c)
{
	vect_t	v1, v2, v3;
	register fastf_t det;

	/* Find a vector perpendicular to both planes B and C */
	VCROSS( v1, b, c );

	/*  If that vector is perpendicular to A,
	 *  then A is parallel to either B or C, and no intersection exists.
	 *  This dot&cross product is the determinant of the matrix M.
	 *  (I suspect there is some deep significance to this!)
	 */
	det = VDOT( a, v1 );
	if( NEAR_ZERO( det, SMALL_FASTF ) )  return(-1);

	VCROSS( v2, a, c );
	VCROSS( v3, a, b );

	det = 1/det;
	pt[X] = det*(a[3]*v1[X] - b[3]*v2[X] + c[3]*v3[X]);
	pt[Y] = det*(a[3]*v1[Y] - b[3]*v2[Y] + c[3]*v3[Y]);
	pt[Z] = det*(a[3]*v1[Z] - b[3]*v2[Z] + c[3]*v3[Z]);
	return(0);
}

/*
 *			B N _ 2 L I N E 3 _ C O L I N E A R
 *
 *  Returns non-zero if the 3 lines are colinear to within tol->dist
 *  over the given distance range.
 *
 *  Range should be at least one model diameter for most applications.
 *  1e5 might be OK for a default for "vehicle sized" models.
 *
 *  The direction vectors do not need to be unit length.
 */
int
bn_2line3_colinear(const fastf_t *p1, const fastf_t *d1, const fastf_t *p2, const fastf_t *d2, double range, const struct bn_tol *tol)
{
	fastf_t		mag1;
	fastf_t		mag2;
	point_t		tail;

	BN_CK_TOL(tol);

	if( (mag1 = MAGNITUDE(d1)) < SMALL_FASTF )  bu_bomb("bn_2line3_colinear() mag1 zero\n");
	if( (mag2 = MAGNITUDE(d2)) < SMALL_FASTF )  bu_bomb("bn_2line3_colinear() mag2 zero\n");

	/* Impose a general angular tolerance to reject "obviously" non-parallel lines */
	/* tol->para and RT_DOT_TOL are too tight a tolerance.  0.1 is 5 degrees */
	if( fabs(VDOT(d1, d2)) < 0.9 * mag1 * mag2  )  goto fail;

	/* See if start points are within tolerance of other line */
	if( bn_distsq_line3_pt3( p1, d1, p2 ) > tol->dist_sq )  goto fail;
	if( bn_distsq_line3_pt3( p2, d2, p1 ) > tol->dist_sq )  goto fail;

	VJOIN1( tail, p1, range/mag1, d1 );
	if( bn_distsq_line3_pt3( p2, d2, tail ) > tol->dist_sq )  goto fail;

	VJOIN1( tail, p2, range/mag2, d2 );
	if( bn_distsq_line3_pt3( p1, d1, tail ) > tol->dist_sq )  goto fail;

	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_2line3colinear(range=%g) ret=1\n",range);
	}
	return 1;
fail:
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_2line3colinear(range=%g) ret=0\n",range);
	}
	return 0;
}

/*
 *			B N _ I S E C T _ L I N E 3 _ P L A N E
 *
 *  Intersect an infinite line (specified in point and direction vector form)
 *  with a plane that has an outward pointing normal.
 *  The direction vector need not have unit length.
 *  The first three elements of the plane equation must form a unit lengh vector.
 *
 *  Explicit Return -
 *	-2	missed (ray is outside halfspace)
 *	-1	missed (ray is inside)
 *	 0	line lies on plane
 *	 1	hit (ray is entering halfspace)
 *	 2	hit (ray is leaving)
 *
 *  Implicit Return -
 *	The value at *dist is set to the parametric distance of the intercept
 */
int
bn_isect_line3_plane(fastf_t *dist, const fastf_t *pt, const fastf_t *dir, const fastf_t *plane, const struct bn_tol *tol)
{
	register fastf_t	slant_factor;
	register fastf_t	norm_dist;
	register fastf_t	dot;
	vect_t			local_dir;

	BN_CK_TOL(tol);

	norm_dist = plane[3] - VDOT( plane, pt );
	slant_factor = VDOT( plane, dir );
	VMOVE( local_dir, dir )
	VUNITIZE( local_dir )
	dot = VDOT( plane, local_dir );

	if( slant_factor < -SMALL_FASTF && dot < -tol->perp  )  {
		*dist = norm_dist/slant_factor;
		return 1;			/* HIT, entering */
	} else if( slant_factor > SMALL_FASTF && dot > tol->perp )  {
		*dist = norm_dist/slant_factor;
		return 2;			/* HIT, leaving */
	}

	/*
	 *  Ray is parallel to plane when dir.N == 0.
	 */
	*dist = 0;		/* sanity */
	if( norm_dist < -tol->dist )
		return -2;	/* missed, outside */
	if( norm_dist > tol->dist )
		return -1;	/* missed, inside */
	return 0;		/* Ray lies in the plane */
}

/*
 *			B N _ I S E C T _ 2 P L A N E S
 *
 *  Given two planes, find the line of intersection between them,
 *  if one exists.
 *  The line of intersection is returned in parametric line
 *  (point & direction vector) form.
 *
 *  In order that all the geometry under consideration be in "front"
 *  of the ray, it is necessary to pass the minimum point of the model
 *  RPP.  If this convention is unnecessary, just pass (0,0,0) as rpp_min.
 *
 *  Explicit Return -
 *	 0	OK, line of intersection stored in `pt' and `dir'.
 *	-1	FAIL, planes are identical (co-planar)
 *	-2	FAIL, planes are parallel and distinct
 *	-3	FAIL, unable to find line of intersection
 *
 *  Implicit Returns -
 *	pt	Starting point of line of intersection
 *	dir	Direction vector of line of intersection (unit length)
 */
int
bn_isect_2planes(fastf_t *pt, fastf_t *dir, const fastf_t *a, const fastf_t *b, const fastf_t *rpp_min, const struct bn_tol *tol)
{
	LOCAL vect_t		abs_dir;
	LOCAL plane_t		pl;
	int			i;

	if( (i = bn_coplanar( a, b, tol )) != 0 )  {
		if( i > 0 )
			return(-1);	/* FAIL -- coplanar */
		return(-2);		/* FAIL -- parallel & distinct */
	}

	/* Direction vector for ray is perpendicular to both plane normals */
	VCROSS( dir, a, b );
	VUNITIZE( dir );		/* safety */

	/*
	 *  Select an axis-aligned plane which has it's normal pointing
	 *  along the same axis as the largest magnitude component of
	 *  the direction vector.
	 *  If the largest magnitude component is negative, reverse the
	 *  direction vector, so that model is "in front" of start point.
	 */
	abs_dir[X] = (dir[X] >= 0) ? dir[X] : (-dir[X]);
	abs_dir[Y] = (dir[Y] >= 0) ? dir[Y] : (-dir[Y]);
	abs_dir[Z] = (dir[Z] >= 0) ? dir[Z] : (-dir[Z]);

	if( abs_dir[X] >= abs_dir[Y] )  {
		if( abs_dir[X] >= abs_dir[Z] )  {
			VSET( pl, 1, 0, 0 );	/* X */
			pl[3] = rpp_min[X];
			if( dir[X] < 0 )  {
				VREVERSE( dir, dir );
			}
		} else {
			VSET( pl, 0, 0, 1 );	/* Z */
			pl[3] = rpp_min[Z];
			if( dir[Z] < 0 )  {
				VREVERSE( dir, dir );
			}
		}
	} else {
		if( abs_dir[Y] >= abs_dir[Z] )  {
			VSET( pl, 0, 1, 0 );	/* Y */
			pl[3] = rpp_min[Y];
			if( dir[Y] < 0 )  {
				VREVERSE( dir, dir );
			}
		} else {
			VSET( pl, 0, 0, 1 );	/* Z */
			pl[3] = rpp_min[Z];
			if( dir[Z] < 0 )  {
				VREVERSE( dir, dir );
			}
		}
	}

	/* Intersection of the 3 planes defines ray start point */
	if( bn_mkpoint_3planes( pt, pl, a, b ) < 0 )
		return(-3);	/* FAIL -- no intersection */

	return(0);		/* OK */
}

/*
 *			B N _ I S E C T _ L I N E 2 _ L I N E 2
 *
 *  Intersect two lines, each in given in parametric form:
 *
 *	X = P + t * D
 *  and
 *	X = A + u * C
 *
 *  While the parametric form is usually used to denote a ray
 *  (ie, positive values of the parameter only), in this case
 *  the full line is considered.
 *
 *  The direction vectors C and D need not have unit length.
 *
 *  Explicit Return -
 *	-1	no intersection, lines are parallel.
 *	 0	lines are co-linear
 *			dist[0] gives distance from P to A,
 *			dist[1] gives distance from P to (A+C) [not same as below]
 *	 1	intersection found (t and u returned)
 *			dist[0] gives distance from P to isect,
 *			dist[1] gives distance from A to isect.
 *
 *  Implicit Returns -
 *	When explicit return > 0, dist[0] and dist[1] are the
 *	line parameters of the intersection point on the 2 rays.
 *	The actual intersection coordinates can be found by
 *	substituting either of these into the original ray equations.
 *
 *  Note that for lines which are very nearly parallel, but not
 *  quite parallel enough to have the determinant go to "zero",
 *  the intersection can turn up in surprising places.
 *  (e.g. when det=1e-15 and det1=5.5e-17, t=0.5)
 */
int
bn_isect_line2_line2(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
       			      			/* dist[2] */
             		  
            		  
             		  
            		  
                   	     
{
	fastf_t			hx, hy;		/* A - P */
	register fastf_t	det;
	register fastf_t	det1;
	vect_t			unit_d;
	vect_t			unit_c;
	vect_t			unit_h;
	int			parallel;
	int			parallel1;

	BN_CK_TOL(tol);
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_isect_line2_line2() p=(%g,%g), d=(%g,%g)\n\t\t\ta=(%g,%g), c=(%g,%g)\n",
			V2ARGS(p), V2ARGS(d), V2ARGS(a), V2ARGS(c) );
	}

	/*
	 *  From the two components q and r, form a system
	 *  of 2 equations in 2 unknowns.
	 *  Solve for t and u in the system:
	 *
	 *	Px + t * Dx = Ax + u * Cx
	 *	Py + t * Dy = Ay + u * Cy
	 *  or
	 *	t * Dx - u * Cx = Ax - Px
	 *	t * Dy - u * Cy = Ay - Py
	 *
	 *  Let H = A - P, resulting in:
	 *
	 *	t * Dx - u * Cx = Hx
	 *	t * Dy - u * Cy = Hy
	 *
	 *  or
	 *
	 *	[ Dx  -Cx ]   [ t ]   [ Hx ]
	 *	[         ] * [   ] = [    ]
	 *	[ Dy  -Cy ]   [ u ]   [ Hy ]
	 *
	 *  This system can be solved by direct substitution, or by
	 *  finding the determinants by Cramers rule:
	 *
	 *	             [ Dx  -Cx ]
	 *	det(M) = det [         ] = -Dx * Cy + Cx * Dy
	 *	             [ Dy  -Cy ]
	 *
	 *  If det(M) is zero, then the lines are parallel (perhaps colinear).
	 *  Otherwise, exactly one solution exists.
	 */
	det = c[X] * d[Y] - d[X] * c[Y];

	/*
	 *  det(M) is non-zero, so there is exactly one solution.
	 *  Using Cramer's rule, det1(M) replaces the first column
	 *  of M with the constant column vector, in this case H.
	 *  Similarly, det2(M) replaces the second column.
	 *  Computation of the determinant is done as before.
	 *
	 *  Now,
	 *
	 *	                  [ Hx  -Cx ]
	 *	              det [         ]
	 *	    det1(M)       [ Hy  -Cy ]   -Hx * Cy + Cx * Hy
	 *	t = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 *
	 *  and
	 *
	 *	                  [ Dx   Hx ]
	 *	              det [         ]
	 *	    det2(M)       [ Dy   Hy ]    Dx * Hy - Hx * Dy
	 *	u = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 */
	hx = a[X] - p[X];
	hy = a[Y] - p[Y];
	det1 = (c[X] * hy - hx * c[Y]);

	unit_d[0] = d[0];
	unit_d[1] = d[1];
	unit_d[2] = 0.0;
	VUNITIZE( unit_d );
	unit_c[0] = c[0];
	unit_c[1] = c[1];
	unit_c[2] = 0.0;
	VUNITIZE( unit_c );
	unit_h[0] = hx;
	unit_h[1] = hy;
	unit_h[2] = 0.0;
	VUNITIZE( unit_h );

	if( fabs( VDOT( unit_d, unit_c ) ) >= tol->para )
		parallel = 1;
	else
		parallel = 0;

	if( fabs( VDOT( unit_h, unit_c ) ) >= tol->para )
		parallel1 = 1;
	else
		parallel1 = 0;

	/* XXX This zero tolerance here should actually be
	 * XXX determined by something like
	 * XXX max(c[X], c[Y], d[X], d[Y]) / MAX_FASTF_DYNAMIC_RANGE
	 * XXX In any case, nothing smaller than 1e-16
	 */
#define DETERMINANT_TOL		1.0e-14		/* XXX caution on non-IEEE machines */
	if( parallel || NEAR_ZERO( det, DETERMINANT_TOL ) )  {
		/* Lines are parallel */
		if( !parallel1 && !NEAR_ZERO( det1, DETERMINANT_TOL ) )  {
			/* Lines are NOT co-linear, just parallel */
			if( bu_debug & BU_DEBUG_MATH )  {
				bu_log("\tparallel, not co-linear.  det=%e, det1=%g\n", det, det1);
			}
			return -1;	/* parallel, no intersection */
		}

		/*
		 *  Lines are co-linear.
		 *  Determine t as distance from P to A.
		 *  Determine u as distance from P to (A+C).  [special!]
		 *  Use largest direction component, for numeric stability
		 *  (and avoiding division by zero).
		 */
		if( fabs(d[X]) >= fabs(d[Y]) )  {
			dist[0] = hx/d[X];
			dist[1] = (hx + c[X]) / d[X];
		} else {
			dist[0] = hy/d[Y];
			dist[1] = (hy + c[Y]) / d[Y];
		}
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("\tcolinear, t = %g, u = %g\n", dist[0], dist[1] );
		}
		return 0;	/* Lines co-linear */
	}
	if( bu_debug & BU_DEBUG_MATH )  {
		/* XXX This print is temporary */
bu_log("\thx=%g, hy=%g, det=%g, det1=%g, det2=%g\n", hx, hy, det, det1, (d[X] * hy - hx * d[Y]) );
	}
	det = 1/det;
	dist[0] = det * det1;
	dist[1] = det * (d[X] * hy - hx * d[Y]);
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("\tintersection, t = %g, u = %g\n", dist[0], dist[1] );
	}

#if 0
	/* XXX This isn't any good.
	 * 1)  Sometimes, dist[0] is very large.  Only caller can tell whether
	 *     that is useful to him or not.
	 * 2)  Sometimes, the difference between the two hit points is
	 *     not much more than tol->dist.  Either hit point is perfectly
	 *     good;  the caller just needs to be careful and not use *both*.
	 */
	{
		point_t		hit1, hit2;
		vect_t		diff;
		fastf_t		dist_sq;

		VJOIN1_2D( hit1, p, dist[0], d );
		VJOIN1_2D( hit2, a, dist[1], c );
		VSUB2_2D( diff, hit1, hit2 );
		dist_sq = MAGSQ_2D( diff );
		if( dist_sq >= tol->dist_sq )  {
			if( bu_debug & BU_DEBUG_MATH || dist_sq < 100*tol->dist_sq )  {
				bu_log("bn_isect_line2_line2(): dist=%g >%g, inconsistent solution, hit1=(%g,%g), hit2=(%g,%g)\n",
					sqrt(dist_sq), tol->dist,
					hit1[X], hit1[Y], hit2[X], hit2[Y]);
			}
			return -2;	/* s/b -1? */
		}
	}
#endif

	return 1;		/* Intersection found */
}

/*
 *			B N _ I S E C T _ L I N E 2 _ L S E G 2
 *
 *  Intersect a line in parametric form:
 *
 *	X = P + t * D
 *
 *  with a line segment defined by two distinct points A and B=(A+C).
 *
 *  XXX probably should take point B, not vector C.  Sigh.
 *
 *  Explicit Return -
 *	-4	A and B are not distinct points
 *	-3	Lines do not intersect
 *	-2	Intersection exists, but outside segemnt, < A
 *	-1	Intersection exists, but outside segment, > B
 *	 0	Lines are co-linear (special meaning of dist[1])
 *	 1	Intersection at vertex A
 *	 2	Intersection at vertex B (A+C)
 *	 3	Intersection between A and B
 *
 *  Implicit Returns -
 *	t	When explicit return >= 0, t is the parameter that describes
 *		the intersection of the line and the line segment.
 *		The actual intersection coordinates can be found by
 *		solving P + t * D.  However, note that for return codes
 *		1 and 2 (intersection exactly at a vertex), it is
 *		strongly recommended that the original values passed in
 *		A or B are used instead of solving P + t * D, to prevent
 *		numeric error from creeping into the position of
 *		the endpoints.
 */
int
bn_isect_line2_lseg2(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
       			      		/* dist[2] */
             		  
            		  
             		  
            		  
                   	     
{
	register fastf_t f;
	fastf_t		ctol;
	int		ret;
	point_t		b;

	BN_CK_TOL(tol);
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_isect_line2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\t\ta=(%g,%g), adir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(d), V2ARGS(a), V2ARGS(c) );
	}

	/*
	 *  To keep the values of u between 0 and 1,
	 *  C should NOT be scaled to have unit length.
	 *  However, it is a good idea to make sure that
	 *  C is a non-zero vector, (ie, that A and B are distinct).
	 */
	if( (ctol = MAGSQ_2D(c)) <= tol->dist_sq )  {
		ret = -4;		/* points A and B are not distinct */
		goto out;
	}

	/*
	 *  Detecting colinearity is difficult, and very very important.
	 *  As a first step, check to see if both points A and B lie
	 *  within tolerance of the line.  If so, then the line segment AC
	 *  is ON the line.
	 */
	VADD2_2D( b, a, c );
	if( bn_distsq_line2_point2( p, d, a ) <= tol->dist_sq  &&
	    (ctol=bn_distsq_line2_point2( p, d, b )) <= tol->dist_sq )  {
		if( bu_debug & BU_DEBUG_MATH )  {
bu_log("b=(%g, %g), b_dist_sq=%g\n", V2ARGS(b), ctol);
			bu_log("bn_isect_line2_lseg2() pts A and B within tol of line\n");
		}
	    	/* Find the parametric distance along the ray */
	    	dist[0] = bn_dist_pt2_along_line2( p, d, a );
	    	dist[1] = bn_dist_pt2_along_line2( p, d, b );
	    	ret = 0;		/* Colinear */
	    	goto out;
	}

	if( (ret = bn_isect_line2_line2( dist, p, d, a, c, tol )) < 0 )  {
		/* Lines are parallel, non-colinear */
		ret = -3;		/* No intersection found */
		goto out;
	}
	if( ret == 0 )  {
		fastf_t	dtol;
		/*  Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		dtol = tol->dist / sqrt(MAGSQ_2D(d));
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("bn_isect_line2_lseg2() dtol=%g, dist[0]=%g, dist[1]=%g\n",
				dtol, dist[0], dist[1]);
		}
		if( dist[0] > -dtol && dist[0] < dtol )  dist[0] = 0;
		else if( dist[0] > 1-dtol && dist[0] < 1+dtol ) dist[0] = 1;

		if( dist[1] > -dtol && dist[1] < dtol )  dist[1] = 0;
		else if( dist[1] > 1-dtol && dist[1] < 1+dtol ) dist[1] = 1;
		ret = 0;		/* Colinear */
		goto out;
	}

	/*
	 *  The two lines are claimed to intersect at a point.
	 *  First, validate that hit point represented by dist[0]
	 *  is in fact on and between A--B.
	 *  (Nearly parallel lines can result in odd situations here).
	 *  The performance hit of doing this is vastly preferable
	 *  to returning wrong answers.  Know a faster algorithm?
	 */
	{
		fastf_t		ab_dist = 0;
		point_t		hit_pt;
		point_t		hit2;

		VJOIN1_2D( hit_pt, p, dist[0], d );
		VJOIN1_2D( hit2, a, dist[1], c );
		/* Check both hit point value calculations */
		if( bn_pt2_pt2_equal( a, hit_pt, tol ) ||
		    bn_pt2_pt2_equal( a, hit2, tol ) )  {
			dist[1] = 0;
			ret = 1;	/* Intersect is at A */
		}
		if( bn_pt2_pt2_equal( b, hit_pt, tol ) ||
		    bn_pt2_pt2_equal( b, hit_pt, tol ) )  {
			dist[1] = 1;
			ret = 2;	/* Intersect is at B */
		}

		ret = bn_isect_pt2_lseg2( &ab_dist, a, b, hit_pt, tol );
		if( bu_debug & BU_DEBUG_MATH )  {
			/* XXX This is temporary */
			V2PRINT("a", a);
			V2PRINT("hit", hit_pt);
			V2PRINT("b", b);
bu_log("bn_isect_pt2_lseg2() hit2d=(%g,%g) ab_dist=%g, ret=%d\n", hit_pt[X], hit_pt[Y], ab_dist, ret);
bu_log("\tother hit2d=(%g,%g)\n", hit2[X], hit2[Y] );
		}
		if( ret <= 0 )  {
			if( ab_dist < 0 )  {
				ret = -2;	/* Intersection < A */
			} else {
				ret = -1;	/* Intersection >B */
			}
			goto out;
		}
		if( ret == 1 )  {
			dist[1] = 0;
			ret = 1;	/* Intersect is at A */
			goto out;
		}
		if( ret == 2 )  {
			dist[1] = 1;
			ret = 2;	/* Intersect is at B */
			goto out;
		}
		/* ret == 3, hit_pt is between A and B */

		if( !bn_between( a[X], hit_pt[X], b[X], tol ) ||
		    !bn_between( a[Y], hit_pt[Y], b[Y], tol ) ) {
		    	bu_bomb("bn_isect_line2_lseg2() hit_pt not between A and B!\n");
		}
	}

	/*
	 *  If the dist[1] parameter is outside the range (0..1),
	 *  reject the intersection, because it falls outside
	 *  the line segment A--B.
	 *
	 *  Convert the tol->dist into allowable deviation in terms of
	 *  (0..1) range of the parameters.
	 */
	ctol = tol->dist / sqrt(ctol);
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_isect_line2_lseg2() ctol=%g, dist[1]=%g\n", ctol, dist[1]);
	}
	if( dist[1] < -ctol )  {
		ret = -2;		/* Intersection < A */
		goto out;
	}
	if( (f=(dist[1]-1)) > ctol )  {
		ret = -1;		/* Intersection > B */
		goto out;
	}

	/* Check for ctoly intersection with one of the verticies */
	if( dist[1] < ctol )  {
		dist[1] = 0;
		ret = 1;		/* Intersection at A */
		goto out;
	}
	if( f >= -ctol )  {
		dist[1] = 1;
		ret = 2;		/* Intersection at B */
		goto out;
	}
	ret = 3;			/* Intersection between A and B */
out:
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_isect_line2_lseg2() dist[0]=%g, dist[1]=%g, ret=%d\n",
			dist[0], dist[1], ret);
	}
	return ret;
}

/*
 *			B N _ I S E C T _ L S E G 2  _ L S E G 2
 *
 *  Intersect two 2D line segments, defined by two points and two vectors.
 *  The vectors are unlikely to be unit length.
 *
 *  Explicit Return -
 *	-2	missed (line segments are parallel)
 *	-1	missed (colinear and non-overlapping)
 *	 0	hit (line segments colinear and overlapping)
 *	 1	hit (normal intersection)
 *
 *  Implicit Return -
 *	The value at dist[] is set to the parametric distance of the intercept
 *	dist[0] is parameter along p, range 0 to 1, to intercept.
 *	dist[1] is parameter along q, range 0 to 1, to intercept.
 *	If within distance tolerance of the endpoints, these will be
 *	exactly 0.0 or 1.0, to ease the job of caller.
 *
 *  Special note:  when return code is "0" for co-linearity, dist[1] has
 *  an alternate interpretation:  it's the parameter along p (not q)
 *  which takes you from point p to the point (q + qdir), i.e., it's
 *  the endpoint of the q linesegment, since in this case there may be
 *  *two* intersections, if q is contained within span p to (p + pdir).
 *  And either may be -10 if the point is outside the span.
 */
int
bn_isect_lseg2_lseg2(fastf_t *dist, const fastf_t *p, const fastf_t *pdir, const fastf_t *q, const fastf_t *qdir, const struct bn_tol *tol)
{
	fastf_t	ptol, qtol;	/* length in parameter space == tol->dist */
	int	status;

	BN_CK_TOL(tol);
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_isect_lseg2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(pdir), V2ARGS(q), V2ARGS(qdir) );
	}

	status = bn_isect_line2_line2( dist, p, pdir, q, qdir, tol );
	if( status < 0 )  {
		/* Lines are parallel, non-colinear */
		return -1;	/* No intersection */
	}
	if( status == 0 )  {
		int	nogood = 0;
		/* Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		ptol = tol->dist / sqrt( MAGSQ_2D(pdir) );
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("ptol=%g\n", ptol);
		}
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;

		if( dist[1] < 0 || dist[1] > 1 )  nogood = 1;
		if( dist[0] < 0 || dist[0] > 1 )  nogood++;
		if( nogood >= 2 )
			return -1;	/* colinear, but not overlapping */
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("  HIT colinear!\n");
		}
		return 0;		/* colinear and overlapping */
	}
	/* Lines intersect */
	/*  If within tolerance of an endpoint (0, 1), make exact. */
	ptol = tol->dist / sqrt( MAGSQ_2D(pdir) );
	if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
	else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

	qtol = tol->dist / sqrt( MAGSQ_2D(qdir) );
	if( dist[1] > -qtol && dist[1] < qtol )  dist[1] = 0;
	else if( dist[1] > 1-qtol && dist[1] < 1+qtol ) dist[1] = 1;

	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("ptol=%g, qtol=%g\n", ptol, qtol);
	}
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 ) {
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("  MISS\n");
		}
		return -1;		/* missed */
	}
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("  HIT!\n");
	}
	return 1;			/* hit, normal intersection */
}

/*
 *			B N _ I S E C T _ L S E G 3  _ L S E G 3
 *
 *  Intersect two 3D line segments, defined by two points and two vectors.
 *  The vectors are unlikely to be unit length.
 *
 *  Explicit Return -
 *	-2	missed (line segments are parallel)
 *	-1	missed (colinear and non-overlapping)
 *	 0	hit (line segments colinear and overlapping)
 *	 1	hit (normal intersection)
 *
 *  Implicit Return -
 *	The value at dist[] is set to the parametric distance of the intercept
 *	dist[0] is parameter along p, range 0 to 1, to intercept.
 *	dist[1] is parameter along q, range 0 to 1, to intercept.
 *	If within distance tolerance of the endpoints, these will be
 *	exactly 0.0 or 1.0, to ease the job of caller.
 *
 *  Special note:  when return code is "0" for co-linearity, dist[1] has
 *  an alternate interpretation:  it's the parameter along p (not q)
 *  which takes you from point p to the point (q + qdir), i.e., it's
 *  the endpoint of the q linesegment, since in this case there may be
 *  *two* intersections, if q is contained within span p to (p + pdir).
 *  And either may be -10 if the point is outside the span.
 */
int
bn_isect_lseg3_lseg3(fastf_t *dist, const fastf_t *p, const fastf_t *pdir, const fastf_t *q, const fastf_t *qdir, const struct bn_tol *tol)
{
	fastf_t	ptol, qtol;	/* length in parameter space == tol->dist */
	fastf_t	pmag, qmag;
	int	status;

	BN_CK_TOL(tol);
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_isect_lseg3_lseg3() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(pdir), V2ARGS(q), V2ARGS(qdir) );
	}

	status = bn_isect_line3_line3( &dist[0], &dist[1], p, pdir, q, qdir, tol );
	if( status < 0 )  {
		/* Lines are parallel, non-colinear */
		return -1;	/* No intersection */
	}
	pmag = MAGNITUDE(pdir);
	if( pmag < SMALL_FASTF )
		bu_bomb("bn_isect_lseg3_lseg3: |p|=0\n");
	if( status == 0 )  {
		int	nogood = 0;
		/* Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		ptol = tol->dist / pmag;
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("ptol=%g\n", ptol);
		}
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;

		if( dist[1] < 0 || dist[1] > 1 )  nogood = 1;
		if( dist[0] < 0 || dist[0] > 1 )  nogood++;
		if( nogood >= 2 )
			return -1;	/* colinear, but not overlapping */
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("  HIT colinear!\n");
		}
		return 0;		/* colinear and overlapping */
	}
	/* Lines intersect */
	/*  If within tolerance of an endpoint (0, 1), make exact. */
	ptol = tol->dist / pmag;
	if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
	else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

	qmag = MAGNITUDE(qdir);
	if( qmag < SMALL_FASTF )
		bu_bomb("bn_isect_lseg3_lseg3: |q|=0\n");
	qtol = tol->dist / qmag;
	if( dist[1] > -qtol && dist[1] < qtol )  dist[1] = 0;
	else if( dist[1] > 1-qtol && dist[1] < 1+qtol ) dist[1] = 1;

	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("ptol=%g, qtol=%g\n", ptol, qtol);
	}
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 ) {
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("  MISS\n");
		}
		return -1;		/* missed */
	}
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("  HIT!\n");
	}
	return 1;			/* hit, normal intersection */
}

/*
 *			B N _ I S E C T _ L I N E 3 _ L I N E 3
 *
 *  Intersect two lines, each in given in parametric form:
 *
 *	X = P + t * D
 *  and
 *	X = A + u * C
 *
 *  While the parametric form is usually used to denote a ray
 *  (ie, positive values of the parameter only), in this case
 *  the full line is considered.
 *
 *  The direction vectors C and D need not have unit length.
 *
 *  Explicit Return -
 *	-2	no intersection, lines are parallel.
 *	-1	no intersection
 *	 0	lines are co-linear (t returned for u=0 to give distance to A)
 *	 1	intersection found (t and u returned)
 *
 *  Implicit Returns -
 *
 *	t,u	When explicit return >= 0, t and u are the
 *		line parameters of the intersection point on the 2 rays.
 *		The actual intersection coordinates can be found by
 *		substituting either of these into the original ray equations.
 *
 * XXX It would be sensible to change the t,u pair to dist[2].
 */
int
bn_isect_line3_line3(fastf_t *t, fastf_t *u, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
{
	LOCAL vect_t		n;
	LOCAL vect_t		abs_n;
	LOCAL vect_t		h;
	register fastf_t	det;
	register fastf_t	det1;
	register short int	q,r,s;

	BN_CK_TOL(tol);

	/*
	 *  Any intersection will occur in the plane with surface
	 *  normal D cross C, which may not have unit length.
	 *  The plane containing the two lines will be a constant
	 *  distance from a plane with the same normal that contains
	 *  the origin.  Therfore, the projection of any point on the
	 *  plane along N has the same length.
	 *  Verify that this holds for P and A.
	 *  If N dot P != N dot A, there is no intersection, because
	 *  P and A must lie on parallel planes that are different
	 *  distances from the origin.
	 */
	VCROSS( n, d, c );
	det = VDOT( n, p ) - VDOT( n, a );
	if( !NEAR_ZERO( det, tol->dist ) )  {
		return(-1);		/* No intersection */
	}

	if( NEAR_ZERO( MAGSQ( n ) , SMALL_FASTF ) )
	{
		vect_t a_to_p;

		/* lines are parallel, must find another way to get normal vector */
		VSUB2( a_to_p , p , a );
		VCROSS( n , a_to_p , d );

		if( NEAR_ZERO( MAGSQ( n ) , SMALL_FASTF ) )
			bn_vec_ortho( n, d );
	}

	/*
	 *  Solve for t and u in the system:
	 *
	 *	Px + t * Dx = Ax + u * Cx
	 *	Py + t * Dy = Ay + u * Cy
	 *	Pz + t * Dz = Az + u * Cz
	 *
	 *  This system is over-determined, having 3 equations in 2 unknowns.
	 *  However, the intersection problem is really only a 2-dimensional
	 *  problem, being located in the surface of a plane.
	 *  Therefore, the "least important" of these equations can
	 *  be initially ignored, leaving a system of 2 equations in
	 *  2 unknowns.
	 *
	 *  Find the component of N with the largest magnitude.
	 *  This component will have the least effect on the parameters
	 *  in the system, being most nearly perpendicular to the plane.
	 *  Denote the two remaining components by the
	 *  subscripts q and r, rather than x,y,z.
	 *  Subscript s is the smallest component, used for checking later.
	 */
	abs_n[X] = (n[X] >= 0) ? n[X] : (-n[X]);
	abs_n[Y] = (n[Y] >= 0) ? n[Y] : (-n[Y]);
	abs_n[Z] = (n[Z] >= 0) ? n[Z] : (-n[Z]);
	if( abs_n[X] >= abs_n[Y] )  {
		if( abs_n[X] >= abs_n[Z] )  {
			/* X is largest in magnitude */
			q = Y;
			r = Z;
			s = X;
		} else {
			/* Z is largest in magnitude */
			q = X;
			r = Y;
			s = Z;
		}
	} else {
		if( abs_n[Y] >= abs_n[Z] )  {
			/* Y is largest in magnitude */
			q = X;
			r = Z;
			s = Y;
		} else {
			/* Z is largest in magnitude */
			q = X;
			r = Y;
			s = Z;
		}
	}

#if 0
	/* XXX Use bn_isect_line2_line2() here */
	/* move the 2d vectors around */
	bn_isect_line2_line2( &dist, p, d, a, c, tol );
#endif

	/*
	 *  From the two components q and r, form a system
	 *  of 2 equations in 2 unknowns:
	 *
	 *	Pq + t * Dq = Aq + u * Cq
	 *	Pr + t * Dr = Ar + u * Cr
	 *  or
	 *	t * Dq - u * Cq = Aq - Pq
	 *	t * Dr - u * Cr = Ar - Pr
	 *
	 *  Let H = A - P, resulting in:
	 *
	 *	t * Dq - u * Cq = Hq
	 *	t * Dr - u * Cr = Hr
	 *
	 *  or
	 *
	 *	[ Dq  -Cq ]   [ t ]   [ Hq ]
	 *	[         ] * [   ] = [    ]
	 *	[ Dr  -Cr ]   [ u ]   [ Hr ]
	 *
	 *  This system can be solved by direct substitution, or by
	 *  finding the determinants by Cramers rule:
	 *
	 *	             [ Dq  -Cq ]
	 *	det(M) = det [         ] = -Dq * Cr + Cq * Dr
	 *	             [ Dr  -Cr ]
	 *
	 *  If det(M) is zero, then the lines are parallel (perhaps colinear).
	 *  Otherwise, exactly one solution exists.
	 */
	VSUB2( h, a, p );
	det = c[q] * d[r] - d[q] * c[r];
	det1 = (c[q] * h[r] - h[q] * c[r]);		/* see below */
	/* XXX This should be no smaller than 1e-16.  See bn_isect_line2_line2 for details */
	if( NEAR_ZERO( det, DETERMINANT_TOL ) )  {
		/* Lines are parallel */
		if( !NEAR_ZERO( det1, DETERMINANT_TOL ) )  {
			/* Lines are NOT co-linear, just parallel */
			return -2;	/* parallel, no intersection */
		}

		/* Lines are co-linear */
		/* Compute t for u=0 as a convenience to caller */
		*u = 0;
		/* Use largest direction component */
		if( fabs(d[q]) >= fabs(d[r]) )  {
			*t = h[q]/d[q];
		} else {
			*t = h[r]/d[r];
		}
		return(0);	/* Lines co-linear */
	}

	/*
	 *  det(M) is non-zero, so there is exactly one solution.
	 *  Using Cramer's rule, det1(M) replaces the first column
	 *  of M with the constant column vector, in this case H.
	 *  Similarly, det2(M) replaces the second column.
	 *  Computation of the determinant is done as before.
	 *
	 *  Now,
	 *
	 *	                  [ Hq  -Cq ]
	 *	              det [         ]
	 *	    det1(M)       [ Hr  -Cr ]   -Hq * Cr + Cq * Hr
	 *	t = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dq * Cr + Cq * Dr
	 *
	 *  and
	 *
	 *	                  [ Dq   Hq ]
	 *	              det [         ]
	 *	    det2(M)       [ Dr   Hr ]    Dq * Hr - Hq * Dr
	 *	u = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dq * Cr + Cq * Dr
	 */
	det = 1/det;
	*t = det * det1;
	*u = det * (d[q] * h[r] - h[q] * d[r]);

	/*
	 *  Check that these values of t and u satisfy the 3rd equation
	 *  as well!
	 *  XXX It isn't clear that "det" is exactly a model-space distance.
	 */
	det = *t * d[s] - *u * c[s] - h[s];
	if( !NEAR_ZERO( det, tol->dist ) )  {
		/* XXX This tolerance needs to be much less loose than
		 * XXX SQRT_SMALL_FASTF.  What about DETERMINANT_TOL?
		 */
		/* Inconsistent solution, lines miss each other */
		return(-1);
	}

	/*  To prevent errors, check the answer.
	 *  Not returning bogus results to our caller is worth the extra time.
	 */
	{
		point_t		hit1, hit2;

		VJOIN1( hit1, p, *t, d );
		VJOIN1( hit2, a, *u, c );
		if( !bn_pt3_pt3_equal( hit1, hit2, tol ) )  {
/*			bu_log("bn_isect_line3_line3(): BOGUS RESULT, hit1=(%g,%g,%g), hit2=(%g,%g,%g)\n",
				hit1[X], hit1[Y], hit1[Z], hit2[X], hit2[Y], hit2[Z]); */
			return -1;
		}
	}

	return(1);		/* Intersection found */
}

/*
 *			B N _ I S E C T _ L I N E _ L S E G
 *
 *  Intersect a line in parametric form:
 *
 *	X = P + t * D
 *
 *  with a line segment defined by two distinct points A and B.
 *
 *  Explicit Return -
 *	-4	A and B are not distinct points
 *	-3	Intersection exists, < A (t is returned)
 *	-2	Intersection exists, > B (t is returned)
 *	-1	Lines do not intersect
 *	 0	Lines are co-linear (t for A is returned)
 *	 1	Intersection at vertex A
 *	 2	Intersection at vertex B
 *	 3	Intersection between A and B
 *
 *  Implicit Returns -
 *	t	When explicit return >= 0, t is the parameter that describes
 *		the intersection of the line and the line segment.
 *		The actual intersection coordinates can be found by
 *		solving P + t * D.  However, note that for return codes
 *		1 and 2 (intersection exactly at a vertex), it is
 *		strongly recommended that the original values passed in
 *		A or B are used instead of solving P + t * D, to prevent
 *		numeric error from creeping into the position of
 *		the endpoints.
 */
/* XXX should probably be called bn_isect_line3_lseg3() */
/* XXX should probably be changed to return dist[2] */
int
bn_isect_line_lseg(fastf_t *t, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
{
	LOCAL vect_t	c;		/* Direction vector from A to B */
	auto fastf_t	u;		/* As in, A + u * C = X */
	register fastf_t f;
	register int	ret;
	fastf_t		fuzz;

	BN_CK_TOL(tol);

	VSUB2( c, b, a );
	/*
	 *  To keep the values of u between 0 and 1,
	 *  C should NOT be scaled to have unit length.
	 *  However, it is a good idea to make sure that
	 *  C is a non-zero vector, (ie, that A and B are distinct).
	 */
	if( (fuzz = MAGSQ(c)) < tol->dist_sq )  {
		return(-4);		/* points A and B are not distinct */
	}

	/*
	 *  Detecting colinearity is difficult, and very very important.
	 *  As a first step, check to see if both points A and B lie
	 *  within tolerance of the line.  If so, then the line segment AC
	 *  is ON the line.
	 */
	if( bn_distsq_line3_pt3( p, d, a ) <= tol->dist_sq  &&
	    bn_distsq_line3_pt3( p, d, b ) <= tol->dist_sq )  {
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("bn_isect_line3_lseg3() pts A and B within tol of line\n");
		}
	    	/* Find the parametric distance along the ray */
		*t = bn_dist_pt3_along_line3( p, d, a );
		/*** dist[1] = bn_dist_pt3_along_line3( p, d, b ); ***/
		return 0;		/* Colinear */
	}

	if( (ret = bn_isect_line3_line3( t, &u, p, d, a, c, tol )) < 0 )  {
		/* No intersection found */
		return( -1 );
	}
	if( ret == 0 )  {
		/* co-linear (t was computed for point A, u=0) */
		return( 0 );
	}

	/*
	 *  The two lines intersect at a point.
	 *  If the u parameter is outside the range (0..1),
	 *  reject the intersection, because it falls outside
	 *  the line segment A--B.
	 *
	 *  Convert the tol->dist into allowable deviation in terms of
	 *  (0..1) range of the parameters.
	 */
	fuzz = tol->dist / sqrt(fuzz);
	if( u < -fuzz )
		return(-3);		/* Intersection < A */
	if( (f=(u-1)) > fuzz )
		return(-2);		/* Intersection > B */

	/* Check for fuzzy intersection with one of the verticies */
	if( u < fuzz )
		return( 1 );		/* Intersection at A */
	if( f >= -fuzz )
		return( 2 );		/* Intersection at B */

	return(3);			/* Intersection between A and B */
}

/*
 *			B N _ D I S T _ L I N E 3_ P T 3
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Find parameter for PCA along line with unitized DIR:
 *	d = VDOT(f, dir) / MAGNITUDE(dir);
 *  Find distance g from PCA to A using Pythagoras:
 *	g = sqrt( MAGSQ(f) - d**2 )
 *
 *  Return -
 *	Distance
 */
double
bn_dist_line3_pt3(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	VSUB2( f, a, pt );
	FdotD = VDOT( f, dir ) / FdotD;
	FdotD = MAGSQ( f ) - FdotD * FdotD;
	if( FdotD <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	FdotD = sqrt(FdotD);
out:
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_dist_line3_pt3() ret=%g\n", FdotD);
	}
	return FdotD;
}

/*
 *			B N _ D I S T S Q _ L I N E 3 _ P T 3
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the square of the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance squared
 */
double
bn_distsq_line3_pt3(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2( f, pt, a );
	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	FdotD = VDOT( f, dir ) / FdotD;
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )  {
		FdotD = 0.0;
	}
out:
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_distsq_line3_pt3() ret=%g\n", FdotD);
	}
	return FdotD;
}

/*
 *			B N _ D I S T _ L I N E _ O R I G I N
 *
 *  Given a parametric line defined by PT + t * DIR,
 *  return the closest distance between the line and the origin.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance
 */
double
bn_dist_line_origin(const fastf_t *pt, const fastf_t *dir)
{
	register fastf_t	PTdotD;

	if( (PTdotD = MAGNITUDE(dir)) <= SMALL_FASTF )
		return 0.0;
	PTdotD = VDOT( pt, dir ) / PTdotD;
	if( (PTdotD = VDOT( pt, pt ) - PTdotD * PTdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(PTdotD) );
}
/*
 *			B N _ D I S T _ L I N E 2 _ P O I N T 2
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance
 */
double
bn_dist_line2_point2(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2_2D( f, pt, a );
	if( (FdotD = sqrt(MAGSQ_2D(dir))) <= SMALL_FASTF )
		return 0.0;
	FdotD = VDOT_2D( f, dir ) / FdotD;
	if( (FdotD = VDOT_2D( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(FdotD) );
}

/*
 *			B N _ D I S T S Q _ L I N E 2 _ P O I N T 2
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point, squared.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance squared
 */
double
bn_distsq_line2_point2(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2_2D( f, pt, a );
	if( (FdotD = sqrt(MAGSQ_2D(dir))) <= SMALL_FASTF )
		return 0.0;
	FdotD = VDOT_2D( f, dir ) / FdotD;
	if( (FdotD = VDOT_2D( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( FdotD );
}

/*
 *			B N _ A R E A _ O F _ T R I A N G L E
 *
 *  Returns the area of a triangle.
 *  Algorithm by Jon Leech 3/24/89.
 */
double
bn_area_of_triangle(register const fastf_t *a, register const fastf_t *b, register const fastf_t *c)
{
	register double	t;
	register double	area;

	t =	a[Y] * (b[Z] - c[Z]) -
		b[Y] * (a[Z] - c[Z]) +
		c[Y] * (a[Z] - b[Z]);
	area  = t*t;
	t =	a[Z] * (b[X] - c[X]) -
		b[Z] * (a[X] - c[X]) +
		c[Z] * (a[X] - b[X]);
	area += t*t;
	t = 	a[X] * (b[Y] - c[Y]) -
		b[X] * (a[Y] - c[Y]) +
		c[X] * (a[Y] - b[Y]);
	area += t*t;

	return( 0.5 * sqrt(area) );
}


/*
 *			B N _ I S E C T _ P T _ L S E G
 *
 * Intersect a point P with the line segment defined by two distinct
 * points A and B.
 *	
 * Explicit Return
 *	-2	P on line AB but outside range of AB,
 *			dist = distance from A to P on line.
 *	-1	P not on line of AB within tolerance
 *	1	P is at A
 *	2	P is at B
 *	3	P is on AB, dist = distance from A to P on line.
 *	
 *    B *
 *	|  
 *    P'*-tol-*P 
 *	|    /  _
 *    dist  /   /|
 *	|  /   /
 *	| /   / AtoP
 *	|/   /
 *    A *   /
 *	
 *	tol = distance limit from line to pt P;
 *	dist = parametric distance from A to P' (in terms of A to B)
 */
int bn_isect_pt_lseg(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
       			      		/* distance along line from A to P */
             		        	/* points for line and intersect */
                   	     
{
	vect_t	AtoP,
		BtoP,
		AtoB,
		ABunit;	/* unit vector from A to B */
	fastf_t	APprABunit;	/* Mag of projection of AtoP onto ABunit */
	fastf_t	distsq;

	BN_CK_TOL(tol);

	VSUB2(AtoP, p, a);
	if (MAGSQ(AtoP) < tol->dist_sq)
		return(1);	/* P at A */

	VSUB2(BtoP, p, b);
	if (MAGSQ(BtoP) < tol->dist_sq)
		return(2);	/* P at B */

	VSUB2(AtoB, b, a);
	VMOVE(ABunit, AtoB);
	distsq = MAGSQ(ABunit);
	if( distsq < tol->dist_sq )
		return -1;	/* A equals B, and P isn't there */
	distsq = 1/sqrt(distsq);
	VSCALE( ABunit, ABunit, distsq );

	/* Similar to bn_dist_line_pt, except we
	 * never actually have to do the sqrt that the other routine does.
	 */

	/* find dist as a function of ABunit, actually the projection
	 * of AtoP onto ABunit
	 */
	APprABunit = VDOT(AtoP, ABunit);

	/* because of pythgorean theorem ... */
	distsq = MAGSQ(AtoP) - APprABunit * APprABunit;
	if (distsq > tol->dist_sq)
		return(-1);	/* dist pt to line too large */

	/* Distance from the point to the line is within tolerance. */
	*dist = VDOT(AtoP, AtoB) / MAGSQ(AtoB);

	if (*dist > 1.0 || *dist < 0.0)	/* P outside AtoB */
		return(-2);

	return(3);	/* P on AtoB */
}

/*
 *			B N _ I S E C T _ P T 2 _ L S E G 2
 *
 * Intersect a point P with the line segment defined by two distinct
 * points A and B.
 *	
 * Explicit Return
 *	-2	P on line AB but outside range of AB,
 *			dist = distance from A to P on line.
 *	-1	P not on line of AB within tolerance
 *	1	P is at A
 *	2	P is at B
 *	3	P is on AB, dist = distance from A to P on line.
 *	
 *    B *
 *	|  
 *    P'*-tol-*P 
 *	|    /  _
 *    dist  /   /|
 *	|  /   /
 *	| /   / AtoP
 *	|/   /
 *    A *   /
 *	
 *	tol = distance limit from line to pt P;
 *	dist = distance from A to P'
 */
int
bn_isect_pt2_lseg2(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
       			      		/* distance along line from A to P */
             		        	/* points for line and intersect */
                   	     
{
	vect_t	AtoP,
		BtoP,
		AtoB,
		ABunit;	/* unit vector from A to B */
	fastf_t	APprABunit;	/* Mag of projection of AtoP onto ABunit */
	fastf_t	distsq;

	BN_CK_TOL(tol);

	VSUB2_2D(AtoP, p, a);
	if (MAGSQ_2D(AtoP) < tol->dist_sq)
		return(1);	/* P at A */

	VSUB2_2D(BtoP, p, b);
	if (MAGSQ_2D(BtoP) < tol->dist_sq)
		return(2);	/* P at B */

	VSUB2_2D(AtoB, b, a);
	VMOVE_2D(ABunit, AtoB);
	distsq = MAGSQ_2D(ABunit);
	if( distsq < tol->dist_sq )  {
		if( bu_debug & BU_DEBUG_MATH )  {
			bu_log("distsq A=%g\n", distsq);
		}
		return -1;	/* A equals B, and P isn't there */
	}
	distsq = 1/sqrt(distsq);
	VSCALE_2D( ABunit, ABunit, distsq );

	/* Similar to bn_dist_line_pt, except we
	 * never actually have to do the sqrt that the other routine does.
	 */

	/* find dist as a function of ABunit, actually the projection
	 * of AtoP onto ABunit
	 */
	APprABunit = VDOT_2D(AtoP, ABunit);

	/* because of pythgorean theorem ... */
	distsq = MAGSQ_2D(AtoP) - APprABunit * APprABunit;
	if (distsq > tol->dist_sq) {
		if( bu_debug & BU_DEBUG_MATH )  {
			V2PRINT("ABunit", ABunit);
			bu_log("distsq B=%g\n", distsq);
		}
		return(-1);	/* dist pt to line too large */
	}

	/* Distance from the point to the line is within tolerance. */
	*dist = VDOT_2D(AtoP, AtoB) / MAGSQ_2D(AtoB);

	if (*dist > 1.0 || *dist < 0.0)	/* P outside AtoB */
		return(-2);

	return(3);	/* P on AtoB */
}

/*
 *			B N _ D I S T _ P T 3 _ L S E G 3
 *
 *  Find the distance from a point P to a line segment described
 *  by the two endpoints A and B, and the point of closest approach (PCA).
 *
 *			P
 *		       *
 *		      /.
 *		     / .
 *		    /  .
 *		   /   . (dist)
 *		  /    .
 *		 /     .
 *		*------*--------*
 *		A      PCA	B
 *
 *  There are six distinct cases, with these return codes -
 *	0	P is within tolerance of lseg AB.  *dist isn't 0: (SPECIAL!!!)
 *		  *dist = parametric dist = |PCA-A| / |B-A|.  pca=computed.
 *	1	P is within tolerance of point A.  *dist = 0, pca=A.
 *	2	P is within tolerance of point B.  *dist = 0, pca=B.
 *	3	P is to the "left" of point A.  *dist=|P-A|, pca=A.
 *	4	P is to the "right" of point B.  *dist=|P-B|, pca=B.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|, pca=computed.
 *
 * This routine was formerly called bn_dist_pt_lseg().
 *
 * XXX For efficiency, a version of this routine that provides the
 * XXX distance squared would be faster.
 */
int
bn_dist_pt3_lseg3(fastf_t *dist, fastf_t *pca, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
{
	vect_t	PtoA;		/* P-A */
	vect_t	PtoB;		/* P-B */
	vect_t	AtoB;		/* B-A */
	fastf_t	P_A_sq;		/* |P-A|**2 */
	fastf_t	P_B_sq;		/* |P-B|**2 */
	fastf_t	B_A;		/* |B-A| */
	fastf_t	t;		/* distance along ray of projection of P */

	BN_CK_TOL(tol);

	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_dist_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
			V3ARGS(a),
			V3ARGS(b),
			V3ARGS(p),
			tol->dist, tol->dist_sq );
	}

	/* Check proximity to endpoint A */
	VSUB2(PtoA, p, a);
	if( (P_A_sq = MAGSQ(PtoA)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around A */
		VMOVE( pca, a );
		if( bu_debug & BU_DEBUG_MATH )  bu_log("  at A\n");
		*dist = 0.0;
		return 1;
	}

	/* Check proximity to endpoint B */
	VSUB2(PtoB, p, b);
	if( (P_B_sq = MAGSQ(PtoB)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around B */
		VMOVE( pca, b );
		if( bu_debug & BU_DEBUG_MATH )  bu_log("  at B\n");
		*dist = 0.0;
		return 2;
	}

	VSUB2(AtoB, b, a);
	B_A = sqrt( MAGSQ(AtoB) );

	/* compute distance (in actual units) along line to PROJECTION of
	 * point p onto the line: point pca
	 */
	t = VDOT(PtoA, AtoB) / B_A;
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_dist_pt3_lseg3() B_A=%g, t=%g\n",
			B_A, t );
	}

	if( t <= 0 )  {
		/* P is "left" of A */
		if( bu_debug & BU_DEBUG_MATH )  bu_log("  left of A\n");
		VMOVE( pca, a );
		*dist = sqrt(P_A_sq);
		return 3;
	}
	if( t < B_A )  {
		/* PCA falls between A and B */
		register fastf_t	dsq;
		fastf_t			param_dist;	/* parametric dist */

		/* Find PCA */
		param_dist = t / B_A;		/* Range 0..1 */
		VJOIN1(pca, a, param_dist, AtoB);

		/* Find distance from PCA to line segment (Pythagorus) */
		if( (dsq = P_A_sq - t * t ) <= tol->dist_sq )  {
			if( bu_debug & BU_DEBUG_MATH )  bu_log("  ON lseg\n");
			/* Distance from PCA to lseg is zero, give param instead */
			*dist = param_dist;	/* special! */
			return 0;
		}
		if( bu_debug & BU_DEBUG_MATH )  bu_log("  closest to lseg\n");
		*dist = sqrt(dsq);
		return 5;
	}
	/* P is "right" of B */
	if( bu_debug & BU_DEBUG_MATH )  bu_log("  right of B\n");
	VMOVE(pca, b);
	*dist = sqrt(P_B_sq);
	return 4;
}

/*
 *			B N _ D I S T _ P T 2 _ L S E G 2
 *
 *  Find the distance from a point P to a line segment described
 *  by the two endpoints A and B, and the point of closest approach (PCA).
 *
 *			P
 *		       *
 *		      /.
 *		     / .
 *		    /  .
 *		   /   . (dist)
 *		  /    .
 *		 /     .
 *		*------*--------*
 *		A      PCA	B
 *
 *  There are six distinct cases, with these return codes -
 *	0	P is within tolerance of lseg AB.  *dist isn't 0: (SPECIAL!!!)
 *		  *dist = parametric dist = |PCA-A| / |B-A|.  pca=computed.
 *	1	P is within tolerance of point A.  *dist = 0, pca=A.
 *	2	P is within tolerance of point B.  *dist = 0, pca=B.
 *	3	P is to the "left" of point A.  *dist=|P-A|**2, pca=A.
 *	4	P is to the "right" of point B.  *dist=|P-B|**2, pca=B.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|**2, pca=computed.
 *
 *
 *  Patterned after bn_dist_pt3_lseg3().
 */
int
bn_dist_pt2_lseg2(fastf_t *dist_sq, fastf_t *pca, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
{
	vect_t	PtoA;		/* P-A */
	vect_t	PtoB;		/* P-B */
	vect_t	AtoB;		/* B-A */
	fastf_t	P_A_sq;		/* |P-A|**2 */
	fastf_t	P_B_sq;		/* |P-B|**2 */
	fastf_t	B_A;		/* |B-A| */
	fastf_t	t;		/* distance along ray of projection of P */

	BN_CK_TOL(tol);

	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_dist_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
			V3ARGS(a),
			V3ARGS(b),
			V3ARGS(p),
			tol->dist, tol->dist_sq );
	}


	/* Check proximity to endpoint A */
	VSUB2_2D(PtoA, p, a);
	if( (P_A_sq = MAGSQ_2D(PtoA)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around A */
		V2MOVE( pca, a );
		if( bu_debug & BU_DEBUG_MATH )  bu_log("  at A\n");
		*dist_sq = 0.0;
		return 1;
	}

	/* Check proximity to endpoint B */
	VSUB2_2D(PtoB, p, b);
	if( (P_B_sq = MAGSQ_2D(PtoB)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around B */
		V2MOVE( pca, b );
		if( bu_debug & BU_DEBUG_MATH )  bu_log("  at B\n");
		*dist_sq = 0.0;
		return 2;
	}

	VSUB2_2D(AtoB, b, a);
	B_A = sqrt( MAGSQ_2D(AtoB) );

	/* compute distance (in actual units) along line to PROJECTION of
	 * point p onto the line: point pca
	 */
	t = VDOT_2D(PtoA, AtoB) / B_A;
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_dist_pt3_lseg3() B_A=%g, t=%g\n",
			B_A, t );
	}

	if( t <= 0 )  {
		/* P is "left" of A */
		if( bu_debug & BU_DEBUG_MATH )  bu_log("  left of A\n");
		V2MOVE( pca, a );
		*dist_sq = P_A_sq;
		return 3;
	}
	if( t < B_A )  {
		/* PCA falls between A and B */
		register fastf_t	dsq;
		fastf_t			param_dist;	/* parametric dist */

		/* Find PCA */
		param_dist = t / B_A;		/* Range 0..1 */
		V2JOIN1(pca, a, param_dist, AtoB);

		/* Find distance from PCA to line segment (Pythagorus) */
		if( (dsq = P_A_sq - t * t ) <= tol->dist_sq )  {
			if( bu_debug & BU_DEBUG_MATH )  bu_log("  ON lseg\n");
			/* Distance from PCA to lseg is zero, give param instead */
			*dist_sq = param_dist;	/* special! Not squared. */
			return 0;
		}
		if( bu_debug & BU_DEBUG_MATH )  bu_log("  closest to lseg\n");
		*dist_sq = dsq;
		return 5;
	}
	/* P is "right" of B */
	if( bu_debug & BU_DEBUG_MATH )  bu_log("  right of B\n");
	V2MOVE(pca, b);
	*dist_sq = P_B_sq;
	return 4;
}

/*
 *			B N _ R O T A T E _ B B O X
 *
 *  Transform a bounding box (RPP) by the given 4x4 matrix.
 *  There are 8 corners to the bounding RPP.
 *  Each one needs to be transformed and min/max'ed.
 *  This is not minimal, but does fully contain any internal object,
 *  using an axis-aligned RPP.
 */
void
bn_rotate_bbox(fastf_t *omin, fastf_t *omax, const fastf_t *mat, const fastf_t *imin, const fastf_t *imax)
{
	point_t	local;		/* vertex point in local coordinates */
	point_t	model;		/* vertex point in model coordinates */

#define ROT_VERT( a, b, c )  \
	VSET( local, a[X], b[Y], c[Z] ); \
	MAT4X3PNT( model, mat, local ); \
	VMINMAX( omin, omax, model ) \

	ROT_VERT( imin, imin, imin );
	ROT_VERT( imin, imin, imax );
	ROT_VERT( imin, imax, imin );
	ROT_VERT( imin, imax, imax );
	ROT_VERT( imax, imin, imin );
	ROT_VERT( imax, imin, imax );
	ROT_VERT( imax, imax, imin );
	ROT_VERT( imax, imax, imax );
#undef ROT_VERT
}

/*
 *			B N _ R O T A T E _ P L A N E
 *
 *  Transform a plane equation by the given 4x4 matrix.
 */
void
bn_rotate_plane(fastf_t *oplane, const fastf_t *mat, const fastf_t *iplane)
{
	point_t		orig_pt;
	point_t		new_pt;

	/* First, pick a point that lies on the original halfspace */
	VSCALE( orig_pt, iplane, iplane[3] );

	/* Transform the surface normal */
	MAT4X3VEC( oplane, mat, iplane );

	/* Transform the point from original to new halfspace */
	MAT4X3PNT( new_pt, mat, orig_pt );

	/*
	 *  The transformed normal is all that is required.
	 *  The new distance is found from the transformed point on the plane.
	 */
	oplane[3] = VDOT( new_pt, oplane );
}

/*
 *			B N _ C O P L A N A R
 *
 *  Test if two planes are identical.  If so, their dot products will be
 *  either +1 or -1, with the distance from the origin equal in magnitude.
 *
 *  Returns -
 *	-1	not coplanar, parallel but distinct
 *	 0	not coplanar, not parallel.  Planes intersect.
 *	+1	coplanar, same normal direction
 *	+2	coplanar, opposite normal direction
 */
int
bn_coplanar(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
{
	register fastf_t	f;
	register fastf_t	dot;

	BN_CK_TOL(tol);

	/* Check to see if the planes are parallel */
	dot = VDOT( a, b );
	if( dot >= 0 )  {
		/* Normals head in generally the same directions */
		if( dot < tol->para )
			return(0);	/* Planes intersect */

		/* Planes have "exactly" the same normal vector */
		f = a[3] - b[3];
		if( NEAR_ZERO( f, tol->dist ) )  {
			return(1);	/* Coplanar, same direction */
		}
		return(-1);		/* Parallel but distinct */
	}
	/* Normals head in generally opposite directions */
	if( -dot < tol->para )
		return(0);		/* Planes intersect */

	/* Planes have "exactly" opposite normal vectors */
	f = a[3] + b[3];
	if( NEAR_ZERO( f, tol->dist ) )  {
		return(2);		/* Coplanar, opposite directions */
	}
	return(-1);			/* Parallel but distinct */
}

/*
 *			B N _ A N G L E _ M E A S U R E
 *
 *  Using two perpendicular vectors (x_dir and y_dir) which lie
 *  in the same plane as 'vec', return the angle (in radians) of 'vec'
 *  from x_dir, going CCW around the perpendicular x_dir CROSS y_dir.
 *
 *  Trig note -
 *
 *  theta = atan2(x,y) returns an angle in the range -pi to +pi.
 *  Here, we need an angle in the range of 0 to 2pi.
 *  This could be implemented by adding 2pi to theta when theta is negative,
 *  but this could have nasty numeric ambiguity right in the vicinity
 *  of theta = +pi, which is a very critical angle for the applications using
 *  this routine.
 *  So, an alternative formulation is to compute gamma = atan2(-x,-y),
 *  and then theta = gamma + pi.  Now, any error will occur in the
 *  vicinity of theta = 0, which can be handled much more readily.
 *
 *  If theta is negative, or greater than two pi,
 *  wrap it around.
 *  These conditions only occur if there are problems in atan2().
 *
 *  Returns -
 *	vec == x_dir returns 0,
 *	vec == y_dir returns pi/2,
 *	vec == -x_dir returns pi,
 *	vec == -y_dir returns 3*pi/2.
 *
 *  In all cases, the returned value is between 0 and bn_twopi.
 */
double
bn_angle_measure(fastf_t *vec, const fastf_t *x_dir, const fastf_t *y_dir)
{
	fastf_t		xproj, yproj;
	fastf_t		gamma;
	fastf_t		ang;

	xproj = -VDOT( vec, x_dir );
	yproj = -VDOT( vec, y_dir );
	gamma = atan2( yproj, xproj );	/* -pi..+pi */
	ang = bn_pi + gamma;		/* 0..+2pi */
	if( ang < 0 )  {
		do {
			ang += bn_twopi;
		} while( ang < 0 );
	} else if( ang > bn_twopi )  {
		do {
			ang -= bn_twopi;
		} while( ang > bn_twopi );
	}
	if( ang < 0 || ang > bn_twopi )  bu_bomb("bn_angle_measure() angle out of range\n");
	return ang;
}

/*
 *			B N _ D I S T _ P T 3 _ A L O N G _ L I N E 3
 *
 *  Return the parametric distance t of a point X along a line defined
 *  as a ray, i.e. solve X = P + t * D.
 *  If the point X does not lie on the line, then t is the distance of
 *  the perpendicular projection of point X onto the line.
 */
double
bn_dist_pt3_along_line3(const fastf_t *p, const fastf_t *d, const fastf_t *x)
{
	vect_t	x_p;

	VSUB2( x_p, x, p );
	return VDOT( x_p, d );
}


/*
 *			B N _ D I S T _ P T 2 _ A L O N G _ L I N E 2
 *
 *  Return the parametric distance t of a point X along a line defined
 *  as a ray, i.e. solve X = P + t * D.
 *  If the point X does not lie on the line, then t is the distance of
 *  the perpendicular projection of point X onto the line.
 */
double
bn_dist_pt2_along_line2(const fastf_t *p, const fastf_t *d, const fastf_t *x)
{
	vect_t	x_p;
	double	ret;

	VSUB2_2D( x_p, x, p );
	ret = VDOT_2D( x_p, d );
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_dist_pt2_along_line2() p=(%g, %g), d=(%g, %g), x=(%g, %g) ret=%g\n",
			V2ARGS(p),
			V2ARGS(d),
			V2ARGS(x),
			ret );
	}
	return ret;
}

/*
 *  Returns -
 *	1	if left <= mid <= right
 *	0	if mid is not in the range.
 */
int
bn_between(double left, double mid, double right, const struct bn_tol *tol)
{
	BN_CK_TOL(tol);

	if( left < right )  {
		if( NEAR_ZERO(left-right, tol->dist*0.1) )  {
			left -= tol->dist*0.1;
			right += tol->dist*0.1;
		}
		if( mid < left || mid > right )  goto fail;
		return 1;
	}
	/* The 'right' value is lowest */
	if( NEAR_ZERO(left-right, tol->dist*0.1) )  {
		right -= tol->dist*0.1;
		left += tol->dist*0.1;
	}
	if( mid < right || mid > left )  goto fail;
	return 1;
fail:
	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log("bn_between( %.17e, %.17e, %.17e ) ret=0 FAIL\n",
			left, mid, right);
	}
	return 0;
}

/*
 *			B N _ D O E S _ R A Y _ I S E C T _ T R I
 *
 *  Returns -
 *	0	No intersection
 *	1	Intersection, 'inter' has intersect point.
 */
int
bn_does_ray_isect_tri(
	const point_t pt,
	const vect_t dir,
	const point_t V,
	const point_t A,
	const point_t B,
	point_t	inter)			/* output variable */
{
	vect_t VP, VA, VB, AB, AP, N;
	fastf_t NdotDir;
	plane_t pl;
	fastf_t dist;

	/* insersect with plane */

	VSUB2( VA, A, V );
	VSUB2( VB, B, V );
	VCROSS( pl, VA, VB );
	VUNITIZE( pl );

	NdotDir = VDOT( pl, dir );
	if( NEAR_ZERO( NdotDir, SMALL_FASTF ) )
		return( 0 );

	pl[3] = VDOT( pl, V );

	dist = (pl[3] - VDOT( pl, pt ))/NdotDir;
	VJOIN1( inter, pt, dist, dir );

	/* determine if point is within triangle */
	VSUB2( VP, inter, V );
	VCROSS( N, VA, VP );
	if( VDOT( N, pl ) < 0.0 )
		return( 0 );

	VCROSS( N, VP, VB );
	if( VDOT( N, pl ) < 0.0 )
		return( 0 );

	VSUB2( AB, B, A );
	VSUB2( AP, inter, A );
	VCROSS( N, AB, AP );
	if( VDOT( N, pl ) < 0.0 )
		return( 0 );

	return( 1 );
}

#if 0
/*
 *			B N _ I S E C T _ R A Y _ T R I
 *
 *  Intersect a infinite ray with a triangle specified by 3 points.
 *  From: "Graphics Gems" ed Andrew S. Glassner:
 *		"An Efficient Ray-Polygon Intersection"  P 390
 *
 *	      o A
 *	      |\
 *	      | \
 *	      |  \
 *	      |   \
 *	   _  |  o \
 *   alpha|   |  P  \
 *	  |   |      \
 *	  |_  o-------o
 *	       V       B
 *	
 *	      |__|
 *		beta
 *
 *  The intersection point P is computed by determining 2 quantities,
 *  (alpha,beta) which indicate the parametric distance along VA and VB
 *  respectively.  The intersection point is thus:
 *
 *	P = V + (alpha * VA) + (beta * VB)
 *
 *  Return:
 *	0	Miss
 *	1	Hit, incoming
 *	-1	Hit, outgoing
 *
 *    If Hit, the following parameters are also set:
 *	dist	parametric distance to the triangle intercept.
 *	N	If non-null, surface normal of triangle
 *	Alpha	If non-null, parametric distance along VA
 *	Beta	If non-null, parametric distance along VB

 *  The parameters Alpha and Beta may be null, otherwise they will be
 *	set.
 */
int
bn_isect_ray_tri(dist_p, N_p, Alpha_p, Beta_p, pt, dir, V, A, B)
fastf_t *dist_p;
fastf_t *N_p;
fastf_t *Alpha_p;
fastf_t *Beta_p;
const point_t pt;
const vect_t dir;
const point_t V;
const point_t A;
const point_t B;
{
	vect_t VA;	/* V -> A vector */
	vect_t VB;	/* V -> B vector */
	vect_t pt_V;	/* Ray_origin -> V  vector */
	vect_t N;	/* Triangle Normal */
	vect_t VPP;	/* perpendicular to vector V -> P */
	fastf_t alpha;	/* parametric distance along VA */
	fastf_t beta;	/* parametric distance along VB */
	fastf_t NdotDir;
	fastf_t entleave;
	fastf_t k;

	/* form edge vectors of triangle */
	VSUB2(VB, B, V);
	VSUB2(VA, A, V);

	/* form triangle normal */
	VCROSS( N, VA, VB );

	NdotDir = VDOT( N, dir );
	if (fabs(NdotDir) < SQRT_SMALL_FASTF)
		return 0;	/* ray parallel to triangle */

	if (NdotDir >= 0.0) entleave = -1;	/* leaving */
	else entleave = 1;			/* entering */

	VSUB2( pt_V, V, pt );
	VCROSS( VPP, pt_V, dir );

	/* alpha is projection of VPP onto VA (not necessaily in plane)
	 * If alpha < 0.0 then p is "before" point V on line V->A
	 * No-one can figure out why alpha > NdotDir is important.
	 */
	alpha = VDOT( VA, VPP ) * entleave;
	if (alpha < 0.0 || alpha > fabs(NdotDir) ) return 0;


	/* beta is projection of VPP onto VB (not necessaily in plane) */
	beta = VDOT(VB, VPP ) * (-1 * entleave);
	if (beta < 0.0 || beta > fabs(NdotDir)) return 0;

	k = VDOT(VPP, N) / NdotDir;
	
	if (dist_p) *dist_p = k;
	if (N_p) {
		VUNITIZE(N);
		VMOVE(N_p, N);
	}
	if (Alpha_p) *Alpha_p = alpha;
	if (Beta_p) *Beta_p = beta;

	return entleave;
}
#endif

/*
 *			B N _ H L F _ C L A S S
 *
 *  Classify a halfspace, specified by its plane equation,
 *  against a bounding RPP.
 *
 *  Returns -
 *      BN_CLASSIFY_INSIDE
 *      BN_CLASSIFY_OVERLAPPING
 *      BN_CLASSIFY_OUTSIDE
 */
int
bn_hlf_class(const fastf_t *half_eqn, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
{
	int	class;	/* current classification */
	fastf_t d;
	
#define CHECK_PT( x, y, z ) \
	d = (x)*half_eqn[0] + (y)*half_eqn[1] + (z)*half_eqn[2] - half_eqn[3];\
	if( d < -tol->dist ) { \
		if( class == BN_CLASSIFY_OUTSIDE ) \
			return BN_CLASSIFY_OVERLAPPING; \
		else class = BN_CLASSIFY_INSIDE; \
	} else if( d > tol->dist ) { \
		if( class == BN_CLASSIFY_INSIDE ) \
			return BN_CLASSIFY_OVERLAPPING; \
		else class = BN_CLASSIFY_OUTSIDE; \
	} else return BN_CLASSIFY_OVERLAPPING

	class = BN_CLASSIFY_UNIMPLEMENTED;
	CHECK_PT( min[X], min[Y], min[Z] );
	CHECK_PT( min[X], min[Y], max[Z] );
	CHECK_PT( min[X], max[Y], min[Z] );
	CHECK_PT( min[X], max[Y], max[Z] );
	CHECK_PT( max[X], min[Y], min[Z] );
	CHECK_PT( max[X], min[Y], max[Z] );
	CHECK_PT( max[X], max[Y], min[Z] );
	CHECK_PT( max[X], max[Y], max[Z] );
	if( class == BN_CLASSIFY_UNIMPLEMENTED )
		bu_log( "bn_hlf_class: error in implementation\
min = (%g, %g, %g), max = (%g, %g, %g), half_eqn = (%d, %d, %d, %d)\n",
			V3ARGS(min), V3ARGS(max), V3ARGS(half_eqn),
			half_eqn[3]);
	return class;
}

/*		B N _ D I S T S Q _ L I N E 3 _ L I N E 3
 *
 * calculate the square of the distance of closest approach for two lines
 * The lines are specifed as a point and a vector each. The vectors need not be unit length.
 * P and d define one line; Q and e define the other.
 *
 * return:
 *	0 - normal return
 *	1 - lines are parallel, dist[0] is set to 0.0
 *
 * Output values:
 * dist[0] is the parametric distance along the first line P + dist[0] * d of the PCA
 * dist[1] is the parametric distance along the second line Q + dist[1] * e of the PCA
 * dist[3] is the square of the distance between the points of closest approach
 * pt1 is the point of closest approach on the first line
 * pt2 is the point of closest approach on the second line
 *
 * This algoritm is based on expressing the distance sqaured, taking partials with respect
 * to the two unknown parameters (dist[0] and dist[1]), seeting the two partails equal to 0,
 * and solving the two simutaneous equations
 */

int
bn_distsq_line3_line3(fastf_t *dist, fastf_t *P, fastf_t *d_in, fastf_t *Q, fastf_t *e_in, fastf_t *pt1, fastf_t *pt2)
{
	fastf_t de, denom;
	vect_t diff, PmQ, tmp;
	vect_t d, e;
	fastf_t len_e, inv_len_e, len_d, inv_len_d;
	int ret=0;

	len_e = MAGNITUDE( e_in );
	if( NEAR_ZERO( len_e, SMALL_FASTF ) )
		bu_bomb( "bn_distsq_line3_line3() called with zero length vector!!!\n");
	inv_len_e = 1.0 / len_e;

	len_d = MAGNITUDE( d_in );
	if( NEAR_ZERO( len_d, SMALL_FASTF ) )
		bu_bomb( "bn_distsq_line3_line3() called with zero length vector!!!\n");
	inv_len_d = 1.0 / len_d;

	VSCALE( e, e_in, inv_len_e );
	VSCALE( d, d_in, inv_len_d );
	de = VDOT( d, e );

	if( NEAR_ZERO( de, SMALL_FASTF ) )
	{
		/* lines are perpendicular */
		dist[0] = VDOT( Q, d ) - VDOT( P, d );
		dist[1] = VDOT( P, e ) - VDOT( Q, e );
	}
	else
	{
		VSUB2( PmQ, P, Q );
		denom = 1.0 - de*de;
		if( NEAR_ZERO( denom, SMALL_FASTF ) )
		{
			/* lines are parallel */
			dist[0] = 0.0;
			dist[1] = VDOT( PmQ, d );
			ret = 1;
		}
		else
		{
			VBLEND2( tmp, 1.0, e, -de, d );
			dist[1] = VDOT( PmQ, tmp )/denom;
			dist[0] = dist[1] * de - VDOT( PmQ, d );
		}
	}
	VJOIN1( pt1, P, dist[0], d );
	VJOIN1( pt2, Q, dist[1], e );
	VSUB2( diff, pt1, pt2 );
	dist[0] *= inv_len_d;
	dist[1] *= inv_len_e;
	dist[2] =  MAGSQ( diff );
	return( ret );
}

/*
 *			B N _ I S E C T _ P L A N E S
 *
 * Calculates the point that is the minimum distance from all the
 * planes in the "planes" array.  If the planes intersect at a single point,
 * that point is the solution.
 *
 * The method used here is based on:
 *	An expression for the distance from a point to a plane is VDOT(pt,plane)-plane[H].
 *	Square that distance and sum for all planes to get the "total" distance.
 *	For minimum total distance, the partial derivatives of this expression (with
 *	respect to x, y, and z) must all be zero. 
 *	This produces a set of three equations in three unknowns (x, y, and z).
 *	This routine sets up the three equations as [matrix][pt] = [hpq]
 *	and solves by inverting "matrix" into "inverse" and
 *	[pt] = [inverse][hpq].
 *
 * There is likely a more economical solution rather than matrix inversion, but
 * bn_mat_inv was handy at the time.
 *
 * Checks if these planes form a singular matrix and returns:
 *	0 - all is well
 *	1 - planes form a singular matrix (no solution)
 */
int
bn_isect_planes(fastf_t *pt, const fastf_t (*planes)[4], const int pl_count)
{
	mat_t matrix;
	mat_t inverse;
	vect_t hpq;
	fastf_t det;
	int i;

	if( bu_debug & BU_DEBUG_MATH )  {
		bu_log( "bn_isect_planes:\n" );
		for( i=0 ; i<pl_count ; i++ )
		{
			bu_log( "Plane #%d (%f %f %f %f)\n" , i , V4ARGS( planes[i] ) );
		}
	}

	MAT_ZERO( matrix );
	VSET( hpq , 0.0 , 0.0 , 0.0 );

	for( i=0 ; i<pl_count ; i++ )
	{
		matrix[0] += planes[i][X] * planes[i][X];
		matrix[5] += planes[i][Y] * planes[i][Y];
		matrix[10] += planes[i][Z] * planes[i][Z];
		matrix[1] += planes[i][X] * planes[i][Y];
		matrix[2] += planes[i][X] * planes[i][Z];
		matrix[6] += planes[i][Y] * planes[i][Z];
		hpq[X] += planes[i][X] * planes[i][H];
		hpq[Y] += planes[i][Y] * planes[i][H];
		hpq[Z] += planes[i][Z] * planes[i][H];
	}

	matrix[4] = matrix[1];
	matrix[8] = matrix[2];
	matrix[9] = matrix[6];
	matrix[15] = 1.0;

	/* Check that we don't have a singular matrix */
	det = bn_mat_determinant( matrix );
	if( NEAR_ZERO( det , SMALL_FASTF ) )
		return( 1 );

	bn_mat_inv( inverse , matrix );

	MAT4X3PNT( pt , inverse , hpq );

	return( 0 );

}

/*
 *			B N _ I S E C T _ L S E G _ R P P
 *
 *  Intersect a line segment with a rectangular parallelpiped (RPP)
 *  that has faces parallel to the coordinate planes (a clipping RPP).
 *  The RPP is defined by a minimum point and a maximum point.
 *  This is a very close relative to rt_in_rpp() from librt/shoot.c
 *
 *  Returns -
 *	 0  if ray does not hit RPP,
 *	!0  if ray hits RPP.
 *
 *  Implicit Return -
 *	if !0 was returned, "a" and "b" have been clipped to the RPP.
 */
int
bn_isect_lseg_rpp(fastf_t *a, fastf_t *b, register fastf_t *min, register fastf_t *max)
{
	auto vect_t	diff;
	register fastf_t *pt = &a[0];
	register fastf_t *dir = &diff[0];
	register int i;
	register double sv;
	register double st;
	register double mindist, maxdist;

	mindist = -MAX_FASTF;
	maxdist = MAX_FASTF;
	VSUB2( diff, b, a );

	for( i=0; i < 3; i++, pt++, dir++, max++, min++ )  {
		if( *dir < -SQRT_SMALL_FASTF )  {
			if( (sv = (*min - *pt) / *dir) < 0.0 )
				return(0);	/* MISS */
			if(maxdist > sv)
				maxdist = sv;
			if( mindist < (st = (*max - *pt) / *dir) )
				mindist = st;
		}  else if( *dir > SQRT_SMALL_FASTF )  {
			if( (st = (*max - *pt) / *dir) < 0.0 )
				return(0);	/* MISS */
			if(maxdist > st)
				maxdist = st;
			if( mindist < ((sv = (*min - *pt) / *dir)) )
				mindist = sv;
		}  else  {
			/*
			 *  If direction component along this axis is NEAR 0,
			 *  (ie, this ray is aligned with this axis),
			 *  merely check against the boundaries.
			 */
			if( (*min > *pt) || (*max < *pt) )
				return(0);	/* MISS */;
		}
	}
	if( mindist >= maxdist )
		return(0);	/* MISS */

	if( mindist > 1 || maxdist < 0 )
		return(0);	/* MISS */

	if( mindist >= 0 && maxdist <= 1 )
		return(1);	/* HIT within box, no clipping needed */

	/* Don't grow one end of a contained segment */
	if( mindist < 0 )
		mindist = 0;
	if( maxdist > 1 )
		maxdist = 1;

	/* Compute actual intercept points */
	VJOIN1( b, a, maxdist, diff );		/* b must go first */
	VJOIN1( a, a, mindist, diff );
	return(1);		/* HIT */
}
@


11.36
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /cvs/brlcad/libbn/plane.c,v 11.35 2004/04/05 07:46:41 morrison Exp $ (BRL)";
@


11.35
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header$ (BRL)";
d21 5
a25 1
#include "conf.h"
@


11.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.32 2001/04/05 19:35:27 morrison Exp $ (BRL)";
d45 1
a45 3
bn_dist_pt3_pt3( a, b )
const point_t	a;
const point_t	b;
d61 1
a61 4
bn_pt3_pt3_equal( a, b, tol )
const point_t		a;
const point_t		b;
const struct bn_tol	*tol;
d79 1
a79 4
bn_pt2_pt2_equal( a, b, tol )
const point_t		a;
const point_t		b;
const struct bn_tol	*tol;
d102 1
a102 3
bn_3pts_collinear(a, b, c, tol)
point_t	a, b, c;
const struct bn_tol	*tol;
d168 1
a168 3
bn_3pts_distinct( a, b, c, tol )
const point_t		a, b, c;
const struct bn_tol	*tol;
d223 1
a223 4
bn_mk_plane_3pts( plane, a, b, c, tol )
plane_t			plane;
const point_t		a, b, c;
const struct bn_tol	*tol;
d292 1
a292 3
bn_mkpoint_3planes( pt, a, b, c )
point_t		pt;
const plane_t	a, b, c;
d330 1
a330 7
bn_2line3_colinear( p1, d1, p2, d2, range, tol )
const point_t		p1;
const vect_t		d1;
const point_t		p2;
const vect_t		d2;
double			range;
const struct bn_tol	*tol;
d385 1
a385 6
bn_isect_line3_plane( dist, pt, dir, plane, tol )
fastf_t		*dist;
const point_t	pt;
const vect_t	dir;
const plane_t	plane;
const struct bn_tol	*tol;
d442 1
a442 7
bn_isect_2planes( pt, dir, a, b, rpp_min, tol )
point_t		pt;
vect_t		dir;
const plane_t	a;
const plane_t	b;
const vect_t	rpp_min;
const struct bn_tol	*tol;
d542 7
a548 7
bn_isect_line2_line2( dist, p, d, a, c, tol )
fastf_t			*dist;			/* dist[2] */
const point_t		p;
const vect_t		d;
const point_t		a;
const vect_t		c;
const struct bn_tol	*tol;
d759 7
a765 7
bn_isect_line2_lseg2( dist, p, d, a, c, tol )
fastf_t			*dist;		/* dist[2] */
const point_t		p;
const vect_t		d;
const point_t		a;
const vect_t		c;
const struct bn_tol	*tol;
d962 1
a962 7
bn_isect_lseg2_lseg2( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
const point_t	p;
const vect_t	pdir;
const point_t	q;
const vect_t	qdir;
const struct bn_tol	*tol;
d1053 1
a1053 7
bn_isect_lseg3_lseg3( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
const point_t	p;
const vect_t	pdir;
const point_t	q;
const vect_t	qdir;
const struct bn_tol	*tol;
d1155 1
a1155 8
bn_isect_line3_line3( t, u, p, d, a, c, tol )
fastf_t			*t;
fastf_t			*u;
const point_t		p;
const vect_t		d;
const point_t		a;
const vect_t		c;
const struct bn_tol	*tol;
d1398 1
a1398 7
bn_isect_line_lseg( t, p, d, a, b, tol )
fastf_t			*t;
const point_t		p;
const vect_t		d;
const point_t		a;
const point_t		b;
const struct bn_tol	*tol;
d1486 1
a1486 4
bn_dist_line3_pt3( pt, dir, a )
const point_t	pt;
const vect_t	dir;
const point_t	a;
d1522 1
a1522 4
bn_distsq_line3_pt3( pt, dir, a )
const point_t	pt;
const vect_t	dir;
const point_t	a;
d1555 1
a1555 3
bn_dist_line_origin( pt, dir )
const point_t	pt;
const vect_t	dir;
d1578 1
a1578 4
bn_dist_line2_point2( pt, dir, a )
const point_t	pt;
const vect_t	dir;
const point_t	a;
d1604 1
a1604 4
bn_distsq_line2_point2( pt, dir, a )
const point_t	pt;
const vect_t	dir;
const point_t	a;
d1625 1
a1625 2
bn_area_of_triangle( a, b, c )
register const point_t a, b, c;
d1674 4
a1677 4
int bn_isect_pt_lseg(dist, a, b, p, tol)
fastf_t			*dist;		/* distance along line from A to P */
const point_t		a, b, p;	/* points for line and intersect */
const struct bn_tol	*tol;
d1755 4
a1758 4
bn_isect_pt2_lseg2(dist, a, b, p, tol)
fastf_t			*dist;		/* distance along line from A to P */
const point_t		a, b, p;	/* points for line and intersect */
const struct bn_tol	*tol;
d1849 1
a1849 5
bn_dist_pt3_lseg3( dist, pca, a, b, p, tol )
fastf_t		*dist;
point_t		pca;
const point_t	a, b, p;
const struct bn_tol *tol;
d1965 1
a1965 5
bn_dist_pt2_lseg2( dist_sq, pca, a, b, p, tol )
fastf_t		*dist_sq;
fastf_t		pca[2];
const point_t	a, b, p;
const struct bn_tol *tol;
d2062 1
a2062 6
bn_rotate_bbox( omin, omax, mat, imin, imax )
point_t		omin;
point_t		omax;
const mat_t	mat;
const point_t	imin;
const point_t	imax;
d2089 1
a2089 4
bn_rotate_plane( oplane, mat, iplane )
plane_t		oplane;
const mat_t	mat;
const plane_t	iplane;
d2123 1
a2123 4
bn_coplanar( a, b, tol )
const plane_t		a;
const plane_t		b;
const struct bn_tol	*tol;
d2188 1
a2188 4
bn_angle_measure( vec, x_dir, y_dir )
vect_t	vec;
const vect_t	x_dir;
const vect_t	y_dir;
d2220 1
a2220 4
bn_dist_pt3_along_line3( p, d, x )
const point_t	p;
const vect_t	d;
const point_t	x;
d2238 1
a2238 4
bn_dist_pt2_along_line2( p, d, x )
const point_t	p;
const vect_t	d;
const point_t	x;
d2261 1
a2261 5
bn_between( left, mid, right, tol )
double	left;
double	mid;
double	right;
const struct bn_tol	*tol;
d2464 1
a2464 4
bn_hlf_class( half_eqn, min, max, tol )
const plane_t		half_eqn;
const vect_t		min, max;
const struct bn_tol    *tol;
d2521 1
a2521 7
bn_distsq_line3_line3( dist, P, d_in, Q, e_in, pt1, pt2 )
fastf_t dist[3];
point_t P;
vect_t d_in;
point_t Q;
vect_t e_in;
point_t pt1, pt2;
d2601 1
a2601 4
bn_isect_planes( pt , planes , pl_count )
point_t pt;
const plane_t planes[];
const int pl_count;
d2667 1
a2667 4
bn_isect_lseg_rpp( a, b, min, max )
point_t		a;
point_t		b;
register fastf_t *min, *max;
@


11.34.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.34 2002/08/20 17:07:36 jra Exp $ (BRL)";
d45 3
a47 1
bn_dist_pt3_pt3(const fastf_t *a, const fastf_t *b)
d63 4
a66 1
bn_pt3_pt3_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d84 4
a87 1
bn_pt2_pt2_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d110 3
a112 1
bn_3pts_collinear(fastf_t *a, fastf_t *b, fastf_t *c, const struct bn_tol *tol)
d178 3
a180 1
bn_3pts_distinct(const fastf_t *a, const fastf_t *b, const fastf_t *c, const struct bn_tol *tol)
d235 4
a238 1
bn_mk_plane_3pts(fastf_t *plane, const fastf_t *a, const fastf_t *b, const fastf_t *c, const struct bn_tol *tol)
d307 3
a309 1
bn_mkpoint_3planes(fastf_t *pt, const fastf_t *a, const fastf_t *b, const fastf_t *c)
d347 7
a353 1
bn_2line3_colinear(const fastf_t *p1, const fastf_t *d1, const fastf_t *p2, const fastf_t *d2, double range, const struct bn_tol *tol)
d408 6
a413 1
bn_isect_line3_plane(fastf_t *dist, const fastf_t *pt, const fastf_t *dir, const fastf_t *plane, const struct bn_tol *tol)
d470 7
a476 1
bn_isect_2planes(fastf_t *pt, fastf_t *dir, const fastf_t *a, const fastf_t *b, const fastf_t *rpp_min, const struct bn_tol *tol)
d576 7
a582 7
bn_isect_line2_line2(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
       			      			/* dist[2] */
             		  
            		  
             		  
            		  
                   	     
d793 7
a799 7
bn_isect_line2_lseg2(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
       			      		/* dist[2] */
             		  
            		  
             		  
            		  
                   	     
d996 7
a1002 1
bn_isect_lseg2_lseg2(fastf_t *dist, const fastf_t *p, const fastf_t *pdir, const fastf_t *q, const fastf_t *qdir, const struct bn_tol *tol)
d1093 7
a1099 1
bn_isect_lseg3_lseg3(fastf_t *dist, const fastf_t *p, const fastf_t *pdir, const fastf_t *q, const fastf_t *qdir, const struct bn_tol *tol)
d1201 8
a1208 1
bn_isect_line3_line3(fastf_t *t, fastf_t *u, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
d1451 7
a1457 1
bn_isect_line_lseg(fastf_t *t, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d1545 4
a1548 1
bn_dist_line3_pt3(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
d1584 4
a1587 1
bn_distsq_line3_pt3(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
d1620 3
a1622 1
bn_dist_line_origin(const fastf_t *pt, const fastf_t *dir)
d1645 4
a1648 1
bn_dist_line2_point2(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
d1674 4
a1677 1
bn_distsq_line2_point2(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
d1698 2
a1699 1
bn_area_of_triangle(register const fastf_t *a, register const fastf_t *b, register const fastf_t *c)
d1748 4
a1751 4
int bn_isect_pt_lseg(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
       			      		/* distance along line from A to P */
             		        	/* points for line and intersect */
                   	     
d1829 4
a1832 4
bn_isect_pt2_lseg2(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
       			      		/* distance along line from A to P */
             		        	/* points for line and intersect */
                   	     
d1923 5
a1927 1
bn_dist_pt3_lseg3(fastf_t *dist, fastf_t *pca, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
d2043 5
a2047 1
bn_dist_pt2_lseg2(fastf_t *dist_sq, fastf_t *pca, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
d2144 6
a2149 1
bn_rotate_bbox(fastf_t *omin, fastf_t *omax, const fastf_t *mat, const fastf_t *imin, const fastf_t *imax)
d2176 4
a2179 1
bn_rotate_plane(fastf_t *oplane, const fastf_t *mat, const fastf_t *iplane)
d2213 4
a2216 1
bn_coplanar(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d2281 4
a2284 1
bn_angle_measure(fastf_t *vec, const fastf_t *x_dir, const fastf_t *y_dir)
d2316 4
a2319 1
bn_dist_pt3_along_line3(const fastf_t *p, const fastf_t *d, const fastf_t *x)
d2337 4
a2340 1
bn_dist_pt2_along_line2(const fastf_t *p, const fastf_t *d, const fastf_t *x)
d2363 5
a2367 1
bn_between(double left, double mid, double right, const struct bn_tol *tol)
d2570 4
a2573 1
bn_hlf_class(const fastf_t *half_eqn, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d2630 7
a2636 1
bn_distsq_line3_line3(fastf_t *dist, fastf_t *P, fastf_t *d_in, fastf_t *Q, fastf_t *e_in, fastf_t *pt1, fastf_t *pt2)
d2716 4
a2719 1
bn_isect_planes(fastf_t *pt, const fastf_t (*planes)[4], const int pl_count)
d2785 4
a2788 1
bn_isect_lseg_rpp(fastf_t *a, fastf_t *b, register fastf_t *min, register fastf_t *max)
@


11.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d45 3
a47 1
bn_dist_pt3_pt3(const fastf_t *a, const fastf_t *b)
d63 4
a66 1
bn_pt3_pt3_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d84 4
a87 1
bn_pt2_pt2_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d110 3
a112 1
bn_3pts_collinear(fastf_t *a, fastf_t *b, fastf_t *c, const struct bn_tol *tol)
d178 3
a180 1
bn_3pts_distinct(const fastf_t *a, const fastf_t *b, const fastf_t *c, const struct bn_tol *tol)
d235 4
a238 1
bn_mk_plane_3pts(fastf_t *plane, const fastf_t *a, const fastf_t *b, const fastf_t *c, const struct bn_tol *tol)
d307 3
a309 1
bn_mkpoint_3planes(fastf_t *pt, const fastf_t *a, const fastf_t *b, const fastf_t *c)
d347 7
a353 1
bn_2line3_colinear(const fastf_t *p1, const fastf_t *d1, const fastf_t *p2, const fastf_t *d2, double range, const struct bn_tol *tol)
d408 6
a413 1
bn_isect_line3_plane(fastf_t *dist, const fastf_t *pt, const fastf_t *dir, const fastf_t *plane, const struct bn_tol *tol)
d470 7
a476 1
bn_isect_2planes(fastf_t *pt, fastf_t *dir, const fastf_t *a, const fastf_t *b, const fastf_t *rpp_min, const struct bn_tol *tol)
d576 7
a582 7
bn_isect_line2_line2(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
       			      			/* dist[2] */
             		  
            		  
             		  
            		  
                   	     
d793 7
a799 7
bn_isect_line2_lseg2(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
       			      		/* dist[2] */
             		  
            		  
             		  
            		  
                   	     
d996 7
a1002 1
bn_isect_lseg2_lseg2(fastf_t *dist, const fastf_t *p, const fastf_t *pdir, const fastf_t *q, const fastf_t *qdir, const struct bn_tol *tol)
d1093 7
a1099 1
bn_isect_lseg3_lseg3(fastf_t *dist, const fastf_t *p, const fastf_t *pdir, const fastf_t *q, const fastf_t *qdir, const struct bn_tol *tol)
d1201 8
a1208 1
bn_isect_line3_line3(fastf_t *t, fastf_t *u, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *c, const struct bn_tol *tol)
d1451 7
a1457 1
bn_isect_line_lseg(fastf_t *t, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d1545 4
a1548 1
bn_dist_line3_pt3(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
d1584 4
a1587 1
bn_distsq_line3_pt3(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
d1620 3
a1622 1
bn_dist_line_origin(const fastf_t *pt, const fastf_t *dir)
d1645 4
a1648 1
bn_dist_line2_point2(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
d1674 4
a1677 1
bn_distsq_line2_point2(const fastf_t *pt, const fastf_t *dir, const fastf_t *a)
d1698 2
a1699 1
bn_area_of_triangle(register const fastf_t *a, register const fastf_t *b, register const fastf_t *c)
d1748 4
a1751 4
int bn_isect_pt_lseg(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
       			      		/* distance along line from A to P */
             		        	/* points for line and intersect */
                   	     
d1829 4
a1832 4
bn_isect_pt2_lseg2(fastf_t *dist, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
       			      		/* distance along line from A to P */
             		        	/* points for line and intersect */
                   	     
d1923 5
a1927 1
bn_dist_pt3_lseg3(fastf_t *dist, fastf_t *pca, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
d2043 5
a2047 1
bn_dist_pt2_lseg2(fastf_t *dist_sq, fastf_t *pca, const fastf_t *a, const fastf_t *b, const fastf_t *p, const struct bn_tol *tol)
d2144 6
a2149 1
bn_rotate_bbox(fastf_t *omin, fastf_t *omax, const fastf_t *mat, const fastf_t *imin, const fastf_t *imax)
d2176 4
a2179 1
bn_rotate_plane(fastf_t *oplane, const fastf_t *mat, const fastf_t *iplane)
d2213 4
a2216 1
bn_coplanar(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d2281 4
a2284 1
bn_angle_measure(fastf_t *vec, const fastf_t *x_dir, const fastf_t *y_dir)
d2316 4
a2319 1
bn_dist_pt3_along_line3(const fastf_t *p, const fastf_t *d, const fastf_t *x)
d2337 4
a2340 1
bn_dist_pt2_along_line2(const fastf_t *p, const fastf_t *d, const fastf_t *x)
d2363 5
a2367 1
bn_between(double left, double mid, double right, const struct bn_tol *tol)
d2570 4
a2573 1
bn_hlf_class(const fastf_t *half_eqn, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d2630 7
a2636 1
bn_distsq_line3_line3(fastf_t *dist, fastf_t *P, fastf_t *d_in, fastf_t *Q, fastf_t *e_in, fastf_t *pt1, fastf_t *pt2)
d2716 4
a2719 1
bn_isect_planes(fastf_t *pt, const fastf_t (*planes)[4], const int pl_count)
d2785 4
a2788 1
bn_isect_lseg_rpp(fastf_t *a, fastf_t *b, register fastf_t *min, register fastf_t *max)
@


11.32
log
@updated SIGNED to signed
updated CONST to const
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.31 2001/03/31 01:56:48 morrison Exp $ (BRL)";
d45 1
a45 3
bn_dist_pt3_pt3( a, b )
const point_t	a;
const point_t	b;
d61 1
a61 4
bn_pt3_pt3_equal( a, b, tol )
const point_t		a;
const point_t		b;
const struct bn_tol	*tol;
d79 1
a79 4
bn_pt2_pt2_equal( a, b, tol )
const point_t		a;
const point_t		b;
const struct bn_tol	*tol;
d102 1
a102 3
bn_3pts_collinear(a, b, c, tol)
point_t	a, b, c;
const struct bn_tol	*tol;
d168 1
a168 3
bn_3pts_distinct( a, b, c, tol )
const point_t		a, b, c;
const struct bn_tol	*tol;
d223 1
a223 4
bn_mk_plane_3pts( plane, a, b, c, tol )
plane_t			plane;
const point_t		a, b, c;
const struct bn_tol	*tol;
d292 1
a292 3
bn_mkpoint_3planes( pt, a, b, c )
point_t		pt;
const plane_t	a, b, c;
d330 1
a330 7
bn_2line3_colinear( p1, d1, p2, d2, range, tol )
const point_t		p1;
const vect_t		d1;
const point_t		p2;
const vect_t		d2;
double			range;
const struct bn_tol	*tol;
d385 1
a385 6
bn_isect_line3_plane( dist, pt, dir, plane, tol )
fastf_t		*dist;
const point_t	pt;
const vect_t	dir;
const plane_t	plane;
const struct bn_tol	*tol;
d442 1
a442 7
bn_isect_2planes( pt, dir, a, b, rpp_min, tol )
point_t		pt;
vect_t		dir;
const plane_t	a;
const plane_t	b;
const vect_t	rpp_min;
const struct bn_tol	*tol;
d542 7
a548 7
bn_isect_line2_line2( dist, p, d, a, c, tol )
fastf_t			*dist;			/* dist[2] */
const point_t		p;
const vect_t		d;
const point_t		a;
const vect_t		c;
const struct bn_tol	*tol;
d759 7
a765 7
bn_isect_line2_lseg2( dist, p, d, a, c, tol )
fastf_t			*dist;		/* dist[2] */
const point_t		p;
const vect_t		d;
const point_t		a;
const vect_t		c;
const struct bn_tol	*tol;
d962 1
a962 7
bn_isect_lseg2_lseg2( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
const point_t	p;
const vect_t	pdir;
const point_t	q;
const vect_t	qdir;
const struct bn_tol	*tol;
d1053 1
a1053 7
bn_isect_lseg3_lseg3( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
const point_t	p;
const vect_t	pdir;
const point_t	q;
const vect_t	qdir;
const struct bn_tol	*tol;
d1155 1
a1155 8
bn_isect_line3_line3( t, u, p, d, a, c, tol )
fastf_t			*t;
fastf_t			*u;
const point_t		p;
const vect_t		d;
const point_t		a;
const vect_t		c;
const struct bn_tol	*tol;
d1398 1
a1398 7
bn_isect_line_lseg( t, p, d, a, b, tol )
fastf_t			*t;
const point_t		p;
const vect_t		d;
const point_t		a;
const point_t		b;
const struct bn_tol	*tol;
d1486 1
a1486 4
bn_dist_line3_pt3( pt, dir, a )
const point_t	pt;
const vect_t	dir;
const point_t	a;
d1522 1
a1522 4
bn_distsq_line3_pt3( pt, dir, a )
const point_t	pt;
const vect_t	dir;
const point_t	a;
d1555 1
a1555 3
bn_dist_line_origin( pt, dir )
const point_t	pt;
const vect_t	dir;
d1578 1
a1578 4
bn_dist_line2_point2( pt, dir, a )
const point_t	pt;
const vect_t	dir;
const point_t	a;
d1604 1
a1604 4
bn_distsq_line2_point2( pt, dir, a )
const point_t	pt;
const vect_t	dir;
const point_t	a;
d1625 1
a1625 2
bn_area_of_triangle( a, b, c )
register const point_t a, b, c;
d1674 4
a1677 4
int bn_isect_pt_lseg(dist, a, b, p, tol)
fastf_t			*dist;		/* distance along line from A to P */
const point_t		a, b, p;	/* points for line and intersect */
const struct bn_tol	*tol;
d1755 4
a1758 4
bn_isect_pt2_lseg2(dist, a, b, p, tol)
fastf_t			*dist;		/* distance along line from A to P */
const point_t		a, b, p;	/* points for line and intersect */
const struct bn_tol	*tol;
d1849 1
a1849 5
bn_dist_pt3_lseg3( dist, pca, a, b, p, tol )
fastf_t		*dist;
point_t		pca;
const point_t	a, b, p;
const struct bn_tol *tol;
d1965 1
a1965 5
bn_dist_pt2_lseg2( dist_sq, pca, a, b, p, tol )
fastf_t		*dist_sq;
fastf_t		pca[2];
const point_t	a, b, p;
const struct bn_tol *tol;
d2062 1
a2062 6
bn_rotate_bbox( omin, omax, mat, imin, imax )
point_t		omin;
point_t		omax;
const mat_t	mat;
const point_t	imin;
const point_t	imax;
d2089 1
a2089 4
bn_rotate_plane( oplane, mat, iplane )
plane_t		oplane;
const mat_t	mat;
const plane_t	iplane;
d2123 1
a2123 4
bn_coplanar( a, b, tol )
const plane_t		a;
const plane_t		b;
const struct bn_tol	*tol;
d2188 1
a2188 4
bn_angle_measure( vec, x_dir, y_dir )
vect_t	vec;
const vect_t	x_dir;
const vect_t	y_dir;
d2220 1
a2220 4
bn_dist_pt3_along_line3( p, d, x )
const point_t	p;
const vect_t	d;
const point_t	x;
d2238 1
a2238 4
bn_dist_pt2_along_line2( p, d, x )
const point_t	p;
const vect_t	d;
const point_t	x;
d2261 1
a2261 5
bn_between( left, mid, right, tol )
double	left;
double	mid;
double	right;
const struct bn_tol	*tol;
d2464 1
a2464 4
bn_hlf_class( half_eqn, min, max, tol )
const plane_t		half_eqn;
const vect_t		min, max;
const struct bn_tol    *tol;
d2521 1
a2521 7
bn_distsq_line3_line3( dist, P, d_in, Q, e_in, pt1, pt2 )
fastf_t dist[3];
point_t P;
vect_t d_in;
point_t Q;
vect_t e_in;
point_t pt1, pt2;
d2601 1
a2601 4
bn_isect_planes( pt , planes , pl_count )
point_t pt;
const plane_t planes[];
const int pl_count;
d2667 1
a2667 4
bn_isect_lseg_rpp( a, b, min, max )
point_t		a;
point_t		b;
register fastf_t *min, *max;
@


11.31
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.30 2000/10/24 18:25:31 mike Exp $ (BRL)";
d46 2
a47 2
CONST point_t	a;
CONST point_t	b;
d64 3
a66 3
CONST point_t		a;
CONST point_t		b;
CONST struct bn_tol	*tol;
d85 3
a87 3
CONST point_t		a;
CONST point_t		b;
CONST struct bn_tol	*tol;
d112 1
a112 1
CONST struct bn_tol	*tol;
d179 2
a180 2
CONST point_t		a, b, c;
CONST struct bn_tol	*tol;
d237 2
a238 2
CONST point_t		a, b, c;
CONST struct bn_tol	*tol;
d309 1
a309 1
CONST plane_t	a, b, c;
d348 4
a351 4
CONST point_t		p1;
CONST vect_t		d1;
CONST point_t		p2;
CONST vect_t		d2;
d353 1
a353 1
CONST struct bn_tol	*tol;
d410 4
a413 4
CONST point_t	pt;
CONST vect_t	dir;
CONST plane_t	plane;
CONST struct bn_tol	*tol;
d473 4
a476 4
CONST plane_t	a;
CONST plane_t	b;
CONST vect_t	rpp_min;
CONST struct bn_tol	*tol;
d578 5
a582 5
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct bn_tol	*tol;
d795 5
a799 5
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct bn_tol	*tol;
d998 5
a1002 5
CONST point_t	p;
CONST vect_t	pdir;
CONST point_t	q;
CONST vect_t	qdir;
CONST struct bn_tol	*tol;
d1095 5
a1099 5
CONST point_t	p;
CONST vect_t	pdir;
CONST point_t	q;
CONST vect_t	qdir;
CONST struct bn_tol	*tol;
d1204 5
a1208 5
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct bn_tol	*tol;
d1453 5
a1457 5
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST point_t		b;
CONST struct bn_tol	*tol;
d1546 3
a1548 3
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
d1585 3
a1587 3
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
d1621 2
a1622 2
CONST point_t	pt;
CONST vect_t	dir;
d1646 3
a1648 3
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
d1675 3
a1677 3
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
d1699 1
a1699 1
register CONST point_t a, b, c;
d1750 2
a1751 2
CONST point_t		a, b, p;	/* points for line and intersect */
CONST struct bn_tol	*tol;
d1831 2
a1832 2
CONST point_t		a, b, p;	/* points for line and intersect */
CONST struct bn_tol	*tol;
d1926 2
a1927 2
CONST point_t	a, b, p;
CONST struct bn_tol *tol;
d2046 2
a2047 2
CONST point_t	a, b, p;
CONST struct bn_tol *tol;
d2147 3
a2149 3
CONST mat_t	mat;
CONST point_t	imin;
CONST point_t	imax;
d2178 2
a2179 2
CONST mat_t	mat;
CONST plane_t	iplane;
d2214 3
a2216 3
CONST plane_t		a;
CONST plane_t		b;
CONST struct bn_tol	*tol;
d2283 2
a2284 2
CONST vect_t	x_dir;
CONST vect_t	y_dir;
d2317 3
a2319 3
CONST point_t	p;
CONST vect_t	d;
CONST point_t	x;
d2338 3
a2340 3
CONST point_t	p;
CONST vect_t	d;
CONST point_t	x;
d2367 1
a2367 1
CONST struct bn_tol	*tol;
d2498 5
a2502 5
CONST point_t pt;
CONST vect_t dir;
CONST point_t V;
CONST point_t A;
CONST point_t B;
d2571 3
a2573 3
CONST plane_t		half_eqn;
CONST vect_t		min, max;
CONST struct bn_tol    *tol;
d2718 2
a2719 2
CONST plane_t planes[];
CONST int pl_count;
@


11.30
log
@
Added bn_does_ray_isect_tri() to bn.h
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.29 2000/08/30 23:35:51 mike Exp $ (BRL)";
d2735 1
a2735 1
	bn_mat_zero( matrix );
@


11.29
log
@
Fixed lint
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.28 2000/08/25 13:04:39 jra Exp $ (BRL)";
d2394 7
d2402 7
a2408 7
bn_does_ray_isect_tri( pt, dir, V, A, B, inter )
CONST point_t pt;
CONST vect_t dir;
CONST point_t V;
CONST point_t A;
CONST point_t B;
point_t inter;			/* output variable */
@


11.28
log
@Fixed a bug in bn_distsq_line3_line3()
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.27 2000/07/11 23:30:39 cjohnson Exp $ (BRL)";
d2631 1
a2631 1
	fastf_t de, Qe, Pe, denom;
a2671 2
			Qe = VDOT( Q, e );
			Pe = VDOT( P, e );
@


11.27
log
@LINT picking.  Missing includes and static const for RCSids
@
text
@d18 1
a18 1
static const char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.26 2000/05/11 19:17:57 mike Exp $ (BRL)";
d2623 1
a2623 1
bn_distsq_line3_line3( dist, P, d, Q, e, pt1, pt2 )
d2626 1
a2626 1
vect_t d;
d2628 1
a2628 1
vect_t e;
d2631 1
a2631 1
	fastf_t de, dd, ee, Qe, Pe, denom;
d2633 2
d2637 12
d2654 2
a2655 2
		dist[0] = (VDOT( Q, d ) - VDOT( P, d ))/VDOT( d, d );
		dist[1] = (VDOT( P, e ) - VDOT( Q, e ))/VDOT( e, e );
a2658 2
		dd = VDOT( d, d );
		ee = VDOT( e, e );
d2660 1
a2660 1
		denom = dd*ee - de*de;
d2665 1
a2665 1
			dist[1] = VDOT( PmQ, d ) / VDOT( d, e );
d2670 1
a2670 1
			VBLEND2( tmp, dd, e, -de, d );
d2674 1
a2674 1
			dist[0] = (dist[1] * ee + (Qe - Pe))/de;
d2680 2
@


11.26
log
@
INFINITY is defined only in raytrace.h.
Use MAX_FASTF in the more general context of LIBBN.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.25 2000/05/11 03:21:05 mike Exp $ (BRL)";
d25 5
@


11.26.2.1
log
@bn_distsq_line3_line3() corrected by unitizing direction vectors
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.26 2000/05/11 19:17:57 mike Exp $ (BRL)";
d2618 1
a2618 1
bn_distsq_line3_line3( dist, P, d_in, Q, e_in, pt1, pt2 )
d2621 1
a2621 1
vect_t d_in;
d2623 1
a2623 1
vect_t e_in;
a2627 2
	vect_t d, e;
	fastf_t len_e, inv_len_e, len_d, inv_len_d;
a2629 12
	len_e = MAGNITUDE( e_in );
	if( NEAR_ZERO( len_e, SMALL_FASTF ) )
		bu_bomb( "bn_distsq_line3_line3() called with zero length vector!!!\n");
	inv_len_e = 1.0 / len_e;

	len_d = MAGNITUDE( d_in );
	if( NEAR_ZERO( len_d, SMALL_FASTF ) )
		bu_bomb( "bn_distsq_line3_line3() called with zero length vector!!!\n");
	inv_len_d = 1.0 / len_d;

	VSCALE( e, e_in, inv_len_e );
	VSCALE( d, d_in, inv_len_d );
d2635 2
a2636 2
		dist[0] = VDOT( Q, d ) - VDOT( P, d );
		dist[1] = VDOT( P, e ) - VDOT( Q, e );
d2640 2
d2643 1
a2643 1
		denom = 1.0 - de*de;
d2648 1
a2648 1
			dist[1] = VDOT( PmQ, d );
d2653 1
a2653 1
			VBLEND2( tmp, 1.0, e, -de, d );
d2657 1
a2657 1
			dist[0] = (dist[1] + (Qe - Pe))/de;
a2662 2
	dist[0] *= inv_len_d;
	dist[1] *= inv_len_e;
@


11.26.2.2
log
@Fixed a bug in bn_distsq_line3_line3()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.26.2.1 2000/08/24 13:29:28 jra Exp $ (BRL)";
d2626 1
a2626 1
	fastf_t de, Qe, Pe, denom;
d2669 1
a2669 1
			dist[0] = dist[1] * de - VDOT( PmQ, d );
@


11.25
log
@
Imported bn_isect_lseg_rpp() from librt/cut.c
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.24 2000/05/10 00:55:03 mike Exp $ (BRL)";
d2774 2
a2775 2
	mindist = -INFINITY;
	maxdist = INFINITY;
@


11.24
log
@
Added comment
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.23 2000/03/29 02:06:57 mike Exp $ (BRL)";
d2743 79
@


11.23
log
@
Imported bn_isect_planes from nmg_misc.c
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.22 2000/02/28 21:03:31 jra Exp $ (BRL)";
d2546 11
@


11.22
log
@Added bn_distsq_line3_line3()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.21 2000/01/07 20:01:07 mike Exp $ (BRL)";
d2654 78
@


11.21
log
@
added CONST
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.20 1999/12/29 20:21:42 jra Exp $ (BRL)";
d2582 72
@


11.20
log
@Eliminated some unused variables
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.19 1999/12/09 19:19:53 jra Exp $ (BRL)";
d2391 6
a2396 2
point_t pt, V, A, B, inter;
vect_t dir;
@


11.19
log
@ifdef'd out bn_isect_ray_tri() again (it doesn't work right) and added bn_does_ray_isect_tri()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.18 1999/12/06 20:35:15 jra Exp $ (BRL)";
a584 1
	fastf_t			dot;
a2397 1
	fastf_t area;
@


11.18
log
@
enabled the ifdef'd out bn_iset_ray_tri()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.17 1999/07/02 19:11:25 mike Exp $ (BRL)";
d2390 47
a2436 1
#if 1
@


11.17
log
@
Removed dependency on compat4.h
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/libbn/plane.c,v 11.16 1998/03/06 16:06:05 jra Exp $ (BRL)";
d2390 1
a2390 1
#if 0
d2481 1
a2481 1
	beta = VDOT(VB, VP_right ) * (-1 * entleave);
d2484 1
a2484 1
	k = VDOT(VPP, N) / NdotDIR;
@


11.16
log
@Fixed bug in bn_isect_line3_line3(). Wasn't working correctly for Colinear lines that are axis aligned.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.15 1997/09/17 20:32:54 jra Exp jra $ (BRL)";
d2289 1
a2289 1
	ang = rt_pi + gamma;		/* 0..+2pi */
d2292 1
a2292 1
			ang += rt_twopi;
d2294 1
a2294 1
	} else if( ang > rt_twopi )  {
d2296 2
a2297 2
			ang -= rt_twopi;
		} while( ang > rt_twopi );
d2299 1
a2299 1
	if( ang < 0 || ang > rt_twopi )  bu_bomb("bn_angle_measure() angle out of range\n");
@


11.15
log
@Clarified comenst about bn_isect_pt_lseg()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.14 1997/07/23 06:54:22 gdurf Exp jra $ (BRL)";
d1241 2
a1242 2
		/* if normal still has zero length, then lines are parallel and collinear
		 * and the following code will work OK */
@


11.14
log
@Added classifier for halfspaces specified by a plane eqn.
Many librt classifier routines will use this.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.13 1997/07/02 21:16:10 butler Exp gdurf $ (BRL)";
d1742 1
a1742 1
 *	dist = distance from A to P'
@


11.13
log
@ifdef'ed version of ray/triangle intersector
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.12 1997/01/07 23:09:38 mike Exp butler $ (BRL)";
d2497 38
@


11.12
log
@Taking address of register variable not allowed.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.11 1997/01/07 22:57:23 jra Exp mike $ (BRL)";
d2389 108
@


11.11
log
@Mod to bn_isect_line3_plane() to account for tol->perp.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.10 1996/12/31 02:50:16 mike Exp jra $ (BRL)";
d413 1
a413 1
	register vect_t		local_dir;
@


11.10
log
@No more depending on LIBRT
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.9 1996/12/23 21:38:24 butler Exp mike $ (BRL)";
d32 2
d390 1
d412 2
d419 3
d423 1
a423 1
	if( slant_factor < -SMALL_FASTF )  {
d426 1
a426 1
	} else if( slant_factor > SMALL_FASTF )  {
@


11.9
log
@converted to using bu_debug to removed rt_g/raytrace.h dependency
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.8 1996/10/03 00:29:25 mike Exp butler $ (BRL)";
d27 1
a30 2
#include "raytrace.h"		/* for rt_g.debug */
#include "../librt/debug.h"
@


11.8
log
@Can't use rt_bomb, use bu_bomb()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/libbn/RCS/plane.c,v 11.7 1996/09/13 04:27:35 butler Exp mike $ (BRL)";
d372 1
a372 1
	if( rt_g.debug & DEBUG_MATH )  {
d377 1
a377 1
	if( rt_g.debug & DEBUG_MATH )  {
d583 1
a583 1
	if( rt_g.debug & DEBUG_MATH )  {
d682 1
a682 1
			if( rt_g.debug & DEBUG_MATH )  {
d702 1
a702 1
		if( rt_g.debug & DEBUG_MATH )  {
d707 1
a707 1
	if( rt_g.debug & DEBUG_MATH )  {
d714 1
a714 1
	if( rt_g.debug & DEBUG_MATH )  {
d736 1
a736 1
			if( rt_g.debug & DEBUG_MATH || dist_sq < 100*tol->dist_sq )  {
d796 1
a796 1
	if( rt_g.debug & DEBUG_MATH )  {
d821 1
a821 1
		if( rt_g.debug & DEBUG_MATH )  {
d842 1
a842 1
		if( rt_g.debug & DEBUG_MATH )  {
d883 1
a883 1
		if( rt_g.debug & DEBUG_MATH )  {
d926 1
a926 1
	if( rt_g.debug & DEBUG_MATH )  {
d951 1
a951 1
	if( rt_g.debug & DEBUG_MATH )  {
d997 1
a997 1
	if( rt_g.debug & DEBUG_MATH )  {
d1012 1
a1012 1
		if( rt_g.debug & DEBUG_MATH )  {
d1025 1
a1025 1
		if( rt_g.debug & DEBUG_MATH )  {
d1040 1
a1040 1
	if( rt_g.debug & DEBUG_MATH )  {
d1044 1
a1044 1
		if( rt_g.debug & DEBUG_MATH )  {
d1049 1
a1049 1
	if( rt_g.debug & DEBUG_MATH )  {
d1095 1
a1095 1
	if( rt_g.debug & DEBUG_MATH )  {
d1113 1
a1113 1
		if( rt_g.debug & DEBUG_MATH )  {
d1126 1
a1126 1
		if( rt_g.debug & DEBUG_MATH )  {
d1144 1
a1144 1
	if( rt_g.debug & DEBUG_MATH )  {
d1148 1
a1148 1
		if( rt_g.debug & DEBUG_MATH )  {
d1153 1
a1153 1
	if( rt_g.debug & DEBUG_MATH )  {
d1475 1
a1475 1
		if( rt_g.debug & DEBUG_MATH )  {
d1555 1
a1555 1
	if( rt_g.debug & DEBUG_MATH )  {
d1591 1
a1591 1
	if( rt_g.debug & DEBUG_MATH )  {
d1844 1
a1844 1
		if( rt_g.debug & DEBUG_MATH )  {
d1864 1
a1864 1
		if( rt_g.debug & DEBUG_MATH )  {
d1928 1
a1928 1
	if( rt_g.debug & DEBUG_MATH )  {
d1941 1
a1941 1
		if( rt_g.debug & DEBUG_MATH )  bu_log("  at A\n");
d1951 1
a1951 1
		if( rt_g.debug & DEBUG_MATH )  bu_log("  at B\n");
d1963 1
a1963 1
	if( rt_g.debug & DEBUG_MATH )  {
d1970 1
a1970 1
		if( rt_g.debug & DEBUG_MATH )  bu_log("  left of A\n");
d1986 1
a1986 1
			if( rt_g.debug & DEBUG_MATH )  bu_log("  ON lseg\n");
d1991 1
a1991 1
		if( rt_g.debug & DEBUG_MATH )  bu_log("  closest to lseg\n");
d1996 1
a1996 1
	if( rt_g.debug & DEBUG_MATH )  bu_log("  right of B\n");
d2048 1
a2048 1
	if( rt_g.debug & DEBUG_MATH )  {
d2062 1
a2062 1
		if( rt_g.debug & DEBUG_MATH )  bu_log("  at A\n");
d2072 1
a2072 1
		if( rt_g.debug & DEBUG_MATH )  bu_log("  at B\n");
d2084 1
a2084 1
	if( rt_g.debug & DEBUG_MATH )  {
d2091 1
a2091 1
		if( rt_g.debug & DEBUG_MATH )  bu_log("  left of A\n");
d2107 1
a2107 1
			if( rt_g.debug & DEBUG_MATH )  bu_log("  ON lseg\n");
d2112 1
a2112 1
		if( rt_g.debug & DEBUG_MATH )  bu_log("  closest to lseg\n");
d2117 1
a2117 1
	if( rt_g.debug & DEBUG_MATH )  bu_log("  right of B\n");
d2336 1
a2336 1
	if( rt_g.debug & DEBUG_MATH )  {
d2376 1
a2376 1
	if( rt_g.debug & DEBUG_MATH )  {
@


11.7
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.6 1996/04/19 15:28:06 jra Exp butler $ (BRL)";
d355 2
a356 2
	if( (mag1 = MAGNITUDE(d1)) < SMALL_FASTF )  rt_bomb("bn_2line3_colinear() mag1 zero\n");
	if( (mag2 = MAGNITUDE(d2)) < SMALL_FASTF )  rt_bomb("bn_2line3_colinear() mag2 zero\n");
d913 1
a913 1
		    	rt_bomb("bn_isect_line2_lseg2() hit_pt not between A and B!\n");
d1107 1
a1107 1
		rt_bomb("bn_isect_lseg3_lseg3: |p|=0\n");
d1139 1
a1139 1
		rt_bomb("bn_isect_lseg3_lseg3: |q|=0\n");
d2292 1
a2292 1
	if( ang < 0 || ang > rt_twopi )  rt_bomb("bn_angle_measure() angle out of range\n");
@


11.6
log
@Commented out irritating "BOGUS HIT" message from rt_isect_line3_line3().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.5 1996/04/12 14:56:26 jra Exp jra $ (BRL)";
d27 1
d29 3
a31 2
#include "raytrace.h"
#include "./debug.h"
d34 1
a34 1
 *			R T _ D I S T _ P T 3 _ P T 3
d39 1
a39 1
rt_dist_pt3_pt3( a, b )
d50 1
a50 1
 *			R T _ P T 3 _ P T 3 _ E Q U A L
d57 1
a57 1
rt_pt3_pt3_equal( a, b, tol )
d60 1
a60 1
CONST struct rt_tol	*tol;
d64 1
a64 1
	RT_CK_TOL(tol);
d71 1
a71 1
 *			R T _ P T 2 _ P T 2 _ E Q U A L
d78 1
a78 1
rt_pt2_pt2_equal( a, b, tol )
d81 1
a81 1
CONST struct rt_tol	*tol;
d85 1
a85 1
	RT_CK_TOL(tol);
d92 1
a92 1
 *			R T _ 3 P T S _ C O L L I N E A R
d104 1
a104 1
rt_3pts_collinear(a, b, c, tol)
d106 1
a106 1
struct rt_tol	*tol;
d161 1
a161 1
 *			R T _ 3 P T S _ D I S T I N C T
d172 1
a172 1
rt_3pts_distinct( a, b, c, tol )
d174 1
a174 1
CONST struct rt_tol	*tol;
d180 1
a180 1
	RT_CK_TOL(tol);
d191 1
a191 1
 *			R T _ M K _ P L A N E _ 3 P T S
d229 1
a229 1
rt_mk_plane_3pts( plane, a, b, c, tol )
d232 1
a232 1
CONST struct rt_tol	*tol;
d239 1
a239 1
	RT_CK_TOL(tol);
d267 1
a267 1
			rt_log("rt_mk_plane_3pts() WARNING: plane[3] value is suspect\n");
d275 1
a275 1
 *			R T _ M K P O I N T _ 3 P L A N E S
d301 1
a301 1
rt_mkpoint_3planes( pt, a, b, c )
d330 1
a330 1
 *			R T _ 2 L I N E 3 _ C O L I N E A R
d341 1
a341 1
rt_2line3_colinear( p1, d1, p2, d2, range, tol )
d347 1
a347 1
CONST struct rt_tol	*tol;
d353 1
a353 1
	RT_CK_TOL(tol);
d355 2
a356 2
	if( (mag1 = MAGNITUDE(d1)) < SMALL_FASTF )  rt_bomb("rt_2line3_colinear() mag1 zero\n");
	if( (mag2 = MAGNITUDE(d2)) < SMALL_FASTF )  rt_bomb("rt_2line3_colinear() mag2 zero\n");
d363 2
a364 2
	if( rt_distsq_line3_pt3( p1, d1, p2 ) > tol->dist_sq )  goto fail;
	if( rt_distsq_line3_pt3( p2, d2, p1 ) > tol->dist_sq )  goto fail;
d367 1
a367 1
	if( rt_distsq_line3_pt3( p2, d2, tail ) > tol->dist_sq )  goto fail;
d370 1
a370 1
	if( rt_distsq_line3_pt3( p1, d1, tail ) > tol->dist_sq )  goto fail;
d373 1
a373 1
		rt_log("rt_2line3colinear(range=%g) ret=1\n",range);
d378 1
a378 1
		rt_log("rt_2line3colinear(range=%g) ret=0\n",range);
d384 1
a384 1
 *			R T _ I S E C T _ L I N E 3 _ P L A N E
d401 1
a401 1
rt_isect_line3_plane( dist, pt, dir, plane, tol )
d406 1
a406 1
CONST struct rt_tol	*tol;
d411 1
a411 1
	RT_CK_TOL(tol);
d436 1
a436 1
 *			R T _ I S E C T _ 2 P L A N E S
d458 1
a458 1
rt_isect_2planes( pt, dir, a, b, rpp_min, tol )
d464 1
a464 1
CONST struct rt_tol	*tol;
d470 1
a470 1
	if( (i = rt_coplanar( a, b, tol )) != 0 )  {
d522 1
a522 1
	if( rt_mkpoint_3planes( pt, pl, a, b ) < 0 )
d529 1
a529 1
 *			R T _ I S E C T _ L I N E 2 _ L I N E 2
d564 1
a564 1
rt_isect_line2_line2( dist, p, d, a, c, tol )
d570 1
a570 1
CONST struct rt_tol	*tol;
d582 1
a582 1
	RT_CK_TOL(tol);
d584 1
a584 1
		rt_log("rt_isect_line2_line2() p=(%g,%g), d=(%g,%g)\n\t\t\ta=(%g,%g), c=(%g,%g)\n",
d683 1
a683 1
				rt_log("\tparallel, not co-linear.  det=%e, det1=%g\n", det, det1);
d703 1
a703 1
			rt_log("\tcolinear, t = %g, u = %g\n", dist[0], dist[1] );
d709 1
a709 1
rt_log("\thx=%g, hy=%g, det=%g, det1=%g, det2=%g\n", hx, hy, det, det1, (d[X] * hy - hx * d[Y]) );
d715 1
a715 1
		rt_log("\tintersection, t = %g, u = %g\n", dist[0], dist[1] );
d737 1
a737 1
				rt_log("rt_isect_line2_line2(): dist=%g >%g, inconsistent solution, hit1=(%g,%g), hit2=(%g,%g)\n",
d750 1
a750 1
 *			R T _ I S E C T _ L I N E 2 _ L S E G 2
d782 1
a782 1
rt_isect_line2_lseg2( dist, p, d, a, c, tol )
d788 1
a788 1
CONST struct rt_tol	*tol;
d795 1
a795 1
	RT_CK_TOL(tol);
d797 1
a797 1
		rt_log("rt_isect_line2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\t\ta=(%g,%g), adir=(%g,%g)\n",
d819 2
a820 2
	if( rt_distsq_line2_point2( p, d, a ) <= tol->dist_sq  &&
	    (ctol=rt_distsq_line2_point2( p, d, b )) <= tol->dist_sq )  {
d822 2
a823 2
rt_log("b=(%g, %g), b_dist_sq=%g\n", V2ARGS(b), ctol);
			rt_log("rt_isect_line2_lseg2() pts A and B within tol of line\n");
d826 2
a827 2
	    	dist[0] = rt_dist_pt2_along_line2( p, d, a );
	    	dist[1] = rt_dist_pt2_along_line2( p, d, b );
d832 1
a832 1
	if( (ret = rt_isect_line2_line2( dist, p, d, a, c, tol )) < 0 )  {
d843 1
a843 1
			rt_log("rt_isect_line2_lseg2() dtol=%g, dist[0]=%g, dist[1]=%g\n",
d871 2
a872 2
		if( rt_pt2_pt2_equal( a, hit_pt, tol ) ||
		    rt_pt2_pt2_equal( a, hit2, tol ) )  {
d876 2
a877 2
		if( rt_pt2_pt2_equal( b, hit_pt, tol ) ||
		    rt_pt2_pt2_equal( b, hit_pt, tol ) )  {
d882 1
a882 1
		ret = rt_isect_pt2_lseg2( &ab_dist, a, b, hit_pt, tol );
d888 2
a889 2
rt_log("rt_isect_pt2_lseg2() hit2d=(%g,%g) ab_dist=%g, ret=%d\n", hit_pt[X], hit_pt[Y], ab_dist, ret);
rt_log("\tother hit2d=(%g,%g)\n", hit2[X], hit2[Y] );
d911 3
a913 3
		if( !rt_between( a[X], hit_pt[X], b[X], tol ) ||
		    !rt_between( a[Y], hit_pt[Y], b[Y], tol ) ) {
		    	rt_bomb("rt_isect_line2_lseg2() hit_pt not between A and B!\n");
d927 1
a927 1
		rt_log("rt_isect_line2_lseg2() ctol=%g, dist[1]=%g\n", ctol, dist[1]);
d952 1
a952 1
		rt_log("rt_isect_line2_lseg2() dist[0]=%g, dist[1]=%g, ret=%d\n",
d959 1
a959 1
 *			R T _ I S E C T _ L S E G 2  _ L S E G 2
d985 1
a985 1
rt_isect_lseg2_lseg2( dist, p, pdir, q, qdir, tol )
d991 1
a991 1
struct rt_tol	*tol;
d996 1
a996 1
	RT_CK_TOL(tol);
d998 1
a998 1
		rt_log("rt_isect_lseg2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
d1002 1
a1002 1
	status = rt_isect_line2_line2( dist, p, pdir, q, qdir, tol );
d1013 1
a1013 1
			rt_log("ptol=%g\n", ptol);
d1026 1
a1026 1
			rt_log("  HIT colinear!\n");
d1041 1
a1041 1
		rt_log("ptol=%g, qtol=%g\n", ptol, qtol);
d1045 1
a1045 1
			rt_log("  MISS\n");
d1050 1
a1050 1
		rt_log("  HIT!\n");
d1056 1
a1056 1
 *			R T _ I S E C T _ L S E G 3  _ L S E G 3
d1082 1
a1082 1
rt_isect_lseg3_lseg3( dist, p, pdir, q, qdir, tol )
d1088 1
a1088 1
struct rt_tol	*tol;
d1094 1
a1094 1
	RT_CK_TOL(tol);
d1096 1
a1096 1
		rt_log("rt_isect_lseg3_lseg3() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
d1100 1
a1100 1
	status = rt_isect_line3_line3( &dist[0], &dist[1], p, pdir, q, qdir, tol );
d1107 1
a1107 1
		rt_bomb("rt_isect_lseg3_lseg3: |p|=0\n");
d1114 1
a1114 1
			rt_log("ptol=%g\n", ptol);
d1127 1
a1127 1
			rt_log("  HIT colinear!\n");
d1139 1
a1139 1
		rt_bomb("rt_isect_lseg3_lseg3: |q|=0\n");
d1145 1
a1145 1
		rt_log("ptol=%g, qtol=%g\n", ptol, qtol);
d1149 1
a1149 1
			rt_log("  MISS\n");
d1154 1
a1154 1
		rt_log("  HIT!\n");
d1160 1
a1160 1
 *			R T _ I S E C T _ L I N E 3 _ L I N E 3
d1190 1
a1190 1
rt_isect_line3_line3( t, u, p, d, a, c, tol )
d1197 1
a1197 1
CONST struct rt_tol	*tol;
d1206 1
a1206 1
	RT_CK_TOL(tol);
d1289 1
a1289 1
	/* XXX Use rt_isect_line2_line2() here */
d1291 1
a1291 1
	rt_isect_line2_line2( &dist, p, d, a, c, tol );
d1328 1
a1328 1
	/* XXX This should be no smaller than 1e-16.  See rt_isect_line2_line2 for details */
d1397 2
a1398 2
		if( !rt_pt3_pt3_equal( hit1, hit2, tol ) )  {
/*			rt_log("rt_isect_line3_line3(): BOGUS RESULT, hit1=(%g,%g,%g), hit2=(%g,%g,%g)\n",
d1408 1
a1408 1
 *			R T _ I S E C T _ L I N E _ L S E G
d1437 1
a1437 1
/* XXX should probably be called rt_isect_line3_lseg3() */
d1440 1
a1440 1
rt_isect_line_lseg( t, p, d, a, b, tol )
d1446 1
a1446 1
CONST struct rt_tol	*tol;
d1454 1
a1454 1
	RT_CK_TOL(tol);
d1473 2
a1474 2
	if( rt_distsq_line3_pt3( p, d, a ) <= tol->dist_sq  &&
	    rt_distsq_line3_pt3( p, d, b ) <= tol->dist_sq )  {
d1476 1
a1476 1
			rt_log("rt_isect_line3_lseg3() pts A and B within tol of line\n");
d1479 2
a1480 2
		*t = rt_dist_pt3_along_line3( p, d, a );
		/*** dist[1] = rt_dist_pt3_along_line3( p, d, b ); ***/
d1484 1
a1484 1
	if( (ret = rt_isect_line3_line3( t, &u, p, d, a, c, tol )) < 0 )  {
d1518 1
a1518 1
 *			R T _ D I S T _ L I N E 3_ P T 3
d1534 1
a1534 1
rt_dist_line3_pt3( pt, dir, a )
d1556 1
a1556 1
		rt_log("rt_dist_line3_pt3() ret=%g\n", FdotD);
d1562 1
a1562 1
 *			R T _ D I S T S Q _ L I N E 3 _ P T 3
d1573 1
a1573 1
rt_distsq_line3_pt3( pt, dir, a )
d1592 1
a1592 1
		rt_log("rt_distsq_line3_pt3() ret=%g\n", FdotD);
d1598 1
a1598 1
 *			R T _ D I S T _ L I N E _ O R I G I N
d1609 1
a1609 1
rt_dist_line_origin( pt, dir )
d1623 1
a1623 1
 *			R T _ D I S T _ L I N E 2 _ P O I N T 2
d1634 1
a1634 1
rt_dist_line2_point2( pt, dir, a )
d1652 1
a1652 1
 *			R T _ D I S T S Q _ L I N E 2 _ P O I N T 2
d1663 1
a1663 1
rt_distsq_line2_point2( pt, dir, a )
d1681 1
a1681 1
 *			R T _ A R E A _ O F _ T R I A N G L E
d1687 1
a1687 1
rt_area_of_triangle( a, b, c )
d1711 1
a1711 1
 *			R T _ I S E C T _ P T _ L S E G
d1737 1
a1737 1
int rt_isect_pt_lseg(dist, a, b, p, tol)
d1740 1
a1740 1
CONST struct rt_tol	*tol;
d1749 1
a1749 1
	RT_CK_TOL(tol);
d1767 1
a1767 1
	/* Similar to rt_dist_line_pt, except we
d1791 1
a1791 1
 *			R T _ I S E C T _ P T 2 _ L S E G 2
d1818 1
a1818 1
rt_isect_pt2_lseg2(dist, a, b, p, tol)
d1821 1
a1821 1
CONST struct rt_tol	*tol;
d1830 1
a1830 1
	RT_CK_TOL(tol);
d1845 1
a1845 1
			rt_log("distsq A=%g\n", distsq);
d1852 1
a1852 1
	/* Similar to rt_dist_line_pt, except we
d1866 1
a1866 1
			rt_log("distsq B=%g\n", distsq);
d1881 1
a1881 1
 *			R T _ D I S T _ P T 3 _ L S E G 3
d1906 1
a1906 1
 * This routine was formerly called rt_dist_pt_lseg().
d1912 1
a1912 1
rt_dist_pt3_lseg3( dist, pca, a, b, p, tol )
d1916 1
a1916 1
CONST struct rt_tol *tol;
d1926 1
a1926 1
	RT_CK_TOL(tol);
d1929 1
a1929 1
		rt_log("rt_dist_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
d1941 1
a1941 1
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at A\n");
d1951 1
a1951 1
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at B\n");
d1964 1
a1964 1
		rt_log("rt_dist_pt3_lseg3() B_A=%g, t=%g\n",
d1970 1
a1970 1
		if( rt_g.debug & DEBUG_MATH )  rt_log("  left of A\n");
d1986 1
a1986 1
			if( rt_g.debug & DEBUG_MATH )  rt_log("  ON lseg\n");
d1991 1
a1991 1
		if( rt_g.debug & DEBUG_MATH )  rt_log("  closest to lseg\n");
d1996 1
a1996 1
	if( rt_g.debug & DEBUG_MATH )  rt_log("  right of B\n");
d2003 1
a2003 1
 *			R T _ D I S T _ P T 2 _ L S E G 2
d2029 1
a2029 1
 *  Patterned after rt_dist_pt3_lseg3().
d2032 1
a2032 1
rt_dist_pt2_lseg2( dist_sq, pca, a, b, p, tol )
d2036 1
a2036 1
CONST struct rt_tol *tol;
d2046 1
a2046 1
	RT_CK_TOL(tol);
d2049 1
a2049 1
		rt_log("rt_dist_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
d2062 1
a2062 1
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at A\n");
d2072 1
a2072 1
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at B\n");
d2085 1
a2085 1
		rt_log("rt_dist_pt3_lseg3() B_A=%g, t=%g\n",
d2091 1
a2091 1
		if( rt_g.debug & DEBUG_MATH )  rt_log("  left of A\n");
d2107 1
a2107 1
			if( rt_g.debug & DEBUG_MATH )  rt_log("  ON lseg\n");
d2112 1
a2112 1
		if( rt_g.debug & DEBUG_MATH )  rt_log("  closest to lseg\n");
d2117 1
a2117 1
	if( rt_g.debug & DEBUG_MATH )  rt_log("  right of B\n");
d2124 1
a2124 1
 *			R T _ R O T A T E _ B B O X
d2133 1
a2133 1
rt_rotate_bbox( omin, omax, mat, imin, imax )
d2160 1
a2160 1
 *			R T _ R O T A T E _ P L A N E
d2165 1
a2165 1
rt_rotate_plane( oplane, mat, iplane )
d2190 1
a2190 1
 *			R T _ C O P L A N A R
d2202 1
a2202 1
rt_coplanar( a, b, tol )
d2205 1
a2205 1
CONST struct rt_tol	*tol;
d2210 1
a2210 1
	RT_CK_TOL(tol);
d2239 1
a2239 1
 *			R T _ A N G L E _ M E A S U R E
d2267 1
a2267 1
 *  In all cases, the returned value is between 0 and rt_twopi.
d2270 1
a2270 1
rt_angle_measure( vec, x_dir, y_dir )
d2292 1
a2292 1
	if( ang < 0 || ang > rt_twopi )  rt_bomb("rt_angle_measure() angle out of range\n");
d2297 1
a2297 1
 *			R T _ D I S T _ P T 3 _ A L O N G _ L I N E 3
d2305 1
a2305 1
rt_dist_pt3_along_line3( p, d, x )
d2318 1
a2318 1
 *			R T _ D I S T _ P T 2 _ A L O N G _ L I N E 2
d2326 1
a2326 1
rt_dist_pt2_along_line2( p, d, x )
d2337 1
a2337 1
		rt_log("rt_dist_pt2_along_line2() p=(%g, %g), d=(%g, %g), x=(%g, %g) ret=%g\n",
d2352 1
a2352 1
rt_between( left, mid, right, tol )
d2356 1
a2356 1
CONST struct rt_tol	*tol;
d2358 1
a2358 1
	RT_CK_TOL(tol);
d2377 1
a2377 1
		rt_log("rt_between( %.17e, %.17e, %.17e ) ret=0 FAIL\n",
@


11.5
log
@Added code to rt_isect_line2_line2() to help detect parallel lines.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.4 1995/03/02 04:47:39 mike Exp $ (BRL)";
d1396 2
a1397 2
			rt_log("rt_isect_line3_line3(): BOGUS RESULT, hit1=(%g,%g,%g), hit2=(%g,%g,%g)\n",
				hit1[X], hit1[Y], hit1[Z], hit2[X], hit2[Y], hit2[Z]);
@


11.4
log
@Added bullet-proofing
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.3 95/02/28 23:45:36 mike Exp Locker: mike $ (BRL)";
d573 6
d647 23
d676 1
a676 1
	if( NEAR_ZERO( det, DETERMINANT_TOL ) )  {
d678 1
a678 1
		if( !NEAR_ZERO( det1, DETERMINANT_TOL ) )  {
@


11.3
log
@Tests for division by zero should be against SMALL_FASTF, not
SQRT_SMALL_FASTF.  See h/machine.h for details.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.2 95/02/02 01:48:04 mike Exp Locker: mike $ (BRL)";
d2235 2
d2253 3
a2255 1
		return rt_twopi + ang;
d2257 3
a2259 1
		return ang - rt_twopi;
d2261 1
@


11.2
log
@Clarified code in rt_dist_line3_pt3().  Fixed unimportant sign problem.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.1 95/01/04 09:58:23 mike Rel4_4 Locker: mike $ (BRL)";
d249 1
a249 1
	if( (mag = MAGNITUDE(plane)) <= SQRT_SMALL_FASTF )
d315 1
a315 1
	if( NEAR_ZERO( det, SQRT_SMALL_FASTF ) )  return(-1);
d414 1
a414 1
	if( slant_factor < -SQRT_SMALL_FASTF )  {
d417 1
a417 1
	} else if( slant_factor > SQRT_SMALL_FASTF )  {
d1075 1
a1075 1
	if( pmag < SQRT_SMALL_FASTF )
d1107 1
a1107 1
	if( qmag < SQRT_SMALL_FASTF )
@


11.1
log
@Release_4.4
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.36 95/01/04 07:56:00 mike Exp $ (BRL)";
d1494 5
a1510 1
	VSUB2( f, pt, a );
d1515 1
d1517 2
a1518 1
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )  {
@


10.36
log
@Cray C90
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.35 94/11/28 13:26:47 jra Exp Locker: mike $ (BRL)";
@


10.35
log
@Fixed rt_isect_line3_line3 to correctly handle parallel lines.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.34 94/11/04 05:54:06 mike Exp Locker: jra $ (BRL)";
d136 1
@


10.34
log
@Irix 6
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.33 94/10/11 19:36:09 mike Exp Locker: mike $ (BRL)";
d1192 12
@


10.33
log
@Fixed some unsafe 2D code that was using [Z].
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.32 94/09/16 20:19:52 mike Exp Locker: mike $ (BRL)";
d355 1
a355 1
	/* Impose a general angular tolerance to reject 
a462 1
	register fastf_t	d;
a960 5
	fastf_t	dx, dy;
	fastf_t	det;		/* determinant */
	fastf_t	det1, det2;
	fastf_t	b,c;
	fastf_t	hx, hy;		/* H = Q - P */
a1057 5
	fastf_t	dx, dy;
	fastf_t	det;		/* determinant */
	fastf_t	det1, det2;
	fastf_t	b,c;
	fastf_t	hx, hy;		/* H = Q - P */
a1873 1
	fastf_t	B_A_sq;
d1907 1
a1907 1
	B_A = sqrt( B_A_sq = MAGSQ(AtoB) );
a1993 1
	fastf_t	B_A_sq;
d2028 1
a2028 1
	B_A = sqrt( B_A_sq = MAGSQ_2D(AtoB) );
@


10.32
log
@Moved rt_2line3_colinear() to plane.c
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.31 94/08/10 19:20:21 gdurf Exp Locker: mike $ (BRL)";
d1826 1
a1826 1
			VPRINT("ABunit", ABunit);
d1996 1
a1996 1
point_t		pca;
d2024 1
a2024 1
		VMOVE( pca, a );
d2034 1
a2034 1
		VMOVE( pca, b );
d2055 1
a2055 1
		VMOVE( pca, a );
d2066 1
a2066 1
		VJOIN1(pca, a, param_dist, AtoB);
d2081 1
a2081 1
	VMOVE(pca, b);
@


10.31
log
@Added include of conf.h
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.30 1994/07/01 23:36:01 mike Exp gdurf $ (BRL)";
d324 54
@


10.30
log
@Added rt_dist_pt3_pt3().  Added DEBUG_MATH prints to rt_dist_line3_pt3().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.29 94/04/22 05:28:14 mike Exp Locker: mike $ (BRL)";
d20 2
@


10.29
log
@Moved stuff into proper header files.
Changed rt_dist_line_point() to rt_dist_line3_pt3().
Left a compatability macro in raytrace.h
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.28 94/04/21 07:00:33 mike Exp Locker: mike $ (BRL)";
d30 16
d1449 4
a1452 2
	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )
		return 0.0;
d1454 10
a1463 3
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(FdotD) );
d1487 4
a1490 2
	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )
		return 0.0;
d1492 7
a1498 2
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
@


10.28
log
@Needed function declaration, to get return type right!
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.27 94/04/20 00:43:22 mike Exp Locker: mike $ (BRL)";
a28 13
/* XXX move to raytrace.h */
RT_EXTERN(double	rt_dist_pt3_along_line3, (CONST point_t	p,
			CONST vect_t d, CONST point_t x));
RT_EXTERN(double	rt_dist_pt2_along_line2, (CONST point_t p,
			CONST vect_t d, CONST point_t x));
RT_EXTERN(double	rt_distsq_line3_pt3, (CONST point_t pt,
			CONST vect_t dir, CONST point_t a));

/* XXX move to vmath.h */
#define V2PRINT(a,b)	\
	rt_log("%s (%g, %g)\n", a, V2ARGS(b) );


d1413 1
a1413 1
 *			R T _ D I S T _ L I N E _ P O I N T
a1421 2
 *
 *  XXX Another name for this might be rt_dist_line3_pt3()
d1424 1
a1424 1
rt_dist_line_point( pt, dir, a )
@


10.27
log
@Relaxed requirement for unit vectors.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.26 94/04/19 07:17:16 mike Exp Locker: mike $ (BRL)";
d34 3
@


10.26
log
@Took out "inconsistent results" blather.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.25 94/04/18 06:06:01 mike Exp Locker: mike $ (BRL)";
a1426 1
 *  It is necessary that DIR have unit length.
d1428 2
d1445 3
a1447 1
	FdotD = VDOT( f, dir );
a1457 1
 *  It is necessary that DIR have unit length.
d1459 2
d1474 3
a1476 1
	FdotD = VDOT( f, dir );
a1486 1
 *  It is necessary that DIR have unit length.
d1488 2
d1500 3
a1502 1
	PTdotD = VDOT( pt, dir );
a1511 1
 *  It is necessary that DIR have unit length.
d1513 2
d1528 3
a1530 1
	FdotD = VDOT_2D( f, dir );
a1540 1
 *  It is necessary that DIR have unit length.
d1542 2
d1557 3
a1559 1
	FdotD = VDOT_2D( f, dir );
@


10.25
log
@Added 'tol' argument to rt_between().
Added some extra error checking.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.24 94/04/18 01:46:03 mike Exp Locker: mike $ (BRL)";
d625 7
a631 2
	/*  To prevent errors, check the answer.
	 *  Not returning bogus results to our caller is worth the extra time.
d651 1
@


10.24
log
@Added externs, and some debug prints.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.23 94/04/17 19:45:34 mike Exp Locker: mike $ (BRL)";
d34 3
d659 2
d771 12
d786 3
d811 5
d2203 37
@


10.23
log
@Fixed problem with Test12, namely, that rt_isect_line2_lseg2() was
missing co-linear intersections.
Applied similar improvements to the 3D code.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.22 94/04/12 22:39:26 mike Exp Locker: mike $ (BRL)";
d29 7
d716 1
a716 1
	    rt_distsq_line2_point2( p, d, b ) <= tol->dist_sq )  {
d718 1
d2166 1
d2169 9
a2177 1
	return VDOT_2D( x_p, d );
@


10.22
log
@Moved 2D macros to vmath.h
Changed BOGUS RESULT logging.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.21 94/03/09 22:03:45 mike Exp Locker: mike $ (BRL)";
d682 1
d696 1
a696 1
	if( (ctol = MAGSQ_2D(c)) < tol->dist_sq )  {
d701 19
a752 1
		point_t		b;
a755 1
		VADD2_2D( b, a, c );
d1333 17
d1392 2
d1412 26
d2120 41
@


10.21
log
@Pulled out DETERMINANT_TOL, which is still a hack, but better than
SQRT_SMALL_FASTF.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.20 94/03/04 18:38:18 mike Exp Locker: mike $ (BRL)";
a28 27
/* XXX move to vmath.h */
#define VADD2_2D(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];}
#define VSUB2_2D(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];}
#define MAGSQ_2D(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] )
#define VDOT_2D(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] )
#define VMOVE_2D(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];}
#define VSCALE_2D(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c); }
#define VJOIN1_2D(a,b,c,d) 	{ \
			(a)[X] = (b)[X] + (c) * (d)[X];\
			(a)[Y] = (b)[Y] + (c) * (d)[Y]; }
#define VUNITIZE_RET(a,ret)	{ \
			register double _f; _f = MAGNITUDE(a); \
			if( _f < VDIVIDE_TOL ) return(ret); \
			_f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; }


#define PI      3.14159265358979323

d620 2
d625 8
a632 3
		if( !rt_pt2_pt2_equal( hit1, hit2, tol ) )  {
			rt_log("rt_isect_line2_line2(): BOGUS RESULT, hit1=(%g,%g), hit2=(%g,%g)\n",
				hit1[X], hit1[Y], hit2[X], hit2[Y]);
@


10.20
log
@Changed to 2D macros, for readability.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.19 94/03/04 18:26:03 mike Exp Locker: mike $ (BRL)";
d601 2
a602 1
	if( NEAR_ZERO( det, SQRT_SMALL_FASTF ) )  {
d604 1
a604 1
		if( !NEAR_ZERO( det1, SQRT_SMALL_FASTF ) )  {
d1197 1
a1197 1
	if( NEAR_ZERO( det, SQRT_SMALL_FASTF ) )  {
d1199 1
a1199 1
		if( !NEAR_ZERO( det1, SQRT_SMALL_FASTF ) )  {
d1250 2
a1251 2
		/* This tolerance needs to be much less loose than
		 * SQRT_SMALL_FASTF.
d1632 3
a1634 1
rt_log("distsq A=%g\n", distsq);
d1652 4
a1655 2
VPRINT("ABunit", ABunit);
rt_log("distsq B=%g\n", distsq);
@


10.19
log
@Fixed missing sqrt() calls.
Added rt_pt2_pt2_equal(), added double checking to line/line isectors.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.18 94/03/04 11:09:53 jra Exp Locker: mike $ (BRL)";
d47 5
d728 1
a728 1
		dtol = tol->dist / sqrt( d[X]*d[X] + d[Y]*d[Y] );
d885 1
a885 1
		ptol = tol->dist / sqrt( pdir[X]*pdir[X] + pdir[Y]*pdir[Y] );
d906 1
a906 1
	ptol = tol->dist / sqrt( pdir[X]*pdir[X] + pdir[Y]*pdir[Y] );
d910 1
a910 1
	qtol = tol->dist / sqrt( qdir[X]*qdir[X] + qdir[Y]*qdir[Y] );
@


10.18
log
@Re-wrote rt_3pts_collinear.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.17 94/03/04 04:30:01 mike Exp Locker: jra $ (BRL)";
d73 21
d98 3
d594 1
d636 15
d746 1
a746 1
		fastf_t		ab_dist;
d749 1
d753 1
d755 5
d1190 1
d1251 15
d1546 1
a1546 1
	distsq = 1/distsq;
d1625 2
a1626 1
	if( distsq < tol->dist_sq )
d1628 2
a1629 1
	distsq = 1/distsq;
d1643 3
a1645 1
	if (distsq > tol->dist_sq)
d1647 1
@


10.17
log
@Added rt_isect_pt2_lseg2().
Added double check for bad results to rt_isect_line2_lseg2(),
since bad results had been seen getting returned to callers on
very nearly parallel lines.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.16 94/03/02 17:07:08 mike Exp Locker: mike $ (BRL)";
d86 4
a89 2
	fastf_t	dist, mag_ba, mag_ca, theta;
	vect_t	ba, ca;
d91 5
a95 3
	VSUB2(ba, b, a);
	VSUB2(ca, c, a);
	mag_ba = MAGNITUDE(ba);
d97 37
a133 3
	theta = acos(VDOT(ba, ca)/(mag_ba * mag_ca));
	dist = mag_ba * sin(theta);
	return(fabs(dist) < tol->dist);
@


10.16
log
@Added some commented-out code to try and make rt_mk_plane_3pts() more
robust.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.15 94/01/27 05:23:59 mike Exp Locker: mike $ (BRL)";
d30 3
d38 9
d48 1
d443 5
d464 1
a464 1
		rt_log("rt_isect_line2_line2() p=(%g,%g), d=(%g,%g)\n\t\ta=(%g,%g), c=(%g,%g)\n",
d528 5
d538 1
a538 1
				rt_log("parallel, not co-linear\n");
d558 1
a558 1
			rt_log("colinear, t = %g, u = %g\n", dist[0], dist[1] );
d562 4
d570 1
a570 1
		rt_log("intersection, t = %g, u = %g\n", dist[0], dist[1] );
d616 1
a616 1
	fastf_t		fuzz;
d620 5
d631 3
a633 2
	if( (fuzz = MAGSQ(c)) < tol->dist_sq )  {
		return -4;		/* points A and B are not distinct */
d638 2
a639 1
		return -3;		/* No intersection found */
d642 1
a642 1
		fastf_t	ptol;
d645 7
a651 3
		ptol = tol->dist / sqrt( d[X]*d[X] + d[Y]*d[Y] );
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;
d653 4
a656 3
		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;
		return 0;		/* Colinear */
d660 37
a696 1
	 *  The two lines intersect at a point.
d704 12
a715 5
	fuzz = tol->dist / sqrt(fuzz);
	if( dist[1] < -fuzz )
		return -2;		/* Intersection < A */
	if( (f=(dist[1]-1)) > fuzz )
		return -1;		/* Intersection > B */
d717 2
a718 2
	/* Check for fuzzy intersection with one of the verticies */
	if( dist[1] < fuzz )  {
d720 2
a721 1
		return 1;		/* Intersection at A */
d723 1
a723 1
	if( f >= -fuzz )  {
d725 2
a726 1
		return 2;		/* Intersection at B */
d728 7
a734 1
	return 3;			/* Intersection between A and B */
d1442 5
a1446 1
	VUNITIZE(ABunit);
d1464 81
@


10.15
log
@Added rt_isect_lseg3_lseg3().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.14 94/01/22 05:17:40 mike Exp Locker: mike $ (BRL)";
d183 1
d185 12
@


10.14
log
@Added rt_dist_line2_point2(), rt_distsq_line2_point2().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.13 94/01/12 02:50:10 mike Exp Locker: mike $ (BRL)";
d737 109
d872 2
@


10.13
log
@Added new routine.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.12 93/08/12 22:26:31 mike Exp Locker: mike $ (BRL)";
d1094 51
@


10.12
log
@CONST args to rt_angle_measure.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.11 93/05/20 17:10:48 mike Exp Locker: mike $ (BRL)";
d29 7
d1322 122
@


10.11
log
@Changed rt_isect_ray_plane to rt_isect_line3_plane(), adding "tol"
parameter.  It now reports when ray lies ON the plane.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.10 93/05/19 20:44:59 butler Exp Locker: mike $ (BRL)";
d1465 2
a1466 2
vect_t	x_dir;
vect_t	y_dir;
@


10.10
log
@fixed comment for rt_isect_line_lseg()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.9 1993/03/25 18:05:02 mm Exp butler $ (BRL)";
d236 1
a236 1
 *			R T _ I S E C T _ R A Y _ P L A N E
d238 3
a240 2
 *  Intersect a ray with a plane that has an outward pointing normal.
 *  The ray direction vector need not have unit length.
d245 3
a247 2
 *	 0	hit (ray is entering halfspace)
 *	 1	hit (ray is leaving)
d253 1
a253 1
rt_isect_ray_plane( dist, pt, dir, plane )
d258 1
d263 2
d270 1
a270 1
		return(0);			/* HIT, entering */
d273 1
a273 1
		return(1);			/* HIT, leaving */
d280 5
a284 3
	if( norm_dist < 0.0 )
		return(-2);	/* missed, outside */
	return(-1);		/* missed, inside */
@


10.9
log
@improved rt_3pts_collinear
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.8 1993/03/24 22:23:22 mm Exp $ (BRL)";
d951 1
a951 1
 *	-2	Intersection exists, < A (t is returned)
@


10.8
log
@added rt_3pts_collinear
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.7 1993/03/17 01:18:29 mike Exp mm $ (BRL)";
d29 2
d58 1
a58 1
 *	1	If all 3 points are collinear
d64 1
a64 1
fastf_t	tol;
d66 2
a67 1
	vect_t	v1, v2, v3;
d69 7
a75 6
	VSUB2(v1, b, a);
	VUNITIZE(v1);
	VSUB2(v2, c, a);
	VUNITIZE(v2);
	VREVERSE(v3, v2);
	return(VAPPROXEQUAL(v1, v2, tol) || VAPPROXEQUAL(v1, v3, tol));
@


10.7
log
@Changed rt_dist_pt_lseg() to rt_dist_pt3_lseg3().
Return code is now a flag to indicate which of 6 cases have happened.
Distance is returned via a pointer instead.
Changed calling sequence, so name was changed.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.6 93/03/17 00:28:34 mike Exp Locker: mike $ (BRL)";
d49 25
@


10.6
log
@Fixed nasty subtle bug in rt_dist_pt_lseg():
It was comparing the distance between the *projection* of P onto
the line to the end points, rather than from P itself.
This produced cases where P was a long ways away from an end point,
yet it was being declared as "on" the end point.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.5 93/03/16 01:18:43 mike Exp Locker: mike $ (BRL)";
d1160 1
a1160 1
 *			R T _ D I S T _ P T _ L S E G
d1162 2
a1163 2
 *	Find the distance from a point P to a line segment described
 *	by the two endpoints A and B.
d1176 8
a1183 1
 *  There are six distinct cases:
d1185 1
a1185 3
 *	Explicit return
 *	    distance from the point of closest approach on lseg to point
 *	    0.0 if within tol->dist of A or B or the line segment.
a1186 3
 *	Implicit return
 *	    pca 	the point of closest approach
 *
d1190 3
a1192 1
double rt_dist_pt_lseg(pca, a, b, p, tol)
d1209 1
a1209 1
		rt_log("rt_dist_pt_lseg() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
d1222 2
a1223 1
		return 0.0;
d1232 2
a1233 1
		return 0.0;
d1244 1
a1244 1
		rt_log("rt_dist_pt_lseg() B_A=%g, t=%g\n",
d1249 2
a1250 1
		/* P is "below" A */
d1252 2
a1253 2
		if( rt_g.debug & DEBUG_MATH )  rt_log("  below A\n");
		return sqrt(P_A_sq);
d1256 1
a1256 1
		/* P falls between A and B */
d1266 4
a1269 2
			if( rt_g.debug & DEBUG_MATH )  rt_log("  on lseg\n");
			return 0.0;
d1272 2
a1273 1
		return sqrt(dsq);
d1275 2
a1276 1
	/* P is "above" B */
d1278 2
a1279 2
	if( rt_g.debug & DEBUG_MATH )  rt_log("  above B\n");
	return sqrt(P_B_sq);
@


10.5
log
@Moved 2d line routines from nmg_inter.c to plane.c
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.4 93/02/11 21:58:11 mike Exp Locker: mike $ (BRL)";
d27 1
d70 1
d129 2
d389 2
a390 2
#	if DEBUG_2D_LINES
		rt_log("rt_isect_line_line2() p=(%g,%g), d=(%g,%g)\n\t\ta=(%g,%g), c=(%g,%g)\n",
d392 1
a392 1
#	endif
d458 1
a458 1
#			if DEBUG_2D_LINES
d460 1
a460 1
#			endif
d478 1
a478 1
#		if DEBUG_2D_LINES
d480 1
a480 1
#		endif
d486 1
a486 1
#	if DEBUG_2D_LINES
d488 1
a488 1
#	endif
d635 1
a635 1
#	if DEBUG_2D_LINES
d638 1
a638 1
#	endif
d650 1
a650 1
#		if DEBUG_2D_LINES
d652 1
a652 1
#		endif
d663 1
a663 1
#		if DEBUG_2D_LINES
d665 1
a665 1
#		endif
d678 1
a678 1
#	if DEBUG_2D_LINES
d680 1
a680 1
#	endif
d682 1
a682 1
#		if DEBUG_2D_LINES
d684 1
a684 1
#		endif
d687 1
a687 1
#	if DEBUG_2D_LINES
d689 1
a689 1
#	endif
d738 2
d958 2
d1122 2
d1165 13
d1194 1
d1196 4
a1199 2
	fastf_t	seglen;		/* |B-A| */
	fastf_t	seglen_sq;
d1201 12
a1212 1
	
d1214 16
d1231 1
a1231 2
	seglen_sq = MAGSQ(AtoB);
	seglen = sqrt(seglen_sq);
d1233 8
a1240 2
	/* compute distance (in actual units) along line to pca */
	t = VDOT(PtoA, AtoB) / seglen;
d1242 1
a1242 1
	if( t < -tol->dist )  {
d1245 2
a1246 1
		return MAGNITUDE(PtoA);
d1248 1
a1248 6
	if( t < tol->dist )  {
		/* P is within the tol->dist radius circle around A */
		VMOVE( pca, a );
		return 0.0;
	}
	if( t < seglen - tol->dist )  {
d1254 1
a1254 1
		param_dist = VDOT(PtoA, AtoB) / seglen_sq;
d1257 3
a1259 2
		/* Find distance from PCA to line segment */
		if( (dsq = VDOT( PtoA, PtoA ) - t * t ) <= tol->dist_sq )  {
d1262 1
a1264 5
	if( t < seglen + tol->dist )  {
		/* P is within the tol->dist radius circle around B */
		VMOVE( pca, b );
		return 0.0;
	}
d1267 2
a1268 2
	VSUB2(PtoA, p, b);
	return MAGNITUDE(PtoA);
d1357 2
@


10.4
log
@Added extra return code from rt_isect_line3_line3
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.3 93/02/06 04:25:53 mike Exp Locker: mike $ (BRL)";
d29 21
d342 348
d802 6
d936 1
@


10.3
log
@Fixed line intersector, so it can tell the difference between
parallel and colinear lines.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.2 92/02/25 00:01:46 mike Exp Locker: mike $ (BRL)";
d321 1
a321 1
 *			R T _ I S E C T _ 2 L I N E S
d349 1
a349 1
rt_isect_2lines( t, u, p, d, a, c, tol )
d540 3
a542 2
 *	-3	A and B are not distinct points
 *	-2	Intersection exists, but is outside of A--B
d560 1
d584 1
a584 1
		return(-3);		/* points A and B are not distinct */
d587 1
a587 1
	if( (ret = rt_isect_2lines( t, &u, p, d, a, c, tol )) < 0 )  {
d607 1
a607 1
		return(-2);		/* Intersection outside of A--B */
d609 1
a609 1
		return(-2);		/* Intersection outside of A--B */
@


10.2
log
@Moved in rt_angle_measure() from nmg_comb.c
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.1 91/10/12 06:40:53 mike Rel4_0 Locker: mike $ (BRL)";
d336 1
d362 1
d461 2
a462 2
	 *  If det(M) is zero, then there is no solution; otherwise,
	 *  exactly one solution exists.
d466 1
d468 6
d478 1
a478 1
		if( d[q] >= d[r] )  {
d510 1
a510 1
	*t = det * (c[q] * h[r] - h[q] * c[r]);
@


10.1
log
@Release_4.0
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.23 91/06/19 21:22:45 mike Exp $ (BRL)";
d944 51
@


1.23
log
@Added rt_coplanar
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.22 91/06/14 06:26:08 mike Exp $ (BRL)";
@


1.22
log
@More rigorous algorithm for rt_rotate_bbox
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.21 91/05/25 01:35:40 mike Exp $ (BRL)";
d260 1
d262 3
a264 8
	/* Check to see if the planes are parallel */
	d = VDOT( a, b );
	if( RT_VECT_ARE_PARALLEL(d, tol) )  {
		/* See if the planes are identical */
		d = a[3] - b[3];
		if( NEAR_ZERO( d, tol->dist ) )  {
			return(-1);	/* FAIL -- planes are identical */
		}
d897 47
@


1.21
log
@Fixed rt_dist_pt_lseg() to take into account tolerances,
so that if pt is within tolerance of A, B, or the line segment,
the distance is zero.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.20 91/05/18 03:03:32 mike Exp $ (BRL)";
d854 2
a855 2
	point_t		rmin, rmax;
	point_t		pt;
d857 4
a860 2
	MAT4X3PNT( rmin, mat, imin );
	MAT4X3PNT( rmax, mat, imax );
d862 9
a870 23
	VSET( omin, rmin[X], rmin[Y], rmin[Z] );
	VMOVE( omax, omin );

	VSET( pt, rmax[X], rmin[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmax[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmax[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmin[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmin[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmax[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmax[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );
@


1.20
log
@Converted to new tolerance interface
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.19 91/04/01 18:36:07 mike Exp $ (BRL)";
d754 1
a754 4

	if (distsq < 0)
		distsq = 0.0;
	else if (distsq > tol->dist_sq)
a759 1
	/* XXX This formula does not give a tol->dist radius around endpts */
d774 1
d778 3
d787 5
a791 3
	vect_t ENDPTtoP, AtoB;
	double Pr_prop;		/* proj of a-p onto a-b as proportion of a-b */
	double distance;	/* distance of point from lseg */
d793 1
a793 1
	VSUB2(ENDPTtoP, p, a);
d795 2
d798 2
a799 2
	/* compute distance along line to pca */
	Pr_prop = VDOT(ENDPTtoP, AtoB) / MAGSQ(AtoB);
d801 4
a804 10
	/* XXX This does not provide a tol->dist circle around endpoints */
	if (Pr_prop < 1.0 && Pr_prop > 0.0) {
		/* pt is along edge of lseg, scale AtoB by Pr_prop to
		 * get a vector from A to the P.C.A.
		 */
		VJOIN1(pca, a, Pr_prop, AtoB);
		VUNITIZE(AtoB);

		distance = rt_dist_line_point(a, AtoB, p);
		return(distance);
d806 9
d816 9
a824 6
	/* pt is closer to an endpoint than to the line segment */
	if (Pr_prop >= 1.0) {
		VSUB2(ENDPTtoP, p, b);
		VMOVE(pca, b);
	} else {
		VMOVE(pca, a);
d826 9
a834 3

	distance = MAGNITUDE(ENDPTtoP);
	return(distance);
@


1.19
log
@Updated comment
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.18 91/02/27 22:58:08 mike Exp $ (BRL)";
d26 1
d40 3
a42 3
rt_3pts_distinct( a, b, c, dist_tol_sq )
point_t	a, b, c;
double	dist_tol_sq;
d49 1
a49 1
	if( MAGSQ( B_A ) <= dist_tol_sq )  return(0);
d51 1
a51 1
	if( MAGSQ( C_A ) <= dist_tol_sq )  return(0);
d53 1
a53 1
	if( MAGSQ( C_B ) <= dist_tol_sq )  return(0);
d96 4
a99 4
rt_mk_plane_3pts( plane, a, b, c, dist_tol_sq )
plane_t	plane;
point_t	a, b, c;
double	dist_tol_sq;
d107 1
a107 1
	if( MAGSQ( B_A ) <= dist_tol_sq )  return(-1);
d109 1
a109 1
	if( MAGSQ( C_A ) <= dist_tol_sq )  return(-1);
d111 1
a111 1
	if( MAGSQ( C_B ) <= dist_tol_sq )  return(-1);
d154 2
a155 2
point_t	pt;
plane_t	a, b, c;
d198 4
a201 4
fastf_t	*dist;
point_t	pt;
vect_t	dir;
plane_t	plane;
d249 7
a255 6
rt_isect_2planes( pt, dir, a, b, rpp_min )
point_t	pt;
vect_t	dir;
plane_t	a;
plane_t	b;
vect_t	rpp_min;
a259 3
	/* XXX These should be parameters */
	fastf_t			cos_ang_tol = 0.999999;
	fastf_t			dist_tol = 0.005;
d263 1
a263 1
	if( !NEAR_ZERO( d, cos_ang_tol ) )  {
d266 1
a266 1
		if( NEAR_ZERO( d, dist_tol ) )  {
a338 2
 *  XXX Tolerancing around zero, as always, remains a problem.
 *
d352 8
a359 6
rt_isect_2lines( t, u, p, d, a, c )
fastf_t		*t, *u;
point_t		p;
vect_t		d;
point_t		a;
vect_t		c;
a378 1
#define DIFFERENCE_TOL	(1.0e-10)
d381 1
a381 1
	if( !NEAR_ZERO( det, DIFFERENCE_TOL ) )  {
d511 1
a511 1
	 *  XXX It isn't clear what tolerance to use here.
d514 1
a514 1
	if( !NEAR_ZERO( det, DIFFERENCE_TOL ) )  {
d555 7
a561 6
rt_isect_line_lseg( t, p, d, a, b )
fastf_t		*t;
point_t		p;
vect_t		d;
point_t		a;
point_t		b;
d567 1
a567 2
	/* XXX should be a parameter */
	fastf_t		dist_tol_sq = SMALL_FASTF;
d576 2
a577 2
	if( MAGSQ(c) < dist_tol_sq )  {
		return(-3);		/* A and B are not distinct */
d580 1
a580 1
	if( (ret = rt_isect_2lines( t, &u, p, d, a, c )) < 0 )  {
d594 3
d598 2
a599 1
	if( u < -SQRT_SMALL_FASTF )
d601 1
a601 1
	if( (f=(u-1)) > SQRT_SMALL_FASTF )
d605 1
a605 1
	if( u < SQRT_SMALL_FASTF )
d607 1
a607 1
	if( f >= -SQRT_SMALL_FASTF )
d625 3
a627 3
point_t	pt;
vect_t	dir;
point_t	a;
d634 1
a634 2
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= 0 ||
	    (FdotD = sqrt( FdotD )) < SQRT_SMALL_FASTF )
d636 1
a636 1
	return( FdotD );
d651 2
a652 2
point_t	pt;
vect_t	dir;
d657 1
a657 2
	if( (PTdotD = VDOT( pt, pt ) - PTdotD * PTdotD ) <= 0 ||
	    (PTdotD = sqrt( PTdotD )) < SQRT_SMALL_FASTF )
d659 1
a659 1
	return( PTdotD );
d670 1
a670 1
register point_t a, b, c;
d692 2
a693 1
/*	R T _ I S E C T _ P T _ L S E G
d719 4
a722 4
int rt_isect_pt_lseg(dist, a, b, p, dist_tol_sq)
fastf_t *dist;		/* distance along line from A to P */
point_t a, b, p;	/* points for line and intersect */
fastf_t dist_tol_sq;	/* dist tol (squared) for pt on line or other-point */
d728 2
a730 5
	fastf_t	APprABunit;	/* Magnitude of the projection of
				 * AtoP onto ABunit
				 */
	fastf_t distsq;		/* distance^2 from parametric line to pt */

d732 1
a732 1
	if (MAGSQ(AtoP) < dist_tol_sq)
d736 1
a736 1
	if (MAGSQ(BtoP) < dist_tol_sq)
d757 1
a757 2

	if (distsq > dist_tol_sq)
d763 1
d770 2
a771 1
/*	R T _ D I S T _ P T _ L S E G
d782 4
a785 2
double rt_dist_pt_lseg(pca, a, b, p)
point_t pca, a, b, p;
d788 1
a788 1
	double Pr_prop;		/* projection of a-p onto a-b as a proportion of a-b */
d797 1
a805 1

a809 1

a817 1

d834 3
a836 3
mat_t		mat;
point_t		imin;
point_t		imax;
d877 2
a878 2
mat_t		mat;
plane_t		iplane;
@


1.18
log
@Added rotate_bbox and rotate_plane
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.17 90/12/07 00:45:46 mike Exp $ (BRL)";
a84 6
 *  This is the "right hand rule".
 *
 *  While listing the points in counterclockwise order is "closer"
 *  to the orientation expected for the cross product,
 *  it might have been nice to have listed the points in clockwise
 *  order to match the convention of the NMG face creation routines.
@


1.17
log
@lint
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.16 90/12/06 19:58:25 mike Exp $ (BRL)";
d826 78
@


1.16
log
@Fixed subtle, but horible, bug in rt_isect_2planes.
It caused serious trouble for mged/proc_reg.c,
not a pretty place to have to debug from.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.15 90/12/06 19:44:43 mike Exp $ (BRL)";
d603 3
a605 1
	if( u < -SQRT_SMALL_FASTF || (f=(u-1)) > SQRT_SMALL_FASTF )
@


1.15
log
@Minor neatening up.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.14 90/11/01 04:49:14 mike Exp $ (BRL)";
d296 1
a296 1
			VSET( pl, 1, 0, 0 );
d302 1
a302 1
			VSET( pl, 0, 0, 1 );
d310 1
a310 1
			VSET( pl, 0, 1, 0 );
d316 2
a317 2
			VSET( pl, 0, 0, 1 );
			pl[3] = rpp_min[Y];
@


1.14
log
@Added rt_3pts_distinct().
Added dist_tol_sq arg to rt_mk_plane_3pts
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.13 90/05/16 07:41:24 butler Exp $ (BRL)";
d264 3
d270 1
a270 2
	/* XXX angular tolerance needed */
	if( !NEAR_ZERO( d, 0.999999 ) )  {
d273 1
a273 2
		/* XXX need distance tolerance */
		if( NEAR_ZERO( d, 0.005 ) )  {
d574 2
d584 1
a584 6
#if 0
	/* Perhaps something like this would be more efficient? */
	if( VNEAR_ZERO( c, 0.005 ) )  return(-3);
#endif
	f = MAGNITUDE(c);		/* always positive */
	if( f < SQRT_SMALL_FASTF )  {
d722 5
a726 6
int rt_isect_pt_lseg(dist, a, b, p, tolsq)
fastf_t *dist;	/* distance along line from A to P */
point_t a, b, p; /* points for line and intersect */
fastf_t tolsq;	/* distance tolerance (squared) for point being */
{		/* on line or other-point */

d738 1
a738 1
	if (MAGSQ(AtoP) < tolsq)
d742 1
a742 1
	if (MAGSQ(BtoP) < tolsq)
d749 3
a751 3
/* This part is similar to rt_dist_line_pt.  The difference being that we
 * never actually have to do the sqrt that the other routine does.
 */
d764 1
a764 1
	if (distsq > tolsq)
d767 1
a767 3
/* at this point we know the distance from the point to the line is
 * within tolerance.
 */
d802 1
a802 1
		 * egt a vector from A to the P.C.A.
@


1.13
log
@rt_dist_pt_lseg debugged (it wasn't really broken)
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.12 90/05/13 11:29:09 mike Exp $ (BRL)";
d28 29
a91 2
 *  XXX The tolerance here should be relative to the model diameter, not abs.
 *
d101 1
a101 1
rt_mk_plane_3pts( plane, a, b, c )
d104 1
d112 1
a112 1
	if( VNEAR_ZERO( B_A, 0.005 ) )  return(-1);
d114 1
a114 1
	if( VNEAR_ZERO( C_A, 0.005 ) )  return(-1);
d116 1
a116 1
	if( VNEAR_ZERO( C_B, 0.005 ) )  return(-1);
@


1.12
log
@Added different return codes to rt_isect_2planes
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.11 90/05/13 11:22:40 butler Exp $ (BRL)";
d768 2
a769 1
	double dist, APdist;
d774 8
a781 4
	dist = VDOT(ENDPTtoP, AtoB) / MAGSQ(AtoB);
	if (dist <= 1.0 && dist >= 0.0) {
		/* pt is along edge of lseg */
		VSCALE(pca, AtoB, dist);
d783 4
a786 1
		return(rt_dist_line_point(a, AtoB, p));
d791 4
a794 5
	APdist = MAGNITUDE(ENDPTtoP);
	VSUB2(ENDPTtoP, p, b);
	dist = MAGNITUDE(ENDPTtoP);

	if (APdist < dist) {
a795 1
		return(APdist);
d798 3
a800 2
	VMOVE(pca, b);
	return(dist);
@


1.11
log
@Fixed minor typos
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.10 90/05/10 08:43:14 butler Locked $ (BRL)";
d217 3
a219 1
 *	-1	FAIL
d239 10
a248 2
	if( !NEAR_ZERO( d, 0.999999 ) )
		return(-1);		/* FAIL -- parallel */
d297 1
a297 1
		return(-1);	/* FAIL -- no intersection */
@


1.10
log
@turned  rt_dist_pt_lseg into what I really wanted (I think ;-)
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.9 90/05/10 05:15:56 butler Locked $ (BRL)";
d690 1
a690 1
{		/ * on line or other-point */
d702 1
a702 1
	VSUB2(AtoP p, a);
d726 3
d768 1
a768 1
		return(rt_dist_pt_line(a, AtoB, p));
@


1.9
log
@added rt_isect_pt_lseg and rt_dist_pt_lseg
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.8 90/03/14 23:10:38 butler Locked $ (BRL)";
d744 6
d751 2
a752 2
double rt_dist_pt_lseg(a, b, p)
point_t a, b, p;
d763 1
d774 6
a779 1
	if (APdist < dist) return(APdist);
@


1.8
log
@Further documented parameters to rt_mk_plane_3pts
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.7 90/03/05 22:23:57 mike Locked $ (BRL)";
d657 112
@


1.7
log
@Improved a comment.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.6 90/03/03 05:59:21 mike Locked $ (BRL)";
d36 26
@


1.6
log
@Added rt_area_of_triangle().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.5 89/10/18 14:31:13 mike Locked $ (BRL)";
d32 4
a35 2
 *  so C had better be counter-clockwise from B to follow the
 *  BRL-CAD outward-pointing normal convention.
d41 2
a42 1
 *	-1	Failure.  At least two of the points were not distinct.
@


1.5
log
@Added rt_dist_line_point() and rt_dist_line_origin()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.1 89/10/10 16:05:53 mike Exp $ (BRL)";
d599 29
@


1.4
log
@Added rt_isect_2lines()
@
text
@d551 8
a558 3
 * Still to come:
 *	Closest Distance between a line and the origin,
 *	Closest Distance between a line and a point.
d560 40
@


1.3
log
@For ray-meets-plane, distinguish between "in" and "on".
@
text
@d4 1
a4 1
 *  Some useful routines for dealing with planes.
d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.2 89/10/13 20:38:35 mike Locked $ (BRL)";
d80 13
d106 1
a106 1
	register fastf_t d;
d108 1
d110 9
a118 3
	d = VDOT( a, v1 );
	if( NEAR_ZERO( d, SQRT_SMALL_FASTF ) )  return(-1);
	d = 1/d;
d122 4
a125 3
	pt[X] = d*(a[3]*v1[X] - b[3]*v2[X] + c[3]*v3[X]);
	pt[Y] = d*(a[3]*v1[Y] - b[3]*v2[Y] + c[3]*v3[Y]);
	pt[Z] = d*(a[3]*v1[Z] - b[3]*v2[Z] + c[3]*v3[Z]);
d136 1
a136 2
 *	-3	missed (ray is outside halfspace)
 *	-2	"missed" (ray lies on plane)
d169 3
a171 5
	if( norm_dist < SQRT_SMALL_FASTF )
		return(-3);	/* missed, outside */
	if( norm_dist > SQRT_SMALL_FASTF )
		return(-1);	/* missed, inside */
	return(-2);		/* "missed", ray lies on plane */
a173 4
static plane_t	xpl = { 1, 0, 0, 0 };
static plane_t	ypl = { 0, 1, 0, 0 };
static plane_t	zpl = { 0, 0, 1, 0 };

d184 1
a184 1
 *  RPP.  If this is unnecessary, just pass (0,0,0).
d213 1
a213 1
	VUNITIZE( dir );		/* safety? */
d228 1
a228 1
			VMOVE( pl, xpl);
d234 1
a234 1
			VMOVE( pl, zpl);
d242 1
a242 1
			VMOVE( pl, ypl);
d248 1
a248 1
			VMOVE( pl, zpl);
d262 293
@


1.2
log
@Added  rt_isect_2planes()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.1 89/10/10 16:05:53 mike Exp $ (BRL)";
d115 2
a116 1
 *	-2	missed (ray is outside halfspace)
d149 5
a153 3
	if( norm_dist < 0.0 )
		return(-2);	/* missed, outside */
	return(-1);		/* missed, inside */
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header$ (BRL)";
d37 1
a37 1
 *  Returns -
d40 3
d80 1
a80 1
 *  Returns -
d83 3
d102 3
a104 4
	pt[X] = a[3]*v1[X] - b[3]*v2[X] + c[3]*v3[X];
	pt[Y] = a[3]*v1[Y] - b[3]*v2[Y] + c[3]*v3[Y];
	pt[Z] = a[3]*v1[Z] - b[3]*v2[Z] + c[3]*v3[Z];
	VSCALE( pt, pt, d );
d151 93
@
