head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.2
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.06;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.37;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.54.49;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.11.23.30.40;	author cjohnson;	state Exp;
branches;
next	11.3;

11.3
date	99.06.03.01.17.41;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.12.16.00.11.46;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.40;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.10.20.00.47;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.08.27.19.52.35;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.01;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.06.30.00.11.24;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.57.09;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.27.23.10.44;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	89.04.11.13.07.28;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	89.04.11.12.33.15;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.43;	author mike;	state Rel3_0;
branches;
next	1.2;

1.2
date	88.09.09.21.32.25;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.01.29.22.24.57;	author phil;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.10;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.16.48;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.41.43;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.18.39.33;	author erikg;	state Exp;
branches;
next	11.6.10.2;

11.6.10.2
date	2004.03.15.14.06.16;	author erikg;	state Exp;
branches;
next	;


desc
@Spherical Map Library
@


11.10
log
@moved to src/
@
text
@/*
 *			S P H M A P . C
 *
 *  Common Subroutines for Spherical Data Structures/Texture Maps Subroutines
 *
 *  Author -
 *	Phillip Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/sphmap.c,v 11.9 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "spm.h"

/*
 *		S P M _ I N I T
 *
 *  Return a sphere map structure initialized for N points around
 *  the equator.  Malloc the storage and fill in the pointers.
 *  This code leaves a ring of "triangular" pixels at the poles.
 *  An alternative would be to have the pole region map to a
 *  single pixel.
 *
 *  Returns SPM_NULL on error.
 */
spm_map_t *
spm_init(int N, int elsize)
{
	int	i, nx, total, index;
	register spm_map_t *mapp;

	mapp = (spm_map_t *)bu_malloc( sizeof(spm_map_t), "spm_map_t");
	if( mapp == SPM_NULL )
		return( SPM_NULL );
	bzero( (char *)mapp, sizeof(spm_map_t) );

	mapp->elsize = elsize;
	mapp->ny = N/2;
	mapp->nx = (int *) bu_malloc( (unsigned)(N/2 * sizeof(*(mapp->nx))), "sph nx" );
	if( mapp->nx == NULL ) {
		spm_free( mapp );
		return( SPM_NULL );
	}
	mapp->xbin = (unsigned char **) bu_malloc( (unsigned)(N/2 * sizeof(char *)), "sph xbin" );
	if( mapp->xbin == NULL ) {
		spm_free( mapp );
		return( SPM_NULL );
	}

	total = 0;
	for( i = 0; i < N/4; i++ ) {
		nx = ceil( N*cos( i*bn_twopi/N ) );
		if( nx > N ) nx = N;
		mapp->nx[ N/4 + i ] = nx;
		mapp->nx[ N/4 - i -1 ] = nx;

		total += 2*nx;
	}

	mapp->_data = (unsigned char *) bu_calloc( (unsigned)total, elsize, "spm_init data" );
	if( mapp->_data == NULL ) {
		spm_free( mapp );
		return( SPM_NULL );
	}

	index = 0;
	for( i = 0; i < N/2; i++ ) {
		mapp->xbin[i] = &((mapp->_data)[index]);
		index += elsize * mapp->nx[i];
	}
	mapp->magic = SPM_MAGIC;
	return( mapp );
}

/*
 *		S P M _ F R E E
 *
 *  Free the storage associated with a sphere structure.
 */
void
spm_free(spm_map_t *mp)
{
	RT_CK_SPM(mp);
	if( mp == SPM_NULL )
		return;

	if( mp->_data != NULL )  {
		(void) bu_free( (char *)mp->_data, "sph _data" );
		mp->_data = NULL;
	}

	if( mp->nx != NULL )  {
		(void) bu_free( (char *)mp->nx, "sph nx" );
		mp->nx = NULL;
	}

	if( mp->xbin != NULL )  {
		(void) bu_free( (char *)mp->xbin, "sph xbin" );
		mp->xbin = NULL;
	}

	(void) bu_free( (char *)mp, "spm_map_t" );
}

/*
 *		S P M _ R E A D
 *
 *  Read the value of the pixel at the given normalized (u,v)
 *  coordinates.  It does NOT check the sanity of the coords.
 *
 *  0.0 <= u < 1.0	Left to Right
 *  0.0 <= v < 1.0	Bottom to Top
 */
void
spm_read(register spm_map_t *mapp, register unsigned char *valp, double u, double v)
{
	int	x, y;
	register unsigned char *cp;
	register int	i;

	RT_CK_SPM(mapp);

	y = v * mapp->ny;
	x = u * mapp->nx[y];
	cp = &(mapp->xbin[y][x*mapp->elsize]);

	i = mapp->elsize;
	while( i-- > 0 ) {
		*valp++ = *cp++;
	}
}

/*
 *		S P M _ W R I T E
 *
 *  Write the value of the pixel at the given normalized (u,v)
 *  coordinates.  It does NOT check the sanity of the coords.
 *
 *  0.0 <= u < 1.0	Left to Right
 *  0.0 <= v < 1.0	Bottom to Top
 */
void
spm_write(register spm_map_t *mapp, register unsigned char *valp, double u, double v)
{
	int	x, y;
	register unsigned char *cp;
	register int	i;

	RT_CK_SPM(mapp);

	y = v * mapp->ny;
	x = u * mapp->nx[y];
	cp = &(mapp->xbin[y][x*mapp->elsize]);

	i = mapp->elsize;
	while( i-- > 0 ) {
		*cp++ = *valp++;
	}
}

/*
 *		S P M _ G E T
 *
 *  Return a pointer to the storage element indexed by (u,v)
 *  coordinates.  It does NOT check the sanity of the coords.
 *
 *  0.0 <= u < 1.0	Left to Right
 *  0.0 <= v < 1.0	Bottom to Top
 */
char *
spm_get(register spm_map_t *mapp, double u, double v)
{
	int	x, y;
	register unsigned char *cp;

	RT_CK_SPM(mapp);

	y = v * mapp->ny;
	x = u * mapp->nx[y];
	cp = &(mapp->xbin[y][x*mapp->elsize]);

	return( (char *)cp );
}

/*
 *		S P M _ L O A D
 *
 *  Read a saved sphere map from a file ("-" for stdin) into
 *  the given map structure.
 *  This does not check for conformity of size, etc.
 *  Returns -1 on error, else 0.
 */
int
spm_load(spm_map_t *mapp, char *filename)
{
	int	y, total;
	FILE	*fp;

	RT_CK_SPM(mapp);

	if( strcmp( filename, "-" ) == 0 )
		fp = stdin;
	else  {
		bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
		fp = fopen( filename, "r" );
		bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
		if( fp == NULL )
			return( -1 );
	}

	total = 0;
	for( y = 0; y < mapp->ny; y++ )
		total += mapp->nx[y];

	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	y = fread( (char *)mapp->_data, mapp->elsize, total, fp );	/* res_syscall */
	(void) fclose( fp );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */

	if( y != total )
		return( -1 );

	return( 0 );
}

/*
 *		S P M _ S A V E
 *
 *  Write a loaded sphere map to the given file ("-" for stdout).
 *  Returns -1 on error, else 0.
 */
int
spm_save(spm_map_t *mapp, char *filename)
{
	int	i;
	int	got;
	FILE	*fp;

	RT_CK_SPM(mapp);

	if( strcmp( filename, "-" ) == 0 )
		fp = stdout;
	else  {
		bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
		fp = fopen( filename, "w" );			/* res_syscall */
		bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
		if( fp == NULL )
			return( -1 );
	}

	for( i = 0; i < mapp->ny; i++ ) {
		bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
		got = fwrite( (char *)mapp->xbin[i], mapp->elsize,	/* res_syscall */
		    mapp->nx[i], fp );
		bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
		if( got != mapp->nx[i] ) {
			bu_log("spm_save(%s): write error\n", filename);
			bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
		    	(void) fclose( fp );
			bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
		    	return( -1 );
		}
	}

	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	(void) fclose( fp );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */

	return( 0 );
}

/*
 *		S P M _ P I X _ L O A D
 *
 *  Load an 'nx' by 'ny' pix file and filter it into the
 *  given sphere structure.
 *  Returns -1 on error, else 0.
 */
int
spm_px_load(spm_map_t *mapp, char *filename, int nx, int ny)
{
	int	i, j;			/* index input file */
	int	x, y;			/* index texture map */
	double	j_per_y, i_per_x;	/* ratios */
	int	nj, ni;			/* ints of ratios */
	unsigned char *cp;
	unsigned char *buffer;
	unsigned long	red, green, blue;
	long	count;
	FILE	*fp;

	RT_CK_SPM(mapp);

	if( strcmp( filename, "-" ) == 0 )
		fp = stdin;
	else  {
		bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
		fp = fopen( filename, "r" );
		bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
		if( fp == NULL )
			return( -1 );
	}

	/* Shamelessly suck it all in */
	buffer = (unsigned char *)bu_malloc( (unsigned)(nx*nx*3), "spm_px_load buffer" );
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	i = fread( (char *)buffer, 3, nx*ny, fp );	/* res_syscall */
	(void) fclose( fp );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	if( i != nx*ny )  {
		bu_log("spm_px_load(%s) read error\n", filename);
		return( -1 );
	}

	j_per_y = (double)ny / (double)mapp->ny;
	nj = (int)j_per_y;
	/* for each bin */
	for( y = 0; y < mapp->ny; y++ ) {
		i_per_x = (double)nx / (double)mapp->nx[y];
		ni = (int)i_per_x;
		/* for each cell in bin */
		for( x = 0; x < mapp->nx[y]; x++ ) {
			/* Average pixels from the input file */
			red = green = blue = 0;
			count = 0;
			for( j = y*j_per_y; j < y*j_per_y+nj; j++ ) {
				for( i = x*i_per_x; i < x*i_per_x+ni; i++ ) {
					red = red + (unsigned long)buffer[ 3*(j*nx+i) ];
					green = green + (unsigned long)buffer[ 3*(j*nx+i)+1 ];
					blue = blue + (unsigned long)buffer[ 3*(j*nx+i)+2 ];
					count++;
				}
			}
			/* Save the color */
			cp = &(mapp->xbin[y][x*3]);
			*cp++ = (unsigned char)(red/count);
			*cp++ = (unsigned char)(green/count);
			*cp++ = (unsigned char)(blue/count);
		}
	}
	(void) bu_free( (char *)buffer, "spm buffer" );

	return( 0 );
}

/*
 *		S P M _ P I X _ S A V E
 *
 *  Save a sphere structure as an 'nx' by 'ny' pix file.
 *  Returns -1 on error, else 0.
 */
int
spm_px_save(spm_map_t *mapp, char *filename, int nx, int ny)
{
	int	x, y;
	FILE	*fp;
	unsigned char pixel[3];
	int	got;

	RT_CK_SPM(mapp);

	if( strcmp( filename, "-" ) == 0 )
		fp = stdout;
	else  {
		bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
		fp = fopen( filename, "w" );
		bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
		if( fp == NULL )
			return( -1 );
	}

	for( y = 0; y < ny; y++ ) {
		for( x = 0; x < nx; x++ ) {
			spm_read( mapp, pixel, (double)x/(double)nx, (double)y/(double)ny );
			bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
			got = fwrite( (char *)pixel, sizeof(pixel), 1, fp );	/* res_syscall */
			bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
			if( got != 1 )  {
				bu_log("spm_px_save(%s): write error\n", filename);
				bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
				(void) fclose( fp );
				bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
				return( -1 );
			}
		}
	}

	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	(void) fclose( fp );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */

	return( 0 );
}

/*
 * 		S P M _ D U M P
 *
 *  Display a sphere structure on stderr.
 *  Used for debugging.
 */
void
spm_dump(spm_map_t *mp, int verbose)
{
	int	i;

	RT_CK_SPM(mp);

	bu_log("elsize = %d\n", mp->elsize );
	bu_log("ny = %d\n", mp->ny );
	bu_log("_data = 0x%x\n", mp->_data );
	if( !verbose )  return;
	for( i = 0; i < mp->ny; i++ ) {
		bu_log("  nx[%d] = %3d, xbin[%d] = 0x%x\n",
			i, mp->nx[i], i, mp->xbin[i] );
	}
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/sphmap.c,v 11.8 2004/04/05 07:46:41 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/sphmap.c,v 11.6 2002/08/20 17:07:37 jra Exp $ (BRL)";
d49 1
a49 3
spm_init( N, elsize )
int	N;
int	elsize;
d103 1
a103 2
spm_free( mp )
spm_map_t *mp;
d137 1
a137 4
spm_read( mapp, valp, u, v )
register spm_map_t	*mapp;
register unsigned char	*valp;
double	u, v;
d165 1
a165 4
spm_write( mapp, valp, u, v )
register spm_map_t	*mapp;
register unsigned char	*valp;
double	u, v;
d193 1
a193 3
spm_get( mapp, u, v )
register spm_map_t	*mapp;
double	u, v;
d216 1
a216 3
spm_load( mapp, filename )
spm_map_t *mapp;
char	*filename;
d255 1
a255 3
spm_save( mapp, filename )
spm_map_t *mapp;
char	*filename;
d302 1
a302 4
spm_px_load( mapp, filename, nx, ny )
spm_map_t *mapp;
char	*filename;
int	nx, ny;
d375 1
a375 4
spm_px_save( mapp, filename, nx, ny )
spm_map_t *mapp;
char	*filename;
int	nx, ny;
d424 1
a424 3
spm_dump( mp, verbose )
spm_map_t *mp;
int	verbose;
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/sphmap.c,v 11.4 2000/07/11 23:30:40 cjohnson Exp $ (BRL)";
@


11.6.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbn/sphmap.c,v 11.7 2004/02/02 17:39:06 morrison Exp $ (BRL)";
@


11.6.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/sphmap.c,v 11.7 2004/02/02 17:39:06 morrison Exp $ (BRL)";
@


11.6.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/sphmap.c,v 11.6.10.1 2004/02/12 18:39:33 erikg Exp $ (BRL)";
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/sphmap.c,v 11.6 2002/08/20 17:07:37 jra Exp $ (BRL)";
d49 3
a51 1
spm_init(int N, int elsize)
d105 2
a106 1
spm_free(spm_map_t *mp)
d140 4
a143 1
spm_read(register spm_map_t *mapp, register unsigned char *valp, double u, double v)
d171 4
a174 1
spm_write(register spm_map_t *mapp, register unsigned char *valp, double u, double v)
d202 3
a204 1
spm_get(register spm_map_t *mapp, double u, double v)
d227 3
a229 1
spm_load(spm_map_t *mapp, char *filename)
d268 3
a270 1
spm_save(spm_map_t *mapp, char *filename)
d317 4
a320 1
spm_px_load(spm_map_t *mapp, char *filename, int nx, int ny)
d393 4
a396 1
spm_px_save(spm_map_t *mapp, char *filename, int nx, int ny)
d445 3
a447 1
spm_dump(spm_map_t *mp, int verbose)
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d49 3
a51 1
spm_init(int N, int elsize)
d105 2
a106 1
spm_free(spm_map_t *mp)
d140 4
a143 1
spm_read(register spm_map_t *mapp, register unsigned char *valp, double u, double v)
d171 4
a174 1
spm_write(register spm_map_t *mapp, register unsigned char *valp, double u, double v)
d202 3
a204 1
spm_get(register spm_map_t *mapp, double u, double v)
d227 3
a229 1
spm_load(spm_map_t *mapp, char *filename)
d268 3
a270 1
spm_save(spm_map_t *mapp, char *filename)
d317 4
a320 1
spm_px_load(spm_map_t *mapp, char *filename, int nx, int ny)
d393 4
a396 1
spm_px_save(spm_map_t *mapp, char *filename, int nx, int ny)
d445 3
a447 1
spm_dump(spm_map_t *mp, int verbose)
@


11.4
log
@LINT picking.  Missing includes and static const for RCSids
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/sphmap.c,v 11.3 1999/06/03 01:17:41 mike Exp $ (BRL)";
d49 1
a49 3
spm_init( N, elsize )
int	N;
int	elsize;
d103 1
a103 2
spm_free( mp )
spm_map_t *mp;
d137 1
a137 4
spm_read( mapp, valp, u, v )
register spm_map_t	*mapp;
register unsigned char	*valp;
double	u, v;
d165 1
a165 4
spm_write( mapp, valp, u, v )
register spm_map_t	*mapp;
register unsigned char	*valp;
double	u, v;
d193 1
a193 3
spm_get( mapp, u, v )
register spm_map_t	*mapp;
double	u, v;
d216 1
a216 3
spm_load( mapp, filename )
spm_map_t *mapp;
char	*filename;
d255 1
a255 3
spm_save( mapp, filename )
spm_map_t *mapp;
char	*filename;
d302 1
a302 4
spm_px_load( mapp, filename, nx, ny )
spm_map_t *mapp;
char	*filename;
int	nx, ny;
d375 1
a375 4
spm_px_save( mapp, filename, nx, ny )
spm_map_t *mapp;
char	*filename;
int	nx, ny;
d424 1
a424 3
spm_dump( mp, verbose )
spm_map_t *mp;
int	verbose;
@


11.3
log
@
sed4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/sphmap.c,v 11.2 1997/12/16 00:11:46 mike Exp $ (BRL)";
d26 5
@


11.2
log
@Converted to bu_semaphore_acquire()
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/sphmap.c,v 11.1 1995/01/04 09:58:40 mike Rel4_4 mike $ (BRL)";
d27 1
d29 1
a29 1
#include "raytrace.h"
d51 1
a51 1
	mapp = (spm_map_t *)rt_malloc( sizeof(spm_map_t), "spm_map_t");
d58 1
a58 1
	mapp->nx = (int *) rt_malloc( (unsigned)(N/2 * sizeof(*(mapp->nx))), "sph nx" );
d63 1
a63 1
	mapp->xbin = (unsigned char **) rt_malloc( (unsigned)(N/2 * sizeof(char *)), "sph xbin" );
d71 1
a71 1
		nx = ceil( N*cos( i*rt_twopi/N ) );
d79 1
a79 1
	mapp->_data = (unsigned char *) rt_calloc( (unsigned)total, elsize, "spm_init data" );
d108 1
a108 1
		(void) rt_free( (char *)mp->_data, "sph _data" );
d113 1
a113 1
		(void) rt_free( (char *)mp->nx, "sph nx" );
d118 1
a118 1
		(void) rt_free( (char *)mp->xbin, "sph xbin" );
d122 1
a122 1
	(void) rt_free( (char *)mp, "spm_map_t" );
d289 1
a289 1
			rt_log("spm_save(%s): write error\n", filename);
d340 1
a340 1
	buffer = (unsigned char *)rt_malloc( (unsigned)(nx*nx*3), "spm_px_load buffer" );
d346 1
a346 1
		rt_log("spm_px_load(%s) read error\n", filename);
d376 1
a376 1
	(void) rt_free( (char *)buffer, "spm buffer" );
d417 1
a417 1
				rt_log("spm_px_save(%s): write error\n", filename);
d448 3
a450 3
	rt_log("elsize = %d\n", mp->elsize );
	rt_log("ny = %d\n", mp->ny );
	rt_log("_data = 0x%x\n", mp->_data );
d453 1
a453 1
		rt_log("  nx[%d] = %3d, xbin[%d] = 0x%x\n",
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/sphmap.c,v 10.3 94/08/10 20:00:47 gdurf Exp $ (BRL)";
d233 1
a233 1
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d235 1
a235 1
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d244 1
a244 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d247 1
a247 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d275 1
a275 1
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d277 1
a277 1
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d283 1
a283 1
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d286 1
a286 1
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d289 1
a289 1
			RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d291 1
a291 1
			RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d296 1
a296 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d298 1
a298 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d331 1
a331 1
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d333 1
a333 1
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d340 1
a340 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d343 1
a343 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d402 1
a402 1
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d404 1
a404 1
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d412 1
a412 1
			RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d414 1
a414 1
			RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d417 1
a417 1
				RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d419 1
a419 1
				RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d425 1
a425 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d427 1
a427 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
@


10.3
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/sphmap.c,v 10.2 1992/08/27 19:52:35 mike Exp gdurf $ (BRL)";
@


10.2
log
@Added magic number protection.
Added verbose flag to spm_dump().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/sphmap.c,v 10.1 91/10/12 06:41:01 mike Rel4_0 Locker: mike $ (BRL)";
d21 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/sphmap.c,v 9.2 91/06/30 00:11:24 mike Exp $ (BRL)";
d87 1
a87 1

d100 1
d104 1
a104 1
	if( mp->_data != NULL )
d106 2
d109 1
a109 1
	if( mp->nx != NULL )
d111 2
d114 1
a114 1
	if( mp->xbin != NULL )
d116 2
d141 2
d172 2
d201 2
d226 2
d268 2
d324 2
d395 2
d437 1
a437 1
spm_dump( mp )
d439 1
d443 2
d448 1
@


9.2
log
@Protected all I/O with RES_ACQUIRE( res_syscall )
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/sphmap.c,v 9.1 89/05/19 05:57:09 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sphmap.c,v 8.4 89/04/27 23:10:44 phil Exp $ (BRL)";
d215 7
a221 2
	else if( (fp = fopen( filename, "r" )) == NULL )
		return( -1 );
d227 2
a228 1
	y = fread( (char *)mapp->_data, mapp->elsize, total, fp );
d230 1
d250 1
d255 7
a261 2
	else if( (fp = fopen( filename, "w" )) == NULL )
		return( -1 );
d264 7
a270 2
		if( fwrite( (char *)mapp->xbin[i], mapp->elsize,
		    mapp->nx[i], fp ) != mapp->nx[i] ) {
d272 1
d277 1
d279 1
d309 7
a315 2
	else if( (fp = fopen( filename, "r" )) == NULL )
		return( -1 );
d319 2
a320 2
	/* XXX */
	(void) fread( (char *)buffer, 3, nx*ny, fp );
d322 5
d374 1
d378 7
a384 2
	else if( (fp = fopen( filename, "w" )) == NULL )
		return( -1 );
d389 10
a398 1
			(void) fwrite( (char *)pixel, sizeof(pixel), 1, fp );
d402 4
d421 3
a423 3
	fprintf( stderr, "elsize = %d\n", mp->elsize );
	fprintf( stderr, "ny = %d\n", mp->ny );
	fprintf( stderr, "_data = 0x%x\n", mp->_data );
d425 1
a425 1
		fprintf( stderr, "  nx[%d] = %3d, xbin[%d] = 0x%x\n",
@


8.4
log
@moved rt_twopi to const.c
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sphmap.c,v 8.3 89/04/11 13:07:28 phil Locked $ (BRL)";
@


8.3
log
@oops, need vmath.h to include raytrace.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sphmap.c,v 8.2 89/04/11 12:33:15 phil Locked $ (BRL)";
a27 2

double	rt_twopi = 6.283185307179586476925286;
@


8.2
log
@included raytrace.h, switch to rt_malloc, calloc, and free
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sphmap.c,v 8.1 88/10/05 00:31:43 phil Locked $ (BRL)";
d25 1
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sphmap.c,v 1.2 88/09/09 21:32:25 mike Exp $ (BRL)";
d25 1
a27 3
char	*malloc();
char	*calloc();

d77 1
a77 1
	mapp->_data = (unsigned char *) calloc( (unsigned)total, elsize );
d293 1
a293 1
	buffer = (unsigned char *)malloc( (unsigned)(nx*nx*3) );
d324 1
a324 1
	(void) free( (char *)buffer );
@


1.2
log
@Added include for machine.h, to cover bzero()
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sphmap.c,v 1.1 88/01/29 22:24:57 mike Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *			S P M . C
d4 1
a4 1
 *  Spherical Data Structures/Texture Maps
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: spm.c,v 7.1 87/11/02 23:56:31 mike Rel $ (BRL)";
d24 1
@
