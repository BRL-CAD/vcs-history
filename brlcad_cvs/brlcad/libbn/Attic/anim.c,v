head	11.22;
access;
symbols
	ansi-20040405-merged:11.18.2.2
	postmerge-20040405-ansi:11.20
	premerge-20040404-ansi:11.19
	postmerge-autoconf:11.19
	autoconf-freeze:11.18.10.1
	premerge-autoconf:11.19
	ansi-20040316-freeze:11.18.2.1
	postmerge-20040315-windows:11.19
	premerge-20040315-windows:11.19
	windows-20040315-freeze:11.18.4.1
	autoconf-20031203:11.18
	autoconf-20031202:11.18
	autoconf-branch:11.18.0.10
	phong-branch:11.18.0.8
	photonmap-branch:11.18.0.6
	rel-6-1-DP:11.18
	windows-branch:11.18.0.4
	rel-6-0-2:11.16
	ansi-branch:11.18.0.2
	rel-6-0-1-branch:11.16.0.2
	hartley-6-0-post:11.17
	hartley-6-0-pre:11.16
	rel-6-0-1:11.16
	rel-6-0:11.16
	rel-5-4:11.15
	offsite-5-3-pre:11.16
	rel-5-3:11.15
	rel-5-2:11.15
	rel-5-1-branch:11.15.0.2
	rel-5-1:11.15
	rel-5-0:11.14
	rel-5-0-beta:11.14
	rel-4-5:11.14
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.22
date	2004.05.21.18.06.21;	author morrison;	state dead;
branches;
next	11.21;

11.21
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.20;

11.20
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2004.02.02.17.39.06;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2002.08.20.17.07.35;	author jra;	state Exp;
branches
	11.18.2.1
	11.18.4.1
	11.18.10.1;
next	11.17;

11.17
date	2002.08.15.20.54.47;	author hartley;	state Exp;
branches;
next	11.16;

11.16
date	2000.10.24.18.02.34;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.12.29.20.28.10;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.12.17.23.33.39;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.03.24.14.51.59;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.01.09.01.02.35;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.08.01.21.37.28;	author cnuzman;	state Exp;
branches;
next	11.10;

11.10
date	96.07.31.20.23.43;	author cnuzman;	state Exp;
branches;
next	11.9;

11.9
date	96.07.30.21.14.52;	author cnuzman;	state Exp;
branches;
next	11.8;

11.8
date	96.07.26.20.43.56;	author cnuzman;	state Exp;
branches;
next	11.7;

11.7
date	96.07.15.19.27.57;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.06.25.23.11.01;	author cnuzman;	state Exp;
branches;
next	11.5;

11.5
date	96.06.24.18.46.04;	author cnuzman;	state Exp;
branches;
next	11.4;

11.4
date	96.06.24.15.36.31;	author cnuzman;	state Exp;
branches;
next	11.3;

11.3
date	96.06.18.22.18.43;	author cnuzman;	state Exp;
branches;
next	11.2;

11.2
date	95.07.10.23.32.44;	author cnuzman;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.28.48;	author mike;	state Rel4_4;
branches;
next	1.9;

1.9
date	94.08.25.11.01.06;	author cnuzman;	state Exp;
branches;
next	1.8;

1.8
date	94.08.11.13.49.19;	author cnuzman;	state Exp;
branches;
next	1.7;

1.7
date	94.07.12.12.08.36;	author cnuzman;	state Exp;
branches;
next	1.6;

1.6
date	94.06.24.18.30.00;	author cnuzman;	state Exp;
branches;
next	1.5;

1.5
date	94.06.09.17.33.29;	author cnuzman;	state Exp;
branches;
next	1.4;

1.4
date	94.06.09.17.21.12;	author cnuzman;	state Exp;
branches;
next	1.3;

1.3
date	94.06.06.14.48.01;	author cnuzman;	state Exp;
branches;
next	1.2;

1.2
date	94.06.01.15.36.00;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	94.06.01.10.28.50;	author stay;	state Exp;
branches;
next	;

11.18.2.1
date	2002.09.19.18.01.08;	author morrison;	state Exp;
branches;
next	11.18.2.2;

11.18.2.2
date	2004.03.17.21.16.46;	author morrison;	state Exp;
branches;
next	;

11.18.4.1
date	2004.03.11.23.41.43;	author morrison;	state Exp;
branches;
next	;

11.18.10.1
date	2004.02.12.18.39.32;	author erikg;	state Exp;
branches;
next	;


desc
@routines used for cnuzman style animation
@


11.22
log
@moved to src/
@
text
@/*				A N I M . C
 *
 *	Routines useful in animation programs.
 *
 *  Author -
 *	Carl J. Nuzman
 *  
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 *
 *
 ***********************************************************************
 *
 *	This file includes the following routines:
 *
 *	anim_v_permute()	apply camera animation permutation
 *	anim_v_unpermute()	undo camera animation permutation
 *	anim_tran()		transpose matrix in place
 *		
 *	anim_mat2zyx()		extract angles from rotation matrix
 *	anim_mat2ypr()		extract yaw,pitch,roll from rotation matrix
 *	anim_mat2quat()		extract quaternion from rotation matrix
 *
 *	anim_ypr2mat()		create rotation matrix from ypr, etc.
 *	anim_ypr2vmat()
 *	anim_y_p_r2mat()
 *	anim_dy_p_r2mat()
 *	anim_dy_p_r2vmat()
 *	anim_x_y_z2mat()
 *	anim_dx_y_z2mat()
 *	anim_z_y_x2mat()
 *	anim_dz_y_x2mat()
 *	anim_quat2mat()
 *	anim_dir2mat()		create rotation matrix from direction
 *	anim_dirn2mat()		create rot matrix from dir and normal
 *	
 *	anim_steer_mat()	automatic steering
 *
 *	anim_add_trans()	add pre- and post- translation to matrix
 *	anim_rotatez()		rotate vector about z-axis
 *	anim_mat_print()	print matrix with optional semi-colon
 *	anim_view_rev()		reverse view matrix
 *
 *
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "anim.h"

#ifndef	M_PI
#define M_PI	3.14159265358979323846
#endif

#define NORMAL		0
#define ERROR1		1
#define ERROR2		2

/* Orientation conventions:
 * The default object orientation is facing the positive x-axis, with 
 * the positive y-axis to the object's left and the positive z-axis above
 * the object.
 * The default view orientation for rt and mged is facing the negative z-axis,
 * with the negative x-axis leading to the left and the positive y-axis 
 * going upwards.
 */

/* ANIM_V_PERMUTE - Pre-multiply a rotation matrix by a matrix 
 * which maps the z-axis to the negative x-axis, the y-axis to the 
 * z-axis and the x-axis to the negative y-axis. 
 * This has the effect of twisting an object in the default view orientation
 * into the default object orientation before applying the matrix.
 * Given a matrix designed to operate on an object, yield a matrix which 
 * operates on the view.
 */
void anim_v_permute(mat_t m)
{
	int i;
	fastf_t store;

	for (i=0; i<9; i+=4){
		store = m[i];
		m[i] = -m[i+1];
		m[i+1] = m[i+2];
		m[i+2] = -store;
	}
}

/* ANIM_V_UNPERMUTE - Undo the mapping done by anim_v_permute().
 * This has the effect of twisting an object in the default object 
 * orientation into the default view orientation before applying the
 * matrix.
 * Given a matrix designed to operate on the view, yield a matrix which 
 * operates on an object.
 */
void anim_v_unpermute(mat_t m)
{
	int i;
	fastf_t store;

	for (i=0; i<9; i+=4){
		store = m[i+2];
		m[i+2] = m[i+1];
		m[i+1] = -m[i];
		m[i] = -store;
	}
}

/* Transpose matrix in place */
void anim_tran(mat_t m)
{
	int i;
	fastf_t store;
#if 1
	/* The sun4's complain about no automatic aggregate initialization,
	 * so we'll do it another way. :-(
	 */
	int src[6];
	int dst[6];

	src[0] = 1;
	src[1] = 2;
	src[2] = 3;
	src[3] = 6;
	src[4] = 7;
	src[5] = 11;

	dst[0] = 4;
	dst[1] = 8;
	dst[2] = 12;
	dst[3] = 9;
	dst[4] = 13;
	dst[5] = 14;
#else
	int src[] = { 1, 2, 3, 6, 7, 11 };
	int dst[] = { 4, 8, 12, 9, 13, 14};
#endif

	for (i=0; i<6; i++) {
		store = m[dst[i]];
		m[dst[i]] = m[src[i]];
		m[src[i]] = store;
	}
}

/***************************************
 *ANIM_MAT2* - Conversions from matrices
 ***************************************/

/* ANIM_MAT2ZYX - Convert the rotational part of a 4x4 transformation matrix
 * to zyx form, that is to say, rotations carried out in the order z, y,
 * and then x. The angles are stored in radians as a vector in the order 
 * x,y,z. A return value of ERROR1 means that arbitrary assumptions were 
 * necessary. ERROR2 means that the conversion failed.
 */
int anim_mat2zyx(const mat_t viewrot, vect_t angle)
{
        int i, return_value, id_x, id_z;
        fastf_t sin_x, sin_z, cos_x, cos_z, big_x, big_z;
        static fastf_t previous[3];

        if ((viewrot[1]==0.0) && (viewrot[0]==0.0)){
                return_value = ERROR1;
                angle[0] = 0.0;
                angle[2] = atan2(viewrot[4],viewrot[5]);
                /*bu_log("Warning: x arbitrarily set to 0.0; z set to %f.\n",angle[2]);*/
        }
        else {
                return_value = NORMAL;
                angle[2] = atan2(-viewrot[1],viewrot[0]);
                angle[0] = atan2(-viewrot[6],viewrot[10]);
        }

        sin_x = sin(angle[0]);
        sin_z = sin(angle[2]);
        cos_x = cos(angle[0]);
        cos_z = cos(angle[2]);

	/* in principle, we can use the sin_x or cos_x with sin_z or cos_z to
	 * figure out angle[1], as long as they are non-zero. To avoid
	 * ill-conditioning effects, we choose the two that are greatest in
	 * absolute value
	 */

	id_z  = (fabs(sin_z) > fabs(cos_z)) ? 1 : 0;
	big_z = id_z ? sin_z : cos_z;
	id_x  = (fabs(sin_x) > fabs(cos_x)) ? 1 : 0;
	big_x = id_x ? sin_x : cos_x;

	if (fabs(big_x*big_z) < VDIVIDE_TOL){ /* this should be impossible*/
                /* unable to calculate pitch*/
                return(ERROR2);
        }
        else if ( id_x && (!id_z) )
                angle[1]=atan2( (viewrot[4] - cos_x*sin_z)/(sin_x*cos_z), -viewrot[6]/sin_x);
        else if ( (!id_x) && (!id_z) )
                angle[1]=atan2( (-viewrot[8] + sin_x*sin_z)/(cos_x*cos_z), viewrot[0]/cos_z);
        else if ( id_x && id_z )
                angle[1]=atan2( (-viewrot[5] + cos_x*cos_z)/(sin_x*sin_z), -viewrot[1]/sin_z);
        else if ( (!id_x) && id_z )
                angle[1]=atan2( (viewrot[9] - sin_x*cos_z)/(cos_x*sin_z), viewrot[10]/cos_x);


        /* assume the smallest possible arc-length from frame to frame */
        for (i=0; i<3; i++) {
                while ((angle[i] - previous[i]) > M_PI)
                        angle[i] -= (2.0*M_PI);
                while ((previous[i] - angle[i]) > M_PI)
                        angle[i] += (2.0*M_PI);
                previous[i] = angle[i];
        }

	return(return_value);
}

/* ANIM_MAT2YPR - Convert the rotational part of a 4x4 transformation matrix
 * to yaw-pitch-roll form, that is to say, +roll degrees about the x-axis, 
 * -pitch degrees about the y-axis, and +yaw degrees about the
 * z-axis. The angles are stored in radians as a vector in the order y,p,r.
 * A return of ERROR1 means that arbitrary assumptions were necessary.
 * ERROR2 means that the conversion failed.
 */
int anim_mat2ypr(mat_t viewrot, vect_t angle)
{
        int i, return_value, id_y, id_r;
        fastf_t sin_y, sin_r, cos_y, cos_r, big_y, big_r;
        static fastf_t prev_angle[3];

        if ((viewrot[9]==0.0) && (viewrot[10]==0.0)){
                return_value = ERROR1;
                angle[2] = 0.0;
                angle[0] = atan2(-viewrot[1],viewrot[5]);
                /*bu_log("Warning: roll arbitrarily set to 0.0; yaw set to %f radians.\n",angle[0]);*/
        }
        else {
                return_value = NORMAL;
                angle[0] = atan2(viewrot[4],viewrot[0]);
                angle[2] = atan2(viewrot[9],viewrot[10]);
        }

        sin_y = sin(angle[0]);
        sin_r = sin(angle[2]);
        cos_y = cos(angle[0]);
        cos_r = cos(angle[2]);

	/* in principle, we can use sin_y or cos_y with sin_r or cos_r to
	 * figure out angle[1], as long as they are non-zero. To avoid
	 * ill-conditioning effects, we choose the two that are greatest in
	 * absolute value
	 */

	id_y  = (fabs(sin_y) > fabs(cos_y)) ? 1 : 0;
	big_y = id_y ? sin_y : cos_y;
	id_r  = (fabs(sin_r) > fabs(cos_r)) ? 1 : 0;
	big_r = id_r ? sin_r : cos_r;
 
	if (fabs(big_y*big_r) < VDIVIDE_TOL){ /* this should not happen */
                /* unable to calculate pitch*/
                return(ERROR2);
        }
        else if ( (!id_y) && id_r )
                angle[1] = atan2( -(viewrot[1]+sin_y*cos_r)/(cos_y*sin_r),viewrot[9]/sin_r);
        else if ( id_y && (!id_r) )
                angle[1] = atan2( -(viewrot[6]+cos_y*sin_r)/(sin_y*cos_r),viewrot[10]/cos_r);
        else if ( id_y && id_r )
                angle[1] = atan2( -(viewrot[5]-cos_y*cos_r)/(sin_y*sin_r),viewrot[4]/sin_y);
        else if ( (!id_y) && (!id_r) )
                angle[1] = atan2( -(viewrot[2]-sin_y*sin_r)/(cos_y*cos_r),viewrot[0]/cos_y);


        /* assume the smallest possible arc-length from frame to frame */
        for (i=0; i<3; i++) {
                while ((angle[i] - prev_angle[i]) > M_PI)
                        angle[i] -= (2.0*M_PI);
                while ((prev_angle[i] - angle[i]) > M_PI)
                        angle[i] += (2.0*M_PI);
                prev_angle[i] = angle[i];
        }

	return(return_value);
}

/* ANIM_MAT2QUAT -  This interprets the rotational part of a 4x4 transformation 
 *  matrix in terms of unit quaternions. The result is stored as a vector in 
 * the order x,y,z,w. 
 * The algorithm is from Ken Shoemake, Animating Rotation with Quaternion 
 * Curves, 1985 SIGGraph Conference Proceeding, p.245.
 */
int anim_mat2quat(quat_t quat, const mat_t viewrot)
{
	int i;	
	fastf_t qdiff[4], square, mag1, mag2;
	static fastf_t prev_quat[4];

	square = 0.25 * (1 + viewrot[0] + viewrot[5] + viewrot[10]);
	if ( square != 0.0 ) {
		quat[W] = sqrt(square);
		quat[X] = 0.25 * (viewrot[9] - viewrot[6])/ quat[W];
		quat[Y] = 0.25 * (viewrot[2] - viewrot[8])/ quat[W];
		quat[Z] = 0.25 * (viewrot[4] - viewrot[1])/ quat[W];
	}
	else {
		quat[W] = 0.0;
		square = -0.5 * (viewrot[5] + viewrot[10]);
		if (square != 0.0 ) {
			quat[X] = sqrt(square);
			quat[Y] = 0.5 * viewrot[4] / quat[X];
			quat[Z] = 0.5 * viewrot[8] / quat[X];
		}
		else {
			quat[X] = 0.0;
			square = 0.5 * (1 - viewrot[10]);
			if (square != 0.0){
				quat[Y] = sqrt(square);
				quat[Z] = 0.5 * viewrot[9]/ quat[Y];
			}
			else {
				quat[Y] = 0.0;
				quat[Z] = 1.0;
			}
		}
	}

	/* quaternions on opposite sides of a four-dimensional sphere
		are equivalent. Take the quaternion closest to the previous
		one */

	for (i=0; i<4; i++)
		qdiff[i] = prev_quat[i] - quat[i];
	mag1 = QMAGSQ(qdiff);
	for (i=0; i<4; i++)
		qdiff[i] = prev_quat[i] + quat[i];
	mag2 = QMAGSQ(qdiff);

	for (i=0; i<4; i++) {
		if (mag1 > mag2)  /* inverse of quat would be closer */
			quat[i] = -quat[i];
		prev_quat[i] = quat[i];
	}

	return(1);
}

/***************************************
 *ANIM_*2MAT - Conversions to matrices
 ***************************************/

/* ANIM_YPR2MAT - Create a premultiplication rotation matrix to turn the front
 * of an object (its x-axis) to the given yaw, pitch, and roll, 
 * which is stored in radians in the vector a.
 */
void anim_ypr2mat(mat_t m, const vect_t a)
{
	fastf_t cos_y,cos_p,cos_r,sin_y,sin_p,sin_r;

	cos_y = cos(a[0]);	
	cos_p = cos(a[1]);	
	cos_r = cos(a[2]);	
	sin_y = sin(a[0]);	
	sin_p = sin(a[1]);	
	sin_r = sin(a[2]);	

        m[0] =	 cos_y*cos_p;
	m[1] =	 -cos_y*sin_p*sin_r-sin_y*cos_r;
        m[2] =	 -cos_y*sin_p*cos_r+sin_y*sin_r;
	m[3] =	0;
        m[4] = 	sin_y*cos_p;
        m[5] =	-sin_y*sin_p*sin_r+cos_y*cos_r;
        m[6] =	-sin_y*sin_p*cos_r-cos_y*sin_r;
	m[7] =	0;
        m[8]= 	sin_p;
        m[9] = 	cos_p*sin_r;
        m[10] = cos_p*cos_r;
	m[11] =	0.0;
	m[12] =	0.0;
	m[13] =	0.0;
	m[14] =	0.0;
	m[15] =	1.0;
}

/* ANIM_YPR2VMAT - Create a post-multiplication rotation matrix ,which could
 * be used to move the virtual camera to the given yaw, pitch, 
 * and roll,  which are stored in radians in the given vector a. The 
 * following are equivalent sets of commands:
 * 	ypr2vmat(matrix,a);
 *		or
 *	ypr2mat(matrix,a);
 * 	v_permute(matrix);
 *	transpose(matrix;
 */
void anim_ypr2vmat(mat_t m, const vect_t a)
{
	fastf_t cos_y,cos_p,cos_r,sin_y,sin_p,sin_r;

	cos_y = cos(a[0]);	
	cos_p = cos(a[1]);	
	cos_r = cos(a[2]);	
	sin_y = sin(a[0]);	
	sin_p = sin(a[1]);	
	sin_r = sin(a[2]);	

	m[0] =    -cos_y*sin_p*sin_r-sin_y*cos_r;
	m[1] =    -sin_y*sin_p*sin_r+cos_y*cos_r;
	m[2] =     cos_p*sin_r;
	m[3] =     0;
	m[4] =    -cos_y*sin_p*cos_r+sin_y*sin_r;
	m[5] =    -sin_y*sin_p*cos_r-cos_y*sin_r;
	m[6] =     cos_p*cos_r;
	m[7] =     0;
	m[8] =     cos_y*cos_p;
	m[9] =     sin_y*cos_p;
	m[10] =    sin_p;
	m[11] =	   0.0;
	m[12] =	   0.0;
	m[13] =	   0.0;
	m[14] =	   0.0;
	m[15] =	   1.0;
}

/* ANIM_Y_P_R2MAT - Make matrix to rotate an object to the given yaw,
 * pitch, and roll. (Specified in radians.)
 */
void anim_y_p_r2mat(mat_t m, double y, double p, double r)
{
        fastf_t cos_y = cos(y);
        fastf_t sin_y = sin(y);
        fastf_t cos_p = cos(p);
        fastf_t sin_p = sin(p);
        fastf_t cos_r = cos(r);
        fastf_t sin_r = sin(r);

        m[0] = cos_y*cos_p;
        m[1] = -cos_y*sin_p*sin_r-sin_y*cos_r;
        m[2] = -cos_y*sin_p*cos_r+sin_y*sin_r;
        m[4] = sin_y*cos_p;
        m[5] = -sin_y*sin_p*sin_r+cos_y*cos_r;
        m[6] = -sin_y*sin_p*cos_r-cos_y*sin_r;
        m[8]= sin_p;
        m[9] = cos_p*sin_r;
        m[10] = cos_p*cos_r;
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0;
        m[15]=1;
}




/* ANIM_DY_P_R2MAT - Make matrix to rotate an object to the given yaw,
 * pitch, and roll. (Specified in degrees.)
 */
void anim_dy_p_r2mat(mat_t m, double y, double p, double r)
{
        fastf_t radian_yaw = y*(M_PI*0.0055555555556);
        fastf_t radian_pitch = p*(M_PI*0.0055555555556);
        fastf_t radian_roll = r*(M_PI*0.0055555555556);

        fastf_t cos_y = cos(radian_yaw);
        fastf_t sin_y = sin(radian_yaw);
        fastf_t cos_p = cos(radian_pitch);
        fastf_t sin_p = sin(radian_pitch);
        fastf_t cos_r = cos(radian_roll);
        fastf_t sin_r = sin(radian_roll);

        m[0] = cos_y*cos_p;
        m[1] = -cos_y*sin_p*sin_r-sin_y*cos_r;
        m[2] = -cos_y*sin_p*cos_r+sin_y*sin_r;
        m[4] = sin_y*cos_p;
        m[5] = -sin_y*sin_p*sin_r+cos_y*cos_r;
        m[6] = -sin_y*sin_p*cos_r-cos_y*sin_r;
        m[8]= sin_p;
        m[9] = cos_p*sin_r;
        m[10] = cos_p*cos_r;
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0;
        m[15]=1;
}


/* ANIM_DY_P_R2VMAT - Make a view rotation matrix, given desired yaw, pitch
 * and roll. (Note that the matrix is a permutation of the object rotation
 * matrix).
 */
void anim_dy_p_r2vmat(mat_t m, double yaw, double pch, double rll)
{

	float ryaw = yaw*(M_PI*0.0055555555556);
	float rpch = pch*(M_PI*0.0055555555556);
	float rrll = rll*(M_PI*0.0055555555556);
	
	float cos_y = cos(ryaw);
	float sin_y = sin(ryaw);
	float cos_p = cos(rpch);
	float sin_p = sin(rpch);
	float cos_r = cos(rrll);
	float sin_r = sin(rrll);
	
	m[0] = -cos_y*sin_p*sin_r-sin_y*cos_r;
	m[1] = -sin_y*sin_p*sin_r+cos_y*cos_r;
	m[2] = cos_p*sin_r;
	m[4] = -cos_y*sin_p*cos_r+sin_y*sin_r;
	m[5] = -sin_y*sin_p*cos_r-cos_y*sin_r;
	m[6] = cos_p*cos_r;
	m[8] = cos_y*cos_p;
	m[9] = sin_y*cos_p;
	m[10]= sin_p;
	m[3]=m[7]=m[11]=0;
	m[12]=m[13]=m[14]=0;
	m[15]=1;

}

/* ANIM_X_Y_Z2MAT - Make a rotation matrix corresponding to a rotation of 
 * "x" radians about the x-axis, "y" radians about the y-axis, and
 * then "z" radians about the z-axis.
 */
void anim_x_y_z2mat(mat_t m, double x, double y, double z)
{
        fastf_t cosx = cos(x);
        fastf_t sinx = sin(x);
        fastf_t cosy = cos(y);
        fastf_t siny = sin(y);
        fastf_t cosz = cos(z);
        fastf_t sinz = sin(z);

        m[0] = cosz*cosy;
        m[1] = cosz*siny*sinx-sinz*cosx;
        m[2] = cosz*siny*cosx+sinz*sinx;
        m[4] = sinz*cosy;
        m[5] = sinz*siny*sinx+cosz*cosx;
        m[6] = sinz*siny*cosx-cosz*sinx;
        m[8] = -siny;
        m[9] = cosy*sinx;
        m[10] = cosy*cosx;
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0;
        m[15]=1;
}



/* ANIM_DX_Y_Z2MAT - Make a rotation matrix corresponding to a rotation of 
 * "x" degrees about the x-axis, "y" degrees about the y-axis, and
 * then "z" degrees about the z-axis.
 */
void anim_dx_y_z2mat(mat_t m, double x, double y, double z)
{
	fastf_t cosx,cosy,cosz,sinx,siny,sinz;

	x *= (M_PI*0.0055555555556);
	y *= (M_PI*0.0055555555556);
	z *= (M_PI*0.0055555555556);

        cosx = cos(x);
        sinx = sin(x);
        cosy = cos(y);
        siny = sin(y);
        cosz = cos(z);
        sinz = sin(z);

        m[0] = cosz*cosy;
        m[1] = cosz*siny*sinx-sinz*cosx;
        m[2] = cosz*siny*cosx+sinz*sinx;
        m[4] = sinz*cosy;
        m[5] = sinz*siny*sinx+cosz*cosx;
        m[6] = sinz*siny*cosx-cosz*sinx;
        m[8] = -siny;
        m[9] = cosy*sinx;
        m[10] = cosy*cosx;
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0.0;
        m[15]=1.0;
}

/* ANIM_ZYX2MAT - Make a rotation matrix corresponding to a rotation of 
 * "z" radians about the z-axis, "y" radians about the y-axis, and
 * then "x" radians about the x-axis. 
 */
void anim_zyx2mat(mat_t m, const vect_t a)
{
	fastf_t cosX,cosY,cosZ,sinX,sinY,sinZ;

	cosX = cos(a[0]);	
	cosY = cos(a[1]);	
	cosZ = cos(a[2]);	
	sinX = sin(a[0]);	
	sinY = sin(a[1]);	
	sinZ = sin(a[2]);	

	m[0] =     cosY*cosZ;
	m[1] =    -cosY*sinZ;
	m[2] =     sinY;
	m[3] =     0;
	m[4] =     cosX*sinZ + sinX*sinY*cosZ;
	m[5] =     cosX*cosZ - sinX*sinY*sinZ;
	m[6] =    -sinX*cosY;
	m[7] =     0;
	m[8] =     sinX*sinZ - cosX*sinY*cosZ;
	m[9] =     sinX*cosZ + cosX*sinY*sinZ;
	m[10] =    cosX*cosY;
	m[11] =	   0.0;
	m[12] =	   0.0;
	m[13] =	   0.0;
	m[14] =	   0.0;
	m[15] =	   1.0;

}

/* ANIM_Z_Y_X2MAT - Make a rotation matrix corresponding to a rotation of 
 * "z" radians about the z-axis, "y" radians about the y-axis, and
 * then "x" radians about the x-axis.
 */
void anim_z_y_x2mat(mat_t m, double x, double y, double z)
{
        fastf_t cosx = cos(x);
        fastf_t sinx = sin(x);
        fastf_t cosy = cos(y);
        fastf_t siny = sin(y);
        fastf_t cosz = cos(z);
        fastf_t sinz = sin(z);

	m[0] =  cosy*cosz;
	m[1] = -cosy*sinz;
	m[2] =  siny;
	m[4] =  cosx*sinz + sinx*siny*cosz;
	m[5] =  cosx*cosz - sinx*siny*sinz;
	m[6] = -sinx*cosy;
	m[8] =  sinx*sinz - cosx*siny*cosz;
	m[9] =  sinx*cosz + cosx*siny*sinz;
	m[10]=  cosx*cosy;
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0.0;
        m[15]=1.0;
}


/* ANIM_DZ_Y_X2MAT - Make a rotation matrix corresponding to a rotation of 
 * "z" degrees about the z-axis, "y" degrees about the y-axis, and
 * then "x" degrees about the x-axis.
 */
void anim_dz_y_x2mat(mat_t m, double x, double y, double z)
{
	fastf_t cosx,cosy,cosz,sinx,siny,sinz;

	x *= (M_PI*0.0055555555556);
	y *= (M_PI*0.0055555555556);
	z *= (M_PI*0.0055555555556);

        cosx = cos(x);
        sinx = sin(x);
        cosy = cos(y);
        siny = sin(y);
        cosz = cos(z);
        sinz = sin(z);

	m[0] =  cosy*cosz;
	m[1] = -cosy*sinz;
	m[2] =  siny;
	m[4] =  cosx*sinz + sinx*siny*cosz;
	m[5] =  cosx*cosz - sinx*siny*sinz;
	m[6] = -sinx*cosy;
	m[8] =  sinx*sinz - cosx*siny*cosz;
	m[9] =  sinx*cosz + cosx*siny*sinz;
	m[10]=  cosx*cosy;
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0;
        m[15]=1;
}


/* ANIM_QUAT2MAT - Make 4x4 matrix from the given quaternion
 * Note: these quaternions are the conjugates of the quaternions 
 * used in the librt/qmath.c quat_quat2mat()
 */

void anim_quat2mat(mat_t m, const quat_t qq)
{
	fastf_t two_q[4];
	quat_t q;

	QMOVE(q, qq);
	QUNITIZE(q);

	VADD2N(two_q,q,q,4);

	m[0] 	= 1.0 - two_q[Y]*q[Y] - two_q[Z]*q[Z];
	m[1]	= two_q[X]*q[Y] - two_q[W]*q[Z];
	m[2]	= two_q[X]*q[Z] + two_q[W]*q[Y];
	m[3]	= 0.0;
	m[4]	= two_q[X]*q[Y] + two_q[W]*q[Z];
	m[5] 	= 1.0 - two_q[X]*q[X] - two_q[Z]*q[Z];
	m[6]	= two_q[Y]*q[Z] - two_q[W]*q[X];
	m[7]	= 0.0;
	m[8]	= two_q[X]*q[Z] - two_q[W]*q[Y];
	m[9]	= two_q[Y]*q[Z] + two_q[W]*q[X];
	m[10] 	= 1.0 - two_q[X]*q[X] - two_q[Y]*q[Y];
	m[11]	= 0.0;
	m[12]	= 0.0;
	m[13]	= 0.0;
	m[14]	= 0.0;
	m[15]	= 1.0;
}



/* ANIM_DIR2MAT - make a matrix which turns a vehicle from the x-axis to 
 * point in the desired direction, staying "right-side up" (ie the y-axis
 * never has a z-component). A second direction vector is consulted when 
 * the given direction is vertical. This is intended to represent the
 * the direction from a previous frame.
 */
void anim_dir2mat(mat_t m, const vect_t d, const vect_t d2b)
{
        fastf_t hypotenuse, sign;
	vect_t d2;

	VMOVE( d2, d2b );
        sign = 1.0;
        hypotenuse = sqrt(d[0]*d[0]+d[1]*d[1]);
        if (hypotenuse < VDIVIDE_TOL){ /* vertical direction - use d2 to
                                        * determine roll */
                hypotenuse = sqrt(d2[0]*d2[0]+d2[1]*d2[1]);
                if (hypotenuse < VDIVIDE_TOL){ /* use x-axis as default*/
                        VSET(d2,1,0,0);
                        hypotenuse = 1;
                }
                if (d[2] < 0)
                        sign = -1.0;
                m[1] = -d2[1]/hypotenuse;
                m[5] = d2[0]/hypotenuse;
                m[2] = -sign * d2[0]/hypotenuse;
                m[6] = -sign * d2[1]/hypotenuse;
                m[8] = sign;
                m[0]=m[4]=m[9]=m[10]=0.0;
        }
        else { /* normal - no roll*/
                m[0] = d[0];
                m[1] = -d[1]/hypotenuse;
                m[2] = -d[0]*d[2]/hypotenuse;
                m[4] = d[1];
                m[5] = d[0]/hypotenuse;
                m[6] = -d[1]*d[2]/hypotenuse;
                m[8] = d[2];
                m[9] = 0.0;
                m[10] = hypotenuse;
        }
        m[3]=m[7]=m[11]=0.0;
        m[12]=m[13]=m[14]=0.0;
        m[15]=1.0;

}

/* ANIM_DIRN2MAT - make a matrix which turns a vehicle from the x-axis to 
 * point in the desired direction, staying "right-side up". In cases where
 * the direction is vertical, the second vector is consulted. The second
 * vector defines a normal to the the vertical plane into which the vehicle's 
 * x and z axes should be put. A good choice to put here is the direction 
 * of the vehicle's y-axis in the previous frame.
 */
void anim_dirn2mat(mat_t m, const vect_t dx2, const vect_t dn)
{
	vect_t temp;
	fastf_t hyp, sign,inv,mag;
	vect_t dx;

	VMOVE( dx, dx2 );
	sign = 1.0;
	mag = MAGNITUDE(dx);
	if (mag < VDIVIDE_TOL) {
		bu_log("anim_dirn2mat: Need non-zero vector");
		return;
	}
	inv = 1.0/mag;
	dx[0] *= inv;
	dx[1] *= inv;
	dx[2] *= inv;
	hyp = sqrt(dx[0]*dx[0]+dx[1]*dx[1]);
	if (hyp < VDIVIDE_TOL) { /* vertical - special handling */
		sign = (dx[2] < 0) ? -1.0 : 1.0;
		VSET(temp, dn[0], dn[1], 0.0);
		mag = MAGNITUDE(temp);
		if (mag < VDIVIDE_TOL) {
			/* use default */
			VSET(temp, 0.0, 1.0, 0.0);
			mag = 1.0;
		} else {
			inv = 1.0/mag;
			temp[0] *= inv;
			temp[1] *= inv;
		}
		m[0] = 0.0;
		m[4] = 0.0;
		m[8] = sign;
		m[1] = temp[0];
		m[5] = temp[1];
		m[9] = 0.0;
		m[2] = -sign*temp[1];
		m[6] = sign*temp[0];
		m[10] = 0.0;
	        m[3]=m[7]=m[11]=0.0;
	        m[12]=m[13]=m[14]=0.0;
	        m[15]=1.0;
		return;
	}

	/*else normal*/
	m[0] = dx[0];
        m[1] = -dx[1]/hyp;
        m[2] = -dx[0]*dx[2]/hyp;
        m[4] = dx[1];
        m[5] = dx[0]/hyp;
        m[6] = -dx[1]*dx[2]/hyp;
        m[8] = dx[2];
        m[9] = 0.0;
        m[10] = hyp;
        m[3]=m[7]=m[11]=0.0;
        m[12]=m[13]=m[14]=0.0;
        m[15]=1.0;

}



#define ASM_EMPTY 0
#define ASM_FIRST 1
#define ASM_FULL  2

/*ANIM_STEER_MAT - given the next frame's position, remember the value of
the previous frame's position and calculate a matrix which points the x-axis
in the direction defined by those two positions. Return new matrix, and the
remembered value of the current position, as arguments; return 1 as the 
normal value, and 0 when there is not yet information to remember.
*/
int anim_steer_mat(mat_t  mat, vect_t point, int end)
{
	void anim_dir2mat(fastf_t *m, const fastf_t *d, const fastf_t *d2b), anim_add_trans(fastf_t *m, const fastf_t *post, const fastf_t *pre), anim_view_rev(fastf_t *m);
	static vect_t p1, p2, p3;
	vect_t dir;
	static vect_t norm;
	static int state = ASM_EMPTY;

	VMOVE(p1,p2);
	VMOVE(p2,p3);
	VMOVE(p3,point);

	switch(state) {
	case ASM_EMPTY:
		if (end) {
			state = ASM_EMPTY;
		} else {
			state = ASM_FIRST;
			/* "don't print yet */
		}
		return 0;
	case ASM_FIRST:
		if (end) {
			/* only one point specified, use default direction*/
			VSET(dir,1.0,0.0,0.0);
			VSET(norm,0.0,1.0,0.0);
			state = ASM_EMPTY;
		} else {
			VSUBUNIT(dir,p3,p2);
			VSET(norm, 0.0, 1.0, 0.0);
			state = ASM_FULL;
		}
		break;
	case ASM_FULL:
		if (end) {
			VSUBUNIT(dir,p2,p1);
			state = ASM_EMPTY;
		} else {
			VSUBUNIT(dir,p3,p1);
			state = ASM_FULL;
		}
	}

	/* go for it */
	anim_dirn2mat(mat,dir,norm); /* create basic rotation matrix */
	VSET(norm, mat[1], mat[5], 0.0); /* save for next time */
	VMOVE(point,p2); /* for main's purposes, the current point is p2 */
	return(1); /* return signal go ahead and print */

}


/***************************************
 * Other animation routines
 ***************************************/


/* ANIM_ADD_TRANS - Add pre- and post- translation to a rotation matrix.
 * The resulting matrix has the effect of performing the first
 * translation, followed by the rotation, followed by the second translation.
 */
void anim_add_trans(mat_t m, const vect_t post, const vect_t pre)
{
        int i;
        for (i=0; i<3; i++)
        m[3+i*4] += m[i*4]*pre[0] + m[1+i*4]*pre[1]+m[2+i*4]*pre[2] + post[i];

}

/* ANIM_ROTATEZ - Rotate the vector "d" through "a" radians about the z-axis.
 */
void anim_rotatez(fastf_t a, vect_t d)
{
        fastf_t temp[3];
        fastf_t cos_y = cos(a);
        fastf_t sin_y = sin(a);
        temp[0] = d[0]*cos_y - d[1]*sin_y;
        temp[1] = d[0]*sin_y + d[1]*cos_y;
        d[0]=temp[0];
        d[1]=temp[1];
}

/* ANIM_MAT_PRINT - print out 4X4 matrix, with optional colon
 */
void anim_mat_print(FILE *fp, const mat_t m, int s_colon)
{
        bu_flog( fp,"%.10g %.10g %.10g %.10g\n", m[0], m[1], m[2], m[3]);
        bu_flog( fp,"%.10g %.10g %.10g %.10g\n", m[4], m[5], m[6], m[7]);
        bu_flog( fp,"%.10g %.10g %.10g %.10g\n", m[8], m[9], m[10], m[11]);
        bu_flog( fp,"%.10g %.10g %.10g %.10g", m[12], m[13], m[14], m[15]);
        if (s_colon)
                bu_flog( fp,";");
        bu_flog( fp,"\n");
}



/* ANIM_MAT_PRINTF - print out 4X4 matrix
 * formstr must be less than twenty chars
 */
void anim_mat_printf(
	FILE *fp,
	const mat_t m,
	const char *formstr,
	const char *linestr,
	const char *endstr)
{
	char mystr[80];
	sprintf(mystr,"%s%s%s%s%%s",formstr,formstr,formstr,formstr);
        bu_flog( fp,mystr, m[0], m[1], m[2], m[3], linestr);
        bu_flog( fp,mystr, m[4], m[5], m[6], m[7], linestr);
        bu_flog( fp,mystr, m[8], m[9], m[10], m[11], linestr);
        bu_flog( fp,mystr, m[12], m[13], m[14], m[15], endstr);
}

/* ANIM_VIEW_REV - Reverse the direction of a view matrix, keeping it
 * right-side up
 */
void anim_view_rev(mat_t m)
{
        m[0] = -m[0];
        m[1] = -m[1];
        m[4] = -m[4];
        m[5] = -m[5];
        m[8] = -m[8];
        m[9] = -m[9];
}
@


11.21
log
@change conf.h to a wrapped config.h
@
text
@@


11.20
log
@merge of ansi-6-0-branch into HEAD
@
text
@d57 5
a61 1
#include "conf.h"
@


11.19
log
@update copyright to include span through 2003
@
text
@d845 1
a845 1
	void anim_dir2mat(), anim_add_trans(), anim_view_rev();
@


11.18
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *      This software is Copyright (C) 1993 by the United States Army
@


11.18.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.18.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.18.2.1
log
@Initial ANSIfication
@
text
@d845 1
a845 1
	void anim_dir2mat(fastf_t *m, const fastf_t *d, const fastf_t *d2b), anim_add_trans(fastf_t *m, const fastf_t *post, const fastf_t *pre), anim_view_rev(fastf_t *m);
@


11.18.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.17
log
@Converted from K&R to ANSI C - RFH
@
text
@d845 1
a845 1
	void anim_dir2mat(fastf_t *m, const fastf_t *d, const fastf_t *d2b), anim_add_trans(fastf_t *m, const fastf_t *post, const fastf_t *pre), anim_view_rev(fastf_t *m);
@


11.16
log
@
Added declarations for anim_* routines to h/bn.h
XXX These should have had a bn_ prefix!
@
text
@d845 1
a845 1
	void anim_dir2mat(), anim_add_trans(), anim_view_rev();
@


11.15
log
@Eliminated some unused variables
@
text
@d91 1
a91 2
void anim_v_permute(m)
mat_t m;
d111 1
a111 2
void anim_v_unpermute(m)
mat_t m;
d125 1
a125 2
void anim_tran(m)
mat_t m;
d171 1
a171 3
int anim_mat2zyx(angle,viewrot)
mat_t viewrot;
vect_t angle;
d238 1
a238 3
int anim_mat2ypr(angle,viewrot)
mat_t viewrot;
vect_t angle;
d304 1
a304 3
int anim_mat2quat(quat,viewrot)
quat_t quat;
mat_t viewrot;
d367 1
a367 3
void anim_ypr2mat(m,a)
mat_t m;
vect_t a;
d406 1
a406 3
void anim_ypr2vmat(m,a)
mat_t m;
vect_t a;
d438 1
a438 3
void anim_y_p_r2mat(m,y,p,r) /*make object rotation matrix from radian ypr*/
mat_t m;
fastf_t y, p, r;
d466 1
a466 3
void anim_dy_p_r2mat(m,y,p,r) /*make object rotation matrix from ypr*/
mat_t m;
fastf_t y, p, r;
d497 1
a497 3
void anim_dy_p_r2vmat(m,yaw,pch,rll) /*make view rotation matrix from ypr*/
mat_t m;
fastf_t yaw, pch, rll;
d530 1
a530 3
void anim_x_y_z2mat(m, x, y, z)
mat_t m;
fastf_t x, y, z;
d558 1
a558 3
void anim_dx_y_z2mat(m, x, y, z)
mat_t m;
fastf_t x, y, z;
d590 1
a590 3
void anim_zyx2mat(m,a)
mat_t m;
vect_t a;
d624 1
a624 3
void anim_z_y_x2mat(m,x,y,z)
mat_t m;
fastf_t x, y, z;
d651 1
a651 3
void anim_dz_y_x2mat(m,x,y,z)
mat_t m;
fastf_t x, y, z;
d685 1
a685 3
void anim_quat2mat(m, q)
mat_t m;
quat_t q;
d688 1
d690 1
a690 1

d721 1
a721 3
void anim_dir2mat(m,d,d2)
mat_t m;
vect_t d, d2;
d724 3
d769 1
a769 3
void anim_dirn2mat(m,dx,dn)
mat_t m;
vect_t dx,dn;
d773 1
d775 1
d843 1
a843 4
int anim_steer_mat(mat,point,end)
mat_t  mat;
vect_t point;
int end;
d904 1
a904 3
void anim_add_trans(m,post,pre)
mat_t m; 
vect_t post, pre;
d914 1
a914 3
void anim_rotatez(a,d)
fastf_t a;
vect_t d;
d927 1
a927 4
void anim_mat_print(fp,m,s_colon)
FILE *fp;
mat_t m;
int s_colon;
d943 6
a948 6
void anim_mat_printf(fp,m,formstr,linestr,endstr)
FILE *fp;
mat_t m;
char *formstr;
char *linestr;
char *endstr;
d961 1
a961 2
void anim_view_rev(m) /* reverses view matrix, but keeps it 'right-side-up'*/
mat_t m;
@


11.14
log
@Removed "statement is unreachable" warning.
@
text
@a803 1
	int ret;
d879 1
a879 1
	vect_t dir, dir2;
@


11.13
log
@anim_mat_print() and anim_mat_printf() now use bu_flog().
@
text
@a891 1
			return(0);
d894 1
a894 1
			return(0); /* "don't print yet */
d896 1
a896 1
		break;
@


11.12
log
@Changed to use libbu
@
text
@d965 2
a966 1
void anim_mat_print(m,s_colon)
d970 4
a973 4
        bu_log("%.10g %.10g %.10g %.10g\n", m[0], m[1], m[2], m[3]);
        bu_log("%.10g %.10g %.10g %.10g\n", m[4], m[5], m[6], m[7]);
        bu_log("%.10g %.10g %.10g %.10g\n", m[8], m[9], m[10], m[11]);
        bu_log("%.10g %.10g %.10g %.10g", m[12], m[13], m[14], m[15]);
d975 2
a976 2
                bu_log(";");
        bu_log("\n");
d984 2
a985 1
void anim_mat_printf(m,formstr,linestr,endstr)
d993 4
a996 4
        bu_log(mystr, m[0], m[1], m[2], m[3], linestr);
        bu_log(mystr, m[4], m[5], m[6], m[7], linestr);
        bu_log(mystr, m[8], m[9], m[10], m[11], linestr);
        bu_log(mystr, m[12], m[13], m[14], m[15], endstr);
@


11.11
log
@added anim_steer_mat from anim_script.c
@
text
@d61 1
d63 1
d186 1
a186 1
                /*fprintf(stderr,"Warning: x arbitrarily set to 0.0; z set to %f.\n",angle[2]);*/
d255 1
a255 1
                /*fprintf(stderr,"Warning: roll arbitrarily set to 0.0; yaw set to %f radians.\n",angle[0]);*/
d809 1
a809 1
		fprintf(stderr,"anim_dirn2mat: Need non-zero vector");
d969 4
a972 4
        printf("%.10g %.10g %.10g %.10g\n", m[0], m[1], m[2], m[3]);
        printf("%.10g %.10g %.10g %.10g\n", m[4], m[5], m[6], m[7]);
        printf("%.10g %.10g %.10g %.10g\n", m[8], m[9], m[10], m[11]);
        printf("%.10g %.10g %.10g %.10g", m[12], m[13], m[14], m[15]);
d974 2
a975 2
                printf(";");
        printf("\n");
d991 4
a994 4
        printf(mystr, m[0], m[1], m[2], m[3], linestr);
        printf(mystr, m[4], m[5], m[6], m[7], linestr);
        printf(mystr, m[8], m[9], m[10], m[11], linestr);
        printf(mystr, m[12], m[13], m[14], m[15], endstr);
a1009 3



@


11.10
log
@added anim_mat_printf
@
text
@d46 2
d858 68
@


11.9
log
@output formatting
@
text
@d906 19
@


11.8
log
@removed warning messages
@
text
@d897 4
a900 4
        printf("%f %f %f %f\n", m[0], m[1], m[2], m[3]);
        printf("%f %f %f %f\n", m[4], m[5], m[6], m[7]);
        printf("%f %f %f %f\n", m[8], m[9], m[10], m[11]);
        printf("%f %f %f %f", m[12], m[13], m[14], m[15]);
@


11.7
log
@hack to quite the sun4's complaining about aggregate initialization
@
text
@d34 1
a34 1
 *	anim_ypr2mat()		create rotation matrix from angles, etc.
d44 2
a45 2
 *	anim_dir2mat()
 *	anim_dirn2mat()		
d182 1
a182 1
                fprintf(stderr,"Warning: x arbitrarily set to 0.0; z set to %f.\n",angle[2]);
d251 1
a251 1
                fprintf(stderr,"Warning: roll arbitrarily set to 0.0; yaw set to %f radians.\n",angle[0]);
@


11.6
log
@added anim_tran
@
text
@d128 21
d151 1
@


11.5
log
@clarifications
@
text
@d28 1
d119 16
@


11.4
log
@replaced anim_dirz2mat with more robust anim_dirn2mat
@
text
@d69 9
d80 5
a84 2
 * z-axis and the x-axis to the negative y-axis. This is used in some 
 * situations where the virtual camera is involved.
d101 5
@


11.3
log
@added anim_dirz2mat
@
text
@d44 1
d686 4
a689 3
 * point in the desired direction. A second direction vector, representing
 * the vehicle's previous direction, is consulted when the given direction
 * is vertical.
d731 8
a738 1
void anim_dirz2mat(m,dx,dz)
d740 1
a740 1
vect_t dx,dz;
d749 1
a749 1
		fprintf(stderr,"anim_dirz2mat: Need non-zero vector");
d759 1
a759 1
		VSET(temp, dz[0], dz[1], 0.0);
d763 1
a763 1
			VSET(temp, -sign, 0.0, 0.0);
d773 2
a774 2
		m[1] = temp[1]*sign;
		m[5] = temp[0]*sign;
d776 2
a777 2
		m[2] = temp[0];
		m[6] = temp[1];
@


11.2
log
@updated anim.c routine names
@
text
@d729 63
@


11.1
log
@Release_4.4
@
text
@d20 31
d68 1
a68 1
/* V_PERMUTE - Pre-multiply a rotation matrix by a matrix 
d73 1
a73 1
void v_permute(m)
d87 1
a87 1
/* UN_V_PERMUTE - Undo the mapping done by v_permute().
d89 1
a89 1
void un_v_permute(m)
d103 3
a105 22
/* TRANSPOSE - Tranpose a 4x4 matrix
 */
void transpose(m)
mat_t m;
{
	fastf_t store;

	store = m[1];
	m[1] = m[4];
	m[4] = store;

	store = m[2];
	m[2] = m[8];
	m[8] = store;

	store = m[3];
	m[3] = m[12];
	m[12] = store;

	store = m[6];
	m[6] = m[9];
	m[9] = store;
d107 1
a107 11
	store = m[7];
	m[7] = m[13];
	m[13] = store;

	store = m[11];
	m[11] = m[14];
	m[14] = store;

}

/* MAT2ZYX - Convert the rotational part of a 4x4 transformation matrix
d113 1
a113 1
int mat2zyx(angle,viewrot)
d175 1
a175 1
/* MAT2YPR - Convert the rotational part of a 4x4 transformation matrix
d182 1
a182 1
int mat2ypr(angle,viewrot)
d244 1
a244 1
/* MAT2QUAT -  This interprets the rotational part of a 4x4 transformation 
d250 1
a250 1
int mat2quat(quat,viewrot)
d307 3
d311 1
a311 1
/* YPR2MAT - Create a premultiplication rotation matrix to turn the front
d315 1
a315 1
void ypr2mat(m,a)
d346 1
a346 1
/* YPR2VMAT - Create a post-multiplication rotation matrix ,which could
d356 1
a356 1
void ypr2vmat(m,a)
d387 1
a387 1
/* Y_P_R2MAT - Make matrix to rotate an object to the given yaw,
d390 1
a390 1
void y_p_r2mat(m,y,p,r) /*make object rotation matrix from radian ypr*/
d417 1
a417 1
/* DY_P_R2MAT - Make matrix to rotate an object to the given yaw,
d420 1
a420 1
void dy_p_r2mat(m,y,p,r) /*make object rotation matrix from ypr*/
d449 1
a449 1
/* DY_P_R2VMAT - Make a view rotation matrix, given desired yaw, pitch
d453 1
a453 1
void dy_p_r2vmat(m,yaw,pch,rll) /*make view rotation matrix from ypr*/
d484 1
a484 1
/* X_Y_Z2MAT - Make a rotation matrix corresponding to a rotation of 
d488 1
a488 1
void x_y_z2mat(m, x, y, z)
d514 1
a514 1
/* DX_Y_Z2MAT - Make a rotation matrix corresponding to a rotation of 
d518 1
a518 1
void dx_y_z2mat(m, x, y, z)
d548 1
a548 1
/* ZYX2MAT - Make a rotation matrix corresponding to a rotation of 
d552 1
a552 1
void zyx2mat(m,a)
d584 1
a584 1
/* Z_Y_X2MAT - Make a rotation matrix corresponding to a rotation of 
d588 1
a588 1
void z_y_x2mat(m,x,y,z)
d613 1
a613 1
/* DZ_Y_X2MAT - Make a rotation matrix corresponding to a rotation of 
d617 1
a617 1
void dz_y_x2mat(m,x,y,z)
d648 3
a650 1
/* QUAT_MAT - Make 4x4 matrix from the given quaternion
d653 1
a653 1
void quat2mat(m, q)
d684 1
a684 1
/* DIR2MAT - make a matrix which turns a vehicle from the x-axis to 
d689 1
a689 1
void dir2mat(m,d,d2)
d729 6
a734 1
/* ADD_TRANS - Add pre- and post- translation to a rotation matrix.
d738 1
a738 1
void add_trans(m,post,pre)
d745 1
d748 1
a748 1
/* ROTATEZ - Rotate the vector "d" through "a" radians about the z-axis.
d750 1
a750 1
void rotatez(a,d)
d763 1
a763 1
/* AN_MAT_PRINT - print out 4X4 matrix, with optional colon
d765 1
a765 1
void an_mat_print(m,s_colon)
d778 1
a778 1
/* VIEW_REV - Reverse the direction of a view matrix, keeping it
d781 1
a781 1
void view_rev(m) /* reverses view matrix, but keeps it 'right-side-up'*/
@


1.9
log
@included conf.h
@
text
@@


1.8
log
@improved mat2ypr and mat2zyx to avoid ill-conditioning
@
text
@d22 1
@


1.7
log
@changed type double to fastf_t and so on
@
text
@d114 2
a115 2
        int i, return_value;
        fastf_t sinx, sinz, cosx, cosz;
d130 4
a133 4
        sinx = sin(angle[0]);
        sinz = sin(angle[2]);
        cosx = cos(angle[0]);
        cosz = cos(angle[2]);
d135 13
a147 10
        if ( (sinx*cosz) != 0.0 )
                angle[1]=atan2( (viewrot[4] - cosx*sinz)/(sinx*cosz), -viewrot[6]/sinx);
        else if ( (cosx*cosz) != 0.0 )
                angle[1]=atan2( (-viewrot[8] + sinx*sinz)/(cosx*cosz), viewrot[0]/cosz);
        else if ( (sinx*sinz) != 0.0 )
                angle[1]=atan2( (-viewrot[5] + cosx*cosz)/(sinx*sinz), -viewrot[1]/sinz);
        else if ( (cosx*sinz) != 0.0 )
                angle[1]=atan2( (viewrot[9] - sinx*cosz)/(cosx*sinz), viewrot[10]/cosx);
        else {
                /* unable to calculate y rotation */
d150 8
d159 1
d183 2
a184 2
        int i, return_value;
        fastf_t sin_y, sin_r, cos_y, cos_r;
d204 16
a219 1
        if ( (cos_y*sin_r) != 0.0 )
d221 1
a221 1
        else if ( (sin_y*cos_r) != 0.0)
d223 1
a223 1
        else if ( (sin_y*sin_r) != 0.0)
d225 1
a225 1
        else if ( (cos_y*cos_r) != 0.0)
d227 1
a227 4
        else {
                /* unable to calculate pitch*/
                return(ERROR2);
        }
@


1.6
log
@changed azimuth,elevation,twist to yaw,pitch,roll
@
text
@d42 1
a42 1
fastf_t *m;
d58 1
a58 1
fastf_t *m;
d74 1
a74 1
fastf_t *m;
d111 2
a112 2
fastf_t *viewrot;
fastf_t *angle;
d168 2
a169 2
fastf_t *viewrot;
fastf_t angle[3];
d224 2
a225 1
fastf_t *quat, *viewrot;
d286 2
a287 2
fastf_t m[11];
fastf_t a[3];
d327 2
a328 2
fastf_t m[11];
fastf_t a[3];
d360 3
a362 2
void y_p_r2mat(m,a,e,t) /*make object rotation matrix from radian ypr*/
double m[], a, e, t;
d364 6
a369 6
        double cos_y = cos(a);
        double sin_y = sin(a);
        double cos_p = cos(e);
        double sin_p = sin(e);
        double cos_r = cos(t);
        double sin_r = sin(t);
d390 3
a392 2
void dy_p_r2mat(m,a,e,t) /*make object rotation matrix from ypr*/
double m[], a, e, t;
d394 3
a396 3
        double radian_yaw = a*(M_PI*0.0055555555556);
        double radian_pitch = e*(M_PI*0.0055555555556);
        double radian_roll = t*(M_PI*0.0055555555556);
d398 6
a403 6
        double cos_y = cos(radian_yaw);
        double sin_y = sin(radian_yaw);
        double cos_p = cos(radian_pitch);
        double sin_p = sin(radian_pitch);
        double cos_r = cos(radian_roll);
        double sin_r = sin(radian_roll);
d423 3
a425 2
void dy_p_r2vmat(m,az,el,tw) /*make view rotation matrix from ypr*/
float m[], az, el, tw;
d428 3
a430 3
	float raz = az*(M_PI*0.0055555555556);
	float rel = el*(M_PI*0.0055555555556);
	float rtw = tw*(M_PI*0.0055555555556);
d432 6
a437 6
	float cos_y = cos(raz);
	float sin_y = sin(raz);
	float cos_p = cos(rel);
	float sin_p = sin(rel);
	float cos_r = cos(rtw);
	float sin_r = sin(rtw);
d459 2
a460 1
double m[], x, y, z;
d462 6
a467 6
        double cosx = cos(x);
        double sinx = sin(x);
        double cosy = cos(y);
        double siny = sin(y);
        double cosz = cos(z);
        double sinz = sin(z);
d489 2
a490 1
double m[], x, y, z;
d492 1
a492 1
	double cosx,cosy,cosz,sinx,siny,sinz;
d523 2
a524 1
fastf_t *m, *a;
d559 2
a560 1
double m[], x, y, z;
d562 6
a567 6
        double cosx = cos(x);
        double sinx = sin(x);
        double cosy = cos(y);
        double siny = sin(y);
        double cosz = cos(z);
        double sinz = sin(z);
d588 2
a589 1
double m[], x, y, z;
d591 1
a591 1
	double cosx,cosy,cosz,sinx,siny,sinz;
d622 2
a623 1
fastf_t *m, *q;
d658 2
a659 1
double m[], d[], d2[];
d661 1
a661 1
        double hypotenuse, sign;
d698 2
d702 2
a703 1
double m[], post[], pre[];
d713 2
a714 1
double a, d[];
d716 3
a718 3
        double temp[3];
        double cos_y = cos(a);
        double sin_y = sin(a);
d728 1
a728 1
double m[];
d744 1
a744 1
double m[];
@


1.5
log
@includes reupdated
@
text
@d160 4
a163 4
/* MAT2AET - Convert the rotational part of a 4x4 transformation matrix
 * to az-el-tw form, that is to say, +twist degrees about the x-axis, 
 * -elevation degrees about the y-axis, and +azimuth degrees about the
 * z-axis. The angles are stored in radians as a vector in the order a,e,t.
d167 1
a167 1
int mat2aet(angle,viewrot)
d172 1
a172 1
        fastf_t sina, sint, cosa, cost;
d179 1
a179 1
                fprintf(stderr,"Warning: twist arbitrarily set to 0.0; azimuth set to %f radians.\n",angle[0]);
d187 4
a190 4
        sina = sin(angle[0]);
        sint = sin(angle[2]);
        cosa = cos(angle[0]);
        cost = cos(angle[2]);
d192 8
a199 8
        if ( (cosa*sint) != 0.0 )
                angle[1] = atan2( -(viewrot[1]+sina*cost)/(cosa*sint),viewrot[9]/sint);
        else if ( (sina*cost) != 0.0)
                angle[1] = atan2( -(viewrot[6]+cosa*sint)/(sina*cost),viewrot[10]/cost);
        else if ( (sina*sint) != 0.0)
                angle[1] = atan2( -(viewrot[5]-cosa*cost)/(sina*sint),viewrot[4]/sina);
        else if ( (cosa*cost) != 0.0)
                angle[1] = atan2( -(viewrot[2]-sina*sint)/(cosa*cost),viewrot[0]/cosa);
d201 1
a201 1
                /* unable to calculate elevation*/
d280 2
a281 2
/* AET2MAT - Create a premultiplication rotation matrix to turn the front
 * of an object (its x-axis) to the given azimuth, elevation, and twist, 
d284 1
a284 1
void aet2mat(m,a)
d288 1
a288 1
	fastf_t cosa,cose,cost,sina,sine,sint;
d290 6
a295 6
	cosa = cos(a[0]);	
	cose = cos(a[1]);	
	cost = cos(a[2]);	
	sina = sin(a[0]);	
	sine = sin(a[1]);	
	sint = sin(a[2]);	
d297 3
a299 3
        m[0] =	 cosa*cose;
	m[1] =	 -cosa*sine*sint-sina*cost;
        m[2] =	 -cosa*sine*cost+sina*sint;
d301 3
a303 3
        m[4] = 	sina*cose;
        m[5] =	-sina*sine*sint+cosa*cost;
        m[6] =	-sina*sine*cost-cosa*sint;
d305 3
a307 3
        m[8]= 	sine;
        m[9] = 	cose*sint;
        m[10] = cose*cost;
d315 3
a317 3
/* AET2VMAT - Create a post-multiplication rotation matrix ,which could
 * be used to move the virtual camera to the given azimuth, elevation, 
 * and twist,  which are stored in radians in the given vector a. The 
d319 1
a319 1
 * 	aet2vmat(matrix,a);
d321 1
a321 1
 *	aet2mat(matrix,a);
d325 1
a325 1
void aet2vmat(m,a)
d329 1
a329 1
	fastf_t cosa,cose,cost,sina,sine,sint;
d331 6
a336 6
	cosa = cos(a[0]);	
	cose = cos(a[1]);	
	cost = cos(a[2]);	
	sina = sin(a[0]);	
	sine = sin(a[1]);	
	sint = sin(a[2]);	
d338 3
a340 3
	m[0] =    -cosa*sine*sint-sina*cost;
	m[1] =    -sina*sine*sint+cosa*cost;
	m[2] =     cose*sint;
d342 3
a344 3
	m[4] =    -cosa*sine*cost+sina*sint;
	m[5] =    -sina*sine*cost-cosa*sint;
	m[6] =     cose*cost;
d346 3
a348 3
	m[8] =     cosa*cose;
	m[9] =     sina*cose;
	m[10] =    sine;
d356 2
a357 2
/* A_E_T2MAT - Make matrix to rotate an object to the given azimuth,
 * elevation, and twist. (Specified in radians.)
d359 1
a359 1
void a_e_t2mat(m,a,e,t) /*make object rotation matrix from radian aet*/
d362 6
a367 6
        double cosa = cos(a);
        double sina = sin(a);
        double cose = cos(e);
        double sine = sin(e);
        double cost = cos(t);
        double sint = sin(t);
d369 9
a377 9
        m[0] = cosa*cose;
        m[1] = -cosa*sine*sint-sina*cost;
        m[2] = -cosa*sine*cost+sina*sint;
        m[4] = sina*cose;
        m[5] = -sina*sine*sint+cosa*cost;
        m[6] = -sina*sine*cost-cosa*sint;
        m[8]= sine;
        m[9] = cose*sint;
        m[10] = cose*cost;
d385 2
a386 2
/* DA_E_T2MAT - Make matrix to rotate an object to the given azimuth,
 * elevation, and twist. (Specified in degrees.)
d388 1
a388 1
void da_e_t2mat(m,a,e,t) /*make object rotation matrix from aet*/
d391 3
a393 3
        double radian_azimuth = a*(M_PI*0.0055555555556);
        double radian_elevation = e*(M_PI*0.0055555555556);
        double radian_twist = t*(M_PI*0.0055555555556);
d395 6
a400 6
        double cosa = cos(radian_azimuth);
        double sina = sin(radian_azimuth);
        double cose = cos(radian_elevation);
        double sine = sin(radian_elevation);
        double cost = cos(radian_twist);
        double sint = sin(radian_twist);
d402 9
a410 9
        m[0] = cosa*cose;
        m[1] = -cosa*sine*sint-sina*cost;
        m[2] = -cosa*sine*cost+sina*sint;
        m[4] = sina*cose;
        m[5] = -sina*sine*sint+cosa*cost;
        m[6] = -sina*sine*cost-cosa*sint;
        m[8]= sine;
        m[9] = cose*sint;
        m[10] = cose*cost;
d416 2
a417 2
/* DA_E_T2VMAT - Make a view rotation matrix, given desired azimuth, elevation
 * and twist. (Note that the matrix is a permutation of the object rotation
d420 1
a420 1
void da_e_t2vmat(m,az,el,tw) /*make view rotation matrix from aet*/
d428 6
a433 6
	float cosa = cos(raz);
	float sina = sin(raz);
	float cose = cos(rel);
	float sine = sin(rel);
	float cost = cos(rtw);
	float sint = sin(rtw);
d435 9
a443 9
	m[0] = -cosa*sine*sint-sina*cost;
	m[1] = -sina*sine*sint+cosa*cost;
	m[2] = cose*sint;
	m[4] = -cosa*sine*cost+sina*sint;
	m[5] = -sina*sine*cost-cosa*sint;
	m[6] = cose*cost;
	m[8] = cosa*cose;
	m[9] = sina*cose;
	m[10]= sine;
d654 1
a654 1
                                        * determine twist */
d669 1
a669 1
        else { /* normal - no twist*/
d702 4
a705 4
        double cosa = cos(a);
        double sina = sin(a);
        temp[0] = d[0]*cosa - d[1]*sina;
        temp[1] = d[0]*sina + d[1]*cosa;
@


1.4
log
@fixed incorrect array numbers in mat2aet()
@
text
@d24 3
a26 3
#include <brlcad/machine.h>
#include <brlcad/vmath.h>
#include "h/anim.h"
@


1.3
log
@standardized routine nomenclature, added header
@
text
@d24 3
a26 3
#include "machine.h"
#include "vmath.h"
#include "anim.h"
d197 1
a197 1
                angle[1] = atan2( -(viewrot[1]-cosa*cost)/(sina*sint),viewrot[4]/sina);
d199 1
a199 1
                angle[1] = atan2( -(viewrot[1]-sina*sint)/(cosa*cost),viewrot[0]/cosa);
d450 1
a450 1
/* XYZ2MAT - Make a rotation matrix corresponding to a rotation of 
@


1.2
log
@added do_aet, do_xyz, do_quat from keyread and otherwise cleaned up
@
text
@d1 21
a21 1
/* ANIM.C - Commonly used routines in animation programs by Carl Nuzman */
d32 8
a39 27
/* DO_ZYX() - Converts a view-rotation matrix to a z rotation,
 * 	a y rotation, and an x rotation. 
 * 	A matrix which rotates the view Z degrees about the z-axis, 
 * then Y degrees about the y-axis, and finally X degrees about the 
 * x-axis should have the following form:
 * 
 * element 0: 	 cosY*cosZ
 * element 1:	-cosY*sinZ
 * element 2:	 sinY
 * element 3:	 0
 * element 4:	 cosX*sinZ + sinX*sinY*cosZ
 * element 5:	 cosX*cosZ - sinX*sinY*sinZ
 * element 6:	-sinX*cosY
 * element 7:	 0
 * element 8:	 sinX*sinZ - cosX*sinY*cosZ
 * element 9:	 sinX*cosZ + cosX*sinY*sinZ
 * element 10:	 cosX*cosY
 * element 11:	 0
 * element 12:	 0
 * element 13:	 0
 * element 14:	 0
 * element 15:	 1.0
 * 
 * This function extracts the angles of rotation from the given matrix,
 * using the atan2() function.
 *	A return value of 0 is normal. A value of 1 means that arbitrary 
 * assumptions were made, and a value of 2 is the error signal.
d41 5
d47 7
a53 2
#define DEGREES		0
#define RADIANS		1
d55 4
a58 3
int do_zyx(viewrot,units_flag)
fastf_t *viewrot;
int units_flag;
d60 2
a61 3
	int i, return_value;
	fastf_t angle[3], sinx, sinz, cosx, cosz;
	static fastf_t previous[3];
d63 5
a67 5
	if ((viewrot[1]==0.0) && (viewrot[0]==0.0)){
		return_value = 1; /* indicates arbitrary assumptions */
		angle[X] = 0.0;
		angle[Z] = atan2(viewrot[4],viewrot[5]);
		fprintf(stderr,"Warning: x arbitrarily set to 0.0; z set to %f.\n",angle[Z]);
d69 1
a69 5
	else {
		return_value = 0; /* normal */
		angle[Z] = atan2(-viewrot[1],viewrot[0]);
		angle[X] = atan2(-viewrot[6],viewrot[10]);
	}
d71 6
a76 4
	sinx = sin(angle[X]);
	sinz = sin(angle[Z]);
	cosx = cos(angle[X]);
	cosz = cos(angle[Z]);
d78 3
a80 12
	if ( (sinx*cosz) != 0.0 )
		angle[Y]=atan2( (viewrot[4] - cosx*sinz)/(sinx*cosz), -viewrot[6]/sinx);
	else if ( (cosx*cosz) != 0.0 )
		angle[Y]=atan2( (-viewrot[8] + sinx*sinz)/(cosx*cosz), viewrot[0]/cosz);
	else if ( (sinx*sinz) != 0.0 )
		angle[Y]=atan2( (-viewrot[5] + cosx*cosz)/(sinx*sinz), -viewrot[1]/sinz);
	else if ( (cosx*sinz) != 0.0 )
		angle[Y]=atan2( (viewrot[9] - sinx*cosz)/(cosx*sinz), viewrot[10]/cosx);
	else {
		/* unable to calculate y rotation */
		return(2);
	}
d82 3
a84 8
	/* assume the smallest possible arc-length from frame to frame */
	for (i=0; i<3; i++) {
		while ((angle[i] - previous[i]) > M_PI)
			angle[i] -= (2.0*M_PI);
		while ((previous[i] - angle[i]) > M_PI)
			angle[i] += (2.0*M_PI);
		previous[i] = angle[i];
	}
d86 3
a88 6
	/* convert to degrees if necessary */
	if (units_flag==DEGREES)  {
		angle[Z] *= (180.0/M_PI);
		angle[Y] *= (180.0/M_PI);
		angle[X] *= (180.0/M_PI);
	}
d90 3
a92 3
	/* print results */
	printf("%f %f %f\n", angle[X], angle[Y], angle[Z]);
	return(return_value);
d94 8
d104 5
a108 26
/* DO_AET() - Interprets a view-rotation matrix in terms of an azimuth, 
 *	an elevation, and a twist. 
 * A matrix which rotates the view to a given azimuth elevation and twist
 * has the following form:
 *        
 * element	0:	-cosa*sine*sint-sina*cost
 * element	1:	-sina*sine*sint+cosa*cost
 * element	2:	 cose*sint
 * element	3:	 0
 * element	4:	-cosa*sine*cost+sina*sint
 * element	5:	-sina*sine*cost-cosa*sint
 * element	6:	 cose*cost
 * element	7:	 0
 * element	8:	 cosa*cose
 * element	9:	 sina*cose
 * element	10:	 sine
 * element	11:	 0
 * element	12:	 0
 * element	13:	 0
 * element	14:	 0
 * element	15:	 1.0
 * 
 * This function extracts the azimuth, elevation and twist from the given
 * matrix, using the atan2() function.
 *	A return value of 0 is normal. A value of 1 means that arbitrary 
 * assumptions were made, and a value of 2 is the error signal.
d110 7
d118 11
a128 2
#define DEGREES		0
#define RADIANS		1
d130 4
a133 3
#define A		0
#define E		1
#define T		2
d135 33
a167 1
int do_aet(viewrot, units_flag)
d169 1
a169 1
int	units_flag;
d171 3
a173 3
	int i, return_value;
	fastf_t aet[3], sina, sint, cosa, cost;
	static fastf_t prev_aet[3];
d175 11
a185 11
	if ((viewrot[2]==0.0) && (viewrot[6]==0.0)){
		return_value = 1; /* indicates arbitrary assumptions */
		aet[T] = 0.0;
		aet[A] = atan2(-viewrot[0],viewrot[1]);
		fprintf(stderr,"Warning: twist arbitrarily set to 0.0; azimuth set to %f radians.\n",aet[A]);
	}
	else {
		return_value = 0; /* normal */
		aet[A] = atan2(viewrot[9],viewrot[8]);
		aet[T] = atan2(viewrot[2],viewrot[6]);
	}
d187 4
a190 4
	sina = sin(aet[A]);
	sint = sin(aet[T]);
	cosa = cos(aet[A]);
	cost = cos(aet[T]);
d192 12
a203 12
	if ( (cosa*sint) != 0.0 )
		aet[E] = atan2( -(viewrot[0]+sina*cost)/(cosa*sint),viewrot[2]/sint);
	else if ( (sina*cost) != 0.0)
		aet[E] = atan2( -(viewrot[5]+cosa*sint)/(sina*cost),viewrot[6]/cost);
	else if ( (sina*sint) != 0.0)
		aet[E] = atan2( -(viewrot[0]-cosa*cost)/(sina*sint),viewrot[9]/sina);
	else if ( (cosa*cost) != 0.0)
		aet[E] = atan2( -(viewrot[0]-sina*sint)/(cosa*cost),viewrot[8]/cosa);
	else {
		/* unable to calculate elevation*/
		return(2);
	}
d205 8
a212 8
	/* assume the smallest possible arc-length from frame to frame */
	for (i=0; i<3; i++) {
		while ((aet[i] - prev_aet[i]) > M_PI)
			aet[i] -= (2.0*M_PI);
		while ((prev_aet[i] - aet[i]) > M_PI)
			aet[i] += (2.0*M_PI);
		prev_aet[i] = aet[i];
	}
a213 12
	/* convert to degrees if necessary */
	if (units_flag==DEGREES) {
		aet[A] *= (180.0/M_PI);
		aet[E] *= (180.0/M_PI);
		aet[T] *= (180.0/M_PI);
	}

	/* print results */
	/* negative signs are introduced because ascript interprets azimuth */
	/* and elevation as looking TOWARD that azimuth and elevation, while*/
	/* mged interprets it as looking FROM that azimuth and elevation*/
	printf("%f %f %f\n", -aet[A], -aet[E], aet[T]);
a214 1

d217 3
a219 1
/* DO_QUAT -  This interprets a view rotation matrix in terms of quaternions.
d223 2
a224 2
int do_quat(viewrot)
fastf_t *viewrot;
d227 1
a227 1
	fastf_t quat[4], qdiff[4], square, mag1, mag2;
d233 3
a235 3
		quat[X] = 0.25 * (viewrot[6] - viewrot[9])/ quat[W];
		quat[Y] = 0.25 * (viewrot[8] - viewrot[2])/ quat[W];
		quat[Z] = 0.25 * (viewrot[1] - viewrot[4])/ quat[W];
d242 2
a243 2
			quat[Y] = 0.5 * viewrot[1] / quat[X];
			quat[Z] = 0.5 * viewrot[2] / quat[X];
d250 1
a250 1
				quat[Z] = 0.5 * viewrot[6]/ quat[Y];
d276 1
a276 3
	/* print results */
	printf("%f %f %f %f\n",quat[X], quat[Y], quat[Z], quat[W]);
	return(1.0);
d280 106
a385 1
/* AET2MAT - Make matrix to rotate an object to the given azimuth,
d388 1
a388 1
void aet2mat(m,a,e,t) /*make object rotation matrix from aet*/
d415 4
a418 2
/* RAD_AET2MAT - Make matrix to rotate an object to the given azimuth,
 * elevation, and twist. (Specified in radians.)
d420 2
a421 2
void rad_aet2mat(m,a,e,t) /*make object rotation matrix from radian aet*/
double m[], a, e, t;
a422 6
        double cosa = cos(a);
        double sina = sin(a);
        double cose = cos(e);
        double sine = sin(e);
        double cost = cos(t);
        double sint = sin(t);
d424 49
a472 9
        m[0] = cosa*cose;
        m[1] = -cosa*sine*sint-sina*cost;
        m[2] = -cosa*sine*cost+sina*sint;
        m[4] = sina*cose;
        m[5] = -sina*sine*sint+cosa*cost;
        m[6] = -sina*sine*cost-cosa*sint;
        m[8]= sine;
        m[9] = cose*sint;
        m[10] = cose*cost;
d479 1
a479 1
/* XYZ_MAT - Make a rotation matrix corresponding to a rotation of 
d483 1
a483 1
void xyz_mat(m, x, y, z)
d508 2
a509 2
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0;
        m[15]=1;
d512 3
a514 3
/* RAD_XYZ_MAT - Make a rotation matrix corresponding to a rotation of 
 * "x" radians about the x-axis, "y" radians about the y-axis, and
 * then "z" radians about the z-axis.
d516 36
a551 1
void rad_xyz_mat(m, x, y, z)
d561 11
a571 11
        m[0] = cosz*cosy;
        m[1] = cosz*siny*sinx-sinz*cosx;
        m[2] = cosz*siny*cosx+sinz*sinx;
        m[4] = sinz*cosy;
        m[5] = sinz*siny*sinx+cosz*cosx;
        m[6] = sinz*siny*cosx-cosz*sinx;
        m[8] = -siny;
        m[9] = cosy*sinx;
        m[10] = cosy*cosx;
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0;
        m[15]=1;
d574 2
a575 1
/* ZYX_MAT - Make a rotation matrix corresponding to a rotation of 
d579 1
a579 1
void zyx_mat(m,x,y,z)
d608 2
a609 3
/* RAD_ZYX_MAT - Make a rotation matrix corresponding to a rotation of 
 * "z" radians about the z-axis, "y" radians about the y-axis, and
 * then "x" radians about the x-axis.
d611 3
a613 2
void rad_zyx_mat(m,x,y,z)
double m[], x, y, z;
d615 1
a615 6
        double cosx = cos(x);
        double sinx = sin(x);
        double cosy = cos(y);
        double siny = sin(y);
        double cosz = cos(z);
        double sinz = sin(z);
a616 12
	m[0] =  cosy*cosz;
	m[1] = -cosy*sinz;
	m[2] =  siny;
	m[4] =  cosx*sinz + sinx*siny*cosz;
	m[5] =  cosx*cosz - sinx*siny*sinz;
	m[6] = -sinx*cosy;
	m[8] =  sinx*sinz - cosx*siny*cosz;
	m[9] =  sinx*cosz + cosx*siny*sinz;
	m[10]=  cosx*cosy;
        m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0;
        m[15]=1;
}
d618 1
a618 7
/* AET2MAT_V - Make a view rotation matrix, given desired azimuth, elevation
 * and twist. (Note that the matrix is a permutation of the object rotation
 * matrix).
 */
void aet2mat_v(m,az,el,tw) /*make view rotation matrix from aet*/
float m[], az, el, tw;
{
d620 1
a620 23
	float raz = az*(M_PI*0.0055555555556);
	float rel = el*(M_PI*0.0055555555556);
	float rtw = tw*(M_PI*0.0055555555556);
	
	float cosa = cos(raz);
	float sina = sin(raz);
	float cose = cos(rel);
	float sine = sin(rel);
	float cost = cos(rtw);
	float sint = sin(rtw);
	
	m[0] = -cosa*sine*sint-sina*cost;
	m[1] = -sina*sine*sint+cosa*cost;
	m[2] = cose*sint;
	m[4] = -cosa*sine*cost+sina*sint;
	m[5] = -sina*sine*cost-cosa*sint;
	m[6] = cose*cost;
	m[8] = cosa*cose;
	m[9] = sina*cose;
	m[10]= sine;
	m[3]=m[7]=m[11]=0;
	m[12]=m[13]=m[14]=0;
	m[15]=1;
d622 16
d639 2
@


1.1
log
@Initial revision
@
text
@a0 20
/*
 *			A N I M . C
 *
 *  Author -
 *	Carl J. Nuzman
 *  
  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1993 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 */

a1 1

d4 2
a5 2
#include <brlcad/machine.h>
#include <brlcad/vmath.h>
d8 39
a46 2
void rotmat_inv(m,a) /*inverts 3x3 part of 4x4 matrix*/
double m[], a[];
d48 54
a101 14
        float det, invdet;
        det = a[0]*a[5]*a[10] - a[0]*a[6]*a[9] + a[1]*a[6]*a[8] - a[1]*a[4]*a[10] + a[2]*a[4]*a[9] - a[2]*a[5]*a[8];
	invdet = 1/det;
	m[0] = (a[5]*a[10] - a[6]*a[9])*invdet;
	m[1] = (a[2]*a[9] - a[1]*a[10])*invdet;
	m[2] = (a[1]*a[6] - a[2]*a[5])*invdet;
	m[4] = (a[6]*a[8] - a[4]*a[10])*invdet;
	m[5] = (a[0]*a[10] - a[2]*a[8])*invdet;
	m[6] = (a[2]*a[4] - a[0]*a[6])*invdet;
	m[8] = (a[4]*a[9] - a[5]*a[8])*invdet;
	m[9] = (a[1]*a[8] - a[0]*a[9])*invdet;
	m[10] = (a[0]*a[5] - a[1]*a[4])*invdet;
	m[3]=m[7]=m[11]=m[12]=m[13]=m[14]=0.0;
	m[15]=1.0;
d104 38
a141 2
void rotmat3_inv(m,a) /*inverts 3x3 matrix*/
fastf_t m[], a[];
d143 57
a199 12
        float det, invdet;
        det = a[0]*a[4]*a[8] - a[0]*a[5]*a[7] + a[1]*a[5]*a[6] - a[1]*a[3]*a[8] + a[2]*a[3]*a[7] - a[2]*a[4]*a[6];
	invdet = 1/det;
	m[0] = (a[4]*a[8] - a[5]*a[7])*invdet;
	m[1] = (a[2]*a[7] - a[1]*a[8])*invdet;
	m[2] = (a[1]*a[5] - a[2]*a[4])*invdet;
	m[3] = (a[5]*a[6] - a[3]*a[8])*invdet;
	m[4] = (a[0]*a[8] - a[2]*a[6])*invdet;
	m[5] = (a[2]*a[3] - a[0]*a[5])*invdet;
	m[6] = (a[3]*a[7] - a[4]*a[6])*invdet;
	m[7] = (a[1]*a[6] - a[0]*a[7])*invdet;
	m[8] = (a[0]*a[4] - a[1]*a[3])*invdet;
d202 66
d271 3
a273 3
        double radian_azimuth = a*DTOR;
        double radian_elevation = e*DTOR;
        double radian_twist = t*DTOR;
d295 3
d323 5
a327 1
void xyz_mat(m, x, y, z)/* rotate x then y then z */
d332 3
a334 3
	x *= DTOR;
	y *= DTOR;
	z *= DTOR;
d355 6
a360 1
void rad_xyz_mat(m, x, y, z)/* rotate x then y then z */
d383 5
a387 1
void zyx_mat(m,x,y,z)/*rotate z y x */
d392 3
a394 3
	x *= DTOR;
	y *= DTOR;
	z *= DTOR;
d416 5
a420 1
void rad_zyx_mat(m,x,y,z)/*rotate z y x */
d443 4
d451 3
a453 3
	float raz = az*DTOR;
	float rel = el*DTOR;
	float rtw = tw*DTOR;
d477 7
a483 4

/*****not for now
int steer_mat(mat,point)
double mat[],point[];
a484 37
        void dir2mat(), add_trans(), rotatez(), view_rev();
        static double p1[3], p2[3], p3[3];
        double dir[3], dir2[3], temp[3];

        VMOVE(p1,p2);
        VMOVE(p2,p3);
        VMOVE(p3,point);
        if (frame == 0){ /* first frame*//*
                VSUBUNIT(dir,p3,p2);
                VMOVE(dir2,dir);
        }
        else if (last_steer){ /*last frame*//*
                VSUBUNIT(dir,p2,p1);
                VMOVE(dir2,dir);
        }
        else if (frame > 0){ /*normal*//*
                VSUBUNIT(dir,p3,p1);
                VSUBUNIT(dir2,p2,p1);/*needed for vertical case*//*
        }
        else return(0);

        if (angle){ /* front of object at angle from x-axis*//*
                rotatez(-angle,dir);
                rotatez(-angle,dir2);
        }
        dir2mat(mat,dir,dir2);
        add_trans(mat,p2,rcentroid);
        if (view){
                view_rev(mat);/*because aet is opposite for the view*//*
        }
        return(1);
}
*****/

void dir2mat(m,d,d2) /*make matrix which turns vehicle from x-axis*/
double m[], d[], d2[]; /* to desired direction*/
{
d521 4
a524 2
void add_trans(m,post,pre) /* add pre and post translation*/
double m[], post[], pre[];  /* to rotation matrix */
d531 3
a533 1
void rotatez(a,d) /*rotate given vector a radians about zaxis*/
d545 2
d560 3
a562 1

d575 1
a575 7
mat_x_mat(o,a,b)
mat_t o,a,b;
{
/*
	(o)[ ] = (a)[ ]*(b)[ ] + (a)[ ]*(b)[ ] + (a)[ ]*(b)[ ] + (a)[ ]*(b)[ ];
*/
}
@
