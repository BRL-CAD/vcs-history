head	11.13;
access;
symbols
	ansi-20040405-merged:11.9.2.2
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.10.2
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.4.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.10
	phong-branch:11.9.0.8
	photonmap-branch:11.9.0.6
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.6
	offsite-5-3-pre:11.7
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.18.06.22;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.06;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.08.20.17.07.36;	author jra;	state Exp;
branches
	11.9.2.1
	11.9.4.1
	11.9.10.1;
next	11.8;

11.8
date	2002.08.15.20.54.48;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.07.05.47.28;	author cjohnson;	state Exp;
branches;
next	11.6;

11.6
date	2000.01.07.20.36.34;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.02.10.21.03.08;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	97.02.10.20.57.01;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.10.02.23.20.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.02.18.16.48;	author cjohnson;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.21;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.12.27.18.18.28;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.18.44.52;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.02.07.20.02.28;	author cjohnson;	state Exp;
branches;
next	10.2;

10.2
date	94.02.07.17.54.36;	author cjohnson;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.37;	author mike;	state Rel4_0;
branches;
next	1.4;

1.4
date	91.07.25.01.26.10;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	91.06.22.05.43.33;	author cjohnson;	state Exp;
branches;
next	1.2;

1.2
date	91.06.22.02.23.36;	author cjohnson;	state Exp;
branches;
next	1.1;

1.1
date	90.04.20.02.05.36;	author cjohnson;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.01.09;	author morrison;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.17.21.16.47;	author morrison;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.11.23.41.43;	author morrison;	state Exp;
branches;
next	;

11.9.10.1
date	2004.02.12.18.39.33;	author erikg;	state Exp;
branches;
next	11.9.10.2;

11.9.10.2
date	2004.03.15.14.06.16;	author erikg;	state Exp;
branches;
next	;


desc
@Random number functions, get long, get double, get gauss
@


11.13
log
@moved to src/
@
text
@/*
 *				M S R . C
 *
 * Minimal Standard RANdom number generator
 *
 * From:
 *	Stephen K. Park and Keith W. Miller
 *	"Random number generators: good ones are hard to find"
 *	CACM vol 31 no 10, Oct 88
 *
 *  Author -
 *	Christopher T. Johnson - 90/04/20
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/msr.c,v 11.12 2004/05/10 15:30:43 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"

/*
 * Note: BN_MSR_MAXTBL must be an even number.
 */
#define	BN_MSR_MAXTBL	4096	/* Size of random number tables. */


/*	bn_unif_init	Initialize a random number structure.
 *
 * Entry:
 *	setseed	seed to use
 *	method  method to use to generate numbers;
 *
 * Exit:
 *	returns	a pointer to a bn_unif structure.
 *	returns 0 on error.
 *
 * Uses:
 *	None.
 *
 * Calls:
 *	bu_malloc
 *
 * Method:
 *	malloc up a structure with pointers to the numbers
 *	get space for the integer table.
 *	get space for the floating table.
 *	set pointer counters
 *	set seed if one was given and setseed != 1
 *
 */
#define	A	16807
#define M	2147483647
#define DM	2147483647.0
#define Q	127773		/* Q = M / A */
#define R	2836		/* R = M % A */
struct bn_unif *
bn_unif_init(long int setseed, int method)
{
	struct bn_unif *p;
	p = (struct bn_unif *) bu_malloc(sizeof(struct bn_unif),"bn_unif");
	p->msr_longs = (long *) bu_malloc(BN_MSR_MAXTBL*sizeof(long), "msr long table");
	p->msr_doubles=(double *) bu_malloc(BN_MSR_MAXTBL*sizeof(double),"msr double table");
	p->msr_seed = 1;
	p->msr_long_ptr = 0;
	p->msr_double_ptr = 0;

	if (setseed&0x7fffffff) p->msr_seed=setseed&0x7fffffff;
	p->magic = BN_UNIF_MAGIC;
	return(p);
}

/*	bn_unif_long_fill	fill a random number table.
 *
 * Use the msrad algorithm to fill a random number table
 * with values from 1 to 2^31-1.  These numbers can (and are) extracted from
 * the random number table via high speed macros and bn_unif_long_fill called
 * when the table is exauseted.
 *
 * Entry:
 *	p	pointer to a bn_unif structure.
 *
 * Exit:
 *	if (!p) returns 1 else returns a value between 1 and 2^31-1
 *
 * Calls:
 *	None.  msran is inlined for speed reasons.
 *
 * Uses:
 *	None.
 *
 * Method:
 *	if (!p) return(1);
 *	if p->msr_longs != NULL 
 *		msr_longs is reloaded with random numbers;
 *		msr_long_ptr is set to BN_MSR_MAXTBL
 *	endif
 *	msr_seed is updated.
 */
long
bn_unif_long_fill(struct bn_unif *p)
{
	register long test,work_seed;
	register int i;

	/*
	 * Gauss and uniform structures have the same format for the
	 * first part (gauss is an extention of uniform) so that a gauss
	 * structure can be passed to a uniform routine.  This means 
	 * that we only maintain one structure for gaussian distributions
	 * rather than two.  It also means that the user can pull 
	 * uniform numbers from a guass structure when the user wants.
	 */
	if (!p || (p->magic != BN_UNIF_MAGIC &&
	    p->magic != BN_GAUSS_MAGIC)) {
		BN_CK_UNIF(p);
	}

	work_seed = p->msr_seed;

	if ( p->msr_longs) {
		for (i=0; i < BN_MSR_MAXTBL; i++) {
			test = A*(work_seed % Q) - R*(work_seed / Q);
			p->msr_longs[i] = work_seed = (test < 0) ?
			     test+M : test;
		}
		p->msr_long_ptr = BN_MSR_MAXTBL;
	}
	test = A*(work_seed % Q) - R*(work_seed / Q);
	p->msr_seed =  (test < 0) ? test+M : test;
	return(p->msr_seed);
}

/*	bn_unif_double_fill	fill a random number table.
 *
 * Use the msrad algorithm to fill a random number table
 * with values from -0.5 to 0.5.  These numbers can (and are) extracted from
 * the random number table via high speed macros and bn_unif_double_fill
 * called when the table is exauseted.
 *
 * Entry:
 *	p	pointer to a bn_unif structure.
 *
 * Exit:
 *	if (!p) returns 0.0 else returns a value between -0.5 and 0.5
 *
 * Calls:
 *	None.  msran is inlined for speed reasons.
 *
 * Uses:
 *	None.
 *
 * Method:
 *	if (!p) return (0.0)
 *	if p->msr_longs != NULL 
 *		msr_longs is reloaded with random numbers;
 *		msr_long_ptr is set to BN_MSR_MAXTBL
 *	endif
 *	msr_seed is updated.
 */
double
bn_unif_double_fill(struct bn_unif *p)
{
	register long test,work_seed;
	register int i;

	/*
	 * Gauss and uniform structures have the same format for the
	 * first part (gauss is an extention of uniform) so that a gauss
	 * structure can be passed to a uniform routine.  This means 
	 * that we only maintain one structure for gaussian distributions
	 * rather than two.  It also means that the user can pull 
	 * uniform numbers from a guass structure when the user wants.
	 */
	if (!p || (p->magic != BN_UNIF_MAGIC &&
	    p->magic != BN_GAUSS_MAGIC)) {
		BN_CK_UNIF(p);
	}

	work_seed = p->msr_seed;

	if (p->msr_doubles) {
		for (i=0; i < BN_MSR_MAXTBL; i++) {
			test = A*(work_seed % Q) - R*(work_seed / Q);
			work_seed = (test < 0) ? test+M : test;
			p->msr_doubles[i] = ( work_seed - M/2) * 1.0/DM;
		}
		p->msr_double_ptr = BN_MSR_MAXTBL;
	}
	test = A*(work_seed % Q) - R*(work_seed / Q);
	p->msr_seed = (test < 0) ? test+M : test;

	return((p->msr_seed - M/2) * 1.0/DM);
}

/*	bn_unif_free	free random number table
 *
 *
 *
 */
void
bn_unif_free(struct bn_unif *p)
{
	bu_free(p->msr_doubles, "msr double table");
	bu_free(p->msr_longs, "msr long table");
	p->magic = 0;
	bu_free(p, "bn_unif");
}


/*	bn_gauss_init	Initialize a random number struct for gaussian 
 *	numbers.
 *
 * Entry:
 *	setseed		Seed to use.
 *	method		method to use to generate numbers (not used)
 *
 * Exit:
 *	Returns a pointer toa bn_msr_guass structure.
 *	returns 0 on error.
 *
 * Calls:
 *	bu_malloc
 *
 * Uses:
 *	None.
 *
 * Method:
 *	malloc up a structure
 *	get table space
 *	set seed and pointer.
 *	if setseed != 0 then seed = setseed
 */
struct bn_gauss *
bn_gauss_init(long int setseed, int method)
{
	struct bn_gauss *p;
	p = (struct bn_gauss *) bu_malloc(sizeof(struct bn_gauss),"bn_msr_guass");
	p->msr_gausses=(double *) bu_malloc(BN_MSR_MAXTBL*sizeof(double),"msr guass table");
	p->msr_gauss_doubles=(double *) bu_malloc(BN_MSR_MAXTBL*sizeof(double),"msr guass doubles");
	p->msr_gauss_seed = 1;
	p->msr_gauss_ptr = 0;
	p->msr_gauss_dbl_ptr = 0;

	if (setseed&0x7fffffff) p->msr_gauss_seed=setseed&0x7fffffff;
	p->magic = BN_GAUSS_MAGIC;
	return(p);
}

/*	bn_gauss_fill	fill a random number table.
 *
 * Use the msrad algorithm to fill a random number table.
 * hese numbers can (and are) extracted from
 * the random number table via high speed macros and bn_msr_guass_fill
 * called when the table is exauseted.
 *
 * Entry:
 *	p	pointer to a bn_msr_guass structure.
 *
 * Exit:
 *	if (!p) returns 0.0 else returns a value with a mean of 0 and
 *	    a variance of 1.0.
 *
 * Calls:
 *	BN_UNIF_CIRCLE to get to uniform random number whos radius is
 *	<= 1.0. I.e. sqrt(v1*v1 + v2*v2) <= 1.0
 *	BN_UNIF_CIRCLE is a macro which can call bn_unif_double_fill.
 *
 * Uses:
 *	None.
 *
 * Method:
 *	if (!p) return (0.0)
 *	if p->msr_longs != NULL 
 *		msr_longs is reloaded with random numbers;
 *		msr_long_ptr is set to BN_MSR_MAXTBL
 *	endif
 *	msr_seed is updated.
 */
double
bn_gauss_fill(struct bn_gauss *p)
{
	register int i;
	/* register */ double v1,v2,r,fac;

	BN_CK_GAUSS(p);

	if (p->msr_gausses) {
		for (i=0; i< BN_MSR_MAXTBL-1; ) {
			BN_UNIF_CIRCLE((struct bn_unif *)p,v1,v2,r);
			if (r<0.00001) continue;
			fac = sqrt(-2.0*log(r)/r);
			p->msr_gausses[i++] = v1*fac;
			p->msr_gausses[i++] = v2*fac;
		}
		p->msr_gauss_ptr = BN_MSR_MAXTBL;
	}

	do {
		BN_UNIF_CIRCLE((struct bn_unif *)p,v1,v2,r);
	} while (r < 0.00001);
	fac = sqrt(-2.0*log(r)/r);
	return(v1*fac);
}
/*	bn_gauss_free	free random number table
 *
 */
void
bn_gauss_free(struct bn_gauss *p)
{
	bu_free(p->msr_gauss_doubles, "msr guass doubles");
	bu_free(p->msr_gausses,"msr guass table");
	bu_free(p,"bn_msr_guass");
}


#undef A
#undef M
#undef DM
#undef Q
#undef R
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/msr.c,v 11.11 2004/04/05 07:46:41 morrison Exp $ (ARL)";
@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d31 5
a35 1
#include "conf.h"
@


11.10
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/msr.c,v 11.9 2002/08/20 17:07:36 jra Exp $ (ARL)";
d76 1
a76 3
bn_unif_init(setseed,method)
long setseed;
int method;
d119 1
a119 2
bn_unif_long_fill(p)
struct bn_unif *p;
d180 1
a180 2
bn_unif_double_fill(p)
struct bn_unif *p;
d220 1
a220 2
bn_unif_free(p)
struct bn_unif *p;
d253 1
a253 3
bn_gauss_init(setseed,method)
long setseed;
int method;
d299 1
a299 2
bn_gauss_fill(p)
struct bn_gauss *p;
d327 1
a327 2
bn_gauss_free(p)
struct bn_gauss *p;
@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1994 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/msr.c,v 11.7 2000/07/07 05:47:28 cjohnson Exp $ (ARL)";
@


11.9.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbn/msr.c,v 11.10 2004/02/02 17:39:06 morrison Exp $ (ARL)";
@


11.9.10.1
log
@merge from HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/msr.c,v 11.10 2004/02/02 17:39:06 morrison Exp $ (ARL)";
@


11.9.10.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/msr.c,v 11.9.10.1 2004/02/12 18:39:33 erikg Exp $ (ARL)";
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/msr.c,v 11.9 2002/08/20 17:07:36 jra Exp $ (ARL)";
d76 3
a78 1
bn_unif_init(long int setseed, int method)
d121 2
a122 1
bn_unif_long_fill(struct bn_unif *p)
d183 2
a184 1
bn_unif_double_fill(struct bn_unif *p)
d224 2
a225 1
bn_unif_free(struct bn_unif *p)
d258 3
a260 1
bn_gauss_init(long int setseed, int method)
d306 2
a307 1
bn_gauss_fill(struct bn_gauss *p)
d335 2
a336 1
bn_gauss_free(struct bn_gauss *p)
@


11.9.2.2
log
@sync branch with HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d76 3
a78 1
bn_unif_init(long int setseed, int method)
d121 2
a122 1
bn_unif_long_fill(struct bn_unif *p)
d183 2
a184 1
bn_unif_double_fill(struct bn_unif *p)
d224 2
a225 1
bn_unif_free(struct bn_unif *p)
d258 3
a260 1
bn_gauss_init(long int setseed, int method)
d306 2
a307 1
bn_gauss_fill(struct bn_gauss *p)
d335 2
a336 1
bn_gauss_free(struct bn_gauss *p)
@


11.7
log
@LINT
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/msr.c,v 11.6 2000/01/07 20:36:34 mike Exp $ (ARL)";
d76 1
a76 3
bn_unif_init(setseed,method)
long setseed;
int method;
d119 1
a119 2
bn_unif_long_fill(p)
struct bn_unif *p;
d180 1
a180 2
bn_unif_double_fill(p)
struct bn_unif *p;
d220 1
a220 2
bn_unif_free(p)
struct bn_unif *p;
d253 1
a253 3
bn_gauss_init(setseed,method)
long setseed;
int method;
d299 1
a299 2
bn_gauss_fill(p)
struct bn_gauss *p;
d327 1
a327 2
bn_gauss_free(p)
struct bn_gauss *p;
@


11.6
log
@
Added #undef's to allow library rollup into one file.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/msr.c,v 11.5 1997/02/10 21:03:08 butler Exp $ (ARL)";
@


11.5
log
@fixed typos
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/msr.c,v 11.4 1997/02/10 20:57:01 butler Exp butler $ (ARL)";
d342 7
@


11.4
log
@added bn_unif_free() and bn_gauss_free()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/msr.c,v 11.3 1996/10/02 23:20:36 mike Exp butler $ (ARL)";
d217 1
d223 1
d227 2
a228 2
	bu_free(p->msr_doubles "msr double table");
	bu_free(p->msr_longs "msr long table");
d336 1
a336 1
struct bn_unif *p;
d338 1
a338 1
	bu_free(p->msr_gauss_doubles,"msr guass doubles");
@


11.3
log
@Moved msr.c to LIBBN
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/msr.c,v 11.2 1995/11/02 18:16:48 cjohnson Exp $ (ARL)";
d217 14
d328 11
@


11.2
log
@Change two calls to mallac to rt_malloc.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/msr.c,v 11.1 1995/01/04 09:57:21 mike Rel4_4 cjohnson $ (ARL)";
d36 1
d38 1
a38 2
#include "raytrace.h"
#include "msr.h"
d40 7
a46 1
/*	msr_unif_init	Initialize a random number structure.
d53 1
a53 1
 *	returns	a pointer to a msr_unif structure.
d60 1
a60 1
 *	rt_malloc
d75 2
a76 2
struct msr_unif *
msr_unif_init(setseed,method)
d80 4
a83 4
	struct msr_unif *p;
	p = (struct msr_unif *) rt_malloc(sizeof(struct msr_unif),"msr_unif");
	p->msr_longs = (long *) rt_malloc(MSRMAXTBL*sizeof(long), "msr long table");
	p->msr_doubles=(double *) rt_malloc(MSRMAXTBL*sizeof(double),"msr double table");
d89 1
a89 1
	p->magic = MSR_UNIF_MAGIC;
d93 1
a93 1
/*	msr_unif_long_fill	fill a random number table.
d97 1
a97 1
 * the random number table via high speed macros and msr_unif_long_fill called
d101 1
a101 1
 *	p	pointer to a msr_unif structure.
d116 1
a116 1
 *		msr_long_ptr is set to MSRMAXTBL
d121 2
a122 2
msr_unif_long_fill(p)
struct msr_unif *p;
d135 3
a137 3
	if (!p || (p->magic != MSR_UNIF_MAGIC &&
	    p->magic != MSR_GAUSS_MAGIC)) {
		MSR_CK_UNIF(p);
d143 1
a143 1
		for (i=0; i < MSRMAXTBL; i++) {
d148 1
a148 1
		p->msr_long_ptr = MSRMAXTBL;
d155 1
a155 1
/*	msr_unif_double_fill	fill a random number table.
d159 1
a159 1
 * the random number table via high speed macros and msr_unif_double_fill
d163 1
a163 1
 *	p	pointer to a msr_unif structure.
d178 1
a178 1
 *		msr_long_ptr is set to MSRMAXTBL
d183 2
a184 2
msr_unif_double_fill(p)
struct msr_unif *p;
d197 3
a199 3
	if (!p || (p->magic != MSR_UNIF_MAGIC &&
	    p->magic != MSR_GAUSS_MAGIC)) {
		MSR_CK_UNIF(p);
d205 1
a205 1
		for (i=0; i < MSRMAXTBL; i++) {
d210 1
a210 1
		p->msr_double_ptr = MSRMAXTBL;
d218 1
a218 1
/*	msr_gauss_init	Initialize a random number struct for gaussian 
d226 1
a226 1
 *	Returns a pointer toa msr_guass structure.
d230 1
a230 1
 *	rt_malloc
d241 2
a242 2
struct msr_gauss *
msr_gauss_init(setseed,method)
d246 4
a249 4
	struct msr_gauss *p;
	p = (struct msr_gauss *) rt_malloc(sizeof(struct msr_gauss),"msr_guass");
	p->msr_gausses=(double *) rt_malloc(MSRMAXTBL*sizeof(double),"msr guass table");
	p->msr_gauss_doubles=(double *) rt_malloc(MSRMAXTBL*sizeof(double),"msr guass doubles");
d255 1
a255 1
	p->magic = MSR_GAUSS_MAGIC;
d259 1
a259 1
/*	msr_gauss_fill	fill a random number table.
d263 1
a263 1
 * the random number table via high speed macros and msr_guass_fill
d267 1
a267 1
 *	p	pointer to a msr_guass structure.
d274 1
a274 1
 *	MSR_UNIF_CIRCLE to get to uniform random number whos radius is
d276 1
a276 1
 *	MSR_UNIF_CIRCLE is a macro which can call msr_unif_double_fill.
d285 1
a285 1
 *		msr_long_ptr is set to MSRMAXTBL
d290 2
a291 2
msr_gauss_fill(p)
struct msr_gauss *p;
d296 1
a296 1
	MSR_CK_GAUSS(p);
d299 2
a300 2
		for (i=0; i< MSRMAXTBL-1; ) {
			MSR_UNIF_CIRCLE((struct msr_unif *)p,v1,v2,r);
d306 1
a306 1
		p->msr_gauss_ptr = MSRMAXTBL;
d310 1
a310 1
		MSR_UNIF_CIRCLE((struct msr_unif *)p,v1,v2,r);
@


11.1
log
@Release_4.4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/msr.c,v 10.5 94/12/27 18:18:28 mike Exp $ (ARL)";
d242 2
a243 2
	p->msr_gausses=(double *) malloc(MSRMAXTBL*sizeof(double));
	p->msr_gauss_doubles=(double *) malloc(MSRMAXTBL*sizeof(double));
@


10.5
log
@Added RCSid
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


10.4
log
@Added include of conf.h
@
text
@d1 2
a2 4
#ifndef lint
static char rcsid[] = "$Header: /m/cad/librt/RCS/msr.c,v 10.3 1994/02/07 20:02:28 cjohnson Exp gdurf $";
#endif
/*				M S R A N . C
d11 1
a11 1
 * Author:
d13 9
d23 3
a25 32
 * Source:
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Balistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland 21005-5066
 *
 * Copyright Notice -
 *	This software is Copyright (C) 1991 by the United States Army.
 *	All rights reserved.
 *
 *
 * $Log: msr.c,v $
 * Revision 10.3  1994/02/07  20:02:28  cjohnson
 * Fix the magic number check in *_unif_* routines.
 *
 * Revision 10.2  1994/02/07  17:54:36  cjohnson
 * Fix comments.
 *
 * Revision 10.1  1991/10/12  06:40:37  mike
 * Release_4.0
 *
 * Revision 1.4  91/07/25  01:26:10  butler
 * added magic number and checking to struct msr_unif & msr_gauss
 * 
 * Revision 1.3  91/06/22  05:43:33  cjohnson
 * Change to rt_malloc, add to many comments, add some NULL pointer tests.
 * 
 * Revision 1.2  1991/06/22  02:23:36  cjohnson
 * Sync RCS to source code
 *
 * Revision 1.1  90/04/20  02:05:36  cjohnson
 * Initial revision
 * 
d27 3
@


10.3
log
@Fix the magic number check in *_unif_* routines.
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/librt/RCS/msr.c,v 10.2 1994/02/07 17:54:36 cjohnson Exp cjohnson $";
d27 3
d49 2
@


10.2
log
@Fix comments.
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/librt/RCS/msr.c,v 10.1 1991/10/12 06:40:37 mike Rel4_0 cjohnson $";
d27 3
d135 12
a146 1
	MSR_CK_UNIF(p);
d197 12
a208 1
	MSR_CK_UNIF(p);
@


10.1
log
@Release_4.0
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/librt/RCS/msr.c,v 1.4 91/07/25 01:26:10 butler Exp $";
d26 4
a29 1
 * $Log:	msr.c,v $
d244 2
a245 2
 * Use the msrad algorithm to fill a random number table
 * with values from -1.0 to 10.0.  These numbers can (and are) extracted from
d250 1
a250 1
 *	p	pointer to a msr_guassstructure.
d253 2
a254 2
 *	if (!p) returns 0.0 else returns a value between -1.0 and 1.0
 *	with a guassian distribution (bell curve)
@


1.4
log
@added magic number and checking to struct msr_unif & msr_gauss
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/librt/RCS/msr.c,v 1.3 91/06/22 05:43:33 cjohnson Exp $";
d27 3
@


1.3
log
@Change to rt_malloc, add to many comments, add some NULL pointer tests.
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: /m/cad/libmsr/RCS/msran.c,v 1.2 1991/06/22 02:23:36 cjohnson Exp cjohnson $";
d26 4
a29 1
 * $Log: msran.c,v $
d40 3
d88 1
d126 1
a126 1
	if (!p) return(1);
d177 1
a177 1
	if (!p) return(0.0);
d232 1
d273 1
a273 1
	if (!p) return(0.0);
@


1.2
log
@Sync RCS to source code
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: msran.c,v 1.1 90/04/20 02:05:36 cjohnson Locked $";
d4 31
d37 3
a39 3
#include "./msr.h"
extern int Debug;
/*	msran	minimal standard random number generator
d53 1
a53 1
 *	malloc
d55 6
a60 4
 *	Stephen K. Park and Keith W. Miller
 *	Random number generators: good ones are hard to find
 *	CACM vol 31 no 10, Oct 88
 *	Translated to 'C' by Christopher T. Johnson
a61 5
 * $Log:	msran.c,v $
 * Revision 1.1  90/04/20  02:05:36  cjohnson
 * Initial revision
 * 
 * 
d74 3
a76 7
	p = (struct msr_unif *) malloc(sizeof(struct msr_unif));
	if (!p) {
		fprintf(stderr,"msr_init: Unable to allocat msr_unif.\n");
		return(NULL);
	}
	p->msr_longs = (long *) malloc(MSRMAXTBL*sizeof(long));
	p->msr_doubles=(double *) malloc(MSRMAXTBL*sizeof(double));
d88 2
a89 2
 * with values from 1 to 2^31-1.  These numbers can extracted from
 * the random number table via high speed macros and msr_unif_fill called
d96 1
a96 6
 *	if p->msr_longs != NULL 
 *		msr_longs is reloaded with random numbers;
 *		msr_long_ptr is set to MSRMAXTBL
 *	endif
 *	msr_seed is updated.
 *	A long between 1 and 2^31-1 is returned.
d104 7
a110 3
 * Author:
 *	Christopher T. Johnson.
 *
d119 2
d123 1
a123 1
	if (p->msr_longs) {
d132 1
a132 2
	p->msr_seed = (test < 0) ? test+M : test;

d136 27
d170 2
d188 23
d217 1
a217 5
	p = (struct msr_gauss *) malloc(sizeof(struct msr_gauss));
	if (!p) {
		fprintf(stderr,"msr_init: Unable to allocat msr_gauss.\n");
		return(NULL);
	}
d228 30
d265 2
d268 1
a268 1
		for (i=0; i< MSRMAXTBL; ) {
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char rcsid[] = "$Header: msran.c,v 2.3 90/04/19 01:51:32 cjohnson Exp $";
d29 3
a31 1
 * $Log$
d33 1
d61 1
a61 1
/*	msr_unif_fill_long	fill a random number table.
d147 1
d150 1
d161 1
a161 1
	register double v1,v2,r,fac;
@
