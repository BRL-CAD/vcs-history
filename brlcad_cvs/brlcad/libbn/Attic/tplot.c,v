head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	ansi-20040316-freeze:11.4.2.1
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:1.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.07.37;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.54.49;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2000.10.18.18.10.32;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.51.21;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.12.19.16.01.07;	author jra;	state Exp;
branches;
next	10.2;

10.2
date	94.08.12.19.21.00;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.40;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.02.01.14.59;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.05.31.11.26.06;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.11.25.11.42.36;	author cjohnson;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.49.55;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.28.49;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.05.13.22.39.56;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.08.23.41.50;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.28.50;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.53.17;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.53.26;	author mike;	state Rel;
branches;
next	1.1;

1.1
date	87.01.12.18.59.54;	author mike;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.01.10;	author morrison;	state Exp;
branches;
next	;


desc
@create an x-y plot
@


11.7
log
@moved to src/
@
text
@/*
 *
 *			T P _ P L O T
 *
 *
 *			George W. Hartwig, Jr.
 *				16 March 1979
 *
 *
 *	This routine is designed to simplify the creation of 
 * X,Y plots for user. The user need only furnish this program
 * the data arrays to be plotted, the lengths of the respective
 * axis, titles for the axis, and the point on the page corresponding
 * to data point (0,0).
 *	The program will then do everything else required to make
 * the plot appear on the user's terminal including scaling of the 
 * data, centering of the titles and positioning on the page.
 *
 *
 * where
 *	int xp,yp	page point corresponding to (0,0) of the data
 *	int xl,yl	lengths of the x and y axis, respectively
 *	char xtitle[], ytitle[]	titles for the axis
 *	float x[], y[]	the floating point data arrays
 *	int n		the number of points in the data arrays
 *
 *
 *		R E V I S I O N  H I S T O R Y
 *
 *	WHO	WHEN		WHAT
 *	GWH	5/21/79		Modified ftoa so that nos. < e-15
 *				map to zero.
 *	GWH	6/29/79		Changed the axis drawing loops to
 *				prevent a one tic mark overrun.
 *	GWH	7/10/79		Subtracted one from n to allow for the
 *				fact that fortran arrays start at one
 *				and not zero as with c.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "plot3.h"

#define TIC		100
#define REF_WIDTH	0.857143
#define NUM_DISTANCE	250
#define LAB_LNGTH	860

void	tp_ftoa(float x, char *s);
void	tp_fixsc(float *x, int npts, float size, float *xs, float *xmin, float *xmax, float *dx), tp_sep(float x, float *coef, int *ex);
double	tp_ipow(double x, int n);

void
tp_plot(FILE *fp, int xp, int yp, int xl, int yl, char *xtitle, char *ytitle, float *x, float *y, int n, double cscale)
    	    
   	   		/* page point desired to be (0,0) for plot */
   	   
   	   		/* lengths of x,y axis */
   	   
    	         
    	         
     	    
     	    
   	  		/* number of points */
      	       		/* character scale factor */
{
	int  ddx, ddy, xend, yend, xpen, ypen;
	float fxl, fyl, xs, ys, xmin, xmax, ymin, ymax, dx, dy;
	float lab;
	int xtics, ytics, i, xtl, ytl, j;
	int ix[101], iy[101], isave;
	char str[32];

	if( xl == 0 ){
		j = 0;
		goto loop;
	}
	fxl = xl/1000.0;
	fyl = yl/1000.0;
	n -= 1; /* allow for the fact that fortran starts arrays at 1 */
	tp_fixsc (x, n, fxl, &xs, &xmin, &xmax, &dx);
	tp_fixsc (y, n, fyl, &ys, &ymin, &ymax, &dy);
	ddx = dx*xs;
	ddy = dy*ys;
	xtics = LAB_LNGTH / ddx + 1.0;
	ytics = 500/ddy + 1.0;
	xend = xl+xp;
	xpen = xp;

	pl_move(fp, xpen, yp-TIC);
	pl_cont(fp, xpen,yp);

	/* label first tic */
	lab = xmin;
	sprintf( str, "%3.3g", xmin );
	tp_2symbol( fp, str, (double)(xpen-171),(double)(yp-TIC-NUM_DISTANCE), cscale, 0.0);
	i = 0;
	while((xpen+ddx)<=xend){
		i++;
		xpen += ddx;
		pl_line( fp, xpen, yp, xpen, yp-TIC );
		/* while here label this tic mark if no overlapping will occur */
		lab += dx;
		/* need if test here to check for overlap */
		if( (i%xtics) == 0){
			sprintf( str, "%3.3g", lab );
			tp_2symbol( fp, str, (double)(xpen-171), (double)(yp-TIC-NUM_DISTANCE), cscale, 0.0);
		}
	}

	/* insert axis label here */
	xtl = xp+(xl - strlen(xtitle)*cscale)/2;
	ytl = yp - 8 * cscale;
	tp_2symbol( fp, xtitle,(double)xtl, (double)ytl, 100.0, 0.0);
	yend = yl+yp;
	ypen= yp;
	pl_line( fp, xp-TIC, ypen, xp, ypen );

	/* draw first y label */
	lab = ymin;
	sprintf( str, "%3.3g", lab );
	tp_2symbol( fp,str, (double)(xp-TIC-LAB_LNGTH-NUM_DISTANCE), (double)ypen, cscale, 0.0);

	i=0;
	while((ypen+ddy)<=yend){
		i++;
		ypen += ddy;
		pl_line( fp, xp, ypen, xp-TIC, ypen );
		/* label the y-axis now, nicely */
		lab += dy;
		if(( i%ytics) ==0){
			sprintf( str, "%3.3g", lab );
			tp_2symbol( fp,str, (double)(xp-TIC-LAB_LNGTH-NUM_DISTANCE), (double)ypen, cscale, 0.0);
		}
	}

	/* insert y-axis title here */
	xtl= xp-1500;
	ytl= yp + (yl - strlen(ytitle)*cscale)/2 ;
	tp_2symbol( fp,ytitle,(double)xtl,(double)ytl,100.0,90.0);

	/* now at long last plot the data */
	j = 0;
loop:
	if( n <= 100 )
		isave = n-1;
	else{
		isave = 100;
		n -= 101;
	}
	if(j == 0){
		ix[0] = (x[j] - xmin)*xs + xp;
		iy[0] = (y[j] - ymin)*ys + yp;
		j++;
	}
	else{
		ix[0] = (x[j-1] - xmin)*xs + xp;
		iy[0] = (y[j-1] - ymin)*ys + yp;
	}
	i = 1;
	while( i <= isave ){
		ix[i] = (x[j] - xmin)*xs + xp;
		iy[i] = (y[j] - ymin)*ys + yp;
		i++;
		j++;
	}
	tp_i2list( fp, ix, iy, isave+1 );
	if( isave == 100 )
		goto loop;
}

/*
 *			T P _ F T O A
 *
 *
 *			George W Hartwig, Jr.
 *			16 March 1979
 *
 * This routine converts a floating point number into a string
 * of ascii characters of the form "sX.XXXesXX". The string is
 * null terminated.
 */
void
tp_ftoa(float x, char *s)
{
	int ex,tmp;
	float coef;
	char esgn, nsgn;
	char i;
	tp_sep(x, &coef, &ex);
	if( ex < -15 ){
		ex = 0;
		*s++ = '0';
		*s++ = '.';
		*s++ = '0';
		*s++ = '0';
		*s++ = '0';
		*s++ = 'e';
		*s++ = '+';
		*s++ = '0';
		*s++ = '0';
		*s   =  0 ;
		return;
	}
	if(ex < 0){
		esgn = '-';
		ex = -ex;
	}
	else
		esgn = '+';
	if( coef < 0.0){
		nsgn = '-';
		coef = -coef;
	}
	else
		nsgn = ' ';
	*s++ = nsgn;
	/* load the first numeral and the decimal point */
	tmp = coef;
	*s++ = tmp + '0';
	coef = (coef - tmp)*10.0;
	*s++ = '.';
	/* now do the three after the decimal */
	for( i=1 ; i<=3 ; ++i){
		tmp = coef;
		coef = (coef - tmp)*10.0;
		*s++ = tmp + '0';
	}
	/* put the e in */
	*s++ = 'e';
	/* the sign for the exponent */
	*s++ = esgn;

	/* and the exponent */
	if( ex < 0)
		ex = -ex;
	if( ex < 10 ){
		*s++ = '0';
		*s++ = ex + '0';
	}
	else{
		tmp = ex/10;
		*s++ = tmp + '0';
		ex = ex - tmp*10;
		*s++ = ex +'0';
	}
	/* add a null byte terminator */
	*s = 0;
}
/*
 *			T P _ F I X S C
 *
 *		written by George Hartwig
 *			6 March 1979
 *
 *   tp_fixsc is a scaling routine intended to be used in conjunction
 *   with plotting routines. What tp_fixsc does is scale the user supplied
 *   data so that it fits on a specified axis and has 'nice' numbers
 *   for labels.
 *
 *   Calling sequence
 *
 *   tp_fixsc(x, npts, size, xs, xmin, xmax, dx)
 *   where
 *
 *	float x[]	the data array to be scaled
 *	int npts	the number of elements in x[]
 *	float size	the length into which x[] is supposed to be fitted
 *			(in inches)
 *	float *xs	the returned scale facter to integer space
 *	float *xmin	the new minimum value for the data array (a returned
 *			value)
 *	float *xmax	the new maximum value for the data array (a returned
 *			value)
 *	float *dx	the value in data units between tic marks (a returned
 *			value)
 *
 */
void
tp_fixsc(float *x, int npts, float size, float *xs, float *xmin, float *xmax, float *dx)
{
	float txmi, txma, coef, delta, diff;
	int i, ex;
	txmi=txma=x[0];
	i = 0;
	while( i <= npts ) {
		if( x[i] < txmi)
			txmi = x[i];
		if( x[i] > txma)
			txma = x[i];
		i++;
	}
	diff = txma - txmi;
	if( diff < .000001 )
		diff = .000001;
	tp_sep (diff, &coef, &ex);
	if( coef < 2.0 )
		delta = .1;
	else if ( coef < 4.0 )
		delta = .2;
	else
	    delta = .5;
	i = 0;
	if(ex < 0 ){
		ex = -ex;
		i=12;
	}
	delta *= tp_ipow(10.0,ex);
	if(i == 12)
		delta = 1.0/delta;
	*dx = delta;
	i = (fabs(txmi)/delta);
	*xmin = i*delta;
	if( txmi < 0.0 )
		*xmin = -(*xmin+delta);
	i = (fabs(txma)/delta);
	*xmax = i*delta;
	if( txma < 0.0)
		*xmax = - *xmax;
	else
	    *xmax = *xmax+delta;
	*xs = 1000.*size/(*xmax - *xmin);
}

/*
 *			T P _ S E P
 *
 *  tp_sep() divides a floating point number into a coefficient
 *  and an exponent. works in base ten.
 */
void
tp_sep(float x, float *coef, int *ex)
{
	int i, isv;
	float xx;
	isv = 1;
	if(x < 0.0 ){
		isv = -1;
		x = -x;
	}
	if( x > 1.0 ){
		xx = x;
		*ex = 0;
		*coef = 0.0;
		if ( xx < 10.0){
			*coef = xx*isv;
			return;
		}
		for ( i=1 ; i < 39 ; ++i){
			*ex += 1;
			xx = xx/10.0;
			if( xx < 10.0 )
				break;
		}
		*coef = xx*isv;
		return;
	}
	else{
		xx = x;
		*ex = 0;
		*coef = 0.0;
		for ( i=1 ; i<39 ; ++i){
			*ex -= 1;
			xx *= 10.0;
			if( xx >= 1.0 )
				break;
		}
		*coef = xx*isv;
		return;
	}
}

/*
 *			T P _ I P O W
 *
 *  tp_ipow() raises a floating point number to a positve integer
 *  power.
 *  XXX Horribly inefficient!
 */
double tp_ipow (double x, int n)
{
	return(n>0?x*tp_ipow(x,n-1):1);
}


/*
 *	FORTRAN Interface Entry
 */
void
PL_FORTRAN(fplot, FPLOT)(fp, xp, yp, xl, yl, xtitle, ytitle, x, y, n, cscale )
FILE	**fp;
int	*xp;
int	*yp;
int	*xl;
int	*yl;
char	*xtitle;
char	*ytitle;
float	*x;
float	*y;
int	*n;
float	*cscale;
{
	tp_plot(*fp, *xp, *yp, *xl, *yl, xtitle, ytitle, x, y, *n, *cscale);
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@@


11.5
log
@merge of ansi-6-0-branch into HEAD
@
text
@d39 5
a43 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d55 3
a57 3
void	tp_ftoa();
void	tp_fixsc(), tp_sep();
double	tp_ipow();
d60 12
a71 12
tp_plot( fp, xp, yp, xl, yl, xtitle, ytitle, x, y, n, cscale )
FILE	*fp;
int	xp;		/* page point desired to be (0,0) for plot */
int	yp;
int	xl;		/* lengths of x,y axis */
int	yl;
char	xtitle[];
char	ytitle[];
float	x[];
float	y[];
int	n;		/* number of points */
double	cscale;		/* character scale factor */
d190 1
a190 3
tp_ftoa(x, s)
float x;
char *s;
d286 1
a286 3
tp_fixsc(x,npts,size,xs,xmin,xmax,dx)
int npts;
float x[], size, *xs, *xmin, *xmax, *dx ;
d338 1
a338 3
tp_sep( x, coef, ex )
float x, *coef;
int *ex;
d386 1
a386 3
double tp_ipow (x, n)
double x;
int n;
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d55 3
a57 3
void	tp_ftoa(float x, char *s);
void	tp_fixsc(float *x, int npts, float size, float *xs, float *xmin, float *xmax, float *dx), tp_sep(float x, float *coef, int *ex);
double	tp_ipow(double x, int n);
d60 12
a71 12
tp_plot(FILE *fp, int xp, int yp, int xl, int yl, char *xtitle, char *ytitle, float *x, float *y, int n, double cscale)
    	    
   	   		/* page point desired to be (0,0) for plot */
   	   
   	   		/* lengths of x,y axis */
   	   
    	         
    	         
     	    
     	    
   	  		/* number of points */
      	       		/* character scale factor */
d190 3
a192 1
tp_ftoa(float x, char *s)
d288 3
a290 1
tp_fixsc(float *x, int npts, float size, float *xs, float *xmin, float *xmax, float *dx)
d342 3
a344 1
tp_sep(float x, float *coef, int *ex)
d392 3
a394 1
double tp_ipow (double x, int n)
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d55 3
a57 3
void	tp_ftoa(float x, char *s);
void	tp_fixsc(float *x, int npts, float size, float *xs, float *xmin, float *xmax, float *dx), tp_sep(float x, float *coef, int *ex);
double	tp_ipow(double x, int n);
d60 12
a71 12
tp_plot(FILE *fp, int xp, int yp, int xl, int yl, char *xtitle, char *ytitle, float *x, float *y, int n, double cscale)
    	    
   	   		/* page point desired to be (0,0) for plot */
   	   
   	   		/* lengths of x,y axis */
   	   
    	         
    	         
     	    
     	    
   	  		/* number of points */
      	       		/* character scale factor */
d190 3
a192 1
tp_ftoa(float x, char *s)
d288 3
a290 1
tp_fixsc(float *x, int npts, float size, float *xs, float *xmin, float *xmax, float *dx)
d342 3
a344 1
tp_sep(float x, float *coef, int *ex)
d392 3
a394 1
double tp_ipow (double x, int n)
@


11.2
log
@Patches for compiling under RedHat 7.0
@
text
@d55 3
a57 3
void	tp_ftoa();
void	tp_fixsc(), tp_sep();
double	tp_ipow();
d60 12
a71 12
tp_plot( fp, xp, yp, xl, yl, xtitle, ytitle, x, y, n, cscale )
FILE	*fp;
int	xp;		/* page point desired to be (0,0) for plot */
int	yp;
int	xl;		/* lengths of x,y axis */
int	yl;
char	xtitle[];
char	ytitle[];
float	x[];
float	y[];
int	n;		/* number of points */
double	cscale;		/* character scale factor */
d190 1
a190 3
tp_ftoa(x, s)
float x;
char *s;
d286 1
a286 3
tp_fixsc(x,npts,size,xs,xmin,xmax,dx)
int npts;
float x[], size, *xs, *xmin, *xmax, *dx ;
d338 1
a338 3
tp_sep( x, coef, ex )
float x, *coef;
int *ex;
d386 1
a386 3
double tp_ipow (x, n)
double x;
int n;
@


11.1
log
@Release_4.4
@
text
@d42 3
@


10.3
log
@Fixed calls to tp_2symbol to satisfy CRAY.
@
text
@@


10.2
log
@Added include of conf.h
@
text
@d99 1
a99 1
	tp_2symbol( fp, str, xpen-171,yp-TIC-NUM_DISTANCE, cscale, 0.0);
d110 1
a110 1
			tp_2symbol( fp, str, xpen-171, yp-TIC-NUM_DISTANCE, cscale, 0.0);
d117 1
a117 1
	tp_2symbol( fp, xtitle,xtl, ytl, 100, 0.0);
d125 1
a125 1
	tp_2symbol( fp,str, xp-TIC-LAB_LNGTH-NUM_DISTANCE, ypen, cscale, 0.0);
d136 1
a136 1
			tp_2symbol( fp,str, xp-TIC-LAB_LNGTH-NUM_DISTANCE, ypen, cscale, 0.0);
d143 1
a143 1
	tp_2symbol( fp,ytitle,xtl,ytl,100,90.0);
@


10.1
log
@Release_4.0
@
text
@d39 2
@


9.4
log
@TIG-Pack is now part of libplot3
@
text
@@


9.3
log
@ANSI prototypes
@
text
@a43 1
#include "./tig.h"
@


9.2
log
@Change the fortran routines to use the F macro from
libplot3/fortran.c to generate subroutine names. (case and trailing 
underscore)
@
text
@d41 3
d51 3
a53 3
/* XXX These should probably either be static, or get different names */
void	fixsc(), sep();
float	pwr();
d58 4
a61 2
int	xp, yp;		/* page point desired to be (0,0) for plot */
int	xl, yl;		/* lengths of x,y axis */
d64 2
a65 1
float	x[], y[];
d83 2
a84 2
	fixsc (x, n, fxl, &xs, &xmin, &xmax, &dx);
	fixsc (y, n, fyl, &ys, &ymin, &ymax, &dy);
d169 1
a169 1
	tp_2list( fp, ix, iy, isave+1 );
d175 1
a175 1
 *			F T O A
d186 1
a186 1
ftoa(x, s)
d194 1
a194 1
	sep(x, &coef, &ex);
d255 1
a255 1
 *			F I X S C
d260 2
a261 2
 *   fixsc is a scaling routine intended to be used in conjunction
 *   with plotting routines. What fixsc does is scale the user supplied
d267 1
a267 1
 *   fixsc(x, npts, size, xs, xmin, xmax, dx)
d284 1
a284 1
fixsc(x,npts,size,xs,xmin,xmax,dx)
d302 1
a302 1
	sep (diff, &coef, &ex);
d314 1
a314 1
	delta *= pwr(10.0,ex);
a330 2
void
sep( x, coef, ex )
d332 3
a334 1
 *  sep() divides a floating point number into a coefficient
d337 2
d382 3
a384 1
 *  pwr() raises a floating point number to a positve integer
d386 1
d388 2
a389 2
float pwr (x, n)
float x;
d392 1
a392 1
	return(n>0?x*pwr(x,n-1):1);
d397 1
a397 1
 *	CULC FORTRAN-IV Interface Entry
d400 12
a411 4
F(fplot, FPLOT)(xp, yp, xl, yl, xtitle, ytitle, x, y, n )
char *xtitle, *ytitle;
int *xp, *yp, *xl, *yl, *n;
float *x, *y;
d413 1
a413 1
	tp_plot(*xp, *yp, *xl, *yl, xtitle, ytitle, x, y, *n);
@


9.1
log
@Release_3.5
@
text
@d41 1
d389 1
a389 1
FPLOT(xp, yp, xl, yl, xtitle, ytitle, x, y, n )
@


8.1
log
@Release_3.0
@
text
@@


7.3
log
@lint fix
@
text
@@


7.2
log
@Latest round of cleanups and name changes.
@
text
@d47 5
d178 1
d183 1
a183 1
	int exp,tmp;
d187 3
a189 3
	sep(x, &coef, &exp);
	if( exp < -15 ){
		exp = 0;
d202 1
a202 1
	if(exp < 0){
d204 1
a204 1
		exp = -exp;
d232 3
a234 3
	if( exp < 0)
		exp = -exp;
	if( exp < 10 ){
d236 1
a236 1
		*s++ = exp + '0';
d239 1
a239 1
		tmp = exp/10;
d241 2
a242 2
		exp = exp - tmp*10;
		*s++ = exp +'0';
d276 1
d282 1
a282 2
	float pwr(), tabs();
	int i, exp;
d295 1
a295 1
	sep (diff, &coef, &exp);
d303 2
a304 2
	if(exp < 0 ){
		exp = -exp;
d307 1
a307 1
	delta *= pwr(10.0,exp);
d311 1
a311 1
	i = (tabs(txmi)/delta);
d315 1
a315 1
	i = (tabs(txma)/delta);
d323 3
a325 1
sep( x, coef, exp )
d331 1
a331 1
int *exp;
d342 1
a342 1
		*exp = 0;
d349 1
a349 1
			*exp += 1;
d359 1
a359 1
		*exp = 0;
d362 1
a362 1
			*exp -= 1;
d371 1
a371 1
float pwr (x, n)
d376 1
a381 9
float tabs(x)
/*
 *  This routine returns the absolute value of a floating
 *  point number.
 */
float x;
{
	return(x>0.0?x:-x);
}
d387 1
a387 1

@


7.1
log
@Release 2.3
@
text
@d81 1
a81 1
	pl_draw(fp, xpen,yp);
d86 1
a86 1
	tp_symbol( fp, str, xpen-171,yp-TIC-NUM_DISTANCE, cscale, 0.0);
d97 1
a97 1
			tp_symbol( fp, str, xpen-171, yp-TIC-NUM_DISTANCE, cscale, 0.0);
d104 1
a104 1
	tp_symbol( fp, xtitle,xtl, ytl, 100, 0.0);
d112 1
a112 1
	tp_symbol( fp,str, xp-TIC-LAB_LNGTH-NUM_DISTANCE, ypen, cscale, 0.0);
d123 1
a123 1
			tp_symbol( fp,str, xp-TIC-LAB_LNGTH-NUM_DISTANCE, ypen, cscale, 0.0);
d130 1
a130 1
	tp_symbol( fp,ytitle,xtl,ytl,100,90.0);
d157 1
a157 1
	tp_line( fp, ix, iy, isave+1 );
d388 1
a388 1
fplot(xp, yp, xl, yl, xtitle, ytitle, x, y, n )
d393 1
a393 1
	plot(*xp, *yp, *xl, *yl, xtitle, ytitle, x, y, *n);
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


1.1
log
@Initial revision
@
text
@@
