head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	ansi-20040316-freeze:11.4.2.1
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:1.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.07.37;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.54.49;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2000.07.11.23.30.40;	author cjohnson;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.51.19;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.04.04.41.43;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.12.19.19.28;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.38;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.02.01.14.57;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.05.31.11.26.04;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.11.25.11.42.30;	author cjohnson;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.49.50;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.28.45;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.06.11.02.14.13;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.13.22.39.52;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.13.00.00.11;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.28.45;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.53.12;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.53.19;	author mike;	state Rel;
branches;
next	1.1;

1.1
date	87.01.12.18.59.22;	author mike;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.01.09;	author morrison;	state Exp;
branches;
next	;


desc
@unix-tig pack
scale data
@


11.7
log
@moved to src/
@
text
@/*
 *			T P _ S C A L E
 *
 *
 *	This routine is intended to take an array of
 * data points as input (either integer, floating, or
 * double), and scale it to fit in a space of LENGTH units.
 * An output array is returned
 * which contains the scaled information stored in 16-bit integers.  The input
 * and output arrays may overlap, as the input will never
 * occupy more space than the output.  Also output are
 * the minimum value encountered (MIN), and a delta
 * factor showing the increase in value each XXXX.
 * This DX factor is rounded to 1,2,4,5,8,or 10 to
 * produce nicer looking axes.
 *
 * where
 *
 *	int *idata	INPUT	This pointer contains the address
 *				of the input array to be scaled.
 *				Actual type of array is determined
 *				by MODE parameter.
 *	int elements	INPUT	Number of elements in IDATA to be used.
 *	int mode	INPUT	Specifies type of data that IDATA points
 *				to;  should be one of:
 *					'd' - double precision
 *					'f' - float (single precision)
 *					'i' - integer
 *	int length	INPUT	Contains the length (in 1/1000ths of an
 *				inch) of the region in which the data is
 *				to be scaled into.  Note that the actual
 *				amount of space needed may be this value
 *				rounded up to the next inch.
 *	int *odata	OUTPUT	This pointer contains the address of the
 *				output array, which will always be of
 *				integer type.
 *	double *min	OUTPUT	This pointer contains the address of the
 *				location for minimum point found to be
 *				placed in.
 *	double *dx	OUTPUT	This pointer addresses the delta value
 *				of the data which corresponds to the width
 *				of EACH tick.
 *				This implies that:
 *				  1)	This is exactly the number to divide
 *					raw data by to scale it to this scale
 *					(ex:  2 graphs with one scale factor)
 *				  2)	When this value is fed to the AXIS
 *					routine, it must be multiplied 
 *					by 1000.0 first (to specify increment
 *					between one INCH ticks).
 *
 * The fact that this routine returns variables of type DOUBLE has
 * important implications for FORTRAN users.  These variables must
 * be declared of type DOUBLE PRECISION to reserve enough space.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/scale.c,v 11.6 2004/05/10 15:30:43 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "plot3.h"

void
tp_scale(int *idata, int elements, register int mode, int length, int *odata, double *min, double *dx)
{
	double xmax, xmin, x, workdx;
	register int i;			/* Index variable */
	static double log_10;		/* Saved value for log base-2(10) */
	float *ifloatp;			/* Used to convert pointer-to-int to float */
	double *idoublep;		/* Used to convert pointer-to-int to double */
	double fractional;		/* Fractional part of DX */
	int integral;			/* Integral part of DX */

	/* Prepare to use a pointer to an array of variable type */
	ifloatp = (float *)idata;
	idoublep = (double *)idata;
	/* Find the maximum and minimum data values */
	xmax = xmin = 0.0;
	for( i=0; i<elements; i++ )  {
		x = (mode=='f')
			? ifloatp[i]
			: ( (mode=='d')
				? idoublep[i]
				: idata[i]
			);
		if( x > xmax )
			xmax = x;
		if( x < xmin )
			xmin = x;
	}

	/* Split initial DX into integral and fractional exponents of 10 */
	if( log_10 <= 0.0 )
		log_10 = log(10.0);

	fractional = log( (xmax-xmin)/length ) / log_10;	/* LOG10(DX) */
	integral = fractional;			/* truncate! */
	fractional -= integral;			/* leave only fract */

	if( fractional < 0.0 )  {
		fractional += 1.0;		/* ?? */
		integral -= 1;
	}

	fractional = pow( 10.0, fractional );
	i = fractional - 0.01;
	switch( i )  {

	case 1:
		fractional = 2.0;
		break;

	case 2:
	case 3:
		fractional = 4.0;
		break;

	case 4:
		fractional = 5.0;
		break;

	case 5:
	case 6:
	case 7:
		fractional = 8.0;
		break;

	case 8:
	case 9:
		fractional = 10.0;

	}

	/* Compute DX factor, combining power of ten & adjusted co-efficient */
	workdx = pow( 10.0, (double)integral ) * fractional;

	/* Apply the MIN and DX values to the users input data */
	for( i=0; i<elements; i++ )  {
		if( mode == 'f' )
			odata[i] = (ifloatp[i] - xmin) / workdx;
		else
			if( mode == 'd' )
				odata[i] = (idoublep[i] - xmin) / workdx;
			else
				odata[i] = (idata[i] - xmin) / workdx;
	}

	/* Send MIN and DX back to the user */
	*min = xmin;
	*dx = workdx;
}



/*
 *	FORTRAN Interface
 */
void
PL_FORTRAN(fscale, FSCALE)( idata, elements, mode, length, odata, min, dx )
int	idata[];
int	*elements;
char	*mode;
int	*length;
int	odata[];
double	*min;
double	*dx;
{
	tp_scale( idata, *elements, *mode, *length, odata, min, dx );
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/scale.c,v 11.5 2004/04/05 07:46:41 morrison Exp $ (ARL)";
@


11.5
log
@merge of ansi-6-0-branch into HEAD
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d70 5
a74 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/scale.c,v 11.2 2000/07/11 23:30:40 cjohnson Exp $ (ARL)";
d79 1
a79 8
tp_scale( idata, elements, mode, length, odata, min, dx )
int idata[];
int elements;
register int mode;
int length;
int odata[];
double *min;
double *dx;
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/scale.c,v 11.4 2002/08/20 17:07:37 jra Exp $ (ARL)";
d79 8
a86 1
tp_scale(int *idata, int elements, register int mode, int length, int *odata, double *min, double *dx)
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d79 8
a86 1
tp_scale(int *idata, int elements, register int mode, int length, int *odata, double *min, double *dx)
@


11.2
log
@LINT picking.  Missing includes and static const for RCSids
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/scale.c,v 11.1 1995/01/04 09:51:19 mike Rel4_4 $ (ARL)";
d79 1
a79 8
tp_scale( idata, elements, mode, length, odata, min, dx )
int idata[];
int elements;
register int mode;
int length;
int odata[];
double *min;
double *dx;
@


11.1
log
@Release_4.4
@
text
@d67 1
a67 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/scale.c,v 10.3 94/11/04 04:41:43 mike Exp $ (ARL)";
@


10.3
log
@Added RCS header
@
text
@d67 1
a67 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


10.2
log
@Added include of conf.h
@
text
@d56 9
d66 4
@


10.1
log
@Release_4.0
@
text
@d57 2
@


9.4
log
@TIG-Pack is now part of libplot3
@
text
@@


9.3
log
@ANSI prototypes
@
text
@a61 1
#include "./tig.h"
@


9.2
log
@Change the fortran routines to use the F macro from
libplot3/fortran.c to generate subroutine names. (case and trailing 
underscore)
@
text
@d59 3
d68 1
a68 1
register char mode;
d164 1
a164 1
 *	FORTRAN-FOUR PLUS User Interface
a165 1

d167 8
a174 8
F(fscale, FSCALE)( idata, elements, mode, length, odata, min, dx )
int idata[];
int *elements;
char *mode;
int *length;
int odata[];
double *min;
double *dx;
@


9.1
log
@Release_3.5
@
text
@d59 1
d165 1
a165 1
FSCALE( idata, elements, mode, length, odata, min, dx )
@


8.1
log
@Release_3.0
@
text
@@


7.4
log
@Changed log10 variable to log_10, for picky Cray.
@
text
@@


7.3
log
@lint fix
@
text
@d72 1
a72 1
	static double log10;		/* Saved value for log base-2(10) */
d97 2
a98 2
	if( log10 <= 0.0 )
		log10 = log(10.0);
d100 1
a100 1
	fractional = log( (xmax-xmin)/length ) / log10;	/* LOG10(DX) */
@


7.2
log
@Fixed updated name
@
text
@d60 1
d163 1
@


7.1
log
@Release 2.3
@
text
@d162 1
a162 1
fscale( idata, elements, mode, length, odata, min, dx )
d171 1
a171 1
	scale( idata, *elements, *mode, *length, odata, min, dx );
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


1.1
log
@Initial revision
@
text
@@
