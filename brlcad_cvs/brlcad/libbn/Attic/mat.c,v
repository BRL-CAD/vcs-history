head	11.34;
access;
symbols
	ansi-20040405-merged:11.30.2.2
	postmerge-20040405-ansi:11.32
	premerge-20040404-ansi:11.31
	postmerge-autoconf:11.31
	autoconf-freeze:11.30.10.2
	premerge-autoconf:11.31
	ansi-20040316-freeze:11.30.2.1
	postmerge-20040315-windows:11.31
	premerge-20040315-windows:11.31
	windows-20040315-freeze:11.30.4.1
	autoconf-20031203:11.30
	autoconf-20031202:11.30
	autoconf-branch:11.30.0.10
	phong-branch:11.30.0.8
	photonmap-branch:11.30.0.6
	rel-6-1-DP:11.30
	windows-branch:11.30.0.4
	rel-6-0-2:11.28
	ansi-branch:11.30.0.2
	rel-6-0-1-branch:11.28.0.2
	hartley-6-0-post:11.29
	hartley-6-0-pre:11.28
	rel-6-0-1:11.28
	rel-6-0:11.28
	rel-5-4:11.18
	offsite-5-3-pre:11.21
	rel-5-3:11.18
	rel-5-2:11.18
	rel-5-1-branch:11.18.0.2
	rel-5-1:11.18
	rel-5-0:11.16
	rel-5-0-beta:11.16
	rel-4-5:11.14
	ctj-4-5-post:11.11
	ctj-4-5-pre:11.11
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1
	rt:1.1;
locks; strict;
comment	@ * @;


11.34
date	2004.05.21.18.06.22;	author morrison;	state dead;
branches;
next	11.33;

11.33
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.32;

11.32
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2004.02.02.17.39.06;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2002.08.20.17.07.36;	author jra;	state Exp;
branches
	11.30.2.1
	11.30.4.1
	11.30.10.1;
next	11.29;

11.29
date	2002.08.15.20.54.48;	author hartley;	state Exp;
branches;
next	11.28;

11.28
date	2002.03.01.13.41.58;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	2002.02.28.01.01.48;	author butler;	state Exp;
branches;
next	11.26;

11.26
date	2001.06.01.17.39.36;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	2001.05.02.17.02.28;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	2001.04.05.19.35.27;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2001.04.02.21.37.57;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.03.31.01.56.48;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.07.05.47.28;	author cjohnson;	state Exp;
branches;
next	11.20;

11.20
date	2000.06.30.21.00.02;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	2000.06.30.20.07.00;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	2000.03.29.17.46.55;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.03.28.21.58.30;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.02.18.15.34.51;	author pjt;	state Exp;
branches;
next	11.15;

11.15
date	98.05.20.13.39.07;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.12.23.09.03.30;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.12.18.06.47.22;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.11.25.16.02.53;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.04.25.02.34.14;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	97.02.01.02.01.31;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.12.31.00.20.08;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.09.13.04.27.35;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.09.10.20.00.57;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.07.04.02.27.52;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.07.02.05.47.13;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.06.06.00.41.48;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.04.24.22.16.18;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.07.10.20.35.42;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.18;	author mike;	state Rel4_4;
branches;
next	10.18;

10.18
date	94.10.19.15.21.22;	author jra;	state Exp;
branches;
next	10.17;

10.17
date	94.10.18.11.24.15;	author jra;	state Exp;
branches;
next	10.16;

10.16
date	94.08.10.20.40.43;	author gdurf;	state Exp;
branches;
next	10.15;

10.15
date	94.08.04.22.32.27;	author gdurf;	state Exp;
branches;
next	10.14;

10.14
date	94.05.06.00.37.48;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.04.20.00.08.04;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.03.10.17.33.54;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.03.02.21.16.40;	author cjohnson;	state Exp;
branches;
next	10.10;

10.10
date	94.01.11.19.08.04;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	93.07.20.16.59.56;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.07.20.15.56.04;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.03.16.00.56.19;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.03.16.00.53.52;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.01.23.04.32.56;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.01.23.04.11.25;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.04.03.21.39.14;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.25.00.00.36;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.35;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.09.21.03.01.04;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.06.30.00.05.20;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.06.13.01.34.25;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.06.04.19.28.14;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.06.05.00.41.45;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.04.24.01.36.28;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.01.02.08.03.47;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.45;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.10.20.52.54;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.10.19.20.05;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.02.23.20.43.00;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.01.09.04.13.01;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.23;	author mike;	state Rel3_0;
branches;
next	7.6;

7.6
date	88.05.13.21.59.54;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.02.19.19.29.29;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.02.06.05.15.29;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.05.02.32.18;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.06.29.57;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.38;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.10.21.00.24.57;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.55.56;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.11.40;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.05.30.06.38.20;	author phil;	state Exp;
branches;
next	4.3;

4.3
date	87.05.28.23.17.29;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.11.24;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.20;	author mike;	state Rel1;
branches;
next	3.2;

3.2
date	86.08.12.04.15.46;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.08;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.11;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.05.10;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	85.07.30.05.52.45;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	85.03.25.11.45.48;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.11.23.20.54.11;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.11.22.09.07.03;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.11.20.20.14.29;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.05.04.09.14.23;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.05.01.06.39.45;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.04.26.05.37.39;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.04.18.02.20.21;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.04.02.19.57.18;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.02.16.42.06;	author mike;	state Exp;
branches;
next	;

11.30.2.1
date	2002.09.19.18.01.08;	author morrison;	state Exp;
branches;
next	11.30.2.2;

11.30.2.2
date	2004.03.17.21.16.47;	author morrison;	state Exp;
branches;
next	;

11.30.4.1
date	2004.03.11.23.41.43;	author morrison;	state Exp;
branches;
next	;

11.30.10.1
date	2004.02.12.18.39.33;	author erikg;	state Exp;
branches;
next	11.30.10.2;

11.30.10.2
date	2004.03.15.14.06.15;	author erikg;	state Exp;
branches;
next	;


desc
@Matrix Math
@


11.34
log
@moved to src/
@
text
@/*
 *			M A T . C
 *
 * 4 x 4 Matrix manipulation functions..............
 *
 *	bn_atan2()			Wrapper for library atan2()
 *(deprecated) bn_mat_zero( &m )		Fill matrix m with zeros
 *(deprecated) bn_mat_idn( &m )		Fill matrix m with identity matrix
 *(deprecated) bn_mat_copy( &o, &i )		Copy matrix i to matrix o
 *	bn_mat_mul( &o, &i1, &i2 )	Multiply i1 by i2 and store in o
 *	bn_mat_mul2( &i, &o )
 *	bn_matXvec( &ov, &m, &iv )	Multiply m by vector iv, store in ov
 *	bn_mat_inv( &om, &im )		Invert matrix im, store result in om
 *	bn_mat_print( &title, &m )	Print matrix (with title) on stderr.
 *	bn_mat_trn( &o, &i )		Transpose matrix i into matrix o
 *	bn_mat_ae( &o, azimuth, elev)	Make rot matrix from azimuth+elevation
 *	bn_ae_vec( &az, &el, v )	Find az/elev from dir vector
 *	bn_aet_vec( &az, &el, &twist, v1, v2 ) Find az,el,twist from two vectors
 *	bn_mat_angles( &o, alpha, beta, gama )	Make rot matrix from angles
 *	bn_eigen2x2()			Eigen values and vectors
 *	bn_mat_lookat			Make rot mat:  xform from D to -Z
 *	bn_mat_fromto			Make rot mat:  xform from A to
 *	bn_mat_arb_rot( &m, pt, dir, ang)	Make rot mat about axis (pt,dir), through ang
 *	bn_mat_is_equal()		Is mat a equal to mat b?
 *
 *
 * Matrix array elements have the following positions in the matrix:
 *
 *				|  0  1  2  3 |		| 0 |
 *	  [ 0 1 2 3 ]		|  4  5  6  7 |		| 1 |
 *				|  8  9 10 11 |		| 2 |
 *				| 12 13 14 15 |		| 3 |
 *
 *
 *     preVector (vect_t)	 Matrix (mat_t)    postVector (vect_t)
 *
 *  Authors -
 *	Robert S. Miles
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char bn_RCSmat[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/mat.c,v 11.33 2004/05/10 15:30:43 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif 

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"

const mat_t	bn_mat_identity = {
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0
};

void
bn_mat_print_guts(const char	*title,
		  const mat_t	m,
		  char		*obuf)
{
	register int	i;
	register char	*cp;

	sprintf(obuf, "MATRIX %s:\n  ", title);
	cp = obuf+strlen(obuf);
	if (!m) {
		strcat(obuf, "(Identity)");
	} else {
		for (i=0; i<16; i++)  {
			sprintf(cp, " %8.3f", m[i]);
			cp += strlen(cp);
			if (i == 15) {
				break;
			} else if((i&3) == 3) {
				*cp++ = '\n';
				*cp++ = ' ';
				*cp++ = ' ';
			}
		}
		*cp++ = '\0';
	}
}

/*
 *			B N _ M A T _ P R I N T
 */
void
bn_mat_print(const char		*title,
	     const mat_t	m)
{
	char		obuf[1024];	/* sprintf may be non-PARALLEL */

	bn_mat_print_guts(title, m, obuf);
	bu_log("%s\n", obuf);
}

/*
 *			B N _ A T A N 2
 *
 *  A wrapper for the system atan2().  On the Silicon Graphics,
 *  and perhaps on others, x==0 incorrectly returns infinity.
 */
double
bn_atan2(double y, double x)
{
	if( x > -1.0e-20 && x < 1.0e-20 )  {
		/* X is equal to zero, check Y */
		if( y < -1.0e-20 )  return( -3.14159265358979323/2 );
		if( y >  1.0e-20 )  return(  3.14159265358979323/2 );
		return(0.0);
	}
	return( atan2( y, x ) );
}

#if 0  /********* Deprecated for macros that call memcpy() *********/

/*
 *			B N _ M A T _ Z E R O
 *
 * Fill in the matrix "m" with zeros.
 */
void
bn_mat_zero( m )
mat_t	m;
{
	register int i = 0;
	register matp_t mp = m;

	bu_log("libbn/mat.c:  bn_mat_zero() is deprecated, use MAT_ZERO()\n");
	/* Clear everything */
	for(; i<16; i++)
		*mp++ = 0.0;
}



/*
 *			B N _ M A T _ I D N
 *
 * Fill in the matrix "m" with an identity matrix.
 */
void
bn_mat_idn( m )
register mat_t	m;
{
	bu_log("libbn/mat.c:  bn_mat_idn() is deprecated, use MAT_IDN()\n");
	memcpy(m, bn_mat_identity, sizeof(m));
}

/*
 *			B N _ M A T _ C O P Y
 * Copy the matrix
 */
void
bn_mat_copy( dest, src )
register mat_t		dest;
register const mat_t	src;
{
	register int i;

	/* Copy all elements */
#	include "noalias.h"
	bu_log("libbn/mat.c:  bn_mat_copy() is deprecated, use MAT_COPY()\n");
	for( i=15; i>=0; i--)
		dest[i] = src[i];
}

#endif	/******************* deprecated *******************/

/*
 *			B N _ M A T _ M U L
 *
 * Multiply matrix "a" by "b" and store the result in "o".
 * NOTE:  This is different from multiplying "b" by "a"
 * (most of the time!)
 * NOTE: "o" must not be the same as either of the inputs.
 */
void
bn_mat_mul(register fastf_t *o, register const fastf_t *a, register const fastf_t *b)
{
	o[ 0] = a[ 0]*b[ 0] + a[ 1]*b[ 4] + a[ 2]*b[ 8] + a[ 3]*b[12];
	o[ 1] = a[ 0]*b[ 1] + a[ 1]*b[ 5] + a[ 2]*b[ 9] + a[ 3]*b[13];
	o[ 2] = a[ 0]*b[ 2] + a[ 1]*b[ 6] + a[ 2]*b[10] + a[ 3]*b[14];
	o[ 3] = a[ 0]*b[ 3] + a[ 1]*b[ 7] + a[ 2]*b[11] + a[ 3]*b[15];

	o[ 4] = a[ 4]*b[ 0] + a[ 5]*b[ 4] + a[ 6]*b[ 8] + a[ 7]*b[12];
	o[ 5] = a[ 4]*b[ 1] + a[ 5]*b[ 5] + a[ 6]*b[ 9] + a[ 7]*b[13];
	o[ 6] = a[ 4]*b[ 2] + a[ 5]*b[ 6] + a[ 6]*b[10] + a[ 7]*b[14];
	o[ 7] = a[ 4]*b[ 3] + a[ 5]*b[ 7] + a[ 6]*b[11] + a[ 7]*b[15];

	o[ 8] = a[ 8]*b[ 0] + a[ 9]*b[ 4] + a[10]*b[ 8] + a[11]*b[12];
	o[ 9] = a[ 8]*b[ 1] + a[ 9]*b[ 5] + a[10]*b[ 9] + a[11]*b[13];
	o[10] = a[ 8]*b[ 2] + a[ 9]*b[ 6] + a[10]*b[10] + a[11]*b[14];
	o[11] = a[ 8]*b[ 3] + a[ 9]*b[ 7] + a[10]*b[11] + a[11]*b[15];

	o[12] = a[12]*b[ 0] + a[13]*b[ 4] + a[14]*b[ 8] + a[15]*b[12];
	o[13] = a[12]*b[ 1] + a[13]*b[ 5] + a[14]*b[ 9] + a[15]*b[13];
	o[14] = a[12]*b[ 2] + a[13]*b[ 6] + a[14]*b[10] + a[15]*b[14];
	o[15] = a[12]*b[ 3] + a[13]*b[ 7] + a[14]*b[11] + a[15]*b[15];
}

/*
 *			B N _ M A T _ M U L 2
 *
 *  o = i * o
 *
 *  A convenience wrapper for bn_mat_mul() to update a matrix in place.
 *  The arugment ordering is confusing either way.
 */
void
bn_mat_mul2(register const fastf_t *i, register fastf_t *o)
{
	mat_t	temp;

	bn_mat_mul( temp, i, o );
	MAT_COPY( o, temp );
}

/*
 *			B N _ M A T _ M U L 3
 *
 *  o = a * b * c
 *
 *  The output matrix may be the same as 'b' or 'c', but may not be 'a'.
 */
void
bn_mat_mul3(fastf_t *o, const fastf_t *a, const fastf_t *b, const fastf_t *c)
{
	mat_t	t;

	bn_mat_mul( t, b, c );
	bn_mat_mul( o, a, t );
}

/*
 *			B N _ M A T _ M U L 4
 *
 *  o = a * b * c * d
 *
 *  The output matrix may be the same as any input matrix.
 */
void
bn_mat_mul4(fastf_t *o, const fastf_t *a, const fastf_t *b, const fastf_t *c, const fastf_t *d)
{
	mat_t	t, u;

	bn_mat_mul( u, c, d );
	bn_mat_mul( t, a, b );
	bn_mat_mul( o, t, u );
}

/*
 *			B N _ M A T X V E C
 *
 * Multiply the matrix "im" by the vector "iv" and store the result
 * in the vector "ov".  Note this is post-multiply, and
 * operates on 4-tuples.  Use MAT4X3VEC() to operate on 3-tuples.
 */
void
bn_matXvec(register fastf_t *ov, register const fastf_t *im, register const fastf_t *iv)
{
	register int eo = 0;		/* Position in output vector */
	register int em = 0;		/* Position in input matrix */
	register int ei;		/* Position in input vector */

	/* For each element in the output array... */
	for(; eo<4; eo++) {

		ov[eo] = 0;		/* Start with zero in output */

		for(ei=0; ei<4; ei++)
			ov[eo] += im[em++] * iv[ei];
	}
}


/*
 *			B N _ M A T _ I N V
 *
 * The matrix pointed at by "im" is inverted and stored in the area
 * pointed at by "om".
 */
/* 
 * Invert a 4-by-4 matrix using Algorithm 120 from ACM.
 * This is a modified Gauss-Jordan alogorithm
 * Note:  Inversion is done in place, with 3 work vectors
 */
void
bn_mat_inv(register fastf_t *output, const fastf_t *input)
{
	register int i, j;			/* Indices */
	LOCAL int k;				/* Indices */
	LOCAL int	z[4];			/* Temporary */
	LOCAL fastf_t	b[4];			/* Temporary */
	LOCAL fastf_t	c[4];			/* Temporary */
	
	MAT_COPY( output, input );	/* Duplicate */

        /* Initialization */
	for( j = 0; j < 4; j++ )
		z[j] = j;

	/* Main Loop */
	for( i = 0; i < 4; i++ )  {
		FAST fastf_t y;				/* local temporary */

		k = i;
		y = output[i*4+i];
		for( j = i+1; j < 4; j++ )  {
			FAST fastf_t w;			/* local temporary */

			w = output[i*4+j];
			if( fabs(w) > fabs(y) )  {
				k = j;
				y = w;
			}
		}

		if( fabs(y) < SQRT_SMALL_FASTF )  {
			bu_log("bn_mat_inv:  error! fabs(y)=%g\n", fabs(y));
			bn_mat_print("singular matrix", input);
			bu_bomb("bn_mat_inv: singular matrix\n");
			/* NOTREACHED */
		}
		y = 1.0 / y;

		for( j = 0; j < 4; j++ )  {
			FAST fastf_t temp;		/* Local */

			c[j] = output[j*4+k];
			output[j*4+k] = output[j*4+i];
			output[j*4+i] = - c[j] * y;
			temp = output[i*4+j] * y;
			b[j] = temp;
			output[i*4+j] = temp;
		}

		output[i*4+i] = y;
		j = z[i];
		z[i] = z[k];
		z[k] = j;
		for( k = 0; k < 4; k++ )  {
			if( k == i )  continue;
			for( j = 0; j < 4; j++ )  {
				if( j == i )  continue;
				output[k*4+j] = output[k*4+j] - b[j] * c[k];
			}
		}
	}

	/*  Second Loop */
	for( i = 0; i < 4; i++ )  {
		while( (k = z[i]) != i )  {
			LOCAL int p;			/* Local temp */

			for( j = 0; j < 4; j++ )  {
				FAST fastf_t w;		/* Local temp */

				w = output[i*4+j];
				output[i*4+j] = output[k*4+j];
				output[k*4+j] = w;
			}
			p = z[i];
			z[i] = z[k];
			z[k] = p;
		}
	}
}

/*
 *			B N _ V T O H _ M O V E
 *
 * Takes a pointer to a [x,y,z] vector, and a pointer
 * to space for a homogeneous vector [x,y,z,w],
 * and builds [x,y,z,1].
 */
void
bn_vtoh_move(register fastf_t *h, register const fastf_t *v)
{
	h[X] = v[X];
	h[Y] = v[Y];
	h[Z] = v[Z];
	h[W] = 1.0;
}

/*
 *			B N _ H T O V _ M O V E
 *
 * Takes a pointer to [x,y,z,w], and converts it to
 * an ordinary vector [x/w, y/w, z/w].
 * Optimization for the case of w==1 is performed.
 */
void
bn_htov_move(register fastf_t *v, register const fastf_t *h)
{
	register fastf_t inv;

	if( h[3] == 1.0 )  {
		v[X] = h[X];
		v[Y] = h[Y];
		v[Z] = h[Z];
	}  else  {
		if( h[W] == SMALL_FASTF )  {
			bu_log("bn_htov_move: divide by %f!\n", h[W]);
			return;
		}
		inv = 1.0 / h[W];
		v[X] = h[X] * inv;
		v[Y] = h[Y] * inv;
		v[Z] = h[Z] * inv;
	}
}


/*
 *			B N _ M A T _ T R N
 */
void
bn_mat_trn(fastf_t *om, register const fastf_t *im)
{
	register matp_t op = om;

	*op++ = im[0];
	*op++ = im[4];
	*op++ = im[8];
	*op++ = im[12];

	*op++ = im[1];
	*op++ = im[5];
	*op++ = im[9];
	*op++ = im[13];

	*op++ = im[2];
	*op++ = im[6];
	*op++ = im[10];
	*op++ = im[14];

	*op++ = im[3];
	*op++ = im[7];
	*op++ = im[11];
	*op++ = im[15];
}

/*
 *			B N _ M A T _ A E
 *
 *  Compute a 4x4 rotation matrix given Azimuth and Elevation.
 *  
 *  Azimuth is +X, Elevation is +Z, both in degrees.
 *
 *  Formula due to Doug Gwyn, BRL.
 */
void
bn_mat_ae(register fastf_t *m, double azimuth, double elev)
{
	LOCAL double sin_az, sin_el;
	LOCAL double cos_az, cos_el;

	azimuth *= bn_degtorad;
	elev *= bn_degtorad;

	sin_az = sin(azimuth);
	cos_az = cos(azimuth);
	sin_el = sin(elev);
	cos_el = cos(elev);

	m[0] = cos_el * cos_az;
	m[1] = -sin_az;
	m[2] = -sin_el * cos_az;
	m[3] = 0;

	m[4] = cos_el * sin_az;
	m[5] = cos_az;
	m[6] = -sin_el * sin_az;
	m[7] = 0;

	m[8] = sin_el;
	m[9] = 0;
	m[10] = cos_el;
	m[11] = 0;

	m[12] = m[13] = m[14] = 0;
	m[15] = 1.0;
}

/*
 *			B N _ A E _ V E C
 *
 *  Find the azimuth and elevation angles that correspond to the
 *  direction (not including twist) given by a direction vector.
 */
void
bn_ae_vec(fastf_t *azp, fastf_t *elp, const fastf_t *v)
{
	register fastf_t	az;

	if( (az = bn_atan2( v[Y], v[X] ) * bn_radtodeg) < 0 )  {
		*azp = 360 + az;
	} else if( az >= 360 ) {
		*azp = az - 360;
	} else {
		*azp = az;
	}
	*elp = bn_atan2( v[Z], hypot( v[X], v[Y] ) ) * bn_radtodeg;
}

/*			B N _ A E T _ V E C
 *
 * Find the azimuth, elevation, and twist from two vectors.
 * Vec_ae is in the direction of view (+z in mged view)
 * and vec_twist points to the viewers right (+x in mged view).
 * Accuracy (degrees) is used to stabilze flutter between
 * equivalent extremes of atan2(), and to snap twist to zero
 * when elevation is near +/- 90
 */
void
bn_aet_vec(fastf_t *az, fastf_t *el, fastf_t *twist, fastf_t *vec_ae, fastf_t *vec_twist, fastf_t accuracy)
{
	vect_t zero_twist,ninety_twist;
	vect_t z_dir;

	/* Get az and el as usual */
	bn_ae_vec( az , el , vec_ae );

	/* stabilize fluctuation bewteen 0 and 360
	 * change azimuth near 360 to 0 */
	if( NEAR_ZERO( *az - 360.0 , accuracy ) )
		*az = 0.0;

	/* if elevation is +/-90 set twist to zero and calculate azimuth */
	if( NEAR_ZERO( *el - 90.0 , accuracy ) || NEAR_ZERO( *el + 90.0 , accuracy ) )
	{
		*twist = 0.0;
		*az = bn_atan2( -vec_twist[X] , vec_twist[Y] ) * bn_radtodeg;
	}
	else
	{
		/* Calculate twist from vec_twist */
		VSET( z_dir , 0 , 0 , 1 );
		VCROSS( zero_twist , z_dir , vec_ae );
		VUNITIZE( zero_twist );
		VCROSS( ninety_twist , vec_ae , zero_twist );
		VUNITIZE( ninety_twist );

		*twist = bn_atan2( VDOT( vec_twist , ninety_twist ) , VDOT( vec_twist , zero_twist ) ) * bn_radtodeg;

		/* stabilize flutter between +/- 180 */
		if( NEAR_ZERO( *twist + 180.0 , accuracy ) )
			*twist = 180.0;
	}
}


/*
 *			B N _ M A T _ A N G L E S
 *
 * This routine builds a Homogeneous rotation matrix, given
 * alpha, beta, and gamma as angles of rotation, in degrees.
 *
 * Alpha is angle of rotation about the X axis, and is done third.
 * Beta is angle of rotation about the Y axis, and is done second.
 * Gamma is angle of rotation about Z axis, and is done first.
 */
void
bn_mat_angles(register fastf_t *mat, double alpha_in, double beta_in, double ggamma_in)
{
	LOCAL double alpha, beta, ggamma;
	LOCAL double calpha, cbeta, cgamma;
	LOCAL double salpha, sbeta, sgamma;

	if( alpha_in == 0.0 && beta_in == 0.0 && ggamma_in == 0.0 )  {
		MAT_IDN( mat );
		return;
	}

	alpha = alpha_in * bn_degtorad;
	beta = beta_in * bn_degtorad;
	ggamma = ggamma_in * bn_degtorad;

	calpha = cos( alpha );
	cbeta = cos( beta );
	cgamma = cos( ggamma );

	/* sine of "180*bn_degtorad" will not be exactly zero
	 * and will result in errors when some codes try to
	 * convert this back to azimuth and elevation.
	 * do_frame() uses this technique!!!
	 */
	if( alpha_in == 180.0 )
		salpha = 0.0;
	else
		salpha = sin( alpha );

	if( beta_in == 180.0 )
		sbeta = 0.0;
	else
		sbeta = sin( beta );

	if( ggamma_in == 180.0 )
		sgamma = 0.0;
	else
		sgamma = sin( ggamma );

	mat[0] = cbeta * cgamma;
	mat[1] = -cbeta * sgamma;
	mat[2] = sbeta;
	mat[3] = 0.0;

	mat[4] = salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = -salpha * sbeta * sgamma + calpha * cgamma;
	mat[6] = -salpha * cbeta;
	mat[7] = 0.0;

	mat[8] = salpha * sgamma - calpha * sbeta * cgamma;
	mat[9] = salpha * cgamma + calpha * sbeta * sgamma;
	mat[10] = calpha * cbeta;
	mat[11] = 0.0;
	mat[12] = mat[13] = mat[14] = 0.0;
	mat[15] = 1.0;
}

/*
 *			B N _ M A T _ A N G L E S _ R A D
 *
 * This routine builds a Homogeneous rotation matrix, given
 * alpha, beta, and gamma as angles of rotation, in radians.
 *
 * Alpha is angle of rotation about the X axis, and is done third.
 * Beta is angle of rotation about the Y axis, and is done second.
 * Gamma is angle of rotation about Z axis, and is done first.
 */
void
bn_mat_angles_rad(register mat_t	mat,
		  double		alpha,
		  double		beta,
		  double		ggamma)
{
	LOCAL double calpha, cbeta, cgamma;
	LOCAL double salpha, sbeta, sgamma;

	if (alpha == 0.0 && beta == 0.0 && ggamma == 0.0) {
		MAT_IDN( mat );
		return;
	}

	calpha = cos( alpha );
	cbeta = cos( beta );
	cgamma = cos( ggamma );

	salpha = sin( alpha );
	sbeta = sin( beta );
	sgamma = sin( ggamma );

	mat[0] = cbeta * cgamma;
	mat[1] = -cbeta * sgamma;
	mat[2] = sbeta;
	mat[3] = 0.0;

	mat[4] = salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = -salpha * sbeta * sgamma + calpha * cgamma;
	mat[6] = -salpha * cbeta;
	mat[7] = 0.0;

	mat[8] = salpha * sgamma - calpha * sbeta * cgamma;
	mat[9] = salpha * cgamma + calpha * sbeta * sgamma;
	mat[10] = calpha * cbeta;
	mat[11] = 0.0;
	mat[12] = mat[13] = mat[14] = 0.0;
	mat[15] = 1.0;
}

/*
 *			B N _ E I G E N 2 X 2
 *
 *  Find the eigenvalues and eigenvectors of a
 *  symmetric 2x2 matrix.
 *	( a b )
 *	( b c )
 *
 *  The eigenvalue with the smallest absolute value is
 *  returned in val1, with its eigenvector in vec1.
 */
void
bn_eigen2x2(fastf_t *val1, fastf_t *val2, fastf_t *vec1, fastf_t *vec2, fastf_t a, fastf_t b, fastf_t c)
{
	fastf_t	d, root;
	fastf_t	v1, v2;

	d = 0.5 * (c - a);

	/* Check for diagonal matrix */
	if( NEAR_ZERO(b, 1.0e-10) ) {
		/* smaller mag first */
		if( fabs(c) < fabs(a) ) {
			*val1 = c;
			VSET( vec1, 0.0, 1.0, 0.0 );
			*val2 = a;
			VSET( vec2, -1.0, 0.0, 0.0 );
		} else {
			*val1 = a;
			VSET( vec1, 1.0, 0.0, 0.0 );
			*val2 = c;
			VSET( vec2, 0.0, 1.0, 0.0 );
		}
		return;
	}

	root = sqrt( d*d + b*b );
	v1 = 0.5 * (c + a) - root;
	v2 = 0.5 * (c + a) + root;

	/* smaller mag first */
	if( fabs(v1) < fabs(v2) ) {
		*val1 = v1;
		*val2 = v2;
		VSET( vec1, b, d - root, 0.0 );
	} else {
		*val1 = v2;
		*val2 = v1;
		VSET( vec1, root - d, b, 0.0 );
	}
	VUNITIZE( vec1 );
	VSET( vec2, -vec1[Y], vec1[X], 0.0 );	/* vec1 X vec2 = +Z */
}

/*
 *			B N _ V E C _ P E R P
 *
 *  Given a vector, create another vector which is perpendicular to it.
 *  The output vector will have unit length only if the input vector did.
 */
void
bn_vec_perp(fastf_t *new, const fastf_t *old)
{
	register int i;
	LOCAL vect_t another;	/* Another vector, different */

	i = X;
	if( fabs(old[Y])<fabs(old[i]) )  i=Y;
	if( fabs(old[Z])<fabs(old[i]) )  i=Z;
	VSETALL( another, 0 );
	another[i] = 1.0;
	if( old[X] == 0 && old[Y] == 0 && old[Z] == 0 )  {
		VMOVE( new, another );
	} else {
		VCROSS( new, another, old );
	}
}

/*
 *			B N _ M A T _ F R O M T O
 *
 *  Given two vectors, compute a rotation matrix that will transform
 *  space by the angle between the two.  There are many
 *  candidate matricies.
 *
 *  The input 'from' and 'to' vectors need not be unit length.
 *  MAT4X3VEC( to, m, from ) is the identity that is created.
 */
void
bn_mat_fromto(fastf_t *m, const fastf_t *from, const fastf_t *to)
{
	vect_t	test_to;
	vect_t	unit_from, unit_to;
	fastf_t	dot;

	/*
	 *  The method used here is from Graphics Gems, A. Glasner, ed.
	 *  page 531, "The Use of Coordinate Frames in Computer Graphics",
	 *  by Ken Turkowski, Example 6.
	 */
	mat_t	Q, Qt;
	mat_t	R;
	mat_t	A;
	mat_t	temp;
	vect_t	N, M;
	vect_t	w_prime;		/* image of "to" ("w") in Qt */

	VMOVE( unit_from, from );
	VUNITIZE( unit_from );		/* aka "v" */
	VMOVE( unit_to, to );
	VUNITIZE( unit_to );		/* aka "w" */

	/*  If from and to are the same or opposite, special handling
	 *  is needed, because the cross product isn't defined.
	 *  asin(0.00001) = 0.0005729 degrees (1/2000 degree)
	 */
	dot = VDOT(unit_from, unit_to);
	if( dot > 1.0-0.00001 )  {
		/* dot == 1, return identity matrix */
		MAT_IDN(m);
		return;
	}
	if( dot < -1.0+0.00001 )  {
		/* dot == -1, select random perpendicular N vector */
		bn_vec_perp( N, unit_from );
	} else {
		VCROSS( N, unit_from, unit_to );
		VUNITIZE( N );			/* should be unnecessary */
	}
	VCROSS( M, N, unit_from );
	VUNITIZE( M );			/* should be unnecessary */

	/* Almost everything here is done with pre-multiplys:  vector * mat */
	MAT_IDN( Q );
	VMOVE( &Q[0], unit_from );
	VMOVE( &Q[4], M );
	VMOVE( &Q[8], N );
	bn_mat_trn( Qt, Q );

	/* w_prime = w * Qt */
	MAT4X3VEC( w_prime, Q, unit_to );	/* post-multiply by transpose */

	MAT_IDN( R );
	VMOVE( &R[0], w_prime );
	VSET( &R[4], -w_prime[Y], w_prime[X], w_prime[Z] );
	VSET( &R[8], 0, 0, 1 );		/* is unnecessary */

	bn_mat_mul( temp, R, Q );
	bn_mat_mul( A, Qt, temp );
	bn_mat_trn( m, A );		/* back to post-multiply style */

	/* Verify that it worked */
	MAT4X3VEC( test_to, m, unit_from );
	dot = VDOT( unit_to, test_to );
	if( dot < 0.98 || dot > 1.02 )  {
		bu_log("bn_mat_fromto() ERROR!  from (%g,%g,%g) to (%g,%g,%g) went to (%g,%g,%g), dot=%g?\n",
			V3ARGS(from),
			V3ARGS(to),
			V3ARGS( test_to ), dot );
	}
}

/*
 *			B N _ M A T _ X R O T
 *
 *  Given the sin and cos of an X rotation angle, produce the rotation matrix.
 */
void
bn_mat_xrot(fastf_t *m, double sinx, double cosx)
{
	m[0] = 1.0;
	m[1] = 0.0;
	m[2] = 0.0;
	m[3] = 0.0;

	m[4] = 0.0;
	m[5] = cosx;
	m[6] = -sinx;
	m[7] = 0.0;

	m[8] = 0.0;
	m[9] = sinx;
	m[10] = cosx;
	m[11] = 0.0;

	m[12] = m[13] = m[14] = 0.0;
	m[15] = 1.0;
}

/*
 *			B N _ M A T _ Y R O T
 *
 *  Given the sin and cos of a Y rotation angle, produce the rotation matrix.
 */
void
bn_mat_yrot(fastf_t *m, double siny, double cosy)
{
	m[0] = cosy;
	m[1] = 0.0;
	m[2] = -siny;
	m[3] = 0.0;

	m[4] = 0.0;
	m[5] = 1.0;
	m[6] = 0.0;
	m[7] = 0.0;

	m[8] = siny;
	m[9] = 0.0;
	m[10] = cosy;

	m[11] = 0.0;
	m[12] = m[13] = m[14] = 0.0;
	m[15] = 1.0;
}

/*
 *			B N _ M A T _ Z R O T
 *
 *  Given the sin and cos of a Z rotation angle, produce the rotation matrix.
 */
void
bn_mat_zrot(fastf_t *m, double sinz, double cosz)
{
	m[0] = cosz;
	m[1] = -sinz;
	m[2] = 0.0;
	m[3] = 0.0;

	m[4] = sinz;
	m[5] = cosz;
	m[6] = 0.0;
	m[7] = 0.0;

	m[8] = 0.0;
	m[9] = 0.0;
	m[10] = 1.0;
	m[11] = 0.0;

	m[12] = m[13] = m[14] = 0.0;
	m[15] = 1.0;
}


/*
 *			B N _ M A T _ L O O K A T
 *
 *  Given a direction vector D of unit length,
 *  product a matrix which rotates that vector D onto the -Z axis.
 *  This matrix will be suitable for use as a "model2view" matrix.
 *
 *  XXX This routine will fail if the vector is already more or less aligned
 *  with the Z axis.
 *
 *  This is done in several steps.
 *	1)  Rotate D about Z to match +X axis.  Azimuth adjustment.
 *	2)  Rotate D about Y to match -Y axis.  Elevation adjustment.
 *	3)  Rotate D about Z to make projection of X axis again point
 *	    in the +X direction.  Twist adjustment.
 *	4)  Optionally, flip sign on Y axis if original Z becomes inverted.
 *	    This can be nice for static frames, but is astonishing when
 *	    used in animation.
 */
void
bn_mat_lookat(fastf_t *rot, const fastf_t *dir, int yflip)
{
	mat_t	first;
	mat_t	second;
	mat_t	prod12;
	mat_t	third;
	vect_t	x;
	vect_t	z;
	vect_t	t1;
	fastf_t	hypot_xy;
	vect_t	xproj;
	vect_t	zproj;

	/* First, rotate D around Z axis to match +X axis (azimuth) */
	hypot_xy = hypot( dir[X], dir[Y] );
	bn_mat_zrot( first, -dir[Y] / hypot_xy, dir[X] / hypot_xy );

	/* Next, rotate D around Y axis to match -Z axis (elevation) */
	bn_mat_yrot( second, -hypot_xy, -dir[Z] );
	bn_mat_mul( prod12, second, first );

	/* Produce twist correction, by re-orienting projection of X axis */
	VSET( x, 1, 0, 0 );
	MAT4X3VEC( xproj, prod12, x );
	hypot_xy = hypot( xproj[X], xproj[Y] );
	if( hypot_xy < 1.0e-10 )  {
		bu_log("Warning: bn_mat_lookat:  unable to twist correct, hypot=%g\n", hypot_xy);
		VPRINT( "xproj", xproj );
		MAT_COPY( rot, prod12 );
		return;
	}
	bn_mat_zrot( third, -xproj[Y] / hypot_xy, xproj[X] / hypot_xy );
	bn_mat_mul( rot, third, prod12 );

	if( yflip )  {
		VSET( z, 0, 0, 1 );
		MAT4X3VEC( zproj, rot, z );
		/* If original Z inverts sign, flip sign on resulting Y */
		if( zproj[Y] < 0.0 )  {
			MAT_COPY( prod12, rot );
			MAT_IDN( third );
			third[5] = -1;
			bn_mat_mul( rot, third, prod12 );
		}
	}

	/* Check the final results */
	MAT4X3VEC( t1, rot, dir );
	if( t1[Z] > -0.98 )  {
		bu_log("Error:  bn_mat_lookat final= (%g, %g, %g)\n", t1[X], t1[Y], t1[Z] );
	}
}

/*
 *			B N _ V E C _ O R T H O
 *
 *  Given a vector, create another vector which is perpendicular to it,
 *  and with unit length.  This algorithm taken from Gift's arvec.f;
 *  a faster algorithm may be possible.
 */
void
bn_vec_ortho(register fastf_t *out, register const fastf_t *in)
{
	register int j, k;
	FAST fastf_t	f;
	register int i;

	if( NEAR_ZERO(in[X], 0.0001) && NEAR_ZERO(in[Y], 0.0001) &&
	    NEAR_ZERO(in[Z], 0.0001) )  {
		VSETALL( out, 0 );
		VPRINT("bn_vec_ortho: zero-length input", in);
		return;
	}

	/* Find component closest to zero */
	f = fabs(in[X]);
	i = X;
	j = Y;
	k = Z;
	if( fabs(in[Y]) < f )  {
		f = fabs(in[Y]);
		i = Y;
		j = Z;
		k = X;
	}
	if( fabs(in[Z]) < f )  {
		i = Z;
		j = X;
		k = Y;
	}
	f = hypot( in[j], in[k] );
	if( NEAR_ZERO( f, SMALL ) ) {
		VPRINT("bn_vec_ortho: zero hypot on", in);
		VSETALL( out, 0 );
		return;
	}
	f = 1.0/f;
	out[i] = 0.0;
	out[j] = -in[k]*f;
	out[k] =  in[j]*f;
}


/*
 *			B N _ M A T _ S C A L E _ A B O U T _ P T
 *
 *  Build a matrix to scale uniformly around a given point.
 *
 *  Returns -
 *	-1	if scale is too small.
 *	 0	if OK.
 */
int
bn_mat_scale_about_pt(fastf_t *mat, const fastf_t *pt, const double scale)
{
	mat_t	xlate;
	mat_t	s;
	mat_t	tmp;

	MAT_IDN( xlate );
	MAT_DELTAS_VEC_NEG( xlate, pt );

	MAT_IDN( s );
	if( NEAR_ZERO( scale, SMALL ) )  {
		MAT_ZERO( mat );
		return -1;			/* ERROR */
	}
	s[15] = 1/scale;

	bn_mat_mul( tmp, s, xlate );

	MAT_DELTAS_VEC( xlate, pt );
	bn_mat_mul( mat, xlate, tmp );
	return 0;				/* OK */
}

/*
 *			B N _ M A T _ X F O R M _ A B O U T _ P T
 *
 *  Build a matrix to apply arbitary 4x4 transformation around a given point.
 */
void
bn_mat_xform_about_pt(fastf_t *mat, const fastf_t *xform, const fastf_t *pt)
{
	mat_t	xlate;
	mat_t	tmp;

	MAT_IDN( xlate );
	MAT_DELTAS_VEC_NEG( xlate, pt );

	bn_mat_mul( tmp, xform, xlate );

	MAT_DELTAS_VEC( xlate, pt );
	bn_mat_mul( mat, xlate, tmp );
}

/*
 *			B N _ M A T _ I S _ E Q U A L
 *
 *  Returns -
 *	0	When matrices are not equal
 *	1	When matricies are equal
 */
int
bn_mat_is_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
{
	register int i;
	register double f;
	register double tdist, tperp;

	BN_CK_TOL(tol);

	tdist = tol->dist;
	tperp = tol->perp;

	/*
	 * First, check that the translation part of the matrix (dist) are
	 * within the distance tolerance.
	 * Because most instancing involves translation and no rotation,
	 * doing this first should detect most non-equal cases rapidly.
	 */
	for (i=3; i<12; i+=4) {
		f = a[i] - b[i];
		if ( !NEAR_ZERO(f, tdist)) return 0;
	}

	/*
	 * Check that the rotation part of the matrix (cosines) are within
	 * the perpendicular tolerance.
	 */
	for (i = 0; i < 16; i+=4) {
		f = a[i] - b[i];
		if ( !NEAR_ZERO(f, tperp)) return 0;
		f = a[i+1] - b[i+1];
		if ( !NEAR_ZERO(f, tperp)) return 0;
		f = a[i+2] - b[i+2];
		if ( !NEAR_ZERO(f, tperp)) return 0;
	}
	/*
	 * Check that the scale part of the matrix (ratio) is within the
	 * perpendicular tolerance.  There is no ratio tolerance so we use
	 * the tighter of dist or perp.
	 */
	f = a[15] - b[15];
	if ( !NEAR_ZERO(f, tperp)) return 0;

	return 1;
}


/*
 *			B N _ M A T _ I S _ I D E N T I T Y
 *
 *  This routine is intended for detecting identity matricies read in
 *  from ascii or binary files, where the numbers are pure ones or zeros.
 *  This routine is *not* intended for tolerance-based "near-zero"
 *  comparisons; as such, it shouldn't be used on matrices which are
 *  the result of calculation.
 *
 *  Returns -
 *	0	non-identity
 *	1	a perfect identity matrix
 */
int
bn_mat_is_identity(const fastf_t *m)
{
	return (! memcmp(m, bn_mat_identity, sizeof(mat_t)));
}

/*	B N _ M A T _ A R B _ R O T
 *
 * Construct a transformation matrix for rotation about an arbitrary axis
 *
 *	The axis is defined by a point (pt) and a unit direction vector (dir).
 *	The angle of rotation is "ang"
 */
void
bn_mat_arb_rot(fastf_t *m, const fastf_t *pt, const fastf_t *dir, const fastf_t ang)
{
	mat_t tran1,tran2,rot;
	double cos_ang, sin_ang, one_m_cosang;
	double n1_sq, n2_sq, n3_sq;
	double n1_n2, n1_n3, n2_n3;

	if( ang == 0.0 )
	{
		MAT_IDN( m );
		return;
	}

	MAT_IDN( tran1 );
	MAT_IDN( tran2 );

	/* construct translation matrix to pt */
	tran1[MDX] = (-pt[X]);
	tran1[MDY] = (-pt[Y]);
	tran1[MDZ] = (-pt[Z]);

	/* construct translation back from pt */
	tran2[MDX] = pt[X];
	tran2[MDY] = pt[Y];
	tran2[MDZ] = pt[Z];

	/* construct rotation matrix */
	cos_ang = cos( ang );
	sin_ang = sin( ang );
	one_m_cosang = 1.0 - cos_ang;
	n1_sq = dir[X]*dir[X];
	n2_sq = dir[Y]*dir[Y];
	n3_sq = dir[Z]*dir[Z];
	n1_n2 = dir[X]*dir[Y];
	n1_n3 = dir[X]*dir[Z];
	n2_n3 = dir[Y]*dir[Z];

	MAT_IDN( rot );
	rot[0] = n1_sq + (1.0 - n1_sq)*cos_ang;
	rot[1] = n1_n2 * one_m_cosang - dir[Z]*sin_ang;
	rot[2] = n1_n3 * one_m_cosang + dir[Y]*sin_ang;

	rot[4] = n1_n2 * one_m_cosang + dir[Z]*sin_ang;
	rot[5] = n2_sq + (1.0 - n2_sq)*cos_ang;
	rot[6] = n2_n3 * one_m_cosang - dir[X]*sin_ang;

	rot[8] = n1_n3 * one_m_cosang - dir[Y]*sin_ang;
	rot[9] = n2_n3 * one_m_cosang + dir[X]*sin_ang;
	rot[10] = n3_sq + (1.0 - n3_sq) * cos_ang;

	bn_mat_mul( m, rot, tran1 );
	bn_mat_mul2( tran2, m );
}


/*
 *			B N _ M A T _ D U P
 *
 *  Return a pointer to a copy of the matrix in dynamically allocated memory.
 */
matp_t
bn_mat_dup(const fastf_t *in)
{
	matp_t	out;

	out = (matp_t) bu_malloc( sizeof(mat_t), "bn_mat_dup" );
	bcopy( (const char *)in, (char *)out, sizeof(mat_t) );
	return out;
}

/*
 *			B N _ M A T _ C K
 *
 *  Check to ensure that a rotation matrix preserves axis perpendicularily.
 *  Note that not all matricies are rotation matricies.
 *
 *  Returns -
 *	-1	FAIL
 *	 0	OK
 */
int
bn_mat_ck(const char *title, const fastf_t *m)
{
	vect_t	A, B, C;
	fastf_t	fx, fy, fz;

	if( !m )  return 0;		/* implies identity matrix */

	/*
	 * Validate that matrix preserves perpendicularity of axis
	 * by checking that A.B == 0, B.C == 0, A.C == 0
	 * XXX these vectors should just be grabbed out of the matrix
	 */
#if 0
	MAT4X3VEC( A, m, xaxis );
	MAT4X3VEC( B, m, yaxis );
	MAT4X3VEC( C, m, zaxis );
#else
	VMOVE( A, &m[0] );
	VMOVE( B, &m[4] );
	VMOVE( C, &m[8] );
#endif
	fx = VDOT( A, B );
	fy = VDOT( B, C );
	fz = VDOT( A, C );
	if( ! NEAR_ZERO(fx, 0.0001) ||
	    ! NEAR_ZERO(fy, 0.0001) ||
	    ! NEAR_ZERO(fz, 0.0001) ||
	    NEAR_ZERO( m[15], VDIVIDE_TOL )
	)  {
		bu_log("bn_mat_ck(%s):  bad matrix, does not preserve axis perpendicularity.\n  X.Y=%g, Y.Z=%g, X.Z=%g, s=%g\n",
			title, fx, fy, fz, m[15] );
		bn_mat_print("bn_mat_ck() bad matrix", m);

		if( bu_debug & (BU_DEBUG_MATH | BU_DEBUG_COREDUMP) )  {
			bu_debug |= BU_DEBUG_COREDUMP;
			bu_bomb("bn_mat_ck() bad matrix\n");
		}
	    	return -1;	/* FAIL */
	}
	return 0;		/* OK */
}

/*
 *		B N _ M A T _ D E T 3
 *
 *	Calculates the determinant of the 3X3 "rotation"
 *	part of the passed matrix
 */
fastf_t
bn_mat_det3(const fastf_t *m)
{
	FAST fastf_t sum;

	sum = m[0] * ( m[5]*m[10] - m[6]*m[9] )
	     -m[1] * ( m[4]*m[10] - m[6]*m[8] )
	     +m[2] * ( m[4]*m[9] - m[5]*m[8] );

	return( sum );
}


/*
 *		B N _ M A T _ D E T E R M I N A N T
 *
 *	Calculates the determinant of the 4X4 matrix
 */
fastf_t
bn_mat_determinant(const fastf_t *m)
{
	fastf_t det[4];
	fastf_t sum;

	det[0] = m[5] * (m[10]*m[15] - m[11]*m[14])
		-m[6] * (m[ 9]*m[15] - m[11]*m[13])
		+m[7] * (m[ 9]*m[14] - m[10]*m[13]);

	det[1] = m[4] * (m[10]*m[15] - m[11]*m[14])
		-m[6] * (m[ 8]*m[15] - m[11]*m[12])
		+m[7] * (m[ 8]*m[14] - m[10]*m[12]);

	det[2] = m[4] * (m[ 9]*m[15] - m[11]*m[13])
		-m[5] * (m[ 8]*m[15] - m[11]*m[12])
		+m[7] * (m[ 8]*m[13] - m[ 9]*m[12]);

	det[3] = m[4] * (m[ 9]*m[14] - m[10]*m[13])
		-m[5] * (m[ 8]*m[14] - m[10]*m[12])
		+m[6] * (m[ 8]*m[13] - m[ 9]*m[12]);

	sum = m[0]*det[0] - m[1]*det[1] + m[2]*det[2] - m[3]*det[3];

	return( sum );

}

int
bn_mat_is_non_unif(const mat_t m)
{
    double mag[3];

    mag[0] = MAGSQ(m);
    mag[1] = MAGSQ(&m[4]);
    mag[2] = MAGSQ(&m[8]);

    if (fabs(1.0 - (mag[1]/mag[0])) > .0005 ||
	fabs(1.0 - (mag[2]/mag[0])) > .0005) {

	return 1;
    }
    
    if (m[12] != 0.0 || m[13] != 0.0 || m[14] != 0.0)
	return 2;

    return 0;
}
@


11.33
log
@change conf.h to a wrapped config.h
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /cvs/brlcad/libbn/mat.c,v 11.32 2004/04/05 07:46:41 morrison Exp $ (ARL)";
@


11.32
log
@merge of ansi-6-0-branch into HEAD
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header$ (ARL)";
d59 5
a63 1
#include "conf.h"
@


11.31
log
@update copyright to include span through 2003
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.30 2002/08/20 17:07:36 jra Exp $ (ARL)";
d130 1
a130 2
bn_atan2(y,x)
double	y,x;
d205 1
a205 4
bn_mat_mul( o, a, b )
register mat_t		o;
register const mat_t	a;
register const mat_t	b;
d237 1
a237 3
bn_mat_mul2( i, o )
register const mat_t	i;
register mat_t		o;
d253 1
a253 5
bn_mat_mul3( o, a, b, c )
mat_t		o;
const mat_t	a;
const mat_t	b;
const mat_t	c;
d269 1
a269 6
bn_mat_mul4( o, a, b, c, d )
mat_t		o;
const mat_t	a;
const mat_t	b;
const mat_t	c;
const mat_t	d;
d286 1
a286 4
bn_matXvec(ov, im, iv)
register hvect_t ov;
register const mat_t im;
register const hvect_t iv;
d315 1
a315 3
bn_mat_inv( output, input )
register mat_t	output;
const mat_t	input;
d404 1
a404 3
bn_vtoh_move( h, v )
register vect_t		h;
register const vect_t	v;
d420 1
a420 3
bn_htov_move( v, h )
register vect_t		v;
register const vect_t	h;
d445 1
a445 3
bn_mat_trn( om, im )
mat_t			om;
register const mat_t	im;
d480 1
a480 4
bn_mat_ae( m, azimuth, elev )
register mat_t	m;
double		azimuth;
double		elev;
d519 1
a519 4
bn_ae_vec( azp, elp, v )
fastf_t		*azp;
fastf_t		*elp;
const vect_t	v;
d543 1
a543 4
bn_aet_vec( az , el , twist , vec_ae, vec_twist , accuracy )
fastf_t *az,*el,*twist;
vect_t vec_ae,vec_twist;
fastf_t accuracy;
d591 1
a591 3
bn_mat_angles( mat, alpha_in, beta_in, ggamma_in )
register mat_t	mat;
double alpha_in, beta_in, ggamma_in;
d710 1
a710 4
bn_eigen2x2( val1, val2, vec1, vec2, a, b, c )
fastf_t	*val1, *val2;
vect_t	vec1, vec2;
fastf_t	a, b, c;
d759 1
a759 3
bn_vec_perp( new, old )
vect_t		new;
const vect_t	old;
d787 1
a787 4
bn_mat_fromto( m, from, to )
mat_t		m;
const vect_t	from;
const vect_t	to;
d866 1
a866 3
bn_mat_xrot( m, sinx, cosx )
mat_t	m;
double	sinx, cosx;
d893 1
a893 3
bn_mat_yrot( m, siny, cosy )
mat_t	m;
double	siny, cosy;
d920 1
a920 3
bn_mat_zrot( m, sinz, cosz )
mat_t	m;
double	sinz, cosz;
d962 1
a962 4
bn_mat_lookat( rot, dir, yflip )
mat_t		rot;
const vect_t	dir;
int		yflip;
d1023 1
a1023 3
bn_vec_ortho( out, in )
register vect_t	out;
register const vect_t	in;
d1075 1
a1075 4
bn_mat_scale_about_pt( mat, pt, scale )
mat_t		mat;
const point_t	pt;
const double	scale;
d1104 1
a1104 4
bn_mat_xform_about_pt( mat, xform, pt )
mat_t		mat;
const mat_t	xform;
const point_t	pt;
d1126 1
a1126 4
bn_mat_is_equal(a, b, tol)
const mat_t	a;
const mat_t	b;
const struct bn_tol	*tol;
d1186 1
a1186 2
bn_mat_is_identity( m )
const mat_t	m;
d1199 1
a1199 5
bn_mat_arb_rot( m, pt, dir, ang)
mat_t m;
const point_t pt;
const vect_t dir;
const fastf_t ang;
d1260 1
a1260 2
bn_mat_dup( in )
const mat_t	in;
d1280 1
a1280 3
bn_mat_ck( title, m )
const char *title;
const mat_t m;
d1329 1
a1329 2
bn_mat_det3( m )
const mat_t m;
d1347 1
a1347 2
bn_mat_determinant( m )
const mat_t m;
@


11.30
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d52 1
a52 1
 *	This software is Copyright (C) 1996 by the United States Army
d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.28 2002/03/01 13:41:58 jra Exp $ (ARL)";
@


11.30.4.1
log
@sync to HEAD...
@
text
@d52 1
a52 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbn/mat.c,v 11.31 2004/02/02 17:39:06 morrison Exp $ (ARL)";
@


11.30.10.1
log
@merge from HEAD
@
text
@d52 1
a52 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.31 2004/02/02 17:39:06 morrison Exp $ (ARL)";
@


11.30.10.2
log
@merge from head
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.30.10.1 2004/02/12 18:39:33 erikg Exp $ (ARL)";
@


11.30.2.1
log
@Initial ANSIfication
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.30 2002/08/20 17:07:36 jra Exp $ (ARL)";
d130 2
a131 1
bn_atan2(double y, double x)
d206 4
a209 1
bn_mat_mul(register fastf_t *o, register const fastf_t *a, register const fastf_t *b)
d241 3
a243 1
bn_mat_mul2(register const fastf_t *i, register fastf_t *o)
d259 5
a263 1
bn_mat_mul3(fastf_t *o, const fastf_t *a, const fastf_t *b, const fastf_t *c)
d279 6
a284 1
bn_mat_mul4(fastf_t *o, const fastf_t *a, const fastf_t *b, const fastf_t *c, const fastf_t *d)
d301 4
a304 1
bn_matXvec(register fastf_t *ov, register const fastf_t *im, register const fastf_t *iv)
d333 3
a335 1
bn_mat_inv(register fastf_t *output, const fastf_t *input)
d424 3
a426 1
bn_vtoh_move(register fastf_t *h, register const fastf_t *v)
d442 3
a444 1
bn_htov_move(register fastf_t *v, register const fastf_t *h)
d469 3
a471 1
bn_mat_trn(fastf_t *om, register const fastf_t *im)
d506 4
a509 1
bn_mat_ae(register fastf_t *m, double azimuth, double elev)
d548 4
a551 1
bn_ae_vec(fastf_t *azp, fastf_t *elp, const fastf_t *v)
d575 4
a578 1
bn_aet_vec(fastf_t *az, fastf_t *el, fastf_t *twist, fastf_t *vec_ae, fastf_t *vec_twist, fastf_t accuracy)
d626 3
a628 1
bn_mat_angles(register fastf_t *mat, double alpha_in, double beta_in, double ggamma_in)
d747 4
a750 1
bn_eigen2x2(fastf_t *val1, fastf_t *val2, fastf_t *vec1, fastf_t *vec2, fastf_t a, fastf_t b, fastf_t c)
d799 3
a801 1
bn_vec_perp(fastf_t *new, const fastf_t *old)
d829 4
a832 1
bn_mat_fromto(fastf_t *m, const fastf_t *from, const fastf_t *to)
d911 3
a913 1
bn_mat_xrot(fastf_t *m, double sinx, double cosx)
d940 3
a942 1
bn_mat_yrot(fastf_t *m, double siny, double cosy)
d969 3
a971 1
bn_mat_zrot(fastf_t *m, double sinz, double cosz)
d1013 4
a1016 1
bn_mat_lookat(fastf_t *rot, const fastf_t *dir, int yflip)
d1077 3
a1079 1
bn_vec_ortho(register fastf_t *out, register const fastf_t *in)
d1131 4
a1134 1
bn_mat_scale_about_pt(fastf_t *mat, const fastf_t *pt, const double scale)
d1163 4
a1166 1
bn_mat_xform_about_pt(fastf_t *mat, const fastf_t *xform, const fastf_t *pt)
d1188 4
a1191 1
bn_mat_is_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d1251 2
a1252 1
bn_mat_is_identity(const fastf_t *m)
d1265 5
a1269 1
bn_mat_arb_rot(fastf_t *m, const fastf_t *pt, const fastf_t *dir, const fastf_t ang)
d1330 2
a1331 1
bn_mat_dup(const fastf_t *in)
d1351 3
a1353 1
bn_mat_ck(const char *title, const fastf_t *m)
d1402 2
a1403 1
bn_mat_det3(const fastf_t *m)
d1421 2
a1422 1
bn_mat_determinant(const fastf_t *m)
@


11.30.2.2
log
@sync branch with HEAD
@
text
@d52 1
a52 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header$ (ARL)";
@


11.29
log
@Converted from K&R to ANSI C - RFH
@
text
@d130 2
a131 1
bn_atan2(double y, double x)
d206 4
a209 1
bn_mat_mul(register fastf_t *o, register const fastf_t *a, register const fastf_t *b)
d241 3
a243 1
bn_mat_mul2(register const fastf_t *i, register fastf_t *o)
d259 5
a263 1
bn_mat_mul3(fastf_t *o, const fastf_t *a, const fastf_t *b, const fastf_t *c)
d279 6
a284 1
bn_mat_mul4(fastf_t *o, const fastf_t *a, const fastf_t *b, const fastf_t *c, const fastf_t *d)
d301 4
a304 1
bn_matXvec(register fastf_t *ov, register const fastf_t *im, register const fastf_t *iv)
d333 3
a335 1
bn_mat_inv(register fastf_t *output, const fastf_t *input)
d424 3
a426 1
bn_vtoh_move(register fastf_t *h, register const fastf_t *v)
d442 3
a444 1
bn_htov_move(register fastf_t *v, register const fastf_t *h)
d469 3
a471 1
bn_mat_trn(fastf_t *om, register const fastf_t *im)
d506 4
a509 1
bn_mat_ae(register fastf_t *m, double azimuth, double elev)
d548 4
a551 1
bn_ae_vec(fastf_t *azp, fastf_t *elp, const fastf_t *v)
d575 4
a578 1
bn_aet_vec(fastf_t *az, fastf_t *el, fastf_t *twist, fastf_t *vec_ae, fastf_t *vec_twist, fastf_t accuracy)
d626 3
a628 1
bn_mat_angles(register fastf_t *mat, double alpha_in, double beta_in, double ggamma_in)
d747 4
a750 1
bn_eigen2x2(fastf_t *val1, fastf_t *val2, fastf_t *vec1, fastf_t *vec2, fastf_t a, fastf_t b, fastf_t c)
d799 3
a801 1
bn_vec_perp(fastf_t *new, const fastf_t *old)
d829 4
a832 1
bn_mat_fromto(fastf_t *m, const fastf_t *from, const fastf_t *to)
d911 3
a913 1
bn_mat_xrot(fastf_t *m, double sinx, double cosx)
d940 3
a942 1
bn_mat_yrot(fastf_t *m, double siny, double cosy)
d969 3
a971 1
bn_mat_zrot(fastf_t *m, double sinz, double cosz)
d1013 4
a1016 1
bn_mat_lookat(fastf_t *rot, const fastf_t *dir, int yflip)
d1077 3
a1079 1
bn_vec_ortho(register fastf_t *out, register const fastf_t *in)
d1131 4
a1134 1
bn_mat_scale_about_pt(fastf_t *mat, const fastf_t *pt, const double scale)
d1163 4
a1166 1
bn_mat_xform_about_pt(fastf_t *mat, const fastf_t *xform, const fastf_t *pt)
d1188 4
a1191 1
bn_mat_is_equal(const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d1251 2
a1252 1
bn_mat_is_identity(const fastf_t *m)
d1265 5
a1269 1
bn_mat_arb_rot(fastf_t *m, const fastf_t *pt, const fastf_t *dir, const fastf_t ang)
d1330 2
a1331 1
bn_mat_dup(const fastf_t *in)
d1351 3
a1353 1
bn_mat_ck(const char *title, const fastf_t *m)
d1402 2
a1403 1
bn_mat_det3(const fastf_t *m)
d1421 2
a1422 1
bn_mat_determinant(const fastf_t *m)
@


11.28
log
@Eliminated some excess debug logging
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.27 2002/02/28 01:01:48 butler Exp $ (ARL)";
d130 1
a130 2
bn_atan2(y,x)
double	y,x;
d205 1
a205 4
bn_mat_mul( o, a, b )
register mat_t		o;
register const mat_t	a;
register const mat_t	b;
d237 1
a237 3
bn_mat_mul2( i, o )
register const mat_t	i;
register mat_t		o;
d253 1
a253 5
bn_mat_mul3( o, a, b, c )
mat_t		o;
const mat_t	a;
const mat_t	b;
const mat_t	c;
d269 1
a269 6
bn_mat_mul4( o, a, b, c, d )
mat_t		o;
const mat_t	a;
const mat_t	b;
const mat_t	c;
const mat_t	d;
d286 1
a286 4
bn_matXvec(ov, im, iv)
register hvect_t ov;
register const mat_t im;
register const hvect_t iv;
d315 1
a315 3
bn_mat_inv( output, input )
register mat_t	output;
const mat_t	input;
d404 1
a404 3
bn_vtoh_move( h, v )
register vect_t		h;
register const vect_t	v;
d420 1
a420 3
bn_htov_move( v, h )
register vect_t		v;
register const vect_t	h;
d445 1
a445 3
bn_mat_trn( om, im )
mat_t			om;
register const mat_t	im;
d480 1
a480 4
bn_mat_ae( m, azimuth, elev )
register mat_t	m;
double		azimuth;
double		elev;
d519 1
a519 4
bn_ae_vec( azp, elp, v )
fastf_t		*azp;
fastf_t		*elp;
const vect_t	v;
d543 1
a543 4
bn_aet_vec( az , el , twist , vec_ae, vec_twist , accuracy )
fastf_t *az,*el,*twist;
vect_t vec_ae,vec_twist;
fastf_t accuracy;
d591 1
a591 3
bn_mat_angles( mat, alpha_in, beta_in, ggamma_in )
register mat_t	mat;
double alpha_in, beta_in, ggamma_in;
d710 1
a710 4
bn_eigen2x2( val1, val2, vec1, vec2, a, b, c )
fastf_t	*val1, *val2;
vect_t	vec1, vec2;
fastf_t	a, b, c;
d759 1
a759 3
bn_vec_perp( new, old )
vect_t		new;
const vect_t	old;
d787 1
a787 4
bn_mat_fromto( m, from, to )
mat_t		m;
const vect_t	from;
const vect_t	to;
d866 1
a866 3
bn_mat_xrot( m, sinx, cosx )
mat_t	m;
double	sinx, cosx;
d893 1
a893 3
bn_mat_yrot( m, siny, cosy )
mat_t	m;
double	siny, cosy;
d920 1
a920 3
bn_mat_zrot( m, sinz, cosz )
mat_t	m;
double	sinz, cosz;
d962 1
a962 4
bn_mat_lookat( rot, dir, yflip )
mat_t		rot;
const vect_t	dir;
int		yflip;
d1023 1
a1023 3
bn_vec_ortho( out, in )
register vect_t	out;
register const vect_t	in;
d1075 1
a1075 4
bn_mat_scale_about_pt( mat, pt, scale )
mat_t		mat;
const point_t	pt;
const double	scale;
d1104 1
a1104 4
bn_mat_xform_about_pt( mat, xform, pt )
mat_t		mat;
const mat_t	xform;
const point_t	pt;
d1126 1
a1126 4
bn_mat_is_equal(a, b, tol)
const mat_t	a;
const mat_t	b;
const struct bn_tol	*tol;
d1186 1
a1186 2
bn_mat_is_identity( m )
const mat_t	m;
d1199 1
a1199 5
bn_mat_arb_rot( m, pt, dir, ang)
mat_t m;
const point_t pt;
const vect_t dir;
const fastf_t ang;
d1260 1
a1260 2
bn_mat_dup( in )
const mat_t	in;
d1280 1
a1280 3
bn_mat_ck( title, m )
const char *title;
const mat_t m;
d1329 1
a1329 2
bn_mat_det3( m )
const mat_t m;
d1347 1
a1347 2
bn_mat_determinant( m )
const mat_t m;
@


11.27
log
@added bn_mat_is_non_unif()
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.26 2001/06/01 17:39:36 bparker Exp $ (ARL)";
a1456 2

    bu_log("%g %g %g\n", V3ARGS(mag));
@


11.26
log
@*- added bn_mat_angles_rad (same as bn_mat_angles
   except it expects angles in radians)
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.25 2001/05/02 17:02:28 bparker Exp $ (ARL)";
d1447 23
@


11.25
log
@*- move guts of bn_mat_print to bn_mat_print_guts
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.24 2001/04/05 19:35:27 morrison Exp $ (ARL)";
d666 50
@


11.24
log
@updated SIGNED to signed
updated CONST to const
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.23 2001/04/02 21:37:57 morrison Exp $ (ARL)";
a81 3
/*
 *			B N _ M A T _ P R I N T
 */
d83 3
a85 3
bn_mat_print( title, m )
const char	*title;
const mat_t	m;
a87 1
	char		obuf[1024];	/* sprintf may be non-PARALLEL */
d92 2
a93 2
	if( !m )  {
		strcat( obuf, "(Identity)" );
d95 1
a95 1
		for(i=0; i<16; i++)  {
d98 1
a98 1
			if( i == 15 )  {
d100 1
a100 1
			} else if( (i&3) == 3 )  {
d108 12
@


11.23
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.22 2001/03/31 01:56:48 morrison Exp $ (ARL)";
d75 1
a75 1
CONST mat_t	bn_mat_identity = {
d87 2
a88 2
CONST char	*title;
CONST mat_t	m;
d176 1
a176 1
register CONST mat_t	src;
d200 2
a201 2
register CONST mat_t	a;
register CONST mat_t	b;
d234 1
a234 1
register CONST mat_t	i;
d253 3
a255 3
CONST mat_t	a;
CONST mat_t	b;
CONST mat_t	c;
d273 4
a276 4
CONST mat_t	a;
CONST mat_t	b;
CONST mat_t	c;
CONST mat_t	d;
d295 2
a296 2
register CONST mat_t im;
register CONST hvect_t iv;
d327 1
a327 1
CONST mat_t	input;
d418 1
a418 1
register CONST vect_t	v;
d436 1
a436 1
register CONST vect_t	h;
d463 1
a463 1
register CONST mat_t	im;
d543 1
a543 1
CONST vect_t	v;
d743 1
a743 1
CONST vect_t	old;
d773 2
a774 2
CONST vect_t	from;
CONST vect_t	to;
d957 1
a957 1
CONST vect_t	dir;
d1021 1
a1021 1
register CONST vect_t	in;
d1075 2
a1076 2
CONST point_t	pt;
CONST double	scale;
d1107 2
a1108 2
CONST mat_t	xform;
CONST point_t	pt;
d1131 3
a1133 3
CONST mat_t	a;
CONST mat_t	b;
CONST struct bn_tol	*tol;
d1194 1
a1194 1
CONST mat_t	m;
d1209 3
a1211 3
CONST point_t pt;
CONST vect_t dir;
CONST fastf_t ang;
d1273 1
a1273 1
CONST mat_t	in;
d1278 1
a1278 1
	bcopy( (CONST char *)in, (char *)out, sizeof(mat_t) );
d1294 2
a1295 2
CONST char *title;
CONST mat_t m;
d1345 1
a1345 1
CONST mat_t m;
d1364 1
a1364 1
CONST mat_t m;
@


11.22
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d9 1
a9 1
 *	bn_mat_copy( &o, &i )		Copy matrix i to matrix o
d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.21 2000/07/07 05:47:28 cjohnson Exp $ (ARL)";
d182 1
d240 1
a240 1
	bn_mat_copy( o, temp );
d335 1
a335 1
	bn_mat_copy( output, input );	/* Duplicate */
d986 1
a986 1
		bn_mat_copy( rot, prod12 );
d997 1
a997 1
			bn_mat_copy( prod12, rot );
@


11.21
log
@LINT
@
text
@d7 2
a8 2
 *	bn_mat_zero( &m )		Fill matrix m with zeros
 *	bn_mat_idn( &m )		Fill matrix m with identity matrix
d22 1
a22 1
 *	bn_mat_fromto			Make rot mat:  xform from A to B
d56 1
a56 1
static const char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.20 2000/06/30 21:00:02 butler Exp $ (ARL)";
d148 1
d165 1
d626 1
a626 1
		bn_mat_idn( mat );
d803 1
a803 1
		bn_mat_idn(m);
d817 1
a817 1
	bn_mat_idn( Q );
d826 1
a826 1
	bn_mat_idn( R );
d997 1
a997 1
			bn_mat_idn( third );
d1081 1
a1081 1
	bn_mat_idn( xlate );
d1084 1
a1084 1
	bn_mat_idn( s );
d1086 1
a1086 1
		bn_mat_zero( mat );
d1112 1
a1112 1
	bn_mat_idn( xlate );
d1219 1
a1219 1
		bn_mat_idn( m );
d1223 2
a1224 2
	bn_mat_idn( tran1 );
	bn_mat_idn( tran2 );
d1247 1
a1247 1
	bn_mat_idn( rot );
@


11.20
log
@optimized bn_mat_is_identity
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.19 2000/06/30 20:07:00 butler Exp $ (ARL)";
d63 6
@


11.19
log
@optimized bn_mat_inv for case of identity matrix
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.18 2000/03/29 17:46:55 mike Exp $ (ARL)";
a324 1
	char	is_identity=1;
a327 4
	/* If we've got an identity matrix the inverse is the same */
	if (memcmp(input, bn_mat_identity, sizeof(bn_mat_identity)))
		return;

d1187 1
a1187 5
	if( m[0]  != 1 || m[1]  != 0 || m[2]  != 0 || m[3]  != 0 )  return 0;
	if( m[4]  != 0 || m[5]  != 1 || m[6]  != 0 || m[7]  != 0 )  return 0;
	if( m[8]  != 0 || m[9]  != 0 || m[10] != 1 || m[11] != 0 )  return 0;
	if( m[12] != 0 || m[13] != 0 || m[14] != 0 || m[15] != 1 )  return 0;
	return 1;
@


11.18
log
@
Added appropriate bu_ and bn_ prefixes to things.
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.17 2000/03/28 21:58:30 mike Exp $ (ARL)";
d325 3
d329 3
a331 1
	bn_mat_copy( output, input );	/* Duplicate */
d333 1
a333 1
	/* Initialization */
@


11.17
log
@
Moved mat_determinant to libbn
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.16 1999/02/18 15:34:51 pjt Exp $ (ARL)";
d250 2
a251 2
	mat_mul( t, b, c );
	mat_mul( o, a, t );
d271 3
a273 3
	mat_mul( u, c, d );
	mat_mul( t, a, b );
	mat_mul( o, t, u );
@


11.16
log
@Nitpicky change in a comment for bn_mat_print()
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /c/CVS/brlcad/libbn/mat.c,v 11.15 1998/05/20 13:39:07 jra Exp $ (ARL)";
d1330 54
@


11.15
log
@Fixed bug in bn_mat_is_equal() (was incorrectly checking scale factor).
@
text
@d14 1
a14 1
 *	bn_mat_print( &title, &m )	Print matrix (with title) on stdout.
d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /m/cad/libbn/RCS/mat.c,v 11.14 1997/12/23 09:03:30 mike Exp jra $ (ARL)";
@


11.14
log
@Added bn_mat_ck()
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /m/cad/libbn/RCS/mat.c,v 11.13 1997/12/18 06:47:22 mike Exp mike $ (ARL)";
d1163 1
a1163 1
	f = a[15] - a[15];
@


11.13
log
@Added null pointer protection to bn_mat_pr()
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /m/cad/libbn/RCS/mat.c,v 11.12 1997/11/25 16:02:53 jra Exp mike $ (ARL)";
d1275 55
@


11.12
log
@bn_mat_angles() needed some help with angles == 180 degrees.
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /m/cad/libbn/RCS/mat.c,v 11.11 1997/04/25 02:34:14 mike Exp jra $ (ARL)";
d90 13
a102 9
	for(i=0; i<16; i++)  {
		sprintf(cp, " %8.3f", m[i]);
		cp += strlen(cp);
		if( i == 15 )  {
			break;
		} else if( (i&3) == 3 )  {
			*cp++ = '\n';
			*cp++ = ' ';
			*cp++ = ' ';
d104 1
a105 1
	*cp++ = '\0';
@


11.11
log
@Reorganized bn_mat_is_equal() for improved performance on
expected inputs.
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /m/cad/libbn/RCS/mat.c,v 11.10 1997/02/01 02:01:31 mike Exp mike $ (ARL)";
d605 1
a605 1
bn_mat_angles( mat, alpha, beta, ggamma )
d607 1
a607 1
double alpha, beta, ggamma;
d609 1
d613 1
a613 1
	if( alpha == 0.0 && beta == 0.0 && ggamma == 0.0 )  {
d618 3
a620 3
	alpha *= bn_degtorad;
	beta *= bn_degtorad;
	ggamma *= bn_degtorad;
d626 19
a644 3
	salpha = sin( alpha );
	sbeta = sin( beta );
	sgamma = sin( ggamma );
@


11.10
log
@Added bn_mat_mul3() and bn_mat_mul4().
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header: /m/cad/libbn/RCS/mat.c,v 11.9 1996/12/31 00:20:08 mike Exp mike $ (ARL)";
d1115 11
a1144 8
	/*
	 * Last, check that the translation part of the matrix (dist) are within
	 * the distance tolerance.
	 */
	for (i=3; i<12; i+=4) {
		f = a[i] - b[i];
		if ( !NEAR_ZERO(f, tdist)) return 0;
	}
@


11.9
log
@Added proper bn_ prefix
@
text
@d56 1
a56 1
static char bn_RCSmat[] = "@@(#)$Header$ (ARL)";
d216 2
a217 1
 *  A convenience wrapper for bn_mat_mul().
d228 42
@


11.8
log
@checkpoint
@
text
@d6 19
a24 19
 *	mat_atan2()			Wrapper for library atan2()
 *	mat_zero( &m )			Fill matrix m with zeros
 *	mat_idn( &m )			Fill matrix m with identity matrix
 *	mat_copy( &o, &i )		Copy matrix i to matrix o
 *	mat_mul( &o, &i1, &i2 )		Multiply i1 by i2 and store in o
 *	mat_mul2( &i, &o )
 *	matXvec( &ov, &m, &iv )		Multiply m by vector iv, store in ov
 *	mat_inv( &om, &im )		Invert matrix im, store result in om
 *	mat_print( &title, &m )		Print matrix (with title) on stdout.
 *	mat_trn( &o, &i )		Transpose matrix i into matrix o
 *	mat_ae( &o, azimuth, elev)	Make rot matrix from azimuth+elevation
 *	mat_ae_vec( &az, &el, v )		Find az/elev from dir vector
 *	mat_aet_vec( &az, &el, &twist, v1, v2 ) Find az,el,twist from two vectors
 *	mat_angles( &o, alpha, beta, gama )	Make rot matrix from angles
 *	mat_eigen2x2()			Eigen values and vectors
 *	mat_lookat			Make rot mat:  xform from D to -Z
 *	mat_fromto			Make rot mat:  xform from A to B
 *	mat_arb_rot( &m, pt, dir, ang)	Make rot mat about axis (pt,dir), through ang
 *	mat_is_equal()			Is mat a equal to mat b?
d43 2
a44 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d46 5
d52 2
a53 2
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d56 1
a56 1
static char RCSmat[] = "@@(#)$Header: /m/cad/libbn/RCS/mat.c,v 11.7 1996/09/10 20:00:57 butler Exp butler $ (BRL)";
d69 1
a69 4

CONST double	mat_degtorad = 0.0174532925199433;
CONST double	mat_radtodeg = 57.29577951308230698802;
CONST mat_t	mat_identity = {
d77 1
a77 1
 *			M A T _ P R I N T
d80 1
a80 1
mat_print( title, m )
d106 1
a106 1
 *			M A T _ A T A N 2
d112 1
a112 1
mat_atan2(y,x)
d127 1
a127 1
 *			M A T _ Z E R O
d132 1
a132 1
mat_zero( m )
d146 1
a146 1
 *			M A T _ I D N
d151 1
a151 1
mat_idn( m )
d154 1
a154 1
	memcpy(m, mat_identity, sizeof(m));
d158 1
a158 2
 *			M A T _ C O P Y
 * XXX how about just 
d162 1
a162 1
mat_copy( dest, src )
d177 1
a177 1
 *			M A T _ M U L
d185 1
a185 1
mat_mul( o, a, b )
d212 1
a212 1
 *			M A T _ M U L 2
d216 1
a216 1
 *  A convenience wrapper for mat_mul().
d219 1
a219 1
mat_mul2( i, o )
d225 2
a226 2
	mat_mul( temp, i, o );
	mat_copy( o, temp );
d230 1
a230 1
 *			M A T X V E C
d237 1
a237 1
matXvec(ov, im, iv)
d258 1
a258 1
 *			M A T _ I N V
d269 1
a269 1
mat_inv( output, input )
d279 1
a279 1
	mat_copy( output, input );	/* Duplicate */
d302 3
a304 3
			bu_log("mat_inv:  error! fabs(y)=%g\n", fabs(y));
			mat_print("singular matrix", input);
			bu_bomb("mat_inv: singular matrix\n");
d353 1
a353 1
 *			M A T _ V T O H _ M O V E
d360 1
a360 1
mat_vtoh_move( h, v )
d371 1
a371 1
 *			M A T _ H T O V _ M O V E
d378 1
a378 1
mat_htov_move( v, h )
d390 1
a390 1
			bu_log("mat_htov_move: divide by %f!\n", h[W]);
d402 1
a402 1
 *			M A T _ T R N
d405 1
a405 1
mat_trn( om, im )
d433 1
a433 1
 *			M A T _ A E
d442 1
a442 1
mat_ae( m, azimuth, elev )
d450 2
a451 2
	azimuth *= mat_degtorad;
	elev *= mat_degtorad;
d478 1
a478 1
 *			M A T _ A E _ V E C
d484 1
a484 1
mat_ae_vec( azp, elp, v )
d491 1
a491 1
	if( (az = mat_atan2( v[Y], v[X] ) * mat_radtodeg) < 0 )  {
d498 1
a498 1
	*elp = mat_atan2( v[Z], hypot( v[X], v[Y] ) ) * mat_radtodeg;
d501 1
a501 1
/*			M A T _ A E T _ V E C
d511 1
a511 1
mat_aet_vec( az , el , twist , vec_ae, vec_twist , accuracy )
d520 1
a520 1
	mat_ae_vec( az , el , vec_ae );
d531 1
a531 1
		*az = mat_atan2( -vec_twist[X] , vec_twist[Y] ) * mat_radtodeg;
d542 1
a542 1
		*twist = mat_atan2( VDOT( vec_twist , ninety_twist ) , VDOT( vec_twist , zero_twist ) ) * mat_radtodeg;
d552 1
a552 1
 *			M A T _ A N G L E S
d562 1
a562 1
mat_angles( mat, alpha, beta, ggamma )
d570 1
a570 1
		mat_idn( mat );
d574 3
a576 3
	alpha *= mat_degtorad;
	beta *= mat_degtorad;
	ggamma *= mat_degtorad;
d605 1
a605 1
 *			M A T _ E I G E N 2 X 2
d616 1
a616 1
mat_eigen2x2( val1, val2, vec1, vec2, a, b, c )
d662 1
a662 1
 *			M A T _ V E C _ P E R P
d668 1
a668 1
mat_vec_perp( new, old )
d688 1
a688 1
 *			M A T _ F R O M T O
d698 1
a698 1
mat_fromto( m, from, to )
d731 1
a731 1
		mat_idn(m);
d736 1
a736 1
		mat_vec_perp( N, unit_from );
d745 1
a745 1
	mat_idn( Q );
d749 1
a749 1
	mat_trn( Qt, Q );
d754 1
a754 1
	mat_idn( R );
d759 3
a761 3
	mat_mul( temp, R, Q );
	mat_mul( A, Qt, temp );
	mat_trn( m, A );		/* back to post-multiply style */
d767 1
a767 1
		bu_log("mat_fromto() ERROR!  from (%g,%g,%g) to (%g,%g,%g) went to (%g,%g,%g), dot=%g?\n",
d775 1
a775 1
 *			M A T _ X R O T
d780 1
a780 1
mat_xrot( m, sinx, cosx )
d804 1
a804 1
 *			M A T _ Y R O T
d809 1
a809 1
mat_yrot( m, siny, cosy )
d833 1
a833 1
 *			M A T _ Z R O T
d838 1
a838 1
mat_zrot( m, sinz, cosz )
d863 1
a863 1
 *			M A T _ L O O K A T
d882 1
a882 1
mat_lookat( rot, dir, yflip )
d900 1
a900 1
	mat_zrot( first, -dir[Y] / hypot_xy, dir[X] / hypot_xy );
d903 2
a904 2
	mat_yrot( second, -hypot_xy, -dir[Z] );
	mat_mul( prod12, second, first );
d911 1
a911 1
		bu_log("Warning: mat_lookat:  unable to twist correct, hypot=%g\n", hypot_xy);
d913 1
a913 1
		mat_copy( rot, prod12 );
d916 2
a917 2
	mat_zrot( third, -xproj[Y] / hypot_xy, xproj[X] / hypot_xy );
	mat_mul( rot, third, prod12 );
d924 2
a925 2
			mat_copy( prod12, rot );
			mat_idn( third );
d927 1
a927 1
			mat_mul( rot, third, prod12 );
d934 1
a934 1
		bu_log("Error:  mat_lookat final= (%g, %g, %g)\n", t1[X], t1[Y], t1[Z] );
d939 1
a939 1
 *			M A T _ V E C _ O R T H O
d946 1
a946 1
mat_vec_ortho( out, in )
d957 1
a957 1
		VPRINT("mat_vec_ortho: zero-length input", in);
d979 1
a979 1
		VPRINT("mat_vec_ortho: zero hypot on", in);
d991 1
a991 1
 *			M A T _ S C A L E _ A B O U T _ P T
d1000 1
a1000 1
mat_scale_about_pt( mat, pt, scale )
d1009 1
a1009 1
	mat_idn( xlate );
d1012 1
a1012 1
	mat_idn( s );
d1014 1
a1014 1
		mat_zero( mat );
d1019 1
a1019 1
	mat_mul( tmp, s, xlate );
d1022 1
a1022 1
	mat_mul( mat, xlate, tmp );
d1027 1
a1027 1
 *			M A T _ X F O R M _ A B O U T _ P T
d1032 1
a1032 1
mat_xform_about_pt( mat, xform, pt )
d1040 1
a1040 1
	mat_idn( xlate );
d1043 1
a1043 1
	mat_mul( tmp, xform, xlate );
d1046 1
a1046 1
	mat_mul( mat, xlate, tmp );
d1050 1
a1050 1
 *			R T _ M A T _ I S _ E Q U A L
d1057 1
a1057 1
mat_is_equal(a, b, tol)
d1066 1
a1066 1
	RT_CK_TOL(tol);
d1104 1
a1104 1
 *			M A T _ I S _ I D E N T I T Y
d1117 1
a1117 1
mat_is_identity( m )
d1127 1
a1127 1
/*	M A T _ A R B _ R O T
d1135 1
a1135 1
mat_arb_rot( m, pt, dir, ang)
d1148 1
a1148 1
		mat_idn( m );
d1152 2
a1153 2
	mat_idn( tran1 );
	mat_idn( tran2 );
d1176 1
a1176 1
	mat_idn( rot );
d1189 2
a1190 2
	mat_mul( m, rot, tran1 );
	mat_mul2( tran2, m );
d1195 1
a1195 1
 *			M A T _ D U P
d1200 1
a1200 1
mat_dup( in )
d1205 1
a1205 1
	out = (matp_t) bu_malloc( sizeof(mat_t), "mat_dup" );
@


11.7
log
@Moved to libbn
@
text
@d52 1
a52 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 11.6 1996/07/04 02:27:52 mike Exp $ (BRL)";
a63 1
#include "raytrace.h" /* for rt_tol */
d65 1
d68 6
d123 2
d143 1
d153 1
a153 5
	/* Clear everything first */
	mat_zero( m );

	/* Set ones in the diagonal */
	m[0] = m[5] = m[10] = m[15] = 1.0;
a155 1

d158 1
a158 1
 *
d174 1
d1060 1
a1060 1
CONST struct rt_tol	*tol;
@


11.6
log
@Added mat_is_identity()
@
text
@d24 1
a24 1
 *	rt_mat_is_equal()		Is mat a equal to mat b?
d40 1
d52 1
a52 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 11.5 1996/07/02 05:47:13 mike Exp mike $ (BRL)";
d61 1
d63 2
a64 1
#include "raytrace.h"
d95 1
a95 1
	rt_log("%s\n", obuf);
d297 1
a297 1
			rt_log("mat_inv:  error! fabs(y)=%g\n", fabs(y));
d299 1
a299 1
			rt_bomb("mat_inv: singular matrix\n");
d385 1
a385 1
			rt_log("mat_htov_move: divide by %f!\n", h[W]);
d762 1
a762 1
		rt_log("mat_fromto() ERROR!  from (%g,%g,%g) to (%g,%g,%g) went to (%g,%g,%g), dot=%g?\n",
d906 1
a906 1
		rt_log("Warning: mat_lookat:  unable to twist correct, hypot=%g\n", hypot_xy);
d929 1
a929 1
		rt_log("Error:  mat_lookat final= (%g, %g, %g)\n", t1[X], t1[Y], t1[Z] );
d1052 1
a1052 1
rt_mat_is_equal(a,b,tol)
a1187 26
#if 0
/*
 *			R T _ V E C T _ M A X M A G
 *
 *  Return the subscript (X, Y, Z) of the element of a vector (3-tuple)
 *  that has the maximum absolute value.
 */
int
rt_vect_maxmag( v )
CONST vect_t	v;
{
	if( fabs(v[X]) >= fabs(v[Y]) )  {
		/* X -vs- Z */
		if( fabs(v[X]) >= fabs(v[Z]) )
			return X;
		else
			return Z;
	}

	/* Y -vs- Z */
	if( fabs(v[Y]) >= fabs(v[Z]) )
		return Y;

	return Z;
}
#endif
d1200 1
a1200 1
	out = (matp_t) rt_malloc( sizeof(mat_t), "mat_dup" );
@


11.5
log
@Added mat_dup.
@
text
@d51 1
a51 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 11.4 1996/06/06 00:41:48 butler Exp mike $ (BRL)";
d1094 24
@


11.4
log
@Documented shortcomings of mat_lookat()
@
text
@d51 1
a51 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 11.3 1996/04/24 22:16:18 butler Exp butler $ (BRL)";
d1186 1
d1188 15
a1202 1
#endif
@


11.3
log
@a little reordering to eliminate gratuitous funciton prototyping
@
text
@d51 1
a51 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 11.2 1995/07/10 20:35:42 jra Exp $ (BRL)";
d860 3
@


11.2
log
@Added mat_arb_rot() for rotation about an arbitrary axis.
@
text
@d51 1
a51 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 11.1 1995/01/04 09:57:18 mike Rel4_4 jra $ (BRL)";
d66 28
a93 7
#if USE_PROTOTYPES
extern void	mat_print(CONST char *title, CONST mat_t m);
extern void	mat_vec_perp(vect_t new, CONST vect_t old);
#else
extern void	mat_print();
extern void	mat_vec_perp();
#endif
a391 28
/*
 *			M A T _ P R I N T
 */
void
mat_print( title, m )
CONST char	*title;
CONST mat_t	m;
{
	register int	i;
	char		obuf[1024];	/* sprintf may be non-PARALLEL */
	register char	*cp;

	sprintf(obuf, "MATRIX %s:\n  ", title);
	cp = obuf+strlen(obuf);
	for(i=0; i<16; i++)  {
		sprintf(cp, " %8.3f", m[i]);
		cp += strlen(cp);
		if( i == 15 )  {
			break;
		} else if( (i&3) == 3 )  {
			*cp++ = '\n';
			*cp++ = ' ';
			*cp++ = ' ';
		}
	}
	*cp++ = '\0';
	rt_log("%s\n", obuf);
}
d654 26
a977 25
/*
 *			M A T _ V E C _ P E R P
 *
 *  Given a vector, create another vector which is perpendicular to it.
 *  The output vector will have unit length only if the input vector did.
 */
void
mat_vec_perp( new, old )
vect_t		new;
CONST vect_t	old;
{
	register int i;
	LOCAL vect_t another;	/* Another vector, different */

	i = X;
	if( fabs(old[Y])<fabs(old[i]) )  i=Y;
	if( fabs(old[Z])<fabs(old[i]) )  i=Z;
	VSETALL( another, 0 );
	another[i] = 1.0;
	if( old[X] == 0 && old[Y] == 0 && old[Z] == 0 )  {
		VMOVE( new, another );
	} else {
		VCROSS( new, another, old );
	}
}
@


11.1
log
@Release_4.4
@
text
@d23 1
d51 1
a51 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.18 94/10/19 15:21:22 jra Exp $ (BRL)";
d1095 67
@


10.18
log
@reversed sense of twist in mat_aet_vec
@
text
@d50 1
a50 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.17 94/10/18 11:24:15 jra Exp Locker: jra $ (BRL)";
@


10.17
log
@Added mat_aet_vec
@
text
@d50 1
a50 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.16 94/08/10 20:40:43 gdurf Exp Locker: jra $ (BRL)";
a503 1
 * Vec_twist must be a unit vector.
d537 1
a537 1
		VCROSS( ninety_twist , zero_twist , vec_ae );
@


10.16
log
@Added include of conf.h
@
text
@d18 1
d50 1
a50 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.15 1994/08/04 22:32:27 gdurf Exp gdurf $ (BRL)";
d498 51
@


10.15
log
@Removed unused function rt_vect_maxmag().
It was causing problems with the creation of libplot3.a, since it would
be carried over into pl_mat.c and cause duplicate symbols.
@
text
@d49 1
a49 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.14 1994/05/06 00:37:48 mike Exp gdurf $ (BRL)";
d51 2
@


10.14
log
@Changed mat_print() to write output all at once.
This is not PARALLEL, but is necessary for debugging RTSRV.
@
text
@d49 1
a49 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.13 94/04/20 00:08:04 mike Exp Locker: mike $ (BRL)";
d1043 1
d1068 2
@


10.13
log
@Added rt_vect_maxmag()
@
text
@d49 1
a49 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.12 94/03/10 17:33:54 mike Exp Locker: mike $ (BRL)";
d356 1
a356 1
		if( h[W] == 0.0 )  {
d375 3
a377 1
	register int i;
d379 2
a380 1
	rt_log("MATRIX %s:\n  ", title);
d382 9
a390 5
		rt_log(" %8.3f", m[i]);
		if( i == 15 )
			rt_log("\n");
		else if( (i&3) == 3 )
			rt_log("\n  ");
d392 2
@


10.12
log
@Parameter type error in matXvect(), as pointed out by
Clay Olbon <olbon@@batman.dynetics.com>.
@
text
@d49 1
a49 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.11 94/03/02 21:16:40 cjohnson Exp Locker: mike $ (BRL)";
d981 7
d1003 4
a1006 5
/*
 * Check that the rotation part of the matrix (cosines) are within
 * the perpendicular tolarance.
 */

d1015 5
a1019 5
/*
 * Check that the scale part of the matrix (ratio) is within the
 * perpendicular tolarance.  There is no ratio tolarance so we use
 * the tighter of dist or perp.
 */
d1023 4
a1026 4
/*
 * Last, check that the translation part of the matrix (dist) are within
 * the distance tolarance.
 */
d1032 25
@


10.11
log
@Add a matrix compare that uses a tolarance structure.
@
text
@d49 1
a49 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.10 1994/01/11 19:08:04 mike Exp cjohnson $ (BRL)";
d200 2
a201 1
 * in the vector "ov".  Note this is post-multiply.
d205 1
a205 1
register vect_t ov;
d207 1
a207 1
register CONST vect_t iv;
@


10.10
log
@Added mat_scale_about_pt(), and mat_xform_about_pt()
formerly of mged/edsol.c
@
text
@d22 1
d49 1
a49 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.9 93/07/20 16:59:56 mike Exp Locker: mike $ (BRL)";
d57 1
d978 47
@


10.9
log
@Added prototypes.
@
text
@d48 1
a48 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.8 93/07/20 15:56:04 mike Exp Locker: mike $ (BRL)";
d917 59
@


10.8
log
@Added void declaration for mat_vec_perp()
@
text
@d48 1
a48 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.7 93/03/16 00:56:19 mike Exp Locker: mike $ (BRL)";
d57 2
a58 2
double	mat_degtorad = 0.0174532925199433;
double	mat_radtodeg = 57.29577951308230698802;
d60 4
d66 1
@


10.7
log
@Eliminated old code for mat_fromto()
@
text
@d48 1
a48 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.6 93/03/16 00:53:52 mike Exp Locker: mike $ (BRL)";
d61 1
@


10.6
log
@In mat_fromto(), check to see if two vectors are colinear.
@
text
@d48 1
a48 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.5 93/01/23 04:32:56 mike Exp Locker: mike $ (BRL)";
a603 3
	double	az, el;
	LOCAL double sin_az, sin_el;
	LOCAL double cos_az, cos_el;
a607 1
#if 0
a608 41
	 *  The method used here is to convert the vectors
	 *  to azimuth/elevation form (azimuth is +X, elevation is +Z),
	 *  take the difference, and form the rotation matrix.
	 *  See mat_ae for that algorithm.
	 *
	 *  This algorithm fails when transforming (0,-1,0) to (0,0,1),
	 *  and probably elsewhere.
	 */
	az = mat_atan2( to[Y], to[X] ) - mat_atan2( from[Y], from[X] );
	el = mat_atan2( to[Z], hypot( to[X], to[Y] ) ) -
	     mat_atan2( from[Z], hypot( from[X], from[Y] ) );

	sin_az = sin(az);
	cos_az = cos(az);
	sin_el = sin(el);
	cos_el = cos(el);

	m[0] = cos_el * cos_az;
	m[1] = -sin_az;
	m[2] = -sin_el * cos_az;
	m[3] = 0;

	m[4] = cos_el * sin_az;
	m[5] = cos_az;
	m[6] = -sin_el * sin_az;
	m[7] = 0;

	m[8] = sin_el;
	m[9] = 0;
	m[10] = cos_el;
	m[11] = 0;

	m[12] = m[13] = m[14] = 0;
	m[15] = 1.0;

	VMOVE( unit_from, from );
	VUNITIZE( unit_from );
	VMOVE( unit_to, to );
	VUNITIZE( unit_to );
#else
	/*
a663 2
#endif

d668 1
a668 1
		rt_log("mat_fromto() ERROR!  from (%g,%g,%g) to (%g,%g,%g) went to (%g,%g,%g), dot=%g, az=%g, el=%g?\n",
d671 1
a671 1
			V3ARGS( test_to ), dot, az, el );
@


10.5
log
@A new version of mat_fromto() that ought to work everywhere.
Algorithm by Ken Turkowski.
@
text
@d48 1
a48 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.4 93/01/23 04:11:25 mike Exp Locker: mike $ (BRL)";
d670 17
a686 2
	VCROSS( N, unit_from, unit_to );
	VUNITIZE( N );			/* should be unnecessary */
d937 2
a938 2
 *  Given a vector, create another vector which is perpendicular to it,
 *  but may not have unit length.
@


10.4
log
@Added error checking to mat_fromto()
@
text
@d48 1
a48 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.3 92/04/03 21:39:14 mike Exp Locker: mike $ (BRL)";
d592 2
a593 5
 *  space by the angle between the two.  Since there are many
 *  candidate matricies, the method used here is to convert the vectors
 *  to azimuth/elevation form (azimuth is +X, elevation is +Z),
 *  take the difference, and form the rotation matrix.
 *  See mat_ae for that algorithm.
d611 10
a647 1
	/* Verify that it worked */
d652 45
@


10.3
log
@Added mat_mul2()
@
text
@d48 1
a48 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.3 92/04/03 20:44:48 mike Exp $ (BRL)";
d610 3
d640 14
@


10.2
log
@Fixed comment
@
text
@d11 1
d48 1
a48 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 10.1 91/10/12 06:40:35 mike Rel4_0 Locker: mike $ (BRL)";
d170 17
@


10.1
log
@Release_4.0
@
text
@d18 1
a18 1
 *	eigen2x2()			Eigen values and vectors
d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 9.8 91/09/21 03:01:04 mike Exp $ (BRL)";
@


9.8
log
@Carl Nuzman correctly pointed out that the previous code
actually computed -beta as the Y rotation.
This version is corrected.
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 9.7 91/06/30 00:05:20 mike Exp $ (BRL)";
@


9.7
log
@More CONST gook
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 9.6 91/06/13 01:34:25 mike Exp $ (BRL)";
d497 1
a497 1
	mat[2] = -sbeta;
d500 2
a501 2
	mat[4] = -salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = salpha * sbeta * sgamma + calpha * cgamma;
d505 2
a506 2
	mat[8] = calpha * sbeta * cgamma + salpha * sgamma;
	mat[9] = -calpha * sbeta * sgamma + salpha * cgamma;
@


9.6
log
@All routines now have mat_ prefix.
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 9.5 91/06/04 19:28:14 mike Exp $ (BRL)";
d122 2
a123 2
mat_t	dest;
mat_t	src;
a124 2
	register matp_t om = dest;
	register matp_t im = src;
d130 1
a130 1
		*om++ = *im++;
d144 3
a146 3
register mat_t o;
register mat_t a;
register mat_t b;
d179 2
a180 2
register mat_t im;
register vect_t iv;
a209 1
mat_t		input;
d211 1
d345 2
a346 2
char	*title;
mat_t	m;
d365 2
a366 2
mat_t		om;
register mat_t	im;
d444 3
a446 3
fastf_t	*azp;
fastf_t	*elp;
vect_t	v;
d585 3
a587 3
mat_t	m;
vect_t	from;
vect_t	to;
d727 3
a729 3
mat_t	rot;
vect_t	dir;
int	yflip;
@


9.5
log
@ANSI
@
text
@d16 1
a16 1
 *	ae_vec( &az, &el, v )		Find az/elev from dir vector
d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/mat.c,v 9.4 90/06/05 00:41:45 mike Exp Locker: mike $ (BRL)";
d295 1
a295 1
 *			V T O H _ M O V E
d302 3
a304 2
vtoh_move( h, v )
register vect_t h, v;
d313 1
a313 1
 *			H T O V _ M O V E
d320 3
a322 2
htov_move( v, h )
register vect_t v, h;
d324 1
a324 1
	FAST fastf_t inv;
d332 1
a332 1
			rt_log("htov_move: divide by %f!\n", h[W]);
d439 1
a439 1
 *			A E _ V E C
d445 1
a445 1
ae_vec( azp, elp, v )
d516 2
d527 1
a527 1
eigen2x2( val1, val2, vec1, vec2, a, b, c )
d785 1
a785 1
 *			V E C _ O R T H O
d792 1
a792 1
vec_ortho( out, in )
d794 1
a794 1
register vect_t	in;
d803 1
a803 1
		VPRINT("vec_ortho: zero-length input", in);
d825 1
a825 1
		VPRINT("vec_ortho: zero hypot on", in);
d836 1
a836 1
 *			V E C _ P E R P
d842 3
a844 2
vec_perp( new, old )
vect_t new, old;
@


9.4
log
@Made argument declarations more modern.
Never use matp_t or vectp_t for arguments, only for pointer variables.
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: /m/cad/librt/RCS/mat.c,v 9.3 90/04/24 01:36:28 mike Exp $ (BRL)";
d246 2
a247 2
			abort();
			return;		/* ERROR */
@


9.3
log
@Added more debugging on matrix inversion error.
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: /n/spark/m/cad/librt/RCS/mat.c,v 9.2 90/01/02 08:03:47 mike Exp $ (BRL)";
d87 1
a87 1
register matp_t m;
d90 1
d94 1
a94 1
		*m++ = 0.0;
d105 1
a105 1
register matp_t m;
d118 1
a118 1
 * Copy the matrix "im" into the matrix "om".
d121 3
a123 3
mat_copy( om, im )
register matp_t om;
register matp_t im;
d125 3
a127 1
	register int i = 0;
d130 2
a131 1
	for(; i<16; i++)
d146 3
a148 3
register matp_t o;
register matp_t a;
register matp_t b;
d180 3
a182 3
register vectp_t ov;
register matp_t im;
register vectp_t iv;
d212 2
a213 2
matp_t input;
register matp_t output;
d303 1
a303 1
register vectp_t h, v;
d305 4
a308 4
	*h++ = *v++;
	*h++ = *v++;
	*h++ = *v;
	*h++ = 1.0;
d320 1
a320 1
register vectp_t v, h;
d325 3
a327 3
		*v++ = *h++;
		*v++ = *h++;
		*v   = *h;
d329 2
a330 2
		if( h[3] == 0.0 )  {
			rt_log("htov_move: divide by %f!\n", h[3]);
d333 4
a336 4
		inv = 1.0 / h[3];
		*v++ = *h++ * inv;
		*v++ = *h++ * inv;
		*v   = *h   * inv;
d345 2
a346 2
char *title;
mat_t m;
d365 2
a366 2
register matp_t om;
register matp_t im;
d368 1
a368 4
	*om++ = im[0];
	*om++ = im[4];
	*om++ = im[8];
	*om++ = im[12];
d370 4
a373 9
	*om++ = im[1];
	*om++ = im[5];
	*om++ = im[9];
	*om++ = im[13];

	*om++ = im[2];
	*om++ = im[6];
	*om++ = im[10];
	*om++ = im[14];
d375 14
a388 4
	*om++ = im[3];
	*om++ = im[7];
	*om++ = im[11];
	*om++ = im[15];
d402 3
a404 3
register matp_t m;
double azimuth;
double elev;
d472 1
a472 1
register matp_t mat;
a742 3
#if 0
rt_log(" az angle=%g\n", mat_atan2( -dir[Y] / hypot_xy, dir[X] / hypot_xy )*mat_radtodeg );
#endif
a745 3
#if 0
rt_log(" el angle=%g\n", mat_atan2( -hypot_xy, -dir[Z] )*mat_radtodeg );
#endif
a758 3
#if 0
rt_log(" tw angle=%g\n", mat_atan2( -xproj[Y] / hypot_xy, xproj[X] / hypot_xy )*mat_radtodeg);
#endif
d789 2
a790 1
register fastf_t *out, *in;
@


9.2
log
@Made the "division by zero" test in mat_inv more realistic.
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 9.1 89/05/19 05:56:45 mike Locked $ (BRL)";
d59 1
d240 2
a241 1
			rt_log("mat_inv:  error!\n");
@


9.1
log
@Release_3.5
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 8.5 89/04/10 20:52:54 mike Exp $ (BRL)";
d238 1
a238 1
		if( fabs(y) < 0.000001 )  {
@


8.5
log
@Some range limiting on ae_vec().
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 8.4 89/04/10 19:20:05 mike Locked $ (BRL)";
@


8.4
log
@Added ae_mat()
@
text
@d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 8.3 89/02/23 20:43:00 mike Locked $ (BRL)";
d440 10
a449 2
	*azp = mat_atan2( v[Y], v[X] );
	*elp = mat_atan2( v[Z], hypot( v[X], v[Y] ) );
@


8.3
log
@Added mat_radtodeg
@
text
@d16 1
d47 1
a47 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 8.2 89/01/09 04:13:01 mike Locked $ (BRL)";
d426 16
@


8.2
log
@Eliminated use of asin(),
added mat_xrot(), mat_yrot(), mat_zrot(),
totally rewrote mat_lookat().  This one works robustly.
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 8.1 88/10/05 00:31:23 mike Locked $ (BRL)";
d55 2
a56 1
double mat_degtorad = 0.0174532925199433;
d711 1
a711 1
rt_log(" az angle=%g\n", mat_atan2( -dir[Y] / hypot_xy, dir[X] / hypot_xy )/mat_degtorad );
d717 1
a717 1
rt_log(" el angle=%g\n", mat_atan2( -hypot_xy, -dir[Z] )/mat_degtorad );
d733 1
a733 1
rt_log(" tw angle=%g\n", mat_atan2( -xproj[Y] / hypot_xy, xproj[X] / hypot_xy )/mat_degtorad);
@


8.1
log
@Release_3.0
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 7.6 88/05/13 21:59:54 mike Exp $ (BRL)";
d544 1
a544 2
 *  The input 'from' and 'to' vectors must be unit length.
 *
d558 2
a559 1
	el = asin( to[Z] ) - asin( from[Z] );
d586 88
d676 3
a678 3
 *  Given a direction vector D, product a matrix suitable for use
 *  as a "model2view" matrix that transforms the vector D
 *  into the -Z ("view") axis.
d680 8
a687 4
 *  Note that due to the special property of mat_fromto()
 *  that prevents "twist" on the vector by orienting on the X-Y
 *  plane, we must first find the transformation that maps
 *  D into the +X axis, and then rotate to the -Z axis.
d690 4
a693 3
mat_lookat( rot, dir )
mat_t rot;
vect_t dir;
d695 1
d697 2
a698 1
	mat_t	first;
d700 5
d706 15
a720 1
	/* Rotate from Dir to +X */
d722 13
a734 1
	mat_fromto( first, dir, x );
d736 17
a752 3
	/* Rotate so that +X is now -Z axis */
	mat_angles( second, -90.0, 0.0, 90.0 );
	mat_mul( rot, second, first );
@


7.6
log
@lint fix
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 7.5 88/02/19 19:29:29 mike Locked $ (BRL)";
@


7.5
log
@removed final extra space in mat_print
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 7.4 88/02/06 05:15:29 phil Locked $ (BRL)";
d622 1
@


7.4
log
@Added vec_ortho and vec_perp
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 7.3 88/02/05 02:32:18 mike Locked $ (BRL)";
d345 4
a348 1
		if( (i&3) == 3 ) rt_log("\n  ");
@


7.3
log
@Removed dependence on raytrace.h, changed stray printf() to rt_log().
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 7.2 87/11/05 06:29:57 mike Locked $ (BRL)";
d610 74
@


7.2
log
@Added abort() call for mat_inv error.
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 7.1 87/11/02 23:33:38 mike Locked $ (BRL)";
d51 1
a53 1
#include "raytrace.h"
d322 1
a322 1
			(void)fprintf(stderr, "htov_move: divide by %f!\n", h[3]);
@


7.1
log
@Release 2.3
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 6.2 87/10/21 00:24:57 mike Exp $ (BRL)";
d238 1
d485 1
d545 1
d594 1
@


6.2
log
@Added mat_lookat, mat_fromto, mat_atan2
@
text
@d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 6.1 87/07/11 07:55:56 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d6 1
d18 2
d46 1
a46 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 5.1 87/06/24 22:11:40 mike Rel $ (BRL)";
d55 1
a55 1
extern double	sin(), cos();
a56 1
static double degtorad = 0.0174532925199433;
d58 18
d395 2
a396 2
	azimuth *= degtorad;
	elev *= degtorad;
d427 4
d445 3
a447 3
	alpha *= degtorad;
	beta *= degtorad;
	ggamma *= degtorad;
a456 7
	/*
	 * compute the new rotation to apply to the previous
	 * viewing rotation.
	 * Alpha is angle of rotation about the X axis, and is done third.
	 * Beta is angle of rotation about the Y axis, and is done second.
	 * Gamma is angle of rotation about Z axis, and is done first.
	 */
d527 79
@


5.1
log
@Release 1.24
@
text
@d43 1
a43 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 4.4 87/05/30 06:38:20 phil Exp $ (BRL)";
@


4.4
log
@expanded mat_mult
added 2x2 eigenvalue routine for curvatures
@
text
@d43 1
a43 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 4.3 87/05/28 23:17:29 phil Locked $ (BRL)";
@


4.3
log
@Changed to use rt_log
@
text
@d16 1
d43 1
a43 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 4.2 87/02/12 22:11:24 mike Locked $ (BRL)";
d50 1
d54 1
a54 1
static double degtorad = 0.0174532925;
d112 4
a115 4
 * Multiply matrix "im1" by "im2" and store the result in "om".
 * NOTE:  This is different from multiplying "im2" by "im1" (most
 * of the time!)
 * NOTE: "om" must not be the same as either of the inputs.
d118 4
a121 4
mat_mul( om, im1, im2 )
register matp_t om;
register matp_t im1;
register matp_t im2;
d123 4
a126 4
	register int em1;		/* Element subscript for im1 */
	register int em2;		/* Element subscript for im2 */
	register int el = 0;		/* Element subscript for om */
	register int i;			/* For counting */
d128 4
a131 2
	/* For each element in the output matrix... */
	for(; el<16; el++) {
d133 4
a136 3
		om[el] = 0.0;		/* Start with zero in output */
		em1 = (el/4)*4;		/* Element at right of row in im1 */
		em2 = el%4;		/* Element at top of column in im2 */
d138 4
a141 7
		for(i=0; i<4; i++) {
			om[el] += im1[em1] * im2[em2];

			em1++;		/* Next row element in m1 */
			em2 += 4;	/* Next column element in m2 */
		}
	}
d456 54
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d42 1
a42 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 4.1 86/12/29 03:45:20 mike Rel1 $ (BRL)";
a49 1
extern int	fprintf();
d215 1
a215 1
			(void)fprintf(stderr, "mat_inv:  error!\n");
d319 1
a319 1
	fprintf(stderr,"MATRIX %s:\n  ", title);
d321 2
a322 2
		fprintf(stderr," %8.3f", m[i]);
		if( (i&3) == 3 ) fprintf(stderr,"\n  ");
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d42 1
a42 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 3.2 86/08/12 04:15:46 mike Exp $ (BRL)";
@


3.2
log
@Changed #include directives for use with CC -I convention
@
text
@d42 1
a42 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 3.1 86/07/11 01:32:08 mike Exp $ (BRL)";
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d42 1
a42 1
static char RCSmat[] = "@@(#)$Header: mat.c,v 3.0 86/06/10 01:33:11 mike Exp $ (BRL)";
d47 2
a48 2
#include "../h/machine.h"
#include "../h/vmath.h"
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: mat.c,v 2.1 85/08/31 06:05:10 mike Exp $ (BRL)";
d45 4
a48 4
#include	<stdio.h>
#include	<math.h>
#include	"../h/machine.h"
#include	"../h/vmath.h"
a176 2
#define EPSILON	0.000001

d215 1
a215 1
		if( fabs(y) < EPSILON )  {
@


2.1
log
@Version 2 of RT
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: mat.c,v 1.11 85/07/30 05:52:45 mike Exp $ (BRL)";
@


1.11
log
@Revised for joint GED/RT vmath.h;  some storage cleanups.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: mat.c,v 1.10 85/03/25 11:45:48 mike Exp $ (BRL)";
@


1.10
log
@Housekeeping
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d47 2
a48 1
#include	"vmath.h"
@


1.9
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d31 9
a39 3
 *	U. S. Army Ballistic Research Laboratory
 *
 * $Revision: 1.8 $
d41 3
@


1.8
log
@Cleanups to make library version
@
text
@d33 1
a33 1
 * $Revision: 1.7 $
d180 4
a183 4
	static int k;				/* Indices */
	static int	z[4];			/* Temporary */
	static fastf_t	b[4];			/* Temporary */
	static fastf_t	c[4];			/* Temporary */
d240 1
a240 1
			static int p;			/* Local temp */
d363 2
a364 2
	static double sin_az, sin_el;
	static double cos_az, cos_el;
d404 2
a405 2
	static double calpha, cbeta, cgamma;
	static double salpha, sbeta, sgamma;
@


1.7
log
@General cleanup
@
text
@d33 1
a33 1
 * $Revision: 1.6 $
d208 1
a208 1
			(void)printf("mat_inv:  error!\n");
d292 1
a292 1
			(void)printf("htov_move: divide by %f!\n", h[3]);
d315 1
a315 1
		if( (i&3) == 3 ) printf("\n  ");
@


1.6
log
@Slight neatening.
@
text
@d33 1
a33 1
 * $Revision: 1.5 $
d36 1
d40 1
a40 1
extern int	printf();
d312 1
a312 1
	printf("MATRIX %s:\n  ", title);
d314 1
a314 1
		printf(" %8.3f", m[i]);
@


1.5
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d33 1
a33 1
 * $Revision: 1.4 $
d40 1
a363 1
	extern double sin(), cos();
@


1.4
log
@Changed to use proper types.
@
text
@d33 1
a33 1
 * $Revision: 1.3 $
d393 1
a393 1
 *			B U I L D H R O T
@


1.3
log
@Boolean operation support
@
text
@d33 1
a33 1
 * $Revision: 1.2 $
d180 2
a181 2
	static float	b[4];			/* Temporary */
	static float	c[4];			/* Temporary */
d191 1
a191 1
		static float y;				/* local temporary */
d196 1
a196 1
			static float w;			/* local temporary */
d212 1
a212 1
			static float temp;		/* Local */
d241 1
a241 1
				static float w;		/* Local temp */
d263 1
a263 1
register float *h, *v;
d280 1
a280 1
register float *v, *h;
d282 1
a282 1
	static float inv;
d322 1
a322 1
register float *om;
d358 2
a359 2
float azimuth;
float elev;
d361 2
a362 2
	static float sin_az, sin_el;
	static float cos_az, cos_el;
d403 2
a404 2
	static float calpha, cbeta, cgamma;
	static float salpha, sbeta, sgamma;
@


1.2
log
@Added mat_ae function
@
text
@d15 1
d33 1
a33 1
 * $Revision$
d41 1
d43 1
a363 1
	static double degtorad = 0.0174532925;
d390 56
@


1.1
log
@Initial revision
@
text
@a0 1
/*	SCCSID	%W%	%E%	*/
d10 2
a11 2
 *	matXvec( &ov, &m, &iv )		Multiply m by vector iv and store in ov
 *	mat_inv( &om, &im )		Invert matrix im and store result in om
d14 1
d27 6
d341 47
@
