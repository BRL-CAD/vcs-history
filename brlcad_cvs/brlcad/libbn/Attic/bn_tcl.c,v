head	1.50;
access;
symbols
	ansi-20040405-merged:1.43.2.2
	postmerge-20040405-ansi:1.48
	premerge-20040404-ansi:1.47
	postmerge-autoconf:1.47
	autoconf-freeze:1.45.6.3
	premerge-autoconf:1.47
	ansi-20040316-freeze:1.43.2.1
	postmerge-20040315-windows:1.47
	premerge-20040315-windows:1.46
	windows-20040315-freeze:1.43.4.2
	autoconf-20031203:1.45
	autoconf-20031202:1.45
	autoconf-branch:1.45.0.6
	phong-branch:1.45.0.4
	photonmap-branch:1.45.0.2
	rel-6-1-DP:1.43
	windows-branch:1.43.0.4
	rel-6-0-2:1.41
	ansi-branch:1.43.0.2
	rel-6-0-1-branch:1.41.0.2
	hartley-6-0-post:1.42
	hartley-6-0-pre:1.41
	rel-6-0-1:1.41
	rel-6-0:1.41
	rel-5-4:1.24.2.1
	offsite-5-3-pre:1.36
	rel-5-3:1.24.2.1
	rel-5-2:1.24
	rel-5-1-branch:1.24.0.2
	rel-5-1:1.24
	rel-5-0:1.15
	rel-5-0-beta:1.15
	rel-4-5:1.12
	ctj-4-5-post:1.11
	ctj-4-5-pre:1.11;
locks; strict;
comment	@ * @;


1.50
date	2004.05.21.18.06.21;	author morrison;	state dead;
branches;
next	1.49;

1.49
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.16.19.16.25;	author morrison;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.02.17.39.06;	author morrison;	state Exp;
branches;
next	1.45;

1.45
date	2003.04.07.17.41.30;	author jra;	state Exp;
branches
	1.45.6.1;
next	1.44;

1.44
date	2003.04.01.14.57.55;	author jra;	state Exp;
branches;
next	1.43;

1.43
date	2002.08.20.17.07.35;	author jra;	state Exp;
branches
	1.43.2.1
	1.43.4.1;
next	1.42;

1.42
date	2002.08.15.20.54.47;	author hartley;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.01.17.39.36;	author bparker;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.02.17.04.23;	author bparker;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.20.22.29.01;	author morrison;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.31.01.56.48;	author morrison;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.19.22.19.43;	author butler;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.06.17.00.54;	author jra;	state Exp;
branches;
next	1.35;

1.35
date	2000.08.16.21.59.56;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.10.13.06.07;	author jra;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.09.19.03.45;	author butler;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.11.23.53.53;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	2000.07.07.05.47.27;	author cjohnson;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.29.18.45.50;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.28.18.55.57;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.28.18.51.41;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.28.18.49.43;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.28.18.41.24;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.27.19.17.59;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.23.04.20.29;	author mike;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.05.22.23.55.34;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.29.17.46.55;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.22.02.16.28;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	99.12.29.21.50.51;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	99.12.24.23.23.52;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	99.10.30.03.06.23;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	99.10.04.18.09.56;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	99.10.04.17.56.19;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	99.01.21.02.41.36;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	98.05.07.18.02.15;	author pjt;	state Exp;
branches;
next	1.13;

1.13
date	98.03.19.09.37.29;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.12.18.02.56.26;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	97.04.18.13.25.17;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	97.03.05.04.20.51;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	97.03.05.02.19.28;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.03.05.02.06.56;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.01.02.19.40.36;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.08.22.20.55.34;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.20.25.25;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	95.08.25.20.24.54;	author mike;	state Exp;
branches;
next	;

1.24.2.1
date	2001.02.06.19.08.28;	author jra;	state Exp;
branches;
next	;

1.43.2.1
date	2002.09.19.18.01.08;	author morrison;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2004.03.17.21.16.46;	author morrison;	state Exp;
branches;
next	;

1.43.4.1
date	2002.09.26.23.03.48;	author morrison;	state Exp;
branches;
next	1.43.4.2;

1.43.4.2
date	2004.03.11.23.41.43;	author morrison;	state Exp;
branches;
next	;

1.45.6.1
date	2004.02.12.18.39.32;	author erikg;	state Exp;
branches;
next	1.45.6.2;

1.45.6.2
date	2004.03.15.14.06.15;	author erikg;	state Exp;
branches;
next	1.45.6.3;

1.45.6.3
date	2004.03.18.18.08.28;	author erikg;	state Exp;
branches;
next	;


desc
@TCL access to LIBRT math functions
@


1.50
log
@moved to src/
@
text
@/*
 *			B N _ T C L . C
 *
 *  Tcl interfaces to all the LIBBN math routines.
 *
 *  Author -
 *	Glenn Durfee
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/bn_tcl.c,v 1.49 2004/05/10 15:30:43 erikg Exp $ (ARL)";
#endif


#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"

/* Support routines for the math functions */

/* XXX Really need a decode_array function that uses atof(),
 * XXX so that junk like leading { and commas between inputs
 * XXX don't spoil the conversion.
 */

int
bn_decode_mat(fastf_t *m, const char *str)
{
	if( strcmp( str, "I" ) == 0 )  {
		MAT_IDN( m );
		return 16;
	}
	if( *str == '{' )  str++;

	return sscanf(str,
	    "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
	    &m[0], &m[1], &m[2], &m[3], &m[4], &m[5], &m[6], &m[7],
	    &m[8], &m[9], &m[10], &m[11], &m[12], &m[13], &m[14], &m[15]);
}

int
bn_decode_quat(fastf_t *q, const char *str)
{
	if( *str == '{' )  str++;
	return sscanf(str, "%lf %lf %lf %lf", &q[0], &q[1], &q[2], &q[3]);
}

int
bn_decode_vect(fastf_t *v, const char *str)
{
	if( *str == '{' )  str++;
	return sscanf(str, "%lf %lf %lf", &v[0], &v[1], &v[2]);
}

int
bn_decode_hvect(fastf_t *v, const char *str)
{
	if( *str == '{' )  str++;
	return sscanf(str, "%lf %lf %lf %lf", &v[0], &v[1], &v[2], &v[3]);
}

void
bn_encode_mat(struct bu_vls *vp, const fastf_t *m)
{
	if( m == NULL )  {
		bu_vls_putc(vp, 'I');
		return;
	}

	bu_vls_printf(vp, "%g %g %g %g  %g %g %g %g  %g %g %g %g  %g %g %g %g",
	    m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
	    m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
}

void
bn_encode_quat(struct bu_vls *vp, const fastf_t *q)
{
	bu_vls_printf(vp, "%g %g %g %g", V4ARGS(q));
}

void
bn_encode_vect(struct bu_vls *vp, const fastf_t *v)
{
	bu_vls_printf(vp, "%g %g %g", V3ARGS(v));
}

void
bn_encode_hvect(struct bu_vls *vp, const fastf_t *v)
{
	bu_vls_printf(vp, "%g %g %g %g", V4ARGS(v));
}

void
bn_quat_distance_wrapper(double *dp, fastf_t *q1, fastf_t *q2)
{
	*dp = quat_distance(q1, q2);
}

void
bn_mat_scale_about_pt_wrapper(int *statusp, fastf_t *mat, const fastf_t *pt, const double scale)
{
	*statusp = bn_mat_scale_about_pt(mat, pt, scale);
}

static void
bn_mat4x3pnt(fastf_t *o, fastf_t *m, fastf_t *i)
{
	MAT4X3PNT(o, m, i);
}

static void
bn_mat4x3vec(fastf_t *o, fastf_t *m, fastf_t *i)
{
	MAT4X3VEC(o, m, i);
}

static void
bn_hdivide(fastf_t *o, const fastf_t *i)
{
	HDIVIDE(o, i);
}

static void
bn_vjoin1(fastf_t *o, const fastf_t *pnt, double scale, const fastf_t *dir)
{
	VJOIN1( o, pnt, scale, dir );
}


static void bn_vblend(fastf_t *a, fastf_t b, fastf_t *c, fastf_t d, fastf_t *e)
{
	VBLEND2( a, b, c, d, e );
}

/*
 *			B N _ M A T H _ C M D
 *
 * Tcl wrappers for the math functions.
 *
 * This is where you should put clauses, in the below "if" statement, to add
 * Tcl support for the LIBBN math routines.
 */

int
bn_math_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	void (*math_func)();
	struct bu_vls result;

	math_func = (void (*)())clientData; /* object-to-function cast */
	bu_vls_init(&result);

	if (math_func == bn_mat_mul) {
		mat_t o, a, b;
		if (argc < 3 || bn_decode_mat(a, argv[1]) < 16 ||
		    bn_decode_mat(b, argv[2]) < 16) {
			bu_vls_printf(&result, "usage: %s matA matB", argv[0]);
			goto error;
		}
		bn_mat_mul(o, a, b);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_inv || math_func == bn_mat_trn) {
		mat_t o, a;

		if (argc < 2 || bn_decode_mat(a, argv[1]) < 16) {
			bu_vls_printf(&result, "usage: %s mat", argv[0]);
			goto error;
		}
		(*math_func)(o, a);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_matXvec) {
		mat_t m;
		hvect_t i, o;
		if (argc < 3 || bn_decode_mat(m, argv[1]) < 16 ||
		    bn_decode_hvect(i, argv[2]) < 4) {
			bu_vls_printf(&result, "usage: %s mat hvect", argv[0]);
			goto error;
		}
		bn_matXvec(o, m, i);
		bn_encode_hvect(&result, o);
	} else if (math_func == bn_mat4x3pnt) {
		mat_t m;
		point_t i, o;
		if (argc < 3 || bn_decode_mat(m, argv[1]) < 16 ||
		    bn_decode_vect(i, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s mat point", argv[0]);
			goto error;
		}
		bn_mat4x3pnt(o, m, i);
		bn_encode_vect(&result, o);
	} else if (math_func == bn_mat4x3vec) {
		mat_t m;
		vect_t i, o;
		if (argc < 3 || bn_decode_mat(m, argv[1]) < 16 ||
		    bn_decode_vect(i, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s mat vect", argv[0]);
			goto error;
		}
		bn_mat4x3vec(o, m, i);
		bn_encode_vect(&result, o);
	} else if (math_func == bn_hdivide) {
		hvect_t i;
		vect_t o;
		if (argc < 2 || bn_decode_hvect(i, argv[1]) < 4) {
			bu_vls_printf(&result, "usage: %s hvect", argv[0]);
			goto error;
		}
		bn_hdivide(o, i);
		bn_encode_vect(&result, o);
	} else if (math_func == bn_vjoin1) {
		point_t o;
		point_t b, d;
		fastf_t c;

		if (argc < 4) {
			bu_vls_printf(&result, "usage: %s pnt scale dir", argv[0]);
			goto error;
		}
		if( bn_decode_vect(b, argv[1]) < 3) goto error;
		if (Tcl_GetDouble(interp, argv[2], &c) != TCL_OK) goto error;
		if( bn_decode_vect(d, argv[3]) < 3) goto error;

		VJOIN1( o, b, c, d );	/* bn_vjoin1( o, b, c, d ) */
		bn_encode_vect(&result, o);

	} else if ( math_func == bn_vblend) {
		point_t a, c, e;
		fastf_t b, d;

		if( argc < 5 ) {
			bu_vls_printf(&result, "usage: %s scale pnt scale pnt", argv[0]);
			goto error;
		}

		if( Tcl_GetDouble(interp, argv[1], &b) != TCL_OK) goto error;
		if( bn_decode_vect( c, argv[2] ) < 3) goto error;
		if( Tcl_GetDouble(interp, argv[3], &d) != TCL_OK) goto error;
		if( bn_decode_vect( e, argv[4] ) < 3) goto error;

		VBLEND2( a, b, c, d, e )
		bn_encode_vect( &result, a );

	} else if (math_func == bn_mat_ae) {
		mat_t o;
		double az, el;

		if (argc < 3) {
			bu_vls_printf(&result, "usage: %s azimuth elevation", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[1], &az) != TCL_OK) goto error;
		if (Tcl_GetDouble(interp, argv[2], &el) != TCL_OK) goto error;

		bn_mat_ae(o, (fastf_t)az, (fastf_t)el);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_ae_vec) {
		fastf_t az, el;
		vect_t v;

		if (argc < 2 || bn_decode_vect(v, argv[1]) < 3) {
			bu_vls_printf(&result, "usage: %s vect", argv[0]);
			goto error;
		}

		bn_ae_vec(&az, &el, v);
		bu_vls_printf(&result, "%g %g", az, el);
	} else if (math_func == bn_aet_vec) {
		fastf_t az, el, twist, accuracy;
		vect_t vec_ae, vec_twist;

		if (argc < 4 || bn_decode_vect(vec_ae, argv[1]) < 3 ||
		    bn_decode_vect(vec_twist, argv[2]) < 3 ||
		    sscanf(argv[3], "%lf", &accuracy) < 1) {
		  bu_vls_printf(&result, "usage: %s vec_ae vec_twist accuracy",
				argv[0]);
		  goto error;
		}

		bn_aet_vec(&az, &el, &twist, vec_ae, vec_twist, accuracy);
		bu_vls_printf(&result, "%g %g %g", az, el, twist);
	} else if (math_func == bn_mat_angles) {
		mat_t o;
		double alpha, beta, ggamma;

		if (argc < 4) {
			bu_vls_printf(&result, "usage: %s alpha beta gamma", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[1], &alpha) != TCL_OK)  goto error;
		if (Tcl_GetDouble(interp, argv[2], &beta) != TCL_OK)   goto error;
		if (Tcl_GetDouble(interp, argv[3], &ggamma) != TCL_OK) goto error;

		bn_mat_angles(o, alpha, beta, ggamma);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_eigen2x2) {
		fastf_t val1, val2;
		vect_t vec1, vec2;
		double a, b, c;

		if (argc < 4) {
			bu_vls_printf(&result, "usage: %s a b c", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[1], &a) != TCL_OK) goto error;
		if (Tcl_GetDouble(interp, argv[2], &c) != TCL_OK) goto error;
		if (Tcl_GetDouble(interp, argv[3], &b) != TCL_OK) goto error;

		bn_eigen2x2(&val1, &val2, vec1, vec2, (fastf_t)a, (fastf_t)b,
		    (fastf_t)c);
		bu_vls_printf(&result, "%g %g {%g %g %g} {%g %g %g}", val1, val2,
		    V3ARGS(vec1), V3ARGS(vec2));
	} else if (math_func == bn_mat_fromto) {
		mat_t o;
		vect_t from, to;

		if (argc < 3 || bn_decode_vect(from, argv[1]) < 3 ||
		    bn_decode_vect(to, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s vecFrom vecTo", argv[0]);
			goto error;
		}
		bn_mat_fromto(o, from, to);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_xrot || math_func == bn_mat_yrot ||
	    math_func == bn_mat_zrot) {
		mat_t o;
		double s, c;
		if (argc < 3) {
			bu_vls_printf(&result, "usage: %s sinAngle cosAngle", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[1], &s) != TCL_OK) goto error;
		if (Tcl_GetDouble(interp, argv[2], &c) != TCL_OK) goto error;

		(*math_func)(o, s, c);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_lookat) {
		mat_t o;
		vect_t dir;
		int yflip;
		if (argc < 3 || bn_decode_vect(dir, argv[1]) < 3) {
			bu_vls_printf(&result, "usage: %s dir yflip", argv[0]);
			goto error;
		}
		if (Tcl_GetBoolean(interp, argv[2], &yflip) != TCL_OK) goto error;

		bn_mat_lookat(o, dir, yflip);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_vec_ortho || math_func == bn_vec_perp) {
		vect_t ov, vec;

		if (argc < 2 || bn_decode_vect(vec, argv[1]) < 3) {
			bu_vls_printf(&result, "usage: %s vec", argv[0]);
			goto error;
		}

		(*math_func)(ov, vec);
		bn_encode_vect(&result, ov);
	} else if (math_func == bn_mat_scale_about_pt_wrapper) {
		mat_t o;
		vect_t v;
		double scale;
		int status;

		if (argc < 3 || bn_decode_vect(v, argv[1]) < 3) {
			bu_vls_printf(&result, "usage: %s pt scale", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[2], &scale) != TCL_OK) goto error;

		bn_mat_scale_about_pt_wrapper(&status, o, v, scale);
		if (status != 0) {
			bu_vls_printf(&result, "error performing calculation");
			goto error;
		}
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_xform_about_pt) {
		mat_t o, xform;
		vect_t v;

		if (argc < 3 || bn_decode_mat(xform, argv[1]) < 16 ||
		    bn_decode_vect(v, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s xform pt", argv[0]);
			goto error;
		}

		bn_mat_xform_about_pt(o, xform, v);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_arb_rot) {
		mat_t o;
		point_t pt;
		vect_t dir;
		double angle;

		if (argc < 4 || bn_decode_vect(pt, argv[1]) < 3 ||
		    bn_decode_vect(dir, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s pt dir angle", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[3], &angle) != TCL_OK)
			return TCL_ERROR;

		bn_mat_arb_rot(o, pt, dir, (fastf_t)angle);
		bn_encode_mat(&result, o);
	} else if (math_func == quat_mat2quat) {
		mat_t mat;
		quat_t quat;

		if (argc < 2 || bn_decode_mat(mat, argv[1]) < 16) {
			bu_vls_printf(&result, "usage: %s mat", argv[0]);
			goto error;
		}

		quat_mat2quat(quat, mat);
		bn_encode_quat(&result, quat);
	} else if (math_func == quat_quat2mat) {
		mat_t mat;
		quat_t quat;

		if (argc < 2 || bn_decode_quat(quat, argv[1]) < 4) {
			bu_vls_printf(&result, "usage: %s quat", argv[0]);
			goto error;
		}

		quat_quat2mat(mat, quat);
		bn_encode_mat(&result, mat);
	} else if (math_func == bn_quat_distance_wrapper) {
		quat_t q1, q2;
		double d;

		if (argc < 3 || bn_decode_quat(q1, argv[1]) < 4 ||
		    bn_decode_quat(q2, argv[2]) < 4) {
			bu_vls_printf(&result, "usage: %s quatA quatB", argv[0]);
			goto error;
		}

		bn_quat_distance_wrapper(&d, q1, q2);
		bu_vls_printf(&result, "%g", d);
	} else if (math_func == quat_double || math_func == quat_bisect ||
	    math_func == quat_make_nearest) {
		quat_t oqot, q1, q2;

		if (argc < 3 || bn_decode_quat(q1, argv[1]) < 4 ||
		    bn_decode_quat(q2, argv[2]) < 4) {
			bu_vls_printf(&result, "usage: %s quatA quatB", argv[0]);
			goto error;
		}

		(*math_func)(oqot, q1, q2);
		bn_encode_quat(&result, oqot);
	} else if (math_func == quat_slerp) {
		quat_t oq, q1, q2;
		double d;

		if (argc < 4 || bn_decode_quat(q1, argv[1]) < 4 ||
		    bn_decode_quat(q2, argv[2]) < 4) {
			bu_vls_printf(&result, "usage: %s quat1 quat2 factor", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[3], &d) != TCL_OK) goto error;

		quat_slerp(oq, q1, q2, d);
		bn_encode_quat(&result, oq);
	} else if (math_func == quat_sberp) {
		quat_t oq, q1, qa, qb, q2;
		double d;

		if (argc < 6 || bn_decode_quat(q1, argv[1]) < 4 ||
		    bn_decode_quat(qa, argv[2]) < 4 || bn_decode_quat(qb, argv[3]) < 4 ||
		    bn_decode_quat(q2, argv[4]) < 4) {
			bu_vls_printf(&result, "usage: %s quat1 quatA quatB quat2 factor",
			    argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[5], &d) != TCL_OK) goto error;

		quat_sberp(oq, q1, qa, qb, q2, d);
		bn_encode_quat(&result, oq);
	} else if (math_func == quat_exp || math_func == quat_log) {
		quat_t qout, qin;

		if (argc < 2 || bn_decode_quat(qin, argv[1]) < 4) {
			bu_vls_printf(&result, "usage: %s quat", argv[0]);
			goto error;
		}

		(*math_func)(qout, qin);
		bn_encode_quat(&result, qout);
	} else {
		bu_vls_printf(&result, "libbn/bn_tcl.c: math function %s not supported yet", argv[0]);
		goto error;
	}

	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;

error:
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_ERROR;
}

static struct math_func_link {
	char *name;
	void (*func)();
} math_funcs[] = {
	{"mat_mul",            bn_mat_mul},
	{"mat_inv",            bn_mat_inv},
	{"mat_trn",            bn_mat_trn},
	{"matXvec",            bn_matXvec},
	{"mat4x3vec",          bn_mat4x3vec},
	{"mat4x3pnt",          bn_mat4x3pnt},
	{"hdivide",            bn_hdivide},
	{"vjoin1",	      bn_vjoin1},
	{"vblend",		bn_vblend},
	{"mat_ae",             bn_mat_ae},
	{"mat_ae_vec",         bn_ae_vec},
	{"mat_aet_vec",        bn_aet_vec},
	{"mat_angles",         bn_mat_angles},
	{"mat_eigen2x2",       bn_eigen2x2},
	{"mat_fromto",         bn_mat_fromto},
	{"mat_xrot",           bn_mat_xrot},
	{"mat_yrot",           bn_mat_yrot},
	{"mat_zrot",           bn_mat_zrot},
	{"mat_lookat",         bn_mat_lookat},
	{"mat_vec_ortho",      bn_vec_ortho},
	{"mat_vec_perp",       bn_vec_perp},
	{"mat_scale_about_pt", bn_mat_scale_about_pt_wrapper},
	{"mat_xform_about_pt", bn_mat_xform_about_pt},
	{"mat_arb_rot",        bn_mat_arb_rot},
	{"quat_mat2quat",      quat_mat2quat},
	{"quat_quat2mat",      quat_quat2mat},
	{"quat_distance",      bn_quat_distance_wrapper},
	{"quat_double",        quat_double},
	{"quat_bisect",        quat_bisect},
	{"quat_slerp",         quat_slerp},
	{"quat_sberp",         quat_sberp},
	{"quat_make_nearest",  quat_make_nearest},
	{"quat_exp",           quat_exp},
	{"quat_log",           quat_log},
	{0, 0}
};

/*
 *			B N _ C M D _ C O M M O N _ F I L E _ S I Z E
 */
int
bn_cmd_common_file_size(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    int width, height;
    int pixel_size = 3;
    
    if (argc != 2 && argc != 3) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 " fileName [#bytes/pixel]\"", NULL);
	return TCL_ERROR;
    }

    if( argc >= 3 )  pixel_size = atoi(argv[2]);

    if (bn_common_file_size(&width, &height, argv[1], pixel_size) > 0) {
	sprintf(interp->result, "%d %d", width, height);
	return TCL_OK;
    }

    /* Signal error */
    Tcl_SetResult(interp, "0 0", TCL_STATIC);
    return TCL_OK;
}

int
bn_cmd_noise_perlin(ClientData clientData,
		  Tcl_Interp *interp,
		  int argc,
		  char **argv)
{
	point_t pt;
	double	v;

	if (argc != 4) {
		Tcl_AppendResult(interp, "wrong # args: should be \"",
				 argv[0], " X Y Z \"",
				 NULL);
		return TCL_ERROR;
	}

	pt[X] = atof(argv[1]);
	pt[Y] = atof(argv[2]);
	pt[Z] = atof(argv[3]);

	v = bn_noise_perlin( pt );
	sprintf(interp->result, "%g", v );

	return TCL_OK;
}

/*
 *  usage: bn_noise_fbm X Y Z h_val lacunarity octaves
 *
 *
 *
 */
int
bn_cmd_noise(ClientData clientData,
		 Tcl_Interp *interp,
		 int argc,
		 char **argv)
{
	point_t pt;
	double h_val;
	double lacunarity;
	double octaves;
	double val;

	if (argc != 7) {
		Tcl_AppendResult(interp, "wrong # args: should be \"",
				 argv[0], " X Y Z h_val lacunarity octaves\"",
				 NULL);
		return TCL_ERROR;
	}

	pt[0] = atof(argv[1]);
	pt[1] = atof(argv[2]);
	pt[2] = atof(argv[3]);

	h_val = atof(argv[4]);
	lacunarity = atof(argv[5]);
	octaves = atof(argv[6]);


	if (!strcmp("bn_noise_turb", argv[0])) {
		val = bn_noise_turb(pt, h_val, lacunarity, octaves);

		sprintf(interp->result, "%g", val );
	} else 	if (!strcmp("bn_noise_fbm", argv[0])) {
		val = bn_noise_fbm(pt, h_val, lacunarity, octaves);
		sprintf(interp->result, "%g", val );
	} else {
		Tcl_AppendResult(interp, "Unknown noise type \"",
				 argv[0], "\"",	 NULL);
		return TCL_ERROR;
	}
	return TCL_OK;
}


/*
 *	usage: noise_slice xdim ydim inv h_val lac octaves dX dY dZ sX [sY sZ]
 *
 *	The idea here is to get a whole slice of noise at once, thereby
 *	avoiding the overhead of doing this in Tcl.
 */
int
bn_cmd_noise_slice(ClientData clientData,
		  Tcl_Interp *interp,
		  int argc,
		  char **argv)
{
	double h_val;
	double lacunarity;
	double octaves;

	vect_t delta; 	/* translation to noise space */
	vect_t scale; 	/* scale to noise space */
	unsigned xdim;	/* # samples X direction */
	unsigned ydim;	/* # samples Y direction */
	unsigned xval, yval;
#define NOISE_FBM 0
#define NOISE_TURB 1

	int noise_type = NOISE_FBM;
	double val;
	point_t pt;

	if (argc != 7) {
		Tcl_AppendResult(interp, "wrong # args: should be \"",
				 argv[0], " Xdim Ydim Zval h_val lacunarity octaves\"",
				 NULL);
		return TCL_ERROR;
	}

	xdim = atoi(argv[0]);
	ydim = atoi(argv[1]);
	VSETALL(delta, 0.0);
	pt[Z] = delta[Z] = atof(argv[2]);
	h_val = atof(argv[3]);
	lacunarity = atof(argv[4]);
	octaves = atof(argv[5]);

	switch (noise_type) {
	case NOISE_FBM: 
		for (yval = 0 ; yval < ydim ; yval++) {

		    pt[Y] = yval * scale[Y] + delta[Y];

		    for (xval = 0 ; xval < xdim ; xval++) {
			pt[X] = xval * scale[X] + delta[X];

			val = bn_noise_fbm(pt, h_val, lacunarity, octaves);

		    }
		}
		break;
	case NOISE_TURB:
		for (yval = 0 ; yval < ydim ; yval++) {

		    pt[Y] = yval * scale[Y] + delta[Y];

		    for (xval = 0 ; xval < xdim ; xval++) {
			pt[X] = xval * scale[X] + delta[X];

			val = bn_noise_turb(pt, h_val, lacunarity, octaves);

		    }
		}
		break;
	}
	 

	pt[0] = atof(argv[1]);
	pt[1] = atof(argv[2]);
	pt[2] = atof(argv[3]);

	h_val = atof(argv[4]);
	lacunarity = atof(argv[5]);
	octaves = atof(argv[6]);


	if (!strcmp("bn_noise_turb", argv[0])) {
		val = bn_noise_turb(pt, h_val, lacunarity, octaves);

		sprintf(interp->result, "%g", val );
	} else 	if (!strcmp("bn_noise_fbm", argv[0])) {
		val = bn_noise_fbm(pt, h_val, lacunarity, octaves);
		sprintf(interp->result, "%g", val );
	} else {
		Tcl_AppendResult(interp, "Unknown noise type \"",
				 argv[0], "\"",	 NULL);
		return TCL_ERROR;
	}
	return TCL_OK;
}


int
bn_cmd_random(ClientData clientData,
		  Tcl_Interp *interp,
		  int argc,
		  char **argv)
{
	int val;
	const char *str;
	double rnd;
	char buf[32];

	if (argc != 2) {
		Tcl_AppendResult(interp, "Wrong # args:  Should be \"",
				 argv[0], " varname\"", NULL);
		return TCL_ERROR;
	}

	if (! (str=Tcl_GetVar(interp, argv[1], 0))) {
		Tcl_AppendResult(interp, "Error getting variable ", 
				 argv[1], NULL);
		return TCL_ERROR;
	}
	val = atoi(str);

	if (val < 0) val = 0;

	rnd = BN_RANDOM(val);

	sprintf(buf, "%d", val);

	if (!Tcl_SetVar(interp, argv[1], buf, 0)) {
		Tcl_AppendResult(interp, "Error setting variable ",
				 argv[1], NULL);
		return TCL_ERROR;
	}

	sprintf(buf, "%g", rnd);
	Tcl_AppendResult(interp, buf, NULL);
	return TCL_OK;
}

/*
 *			B N _ M A T _ P R I N T
 */
void
bn_tcl_mat_print(Tcl_Interp		*interp,
		 const char		*title,
		 const mat_t		m)
{
	char		obuf[1024];	/* sprintf may be non-PARALLEL */

	bn_mat_print_guts(title, m, obuf);
	Tcl_AppendResult(interp, obuf, "\n", (char *)NULL);
}

/*
 *			B N _ T C L _ S E T U P
 *
 *  Add all the supported Tcl interfaces to LIBBN routines to
 *  the list of commands known by the given interpreter.
 */
void
bn_tcl_setup(Tcl_Interp *interp)
{
	struct math_func_link *mp;

	for (mp = math_funcs; mp->name != NULL; mp++) {
		(void)Tcl_CreateCommand(interp, mp->name,
		    (Tcl_CmdProc *)bn_math_cmd,
		    (ClientData)mp->func, /* Function-to-Object pointer cast */
		    (Tcl_CmdDeleteProc *)NULL);
	}

	(void)Tcl_CreateCommand(interp, "bn_noise_perlin",
		(Tcl_CmdProc *)bn_cmd_noise_perlin, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_noise_turb",
		(Tcl_CmdProc *)bn_cmd_noise, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_noise_fbm",
		(Tcl_CmdProc *)bn_cmd_noise, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_noise_slice",
		(Tcl_CmdProc *)bn_cmd_noise_slice, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_common_file_size",
		(Tcl_CmdProc *)bn_cmd_common_file_size, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_random",
		(Tcl_CmdProc *)bn_cmd_random, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);


	Tcl_SetVar(interp, "bn_version", (char *)bn_version+5, TCL_GLOBAL_ONLY);
}

/*
 *			B N _ I N I T
 *
 *  Allows LIBBN to be dynamically loade to a vanilla tclsh/wish with
 *  "load /usr/brlcad/lib/libbn.so"
 *
 *  The name of this function is specified by TCL.
 */
int
Bn_Init(Tcl_Interp *interp)
{
	bn_tcl_setup(interp);
	return TCL_OK;
}


double bn_noise_fbm(point_t point,double h_val,double lacunarity,double octaves);
double bn_noise_turb(point_t point,double h_val,double lacunarity,double octaves);
@


1.49
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/bn_tcl.c,v 1.48 2004/04/05 07:46:41 morrison Exp $ (ARL)";
@


1.48
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 6
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a31 1
#include "conf.h"
@


1.47
log
@merge of windows-6-0-branch into head
@
text
@d52 1
a52 3
bn_decode_mat(m, str)
mat_t m;
const char *str;
d67 1
a67 3
bn_decode_quat(q, str)
quat_t q;
const char *str;
d74 1
a74 3
bn_decode_vect(v, str)
vect_t v;
const char *str;
d81 1
a81 3
bn_decode_hvect(v, str)
hvect_t v;
const char *str;
d88 1
a88 3
bn_encode_mat(vp, m)
struct bu_vls *vp;
const mat_t m;
d101 1
a101 3
bn_encode_quat(vp, q)
struct bu_vls *vp;
const quat_t q;
d107 1
a107 3
bn_encode_vect(vp, v)
struct bu_vls *vp;
const vect_t v;
d113 1
a113 3
bn_encode_hvect(vp, v)
struct bu_vls *vp;
const hvect_t v;
d119 1
a119 3
bn_quat_distance_wrapper(dp, q1, q2)
double *dp;
quat_t q1, q2;
d125 1
a125 5
bn_mat_scale_about_pt_wrapper(statusp, mat, pt, scale)
int *statusp;
mat_t mat;
const point_t pt;
const double scale;
d131 1
a131 3
bn_mat4x3pnt(o, m, i)
point_t i, o;
mat_t m;
d137 1
a137 3
bn_mat4x3vec(o, m, i)
vect_t i, o;
mat_t m;
d143 1
a143 3
bn_hdivide(o, i)
const hvect_t i;
vect_t o;
d149 1
a149 5
bn_vjoin1(o, pnt, scale, dir )
point_t o;
const point_t pnt;
double scale;
const vect_t dir;
d155 1
a155 6
static void bn_vblend( a, b, c, d, e )
point_t a;
fastf_t b;
point_t c;
fastf_t d;
point_t e;
a168 1
#ifndef WIN32
d170 1
a170 13
bn_math_cmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
#else
int bn_math_cmd(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif

a571 8
#ifndef WIN32
int
bn_cmd_common_file_size(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
#else
d573 1
a573 6
bn_cmd_common_file_size(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif
d832 1
a832 2
bn_tcl_setup(interp)
Tcl_Interp *interp;
d880 1
a880 2
Bn_Init(interp)
Tcl_Interp *interp;
@


1.46
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.45 2003/04/07 17:41:30 jra Exp $ (ARL)";
d206 1
d213 8
d622 1
d629 8
@


1.45
log
@Added some casts to quiet the compiler
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1995 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.44 2003/04/01 14:57:55 jra Exp $ (ARL)";
@


1.45.6.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.46 2004/02/02 17:39:06 morrison Exp $ (ARL)";
@


1.45.6.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.45.6.1 2004/02/12 18:39:32 erikg Exp $ (ARL)";
@


1.45.6.3
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a205 1
#ifndef WIN32
a211 8
#else
int bn_math_cmd(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif

a612 1
#ifndef WIN32
a618 8
#else
int
bn_cmd_common_file_size(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif
@


1.44
log
@Added a "const" to quiet the compiler
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.43 2002/08/20 17:07:35 jra Exp $ (ARL)";
d883 2
a884 1
		(void)Tcl_CreateCommand(interp, mp->name, bn_math_cmd,
d890 1
a890 1
		bn_cmd_noise_perlin, (ClientData)NULL,
d894 1
a894 1
		bn_cmd_noise, (ClientData)NULL,
d898 1
a898 1
		bn_cmd_noise, (ClientData)NULL,
d902 1
a902 1
		bn_cmd_noise_slice, (ClientData)NULL,
d906 1
a906 1
		bn_cmd_common_file_size, (ClientData)NULL,
d910 1
a910 1
		bn_cmd_random, (ClientData)NULL,
@


1.43
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.41 2001/06/01 17:39:36 bparker Exp $ (ARL)";
d822 1
a822 1
	char *str;
@


1.43.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.43 2002/08/20 17:07:35 jra Exp $ (ARL)";
a205 1
#ifndef WIN32
a211 8
#else
int bn_math_cmd(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif

a612 1
#ifndef WIN32
a618 8
#else
int
bn_cmd_common_file_size(
ClientData clientData,
Tcl_Interp *interp,
int argc,
char **argv)
#endif
@


1.43.4.2
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libbn/bn_tcl.c,v 1.43.4.1 2002/09/26 23:03:48 morrison Exp $ (ARL)";
d840 1
a840 1
	const char *str;
d901 1
a901 2
		(void)Tcl_CreateCommand(interp, mp->name,
		    (Tcl_CmdProc *)bn_math_cmd,
d907 1
a907 1
		(Tcl_CmdProc *)bn_cmd_noise_perlin, (ClientData)NULL,
d911 1
a911 1
		(Tcl_CmdProc *)bn_cmd_noise, (ClientData)NULL,
d915 1
a915 1
		(Tcl_CmdProc *)bn_cmd_noise, (ClientData)NULL,
d919 1
a919 1
		(Tcl_CmdProc *)bn_cmd_noise_slice, (ClientData)NULL,
d923 1
a923 1
		(Tcl_CmdProc *)bn_cmd_common_file_size, (ClientData)NULL,
d927 1
a927 1
		(Tcl_CmdProc *)bn_cmd_random, (ClientData)NULL,
@


1.43.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.43 2002/08/20 17:07:35 jra Exp $ (ARL)";
d52 3
a54 1
bn_decode_mat(fastf_t *m, const char *str)
d69 3
a71 1
bn_decode_quat(fastf_t *q, const char *str)
d78 3
a80 1
bn_decode_vect(fastf_t *v, const char *str)
d87 3
a89 1
bn_decode_hvect(fastf_t *v, const char *str)
d96 3
a98 1
bn_encode_mat(struct bu_vls *vp, const fastf_t *m)
d111 3
a113 1
bn_encode_quat(struct bu_vls *vp, const fastf_t *q)
d119 3
a121 1
bn_encode_vect(struct bu_vls *vp, const fastf_t *v)
d127 3
a129 1
bn_encode_hvect(struct bu_vls *vp, const fastf_t *v)
d135 3
a137 1
bn_quat_distance_wrapper(double *dp, fastf_t *q1, fastf_t *q2)
d143 5
a147 1
bn_mat_scale_about_pt_wrapper(int *statusp, fastf_t *mat, const fastf_t *pt, const double scale)
d153 3
a155 1
bn_mat4x3pnt(fastf_t *o, fastf_t *m, fastf_t *i)
d161 3
a163 1
bn_mat4x3vec(fastf_t *o, fastf_t *m, fastf_t *i)
d169 3
a171 1
bn_hdivide(fastf_t *o, const fastf_t *i)
d177 5
a181 1
bn_vjoin1(fastf_t *o, const fastf_t *pnt, double scale, const fastf_t *dir)
d187 6
a192 1
static void bn_vblend(fastf_t *a, fastf_t b, fastf_t *c, fastf_t d, fastf_t *e)
d207 5
a211 1
bn_math_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d614 5
a618 1
bn_cmd_common_file_size(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d877 2
a878 1
bn_tcl_setup(Tcl_Interp *interp)
d925 2
a926 1
Bn_Init(Tcl_Interp *interp)
@


1.43.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d777 1
a777 1
	const char *str;
d837 1
a837 2
		(void)Tcl_CreateCommand(interp, mp->name,
		    (Tcl_CmdProc *)bn_math_cmd,
d843 1
a843 1
		(Tcl_CmdProc *)bn_cmd_noise_perlin, (ClientData)NULL,
d847 1
a847 1
		(Tcl_CmdProc *)bn_cmd_noise, (ClientData)NULL,
d851 1
a851 1
		(Tcl_CmdProc *)bn_cmd_noise, (ClientData)NULL,
d855 1
a855 1
		(Tcl_CmdProc *)bn_cmd_noise_slice, (ClientData)NULL,
d859 1
a859 1
		(Tcl_CmdProc *)bn_cmd_common_file_size, (ClientData)NULL,
d863 1
a863 1
		(Tcl_CmdProc *)bn_cmd_random, (ClientData)NULL,
@


1.42
log
@Converted from K&R to ANSI C - RFH
@
text
@d52 3
a54 1
bn_decode_mat(fastf_t *m, const char *str)
d69 3
a71 1
bn_decode_quat(fastf_t *q, const char *str)
d78 3
a80 1
bn_decode_vect(fastf_t *v, const char *str)
d87 3
a89 1
bn_decode_hvect(fastf_t *v, const char *str)
d96 3
a98 1
bn_encode_mat(struct bu_vls *vp, const fastf_t *m)
d111 3
a113 1
bn_encode_quat(struct bu_vls *vp, const fastf_t *q)
d119 3
a121 1
bn_encode_vect(struct bu_vls *vp, const fastf_t *v)
d127 3
a129 1
bn_encode_hvect(struct bu_vls *vp, const fastf_t *v)
d135 3
a137 1
bn_quat_distance_wrapper(double *dp, fastf_t *q1, fastf_t *q2)
d143 5
a147 1
bn_mat_scale_about_pt_wrapper(int *statusp, fastf_t *mat, const fastf_t *pt, const double scale)
d153 3
a155 1
bn_mat4x3pnt(fastf_t *o, fastf_t *m, fastf_t *i)
d161 3
a163 1
bn_mat4x3vec(fastf_t *o, fastf_t *m, fastf_t *i)
d169 3
a171 1
bn_hdivide(fastf_t *o, const fastf_t *i)
d177 5
a181 1
bn_vjoin1(fastf_t *o, const fastf_t *pnt, double scale, const fastf_t *dir)
d187 6
a192 1
static void bn_vblend(fastf_t *a, fastf_t b, fastf_t *c, fastf_t d, fastf_t *e)
d207 5
a211 1
bn_math_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d614 5
a618 1
bn_cmd_common_file_size(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d877 2
a878 1
bn_tcl_setup(Tcl_Interp *interp)
d925 2
a926 1
Bn_Init(Tcl_Interp *interp)
@


1.41
log
@*- added bn_mat_angles_rad (same as bn_mat_angles
   except it expects angles in radians)
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.40 2001/05/02 17:04:23 bparker Exp $ (ARL)";
d52 1
a52 3
bn_decode_mat(m, str)
mat_t m;
const char *str;
d67 1
a67 3
bn_decode_quat(q, str)
quat_t q;
const char *str;
d74 1
a74 3
bn_decode_vect(v, str)
vect_t v;
const char *str;
d81 1
a81 3
bn_decode_hvect(v, str)
hvect_t v;
const char *str;
d88 1
a88 3
bn_encode_mat(vp, m)
struct bu_vls *vp;
const mat_t m;
d101 1
a101 3
bn_encode_quat(vp, q)
struct bu_vls *vp;
const quat_t q;
d107 1
a107 3
bn_encode_vect(vp, v)
struct bu_vls *vp;
const vect_t v;
d113 1
a113 3
bn_encode_hvect(vp, v)
struct bu_vls *vp;
const hvect_t v;
d119 1
a119 3
bn_quat_distance_wrapper(dp, q1, q2)
double *dp;
quat_t q1, q2;
d125 1
a125 5
bn_mat_scale_about_pt_wrapper(statusp, mat, pt, scale)
int *statusp;
mat_t mat;
const point_t pt;
const double scale;
d131 1
a131 3
bn_mat4x3pnt(o, m, i)
point_t i, o;
mat_t m;
d137 1
a137 3
bn_mat4x3vec(o, m, i)
vect_t i, o;
mat_t m;
d143 1
a143 3
bn_hdivide(o, i)
const hvect_t i;
vect_t o;
d149 1
a149 5
bn_vjoin1(o, pnt, scale, dir )
point_t o;
const point_t pnt;
double scale;
const vect_t dir;
d155 1
a155 6
static void bn_vblend( a, b, c, d, e )
point_t a;
fastf_t b;
point_t c;
fastf_t d;
point_t e;
d170 1
a170 5
bn_math_cmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d573 1
a573 5
bn_cmd_common_file_size(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d832 1
a832 2
bn_tcl_setup(interp)
Tcl_Interp *interp;
d879 1
a879 2
Bn_Init(interp)
Tcl_Interp *interp;
@


1.40
log
@*- add new routine, bn_tcl_mat_print, that
   puts a string representation of a matrix
   into interp->result
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.39 2001/04/20 22:29:01 morrison Exp $ (ARL)";
a42 1

@


1.39
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.38 2001/03/31 01:56:48 morrison Exp $ (ARL)";
d855 14
@


1.38
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.37 2001/03/19 22:19:43 butler Exp $ (ARL)";
d147 2
a148 2
CONST point_t pt;
CONST double scale;
d171 1
a171 1
CONST hvect_t i;
d180 1
a180 1
CONST point_t pnt;
d182 1
a182 1
CONST vect_t dir;
@


1.37
log
@patches to merge 5.3 into 6.0
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/libbn/bn_tcl.c,v 1.36 2001/02/06 17:00:54 jra Exp $ (ARL)";
d58 1
a58 1
		bn_mat_idn( m );
@


1.36
log
@Added vblend function
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.35 2000/08/16 21:59:56 mike Exp $ (ARL)";
d187 1
d195 1
a195 1
	VBLEND2( a, b, c, d, e )
d292 1
d309 1
@


1.35
log
@
lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.34 2000/08/10 13:06:07 jra Exp $ (ARL)";
d187 10
d291 16
d579 1
@


1.34
log
@Fixed type mismatch problems with prototypes in bn.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.33 2000/08/09 19:03:45 butler Exp $ (ARL)";
@


1.33
log
@Added bn_random as a Tcl command
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.24 2000/05/23 04:20:29 mike Exp $ (ARL)";
d55 1
a55 1
char *str;
d72 1
a72 1
char *str;
d81 1
a81 1
char *str;
d90 1
a90 1
char *str;
d99 1
a99 1
mat_t m;
d114 1
a114 1
quat_t q;
d122 1
a122 1
vect_t v;
d130 1
a130 1
hvect_t v;
d545 34
a578 34
	"mat_mul",            bn_mat_mul,
	"mat_inv",            bn_mat_inv,
	"mat_trn",            bn_mat_trn,
	"matXvec",            bn_matXvec,
	"mat4x3vec",          bn_mat4x3vec,
	"mat4x3pnt",          bn_mat4x3pnt,
	"hdivide",            bn_hdivide,
	"vjoin1",	      bn_vjoin1,
	"mat_ae",             bn_mat_ae,
	"mat_ae_vec",         bn_ae_vec,
	"mat_aet_vec",        bn_aet_vec,
	"mat_angles",         bn_mat_angles,
	"mat_eigen2x2",       bn_eigen2x2,
	"mat_fromto",         bn_mat_fromto,
	"mat_xrot",           bn_mat_xrot,
	"mat_yrot",           bn_mat_yrot,
	"mat_zrot",           bn_mat_zrot,
	"mat_lookat",         bn_mat_lookat,
	"mat_vec_ortho",      bn_vec_ortho,
	"mat_vec_perp",       bn_vec_perp,
	"mat_scale_about_pt", bn_mat_scale_about_pt_wrapper,
	"mat_xform_about_pt", bn_mat_xform_about_pt,
	"mat_arb_rot",        bn_mat_arb_rot,
	"quat_mat2quat",      quat_mat2quat,
	"quat_quat2mat",      quat_quat2mat,
	"quat_distance",      bn_quat_distance_wrapper,
	"quat_double",        quat_double,
	"quat_bisect",        quat_bisect,
	"quat_slerp",         quat_slerp,
	"quat_sberp",         quat_sberp,
	"quat_make_nearest",  quat_make_nearest,
	"quat_exp",           quat_exp,
	"quat_log",           quat_log,
	0, 0
@


1.32
log
@
Added Tcl interfaces.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.31 2000/07/07 05:47:27 cjohnson Exp $ (ARL)";
d53 3
a55 1
bn_decode_mat(mat_t m, const char *str)
a68 23
/*
 *			B N _ D E C O D E _ T O L
 *
 *  If the user specifies {}, or only the distance tolerance,
 *  provide the same defaults that LIBRT uses.
 */
int
bn_decode_tol(struct bn_tol *tol, const char *str)
{
	tol->magic = BN_TOL_MAGIC;

	/* provide meaningful defaults */
	tol->dist = 0.005;
	tol->perp = 1e-6;

	if( *str == '{' )  str++;
	(void)sscanf(str, "%lf %lf", &tol->dist, &tol->perp);
	tol->dist_sq = tol->dist * tol->dist;
	tol->para = 1 - tol->perp;

	return 2;	/* You always get something good */
}

d70 3
a72 1
bn_decode_quat(quat_t q, const char *str)
d79 3
a81 1
bn_decode_vect( vect_t v, const char *str )
d88 3
a90 1
bn_decode_hvect(hvect_t v, const char *str)
a95 12
int
bn_decode_plane(plane_t v, const char *str)
{
	if( *str == '{' )  str++;
	return sscanf(str, "%lf %lf %lf %lf", &v[0], &v[1], &v[2], &v[3]);
}

/*
 *  Encoding routines.
 *  All these tuples should be wrapped in {}s.
 */

d97 3
a99 1
bn_encode_mat(struct bu_vls *vp, const mat_t m)
d106 1
a106 1
	bu_vls_printf(vp, "{%g %g %g %g  %g %g %g %g  %g %g %g %g  %g %g %g %g} ",
d112 3
a114 1
bn_encode_quat(struct bu_vls *vp, const quat_t q)
d116 1
a116 1
	bu_vls_printf(vp, "{%g %g %g %g} ", V4ARGS(q));
d120 3
a122 1
bn_encode_vect(struct bu_vls *vp, const vect_t v)
d124 1
a124 1
	bu_vls_printf(vp, "{%g %g %g} ", V3ARGS(v));
d128 3
a130 1
bn_encode_hvect(struct bu_vls *vp, const hvect_t v)
d132 1
a132 1
	bu_vls_printf(vp, "{%g %g %g %g} ", V4ARGS(v));
a134 4
/*
 *  Wrappers for macros and multiple-return-value functions
 */

d138 1
a138 2
const quat_t q1;
const quat_t q2;
d188 1
a188 1
 *			B N _ M A T H _ C M D _ V O I D
d190 1
a190 1
 * Tcl wrappers for the math functions of type void.
d197 1
a197 1
bn_math_cmd_void(clientData, interp, argc, argv)
d541 1
a541 1
static struct math_func_link_void {
d544 35
a578 39
} math_funcs_void[] = {
	{"mat_mul",            bn_mat_mul},
	{"mat_inv",            bn_mat_inv},
	{"mat_trn",            bn_mat_trn},
	{"matXvec",            bn_matXvec},
	{"mat4x3vec",          bn_mat4x3vec},
	{"mat4x3pnt",          bn_mat4x3pnt},
	{"hdivide",            bn_hdivide},
	{"vjoin1",	       bn_vjoin1},
	{"mat_ae",             bn_mat_ae},
	{"mat_ae_vec",         bn_ae_vec},	/* wrong name! */
	{"bn_ae_vec",          bn_ae_vec},
	{"mat_aet_vec",        bn_aet_vec},
	{"bn_aet_vec",         bn_aet_vec},	/* wrong name! */
	{"mat_angles",         bn_mat_angles},
	{"mat_eigen2x2",       bn_eigen2x2},
	{"mat_fromto",         bn_mat_fromto},
	{"mat_xrot",           bn_mat_xrot},
	{"mat_yrot",           bn_mat_yrot},
	{"mat_zrot",           bn_mat_zrot},
	{"mat_lookat",         bn_mat_lookat},
	{"mat_vec_ortho",      bn_vec_ortho},	/* wrong name! */
	{"bn_vec_ortho",       bn_vec_ortho},
	{"mat_vec_perp",       bn_vec_perp},	/* wrong name! */
	{"bn_vec_perp",        bn_vec_perp},
	{"mat_scale_about_pt", bn_mat_scale_about_pt_wrapper},
	{"mat_xform_about_pt", bn_mat_xform_about_pt},
	{"mat_arb_rot",        bn_mat_arb_rot},
	{"quat_mat2quat",      quat_mat2quat},
	{"quat_quat2mat",      quat_quat2mat},
	{"quat_distance",      bn_quat_distance_wrapper},
	{"quat_double",        quat_double},
	{"quat_bisect",        quat_bisect},
	{"quat_slerp",         quat_slerp},
	{"quat_sberp",         quat_sberp},
	{"quat_make_nearest",  quat_make_nearest},
	{"quat_exp",           quat_exp},
	{"quat_log",           quat_log},
	{0, 0}
a580 70

/*
 *			B N _ M A T H _ C M D _ I N T
 *
 * Tcl wrappers for the math functions of type int.
 *
 * This is where you should put clauses, in the below "if" statement, to add
 * Tcl support for the LIBBN math routines.
 */

int
bn_math_cmd_int(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int (*math_func)();
	struct bu_vls result;

	math_func = (int (*)())clientData; /* object-to-function cast */
	bu_vls_init(&result);

	if (math_func == bn_isect_2planes )  {
		plane_t	a, b;
		point_t	rpp_min;
		struct bn_tol tol;
		point_t	out_pt;
		vect_t	out_dir;
		int	ret;

		if( argc != 5 ||
		    bn_decode_plane(a, argv[1]) < 4 ||
		    bn_decode_plane(b, argv[2]) < 4 ||
		    bn_decode_vect(rpp_min, argv[3]) < 3 ||
		    bn_decode_tol(&tol, argv[4]) < 2
		)  {
			bu_vls_printf(&result, "usage: %s plane_a plane_b rpp_min tol\n", argv[0]);
			goto error;
		}
		if( (ret = bn_isect_2planes( out_pt, out_dir, a, b, rpp_min, &tol )) < 0 )  {
			bu_vls_printf(&result, "bn_isect_2planes() failed, ret=%d\n", ret);
			goto error;
		}
		bn_encode_vect( &result, out_pt );
		bn_encode_vect( &result, out_dir );
	} else {
		bu_vls_printf(&result, "libbn/bn_tcl.c: math function %s not supported yet", argv[0]);
		goto error;
	}

	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;

error:
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_ERROR;
}

static struct math_func_link_int {
	char *name;
	int (*func)();
} math_funcs_int[] = {
	{"bn_isect_2planes",	bn_isect_2planes},
	{0, 0}
};


d786 41
d837 1
a837 2
	struct math_func_link_void *vp;
	struct math_func_link_int *ip;
d839 3
a841 9
	for (vp = math_funcs_void; vp->name != NULL; vp++) {
		(void)Tcl_CreateCommand(interp, vp->name, bn_math_cmd_void,
		    (ClientData)vp->func, /* Function-to-Object pointer cast */
		    (Tcl_CmdDeleteProc *)NULL);
	}

	for (ip = math_funcs_int; ip->name != NULL; ip++) {
		(void)Tcl_CreateCommand(interp, ip->name, bn_math_cmd_int,
		    (ClientData)ip->func, /* Function-to-Object pointer cast */
d863 4
@


1.31
log
@LINT
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.30 2000/06/29 18:45:50 mike Exp $ (ARL)";
d53 1
a53 3
bn_decode_mat(m, str)
mat_t m;
char *str;
d74 1
a74 3
bn_decode_tol(tol, str)
struct bn_tol *tol;
const char *str;
d89 1
d91 1
a91 3
bn_decode_quat(q, str)
quat_t q;
const char *str;
d98 1
a98 3
bn_decode_vect(v, str)
vect_t v;
const char *str;
d105 1
a105 3
bn_decode_hvect(v, str)
hvect_t v;
const char *str;
d112 1
a112 3
bn_decode_plane(v, str)
plane_t v;
const char *str;
d124 1
a124 3
bn_encode_mat(vp, m)
struct bu_vls *vp;
const mat_t m;
d137 1
a137 3
bn_encode_quat(vp, q)
struct bu_vls *vp;
const quat_t q;
d143 1
a143 3
bn_encode_vect(vp, v)
struct bu_vls *vp;
const vect_t v;
d149 1
a149 3
bn_encode_hvect(vp, v)
struct bu_vls *vp;
const hvect_t v;
@


1.30
log
@
Removed dead variable
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.29 2000/06/28 18:55:57 mike Exp $ (ARL)";
d588 38
a625 38
	"mat_mul",            bn_mat_mul,
	"mat_inv",            bn_mat_inv,
	"mat_trn",            bn_mat_trn,
	"matXvec",            bn_matXvec,
	"mat4x3vec",          bn_mat4x3vec,
	"mat4x3pnt",          bn_mat4x3pnt,
	"hdivide",            bn_hdivide,
	"vjoin1",	      bn_vjoin1,
	"mat_ae",             bn_mat_ae,
	"mat_ae_vec",         bn_ae_vec,	/* wrong name! */
	"bn_ae_vec",          bn_ae_vec,
	"mat_aet_vec",        bn_aet_vec,
	"bn_aet_vec",         bn_aet_vec,	/* wrong name! */
	"mat_angles",         bn_mat_angles,
	"mat_eigen2x2",       bn_eigen2x2,
	"mat_fromto",         bn_mat_fromto,
	"mat_xrot",           bn_mat_xrot,
	"mat_yrot",           bn_mat_yrot,
	"mat_zrot",           bn_mat_zrot,
	"mat_lookat",         bn_mat_lookat,
	"mat_vec_ortho",      bn_vec_ortho,	/* wrong name! */
	"bn_vec_ortho",       bn_vec_ortho,
	"mat_vec_perp",       bn_vec_perp,	/* wrong name! */
	"bn_vec_perp",        bn_vec_perp,
	"mat_scale_about_pt", bn_mat_scale_about_pt_wrapper,
	"mat_xform_about_pt", bn_mat_xform_about_pt,
	"mat_arb_rot",        bn_mat_arb_rot,
	"quat_mat2quat",      quat_mat2quat,
	"quat_quat2mat",      quat_quat2mat,
	"quat_distance",      bn_quat_distance_wrapper,
	"quat_double",        quat_double,
	"quat_bisect",        quat_bisect,
	"quat_slerp",         quat_slerp,
	"quat_sberp",         quat_sberp,
	"quat_make_nearest",  quat_make_nearest,
	"quat_exp",           quat_exp,
	"quat_log",           quat_log,
	0, 0
d693 2
a694 2
	"bn_isect_2planes",	bn_isect_2planes,
	0, 0
@


1.29
log
@
Vectors and matricies, when output, need to be wrapped in {}s!
This is particularly important when returning more that one.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.28 2000/06/28 18:51:41 mike Exp $ (ARL)";
a79 2
	int ret;

d87 1
a87 1
	ret = sscanf(str, "%lf %lf", &tol->dist, &tol->perp);
@


1.28
log
@
Added comment
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.27 2000/06/28 18:49:43 mike Exp $ (ARL)";
a51 4
/*
 * XXX On output, these should be bracketed in {} !!!!
 */

d131 5
d146 1
a146 1
	bu_vls_printf(vp, "%g %g %g %g  %g %g %g %g  %g %g %g %g  %g %g %g %g",
d156 1
a156 1
	bu_vls_printf(vp, "%g %g %g %g", V4ARGS(q));
d164 1
a164 1
	bu_vls_printf(vp, "%g %g %g", V3ARGS(v));
d172 1
a172 1
	bu_vls_printf(vp, "%g %g %g %g", V4ARGS(v));
d175 4
a673 1
		bu_vls_printf(&result, "{");
a674 1
		bu_vls_printf(&result, "} {");
a675 1
		bu_vls_printf(&result, "}");
@


1.27
log
@
Fixed check for argc
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.26 2000/06/28 18:41:24 mike Exp $ (ARL)";
d53 1
a53 1
 * XXX These should be bracketed in {} !!!!
d73 6
@


1.26
log
@
Added tcl wrapper for bn_isect_2planes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.25 2000/06/27 19:17:59 mike Exp $ (ARL)";
d650 1
a650 1
		if( argc != 4 ||
@


1.25
log
@
There were several incorrect name bindings.
The correct bindings were added
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.24 2000/05/23 04:20:29 mike Exp $ (ARL)";
d52 4
d74 20
d96 1
a96 1
char *str;
d105 1
a105 1
char *str;
d114 10
a123 1
char *str;
d132 1
a132 1
mat_t m;
d147 1
a147 1
quat_t q;
d155 1
a155 1
vect_t v;
d163 1
a163 1
hvect_t v;
d171 2
a172 1
quat_t q1, q2;
d222 1
a222 1
 *			B N _ M A T H _ C M D
d224 1
a224 1
 * Tcl wrappers for the math functions.
d231 1
a231 1
bn_math_cmd(clientData, interp, argc, argv)
d575 1
a575 1
static struct math_func_link {
d578 1
a578 1
} math_funcs[] = {
d619 73
d907 8
a914 1
	struct math_func_link *mp;
d916 3
a918 3
	for (mp = math_funcs; mp->name != NULL; mp++) {
		(void)Tcl_CreateCommand(interp, mp->name, bn_math_cmd,
		    (ClientData)mp->func, /* Function-to-Object pointer cast */
@


1.24
log
@
Added "vjoin1" Tcl routine.
Very useful when doing ray-tracing computations in Tcl.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.23 2000/05/22 23:55:34 mike Exp $ (ARL)";
d554 2
a555 1
	"mat_ae_vec",         bn_ae_vec,
d557 1
d565 4
a568 2
	"mat_vec_ortho",      bn_vec_ortho,
	"mat_vec_perp",       bn_vec_perp,
@


1.24.2.1
log
@Added vblend
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.24 2000/05/23 04:20:29 mike Exp $ (ARL)";
a186 10
static void bn_vblend( a, b, c, d, e )
point_t a;
fastf_t b;
point_t c;
fastf_t d;
point_t e;
{
      VBLEND2( a, b, c, d, e )
}

a280 16
      } else if ( math_func == bn_vblend) {
		point_t a, c, e;
		fastf_t b, d;

		if( argc < 5 ) {
		        bu_vls_printf(&result, "usage: %s scale pnt scale pnt", argv[0]);
		        goto error;
		}

		if( Tcl_GetDouble(interp, argv[1], &b) != TCL_OK) goto error;
		if( bn_decode_vect( c, argv[2] ) < 3) goto error;
		if( Tcl_GetDouble(interp, argv[3], &d) != TCL_OK) goto error;
		if( bn_decode_vect( e, argv[4] ) < 3) goto error;

		VBLEND2( a, b, c, d, e )
		bn_encode_vect( &result, a );
a552 1
	"vblend",	      bn_vblend,
@


1.23
log
@
Added comment.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.22 2000/03/29 17:46:55 mike Exp $ (ARL)";
d171 1
a171 1
hvect_t i;
d177 9
d266 15
d552 1
@


1.22
log
@
Added appropriate bu_ and bn_ prefixes to things.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.21 2000/03/22 02:16:28 mike Exp $ (ARL)";
d46 5
@


1.21
log
@
Added Bn_Init() to allow use with Tcl built-in "load" command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.20 1999/12/29 21:50:51 butler Exp $ (ARL)";
d602 1
a602 1
	v = noise_perlin( pt );
@


1.20
log
@documented pointer casting
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.19 1999/12/24 23:23:52 mike Exp $ (ARL)";
d796 16
@


1.19
log
@
Removed unused var 'img'.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.18 1999/10/30 03:06:23 butler Exp $ (ARL)";
d192 1
a192 1
	math_func = (void (*)())clientData;
d770 1
a770 1
		    (ClientData)mp->func,
@


1.18
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.17 1999/10/04 18:09:56 butler Exp $ (ARL)";
a684 1
	double *img;
a699 3


	img = bu_malloc(xdim*ydim*sizeof(double), "noise array");
@


1.17
log
@

fixed compile errors on m4i64
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.16 1999/10/04 17:56:19 butler Exp $ (ARL)";
d607 1
d609 1
a609 1
 *  usage: bn_noise_fbm pt h_val lacunarity octaves
d661 2
a662 1
 *
@


1.16
log
@

Added Tcl interface to noise functions
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.15 1999/01/21 02:41:36 mike Exp $ (ARL)";
d680 1
a680 1
	int noise_type;
d687 1
a687 1
				 argv[0], " X Y Z h_val lacunarity octaves\"",
d694 5
a698 1

a702 1
	pt[Z] = delta[Z];
d710 1
a710 1
			pt[X] = xval * scale[X]; + delta[X];
d723 1
a723 1
			pt[X] = xval * scale[X]; + delta[X];
@


1.15
log
@Added bn_common_file_size, obviating need for custom routine in libtclcad/
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/bn_tcl.c,v 1.14 1998/05/07 18:02:15 pjt Exp $ (ARL)";
d582 173
d773 15
d793 1
d796 4
@


1.14
log
@Implemented matXvec, mat4x3pnt, mat4x3vec, and hdivide
(as well as bn_decode_hvect and bn_encode_hvect)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/bn_tcl.c,v 1.13 1998/03/19 09:37:29 mike Exp $ (ARL)";
d552 31
d599 5
@


1.13
log
@Added helpful check to decoders to skip over leading { of list,
should it be present.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/bn_tcl.c,v 1.12 1997/12/18 02:56:26 mike Exp mike $ (ARL)";
d82 9
d123 8
d148 23
d213 39
d519 4
@


1.12
log
@Added support for null matrix pointer signifying identity matrix.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/bn_tcl.c,v 1.11 1997/04/18 13:25:17 bparker Exp mike $ (ARL)";
d56 1
d69 1
d78 1
@


1.11
log
@fixed typo
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/bn_tcl.c,v 1.10 1997/03/05 04:20:51 mike Exp bparker $ (ARL)";
d52 5
d84 5
@


1.10
log
@Added library version string, in case it's useful.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/bn_tcl.c,v 1.9 1997/03/05 02:19:28 mike Exp mike $ (ARL)";
d447 1
a447 1
	"quat_slerp",         quat_bisect,
@


1.9
log
@Improved global naming.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/bn_tcl.c,v 1.8 1997/03/05 02:06:56 mike Exp mike $ (ARL)";
d472 2
@


1.8
log
@Eliminated needless #includes.
@
text
@a2 1
 *			M A T H . C
d4 2
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/math.c,v 1.7 1997/01/02 19:40:36 bparker Exp mike $ (ARL)";
d47 2
a48 2
static int
decode_mat(m, str)
d58 2
a59 2
static int
decode_quat(q, str)
d66 2
a67 2
static int
decode_vect(v, str)
d74 2
a75 2
static void
encode_mat(vp, m)
d84 2
a85 2
static void
encode_quat(vp, q)
d92 2
a93 2
static void
encode_vect(vp, v)
d100 2
a101 2
static void
quat_distance_wrapper(dp, q1, q2)
d108 2
a109 2
static void
mat_scale_about_pt_wrapper(statusp, mat, pt, scale)
d120 2
a121 1
/*                      C M D _ M A T H
d126 1
a126 1
 * Tcl support for the librt math routines.
d130 1
a130 1
cmd_math(clientData, interp, argc, argv)
d144 2
a145 2
		if (argc < 3 || decode_mat(a, argv[1]) < 16 ||
		    decode_mat(b, argv[2]) < 16) {
d149 2
a150 2
		(*math_func)(o, a, b);
		encode_mat(&result, o);
d154 1
a154 1
		if (argc < 2 || decode_mat(a, argv[1]) < 16) {
d159 1
a159 1
		encode_mat(&result, o);
d171 2
a172 2
		(*math_func)(o, (fastf_t)az, (fastf_t)el);
		encode_mat(&result, o);
d177 1
a177 1
		if (argc < 2 || decode_vect(v, argv[1]) < 3) {
d182 1
a182 1
		(*math_func)(&az, &el, v);
d188 2
a189 2
		if (argc < 4 || decode_vect(vec_ae, argv[1]) < 3 ||
		    decode_vect(vec_twist, argv[2]) < 3 ||
d196 1
a196 1
		(*math_func)(&az, &el, &twist, vec_ae, vec_twist, accuracy);
d210 2
a211 2
		(*math_func)(o, alpha, beta, ggamma);
		encode_mat(&result, o);
d225 1
a225 1
		(*math_func)(&val1, &val2, vec1, vec2, (fastf_t)a, (fastf_t)b,
d233 2
a234 2
		if (argc < 3 || decode_vect(from, argv[1]) < 3 ||
		    decode_vect(to, argv[2]) < 3) {
d238 2
a239 2
		(*math_func)(o, from, to);
		encode_mat(&result, o);
d252 1
a252 1
		encode_mat(&result, o);
d257 1
a257 1
		if (argc < 3 || decode_vect(dir, argv[1]) < 3) {
d263 2
a264 2
		(*math_func)(o, dir, yflip);
		encode_mat(&result, o);
d268 1
a268 1
		if (argc < 2 || decode_vect(vec, argv[1]) < 3) {
d274 2
a275 2
		encode_vect(&result, ov);
	} else if (math_func == mat_scale_about_pt_wrapper) {
d281 1
a281 1
		if (argc < 3 || decode_vect(v, argv[1]) < 3) {
d287 1
a287 1
		(*math_func)(&status, o, v, scale);
d292 1
a292 1
		encode_mat(&result, o);
d297 2
a298 2
		if (argc < 3 || decode_mat(xform, argv[1]) < 16 ||
		    decode_vect(v, argv[2]) < 3) {
d303 2
a304 2
		(*math_func)(o, xform, v);
		encode_mat(&result, o);
d311 2
a312 2
		if (argc < 4 || decode_vect(pt, argv[1]) < 3 ||
		    decode_vect(dir, argv[2]) < 3) {
d319 2
a320 2
		(*math_func)(o, pt, dir, (fastf_t)angle);
		encode_mat(&result, o);
d325 1
a325 1
		if (argc < 2 || decode_mat(mat, argv[1]) < 16) {
d330 2
a331 2
		(*math_func)(quat, mat);
		encode_quat(&result, quat);
d336 1
a336 1
		if (argc < 2 || decode_quat(quat, argv[1]) < 4) {
d341 3
a343 3
		(*math_func)(mat, quat);
		encode_mat(&result, mat);
	} else if (math_func == quat_distance_wrapper) {
d347 2
a348 2
		if (argc < 3 || decode_quat(q1, argv[1]) < 4 ||
		    decode_quat(q2, argv[2]) < 4) {
d353 1
a353 1
		(*math_func)(&d, q1, q2);
d359 2
a360 2
		if (argc < 3 || decode_quat(q1, argv[1]) < 4 ||
		    decode_quat(q2, argv[2]) < 4) {
d366 1
a366 1
		encode_quat(&result, oqot);
d371 2
a372 2
		if (argc < 4 || decode_quat(q1, argv[1]) < 4 ||
		    decode_quat(q2, argv[2]) < 4) {
d378 2
a379 2
		(*math_func)(oq, q1, q2, d);
		encode_quat(&result, oq);
d384 3
a386 3
		if (argc < 6 || decode_quat(q1, argv[1]) < 4 ||
		    decode_quat(qa, argv[2]) < 4 || decode_quat(qb, argv[3]) < 4 ||
		    decode_quat(q2, argv[4]) < 4) {
d393 2
a394 2
		(*math_func)(oq, q1, qa, qb, q2, d);
		encode_quat(&result, oq);
d398 1
a398 1
		if (argc < 2 || decode_quat(qin, argv[1]) < 4) {
d404 1
a404 1
		encode_quat(&result, qout);
d406 1
a406 1
		bu_vls_printf(&result, "math function %s not supported yet", argv[0]);
d424 1
a424 1
	"bn_mat_mul",            bn_mat_mul,
d439 1
a439 1
	"mat_scale_about_pt", mat_scale_about_pt_wrapper,
d444 1
a444 1
	"quat_distance",      quat_distance_wrapper,
d468 1
a468 1
		(void)Tcl_CreateCommand(interp, mp->name, cmd_math,
@


1.7
log
@mods to use libbn and libbu
@
text
@d2 1
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/math.c,v 1.6 1996/09/25 20:10:14 bparker Exp bparker $ (ARL)";
a29 1
#include <signal.h>
a34 2
#include <sys/time.h>
#include <time.h>
a35 1
#if 0
a36 2
#include "tk.h"
#endif
a41 5
#include "raytrace.h"
#include "rtgeom.h"
#include "externs.h"
#include "./ged.h"
#include "./mged_solid.h"
a42 1
#include "./mgedtcl.h"
a43 1

d454 1
a454 1
 *			M A T H _ S E T U P
d456 2
a457 1
 *  Called from cmd_setup()
d460 2
a461 1
math_setup()
@


1.6
log
@include mged_solid.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/math.c,v 1.5 1996/09/03 20:02:37 bparker Exp bparker $ (ARL)";
d38 1
d41 1
d46 1
d126 1
a126 1
	*statusp = mat_scale_about_pt(mat, pt, scale);
d152 1
a152 1
	if (math_func == mat_mul) {
d161 1
a161 1
	} else if (math_func == mat_inv || math_func == mat_trn) {
d170 1
a170 1
	} else if (math_func == mat_ae) {
d183 1
a183 1
	} else if (math_func == mat_ae_vec) {
d194 1
a194 1
	} else if (math_func == mat_aet_vec) {
d208 1
a208 1
	} else if (math_func == mat_angles) {
d222 1
a222 1
	} else if (math_func == mat_eigen2x2) {
d239 1
a239 1
	} else if (math_func == mat_fromto) {
d250 2
a251 2
	} else if (math_func == mat_xrot || math_func == mat_yrot ||
	    math_func == mat_zrot) {
d263 1
a263 1
	} else if (math_func == mat_lookat) {
d275 1
a275 1
	} else if (math_func == mat_vec_ortho || math_func == mat_vec_perp) {
d303 1
a303 1
	} else if (math_func == mat_xform_about_pt) {
d315 1
a315 1
	} else if (math_func == mat_arb_rot) {
d434 15
a448 15
	"mat_mul",            mat_mul,
	"mat_inv",            mat_inv,
	"mat_trn",            mat_trn,
	"mat_ae",             mat_ae,
	"mat_ae_vec",         mat_ae_vec,
	"mat_aet_vec",        mat_aet_vec,
	"mat_angles",         mat_angles,
	"mat_eigen2x2",       mat_eigen2x2,
	"mat_fromto",         mat_fromto,
	"mat_xrot",           mat_xrot,
	"mat_yrot",           mat_yrot,
	"mat_zrot",           mat_zrot,
	"mat_lookat",         mat_lookat,
	"mat_vec_ortho",      mat_vec_ortho,
	"mat_vec_perp",       mat_vec_perp,
d450 2
a451 2
	"mat_xform_about_pt", mat_xform_about_pt,
	"mat_arb_rot",        mat_arb_rot,
@


1.5
log
@rt_list ---> bu_list
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/math.c,v 1.4 1996/08/27 20:30:05 bparker Exp bparker $ (ARL)";
d48 1
a48 1
#include "./solid.h"
@


1.4
log
@now using libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/math.c,v 1.3 1996/08/22 20:55:34 bparker Exp bparker $ (ARL)";
d42 1
a44 2
#include "rtstring.h"
#include "rtlist.h"
@


1.3
log
@initialize variable - accuracy
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/math.c,v 1.2 1996/04/18 20:25:25 bparker Exp bparker $ (ARL)";
d85 1
a85 1
struct rt_vls *vp;
d88 1
a88 1
	rt_vls_printf(vp, "%g %g %g %g  %g %g %g %g  %g %g %g %g  %g %g %g %g",
d95 1
a95 1
struct rt_vls *vp;
d98 1
a98 1
	rt_vls_printf(vp, "%g %g %g %g", V4ARGS(q));
d103 1
a103 1
struct rt_vls *vp;
d106 1
a106 1
	rt_vls_printf(vp, "%g %g %g", V3ARGS(v));
d145 1
a145 1
	struct rt_vls result;
d148 1
a148 1
	rt_vls_init(&result);
d154 1
a154 1
			rt_vls_printf(&result, "usage: %s matA matB", argv[0]);
d163 1
a163 1
			rt_vls_printf(&result, "usage: %s mat", argv[0]);
d173 1
a173 1
			rt_vls_printf(&result, "usage: %s azimuth elevation", argv[0]);
d186 1
a186 1
			rt_vls_printf(&result, "usage: %s vect", argv[0]);
d191 1
a191 1
		rt_vls_printf(&result, "%g %g", az, el);
d199 1
a199 1
		  rt_vls_printf(&result, "usage: %s vec_ae vec_twist accuracy",
d205 1
a205 1
		rt_vls_printf(&result, "%g %g %g", az, el, twist);
d211 1
a211 1
			rt_vls_printf(&result, "usage: %s alpha beta gamma", argv[0]);
d226 1
a226 1
			rt_vls_printf(&result, "usage: %s a b c", argv[0]);
d235 1
a235 1
		rt_vls_printf(&result, "%g %g {%g %g %g} {%g %g %g}", val1, val2,
d243 1
a243 1
			rt_vls_printf(&result, "usage: %s vecFrom vecTo", argv[0]);
d253 1
a253 1
			rt_vls_printf(&result, "usage: %s sinAngle cosAngle", argv[0]);
d266 1
a266 1
			rt_vls_printf(&result, "usage: %s dir yflip", argv[0]);
d277 1
a277 1
			rt_vls_printf(&result, "usage: %s vec", argv[0]);
d290 1
a290 1
			rt_vls_printf(&result, "usage: %s pt scale", argv[0]);
d297 1
a297 1
			rt_vls_printf(&result, "error performing calculation");
d307 1
a307 1
			rt_vls_printf(&result, "usage: %s xform pt", argv[0]);
d321 1
a321 1
			rt_vls_printf(&result, "usage: %s pt dir angle", argv[0]);
d334 1
a334 1
			rt_vls_printf(&result, "usage: %s mat", argv[0]);
d345 1
a345 1
			rt_vls_printf(&result, "usage: %s quat", argv[0]);
d357 1
a357 1
			rt_vls_printf(&result, "usage: %s quatA quatB", argv[0]);
d362 1
a362 1
		rt_vls_printf(&result, "%g", d);
d369 1
a369 1
			rt_vls_printf(&result, "usage: %s quatA quatB", argv[0]);
d381 1
a381 1
			rt_vls_printf(&result, "usage: %s quat1 quat2 factor", argv[0]);
d395 1
a395 1
			rt_vls_printf(&result, "usage: %s quat1 quatA quatB quat2 factor",
d407 1
a407 1
			rt_vls_printf(&result, "usage: %s quat", argv[0]);
d414 1
a414 1
		rt_vls_printf(&result, "math function %s not supported yet", argv[0]);
d418 2
a419 2
	Tcl_AppendResult(interp, rt_vls_addr(&result), (char *)NULL);
	rt_vls_free(&result);
d423 2
a424 2
	Tcl_AppendResult(interp, rt_vls_addr(&result), (char *)NULL);
	rt_vls_free(&result);
@


1.2
log
@convert commands to Tcl
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/math.c,v 1.1 1995/08/25 20:24:54 mike Exp bparker $ (ARL)";
d197 5
a201 4
		    decode_vect(vec_twist, argv[2]) < 3) {
			rt_vls_printf(&result, "usage: %s vec_ae vec_twist accuracy",
			    argv[0]);
			goto error;
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d417 1
a417 1
	Tcl_SetResult(interp, rt_vls_addr(&result), TCL_VOLATILE);
@
