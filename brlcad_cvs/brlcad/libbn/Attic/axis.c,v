head	11.9;
access;
symbols
	ansi-20040405-merged:11.6.2.1
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.6
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.6
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:1.1;
locks; strict;
comment	@ * @;


11.9
date	2004.05.21.18.06.21;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.35;	author jra;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	2002.08.15.20.54.47;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.03.31.01.56.48;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	2000.07.11.23.30.38;	author cjohnson;	state Exp;
branches;
next	11.2;

11.2
date	97.01.08.03.55.58;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.51.11;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.04.04.40.47;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.13.20.25;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.31;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.07.02.04.14.05;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.07.02.01.14.44;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.05.31.11.26.00;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.05.09.22.14.53;	author sue;	state Exp;
branches;
next	9.2;

9.2
date	90.11.25.11.41.03;	author cjohnson;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.49.40;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.28.40;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.05.13.22.20.00;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.02.08.23.41.18;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.05.07.06.11;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.04.21.51.14;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.28.37;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.53.05;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.53.11;	author mike;	state Rel;
branches;
next	1.1;

1.1
date	87.01.12.18.58.26;	author mike;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.08;	author morrison;	state Exp;
branches;
next	;


desc
@unix-tig pack
draw an axis
@


11.9
log
@moved to src/
@
text
@/*
 *			T P _ A X I S
 *
 *	This routine is used to generate an axis for a graph.
 * It draws an axis with a linear scale, places tic marks every inch,
 * labels the tics, and uses the supplied title for the axis.
 *
 *	The strategy behind this routine is to split the axis
 * into SEGMENTS, which run from one tick to the next.  The
 * origin of the first segment (x,y), the origin of the bottom
 * of the first tick (xbott,ybott), and the origin of the first
 * tick label (xnum,ynum) are computed along with the delta x
 * and delta y (xincr,yincr) which describes the interval to
 * the start of the next tick.
 *
 *  Author -
 *	Michael John Muuss
 *	August 01, 1978
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/axis.c,v 11.8 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "plot3.h"

#define	TICK_YLEN	(char_width)	/* tick is 1 character height */
#define	NUM_YOFF	(3*char_width)	/* numbers offset from line */
#define	TITLE_YOFF	(5*char_width)	/* title offset from line */

void
tp_3axis(FILE *fp, char *string, fastf_t *origin, fastf_t *rot, double length, int ccw, int ndigits, double label_start, double label_incr, double tick_separation, double char_width)
    	    
    	        		/* label for axis */
       	       
     	    
      	       			/* length of axis */
   	    			/* 0=clockwise, !0=counter clockwise (ccw) */
   	        		/* # digits wide */
      	            		/* label starting value */
      	           		/* label increment between ticks */
      	                	/* plot distance between ticks */
      	           		/* character scale (size) */
{
	register int i;
	int	nticks;
	point_t	tick_bottom;			/* -Y point of tick */
	vect_t	axis_incr;			/* +X vect between ticks */
	vect_t	axis_dir;
	point_t	title_left;			/* left edge of title */
	point_t	cur_point;
	point_t	num_start;
	point_t	num_center;			/* center point of number */
	point_t	num_last_end;			/* end of last number */
	vect_t	temp;
	vect_t	diff;
	mat_t	xlate_to_0;
	mat_t	mat;				/* combined transform */
	char	fmt[32];
	char	str[64];

	/* Determine direction for ticks */
	if( ccw )
		ccw = -1;			/* counter clockwise */
	else
		ccw = 1;			/* clockwise */

	if( NEAR_ZERO(tick_separation, SMALL) )  tick_separation = 1;

	/*
	 *  The point "origin" will be the center of the axis rotation.
	 *  On the assumption that this origin point is not at (0,0,0),
	 *  translate origin to (0,0,0) & apply the provided rotation matrix.
	 *  If the user provides translation or
	 *  scaling in his matrix, it will also be applied, but in most
	 *  cases that would not be useful.
	 */
	MAT_IDN( xlate_to_0 );
	MAT_DELTAS( xlate_to_0,	 origin[X],  origin[Y],  origin[Z] );
	bn_mat_mul( mat, rot, xlate_to_0 );
	VMOVE( cur_point, origin );

	/* Compute the bottom of the first tick */
	VSET( temp, 0, -TICK_YLEN * ccw, 0 );
	MAT4X3PNT( tick_bottom, mat, temp );

	/* Compute the start of this tick's label */
	VSET( temp, 0, -NUM_YOFF * ccw, 0 );
	MAT4X3PNT( num_center, mat, temp );
	temp[X] = -char_width*ndigits;
	MAT4X3PNT( num_last_end, mat, temp );

	/* Determine the increment between ticks */
	VSET( temp, 1, 0, 0 );
	MAT4X3VEC( axis_dir, mat, temp );
	VSCALE( axis_incr, axis_dir, tick_separation );

	/* Center the title, and find left edge */
	VSET( temp, 0.5*(length - strlen(string)*char_width), -TITLE_YOFF*ccw, 0 );
	MAT4X3PNT( title_left, mat, temp );
	tp_3symbol(fp, string, title_left, rot, char_width );

	nticks = length/tick_separation+0.5;
	pdv_3move( fp, cur_point );
	for( i=0; i<=nticks; i++) {
		/*
		 *  First, draw a tick.
		 *  Then, if room, draw a numeric label.
		 *  If last tick, done.
		 *  Otherwise, advance in axis_dir direction.
		 */
		pdv_3cont( fp, tick_bottom );

		if( ndigits > 0 )  {
			double f;
			sprintf( fmt, "%%%dg", ndigits);
			sprintf( str, fmt, label_start );
			f = strlen(str) * char_width * 0.5;
			VJOIN1( num_start, num_center, -f, axis_dir );

			/* Only label this tick if the number will not
			 * overlap with the previous number.
			 */
			VSUB2( diff, num_start, num_last_end );
			if( VDOT( diff, axis_dir ) >= 0 )  {
				tp_3symbol( fp, str, num_start, rot, char_width );
				VJOIN1( num_last_end, num_center, f, axis_dir );
			}
		}

		if( i == nticks )  break;

		/* Advance, and draw next axis segment */
		pdv_3move( fp, cur_point );
		VADD2( cur_point, cur_point, axis_incr );
		VADD2( tick_bottom, tick_bottom, axis_incr );
		VADD2( num_center, num_center, axis_incr );

		label_start += label_incr;

		pdv_3cont( fp, cur_point);		/* draw axis */
	}
}

void
PL_FORTRAN(f3axis, F3AXIS)(fp, string, x, y, z, length, theta, ccw,
	ndigits, label_start, label_incr, tick_separation, char_width )
FILE		**fp;
char		*string;	/* label for axis */
float		*x,*y,*z;		/* start coordinates for axis */
float		*length;	/* length of axis */
float		*theta;		/* rotation off X-axis, in degrees */
int		*ccw;
int		*ndigits;	/* # digits wide */
float		*label_start;	/* minimum value on axis */
float		*label_incr;		/* increment for each tick */
float		*tick_separation;		/* distance between ticks */
float		*char_width;	/* character scale (size) */
{
	char buf[128];
	mat_t	mat;
	vect_t	pnt;

	VSET( pnt, *x, *y, *z );
	MAT_IDN(mat);
	bn_mat_angles( mat, 0.0, 0.0, *theta );
	strncpy( buf, string, sizeof(buf)-1 );
	buf[sizeof(buf)-1] = '\0';
	tp_3axis( *fp, buf, pnt, mat, *length, *ccw,
		*ndigits, *label_start, *label_incr,
		*tick_separation, *char_width );
}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/axis.c,v 11.7 2004/04/05 07:46:41 morrison Exp $ (BRL)";
@


11.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d32 5
a36 1
#include "conf.h"
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/axis.c,v 11.4 2001/03/31 01:56:48 morrison Exp $ (BRL)";
d51 12
a62 13
tp_3axis( fp, string, origin, rot, length, ccw,
	ndigits, label_start, label_incr, tick_separation, char_width )
FILE	*fp;
char	*string;		/* label for axis */
point_t	origin;
mat_t	rot;
double	length;			/* length of axis */
int	ccw;			/* 0=clockwise, !0=counter clockwise (ccw) */
int	ndigits;		/* # digits wide */
double	label_start;		/* label starting value */
double	label_incr;		/* label increment between ticks */
double	tick_separation;	/* plot distance between ticks */
double	char_width;		/* character scale (size) */
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/axis.c,v 11.6 2002/08/20 17:07:35 jra Exp $ (BRL)";
d51 13
a63 12
tp_3axis(FILE *fp, char *string, fastf_t *origin, fastf_t *rot, double length, int ccw, int ndigits, double label_start, double label_incr, double tick_separation, double char_width)
    	    
    	        		/* label for axis */
       	       
     	    
      	       			/* length of axis */
   	    			/* 0=clockwise, !0=counter clockwise (ccw) */
   	        		/* # digits wide */
      	            		/* label starting value */
      	           		/* label increment between ticks */
      	                	/* plot distance between ticks */
      	           		/* character scale (size) */
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d51 13
a63 12
tp_3axis(FILE *fp, char *string, fastf_t *origin, fastf_t *rot, double length, int ccw, int ndigits, double label_start, double label_incr, double tick_separation, double char_width)
    	    
    	        		/* label for axis */
       	       
     	    
      	       			/* length of axis */
   	    			/* 0=clockwise, !0=counter clockwise (ccw) */
   	        		/* # digits wide */
      	            		/* label starting value */
      	           		/* label increment between ticks */
      	                	/* plot distance between ticks */
      	           		/* character scale (size) */
@


11.4
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/axis.c,v 11.3 2000/07/11 23:30:38 cjohnson Exp $ (BRL)";
d51 12
a62 13
tp_3axis( fp, string, origin, rot, length, ccw,
	ndigits, label_start, label_incr, tick_separation, char_width )
FILE	*fp;
char	*string;		/* label for axis */
point_t	origin;
mat_t	rot;
double	length;			/* length of axis */
int	ccw;			/* 0=clockwise, !0=counter clockwise (ccw) */
int	ndigits;		/* # digits wide */
double	label_start;		/* label starting value */
double	label_incr;		/* label increment between ticks */
double	tick_separation;	/* plot distance between ticks */
double	char_width;		/* character scale (size) */
@


11.3
log
@LINT picking.  Missing includes and static const for RCSids
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/axis.c,v 11.2 1997/01/08 03:55:58 mike Exp $ (BRL)";
d98 1
a98 1
	bn_mat_idn( xlate_to_0 );
d185 1
a185 1
	bn_mat_idn(mat);
@


11.2
log
@Changed pl_mat_* to bn_mat_*
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/axis.c,v 11.1 1995/01/04 09:51:11 mike Rel4_4 mike $ (BRL)";
d36 5
@


11.1
log
@Release_4.4
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/axis.c,v 10.3 94/11/04 04:40:47 mike Exp $ (BRL)";
d93 1
a93 1
	pl_mat_idn( xlate_to_0 );
d95 1
a95 1
	pl_mat_mul( mat, rot, xlate_to_0 );
d180 2
a181 2
	pl_mat_idn(mat);
	pl_mat_angles( mat, 0.0, 0.0, *theta );
@


10.3
log
@unused vars
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/axis.c,v 10.2 94/08/11 13:20:25 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/axis.c,v 10.1 1991/10/12 06:36:31 mike Rel4_0 gdurf $ (BRL)";
a60 1
	int	direction;			/* 1=clockwise, -1=counter */
a72 2
	mat_t	xlate_to_origin;
	mat_t	mtemp;
@


10.1
log
@Release_4.0
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/axis.c,v 9.6 91/07/02 04:14:05 mike Exp $ (BRL)";
d31 2
@


9.6
log
@Modified libplot3 to have private version of LIBRT's matrix library,
by running SED over the source to librt/mat.c to create, e.g., pl_mat_inv
so that LIBRT didn't need to be linked in, just to do plotting.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/axis.c,v 9.5 91/07/02 01:14:44 mike Exp $ (BRL)";
@


9.5
log
@TIG-Pack is now part of libplot3
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/axis.c,v 9.4 91/05/31 11:26:00 mike Exp $ (BRL)";
d94 1
a94 1
	mat_idn( xlate_to_0 );
d96 1
a96 1
	mat_mul( mat, rot, xlate_to_0 );
d181 2
a182 2
	mat_idn(mat);
	mat_angles( mat, 0.0, 0.0, *theta );
@


9.4
log
@ANSI prototypes
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libtig/RCS/axis.c,v 9.3 91/05/09 22:14:53 sue Exp $ (BRL)";
a37 1
#include "./tig.h"
@


9.3
log
@Changed from pl_strncpy() [which didn't exist] to strncpy().
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libtig/RCS/axis.c,v 9.2 90/11/25 11:41:03 cjohnson Exp $ (BRL)";
d37 1
d163 1
a163 1
F(f3axis, F3AXIS)(fp, string, x, y, z, length, theta, ccw,
@


9.2
log
@Change the fortran routines to use the F macro from
libplot3/fortran.c to generate subroutine names. (case and trailing 
underscore)
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/libtig/RCS/axis.c,v 9.1 89/05/19 05:49:40 mike Rel3_5 $ (BRL)";
d183 2
a184 1
	pl_strncpy( buf, string, sizeof(buf) );
@


9.1
log
@Release_3.5
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: axis.c,v 8.1 88/10/05 00:28:40 mike Rel3_0 $ (BRL)";
d37 1
d162 1
a162 1
F3AXIS(fp, string, x, y, z, length, theta, ccw,
@


8.1
log
@Release_3.0
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: axis.c,v 7.5 88/05/13 22:20:00 mike Exp $ (BRL)";
@


7.5
log
@lint fix
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: axis.c,v 7.4 88/02/08 23:41:18 mike Locked $ (BRL)";
@


7.4
log
@Latest round of cleanups and name changes.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d42 1
a42 1

d160 1
@


7.3
log
@More 3D work, new calling sequences
@
text
@a3 3
 *	Terminal Independant Graphics Display Package
 *		Mike Muuss  August 01, 1978
 *
d15 12
d28 4
d43 1
a43 1
tp_axis( fp, string, origin, rot, length, ccw,
d160 1
a160 1
FAXIS(fp, string, x, y, z, length, theta, ccw,
d181 2
a182 2
	tp_strncpy( buf, string, sizeof(buf) );
	tp_axis( *fp, buf, pnt, mat, *length, *ccw,
@


7.2
log
@Beginning of new version for floating point.
@
text
@d22 2
a23 3
#define	TICK_YLEN	(cscale)	/* tick is 1 character height */
#define	NUM_YOFF	(3*cscale)	/* numbers offset from line */
#define	TITLE_YOFF	(5*cscale)	/* title offset from line */
d25 3
a27 6
/* Rotation macros */
#define	X(a,b)	((a)*xrot - (b)*yrot)
#define Y(a,b)	((a)*yrot + (b)*xrot)
#define	ROT(a,b)	temp=X(a-x,b-y) + x;\
			b=Y(a-x,b-y) + y;\
			a=temp
d30 13
a42 11
tp_axis( fp, string, x, y, length, theta, ndigits, minval, incr, unit, cscale )
FILE		*fp;
char		*string;	/* label for axis */
double		x,y;		/* start coordinates for axis */
double		length;		/* length of axis */
double		theta;		/* rotation off X-axis, in degrees */
int		ndigits;	/* # digits wide */
double		minval;		/* minimum value on axis */
double		incr;		/* increment for each tick */
double		unit;		/* distance between ticks */
double		cscale;		/* character scale (size) */
d44 1
a44 8
	register int i;				/* index  variable */
	double	xrot, yrot;			/* direction & rotation */
	double	temp;				/* Work area for ROT macro */
	double	xincr, yincr;			/* increments for rotation */
	double	xbott, ybott;			/* address of bottom of tick */
	double	xnum, ynum;			/* addr of ticks number */
	double	xtitle, ytitle;			/* addr of axis title */
	double	xlab_end, ylab_end;			/* last number pos */
d47 16
d65 4
a68 5
	direction = 1;				/* normal is clockwise ticks */
	if( length < 0 )  {
		direction = (-1);		/* he wants counterclockwise */
		length = (-length);
	}
d70 1
a70 2
	xrot = cos( 0.0174533 * theta );
	yrot = sin( 0.0174533 * theta );
d72 13
d86 2
a87 3
	xbott = x;
	ybott = y - TICK_YLEN * direction;
	ROT( xbott, ybott );
d90 4
a93 3
	xnum = x;
	ynum = y - NUM_YOFF * direction;
	ROT( xnum, ynum );
a94 5
	/* Center the title */
	xtitle = x + ( length - strlen( string ) * cscale ) / 2;
	ytitle = y - TITLE_YOFF * direction;
	ROT( xtitle, ytitle );

d96 3
a98 2
	xincr = X( unit, 0 );
	yincr = Y( unit, 0 );
d100 4
a103 2
	/* Draw the title */
	tp_symbol(fp, string, xtitle, ytitle, cscale, theta);
d105 10
a114 1
	nticks = length/unit+0.5;		/* number of ticks to do */
d116 6
a121 7
	/*
	 *  Draw the axis & label as we go.
	 *  Do left-most tick, then repeat:
	 *  across, down, label.
	 */
	pd_move( fp, xbott, ybott );
	pd_cont( fp, x, y );
d123 9
a131 3
	/* initial label */
	if( ndigits > 0 )
		tp_number( fp, minval, xnum, ynum, cscale, theta, ndigits );
d133 1
a133 2
	xlab_end = xnum + X( ndigits * cscale, 0 );
	ylab_end = ynum + Y( ndigits * cscale, 0 );
d135 5
a139 2
	for( i=0; i<nticks; i++) {
		pd_move( fp, x, y );
d141 1
a141 4
		/* advance x & y for next segment */
		x += xincr;
		xbott += xincr;
		xnum += xincr;
d143 1
a143 21
		y += yincr;
		ybott += yincr;
		ynum += yincr;

		minval += incr;

		pd_cont( fp, x, y );		/* draw segment */
		pd_cont( fp, xbott, ybott );	/* draw tick */

		/*
		 *  Only label this tick if it is beyond
		 *  the last label.
		 */
		if( ndigits <= 0 )  continue;
		if( ( (xincr >= 0) ? (x < xlab_end) : (x > xlab_end) ) ||
		    ( (yincr >= 0) ? (y < ylab_end) : (y > ylab_end) ) )
			continue;

		tp_number( fp, minval, xnum, ynum, cscale, theta, ndigits );
		xlab_end = xnum + X( ndigits * cscale, 0 );
		ylab_end = ynum + Y( ndigits * cscale, 0 );
d147 2
a148 1
FAXIS(fp, string, x, y, length, theta, ndigits, minval, incr, unit, cscale )
d151 1
a151 1
float		*x,*y;		/* start coordinates for axis */
d154 1
d156 4
a159 4
float		*minval;	/* minimum value on axis */
float		*incr;		/* increment for each tick */
float		*unit;		/* distance between ticks */
float		*cscale;	/* character scale (size) */
d162 6
d169 3
a171 2
	tp_axis( *fp, buf, *x, *y, *length,
		*theta, *ndigits, *minval, *incr, *unit, *cscale );
@


7.1
log
@Release 2.3
@
text
@d37 2
a38 2
register int	x,y;		/* start coordinates for axis */
int		length;		/* length of axis */
d43 1
a43 1
int		unit;		/* distance between ticks */
d48 6
a53 5
	int	temp;				/* Work area for ROT macro */
	int	xincr, yincr;			/* increments for rotation */
	int	xbott, ybott;			/* address of bottom of tick */
	int	xnum, ynum;			/* addr of ticks number */
	int	xtitle, ytitle;			/* addr of axis title */
d55 1
a55 4
	int	n;
	int	label_width;
	int	space;
	int	xlast, ylast;			/* last number pos */
d89 1
a89 1
	length = (length+unit-1)/unit;		/* number of ticks to do */
d96 2
a97 2
	pl_move( fp, xbott, ybott );
	pl_cont( fp, x, y );
a101 5
	xlast = ndigits * cscale;
	ylast = ndigits * cscale;
	ROT( xlast, ylast );
	xlast += xnum;
	ylast += ynum;
d103 2
a104 2
	for( i=0; i<length; i++) {
		pl_move( fp, x, y );
d106 3
d113 1
d120 2
a121 1
		pl_cont( fp, x, y );		/* draw segment */
d124 1
a124 1
		 *  Draw and label this tick if it is beyond
d127 3
a129 2
		if( ( (xincr >= 0) ? (x <= xlast) : (x >= xlast) ) ||
		    ( (yincr >= 0) ? (y <= ylast) : (y >= ylast) ) )
d132 3
a134 3
		pl_cont( fp, xbott, ybott );	/* draw tick */
		if( ndigits > 0 )
			tp_number( fp, minval, xnum, ynum, cscale, theta, ndigits );
d136 18
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


1.1
log
@Initial revision
@
text
@@
