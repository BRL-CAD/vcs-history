head	1.13;
access;
symbols
	ansi-20040405-merged:1.11
	postmerge-20040405-ansi:1.11
	premerge-20040404-ansi:1.11
	postmerge-autoconf:1.11
	autoconf-freeze:1.11
	premerge-autoconf:1.11
	ansi-20040316-freeze:1.11
	postmerge-20040315-windows:1.11
	premerge-20040315-windows:1.11
	windows-20040315-freeze:1.11
	autoconf-20031203:1.11
	autoconf-20031202:1.11
	autoconf-branch:1.11.0.12
	phong-branch:1.11.0.10
	photonmap-branch:1.11.0.8
	rel-6-1-DP:1.11
	windows-branch:1.11.0.6
	rel-6-0-2:1.11
	ansi-branch:1.11.0.4
	rel-6-0-1-branch:1.11.0.2
	hartley-6-0-post:1.11
	hartley-6-0-pre:1.11
	rel-6-0-1:1.11
	rel-6-0:1.11
	rel-5-4:1.10
	offsite-5-3-pre:1.11
	rel-5-3:1.10
	rel-5-2:1.10
	rel-5-1-branch:1.10.0.2
	rel-5-1:1.10
	rel-5-0:1.9
	rel-5-0-beta:1.9
	rel-4-5:1.6
	ctj-4-5-post:1.5
	ctj-4-5-pre:1.5;
locks; strict;
comment	@ * @;


1.13
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	1.12;

1.12
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.18.18.10.33;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	99.12.29.20.27.02;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	99.01.13.08.01.17;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	99.01.12.07.15.47;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	99.01.12.05.53.16;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	97.08.26.04.48.17;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.10.10.03.25.42;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	96.09.20.00.22.49;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.09.13.04.27.35;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	96.09.05.02.41.55;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	96.09.05.02.37.31;	author butler;	state Exp;
branches;
next	;


desc
@Wavelet transforms
@


1.13
log
@moved to src/
@
text
@/*			W A V E L E T . C
 *
 *  This is a standard wavelet library that takes a given data buffer of some data
 *  type and then performs a wavelet transform on that data.  The transform
 *  operations available are to either decompose or reconstruct a signal into it's
 *  corresponding wavelet form based on the haar wavelet.
 *
 *  Wavelet decompose/reconstruct operations
 *
 *	bn_wlt_haar_1d_double_decompose(tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_1d_float_decompose (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_1d_char_decompose  (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_1d_short_decompose (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_1d_int_decompose   (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_1d_long_decompose  (tbuffer, buffer, dimen, channels, limit)
 *
 *	bn_wlt_haar_1d_double_reconstruct(tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_1d_float_reconstruct (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_1d_char_reconstruct  (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_1d_short_reconstruct (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_1d_int_reconstruct   (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_1d_long_reconstruct  (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *
 *	bn_wlt_haar_2d_double_decompose(tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_2d_float_decompose (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_2d_char_decompose  (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_2d_short_decompose (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_2d_int_decompose   (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_haar_2d_long_decompose  (tbuffer, buffer, dimen, channels, limit)
 *
 *	bn_wlt_haar_2d_double_reconstruct(tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_float_reconstruct (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_char_reconstruct  (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_short_reconstruct (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_int_reconstruct   (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_long_reconstruct  (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *
 *	bn_wlt_haar_2d_double_decompose2(tbuffer, buffer, width, height, channels, limit)
 *	bn_wlt_haar_2d_float_decompose2 (tbuffer, buffer, width, height, channels, limit)
 *	bn_wlt_haar_2d_char_decompose2  (tbuffer, buffer, width, height, channels, limit)
 *	bn_wlt_haar_2d_short_decompose2 (tbuffer, buffer, width, height, channels, limit)
 *	bn_wlt_haar_2d_int_decompose2   (tbuffer, buffer, width, height, channels, limit)
 *	bn_wlt_haar_2d_long_decompose2  (tbuffer, buffer, width, height, channels, limit)
 *
 *	bn_wlt_haar_2d_double_reconstruct2(tbuffer, buffer, width, height, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_float_reconstruct2 (tbuffer, buffer, width, height, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_char_reconstruct2  (tbuffer, buffer, width, height, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_short_reconstruct2 (tbuffer, buffer, width, height, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_int_reconstruct2   (tbuffer, buffer, width, height, channels, sub_sz, limit)
 *	bn_wlt_haar_2d_long_reconstruct2  (tbuffer, buffer, width, height, channels, sub_sz, limit)
 *	
 *  
 *  For greatest accuracy, it is preferable to convert everything to "double"
 *  and decompose/reconstruct with that.  However, there are useful 
 *  properties to performing the decomposition and/or reconstruction in 
 *  various data types (most notably char).
 *
 *  Rather than define all of these routines explicitly, we define
 *  2 macros "decompose" and "reconstruct" which embody the structure of
 *  the function (which is common to all of them).  We then instatiate
 *  these macros once for each of the data types.  It's ugly, but it
 *  assures that a change to the structure of one operation type 
 *  (decompose or reconstruct) occurs for all data types.
 *
 *
 *
 *
 *  bn_wlt_haar_1d_*_decompose(tbuffer, buffer, dimen, channels, limit)
 *  Parameters:
 *	tbuffer     a temporary data buffer 1/2 as large as "buffer". See (1) below.
 *	buffer      pointer to the data to be decomposed
 *	dimen    the number of samples in the data buffer 
 *	channels the number of values per sample
 *	limit    the extent of the decomposition
 *
 *  Perform a Haar wavelet decomposition on the data in buffer "buffer".  The
 *  decomposition is done "in place" on the data, hence the values in "buffer"
 *  are not preserved, but rather replaced by their decomposition.
 *  The number of original samples in the buffer (parameter "dimen") and the
 *  decomposition limit ("limit") must both be a power of 2 (e.g. 512, 1024).
 *  The buffer is decomposed into "average" and "detail" halves until the
 *  size of the "average" portion reaches "limit".  Simultaneous 
 *  decomposition of multi-plane (e.g. pixel) data, can be performed by
 *  indicating the number of planes in the "channels" parameter.
 *  
 *  (1) The process requires a temporary buffer which is 1/2 the size of the
 *  longest span to be decomposed.  If the "tbuffer" argument is non-null then
 *  it is a pointer to a temporary buffer.  If the pointer is NULL, then a
 *  local temporary buffer will be allocated (and freed).
 *
 *  Examples:
 *	double dbuffer[512], cbuffer[256];
 *	...
 *	bn_wlt_haar_1d_double_decompose(cbuffer, dbuffer, 512, 1, 1);
 *
 *    performs complete decomposition on the data in array "dbuffer".
 *
 *	double buffer[3][512];	 /_* 512 samples, 3 values/sample (e.g. RGB?)*_/
 *	double tbuffer[3][256];	 /_* the temporary buffer *_/
 *	...
 *	bn_wlt_haar_1d_double_decompose(tbuffer, buffer, 512, 3, 1);
 *
 *    This will completely decompose the data in buffer.  The first sample will
 *    be the average of all the samples.  Alternatively:
 *
 *	bn_wlt_haar_1d_double_decompose(tbuffer, buffer, 512, 3, 64);
 *
 *    decomposes buffer into a 64-sample "average image" and 3 "detail" sets.
 *
 *
 *
 *  bn_wlt_haar_1d_*_reconstruct(tbuffer, buffer, dimen, channels, sub_sz, limit)
 *
 *
 *  Author -
 *	Lee A. Butler
 *
 *  Modifications -
 *      Christopher Sean Morrison
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"


#ifdef __STDC__
#define decompose_1d(DATATYPE) bn_wlt_haar_1d_ ## DATATYPE ## _decompose
#else
#define decompose_1d(DATATYPE) bn_wlt_haar_1d_/**/DATATYPE/**/_decompose
#endif



#define make_wlt_haar_1d_decompose(DATATYPE)  \
void \
decompose_1d(DATATYPE) \
( tbuffer, buffer, dimen, channels, limit ) \
DATATYPE *tbuffer;		/* temporary buffer */ \
DATATYPE *buffer;		/* data buffer */ \
unsigned long dimen;	/* # of samples in data buffer */ \
unsigned long channels;	/* # of data values per sample */ \
unsigned long limit;	/* extent of decomposition */ \
{ \
	register DATATYPE *detail; \
	register DATATYPE *avg; \
	unsigned long img_size; \
	unsigned long half_size; \
	int do_free = 0; \
	unsigned long x, x_tmp, d, i, j; \
	register fastf_t onehalf = (fastf_t)0.5; \
\
	CK_POW_2( dimen ); \
\
	if ( ! tbuffer ) { \
		tbuffer = (DATATYPE *)bu_malloc( \
				(dimen/2) * channels * sizeof( *buffer ), \
				"1d wavelet buffer"); \
		do_free = 1; \
	} \
\
	/* each iteration of this loop decomposes the data into 2 halves: \
	 * the "average image" and the "image detail" \
	 */ \
	for (img_size = dimen ; img_size > limit ; img_size = half_size ){ \
\
		half_size = img_size/2; \
		 \
		detail = tbuffer; \
		avg = buffer; \
\
		for ( x=0 ; x < img_size ; x += 2 ) { \
			x_tmp = x*channels; \
\
			for (d=0 ; d < channels ; d++, avg++, detail++) { \
				i = x_tmp + d; \
				j = i + channels; \
				*detail = (buffer[i] - buffer[j]) * onehalf; \
				*avg    = (buffer[i] + buffer[j]) * onehalf; \
			} \
		} \
\
		/* "avg" now points to the first element AFTER the "average \
		 * image" section, and hence is the START of the "image  \
		 * detail" portion.  Convenient, since we now want to copy \
		 * the contents of "tbuffer" (which holds the image detail) into \
		 * place. \
		 */ \
		memcpy(avg, tbuffer, sizeof(*buffer) * channels * half_size); \
	} \
	 \
	if (do_free) \
		bu_free( (genptr_t)tbuffer, "1d wavelet buffer"); \
}


#if defined(__STDC__) 
#define reconstruct(DATATYPE ) bn_wlt_haar_1d_ ## DATATYPE ## _reconstruct
#else
#define reconstruct(DATATYPE) bn_wlt_haar_1d_/**/DATATYPE/**/_reconstruct
#endif

#define make_wlt_haar_1d_reconstruct( DATATYPE ) \
void \
reconstruct(DATATYPE) \
( tbuffer, buffer, dimen, channels, subimage_size, limit )\
DATATYPE *tbuffer; \
DATATYPE *buffer; \
unsigned long dimen; \
unsigned long channels; \
unsigned long subimage_size; \
unsigned long limit; \
{ \
	register DATATYPE *detail; \
	register DATATYPE *avg; \
	unsigned long img_size; \
	unsigned long dbl_size; \
	int do_free = 0; \
	unsigned long x_tmp, d, x, i, j; \
\
	CK_POW_2( subimage_size ); \
	CK_POW_2( dimen ); \
	CK_POW_2( limit ); \
\
        if ( ! (subimage_size < dimen) ) { \
		bu_log("%s:%d Dimension %d should be greater than subimage size (%d)\n", \
			__FILE__, __LINE__, dimen, subimage_size); \
		bu_bomb("reconstruct"); \
	} \
\
        if ( ! (subimage_size < limit) ) { \
		bu_log("%s:%d Channels limit %d should be greater than subimage size (%d)\n", \
			__FILE__, __LINE__, limit, subimage_size); \
		bu_bomb("reconstruct"); \
	} \
\
        if ( ! (limit <= dimen) ) { \
		bu_log("%s:%d Dimension %d should be greater than or equal to the channels limit (%d)\n", \
			__FILE__, __LINE__, dimen, limit); \
		bu_bomb("reconstruct"); \
	} \
\
\
	if ( ! tbuffer ) { \
		tbuffer = ( DATATYPE *)bu_malloc((dimen/2) * channels * sizeof( *buffer ), \
				"1d wavelet reconstruct tmp buffer"); \
		do_free = 1; \
	} \
\
	/* Each iteration of this loop reconstructs an image twice as \
	 * large as the original using a "detail image". \
	 */ \
	for (img_size=subimage_size ; img_size < limit ; img_size=dbl_size) { \
		dbl_size = img_size * 2; \
\
		d = img_size * channels; \
		detail = &buffer[ d ]; \
\
		/* copy the original or "average" data to temporary buffer */ \
		avg = tbuffer; \
		memcpy(avg, buffer, sizeof(*buffer) * d ); \
\
\
		for (x=0 ; x < dbl_size ; x += 2 ) { \
			x_tmp = x * channels; \
			for (d=0 ; d < channels ; d++, avg++, detail++ ) { \
				i = x_tmp + d; \
				j = i + channels; \
				buffer[i] = *avg + *detail; \
				buffer[j] = *avg - *detail; \
			} \
		} \
	} \
\
	if (do_free) \
		bu_free( (genptr_t)tbuffer, \
			"1d wavelet reconstruct tmp buffer"); \
}

/* Believe it or not, this is where the actual code is generated */

make_wlt_haar_1d_decompose(double)
make_wlt_haar_1d_reconstruct(double)

make_wlt_haar_1d_decompose(float)
make_wlt_haar_1d_reconstruct(float)

make_wlt_haar_1d_decompose(char)
make_wlt_haar_1d_reconstruct(char)

make_wlt_haar_1d_decompose(int)
make_wlt_haar_1d_reconstruct(int)

make_wlt_haar_1d_decompose(short)
make_wlt_haar_1d_reconstruct(short)

make_wlt_haar_1d_decompose(long)
make_wlt_haar_1d_reconstruct(long)


#ifdef __STDC__
#define decompose_2d( DATATYPE ) bn_wlt_haar_2d_ ## DATATYPE ## _decompose
#else
#define decompose_2d(DATATYPE) bn_wlt_haar_2d_/* */DATATYPE/* */_decompose
#endif

#define make_wlt_haar_2d_decompose(DATATYPE) \
void \
decompose_2d(DATATYPE) \
(tbuffer, buffer, dimen, channels, limit) \
DATATYPE *tbuffer; \
DATATYPE *buffer; \
unsigned long dimen; \
unsigned long channels; \
unsigned long limit; \
{ \
	register DATATYPE *detail; \
	register DATATYPE *avg; \
	unsigned long img_size; \
	unsigned long half_size; \
	unsigned long x, y, x_tmp, y_tmp, d, i, j; \
	register fastf_t onehalf = (fastf_t)0.5; \
\
	CK_POW_2( dimen ); \
\
	if ( ! tbuffer ) { \
		tbuffer = (DATATYPE *)bu_malloc( \
				(dimen/2) * channels * sizeof( *buffer ), \
				"1d wavelet buffer"); \
	} \
\
	/* each iteration of this loop decomposes the data into 4 quarters: \
	 * the "average image", the horizontal detail, the vertical detail \
	 * and the horizontal-vertical detail \
	 */ \
	for (img_size = dimen ; img_size > limit ; img_size = half_size ) { \
		half_size = img_size/2; \
\
		/* do a horizontal detail decomposition first */ \
		for (y=0 ; y < img_size ; y++ ) { \
			y_tmp = y * dimen * channels; \
\
			detail = tbuffer; \
			avg = &buffer[y_tmp]; \
\
			for (x=0 ; x < img_size ; x += 2 ) { \
				x_tmp = x*channels + y_tmp; \
\
				for (d=0 ; d < channels ; d++, avg++, detail++){ \
					i = x_tmp + d; \
					j = i + channels; \
					*detail = (buffer[i] - buffer[j]) * onehalf; \
					*avg    = (buffer[i] + buffer[j]) * onehalf; \
				} \
			} \
			/* "avg" now points to the first element AFTER the \
			 * "average image" section, and hence is the START \
			 * of the "image detail" portion.  Convenient, since \
			 * we now want to copy the contents of "tbuffer" (which \
			 * holds the image detail) into place. \
			 */ \
			memcpy(avg, tbuffer, sizeof(*buffer) * channels * half_size); \
		} \
\
		/* Now do the vertical decomposition */ \
		for (x=0 ; x < img_size ; x ++ ) { \
			x_tmp = x*channels; \
\
			detail = tbuffer; \
			avg = &buffer[x_tmp]; \
\
			for (y=0 ; y < img_size ; y += 2) { \
				y_tmp =y*dimen*channels + x_tmp; \
\
				for (d=0 ; d < channels ; d++, avg++, detail++) { \
					i = y_tmp + d; \
					j = i + dimen*channels; \
					*detail = (buffer[i] - buffer[j]) * onehalf; \
					*avg    = (buffer[i] + buffer[j]) * onehalf; \
				} \
				avg += (dimen-1)*channels; \
			} \
\
			/* "avg" now points to the element ABOVE the \
			 * last "average image" pixel or the first "detail" \
			 * location in the user buffer. \
			 * \
			 * There is no memcpy for the columns, so we have to \
			 * copy the data back to the user buffer ourselves. \
			 */ \
			detail = tbuffer; \
			for (y=half_size ; y < img_size ; y++) { \
				for (d=0; d < channels ; d++) { \
					*avg++ = *detail++; \
				} \
				avg += (dimen-1)*channels; \
			} \
		} \
	} \
}


#ifdef __STDC__
#define reconstruct_2d( DATATYPE ) bn_wlt_haar_2d_ ## DATATYPE ## _reconstruct
#else
#define reconstruct_2d(DATATYPE) bn_wlt_haar_2d_/* */DATATYPE/* */_reconstruct
#endif

#define make_wlt_haar_2d_reconstruct(DATATYPE) \
void \
reconstruct_2d(DATATYPE) \
(tbuf, buf, width, channels, avg_size, limit) \
DATATYPE *tbuf; \
DATATYPE *buf; \
unsigned long width; \
unsigned long channels; \
unsigned long avg_size; \
unsigned long limit; \
{ \
	register DATATYPE *detail; \
	register DATATYPE *avg; \
	unsigned long img_size; \
	unsigned long dbl_size; \
	unsigned long x_tmp, d, x, i, j; \
	unsigned long y, row_len, row_start; \
 \
	CK_POW_2( avg_size ); \
	CK_POW_2( width ); \
	CK_POW_2( limit ); \
 \
	/* XXX check for: \
	 * subimage_size < dimen && subimage_size < limit \
	 * limit <= dimen \
	 */ \
 \
 \
	if ( ! tbuf ) { \
		tbuf = ( DATATYPE *)bu_malloc((width/2) * channels * sizeof( *buf ), \
				"1d wavelet reconstruct tmp buffer"); \
	} \
 \
	row_len = width * channels; \
 \
	/* Each iteration of this loop reconstructs an image twice as \
	 * large as the original using a "detail image". \
	 */ \
 \
	for (img_size = avg_size ; img_size < limit ; img_size = dbl_size) { \
		dbl_size = img_size * 2; \
		 \
		 \
		/* first is a vertical reconstruction */ \
		for (x=0 ; x < dbl_size ; x++ ) { \
			/* reconstruct column x */ \
 \
			/* copy column of "average" data to tbuf */ \
			x_tmp = x*channels; \
			for (y=0 ; y < img_size ; y++) { \
				i = x_tmp + y*row_len; \
				j = y * channels; \
				for (d=0 ; d < channels ; d++) { \
					tbuf[j++] = buf[i++]; \
				} \
			} \
			avg = tbuf; \
			detail = &buf[x_tmp + img_size*row_len]; \
 \
			/* reconstruct column */ \
			for (y=0 ; y < dbl_size ; y += 2) { \
 \
				i = x_tmp + y*row_len; \
				j = i + row_len; \
 \
				for (d=0 ; d < channels ; d++,avg++,detail++){ \
					buf[i++] = *avg + *detail; \
					buf[j++] = *avg - *detail; \
				} \
				detail += row_len - channels; \
			} \
		} \
 \
		/* now a horizontal reconstruction */ \
		for (y=0 ; y < dbl_size ; y++ ) { \
			/* reconstruct row y */ \
 \
			/* copy "average" row to tbuf and set pointer to \
			 * begining of "detail" \
			 */ \
			d = img_size * channels; \
			row_start = y*row_len; \
 \
 \
			avg = &buf[ row_start ]; \
			detail = &buf[ row_start + d]; \
 \
			memcpy(tbuf, avg, sizeof(*buf) * d ); \
			avg = tbuf; \
 \
			/* reconstruct row */ \
			for (x=0 ; x < dbl_size ; x += 2 ) { \
				x_tmp = x * channels; \
				i = row_start + x * channels; \
				j = i + channels; \
 \
				for (d=0 ; d < channels ; d++,avg++,detail++){ \
					buf[i++] = *avg + *detail; \
					buf[j++] = *avg - *detail; \
				} \
			} \
		} \
	} \
}


make_wlt_haar_2d_decompose(double)
make_wlt_haar_2d_decompose(float)
make_wlt_haar_2d_decompose(char)
make_wlt_haar_2d_decompose(int)
make_wlt_haar_2d_decompose(short)
make_wlt_haar_2d_decompose(long)

make_wlt_haar_2d_reconstruct(double)
make_wlt_haar_2d_reconstruct(float)
make_wlt_haar_2d_reconstruct(char)
make_wlt_haar_2d_reconstruct(int)
make_wlt_haar_2d_reconstruct(short)
make_wlt_haar_2d_reconstruct(long)



#ifdef __STDC__
#define decompose_2d_2( DATATYPE ) bn_wlt_haar_2d_ ## DATATYPE ## _decompose2
#else
#define decompose_2d_2(DATATYPE) bn_wlt_haar_2d_/* */DATATYPE/* */_decompose2
#endif

#define make_wlt_haar_2d_decompose2(DATATYPE) \
void \
decompose_2d_2(DATATYPE) \
(tbuffer, buffer, width, height, channels, limit) \
DATATYPE *tbuffer; \
DATATYPE *buffer; \
unsigned long width; \
unsigned long height; \
unsigned long channels; \
unsigned long limit; \
{ \
	register DATATYPE *detail; \
	register DATATYPE *avg; \
	unsigned long img_wsize; \
	unsigned long img_hsize; \
	unsigned long half_wsize; \
	unsigned long half_hsize; \
	unsigned long x, y, x_tmp, y_tmp, d, i, j; \
	register fastf_t onehalf = (fastf_t)0.5; \
\
	CK_POW_2( width ); \
	CK_POW_2( height ); \
\
        /* create a temp buffer the half the size of the larger dimension \
         */ \
	if ( ! tbuffer ) { \
		tbuffer = (DATATYPE *)bu_malloc( \
				(((width>height)?width:height)/2) * channels * sizeof( *buffer ), \
				"1d wavelet buffer"); \
	} \
\
	/* each iteration of this loop decomposes the data into 4 quarters: \
	 * the "average image", the horizontal detail, the vertical detail \
	 * and the horizontal-vertical detail \
	 */ \
	for (img_wsize = width, img_hsize = height ; (img_wsize > limit) && (img_hsize > limit) ; img_wsize = half_wsize, img_hsize = half_hsize ) { \
		half_wsize = img_wsize/2; \
		half_hsize = img_hsize/2; \
\
		/* do a horizontal detail decomposition first */ \
		for (y=0 ; y < img_hsize ; y++ ) { \
			y_tmp = y * width * channels; \
\
			detail = tbuffer; \
			avg = &buffer[y_tmp]; \
\
			for (x=0 ; x < img_wsize ; x += 2 ) { \
				x_tmp = x*channels + y_tmp; \
\
				for (d=0 ; d < channels ; d++, avg++, detail++){ \
					i = x_tmp + d; \
					j = i + channels; \
					*detail = (buffer[i] - buffer[j]) * onehalf; \
					*avg    = (buffer[i] + buffer[j]) * onehalf; \
				} \
			} \
			/* "avg" now points to the first element AFTER the \
			 * "average image" section, and hence is the START \
			 * of the "image detail" portion.  Convenient, since \
			 * we now want to copy the contents of "tbuffer" (which \
			 * holds the image detail) into place. \
			 */ \
			memcpy(avg, tbuffer, sizeof(*buffer) * channels * half_wsize); \
		} \
\
		/* Now do the vertical decomposition */ \
		for (x=0 ; x < img_wsize ; x ++ ) { \
			x_tmp = x*channels; \
\
			detail = tbuffer; \
			avg = &buffer[x_tmp]; \
\
			for (y=0 ; y < img_hsize ; y += 2) { \
				y_tmp =y*width*channels + x_tmp; \
\
				for (d=0 ; d < channels ; d++, avg++, detail++) { \
					i = y_tmp + d; \
					j = i + width*channels; \
					*detail = (buffer[i] - buffer[j]) * onehalf; \
					*avg    = (buffer[i] + buffer[j]) * onehalf; \
				} \
				avg += (width-1)*channels; \
			} \
\
			/* "avg" now points to the element ABOVE the \
			 * last "average image" pixel or the first "detail" \
			 * location in the user buffer. \
			 * \
			 * There is no memcpy for the columns, so we have to \
			 * copy the data back to the user buffer ourselves. \
			 */ \
			detail = tbuffer; \
			for (y=half_hsize ; y < img_hsize ; y++) { \
				for (d=0; d < channels ; d++) { \
					*avg++ = *detail++; \
				} \
				avg += (width-1)*channels; \
			} \
		} \
	} \
}

make_wlt_haar_2d_decompose2(double)
make_wlt_haar_2d_decompose2(float)
make_wlt_haar_2d_decompose2(char)
make_wlt_haar_2d_decompose2(int)
make_wlt_haar_2d_decompose2(short)
make_wlt_haar_2d_decompose2(long)

@


1.12
log
@change conf.h to a wrapped config.h
@
text
@@


1.11
log
@Patches for compiling under RedHat 7.0
@
text
@d129 5
a133 1
#include "conf.h"
@


1.10
log
@Eliminated some unused variables
@
text
@d129 2
d132 4
@


1.9
log
@Merged Chris Morrison's name changes with the new 2d reconstruction
implementation.
@
text
@a327 1
	register DATATYPE *ptr; \
a330 1
	int do_free = 0; \
a338 1
		do_free = 1; \
a432 1
	int do_free = 0; \
d434 1
a434 1
	unsigned long y_tmp, y, row_len, row_start; \
a448 1
		do_free = 1; \
a558 1
	register DATATYPE *ptr; \
a563 1
	int do_free = 0; \
a574 1
		do_free = 1; \
@


1.8
log
@updated the names of the functions to include the _haar for the
wavelet function definitions

added the functions necessary to specify height and width images,
instead of just square images.  image dimensions must still be a
power of 2, though.  that is something for later.
@
text
@d414 115
d536 6
d544 1
d662 1
@


1.7
log
@modified wavelet.c throughout (minor changes)
changes include extra notes at beginning, variables renamed, and
changed a divide by 2.0 to a multiply by 0.5
@
text
@d3 5
d10 41
a50 28
 *	bn_wlt_1d_double_decompose(tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_1d_float_decompose (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_1d_char_decompose  (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_1d_short_decompose (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_1d_int_decompose   (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_1d_long_decompose  (tbuffer, buffer, dimen, channels, limit)
 *
 *	bn_wlt_1d_double_reconstruct(tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_1d_float_reconstruct (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_1d_char_reconstruct  (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_1d_short_reconstruct (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_1d_int_reconstruct   (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_1d_long_reconstruct  (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *
 *	bn_wlt_2d_double_decompose(tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_2d_float_decompose (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_2d_char_decompose  (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_2d_short_decompose (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_2d_int_decompose   (tbuffer, buffer, dimen, channels, limit)
 *	bn_wlt_2d_long_decompose  (tbuffer, buffer, dimen, channels, limit)
 *
 *	bn_wlt_2d_double_reconstruct(tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_2d_float_reconstruct (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_2d_char_reconstruct  (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_2d_short_reconstruct (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_2d_int_reconstruct   (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *	bn_wlt_2d_long_reconstruct  (tbuffer, buffer, dimen, channels, sub_sz, limit)
 *
d68 1
a68 1
 *  bn_wlt_1d_*_decompose(tbuffer, buffer, dimen, channels, limit)
d94 1
a94 1
 *	bn_wlt_1d_double_decompose(cbuffer, dbuffer, 512, 1, 1);
d101 1
a101 1
 *	bn_wlt_1d_double_decompose(tbuffer, buffer, 512, 3, 1);
d106 1
a106 1
 *	bn_wlt_1d_double_decompose(tbuffer, buffer, 512, 3, 64);
d112 1
a112 1
 *  bn_wlt_1d_*_reconstruct(tbuffer, buffer, dimen, channels, sub_sz, limit)
d137 1
a137 1
#define decompose_1d(DATATYPE) bn_wlt_1d_ ## DATATYPE ## _decompose
d139 1
a139 1
#define decompose_1d(DATATYPE) bn_wlt_1d_/**/DATATYPE/**/_decompose
d144 1
a144 1
#define make_wlt_1d_decompose(DATATYPE)  \
d207 1
a207 1
#define reconstruct(DATATYPE ) bn_wlt_1d_ ## DATATYPE ## _reconstruct
d209 1
a209 1
#define reconstruct(DATATYPE) bn_wlt_1d_/**/DATATYPE/**/_reconstruct
d212 1
a212 1
#define make_wlt_1d_reconstruct( DATATYPE ) \
d291 2
a292 2
make_wlt_1d_decompose(double)
make_wlt_1d_reconstruct(double)
d294 2
a295 2
make_wlt_1d_decompose(float)
make_wlt_1d_reconstruct(float)
d297 2
a298 2
make_wlt_1d_decompose(char)
make_wlt_1d_reconstruct(char)
d300 2
a301 2
make_wlt_1d_decompose(int)
make_wlt_1d_reconstruct(int)
d303 2
a304 2
make_wlt_1d_decompose(short)
make_wlt_1d_reconstruct(short)
d306 2
a307 2
make_wlt_1d_decompose(long)
make_wlt_1d_reconstruct(long)
d311 1
a311 1
#define decompose_2d( DATATYPE ) bn_wlt_2d_ ## DATATYPE ## _decompose
d313 1
a313 1
#define decompose_2d(DATATYPE) bn_wlt_2d_/* */DATATYPE/* */_decompose
d316 1
a316 1
#define make_wlt_2d_decompose(DATATYPE) \
d414 14
a427 1
#define make_wlt_2d_reconstruct(DATATYPE) /* DATATYPE */
d429 104
a532 6
make_wlt_2d_decompose(double)
make_wlt_2d_decompose(float)
make_wlt_2d_decompose(char)
make_wlt_2d_decompose(int)
make_wlt_2d_decompose(short)
make_wlt_2d_decompose(long)
d534 6
@


1.6
log
@Removed improper reference to "debug" external variable.
@
text
@d5 27
a31 13
 *	bn_wlt_1d_double_decompose(tbuf, buf, dimen, depth, limit)
 *	bn_wlt_1d_float_decompose (tbuf, buf, dimen, depth, limit)
 *	bn_wlt_1d_char_decompose  (tbuf, buf, dimen, depth, limit)
 *	bn_wlt_1d_short_decompose (tbuf, buf, dimen, depth, limit)
 *	bn_wlt_1d_int_decompose   (tbuf, buf, dimen, depth, limit)
 *	bn_wlt_1d_long_decompose  (tbuf, buf, dimen, depth, limit)
 *
 *	bn_wlt_1d_double_reconstruct(tbuf, buf, dimen, depth, sub_sz, limit)
 *	bn_wlt_1d_float_reconstruct (tbuf, buf, dimen, depth, sub_sz, limit)
 *	bn_wlt_1d_char_reconstruct  (tbuf, buf, dimen, depth, sub_sz, limit)
 *	bn_wlt_1d_short_reconstruct (tbuf, buf, dimen, depth, sub_sz, limit)
 *	bn_wlt_1d_int_reconstruct   (tbuf, buf, dimen, depth, sub_sz, limit)
 *	bn_wlt_1d_long_reconstruct  (tbuf, buf, dimen, depth, sub_sz, limit)
d50 1
a50 1
 *  bn_wlt_1d_*_decompose(tbuf, buf, dimen, depth, limit)
d52 5
a56 5
 *	tbuf	a temporary data buffer 1/2 as large as "buf". See (1) below.
 *	buf	pointer to the data to be decomposed
 *	dimen	The number of samples in the data buffer 
 *	depth	The number of values per sample
 *	limit	The extent of the decomposition
d58 2
a59 2
 *  Perform a Haar wavelet decomposition on the data in buffer "buf".  The
 *  decomposition is done "in place" on the data, hence the values in "buf"
d66 1
a66 1
 *  indicating the number of planes in the "depth" parameter.
d69 1
a69 1
 *  longest span to be decomposed.  If the "tbuf" argument is non-null then
d74 1
a74 1
 *	double dbuf[512], cbuf[256];
d76 1
a76 1
 *	bn_wlt_1d_double_decompose(cbuf, dbuf, 512, 1, 1);
d78 1
a78 1
 *    performs complete decomposition on the data in array "dbuf".
d80 2
a81 2
 *	double buf[3][512];	 /_* 512 samples, 3 values/sample (e.g. RGB?)*_/
 *	double tbuf[3][256];	 /_* the temporary buffer *_/
d83 1
a83 1
 *	bn_wlt_1d_double_decompose(tbuf, buf, 512, 3, 1);
d85 1
a85 1
 *    This will completely decompose the data in buf.  The first sample will
d88 1
a88 1
 *	bn_wlt_1d_double_decompose(tbuf, buf, 512, 3, 64);
d90 1
a90 1
 *    decomposes buf into a 64-sample "average image" and 3 "detail" sets.
d94 1
a94 1
 *  bn_wlt_1d_*_reconstruct(tbuf, buf, dimen, depth, sub_sz, limit)
d99 3
d110 1
a110 3
#ifndef lint
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/wavelet.c,v 1.5 1996/10/10 03:25:42 butler Exp mike $ (ARL)";
#endif
a116 12
#define CK_POW_2(dimen) { register unsigned long j; register int ok;\
	for (ok=0, j=0 ; j < sizeof(unsigned long) * 8 ; j++) { \
		if ( (1<<j) == dimen) { ok = 1;  break; } \
	} \
	if ( ! ok ) { \
		bu_log("%s:%d Dimension %d should be power of 2 (%d)\n", \
			__FILE__, __LINE__, dimen, j); \
		bu_bomb("CK_POW_2"); \
	} \
}


d129 3
a131 3
( tbuf, buf, dimen, depth, limit ) \
DATATYPE *tbuf;		/* temporary buffer */ \
DATATYPE *buf;		/* data buffer */ \
d133 1
a133 1
unsigned long depth;	/* # of data values per sample */ \
d142 1
d146 3
a148 3
	if ( ! tbuf ) { \
		tbuf = (DATATYPE *)bu_malloc( \
				(dimen/2) * depth * sizeof( *buf ), \
d160 2
a161 2
		detail = tbuf; \
		avg = buf; \
d164 1
a164 1
			x_tmp = x*depth; \
d166 1
a166 1
			for (d=0 ; d < depth ; d++, avg++, detail++) { \
d168 3
a170 3
				j = i + depth; \
				*detail = (buf[i] - buf[j]) / 2.0; \
				*avg    = (buf[i] + buf[j]) / 2.0; \
d177 1
a177 1
		 * the contents of "tbuf" (which holds the image detail) into \
d180 1
a180 1
		memcpy(avg, tbuf, sizeof(*buf) * depth * half_size); \
d184 1
a184 1
		bu_free( (genptr_t)tbuf, "1d wavelet buffer"); \
d197 3
a199 3
( tbuf, buf, dimen, depth, subimage_size, limit )\
DATATYPE *tbuf; \
DATATYPE *buf; \
d201 1
a201 1
unsigned long depth; \
d216 18
a233 4
	/* XXX check for: \
	 * subimage_size < dimen && subimage_size < limit \
	 * limit <= dimen \
	 */ \
d235 2
a236 2
	if ( ! tbuf ) { \
		tbuf = ( DATATYPE *)bu_malloc((dimen/2) * depth * sizeof( *buf ), \
d247 2
a248 2
		d = img_size * depth; \
		detail = &buf[ d ]; \
d251 2
a252 2
		avg = tbuf; \
		memcpy(avg, buf, sizeof(*buf) * d ); \
d256 2
a257 2
			x_tmp = x * depth; \
			for (d=0 ; d < depth ; d++, avg++, detail++ ) { \
d259 3
a261 3
				j = i + depth; \
				buf[i] = *avg + *detail; \
				buf[j] = *avg - *detail; \
d267 1
a267 1
		bu_free( (genptr_t)tbuf, \
d301 3
a303 3
(tbuf, buf, dimen, depth, limit) \
DATATYPE *tbuf; \
DATATYPE *buf; \
d305 1
a305 1
unsigned long depth; \
d314 2
a315 1
	int do_free; \
d319 3
a321 3
	if ( ! tbuf ) { \
		tbuf = (DATATYPE *)bu_malloc( \
				(dimen/2) * depth * sizeof( *buf ), \
a323 2
	} else { \
		do_free = 0; \
d335 1
a335 1
			y_tmp = y * dimen * depth; \
d337 2
a338 2
			detail = tbuf; \
			avg = &buf[y_tmp]; \
d341 1
a341 1
				x_tmp = x*depth + y_tmp; \
d343 1
a343 1
				for (d=0 ; d < depth ; d++, avg++, detail++){ \
d345 3
a347 3
					j = i + depth; \
					*detail = (buf[i] - buf[j]) / 2.0; \
					*avg    = (buf[i] + buf[j]) / 2.0; \
d353 1
a353 1
			 * we now want to copy the contents of "tbuf" (which \
d356 1
a356 1
			memcpy(avg, tbuf, sizeof(*buf) * depth * half_size); \
d361 1
a361 1
			x_tmp = x*depth; \
d363 2
a364 2
			detail = tbuf; \
			avg = &buf[x_tmp]; \
d367 1
a367 1
				y_tmp =y*dimen*depth + x_tmp; \
d369 1
a369 1
				for (d=0 ; d < depth ; d++, avg++, detail++) { \
d371 3
a373 3
					j = i + dimen*depth; \
					*detail = (buf[i] - buf[j]) / 2.0; \
					*avg    = (buf[i] + buf[j]) / 2.0; \
d375 1
a375 1
				avg += (dimen-1)*depth; \
d385 1
a385 1
			detail = tbuf; \
d387 1
a387 1
				for (d=0; d < depth ; d++) { \
d390 1
a390 1
				avg += (dimen-1)*depth; \
@


1.5
log
@2d decompose added
@
text
@d94 1
a94 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/wavelet.c,v 1.4 1996/09/20 00:22:49 mike Exp butler $ (ARL)";
a296 1
	extern int debug; \
@


1.4
log
@Fixed non-ANSI nested commenting
@
text
@d94 1
a94 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/wavelet.c,v 1.3 1996/09/13 04:27:35 butler Exp mike $ (ARL)";
d116 1
a116 1
#define decompose( DATATYPE ) bn_wlt_1d_ ## DATATYPE ## _decompose
d118 1
a118 1
#define decompose( DATATYPE ) bn_wlt_1d_/* */DATATYPE/* */_decompose
d123 1
a123 1
#define make_wlt_1d_decompose( DATATYPE )  \
d125 1
a125 1
decompose( DATATYPE ) \
d139 1
a139 1
 \
d141 1
a141 1
 \
d148 1
a148 1
 \
d153 1
a153 1
 \
d158 1
a158 1
 \
d161 1
a161 1
 \
d169 1
a169 1
 \
d184 2
a185 2
#ifdef __STDC__
#define reconstruct( DATATYPE ) bn_wlt_1d_ ## DATATYPE ## _reconstruct
d187 1
a187 1
#define reconstruct( DATATYPE ) bn_wlt_1d_/* */DATATYPE/* */_reconstruct
d192 1
a192 1
reconstruct( DATATYPE ) \
d207 1
a207 1
 \
d211 1
a211 1
 \
d216 1
a216 1
 \
d222 1
a222 1
 \
d228 1
a228 1
 \
d231 1
a231 1
 \
d235 2
a236 2
 \
 \
d247 1
a247 1
 \
d255 14
a268 2
make_wlt_1d_decompose( double ) 
make_wlt_1d_reconstruct( double ) 
d270 2
a271 2
make_wlt_1d_decompose( float ) 
make_wlt_1d_reconstruct( float ) 
a272 2
make_wlt_1d_decompose( char ) 
make_wlt_1d_reconstruct( char ) 
d274 105
a378 2
make_wlt_1d_decompose( int ) 
make_wlt_1d_reconstruct( int ) 
d380 1
a380 2
make_wlt_1d_decompose( short ) 
make_wlt_1d_reconstruct( short ) 
d382 6
a387 2
make_wlt_1d_decompose( long ) 
make_wlt_1d_reconstruct( long ) 
@


1.3
log
@checkpoint
@
text
@d66 3
a68 3
 *	double buf[3][512];	 /* 512 samples, 3 values/sample (e.g. RGB?)*/
/*	double tbuf[3][256];	 /* the temporary buffer */
/*	...
d94 1
a94 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.2
log
@added casts to make lint happy
@
text
@d1 95
d99 1
d114 67
a180 47
void
bn_wlt_1d_double_decompose(
	double *tbuf,		/* temporary buffer */
	double *buf,		/* data buffer */
	unsigned long dimen,	/* # of samples in data buffer */
	unsigned long depth,	/* # of data values per sample */
 	unsigned long limit )	/* extent of decomposition */
{
	double *detail;
	double *avg;
	unsigned long img_size;
	unsigned long half_size;
	int do_free = 0;
	unsigned long x, x_tmp, d, i, j;

	CK_POW_2( dimen );

	if ( ! tbuf ) {
		tbuf = (double *)bu_malloc((dimen/2) * depth * sizeof( *buf ),
				"1d 'double' wavelet buffer");
		do_free = 1;
	}

	for (img_size = dimen ; img_size > limit ; img_size = half_size ){
		half_size = img_size/2;
		
		detail = tbuf;
		avg = buf;

		for ( x=0 ; x < img_size ; x += 2 ) {
			x_tmp = x*depth;

			for (d=0 ; d < depth ; d++, avg++, detail++) {
				i = x_tmp + d;
				j = i + depth;
				*detail = (buf[i] - buf[j]) / 2.0;
				*avg    = (buf[i] + buf[j]) / 2.0;
			}
		}

		memcpy(&buf[ half_size*depth ], tbuf,
			sizeof(*buf) * depth * half_size);

	}
	
	if (do_free)
		bu_free( (genptr_t)tbuf, "1d 'double' wavelet buffer");
a182 50
void
bn_wlt_1d_double_reconstruct(
	double *tbuf,
	double *buf,
	unsigned long dimen,
	unsigned long depth,
	unsigned long subimage_size,
	unsigned long limit )
{
	register double *detail;
	register double *avg;
	unsigned long img_size;
	unsigned long dbl_size;
	int do_free = 0;
	unsigned long x_tmp, d, x, i, j;

	CK_POW_2( subimage_size );
	CK_POW_2( dimen );
	CK_POW_2( limit );

	/* XXX check for:
	 * subimage_size < dimen && subimage_size < limit
	 * limit <= dimen
	 */

	if ( ! tbuf ) {
		tbuf = (double *)bu_malloc((dimen/2) * depth * sizeof( *buf ),
				"1d 'double' wavelet buffer");
		do_free = 1;
	}


	for (img_size=subimage_size ; img_size < limit ; img_size=dbl_size) {
		dbl_size = img_size * 2;

		memcpy(tbuf, buf, sizeof(*buf) * depth * img_size);

		detail = &buf[ img_size * depth ];
		avg = tbuf;

		for (x=0 ; x < dbl_size ; x += 2 ) {
			x_tmp = x * depth;
			for (d=0 ; d < depth ; d++, avg++, detail++ ) {
				i = x_tmp + d;
				j = i + depth;
				buf[i] = *avg + *detail;
				buf[j] = *avg - *detail;
			}
		}
	}
d184 67
a250 2
	if (do_free)
		bu_free( (genptr_t)tbuf, "1d 'double' wavelet buffer");
d252 21
@


1.1
log
@Initial revision
@
text
@d64 1
a64 1
		bu_free( tbuf, "1d 'double' wavelet buffer");
d119 1
a119 1
		bu_free( tbuf, "1d 'double' wavelet buffer");
@
