head	1.11;
access;
symbols
	ansi-20040405-merged:1.7.2.2
	postmerge-20040405-ansi:1.9
	premerge-20040404-ansi:1.8
	postmerge-autoconf:1.8
	autoconf-freeze:1.7.10.1
	premerge-autoconf:1.8
	ansi-20040316-freeze:1.7.2.1
	postmerge-20040315-windows:1.8
	premerge-20040315-windows:1.7
	windows-20040315-freeze:1.7.4.1
	autoconf-20031203:1.7
	autoconf-20031202:1.7
	autoconf-branch:1.7.0.10
	phong-branch:1.7.0.8
	photonmap-branch:1.7.0.6
	rel-6-1-DP:1.7
	windows-branch:1.7.0.4
	rel-6-0-2:1.5
	ansi-branch:1.7.0.2
	rel-6-0-1-branch:1.5.0.2
	hartley-6-0-post:1.6
	hartley-6-0-pre:1.5
	rel-6-0-1:1.5
	rel-6-0:1.4
	rel-5-4:1.2
	offsite-5-3-pre:1.3
	rel-5-3:1.2
	rel-5-2:1.2
	rel-5-1-branch:1.2.0.2
	rel-5-1:1.2
	rel-5-0:1.2
	rel-5-0-beta:1.2
	rel-4-5:1.2
	ctj-4-5-post:1.2
	ctj-4-5-pre:1.2;
locks; strict;
comment	@ * @;


1.11
date	2004.05.21.18.06.22;	author morrison;	state dead;
branches;
next	1.10;

1.10
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.16.19.16.26;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.20.17.07.37;	author jra;	state Exp;
branches
	1.7.2.1
	1.7.4.1
	1.7.10.1;
next	1.6;

1.6
date	2002.08.15.20.54.49;	author hartley;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.05.20.59.31;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.20.22.29.02;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.11.23.30.39;	author cjohnson;	state Exp;
branches;
next	1.2;

1.2
date	96.08.31.10.39.17;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.08.31.10.37.33;	author mike;	state Exp;
branches;
next	;

1.7.2.1
date	2002.09.19.18.01.09;	author morrison;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2004.03.17.21.16.48;	author morrison;	state Exp;
branches;
next	;

1.7.4.1
date	2002.09.26.23.03.49;	author morrison;	state Exp;
branches;
next	;

1.7.10.1
date	2004.03.18.18.08.28;	author erikg;	state Exp;
branches;
next	;


desc
@poly.c
@


1.11
log
@moved to src/
@
text
@/*
 *  			P O L Y . C
 *
 *	Library for dealing with polynomials.
 *
 *  Author -
 *	Jeff Hanes
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSpoly[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/poly.c,v 1.10 2004/05/10 15:30:43 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <signal.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"

#define Abs( a )		((a) >= 0 ? (a) : -(a))
#define Max( a, b )		((a) > (b) ? (a) : (b))

#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif
#define PI_DIV_3	(M_PI/3.0)

static const struct bn_poly	bn_Zero_poly = { BN_POLY_MAGIC, 0, {0.0} };

/*
 *	bn_poly_mul -- multiply two polynomials
 */
struct bn_poly *
bn_poly_mul(register struct bn_poly *product, register const struct bn_poly *m1, register const struct bn_poly *m2)
{
	if( m1->dgr == 1 && m2->dgr == 1 )  {
		product->dgr = 2;
		product->cf[0] = m1->cf[0] * m2->cf[0];
		product->cf[1] = m1->cf[0] * m2->cf[1] +
				 m1->cf[1] * m2->cf[0];
		product->cf[2] = m1->cf[1] * m2->cf[1];
		return(product);
	}
	if( m1->dgr == 2 && m2->dgr == 2 )  {
		product->dgr = 4;
		product->cf[0] = m1->cf[0] * m2->cf[0];
		product->cf[1] = m1->cf[0] * m2->cf[1] +
				 m1->cf[1] * m2->cf[0];
		product->cf[2] = m1->cf[0] * m2->cf[2] +
				 m1->cf[1] * m2->cf[1] +
				 m1->cf[2] * m2->cf[0];
		product->cf[3] = m1->cf[1] * m2->cf[2] +
				 m1->cf[2] * m2->cf[1];
		product->cf[4] = m1->cf[2] * m2->cf[2];
		return(product);
	}

	/* Not one of the common (or easy) cases. */
	{
		register int		ct1, ct2;

		*product = bn_Zero_poly;

		/* If the degree of the product will be larger than the
		 * maximum size allowed in "polyno.h", then return a null
		 * pointer to indicate failure.
		 */
		if ( (product->dgr = m1->dgr + m2->dgr) > BN_MAX_POLY_DEGREE )
			return BN_POLY_NULL;

		for ( ct1=0; ct1 <= m1->dgr; ++ct1 ){
			for ( ct2=0; ct2 <= m2->dgr; ++ct2 ){
				product->cf[ct1+ct2] +=
					m1->cf[ct1] * m2->cf[ct2];
			}
		}
	}
	return product;
}


/*
 *	bn_poly_scale -- scale a polynomial
 */
struct bn_poly *
bn_poly_scale(register struct bn_poly *eqn, double factor)
{
	register int		cnt;

	for ( cnt=0; cnt <= eqn->dgr; ++cnt ){
		eqn->cf[cnt] *= factor;
	}
	return eqn;
}


/*
 *	bn_poly_add -- add two polynomials
 */
struct bn_poly *
bn_poly_add(register struct bn_poly *sum, register const struct bn_poly *poly1, register const struct bn_poly *poly2)
{
	LOCAL struct bn_poly	tmp;
	register int		i, offset;

	offset = Abs(poly1->dgr - poly2->dgr);

	tmp = bn_Zero_poly;

	if ( poly1->dgr >= poly2->dgr ){
		*sum = *poly1;
		for ( i=0; i <= poly2->dgr; ++i ){
			tmp.cf[i+offset] = poly2->cf[i];
		}
	} else {
		*sum = *poly2;
		for ( i=0; i <= poly1->dgr; ++i ){
			tmp.cf[i+offset] = poly1->cf[i];
		}
	}

	for ( i=0; i <= sum->dgr; ++i ){
		sum->cf[i] += tmp.cf[i];
	}
	return sum;
}


/*
 *	bn_poly_sub -- subtract two polynomials
 */
struct bn_poly *
bn_poly_sub(register struct bn_poly *diff, register const struct bn_poly *poly1, register const struct bn_poly *poly2)
{
	LOCAL struct bn_poly	tmp;
	register int		i, offset;

	offset = Abs(poly1->dgr - poly2->dgr);

	*diff = bn_Zero_poly;
	tmp = bn_Zero_poly;

	if ( poly1->dgr >= poly2->dgr ){
		*diff = *poly1;
		for ( i=0; i <= poly2->dgr; ++i ){
			tmp.cf[i+offset] = poly2->cf[i];
		}
	} else {
		diff->dgr = poly2->dgr;
		for ( i=0; i <= poly1->dgr; ++i ){
			diff->cf[i+offset] = poly1->cf[i];
		}
		tmp = *poly2;
	}

	for ( i=0; i <= diff->dgr; ++i ){
		diff->cf[i] -= tmp.cf[i];
	}
	return diff;
}


/*	s y n D i v ( )
 *	Divides any polynomial into any other polynomial using synthetic
 *	division.  Both polynomials must have real coefficients.
 */
void
bn_poly_synthetic_division(register struct bn_poly *quo, register struct bn_poly *rem, register const struct bn_poly *dvdend, register const struct bn_poly *dvsor)
{
	register int	div;
	register int	n;

	*quo = *dvdend;
	*rem = bn_Zero_poly;

	if ((quo->dgr = dvdend->dgr - dvsor->dgr) < 0)
		quo->dgr = -1;
	if ((rem->dgr = dvsor->dgr - 1) > dvdend->dgr)
		rem->dgr = dvdend->dgr;

	for ( n=0; n <= quo->dgr; ++n){
		quo->cf[n] /= dvsor->cf[0];
		for ( div=1; div <= dvsor->dgr; ++div){
			quo->cf[n+div] -= quo->cf[n] * dvsor->cf[div];
		}
	}
	for ( n=1; n<=(rem->dgr+1); ++n){
		rem->cf[n-1] = quo->cf[quo->dgr+n];
		quo->cf[quo->dgr+n] = 0;
	}
}


/*	q u a d r a t i c ( )
 *
 *	Uses the quadratic formula to find the roots (in `complex' form)
 *	of any quadratic equation with real coefficients.
 */
int
bn_poly_quadratic_roots(register struct bn_complex *roots, register const struct bn_poly *quadrat)
{
	LOCAL fastf_t	discrim, denom, rad;

	if( NEAR_ZERO( quadrat->cf[0], SQRT_SMALL_FASTF ) )  {
		/* root = -cf[2] / cf[1] */
		if( NEAR_ZERO( quadrat->cf[1], SQRT_SMALL_FASTF ) )  {
			/* No solution.  Now what? */
			bu_log("bn_poly_quadratic_roots(): ERROR, no solution\n");
			return -1;
		}
		/* Fake it as a repeated root. */
		roots[0].re = roots[1].re = -quadrat->cf[2]/quadrat->cf[1];
		roots[0].im = roots[1].im = 0.0;
		return 1;	/* OK - repeated root */
	}
	/* What to do if cf[1] > SQRT_MAX_FASTF ? */

	discrim = quadrat->cf[1]*quadrat->cf[1] - 4.0* quadrat->cf[0]*quadrat->cf[2];
	denom = 0.5 / quadrat->cf[0];
	if ( discrim >= 0.0 ){
		rad = sqrt( discrim );
		roots[0].re = ( -quadrat->cf[1] + rad ) * denom;
		roots[1].re = ( -quadrat->cf[1] - rad ) * denom;
		roots[1].im = roots[0].im = 0.0;
	} else {
		roots[1].re = roots[0].re = -quadrat->cf[1] * denom;
		roots[1].im = -(roots[0].im = sqrt( -discrim ) * denom);
	}
	return 0;		/* OK */
}


#define SQRT3			1.732050808
#define THIRD			0.333333333333333333333333333
#define INV_TWENTYSEVEN		0.037037037037037037037037037
#define	CUBEROOT( a )	(( (a) >= 0.0 ) ? pow( a, THIRD ) : -pow( -(a), THIRD ))

/*	c u b i c ( )
 *
 *	Uses the cubic formula to find the roots ( in `complex' form )
 *	of any cubic equation with real coefficients.
 *
 *	to solve a polynomial of the form:
 *
 *		X**3 + c1*X**2 + c2*X + c3 = 0,
 *
 *	first reduce it to the form:
 *
 *		Y**3 + a*Y + b = 0,
 *
 *	where
 *		Y = X + c1/3,
 *	and
 *		a = c2 - c1**2/3,
 *		b = ( 2*c1**3 - 9*c1*c2 + 27*c3 )/27.
 *
 *	Then we define the value delta,   D = b**2/4 + a**3/27.
 *
 *	If D > 0, there will be one real root and two conjugate
 *	complex roots.
 *	If D = 0, there will be three real roots at least two of
 *	which are equal.
 *	If D < 0, there will be three unequal real roots.
 *
 *	Returns 1 for success, 0 for fail.
 */
static int	bn_expecting_fpe = 0;
static jmp_buf	bn_abort_buf;
HIDDEN void bn_catch_FPE(int sig)
{
	if( !bn_expecting_fpe )
		bu_bomb("bn_catch_FPE() unexpected SIGFPE!");
	if( !bu_is_parallel() )
		(void)signal(SIGFPE, bn_catch_FPE);	/* Renew handler */
	longjmp(bn_abort_buf, 1);	/* return error code */
}

/*
 *			B N _ P O L Y _ C U B I C _ R O O T S
 */
int
bn_poly_cubic_roots(register struct bn_complex *roots, register const struct bn_poly *eqn)
{
	LOCAL fastf_t	a, b, c1, c1_3rd, delta;
	register int	i;
	static int	first_time = 1;
	
	if( !bu_is_parallel() ) {
		/* bn_abort_buf is NOT parallel! */
		if( first_time )  {
			first_time = 0;
			(void)signal(SIGFPE, bn_catch_FPE);
		}
		bn_expecting_fpe = 1;
		if( setjmp( bn_abort_buf ) )  {
			(void)signal(SIGFPE, bn_catch_FPE);
			bu_log("bn_poly_cubic_roots() Floating Point Error\n");
			return(0);	/* FAIL */
		}
	}

	c1 = eqn->cf[1];
	if( Abs(c1) > SQRT_MAX_FASTF )  return(0);	/* FAIL */

	c1_3rd = c1 * THIRD;
	a = eqn->cf[2] - c1*c1_3rd;
	if( Abs(a) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
	b = (2.0*c1*c1*c1 - 9.0*c1*eqn->cf[2] + 27.0*eqn->cf[3])*INV_TWENTYSEVEN;
	if( Abs(b) > SQRT_MAX_FASTF )  return(0);	/* FAIL */

	if( (delta = a*a) > SQRT_MAX_FASTF ) return(0);	/* FAIL */
	delta = b*b*0.25 + delta*a*INV_TWENTYSEVEN;

	if ( delta > 0.0 ){
		LOCAL fastf_t		r_delta, A, B;

		r_delta = sqrt( delta );
		A = B = -0.5 * b;
		A += r_delta;
		B -= r_delta;

		A = CUBEROOT( A );
		B = CUBEROOT( B );

		roots[2].re = roots[1].re = -0.5 * ( roots[0].re = A + B );

		roots[0].im = 0.0;
		roots[2].im = -( roots[1].im = (A - B)*SQRT3*0.5 );
	} else if ( delta == 0.0 ){
		LOCAL fastf_t	b_2;
		b_2 = -0.5 * b;

		roots[0].re = 2.0* CUBEROOT( b_2 );
		roots[2].re = roots[1].re = -0.5 * roots[0].re;
		roots[2].im = roots[1].im = roots[0].im = 0.0;
	} else {
		LOCAL fastf_t		phi, fact;
		LOCAL fastf_t		cs_phi, sn_phi_s3;

		if( a >= 0.0 )  {
			fact = 0.0;
			phi = 0.0;
			cs_phi = 1.0;		/* cos( phi ); */
			sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
		} else {
			FAST fastf_t	f;
			a *= -THIRD;
			fact = sqrt( a );
			if( (f = b * (-0.5) / (a*fact)) >= 1.0 )  {
				phi = 0.0;
				cs_phi = 1.0;		/* cos( phi ); */
				sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
			}  else if( f <= -1.0 )  {
				phi = PI_DIV_3;
				cs_phi = cos( phi );
				sn_phi_s3 = sin( phi ) * SQRT3;
			}  else  {
				phi = acos( f ) * THIRD;
				cs_phi = cos( phi );
				sn_phi_s3 = sin( phi ) * SQRT3;
			}
		}

		roots[0].re = 2.0*fact*cs_phi;
		roots[1].re = fact*(  sn_phi_s3 - cs_phi);
		roots[2].re = fact*( -sn_phi_s3 - cs_phi);
		roots[2].im = roots[1].im = roots[0].im = 0.0;
	}
	for ( i=0; i < 3; ++i )
		roots[i].re -= c1_3rd;

	if( !bu_is_parallel() )
		bn_expecting_fpe = 0;

	return(1);		/* OK */
}


/*
 *			B N _ P O L Y _ Q U A R T I C _ R O O T S
 *
 *	Uses the quartic formula to find the roots ( in `complex' form )
 *	of any quartic equation with real coefficients.
 *
 *	Returns 1 for success, 0 for fail.
 */
int
bn_poly_quartic_roots(register struct bn_complex *roots, register const struct bn_poly *eqn)
{
	LOCAL struct bn_poly	cube, quad1, quad2;
	LOCAL bn_complex_t	u[3];
	LOCAL fastf_t		U, p, q, q1, q2;
#define Max3(a,b,c) ((c)>((a)>(b)?(a):(b)) ? (c) : ((a)>(b)?(a):(b)))

	cube.dgr = 3;
	cube.cf[0] = 1.0;
	cube.cf[1] = -eqn->cf[2];
	cube.cf[2] = eqn->cf[3]*eqn->cf[1]
			- 4*eqn->cf[4];
	cube.cf[3] = -eqn->cf[3]*eqn->cf[3]
			- eqn->cf[4]*eqn->cf[1]*eqn->cf[1]
			+ 4*eqn->cf[4]*eqn->cf[2];

	if( !bn_poly_cubic_roots( u, &cube ) )  {
		return( 0 );		/* FAIL */
	}
	if ( u[1].im != 0.0 ){
		U = u[0].re;
	} else {
		U = Max3( u[0].re, u[1].re, u[2].re );
	}

	p = eqn->cf[1]*eqn->cf[1]*0.25 + U - eqn->cf[2];
	U *= 0.5;
	q = U*U - eqn->cf[4];
	if( p < 0 )  {
		if( p < -1.0e-8 )  {
			return(0);	/* FAIL */
		}
		p = 0;
	} else {
		p = sqrt( p );
	}
	if( q < 0 )  {
		if( q < -1.0e-8 )  {
			return(0);	/* FAIL */
		}
		q = 0;
	} else {
		q = sqrt( q );
	}

	quad1.dgr = quad2.dgr = 2;
	quad1.cf[0] = quad2.cf[0] = 1.0;
	quad1.cf[1] = eqn->cf[1]*0.5;
	quad2.cf[1] = quad1.cf[1] + p;
	quad1.cf[1] -= p;
	
	q1 = U - q;
	q2 = U + q;

	p = quad1.cf[1]*q2 + quad2.cf[1]*q1 - eqn->cf[3];
	if( Abs( p ) < 1.0e-8){
		quad1.cf[2] = q1;
		quad2.cf[2] = q2;
	} else {
		q = quad1.cf[1]*q1 + quad2.cf[1]*q2 - eqn->cf[3];
		if( Abs( q ) < 1.0e-8 ){
			quad1.cf[2] = q2;
			quad2.cf[2] = q1;
		} else {
			return(0);	/* FAIL */
		}
	}

	bn_poly_quadratic_roots( &roots[0], &quad1 );
	bn_poly_quadratic_roots( &roots[2], &quad2 );
	return(1);		/* SUCCESS */
}


/*
 *			B N _ P R _ P O L Y
 */
void
bn_pr_poly(const char *title, register const struct bn_poly *eqn)
{
	register int	n;
	register int	exp;
	struct bu_vls	str;
	char		buf[48];

	bu_vls_init( &str );
	bu_vls_extend( &str, 196 );
	bu_vls_strcat( &str, title );
	sprintf(buf, " polynomial, degree = %d\n", eqn->dgr);
	bu_vls_strcat( &str, buf );

	exp = eqn->dgr;
	for ( n=0; n<=eqn->dgr; n++,exp-- )  {
		register double coeff = eqn->cf[n];
		if( n > 0 )  {
			if( coeff < 0 )  {
				bu_vls_strcat( &str, " - " );
				coeff = -coeff;
			}  else  {
				bu_vls_strcat( &str, " + " );
			}
		}
		bu_vls_printf( &str, "%g", coeff );
		if( exp > 1 )  {
			bu_vls_printf( &str, " *X^%d", exp );
		} else if( exp == 1 )  {

			bu_vls_strcat( &str, " *X" );
		} else {
			/* For constant term, add nothing */
		}
	}
	bu_vls_strcat( &str, "\n" );
	bu_log( "%s", bu_vls_addr(&str) );
	bu_vls_free( &str );
}

/*
 *			B N _ P R _ R O O T S
 */
void
bn_pr_roots(const char *title, const struct bn_complex *roots, int n)
{
	register int	i;

	bu_log("%s: %d roots:\n", title, n );
	for( i=0; i<n; i++ )  {
		bu_log("%4d %e + i * %e\n", i, roots[i].re, roots[i].im );
	}
}
@


1.10
log
@change conf.h to a wrapped config.h
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /cvs/brlcad/libbn/poly.c,v 1.9 2004/04/05 07:46:41 morrison Exp $ (ARL)";
@


1.9
log
@merge of ansi-6-0-branch into HEAD
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header$ (ARL)";
d20 5
a24 1
#include "conf.h"
@


1.8
log
@merge of windows-6-0-branch into head
@
text
@d45 1
a45 4
bn_poly_mul(product, m1, m2)
register struct bn_poly	*product;
register const struct bn_poly	*m1;
register const struct bn_poly	*m2;
d97 1
a97 3
bn_poly_scale(eqn,factor)
register struct bn_poly	*eqn;
double	factor;
d112 1
a112 4
bn_poly_add(sum,poly1,poly2)
register struct bn_poly	*sum;
register const struct bn_poly	*poly1;
register const struct bn_poly	*poly2;
d144 1
a144 4
bn_poly_sub(diff, poly1, poly2)
register struct bn_poly *diff;
register const struct bn_poly	*poly1;
register const struct bn_poly	*poly2;
d174 1
a174 1
/*	>>>  s y n D i v ( )  <<<
d179 1
a179 5
bn_poly_synthetic_division(quo, rem, dvdend, dvsor)
register struct bn_poly	*quo;
register struct bn_poly	*rem;
register const struct bn_poly	*dvdend;
register const struct bn_poly	*dvsor;
d205 1
a205 1
/*	>>>  q u a d r a t i c ( )  <<<
d211 1
a211 3
bn_poly_quadratic_roots( roots, quadrat )
register struct bn_complex	roots[];
register const struct bn_poly	*quadrat;
d249 1
a249 1
/*	>>>  c u b i c ( )  <<<
a279 4
#ifndef WIN32
HIDDEN void bn_catch_FPE(sig)
int	sig;
#else
a280 1
#endif
d293 1
a293 3
bn_poly_cubic_roots( roots, eqn )
register struct bn_complex	roots[];
register const struct bn_poly	*eqn;
d399 1
a399 3
bn_poly_quartic_roots( roots, eqn )
register struct bn_complex	roots[];
register const struct bn_poly	*eqn;
d477 1
a477 3
bn_pr_poly(title, eqn)
const char			*title;
register const struct bn_poly	*eqn;
d520 1
a520 4
bn_pr_roots( title, roots, n )
const char	*title;
const struct bn_complex	roots[];
int		n;
@


1.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /c/CVS/brlcad/libbn/poly.c,v 1.5 2002/06/05 20:59:31 butler Exp $ (ARL)";
d297 1
d300 3
@


1.7.10.1
log
@merge from head
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header$ (ARL)";
a296 1
#ifndef WIN32
a298 3
#else
HIDDEN void bn_catch_FPE(int sig)
#endif
@


1.7.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /c/CVS/brlcad/libbn/poly.c,v 1.7 2002/08/20 17:07:37 jra Exp $ (ARL)";
a296 1
#ifndef WIN32
a298 3
#else
HIDDEN void bn_catch_FPE(int sig)
#endif
@


1.7.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /c/CVS/brlcad/libbn/poly.c,v 1.7 2002/08/20 17:07:37 jra Exp $ (ARL)";
d45 4
a48 1
bn_poly_mul(register struct bn_poly *product, register const struct bn_poly *m1, register const struct bn_poly *m2)
d100 3
a102 1
bn_poly_scale(register struct bn_poly *eqn, double factor)
d117 4
a120 1
bn_poly_add(register struct bn_poly *sum, register const struct bn_poly *poly1, register const struct bn_poly *poly2)
d152 4
a155 1
bn_poly_sub(register struct bn_poly *diff, register const struct bn_poly *poly1, register const struct bn_poly *poly2)
d190 5
a194 1
bn_poly_synthetic_division(register struct bn_poly *quo, register struct bn_poly *rem, register const struct bn_poly *dvdend, register const struct bn_poly *dvsor)
d226 3
a228 1
bn_poly_quadratic_roots(register struct bn_complex *roots, register const struct bn_poly *quadrat)
d297 2
a298 1
HIDDEN void bn_catch_FPE(int sig)
d311 3
a313 1
bn_poly_cubic_roots(register struct bn_complex *roots, register const struct bn_poly *eqn)
d419 3
a421 1
bn_poly_quartic_roots(register struct bn_complex *roots, register const struct bn_poly *eqn)
d499 3
a501 1
bn_pr_poly(const char *title, register const struct bn_poly *eqn)
d544 4
a547 1
bn_pr_roots(const char *title, const struct bn_complex *roots, int n)
@


1.7.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header$ (ARL)";
d174 1
a174 1
/*	s y n D i v ( )
d205 1
a205 1
/*	q u a d r a t i c ( )
d249 1
a249 1
/*	c u b i c ( )
@


1.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d45 4
a48 1
bn_poly_mul(register struct bn_poly *product, register const struct bn_poly *m1, register const struct bn_poly *m2)
d100 3
a102 1
bn_poly_scale(register struct bn_poly *eqn, double factor)
d117 4
a120 1
bn_poly_add(register struct bn_poly *sum, register const struct bn_poly *poly1, register const struct bn_poly *poly2)
d152 4
a155 1
bn_poly_sub(register struct bn_poly *diff, register const struct bn_poly *poly1, register const struct bn_poly *poly2)
d190 5
a194 1
bn_poly_synthetic_division(register struct bn_poly *quo, register struct bn_poly *rem, register const struct bn_poly *dvdend, register const struct bn_poly *dvsor)
d226 3
a228 1
bn_poly_quadratic_roots(register struct bn_complex *roots, register const struct bn_poly *quadrat)
d297 2
a298 1
HIDDEN void bn_catch_FPE(int sig)
d311 3
a313 1
bn_poly_cubic_roots(register struct bn_complex *roots, register const struct bn_poly *eqn)
d419 3
a421 1
bn_poly_quartic_roots(register struct bn_complex *roots, register const struct bn_poly *eqn)
d499 3
a501 1
bn_pr_poly(const char *title, register const struct bn_poly *eqn)
d544 4
a547 1
bn_pr_roots(const char *title, const struct bn_complex *roots, int n)
@


1.5
log
@patch to eliminate set of shared scalar bn_expecting_fpe when in parallel
mode.  This results in a substantial improvement on SGI systems with models
having lots of TGCs and TORs
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /c/CVS/brlcad/libbn/poly.c,v 1.4 2001/04/20 22:29:02 morrison Exp $ (ARL)";
d45 1
a45 4
bn_poly_mul(product, m1, m2)
register struct bn_poly	*product;
register const struct bn_poly	*m1;
register const struct bn_poly	*m2;
d97 1
a97 3
bn_poly_scale(eqn,factor)
register struct bn_poly	*eqn;
double	factor;
d112 1
a112 4
bn_poly_add(sum,poly1,poly2)
register struct bn_poly	*sum;
register const struct bn_poly	*poly1;
register const struct bn_poly	*poly2;
d144 1
a144 4
bn_poly_sub(diff, poly1, poly2)
register struct bn_poly *diff;
register const struct bn_poly	*poly1;
register const struct bn_poly	*poly2;
d179 1
a179 5
bn_poly_synthetic_division(quo, rem, dvdend, dvsor)
register struct bn_poly	*quo;
register struct bn_poly	*rem;
register const struct bn_poly	*dvdend;
register const struct bn_poly	*dvsor;
d211 1
a211 3
bn_poly_quadratic_roots( roots, quadrat )
register struct bn_complex	roots[];
register const struct bn_poly	*quadrat;
d280 1
a280 2
HIDDEN void bn_catch_FPE(sig)
int	sig;
d293 1
a293 3
bn_poly_cubic_roots( roots, eqn )
register struct bn_complex	roots[];
register const struct bn_poly	*eqn;
d399 1
a399 3
bn_poly_quartic_roots( roots, eqn )
register struct bn_complex	roots[];
register const struct bn_poly	*eqn;
d477 1
a477 3
bn_pr_poly(title, eqn)
const char			*title;
register const struct bn_poly	*eqn;
d520 1
a520 4
bn_pr_roots( title, roots, n )
const char	*title;
const struct bn_complex	roots[];
int		n;
@


1.4
log
@CONST to const
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /c/CVS/brlcad/libbn/poly.c,v 1.3 2000/07/11 23:30:39 cjohnson Exp $ (ARL)";
d335 1
d402 4
a405 1
	bn_expecting_fpe = 0;
@


1.3
log
@LINT picking.  Missing includes and static const for RCSids
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /c/CVS/brlcad/libbn/poly.c,v 1.2 1996/08/31 10:39:17 mike Exp $ (ARL)";
d39 1
a39 1
static CONST struct bn_poly	bn_Zero_poly = { BN_POLY_MAGIC, 0, {0.0} };
d47 2
a48 2
register CONST struct bn_poly	*m1;
register CONST struct bn_poly	*m2;
d119 2
a120 2
register CONST struct bn_poly	*poly1;
register CONST struct bn_poly	*poly2;
d154 2
a155 2
register CONST struct bn_poly	*poly1;
register CONST struct bn_poly	*poly2;
d193 2
a194 2
register CONST struct bn_poly	*dvdend;
register CONST struct bn_poly	*dvsor;
d228 1
a228 1
register CONST struct bn_poly	*quadrat;
d313 1
a313 1
register CONST struct bn_poly	*eqn;
d417 1
a417 1
register CONST struct bn_poly	*eqn;
d496 2
a497 2
CONST char			*title;
register CONST struct bn_poly	*eqn;
d541 2
a542 2
CONST char	*title;
CONST struct bn_complex	roots[];
@


1.2
log
@Changed header
@
text
@d17 1
a17 1
static char RCSpoly[] = "@@(#)$Header$ (ARL)";
d39 1
a39 1
static CONST struct bn_poly	bn_Zero_poly = { BN_POLY_MAGIC, 0, 0.0 };
@


1.1
log
@Initial revision
@
text
@a5 10
 *  Functions -
 *	bn_poly_mul		Multiply two polynomials
 *	bn_poly_scale	Scale a polynomial
 *	bn_poly_add		Add two polynomials
 *	bn_poly_sub		Subtract two polynomials
 *	bn_poly_synthetic_division		Divide 1 poly into another using Synthetic Division
 *	quadratic	Solve quadratic formula
 *	cubic		Solve cubic forumla
 *	bn_pr_poly	Print a polynomial
 *
d10 2
a11 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d13 2
a14 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d17 1
a17 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 11.1 95/01/04 09:58:26 mike Rel4_4 $ (BRL)";
@
