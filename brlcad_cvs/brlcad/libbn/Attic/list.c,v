head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	ansi-20040316-freeze:11.4.2.1
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:1.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.18.06.22;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.07.36;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.54.48;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2000.07.11.23.30.38;	author cjohnson;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.51.15;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.10.11.16.59.25;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.12.19.18.07;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.35;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.09.24.20.24.07;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	91.09.23.16.37.44;	author butler;	state Exp;
branches;
next	9.4;

9.4
date	91.07.02.01.14.53;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.05.31.11.26.02;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.11.25.11.42.20;	author cjohnson;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.49.44;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.28.42;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.09.23.23.50.42;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.05.13.22.24.53;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.05.13.22.22.55;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.02.08.23.41.31;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.06.09.16.27;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.04.21.51.39;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.28.40;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.53.07;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.53.13;	author mike;	state Rel;
branches;
next	1.1;

1.1
date	87.01.12.18.58.42;	author mike;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.01.08;	author morrison;	state Exp;
branches;
next	;


desc
@unix-tig pack
draw a line of data
@


11.7
log
@moved to src/
@
text
@/*
 *			L I S T . C
 *
 *  NOTE that tp_2list() and tp_3list() are good candidates to become
 *  intrinsic parts of plot3.c, for efficiency reasons.
 *
 *  Author -
 *	Michael John Muuss
 *	August 04, 1978
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/list.c,v 11.6 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "plot3.h"

/* Modes for internal flag */
#define	TP_MARK		1		/* Draw marks */
#define	TP_LINE		2		/* Draw lines */

/*
 *			T P _ I 2 L I S T
 * 
 *  Take a set of x,y coordinates, and plot them as a
 *  polyline, ie, connect them with line segments.
 *  For markers, use tp_mlist(), below.
 *  This "C" interface expects arrays of INTs.
 */
void
tp_i2list(register FILE *fp, register int *x, register int *y, register int npoints)
             	    
            	   			/* array of points */
            	   			/* array of points */
            	        
{
	if( npoints <= 0 )
		return;

	pl_move( fp, *x++, *y++ );
	while( --npoints > 0 )
		pl_cont( fp, *x++, *y++ );
}

/*
 *			T P _ 2 L I S T
 * 
 *  Take a set of x,y coordinates, and plot them as a
 *  polyline, ie, connect them with line segments.
 *  For markers, use tp_mlist(), below.
 *  This "C" interface expects arrays of DOUBLES.
 */
void
tp_2list(register FILE *fp, register double *x, register double *y, register int npoints)
             	    
               	   			/* array of points */
               	   			/* array of points */
            	        
{
	if( npoints <= 0 )
		return;

	pd_move( fp, *x++, *y++ );
	while( --npoints > 0 )
		pd_cont( fp, *x++, *y++ );
}

void
PL_FORTRAN(f2list, F2LIST)( fpp, x, y, n )
FILE		**fpp;
register float	*x;
register float	*y;
int		*n;
{
	register int npoints = *n-1;	/* FORTRAN uses 1-based subscripts */
	register FILE	*fp = *fpp;

	if( npoints <= 0 )
		return;

	pd_move( fp, *x++, *y++ );
	while( --npoints > 0 )
		pd_cont( fp, *x++, *y++ );
}

/*
 *			T P _ 3 L I S T
 */
void
tp_3list(FILE *fp, register double *x, register double *y, register double *z, register int npoints)
{
	if( npoints <= 0 )
		return;

	pd_3move( fp, *x++, *y++, *z++ );
	while( --npoints > 0 )
		pd_3cont( fp, *x++, *y++, *z++ );
}

void
PL_FORTRAN(f3list, F3LIST)( fpp, x, y, z, n )
FILE		**fpp;
register float	*x;
register float	*y;
register float	*z;
int		*n;
{
	register int npoints = *n-1;	/* FORTRAN uses 1-based subscripts */
	register FILE	*fp = *fpp;

	if( npoints <= 0 )
		return;

	pd_3move( fp, *x++, *y++, *z++ );
	while( --npoints > 0 )
		pd_3cont( fp, *x++, *y++, *z++ );
}

/*
 *			T P _ 2 M L I S T
 *
 *  Take a set of x,y co-ordinates and plots them,
 *  with a combination of connecting lines and/or place markers.
 *  It is important to note that the arrays
 *  are arrays of doubles, and express UNIX-plot coordinates in the
 *  current pl_space().
 *
 *  tp_scale(TIG) may be called first to optionally re-scale the data.
 *
 *  The 'mark' character to be used for marking points off can be any
 *  printing ASCII character, or 001 to 005 for the special marker characters.
 *
 *  In addition, the value of the 'flag' variable determines the type
 *  of line to be drawn, as follows:
 *
 *	0	Draw nothing (rather silly)
 *	1	Marks only, no connecting lines.  Suggested interval=1.
 *	2	Draw connecting lines only.
 *	3	Draw line and marks
 */
void
tp_2mlist(FILE *fp, register double *x, register double *y, int npoints, int flag, int mark, int interval, double size)
    		    
               	   
               	   			/* arrays of points */
   		        
   		     			/* TP_MARK|TP_LINE */
   		     			/* marker character to use */
   		         		/* marker drawn every N points */
      		     			/* marker size */
{
	register int i;			/* index variable */
	register int counter;		/* interval counter */

	if( npoints <= 0 )
		return;

	if( flag & TP_LINE )
		tp_2list( fp, x, y, npoints );
	if( flag & TP_MARK )  {
		tp_2marker( fp, mark, *x++, *y++, size );
		counter = 1;		/* Already plotted one */
		for( i=1; i<npoints; i++ )  {
			if( counter >= interval )  {
				tp_2marker( fp, mark, *x, *y, size );
				counter = 0;	/* We made a mark */
			}
			x++; y++;
			counter++;		/* One more point done */
		}
	}
}

/*
 *  This FORTRAN interface expects arrays of REALs (single precision).
 */
void
PL_FORTRAN(f2mlst, F2MLST)( fp, x, y, np, flag, mark, interval, size )
FILE	**fp;
float	*x;
float	*y;
int	*np;
int	*flag;		/* indicates user's mode request */
int	*mark;
int	*interval;
float	*size;
{
	register int i;			/* index variable */
	register int counter;		/* interval counter */
	register int npoints = *np-1;

	if( npoints <= 0 )
		return;

	if( *flag & TP_LINE )
		PL_FORTRAN(f2list,F2LIST)( fp, x, y, np );
	if( *flag & TP_MARK )  {
		tp_2marker( *fp, *mark, *x++, *y++, *size );
		counter = 1;			/* We already plotted one */
		for( i=1; i<npoints; i++ )  {
			if( counter >= *interval )  {
				tp_2marker( *fp, *mark, *x, *y, *size );
				counter = 0;	/* Made a mark */
			}
			x++; y++;
			counter++;		/* One more point done */
		}
	}
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/list.c,v 11.5 2004/04/05 07:46:41 morrison Exp $ (BRL)";
@


11.5
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/list.c,v 11.2 2000/07/11 23:30:38 cjohnson Exp $ (BRL)";
d43 5
a47 5
tp_i2list( fp, x, y, npoints )
register FILE	*fp;
register int	*x;			/* array of points */
register int	*y;			/* array of points */
register int	npoints;
d66 5
a70 5
tp_2list( fp, x, y, npoints )
register FILE	*fp;
register double	*x;			/* array of points */
register double	*y;			/* array of points */
register int	npoints;
d102 1
a102 6
tp_3list( fp, x, y, z, npoints )
FILE		*fp;
register double	*x;
register double	*y;
register double	*z;
register int	npoints;
d154 9
a162 9
tp_2mlist( fp, x, y, npoints, flag, mark, interval, size )
FILE		*fp;
register double	*x;
register double	*y;			/* arrays of points */
int		npoints;
int		flag;			/* TP_MARK|TP_LINE */
int		mark;			/* marker character to use */
int		interval;		/* marker drawn every N points */
double		size;			/* marker size */
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/list.c,v 11.4 2002/08/20 17:07:36 jra Exp $ (BRL)";
d43 5
a47 5
tp_i2list(register FILE *fp, register int *x, register int *y, register int npoints)
             	    
            	   			/* array of points */
            	   			/* array of points */
            	        
d66 5
a70 5
tp_2list(register FILE *fp, register double *x, register double *y, register int npoints)
             	    
               	   			/* array of points */
               	   			/* array of points */
            	        
d102 6
a107 1
tp_3list(FILE *fp, register double *x, register double *y, register double *z, register int npoints)
d159 9
a167 9
tp_2mlist(FILE *fp, register double *x, register double *y, int npoints, int flag, int mark, int interval, double size)
    		    
               	   
               	   			/* arrays of points */
   		        
   		     			/* TP_MARK|TP_LINE */
   		     			/* marker character to use */
   		         		/* marker drawn every N points */
      		     			/* marker size */
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 5
a47 5
tp_i2list(register FILE *fp, register int *x, register int *y, register int npoints)
             	    
            	   			/* array of points */
            	   			/* array of points */
            	        
d66 5
a70 5
tp_2list(register FILE *fp, register double *x, register double *y, register int npoints)
             	    
               	   			/* array of points */
               	   			/* array of points */
            	        
d102 6
a107 1
tp_3list(FILE *fp, register double *x, register double *y, register double *z, register int npoints)
d159 9
a167 9
tp_2mlist(FILE *fp, register double *x, register double *y, int npoints, int flag, int mark, int interval, double size)
    		    
               	   
               	   			/* arrays of points */
   		        
   		     			/* TP_MARK|TP_LINE */
   		     			/* marker character to use */
   		         		/* marker drawn every N points */
      		     			/* marker size */
@


11.2
log
@LINT picking.  Missing includes and static const for RCSids
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/list.c,v 11.1 1995/01/04 09:51:15 mike Rel4_4 $ (BRL)";
d43 5
a47 5
tp_i2list( fp, x, y, npoints )
register FILE	*fp;
register int	*x;			/* array of points */
register int	*y;			/* array of points */
register int	npoints;
d66 5
a70 5
tp_2list( fp, x, y, npoints )
register FILE	*fp;
register double	*x;			/* array of points */
register double	*y;			/* array of points */
register int	npoints;
d102 1
a102 6
tp_3list( fp, x, y, z, npoints )
FILE		*fp;
register double	*x;
register double	*y;
register double	*z;
register int	npoints;
d154 9
a162 9
tp_2mlist( fp, x, y, npoints, flag, mark, interval, size )
FILE		*fp;
register double	*x;
register double	*y;			/* arrays of points */
int		npoints;
int		flag;			/* TP_MARK|TP_LINE */
int		mark;			/* marker character to use */
int		interval;		/* marker drawn every N points */
double		size;			/* marker size */
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/list.c,v 10.3 94/10/11 16:59:25 mike Exp $ (BRL)";
@


10.3
log
@Applied fix from Tim Smith, using PL_FORTRAN() macro to make
interface conventions match.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/list.c,v 10.2 94/08/12 19:18:07 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/list.c,v 10.1 1991/10/12 06:36:35 mike Rel4_0 gdurf $ (BRL)";
d213 1
a213 1
		F2LIST( fp, x, y, np );
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/list.c,v 9.6 91/09/24 20:24:07 butler Exp $ (BRL)";
d22 2
@


9.6
log
@tp_2marker() expects (int) not (int *) as second argument
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/list.c,v 9.5 91/09/23 16:37:44 butler Exp Locker: butler $ (BRL)";
@


9.5
log
@user specified marker was not being provided to tp_2marker()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/list.c,v 9.4 91/07/02 01:14:53 mike Exp $ (BRL)";
d213 1
a213 1
		tp_2marker( *fp, mark, *x++, *y++, *size );
d217 1
a217 1
				tp_2marker( *fp, mark, *x, *y, *size );
@


9.4
log
@TIG-Pack is now part of libplot3
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libplot3/RCS/list.c,v 9.3 91/05/31 11:26:02 mike Exp $ (BRL)";
a204 1
	int mk;
d213 1
a213 1
		tp_2marker( *fp, mk, *x++, *y++, *size );
d217 1
a217 1
				tp_2marker( *fp, mk, *x, *y, *size );
@


9.3
log
@ANSI prototypes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libtig/RCS/list.c,v 9.2 90/11/25 11:42:20 cjohnson Exp $ (BRL)";
d24 2
a26 1
#include "./tig.h"
@


9.2
log
@Change the fortran routines to use the F macro from
libplot3/fortran.c to generate subroutine names. (case and trailing 
underscore)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/libtig/RCS/list.c,v 9.1 89/05/19 05:49:44 mike Rel3_5 $ (BRL)";
d24 1
d31 17
d49 5
d65 2
a66 1
register double	*x, *y;			/* arrays of points */
d78 1
a78 1
F(f2list, F2LIST)( fpp, x, y, n )
d80 2
a81 1
register float	*x, *y;
d101 3
a103 1
register double	*x, *y, *z;
d115 1
a115 1
F(f3list, F3LIST)( fpp, x, y, z, n )
d117 3
a119 1
register float	*x, *y, *z;
d158 2
a159 1
register double	*x, *y;			/* arrays of points */
d192 1
a192 1
F(f2mlst, F2MLST)( fp, x, y, np, flag, mark, interval, size )
d194 2
a195 1
float	*x, *y;
d198 2
a199 1
int	*mark, *interval;
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: list.c,v 8.1 88/10/05 00:28:42 mike Rel3_0 $ (BRL)";
d24 1
d54 1
a54 1
F2LIST( fpp, x, y, n )
d88 1
a88 1
F3LIST( fpp, x, y, z, n )
d162 1
a162 1
F2MLST( fp, x, y, np, flag, mark, interval, size )
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: list.c,v 7.7 88/09/23 23:50:42 mike Exp $ (BRL)";
@


7.7
log
@Fixed arg declaration.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: list.c,v 7.6 88/05/13 22:24:53 mike Locked $ (BRL)";
@


7.6
log
@fixed hiding of arg "flag".
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: list.c,v 7.5 88/05/13 22:22:55 mike Locked $ (BRL)";
d162 1
a162 1
FILE	*fp;
@


7.5
log
@lint fix
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: list.c,v 7.4 88/02/08 23:41:31 mike Locked $ (BRL)";
d165 1
a165 1
int	*flag;
a168 1
	register int flag;		/* indicates user's mode request */
d177 1
a177 1
	if( flag & TP_LINE )
d179 1
a179 1
	if( flag & TP_MARK )  {
@


7.4
log
@Latest round of cleanups and name changes.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d38 1
d52 1
d72 1
d86 1
d125 1
d160 1
@


7.3
log
@Added tp_3line and F3LINE
@
text
@d2 1
a2 1
 *			L I N E . C
d4 2
a5 2
 *	Terminal Independant Graphics Display Package
 *		Mike Muuss  August 04, 1978
d7 11
d19 4
d26 2
a27 2
#define	DO_MARK		1		/* Draw marks */
#define	DO_LINE		2		/* Draw lines */
d31 1
a31 1
 *			T P _ L I N E
d35 1
a35 1
 *  For markers, use tp_mline(), below.
d38 2
a39 2
tp_line( fp, x, y, npoints )
FILE		*fp;
d51 4
a54 4
FLINE( fpp, x, y, n )
FILE	**fpp;
float	*x, *y;
int	*n;
d56 2
a57 2
	FILE	*fp = *fpp;
	register int npoints = *n;
d68 1
a68 1
 *			T P _ 3 L I N E
d70 1
a70 1
tp_3line( fp, x, y, z, npoints )
d83 4
a86 4
F3LINE( fpp, x, y, z, n )
FILE	**fpp;
float	*x, *y, *z;
int	*n;
d88 2
a89 2
	FILE	*fp = *fpp;
	register int npoints = *n;
d100 1
a100 1
 *			T P _ M L I N E
d111 3
a113 2
 *  printing character, or 001 to 005 for the special marker characters.
 *  In addition, the sign of the mark character determines the type
d115 5
a119 3
 *	-	Marks only, no connecting lines.  Suggested interval=1.
 *	0	Draw connecting lines only.
 *	+	Draw line and marks
d121 1
a121 1
tp_mline( fp, x, y, npoints, mark, interval, scale )
d125 1
d128 1
a128 1
double		scale;			/* marker scale */
a129 1
	register int flag;		/* indicates user's mode request */
d136 6
a141 23
	/* Determine line drawing mode */
	if( mark < 0 )  {
		flag = DO_MARK;
		mark = (-mark);
	} else {
		if( mark > 0 )
			flag = DO_MARK | DO_LINE;
		else
			flag = DO_LINE;
	}

	if( flag & DO_MARK )  {
		pd_move( fp, *x, *y );
		tp_marker( fp, mark, *x, *y, scale );
	}

	x++, y++;
	counter = 1;			/* We already plotted one */
	for( i=1; i<npoints; i++ )  {
		if( flag & DO_LINE )
			pd_line( fp, x[-1], y[-1], *x, *y );

		if( flag & DO_MARK )  {
d143 1
a143 1
				tp_marker( fp, mark, *x, *y, scale );
d146 1
d155 1
a155 1
FMLINE( fp, x, y, npoints, mark, interval, scale )
d157 5
a161 3
double	*x, *y;
int	*npoints, *mark, *interval;
float	*scale;
d167 1
d172 6
a177 22
	/* Determine line drawing mode */
	if( (mk = *mark) < 0 )  {
		flag = DO_MARK;
		mk = (-mk);
	} else if( mark > 0 ) {
		flag = DO_MARK | DO_LINE;
	} else {
		flag = DO_LINE;
	}

	if( flag & DO_MARK )  {
		pd_move( fp, *x, *y );
		tp_marker( fp, mk, *x, *y, scale );
	}

	x++, y++;
	counter = 1;			/* We already plotted one */
	for( i=1; i<*npoints; i++ )  {
		if( flag & DO_LINE )
			pd_line( fp, x[-1], y[-1], *x, *y );

		if( flag & DO_MARK )  {
d179 1
a179 1
				tp_marker( fp, mk, *x, *y, scale );
d182 1
@


7.2
log
@Beginning of new version for floating point.
@
text
@a35 3
/*
 *  This FORTRAN interface expects arrays of REALs (single precision).
 */
d50 32
@


7.1
log
@Release 2.3
@
text
@d18 4
a21 3
 *  Take a set of integer x,y coordinates, and plot them as a
 *  polyline, ie, connect them with line segments.  For markers,
 *  use tp_mline(), below.
d25 2
a26 2
register int	*x, *y;			/* arrays of integer points */
int		npoints;		/* numbers of points */
d28 2
a29 1
	register int i;
d31 16
d50 3
a52 3
	pl_move( fp, *x++, *y++ );
	for( i=1; i<npoints; i++ )
		pl_cont( fp, *x++, *y++ );
d58 1
a58 1
 *  Take a set of integer x,y co-ordinates and plots them,
d61 2
a62 3
 *  are arrays of integers, and express UNIX-plot coordinates in the
 *  current pl_space(). For most uses, SCALE(TIG) should be called first to
 *  appropriately scale the data.
d64 2
d76 3
a78 3
register int	*x, *y;			/* arrays of integer points */
int		npoints;		/* numbers of points */
int		mark;			/* marker characters */
d101 1
a101 1
		pl_move( fp, *x, *y );
d109 1
a109 1
			pl_line( fp, x[-1], y[-1], *x, *y );
a120 1

d122 1
a122 1
 *	FORTRAN-IV Interface Entries
d124 1
a124 2

fline( fp, x, y, npoints )
d126 3
a128 1
int	*x, *y, *npoints;
d130 4
a133 3
	/* Need to offset array by 1 for fortran 1-based arrays? */
	tp_line( fp, x, y, *npoints );
}
d135 32
a166 6
fmline( fp, x, y, npoints, mark, interval, scale )
FILE	*fp;
int	*x, *y, *npoints, *mark, *interval;
float	*scale;
{
	tp_mline( fp, x, y, *npoints, *mark, *interval, *scale );
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


1.1
log
@Initial revision
@
text
@@
