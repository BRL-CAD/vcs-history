head	1.16;
access;
symbols
	ansi-20040405-merged:1.13.2.1
	postmerge-20040405-ansi:1.14
	premerge-20040404-ansi:1.13
	postmerge-autoconf:1.13
	autoconf-freeze:1.13
	premerge-autoconf:1.13
	ansi-20040316-freeze:1.13.2.1
	postmerge-20040315-windows:1.13
	premerge-20040315-windows:1.13
	windows-20040315-freeze:1.13
	autoconf-20031203:1.13
	autoconf-20031202:1.13
	autoconf-branch:1.13.0.10
	phong-branch:1.13.0.8
	photonmap-branch:1.13.0.6
	rel-6-1-DP:1.13
	windows-branch:1.13.0.4
	rel-6-0-2:1.11
	ansi-branch:1.13.0.2
	rel-6-0-1-branch:1.11.0.2
	hartley-6-0-post:1.12
	hartley-6-0-pre:1.11
	rel-6-0-1:1.11
	rel-6-0:1.11
	rel-5-4:1.8
	offsite-5-3-pre:1.10
	rel-5-3:1.8
	rel-5-2:1.8
	rel-5-1-branch:1.8.0.2
	rel-5-1:1.8
	rel-5-0:1.4
	rel-5-0-beta:1.4
	rel-4-5:1.2
	ctj-4-5-post:1.1
	ctj-4-5-pre:1.1;
locks; strict;
comment	@ * @;


1.16
date	2004.05.21.18.06.22;	author morrison;	state dead;
branches;
next	1.15;

1.15
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.20.17.07.36;	author jra;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2002.08.15.20.54.48;	author hartley;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.20.22.29.01;	author morrison;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.07.21.05.59;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.07.05.47.28;	author cjohnson;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.29.17.46.56;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.13.03.29.43;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.10.15.50.02;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	99.12.29.20.20.36;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	98.07.12.04.28.57;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	98.06.15.13.14.40;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	98.01.12.12.04.03;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	96.09.14.03.34.08;	author butler;	state Exp;
branches;
next	;

1.13.2.1
date	2002.09.19.18.01.09;	author morrison;	state Exp;
branches;
next	;


desc
@support for procedural and fractal noise
@


1.16
log
@moved to src/
@
text
@/*  S N O I S E . C
 *
 *  Signed noise functions
 *
 *	bn_noise_perlin	Robert Skinner's Perlin-style "Noise" function
 *	bn_noise_vec	Vector-valued noise
 *
 *  Spectral Noise functions
 *
 *	bn_noise_fbm	fractional Brownian motion.  Based on bn_noise_perlin
 *	bn_noise_turb	turbulence.  Based on bn_noise_perlin
 *
 *  These noise functions provide mostly random noise at the integer lattice
 *  points.  The functions should be evaluated at non-integer locations for
 *  their nature to be realized.
 *
 *  Author - 
 *	Lee A. Butler
 *	F. Kenton Musgrave
 *	Robert Skinner
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/noise.c,v 1.15 2004/05/10 15:30:43 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"



/* SMOOTHSTEP() takes a value in the range [0:1] and provides a number
 * in the same range indicating the amount of (a) present in a smooth
 * interpolation transition between (a) and (b)
 */
#define SMOOTHSTEP(x)	(  (x) * (x) * (3 - 2*(x))  )



/* FILTER_ARGS() folds space to extend the domain over which we can take
 * noise values.
 *
 * x, y, z are set to the noise space location for the source point.
 * ix, iy, iz are the integer lattice point (integer portion of x,y,z)
 * fx, fy, fz are the fractional lattice distance above ix,iy,iz
 *
 * The noise function has a finite domain, which can be exceeded when
 * using fractal textures with very high frequencies.  This routine is
 * designed to extend the effective domain of the function, albeit by
 * introducing periodicity.	-FKM 4/93
 */

#define FLOOR(x)	(  (int)(x) - (  (x) < 0 && (x) != (int)(x)  )  )

#if 0
#define MAXVAL  	2147483647.  /* (2^31)-1 max val for noise integers */
#define TWICE_MAXVAL 	4294967294.

/* XXX Do we need this for 64bit integer architectures?
 *
 * #define MAXVAL	  	 9223372036854775807.
 * #define TWICE_MAXVAL 	18446744073709551615.
 * #endif
 */


#define FILTER_ARGS( src) {\
	register int i; \
	point_t dst; \
 \
	for (i=0 ; i < 3 ; i++) { \
		/* assure values are positive */ \
		if (src[i] < 0) dst[i] = -src[i]; \
		else dst[i] = src[i]; \
 \
		/* fold space */ \
		while (dst[i] > MAXVAL || dst[i]<0) \
			if (dst[i] > MAXVAL) \
				dst[i] = TWICE_MAXVAL - dst[i]; \
			else \
				dst[i] = -dst[i]; \
	} \
\
	x = dst[0];	ix = FLOOR(x);	fx = x - ix; \
	y = dst[1];	iy = FLOOR(y);	fy = y - iy; \
	z = dst[2];	iz = FLOOR(z);	fz = z - iz; \
}
#endif
static void
filter_args(fastf_t *src, fastf_t *p, fastf_t *f, int *ip)
{
	register int i;
	point_t dst;
	static unsigned long max2x = ~((unsigned long)0);
	static unsigned long max = (~((unsigned long)0)) >> 1;

	for (i=0 ; i < 3 ; i++) {
		/* assure values are positive */
		if (src[i] < 0) dst[i] = -src[i];
		else dst[i] = src[i];


		/* fold space */
		while (dst[i] > max || dst[i]<0) {
			if (dst[i] > max) {
				dst[i] = max2x - dst[i];
			} else {
				dst[i] = -dst[i];
			}
		}

	}

	p[X] = dst[0];	ip[X] = FLOOR(p[X]);	f[X] = p[X] - ip[X];
	p[Y] = dst[1];	ip[Y] = FLOOR(p[Y]);	f[Y] = p[Y] - ip[Y];
	p[Z] = dst[2];	ip[Z] = FLOOR(p[Z]);	f[Z] = p[Z] - ip[Z];
}


/* 
 * The RTable maps numbers into the range [-1..1]
 */
#define MAXSIZE 267	/* 255 + 3 * (4 values) */
static double	RTable[MAXSIZE];

#define INCRSUM(m,s,x,y,z)	((s)*(RTable[m]*0.5		\
					+ RTable[m+1]*(x)	\
					+ RTable[m+2]*(y)	\
					+ RTable[m+3]*(z)))



/*
 *  A heavily magic-number protected version of the hashtable.
 *
 *  This table is used to convert integers into repeatable random results
 *  for indicies into RTable.
 */

struct str_ht {
	long	magic;	
	char	hashTableValid;
	long	*hashTableMagic1;
	short	*hashTable;
	long	*hashTableMagic2;
	long	magic_end;	
};

static struct str_ht ht;

#define MAGIC_STRHT1	1771561
#define MAGIC_STRHT2	1651771
#define MAGIC_TAB1	   9823
#define MAGIC_TAB2	 784642
#define CK_HT() { \
	BU_CKMAG(&ht.magic, MAGIC_STRHT1, "struct str_ht ht 1"); \
	BU_CKMAG(&ht.magic_end, MAGIC_STRHT2, "struct str_ht ht 2"); \
	BU_CKMAG(ht.hashTableMagic1, MAGIC_TAB1, "hashTable Magic 1"); \
	BU_CKMAG(ht.hashTableMagic2, MAGIC_TAB2, "hashTable Magic 2"); \
	if (ht.hashTable != (short *)&ht.hashTableMagic1[1] ) \
		bu_bomb("ht.hashTable changed rel ht.hashTableMagic1"); \
	if (ht.hashTableMagic2 != (long *)&ht.hashTable[4096] ) \
		bu_bomb("ht.hashTable changed rel ht.hashTableMagic2"); \
}

/* 
 * Map integer point into repeatable random number [0..4095] 
 * We actually only use the first 8 bits of the final value extracted from
 * this table.  It's not quite clear that we really need this big a table.
 * The extra size does provide some extra randomness for intermediate results.
 */
#define Hash3d(a,b,c) \
	ht.hashTable[  \
		ht.hashTable[  \
			ht.hashTable[(a) & 0xfff] ^ ((b) & 0xfff) \
		]  ^ ((c) & 0xfff) \
	]


void
bn_noise_init(void)
{
	int i, j, k, temp;
	int rndtabi = BN_RAND_TABSIZE - 1;
	
	bu_semaphore_acquire( BU_SEM_BN_NOISE );

	if (ht.hashTableValid) {
		bu_semaphore_release( BU_SEM_BN_NOISE );
		return;
	}

	BN_RANDSEED(rndtabi, (BN_RAND_TABSIZE-1) );
	ht.hashTableMagic1 = (long *) bu_malloc(
		2*sizeof(long) + 4096*sizeof(short int),
		"noise hashTable");
	ht.hashTable = (short *)&ht.hashTableMagic1[1];
	ht.hashTableMagic2 = (long *)&ht.hashTable[4096];

	*ht.hashTableMagic1 = MAGIC_TAB1;
	*ht.hashTableMagic2 = MAGIC_TAB2;

	ht.magic_end = MAGIC_STRHT2;
	ht.magic = MAGIC_STRHT1;

	for (i = 0; i < 4096; i++)
		ht.hashTable[i] = i;

	/* scramble the hash table */
	for (i = 4095; i > 0; i--) {
		j = (int)(BN_RANDOM(rndtabi) * 4096.0);

		temp = ht.hashTable[i];
		ht.hashTable[i] = ht.hashTable[j];
		ht.hashTable[j] = temp;
	}

	BN_RANDSEED(k, 13);

	for (i = 0; i < MAXSIZE; i++)
		RTable[i] = BN_RANDOM(k) * 2.0 - 1.0;


	ht.hashTableValid = 1;

	bu_semaphore_release( BU_SEM_BN_NOISE );


	CK_HT();
}



/*
 * Robert Skinner's Perlin-style "Noise" function
 *
 * Results are in the range [-0.5 .. 0.5].  Unlike many implementations,
 * this function provides random noise at the integer lattice values.  
 * However this produces much poorer quality and should be avoided if 
 * possible.
 *
 * The power distribution of the result has no particular shape, though it 
 * isn't as flat as the literature would have one believe.
 */
double
bn_noise_perlin(fastf_t *point)
{
	register int	jx, jy, jz;
	int ix, iy, iz;	/* lower integer lattice point */
	double x, y, z;	/* corrected point */
	double fx, fy, fz;	/* distance above integer lattice point */
	double	sx, sy, sz, tx, ty, tz;
	double	sum;
	short	m;
	point_t p, f;
	int ip[3];

	if (!ht.hashTableValid) bn_noise_init();
	else {
/*		CK_HT(); */
	}

	/* IS: const fastf_t *, point_t, point_t, int[3] */
	/* NE: fastf_t *, fastf_t *, fastf_t *, int *    */
	filter_args( point, p, f, ip);
	ix = ip[X];
	iy = ip[Y];
	iz = ip[Z];

	fx = f[X];
	fy = f[Y];
	fz = f[Z];

	x = p[X];
	y = p[Y];
	z = p[Z];

	jx = ix + 1; /* (jx,jy,jz) = integer lattice point above (ix,iy,iz) */
	jy = iy + 1; 
	jz = iz + 1;

	sx = SMOOTHSTEP(fx); 
	sy = SMOOTHSTEP(fy); 
	sz = SMOOTHSTEP(fz);

	/* the complement values of sx,sy,sz */
	tx = 1.0 - sx; 
	ty = 1.0 - sy; 
	tz = 1.0 - sz;

	/*
	 *  interpolate!
	 */
	/* get a repeatable random # 0..4096 & 0xFF*/
	m = Hash3d( ix, iy, iz ) & 0xFF;
	sum = INCRSUM(m,(tx*ty*tz),(x-ix),(y-iy),(z-iz));

	m = Hash3d( jx, iy, iz ) & 0xFF;
	sum += INCRSUM(m,(sx*ty*tz),(x-jx),(y-iy),(z-iz));

	m = Hash3d( ix, jy, iz ) & 0xFF;
	sum += INCRSUM(m,(tx*sy*tz),(x-ix),(y-jy),(z-iz));

	m = Hash3d( jx, jy, iz ) & 0xFF;
	sum += INCRSUM(m,(sx*sy*tz),(x-jx),(y-jy),(z-iz));

	m = Hash3d( ix, iy, jz ) & 0xFF;
	sum += INCRSUM(m,(tx*ty*sz),(x-ix),(y-iy),(z-jz));

	m = Hash3d( jx, iy, jz ) & 0xFF;
	sum += INCRSUM(m,(sx*ty*sz),(x-jx),(y-iy),(z-jz));

	m = Hash3d( ix, jy, jz ) & 0xFF;
	sum += INCRSUM(m,(tx*sy*sz),(x-ix),(y-jy),(z-jz));

	m = Hash3d( jx, jy, jz ) & 0xFF;
	sum += INCRSUM(m,(sx*sy*sz),(x-jx),(y-jy),(z-jz));

	return sum;

}

/*
 * Vector-valued "Noise"
 */
void
bn_noise_vec(fastf_t *point, fastf_t *result)
{
	register int	jx, jy, jz;
	int ix, iy, iz;		/* lower integer lattice point */
	double x, y, z;		/* corrected point */
	double		px, py, pz, s;
	double		sx, sy, sz, tx, ty, tz;
	short		m;
	point_t p, f;
	int ip[3];


	if ( ! ht.hashTableValid ) bn_noise_init();


	/* sets:
	 * x,y,z to range [0..maxval],
	 * ix,iy,iz to integer portion,
	 * fx,fy,fz to fractional portion
	 */
	filter_args( point, p, f, ip);
	ix = ip[X];
	iy = ip[Y];
	iz = ip[Z];

	x = p[X];
	y = p[Y];
	z = p[Z];

	jx = ix+1;   jy = iy + 1;   jz = iz + 1;

	sx = SMOOTHSTEP(x - ix); 
	sy = SMOOTHSTEP(y - iy); 
	sz = SMOOTHSTEP(z - iz);

	/* the complement values of sx,sy,sz */
	tx = 1.0 - sx; 
	ty = 1.0 - sy; 
	tz = 1.0 - sz;

	/*
	 *  interpolate!
	 */
	m = Hash3d( ix, iy, iz ) & 0xFF;
	px = x-ix;  
	py = y-iy;  
	pz = z-iz;
	s = tx*ty*tz;
	result[0] = INCRSUM(m,s,px,py,pz);
	result[1] = INCRSUM(m+4,s,px,py,pz);
	result[2] = INCRSUM(m+8,s,px,py,pz);

	m = Hash3d( jx, iy, iz ) & 0xFF;
	px = x-jx;
	s = sx*ty*tz;
	result[0] += INCRSUM(m,s,px,py,pz);
	result[1] += INCRSUM(m+4,s,px,py,pz);
	result[2] += INCRSUM(m+8,s,px,py,pz);

	m = Hash3d( jx, jy, iz ) & 0xFF;
	py = y-jy;
	s = sx*sy*tz;
	result[0] += INCRSUM(m,s,px,py,pz);
	result[1] += INCRSUM(m+4,s,px,py,pz);
	result[2] += INCRSUM(m+8,s,px,py,pz);

	m = Hash3d( ix, jy, iz ) & 0xFF;
	px = x-ix;
	s = tx*sy*tz;
	result[0] += INCRSUM(m,s,px,py,pz);
	result[1] += INCRSUM(m+4,s,px,py,pz);
	result[2] += INCRSUM(m+8,s,px,py,pz);

	m = Hash3d( ix, jy, jz ) & 0xFF;
	pz = z-jz;
	s = tx*sy*sz;
	result[0] += INCRSUM(m,s,px,py,pz);
	result[1] += INCRSUM(m+4,s,px,py,pz);
	result[2] += INCRSUM(m+8,s,px,py,pz);

	m = Hash3d( jx, jy, jz ) & 0xFF;
	px = x-jx;
	s = sx*sy*sz;
	result[0] += INCRSUM(m,s,px,py,pz);
	result[1] += INCRSUM(m+4,s,px,py,pz);
	result[2] += INCRSUM(m+8,s,px,py,pz);

	m = Hash3d( jx, iy, jz ) & 0xFF;
	py = y-iy;
	s = sx*ty*sz;
	result[0] += INCRSUM(m,s,px,py,pz);
	result[1] += INCRSUM(m+4,s,px,py,pz);
	result[2] += INCRSUM(m+8,s,px,py,pz);

	m = Hash3d( ix, iy, jz ) & 0xFF;
	px = x-ix;
	s = tx*ty*sz;
	result[0] += INCRSUM(m,s,px,py,pz);
	result[1] += INCRSUM(m+4,s,px,py,pz);
	result[2] += INCRSUM(m+8,s,px,py,pz);
}
/*************************************************************
 *
 *	Spectral Noise functions
 *
 *************************************************************
 *
 *	The Spectral Noise functions cache the values of the
 *	term:
 *		    (-h_val)
 *		freq
 *
 *	Which on some systems is rather expensive to compute.
 *
 *************************************************************/
struct fbm_spec {
	long	magic;
	double	octaves;
	double	lacunarity;
	double	h_val;
	double	remainder;
	double	*spec_wgts;
};
#define MAGIC_fbm_spec_wgt 0x837592

static struct fbm_spec *etbl = (struct fbm_spec *)NULL;
static int etbl_next = 0;
static int etbl_size = 0;

#define PSCALE(_p, _s) _p[0] *= _s; _p[1] *= _s; _p[2] *= _s
#define PCOPY(_d, _s) _d[0] = _s[0]; _d[1] = _s[1]; _d[2] = _s[2]



static struct fbm_spec *
build_spec_tbl(double h_val, double lacunarity, double octaves)
{
	struct fbm_spec	*ep;
	double		*spec_wgts;
	double		frequency;
	int		i;

	/* The right spectral weights table for these parameters has not been
	 * pre-computed.  As a result, we compute the table now and save it
	 * with the knowledge that we'll likely want it again later.
	 */

	/* allocate storage for new tables if needed */
	if (etbl_next >= etbl_size) {
		if (etbl_size) {
			etbl_size *= 2;
			etbl = (struct fbm_spec *)bu_realloc((char *)etbl,
					etbl_size*sizeof(struct fbm_spec),
					"spectral weights table");
		} else
			etbl = (struct fbm_spec *)bu_calloc(etbl_size = 10,
					sizeof(struct fbm_spec),
					"spectral weights table");

		if (!etbl) abort();
	}

	/* set up the next available table */
	ep = &etbl[etbl_next];
	ep->magic = MAGIC_fbm_spec_wgt;	ep->octaves = octaves;
	ep->h_val = h_val;		ep->lacunarity = lacunarity;
	spec_wgts = ep->spec_wgts = 
		(double *)bu_malloc( ((int)(octaves+1)) * sizeof(double),
		"spectral weights" );

	/* precompute and store spectral weights table */
	for (frequency = 1.0, i=0 ; i < octaves ; i++) {
		/* compute weight for each frequency */
		spec_wgts[i] = pow(frequency, -h_val);
		frequency *= lacunarity;
	}

	etbl_next++; /* saved for last in case we're running multi-threaded */
	return ep;
}

/* The first order of business is to see if we have pre-computed
 * the spectral weights table for these parameters in a previous
 * invocation.  If not, the we compute them and save them for
 * possible future use
 */

struct fbm_spec		*
find_spec_wgt(double h, double l, double o)
{
	struct fbm_spec	*ep;
	int i;


	for (ep = etbl, i=0 ; i < etbl_next ; i++, ep++) {
		if (ep->magic != MAGIC_fbm_spec_wgt) bu_bomb("find_spec_wgt");
		if (ep->lacunarity == l && ep->h_val == h && 
			ep->octaves >= o )
				return ep;
	}

	/* we didn't find the table we wanted so we've got to semaphore on
	 * the list to wait our turn to add what we want to the table.
	 */

	bu_semaphore_acquire( BU_SEM_BN_NOISE );

	/* We search the list one more time in case the last process to
	 * hold the semaphore just created the table we were about to add
	 */
	for (ep = etbl, i=0 ; i < etbl_next ; i++, ep++) {
		if (ep->magic != MAGIC_fbm_spec_wgt) bu_bomb("find_spec_wgt");
		if (ep->lacunarity == l && ep->h_val == h && 
			ep->octaves >= o )
		    		break;
	}

	if (i >= etbl_next) ep = build_spec_tbl(h, l, o);

	bu_semaphore_release( BU_SEM_BN_NOISE );

	return (ep);
}
/*
 * Procedural fBm evaluated at "point"; returns value stored in "value".
 * 
 * Parameters:
 *    ``h_val''		fractal increment parameter
 *    ``lacunarity''	gap between successive frequencies
 *    ``octaves''  	number of frequencies in the fBm
 *
 * The spectral properties of the result are in the APPROXIMATE range [-1..1]
 * Depending upon the number of octaves computed, this range may be exceeded.
 * Applications should clamp or scale the result to their needs.
 * The results have a more-or-less gaussian distribution.  Typical 
 * results for 1M samples include:
 *
 * Min           -1.15246
 * Max            1.23146
 * Mean        -0.0138744
 * s.d.          0.306642
 * Var          0.0940295
 * 
 * 
 * 
 * The function call pow() is relatively expensive.  Therfore, this function
 * pre-computes and saves the spectral weights in a table for re-use in 
 * successive invocations.
 */
double
bn_noise_fbm(fastf_t *point, double h_val, double lacunarity, double octaves)
{
	struct fbm_spec		*ep;
	double			value, remainder, *spec_wgts;
	point_t			pt;
	int			i, oct;

	/* The first order of business is to see if we have pre-computed
	 * the spectral weights table for these parameters in a previous
	 * invocation.  If not, the we compute them and save them for
	 * possible future use
	 */

	ep = find_spec_wgt(h_val, lacunarity, octaves);

	/* now we're ready to compute the fBm value */

	value = 0.0;            /* initialize vars to proper values */
	/* copy the point so we don't corrupt the caller's version */
	PCOPY(pt, point);

	spec_wgts = ep->spec_wgts;

	/* inner loop of spectral construction */
	oct=(int)octaves; /* save repeating double->int cast */
	for (i=0 ; i < oct ; i++) {
		value += bn_noise_perlin( pt ) * spec_wgts[i];
		PSCALE(pt, lacunarity);
	}

	remainder = octaves - (int)octaves;
	if ( remainder ) {
		/* add in ``octaves''  remainder
		 * ``i''  and spatial freq. are preset in loop above
		 */
            value += remainder * bn_noise_perlin( pt ) * spec_wgts[i];
	}

	return( value );

} /* bn_noise_fbm() */


/*
 * Procedural turbulence evaluated at "point"; 
 * 
 * returns value stored in "value".
 *
 * Parameters:
 *    ``h_val''		fractal increment parameter
 *    ``lacunarity''	gap between successive frequencies
 *    ``octaves''  	number of frequencies in the fBm
 *
 * The result is characterized by sharp, narrow trenches in low values and
 * a more fbm-like quality in the mid-high values.  Values are in the
 * APPROXIMATE range [0 .. 1] depending upon the number of octaves evaluated.
 * Typical results:
 *
 * Min         0.00857137
 * Max            1.26712
 * Mean          0.395122
 * s.d.          0.174796
 * Var          0.0305536
 *
 * The function call pow() is relatively expensive.  Therfore, this function
 * pre-computes and saves the spectral weights in a table for re-use in 
 * successive invocations.
 */
double
bn_noise_turb(fastf_t *point, double h_val, double lacunarity, double octaves)
{
	struct fbm_spec		*ep;
	double			value, remainder, *spec_wgts;
	point_t			pt;
	int			i, oct;


	/* The first order of business is to see if we have pre-computed
	 * the spectral weights table for these parameters in a previous
	 * invocation.  If not, the we compute them and save them for
	 * possible future use
	 */

#define CACHE_SPECTRAL_WGTS 1
#ifdef CACHE_SPECTRAL_WGTS

	ep = find_spec_wgt(h_val, lacunarity, octaves);

	/* now we're ready to compute the fBm value */

	value = 0.0;            /* initialize vars to proper values */

	/* copy the point so we don't corrupt 
	 * the caller's copy of the variable
	 */
	PCOPY(pt, point);	
	spec_wgts = ep->spec_wgts;

	/* inner loop of spectral construction */
	oct=(int)octaves; /* save repeating double->int cast */
	for (i=0 ; i < oct ; i++) {
		value += fabs(bn_noise_perlin( pt )) * spec_wgts[i];
		PSCALE(pt, lacunarity);
	}

	remainder = octaves - (int)octaves;
	if ( remainder ) {
		/* add in ``octaves''  remainder
		 * ``i''  and spatial freq. are preset in loop above
		 */
            value += remainder * bn_noise_perlin( pt ) * spec_wgts[i];
	}
#else
	PCOPY(pt, point);	

	value = 0.0;            /* initialize vars to proper values */
	frequency = 1.0;

	oct=(int)octaves; /* save repeating double->int cast */
	for (i=0 ; i < oct ; i++) {
		value += fabs(bn_noise_perlin( pt )) * pow(frequency, -h_val);
		frequency *= lacunarity;
		PSCALE(pt, lacunarity);
	}
	
	remainder = octaves - (int)octaves;
	if ( remainder ) {
		/* add in ``octaves''  remainder
		 * ``i''  and spatial freq. are preset in loop above
		 */
            value += remainder * bn_noise_perlin( pt ) * pow(frequency, -h_val);
	}
#endif
	return( value );

} /* bn_noise_turb() */

/***********************************************************************
 *
 *	From "Texturing and Modeling, A Procedural Approach" 2nd ed p338
 *
 *
 */
double
bn_noise_ridged(fastf_t *point, double h_val, double lacunarity, double octaves, double offset)
{
	struct fbm_spec		*ep;
	double			result, weight, signal, *spec_wgts;
	point_t			pt;
	int			i;
	
	/* The first order of business is to see if we have pre-computed
	 * the spectral weights table for these parameters in a previous
	 * invocation.  If not, the we compute them and save them for
	 * possible future use
	 */

	ep = find_spec_wgt(h_val, lacunarity, octaves);

	/* copy the point so we don't corrupt 
	 * the caller's copy of the variable
	 */
	PCOPY(pt, point);	
	spec_wgts = ep->spec_wgts;

	
	/* get first octave */
	signal = bn_noise_perlin(pt);

	/* get absolute value of signal (this creates the ridges) */
	if (signal < 0.0) signal = -signal;

	/* invert and translate (note that "offset shoudl be ~= 1.0 */
	signal = offset - signal;

	/* square the signal, to increase "sharpness" of ridges */
	signal *= signal;

	/* assign initial value */
	result = signal;
	weight = 1.0;

	for (i=1 ; i < octaves ; i++ ) {
		PSCALE(pt, lacunarity);

		signal = bn_noise_perlin(pt);

		if (signal < 0.0) signal = - signal;
		signal = offset - signal;

		/* weight the contribution */
		signal *= weight;
		result += signal * spec_wgts[i];
	}
	return result;
}

/***********************************************************************
 *
 *	From "Texturing and Modeling, A Procedural Approach" 2nd ed
 *
 */

double
bn_noise_mf(fastf_t *point, double h_val, double lacunarity, double octaves, double offset)
{
	double 			frequency = 1.0;
	struct fbm_spec		*ep;
	double			result, weight, signal, *spec_wgts;
	point_t			pt;
	int			i;
	
	/* The first order of business is to see if we have pre-computed
	 * the spectral weights table for these parameters in a previous
	 * invocation.  If not, the we compute them and save them for
	 * possible future use
	 */

	ep = find_spec_wgt( h_val, lacunarity, octaves );

	/* copy the point so we don't corrupt 
	 * the caller's copy of the variable
	 */
	PCOPY( pt, point );
	spec_wgts = ep->spec_wgts;
	offset = 1.0;

	result = (bn_noise_perlin(pt) + offset) * spec_wgts[0];
	weight = result;

	for (i=1 ; i < octaves ; i++) {
		PSCALE(pt, lacunarity);

		if (weight > 1.0) weight = 1.0;

		signal = ( bn_noise_perlin(pt) + offset ) * spec_wgts[i];

		signal += fabs(bn_noise_perlin( pt )) * pow(frequency, -h_val);
		frequency *= lacunarity;
		PSCALE(pt, lacunarity);
	}
	return result;
}





@


1.15
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/noise.c,v 1.14 2004/04/05 07:46:41 morrison Exp $ (ARL)";
@


1.14
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d33 5
a37 1
#include "conf.h"
@


1.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.11 2001/04/20 22:29:01 morrison Exp $ (ARL)";
d103 1
a103 5
filter_args(src, p, f, ip)
point_t src;
point_t p;
point_t f;
int	ip[3];
d194 1
a194 1
bn_noise_init()
d259 1
a259 2
bn_noise_perlin(point)
const point_t point;
d276 2
d340 1
a340 3
bn_noise_vec(point, result)
const point_t point;
point_t result;
d475 1
a475 2
build_spec_tbl(h_val, lacunarity, octaves)
double h_val, lacunarity, octaves;
d528 1
a528 4
find_spec_wgt(h, l, o)
double			h;
double			l;
double			o;
d590 1
a590 5
bn_noise_fbm(point, h_val, lacunarity, octaves)
point_t point;
double h_val;
double lacunarity;
double octaves;
d659 1
a659 5
bn_noise_turb( point, h_val, lacunarity, octaves)
point_t point;
double h_val;
double lacunarity;
double octaves;
d734 1
a734 6
bn_noise_ridged(point, h_val, lacunarity, octaves, offset)
point_t point;
double h_val;
double lacunarity;
double octaves;
double offset;
d794 1
a794 6
bn_noise_mf( point, h_val, lacunarity, octaves, offset)
point_t point;
double h_val;
double lacunarity;
double octaves;
double offset;
@


1.13.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.13 2002/08/20 17:07:36 jra Exp $ (ARL)";
d103 5
a107 1
filter_args(fastf_t *src, fastf_t *p, fastf_t *f, int *ip)
d198 1
a198 1
bn_noise_init(void)
d263 2
a264 1
bn_noise_perlin(fastf_t *point)
a280 2
	/* IS: const fastf_t *, point_t, point_t, int[3] */
	/* NE: fastf_t *, fastf_t *, fastf_t *, int *    */
d343 3
a345 1
bn_noise_vec(fastf_t *point, fastf_t *result)
d480 2
a481 1
build_spec_tbl(double h_val, double lacunarity, double octaves)
d534 4
a537 1
find_spec_wgt(double h, double l, double o)
d599 5
a603 1
bn_noise_fbm(fastf_t *point, double h_val, double lacunarity, double octaves)
d672 5
a676 1
bn_noise_turb(fastf_t *point, double h_val, double lacunarity, double octaves)
d751 6
a756 1
bn_noise_ridged(fastf_t *point, double h_val, double lacunarity, double octaves, double offset)
d816 6
a821 1
bn_noise_mf(fastf_t *point, double h_val, double lacunarity, double octaves, double offset)
@


1.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d103 5
a107 1
filter_args(fastf_t *src, fastf_t *p, fastf_t *f, int *ip)
d198 1
a198 1
bn_noise_init(void)
d263 2
a264 1
bn_noise_perlin(fastf_t *point)
a280 2
	/* IS: const fastf_t *, point_t, point_t, int[3] */
	/* NE: fastf_t *, fastf_t *, fastf_t *, int *    */
d343 3
a345 1
bn_noise_vec(fastf_t *point, fastf_t *result)
d480 2
a481 1
build_spec_tbl(double h_val, double lacunarity, double octaves)
d534 4
a537 1
find_spec_wgt(double h, double l, double o)
d599 5
a603 1
bn_noise_fbm(fastf_t *point, double h_val, double lacunarity, double octaves)
d672 5
a676 1
bn_noise_turb(fastf_t *point, double h_val, double lacunarity, double octaves)
d751 6
a756 1
bn_noise_ridged(fastf_t *point, double h_val, double lacunarity, double octaves, double offset)
d816 6
a821 1
bn_noise_mf(fastf_t *point, double h_val, double lacunarity, double octaves, double offset)
@


1.11
log
@CONST to const
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.10 2000/07/07 21:05:59 butler Exp $ (ARL)";
d103 1
a103 5
filter_args(src, p, f, ip)
point_t src;
point_t p;
point_t f;
int	ip[3];
d194 1
a194 1
bn_noise_init()
d259 1
a259 2
bn_noise_perlin(point)
const point_t point;
d276 2
d340 1
a340 3
bn_noise_vec(point, result)
const point_t point;
point_t result;
d475 1
a475 2
build_spec_tbl(h_val, lacunarity, octaves)
double h_val, lacunarity, octaves;
d528 1
a528 4
find_spec_wgt(h, l, o)
double			h;
double			l;
double			o;
d590 1
a590 5
bn_noise_fbm(point, h_val, lacunarity, octaves)
point_t point;
double h_val;
double lacunarity;
double octaves;
d659 1
a659 5
bn_noise_turb( point, h_val, lacunarity, octaves)
point_t point;
double h_val;
double lacunarity;
double octaves;
d734 1
a734 6
bn_noise_ridged(point, h_val, lacunarity, octaves, offset)
point_t point;
double h_val;
double lacunarity;
double octaves;
double offset;
d794 1
a794 6
bn_noise_mf( point, h_val, lacunarity, octaves, offset)
point_t point;
double h_val;
double lacunarity;
double octaves;
double offset;
@


1.10
log
@Initialized frequency in the _mf function.  Added comment about origins.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.9 2000/07/07 05:47:28 cjohnson Exp $ (ARL)";
d264 1
a264 1
CONST point_t point;
d344 1
a344 1
CONST point_t point;
@


1.9
log
@LINT
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.8 2000/03/29 17:46:56 mike Exp $ (ARL)";
d811 1
a811 2
 *
 *
d823 1
a823 1
	double 			frequency;
@


1.8
log
@
Added appropriate bu_ and bn_ prefixes to things.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.7 2000/03/13 03:29:43 butler Exp $ (ARL)";
d761 1
a761 1
	int			i, oct;
d828 1
a828 1
	int			i, oct;
@


1.7
log
@Added ridged noise function
@
text
@d10 2
a11 2
 *	bn_noise_fbm	fractional Brownian motion.  Based on noise_perlin
 *	bn_noise_turb	turbulence.  Based on noise_perlin
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.6 2000/03/10 15:50:02 butler Exp $ (ARL)";
d173 4
a176 4
	RT_CKMAG(&ht.magic, MAGIC_STRHT1, "struct str_ht ht 1"); \
	RT_CKMAG(&ht.magic_end, MAGIC_STRHT2, "struct str_ht ht 2"); \
	RT_CKMAG(ht.hashTableMagic1, MAGIC_TAB1, "hashTable Magic 1"); \
	RT_CKMAG(ht.hashTableMagic2, MAGIC_TAB2, "hashTable Magic 2"); \
d211 1
a211 1
	ht.hashTableMagic1 = (long *) rt_malloc(
d497 1
a497 1
			etbl = (struct fbm_spec *)rt_realloc((char *)etbl,
d501 1
a501 1
			etbl = (struct fbm_spec *)rt_calloc(etbl_size = 10,
d513 1
a513 1
		(double *)rt_malloc( ((int)(octaves+1)) * sizeof(double),
d629 1
a629 1
		value += noise_perlin( pt ) * spec_wgts[i];
d638 1
a638 1
            value += remainder * noise_perlin( pt ) * spec_wgts[i];
d643 1
a643 1
} /* noise_fbm() */
d708 1
a708 1
		value += fabs(noise_perlin( pt )) * spec_wgts[i];
d717 1
a717 1
            value += remainder * noise_perlin( pt ) * spec_wgts[i];
d727 1
a727 1
		value += fabs(noise_perlin( pt )) * pow(frequency, -h_val);
d737 1
a737 1
            value += remainder * noise_perlin( pt ) * pow(frequency, -h_val);
d742 1
a742 1
} /* noise_turb() */
d779 1
a779 1
	signal = noise_perlin(pt);
d797 1
a797 1
		signal = noise_perlin(pt);
d845 1
a845 1
	result = (noise_perlin(pt) + offset) * spec_wgts[0];
d853 1
a853 1
		signal = ( noise_perlin(pt) + offset ) * spec_wgts[i];
d855 1
a855 1
		signal += fabs(noise_perlin( pt )) * pow(frequency, -h_val);
@


1.6
log
@Change unsigned long initializer from -1 to ~0
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.5 1999/12/29 20:20:36 jra Exp $ (ARL)";
d743 123
@


1.5
log
@Eliminated some unused variables
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.4 1998/07/12 04:28:57 butler Exp $ (ARL)";
d111 2
a112 2
	static unsigned long max2x = -1;
	static unsigned long max = (-1) >> 1;
@


1.4
log
@Made FILTER_ARGS a function and independent of machine int size
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libbn/noise.c,v 1.3 1998/06/15 13:14:40 butler Exp $ (ARL)";
a349 1
	double fx, fy, fz;	/* distance above integer lattice point */
a368 4

	fx = f[X];
	fy = f[Y];
	fz = f[Z];
@


1.3
log
@XXX about 64bit systems
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/noise.c,v 1.2 1998/01/12 12:04:03 butler Exp butler $ (ARL)";
d66 1
d68 1
a78 1
#define FLOOR(x)	(  (int)(x) - (  (x) < 0 && (x) != (int)(x)  )  )
d101 34
d273 2
d280 13
a292 1
	FILTER_ARGS( point); /* sets x,y,z, ix,iy,iz, fx,fy,fz */
d354 2
d366 12
a377 1
	FILTER_ARGS( point);
@


1.2
log
@updated comments and bn-ified function calls
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/libbn/RCS/noise.c,v 1.1 1996/09/14 03:34:08 butler Exp butler $ (ARL)";
d65 2
d69 8
a99 1

@


1.1
log
@Initial revision
@
text
@d9 1
d13 4
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/snoise.c,v 1.12 1996/08/27 01:56:28 mike Exp butler $ (ARL)";
d209 8
d230 1
a230 1
	if (!ht.hashTableValid) noise_init();
d298 1
a298 1
	if ( ! ht.hashTableValid ) noise_init();
d514 14
d589 11
@
