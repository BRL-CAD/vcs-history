head	1.40;
access;
symbols
	ansi-20040405-merged:1.36.2.2
	postmerge-20040405-ansi:1.38
	premerge-20040404-ansi:1.37
	postmerge-autoconf:1.37
	autoconf-freeze:1.36.10.1
	premerge-autoconf:1.37
	ansi-20040316-freeze:1.36.2.1
	postmerge-20040315-windows:1.37
	premerge-20040315-windows:1.36
	windows-20040315-freeze:1.36.4.1
	autoconf-20031203:1.36
	autoconf-20031202:1.36
	autoconf-branch:1.36.0.10
	phong-branch:1.36.0.8
	photonmap-branch:1.36.0.6
	rel-6-1-DP:1.36
	windows-branch:1.36.0.4
	rel-6-0-2:1.34
	ansi-branch:1.36.0.2
	rel-6-0-1-branch:1.34.0.2
	hartley-6-0-post:1.35
	hartley-6-0-pre:1.34
	rel-6-0-1:1.34
	rel-6-0:1.34
	rel-5-4:1.31
	offsite-5-3-pre:1.33
	rel-5-3:1.31
	rel-5-2:1.31
	rel-5-1-branch:1.31.0.2
	rel-5-1:1.31
	rel-5-0:1.26
	rel-5-0-beta:1.25
	rel-4-5:1.7
	ctj-4-5-post:1.6
	ctj-4-5-pre:1.6;
locks; strict;
comment	@ * @;


1.40
date	2004.05.21.18.06.23;	author morrison;	state dead;
branches;
next	1.39;

1.39
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.05.07.46.41;	author morrison;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.16.19.16.26;	author morrison;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.20.17.07.37;	author jra;	state Exp;
branches
	1.36.2.1
	1.36.4.1
	1.36.10.1;
next	1.35;

1.35
date	2002.08.15.20.54.49;	author hartley;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.05.19.35.28;	author morrison;	state Exp;
branches;
next	1.33;

1.33
date	2000.07.25.16.43.47;	author butler;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.11.23.30.40;	author cjohnson;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.29.17.46.56;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.03.23.19.14;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.20.21.59.30;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.20.21.16.43;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	99.12.29.20.29.23;	author jra;	state Exp;
branches;
next	1.26;

1.26
date	99.07.02.19.09.42;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	98.12.16.03.50.34;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	98.12.11.20.43.25;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	98.12.11.20.41.09;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	98.12.11.20.22.52;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	98.12.11.06.01.27;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	98.12.11.04.26.08;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	98.12.10.08.48.57;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	98.12.10.08.28.10;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	98.11.26.03.39.25;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.11.26.03.21.11;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	98.11.26.02.20.36;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	98.11.20.23.07.38;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	98.11.17.22.03.18;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	98.10.09.05.51.23;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	98.10.07.20.59.37;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	98.10.07.07.35.09;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	98.10.07.07.17.27;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	98.09.30.03.52.51;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.12.16.00.10.56;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	96.08.27.01.33.15;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.07.12.12.10.21;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	96.04.06.03.51.46;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.04.06.03.47.47;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.04.06.02.52.48;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.04.06.00.59.25;	author mike;	state Exp;
branches;
next	;

1.36.2.1
date	2002.09.19.18.01.10;	author morrison;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2004.03.17.21.16.48;	author morrison;	state Exp;
branches;
next	;

1.36.4.1
date	2002.09.26.23.03.50;	author morrison;	state Exp;
branches;
next	;

1.36.10.1
date	2004.03.18.18.08.28;	author erikg;	state Exp;
branches;
next	;


desc
@tabdata.c
Routines for tabular data.
@


1.40
log
@moved to src/
@
text
@
/*
 *			T A B D A T A . C
 *
 *  Routines for processing tables (curves) of data with one independent
 *  parameter which is common to many sets of dependent data values.
 *
 *  Operates on bn_table (independent var) and
 *  bn_tabdata (dependent variable) structures.
 *
 *  One application is for storing spectral curves, see spectrum.c
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 *
 *  Inspired by -
 *	Roy Hall and his book "Illumination and Color in Computer
 *	Generated Imagery", Springer Verlag, New York, 1989.
 *	ISBN 0-387-96774-5
 *
 *  With thanks to Russ Moulton Jr, EOSoft Inc. for his "rad.c" module.
 */
#ifndef lint
static const char RCStabdata[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libbn/tabdata.c,v 1.39 2004/05/10 15:30:43 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#if HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <math.h>
#include <fcntl.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "externs.h"
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"

/*
 *			B N _ T A B L E _ F R E E
 */
void
bn_table_free(struct bn_table *tabp)
{
	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_free(x%x)\n", tabp);
	BN_CK_TABLE(tabp);

	tabp->nx = 0;			/* sanity */
	bu_free( tabp, "struct bn_table");
}

/*
 *			B N _ T A B D A T A _ F R E E
 */
void
bn_tabdata_free(struct bn_tabdata *data)
{
	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_free(x%x)\n", data);

	BN_CK_TABDATA(data);
	BN_CK_TABLE(data->table);

	data->ny = 0;			/* sanity */
	data->table = NULL;		/* sanity */
	bu_free( data, "struct bn_tabdata" );
}

/*
 *			B N _ C K _ T A B L E
 */
void
bn_ck_table(const struct bn_table *tabp)
{
	register int	i;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_ck_table(x%x)\n", tabp);

	BN_CK_TABLE(tabp);

	if( tabp->nx < 2 ) bu_bomb("bn_ck_table() less than 2 wavelengths\n");

	for( i=0; i < tabp->nx; i++ )  {
		if( tabp->x[i] >= tabp->x[i+1] )
			bu_bomb("bn_ck_table() wavelengths not in strictly ascending order\n");
	}
}

/*
 *			B N _ T A B L E _ M A K E _ U N I F O R M
 *
 *  Set up an independent "table margin" from 'first' to 'last',
 *  inclusive, using 'num' uniformly spaced samples.  Num >= 1.
 */
struct bn_table *
bn_table_make_uniform(int num, double first, double last)
{
	struct bn_table	*tabp;
	fastf_t			*fp;
	fastf_t			delta;
	int			j;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_make_uniform( num=%d, %g, %g )\n", num, first, last );

	if( first >= last )  bu_bomb("bn_table_make_uniform() first >= last\n");

	BN_GET_TABLE( tabp, num );

	delta = (last - first) / (double)num;

	fp = &tabp->x[0];
	for( j = num; j > 0; j-- )  {
		*fp++ = first;
		first += delta;
	}
	tabp->x[num] = last;

	return( tabp );
}

/*
 *			B N _ T A B D A T A _ A D D
 *
 *  Sum the values from two data tables.
 */
void
bn_tabdata_add(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_add(x%x, x%x, x%x)\n", out, in1, in2);

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );

	if( in1->table != in2->table || in1->table != out->table )
		bu_bomb("bn_tabdata_add(): samples drawn from different tables\n");
	if( in1->ny != in2->ny || in1->ny != out->ny )
		bu_bomb("bn_tabdata_add(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ = *i1++ + *i2++;
	/* VADD2N( out->y, i1->y, i2->y, in1->ny ); */
}

/*
 *			B N _ T A B D A T A _ M U L
 *
 *  Element-by-element multiply the values from two data tables.
 */
void
bn_tabdata_mul(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_mul(x%x, x%x, x%x)\n", out, in1, in2);

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );

	if( in1->table != in2->table || in1->table != out->table )
		bu_bomb("bn_tabdata_mul(): samples drawn from different tables\n");
	if( in1->ny != in2->ny || in1->ny != out->ny )
		bu_bomb("bn_tabdata_mul(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ = *i1++ * *i2++;
	/* VELMUL2N( out->y, i1->y, i2->y, in1->ny ); */
}

/*
 *			B N _ T A B D A T A _ M U L 3
 *
 *  Element-by-element multiply the values from three data tables.
 */
void
bn_tabdata_mul3(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, const struct bn_tabdata *in3)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2, *i3;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_mul3(x%x, x%x, x%x, x%x)\n", out, in1, in2, in3);

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );
	BN_CK_TABDATA( in3 );

	if( in1->table != in2->table || in1->table != out->table || in1->table != in2->table )
		bu_bomb("bn_tabdata_mul(): samples drawn from different tables\n");
	if( in1->ny != in2->ny || in1->ny != out->ny )
		bu_bomb("bn_tabdata_mul(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	i3 = in3->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ = *i1++ * *i2++ * *i3++;
	/* VELMUL3N( out->y, i1->y, i2->y, i3->y, in1->ny ); */
}

/*
 *			B N _ T A B D A T A _ I N C R _ M U L 3 _ S C A L E
 *
 *  Element-by-element multiply the values from three data tables and a scalor.
 *
 *	out += in1 * in2 * in3 * scale
 */
void
bn_tabdata_incr_mul3_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, const struct bn_tabdata *in3, register double scale)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2, *i3;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_incr_mul3_scale(x%x, x%x, x%x, x%x, %g)\n", out, in1, in2, in3, scale);

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );
	BN_CK_TABDATA( in3 );

	if( in1->table != in2->table || in1->table != out->table || in1->table != in3->table )
		bu_bomb("bn_tabdata_mul(): samples drawn from different tables\n");
	if( in1->ny != in2->ny || in1->ny != out->ny )
		bu_bomb("bn_tabdata_mul(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	i3 = in3->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ += *i1++ * *i2++ * *i3++ * scale;
}

/*
 *			B N _ T A B D A T A _ I N C R _ M U L 2 _ S C A L E
 *
 *  Element-by-element multiply the values from two data tables and a scalor.
 *
 *	out += in1 * in2 * scale
 */
void
bn_tabdata_incr_mul2_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, register double scale)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_incr_mul2_scale(x%x, x%x, x%x, %g)\n", out, in1, in2, scale);

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );

	if( in1->table != in2->table || in1->table != out->table )
		bu_bomb("bn_tabdata_mul(): samples drawn from different tables\n");
	if( in1->ny != in2->ny || in1->ny != out->ny )
		bu_bomb("bn_tabdata_mul(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ += *i1++ * *i2++ * scale;
}

/*
 *			B N _ T A B D A T A _ S C A L E
 *
 *  Multiply every element in a data table by a scalar value 'scale'.
 */
void
bn_tabdata_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_scale(x%x, x%x, %g)\n", out, in1, scale);

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );

	if( in1->table != out->table )
		bu_bomb("bn_tabdata_scale(): samples drawn from different tables\n");
	if( in1->ny != out->ny )
		bu_bomb("bn_tabdata_scale(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ = *i1++ * scale;
	/* VSCALEN( out->y, in->y, scale ); */
}

/*
 *			B N _ T A B L E _ S C A L E
 *
 *  Scale the indepentent axis of a table by 'scale'.
 */
void
bn_table_scale(struct bn_table *tabp, register double scale)
{
	register int		j;
	register fastf_t	*op;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_scale(x%x, %g)\n", tabp, scale );

	BN_CK_TABLE( tabp );

	op = tabp->x;
	for( j = tabp->nx+1; j > 0; j-- )
		*op++ *= scale;
	/* VSCALEN( tabp->x, tabp->x, scale, tabp->nx+1 ); */
}

/*
 *			B N _ T A B D A T A _ J O I N 1
 *
 *  Multiply every element in data table in2 by a scalar value 'scale',
 *  add it to the element in in1, and store in 'out'.
 *  'out' may overlap in1 or in2.
 */
void
bn_tabdata_join1(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale, const struct bn_tabdata *in2)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_join1(x%x, x%x, %g, x%x)\n", out, in1, scale, in2 );

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );

	if( in1->table != out->table )
		bu_bomb("bn_tabdata_join1(): samples drawn from different tables\n");
	if( in1->table != in2->table )
		bu_bomb("bn_tabdata_join1(): samples drawn from different tables\n");
	if( in1->ny != out->ny )
		bu_bomb("bn_tabdata_join1(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ = *i1++ + scale * *i2++;
	/* VJOIN1N( out->y, in1->y, scale, in2->y ); */
}

/*
 *			B N _ T A B D A T A _ J O I N 2
 *
 *  Multiply every element in data table in2 by a scalar value 'scale2',
 *  plus in3 * scale3, and
 *  add it to the element in in1, and store in 'out'.
 *  'out' may overlap in1 or in2.
 */
void
bn_tabdata_join2(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2, register double scale3, const struct bn_tabdata *in3)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2, *i3;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_join2(x%x, x%x, %g, x%x, %g, x%x)\n", out, in1, scale2, in2, scale3, in3 );

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );

	if( in1->table != out->table )
		bu_bomb("bn_tabdata_join1(): samples drawn from different tables\n");
	if( in1->table != in2->table )
		bu_bomb("bn_tabdata_join1(): samples drawn from different tables\n");
	if( in1->table != in3->table )
		bu_bomb("bn_tabdata_join1(): samples drawn from different tables\n");
	if( in1->ny != out->ny )
		bu_bomb("bn_tabdata_join1(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	i3 = in3->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ = *i1++ + scale2 * *i2++ + scale3 * *i3++;
	/* VJOIN2N( out->y, in1->y, scale2, in2->y, scale3, in3->y ); */
}

/*
 *			B N _ T A B D A T A _ B L E N D 2
 */
void
bn_tabdata_blend2(struct bn_tabdata *out, register double scale1, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_blend2(x%x, %g, x%x, %g, x%x)\n", out, scale1, in1, scale2, in2 );

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );

	if( in1->table != out->table )
		bu_bomb("bn_tabdata_blend2(): samples drawn from different tables\n");
	if( in1->table != in2->table )
		bu_bomb("bn_tabdata_blend2(): samples drawn from different tables\n");
	if( in1->ny != out->ny )
		bu_bomb("bn_tabdata_blend2(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ = scale1 * *i1++ + scale2 * *i2++;
	/* VBLEND2N( out->y, scale1, in1->y, scale2, in2->y ); */
}

/*
 *			B N _ T A B D A T A _ B L E N D 3
 */
void
bn_tabdata_blend3(struct bn_tabdata *out, register double scale1, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2, register double scale3, const struct bn_tabdata *in3)
{
	register int		j;
	register fastf_t	*op;
	register const fastf_t	*i1, *i2, *i3;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_blend3(x%x, %g, x%x, %g, x%x, %g, x%x)\n", out, scale1, in1, scale2, in2, scale3, in3 );

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in1 );
	BN_CK_TABDATA( in2 );
	BN_CK_TABDATA( in3 );

	if( in1->table != out->table )
		bu_bomb("bn_tabdata_blend3(): samples drawn from different tables\n");
	if( in1->table != in2->table )
		bu_bomb("bn_tabdata_blend3(): samples drawn from different tables\n");
	if( in1->table != in3->table )
		bu_bomb("bn_tabdata_blend3(): samples drawn from different tables\n");
	if( in1->ny != out->ny )
		bu_bomb("bn_tabdata_blend3(): different tabdata lengths?\n");

	op = out->y;
	i1 = in1->y;
	i2 = in2->y;
	i3 = in3->y;
	for( j = in1->ny; j > 0; j-- )
		*op++ = scale1 * *i1++ + scale2 * *i2++ + scale3 * *i3++;
	/* VBLEND3N( out->y, scale1, in1->y, scale2, in2->y, scale3, in3->y ); */
}

/*
 *			B N _ T A B D A T A _ A R E A 1
 *
 *  Following interpretation #1, where y[j] stores the total (integral
 *  or area) value within the interval, return the area under the whole curve.
 *  This is simply totaling up the areas from each of the intervals.
 */
double
bn_tabdata_area1(const struct bn_tabdata *in)
{
	FAST fastf_t		area;
	register const fastf_t	*ip;
	register int		j;

	BN_CK_TABDATA(in);

	area = 0;
	ip = in->y;
	for( j = in->ny; j > 0; j-- )
		area += *ip++;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_area(x%x) = %g\n", in, area);

	return area;
}

/*
 *			B N _ T A B D A T A _ A R E A 2
 *
 *  Following interpretation #2, where y[j] stores the average
 *  value for the interval, return the area under
 *  the whole curve.  Since the iterval spacing need not be uniform,
 *  sum the areas of the rectangles.
 */
double
bn_tabdata_area2(const struct bn_tabdata *in)
{
	const struct bn_table	*tabp;
	FAST fastf_t		area;
	fastf_t			width;
	register int		j;

	BN_CK_TABDATA(in);
	tabp = in->table;
	BN_CK_TABLE(tabp);

	area = 0;
	for( j = in->ny-1; j >= 0; j-- )  {
		width = tabp->x[j+1] - tabp->x[j];
		area += in->y[j] * width;
	}

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_area2(x%x) = %g\n", in, area);
	return area;
}

/*
 *			B N _ T A B D A T A _ M U L _ A R E A 1
 *
 *  Following interpretation #1, where y[j] stores the total (integral
 *  or area) value within the interval, return the area under the whole curve.
 *  This is simply totaling up the areas from each of the intervals.
 *  The curve value is found by multiplying corresponding entries from
 *  in1 and in2.
 */
double
bn_tabdata_mul_area1(const struct bn_tabdata *in1, const struct bn_tabdata *in2)
{
	FAST fastf_t		area;
	register const fastf_t	*i1, *i2;
	register int		j;

	BN_CK_TABDATA(in1);
	BN_CK_TABDATA(in2);

	area = 0;
	i1 = in1->y;
	i2 = in2->y;
	for( j = in1->ny; j > 0; j-- )
		area += *i1++ * *i2++;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_mul_area1(x%x, x%x) = %g\n", in1, in2, area);
	return area;
}

/*
 *			B N _ T A B D A T A _ M U L _ A R E A 2
 *
 *  Following interpretation #2,
 *  return the area under the whole curve.
 *  The curve value is found by multiplying corresponding entries from
 *  in1 and in2.
 */
double
bn_tabdata_mul_area2(const struct bn_tabdata *in1, const struct bn_tabdata *in2)
{
	const struct bn_table	*tabp;
	FAST fastf_t		area;
	fastf_t			width;
	register int		j;

	BN_CK_TABDATA(in1);
	BN_CK_TABDATA(in2);
	tabp = in1->table;
	BN_CK_TABLE(tabp);

	area = 0;
	for( j = in1->ny-1; j >= 0; j-- )  {
		width = tabp->x[j+1] - tabp->x[j];
		area += in1->y[j] * in2->y[j] * width;
	}

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_mul_area2(x%x, x%x) = %g\n", in1, in2, area);
	return area;
}

/*
 *			B N _ T A B L E _ F I N D _ X
 *
 *  Return the index in the table's x[] array of the interval which
 *  contains 'xval'.
 *
 *  Returns -
 *	-1	if less than start value
 *	-2	if greater than end value.
 *	0..nx-1	otherwise.
 *		Never returns a value of nx.
 *
 *  A binary search would be more efficient, as the wavelengths (x values)
 *  are known to be sorted in ascending order.
 */
int
bn_table_find_x(const struct bn_table *tabp, double xval)
{
	register int	i;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_find_x(x%x, %g)\n", tabp, xval );
	BN_CK_TABLE(tabp);

	if( xval > tabp->x[tabp->nx] )  return -2;
	if( xval >= tabp->x[tabp->nx-1] )  return tabp->nx-1;

	/* Search for proper interval in input spectrum */
	for( i = tabp->nx-2; i >=0; i-- )  {
		if( xval >= tabp->x[i] )  return i;
	}
	/* if( xval < tabp->x[0] )  return -1; */
	return -1;
}

/*
 *			B N _ T A B L E _ L I N _ I N T E R P
 *
 *  Return the value of the curve at independent parameter value 'wl'.
 *  Linearly interpolate between values in the input table.
 *  Zero is returned for values outside the sampled range.
 */
fastf_t
bn_table_lin_interp(const struct bn_tabdata *samp, register double wl)
{
	const struct bn_table	*tabp;
	register int		i;
	register fastf_t	fract;
	register fastf_t	ret;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_lin_interp(x%x, %g)\n", samp, wl);

	BN_CK_TABDATA(samp);
	tabp = samp->table;
	BN_CK_TABLE(tabp);

	if( (i = bn_table_find_x( tabp, wl )) < 0 )  {
		if(bu_debug&BU_DEBUG_TABDATA)bu_log("bn_table_lin_interp(%g) out of range %g to %g\n", wl, tabp->x[0], tabp->x[tabp->nx] );
		return 0;
	}

	if( wl < tabp->x[i] || wl >= tabp->x[i+1] )  {
		bu_log("bn_table_lin_interp(%g) assertion1 failed at %g\n", wl, tabp->x[i] );
		bu_bomb("bn_table_lin_interp() assertion1 failed\n");
	}

	if( i >= tabp->nx-2 )  {
		/* Assume value is constant in final interval. */
		if(bu_debug&BU_DEBUG_TABDATA)bu_log("bn_table_lin_interp(%g)=%g off end of range %g to %g\n", wl, samp->y[tabp->nx-1], tabp->x[0], tabp->x[tabp->nx] );
		return samp->y[tabp->nx-1];
	}

	/* The interval has been found */
	fract = (wl - tabp->x[i]) / (tabp->x[i+1] - tabp->x[i]);
	if( fract < 0 || fract > 1 )  bu_bomb("bn_table_lin_interp() assertion2 failed\n");
	ret = (1-fract) * samp->y[i] + fract * samp->y[i+1];
	if(bu_debug&BU_DEBUG_TABDATA)bu_log("bn_table_lin_interp(%g)=%g in range %g to %g\n",
		wl, ret, tabp->x[i], tabp->x[i+1] );
	return ret;
}

/*
 *			B N _ T A B D A T A _ R E S A M P L E _ M A X
 *
 *  Given a set of sampled data 'olddata', resample it for different
 *  spacing, by linearly interpolating the values when an output span
 *  is entirely contained within an input span, and by taking the
 *  maximum when an output span covers more than one input span.
 *
 *  This assumes interpretation (2) of the data, i.e. that the values
 *  are the average value across the interval.
 */
struct bn_tabdata *
bn_tabdata_resample_max(const struct bn_table *newtable, const struct bn_tabdata *olddata)
{
	const struct bn_table	*oldtable;
	struct bn_tabdata	*newsamp;
	int			i;
	int			j, k;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_resample_max(x%x, x%x)\n", newtable, olddata);

	BN_CK_TABLE(newtable);
	BN_CK_TABDATA(olddata);
	oldtable = olddata->table;
	BN_CK_TABLE(oldtable);

	if( oldtable == newtable )  bu_log("bn_tabdata_resample_max() NOTICE old and new bn_table structs are the same\n");

	BN_GET_TABDATA( newsamp, newtable );

	for( i = 0; i < newtable->nx; i++ )  {
		/*
		 *  Find good value(s) in olddata to represent the span from
		 *  newtable->x[i] to newtable->x[i+1].
		 */
		j = bn_table_find_x( oldtable, newtable->x[i] );
		k = bn_table_find_x( oldtable, newtable->x[i+1] );
		if( k == -1 )  {
			/* whole new span is off left side of old table */
			newsamp->y[i] = 0;
			continue;
		}
		if( j == -2 )  {
			/* whole new span is off right side of old table */
			newsamp->y[i] = 0;
			continue;
		}

		if( j == k && j > 0 )  {
			register fastf_t tmp;
			/*
			 *  Simple case, ends of output span are completely
			 *  contained within one input span.
			 *  Interpolate for both ends, take max.
			 *  XXX this could be more efficiently written inline here.
			 */
			newsamp->y[i] = bn_table_lin_interp( olddata, newtable->x[i] );
			tmp = bn_table_lin_interp( olddata, newtable->x[i+1] );
			if( tmp > newsamp->y[i] )  newsamp->y[i] = tmp;
		} else {
			register fastf_t tmp, n;
			register int	s;
			/*
			 *  Complex case: find good representative value.
			 *  Interpolate both ends, and consider all
			 *  intermediate old samples in span.  Take max.
			 *  One (but not both) new ends may be off old table.
			 */
			n = bn_table_lin_interp( olddata, newtable->x[i] );
			tmp = bn_table_lin_interp( olddata, newtable->x[i+1] );
			if( tmp > n )  n = tmp;
			for( s = j+1; s <= k; s++ )  {
				if( (tmp = olddata->y[s]) > n )
					n = tmp;
			}
			newsamp->y[i] = n;
		}
	}
	return newsamp;
}

/*
 *			B N _ T A B D A T A _ R E S A M P L E _ A V G
 *
 *  Given a set of sampled data 'olddata', resample it for different
 *  spacing, by linearly interpolating the values when an output span
 *  is entirely contained within an input span, and by taking the
 *  average when an output span covers more than one input span.
 *
 *  This assumes interpretation (2) of the data, i.e. that the values
 *  are the average value across the interval.
 */
struct bn_tabdata *
bn_tabdata_resample_avg(const struct bn_table *newtable, const struct bn_tabdata *olddata)
{
	const struct bn_table	*oldtable;
	struct bn_tabdata	*newsamp;
	int			i;
	int			j, k;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_resample_avg(x%x, x%x)\n", newtable, olddata);

	BN_CK_TABLE(newtable);
	BN_CK_TABDATA(olddata);
	oldtable = olddata->table;
	BN_CK_TABLE(oldtable);

	if( oldtable == newtable )  bu_log("bn_tabdata_resample_avg() NOTICE old and new bn_table structs are the same\n");

	BN_GET_TABDATA( newsamp, newtable );

	for( i = 0; i < newtable->nx; i++ )  {
		/*
		 *  Find good value(s) in olddata to represent the span from
		 *  newtable->x[i] to newtable->x[i+1].
		 */
		j = bn_table_find_x( oldtable, newtable->x[i] );
		k = bn_table_find_x( oldtable, newtable->x[i+1] );

		if( j < 0 || k < 0 || j == k )  {
			/*
			 *  Simple case, ends of output span are completely
			 *  contained within one input span.
			 *  Interpolate for both ends, take average.
			 *  XXX this could be more efficiently written inline here.
			 */
			newsamp->y[i] = 0.5 * (
			    bn_table_lin_interp( olddata, newtable->x[i] ) +
			    bn_table_lin_interp( olddata, newtable->x[i+1] ) );
		} else {
			/*
			 *  Complex case: find average value.
			 *  Interpolate both end, and consider all
			 *  intermediate old spans.
			 *  There are three parts to sum:
			 *	Partial interval from newx[i] to j+1
			 *	Full intervals from j+1 to k
			 *	Partial interval from k to newx[i+1]
			 */
			fastf_t wsum;		/* weighted sum */
			fastf_t	a,b;		/* values being averaged */
			int	s;

			/* Partial interval from newx[i] to j+1 */
			a = bn_table_lin_interp( olddata, newtable->x[i] );	/* in "j" bin */
			b = olddata->y[j+1];
			wsum = 0.5 * (a+b) * (oldtable->x[j+1] - newtable->x[i] );

			/* Full intervals from j+1 to k */
			for( s = j+1; s < k; s++ )  {
				a = olddata->y[s];
				b = olddata->y[s+1];
				wsum += 0.5 * (a+b) * (oldtable->x[s+1] - oldtable->x[s] );
			}

			/* Partial interval from k to newx[i+1] */
			a = olddata->y[k];
			b = bn_table_lin_interp( olddata, newtable->x[i+1] );	/* in "k" bin */
			wsum += 0.5 * (a+b) * (newtable->x[i+1] - oldtable->x[k] );

			/* Adjust the weighted sum by the total width */
			newsamp->y[i] =
				wsum / (newtable->x[i+1] - newtable->x[i]);
		}
	}
	return newsamp;
}

/*
 *			B N _ T A B L E _ W R I T E 
 *
 *  Write out the table structure in an ASCII file,
 *  giving the number of values (minus 1), and the
 *  actual values.
 */
int
bn_table_write(const char *filename, const struct bn_table *tabp)
{
	FILE	*fp;
	int	j;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_write(%s, x%x)\n", filename, tabp);

	BN_CK_TABLE(tabp);

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	fp = fopen( filename, "w" );
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( fp == NULL )  {
		perror(filename);
		bu_log("bn_table_write(%s, x%x) FAILED\n", filename, tabp);
		return -1;
	}

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	fprintf(fp, "  %d sample starts, and one end.\n", tabp->nx );
	for( j=0; j <= tabp->nx; j++ )  {
		fprintf( fp, "%g\n", tabp->x[j] );
	}
	fclose(fp);
	bu_semaphore_release( BU_SEM_SYSCALL );
	return 0;
}

/*
 *			B N _ T A B L E _ R E A D
 *
 *  Allocate and read in the independent variable values from an ASCII file,
 *  giving the number of samples (minus 1), and the
 *  actual values.
 */
struct bn_table *
bn_table_read(const char *filename)
{
	struct bn_table	*tabp;
	struct bu_vls		line;
	FILE	*fp;
	int	nw;
	int	j;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_read(%s)\n", filename);

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	fp = fopen( filename, "r" );
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( fp == NULL )  {
		perror(filename);
		bu_log("bn_table_read(%s) FAILED\n", filename);
		return NULL;
	}

	bu_vls_init(&line);
	bu_vls_gets( &line, fp );
	nw = 0;
	sscanf( bu_vls_addr(&line), "%d", &nw );
	bu_vls_free(&line);

	if( nw <= 0 ) bu_bomb("bn_table_read() bad nw value\n");

	BN_GET_TABLE( tabp, nw );

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	for( j=0; j <= tabp->nx; j++ )  {
		/* XXX assumes fastf_t == double */
		fscanf( fp, "%lf", &tabp->x[j] );
	}
	fclose(fp);
	bu_semaphore_release( BU_SEM_SYSCALL );

	bn_ck_table( tabp );

	return tabp;
}

/*
 *			B N _ P R _ T A B L E
 */
void
bn_pr_table(const char *title, const struct bn_table *tabp)
{
	int	j;

	bu_log("%s\n", title);
	BN_CK_TABLE(tabp);

	for( j=0; j <= tabp->nx; j++ )  {
		bu_log("%3d: %g\n", j, tabp->x[j] );
	}
}

/*
 *			B N _ P R _ T A B D A T A
 */
void
bn_pr_tabdata(const char *title, const struct bn_tabdata *data)
{
	int	j;

	bu_log("%s: ", title);
	BN_CK_TABDATA(data);

	for( j=0; j < data->ny; j++ )  {
		bu_log("%g, ", data->y[j] );
	}
	bu_log("\n");
}

/*
 *			B N _ P R I N T _ T A B L E _ A N D _ T A B D A T A
 *
 *  Write out a given data table into an ASCII file,
 *  suitable for input to GNUPLOT.
 *	(set term postscript)
 *	(set output "|print-postscript")
 *	(plot "filename" with lines)
 */
int
bn_print_table_and_tabdata(const char *filename, const struct bn_tabdata *data)
{
	FILE	*fp;
	const struct bn_table	*tabp;
	int	j;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_print_table_and_tabdata(%s, x%x)\n", filename, data);

	BN_CK_TABDATA(data);
	tabp = data->table;
	BN_CK_TABLE(tabp);

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	fp = fopen( filename, "w" );
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( fp == NULL )  {
		perror(filename);
		bu_log("bn_print_table_and_tabdata(%s, x%x) FAILED\n", filename, data );
		return -1;
	}

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	for( j=0; j < tabp->nx; j++ )  {
		fprintf( fp, "%g %g\n", tabp->x[j], data->y[j] );
	}
	fprintf( fp, "%g (novalue)\n", tabp->x[tabp->nx] );
	fclose(fp);
	bu_semaphore_release( BU_SEM_SYSCALL );
	return 0;
}

/*
 *			B N _ R E A D _ T A B L E _ A N D _ T A B D A T A
 *
 *  Read in a file which contains two columns of numbers, the first
 *  column being the waveength, the second column being the sample value
 *  at that wavelength.
 *  A new bn_table structure and one bn_tabdata structure
 *  are created, a pointer to the bn_tabdata structure is returned.
 *  The final wavelength is guessed at.
 */
struct bn_tabdata *
bn_read_table_and_tabdata(const char *filename)
{
	struct bn_table	*tabp;
	struct bn_tabdata	*data;
	FILE	*fp;
	char	buf[128];
	int	count = 0;
	int	i;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_read_table_and_tabdata(%s)\n", filename);

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	fp = fopen( filename, "r" );
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( fp == NULL )  {
		perror(filename);
		bu_log("bn_read_table_and_tabdata(%s) FAILED\n", filename);
		return NULL;
	}

	/* First pass:  Count number of lines */
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	for(;;)  {
		if( fgets( buf, sizeof(buf), fp ) == NULL )  break;
		count++;
	}
	fclose(fp);
	bu_semaphore_release( BU_SEM_SYSCALL );

	/* Allocate storage */
	BN_GET_TABLE( tabp, count );
	BN_GET_TABDATA( data, tabp );

	/* Second pass:  Read only as much data as storage was allocated for */
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	fp = fopen( filename, "r" );
	for( i=0; i < count; i++ )  {
		buf[0] = '\0';
		if( fgets( buf, sizeof(buf), fp ) == NULL )  {
			bu_log("bn_read_table_and_tabdata(%s) unexpected EOF on line %d\n", filename, i);
			break;
		}
		sscanf( buf, "%lf %lf", &tabp->x[i], &data->y[i] );
	}
	fclose(fp);
	bu_semaphore_release( BU_SEM_SYSCALL );

	/* Complete final interval */
	tabp->x[count] = 2 * tabp->x[count-1] - tabp->x[count-2];

	bn_ck_table( tabp );

	return data;
}

/*
 *			B N _ T A B D A T A _ B I N A R Y _ R E A D
 */
struct bn_tabdata *
bn_tabdata_binary_read(const char *filename, int num, const struct bn_table *tabp)
{
	struct bn_tabdata	*data;
	char	*cp;
	int	nbytes;
	int	len;
	int	got;
	int	fd;
	int	i;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_binary_read(%s, num=%d, x%x)\n", filename, num, tabp);

	BN_CK_TABLE(tabp);

	nbytes = BN_SIZEOF_TABDATA(tabp);
	len = num * nbytes;

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	fd = open(filename, 0);
	bu_semaphore_release( BU_SEM_SYSCALL );
	if( fd <= 0 )  {
		perror(filename);
		bu_log("bn_tabdata_binary_read(%s): %m\n", filename);
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		close(fd);
		bu_semaphore_release( BU_SEM_SYSCALL );
		return (struct bn_tabdata *)NULL;
	}

	/* Get a big array of structures for reading all at once */
	data = (struct bn_tabdata *)bu_malloc( len+8, "bn_tabdata[]" );

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	got = read( fd, (char *)data, len );
	bu_semaphore_release( BU_SEM_SYSCALL );
	if( got != len )  {
		bu_log("bn_tabdata_binary_read(%s) expected %d got %d\n",
			filename, len, got);
		bu_free( data, "bn_tabdata[]" );
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		close(fd);
		bu_semaphore_release( BU_SEM_SYSCALL );
		return (struct bn_tabdata *)NULL;
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	close(fd);
	bu_semaphore_release( BU_SEM_SYSCALL );

	/* Connect data[i].table pointer to tabp */
	cp = (char *)data;
	for( i = num-1; i >= 0; i--, cp += nbytes )  {
		register struct bn_tabdata	*sp;

		sp = (struct bn_tabdata *)cp;
		BN_CK_TABDATA(sp);
		sp->table = tabp;
	}

	return data;
}

/*
 *			B N _ T A B D A T A _ M A L L O C _ A R R A Y
 *
 *  Allocate storage for, and initialize, an array of 'num' data table
 *  structures.
 *  This subroutine is provided because the bn_tabdata structures
 *  are variable length.
 */
struct bn_tabdata *
bn_tabdata_malloc_array(const struct bn_table *tabp, int num)
{
	struct bn_tabdata	*data;
	char	*cp;
	int	i;
	int	nw;
	int	nbytes;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_malloc_array(x%x, num=%d)\n", tabp, num);

	BN_CK_TABLE(tabp);
	nw = tabp->nx;
	nbytes = BN_SIZEOF_TABDATA(tabp);

	data = (struct bn_tabdata *)bu_calloc( num,
		nbytes, "struct bn_tabdata[]" );

	cp = (char *)data;
	for( i = 0; i < num; i++ ) {
		register struct bn_tabdata	*sp;

		sp = (struct bn_tabdata *)cp;
		sp->magic = BN_TABDATA_MAGIC;
		sp->ny = nw;
		sp->table = tabp;
		cp += nbytes;
	}
	return data;
}

/*
 *			B N _ T A B D A T A _ C O P Y
 */
void
bn_tabdata_copy(struct bn_tabdata *out, const struct bn_tabdata *in)
{
	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_copy(x%x, x%x)\n", out, in);

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in );

	if( in->table != out->table )
		bu_bomb("bn_tabdata_copy(): samples drawn from different tables\n");
	if( in->ny != out->ny )
		bu_bomb("bn_tabdata_copy(): different tabdata lengths?\n");

	bcopy( (const char *)in->y, (char *)out->y, BN_SIZEOF_TABDATA_Y(in) );
}

/*
 *			B N _ T A B D A T A _ D U P
 */
struct bn_tabdata *
bn_tabdata_dup(const struct bn_tabdata *in)
{
	struct bn_tabdata *data;

	BN_CK_TABDATA( in );
	BN_GET_TABDATA( data, in->table );

	bcopy( (const char *)in->y, (char *)data->y, BN_SIZEOF_TABDATA_Y(in) );

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_dup(x%x) = x%x\n", in, data);
	return data;
}

/*
 *			B N _ T A B D A T A _ G E T _ C O N S T V A L
 *
 *  For a given table, allocate and return a tabdata structure
 *  with all elements initialized to 'val'.
 */
struct bn_tabdata *
bn_tabdata_get_constval(double val, const struct bn_table *tabp)
{
	struct bn_tabdata	*data;
	int			todo;
	register fastf_t	*op;

	BN_CK_TABLE(tabp);
	BN_GET_TABDATA( data, tabp );

	op = data->y;
	for( todo = data->ny-1; todo >= 0; todo-- )
		*op++ = val;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_get_constval(val=%g, x%x)=x%x\n", val, tabp, data);

	return data;
}

/*
 *			B N _ T A B D A T A _ C O N S T V A L
 *
 *  Set all the tabdata elements to 'val'
 */
void
bn_tabdata_constval(struct bn_tabdata *data, double val)
{
	int			todo;
	register fastf_t	*op;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_constval(x%x, val=%g)\n", data, val);

	BN_CK_TABDATA(data);

	op = data->y;
	for( todo = data->ny-1; todo >= 0; todo-- )
		*op++ = val;
}

/*
 *			B N _ T A B D A T A _ T O _ T C L
 *
 *  Convert an bn_tabdata/bn_table pair into a Tcl compatible string
 *  appended to a VLS.  It will have form:
 *	x {...} y {...} nx # ymin # ymax #
 */
void
bn_tabdata_to_tcl(struct bu_vls *vp, const struct bn_tabdata *data)
{
	const struct bn_table	*tabp;
	register int i;
	FAST fastf_t	minval = MAX_FASTF, maxval = -MAX_FASTF;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_to_tcl(x%x, x%x)\n", vp, data);

	BU_CK_VLS(vp);
	BN_CK_TABDATA(data);
	tabp = data->table;
	BN_CK_TABLE(tabp);

	bu_vls_strcat(vp, "x {");
	for( i=0; i < tabp->nx; i++ )  {
		bu_vls_printf( vp, "%g ", tabp->x[i] );
	}
	bu_vls_strcat(vp, "} y {");
	for( i=0; i < data->ny; i++ )  {
		register fastf_t val = data->y[i];
		bu_vls_printf( vp, "%g ", val );
		if( val < minval )  minval = val;
		if( val > maxval )  maxval = val;
	}
	bu_vls_printf( vp, "} nx %d ymin %g ymax %g",
		tabp->nx, minval, maxval );
}

/*
 *			B N _ T A B D A T A _ F R O M _ A R R A Y
 *
 *  Given an array of (x,y) pairs, build the relevant bn_table and
 *  bn_tabdata structures.
 *  The table is terminated by an x value <= 0.
 *  Consistent with the interpretation of the spans,
 *  invent a final span ending x value.
 */
struct bn_tabdata *
bn_tabdata_from_array(const double *array)
{
	register const double	*dp;
	int			len = 0;
	struct bn_table		*tabp;
	struct bn_tabdata	*data;
	register int		i;

	/* First, find len */
	for( dp = array; *dp > 0; dp += 2 )	/* NIL */ ;
	len = (dp - array) >> 1;

	/* Second, build bn_table */
	BN_GET_TABLE( tabp, len );
	for( i = 0; i < len; i++ )  {
		tabp->x[i] = array[i<<1];
	}
	tabp->x[len] = tabp->x[len-1] + 1;	/* invent span end */

	/* Third, build bn_tabdata (last input "y" is ignored) */
	BN_GET_TABDATA( data, tabp );
	for( i = 0; i < len-1; i++ )  {
		data->y[i] = array[(i<<1)+1];
	}

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_from_array(x%x) = x%x\n", array, data);
	return data;
}

/*
 *			B N _ T A B D A T A _ F R E Q _ S H I F T
 *
 *  Shift the data by a constant offset in the independent variable
 *  (often frequency), interpolating new sample values.
 */
void
bn_tabdata_freq_shift(struct bn_tabdata *out, const struct bn_tabdata *in, double offset)
{
	const struct bn_table	*tabp;
	register int 		i;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_freq_shift(x%x, x%x, offset=%g)\n", out, in, offset);

	BN_CK_TABDATA( out );
	BN_CK_TABDATA( in );
	tabp = in->table;

	if( tabp != out->table )
		bu_bomb("bn_tabdata_freq_shift(): samples drawn from different tables\n");
	if( in->ny != out->ny )
		bu_bomb("bn_tabdata_freq_shift(): different tabdata lengths?\n");

	for( i=0; i < out->ny; i++ ) {
		out->y[i] = bn_table_lin_interp( in, tabp->x[i]+offset );
	}
}

/*
 *			B N _ T A B L E _ I N T E R V A L _ N U M _ S A M P L E S
 *
 *  Returns number of sample points between 'low' and 'hi', inclusive.
 */
int
bn_table_interval_num_samples(const struct bn_table *tabp, double low, double hi)
{
	register int	i;
	register int	count = 0;

	BN_CK_TABLE(tabp);

	for( i=0; i < tabp->nx-1; i++ )  {
		if( tabp->x[i] >= low && tabp->x[i] <= hi )  count++;
	}

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_interval_num_samples(x%x, low=%g, hi=%g) = %d\n", tabp, low, hi, count);
	return count;
}

/*
 *			B N _ T A B L E _ D E L E T E _ S A M P L E _ P T S
 *
 *  Remove all sampling points between subscripts i and j, inclusive.
 *  Don't bother freeing the tiny bit of storage at the end of the array.
 *  Returns number of points removed.
 */
int
bn_table_delete_sample_pts(struct bn_table *tabp, int i, int j)
{
	int	tokill;
	int	k;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_delete_samples(x%x, %d, %d)\n", tabp, i, j);

	BN_CK_TABLE(tabp);

	if( i < 0 || j < 0 )  bu_bomb("bn_table_delete_sample_pts() negative indices\n");
	if( i >= tabp->nx || j >= tabp->nx )  bu_bomb("bn_table_delete_sample_pts() index out of range\n");

	tokill = j - i + 1;
	if( tokill < 1 )  bu_bomb("bn_table_delete_sample_pts(): nothing to delete\n");
	if( tokill >= tabp->nx ) bu_bomb("bn_table_delete_sample_pts(): you can't kill 'em all!\n");

	tabp->nx -= tokill;

	for( k = i; k < tabp->nx; k++ )  {
		tabp->x[k] = tabp->x[k+tokill];
	}
	return tokill;
}

/*
 *			B N _ T A B L E _ M E R G E 2
 *
 *  A new table is returned which has sample points at places from
 *  each of the input tables.
 */
struct bn_table *
bn_table_merge2(const struct bn_table *a, const struct bn_table *b)
{
	struct bn_table *new;
	register int i, j, k;

	BN_CK_TABLE(a);
	BN_CK_TABLE(b);

	BN_GET_TABLE(new, a->nx + b->nx + 2 );

	i = j = 0;		/* input subscripts */
	k = 0;			/* output subscript */
	while( i <= a->nx || j <= b->nx )  {
		if( i > a->nx )  {
			while( j <= b->nx )
				new->x[k++] = b->x[j++];
			break;
		}
		if( j > b->nx )  {
			while( i <= a->nx )
				new->x[k++] = a->x[i++];
			break;
		}
		/* Both have remaining elements, take lower one */
		if( a->x[i] == b->x[j] )  {
			new->x[k++] = a->x[i++];
			j++;		/* compress out duplicate */
			continue;
		}
		if( a->x[i] <= b->x[j] )  {
			new->x[k++] = a->x[i++];
		} else {
			new->x[k++] = b->x[j++];
		}
	}
	if( k > new->nx )  bu_bomb("bn_table_merge2() assertion failed, k>nx?\n");
	new->nx = k-1;

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_table_merge2(x%x, x%x) = x%x\n", a, b, new);
	return new;
}

/*
 *		B N _ T A B D A T A _ M K _ L I N E A R _ F I L T E R
 *
 *  Create a filter to accept power in a given band.
 *  The first and last filter values will be in the range 0..1,
 *  while all the internal filter values will be 1.0,
 *  and all samples outside the given band will be 0.0.
 *
 *  Returns -
 *	NULL	if given band does not overlap input spectrum
 *	tabdata*
 */
struct bn_tabdata *
bn_tabdata_mk_linear_filter(const struct bn_table *spectrum, double lower_wavelen, double upper_wavelen)
{
	struct bn_tabdata *filt;
	int	first;
	int	last;
	fastf_t filt_range;
	fastf_t	cell_range;
	fastf_t	frac;
	int	i;

	BN_CK_TABLE(spectrum);

	if(bu_debug&BU_DEBUG_TABDATA) bu_log("bn_tabdata_mk_linear_filter(x%x, low=%g, up=%g)\n", spectrum, lower_wavelen, upper_wavelen);

	if( lower_wavelen < spectrum->x[0] )
	if( upper_wavelen > spectrum->x[spectrum->nx] )
		bu_log("bn_tabdata_mk_linear_filter() warning, upper_wavelen %g > hightest sampled wavelen %g\n",
			upper_wavelen, spectrum->x[spectrum->nx] );

	/* First, find first (possibly partial) sample */
	first = bn_table_find_x( spectrum, lower_wavelen );
	if( first == -1 )  {
		first = 0;
		bu_log("bn_tabdata_mk_linear_filter() warning, lower_wavelen %g < lowest sampled wavelen %g\n",
			lower_wavelen, spectrum->x[0] );
	} else if( first <= -2 )  {
		bu_log("bn_tabdata_mk_linear_filter() ERROR, lower_wavelen %g > highest sampled wavelen %g\n",
			lower_wavelen, spectrum->x[spectrum->nx] );
		return NULL;
	}

	/* Second, find last (possibly partial) sample */
	last = bn_table_find_x( spectrum, upper_wavelen );
	if( last == -1 )  {
		bu_log("bn_tabdata_mk_linear_filter() ERROR, upper_wavelen %g < lowest sampled wavelen %g\n",
			upper_wavelen, spectrum->x[0] );
		return NULL;
	} else if( last <= -2 )  {
		last = spectrum->nx-1;
		bu_log("bn_tabdata_mk_linear_filter() warning, upper_wavelen %g > highest sampled wavelen %g\n",
			upper_wavelen, spectrum->x[spectrum->nx] );
	}

	/* 'filt' is filled with zeros by default */
	BN_GET_TABDATA( filt, spectrum );

	/* Special case:  first and last are in same sample cell */
	if( first == last )  {
		filt_range = upper_wavelen - lower_wavelen;
		cell_range = spectrum->x[first+1] - spectrum->x[first];
		frac = filt_range / cell_range;

		/* Could use a BU_ASSERT_RANGE_FLOAT */
		BU_ASSERT( (frac >= 0.0) && (frac <= 1.0) );

		filt->y[first] = frac;
		return filt;
	}

	/* Calculate fraction 0..1.0 for first and last samples */
	filt_range = spectrum->x[first+1] - lower_wavelen;
	cell_range = spectrum->x[first+1] - spectrum->x[first];
	frac = filt_range / cell_range;
	if( frac > 1 )  frac = 1;
	BU_ASSERT( (frac >= 0.0) && (frac <= 1.0) );
	filt->y[first] = frac;

	filt_range = upper_wavelen - spectrum->x[last];
	cell_range = spectrum->x[last+1] - spectrum->x[last];
	frac = filt_range / cell_range;
	if( frac > 1 )  frac = 1;
	BU_ASSERT( (frac >= 0.0) && (frac <= 1.0) );
	filt->y[last] = frac;

	/* Fill in range between with 1.0 values */
	for( i = first+1; i < last; i++ )
		filt->y[i] = 1.0;

	return filt;
}
@


1.39
log
@change conf.h to a wrapped config.h
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header: /cvs/brlcad/libbn/tabdata.c,v 1.38 2004/04/05 07:46:41 morrison Exp $ (ARL)";
@


1.38
log
@merge of ansi-6-0-branch into HEAD
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header$ (ARL)";
d34 5
a38 1
#include "conf.h"
@


1.37
log
@merge of windows-6-0-branch into head
@
text
@d57 1
a57 2
bn_table_free( tabp )
struct bn_table	*tabp;
d70 1
a70 2
bn_tabdata_free( data )
struct bn_tabdata *data;
d86 1
a86 2
bn_ck_table( tabp )
const struct bn_table	*tabp;
d109 1
a109 4
bn_table_make_uniform( num, first, last )
int	num;
double	first;
double	last;
d140 1
a140 4
bn_tabdata_add( out, in1, in2 )
struct bn_tabdata		*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
d171 1
a171 4
bn_tabdata_mul( out, in1, in2 )
struct bn_tabdata		*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
d202 1
a202 5
bn_tabdata_mul3( out, in1, in2, in3 )
struct bn_tabdata		*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
const struct bn_tabdata	*in3;
d237 1
a237 6
bn_tabdata_incr_mul3_scale( out, in1, in2, in3, scale )
struct bn_tabdata	*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
const struct bn_tabdata	*in3;
register double		scale;
d271 1
a271 5
bn_tabdata_incr_mul2_scale( out, in1, in2, scale )
struct bn_tabdata	*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
register double		scale;
d301 1
a301 4
bn_tabdata_scale( out, in1, scale )
struct bn_tabdata		*out;
const struct bn_tabdata	*in1;
register double			scale;
d330 1
a330 3
bn_table_scale( tabp, scale )
struct bn_table	*tabp;
register double		scale;
d353 1
a353 5
bn_tabdata_join1( out, in1, scale, in2 )
struct bn_tabdata		*out;
const struct bn_tabdata		*in1;
register double			scale;
const struct bn_tabdata		*in2;
d389 1
a389 7
bn_tabdata_join2( out, in1, scale2, in2, scale3, in3 )
struct bn_tabdata		*out;
const struct bn_tabdata		*in1;
register double			scale2;
const struct bn_tabdata		*in2;
register double			scale3;
const struct bn_tabdata		*in3;
d423 1
a423 6
bn_tabdata_blend2( out, scale1, in1, scale2, in2 )
struct bn_tabdata		*out;
register double			scale1;
const struct bn_tabdata		*in1;
register double			scale2;
const struct bn_tabdata		*in2;
d454 1
a454 8
bn_tabdata_blend3( out, scale1, in1, scale2, in2, scale3, in3 )
struct bn_tabdata		*out;
register double			scale1;
const struct bn_tabdata		*in1;
register double			scale2;
const struct bn_tabdata		*in2;
register double			scale3;
const struct bn_tabdata		*in3;
d493 1
a493 2
bn_tabdata_area1( in )
const struct bn_tabdata	*in;
d520 1
a520 2
bn_tabdata_area2( in )
const struct bn_tabdata	*in;
d551 1
a551 3
bn_tabdata_mul_area1( in1, in2 )
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
d579 1
a579 3
bn_tabdata_mul_area2( in1, in2 )
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
d617 1
a617 3
bn_table_find_x( tabp, xval )
const struct bn_table	*tabp;
double			xval;
d643 1
a643 3
bn_table_lin_interp( samp, wl )
const struct bn_tabdata	*samp;
register double			wl;
d693 1
a693 3
bn_tabdata_resample_max( newtable, olddata )
const struct bn_table	*newtable;
const struct bn_tabdata	*olddata;
d774 1
a774 3
bn_tabdata_resample_avg( newtable, olddata )
const struct bn_table	*newtable;
const struct bn_tabdata	*olddata;
d857 1
a857 3
bn_table_write( filename, tabp )
const char	*filename;
const struct bn_table	*tabp;
d894 1
a894 2
bn_table_read( filename )
const char	*filename;
d941 1
a941 3
bn_pr_table( title, tabp )
const char		*title;
const struct bn_table	*tabp;
d957 1
a957 3
bn_pr_tabdata( title, data )
const char		*title;
const struct bn_tabdata	*data;
d980 1
a980 3
bn_print_table_and_tabdata( filename, data )
const char			*filename;
const struct bn_tabdata	*data;
d1023 1
a1023 2
bn_read_table_and_tabdata( filename )
const char	*filename;
d1083 1
a1083 4
bn_tabdata_binary_read( filename, num, tabp )
const char			*filename;
int				num;
const struct bn_table	*tabp;
d1153 1
a1153 3
bn_tabdata_malloc_array( tabp, num )
const struct bn_table	*tabp;
int	num;
d1187 1
a1187 3
bn_tabdata_copy( out, in )
struct bn_tabdata	*out;
const struct bn_tabdata	*in;
d1206 1
a1206 2
bn_tabdata_dup( in )
const struct bn_tabdata	*in;
d1226 1
a1226 3
bn_tabdata_get_constval( val, tabp )
double			val;
const struct bn_table	*tabp;
d1250 1
a1250 3
bn_tabdata_constval( data, val )
struct bn_tabdata	*data;
double			val;
d1272 1
a1272 3
bn_tabdata_to_tcl( vp, data )
struct bu_vls		*vp;
const struct bn_tabdata	*data;
d1310 1
a1310 2
bn_tabdata_from_array( array )
const double *array;
d1346 1
a1346 4
bn_tabdata_freq_shift( out, in, offset )
struct bn_tabdata		*out;
const struct bn_tabdata		*in;
double				offset;
d1373 1
a1373 4
bn_table_interval_num_samples( tabp, low, hi )
const struct bn_table *tabp;
double	low;
double	hi;
d1396 1
a1396 4
bn_table_delete_sample_pts( tabp, i, j )
struct bn_table *tabp;
int	i;
int	j;
d1427 1
a1427 3
bn_table_merge2( a, b )
const struct bn_table	*a;
const struct bn_table	*b;
d1482 1
a1482 4
bn_tabdata_mk_linear_filter( spectrum, lower_wavelen, upper_wavelen )
const struct bn_table *spectrum;
double		lower_wavelen;
double		upper_wavelen;
@


1.36
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.34 2001/04/05 19:35:28 morrison Exp $ (ARL)";
d36 1
d38 1
@


1.36.10.1
log
@merge from head
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header$ (ARL)";
a35 1
#if HAVE_UNISTD_H
a36 1
#endif
@


1.36.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.36 2002/08/20 17:07:37 jra Exp $ (ARL)";
a35 1
#if HAVE_UNISTD_H
a36 1
#endif
@


1.36.2.1
log
@Initial ANSIfication
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.36 2002/08/20 17:07:37 jra Exp $ (ARL)";
d55 2
a56 1
bn_table_free(struct bn_table *tabp)
d69 2
a70 1
bn_tabdata_free(struct bn_tabdata *data)
d86 2
a87 1
bn_ck_table(const struct bn_table *tabp)
d110 4
a113 1
bn_table_make_uniform(int num, double first, double last)
d144 4
a147 1
bn_tabdata_add(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2)
d178 4
a181 1
bn_tabdata_mul(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2)
d212 5
a216 1
bn_tabdata_mul3(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, const struct bn_tabdata *in3)
d251 6
a256 1
bn_tabdata_incr_mul3_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, const struct bn_tabdata *in3, register double scale)
d290 5
a294 1
bn_tabdata_incr_mul2_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, register double scale)
d324 4
a327 1
bn_tabdata_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale)
d356 3
a358 1
bn_table_scale(struct bn_table *tabp, register double scale)
d381 5
a385 1
bn_tabdata_join1(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale, const struct bn_tabdata *in2)
d421 7
a427 1
bn_tabdata_join2(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2, register double scale3, const struct bn_tabdata *in3)
d461 6
a466 1
bn_tabdata_blend2(struct bn_tabdata *out, register double scale1, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2)
d497 8
a504 1
bn_tabdata_blend3(struct bn_tabdata *out, register double scale1, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2, register double scale3, const struct bn_tabdata *in3)
d543 2
a544 1
bn_tabdata_area1(const struct bn_tabdata *in)
d571 2
a572 1
bn_tabdata_area2(const struct bn_tabdata *in)
d603 3
a605 1
bn_tabdata_mul_area1(const struct bn_tabdata *in1, const struct bn_tabdata *in2)
d633 3
a635 1
bn_tabdata_mul_area2(const struct bn_tabdata *in1, const struct bn_tabdata *in2)
d673 3
a675 1
bn_table_find_x(const struct bn_table *tabp, double xval)
d701 3
a703 1
bn_table_lin_interp(const struct bn_tabdata *samp, register double wl)
d753 3
a755 1
bn_tabdata_resample_max(const struct bn_table *newtable, const struct bn_tabdata *olddata)
d836 3
a838 1
bn_tabdata_resample_avg(const struct bn_table *newtable, const struct bn_tabdata *olddata)
d921 3
a923 1
bn_table_write(const char *filename, const struct bn_table *tabp)
d960 2
a961 1
bn_table_read(const char *filename)
d1008 3
a1010 1
bn_pr_table(const char *title, const struct bn_table *tabp)
d1026 3
a1028 1
bn_pr_tabdata(const char *title, const struct bn_tabdata *data)
d1051 3
a1053 1
bn_print_table_and_tabdata(const char *filename, const struct bn_tabdata *data)
d1096 2
a1097 1
bn_read_table_and_tabdata(const char *filename)
d1157 4
a1160 1
bn_tabdata_binary_read(const char *filename, int num, const struct bn_table *tabp)
d1230 3
a1232 1
bn_tabdata_malloc_array(const struct bn_table *tabp, int num)
d1266 3
a1268 1
bn_tabdata_copy(struct bn_tabdata *out, const struct bn_tabdata *in)
d1287 2
a1288 1
bn_tabdata_dup(const struct bn_tabdata *in)
d1308 3
a1310 1
bn_tabdata_get_constval(double val, const struct bn_table *tabp)
d1334 3
a1336 1
bn_tabdata_constval(struct bn_tabdata *data, double val)
d1358 3
a1360 1
bn_tabdata_to_tcl(struct bu_vls *vp, const struct bn_tabdata *data)
d1398 2
a1399 1
bn_tabdata_from_array(const double *array)
d1435 4
a1438 1
bn_tabdata_freq_shift(struct bn_tabdata *out, const struct bn_tabdata *in, double offset)
d1465 4
a1468 1
bn_table_interval_num_samples(const struct bn_table *tabp, double low, double hi)
d1491 4
a1494 1
bn_table_delete_sample_pts(struct bn_table *tabp, int i, int j)
d1525 3
a1527 1
bn_table_merge2(const struct bn_table *a, const struct bn_table *b)
d1582 4
a1585 1
bn_tabdata_mk_linear_filter(const struct bn_table *spectrum, double lower_wavelen, double upper_wavelen)
@


1.36.2.2
log
@sync branch with HEAD
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header$ (ARL)";
a35 1
#if HAVE_UNISTD_H
a36 1
#endif
@


1.35
log
@Converted from K&R to ANSI C - RFH
@
text
@d55 2
a56 1
bn_table_free(struct bn_table *tabp)
d69 2
a70 1
bn_tabdata_free(struct bn_tabdata *data)
d86 2
a87 1
bn_ck_table(const struct bn_table *tabp)
d110 4
a113 1
bn_table_make_uniform(int num, double first, double last)
d144 4
a147 1
bn_tabdata_add(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2)
d178 4
a181 1
bn_tabdata_mul(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2)
d212 5
a216 1
bn_tabdata_mul3(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, const struct bn_tabdata *in3)
d251 6
a256 1
bn_tabdata_incr_mul3_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, const struct bn_tabdata *in3, register double scale)
d290 5
a294 1
bn_tabdata_incr_mul2_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, const struct bn_tabdata *in2, register double scale)
d324 4
a327 1
bn_tabdata_scale(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale)
d356 3
a358 1
bn_table_scale(struct bn_table *tabp, register double scale)
d381 5
a385 1
bn_tabdata_join1(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale, const struct bn_tabdata *in2)
d421 7
a427 1
bn_tabdata_join2(struct bn_tabdata *out, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2, register double scale3, const struct bn_tabdata *in3)
d461 6
a466 1
bn_tabdata_blend2(struct bn_tabdata *out, register double scale1, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2)
d497 8
a504 1
bn_tabdata_blend3(struct bn_tabdata *out, register double scale1, const struct bn_tabdata *in1, register double scale2, const struct bn_tabdata *in2, register double scale3, const struct bn_tabdata *in3)
d543 2
a544 1
bn_tabdata_area1(const struct bn_tabdata *in)
d571 2
a572 1
bn_tabdata_area2(const struct bn_tabdata *in)
d603 3
a605 1
bn_tabdata_mul_area1(const struct bn_tabdata *in1, const struct bn_tabdata *in2)
d633 3
a635 1
bn_tabdata_mul_area2(const struct bn_tabdata *in1, const struct bn_tabdata *in2)
d673 3
a675 1
bn_table_find_x(const struct bn_table *tabp, double xval)
d701 3
a703 1
bn_table_lin_interp(const struct bn_tabdata *samp, register double wl)
d753 3
a755 1
bn_tabdata_resample_max(const struct bn_table *newtable, const struct bn_tabdata *olddata)
d836 3
a838 1
bn_tabdata_resample_avg(const struct bn_table *newtable, const struct bn_tabdata *olddata)
d921 3
a923 1
bn_table_write(const char *filename, const struct bn_table *tabp)
d960 2
a961 1
bn_table_read(const char *filename)
d1008 3
a1010 1
bn_pr_table(const char *title, const struct bn_table *tabp)
d1026 3
a1028 1
bn_pr_tabdata(const char *title, const struct bn_tabdata *data)
d1051 3
a1053 1
bn_print_table_and_tabdata(const char *filename, const struct bn_tabdata *data)
d1096 2
a1097 1
bn_read_table_and_tabdata(const char *filename)
d1157 4
a1160 1
bn_tabdata_binary_read(const char *filename, int num, const struct bn_table *tabp)
d1230 3
a1232 1
bn_tabdata_malloc_array(const struct bn_table *tabp, int num)
d1266 3
a1268 1
bn_tabdata_copy(struct bn_tabdata *out, const struct bn_tabdata *in)
d1287 2
a1288 1
bn_tabdata_dup(const struct bn_tabdata *in)
d1308 3
a1310 1
bn_tabdata_get_constval(double val, const struct bn_table *tabp)
d1334 3
a1336 1
bn_tabdata_constval(struct bn_tabdata *data, double val)
d1358 3
a1360 1
bn_tabdata_to_tcl(struct bu_vls *vp, const struct bn_tabdata *data)
d1398 2
a1399 1
bn_tabdata_from_array(const double *array)
d1435 4
a1438 1
bn_tabdata_freq_shift(struct bn_tabdata *out, const struct bn_tabdata *in, double offset)
d1465 4
a1468 1
bn_table_interval_num_samples(const struct bn_table *tabp, double low, double hi)
d1491 4
a1494 1
bn_table_delete_sample_pts(struct bn_table *tabp, int i, int j)
d1525 3
a1527 1
bn_table_merge2(const struct bn_table *a, const struct bn_table *b)
d1582 4
a1585 1
bn_tabdata_mk_linear_filter(const struct bn_table *spectrum, double lower_wavelen, double upper_wavelen)
@


1.34
log
@updated SIGNED to signed
updated CONST to const
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.33 2000/07/25 16:43:47 butler Exp $ (ARL)";
d55 1
a55 2
bn_table_free( tabp )
struct bn_table	*tabp;
d68 1
a68 2
bn_tabdata_free( data )
struct bn_tabdata *data;
d84 1
a84 2
bn_ck_table( tabp )
const struct bn_table	*tabp;
d107 1
a107 4
bn_table_make_uniform( num, first, last )
int	num;
double	first;
double	last;
d138 1
a138 4
bn_tabdata_add( out, in1, in2 )
struct bn_tabdata		*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
d169 1
a169 4
bn_tabdata_mul( out, in1, in2 )
struct bn_tabdata		*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
d200 1
a200 5
bn_tabdata_mul3( out, in1, in2, in3 )
struct bn_tabdata		*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
const struct bn_tabdata	*in3;
d235 1
a235 6
bn_tabdata_incr_mul3_scale( out, in1, in2, in3, scale )
struct bn_tabdata	*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
const struct bn_tabdata	*in3;
register double		scale;
d269 1
a269 5
bn_tabdata_incr_mul2_scale( out, in1, in2, scale )
struct bn_tabdata	*out;
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
register double		scale;
d299 1
a299 4
bn_tabdata_scale( out, in1, scale )
struct bn_tabdata		*out;
const struct bn_tabdata	*in1;
register double			scale;
d328 1
a328 3
bn_table_scale( tabp, scale )
struct bn_table	*tabp;
register double		scale;
d351 1
a351 5
bn_tabdata_join1( out, in1, scale, in2 )
struct bn_tabdata		*out;
const struct bn_tabdata		*in1;
register double			scale;
const struct bn_tabdata		*in2;
d387 1
a387 7
bn_tabdata_join2( out, in1, scale2, in2, scale3, in3 )
struct bn_tabdata		*out;
const struct bn_tabdata		*in1;
register double			scale2;
const struct bn_tabdata		*in2;
register double			scale3;
const struct bn_tabdata		*in3;
d421 1
a421 6
bn_tabdata_blend2( out, scale1, in1, scale2, in2 )
struct bn_tabdata		*out;
register double			scale1;
const struct bn_tabdata		*in1;
register double			scale2;
const struct bn_tabdata		*in2;
d452 1
a452 8
bn_tabdata_blend3( out, scale1, in1, scale2, in2, scale3, in3 )
struct bn_tabdata		*out;
register double			scale1;
const struct bn_tabdata		*in1;
register double			scale2;
const struct bn_tabdata		*in2;
register double			scale3;
const struct bn_tabdata		*in3;
d491 1
a491 2
bn_tabdata_area1( in )
const struct bn_tabdata	*in;
d518 1
a518 2
bn_tabdata_area2( in )
const struct bn_tabdata	*in;
d549 1
a549 3
bn_tabdata_mul_area1( in1, in2 )
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
d577 1
a577 3
bn_tabdata_mul_area2( in1, in2 )
const struct bn_tabdata	*in1;
const struct bn_tabdata	*in2;
d615 1
a615 3
bn_table_find_x( tabp, xval )
const struct bn_table	*tabp;
double			xval;
d641 1
a641 3
bn_table_lin_interp( samp, wl )
const struct bn_tabdata	*samp;
register double			wl;
d691 1
a691 3
bn_tabdata_resample_max( newtable, olddata )
const struct bn_table	*newtable;
const struct bn_tabdata	*olddata;
d772 1
a772 3
bn_tabdata_resample_avg( newtable, olddata )
const struct bn_table	*newtable;
const struct bn_tabdata	*olddata;
d855 1
a855 3
bn_table_write( filename, tabp )
const char	*filename;
const struct bn_table	*tabp;
d892 1
a892 2
bn_table_read( filename )
const char	*filename;
d939 1
a939 3
bn_pr_table( title, tabp )
const char		*title;
const struct bn_table	*tabp;
d955 1
a955 3
bn_pr_tabdata( title, data )
const char		*title;
const struct bn_tabdata	*data;
d978 1
a978 3
bn_print_table_and_tabdata( filename, data )
const char			*filename;
const struct bn_tabdata	*data;
d1021 1
a1021 2
bn_read_table_and_tabdata( filename )
const char	*filename;
d1081 1
a1081 4
bn_tabdata_binary_read( filename, num, tabp )
const char			*filename;
int				num;
const struct bn_table	*tabp;
d1151 1
a1151 3
bn_tabdata_malloc_array( tabp, num )
const struct bn_table	*tabp;
int	num;
d1185 1
a1185 3
bn_tabdata_copy( out, in )
struct bn_tabdata	*out;
const struct bn_tabdata	*in;
d1204 1
a1204 2
bn_tabdata_dup( in )
const struct bn_tabdata	*in;
d1224 1
a1224 3
bn_tabdata_get_constval( val, tabp )
double			val;
const struct bn_table	*tabp;
d1248 1
a1248 3
bn_tabdata_constval( data, val )
struct bn_tabdata	*data;
double			val;
d1270 1
a1270 3
bn_tabdata_to_tcl( vp, data )
struct bu_vls		*vp;
const struct bn_tabdata	*data;
d1308 1
a1308 2
bn_tabdata_from_array( array )
const double *array;
d1344 1
a1344 4
bn_tabdata_freq_shift( out, in, offset )
struct bn_tabdata		*out;
const struct bn_tabdata		*in;
double				offset;
d1371 1
a1371 4
bn_table_interval_num_samples( tabp, low, hi )
const struct bn_table *tabp;
double	low;
double	hi;
d1394 1
a1394 4
bn_table_delete_sample_pts( tabp, i, j )
struct bn_table *tabp;
int	i;
int	j;
d1425 1
a1425 3
bn_table_merge2( a, b )
const struct bn_table	*a;
const struct bn_table	*b;
d1480 1
a1480 4
bn_tabdata_mk_linear_filter( spectrum, lower_wavelen, upper_wavelen )
const struct bn_table *spectrum;
double		lower_wavelen;
double		upper_wavelen;
@


1.33
log
@added include of unistd.h to pick up declarations of external functions
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.32 2000/07/11 23:30:40 cjohnson Exp $ (ARL)";
d87 1
a87 1
CONST struct bn_table	*tabp;
d146 2
a147 2
CONST struct bn_tabdata	*in1;
CONST struct bn_tabdata	*in2;
d151 1
a151 1
	register CONST fastf_t	*i1, *i2;
d180 2
a181 2
CONST struct bn_tabdata	*in1;
CONST struct bn_tabdata	*in2;
d185 1
a185 1
	register CONST fastf_t	*i1, *i2;
d214 3
a216 3
CONST struct bn_tabdata	*in1;
CONST struct bn_tabdata	*in2;
CONST struct bn_tabdata	*in3;
d220 1
a220 1
	register CONST fastf_t	*i1, *i2, *i3;
d253 3
a255 3
CONST struct bn_tabdata	*in1;
CONST struct bn_tabdata	*in2;
CONST struct bn_tabdata	*in3;
d260 1
a260 1
	register CONST fastf_t	*i1, *i2, *i3;
d292 2
a293 2
CONST struct bn_tabdata	*in1;
CONST struct bn_tabdata	*in2;
d298 1
a298 1
	register CONST fastf_t	*i1, *i2;
d326 1
a326 1
CONST struct bn_tabdata	*in1;
d331 1
a331 1
	register CONST fastf_t	*i1;
d383 1
a383 1
CONST struct bn_tabdata		*in1;
d385 1
a385 1
CONST struct bn_tabdata		*in2;
d389 1
a389 1
	register CONST fastf_t	*i1, *i2;
d423 1
a423 1
CONST struct bn_tabdata		*in1;
d425 1
a425 1
CONST struct bn_tabdata		*in2;
d427 1
a427 1
CONST struct bn_tabdata		*in3;
d431 1
a431 1
	register CONST fastf_t	*i1, *i2, *i3;
d464 1
a464 1
CONST struct bn_tabdata		*in1;
d466 1
a466 1
CONST struct bn_tabdata		*in2;
d470 1
a470 1
	register CONST fastf_t	*i1, *i2;
d500 1
a500 1
CONST struct bn_tabdata		*in1;
d502 1
a502 1
CONST struct bn_tabdata		*in2;
d504 1
a504 1
CONST struct bn_tabdata		*in3;
d508 1
a508 1
	register CONST fastf_t	*i1, *i2, *i3;
d544 1
a544 1
CONST struct bn_tabdata	*in;
d547 1
a547 1
	register CONST fastf_t	*ip;
d572 1
a572 1
CONST struct bn_tabdata	*in;
d574 1
a574 1
	CONST struct bn_table	*tabp;
d604 2
a605 2
CONST struct bn_tabdata	*in1;
CONST struct bn_tabdata	*in2;
d608 1
a608 1
	register CONST fastf_t	*i1, *i2;
d634 2
a635 2
CONST struct bn_tabdata	*in1;
CONST struct bn_tabdata	*in2;
d637 1
a637 1
	CONST struct bn_table	*tabp;
d674 1
a674 1
CONST struct bn_table	*tabp;
d702 1
a702 1
CONST struct bn_tabdata	*samp;
d705 1
a705 1
	CONST struct bn_table	*tabp;
d754 2
a755 2
CONST struct bn_table	*newtable;
CONST struct bn_tabdata	*olddata;
d757 1
a757 1
	CONST struct bn_table	*oldtable;
d837 2
a838 2
CONST struct bn_table	*newtable;
CONST struct bn_tabdata	*olddata;
d840 1
a840 1
	CONST struct bn_table	*oldtable;
d922 2
a923 2
CONST char	*filename;
CONST struct bn_table	*tabp;
d961 1
a961 1
CONST char	*filename;
d1009 2
a1010 2
CONST char		*title;
CONST struct bn_table	*tabp;
d1027 2
a1028 2
CONST char		*title;
CONST struct bn_tabdata	*data;
d1052 2
a1053 2
CONST char			*filename;
CONST struct bn_tabdata	*data;
d1056 1
a1056 1
	CONST struct bn_table	*tabp;
d1097 1
a1097 1
CONST char	*filename;
d1158 1
a1158 1
CONST char			*filename;
d1160 1
a1160 1
CONST struct bn_table	*tabp;
d1231 1
a1231 1
CONST struct bn_table	*tabp;
d1268 1
a1268 1
CONST struct bn_tabdata	*in;
d1280 1
a1280 1
	bcopy( (CONST char *)in->y, (char *)out->y, BN_SIZEOF_TABDATA_Y(in) );
d1288 1
a1288 1
CONST struct bn_tabdata	*in;
d1295 1
a1295 1
	bcopy( (CONST char *)in->y, (char *)data->y, BN_SIZEOF_TABDATA_Y(in) );
d1310 1
a1310 1
CONST struct bn_table	*tabp;
d1360 1
a1360 1
CONST struct bn_tabdata	*data;
d1362 1
a1362 1
	CONST struct bn_table	*tabp;
d1399 1
a1399 1
CONST double *array;
d1401 1
a1401 1
	register CONST double	*dp;
d1437 1
a1437 1
CONST struct bn_tabdata		*in;
d1440 1
a1440 1
	CONST struct bn_table	*tabp;
d1466 1
a1466 1
CONST struct bn_table *tabp;
d1526 2
a1527 2
CONST struct bn_table	*a;
CONST struct bn_table	*b;
d1583 1
a1583 1
CONST struct bn_table *spectrum;
@


1.32
log
@LINT picking.  Missing includes and static const for RCSids
@
text
@d31 1
a31 1
static const char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.31 2000/03/29 17:46:56 mike Exp $ (ARL)";
d36 1
@


1.31
log
@
Added appropriate bu_ and bn_ prefixes to things.
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.30 2000/02/03 23:19:14 mike Exp $ (ARL)";
d34 1
d37 8
@


1.30
log
@
Added a blend2 operation
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.29 2000/01/20 21:59:30 mike Exp $ (ARL)";
d1236 1
a1236 1
	data = (struct bn_tabdata *)rt_calloc( num,
@


1.29
log
@
Added bn_tabdata_mk_linear_filter()
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.28 2000/01/20 21:16:43 mike Exp $ (ARL)";
d445 36
@


1.28
log
@
Fixed comment typo
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.27 1999/12/29 20:29:23 jra Exp $ (ARL)";
d617 5
a621 1
 *  Returns -1 if less than start value, -2 if greater than end value.
d636 2
a637 1
	if( xval >= tabp->x[tabp->nx-1] )  return -2;
d1521 97
@


1.27
log
@Eliminated some unused variables
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.26 1999/07/02 19:09:42 mike Exp $ (ARL)";
d73 1
a73 1
 *			R T _ C K _ T A B L E
@


1.26
log
@
Fixed missing semi-colons.  Very odd.
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.25 1998/12/16 03:50:34 mike Exp $ (ARL)";
d351 1
a351 1
	register fastf_t	*op, *i1;
a832 1
			fastf_t	w_frac;
a1049 1
	struct bu_vls		line;
@


1.25
log
@Fixed stray rt_ prefix on rt_pr_tabdata()
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.24 1998/12/11 20:43:25 mike Exp $ (ARL)";
d384 1
a384 1
	BN_CK_TABDATA( in1 )
d426 1
a426 1
	BN_CK_TABDATA( in1 )
d467 1
a467 1
	BN_CK_TABDATA( in1 )
@


1.24
log
@h/tabdata.h now part of bn.h
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.23 1998/12/11 20:41:09 mike Exp $ (ARL)";
d955 1
a955 1
 *			R T _ P R _ T A B L E
d958 1
a958 1
rt_pr_table( title, tabp )
d964 1
a964 1
	bu_log("rt_pr_table(%s):\n", title);
d973 1
a973 1
 *			R T _ P R _ T A B D A T A
d976 1
a976 1
rt_pr_tabdata( title, data )
d982 1
a982 1
	bu_log("rt_pr_tabdata(%s): ", title);
@


1.23
log
@rt_tabdata stuff is now all bn_tabdata
@
text
@d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.22 1998/12/11 20:22:52 mike Exp $ (ARL)";
d39 1
a39 3
/* #include "raytrace.h" */
#include "tabdata.h"
#include "../librt/debug.h"
d666 1
a666 1
		if(bu_debug&DEBUG_MATH)bu_log("bn_table_lin_interp(%g) out of range %g to %g\n", wl, tabp->x[0], tabp->x[tabp->nx] );
d677 1
a677 1
		if(bu_debug&DEBUG_MATH)bu_log("bn_table_lin_interp(%g)=%g off end of range %g to %g\n", wl, samp->y[tabp->nx-1], tabp->x[0], tabp->x[tabp->nx] );
d685 1
a685 1
	if(bu_debug&DEBUG_MATH)bu_log("bn_table_lin_interp(%g)=%g in range %g to %g\n",
@


1.22
log
@tabdata.c moved to libbn from librt
@
text
@a0 1
#define DEBUG_TABDATA	0x08000000	/* 28 tabdata library */
a4 2
 * XXX Probably belongs in LIBBN.
 *
d8 2
a9 2
 *  Operates on rt_table (independent var) and
 *  rt_tabdata (dependent variable) structures.
d31 1
a31 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/libbn/tabdata.c,v 1.21 1998/12/11 06:01:27 mike Exp $ (ARL)";
d39 1
a39 1
#include "raytrace.h"
d44 1
a44 1
 *			R T _ T A B L E _ F R E E
d47 2
a48 2
rt_table_free( tabp )
struct rt_table	*tabp;
d50 2
a51 2
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_free(x%x)\n", tabp);
	RT_CK_TABLE(tabp);
d54 1
a54 1
	bu_free( tabp, "struct rt_table");
d58 1
a58 1
 *			R T _ T A B D A T A _ F R E E
d61 2
a62 2
rt_tabdata_free( data )
struct rt_tabdata *data;
d64 1
a64 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_free(x%x)\n", data);
d66 2
a67 2
	RT_CK_TABDATA(data);
	RT_CK_TABLE(data->table);
d71 1
a71 1
	bu_free( data, "struct rt_tabdata" );
d78 2
a79 2
rt_ck_table( tabp )
CONST struct rt_table	*tabp;
d83 1
a83 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_ck_table(x%x)\n", tabp);
d85 1
a85 1
	RT_CK_TABLE(tabp);
d87 1
a87 1
	if( tabp->nx < 2 ) rt_bomb("rt_ck_table() less than 2 wavelengths\n");
d91 1
a91 1
			rt_bomb("rt_ck_table() wavelengths not in strictly ascending order\n");
d96 1
a96 1
 *			R T _ T A B L E _ M A K E _ U N I F O R M
d101 2
a102 2
struct rt_table *
rt_table_make_uniform( num, first, last )
d107 1
a107 1
	struct rt_table	*tabp;
d112 1
a112 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_make_uniform( num=%d, %g, %g )\n", num, first, last );
d114 1
a114 1
	if( first >= last )  rt_bomb("rt_table_make_uniform() first >= last\n");
d116 1
a116 1
	RT_GET_TABLE( tabp, num );
d131 1
a131 1
 *			R T _ T A B D A T A _ A D D
d136 4
a139 4
rt_tabdata_add( out, in1, in2 )
struct rt_tabdata		*out;
CONST struct rt_tabdata	*in1;
CONST struct rt_tabdata	*in2;
d145 1
a145 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_add(x%x, x%x, x%x)\n", out, in1, in2);
d147 3
a149 3
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 );
	RT_CK_TABDATA( in2 );
d152 1
a152 1
		rt_bomb("rt_tabdata_add(): samples drawn from different tables\n");
d154 1
a154 1
		rt_bomb("rt_tabdata_add(): different tabdata lengths?\n");
d165 1
a165 1
 *			R T _ T A B D A T A _ M U L
d170 4
a173 4
rt_tabdata_mul( out, in1, in2 )
struct rt_tabdata		*out;
CONST struct rt_tabdata	*in1;
CONST struct rt_tabdata	*in2;
d179 1
a179 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_mul(x%x, x%x, x%x)\n", out, in1, in2);
d181 3
a183 3
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 );
	RT_CK_TABDATA( in2 );
d186 1
a186 1
		rt_bomb("rt_tabdata_mul(): samples drawn from different tables\n");
d188 1
a188 1
		rt_bomb("rt_tabdata_mul(): different tabdata lengths?\n");
d199 1
a199 1
 *			R T _ T A B D A T A _ M U L 3
d204 5
a208 5
rt_tabdata_mul3( out, in1, in2, in3 )
struct rt_tabdata		*out;
CONST struct rt_tabdata	*in1;
CONST struct rt_tabdata	*in2;
CONST struct rt_tabdata	*in3;
d214 1
a214 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_mul3(x%x, x%x, x%x, x%x)\n", out, in1, in2, in3);
d216 4
a219 4
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 );
	RT_CK_TABDATA( in2 );
	RT_CK_TABDATA( in3 );
d222 1
a222 1
		rt_bomb("rt_tabdata_mul(): samples drawn from different tables\n");
d224 1
a224 1
		rt_bomb("rt_tabdata_mul(): different tabdata lengths?\n");
d236 1
a236 1
 *			R T _ T A B D A T A _ I N C R _ M U L 3 _ S C A L E
d243 5
a247 5
rt_tabdata_incr_mul3_scale( out, in1, in2, in3, scale )
struct rt_tabdata	*out;
CONST struct rt_tabdata	*in1;
CONST struct rt_tabdata	*in2;
CONST struct rt_tabdata	*in3;
d254 1
a254 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_incr_mul3_scale(x%x, x%x, x%x, x%x, %g)\n", out, in1, in2, in3, scale);
d256 4
a259 4
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 );
	RT_CK_TABDATA( in2 );
	RT_CK_TABDATA( in3 );
d262 1
a262 1
		rt_bomb("rt_tabdata_mul(): samples drawn from different tables\n");
d264 1
a264 1
		rt_bomb("rt_tabdata_mul(): different tabdata lengths?\n");
d275 1
a275 1
 *			R T _ T A B D A T A _ I N C R _ M U L 2 _ S C A L E
d282 4
a285 4
rt_tabdata_incr_mul2_scale( out, in1, in2, scale )
struct rt_tabdata	*out;
CONST struct rt_tabdata	*in1;
CONST struct rt_tabdata	*in2;
d292 1
a292 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_incr_mul2_scale(x%x, x%x, x%x, %g)\n", out, in1, in2, scale);
d294 3
a296 3
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 );
	RT_CK_TABDATA( in2 );
d299 1
a299 1
		rt_bomb("rt_tabdata_mul(): samples drawn from different tables\n");
d301 1
a301 1
		rt_bomb("rt_tabdata_mul(): different tabdata lengths?\n");
d311 1
a311 1
 *			R T _ T A B D A T A _ S C A L E
d316 3
a318 3
rt_tabdata_scale( out, in1, scale )
struct rt_tabdata		*out;
CONST struct rt_tabdata	*in1;
d325 1
a325 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_scale(x%x, x%x, %g)\n", out, in1, scale);
d327 2
a328 2
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 );
d331 1
a331 1
		rt_bomb("rt_tabdata_scale(): samples drawn from different tables\n");
d333 1
a333 1
		rt_bomb("rt_tabdata_scale(): different tabdata lengths?\n");
d343 1
a343 1
 *			R T _ T A B L E _ S C A L E
d348 2
a349 2
rt_table_scale( tabp, scale )
struct rt_table	*tabp;
d355 1
a355 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_scale(x%x, %g)\n", tabp, scale );
d357 1
a357 1
	RT_CK_TABLE( tabp );
d366 1
a366 1
 *			R T _ T A B D A T A _ J O I N 1
d373 3
a375 3
rt_tabdata_join1( out, in1, scale, in2 )
struct rt_tabdata		*out;
CONST struct rt_tabdata		*in1;
d377 1
a377 1
CONST struct rt_tabdata		*in2;
d383 1
a383 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_join1(x%x, x%x, %g, x%x)\n", out, in1, scale, in2 );
d385 3
a387 3
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 )
	RT_CK_TABDATA( in2 );
d390 1
a390 1
		rt_bomb("rt_tabdata_join1(): samples drawn from different tables\n");
d392 1
a392 1
		rt_bomb("rt_tabdata_join1(): samples drawn from different tables\n");
d394 1
a394 1
		rt_bomb("rt_tabdata_join1(): different tabdata lengths?\n");
d405 1
a405 1
 *			R T _ T A B D A T A _ J O I N 2
d413 3
a415 3
rt_tabdata_join2( out, in1, scale2, in2, scale3, in3 )
struct rt_tabdata		*out;
CONST struct rt_tabdata		*in1;
d417 1
a417 1
CONST struct rt_tabdata		*in2;
d419 1
a419 1
CONST struct rt_tabdata		*in3;
d425 1
a425 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_join2(x%x, x%x, %g, x%x, %g, x%x)\n", out, in1, scale2, in2, scale3, in3 );
d427 3
a429 3
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 )
	RT_CK_TABDATA( in2 );
d432 1
a432 1
		rt_bomb("rt_tabdata_join1(): samples drawn from different tables\n");
d434 1
a434 1
		rt_bomb("rt_tabdata_join1(): samples drawn from different tables\n");
d436 1
a436 1
		rt_bomb("rt_tabdata_join1(): samples drawn from different tables\n");
d438 1
a438 1
		rt_bomb("rt_tabdata_join1(): different tabdata lengths?\n");
d450 1
a450 1
 *			R T _ T A B D A T A _ B L E N D 3
d453 2
a454 2
rt_tabdata_blend3( out, scale1, in1, scale2, in2, scale3, in3 )
struct rt_tabdata		*out;
d456 1
a456 1
CONST struct rt_tabdata		*in1;
d458 1
a458 1
CONST struct rt_tabdata		*in2;
d460 1
a460 1
CONST struct rt_tabdata		*in3;
d466 1
a466 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_blend3(x%x, %g, x%x, %g, x%x, %g, x%x)\n", out, scale1, in1, scale2, in2, scale3, in3 );
d468 4
a471 4
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in1 )
	RT_CK_TABDATA( in2 );
	RT_CK_TABDATA( in3 );
d474 1
a474 1
		rt_bomb("rt_tabdata_blend3(): samples drawn from different tables\n");
d476 1
a476 1
		rt_bomb("rt_tabdata_blend3(): samples drawn from different tables\n");
d478 1
a478 1
		rt_bomb("rt_tabdata_blend3(): samples drawn from different tables\n");
d480 1
a480 1
		rt_bomb("rt_tabdata_blend3(): different tabdata lengths?\n");
d492 1
a492 1
 *			R T _ T A B D A T A _ A R E A 1
d499 2
a500 2
rt_tabdata_area1( in )
CONST struct rt_tabdata	*in;
d506 1
a506 1
	RT_CK_TABDATA(in);
d513 1
a513 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_area(x%x) = %g\n", in, area);
d519 1
a519 1
 *			R T _ T A B D A T A _ A R E A 2
d527 2
a528 2
rt_tabdata_area2( in )
CONST struct rt_tabdata	*in;
d530 1
a530 1
	CONST struct rt_table	*tabp;
d535 1
a535 1
	RT_CK_TABDATA(in);
d537 1
a537 1
	RT_CK_TABLE(tabp);
d545 1
a545 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_area2(x%x) = %g\n", in, area);
d550 1
a550 1
 *			R T _ T A B D A T A _ M U L _ A R E A 1
d559 3
a561 3
rt_tabdata_mul_area1( in1, in2 )
CONST struct rt_tabdata	*in1;
CONST struct rt_tabdata	*in2;
d567 2
a568 2
	RT_CK_TABDATA(in1);
	RT_CK_TABDATA(in2);
d576 1
a576 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_mul_area1(x%x, x%x) = %g\n", in1, in2, area);
d581 1
a581 1
 *			R T _ T A B D A T A _ M U L _ A R E A 2
d589 3
a591 3
rt_tabdata_mul_area2( in1, in2 )
CONST struct rt_tabdata	*in1;
CONST struct rt_tabdata	*in2;
d593 1
a593 1
	CONST struct rt_table	*tabp;
d598 2
a599 2
	RT_CK_TABDATA(in1);
	RT_CK_TABDATA(in2);
d601 1
a601 1
	RT_CK_TABLE(tabp);
d609 1
a609 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_mul_area2(x%x, x%x) = %g\n", in1, in2, area);
d614 1
a614 1
 *			R T _ T A B L E _ F I N D _ X
d625 2
a626 2
rt_table_find_x( tabp, xval )
CONST struct rt_table	*tabp;
d631 2
a632 2
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_find_x(x%x, %g)\n", tabp, xval );
	RT_CK_TABLE(tabp);
d645 1
a645 1
 *			R T _ T A B L E _ L I N _ I N T E R P
d652 2
a653 2
rt_table_lin_interp( samp, wl )
CONST struct rt_tabdata	*samp;
d656 1
a656 1
	CONST struct rt_table	*tabp;
d661 1
a661 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_lin_interp(x%x, %g)\n", samp, wl);
d663 1
a663 1
	RT_CK_TABDATA(samp);
d665 1
a665 1
	RT_CK_TABLE(tabp);
d667 2
a668 2
	if( (i = rt_table_find_x( tabp, wl )) < 0 )  {
		if(rt_g.debug&DEBUG_MATH)bu_log("rt_table_lin_interp(%g) out of range %g to %g\n", wl, tabp->x[0], tabp->x[tabp->nx] );
d673 2
a674 2
		rt_log("rt_table_lin_interp(%g) assertion1 failed at %g\n", wl, tabp->x[i] );
		rt_bomb("rt_table_lin_interp() assertion1 failed\n");
d679 1
a679 1
		if(rt_g.debug&DEBUG_MATH)bu_log("rt_table_lin_interp(%g)=%g off end of range %g to %g\n", wl, samp->y[tabp->nx-1], tabp->x[0], tabp->x[tabp->nx] );
d685 1
a685 1
	if( fract < 0 || fract > 1 )  rt_bomb("rt_table_lin_interp() assertion2 failed\n");
d687 1
a687 1
	if(rt_g.debug&DEBUG_MATH)bu_log("rt_table_lin_interp(%g)=%g in range %g to %g\n",
d693 1
a693 1
 *			R T _ T A B D A T A _ R E S A M P L E _ M A X
d703 4
a706 4
struct rt_tabdata *
rt_tabdata_resample_max( newtable, olddata )
CONST struct rt_table	*newtable;
CONST struct rt_tabdata	*olddata;
d708 2
a709 2
	CONST struct rt_table	*oldtable;
	struct rt_tabdata	*newsamp;
d713 1
a713 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_resample_max(x%x, x%x)\n", newtable, olddata);
d715 2
a716 2
	RT_CK_TABLE(newtable);
	RT_CK_TABDATA(olddata);
d718 1
a718 1
	RT_CK_TABLE(oldtable);
d720 1
a720 1
	if( oldtable == newtable )  rt_log("rt_tabdata_resample_max() NOTICE old and new rt_table structs are the same\n");
d722 1
a722 1
	RT_GET_TABDATA( newsamp, newtable );
d729 2
a730 2
		j = rt_table_find_x( oldtable, newtable->x[i] );
		k = rt_table_find_x( oldtable, newtable->x[i+1] );
d750 2
a751 2
			newsamp->y[i] = rt_table_lin_interp( olddata, newtable->x[i] );
			tmp = rt_table_lin_interp( olddata, newtable->x[i+1] );
d762 2
a763 2
			n = rt_table_lin_interp( olddata, newtable->x[i] );
			tmp = rt_table_lin_interp( olddata, newtable->x[i+1] );
d776 1
a776 1
 *			R T _ T A B D A T A _ R E S A M P L E _ A V G
d786 4
a789 4
struct rt_tabdata *
rt_tabdata_resample_avg( newtable, olddata )
CONST struct rt_table	*newtable;
CONST struct rt_tabdata	*olddata;
d791 2
a792 2
	CONST struct rt_table	*oldtable;
	struct rt_tabdata	*newsamp;
d796 1
a796 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_resample_avg(x%x, x%x)\n", newtable, olddata);
d798 2
a799 2
	RT_CK_TABLE(newtable);
	RT_CK_TABDATA(olddata);
d801 1
a801 1
	RT_CK_TABLE(oldtable);
d803 1
a803 1
	if( oldtable == newtable )  rt_log("rt_tabdata_resample_avg() NOTICE old and new rt_table structs are the same\n");
d805 1
a805 1
	RT_GET_TABDATA( newsamp, newtable );
d812 2
a813 2
		j = rt_table_find_x( oldtable, newtable->x[i] );
		k = rt_table_find_x( oldtable, newtable->x[i+1] );
d823 2
a824 2
			    rt_table_lin_interp( olddata, newtable->x[i] ) +
			    rt_table_lin_interp( olddata, newtable->x[i+1] ) );
d841 1
a841 1
			a = rt_table_lin_interp( olddata, newtable->x[i] );	/* in "j" bin */
d854 1
a854 1
			b = rt_table_lin_interp( olddata, newtable->x[i+1] );	/* in "k" bin */
d866 1
a866 1
 *			R T _ T A B L E _ W R I T E 
d873 1
a873 1
rt_table_write( filename, tabp )
d875 1
a875 1
CONST struct rt_table	*tabp;
d880 1
a880 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_write(%s, x%x)\n", filename, tabp);
d882 1
a882 1
	RT_CK_TABLE(tabp);
d890 1
a890 1
		rt_log("rt_table_write(%s, x%x) FAILED\n", filename, tabp);
d905 1
a905 1
 *			R T _ T A B L E _ R E A D
d911 2
a912 2
struct rt_table *
rt_table_read( filename )
d915 1
a915 1
	struct rt_table	*tabp;
d921 1
a921 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_read(%s)\n", filename);
d929 1
a929 1
		rt_log("rt_table_read(%s) FAILED\n", filename);
d939 1
a939 1
	if( nw <= 0 ) rt_bomb("rt_table_read() bad nw value\n");
d941 1
a941 1
	RT_GET_TABLE( tabp, nw );
d951 1
a951 1
	rt_ck_table( tabp );
d962 1
a962 1
CONST struct rt_table	*tabp;
d967 1
a967 1
	RT_CK_TABLE(tabp);
d980 1
a980 1
CONST struct rt_tabdata	*data;
d985 1
a985 1
	RT_CK_TABDATA(data);
d994 1
a994 1
 *			R T _ P R _ T A B L E _ A N D _ T A B D A T A
d1003 1
a1003 1
rt_pr_table_and_tabdata( filename, data )
d1005 1
a1005 1
CONST struct rt_tabdata	*data;
d1008 1
a1008 1
	CONST struct rt_table	*tabp;
d1011 1
a1011 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_pr_table_and_tabdata(%s, x%x)\n", filename, data);
d1013 1
a1013 1
	RT_CK_TABDATA(data);
d1015 1
a1015 1
	RT_CK_TABLE(tabp);
d1023 1
a1023 1
		rt_log("rt_pr_table_and_tabdata(%s, x%x) FAILED\n", filename, data );
d1038 1
a1038 1
 *			R T _ R E A D _ T A B L E _ A N D _ T A B D A T A
d1043 2
a1044 2
 *  A new rt_table structure and one rt_tabdata structure
 *  are created, a pointer to the rt_tabdata structure is returned.
d1047 2
a1048 2
struct rt_tabdata *
rt_read_table_and_tabdata( filename )
d1051 2
a1052 2
	struct rt_table	*tabp;
	struct rt_tabdata	*data;
d1059 1
a1059 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_read_table_and_tabdata(%s)\n", filename);
d1067 1
a1067 1
		rt_log("rt_read_table_and_tabdata(%s) FAILED\n", filename);
d1081 2
a1082 2
	RT_GET_TABLE( tabp, count );
	RT_GET_TABDATA( data, tabp );
d1090 1
a1090 1
			rt_log("rt_read_table_and_tabdata(%s) unexpected EOF on line %d\n", filename, i);
d1101 1
a1101 1
	rt_ck_table( tabp );
d1107 1
a1107 1
 *			R T _ T A B D A T A _ B I N A R Y _ R E A D
d1109 2
a1110 2
struct rt_tabdata *
rt_tabdata_binary_read( filename, num, tabp )
d1113 1
a1113 1
CONST struct rt_table	*tabp;
d1115 1
a1115 1
	struct rt_tabdata	*data;
d1123 1
a1123 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_binary_read(%s, num=%d, x%x)\n", filename, num, tabp);
d1125 1
a1125 1
	RT_CK_TABLE(tabp);
d1127 1
a1127 1
	nbytes = RT_SIZEOF_TABDATA(tabp);
d1135 1
a1135 1
		bu_log("rt_tabdata_binary_read(%s): %m\n", filename);
d1139 1
a1139 1
		return (struct rt_tabdata *)NULL;
d1143 1
a1143 1
	data = (struct rt_tabdata *)bu_malloc( len+8, "rt_tabdata[]" );
d1149 1
a1149 1
		bu_log("rt_tabdata_binary_read(%s) expected %d got %d\n",
d1151 1
a1151 1
		bu_free( data, "rt_tabdata[]" );
d1155 1
a1155 1
		return (struct rt_tabdata *)NULL;
d1164 1
a1164 1
		register struct rt_tabdata	*sp;
d1166 2
a1167 2
		sp = (struct rt_tabdata *)cp;
		RT_CK_TABDATA(sp);
d1175 1
a1175 1
 *			R T _ T A B D A T A _ M A L L O C _ A R R A Y
d1179 1
a1179 1
 *  This subroutine is provided because the rt_tabdata structures
d1182 3
a1184 3
struct rt_tabdata *
rt_tabdata_malloc_array( tabp, num )
CONST struct rt_table	*tabp;
d1187 1
a1187 1
	struct rt_tabdata	*data;
d1193 1
a1193 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_malloc_array(x%x, num=%d)\n", tabp, num);
d1195 1
a1195 1
	RT_CK_TABLE(tabp);
d1197 1
a1197 1
	nbytes = RT_SIZEOF_TABDATA(tabp);
d1199 2
a1200 2
	data = (struct rt_tabdata *)rt_calloc( num,
		nbytes, "struct rt_tabdata[]" );
d1204 1
a1204 1
		register struct rt_tabdata	*sp;
d1206 2
a1207 2
		sp = (struct rt_tabdata *)cp;
		sp->magic = RT_TABDATA_MAGIC;
d1216 1
a1216 1
 *			R T _ T A B D A T A _ C O P Y
d1219 3
a1221 3
rt_tabdata_copy( out, in )
struct rt_tabdata	*out;
CONST struct rt_tabdata	*in;
d1223 1
a1223 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_copy(x%x, x%x)\n", out, in);
d1225 2
a1226 2
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in );
d1229 1
a1229 1
		rt_bomb("rt_tabdata_copy(): samples drawn from different tables\n");
d1231 1
a1231 1
		rt_bomb("rt_tabdata_copy(): different tabdata lengths?\n");
d1233 1
a1233 1
	bcopy( (CONST char *)in->y, (char *)out->y, RT_SIZEOF_TABDATA_Y(in) );
d1237 1
a1237 1
 *			R T _ T A B D A T A _ D U P
d1239 3
a1241 3
struct rt_tabdata *
rt_tabdata_dup( in )
CONST struct rt_tabdata	*in;
d1243 1
a1243 1
	struct rt_tabdata *data;
d1245 2
a1246 2
	RT_CK_TABDATA( in );
	RT_GET_TABDATA( data, in->table );
d1248 1
a1248 1
	bcopy( (CONST char *)in->y, (char *)data->y, RT_SIZEOF_TABDATA_Y(in) );
d1250 1
a1250 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_dup(x%x) = x%x\n", in, data);
d1255 1
a1255 1
 *			R T _ T A B D A T A _ G E T _ C O N S T V A L
d1260 2
a1261 2
struct rt_tabdata *
rt_tabdata_get_constval( val, tabp )
d1263 1
a1263 1
CONST struct rt_table	*tabp;
d1265 1
a1265 1
	struct rt_tabdata	*data;
d1269 2
a1270 2
	RT_CK_TABLE(tabp);
	RT_GET_TABDATA( data, tabp );
d1276 1
a1276 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_get_constval(val=%g, x%x)=x%x\n", val, tabp, data);
d1282 1
a1282 1
 *			R T _ T A B D A T A _ C O N S T V A L
d1287 2
a1288 2
rt_tabdata_constval( data, val )
struct rt_tabdata	*data;
d1294 1
a1294 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_constval(x%x, val=%g)\n", data, val);
d1296 1
a1296 1
	RT_CK_TABDATA(data);
d1304 1
a1304 1
 *			R T _ T A B D A T A _ T O _ T C L
d1306 1
a1306 1
 *  Convert an rt_tabdata/rt_table pair into a Tcl compatible string
d1311 1
a1311 1
rt_tabdata_to_tcl( vp, data )
d1313 1
a1313 1
CONST struct rt_tabdata	*data;
d1315 1
a1315 1
	CONST struct rt_table	*tabp;
d1317 1
a1317 1
	FAST fastf_t	minval = INFINITY, maxval = -INFINITY;
d1319 1
a1319 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_to_tcl(x%x, x%x)\n", vp, data);
d1322 1
a1322 1
	RT_CK_TABDATA(data);
d1324 1
a1324 1
	RT_CK_TABLE(tabp);
d1342 1
a1342 1
 *			R T _ T A B D A T A _ F R O M _ A R R A Y
d1344 2
a1345 2
 *  Given an array of (x,y) pairs, build the relevant rt_table and
 *  rt_tabdata structures.
d1350 2
a1351 2
struct rt_tabdata *
rt_tabdata_from_array( array )
d1356 2
a1357 2
	struct rt_table		*tabp;
	struct rt_tabdata	*data;
d1364 2
a1365 2
	/* Second, build rt_table */
	RT_GET_TABLE( tabp, len );
d1371 2
a1372 2
	/* Third, build rt_tabdata (last input "y" is ignored) */
	RT_GET_TABDATA( data, tabp );
d1377 1
a1377 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_from_array(x%x) = x%x\n", array, data);
d1382 1
a1382 1
 *			R T _ T A B D A T A _ F R E Q _ S H I F T
d1388 3
a1390 3
rt_tabdata_freq_shift( out, in, offset )
struct rt_tabdata		*out;
CONST struct rt_tabdata		*in;
d1393 1
a1393 1
	CONST struct rt_table	*tabp;
d1396 1
a1396 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_tabdata_freq_shift(x%x, x%x, offset=%g)\n", out, in, offset);
d1398 2
a1399 2
	RT_CK_TABDATA( out );
	RT_CK_TABDATA( in );
d1403 1
a1403 1
		rt_bomb("rt_tabdata_freq_shift(): samples drawn from different tables\n");
d1405 1
a1405 1
		rt_bomb("rt_tabdata_freq_shift(): different tabdata lengths?\n");
d1408 1
a1408 1
		out->y[i] = rt_table_lin_interp( in, tabp->x[i]+offset );
d1413 1
a1413 1
 *			R T _ T A B L E _ I N T E R V A L _ N U M _ S A M P L E S
d1418 2
a1419 2
rt_table_interval_num_samples( tabp, low, hi )
CONST struct rt_table *tabp;
d1426 1
a1426 1
	RT_CK_TABLE(tabp);
d1432 1
a1432 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_interval_num_samples(x%x, low=%g, hi=%g) = %d\n", tabp, low, hi, count);
d1437 1
a1437 1
 *			R T _ T A B L E _ D E L E T E _ S A M P L E _ P T S
d1444 2
a1445 2
rt_table_delete_sample_pts( tabp, i, j )
struct rt_table *tabp;
d1452 1
a1452 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_delete_samples(x%x, %d, %d)\n", tabp, i, j);
d1454 1
a1454 1
	RT_CK_TABLE(tabp);
d1456 2
a1457 2
	if( i < 0 || j < 0 )  bu_bomb("rt_table_delete_sample_pts() negative indices\n");
	if( i >= tabp->nx || j >= tabp->nx )  bu_bomb("rt_table_delete_sample_pts() index out of range\n");
d1460 2
a1461 2
	if( tokill < 1 )  bu_bomb("rt_table_delete_sample_pts(): nothing to delete\n");
	if( tokill >= tabp->nx ) bu_bomb("rt_table_delete_sample_pts(): you can't kill 'em all!\n");
d1472 1
a1472 1
 *			R T _ T A B L E _ M E R G E 2
d1477 4
a1480 4
struct rt_table *
rt_table_merge2( a, b )
CONST struct rt_table	*a;
CONST struct rt_table	*b;
d1482 1
a1482 1
	struct rt_table *new;
d1485 2
a1486 2
	RT_CK_TABLE(a);
	RT_CK_TABLE(b);
d1488 1
a1488 1
	RT_GET_TABLE(new, a->nx + b->nx + 2 );
d1515 1
a1515 1
	if( k > new->nx )  bu_bomb("rt_table_merge2() assertion failed, k>nx?\n");
d1518 1
a1518 1
	if(rt_g.debug&DEBUG_TABDATA) bu_log("rt_table_merge2(x%x, x%x) = x%x\n", a, b, new);
@


1.21
log
@Added new routines like rt_tabdata_incr_mul3_scale() for the benefit
of the multispectral Phong shader.
@
text
@d34 1
a34 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.20 1998/12/11 04:26:08 mike Exp $ (ARL)";
d44 1
a44 1
#include "./debug.h"
@


1.20
log
@Added per-function debugging routines.
Fixed bug in rt_tabdata_dup()
@
text
@d34 1
a34 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.19 1998/12/10 08:48:57 mike Exp $ (ARL)";
d199 112
@


1.19
log
@Wrong arg
@
text
@d1 2
d6 2
d34 1
a34 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.18 1998/12/10 08:28:10 mike Exp $ (ARL)";
d53 1
d67 2
d86 2
d115 2
d148 2
d182 2
d216 2
d246 2
d274 2
d316 2
d357 2
d404 2
d436 1
d467 1
d499 2
d522 1
d552 2
d604 2
d687 2
d771 2
d812 2
d902 2
d950 2
d1014 2
d1084 2
d1111 1
a1111 1
struct rt_tabdata		*out;
d1114 2
d1124 1
a1124 1
	bcopy( (char *)in->y, (char *)out->y, RT_SIZEOF_TABDATA(in->table) );
d1139 3
a1141 1
	bcopy( (char *)in->y, (char *)data->y, RT_SIZEOF_TABDATA(in->table) );
d1167 2
d1185 2
d1210 2
d1267 2
d1287 2
d1322 2
d1332 1
d1343 2
d1409 1
@


1.18
log
@Added rt_pr_tabdata().  Fixed bcopy() length problem.
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.17 1998/11/26 03:39:25 mike Exp $ (ARL)";
d1072 1
a1072 1
	bcopy( (char *)in->y, (char *)out->y, RT_SIZEOF_TABDATA(in) );
d1087 1
a1087 1
	bcopy( (char *)in->y, (char *)data->y, RT_SIZEOF_TABDATA(in) );
@


1.17
log
@Made rt_table_merge2() actually work.
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.16 1998/11/26 03:21:11 mike Exp $ (ARL)";
d806 1
d824 19
d1072 1
a1072 1
	bcopy( (char *)in->y, (char *)out->y, in->ny * sizeof(fastf_t) );
d1087 1
a1087 1
	bcopy( (char *)in->y, (char *)data->y, in->ny * sizeof(fastf_t) );
@


1.16
log
@Additional functions added
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.15 1998/11/26 02:20:36 mike Exp $ (ARL)";
d806 17
d1290 1
a1290 1
	RT_GET_TABLE(new, a->nx + b->nx );
d1294 3
a1296 3
	while( i < a->nx && j < b->nx )  {
		if( i >= a->nx )  {
			while( j < b->nx )
d1300 2
a1301 2
		if( j >= b->nx )  {
			while( i < a->nx )
d1318 1
a1318 1
	new->nx = k;
@


1.15
log
@Improved robustness, added two new routines
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.14 1998/11/20 23:07:38 mike Exp $ (ARL)";
d43 28
d948 1
d1136 38
d1203 2
a1204 1
 *			R T _ T A B D A T A _ I N T E R V A L _ N U M _ S A M P L E S
d1208 1
a1208 1
rt_tabdata_interval_num_samples( tabp, low, hi )
d1222 82
@


1.14
log
@New subroutine name was wrong
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.13 1998/11/17 22:03:18 mike Exp $ (ARL)";
d899 1
a906 1
	data = (struct rt_tabdata *)rt_malloc( len+8, "rt_tabdata[]" );
d908 4
a911 1
	if( (fd = open(filename, 0)) <= 0 )  {
d913 5
a917 1
		rt_bomb("Unable to open rt_tabdata file\n");
d919 14
a932 2
	if( read( fd, (char *)data, len ) != len )  {
		rt_bomb("Read of rt_tabdata failed\n");
d934 1
d936 1
d1104 50
@


1.13
log
@More routines
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.12 1998/10/09 05:51:23 mike Exp $ (ARL)";
d255 1
a255 1
rt_tabdata_join1( out, in1, scale2, in2, scale3, in3 )
@


1.12
log
@Added rt_table_find_x(), as a centralized and robust way of locating
the span containing a given X value. Modified rt_table_lin_interp() to
use it, which cleaned the code up quite a bit. Changed
rt_tabdata_resample(), which had bad aliasing, into
rt_tabdata_resample_max() and rt_tabdata_resample_avg().
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.11 1998/10/07 20:59:37 mike Exp $ (ARL)";
d247 43
d989 17
a1005 1
 *			R T _ T A B D A T A _ C O N S T V A L
d1007 2
a1008 2
 *  For a given table, return a tabdata structure with all elements
 *  initialized to 'val'.
d1027 20
@


1.11
log
@Added rt_tabdata_to_tcl()
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.10 1998/10/07 07:35:09 mike Exp $ (ARL)";
d403 30
a437 3
 *
 *  A binary search would be more efficient, as the wavelengths
 *  are known to be sorted in ascending order.
d445 2
a446 1
	register int			i;
d453 1
a453 1
	if( wl < tabp->x[0] || wl > tabp->x[tabp->nx] )  {
d458 49
a506 3
	/* Search for proper interval in input spectrum */
	for( i = 0; i < tabp->nx-1; i++ )  {
		FAST fastf_t	fract;		/* fraction from [i] to [i+1] */
d508 16
a523 3
		if( wl < tabp->x[i] )  {
			rt_log("rt_table_lin_interp(%g) assertion1 failed at %g\n", wl, tabp->x[i] );
			rt_bomb("rt_table_lin_interp() assertion1 failed\n");
a524 1
		if( wl >= tabp->x[i+1] )  continue;
d526 29
a554 7
		/* The interval has been found */
		fract = (wl - tabp->x[i]) /
			(tabp->x[i+1] - tabp->x[i]);
		if( fract < 0 || fract > 1 )  rt_bomb("rt_table_lin_interp() assertion2 failed\n");
		ret = (1-fract) * samp->y[i] + fract * samp->y[i+1];
		if(rt_g.debug&DEBUG_MATH)bu_log("rt_table_lin_interp(%g)=%g in range %g to %g\n", wl, ret, tabp->x[i], tabp->x[i+1] );
		return ret;
d556 1
a556 6

	/* Assume value is constant in final interval. */
	if( !( wl >= tabp->x[tabp->nx-1] ) )
		rt_bomb("rt_table_lin_interp() assertion3 failed\n");
	if(rt_g.debug&DEBUG_MATH)bu_log("rt_table_lin_interp(%g)=%g off end of range %g to %g\n", wl, samp->y[tabp->nx-1], tabp->x[0], tabp->x[tabp->nx] );
	return samp->y[tabp->nx-1];
d560 1
a560 1
 *			R T _ T A B D A T A _ R E S A M P L E
d563 3
a565 1
 *  spacing, by linearly interpolating the values.
a568 4
 *
 *  XXX Really should check to see if more than one input value spans
 *  interval in output, and if so, average those inputs together
 *  weighted by their fraction of the span.
d571 1
a571 1
rt_tabdata_resample( newtable, olddata )
d576 3
a578 2
	struct rt_tabdata		*newsamp;
	int				i;
d585 1
a585 1
	if( oldtable == newtable )  rt_log("rt_tabdata_resample() NOTICE old and new rt_table structs are the same\n");
d590 53
a642 1
		newsamp->y[i] = rt_table_lin_interp( olddata, newtable->x[i] );
@


1.10
log
@Added error checking and logging to rt_table_lin_interp()
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.8 1998/09/30 03:52:51 mike Exp $ (ARL)";
d814 36
@


1.9
log
@Added comment
@
text
@d40 1
d419 1
d425 2
a426 1
	if( wl < tabp->x[0] || wl > tabp->x[tabp->nx] )
d428 1
d434 4
a437 1
		if( wl < tabp->x[i] )  rt_bomb("rt_table_lin_interp() assertion1 failed\n");
d444 3
a446 1
		return (1-fract) * samp->y[i] + fract * samp->y[i+1];
d452 1
d616 1
@


1.8
log
@Added new routine rt_tabdata_get_constval()
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /c/CVS/brlcad/librt/tabdata.c,v 1.7 1997/12/16 00:10:56 mike Exp $ (ARL)";
d454 4
@


1.7
log
@Converted to bu_semaphore_acquire()
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /m/cad/librt/RCS/tabdata.c,v 1.6 1996/08/27 01:33:15 mike Exp mike $ (ARL)";
d774 25
@


1.6
log
@Converted to bu_vls
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /m/cad/librt/RCS/tabdata.c,v 1.5 1996/07/12 12:10:21 jra Exp mike $ (ARL)";
d496 1
a496 1
	RES_ACQUIRE( &rt_g.res_syscall );
d498 1
a498 1
	RES_RELEASE( &rt_g.res_syscall );
d506 1
a506 1
	RES_ACQUIRE( &rt_g.res_syscall );
d512 1
a512 1
	RES_RELEASE( &rt_g.res_syscall );
d533 1
a533 1
	RES_ACQUIRE( &rt_g.res_syscall );
d535 1
a535 1
	RES_RELEASE( &rt_g.res_syscall );
d553 1
a553 1
	RES_ACQUIRE( &rt_g.res_syscall );
d559 1
a559 1
	RES_RELEASE( &rt_g.res_syscall );
d588 1
a588 1
	RES_ACQUIRE( &rt_g.res_syscall );
d590 1
a590 1
	RES_RELEASE( &rt_g.res_syscall );
d598 1
a598 1
	RES_ACQUIRE( &rt_g.res_syscall );
d603 1
a603 1
	RES_RELEASE( &rt_g.res_syscall );
d629 1
a629 1
	RES_ACQUIRE( &rt_g.res_syscall );
d631 1
a631 1
	RES_RELEASE( &rt_g.res_syscall );
d640 1
a640 1
	RES_ACQUIRE( &rt_g.res_syscall );
d646 1
a646 1
	RES_RELEASE( &rt_g.res_syscall );
d653 1
a653 1
	RES_ACQUIRE( &rt_g.res_syscall );
d664 1
a664 1
	RES_RELEASE( &rt_g.res_syscall );
@


1.5
log
@Minor Mods for IRIX 6.2
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /m/cad/librt/RCS/tabdata.c,v 1.4 1996/04/06 03:51:46 mike Exp jra $ (ARL)";
d37 1
a37 1
#include "rtstring.h"
d528 1
a528 1
	struct rt_vls		line;
d543 2
a544 2
	rt_vls_init(&line);
	rt_vls_gets( &line, fp );
d546 2
a547 2
	sscanf( rt_vls_addr(&line), "%d", &nw );
	rt_vls_free(&line);
d623 1
a623 1
	struct rt_vls		line;
@


1.4
log
@Oops.
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /m/cad/librt/RCS/tabdata.c,v 1.3 1996/04/06 03:47:47 mike Exp mike $ (ARL)";
d89 2
d105 2
a106 1
	register fastf_t	*op, *i1, *i2;
d137 2
a138 1
	register fastf_t	*op, *i1, *i2;
d169 2
a170 1
	register fastf_t	*op, *i1;
d223 2
a224 1
	register fastf_t	*op, *i1, *i2;
d259 2
a260 1
	register fastf_t	*op, *i1, *i2, *i3;
d297 1
a297 1
	register fastf_t	*ip;
d355 1
a355 1
	register fastf_t	*i1, *i2;
@


1.3
log
@Added mul_area2
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /m/cad/librt/RCS/tabdata.c,v 1.2 1996/04/06 02:52:48 mike Exp mike $ (ARL)";
d383 2
@


1.2
log
@More functions
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /m/cad/librt/RCS/tabdata.c,v 1.1 1996/04/06 00:59:25 mike Exp mike $ (ARL)";
d360 29
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
static char RCStabdata[] = "@@(#)$Header: /m/cad/rt/RCS/spectrum.c,v 1.14 1996/03/16 00:50:43 mike Exp mike $ (ARL)";
d204 75
d329 30
@
