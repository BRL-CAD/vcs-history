head	11.12;
access;
symbols
	ansi-20040405-merged:11.9.6.1
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.14.2
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.8.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.14
	phong-branch:11.9.0.12
	photonmap-branch:11.9.0.10
	rel-6-1-DP:11.9
	windows-branch:11.9.0.8
	rel-6-0-2:11.9
	ansi-branch:11.9.0.6
	rel-6-0-1-branch:11.9.0.4
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.9
	offsite-5-3-pre:11.9
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.8
	rel-5-0-beta:11.8
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.24.04.16.47;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.38.59;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2000.01.31.16.28.51;	author jra;	state Exp;
branches
	11.9.6.1
	11.9.8.1
	11.9.14.1;
next	11.8;

11.8
date	98.12.29.00.33.07;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	98.10.27.20.28.10;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.12.20.20.06.11;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.09.18.00.35.11;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.05.08.04.04.34;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.05.04.00.46.57;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.01.25.00.32.31;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.45;	author mike;	state Rel4_4;
branches;
next	1.7;

1.7
date	94.12.01.18.59.35;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.11.14.23.37.45;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.11.07.23.55.48;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.08.24.14.30.11;	author gdurf;	state Exp;
branches;
next	1.3;

1.3
date	94.08.24.14.29.36;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	92.05.13.06.08.03;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	92.05.12.19.12.12;	author butler;	state Exp;
branches;
next	;

11.9.6.1
date	2004.03.17.21.15.53;	author morrison;	state Exp;
branches;
next	;

11.9.8.1
date	2004.03.11.23.40.28;	author morrison;	state Exp;
branches;
next	;

11.9.14.1
date	2004.02.12.19.40.42;	author erikg;	state Exp;
branches;
next	11.9.14.2;

11.9.14.2
date	2004.03.15.14.06.06;	author erikg;	state Exp;
branches;
next	;


desc
@Program for printing an image on a CLC500 w/ IPU-10.  Takes BRLCAD PIX(5)
format image as argument or stdin.
@


11.12
log
@moved to src/canon/
@
text
@/*
 *			P I X - I P U . C
 *
 *  Print a BRL-CAD .pix or .bw file on the Canon CLC-500 scanner.
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 *
 *	Options
 *	a	autosize image file
 *	c	clear framebuffer first
 *	d	SCSI device
 *	g	gamma
 *	h	1Kx1K
 *	m	mosaic
 *	n	scanlines (image)
 *	s	squaresize (image)
 *	w	width (image)
 *	x	file_xoffset
 *	y	file_yoffset
 *	z	zoom image display
 *	A	Autoscale
 *	M	Mag_factor
 *	R	Resolution
 *	C	# copies
 *	D	Divisor
 *	N	scr_height
 *	S	scr_height
 *	U	units ( i | m )
 *	W	scr_width
 *	X	scr_xoffset
 *	Y	scr_yoffset
 *	v	verbose;
 *	V	verbose;
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/canon/pix-ipu.c,v 11.11 2004/05/10 15:30:41 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"

/* Read multiple times until quantity is obtained.  Necessary for pipes */
static int
mread(fd, bufp, n)
int	fd;
register char	*bufp;
int	n;
{
	register int	count = 0;
	register int	nread;

	do {
		nread = read(fd, bufp, (unsigned)n-count);
		if(nread < 0)  {
			return nread;
		}
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}

#if defined(IRIX) && (IRIX == 4 || IRIX == 5 || IRIX == 6)
#include "./canon.h"

# define _SGI_SOURCE	1	/* IRIX 5.0.1 needs this to def M_BLKSZ */
# define _BSD_TYPES	1	/* IRIX 5.0.1 botch in sys/prctl.h */
#include <sys/types.h>
# include <ulocks.h>
/* ulocks.h #include's <limits.h> and <malloc.h> */
/* ulocks.h #include's <task.h> for getpid stuff */
/* task.h #include's <sys/prctl.h> */
# include <malloc.h>
/* <malloc.h> #include's <stddef.h> */
#include <fcntl.h>
#include <stdlib.h>

#include "./chore.h"

static 	struct dsreq *dsp;
static	int	fd;

struct chore	chores[3];

struct chore	*await1;
struct chore	*await2;
struct chore	*await3;

/*
 *  While this step looks innocuous, if the file is located on a slow
 *  or busy disk drive or (worse yet) is on an NFS partition,
 *  this can take a long time.
 */
void step1(aa)
void *aa;
{
	struct chore	*chorep;
	int		pix_y;
	static int	nstarted = 0;

	pix_y = 0;
	for(;;)  {
		if( nstarted < 3 )  {
			chorep = &chores[nstarted++];
			chorep->cbuf = malloc( 255*1024 );
		} else {
			GET( chorep, await1 );
		}

		if( pix_y >= height )  {
			/* Send through a "done" chore and exit */
			chorep->pix_y = -1;
			PUT( await2, chorep );
			/* Wait for them to percolate through */
			GET( chorep, await1 );
			GET( chorep, await1 );
			break;
		}

		chorep->pix_y = pix_y;
		chorep->todo = 255*1024 / (ipu_bytes_per_pixel*width);	/* Limit 255 Kbytes */
		if( height - pix_y < chorep->todo )  chorep->todo = height - pix_y;
		chorep->buflen = chorep->todo * ipu_bytes_per_pixel * width;

		if( mread( fd, chorep->obuf, chorep->buflen ) != chorep->buflen )  {
			perror("pix-ipu mread");
			fprintf(stderr, "buffer read error, line %d\n", chorep->pix_y);
			exit(2);
		}
		pix_y += chorep->todo;

		/* Pass this chore off to next process */
		PUT( await2, chorep );
	}
	exit(0);
}

/* format conversion */
void step2(aa)
void	*aa;
{
	struct chore	*chorep;
	register unsigned char	*cp;
	unsigned char *green, *blue;
	int	buf_y;

	for(;;)  {
		GET(chorep, await2);
		if( chorep->pix_y < 0 )  {
			/* Pass on "done" token and exit */
			PUT( await3, chorep );
			break;
		}

		cp = chorep->obuf;

		if( ipu_bytes_per_pixel == 3 )  {
			green = &chorep->cbuf[width*chorep->todo];
			blue = &chorep->cbuf[width*chorep->todo*2];

			for( buf_y = chorep->todo-1; buf_y >= 0; buf_y-- )  {
				int	offset;
				register unsigned char	*rp, *gp, *bp;
				register int		x;

				offset = buf_y * width;
				rp = &chorep->cbuf[offset];
				gp = &green[offset];
				bp = &blue[offset];
				for( x = width-1; x >= 0; x-- )  {
					*rp++ = *cp++;
					*gp++ = *cp++;
					*bp++ = *cp++;
				}
			}
		} else {
			/* Monochrome */
			for( buf_y = chorep->todo-1; buf_y >= 0; buf_y-- )  {
				int	offset;
				register unsigned char	*rp;
					offset = buf_y * width;
				rp = &chorep->cbuf[offset];
				bcopy( cp, rp, width );
				cp += width;
			}
		}
		PUT( await3, chorep );
	}
	exit(0);
}

/* output via SCSI bus to IPU.  This is the time consuming step. */
void step3(aa)
void	*aa;
{
	struct chore	*chorep;
	int		canon_y;

	for(;;)  {
		GET( chorep, await3 );
		if( chorep->pix_y < 0 )  {
			break;	/* "done" token */
		}

		canon_y = height - chorep->pix_y - chorep->todo;

		ipu_put_image_frag(dsp, 1, 0, canon_y, width, chorep->todo, chorep->cbuf);

		/* Pass this chore off to next process for recycling */
		PUT( await1, chorep );
	}
	exit(0);	/* exit this thread */
}


/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(ac,av)
int ac;
char *av[];
{
	int arg_index;
	int i;
	int	pid[3];

	if ((arg_index = parse_args(ac, av)) >= ac) {
		if (isatty(fileno(stdin)))
			usage("Specify image on cmd line or redirect from standard input\n");

		if (autosize) fprintf(stderr, "Cannot autosize stdin\n");

	} else if (arg_index+1 < ac)
		(void)fprintf(stderr,
			"%s: Excess command line arguments ignored\n", *av);
	else if (freopen(av[arg_index], "r", stdin) == NULL) {
		perror(av[arg_index]);
		return(-1);
	} else if (autosize &&
	    !fb_common_file_size( &width, &height, av[arg_index], ipu_bytes_per_pixel)) {
	    	fprintf(stderr, "unable to autosize\n");
	}

	/* open the printer SCSI device */
	if ((dsp = dsopen(scsi_device, O_RDWR)) == NULL) {
		perror(scsi_device);
		usage("Cannot open SCSI device\n");
	}

	if (ipu_debug)
		fprintf(stderr, "Image is %dx%d (%d)\n", width, height, width*height*ipu_bytes_per_pixel);

	if (conv == IPU_RESOLUTION) {
		if (scr_width)
			scr_width *= 400.0 / (double)param.i;
		else
			scr_width = width * 400.0 / (double)param.i;
		if (scr_height)
			scr_height *= 400.0 / (double)param.i;
		else
			scr_height = height * 400.0 / (double)param.i;
	} else if (conv == IPU_MAG_FACTOR) {
		if (scr_width)
			scr_width *= 400.0 / (double)param.i;
		else
			scr_width = width * 400.0 / (double)param.i;
		if (scr_height)
			scr_height *= 400.0 / (double)param.i;
		else
			scr_height = height * 400.0 / (double)param.i;
	}

	/* Wait for printer to finish what it was doing */
	ipu_acquire(dsp, 120);

	ipu_delete_file(dsp, 1);
	ipu_create_file(dsp, (char)1, ipu_filetype, width, height, 0);

	/* Stream file into the IPU */
	/* Start three threads, then wait for them to finish */
	pid[0] = sproc( step1, PR_SALL|PR_SFDS );
	pid[1] = sproc( step2, PR_SALL|PR_SFDS );
	pid[2] = sproc( step3, PR_SALL|PR_SFDS );

	for( i=0; i<3; i++ )  {
		int	this_pid;
		int	pstat;
		int	j;

		pstat = 0;
		if( (this_pid = wait(&pstat)) <= 0  )  {
			perror("wait");
			fprintf(stderr, "wait returned %d\n", this_pid);
			for( j=0; j<3; j++) kill(pid[j], 9);
			exit(3);
		}
		if( (pstat & 0xFF) != 0 )  {
			fprintf(stderr, "*** child pid %d blew out with error x%x\n", this_pid, pstat);
			for( j=0; j<3; j++) kill(pid[j], 9);
			exit(4);
		}
	}
	/* All children are finished */

	ipu_print_config(dsp, units, divisor, conv,
			mosaic, ipu_gamma, tray);

	if( ipu_filetype == IPU_PALETTE_FILE )
		ipu_set_palette(dsp, NULL);

	if (strcmp(progname, "pix-ipu")==0)
		ipu_print_file(dsp, (char)1, copies, 0/*wait*/,
			scr_xoff, scr_yoff, scr_width, scr_height, &param);

	/* Wait for print operation to complete */
	ipu_acquire(dsp, 30 * copies);

	dsclose(dsp);
	return(0);
}

#else
int
main(ac, av)
int ac;
char *av[];
{
	fprintf(stderr,
		"%s only works on SGI(tm) systems with dslib (direct SCSI library) support\n", *av);
	return(-1);
}
#endif
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/canon/pix-ipu.c,v 11.10 2004/02/02 17:38:59 morrison Exp $ (ARL)";
@


11.10
log
@update copyright to include span through 2003
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/pix-ipu.c,v 11.9 2000/01/31 16:28:51 jra Exp $ (ARL)";
d54 5
a58 1
#include "conf.h"
@


11.9
log
@Eliminated some unused variables
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996 by the United States Army
d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/pix-ipu.c,v 11.8 1998/12/29 00:33:07 mike Exp $ (ARL)";
@


11.9.6.1
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d51 1
a51 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.9.8.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/canon/pix-ipu.c,v 11.10 2004/02/02 17:38:59 morrison Exp $ (ARL)";
@


11.9.14.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/pix-ipu.c,v 11.10 2004/02/02 17:38:59 morrison Exp $ (ARL)";
@


11.9.14.2
log
@merge from head
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/pix-ipu.c,v 11.9.14.1 2004/02/12 19:40:42 erikg Exp $ (ARL)";
@


11.8
log
@Fixed up to compile on IRIX 6
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/pix-ipu.c,v 11.7 1998/10/27 20:28:10 mike Exp $ (ARL)";
a104 3
static char		lockfile[] = "/var/tmp/pix-ipuXXXXXX";
static usptr_t		*lockstuff = 0;

d171 1
a171 1
	unsigned char *red, *green, *blue;
a207 1
				register int		x;
@


11.7
log
@Created png-ipu
Fixed minor aspect ratio problem in pix-ipu.c
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/pix-ipu.c,v 11.6 1996/12/20 20:06:11 butler Exp $ (ARL)";
d90 1
a90 1
#if defined(IRIX) && (IRIX == 4 || IRIX == 5)
@


11.6
log
@removed gratuitous "bb" parameter from step[123]().
SGI compiler was complaining.
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 11.5 1996/09/18 00:35:11 mike Exp butler $ (ARL)";
d295 1
a295 1
			scr_height = width * 400.0 / (double)param.i;
d304 1
a304 1
			scr_height = width * 400.0 / (double)param.i;
@


11.5
log
@Modified to use three threads in a tripple-buffer overlapped I/O
strategy.
Greatly speeds up output:
Size             Old     New
========        ======  ======
1100x850.bw      18.26   17.85
1320x1705.pix    20.18   17.60
1320x1705.pix    20.09   18.25
4400x3400.pix   188.96  100.39
4400x3400.pix   186.92  100.30
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/canon/RCS/pix-ipu.c,v 11.4 1996/05/08 04:04:34 mike Exp mike $ (ARL)";
d124 2
a125 3
void step1(aa,bb)
void	*aa;
size_t	bb;
d169 1
a169 1
void step2(aa,bb)
a170 1
size_t	bb;
d224 1
a224 1
void step3(aa,bb)
a225 1
size_t	bb;
@


11.4
log
@Whoops, one advantage of fread() is that it didn't balk on pipes.
Changed read() to mread(), which retains the efficiency of a
direct read() by avoiding a buffer copy, but can handle the
sys-call re-issue needed when reading from pipes.
@
text
@d3 4
a6 1
 *  Author -
d8 1
d11 2
a12 3
 *	SECAD/VLD Computing Consortium
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d14 5
d20 2
a21 2
 *	This software is Copyright (C) 1992 by the United States Army.
 *	All rights reserved.
d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 11.3 1996/05/04 00:46:57 mike Exp mike $ (BRL)";
d63 4
d91 4
d96 6
d104 145
a248 1
#include "./canon.h"
a260 3
	struct dsreq *dsp;
	u_char	*img_buffer = (u_char *)NULL;
	int	img_bytes;
d262 1
a280 10
	/* get a buffer for the image */
	img_bytes = width * height * ipu_bytes_per_pixel;

	if ( ! (img_buffer=(u_char*)malloc(img_bytes)) ) {
		(void)fprintf(stderr,
			"Cannot allocate memory for %d by %d image\n",
			width, height);
		return(-1);
	}

d288 1
a288 7
		fprintf(stderr, "Image is %dx%d (%d)\n", width, height, img_bytes);

	/* bring the image into memory */
	if ((i=mread(0, &img_buffer[0], img_bytes)) != img_bytes) {
		(void)fprintf(stderr, "%s: Error reading image at %d of %d bytes read\n", progname, i, img_bytes);
		return(-1);
	}
d315 26
a340 1
	ipu_put_image(dsp, (char)1, width, height, img_buffer);
d348 1
a348 1
	if (!strcmp(progname, "pix-ipu"))
d366 1
a366 1
		"%s only works on SGI(tm) systems with dslib support\n", *av);
@


11.3
log
@Changed to not use fread() on entire file, saves a buffer copy.
Changed to initialize palette in 8-bit mode.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 11.2 1996/01/25 00:32:31 mike Exp mike $ (BRL)";
d55 23
d137 1
a137 1
	if ((i=read(0, &img_buffer[0], img_bytes)) != img_bytes) {
@


11.2
log
@Added support for -#1 command line option,
for monochrome images.
Isn't very useful until a library routine is written to set the IPU's
color map.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/canon/RCS/pix-ipu.c,v 11.1 1995/01/04 10:35:45 mike Rel4_4 mike $ (BRL)";
d114 2
a115 2
	if ((i=fread(&img_buffer[0], 1, img_bytes, stdin)) != img_bytes) {
		(void)fprintf(stderr, "%s: Error reading image %d of %d bytes read\n", progname, i, img_bytes);
d148 3
@


11.1
log
@Release_4.4
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.7 94/12/01 18:59:35 mike Exp $ (BRL)";
d90 1
a90 1
	    !fb_common_file_size( &width, &height, av[arg_index], 3)) {
d95 1
a95 1
	img_bytes = width * height * 3;
d143 1
a143 1
	ipu_create_file(dsp, (char)1, IPU_RGB_FILE, width, height, 0);
@


1.7
log
@Used more specific #if to tell if the Direct SCSI support exists or not.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.6 94/11/14 23:37:45 mike Exp Locker: mike $ (BRL)";
@


1.6
log
@Irix 6
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.5 94/11/07 23:55:48 mike Exp Locker: mike $ (BRL)";
d55 1
a55 1
#if defined(__sgi) || defined(sgi)
@


1.5
log
@Changed from extern gamma to extern ipu_gamma, to avoid conflict
with gamma() function in math.h.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.4 94/08/24 14:30:11 gdurf Exp Locker: mike $ (BRL)";
a74 1
	FILE	*image_file;
@


1.4
log
@Factored ifdefs
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.3 1994/08/24 14:29:36 gdurf Exp gdurf $ (BRL)";
d148 1
a148 1
			mosaic, gamma, tray);
@


1.3
log
@Changes by butler
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/canon/RCS/pix-ipu.c,v 1.2 92/05/13 06:08:03 butler Exp Locker: butler $ (BRL)";
d46 2
d49 1
d51 4
@


1.2
log
@made timeout on printing proportional to # of copies being printed
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.1 92/05/12 19:12:12 butler Exp Locker: butler $ (BRL)";
d46 3
a50 1
#include <stdio.h>
a51 2
#include <string.h>
#ifdef __sgi
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /n/wolf/d/butler/printer/RCS/pix-ipu.c,v 1.3 92/05/01 02:49:32 butler Exp Locker: butler $ (BRL)";
d148 1
a148 1
	ipu_acquire(dsp, 120);
@
