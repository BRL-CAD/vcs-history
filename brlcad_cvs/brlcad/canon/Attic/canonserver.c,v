head	11.2;
access;
symbols
	ansi-20040405-merged:11.1
	postmerge-20040405-ansi:11.1
	premerge-20040404-ansi:11.1
	postmerge-autoconf:11.1
	autoconf-freeze:11.1
	premerge-autoconf:11.1
	ansi-20040316-freeze:11.1
	postmerge-20040315-windows:11.1
	premerge-20040315-windows:11.1
	windows-20040315-freeze:11.1
	autoconf-20031203:11.1
	autoconf-20031202:11.1
	autoconf-branch:11.1.0.14
	phong-branch:11.1.0.12
	photonmap-branch:11.1.0.10
	rel-6-1-DP:11.1
	windows-branch:11.1.0.8
	rel-6-0-2:11.1
	ansi-branch:11.1.0.6
	rel-6-0-1-branch:11.1.0.4
	hartley-6-0-post:11.1
	hartley-6-0-pre:11.1
	rel-6-0-1:11.1
	rel-6-0:11.1
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.2
date	2004.05.24.04.16.47;	author morrison;	state dead;
branches;
next	11.1;

11.1
date	95.01.04.10.35.43;	author mike;	state Rel4_4;
branches;
next	1.2;

1.2
date	92.05.14.04.52.42;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	92.05.12.19.11.04;	author butler;	state Exp;
branches;
next	;


desc
@MDQS server program for Canon CLC500 w/ IPU-10.  Invokes "pix-ipu" to
print image.
@


11.2
log
@moved to src/canon/
@
text
@/*	Canonserver.c --- MDQS interface for Canon CLC500 on SGI SCSI bus
 *
 *	Options
 *	h	help
 */
#include <stdio.h>
#include <ctype.h>
#include <sys/wait.h>

#include "queue.h"
#include "qreplys.h"

#define DEBUG
extern char	*Qdatadir;	/* queue file directory name */
static int  lpoptions = 0;	/* line-printer style options */
static char *progname = "(noname)";

static char ipu_prog[64] = "/usr/brlcad/bin/pix-ipu";

int
print(file, copies)
char *file;
int copies;
{
#define MAXARGS 200
	char *argv[MAXARGS];
	int argc;
	char linebuf[1024];
	char *p;
	pid_t pid, rpid;
	int retcode;

#ifdef DEBUG
	(void)fprintf(stderr, "Printing %d copies of \"%s\"\n", copies, file);
	(void)fflush(stderr);
#endif
	if ((pid = fork()) == 0) {
		/* child */
		(void)close(3);
		(void)close(4);

		/* open the data file */
		if (freopen(file, "r", stdin) == (FILE *)NULL)
			exit(2000);

		/* read command line arguments from head of data file */
		fgets(linebuf, sizeof(linebuf)-1, stdin);
		if ( *(p = &linebuf[strlen(linebuf)-1]) == '\n')
			*p = '\0';

		/* create argv for exec() */
		argc = 1;
		p = linebuf;

		if (strncmp(p, "CLC500", 6)) {
			fprintf(stderr, "Bad Magic number in image request\n");
			retmsg( RP_FATAL, "Bad Magic number in image request\n");
			exit( 10 );
		}
		p += 6;

		while (*p && argc < MAXARGS-1) {
			/* skip initial white space */
			while (*p && isascii(*p) && isspace(*p))
				p++;

			argv[argc++] = p;

			/* find the end of a word */
			while (*p && isascii(*p) && !isspace(*p))
				p++;

			*p++ = '\0';
		}
		argv[argc] = (char *)NULL;
		argv[0] = "pix-ipu";

#ifdef DEBUG
		fprintf(stderr,
			"execl(\"%s\") ", ipu_prog);

		for (argc=0 ; argv[argc] != (char *)NULL ; argc++)
			fprintf(stderr, ", \"%s\"", argv[argc]);

		fprintf(stderr, ")\n");
		fflush(stderr);
#endif

		/* hack the kernel's idea of my file pointer to be at
		 * the begining of the image data
		 */
		lseek(fileno(stdin), ftell(stdin), 0);

		execv(ipu_prog, argv);
		perror(ipu_prog);
		exit(16);
	}

	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;

	return(retcode);
}


/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(ac,av)
int ac;
char *av[];
{
	int arg_index;
	int c;
	char ans='\0';
	char	linebuf[LINESIZ];
	char	filename[LINESIZ];
	struct request r;


#ifdef DEBUG
	(void)freopen("/tmp/canonlog", "a", stderr);
#endif
	if (gethdr( stdin, &r ) == NULL ) {
		(void)fprintf(stderr, "%s: \"%s\"\n", progname,
			"error reading request header");
		retmsg( RP_FATAL, "error reading request header");
		exit( 10 );
	}
	while ( fgets( linebuf, (int)sizeof linebuf, stdin ) != NULL ) {
		register char *cp;
		
		if ( *(cp = &linebuf[strlen( linebuf ) - 1]) == '\n' )
			*cp = '\0';

		cp = &linebuf[0];
#ifdef DEBUG
		fprintf(stderr, "%s\n", cp);
#endif
		switch ( *cp++ ) {
		case 'B' :	/* ignore and remove banner */
			filename[sizeof(filename)-1] = '\0';
			strncpy(filename, Qdatadir, sizeof(filename)-1);
			strncat(filename, cp,
				sizeof(filename)-strlen(filename)-1);

			if ( unlink(filename) != 0 )
				(void)fprintf(stderr,
					"couldn't unlink banner \"%s\"\n",
					filename);
			break;
		case 'D' :	/* change working directory */
			if ( chdir( cp ) != 0 ) {
				(void)fprintf(stderr,
					"%s: chdir error\n", progname);
				(void)chdir( "/tmp" );	/* safe */
			}
			break;
		case 'F' :	/* print user file */
			if (print(cp, r.r_copies)
			    && lpoptions & NOKEEP
			    && unlink( cp ) ) {
				fprintf(stderr,
					"couldn't unlink data file \"%s\"\n", 
					cp);
			}
			break;
		case 'I':		/* print spooled file */
			filename[sizeof(filename)-1] = '\0';
			strncpy(filename, Qdatadir, sizeof(filename)-1);
			strncat(filename, cp,
				sizeof(filename)-strlen(filename)-1);

			print(filename, r.r_copies);
			if ( unlink( filename ) != 0 )
				fprintf(stderr,
				    "couldn't unlink spooled file \"%s\"\n",
				    filename );
			break;
		case 'O':		/* line-printer style options */
			lpoptions |= atoi( cp );
			break;
		case 'X':		/* extended options */
		case 'U':		/* user name */
		case 'H':		/* print header */
		case 'T':		/* title */
		default:		/* ignore unknown controls */
			break;
		}
	}

	retmsg( RP_OK, (char *)0 );

	return 0;
}
@


11.1
log
@Release_4.4
@
text
@@


1.2
log
@added magic number checking
@
text
@@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char ipu_prog[64] = "/usr/brlcad/bin/ipx-ipu";
d54 8
@
