head	11.11;
access;
symbols
	ansi-20040405-merged:11.8.6.1
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.14.2
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.8
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.8.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.14
	phong-branch:11.8.0.12
	photonmap-branch:11.8.0.10
	rel-6-1-DP:11.8
	windows-branch:11.8.0.8
	rel-6-0-2:11.8
	ansi-branch:11.8.0.6
	rel-6-0-1-branch:11.8.0.4
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.8
	offsite-5-3-pre:11.8
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.7
	rel-5-0-beta:11.7
	rel-4-5:11.4
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.24.04.16.47;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.38.59;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2000.01.31.16.28.51;	author jra;	state Exp;
branches
	11.8.6.1
	11.8.8.1
	11.8.14.1;
next	11.7;

11.7
date	98.12.29.00.33.07;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	98.11.21.03.45.16;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.10.27.20.28.10;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.05.08.04.04.34;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.05.04.00.46.57;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.01.25.00.32.31;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.45;	author mike;	state Rel4_4;
branches;
next	1.7;

1.7
date	94.12.01.18.59.35;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.11.14.23.37.45;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.11.07.23.55.48;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.08.24.14.30.11;	author gdurf;	state Exp;
branches;
next	1.3;

1.3
date	94.08.24.14.29.36;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	92.05.13.06.08.03;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	92.05.12.19.12.12;	author butler;	state Exp;
branches;
next	;

11.8.6.1
date	2004.03.17.21.15.53;	author morrison;	state Exp;
branches;
next	;

11.8.8.1
date	2004.03.11.23.40.28;	author morrison;	state Exp;
branches;
next	;

11.8.14.1
date	2004.02.12.19.40.42;	author erikg;	state Exp;
branches;
next	11.8.14.2;

11.8.14.2
date	2004.03.15.14.06.06;	author erikg;	state Exp;
branches;
next	;


desc
@Program for printing an image on a CLC500 w/ IPU-10.  Takes BRLCAD PIX(5)
format image as argument or stdin.
@


11.11
log
@moved to src/canon/
@
text
@/*
 *			P N G - I P U . C
 *
 *  Display a PNG file on the Canon CLC-500 Color Laser printer.
 *  This program is based upon pix-ipu.c
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1992-2004 by the United States Army.
 *	All rights reserved.
 *
 *	Options
 *	a	autosize image file
 *	c	clear framebuffer first
 *	d	SCSI device
 *	g	gamma
 *	h	1Kx1K
 *	m	mosaic
 *	n	scanlines (image)
 *	s	squaresize (image)
 *	w	width (image)
 *	x	file_xoffset
 *	y	file_yoffset
 *	z	zoom image display
 *	A	Autoscale
 *	M	Mag_factor
 *	R	Resolution
 *	C	# copies
 *	D	Divisor
 *	N	scr_height
 *	S	scr_height
 *	U	units ( i | m )
 *	W	scr_width
 *	X	scr_xoffset
 *	Y	scr_yoffset
 *	v	verbose;
 *	V	verbose;
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/canon/png-ipu.c,v 11.10 2004/05/10 15:30:41 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"			/* For getopt */
#include "bu.h"
#include "png.h"

static int
mread(fd, bufp, n)
int	fd;
register char	*bufp;
int	n;
{
	register int	count = 0;
	register int	nread;

	do {
		nread = read(fd, bufp, (unsigned)n-count);
		if(nread < 0)  {
			return nread;
		}
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}

#if defined(IRIX) && (IRIX == 4 || IRIX == 5 || IRIX == 6)
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include "./canon.h"

static png_color_16 def_backgrd={ 255,255,255,255,255 };	/* white */
static double	def_screen_gamma=1.0;	/* Don't add more gamma, by default */

static unsigned char **scanline;	/* 1 scanline pixel buffer */


/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(ac,av)
int ac;
char *av[];
{
	int arg_index;
	struct dsreq *dsp;
	int i;
	/**/
	png_structp png_p;
	png_infop info_p;
	char header[8];
	int bit_depth;
	int color_type;
	png_color_16p input_backgrd;
	double gamma=1.0;
	int file_width, file_height;
	unsigned char *image;


	if ((arg_index = parse_args(ac, av)) >= ac) {
		if (isatty(fileno(stdin)))
			usage("Specify image on cmd line or redirect from standard input\n");

		if (autosize) fprintf(stderr, "Cannot autosize stdin\n");

	} else if (arg_index+1 < ac)
		(void)fprintf(stderr,
			"%s: Excess command line arguments ignored\n", *av);
	else if (freopen(av[arg_index], "r", stdin) == NULL) {
		perror(av[arg_index]);
		return(-1);
	}


	/* open the printer SCSI device */
	if ((dsp = dsopen(scsi_device, O_RDWR)) == NULL) {
		perror(scsi_device);
		usage("Cannot open SCSI device\n");
	}

	/* Read the image */
	if( fread( header, 8, 1, stdin ) != 1 )
		bu_bomb( "png-ipu: ERROR: Failed while reading file header!!!\n" );

	if( !png_check_sig( (png_bytep)header, 8 ) )
		bu_bomb( "png-ipu: This is not a PNG file!!!\n" );

	png_p = png_create_read_struct( PNG_LIBPNG_VER_STRING, NULL, NULL, NULL );
	if( !png_p )
		bu_bomb( "png_create_read_struct() failed!!\n" );

	info_p = png_create_info_struct( png_p );
	if( !info_p )
		bu_bomb( "png_create_info_struct() failed!!\n" );

	png_init_io( png_p, stdin );

	png_set_sig_bytes( png_p, 8 );

	png_read_info( png_p, info_p );

	color_type = png_get_color_type( png_p, info_p );

	png_set_expand( png_p );
	bit_depth = png_get_bit_depth( png_p, info_p );
	if( bit_depth == 16 )
		png_set_strip_16( png_p );

	file_width = png_get_image_width( png_p, info_p );
	file_height = png_get_image_height( png_p, info_p );

	if( ipu_debug )
	{
		switch (color_type)
		{
			case PNG_COLOR_TYPE_GRAY:
				bu_log( "color type: b/w (bit depth=%d)\n", bit_depth );
				break;
			case PNG_COLOR_TYPE_GRAY_ALPHA:
				bu_log( "color type: b/w with alpha channel (bit depth=%d)\n", bit_depth );
				break;
			case PNG_COLOR_TYPE_PALETTE:
				bu_log( "color type: color palette (bit depth=%d)\n", bit_depth );
				break;
			case PNG_COLOR_TYPE_RGB:
				bu_log( "color type: RGB (bit depth=%d)\n", bit_depth );
				break;
			case PNG_COLOR_TYPE_RGB_ALPHA:
				bu_log( "color type: RGB with alpha channel (bit depth=%d)\n", bit_depth );
				break;
			default:
				bu_log( "Unrecognized color type (bit depth=%d)\n", bit_depth );
				break;
		}
		bu_log( "Image size: %d X %d\n", file_width, file_height );
	}

	if( png_get_bKGD( png_p, info_p, &input_backgrd ) )
	{
		if( ipu_debug && (color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
				color_type == PNG_COLOR_TYPE_RGB_ALPHA ) )
			bu_log( "background color: %d %d %d\n", input_backgrd->red, input_backgrd->green, input_backgrd->blue );
		png_set_background( png_p, input_backgrd, PNG_BACKGROUND_GAMMA_FILE, 1, 1.0 );
	}
	else
		png_set_background( png_p, &def_backgrd, PNG_BACKGROUND_GAMMA_FILE, 0, 1.0 );

	if( !png_get_gAMA( png_p, info_p, &gamma ) )
		gamma = 0.5;
	png_set_gamma( png_p, def_screen_gamma, gamma );
	if( ipu_debug )
		bu_log( "file gamma: %f, additional screen gamma: %f\n",
			gamma, def_screen_gamma );

	if( ipu_debug )
	{
		if( png_get_interlace_type( png_p, info_p ) == PNG_INTERLACE_NONE )
			bu_log( "not interlaced\n" );
		else
			bu_log( "interlaced\n" );
	}

	png_read_update_info( png_p, info_p );

	/* allocate memory for image */
	image = (unsigned char *)bu_calloc( 1, file_width*file_height*3, "image" );

	/* create rows array */
	scanline = (unsigned char **)bu_calloc( file_height, sizeof( unsigned char *), "scanline" );

	/* Change order top-to-bottom */
	for( i=0 ; i<file_height ; i++ )
		scanline[file_height-1-i] = image+(i*file_width*3);

	png_read_image( png_p, scanline );

	if( ipu_debug )
	{
		png_timep mod_time;
		png_textp text;
		int num_text;

		png_read_end(png_p, info_p );
		if( png_get_text( png_p, info_p, &text, &num_text ) )
		{
			int i;

			for( i=0 ; i<num_text ; i++ )
				bu_log( "%s: %s\n", text[i].key, text[i].text );
		}
		if( png_get_tIME( png_p, info_p, &mod_time ) )
			bu_log( "Last modified: %d/%d/%d %d:%d:%d\n", mod_time->month, mod_time->day,
				mod_time->year, mod_time->hour, mod_time->minute, mod_time->second );
	}

	if (ipu_debug)
		fprintf(stderr, "Image is %dx%d\n", file_width, file_height);

	if (conv == IPU_RESOLUTION) {
		if (scr_width)
			scr_width *= 400.0 / (double)param.i;
		else
			scr_width = file_width * 400.0 / (double)param.i;
		if (scr_height)
			scr_height *= 400.0 / (double)param.i;
		else
			scr_height = file_height * 400.0 / (double)param.i;
	} else if (conv == IPU_MAG_FACTOR) {
		if (scr_width)
			scr_width *= 400.0 / (double)param.i;
		else
			scr_width = file_width * 400.0 / (double)param.i;
		if (scr_height)
			scr_height *= 400.0 / (double)param.i;
		else
			scr_height = file_height * 400.0 / (double)param.i;
	}

	/* Wait for printer to finish what it was doing */
	ipu_acquire(dsp, 120);

	ipu_delete_file(dsp, 1);
	ipu_create_file(dsp, (char)1, ipu_filetype, file_width, file_height, 0);
	ipu_put_image(dsp, (char)1, file_width, file_height, image);

	ipu_print_config(dsp, units, divisor, conv,
			mosaic, ipu_gamma, tray);

	if( ipu_filetype == IPU_PALETTE_FILE )
		ipu_set_palette(dsp, NULL);

	ipu_print_file(dsp, (char)1, copies, 0/*wait*/,
			scr_xoff, scr_yoff, scr_width, scr_height, &param);

	/* Wait for print operation to complete */
	ipu_acquire(dsp, 30 * copies);

	dsclose(dsp);
	return(0);
}

#else
int
main(ac, av)
int ac;
char *av[];
{
	fprintf(stderr,
		"%s only works on SGI(tm) systems with dslib support\n", *av);
	return(-1);
}
#endif
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/canon/png-ipu.c,v 11.9 2004/02/02 17:38:59 morrison Exp $ (BRL)";
@


11.9
log
@update copyright to include span through 2003
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/png-ipu.c,v 11.8 2000/01/31 16:28:51 jra Exp $ (BRL)";
d51 5
a55 1
#include "conf.h"
@


11.8
log
@Eliminated some unused variables
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992 by the United States Army.
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/png-ipu.c,v 11.7 1998/12/29 00:33:07 mike Exp $ (BRL)";
@


11.8.6.1
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d48 1
a48 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.8.8.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/canon/png-ipu.c,v 11.9 2004/02/02 17:38:59 morrison Exp $ (BRL)";
@


11.8.14.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/png-ipu.c,v 11.9 2004/02/02 17:38:59 morrison Exp $ (BRL)";
@


11.8.14.2
log
@merge from head
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/png-ipu.c,v 11.8.14.1 2004/02/12 19:40:42 erikg Exp $ (BRL)";
@


11.7
log
@Fixed up to compile on IRIX 6
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/png-ipu.c,v 11.6 1998/11/21 03:45:16 mike Exp $ (BRL)";
a110 1
	u_char	*img_buffer = (u_char *)NULL;
@


11.6
log
@Made image come out right-side-up.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/png-ipu.c,v 11.5 1998/10/27 20:28:10 mike Exp $ (BRL)";
d87 1
a87 1
#if defined(IRIX) && (IRIX == 4 || IRIX == 5)
a111 1
	int	img_bytes;
d262 1
a262 1
		fprintf(stderr, "Image is %dx%d (%d)\n", file_width, file_height, img_bytes);
@


11.5
log
@Created png-ipu
Fixed minor aspect ratio problem in pix-ipu.c
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/png-ipu.c,v 11.4 1996/05/08 04:04:34 mike Exp $ (BRL)";
d236 2
d239 1
a239 1
		scanline[i] = image+(i*file_width*3);
@


11.4
log
@Whoops, one advantage of fread() is that it didn't balk on pipes.
Changed read() to mread(), which retains the efficiency of a
direct read() by avoiding a buffer copy, but can handle the
sys-call re-issue needed when reading from pipes.
@
text
@d2 7
a8 2
 *			P I X - I P U . C
 *  Author -
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 11.3 1996/05/04 00:46:57 mike Exp mike $ (BRL)";
d59 4
d93 6
d114 11
a137 3
	} else if (autosize &&
	    !fb_common_file_size( &width, &height, av[arg_index], ipu_bytes_per_pixel)) {
	    	fprintf(stderr, "unable to autosize\n");
a139 9
	/* get a buffer for the image */
	img_bytes = width * height * ipu_bytes_per_pixel;

	if ( ! (img_buffer=(u_char*)malloc(img_bytes)) ) {
		(void)fprintf(stderr,
			"Cannot allocate memory for %d by %d image\n",
			width, height);
		return(-1);
	}
d147 104
a250 2
	if (ipu_debug)
		fprintf(stderr, "Image is %dx%d (%d)\n", width, height, img_bytes);
d252 6
a257 4
	/* bring the image into memory */
	if ((i=mread(0, &img_buffer[0], img_bytes)) != img_bytes) {
		(void)fprintf(stderr, "%s: Error reading image at %d of %d bytes read\n", progname, i, img_bytes);
		return(-1);
d260 3
d267 1
a267 1
			scr_width = width * 400.0 / (double)param.i;
d271 1
a271 1
			scr_height = width * 400.0 / (double)param.i;
d276 1
a276 1
			scr_width = width * 400.0 / (double)param.i;
d280 1
a280 1
			scr_height = width * 400.0 / (double)param.i;
d287 2
a288 2
	ipu_create_file(dsp, (char)1, ipu_filetype, width, height, 0);
	ipu_put_image(dsp, (char)1, width, height, img_buffer);
d296 1
a296 2
	if (!strcmp(progname, "pix-ipu"))
		ipu_print_file(dsp, (char)1, copies, 0/*wait*/,
@


11.3
log
@Changed to not use fread() on entire file, saves a buffer copy.
Changed to initialize palette in 8-bit mode.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 11.2 1996/01/25 00:32:31 mike Exp mike $ (BRL)";
d55 23
d137 1
a137 1
	if ((i=read(0, &img_buffer[0], img_bytes)) != img_bytes) {
@


11.2
log
@Added support for -#1 command line option,
for monochrome images.
Isn't very useful until a library routine is written to set the IPU's
color map.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/canon/RCS/pix-ipu.c,v 11.1 1995/01/04 10:35:45 mike Rel4_4 mike $ (BRL)";
d114 2
a115 2
	if ((i=fread(&img_buffer[0], 1, img_bytes, stdin)) != img_bytes) {
		(void)fprintf(stderr, "%s: Error reading image %d of %d bytes read\n", progname, i, img_bytes);
d148 3
@


11.1
log
@Release_4.4
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.7 94/12/01 18:59:35 mike Exp $ (BRL)";
d90 1
a90 1
	    !fb_common_file_size( &width, &height, av[arg_index], 3)) {
d95 1
a95 1
	img_bytes = width * height * 3;
d143 1
a143 1
	ipu_create_file(dsp, (char)1, IPU_RGB_FILE, width, height, 0);
@


1.7
log
@Used more specific #if to tell if the Direct SCSI support exists or not.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.6 94/11/14 23:37:45 mike Exp Locker: mike $ (BRL)";
@


1.6
log
@Irix 6
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.5 94/11/07 23:55:48 mike Exp Locker: mike $ (BRL)";
d55 1
a55 1
#if defined(__sgi) || defined(sgi)
@


1.5
log
@Changed from extern gamma to extern ipu_gamma, to avoid conflict
with gamma() function in math.h.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.4 94/08/24 14:30:11 gdurf Exp Locker: mike $ (BRL)";
a74 1
	FILE	*image_file;
@


1.4
log
@Factored ifdefs
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.3 1994/08/24 14:29:36 gdurf Exp gdurf $ (BRL)";
d148 1
a148 1
			mosaic, gamma, tray);
@


1.3
log
@Changes by butler
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/canon/RCS/pix-ipu.c,v 1.2 92/05/13 06:08:03 butler Exp Locker: butler $ (BRL)";
d46 2
d49 1
d51 4
@


1.2
log
@made timeout on printing proportional to # of copies being printed
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/pix-ipu.c,v 1.1 92/05/12 19:12:12 butler Exp Locker: butler $ (BRL)";
d46 3
a50 1
#include <stdio.h>
a51 2
#include <string.h>
#ifdef __sgi
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /n/wolf/d/butler/printer/RCS/pix-ipu.c,v 1.3 92/05/01 02:49:32 butler Exp Locker: butler $ (BRL)";
d148 1
a148 1
	ipu_acquire(dsp, 120);
@
