head	11.12;
access;
symbols
	ansi-20040405-merged:11.9.6.1
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.14.2
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.8.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.14
	phong-branch:11.9.0.12
	photonmap-branch:11.9.0.10
	rel-6-1-DP:11.9
	windows-branch:11.9.0.8
	rel-6-0-2:11.9
	ansi-branch:11.9.0.6
	rel-6-0-1-branch:11.9.0.4
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.9
	offsite-5-3-pre:11.9
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.8
	rel-5-0-beta:11.8
	rel-4-5:11.7
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.24.04.16.47;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.38.59;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2000.01.31.16.28.51;	author jra;	state Exp;
branches
	11.9.6.1
	11.9.8.1
	11.9.14.1;
next	11.8;

11.8
date	98.12.29.00.33.06;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.12.20.20.06.11;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.09.17.22.34.19;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.12.28.05.04.06;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.12.28.03.37.30;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.12.28.02.49.55;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.28.00.19.13;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.35.44;	author mike;	state Rel4_4;
branches;
next	1.5;

1.5
date	94.12.01.18.59.37;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.11.23.22.14.47;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.11.23.22.05.30;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	94.11.23.21.52.40;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	94.11.23.21.39.53;	author mike;	state Exp;
branches;
next	;

11.9.6.1
date	2004.03.17.21.15.53;	author morrison;	state Exp;
branches;
next	;

11.9.8.1
date	2004.03.11.23.40.28;	author morrison;	state Exp;
branches;
next	;

11.9.14.1
date	2004.02.12.19.40.42;	author erikg;	state Exp;
branches;
next	11.9.14.2;

11.9.14.2
date	2004.03.15.14.06.06;	author erikg;	state Exp;
branches;
next	;


desc
@Canon CLC-500 IPU to PIX program.
@


11.12
log
@moved to src/canon/
@
text
@/*	
 *			 I P U S C A N
 *
 *  Obtain a BRL-CAD .pix file from the Canon CLC-500 scanner glass.
 *
 *	Options
 *	h	help
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/canon/ipuscan.c,v 11.11 2004/05/10 15:30:41 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"

#if defined(IRIX) && (IRIX == 4 || IRIX == 5 || IRIX == 6)
#include "./canon.h"

# define _SGI_SOURCE	1	/* IRIX 5.0.1 needs this to def M_BLKSZ */
# define _BSD_TYPES	1	/* IRIX 5.0.1 botch in sys/prctl.h */
# include <sys/types.h>
# include <ulocks.h>
/* ulocks.h #include's <limits.h> and <malloc.h> */
/* ulocks.h #include's <task.h> for getpid stuff */
/* task.h #include's <sys/prctl.h> */
# include <malloc.h>
/* <malloc.h> #include's <stddef.h> */

#include "./chore.h"

static 	struct dsreq *dsp;
static	int	fd;

struct chore	chores[3];

struct chore	*await1;
struct chore	*await2;
struct chore	*await3;

void step1(aa)
void	*aa;
{
	struct chore	*chorep;
	int		pix_y;
	int		canon_y;
	static int	nstarted = 0;

	pix_y = 0;
	for(;;)  {
		if( nstarted < 3 )  {
			chorep = &chores[nstarted++];
		} else {
			GET( chorep, await1 );
		}

		if( pix_y >= height )  {
			/* Send through a "done" chore and exit */
			chorep->pix_y = -1;
			PUT( await2, chorep );
			/* Wait for them to percolate through */
			GET( chorep, await1 );
			GET( chorep, await1 );
			break;
		}

		chorep->pix_y = pix_y;
		chorep->todo = 255*1024 / (ipu_bytes_per_pixel*width);	/* Limit 255 Kbytes */
		if( height - pix_y < chorep->todo )  chorep->todo = height - pix_y;
		chorep->buflen = chorep->todo * ipu_bytes_per_pixel * width;

		canon_y = height - (pix_y+chorep->todo);

		chorep->cbuf = ipu_get_image(dsp, 1, 0, canon_y, width, chorep->todo);
		pix_y += chorep->todo;

		/* Pass this chore off to next process */
		PUT( await2, chorep );
	}
	exit(0);	/* exit this thread */
}

void step2(aa)
void	*aa;
{
	struct chore	*chorep;
	register unsigned char	*cp;
	unsigned char *green, *blue;
	int	buf_y;

	for(;;)  {
		GET(chorep, await2);
		if( chorep->pix_y < 0 )  {
			/* Pass on "done" token and exit */
			PUT( await3, chorep );
			break;
		}

		cp = chorep->obuf;

		if( ipu_bytes_per_pixel == 3 )  {
			green = &chorep->cbuf[width*chorep->todo];
			blue = &chorep->cbuf[width*chorep->todo*2];

			for( buf_y = chorep->todo-1; buf_y >= 0; buf_y-- )  {
				int	offset;
				register unsigned char	*rp, *gp, *bp;
				register int		x;

				offset = buf_y * width;
				rp = &chorep->cbuf[offset];
				gp = &green[offset];
				bp = &blue[offset];
				for( x = width-1; x >= 0; x-- )  {
					*cp++ = *rp++;
					*cp++ = *gp++;
					*cp++ = *bp++;
				}
				chorep->pix_y++;	/* Record our progress */
			}
		} else {
			/* Monochrome */
			for( buf_y = chorep->todo-1; buf_y >= 0; buf_y-- )  {
				int	offset;
				register unsigned char	*rp;
					offset = buf_y * width;
				rp = &chorep->cbuf[offset];
				bcopy( rp, cp, width );
				cp += width;
				chorep->pix_y++;	/* Record our progress */
			}
		}
		PUT( await3, chorep );
	}
	exit(0);
}

/*
 *  While this step looks innocuous, if the file is located on a slow
 *  or busy disk drive or (worse yet) is on an NFS partition,
 *  this can take a long time.
 */
void step3(aa)
void	*aa;
{
	struct chore	*chorep;

	for(;;)  {
		GET( chorep, await3 );
		if( chorep->pix_y < 0 )  {
			break;	/* "done" token */
		}

		if( write( fd, chorep->obuf, chorep->buflen ) != chorep->buflen )  {
			perror("ipuscan write");
			fprintf(stderr, "buffer write error, line %d\n", chorep->pix_y);
			exit(2);
		}
		(void)free(chorep->cbuf);
		chorep->cbuf = NULL;
		PUT( await1, chorep );
	}
	exit(0);
}


/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(ac,av)
int ac;
char *av[];
{
	int arg_index;
	int i;
	int	pid[3];

	/* pick the LUN for the scanner this time */
	(void)strncpy( scsi_device, "/dev/scsi/sc0d6l0", 1024 );

	/* parse command flags, and make sure there are arguments
	 * left over for processing.
	 */
	if ((arg_index = parse_args(ac, av)) < ac) {
		if ((fd=creat(av[arg_index], 0444)) == -1) {
			perror(av[arg_index]);
			(void)fprintf(stderr, "%s: ", progname);
			return(-1);
		}
	} else if (isatty(fileno(stdout))) {
		usage("Cannot scan to tty\n");
	} else
		fd = fileno(stdout);

	if ((dsp = dsopen(scsi_device, O_RDWR)) == NULL) {
		perror(scsi_device);
		usage("Cannot open SCSI device\n");
	}

	if (ipu_debug)
		fprintf(stderr, "%s\n", ipu_inquire(dsp));

	ipu_remote(dsp);
	ipu_delete_file(dsp, 1);
	/* Don't bother clearing memory, it takes too long */
	ipu_create_file(dsp, 1, ipu_filetype, width, height, 0);
	ipu_scan_config(dsp,units,divisor,conv,0,0);

	if (conv == IPU_AUTOSCALE)
		ipu_scan_file(dsp,1/*id*/,
				0/*wait*/,0,0,0,0,&param);
	else
		ipu_scan_file(dsp,1/*id*/,
				0/*wait*/,scr_xoff,scr_yoff,
				width,height,&param);

	ipu_acquire(dsp, 30);

	if (ipu_debug)
		fprintf(stderr, "%s\n", ipu_list_files(dsp));



	/* Start three threads, then wait for them to finish */
	pid[0] = sproc( step1, PR_SALL|PR_SFDS );
	pid[1] = sproc( step2, PR_SALL|PR_SFDS );
	pid[2] = sproc( step3, PR_SALL|PR_SFDS );

	for( i=0; i<3; i++ )  {
		int	this_pid;
		int	pstat;
		int	j;

		pstat = 0;
		if( (this_pid = wait(&pstat)) <= 0  )  {
			perror("wait");
			fprintf(stderr, "wait returned %d\n", this_pid);
			for( j=0; j<3; j++) kill(pid[j], 9);
			exit(3);
		}
		if( (pstat & 0xFF) != 0 )  {
			fprintf(stderr, "*** child pid %d blew out with error x%x\n", this_pid, pstat);
			for( j=0; j<3; j++) kill(pid[j], 9);
			exit(4);
		}
	}
	/* All children are finished */

	close(fd);
	(void)dsclose(dsp);
	(void)close(fd);
	(void)chmod(av[arg_index], 0444);
	return(0);
}
#else
int
main(ac, av)
int ac;
char *av[];
{
	fprintf(stderr,
		"%s only works on SGI(tm) systems with dslib support\n", *av);
	return(-1);
}
#endif
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/canon/ipuscan.c,v 11.10 2004/02/02 17:38:59 morrison Exp $ (ARL)";
@


11.10
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/ipuscan.c,v 11.9 2000/01/31 16:28:51 jra Exp $ (ARL)";
d30 5
a34 1
#include "conf.h"
@


11.9
log
@Eliminated some unused variables
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994 by the United States Army
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/ipuscan.c,v 11.8 1998/12/29 00:33:06 mike Exp $ (ARL)";
@


11.9.6.1
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.9.8.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/canon/ipuscan.c,v 11.10 2004/02/02 17:38:59 morrison Exp $ (ARL)";
@


11.9.14.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/ipuscan.c,v 11.10 2004/02/02 17:38:59 morrison Exp $ (ARL)";
@


11.9.14.2
log
@merge from head
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/ipuscan.c,v 11.9.14.1 2004/02/12 19:40:42 erikg Exp $ (ARL)";
@


11.8
log
@Fixed up to compile on IRIX 6
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/canon/ipuscan.c,v 11.7 1996/12/20 20:06:11 butler Exp $ (ARL)";
a56 2
static char		lockfile[] = "/var/tmp/ipuscanXXXXXX";
static usptr_t		*lockstuff = 0;
d116 1
a116 1
	unsigned char *red, *green, *blue;
a153 1
				register int		x;
a206 1
	int	pix_y;
@


11.7
log
@removed gratuitous "bb" parameter from step[123]().
SGI compiler was complaining.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 11.6 1996/09/17 22:34:19 mike Exp butler $ (ARL)";
d45 1
a45 1
#if defined(IRIX) && (IRIX == 4 || IRIX == 5)
@


11.6
log
@Moved data structures out into chore.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/canon/RCS/ipuscan.c,v 11.5 1995/12/28 05:04:06 mike Exp mike $ (ARL)";
d71 1
a71 1
void step1(aa,bb)
a72 1
size_t	bb;
d113 1
a113 1
void step2(aa,bb)
a114 1
size_t	bb;
d174 1
a174 1
void step3(aa,bb)
a175 1
size_t	bb;
@


11.5
log
@This version runs in parallel, using 3 threads.
The main source of delay seems to be the Canon.
The previous version could scan 4400x3400 .pix file in about
3min 7sec realtime, the new version can do it in 2min 26sec.
About a 40 second savings (22% faster).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 11.4 1995/12/28 03:37:30 mike Exp mike $ (ARL)";
d60 1
a64 9
struct chore {
	int	todo;
	int	buflen;
	int	pix_y;
	int	canon_y;
	unsigned char	*cbuf;			/* ptr to canon buffer */
	unsigned char	obuf[255*1024];
};

a69 10

#define GET(item, queue)	{\
	while( queue == NULL )  sginap(1); \
	item = queue; \
	queue = NULL; }

#define PUT(queue, item)	{ \
	while( queue != NULL )  sginap(1); \
	queue = item; \
	item = NULL;  }
@


11.4
log
@Partial conversion to tripple-buffering
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 11.3 1995/12/28 02:49:55 mike Exp mike $ (ARL)";
d48 13
d73 1
a73 1
struct chore	chore1;
d75 17
a91 3
int step1(chorep, pix_y)
struct chore	*chorep;
int		pix_y;
d93 22
a114 1
	int	canon_y;
d116 4
a119 4
	chorep->pix_y = pix_y;
	chorep->todo = 255*1024 / (ipu_bytes_per_pixel*width);	/* Limit 255 Kbytes */
	if( height - pix_y < chorep->todo )  chorep->todo = height - pix_y;
	chorep->buflen = chorep->todo * ipu_bytes_per_pixel * width;
d121 1
a121 1
	canon_y = height - (pix_y+chorep->todo);
d123 2
a124 1
	chorep->cbuf = ipu_get_image(dsp, 1, 0, canon_y, width, chorep->todo);
d126 4
a129 1
	return pix_y + chorep->todo;
d132 3
a134 2
void step2(chorep)
struct chore	*chorep;
d136 1
d141 9
a149 1
	cp = chorep->obuf;
d151 19
a169 17
	if( ipu_bytes_per_pixel == 3 )  {
		green = &chorep->cbuf[width*chorep->todo];
		blue = &chorep->cbuf[width*chorep->todo*2];

		for( buf_y = chorep->todo-1; buf_y >= 0; buf_y-- )  {
			int	offset;
			register unsigned char	*rp, *gp, *bp;
			register int		x;

			offset = buf_y * width;
			rp = &chorep->cbuf[offset];
			gp = &green[offset];
			bp = &blue[offset];
			for( x = width-1; x >= 0; x-- )  {
				*cp++ = *rp++;
				*cp++ = *gp++;
				*cp++ = *bp++;
d171 12
a182 13
			chorep->pix_y++;	/* Record our progress */
		}
	} else {
		/* Monochrome */
		for( buf_y = chorep->todo-1; buf_y >= 0; buf_y-- )  {
			int	offset;
			register unsigned char	*rp;
			register int		x;
				offset = buf_y * width;
			rp = &chorep->cbuf[offset];
			bcopy( rp, cp, width );
			cp += width;
			chorep->pix_y++;	/* Record our progress */
d184 1
d186 1
d194 3
a196 2
void step3(chorep)
struct chore	*chorep;
d198 16
a213 4
	if( write( fd, chorep->obuf, chorep->buflen ) != chorep->buflen )  {
		perror("ipuscan write");
		fprintf(stderr, "buffer write error, line %d\n", chorep->pix_y);
		exit(2);
d215 1
a215 2
	(void)free(chorep->cbuf);
	chorep->cbuf = NULL;
d232 1
d273 1
a273 2
	sleep(15);
	ipu_acquire(dsp, 120);
d278 1
a278 7
	/* SCSI Bus can't do large ones all at once.
	 * Take it in small chunks.
	 * Also, note that the scanner is quadrant IV,
	 * while .pix files are quadrant I.
	 */
	for( pix_y=0; pix_y < height; )  {
		struct chore	*chorep = &chore1;
d280 22
a301 3
		pix_y = step1( chorep, pix_y );
		step2( chorep );
		step3( chorep );
d303 1
@


11.3
log
@Added support for monochrome scans
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 11.2 1995/12/28 00:19:13 mike Exp $ (ARL)";
d48 2
d51 91
a152 3
	unsigned char *red, *green, *blue;
	struct dsreq *dsp;
	int	fd;
a153 1
	int	canon_y;
a154 2
	int	buf_y;
	u_char	obuf[255*1024];
d207 1
a207 39
		register unsigned char	*cp;
		int	todo;	/* # scanlines to do */
		int	buflen;

		todo = 255*1024 / (ipu_bytes_per_pixel*width);	/* Limit 255 Kbytes */
		if( height - pix_y < todo )  todo = height - pix_y;
		buflen = todo * ipu_bytes_per_pixel * width;

		canon_y = height - (pix_y+todo);

		red = ipu_get_image(dsp, 1, 0, canon_y, width, todo);
		cp = obuf;

		if( ipu_bytes_per_pixel == 3 )  {
			green = &red[width*todo];
			blue = &red[width*todo*2];

			for( buf_y = todo-1; buf_y >= 0; buf_y-- )  {
				int	offset;
				register unsigned char	*rp, *gp, *bp;
				register int		x;

				offset = buf_y * width;
				rp = &red[offset];
				gp = &green[offset];
				bp = &blue[offset];
				for( x = width-1; x >= 0; x-- )  {
					*cp++ = *rp++;
					*cp++ = *gp++;
					*cp++ = *bp++;
				}
				pix_y++;	/* Record our progress */
			}
		} else {
			/* Monochrome */
			for( buf_y = todo-1; buf_y >= 0; buf_y-- )  {
				int	offset;
				register unsigned char	*rp;
				register int		x;
d209 3
a211 13
				offset = buf_y * width;
				rp = &red[offset];
				bcopy( rp, cp, width );
				cp += width;
				pix_y++;	/* Record our progress */
			}
		}
		if( write( fd, obuf, buflen ) != buflen )  {
			perror("ipuscan write");
			fprintf(stderr, "buffer write error, line %d\n", pix_y);
			return(-1);
		}
		(void)free(red);
@


11.2
log
@Changed SCSI LUN, so that it works at all.
Some performance enhancements.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 11.1 1995/01/04 10:35:44 mike Rel4_4 $ (ARL)";
d97 1
a97 1
	ipu_create_file(dsp, 1, IPU_RGB_FILE, width, height, 0);
d124 1
a124 1
		todo = 255*1024 / (3*width);	/* Limit 255 Kbytes */
d126 1
a126 1
		buflen = todo * 3 * width;
a130 4

		green = &red[width*todo];
		blue = &red[width*todo*2];

d133 32
a164 13
		for( buf_y = todo-1; buf_y >= 0; buf_y-- )  {
			int	offset;
			register unsigned char	*rp, *gp, *bp;
			register int		x;

			offset = buf_y * width;
			rp = &red[offset];
			gp = &green[offset];
			bp = &blue[offset];
			for( x = width-1; x >= 0; x-- )  {
				*cp++ = *rp++;
				*cp++ = *gp++;
				*cp++ = *bp++;
a165 1
			pix_y++;	/* Record our progress */
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 1.5 94/12/01 18:59:37 mike Exp $ (ARL)";
a63 2
	int bufpos;
	unsigned char	*buf = (unsigned char *)NULL;
d67 1
a67 1
	int	x;
d69 3
d76 2
a77 1
		if ((fd=open(av[arg_index], 0)) < 0) {
a78 1
			perror(av[arg_index]);
d122 1
a124 1
		if( !buf )  buf = (unsigned char *)malloc(todo*3*width);
d126 1
a133 1
		cp = buf;
d135 2
d139 2
d143 7
a149 4
			for( x=0; x < width; x++ )  {
				*cp++ = red[offset+x];
				*cp++ = green[offset+x];
				*cp++ = blue[offset+x];
d153 2
a154 4
		(void)free(red);

		/* Large buffer write */
		if (write(fd, buf, todo*width*3) != todo*width*3) {
d158 1
d161 1
@


1.5
log
@Used more specific #if to tell if the Direct SCSI support exists or not.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 1.4 94/11/23 22:14:47 mike Exp Locker: mike $ (ARL)";
@


1.4
log
@Give the kernel a large write buffer.
This is particularly beneficial on EFS, so it can allocate
a large extent.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 1.3 94/11/23 22:05:30 mike Exp Locker: mike $ (ARL)";
d44 2
d159 11
@


1.3
log
@Modified to use write() not fwrite().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/canon/RCS/ipuscan.c,v 1.2 94/11/23 21:52:40 mike Exp Locker: mike $ (ARL)";
d58 1
a58 1
	u_char *red, *green, *blue;
d63 1
a63 1
	u_char buf[3*10240];
d117 1
d121 1
d130 1
d134 1
a134 2
			register unsigned char	*cp;
			cp = buf;
a140 4
			if (write(fd, buf, width*3) != width*3) {
				fprintf(stderr, "buffer write error, line %d\n", pix_y);
				return(-1);
			}
d144 6
@


1.2
log
@Ported to BRL-CAD compile environment
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d60 1
a60 1
	FILE *fd;
d73 1
a73 1
		if ((fd=fopen(av[arg_index], "w")) == (FILE *)NULL) {
d81 1
a81 1
		fd = stdout;
d139 1
a139 1
			if (fwrite(buf, width*3, 1, fd) != 1) {
d149 1
@


1.1
log
@Initial revision
@
text
@d8 17
d26 7
a32 1
#include <sys/types.h>
d35 2
a36 2
#include <stdio.h>
#include <stdlib.h>
d38 3
a40 1
#include "canon.h"
d42 3
d46 1
a67 3

	/* pick the LUN for the scanner this time */
	scsi_device = "/dev/scsi/sc0d6l0";
@
