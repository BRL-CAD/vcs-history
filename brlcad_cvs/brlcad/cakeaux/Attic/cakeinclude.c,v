head	11.4;
access;
symbols
	ansi-20040405-merged:11.3
	postmerge-20040405-ansi:11.3
	premerge-20040404-ansi:11.3
	postmerge-autoconf:11.3
	autoconf-freeze:11.3
	premerge-autoconf:11.3
	ansi-20040316-freeze:11.3
	postmerge-20040315-windows:11.3
	premerge-20040315-windows:11.3
	windows-20040315-freeze:11.3
	autoconf-20031203:11.3
	autoconf-20031202:11.3
	autoconf-branch:11.3.0.14
	phong-branch:11.3.0.12
	photonmap-branch:11.3.0.10
	rel-6-1-DP:11.3
	windows-branch:11.3.0.8
	rel-6-0-2:11.3
	ansi-branch:11.3.0.6
	rel-6-0-1-branch:11.3.0.4
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.3
	offsite-5-3-pre:11.3
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:1.5
	rel-4-0:1.5;
locks; strict;
comment	@ * @;


11.4
date	2004.05.19.15.45.58;	author morrison;	state dead;
branches;
next	11.3;

11.3
date	97.05.22.02.26.08;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.05.22.02.24.19;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.05.06.03.11;	author mike;	state Rel4_4;
branches;
next	1.5;

1.5
date	91.07.24.20.16.37;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.07.24.20.02.06;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.07.02.04.24.32;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	90.02.27.21.09.13;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.17.14.47.51;	author mike;	state Exp;
branches;
next	;


desc
@cakeinclude.c, program to determine dependencies for CAKE
using BRL-CAD conventions
@


11.4
log
@cake is no more and theres no incentive to maintain it any more so .. buh bye.
@
text
@/*
 *			C A K E I N C L U D E . C
 *  This program lists the names of all header files that a given C source
 *  module includes.  It is intended to be a faster replacement for the
 *  cakeinclude.sh script used for BRL-CAD distributions.
 *  It therefore embodies the same conventions and restrictions.
 *
 *  This program prints the names of all header files that a given
 *  C source module includes.  No attempt is made to deal with
 *  conditional inclusion of header files.
 *
 *  The BRL-CAD convention for writing #include directives is:
 *	#include "./file"	gives file in "current" directory (SRCDIR)
 *	#include "/file"	gives file at absolute path
 *	#include "file"		gives file in ${INCDIR}
 *	#include <file>		leaves to CPP
 *
 *  Note that there must be whitespace between the "#" and the word "include"
 *  to defeat the detection of the include.
 *  This allows conditional includes (if needed) to be indicated
 *  by a # SP include, so as to not cause trouble.
 *
 *  This routine does not handle nested #includes, which is bad style anyway.
 *
 *  Options -
 *	i dir	Specify Include dir
 *	s dir	Specify Source dir
 *	b #	Buffer size
 *	h	help
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/cakeaux/cakeinclude.c,v 11.3 1997/05/22 02:26:08 mike Exp $ (BRL)";
#endif

#include <stdio.h>

/* declarations to support use of getopt() system call */
char *options = "hb:i:s:d";
char optflags[sizeof(options)];
extern char *optarg;
extern int optind, opterr, getopt();

char *progname = "(noname)";
char *malloc(), *realloc();
char *srcdir = ".";
char *incdir = ".";
int status;
unsigned bsize=16384;
FILE *fopen();
int debug = 0;
void get_includes();

/*
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void usage()
{
	(void) fprintf(stderr,
		"Usage: %s [ -s srcdir ] [ -i incdir ] [ -b bufsize ] file\n",
			progname);
	exit(1);
}

/*
 *	P A R S E _ A R G S --- Parse through command line flags
 */
int parse_args(ac, av)
int ac;
char *av[];
{
	int  c;

	progname = *av;
	
	/* turn all the option flags off */
	for (c=strlen(options) ; c-- ; optflags[c] = '\0');
	
	/* Turn off getopt's error messages */
	opterr = 0;

	/* get all the option flags from the command line */
	while ((c=getopt(ac,av,options)) != EOF)
		switch (c) {
		case 'b'	: if ((bsize = atoi(optarg)) < 11)
					usage();
				break;
		case 'i':
			incdir = optarg;
			break;
		case 's':
			srcdir = optarg;
			break;
		case 'd':
			debug = !debug;
			break;
		default		: usage(); break; 
		}

	return(optind);
}

/*	C H K I N C L
 *
 *	check an include statement for suitability
 */
int chkincl(fd, bufpos, eob_cnt_p, buffer, bufsiz)
FILE *fd;
char *buffer;
unsigned *bufsiz;
register int bufpos, *eob_cnt_p;
{
	int k;
	char name[1024];

	/* skip over any white space */
	while (bufpos < *eob_cnt_p &&
	    buffer[bufpos] == ' ' || buffer[bufpos] == '\t')
		bufpos++;

	if (bufpos >= *eob_cnt_p) return(bufpos);

	/* ignore the #include <> format and # include " " format.
	 * we are only interested in lines of the form:
	 * #include "filespec"
	 */
	if (buffer[bufpos++] != '"') return(bufpos);

	/* find end of filename */
label:	for (k = bufpos ;
	     k < *eob_cnt_p && buffer[k] != '"' && buffer[k] != '\n' ;
	     k++)
		;

	if (buffer[k] == '\n')
		return(k);
	else if (k >= *eob_cnt_p) {
		/* we hit the end of the buffer in the middle of an include
		 * statement.  If the buffer wasn't full, we hit EOF and can
		 * just give up.  On the other hand, if the buffer was full,
		 * we should try to extend the buffer and read in the rest
		 * of the include statment
		 */
		if (*eob_cnt_p < (*bufsiz) -1) return(k);
		if ((buffer=realloc(buffer, (*bufsiz)+1024)) == (char *)NULL){
			fprintf(stderr, "%s: Error extending buffer\n",
				progname);
			exit(-1);
		}
		/* read a little more data */
		*bufsiz += 1024;
		while ( *eob_cnt_p < (*bufsiz)-1 && 
		    (status=fread(&buffer[*eob_cnt_p], 1, (*bufsiz)-1-(*eob_cnt_p), fd)) )
			*eob_cnt_p += status;

		goto label;

	}
	else
		buffer[k] = '\0';

	/* ignore the "...debug.h" files */
	if (k-7 >= bufpos && !strncmp("debug.h", &buffer[k-7], 7))
		return(k);

	if (buffer[bufpos] == '.' && buffer[bufpos+1] == '/') {
		(void)printf("%s%s\n", srcdir, &buffer[bufpos+1]);

		if (strlen(srcdir)+strlen(&buffer[bufpos+1]) < sizeof(name)){
			sprintf(name, "%s%s", srcdir, &buffer[bufpos+1]);
			get_includes(name);
		}

	} else if (buffer[bufpos] == '/') {
		(void)printf("%s\n", &buffer[bufpos]);

		if (strlen(&buffer[bufpos]) < sizeof(name)) {
			strcpy(name, &buffer[bufpos]);
			get_includes(name);
		}
	} else {
		(void)printf("%s/%s\n", incdir, &buffer[bufpos]);

		if (strlen(incdir) + strlen(&buffer[bufpos]) < sizeof(name)) {
			sprintf(name, "%s/%s", incdir, &buffer[bufpos]);
			get_includes(name);
		}

	}


	return(k);
}

/*
 *			G E T _ I N C L U D E S
 */
void
get_includes(s)
char *s;
{
	int bufpos, eob, newline;
	char *buffer;
	unsigned bufsiz= bsize;
	FILE *fd, *fopen();

	if ((buffer=malloc(bufsiz)) == (char *)0) {
		fprintf(stderr, "%s: Unable to allocate %u bytes for buffer\n",
			progname, bufsiz);
		exit(-1);
	}

	if (debug)
		(void)fprintf(stderr, "cakeinclude visiting \"%s\"\n", s);

	/* This part might be done in a loop, to match usage message? */

	if ((fd = fopen(s, "r")) == (FILE *)NULL) {
		(void)fprintf(stderr, "%s:  ", progname);
		perror(s);
		exit(-1);
	}

	/* fill buffer */
	for (eob=0 ; eob < bufsiz-1 && 
	    (status=fread(&buffer[eob], 1, bufsiz-1-eob, fd)) ; eob += status)
		;

	if (eob == 0) {
		fprintf(stderr, "%s: Error reading file \"%s\"\n",
				progname, s);
		perror("fread");
		exit(-1);
	}
	
	newline = 1;
	for (bufpos = 0 ; bufpos < eob ; bufpos++) {
		if (newline && !strncmp("#include", &buffer[bufpos], 8))
			bufpos= chkincl(fd, bufpos+8, &eob, buffer, &bufsiz);

		newline = (buffer[bufpos] == '\n');
	}

	(void)fclose(fd);
	if (debug)
		(void)fprintf(stderr, "cakeinclude leaving \"%s\"\n", s);
}


/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(ac,av)
int ac;
char *av[];
{
	int arg_index;
	char *cp;
	char *last_slash=(char *)NULL;

	/* parse command flags, and make sure there are arguments
	 * left over for processing.
	 */
	if ((arg_index = parse_args(ac, av)) >= ac) usage();

	/* if the source file has a path, use that as source directory */
	cp = av[arg_index];
	while( *cp != '\0' )
	{
		if( *cp == '/' )
			last_slash = cp;
		cp++;
	}

	if( last_slash )
	{
		int len;

		len = last_slash - av[arg_index];
		srcdir = (char *)malloc( len + 1 );
		strncpy( srcdir, av[arg_index], len );
		srcdir[len] = '\0';
	}

	if( debug )  {
		if( incdir )  fprintf(stderr, "include dir = '%s'\n", incdir );
		if( srcdir )  fprintf(stderr, "source dir  = '%s'\n", srcdir );
	}

	get_includes(av[arg_index]);
	return(0);
}
@


11.3
log
@identifed log messages.
added void type
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/cakeaux/RCS/cakeinclude.c,v 11.2 1997/05/22 02:24:19 mike Exp mike $ (BRL)";
@


11.2
log
@JRA fix to use full path info
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/cakeaux/RCS/cakeinclude.c,v 11.1 1995/01/05 06:03:11 mike Rel4_4 jra $ (BRL)";
d62 1
d208 1
d224 1
a224 1
		(void)fprintf(stderr, "Visiting \"%s\"\n", s);
d256 1
a256 1
		(void)fprintf(stderr, "leaving \"%s\"\n", s);
@


11.1
log
@Release_4_4
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/cakeaux/RCS/cakeinclude.c,v 1.5 91/07/24 20:16:37 mike Exp $ (BRL)";
d269 2
d276 19
@


1.5
log
@Expanded -d printing
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/cakeaux/RCS/cakeinclude.c,v 1.4 91/07/24 20:02:06 mike Exp $ (BRL)";
@


1.4
log
@Improved error messages
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/cakeaux/RCS/cakeinclude.c,v 1.3 91/07/02 04:24:32 butler Exp $ (BRL)";
d204 3
d274 5
@


1.3
log
@Improvements
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/cakeaux/RCS/cakeinclude.c,v 1.2 90/02/27 21:09:13 mike Exp $ (BRL)";
d224 1
a224 1
		(void)fprintf(stderr, "%s: routine get_includes: ", progname);
d237 1
@


1.2
log
@Changed perror to give filename rather than program name on open failure.
@
text
@d3 2
a4 2
 *
 *  This program is intended to be a faster replacement for the
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: cakeinclude.c,v 1.1 89/10/17 14:47:51 mike Locked $ (BRL)";
d49 1
a49 1
char *options = "hb:i:s:";
d55 1
a55 2
char *buffer, *malloc(), *realloc();
unsigned bufsiz=16384;
d59 3
a61 1
FILE *fd, *fopen();
d68 3
a70 2
	(void) fprintf(stderr, "Usage: %s [ -%s ] file [ file ... ]\n",
			progname, options);
d94 1
a94 1
		case 'b'	: if ((bufsiz = atoi(optarg)) < 11)
d103 3
d116 5
a120 2
int chkincl(j, i)
register int j, *i;
d123 1
d126 3
a128 1
	while (j < *i && buffer[j] == ' ' || buffer[j] == '\t')  j++;
d130 1
a130 1
	if (j >= *i) return(j);
d136 1
a136 1
	if (buffer[j++] != '"') return(j);
d139 3
a141 1
label:	for (k = j ; k < *i && buffer[k] != '"' && buffer[k] != '\n' ; k++)
d146 1
a146 1
	else if (k >= *i) {
d153 2
a154 2
		if (*i < bufsiz-1) return(k);
		if ((buffer=realloc(buffer, bufsiz+1024)) == (char *)NULL) {
d159 5
a163 5
		/* read a little more data */			
		bufsiz += 1024;
		while ( *i < bufsiz-1 && 
		    (status=fread(&buffer[*i], 1, bufsiz-1-(*i), fd)) )
			*i += status;
d172 1
a172 1
	if (k-7 >= j && !strncmp("debug.h", &buffer[k-7], 7))
d175 2
a176 6
	if (buffer[j] == '.' && buffer[j+1] == '/')
		(void)printf("%s%s\n", srcdir, &buffer[j+1]);
	else if (buffer[j] == '/')
		(void)printf("%s\n", &buffer[j]);
	else
		(void)printf("%s/%s\n", incdir, &buffer[j]);
d178 23
d204 2
a205 10

/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(ac,av)
int ac;
char *av[];
d207 4
a210 2
	int arg_index;
	int j, eob, newline;
a211 5
	/* parse command flags, and make sure there are arguments
	 * left over for processing.
	 */
	if ((arg_index = parse_args(ac, av)) >= ac) usage();

d213 1
a213 1
		fprintf(stderr, "%s: Unable to allocate %d bytes for buffer\n",
d218 3
d223 3
a225 2
	if ((fd = fopen(av[arg_index], "r")) == (FILE *)NULL) {
		perror(av[arg_index]);
d236 1
a236 1
				progname, av[arg_index]);
d241 3
a243 3
	for (j = 0 ; j < eob ; j++) {
		if (newline && !strncmp("#include", &buffer[j], 8))
			j = chkincl(j+8, &eob);
d245 1
a245 1
		newline = (buffer[j] == '\n');
d249 24
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d200 1
a200 1
		perror(progname);
@
