head	11.17;
access;
symbols
	rel-4-5:11.15
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.17
date	98.09.22.01.43.11;	author mike;	state dead;
branches;
next	11.16;

11.16
date	98.06.30.22.54.18;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.12.31.08.15.45;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.12.16.06.25.54;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.12.09.04.45.30;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	97.11.25.22.18.44;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	97.06.05.05.05.04;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.05.09.03.25.47;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.05.07.19.26.36;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.12.11.20.22.45;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.08;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.02.25.41;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.10;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.09.27.16.02.20;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.07.06.00.35.20;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.02.17.20.15.53;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.01.05.03.09.13;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.12.16.35.07;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	90.12.08.08.58.11;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.11.01.11.18.10;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.36;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.30.20.40.06;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.04.05.02.02;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.27.16.35.03;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.32.57;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.08.20.05.07.54;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.02.28.18;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.03.19.02.33.28;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.26.05.30.03;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.54.18;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.10.07.14.36;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.58.48;	author mike;	state Rel;
branches;
next	5.6;

5.6
date	87.07.06.15.26.37;	author mike;	state Exp;
branches;
next	5.5;

5.5
date	87.07.02.02.53.47;	author mike;	state Exp;
branches;
next	5.4;

5.4
date	87.06.27.06.46.08;	author phil;	state Exp;
branches;
next	5.3;

5.3
date	87.06.27.03.45.57;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.57.56;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.14.50;	author mike;	state Rel;
branches;
next	4.8;

4.8
date	87.06.13.03.19.45;	author mike;	state Exp;
branches;
next	4.7;

4.7
date	87.06.13.01.38.51;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.04.10.22.49.26;	author mike;	state Exp;
branches;
next	4.5;

4.5
date	87.04.01.04.51.36;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.23.23.48.18;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.17.20.19.00;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.01.38;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.48.29;	author mike;	state Rel1;
branches;
next	1.19;

1.19
date	86.12.24.08.23.29;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	86.12.18.16.01.46;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	86.12.14.17.54.26;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.12.10.03.26.08;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.11.10.21.56.50;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.11.07.02.46.11;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.11.07.01.46.23;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.10.26.17.07.02;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.08.13.11.00.45;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.08.12.05.50.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.08.06.19.59.58;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.07.31.08.28.16;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.07.30.03.56.17;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.07.29.20.22.07;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.07.24.06.05.05;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.07.22.03.53.29;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.07.19.04.38.49;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.07.17.18.33.01;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.06.11.00.13.54;	author mike;	state Exp;
branches;
next	;


desc
@Routines to implement Phong shading, yielding plastic-looking
objects.  Also handles reflection and refraction.
@


11.17
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@/*
 *			P L A S T I C
 *
 *  Notes -
 *	The normals on all surfaces point OUT of the solid.
 *	The incomming light rays point IN.  Thus the sign change.
 *
 *  Authors -
 *	Michael John Muuss
 *	Gary S. Moss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSplastic[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_plastic.c,v 11.16 1998/06/30 22:54:18 mike Exp mike $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "./rdebug.h"
#include "./material.h"
#include "./light.h"

/* Fast approximation to specular term */
#define PHAST_PHONG 1	/* See Graphics Gems IV pg 387 */

/* from view.c */
extern double AmbientIntensity;

/* Local information */
struct phong_specific {
	int	magic;
	int	shine;
	double	wgt_specular;
	double	wgt_diffuse;
	double	transmit;	/* Moss "transparency" */
	double	reflect;	/* Moss "transmission" */
	double	refrac_index;
	double	extinction;
	struct mfuncs *mfp;
};
#define PL_MAGIC	0xbeef00d
#define PL_NULL	((struct phong_specific *)0)
#define PL_O(m)	offsetof(struct phong_specific, m)

struct bu_structparse phong_parse[] = {
	{"%d",	1, "shine",		PL_O(shine),		FUNC_NULL },
	{"%d",	1, "sh",		PL_O(shine),		FUNC_NULL },
	{"%f",	1, "specular",		PL_O(wgt_specular),	FUNC_NULL },
	{"%f",	1, "sp",		PL_O(wgt_specular),	FUNC_NULL },
	{"%f",	1, "diffuse",		PL_O(wgt_diffuse),	FUNC_NULL },
	{"%f",	1, "di",		PL_O(wgt_diffuse),	FUNC_NULL },
	{"%f",	1, "transmit",		PL_O(transmit),		FUNC_NULL },
	{"%f",	1, "tr",		PL_O(transmit),		FUNC_NULL },
	{"%f",	1, "reflect",		PL_O(reflect),		FUNC_NULL },
	{"%f",	1, "re",		PL_O(reflect),		FUNC_NULL },
	{"%f",	1, "ri",		PL_O(refrac_index),	FUNC_NULL },
	{"%f",	1, "extinction_per_meter", PL_O(extinction),	FUNC_NULL },
	{"%f",	1, "extinction",	PL_O(extinction),	FUNC_NULL },
	{"%f",	1, "ex",		PL_O(extinction),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
};

HIDDEN int phong_setup(), mirror_setup(), glass_setup();
HIDDEN int phong_render();
HIDDEN void	phong_print();
HIDDEN void	phong_free();

/* This can't be CONST, so the forward link can be written later */
struct mfuncs phg_mfuncs[] = {
	{MF_MAGIC,	"default",	0,		MFI_NORMAL,	0,
	phong_setup,	phong_render,	phong_print,	phong_free },

	{MF_MAGIC,	"plastic",	0,		MFI_NORMAL,	0,
	phong_setup,	phong_render,	phong_print,	phong_free },

	{MF_MAGIC,	"mirror",	0,		MFI_NORMAL,	0,
	mirror_setup,	phong_render,	phong_print,	phong_free },

	{MF_MAGIC,	"glass",	0,		MFI_NORMAL,	0,
	glass_setup,	phong_render,	phong_print,	phong_free },

	{0,		(char *)0,	0,		0,	0,
	0,		0,		0,		0 }
};

#ifndef PHAST_PHONG
extern double phg_ipow();
#endif

#define RI_AIR		1.0    /* Refractive index of air.		*/

/*
 *			P H O N G _ S E T U P
 */
HIDDEN int
phong_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct rt_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
{
	register struct phong_specific *pp;

	RT_VLS_CHECK( matparm );
	GETSTRUCT( pp, phong_specific );
	*dpp = (char *)pp;

	pp->magic = PL_MAGIC;
	pp->shine = 10;
	pp->wgt_specular = 0.7;
	pp->wgt_diffuse = 0.3;
	pp->transmit = 0.0;
	pp->reflect = 0.0;
	pp->refrac_index = RI_AIR;
	pp->extinction = 0.0;
	pp->mfp = mfp;

	if( bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
		rt_free( (char *)pp, "phong_specific" );
		return(-1);
	}

	if( pp->transmit > 0 )
		rp->reg_transmit = 1;
	return(1);
}

/*
 *			M I R R O R _ S E T U P
 */
HIDDEN int
mirror_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct rt_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
{
	register struct phong_specific *pp;

	RT_VLS_CHECK( matparm );
	GETSTRUCT( pp, phong_specific );
	*dpp = (char *)pp;

	pp->magic = PL_MAGIC;
	pp->shine = 4;
	pp->wgt_specular = 0.6;
	pp->wgt_diffuse = 0.4;
	pp->transmit = 0.0;
	pp->reflect = 0.75;
	pp->refrac_index = 1.65;
	pp->extinction = 0.0;
	pp->mfp = mfp;

	if( bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
		rt_free( (char *)pp, "phong_specific" );
		return(-1);
	}

	if( pp->transmit > 0 )
		rp->reg_transmit = 1;
	return(1);
}

/*
 *			G L A S S _ S E T U P
 */
HIDDEN int
glass_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct rt_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
{
	register struct phong_specific *pp;

	RT_VLS_CHECK( matparm );
	GETSTRUCT( pp, phong_specific );
	*dpp = (char *)pp;

	pp->magic = PL_MAGIC;
	pp->shine = 4;
	pp->wgt_specular = 0.7;
	pp->wgt_diffuse = 0.3;
	pp->transmit = 0.8;
	pp->reflect = 0.1;
	/* leaving 0.1 for diffuse/specular */
	pp->refrac_index = 1.65;
	pp->extinction = 0.0;
	pp->mfp = mfp;

	if( bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
		rt_free( (char *)pp, "phong_specific" );
		return(-1);
	}

	if( pp->transmit > 0 )
		rp->reg_transmit = 1;
	return(1);
}

/*
 *			P H O N G _ P R I N T
 */
HIDDEN void
phong_print( rp, dp )
register struct region *rp;
char	*dp;
{
	bu_struct_print(rp->reg_name, phong_parse, (char *)dp);
}

/*
 *			P H O N G _ F R E E
 */
HIDDEN void
phong_free( cp )
char *cp;
{
	rt_free( cp, "phong_specific" );
}


/*
 *			P H O N G _ R E N D E R
 *
	Color pixel based on the energy of a point light source (Eps)
	plus some diffuse illumination (Epd) reflected from the point
	<x,y> :

				E = Epd + Eps		(1)

	The energy reflected from diffuse illumination is the product
	of the reflectance coefficient at point P (Rp) and the diffuse
	illumination (Id) :

				Epd = Rp * Id		(2)

	The energy reflected from the point light source is calculated
	by the sum of the diffuse reflectance (Rd) and the specular
	reflectance (Rs), multiplied by the intensity of the light
	source (Ips) :

				Eps = (Rd + Rs) * Ips	(3)

	The diffuse reflectance is calculated by the product of the
	reflectance coefficient (Rp) and the cosine of the angle of
	incidence (I) :

				Rd = Rp * cos(I)	(4)

	The specular reflectance is calculated by the product of the
	specular reflectance coeffient and (the cosine of the angle (S)
	raised to the nth power) :

				Rs = W(I) * cos(S)**n	(5)

	Where,
		I is the angle of incidence.
		S is the angle between the reflected ray and the observer.
		W returns the specular reflection coefficient as a function
	of the angle of incidence.
		n (roughly 1 to 10) represents the shininess of the surface.
 *
	This is the heart of the lighting model which is based on a model
	developed by Bui-Tuong Phong, [see Wm M. Newman and R. F. Sproull,
	"Principles of Interactive Computer Graphics", 	McGraw-Hill, 1979]

	Er = Ra(m)*cos(Ia) + Rd(m)*cos(I1) + W(I1,m)*cos(s)^^n
	where,
 
	Er	is the energy reflected in the observer's direction.
	Ra	is the diffuse reflectance coefficient at the point
		of intersection due to ambient lighting.
	Ia	is the angle of incidence associated with the ambient
		light source (angle between ray direction (negated) and
		surface normal).
	Rd	is the diffuse reflectance coefficient at the point
		of intersection due to primary lighting.
	I1	is the angle of incidence associated with the primary
		light source (angle between light source direction and
		surface normal).
	m	is the material identification code.
	W	is the specular reflectance coefficient,
		a function of the angle of incidence, range 0.0 to 1.0,
		for the material.
	s	is the angle between the reflected ray and the observer.
	n	'Shininess' of the material,  range 1 to 10.
 */
HIDDEN int
phong_render( ap, pp, swp, dp )
register struct application *ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
{
	register struct light_specific *lp;
	register fastf_t *intensity, *to_light;
	register int	i;
	register fastf_t cosine;
	register fastf_t refl;
	vect_t	work;
	vect_t	reflected;
	vect_t	cprod;			/* color product */
	point_t	matcolor;		/* Material color */
	struct phong_specific *ps =
		(struct phong_specific *)dp;

	if( ps->magic != PL_MAGIC )  rt_log("phong_render: bad magic\n");

	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "phong_render", phong_parse, (char *)ps );

	swp->sw_transmit = ps->transmit;
	swp->sw_reflect = ps->reflect;
	swp->sw_refrac_index = ps->refrac_index;
	swp->sw_extinction = ps->extinction;
	if( swp->sw_xmitonly ) {
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 ) {
			if( rdebug&RDEBUG_SHADE)
				bu_log("calling rr_render from phong, sw_xmitonly\n");
			(void)rr_render( ap, pp, swp );
		}
		return(1);	/* done */
	}

	VMOVE( matcolor, swp->sw_color );

	/* Diffuse reflectance from "Ambient" light source (at eye) */
	if( (cosine = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )) > 0.0 )  {
		if( cosine > 1.00001 )  {
			rt_log("cosAmb=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
				ap->a_x, ap->a_y, ap->a_level);
			cosine = 1;
		}
		cosine *= AmbientIntensity;
		VSCALE( swp->sw_color, matcolor, cosine );
	} else {
		VSETALL( swp->sw_color, 0 );
	}

	/* With the advent of procedural shaders, the caller can no longer
	 * provide us reliable light visibility information.  The hit point
	 * may have been changed by another shader in a stack.  There is no
	 * way that anyone else can tell us whether lights are visible.
	 */
	light_visibility(ap, swp, ps->mfp->mf_inputs);

	/* Consider effects of each light source */
	for( i=ap->a_rt_i->rti_nlights-1; i>=0; i-- )  {

		if( (lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
			continue;
	
		/* Light is not shadowed -- add this contribution */
		intensity = swp->sw_intensity+3*i;
		to_light = swp->sw_tolight+3*i;

		/* Diffuse reflectance from this light source. */
		if( (cosine = VDOT( swp->sw_hit.hit_normal, to_light )) > 0.0 )  {
			if( cosine > 1.00001 )  {
				rt_log("cosI=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
					ap->a_x, ap->a_y, ap->a_level);
				cosine = 1;
			}
			refl = cosine * lp->lt_fraction * ps->wgt_diffuse;
			VELMUL( work, lp->lt_color,
				intensity );
			VELMUL( cprod, matcolor, work );
			VJOIN1( swp->sw_color, swp->sw_color,
				refl, cprod );
		}

		/* Calculate specular reflectance.
		 *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
		 * 	Cos(s) = Reflected ray DOT Incident ray.
		 */
		cosine *= 2;
		VSCALE( work, swp->sw_hit.hit_normal, cosine );
		VSUB2( reflected, work, to_light );
		if( (cosine = -VDOT( reflected, ap->a_ray.r_dir )) > 0 )  {
			if( cosine > 1.00001 )  {
				rt_log("cosS=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
					ap->a_x, ap->a_y, ap->a_level);
				cosine = 1;
			}
			refl = ps->wgt_specular * lp->lt_fraction *
#ifdef PHAST_PHONG
				/* It is unnecessary to compute the actual
				 * exponential here since phong is just a
				 * gross hack.  We approximate re:
				 *  Graphics Gems IV "A Fast Alternative to
				 *  Phong's Specular Model" Pg 385
				 */
				cosine /
				(ps->shine - ps->shine*cosine + cosine);
#else
				phg_ipow(cosine, ps->shine);
#endif
			VELMUL( work, lp->lt_color,
				intensity );
			VJOIN1( swp->sw_color, swp->sw_color,
				refl, work );
		}
	}
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
	return(1);
}

#ifndef PHAST_PHONG
/*
 *  			I P O W
 *  
 *  Raise a floating point number to an integer power
 */
double
phg_ipow( d, cnt )
double d;
register int cnt;
{
	FAST fastf_t input, result;

	if( (input=d) < 1e-8 )  return(0.0);
	if( cnt < 0 || cnt > 200 )  {
		rt_log("phg_ipow(%g,%d) bad\n", d, cnt);
		return(d);
	}
	result = 1;
	while( cnt-- > 0 )
		result *= input;
	return( result );
}
#endif
@


11.16
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_plastic.c,v 11.15 1997/12/31 09:01:40 mike Exp $ (BRL)";
@


11.15
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.14 1997/12/31 08:15:45 mike Exp mike $ (BRL)";
d82 2
a83 1
CONST struct mfuncs phg_mfuncs[] = {
@


11.14
log
@Initialized magic numbers
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.13 1997/12/16 06:25:54 mike Exp mike $ (BRL)";
d82 2
a83 2
struct mfuncs phg_mfuncs[] = {
	{"default",	MF_MAGIC,	0,		MFI_NORMAL,	0,
d86 1
a86 1
	{"plastic",	MF_MAGIC,	0,		MFI_NORMAL,	0,
d89 1
a89 1
	{"mirror",	MF_MAGIC,	0,		MFI_NORMAL,	0,
d92 1
a92 1
	{"glass",	MF_MAGIC,	0,		MFI_NORMAL,	0,
d95 1
a95 1
	{(char *)0,	0,		0,		0,	0,
@


11.13
log
@Made debugging message conditional on RDEBUG_SHADE
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.12 1997/12/09 04:45:30 butler Exp mike $ (BRL)";
d83 1
a83 1
	{"default",	0,		0,		MFI_NORMAL,	0,
d86 1
a86 1
	{"plastic",	0,		0,		MFI_NORMAL,	0,
d89 1
a89 1
	{"mirror",	0,		0,		MFI_NORMAL,	0,
d92 1
a92 1
	{"glass",	0,		0,		MFI_NORMAL,	0,
@


11.12
log
@has to do it's own light visibility calculations now.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.11 1997/11/25 22:18:44 butler Exp butler $ (BRL)";
d335 2
a336 1
			bu_log("calling rr_render from phong\n");
@


11.11
log
@fixed typo
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.10 1997/11/25 22:16:43 butler Exp butler $ (BRL)";
d53 1
d83 1
a83 1
	{"default",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d86 1
a86 1
	{"plastic",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d89 1
a89 1
	{"mirror",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d92 1
a92 1
	{"glass",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d130 1
d167 1
d205 1
d334 2
a335 1
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d337 1
d355 7
@


11.10
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.9 1997/06/05 05:05:04 butler Exp butler $ (BRL)";
a183 1
{
d186 1
@


11.9
log
@Christophe Shlick's fast approximation to phong specular term
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.8 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d108 1
a108 1
phong_setup( rp, matparm, dpp )
d112 2
d144 1
a144 1
mirror_setup( rp, matparm, dpp )
d148 2
d180 1
a180 1
glass_setup( rp, matparm, dpp )
d185 2
@


11.8
log
@bu_struct_print
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.7 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d37 3
d98 1
d100 1
d383 10
d394 1
d406 1
d429 1
@


11.7
log
@bu_struct_parse
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.6 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d210 1
a210 1
	bu_structprint(rp->reg_name, phong_parse, (char *)dp);
d312 1
a312 1
		bu_structprint( "phong_render", phong_parse, (char *)ps );
@


11.6
log
@structparse moved to libbu
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.5 1996/05/09 03:25:47 butler Exp butler $ (BRL)";
d123 1
a123 1
	if( bu_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d157 1
a157 1
	if( bu_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d192 1
a192 1
	if( bu_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
@


11.5
log
@nit picking.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.4 1996/05/07 19:26:36 jra Exp butler $ (BRL)";
d55 1
a55 1
struct structparse phong_parse[] = {
d123 1
a123 1
	if( rt_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d157 1
a157 1
	if( rt_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d192 1
a192 1
	if( rt_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d210 1
a210 1
	rt_structprint(rp->reg_name, phong_parse, (char *)dp);
d312 1
a312 1
		rt_structprint( "phong_render", phong_parse, (char *)ps );
@


11.4
log
@Individual shaders now call rr_render() directly.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.3 1995/12/11 20:22:45 jra Exp jra $ (BRL)";
d318 1
a318 2
	if( swp->sw_xmitonly )
	{
@


11.3
log
@Added a debug message.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.2 1995/10/20 04:43:53 butler Exp jra $ (BRL)";
d318 6
a323 1
	if( swp->sw_xmitonly )  return(1);	/* done */
d386 2
@


11.2
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.1 1995/01/04 10:01:08 mike Rel4_4 butler $ (BRL)";
d310 3
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 10.2 94/08/11 02:25:41 gdurf Exp $ (BRL)";
d79 1
a79 1
	{"default",	0,		0,		MFI_NORMAL|MFI_LIGHT,
d82 1
a82 1
	{"plastic",	0,		0,		MFI_NORMAL|MFI_LIGHT,
d85 1
a85 1
	{"mirror",	0,		0,		MFI_NORMAL|MFI_LIGHT,
d88 1
a88 1
	{"glass",	0,		0,		MFI_NORMAL|MFI_LIGHT,
d91 1
a91 1
	{(char *)0,	0,		0,		0,
@


10.2
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 10.1 1991/10/12 06:42:10 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.8 91/09/27 16:02:20 mike Exp $ (BRL)";
d24 2
@


9.8
log
@Made extintion more specific
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.7 91/07/06 00:35:20 mike Exp Locker: mike $ (BRL)";
@


9.7
log
@ANSI structure initialization
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.6 91/02/17 20:15:53 mike Exp $ (BRL)";
d65 1
@


9.6
log
@Check return code from rt_structparse()
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.5 91/01/05 03:09:13 mike Exp $ (BRL)";
d54 14
a67 14
	"%d",	1, "shine",		PL_O(shine),		FUNC_NULL,
	"%d",	1, "sh",		PL_O(shine),		FUNC_NULL,
	"%f",	1, "specular",		PL_O(wgt_specular),	FUNC_NULL,
	"%f",	1, "sp",		PL_O(wgt_specular),	FUNC_NULL,
	"%f",	1, "diffuse",		PL_O(wgt_diffuse),	FUNC_NULL,
	"%f",	1, "di",		PL_O(wgt_diffuse),	FUNC_NULL,
	"%f",	1, "transmit",		PL_O(transmit),		FUNC_NULL,
	"%f",	1, "tr",		PL_O(transmit),		FUNC_NULL,
	"%f",	1, "reflect",		PL_O(reflect),		FUNC_NULL,
	"%f",	1, "re",		PL_O(reflect),		FUNC_NULL,
	"%f",	1, "ri",		PL_O(refrac_index),	FUNC_NULL,
	"%f",	1, "extinction",	PL_O(extinction),	FUNC_NULL,
	"%f",	1, "ex",		PL_O(extinction),	FUNC_NULL,
	"",	0, (char *)0,		0,			FUNC_NULL
d76 2
a77 2
	"default",	0,		0,		MFI_NORMAL|MFI_LIGHT,
	phong_setup,	phong_render,	phong_print,	phong_free,
d79 2
a80 2
	"plastic",	0,		0,		MFI_NORMAL|MFI_LIGHT,
	phong_setup,	phong_render,	phong_print,	phong_free,
d82 2
a83 2
	"mirror",	0,		0,		MFI_NORMAL|MFI_LIGHT,
	mirror_setup,	phong_render,	phong_print,	phong_free,
d85 2
a86 2
	"glass",	0,		0,		MFI_NORMAL|MFI_LIGHT,
	glass_setup,	phong_render,	phong_print,	phong_free,
d88 2
a89 2
	(char *)0,	0,		0,		0,
	0,		0,		0,		0
@


9.5
log
@Converted to new format for fmt entry in structparse
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.4 90/12/12 16:35:07 butler Exp $ (BRL)";
d120 4
a123 1
	rt_structparse( matparm, phong_parse, (char *)pp );
d154 4
a157 1
	rt_structparse( matparm, phong_parse, (char *)pp );
d189 4
a192 1
	rt_structparse( matparm, phong_parse, (char *)pp );
@


9.4
log
@modified to reflect changes in structparse format
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.3 90/12/08 08:58:11 butler Exp $ (BRL)";
d67 1
a67 1
	(char *)0, 0, (char *)0,	0,			FUNC_NULL
@


9.3
log
@changed material property parameter to be struct rt_vls
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.2 90/11/01 11:18:10 mike Exp $ (BRL)";
d54 14
a67 14
	"%d",	"shine",	PL_O(shine),		FUNC_NULL,
	"%d",	"sh",		PL_O(shine),		FUNC_NULL,
	"%f",	"specular",	PL_O(wgt_specular),	FUNC_NULL,
	"%f",	"sp",		PL_O(wgt_specular),	FUNC_NULL,
	"%f",	"diffuse",	PL_O(wgt_diffuse),	FUNC_NULL,
	"%f",	"di",		PL_O(wgt_diffuse),	FUNC_NULL,
	"%f",	"transmit",	PL_O(transmit),		FUNC_NULL,
	"%f",	"tr",		PL_O(transmit),		FUNC_NULL,
	"%f",	"reflect",	PL_O(reflect),		FUNC_NULL,
	"%f",	"re",		PL_O(reflect),		FUNC_NULL,
	"%f",	"ri",		PL_O(refrac_index),	FUNC_NULL,
	"%f",	"extinction",	PL_O(extinction),	FUNC_NULL,
	"%f",	"ex",		PL_O(extinction),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.2
log
@Added magic number protection
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.1 89/05/19 05:59:36 mike Rel3_5 $ (BRL)";
d102 1
a102 1
char	*matparm;
d107 1
d133 1
a133 1
char	*matparm;
d138 1
d164 1
a164 1
char	*matparm;
d169 1
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: sh_plastic.c,v 8.4 89/04/30 20:40:06 mike Exp $ (BRL)";
d40 1
d49 1
d110 1
d140 1
d170 1
d293 2
@


8.4
log
@No longer depends on mathatb.h
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: sh_plastic.c,v 8.3 89/04/04 05:02:02 mike Locked $ (BRL)";
@


8.3
log
@Converted to new way of representing structure offsets.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 8.2 88/12/27 16:35:03 mike Locked $ (BRL)";
a32 1
#include "./mathtab.h"
@


8.2
log
@Converted matparse --> structparse
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 8.1 88/10/05 00:32:57 mike Locked $ (BRL)";
d50 1
d53 14
a66 14
	"%d",	"shine",	(stroff_t)&(PL_NULL->shine),		FUNC_NULL,
	"%d",	"sh",		(stroff_t)&(PL_NULL->shine),		FUNC_NULL,
	"%f",	"specular",	(stroff_t)&(PL_NULL->wgt_specular),	FUNC_NULL,
	"%f",	"sp",		(stroff_t)&(PL_NULL->wgt_specular),	FUNC_NULL,
	"%f",	"diffuse",	(stroff_t)&(PL_NULL->wgt_diffuse),	FUNC_NULL,
	"%f",	"di",		(stroff_t)&(PL_NULL->wgt_diffuse),	FUNC_NULL,
	"%f",	"transmit",	(stroff_t)&(PL_NULL->transmit),		FUNC_NULL,
	"%f",	"tr",		(stroff_t)&(PL_NULL->transmit),		FUNC_NULL,
	"%f",	"reflect",	(stroff_t)&(PL_NULL->reflect),		FUNC_NULL,
	"%f",	"re",		(stroff_t)&(PL_NULL->reflect),		FUNC_NULL,
	"%f",	"ri",		(stroff_t)&(PL_NULL->refrac_index),	FUNC_NULL,
	"%f",	"extinction",	(stroff_t)&(PL_NULL->extinction),	FUNC_NULL,
	"%f",	"ex",		(stroff_t)&(PL_NULL->extinction),	FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d117 1
a117 1
	rt_structparse( matparm, phong_parse, (stroff_t)pp );
d146 1
a146 1
	rt_structparse( matparm, phong_parse, (stroff_t)pp );
d176 1
a176 1
	rt_structparse( matparm, phong_parse, (stroff_t)pp );
d191 1
a191 1
	rt_structprint(rp->reg_name, phong_parse, (stroff_t)dp);
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.5 88/08/20 05:07:54 mike Exp $ (BRL)";
d51 15
a65 15
struct matparse phong_parse[] = {
	"shine",	(mp_off_ty)&(PL_NULL->shine),		"%d",
	"sh",		(mp_off_ty)&(PL_NULL->shine),		"%d",
	"specular",	(mp_off_ty)&(PL_NULL->wgt_specular),	"%f",
	"sp",		(mp_off_ty)&(PL_NULL->wgt_specular),	"%f",
	"diffuse",	(mp_off_ty)&(PL_NULL->wgt_diffuse),	"%f",
	"di",		(mp_off_ty)&(PL_NULL->wgt_diffuse),	"%f",
	"transmit",	(mp_off_ty)&(PL_NULL->transmit),	"%f",
	"tr",		(mp_off_ty)&(PL_NULL->transmit),	"%f",
	"reflect",	(mp_off_ty)&(PL_NULL->reflect),		"%f",
	"re",		(mp_off_ty)&(PL_NULL->reflect),		"%f",
	"ri",		(mp_off_ty)&(PL_NULL->refrac_index),	"%f",
	"extinction",	(mp_off_ty)&(PL_NULL->extinction),	"%f",
	"ex",		(mp_off_ty)&(PL_NULL->extinction),	"%f",
	(char *)0,	(mp_off_ty)0,				(char *)0
d116 1
a116 1
	mlib_parse( matparm, phong_parse, (mp_off_ty)pp );
d145 1
a145 1
	mlib_parse( matparm, phong_parse, (mp_off_ty)pp );
d175 1
a175 1
	mlib_parse( matparm, phong_parse, (mp_off_ty)pp );
d190 1
a190 1
	mlib_print(rp->reg_name, phong_parse, (mp_off_ty)dp);
@


7.5
log
@Added "default" entry to be "plastic".
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.4 88/05/14 02:28:18 mike Locked $ (BRL)";
@


7.4
log
@lint fixes
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.3 88/03/19 02:33:28 mike Locked $ (BRL)";
d74 3
@


7.3
log
@changed ipow() to phg_ipow()
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.2 88/01/26 05:30:03 mike Locked $ (BRL)";
d70 2
a71 2
HIDDEN int phong_print();
HIDDEN int phong_free();
d182 1
a182 1
HIDDEN int
d193 1
a193 1
HIDDEN int
@


7.2
log
@extinction coeff, tolight vectors
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.1 87/11/02 23:54:18 mike Rel $ (BRL)";
d87 1
a87 1
extern double ipow();
d346 1
a346 1
				ipow(cosine, ps->shine);
d362 1
a362 1
ipow( d, cnt )
d370 1
a370 1
		rt_log("ipow(%g,%d) bad\n", d, cnt);
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 6.2 87/09/10 07:14:36 mike Exp $ (BRL)";
d47 1
d63 2
d111 1
d140 1
d170 1
d275 1
a275 1
	register fastf_t *intensity;
a280 1
	vect_t	to_light;
d289 1
d315 1
a317 2
		VSUB2( to_light, lp->lt_pos, swp->sw_hit.hit_point );
		VUNITIZE( to_light );
@


6.2
log
@Light visibility is now determined in viewshade();
supporting light hit&miss routines moved to light.c
plastic.c now merely implements Phong shading.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 6.1 87/07/11 07:58:48 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.6 87/07/06 15:26:37 mike Exp $ (BRL)";
a35 2
extern struct light_specific *LightHeadp;

a36 1
extern int lightmodel;		/* lighting model # to use */
d71 1
a71 1
	"plastic",	0,		0,		MFI_NORMAL,
d74 1
a74 1
	"mirror",	0,		0,		MFI_NORMAL,
d77 1
a77 1
	"glass",	0,		0,		MFI_NORMAL,
a83 1
extern int light_hit(), light_miss();
a260 1
static char *phong_hack = "light visibility?";
d269 9
a277 10
	auto struct application sub_ap;
	auto int light_visible;
	auto fastf_t	d_a;		/* ambient diffuse */
	auto fastf_t	cosAmb;
	auto fastf_t	f;
	auto vect_t	work;
	auto vect_t	reflected;
	auto vect_t	to_eye;
	auto vect_t	to_light;
	auto point_t	matcolor;		/* Material color */
d284 1
d286 1
a286 4
	/**** DO NOT RECURSE on light rays XXX hack XXX ****/
	if( ap->a_purpose == phong_hack )  {
		return(1);
	}
a287 7
	VREVERSE( to_eye, ap->a_ray.r_dir );

	/* Diminish intensity of reflected light as a function of
	 * the distance from your eye.
	 */
/**	dist_gradient = kCons / (swp->sw_hit.hit_dist + cCons);  */

d289 3
a291 4
	d_a = 0;
	if( (cosAmb = VDOT( swp->sw_hit.hit_normal, to_eye )) > 0.0 )  {
		if( cosAmb > 1.00001 )  {
			rt_log("cosAmb=1+%g (x%d,y%d,lvl%d)\n", cosAmb-1,
d293 1
a293 1
			cosAmb = 1;
d295 4
a298 1
		d_a = cosAmb * AmbientIntensity;
a299 2
	VMOVE( matcolor, swp->sw_color );
	VSCALE( swp->sw_color, matcolor, d_a );
d302 1
a302 2
	for( lp=LightHeadp; lp; lp = lp->lt_forw )  {
		FAST fastf_t f;
d304 2
a305 25
		if( lp->lt_explicit )  {
			/* Fire ray at light source to check for shadowing */
			/* This SHOULD actually return an energy value */
			sub_ap = *ap;		/* struct copy */
			sub_ap.a_hit = light_hit;
			sub_ap.a_miss = light_miss;
			sub_ap.a_level = 0;
			VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
			
			/* Dither light pos for penumbra by +/- 0.5 light radius */
			/* This presently makes a cubical light source distribution */
			f = lp->lt_radius * 0.9;
			sub_ap.a_ray.r_dir[X] =  lp->lt_pos[X] + rand_half()*f - swp->sw_hit.hit_point[X];
			sub_ap.a_ray.r_dir[Y] =  lp->lt_pos[Y] + rand_half()*f - swp->sw_hit.hit_point[Y];
			sub_ap.a_ray.r_dir[Z] =  lp->lt_pos[Z] + rand_half()*f - swp->sw_hit.hit_point[Z];
			VUNITIZE( sub_ap.a_ray.r_dir );
			VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
			sub_ap.a_purpose = "light visibility?";
			sub_ap.a_purpose = phong_hack;
			light_visible = rt_shootray( &sub_ap );
			/* sub_ap.a_color now contains visible fraction */
		} else {
			light_visible = 1;
			VSETALL( sub_ap.a_color, 1 );
		}
d307 2
a308 5
		/* If not shadowed add this light contribution */
		if( light_visible )  {
			auto fastf_t cosI;
			auto fastf_t cosS;
			vect_t light_intensity;
d310 8
a317 17
			/* Diffuse reflectance from this light source. */
			VSUB2( to_light, lp->lt_pos, swp->sw_hit.hit_point );
			VUNITIZE( to_light );
			if( (cosI = VDOT( swp->sw_hit.hit_normal, to_light )) > 0.0 )  {
				fastf_t	Rd;
				vect_t	cprod;	/* color product */
				if( cosI > 1.00001 )  {
					rt_log("cosI=1+%g (x%d,y%d,lvl%d)\n", cosI-1,
						ap->a_x, ap->a_y, ap->a_level);
					cosI = 1;
				}
				Rd = cosI * lp->lt_fraction * ps->wgt_diffuse;
				VELMUL( light_intensity, lp->lt_color,
					sub_ap.a_color );
				VELMUL( cprod, matcolor, light_intensity );
				VJOIN1( swp->sw_color, swp->sw_color,
					Rd, cprod );
d319 7
d327 12
a338 20
			/* Calculate specular reflectance.
			 *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
			 * 	Cos(s) = Reflected ray DOT Incident ray.
			 */
			cosI *= 2;
			VSCALE( work, swp->sw_hit.hit_normal, cosI );
			VSUB2( reflected, work, to_light );
			if( (cosS = VDOT( reflected, to_eye )) > 0 )  {
				fastf_t Rs;
				if( cosS > 1.00001 )  {
					rt_log("cosS=1+%g (x%d,y%d,lvl%d)\n", cosS-1,
						ap->a_x, ap->a_y, ap->a_level);
					cosS = 1;
				}
				Rs = ps->wgt_specular * lp->lt_fraction *
					ipow(cosS, ps->shine);
				VELMUL( light_intensity, lp->lt_color,
					sub_ap.a_color );
				VJOIN1( swp->sw_color, swp->sw_color,
					Rs, light_intensity );
d340 6
a372 132

static struct shadework light_default = {
	0.0,				/* xmit */
	0.0,				/* reflect */
	1.0,				/* refractive index */
	1.0, 1.0, 1.0,			/* color: white */
	/* rest are zeros */
};

/* 
 *			L I G H T _ H I T
 *
 *  Input -
 *	a_color[] contains the fraction of a the light that will be
 *	propagated back along the ray, so far.  If this gets too small,
 *	recursion through lots of glass ought to stop.
 *  Output -
 *	a_color[] contains the fraction of light that can be seen.
 *	RGB transmissions are separately indicated, to allow simplistic
 *	colored glass (with apologies to Roy Hall).
 *
 *  These shadow functions return a boolean "light_visible".
 * 
 *  This is a simplified algorithm, and could be improved.
 *  Reflected light can't be dealt with at all.
 *
 *  Would also be nice to return an actual energy level, rather than
 *  a boolean, which could account for distance, etc.
 */
light_hit(ap, PartHeadp)
struct application *ap;
struct partition *PartHeadp;
{
	register struct partition *pp;
	register struct region	*regp;
	struct application	sub_ap;
	struct shadework	sw;
	extern int	light_render();
	vect_t	filter_color;
	int	light_visible;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		rt_log("light_hit:  no hit out front?\n");
		light_visible = 0;
		goto out;
	}
	regp = pp->pt_regionp;

	/* Check to see if we hit a light source */
	if( ((struct mfuncs *)(regp->reg_mfuncs))->mf_render == light_render )  {
		VSETALL( ap->a_color, 1 );
		light_visible = 1;
		goto out;
	}

	/* If we hit an entirely opaque object, this light is invisible */
	if( pp->pt_outhit->hit_dist >= INFINITY ||
	    regp->reg_transmit == 0 )  {
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		goto out;
	}

	/*  See if any further contributions will mater */
	if( ap->a_color[0] + ap->a_color[1] + ap->a_color[2] < 0.01 )  {
	    	/* Any light energy is "fully" attenuated by here */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		goto out;
	}

	/*
	 *  Determine transparency parameters of this object.
	 */
	sw = light_default;		/* struct copy */
	viewshade( ap, pp, &sw );
	VSCALE( filter_color, sw.sw_color, sw.sw_transmit );
	if( filter_color[0] + filter_color[1] + filter_color[2] < 0.01 )  {
	    	/* Any recursion won't be significant */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		goto out;
	}

	/*
	 * Push on to exit point, and trace on from there.
	 * Transmission so far is passed along in sub_ap.a_color[];
	 * Don't even think of trying to refract, or we will miss the light!
	 */
	sub_ap = *ap;			/* struct copy */
	sub_ap.a_level = ap->a_level+1;
	{
		FAST fastf_t f;
		f = pp->pt_outhit->hit_dist+0.0001;
		VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt, f, ap->a_ray.r_dir);
	}
	sub_ap.a_purpose = "light transmission after filtering";
	light_visible = rt_shootray( &sub_ap );

	VELMUL( ap->a_color, sub_ap.a_color, filter_color );
out:
	if( rdebug & RDEBUG_LIGHT ) rt_log("light %s vis=%d\n", regp->reg_name, light_visible);
	return(light_visible);
}

/*
 *  			L I G H T _ M I S S
 *  
 *  If there is no explicit light solid in the model, we will always "miss"
 *  the light, so return light_visible = TRUE.
 */
/* ARGSUSED */
light_miss(ap, PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	extern struct light_specific *LightHeadp;

	if( LightHeadp )  {
		/* Explicit lights exist, somehow we missed (dither?) */
		VSETALL( ap->a_color, 0 );
		return(0);		/* light_visible = 0 */
	}
	/* No explicit light -- it's hard to hit */
	VSETALL( ap->a_color, 1 );
	return(1);			/* light_visible = 1 */
}

/* Null function */
nullf() { return(0); }
@


5.6
log
@Added reg_transmit flag handling, converted to viewshade() processing.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.5 87/07/02 02:53:47 mike Locked $ (BRL)";
@


5.5
log
@Modified cos() > 1 tests for Cray's incredible number of digits.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.4 87/06/27 06:46:08 mike Locked $ (BRL)";
d115 2
a116 2
	VSCALE( rp->reg_mater.ma_transmit, 
		rp->reg_mater.ma_color, pp->transmit );
a141 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, phong_parse, (mp_off_ty)pp);
d143 2
a144 2
	VSCALE( rp->reg_mater.ma_transmit, 
		rp->reg_mater.ma_color, pp->transmit );
d165 2
a166 2
	pp->transmit = 0.6;
	pp->reflect = 0.3;
a170 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, phong_parse, (mp_off_ty)pp);
d172 2
a173 2
	VSCALE( rp->reg_mater.ma_transmit, 
		rp->reg_mater.ma_color, pp->transmit );
d265 1
d291 5
d326 1
a326 1
			sub_ap.a_level++;
d337 2
d420 8
d453 6
a458 4
	register struct region *regp;
	struct application sub_ap;
	extern int light_render();
	int ret;
d464 2
a465 1
		return(0);
d472 2
a473 1
		return(1);		/* light_visible = 1 */
d477 2
a478 4
	if( pp->pt_outhit->hit_dist >= INFINITY || (
	    regp->reg_mater.ma_transmit[0] +
	    regp->reg_mater.ma_transmit[1] +
	    regp->reg_mater.ma_transmit[2] <= 0 ) )  {
d480 2
a481 1
		return(0);			/* light_visible = 0 */
d484 1
a484 3
	/*
	 * We hit a transparant object.  Continue on.
	 */
d488 2
a489 1
		return(0);		/* light_visible = 0 */
d492 15
a506 1
	/* Push on to exit point, and trace on from there.
d508 1
d517 7
a523 4
	ret = rt_shootray( &sub_ap );
	VELMUL( ap->a_color, sub_ap.a_color,
		regp->reg_mater.ma_transmit );
	return(ret);			/* light_visible = ret */
@


5.4
log
@rendering parameter changes
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.3 87/06/27 03:45:57 phil Locked $ (BRL)";
d305 1
a305 1
			rt_log("cosAmb=%g (x%d,y%d,lvl%d)\n", cosAmb,
d354 2
a355 2
				if( cosI > 1 )  {
					rt_log("cosI=%g (x%d,y%d,lvl%d)\n", cosI,
d376 2
a377 2
				if( cosS > 1 )  {
					rt_log("cosS=%g (x%d,y%d,lvl%d)\n", cosS,
@


5.3
log
@Added support for colored transparant objects
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.2 87/06/26 05:57:56 mike Exp $ (BRL)";
d96 1
a96 1
phong_setup( rp )
d98 2
d104 1
a104 1
	rp->reg_udata = (char *)pp;
d113 1
a113 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (mp_off_ty)pp );
d124 1
a124 1
mirror_setup( rp )
d126 2
d132 1
a132 1
	rp->reg_udata = (char *)pp;
d141 1
a141 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (mp_off_ty)pp );
d154 1
a154 1
glass_setup( rp )
d156 2
d162 1
a162 1
	rp->reg_udata = (char *)pp;
d172 1
a172 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (mp_off_ty)pp );
d185 1
a185 1
phong_print( rp )
d187 1
d189 1
a189 1
	mlib_print(rp->reg_name, phong_parse, (mp_off_ty)rp->reg_udata);
d270 1
a270 1
phong_render( ap, pp, swp )
d274 1
d288 1
a288 1
		(struct phong_specific *)pp->pt_regionp->reg_udata;
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.1 87/06/24 22:14:50 mike Locked $ (BRL)";
d112 3
d140 3
d161 1
a161 1
	pp->transmit = 0.7;
d163 1
d169 3
d326 1
d328 1
d331 1
d338 1
d352 5
a356 2
				VELMUL( cprod, matcolor, lp->lt_color );
				VJOIN1( swp->sw_color, swp->sw_color, Rd, cprod );
d375 4
a378 1
				VJOIN1( swp->sw_color, swp->sw_color, Rs, lp->lt_color );
d411 9
d422 1
a422 2
 *  This is an incredibly simplistic algorithm, in need of improvement.
 *  If glass is hit, we need to keep going.
d424 3
a426 2
 *  Would also be nice to return an energy level, rather than
 *  a boolean, which could account for lots of interesting effects.
d433 2
d436 1
d444 1
d447 2
a448 1
	if( ((struct mfuncs *)(pp->pt_regionp->reg_mfuncs))->mf_render == light_render )
d450 34
a483 1
	return(0);			/* light_visible = 0 */
d497 9
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.8 87/06/13 03:19:45 mike Exp $ (BRL)";
a40 2
#define MAX_IREFLECT	9	/* Maximum internal reflection level */
#define MAX_BOUNCE	4	/* Maximum recursion level */
d74 1
a74 1
	"plastic",	0,		0,
d77 1
a77 1
	"mirror",	0,		0,
d80 1
a80 1
	"glass",	0,		0,
d83 1
a83 1
	(char *)0,	0,		0,
a86 4
HIDDEN int phg_rmiss();
HIDDEN int phg_rhit();
HIDDEN int phg_refract();

d253 1
a253 1
phong_render( ap, pp )
d255 2
a256 1
register struct partition *pp;
a257 1
	register struct hit *hitp= pp->pt_inhit;
d272 3
a275 35
	/* Get default color-by-ident for region.			*/
	{
		register struct region *rp;
		if( (rp=pp->pt_regionp) == REGION_NULL )  {
			rt_log("bad region pointer\n");
			VSET( ap->a_color, 0.7, 0.7, 0.7 );
			goto finish;
		}
		if( rp->reg_mater.ma_override )  {
			VSET( matcolor,
				rp->reg_mater.ma_rgb[0]/255.,
				rp->reg_mater.ma_rgb[1]/255.,
				rp->reg_mater.ma_rgb[2]/255. );
		} else {
			/* Default color is white (uncolored) */
			VSETALL( matcolor, 1.0 );
		}
	}

	/* Get surface normal for hit point */
	RT_HIT_NORM( hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );

	/* Temporary check to make sure normals are OK */
	if( hitp->hit_normal[X] < -1.01 || hitp->hit_normal[X] > 1.01 ||
	    hitp->hit_normal[Y] < -1.01 || hitp->hit_normal[Y] > 1.01 ||
	    hitp->hit_normal[Z] < -1.01 || hitp->hit_normal[Z] > 1.01 )  {
	    	VPRINT("phong_render: N", hitp->hit_normal);
		VSET( ap->a_color, 9, 9, 0 );	/* Yellow */
		return(1);
	}
	if( pp->pt_inflip )  {
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
		pp->pt_inflip = 0;
	}

d278 1
a278 1
	/* Diminish intensity of reflected light the as a function of
d281 1
a281 1
/**	dist_gradient = kCons / (hitp->hit_dist + cCons);  */
d285 1
a285 1
	if( (cosAmb = VDOT( hitp->hit_normal, to_eye )) > 0.0 )  {
d293 2
a294 1
	VSCALE( ap->a_color, matcolor, d_a );
d307 1
a307 1
			VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
d310 1
d312 3
a314 3
			sub_ap.a_ray.r_dir[X] =  lp->lt_pos[X] + rand_half()*f - hitp->hit_point[X];
			sub_ap.a_ray.r_dir[Y] =  lp->lt_pos[Y] + rand_half()*f - hitp->hit_point[Y];
			sub_ap.a_ray.r_dir[Z] =  lp->lt_pos[Z] + rand_half()*f - hitp->hit_point[Z];
d327 1
a327 1
			VSUB2( to_light, lp->lt_pos, hitp->hit_point );
d329 1
a329 1
			if( (cosI = VDOT( hitp->hit_normal, to_light )) > 0.0 )  {
d339 1
a339 1
				VJOIN1( ap->a_color, ap->a_color, Rd, cprod );
d347 1
a347 1
			VSCALE( work, hitp->hit_normal, cosI );
d358 1
a358 1
				VJOIN1( ap->a_color, ap->a_color, Rs, lp->lt_color );
a361 113

	if( (ps->reflect <= 0 && ps->transmit <= 0) ||
	    ap->a_level > MAX_BOUNCE )  {
		/* Nothing more to do for this ray */
		goto finish;
	}

	/*
	 *  Diminish base color appropriately, and add in
	 *  contributions from mirror reflection & transparency
	 */
	f = 1 - (ps->reflect + ps->transmit);
	if( f > 0 )  {
		VSCALE( ap->a_color, ap->a_color, f );
	}
	if( ps->reflect > 0 )  {
		/* Mirror reflection */
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_level = ap->a_level+1;
		sub_ap.a_onehit = 1;
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
		f = 2 * VDOT( to_eye, hitp->hit_normal );
		VSCALE( work, hitp->hit_normal, f );
		/* I have been told this has unit length */
		VSUB2( sub_ap.a_ray.r_dir, work, to_eye );
		(void)rt_shootray( &sub_ap );
		VJOIN1(ap->a_color, ap->a_color, ps->reflect, sub_ap.a_color);
	}
	if( ps->transmit > 0 )  {
		LOCAL vect_t incident_dir;

		/* Calculate refraction at entrance. */
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_level = (ap->a_level+1) * 100;	/* flag */
		sub_ap.a_onehit = 1;
		sub_ap.a_user = (int)(pp->pt_regionp);
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
		VMOVE( incident_dir, ap->a_ray.r_dir );
		if( !phg_refract(incident_dir, /* Incident ray (IN) */
			hitp->hit_normal,
			RI_AIR, ps->refrac_index,
			sub_ap.a_ray.r_dir	/* Refracted ray (OUT) */
		) )  {
			/* Reflected back outside solid */
			goto do_exit;
		}
		/* Find new exit point from the inside. */
do_inside:
		sub_ap.a_hit =  phg_rhit;
		sub_ap.a_miss = phg_rmiss;
		if( rt_shootray( &sub_ap ) == 0 )  {
			if(rdebug&RDEBUG_HITS)rt_log("phong: Refracted ray missed '%s' -- RETRYING, lvl=%d\n",
				pp->pt_inseg->seg_stp->st_name,
				sub_ap.a_level );
			/* Back off just a little bit, and try again */
			/* Useful when striking exactly in corners */
			VJOIN1( sub_ap.a_ray.r_pt, sub_ap.a_ray.r_pt,
				-3.0, incident_dir );
			if( rt_shootray( &sub_ap ) == 0 )  {
				rt_log("phong: Refracted ray missed 2x '%s', lvl=%d\n",
					pp->pt_inseg->seg_stp->st_name,
					sub_ap.a_level );
				VPRINT("pt", sub_ap.a_ray.r_pt );
				VPRINT("dir", sub_ap.a_ray.r_dir );
				VSET( ap->a_color, 0, 99, 0 );	/* green */
				goto finish;		/* abandon hope */
			}
		}
		/* NOTE: phg_rhit returns EXIT Point in sub_ap.a_uvec,
		 *  and returns EXIT Normal in sub_ap.a_vvec.
		 */
		if( rdebug&RDEBUG_RAYWRITE )  {
			wraypts( sub_ap.a_ray.r_pt, sub_ap.a_uvec,
				ap, stdout );
		}
		if( rdebug&RDEBUG_RAYPLOT )  {
			pl_color( stdout, 0, 255, 0 );
			rt_drawvec( stdout, ap->a_rt_i,
				sub_ap.a_ray.r_pt,
				sub_ap.a_uvec );
		}
		VMOVE( sub_ap.a_ray.r_pt, sub_ap.a_uvec );

		/* Calculate refraction at exit. */
		VMOVE( incident_dir, sub_ap.a_ray.r_dir );
		if( !phg_refract( incident_dir,		/* input direction */
			sub_ap.a_vvec,			/* exit normal */
			ps->refrac_index, RI_AIR,
			sub_ap.a_ray.r_dir		/* output direction */
		) )  {
			/* Reflected internally -- keep going */
			if( (++sub_ap.a_level)%100 > MAX_IREFLECT )  {
				rt_log("phong: %s Excessive internal reflection (x%d, y%d, lvl=%d)\n",
					pp->pt_inseg->seg_stp->st_name,
					sub_ap.a_x, sub_ap.a_y, sub_ap.a_level );
				if(rdebug&RDEBUG_SHOWERR) {
					VSET( ap->a_color, 0, 9, 0 );	/* green */
				} else {
					VSETALL( ap->a_color, .18 ); /* 18% grey */
				}
				goto finish;
			}
			goto do_inside;
		}
do_exit:
		sub_ap.a_hit =  ap->a_hit;
		sub_ap.a_miss = ap->a_miss;
		sub_ap.a_level++;
		(void) rt_shootray( &sub_ap );
		VJOIN1( ap->a_color, ap->a_color,
			ps->transmit, sub_ap.a_color );
	}
finish:
a365 159
 *			R F R _ M I S S
 */
HIDDEN int
/*ARGSUSED*/
phg_rmiss( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	return(0);
}

/*
 *			R F R _ H I T
 *
 *  Implicit Returns -
 *	a_uvec	exit Point
 *	a_vvec	exit Normal
 */
HIDDEN int
phg_rhit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	register struct hit	*hitp;
	register struct soltab *stp;
	register struct partition *pp;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist > 0.0 )  break;
	if( pp == PartHeadp )  {
		if(rdebug&RDEBUG_SHOWERR)
			rt_log("phg_rhit:  no hit out front?\n");
		goto bad;
	}
	if( pp->pt_regionp != (struct region *)(ap->a_user) )  {
		if(rdebug&RDEBUG_HITS)
			rt_log("phg_rhit:  Ray reflected within %s now in %s!\n",
				((struct region *)(ap->a_user))->reg_name,
				pp->pt_regionp->reg_name );
		goto bad;
	}

	hitp = pp->pt_inhit;
	if( !NEAR_ZERO(hitp->hit_dist, 10) )  {
/**		if(rdebug&RDEBUG_HITS) **/
		{
			stp = pp->pt_inseg->seg_stp;
			RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
			rt_log("phg_rhit:  '%s' inhit %g not near zero!\n",
				stp->st_name, hitp->hit_dist);
			rt_pr_hit("inhit", hitp);
			rt_pr_hit("outhit", pp->pt_outhit);
		}
		goto bad;
	}

	hitp = pp->pt_outhit;
	stp = pp->pt_outseg->seg_stp;
	RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
	if( hitp->hit_dist >= INFINITY )  {
		if(rdebug&RDEBUG_SHOWERR)
			rt_log("phg_rhit:  (%g,%g) bad!\n",
				pp->pt_inhit->hit_dist, hitp->hit_dist);
		goto bad;
	}

	VMOVE( ap->a_uvec, hitp->hit_point );
	/* Safety check */
	if( (rdebug&RDEBUG_SHOWERR) && (
	    !NEAR_ZERO(hitp->hit_normal[X], 1.001) ||
	    !NEAR_ZERO(hitp->hit_normal[Y], 1.001) ||
	    !NEAR_ZERO(hitp->hit_normal[Z], 1.001) ) )  {
	    	rt_log("phg_rhit: defective normal hitting %s\n", stp->st_name);
	    	VPRINT("hit_normal", hitp->hit_normal);
	    	goto bad;
	}
	/* For refraction, want exit normal to point inward. */
	VREVERSE( ap->a_vvec, hitp->hit_normal );
	return(1);

	/* Give serious information when problems are encountered */
bad:
	if(rdebug&RDEBUG_HITS) rt_pr_partitions( ap->a_rt_i, PartHeadp, "phg_rhit" );
	return(0);
}

/*
 *			R E F R A C T
 *
 *	Compute the refracted ray 'v_2' from the incident ray 'v_1' with
 *	the refractive indices 'ri_2' and 'ri_1' respectively.
 *	Using Schnell's Law:
 *
 *		theta_1 = angle of v_1 with surface normal
 *		theta_2 = angle of v_2 with reversed surface normal
 *		ri_1 * sin( theta_1 ) = ri_2 * sin( theta_2 )
 *
 *		sin( theta_2 ) = ri_1/ri_2 * sin( theta_1 )
 *		
 *	The above condition is undefined for ri_1/ri_2 * sin( theta_1 )
 *	being greater than 1, and this represents the condition for total
 *	reflection, the 'critical angle' is the angle theta_1 for which
 *	ri_1/ri_2 * sin( theta_1 ) equals 1.
 *
 *  Returns TRUE if refracted, FALSE if reflected.
 *
 *  Note:  output (v_2) can be same storage as an input.
 */
HIDDEN int
phg_refract( v_1, norml, ri_1, ri_2, v_2 )
register vect_t	v_1;
register vect_t	norml;
double	ri_1, ri_2;
register vect_t	v_2;
{
	LOCAL vect_t	w, u;
	FAST fastf_t	beta;

	if( NEAR_ZERO(ri_1, 0.0001) || NEAR_ZERO( ri_2, 0.0001 ) )  {
		rt_log("phg_refract:ri1=%g, ri2=%g\n", ri_1, ri_2 );
		beta = 1;
	} else {
		beta = ri_1/ri_2;		/* temp */
		if( beta > 10000 )  {
			rt_log("phg_refract:  beta=%g\n", beta);
			beta = 1000;
		}
	}
	VSCALE( w, v_1, beta );
	VCROSS( u, w, norml );
	    	
	/*
	 *	|w X norml| = |w||norml| * sin( theta_1 )
	 *	        |u| = ri_1/ri_2 * sin( theta_1 ) = sin( theta_2 )
	 */
	if( (beta = VDOT( u, u )) > 1.0 )  {
		/*  Past critical angle, total reflection.
		 *  Calculate reflected (bounced) incident ray.
		 */
		VREVERSE( u, v_1 );
		beta = 2 * VDOT( u, norml );
		VSCALE( w, norml, beta );
		VSUB2( v_2, w, u );
		return(0);		/* reflected */
	} else {
		/*
		 * 1 - beta = 1 - sin( theta_2 )^^2
		 *	    = cos( theta_2 )^^2.
		 *     beta = -1.0 * cos( theta_2 ) - Dot( w, norml ).
		 */
		beta = -sqrt( 1.0 - beta) - VDOT( w, norml );
		VSCALE( u, norml, beta );
		VADD2( v_2, w, u );
		return(1);		/* refracted */
	}
	/* NOTREACHED */
}

/*
d414 1
a414 1
	if( pp->pt_regionp->reg_mfuncs->mf_render == light_render )
@


4.8
log
@Changed default refrac_index to non-zero values, so if user overrides
transmit or reflect on plastic or mirror, the RI is sensible.
Probably should test RI for >= 0.01 or something.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.7 87/06/13 01:38:51 mike Locked $ (BRL)";
@


4.7
log
@Moved hit_nothing() into view.c,
fixed potential minor bug in refraction;  more certainly remain.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.6 87/04/10 22:49:26 mike Locked $ (BRL)";
d115 1
a115 1
	pp->refrac_index = 0.0;
d138 1
a138 1
	pp->refrac_index = 0.0;
@


4.6
log
@Adjusted calling sequence of rt_pr_partitions
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.5 87/04/01 04:51:36 mike Locked $ (BRL)";
a35 2
extern int colorview();		/* from view.c */

a93 1
extern int hit_nothing();
d503 2
a504 2
		sub_ap.a_hit =  colorview;
		sub_ap.a_miss = hit_nothing;
a742 19

/*
 *			H I T _ N O T H I N G
 *
 *  a_miss() routine called when no part of the model is hit.
 *  Background texture mapping could be done here.
 *  For now, return a pleasant dark blue.
 */
hit_nothing( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	if( lightmodel == 2 )  {
		VSET( ap->a_color, 0, 0, 0 );
	}  else  {
		VSET( ap->a_color, .25, 0, .5 );	/* Background */
	}
	return(0);
}
@


4.5
log
@Added RDEBUG_PLOTRAY flag, and code to support it.
Gives direct UNIX-plot output of ray paths, clipped to model RPP.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.4 87/03/23 23:48:18 mike Exp $ (BRL)";
d600 1
a600 1
	if(rdebug&RDEBUG_HITS) rt_pr_partitions( PartHeadp, "phg_rhit" );
@


4.4
log
@Revised for new material property interface.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.3 87/03/17 20:19:00 mike Exp $ (BRL)";
a403 7
		if( rdebug&RDEBUG_RAYWRITE )  {
			register struct soltab *stp;
			/* Record passing through the solid */
			stp = pp->pt_outseg->seg_stp;
			RT_HIT_NORM( pp->pt_outhit, stp, &(ap->a_ray) );
			wray( pp, ap, stdout );
		}
d470 1
a470 1
		 *  and returns EXIT Normal in sub_ap.a_color.
d476 6
d487 1
a487 1
			sub_ap.a_color,			/* exit normal */
d534 1
a534 1
 *	a_color	exit Normal
d595 1
a595 1
	VREVERSE( ap->a_color, hitp->hit_normal );
@


4.3
log
@Added multiple lights, added beginnings of command-driven
input capability.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.1 86/12/29 03:48:29 mike Rel1 $ (BRL)";
d72 19
a90 1
extern int phong_render();
d104 1
a104 1
int
a110 1
	rp->reg_ufunc = phong_render;
a120 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, phong_parse, (mp_off_ty)pp);
d127 1
a127 1
int
a133 1
	rp->reg_ufunc = phong_render;
d152 1
a152 1
int
a158 1
	rp->reg_ufunc = phong_render;
d174 9
d185 11
d261 1
d726 1
a726 1
	if( pp->pt_regionp->reg_ufunc == light_render )
d746 1
a746 1
nullf() { ; }
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d34 1
d38 3
a40 1
/* HACKS from view.c */
a41 3
extern struct soltab *l0stp;
extern vect_t l0color;
extern vect_t l0pos;
d233 1
a235 1
	auto fastf_t	Rd1;
d237 1
a237 1
	auto double	cosI1, cosI2;
d243 1
a243 1
	auto point_t	mcolor;		/* Material color */
d257 1
a257 1
			VSET( mcolor,
d263 1
a263 1
			VSETALL( mcolor, 1.0 );
d290 1
a290 14
	/* Diffuse reflectance from primary light source. */
	VSUB2( to_light, l0pos, hitp->hit_point );
	VUNITIZE( to_light );
	Rd1 = 0;
	if( (cosI1 = VDOT( hitp->hit_normal, to_light )) > 0.0 )  {
		if( cosI1 > 1 )  {
			rt_log("cosI1=%g (x%d,y%d,lvl%d)\n", cosI1,
				ap->a_x, ap->a_y, ap->a_level);
			cosI1 = 1;
		}
		Rd1 = cosI1 * (1 - AmbientIntensity);
	}

	/* Diffuse reflectance from secondary light source (at eye) */
d292 3
a294 3
	if( (cosI2 = VDOT( hitp->hit_normal, to_eye )) > 0.0 )  {
		if( cosI2 > 1.00001 )  {
			rt_log("cosI2=%g (x%d,y%d,lvl%d)\n", cosI2,
d296 1
a296 1
			cosI2 = 1;
d298 1
a298 1
		d_a = cosI2 * AmbientIntensity;
d300 1
d302 2
a303 4
	/* Apply secondary (ambient) (white) lighting. */
	VSCALE( ap->a_color, mcolor, d_a );
	if( l0stp )  {
		/* An actual light solid exists */
d306 19
a324 18
		/* Fire ray at light source to check for shadowing */
		/* This SHOULD actually return an energy value */
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_hit = light_hit;
		sub_ap.a_miss = light_miss;
		sub_ap.a_level++;
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );

		/* Dither light pos for penumbra by +/- 0.5 light radius */
		f = l0stp->st_aradius * 0.9;
		sub_ap.a_ray.r_dir[X] =  l0pos[X] + rand_half()*f - hitp->hit_point[X];
		sub_ap.a_ray.r_dir[Y] =  l0pos[Y] + rand_half()*f - hitp->hit_point[Y];
		sub_ap.a_ray.r_dir[Z] =  l0pos[Z] + rand_half()*f - hitp->hit_point[Z];
		VUNITIZE( sub_ap.a_ray.r_dir );
		light_visible = rt_shootray( &sub_ap );
	} else {
		light_visible = 1;
	}
d326 4
a329 4
	/* If not shadowed add primary lighting. */
	if( light_visible )  {
		auto fastf_t specular;
		auto fastf_t cosS;
d331 15
a345 2
		/* Diffuse */
		VJOIN1( ap->a_color, ap->a_color, Rd1, mcolor );
d347 17
a363 12
		/* Calculate specular reflectance.
		 *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
		 * 	Cos(s) = Reflected ray DOT Incident ray.
		 */
		cosI1 *= 2;
		VSCALE( work, hitp->hit_normal, cosI1 );
		VSUB2( reflected, work, to_light );
		if( (cosS = VDOT( reflected, to_eye )) > 0 )  {
			if( cosS > 1 )  {
				rt_log("cosS=%g (x%d,y%d,lvl%d)\n", cosS,
					ap->a_x, ap->a_y, ap->a_level);
				cosS = 1;
a364 3
			specular = ps->wgt_specular *
				ipow(cosS, ps->shine);
			VJOIN1( ap->a_color, ap->a_color, specular, l0color );
d682 1
d691 2
a692 2
	/* Check to see if we hit the light source */
	if( pp->pt_inseg->seg_stp == l0stp )
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.19 86/12/24 08:23:29 mike Locked $ (BRL)";
@


1.19
log
@Updated for resource struct
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.18 86/12/18 16:01:46 mike Locked $ (BRL)";
@


1.18
log
@rdebug.h separated from librt/debug.h
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.17 86/12/14 17:54:26 mike Exp $ (BRL)";
d322 1
d325 1
a325 7
		sub_ap.a_onehit = 1;
		sub_ap.a_level = ap->a_level + 1;
		sub_ap.a_x = ap->a_x;
		sub_ap.a_y = ap->a_y;
		sub_ap.a_rt_i = ap->a_rt_i;
		sub_ap.a_rbeam = ap->a_rbeam;
		sub_ap.a_diverge = ap->a_diverge;
a472 3
		sub_ap.a_rt_i = ap->a_rt_i;
		sub_ap.a_rbeam = ap->a_rbeam;
		sub_ap.a_diverge = ap->a_diverge;
@


1.17
log
@Improved ipow().
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.16 86/12/10 03:26:08 mike Locked $ (BRL)";
d31 1
a31 1
#include "../librt/debug.h"
d58 12
a69 12
	"shine",	(int)&(PL_NULL->shine),		"%d",
	"sh",		(int)&(PL_NULL->shine),		"%d",
	"specular",	(int)&(PL_NULL->wgt_specular),	"%f",
	"sp",		(int)&(PL_NULL->wgt_specular),	"%f",
	"diffuse",	(int)&(PL_NULL->wgt_diffuse),	"%f",
	"di",		(int)&(PL_NULL->wgt_diffuse),	"%f",
	"transmit",	(int)&(PL_NULL->transmit),	"%f",
	"tr",		(int)&(PL_NULL->transmit),	"%f",
	"reflect",	(int)&(PL_NULL->reflect),	"%f",
	"re",		(int)&(PL_NULL->reflect),	"%f",
	"ri",		(int)&(PL_NULL->refrac_index),	"%f",
	(char *)0,	0,				(char *)0
d103 3
a105 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (char *)pp );
d129 3
a131 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (char *)pp );
d155 3
a157 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (char *)pp );
d366 1
a366 1
				ipow(cosS,(int)ps->shine);
d373 1
a373 1
		if( rt_g.debug&DEBUG_RAYWRITE )  {
d428 1
a428 1
			if(rt_g.debug&DEBUG_HITS)rt_log("phong: Refracted ray missed '%s' -- RETRYING, lvl=%d\n",
d441 1
a441 7
				VSET( ap->a_color, 0, 1, 0 );	/* green */
#ifdef never
odebug= rt_g.debug;
rt_g.debug = DEBUG_ALLRAYS|DEBUG_BOXING|DEBUG_SHOOT;
rt_shootray( &sub_ap );
rt_g.debug = odebug;
#endif
d448 1
a448 1
		if( rt_g.debug&DEBUG_RAYWRITE )  {
d466 1
a466 1
				if(rt_g.debug) {
d521 2
a522 1
		if(rt_g.debug&DEBUG_HITS)rt_log("phg_rhit:  no hit out front?\n");
d526 4
a529 3
		if(rt_g.debug&DEBUG_HITS)rt_log("phg_rhit:  Ray reflected within %s now in %s!\n",
			((struct region *)(ap->a_user))->reg_name,
			pp->pt_regionp->reg_name );
d535 1
a535 1
/**		if(rt_g.debug&DEBUG_HITS) **/
d551 1
a551 1
		if(rt_g.debug&DEBUG_HITS)
d559 2
a560 1
	if( rt_g.debug && (!NEAR_ZERO(hitp->hit_normal[X], 1.001) ||
d573 1
a573 1
	if(rt_g.debug&DEBUG_HITS) rt_pr_partitions( PartHeadp, "phg_rhit" );
@


1.16
log
@Added 2-character abbreviations
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.15 86/11/10 21:56:50 mike Locked $ (BRL)";
d656 1
a656 1
	FAST fastf_t result;
d658 5
a662 1
	if( d < 1e-8 )  return(0.0);
d665 1
a665 1
		result *= d;
@


1.15
log
@Made default color be white, not red.
Prevents non-color-override objects (esp. glass)
from turning red!
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.14 86/11/07 02:46:11 mike Locked $ (BRL)";
d59 1
d61 1
d63 1
d65 1
d67 1
@


1.14
log
@Changed so that computation of hit_point and hit_norm is done
in the individual material routines, and only as much as needed.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.13 86/11/07 01:46:23 mike Locked $ (BRL)";
d251 2
a252 1
			VSET( mcolor, 1.0, 0.0, 0.0 );	/* default: red */
@


1.13
log
@Changed to perform RT_HIT_NORM() macros where hit_point and hit_norm
are needed.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.12 86/10/26 17:07:02 mike Locked $ (BRL)";
d255 16
d284 1
a284 1
			rt_log("cosI1=%f (x%d,y%d,lvl%d)\n", cosI1,
d295 1
a295 1
			rt_log("cosI2=%f (x%d,y%d,lvl%d)\n", cosI2,
d349 1
a349 1
				rt_log("cosS=%f (x%d,y%d,lvl%d)\n", cosS,
@


1.12
log
@Minor improvements to error colors
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.11 86/08/13 11:00:45 mike Exp $ (BRL)";
d349 1
a349 2
			rt_functab[stp->st_id].ft_norm(
				pp->pt_outhit, stp, &(ap->a_ray) );
d511 4
a514 1
		if(rt_g.debug&DEBUG_HITS)  {
d516 1
a516 1
				pp->pt_inseg->seg_stp->st_name, hitp->hit_dist);
d524 2
a532 3
	stp = pp->pt_outseg->seg_stp;
	rt_functab[stp->st_id].ft_norm(
		hitp, stp, &(ap->a_ray) );
d643 11
a653 1
/* These shadow functions return a boolean "light_visible" */
@


1.11
log
@Made cosI2 more tolerant
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.10 86/08/12 05:50:45 mike Exp $ (BRL)";
d446 1
a446 1
					VSET( ap->a_color, 0, 1, 0 );	/* green */
d448 1
a448 1
					VSET( ap->a_color, .16, .16, .16 );	/* grey */
@


1.10
log
@Changed to find #include files with CC -I../h
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.9 86/08/06 19:59:58 mike Exp $ (BRL)";
d278 1
a278 1
		if( cosI2 > 1 )  {
@


1.9
log
@Print first refraction miss only if debugging is on.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.8 86/07/31 08:28:16 mike Exp $ (BRL)";
d27 4
a30 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/mater.h"
#include "../h/raytrace.h"
d32 2
a33 2
#include "material.h"
#include "mathtab.h"
@


1.8
log
@Added code to handle case where ray hits internal edge of box
while doing refraction code, and reflected ray leaves the
box "unexpectedly".
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.7 86/07/30 03:56:17 mike Exp $ (BRL)";
d401 1
a401 1
			rt_log("phong: Refracted ray missed '%s', lvl=%d\n",
@


1.7
log
@Improved diagnostics
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.6 86/07/29 20:22:07 mike Exp $ (BRL)";
d379 2
d382 7
a388 5
		sub_ap.a_level = ap->a_level * 100;	/* flag */
		sub_ap.a_x = ap->a_x;
		sub_ap.a_y = ap->a_y;
		sub_ap.a_rt_i = ap->a_rt_i;
		if( !phg_refract(ap->a_ray.r_dir, /* Incident ray (IN) */
a393 1
			VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
a396 1
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
d401 1
a401 1
			rt_log("phong: Refracted ray missed %s, lvl=%d\n",
d404 19
a422 1
			goto finish;		/* abandon hope */
d434 2
a435 1
		if( !phg_refract( sub_ap.a_ray.r_dir,	/* input direction */
d498 1
a498 1
		if( pp->pt_outhit->hit_dist > 0.01 )  break;
d500 2
a501 2
		rt_log("phg_rhit:  no hit out front?\n");
		return(0);
d503 6
d512 7
a518 4
		rt_log("phg_rhit:   inhit %g not near zero!\n", hitp->hit_dist);
		rt_pr_hit("inhit", hitp);
		rt_pr_hit("outhit", pp->pt_outhit);
		return(0);
d523 4
a526 2
		rt_log("phg_rhit:  (%g,%g) bad!\n", pp->pt_inhit->hit_dist, hitp->hit_dist);
		return(0);
d534 4
a537 4
	if( rt_g.debug && (!NEAR_ZERO(hitp->hit_normal[X], 1) ||
	    !NEAR_ZERO(hitp->hit_normal[Y], 1) ||
	    !NEAR_ZERO(hitp->hit_normal[Z], 1) ) )  {
	    	rt_log("phg_rhit: TROUBLE refracting in %s\n", stp->st_name);
d539 1
a539 1
	    	return(0);
d544 5
@


1.6
log
@Moved initialization of materials to rt.c
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.5 86/07/24 06:05:05 mike Exp $ (BRL)";
d367 1
a368 3
		sub_ap.a_hit = colorview;
		sub_ap.a_miss = hit_nothing;
		sub_ap.a_rt_i = ap->a_rt_i;
a369 2
		sub_ap.a_rbeam = ap->a_rbeam;
		sub_ap.a_diverge = ap->a_diverge;
d399 3
a401 1
			rt_log("phong: Refracted ray missed, lvl=%d\n",sub_ap.a_level );
d421 2
a422 1
				rt_log("Excessive internal reflection (x%d,y%d, lvl%d)\n",
d477 1
a477 1
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
d485 1
a485 1
		rt_log("phg_rhit:   inhit not near zero!\n");
d487 1
@


1.5
log
@Added uvcoord code, conical ray divergance.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.4 86/07/22 03:53:29 mike Exp $ (BRL)";
d33 1
a76 32

#ifdef BENCHMARK
#define rand0to1()	(0.5)
#define rand_half()	(0)
#else BENCHMARK
/*
 *  			R A N D 0 T O 1
 *
 *  Returns a random number in the range 0 to 1
 */
double rand0to1()
{
	FAST fastf_t f;
	/* On BSD, might want to use random() */
	/* / (double)0x7FFFFFFFL */
	f = ((double)rand()) *
		0.00000000046566128752457969241057508271679984532147;
	if( f > 1.0 || f < 0 )  {
		rt_log("rand0to1 out of range\n");
		return(0.42);
	}
	return(f);
}

/*
 *  			R A N D _ H A L F
 *
 *  Returns a random number in the range -0.5 to +0.5
 */
#define rand_half()	(rand0to1()-0.5)

#endif BENCHMARK
@


1.4
log
@Added some safety checks.
Added ability to handle partitions that start behind the eye.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.3 86/07/19 04:38:49 mike Exp $ (BRL)";
d332 2
d403 2
d469 2
d514 8
@


1.3
log
@Added more stuff
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.2 86/07/17 18:33:01 mike Exp $ (BRL)";
a75 1
#define RI_GLASS	1.3    /* Refractive index of glass.		*/
d122 2
a123 2
	pp->shine = 7;
	pp->wgt_specular = 0.6;
d173 2
a174 2
	pp->transmit = 0.8;
	pp->reflect = 0.4;
d386 4
a389 1
	/* Add in contributions from mirror reflection & transparency */
d407 1
a407 2
		VJOIN1( ap->a_color, ap->a_color,
			ps->reflect, sub_ap.a_color );
d429 6
a434 3
		(void) rt_shootray( &sub_ap );
		/* NOTE: phg_rhit returns EXIT point in sub_ap.a_uvec,
		 *  and returns EXIT normal in sub_ap.a_color.
d449 1
a449 1
			if( ++sub_ap.a_level > 100+MAX_IREFLECT )  {
a482 4
	rt_log("phg_rmiss: Refracted ray missed!\n" );
	/* Return entry point as exit point */
	VREVERSE( ap->a_color, ap->a_ray.r_dir );	/* inward pointing */
	VMOVE( ap->a_uvec, ap->a_ray.r_pt );
d488 4
d498 1
a498 1
	register struct hit	*hitp = PartHeadp->pt_forw->pt_outhit;
d500 1
d502 13
a514 1
	stp = PartHeadp->pt_forw->pt_outseg->seg_stp;
d518 8
d564 1
a564 1
		rt_log("phg_refract:ri1=%f, ri2=%f\n", ri_1, ri_2 );
d568 4
d575 1
d627 9
d637 1
a637 1
	if( PartHeadp->pt_forw->pt_inseg->seg_stp == l0stp )
d666 1
a666 1
hit_nothing( ap )
d668 1
@


1.2
log
@Names shortened for non-FLEXNAMES systems (cray),
and converted to using stdio for all I/O.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.1 86/06/11 00:13:54 mike Exp $ (BRL)";
d111 1
a111 1
 *			P L A S T I C _ S E T U P
d134 8
d143 15
d159 26
a184 1
 *			P L A S T I C _ R E N D E R
d332 1
d397 1
d413 1
d460 1
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: view.c,v 3.0 86/06/10 01:32:32 mike Exp $ (BRL)";
d46 1
a46 1
struct plastic_specific {
d54 1
a54 1
#define PL_NULL	((struct plastic_specific *)0)
d56 1
a56 1
struct matparse plastic_parse[] = {
d66 4
a69 4
extern int plastic_render();
HIDDEN int plastic_rfr_miss();
HIDDEN int plastic_rfr_hit();
HIDDEN int plastic_refract();
d114 1
a114 1
plastic_setup( rp )
d117 1
a117 1
	register struct plastic_specific *pp;
d119 2
a120 2
	GETSTRUCT( pp, plastic_specific );
	rp->reg_ufunc = plastic_render;
d130 1
a130 2
	matlib_parse( rp->reg_mater.ma_matparm, plastic_parse, (char *)pp );
	matlib_print( "plastic", plastic_parse, (char *)pp );
d201 1
a201 1
plastic_render( ap, pp )
d217 2
a218 2
	struct plastic_specific *ps =
		(struct plastic_specific *)pp->pt_regionp->reg_udata;
d363 1
a363 1
		if( !plastic_refract(ap->a_ray.r_dir, /* Incident ray (IN) */
d375 2
a376 2
		sub_ap.a_hit =  plastic_rfr_hit;
		sub_ap.a_miss = plastic_rfr_miss;
d378 1
a378 1
		/* NOTE: plastic_rfr_hit returns EXIT point in sub_ap.a_uvec,
d388 1
a388 1
		if( !plastic_refract( sub_ap.a_ray.r_dir,	/* input direction */
d423 1
a423 1
plastic_rfr_miss( ap, PartHeadp )
d427 1
a427 1
	rt_log("plastic_rfr_miss: Refracted ray missed!\n" );
d438 1
a438 1
plastic_rfr_hit( ap, PartHeadp )
d477 1
a477 1
plastic_refract( v_1, norml, ri_1, ri_2, v_2 )
d486 2
a487 2
	if( NEAR_ZERO(ri_1) || NEAR_ZERO( ri_2 ) )  {
		rt_log("plastic_refract:ri1=%f, ri2=%f\n", ri_1, ri_2 );
@
