head	11.11;
access;
symbols
	ansi-20040405-merged:11.7.2.2
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.8
	postmerge-autoconf:11.8
	autoconf-freeze:11.8
	premerge-autoconf:11.8
	postmerge-20040315-windows:11.8
	premerge-20040315-windows:11.8
	windows-20040315-freeze:11.7.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.4
	phong-branch:11.8.0.2
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.4
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.5
	offsite-5-3-pre:11.5
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.17.31.05;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2003.08.02.23.12.45;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.7.2.1
	11.7.4.1
	11.7.6.1;
next	11.6;

11.6
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2000.01.12.00.33.24;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.05.28.01.17.25;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.03.29.21.55.48;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.50;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.11.00.38.32;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.11.17.00.29.51;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.55;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.05.59.18;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.04.13.00.44.57;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.13;	author mike;	state Rel3_0;
branches;
next	1.1;

1.1
date	88.07.07.23.51.28;	author phil;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	11.7.2.2;

11.7.2.2
date	2004.03.17.21.22.58;	author morrison;	state Exp;
branches;
next	;

11.7.4.1
date	2004.03.11.23.48.06;	author morrison;	state Exp;
branches;
next	;

11.7.6.1
date	2003.08.26.13.57.18;	author justin;	state Exp;
branches;
next	;


desc
@A trivial, commented, librt application example
@


11.11
log
@moved to src/rt/
@
text
@/*
 *			R T E X A M P L E . C
 *
 *  A trivial example of a program that uses librt.  With comments.
 *
 *    cc -I/usr/include/brlcad -o rtexample rtexample.c librt.a -lm
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"		/* machine specific definitions */
#include "vmath.h"		/* vector math macros */
#include "raytrace.h"		/* librt interface definitions */

/* every application needs one of these */
struct application	ap;

/* routines for shootray() to call on hit or miss */
extern int hit(struct application *ap, struct partition *PartHeadp), miss(register struct application *ap);

char	usage[] = "\
Usage:  rtexample model.g objects...\n";

main(int argc, char **argv)
{
	static struct rt_i *rtip;	/* rt_dirbuild returns this */
	char idbuf[132];		/* First ID record info */

	if( argc < 3 )  {
		(void)fputs(usage, stderr);
		exit(1);
	}

	/*
	 *  Load database.
	 *  rt_dirbuild() returns an "instance" pointer which describes
	 *  the database to be ray traced.  It also gives you back the
	 *  title string in the header (ID) record.
	 */
	if( (rtip=rt_dirbuild(argv[1], idbuf, sizeof(idbuf))) == RTI_NULL ) {
		fprintf(stderr,"rtexample: rt_dirbuild failure\n");
		exit(2);
	}
	ap.a_rt_i = rtip;	/* your application uses this instance */
	fprintf(stderr, "db title: %s\n", idbuf);

	/* Walk trees.
	 * Here you identify any object trees in the database that you
	 * want included in the ray trace.
	 */
	while( argc > 2 )  {
		if( rt_gettree(rtip, argv[2]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[0]);
		argc--;
		argv++;
	}
	/*
	 * This next call gets the database ready for ray tracing.
	 * (it precomputes some values, sets up space partitioning, etc.)
	 */
	rt_prep_parallel(rtip,1);

	/*
	 * Set the ray start point and direction
	 * rt_shootray() uses these two to determine what ray to fire.
	 * In this case we simply shoot down the z axis toward the
	 * origin from 10 meters away [librt assumes units of millimeters.
	 * not that is really maters here, but an MGED database made with
	 * units=mm will have the same values in the file (and thus in
	 * librt) that you see displayed by MGED.
	 */
	VSET( ap.a_ray.r_pt, 0, 0, 10000 );
	VSET( ap.a_ray.r_dir, 0, 0, -1 );

	VPRINT( "Pnt", ap.a_ray.r_pt );
	VPRINT( "Dir", ap.a_ray.r_dir );

	/* Shoot Ray */
	ap.a_hit = hit;			/* where to go on a hit */
	ap.a_miss = miss;		/* where to go on a miss */
	(void)rt_shootray( &ap );	/* do it */

	/*
	 * A real application would probably set up another
	 * ray and fire again.
	 */

	return(0);
}

/*
 *  rt_shootray() was told to call this on a hit.  He gives up the
 *  application structure which describes the state of the world
 *  (see raytrace.h), and a circular linked list of partitions,
 *  each one describing one in and out segment of one region.
 */
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
{
	/* see raytrace.h for all of these guys */
	register struct partition *pp;
	register struct hit *hitp;
	register struct soltab *stp;
	struct curvature cur;
	point_t		pt;
	vect_t		inormal;
	vect_t		onormal;

	/* examine each partition until we get back to the head */
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
		bu_log("\n--- Hit region %s (in %s, out %s)\n",
			pp->pt_regionp->reg_name,
			pp->pt_inseg->seg_stp->st_name,
			pp->pt_outseg->seg_stp->st_name );

		/* inhit info */
		hitp = pp->pt_inhit;
		stp = pp->pt_inseg->seg_stp;

		VJOIN1( pt, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );

		/* This macro takes care of the flip flag and all that */
		RT_HIT_NORMAL( inormal, hitp, stp, &(ap->a_ray), pp->pt_inflip );

		rt_pr_hit( "  In", hitp );
		VPRINT(    "  Ipoint", pt );
		VPRINT(    "  Inormal", inormal );
		/*
		 * This next macro fills in the curvature information
		 * which consists on a principle direction vector, and
		 * the inverse radii of curvature along that direction
		 * and perpendicular to it.  Positive curvature bends
		 * toward the outward pointing normal.
		 */
		RT_CURVATURE( &cur, hitp, pp->pt_inflip, stp );
		VPRINT("PDir", cur.crv_pdir );
		bu_log(" c1=%g\n", cur.crv_c1);
		bu_log(" c2=%g\n", cur.crv_c2);

		/* outhit info */
		hitp = pp->pt_outhit;
		stp = pp->pt_outseg->seg_stp;
		VJOIN1( pt, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
		RT_HIT_NORMAL( onormal, hitp, stp, &(ap->a_ray), pp->pt_outflip );

		rt_pr_hit( "  Out", hitp );
		VPRINT(    "  Opoint", pt );
		VPRINT(    "  Onormal", onormal );
	}

	/*
	 * A more complicated application would probably fill in a
	 * new local application structure and describe say a reflected
	 * or refracted ray, and then call rt_shootray with it.
	 */

	/*
	 * This value is returned by rt_shootray
	 * a hit usually returns 1, miss 0.
	 */
	return(1);
}

/*
 * rt_shootray() was told to call this on a miss.
 */
miss(register struct application *ap)
{
	bu_log("missed\n");
	return(0);
}
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@@


11.9
log
@merge of ansi-6-0-branch into head
@
text
@d8 5
a12 1
#include "conf.h"
@


11.8
log
@ANSI C style hit routine declaration
@
text
@d20 1
a20 1
extern int hit(), miss();
d25 1
a25 3
main(argc, argv)
int argc;
char **argv;
d98 1
a98 3
hit(register struct application *ap,
    struct partition *PartHeadp,
    struct seg	*segs)
d167 1
a167 2
miss( ap )
register struct application *ap;
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d100 3
a102 3
hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
@


11.7.4.1
log
@sync to HEAD...
@
text
@d100 3
a102 3
hit(register struct application *ap,
    struct partition *PartHeadp,
    struct seg	*segs)
@


11.7.6.1
log
@updated for merging
@
text
@d100 3
a102 3
hit(register struct application *ap,
    struct partition *PartHeadp,
    struct seg	*segs)
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
extern int hit(struct application *ap, struct partition *PartHeadp), miss(register struct application *ap);
d25 3
a27 1
main(int argc, char **argv)
d100 3
a102 1
hit(register struct application *ap, struct partition *PartHeadp)
d171 2
a172 1
miss(register struct application *ap)
@


11.7.2.2
log
@sync branch with HEAD
@
text
@d98 1
a98 1
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d20 1
a20 1
extern int hit(struct application *ap, struct partition *PartHeadp), miss(register struct application *ap);
d25 3
a27 1
main(int argc, char **argv)
d100 3
a102 1
hit(register struct application *ap, struct partition *PartHeadp)
d171 2
a172 1
miss(register struct application *ap)
@


11.5
log
@
Changed to use rt_prep_parallel(), for illustrative purposes.
@
text
@d20 1
a20 1
extern int hit(), miss();
d25 1
a25 3
main(argc, argv)
int argc;
char **argv;
d98 1
a98 3
hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
d167 1
a167 2
miss( ap )
register struct application *ap;
@


11.4
log
@
sed4
@
text
@d64 1
a64 1
	rt_prep(rtip);
@


11.3
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d115 1
a115 1
		rt_log("\n--- Hit region %s (in %s, out %s)\n",
d141 2
a142 2
		rt_log(" c1=%g\n", cur.crv_c1);
		rt_log(" c2=%g\n", cur.crv_c2);
d174 1
a174 1
	rt_log("missed\n");
@


11.2
log
@Changed to use new curvature macro.
@
text
@d109 3
a111 2
	struct hit	ihit;
	struct hit	ohit;
d123 9
a131 22
		/*
		 * This next macro fills in the normal and hit_point in hitp.
		 * If you just want the hit point, get it from the hit
		 * distance by:
		 * VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
		 */
		RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
		/*
		 * If the flip flag is on, it means that the outward
		 * pointing normal actually points the other way so we
		 * need to reverse it.  The application is responsible
		 * for doing this because it's just a reference to the
		 * actual hit point on the segment, and may be referred to
		 * in it's non-flipped sense in the next (or previous)
		 * partition.  It is this sharing which requires the
		 * application to make it's own copy of the hit, too.
		 */
		ihit = *hitp;	/* struct copy */
		if( pp->pt_inflip ) {
			VREVERSE( ihit.hit_normal, ihit.hit_normal );
		}
		rt_pr_hit( "  In", &ihit );
d139 1
a139 1
		RT_CURVATURE( &cur, &ihit, pp->pt_inflip, stp );
d147 6
a152 6
		RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
		ohit = *hitp;		/* struct copy */
		if( pp->pt_outflip ) {
			VREVERSE( ohit.hit_normal, ohit.hit_normal );
		}
		rt_pr_hit( " Out", &ohit );
@


11.1
log
@Release_4.4
@
text
@d151 1
a151 1
		RT_CURVE( &cur, &ihit, stp );
@


10.3
log
@Added include of conf.h
@
text
@@


10.2
log
@Clarified handling of normals.
@
text
@d8 2
@


10.1
log
@Release_4.0
@
text
@d107 2
d131 5
a135 1
		 * for doing this for some rather complicated reasons.
d137 1
d139 1
a139 2
			VREVERSE( hitp->hit_normal, hitp->hit_normal );
			pp->pt_inflip = 0;
d141 1
a141 1
		rt_pr_hit( "  In", hitp );
d149 1
a149 1
		RT_CURVE( &cur, hitp, stp );
d158 1
d160 1
a160 2
			VREVERSE( hitp->hit_normal, hitp->hit_normal );
			pp->pt_outflip = 0;
d162 1
a162 1
		rt_pr_hit( " Out", hitp );
@


9.1
log
@Release_3.5
@
text
@@


8.2
log
@Fixed header files
@
text
@@


8.1
log
@Release_3.0
@
text
@d6 1
a6 1
 *    cc -o rtexample rtexample.c librt.a -lm
d10 3
a12 3
#include <brlcad/machine.h>		/* machine specific definitions */
#include <brlcad/vmath.h>		/* vector math macros */
#include <brlcad/raytrace.h>		/* librt interface definitions */
@


1.1
log
@Initial revision
@
text
@@
