head	1.36;
access;
symbols
	rel-4-5:1.30;
locks; strict;
comment	@ * @;


1.36
date	98.09.22.01.43.11;	author mike;	state dead;
branches;
next	1.35;

1.35
date	98.09.11.17.05.09;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	98.07.12.18.44.17;	author butler;	state Exp;
branches;
next	1.33;

1.33
date	98.06.30.22.54.17;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	98.06.15.13.20.14;	author butler;	state Exp;
branches;
next	1.31;

1.31
date	98.03.08.19.53.15;	author butler;	state Exp;
branches;
next	1.30;

1.30
date	98.01.16.04.55.06;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	98.01.12.22.26.41;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	98.01.12.21.18.20;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	98.01.12.19.59.07;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	98.01.12.19.24.12;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	98.01.12.18.44.36;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	98.01.12.11.24.10;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	98.01.12.10.56.43;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	98.01.12.09.39.00;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	98.01.12.05.58.25;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	98.01.12.04.53.06;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	98.01.12.01.44.16;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	98.01.10.13.26.51;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	98.01.09.10.49.34;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	98.01.08.05.22.49;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	98.01.07.05.58.07;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	97.12.31.06.31.36;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	97.12.19.07.56.50;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	97.12.18.08.49.03;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	97.12.17.23.16.01;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	97.12.10.09.22.24;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	97.12.10.07.04.59;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	97.12.10.06.51.58;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	97.12.09.04.47.24;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	97.11.25.22.20.26;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	97.11.18.05.53.40;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	97.11.14.04.00.33;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	97.11.11.23.33.03;	author butler;	state Exp;
branches;
next	;


desc
@Voulmetric grass effect
@


1.36
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@/*
 *	S H _ G R A S S . C
 *
 *	A procedural shader to produce grass
 *
 */
#include "conf.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "plot3.h"
#include "raytrace.h"
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"

#ifndef M_PI
#define M_PI            3.14159265358979323846
#endif

#define SHADE_CONT	0
#define SHADE_ABORT_GRASS	1	/* bit_flag */
#define SHADE_ABORT_STACK	2	/* bit_flag */

#define CLAMP(_x,_a,_b)     (_x < _a ? _a : (_x > _b ? _b : _x))

#define grass_MAGIC 0x1834    /* make this a unique number for each shader */
#define CK_grass_SP(_p) RT_CKMAG(_p, grass_MAGIC, "grass_specific")

/* compute the Region coordinates of the origin of a cell */
#define CELL_POS(cell_pos, grass_sp, cell_num) \
	cell_pos[X] = cell_num[X] * grass_sp->cell[X]; \
	cell_pos[Y] = cell_num[Y] * grass_sp->cell[Y]

#define BLADE_SEGS_MAX 4

#define LEAF_MAGIC 1024
#define BLADE_MAGIC 1023
#define PLANT_MAGIC 1022

struct leaf_segment {
	long	magic;
	double len;	/* length of blade segment */
	vect_t blade;	/* direction of blade growth */ 
	vect_t	N;	/* surface normal of blade segment */
};

struct blade {
	long			magic;
	double			width;
	double			tot_len;	/* total length of blade */
	int			segs;		/* # of segments in blade */
	struct leaf_segment	leaf[BLADE_SEGS_MAX];	/* segments */
	point_t			pmin;		/* blade bbox min */
	point_t			pmax;		/* blade bbox max */
};

#define BLADE_MAX 6
#define BLADE_LAST (BLADE_MAX-1)
struct plant {
	long		magic;
	point_t		root;		/* location of base of blade */
	int 		blades;		/* # of blades from same root */
	struct blade	b[BLADE_MAX];	/* blades */
	point_t		pmin;		/* plant bbox min */
	point_t		pmax;		/* plant bbox max */
};

#define GRASSRAY_MAGIC 2048
struct grass_ray {
	long		magic;
	double		occlusion;
	struct xray	r;
	double		d_min;
	double		d_max;
	vect_t		rev;
	double		diverge;
	double		radius;
	struct bn_tol	tol;
	struct hit	hit;
	FILE 		*fd;
	struct application *ap;
};
#define grass_ray_MAGIC 0x2461
#define CK_grass_r(_p) RT_CKMAG(_p, grass_ray_MAGIC, "grass_ray")

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct grass_specific {
	long	magic;	/* magic # for memory validity check, must come 1st */
	int	debug;
	FILE 	*fd;
	double	cell[2];	/* size of a cell in Region coordinates */
	double	ppc;		/* mean # plants_per_cell */
	double	ppcd;		/* deviation of plants_per_cell */
	double	t;		/* mean length of leaf segment */
	double	blade_width;	/* max width of blade segment */
	int	nsegs;		/* #segs per blade */
	double	seg_ratio;
	double	lacunarity;	/* the usual noise parameters */
	double	h_val;
	double	octaves;
	double	size;		/* size of noise coordinate space */
	point_t	vscale;		/* size of noise coordinate space */
	vect_t	delta;
	point_t brown;
	struct	plant proto;

	mat_t	m_to_sh;	/* model to shader space matrix */
	mat_t	sh_to_m;	/* model to shader space matrix */
};

/* The default values for the variables in the shader specific structure */
static CONST
struct grass_specific grass_defaults = {
	grass_MAGIC,
	0,
	(FILE *)0,
	{400.0, 400.0},			/* cell */
	5.0,				/* plants_per_cell */
	3.0,				/* deviation of plants_per_cell */
	300.0,				/* "t" mean length of leaf (mm)*/
	3.0,				/* max width (mm) of blade segment */
	4,				/* # segs per blade */
	1.0,				/* seg ratio */
	2.1753974,			/* lacunarity */
	1.0,				/* h_val */
	4.0,				/* octaves */
	.31415926535,			/* size */
	{ 1.0, 1.0, 1.0 },		/* vscale */
	{ 1001.6, 1020.5, 1300.4 },	/* delta into noise space */
	{.7, .6, .3},	
	{	0.0, 0.0, 0.0, 0.0,	/* m_to_sh */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 }
	};

#define SHDR_NULL	((struct grass_specific *)0)
#define SHDR_O(m)	offsetof(struct grass_specific, m)
#define SHDR_AO(m)	offsetofarray(struct grass_specific, m)

/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse grass_print_tab[] = {
	{"%f",  2, "cell",		SHDR_AO(cell),		FUNC_NULL },
	{"%f",	1, "ppc",		SHDR_O(ppc),		FUNC_NULL },
	{"%f",	1, "ppcd",		SHDR_O(ppcd),		FUNC_NULL },
	{"%f",	1, "t",			SHDR_O(t),		FUNC_NULL },
	{"%f",	1, "width",		SHDR_O(blade_width),	FUNC_NULL },
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "size",		SHDR_O(size),		FUNC_NULL },
	{"%d",	1, "nsegs",		SHDR_O(nsegs),		FUNC_NULL },
	{"%f",	1, "seg_ratio",		SHDR_O(seg_ratio),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }

};
struct bu_structparse grass_parse_tab[] = {
	{"i",	bu_byteoffset(grass_print_tab[0]), "grass_print_tab", 0, FUNC_NULL },
	{"%f",  2, "c",			SHDR_AO(cell),		FUNC_NULL },
	{"%f",	1, "p",			SHDR_O(ppc),		FUNC_NULL },
	{"%f",	1, "pd",		SHDR_O(ppcd),		FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "s",			SHDR_O(size),		FUNC_NULL },
	{"%f",	1, "w",			SHDR_O(blade_width),	FUNC_NULL },
	{"%d",	1, "n",			SHDR_O(nsegs),		FUNC_NULL },
	{"%f",	1, "r",			SHDR_O(seg_ratio),	FUNC_NULL },
	{"%d",	1, "d",			SHDR_O(debug),		FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
};

HIDDEN int	grass_setup(), grass_render();
HIDDEN void	grass_print(), grass_free();

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs grass_mfuncs[] = {
	{MF_MAGIC,	"grass",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,  MFF_PROC,
	grass_setup,	grass_render,	grass_print,	grass_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

/* fraction of total allowed returned */
static double
plants_this_cell(cell, grass_sp)
long cell[3];	/* integer cell number */
struct grass_specific *grass_sp;
{
	point_t c;
	double val;

	VSCALE(c, cell, grass_sp->size);  /* int/float conv */
	VADD2(c, c, grass_sp->delta);

	val = fabs(bn_noise_fbm(c, grass_sp->h_val, grass_sp->lacunarity,
			grass_sp->octaves));
	
	val = CLAMP(val, 0.0, 1.0);

	return val;
}

static void
print_plant(str, plant)
char *str;
CONST struct plant *plant;
{
	int blade, seg;

  	bu_log("%s: %d blades\n", str, plant->blades);
	bu_log(" root: %g %g %g\n", V3ARGS(plant->root));

  	for (blade=0 ; blade < plant->blades ; blade++) {
  		bu_log("  blade %d  segs:%d tot_len:%g\n",
  			blade, plant->b[blade].segs, plant->b[blade].tot_len);
  		bu_log("    min:%g %g %g  max:%g %g %g\n",
  			V3ARGS(plant->b[blade].pmin),
  			V3ARGS(plant->b[blade].pmax));
  		for (seg=0 ; seg < plant->b[blade].segs ; seg++) {
  			bu_log("    leaf[%d](%g %g %g) %g\n", seg,
  				V3ARGS(plant->b[blade].leaf[seg].blade),
  				plant->b[blade].leaf[seg].len );
  		}
  	}
}
/*
 *	Rotate a blade about the Z axis, compute blade bounding box
 *
 */
static void
blade_rot(o, i, m, root)
struct blade *o;
struct blade *i;
mat_t m;
CONST point_t root;
{
	struct blade tmp;
	int seg;
	point_t pt;

	if (i == o) {
		tmp = *i;	/* struct copy */
		i = &tmp;
	}
	VMOVE(pt, root);
	VMOVE(o->pmin, root);
	VMOVE(o->pmax, root);

	o->segs = i->segs;
	o->tot_len = 0.0;
	for (seg=0 ; seg < i->segs ; seg++) {
		o->leaf[seg].magic = i->leaf[seg].magic;
		MAT4X3VEC(o->leaf[seg].blade, m, i->leaf[seg].blade);
		MAT4X3VEC(o->leaf[seg].N, m, i->leaf[seg].N);
		o->leaf[seg].len = i->leaf[seg].len;
		o->tot_len += i->leaf[seg].len;

		VJOIN1(pt, pt, o->leaf[seg].len, o->leaf[seg].blade);
		VMINMAX(o->pmin, o->pmax, pt);
	}
}
static void
plant_rot(pl, a)
struct plant *pl;
double a;
{
	int blade;
	mat_t m;

	bn_mat_zrot(m, sin(a), cos(a));

	for (blade=0 ; blade < pl->blades ; blade++) {
		blade_rot(&pl->b[blade], &pl->b[blade], m, pl->root);
	}
}

/*
 * decide how many blades to use, and how long the blades will be
 *
 */
static void
plant_scale(pl, w)
struct plant *pl;
double w;	/* 0..1, */
{
	int blade, seg;
	double d;

	if (rdebug&RDEBUG_SHADE)
		bu_log("plant_scale(%g)\n", w);

	d = 1.0 - w;

	/* decide the number of blades */
	if (d < .8) {
		pl->blades -= d * pl->blades * .5;
		pl->blades = CLAMP(pl->blades, 1, BLADE_LAST);
	} 

	for (blade=0 ; blade < pl->blades ; blade++) {
		pl->b[blade].tot_len = 0.0;
		if (blade != BLADE_LAST)
			pl->b[blade].width *= d;
		else
			d *= d;

		for (seg=0; seg < pl->b[blade].segs ; seg++) {
			pl->b[blade].leaf[seg].len *= d;

			pl->b[blade].tot_len += pl->b[blade].leaf[seg].len;
		}
	}

}

/*
 *	Make a prototype blade we can copy for use later
 *	Doesn't set bounding box.
 */
static void
make_proto(grass_sp)
struct grass_specific *grass_sp;
{
  static CONST point_t z_axis = { 0.0, 0.0, 1.0 };
  vect_t left;
  int blade, seg;
  mat_t m, r;
  double start_angle;
  double seg_delta_angle;
  double angle;
  double val, tmp;
  double seg_len;

  grass_sp->proto.magic = PLANT_MAGIC;
  VSETALL(grass_sp->proto.root, 0.0);
  VMOVE(grass_sp->proto.pmin, grass_sp->proto.root);
  VMOVE(grass_sp->proto.pmax, grass_sp->proto.root);

  grass_sp->proto.blades = BLADE_MAX;

  /* First we make blade 0.  This blade will be used as the prototype
   * for all the other blades.  Most significantly, the others are just
   * a rotation/scale of this first one.
   */
  bn_mat_zrot(r, sin(bn_degtorad*137.0), cos(bn_degtorad*137.0));
  bn_mat_copy(m,r);

  seg_delta_angle = (87.0 / (double)BLADE_SEGS_MAX);

  for (blade=0 ; blade < BLADE_LAST ; blade++) {
    val = (double)blade / (double)(BLADE_LAST);

    grass_sp->proto.b[blade].magic = BLADE_MAGIC;
    grass_sp->proto.b[blade].tot_len = 0.0;
    grass_sp->proto.b[blade].width = grass_sp->blade_width;
    grass_sp->proto.b[blade].segs = BLADE_SEGS_MAX 
    	/* - (val*BLADE_SEGS_MAX*.25) */   ;


    /* pick a start angle for the first segment */
    start_angle = 55.0 + 30.0 * (1.0-val);
    seg_len = grass_sp->t / grass_sp->proto.b[blade].segs;

    for (seg=0 ; seg < grass_sp->proto.b[blade].segs; seg++) {
        grass_sp->proto.b[blade].leaf[seg].magic = LEAF_MAGIC;

    	angle = start_angle - (double)seg * seg_delta_angle;
    	angle *= bn_degtorad;
        VSET(grass_sp->proto.b[blade].leaf[seg].blade,
        	cos(angle), 0.0, sin(angle));

    	/* pick a length for the blade */
    	tmp = (double)seg / (double)BLADE_SEGS_MAX;



	grass_sp->proto.b[blade].leaf[seg].len =
#if 1
    	seg_len * .25 + tmp * (seg_len*1.75);
#else
    	    (grass_sp->t*.8) + seg * (grass_sp->t*.5);
#endif
        grass_sp->proto.b[blade].tot_len +=
    	     grass_sp->proto.b[blade].leaf[seg].len;


        VUNITIZE(grass_sp->proto.b[blade].leaf[seg].blade);
        VCROSS(left, grass_sp->proto.b[blade].leaf[seg].blade, z_axis);
        VUNITIZE(left);
        VCROSS(grass_sp->proto.b[blade].leaf[seg].N,
      		left, grass_sp->proto.b[blade].leaf[seg].blade);
        VUNITIZE(grass_sp->proto.b[blade].leaf[seg].N);
    }
    blade_rot(&grass_sp->proto.b[blade], &grass_sp->proto.b[blade], m, grass_sp->proto.root);
    bn_mat_mul2(r, m);
  }


  /* The central stalk is a bit different.  It's basically a straight tall
   * shaft
   */
  blade = BLADE_LAST;
  grass_sp->proto.b[blade].magic = BLADE_MAGIC;
  grass_sp->proto.b[blade].tot_len = 0.0;
  grass_sp->proto.b[blade].segs = BLADE_SEGS_MAX;
  grass_sp->proto.b[blade].width = grass_sp->blade_width * 0.5;


  seg_len = .75 * grass_sp->t / grass_sp->proto.b[blade].segs;
  val = .9;
  for (seg=0 ; seg < grass_sp->proto.b[blade].segs ; seg++) {
    tmp = (double)seg / (double)BLADE_SEGS_MAX;

    grass_sp->proto.b[blade].leaf[seg].magic = LEAF_MAGIC;
    
    VSET(grass_sp->proto.b[blade].leaf[seg].blade, 0.0, .1, val);
    VUNITIZE(grass_sp->proto.b[blade].leaf[seg].blade);


    grass_sp->proto.b[blade].leaf[seg].len = seg_len;

    grass_sp->proto.b[blade].tot_len += grass_sp->proto.b[blade].leaf[seg].len;

    VCROSS(left, grass_sp->proto.b[blade].leaf[seg].blade, z_axis);
    VUNITIZE(left);
    VCROSS(grass_sp->proto.b[blade].leaf[seg].N,
      		left, grass_sp->proto.b[blade].leaf[seg].blade);
    VUNITIZE(grass_sp->proto.b[blade].leaf[seg].N);

    val -= tmp * .4;
  }

  if( rdebug&RDEBUG_SHADE) {
  	print_plant("proto", &grass_sp->proto);
  }


}

/*	G R A S S _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
grass_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct rt_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
{
	register struct grass_specific	*grass_sp;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	RT_VLS_CHECK( matparm );
	RT_CK_REGION(rp);


	if( rdebug&RDEBUG_SHADE)
		rt_log("grass_setup(%s)\n", rp->reg_name);

	/* Get memory for the shader parameters and shader-specific data */
	GETSTRUCT( grass_sp, grass_specific );
	*dpp = (char *)grass_sp;

	/* initialize the default values for the shader */
	memcpy(grass_sp, &grass_defaults, sizeof(struct grass_specific) );

	if (rp->reg_aircode == 0) {
		bu_log("%s\n%s\n",
		"*** WARNING: grass shader applied to non-air region!!! ***",
		"Set air flag with \"edcodes\" in mged");
		rt_bomb("");
	}

	/* parse the user's arguments for this use of the shader. */
	if( bu_struct_parse( matparm, grass_parse_tab, (char *)grass_sp ) < 0 )
		return(-1);

	/* The shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation).
	 * We need to get a matrix to perform the appropriate transform(s).
	 */
	db_region_mat(grass_sp->m_to_sh, rtip->rti_dbip, rp->reg_name);

	mat_inv(grass_sp->sh_to_m, grass_sp->m_to_sh);

	if( rdebug&RDEBUG_SHADE) {

		bu_struct_print( " Parameters:", grass_print_tab, (char *)grass_sp );
		mat_print( "m_to_sh", grass_sp->m_to_sh );
		mat_print( "sh_to_m", grass_sp->sh_to_m );
	}

	if (grass_sp->proto.magic != PLANT_MAGIC) {
		make_proto(grass_sp);
	}


	return(1);
}

/*
 *	G R A S S _ P R I N T
 */
HIDDEN void
grass_print( rp, dp )
register struct region *rp;
char	*dp;
{
	bu_struct_print( rp->reg_name, grass_print_tab, (char *)dp );
}

/*
 *	G R A S S _ F R E E
 */
HIDDEN void
grass_free( cp )
char *cp;
{
	rt_free( cp, "grass_specific" );
}

static void
plot_bush(pl, r)
struct plant 		*pl;
struct grass_ray	*r;
{
	int blade, seg;
	point_t pt;

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	pl_color(r->fd, 150, 250, 150);

	for (blade=0 ; blade < pl->blades ; blade++) {

		VMOVE(pt, pl->root);
		pdv_3move(r->fd, pt);

		for (seg=0 ; seg < pl->b[blade].segs ; seg++ ) {

			VJOIN1(pt, pt,  pl->b[blade].leaf[seg].len,
				 pl->b[blade].leaf[seg].blade);

			pdv_3cont(r->fd, pt);
		}
	}

#if 1
	/* plot bounding Box */
	pl_color(r->fd, 100, 200, 100);
	pdv_3move(r->fd, pl->pmin);
	pd_3cont(r->fd, pl->pmin[X], pl->pmin[Y], pl->pmin[Z]);
	pd_3cont(r->fd, pl->pmax[X], pl->pmin[Y], pl->pmin[Z]);
	pd_3cont(r->fd, pl->pmax[X], pl->pmax[Y], pl->pmin[Z]);
	pd_3cont(r->fd, pl->pmin[X], pl->pmax[Y], pl->pmin[Z]);
	pd_3cont(r->fd, pl->pmin[X], pl->pmin[Y], pl->pmin[Z]);

	pd_3cont(r->fd, pl->pmin[X], pl->pmin[Y], pl->pmax[Z]);
	pd_3cont(r->fd, pl->pmax[X], pl->pmin[Y], pl->pmax[Z]);
	pd_3cont(r->fd, pl->pmax[X], pl->pmax[Y], pl->pmax[Z]);
	pd_3cont(r->fd, pl->pmin[X], pl->pmax[Y], pl->pmax[Z]);
	pd_3cont(r->fd, pl->pmin[X], pl->pmin[Y], pl->pmax[Z]);

#endif
	pl_color(r->fd, 255, 255, 255);
	bu_semaphore_release(BU_SEM_SYSCALL);
}
static void
make_bush(pl, seed, cell_pos, grass_sp, w, r)
struct plant 			*pl;
double 				seed;	/* derived from cell_num */
CONST point_t			cell_pos;
CONST struct grass_specific 	*grass_sp;
double				w; /* cell specific weght for count, height */
struct grass_ray		*r;
{
	point_t pt;
	int blade, seg;
	unsigned idx;

	if (rdebug&RDEBUG_SHADE)
		bu_log("make_bush(%g, ... %g)\n", seed, w);

	CK_grass_SP(grass_sp);

	*pl = grass_sp->proto; /* struct copy */

	/* get coordinates for the plant root within the cell */
	VMOVE(pl->root, cell_pos);
	pl->root[Z] = 0.0;

	BN_RANDSEED(idx, seed);
	pl->root[X] += BN_RANDOM(idx) * grass_sp->cell[X];

	pl->root[Y] += BN_RANDOM(idx) * grass_sp->cell[Y];

	/* set up for bounding box computation */
	VADD2(pl->pmin, pl->pmin, pl->root);
	VADD2(pl->pmax, pl->pmax, pl->root);

	VSCALE(pt, pl->root, grass_sp->size);

	plant_scale(pl, w);	/* must come first */
	plant_rot(pl, BN_RANDOM(idx) * M_PI * 2.0);/* computes bounding box */

	/* set bounding boxes */
	for (blade=0 ; blade < pl->blades ; blade++) {
		VMOVE(pt, pl->root);
		for (seg=0 ; seg < pl->b[blade].segs ; seg++ ) {
			VJOIN1(pt, pt, pl->b[blade].leaf[seg].len,
				pl->b[blade].leaf[seg].blade);

			VMINMAX(pl->b[blade].pmin, pl->b[blade].pmax, pt);
		}
		VMINMAX(pl->pmin, pl->pmax, pl->b[blade].pmin);
		VMINMAX(pl->pmin, pl->pmax, pl->b[blade].pmax);
	}
	if (rdebug&RDEBUG_SHADE && r->fd) plot_bush(pl, r);
}



/*	Intersect ray with leaf segment.  We already know we're within
 *	max width of the segment.
 *
 */
static void
hit_blade(bl, r, swp, grass_sp, seg, ldist, blade_num, fract)
CONST struct blade *bl;
struct grass_ray *r;
struct shadework	*swp;	/* defined in material.h */
CONST struct grass_specific *grass_sp;
int seg;
double ldist[2];
int blade_num;
double fract;
{
	CK_grass_SP(grass_sp);
	BU_CKMAG(r, GRASSRAY_MAGIC, "grass_ray");


	/* get the hit point/PCA */
	if (rdebug&RDEBUG_SHADE)
		bu_log("\t  hit_blade()\n");

	r->occlusion = 1.0;
	return;


	if (ldist[0] < r->hit.hit_dist) {

		/* we're the closest hit on the cell */
		r->hit.hit_dist = ldist[0];
		VJOIN1(r->hit.hit_point, r->r.r_pt, ldist[0], r->r.r_dir);

		if (VDOT(bl->leaf[seg].N, r->r.r_dir) > 0.0) {
			VREVERSE(r->hit.hit_normal, bl->leaf[seg].N);
		} else {
			VMOVE(r->hit.hit_normal, bl->leaf[seg].N);
		}

		if (blade_num == BLADE_LAST) {
			vect_t brown;
			double d;

			d = (1.0-fract) * .4;
			VSCALE(swp->sw_color, swp->sw_color, d);
			d = 1.0 - d;

			VSCALE(brown, grass_sp->brown, d);

			VADD2(swp->sw_color, swp->sw_color, brown);
		}
		fract = fract * 0.25 + .75;
		VSCALE(swp->sw_color, swp->sw_color, fract);

		if (rdebug&RDEBUG_SHADE) {
			bu_log("  New closest hit %g < %g\n",
				ldist[0], r->hit.hit_dist);
			bu_log("  pt:(%g %g %g)\n  Normal:(%g %g %g)\n",
				V3ARGS(r->hit.hit_point),
				V3ARGS(r->hit.hit_normal));
		}


		return /* SHADE_ABORT_GRASS */;
	} else {
		if (rdebug&RDEBUG_SHADE)
			bu_log("abandon hit in cell: %g > %g\n",
				ldist[0], r->hit.hit_dist);
	}
	return /* SHADE_CONT */;
}


/*	intersect ray with leaves of single blade
 *
 */
static void
isect_blade(bl, root, r, swp, grass_sp, blade_num)
CONST struct blade *bl;
CONST point_t root;
struct grass_ray *r;
struct shadework	*swp;	/* defined in material.h */
CONST struct grass_specific *grass_sp;
int blade_num;
{
	double ldist[2];
	point_t pt;
	int cond;
	int seg;
	point_t PCA_ray;
	double	PCA_ray_radius;
	point_t PCA_grass;
	vect_t	tmp;
	double dist;
	double accum_len;/* accumulated distance along blade from prev segs */
	double fract;	/* fraction of total blade length to PCA */
	double blade_width;/* width of blade at PCA with ray */


	CK_grass_SP(grass_sp);
	BU_CKMAG(r, GRASSRAY_MAGIC, "grass_ray");

	if (rdebug&RDEBUG_SHADE)
		bu_log("\t  isect_blade()\n");


	BU_CKMAG(bl, BLADE_MAGIC, "blade");

	VMOVE(pt, root);

	accum_len = 0.0;

	for (seg=0 ; seg < bl->segs ; accum_len += bl->leaf[seg].len ) {

		BU_CKMAG(&bl->leaf[seg].magic, LEAF_MAGIC, "leaf");

		cond = rt_dist_line3_line3(ldist, r->r.r_pt, r->r.r_dir,
			pt, bl->leaf[seg].blade, &r->tol);

		if (rdebug&RDEBUG_SHADE) {
			bu_log("\t    ");
			switch (cond) {
			case -2: bu_log("lines paralell  "); break;
			case -1: bu_log("lines colinear  "); break;
			case  0: bu_log("lines intersect "); break;
			case  1: bu_log("lines miss      "); break;
			}
			bu_log("d1:%g d2:%g\n", cond, V2ARGS(ldist));
		}
		if (ldist[0] < 0.0 		/* behind ray */ || 
		    ldist[0] >= r->d_max	/* beyond out point */ ||
		    ldist[1] < 0.0 		/* under ground */ ||
		    ldist[1] > bl->leaf[seg].len/* beyond end of seg */
		    )	goto iter;

		VJOIN1(PCA_ray, r->r.r_pt, ldist[0], r->r.r_dir);
		PCA_ray_radius = r->radius + ldist[0] * r->diverge;

		VJOIN1(PCA_grass, pt, ldist[1], bl->leaf[seg].blade);
		VSUB2(tmp, PCA_grass, PCA_ray);
		dist = MAGNITUDE(tmp);


		/* We want to narrow the blade of grass toward the tip.
		 * So we scale the width of the blade based upon the 
		 * fraction of total blade length to PCA.
		 */
		fract = (accum_len + ldist[1]) / bl->tot_len;
		if (blade_num < BLADE_LAST) {
			blade_width = bl->width * (1.0 - fract);
		} else {
			blade_width = .5 * bl->width * (1.0 - fract);
		}

		if (dist < (PCA_ray_radius+blade_width)) {
			if (rdebug&RDEBUG_SHADE)
				bu_log("\thit grass: %g < (%g + %g)\n",
					dist, PCA_ray_radius,
					bl->width);

			hit_blade(bl, r, swp, grass_sp, seg, ldist,
				blade_num, fract);

			if (r->occlusion >= 1.0) return;

		}
		if (rdebug&RDEBUG_SHADE) bu_log("\t    (missed aside)\n");

iter:
		/* compute origin of NEXT leaf segment */
		VJOIN1(pt, pt, bl->leaf[seg].len, bl->leaf[seg].blade);
		seg++;
	}
}


static void
isect_plant(pl, r, swp, grass_sp)
CONST struct plant *pl;
struct grass_ray *r;
struct shadework	*swp;	/* defined in material.h */
CONST struct grass_specific *grass_sp;
{
	int i;

	CK_grass_SP(grass_sp);
	BU_CKMAG(r, GRASSRAY_MAGIC, "grass_ray");
	BU_CKMAG(pl, PLANT_MAGIC, "plant");

	if( rdebug&RDEBUG_SHADE) {
		bu_log("isect_plant()\n");
		print_plant("plant", pl);
	}

	r->r.r_min = r->r.r_max = 0.0;
	if (! rt_in_rpp(&r->r, r->rev, pl->pmin, pl->pmax) ) {
		if( rdebug&RDEBUG_SHADE) {
			point_t in_pt, out_pt;
			bu_log("min:%g max:%g\n", r->r.r_min, r->r.r_max);

			bu_log("ray %g %g %g->%g %g %g misses:\n\trpp %g %g %g, %g %g %g\n",
				V3ARGS(r->r.r_pt), V3ARGS(r->r.r_dir),
				V3ARGS(pl->pmin),  V3ARGS(pl->pmax));
			VJOIN1(in_pt, r->r.r_pt, r->r.r_min, r->r.r_dir);
			VPRINT("\tin_pt", in_pt);
	
			VJOIN1(out_pt, r->r.r_pt, r->r.r_max, r->r.r_dir);
			VPRINT("\tout_pt", out_pt);
			bu_log("MISSED BBox\n");
		}
		return;
	} else { 
		if( rdebug&RDEBUG_SHADE) {
			point_t in_pt, out_pt;
			bu_log("min:%g max:%g\n", r->r.r_min, r->r.r_max);
			bu_log("ray %g %g %g->%g %g %g hit:\n\trpp %g %g %g, %g %g %g\n",
				V3ARGS(r->r.r_pt),
				V3ARGS(r->r.r_dir),
				V3ARGS(pl->pmin),
				V3ARGS(pl->pmax));
			VJOIN1(in_pt, r->r.r_pt, r->r.r_min, r->r.r_dir);
			VPRINT("\tin_pt", in_pt);
	
			VJOIN1(out_pt, r->r.r_pt, r->r.r_max, r->r.r_dir);
			VPRINT("\tout_pt", out_pt);
			bu_log("HIT BBox\n");
		}
	}

	for (i=0 ; i < pl->blades ; i++) {
		isect_blade(&pl->b[i], pl->root, r, swp, grass_sp, i);
		if (r->occlusion >= 1.0)
			return;
	}
}


static int
stat_cell(cell_pos, r, grass_sp, swp, dist_to_cell, radius)
point_t cell_pos;	/* origin of cell in region coordinates */
struct grass_ray	*r;
struct grass_specific	*grass_sp;
struct shadework	*swp;
double dist_to_cell;
double radius;	/* radius of ray */
{
	point_t tmp;
	vect_t color;
	double h;

	double ratio = grass_sp->blade_width / radius;
	/* the ray is "large" so just pick something appropriate */

	CK_grass_SP(grass_sp);
	BU_CKMAG(r, GRASSRAY_MAGIC, "grass_ray");

	if (rdebug&RDEBUG_SHADE)
		bu_log("statistical bailout\n");

	r->hit.hit_dist = dist_to_cell;
	VJOIN1(r->hit.hit_point, r->r.r_pt, dist_to_cell, r->r.r_dir);

	/* compute color at this point */
	h = r->hit.hit_point[Z] / 400.0;

	VSCALE(color, swp->sw_basecolor, 1.0 - h);
	VJOIN1(color, color, h, grass_sp->brown);
	
	if (VEQUAL(swp->sw_color, swp->sw_basecolor)) {
		VSCALE(swp->sw_color, color, ratio);
		swp->sw_transmit -= ratio;
	} else {
		VJOIN1(swp->sw_color, swp->sw_color, ratio, grass_sp->brown);
		swp->sw_transmit -= ratio;
	}

#if 0
	bn_noise_vec(cell_pos, r->hit.hit_normal);
	r->hit.hit_normal[Z] += 1.0;
#else
	VADD2(tmp, r->hit.hit_point, grass_sp->delta);
	bn_noise_vec(tmp, r->hit.hit_normal);
	if (r->hit.hit_normal[Z] < 0.0) r->hit.hit_normal[Z] *= -1.0;
#endif
	VUNITIZE(r->hit.hit_normal);
	if (VDOT(r->hit.hit_normal, r->r.r_dir) > 0.0) {
		VREVERSE(r->hit.hit_normal, r->hit.hit_normal);
	}

	if (swp->sw_transmit < .05)
		return SHADE_ABORT_GRASS;
	else
		return SHADE_CONT;
}

static void
plot_cell(cell, r, grass_sp)
long			cell[3];	/* cell number (such as 5,3) */
struct grass_ray	*r;
struct grass_specific	*grass_sp;
{
	point_t cell_pos;

	CK_grass_SP(grass_sp);

	CELL_POS(cell_pos, grass_sp, cell);
	bu_log("plotting cell %d,%d (%g,%g) %g %g\n",
		V2ARGS(cell), V2ARGS(cell_pos), V2ARGS(grass_sp->cell));

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	pl_color(r->fd, 100, 100, 200);

	pd_3move(r->fd, cell_pos[X], cell_pos[Y], 0.0);
	pd_3cont(r->fd, cell_pos[X]+grass_sp->cell[X], cell_pos[Y], 0.0);
	pd_3cont(r->fd, cell_pos[X]+grass_sp->cell[X], cell_pos[Y]+grass_sp->cell[Y], 0.0);
	pd_3cont(r->fd, cell_pos[X], cell_pos[Y]+grass_sp->cell[Y], 0.0);
	pd_3cont(r->fd, cell_pos[X], cell_pos[Y], 0.0);
	pl_color(r->fd, 255, 255, 255);
	bu_semaphore_release(BU_SEM_SYSCALL);

}

/*	I S E C T _ C E L L
 *
 *  Intersects a region-space ray with a grid cell of grass.
 *
 */
static void
isect_cell(cell, r, swp, out_dist, grass_sp, curr_dist)
long			cell[3];	/* cell number (such as 5,3) */
struct grass_ray	*r;
double 			out_dist;
struct shadework	*swp;
struct grass_specific	*grass_sp;
double curr_dist;
{
	point_t c;		/* float version of cell # */
	point_t cell_pos;	/* origin of cell in region coordinates */
	double val;
	vect_t v;
	int p;		/* current plant number (loop variable) */
	int ppc;	/* # plants in this cell */
	struct plant pl;
	double dist_to_cell;
	double seed;

	CK_grass_SP(grass_sp);

	if( rdebug&RDEBUG_SHADE) {
		static int plot_num = 0;
		char buf[32];
		point_t cell_in_pt;
		point_t cell_out_pt;	/* not really */

		bu_log("isect_cell(%ld,%ld)\n", V2ARGS(cell));


		bu_semaphore_acquire(BU_SEM_SYSCALL);
		sprintf(buf, "g_ray%d,%d_%d_cell%ld,%ld_.pl",
			r->ap->a_x, r->ap->a_y, plot_num++, cell[0], cell[1]);
		r->fd = fopen(buf, "w");
		if (r->fd) {
			if (swp->sw_xmitonly)
				pl_color(r->fd, 255, 255, 55);
			else
				pl_color(r->fd, 255, 55, 55);

			VJOIN1(cell_in_pt, r->r.r_pt, curr_dist, r->r.r_dir);
			VJOIN1(cell_out_pt, r->r.r_pt, out_dist, r->r.r_dir);

			pdv_3move(r->fd, cell_in_pt);
			pdv_3cont(r->fd, cell_out_pt);
			pl_color(r->fd, 255, 255, 255);
		}

		bu_semaphore_release(BU_SEM_SYSCALL);
		if (r->fd) plot_cell(cell, r, grass_sp);
	}


	/* get coords of cell */
	CELL_POS(cell_pos, grass_sp, cell);

	VSUB2(v, cell_pos, r->r.r_pt);
	dist_to_cell = MAGNITUDE(v);

	

	/* radius of ray at cell origin */
	val = r->radius + r->diverge * dist_to_cell;

	if (rdebug&RDEBUG_SHADE)
		bu_log("\t  ray radius @@cell %g = %g, %g, %g   (%g)\n\t   cell:%g,%g\n",
			val, r->radius, r->diverge, dist_to_cell,  val*32.0,
			V2ARGS(grass_sp->cell));

	if (val > grass_sp->blade_width * 3) {
		stat_cell(cell_pos, r, grass_sp, swp, dist_to_cell, val);
		return;
	}

	/* Figure out how many plants are in this cell */

	val = plants_this_cell(cell, grass_sp);

	ppc = grass_sp->ppc + grass_sp->ppcd * val;

	if (rdebug&RDEBUG_SHADE) {
		bu_log("cell pos(%g,%g .. %g,%g)\n", V2ARGS(cell_pos),
			cell_pos[X]+grass_sp->cell[X],
			cell_pos[Y]+grass_sp->cell[Y]);

		bu_log("%d plants  ppc:%g v:%g\n", ppc, grass_sp->ppcd, val);
	}

	/* Get origin of cell in noise space (without delta)
	 * to use for computing seed needed by make_bush
	 */
	VSCALE(c, cell, grass_sp->size);


	/* intersect the ray with each plant */
	for (p=0 ;  p < ppc ; p++) {

		CK_grass_SP(grass_sp);
		BU_CKMAG(r, GRASSRAY_MAGIC, "grass_ray");

		make_bush(&pl, c[X]+c[Y],  cell_pos, grass_sp, val, r);

		CK_grass_SP(grass_sp);
		BU_CKMAG(r, GRASSRAY_MAGIC, "grass_ray");
		BU_CKMAG(&pl, PLANT_MAGIC, "plant");

		isect_plant(&pl, r, swp, grass_sp);
		if (r->occlusion >= 1.0) return;

		VSCALE(c, c, grass_sp->lacunarity);
	}
}



/*  Process a grid cell and any unprocessed adjoining neighbors.
 *
 * The flags argument indicates which cells (relative to the central
 * one) need to be processed.  The bit values for the relative
 * positions are:
 *
 *  pos   bit	 pos  bit   pos  bit
 *------------------------------------
 * -1, 1  0100	0, 1 0200  1, 1 0400
 * -1, 0  0010  0, 0 0020  1, 0 0040
 * -1,-1  0001  0,-1 0002  1,-1 0004
 *
 *
 * A set flag indicates that the cell has NOT been processed
 *
 *  Return:
 *	0	continue grid marching
 *	!0	abort grid marching
 */
static void
do_cells(cell_num, r, flags, swp, out_dist, grass_sp, curr_dist)
long			cell_num[3];
struct grass_ray	*r;
short 			flags;		/* which adj cells need processing */
double 			out_dist;
struct shadework	*swp;	/* defined in material.h */
struct grass_specific	*grass_sp;
double			curr_dist;
{
	int x, y;
	long cell[3];

#define FLAG(x,y) ((1 << ((y+1)*3)) << (x+1))
#define ISDONE(x,y,flags) ( ! (FLAG(x,y) & flags))

	CK_grass_SP(grass_sp);
	BU_CKMAG(r, GRASSRAY_MAGIC, "grass_ray");

	if( rdebug&RDEBUG_SHADE)
		bu_log("do_cells(%ld,%ld)\n", V2ARGS(cell_num));

	for (y=-1; y < 2 ; y++) {
		for (x=-1; x < 2 ; x++) {

			if ( ISDONE(x,y,flags) ) continue;

			cell[X] = cell_num[X] + x;
			cell[Y] = cell_num[Y] + y;

			if( rdebug&RDEBUG_SHADE)
				bu_log("checking relative cell %2d,%2d at(%d,%d)\n",
					x, y, V2ARGS(cell));

			isect_cell(cell, r, swp, out_dist, grass_sp, curr_dist);
			if (r->occlusion >= 1.0) return;
		}
	}
}

/*
 *	G R A S S _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
grass_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
{
	register struct grass_specific *grass_sp =
		(struct grass_specific *)dp;
	struct grass_ray	gr;
	vect_t		v;
	vect_t		in_rad, out_rad;
	point_t 	in_pt, out_pt, curr_pt;
	double		curr_dist, out_dist;
	double		radius;
	short		flags;
	double		t[2], tD[2];
	int		n;
	double		t_orig[2];
	long		tD_iter[2];
	long		cell_num[3];	/* cell number */
	long		old_cell_num[3];	/* cell number */
	point_t		in_pt_m;	/* model space in/out */
	point_t		out_pt_m;


	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_grass_SP(grass_sp);

	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "grass_render Parameters:", grass_print_tab, (char *)grass_sp );

	VMOVE(in_pt_m, swp->sw_hit.hit_point);

	swp->sw_transmit = 1.0;

	/* XXX now how would you transform the tolerance structure
	 * to the local coordinate space ?
	 */
	gr.magic = GRASSRAY_MAGIC;
	gr.occlusion = 0.0;

		
#if 1
	gr.tol = ap->a_rt_i->rti_tol;
#else
	gr.tol.magic = BN_TOL_MAGIC;
	gr.tol.dist = grass_sp->blade_width;
	gr.tol.dist_sq = grass_sp->blade_width * grass_sp->blade_width;
#endif
	gr.ap = ap;

	/* Convert everything over to "Region" space.
	 * First the ray and its radius then
	 * the in/out points
	 */
	MAT4X3PNT(gr.r.r_pt, grass_sp->m_to_sh, ap->a_ray.r_pt);
	MAT4X3VEC(gr.r.r_dir, grass_sp->m_to_sh, ap->a_ray.r_dir);
	VUNITIZE(gr.r.r_dir);
	VINVDIR(gr.rev, gr.r.r_dir);

	/* In Hit point */
	MAT4X3PNT(in_pt, grass_sp->m_to_sh, swp->sw_hit.hit_point);

	/* The only thing we can really do to get the size of the
	 * ray footprint at the In Hit point is get 3 (possibly different)
	 * radii in the Region coordinate system.  We construct a unit vector
	 * in model space with equal X,Y,Z and transform it to region space.
	 */
	radius = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
	VSETALL(v, radius);
	VUNITIZE(v);
	MAT4X3VEC(in_rad, grass_sp->m_to_sh, v);

	gr.radius = ap->a_rbeam;   /* XXX Bogus if Region != Model space */
	gr.diverge = ap->a_diverge;/* XXX Bogus if Region != Model space */

	/* Out point */
	VJOIN1(out_pt_m, ap->a_ray.r_pt, pp->pt_outhit->hit_dist,
		ap->a_ray.r_dir);
	MAT4X3VEC(out_pt, grass_sp->m_to_sh, out_pt_m);
	radius = ap->a_rbeam + pp->pt_outhit->hit_dist * ap->a_diverge;
	VSETALL(v, radius);
	MAT4X3VEC(out_rad, grass_sp->m_to_sh, v);



	/* set up a DDA grid to march through. */
	VSUB2(v, in_pt, gr.r.r_pt);
	curr_dist = MAGNITUDE(v);

	/* We set up a hit on the out point so that when we get a hit on
	 * a grass blade in a cell we can tell if it's closer than the 
	 * previous hits.  This way we end up using the closest hit for 
	 * the final result.
	 */
	VSUB2(v, out_pt, gr.r.r_pt);
	gr.d_max = gr.hit.hit_dist = out_dist = MAGNITUDE(v);
	VMOVE(gr.hit.hit_point, out_pt);
	MAT4X3VEC(gr.hit.hit_normal, grass_sp->m_to_sh, swp->sw_hit.hit_normal);

	if( rdebug&RDEBUG_SHADE) {
		bu_log("Pt: (%g %g %g)\nRPt:(%g %g %g)\n",
			V3ARGS(ap->a_ray.r_pt),
			V3ARGS(gr.r.r_pt));
		bu_log("Dir: (%g %g %g)\nRDir:(%g %g %g)\n", V3ARGS(ap->a_ray.r_dir),
			V3ARGS(gr.r.r_dir));
		bu_log("rev: (%g %g %g)\n", V3ARGS(gr.rev));

		bu_log("Hit Pt:(%g %g %g) d:%g r:  %g\nRegHPt:(%g %g %g) d:%g Rr:(%g %g %g)\n",
			V3ARGS(swp->sw_hit.hit_point), swp->sw_hit.hit_dist,
			ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge,
			V3ARGS(in_pt), curr_dist, V3ARGS(in_rad));

		VJOIN1(v, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
		bu_log("Out Pt:(%g %g %g) d:%g r:   %g\nRegOPt:(%g %g %g) d:%g ROr:(%g %g %g)\n",
			V3ARGS(v), pp->pt_outhit->hit_dist, radius,
			V3ARGS(out_pt), out_dist, V3ARGS(out_rad));
	}


	/* tD[X] is the distance along the ray we have to travel
	 * to traverse a cell (travel a unit distance) along the
	 * X axis of the grid.
	 *
	 * t[X] is the distance along the ray to the first cell boundary
	 * beyond the hit point in the X direction.
	 *
	 * t_orig[X] is the same as t[X] but won't get changed as we
	 * march across the grid.  At each X grid line crossing, we recompute
	 * a new t[X] from t_orig[X], tD[X], tD_iter[X].  The tD_iter[X] is 
	 * the number of times we've made a full step in the X direction.
	 */
	for (n=X ; n < Z ; n++) {
		char *s;
		if (n == X) s="X";
		else s="Y";

		/* compute distance from cell origin to in_pt */
		t[n] = in_pt[n] - 
			floor(in_pt[n]/grass_sp->cell[n]) *
				       grass_sp->cell[n];
		if( rdebug&RDEBUG_SHADE)
			bu_log("t[%s]:%g = in_pt[%s]:%g - floor():%g * cell[%s]%g\n",
				s, t[n], s, in_pt[n],
				floor(in_pt[n]/grass_sp->cell[n]),
				s, grass_sp->cell[n]);

		if (gr.r.r_dir[n] < -SMALL_FASTF) {
			tD[n] = -grass_sp->cell[n] / gr.r.r_dir[n];
			t[n] = t[n] / -gr.r.r_dir[n];
			t[n] += curr_dist;
		} else if (gr.r.r_dir[n] > SMALL_FASTF) {
			tD[n] = grass_sp->cell[n] / gr.r.r_dir[n];
			t[n] = grass_sp->cell[n] - t[n];
			t[n] = t[n] / gr.r.r_dir[n];
			t[n] += curr_dist;
		} else {
			tD[n] = t[n] = MAX_FASTF;
		}
		if (t[n] > out_dist) t[n] = out_dist;
		t_orig[n] = t[n];
		tD_iter[n] = 0;
	}
	

	if( rdebug&RDEBUG_SHADE) {
		bu_log("t[X]:%g tD[X]:%g\n", t[X], tD[X]);
		bu_log("t[Y]:%g tD[Y]:%g\n\n", t[Y], tD[Y]);
	}

	/* The flags argument indicates which cells (relative to the central
	 * one) have already been processed.  The bit values for the relative
	 * positions are:
	 *
	 *  pos   bit	 pos  bit   pos  bit
	 *------------------------------------
	 * -1, 1  0100	0, 1 0200  1, 1 0400
	 * -1, 0  0010  0, 0 0020  1, 0 0040
	 * -1,-1  0001  0,-1 0002  1,-1 0004
	 *
	 * A set bit indicates that the cell has NOT been processed.
	 */
	flags = 0777;	/* no ajacent cells processed */
	VMOVE(curr_pt, in_pt);
	cell_num[X] = (long)(in_pt[X] / grass_sp->cell[X]);
	cell_num[Y] = (long)(in_pt[Y] / grass_sp->cell[Y]);
	cell_num[Z] = 0.0;

	/* Time to go marching across the grid */
	while (curr_dist < out_dist) {


		if( rdebug&RDEBUG_SHADE) {
			point_t	cell_pos; /* cell origin position */

			if( rdebug&RDEBUG_SHADE) {
				bu_log("dist:%g (%g %g %g)\n", curr_dist,
					V3ARGS(curr_pt));
				bu_log("cell num: %d %d\n", V2ARGS(cell_num));
			}
			CELL_POS(cell_pos, grass_sp, cell_num);

			if( rdebug&RDEBUG_SHADE)
				bu_log("cell pos: %g %g\n", V2ARGS(cell_pos));
		}


		do_cells(cell_num, &gr, flags, swp, out_dist, grass_sp, curr_dist);
		if (gr.occlusion >= 1.0)
			goto done;

		VMOVE(old_cell_num, cell_num);
		if (t[X] < t[Y]) {
			if( rdebug&RDEBUG_SHADE)
				bu_log("stepping X %le\n", t[X]);
			if (gr.r.r_dir[X] < 0.0) {
				flags = 0111;
				cell_num[X]--;
			} else {
				flags = 0444;
				cell_num[X]++;
			}
			n = X;
		} else {
			if( rdebug&RDEBUG_SHADE)
				bu_log("stepping Y %le\n", t[Y]);
			if (gr.r.r_dir[Y] < 0.0) {
				flags = 0007;
				cell_num[Y]--;
			} else {
				flags = 0700;
				cell_num[Y]++;
			}
			n = Y;
		}
		curr_dist = t[n];
		t[n] = t_orig[n] + tD[n] * ++tD_iter[n];

		if (t[n] > out_dist) t[n] = out_dist; 

		VJOIN1(curr_pt, gr.r.r_pt, curr_dist, gr.r.r_dir);
		curr_pt[n] = ((long) ((curr_pt[n] / grass_sp->cell[n]) + .1))
			 * grass_sp->cell[n];
	}


	if( rdebug&RDEBUG_SHADE)
		bu_log("Missed grass blades\n");

	/* Missed everything */




	if (grass_sp->debug && !swp->sw_xmitonly) {
		/* show the cell positions on the ground */
		double bc;

		bc =  plants_this_cell(cell_num, grass_sp);
		bc = CLAMP(bc, 0.0, 1.0);
		bc = .25 * bc + .7;

		if ((cell_num[X] + cell_num[Y]) & 1) {
			VSET(swp->sw_basecolor, bc, bc*.7, bc*.7);
		} else {
			VSET(swp->sw_basecolor, bc*.7, bc*.7, bc);
		}
	} else {
		/* setting basecolor to 1.0 prevents "filterglass" effect */
		VSETALL(swp->sw_basecolor, 1.0); 
	}



	(void)rr_render( ap, pp, swp );

done:
	if ( rdebug&RDEBUG_SHADE) {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		fflush(gr.fd);
		fclose(gr.fd);
		bu_semaphore_release(BU_SEM_SYSCALL);
	}

#if 0

	/* Tell stacker to abort shading */
	return 0;

	if( rdebug&RDEBUG_SHADE)
		bu_log("Hit grass blades\n");


	/* if we got here then we hit something.  Convert the hit info
	 * back into model coordinates.
	 *
	 * Tell stacker to shade with plastic
	 * XXX another possibility here is to do:
	 *	extern struct mfuncs phg_mfuncs[];
	 *	return phg_mfuncs[1].mf_render(ap, pp, swp, dp);
	 * This would require calling the mf_setup routine in our _setup(),
	 * and hiding a pointer to a phong_specific in grass_specific.
	 */

	MAT4X3PNT(swp->sw_hit.hit_point, grass_sp->sh_to_m, gr.hit.hit_point);
	VSUB2(v, swp->sw_hit.hit_point, ap->a_ray.r_pt);
	swp->sw_hit.hit_dist = MAGNITUDE(v);

	swp->sw_transmit = 0.0;

	if (status & SHADE_ABORT_STACK) {
		if( rdebug&RDEBUG_SHADE)
			bu_log("Aborting stack (statistical grass)\n");
		return 0;
	}


	if (swp->sw_xmitonly) return 0;

	if( rdebug&RDEBUG_SHADE)
		bu_log("normal before xform:(%g %g %g)\n",
			V3ARGS(swp->sw_hit.hit_normal));

	MAT4X3VEC(swp->sw_hit.hit_normal, grass_sp->sh_to_m, gr.hit.hit_normal);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Rnormal", gr.hit.hit_normal);
		VPRINT("Mnormal", swp->sw_hit.hit_normal);
		bu_log("MAG(Rnormal)%g, MAG(Mnormal)%g\n", MAGNITUDE(gr.hit.hit_normal), MAGNITUDE(swp->sw_hit.hit_normal));
	}
	VUNITIZE(swp->sw_hit.hit_normal);
#endif

	return 1;


}
@


1.35
log
@*- #define M_PI if not already defined
@
text
@@


1.34
log
@First cut at non-stack version of shader
@
text
@d19 4
@


1.33
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d13 1
d70 1
d79 2
d82 2
d92 1
d118 1
d122 1
a122 1
	300.0,				/* "t" mean length of leaf */
d206 1
a207 1
	VADD2(c, c, grass_sp->delta);
d219 1
a219 1
struct plant *plant;
d244 1
a244 1
blade_rot(o, i, m)
d248 1
d258 3
a260 3
	VSETALL(pt, 0.0);
	VMOVE(o->pmin, pt);
	VMOVE(o->pmax, pt);
d286 1
a286 1
		blade_rot(&pl->b[blade], &pl->b[blade], m);
a340 1
  point_t pt;
d344 1
a344 1
  double val, tmp, len;
d407 1
a407 1
    blade_rot(&grass_sp->proto.b[blade], &grass_sp->proto.b[blade], m);
d505 1
d540 20
d561 24
d586 1
a586 1
make_bush(pl, c, cell_pos, grass_sp, w)
d588 1
a588 1
point_t				c;	/* derived from cell_num */
d591 2
a592 1
double w;		/* cell specific weght for count, height */
a594 1
	vect_t left;
d596 1
a596 3
	double val;
	double foo;
	int idx;
a597 1

d599 1
a599 1
		bu_log("make_bush(%g %g %g, ... %g)\n", V3ARGS(c), w);
d601 1
d609 1
a609 3

	idx = (int)(c[X] + c[Y]);
	BN_RANDSEED(idx, idx);
a611 2
	idx *= (int)(c[X] + c[Y]);
	BN_RANDSEED(idx, idx);
a613 1

a617 1

a619 1

a622 1

d635 1
a642 3
 *	Return:
 *		0	missed
 *		1	hit something
d644 1
a644 1
static int
d663 3
d703 1
a703 1
		return SHADE_ABORT_GRASS;
d709 1
a709 1
	return SHADE_CONT;
d712 1
a714 3
 *	Return:
 *		0	missed
 *		1	hit something
d716 1
a716 1
static int
d719 1
a719 1
point_t root;
d745 1
a790 6
#if 0
			if (fract > .9)
				blade_width = bl->width * 1.1;
			else
				blade_width = bl->width * .5;
#endif
d800 1
a800 1
			return hit_blade(bl, r, swp, grass_sp, seg, ldist,
d802 3
d813 1
a814 2
	return SHADE_CONT;
}
d816 1
a816 1
static int
d823 1
a823 1
	int i, status;
d833 1
d850 1
a850 1
		return 0;
d865 1
d870 3
a872 3
		status = isect_blade(&pl->b[i], pl->root, r, swp, grass_sp, i);
		if (status) 
			return status;
a873 2

	return 0;
d935 26
a965 5
 *
 *
 *  Return:
 *	0	continue grid marching
 *	~0	hit something
d967 2
a968 2
static int
isect_cell(cell, r, swp, out_dist, grass_sp)
d974 1
a982 1
	int hit = 0;
d984 1
d988 6
a993 1
	if (rdebug&RDEBUG_SHADE)
d997 23
d1027 1
a1030 1

d1037 2
a1038 1
		return stat_cell(cell_pos, r, grass_sp, swp, dist_to_cell, val);
d1042 1
d1044 1
d1047 1
a1047 3
	VSCALE(c, cell, grass_sp->size);

	if (rdebug&RDEBUG_SHADE)
a1051 1
	if (rdebug&RDEBUG_SHADE)
d1053 6
d1060 1
d1067 1
a1067 1
		make_bush(&pl, c, cell_pos, grass_sp, val);
d1073 2
a1074 1
		hit |= isect_plant(&pl, r, swp, grass_sp);
a1077 2

	return hit;
d1095 2
d1101 2
a1102 2
static int
do_cells(cell_num, r, flags, swp, out_dist, grass_sp)
d1109 1
a1112 1
	int hit = 0;
d1125 1
a1125 7
#if 0
			short f;
			f = FLAG(x,y);
			if( rdebug&RDEBUG_SHADE)
				bu_log("\n0%03o &\n0%03o = %d ",
					flags, f, (flags & f) != 0 );
#endif
d1134 3
a1136 1
			hit |= isect_cell(cell, r, swp, out_dist, grass_sp);
a1138 1
	return hit;
d1170 2
a1171 1
	int		status;
d1173 1
d1182 2
a1183 8
#if 0
	if (swp->sw_xmitonly) {
		if( rdebug&RDEBUG_SHADE)
			bu_log("grass no shadows\n");
		swp->sw_transmit = 1.0;
		return 0;
	}
#endif
a1185 1

d1190 1
d1192 1
d1200 2
d1214 4
a1217 2
	/* The only thing we can really do is get (possibly 3 different)
	 * radii in the Region coordinate system
a1223 2
	VSUB2(v, gr.r.r_pt, in_pt);

d1228 3
a1230 2
	VJOIN1(v, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3VEC(out_pt, grass_sp->m_to_sh, v);
d1235 2
d1252 2
a1253 1
		bu_log("Pt: (%g %g %g)\nRPt:(%g %g %g)\n", V3ARGS(ap->a_ray.r_pt),
d1331 1
d1333 1
a1333 1
	flags = 0777;
d1357 3
a1359 2
		if (status = do_cells(cell_num, &gr, flags,
		    swp, out_dist, grass_sp))
d1403 2
a1406 1
		int plants;
d1424 1
d1427 10
a1439 1
done:
d1482 1
a1482 1

@


1.32
log
@checkpoint
@
text
@d180 1
a180 1
CONST struct mfuncs grass_mfuncs[] = {
@


1.31
log
@checkpoint
@
text
@a15 1
#include "./light.h"
d69 8
a76 8
	struct xray	r;	/* pt, direction */
	double		d_min;	
	double		d_max;	/* out point of solid (hit pt cull) */
	vect_t		rev;	/* VINVDIR(r.r_dir) for rt_in_rpp */
	double		diverge;/* ray divergence in region space */
	double		radius;	/* radius of beam at in point */
	struct bn_tol	tol;	/* XXX region space tolerance (bogus) */
	struct hit	hit;	/* */
d111 1
a111 1
	{300.0, 300.0},			/* cell */
d116 1
a116 1
	3,				/* # segs per blade */
d124 1
a124 1
	{.7, .6, .3},			/* brown */
d188 1
a188 6
/* 
 *  Based upon a cell location we come up with a cell-specific random 
 *  number in the range 0.0 .. 1.0 inclusive.  This is used to determine
 *  the deviation from the mean number of plants per cell for the given
 *  cell.
 */
d197 1
a197 2
	VSCALE(c, cell, grass_sp->size);  /* int/float conv + noise scale */
	VADD2(c, c, grass_sp->delta);	/* noise space shift */
d199 1
d202 1
a202 1

d232 1
a232 1
 *	Rotate a blade about the Z axis
d236 1
a236 1
blade_rot(o, i, m, wind)
a239 1
vect_t wind;
a243 1
	vect_t v;
d249 3
a256 12
#define WIND 1
#if WIND
		if (seg <= BLADE_LAST-1) {
			MAT4X3VEC(v, m, i->leaf[seg].blade);
			VADD2(v, v, wind);
			VUNITIZE(v);
			VMOVE(o->leaf[seg].blade, v);

		} else {
			MAT4X3VEC(o->leaf[seg].blade, m, i->leaf[seg].blade);
		}
#else
a257 2
#endif
		/* XXX should recompute N? */
d261 3
d267 1
a267 1
plant_rot(pl, a, wind)
a269 1
vect_t wind;
d277 1
a277 1
		blade_rot(&pl->b[blade], &pl->b[blade], m, wind);
d296 1
a296 2
	d =  w * 2.0;
	d = CLAMP(d, 0.0, 1.0);
d299 2
a300 2
	if (d < .7) {
		pl->blades -= (1.0 - d) * pl->blades;
d302 1
a302 1
	}
d309 1
a309 1
			d = d * d * d * d;
a337 1
  static CONST vect_t wind = { 0.0, 0.0, 0.0};
d367 1
a367 1
    seg_len = 1.5 * grass_sp->t / grass_sp->proto.b[blade].segs;
d399 1
a399 1
    blade_rot(&grass_sp->proto.b[blade], &grass_sp->proto.b[blade], m, wind);
d411 1
a411 1
  grass_sp->proto.b[blade].width = grass_sp->blade_width;
d414 1
a414 2
/* XXX need to get the height of the stalks to vary more somehow */
  seg_len = 1.75 * grass_sp->t / grass_sp->proto.b[blade].segs;
d533 1
a533 1
make_bush(pl, c, cell_pos, grass_sp, w, wind)
a538 1
vect_t wind;		/* wind direction vector */
d577 1
a577 1
	plant_rot(pl, BN_RANDOM(idx) * bn_twopi, wind);
d579 1
d796 14
a809 2
		if( rdebug&RDEBUG_SHADE)
			bu_log("MISSED plant BBox\n");
d811 15
d867 9
a875 2
	VSCALE(tmp, grass_sp->brown, 1.4);
	VJOIN1(swp->sw_color, color, h, tmp);
a876 2
	swp->sw_transmit = 0.0;

d881 1
a881 3
/* XXX should use wind vect and frametime here */
	VSCALE(tmp, r->hit.hit_point, grass_sp->size * .05);
	VADD2(tmp, tmp, grass_sp->delta);
d890 4
a893 2

	return SHADE_ABORT_GRASS;
a923 1
	vect_t wind;
d930 1
d936 1
d941 1
d947 1
a947 7
	/* If the radius of the ray at the cell origin is larger
	 * than some threshold, then we skip all the grass intersection code
	 * and just to a statistical surface noise approximation of the
	 * effect.  This saves a lot of computation marching through cells
	 * that ar out near the horizon.
	 */
	if (val > grass_sp->blade_width * 3.5)
d949 1
a949 9


	/* We're going to have to intersect individual grass blades for 
	 * this cell.  We first need to figure out how many grass plants
	 * are in the cell.  At the moment we do this by taking a mean
	 * number of plants in a cell (ppc) and modify it with a 
	 * cell-specific random number and the user-specified deviation 
	 * in plants-per-cell (ppcd)
	 */
d951 1
d955 3
a957 1
	if (rdebug&RDEBUG_SHADE) {
d962 1
a963 21
	}


#if WIND
{
	vect_t wind_vec;
	VSET(wind_vec, 0.70710678, 0.70710678, 0.0);
	VSCALE(c, cell, grass_sp->size);

	/* how often do we move */
	VJOIN1(c, c, swp->sw_frametime*2, wind_vec); 
	bn_noise_vec(c, wind);

	/* how much do we move when we move */
	VSCALE(wind, wind, .05); 
}
#else
	VSET(wind, 0.0, 0.0, 0.0);
	VSCALE(c, cell, grass_sp->size);
#endif

d971 1
a971 1
		make_bush(&pl, c, cell_pos, grass_sp, val, wind);
d1246 1
a1379 22


#if 0
shade_pt(pt, norm, color)
{
	register struct light_specific *lp;
	vect_t tolight;


	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		/* compute the light direction */
		if( lp->lt_infinite ) {
			/* Infinite lights are point sources, no fuzzy penumbra */
			VMOVE( tolight, lp->lt_vec );
		} else {
			VSUB2(tolight, lp->lt_pos,
				swp->sw_hit.hit_point);
		}
	}
}
#endif
@


1.30
log
@checkpoint
@
text
@d16 1
d70 8
a77 8
	struct xray	r;
	double		d_min;
	double		d_max;
	vect_t		rev;
	double		diverge;
	double		radius;
	struct bn_tol	tol;
	struct hit	hit;
d189 6
a194 1
/* fraction of total allowed returned */
d203 2
a204 1
	VSCALE(c, cell, grass_sp->size);  /* int/float conv */
a205 1
	VADD2(c, c, grass_sp->delta);
d208 1
a208 1
	
d816 2
a817 14
		if( rdebug&RDEBUG_SHADE) {
			point_t in_pt, out_pt;
			bu_log("min:%g max:%g\n", r->r.r_min, r->r.r_max);

			bu_log("ray %g %g %g->%g %g %g misses:\n\trpp %g %g %g, %g %g %g\n",
				V3ARGS(r->r.r_pt), V3ARGS(r->r.r_dir),
				V3ARGS(pl->pmin),  V3ARGS(pl->pmax));
			VJOIN1(in_pt, r->r.r_pt, r->r.r_min, r->r.r_dir);
			VPRINT("\tin_pt", in_pt);
	
			VJOIN1(out_pt, r->r.r_pt, r->r.r_max, r->r.r_dir);
			VPRINT("\tout_pt", out_pt);
			bu_log("MISSED BBox\n");
		}
a818 15
	} else { 
		if( rdebug&RDEBUG_SHADE) {
			point_t in_pt, out_pt;
			bu_log("min:%g max:%g\n", r->r.r_min, r->r.r_max);
			bu_log("ray %g %g %g->%g %g %g hit:\n\trpp %g %g %g, %g %g %g\n",
				V3ARGS(r->r.r_pt),
				V3ARGS(r->r.r_dir),
				V3ARGS(pl->pmin),
				V3ARGS(pl->pmax));
			VJOIN1(in_pt, r->r.r_pt, r->r.r_min, r->r.r_dir);
			VPRINT("\tin_pt", in_pt);
	
			VJOIN1(out_pt, r->r.r_pt, r->r.r_max, r->r.r_dir);
			VPRINT("\tout_pt", out_pt);
		}
a918 1

a923 1

a927 1

d933 7
a939 1
	if (val > grass_sp->blade_width * 3.5) {
d941 9
a949 1
	}
a950 1
	/* Figure out how many plants are in this cell */
d954 9
d974 1
a974 1
	VSCALE(wind, wind, .125); 
d978 1
a979 6
	VSCALE(c, cell, grass_sp->size);

	if (rdebug&RDEBUG_SHADE)
		bu_log("cell pos(%g,%g .. %g,%g)\n", V2ARGS(cell_pos),
			cell_pos[X]+grass_sp->cell[X],
			cell_pos[Y]+grass_sp->cell[Y]);
a980 2
	if (rdebug&RDEBUG_SHADE)
		bu_log("%d plants  ppc:%g v:%g\n", ppc, grass_sp->ppcd, val);
a1262 1

d1396 22
@


1.29
log
@checkpoint
@
text
@d258 1
a258 1
		if (seg == BLADE_LAST) {
d424 1
a424 1
  grass_sp->proto.b[blade].width = grass_sp->blade_width * 0.5;
d592 1
a592 1
	plant_rot(pl, BN_RANDOM(idx) * M_PI * 2.0, wind);
a593 1

d970 3
a972 1
	VJOIN1(c, c, swp->sw_frametime*.5, wind_vec);
d974 3
a976 1
	VSCALE(wind, wind, .25);
@


1.28
log
@clumps!
@
text
@d321 1
a321 1
			d = d * d * d;
d428 1
a428 1
  seg_len = 2. * grass_sp->t / grass_sp->proto.b[blade].segs;
d891 3
a893 1
	VADD2(tmp, r->hit.hit_point, grass_sp->delta);
@


1.27
log
@interesting clumps at 400,400 grid
@
text
@d314 1
a314 1
	} 
d321 1
a321 1
			d *= d;
d427 2
a428 1
  seg_len = 2.25 * grass_sp->t / grass_sp->proto.b[blade].segs;
d882 2
a883 1
	VJOIN1(swp->sw_color, color, h, grass_sp->brown);
d956 1
a956 1
	if (val > grass_sp->blade_width * 3) {
@


1.26
log
@revert
@
text
@d112 1
a112 1
	3.0,				/* plants_per_cell */
d307 2
a308 1
	d = 1.0 - w;
d311 2
a312 2
	if (d < .8) {
		pl->blades -= d * pl->blades * .5;
d380 1
a380 1
    seg_len = grass_sp->t / grass_sp->proto.b[blade].segs;
@


1.25
log
@checkpoint
@
text
@d112 2
a113 2
	2.0,				/* plants_per_cell */
	4.0,				/* deviation of plants_per_cell */
a306 1
#if 0
d310 2
a311 9
	if (d < .95) {
		pl->blades--;
		pl->blades -= d * pl->blades * .75;
		pl->blades = CLAMP(pl->blades, 1, BLADE_LAST);
	}
#else
	if (d < .9) {
		pl->blades--;
		pl->blades -= d * pl->blades * .75;
d313 1
a313 3
	}
	d = 1.0 - w;
#endif
d320 1
a320 1
			d = d * d * d * d;
d379 1
a379 1
    seg_len = 1.25 * grass_sp->t / grass_sp->proto.b[blade].segs;
d426 1
a426 1
  seg_len = 2.5 * grass_sp->t / grass_sp->proto.b[blade].segs;
a575 1
#if 0
a577 1
#endif
d876 6
d888 1
a888 3
	VSCALE(tmp, r->hit.hit_point, grass_sp->size);
	tmp[Z] = 0.0;
	VADD2(tmp, tmp, grass_sp->delta);
a889 13


	/* compute color at this point */
	h = r->hit.hit_point[Z] / 400.0;
	h = CLAMP(tmp[Z], 0.0, 1.0);
#if 0
	VSCALE(color, swp->sw_basecolor, 1.0 - h);
	VJOIN1(swp->sw_color, color, h, grass_sp->brown);
#else
	VSCALE(swp->sw_color, grass_sp->brown, 1.5);
#endif


d897 2
a898 9
	if (rdebug&RDEBUG_SHADE) {
		bu_log("Normal %g %g %g\n", V3ARGS(r->hit.hit_normal));
		bu_log("color %g %g %g\n", V3ARGS(swp->sw_color));
	}
	if (swp->sw_transmit < .05) {
		swp->sw_transmit = 0.0;
		return SHADE_ABORT_GRASS;
	} else
		return SHADE_CONT;
@


1.24
log
@blade_rot needed 4 parameters in make_proto
@
text
@d113 1
a113 1
	1.0,				/* deviation of plants_per_cell */
d258 1
a258 1
		if (seg > 0) {
d307 1
d311 9
a319 2
	if (d < .8) {
		pl->blades -= d * pl->blades * .5;
d321 3
a323 1
	} 
d330 1
a330 1
			d *= d;
d389 1
a389 1
    seg_len = grass_sp->t / grass_sp->proto.b[blade].segs;
d436 1
a436 1
  seg_len = 1.5 * grass_sp->t / grass_sp->proto.b[blade].segs;
d586 1
d589 1
d888 1
a888 13
	/* compute color at this point */
	h = r->hit.hit_point[Z] / 400.0;

	VSCALE(color, swp->sw_basecolor, 1.0 - h);
	VJOIN1(color, color, h, grass_sp->brown);
	
	if (VEQUAL(swp->sw_color, swp->sw_basecolor)) {
		VSCALE(swp->sw_color, color, ratio);
		swp->sw_transmit -= ratio;
	} else {
		VJOIN1(swp->sw_color, swp->sw_color, ratio, grass_sp->brown);
		swp->sw_transmit -= ratio;
	}
d894 3
a896 1
	VADD2(tmp, r->hit.hit_point, grass_sp->delta);
d898 13
d918 6
a923 1
	if (swp->sw_transmit < .05)
d925 1
a925 1
	else
d994 1
a994 1
	VJOIN1(c, c, swp->sw_frametime, wind_vec);
d996 1
a996 1
	VSCALE(wind, wind, .05);
@


1.23
log
@modified wind
@
text
@d349 1
d411 1
a411 1
    blade_rot(&grass_sp->proto.b[blade], &grass_sp->proto.b[blade], m);
@


1.22
log
@wind implemented
@
text
@d256 2
a257 1

a258 1

d263 1
d267 3
d968 1
a968 1
#if 1
@


1.21
log
@pre-animation
@
text
@d124 1
a124 1
	{.7, .6, .3},	
d232 1
a232 1
 *	Rotate a blade about the Z axis, compute blade bounding box
d236 1
a236 1
blade_rot(o, i, m)
d240 1
d245 1
a250 3
	VSETALL(pt, 0.0);
	VMOVE(o->pmin, pt);
	VMOVE(o->pmax, pt);
d256 11
a266 1
		MAT4X3VEC(o->leaf[seg].blade, m, i->leaf[seg].blade);
a269 3

		VJOIN1(pt, pt, o->leaf[seg].len, o->leaf[seg].blade);
		VMINMAX(o->pmin, o->pmax, pt);
d273 1
a273 1
plant_rot(pl, a)
d276 1
d284 1
a284 1
		blade_rot(&pl->b[blade], &pl->b[blade], m);
d421 1
a421 1
  seg_len = .75 * grass_sp->t / grass_sp->proto.b[blade].segs;
d540 1
a540 1
make_bush(pl, c, cell_pos, grass_sp, w)
d546 1
d585 1
a585 1
	plant_rot(pl, BN_RANDOM(idx) * M_PI * 2.0);/* computes bounding box */
d932 1
d964 12
d992 1
a992 1
		make_bush(&pl, c, cell_pos, grass_sp, val);
@


1.20
log
@checkpoint
@
text
@d56 1
d99 1
d123 2
a124 1
	{ 1000.0, 1000.0, 1000.0 },	/* delta into noise space */
d300 2
a301 3
		pl->blades -= d * (pl->blades-1) * .5;
		pl->blades += 1;
		pl->blades = CLAMP(pl->blades, 1, BLADE_MAX-1);
d306 1
a306 1
		if (blade != BLADE_MAX-1)
d308 2
a310 1

d355 2
a356 2
  for (blade=0 ; blade < BLADE_MAX-1 ; blade++) {
    val = (double)blade / (double)(BLADE_MAX-1);
d366 1
a366 1
    start_angle = 65.0 + 20.0 * (1.0-val);
d372 1
a372 1
    	angle = start_angle - seg * seg_delta_angle;
d407 1
a407 1
  blade = BLADE_MAX-1;
d414 1
a414 1
  seg_len = grass_sp->t / grass_sp->proto.b[blade].segs;
d417 1
a417 1
    	tmp = (double)seg / (double)BLADE_SEGS_MAX;
d558 1
d635 1
a635 1
		if (blade_num == BLADE_MAX-1) {
d639 1
a639 1
			d = (1.0-fract) * .25;
d643 1
a643 2
			VSET(brown, .7, .6, .3);
			VSCALE(brown, brown, d);
d744 2
a745 2
		if (blade_num < BLADE_MAX-1) {
			fract = (accum_len + ldist[1]) / bl->tot_len;
d748 1
a748 1
			fract = (accum_len + ldist[1]) / bl->tot_len;
d753 2
d839 1
a839 1
stat_cell(cell_pos, r, grass_sp, swp, dist_to_cell)
d845 1
d848 4
d863 13
a875 1
	VSET(swp->sw_color, .7, .6, .3);
d890 4
a893 1
	return SHADE_ABORT_GRASS;
d947 3
a949 3
	if (val > grass_sp->blade_width * 3)
		return stat_cell(cell_pos, r, grass_sp, swp, dist_to_cell);

d1096 3
a1325 1
	swp->sw_transmit = 1.0;
@


1.19
log
@checkpoint
@
text
@d55 1
a55 1
#define BLADE_MAX 4
d112 1
a112 1
	30.0,				/* "t" mean length of leaf seg */
d196 4
a199 4
	val = bn_noise_turb(c, grass_sp->h_val, grass_sp->lacunarity,
			grass_sp->octaves);

	val *= 1.5;
d293 1
a293 1
	if (w > .4) pl->blades--;
d295 7
d305 2
a306 3
			pl->b[blade].width *= w;
		else
			w = 1.0 - w;
d309 1
a309 1
				pl->b[blade].leaf[seg].len *= w;
d330 2
d333 2
a334 1
  double val;
d345 1
a345 1
   * a rotation of this first one.
d347 2
a348 5
  blade = 0;
  grass_sp->proto.b[blade].magic = BLADE_MAGIC;
  grass_sp->proto.b[blade].tot_len = 0.0;
  grass_sp->proto.b[blade].segs = 4;
  grass_sp->proto.b[blade].width = grass_sp->blade_width;
d350 1
a350 3
  VSETALL(pt, 0.0);
  for (seg=0 ; seg < grass_sp->proto.b[blade].segs ; seg++) {
    grass_sp->proto.b[blade].leaf[seg].magic = LEAF_MAGIC;
d352 2
a353 3
    /* Initial blade direction along X axis
     * compute angle of blade segment.
     */
d355 5
a359 2
	angle = 80.0 / (grass_sp->proto.b[blade].segs-1.0);
	angle = 70.0 - seg * angle;
d362 3
a364 3
    angle *= bn_degtorad;
  
    VSET(grass_sp->proto.b[blade].leaf[seg].blade, cos(angle), 0.0, sin(angle));
d366 2
a367 3
    /* pick a length for the blade segment */
    grass_sp->proto.b[blade].leaf[seg].len = 
    	(grass_sp->t*.8) + seg * (grass_sp->t*.5);
d369 4
a372 2
    grass_sp->proto.b[blade].tot_len +=
    	grass_sp->proto.b[blade].leaf[seg].len;
d374 2
a376 7
    VUNITIZE(grass_sp->proto.b[blade].leaf[seg].blade);
    VCROSS(left, grass_sp->proto.b[blade].leaf[seg].blade, z_axis);
    VUNITIZE(left);
    VCROSS(grass_sp->proto.b[blade].leaf[seg].N,
      		left, grass_sp->proto.b[blade].leaf[seg].blade);
    VUNITIZE(grass_sp->proto.b[blade].leaf[seg].N);
  }
a377 8
  /* We now create a matrix for producing a 137 degree rotation about
   * the Z axis.  This rotates the principle blade to other angles to
   * create the successive blades.
   *  Prusinkewicz et. al showed that this was a good angle for such 
   * phenomena.  
   */
  bn_mat_zrot(r, sin(bn_degtorad*137.0), cos(bn_degtorad*137.0));
  bn_mat_copy(m,r);
d379 8
a386 2
  /* other blades are just a rotation of primary blade */
  for (blade=1 ; blade < BLADE_MAX-1 ; blade++) { 
a387 1
    grass_sp->proto.b[blade].magic = BLADE_MAGIC;
d389 6
a394 9
    /* rotate the vectors of blade 0 to form each extra blade */
    blade_rot(&grass_sp->proto.b[blade], &grass_sp->proto.b[0], m);

    /* scale the leaves so that they aren't all the same length */
    val = (double)blade / (double)(BLADE_MAX-1);
    val = val * .25 + .75;

    for (seg=0; seg < grass_sp->proto.b[blade].segs ; seg++) {
      grass_sp->proto.b[blade].leaf[seg].len *= val;
d396 1
a396 1

d400 1
d407 1
a407 1
  grass_sp->proto.b[blade].segs = 3;
d410 2
d414 2
d422 2
a423 8
    grass_sp->proto.b[blade].leaf[seg].len = 
#if 0
	    100 - seg * 20;
#else
    	grass_sp->t*1.25 + 
    		(grass_sp->proto.b[blade].segs - seg) *
    		grass_sp->t * .75;
#endif
d432 1
a432 1
    val -= (seg+1) * .2;
d630 1
a630 1
#if 1
d632 11
a642 1
			VSET(swp->sw_color, .7, .6, .3);
a643 1
#endif
d645 2
a646 1
		VSCAEL(swp->sw_color, swp->sw_color, fract);
d828 1
d841 1
a841 1

d859 2
a860 1
	bn_noise_vec(r->hit.hit_point, r->hit.hit_normal);
a1054 1

a1127 1

@


1.18
log
@checkpoint
@
text
@d288 1
d293 1
a293 1
	if ( w < .6) pl->blades--;
d299 2
d303 1
a303 1
			pl->b[blade].leaf[seg].len *= w;
d393 7
a399 2
    VMINMAX(grass_sp->proto.pmin, grass_sp->proto.pmax, grass_sp->proto.b[blade].pmin);
    VMINMAX(grass_sp->proto.pmin, grass_sp->proto.pmax, grass_sp->proto.b[blade].pmax);
d425 1
a425 1
    	grass_sp->t*2.0 + 
d437 1
a437 1
    val -= (seg+1) * .1;
d605 1
a605 1
hit_blade(bl, r, swp, grass_sp, seg, ldist, blade_num)
d613 1
a628 1
		VMOVE(r->hit.hit_normal, bl->leaf[seg].N);
d630 5
d640 2
d754 1
a754 1
				blade_num);
d846 3
a849 3
	VSET(swp->sw_color, 1.0, 0.0, 0.0);
#else

d852 4
d857 3
a859 2

#endif
d915 1
a915 1
	if (val > grass_sp->blade_width * 5)
d921 1
a921 1
	ppc = val * grass_sp->ppc;
@


1.17
log
@checkpoint
@
text
@d84 1
d108 1
d119 1
a119 1
	.3,				/* size */
d162 1
a162 1
	
d185 20
d283 1
a283 1
plant_scale(pl, w, val)
d285 1
a285 2
double w;	/* -1 .. 1 */
double val;
d292 1
a292 6
	if ( w < .5) pl->blades--;

	if (w >= 0.0) return;

	w *= 2.0;

d296 2
a297 2
		pl->b[blade].width +=
			pl->b[blade].width * w;
d300 1
a300 2
			pl->b[blade].leaf[seg].len += 
				pl->b[blade].leaf[seg].len * w;
a398 1

d403 1
a403 1
  grass_sp->proto.b[blade].width = grass_sp->blade_width * 2.0;
d417 3
a419 1
    	grass_sp->t*1.35 + seg * grass_sp->t * .75;
d539 1
d548 1
d552 10
a564 15
	VSCALE(pt, c, grass_sp->lacunarity);
	val = bn_noise_fbm(pt, grass_sp->h_val, grass_sp->lacunarity,
			grass_sp->octaves);

	VSCALE(pt, pt, grass_sp->lacunarity);
	foo = bn_noise_fbm(pt, grass_sp->h_val, grass_sp->lacunarity,
			grass_sp->octaves);

	if (rdebug&RDEBUG_SHADE)
		bu_log("val:%g  foo:%g\n", val, foo);
#if 1
	pl->root[X] += val * grass_sp->cell[X];
	pl->root[Y] += foo * grass_sp->cell[Y];
#endif
	val = val * .5 + .5;
d566 1
a566 1
	CLAMP(val, 0.0, 1.0);
a567 1
	plant_scale(pl, w, val);	/* must come first */
d569 2
a570 3
	foo *= 180.0;
	foo *= bn_degtorad;
	plant_rot(pl, foo);	/* computes bounding box */
d716 1
d721 10
a730 3
		fract = (accum_len + ldist[1]) / bl->tot_len;
		blade_width = bl->width * (1.0 - fract);

d900 4
a903 4
	VSCALE(c, cell, grass_sp->size);  /* int/float conv */
	val = bn_noise_fbm(c, grass_sp->h_val, grass_sp->lacunarity,
			grass_sp->octaves);
	ppc = (int) (grass_sp->ppc + grass_sp->ppcd * val * 2.0);
a904 1
	VMOVE(c, cell);
d1251 10
a1260 2
	/* setting basecolor to 1.0 prevents "filterglass" effect */
	VSETALL(swp->sw_basecolor, 1.0); 
d1262 9
@


1.16
log
@fixed memory corruption
@
text
@d27 37
d97 1
d110 1
a110 1
	70.0,				/* "t" mean length of leaf seg */
d117 1
a117 1
	1.0,				/* size */
d183 67
d251 172
d480 5
a508 26
/* compute the Region coordinates of the origin of a cell */
#define CELL_POS(cell_pos, grass_sp, cell_num) \
	cell_pos[X] = cell_num[X] * grass_sp->cell[X]; \
	cell_pos[Y] = cell_num[Y] * grass_sp->cell[Y]

#define BLADE_SEGS_MAX 4

#define LEAF_MAGIC 1024
#define BLADE_MAGIC 1023
#define PLANT_MAGIC 1022

struct leaf_segment {
	long	magic;
	double len;
	vect_t blade;	/* direction of blade growth */ 
	vect_t	N;	/* surface normal of blade segment */
};

struct blade {
	long			magic;
	double			tot_len;
	int			segs;
	struct leaf_segment	leaf[BLADE_SEGS_MAX];
	point_t			pmin;
	point_t			pmax;
};
a509 13
#define BLADE_MAX 4
struct plant {
	long		magic;
	point_t		root;	/* location of base of blade */
	int 		blades;
	struct blade	b[BLADE_MAX];
	point_t		pmin;
	point_t		pmax;
};
/*
 *
 *
 */
d511 6
a516 6
make_blade(bl, root, c, cell_pos, grass_sp)
struct blade *bl;
point_t		root;	/* location of base of plant */
point_t		c;	/* derived from cell_num */
CONST point_t	cell_pos;
CONST struct grass_specific *grass_sp;
d518 3
a520 4
	static CONST point_t z_axis = { 0.0, 0.0, 1.0 };
	point_t cl;	/* our local copy of the cell_pos for changing */
	vect_t	left;
	int t;
d522 1
a522 2
	vect_t v;
	point_t seg_start;
a523 1
	CK_grass_SP(grass_sp);
d526 1
a526 1
		bu_log("\tmake blade..");
a527 1
	bl->magic = BLADE_MAGIC;
d529 1
a529 1
	VMOVE(cl, c);
d531 2
a532 1
	bl->segs = grass_sp->nsegs;
d534 2
a535 23
	/* get vector for blade growth */
	bl->leaf[0].magic = LEAF_MAGIC;
	bn_noise_vec(cl, bl->leaf[0].blade);
	bl->leaf[0].blade[Z] += 1.0;
	VUNITIZE(bl->leaf[0].blade);
	bl->tot_len = bl->leaf[0].len = grass_sp->t + 
		bn_noise_turb(cl, grass_sp->h_val,
			grass_sp->lacunarity, grass_sp->octaves) *
		grass_sp->t;


	/* get surface normal for blade */
	VCROSS(left, bl->leaf[0].blade, z_axis);
	VUNITIZE(left);
	VCROSS(bl->leaf[0].N, left, bl->leaf[0].blade);
	VUNITIZE(bl->leaf[0].N);

	if (rdebug&RDEBUG_SHADE) {
		bu_log("root:%g %g %g\n\t  blade:%g %g %g N:%g %g %g  len:%g\n",
			V3ARGS(root), V3ARGS(bl->leaf[0].blade),
			V3ARGS(bl->leaf[0].N),
			bl->leaf[0].len);
	}
d537 3
a539 1
	VJOIN1(seg_start, root, bl->leaf[0].len, bl->leaf[0].blade);
d541 3
a543 1
	for (t=1; t < bl->segs ; t++) {
d545 7
a551 6
		bl->leaf[t].magic = LEAF_MAGIC;

		/* droop the blade */
		VMOVE(bl->leaf[t].blade, bl->leaf[t-1].blade);

		VJOIN1(v, root, t, bl->leaf[t-1].blade);
d553 1
a553 4
		val = bn_noise_turb(v, grass_sp->h_val,
				grass_sp->lacunarity, grass_sp->octaves);
		if (val < .3) val = .3;
		if (val > .9) val = .9;
d555 1
a555 1
		bl->leaf[t].blade[Z] *= val;
d557 3
a559 1
		VUNITIZE(bl->leaf[t].blade);
a560 3
		val = 1.0 - val;
		if (val < .3) val = .3;
		if (val > .9) val = .9;
d562 6
a567 1
		bl->tot_len += bl->leaf[t].len = bl->leaf[t-1].len * val;
d569 1
a569 8
		VCROSS(bl->leaf[t].N, left, bl->leaf[t].blade);
		VUNITIZE(bl->leaf[t].N);

		if (rdebug&RDEBUG_SHADE) {
	                bu_log("\t  seg:%g %g %g N:%g %g %g  len:%g\n",
	                	V3ARGS(bl->leaf[t].blade),
				V3ARGS(bl->leaf[t].N),
				bl->leaf[t].len);
d571 2
a572 4

		VJOIN1(seg_start, seg_start, bl->leaf[t].len, bl->leaf[t].blade);
		/* compute bounding box */
		VMINMAX(bl->pmin, bl->pmax, seg_start);
a573 11


	if (rdebug&RDEBUG_SHADE) {
		bu_log("\tbbox: %g %g %g   %g %g %g\n",
			V3ARGS(bl->pmin), V3ARGS(bl->pmax));
	}

	for (t = bl->segs ; t < BLADE_SEGS_MAX ; t++)
		bl->leaf[t].magic = 0;


a574 41
static void
make_plant(pl, c, cell_pos, grass_sp)
struct plant 			*pl;
point_t				c;	/* derived from cell_num */
CONST point_t			cell_pos;
CONST struct grass_specific 	*grass_sp;
{
	int i, j;
	point_t pt;
	double f, g;

	CK_grass_SP(grass_sp);

	pl->magic = PLANT_MAGIC;
	pl->blades = 1;	

	f = bn_noise_turb(c, grass_sp->h_val,
			grass_sp->lacunarity, grass_sp->octaves);

	g = f * (BLADE_MAX - 1);

	pl->blades = 1 + (g + .5);
	CLAMP(pl->blades, 0, (BLADE_MAX-1));

	
	if (rdebug&RDEBUG_SHADE)
		bu_log("%g means %d blades on plant\n", f, pl->blades);

	/* get position of the root of the blade */
	pl->root[X] = cell_pos[X] + 
		grass_sp->cell[X] * bn_noise_perlin(c);

	VSCALE(pt, c, grass_sp->lacunarity);
	pl->root[Y] = cell_pos[Y] + 
		grass_sp->cell[Y] * bn_noise_perlin(pt);
	pl->root[Z] = 0.0;	/* XXX not valid for non-slab grass */
	
	VMOVE(pl->pmin, pl->root);
	VMOVE(pl->pmax, pl->root);

	VMOVE(pt, c);
a575 23
	for (i=0 ; i < pl->blades ; i++ ) {
		make_blade(&pl->b[i], pl->root, pt, cell_pos, grass_sp);
		if (i == 0) {
			VMOVE(pl->pmin, pl->b[i].pmin);
			VMOVE(pl->pmax, pl->b[i].pmax);
		} else {
			VMINMAX(pl->pmin, pl->pmax, pl->b[i].pmin);
			VMINMAX(pl->pmin, pl->pmax, pl->b[i].pmax);
		}

		VSCALE(pt, pt, grass_sp->lacunarity);
	}
	for (i = pl->blades ; i < BLADE_MAX ; i++) {
		pl->b[i].magic = 0;
		for (j=0 ; j < BLADE_SEGS_MAX ; j++)
			pl->b[i].leaf[i].magic = 0;
	}

	if (rdebug&RDEBUG_SHADE) {
		bu_log("\tplant bbox: %g %g %g   %g %g %g\n",
			V3ARGS(pl->pmin), V3ARGS(pl->pmax));
	}

a576 1
}
d586 1
a586 1
hit_blade(bl, r, swp, grass_sp, seg, ldist)
d593 1
d611 5
d641 1
a641 1
isect_blade(bl, root, r, swp, grass_sp)
d647 1
d682 10
a691 3
		if (rdebug&RDEBUG_SHADE)
			bu_log("\t    cond:%d d1:%g d2:%g\n", cond, V2ARGS(ldist));

d710 1
a710 1
		blade_width = grass_sp->blade_width * (1.0 - fract);
d712 1
d717 1
a717 1
					grass_sp->blade_width);
d719 2
a720 1
			return hit_blade(bl, r, swp, grass_sp, seg, ldist);
d722 1
a722 1
		if (rdebug&RDEBUG_SHADE) bu_log("missed aside\n");
d748 1
a748 1
		r->r.r_min = r->r.r_max = 0.0;
d750 1
a750 1

d764 1
d785 3
a787 2
		status = isect_blade(&pl->b[i], pl->root, r, swp, grass_sp);
		if (status) return status;
d838 1
a838 1
long			cell[3];
d876 1
a876 2
	val *= 32.0;
	if (val >= grass_sp->cell[X] || val >= grass_sp->cell[Y])
d881 3
a883 2
	VMOVE(c, cell); /* int/float conv */
	val = bn_noise_perlin(c);
d886 1
d901 1
a901 1
		make_plant(&pl, c, cell_pos, grass_sp);
d1235 3
@


1.15
log
@multiple grass blades per root, and bounding boxes
@
text
@d22 1
d66 1
a66 1
CONST static
d257 1
a257 1
	point_t			root;	/* location of base of blade */
d260 2
a261 2
	point_t			pmin;
	point_t			pmax;
d275 1
a275 1
	CONST static point_t z_axis = { 0.0, 0.0, 1.0 };
a280 1
	point_t pmin, pmax;
d377 1
a377 1
	int i;
d392 2
d426 2
d446 2
a447 2
hit_blade(pl, r, swp, grass_sp, seg, ldist)
CONST struct blade *pl;
a453 2
	point_t PCA;

d468 1
a468 1
		VMOVE(r->hit.hit_normal, pl->leaf[seg].N);
d498 1
a498 1
CONST struct grass_ray *r;
d643 1
a643 2
	double val;
	point_t tmp;
d739 3
d743 4
@


1.14
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d26 2
d29 1
d31 3
d233 4
d238 1
d245 6
a250 6
	point_t	root;	/* location of base of blade */
	double	tot_len;
	int	segs;
	struct leaf_segment leaf[BLADE_SEGS_MAX];
	point_t	pmin;
	point_t	pmax;
d253 9
a261 1

d267 3
a269 2
make_blade(pl, c, cell_pos, grass_sp)
struct blade *pl;
d283 2
d288 1
a288 14
	/* get position of the root of the blade */
	pl->root[X] = cell_pos[X] + 
		grass_sp->cell[X] * bn_noise_perlin(c);

	VSCALE(cl, c, grass_sp->lacunarity);
	pl->root[Y] = cell_pos[Y] + 
		grass_sp->cell[Y] * bn_noise_perlin(cl);
	pl->root[Z] = 0.0;	/* XXX not valid for non-slab grass */
	

	VMOVE(pl->pmin, pl->root);
	VMOVE(pl->pmax, pl->root);

	VSCALE(cl, cl, grass_sp->lacunarity);
d290 1
a290 1
	pl->segs = grass_sp->nsegs;
d292 1
a292 1
	VSCALE(cl, cl, grass_sp->lacunarity * .5);
d295 6
a300 5
	bn_noise_vec(cl, pl->leaf[0].blade);
	pl->leaf[0].blade[Z] += 1.0;
	VUNITIZE(pl->leaf[0].blade);
	pl->tot_len = pl->leaf[0].len = grass_sp->t + 
		bn_noise_turb(pl->root, grass_sp->h_val,
d306 1
a306 1
	VCROSS(left, pl->leaf[0].blade, z_axis);
d308 2
a309 2
	VCROSS(pl->leaf[0].N, left, pl->leaf[0].blade);
	VUNITIZE(pl->leaf[0].N);
d312 4
a315 4
		bu_log("root:%g %g %g\n\t  blade:%g %g %g t:%g N:%g %g %g\n",
			V3ARGS(pl->root), V3ARGS(pl->leaf[0].blade),
			pl->leaf[0].len,
			V3ARGS(pl->leaf[0].N));
d318 1
a318 1
	VJOIN1(seg_start, pl->root, pl->leaf[0].len, pl->leaf[0].blade);
d320 1
a320 1
	for (t=1; t < pl->segs ; t++) {
d322 2
d325 1
a325 1
		VMOVE(pl->leaf[t].blade, pl->leaf[t-1].blade);
d327 1
a327 1
		VJOIN1(v, pl->root, t, pl->leaf[t-1].blade);
d334 1
a334 1
		pl->leaf[t].blade[Z] *= val;
d336 1
a336 1
		VUNITIZE(pl->leaf[t].blade);
d342 1
a342 1
		pl->tot_len += pl->leaf[t].len = pl->leaf[t-1].len * val;
d344 2
a345 2
		VCROSS(pl->leaf[t].N, left, pl->leaf[t].blade);
		VUNITIZE(pl->leaf[t].N);
d348 70
a417 3
	                bu_log("\t  blade:%g %g %g N:%g %g %g\n",
	                	V3ARGS(pl->leaf[t].blade),
				V3ARGS(pl->leaf[t].N));
d420 1
a420 1
		VJOIN1(seg_start, seg_start, pl->leaf[t].len, pl->leaf[t].blade);
d422 8
a430 2
	/* compute bounding box */
	VMINMAX(pl->pmin, pl->pmax, seg_start);
d452 4
d493 3
a495 2
isect_blade(pl, r, swp, grass_sp)
CONST struct blade *pl;
d514 3
d520 1
a520 1
	VMOVE(pt, pl->root);
d522 2
d526 3
a528 1
	for (seg=0 ; seg < pl->segs ; accum_len += pl->leaf[seg].len ) {
d531 1
a531 1
			pt, pl->leaf[seg].blade, &r->tol);
d537 1
a537 1
		    ldist[0] >= r->r.r_max	/* beyond out point */ ||
d539 1
a539 1
		    ldist[1] > pl->leaf[seg].len/* beyond end of seg */
d545 1
a545 1
		VJOIN1(PCA_grass, pt, ldist[1], pl->leaf[seg].blade);
d553 1
a553 1
		fract = (accum_len + ldist[1]) / pl->tot_len;
d562 1
a562 1
			return hit_blade(pl, r, swp, grass_sp, seg, ldist);
d568 1
a568 1
		VJOIN1(pt, pt, pl->leaf[seg].len, pl->leaf[seg].blade);
d575 4
a578 13

#if 0
/*
 *	N O R M _ N O I S E
 *
 *	Apply a noise function to the surface normal
 */
static void
norm_noise(pt, val, gravel_sp, func, swp, rescale)
point_t pt;
double val;
struct gravel_specific *gravel_sp;
double (*func)();
d580 1
a580 1
int rescale;
d582 1
a582 5
	vect_t N, tmp;
	point_t u_pt, v_pt;
	vect_t u_vec, v_vec;
	double u_val, v_val;
	mat_t u_mat, v_mat;
d584 3
a586 3
	/* dork the normal around
	 * Convert the normal to shader space, get u,v coordinate system
	 */
d589 2
a590 1
		VPRINT("Model space Normal", swp->sw_hit.hit_normal);
a591 5
	MAT4X3VEC(N, gravel_sp->m_to_sh, swp->sw_hit.hit_normal);
	VUNITIZE(N);
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Shader space Normal", N);
	}
d593 30
a622 32
	/* construct coordinate system from vectors perpendicular to normal */
	bn_vec_perp(u_vec, N);
	VCROSS(v_vec, N, u_vec);

	/* compute noise function at position slightly off pt in both
	 * U and V directions to get change in values
	 */
	VJOIN1(u_pt, pt, gravel_sp->nsd, u_vec);
	u_val = func(u_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);

	if (rescale) RESCALE_NOISE(u_val);

	VJOIN1(v_pt, pt, gravel_sp->nsd, v_vec);
	v_val = func(v_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);

	if (rescale) RESCALE_NOISE(v_val);

	/* construct normal rotation about U and V vectors based upon 
	 * variation in surface in each direction.  Apply the result to
	 * the surface normal.
	 */
	bn_mat_arb_rot(u_mat, pt, u_vec, (val - v_val) * gravel_sp->max_angle);
	MAT4X3VEC(tmp, u_mat, N);

	bn_mat_arb_rot(v_mat, pt, v_vec, (val - u_val) * gravel_sp->max_angle);

	MAT4X3VEC(N, v_mat, tmp);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("old normal", swp->sw_hit.hit_normal);
d625 3
a627 4
	MAT4X3VEC(swp->sw_hit.hit_normal, gravel_sp->sh_to_m, N);
	VUNITIZE(swp->sw_hit.hit_normal);
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("new normal", swp->sw_hit.hit_normal);
d629 1
d631 1
a631 1
#endif
d645 3
d691 1
a691 1
	struct blade pl;
d695 2
d711 1
d738 1
a738 1
		make_blade(&pl, c, cell_pos, grass_sp);
d740 1
a740 1
		hit |= isect_blade(&pl, r, swp, grass_sp);
d783 3
d863 2
d879 1
d914 1
a914 1
	gr.r.r_max = gr.hit.hit_dist = out_dist = MAGNITUDE(v);
d924 1
@


1.13
log
@checkpoint
@
text
@d130 2
a131 2
struct mfuncs grass_mfuncs[] = {
	{"grass",	0,	0,	MFI_NORMAL|MFI_HIT|MFI_UV,  MFF_PROC,
d134 1
a134 1
	{(char *)0,	0,		0,		0,		0,
@


1.12
log
@grass in cells instead of at corners.
@
text
@d18 5
d41 1
a41 1
	double	ppc;		/* plants_per_cell */
d45 2
d50 2
a51 2
	double	size;
	point_t	vscale;	/* size of noise coordinate space */
d62 1
a62 1
	{1.0, 1.0},			/* cell */
d67 2
d90 4
a93 4
	{"%f",  2, "cell",		SHDR_AO(cell),	FUNC_NULL },
	{"%f",	1, "ppc",		SHDR_O(ppc),	FUNC_NULL },
	{"%f",	1, "ppcd",		SHDR_O(ppcd),	FUNC_NULL },
	{"%f",	1, "t",			SHDR_O(t),	FUNC_NULL },
d96 1
a96 1
	{"%f",	1, "H", 		SHDR_O(h_val),	FUNC_NULL },
d98 3
a100 1
	{"%f",  1, "size",		SHDR_O(size),	FUNC_NULL },
d113 3
d131 1
a131 1
	{"grass",	0,	0,	MFI_HIT,  MFF_PROC,
d193 1
d220 2
a221 1
#define CELL_POS(cell_num, grass_sp, cell_pos) \
d233 3
a235 2
struct plant {
	point_t	root;	/* location of base of plant */
d238 2
d241 6
d248 2
a249 2
make_plant(pl, c, cell_pos, grass_sp)
struct plant *pl;
d260 2
d264 1
a264 5
		bu_log("\tmake plant..");

	/* get position of the root of the plant */


d266 1
d274 4
d281 1
a282 6
#if 0
	pl->segs = 1 + (BLADE_SEGS_MAX-1) * 
		bn_noise_turb(cl, grass_sp->h_val, grass_sp->lacunarity, 3);
#else
	pl->segs = 3;
#endif
d289 1
a289 1
	pl->leaf[0].len = grass_sp->t + 
d294 1
d308 1
d330 1
a330 1
		pl->leaf[t].len = pl->leaf[t-1].len * val;
d340 2
d343 4
d358 2
a359 2
CONST struct plant *pl;
CONST struct grass_ray *r;
d369 1
a369 1
		bu_log("hit_blade\n");
d375 18
a392 3
		VJOIN1(swp->sw_hit.hit_point, r->r.r_pt, ldist[0], r->r.r_dir);
		VMOVE(swp->sw_hit.hit_normal, pl->leaf[seg].N);
		return 1;
d394 1
a394 1
	return 0;
d397 1
a397 1
/*	intersect ray with leaves of single plant
d404 2
a405 2
isect_plant(pl, r, swp, grass_sp)
CONST struct plant *pl;
d419 3
d423 1
d425 1
a425 1
		bu_log("\t  isect_plant()\n");
d429 3
a431 1
	for (seg=0 ; seg < pl->segs ; ) {
d451 14
a464 1
		if (dist < (PCA_ray_radius+grass_sp->blade_width)) {
d475 108
a582 1
	return 0;
d610 1
a610 1
	struct plant pl;
d612 1
d617 21
d642 1
a642 1
	CELL_POS(cell, grass_sp, cell_pos);
d654 1
a654 1
		make_plant(&pl, c, cell_pos, grass_sp);
d656 1
a656 1
		hit |= isect_plant(&pl, r, swp, grass_sp);
d681 1
a681 1
 *	~0	abort grid marching
d686 2
a687 2
struct grass_ray		*r;
short 			flags;
d754 1
a756 1

d765 1
d772 1
d826 2
a827 1
	
d926 1
a926 1
			CELL_POS(cell_num, grass_sp, cell_pos);
d932 1
a932 1
		if (do_cells(cell_num, &gr, flags,
d987 1
d1000 2
d1004 8
d1014 4
d1019 1
a1026 2
	VSUB2(v, swp->sw_hit.hit_point, ap->a_ray.r_pt);
	swp->sw_hit.hit_dist = MAGNITUDE(v);
@


1.11
log
@gutted and reworked for different cell marching strategy
@
text
@d21 8
d36 5
a40 1
	double	lacunarity;
d46 1
d48 1
d56 4
d82 4
d95 3
a97 1
	{"%f",  2, "c",			SHDR_AO(cell),	FUNC_NULL },
d100 2
a101 1
	{"%f",  1, "s",			SHDR_O(size),	FUNC_NULL },
d117 1
a117 1
	{"grass",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d174 2
d205 209
d418 2
d422 1
a422 1
 *	~0	abort grid marching
d427 1
a427 1
struct xray		*r;
d432 10
a441 1
	if( rdebug&RDEBUG_SHADE)
d444 24
a467 1
	return 0;
d492 1
a492 1
struct xray		*r;
d500 1
d525 1
a525 3
			if (isect_cell(cell, r, swp, out_dist, grass_sp))
				return 1;

d528 1
a528 1
	return 0;
d547 1
a547 1
	struct xray	r;
d559 1
d571 16
d591 3
a593 3
	MAT4X3PNT(r.r_pt, grass_sp->m_to_sh, ap->a_ray.r_pt);
	MAT4X3VEC(r.r_dir, grass_sp->m_to_sh, ap->a_ray.r_dir);
	VUNITIZE(r.r_dir);
d603 1
d606 5
d619 1
a619 1
	VSUB2(v, in_pt, r.r_pt);
d621 10
a630 2
	VSUB2(v, out_pt, r.r_pt);
	out_dist = MAGNITUDE(v);
d634 1
a634 1
			V3ARGS(r.r_pt));
d636 1
a636 1
			V3ARGS(r.r_dir));
d677 3
a679 3
		if (r.r_dir[n] < -SMALL_FASTF) {
			tD[n] = -grass_sp->cell[n] / r.r_dir[n];
			t[n] = t[n] / -r.r_dir[n];
d681 2
a682 2
		} else if (r.r_dir[n] > SMALL_FASTF) {
			tD[n] = grass_sp->cell[n] / r.r_dir[n];
d684 1
a684 1
			t[n] = t[n] / r.r_dir[n];
d729 1
a729 2
			cell_pos[X] = cell_num[X] * grass_sp->cell[X];
			cell_pos[Y] = cell_num[Y] * grass_sp->cell[Y];
d735 1
a735 1
		if (do_cells(cell_num, &r, flags,
d739 1
d743 1
a743 1
			if (r.r_dir[X] < 0.0) {
d754 1
a754 1
			if (r.r_dir[Y] < 0.0) {
d768 1
a768 1
		VJOIN1(curr_pt, r.r_pt, curr_dist, r.r_dir);
d786 16
d803 14
a816 2
done:
	/* Tell stacker to shade with plastic */
@


1.10
log
@preparing to change everything
@
text
@d27 1
a27 1
	double	grass_cell[2];	/* size of a cell in Region coordinates */
a34 1
/*	mat_t	sh_to_m;	/* shader to model space matrix */
d41 1
a41 1
	{1.0, 1.0},			/* grass_cell */
a57 1

d63 1
a63 1
	{"%f",  2, "cell",		SHDR_AO(grass_cell),	FUNC_NULL },
d73 1
a73 1
	{"%f",  2, "c",			SHDR_AO(grass_cell),	FUNC_NULL },
a114 2
	mat_t	tmp;
	vect_t	bb_min, bb_max, v_tmp;
d178 3
a180 1
/*  Process a grid cell and any unprocessed adjoining neighbors.
d187 6
a192 3
process(curr_pt, flags)
point_t curr_pt;
short flags;
d194 2
a195 1
	point_t grid_loc;
d200 7
a206 3
/* The flags argument indicates which cells (relative to the central one)
 * have already been processed.  The bits in the flag word are assigned
 * as follows: ABCDEFGHI.  and represent the relative grid positions:
d208 5
a212 3
 *	G H I
 *	D E F
 *	A B C
a213 6
 * So to move one row in the positive Y direction, we shift the bits
 * as follows: DEFGHI000 while to move in the negative Y we shift the
 * bits as in: 000ABCDEF.
 * Moving in X is slightly more tricky.  To move one row in the positive X
 * direction, a bit pattern ABCDEFGHI becomes BC0EF0HI0 and negative X move
 * results in 0AB0DE0GH.
d215 3
a217 1
 * To hide the gory details, we have some macros to do the work.
d219 14
a232 7
#define FLAGS_X_MOVE(f, s) \
	if (s < 0) f = 0333;	/* ABC DEF GHI -> 0AB 0DE 0GH */\
	else f = 0666		/* ABC DEF GHI -> BC0 EF0 HI0 */

#define	FLAGS_Y_MOVE(f, s) \
	if (s < 0) f = 0077;	/* ABC DEF GHI -> 000 ABC DEF */\
	else f = 0770		/* ABC DEF GHI -> DEF GHI 000 */
d234 22
d257 4
a281 1
	double		tX, tDX, tY, tDY;
d285 7
d300 4
a303 2
	/* figure out the in/out points, and the radius of the beam in
	 * "region" space.
d309 1
d319 1
d326 1
a326 1

d329 19
a347 2
	VSUB2(v, out_pt, in_pt);
	out_dist = curr_dist + MAGNITUDE(v);
d350 1
a350 1
	/* tDX is the distance along the ray we have to travel
d354 1
a354 1
	 * tX is the distance along the ray to the first cell boundary
d356 5
d362 30
a391 12
	tX = in_pt[X] - 
		floor(in_pt[X]/grass_sp->grass_cell[X]) *
			       grass_sp->grass_cell[X];
	if (r.r_dir[X] < 0.0) {
		tDX = -grass_sp->grass_cell[X] / r.r_dir[X];
		tX += curr_dist;
	} else if (r.r_dir[X] > 0.0) {
		tDX = grass_sp->grass_cell[X] / r.r_dir[X];
		tX = grass_sp->grass_cell[X] - tX;
		tX += curr_dist;
	} else {
		tDX = tX = MAX_FASTF;
d393 1
a393 1
	if (tX > out_dist) tX = out_dist;
d395 3
a397 13
	/* tDY and tY are for Y as tDX and tX are for X */
	tY = in_pt[Y] - 
		floor(in_pt[Y]/grass_sp->grass_cell[Y]) *
		               grass_sp->grass_cell[Y];
	if (r.r_dir[Y] < 0.0) {
		tDY = -grass_sp->grass_cell[Y] / r.r_dir[Y];
		tY += curr_dist;
	} else if (r.r_dir[Y] > 0.0) {
		tDY = grass_sp->grass_cell[Y] / r.r_dir[Y];
		tY = grass_sp->grass_cell[Y] - tY;
		tY += curr_dist;
	} else {
		tDY = tY = MAX_FASTF;
d399 17
a415 1
	if (tY > out_dist) tY = out_dist;
a417 2
	flags = 0;
	VMOVE(curr_pt, in_pt);
d420 18
a437 2
		/* XXX need to get/pass cell #'s and cell widths */
		if (process(curr_pt, flags))
d440 11
a450 5
		if (tX < tY) {
			FLAGS_X_MOVE(flags, r.r_dir[X]);
			curr_dist = tX;
			tX += tDX;
			if (tX > out_dist) tX = out_dist; 
d452 10
a461 4
			FLAGS_Y_MOVE(flags, r.r_dir[Y]);
			curr_dist = tY;
			tY += tDY;
			if (tY > out_dist) tY = out_dist; 
d463 8
a470 1
		VJOIN1(curr_pt, in_pt, curr_dist, r.r_dir);
@


1.9
log
@tweak
@
text
@d4 1
a4 1
 *  This shader mimics certain characteristics of grass.
a5 21
 *  XXX At the moment, this shader assumes that the solid is
 *  a slab from 0.0 to .5m in height.
 *
 *  Parameters:
 *	h/height  space scaling factor for noise call to get height of grass
 *	f/func	  one of either "fbm" or "tur" for the noise function for 
 *			grass height.
 *	t/tilt	  space scaling factor for noise call to get tilt of blades
 *	s/size	  space scaling factor for grid (how small are the cells
 *			between grass blades.
 *	r/radius  size/width of a blade of grass
 *
 *
 *
 *	The usual noise parameters:
 *	   Lacunarity, octaves, h_val, 
 *
 *	Present, but unused at the moment:
 *	   delta, max, min
 *
 *
a14 1
#include "./light.h"
d18 1
a18 8
/* #define SHADOWS 0*/
#define RI_AIR		1.0		/* Refractive index of air */

#define PREV_X	3
#define PREV_Y	7
#define PREV_NONE 0

#define grass_MAGIC 0x9    /* make this a unique number for each shader */
a20 18
struct grass_ray {
	long		magic;
	struct xray	r;
	struct bn_tol	*tol;
	fastf_t		radius;
	fastf_t		diverge;
};

struct grass_hit {
	struct hit	h;
	vect_t		stalk;
	point_t		root;
	vect_t		normal;
	double		len;
	double		alt;
	double		noise;
};

d27 1
d34 2
a35 10
	double	tilt_scale;		/* lean/tilt noise scaling */
	double	height_scale;	/* grass length noise scaling */
	double	grass_radius;	/* "diameter" of grass blades */
	vect_t	grass_delta;	/* offset into noise space */
	point_t grass_min;
	point_t grass_max;
	char	hfunc[4];	/* func to call for noise */
	mat_t	m_to_r;	/* model to region space matrix */
	mat_t	r_to_m;	/* region to model space matrix */
	double	inv_size;
d42 6
a47 5
	2.1753974,	/* lacunarity */
	1.0,		/* h_val */
	4.0,		/* octaves */
	1.0,		/* size */
	{ 1.0, 1.0, 1.0 },	/* vscale */
d49 4
a52 11
	3.141592653,			/* tilt_scale */
	1.0,				/* height_scale */
	1.0,				/* grass_radius */
	{ 1.0, 1.0, 1.0 },		/* grass_delta */
	{ 0.0, 0.0, 0.0 },		/* grass_min */
	{ 0.0, 0.0, 0.0 },		/* grass_max */
	"fbm",				/* func */
	{	1.0, 0.0, 0.0, 0.0,	/* grass_m_to_sh */
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0 }
d65 1
a69 10
	{"%f",  1, "1/size",		SHDR_O(inv_size),	FUNC_NULL },
	{"%f",  1, "tilt",		SHDR_O(tilt_scale),	FUNC_NULL },
	{"%f",  1, "height",		SHDR_O(height_scale),	FUNC_NULL },
	{"%f",  1, "radius",		SHDR_O(grass_radius),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(grass_delta),	FUNC_NULL },
	{"%f",  3, "max",		SHDR_AO(grass_max),	FUNC_NULL },
	{"%f",  3, "min",		SHDR_AO(grass_min),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(grass_delta),	FUNC_NULL },
	{"%s",	4, "func",		SHDR_AO(hfunc),		FUNC_NULL },
	{"%f",  16, "m_to_r",		SHDR_AO(m_to_r),	FUNC_NULL },
d75 1
a78 5
	{"%f",  1, "t",			SHDR_O(tilt_scale),	FUNC_NULL },
	{"%f",  1, "r",			SHDR_O(grass_radius),	FUNC_NULL },
	{"%f",  1, "h",			SHDR_O(height_scale),	FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(grass_delta),	FUNC_NULL },
	{"%s",	4, "f",			SHDR_AO(hfunc),		FUNC_NULL },
d94 1
a94 1
	{"grass",	0,	0, MFI_NORMAL|MFI_HIT|MFI_UV,	MFF_PROC,
d117 2
d127 1
a127 1
		bu_log("grass_setup(%s)\n", rp->reg_name);
d147 3
a149 2
	/* We're going to operate in Region space so we can extract known
	 * distances and sizes in mm for the shader calculations.
d151 1
a151 7
	db_region_mat(grass_sp->m_to_r, rtip->rti_dbip, rp->reg_name);

	grass_sp->inv_size = 1.0 / grass_sp->size;

	mat_inv(grass_sp->r_to_m, grass_sp->m_to_r);

	grass_sp->grass_radius *= grass_sp->size;
d155 1
a155 1
		mat_print( "m_to_r", grass_sp->m_to_r );
d182 1
a182 17


/* Make sure the Z value of a vector is larger than X and Y */
#define VECT_UP(v) { register double t; \
	if (v[X] > v[Y]) { \
		if (v[X] > v[Z]) { \
			t = v[X]; v[X] = v[Z]; v[Z] = t; \
		} \
	} else { \
		if (v[Y] > v[Z]) { \
			t = v[Y]; v[Y] = v[Z]; v[Z] = t; \
		} \
	} \
}

/*
 *	Intersect ray with grass at one grid crossing.
d184 3
a186 3
 *	Return:
 *		0	No hit, no changes
 *		1	Hit grass, struct "h" filled in.
d189 3
a191 6
grass_isect(gr, grid_pt, t, grass_sp, h)
struct grass_ray *gr;
point_t grid_pt;	/* grid location to intersect */
double t;		/* distance from "in" along "dir" to curr grid crossing */
struct grass_specific *grass_sp;
struct grass_hit *h;		/* return information */
d193 1
a193 18
	point_t	tmp;
	point_t	npt;	/* new point for stalk origin */
	vect_t	stalk;
	int 	cond;
	double	dist;
	double	val;
	double	len;
	double	ldist[2];
	point_t	PCA_grass;
	point_t	PCA_ray;
	double	PCA_ray_radius;

	/* compute tilting from vertical for this stalk */
	VSCALE(tmp, grid_pt, grass_sp->tilt_scale);
	bn_noise_vec(tmp, stalk);
	VECT_UP(stalk);
	stalk[Z] += 2.0;
	VUNITIZE(stalk);
d195 1
a195 85
	/* Adding a perturbation of the grid point to break up
	 * some of the "grid" structure of the stalk locations.
	 */
	npt[X] = grid_pt[X] - stalk[X];
	npt[Y] = grid_pt[Y] - stalk[Y];
	npt[Z] = grid_pt[Z] = 0.0;

	/* intersect ray with vertical stalk
	 * XXX we really should take advantage of the tolerance here
	 */
	cond = rt_dist_line3_line3(ldist, gr->r.r_pt, gr->r.r_dir,
		npt, stalk, gr->tol);


	if (cond < 0) {
		if (rdebug&RDEBUG_SHADE) bu_log("grass colinear w/ray\n");
		if (cond < -1) return 0;

		/* XXX Lines are parallel and collinear */
		return 0;
	}

	if (ldist[0] >= gr->r.r_max /* beyond out point */ ||
	    ldist[1] < 0.0 /* under ground */)
	    	return 0;


	/* Noise function to define height of grass blades */
	VSCALE(tmp, npt, grass_sp->height_scale);

	if (!strncmp(grass_sp->hfunc, "fbm", 3)) {
		val = bn_noise_fbm(tmp, grass_sp->h_val,
			grass_sp->lacunarity, grass_sp->octaves);
	} else if (!strncmp(grass_sp->hfunc, "tur", 3)) {
		val = bn_noise_turb(tmp, grass_sp->h_val,
			grass_sp->lacunarity, grass_sp->octaves) - .5;
	} else {
		bu_log("unkown noise func \"%s\". Using fbm\n", grass_sp->hfunc);
		val = bn_noise_fbm(tmp, grass_sp->h_val,
			grass_sp->lacunarity, grass_sp->octaves);
	}

#define HEIGHT_OF_SOLID (500.0 * grass_sp->size) /* XXX height of solid in mm */
	len = val * HEIGHT_OF_SOLID;
	if (len < 0.0 /* negative grass length */ ||
	    ldist[1] > len  /* Isect point off end of grass */) {

		if (rdebug&RDEBUG_SHADE) bu_log("grass short\n");
	    	return 0;
	}
	/* compute Pt of closest approach along ray */
	VJOIN1(PCA_ray, gr->r.r_pt, ldist[0], gr->r.r_dir);
	PCA_ray_radius = gr->radius + ldist[0] * gr->diverge;

#if 0
	/* if the grass is too short, we miss and march onward */
	if ( (PCA_ray[Z] - PCA_ray_radius) >= len) {

		return 0;
	}
#endif
	VJOIN1(PCA_grass, npt, ldist[1], stalk);
	VSUB2(tmp, PCA_grass, PCA_ray);
	dist = MAGNITUDE(tmp);
	if (dist > (PCA_ray_radius+grass_sp->grass_radius)) {
		if (rdebug&RDEBUG_SHADE) bu_log("missed aside\n");
		return 0;
	}

	/* At this point we've got a hit */
	h->h.hit_dist = ldist[0];
	VMOVE(h->h.hit_point, PCA_ray);
	VMOVE(h->stalk, stalk);
	VMOVE(h->root, npt);
	h->len = len;
	h->alt = ldist[1];
	h->noise = val;

	/* XXX we really should look at how much of the ray footprint
	 * is occupied by the blade, and potentially march on collecting
	 * more information about other points hit.  This would allow
	 * better color selection.
	 */

	return 1;
d198 14
a211 3

/*
 *	March through the grass, intersecting with each grid crossing.
d213 1
a213 3
 *	Return:
 *		0	Missed everything
 *		1	Hit some grass, h modified
d215 7
a221 59
static int
grass_march(gr, grass_sp, h)
struct grass_ray *gr;
struct grass_specific *grass_sp;
struct grass_hit *h;
{
	double	tDX;		/* dist along ray to span 1 cell in X dir */
	double	tDY;		/* dist along ray to span 1 cell in Y dir */
	double	tX, tY;	/* dist along ray from hit pt. to next cell boundary */
	double	which_x;
	double	which_y;
	point_t	next_pt;
	point_t grid_pt;
	int		step_prev;

	grid_pt[Z] = 0.0;

	/* tDX is the distance along the ray we have to travel
	 * to traverse a cell (travel a unit distance) along the
	 * X axis of the grid.
	 *
	 * tX is the distance along the ray from the initial hit point
	 * to the first cell boundary in the X direction
	 */
	if (gr->r.r_dir[X] < 0.0) {
		tDX = -1.0 / gr->r.r_dir[X];
		tX = (gr->r.r_pt[X] - ((int)gr->r.r_pt[X])) / gr->r.r_dir[X];
		which_x = 0.0;
	} else {
		tDX = 1.0 / gr->r.r_dir[X];
		if (gr->r.r_dir[X] > 0.0)
			tX = (1.0 - (gr->r.r_pt[X] - ((int)gr->r.r_pt[X]))) / gr->r.r_dir[X];
		else
			tX = MAX_FASTF;
		which_x = 1.0;
	}
	if (tX > gr->r.r_max) tX = gr->r.r_max;


	/* tDY is the distance along the ray we have to travel
	 * to traverse a cell (travel a unit distance) along the
	 * Y axis of the grid
	 *
	 * tY is the distance along the ray from the initial hit point
	 * to the first cell boundary in the Y direction
	 */
	if (gr->r.r_dir[Y] < 0.0) {
		tDY = -1.0 / gr->r.r_dir[Y];
		tY = (gr->r.r_pt[Y] - ((int)gr->r.r_pt[Y])) / gr->r.r_dir[Y];
		which_y = 0.0;
	} else {
		tDY = 1.0 / gr->r.r_dir[Y];
		if (gr->r.r_dir[Y] > 0.0)
			tY = (1.0 - (gr->r.r_pt[Y] - ((int)gr->r.r_pt[Y]))) / gr->r.r_dir[Y];
		else
			tY = MAX_FASTF;
		which_y = 1.0;
	}
	if (tY > gr->r.r_max) tY = gr->r.r_max;
a222 5
	/* time to go marching through the noise space */
	if( rdebug&RDEBUG_SHADE) {
		bu_log("tX %g  tDX %g\n", tX, tDX);
		bu_log("tY %g  tDY %g\n", tY, tDY);
	}
d225 1
a225 154
	/* March through the grid, cell by cell.  At each cell boundary,
	 * we intersect the ray with cell corners.  By keeping track of whether
	 * the previous boundary was the same axis as the current one, we can
	 * avoid intersecting any cell corner more than once. 
	 */
	while (tX < gr->r.r_max || tY < gr->r.r_max) {
		if (tX < tY) {
			/* one step in X direction */
			VJOIN1(next_pt, gr->r.r_pt, tX, gr->r.r_dir);
			grid_pt[X] = floor(next_pt[X]);

			if (step_prev != PREV_Y) {
				/* check (int)y and (int)y+1.0 */
				grid_pt[Y] = floor(next_pt[Y]);

				if( rdebug&RDEBUG_SHADE)
					bu_log("tX(%g) pt %g %g %g (check 2)\n\tgrid_pt=%g,%g,%g\n",
						tX, V3ARGS(next_pt), V3ARGS(grid_pt));

				if (grass_isect(gr, grid_pt, tX, grass_sp, h))
					return 1;


				grid_pt[Y] += 1.0;
				if( rdebug&RDEBUG_SHADE)
					bu_log("\tgrid_pt=%g,%g,%g\n", V3ARGS(grid_pt));

				if (grass_isect(gr, grid_pt, tX, grass_sp, h))
					return 1;

			} else {
				/* check only the rayward one */
				grid_pt[Y] = floor(next_pt[Y]+which_y);

				if( rdebug&RDEBUG_SHADE)
					bu_log("tX(%g) pt %g %g %g (check 1)\n\tgrid_pt=%g,%g,%g\n",
						tX, V3ARGS(next_pt), V3ARGS(grid_pt));

				if (grass_isect(gr, grid_pt, tX, grass_sp, h))
				  	return 1;
			}
			step_prev = PREV_X;
			tX += tDX;
		} else {
			/* one step in Y gr->r.r_direction */
			VJOIN1(next_pt, gr->r.r_pt, tY, gr->r.r_dir);
			grid_pt[Y] = floor(next_pt[Y]);

			if (step_prev != PREV_X) {
				/* check (int)x and (int)x+1.0 */
				grid_pt[X] = floor(next_pt[X]);

				if( rdebug&RDEBUG_SHADE)
					bu_log("tY(%g) pt %g %g %g (check 2)\n\tgrid_pt=%g,%g,%g\n",
						tY, V3ARGS(next_pt),
						V3ARGS(grid_pt));

				if (grass_isect(gr, grid_pt, tY, grass_sp, h))
						return 1;

				grid_pt[X] += 1.0;
				if( rdebug&RDEBUG_SHADE)
					bu_log("\tgrid_pt=%g,%g,%g\n", V3ARGS(grid_pt));

				if (grass_isect(gr, grid_pt, tY, grass_sp, h))
						return 1;
			} else {
				/* check only the rayward one */
				grid_pt[X] = floor(next_pt[X]+which_x);

				if( rdebug&RDEBUG_SHADE)
					bu_log("tY(%g) pt %g %g %g (check 1)\n\tgrid_pt=%g,%g,%g\n",
						tY, V3ARGS(next_pt), V3ARGS(grid_pt));

				if (grass_isect(gr, grid_pt, tY, grass_sp, h))
						return 1;
			}
			step_prev = PREV_Y;
			tY += tDY;
		}
	}
	return 0;
}




static void
do_hit(swp, ap, h, grass_sp)
struct shadework *swp;
struct application	*ap;
struct grass_hit *h;
struct grass_specific *grass_sp;
{
	CONST static vect_t up = {0.0, 0.0, 1.0};
	vect_t left;
	vect_t tmp;
	double colorscale;

	/* re-scale shader hit point/distance back into model space */
	swp->sw_hit.hit_dist += grass_sp->inv_size * h->h.hit_dist;

	VSCALE(	swp->sw_hit.hit_point, h->h.hit_point, grass_sp->inv_size);

	swp->sw_transmit = 0.0;

	/* Need to pick a normal */
	VCROSS(left, h->stalk, up);
	VUNITIZE(left);
	VCROSS(swp->sw_hit.hit_normal, left, h->stalk);
	VUNITIZE(swp->sw_hit.hit_normal);
	if( rdebug&RDEBUG_SHADE) {
		bu_log("Hit grass blade\n");
		bu_log("grass root (%g %g %g) stalk (%g %g %g) %g\n",
			V3ARGS(h->root), V3ARGS(h->stalk), MAGNITUDE(h->stalk));
		bu_log("left (%g %g %g) %g\n", V3ARGS(left), MAGNITUDE(left));
		bu_log("Original grass normal (%g %g %g)\n",
			V3ARGS(swp->sw_hit.hit_normal));
	}

	if (VDOT(swp->sw_hit.hit_normal, ap->a_ray.r_dir) > 0.0) {
		VREVERSE(swp->sw_hit.hit_normal,
			swp->sw_hit.hit_normal);
	}
	if (swp->sw_hit.hit_normal[Z] < 0.0)
		swp->sw_hit.hit_normal[Z] *= -1.0;



#if 1
	colorscale = h->alt/h->len;
	if (colorscale > 0.9) {
		/* XXX a hack to turn the grass tips brown */
		VSET(swp->sw_color, .4, .31, .18);
	} else {
		colorscale = colorscale * 0.75 + 0.5;
		VSCALE(swp->sw_color, swp->sw_basecolor, colorscale);
	}
#endif
	if( rdebug&RDEBUG_SHADE) {

		bu_log("Hit pt (%g %g %g) (dist:%g)\n",
			V3ARGS(swp->sw_hit.hit_point),
			swp->sw_hit.hit_dist);

		bu_log("Normal %g %g %g\n",
			V3ARGS(swp->sw_hit.hit_normal));
	}
}




/*
a230 3
 *
 *	Because grass doesn't tend to move around from place to place
 *	in the scene or get scaled up and down, we opt to work in region space.
d241 8
a248 6
	struct grass_ray gr;
	point_t 	in_pt, out_pt;
	double		in_pt_radius, out_pt_radius;
	double		out_dist;
	struct grass_hit	h;
	int			status;
d255 4
a258 8
	if( rdebug&RDEBUG_SHADE) bu_log("grass_render\n");

	/* figure out the in/out points, and the radius of the beam
	 * We can work in model space since grass isn't likely to be moving
	 * around the scene.
	 *
	 * XXX We really should at least operate in Region space.
	 * MAT4X3PNT(in_pt, grass_sp->m_to_r, swp->sw_hit.hit_point);
d260 3
a262 2
	VJOIN1(in_pt, ap->a_ray.r_pt, swp->sw_hit.hit_dist, ap->a_ray.r_dir);
	in_pt_radius = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
d264 1
a264 2
	VJOIN1(out_pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	out_pt_radius = ap->a_rbeam + pp->pt_outhit->hit_dist * ap->a_diverge;
d266 2
a267 6
	/* We usually can't afford to evaluate the shader every mm so we allow
	 * the user to scale space by a constant to reduce the density of
	 * the grass and the number of computations needed.
	 *
	 * We get a new "in" and "out" points and a new radius at the "in"
	 * point in this new coordiante system.
d269 9
a277 7
	VSCALE(in_pt, in_pt, grass_sp->size);
	VSCALE(out_pt, out_pt, grass_sp->size);
 	in_pt_radius *= grass_sp->size;

	/* distance to out point from "in_pt" point (not ray start point). */
	out_dist = (pp->pt_outhit->hit_dist - swp->sw_hit.hit_dist) *
			 grass_sp->size;
a278 9
	if( rdebug&RDEBUG_SHADE) {
		bu_log("\tPnt: %g %g %g\n", V3ARGS(ap->a_ray.r_pt));
		bu_log("\tDir: %g %g %g (diverge:%g)\n", V3ARGS(ap->a_ray.r_dir), ap->a_diverge);
		bu_log("\tHit: %g %g %g  (dist:%g) (radius:%g)\n",
			V3ARGS(swp->sw_hit.hit_point), swp->sw_hit.hit_dist,
			ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge);
		bu_log("\tOut: %g %g %g  (dist:%g) (radius:%g)\n",
			V3ARGS(out_pt), pp->pt_outhit->hit_dist,
			out_pt_radius);
d280 4
a283 2
		bu_log("\t in: %g %g %g (dist:%g) r:%g\n", V3ARGS(in_pt), 
			swp->sw_hit.hit_dist * grass_sp->size, in_pt_radius);
a284 1
		bu_log("\tout: %g %g %g (dist%g)\n", V3ARGS(out_pt), out_dist);
d286 21
a306 2
		bu_struct_print("Parameters:", grass_print_tab, (char *)grass_sp );
	 	if( swp->sw_xmitonly ) bu_log("xmit only\n");
d308 13
d322 1
d324 8
a331 10
	VMOVE(gr.r.r_pt, in_pt);
	VMOVE(gr.r.r_dir, ap->a_ray.r_dir);
	gr.r.r_max = out_dist;
	gr.diverge = ap->a_diverge;
	gr.radius = in_pt_radius;
	gr.tol = &ap->a_rt_i->rti_tol;
	
	status = grass_march(&gr, grass_sp, &h);
	if (status) {
		do_hit(swp, ap, &h, grass_sp);
d333 12
a344 3
		/* Tell stacker to shade with plastic */

		return 1;
a350 1

d359 6
@


1.8
log
@turn grass tips brown.  Interesting.
@
text
@d385 6
d600 1
a600 1
	if (colorscale > 0.85) {
@


1.7
log
@checkpoint.  Got some nice grass clumps to work.
@
text
@d352 3
a354 1
	    ldist[1] > len  /* Isect point off end of grass */)
d356 1
a356 1

d361 1
d364 1
a364 1
		if (rdebug&RDEBUG_SHADE) bu_log("grass short\n");
d367 1
a367 1

d591 2
d594 3
a596 2
	if (colorscale < 0.0 || colorscale > 1.0) {
		bu_log("bad:%g = %g/%g\n", colorscale, h->alt, h->len);
d598 2
a599 1
		bu_log("good:%g = %g/%g\n", colorscale, h->alt, h->len);
a600 4
#if 0

	colorscale = (h->alt/h->len) * 0.75 + 0.25;
	VSCALE(swp->sw_color, swp->sw_basecolor, colorscale);
@


1.6
log
@checkpoint
@
text
@d4 1
a4 1
 *  To add a new shader to the "rt" program:
d6 21
a26 16
 *	1) Copy this file to sh_shadername.c
 *	2) edit sh_shadername.c:
 *		change "G R A S S" to "S H A D E R N A M E"
 *		change "grass"   to "shadername"
 *		Set a new number for the grass_MAGIC define
 *		define shader specific structure and defaults
 *		edit/build parse table for bu_structparse from grass_parse
 *		edit/build shader_mfuncs tables from grass_mfuncs for
 *			each shader name being built.
 *		edit the grass_setup function to do shader-specific setup
 *		edit the grass_render function to do the actual rendering
 *	3) Edit view.c to add extern for grass_mfuncs and call to mlib_add
 *		to function view_init()
 *	4) Edit Cakefile to add shader file to "FILES" and "RT_OBJ" macros.
 *	5) replace this list with a description of the shader, its parameters
 *		and use.
d43 4
d50 18
d80 3
a82 4
	double	grass_ls;	/* lean/tilt scaling */
	double	grass_radius;
	double	grass_norm;	/* variables for shader ... */
	double	grass_thresh;	/* variables for shader ... */
d86 1
d102 2
a103 1
	3.141592653,			/* grass_ls */
a104 2
	0.0,				/* grass_norm */
	1.0,				/* grass_thresh */
d108 1
d130 2
a131 1
	{"%f",  1, "lean",		SHDR_O(grass_ls),	FUNC_NULL },
a132 2
	{"%f",  1, "norm",		SHDR_O(grass_norm),	FUNC_NULL },
	{"%f",  1, "thresh",		SHDR_O(grass_thresh),	FUNC_NULL },
d137 1
d147 1
a147 1
	{"%f",  1, "ls",		SHDR_O(grass_ls),	FUNC_NULL },
d149 1
a149 2
	{"%f",  1, "n",			SHDR_O(grass_norm),	FUNC_NULL },
	{"%f",  1, "t",			SHDR_O(grass_thresh),	FUNC_NULL },
d151 1
a189 2
	mat_t	tmp, mtr;
	vect_t	bb_min, bb_max, v_tmp;
d198 1
a198 1
		rt_log("grass_setup(%s)\n", rp->reg_name);
d208 1
a208 1
		rt_log("%s\n%s\n",
d221 1
a221 26
	db_region_mat(mtr, rtip->rti_dbip, rp->reg_name);	 


#if 0
	mat_idn(tmp);
	if (grass_sp->size != 1.0) {
		/* the user sets "size" to the size of the biggest
		 * noise-space blob in model coordinates
		 */
		tmp[0] = tmp[5] = tmp[10] = 1.0/grass_sp->size;
	} else {
		tmp[0] = 1.0/grass_sp->vscale[0];
		tmp[5] = 1.0/grass_sp->vscale[1];
		tmp[10] = 1.0/grass_sp->vscale[2];
	}

	mat_mul(grass_sp->m_to_r, tmp, mtr);

	/* Add any translation within shader/region space */
	mat_idn(tmp);
	tmp[MDX] = grass_sp->delta[0];
	tmp[MDY] = grass_sp->delta[1];
	tmp[MDZ] = grass_sp->delta[2];
	mat_mul2(tmp, grass_sp->m_to_r);
#else
	mat_copy(grass_sp->m_to_r, mtr);
a223 1
#endif
d227 2
d258 15
d274 1
a274 1
 *	Actual ray/blade intersection
d276 3
d281 4
a284 6
frob(in, dir, p2, ap, swp, grass_sp, radius, t, out_dist)
point_t in; /* in point in the solid */
vect_t dir; /* ray direction */
point_t p2; /* grid point to test for grass */
struct application *ap;
struct shadework *swp;
d286 1
a286 3
double radius;	/* radius of ray at "in" */
double t;	/* distance from "in" along "dir" to curr grid pt */
double out_dist;/* distance to solid exit */
d288 11
a298 17
	point_t PCA1, PCA2;	/* point of closest approach for each line */
	double ldist[2];	/* dist along each line to PCA */
	vect_t v;
	vect_t stalk;
	double val;
	double alt;
	double radius_at_PCA;
	point_t npt;
	double dist;
	double grass_diameter;
	point_t tmp;
	CONST static vect_t d2 = { 0.0, 0.0, 1.0};
	register struct light_specific *lp;
	extern struct light_specific LightHead;
	vect_t	tolight;	

	grass_diameter = grass_sp->grass_radius /* mm */ * grass_sp->size;
d300 2
a301 4
	/* Tilt the vertical stalk by a (repeatable) random amount.  Make sure
	 * that the Z value is the largest.
	 */
	VSCALE(tmp, p2, grass_sp->grass_ls);
d303 1
a303 12
	if( rdebug&RDEBUG_SHADE) {
		bu_log("frob: %g %g %g scaled to %g %g %g\n",
			V3ARGS(p2), V3ARGS(tmp));
		bu_log("became %g %g %g\n", V3ARGS(stalk));
	}

	if (stalk[X] > stalk[Z]) { val = stalk[Z]; stalk[Z] = stalk[X]; stalk[X] = val; }
	if (stalk[Y] > stalk[Z]) { val = stalk[Z]; stalk[Z] = stalk[Y]; stalk[Y] = val; }

	/* The following assures we can make unit vector,
	 * and that the grass doesn't lean over too much
	 */
d307 6
d314 2
a315 2
	/*
	 * intersect ray with vertical stalk
d317 2
a318 21
	if (rt_dist_line3_line3(ldist, in, dir, p2, stalk,
	    &ap->a_rt_i->rti_tol) < 0)
		rt_bomb("line/line isect error\n");

#if 1
	/* Noise function to define height of grass blades */
	VSCALE(tmp, p2, grass_sp->grass_thresh);
	val = bn_noise_fbm(tmp, grass_sp->h_val,
		grass_sp->lacunarity, grass_sp->octaves);

#else
	val = .4;
#endif


#define SOLID_HEIGHT 500.0 /* XXX hack.  Known height of solid in mm */
	alt = val * (SOLID_HEIGHT * grass_sp->size);

	/* compute Pt of closest approach along ray */
	VJOIN1(PCA1, in, ldist[0], dir);
	radius_at_PCA = radius + ldist[0] * ap->a_diverge;
a319 6
	if( rdebug&RDEBUG_SHADE) {
		bu_log("\tgrass_dia: %g (%g)\n", grass_diameter);
		bu_log("\tval:%g  alt:%g\n", val, alt);
		bu_log("\tdist to ray PCA=%g PCA1 %g %g %g radius@@PCA:%g\n",
			ldist[0], V3ARGS(PCA1), radius_at_PCA);
	}
d321 3
d325 1
a325 4
	/* if the grass is too short, we miss and march onward */
	if ( (PCA1[Z] - radius_at_PCA) >= alt) {
		if( rdebug&RDEBUG_SHADE)
			bu_log("\tPCA1(%g) > alt(%g) of grass + r@@PCA\n", PCA1[Z], alt);
d329 3
a331 8
	/* if we hit the grass below the ground, forget it and 
	 * signal caller to quit cell-marching
	 */
	if ( (PCA1[Z] + radius_at_PCA) < 0.0) {
		if( rdebug&RDEBUG_SHADE)
			bu_log("\tPCA1(%g) < ground\n", PCA1[Z]);
		return -1;
	}
d334 2
a335 4
	/* compute dist between Points of closest approach */
	VJOIN1(PCA2, p2, ldist[1], stalk);
	VSUB2(v, PCA1, PCA2);
	dist = MAGNITUDE(v);
d337 10
a346 5
	if( rdebug&RDEBUG_SHADE) {
		bu_log("\tdist to grass PCA=%g PCA2 %g %g %g\n",
			ldist[1], V3ARGS(PCA2));
		bu_log("\tdelta btw PCA pts:%g  beam radius:%g\n",
			dist, radius);
d349 9
d359 3
a361 5
	/* if the ray radius isn't greater than the distance to the blade then
	 *  we've missed, march onward
	 */
	if (dist > (radius_at_PCA + grass_diameter)  &&
	    (radius_at_PCA + grass_diameter) < .75 )
a362 39

	/* Ray overlaps blade of grass 
	 * XXX The ray might overlap several blades of grass.  We should do
	 * more here.  Perhaps based upon the area of overlap vs ray footprint
	 * area?
	 */
	swp->sw_transmit = 0.0;

	/* if this is a shadow ray, then just register opacity and quit.
	 * XXX Once again some indication of partial transmittance might be
	 * nice to add.  Grass tends to be translucent at short distances.
	 */
 	if( swp->sw_xmitonly ) return -1;

	/* set the color
	 * We scale the color based upon the height of the hitpoint to
	 * approximate basic shadowing.  Gross hack XXX
	 */
	val = (PCA1[Z]/alt) * 0.5 + 0.5;

	VSCALE(swp->sw_color, swp->sw_basecolor, val );

#if 1
	/* compute normal for stalk */

	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		/* compute the light direction */
		if( lp->lt_infinite ) {
			/* Infinite lights are point sources, no fuzzy penumbra */
			VMOVE( tolight, lp->lt_vec );
		} else {
			/* convert light position into shader space */
			VSCALE(tmp, lp->lt_pos, grass_sp->size);

			VSUB2(tolight, tmp, 
				swp->sw_hit.hit_point);
		}
		if (lp->lt_fraction > 0.6) break;
d365 6
a370 8
	VCROSS(tmp, stalk, d2);
	VCROSS(v, tmp, stalk);
	VUNITIZE(v);	/* tentative normal for stalk */
	VUNITIZE(tolight);
	if (VDOT(v, tolight)  > 0.0) {
		VMOVE(swp->sw_hit.hit_normal, v);
	} else {
		VREVERSE(swp->sw_hit.hit_normal, v);
a371 16
#else
	/* Compute a normal for the blade of grass based upon
	 * the blade's 2D position
	 */
	PCA2[Z] = 0.0;

	if (grass_sp->grass_norm != 0.0) {
		/* hack for manipulating grass normal */
		VSCALE(PCA2, PCA2, grass_sp->grass_norm);

		do {
			VSCALE(PCA2, PCA2, grass_sp->lacunarity);
			bn_noise_vec(PCA2, v);
		} while (VDOT(v, dir) >= -0.2);

		VUNITIZE(v);
d373 8
a380 19
		VSCALE(PCA2, PCA2, grass_sp->lacunarity);
		bn_noise_vec(PCA2, tmp);

		VUNITIZE(tmp);
		VSCALE(tmp, tmp, 0.1736);
		VADD2(v, v, tmp);

		VUNITIZE(v);
		VMOVE(swp->sw_hit.hit_normal, v);
	} else {
		bn_noise_vec(PCA2, v);
		if (VDOT(v, dir) > 0.0) {
			VREVERSE(swp->sw_hit.hit_normal, v);
		} else {
			VMOVE(swp->sw_hit.hit_normal, v);
		}
	}
	VUNITIZE(swp->sw_hit.hit_normal);
#endif
d386 2
a387 6




/*
 *	G R A S S _ R E N D E R
d389 3
a391 3
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
d393 5
a397 6
int
grass_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
a398 8
	register struct grass_specific *grass_sp =
		(struct grass_specific *)dp;
	point_t in_pt, out_pt;	/* model space in/out points */
	point_t in, out, next_pt;
	double in_pt_radius, out_pt_radius;	/* beam radius, model space */
	double in_radius, out_radius;	/* beam radius, shader space */
	double radius;
	double out_dist;
a401 4
#define PREV_X	3
#define PREV_Y	7
#define PREV_NONE 0
	int 	step_prev = PREV_NONE;
d404 3
a406 37
	double	ldist[2];
	vect_t	dir;
	point_t	p2;
	int i;
	double	dist;
	int hit;
	int iter;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_grass_SP(grass_sp);

	/* set some fast constants */
	VMOVE(dir, ap->a_ray.r_dir);
	p2[Z] = 0.0;


	if( rdebug&RDEBUG_SHADE) bu_log("grass_render\n");

#if !defined(SHADOWS)
	if (swp->sw_xmitonly) {
		/* XXX hack, cast no shadows */
		VSETALL(swp->sw_basecolor, 1.0); 
		swp->sw_transmit = 1.0;

		if( rdebug&RDEBUG_SHADE) bu_log("XXX HACK no grass shadows\n");

		return 0;	/* don't do phong shading on light vis rays */
	}
#endif
	/* figure out the in/out points, and the radius of the beam
	 * We can work in model space since grass isn't likely to be moving
	 * around the scene.
	 */
	VJOIN1(in_pt, ap->a_ray.r_pt, swp->sw_hit.hit_dist, dir);
	in_pt_radius = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
d408 1
a408 37
	VJOIN1(out_pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, dir);
	out_pt_radius = ap->a_rbeam + pp->pt_outhit->hit_dist * ap->a_diverge;

	/* We usually can't afford to evaluate the shader every mm so we allow
	 * the user to scale space by a constant to reduce the density of
	 * the grass and the number of computations needed.
	 *
	 * We get a new "in" and "out points and a new radius at the "in"
	 * point in this new coordiante system.
	 */
	VSCALE(in, in_pt, grass_sp->size);
	VSCALE(out, out_pt, grass_sp->size);
 	in_radius = in_pt_radius * grass_sp->size;

	/* out distance computed from "in" hit point */
	out_dist = (pp->pt_outhit->hit_dist - swp->sw_hit.hit_dist) *
			 grass_sp->size;

	if( rdebug&RDEBUG_SHADE) {
		bu_log("\tPnt: %g %g %g\n", V3ARGS(ap->a_ray.r_pt));
		bu_log("\tDir: %g %g %g (diverge:%g)\n", V3ARGS(ap->a_ray.r_dir), ap->a_diverge);
		bu_log("\tHit: %g %g %g  (dist:%g) (radius:%g)\n",
			V3ARGS(swp->sw_hit.hit_point), swp->sw_hit.hit_dist,
			in_pt_radius);
		bu_log("\tOut: %g %g %g  (dist:%g) (radius:%g)\n",
			V3ARGS(out_pt), pp->pt_outhit->hit_dist,
			out_pt_radius);
		bu_log("\t in: %g %g %g (dist:%g) r:%g\n", V3ARGS(in), 
			swp->sw_hit.hit_dist * grass_sp->size, in_radius);

		bu_log("\tout: %g %g %g (dist%g)\n", V3ARGS(out), out_dist);

		bu_struct_print("Parameters:", grass_print_tab, (char *)grass_sp );
	 	if( swp->sw_xmitonly ) bu_log("xmit only\n");

	}

d417 3
a419 3
	if (dir[X] < 0.0) {
		tDX = -1.0 / dir[X];
		tX = (in[X] - ((int)in[X])) / dir[X];
d422 3
a424 3
		tDX = 1.0 / dir[X];
		if (dir[X] > 0.0)
			tX = (1.0 - (in[X] - ((int)in[X]))) / dir[X];
d429 1
a429 1
	if (tX > out_dist) tX = out_dist;
d439 3
a441 3
	if (dir[Y] < 0.0) {
		tDY = -1.0 / dir[Y];
		tY = (in[Y] - ((int)in[Y])) / dir[Y];
d444 3
a446 3
		tDY = 1.0 / dir[Y];
		if (dir[Y] > 0.0)
			tY = (1.0 - (in[Y] - ((int)in[Y]))) / dir[Y];
d451 1
a451 1
	if (tY > out_dist) tY = out_dist;
d458 8
a465 4
	hit = 0;
	iter = 0;
	swp->sw_transmit = 1.0;
	while (! hit && (tX < out_dist || tY < out_dist)) {
d468 2
a469 2
			VJOIN1(next_pt, in, tX, dir);
			p2[X] = floor(next_pt[X]);
d472 2
a473 2
				/* check (int)y and (int)y+1.0 XXX use floor()*/
				p2[Y] = floor(next_pt[Y]);
d476 2
a477 2
					bu_log("tX(%g) pt %g %g %g (check 2)\n\tp2=%g,%g,%g\n",
						tX, V3ARGS(next_pt), V3ARGS(p2));
d479 2
a480 8
				hit = frob(in, dir, p2, ap, swp, 
					grass_sp, in_radius, tX, out_dist);
				if (hit) { 
					swp->sw_hit.hit_dist += 
						tX * grass_sp->inv_size;
					VMOVE(swp->sw_hit.hit_point, next_pt);
					break;
				}
d482 2
a483 1
				p2[Y] += 1.0;
d485 4
a488 1
					bu_log("\tp2=%g,%g,%g\n", V3ARGS(p2));
a489 8
				hit = frob(in, dir, p2, ap, swp,
					grass_sp, in_radius, tX, out_dist);
				if (hit) { 
					swp->sw_hit.hit_dist += 
						tX * grass_sp->inv_size;
					VMOVE(swp->sw_hit.hit_point, next_pt);
					break;
				}
d492 1
a492 1
				p2[Y] = floor(next_pt[Y]+which_y);
d495 2
a496 2
					bu_log("tX(%g) pt %g %g %g (check 1)\n\tp2=%g,%g,%g\n",
						tX, V3ARGS(next_pt), V3ARGS(p2));
d498 2
a499 8
				hit = frob(in, dir, p2, ap, swp,
					grass_sp, in_radius, tX, out_dist);
				if (hit) { 
					swp->sw_hit.hit_dist += 
						tX * grass_sp->inv_size;
					VMOVE(swp->sw_hit.hit_point, next_pt);
					break;
				}
d504 3
a506 3
			/* one step in Y direction */
			VJOIN1(next_pt, in, tY, dir);
			p2[Y] = floor(next_pt[Y]);
d510 1
a510 1
				p2[X] = floor(next_pt[X]);
d513 1
a513 1
					bu_log("tY(%g) pt %g %g %g (check 2)\n\tp2=%g,%g,%g\n",
d515 1
a515 1
						V3ARGS(p2));
d517 4
a520 13
				hit = frob(in, dir, p2, ap, swp, 
					grass_sp, in_radius, tY, out_dist);
				if (hit) { 
					if( rdebug&RDEBUG_SHADE)
						bu_log("A d:%g tY:%g inv:%g\n",
							swp->sw_hit.hit_dist,
							tY, grass_sp->inv_size);
					swp->sw_hit.hit_dist += 
						tY * grass_sp->inv_size;
					VMOVE(swp->sw_hit.hit_point, next_pt);
					break;
				}
				p2[X] += 1.0;
d522 1
a522 1
					bu_log("\tp2=%g,%g,%g\n", V3ARGS(p2));
d524 2
a525 12
				hit = frob(in, dir, p2, ap, swp, 
					grass_sp, in_radius, tY, out_dist);
				if (hit) { 
					if( rdebug&RDEBUG_SHADE)
						bu_log("B d:%g tY:%g inv:%g\n",
							swp->sw_hit.hit_dist,
							tY, grass_sp->inv_size);
					swp->sw_hit.hit_dist += 
						tY * grass_sp->inv_size;
					VMOVE(swp->sw_hit.hit_point, next_pt);
					break;
				}
d528 1
a528 1
				p2[X] = floor(next_pt[X]+which_x);
d531 2
a532 2
					bu_log("tY(%g) pt %g %g %g (check 1)\n\tp2=%g,%g,%g\n",
						tY, V3ARGS(next_pt), V3ARGS(p2));
d534 2
a535 16
				hit = frob(in, dir, p2, ap, swp, 
					grass_sp, in_radius, tY, out_dist);
				if (hit) { 
					if( rdebug&RDEBUG_SHADE)
						bu_log("d:%g tY:%g inv:%g\n",
							swp->sw_hit.hit_dist,
							tY, grass_sp->inv_size);
					swp->sw_hit.hit_dist += 
						tY * grass_sp->inv_size;
					if( rdebug&RDEBUG_SHADE)
						bu_log("new d:%g\n",
							swp->sw_hit.hit_dist);

					VMOVE(swp->sw_hit.hit_point, next_pt);
					break;
				}
d541 142
d684 2
d687 1
a687 14
	if (hit > 0) {
		if( rdebug&RDEBUG_SHADE)
			bu_log("Hit grass blade\n");

		/* RE-SCALE shader hit point and distance back into model
		 * coordinate system.
		 */
		VJOIN1(swp->sw_hit.hit_point, ap->a_ray.r_pt, 
			swp->sw_hit.hit_dist, ap->a_ray.r_dir);

		if( rdebug&RDEBUG_SHADE)
			bu_log("new hit point: %g %g %g (dist:%g)\n",
				V3ARGS(swp->sw_hit.hit_point),
				swp->sw_hit.hit_dist);
d689 3
a691 1
		return 1;
d694 13
a706 5
#if defined(SHADOWS)
	/* XXX here is where we should do the procedural shadows */
	/* seems to have something to do with shadow rays through grass */
	if (hit < 0) {
		/* hit grass, xmitonly case */
a708 1
#endif
a709 1
	/* If we missed everything, then it's time to trace on through */
d715 1
d721 1
d723 1
@


1.5
log
@checkpoint
@
text
@d31 1
d35 1
d53 3
d62 1
d75 4
a78 1
	0.75,				/* grass_thresh */
d102 4
d120 3
d222 2
d257 4
d262 4
a265 3
frob(in, dir, p2, d2, ap, swp, grass_sp, radius, t, out_dist)
point_t in, p2;
vect_t dir, d2;
d269 3
a271 3
double radius;
double t;
double out_dist;
d273 2
a274 1
	point_t PCA1, PCA2;
d276 1
d278 2
a279 1
	double ldist[2];
d281 29
a310 1
	double dist;
d312 5
a316 1
	if (rt_dist_line3_line3(ldist, in, dir, p2, d2, &ap->a_rt_i->rti_tol) < 0)
d319 4
a322 1
	val = bn_noise_fbm(p2, grass_sp->h_val,
d325 4
a328 2
	val *=  500.0 /* XXX hack.  Known height of solid */
		* grass_sp->size;
d330 2
d333 1
d335 2
d338 12
a349 3
		bu_log("\tp2=%g,%g,%g d2=%g,%g,%g\n", V3ARGS(p2), V3ARGS(d2));
		bu_log("\tval %g %g\n", val, val * 500.0 * grass_sp->size);
		bu_log("\tldist[0]=%g PCA1 %g %g %g\n", ldist[0], V3ARGS(PCA1));
a350 2
	if (PCA1[Z] >= val) return 0;
	if (PCA1[Z] < 0.0) return -1;
d352 8
d362 2
a363 1
	VJOIN1(PCA2, p2, ldist[1], d2);
d366 1
d368 4
a371 2
		bu_log("\tldist[1]=%g PCA2 %g %g %g\n", ldist[1], V3ARGS(PCA2));
		bu_log("\tdelta PCA %g  beam radius %g\n", dist, radius);
d373 1
a373 1
	if (dist > radius) return 0;
d375 12
a386 1
	VMOVE(swp->sw_color, swp->sw_basecolor);
d389 46
d436 14
a449 2
#if 0
	VSCALE(PCA2, PCA2, 0.01);
d451 3
a453 4
	do {
		VSCALE(PCA2, PCA2, 2.36398);
		bn_noise_vec(PCA2, v);
	} while (VDOT(v, dir) >= -0.1736);
d455 2
a456 4
#else
	bn_noise_vec(PCA2, v);
	if (VDOT(v, dir) > 0.0) {
		VREVERSE(swp->sw_hit.hit_normal, v);
d458 6
a463 1
		VMOVE(swp->sw_hit.hit_normal, v);
d465 1
a466 1
	VUNITIZE(swp->sw_hit.hit_normal);
d494 2
a495 1
	double in_radius, out_radius;	/* beam radius, model space */
a508 1
	static CONST vect_t d2 = {0.0, 0.0, 1.0};
d520 1
a520 10
	if( rdebug&RDEBUG_SHADE) {
		bu_struct_print( "grass_render Parameters:", grass_print_tab, (char *)grass_sp );
	}

	/* XXX for now, all light rays pass through */
 	if( swp->sw_xmitonly )  {
 		bu_log("xmitonly\n");
 		swp->sw_transmit = 1.0;
 		return 0;
 	}
d524 14
d542 2
a543 2
	VJOIN1(in_pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, dir);
	in_radius = ap->a_rbeam + pp->pt_inhit->hit_dist * ap->a_diverge;
d546 1
a546 1
	out_radius = ap->a_rbeam + pp->pt_outhit->hit_dist * ap->a_diverge;
d548 7
a554 1
	/* scale mm to centimeters */
d557 5
a561 4
 	in_radius *= grass_sp->size;
	/* out distance computed from in hit point */
	out_dist = (pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist) * grass_sp->size;
	
d564 16
a579 6
		bu_log(" in_pt: %g %g %g  radius: %g\n", V3ARGS(in_pt), in_radius);
		bu_log("out_pt: %g %g %g  radius: %g\n", V3ARGS(out_pt), out_radius);
		bu_log(" in: %g %g %g\n", V3ARGS(in));
		bu_log("out: %g %g %g\n", V3ARGS(out));
		bu_log("out_dist: %g\n", out_dist);
		VPRINT("dir", dir);
a626 1

d638 1
a638 1
			radius = in_radius + tX *ap->a_diverge;
a639 4
			if( rdebug&RDEBUG_SHADE)
				bu_log("tX(%g) pt %g %g %g r=%g\n",
					tX, V3ARGS(next_pt), radius);
			
d641 2
a642 3
				/* check (int)y and (int)y+1.0 */
				p2[X] = (fastf_t)((int)(next_pt[X]));
				p2[Y] = (fastf_t)((int)(next_pt[Y]));
d644 12
a655 1
				hit = frob(in, dir, p2, d2, ap, swp, grass_sp, radius, tX, out_dist);
d657 3
d661 8
a668 2
				p2[Y] += 1.0;
				hit = frob(in, dir, p2, d2, ap, swp, grass_sp, radius, tX, out_dist);
d671 1
d673 12
a684 4
				p2[X] = (fastf_t)((int)(next_pt[X]));
				p2[Y] = (fastf_t)((int)(next_pt[Y]+which_y));

				hit = frob(in, dir, p2, d2, ap, swp, grass_sp, radius, tX, out_dist);
d691 1
a691 5
			radius = in_radius + tY *ap->a_diverge;

			if( rdebug&RDEBUG_SHADE)
				bu_log("tY(%g) pt %g %g %g r=%g\n",
					tY, V3ARGS(next_pt), radius);
d695 1
a695 3
				p2[X] = (fastf_t)((int)(next_pt[X]));
				p2[Y] = (fastf_t)((int)(next_pt[Y]));
				hit = frob(in, dir, p2, d2, ap, swp, grass_sp, radius, tY, out_dist);
d697 17
d715 15
a729 1
				hit = frob(in, dir, p2, d2, ap, swp, grass_sp, radius, tY, out_dist);
d732 1
d734 20
a753 3
				p2[X] = (fastf_t)((int)(next_pt[X]+which_x));
				p2[Y] = (fastf_t)((int)(next_pt[Y]));
				hit = frob(in, dir, p2, d2, ap, swp, grass_sp, radius, tY, out_dist);
d762 14
a775 2
		VMOVE(pp->pt_inhit->hit_normal, swp->sw_hit.hit_normal);
		swp->sw_transmit = 0.0;
d779 8
d788 1
d790 2
a792 1
	/* If we missed everything, then it's time to trace on through */
@


1.4
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@a238 20
int
xmit_hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
return 1;
}

/*
 *			R R _ M I S S
 */
HIDDEN int
/*ARGSUSED*/
xmit_miss( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	RT_AP_CHECK(ap);
	return(1);	/* treat as escaping ray */
}
d254 1
d264 2
a265 1
	val *=  500.0 * grass_sp->size;
d274 2
a275 1
	if (PCA1[Z] >= val || PCA1[Z] < 0.0) return 0;
d292 9
a300 1
#if 1
d307 1
a308 1
#endif
d411 1
a411 1
		tDX = 1.0 / dir[X];
d433 1
a433 1
		tDY = 1.0 / dir[Y];
d515 1
a515 1
	if (hit) {
@


1.3
log
@checkpoint
@
text
@d34 2
d124 1
a124 1
	{"grass",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d183 1
d204 3
d239 88
d344 1
d346 19
a364 10
	int step_cnt;
	double step_dist, seg_dist;
	vect_t dist_v;
	point_t pt;
	double val, dist, delta;
	double	step_delta;/* distance between sample points, texture space */
	fastf_t	model_step; /* distance between sample points, model space */
	int	steps;	   /* # of samples along ray/solid intersection */
	int	i, octaves;
	double	alt, r, radius;
d375 9
d388 1
a388 1
	VJOIN1(in_pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
d391 1
a391 1
	VJOIN1(out_pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
d394 8
d405 4
d411 7
a417 2
	/* XXX the radius of the beam should give us an idea 
	 * of how many octaves of noise we need to evaluate.
d419 13
d434 20
a453 3

	seg_dist = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
	step_cnt = seg_dist / 10; /* scale dist to cm units,  1_sample/cm */
d455 1
a455 4
	/* get actual length of step */
	step_dist = seg_dist / (double)step_cnt; 

	swp->sw_transmit = 1.0;
d458 2
a459 2
		bu_log("seg_dist: %g\n", seg_dist);
		bu_log("step_cnt %d  step_dist %g\n", step_cnt, step_dist);
d461 59
a519 9

	for (i=0 ; i < step_cnt ; i++ ) {
		dist = pp->pt_inhit->hit_dist + i * step_dist;
		VJOIN1(pt, ap->a_ray.r_pt, dist, ap->a_ray.r_dir);
		radius = ap->a_rbeam + dist * ap->a_diverge;

		if ( rdebug&RDEBUG_SHADE) {
			bu_log("pt %g %g %g radius %g\n", 
				V3ARGS(pt), radius);
d521 1
a522 3
		octaves = 1;
		for (r = radius ; r < grass_sp->size ; r *= grass_sp->lacunarity)
			octaves ++;
d524 5
a528 3
		if ( rdebug&RDEBUG_SHADE) {
			bu_log("octaves %d\n", octaves);
		}
a529 5
		alt = pt[Z];
		pt[Z] = 0.0;
		VSCALE(pt, pt, 1.0/grass_sp->size);
		val = bn_noise_fbm(pt, grass_sp->h_val,
			grass_sp->lacunarity, octaves);
a530 3
		if ( rdebug&RDEBUG_SHADE) {
			bu_log("value %g\n", val);
		}
a531 9
		if (val > grass_sp->grass_thresh) {
			swp->sw_transmit = 0.0;
			break;
		}
		if (alt < 100.0 && val < -grass_sp->grass_thresh) {
			swp->sw_transmit = 0.0;
			break;
		}
	}
d533 1
a533 2
	/* grass is basically a green object with transparency */
	if( swp->sw_xmitonly )  return 1;
d535 4
a538 30
	if (swp->sw_transmit == 0.0) {
		/* hit a blade of grass */
		/* compute new random normal */
		vect_t N;

		pt[Z] = (alt/grass_sp->size) * 0.125;
		bn_noise_vec(pt, N);
		if ( rdebug&RDEBUG_SHADE) {
			bu_log("Old Normal %g %g %g\n",
				V3ARGS(swp->sw_hit.hit_normal));
		}
		if (VDOT(N, ap->a_ray.r_dir) > 0.0) {
			VREVERSE(swp->sw_hit.hit_normal, N);
		} else {
			VMOVE(swp->sw_hit.hit_normal, N);
		}
		VUNITIZE(swp->sw_hit.hit_normal);
		if ( rdebug&RDEBUG_SHADE) {
			bu_log("New Normal %g %g %g\n",
				V3ARGS(swp->sw_hit.hit_normal));
		}
	} else {
		/* missed everything XXX shoot a ray on through */
		swp->sw_transmit = 1.0;
#if 1
		VSETALL(swp->sw_color, 0.0);
		VSETALL(swp->sw_basecolor, 0.0);
#endif		
		swp->sw_refrac_index = 1.0;
		swp->sw_reflect = 0.0;
d540 1
a540 14
	}
	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
#if 0
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
	else {
		/* call plastic here */
	}
#endif
	return(1);
@


1.2
log
@checkpoint
@
text
@d67 1
a67 1
	0.45,				/* grass_thresh */
d249 6
a254 1
	point_t in_pt, out_pt, dist_v, pt;
d259 2
a260 2
	int	i;
	double	alt;
a268 1
		
d270 4
a273 3
	/* We are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in grass_setup().
d275 2
a276 2
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(in_pt, grass_sp->m_to_r, pt);
d278 2
a279 2
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(out_pt, grass_sp->m_to_r, pt);
d282 2
a283 2
		VPRINT("in_pt", in_pt);
		VPRINT("out_pt", out_pt);
d286 2
a287 2
	/* get the ray/region intersection vector (in region space)
	 * and compute thickness of solid along ray path
d289 1
a289 1
	VSUB2(dist_v, out_pt, in_pt);
a290 13
	/* The noise field used by the noise_turb and noise_fbm routines
	 * has a maximum frequency of about 1 cycle per integer step in
	 * noise space.  Each octave increases this frequency by the
	 * "lacunarity" factor.  To sample this space adequately we need 
	 *
	 *	4 samples per integer step for the first octave,
	 *	lacunarity * 4 samples/step for the second octave,
	 * 	lacunarity^2 * 4 samples/step for the third octave,
	 * 	lacunarity^3 * 4 samples/step for the forth octave,
	 *
	 * so for a computation with 4 octaves we need something on the
	 * order of lacunarity^3 * 4 samples per integer step in noise space.
	 */
d292 2
a293 4
	steps = pow(grass_sp->lacunarity, grass_sp->octaves-1) * 4;
	step_delta = MAGNITUDE(dist_v) / (double)steps;
	model_step = (pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist) /
		(double)steps;
d295 2
a296 2
	VUNITIZE(dist_v);
	VMOVE(pt, in_pt);
d299 23
a321 4
	
	for (i=0 ; i < steps ; i++ ) {
		/* compute the next point in the cloud space */
		VJOIN1(pt, in_pt, i*step_delta, dist_v);
a323 1

d325 3
a327 2
		val = bn_noise_fbm(pt, grass_sp->h_val, 
			grass_sp->lacunarity, grass_sp->octaves );
d329 3
d337 1
a337 1
		if (alt < 1008.0 && val < -grass_sp->grass_thresh) {
a342 1

d348 19
d368 1
a368 1
		/* missed everything */
d370 1
d372 2
a373 1
		VSETALL(swp->sw_basecolor, 1.0);
d376 1
@


1.1
log
@Initial revision
@
text
@d43 7
a49 1
	double	grass_val;	/* variables for shader ... */
d53 2
a54 1
	mat_t	grass_m_to_r;	/* model to region space matrix */
d61 7
a67 1
	1.0,				/* grass_val */
d87 5
a91 1
	{"%f",  1, "val",		SHDR_O(grass_val),	FUNC_NULL },
d95 2
d102 4
a105 1
	{"%f",  1, "v",			SHDR_O(grass_val),	FUNC_NULL },
d145 1
a145 1
	mat_t	tmp;
d164 7
d178 16
a193 1
	db_region_mat(grass_sp->grass_m_to_r, rtip->rti_dbip, rp->reg_name);	 
d195 9
d206 1
a206 1
		mat_print( "m_to_r", grass_sp->grass_m_to_r );
d249 7
a255 1
	point_t pt;
d262 1
a262 1
	if( rdebug&RDEBUG_SHADE)
d264 2
a265 1

d270 2
a271 1
	MAT4X3PNT(pt, grass_sp->grass_m_to_r, swp->sw_hit.hit_point);
d273 3
d277 52
a328 3
		rt_log("grass_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
d331 3
a333 2
	/* GRASS perform shading operations here */
	VMOVE(swp->sw_color, pt);
d335 10
d350 1
d353 4
a356 1

@
