head	11.35;
access;
symbols
	ansi-20040405-merged:11.31.2.1
	phong-branch:11.34.0.2
	photonmap-branch:11.32.0.2
	rel-6-1-DP:11.31
	rel-6-0-2:11.28
	ansi-branch:11.31.0.2
	rel-6-0-1-branch:11.28.0.2
	hartley-6-0-post:11.29
	hartley-6-0-pre:11.28
	rel-6-0-1:11.28
	rel-6-0:11.28
	rel-5-4:11.16
	offsite-5-3-pre:11.27
	rel-5-3:11.16
	rel-5-2:11.16
	rel-5-1-branch:11.16.0.2
	rel-5-1:11.16
	rel-5-0:11.15
	rel-5-0-beta:11.14
	rel-4-5:11.12
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	windows-6-0-branch:11.31.0.4;
locks; strict;
comment	@ * @;


11.35
date	2003.09.27.00.56.11;	author morrison;	state dead;
branches;
next	11.34;

11.34
date	2003.08.04.01.49.33;	author butler;	state Exp;
branches;
next	11.33;

11.33
date	2003.08.02.23.11.55;	author butler;	state Exp;
branches;
next	11.32;

11.32
date	2003.01.10.22.35.35;	author butler;	state Exp;
branches
	11.32.2.1;
next	11.31;

11.31
date	2002.09.05.04.03.54;	author butler;	state Exp;
branches
	11.31.2.1
	11.31.4.1;
next	11.30;

11.30
date	2002.08.20.17.08.37;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.28;

11.28
date	2001.04.05.19.36.04;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2000.09.09.04.57.06;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.08.24.17.52.14;	author butler;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.17.02.47.51;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.08.17.02.41.34;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.08.14.22.35.23;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.08.14.14.27.34;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.21.21.36.55;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	2000.07.21.14.56.58;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.20.19.49.54;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.06.28.15.23.52;	author butler;	state Exp;
branches;
next	11.16;

11.16
date	99.11.24.22.17.07;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.06.03.01.46.10;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	98.09.22.01.46.58;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	98.09.22.01.43.10;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.12.31.06.30.18;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	97.08.01.18.00.08;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	97.01.08.01.57.09;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.01.08.01.43.22;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.12.04.02.55.51;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.11.22.08.31.47;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.10.19.06.17.00;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.08.22.02.22.39;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.06.02.23.34.05;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.11.02.23.48;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.41;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.12.19.20.11.31;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.00.30.31;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.46;	author mike;	state Rel4_0;
branches;
next	9.10;

9.10
date	91.07.19.03.20.41;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.02.20.01.15.47;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.08.08.30.31;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.08.07.57.02;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.11.21.06.34.23;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.01.11.38.27;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.01.11.17.47;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.10.15.11.02.17;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.27.01.26.17;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.58.56;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.28.06.21.40;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	88.12.27.16.35.00;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.15.03.33.48;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.32.48;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.09.19.22.44.55;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.08.20.07.16.38;	author phil;	state Exp;
branches;
next	7.5;

7.5
date	88.06.21.00.58.16;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.02.28.13;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.01.26.05.56.15;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.22.21.13.51;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.54.02;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.11.02.21.36.52;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.58.31;	author mike;	state Rel;
branches;
next	5.4;

5.4
date	87.07.03.05.39.54;	author mike;	state Exp;
branches;
next	5.3;

5.3
date	87.06.27.06.46.38;	author phil;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.57.09;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.14.29;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.03.24.00.49.31;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.03.23.23.48.28;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.17.20.18.30;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.01.22;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.48.12;	author mike;	state Rel1;
branches;
next	1.9;

1.9
date	86.12.18.16.00.57;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	89.10.31.08.23.35;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.10.29.04.51.30;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.12.05.50.39;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.07.28.22.52.42;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.07.19.04.38.33;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.07.17.18.32.57;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.06.13.00.34.56;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.06.11.00.13.32;	author mike;	state Exp;
branches;
next	;

11.31.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	;

11.31.4.1
date	2004.03.11.23.48.06;	author morrison;	state dead;
branches;
next	;

11.32.2.1
date	2003.08.26.13.58.50;	author justin;	state Exp;
branches;
next	;


desc
@Routines to implement the object-oriented interface to
the material-property routines
@


11.35
log
@moved a majority of the rt "back-end" to liboptical in order to decouple a symbol reference as well as to provide the functionality in a library
@
text
@/*
 *			M A T E R I A L . C
 *
 *  Routines to coordinate the implementation of material properties
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.34 2003/08/04 01:49:33 butler Exp $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "rtprivate.h"

#ifdef HAVE_DLOPEN
# undef BSD
# include <sys/param.h>
# include <dlfcn.h>
#endif


static const char *mdefault = "default"; /* Name of default material */

/*
 *			M L I B _ A D D _ S H A D E R
 *
 *  Routine to add an array of mfuncs structures to the linked
 *  list of material (shader) routines.
 */
void
mlib_add_shader( headp, mfp1 )
struct mfuncs **headp;
struct mfuncs *mfp1;
{
	register struct mfuncs *mfp;

	RT_CK_MF(mfp1);
	for( mfp = mfp1; mfp->mf_name != (char *)0; mfp++ )  {
		RT_CK_MF(mfp);
		mfp->mf_forw = *headp;
		*headp = mfp;
	}
}

#ifdef HAVE_DLOPEN
/*
 *  T R Y _ L O A D
 *
 *  Try to load a DSO from the specified path.  If we succeed in opening
 *  the DSO, then retrieve the symbol "shader_mfuncs" and look up the shader
 *  named "material" in the table.
 */
static struct mfuncs *
try_load(const char *path, const char *material, const char *shader_name)
{
	void *handle;
	struct mfuncs *shader_mfuncs;
	struct mfuncs *mfp;
	char *dl_error_str;
	char sym[MAXPATHLEN];


	if ( ! (handle = dlopen(path, RTLD_NOW)) ) {
		if (rdebug&RDEBUG_MATERIAL) 
			bu_log("dlopen failed on \"%s\"\n", path);
		return (struct mfuncs *)NULL;
	} else if (rdebug&RDEBUG_MATERIAL) {
		bu_log("%s open... ", path);
	}

	/* Find the {shader}_mfuncs symbol in the library */
	sprintf(sym, "%s_mfuncs", shader_name);
	shader_mfuncs = dlsym(handle, sym);
	if ( (dl_error_str=dlerror()) == (char *)NULL) goto found;


	/* We didn't find a {shader}_mfuncs symbol, so
	 * try the generic "shader_mfuncs" symbol.
	 */
	shader_mfuncs = dlsym(handle, "shader_mfuncs");
	if ( (dl_error_str=dlerror()) != (char *)NULL) {
		/* didn't find anything appropriate, give up */
		if (rdebug&RDEBUG_MATERIAL) bu_log("%s has no %s table, %s\n", material, sym, dl_error_str);
		dlclose(handle);
		return (struct mfuncs *)NULL;
	}

found:
	if (rdebug&RDEBUG_MATERIAL)
		bu_log("%s_mfuncs table found\n", shader_name);

	/* make sure the shader we were looking for is in the mfuncs table */
	for (mfp = shader_mfuncs ; mfp->mf_name != (char *)NULL; mfp++) {
		RT_CK_MF(mfp);

		if ( ! strcmp(mfp->mf_name, shader_name))
			return shader_mfuncs; /* found ! */
	}

	if (rdebug&RDEBUG_MATERIAL) bu_log("shader '%s' not found in library\n", shader_name);

	/* found the library, but not the shader */
	dlclose(handle);
	return (struct mfuncs *)NULL;
}


/*
 *  L O A D _ D Y N A M I C _ S H A D E R
 *
 *  Given a shader/material name, try to find a DSO to supply the shader.
 *
 */
struct mfuncs *
load_dynamic_shader(const char *material,
		    const int mlen)
{
	struct mfuncs *shader_mfuncs = (struct mfuncs *)NULL;
	char libname[MAXPATHLEN];
	char *cwd = (char *)NULL;
	int old_rdebug = rdebug;
	char sh_name[128]; /* XXX constants are bogus */

	if (mlen < sizeof(sh_name)) {
	    strncpy(sh_name, material, mlen);
	    sh_name[mlen] = '\0';
	} else {
	    bu_log("shader name too long \"%s\" %d > %d\n",
		   material, mlen, sizeof(sh_name));
	    return (struct mfuncs *)NULL;
	}
	/* rdebug |= RDEBUG_MATERIAL; */

	if (rdebug&RDEBUG_MATERIAL)
		bu_log("load_dynamic_shader( \"%s\", %d )\n", sh_name, mlen);

	cwd = getcwd((char *)NULL, (size_t)MAXPATHLEN);

	if ( cwd ) {
		/* Look in the current working directory for {sh_name}.so */
		sprintf(libname, "%s/%s.so", cwd, sh_name);
		if ( (shader_mfuncs = try_load(libname, material, sh_name)) )
			goto done;


		/* Look in the current working directory for shaders.so */
		sprintf(libname, "%s/shaders.so", cwd);
		if ( (shader_mfuncs = try_load(libname, material, sh_name)) )
			goto done;

	} else {
		bu_log("Cannot get current working directory\n\tSkipping local shader load\n");
	}

	/* Look in the location indicated by $LD_LIBRARY_PATH for
	 * lib{sh_name}.so
	 */
	sprintf(libname, "lib%s.so", sh_name);
	if ( (shader_mfuncs = try_load(libname, material, sh_name)) )
		goto done;

	/* Look in $BRLCAD_ROOT/lib/ for lib{sh_name}.so */
	strcpy(libname, bu_brlcad_path(""));
	sprintf( &libname[strlen(libname)], "/lib/lib%s.so", sh_name);
	if ( (shader_mfuncs = try_load(libname, material, sh_name)) ) 
		goto done;



done:

	/* clean up memory allocated */
	if (cwd) free(cwd);

	/* print appropriate log messages */
	if (shader_mfuncs)
		bu_log("loaded from %s\n", libname);
	else
		bu_log("Not found\n");



	rdebug = old_rdebug;

	return shader_mfuncs;
}
#endif

/*
 *			M L I B _ S E T U P
 *
 *  Returns -
 *	-1	failed
 *	 0	indicates that this region should be dropped
 *	 1	success
 */
int
mlib_setup( struct mfuncs **headp,
	register struct region *rp,
	struct rt_i *rtip )
{
	register const struct mfuncs *mfp;
#ifdef HAVE_DLOPEN
	register struct mfuncs *mfp_new;
#endif
	int		ret;
	struct bu_vls	param;
	const char	*material;
	int		mlen;

	RT_CK_REGION(rp);
	RT_CK_RTI(rtip);

	if( rp->reg_mfuncs != (char *)0 )  {
		bu_log("mlib_setup:  region %s already setup\n", rp->reg_name );
		return(-1);
	}
	bu_vls_init( &param );
	material = rp->reg_mater.ma_shader;
	if( material == NULL || material[0] == '\0' )  {
		material = mdefault;
		mlen = strlen(mdefault);
	} else {
		char	*endp;
		endp = strchr( material, ' ' );
		if( endp )  {
			mlen = endp - material;
			bu_vls_strcpy( &param, rp->reg_mater.ma_shader+mlen+1 );
		} else {
			mlen = strlen(material);
		}
	}
retry:
	for( mfp = *headp; mfp != MF_NULL; mfp = mfp->mf_forw )  {
	    if (material[0] != mfp->mf_name[0] ||
		strncmp(material, mfp->mf_name, strlen(mfp->mf_name)))
		continue;
	    goto found;
	}

#ifdef HAVE_DLOPEN
	/* If we get here, then the shader wasn't found in the list of 
	 * compiled-in (or previously loaded) shaders.  See if we can
	 * dynamically load it.
	 */

	bu_log("Shader \"%s\"... ", material);

	if ((mfp_new = load_dynamic_shader(material, mlen))) {
		mlib_add_shader(headp, mfp_new);
		bu_log("retrying\n");
		goto retry;
	}
#else
	bu_log("****** dynamic shader loading not available ******\n");
#endif


	/* If we get here, then the shader was not found at all (either in
	 * the compiled-in or dynamically loaded shader sets).  We set the
	 * shader name to "default" (which should match an entry in the 
	 * table) and search again.
	 */

	bu_log("*ERROR mlib_setup('%s'):  material not known, default assumed %s\n\n",
		material, rp->reg_name );
	if( material != mdefault )  {
		material = mdefault;
		mlen = strlen(mdefault);
		bu_vls_trunc( &param, 0 );
		goto retry;
	}
	bu_vls_free( &param );
	return(-1);
found:
	rp->reg_mfuncs = (char *)mfp;
	rp->reg_udata = (char *)0;

	if(rdebug&RDEBUG_MATERIAL)
		bu_log("mlib_setup(%s) shader=%s\n", rp->reg_name, mfp->mf_name);
	if( (ret = mfp->mf_setup( rp, &param, &rp->reg_udata, mfp, rtip, headp )) < 0 )  {
		bu_log("ERROR mlib_setup(%s) failed. Material='%s', param='%s'.\n",
			rp->reg_name, material, bu_vls_addr(&param) );
		if( material != mdefault )  {
			/* If not default material, change to default & retry */
			bu_log("\tChanging %s material to default and retrying.\n", rp->reg_name);
			material = mdefault;
			bu_vls_trunc( &param, 0 );
			goto retry;
		}
		/* What to do if default setup fails? */
		bu_log("mlib_setup(%s) error recovery failed.\n", rp->reg_name);
	}
	bu_vls_free( &param );
	return(ret);		/* Good or bad, as mf_setup says */
}

/*
 *			M L I B _ F R E E
 *
 *  Routine to free material-property specific data
 */
void
mlib_free( register struct region *rp )
{
	register const struct mfuncs *mfp = (struct mfuncs *)rp->reg_mfuncs;

	if( mfp == MF_NULL )  {
		bu_log("mlib_free(%s):  reg_mfuncs NULL\n", rp->reg_name);
		return;
	}
	if( mfp->mf_magic != MF_MAGIC )  {
		bu_log("mlib_free(%s):  reg_mfuncs bad magic, %x != %x\n",
			rp->reg_name,
			mfp->mf_magic, MF_MAGIC );
		return;
	}
	if( mfp->mf_free ) mfp->mf_free( rp->reg_udata );
	rp->reg_mfuncs = (char *)0;
	rp->reg_udata = (char *)0;
}

/*
 *			M L I B _ Z E R O
 *
 *  Regardless of arguments, always return zero.
 *  Useful mostly as a stub print, and/or free routine.
 */
/* VARARGS */
int
mlib_zero()
{
	return(0);
}

/*
 *			M L I B _ O N E
 *
 *  Regardless of arguments, always return one.
 *  Useful mostly as a stub setup routine.
 */
/* VARARGS */
int
mlib_one()
{
	return(1);
}

/*
 *			M L I B _ V O I D
 */
/* VARARGS */
void
mlib_void()
{
}
@


11.34
log
@fixed strcmp/strncmp bug
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.33 2003/08/02 23:11:55 butler Exp $ (BRL)";
@


11.33
log
@Fixed bug with shader name comparison.  Strings now must match exactly.
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.32 2003/01/10 22:35:35 butler Exp $ (BRL)";
d262 1
a262 1
		strcmp(material, mfp->mf_name))
d277 1
@


11.32
log
@Fixed off-by-one error
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.31 2002/09/05 04:03:54 butler Exp $ (BRL)";
d116 1
a116 1
		bu_log("%s mfuncs table found\n", shader_name);
a211 1

d261 4
a264 4
		if( material[0] != mfp->mf_name[0]  ||
		    strncmp( material, mfp->mf_name, mlen ) != 0 )
			continue;
		goto found;
@


11.32.2.1
log
@updated for merging
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.34 2003/08/04 01:49:33 butler Exp $ (BRL)";
d116 1
a116 1
		bu_log("%s_mfuncs table found\n", shader_name);
d212 1
d262 4
a265 4
	    if (material[0] != mfp->mf_name[0] ||
		strncmp(material, mfp->mf_name, strlen(mfp->mf_name)))
		continue;
	    goto found;
a277 1
		bu_log("retrying\n");
@


11.31
log
@Changes so that loadable shaders can have parameters
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.30 2002/08/20 17:08:37 jra Exp $ (BRL)";
d152 1
a152 1
	    sh_name[mlen+1] = '\0';
@


11.31.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/Attic/material.c,v 11.31 2002/09/05 04:03:54 butler Exp $ (BRL)";
@


11.31.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.31 2002/09/05 04:03:54 butler Exp $ (BRL)";
d57 3
a59 1
mlib_add_shader(struct mfuncs **headp, struct mfuncs *mfp1)
d357 1
a357 1
mlib_zero(void)
d370 1
a370 1
mlib_one(void)
d380 1
a380 1
mlib_void(void)
@


11.30
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.28 2001/04/05 19:36:04 morrison Exp $ (BRL)";
d80 1
a80 1
try_load(const char *path, const char *material)
d98 1
a98 1
	sprintf(sym, "%s_mfuncs", material);
d116 1
a116 1
		bu_log("%s mfuncs table found\n", material);
d122 1
a122 1
		if ( ! strcmp(mfp->mf_name, material))
d126 1
a126 1
	if (rdebug&RDEBUG_MATERIAL) bu_log("shader '%s' not found in library\n", material);
d148 1
d150 8
d161 1
a161 1
		bu_log("load_dynamic_shader( \"%s\", %d )\n", material, mlen);
d166 3
a168 3
		/* Look in the current working directory for {material}.so */
		sprintf(libname, "%s/%s.so", cwd, material);
		if ( (shader_mfuncs = try_load(libname, material)) )
d174 1
a174 1
		if ( (shader_mfuncs = try_load(libname, material)) )
d182 1
a182 1
	 * lib{material}.so
d184 2
a185 2
	sprintf(libname, "lib%s.so", material);
	if ( (shader_mfuncs = try_load(libname, material)) )
d188 1
a188 1
	/* Look in $BRLCAD_ROOT/lib/ for lib{material}.so */
d190 2
a191 2
	sprintf( &libname[strlen(libname)], "/lib/lib%s.so", material);
	if ( (shader_mfuncs = try_load(libname, material)) ) 
@


11.29
log
@Converted from K&R to ANSI C - RFH
@
text
@d57 3
a59 1
mlib_add_shader(struct mfuncs **headp, struct mfuncs *mfp1)
d348 1
a348 1
mlib_zero(void)
d361 1
a361 1
mlib_one(void)
d371 1
a371 1
mlib_void(void)
@


11.28
log
@updated SIGNED to signed
updated CONST to const
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.27 2000/09/09 04:57:06 mike Exp $ (BRL)";
d57 1
a57 3
mlib_add_shader( headp, mfp1 )
struct mfuncs **headp;
struct mfuncs *mfp1;
d346 1
a346 1
mlib_zero()
d359 1
a359 1
mlib_one()
d369 1
a369 1
mlib_void()
@


11.27
log
@
Fixed lint problem with include file sequencing for DSOs.
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.26 2000/08/24 17:52:14 butler Exp $ (BRL)";
d48 1
a48 1
static CONST char *mdefault = "default"; /* Name of default material */
d220 1
a220 1
	register CONST struct mfuncs *mfp;
d226 1
a226 1
	CONST char	*material;
d323 1
a323 1
	register CONST struct mfuncs *mfp = (struct mfuncs *)rp->reg_mfuncs;
@


11.26
log
@getcwd needs a non-zero size argument on Irix, even if it will allocate the
string itself
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.25 2000/08/17 02:47:51 mike Exp $ (BRL)";
a24 2
#include <unistd.h>
#include <sys/param.h>
a31 3
#ifdef HAVE_DLOPEN
#include <dlfcn.h>
#endif
d41 7
d221 1
d223 1
@


11.25
log
@
Removed lint warning, enhanced error messages
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.24 2000/08/17 02:41:34 mike Exp $ (BRL)";
d152 1
a152 1
	cwd = getcwd((char *)NULL, (size_t)0);
@


11.24
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d19 1
a19 1
static const char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.23 2000/08/14 22:35:23 mike Exp $ (BRL)";
d107 1
a107 1
		if (rdebug&RDEBUG_MATERIAL) bu_log("no mfuncs table\n");
d114 1
a114 1
		bu_log("mfuncs table found\n");
d124 1
a124 1
	if (rdebug&RDEBUG_MATERIAL) bu_log("shader not found in library\n");
@


11.23
log
@
ansi prototypes.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.22 2000/08/14 14:27:34 jra Exp $ (BRL)";
@


11.22
log
@load_dynamic_shader() cannot be static, it is called from elswhere
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.21 2000/07/25 16:39:48 butler Exp $ (BRL)";
d214 3
a216 4
mlib_setup( headp, rp, rtip )
struct mfuncs		**headp;
register struct region	*rp;
struct rt_i		*rtip;
d317 1
a317 2
mlib_free( rp )
register struct region *rp;
@


11.21
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.20 2000/07/21 21:36:55 butler Exp $ (BRL)";
d138 1
a138 1
static struct mfuncs *
@


11.20
log
@Polished up dynamic shader loading under Linux
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.19 2000/07/21 14:56:58 butler Exp $ (BRL)";
d44 1
a44 1
#include "./rdebug.h"
d144 1
a144 1
	char cwd[MAXPATHLEN];
d152 3
a154 1
	if (getcwd(cwd, MAXPATHLEN)) {
d187 4
d195 2
@


11.19
log
@Fixed call to getcwd
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.18 2000/07/20 19:49:54 mike Exp $ (BRL)";
d25 1
a85 3
/* if (rdebug&RDEBUG_SHADE) */
	bu_log("try_load(\"%s\", \"%s\")\n", path, material);

d88 2
a89 1
		bu_log("dlopen failed\n");
d91 2
d95 1
a95 1
	/* check for the appropriate symbol in the library */
d97 1
a97 2
	bu_log("dlsym %s\n", sym);
	shader_mfuncs = dlsym(handle, "shader_mfuncs");
d101 3
a103 4


	/* Try a generic name for the mfuncs table */
	bu_log("dlsym %s\n", "shader_mfuncs");
d107 1
a107 2
		if(rdebug&RDEBUG_MATERIAL)
			bu_log("dlsym(%s) error=%s\n", path, dl_error_str);
d113 3
a118 2
		bu_log("checking %s for match to %s\n",
			mfp->mf_name, material);
d120 1
a120 1
		if ( ! strcmp(mfp->mf_name, material)) {
a121 1
		}
d124 2
d142 1
a142 2
	void *handle;
	struct mfuncs *shader_mfuncs;
a143 1
	char sym[MAXPATHLEN];
d145 1
d147 1
a147 2
/* if (rdebug&RDEBUG_SHADE) */
	bu_log("load_dynamic_shader( \"%s\", %d )\n", material, mlen);
d149 2
d152 5
d159 4
a162 1
	getcwd(cwd, MAXPATHLEN);
d164 2
a165 9
	/* Look in the current working directory for {material}.so */
	sprintf(libname, "%s/%s.so", cwd, material);
	if ( shader_mfuncs = try_load(libname, material) )
		 return shader_mfuncs;

	/* Look in the current working directory for shaders.so */
	sprintf(libname, "%s/shaders.so", cwd);
	if ( shader_mfuncs = try_load(libname, material) ) {
		return shader_mfuncs;
d172 2
a173 2
	if ( shader_mfuncs = try_load(libname, material) )
		return shader_mfuncs;
d178 4
a181 2
	if ( shader_mfuncs = try_load(libname, material) ) 
		return shader_mfuncs;
d183 10
a192 1
	return (struct mfuncs *)NULL;
d254 3
a256 2
	bu_log("\ntrying dynamic shader loading\n");
	if (mfp_new = load_dynamic_shader(material, mlen)) {
d261 1
a261 1
	bu_log("\ndynamic shader loading not available\n");
d271 1
a271 1
	bu_log("\n*ERROR mlib_setup('%s'):  material not known, default assumed %s\n",
@


11.18
log
@
Changed getcwd() call to have proper number of args.
Added debugging.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.17 2000/06/28 15:23:52 butler Exp $ (BRL)";
d70 1
d72 3
a74 3
 *
 *
 *
d83 1
d85 6
a90 1
	if ( ! (handle = dlopen(path, RTLD_NOW)) )
d92 1
d95 10
d107 1
d114 1
d118 4
a121 1
		if ( ! strcmp(mfp->mf_name, material)) 
d123 1
d133 1
d135 1
a135 2
 *
 *
a144 1
	char *cwd;
d146 7
d154 1
a154 2
	/* Obtain current directory, as dynamically allocated string */
	cwd = getcwd(NULL, -1);
d156 4
a159 6
	/* Look in the current working directory for lib{material}.so.1 */
	sprintf(libname, "%s/lib%s.so.1", cwd, material);
	if ( shader_mfuncs = try_load(libname, material) )  {
		free(cwd);
		return shader_mfuncs;
	}
d161 3
a163 4
	/* Look in the current working directory for libshaders.so.1 */
	sprintf(libname, "%s/libshaders.so.1", cwd);
	if ( shader_mfuncs = try_load(libname, material) )  {
		free(cwd);
a165 2
	free(cwd);
	cwd = NULL;	/* sanity */
d167 4
a170 2
	/* Look in the location indicated by $LD_LIBRARY_PATH */
	sprintf(libname, "lib%s.so.1", material);
d174 1
a174 1
	/* Look in $BRLCAD_ROOT/lib/ */
d176 1
a176 1
	sprintf( &libname[strlen(libname)], "/lib/lib%s.so.1", material);
d242 1
d247 2
a248 1

@


11.17
log
@Added dynamic shader loading
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.16 1999/11/24 22:17:07 mike Exp $ (BRL)";
d89 2
d121 1
a121 1
	char cwd[MAXPATHLEN];
d123 3
a125 1
	getcwd(cwd);
d129 4
a132 2
	if ( shader_mfuncs = try_load(libname, material) )
		 return shader_mfuncs;
d135 3
a137 2
	sprintf(libname, "%s/libshaders.so.1", cwd, material);
	if ( shader_mfuncs = try_load(libname, material) )
d139 3
@


11.16
log
@
Removed obsolete header files
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.15 1999/06/03 01:46:10 mike Exp $ (BRL)";
d25 1
d33 3
d68 81
d164 1
d199 21
@


11.15
log
@
sed4
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.14 1998/09/22 01:46:58 mike Exp $ (BRL)";
a36 1
#include "rtstring.h"
@


11.14
log
@Moved pr_shadework() from material.c to shade.c, where it belongs.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.13 1998/09/22 01:43:10 mike Exp $ (BRL)";
d81 1
a81 1
	struct rt_vls	param;
d89 1
a89 1
		rt_log("mlib_setup:  region %s already setup\n", rp->reg_name );
d92 1
a92 1
	rt_vls_init( &param );
d102 1
a102 1
			rt_vls_strcpy( &param, rp->reg_mater.ma_shader+mlen+1 );
d114 1
a114 1
	rt_log("\n*ERROR mlib_setup('%s'):  material not known, default assumed %s\n",
d119 1
a119 1
		rt_vls_trunc( &param, 0 );
d122 1
a122 1
	rt_vls_free( &param );
d131 2
a132 2
		rt_log("ERROR mlib_setup(%s) failed. Material='%s', param='%s'.\n",
			rp->reg_name, material, RT_VLS_ADDR(&param) );
d135 1
a135 1
			rt_log("\tChanging %s material to default and retrying.\n", rp->reg_name);
d137 1
a137 1
			rt_vls_trunc( &param, 0 );
d141 1
a141 1
		rt_log("mlib_setup(%s) error recovery failed.\n", rp->reg_name);
d143 1
a143 1
	rt_vls_free( &param );
d159 1
a159 1
		rt_log("mlib_free(%s):  reg_mfuncs NULL\n", rp->reg_name);
d163 1
a163 1
		rt_log("mlib_free(%s):  reg_mfuncs bad magic, %x != %x\n",
@


11.13
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /c/CVS/brlcad/rt/material.c,v 11.12 1997/12/31 09:01:40 mike Exp $ (BRL)";
a39 1
#include "shadework.h"
a205 48
}

/* XXX move to shade.c */

/*
 *			P R _ S H A D E W O R K
 *
 *  Pretty print a shadework structure.
 */
void
pr_shadework( str, swp )
CONST char *str;
register CONST struct shadework *swp;
{
	int	i;

	rt_log( "Shadework %s: 0x%x\n", str, swp );
	if (swp->sw_inputs && MFI_HIT)
		rt_log( " sw_hit.dist:%g  sw_hit.point(%g %g %g)\n",
			swp->sw_hit.hit_dist, 
			V3ARGS(swp->sw_hit.hit_point));
	else
		rt_log( " sw_hit.dist:%g\n", swp->sw_hit.hit_dist);

	if (swp->sw_inputs && MFI_NORMAL) 
		rt_log(" sw_hit.normal(%g %g %g)\n",
			V3ARGS(swp->sw_hit.hit_normal));


	rt_log( " sw_transmit %f\n", swp->sw_transmit );
	rt_log( " sw_reflect %f\n", swp->sw_reflect );
	rt_log( " sw_refract_index %f\n", swp->sw_refrac_index );
	rt_log( " sw_extinction %f\n", swp->sw_extinction );
	VPRINT( " sw_color", swp->sw_color );
	VPRINT( " sw_basecolor", swp->sw_basecolor );
	rt_log( " sw_uv  %f %f\n", swp->sw_uv.uv_u, swp->sw_uv.uv_v );
	rt_log( " sw_dudv  %f %f\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv );
	rt_log( " sw_xmitonly %d\n", swp->sw_xmitonly );
	rt_printb( " sw_inputs", swp->sw_inputs,
		"\020\4HIT\3LIGHT\2UV\1NORMAL" );
	rt_log( "\n");
	for( i=0; i < SW_NLIGHTS; i++ )  {
		if( swp->sw_visible[i] == (char *)0 )  continue;
		rt_log("   light %d visible, intensity=%g, dir=(%g,%g,%g)\n",
			i,
			swp->sw_intensity[i],
			V3ARGS(&swp->sw_tolight[i*3]) );
	}
@


11.12
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.11 1997/12/31 06:30:18 butler Exp mike $ (BRL)";
d35 1
d39 2
a40 1
#include "./material.h"
d43 1
a43 1
struct mfuncs *mfHead = MF_NULL;	/* Head of list of materials */
a44 2
static char *mdefault = "default";	/* Name of default material */

d46 1
a46 1
 *			M L I B _ A D D
d48 2
a49 2
 *  Internal routine to add an array of mfuncs structures to the linked
 *  list of material routines.
d52 2
a53 1
mlib_add( mfp1 )
d61 2
a62 2
		mfp->mf_forw = mfHead;
		mfHead = mfp;
d75 2
a76 1
mlib_setup( rp, rtip )
d80 2
a81 2
	register struct mfuncs *mfp;
	int	ret;
d83 2
a84 2
	char	*material;
	int	mlen;
d109 1
a109 1
	for( mfp=mfHead; mfp != MF_NULL; mfp = mfp->mf_forw )  {
d131 1
a131 1
	if( (ret = mfp->mf_setup( rp, &param, &rp->reg_udata, mfp, rtip )) < 0 )  {
d157 1
a157 1
	register struct mfuncs *mfp = (struct mfuncs *)rp->reg_mfuncs;
d209 2
d218 2
a219 2
char *str;
register struct shadework *swp;
@


11.11
log
@added printing to pr_shadework()
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.10 1997/08/01 18:00:08 jra Exp butler $ (BRL)";
d52 2
a53 2
mlib_add( mfp )
register struct mfuncs *mfp;
d55 5
a59 2
	for( ; mfp->mf_name != (char *)0; mfp++ )  {
		mfp->mf_magic = MF_MAGIC;
@


11.10
log
@Added du and dv output to pr_shadework().
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.9 1997/01/08 01:57:09 mike Exp jra $ (BRL)";
d217 12
@


11.9
log
@mlen wasn't set if no params given.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.8 1997/01/08 01:43:22 mike Exp mike $ (BRL)";
d224 1
@


11.8
log
@Added debuggign
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.7 1996/12/04 02:55:51 mike Exp mike $ (BRL)";
d99 2
@


11.7
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.6 1996/11/22 08:31:47 mike Exp mike $ (BRL)";
d122 2
@


11.6
log
@Fixed null pointer bug
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/material.c,v 11.5 1996/10/19 06:17:00 mike Exp mike $ (BRL)";
d27 6
d34 1
d79 1
d89 1
a89 1
	material = rp->reg_mater.ma_matname;
d92 1
d94 6
a99 1
		rt_vls_strcpy( &param, rp->reg_mater.ma_matparm );
d104 1
a104 1
		    strcmp( material, mfp->mf_name ) != 0 )
d108 2
a109 2
	rt_log("\n*ERROR mlib_setup('%s'):  material not known, default assumed\n",
		material );
d112 1
@


11.5
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.4 1995/08/22 02:22:39 butler Exp mike $ (BRL)";
d82 1
a82 2
	rt_vls_strcpy( &param, rp->reg_mater.ma_matparm );
	if( material[0] == '\0' )  {
d84 2
a85 1
		rt_vls_trunc( &param, 0 );
@


11.4
log
@changed printf to rt_log
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.3 1995/06/02 23:34:05 mike Exp butler $ (BRL)";
d82 1
a82 1
	rt_vls_strncpy( &param, rp->reg_mater.ma_matparm, sizeof(rp->reg_mater.ma_matparm) );
@


11.3
log
@mlib_setup() and the XXX->mf_setup() routines now take rtip as final arg.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.2 1995/03/11 02:23:48 mike Exp mike $ (BRL)";
d211 1
a211 1
		printf("   light %d visible, intensity=%g, dir=(%g,%g,%g)\n",
@


11.2
log
@Added mfp parameter to mf_setup() call.
This allows the shader setup routine to know what name it was invoked by.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 11.1 95/01/04 10:00:41 mike Rel4_4 Locker: mike $ (BRL)";
d64 3
a66 2
mlib_setup( rp )
register struct region *rp;
d73 3
d107 1
a107 1
	if( (ret = mfp->mf_setup( rp, &param, &rp->reg_udata, mfp )) < 0 )  {
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 10.3 94/12/19 20:11:31 mike Exp $ (BRL)";
d103 1
a103 1
	if( (ret = mfp->mf_setup( rp, &param, &rp->reg_udata )) < 0 )  {
@


10.3
log
@Improved error messages
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 10.2 94/08/11 00:30:31 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 10.1 1991/10/12 06:41:46 mike Rel4_0 gdurf $ (BRL)";
d104 1
a104 1
		rt_log("mlib_setup(%s) failure, material='%s', param='%s'\n",
d108 1
d114 1
a114 1
		rt_log("mlib_setup(%s) error recovery fails\n", rp->reg_name);
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.10 91/07/19 03:20:41 mike Exp $ (BRL)";
d21 2
@


9.10
log
@improved error message
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.9 91/02/20 01:15:47 mike Exp $ (BRL)";
@


9.9
log
@Added error messages when mlib_setup() fails
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.8 90/12/08 08:30:31 mike Exp $ (BRL)";
d88 1
a88 1
	rt_log("\n*ERROR mlib_setup(%s):  material not known, default assumed\n",
@


9.8
log
@fixed bugs
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.7 90/12/08 07:57:02 mike Exp $ (BRL)";
d76 1
a99 1
	rt_vls_strncpy( &param, rp->reg_mater.ma_matparm, sizeof(rp->reg_mater.ma_matparm) );
d102 2
a103 1
		/* What to do if setup fails? */
d105 1
d110 2
@


9.7
log
@Changed to using vls strings for material _setup routines
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.6 90/11/21 06:34:23 mike Exp $ (BRL)";
d78 1
a78 1
		rt_vls_trunc( &param );
d91 1
a91 1
		rt_vls_trunc( &param );
d105 1
a105 1
			rt_vls_trunc( &param );
@


9.6
log
@Added material name to mlib_free() error messages
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.5 90/11/01 11:38:27 mike Exp $ (BRL)";
d27 1
d67 1
a67 1
	char	param[256];
d74 1
d78 1
a78 1
		param[0] = '\0';
d91 1
a91 1
		param[0] = '\0';
d94 1
d99 1
a99 2
	strncpy( param, rp->reg_mater.ma_matparm, sizeof(rp->reg_mater.ma_matparm) );
	param[sizeof(rp->reg_mater.ma_matparm)+1] = '\0';
d101 1
a101 1
	if( (ret = mfp->mf_setup( rp, param, &rp->reg_udata )) < 0 )  {
d105 1
a105 1
			param[0] = '\0';
d109 1
@


9.5
log
@Avoid dereferencing NULL
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.4 90/11/01 11:17:47 mike Exp $ (BRL)";
d122 1
a122 1
		rt_log("mlib_free:  reg_mfuncs NULL\n");
d126 2
a127 1
		rt_log("mlib_free:  reg_mfuncs bad magic, %x != %x\n",
@


9.4
log
@Added more details when printing shadework structure (like light info).
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.3 90/10/15 11:02:17 mike Exp $ (BRL)";
d130 1
a130 1
	mfp->mf_free( rp->reg_udata );
@


9.3
log
@Made error message more noticable.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: /m/cad/rt/RCS/material.c,v 9.2 90/04/27 01:26:17 mike Exp $ (BRL)";
d180 2
d191 10
a200 1
	rt_log( " sw_inputs 0x%x\n", swp->sw_inputs );
@


9.2
log
@If switching to default material, drop parameter string.
It is almost certainly incompatible with the default material.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 9.1 89/05/19 05:58:56 mike Locked $ (BRL)";
d85 1
a85 1
	rt_log("mlib_setup(%s):  material not known, default assumed\n",
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 8.4 89/04/28 06:21:40 phil Exp $ (BRL)";
d74 1
a74 1
	if( material[0] == '\0' )
d76 2
d89 1
d103 1
@


8.4
log
@added pr_shadework() function - not complete but it's a start
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 8.3 88/12/27 16:35:00 phil Locked $ (BRL)";
@


8.3
log
@Converted matparse --> structparse
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 8.2 88/12/15 03:33:48 mike Locked $ (BRL)";
d164 22
@


8.2
log
@added the hack of mlib_parse2 to take two parsing tables.
we should really generalize this to make parse tables chainable,
with descriptive strings, and optional side-effect functions.
put in a vect_t type "%V"
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 8.1 88/10/05 00:32:48 phil Locked $ (BRL)";
a128 304
}

/*
 *			M L I B _ R G B
 *
 *  Parse a slash (or other non-numeric, non-whitespace) separated string
 *  as 3 decimal (or octal) bytes.  Useful for entering rgb values in
 *  mlib_parse as 4/5/6.  Element [3] is made non-zero to indicate
 *  that a value has been loaded.
 */
void
mlib_rgb( rgb, str )
register unsigned char *rgb;
register char *str;
{
	if( !isdigit(*str) )  return;
	rgb[0] = atoi(str);
	rgb[1] = rgb[2] = 0;
	rgb[3] = 1;
	while( *str )
		if( !isdigit(*str++) )  break;
	if( !*str )  return;
	rgb[1] = atoi(str);
	while( *str )
		if( !isdigit(*str++) )  break;
	if( !*str )  return;
	rgb[2] = atoi(str);
}

/*
 *			M L I B _ V E C T
 *
 *  Parse a slash (or other non-numeric, non-whitespace) separated string
 *  as a vect_t (3 fastf_t's).  Useful for entering vector values in
 *  mlib_parse as 1.0/0.5/0.1.
 */
void
mlib_vect( vp, str )
register fastf_t *vp;
register char *str;
{
	if( !isdigit(*str) && *str != '.' )  return;
	vp[0] = atof(str);
	vp[1] = vp[2] = 0.0;
	while( *str ) {
		if( !isdigit(*str) && *str != '.' ) {
			str++;
			break;
		}
		str++;
	}
	if( !*str )  return;
	vp[1] = atof(str);
	while( *str ) {
		if( !isdigit(*str) && *str != '.' ) {
			str++;
			break;
		}
		str++;
	}
	if( !*str )  return;
	vp[2] = atof(str);
}

/*
 *			M L I B _ P A R S E
 */
void
mlib_parse( cp, parsetab, base )
register char *cp;
struct matparse *parsetab;
int *base;		/* base address of users structure */
{
	register struct matparse *mp;
	char *name;
	char *value;

	while( *cp )  {
		/* NAME = VALUE separator (comma, space, tab) */

		/* skip any leading whitespace */
		while( *cp != '\0' && 
		    (*cp == ',' || *cp == ' ' || *cp == '\t' ) )
			cp++;

		/* Find equal sign */
		name = cp;
		while( *cp != '\0' && *cp != '=' )  cp++;
		if( *cp == '\0' )  {
			rt_log("name %s without value\n", name );
			break;
		}
		*cp++ = '\0';

		/* Find end of value */
		value = cp;
		while( *cp != '\0' && *cp != ',' &&
		    *cp != ' ' && *cp != '\t' )
			cp++;
		if( *cp != '\0' )
			*cp++ = '\0';

		/* Lookup name in parsetab table */
		for( mp = parsetab; mp->mp_name != (char *)0; mp++ )  {
			register char *loc;

			if( strcmp( mp->mp_name, name ) != 0 )
				continue;
			loc = (char *)(((mp_off_ty)base) +
					((int)mp->mp_offset));
			switch( mp->mp_fmt[1] )  {
			case 'C':
				mlib_rgb( loc, value );
				break;
			case 'V':
				mlib_vect( loc, value );
				break;
			case 'f':
				/*  Silicon Graphics sucks wind.
				 *  On the 3-D machines, float==double,
				 *  which breaks the scanf() strings.
				 *  So, here we cause "%f" to store into
				 *  a double.  This is the "generic"
				 *  floating point read.  Humbug.
				 */
				*((double *)loc) = atof( value );
				break;
			default:
				(void)sscanf( value, mp->mp_fmt, loc );
				break;
			}
			goto out;
		}
		rt_log("mlib_parse:  %s=%s not a valid arg\n", name, value);
out:		;
	}
}

/*
 *			M L I B _ P A R S E 2
 *
 *  XXX A Hack to take two parse tables until (unless?) things are
 *  fixed up so that we can chain tables together.
 */
void
mlib_parse2( cp, parsetab, parsetab2, base )
register char *cp;
struct matparse *parsetab;
struct matparse *parsetab2;
int *base;		/* base address of users structure */
{
	register struct matparse *mp;
	char *name;
	char *value;

	while( *cp )  {
		/* NAME = VALUE separator (comma, space, tab) */

		/* skip any leading whitespace */
		while( *cp != '\0' && 
		    (*cp == ',' || *cp == ' ' || *cp == '\t' ) )
			cp++;

		/* Find equal sign */
		name = cp;
		while( *cp != '\0' && *cp != '=' )  cp++;
		if( *cp == '\0' )  {
			rt_log("name %s without value\n", name );
			break;
		}
		*cp++ = '\0';

		/* Find end of value */
		value = cp;
		while( *cp != '\0' && *cp != ',' &&
		    *cp != ' ' && *cp != '\t' )
			cp++;
		if( *cp != '\0' )
			*cp++ = '\0';

		/* Lookup name in parsetab table */
		for( mp = parsetab; mp->mp_name != (char *)0; mp++ )  {
			register char *loc;

			if( strcmp( mp->mp_name, name ) != 0 )
				continue;
			loc = (char *)(((mp_off_ty)base) +
					((int)mp->mp_offset));
			switch( mp->mp_fmt[1] )  {
			case 'C':
				mlib_rgb( loc, value );
				break;
			case 'V':
				mlib_vect( loc, value );
				break;
			case 'f':
				/*  Silicon Graphics sucks wind.
				 *  On the 3-D machines, float==double,
				 *  which breaks the scanf() strings.
				 *  So, here we cause "%f" to store into
				 *  a double.  This is the "generic"
				 *  floating point read.  Humbug.
				 */
				*((double *)loc) = atof( value );
				break;
			default:
				(void)sscanf( value, mp->mp_fmt, loc );
				break;
			}
			goto out;
		}
		for( mp = parsetab2; mp->mp_name != (char *)0; mp++ )  {
			register char *loc;

			if( strcmp( mp->mp_name, name ) != 0 )
				continue;
			loc = (char *)(((mp_off_ty)base) +
					((int)mp->mp_offset));
			switch( mp->mp_fmt[1] )  {
			case 'C':
				mlib_rgb( loc, value );
				break;
			case 'V':
				mlib_vect( loc, value );
				break;
			case 'f':
				/*  Silicon Graphics sucks wind.
				 *  On the 3-D machines, float==double,
				 *  which breaks the scanf() strings.
				 *  So, here we cause "%f" to store into
				 *  a double.  This is the "generic"
				 *  floating point read.  Humbug.
				 */
				*((double *)loc) = atof( value );
				break;
			default:
				(void)sscanf( value, mp->mp_fmt, loc );
				break;
			}
			goto out;
		}
		rt_log("mlib_parse:  %s=%s not a valid arg\n", name, value);
out:		;
	}
}

/*
 *			M L I B _ P R I N T
 */
void
mlib_print( title, parsetab, base )
char *title;
struct matparse *parsetab;
int *base;		/* base address of users structure */
{
	register struct matparse *mp;
	register char *loc;
	register mp_off_ty lastoff = (mp_off_ty)(-1);

	rt_log( "%s\n", title );
	for( mp = parsetab; mp->mp_name != (char *)0; mp++ )  {

		/* Skip alternate keywords for same value */
		if( lastoff == mp->mp_offset )
			continue;
		lastoff = mp->mp_offset;

		loc = (char *)(((mp_off_ty)base) +
				((int)mp->mp_offset));

		switch( mp->mp_fmt[1] )  {
		case 's':
			rt_log( " %s=%s\n", mp->mp_name, (char *)loc );
			break;
		case 'd':
			rt_log( " %s=%d\n", mp->mp_name,
				*((int *)loc) );
			break;
		case 'f':
			rt_log( " %s=%g\n", mp->mp_name,
				*((double *)loc) );
			break;
		case 'C':
			{
				register unsigned char *cp =
					(unsigned char *)loc;
				rt_log(" %s=%d/%d/%d(%d)\n", mp->mp_name,
					cp[0], cp[1], cp[2], cp[3] );
				break;
			}
		case 'V':
			{
				register fastf_t *fp =
					(fastf_t *)loc;
				rt_log(" %s=%f/%f/%f\n", mp->mp_name,
					fp[0], fp[1], fp[2] );
				break;
			}
		default:
			rt_log( " %s=%s??\n", mp->mp_name,
				mp->mp_fmt );
			break;
		}
	}
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 7.7 88/09/19 22:44:55 mike Exp $ (BRL)";
d159 35
d243 3
d268 108
d417 8
@


7.7
log
@atof() is adequately "extern'ed" in <math.h>, and
re-defining in locally sometimes produced clashes,
so local definitions were removed.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 7.6 88/08/20 07:16:38 mike Locked $ (BRL)";
@


7.6
log
@cleaned up the default material type handling and moved knowledge
of particular shaders out of here (since set uses the material
parser and printer and all view modules will end up with set).
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 7.5 88/06/21 00:58:16 phil Locked $ (BRL)";
d24 1
a29 2

extern double	atof();
@


7.5
log
@Added marble and stxt
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 7.4 88/05/14 02:28:13 mike Locked $ (BRL)";
d30 2
d34 2
d42 1
a42 1
HIDDEN void
a53 30
 *			M L I B _ I N I T
 *
 *  Enrole the various materials.  Single point of explicit interface with
 *  the materials modules.
 */
void
mlib_init()
{
	extern struct mfuncs phg_mfuncs[];
	extern struct mfuncs light_mfuncs[];
	extern struct mfuncs cloud_mfuncs[];
	extern struct mfuncs spm_mfuncs[];
	extern struct mfuncs txt_mfuncs[];
	extern struct mfuncs stk_mfuncs[];
	extern struct mfuncs cook_mfuncs[];
	extern struct mfuncs marble_mfuncs[];
	extern struct mfuncs stxt_mfuncs[];

	mlib_add( phg_mfuncs );
	mlib_add( light_mfuncs );
	mlib_add( cloud_mfuncs );
	mlib_add( spm_mfuncs );
	mlib_add( txt_mfuncs );
	mlib_add( stk_mfuncs );
	mlib_add( cook_mfuncs );
	mlib_add( marble_mfuncs );
	mlib_add( stxt_mfuncs );
}

/*
d68 1
d74 4
a77 2
	if( rp->reg_mater.ma_matname[0] == '\0' )
		goto def;
d79 2
a80 2
		if( rp->reg_mater.ma_matname[0] != mfp->mf_name[0]  ||
		    strcmp( rp->reg_mater.ma_matname, mfp->mf_name ) != 0 )
d85 6
a90 3
		rp->reg_mater.ma_matname );
def:
	mfp = phg_mfuncs;		/* default */
d99 4
a102 2
		if( mfp != phg_mfuncs )
			goto def;
d205 2
a206 1
			if( mp->mp_fmt[1] == 'C' )
d208 12
a219 1
			else
d221 2
@


7.4
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 7.3 88/01/26 05:56:15 mike Locked $ (BRL)";
d65 2
d75 2
@


7.3
log
@Added mlib_one(), incorporated new mlib_setup() return code convention,
so that a material setup routine can indicate that this region is to
be destroyed.  Used with lights that become implicit.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 7.2 88/01/22 21:13:51 mike Locked $ (BRL)";
d55 1
d126 1
d176 1
d233 1
d289 1
d302 1
d306 9
@


7.2
log
@hook for cook shader
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 7.1 87/11/02 23:54:02 phil Locked $ (BRL)";
d78 3
a80 2
 *	<0	failed
 *	!0	success
d87 1
d111 2
a112 1
	if( mfp->mf_setup( rp, param, &rp->reg_udata ) < 0 )  {
a115 1
		return(-1);		/* BAD */
d117 1
a117 1
	return(0);			/* OK */
d282 1
a282 1
 *  Useful mostly as a stub setup, print, and/or free routine.
d288 12
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 6.2 87/11/02 21:36:52 mike Exp $ (BRL)";
d63 1
d71 1
@


6.2
log
@Ensured that material param strings are null terminated.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 6.1 87/07/11 07:58:31 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 5.4 87/07/03 05:39:54 mike Exp $ (BRL)";
d84 1
d105 3
a107 1
	if( mfp->mf_setup( rp, rp->reg_mater.ma_matparm, &rp->reg_udata ) < 0 )  {
@


5.4
log
@Changed from %f to %g, to prevent Cray loops.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 5.3 87/06/27 06:46:38 mike Locked $ (BRL)";
@


5.3
log
@rendering parameter changes
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 5.2 87/06/26 05:57:09 phil Locked $ (BRL)";
d252 1
a252 1
			rt_log( " %s=%f\n", mp->mp_name,
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 5.1 87/06/24 22:14:29 mike Rel $ (BRL)";
d62 1
d69 1
d104 1
a104 1
	if( mfp->mf_setup( rp ) < 0 )  {
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 4.5 87/03/24 00:49:31 phil Exp $ (BRL)";
d83 1
a83 1
	if( rp->reg_mfuncs != MF_NULL )  {
d100 1
a100 1
	rp->reg_mfuncs = mfp;
d119 1
a119 1
	register struct mfuncs *mfp = rp->reg_mfuncs;
d131 1
a131 1
	rp->reg_mfuncs = MF_NULL;
@


4.5
log
@changed sphere maps from sph_ to spm_ due to librt/sph.c
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 4.4 87/03/23 23:48:28 phil Locked $ (BRL)";
@


4.4
log
@Revised for new material property interface.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 4.3 87/03/17 20:18:30 mike Exp $ (BRL)";
d60 1
a60 1
	extern struct mfuncs sph_mfuncs[];
d66 1
a66 1
	mlib_add( sph_mfuncs );
@


4.3
log
@Added multiple lights, added beginnings of command-driven
input capability.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 4.1 86/12/29 03:48:12 mike Rel1 $ (BRL)";
d30 1
a30 10
extern int phong_setup();
extern int txt_setup();
extern int tmap_setup();
extern int cloud_setup();
extern int mirror_setup();
extern int glass_setup();
extern int ckr_setup();
extern int star_setup();
extern int sph_setup();
extern int light_setup();
d32 16
a47 16
struct matlib {
	char	*ml_name;
	int	(*ml_setup)();
} matlib[] = {
	"plastic",	phong_setup,
	"texture",	txt_setup,
	"testmap",	tmap_setup,
	"cloud",	cloud_setup,
	"mirror",	mirror_setup,
	"glass",	glass_setup,
	"checker",	ckr_setup,
	"fakestar",	star_setup,
	"sph",		sph_setup,
	"light",	light_setup,
	(char *)0,	0			/* END */
};
d50 21
d74 1
a74 1
 *	0	failed
d81 1
a81 1
	register struct matlib *mlp;
d83 1
a83 1
	if( rp->reg_ufunc )  {
d85 1
a85 1
		return(0);
d89 3
a91 3
	for( mlp=matlib; mlp->ml_name != (char *)0; mlp++ )  {
		if( rp->reg_mater.ma_matname[0] != mlp->ml_name[0]  ||
		    strcmp( rp->reg_mater.ma_matname, mlp->ml_name ) != 0 )
d93 1
a93 1
		return( mlp->ml_setup( rp ) );
d98 11
a108 1
	return( phong_setup( rp ) );
d112 24
d267 12
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d39 1
d54 1
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 1.9 86/12/18 16:00:57 mike Locked $ (BRL)";
@


1.9
log
@rdebug.h separated from librt/debug.h
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 1.8 89/10/31 08:23:35 mike Locked $ (BRL)";
@


1.8
log
@Added sphere texture hook
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 1.7 86/10/29 04:51:30 mike Locked $ (BRL)";
d28 1
d120 1
a120 1
char *base;		/* base address of users structure */
d153 2
d157 2
d160 1
a160 1
				mlib_rgb( base + mp->mp_offset, value );
d162 1
a162 2
				(void)sscanf( value,
					mp->mp_fmt, base + mp->mp_offset );
d176 1
a176 1
char *base;		/* base address of users structure */
d179 2
d184 9
d195 1
a195 2
			rt_log( " %s=%s\n", mp->mp_name,
				base + mp->mp_offset );
d199 1
a199 1
				*((int *)(base + mp->mp_offset)) );
d203 1
a203 1
				*((double *)(base + mp->mp_offset)) );
d208 1
a208 1
					(unsigned char *)(base+mp->mp_offset);
@


1.7
log
@Added fakestar function
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 1.6 86/08/12 05:50:39 mike Exp $ (BRL)";
d37 1
d51 1
@


1.6
log
@Changed to find #include files with CC -I../h
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 1.5 86/07/28 22:52:42 mike Exp $ (BRL)";
d36 1
d49 1
@


1.5
log
@Added support for transparent textures.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 1.4 86/07/19 04:38:33 mike Exp $ (BRL)";
d24 4
a27 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "material.h"
@


1.4
log
@Added more stuff
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 1.3 86/07/17 18:32:57 mike Exp $ (BRL)";
d23 1
d83 27
d148 5
a152 1
			if( strcmp( mp->mp_name, name ) == 0 )  {
d154 2
a155 4
					mp->mp_fmt, 
					base + mp->mp_offset );
				goto out;
			}
d187 8
@


1.3
log
@Names shortened for non-FLEXNAMES systems (cray),
and converted to using stdio for all I/O.
@
text
@d19 1
a19 1
static char RCSmaterial[] = "@@(#)$Header: material.c,v 1.2 86/06/13 00:34:56 mike Exp $ (BRL)";
d32 3
d44 3
@


1.2
log
@Minor improvements to matlib_print
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: material.c,v 1.1 86/06/11 00:13:32 mike Exp $ (BRL)";
d28 3
a30 3
extern int plastic_setup();
extern int texture_setup();
extern int testmap_setup();
d37 3
a39 3
	"plastic",	plastic_setup,
	"texture",	texture_setup,
	"testmap",	testmap_setup,
d45 1
a45 1
 *			M A T L I B _ S E T U P
d52 1
a52 1
matlib_setup( rp )
d58 1
a58 1
		rt_log("matlib_setup:  region %s already setup\n", rp->reg_name );
d69 1
a69 1
	rt_log("matlib_setup(%s):  material not known, default assumed\n",
d72 1
a72 1
	return( plastic_setup( rp ) );
d76 1
a76 1
 *			M A T L I B _ P A R S E
d78 1
a78 1
matlib_parse( cp, parsetab, base )
d121 1
a121 1
		rt_log("matlib_parse:  %s=%s not a valid arg\n", name, value);
d127 1
a127 1
 *			M A T L I B _ P R I N T
d129 1
a129 1
matlib_print( title, parsetab, base )
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: $ (BRL)";
a123 1
	matlib_print( "matlib_parse", parsetab, base );
a137 1
		rt_log( " %s=", mp->mp_name );
d140 2
a141 1
			rt_log( "%s\n", base + mp->mp_offset );
d144 2
a145 1
			rt_log( "%d\n", *((int *)(base + mp->mp_offset)) );
d148 2
a149 1
			rt_log( "%f\n", *((double *)(base + mp->mp_offset)) );
d152 2
a153 1
			rt_log( " %s??\n", mp->mp_fmt );
@
