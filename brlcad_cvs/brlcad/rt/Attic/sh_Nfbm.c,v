head	1.11;
access;
symbols
	rel-4-5:1.10
	ctj-4-5-post:1.10
	ctj-4-5-pre:1.10;
locks; strict;
comment	@ * @;


1.11
date	98.09.22.01.43.10;	author mike;	state dead;
branches;
next	1.10;

1.10
date	96.09.14.03.43.17;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	96.08.31.08.47.53;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	96.08.31.08.22.03;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	96.08.27.07.31.47;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.08.21.13.48.41;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	96.07.30.23.31.19;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	96.03.01.03.06.47;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	95.08.19.05.05.01;	author butler;	state Exp;
branches;
next	;


desc
@Normal noise shader
@


1.11
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@/*
 *	S H _ N F B M . C
 *
 */
#include "conf.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"


#define Nfbm_MAGIC 0x18364	/* XXX change this number for each shader */
struct Nfbm_specific {
	long	magic;
	double	lacunarity;
	double	h_val;
	double	octaves;
	double	max_angle;
	double	size;
	point_t vsize;
	vect_t	delta;
	mat_t	xform;
};
#define CK_Nfbm_SP(_p) RT_CKMAG(_p, Nfbm_MAGIC, "Nfbm_specific")

static struct Nfbm_specific Nfbm_defaults = {
	Nfbm_MAGIC,
	2.1753974,			/* lacunarity */
	1.0,				/* h_val */
	4,				/* octaves */
	22.5,				/* Angle  */
	1.0,				/* size */
	{ 1.0, 1.0, 1.0 },		/* Vector Size */
	{ 1000.0, 1000.0, 1000.0 }	/* delta */
	};

#define SHDR_NULL	((struct Nfbm_specific *)0)
#define SHDR_O(m)	offsetof(struct Nfbm_specific, m)
#define SHDR_AO(m)	offsetofarray(struct Nfbm_specific, m)

void
cvt_parse( sdp, name, base, value )
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
char					*base;	/* begining of structure */
CONST char				*value;	/* string containing value */
{
	double v;
	double *p = (double *)(base+sdp->sp_offset);

	/* reconvert with optional units */
	*p = rt_mm_value(value);
}

struct bu_structparse Nfbm_parse[] = {
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",	1, "angle",		SHDR_O(max_angle),	FUNC_NULL },
	{"%f",	1, "a", 		SHDR_O(max_angle),	FUNC_NULL },
	{"%f",  1, "size",		SHDR_O(size),		cvt_parse },
	{"%f",  1, "s",			SHDR_O(size),		cvt_parse },
	{"%f",  3, "vsize",		SHDR_AO(vsize),		FUNC_NULL },
	{"%f",  3, "v",			SHDR_AO(vsize),		FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),		FUNC_NULL },
	
	{"",	0, (char *)0,		0,			FUNC_NULL }
};

HIDDEN int	Nfbm_setup(), Nfbm_render();
HIDDEN void	Nfbm_print(), Nfbm_free();

struct mfuncs Nfbm_mfuncs[] = {
	{"Nfbm",	0,	0,		MFI_NORMAL,		0,
	Nfbm_setup,	Nfbm_render,	Nfbm_print,	Nfbm_free },

	{(char *)0,	0,		0,		0,		0,
	0,		0,		0,		0 }
};


/*	N F B M _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
Nfbm_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct rt_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
{
	register struct Nfbm_specific	*Nfbm_sp;
	mat_t	model_to_region;
	mat_t	tmp;

	RT_CHECK_RTI(rtip);
	RT_VLS_CHECK( matparm );
	RT_CK_REGION(rp);
	GETSTRUCT( Nfbm_sp, Nfbm_specific );
	*dpp = (char *)Nfbm_sp;

	memcpy(Nfbm_sp, &Nfbm_defaults, sizeof(struct Nfbm_specific) );

	if( bu_struct_parse( matparm, Nfbm_parse, (char *)Nfbm_sp ) < 0 )
		return(-1);

	/* Optional:  get the matrix which maps model space into
	 *  "region" or "shader" space
	 */
	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name);

	/* add the noise-space scaling */
	mat_idn(tmp);
	if (Nfbm_sp->size != 1.0) {
		tmp[0] = tmp[5] = tmp[10] = 1.0/Nfbm_sp->size;
	} else {
		tmp[0] = 1.0/Nfbm_sp->vsize[0];
		tmp[5] = 1.0/Nfbm_sp->vsize[1];
		tmp[10] = 1.0/Nfbm_sp->vsize[2];
	}

	mat_mul(Nfbm_sp->xform, tmp, model_to_region);

	/* Add any translation within shader/region space */
	mat_idn(tmp);
	tmp[MDX] = Nfbm_sp->delta[0];
	tmp[MDY] = Nfbm_sp->delta[1];
	tmp[MDZ] = Nfbm_sp->delta[2];
	mat_mul2(tmp, Nfbm_sp->xform);

	if( rdebug&RDEBUG_SHADE) {
		bu_struct_print( rp->reg_name, Nfbm_parse, (char *)Nfbm_sp );
		mat_print( "xform", Nfbm_sp->xform );
	}

	return(1);
}

/*
 *	N F B M _ P R I N T
 */
HIDDEN void
Nfbm_print( rp, dp )
register struct region *rp;
char	*dp;
{
	bu_struct_print( rp->reg_name, Nfbm_parse, (char *)dp );
}

/*
 *	N F B M _ F R E E
 */
HIDDEN void
Nfbm_free( cp )
char *cp;
{
	rt_free( cp, "Nfbm_specific" );
}

/*	N F B M _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
 */
int
Nfbm_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
{
	register struct Nfbm_specific *Nfbm_sp =
		(struct Nfbm_specific *)dp;

	point_t pt;
	vect_t	v_noise;	/* noise vector for each octave */
	vect_t	freq_v;
	double	cos_angle;
	double	angle;
	quat_t	q;
	static CONST vect_t up = { 0.0, 0.0, 1.0 };
	vect_t	N;
	mat_t	mat;
	int	i;
	double	freq;
	point_t	p;

	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_Nfbm_SP(Nfbm_sp);

	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "foo", Nfbm_parse, (char *)Nfbm_sp );


	/* transform hit point into "shader-space coordinates" */
	MAT4X3PNT(pt, Nfbm_sp->xform, swp->sw_hit.hit_point);


	/* Compute random vector from point */
	VSETALL(v_noise, 0.0);
	freq = 1.0;
	for (i=0 ; i < Nfbm_sp->octaves ; i++ ) {

#if 0
		noise_vec(pt, freq_v);
#else
		freq_v[X] = noise_perlin(pt);
		VSCALE(p, pt, Nfbm_sp->lacunarity);
		freq_v[Y] = noise_perlin(p);
		VSCALE(p, pt, Nfbm_sp->lacunarity*Nfbm_sp->lacunarity);
		freq_v[Z] = noise_perlin(p);
#endif
		VJOIN1(v_noise, v_noise, 1.0/freq, freq_v);
		VSCALE(pt, pt, Nfbm_sp->lacunarity);
		freq *= Nfbm_sp->lacunarity;
	}

	VUNITIZE(v_noise);
	cos_angle = VDOT(v_noise, up);
	angle = acos(cos_angle);
	
	angle *= Nfbm_sp->max_angle / 180.0;


	/* form quaternion to rotate Normal to new location */
	VCROSS(q, up, v_noise);

	QUAT_FROM_VROT_RAD(q, angle, q);
	quat_quat2mat(mat, q);
	VMOVE(N, swp->sw_hit.hit_normal);
	MAT4X3VEC(swp->sw_hit.hit_normal, mat, N);
	
	return(1);
}
#if 0

/* compute the footprint of the ray intersect point */
radius = ap->a_rbeam + ap->a_diverge * swp->sw_hit.hit_dist;


	/* Compute random vector from point */
	VSET(v_noise, 0.0, 0.0, 0.0);
	VSET(N, 0.0, 0.0, 0.0);
	freq = 1.0;
	for (i=0 ; i < Nfbm_sp->octaves ; i++ ) {
		noise_vec(pt, v_noise);
		VJOIN1(N, N, 1.0/freq, v_noise);
		VSCALE(pt, pt, Nfbm_sp->lacunarity);
		freq *= Nfbm_sp->lacunarity;
	}

	/* XXX This is bad */
	while ( MAGSQ(N) > .125) {
		VSCALE(N, N, 0.5);
	}

	VADD2(swp->sw_hit.hit_normal, swp->sw_hit.hit_normal, N);
	VUNITIZE(swp->sw_hit.hit_normal);

	new_cos_angle = VDOT(swp->sw_hit.hit_normal, ap->a_ray.r_dir) ;

	/* preserve the normal vs ray orientation */
	if (cos_angle <= 0.0 && new_cos_angle > 0.0 ||
	    cos_angle > 0.0 && new_cos_angle <= 0.0) {
		VREVERSE(swp->sw_hit.hit_normal, swp->sw_hit.hit_normal);
	}
#endif
@


1.10
log
@noise_g went away.  call noise_perlin now
@
text
@@


1.9
log
@bu_struct_print
@
text
@d220 1
a220 1
		freq_v[X] = noise_g(pt);
d222 1
a222 1
		freq_v[Y] = noise_g(p);
d224 1
a224 1
		freq_v[Z] = noise_g(p);
@


1.8
log
@bu_struct_parse
@
text
@d144 1
a144 1
		bu_structprint( rp->reg_name, Nfbm_parse, (char *)Nfbm_sp );
d159 1
a159 1
	bu_structprint( rp->reg_name, Nfbm_parse, (char *)dp );
d205 1
a205 1
		bu_structprint( "foo", Nfbm_parse, (char *)Nfbm_sp );
@


1.7
log
@structparse moved to libbu
@
text
@d116 1
a116 1
	if( bu_structparse( matparm, Nfbm_parse, (char *)Nfbm_sp ) < 0 )
@


1.6
log
@Fixed non-ANSI error
@
text
@d48 1
a48 1
register CONST struct structparse	*sdp;	/* structure description */
d60 1
a60 1
struct structparse Nfbm_parse[] = {
d116 1
a116 1
	if( rt_structparse( matparm, Nfbm_parse, (char *)Nfbm_sp ) < 0 )
d144 1
a144 1
		rt_structprint( rp->reg_name, Nfbm_parse, (char *)Nfbm_sp );
d159 1
a159 1
	rt_structprint( rp->reg_name, Nfbm_parse, (char *)dp );
d205 1
a205 1
		rt_structprint( "foo", Nfbm_parse, (char *)Nfbm_sp );
@


1.5
log
@Minor mods for IRIX 6.2.
@
text
@d193 1
a193 1
	static const vect_t up = { 0.0, 0.0, 1.0 };
@


1.4
log
@reworked to allow user to specify max angle of normal perturbation
@
text
@d193 1
a193 1
	const static vect_t up = { 0.0, 0.0, 1.0 };
@


1.3
log
@Fixed footprint calculation
@
text
@d23 3
a25 1
	point_t	scale;		/* scale noise space */
d36 3
a38 1
	{ 1.0, 1.0, 1.0 },		/* scale */
d46 14
d66 6
a71 2
	{"%f",  3, "scale",		SHDR_AO(scale),		FUNC_NULL },
	{"%f",  3, "s",			SHDR_AO(scale),		FUNC_NULL },
d74 1
a74 1

d126 7
a132 3
	tmp[0] = Nfbm_sp->scale[0];
	tmp[5] = Nfbm_sp->scale[1];
	tmp[10] = Nfbm_sp->scale[2];
d186 2
d189 10
a198 8
	vect_t	N;		/* sum of noise vector "octaves" */
	point_t pt;
	double freq;
	int i;
	double cos_angle;
	double new_cos_angle;
	double tmp;
	double radius;
a206 2
	/* compute the footprint of the ray intersect point */
	radius = ap->a_rbeam + ap->a_diverge * swp->sw_hit.hit_dist;
a207 3
	/* get angle between ray and original surface normal */
	cos_angle = VDOT(swp->sw_hit.hit_normal, ap->a_ray.r_dir);

d211 44
d280 1
a280 2
	return(1);
}
@


1.2
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d168 1
a168 1
	double area;
d178 1
a178 1
	area = ap->a_rbeam + ap->a_diverge * swp->sw_hit.hit_dist;
@


1.1
log
@Initial revision
@
text
@d60 1
a60 1
	{"Nfbm",	0,	0,		MFI_NORMAL,
d63 1
a63 1
	{(char *)0,	0,		0,		0,
d168 1
d177 6
d196 2
a197 3
	cos_angle = VDOT(swp->sw_hit.hit_normal, ap->a_ray.r_dir);

	if ( MAGSQ(N) > .25) {
@
