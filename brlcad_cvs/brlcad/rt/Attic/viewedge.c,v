head	11.28;
access;
symbols
	ansi-20040405-merged:11.21.2.2
	postmerge-20040405-ansi:11.26
	premerge-20040404-ansi:11.25
	postmerge-autoconf:11.25
	autoconf-freeze:11.23.6.3
	premerge-autoconf:11.25
	postmerge-20040315-windows:11.25
	premerge-20040315-windows:11.25
	windows-20040315-freeze:11.21.4.1
	autoconf-20031203:11.23.6.1
	autoconf-20031202:11.23
	autoconf-branch:11.23.0.6
	phong-branch:11.23.0.4
	photonmap-branch:11.23.0.2
	rel-6-1-DP:11.21
	windows-branch:11.21.0.4
	rel-6-0-2:11.19
	ansi-branch:11.21.0.2
	rel-6-0-1-branch:11.19.0.2
	hartley-6-0-post:11.20
	hartley-6-0-pre:11.19
	rel-6-0-1:11.19
	rel-6-0:11.19;
locks; strict;
comment	@ * @;


11.28
date	2004.05.21.17.31.09;	author morrison;	state dead;
branches;
next	11.27;

11.27
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.26;

11.26
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2003.10.08.17.34.41;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2003.04.01.19.25.43;	author jra;	state Exp;
branches
	11.23.6.1;
next	11.22;

11.22
date	2002.12.31.14.48.42;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2002.08.20.17.08.39;	author jra;	state Exp;
branches
	11.21.2.1
	11.21.4.1;
next	11.20;

11.20
date	2002.08.15.20.55.50;	author hartley;	state Exp;
branches;
next	11.19;

11.19
date	2002.01.14.21.09.50;	author rbowers;	state Exp;
branches;
next	11.18;

11.18
date	2001.10.17.07.40.06;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2001.06.27.17.50.04;	author rbowers;	state Exp;
branches;
next	11.16;

11.16
date	2001.06.26.21.13.32;	author rbowers;	state Exp;
branches;
next	11.15;

11.15
date	2001.06.26.13.27.58;	author rbowers;	state Exp;
branches;
next	11.14;

11.14
date	2001.06.25.21.27.55;	author rbowers;	state Exp;
branches;
next	11.13;

11.13
date	2001.06.25.14.14.31;	author rbowers;	state Exp;
branches;
next	11.12;

11.12
date	2001.06.25.13.24.58;	author rbowers;	state Exp;
branches;
next	11.11;

11.11
date	2001.06.22.12.30.44;	author rbowers;	state Exp;
branches;
next	11.10;

11.10
date	2001.06.20.20.56.42;	author rbowers;	state Exp;
branches;
next	11.9;

11.9
date	2001.05.31.15.28.53;	author rbowers;	state Exp;
branches;
next	11.8;

11.8
date	2001.05.16.21.38.19;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2001.03.23.21.26.54;	author rbowers;	state Exp;
branches;
next	11.6;

11.6
date	2001.03.21.22.32.15;	author rbowers;	state Exp;
branches;
next	11.5;

11.5
date	2001.03.21.16.50.13;	author rbowers;	state Exp;
branches;
next	11.4;

11.4
date	2001.03.21.16.34.12;	author rbowers;	state Exp;
branches;
next	11.3;

11.3
date	2001.03.20.21.55.55;	author rbowers;	state Exp;
branches;
next	11.2;

11.2
date	2001.03.20.21.31.06;	author rbowers;	state Exp;
branches;
next	11.1;

11.1
date	2001.03.20.21.17.03;	author rbowers;	state Exp;
branches;
next	;

11.21.2.1
date	2002.09.19.18.02.16;	author morrison;	state Exp;
branches;
next	11.21.2.2;

11.21.2.2
date	2004.03.17.21.23.01;	author morrison;	state Exp;
branches;
next	;

11.21.4.1
date	2004.03.11.23.48.07;	author morrison;	state Exp;
branches;
next	;

11.23.6.1
date	2003.12.03.16.25.44;	author erikg;	state Exp;
branches;
next	11.23.6.2;

11.23.6.2
date	2004.02.12.19.37.14;	author erikg;	state Exp;
branches;
next	11.23.6.3;

11.23.6.3
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.28
log
@moved to src/rt/
@
text
@/*
 *			V I E W E D G E
 *
 *  Ray Tracing program RTEDGE bottom half.
 *
 *  This module utilizes the RT library to interrogate a MGED
 *  model and produce a pixfile or framebuffer image of the
 *  hidden line 'edges' of the geometry. An edge exists whenever
 *  there is a change in region ID, or a significant change in
 *  obliquity or line-of-sight distance.
 *
 *  
 *  XXX - Add support for detecting changes in specified attributes.
 *
 *  Author -
 *	Ronald A. Bowers
 *
 *  Source -
 *	
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 2001-2004 by the United States Army.
 * All rights reserved.  */
#ifndef lint
static const char RCSviewedge[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/viewedge.c,v 11.27 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "fb.h"
#include "./ext.h"

#define RTEDGE_DEBUG 1

int	use_air = 0;			/* Handling of air in librt */
int	using_mlib = 0;			/* Material routines NOT used */

extern 	FBIO	*fbp;			/* Framebuffer handle */
extern	fastf_t	viewsize;
extern	int	lightmodel;
extern	int	width, height;
extern int	per_processor_chunk;

static	int pixsize = 0;		/* bytes per pixel in scanline */

struct cell {
        int		c_ishit;
	struct region *	c_region;
	fastf_t		c_dist;		/* distance from emanation plane to in_hit */
	int		c_id;		/* region_id of component hit */
	point_t		c_hit;		/* 3-space hit point of ray */
	vect_t		c_normal;	/* surface normal at the hit point */
	vect_t		c_rdir;		/* ray direction, permits perspective */
};

#define MISS_DIST	MAX_FASTF
#define MISS_ID		-1

static unsigned char *writeable[MAX_PSW];
static unsigned char *scanline[MAX_PSW];
static unsigned char *blendline[MAX_PSW];
static struct cell   *saved[MAX_PSW];
static struct resource occlusion_resources[MAX_PSW];

int   		nEdges = 0;
int   		nPixels = 0;
fastf_t		max_dist; /* min. distance for drawing pits/mountains */
fastf_t		maxangle; /* Value of the cosine of the angle between
			   * surface normals that triggers shading 
			   */

typedef int color[3];
color	foreground = { 255, 255, 255};

/*
 * Flags that set which edges are detected.
 * detect_ids means detect boundaries region id codes.
 * detect_regions -> detect region boundaries.
 * detect_distance -> detect noticable differences in hit distance.
 * detect_normals -> detect rapid change in surface normals
 */
int	detect_ids = 1;
int	detect_regions = 0;
int	detect_distance = 1;
int	detect_normals = 1;
int     detect_attributes = 0; /* unsupported yet */

RGBpixel bg_color;

/*
 * Overlay Mode
 *
 * If set, and the fbio points to a readable framebuffer, only
 * edge pixels are splatted. This allows rtedge to overlay edges
 * directly rather than having to use pixmerge.
 */
#define OVERLAY_MODE_UNSET 0
#define OVERLAY_MODE_DOIT  1
#define OVERLAY_MODE_FORCE 2

static int    overlay = OVERLAY_MODE_UNSET;

/*
 * Blend Mode
 * 
 * If set, and the fbio points to a readable framebuffer, the edge
 * pixels are blended (using some HSV manipulations) with the 
 * original framebuffer pixels. The intent is to produce an effect
 * similar to the "bugs" on TV networks.
 *
 * Doesn't work worth beans!
 */
int    blend = 0;

/*
 * Region Colors Mode
 * 
 * If set, the color of edge pixels is set to the region colors.
 * If the edge is determined because of a change from one region 
 * to another, the color selected is the one from the region with
 * the lowest hit distance.
 */
int    region_colors = 0;

/*
 * Occlusions Mode
 *
 * This is really cool! Occlusion allows the user to specify a second
 * set of objects (from the same .g) that can be used to separate fore-
 * ground from background.
 */
#define OCCLUSION_MODE_NONE 0
#define OCCLUSION_MODE_EDGES 1
#define OCCLUSION_MODE_HITS 2
#define OCCLUSION_MODE_DITHER 3
#define OCCLUSION_MODE_DEFAULT 2

int occlusion_mode = OCCLUSION_MODE_NONE;

struct bu_vls occlusion_objects;
struct rt_i *occlusion_rtip = NULL;
struct application **occlusion_apps;

static int occlusion_hit (struct application *, 
			  struct partition *, struct seg *);
static int occlusion_miss (struct application *);
static int occludes (struct application *, struct cell *);


/*
 * Prototypes for the viewedge edge detection functions
 */
static int is_edge(struct application *, struct cell *, struct cell *,
	struct cell *below);
static int rayhit (struct application *, struct partition *, struct seg *);
static int rayhit2 (struct application *, struct partition *, struct seg *);
static int raymiss (struct application *);
static int raymiss2 (struct application *);
static int handle_main_ray(struct application *, struct partition *, 
			   struct seg *);
static int diffpixel (RGBpixel a, RGBpixel b);
static void choose_color (RGBpixel col, struct cell *me,
			  struct cell *left, struct cell *below);

#define COSTOL 0.91    /* normals differ if dot product < COSTOL */
#define OBLTOL 0.1     /* high obliquity if cosine of angle < OBLTOL ! */
#define is_Odd(_a)      ((_a)&01)
#define ARCTAN_87       19.08

#ifndef Abs
#define Abs( x )        ((x) < 0 ? -(x) : (x))                  /* UNSAFE */
#endif

/*
 * From do.c
 */
#if CRAY
#	define byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
#	define byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define byteoffset(_i)	((int)((char *)&(_i)))
#    else
/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#    endif
#  endif
#endif
/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
  {"%d", 1, "detect_regions", byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dr", byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_distance", byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dd", byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_normals", byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dn", byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_ids", byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "di", byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "foreground", byteoffset(foreground), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "fg", byteoffset(foreground), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "background", byteoffset(background), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "bg", byteoffset(background), BU_STRUCTPARSE_FUNC_NULL},	
  {"%d", 1, "overlay", byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "ov", byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "blend", byteoffset(blend), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "bl", byteoffset(blend), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "region_color", byteoffset(region_colors), 
   BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "rc", byteoffset(region_colors), BU_STRUCTPARSE_FUNC_NULL},
  {"%S", 1, "occlusion_objects", byteoffset(occlusion_objects), 
   BU_STRUCTPARSE_FUNC_NULL},
  {"%S", 1, "oo", byteoffset(occlusion_objects), 
   BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "occlusion_mode", byteoffset(occlusion_mode), 
   BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "om", byteoffset(occlusion_mode), BU_STRUCTPARSE_FUNC_NULL},
  {"",	0, (char *)0,	0,	BU_STRUCTPARSE_FUNC_NULL }
};

char usage[] = "\
Usage:  rtedge [options] model.g objects... >file.pix\n\
Options:\n\
 -s #               Grid size in pixels, (default 512)\n\
 -w # -n #          Grid size width and height in pixels\n\
 -V #               View (pixel) aspect ratio (width/height)\n\
 -a #               Azimuth in deg\n\
 -e #               Elevation in deg\n\
 -M                 Read matrix+cmds on stdin\n\
 -N #               NMG debug flags\n\
 -o model.pix       Output file, .pix format (default=fb)\n\
 -x #               librt debug flags\n\
 -X #               rt debug flags\n\
 -p #               Perspsective, degrees side to side\n\
 -P #               Set number of processors\n\
 -T #/#             Tolerance: distance/angular\n\
 -r                 Report overlaps\n\
 -R                 Do not report overlaps\n\
 -c                 Auxillary commands (see man page)\n";
 

/*
 *  Called at the start of a run.
 *  Returns 1 if framebuffer should be opened, else 0.
 */
int
view_init( struct application *ap, char *file, char *obj, int minus_o )
{
  /*
   *  Allocate a scanline for each processor.
   */
  ap->a_hit = rayhit;
  ap->a_miss = raymiss;
  ap->a_onehit = 1;

  /*
   * Does the user want occlusion checking?
   * 
   * If so, load and prep.
   */
  if (bu_vls_strlen(&occlusion_objects) != 0) {
    /*    char idbuf[512]; */
    struct db_i *dbip;
    int nObjs;
    const char **objs;
    int i;

    bu_log ("rtedge: loading occlusion geometry from %s.\n", file);

    if (Tcl_SplitList (NULL, bu_vls_addr (&occlusion_objects), &nObjs, 
		       &objs) == TCL_ERROR) {
      bu_log  ("rtedge: occlusion list = %s\n", 
	       bu_vls_addr(&occlusion_objects));
      bu_bomb ("rtedge: could not parse occlusion objects list.\n");
    }

    for (i=0; i<nObjs; ++i) {
      bu_log ("rtedge: occlusion object %d = %s\n", i, objs[i]);
    }
    

    if( (dbip = db_open( file, "r" )) == DBI_NULL ) {
      bu_bomb ("rtedge: could not open database.\n");
    }
    RT_CK_DBI(dbip);

    occlusion_rtip = rt_new_rti( dbip ); /* clones dbip */

    for( i=0; i < MAX_PSW; i++ )  
      {
	rt_init_resource( &occlusion_resources[i], i, occlusion_rtip );
	bn_rand_init( occlusion_resources[i].re_randptr, i );
      }

    db_close(dbip);			 /* releases original dbip */

    for (i=0; i<nObjs; ++i) {
      if (rt_gettree (occlusion_rtip, objs[i]) < 0) {
	bu_log ("rtedge: gettree failed for %s\n", objs[i]);
      }
      else {
	bu_log ("rtedge: got tree for object %d = %s\n", i, objs[i]);
      }
    }

    bu_log ("rtedge: occlusion rt_gettrees done.\n");

    rt_prep (occlusion_rtip);

    bu_log ("rtedge: occlustion prep done.\n");

    /*
     * Create a set of application structures for the occlusion
     * geometry. Need one per cpu, the upper half does the per-
     * thread allocation in worker, but that's off limits.
     */
    occlusion_apps = bu_calloc (npsw, sizeof(struct application *), 
			    "occlusion application structure array");
    for (i=0; i<npsw; ++i) {
      occlusion_apps[i] = bu_calloc (1, sizeof(struct application), 
				 "occlusion_application structure");

      occlusion_apps[i]->a_rt_i = occlusion_rtip;
      occlusion_apps[i]->a_resource = (struct resource *)BU_PTBL_GET( &occlusion_rtip->rti_resources, i );
      occlusion_apps[i]->a_onehit = 1;
      occlusion_apps[i]->a_hit = occlusion_hit;
      occlusion_apps[i]->a_miss = occlusion_miss;
      if (rpt_overlap) {
	      occlusion_apps[i]->a_logoverlap = ((void (*)())0);
      } else {
	      occlusion_apps[i]->a_logoverlap = rt_silent_logoverlap;
      }

    }    		       
    bu_log ("rtedge: will perform occlusion testing.\n");

    /*
     * If an inclusion mode has not been specified, use the default.
     */
    if (occlusion_mode == OCCLUSION_MODE_NONE) {
      occlusion_mode = OCCLUSION_MODE_DEFAULT;
      bu_log ("rtedge: occlusion mode = %d\n", occlusion_mode);
    }

    if ((occlusion_mode != OCCLUSION_MODE_NONE) && 
	(overlay == OVERLAY_MODE_UNSET)) {
      bu_log ("rtedge: automagically activating overlay mode.\n");
      overlay = OVERLAY_MODE_DOIT;
    }

  }
 
  if (occlusion_mode != OCCLUSION_MODE_NONE &&
      bu_vls_strlen(&occlusion_objects) == 0) {
    bu_bomb ("rtedge: occlusion mode set, but no objects were specified.\n");
  }


  if( minus_o ) {
    /*
     * Output is to a file stream.
     * Do not open a framebuffer, do not allow parallel
     * processing since we can't seek to the rows.
     */
    rt_g.rtg_parallel = 0;
    bu_log ("view_init: deactivating parallelism due to minus_o.\n");
    /*
     * The overlay and blend cannot be used in -o mode.
     * Note that the overlay directive takes precendence, they
     * can't be used together.
     */
    overlay = 0;
    blend = 0;
    bu_log ("view_init: deactivating overlay and blending due to minus_o.\n");
    return(0);
  }
  else if (overlay) {      
    bu_log ("view_init: will perform simple overlay.\n");
  }
  else if (blend) {
    bu_log ("view_init: will perform blending.\n");
  }
  
  return(1);		/* we need a framebuffer */
}

/* beginning of a frame */
void
view_2init( struct application *ap )
{
  int i;

  /*
   * Per_processor_chuck specifies the number of pixels rendered
   * per each pass of a worker. By making this value equal to the
   * width of the image, each worker will render one scanline at
   * a time.
   */
  per_processor_chunk = width;

  /*
   * Create a cell to store current data for next cells left side.
   */
  for (i = 0; i < npsw; ++i) {
    if (saved[i] == NULL) {
      saved[i] = (struct cell *) bu_calloc( 1, sizeof(struct cell), 
					      "saved cell info" );
    }	
  }

  /*
   * Create a edge flag buffer for each processor.
   */
  for ( i = 0; i < npsw; ++i ) {
    if (writeable[i] == NULL) {
      writeable[i] = (unsigned char *) bu_calloc( 1, per_processor_chunk, 
					      "writeable pixel flag buffer" );
    }	
  }

  /*
   * Use three bytes per pixel.
   */
  pixsize = 3;
  
  /*
   * Create a scanline buffer for each processor.
   */
  for ( i = 0; i < npsw; ++i ) {
    if (scanline[i] == NULL) {
      scanline[i] = (unsigned char *) bu_calloc( per_processor_chunk, 
						 pixsize, "scanline buffer" );
    }	
  }
  
  /*
   * Set the hit distance difference necessary to trigger an edge.
   * This algorythm was stolen from lgt, I may make it settable later.
   */
  max_dist = (cell_width*ARCTAN_87)+2;
  
  /*
   * Determine if the framebuffer is readable.
   */
  if (overlay || blend) {
    
    if (fb_read(fbp,0,0,bg_color,1) < 0) {
      bu_bomb ("rt_edge: specified framebuffer is not readable, cannot merge.\n");
      
    }
  }

  /*
   * If blending is desired, create scanline buffers to hold
   * the read-in lines from the framebuffer.
   */
  if (blend) {
    for (i = 0; i < npsw; ++i) {
      if (blendline[i] == NULL) {
	blendline[i] = (unsigned char *) bu_calloc( per_processor_chunk, 
						    pixsize, 
						    "blend buffer" );
      }	
    }
  }
 
  /*
   * If operating in overlay mode, we want the rtedge background color 
   * to be the shaded images background. This sets the bg color 
   * automatically, but assumes that pixel 0,0 is background. If not,
   * the user can set it manually (so long as it isn't 0 0 1!).
   *
   */
  if (overlay) {
    if (background[RED] == 0 && 
	background[GRN] == 0 &&
	background[BLU] == 1) {
      
      background[RED] = bg_color[RED];
      background[GRN] = bg_color[GRN];
      background[BLU] = bg_color[BLU];
    }
  }
  return;
}

/* end of each pixel */
void view_pixel( struct application *ap ) { }


/*
 * view_eol - action performed at the end of each scanline
 *
 */
void
view_eol( struct application *ap )
{
  int cpu = ap->a_resource->re_cpu;
  int i;

  if (overlay) {
    /*
     * Overlay mode. Check if the pixel is an edge.
     * If so, write it to the framebuffer.
     */
    for (i = 0; i < per_processor_chunk; ++i) {
      if (writeable[cpu][i]) {
	/*
	 * Write this pixel
	 */
	bu_semaphore_acquire (BU_SEM_SYSCALL);
	fb_write(fbp, i, ap->a_y, &scanline[cpu][i*3], 1);	  
	bu_semaphore_release (BU_SEM_SYSCALL);
      }
    }
  }
  else if (blend) {
    /*
     * Blend mode.
     *
     * Read a line from the existing framebuffer,
     * convert to HSV, manipulate, and put the results
     * in the scanline as RGB.
     */
    int replace_down = 0; /* flag that specifies if the pixel in the
			   * scanline below must be replaced.
			   */
    RGBpixel rgb;
    fastf_t hsv[3];
    
    bu_semaphore_acquire (BU_SEM_SYSCALL);
    if (fb_read(fbp,0,ap->a_y,blendline[cpu],per_processor_chunk) < 0) {
      bu_bomb ("rtedge: error reading from framebuffer.\n");
    }
    bu_semaphore_release (BU_SEM_SYSCALL);
    
    for (i=0; i<per_processor_chunk; ++i) {
      /*
       * Is this pixel an edge?
       */
      if (writeable[cpu][i]) {

	/*
	 * The pixel is an edge, retrieve the appropriate
	 * pixel from the line buffer and convert it to HSV.
	 */
	rgb[RED] = blendline[cpu][i*3+RED];
	rgb[GRN] = blendline[cpu][i*3+GRN];
	rgb[BLU] = blendline[cpu][i*3+BLU];

	/*
	 * Is the pixel in the blendline array the
	 * background color? If so, look left and down
	 * to determine which pixel is the "source" of the
	 * edge. Unless, of course, we are on the bottom 
	 * scanline or the leftmost column (x=y=0)
	 */
	if (i != 0 && ap->a_y != 0 && !diffpixel (rgb,bg_color)) {
	  RGBpixel left;
	  RGBpixel down;
	  
	  left[RED] = blendline[cpu][(i-1)*3+RED];
	  left[GRN] = blendline[cpu][(i-1)*3+GRN];
	  left[BLU] = blendline[cpu][(i-1)*3+BLU];

	  bu_semaphore_acquire (BU_SEM_SYSCALL);
	  fb_read (fbp, i, ap->a_y - 1, down, 1);	  
	  bu_semaphore_release (BU_SEM_SYSCALL);

	  if (diffpixel (left, bg_color)) {
	    /* 
	     * Use this one.
	     */
	    rgb[RED] = left[RED];
	    rgb[GRN] = left[GRN];
	    rgb[BLU] = left[BLU];
	  }
	  else if (diffpixel (down, bg_color)) {
	    /*
	     * Use the pixel from the scanline below
	     */
	    replace_down = 1;

	    rgb[RED] = down[RED];
	    rgb[GRN] = down[GRN];
	    rgb[BLU] = down[BLU];
	  }
	}
	/*
	 * Convert to HSV
	 */
	bu_rgb_to_hsv (rgb, hsv);
      
	/*
	 * Now perform the manipulations.
	 */
	hsv[VAL] *= 3.0;
	hsv[SAT] /= 3.0;

	if (hsv[VAL] > 1.0) {
	  fastf_t d = hsv[VAL] - 1.0;
	  
	  hsv[VAL] = 1.0;
	  hsv[SAT] -= d;
	  hsv[SAT] = hsv[SAT] >= 0.0 ? hsv[SAT] : 0.0;
	}

	/*
	 * Convert back to RGB.
	 */
	bu_hsv_to_rgb(hsv,rgb);
	
	if (replace_down) {
	  /* 
	   * Write this pixel immediately, do not put it into 
	   * the blendline since it corresponds to the wrong
	   * scanline.
	   */
	  bu_semaphore_acquire (BU_SEM_SYSCALL);
	  fb_write (fbp, i, ap->a_y, rgb, 1);
	  bu_semaphore_release (BU_SEM_SYSCALL);

	  replace_down = 0;
	} 
	else {
	  /* 
	   * Put this pixel back into the blendline array.
	   * We'll push it to the buffer when the entire
	   * scanline has been processed.
	   */
	  blendline[cpu][i*3+RED] = rgb[RED];
	  blendline[cpu][i*3+GRN] = rgb[GRN];
	  blendline[cpu][i*3+BLU] = rgb[BLU];
	}
      } /* end "if this pixel is an edge" */
    } /* end pixel loop */

    /* 
     * Write the blendline to the framebuffer.
     */
    bu_semaphore_acquire (BU_SEM_SYSCALL);
    fb_write (fbp, 0, ap->a_y, blendline[cpu], per_processor_chunk);	  
    bu_semaphore_release (BU_SEM_SYSCALL);
  } /* end blend */
  else if( fbp != FBIO_NULL ) {
    /*
     * Simple whole scanline write to a framebuffer.
     */
    bu_semaphore_acquire (BU_SEM_SYSCALL);
    fb_write( fbp, 0, ap->a_y, scanline[cpu], per_processor_chunk );
    bu_semaphore_release (BU_SEM_SYSCALL);
  }
  else if( outfp != NULL ) {
    /*
     * Write to a file.
     */
    bu_semaphore_acquire (BU_SEM_SYSCALL);
    fwrite( scanline[cpu], pixsize, per_processor_chunk, outfp );
    bu_semaphore_release (BU_SEM_SYSCALL);
  }
  else {
    bu_log ("rtedge: strange, no end of line actions taken.\n");
  } 
  
  return;

}

void view_setup(void) { }

/*
 * end of a frame, called after rt_clean()
 */
void view_cleanup(void) { }

/*
 * end of each frame
 */
void view_end(void) { }

/*
 *			R A Y H I T
 */
int rayhit (struct application *ap, register struct partition *pt,
	struct seg *segp )
{
    if ( handle_main_ray(ap, pt, segp)) {
	ap->a_user = 1;
    } else {
	ap->a_user = 0;
    }
    return 1;
}

/*
 *			R A Y M I S S
 */
int raymiss( struct application *ap )
{
    if ( handle_main_ray(ap, NULL, NULL)) {
	ap->a_user = 1;
    } else {
	ap->a_user = 0;
    }
    return 0;
}

/*
 *			R A Y H I T 2
 */
int rayhit2 (struct application *ap, register struct partition *pt,
	struct seg *segp )
{
    struct partition	*pp = pt->pt_forw;
    struct hit		*hitp = pt->pt_forw->pt_inhit;
    struct cell 	*c = (struct cell *)ap->a_uptr;

    c->c_ishit 		= 1;
    c->c_region 	= pp->pt_regionp;
    c->c_id 		= pp->pt_regionp->reg_regionid;
    VMOVE(c->c_rdir, ap->a_ray.r_dir);
    VJOIN1(c->c_hit, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
    RT_HIT_NORMAL(c->c_normal, hitp,
	pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);
    c->c_dist = hitp->hit_dist;

    return(1);		
}

/*
 *			R A Y M I S S 2
 */
int raymiss2( register struct application *ap )
{
    struct cell *c = (struct cell *)ap->a_uptr;

    c->c_ishit    	= 0;
    c->c_region   	= 0;
    c->c_dist     	= MISS_DIST;
    c->c_id	    	= MISS_ID;	
    VSETALL(c->c_hit, MISS_DIST);
    VSETALL(c->c_normal, 0);
    VMOVE(c->c_rdir, ap->a_ray.r_dir);

    return(0);
}

int is_edge(struct application *ap, struct cell *here,
	    struct cell *left, struct cell *below)
{
  if (here->c_ishit) {

    if (detect_ids) {
      if (here->c_id != left->c_id || here->c_id != below->c_id) {
	return 1;
      } 
    } 

    if (detect_regions) {
      if (here->c_region != left->c_region || 
	  here->c_region != below->c_region ) {
	return 1;
      }
    }
  
    if (detect_distance) {
      if (Abs(here->c_dist - left->c_dist) > max_dist ||
	  Abs(here->c_dist - below->c_dist) > max_dist) {
	return 1;
      }
    }

    if (detect_normals) {
      if ((VDOT(here->c_normal, left->c_normal) < COSTOL) ||
	  (VDOT(here->c_normal, below->c_normal)< COSTOL)) {
	return 1;	
      }
    }
  }
  else {
    if (left->c_ishit || below->c_ishit) {
      return 1;
    }
  }
  
  return 0;
}


/*
 *			H A N D L E _ M A I N _ R A Y
 *
 */

int
handle_main_ray( struct application *ap, register struct partition *PartHeadp,
		 struct seg *segp )
{
  register struct partition *pp;
  register struct hit	*hitp;		/* which hit */
  
  LOCAL struct application	a2;
  LOCAL struct cell		me;
  LOCAL struct cell		below;
  LOCAL struct cell		left;
  LOCAL int			edge = 0;
  LOCAL int			cpu;	
  LOCAL int                     oc = 1;

  RGBpixel                      col;

  memset(&a2, 0, sizeof(struct application));
  memset(&me, 0, sizeof(struct cell));
  memset(&below, 0, sizeof(struct cell));
  memset(&left, 0, sizeof(struct cell));
  
  cpu = ap->a_resource->re_cpu;	
  
  if (PartHeadp == NULL) {
    /* The main shotline missed.
     * pack the application struct
     */
    me.c_ishit    = 0;
    me.c_dist   = MISS_DIST;
    me.c_id	    = MISS_ID;
    me.c_region = 0;
    VSETALL(me.c_hit, MISS_DIST);
    VSETALL(me.c_normal, 0);
    VMOVE(me.c_rdir, ap->a_ray.r_dir);
  } else {
    pp = PartHeadp->pt_forw;
    hitp = pp->pt_inhit;	
    /*
     * Stuff the information for this cell.
     */
    me.c_ishit    = 1;
    me.c_id = pp->pt_regionp->reg_regionid;
    me.c_dist = hitp->hit_dist;
    me.c_region = pp->pt_regionp;
    VMOVE(me.c_rdir, ap->a_ray.r_dir);
    VJOIN1(me.c_hit, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
    RT_HIT_NORMAL(me.c_normal, hitp,
		  pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);	       
  }
  
  /*
   * Now, fire a ray for both the cell below and if necessary, the
   * cell to the left.
   */
  a2.a_hit = rayhit2;
  a2.a_miss = raymiss2;
  a2.a_onehit = 1;
  a2.a_rt_i = ap->a_rt_i;
  a2.a_resource = ap->a_resource;
  a2.a_logoverlap = ap->a_logoverlap;
  
  VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dy_model); /* below */
  VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
  a2.a_uptr = (genptr_t)&below;
  rt_shootray(&a2);
  
  if (ap->a_x == 0) {
    /*
     * For the first pixel in a scanline, we have to shoot to the left.
     * For each pixel afterword, we save the current cell info to be used
     * as the left side cell info for the following pixel
     */
    VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dx_model); /* left */
    VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
    a2.a_uptr = (genptr_t)&left;
    rt_shootray(&a2);
  }
  else {
    left.c_ishit    = saved[cpu]->c_ishit;
    left.c_id = saved[cpu]->c_id;
    left.c_dist = saved[cpu]->c_dist;
    left.c_region = saved[cpu]->c_region;
    VMOVE (left.c_rdir, saved[cpu]->c_rdir);
    VMOVE (left.c_hit, saved[cpu]->c_hit);
    VMOVE (left.c_normal, saved[cpu]->c_normal);
  }
  
  /*
   * Is this pixel an edge?
   */
  edge = is_edge (ap, &me, &left, &below);

  /*
   * Does this pixel occlude the second geometry?
   * Note that we must check on edges as well since right side and
   * top edges are actually misses.
   */
  if (occlusion_mode != OCCLUSION_MODE_NONE) {
    if (me.c_ishit || edge) {
      oc = occludes (ap, &me);
    }
  }

  /*
   * Perverse Pixel Painting Paradigm(tm)
   * If a pixel should be written to the fb, writeable is set.
   */
  if (occlusion_mode == OCCLUSION_MODE_EDGES) {
      
    if (edge && oc) {
      writeable[cpu][ap->a_x] = 1;
    } else {
      writeable[cpu][ap->a_x] = 0;
    }
  }
  else if (occlusion_mode == OCCLUSION_MODE_HITS) {
      
    if ( (me.c_ishit || edge) && oc) {
      writeable[cpu][ap->a_x] = 1;
    } 
    else {
      writeable[cpu][ap->a_x] = 0;
    }
  }
  else if (occlusion_mode == OCCLUSION_MODE_DITHER) {
      
    if (edge && oc) {
      writeable[cpu][ap->a_x] = 1;
    }
    else if (me.c_ishit && oc) {
      /*
       * Dither mode.
       *
       * For occluding non-edges, only write every 
       * other pixel.
       */
      if (oc == 1 && ((ap->a_x + ap->a_y) % 2) == 0) {
	writeable[cpu][ap->a_x] = 1;
      } 
      else if (oc == 2) {
	writeable[cpu][ap->a_x] = 1;
      }
      else {
	writeable[cpu][ap->a_x] = 0;
      }
    } 
    else {
      writeable[cpu][ap->a_x] = 0;
    }
  }
  else {
    if (edge) {
      writeable[cpu][ap->a_x] = 1;
    } else {
      writeable[cpu][ap->a_x] = 0;
    }
  }

  if (edge) {

    choose_color (col, &me, &left, &below);
    
    scanline[cpu][ap->a_x*3+RED] = col[RED];
    scanline[cpu][ap->a_x*3+GRN] = col[GRN];
    scanline[cpu][ap->a_x*3+BLU] = col[BLU];
    
  } else {
    
    scanline[cpu][ap->a_x*3+RED] = background[RED];
    scanline[cpu][ap->a_x*3+GRN] = background[GRN];
    scanline[cpu][ap->a_x*3+BLU] = background[BLU];	  
  }

  /*
   * Save the cell info for the next pixel.
   */
  saved[cpu]->c_ishit = me.c_ishit;
  saved[cpu]->c_id = me.c_id;
  saved[cpu]->c_dist = me.c_dist;
  saved[cpu]->c_region = me.c_region;
  VMOVE (saved[cpu]->c_rdir, me.c_rdir);
  VMOVE (saved[cpu]->c_hit, me.c_hit);
  VMOVE (saved[cpu]->c_normal, me.c_normal);

  return edge;
}

void application_init (void) { 
  bu_vls_init(&occlusion_objects);
}


int diffpixel (RGBpixel a, RGBpixel b)
{
  if (a[RED] != b[RED]) return 1;
  if (a[GRN] != b[GRN]) return 1;
  if (a[BLU] != b[BLU]) return 1;
  return 0;
}

/*
 *
 *
 */
void choose_color (RGBpixel col, struct cell *me,
		  struct cell *left, struct cell *below)
{
  col[RED] = foreground[RED];
  col[GRN] = foreground[GRN];
  col[BLU] = foreground[BLU];

  if (region_colors) {

    struct cell *use_this = me;

    /*
     * Determine the cell with the smallest hit distance.
     */

    use_this = (me->c_dist < left->c_dist) ? me : left ;
    use_this = (use_this->c_dist < below->c_dist) ? use_this : below ;

    if (use_this == (struct cell *)NULL) {
      bu_bomb ("Error: use_this is NULL.\n");
    }

    col[RED] = 255 * use_this->c_region->reg_mater.ma_color[RED];
    col[GRN] = 255 * use_this->c_region->reg_mater.ma_color[GRN];
    col[BLU] = 255 * use_this->c_region->reg_mater.ma_color[BLU];

  }
  return;
}

static int occlusion_hit (struct application *ap, struct partition *pt, 
		      struct seg *segp)
{
  struct hit		*hitp = pt->pt_forw->pt_inhit;
  
  ap->a_dist = hitp->hit_dist;
  return 1;		
}

static int occlusion_miss (struct application *ap)
{
  ap->a_dist = MAX_FASTF;
  return 0;		
}



static int occludes (struct application *ap, struct cell *here)
{ 
  int cpu = ap->a_resource->re_cpu;	
  int oc_hit = 0;
  /*
   * Test the hit distance on the second geometry.
   * If the second geometry is closer, do not
   * color pixel
   */
  VMOVE (occlusion_apps[cpu]->a_ray.r_pt, ap->a_ray.r_pt);
  VMOVE (occlusion_apps[cpu]->a_ray.r_dir, ap->a_ray.r_dir);


  oc_hit = rt_shootray (occlusion_apps[cpu]);

  if (!oc_hit) {
    /*
     * The occlusion ray missed, therefore this 
     * pixel occludes the second geometry. 
     * 
     * Return 2 so that the fact that there is no
     * geometry behind can be conveyed to the 
     * OCCLUSION_MODE_DITHER section.
     */
    return 2;
  }

  if (occlusion_apps[cpu]->a_dist < here->c_dist) {
    /* 
     * The second geometry is close than the edge, therefore it
     * is 'foreground'. Do not draw the edge.
     *
     * - This pixel DOES NOT occlude the second geometry.
     */
    return 0; 
  }    
  return 1;
}
@


11.27
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /cvs/brlcad/rt/viewedge.c,v 11.26 2004/04/05 05:45:59 morrison Exp $ (BRL)";
@


11.26
log
@merge of ansi-6-0-branch into head
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header$ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.25
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.24 2003/10/08 17:34:41 morrison Exp $ (BRL)";
d677 1
a677 1
void view_setup() { }
d682 1
a682 1
void view_cleanup() { }
d687 1
a687 1
void view_end() { }
d991 1
a991 1
void application_init () { 
@


11.24
log
@Fix bug where pixels that have no blue component are off by one.
Added initialization of background to desired color in front-end now that background is provided by the liboptical.
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 2001 by the United States Army.
d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.23 2003/04/01 19:25:43 jra Exp $ (BRL)";
@


11.23
log
@Added a "const" to quiet the compiler
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.22 2002/12/31 14:48:42 jra Exp $ (BRL)";
a79 1
color	background = { 0, 0, 1};
@


11.23.6.1
log
@updates from HEAD, part 1
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.24 2003/10/08 17:34:41 morrison Exp $ (BRL)";
d80 1
@


11.23.6.2
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 2001-2004 by the United States Army.
d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.25 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.23.6.3
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.23.6.2 2004/02/12 19:37:14 erikg Exp $ (BRL)";
@


11.22
log
@Now sets overlap reporting option for all application structs it uses
resource structures are assigned to each application structure
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.21 2002/08/20 17:08:39 jra Exp $ (BRL)";
d274 1
a274 1
    char **objs;
@


11.21
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.19 2002/01/14 21:09:50 rbowers Exp $ (BRL)";
d333 1
d337 5
a482 1
  bu_log("1\n");
a492 1
  bu_log("2\n");
d864 1
a1064 1
  occlusion_apps[cpu]->a_resource = ap->a_resource;
a1093 32
































@


11.21.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 2001-2004 by the United States Army.
d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/viewedge.c,v 11.25 2004/02/02 17:39:39 morrison Exp $ (BRL)";
d80 1
d274 1
a274 1
    const char **objs;
a332 1
      occlusion_apps[i]->a_resource = (struct resource *)BU_PTBL_GET( &occlusion_rtip->rti_resources, i );
a335 5
      if (rpt_overlap) {
	      occlusion_apps[i]->a_logoverlap = ((void (*)())0);
      } else {
	      occlusion_apps[i]->a_logoverlap = rt_silent_logoverlap;
      }
d477 1
d488 1
a859 1
  a2.a_logoverlap = ap->a_logoverlap;
d1060 1
d1090 32
@


11.21.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.21 2002/08/20 17:08:39 jra Exp $ (BRL)";
d674 1
a674 1
void view_setup(void) { }
d679 1
a679 1
void view_cleanup(void) { }
d684 1
a684 1
void view_end(void) { }
d987 1
a987 1
void application_init (void) { 
@


11.21.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 2001-2004 by the United States Army.
d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header$ (BRL)";
d80 1
d274 1
a274 1
    const char **objs;
a332 1
      occlusion_apps[i]->a_resource = (struct resource *)BU_PTBL_GET( &occlusion_rtip->rti_resources, i );
a335 5
      if (rpt_overlap) {
	      occlusion_apps[i]->a_logoverlap = ((void (*)())0);
      } else {
	      occlusion_apps[i]->a_logoverlap = rt_silent_logoverlap;
      }
d477 1
d488 1
a859 1
  a2.a_logoverlap = ap->a_logoverlap;
d1060 1
d1090 32
@


11.20
log
@Converted from K&R to ANSI C - RFH
@
text
@d674 1
a674 1
void view_setup(void) { }
d679 1
a679 1
void view_cleanup(void) { }
d684 1
a684 1
void view_end(void) { }
d987 1
a987 1
void application_init (void) { 
@


11.19
log
@-* now properly initialize the struct resource stuff in the occlusion_rtip.
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.18 2001/10/17 07:40:06 morrison Exp $ (BRL)";
d674 1
a674 1
void view_setup() { }
d679 1
a679 1
void view_cleanup() { }
d684 1
a684 1
void view_end() { }
d987 1
a987 1
void application_init () { 
@


11.18
log
@Mac OS X warning and error fixes for non-production build
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.17 2001/06/27 17:50:04 rbowers Exp $ (BRL)";
d69 1
a69 1

d297 7
@


11.17
log
@-* Added ooclusion mode 3 (dithered transparency)!!!!!!
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.16 2001/06/26 21:13:32 rbowers Exp $ (BRL)";
d108 1
a108 1
int    overlay = OVERLAY_MODE_UNSET;
@


11.16
log
@-* occlusion test bug fixes
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.15 2001/06/26 13:27:58 rbowers Exp $ (BRL)";
d104 5
a108 1
int    overlay = 0;
d142 1
d338 7
a344 2
      bu_log ("rtedge: occlusion mode = %d\n", 
	      occlusion_mode);
d349 6
d890 2
a891 2
  if (me.c_ishit || edge) {
    if (occlusion_mode != OCCLUSION_MODE_NONE) {
d917 26
d1063 5
a1067 1
     * pixel occludes the second geometry.
d1069 1
a1069 1
    return 1;
@


11.15
log
@-* remove C++ style comments. They compiled file on linux so I didn't
   notice them. They broke on Irix 6.4
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.14 2001/06/25 21:27:55 rbowers Exp $ (BRL)";
d68 1
a68 1
static struct cell saved[MAX_PSW];
d276 2
a280 1

d282 1
a282 1
      bu_log ("object %d = %s\n", i, objs[i]);
d298 3
d333 2
a334 1
      bu_log ("occlusion mode = %d\n", occlusion_mode);
d382 10
d446 1
a446 2

  
d790 1
a790 1
  LOCAL int                     oc = 0;
d855 7
a861 7
    left.c_ishit    = saved[cpu].c_ishit;
    left.c_id = saved[cpu].c_id;
    left.c_dist = saved[cpu].c_dist;
    left.c_region = saved[cpu].c_region;
    VMOVE (left.c_rdir, saved[cpu].c_rdir);
    VMOVE (left.c_hit, saved[cpu].c_hit);
    VMOVE (left.c_normal, saved[cpu].c_normal);
d871 2
d874 1
a874 1
  if (me.c_ishit) {
a882 2
   * 
   * 
d927 7
a933 7
  saved[cpu].c_ishit = me.c_ishit;
  saved[cpu].c_id = me.c_id;
  saved[cpu].c_dist = me.c_dist;
  saved[cpu].c_region = me.c_region;
  VMOVE (saved[cpu].c_rdir, me.c_rdir);
  VMOVE (saved[cpu].c_hit, me.c_hit);
  VMOVE (saved[cpu].c_normal, me.c_normal);
d991 1
a991 1
  return(1);		
d997 1
a997 1
  return(1);		
d1005 1
a1014 1
  rt_shootray (occlusion_apps[cpu]);
d1016 11
a1026 1
  if (occlusion_apps[cpu]->a_dist <= here->c_dist) {
d1033 1
a1033 1
      return 0; 
d1037 13
@


11.14
log
@-* fixed occlusion testing
-* will be version 1.0
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.12 2001/06/25 13:24:58 rbowers Exp $ (BRL)";
a995 2

  //    configure ray/ap;
d999 1
a999 1
  //    shoot;
d1001 1
a1001 1
  //    compare;
@


11.13
log
@-* fixed occlusion check
@
text
@d65 1
a65 1
static unsigned char *edges[MAX_PSW];
d68 2
d129 1
a129 1
 * Interlay Mode
d131 1
a131 1
 * This is really cool! Interlay allows the user to specify a second
d135 16
a150 6
struct bu_vls interlay_objects;
int interlay = 0;
struct rt_i *inter_rtip = NULL;
struct application **inter_apps;
static int inter_hit (struct application *, struct partition *, struct seg *);
static int inter_miss (struct application *);
d215 1
a215 1
  {"%S", 1, "interlay", byteoffset(interlay_objects), 
d217 1
a217 1
  {"%S", 1, "in", byteoffset(interlay_objects), 
d219 3
d261 1
a261 1
   * Does the user want interlay?
d265 1
a265 1
  if (bu_vls_strlen(&interlay_objects) != 0) {
d274 1
a274 1
    if (Tcl_SplitList (NULL, bu_vls_addr (&interlay_objects), &nObjs, 
d276 1
a276 1
      bu_bomb ("rtedge: could not parse interlay objects list.\n");
d290 2
a291 13
    
    inter_rtip = rt_new_rti( dbip );		/* clones dbip */
    db_close(dbip);				/* releases original dbip */

    /*
     *if ((inter_rtip = rt_dirbuild(file, idbuf, sizeof(idbuf))) == RTI_NULL) {
     *bu_log ("rtedge: dirbuild failed for auxillary file %s.\n",
     *ap->a_rt_i->rti_dbip->dbi_filename);
     *bu_bomb ("rtedge: goodbye!\n");
     *}
    */

    bu_log ("rtedge: occlusion rt_dirbuild done.\n");
d294 1
a294 1
      if (rt_gettree (inter_rtip, objs[i]) < 0) {
d301 1
a301 1
    rt_prep (inter_rtip);
d306 1
a306 1
     * Create a set of application structures for the interlay
d310 2
a311 2
    inter_apps = bu_calloc (npsw, sizeof(struct application *), 
			    "interlay application structure array");
d313 2
a314 2
      inter_apps[i] = bu_calloc (1, sizeof(struct application), 
				 "inter application structure");
d316 4
a319 4
      inter_apps[i]->a_rt_i = inter_rtip;
      inter_apps[i]->a_onehit = 1;
      inter_apps[i]->a_hit = inter_hit;
      inter_apps[i]->a_miss = inter_miss;
a321 1
    interlay = 1;
d323 9
d380 3
a382 3
    if (edges[i] == NULL) {
      edges[i] = (unsigned char *) bu_calloc( 1, per_processor_chunk, 
					      "edges buffer" );
d413 2
a414 3
      bu_log ("rt_edge: specified framebuffer is not readable, cannot merge.\n");
      overlay = 0;
      blend = 0;
d416 13
a428 13
    
    /*
     * If blending is desired, create scanline buffers to hold
     * the read-in lines from the framebuffer.
     */
    if (blend) {
      for (i = 0; i < npsw; ++i) {
	if (blendline[i] == NULL) {
	  blendline[i] = (unsigned char *) bu_calloc( per_processor_chunk, 
						      pixsize, 
						      "blend buffer" );
	}	
      }
d432 20
d475 1
a475 1
      if (edges[cpu][i]) {
d509 1
a509 1
      if (edges[cpu][i]) {
d719 1
a719 2
  int could_be = 0;
  int cpu = ap->a_resource->re_cpu;	
d721 11
a731 12

  if( here->c_id == -1 && left->c_id == -1 && below->c_id == -1) {
    /*
     * All misses - catches condtions that would be bad later.
     */
    return 0;
  }
  
  if (detect_ids) {
    if (here->c_id != -1 &&
	(here->c_id != left->c_id || here->c_id != below->c_id)) {
      could_be = 1;
a732 1
  }
d734 5
a738 5
  if (detect_regions) {
    if (here->c_region != 0 &&
	(here->c_region != left->c_region
	 || here->c_region != below->c_region)) {
      could_be = 1;
d740 6
a745 6
  }
  
  if (detect_distance) {
    if (Abs(here->c_dist - left->c_dist) > max_dist ||
	Abs(here->c_dist - below->c_dist) > max_dist) {
      could_be = 1;
d748 3
a750 5

  if (detect_normals) {
    if ((VDOT(here->c_normal, left->c_normal) < COSTOL) ||
	(VDOT(here->c_normal, below->c_normal)< COSTOL)) {
      could_be = 1;	
d754 1
a754 27
  if (could_be && interlay) {
    bu_log ("is_edge: performing occlusion test.\n");

    /*
     * Test the hit distance on the second geometry.
     * If the second geometry is closer, do not
     * color pixel
     */

    //    configure ray/ap;
    inter_apps[cpu]->a_resource = ap->a_resource;
    VMOVE (inter_apps[cpu]->a_ray.r_pt, ap->a_ray.r_pt);
    VMOVE (inter_apps[cpu]->a_ray.r_dir, ap->a_ray.r_dir);
    //    shoot;
    bu_log ("is_edge: shooting.\n");
    rt_shootray (inter_apps[cpu]);
    //    compare;
    if (inter_apps[cpu]->a_dist <= here->c_dist) {
      /* 
       * The second geometry is close than the edge, therefore it
       * is 'foreground'. Do not draw the edge.
       */
      could_be = 0; 
    }    
  }

  return could_be;
d774 1
a774 1
  LOCAL int			edge;
d776 3
a778 2
  
  static struct cell            saved[MAX_PSW];
d804 1
a804 1
    me.c_ishit    = 0;
d851 6
a856 2
   * Finally, compare the values. If they differ, record this
   * point as lying on an edge.
d858 39
a896 8
  if (is_edge (ap, &me, &left, &below)) {
    RGBpixel col;
    
    /*
     * Don't test.
     */
    edges[cpu][ap->a_x] = 1;
    
d902 1
a902 1
    edge = 1;
d904 1
a904 2
    edges[cpu][ap->a_x] = 0;

a907 2

    edge = 0;
d925 1
a925 1
  bu_vls_init(&interlay_objects);
d971 1
a971 1
static int inter_hit (struct application *ap, struct partition *pt, 
d980 1
a980 1
static int inter_miss (struct application *ap)
d983 1
a983 1
  return(0);		
d985 48
@


11.12
log
@-* began work on occlusion checking.
-* added left-pixel reuse. performance up about 30%
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.11 2001/06/22 12:30:44 rbowers Exp $ (BRL)";
d729 2
d739 1
d742 1
a892 1
  RT_G_DEBUG |= DEBUG_DB;
d950 1
a950 1
  return(1);		
@


11.11
log
@-* Added per-cpu array of "pixel-is-an-edge" flags. These flags are used
   to control the fb_writes in overlay and blend modes. The old method
   of deciding whether to record or not--by comparing fg and bg--has been
   eliminated. The old method did not work reliably. It required the user
   to set the bg color manually when the extant framebuffer bg was not
   1/1/1.
@
text
@d23 1
a23 2
 *	All rights reserved.
 */
d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.10 2001/06/20 20:56:42 rbowers Exp $ (BRL)";
d91 1
d111 2
d117 6
a122 1
 *
d127 14
d194 2
a195 2
  {"%d", 3, "background", byteoffset(background),	BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "bg", byteoffset(background),	BU_STRUCTPARSE_FUNC_NULL},	
d200 2
a201 1
  {"%d", 1, "regcol", byteoffset(region_colors), BU_STRUCTPARSE_FUNC_NULL},
d203 4
d244 78
a321 1
  
d330 8
a339 5
  /*
   * The overlay and blend cannot be used in -o mode.
   * Note that the overlay directive takes precendence, they
   * can't be used together.
   */
d688 4
a691 1
  
d702 1
a702 1
      return 1;
d710 1
a710 1
      return 1;
d717 1
a717 1
      return 1;
d724 1
a724 1
      return 1;	
d728 23
a750 1
  return 0;
d773 2
d806 1
a806 1
		  pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);	    		
d810 1
a810 1
   * Now, fire a ray for both the cell below and the
d824 20
a843 4
  VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dx_model); /* left */
  VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
  a2.a_uptr = (genptr_t)&left;
  rt_shootray(&a2);
d851 4
a854 1

d856 1
a856 1

d872 12
d887 4
a890 1
void application_init () { }
d935 8
d944 5
a948 12












@


11.10
log
@-* added blend mode. when writing into an existing fb, will try to make the
   edge line blend into the picture through some hsv magic. sorta like a
   tv network "bug". doesn't work very well yet.

-* added region color mode. edge colors are determined by the region material
   color. if an edge is between two or more regions, the nearer (lower hit
   dist) one is used.
@
text
@d26 1
a26 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.9 2001/05/31 15:28:53 rbowers Exp $ (BRL)";
d66 1
d257 11
a267 1
  
d338 1
a338 3
      if (scanline[cpu][i*3+RED] != background[RED] &&
	  scanline[cpu][i*3+GRN] != background[GRN] &&
	  scanline[cpu][i*3+BLU] != background[BLU]) {
d372 1
a372 3
      if (scanline[cpu][i*3+RED] == foreground[RED] &&
	  scanline[cpu][i*3+GRN] == foreground[GRN] &&
	  scanline[cpu][i*3+BLU] == foreground[BLU]) {
d702 3
a704 1
    
d712 2
d717 1
@


11.9
log
@
*- added overlay mode. When operating in overlay mode ( -c "set ov=1")
   rtedge will place edge pixels in an existing framebuffer. Non-edge
   pixels are not written. Thus, "highlighted" images can created without
   using pixmerge.
*- changed default background from {0,0,0} to cad standard {0,0,1}.
@
text
@d12 1
a12 1
 *  XXX - Get parallel processing working.
d26 1
a26 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.8 2001/05/16 21:38:19 morrison Exp $ (BRL)";
d63 1
a63 1
#define MISS_DIST	-1
d67 2
d71 4
a74 2
fastf_t		max_dist;	/* min. distance for drawing pits/mountains */
fastf_t		maxangle;	/* value of the cosine of the angle bet. surface normals that triggers shading */
d92 2
d104 15
d127 5
a131 1
static int handle_main_ray(struct application *, struct partition *, struct seg *);
d133 2
a134 2
#define COSTOL          0.91    /* normals differ if dot product < COSTOL */
#define OBLTOL          0.1     /* high obliquity if cosine of angle < OBLTOL ! */
d152 1
a152 1
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
d155 1
a155 1
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
d162 19
a180 15
	{"%d", 1, "detect_regions", byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 1, "dr", byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 1, "detect_distance", byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 1, "dd", byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 1, "detect_normals", byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 1, "dn", byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 1, "detect_ids", byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 1, "di", byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 3, "foreground", byteoffset(foreground), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 3, "fg", byteoffset(foreground), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 3, "background", byteoffset(background),	BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 3, "bg", byteoffset(background),	BU_STRUCTPARSE_FUNC_NULL},	
	{"%d", 1, "overlay", byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
	{"%d", 1, "ov", byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
	{"",	0, (char *)0,	0,	BU_STRUCTPARSE_FUNC_NULL }
d201 1
a201 1
 -c                 Auxillary commands\n";
d211 8
d220 3
a222 1
     *  Allocate a scanline for each processor.
d224 17
a240 16
    ap->a_hit = rayhit;
    ap->a_miss = raymiss;
    ap->a_onehit = 1;

    if( minus_o ) {
	/*
	 * Output is to a file stream.
	 * Do not open a framebuffer, do not allow parallel
	 * processing since we can't seek to the rows.
	 */
	rt_g.rtg_parallel = 0;
	bu_log ("view_init: deactivating parallelism due to minus_o.\n");
	return(0);
    }

    return(1);		/* we need a framebuffer */
d247 1
a247 9
    int i;

    /*
     * Per_processor_chuck specifies the number of pixels rendered
     * per each pass of a worker. By making this value equal to the
     * width of the image, each worker will render one scanline at
     * a time.
     */
    per_processor_chunk = width;
d249 40
d290 2
a291 1
     * Use three bytes per pixel.
d293 6
a298 9
    pixsize = 3;

    /*
     * Create a buffer for each scanline.
     */
    for ( i = 0; i < npsw; ++i ) {
	if (scanline[i] == NULL) {
	    scanline[i] = (unsigned char *)
		bu_malloc( per_processor_chunk*pixsize, "scanline buffer" );
d300 1
d302 1
d304 1
a304 17
    /*
     * Set the hit distance difference necessary to trigger an edge.
     * This algorythm stolen from lgt, I may make it settable later.
     */
    max_dist = (cell_width*ARCTAN_87)+2;

    /*
     * Determine if the framebuffer is readable.
     */
    if (overlay == 1) {
      RGBpixel tmp;
      
      if (fb_read(fbp,0,0,tmp,1) < 0) {
	bu_log ("rt_edge: framebuffer is not readable, cannot overlay.\n");
	overlay = 0;
      }
    }
d310 5
a314 1
/* end of each line */
d318 2
a319 1
    int		cpu = ap->a_resource->re_cpu;
d321 121
a441 9
    bu_semaphore_acquire( BU_SEM_SYSCALL );
    if (overlay) {
      int i;
      for (i = 0; i < per_processor_chunk; ++i) {
	if (scanline[cpu][i*3+RED] == foreground[RED] &&
	    scanline[cpu][i*3+GRN] == foreground[GRN] &&
	    scanline[cpu][i*3+BLU] == foreground[BLU]) {
	  /*
	   * Write this pixel
d443 15
a457 1
	  fb_write(fbp, i, ap->a_y, &scanline[cpu][i*3], 1);	  
d459 32
a490 11
      }
    } 
    else {
      if( outfp != NULL ) {
	fwrite( scanline[cpu], pixsize, per_processor_chunk, outfp );
      } 
      else if( fbp != FBIO_NULL ) {
	fb_write( fbp, 0, ap->a_y, scanline[cpu], per_processor_chunk );
      }
    }
    bu_semaphore_release( BU_SEM_SYSCALL );
d573 1
a573 1
    struct cell *left, struct cell *below)
d575 39
a614 6
    if( here->c_id == -1 && left->c_id == -1 && below->c_id == -1) {
	/*
	 * All misses - catches condtions that would be bad later.
	 */
	return 0;
    }
d616 4
a619 6
    if (detect_ids) {
        if (here->c_id != -1 &&
            (here->c_id != left->c_id || here->c_id != below->c_id)) {
	    return 1;
        }
    }
d621 89
a709 7
    if (detect_regions) {
        if (here->c_region != 0 &&
            (here->c_region != left->c_region
            || here->c_region != below->c_region)) {
	    return 1;
        }
    }
d711 1
a711 6
    if (detect_distance) {
        if (Abs(here->c_dist - left->c_dist) > max_dist ||
	    Abs(here->c_dist - below->c_dist) > max_dist) {
	    return 1;
        }
    }
a712 6
    if (detect_normals) {
    	if ((VDOT(here->c_normal, left->c_normal) < COSTOL) ||
	    (VDOT(here->c_normal, below->c_normal)< COSTOL)) {
	     return 1;	
        }
    }
d714 6
a719 1
    return 0;
a721 1

d723 1
a723 1
 *			H A N D L E _ M A I N _ R A Y
d726 14
d741 10
a750 45
int
handle_main_ray( struct application *ap, register struct partition *PartHeadp,
	struct seg *segp )
{
	register struct partition *pp;
	register struct hit	*hitp;		/* which hit */
	
	LOCAL struct application	a2;
	LOCAL struct cell		me;
	LOCAL struct cell		below;
	LOCAL struct cell		left;
	LOCAL int			edge;
	LOCAL int			cpu;	

	memset(&a2, 0, sizeof(struct application));
	memset(&me, 0, sizeof(struct cell));
	memset(&below, 0, sizeof(struct cell));
	memset(&left, 0, sizeof(struct cell));
	
	cpu = ap->a_resource->re_cpu;	
	
	if (PartHeadp == NULL) {
	    /* The main shotline missed.
	     * pack the application struct
	     */
	    me.c_ishit    = 0;
	    me.c_dist   = MISS_DIST;
    	    me.c_id	    = MISS_ID;	
            VSETALL(me.c_hit, MISS_DIST);
            VSETALL(me.c_normal, 0);
            VMOVE(me.c_rdir, ap->a_ray.r_dir);
	} else {
	     pp = PartHeadp->pt_forw;
	     hitp = pp->pt_inhit;	
            /*
	     * Stuff the information for this cell.
	     */
	    me.c_ishit    = 0;
	    me.c_id = pp->pt_regionp->reg_regionid;
	    me.c_dist = hitp->hit_dist;
	    VMOVE(me.c_rdir, ap->a_ray.r_dir);
	    VJOIN1(me.c_hit, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
	    RT_HIT_NORMAL(me.c_normal, hitp,
	        pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);	    		
	}
d752 2
a753 40
	/*
	 * Now, fire a ray for both the cell below and the
	 * cell to the left.
	 */
	a2.a_hit = rayhit2;
	a2.a_miss = raymiss2;
	a2.a_onehit = 1;
	a2.a_rt_i = ap->a_rt_i;
	a2.a_resource = ap->a_resource;
	
	VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dy_model); /* below */
	VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
	a2.a_uptr = (genptr_t)&below;
        rt_shootray(&a2);
	
	VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dx_model); /* left */
	VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
	a2.a_uptr = (genptr_t)&left;
        rt_shootray(&a2);
	
	/*
	 * Finally, compare the values. If they differ, record this
	 * point as lying on an edge.
	 */
	if (is_edge (ap, &me, &left, &below)) {
	    bu_semaphore_acquire (RT_SEM_RESULTS);	
	    	scanline[cpu][ap->a_x*3+RED] = foreground[RED];
		scanline[cpu][ap->a_x*3+GRN] = foreground[GRN];
		scanline[cpu][ap->a_x*3+BLU] = foreground[BLU];
	    bu_semaphore_release (RT_SEM_RESULTS);
	    edge = 1;
	} else {
	    bu_semaphore_acquire (RT_SEM_RESULTS);
	       	scanline[cpu][ap->a_x*3+RED] = background[RED];
		scanline[cpu][ap->a_x*3+GRN] = background[GRN];
		scanline[cpu][ap->a_x*3+BLU] = background[BLU];
	    bu_semaphore_release (RT_SEM_RESULTS);
	    edge = 0;
	}
	return edge;
d756 14
a769 1
void application_init () { }
@


11.8
log
@PRODUCTION optimizations
@
text
@d26 1
a26 1
static const char RCSviewedge[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewedge.c,v 11.7 2001/03/23 21:26:54 rbowers Exp $ (BRL)";
d74 1
a74 1
color	background = { 0, 0, 0};
d89 9
d149 2
d171 3
a173 1
 -R                 Do not report overlaps\n";
d238 11
d261 10
a270 4
	if( outfp != NULL ) {
	    fwrite( scanline[cpu], pixsize, per_processor_chunk, outfp );
	} else if( fbp != FBIO_NULL ) {
	    fb_write( fbp, 0, ap->a_y, scanline[cpu], per_processor_chunk );
d272 10
@


11.7
log
@Version 0.99!

Added these capabilities:
    Set foreground color
    Set background color
    Toggle id test, region test, distance test, normal test.
@
text
@d26 1
a26 1
static const char RCSviewedge[] = "@@(#)$Header: /d/CVS/brlcad/rt/viewedge.c,v 11.6 2001/03/21 22:32:15 rbowers Exp $ (BRL)";
d387 4
a390 4
	bzero (&a2, sizeof(struct application));
	bzero (&me, sizeof(struct cell));
	bzero (&below, sizeof(struct cell));
	bzero (&left, sizeof(struct cell));
@


11.6
log
@version 0.8! woo hoo
@
text
@d26 1
a26 1
static const char RCSviewedge[] = "@@(#)$Header: /d/CVS/brlcad/rt/viewedge.c,v 11.3 2001/03/20 21:55:55 rbowers Exp $ (BRL)";
a47 1
extern	double	AmbientIntensity;	/* XXX - temp hack for contrast! */
d54 7
a60 6
        int	c_ishit;
	fastf_t	c_dist;			/* distance from emanation plane to in_hit */
	int	c_id;			/* region_id of component hit */
	point_t	c_hit;			/* 3-space hit point of ray */
	vect_t	c_normal;		/* surface normal at the hit point */
	vect_t	c_rdir;			/* ray direction, permits perspective */
d69 2
a70 2
fastf_t		pit_depth;		/* min. distance for drawing pits/mountains */
fastf_t		maxangle;		/* value of the cosine of the angle bet. surface normals that triggers shading */
d72 21
d99 4
d108 18
d128 12
a147 1
 -A angle           Angle between surface normals (default=5degrees)\n\
d151 1
a151 1
h -M                 Read matrix+cmds on stdin\n\
a175 2
    per_processor_chunk = width;

a194 2
    register struct region *rp;
    register struct rt_i *rtip = ap->a_rt_i;
d196 16
a211 1
    pixsize = 3;		/* Frame buffer */
d218 7
a224 4
	
    for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
        rp->reg_udata = (genptr_t) NULL;
    }
d294 3
a296 2
    c->c_ishit = 1;
    c->c_id = pp->pt_regionp->reg_regionid;
d313 4
a316 3
    c->c_ishit    = 0;
    c->c_dist   = MISS_DIST;
    c->c_id	    = MISS_ID;	
a323 6

#define COSTOL          0.91    /* normals differ if dot product < COSTOL */
#define OBLTOL          0.1     /* high obliquity if cosine of angle < OBLTOL ! */
#define is_Odd(_a)      ((_a)&01)
#define ARCTAN_87       19.08

a326 1
    fastf_t  max_dist = (cell_width*ARCTAN_87)+2;
d335 13
a347 3
    if (here->c_id != -1 &&
        (here->c_id != left->c_id || here->c_id != below->c_id)) {
	return 1;
d350 5
a354 3
    if ( Abs(here->c_dist - left->c_dist) > max_dist ||
	 Abs(here->c_dist - below->c_dist) > max_dist) {
	return 1;
d357 5
a361 3
    if ((VDOT(here->c_normal, left->c_normal) < COSTOL) ||
	(VDOT(here->c_normal, below->c_normal)< COSTOL)) {
	return 1;	
d445 3
a447 3
	    	scanline[cpu][ap->a_x*3+RED] = 255;
		scanline[cpu][ap->a_x*3+GRN] = 255;
		scanline[cpu][ap->a_x*3+BLU] = 255;
d452 3
a454 3
	       	scanline[cpu][ap->a_x*3+RED] = 0;
		scanline[cpu][ap->a_x*3+GRN] = 0;
		scanline[cpu][ap->a_x*3+BLU] = 0;
@


11.5
log
@Disallowed parallel processing when using -o option. The user
should use the -Ffilename instead.
@
text
@d50 1
a66 1

d97 1
a97 1
 -M                 Read matrix+cmds on stdin\n\
d113 1
a113 4
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
int minus_o;
d115 8
a122 3
	int i;
	
	pixsize = 3;		/* Frame buffer */
d124 1
d126 3
a128 1
	 *  Allocate a scanline for each processor.
d130 6
a135 18
	for ( i = 0; i < npsw; ++i ) {
	    if (scanline[i] == NULL) {
	        scanline[i] = (unsigned char *)
			bu_malloc( width*pixsize, "scanline buffer" );
	    }	
	}
	
	if( minus_o ) {
	    /*
	     * Output is to a file stream.
	     * Do not open a framebuffer, do not allow parallel
	     * processing since we can't seek to the rows.
	     */
	    rt_g.rtg_parallel = 0;
	    return(0);
	}
	
	return(1);		/* we need a framebuffer */
d140 1
a140 3
view_2init( ap, framename )
struct application *ap;
char *framename;
d142 15
a156 3
	ap->a_hit = rayhit;
	ap->a_miss = raymiss;
	ap->a_onehit = 1;
d160 1
a160 5
void
view_pixel( ap )
register struct application *ap;
{
}
d164 1
a164 2
view_eol( ap )
register struct application *ap;
d170 1
a170 1
	    fwrite( scanline[cpu], pixsize, width, outfp );
d172 1
a172 1
	    fb_write( fbp, 0, ap->a_y, scanline[cpu], width );
d177 1
a177 11
void	view_setup() {}
/* end of a frame, called after rt_clean() */
void	view_cleanup() {}

/* end of each frame */
void
view_end()
{

}

d179 4
d184 4
d192 1
a192 2
int
rayhit (struct application *ap, register struct partition *PartHeadp,
d195 6
a200 7
	if ( handle_main_ray(ap, PartHeadp,segp)) {
	    ap->a_user = 1;
	} else {
	    ap->a_user = 0;
	}
	
	return 1;
d206 1
a206 2
int
raymiss( register struct application *ap )
d208 6
a213 7
	if ( handle_main_ray(ap, NULL, NULL)) {
	    ap->a_user = 1;
	} else {
	    ap->a_user = 0;
	}
	
	return 1;	
d219 1
a219 2
int
rayhit2 (struct application *ap, register struct partition *PartHeadp,
d222 3
a224 3
    struct partition	*pp = PartHeadp->pt_forw;
    struct hit		*hitp = PartHeadp->pt_forw->pt_inhit;
    struct cell *c = (struct cell *)ap->a_uptr;
d233 1
d240 1
a240 2
int
raymiss2( register struct application *ap )
d243 1
d250 2
a251 1
    return(1);
d260 2
a261 2
int
is_edge(struct cell *here, struct cell *left, struct cell *below)
d278 1
a278 1
	 Abs(here->c_dist - below->c_dist) > max_dist) {	
d350 1
d366 1
a366 1
	if (is_edge (&me, &left, &below)) {
d372 1
d379 1
d384 1
a384 6
void application_init () {




}
@


11.4
log
@Added parallel processing capability.
@
text
@d119 1
a119 10
	/*
	 *  We need to work to get the output pixels and scanlines
	 *  in order before we can run in parallel.  Something like
	 *  view.c does in its dynamic buffering mode.
	 */
	if (rt_g.rtg_parallel) {
		rt_g.rtg_parallel = 0;
		bu_log("rtxray: Can't do parallel yet, using one CPU\n");
	}

d133 7
a139 2
		/* output is to a file */
		return(0);		/* don't open frame buffer */
@


11.3
log
@Tweaked the edge detection logic.
@
text
@d2 1
a2 1
  *			V I E W E D G E
d12 3
d26 1
a26 1
static const char RCSviewedge[] = "@@(#)$Header: /d/CVS/brlcad/rt/viewedge.c,v 0.1 2000/08/17 02:41:42 mike Exp $ (BRL)";
d55 1
a55 1
	double	c_dist;			/* distance from emanation plane to in_hit */
d65 2
a66 1
static unsigned char *scanline;
d118 1
d130 7
a136 4
	
	
	if( pixsize ) {
		scanline = (unsigned char *)
d138 1
d140 1
a140 1

d172 2
d176 1
a176 1
	    fwrite( scanline, pixsize, width, outfp );
d178 1
a178 1
	    fb_write( fbp, 0, ap->a_y, scanline, width );
d274 1
a274 1
    double  max_dist = (cell_width*ARCTAN_87)+2;
d318 2
a319 1
	LOCAL int			edge;	
d324 3
a326 1
	bzero (&left, sizeof(struct cell));	
d378 3
a380 3
	    	scanline[ap->a_x*3+RED] = 255;
		scanline[ap->a_x*3+GRN] = 255;
		scanline[ap->a_x*3+BLU] = 255;
d384 3
a386 3
	       	scanline[ap->a_x*3+RED] = 0;
		scanline[ap->a_x*3+GRN] = 0;
		scanline[ap->a_x*3+BLU] = 0;
@


11.2
log
@Changed pixel color to white.
@
text
@d272 2
a273 1
    if ( here->c_id != left->c_id || here->c_id != below->c_id) {
@


11.1
log
@Added viewedge.c. Viewedge is the bottom half for rtedge. rtedge is
a renderer that produces lgt-style hidden line drawings that align
with other rt* results (e.g. images from rt).
@
text
@d363 3
a365 3
	    	scanline[ap->a_x*3+RED] = 0;
		scanline[ap->a_x*3+GRN] = 0;
		scanline[ap->a_x*3+BLU] = 200;
d377 6
a382 1
void application_init () {}
@

