head	11.47;
access;
symbols
	ansi-20040405-merged:11.37.2.2
	postmerge-20040405-ansi:11.45
	premerge-20040404-ansi:11.44
	postmerge-autoconf:11.44
	autoconf-freeze:11.40.2.3
	premerge-autoconf:11.44
	postmerge-20040315-windows:11.44
	premerge-20040315-windows:11.44
	windows-20040315-freeze:11.37.4.1
	autoconf-20031203:11.40.2.1
	autoconf-20031202:11.40
	autoconf-branch:11.40.0.2
	phong-branch:11.38.0.2
	photonmap-branch:11.37.0.6
	rel-6-1-DP:11.37
	windows-branch:11.37.0.4
	rel-6-0-2:11.35
	ansi-branch:11.37.0.2
	rel-6-0-1-branch:11.35.0.2
	hartley-6-0-post:11.36
	hartley-6-0-pre:11.35
	rel-6-0-1:11.35
	rel-6-0:11.34
	rel-5-4:11.28
	offsite-5-3-pre:11.32
	rel-5-3:11.28
	rel-5-2:11.28
	rel-5-1-branch:11.28.0.2
	rel-5-1:11.28
	rel-5-0:11.23
	rel-5-0-beta:11.23
	rel-4-5:11.16
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.47
date	2004.05.21.17.31.11;	author morrison;	state dead;
branches;
next	11.46;

11.46
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.45;

11.45
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	11.44;

11.44
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.43;

11.43
date	2004.01.15.01.32.13;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	2003.10.29.15.56.01;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	2003.10.28.16.32.05;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	2003.10.07.01.23.30;	author morrison;	state Exp;
branches
	11.40.2.1;
next	11.39;

11.39
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2003.09.05.15.21.46;	author justin;	state Exp;
branches;
next	11.37;

11.37
date	2002.08.20.17.08.40;	author jra;	state Exp;
branches
	11.37.2.1
	11.37.4.1;
next	11.36;

11.36
date	2002.08.15.20.55.51;	author hartley;	state Exp;
branches;
next	11.35;

11.35
date	2002.04.05.14.06.00;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	2001.04.02.21.38.31;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2001.03.31.01.57.32;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2000.10.19.19.19.47;	author butler;	state Exp;
branches;
next	11.31;

11.31
date	2000.08.17.02.41.43;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.07.27.19.32.53;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	2000.07.25.16.39.49;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	2000.03.08.06.37.03;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.02.04.09.38.11;	author butler;	state Exp;
branches;
next	11.26;

11.26
date	99.11.16.01.13.09;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	99.11.13.05.28.58;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	99.10.30.03.06.27;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	99.05.28.01.17.27;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.01.25.05.29.57;	author butler;	state Exp;
branches;
next	11.21;

11.21
date	98.06.03.05.10.12;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	98.05.13.02.41.03;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	98.05.12.22.52.09;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	98.05.06.04.40.45;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	98.04.15.05.13.15;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.01.23.02.01.31;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	97.12.04.06.20.25;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.11.14.04.43.09;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.11.14.02.51.43;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.11.14.02.04.35;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.11.14.02.03.25;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	97.08.26.06.49.04;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	97.03.07.06.16.06;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.03.07.06.12.28;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.12.31.00.16.34;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.08.29.02.11.21;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.07.29.22.17.07;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.03.18.00.50.31;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.03.18.00.48.32;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.18.00.09.05;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.34;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.08.11.02.48.14;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.05.07.21.16.11;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.05.07.20.49.09;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.05.06.02.59.19;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.05.05.23.00.11;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.04.05.21.18.53;	author phil;	state Exp;
branches;
next	10.2;

10.2
date	92.10.27.16.03.32;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.27;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.10.12.04.44.09;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.10.01.02.44.09;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.06.23.00.21.34;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.06.22.06.27.00;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.06.19.00.08.44;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.10.06.02.48.13;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.11.20.16.58.12;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.00.05;	author mike;	state Rel3_5;
branches;
next	8.8;

8.8
date	89.04.30.21.26.11;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.14.14.10.22;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.04.13.05.02.37;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.03.20.49.31;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.03.19.53.53;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	88.12.28.22.49.15;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.23.05.00.57;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.46;	author mike;	state Rel3_0;
branches;
next	7.10;

7.10
date	88.09.17.06.14.09;	author mike;	state Exp;
branches;
next	7.9;

7.9
date	88.08.20.07.18.37;	author phil;	state Exp;
branches;
next	7.8;

7.8
date	88.08.09.17.53.22;	author phil;	state Exp;
branches;
next	7.7;

7.7
date	88.06.16.02.49.36;	author phil;	state Exp;
branches;
next	7.6;

7.6
date	88.05.14.02.28.50;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.01.27.07.01.27;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.01.25.23.40.14;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.01.22.21.05.56;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	88.01.15.14.52.26;	author stay;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.57.00;	author mike;	state Rel;
branches;
next	6.4;

6.4
date	87.10.14.20.49.57;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.09.26.07.57.21;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.03.01.30.50;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.59.47;	author mike;	state Rel;
branches;
next	5.5;

5.5
date	87.07.10.07.27.43;	author mike;	state Exp;
branches;
next	5.4;

5.4
date	87.07.09.03.31.36;	author mike;	state Exp;
branches;
next	5.3;

5.3
date	87.07.06.15.08.39;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.25.22.29.58;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.15.53;	author mike;	state Rel;
branches;
next	4.7;

4.7
date	87.05.30.07.05.03;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.04.10.07.03.48;	author mike;	state Exp;
branches;
next	4.5;

4.5
date	87.03.25.17.28.36;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.03.17.20.19.28;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.13.05.11.03;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.03.17;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.49.07;	author mike;	state Rel1;
branches;
next	1.9;

1.9
date	86.12.29.01.55.02;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.12.24.08.31.21;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.12.18.16.07.04;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.12.05.16.11.37;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.11.25.04.32.44;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.10.31.04.36.26;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.10.29.01.32.30;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.10.28.23.25.45;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.10.26.18.38.02;	author mike;	state Exp;
branches;
next	;

11.37.2.1
date	2002.09.19.18.02.17;	author morrison;	state Exp;
branches;
next	11.37.2.2;

11.37.2.2
date	2004.03.17.21.23.02;	author morrison;	state Exp;
branches;
next	;

11.37.4.1
date	2004.03.11.23.48.08;	author morrison;	state Exp;
branches;
next	;

11.40.2.1
date	2003.12.03.16.25.44;	author erikg;	state Exp;
branches;
next	11.40.2.2;

11.40.2.2
date	2004.02.12.19.37.14;	author erikg;	state Exp;
branches;
next	11.40.2.3;

11.40.2.3
date	2004.03.15.14.08.08;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to handle initialization of the grid,
and dispatch the first rays from the eye.
@


11.47
log
@moved to src/rt/
@
text
@/*
 *			W O R K E R . C
 *
 *  Routines to handle initialization of the grid,
 *  and dispatch of the first rays from the eye.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSworker[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/worker.c,v 11.46 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "./ext.h"
#include "rtprivate.h"
#include "fb.h"					/* Added because RGBpixel is now needed in do_pixel() */

/* for fork/pipe linux timing hack */
#if defined(linux)
#  include <sys/select.h>
#  include <sys/types.h>
#  include <sys/wait.h>
#  include <unistd.h>
#endif


int		per_processor_chunk = 0;	/* how many pixels to do at once */

fastf_t		gift_grid_rounding = 0;		/* set to 25.4 for inches */

point_t		viewbase_model;	/* model-space location of viewplane corner */

int			fullfloat_mode = 0;
int			reproject_mode = 0;
struct floatpixel	*curr_float_frame;	/* buffer of full frame */
struct floatpixel	*prev_float_frame;
int		reproj_cur;	/* number of pixels reprojected this frame */
int		reproj_max;	/* out of total number of pixels */

/* Local communication with worker() */
int cur_pixel;			/* current pixel number, 0..last_pixel */
int last_pixel;			/* last pixel number */

extern int		query_x;
extern int		query_y;
extern int		Query_one_pixel;
extern int		query_rdebug;
extern int		query_debug;

extern unsigned	char	*pixmap;		/* pixmap for rerendering of black pixels */

/*
 *			G R I D _ S E T U P
 *
 *  In theory, the grid can be specified by providing any two of
 *  these sets of parameters:
 *	number of pixels (width, height)
 *	viewsize (in model units, mm)
 *	number of grid cells (cell_width, cell_height)
 *  however, for now, it is required that the view size always be specified,
 *  and one or the other parameter be provided.
 */
void
grid_setup(void)
{
	vect_t temp;
	mat_t toEye;

	if( viewsize <= 0.0 )
		rt_bomb("viewsize <= 0");
	/* model2view takes us to eye_model location & orientation */
	MAT_IDN( toEye );
	MAT_DELTAS_VEC_NEG( toEye, eye_model );
	Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
	bn_mat_mul( model2view, Viewrotscale, toEye );
	bn_mat_inv( view2model, model2view );

	/* Determine grid cell size and number of pixels */
	if( cell_newsize ) {
		if( cell_width <= 0.0 ) cell_width = cell_height;
		if( cell_height <= 0.0 ) cell_height = cell_width;
		width = (viewsize / cell_width) + 0.99;
		height = (viewsize / (cell_height*aspect)) + 0.99;
		cell_newsize = 0;
	} else {
		/* Chop -1.0..+1.0 range into parts */
		cell_width = viewsize / width;
		cell_height = viewsize / (height*aspect);
	}

	/*
	 *  Optional GIFT compatabilty, mostly for RTG3.
	 *  Round coordinates of lower left corner to fall on integer-
	 *  valued coordinates, in "gift_grid_rounding" units.
	 */
	if( gift_grid_rounding > 0.0 )  {
		point_t		v_ll;		/* view, lower left */
		point_t		m_ll;		/* model, lower left */
		point_t		hv_ll;		/* hv, lower left*/
		point_t		hv_wanted;
		vect_t		hv_delta;
		vect_t		m_delta;
		mat_t		model2hv;
		mat_t		hv2model;

		/* Build model2hv matrix, including mm2inches conversion */
		MAT_COPY( model2hv, Viewrotscale );
		model2hv[15] = gift_grid_rounding;
		bn_mat_inv( hv2model, model2hv );

		VSET( v_ll, -1, -1, 0 );
		MAT4X3PNT( m_ll, view2model, v_ll );
		MAT4X3PNT( hv_ll, model2hv, m_ll );
		VSET( hv_wanted, floor(hv_ll[X]), floor(hv_ll[Y]),floor(hv_ll[Z]) );
		VSUB2( hv_delta, hv_ll, hv_wanted );

		MAT4X3PNT( m_delta, hv2model, hv_delta );
		VSUB2( eye_model, eye_model, m_delta );
		MAT_DELTAS_VEC_NEG( toEye, eye_model );
		bn_mat_mul( model2view, Viewrotscale, toEye );
		bn_mat_inv( view2model, model2view );
	}

	/* Create basis vectors dx and dy for emanation plane (grid) */
	VSET( temp, 1, 0, 0 );
	MAT3X3VEC( dx_unit, view2model, temp );	/* rotate only */
	VSCALE( dx_model, dx_unit, cell_width );

	VSET( temp, 0, 1, 0 );
	MAT3X3VEC( dy_unit, view2model, temp );	/* rotate only */
	VSCALE( dy_model, dy_unit, cell_height );

	if( stereo )  {
		/* Move left 2.5 inches (63.5mm) */
		VSET( temp, -63.5*2.0/viewsize, 0, 0 );
		bu_log("red eye: moving %f relative screen (left)\n", temp[X]);
		MAT4X3VEC( left_eye_delta, view2model, temp );
		VPRINT("left_eye_delta", left_eye_delta);
	}

	/* "Lower left" corner of viewing plane */
	if( rt_perspective > 0.0 )  {
		fastf_t	zoomout;
		zoomout = 1.0 / tan( bn_degtorad * rt_perspective / 2.0 );
		VSET( temp, -1, -1/aspect, -zoomout );	/* viewing plane */
		/*
		 * divergence is perspective angle divided by the number
		 * of pixels in that angle. Extra factor of 0.5 is because
		 * perspective is a full angle while divergence is the tangent
		 * (slope) of a half angle.
		 */
		ap.a_diverge = tan( bn_degtorad * rt_perspective * 0.5 / width );
		ap.a_rbeam = 0;
	}  else  {
		/* all rays go this direction */
		VSET( temp, 0, 0, -1 );
		MAT4X3VEC( ap.a_ray.r_dir, view2model, temp );
		VUNITIZE( ap.a_ray.r_dir );

		VSET( temp, -1, -1/aspect, 0 );	/* eye plane */
		ap.a_rbeam = 0.5 * viewsize / width;
		ap.a_diverge = 0;
	}
	if( NEAR_ZERO(ap.a_rbeam, SMALL) && NEAR_ZERO(ap.a_diverge, SMALL) )
		rt_bomb("zero-radius beam");
	MAT4X3PNT( viewbase_model, view2model, temp );

	if( jitter & JITTER_FRAME )  {
		/* Move the frame in a smooth circular rotation in the plane */
		fastf_t		ang;	/* radians */
		fastf_t		dx, dy;

		ang = curframe * frame_delta_t * bn_twopi / 10;	/* 10 sec period */
		dx = cos(ang) * 0.5;	/* +/- 1/4 pixel width in amplitude */
		dy = sin(ang) * 0.5;
		VJOIN2( viewbase_model, viewbase_model,
			dx, dx_model,
			dy, dy_model );
	}

	if( cell_width <= 0 || cell_width >= INFINITY ||
	    cell_height <= 0 || cell_height >= INFINITY )  {
		bu_log("grid_setup: cell size ERROR (%g, %g) mm\n",
			cell_width, cell_height );
	    	rt_bomb("cell size");
	}
	if( width <= 0 || height <= 0 )  {
		bu_log("grid_setup: ERROR bad image size (%d, %d)\n",
			width, height );
		rt_bomb("bad size");
	}
}


/*
 *			D O _ R U N
 *
 *  Compute a run of pixels, in parallel if the hardware permits it.
 *
 *  For a general-purpose version, see LIBRT rt_shoot_many_rays()
 */
void do_run( int a, int b )
{
	int		cpu;

	cur_pixel = a;
	last_pixel = b;

#  if defined(linux)
	int pid, wpid;
	int waitret;
	int p[2];
	void *buffer;
	struct resource *tmp_res;

	if( rt_g.rtg_parallel ) {
		buffer = calloc(npsw, sizeof(resource[0]));
		if (buffer == NULL) {
			perror("calloc failed");
			bu_bomb("Unable to allocate memory");
		}
		if (pipe(p) == -1) {
			perror("pipe failed");
		}
	}
#  endif


	if( !rt_g.rtg_parallel )  {
		/*
		 * SERIAL case -- one CPU does all the work.
		 */
		npsw = 1;
		worker(0, NULL);
	} else {
		/*
		 *  Parallel case.
		 */

		/* hack to bypass a bug in the Linux 2.4 kernel pthreads
		 * implementation. cpu statistics are only traceable on a
		 * process level and the timers will report effectively no
		 * elapsed cpu time.  this allows the stats of all threads
		 * to be gathered up by an encompassing process that may
		 * be timed.
		 *
		 * XXX this should somehow only apply to a build on a 2.4
		 * linux kernel.
		 */
#  if defined(linux)
		pid = fork();
		if (pid < 0) {
			perror("fork failed");
			exit(1);
		} else if (pid == 0) {
#  endif

			bu_parallel( worker, npsw, NULL );

#  if defined(linux)
			/* send raytrace instance data back to the parent */
			if (write(p[1], resource, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to write to the communication pipe");
				exit(1);
			}
			/* flush the pipe */
			if (close(p[1]) == -1) {
			  	perror("Unable to close the communication pipe");
			  	sleep(1); /* give the parent time to read */
			}
			exit(0); 
		} else {
			if (read(p[0], buffer, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to read from the communication pipe");
			}

			/* do not use the just read info to overwrite the resource structures.
			 * doing so will hose the resources completely
			 */

			/* parent ends up waiting on his child (and his child's threads) to
			 * terminate.  we can get valid usage statistics on a child process.
			 */
			while ((wpid = wait(&waitret)) != pid && wpid != -1)
				; /* do nothing */
		} /* end fork() */
#  endif

	} /* end parallel case */

#  if defined(linux )
	if( rt_g.rtg_parallel ) {
		tmp_res = (struct resource *)buffer;
	} else {
		tmp_res = resource;
	}
	for( cpu=0; cpu < npsw; cpu++ ) {
		if ( tmp_res[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &tmp_res[cpu] );
		rt_zero_res_stats( &resource[cpu] );
	}
#  else
	/* Tally up the statistics */
	for ( cpu=0; cpu < npsw; cpu++ ) {
		if ( resource[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &resource[cpu] );
	}
#endif
	return;
}

#define CRT_BLEND(v)	(0.26*(v)[X] + 0.66*(v)[Y] + 0.08*(v)[Z])
#define NTSC_BLEND(v)	(0.30*(v)[X] + 0.59*(v)[Y] + 0.11*(v)[Z])
int	stop_worker = 0;

/*
 * For certain hypersample values there is a particular advantage to subdividing
 * the pixel and shooting a ray in each sub-pixel.  This structure keeps track of
 * those patterns
 */
struct jitter_pattern {
	int   num_samples;/* number of samples, or coordinate pairs in coords[] */
	float rand_scale[2]; /* amount to scale bn_rand_half value */
	float coords[32]; /* center of each sub-pixel */
};

static struct jitter_pattern pt_pats[] = {

	{4, {0.5, 0.5}, 	/* -H 3 */
	 { 0.25, 0.25,
	   0.25, 0.75,
	   0.75, 0.25,
	   0.75, 0.75 } },

	{5, {0.4, 0.4}, 	/* -H 4 */
	 { 0.2, 0.2,
	   0.2, 0.8,
	   0.8, 0.2,
	   0.8, 0.8,
	   0.5, 0.5} },

	{9, {0.3333, 0.3333}, /* -H 8 */
	 { 0.17, 0.17,  0.17, 0.5,  0.17, 0.82,
	   0.5, 0.17,    0.5, 0.5,   0.5, 0.82,
	   0.82, 0.17,  0.82, 0.5,  0.82, 0.82 } },

	{16, {0.25, 0.25}, 	/* -H 15 */
	 { 0.125, 0.125,  0.125, 0.375, 0.125, 0.625, 0.125, 0.875,
	   0.375, 0.125,  0.375, 0.375, 0.375, 0.625, 0.375, 0.875,
	   0.625, 0.125,  0.625, 0.375, 0.625, 0.625, 0.625, 0.875,
	   0.875, 0.125,  0.875, 0.375, 0.875, 0.625, 0.875, 0.875} },

	{ 0, {0.0, 0.0}, {0.0} } /* must be here to stop search */
};

/***********************************************************************
 *
 *  compute_point
 *
 * Compute the origin for this ray, based upon the number of samples 
 * per pixel and the number of the current sample.  For certain 
 * ray-counts, it is highly advantageous to subdivide the pixel and 
 * fire each ray in a specific sub-section of the pixel.
 */
static void 
jitter_start_pt(vect_t point, struct application *a, int samplenum, int pat_num)
{
	FAST fastf_t dx, dy;

	if (pat_num >= 0) {
		dx = a->a_x + pt_pats[pat_num].coords[samplenum*2] +
			(bn_rand_half(a->a_resource->re_randptr) * 
			 pt_pats[pat_num].rand_scale[X] );
	
		dy = a->a_y + pt_pats[pat_num].coords[samplenum*2 + 1] +
			(bn_rand_half(a->a_resource->re_randptr) * 
			 pt_pats[pat_num].rand_scale[Y] );
	} else {
		dx = a->a_x + bn_rand_half(a->a_resource->re_randptr);
		dy = a->a_y + bn_rand_half(a->a_resource->re_randptr);
	}
	VJOIN2( point, viewbase_model, dx, dx_model, dy, dy_model );
}

void do_pixel(int cpu,
	      int pat_num,
	      int pixelnum)
{
	LOCAL	struct	application	a;
	LOCAL	struct	pixel_ext	pe;
	LOCAL	vect_t			point;		/* Ref point on eye or view plane */
	LOCAL	vect_t			colorsum;
	int				samplenum,i;
        unsigned	char		*pixel;


	/* Obtain fresh copy of global application struct */
	a = ap;				/* struct copy */
	a.a_resource = &resource[cpu];

	if( incr_mode )  {
		register int i = 1<<incr_level;
		a.a_x = pixelnum%i;
		a.a_y = pixelnum/i;
		if( incr_level != 0 )  {
			/* See if already done last pass */
			if( ((a.a_x & 1) == 0 ) &&
			    ((a.a_y & 1) == 0 ) )
				return;
		}
		a.a_x <<= (incr_nlevel-incr_level);
		a.a_y <<= (incr_nlevel-incr_level);
	} else {
		a.a_x = pixelnum%width;
		a.a_y = pixelnum/width;
	}

	if (Query_one_pixel) {
		if (a.a_x == query_x && a.a_y == query_y) {
			rdebug = query_rdebug;
			rt_g.debug = query_debug;
		} else {
			rt_g.debug = rdebug = 0;
		}
	}

	if( sub_grid_mode )  {
		if( a.a_x < sub_xmin || a.a_x > sub_xmax )
			return;
		if( a.a_y < sub_ymin || a.a_y > sub_ymax )
			return;
	}
	if( fullfloat_mode )  {
		register struct floatpixel	*fp;
		fp = &curr_float_frame[a.a_y*width + a.a_x];
		if( fp->ff_frame >= 0 )  {
			return;	/* pixel was reprojected */
		}
	}



        /* Check the pixel map to determine if this image should be rendered or not */
	pixel= (unsigned char*)malloc(sizeof(RGBpixel));
	for (i= 0; i < sizeof(RGBpixel); i++)
		pixel[i]= 0;
	if (pixmap) {
/*		bu_log("val[%d]\n",3*(pixelnum%width+pixelnum/width));*/
		memcpy(pixel,&pixmap[pixelnum*sizeof(RGBpixel)],sizeof(RGBpixel));
		a.a_user= 1;	/* Force Shot Hit */
/*		bu_log("a.a_user: %d\n",a.a_user);*/
	}

	if (pixel[0]+pixel[1]+pixel[2]) {
		a.a_color[0]= (double)(pixel[0])/255.0;
		a.a_color[1]= (double)(pixel[1])/255.0;
		a.a_color[2]= (double)(pixel[2])/255.0;
/*		bu_log("1: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]);*/
	} else {
		VSETALL( colorsum, 0 );

		for( samplenum=0; samplenum<=hypersample; samplenum++ )  {
			if( jitter & JITTER_CELL ) {
				jitter_start_pt(point, &a, samplenum, pat_num);
			}  else  {
				VJOIN2( point, viewbase_model,
					a.a_x, dx_model,
					a.a_y, dy_model );
			}
			if (a.a_rt_i->rti_prismtrace) {
				/* compute the four corners */
				pe.magic = PIXEL_EXT_MAGIC;

				VJOIN2(pe.corner[0].r_pt,
				       viewbase_model,
				       a.a_x, dx_model,
				       a.a_y, dy_model );

				VJOIN2(pe.corner[1].r_pt,
				       viewbase_model,
				       (a.a_x+1), dx_model,
				       a.a_y, dy_model );

				VJOIN2(pe.corner[2].r_pt,
				       viewbase_model,
				       (a.a_x+1), dx_model,
				       (a.a_y+1), dy_model );

				VJOIN2(pe.corner[3].r_pt,
				       viewbase_model,
				       a.a_x, dx_model,
				       (a.a_y+1), dy_model );

				a.a_pixelext = &pe;
			} else {
				a.a_pixelext=(struct pixel_ext *)NULL;
			}

			if( rt_perspective > 0.0 )  {
				VSUB2( a.a_ray.r_dir,
				point, eye_model );
				VUNITIZE( a.a_ray.r_dir );
				VMOVE( a.a_ray.r_pt, eye_model );
				if (a.a_rt_i->rti_prismtrace) {
					VSUB2(pe.corner[0].r_dir,
					      pe.corner[0].r_pt,
					      eye_model);
					VSUB2(pe.corner[1].r_dir,
					      pe.corner[1].r_pt,
					      eye_model);
					VSUB2(pe.corner[2].r_dir,
					      pe.corner[2].r_pt,
					      eye_model);
					VSUB2(pe.corner[3].r_dir,
					      pe.corner[3].r_pt,
					      eye_model);
				}
			} else {
				VMOVE( a.a_ray.r_pt, point );
				VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );

				if (a.a_rt_i->rti_prismtrace) {
					VMOVE(pe.corner[0].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[1].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[2].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[3].r_dir,
					      a.a_ray.r_dir);
				}
			}
			if( report_progress )  {
				report_progress = 0;
				bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
			}

			a.a_level = 0;		/* recursion level */
			a.a_purpose = "main ray";
			(void)rt_shootray( &a );

			if( stereo )  {
				FAST fastf_t right,left;

				right = CRT_BLEND(a.a_color);

				VSUB2(  point, point,
					left_eye_delta );
				if( rt_perspective > 0.0 )  {
					VSUB2( a.a_ray.r_dir,
					       point, eye_model );
					VUNITIZE( a.a_ray.r_dir );
					VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
				} else {
					VMOVE( a.a_ray.r_pt, point );
				}
				a.a_level = 0;		/* recursion level */
				a.a_purpose = "left eye ray";
				(void)rt_shootray( &a );

				left = CRT_BLEND(a.a_color);
				VSET( a.a_color, left, 0, right );
			}
			VADD2( colorsum, colorsum, a.a_color );
		} /* for samplenum <= hypersample */
		if( hypersample )  {
			FAST fastf_t f;
			f = 1.0 / (hypersample+1);
			VSCALE( a.a_color, colorsum, f );
		}

/*		bu_log("2: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]);*/
	}

	free(pixel);
	view_pixel( &a );
	if( a.a_x == width-1 )
		view_eol( &a );		/* End of scan line */
}

/*
 *  			W O R K E R
 *  
 *  Compute some pixels, and store them.
 *  A "self-dispatching" parallel algorithm.
 *  Executes until there is no more work to be done, or is told to stop.
 *
 *  In order to reduce the traffic through the res_worker critical section,
 *  a multiple pixel block may be removed from the work queue at once.
 *
 *  For a general-purpose version, see LIBRT rt_shoot_many_rays()
 */
void
worker(int cpu, genptr_t arg)
{
	int	pixel_start;
	int	pixelnum;
	int	pat_num = -1;

	/* The more CPUs at work, the bigger the bites we take */
	if( per_processor_chunk <= 0 )  per_processor_chunk = npsw;

	if( cpu >= MAX_PSW )  {
		bu_log("rt/worker() cpu %d > MAX_PSW %d, array overrun\n", cpu, MAX_PSW);
		rt_bomb("rt/worker() cpu > MAX_PSW, array overrun\n");
	}
	RT_CK_RESOURCE( &resource[cpu] );

	pat_num = -1;
	if (hypersample) {
		int i, ray_samples;

		ray_samples = hypersample + 1;
		for (i=0 ; pt_pats[i].num_samples != 0 ; i++) {
			if (pt_pats[i].num_samples == ray_samples) {
				pat_num = i;
				goto pat_found;
			}
		}
	}
 pat_found:

	if (transpose_grid) {
	  int     tmp;

	  /* switch cur_pixel and last_pixel */
	  tmp = cur_pixel;
	  cur_pixel = last_pixel;
	  last_pixel = tmp;

	  while (1)  {
	    if (stop_worker)
	      return;

	    bu_semaphore_acquire(RT_SEM_WORKER);
	    pixel_start = cur_pixel;
	    cur_pixel -= per_processor_chunk;
	    bu_semaphore_release(RT_SEM_WORKER);

	    for (pixelnum = pixel_start; pixelnum > pixel_start-per_processor_chunk; pixelnum--) {
	      if (pixelnum < last_pixel)
		return;

	      do_pixel(cpu, pat_num, pixelnum);
	    }
	  }
	} else {
	  while (1) {
	    if (stop_worker)
	      return;

	    bu_semaphore_acquire(RT_SEM_WORKER);
	    pixel_start = cur_pixel;
	    cur_pixel += per_processor_chunk;
	    bu_semaphore_release(RT_SEM_WORKER);

	    for (pixelnum = pixel_start; pixelnum < pixel_start+per_processor_chunk; pixelnum++) {

	      if (pixelnum > last_pixel)
		return;

	      do_pixel(cpu, pat_num, pixelnum);
	    }
	  }
	}
}
@


11.46
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /cvs/brlcad/rt/worker.c,v 11.45 2004/04/05 05:45:59 morrison Exp $ (BRL)";
@


11.45
log
@merge of ansi-6-0-branch into head
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.44
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.43 2004/01/15 01:32:13 jra Exp $ (BRL)";
d85 1
a85 1
grid_setup()
d621 1
a621 3
worker(cpu, arg)
int		cpu;
genptr_t	arg;
@


11.43
log
@Minor adjustment to get statistics working correctly for a single CPU under Linux
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985 by the United States Army.
d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.42 2003/10/29 15:56:01 jra Exp $ (BRL)";
@


11.42
log
@Added call to rt_zero_res_stats() at end of do_run()
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.40 2003/10/07 01:23:30 morrison Exp $ (BRL)";
d237 9
a245 7
	buffer = calloc(npsw, sizeof(resource[0]));
	if (buffer == NULL) {
		perror("calloc failed");
		bu_bomb("Unable to allocate memory");
	}
	if (pipe(p) == -1) {
		perror("pipe failed");
d313 5
a317 1
	tmp_res = (struct resource *)buffer;
@


11.41
log
@Mods to Sean's mods for getting Linux multi-cpu statistics. Instead of overwriting
(and hosing) the resource structs, just pass the stuff read from the pipe
to the resource stats counter.
@
text
@d318 1
@


11.40
log
@Weee... Fixed the Linux thread cpu utilization bug.
Linux 2.4 has a kernal/library bug that prevents a parent thread from accumulating statistics
for child _threads_.  You can, however, compute statistics for a child _process_.  This patch
forks off prior to computation and then gathers statistics on that child process (which
properly includes the children thread cpu utilization).  A pipe is used to pass the multi-
cpu resources back to the parent process as the IPC communication mechanism.
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.39 2003/09/27 01:11:25 morrison Exp $ (BRL)";
d235 1
d295 3
a297 2
			/* obliterate the raytrace instance pointer with what
			 * the child left us with.
d299 1
a299 1
			memcpy(resource, buffer, sizeof(resource[0]) * npsw);
d310 10
a319 1

d328 1
@


11.40.2.1
log
@updates from HEAD, part 1
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.42 2003/10/29 15:56:01 jra Exp $ (BRL)";
a234 1
	struct resource *tmp_res;
d294 2
a295 3

			/* do not use the just read info to overwrite the resource structures.
			 * doing so will hose the resources completely
d297 1
a297 1

d308 1
a308 11
#  if defined(linux )
	tmp_res = (struct resource *)buffer;
	for( cpu=0; cpu < npsw; cpu++ ) {
		if ( tmp_res[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &tmp_res[cpu] );
		rt_zero_res_stats( &resource[cpu] );
	}
#  else
a316 1
#endif
@


11.40.2.2
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.44 2004/02/02 17:39:39 morrison Exp $ (BRL)";
d237 7
a243 9
	if( rt_g.rtg_parallel ) {
		buffer = calloc(npsw, sizeof(resource[0]));
		if (buffer == NULL) {
			perror("calloc failed");
			bu_bomb("Unable to allocate memory");
		}
		if (pipe(p) == -1) {
			perror("pipe failed");
		}
d311 1
a311 5
	if( rt_g.rtg_parallel ) {
		tmp_res = (struct resource *)buffer;
	} else {
		tmp_res = resource;
	}
@


11.40.2.3
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.40.2.2 2004/02/12 19:37:14 erikg Exp $ (BRL)";
@


11.39
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.38 2003/09/05 15:21:46 justin Exp $ (BRL)";
d39 8
d215 1
d230 17
d257 51
a307 2
		bu_parallel( worker, npsw, NULL );
	}
d310 2
a311 2
	for( cpu=0; cpu < npsw; cpu++ )  {
		if( resource[cpu].re_magic != RESOURCE_MAGIC )  {
@


11.38
log
@updated to support re-rendering of black pixels
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.37 2002/08/20 17:08:40 jra Exp $ (BRL)";
a51 1
/* XXX should record width&height, in case size changes on-the-fly */
@


11.37
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.35 2002/04/05 14:06:00 jra Exp $ (BRL)";
d37 2
d64 2
d323 6
a328 5
	LOCAL struct application a;
	LOCAL struct pixel_ext pe;
	LOCAL vect_t point;		/* Ref point on eye or view plane */
	LOCAL vect_t colorsum;
	int	samplenum;
a374 1
	VSETALL( colorsum, 0 );
a375 31
	for( samplenum=0; samplenum<=hypersample; samplenum++ )  {
		if( jitter & JITTER_CELL ) {
			jitter_start_pt(point, &a, samplenum, pat_num);
		}  else  {
			VJOIN2( point, viewbase_model,
				a.a_x, dx_model,
				a.a_y, dy_model );
		}
		if (a.a_rt_i->rti_prismtrace) {
			/* compute the four corners */
			pe.magic = PIXEL_EXT_MAGIC;

			VJOIN2(pe.corner[0].r_pt,
			       viewbase_model,
			       a.a_x, dx_model,
			       a.a_y, dy_model );

			VJOIN2(pe.corner[1].r_pt,
			       viewbase_model,
			       (a.a_x+1), dx_model,
			       a.a_y, dy_model );

			VJOIN2(pe.corner[2].r_pt,
			       viewbase_model,
			       (a.a_x+1), dx_model,
			       (a.a_y+1), dy_model );

			VJOIN2(pe.corner[3].r_pt,
			       viewbase_model,
			       a.a_x, dx_model,
			       (a.a_y+1), dy_model );
d377 18
a394 4
			a.a_pixelext = &pe;
		} else {
			a.a_pixelext=(struct pixel_ext *)NULL;
		}
d396 7
a402 18
		if( rt_perspective > 0.0 )  {
			VSUB2( a.a_ray.r_dir,
			       point, eye_model );
			VUNITIZE( a.a_ray.r_dir );
			VMOVE( a.a_ray.r_pt, eye_model );
			if (a.a_rt_i->rti_prismtrace) {
				VSUB2(pe.corner[0].r_dir,
				      pe.corner[0].r_pt,
				      eye_model);
				VSUB2(pe.corner[1].r_dir,
				      pe.corner[1].r_pt,
				      eye_model);
				VSUB2(pe.corner[2].r_dir,
				      pe.corner[2].r_pt,
				      eye_model);
				VSUB2(pe.corner[3].r_dir,
				      pe.corner[3].r_pt,
				      eye_model);
a403 4
		} else {
			VMOVE( a.a_ray.r_pt, point );
			VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );

d405 2
a406 14
				VMOVE(pe.corner[0].r_dir,
				      a.a_ray.r_dir);
				VMOVE(pe.corner[1].r_dir,
				      a.a_ray.r_dir);
				VMOVE(pe.corner[2].r_dir,
				      a.a_ray.r_dir);
				VMOVE(pe.corner[3].r_dir,
				      a.a_ray.r_dir);
			}
		}
		if( report_progress )  {
			report_progress = 0;
			bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
		}
d408 19
a426 3
		a.a_level = 0;		/* recursion level */
		a.a_purpose = "main ray";
		(void)rt_shootray( &a );
d428 4
a431 4
		if( stereo )  {
			FAST fastf_t right,left;

			right = CRT_BLEND(a.a_color);
a432 2
			VSUB2(  point, point,
				left_eye_delta );
d435 1
a435 1
				       point, eye_model );
d437 15
a451 1
				VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
d454 16
d471 1
d473 1
a473 1
			a.a_purpose = "left eye ray";
d476 28
a503 2
			left = CRT_BLEND(a.a_color);
			VSET( a.a_color, left, 0, right );
d505 2
a506 6
		VADD2( colorsum, colorsum, a.a_color );
	} /* for samplenum <= hypersample */
	if( hypersample )  {
		FAST fastf_t f;
		f = 1.0 / (hypersample+1);
		VSCALE( a.a_color, colorsum, f );
d508 2
@


11.37.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/worker.c,v 11.44 2004/02/02 17:39:39 morrison Exp $ (BRL)";
a36 10
#include "fb.h"					/* Added because RGBpixel is now needed in do_pixel() */

/* for fork/pipe linux timing hack */
#if defined(linux)
#  include <sys/select.h>
#  include <sys/types.h>
#  include <sys/wait.h>
#  include <unistd.h>
#endif

d50 1
a61 2
extern unsigned	char	*pixmap;		/* pixmap for rerendering of black pixels */

a203 1

a217 20
#  if defined(linux)
	int pid, wpid;
	int waitret;
	int p[2];
	void *buffer;
	struct resource *tmp_res;

	if( rt_g.rtg_parallel ) {
		buffer = calloc(npsw, sizeof(resource[0]));
		if (buffer == NULL) {
			perror("calloc failed");
			bu_bomb("Unable to allocate memory");
		}
		if (pipe(p) == -1) {
			perror("pipe failed");
		}
	}
#  endif


d228 2
a230 66
		/* hack to bypass a bug in the Linux 2.4 kernel pthreads
		 * implementation. cpu statistics are only traceable on a
		 * process level and the timers will report effectively no
		 * elapsed cpu time.  this allows the stats of all threads
		 * to be gathered up by an encompassing process that may
		 * be timed.
		 *
		 * XXX this should somehow only apply to a build on a 2.4
		 * linux kernel.
		 */
#  if defined(linux)
		pid = fork();
		if (pid < 0) {
			perror("fork failed");
			exit(1);
		} else if (pid == 0) {
#  endif

			bu_parallel( worker, npsw, NULL );

#  if defined(linux)
			/* send raytrace instance data back to the parent */
			if (write(p[1], resource, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to write to the communication pipe");
				exit(1);
			}
			/* flush the pipe */
			if (close(p[1]) == -1) {
			  	perror("Unable to close the communication pipe");
			  	sleep(1); /* give the parent time to read */
			}
			exit(0); 
		} else {
			if (read(p[0], buffer, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to read from the communication pipe");
			}

			/* do not use the just read info to overwrite the resource structures.
			 * doing so will hose the resources completely
			 */

			/* parent ends up waiting on his child (and his child's threads) to
			 * terminate.  we can get valid usage statistics on a child process.
			 */
			while ((wpid = wait(&waitret)) != pid && wpid != -1)
				; /* do nothing */
		} /* end fork() */
#  endif

	} /* end parallel case */

#  if defined(linux )
	if( rt_g.rtg_parallel ) {
		tmp_res = (struct resource *)buffer;
	} else {
		tmp_res = resource;
	}
	for( cpu=0; cpu < npsw; cpu++ ) {
		if ( tmp_res[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &tmp_res[cpu] );
		rt_zero_res_stats( &resource[cpu] );
	}
#  else
d232 2
a233 2
	for ( cpu=0; cpu < npsw; cpu++ ) {
		if ( resource[cpu].re_magic != RESOURCE_MAGIC )  {
a238 1
#endif
d319 5
a323 6
	LOCAL	struct	application	a;
	LOCAL	struct	pixel_ext	pe;
	LOCAL	vect_t			point;		/* Ref point on eye or view plane */
	LOCAL	vect_t			colorsum;
	int				samplenum,i;
        unsigned	char		*pixel;
d370 1
d372 31
d404 4
a407 18
        /* Check the pixel map to determine if this image should be rendered or not */
	pixel= (unsigned char*)malloc(sizeof(RGBpixel));
	for (i= 0; i < sizeof(RGBpixel); i++)
		pixel[i]= 0;
	if (pixmap) {
/*		bu_log("val[%d]\n",3*(pixelnum%width+pixelnum/width));*/
		memcpy(pixel,&pixmap[pixelnum*sizeof(RGBpixel)],sizeof(RGBpixel));
		a.a_user= 1;	/* Force Shot Hit */
/*		bu_log("a.a_user: %d\n",a.a_user);*/
	}

	if (pixel[0]+pixel[1]+pixel[2]) {
		a.a_color[0]= (double)(pixel[0])/255.0;
		a.a_color[1]= (double)(pixel[1])/255.0;
		a.a_color[2]= (double)(pixel[2])/255.0;
/*		bu_log("1: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]);*/
	} else {
		VSETALL( colorsum, 0 );
d409 18
a426 7
		for( samplenum=0; samplenum<=hypersample; samplenum++ )  {
			if( jitter & JITTER_CELL ) {
				jitter_start_pt(point, &a, samplenum, pat_num);
			}  else  {
				VJOIN2( point, viewbase_model,
					a.a_x, dx_model,
					a.a_y, dy_model );
d428 4
d433 18
a450 2
				/* compute the four corners */
				pe.magic = PIXEL_EXT_MAGIC;
d452 2
a453 19
				VJOIN2(pe.corner[0].r_pt,
				       viewbase_model,
				       a.a_x, dx_model,
				       a.a_y, dy_model );

				VJOIN2(pe.corner[1].r_pt,
				       viewbase_model,
				       (a.a_x+1), dx_model,
				       a.a_y, dy_model );

				VJOIN2(pe.corner[2].r_pt,
				       viewbase_model,
				       (a.a_x+1), dx_model,
				       (a.a_y+1), dy_model );

				VJOIN2(pe.corner[3].r_pt,
				       viewbase_model,
				       a.a_x, dx_model,
				       (a.a_y+1), dy_model );
d455 1
a455 4
				a.a_pixelext = &pe;
			} else {
				a.a_pixelext=(struct pixel_ext *)NULL;
			}
d457 2
d461 1
a461 1
				point, eye_model );
d463 1
a463 15
				VMOVE( a.a_ray.r_pt, eye_model );
				if (a.a_rt_i->rti_prismtrace) {
					VSUB2(pe.corner[0].r_dir,
					      pe.corner[0].r_pt,
					      eye_model);
					VSUB2(pe.corner[1].r_dir,
					      pe.corner[1].r_pt,
					      eye_model);
					VSUB2(pe.corner[2].r_dir,
					      pe.corner[2].r_pt,
					      eye_model);
					VSUB2(pe.corner[3].r_dir,
					      pe.corner[3].r_pt,
					      eye_model);
				}
a465 12
				VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );

				if (a.a_rt_i->rti_prismtrace) {
					VMOVE(pe.corner[0].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[1].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[2].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[3].r_dir,
					      a.a_ray.r_dir);
				}
a466 5
			if( report_progress )  {
				report_progress = 0;
				bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
			}

d468 1
a468 1
			a.a_purpose = "main ray";
d471 2
a472 28
			if( stereo )  {
				FAST fastf_t right,left;

				right = CRT_BLEND(a.a_color);

				VSUB2(  point, point,
					left_eye_delta );
				if( rt_perspective > 0.0 )  {
					VSUB2( a.a_ray.r_dir,
					       point, eye_model );
					VUNITIZE( a.a_ray.r_dir );
					VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
				} else {
					VMOVE( a.a_ray.r_pt, point );
				}
				a.a_level = 0;		/* recursion level */
				a.a_purpose = "left eye ray";
				(void)rt_shootray( &a );

				left = CRT_BLEND(a.a_color);
				VSET( a.a_color, left, 0, right );
			}
			VADD2( colorsum, colorsum, a.a_color );
		} /* for samplenum <= hypersample */
		if( hypersample )  {
			FAST fastf_t f;
			f = 1.0 / (hypersample+1);
			VSCALE( a.a_color, colorsum, f );
d474 6
a479 2

/*		bu_log("2: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]);*/
a480 2

	free(pixel);
@


11.37.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.37 2002/08/20 17:08:40 jra Exp $ (BRL)";
d74 1
a74 1
grid_setup(void)
d499 3
a501 1
worker(int cpu, genptr_t arg)
@


11.37.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header$ (BRL)";
a36 10
#include "fb.h"					/* Added because RGBpixel is now needed in do_pixel() */

/* for fork/pipe linux timing hack */
#if defined(linux)
#  include <sys/select.h>
#  include <sys/types.h>
#  include <sys/wait.h>
#  include <unistd.h>
#endif

d50 1
a61 2
extern unsigned	char	*pixmap;		/* pixmap for rerendering of black pixels */

a203 1

a217 20
#  if defined(linux)
	int pid, wpid;
	int waitret;
	int p[2];
	void *buffer;
	struct resource *tmp_res;

	if( rt_g.rtg_parallel ) {
		buffer = calloc(npsw, sizeof(resource[0]));
		if (buffer == NULL) {
			perror("calloc failed");
			bu_bomb("Unable to allocate memory");
		}
		if (pipe(p) == -1) {
			perror("pipe failed");
		}
	}
#  endif


d228 2
a230 66
		/* hack to bypass a bug in the Linux 2.4 kernel pthreads
		 * implementation. cpu statistics are only traceable on a
		 * process level and the timers will report effectively no
		 * elapsed cpu time.  this allows the stats of all threads
		 * to be gathered up by an encompassing process that may
		 * be timed.
		 *
		 * XXX this should somehow only apply to a build on a 2.4
		 * linux kernel.
		 */
#  if defined(linux)
		pid = fork();
		if (pid < 0) {
			perror("fork failed");
			exit(1);
		} else if (pid == 0) {
#  endif

			bu_parallel( worker, npsw, NULL );

#  if defined(linux)
			/* send raytrace instance data back to the parent */
			if (write(p[1], resource, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to write to the communication pipe");
				exit(1);
			}
			/* flush the pipe */
			if (close(p[1]) == -1) {
			  	perror("Unable to close the communication pipe");
			  	sleep(1); /* give the parent time to read */
			}
			exit(0); 
		} else {
			if (read(p[0], buffer, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to read from the communication pipe");
			}

			/* do not use the just read info to overwrite the resource structures.
			 * doing so will hose the resources completely
			 */

			/* parent ends up waiting on his child (and his child's threads) to
			 * terminate.  we can get valid usage statistics on a child process.
			 */
			while ((wpid = wait(&waitret)) != pid && wpid != -1)
				; /* do nothing */
		} /* end fork() */
#  endif

	} /* end parallel case */

#  if defined(linux )
	if( rt_g.rtg_parallel ) {
		tmp_res = (struct resource *)buffer;
	} else {
		tmp_res = resource;
	}
	for( cpu=0; cpu < npsw; cpu++ ) {
		if ( tmp_res[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &tmp_res[cpu] );
		rt_zero_res_stats( &resource[cpu] );
	}
#  else
d232 2
a233 2
	for ( cpu=0; cpu < npsw; cpu++ ) {
		if ( resource[cpu].re_magic != RESOURCE_MAGIC )  {
a238 1
#endif
d319 5
a323 6
	LOCAL	struct	application	a;
	LOCAL	struct	pixel_ext	pe;
	LOCAL	vect_t			point;		/* Ref point on eye or view plane */
	LOCAL	vect_t			colorsum;
	int				samplenum,i;
        unsigned	char		*pixel;
d370 1
d372 31
d404 4
a407 18
        /* Check the pixel map to determine if this image should be rendered or not */
	pixel= (unsigned char*)malloc(sizeof(RGBpixel));
	for (i= 0; i < sizeof(RGBpixel); i++)
		pixel[i]= 0;
	if (pixmap) {
/*		bu_log("val[%d]\n",3*(pixelnum%width+pixelnum/width));*/
		memcpy(pixel,&pixmap[pixelnum*sizeof(RGBpixel)],sizeof(RGBpixel));
		a.a_user= 1;	/* Force Shot Hit */
/*		bu_log("a.a_user: %d\n",a.a_user);*/
	}

	if (pixel[0]+pixel[1]+pixel[2]) {
		a.a_color[0]= (double)(pixel[0])/255.0;
		a.a_color[1]= (double)(pixel[1])/255.0;
		a.a_color[2]= (double)(pixel[2])/255.0;
/*		bu_log("1: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]);*/
	} else {
		VSETALL( colorsum, 0 );
d409 18
a426 7
		for( samplenum=0; samplenum<=hypersample; samplenum++ )  {
			if( jitter & JITTER_CELL ) {
				jitter_start_pt(point, &a, samplenum, pat_num);
			}  else  {
				VJOIN2( point, viewbase_model,
					a.a_x, dx_model,
					a.a_y, dy_model );
d428 4
d433 18
a450 2
				/* compute the four corners */
				pe.magic = PIXEL_EXT_MAGIC;
d452 2
a453 19
				VJOIN2(pe.corner[0].r_pt,
				       viewbase_model,
				       a.a_x, dx_model,
				       a.a_y, dy_model );

				VJOIN2(pe.corner[1].r_pt,
				       viewbase_model,
				       (a.a_x+1), dx_model,
				       a.a_y, dy_model );

				VJOIN2(pe.corner[2].r_pt,
				       viewbase_model,
				       (a.a_x+1), dx_model,
				       (a.a_y+1), dy_model );

				VJOIN2(pe.corner[3].r_pt,
				       viewbase_model,
				       a.a_x, dx_model,
				       (a.a_y+1), dy_model );
d455 1
a455 4
				a.a_pixelext = &pe;
			} else {
				a.a_pixelext=(struct pixel_ext *)NULL;
			}
d457 2
d461 1
a461 1
				point, eye_model );
d463 1
a463 15
				VMOVE( a.a_ray.r_pt, eye_model );
				if (a.a_rt_i->rti_prismtrace) {
					VSUB2(pe.corner[0].r_dir,
					      pe.corner[0].r_pt,
					      eye_model);
					VSUB2(pe.corner[1].r_dir,
					      pe.corner[1].r_pt,
					      eye_model);
					VSUB2(pe.corner[2].r_dir,
					      pe.corner[2].r_pt,
					      eye_model);
					VSUB2(pe.corner[3].r_dir,
					      pe.corner[3].r_pt,
					      eye_model);
				}
a465 12
				VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );

				if (a.a_rt_i->rti_prismtrace) {
					VMOVE(pe.corner[0].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[1].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[2].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[3].r_dir,
					      a.a_ray.r_dir);
				}
a466 5
			if( report_progress )  {
				report_progress = 0;
				bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
			}

d468 1
a468 1
			a.a_purpose = "main ray";
d471 2
a472 28
			if( stereo )  {
				FAST fastf_t right,left;

				right = CRT_BLEND(a.a_color);

				VSUB2(  point, point,
					left_eye_delta );
				if( rt_perspective > 0.0 )  {
					VSUB2( a.a_ray.r_dir,
					       point, eye_model );
					VUNITIZE( a.a_ray.r_dir );
					VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
				} else {
					VMOVE( a.a_ray.r_pt, point );
				}
				a.a_level = 0;		/* recursion level */
				a.a_purpose = "left eye ray";
				(void)rt_shootray( &a );

				left = CRT_BLEND(a.a_color);
				VSET( a.a_color, left, 0, right );
			}
			VADD2( colorsum, colorsum, a.a_color );
		} /* for samplenum <= hypersample */
		if( hypersample )  {
			FAST fastf_t f;
			f = 1.0 / (hypersample+1);
			VSCALE( a.a_color, colorsum, f );
d474 6
a479 2

/*		bu_log("2: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]);*/
a480 2

	free(pixel);
@


11.36
log
@Converted from K&R to ANSI C - RFH
@
text
@d74 1
a74 1
grid_setup(void)
d499 3
a501 1
worker(int cpu, genptr_t arg)
@


11.35
log
@Bob Parker's "transpose grid" option (reverses order of rays)
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.34 2001/04/02 21:38:31 morrison Exp $ (BRL)";
d74 1
a74 1
grid_setup()
d499 1
a499 3
worker(cpu, arg)
int		cpu;
genptr_t	arg;
@


11.34
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.33 2001/03/31 01:57:32 morrison Exp $ (BRL)";
d315 170
a502 4
	LOCAL struct application a;
	LOCAL struct pixel_ext pe;
	LOCAL vect_t point;		/* Ref point on eye or view plane */
	LOCAL vect_t colorsum;
a504 1
	int	samplenum;
d530 2
a531 2
	while(1)  {
		if( stop_worker )  return;
d533 39
a571 173
		bu_semaphore_acquire( RT_SEM_WORKER );
		pixel_start = cur_pixel;
		cur_pixel += per_processor_chunk;
		bu_semaphore_release( RT_SEM_WORKER );

		for( pixelnum = pixel_start; pixelnum < pixel_start+per_processor_chunk; pixelnum++ )  {

			if( pixelnum > last_pixel )
				return;

			/* Obtain fresh copy of global application struct */
			a = ap;				/* struct copy */
			a.a_resource = &resource[cpu];

			if( incr_mode )  {
				register int i = 1<<incr_level;
				a.a_x = pixelnum%i;
				a.a_y = pixelnum/i;
				if( incr_level != 0 )  {
					/* See if already done last pass */
					if( ((a.a_x & 1) == 0 ) &&
					    ((a.a_y & 1) == 0 ) )
						continue;
				}
				a.a_x <<= (incr_nlevel-incr_level);
				a.a_y <<= (incr_nlevel-incr_level);
			} else {
				a.a_x = pixelnum%width;
				a.a_y = pixelnum/width;
			}

			if (Query_one_pixel) {
				if (a.a_x == query_x && a.a_y == query_y) {
					rdebug = query_rdebug;
					rt_g.debug = query_debug;
				} else {
					rt_g.debug = rdebug = 0;
				}
			}



			if( sub_grid_mode )  {
				if( a.a_x < sub_xmin || a.a_x > sub_xmax )
					continue;
				if( a.a_y < sub_ymin || a.a_y > sub_ymax )
					continue;
			}
			if( fullfloat_mode )  {
				register struct floatpixel	*fp;
				fp = &curr_float_frame[a.a_y*width + a.a_x];
				if( fp->ff_frame >= 0 )  {
					continue;	/* pixel was reprojected */
				}
			}

			VSETALL( colorsum, 0 );



			for( samplenum=0; samplenum<=hypersample; samplenum++ )  {
				if( jitter & JITTER_CELL ) {
					jitter_start_pt(point, &a, samplenum, pat_num);
				}  else  {
					VJOIN2( point, viewbase_model,
						a.a_x, dx_model,
						a.a_y, dy_model );
				}
				if (a.a_rt_i->rti_prismtrace) {
					/* compute the four corners */
					pe.magic = PIXEL_EXT_MAGIC;

					VJOIN2(pe.corner[0].r_pt,
						viewbase_model,
						a.a_x, dx_model,
						a.a_y, dy_model );

					VJOIN2(pe.corner[1].r_pt,
						viewbase_model,
						(a.a_x+1), dx_model,
						a.a_y, dy_model );

					VJOIN2(pe.corner[2].r_pt,
						viewbase_model,
						(a.a_x+1), dx_model,
						(a.a_y+1), dy_model );

					VJOIN2(pe.corner[3].r_pt,
						viewbase_model,
						a.a_x, dx_model,
						(a.a_y+1), dy_model );

					a.a_pixelext = &pe;
				} else {
					a.a_pixelext=(struct pixel_ext *)NULL;
				}

				if( rt_perspective > 0.0 )  {
					VSUB2( a.a_ray.r_dir,
						point, eye_model );
					VUNITIZE( a.a_ray.r_dir );
					VMOVE( a.a_ray.r_pt, eye_model );
					if (a.a_rt_i->rti_prismtrace) {
						VSUB2(pe.corner[0].r_dir,
						      pe.corner[0].r_pt,
						      eye_model);
						VSUB2(pe.corner[1].r_dir,
						      pe.corner[1].r_pt,
						      eye_model);
						VSUB2(pe.corner[2].r_dir,
						      pe.corner[2].r_pt,
						      eye_model);
						VSUB2(pe.corner[3].r_dir,
						      pe.corner[3].r_pt,
						      eye_model);
					}
				} else {
					VMOVE( a.a_ray.r_pt, point );
				 	VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );

					if (a.a_rt_i->rti_prismtrace) {
						VMOVE(pe.corner[0].r_dir,
							a.a_ray.r_dir);
						VMOVE(pe.corner[1].r_dir,
							a.a_ray.r_dir);
						VMOVE(pe.corner[2].r_dir,
							a.a_ray.r_dir);
						VMOVE(pe.corner[3].r_dir,
							a.a_ray.r_dir);
					}
				}
				if( report_progress )  {
					report_progress = 0;
					bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
				}

				a.a_level = 0;		/* recursion level */
				a.a_purpose = "main ray";
				(void)rt_shootray( &a );

				if( stereo )  {
					FAST fastf_t right,left;

					right = CRT_BLEND(a.a_color);

					VSUB2(  point, point,
						left_eye_delta );
					if( rt_perspective > 0.0 )  {
						VSUB2( a.a_ray.r_dir,
							point, eye_model );
						VUNITIZE( a.a_ray.r_dir );
						VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
					} else {
						VMOVE( a.a_ray.r_pt, point );
					}
					a.a_level = 0;		/* recursion level */
					a.a_purpose = "left eye ray";
					(void)rt_shootray( &a );

					left = CRT_BLEND(a.a_color);
					VSET( a.a_color, left, 0, right );
				}
				VADD2( colorsum, colorsum, a.a_color );
			} /* for samplenum <= hypersample */
			if( hypersample )  {
				FAST fastf_t f;
				f = 1.0 / (hypersample+1);
				VSCALE( a.a_color, colorsum, f );
			}
			view_pixel( &a );
			if( a.a_x == width-1 )
				view_eol( &a );		/* End of scan line */
		}
@


11.33
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.32 2000/10/19 19:19:47 butler Exp $ (BRL)";
d117 1
a117 1
		bn_mat_copy( model2hv, Viewrotscale );
@


11.32
log
@Changes to compile under RedHat 7.0
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.31 2000/08/17 02:41:43 mike Exp $ (BRL)";
d82 1
a82 1
	bn_mat_idn( toEye );
@


11.31
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.30 2000/07/27 19:32:53 butler Exp $ (BRL)";
d26 3
@


11.30
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.29 2000/07/25 16:39:49 butler Exp $ (BRL)";
@


11.29
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.28 2000/03/08 06:37:03 mike Exp $ (BRL)";
d53 6
d395 11
@


11.28
log
@
Added support for ^T on FreeBSD, and SIGUSR1 everywhere,
to report progress of ray-tracing.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.27 2000/02/04 09:38:11 butler Exp $ (BRL)";
d33 1
a33 1
#include "./rdebug.h"
d202 1
a202 2
void
do_run( a, b )
a330 1
	FAST fastf_t dx, dy;
@


11.27
log
@Improved sampling distribution for some hypersampling levels
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.26 1999/11/16 01:13:09 mike Exp $ (BRL)";
d481 5
d488 1
a488 1
				rt_shootray( &a );
d507 1
a507 1
					rt_shootray( &a );
@


11.26
log
@
Stored dx_unit in addition to dx_model.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.25 1999/11/13 05:28:58 mike Exp $ (BRL)";
d239 70
d332 2
d344 14
d407 3
d411 2
a412 8
				if( jitter & JITTER_CELL )  {
					FAST fastf_t dx, dy;
					dx = a.a_x + 
						bn_rand_half(a.a_resource->re_randptr);
					dy = a.a_y + 
						bn_rand_half(a.a_resource->re_randptr);
					VJOIN2( point, viewbase_model,
						dx, dx_model, dy, dy_model );
d508 1
a508 1
			}
@


11.25
log
@
Added comments pointing to rt_shoot_many_rays() in LIBRT.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.24 1999/10/30 03:06:27 butler Exp $ (BRL)";
d127 2
a128 2
	MAT3X3VEC( dx_model, view2model, temp );	/* rotate only */
	VSCALE( dx_model, dx_model, cell_width );
d131 2
a132 2
	MAT3X3VEC( dy_model, view2model, temp );	/* rotate only */
	VSCALE( dy_model, dy_model, cell_height );
@


11.24
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.23 1999/05/28 01:17:27 mike Exp $ (BRL)";
d200 1
d247 2
@


11.23
log
@
sed4
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.22 1999/01/25 05:29:57 butler Exp $ (BRL)";
a32 1
#include "./mathtab.h"
d321 4
a324 2
					dx = a.a_x + rand_half(a.a_resource->re_randptr);
					dy = a.a_y + rand_half(a.a_resource->re_randptr);
@


11.22
log
@Changes for prism tracing.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /c/CVS/brlcad/rt/worker.c,v 11.21 1998/06/03 05:10:12 mike Exp $ (BRL)";
d265 1
a265 1
		rt_log("rt/worker() cpu %d > MAX_PSW %d, array overrun\n", cpu, MAX_PSW);
@


11.21
log
@removed HIDDEN from cur_pixel and last_pixel, now shared by view.c
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.20 1998/05/13 02:41:03 mike Exp mike $ (BRL)";
d254 1
d303 1
d331 29
d365 14
d382 11
@


11.20
log
@Eliminated rt_savings double-check counter.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.19 1998/05/12 22:52:09 mike Exp mike $ (BRL)";
d51 2
a52 2
HIDDEN int cur_pixel;		/* current pixel number, 0..last_pixel */
HIDDEN int last_pixel;		/* last pixel number */
@


11.19
log
@Initial reprojection support
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.18 1998/05/06 04:40:45 mike Exp mike $ (BRL)";
a195 2
int	rt_savings;

a208 1
rt_savings = 0;
a230 1
bu_log("rt_savings = %d\n", rt_savings);
a311 1
rt_savings++;	/* non-parallel */
@


11.18
log
@Additions to pixel reprojection code.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.17 1998/04/15 05:13:15 mike Exp mike $ (BRL)";
d42 7
a48 1
extern int	fullfloat_mode;
d196 2
d211 1
d234 1
a311 1
#if 0
d315 2
a316 1
				if( fp->ff_frame >= 0 )
d318 1
a319 1
#endif
@


11.17
log
@Modified for new calling sequence of bu_parallel().
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.16 1998/01/23 02:01:31 mike Exp mike $ (BRL)";
d42 2
d302 8
@


11.16
log
@Added support for -j flag (just these scanlines)
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.15 1997/12/04 06:20:25 mike Exp mike $ (BRL)";
d207 1
a207 1
		worker(0);
d212 1
a212 1
		bu_parallel( worker, npsw );
d241 3
a243 2
worker(cpu)
int	cpu;
@


11.15
log
@Improved error message about hitting MAX_PSW limit
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.14 1997/11/14 04:43:09 mike Exp mike $ (BRL)";
d293 7
@


11.14
log
@Took advantage of new bu_parallel() providing cpu number as arg
and doing extra checking.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.13 1997/11/14 02:51:43 mike Exp mike $ (BRL)";
d254 4
a257 1
	if( cpu >= MAX_PSW )  rt_bomb("rt/worker() cpu > MAXPSW, array overrun\n");
@


11.13
log
@Changed RES_ACQUIRE to bu_semaphore_acquire
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.12 1997/11/14 02:04:35 mike Exp mike $ (BRL)";
a44 2
HIDDEN int nworkers_started;	/* number of workers started */
HIDDEN int nworkers_finished;	/* number of workers properly finished */
a201 2
	nworkers_started = 0;
	nworkers_finished = 0;
d207 1
a207 1
		worker();
a213 13
	/*
	 *  Ensure that all the workers are REALLY finished.
	 *  On some systems, if threads core dump, the rest of
	 *  the gang keeps going, so this can actually happen (sigh).
	 */
	if( nworkers_finished != npsw )  {
		bu_log("\n***ERROR: %d workers did not finish!\n\n",
			npsw - nworkers_finished);
	}
	if( nworkers_started != npsw )  {
		bu_log("\nNOTICE:  only %d workers started, expected %d\n",
			nworkers_started, npsw );
	}
d228 1
d235 1
d241 2
a242 1
worker()
a249 1
	int	cpu;			/* our CPU (PSW) number */
a250 4
	bu_semaphore_acquire( RT_SEM_WORKER );
	cpu = nworkers_started++;
	bu_semaphore_release( RT_SEM_WORKER );

d258 2
d268 1
a268 1
				goto out;
d270 1
a270 1
			/* Obtain fresh copy of application struct */
a349 4
out:
	bu_semaphore_acquire( RT_SEM_WORKER );
	nworkers_finished++;
	bu_semaphore_release( RT_SEM_WORKER );
@


11.12
log
@Changed to bu_ names
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.11 1997/11/14 02:03:25 mike Exp mike $ (BRL)";
d266 1
a266 1
	RES_ACQUIRE( &rt_g.res_worker );
d268 1
a268 1
	RES_RELEASE( &rt_g.res_worker );
d277 1
a277 1
		RES_ACQUIRE( &rt_g.res_worker );
d280 1
a280 1
		RES_RELEASE( &rt_g.res_worker );
d368 1
a368 1
	RES_ACQUIRE( &rt_g.res_worker );
d370 1
a370 1
	RES_RELEASE( &rt_g.res_worker );
@


11.11
log
@JRA fix to computation of a_diverge
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.10 1997/08/26 06:49:04 mike Exp jra $ (BRL)";
d68 1
a68 1
	mat_idn( toEye );
d71 2
a72 2
	mat_mul( model2view, Viewrotscale, toEye );
	mat_inv( view2model, model2view );
d103 1
a103 1
		mat_copy( model2hv, Viewrotscale );
d105 1
a105 1
		mat_inv( hv2model, model2hv );
d116 2
a117 2
		mat_mul( model2view, Viewrotscale, toEye );
		mat_inv( view2model, model2view );
d132 1
a132 1
		rt_log("red eye: moving %f relative screen (left)\n", temp[X]);
d169 1
a169 1
		ang = curframe * frame_delta_t * rt_twopi / 10;	/* 10 sec period */
d179 1
a179 1
		rt_log("grid_setup: cell size ERROR (%g, %g) mm\n",
d184 1
a184 1
		rt_log("grid_setup: ERROR bad image size (%d, %d)\n",
d216 1
a216 1
		rt_parallel( worker, npsw );
d224 1
a224 1
		rt_log("\n***ERROR: %d workers did not finish!\n\n",
d228 1
a228 1
		rt_log("\nNOTICE:  only %d workers started, expected %d\n",
d235 1
a235 1
			rt_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
@


11.10
log
@Moved rt_init_resource() from worker() into main().
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.9 1997/03/07 06:16:06 mike Exp mike $ (BRL)";
d143 4
a146 2
		 * Divergance is (0.5 * viewsize / width) mm at
		 * a ray distance of (viewsize * zoomout) mm.
d148 1
a148 1
		ap.a_diverge = (0.5 / width) / zoomout;
@


11.9
log
@Had to do rand_init here, it's an "rt" macro.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.8 1997/03/07 06:12:28 mike Exp mike $ (BRL)";
d272 1
a272 2
	rt_init_resource( &resource[cpu], cpu );
	rand_init( resource[cpu].re_randptr, cpu );
@


11.8
log
@Moved bu_debug compat settings from main.c to opt.c.
Moved rt_init_resource() call from main.c to worker.c
Both to support remrt/rtsync.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.7 1996/12/31 00:16:34 mike Exp mike $ (BRL)";
d273 1
@


11.7
log
@LIBBN
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.6 1996/08/29 02:11:21 mike Exp mike $ (BRL)";
d272 1
a272 3
	resource[cpu].re_cpu = cpu;
	resource[cpu].re_magic = RESOURCE_MAGIC;
	rand_init( resource[cpu].re_randptr, cpu );
@


11.6
log
@Changed -J2 behavior to be less noticable.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.5 1996/07/29 22:17:07 mike Exp mike $ (BRL)";
d28 1
d30 1
d140 1
a140 2
		extern double mat_degtorad;
		zoomout = 1.0 / tan( mat_degtorad * rt_perspective / 2.0 );
@


11.5
log
@jitter is now a bit vector
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 11.4 1995/03/18 00:50:31 mike Exp mike $ (BRL)";
d166 2
a167 2
		ang = curframe * frame_delta_t * rt_pi;	/* 2 sec period */
		dx = cos(ang) * 0.5;	/* 1/2 width amplitude */
@


11.4
log
@Needed break**2
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/worker.c,v 11.3 1995/03/18 00:48:32 mike Exp mike $ (BRL)";
d161 13
d308 1
a308 1
				if( jitter )  {
@


11.3
log
@Loop termination condition not checked in the right place.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/worker.c,v 11.2 1995/03/18 00:09:05 mike Exp mike $ (BRL)";
d271 1
a271 1
				break;
d353 1
@


11.2
log
@The more processors being used, the larger the bites we take.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/worker.c,v 11.1 1995/01/04 10:01:34 mike Rel4_4 mike $ (BRL)";
d233 5
a237 1
 *  Compute one pixel, and store it.
d268 1
a268 2
		if( pixel_start > last_pixel )
			break;
d270 2
a271 1
		for( pixelnum = pixel_start; pixelnum < pixel_start+per_processor_chunk; pixelnum++ )  {
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 10.8 94/08/11 02:48:14 gdurf Exp $ (BRL)";
d34 2
d241 3
a243 1
	register int com;
d250 3
d260 2
a261 1
		com = cur_pixel++;
d264 1
a264 1
		if( com > last_pixel )
d267 18
a284 38
		/* Obtain fresh copy of application struct */
		a = ap;				/* struct copy */
		a.a_resource = &resource[cpu];

		if( incr_mode )  {
			register int i = 1<<incr_level;
			a.a_x = com%i;
			a.a_y = com/i;
			if( incr_level != 0 )  {
				/* See if already done last pass */
				if( ((a.a_x & 1) == 0 ) &&
				    ((a.a_y & 1) == 0 ) )
					continue;
			}
			a.a_x <<= (incr_nlevel-incr_level);
			a.a_y <<= (incr_nlevel-incr_level);
		} else {
			a.a_x = com%width;
			a.a_y = com/width;
		}
		VSETALL( colorsum, 0 );
		for( com=0; com<=hypersample; com++ )  {
			if( jitter )  {
				FAST fastf_t dx, dy;
				dx = a.a_x + rand_half(a.a_resource->re_randptr);
				dy = a.a_y + rand_half(a.a_resource->re_randptr);
				VJOIN2( point, viewbase_model,
					dx, dx_model, dy, dy_model );
			}  else  {
				VJOIN2( point, viewbase_model,
					a.a_x, dx_model,
					a.a_y, dy_model );
			}
			if( rt_perspective > 0.0 )  {
				VSUB2( a.a_ray.r_dir,
					point, eye_model );
				VUNITIZE( a.a_ray.r_dir );
				VMOVE( a.a_ray.r_pt, eye_model );
d286 2
a287 2
				VMOVE( a.a_ray.r_pt, point );
			 	VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );
d289 13
a301 11
			a.a_level = 0;		/* recursion level */
			a.a_purpose = "main ray";
			rt_shootray( &a );

			if( stereo )  {
				FAST fastf_t right,left;

				right = CRT_BLEND(a.a_color);

				VSUB2(  point, point,
					left_eye_delta );
d306 1
a306 1
					VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
d309 1
d312 1
a312 1
				a.a_purpose = "left eye ray";
d315 23
a337 2
				left = CRT_BLEND(a.a_color);
				VSET( a.a_color, left, 0, right );
d339 8
a346 6
			VADD2( colorsum, colorsum, a.a_color );
		}
		if( hypersample )  {
			FAST fastf_t f;
			f = 1.0 / (hypersample+1);
			VSCALE( a.a_color, colorsum, f );
a347 3
		view_pixel( &a );
		if( a.a_x == width-1 )
			view_eol( &a );		/* End of scan line */
@


10.8
log
@Added include of conf.h
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 10.7 1994/05/07 21:16:11 mike Exp gdurf $ (BRL)";
@


10.7
log
@Added array bounds protection
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 10.6 94/05/07 20:49:09 mike Exp Locker: mike $ (BRL)";
d22 2
@


10.6
log
@Made checking independent of whether running parallel or not.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 10.5 94/05/06 02:59:19 mike Exp Locker: mike $ (BRL)";
d244 1
@


10.5
log
@It is necessary to initialize nworkers_started & nworkers_finished
even in the serial case, as REMRT makes many calls on do_run().
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 10.4 94/05/05 23:00:11 mike Exp $ (BRL)";
d190 1
d197 13
a209 14

		/*
		 *  Ensure that all the workers are REALLY finished.
		 *  On some systems, if threads core dump, the rest of
		 *  the gang keeps going, so this can actually happen (sigh).
		 */
		if( nworkers_finished != npsw )  {
			rt_log("\n***ERROR: %d workers did not finish!\n\n",
				npsw - nworkers_finished);
		}
		if( nworkers_started != npsw )  {
			rt_log("\nNOTICE:  only %d workers started, expected %d\n",
				nworkers_started, npsw );
		}
@


10.4
log
@Some workers can finish before others even get started!
Keep separate counters.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 10.3 93/04/05 21:18:53 phil Exp Locker: mike $ (BRL)";
d184 2
a194 2
		nworkers_started = 0;
		nworkers_finished = 0;
@


10.3
log
@Added cell_newsize.  See opt.c.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 10.2 1992/10/27 16:03:32 mike Exp phil $ (BRL)";
d39 2
a40 1
HIDDEN int nworkers;		/* number of workers now running */
d193 2
a194 1
		nworkers = 0;
d202 1
a202 1
		if( nworkers > 0 )  {
d204 1
a204 1
				nworkers);
d206 4
d241 1
a241 1
	cpu = nworkers++;
d336 1
a336 1
	nworkers--;
@


10.2
log
@Check validity of cell sizes and pixel counts.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 10.1 91/10/12 06:42:27 mike Rel4_0 Locker: mike $ (BRL)";
d68 3
a70 2
	if( cell_width > 0.0 && width <= 0)  {
		if( cell_height <= 0.0 )  cell_height = cell_width;
d73 2
a74 1
	} else if( cell_width <= 0.0 && width > 0 )  {
a77 2
	} else {
		/* Do nothing, both are already set */
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 9.8 91/10/12 04:44:09 mike Exp $ (BRL)";
d155 12
@


9.8
log
@Added XMP bug-check.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 9.7 91/10/01 02:44:09 mike Exp Locker: mike $ (BRL)";
@


9.7
log
@Call rt_add_res_stats to add up all the per-cpu statistics
and make rt_i structure look like it did before.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 9.6 91/06/23 00:21:34 mike Exp Locker: mike $ (BRL)";
d195 5
a199 1
	for( cpu=0; cpu < npsw; cpu++ )
d201 1
@


9.6
log
@Removed #if 0 debugging stuff
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 9.5 91/06/22 06:27:00 mike Exp $ (BRL)";
d166 2
d176 16
a191 1
		return;
d194 4
a197 15
	/*
	 *  Parallel case.
	 */
	nworkers = 0;
	rt_parallel( worker, npsw );

	/*
	 *  Ensure that all the workers are REALLY finished.
	 *  On some systems, if threads core dump, the rest of
	 *  the gang keeps going, so this can actually happen (sigh).
	 */
	if( nworkers > 0 )  {
		rt_log("\n***ERROR: %d workers did not finish!\n\n",
			nworkers);
	}
d233 1
a233 1
		/* Note: ap.... may not be valid until first time here */
@


9.5
log
@Oops, left gift_grid_rounding non-zero!
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 9.4 91/06/19 00:08:44 mike Exp $ (BRL)";
a110 14
#if 0
VPRINT("hv_wanted", hv_wanted);
VPRINT("hv_delta", hv_delta);
VPRINT("m_delta", m_delta);

		/* As a check, go again... */
		VSET( v_ll, -1, -1, 0 );
		MAT4X3PNT( m_ll, view2model, v_ll );
		MAT4X3PNT( hv_ll, model2hv, m_ll );
		VSET( hv_wanted, floor(hv_ll[X]), floor(hv_ll[Y]),floor(hv_ll[Z]) );
		VSUB2( hv_delta, hv_ll, hv_wanted );
VPRINT("hv_wanted", hv_wanted);
VPRINT("check hv_delta", hv_delta );
#endif
@


9.4
log
@Added GIFT-style grid rounding, as an option
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 9.3 90/10/06 02:48:13 mike Exp $ (BRL)";
d32 1
a32 1
fastf_t		gift_grid_rounding = 25.4;	/* set to 25.4 for inches */
@


9.3
log
@Changed to more reasonable policy of noting that some workers
did not finish, rather than looping (usually forever), waiting
for them to finish.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: /m/cad/rt/RCS/worker.c,v 9.2 89/11/20 16:58:12 mike Exp $ (BRL)";
d32 4
a36 1
HIDDEN point_t	viewbase_model;	/* model-space location of viewplane corner */
d43 8
d62 1
a62 3
	toEye[MDX] = -eye_model[X];
	toEye[MDY] = -eye_model[Y];
	toEye[MDZ] = -eye_model[Z];
d67 1
a67 1
	/* Determine grid spacing and orientation */
d79 49
@


9.2
log
@If cell_width is set and width is not set, calculate one way.
If the reverse case is true, calculate the other way.
Otherwise, just use previous values.
This prevents the values from wandering +/-1 from frame to frame!
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 9.1 89/05/19 06:00:05 mike Locked $ (BRL)";
a121 2
	int	x;

d139 9
a147 4
	/* Ensure that all the workers are REALLY dead */
	x = 0;
	while( nworkers > 0 )  x++;
	if( x > 0 )  rt_log("do_run(%d,%d): termination took %d extra loops\n", a, b, x);	
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 8.8 89/04/30 21:26:11 mike Exp $ (BRL)";
d59 1
a59 1
	if( cell_width > 0.0 )  {
d61 3
a63 3
		width = viewsize / cell_width;
		height = viewsize / (cell_height*aspect);
	} else {
d67 2
@


8.8
log
@The rand() macros now require a parameter which is the random number
table pointer to be used.  This provides perfectly "safe" access to
the random number tables in a parallel processing environment.
Each processor is seeded differently in worker.c
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 8.7 89/04/14 14:10:22 mike Locked $ (BRL)";
@


8.7
log
@removed comment that no longer applies
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 8.6 89/04/13 05:02:37 mike Locked $ (BRL)";
d168 1
d202 2
a203 2
				dx = a.a_x + rand_half();
				dy = a.a_y + rand_half();
@


8.6
log
@Added magic number initialization
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 8.5 89/04/03 20:49:31 mike Locked $ (BRL)";
a155 1
	/* breaks when a is static (default for LOCAL) or global, okay if auto */
@


8.5
log
@Added support for -g cell_width and -G cell_height options,
which included rearranging some calculations, because
grid_setup() can now change the values of width and height.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 8.4 89/04/03 19:53:53 mike Locked $ (BRL)";
d28 1
a31 28
/***** view.c variables imported from rt.c *****/
extern mat_t	view2model;
extern mat_t	model2view;

/***** worker.c variables imported from opt.c *****/
extern void	worker();
extern struct application ap;
extern int	stereo;			/* stereo viewing */
extern vect_t	left_eye_delta;
extern int	hypersample;		/* number of extra rays to fire */
extern int	jitter;			/* jitter ray starting positions */
extern fastf_t	rt_perspective;		/* persp (degrees X) 0 => ortho */
extern fastf_t	aspect;			/* view aspect ratio X/Y */
extern vect_t	dx_model;		/* view delta-X as model-space vect */
extern vect_t	dy_model;		/* view delta-Y as model-space vect */
extern fastf_t	cell_width;		/* model space grid cell width */
extern fastf_t	cell_height;		/* model space grid cell height */
extern point_t	eye_model;		/* model-space location of eye */
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
extern mat_t	Viewrotscale;
extern fastf_t	viewsize;
extern int	incr_mode;		/* !0 for incremental resolution */
extern int	incr_level;		/* current incremental level */
extern int	incr_nlevel;		/* number of levels */
extern int	npsw;
extern struct resource resource[];

a165 1
/*printf("cpu = %d, &resource[0] = 0x%x\n", cpu, &resource[0]);*/
d168 1
d177 1
a179 1
/*		bcopy( &ap, &a, sizeof(a) );*/
d181 1
a181 1
/*printf("cpu = %d, &resource[0] = 0x%x\n", cpu, &resource[0]);*/
@


8.4
log
@Noted some areas that show up problems
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 8.3 88/12/28 22:49:15 phil Locked $ (BRL)";
d35 1
a35 1
/***** worker.c variables imported from rt.c *****/
d46 2
d85 18
a102 5
	/* Chop -1.0..+1.0 range into parts */
	VSET( temp, 2.0/width, 0, 0 );
	MAT4X3VEC( dx_model, view2model, temp );
	VSET( temp, 0, 2.0/(height*aspect), 0 );
	MAT4X3VEC( dy_model, view2model, temp );
@


8.3
log
@Testing of rt_perspective made more portable (avoids SGI 3-d bug)
Added check for zero-radius beam.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 8.2 88/10/23 05:00:57 mike Locked $ (BRL)";
d168 1
d178 1
d191 1
d193 1
@


8.2
log
@worker no longer takes an argument
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 8.1 88/10/05 00:33:46 phil Locked $ (BRL)";
d97 1
a97 1
	if( rt_perspective )  {
d118 2
d219 1
a219 1
			if( rt_perspective )  {
d239 1
a239 1
				if( rt_perspective )  {
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.10 88/09/17 06:14:09 mike Exp $ (BRL)";
d139 1
a139 1
		worker(0);
@


7.10
log
@worker no longer takes any parameters.
This is necessary for systems like the Ardent and Stellar
which have very lightweight threads that start with no stack.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.9 88/08/20 07:18:37 mike Locked $ (BRL)";
@


7.9
log
@a separate persp_angle went away.  rt_perspective == 0 implies ortho.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.8 88/08/09 17:53:22 phil Locked $ (BRL)";
a30 4
#ifdef HEP
# include <synch.h>
#endif

d164 1
a164 2
worker(cpu)
int cpu;
d170 1
d173 1
a173 1
	com = nworkers++;
@


7.8
log
@added jitter flag for ray position randomization (decoupled from -H).
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.7 88/06/16 02:49:36 phil Locked $ (BRL)";
d46 1
a46 1
extern int	rt_perspective;		/* perspective view -vs- parallel */
a47 1
extern fastf_t	persp_angle;		/* perspective angle (degrees X) */
d104 1
a104 1
		zoomout = 1.0 / tan( mat_degtorad * persp_angle / 2.0 );
@


7.7
log
@aspect was changed to more conventional X/Y
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.6 88/05/14 02:28:50 phil Locked $ (BRL)";
d45 1
d211 1
a211 1
			if( hypersample )  {
@


7.6
log
@lint fixes
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.5 88/01/27 07:01:27 mike Locked $ (BRL)";
d46 1
a46 1
extern fastf_t	aspect;			/* aspect ratio Y/X */
d90 1
a90 1
	VSET( temp, 0, 2.0*aspect/height, 0 );
d105 1
a105 1
		VSET( temp, -1, -aspect, -zoomout );	/* viewing plane */
d118 1
a118 1
		VSET( temp, -1, -aspect, 0 );	/* eye plane */
@


7.5
log
@do_run now greatly shortened -- much of the hard work has been
moved to librt/machine.c
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.4 88/01/25 23:40:14 mike Locked $ (BRL)";
d131 1
@


7.4
log
@aspect and perspective angle control
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.3 88/01/22 21:05:56 phil Locked $ (BRL)";
a57 1
extern int	parallel;		/* Trying to use multi CPUs */
a66 8
#ifdef cray
struct taskcontrol {
	int	tsk_len;
	int	tsk_id;
	int	tsk_value;
} taskcontrol[MAX_PSW];
#endif

a129 5
 *  Don't use registers in this function.  At least on the Alliant,
 *  register context is NOT preserved when exiting the parallel mode,
 *  because the serial portion resumes on some arbitrary processor,
 *  not necessarily the one that serial execution started on.
 *  The registers are not shared.
a132 3
#ifdef alliant
	register int d7;	/* known to be in d7 */
#endif
a133 1
	int	pid;
d138 1
a138 1
	if( !parallel )  {
d147 1
a147 2
	 *  Parallel case.  This is different for each system.
	 *  The parallel workers are started and terminated here.
d150 2
a151 33
#ifndef CRAY_COS
	pid = getpid();
#endif CRAY_COS
#ifdef HEP
	for( x=1; x<npsw; x++ )  {
		/* This is more expensive when GEMINUS>1 */
		Dcreate( worker, x );
	}
	worker(0);	/* avoid wasting this task */
#endif HEP
#ifdef cray
	/* Create any extra worker tasks */
	for( x=1; x<npsw; x++ ) {
		taskcontrol[x].tsk_len = 3;
		taskcontrol[x].tsk_value = x;
		TSKSTART( &taskcontrol[x], worker, x );
	}
	worker(0);	/* avoid wasting this task */
	/* Wait for them to finish */
	for( x=1; x<npsw; x++ )  {
		TSKWAIT( &taskcontrol[x] );
	}
#endif
#ifdef alliant
	{
		asm("	movl		_npsw,d0");
		asm("	subql		#1,d0");
		asm("	cstart		d0");
		asm("super_loop:");
		worker(d7);		/* d7 has current index, like magic */
		asm("	crepeat		super_loop");
	}
#endif
a155 15

#ifndef CRAY_COS
	/*
	 * At this point, all multi-tasking activity should have ceased,
	 * and we should be just a single UNIX process with our original
	 * PID and open file table (kernel struct u).  If not, then any
	 * output is going to be written into the wrong file.
	 * Both CRAY machines are known to get this wrong. XXX
	 */
	if( pid != (x=getpid()) )  {
		rt_log("\n**ERROR** do_run:  PID changed from %d to %d, open file table probably botched!\n\n",
			pid, x );
		/* rt_bomb( "files scrambled" ); */
	}
#endif CRAY_COS
@


7.3
log
@removed a_onehit=1, the decision wasn't his to make
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.2 88/01/15 14:52:26 phil Locked $ (BRL)";
d24 1
d46 2
a54 1
extern fastf_t	zoomout;
d99 1
a99 1
	VSET( temp, 0, 2.0/height, 0 );
d103 1
a103 1
		VSET( temp, 2.0*(-63.5/viewsize), 0, 0 );
d111 4
a114 1
		VSET( temp, -1, -1, -zoomout );	/* viewing plane */
d122 1
d127 1
a127 1
		VSET( temp, -1, -1, 0 );	/* eye plane */
@


7.2
log
@perspective is a common library name in some graphics librariues
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 7.1 87/11/02 23:57:00 stay Locked $ (BRL)";
a238 1
	ap.a_onehit = 1;
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 6.4 87/10/14 20:49:57 mike Exp $ (BRL)";
d44 1
a44 1
extern int	perspective;		/* perspective view -vs- parallel */
d108 1
a108 1
	if( perspective )  {
d280 1
a280 1
			if( perspective )  {
d300 1
a300 1
				if( perspective )  {
@


6.4
log
@Added additional multi-processor botch protection
(which catches the Crays red-handed).
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 6.3 87/09/26 07:57:21 mike Locked $ (BRL)";
@


6.3
log
@Added check to make sure that viewsize has been set.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 6.2 87/09/03 01:30:50 mike Locked $ (BRL)";
d144 2
a145 1
	int x;
d163 3
d199 16
a214 1
	if( x > 0 )  rt_log("do_run(%d,%d): termination took %d extra loops\n", a, b, x);
@


6.2
log
@Added incremental resolution capability.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 6.1 87/07/11 07:59:47 mike Rel $ (BRL)";
d83 2
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 5.5 87/07/10 07:27:43 mike Exp $ (BRL)";
d53 3
d230 16
a245 2
		a.a_x = com%width;
		a.a_y = com/width;
@


5.5
log
@Fixed horrid parallel bug.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 5.4 87/07/09 03:31:36 mike Locked $ (BRL)";
@


5.4
log
@Changed parallel support from #ifdef to runtime determination.
Added 3 types of libfb interaction
Misc. cleanups.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 5.3 87/07/06 15:08:39 mike Locked $ (BRL)";
a213 1
	a.a_resource = &resource[cpu];
d215 1
a215 1
	a.a_onehit = 1;
d226 1
@


5.3
log
@Added two a_purpose strings.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 5.2 87/06/25 22:29:58 mike Locked $ (BRL)";
d53 1
d144 8
a151 1
#ifdef PARALLEL
a190 6
#else
	/*
	 * SERIAL case -- one CPU does all the work.
	 */
	worker(0);
#endif
@


5.2
log
@Changed to fully initialize local application struct.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 5.1 87/06/24 22:15:53 mike Locked $ (BRL)";
d250 1
d269 1
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 4.7 87/05/30 07:05:03 mike Exp $ (BRL)";
d224 1
a226 5
		a.a_hit = ap.a_hit;
		a.a_miss = ap.a_miss;
		a.a_rt_i = ap.a_rt_i;
		a.a_rbeam = ap.a_rbeam;
		a.a_diverge = ap.a_diverge;
@


4.7
log
@Added code for non-square views, single pixel (-b) debugging.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 4.6 87/04/10 07:03:48 mike Locked $ (BRL)";
@


4.6
log
@Minor changes to split rt.c into rt.c and do.c,
plus reintegration with remrt/rtsrv.c
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 4.5 87/03/25 17:28:36 phil Exp $ (BRL)";
d41 1
a41 1
extern int	stereo;		/* stereo viewing */
d43 7
a49 6
extern int	hypersample;	/* number of extra rays to fire */
extern int	perspective;	/* perspective view -vs- parallel view */
extern vect_t	dx_model;	/* view delta-X as model-space vector */
extern vect_t	dy_model;	/* view delta-Y as model-space vector */
extern point_t	eye_model;	/* model-space location of eye */
extern int	npts;		/* # of points to shoot: x,y */
d88 2
a89 2
	/* Chop -1.0..+1.0 range into npts parts */
	VSET( temp, 2.0/npts, 0, 0 );
d91 1
a91 1
	VSET( temp, 0, 2.0/npts, 0 );
d105 1
a105 1
		 * Divergance is (0.5 * viewsize / npts) mm at
d108 1
a108 1
		ap.a_diverge = (0.5 / npts) / zoomout;
d116 1
a116 1
		ap.a_rbeam = 0.5 * viewsize / npts;
d224 2
a225 2
		a.a_x = com%npts;
		a.a_y = com/npts;
d285 1
a285 1
		if( a.a_x == npts-1 )
@


4.5
log
@fixed stereo code; removed include nit.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 4.4 87/03/17 20:19:28 phil Locked $ (BRL)";
d30 4
a47 1
extern point_t	viewbase_model;	/* model-space location of viewplane corner */
d56 1
d145 1
a145 3
	 *  In the case of the HEP, the workers were started in
	 *  the mainline;  for other systems, the workers are
	 *  started and terminated here.
d148 7
a156 1
RES_ACQUIRE( &rt_g.res_worker );
a161 2
for( x=0; x<1000000; x++ ) a=x+1;	/* take time to get started */
RES_RELEASE( &rt_g.res_worker );
@


4.4
log
@Added multiple lights, added beginnings of command-driven
input capability.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 4.3 87/02/13 05:11:03 mike Exp $ (BRL)";
d27 1
a27 1
#include "../rt/mathtab.h"
d254 1
a254 1
				VADD2(  point, point,
d260 1
a260 1
					VMOVE( a.a_ray.r_pt, eye_model );
@


4.3
log
@Release 1.20 (really) -- First Formal Release

Added PARALLEL fix to remove assumption that the hardware
had parallel-protected byte-splicing for pixel buffer output.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 4.2 87/02/13 00:03:17 mike Exp $ (BRL)";
a51 8
#ifdef RTSRV
extern char scanbuf[];
#else
#ifdef PARALLEL
extern char *scanbuf;		/*** Output buffering, for parallelism */
#endif
#endif

a276 1
#if !defined(PARALLEL) && !defined(RTSRV)
a279 34
#endif
#if defined(PARALLEL) || defined(RTSRV)
		{
			register char *pixelp;
			register int r,g,b;

			/* .pix files go bottom to top */
#ifdef RTSRV
			/* Here, the buffer is only one line long */
			pixelp = scanbuf+a.a_x*3;
#else
			pixelp = scanbuf+((a.a_y*npts)+a.a_x)*3;
#endif
			r = a.a_color[0]*255.+rand_half();
			g = a.a_color[1]*255.+rand_half();
			b = a.a_color[2]*255.+rand_half();
			/* Truncate glints, etc */
			if( r > 255 )  r=255;
			if( g > 255 )  g=255;
			if( b > 255 )  b=255;
			if( r<0 || g<0 || b<0 )  {
				rt_log("Negative RGB %d,%d,%d\n", r, g, b );
				r = 0x80;
				g = 0xFF;
				b = 0x80;
			}
			/* Don't depend on interlocked hardware byte-splice */
			RES_ACQUIRE( &rt_g.res_worker );
			*pixelp++ = r ;
			*pixelp++ = g ;
			*pixelp++ = b ;
			RES_RELEASE( &rt_g.res_worker );
		}
#endif
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 4.1 86/12/29 03:49:07 mike Rel1 $ (BRL)";
d315 2
d320 1
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 1.9 86/12/29 01:55:02 mike Locked $ (BRL)";
@


1.9
log
@Alliant fix for new worker() calling sequence.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 1.8 86/12/24 08:31:21 mike Locked $ (BRL)";
@


1.8
log
@Updated for resource struct
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 1.7 86/12/18 16:07:04 mike Locked $ (BRL)";
d138 3
d176 1
a176 2
		/******** need to push index here as arg ******/
		worker();
@


1.7
log
@rdebug.h separated from librt/debug.h
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 1.6 86/12/05 16:11:37 mike Exp $ (BRL)";
d31 2
a32 2
extern mat_t view2model;
extern mat_t model2view;
d35 1
a35 1
extern void worker();
d38 1
a38 1
extern vect_t left_eye_delta;
d45 6
a50 5
extern int npts;	/* # of points to shoot: x,y */
extern mat_t Viewrotscale;
extern fastf_t viewsize;
extern fastf_t zoomout;
extern int npsw;
a209 3
#ifdef PARALLEL
rt_log("Worker %d running on cpu %d, rt_g=0%o, ap=0%o\n", com, cpu, &rt_g, &ap);
#endif
d211 2
d214 1
@


1.6
log
@Added extern.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 1.5 86/11/25 04:32:44 mike Locked $ (BRL)";
d28 1
d152 2
a153 2

	for( x=0; x<npsw; x++ ) {
d156 1
a156 1
		TSKSTART( &taskcontrol[x], worker );
d158 3
d162 1
a162 1
	for( x=0; x<npsw; x++ )  {
d172 1
d185 1
a185 1
	worker();
d198 2
a199 1
worker()
d207 1
a207 1
	nworkers++;
d209 3
@


1.5
log
@Moved declarations more local.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 1.4 89/10/31 04:36:26 mike Locked $ (BRL)";
d54 1
a54 1
char *scanbuf;		/*** Output buffering, for parallelism */
@


1.4
log
@Changed RCSid string for Cray.
@
text
@d20 1
a20 1
static char RCSworker[] = "@@(#)$Header: worker.c,v 1.3 86/10/29 01:32:30 mike Locked $ (BRL)";
a45 1
extern mat_t toEye;
d77 2
a78 1
	static vect_t temp;
@


1.3
log
@Improved error print.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: worker.c,v 1.2 86/10/28 23:25:45 mike Locked $ (BRL)";
@


1.2
log
@Parallel reorganization
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: worker.c,v 1.1 86/10/26 18:38:02 mike Locked $ (BRL)";
d175 1
a175 1
	if( x > 0 )  rt_log("y=%d: termination took %d extra loops\n", y, x);
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.17 86/10/12 00:20:44 mike Locked $ (BRL)";
d27 1
a27 1
#include "./mathtab.h"
d34 1
a44 2
extern int cur_pixel;		/* current pixel number, 0..last_pixel */
extern int last_pixel;		/* last pixel number */
d49 1
d51 3
d57 1
d59 13
d123 14
d138 46
d200 4
d206 1
a206 1
		RES_ACQUIRE( &rt_g.res_printf );	/* HACK */
d208 1
a208 1
		RES_RELEASE( &rt_g.res_printf );	/* HACK */
d210 3
a212 2
		if( com > last_pixel )  return;
		/* Note: ap.... not valid until first time here */
d273 1
a273 1
#ifndef PARALLEL
d277 2
a278 1
#else
d282 1
d284 4
d289 1
d309 3
@
