head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.2
	premerge-autoconf:11.11
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.3
	offsite-5-3-pre:11.5
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.17.31.06;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.02.21.38.30;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.02.15.05.14;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	2001.03.31.01.57.31;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.25.01.28.00;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.17.02.41.35;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.05.28.01.17.25;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.08.27.03.20.36;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.56;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.00.39.34;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.00;	author mike;	state Rel4_0;
branches;
next	1.8;

1.8
date	91.06.27.10.21.05;	author sue;	state Exp;
branches;
next	1.7;

1.7
date	91.06.03.15.41.34;	author sue;	state Exp;
branches;
next	1.6;

1.6
date	91.06.03.15.27.03;	author sue;	state Exp;
branches;
next	1.5;

1.5
date	91.05.31.14.02.59;	author sue;	state Exp;
branches;
next	1.4;

1.4
date	91.05.22.15.21.25;	author sue;	state Exp;
branches;
next	1.3;

1.3
date	91.05.17.15.56.34;	author sue;	state Exp;
branches;
next	1.2;

1.2
date	91.05.16.11.04.26;	author sue;	state Exp;
branches;
next	1.1;

1.1
date	91.05.14.15.27.59;	author sue;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.22.59;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.48.07;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	11.10.10.2;

11.10.10.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@This program constructs a registration matrix from two input files.
These files are the RT log files for a UNIX-Plot file to be registered
with a pixel file.  The RT logfile of the pixel file is the second
input.  The objective is to then translate and scale the plot file
so it can be registered with the pixel file.  IT IS ASSUMED THAT BOTH
IMAGES WERE RAY-TRACED FROM THE SAME ORIENTATION.
At this time, the files are read and individual matrices are constructed.
Translation deltas between the matrices are found and recorded, and the
size of the images is scaled.
@


11.14
log
@moved to src/rt/
@
text
@/*                    R E G I S T E R
*
*  This is a program will register a Unix-Plot file with its companion
*  pix file.  It is assumed that both images were ray-traced at the same
*  rotation.  A homogeneous transformation matrix is constructed from the
*  RT log files of the two images.  This matrix will permit the translation
*  and scaling of the plot file so that it can be readily overlaid onto its
*  pixel image mate.
*  
*  It is expected that the first log file given corresponds to the image
*  file to be overlaid onto the image that corresponds to the second log
*  file.  Also for the moment it is expected that the first log will
*  correspond to a Unix-Plot file, whereas the second will correspond to a
*  pixel file.  If both images where Unix-Plot files, they can be overlaid
*  by simply concatentating them: "cat file.pl file.pl >> out.pl"
*
*  The program conisists of three parts:
*	1) take view, orientation, eye_position, and size from two rt log 
*          files, and use this information to build up the registration matrix;
*	2) puts out a registration matrix and a new space command to be
*	   used by plrot in lieu of -a#, -e#, -g to rotate/transform the 
*	   UNIX_Plot file
*			and
*	3) involve pix-fb -o to do the overlaying of the actual files.
*	4) Note: two pixel files (one lo-res, one hi-res) will be registered
*	   later in a slightly different way.
*
*  Authors -
*	Susanne L. Muuss, J.D.
*	
*
*  Source -
*	SECAD/VLD Computing Consortium, Bldg. 394
*	The U. S. Army Ballistic Reasearch Laboratory
*	Aberdeen Proving Ground, Maryland  21005
*
*  Copyright Notice -
*	This software is Copyright (C) 1991-2004 by the United States Army.
*	All rights reserved.
*/
#ifndef lint
static const char RCSregis[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/rtregis.c,v 11.13 2004/05/10 15:30:49 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"

#define NAMELEN 40
#define BUFF_LEN 256
#define FALSE 0
#define TRUE 1

char usage[] = "\
Usage:  regis plot.log pix.log\n";


int	mat_build(fastf_t *mat1, fastf_t *mat2, fastf_t *regismat);
int	read_rt_file(FILE *infp, char *name, fastf_t *model2view);
void	print_info(fastf_t *mat);

static FILE	*fp;
int		verbose;		/* to be used for debugging */

/*
 *
 *                     M A I N
 *
 *  Main exists to coordinate the actions of the parts of this program.
 *  It also processes its own arguments (argc and argv).
 */
int
main(int argc, char **argv)
{

	mat_t		mod2view1;		/* first log matrix its view */
	mat_t		mod2view2;		/* second log matrix to its view*/
	mat_t		regismat;		/* registration matrix */
	mat_t		view2model;		/* matrix for converting from view to model space */
	int		ret;			/* function return code */

	MAT_IDN(mod2view1);				/* makes an identity matrix */
	MAT_IDN(mod2view2);
	MAT_IDN(regismat);

	/* Check to see that the correct format is given, else print
	 * usage message.
	 */

	if(argc != 3)  {
		fputs(usage, stderr);
		exit(-1);
	}

	/* Now process the arguments from main: i.e. open the log files
	 * for reading and send to read_rt_file().
	 * Send read_rt_file() a pointer to local model matrix 
	 * and to the appropriate log file. 
	 * ( Note &view2model[0] can be used, but is not elegant.)
	 */

	fp = fopen(argv[1], "r");
	if( fp == NULL )  {
		perror(argv[1]);
		exit(-1);
	}

	ret = read_rt_file(fp, argv[1], mod2view1);
	if(ret < 0)  {
		exit(-1);
	}
	fclose(fp);		/* clean up */

	fp = fopen(argv[2], "r");
	if( fp == NULL )  {
		perror(argv[2]);
		exit(-1);
	}

	ret = read_rt_file(fp, argv[2], mod2view2);
	if(ret < 0)  {
		exit(-1);
	}

	fclose(fp);

	if(verbose)  {
		bn_mat_inv(view2model, mod2view1);
		bn_mat_print("mod2view1-plot.log", mod2view1);
		bn_mat_print("mod2view2-pix.log", mod2view2);
		fprintf(stderr, "mod2view1[0, 1, 2, 3, 15]: %.6f, %.6f, %.6f, %.6f, %.6f\n",
		mod2view1[0], mod2view1[1], mod2view1[2], mod2view1[3], mod2view1[15]);
	}

	/* Now build the registration matrix for the two files. */

	ret = mat_build(mod2view1, mod2view2, regismat);
	if(ret == FALSE)  {
		fprintf(stderr, "regis: can't build registration matrix!\n");
		exit(-1);
	}
	print_info(regismat);	
	exit(0);

}


/*
 *		 M A T _ B U I L D
 *
 * This routine takes pointers to two matices corresponding to the two
 * files to be registered and a registration matrix.
 * It builds the registration matrix.  It returns success or failure.
 */

int
mat_build(fastf_t *mat1, fastf_t *mat2, fastf_t *regismat)
{

	vect_t	adelta, bdelta;		/* deltas for mod1 and mod2 */
	vect_t	delta;			/* difference bet. mod1 and mod2 deltas */
	fastf_t	scale;

	/* At this point it is important to check that the rotation part
	 * of the matices is within a certain tolerance: ie. that the
	 * two images were raytraced from the same angle.  No overlays will
	 * be possible if they are not at the same rotation.
	 */

	/* Now record the deltas: the translation part of the matrix. */
	VSET(adelta, mat1[MDX], mat1[MDY], mat1[MDZ]);
	VSET(bdelta, mat2[MDX], mat2[MDY], mat2[MDZ]);

	/* Take the difference between the deltas. Also scale the size
	 * of the model (scale).  These will be used to register two
	 * pixel files later on.
	 */

	VSUB2(delta, adelta, bdelta);
	scale = mat1[15]/mat2[15];

	VPRINT("delta", delta);
	fprintf(stderr, "scale: %.6f\n", scale);	

	/* If the first log corresponds to a UNIX-Plot file, following
	 * applies.  Since UNIX-Plot files are in model coordinates, the 
	 * mod2view2 ("model2pix") is also the registration matrix.  In
	 * this case, pl-fb needs to learn that the UNIX-Plot file's space
	 * runs from -1 -> 1 in x and y.  This can be done by adding an
	 * alternate space command in that program. Therefore the below
	 * applies.
	 * What if the first log corresponds to a hi-res pixel file to be
	 * registered with a lo-res pixel file?  Then the above calculated
	 * deltas are used.   This will be implemented later.
	 */

	MAT_COPY( regismat, mat2);
	bn_mat_print("regismat", regismat);
	return(1);				/* OK */
}


/*		P R I N T _ I N F O
 *
 *  This routine takes as its input parameter a registration matrix.  Its
 *  sole task is to print this matrix out in a form usable by plrot.  It
 *  also prints out the parameters for the new space command for plrot.
 */

void
print_info(fastf_t *mat)
{

	int	i;

	fprintf(stdout, "plrot -m\"");
	for( i = 0; i < 15; i++ )  {
		fprintf(stdout, "%.6f ", mat[i]);
	}
	fprintf(stdout, "%g\" -S\"-1 -1 -1 1 1 1\"\n", mat[15]);
	return;
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /cvs/brlcad/rt/rtregis.c,v 11.12 2004/04/05 05:45:58 morrison Exp $";
@


11.12
log
@merge of ansi-6-0-branch into head
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header$";
d45 5
a49 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.10 2002/08/20 17:08:38 jra Exp $";
d70 3
a72 3
int	mat_build();
int	read_rt_file();
void	print_info();
d85 1
a85 4
main(argc, argv)
int	argc;
char	**argv;

d169 1
a169 4
mat_build(mat1, mat2, regismat)
mat_t	mat1;
mat_t	mat2;
mat_t	regismat;
d223 1
a223 2
print_info(mat)
mat_t	mat;
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d38 1
a38 1
*	This software is Copyright (C) 1991 by the United States Army.
d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.8 2001/04/02 21:38:30 morrison Exp $";
@


11.10.4.1
log
@sync to HEAD...
@
text
@d38 1
a38 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/rtregis.c,v 11.11 2004/02/02 17:39:39 morrison Exp $";
@


11.10.10.1
log
@merge from HEAD
@
text
@d38 1
a38 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.11 2004/02/02 17:39:39 morrison Exp $";
@


11.10.10.2
log
@merge from head
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.10.10.1 2004/02/12 19:37:13 erikg Exp $";
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.10 2002/08/20 17:08:38 jra Exp $";
d70 3
a72 3
int	mat_build(fastf_t *mat1, fastf_t *mat2, fastf_t *regismat);
int	read_rt_file(FILE *infp, char *name, fastf_t *model2view);
void	print_info(fastf_t *mat);
d85 4
a88 1
main(int argc, char **argv)
d172 4
a175 1
mat_build(fastf_t *mat1, fastf_t *mat2, fastf_t *regismat)
d229 2
a230 1
print_info(fastf_t *mat)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d38 1
a38 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header$";
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d70 3
a72 3
int	mat_build(fastf_t *mat1, fastf_t *mat2, fastf_t *regismat);
int	read_rt_file(FILE *infp, char *name, fastf_t *model2view);
void	print_info(fastf_t *mat);
d85 4
a88 1
main(int argc, char **argv)
d172 4
a175 1
mat_build(fastf_t *mat1, fastf_t *mat2, fastf_t *regismat)
d229 2
a230 1
print_info(fastf_t *mat)
@


11.8
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.7 2001/04/02 15:05:14 jra Exp $";
d70 3
a72 3
int	mat_build();
int	read_rt_file();
void	print_info();
d85 1
a85 4
main(argc, argv)
int	argc;
char	**argv;

d169 1
a169 4
mat_build(mat1, mat2, regismat)
mat_t	mat1;
mat_t	mat2;
mat_t	regismat;
d223 1
a223 2
print_info(mat)
mat_t	mat;
@


11.7
log
@Lint
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.6 2001/03/31 01:57:31 morrison Exp $";
d215 1
a215 1
	bn_mat_copy( regismat, mat2);
@


11.6
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.5 2000/08/25 01:28:00 mike Exp $";
d48 7
@


11.5
log
@
lint
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.4 2000/08/17 02:41:35 mike Exp $";
d90 3
a92 3
	bn_mat_idn(mod2view1);				/* makes an identity matrix */
	bn_mat_idn(mod2view2);
	bn_mat_idn(regismat);
@


11.4
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d42 1
a42 1
static const char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.3 1999/05/28 01:17:25 mike Exp $";
d77 1
a77 1

@


11.3
log
@
sed4
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtregis.c,v 11.2 1996/08/27 03:20:36 mike Exp $";
@


11.2
log
@bu.h
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /m/cad/rt/RCS/rtregis.c,v 11.1 1995/01/04 10:00:56 mike Rel4_4 mike $";
d90 3
a92 3
	mat_idn(mod2view1);				/* makes an identity matrix */
	mat_idn(mod2view2);
	mat_idn(regismat);
d136 3
a138 3
		mat_inv(view2model, mod2view1);
		mat_print("mod2view1-plot.log", mod2view1);
		mat_print("mod2view2-pix.log", mod2view2);
d208 2
a209 2
	mat_copy( regismat, mat2);
	mat_print("regismat", regismat);
@


11.1
log
@Release_4.4
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /m/cad/rt/RCS/rtregis.c,v 10.2 94/08/11 00:39:34 gdurf Exp $";
d51 2
@


10.2
log
@Added include of conf.h
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /m/cad/rt/RCS/rtregis.c,v 10.1 1991/10/12 06:42:00 mike Rel4_0 gdurf $";
@


10.1
log
@Release_4.0
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /m/cad/rt/RCS/rtregis.c,v 1.8 91/06/27 10:21:05 sue Exp $";
d44 2
@


1.8
log
@Changed %g's to $.6f to prevent rounding to nearest int.
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/rtregis.c,v 1.7 91/06/03 15:44:15 sue Exp $";
@


1.7
log
@Fixed a syntax error.
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /m/cad/rt/RCS/rtregis.c,v 1.6 91/06/03 15:27:03 sue Exp $";
d135 1
a135 1
		fprintf(stderr, "mod2view1[0, 1, 2, 3, 15]: %g, %g, %g, %g, %g\n",
d190 1
a190 1
	fprintf(stderr, "scale: %g\n", scale);	
d226 1
a226 1
		fprintf(stdout, "%g ", mat[i]);
@


1.6
log
@Added a verbose flag for future diagnostics support.
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/rtregis.c,v 1.5 91/05/31 14:02:59 sue Exp $";
d132 1
a132 1
		mat_inv(view2model, model2view);
@


1.5
log
@The rt-log reading routine has been taken out and made  common with
rtscale.
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/rtregis.c,v 1.4 91/05/22 15:21:25 sue Exp $";
d64 1
d131 7
a137 7
/*	mat_inv(view2model, model2view);
 */
mat_print("mod2view1-plot.log", mod2view1);
mat_print("mod2view2-pix.log", mod2view2);
/* fprintf(stderr, "mod2view1[0, 1, 2, 3, 15]: %g, %g, %g, %g, %g\n",
 *	mod2view1[0], mod2view1[1], mod2view1[2], mod2view1[3], mod2view1[15]);
 */
@


1.4
log
@Changed the final output to inlcude calling plrot.
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /vld/sue/develop/regis/RCS/regis.c,v 1.3 91/05/17 15:56:34 sue Exp $";
a208 211
/*		R E A D _ R T _ F I L E
 *
 * This routine reads an rt_log file line by line until it either finds
 * view, orientation, eye_postion, and size of the model, or it hits the
 * end of file.  When a colon is found, sscanf() retrieves the
 * necessary information.  It takes a file pointer, file name, and a matrix
 * pointer as parameters.  It returns 0 okay or < 0 failure.
 */

int
read_rt_file(infp, name, model2view)
FILE	*infp;
char	*name;
mat_t 	model2view;
{

	fastf_t		azimuth;		/* part of the view */
	fastf_t		elevation;		/* part of the view */
	quat_t		orientation;		/* orientation */
	point_t		eye_pos;
	fastf_t		m_size;			/* size of model in mm */
	char		*ret;			/* return code for fgets */
	char		string[BUFF_LEN];	/* temporary buffer */
	char		*arg_ptr;		/* place holder */
	char		forget_it[9];		/* "azimuth" catcher, then forget */
	int		i;			/* reusable counter */
	int		num;			/* return code for sscanf */
	int		seen_view;		/* these are flags.  */
	int		seen_orientation;
	int		seen_eye_pos;
	int		seen_size;

	mat_t		rotate, xlate;
	mat_t		tmp_mat;

	/* Set all flags to ready state.  */

	seen_view = FALSE;
	seen_orientation = FALSE;
	seen_eye_pos = FALSE;
	seen_size = FALSE;

/* fprintf(stderr, "set flags: view=%d, orient.=%d, eye_pos=%d, size=%d\n",
 *	seen_view, seen_orientation, seen_eye_pos, seen_size);
 */

	/* feof returns 1 on failure */

	while( feof(infp) == 0 )  {

		/* clear the buffer */	
		for( i = 0; i < BUFF_LEN; i++ )  {
			string[i] = '\0';
		}
		ret = fgets(string, BUFF_LEN, infp);

		if( ret == NULL )  {
			/* There are two times when NULL might be seen:
			 * at the end of the file (handled above) and
			 * when the process dies horriblely and unexpectedly.
			 */

			if( feof(infp) )
				break;
			
			/* This needs to be seen only if there is an
			 * unexpected end.
			 */
			fprintf(stderr, "read_rt_log: read failure on file %s\n",
 				name);
 			return(-1);
		}

		/* Check the first for a colon in the buffer.  If there is
		 * one, replace it with a NULL, and set a pointer to the
		 * next space.  Then feed the buffer to
		 * strcmp see whether it is the view, the orientation,
		 * the eye_position, or the size.  If it is, then sscanf()
		 * the needed information into the appropriate variables.
		 * If the keyword is not found, go back for another line.
		 *
		 * Set arg_ptr to NULL so it can be used as a flag to verify
		 * finding a colon in the input buffer.
		 */

		arg_ptr = NULL;

		for( i = 0; i < BUFF_LEN; i++ )  {
			/* Check to make sure the first char. is not a NULL;
			 * if it is, go back for a new line.
			 */
			if( string[i] == '\0' )  {
				break;
			}
			if( string[i] == ':')  {
				/* If a colon is found, set arg_ptr to the
				 * address of the colon, and break: no need to
				 * look for more colons on this line.
				 */

/* fprintf(stderr, "found colon\n");
 */
				string[i] = '\0';
				arg_ptr = &string[++i];		/* increment before using */
				break;
			}
		}

		/* Check to see if a colon has been found.  If not, get another
		 * input line.
		 */

		if( arg_ptr == NULL )  {
			continue;
		}

		/* Now compare the first word in the buffer with the
		 * key words wanted.  If there is a match, read the
		 * information that follows into the appropriate
		 * variable, and set a flag to indicate that the
		 * magic thing has been seen.
		 *
		 * Note two points of interest: scanf() does not like %g;
		 * use %lf.  Also, if loading a whole array of characters
		 * with %s, then the name of the array can be used for the
		 * destination.  However, if the characters are loaded 
		 * individually into the subsripted spots with %c (or equiv),
		 * the address of the location must be provided: &eye_pos[0].
		 */

		if(strcmp(string, "View") == 0)  {
			num = sscanf(arg_ptr, "%lf %s %lf", &azimuth, forget_it, &elevation);
			if( num != 3)  {
				fprintf(stderr, "View= %g %s %g elevation\n", azimuth, forget_it, elevation);
				return(-1);
			}
			seen_view = TRUE;
		} else if(strcmp(string, "Orientation") == 0)  {
			num = sscanf(arg_ptr, "%lf, %lf, %lf, %lf",
				&orientation[0], &orientation[1], &orientation[2],
				&orientation[3]);

 			if(num != 4)  {
				fprintf(stderr, "Orientation= %g, %g, %g, %g\n",
				 	V4ARGS(orientation) );
				return(-1);
			}
			seen_orientation = TRUE;
		} else if(strcmp(string, "Eye_pos") == 0)  {
			num = sscanf(arg_ptr, "%lf, %lf, %lf", &eye_pos[0],
				&eye_pos[1], &eye_pos[2]);
			if( num != 3)  {
				fprintf(stderr, "Eye_pos= %g, %g, %g\n",
					V3ARGS(eye_pos) );
				return(-1);
			}
			seen_eye_pos = TRUE;
		} else if(strcmp(string, "Size") == 0)  {
			num = sscanf(arg_ptr, "%lf", &m_size);
			if(num != 1)  {
				fprintf(stderr, "Size=%g\n", m_size);
				return(-1);
			}
			seen_size = TRUE;
		}
	}

	/* Check that all the information to proceed is available */

	if( seen_view != TRUE )  {
		fprintf(stderr, "View not read for %s!\n", name);
		return(-1);
	}

	if( seen_orientation != TRUE )  {
		fprintf(stderr, "Orientation not read for %s!\n", name);
		return(-1);
	}

	if( seen_eye_pos != TRUE )  {
		fprintf(stderr, "Eye_pos not read for %s!\n", name);
		return(-1);
	}

	if ( seen_size != TRUE )  {
		fprintf(stderr, "Size not read for %s!\n", name);
		return(-1);
	}

	/* For now, just print the stuff */

	fprintf(stderr, "logfile: %s\n", name);
	fprintf(stderr, "view= %g azimuth, %g elevation\n", azimuth, elevation);
	fprintf(stderr, "orientation= %g, %g, %g, %g\n", V4ARGS(orientation) );
	fprintf(stderr, "eye_pos= %g, %g, %g\n", V3ARGS(eye_pos) );
	fprintf(stderr, "size= %gmm\n", m_size);

	/* Build the view2model matrix. */

	quat_quat2mat( rotate, orientation );
	rotate[15] = 0.5 * m_size;
	mat_idn( xlate );
	MAT_DELTAS( xlate, -eye_pos[0], -eye_pos[1], -eye_pos[2] );
	mat_mul( model2view, rotate, xlate );

 mat_print("model2view", model2view);

	return(0);
}


d228 1
a228 1
	return(0);
@


1.3
log
@This version prints out the registration matrix and the alternate space
command in such a way that it can be pasted into a shell script to be
fed to plrot.
@
text
@d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /vld/sue/develop/regis/RCS/regis.c,v 1.2 91/05/16 11:04:26 sue Exp $";
d434 1
a434 1
	fprintf(stdout, "-m\"");
@


1.2
log
@Can now catch unexpected end-of-file; tentatively write out a registration
matrix based on the notition that the first file and the one to be
registered with are both originally in model coordinates.  Hence, the
second file's model2view matrix IS the registration matrix.
@
text
@d20 3
a22 2
*	2) possibley use plrot to rotate/transform the UNIX_Plot file
*	   or do this here
d25 2
a27 1
*
d42 1
a42 1
static char RCSregis[] = "@@(#)$Header: /vld/sue/develop/regis/RCS/regis.c,v 1.1 91/05/14 15:27:59 sue Exp $";
d61 1
a62 1

d145 1
a145 1
	
d181 2
a182 1
	 * of the model (scale).
d199 2
a200 3
	 * registered with a lo-res pixel file?  Is the treated the same as
	 * as two plot files (i.e. two plot files are cat'ed together;
	 * two plot files may be pixmatte'ed...
d205 1
d420 21
a440 1
	
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
static char RCSregis[] = "@@(#)$Header: $";
a58 1
int	overlay();
d60 1
d77 2
a78 2
	mat_t		mod1;			/* matrix from first log */
	mat_t		mod2;			/* matrix from second log */
d83 2
a84 2
	mat_idn(mod1);				/* makes an identity matrix */
	mat_idn(mod2);
d109 1
a109 1
	ret = read_rt_file(fp, argv[1], mod1);
d121 1
a121 1
	ret = read_rt_file(fp, argv[2], mod2);
d130 4
a133 4
mat_print("mod1-plot.log", mod1);
mat_print("mod2-pix.log", mod2);
/* fprintf(stderr, "mod1[0, 1, 2, 3, 15]: %g, %g, %g, %g, %g\n",
 *	mod1[0], mod1[1], mod1[2], mod1[3], mod1[15]);
d138 1
a138 1
	ret = mat_build(mod1, mod2, regismat);
d187 16
d261 1
a261 1
#ifdef
d263 11
a276 1
			break;
a277 1
#endif
a417 40

/*		D R A W S C A L E
 *
 * 
 * 
 * 
 * 
 * 
 */

int
drawscale(outfp, startpt, len, hgt, lenv, hgtv, inv_hgtv)
FILE		*outfp;
point_t		startpt;
fastf_t		len;
fastf_t		hgt;
vect_t		lenv;
vect_t		hgtv;
vect_t		inv_hgtv;
{
}


/*		D R A W T I C K S
 *
 *
 *
 *
 *
 */

int
drawticks(outfp, centerpt, hgtv, hgt, inv_hgtv)
FILE		*outfp;
point_t		centerpt;
vect_t		hgtv;
fastf_t		hgt;
vect_t		inv_hgtv;
{
}
@
