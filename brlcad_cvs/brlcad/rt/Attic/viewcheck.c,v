head	11.23;
access;
symbols
	ansi-20040405-merged:11.19.2.2
	postmerge-20040405-ansi:11.21
	premerge-20040404-ansi:11.20
	postmerge-autoconf:11.20
	autoconf-freeze:11.19.10.2
	premerge-autoconf:11.20
	postmerge-20040315-windows:11.20
	premerge-20040315-windows:11.20
	windows-20040315-freeze:11.19.4.1
	autoconf-20031203:11.19
	autoconf-20031202:11.19
	autoconf-branch:11.19.0.10
	phong-branch:11.19.0.8
	photonmap-branch:11.19.0.6
	rel-6-1-DP:11.19
	windows-branch:11.19.0.4
	rel-6-0-2:11.17
	ansi-branch:11.19.0.2
	rel-6-0-1-branch:11.17.0.2
	hartley-6-0-post:11.18
	hartley-6-0-pre:11.17
	rel-6-0-1:11.17
	rel-6-0:11.17
	rel-5-4:11.10.2.1
	offsite-5-3-pre:11.14
	rel-5-3:11.10.2.1
	rel-5-2:11.10.2.1
	rel-5-1-branch:11.10.0.2
	rel-5-1:11.10
	rel-5-0:11.10
	rel-5-0-beta:11.9
	rel-4-5:11.6
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.23
date	2004.05.21.17.31.09;	author morrison;	state dead;
branches;
next	11.22;

11.22
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.21;

11.21
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2002.08.20.17.08.39;	author jra;	state Exp;
branches
	11.19.2.1
	11.19.4.1
	11.19.10.1;
next	11.18;

11.18
date	2002.08.15.20.55.50;	author hartley;	state Exp;
branches;
next	11.17;

11.17
date	2001.12.07.00.18.23;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2001.12.04.23.59.49;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2001.04.05.19.36.04;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2000.10.19.19.19.47;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2000.08.17.02.41.38;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.08.14.17.16.20;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.27.19.32.53;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	99.07.02.22.19.46;	author mike;	state Exp;
branches
	11.10.2.1;
next	11.9;

11.9
date	99.05.28.01.19.28;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.09.22.00.21.52;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	98.03.19.04.05.44;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.12.16.00.20.11;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.11.24.16.12.58;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.12.06.17.57.53;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.01.28.00.11.10;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.23;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.05.03.05.38;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.02.45.22;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.17;	author mike;	state Rel4_0;
branches;
next	9.15;

9.15
date	91.07.06.00.35.27;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.07.01.03.34.05;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.06.28.05.43.16;	author jehunt;	state Exp;
branches;
next	9.12;

9.12
date	91.06.27.11.09.24;	author jehunt;	state Exp;
branches;
next	9.11;

9.11
date	91.06.26.15.59.22;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.06.07.07.16.23;	author jehunt;	state Exp;
branches;
next	9.9;

9.9
date	91.02.20.00.51.31;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.05.03.09.22;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.12.16.35.15;	author butler;	state Exp;
branches;
next	9.6;

9.6
date	90.12.07.00.54.30;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.14.15.43.37;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.06.06.20.42.24;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.06.06.20.40.41;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.10.28.02.26.58;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.53;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.05.09.15.08.21;	author stay;	state Exp;
branches;
next	8.5;

8.5
date	89.05.09.14.48.08;	author stay;	state Exp;
branches;
next	8.4;

8.4
date	89.04.04.05.02.16;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.27.16.37.06;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.15.03.45.27;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.38;	author mike;	state Rel3_0;
branches;
next	1.5;

1.5
date	88.08.23.02.33.11;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	88.05.20.03.23.00;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.05.15.21.19.43;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.02.27.00.44.19;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.02.26.16.57.18;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2000.08.15.17.59.07;	author jra;	state Exp;
branches;
next	;

11.19.2.1
date	2002.09.19.18.02.16;	author morrison;	state Exp;
branches;
next	11.19.2.2;

11.19.2.2
date	2004.03.17.21.23.01;	author morrison;	state Exp;
branches;
next	;

11.19.4.1
date	2004.03.11.23.48.07;	author morrison;	state Exp;
branches;
next	;

11.19.10.1
date	2004.02.12.19.37.14;	author erikg;	state Exp;
branches;
next	11.19.10.2;

11.19.10.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@view.c module to make rtcheck, a program to find geometry overlaps
and report them as 3-D floating point BRL-UNIX-plot lines.
@


11.23
log
@moved to src/rt/
@
text
@/*
 *			V I E W C H E C K
 *
 *  Ray Tracing program RTCHECK bottom half.
 *
 *  This module outputs overlapping partitions, no other information.
 *  The partitions are written to the output file (typically stdout)
 *  as BRL-UNIX-plot 3-D floating point lines, so that they can be
 *  processed by any tool that reads UNIX-plot.  Because the BRL UNIX
 *  plot format is defined in a machine independent way, this program
 *  can be run anywhere, and the results piped back for local viewing,
 *  for example, on a workstation.
 *
 *  ToDo: It would be nice if we could pass in (1) an overlap depth
 *  tolerance, (2) choose either region pair or solid pair grouping
 *  and (3) set the verbosity, e.g. whether to print *every* overlap
 *  or not.
 *
 *  Authors -
 *	Michael John Muuss
 *	Gary S. Moss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCScheckview[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/viewcheck.c,v 11.22 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "plot3.h"

#define OVLP_TOL	0.1

extern int	rpt_overlap;		/* report overlapping region names */
int		use_air = 0;		/* Handling of air in librt */

/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
	{"",	0, (char *)0,	0,		BU_STRUCTPARSE_FUNC_NULL }
};

extern FILE	*outfp;

char usage[] = "Usage:  rtcheck [options] model.g objects...\n\
Options:\n\
 -s #       Square grid size in pixels (default 512)\n\
 -w # -n #  Grid size width and height in pixels\n\
 -V #       View (pixel) aspect ratio (width/height)\n\
 -a #       Azimuth in degrees\n\
 -e #       Elevation in degrees\n\
 -M         Read matrix, cmds on stdin\n\
 -N #	    Set NMG debug flags\n\
 -o file.pl Specify UNIX-plot output file\n\
 -x #       Set librt debug flags\n\
 -X #       Set rt debug flags\n\
 -r         Report only unique overlaps\n\
 -P #       Set number of processors\n\
";

static int	noverlaps;		/* Number of overlaps seen */
static int	overlap_count;		/* Number of overlap pairs seen */
static int	unique_overlap_count;	/* Number of unique overlap pairs seen */

/*
 *  For each unique pair of regions that we find an overlap for
 *  we build up one of these structures.
 *  Note that we could also discriminate at the solid pair level.
 */
struct overlap_list {
	struct overlap_list *next;	/* next one */
	const char 	*reg1;		/* overlapping region 1 */
	const char	*reg2;		/* overlapping region 2 */
	long	count;			/* number of time reported */
	double	maxdepth;		/* maximum overlap depth */
};
static struct overlap_list *olist=NULL;	/* root of the list */


/*
 *			H I T
 *
 * Null function -- handle a hit
 */
/*ARGSUSED*/
int
hit(struct application *ap, register struct partition *PartHeadp, struct seg *segHeadp)
{
	return	1;
}

/*
 *			M I S S
 *
 *  Null function -- handle a miss
 */
/*ARGSUSED*/
int
miss(struct application *ap)
{
	return	0;
}

/*
 *			O V E R L A P
 *
 *  Write end points of partition to the standard output.
 *  If this routine return !0, this partition will be dropped
 *  from the boolean evaluation.
 */
int
overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
{	
	register struct xray	*rp = &ap->a_ray;
	register struct hit	*ihitp = pp->pt_inhit;
	register struct hit	*ohitp = pp->pt_outhit;
	vect_t	ihit;
	vect_t	ohit;
	double depth;

	VJOIN1( ihit, rp->r_pt, ihitp->hit_dist, rp->r_dir );
	VJOIN1( ohit, rp->r_pt, ohitp->hit_dist, rp->r_dir );
	depth = ohitp->hit_dist - ihitp->hit_dist;
	if( depth < OVLP_TOL )
		return(0);

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	pdv_3line( outfp, ihit, ohit );
	noverlaps++;
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( !rpt_overlap ) {
		bu_log("OVERLAP %d: %s\nOVERLAP %d: %s\nOVERLAP %d: depth %gmm\nOVERLAP %d: in_hit_point (%g,%g,%g) mm\nOVERLAP %d: out_hit_point (%g,%g,%g) mm\n------------------------------------------------------------\n",
			noverlaps,reg1->reg_name,
			noverlaps,reg2->reg_name,
			noverlaps,depth,
			noverlaps,ihit[X],ihit[Y],ihit[Z],
			noverlaps,ohit[X],ohit[Y],ohit[Z]);

	/* If we report overlaps, don't print if already noted once.
	 * Build up a linked list of known overlapping regions and compare 
	 * againt it.
	 */
	} else {
		struct overlap_list	*prev_ol = (struct overlap_list *)0;
		struct overlap_list	*op;		/* overlap list */
		struct overlap_list     *new_op;
		new_op =(struct overlap_list *)bu_malloc(sizeof(struct overlap_list),"overlap list");

		/* look for it in our list */
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		for( op=olist; op; prev_ol=op, op=op->next ) {

			/* if we already have an entry for this region pair, 
			 * we increase the counter and return 
			 */
			if( (strcmp(reg1->reg_name,op->reg1) == 0) && (strcmp(reg2->reg_name,op->reg2) == 0) ) {
				op->count++;
				if( depth > op->maxdepth )
					op->maxdepth = depth;
				bu_semaphore_release( BU_SEM_SYSCALL );
				bu_free( (char *) new_op, "overlap list");
				return	0;	/* already on list */
			} 
		}
		
		for( op=olist; op; prev_ol=op, op=op->next ) {
			/* if this pair was seen in reverse, decrease the unique counter */
			if ( (strcmp(reg1->reg_name, op->reg2) == 0) && (strcmp(reg2->reg_name, op->reg1) == 0) ) {
				unique_overlap_count--;
				break;
			}
		}
		
		/* we have a new overlapping region pair */
		overlap_count++;
		unique_overlap_count++;
		
		op = new_op;
		if( olist )		/* previous entry exists */
			prev_ol->next = op;
		else
			olist = op;	/* finally initialize root */
		op->reg1 = reg1->reg_name;
		op->reg2 = reg2->reg_name;
		op->maxdepth = depth;
		op->next = NULL;
		op->count = 1;
		bu_semaphore_release( BU_SEM_SYSCALL );
	}

	/* useful debugging */
	if (0) {
		struct overlap_list	*op;		/* overlap list */
		bu_log("PRINTING LIST::reg1==%s, reg2==%s\n", reg1->reg_name, reg2->reg_name);
		for (op=olist; op; op=op->next) {
			bu_log("\tpair: %s  %s  %d matches\n", op->reg1, op->reg2, op->count);
		}
	}
	
	return(0);	/* No further consideration to this partition */
}

/*
 *  			V I E W _ I N I T
 *
 *  Called once for this run.
 */
int
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{
	ap->a_hit = hit;
	ap->a_miss = miss;
	ap->a_overlap = overlap;
	ap->a_logoverlap = rt_silent_logoverlap;
	ap->a_onehit = 0;
	if( !minus_o)			/* Needs to be set to  stdout */
		outfp = stdout;
	return	0;		/* No framebuffer needed */
}

/*
 *			V I E W _ 2 I N I T
 *
 *  Called at the beginning of each frame
 */
void
view_2init(register struct application *ap)
{
	register struct rt_i *rtip = ap->a_rt_i;
	
	pdv_3space( outfp, rtip->rti_pmin, rtip->rti_pmax );
	noverlaps = 0;
	overlap_count = 0;
	unique_overlap_count = 0;
}


/*
 *	P R I N T _ O V E R L A P _ S U M M A R Y
 *
 *  Print out a summary of the overlaps found
 */
static void print_overlap_summary(void) {
	register struct overlap_list *op=0, *backop=0;
	int object_counter=0;
	
	/* if there are any overlaps, print out a summary report, otherwise just
	 * print out that there were zero overlaps
	 */
	if (noverlaps) {
		
		bu_log("==========================================\n");
		bu_log("SUMMARY\n");
		
		bu_log("\t%d overlap%c detected\n", noverlaps, (noverlaps==1)?(char)NULL:'s');
		bu_log("\t%d unique overlapping pair%c (%d ordered pair%c)\n", unique_overlap_count, (unique_overlap_count==1)?(char)NULL:'s', overlap_count, (overlap_count==1)?(char)NULL:'s');
		
		if (olist)	{
			bu_log("\tOverlapping objects: ");
			
			for (op=olist; op ; op=op->next) {

				/* iterate over the list and see if we already printed this one */
				for ( backop=olist; (backop!=op) && (backop); backop=backop->next ) {
					if ((strcmp(op->reg1, backop->reg1) == 0) || (strcmp(op->reg1, backop->reg2) == 0)) break;
				}
				/* if we got to the end of the list (backop points to the match) */
				if (!backop || (backop==op)) {
					bu_log("%s  ", op->reg1);
					object_counter++;
				}

				/* iterate over the list again up to where we are to see if the second
				 * region was already printed */
				for (backop=olist; backop; backop=backop->next) {
					if ((strcmp(op->reg2, backop->reg1) == 0) || (strcmp(op->reg2, backop->reg2) == 0)) break;
				}
				if ( !backop || (backop==op)) {
					bu_log("%s  ", op->reg2);
					object_counter++;
				}
			}
			bu_log("\n\t%d unique overlapping object%c detected\n", object_counter, (object_counter==1)?(char)NULL:'s');
		}
	} 
	else {
		bu_log("%d overlap%c detected\n\n", noverlaps, (noverlaps==1)?(char)NULL:'s');
	}
}

/*
 *			V I E W _ E N D
 *
 *  Called at the end of each frame
 */
void
view_end(void) {
	pl_flush(outfp);
	fflush(outfp);
	/*	bu_log("%d overlap%c detected\n\n", noverlaps, (noverlaps==1)?(char)NULL:'s');*/
	
	/*        bu_log("\nocount==%d, unique_ocount==%d\n\n", overlap_count, unique_overlap_count);*/
	
	if( rpt_overlap ) {
		/* using counters instead of the actual variables to be able to
		 * summarize after checking for matching pairs
		 */
		int overlap_counter=overlap_count;
		int unique_overlap_counter=unique_overlap_count;
		register struct overlap_list *op=0, *backop=0, *nextop=0;
		
		/* iterate over the overlap pairs and output one OVERLAP section
		 * per unordered pair.  a summary is output at the end. 
		 */
		bu_log("OVERLAP PAIRS\n------------------------------------------\n");
		for ( op=olist; op; op=op->next ) {
			
			/* !!! would/should not need to do this..  need a doubly-linked
			 * list so we can go backwards.  we look through the list and
			 * see if we hit the reverse previously.
			 */
			for ( backop=olist; (backop!=op) && (backop); backop=backop->next ) {
				if ((strcmp(op->reg2, backop->reg1) == 0) && (strcmp(op->reg1, backop->reg2) == 0)) break;
			}
			if (backop && (backop!=op)) continue;
			
			bu_log("%s and %s overlap\n", op->reg1, op->reg2);
			
			nextop=(struct overlap_list *)NULL;
			/* if there are still matching pairs to search for */
			if (overlap_counter > unique_overlap_counter) {
				
				/* iterate until end of pairs or we find a
				 * reverse matching pair (done inside loop 
				 * explicitly)*/
				for ( nextop=op; nextop ; nextop=nextop->next) {
					if ((strcmp(op->reg1, nextop->reg2) == 0) && 
							(strcmp(op->reg2, nextop->reg1) == 0))
						break;
				}	
				/* when we leave the loop, nextop is either 
				 * null (hit end of list) or the matching
				 * reverse pair */
			}
			
			bu_log("\t<%s, %s>: %d overlap%c detected, maximum depth is %gmm\n", op->reg1, op->reg2, op->count, op->count>1 ? 's' : (char) 0, op->maxdepth);
			if (nextop) {
				bu_log("\t<%s, %s>: %d overlap%c detected, maximum depth is %gmm\n", nextop->reg1, nextop->reg2, nextop->count, nextop->count>1 ? 's' : (char) 0, nextop->maxdepth);
				/* counter the decrement below to account for 
				 * the matched reverse pair 
				 */
				unique_overlap_counter++;
			}
			
			/* decrement so we may stop scanning for unique overlaps asap */
			unique_overlap_counter--;
			overlap_counter--;
		}
		
		/* print out a summary of the overlaps that were found */
		print_overlap_summary();
		
		/* free our structures */
		op = olist;
		while( op ) {
			/* free struct */
			nextop = op->next;
			bu_free( (char *)op, "overlap_list" );
			op = nextop;
		}
		olist = (struct overlap_list *)NULL;
	}
	bu_log("\n");
}

/*
 *	Stubs
 */
void view_pixel(void) {}

void view_eol(void) {}

void view_setup(void) {}
void view_cleanup(void) {}
void application_init (void) {}
@


11.22
log
@change conf.h to a wrapped config.h
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /cvs/brlcad/rt/viewcheck.c,v 11.21 2004/04/05 05:45:59 morrison Exp $ (BRL)";
@


11.21
log
@merge of ansi-6-0-branch into head
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header$ (BRL)";
d36 5
a40 1
#include "conf.h"
@


11.20
log
@update copyright to include span through 2003
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.19 2002/08/20 17:08:39 jra Exp $ (BRL)";
d101 1
a101 4
hit( ap, PartHeadp, segHeadp )
struct application *ap;
register struct partition *PartHeadp;
struct seg		*segHeadp;
d113 1
a113 2
miss( ap )
struct application *ap;
d126 1
a126 5
overlap( ap, pp, reg1, reg2 )
struct application	*ap;
struct partition	*pp;
struct region		*reg1;
struct region		*reg2;
d224 1
a224 4
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
int minus_o;
d242 1
a242 2
view_2init( ap )
register struct application *ap;
d312 1
a312 1
view_end() {
d394 1
a394 1
void view_pixel() {}
d396 1
a396 1
void view_eol() {}
d398 3
a400 3
void view_setup() {}
void view_cleanup() {}
void application_init () {}
@


11.19
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1988 by the United States Army.
d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.17 2001/12/07 00:18:23 morrison Exp $ (BRL)";
@


11.19.4.1
log
@sync to HEAD...
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/viewcheck.c,v 11.20 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.19.10.1
log
@merge from HEAD
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.20 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.19.10.2
log
@merge from head
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.19.10.1 2004/02/12 19:37:14 erikg Exp $ (BRL)";
@


11.19.2.1
log
@Initial ANSIfication
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.19 2002/08/20 17:08:39 jra Exp $ (BRL)";
d101 4
a104 1
hit(struct application *ap, register struct partition *PartHeadp, struct seg *segHeadp)
d116 2
a117 1
miss(struct application *ap)
d130 5
a134 1
overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
d232 4
a235 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d253 2
a254 1
view_2init(register struct application *ap)
d324 1
a324 1
view_end(void) {
d406 1
a406 1
void view_pixel(void) {}
d408 1
a408 1
void view_eol(void) {}
d410 3
a412 3
void view_setup(void) {}
void view_cleanup(void) {}
void application_init (void) {}
@


11.19.2.2
log
@sync branch with HEAD
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header$ (BRL)";
@


11.18
log
@Converted from K&R to ANSI C - RFH
@
text
@d101 4
a104 1
hit(struct application *ap, register struct partition *PartHeadp, struct seg *segHeadp)
d116 2
a117 1
miss(struct application *ap)
d130 5
a134 1
overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
d232 4
a235 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d253 2
a254 1
view_2init(register struct application *ap)
d324 1
a324 1
view_end(void) {
d406 1
a406 1
void view_pixel(void) {}
d408 1
a408 1
void view_eol(void) {}
d410 3
a412 3
void view_setup(void) {}
void view_cleanup(void) {}
void application_init (void) {}
@


11.17
log
@Fixed a display bug causing improper output.  also modified reporting to be more friendly to the ojos.
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.16 2001/12/04 23:59:49 morrison Exp $ (BRL)";
d101 1
a101 4
hit( ap, PartHeadp, segHeadp )
struct application *ap;
register struct partition *PartHeadp;
struct seg		*segHeadp;
d113 1
a113 2
miss( ap )
struct application *ap;
d126 1
a126 5
overlap( ap, pp, reg1, reg2 )
struct application	*ap;
struct partition	*pp;
struct region		*reg1;
struct region		*reg2;
d224 1
a224 4
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
int minus_o;
d242 1
a242 2
view_2init( ap )
register struct application *ap;
d312 1
a312 1
view_end() {
d394 1
a394 1
void view_pixel() {}
d396 1
a396 1
void view_eol() {}
d398 3
a400 3
void view_setup() {}
void view_cleanup() {}
void application_init () {}
@


11.16
log
@reworked the rtcheck -r report mechanism so that the ordering of overlaps matters.  if some object overlaps A->B and then B->A there is only one section that lists both.  also, added a summary to the end including a summary of what regions overlap something.
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.15 2001/04/05 19:36:04 morrison Exp $ (BRL)";
d77 1
a77 1
static int	unique_overlap_count; /* Number of unique overlap pairs seen */
d174 1
a174 1
		for( op=olist; op; prev_ol=op,op=op->next ) {
d176 4
a179 3
			/* if we already have an entry for this region pair, we increase the counter and return */
			if( (strcmp(reg1->reg_name,op->reg1) == 0)
			 && (strcmp(reg2->reg_name,op->reg2) == 0) ) {
d187 3
d191 1
a191 1
			else if ( (strcmp(reg1->reg_name, op->reg2) == 0) && (strcmp(reg2->reg_name, op->reg1) == 0) ) {
d193 1
d196 1
a196 1

d199 2
a200 2
    unique_overlap_count++;

d214 9
d264 54
d327 4
a330 2
	bu_log("%d overlap%c detected\n\n", noverlaps, (noverlaps==1)?(char)NULL:'s');

d332 3
a334 1
		/* using counters instead of the actual variables to be able to summarize after checking for matching pairs */
d337 6
a342 4
		register struct overlap_list *op=0, *nextop;

		/* iterate over the overlap pairs and output one OVERLAP section per
		 * unordered pair.  a summary is output at the end. */
d344 12
a355 2
			bu_log("OVERLAP\t(%s, %s)\n", op->reg1, op->reg2);

d360 3
a362 1
				/* iterate until end of pairs or we find a reverse matching pair (done inside loop explicitly)*/
d364 2
a365 1
					if ((strcmp(op->reg1, nextop->reg2) == 0) && (strcmp(op->reg2, nextop->reg1) == 0))
d368 3
a370 1
				/* when we leave the loop, nextop is either null (hit end of list) or the matching reverse pair */
d373 1
a373 1
			bu_log("\t(%s, %s): %d overlap%c detected, maximum depth is %gmm\n", op->reg1, op->reg2, op->count, op->count>1 ? 's' : (char) 0, op->maxdepth);
d375 4
a378 2
				bu_log("\t(%s, %s): %d overlap%c detected, maximum depth is %gmm\n", nextop->reg1, nextop->reg2, op->count, op->count>1 ? 's' : (char) 0, op->maxdepth);
				/* counter the decrement below to account for the matched reverse pair */
a381 2
			bu_log("------------------------------------------\n");

d386 4
a389 30

		if (noverlaps) {
			bu_log("OVERLAP SUMMARY\n");
			bu_log("\t%d duplicate%c detected\n", noverlaps, (noverlaps==1)?(char)NULL:'s');
			bu_log("\t%d unique overlapping region pair%c (%d ordered pair%c)\n", unique_overlap_count, (unique_overlap_count==1)?(char)NULL:'s', overlap_count, (overlap_count==1)?(char)NULL:'s');
			bu_log("\tOverlapping regions: ");

			for (op=olist; op ; op=op->next) {
				bu_log("%s  ", op->reg1);

				/* iterate over the list again up to where we are to see if the second
				 * region was already printed */
				for (nextop=olist; nextop; nextop=nextop->next) {
					if (strcmp(op->reg1, nextop->reg1)==0 && strcmp(op->reg2, nextop->reg2)==0) {
						nextop=(struct overlap_list *)NULL;
						break;
					}	else if (strcmp(op->reg2, nextop->reg1)==0 || strcmp(op->reg2, nextop->reg2)==0) {
						break;
					}
				}

				/* if we got to the end of the list (nextop points to the match) */
				if ( ! nextop ) {
					bu_log("%s  ", op->reg2);
				}

			}
			bu_log("\n");
		}

@


11.15
log
@updated SIGNED to signed
updated CONST to const
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.14 2000/10/19 19:19:47 butler Exp $ (BRL)";
d77 1
d175 2
d185 4
d194 2
d247 1
d259 2
a260 1
	bu_log("%d overlaps detected\n", noverlaps);
d262 64
a325 1
		register struct overlap_list *op, *nextop;
d327 1
a327 1
		bu_log("%d overlapping region pairs\n", overlap_count);
a329 3
			bu_log("OVERLAP : %s\nOVERLAP : %s\n%d overlap%c detected, maximum depth is %gmm\n-------------------------------------------\n",
			op->reg1, op->reg2,
			op->count, op->count>1 ? 's' : (char) 0, op->maxdepth);
@


11.14
log
@Changes to compile under RedHat 7.0
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.13 2000/08/17 02:41:38 mike Exp $ (BRL)";
d85 2
a86 2
	CONST char 	*reg1;		/* overlapping region 1 */
	CONST char	*reg2;		/* overlapping region 2 */
@


11.13
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d33 1
a33 1
static const char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.12 2000/08/14 17:16:20 bparker Exp $ (BRL)";
d39 3
@


11.12
log
@Set ap->a_logoverlap = rt_silent_logoverlap
in view_init. Viewcheck has its' own idea
of what to print to the screen.
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.11 2000/07/27 19:32:53 butler Exp $ (BRL)";
@


11.11
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.10 1999/07/02 22:19:46 mike Exp $ (BRL)";
d214 1
@


11.10
log
@
Removed dependence on compat4.h
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.9 1999/05/28 01:19:28 mike Exp $ (BRL)";
d42 1
@


11.10.2.1
log
@Needed ap_logoverlap pointer set to silent logging
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.10 1999/07/02 22:19:46 mike Exp $ (BRL)";
a212 1
	ap->a_logoverlap = rt_silent_logoverlap;
@


11.9
log
@
sed4
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.8 1998/09/22 00:21:52 mike Exp $ (BRL)";
d50 1
a50 1
	{"",	0, (char *)0,	0,		FUNC_NULL }
@


11.8
log
@Doesn't need material.h
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewcheck.c,v 11.7 1998/03/19 04:05:44 mike Exp $ (BRL)";
d150 1
a150 1
		rt_log("OVERLAP %d: %s\nOVERLAP %d: %s\nOVERLAP %d: depth %gmm\nOVERLAP %d: in_hit_point (%g,%g,%g) mm\nOVERLAP %d: out_hit_point (%g,%g,%g) mm\n------------------------------------------------------------\n",
d165 1
a165 1
		new_op =(struct overlap_list *)rt_malloc(sizeof(struct overlap_list),"overlap list");
d176 1
a176 1
				rt_free( (char *) new_op, "overlap list");
d244 1
a244 1
	rt_log("%d overlaps detected\n", noverlaps);
d248 1
a248 1
		rt_log("%d overlapping region pairs\n", overlap_count);
d251 1
a251 1
			rt_log("OVERLAP : %s\nOVERLAP : %s\n%d overlap%c detected, maximum depth is %gmm\n-------------------------------------------\n",
d256 1
a256 1
			rt_free( (char *)op, "overlap_list" );
d261 1
a261 1
	rt_log("\n");
@


11.7
log
@a_hit arg fix
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 11.6 1997/12/16 00:20:11 mike Exp mike $ (BRL)";
a41 1
#include "./material.h"
@


11.6
log
@Converted to bu_semaphore_acquire()
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 11.5 1997/11/24 16:12:58 jra Exp mike $ (BRL)";
d97 1
a97 1
hit( ap, PartHeadp )
d100 1
@


11.5
log
@Fixed an error in the logging.
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 11.4 1996/08/30 00:08:21 butler Exp jra $ (BRL)";
d144 1
a144 1
	RES_ACQUIRE( &rt_g.res_syscall );
d147 1
a147 1
	RES_RELEASE( &rt_g.res_syscall );
d168 1
a168 1
		RES_ACQUIRE( &rt_g.res_syscall );
d175 1
a175 1
				RES_RELEASE( &rt_g.res_syscall );
d193 1
a193 1
		RES_RELEASE( &rt_g.res_syscall );
@


11.4
log
@structparse moved to libbu
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 11.3 1995/12/06 17:57:53 pjt Exp butler $ (BRL)";
d154 2
a155 2
			noverlaps,ihit[X],ihit[Y],ihit[Z],depth,
			noverlaps,ohit[X],ohit[Y],ohit[Z],depth);
@


11.3
log
@Added a stub for application_init()
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 11.2 1995/01/28 00:11:10 butler Exp pjt $ (BRL)";
d50 1
a50 1
struct structparse view_parse[] = {
@


11.2
log
@added -N description to Options help message
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 11.1 1995/01/04 10:01:23 mike Rel4_4 butler $ (BRL)";
d273 1
@


11.1
log
@Release_4.4
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 10.3 94/11/05 03:05:38 mike Exp $ (BRL)";
d64 1
@


10.3
log
@Irix 6
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 10.2 94/08/11 02:45:22 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 10.1 1991/10/12 06:42:17 mike Rel4_0 gdurf $ (BRL)";
a72 1
static int	rays;
a214 1
	rays = 1;
@


10.1
log
@Release_4.0
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.15 91/07/06 00:35:27 mike Exp $ (BRL)";
d35 2
@


9.15
log
@ANSI structure initialization
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.14 91/07/01 03:34:05 mike Exp $ (BRL)";
@


9.14
log
@ANSI lint fix
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.13 91/06/28 05:43:16 jehunt Exp $ (BRL)";
d49 1
a49 1
	"",	0, (char *)0,	0,		FUNC_NULL
@


9.13
log
@removed some debugging statements
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.12 91/06/27 11:09:24 jehunt Exp $ (BRL)";
d80 2
a81 2
	char 	*reg1;			/* overlapping region 1 */
	char	*reg2;			/* overlapping region 2 */
@


9.12
log
@rt_malloc also has locking on res_syscall
so the code needed still more reorganizing.
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.11 91/06/26 15:59:22 mike Exp $ (BRL)";
a146 2
	rt_log( "OVERLAP %d\n", noverlaps );

d148 1
a148 1
		rt_log("OVERLAP %d: %s\nOVERLAP %d: %s\nOVERLAP %d: depth %gmm\nOVERLAP %d: in_hit_point (%g,%g,%g) mm\nOVERLAP %d: out_hit_point (%g,%g,%g) mm\n--------------------------------------------------\n",
@


9.11
log
@rt_log already has locking on res_syscall,
so the locking code needed to be reorganized slightly.
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.10 91/06/07 07:16:23 jehunt Exp $ (BRL)";
d144 1
a145 1
	noverlaps++;
d147 2
d150 5
a154 6
		rt_log("OVERLAP %d: %s\n",noverlaps,reg1->reg_name);
		rt_log("OVERLAP %d: %s\n",noverlaps,reg2->reg_name);
		rt_log("OVERLAP %d: depth %gmm\n",noverlaps,depth);
		rt_log("OVERLAP %d: in_hit_point (%g,%g,%g) mm\n",
			noverlaps,ihit[X],ihit[Y],ihit[Z],depth);
		rt_log("OVERLAP %d: out_hit_point (%g,%g,%g) mm\n",
a155 1
		rt_log("--------------------------------------------------\n");
d164 2
d176 1
d183 1
a183 1
		op =(struct overlap_list *)rt_malloc(sizeof(struct overlap_list),"overlap list");
d252 3
a254 3
			rt_log("\nOVERLAP: %d overlap%c detected--maximum depth is %gmm\n\t%s\n\t%s\n",
			op->count, op->count>1 ? 's' : (char) 0, 
			op->maxdepth, op->reg1, op->reg2);
@


9.10
log
@cosmetic changes and needed to initialize new overlap_list structures
with a count of 1 and some maxdepth
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.9 91/02/20 00:51:31 mike Exp $ (BRL)";
d144 1
d166 1
d180 11
a190 14
		if( (op =(struct overlap_list *)rt_malloc(sizeof(struct overlap_list),"overlap list")) != NULL ){
			if( olist )		/* previous entry exists */
				prev_ol->next = op;
			else
				olist = op;	/* finally initialize root */
			op->reg1 = reg1->reg_name;
			op->reg2 = reg2->reg_name;
			op->maxdepth = depth;
			op->next = NULL;
			op->count = 1;
		} else {
			rt_log("rtcheck: can't allocate enough space for overlap list!!\n");
			exit(1);
		}
a191 1
	RES_RELEASE( &rt_g.res_syscall );
@


9.9
log
@Added new view-module interface called view_setup() which is used
for initializing material properties, lights, etc.
It compliments view_cleanup(), and finally removed knowledge of
the view.c materials (and all the shaders) from the RT "top half".
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.8 91/01/05 03:09:22 mike Exp $ (BRL)";
d42 2
d54 14
a67 1
char usage[] = "Usage:  rtcheck [options] model.g objects...\n";
d71 1
d112 1
a112 1
	return	1;
d134 1
d138 3
d146 10
d160 1
a160 1
	if( rpt_overlap ) {
a162 1
		double depth = ohitp->hit_dist - ihitp->hit_dist;
a177 10
#if 0
		/*
		 * Note: by default, RT also gives us in/out solid names in
		 * the partition, the XYZ hit point, and the ray grid x,y.
		 */
		rt_log("OVERLAP %d: %s\n",overlap_count,reg1->reg_name);
		rt_log("OVERLAP %d: %s\n",overlap_count,reg2->reg_name);
		rt_log("OVERLAP %d: depth %gmm\n",overlap_count,reg2->reg_name,depth);
		rt_log("-----<>-----<>-----<>-----<>-----<>------<>-----\n");
#endif
d185 1
d187 1
d215 1
a215 1

d251 3
a253 1
			rt_log("OVERLAP: %gmm %s %s\n", op->maxdepth, op->reg1, op->reg2);
@


9.8
log
@Converted to new format for fmt entry in structparse
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.7 90/12/12 16:35:15 butler Exp $ (BRL)";
a43 1
int		using_mlib = 0;		/* Material routines NOT used */
d248 1
@


9.7
log
@modified to reflect changes in structparse format
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.6 90/12/07 00:54:30 mike Exp $ (BRL)";
d48 1
a48 1
	(char *)0, 0, (char *)0,	0,		FUNC_NULL
@


9.6
log
@lint
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.5 90/11/14 15:43:37 mike Exp $ (BRL)";
d48 1
a48 1
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.5
log
@As part of "clean" command, call "view_cleanup()", to allow
viewing module the opportunity to clean up things like implicit
light sources, etc.
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.4 90/06/06 20:42:24 mike Exp $ (BRL)";
d132 2
a133 1
		struct overlap_list	*prev_ol,*op;	/* overlap list */
@


9.4
log
@lint
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.3 90/06/06 20:40:41 phil Exp $ (BRL)";
d247 2
@


9.3
log
@Improved.
@
text
@d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: /m/cad/rt/RCS/viewcheck.c,v 9.2 89/10/28 02:26:58 phil Exp Locker: phil $ (BRL)";
d233 1
a233 1
			rt_free( op );
@


9.2
log
@Added summary option from Dan Dender.  Could probably use some work.
E.g. keeping track of max overlap depth for a given pair, number of
hits for each pair, and printing all this at the end would be useful.
Also, an adjustable overlap tolerance would be good.
@
text
@d14 5
d33 1
a33 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 9.1 89/05/19 05:59:53 phil Locked $ (BRL)";
d56 1
a56 1
static int	overlap_count;		/* Number of differentiable overlaps seen */
d59 15
a99 8

struct overlap_list {
	char 	*reg1,			/* overlapping region 1 */
		*reg2;			/* overlapping region 2 */
	struct overlap_list *next;	/* next one */
};


d104 2
d132 2
d135 7
a141 6
		static struct overlap_list *root=NULL;		/* root of the list*/
		struct overlap_list	*prev_ol,*olist;	/* overlap list */

		for( olist=root; olist; prev_ol=olist,olist=olist->next ) {
			if( (strcmp(reg1->reg_name,olist->reg1) == 0)
			 && (strcmp(reg2->reg_name,olist->reg2) == 0) ) {
d147 1
d149 13
a161 7
		fprintf(stderr,"OVERLAP %d: %s\n",overlap_count,reg1->reg_name);
		fprintf(stderr,"OVERLAP %d: %s\n",overlap_count,reg2->reg_name);
		fprintf(stderr,"-----<>-----<>-----<>-----<>-----<>------<>-----\n");

		if( (olist =(struct overlap_list *)rt_malloc(sizeof(struct overlap_list),"overlap list")) != NULL ){
			if( root )		/* previous entry exists */
				prev_ol->next = olist;
d163 4
a166 5
				root = olist;	/* finally initialize root */
			olist->reg1 = reg1->reg_name;
			olist->reg2 = reg2->reg_name;
			olist->next = NULL;

d168 1
a168 1
			fprintf(stderr,"rtcheck: can't allocate enough space for overlap list!!\n");
d224 15
@


9.1
log
@Release_3.5
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 8.6 89/05/09 15:08:21 stay Exp $ (BRL)";
d37 1
d51 1
d80 8
d112 37
d188 1
@


8.6
log
@Someone forgot to take out the npts arg
in view_init, which caused rtcheck to
not get the minus_o flag set right.
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 8.5 89/05/09 14:48:08 stay Locked $ (BRL)";
@


8.5
log
@outfp was not being set so if there is no output file
specified than stdout is the default.
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 8.4 89/04/04 05:02:16 stay Locked $ (BRL)";
d113 1
a113 1
view_init( ap, file, obj, npts, minus_o )
d116 1
@


8.4
log
@Converted to new way of representing structure offsets.
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 8.3 88/12/27 16:37:06 mike Locked $ (BRL)";
d121 3
@


8.3
log
@Converted matparse --> structparse
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 8.2 88/12/15 03:45:27 mike Locked $ (BRL)";
d42 1
a42 1
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
@


8.2
log
@removed ireflect, bounce stubs.  put in view_parse stub instead.
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 8.2 88/12/15 03:31:08 phil Exp $ (BRL)";
d41 2
a42 2
struct matparse view_parse[] = {
	(char *)0,	(mp_off_ty)0,				(char *)0
@


8.1
log
@Release_3.0
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 1.5 88/08/23 02:33:11 mike Exp $ (BRL)";
d35 1
d38 1
d40 4
a43 3
int		using_mlib = 0;		/* Material routines NOT used */
int		max_bounces;		/* stub for "set" cmd */
int		max_ireflect;		/* stub for "set" cmd */
@


1.5
log
@Added declarations of using_mlib=0,
added max_bounces stub variables, to keep "set" command happy,
deleted stub mlib_setup(), mlib_free() stubs.
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 1.4 88/05/20 03:23:00 mike Locked $ (BRL)";
@


1.4
log
@Added use_air variable.
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 1.3 88/05/15 21:19:43 mike Locked $ (BRL)";
d38 4
a153 6

int mlib_setup() { 
	return(1); 
}

void mlib_free() { ; }
@


1.3
log
@lint fix
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 1.2 88/02/27 00:44:19 mike Locked $ (BRL)";
d35 2
@


1.2
log
@Added parallel support, counted up number of overlaps.
@
text
@d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header: viewcheck.c,v 1.1 88/02/26 16:57:18 mike Locked $ (BRL)";
d48 1
d62 1
d74 1
d103 1
d120 1
a127 1
	return(0);
d135 1
d145 1
a145 1
view_pixel() {}
d147 1
a147 1
view_eol() {}
d149 1
a149 1
mlib_setup() { 
d153 1
a153 1
mlib_free() { ; }
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1987 by the United States Army.
d28 1
a28 1
static char RCScheckview[] = "@@(#)$Header$ (BRL)";
d40 2
d87 1
a87 1
	/* Not PARALLEL -- needs syscall resource lock around this call */
d89 3
d97 2
d112 3
a114 1
 *	Stubs
a115 9
view_pixel() {}

view_eol() {}

view_end() {
	pl_flush(outfp);
	fflush(outfp);
}

d122 2
a123 1
	return	0;
d125 18
@
