head	11.34;
access;
symbols
	ansi-20040405-merged:11.33.2.2
	phong-branch:11.33.0.8
	photonmap-branch:11.33.0.6
	rel-6-1-DP:11.33
	rel-6-0-2:11.31
	ansi-branch:11.33.0.2
	rel-6-0-1-branch:11.31.0.2
	hartley-6-0-post:11.32
	hartley-6-0-pre:11.31
	rel-6-0-1:11.31
	rel-6-0:11.31
	rel-5-4:11.22.2.2
	offsite-5-3-pre:11.27
	rel-5-3:11.22.2.2
	rel-5-2:11.22
	rel-5-1-branch:11.22.0.2
	rel-5-1:11.22
	rel-5-0:11.19
	rel-5-0-beta:11.19
	rel-4-5:11.14
	ctj-4-5-post:11.11
	ctj-4-5-pre:11.11
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	windows-6-0-branch:11.33.0.4;
locks; strict;
comment	@ * @;


11.34
date	2003.09.27.00.56.11;	author morrison;	state dead;
branches;
next	11.33;

11.33
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.33.2.1
	11.33.4.1;
next	11.32;

11.32
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.31;

11.31
date	2001.10.12.18.39.35;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	2001.05.16.21.38.18;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2001.04.05.19.36.04;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2001.03.19.22.20.14;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	2000.10.20.18.55.00;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.08.29.20.47.23;	author butler;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.17.02.41.35;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.27.19.32.52;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.22;

11.22
date	99.12.04.01.16.15;	author mike;	state Exp;
branches
	11.22.2.1;
next	11.21;

11.21
date	99.12.04.00.10.18;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.12.03.20.48.28;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.05.28.01.17.25;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	98.12.11.22.53.21;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	98.12.10.08.28.48;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.11.17.22.59.05;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	98.09.22.01.43.10;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	98.01.13.12.44.36;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.12.09.04.44.04;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	97.08.28.23.47.39;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.03.04.04.39.25;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	97.01.30.13.39.54;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	97.01.29.21.25.11;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.05.09.03.23.54;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.12.11.20.28.19;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.12.11.20.21.57;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.08.23.05.05.47;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.08.23.04.36.58;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.08.22.02.03.48;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.48;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.05.02.49.20;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.00.37.56;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.52;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.09.27.17.25.23;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.10.04.22.55.13;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.31.07.45.02;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.09;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.30.20.37.46;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.14.13.16.18;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.03.01.21;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.33.03;	author mike;	state Rel3_0;
branches;
next	7.15;

7.15
date	88.08.20.07.06.00;	author mike;	state Exp;
branches;
next	7.14;

7.14
date	88.08.20.01.01.57;	author mike;	state Exp;
branches;
next	7.13;

7.13
date	88.05.20.04.01.51;	author mike;	state Exp;
branches;
next	7.12;

7.12
date	88.05.20.03.37.59;	author mike;	state Exp;
branches;
next	7.11;

7.11
date	88.02.25.00.50.35;	author mike;	state Exp;
branches;
next	7.10;

7.10
date	88.01.26.05.57.34;	author mike;	state Exp;
branches;
next	7.9;

7.9
date	88.01.26.01.49.52;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.01.26.01.05.56;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.01.23.04.13.05;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.01.23.00.05.18;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.01.20.08.45.57;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.01.20.02.44.34;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.01.11.18.25.26;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.12.11.23.17.06;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.03;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.10.16.00.49.16;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.10.15.02.33.04;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.58.57;	author mike;	state Rel;
branches;
next	1.8;

1.8
date	87.07.11.03.00.06;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	87.07.06.15.20.24;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	87.07.02.06.19.19;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	87.07.02.01.27.39;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	87.06.27.06.46.14;	author phil;	state Exp;
branches;
next	1.3;

1.3
date	87.06.27.03.51.14;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.06.27.03.48.28;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.06.26.05.56.03;	author mike;	state Exp;
branches;
next	;

11.22.2.1
date	2000.11.28.00.04.30;	author jra;	state Exp;
branches;
next	11.22.2.2;

11.22.2.2
date	2000.11.29.19.15.49;	author jra;	state Exp;
branches;
next	;

11.33.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	11.33.2.2;

11.33.2.2
date	2003.02.11.18.09.53;	author morrison;	state Exp;
branches;
next	;

11.33.4.1
date	2004.03.11.23.48.06;	author morrison;	state dead;
branches;
next	;


desc
@Module to handle reflection and refraction.
@


11.34
log
@moved a majority of the rt "back-end" to liboptical in order to decouple a symbol reference as well as to provide the functionality in a library
@
text
@/*
 *			R E F R A C T
 *
 *  Authors -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985,1987 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.33 2002/08/20 17:08:38 jra Exp $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "plot3.h"

extern int viewshade(struct application *ap,
		     register const struct partition *pp,
		     register struct shadework *swp);


int	max_ireflect = 5;	/* Maximum internal reflection level */
int	max_bounces = 5;	/* Maximum recursion level */

#define MSG_PROLOGUE	20		/* # initial messages to see */
#define MSG_INTERVAL	4000		/* message interval thereafter */

#define RI_AIR		1.0		/* Refractive index of air */

#define AIR_GAP_TOL	0.01		/* Max permitted air gap for RI tracking */

HIDDEN int	rr_hit(), rr_miss();
HIDDEN int	rr_refract();

#if RT_MULTISPECTRAL
extern const struct bn_table	*spectrum;
extern struct bn_tabdata	*background; /* from rttherm/viewtherm.c */
#else
extern vect_t background;
#endif

/*
 *			R R _ R E N D E R
 */
int
rr_render(register struct application *ap,
	  struct partition	*pp,
	  struct shadework	*swp)
{
	struct application sub_ap;
	vect_t	work;
	vect_t	incident_dir;
	fastf_t	shader_fract;
	fastf_t	reflect;
	fastf_t	transmit;

#if RT_MULTISPECTRAL
	struct bn_tabdata	*ms_filter_color = BN_TABDATA_NULL;
	struct bn_tabdata	*ms_shader_color = BN_TABDATA_NULL;
	struct bn_tabdata	*ms_reflect_color = BN_TABDATA_NULL;
	struct bn_tabdata	*ms_transmit_color = BN_TABDATA_NULL;
#else
	vect_t	filter_color;
	vect_t	shader_color;
	vect_t	reflect_color;
	vect_t	transmit_color;
#endif

	fastf_t	attenuation;
	vect_t	to_eye;
	int	code;
#if 0
	static FILE	*plotfp;
#endif

	RT_AP_CHECK(ap);

#if RT_MULTISPECTRAL
	sub_ap.a_spectrum = BN_TABDATA_NULL;
#endif

	/*
	 *  sw_xmitonly is set primarily for light visibility rays.
	 *  Need to compute (partial) transmission through to the light,
	 *  or procedural shaders won't be able to cast shadows
	 *  and light won't be able to get through glass
	 *  (including "stained glass" and "filter glass").
	 *
	 *  On the other hand, light visibility rays shouldn't be refracted,
	 *  it is pointless to shoot at where the light isn't.
	 */
	if( swp->sw_xmitonly )  {
		/* Caller wants transmission term only, don't fire reflected rays */
		transmit = swp->sw_transmit + swp->sw_reflect;	/* Don't loose energy */
		reflect = 0;
	} else {
		reflect = swp->sw_reflect;
		transmit = swp->sw_transmit;
	}
	if(rdebug&RDEBUG_REFRACT) {
		bu_log("rr_render(%s) START: lvl=%d reflect=%g, transmit=%g, xmitonly=%d\n",
			pp->pt_regionp->reg_name,
			ap->a_level,
			reflect, transmit,
			swp->sw_xmitonly );
	}
	if( reflect <= 0 && transmit <= 0 )
		goto out;

	if( ap->a_level > max_bounces )  {
		/* Nothing more to do for this ray */
		static long count = 0;		/* Not PARALLEL, should be OK */

		if( (rdebug&(RDEBUG_SHOWERR|RDEBUG_REFRACT)) && (
			count++ < MSG_PROLOGUE ||
			(count%MSG_INTERVAL) == 3
		) )  {
			bu_log("rr_render: %d,%d MAX BOUNCES=%d: %s\n",
				ap->a_x, ap->a_y,
				ap->a_level,
				pp->pt_regionp->reg_name );
		}

		/* 
		 * Return the basic color of the object, ignoring the
		 * the fact that it is supposed to be
		 * filtering or reflecting light here.
		 * This is much better than returning just black,
		 * but something better might be done.
		 */
#if RT_MULTISPECTRAL
		BN_CK_TABDATA(swp->msw_color);
		BN_CK_TABDATA(swp->msw_basecolor);
		bn_tabdata_copy( swp->msw_color, swp->msw_basecolor );
#else
		VMOVE( swp->sw_color, swp->sw_basecolor );
#endif
		ap->a_cumlen += pp->pt_inhit->hit_dist;
		goto out;
	}
#if RT_MULTISPECTRAL
	BN_CK_TABDATA(swp->msw_basecolor);
	ms_filter_color = bn_tabdata_dup( swp->msw_basecolor );

#else
	VMOVE( filter_color, swp->sw_basecolor );
#endif

#if 0
/* XXX temp hack -Mike & JRA */
	if( rdebug&RDEBUG_RAYPLOT )  {
		static int	count = 0;
		char		name[128];
		if( plotfp && plotfp != stdout )  fclose(plotfp);
		sprintf(name, "rr%d.pl", count++);
		if( (plotfp = fopen( name, "w" )) == NULL )  {
			perror(name);
			plotfp = stdout;
		}
	}
#endif

	if( (swp->sw_inputs & (MFI_HIT|MFI_NORMAL)) != (MFI_HIT|MFI_NORMAL) )
		shade_inputs( ap, pp, swp, MFI_HIT|MFI_NORMAL );

	/*
	 *  If this ray is being fired from the exit point of
	 *  an object, and is directly entering another object,
	 *  (ie, there is no intervening air-gap), and
	 *  the two refractive indices match, then do not fire a
	 *  reflected ray -- just take the transmission contribution.
	 *  This is important, eg, for glass gun tubes projecting
	 *  through a glass armor plate. :-)
	 */
	if( NEAR_ZERO( pp->pt_inhit->hit_dist, AIR_GAP_TOL ) &&
	    ap->a_refrac_index == swp->sw_refrac_index )  {
	    	transmit += reflect;
	    	reflect = 0;
	}

	/*
	 *  Diminish base color appropriately, and add in
	 *  contributions from mirror reflection & transparency
	 */
	shader_fract = 1 - (reflect + transmit);
	if( shader_fract < 0 )  {
		shader_fract = 0;
	} else if( shader_fract >= 1 )  {
		goto out;
	}
	if(rdebug&RDEBUG_REFRACT) {
		bu_log("rr_render: lvl=%d start shader=%g, reflect=%g, transmit=%g %s\n",
			ap->a_level,
			shader_fract, reflect, transmit,
			pp->pt_regionp->reg_name );
	}
#if RT_MULTISPECTRAL
	BN_GET_TABDATA( ms_shader_color, swp->msw_color->table );
	bn_tabdata_scale( ms_shader_color, swp->msw_color, shader_fract );
#else
	VSCALE( shader_color, swp->sw_color, shader_fract );
#endif

	/*
	 *  Compute transmission through an object.
	 *  There may be a mirror reflection, which will be handled
	 *  by the reflection code later
	 */
	if( transmit > 0 )  {
		if(rdebug&RDEBUG_REFRACT) {
			bu_log("rr_render: lvl=%d transmit=%g.  Calculate refraction at entrance to %s.\n",
				ap->a_level, transmit,
				pp->pt_regionp->reg_name );
		}
		/*
		 *  Calculate refraction at entrance.
		 */
		sub_ap = *ap;		/* struct copy */
#if RT_MULTISPECTRAL
		sub_ap.a_spectrum = bn_tabdata_dup( (struct bn_tabdata *)ap->a_spectrum );
#endif
		sub_ap.a_level = 0;	/* # of internal reflections */
		sub_ap.a_cumlen = 0;	/* distance through the glass */
		sub_ap.a_user = -1;	/* sanity */
		sub_ap.a_rbeam = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
		sub_ap.a_diverge = 0.0;
		sub_ap.a_uptr = (genptr_t)(pp->pt_regionp);
		VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
		VMOVE( incident_dir, ap->a_ray.r_dir );

		/* If there is an air gap, reset ray's RI to air */
		if( pp->pt_inhit->hit_dist > AIR_GAP_TOL )
			sub_ap.a_refrac_index = RI_AIR;

		if( sub_ap.a_refrac_index != swp->sw_refrac_index &&
		    !rr_refract( incident_dir,		/* input direction */
			swp->sw_hit.hit_normal,		/* exit normal */
			sub_ap.a_refrac_index,		/* current RI */
			swp->sw_refrac_index,		/* next RI */
			sub_ap.a_ray.r_dir		/* output direction */
		) )  {
			/*
			 *  Ray was mirror reflected back outside solid.
			 *  Just add contribution to reflection,
			 *  and quit.
			 */
			reflect += transmit;
			transmit = 0;
#if RT_MULTISPECTRAL
			ms_transmit_color = bn_tabdata_get_constval( 0.0, spectrum );
#else
			VSETALL( transmit_color, 0 );
#endif
			if(rdebug&RDEBUG_REFRACT) {
				bu_log("rr_render: lvl=%d change xmit into reflection %s\n",
					ap->a_level,
					pp->pt_regionp->reg_name );
			}
			goto do_reflection;
		}
		if(rdebug&RDEBUG_REFRACT) {
			bu_log("rr_render: lvl=%d begin transmission through %s.\n",
				ap->a_level,
				pp->pt_regionp->reg_name );
		}

		/*
		 *  Find new exit point from the inside. 
		 *  We will iterate, but not recurse, due to the special
		 *  (non-recursing) hit and miss routines used here for
		 *  internal reflection.
		 *
		 *  a_onehit is set to 3, so that where possible,
		 *  rr_hit() will be given three accurate hit points:
		 *  the entry and exit points of this glass region,
		 *  and the entry point into the next region.
		 *  This permits calculation of the departing
		 *  refraction angle based on the RI of the current and
		 *  *next* regions along the ray.
		 */
		sub_ap.a_purpose = "rr first glass transmission ray";
		sub_ap.a_flag = 0;
do_inside:
		sub_ap.a_hit =  rr_hit;
		sub_ap.a_miss = rr_miss;
		sub_ap.a_onehit = 3;
		sub_ap.a_rbeam = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
		sub_ap.a_diverge = 0.0;
		switch( code = rt_shootray( &sub_ap ) )  {
		case 3:
			/* More glass to come.
			 *  uvec=exit_pt, vvec=N, a_refrac_index = next RI.
			 */
			break;
		case 2:
			/* No more glass to come.
			 *  uvec=exit_pt, vvec=N, a_refrac_index = next RI.
			 */
			break;
		case 1:
			/* Treat as escaping ray */
			if(rdebug&RDEBUG_REFRACT)
				bu_log("rr_refract: Treating as escaping ray\n");
			goto do_exit;
		case 0:
		default:
			/* Dreadful error */
#if RT_MULTISPECTRAL
			bu_bomb("rr_refract: Stuck in glass. Very green pixel, unsupported in multi-spectral mode\n");
#else
			VSET( swp->sw_color, 0, 99, 0 ); /* very green */
#endif
			goto out;			/* abandon hope */
		}

		if(rdebug&RDEBUG_REFRACT)  {
			bu_log("rr_render: calculating refraction @@ exit from %s (green)\n", pp->pt_regionp->reg_name);
			bu_log("Start point to exit point:\n\
vdraw open rr;vdraw params c 00ff00; vdraw write n 0 %g %g %g; vdraw wwrite n 1 %g %g %g; vdraw send\n",
				V3ARGS(sub_ap.a_ray.r_pt),
				V3ARGS(sub_ap.a_uvec) );
		}
		/* NOTE: rr_hit returns EXIT Point in sub_ap.a_uvec,
		 *  and returns EXIT Normal in sub_ap.a_vvec,
		 *  and returns next RI in sub_ap.a_refrac_index
		 */
		if( rdebug&RDEBUG_RAYWRITE )  {
			wraypts( sub_ap.a_ray.r_pt,
				sub_ap.a_ray.r_dir,
				sub_ap.a_uvec,
				2, ap, stdout );	/* 2 = ?? */
		}
		if( rdebug&RDEBUG_RAYPLOT )  {
			/* plotfp */
			bu_semaphore_acquire( BU_SEM_SYSCALL );
			pl_color( stdout, 0, 255, 0 );
			pdv_3line( stdout,
				sub_ap.a_ray.r_pt,
				sub_ap.a_uvec );
			bu_semaphore_release( BU_SEM_SYSCALL );
		}
		/* Advance.  Exit point becomes new start point */
		VMOVE( sub_ap.a_ray.r_pt, sub_ap.a_uvec );
		VMOVE( incident_dir, sub_ap.a_ray.r_dir );

		/*
		 *  Calculate refraction at exit point.
		 *  Use "look ahead" RI value from rr_hit.
		 */
		if( sub_ap.a_refrac_index != swp->sw_refrac_index &&
		    !rr_refract( incident_dir,		/* input direction */
			sub_ap.a_vvec,			/* exit normal */
			swp->sw_refrac_index,		/* current RI */
			sub_ap.a_refrac_index,		/* next RI */
			sub_ap.a_ray.r_dir		/* output direction */
		) )  {
			static long count = 0;		/* not PARALLEL, should be OK */

			/* Reflected internally -- keep going */
			if( (++sub_ap.a_level) <= max_ireflect )  {
				sub_ap.a_purpose = "rr reflected internal ray, probing for glass exit point";
				sub_ap.a_flag = 0;
				goto do_inside;
			}

			/*
			 *  Internal Reflection limit exceeded -- just let
			 *  the ray escape, continuing on current course.
			 *  This will cause some energy from somewhere in the
			 *  sceen to be received through this glass,
			 *  which is much better than just returning
			 *  grey or black, as before.
			 */
			if( (rdebug&(RDEBUG_SHOWERR|RDEBUG_REFRACT)) && (
				count++ < MSG_PROLOGUE ||
				(count%MSG_INTERVAL) == 3
			) )  {
				bu_log("rr_render: %d,%d Int.reflect=%d: %s lvl=%d\n",
					sub_ap.a_x, sub_ap.a_y,
					sub_ap.a_level,
					pp->pt_regionp->reg_name,
					ap->a_level );
			}
			VMOVE( sub_ap.a_ray.r_dir, incident_dir );
			goto do_exit;
		}
do_exit:
		/*
		 *  Compute internal spectral transmittance.
		 *  Bouger's law.  pg 30 of "color science"
		 *
		 *  Apply attenuation factor due to thickness of the glass.
		 *  sw_extinction is in terms of fraction of light absorbed
		 *  per linear meter of glass.  a_cumlen is in mm.
		 */
/* XXX extinction should be a spectral curve, not scalor */
		if( swp->sw_extinction > 0 && sub_ap.a_cumlen > 0 )  {
			attenuation = pow( 10.0, -1.0e-3 * sub_ap.a_cumlen *
				swp->sw_extinction );
		} else {
			attenuation = 1;
		}

		/*
		 *  Process the escaping refracted ray.
		 *  This is the only place we might recurse dangerously,
		 *  so we are careful to use our caller's recursion level+1.
		 *  NOTE: point & direction already filled in
		 */
		sub_ap.a_hit =  ap->a_hit;
		sub_ap.a_miss = ap->a_miss;
		sub_ap.a_onehit = ap->a_onehit;
		sub_ap.a_level = ap->a_level+1;
		sub_ap.a_uptr = ap->a_uptr;
		sub_ap.a_rbeam = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
		sub_ap.a_diverge = 0.0;
		if( code == 3 )  {
			sub_ap.a_purpose = "rr recurse on next glass";
			sub_ap.a_flag = 0;
		}  else  {
			sub_ap.a_purpose = "rr recurse on escaping internal ray";
			sub_ap.a_flag = 1;
			sub_ap.a_onehit = sub_ap.a_onehit > -3 ? -3 : sub_ap.a_onehit;
		}
		/* sub_ap.a_refrac_index was set to RI of next material by rr_hit().
		 */
		sub_ap.a_cumlen = 0;
		(void) rt_shootray( &sub_ap );

		/* a_user has hit/miss flag! */
		if( sub_ap.a_user == 0 )  {
#if RT_MULTISPECTRAL
			bn_tabdata_copy( ms_transmit_color, background );
#else
			VMOVE( transmit_color, background );
#endif
			sub_ap.a_cumlen = 0;
		} else {
#if RT_MULTISPECTRAL
			bn_tabdata_copy( ms_transmit_color, sub_ap.a_spectrum );
#else
			VMOVE( transmit_color, sub_ap.a_color );
#endif
		}
		transmit *= attenuation;
#if RT_MULTISPECTRAL
		bn_tabdata_mul( ms_transmit_color, ms_filter_color, ms_transmit_color );
#else
		VELMUL( transmit_color, filter_color, transmit_color );
#endif
		if(rdebug&RDEBUG_REFRACT) {
			bu_log("rr_render: lvl=%d end of xmit through %s\n",
				ap->a_level,
				pp->pt_regionp->reg_name );
		}
	} else {
#if RT_MULTISPECTRAL
		bn_tabdata_constval( ms_transmit_color, 0.0 );
#else
		VSETALL( transmit_color, 0 );
#endif
	}

	/*
	 *  Handle any reflection, including mirror reflections
	 *  detected by the transmission code, above.
	 */
do_reflection:
#if RT_MULTISPECTRAL
	if(sub_ap.a_spectrum)  {
		bu_free(sub_ap.a_spectrum, "rr_render: sub_ap.a_spectrum bn_tabdata*");
		sub_ap.a_spectrum = BN_TABDATA_NULL;
	}
#endif
	if( reflect > 0 )  {
		register fastf_t	f;

		/* Mirror reflection */
		if(rdebug&RDEBUG_REFRACT)
			bu_log("rr_render: calculating mirror reflection off of %s\n", pp->pt_regionp->reg_name);
		sub_ap = *ap;		/* struct copy */
#if RT_MULTISPECTRAL
		sub_ap.a_spectrum = bn_tabdata_dup( (struct bn_tabdata *)ap->a_spectrum );
#endif
		sub_ap.a_rbeam = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
		sub_ap.a_diverge = 0.0;
		sub_ap.a_level = ap->a_level+1;
		sub_ap.a_onehit = -1;	/* Require at least one non-air hit */
		VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
		VREVERSE( to_eye, ap->a_ray.r_dir );
		f = 2 * VDOT( to_eye, swp->sw_hit.hit_normal );
		VSCALE( work, swp->sw_hit.hit_normal, f );
		/* I have been told this has unit length */
		VSUB2( sub_ap.a_ray.r_dir, work, to_eye );
		sub_ap.a_purpose = "rr reflected ray";
		sub_ap.a_flag = 0;

		if( rdebug&(RDEBUG_RAYPLOT|RDEBUG_REFRACT) )  {
			point_t		endpt;
			/* Plot the surface normal -- green/blue */
			/* plotfp */
			f = sub_ap.a_rt_i->rti_radius * 0.02;
			VJOIN1( endpt, sub_ap.a_ray.r_pt,
				f, swp->sw_hit.hit_normal );
			if(rdebug&RDEBUG_RAYPLOT)  {
				bu_semaphore_acquire( BU_SEM_SYSCALL );
				pl_color( stdout, 0, 255, 255 );
				pdv_3line( stdout, sub_ap.a_ray.r_pt, endpt );
				bu_semaphore_release( BU_SEM_SYSCALL );
			}
			bu_log("Surface normal for reflection:\n\
vdraw open rrnorm;vdraw params c 00ffff;vdraw write n 0 %g %g %g;vdraw write n 1 %g %g %g;vdraw send\n",
				V3ARGS(sub_ap.a_ray.r_pt),
				V3ARGS(endpt) );

		}

		(void)rt_shootray( &sub_ap );

		/* a_user has hit/miss flag! */
		if( sub_ap.a_user == 0 )  {
			/* MISS */
#if RT_MULTISPECTRAL
			bn_tabdata_copy( ms_reflect_color, background );
#else
			VMOVE( reflect_color, background );
#endif
		} else {
			ap->a_cumlen += sub_ap.a_cumlen;
#if RT_MULTISPECTRAL
			bn_tabdata_copy( ms_reflect_color, sub_ap.a_spectrum );
#else
			VMOVE( reflect_color, sub_ap.a_color );
#endif
		}
	} else {
#if RT_MULTISPECTRAL
		bn_tabdata_constval( ms_reflect_color, 0.0 );
#else
		VSETALL( reflect_color, 0 );
#endif
	}

	/*
	 *  Collect the contributions to the final color
	 */
#if RT_MULTISPECTRAL
	bn_tabdata_join2( swp->msw_color, ms_shader_color,
		reflect, ms_reflect_color,
		transmit, ms_transmit_color );
#else
	VJOIN2( swp->sw_color, shader_color,
		reflect, reflect_color,
		transmit, transmit_color );
#endif
	if(rdebug&RDEBUG_REFRACT)  {
		bu_log("rr_render: lvl=%d end shader=%g reflect=%g, transmit=%g %s\n",
			ap->a_level,
			shader_fract, reflect, transmit,
			pp->pt_regionp->reg_name );
#if RT_MULTISPECTRAL
		{ struct bu_vls str;
			bu_vls_init(&str);
			bu_vls_strcat(&str, "ms_shader_color: ");
			bn_tabdata_to_tcl( &str, ms_shader_color);
			bu_vls_strcat(&str, "\nms_reflect_color: ");
			bn_tabdata_to_tcl( &str, ms_reflect_color);
			bu_vls_strcat(&str, "\nms_transmit_color: ");
			bn_tabdata_to_tcl( &str, ms_transmit_color);
			bu_log("rr_render: %s\n", bu_vls_addr(&str) );
			bu_vls_free(&str);
		}
#else
		VPRINT("shader  ", shader_color);
		VPRINT("reflect ", reflect_color);
		VPRINT("transmit", transmit_color);
#endif
	}
out:
	if(rdebug&RDEBUG_REFRACT)  {
#if RT_MULTISPECTRAL
		{ struct bu_vls str;
			bu_vls_init(&str);
			bu_vls_strcat(&str, "final swp->msw_color: ");
			bn_tabdata_to_tcl( &str, swp->msw_color);
			bu_log("rr_render: %s\n", bu_vls_addr(&str) );
			bu_vls_free(&str);
		}
#else
		VPRINT("final   ", swp->sw_color);
#endif
	}

	/* Release all the dynamic spectral curves */
#if RT_MULTISPECTRAL
	if(ms_filter_color) bu_free(ms_filter_color, "rr_render: ms_filter_color bn_tabdata*");
	if(ms_shader_color) bu_free(ms_shader_color, "rr_render: ms_shader_color bn_tabdata*");
	if(ms_reflect_color) bu_free(ms_reflect_color, "rr_render: ms_reflect_color bn_tabdata*");
	if(sub_ap.a_spectrum) bu_free(sub_ap.a_spectrum, "rr_render: sub_ap.a_spectrum bn_tabdata*");
#endif

	return(1);
}

/*
 *			R R _ M I S S
 */
HIDDEN int
/*ARGSUSED*/
rr_miss( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	RT_AP_CHECK(ap);
	return(1);	/* treat as escaping ray */
}

/*
 *			R R _ H I T
 *
 *  This routine is called when an internal reflection ray hits something
 *  (which is ordinarily the case).
 *
 *  Generally, there will be one or two partitions on the hit list.
 *  The values for pt_outhit for the second partition should not be used,
 *  as a_onehit was set to 3, getting a maximum of 3 valid hit points.
 *
 *  Explicit Returns -
 *	0	dreadful internal error
 *	1	treat as escaping ray & reshoot
 *	2	Proper exit point determined, with Implicit Returns:
 *			a_uvec		exit Point
 *			a_vvec		exit Normal (inward pointing)
 *			a_refrac_index	RI of *next* material
 */
HIDDEN int
rr_hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	register struct partition *pp;
	register struct hit	*hitp;
	register struct soltab	*stp;
	struct partition	*psave = (struct partition *)NULL;
	struct shadework	sw;
	struct application	appl;
	int			ret;

	RT_AP_CHECK(ap);

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist > 0.0 )  break;
	if( pp == PartHeadp )  {
		if(rdebug&(RDEBUG_SHOWERR|RDEBUG_REFRACT))  {
			bu_log("rr_hit:  %d,%d no hit out front?\n",
				ap->a_x, ap->a_y );
			ret = 0;	/* error */
			goto out;
		}
		ret = 1;		/* treat as escaping ray */
		goto out;
	}

	/*
	 *  Ensure that the partition we are given is part of the same
	 *  region that we started in.  When the internal reflection
	 *  is happening very near an edge or corner, this is not always
	 *  the case, and either (a) a small sliver of some other region
	 *  is found to be in the way, or (b) the ray completely misses the
	 *  region that it started in, although not by much.
	 */
	psave = pp;
	if(rdebug&RDEBUG_REFRACT) bu_log("rr_hit(%s)\n", psave->pt_regionp->reg_name);
	for( ; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_regionp == (struct region *)(ap->a_uptr) )  break;
	if( pp == PartHeadp )  {
		if(rdebug&(RDEBUG_SHOWERR|RDEBUG_REFRACT))  {
			bu_log("rr_hit:  %d,%d Ray internal to %s landed unexpectedly in %s\n",
				ap->a_x, ap->a_y,
				((struct region *)(ap->a_uptr))->reg_name,
				psave->pt_regionp->reg_name );
			ret = 0;	/* error */
			goto out;
		}
		ret = 1;		/* treat as escaping ray */
		goto out;
	}

	/*
	 *  At one time, this was a check for pp->pt_inhit->hit_dist
	 *  being NEAR zero.  That was a mistake, because we may have
	 *  been at the edge of a subtracted out center piece when
	 *  internal reflection happened, except that floating point
	 *  error (being right on the surface of the interior solid)
	 *  prevented us from "seeing" that solid on the next ray,
	 *  causing our ray endpoints to be quite far from the starting
	 *  point, yet with the ray still validly inside the glass region.
	 *
	 *  There is a major problem if the entry point
	 *  is further ahead than the firing point, ie, >0.
	 *
	 *  Because this error has not yet been encountered, it is
	 *  considered dreadful.  Some recovery may be possible.
	 *
	 * For now, this seems to happen when a reflected ray starts outside
	 * the glass and doesn't even intersect the glass, so treat it as
	 * an escaping ray.
	 */

	if( pp->pt_inhit->hit_dist > 10 )  {
		stp = pp->pt_inseg->seg_stp;
		if( rdebug&RDEBUG_REFRACT )
			bu_log("rr_hit: %d,%d %s inhit %g > 10.0! (treating as escaping ray)\n",
				ap->a_x, ap->a_y,
				pp->pt_regionp->reg_name,
				pp->pt_inhit->hit_dist);
		ret = 1;	/* treat as escaping ray */
		goto out;
	}

	/*
	 * If there is a very small crack in the glass, perhaps formed
	 * by a small error when taking the Union of two solids,
	 * attempt to find the real exit point.
	 * NOTE that this is usually taken care of inside librt
	 * in the bool_weave code, but it is inexpensive to check for it
	 * here.  If this case is detected, push on, and log it.
	 * This code is not expected to be needed.
	 */
	while( pp->pt_forw != PartHeadp )  {
		register fastf_t d;
		d = pp->pt_forw->pt_inhit->hit_dist - pp->pt_outhit->hit_dist;
		if( !NEAR_ZERO( d, AIR_GAP_TOL ) )
			break;
		if( pp->pt_forw->pt_regionp != pp->pt_regionp )
			break;
		if(rdebug&(RDEBUG_SHOWERR|RDEBUG_REFRACT)) bu_log(
			"rr_hit: %d,%d fusing small crack in glass %s\n",
			ap->a_x, ap->a_y,
			pp->pt_regionp->reg_name );
		pp = pp->pt_forw;
	}

	hitp = pp->pt_outhit;
	stp = pp->pt_outseg->seg_stp;
	if( hitp->hit_dist >= INFINITY )  {
		bu_log("rr_hit: %d,%d infinite glass (%g,%g) %s\n",
			ap->a_x, ap->a_y,
			pp->pt_inhit->hit_dist, hitp->hit_dist,
			pp->pt_regionp->reg_name );
		ret = 0;		/* dreadful error */
		goto out;
	}
	VJOIN1( hitp->hit_point, ap->a_ray.r_pt,
		hitp->hit_dist, ap->a_ray.r_dir );
	RT_HIT_NORMAL( ap->a_vvec, hitp, stp, &(ap->a_ray), pp->pt_outflip );

	/* For refraction, want exit normal to point inward. */
	VREVERSE( ap->a_vvec, ap->a_vvec );
	VMOVE( ap->a_uvec, hitp->hit_point );
	ap->a_cumlen += (hitp->hit_dist - pp->pt_inhit->hit_dist);

	ap->a_refrac_index = RI_AIR;			/* Default medium: air */

	/*
	 *  Look ahead, and see if there is more glass to come.
	 *  If so, obtain its refractive index, to enable correct
	 *  calculation of the departing refraction angle.
	 */
	if( pp->pt_forw != PartHeadp )  {
		register fastf_t	d;
		d = pp->pt_forw->pt_inhit->hit_dist - hitp->hit_dist;
		if( NEAR_ZERO( d, AIR_GAP_TOL ) )  {
			/*
			 * Make a private copy of the application struct,
			 * because viewshade() may change various fields.
			 */
			appl = *ap;			/* struct copy */

			memset( (char *)&sw, 0, sizeof(sw) );
			sw.sw_transmit = sw.sw_reflect = 0.0;

			/* Set default in case shader doesn't fill this in. */
			sw.sw_refrac_index = RI_AIR;

			/* Set special flag so that we get only shader
			 * parameters (refractive index, in this case).
			 * We don't even care about transmitted energy.
			 */
			sw.sw_xmitonly = 2;
			sw.sw_inputs = 0;		/* no fields filled yet */
#if RT_MULTISPECTRAL
			sw.msw_color = bn_tabdata_get_constval( 1.0, spectrum );
			sw.msw_basecolor = bn_tabdata_get_constval( 1.0, spectrum );
#else
			VSETALL( sw.sw_color, 1 );
			VSETALL( sw.sw_basecolor, 1 );
#endif

			if (rdebug&(RDEBUG_SHADE|RDEBUG_REFRACT))
				bu_log("rr_hit calling viewshade to discover refractive index\n");

			(void)viewshade( &appl, pp->pt_forw, &sw );

#if RT_MULTISPECTRAL
			bu_free( sw.msw_color, "sw.msw_color");
			bu_free( sw.msw_basecolor, "sw.msw_basecolor");
#endif

			if (rdebug&(RDEBUG_SHADE|RDEBUG_REFRACT))
				bu_log("rr_hit refractive index = %g\n", sw.sw_refrac_index);

			if( sw.sw_transmit > 0 )  {
				ap->a_refrac_index = sw.sw_refrac_index;
				if (rdebug&RDEBUG_SHADE)  {
					bu_log("rr_hit a_refrac_index=%g (trans=%g)\n",
						ap->a_refrac_index,
						sw.sw_transmit );
				}
				ret= 3;	/* OK -- more glass follows */
				goto out;
			}
		}
	}
	ret = 2;				/* OK -- no more glass */
out:
	if(rdebug&RDEBUG_REFRACT) bu_log("rr_hit(%s) return=%d\n",
		psave ? psave->pt_regionp->reg_name : "",
		ret);
	return ret;
}

/*
 *			R E F R A C T
 *
 *	Compute the refracted ray 'v_2' from the incident ray 'v_1' with
 *	the refractive indices 'ri_2' and 'ri_1' respectively.
 *	Using Schnell's Law:
 *
 *		theta_1 = angle of v_1 with surface normal
 *		theta_2 = angle of v_2 with reversed surface normal
 *		ri_1 * sin( theta_1 ) = ri_2 * sin( theta_2 )
 *
 *		sin( theta_2 ) = ri_1/ri_2 * sin( theta_1 )
 *		
 *	The above condition is undefined for ri_1/ri_2 * sin( theta_1 )
 *	being greater than 1, and this represents the condition for total
 *	reflection, the 'critical angle' is the angle theta_1 for which
 *	ri_1/ri_2 * sin( theta_1 ) equals 1.
 *
 *  Returns TRUE if refracted, FALSE if reflected.
 *
 *  Note:  output (v_2) can be same storage as an input.
 */
HIDDEN int
rr_refract( v_1, norml, ri_1, ri_2, v_2 )
register vect_t	v_1;
register vect_t	norml;
double	ri_1, ri_2;
register vect_t	v_2;
{
	LOCAL vect_t	w, u;
	FAST fastf_t	beta;

	if( NEAR_ZERO(ri_1, 0.0001) || NEAR_ZERO( ri_2, 0.0001 ) )  {
		bu_log("rr_refract:ri1=%g, ri2=%g\n", ri_1, ri_2 );
		beta = 1;
	} else {
		beta = ri_1/ri_2;		/* temp */
		if( beta > 10000 )  {
			bu_log("rr_refract:  beta=%g\n", beta);
			beta = 1000;
		}
	}
	VSCALE( w, v_1, beta );
	VCROSS( u, w, norml );
	    	
	/*
	 *	|w X norml| = |w||norml| * sin( theta_1 )
	 *	        |u| = ri_1/ri_2 * sin( theta_1 ) = sin( theta_2 )
	 */
	if( (beta = VDOT( u, u )) > 1.0 )  {
		/*  Past critical angle, total reflection.
		 *  Calculate reflected (bounced) incident ray.
		 */
		if(rdebug&RDEBUG_REFRACT) bu_log("rr_refract: reflected.  ri1=%g ri2=%g beta=%g\n",
			ri_1, ri_2, beta);
		VREVERSE( u, v_1 );
		beta = 2 * VDOT( u, norml );
		VSCALE( w, norml, beta );
		VSUB2( v_2, w, u );
		return(0);		/* reflected */
	} else {
		/*
		 * 1 - beta = 1 - sin( theta_2 )^^2
		 *	    = cos( theta_2 )^^2.
		 *     beta = -1.0 * cos( theta_2 ) - Dot( w, norml ).
		 */
		if(rdebug&RDEBUG_REFRACT) bu_log("rr_refract: refracted.  ri1=%g ri2=%g beta=%g\n",
			ri_1, ri_2, beta);
		beta = -sqrt( 1.0 - beta) - VDOT( w, norml );
		VSCALE( u, norml, beta );
		VADD2( v_2, w, u );		
		return(1);		/* refracted */
	}
	/* NOTREACHED */
}
@


11.33
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.31 2001/10/12 18:39:35 butler Exp $ (BRL)";
@


11.33.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/Attic/refract.c,v 11.33 2002/08/20 17:08:38 jra Exp $ (BRL)";
@


11.33.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.33 2002/08/20 17:08:38 jra Exp $ (BRL)";
d49 2
a50 2
HIDDEN int	rr_hit(register struct application *ap, struct partition *PartHeadp), rr_miss(register struct application *ap, struct partition *PartHeadp);
HIDDEN int	rr_refract(register fastf_t *v_1, register fastf_t *norml, double ri_1, double ri_2, register fastf_t *v_2);
d627 3
a629 1
rr_miss(register struct application *ap, struct partition *PartHeadp)
d654 3
a656 1
rr_hit(register struct application *ap, struct partition *PartHeadp)
d873 5
a877 1
rr_refract(register fastf_t *v_1, register fastf_t *norml, double ri_1, double ri_2, register fastf_t *v_2)
@


11.33.2.2
log
@updated hit and miss routines to match expected function pointer type
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.33.2.1 2002/09/19 18:02:15 morrison Exp $ (BRL)";
d49 2
a50 3
HIDDEN int rr_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segp);
HIDDEN int rr_miss(register struct application *ap);
HIDDEN int rr_refract(register fastf_t *v_1, register fastf_t *norml, double ri_1, double ri_2, register fastf_t *v_2);
d627 1
a627 1
rr_miss(register struct application *ap)
d652 1
a652 1
rr_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segp)
@


11.32
log
@Converted from K&R to ANSI C - RFH
@
text
@d49 2
a50 2
HIDDEN int	rr_hit(register struct application *ap, struct partition *PartHeadp), rr_miss(register struct application *ap, struct partition *PartHeadp);
HIDDEN int	rr_refract(register fastf_t *v_1, register fastf_t *norml, double ri_1, double ri_2, register fastf_t *v_2);
d627 3
a629 1
rr_miss(register struct application *ap, struct partition *PartHeadp)
d654 3
a656 1
rr_hit(register struct application *ap, struct partition *PartHeadp)
d873 5
a877 1
rr_refract(register fastf_t *v_1, register fastf_t *norml, double ri_1, double ri_2, register fastf_t *v_2)
@


11.31
log
@forced rt_g.debug printing for certain cases, updated the "vdraw" debugging
output to match current syntax.
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.30 2001/05/16 21:38:18 morrison Exp $ (BRL)";
d49 2
a50 2
HIDDEN int	rr_hit(), rr_miss();
HIDDEN int	rr_refract();
d627 1
a627 3
rr_miss( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
d652 1
a652 3
rr_hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
d869 1
a869 5
rr_refract( v_1, norml, ri_1, ri_2, v_2 )
register vect_t	v_1;
register vect_t	norml;
double	ri_1, ri_2;
register vect_t	v_2;
@


11.30
log
@PRODUCTION optimizations
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.29 2001/04/05 19:36:04 morrison Exp $ (BRL)";
d336 1
a336 1
vdraw o rr;vdraw p c 00ff00; vdraw w n 0 %g %g %g; vdraw w n 1 %g %g %g; vdraw s\n",
d529 1
a529 1
vdraw o rrnorm;vdraw p c 00ffff;vdraw w n 0 %g %g %g;vdraw w n 1 %g %g %g;vdraw s\n",
@


11.29
log
@updated SIGNED to signed
updated CONST to const
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.28 2001/03/19 22:20:14 butler Exp $ (BRL)";
d797 1
a797 1
			bzero( (char *)&sw, sizeof(sw) );
@


11.28
log
@patches to merge 5.3 into 6.0
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /d/CVS/brlcad/rt/refract.c,v 11.27 2000/10/20 18:55:00 mike Exp $ (BRL)";
d53 1
a53 1
extern CONST struct bn_table	*spectrum;
@


11.27
log
@
Locking for making plot files in parallel.
Keeps CPUs from tripping over each other.
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.26 2000/08/29 20:47:23 butler Exp $ (BRL)";
d299 1
d379 1
d436 1
d439 2
d513 1
d721 4
d726 1
d729 6
a734 5
		bu_log("rr_hit: %d,%d %s inhit %g > 10.0!\n",
			ap->a_x, ap->a_y,
			pp->pt_regionp->reg_name,
			pp->pt_inhit->hit_dist);
		ret = 0;		/* dreadful error */
@


11.26
log
@ANSI-ized rr_render at time function prototype added to rtprivate.h
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.25 2000/08/17 02:41:35 mike Exp $ (BRL)";
d351 1
d356 1
a512 1
			if(rdebug&RDEBUG_RAYPLOT) pl_color( stdout, 0, 255, 255 );
d516 6
a521 1
			if(rdebug&RDEBUG_RAYPLOT) pdv_3line( stdout, sub_ap.a_ray.r_pt, endpt );
@


11.25
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d17 1
a17 1
static const char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.24 2000/07/27 19:32:52 butler Exp $ (BRL)";
d63 3
a65 4
rr_render( ap, pp, swp )
register struct application *ap;
struct partition	*pp;
struct shadework	*swp;
@


11.24
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.23 2000/07/25 16:39:48 butler Exp $ (BRL)";
@


11.23
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.22 1999/12/04 01:16:15 mike Exp $ (BRL)";
d23 1
d32 6
@


11.22
log
@
Additional debugging.
Set sw_xmitonly = 2
when all we want from the shader is the material properties,
and not any shading at all.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.21 1999/12/04 00:10:18 mike Exp $ (BRL)";
d28 1
a28 1
#include "./rdebug.h"
d64 4
d70 3
a74 5
#endif
	fastf_t	shader_fract;
#if RT_MULTISPECTRAL
	struct bn_tabdata	*ms_shader_color = BN_TABDATA_NULL;
#else
a75 5
#endif
	fastf_t	reflect;
#if RT_MULTISPECTRAL
	struct bn_tabdata	*ms_reflect_color = BN_TABDATA_NULL;
#else
a76 5
#endif
	fastf_t	transmit;
#if RT_MULTISPECTRAL
	struct bn_tabdata	*ms_transmit_color = BN_TABDATA_NULL;
#else
d79 1
@


11.22.2.1
log
@Fixed bug where an escaping ray after refraction would see a sliver of the
glass that it was supposed to escape from. Uses new "a_flag" field of
application structure.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.22 1999/12/04 01:16:15 mike Exp $ (BRL)";
a299 1
		sub_ap.a_flag = 0;
a376 1
				sub_ap.a_flag = 0;
a432 1
			sub_ap.a_flag = 0;
a434 2
			sub_ap.a_flag = 1;
			sub_ap.a_onehit = sub_ap.a_onehit > -3 ? -3 : sub_ap.a_onehit;
a506 1
		sub_ap.a_flag = 0;
@


11.22.2.2
log
@A couple kludges to avoid errors where refracted or reflected rays
unexpectedly hit/miss the glass region.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.22.2.1 2000/11/28 00:04:30 jra Exp $ (BRL)";
a715 4
	 *
	 * For now, this seems to happen when a reflected ray starts outside
	 * the glass and doesn't even intersect the glass, so treat it as
	 * an escaping ray.
a716 1

d719 5
a723 6
		if( rdebug&RDEBUG_REFRACT )
			bu_log("rr_hit: %d,%d %s inhit %g > 10.0! (treating as escaping ray)\n",
				ap->a_x, ap->a_y,
				pp->pt_regionp->reg_name,
				pp->pt_inhit->hit_dist);
		ret = 1;	/* treat as escaping ray */
@


11.21
log
@
Added lots more debugging, including
cut-n-paste into MGED style "vdraw" commands,
for one-ray-at-a-time debugging as you read along in the log.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.20 1999/12/03 20:48:28 mike Exp $ (BRL)";
d490 2
d510 1
a510 1
			/* Plot the surface normal -- forrest green */
d512 1
a512 1
			if(rdebug&RDEBUG_RAYPLOT) pl_color( stdout, 192, 255, 192 );
d517 2
a518 2
			bu_log("Surface normal:\n\
vdraw o rrnorm;vdraw p c c0ffc0;vdraw w n 0 %g %g %g;vdraw w n 1 %g %g %g;vdraw s\n",
d782 2
d785 6
a790 1
			sw.sw_xmitonly = 1;		/* want XMIT data only */
a801 4
			/* XXX Need better flag here, to keep viewshade
			 * XXX from feeing the need to fire extra rays, etc.
			 * XXX We need even less info that "sw_xmitonly".
			 */
@


11.20
log
@
Made both invocations of rr_refract() be the same.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.19 1999/05/28 01:17:25 mike Exp $ (BRL)";
d118 7
d229 2
a230 2
			bu_log("rr_render: lvl=%d begin xmit through %s\n",
				ap->a_level,
d279 5
d299 1
a302 1
		sub_ap.a_purpose = "rr internal ray probing for glass exit pnt";
d333 7
a339 3
		if(rdebug&RDEBUG_REFRACT)
			bu_log("rr_render: calculating refraction @@ exit from %s\n", pp->pt_regionp->reg_name);

d375 2
a376 1
			if( (++sub_ap.a_level) <= max_ireflect )
d378 1
d506 1
a506 1
		if( rdebug&RDEBUG_RAYPLOT )  {
d510 1
a510 1
			pl_color( stdout, 100, 255, 100 );
d514 6
a519 1
			pdv_3line( stdout, sub_ap.a_ray.r_pt, endpt );
d648 1
a648 1
	struct partition	*psave;				
d651 1
d661 2
a662 1
			return(0);	/* error */
d664 2
a665 1
		return(1);		/* treat as escaping ray */
d677 1
d682 1
a682 1
			bu_log("rr_hit:  %d,%d Ray int.reflected in %s landed in %s\n",
d686 2
a687 1
			return(0);	/* error */
d689 2
a690 1
		return(1);		/* treat as escaping ray */
d715 2
a716 1
		return(0);		/* dreadful error */
d749 2
a750 1
		return(0);		/* dreadful error */
d791 1
a791 1
			if (rdebug&RDEBUG_SHADE)
d793 4
d805 3
d815 2
a816 1
				return 3;	/* OK -- more glass follows */
d820 6
a825 1
	return 2;				/* OK -- no more glass */
@


11.19
log
@
sed4
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.18 1998/12/11 22:53:21 mike Exp $ (BRL)";
d349 2
a350 1
		if( !rr_refract( incident_dir,		/* input direction */
@


11.18
log
@Converted from rt_tabdata to bn_tabdata.

Added -!0100 flag to opt.c to allow setting of libbu debug bits from
command line.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.17 1998/12/10 08:28:48 mike Exp $ (BRL)";
d129 1
a129 1
			rt_log("rr_render: %d,%d MAX BOUNCES=%d: %s\n",
d203 1
a203 1
		rt_log("rr_render: lvl=%d start shader=%g, reflect=%g, transmit=%g %s\n",
d222 1
a222 1
			rt_log("rr_render: lvl=%d begin xmit through %s\n",
d266 1
a266 1
				rt_log("rr_render: lvl=%d change xmit into reflection %s\n",
d308 1
a308 1
				rt_log("rr_refract: Treating as escaping ray\n");
d322 1
a322 1
			rt_log("rr_render: calculating refraction @@ exit from %s\n", pp->pt_regionp->reg_name);
d373 1
a373 1
				rt_log("rr_render: %d,%d Int.reflect=%d: %s lvl=%d\n",
d444 1
a444 1
			rt_log("rr_render: lvl=%d end of xmit through %s\n",
d537 1
a537 1
		rt_log("rr_render: lvl=%d end shader=%g reflect=%g, transmit=%g %s\n",
d634 1
a634 1
			rt_log("rr_hit:  %d,%d no hit out front?\n",
d654 1
a654 1
			rt_log("rr_hit:  %d,%d Ray int.reflected in %s landed in %s\n",
d681 1
a681 1
		rt_log("rr_hit: %d,%d %s inhit %g > 10.0!\n",
d704 1
a704 1
		if(rdebug&(RDEBUG_SHOWERR|RDEBUG_REFRACT)) rt_log(
d714 1
a714 1
		rt_log("rr_hit: %d,%d infinite glass (%g,%g) %s\n",
d760 1
a760 1
				rt_log("rr_hit calling viewshade to discover refractive index\n");
d772 1
a772 1
					rt_log("rr_hit a_refrac_index=%g (trans=%g)\n",
d816 1
a816 1
		rt_log("rr_refract:ri1=%g, ri2=%g\n", ri_1, ri_2 );
d821 1
a821 1
			rt_log("rr_refract:  beta=%g\n", beta);
d836 1
a836 1
		if(rdebug&RDEBUG_REFRACT) rt_log("rr_refract: reflected.  ri1=%g ri2=%g beta=%g\n",
d849 1
a849 1
		if(rdebug&RDEBUG_REFRACT) rt_log("rr_refract: refracted.  ri1=%g ri2=%g beta=%g\n",
@


11.17
log
@Mis-spelled routine name.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.16 1998/11/17 22:59:05 mike Exp $ (BRL)";
a30 3
#if RT_MULTISPECTRAL
# include "tabdata.h"
#endif
d46 2
a47 2
extern CONST struct rt_table	*spectrum;
extern struct rt_tabdata	*background; /* from rttherm/viewtherm.c */
d65 1
a65 1
	struct rt_tabdata	*ms_filter_color = RT_TABDATA_NULL;
d71 1
a71 1
	struct rt_tabdata	*ms_shader_color = RT_TABDATA_NULL;
d77 1
a77 1
	struct rt_tabdata	*ms_reflect_color = RT_TABDATA_NULL;
d83 1
a83 1
	struct rt_tabdata	*ms_transmit_color = RT_TABDATA_NULL;
d97 1
a97 1
	sub_ap.a_spectrum = RT_TABDATA_NULL;
d143 3
a145 3
		RT_CK_TABDATA(swp->msw_color);
		RT_CK_TABDATA(swp->msw_basecolor);
		rt_tabdata_copy( swp->msw_color, swp->msw_basecolor );
d153 2
a154 2
	RT_CK_TABDATA(swp->msw_basecolor);
	ms_filter_color = rt_tabdata_dup( swp->msw_basecolor );
d209 2
a210 2
	RT_GET_TABDATA( ms_shader_color, swp->msw_color->table );
	rt_tabdata_scale( ms_shader_color, swp->msw_color, shader_fract );
d231 1
a231 1
		sub_ap.a_spectrum = rt_tabdata_dup( (struct rt_tabdata *)ap->a_spectrum );
d261 1
a261 1
			ms_transmit_color = rt_tabdata_get_constval( 0.0, spectrum );
d425 1
a425 1
			rt_tabdata_copy( ms_transmit_color, background );
d432 1
a432 1
			rt_tabdata_copy( ms_transmit_color, sub_ap.a_spectrum );
d439 1
a439 1
		rt_tabdata_mul( ms_transmit_color, ms_filter_color, ms_transmit_color );
d450 1
a450 1
		rt_tabdata_constval( ms_transmit_color, 0.0 );
d463 2
a464 2
		bu_free(sub_ap.a_spectrum, "rr_render: sub_ap.a_spectrum rt_tabdata*");
		sub_ap.a_spectrum = RT_TABDATA_NULL;
d473 1
a473 1
		sub_ap.a_spectrum = rt_tabdata_dup( (struct rt_tabdata *)ap->a_spectrum );
d504 1
a504 1
			rt_tabdata_copy( ms_reflect_color, background );
d511 1
a511 1
			rt_tabdata_copy( ms_reflect_color, sub_ap.a_spectrum );
d518 1
a518 1
		rt_tabdata_constval( ms_reflect_color, 0.0 );
d528 1
a528 1
	rt_tabdata_join2( swp->msw_color, ms_shader_color,
d545 1
a545 1
			rt_tabdata_to_tcl( &str, ms_shader_color);
d547 1
a547 1
			rt_tabdata_to_tcl( &str, ms_reflect_color);
d549 1
a549 1
			rt_tabdata_to_tcl( &str, ms_transmit_color);
d565 1
a565 1
			rt_tabdata_to_tcl( &str, swp->msw_color);
d576 4
a579 4
	if(ms_filter_color) bu_free(ms_filter_color, "rr_render: ms_filter_color rt_tabdata*");
	if(ms_shader_color) bu_free(ms_shader_color, "rr_render: ms_shader_color rt_tabdata*");
	if(ms_reflect_color) bu_free(ms_reflect_color, "rr_render: ms_reflect_color rt_tabdata*");
	if(sub_ap.a_spectrum) bu_free(sub_ap.a_spectrum, "rr_render: sub_ap.a_spectrum rt_tabdata*");
d752 2
a753 2
			sw.msw_color = rt_tabdata_get_constval( 1.0, spectrum );
			sw.msw_basecolor = rt_tabdata_get_constval( 1.0, spectrum );
@


11.16
log
@Initial multispectral support
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.15 1998/09/22 01:43:10 mike Exp $ (BRL)";
d547 1
a547 1
			bu_vls_puts(&str, "ms_shader_color: ");
d549 1
a549 1
			bu_vls_puts(&str, "\nms_reflect_color: ");
d551 1
a551 1
			bu_vls_puts(&str, "\nms_transmit_color: ");
d567 1
a567 1
			bu_vls_puts(&str, "final swp->msw_color: ");
@


11.15
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /c/CVS/brlcad/rt/refract.c,v 11.14 1998/01/13 12:44:36 mike Exp $ (BRL)";
d31 3
d48 6
a53 1
extern vect_t	background;
d67 3
d71 1
d73 3
d77 1
d79 3
d83 1
d85 3
d89 1
d99 4
d145 5
d151 1
d155 5
d161 1
d211 4
d216 1
d233 3
d263 3
d267 1
d316 3
d320 1
d394 1
d427 3
d431 1
d434 3
d438 1
d441 3
d445 1
d452 3
d456 1
d464 6
d475 3
d506 3
d510 1
d513 3
d517 1
d520 3
d524 1
d530 5
d538 1
d544 13
d560 1
d564 9
d574 1
d576 9
d754 4
d760 1
d766 5
@


11.14
log
@Eliminate reflection rays on "xmitonly" computations.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.13 1997/12/09 04:44:04 butler Exp mike $ (BRL)";
d29 2
a30 1
#include "./material.h"
@


11.13
log
@beam radius and divergence for light rays, plus removed abortive hack.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/refract.c,v 11.12 1997/08/28 23:47:39 mike Exp butler $ (BRL)";
d74 18
a91 6
/*	This prevents us from shadowing as a result of procedural shaders. Lee
 *	if( swp->sw_xmitonly )  return 1;
 */

	reflect = swp->sw_reflect;
	transmit = swp->sw_transmit;
@


11.12
log
@Changed use of a_onehit to require at least one NON-AIR hit.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.11 1997/03/04 04:39:25 mike Exp mike $ (BRL)";
d74 3
a76 1
	if( swp->sw_xmitonly )  return 1;
d178 2
d230 2
d343 2
d383 2
@


11.11
log
@Put in bullet-proofing for xmit-only case (light vis rays).
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.10 1997/01/30 13:39:54 jra Exp mike $ (BRL)";
d376 1
a376 1
		sub_ap.a_onehit = 1;
@


11.10
log
@Set max_ireflect and max_bounces back to 5.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.9 1997/01/29 21:25:11 mike Exp jra $ (BRL)";
d73 2
@


11.9
log
@Debug stuff.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.8 1996/05/09 03:23:54 butler Exp mike $ (BRL)";
d31 2
a32 2
int	max_ireflect = 15;	/* Maximum internal reflection level */
int	max_bounces = 15;	/* Maximum recursion level */
@


11.8
log
@fixed light visibility ray calcualtion when "pushing" through glass
toward light.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.7 1996/03/29 23:20:55 mike Exp butler $ (BRL)";
d68 3
d106 14
d261 1
d385 3
a387 2
			/* Plot the surface normal */
			pl_color( stdout, 0, 255, 0 );
@


11.7
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.6 1995/12/11 20:28:19 jra Exp mike $ (BRL)";
d316 1
@


11.6
log
@Bumped recursion level up to 15.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.5 1995/12/11 20:21:57 jra Exp jra $ (BRL)";
d547 1
a547 4
	RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
	if( pp->pt_outflip )  {
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
	}
d550 1
a550 1
	VREVERSE( ap->a_vvec, hitp->hit_normal );
@


11.5
log
@Increased maximum recursion level from 5 to 10.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.4 1995/08/23 05:05:47 mike Exp jra $ (BRL)";
d31 2
a32 2
int	max_ireflect = 10;	/* Maximum internal reflection level */
int	max_bounces = 10;	/* Maximum recursion level */
@


11.4
log
@Fixed bug that Lee was having with multiple glasses of differing RI
being stacked next to each other.
RI tracking was in error.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.3 1995/08/23 04:36:58 butler Exp mike $ (BRL)";
d31 2
a32 2
int	max_ireflect = 5;	/* Maximum internal reflection level */
int	max_bounces = 5;	/* Maximum recursion level */
@


11.3
log
@more debugging to help understand the glass/glass interface problem
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/refract.c,v 11.2 1995/08/22 02:03:48 butler Exp butler $ (BRL)";
d316 1
a316 1
		if( code == 3 )
d318 1
a318 1
		else
d320 3
a322 1
		sub_ap.a_refrac_index = swp->sw_refrac_index;
@


11.2
log
@Improved debugging
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 11.1 1995/01/04 10:00:48 mike Rel4_4 butler $ (BRL)";
d67 1
d205 1
a205 1
		sub_ap.a_purpose = "rr internal ray seeking exit";
d207 6
a212 1
		switch( rt_shootray( &sub_ap ) )  {
d214 3
a216 1
			/* All is well, implicit returns stored in sub_ap */
d220 2
d230 3
d249 1
d254 1
a254 1
		 *  Calculate refraction at exit.
d316 4
a319 1
		sub_ap.a_purpose = "rr escaping internal ray";
d550 7
a561 1
	ap->a_refrac_index = RI_AIR;			/* Default medium: air */
d574 1
a574 1
			sw.sw_refrac_index = 1.0;
a583 1
			ap->a_refrac_index = sw.sw_refrac_index;
d585 9
a593 2
			if (rdebug&RDEBUG_SHADE)
				rt_log("rr_hit a_refrac_index=%g\n", ap->a_refrac_index);
d596 1
a596 6

	/* For refraction, want exit normal to point inward. */
	VREVERSE( ap->a_vvec, hitp->hit_normal );
	VMOVE( ap->a_uvec, hitp->hit_point );
	ap->a_cumlen += (hitp->hit_dist - pp->pt_inhit->hit_dist);
	return(2);			/* OK */
@


11.1
log
@Release_4.4
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 10.3 94/11/05 02:49:20 mike Exp $ (BRL)";
d204 1
a204 1
		sub_ap.a_purpose = "internal reflection";
d302 1
a302 1
		sub_ap.a_purpose = "escaping refracted ray";
d343 1
a343 1
		sub_ap.a_purpose = "reflected ray";
d557 3
d562 3
@


10.3
log
@Changed to a_uptr, for Irix 6
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 10.2 94/08/11 00:37:56 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 10.1 1991/10/12 06:41:52 mike Rel4_0 gdurf $ (BRL)";
d155 2
a156 1
		sub_ap.a_user = (int)(pp->pt_regionp);
d457 1
a457 1
		if( pp->pt_regionp == (struct region *)(ap->a_user) )  break;
d462 1
a462 1
				((struct region *)(ap->a_user))->reg_name,
@


10.1
log
@Release_4.0
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 9.4 91/09/27 17:25:23 mike Exp $ (BRL)";
d19 2
@


9.4
log
@Added extinction
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 9.3 90/10/04 22:55:13 mike Exp Locker: mike $ (BRL)";
@


9.3
log
@Added green surface normal plotting to reflection points,
when RAYPLOT debugging is on.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: /m/cad/rt/RCS/refract.c,v 9.2 89/12/31 07:45:02 mike Exp $ (BRL)";
d275 3
d279 2
a280 2
		 *  This is totally arbitrary, for now.
		 *  Assume 20% attenuation per meter of glass, 2e-4/mm
d282 6
a287 6
		attenuation = 1;
#ifdef later
		attenuation = (1.0 - 2e-4 * sub_ap.a_cumlen);
		if( attenuation < 0 )  attenuation = 0;
/*rt_log("len=%g, atten=%g lvl%d\n", sub_ap.a_cumlen, attenuation, sub_ap.a_level);*/
#endif
@


9.2
log
@Changed to use the new meaning of a_onehit.
Can now get 3 hit points, rather than having to compute out to +infinity
when passing through glass objects.  Should be a big performance "win".
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 9.1 89/05/19 05:59:09 mike Locked $ (BRL)";
d338 11
@


9.1
log
@Release_3.5
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 8.4 89/04/30 20:37:46 mike Exp $ (BRL)";
d189 8
d202 1
a202 1
		sub_ap.a_onehit = 0;	/* need 1st EXIT, not just 1st HIT */
d393 3
a395 6
 * XXX If this hit resulted from a shot done with the "one hit" flag set,
 * there are no assurances about the accuracy of things behind
 * the ENTRY point.  We need the EXIT point to be accurate.
 * Perhaps this might be good motivation for adding support for
 * a setting of the "one hit" flag that is accurate through the
 * EXIT point, rather than the entry point.
@


8.4
log
@Does not require mathtab.h any longr
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 8.3 89/04/14 13:16:18 mike Locked $ (BRL)";
@


8.3
log
@Removed unnecessary extra parameter to rr_render,
added some RT_AP_CHECK()s, moved some struct declarations,
added a bzero( &shadework );
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 8.2 88/10/06 03:01:21 mike Locked $ (BRL)";
a27 1
#include "./mathtab.h"
@


8.2
log
@oops, Really Rel 3.0
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 8.1 88/10/05 00:33:03 mike Locked $ (BRL)";
d48 2
a49 2
HIDDEN int
rr_render( ap, pp, swp, dp )
d51 1
a51 1
struct partition *pp;
a52 1
char		*dp;
d65 1
d67 2
a317 1
		LOCAL vect_t		to_eye;
d376 1
d410 2
d413 2
d522 3
a524 5
			struct shadework	sw;
			struct application	appl;

			/* Make private copy of application struct,
			 * because viewshade() may change various fields. ???
d528 1
@


8.1
log
@Release_3.0
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.15 88/08/20 07:06:00 mike Exp $ (BRL)";
d460 1
a460 1
		rt_log("rr_hit: %d,%d %s inhit %g > 0.0!\n",
d463 1
a463 1
			hitp->hit_dist);
@


7.15
log
@Improved debugging messages some more.
In the case where a transmitted ray is reflected (mirror reflection)
previously two rays would have been fired (once in the reflection code,
again in the transmission code).  In this case, the effect is
collected together and sent to the reflection code.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.14 88/08/20 01:01:57 mike Locked $ (BRL)";
@


7.14
log
@Individual color components separated out,
additional debugging added.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.13 88/05/20 04:01:51 mike Locked $ (BRL)";
d31 1
a31 1
int	max_bounces = 3;	/* Maximum recursion level */
d72 1
a72 1
	if( ap->a_level >= max_bounces )  {
d80 1
a80 1
			rt_log("rr_render: %d,%d Max bounces=%d: %s\n",
d128 1
a128 1
		rt_log("rr_render: lvl=%d shader=%g, reflect=%g, transmit=%g %s\n",
d135 10
a144 24
	if( reflect > 0 )  {
		LOCAL vect_t		to_eye;
		register fastf_t	f;

		/* Mirror reflection */
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_level = ap->a_level+1;
		sub_ap.a_onehit = 1;
		VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
		VREVERSE( to_eye, ap->a_ray.r_dir );
		f = 2 * VDOT( to_eye, swp->sw_hit.hit_normal );
		VSCALE( work, swp->sw_hit.hit_normal, f );
		/* I have been told this has unit length */
		VSUB2( sub_ap.a_ray.r_dir, work, to_eye );
		sub_ap.a_purpose = "reflected ray";
		(void)rt_shootray( &sub_ap );

		/* a_user has hit/miss flag! */
		if( sub_ap.a_user == 0 )  {
			/* MISS */
			VMOVE( reflect_color, background );
		} else {
			ap->a_cumlen += sub_ap.a_cumlen;
			VMOVE( reflect_color, sub_ap.a_color );
a145 4
	} else {
		VSETALL( reflect_color, 0 );
	}
	if( transmit > 0 )  {
d167 14
a180 3
			/* Reflected back outside solid */
			VSETALL( filter_color, 1 );
			goto do_exit;
d301 5
d309 38
d351 1
a351 1
		rt_log("rr_render: lvl=%d shader=%g reflect=%g, transmit=%g, (final)\n",
d353 2
a354 1
			shader_fract, reflect, transmit );
d483 2
a484 1
		rt_log("rr_hit: %d,%d fusing small crack in glass %s\n",
d596 2
d609 2
d613 1
a613 1
		VADD2( v_2, w, u );
@


7.13
log
@fixed bad call to viewshade() which Phil found
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.12 88/05/20 03:37:59 mike Locked $ (BRL)";
a55 1
	fastf_t	f;
d59 6
a65 2
	fastf_t	transmit;
	fastf_t	reflect;
d70 1
a70 1
		goto finish;
d76 1
a76 1
		if( (rdebug&RDEBUG_SHOWERR) && (
d95 1
a95 1
		goto finish;
d121 13
a133 4
	f = 1 - (reflect + transmit);
	if( f < 0 )  f = 0;
	else if( f > 1 )  f = 1;
	VSCALE( swp->sw_color, swp->sw_color, f );
d136 2
a137 1
		LOCAL vect_t	to_eye;
d155 1
a155 1
			VMOVE( sub_ap.a_color, background );
d158 1
d160 2
a161 2
		VJOIN1(swp->sw_color, swp->sw_color,
			reflect, sub_ap.a_color);
d180 3
a182 3
			swp->sw_hit.hit_normal,
			sub_ap.a_refrac_index,
			swp->sw_refrac_index,
d211 2
a212 2
			VSET( swp->sw_color, 0, 99, 0 );	/* very green */
			goto finish;			/* abandon hope */
d258 1
a258 1
			if( (rdebug&RDEBUG_SHOWERR) && (
d301 1
a301 1
			VMOVE( sub_ap.a_color, background );
d303 2
d306 4
a309 4
		f = transmit * attenuation;
		VELMUL( work, filter_color, sub_ap.a_color );
		VJOIN1( swp->sw_color, swp->sw_color,
			f, work );
d311 15
a325 1
finish:
d375 1
a375 1
		if(rdebug&RDEBUG_SHOWERR)  {
d395 1
a395 1
		if(rdebug&RDEBUG_SHOWERR)  {
@


7.12
log
@changed for new wraypts() calling sequence
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.11 88/02/25 00:50:35 mike Locked $ (BRL)";
d449 1
a449 1
			struct application	ap2;
d451 5
a455 1
			ap2 = *ap;			/* struct copy -- avoids accidents */
d463 1
a463 1
			(void)viewshade( ap2, pp->pt_forw, &sw );
@


7.11
log
@Modified for new 3-D floating point UNIX-plot
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.10 88/01/26 05:57:34 mike Locked $ (BRL)";
d206 4
a209 2
			wraypts( sub_ap.a_ray.r_pt, sub_ap.a_uvec,
				ap, stdout );
@


7.10
log
@When ray is quenched, still tally up length.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.9 88/01/26 01:49:52 mike Locked $ (BRL)";
d211 1
a211 1
			rt_drawvec( stdout, ap->a_rt_i,
@


7.9
log
@Working version that incorporates code to "look ahead" and
correctly compute exit RI refractions to the next medium,
as well as RI tracking along the entire ray.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.7 88/01/23 04:13:05 mike Locked $ (BRL)";
d91 1
@


7.8
log
@Still an intermediate version, this one addresses the problem
of avoiding the reflected ray when entering a 2nd piece of glass,
but still botches the departing refraction from the 1st piece.
@
text
@d31 1
a31 1
int	max_bounces = 6;	/* Maximum recursion level */
a110 1
/*rt_log("no reflect, ri=%g, lvl=%d\n", ap->a_refrac_index, ap->a_level);*/
a161 1
/*else rt_log("%d,%d no air gap, ri=%g,%g\n", sub_ap.a_x, sub_ap.a_y, sub_ap.a_refrac_index, swp->sw_refrac_index);*/
d188 1
a188 1
			/* All is well */
d201 2
a202 1
		 *  and returns EXIT Normal in sub_ap.a_vvec.
d219 1
a219 3
		 *  XXX We really should "look ahead" to "sense" the
		 *  RI of the next material.  Just using RI_AIR is
		 *  excessively simplistic.
d223 2
a224 2
			swp->sw_refrac_index,
			RI_AIR,
d325 3
a327 2
 *		a_uvec	exit Point
 *		a_vvec	exit Normal (inward pointing)
d409 1
a409 1
		if( !NEAR_ZERO( d, 1.0e-3 ) )	/* XXX absolute tolerance */
d433 26
@


7.7
log
@Both known difficulties are now resolved:
-- hollow glass
-- hitting right on the edge.
Error handling has been significantly cleaned up, and the reasoning
behind the tests explained.
rr_hit now returns one of three outcomes, good, bad, or push on.
Lowered bounce and i_reflect limits to conserve CPU time;  images
seem just as nice with 3&5, rather than the previous 4&9.
Only remaining known problem is lack of Refractive Index tracking
from region to region -- this causes bogus inclusion of reflection
rays at the interface.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.4 88/01/20 02:44:34 mike Locked $ (BRL)";
d30 2
a31 2
#define MAX_IREFLECT	5	/* Maximum internal reflection level */
#define MAX_BOUNCE	3	/* Maximum recursion level */
d36 1
a36 1
#define RI_AIR		1.0    /* Refractive index of air.		*/
d38 2
d53 1
a53 1
char	*dp;
d55 8
a62 5
	auto struct application sub_ap;
	auto fastf_t	f;
	auto vect_t	work;
	auto vect_t	incident_dir;
	auto vect_t	filter_color;
d64 3
a66 1
	if( swp->sw_reflect <= 0 && swp->sw_transmit <= 0 )
d69 1
a69 1
	if( ap->a_level >= MAX_BOUNCE )  {
d98 15
d118 1
a118 1
	f = 1 - (swp->sw_reflect + swp->sw_transmit);
d123 1
a123 1
	if( swp->sw_reflect > 0 )  {
d141 1
d143 2
d147 1
a147 1
			swp->sw_reflect, sub_ap.a_color);
d149 1
a149 1
	if( swp->sw_transmit > 0 )  {
a151 4
		 *  XXX A fairly serious bug with this code is that it doees
		 *  not handle the case of two adjacent pieces of glass,
		 *  ie, the RI of the last/current medium
		 *  does not propagate along the ray.
d155 1
d159 8
a166 1
		if( !rr_refract(incident_dir, /* Incident ray (IN) */
d168 3
a170 2
			RI_AIR, swp->sw_refrac_index,
			sub_ap.a_ray.r_dir	/* Refracted ray (OUT) */
d216 1
d218 6
a223 2
		/* Calculate refraction at exit. */
		VMOVE( incident_dir, sub_ap.a_ray.r_dir );
d226 2
a227 1
			swp->sw_refrac_index, RI_AIR,
d233 1
a233 1
			if( (++sub_ap.a_level) <= MAX_IREFLECT )
d259 12
d281 2
d288 1
d290 1
d293 1
a293 1
			swp->sw_transmit, work );
a436 2
	VMOVE( ap->a_uvec, hitp->hit_point );

d439 2
@


7.6
log
@Another intermediate version.
Two serious bugs addressed:
-- bad "inhit near zero" check in rr_hit changed to "inhit > 0".
-- To counter uncertainty about EXIT point when onehit flag is set,
   clear onehit flag for internal reflection code.
@
text
@d30 2
a31 2
#define MAX_IREFLECT	9	/* Maximum internal reflection level */
#define MAX_BOUNCE	4	/* Maximum recursion level */
a61 3
	if( (swp->sw_inputs & (MFI_HIT|MFI_NORMAL)) != (MFI_HIT|MFI_NORMAL) )
		shade_inputs( ap, pp, swp, MFI_HIT|MFI_NORMAL );

d66 4
a69 1
		if( count++ < MSG_PROLOGUE || (count%MSG_INTERVAL) == 3 )  {
d75 9
a83 12
		if(rdebug&RDEBUG_SHOWERR)  {
			VSET( swp->sw_color, 99, 99, 0 );	/* Yellow */
		} else {
			/* Return basic color of object, ignoring the
			 * the fact that it is supposed to be
			 * filtering or reflecting light here.
			 * This is better than returning just black,
			 * but something better might be done
			 * (eg, hand off to phong shader too).
			 */
			VMOVE( swp->sw_color, swp->sw_basecolor );
		}
d88 4
d158 13
a170 3
		if( rt_shootray( &sub_ap ) == 0 )  {
			vect_t	voffset;
			register fastf_t	f;
a171 37
			/*
			 *  Internal reflection missed, or hit the wrong
			 *  thing, or encountered other adversity.
			 *  [Move the ray start point 1% or 1mm
			 *  (whichever is smaller) towards the solids'
			 *  center point, and try again. XXX This is wrong
			 *  if the entry point was due to a subtracted solid].
			 */
/**			if(rdebug&RDEBUG_HITS)**/
				rt_log("rr_render: Refracted ray missed '%s' -- RETRYING, lvl=%d xy=%d,%d\n",
				pp->pt_regionp->reg_name,
				sub_ap.a_level,
				ap->a_x, ap->a_y );
#ifdef later
			VSUB2( voffset, sub_ap.a_ray.r_pt,
				pp->pt_inseg->seg_stp->st_center );
			f = MAGNITUDE(voffset);
			if( f > 1.0 )
				f = 1.0/f;		/* use 1mm */
			else
				f = 0.01/f;		/* use 1% */
			VJOIN1( sub_ap.a_ray.r_pt, sub_ap.a_ray.r_pt,
				f, voffset );
#else
			VJOIN1( sub_ap.a_ray.r_pt, sub_ap.a_ray.r_pt,
				-10, incident_dir );
#endif
			sub_ap.a_purpose = "backed off, internal reflection";
			if( rt_shootray( &sub_ap ) == 0 )  {
				rt_log("rr_render: Refracted ray missed 2x '%s', lvl=%d, xy=%d,%d\n",
					pp->pt_regionp->reg_name,
					sub_ap.a_level,
					ap->a_x, ap->a_y );
				VSET( swp->sw_color, 0, 99, 0 );	/* green */
				goto finish;		/* abandon hope */
			}
		}
a199 15
			/* All chattering should probably be supressed, except
			 * in the SHOWERR case, as this will be the "normal"
			 * behavior now.
			 */
			if( count++ < MSG_PROLOGUE || (count%MSG_INTERVAL) == 3 )  {
				rt_log("rr_render: %d,%d Int.reflect=%d: %s lvl=%d\n",
					sub_ap.a_x, sub_ap.a_y,
					sub_ap.a_level,
					pp->pt_regionp->reg_name,
					ap->a_level );
			}
			if(rdebug&RDEBUG_SHOWERR) {
				VSET( swp->sw_color, 0, 9, 0 );	/* green */
				goto finish;
			}
d208 10
d222 6
a227 1
		/* This is the only place we might recurse dangerously */
d230 1
d256 1
a256 1
	return(0);
d262 16
a277 3
 *  Implicit Returns -
 *	a_uvec	exit Point
 *	a_vvec	exit Normal
d284 1
d286 2
a287 2
	register struct soltab *stp;
	register struct partition *pp;
d292 6
a297 3
/**		if(rdebug&RDEBUG_SHOWERR) **/
			rt_log("rr_hit:  no hit out front?\n");
		goto bad;
d299 16
a314 3
	if( pp->pt_regionp != (struct region *)(ap->a_user) )  {
/**		if(rdebug&RDEBUG_HITS) **/
			rt_log("rr_hit:  Ray reflected within %s now in %s!\n",
d316 4
a319 3
				pp->pt_regionp->reg_name );
		rt_pr_partitions(ap->a_rt_i, PartHeadp, "RR: Whole Partition" );
		goto bad;
d324 1
a324 1
	 *  being NEAR zero.  This was a mistake, because we may have
d328 1
a328 1
	 *  prevents us from "seeing" that solid on the next ray,
d330 7
a336 3
	 *  point.  There is a real problem if the entry point
	 *  is somehow further ahead than the firing point, ie, >0.
	 *  If we have a good exit point, just march on.
d339 6
a344 12
/**		if(rdebug&RDEBUG_HITS) **/
		{
			stp = pp->pt_inseg->seg_stp;
			RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
			if( pp->pt_inflip )  {
				VREVERSE( hitp->hit_normal, hitp->hit_normal );
			}
			rt_log("rr_hit:  '%s' inhit %g > 0.0!\n",
				stp->st_name, hitp->hit_dist);
			rt_pr_hit("inhit", hitp);
		}
		goto bad;
a354 7
	 *
	 * If this shot was done with the "one hit" flag set,
	 * there are no assurances about the accuracy of things behind
	 * the ENTRY point.  We need the EXIT point to be accurate.
	 * Perhaps this might be good motivation for adding support for
	 * a setting of the "one hit" flag that is accurate through the
	 * EXIT point, rather than the entry point.
d363 3
a365 1
		rt_log("rr_hit:  fusing small crack in glass\n");
d372 5
a376 4
/**		if(rdebug&RDEBUG_SHOWERR) **/
			rt_log("rr_hit:  (%g,%g) bad!\n",
				pp->pt_inhit->hit_dist, hitp->hit_dist);
		goto bad;
d384 1
a384 1
rt_pr_hit("uvec", hitp);
a386 9
	/* Safety check */
	if( (rdebug&RDEBUG_SHOWERR) && (
	    !NEAR_ZERO(hitp->hit_normal[X], 1.001) ||
	    !NEAR_ZERO(hitp->hit_normal[Y], 1.001) ||
	    !NEAR_ZERO(hitp->hit_normal[Z], 1.001) ) )  {
	    	rt_log("rr_hit: defective normal hitting %s\n", stp->st_name);
	    	VPRINT("hit_normal", hitp->hit_normal);
	    	goto bad;
	}
d389 1
a389 6
	return(1);

	/* Give serious information when problems are encountered */
bad:
	if(rdebug&RDEBUG_HITS) rt_pr_partitions( ap->a_rt_i, PartHeadp, "rr_hit" );
	return(0);
@


7.5
log
@INTERIM VERSION -- I need sleep.
Has improved error logging.
But, some conditional error logging is off.
Like, commented out.
@
text
@d156 1
a156 1
		sub_ap.a_onehit = 1;
a188 1
			sub_ap.a_onehit = 0;
d316 13
a328 2
	hitp = pp->pt_inhit;
	if( !NEAR_ZERO(hitp->hit_dist, 10) )  {
d336 1
a336 1
			rt_log("rr_hit:  '%s' inhit %g not near zero!\n",
d343 2
a344 1
	/* If there is a very small crack in the glass, perhaps formed
d351 2
a352 1
	 * Since this shot was done with the "one hit" flag set,
d354 1
a354 1
	 * this hit point.  I don't know if this is significant here.
d384 1
@


7.4
log
@Added logging and (bounces omitted) code to max bounces exceeded
case.  Improved code which handles max internal reflections
to just continue on in the same direction.
Both fixes cause quenched rays to assume the color of SOME part of
the sceen, rather than just picking a color for them.
Also added code to look for small cracks in glass, and fuse them.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.3 88/01/11 18:25:26 mike Locked $ (BRL)";
d33 3
d62 3
d69 5
a73 3
		if( ++count > 100 )  {
			if( (count%100) != 3 )  goto show_quench;
			rt_log("(bounces omitted)\n");
a74 5
		rt_log("rr_render: Maximum bounces=%d, stopping with %s at %d,%d\n",
			ap->a_level,
			pp->pt_inseg->seg_stp->st_name,
			ap->a_x, ap->a_y );
show_quench:	;
d124 7
a130 2

		/* Calculate refraction at entrance. */
a132 1
		sub_ap.a_onehit = 1;
d156 1
d158 24
a181 5
			if(rdebug&RDEBUG_HITS)rt_log("rr_render: Refracted ray missed '%s' -- RETRYING, lvl=%d\n",
				pp->pt_inseg->seg_stp->st_name,
				sub_ap.a_level );
			/* Back off just a little bit, and try again */
			/* Useful when striking exactly in corners */
d183 5
a187 1
				-0.5, incident_dir );
d189 1
d191 4
a194 5
				rt_log("rr_render: Refracted ray missed 2x '%s', lvl=%d\n",
					pp->pt_inseg->seg_stp->st_name,
					sub_ap.a_level );
				VPRINT("pt", sub_ap.a_ray.r_pt );
				VPRINT("dir", sub_ap.a_ray.r_dir );
d227 1
a227 1
			/* A chattering should probably be supressed, except
d231 6
a236 3
			if( ++count > 100 )  {
				if( (count%100) != 3 )  goto show_rstop;
				rt_log("(internal reflections omitted)\n");
a237 5
			rt_log("rr_render: %s Internal reflection stopped after %d bounces, (x%d, y%d, lvl=%d)\n",
				pp->pt_inseg->seg_stp->st_name,
				sub_ap.a_level,
				sub_ap.a_x, sub_ap.a_y, ap->a_level );
show_rstop:		;
d304 1
a304 1
		if(rdebug&RDEBUG_SHOWERR)
d309 1
a309 1
		if(rdebug&RDEBUG_HITS)
d313 1
d361 1
a361 1
		if(rdebug&RDEBUG_SHOWERR)
@


7.3
log
@A very minor improvement to the internal reflection
problem.  Something better is needed.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.2 87/12/11 23:17:06 mike Locked $ (BRL)";
d58 1
d61 7
a67 2
#ifdef debug
		rt_log("rr_render: lvl=%d, stopping at %s\n",
d69 15
a83 5
			pp->pt_inseg->seg_stp->st_name);
		VSET( swp->sw_color, 99, 99, 0 );
#else
		VSETALL( swp->sw_color, 0 );
#endif
d190 1
a190 1
			static long count = 0;
d196 4
d201 2
a202 2
				if( (count%100) != 3 )  goto show_err;
				rt_log("(reflections omitted)\n");
d208 1
a208 1
show_err:		;
d211 1
a211 4
			} else {
				/* 18% grey, filtered */
				VSETALL( work, .18*swp->sw_transmit );
				VELMUL( swp->sw_color, filter_color, work );
d213 10
a222 1
			goto finish;
d301 25
@


7.2
log
@Eliminated printing outhit, when it hadn't been properly filled in.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 7.1 87/11/02 23:56:03 mike Locked $ (BRL)";
d192 3
a194 1
				VSETALL( swp->sw_color, .18 ); /* 18% grey */
@


7.1
log
@Release 2.3
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 6.3 87/10/16 00:49:16 mike Exp $ (BRL)";
a270 1
			rt_pr_hit("outhit", pp->pt_outhit);
@


6.3
log
@Fixed dangerous recursion bug.
Escaping refracted ray's "level" is one more than that of the incident
ray before internal reflection.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 6.2 87/10/15 02:33:04 mike Locked $ (BRL)";
@


6.2
log
@Added code to limit number of "internal reflection" complaints.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 6.1 87/07/11 07:58:57 mike Locked $ (BRL)";
d200 1
a200 1
		sub_ap.a_level++;
@


6.1
log
@Release 2.0
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 1.8 87/07/11 03:00:06 mike Exp $ (BRL)";
d174 2
d180 4
d188 1
@


1.8
log
@Added sw_basecolor for dealing with glass filters.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 1.7 87/07/06 15:20:24 mike Locked $ (BRL)";
@


1.7
log
@Added a_purpose strings.
Setting of filter_color variable still isn't quite right.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 1.6 87/07/02 06:19:19 mike Locked $ (BRL)";
d70 1
a70 1
	VMOVE( filter_color, swp->sw_color );
@


1.6
log
@Some cleanup in refraction code, including fix to horrid bug
(forgetting to honor outflip flag).
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 1.5 87/07/02 01:27:39 mike Locked $ (BRL)";
d60 1
d65 3
d70 1
d94 1
a121 1
		VMOVE( filter_color, pp->pt_regionp->reg_mater.ma_transmit );
d132 1
d141 1
d194 1
@


1.5
log
@Refracted light is colored by the color of the glass.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 1.4 87/06/27 06:46:14 mike Locked $ (BRL)";
d58 1
a58 1
	if( ap->a_level > MAX_BOUNCE )  {
d60 4
a63 1
		rt_log("rr_render: lvl=%d, stopping\n", ap->a_level);
d102 1
a102 1
		sub_ap.a_level = (ap->a_level+1) * 100;	/* flag */
d118 6
a123 1
		/* Find new exit point from the inside. */
d168 11
a178 10
			if( (++sub_ap.a_level)%100 > MAX_IREFLECT )  {
				rt_log("rr_render: %s Excessive internal reflection (x%d, y%d, lvl=%d)\n",
					pp->pt_inseg->seg_stp->st_name,
					sub_ap.a_x, sub_ap.a_y, sub_ap.a_level );
				if(rdebug&RDEBUG_SHOWERR) {
					VSET( swp->sw_color, 0, 9, 0 );	/* green */
				} else {
					VSETALL( swp->sw_color, .18 ); /* 18% grey */
				}
				goto finish;
d180 1
a180 1
			goto do_inside;
d183 1
d250 3
a262 1
	RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
d269 7
a276 1
	VMOVE( ap->a_uvec, hitp->hit_point );
@


1.4
log
@rendering parameter changes
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 1.3 87/06/27 03:51:14 phil Locked $ (BRL)";
d36 1
d53 2
d56 3
a58 2
	if( (swp->sw_reflect <= 0 && swp->sw_transmit <= 0) ||
	    ap->a_level > MAX_BOUNCE )  {
d60 1
a95 1
		LOCAL vect_t incident_dir;
d104 1
a104 1
		if( !phg_refract(incident_dir, /* Incident ray (IN) */
d110 1
d113 2
d120 1
a120 1
			if(rdebug&RDEBUG_HITS)rt_log("phong: Refracted ray missed '%s' -- RETRYING, lvl=%d\n",
d128 1
a128 1
				rt_log("phong: Refracted ray missed 2x '%s', lvl=%d\n",
d154 1
a154 1
		if( !phg_refract( incident_dir,		/* input direction */
d161 1
a161 1
				rt_log("phong: %s Excessive internal reflection (x%d, y%d, lvl=%d)\n",
d183 1
d185 1
a185 1
			swp->sw_transmit, sub_ap.a_color );
d301 1
a301 1
phg_refract( v_1, norml, ri_1, ri_2, v_2 )
d311 1
a311 1
		rt_log("phg_refract:ri1=%g, ri2=%g\n", ri_1, ri_2 );
d316 1
a316 1
			rt_log("phg_refract:  beta=%g\n", beta);
@


1.3
log
@Eliminated stray debugging.
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: refract.c,v 1.1 87/06/26 05:56:03 mike Locked $ (BRL)";
d43 1
a43 1
rr_render( ap, pp, swp )
d47 1
@


1.2
log
@Fixed horrid bug in surface color contributions on refract/reflective
surfaces.
Added background color for escaping (miss) rays.
@
text
@a140 4
			if( rdebug&RDEBUG_HITS )  {
				VPRINT("R", sub_ap.a_ray.r_pt);
				VPRINT("S", sub_ap.a_uvec);
			}
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char RCSrefract[] = "@@(#)$Header: plastic.c,v 5.1 87/06/24 22:14:50 mike Locked $ (BRL)";
d37 2
d63 4
a66 3
	if( f > 0 )  {
		VSCALE( swp->sw_color, swp->sw_color, f );
	}
d81 7
a87 1
		VJOIN1(swp->sw_color, swp->sw_color, swp->sw_reflect, sub_ap.a_color);
d141 4
d174 5
@
