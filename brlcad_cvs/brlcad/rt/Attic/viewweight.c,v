head	11.21;
access;
symbols
	ansi-20040405-merged:11.16.2.2
	postmerge-20040405-ansi:11.19
	premerge-20040404-ansi:11.18
	postmerge-autoconf:11.18
	autoconf-freeze:11.16.10.1
	premerge-autoconf:11.18
	postmerge-20040315-windows:11.18
	premerge-20040315-windows:11.18
	windows-20040315-freeze:11.16.4.1
	autoconf-20031203:11.16
	autoconf-20031202:11.16
	autoconf-branch:11.16.0.10
	phong-branch:11.16.0.8
	photonmap-branch:11.16.0.6
	rel-6-1-DP:11.16
	windows-branch:11.16.0.4
	rel-6-0-2:11.14
	ansi-branch:11.16.0.2
	rel-6-0-1-branch:11.14.0.2
	hartley-6-0-post:11.15
	hartley-6-0-pre:11.14
	rel-6-0-1:11.14
	rel-6-0:11.14
	rel-5-4:11.10.2.1
	offsite-5-3-pre:11.13
	rel-5-3:11.10
	rel-5-2:11.10
	rel-5-1-branch:11.10.0.2
	rel-5-1:11.10
	rel-5-0:11.8
	rel-5-0-beta:11.7
	rel-4-5:11.5
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.21
date	2004.05.21.17.31.10;	author morrison;	state dead;
branches;
next	11.20;

11.20
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.19;

11.19
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2004.02.03.17.15.41;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2002.08.20.17.08.40;	author jra;	state Exp;
branches
	11.16.2.1
	11.16.4.1
	11.16.10.1;
next	11.15;

11.15
date	2002.08.15.20.55.51;	author hartley;	state Exp;
branches;
next	11.14;

11.14
date	2001.04.11.01.31.45;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	2000.08.25.21.14.01;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.27.19.32.53;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.25.16.39.49;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	2000.01.07.04.32.45;	author mike;	state Exp;
branches
	11.10.2.1;
next	11.9;

11.9
date	99.12.23.05.59.01;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.07.02.22.19.47;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.05.28.01.19.31;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	98.09.22.00.19.50;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.12.16.00.20.11;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.02.14.06.09.55;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.12.06.17.57.53;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.32;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.02.47.50;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.25;	author mike;	state Rel4_0;
branches;
next	1.1;

1.1
date	91.07.02.01.38.34;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2001.04.11.00.58.24;	author jra;	state Exp;
branches;
next	;

11.16.2.1
date	2002.09.19.18.02.17;	author morrison;	state Exp;
branches;
next	11.16.2.2;

11.16.2.2
date	2004.03.17.21.23.01;	author morrison;	state Exp;
branches;
next	;

11.16.4.1
date	2004.03.11.23.48.08;	author morrison;	state Exp;
branches;
next	;

11.16.10.1
date	2004.02.12.19.37.14;	author erikg;	state Exp;
branches;
next	;


desc
@View module for sample weight program.
@


11.21
log
@moved to src/rt/
@
text
@/*
 *			V I E W W E I G H T
 *
 *  Ray Tracing program RTWEIGHT bottom half.
 *
 *  This module outputs the weights and moments of a target model
 *  using density values located in ".density" or "$HOME/.density"
 *  Output is given in metric and english units, although input is
 *  assumed in lbs/cu.in.
 *
 *  Author -
 *	Jim Hunt
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include <time.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"

#include "db.h"  /* Yes, I know I shouldn't be peeking, put I am only
			looking to see what units we prefer... */

extern struct resource resource[];

int	use_air = 0;		/* Handling of air in librt */
int	using_mlib = 0;		/* Material routines NOT used */

/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
	{"",	0, (char *)0,	0,	BU_STRUCTPARSE_FUNC_NULL}
};

char usage[] = "\
Usage:  rtweight [options] model.g objects...\n\
Options:\n\
 -s #		Grid size in pixels, default 512\n\
 -g #		Grid cell width [and height] in mm\n\
 -G #		Grid cell height [and width] in mm\n\
 -a Az		Azimuth in degrees\n\
 -e Elev	Elevation in degrees\n\
 -o file.out	Weights and Moments output file\n\
 -M		Read matrix, cmds on stdin\n\
 -r 		Report verbosely mass of each region\n\
 -x #		Set librt debug flags\n\
Files:\n\
 .density, OR\n\
 $HOME/.density\n\
";

int	hit(struct application *ap, struct partition *PartHeadp);
int	miss(register struct application *ap);
int	overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2);

int	noverlaps = 0;

FILE	*densityfp;
char	*densityfile;
#define	DENSITY_FILE	".density"
#define MAXMATLS	99
fastf_t	density[MAXMATLS];
char	*dens_name[MAXMATLS];

struct datapoint {
	struct datapoint *next;
	vect_t	centroid;
	fastf_t	weight;
	fastf_t	volume;
	};

extern int     	rpt_overlap;     	/* report region verbosely */
extern fastf_t  cell_width;      	/* model space grid cell width */
extern fastf_t  cell_height;     	/* model space grid cell height */
extern FILE     *outfp;          	/* optional output file */
extern char	*outputfile;     	/* name of base of output file */
extern int	output_is_binary;	/* !0 means output is binary */

/*
 *  			V I E W _ I N I T
 *
 *  Called at the start of a run.
 *  Returns 1 if framebuffer should be opened, else 0.
 */
int
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{
	register int i;
	char buf[BUFSIZ+1];
	static char null = (char) 0;

	if( !minus_o ) {
		outfp = stdout;
		output_is_binary = 0;
		}

	for( i=1; i<MAXMATLS; i++ ) {
		density[i] = -1;
		dens_name[i] = &null;
		}

	if( (densityfp=fopen( densityfile=DENSITY_FILE, "r" )) == (FILE *) 0 ) {
		char *homedir = getenv( "HOME" );
		densityfile = (char *)malloc( strlen(homedir) + strlen(DENSITY_FILE) + 1 );
		strcpy( densityfile, homedir );
		strcat( densityfile, "/" );
		strcat( densityfile, DENSITY_FILE );
		if( (densityfp=fopen( densityfile, "r" )) == (FILE *) 0 ) {
			perror( densityfile );
			exit( -1 );
			}
		}

	/* Read in density in terms of grams/cm^3 */
	while( feof( densityfp ) != EOF ) {
		int index;
		float dens;
		register char *ptr = buf;
		if( fscanf( densityfp, "%d %f", &index, &dens ) == EOF )
			break;
		(void)fgets( buf, BUFSIZ, densityfp );
		if( index > 0 && index < MAXMATLS ) {
			while( *ptr == ' ' || *ptr == (char) 9 )
				ptr++;
			density[ index ] = dens;
			dens_name[ index ] = malloc( strlen( ptr ) + 1 );
			strcpy( dens_name[index], ptr );
			for( ptr=dens_name[index]; *ptr; ptr++ )
				if( *ptr==(char)13 || *ptr==(char)10 ) {
					*ptr = (char) 0;
					break;
					}
			}
		else
			bu_log( "Material index %d in \"%s\" is out of range.\n", index, densityfile );
		}
	ap->a_hit = hit;
	ap->a_miss = miss;
	ap->a_overlap = overlap;
	ap->a_onehit = 0;

	return(0);		/* no framebuffer needed */
}

/* beginning of a frame */
void
view_2init(struct application *ap)
{
	register struct region *rp;
	register struct rt_i *rtip = ap->a_rt_i;
	
	for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
		rp->reg_udata = (genptr_t) NULL;
	}
}

/* end of each pixel */
void	view_pixel(struct application *ap)
{ }

/* end of each line */
void	view_eol(struct application *ap)
{ }

/* end of a frame */
void	view_end(struct application *ap)
{
	register struct datapoint *dp;
	register struct region *rp;
	register fastf_t total_weight = 0;
	fastf_t sum_x = 0, sum_y = 0, sum_z = 0;
	struct rt_i *rtip = ap->a_rt_i;
	struct db_i *dbp = ap->a_rt_i->rti_dbip;
	fastf_t conversion = 1.0;	/* Conversion factor for mass */
	fastf_t volume = 0;
	char units[128] = {0};
	char unit2[128] = {0};
	int MAX_ITEM = 0;
	time_t clock;
	struct tm *locltime;
	char *timeptr;

	/* default units */
	strcpy(units, "grams");
	strcpy(unit2, "in.");

	(void) time( &clock );
	locltime = localtime( &clock );
	timeptr = asctime( locltime );
	
	if( dbp->dbi_base2local == 304.8 )  {
		/* Feet */
		strcpy( units, "grams" );
		strcpy( unit2, "ft." );
	} else if( dbp->dbi_base2local == 25.4 )  {
		/* inches */
                conversion = 0.002204623;  /* lbs./gram */
		strcpy( units, "lbs." );
		strcpy( unit2, "in." );
	} else if( dbp->dbi_base2local == 1.0 )  {
		/* mm */
		conversion = 0.001;  /* kg/gram */
		strcpy( units, "kg" );
		strcpy( unit2, "mm" );
	} else if( dbp->dbi_base2local == 1000.0 )  {
		/* km */
		conversion = 0.001;  /* kg/gram */
		strcpy( units, "kg" );
		strcpy( unit2, "m" );
	} else if( dbp->dbi_base2local == 10.0 )  {
		/* cm */
		strcpy( units, "grams" );
		strcpy( unit2, "in." );
	} else {
		bu_log("Warning: base2mm=%g, using default of %s--%s\n",
		       dbp->dbi_base2local, units, unit2 );
	}
	
	if( noverlaps )
		bu_log( "%d overlap%c detected.\n\n", noverlaps,
			noverlaps==1 ? '\0' : 's' );

	fprintf( outfp, "RT Check Program Output:\n" );
	fprintf( outfp, "\nDatabase Title: \"%s\"\n", dbp->dbi_title );
	fprintf( outfp, "Time Stamp: %s\n\nDensity Table Used:\n\n", timeptr );
	fprintf( outfp, "Material  Density(g/cm^3)  Name\n" );
	{ register int i;
	for( i=1; i<MAXMATLS; i++ ) {
		if( density[i] >= 0 )
			fprintf( outfp, "%5d     %10.4f       %s\n",
				i, density[i], dens_name[i] );
		} }

	if( rpt_overlap ) {
		/* ^L is char code for FormFeed/NewPage */
		fprintf( outfp, "Weight by region (in %s, density given in g/cm^3):\n\n", units );
		fprintf( outfp, "  Weight Matl LOS  Material Name  Density Name\n" );
		fprintf( outfp, " ------- ---- --- --------------- ------- -------------\n" );
		}
	for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
		register fastf_t weight = 0;
		register int l = strlen(rp->reg_name);
		register fastf_t *ptr;

/* */
		if( MAX_ITEM < rp->reg_regionid )
			MAX_ITEM = rp->reg_regionid;
/* */
		for( dp = (struct datapoint *) rp->reg_udata;
			dp != (struct datapoint *) NULL; dp = dp->next ) {
			sum_x += dp->weight * dp->centroid[X];
			sum_y += dp->weight * dp->centroid[Y];
			sum_z += dp->weight * dp->centroid[Z];
			weight += dp->weight;
			volume += dp->volume;
			}

		weight *= conversion;
		total_weight += weight;

		ptr = (fastf_t *) malloc( sizeof(fastf_t) );
		*ptr = weight;
		rp->reg_udata = (genptr_t) ptr;

		l = l > 37 ? l-37 : 0;
		if( rpt_overlap )
			fprintf( outfp, "%8.3f %4d %3d %-15.15s %7.4f %-37.37s\n",
				weight, rp->reg_gmater, rp->reg_los,
				dens_name[rp->reg_gmater],
				density[rp->reg_gmater], &rp->reg_name[l] );
		}

	if( rpt_overlap ) {
		register int i;
/*
#define MAX_ITEM 10001
		fastf_t item_wt[MAX_ITEM];
*/
		fastf_t *item_wt;
		MAX_ITEM++;
		item_wt = (fastf_t *) malloc( sizeof(fastf_t) * (MAX_ITEM + 1) );
		for( i=1; i<=MAX_ITEM; i++ )
			item_wt[i] = -1.0;
		fprintf(outfp,"Weight by item number (in %s):\n\n",units);
		fprintf(outfp,"Item  Weight  Region Names\n" );
		fprintf(outfp,"---- -------- --------------------\n" );
		for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
			register int i = rp->reg_regionid;
	
			if( item_wt[i] < 0 )
				item_wt[i] = *(fastf_t *)rp->reg_udata;
			else
				item_wt[i] += *(fastf_t *)rp->reg_udata;
			}
		for( i=1; i<MAX_ITEM; i++ ) {
			int CR = 0;
			if( item_wt[i] < 0 )
				continue;
			fprintf(outfp,"%4d %8.3f ", i, item_wt[i] );
			for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
				if( rp->reg_regionid == i ) {
					register int l = strlen(rp->reg_name);
					l = l > 65 ? l-65 : 0;
					if( CR )
						fprintf(outfp,"              ");
					fprintf(outfp,"%-65.65s\n", &rp->reg_name[l] );
					CR = 1;
					}
				}
			}
		}

	volume *= (dbp->dbi_base2local*dbp->dbi_base2local*dbp->dbi_base2local);
	sum_x *= (conversion / total_weight) * dbp->dbi_base2local;
	sum_y *= (conversion / total_weight) * dbp->dbi_base2local;
	sum_z *= (conversion / total_weight) * dbp->dbi_base2local;
	
	fprintf( outfp, "RT Check Program Output:\n" );
	fprintf( outfp, "\nDatabase Title: \"%s\"\n", dbp->dbi_title );
	fprintf( outfp, "Time Stamp: %s\n\n", timeptr );
	fprintf( outfp, "Total volume = %g %s^3\n\n", volume, unit2 );
	fprintf( outfp, "Centroid: X = %g %s\n", sum_x, unit2 );
	fprintf( outfp, "          Y = %g %s\n", sum_y, unit2 );
	fprintf( outfp, "          Z = %g %s\n", sum_z, unit2 );
	fprintf( outfp, "\nTotal mass = %g %s\n\n", total_weight, units );
	}

void	view_setup(void) {}

/* Associated with "clean" command, before new tree is loaded  */
void	view_cleanup(void) {}

int
hit(struct application *ap, struct partition *PartHeadp)
{
	struct partition *pp;
	register struct xray *rp = &ap->a_ray;
	genptr_t addp;
	int part_count = 0;

	for( pp = PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw ) {
		register struct region	*reg = pp->pt_regionp;
		register struct hit	*ihitp = pp->pt_inhit;
		register struct hit	*ohitp = pp->pt_outhit;
		register fastf_t	depth;
		register struct datapoint *dp;

		if( reg->reg_aircode )
			continue;

		/* fill in hit points and hit distances */
		VJOIN1(ihitp->hit_point, rp->r_pt, ihitp->hit_dist, rp->r_dir );
		VJOIN1(ohitp->hit_point, rp->r_pt, ohitp->hit_dist, rp->r_dir );
		depth = ohitp->hit_dist - ihitp->hit_dist;

		part_count++;
		/* add the datapoint structure in and then calculate it
		   in parallel, the region structures are a shared resource */
		bu_semaphore_acquire( BU_SEM_SYSCALL );
#if 0
		bu_log( "\nhit: partition %d\n", part_count );
#endif
		dp = (struct datapoint *) malloc( sizeof(struct datapoint));
		addp = reg->reg_udata;
		reg->reg_udata = (genptr_t) dp;
		dp->next = (struct datapoint *) addp;
        	bu_semaphore_release( BU_SEM_SYSCALL );

		if( density[ reg->reg_gmater ] < 0 ) {
			bu_log( "Material type %d used, but has no density file entry.\n", reg->reg_gmater );
			bu_semaphore_acquire( BU_SEM_SYSCALL );
			reg->reg_gmater = 0;
        		bu_semaphore_release( BU_SEM_SYSCALL );
			}
		else if( density[ reg->reg_gmater ] > 0 ) {
			VBLEND2( dp->centroid, 0.5, ihitp->hit_point, 0.5, ohitp->hit_point );

			/* Compute mass in terms of grams */
			dp->weight = depth * density[reg->reg_gmater] *
				(fastf_t) reg->reg_los * 
				cell_height * cell_height * 0.00001;
			dp->volume = depth * cell_height * cell_width;
#if 0
			bu_semaphore_acquire( BU_SEM_SYSCALL );
			bu_log( "hit: reg_name=\"%s\"\n",reg->reg_name );
			bu_log( "hit: gmater=%d, los=%d, density=%gg/cc, depth=%gmm, wt=%gg\n",
			reg->reg_gmater, reg->reg_los, density[reg->reg_gmater],
			depth, dp->weight );
        		bu_semaphore_release( BU_SEM_SYSCALL );
#endif
			}
		}
	return(1);	/* report hit to main routine */
	}

int
miss(register struct application *ap)
{
	return(0);
	}

int
overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
{
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	noverlaps++;
        bu_semaphore_release( BU_SEM_SYSCALL );
	return(0);
	}

void application_init (void) {}
@


11.20
log
@change conf.h to a wrapped config.h
@
text
@@


11.19
log
@merge of ansi-6-0-branch into head
@
text
@d24 5
a28 1
#include "conf.h"
@


11.18
log
@initialize the character array to minimize a potential segfault in the future.  fixed a bug where bu_log was missing one of its parameters (understandably caused bus error).
@
text
@d65 3
a67 3
int	hit();
int	miss();
int	overlap();
d99 2
a100 4
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
	{
d160 1
a160 2
view_2init( ap )
struct application *ap;
d171 2
a172 2
void	view_pixel(ap)
struct application *ap; { }
d175 2
a176 2
void	view_eol(ap)
struct application *ap; { }
d179 2
a180 3
void	view_end( ap )
struct application *ap;
	{
d341 1
a341 1
void	view_setup() {}
d344 1
a344 1
void	view_cleanup() {}
d347 2
a348 4
hit( ap, PartHeadp )
struct application *ap;
struct partition *PartHeadp;
	{
d410 2
a411 3
miss( ap )
register struct application *ap;
	{
d416 2
a417 6
overlap( ap, pp, reg1, reg2 )
struct application      *ap;
struct partition        *pp;
struct region           *reg1;
struct region           *reg2;
	{
d424 1
a424 1
void application_init () {}
@


11.17
log
@update copyright to include span through 2003
@
text
@d193 2
a194 2
	static char units[] = { "grams" };
	static char unit2[] = { "in." };
d200 4
d233 1
a233 1
			units, unit2 );
d238 1
a238 1
			noverlaps==1 ? (char) 0 : 's' );
d252 1
@


11.16
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1988 by the United States Army.
@


11.16.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d193 2
a194 2
	char units[128] = {0};
	char unit2[128] = {0};
a199 4
	/* default units */
	strcpy(units, "grams");
	strcpy(unit2, "in.");

d229 1
a229 1
		       dbp->dbi_base2local, units, unit2 );
d234 1
a234 1
			noverlaps==1 ? '\0' : 's' );
a247 1
		/* ^L is char code for FormFeed/NewPage */
@


11.16.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d193 2
a194 2
	char units[128] = {0};
	char unit2[128] = {0};
a199 4
	/* default units */
	strcpy(units, "grams");
	strcpy(unit2, "in.");

d229 1
a229 1
		       dbp->dbi_base2local, units, unit2 );
d234 1
a234 1
			noverlaps==1 ? '\0' : 's' );
a247 1
		/* ^L is char code for FormFeed/NewPage */
@


11.16.2.1
log
@Initial ANSIfication
@
text
@d65 3
a67 3
int	hit(struct application *ap, struct partition *PartHeadp);
int	miss(register struct application *ap);
int	overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2);
d99 4
a102 2
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{
d162 2
a163 1
view_2init(struct application *ap)
d174 2
a175 2
void	view_pixel(struct application *ap)
{ }
d178 2
a179 2
void	view_eol(struct application *ap)
{ }
d182 3
a184 2
void	view_end(struct application *ap)
{
d340 1
a340 1
void	view_setup(void) {}
d343 1
a343 1
void	view_cleanup(void) {}
d346 4
a349 2
hit(struct application *ap, struct partition *PartHeadp)
{
d411 3
a413 2
miss(register struct application *ap)
{
d418 6
a423 2
overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
{
d430 1
a430 1
void application_init (void) {}
@


11.16.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d189 2
a190 2
	char units[128] = {0};
	char unit2[128] = {0};
a195 4
	/* default units */
	strcpy(units, "grams");
	strcpy(unit2, "in.");

d225 1
a225 1
		       dbp->dbi_base2local, units, unit2 );
d230 1
a230 1
			noverlaps==1 ? '\0' : 's' );
a243 1
		/* ^L is char code for FormFeed/NewPage */
@


11.15
log
@Converted from K&R to ANSI C - RFH
@
text
@d65 3
a67 3
int	hit(struct application *ap, struct partition *PartHeadp);
int	miss(register struct application *ap);
int	overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2);
d99 4
a102 2
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{
d162 2
a163 1
view_2init(struct application *ap)
d174 2
a175 2
void	view_pixel(struct application *ap)
{ }
d178 2
a179 2
void	view_eol(struct application *ap)
{ }
d182 3
a184 2
void	view_end(struct application *ap)
{
d340 1
a340 1
void	view_setup(void) {}
d343 1
a343 1
void	view_cleanup(void) {}
d346 4
a349 2
hit(struct application *ap, struct partition *PartHeadp)
{
d411 3
a413 2
miss(register struct application *ap)
{
d418 6
a423 2
overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
{
d430 1
a430 1
void application_init (void) {}
@


11.14
log
@view_end() was overrunning an array
@
text
@d65 3
a67 3
int	hit();
int	miss();
int	overlap();
d99 2
a100 4
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
	{
d160 1
a160 2
view_2init( ap )
struct application *ap;
d171 2
a172 2
void	view_pixel(ap)
struct application *ap; { }
d175 2
a176 2
void	view_eol(ap)
struct application *ap; { }
d179 2
a180 3
void	view_end( ap )
struct application *ap;
	{
d336 1
a336 1
void	view_setup() {}
d339 1
a339 1
void	view_cleanup() {}
d342 2
a343 4
hit( ap, PartHeadp )
struct application *ap;
struct partition *PartHeadp;
	{
d405 2
a406 3
miss( ap )
register struct application *ap;
	{
d411 2
a412 6
overlap( ap, pp, reg1, reg2 )
struct application      *ap;
struct partition        *pp;
struct region           *reg1;
struct region           *reg2;
	{
d419 1
a419 1
void application_init () {}
@


11.13
log
@
lint
@
text
@d293 1
a293 1
		item_wt = (fastf_t *) malloc( sizeof(fastf_t) * MAX_ITEM );
@


11.12
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d45 1
a45 1
	"",	0, (char *)0,	0,	BU_STRUCTPARSE_FUNC_NULL
a198 1
	char *unitstr;
@


11.11
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d27 1
d98 1
@


11.10
log
@
Eliminated dependence on dbi_localunit
@
text
@d32 1
a32 1
#include "./rdebug.h"
@


11.10.2.1
log
@view_end() was overrunning an array
@
text
@d292 1
a292 1
		item_wt = (fastf_t *) malloc( sizeof(fastf_t) * (MAX_ITEM + 1) );
@


11.9
log
@
struct region is now a bu_list
@
text
@d197 1
d203 27
a229 20
        switch( dbp->dbi_localunit ) {
                case ID_FT_UNIT:
			strcpy( unit2, "ft." );
                case ID_IN_UNIT:
                        conversion = 0.002204623;  /* lbs./gram */
			strcpy( units, "lbs." );
                case ID_NO_UNIT:
			break;
                case ID_MM_UNIT:
			conversion = 0.001;  /* kg/gram */
			strcpy( units, "kg" );
			strcpy( unit2, "mm" );
			break;
		case ID_M_UNIT:
			conversion = 0.001;  /* kg/gram */
			strcpy( units, "kg" );
			strcpy( unit2, "m" );
                case ID_CM_UNIT:
			break;
		}
@


11.8
log
@
Removed dependence on compat4.h
@
text
@d162 1
a162 1
	{
d166 1
a166 2
	for( rp = rtip->HeadRegion; rp != (struct region *) NULL;
			rp = rp->reg_forw ) {
a167 1
		}
d169 1
d243 1
a243 2
	for( rp = rtip->HeadRegion; rp != (struct region *) NULL;
			rp = rp->reg_forw ) {
d290 1
a290 2
		for( rp = rtip->HeadRegion; rp != (struct region *) NULL;
				rp = rp->reg_forw ) {
d303 1
a303 3
			for( rp = rtip->HeadRegion;
					rp != (struct region *) NULL;
					rp = rp->reg_forw ) {
@


11.7
log
@
sed4
@
text
@d44 1
a44 1
	"",	0, (char *)0,	0,	FUNC_NULL
@


11.6
log
@Variable type needs to be specified in ANSI C, Mr. Hunt. :-)
@
text
@d148 1
a148 1
			rt_log( "Material index %d in \"%s\" is out of range.\n", index, densityfile );
d225 1
a225 1
		rt_log( "%d overlap%c detected.\n\n", noverlaps,
d371 1
a371 1
		rt_log( "\nhit: partition %d\n", part_count );
d380 1
a380 1
			rt_log( "Material type %d used, but has no density file entry.\n", reg->reg_gmater );
d395 2
a396 2
			rt_log( "hit: reg_name=\"%s\"\n",reg->reg_name );
			rt_log( "hit: gmater=%d, los=%d, density=%gg/cc, depth=%gmm, wt=%gg\n",
@


11.5
log
@Converted to bu_semaphore_acquire()
@
text
@d247 1
a247 1
		register l = strlen(rp->reg_name);
@


11.4
log
@a_onehit should have been 0, not -1.
@
text
@d369 1
a369 1
		RES_ACQUIRE( &rt_g.res_syscall );
d377 1
a377 1
        	RES_RELEASE( &rt_g.res_syscall );
d381 1
a381 1
			RES_ACQUIRE( &rt_g.res_syscall );
d383 1
a383 1
        		RES_RELEASE( &rt_g.res_syscall );
d394 1
a394 1
			RES_ACQUIRE( &rt_g.res_syscall );
d399 1
a399 1
        		RES_RELEASE( &rt_g.res_syscall );
d420 1
a420 1
	RES_ACQUIRE( &rt_g.res_syscall );
d422 1
a422 1
        RES_RELEASE( &rt_g.res_syscall );
@


11.3
log
@structparse moved to libbu
@
text
@d153 1
a153 1
	ap->a_onehit = -1;
@


11.2
log
@Added a stub for application_init()
@
text
@d43 1
a43 1
struct structparse view_parse[] = {
@


11.1
log
@Release_4.4
@
text
@d425 2
@


10.2
log
@Added include of conf.h
@
text
@@


10.1
log
@Release_4.0
@
text
@d24 2
@


1.1
log
@Initial revision
@
text
@@
