head	11.54;
access;
symbols
	ansi-20040405-merged:11.43.2.2
	postmerge-20040405-ansi:11.52
	premerge-20040404-ansi:11.51
	postmerge-autoconf:11.51
	autoconf-freeze:11.50.2.2
	premerge-autoconf:11.51
	postmerge-20040315-windows:11.51
	premerge-20040315-windows:11.51
	windows-20040315-freeze:11.43.4.1
	autoconf-20031203:11.50
	autoconf-20031202:11.50
	autoconf-branch:11.50.0.2
	phong-branch:11.48.0.2
	photonmap-branch:11.44.0.2
	rel-6-1-DP:11.43
	windows-branch:11.43.0.4
	rel-6-0-2:11.41
	ansi-branch:11.43.0.2
	rel-6-0-1-branch:11.41.0.2
	hartley-6-0-post:11.42
	hartley-6-0-pre:11.41
	rel-6-0-1:11.41
	rel-6-0:11.41
	rel-5-4:11.27.2.4
	offsite-5-3-pre:11.35
	rel-5-3:11.27.2.4
	rel-5-2:11.27.2.1
	rel-5-1-branch:11.27.0.2
	rel-5-1:11.27
	rel-5-0:11.20
	rel-5-0-beta:11.19
	rel-4-5:11.16
	ctj-4-5-post:11.15
	ctj-4-5-pre:11.15
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.54
date	2004.05.21.17.31.03;	author morrison;	state dead;
branches;
next	11.53;

11.53
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.52;

11.52
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.51;

11.51
date	2004.02.02.17.39.38;	author morrison;	state Exp;
branches;
next	11.50;

11.50
date	2003.10.07.01.16.07;	author morrison;	state Exp;
branches
	11.50.2.1;
next	11.49;

11.49
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches;
next	11.48;

11.48
date	2003.09.10.12.33.45;	author jra;	state Exp;
branches;
next	11.47;

11.47
date	2003.09.09.15.15.05;	author justin;	state Exp;
branches;
next	11.46;

11.46
date	2003.09.05.16.05.51;	author justin;	state Exp;
branches;
next	11.45;

11.45
date	2003.09.05.16.05.13;	author justin;	state Exp;
branches;
next	11.44;

11.44
date	2003.04.11.19.38.37;	author jra;	state Exp;
branches;
next	11.43;

11.43
date	2002.08.20.17.08.37;	author jra;	state Exp;
branches
	11.43.2.1
	11.43.4.1;
next	11.42;

11.42
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.41;

11.41
date	2002.03.14.14.09.48;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	2001.11.29.18.05.35;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2001.05.17.20.06.07;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2001.04.05.19.36.03;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2001.03.31.01.57.31;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2001.03.19.22.20.14;	author butler;	state Exp;
branches;
next	11.35;

11.35
date	2000.12.05.15.49.12;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	2000.09.08.05.54.46;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.09.07.19.35.42;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.08.23.06.25.49;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.08.17.02.41.33;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.07.31.02.01.15;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	2000.07.27.19.32.52;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	2000.07.25.16.39.47;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	2000.05.18.21.10.09;	author jra;	state Exp;
branches
	11.27.2.1;
next	11.26;

11.26
date	2000.05.18.02.02.24;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.02.12.02.08.17;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.02.03.01.19.49;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.01.11.21.58.53;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.12.30.05.49.28;	author butler;	state Exp;
branches;
next	11.21;

11.21
date	99.12.23.05.59.00;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.07.02.22.19.45;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.05.28.01.11.01;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	98.09.23.19.38.57;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	98.09.22.00.23.40;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	97.12.31.09.23.14;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	97.07.07.13.12.07;	author gdurf;	state Exp;
branches;
next	11.14;

11.14
date	97.05.22.00.57.32;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.01.02.20.59.37;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	96.08.31.08.21.34;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	96.08.31.04.35.10;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.08.29.23.36.10;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.08.28.07.23.37;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.08.28.03.38.13;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.08.27.03.17.03;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.07.22.20.34.18;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.11.07.14.27.33;	author adam;	state Exp;
branches;
next	11.3;

11.3
date	95.10.30.23.52.01;	author adam;	state Exp;
branches;
next	11.2;

11.2
date	95.03.18.02.13.17;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.37;	author mike;	state Rel4_4;
branches;
next	10.17;

10.17
date	94.12.30.01.01.45;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.12.22.00.27.05;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.12.21.14.44.31;	author stay;	state Exp;
branches;
next	10.14;

10.14
date	94.12.01.20.45.53;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.11.24.02.56.07;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.11.19.01.28.51;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.11.09.15.13.53;	author jra;	state Exp;
branches;
next	10.10;

10.10
date	94.11.05.03.25.36;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.11.05.02.44.10;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.10.31.22.08.16;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.09.30.16.01.42;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.22.19.23.39;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.00.22.51;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.11.00.20.55;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	93.03.24.03.18.35;	author phil;	state Exp;
branches;
next	10.2;

10.2
date	92.08.25.23.05.17;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.42;	author mike;	state Rel4_0;
branches;
next	9.44;

9.44
date	91.10.01.02.47.34;	author butler;	state Exp;
branches;
next	9.43;

9.43
date	91.08.30.23.11.20;	author mike;	state Exp;
branches;
next	9.42;

9.42
date	91.08.30.02.47.46;	author mike;	state Exp;
branches;
next	9.41;

9.41
date	91.08.29.22.37.22;	author mike;	state Exp;
branches;
next	9.40;

9.40
date	91.07.10.02.17.29;	author mike;	state Exp;
branches;
next	9.39;

9.39
date	91.07.06.00.38.40;	author mike;	state Exp;
branches;
next	9.38;

9.38
date	91.07.06.00.35.07;	author mike;	state Exp;
branches;
next	9.37;

9.37
date	91.07.05.22.15.33;	author mike;	state Exp;
branches;
next	9.36;

9.36
date	91.07.01.03.38.44;	author mike;	state Exp;
branches;
next	9.35;

9.35
date	91.06.30.22.08.17;	author mike;	state Exp;
branches;
next	9.34;

9.34
date	91.06.30.18.31.52;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	91.06.13.07.48.43;	author mike;	state Exp;
branches;
next	9.32;

9.32
date	91.03.01.16.15.13;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	91.03.01.15.51.34;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.02.28.15.46.43;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.02.20.00.53.19;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.02.20.00.50.21;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.02.17.20.15.40;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.01.05.03.08.59;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	90.12.14.22.21.22;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	90.12.12.08.43.24;	author butler;	state Exp;
branches;
next	9.23;

9.23
date	90.12.10.10.48.41;	author butler;	state Exp;
branches;
next	9.22;

9.22
date	90.12.08.07.53.58;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	90.11.22.07.16.03;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	90.11.21.06.32.08;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	90.11.14.15.42.56;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	90.11.11.04.52.19;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.11.04.09.01.05;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.11.02.06.29.01;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.11.01.11.17.19;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.10.07.21.39.11;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.07.31.01.32.45;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.07.31.01.09.55;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.07.31.01.03.54;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.06.01.00.13.40;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.05.30.13.32.41;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.04.25.00.43.23;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.04.12.03.59.32;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.02.08.02.22.53;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.02.04.00.06.53;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.01.11.04.42.18;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.01.11.03.10.03;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.30.03.06.37;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.58.50;	author mike;	state Rel3_5;
branches;
next	8.21;

8.21
date	89.04.30.20.39.18;	author mike;	state Exp;
branches;
next	8.20;

8.20
date	89.04.14.06.02.17;	author mike;	state Exp;
branches;
next	8.19;

8.19
date	89.04.14.03.07.59;	author mike;	state Exp;
branches;
next	8.18;

8.18
date	89.04.05.02.14.52;	author mike;	state Exp;
branches;
next	8.17;

8.17
date	89.04.04.05.01.55;	author mike;	state Exp;
branches;
next	8.16;

8.16
date	89.04.03.20.50.24;	author mike;	state Exp;
branches;
next	8.15;

8.15
date	89.03.04.02.58.39;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.02.27.00.08.58;	author mike;	state Exp;
branches;
next	8.13;

8.13
date	89.02.10.22.53.28;	author mike;	state Exp;
branches;
next	8.12;

8.12
date	89.01.25.05.37.57;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.01.25.04.14.44;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.01.20.03.19.16;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.01.09.06.07.16;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.01.09.05.43.32;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.01.09.05.11.56;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.01.02.18.25.52;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	88.12.27.16.34.07;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	88.12.15.03.32.27;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	88.12.06.04.45.24;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.21.17.37.54;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.32.41;	author mike;	state Rel3_0;
branches;
next	7.15;

7.15
date	88.09.19.22.44.13;	author mike;	state Exp;
branches;
next	7.14;

7.14
date	88.08.23.02.31.53;	author mike;	state Exp;
branches;
next	7.13;

7.13
date	88.08.20.07.21.28;	author phil;	state Exp;
branches;
next	7.12;

7.12
date	88.08.14.21.04.27;	author mike;	state Exp;
branches;
next	7.11;

7.11
date	88.07.26.01.25.26;	author mike;	state Exp;
branches;
next	7.10;

7.10
date	88.06.17.02.50.27;	author mike;	state Exp;
branches;
next	7.9;

7.9
date	88.06.17.00.23.41;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.06.16.02.52.23;	author phil;	state Exp;
branches;
next	7.7;

7.7
date	88.05.14.02.28.08;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.01.27.07.01.02;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.01.27.04.36.02;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.01.26.05.57.09;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.01.22.20.58.02;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.00.35.46;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.36.00;	author mike;	state Rel;
branches;
next	6.6;

6.6
date	87.10.15.02.16.58;	author mike;	state Exp;
branches;
next	6.5;

6.5
date	87.10.14.23.30.48;	author mike;	state Exp;
branches;
next	6.4;

6.4
date	87.10.14.21.20.19;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.10.14.21.12.52;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.03.01.30.14;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.58.16;	author mike;	state Rel;
branches;
next	5.5;

5.5
date	87.07.10.02.56.53;	author mike;	state Exp;
branches;
next	5.4;

5.4
date	87.07.09.03.28.11;	author mike;	state Exp;
branches;
next	5.3;

5.3
date	87.07.03.05.46.13;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.56.57;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.14.15;	author mike;	state Rel;
branches;
next	1.7;

1.7
date	87.05.31.04.48.06;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	87.05.30.07.03.06;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	87.04.30.17.40.54;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	87.04.10.20.11.41;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.04.10.08.13.49;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.04.10.07.15.35;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.04.10.07.04.10;	author mike;	state Exp;
branches;
next	;

11.27.2.1
date	2000.08.24.13.34.38;	author jra;	state Exp;
branches;
next	11.27.2.2;

11.27.2.2
date	2000.10.25.19.03.11;	author jra;	state Exp;
branches;
next	11.27.2.3;

11.27.2.3
date	2000.10.26.12.48.52;	author jra;	state Exp;
branches;
next	11.27.2.4;

11.27.2.4
date	2000.11.22.13.37.09;	author jra;	state Exp;
branches;
next	;

11.43.2.1
date	2002.09.19.18.02.14;	author morrison;	state Exp;
branches;
next	11.43.2.2;

11.43.2.2
date	2004.03.17.21.22.56;	author morrison;	state Exp;
branches;
next	;

11.43.4.1
date	2004.03.11.23.48.05;	author morrison;	state Exp;
branches;
next	;

11.50.2.1
date	2004.02.12.19.37.12;	author erikg;	state Exp;
branches;
next	11.50.2.2;

11.50.2.2
date	2004.03.15.14.08.06;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to manage the setup and control of the raytracing process.
@


11.54
log
@moved to src/rt/
@
text
@/*
 *			D O . C 
 *
 *  Routines that process the various commands, and manage
 *  the overall process of running the raytracing process.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/do.c,v 11.53 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#ifdef HAVE_UNIX_IO
# include <sys/types.h>
# include <sys/stat.h>
# include <fcntl.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "externs.h"
#include "rtprivate.h"
#include "../librt/debug.h"

extern int	rdebug;			/* RT program debugging (not library) */

/***** Variables shared with viewing model *** */
extern FILE	*outfp;			/* optional pixel output file */
extern double	azimuth, elevation;
extern mat_t	view2model;
extern mat_t	model2view;
/***** end of sharing with viewing model *****/

extern void	grid_setup(void);
extern void	worker(int cpu, genptr_t arg);

/***** variables shared with worker() ******/
extern struct application ap;
extern int	hypersample;		/* number of extra rays to fire */
extern fastf_t	aspect;			/* view aspect ratio X/Y */
extern fastf_t	cell_width;		/* model space grid cell width */
extern fastf_t	cell_height;		/* model space grid cell height */
extern point_t	eye_model;		/* model-space location of eye */
extern fastf_t  eye_backoff;		/* dist of eye from center */
extern fastf_t	rt_perspective;		/* persp (degrees X) 0 => ortho */
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
extern mat_t	Viewrotscale;
extern fastf_t	viewsize;
extern int	incr_mode;		/* !0 for incremental resolution */
extern int	incr_level;		/* current incremental level */
extern int	incr_nlevel;		/* number of levels */
extern int	npsw;
extern struct resource resource[];
/***** end variables shared with worker() */

/***** variables shared with rt.c *****/
extern char	*string_pix_start;	/* string spec of starting pixel */
extern char	*string_pix_end;	/* string spec of ending pixel */
extern int	pix_start;		/* pixel to start at */
extern int	pix_end;		/* pixel to end at */
extern int	nobjs;			/* Number of cmd-line treetops */
extern char	**objtab;		/* array of treetop strings */
extern int	matflag;		/* read matrix from stdin */
extern int	desiredframe;		/* frame to start at */
extern int	finalframe;		/* frame to halt at */
extern int	curframe;		/* current frame number */
extern char	*outputfile;		/* name of base of output file */
extern int	interactive;		/* human is watching results */
extern int	save_overlaps;		/* flag for setting rti_save_overlaps */
/***** end variables shared with rt.c *****/

/***** variables shared with refract.c *****/
extern int	max_bounces;		/* max reflection/recursion level */
extern int	max_ireflect;		/* max internal reflection level */
/***** end variables shared with refract.c *****/


/***** variables shared with viewg3.c *****/
struct bu_vls   ray_data_file;  /* file name for ray data output */
/***** end variables shared with viewg3.c *****/

/***** variables shared with g_cline.c ******/
extern fastf_t rt_cline_radius;
/***** end variables shared with g_cline.c ******/

/***** variables for frame buffer black pixel rendering *****/
unsigned char *pixmap = NULL; /* Pixel Map for rerendering of black pixels */


void		def_tree(register struct rt_i *rtip);
void		do_ae(double azim, double elev);
void		res_pr(void);
void		memory_summary(void);

/*
 *			O L D _ F R A M E
 *
 *  Acquire particulars about a frame, in the old format.
 *  Returns -1 if unable to acquire info, 0 if successful.
 */
int
old_frame(FILE *fp)
{
	register int i;
	char number[128];

	/* Visible part is from -1 to +1 in view space */
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	viewsize = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[X] = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[Y] = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[Z] = atof(number);
	for( i=0; i < 16; i++ )  {
		if( fscanf( fp, "%s", number ) != 1 )
			return(-1);
		Viewrotscale[i] = atof(number);
	}
	return(0);		/* OK */
}


/*
 *			O L D _ W A Y
 * 
 *  Determine if input file is old or new format, and if
 *  old format, handle process *  Returns 0 if new way, 1 if old way (and all done).
 *  Note that the rewind() will fail on ttys, pipes, and sockets (sigh).
 */
int
old_way(FILE *fp)
{
	int	c;

	viewsize = -42.0;

	/* Sneek a peek at the first character, and then put it back */
	if( (c = fgetc( fp )) == EOF )  {
		/* Claim old way, all (ie, nothing) done */
		return(1);
	}
	if( ungetc( c, fp ) != c )
		rt_bomb("do.c:old_way() ungetc failure\n");

	/*
	 * Old format files start immediately with a %.9e format,
	 * so the very first character should be a digit or '-'.
	 */
	if( (c < '0' || c > '9') && c != '-' )  {
		return( 0 );		/* Not old way */
	}

	if( old_frame( fp ) < 0 || viewsize <= 0.0 )  {
		rewind( fp );
		return(0);		/* Not old way */
	}
	bu_log("Interpreting command stream in old format\n");

	def_tree( ap.a_rt_i );		/* Load the default trees */

	curframe = 0;
	do {
		if( finalframe >= 0 && curframe > finalframe )
			return(1);
		if( curframe >= desiredframe )
			do_frame( curframe );
		curframe++;
	}  while( old_frame( fp ) >= 0 && viewsize > 0.0 );
	return(1);			/* old way, all done */
}


/*
 *			C M _ S T A R T
 *
 *  Process "start" command in new format input stream
 */
int cm_start( int argc, char **argv)
{
	char	*buf;
	int	frame;

	frame = atoi(argv[1]);
	if( finalframe >= 0 && frame > finalframe )
		return(-1);	/* Indicate EOF -- user declared a halt */
	if( frame >= desiredframe )  {
		curframe = frame;
		return(0);
	}

	/* Skip over unwanted frames -- find next frame start */
	while( (buf = rt_read_cmd( stdin )) != (char *)0 )  {
		register char *cp;

		cp = buf;
		while( *cp && isspace(*cp) )  cp++;	/* skip spaces */
		if( strncmp( cp, "start", 5 ) != 0 )  continue;
		while( *cp && !isspace(*cp) )  cp++;	/* skip keyword */
		while( *cp && isspace(*cp) )  cp++;	/* skip spaces */
		frame = atoi(cp);
		bu_free( buf, "rt_read_cmd command buffer (skipping frames)" );
		if( finalframe >= 0 && frame > finalframe )
			return(-1);			/* "EOF" */
		if( frame >= desiredframe )  {
			curframe = frame;
			return(0);
		}
	}
	return(-1);		/* EOF */
}

int cm_vsize( int argc, char **argv)
{
	viewsize = atof( argv[1] );
	return(0);
}

int cm_eyept(int argc, char **argv)
{
	register int i;

	for( i=0; i<3; i++ )
		eye_model[i] = atof( argv[i+1] );
	return(0);
}

int cm_lookat_pt(int argc, char **argv)
{
	point_t	pt;
	vect_t	dir;
	int	yflip = 0;

	if( argc < 4 )
		return(-1);
	pt[X] = atof(argv[1]);
	pt[Y] = atof(argv[2]);
	pt[Z] = atof(argv[3]);
	if( argc > 4 )
		yflip = atoi(argv[4]);

	/*
	 *  eye_pt must have been specified before here (for now)
	 */
	VSUB2( dir, pt, eye_model );
	VUNITIZE( dir );
	bn_mat_lookat( Viewrotscale, dir, yflip );
	return(0);
}

int cm_vrot( int argc, char **argv)
{
	register int i;

	for( i=0; i<16; i++ )
		Viewrotscale[i] = atof( argv[i+1] );
	return(0);
}

int cm_orientation(int argc, char **argv)
{
	register int	i;
	quat_t		quat;

	for( i=0; i<4; i++ )
		quat[i] = atof( argv[i+1] );
	quat_quat2mat( Viewrotscale, quat );
	return(0);
}

int cm_end(int argc, char **argv)
{
	struct rt_i *rtip = ap.a_rt_i;

	if( BU_LIST_IS_EMPTY( &rtip->HeadRegion ) )  {
		def_tree( rtip );		/* Load the default trees */
	}

	/* If no matrix or az/el specified yet, use params from cmd line */
	if( Viewrotscale[15] <= 0.0 )
		do_ae( azimuth, elevation );

	if( do_frame( curframe ) < 0 )  return(-1);
	return(0);
}

int cm_tree( int argc, const char **argv)
{
	register struct rt_i *rtip = ap.a_rt_i;
	struct bu_vls	times;

	if( argc <= 1 )  {
		def_tree( rtip );		/* Load the default trees */
		return(0);
	}
	bu_vls_init( &times );

	rt_prep_timer();
	if( rt_gettrees(rtip, argc-1, &argv[1], npsw) < 0 )
		bu_log("rt_gettrees(%s) FAILED\n", argv[0]);
	(void)rt_get_timer( &times, NULL );

	if (rt_verbosity & VERBOSE_STATS)
		bu_log("GETTREE: %s\n", bu_vls_addr(&times) );
	bu_vls_free( &times );
	return(0);
}

int cm_multiview( int argc, char **argv)
{
	register struct rt_i *rtip = ap.a_rt_i;
	int i;
	static int a[] = {
		 35,   0,
		  0,  90, 135, 180, 225, 270, 315,
		  0,  90, 135, 180, 225, 270, 315
	};
	static int e[] = {
		25, 90,
		30, 30, 30, 30, 30, 30, 30,
		60, 60, 60, 60, 60, 60, 60
	};

	if( BU_LIST_IS_EMPTY( &rtip->HeadRegion ) )  {
		def_tree( rtip );		/* Load the default trees */
	}
	for( i=0; i<(sizeof(a)/sizeof(a[0])); i++ )  {
		do_ae( (double)a[i], (double)e[i] );
		(void)do_frame( curframe++ );
	}
	return(-1);	/* end RT by returning an error */
}

/*
 *			C M _ A N I M
 *
 *  Experimental animation code
 *
 *  Usage:  anim <path> <type> args
 */
int cm_anim(int argc, const char **argv)
{

	if( db_parse_anim( ap.a_rt_i->rti_dbip, argc, argv ) < 0 )  {
		bu_log("cm_anim:  %s %s failed\n", argv[1], argv[2]);
		return(-1);		/* BAD */
	}
	return(0);
}

/*
 *			C M _ C L E A N
 *
 *  Clean out results of last rt_prep(), and start anew.
 */
int cm_clean(int argc, char **argv)
{
	/* Allow lighting model to clean up (e.g. lights, materials, etc) */
	view_cleanup( ap.a_rt_i );

	rt_clean( ap.a_rt_i );

	if(R_DEBUG&RDEBUG_RTMEM_END)
		bu_prmem( "After cm_clean" );
	return(0);
}

/*
 *			C M _ C L O S E D B
 *
 *  To be invoked after a "clean" command, to close out the ".g" database.
 *  Intended for memory debugging, to help chase down memory "leaks".
 *  This terminates the program, as there is no longer a database.
 */
int cm_closedb(int argc, char **argv)
{
	db_close( ap.a_rt_i->rti_dbip );
	ap.a_rt_i->rti_dbip = DBI_NULL;

	bu_free( (genptr_t)ap.a_rt_i, "struct rt_i" );
	ap.a_rt_i = RTI_NULL;

	bu_prmem( "After _closedb" );
	exit(0);

	return( 1 );	/* for compiler */
}

/* viewing module specific variables */
extern struct bu_structparse view_parse[];

/* from librt/g_bot.c */
extern int rt_bot_minpieces;
extern int rt_bot_tri_per_piece;

/*
 *  Generic settable parameters.
 *  By setting the "base address" to zero in the bu_structparse call,
 *  the actual memory address is given here as the structure offset.
 *
 *  Strictly speaking, the C language only permits initializers of the
 *  form: address +- constant, where here the intent is to measure the
 *  byte address of the indicated variable.
 *  Matching compensation code for the CRAY is located in librt/parse.c
 */
#if CRAY
#	define byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
#	define byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define byteoffset(_i)	((int)((char *)&(_i)))
#    else
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#    endif
#  endif
#endif
struct bu_structparse set_parse[] = {
#if !defined(__alpha)	/* XXX Alpha does not support this initialization! */
	{"%d",	1, "width",	byteoffset(width),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "height",	byteoffset(height),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "save_overlaps", byteoffset(save_overlaps),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "perspective", byteoffset(rt_perspective),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "angle",	byteoffset(rt_perspective),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "rt_bot_minpieces", byteoffset(rt_bot_minpieces),BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "rt_bot_tri_per_piece", byteoffset(rt_bot_tri_per_piece),BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "rt_cline_radius", byteoffset(rt_cline_radius),BU_STRUCTPARSE_FUNC_NULL },
	{"%S",  1, "ray_data_file", byteoffset(ray_data_file),BU_STRUCTPARSE_FUNC_NULL },
	{"i", byteoffset(view_parse[0]),"View_Module-Specific Parameters", 0, BU_STRUCTPARSE_FUNC_NULL },
#endif
	{"",	0, (char *)0,	0,				BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *			C M _ S E T
 *
 *  Allow variable values to be set or examined.
 */
int cm_set(int argc, char **argv)
{
	struct bu_vls	str;

	if( argc <= 1 ) {
		bu_struct_print( "Generic and Application-Specific Parameter Values",
			set_parse, (char *)0 );
		return(0);
	}
	bu_vls_init( &str );
	bu_vls_from_argv( &str, argc-1, argv+1 );
	if( bu_struct_parse( &str, set_parse, (char *)0 ) < 0 )  {
		bu_vls_free( &str );
		return(-1);
	}
	bu_vls_free( &str );
	return(0);
}

/* 
 *			C M _ A E
 */
int cm_ae( int argc, char **argv)
{
	azimuth = atof(argv[1]);	/* set elevation and azimuth */
	elevation = atof(argv[2]);
	Viewrotscale[15] = 0.0;		/* set scale to 0.0 so that cm_end */
					/* will do the do_ae               */

	return(0);
}

/*
 *			C M _ O P T
 */
int cm_opt(int argc, char **argv)
{
	int old_bu_optind=bu_optind;	/* need to restore this value after calling get_args() */

	if( get_args( argc, argv ) <= 0 ) {
		bu_optind = old_bu_optind;
		return(-1);
	}
	bu_optind = old_bu_optind;
	return(0);
}


/*
 *			D E F _ T R E E
 *
 *  Load default tree list, from command line.
 */
void
def_tree(register struct rt_i *rtip)
{
	struct bu_vls	times;

	RT_CK_RTI(rtip);

	bu_vls_init( &times );
	rt_prep_timer();
	if( rt_gettrees(rtip, nobjs, (const char **)objtab, npsw) < 0 )
		bu_log("rt_gettrees(%s) FAILED\n", objtab[0]);
	(void)rt_get_timer( &times, NULL );

	if (rt_verbosity & VERBOSE_STATS)
		bu_log("GETTREE: %s\n", bu_vls_addr(&times));
	bu_vls_free( &times );
	memory_summary();
}

/*
 *			D O _ P R E P
 *
 *  This is a separate function primarily as a service to REMRT.
 */
void
do_prep(struct rt_i *rtip)
{
	struct bu_vls	times;

	RT_CHECK_RTI(rtip);
	if( rtip->needprep )  {
		/* Allow lighting model to set up (e.g. lights, materials, etc) */
		view_setup(rtip);

		/* Allow RT library to prepare itself */
		bu_vls_init( &times );
		rt_prep_timer();
		rt_prep_parallel(rtip, npsw);

		(void)rt_get_timer( &times, NULL );
		if (rt_verbosity & VERBOSE_STATS)
			bu_log( "PREP: %s\n", bu_vls_addr(&times) );
		bu_vls_free( &times );
	}
	memory_summary();
	if (rt_verbosity & VERBOSE_STATS)  {
		bu_log("%s: %d nu, %d cut, %d box (%d empty)\n",
			rtip->rti_space_partition == RT_PART_NUGRID ?
				"NUGrid" : "NUBSP",
			rtip->rti_ncut_by_type[CUT_NUGRIDNODE],
			rtip->rti_ncut_by_type[CUT_CUTNODE],
			rtip->rti_ncut_by_type[CUT_BOXNODE],
			rtip->nempty_cells );
#if 0
rt_pr_cut_info( rtip, "main" );
#endif
	}
}

/*
 *			D O _ F R A M E
 *
 *  Do all the actual work to run a frame.
 *
 *  Returns -1 on error, 0 if OK.
 */
int
do_frame(int framenumber)
{
	struct bu_vls	times;
	char framename[128];		/* File name to hold current frame */
	struct rt_i *rtip = ap.a_rt_i;
	double	utime = 0.0;			/* CPU time used */
	double	nutime = 0.0;			/* CPU time used, normalized by ncpu */
	double	wallclock;		/* # seconds of wall clock time */
	int	npix,i;			/* # of pixel values to be done */
	int	lim;
	vect_t	work, temp;
	quat_t	quat;

	if (rt_verbosity & VERBOSE_FRAMENUMBER)
		bu_log( "\n...................Frame %5d...................\n",
			framenumber);

	/* Compute model RPP, etc */
	do_prep( rtip );

	if (rt_verbosity & VERBOSE_VIEWDETAIL)
		bu_log("Tree: %d solids in %d regions\n",
			rtip->nsolids, rtip->nregions );

	if (Query_one_pixel) {
		query_rdebug = R_DEBUG;
		query_debug = RT_G_DEBUG;
		rt_g.debug = rdebug = 0;
	}

	if( rtip->nsolids <= 0 )  {
		bu_log("rt ERROR: No solids\n");
		exit(3);
	}

	if (rt_verbosity & VERBOSE_VIEWDETAIL)
		bu_log("Model: X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
			rtip->mdl_min[X], rtip->mdl_max[X],
			rtip->mdl_min[Y], rtip->mdl_max[Y],
			rtip->mdl_min[Z], rtip->mdl_max[Z] );

	/*
	 *  Perform Grid setup.
	 *  This may alter cell size or width/height.
	 */
	grid_setup();
	/* az/el 0,0 is when screen +Z is model +X */
	VSET( work, 0, 0, 1 );
	MAT3X3VEC( temp, view2model, work );
	bn_ae_vec( &azimuth, &elevation, temp );

	if (rt_verbosity & VERBOSE_VIEWDETAIL)
		bu_log(
			"View: %g azimuth, %g elevation off of front view\n",
			azimuth, elevation);
	quat_mat2quat( quat, model2view );
	if (rt_verbosity & VERBOSE_VIEWDETAIL) {
		bu_log("Orientation: %g, %g, %g, %g\n", V4ARGS(quat) );
		bu_log("Eye_pos: %g, %g, %g\n", V3ARGS(eye_model) );
		bu_log("Size: %gmm\n", viewsize);
#if 0
	/*
	 *  This code shows how the model2view matrix can be reconstructed
	 *  using the information from the Orientation, Eye_pos, and Size
	 *  messages.
	 */
		{
			mat_t	rotscale, xlate;
			mat_t	new;
			quat_t	newquat;

			bn_mat_print("model2view", model2view);
			quat_quat2mat( rotscale, quat );
			rotscale[15] = 0.5 * viewsize;
			MAT_IDN( xlate );
			MAT_DELTAS( xlate, -eye_model[X], -eye_model[Y], -eye_model[Z] );
			bn_mat_mul( new, rotscale, xlate );
			bn_mat_print("reconstructed m2v", new);
			quat_mat2quat( newquat, new );
			HPRINT( "reconstructed orientation:", newquat );
		}
#endif
		bu_log("Grid: (%g, %g) mm, (%d, %d) pixels\n",
			cell_width, cell_height,
			width, height );
		bu_log("Beam: radius=%g mm, divergence=%g mm/1mm\n",
			ap.a_rbeam, ap.a_diverge );
	}

	/* Process -b and ??? options now, for this frame */
	if( pix_start == -1 )  {
		pix_start = 0;
		pix_end = height * width - 1;
	}
	if( string_pix_start )  {
		int xx, yy;
		register char *cp = string_pix_start;

		xx = atoi(cp);
		while( *cp >= '0' && *cp <= '9' )  cp++;
		while( *cp && (*cp < '0' || *cp > '9') ) cp++;
		yy = atoi(cp);
		bu_log("only pixel %d %d\n", xx, yy);
		if( xx * yy >= 0 )  {
			pix_start = yy * width + xx;
			pix_end = pix_start;
		}
	}
	if( string_pix_end )  {
		int xx, yy;
		register char *cp = string_pix_end;

		xx = atoi(cp);
		while( *cp >= '0' && *cp <= '9' )  cp++;
		while( *cp && (*cp < '0' || *cp > '9') ) cp++;
		yy = atoi(cp);
		bu_log("ending pixel %d %d\n", xx, yy);
		if( xx * yy >= 0 )  {
			pix_end = yy * width + xx;
		}
	}

	/*
	 *  After the parameters for this calculation have been established,
	 *  deal with CPU limits and priorities, where appropriate.
	 *  Because limits exist, they better be adequate.
	 *  We assume that the Cray can produce MINRATE pixels/sec
	 *  on images with extreme amounts of glass & mirrors.
	 */
#ifdef CRAY2
#define MINRATE	35
#else
#define MINRATE	65
#endif
	npix = width*height*(hypersample+1);
	if( (lim = bu_cpulimit_get()) > 0 )  {
		bu_cpulimit_set( lim + npix / MINRATE + 100 );
	}

	/* Allocate data for pixel map for rerendering of black pixels */
	pixmap= (unsigned char*)malloc(sizeof(RGBpixel)*width*height);
	for (i= 0; i < width*height*sizeof(RGBpixel); i++)
		pixmap[i]= 0;

	/*
	 *  If this image is unlikely to be for debugging,
	 *  be gentle to the machine.
	 */
	if( !interactive )  {
		if( npix > 256*256 )
			bu_nice_set(10);
		else if( npix > 512*512 )
			bu_nice_set(14);
	}

	/*
	 *  Determine output file name
	 *  On UNIX only, check to see if this is a "restart".
	 */
	if( outputfile != (char *)0 )  {
#ifdef CRAY_COS
		/* Dots in COS file names make them permanant files. */
		sprintf( framename, "F%d", framenumber );
		if( (outfp = fopen( framename, "w" )) == NULL )  {
			perror( framename );
			if( matflag )  return(0);
			return(-1);
		}
		/* Dispose to shell script starts with "!" */
		if( framenumber <= 0 || outputfile[0] == '!' )  {
			sprintf( framename, outputfile );
		}  else  {
			sprintf( framename, "%s.%d", outputfile, framenumber );
		}
#else
		if( framenumber <= 0 )  {
			sprintf( framename, outputfile );
		}  else  {
			sprintf( framename, "%s.%d", outputfile, framenumber );
		}
#ifdef HAVE_UNIX_IO
		/*
		 *  This code allows the computation of a particular frame
		 *  to a disk file to be resumed automaticly.
		 *  This is worthwhile crash protection.
		 *  This use of stat() and fseek() is UNIX-specific.
		 *
		 *  It is not appropriate for the RT "top part" to assume
		 *  anything about the data that the view module will be
		 *  storing.  Therefore, it is the responsibility of
		 *  view_2init() to also detect that some existing data
		 *  is in the file, and take appropriate measures
		 *  (like reading it in).
		 *  view_2init() can depend on the file being open for both
		 *  reading and writing, but must do it's own positioning.
		 */
		{
			struct		stat	sb;
			if( stat( framename, &sb ) >= 0 && sb.st_size > 0 )  {
				/* File exists, with partial results */
				register int	fd;
				if( (fd = open( framename, 2 )) < 0 ||
				    (outfp = fdopen( fd, "r+" )) == NULL )  {
					perror( framename );
					if( matflag )  return(0);	/* OK */
					return(-1);			/* Bad */
				}
				/* Read existing pix data into the frame buffer */
				if (sb.st_size) {
					(void)fread(pixmap,1,sb.st_size,outfp);
				}
			}
		}
#endif

		/* Ordinary case for creating output file */
		if( outfp == NULL && (outfp = fopen( framename, "w" )) == NULL )  {
			perror( framename );
			if( matflag )  return(0);	/* OK */
			return(-1);			/* Bad */
		}
#endif /* CRAY_COS */
		if (rt_verbosity & VERBOSE_OUTPUTFILE)
			bu_log("Output file is '%s' %dx%d pixels\n", 
				framename, width, height);
	}

	/* initialize lighting, may update pix_start */
	view_2init( &ap, framename );

	/* Just while doing the ray-tracing */
	if(R_DEBUG&RDEBUG_RTMEM)
		bu_debug |= (BU_DEBUG_MEM_CHECK|BU_DEBUG_MEM_LOG);

	rtip->nshots = 0;
	rtip->nmiss_model = 0;
	rtip->nmiss_tree = 0;
	rtip->nmiss_solid = 0;
	rtip->nmiss = 0;
	rtip->nhits = 0;
	rtip->rti_nrays = 0;

	if (rt_verbosity & (VERBOSE_LIGHTINFO|VERBOSE_STATS))
		bu_log("\n");
	fflush(stdout);
	fflush(stderr);

	/*
	 *  Compute the image
	 *  It may prove desirable to do this in chunks
	 */
	rt_prep_timer();

	if( incr_mode )  {
		for( incr_level = 1; incr_level <= incr_nlevel; incr_level++ )  {
			if( incr_level > 1 )
				view_2init( &ap, framename );

			do_run( 0, (1<<incr_level)*(1<<incr_level)-1 );
		}
	} else {
		do_run( pix_start, pix_end );

		/* Reset values to full size, for next frame (if any) */
		pix_start = 0;
		pix_end = height*width - 1;
	}
	bu_vls_init( &times );
	utime = rt_get_timer( &times, &wallclock );

	/*
	 *  End of application.  Done outside of timing section.
	 *  Typically, writes any remaining results out.
	 */
	view_end( &ap );

	/* Stop memory debug printing until next frame, leave full checking on */
	if(R_DEBUG&RDEBUG_RTMEM)
		bu_debug &= ~BU_DEBUG_MEM_LOG;

	/*
	 *  Certain parallel systems (eg, Alliant) count the entire 
	 *  multi-processor complex as one computer, and charge only once.
	 *  This matches the desired behavior here.
	 *  Other vendors (eg, SGI) count each processor separately,
	 *  and charge for all of them.  These results need to be normalized.
	 *  Otherwise, all we would know is that a given workload takes about
	 *  the same amount of CPU time, regardless of the number of CPUs.
	 */
#if !defined(alliant)
	if( npsw > 1 )  {
		int avail_cpus;
		int ncpus;

		avail_cpus = bu_avail_cpus();
		if( npsw > avail_cpus ) {
			ncpus = avail_cpus;
		} else {
			ncpus = npsw;
		}
		nutime = utime / ncpus;			/* compensate */
	} else
#endif
		nutime = utime;

	/* prevent a bogus near-zero time to prevent infinate and near-infinate
	 * results without relying on IEEE floating point zero comparison.
	 */
	if (NEAR_ZERO(nutime, VDIVIDE_TOL)) {
	  bu_log("WARNING:  Raytrace timings are likely to be meaningless\n");
	  nutime = VDIVIDE_TOL;
	}

	/*
	 *  All done.  Display run statistics.
	 */
	if (rt_verbosity & VERBOSE_STATS)
		bu_log("SHOT: %s\n", bu_vls_addr( &times ) );
	bu_vls_free( &times );
	memory_summary();
	if (rt_verbosity & VERBOSE_STATS) {
		bu_log("%ld solid/ray intersections: %ld hits + %ld miss\n",
			rtip->nshots, rtip->nhits, rtip->nmiss );
		bu_log("pruned %.1f%%:  %ld model RPP, %ld dups skipped, %ld solid RPP\n",
			rtip->nshots>0?((double)rtip->nhits*100.0)/rtip->nshots:100.0,
			rtip->nmiss_model, rtip->ndup, rtip->nmiss_solid );
		bu_log(
			"Frame %5d: %8d pixels in %10.2f sec = %10.2f pixels/sec\n",
			framenumber,
			width*height, nutime, ((double)(width*height))/nutime );
		bu_log(
			"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/sec (RTFM)\n",
			framenumber,
			rtip->rti_nrays, nutime, ((double)(rtip->rti_nrays))/nutime );
		bu_log(
			"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/CPU_sec\n",
			framenumber,
			rtip->rti_nrays, utime, ((double)(rtip->rti_nrays))/utime );
		bu_log(
			"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/sec (wallclock)\n",
			framenumber,
			rtip->rti_nrays,
			wallclock, ((double)(rtip->rti_nrays))/wallclock );
	}
	if( outfp != NULL )  {
#ifdef CRAY_COS
		int status;
		char dn[16];
		char message[128];

		strncpy( dn, outfp->ldn, sizeof(outfp->ldn) );	/* COS name */
#endif
		(void)fclose(outfp);
		outfp = NULL;
#ifdef CRAY_COS
		status = 0;
		/* Binary out */
		(void)DISPOSE( &status, "DN      ", dn,
			"TEXT    ", framename,
			"NOWAIT  ",
			"DF      ", "BB      " );
		sprintf(message,
			"%s Dispose,dn='%s',text='%s'.  stat=0%o",
			(status==0) ? "Good" : "---BAD---",
			dn, framename, status );
		bu_log( "%s\n", message);
		remark(message);	/* Send to log files */
#else
		/* Protect finished product */
		if( outputfile != (char *)0 )
			chmod( framename, 0444 );
#endif
	}

	if(R_DEBUG&RDEBUG_STATS)  {
		/* Print additional statistics */
		res_pr();
	}

	bu_log("\n");
        free(pixmap);
	return(0);		/* OK */
}

/*
 *			D O _ A E
 *
 *  Compute the rotation specified by the azimuth and elevation
 *  parameters.  First, note that these are specified relative
 *  to the GIFT "front view", ie, model (X,Y,Z) is view (Z,X,Y):
 *  looking down X axis, Y right, Z up.
 *  A positive azimuth represents rotating the *eye* around the
 *  Y axis, or, rotating the *model* in -Y.
 *  A positive elevation represents rotating the *eye* around the
 *  X axis, or, rotating the *model* in -X.
 */
void
do_ae(double azim, double elev)
{
	vect_t	temp;
	vect_t	diag;
	mat_t	toEye;
	struct rt_i *rtip = ap.a_rt_i;

	if( rtip->nsolids <= 0 )
		rt_bomb("do_ae: no solids active\n");
	if( rtip->mdl_max[X] >= INFINITY || rtip->mdl_max[X] <= -INFINITY )
		rt_bomb("do_ae: infinite model bounds?\n");

	/*
	 *  Enlarge the model RPP just slightly, to avoid nasty
	 *  effects with a solid's face being exactly on the edge
	 *  NOTE:  This code is duplicated out of librt/tree.c/rt_prep(),
	 *  and has to appear here to enable the viewsize calculation to
	 *  match the final RPP.
	 */
	rtip->mdl_min[X] = floor( rtip->mdl_min[X] );
	rtip->mdl_min[Y] = floor( rtip->mdl_min[Y] );
	rtip->mdl_min[Z] = floor( rtip->mdl_min[Z] );
	rtip->mdl_max[X] = ceil( rtip->mdl_max[X] );
	rtip->mdl_max[Y] = ceil( rtip->mdl_max[Y] );
	rtip->mdl_max[Z] = ceil( rtip->mdl_max[Z] );

	MAT_IDN( Viewrotscale );
	bn_mat_angles( Viewrotscale, 270.0+elev, 0.0, 270.0-azim );

	/* Look at the center of the model */
	MAT_IDN( toEye );
	toEye[MDX] = -(rtip->mdl_max[X]+rtip->mdl_min[X])/2;
	toEye[MDY] = -(rtip->mdl_max[Y]+rtip->mdl_min[Y])/2;
	toEye[MDZ] = -(rtip->mdl_max[Z]+rtip->mdl_min[Z])/2;

	/* Fit a sphere to the model RPP, diameter is viewsize,
	 * unless viewsize command used to override.
	 */
	if( viewsize <= 0 ) {
		VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
		viewsize = MAGNITUDE( diag );
		if( aspect > 1 ) {
			/* don't clip any of the image when autoscaling */
			viewsize *= aspect;
		}
	}
	Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
	bn_mat_mul( model2view, Viewrotscale, toEye );
	bn_mat_inv( view2model, model2view );
	VSET( temp, 0, 0, eye_backoff );
	MAT4X3PNT( eye_model, view2model, temp );
}

/*
 *			R E S _ P R
 */
void
res_pr(void)
{
	register struct resource *res;
	register int i;

	fprintf(stderr,"\nResource use summary, by processor:\n");
	res = &resource[0];
	for( i=0; i<npsw; i++, res++ )  {
		fprintf(stderr, "---CPU %d:\n", i);
		if( res->re_magic != RESOURCE_MAGIC )  {
			fprintf(stderr,"Bad magic number!!\n");
			continue;
		}
		fprintf(stderr,"seg       len=%10ld get=%10ld free=%10ld\n",
			res->re_seglen, res->re_segget, res->re_segfree );
		fprintf(stderr,"partition len=%10ld get=%10ld free=%10ld\n",
			res->re_partlen, res->re_partget, res->re_partfree );
#if 0
		fprintf(stderr,"bitv_elem len=%10ld get=%10ld free=%10ld\n",
			res->re_bitvlen, res->re_bitvget, res->re_bitvfree );
#endif
		fprintf(stderr,"boolstack len=%10ld\n",
			res->re_boolslen);
	}
}

/*
 *  Command table for RT control script language
 */

struct command_tab rt_cmdtab[] = {
	{"start", "frame number", "start a new frame",
		cm_start,	2, 2},
	{"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2},
	{"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4},
	{"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5},
	{"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17},
	{"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5},
	{"end", 	"", "end of frame setup, begin raytrace",
		cm_end,		1, 1},
	{"multiview", "", "produce stock set of views",
		cm_multiview,	1, 1},
	{"anim", 	"path type args", "specify articulation animation",
		cm_anim,	4, 999},
	{"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_tree,	1, 999},
	{"clean", "", "clean articulation from previous frame",
		cm_clean,	1, 1},
	{"_closedb", "", "Close .g database, (for memory debugging)",
		cm_closedb,	1, 1},
	{"set", 	"", "show or set parameters",
		cm_set,		1, 999},
	{"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_ae,		3, 3},
	{"opt", "-flags", "set flags, like on command line",
		cm_opt,		2, 999},
	{(char *)0, (char *)0, (char *)0,
	        0,		0, 0	/* END */}
};
@


11.53
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/do.c,v 11.52 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.52
log
@merge of ansi-6-0-branch into head
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.51
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.50 2003/10/07 01:16:07 morrison Exp $ (BRL)";
d52 2
a53 2
extern void	grid_setup();
extern void	worker();
d109 3
a111 3
void		def_tree();
void		do_ae();
void		res_pr();
d121 1
a121 2
old_frame( fp )
FILE *fp;
d152 1
a152 2
old_way( fp )
FILE *fp;
d516 1
a516 2
def_tree( rtip )
register struct rt_i	*rtip;
d540 1
a540 2
do_prep( rtip )
struct rt_i	*rtip;
d582 1
a582 2
do_frame( framenumber )
int framenumber;
d979 1
a979 2
do_ae( azim, elev )
double azim, elev;
d1036 1
a1036 1
res_pr()
@


11.50
log
@added near infinite normalized cpu time usage to limit the impact of floating point division error
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1987 by the United States Army.
d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.49 2003/09/27 01:11:25 morrison Exp $ (BRL)";
@


11.50.2.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.51 2004/02/02 17:39:38 morrison Exp $ (BRL)";
@


11.50.2.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.50.2.1 2004/02/12 19:37:12 erikg Exp $ (BRL)";
@


11.49
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.48 2003/09/10 12:33:45 jra Exp $ (BRL)";
d592 2
a593 2
	double	utime;			/* CPU time used */
	double	nutime;			/* CPU time used, normalized by ncpu */
d839 1
d844 1
d891 8
@


11.48
log
@Eliminated an unused variable
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.47 2003/09/09 15:15:05 justin Exp $ (BRL)";
d385 1
a385 1
	if(rdebug&RDEBUG_RTMEM_END)
d612 1
a612 1
		query_rdebug = rdebug;
d818 1
a818 1
	if(rdebug&RDEBUG_RTMEM)
d862 1
a862 1
	if(rdebug&RDEBUG_RTMEM)
d951 1
a951 1
	if(rdebug&RDEBUG_STATS)  {
@


11.47
log
@migrated black pixel rendering to do.c for blac pixel rendering
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.46 2003/09/05 16:05:51 justin Exp $ (BRL)";
a784 1
			int			n;
d796 1
a796 1
					n= fread(pixmap,1,sb.st_size,outfp);
@


11.46
log
@updated black pixel re-rendering
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.45 2003/09/05 16:05:13 justin Exp $ (BRL)";
d106 1
a106 1
extern unsigned	char	*pixmap;		/* pixel map for rerendering of black pixels */
d595 1
a595 1
	int	npix;			/* # of pixel values to be done */
d726 5
d958 1
@


11.45
log
@updated for black pixel re-rendering
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.44 2003/04/11 19:38:37 jra Exp $ (BRL)";
d106 1
a106 1
extern FBIO	*pixmap;		/* pixel map for rerendering of black pixels */
@


11.44
log
@cm_opt() was calling get_args() which hosed the current value of bu_optind.
Added code to reset it after the call to get_args()
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.43 2002/08/20 17:08:37 jra Exp $ (BRL)";
a101 1

d105 3
d779 2
a780 1
			struct stat sb;
d789 4
@


11.43
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.41 2002/03/14 14:09:48 jra Exp $ (BRL)";
d499 4
a502 1
	if( get_args( argc, argv ) <= 0 )
d504 2
@


11.43.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/do.c,v 11.51 2004/02/02 17:39:38 morrison Exp $ (BRL)";
d102 1
a105 3
/***** variables for frame buffer black pixel rendering *****/
unsigned char *pixmap = NULL; /* Pixel Map for rerendering of black pixels */

d383 1
a383 1
	if(R_DEBUG&RDEBUG_RTMEM_END)
d499 1
a499 4
	int old_bu_optind=bu_optind;	/* need to restore this value after calling get_args() */

	if( get_args( argc, argv ) <= 0 ) {
		bu_optind = old_bu_optind;
a500 2
	}
	bu_optind = old_bu_optind;
d585 2
a586 2
	double	utime = 0.0;			/* CPU time used */
	double	nutime = 0.0;			/* CPU time used, normalized by ncpu */
d588 1
a588 1
	int	npix,i;			/* # of pixel values to be done */
d605 1
a605 1
		query_rdebug = R_DEBUG;
a718 5
	/* Allocate data for pixel map for rerendering of black pixels */
	pixmap= (unsigned char*)malloc(sizeof(RGBpixel)*width*height);
	for (i= 0; i < width*height*sizeof(RGBpixel); i++)
		pixmap[i]= 0;

d772 1
a772 1
			struct		stat	sb;
a781 4
				/* Read existing pix data into the frame buffer */
				if (sb.st_size) {
					(void)fread(pixmap,1,sb.st_size,outfp);
				}
d802 1
a802 1
	if(R_DEBUG&RDEBUG_RTMEM)
a822 1

a826 1

d846 1
a846 1
	if(R_DEBUG&RDEBUG_RTMEM)
a873 8
	/* prevent a bogus near-zero time to prevent infinate and near-infinate
	 * results without relying on IEEE floating point zero comparison.
	 */
	if (NEAR_ZERO(nutime, VDIVIDE_TOL)) {
	  bu_log("WARNING:  Raytrace timings are likely to be meaningless\n");
	  nutime = VDIVIDE_TOL;
	}

d935 1
a935 1
	if(R_DEBUG&RDEBUG_STATS)  {
a940 1
        free(pixmap);
@


11.43.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.43 2002/08/20 17:08:37 jra Exp $ (BRL)";
d52 2
a53 2
extern void	grid_setup(void);
extern void	worker(int cpu, genptr_t arg);
d107 3
a109 3
void		def_tree(register struct rt_i *rtip);
void		do_ae(double azim, double elev);
void		res_pr(void);
d119 2
a120 1
old_frame(FILE *fp)
d151 2
a152 1
old_way(FILE *fp)
d511 2
a512 1
def_tree(register struct rt_i *rtip)
d536 2
a537 1
do_prep(struct rt_i *rtip)
d579 2
a580 1
do_frame(int framenumber)
d957 2
a958 1
do_ae(double azim, double elev)
d1015 1
a1015 1
res_pr(void)
@


11.43.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d102 1
a105 3
/***** variables for frame buffer black pixel rendering *****/
unsigned char *pixmap = NULL; /* Pixel Map for rerendering of black pixels */

d381 1
a381 1
	if(R_DEBUG&RDEBUG_RTMEM_END)
d497 1
a497 4
	int old_bu_optind=bu_optind;	/* need to restore this value after calling get_args() */

	if( get_args( argc, argv ) <= 0 ) {
		bu_optind = old_bu_optind;
a498 2
	}
	bu_optind = old_bu_optind;
d580 2
a581 2
	double	utime = 0.0;			/* CPU time used */
	double	nutime = 0.0;			/* CPU time used, normalized by ncpu */
d583 1
a583 1
	int	npix,i;			/* # of pixel values to be done */
d600 1
a600 1
		query_rdebug = R_DEBUG;
a713 5
	/* Allocate data for pixel map for rerendering of black pixels */
	pixmap= (unsigned char*)malloc(sizeof(RGBpixel)*width*height);
	for (i= 0; i < width*height*sizeof(RGBpixel); i++)
		pixmap[i]= 0;

d767 1
a767 1
			struct		stat	sb;
a776 4
				/* Read existing pix data into the frame buffer */
				if (sb.st_size) {
					(void)fread(pixmap,1,sb.st_size,outfp);
				}
d797 1
a797 1
	if(R_DEBUG&RDEBUG_RTMEM)
a817 1

a821 1

d841 1
a841 1
	if(R_DEBUG&RDEBUG_RTMEM)
a868 8
	/* prevent a bogus near-zero time to prevent infinate and near-infinate
	 * results without relying on IEEE floating point zero comparison.
	 */
	if (NEAR_ZERO(nutime, VDIVIDE_TOL)) {
	  bu_log("WARNING:  Raytrace timings are likely to be meaningless\n");
	  nutime = VDIVIDE_TOL;
	}

d930 1
a930 1
	if(R_DEBUG&RDEBUG_STATS)  {
a935 1
        free(pixmap);
@


11.42
log
@Converted from K&R to ANSI C - RFH
@
text
@d52 2
a53 2
extern void	grid_setup(void);
extern void	worker(int cpu, genptr_t arg);
d107 3
a109 3
void		def_tree(register struct rt_i *rtip);
void		do_ae(double azim, double elev);
void		res_pr(void);
d119 2
a120 1
old_frame(FILE *fp)
d151 2
a152 1
old_way(FILE *fp)
d511 2
a512 1
def_tree(register struct rt_i *rtip)
d536 2
a537 1
do_prep(struct rt_i *rtip)
d579 2
a580 1
do_frame(int framenumber)
d957 2
a958 1
do_ae(double azim, double elev)
d1015 1
a1015 1
res_pr(void)
@


11.41
log
@do_frame() now bases RTFM calculations on the lesser of npsw and bu_avail_cpus()
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.40 2001/11/29 18:05:35 jra Exp $ (BRL)";
d52 2
a53 2
extern void	grid_setup();
extern void	worker();
d107 3
a109 3
void		def_tree();
void		do_ae();
void		res_pr();
d119 1
a119 2
old_frame( fp )
FILE *fp;
d150 1
a150 2
old_way( fp )
FILE *fp;
d509 1
a509 2
def_tree( rtip )
register struct rt_i	*rtip;
d533 1
a533 2
do_prep( rtip )
struct rt_i	*rtip;
d575 1
a575 2
do_frame( framenumber )
int framenumber;
d952 1
a952 2
do_ae( azim, elev )
double azim, elev;
d1009 1
a1009 1
res_pr()
@


11.40
log
@Added "rt_bot_tri_per_piece" as a settable variable
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.39 2001/05/17 20:06:07 morrison Exp $ (BRL)";
d860 10
a869 1
		nutime = utime / npsw;			/* compensate */
@


11.39
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.38 2001/04/05 19:36:03 morrison Exp $ (BRL)";
d414 1
d449 1
@


11.38
log
@updated SIGNED to signed
updated CONST to const
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.37 2001/03/31 01:57:31 morrison Exp $ (BRL)";
d604 1
a604 1
		query_debug = rt_g.debug;
@


11.37
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.36 2001/03/19 22:20:14 butler Exp $ (BRL)";
d518 1
a518 1
	if( rt_gettrees(rtip, nobjs, (CONST char **)objtab, npsw) < 0 )
@


11.36
log
@patches to merge 5.3 into 6.0
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /d/CVS/brlcad/rt/do.c,v 11.35 2000/12/05 15:49:12 jra Exp $ (BRL)";
d652 1
a652 1
			bn_mat_idn( xlate );
d973 1
a973 1
	bn_mat_idn( Viewrotscale );
d977 1
a977 1
	bn_mat_idn( toEye );
@


11.35
log
@Added support for rt_cline_radius and ray_data_file
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.34 2000/09/08 05:54:46 mike Exp $ (BRL)";
d96 1
d102 1
@


11.34
log
@
Modified tree routines to take resource pointer.
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.33 2000/09/07 19:35:42 mike Exp $ (BRL)";
d96 9
d446 2
@


11.33
log
@
Broke out memory_summary() routine, added malloc/free logging.
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.32 2000/08/23 06:25:49 mike Exp $ (BRL)";
d501 1
a501 5
	if( rtip->rti_magic != RTI_MAGIC )  {
		bu_log("rtip=x%x, rti_magic=x%x s/b x%x\n", rtip,
			rtip->rti_magic, RTI_MAGIC );
		rt_bomb("def_tree:  bad rtip\n");
	}
@


11.32
log
@
rt_bot_minpieces is an int, not a fastf_t.
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.31 2000/08/17 02:41:33 mike Exp $ (BRL)";
a81 1
extern char	*beginptr;		/* sbrk() at start of program */
d99 1
d516 1
a516 7

#ifdef HAVE_SBRK
	if (rt_verbosity & VERBOSE_STATS)
		bu_log("Additional dynamic memory used=%ld. bytes\n",
			(long)((char *)sbrk(0)-beginptr) );
	beginptr = (char *) sbrk(0);
#endif
d545 1
a545 6
#ifdef HAVE_SBRK
	if (rt_verbosity & VERBOSE_STATS)
		bu_log("Additional dynamic memory used=%ld. bytes\n",
			(long)((char *)sbrk(0)-beginptr) );
	beginptr = (char *) sbrk(0);
#endif
d860 1
a860 6
#ifdef HAVE_SBRK
	if (rt_verbosity & VERBOSE_STATS)
		bu_log("Additional dynamic memory used=%ld. bytes\n",
			(long)((char *)sbrk(0)-beginptr) );
	beginptr = (char *) sbrk(0);
#endif
@


11.31
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.30 2000/07/31 02:01:15 butler Exp $ (BRL)";
d436 1
a436 1
	{"%f",  1, "rt_bot_minpieces", byteoffset(rt_bot_minpieces),BU_STRUCTPARSE_FUNC_NULL },
@


11.30
log
@Support for a new method for light sample pts.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.29 2000/07/27 19:32:52 butler Exp $ (BRL)";
@


11.29
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.28 2000/07/25 16:39:47 butler Exp $ (BRL)";
d614 1
@


11.28
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.27 2000/05/18 21:10:09 jra Exp $ (BRL)";
d603 7
@


11.27
log
@
Added "save_overlaps" as a settable variable.
It value is given to rti_save_overlaps in do.c.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.26 2000/05/18 02:02:24 mike Exp $ (BRL)";
d26 1
d32 1
d40 1
a40 1
#include "./rdebug.h"
d102 31
a181 29
/*
 *			O L D _ F R A M E
 *
 *  Acquire particulars about a frame, in the old format.
 *  Returns -1 if unable to acquire info, 0 if successful.
 */
int
old_frame( fp )
FILE *fp;
{
	register int i;
	char number[128];

	/* Visible part is from -1 to +1 in view space */
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	viewsize = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[X] = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[Y] = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[Z] = atof(number);
	for( i=0; i < 16; i++ )  {
		if( fscanf( fp, "%s", number ) != 1 )
			return(-1);
		Viewrotscale[i] = atof(number);
	}
	return(0);		/* OK */
}
d188 1
a188 3
cm_start( argc, argv )
int	argc;
char	**argv;
d222 1
a222 3
cm_vsize( argc, argv )
int	argc;
char	**argv;
d228 1
a228 3
cm_eyept( argc, argv )
int	argc;
char	**argv;
d237 1
a237 3
cm_lookat_pt( argc, argv )
int	argc;
char	**argv;
d260 1
a260 3
cm_vrot( argc, argv )
int	argc;
char	**argv;
d269 1
a269 3
cm_orientation( argc, argv )
int	argc;
char	**argv;
d280 1
a280 3
cm_end( argc, argv )
int	argc;
char	**argv;
d296 1
a296 3
cm_tree( argc, argv )
int		argc;
CONST char	**argv;
d318 1
a318 3
cm_multiview( argc, argv )
int	argc;
char	**argv;
d350 1
a350 3
cm_anim( argc, argv )
int	argc;
char	**argv;
d365 1
a365 3
cm_clean( argc, argv )
int	argc;
char	**argv;
d384 1
a384 4
int
cm_closedb( argc, argv )
int	argc;
char	**argv;
d447 1
a447 3
cm_set( argc, argv )
int	argc;
char	**argv;
d469 1
a469 3
cm_ae( argc, argv )
int	argc;
char	**argv;
d482 1
a482 3
cm_opt( argc, argv )
int	argc;
char	**argv;
d578 1
d818 1
a818 1
				view_2init( &ap );
d1034 32
a1065 32
	"start", "frame number", "start a new frame",
		cm_start,	2, 2,
	"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2,
	"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4,
	"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5,
	"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17,
	"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5,
	"end", 	"", "end of frame setup, begin raytrace",
		cm_end,		1, 1,
	"multiview", "", "produce stock set of views",
		cm_multiview,	1, 1,
	"anim", 	"path type args", "specify articulation animation",
		cm_anim,	4, 999,
	"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_tree,	1, 999,
	"clean", "", "clean articulation from previous frame",
		cm_clean,	1, 1,
	"_closedb", "", "Close .g database, (for memory debugging)",
		cm_closedb,	1, 1,
	"set", 	"", "show or set parameters",
		cm_set,		1, 999,
	"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_ae,		3, 3,
	"opt", "-flags", "set flags, like on command line",
		cm_opt,		2, 999,
	(char *)0, (char *)0, (char *)0,
		0,		0, 0	/* END */
@


11.27.2.1
log
@rt_bot_minpieces is an int, not a float
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.27 2000/05/18 21:10:09 jra Exp $ (BRL)";
d457 1
a457 1
	{"%d",  1, "rt_bot_minpieces", byteoffset(rt_bot_minpieces),BU_STRUCTPARSE_FUNC_NULL },
@


11.27.2.2
log
@Added "ray_data_file" as a settable variable to get optional ray data output in rtg3
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.27.2.1 2000/08/24 13:34:38 jra Exp $ (BRL)";
a94 4
/***** variables shared with viewg3.c *****/
extern struct bu_vls	ray_data_file;	/* file name for ray data output */
/***** end variables shared with viewg3.c *****/

a457 1
	{"%S",  1, "ray_data_file", byteoffset(ray_data_file),BU_STRUCTPARSE_FUNC_NULL },
@


11.27.2.3
log
@Moved definition of ray_data_file from viewg3.c to do.c
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.27.2.2 2000/10/25 19:03:11 jra Exp $ (BRL)";
d96 1
a96 1
struct bu_vls	ray_data_file;	/* file name for ray data output */
@


11.27.2.4
log
@Mods to support CLINE radius addition
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.27.2.3 2000/10/26 12:48:52 jra Exp $ (BRL)";
a98 5
/***** variables shared with g_cline.c ******/
extern fastf_t rt_cline_radius;
/***** end variables shared with g_cline.c ******/


a461 1
	{"%f",  1, "rt_cline_radius", byteoffset(rt_cline_radius),BU_STRUCTPARSE_FUNC_NULL },
@


11.26
log
@
Added externally settable parameter rt_bot_minpieces
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.25 2000/02/12 02:08:17 mike Exp $ (BRL)";
d87 1
d454 1
@


11.25
log
@
Improved stats
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.24 2000/02/03 01:19:49 mike Exp $ (BRL)";
d421 3
d455 1
@


11.24
log
@
Sometimes, we use more than 2Gbytes of additional memory.
Change printout to use long.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.23 2000/01/11 21:58:53 mike Exp $ (BRL)";
d579 1
a579 1
		bu_log("%s: %8d nu, %8d cut, %8d box (%8d empty)\n",
d586 3
@


11.23
log
@
Made space partitioning info more descriptive, and printed right
away after prep, rather than waiting until after raytracing is done.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.22 1999/12/30 05:49:28 butler Exp $ (BRL)";
d540 2
a541 2
		bu_log("Additional dynamic memory used=%d. bytes\n",
			(char *)sbrk(0)-beginptr );
d574 2
a575 2
		bu_log("Additional dynamic memory used=%d. bytes\n",
			(char *)sbrk(0)-beginptr );
d882 3
a884 3
		bu_log("Additional dynamic memory used=%d. bytes\n",
			(char *)sbrk(0)-beginptr );
			beginptr = (char *) sbrk(0);
@


11.22
log
@additions for -v flag to rt
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.21 1999/12/23 05:59:00 mike Exp $ (BRL)";
d578 9
a891 3
		bu_log("%8d empty boxnodes (%s)\n", rtip->nempty_cells,
		       rtip->rti_space_partition == RT_PART_NUGRID ? "NUGrid" :
		       "NUBSPT" );
@


11.21
log
@
struct region is now a bu_list
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.20 1999/07/02 22:19:45 mike Exp $ (BRL)";
d323 2
a324 1
	bu_log("GETTREE: %s\n", bu_vls_addr(&times) );
d533 3
a535 1
	bu_log("GETTREE: %s\n", bu_vls_addr(&times));
d539 3
a541 2
	bu_log("Additional dynamic memory used=%d. bytes\n",
		(char *)sbrk(0)-beginptr );
d568 2
a569 1
		bu_log( "PREP: %s\n", bu_vls_addr(&times) );
d573 3
a575 2
	bu_log("Additional dynamic memory used=%d. bytes\n",
		(char *)sbrk(0)-beginptr );
d601 3
a603 2
	bu_log( "\n...................Frame %5d...................\n",
		framenumber);
d608 3
a610 2
	bu_log("Tree: %d solids in %d regions\n",
		rtip->nsolids, rtip->nregions );
d615 5
a619 4
	bu_log("Model: X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
		rtip->mdl_min[X], rtip->mdl_max[X],
		rtip->mdl_min[Y], rtip->mdl_max[Y],
		rtip->mdl_min[Z], rtip->mdl_max[Z] );
d630 5
a634 3
	bu_log(
		"View: %g azimuth, %g elevation off of front view\n",
		azimuth, elevation);
d636 4
a639 3
	bu_log("Orientation: %g, %g, %g, %g\n", V4ARGS(quat) );
	bu_log("Eye_pos: %g, %g, %g\n", V3ARGS(eye_model) );
	bu_log("Size: %gmm\n", viewsize);
d646 22
a667 21
	{
		mat_t	rotscale, xlate;
		mat_t	new;
		quat_t	newquat;

		bn_mat_print("model2view", model2view);
		quat_quat2mat( rotscale, quat );
		rotscale[15] = 0.5 * viewsize;
		bn_mat_idn( xlate );
		MAT_DELTAS( xlate, -eye_model[X], -eye_model[Y], -eye_model[Z] );
		bn_mat_mul( new, rotscale, xlate );
		bn_mat_print("reconstructed m2v", new);
		quat_mat2quat( newquat, new );
		HPRINT( "reconstructed orientation:", newquat );
	}
#endif
	bu_log("Grid: (%g, %g) mm, (%d, %d) pixels\n",
		cell_width, cell_height,
		width, height );
	bu_log("Beam: radius=%g mm, divergence=%g mm/1mm\n",
		ap.a_rbeam, ap.a_diverge );
d793 3
a795 1
		bu_log("Output file is '%s'\n", framename);
d813 2
a814 1
	bu_log("\n");
d868 2
a869 1
	bu_log("SHOT: %s\n", bu_vls_addr( &times ) );
d872 32
a903 30
	bu_log("Additional dynamic memory used=%d. bytes\n",
		(char *)sbrk(0)-beginptr );
		beginptr = (char *) sbrk(0);
#endif
	bu_log("%ld solid/ray intersections: %ld hits + %ld miss\n",
		rtip->nshots, rtip->nhits, rtip->nmiss );
	bu_log("pruned %.1f%%:  %ld model RPP, %ld dups skipped, %ld solid RPP\n",
		rtip->nshots>0?((double)rtip->nhits*100.0)/rtip->nshots:100.0,
		rtip->nmiss_model, rtip->ndup, rtip->nmiss_solid );
	bu_log("%8d empty boxnodes (%s)\n", rtip->nempty_cells,
	       rtip->rti_space_partition == RT_PART_NUGRID ? "NUGrid" :
	       "NUBSPT" );
	bu_log(
		"Frame %5d: %8d pixels in %10.2f sec = %10.2f pixels/sec\n",
		framenumber,
		width*height, nutime, ((double)(width*height))/nutime );
	bu_log(
		"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/sec (RTFM)\n",
		framenumber,
		rtip->rti_nrays, nutime, ((double)(rtip->rti_nrays))/nutime );
	bu_log(
		"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/CPU_sec\n",
		framenumber,
		rtip->rti_nrays, utime, ((double)(rtip->rti_nrays))/utime );
	bu_log(
		"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/sec (wallclock)\n",
		framenumber,
		rtip->rti_nrays,
		wallclock, ((double)(rtip->rti_nrays))/wallclock );

@


11.20
log
@
Removed dependence on compat4.h
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.19 1999/05/28 01:11:01 mike Exp $ (BRL)";
d293 1
a293 1
	if( rtip->HeadRegion == REGION_NULL )  {
d345 1
a345 1
	if( rtip->HeadRegion == REGION_NULL )  {
@


11.19
log
@
sed4
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.18 1998/09/23 19:38:57 jra Exp $ (BRL)";
d447 4
a450 4
	{"%d",	1, "width",	byteoffset(width),		FUNC_NULL },
	{"%d",	1, "height",	byteoffset(height),		FUNC_NULL },
	{"%f",	1, "perspective", byteoffset(rt_perspective),	FUNC_NULL },
	{"%f",	1, "angle",	byteoffset(rt_perspective),	FUNC_NULL },
d453 1
a453 1
	{"",	0, (char *)0,	0,				FUNC_NULL }
d620 1
a620 1
	ae_vec( &azimuth, &elevation, temp );
@


11.18
log
@Modified definition of byteoffset() using definitions of _MIPS_SIM.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.17 1998/09/22 00:23:40 mike Exp $ (BRL)";
d133 1
a133 1
	rt_log("Interpreting command stream in old format\n");
d208 1
a208 1
		rt_free( buf, "rt_read_cmd command buffer (skipping frames)" );
d259 1
a259 1
	mat_lookat( Viewrotscale, dir, yflip );
d310 1
a310 1
	struct rt_vls	times;
d316 1
a316 1
	rt_vls_init( &times );
d320 1
a320 1
		rt_log("rt_gettrees(%s) FAILED\n", argv[0]);
d323 2
a324 2
	rt_log("GETTREE: %s\n", rt_vls_addr(&times) );
	rt_vls_free( &times );
d368 1
a368 1
		rt_log("cm_anim:  %s %s failed\n", argv[1], argv[2]);
d389 1
a389 1
		rt_prmem( "After cm_clean" );
d411 1
a411 1
	rt_prmem( "After _closedb" );
d451 1
a451 1
	{"i", byteoffset(view_parse[0]),"View_Module-Specific Parameters", 0, FUNC_NULL },
d465 1
a465 1
	struct rt_vls	str;
d472 2
a473 2
	rt_vls_init( &str );
	rt_vls_from_argv( &str, argc-1, argv+1 );
d475 1
a475 1
		rt_vls_free( &str );
d478 1
a478 1
	rt_vls_free( &str );
d519 1
a519 1
	struct rt_vls	times;
d522 1
a522 1
		rt_log("rtip=x%x, rti_magic=x%x s/b x%x\n", rtip,
d527 1
a527 1
	rt_vls_init( &times );
d530 1
a530 1
		rt_log("rt_gettrees(%s) FAILED\n", objtab[0]);
d532 2
a533 2
	rt_log("GETTREE: %s\n", rt_vls_addr(&times));
	rt_vls_free( &times );
d536 1
a536 1
	rt_log("Additional dynamic memory used=%d. bytes\n",
d551 1
a551 1
	struct rt_vls	times;
d559 1
a559 1
		rt_vls_init( &times );
d564 2
a565 2
		rt_log( "PREP: %s\n", rt_vls_addr(&times) );
		rt_vls_free( &times );
d568 1
a568 1
	rt_log("Additional dynamic memory used=%d. bytes\n",
d584 1
a584 1
	struct rt_vls	times;
d595 1
a595 1
	rt_log( "\n...................Frame %5d...................\n",
d601 1
a601 1
	rt_log("Tree: %d solids in %d regions\n",
d604 1
a604 1
		rt_log("rt ERROR: No solids\n");
d607 1
a607 1
	rt_log("Model: X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
d621 1
a621 1
	rt_log(
d625 3
a627 3
	rt_log("Orientation: %g, %g, %g, %g\n", V4ARGS(quat) );
	rt_log("Eye_pos: %g, %g, %g\n", V3ARGS(eye_model) );
	rt_log("Size: %gmm\n", viewsize);
d639 1
a639 1
		mat_print("model2view", model2view);
d642 1
a642 1
		mat_idn( xlate );
d644 2
a645 2
		mat_mul( new, rotscale, xlate );
		mat_print("reconstructed m2v", new);
d650 1
a650 1
	rt_log("Grid: (%g, %g) mm, (%d, %d) pixels\n",
d653 1
a653 1
	rt_log("Beam: radius=%g mm, divergence=%g mm/1mm\n",
d669 1
a669 1
		rt_log("only pixel %d %d\n", xx, yy);
d683 1
a683 1
		rt_log("ending pixel %d %d\n", xx, yy);
d702 2
a703 2
	if( (lim = rt_cpuget()) > 0 )  {
		rt_cpuset( lim + npix / MINRATE + 100 );
d712 1
a712 1
			rt_pri_set(10);
d714 1
a714 1
			rt_pri_set(14);
d780 1
a780 1
		rt_log("Output file is '%s'\n", framename);
d798 1
a798 1
	rt_log("\n");
d820 1
a820 1
	rt_vls_init( &times );
d852 2
a853 2
	rt_log("SHOT: %s\n", rt_vls_addr( &times ) );
	rt_vls_free( &times );
d855 1
a855 1
	rt_log("Additional dynamic memory used=%d. bytes\n",
d859 1
a859 1
	rt_log("%ld solid/ray intersections: %ld hits + %ld miss\n",
d861 1
a861 1
	rt_log("pruned %.1f%%:  %ld model RPP, %ld dups skipped, %ld solid RPP\n",
d864 1
a864 1
	rt_log("%8d empty boxnodes (%s)\n", rtip->nempty_cells,
d867 1
a867 1
	rt_log(
d871 1
a871 1
	rt_log(
d875 1
a875 1
	rt_log(
d879 1
a879 1
	rt_log(
d906 1
a906 1
		rt_log( "%s\n", message);
d920 1
a920 1
	rt_log("\n");
d964 2
a965 2
	mat_idn( Viewrotscale );
	mat_angles( Viewrotscale, 270.0+elev, 0.0, 270.0-azim );
d968 1
a968 1
	mat_idn( toEye );
d985 2
a986 2
	mat_mul( model2view, Viewrotscale, toEye );
	mat_inv( view2model, model2view );
@


11.17
log
@Doesn't need material.h
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/do.c,v 11.16 1997/12/31 09:23:14 mike Exp $ (BRL)";
d433 1
a433 1
#  if IRIX > 5
@


11.16
log
@Attempted to match format to LONG arguments
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.15 1997/07/07 13:12:07 gdurf Exp mike $ (BRL)";
a37 1
#include "./material.h"
@


11.15
log
@Added new accounting statistics
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.14 1997/05/22 00:57:32 mike Exp gdurf $ (BRL)";
d1009 1
a1009 1
		fprintf(stderr,"seg       len=%10d get=%10d free=%10d\n",
d1011 1
a1011 1
		fprintf(stderr,"partition len=%10d get=%10d free=%10d\n",
d1014 1
a1014 1
		fprintf(stderr,"bitv_elem len=%10d get=%10d free=%10d\n",
d1017 1
a1017 1
		fprintf(stderr,"boolstack len=%10d\n",
@


11.14
log
@Less ambiguous casting
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.13 1997/01/02 20:59:37 jra Exp mike $ (BRL)";
d864 4
a867 1
		rtip->nmiss_model, rtip->nmiss_tree, rtip->nmiss_solid );
@


11.13
log
@Minor mod to make compiler happy.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.12 1996/08/31 08:46:01 butler Exp jra $ (BRL)";
d868 1
a868 1
		width*height, nutime, (double)(width*height)/nutime );
d872 1
a872 1
		rtip->rti_nrays, nutime, (double)(rtip->rti_nrays)/nutime );
d876 1
a876 1
		rtip->rti_nrays, utime, (double)(rtip->rti_nrays)/utime );
d881 1
a881 1
		wallclock, (double)(rtip->rti_nrays)/wallclock );
@


11.12
log
@bu_struct_print
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.11 1996/08/31 08:21:34 butler Exp butler $ (BRL)";
d414 2
@


11.11
log
@struct_parse
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.10 1996/08/31 04:35:10 mike Exp butler $ (BRL)";
d467 1
a467 1
		bu_structprint( "Generic and Application-Specific Parameter Values",
@


11.10
log
@Added _closedb command, to help check for memory leaks.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.9 1996/08/29 23:36:10 butler Exp mike $ (BRL)";
d473 1
a473 1
	if( bu_structparse( &str, set_parse, (char *)0 ) < 0 )  {
@


11.9
log
@structparse moved to libbu
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.8 1996/08/28 07:23:37 mike Exp butler $ (BRL)";
d390 1
a390 1
		rt_prmem( "After rt_clean" );
d394 22
d1044 2
@


11.8
log
@libbu has different debug bits.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.7 1996/08/28 03:38:13 mike Exp mike $ (BRL)";
d395 1
a395 1
extern struct structparse view_parse[];
d399 1
a399 1
 *  By setting the "base address" to zero in the rt_structparse call,
d422 1
a422 1
struct structparse set_parse[] = {
d445 1
a445 1
		rt_structprint( "Generic and Application-Specific Parameter Values",
d451 1
a451 1
	if( rt_structparse( &str, set_parse, (char *)0 ) < 0 )  {
@


11.7
log
@Some statistics have gone away.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.6 1996/08/27 03:17:03 mike Exp mike $ (BRL)";
d765 1
a765 1
		rt_g.debug |= (DEBUG_MEM|DEBUG_MEM_FULL);
d808 1
a808 1
		rt_g.debug &= ~DEBUG_MEM;
@


11.6
log
@Parallel library no longer collects statistics
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.5 1996/07/22 20:34:18 jra Exp mike $ (BRL)";
d986 1
d989 1
@


11.5
log
@Minor Mods for IRIX 6.2
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.4 1995/11/07 14:27:33 adam Exp jra $ (BRL)";
a510 4
	if(rdebug&RDEBUG_STATS)  {
		/* Print additional statistics */
		rt_pr_lock_stats();
	}
a890 1
		rt_pr_lock_stats();
@


11.4
log
@Matching malloc and free messages -- rt_read_cmd command buffer
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.3 1995/10/30 23:52:01 adam Exp adam $ (BRL)";
d411 1
a411 1
#	define byteoffset(_i)	((long)((char *)&(_i)))
@


11.3
log
@Fixed cm_ae. It now waits for cm_end to execute before doing the do_ae.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.2 1995/03/18 02:13:17 mike Exp adam $ (BRL)";
d209 1
a209 1
		rt_free( buf, "cmd buf (skiping frames)" );
@


11.2
log
@Called rt_prep_parallel().
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 11.1 95/01/04 10:00:37 mike Rel4_4 Locker: mike $ (BRL)";
d466 5
a470 1
	do_ae( atof(argv[1]), atof(argv[2]) );
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.17 94/12/30 01:01:45 mike Exp $ (BRL)";
d538 1
a538 1
		rt_prep(rtip);
@


10.17
log
@DEC Alpha
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.16 94/12/22 00:27:05 mike Exp Locker: mike $ (BRL)";
@


10.16
log
@From: Ingbert Graf <graf@@conmuc.de.convex.com>
HP port
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.15 94/12/21 14:44:31 stay Exp Locker: mike $ (BRL)";
d423 1
d429 1
@


10.15
log
@fixed cast for sbrk to (char *)
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.14 94/12/01 20:45:53 mike Exp Locker: stay $ (BRL)";
d413 1
a413 1
#    if sgi || __convexc__ || ultrix
@


10.14
log
@SunOS 4 warning.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.13 94/11/24 02:56:07 mike Exp Locker: mike $ (BRL)";
d513 1
a513 1
	beginptr = sbrk(0);
d545 1
a545 1
	beginptr = sbrk(0);
d832 1
a832 1
		beginptr = sbrk(0);
@


10.13
log
@sbrk() now returns (void *) -- need to cast it to (char *) to do subtraction.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.12 94/11/19 01:28:51 mike Exp Locker: mike $ (BRL)";
d427 1
a427 1
	{"i", byteoffset(view_parse),"View_Module-Specific Parameters", 0, FUNC_NULL },
@


10.12
log
@Added ULTRIX flag, per Bill Laut bug #195
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.11 94/11/09 15:13:53 jra Exp Locker: mike $ (BRL)";
d512 1
a512 1
		sbrk(0)-beginptr );
d544 1
a544 1
		sbrk(0)-beginptr );
d831 1
a831 1
		sbrk(0)-beginptr );
@


10.11
log
@Fixed -i option.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.10 94/11/05 03:25:36 mike Exp $ (BRL)";
d413 1
a413 1
#    if sgi || __convexc__
@


10.10
log
@Ugly Irix 6 hack.  Still kicks up warnings.  May work.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.9 94/11/05 02:44:10 mike Exp Locker: mike $ (BRL)";
d783 2
a784 2
		for( incr_level = 0; incr_level < incr_nlevel; incr_level++ )  {
			if( incr_level > 0 )
a786 1
			view_end( &ap );
@


10.9
log
@Irix 6 unused vars
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.8 94/10/31 22:08:16 mike Exp Locker: mike $ (BRL)";
d410 3
d420 1
d427 1
a427 1
	{"i", (int)view_parse,"View_Module-Specific Parameters", 0, FUNC_NULL },
@


10.8
log
@Changed over to using rt_vls version of timer routine rt_get_timer(),
so that the time data is no longer truncated at 132 characters.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.7 94/09/30 16:01:42 mike Exp Locker: mike $ (BRL)";
a311 1
	register int	i;
a486 1
	register int	i;
@


10.7
log
@Modified to use new timer interface that gives RT VLS.
Also modified to format up timing results in more useful format,
calling out rays/CPU_sec and rays/wallclock_sec separately.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.6 94/08/22 19:23:39 gdurf Exp Locker: mike $ (BRL)";
d311 2
a312 2
	char outbuf[132];
	register int i;
d318 2
d323 4
a326 2
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	rt_log("GETTREE: %s\n", outbuf);
d487 2
a488 2
	char outbuf[132];
	register int i;
d496 1
d500 3
a502 2
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	rt_log("GETTREE: %s\n", outbuf);
d524 1
a524 1
	char	outbuf[132];
d532 1
d536 3
a538 2
		(void)rt_read_timer( outbuf, sizeof(outbuf) );
		rt_log( "PREP: %s\n", outbuf );
@


10.6
log
@Factored ifdefs
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.5 1994/08/11 00:22:51 gdurf Exp gdurf $ (BRL)";
d549 1
a549 1
	char outbuf[132];
d552 3
a554 1
	static double utime;
d786 2
a787 1
	utime = rt_read_timer( outbuf, sizeof(outbuf) );
d810 2
a811 2
		utime /= npsw;			/* compensate */
	}
d813 1
d818 2
a819 1
	rt_log("SHOT: %s\n", outbuf );
d833 1
a833 1
		width*height, utime, (double)(width*height)/utime );
d837 4
d842 5
@


10.5
log
@name change
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.4 1994/08/11 00:20:55 gdurf Exp gdurf $ (BRL)";
a40 4

#ifdef HAVE_SBRK
extern char	*sbrk();
#endif
@


10.4
log
@Factored ifdefs
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.3 1993/03/24 03:18:35 phil Exp gdurf $ (BRL)";
d42 1
a42 1
#ifdef HAVE_UNIX_IO
d506 1
a506 1
#ifdef HAVE_UNIX_IO
d536 1
a536 1
#ifdef HAVE_UNIX_IO
d819 1
a819 1
#ifdef HAVE_UNIX_IO
@


10.3
log
@cm_tree was incorrectly passing "tree" as arg[0] to rt_gettrees()
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.2 1992/08/25 23:05:17 mike Exp phil $ (BRL)";
d23 1
a23 1
#include "machine.h"	/* comes before looking at __unix */
d25 4
a28 1
#if defined(unix) || defined(__unix)
d33 1
a33 10
#ifdef HEP
# include <synch.h>
# undef stderr
# define stderr stdout
# define PARALLEL 1
#endif

#include <stdio.h>
#include <ctype.h>
#include <math.h>
d42 1
d44 1
d506 1
d510 1
d536 1
d540 1
d709 1
a709 1
#if defined(unix) || defined(__unix)
d819 1
d823 1
@


10.2
log
@Added "set perspective", for compat with MGED
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 10.1 91/10/12 06:41:42 mike Rel4_0 Locker: mike $ (BRL)";
d327 1
a327 1
	if( rt_gettrees(rtip, argc, argv, npsw) < 0 )
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.44 91/10/01 02:47:34 butler Exp $ (BRL)";
d426 1
@


9.44
log
@added the convex to the ifdef on line 415
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.43 91/08/30 23:11:20 mike Exp Locker: butler $ (BRL)";
@


9.43
log
@Need externs.h
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.42 91/08/30 02:47:46 mike Exp $ (BRL)";
d415 1
a415 1
#    if sgi
@


9.42
log
@must include machine.h before looking at __unix symbol
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.41 91/08/29 22:37:22 mike Exp $ (BRL)";
d43 1
@


9.41
log
@ANSI lint, for Stardent
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.40 91/07/10 02:17:29 mike Exp $ (BRL)";
d23 2
a39 1
#include "machine.h"
@


9.40
log
@Added debugging code to reconstruct the orientation
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.39 91/07/06 00:38:40 mike Exp $ (BRL)";
d313 2
a314 2
int	argc;
char	**argv;
d498 1
a498 1
	if( rt_gettrees(rtip, nobjs, objtab, npsw) < 0 )
@


9.39
log
@unix --> __unix in ANSI
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.38 91/07/06 00:35:07 mike Exp $ (BRL)";
d601 1
d610 2
@


9.38
log
@ANSI structure initialization
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.37 91/07/05 22:15:33 mike Exp $ (BRL)";
d23 1
a23 1
#ifdef unix
d703 1
a703 1
#ifdef unix
@


9.37
log
@Added more error checking & better messages to do_ae().
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.36 91/07/01 03:38:44 mike Exp $ (BRL)";
d422 5
a426 5
	"%d",	1, "width",	byteoffset(width),		FUNC_NULL,
	"%d",	1, "height",	byteoffset(height),		FUNC_NULL,
	"%f",	1, "angle",	byteoffset(rt_perspective),	FUNC_NULL,
	"i", (int)view_parse,"View_Module-Specific Parameters", 0, FUNC_NULL,
	"",	0, (char *)0,	0,				FUNC_NULL
@


9.36
log
@Added extra statistics printing, now that we have a parallel treewalker.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.35 91/06/30 22:08:17 mike Exp $ (BRL)";
d891 2
d894 1
a894 1
		rt_bomb("do_ae called before rt_gettree");
@


9.35
log
@Eliminated needless reference to rti_headsolid
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.34 91/06/30 18:31:52 mike Exp $ (BRL)";
d502 4
@


9.34
log
@Parallel prepping now works.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.33 91/06/13 07:48:43 mike Exp $ (BRL)";
d563 1
a563 1
	if( RT_LIST_IS_EMPTY( &rtip->rti_headsolid ) )  {
@


9.33
log
@byteoffset() macro variations
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.32 91/03/01 16:15:13 mike Exp $ (BRL)";
a323 1
#define npsw 1		/* XXXXXXXXX Temp. disable parallel prep, it may be buggy XXXXX -M */
a506 1
#undef npsw 		/* XXXXXXXXX end Temp. disable parallel prep, it may be buggy XXXXX -M */
@


9.32
log
@Added "orientation" command to allow setting of the view direction
from a 4-tuple quaturnion.
This can be used interchangably with the "viewrot" command,
which gives the full 4x4 matrix.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.31 91/03/01 15:51:34 mike Exp $ (BRL)";
d412 1
a412 1
#	define byteoffset(_i)	(((int)&(_i)))
d414 5
d420 1
@


9.31
log
@Added two more lines to the RT log messages, so that the model2view
matrix can be precisely reconstructed.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.30 91/02/28 15:46:43 mike Exp $ (BRL)";
a269 1

d281 13
d970 2
@


9.30
log
@Defer handling of -b (only pixel) command until do_frame(),
so that image width is known.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.29 91/02/20 00:53:19 mike Exp $ (BRL)";
d537 1
d568 3
d572 19
@


9.29
log
@Eliminated env_region.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.28 91/02/20 00:50:21 mike Exp $ (BRL)";
d81 2
d574 1
d578 27
@


9.28
log
@Added new view-module interface called view_setup() which is used
for initializing material properties, lights, etc.
It compliments view_cleanup(), and finally removed knowledge of
the view.c materials (and all the shaders) from the RT "top half".
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.27 91/02/17 20:15:40 mike Exp $ (BRL)";
a97 4

/***** variables shared with text.c *****/
struct region	env_region;		/* environment map region */
/***** end variables shared with text.c *****/
@


9.27
log
@Check return code from rt_structparse()
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.26 91/01/05 03:08:59 mike Exp $ (BRL)";
a54 1
extern int	using_mlib;		/* !0 = material routines used */
d378 2
a379 1
	register struct region	*regp;
a380 9
	/* The linkage here needs to be much better for things
	 * like rtrad, etc. XXXX
	 */
	for( regp=ap.a_rt_i->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
		mlib_free( regp );
	}
	if( env_region.reg_mfuncs )  {
		mlib_free( &env_region );
	}
d382 1
a382 1
	view_cleanup();
a502 1
	register struct region *regp;
d505 1
d507 2
a508 37

		/*
		 *  Initialize the material library for all regions.
		 *  As this may result in some regions being dropped,
		 *  (eg, light solids that become "implicit" -- non drawn),
		 *  this must be done before allowing the library to prep
		 *  itself.  This is a slight layering violation;  later it
		 *  may be clear how to repackage this operation.
		 */
		for( regp=rtip->HeadRegion; regp != REGION_NULL; )  {
			if(using_mlib) switch( mlib_setup( regp ) )  {
			case -1:
			default:
				rt_log("mlib_setup failure on %s\n", regp->reg_name);
				break;
			case 0:
				if(rdebug&RDEBUG_MATERIAL)
					rt_log("mlib_setup: drop region %s\n", regp->reg_name);
				{
					struct region *r = regp->reg_forw;
					/* zap reg_udata? beware of light structs */
					rt_del_regtree( rtip, regp );
					regp = r;
					continue;
				}
			case 1:
				/* Full success */
				if( rdebug&RDEBUG_MATERIAL &&
				    ((struct mfuncs *)(regp->reg_mfuncs))->mf_print )  {
					((struct mfuncs *)(regp->reg_mfuncs))->
						mf_print( regp, regp->reg_udata );
				}
				/* Perhaps this should be a function? */
				break;
			}
			regp = regp->reg_forw;
		}
@


9.26
log
@Converted to new format for fmt entry in structparse
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.25 90/12/14 22:21:22 mike Exp $ (BRL)";
d441 4
a444 1
	rt_structparse( &str, set_parse, (char *)0 );
@


9.25
log
@Fixed table declaration
Added info on storage breakdown between GETTREE & PREP (cut).
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/do.c,v 9.24 90/12/12 08:43:24 butler Exp $ (BRL)";
d419 2
a420 2
	"indir",(int)view_parse,"View_Module-Specific Parameters", 0, FUNC_NULL,
	(char *)0,0,(char *)0,	0,				FUNC_NULL
@


9.24
log
@added count entry in structparse table declaration,
moved structparse indirect address from sp_offset to sp_count
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.23 90/12/10 10:48:41 butler Exp $ (BRL)";
d420 1
a420 1
	(char *)0,(char *)0,	0,				FUNC_NULL
d493 4
@


9.23
log
@converted structparse to struct_desc
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.22 90/12/08 07:53:58 mike Exp $ (BRL)";
a22 11
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./material.h"
#include "./rdebug.h"
#include "../librt/debug.h"

d35 11
d398 1
a398 1
extern struct struct_desc view_parse[];
d415 6
a420 6
struct struct_desc set_parse[] = {
	"%d",	"width",	byteoffset(width),		1, FUNC_NULL,
	"%d",	"height",	byteoffset(height),		1, FUNC_NULL,
	"%f",	"angle",	byteoffset(rt_perspective),	1, FUNC_NULL,
	"indir", "View_Module-Specific Parameters", (int)view_parse, 1, FUNC_NULL,
	(char *)0,(char *)0,	0,				0, FUNC_NULL
@


9.22
log
@Changed to using vls strings
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.21 90/11/22 07:16:03 mike Exp $ (BRL)";
d398 1
a398 1
extern struct structparse view_parse[];
d415 6
a420 6
struct structparse set_parse[] = {
	"%d",	"width",	byteoffset(width),		FUNC_NULL,
	"%d",	"height",	byteoffset(height),		FUNC_NULL,
	"%f",	"angle",	byteoffset(rt_perspective),	FUNC_NULL,
	"indir", "View_Module-Specific Parameters", (int)view_parse, FUNC_NULL,
	(char *)0,(char *)0,	0,				FUNC_NULL
@


9.21
log
@Infitesimal efficiency hack.  Neatness, really.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.20 90/11/21 06:32:08 mike Exp $ (BRL)";
d432 2
d439 4
a442 5
	while( argc > 1 ) {
		rt_structparse( argv[1], set_parse, (char *)0 );
		argc--;
		argv++;
	}
@


9.20
log
@Changed various fprintf(stderr...) calls to rt_log().
Keeps RTSRV from blathering, among other things.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.19 90/11/14 15:42:56 mike Exp $ (BRL)";
a886 1
	VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
d888 1
@


9.19
log
@As part of "clean" command, call "view_cleanup()", to allow
viewing module the opportunity to clean up things like implicit
light sources, etc.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.18 90/11/11 04:52:19 mike Exp $ (BRL)";
d318 1
a318 1
		fprintf(stderr,"rt_gettrees(%s) FAILED\n", argv[0]);
d320 1
a320 1
	fprintf(stderr,"GETTREE: %s\n", outbuf);
d489 1
a489 1
		fprintf(stderr,"rt_gettrees(%s) FAILED\n", objtab[0]);
d491 1
a491 1
	fprintf(stderr,"GETTREE: %s\n", outbuf);
d551 1
a551 1
		fprintf(stderr, "PREP: %s\n", outbuf );
d553 1
a553 1
	fprintf(stderr,"Additional dynamic memory used=%d. bytes\n",
d576 1
a576 1
	fprintf(stderr, "\n...................Frame %5d...................\n",
d582 1
a582 1
	fprintf(stderr,"Tree: %d solids in %d regions\n",
d585 1
a585 1
		fprintf(stderr,"rt ERROR: No solids\n");
d588 1
a588 1
	fprintf(stderr,"Model: X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
d602 1
a602 1
	fprintf(stderr,
d605 2
a606 2
	fprintf(stderr,"Size: %gmm\n", viewsize);
	fprintf(stderr,"Grid: (%g, %g) mm, (%d, %d) pixels\n",
d609 1
a609 1
	fprintf(stderr,"Beam: radius=%g mm, divergence=%g mm/1mm\n",
d708 1
a708 1
		fprintf(stderr,"Output file is '%s'\n", framename);
d726 1
a726 1
	fprintf(stderr,"\n");
d779 2
a780 2
	fprintf(stderr,"SHOT: %s\n", outbuf );
	fprintf(stderr,"Additional dynamic memory used=%d. bytes\n",
d783 1
a783 1
	fprintf(stderr,"%ld solid/ray intersections: %ld hits + %ld miss\n",
d785 1
a785 1
	fprintf(stderr,"pruned %.1f%%:  %ld model RPP, %ld dups skipped, %ld solid RPP\n",
d788 1
a788 1
	fprintf(stderr,
d792 1
a792 1
	fprintf(stderr,
d818 1
a818 1
		fprintf(stderr, "%s\n", message);
d833 1
a833 1
	fprintf(stderr,"\n");
@


9.18
log
@Moved anim parsing to librt
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.17 90/11/04 09:01:05 mike Exp $ (BRL)";
d391 1
@


9.17
log
@Added -K flag to indicate what frame in an animation to "kill" ourselves
at.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.16 90/11/02 06:29:01 mike Exp $ (BRL)";
a361 5
	struct rt_i *rtip = ap.a_rt_i;
	struct animate *anp;
	struct directory **dir;
	int i;
	int	at_root = 0;
d363 3
a365 33
	if( argv[1][0] == '/' )
		at_root = 1;
	if( (i = rt_plookup( rtip, &dir, argv[1], LOOKUP_NOISY )) <= 0 )
		return(-1);		/* error */
	if( i > 1 )
		at_root = 0;

	GETSTRUCT( anp, animate );
	anp->an_path = dir;
	anp->an_pathlen = i;

	if( strcmp( argv[2], "matrix" ) == 0 )  {
		anp->an_type = AN_MATRIX;
		if( strcmp( argv[3], "rstack" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RSTACK;
		else if( strcmp( argv[3], "rarc" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RARC;
		else if( strcmp( argv[3], "lmul" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_LMUL;
		else if( strcmp( argv[3], "rmul" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RMUL;
		else if( strcmp( argv[3], "rboth" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RBOTH;
		else  {
			fprintf(stderr,"cm_anim:  Matrix op %s unknown\n",
				argv[3]);
			goto bad;
		}
		for( i=0; i<16; i++ )
			anp->an_u.anu_m.anm_mat[i] = atof( argv[i+4] );
	} else {
		fprintf(stderr,"cm_anim:  type %s unknown\n", argv[2]);
		goto bad;
a366 4
	if( db_add_anim( rtip->rti_dbip, anp, at_root ) < 0 )  {
		fprintf(stderr,"cm_anim:  %s %s failed\n", argv[1], argv[2]);
		goto bad;
	}
a367 4
bad:
	rt_free( (char *)dir, "directory []");
	rt_free( (char *)anp, "animate");
	return(-1);		/* BAD */
@


9.16
log
@Temporarily disable parallel prepping, as it either has a bug,
or excites a bug on the SGI.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.15 90/11/01 11:17:19 mike Exp $ (BRL)";
d89 1
d149 2
d201 2
d219 2
@


9.15
log
@Don't dereference NULL pointers
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.14 90/10/07 21:39:11 mike Exp $ (BRL)";
d308 1
d528 1
@


9.14
log
@struct soltab changed to use rt_list structures.
HeadSolid became rti_headsolid
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.13 90/07/31 01:32:45 mike Exp $ (BRL)";
d568 2
a569 1
				if(rdebug&RDEBUG_MATERIAL)
d572 1
@


9.13
log
@Oops
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.12 90/07/31 01:09:55 mike Exp $ (BRL)";
d615 1
a615 1
	if( rtip->HeadSolid == SOLTAB_NULL )  {
@


9.12
log
@Enhanced printing
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.11 90/07/31 01:03:54 mike Exp $ (BRL)";
d945 2
a946 2
		fprintf("---CPU %d:\n", i);
		if( res->re_magic != RESOURCE_MAGIC )
d948 2
@


9.11
log
@Improved debugging flags
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.10 90/06/01 00:13:40 mike Exp $ (BRL)";
d942 1
d945 4
a948 2
		fprintf(stderr,"cpu%d seg  len=%10d get=%10d free=%10d\n",
			i,
d950 1
a950 2
		fprintf(stderr,"cpu%d part len=%10d get=%10d free=%10d\n",
			i,
d952 1
a952 2
		fprintf(stderr,"cpu%d bitv len=%10d get=%10d free=%10d\n",
			i,
d954 2
@


9.10
log
@lint
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.9 90/05/30 13:32:41 mike Exp $ (BRL)";
d745 1
d747 1
a747 1
		rt_g.debug |= DEBUG_MEM;	/* Just for the tracing */
d788 1
d790 1
a790 1
		rt_g.debug &= ~DEBUG_MEM;	/* Stop until next frame */
@


9.9
log
@Added RTMEM_END
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/do.c,v 9.8 90/04/25 00:43:23 mike Exp $ (BRL)";
d394 1
a394 1
	if( db_add_anim( rtip, anp, at_root ) < 0 )  {
@


9.8
log
@Passed number of CPUs to use to rt_gettrees().
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 9.7 90/04/12 03:59:32 mike Locked $ (BRL)";
d426 1
a426 1
	if(rdebug&RDEBUG_RTMEM)
@


9.7
log
@Changed to use rt_gettrees(), which will better exploit parallelism
while prepping.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 9.6 90/02/08 02:22:53 mike Locked $ (BRL)";
d309 1
a309 1
	if( rt_gettrees(rtip, argc, argv) < 0 )
d522 1
a522 1
	if( rt_gettrees(rtip, nobjs, objtab) < 0 )
@


9.6
log
@Moved checkpoint-restart features into view.c
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 9.5 90/02/04 00:06:53 mike Locked $ (BRL)";
d309 2
a310 4
	for( i=1; i < argc; i++ )  {
		if( rt_gettree(rtip, argv[i]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[i]);
	}
d394 1
a394 1
	if( rt_add_anim( rtip, anp, at_root ) < 0 )  {
d522 2
a523 4
	for( i=0; i < nobjs; i++ )  {
		if( rt_gettree(rtip, objtab[i]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", objtab[i]);
	}
@


9.5
log
@Eliminated stray references to scanbuf.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 9.4 90/01/11 04:42:18 mike Locked $ (BRL)";
a51 1
extern int	hex_out;		/* Binary or Hex .pix output file */
d711 9
d725 6
a730 32
				register int pixoff, des_pos, fd;
				pixoff = sb.st_size / sizeof(RGBpixel);
				des_pos = pixoff * sizeof(RGBpixel);
				if( pix_start == 0 && pix_end > pixoff )  {
					fprintf(stderr, "Continuing with pixel %d (%d, %d) [size %d, want %d]\n",
						pixoff,
						pixoff % width,
						pixoff / width,
						sb.st_size,
						des_pos );
					pix_start = pixoff;
					/*
					 *  Append to existing UNIX file.
					 *  Ensure that positioning is precisely pixel aligned.
					 *  The file size is almost certainly
					 *  not an exact multiple of three bytes.
					 *  Use UNIX sys-calls here because SYSV
					 *  stdio & fseek() on append-mode files
					 *  don't seem to work right, and this
					 *  way is simpler anyway.
					 */
					if( (fd = open( framename, 2 )) < 0 ||
					    (outfp = fdopen( fd, "r+" )) == NULL )  {
						perror( framename );
						if( matflag )  return(0);	/* OK */
						return(-1);			/* Bad */
					}
					(void)fseek( outfp, (long)des_pos, 0);
					/*
					 *  view_2init() reads the file into
					 *  scanbuf, when needed by buffering.
					 */
d735 2
d746 2
a747 2
	/* initialize lighting */
	view_2init( &ap );
d842 5
a846 11
		if( hex_out )  {
			(void)DISPOSE( &status, "DN      ", dn,
				"TEXT    ", framename,
				"NOWAIT  " );
		} else {
			/* Binary out */
			(void)DISPOSE( &status, "DN      ", dn,
				"TEXT    ", framename,
				"NOWAIT  ",
				"DF      ", "BB      " );
		}
@


9.4
log
@ Changed lock_pr() to rt_pr_lock_stats().
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: /n/spark/m/cad/rt/RCS/do.c,v 9.3 90/01/11 03:10:03 mike Exp $ (BRL)";
a74 1
extern char	*scanbuf;		/* For optional output buffering */
@


9.3
log
@Changed end-of-frame statistics from conditional compilation
to RDEBUG_STATS selectable
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 9.2 89/12/30 03:06:37 mike Locked $ (BRL)";
d885 1
a885 1
		lock_pr();
@


9.2
log
@Removed some dubious code.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 9.1 89/05/19 05:58:50 mike Locked $ (BRL)";
d107 1
d883 5
a887 4
#ifdef STAT_PARALLEL
	lock_pr();
	res_pr();
#endif
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.21 89/04/30 20:39:18 mike Exp $ (BRL)";
d589 3
a591 17

	if( rt_g.rtg_parallel && resource[0].re_seg == SEG_NULL )  {
		register int x;
		/* 
		 *  Get dynamic memory to keep from having to call
		 *  malloc(), because the portability of doing sbrk()
		 *  sys-calls when running in parallel mode is unknown.
		 */
		for( x=0; x<npsw; x++ )  {
			rt_get_seg(&resource[x]);
			rt_get_pt(rtip, &resource[x]);
			rt_get_bitv(rtip, &resource[x]);
		}
		fprintf(stderr,"Additional dynamic memory used=%d. bytes\n",
			sbrk(0)-beginptr );
		beginptr = sbrk(0);
	}
@


8.21
log
@No longer depends on mathtab.h
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.20 89/04/14 06:02:17 mike Locked $ (BRL)";
@


8.20
log
@Moved az/el printing from do_ae() into do_frame().
Compute actual az/el from current viewing direction,
regardless of how specified.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.19 89/04/14 03:07:59 mike Locked $ (BRL)";
a30 1
#include "./mathtab.h"
@


8.19
log
@Comments on structparse improved.
indir structparse pointers moved back to sp_offset, from sp_hook;
see rcslog entry in librt/parse.c for full details.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.18 89/04/05 02:14:52 mike Locked $ (BRL)";
d625 1
d633 1
a633 1
	fprintf(stderr,"shooting at %d solids in %d regions\n",
d639 1
a639 1
	fprintf(stderr,"model X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
d649 8
d660 1
a660 1
	fprintf(stderr,"Beam radius=%g mm, divergence=%g mm/1mm\n",
a929 1

a945 3
	fprintf(stderr,
		"Viewing %g azimuth, %g elevation off of front view\n",
		azim, elev);
a963 2
	fprintf(stderr,"view size = %g\n", viewsize);

@


8.18
log
@This upgrade of the Cray hack is still WRONG.
The &-& initializer is illegal in STDC
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.17 89/04/04 05:01:55 mike Locked $ (BRL)";
d442 5
d448 1
a448 2
#if __STDC__ && CRAY
/*	Cray SCC bug prevents using correct expression here */
d457 1
a457 1
	"indir", "View_Module-Specific Parameters", 0, (void (*)())view_parse,
@


8.17
log
@Converted to new way of representing structure offsets.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.16 89/04/03 20:50:24 mike Locked $ (BRL)";
d443 6
d450 5
a454 5
	"%d",	"width",	(int)&width,		FUNC_NULL,
	"%d",	"height",	(int)&height,		FUNC_NULL,
	"%f",	"angle",	(int)&rt_perspective,	FUNC_NULL,
	"indir", "View Module",	(int)0,		(void (*)())view_parse,
	(char *)0,(char *)0,	(int)0,			FUNC_NULL
@


8.16
log
@Added support for -g cell_width and -G cell_height options,
which included rearranging some calculations, because
grid_setup() can now change the values of width and height.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.15 89/03/04 02:58:39 mike Locked $ (BRL)";
d444 5
a448 5
	"%d",	"width",	(stroff_t)&width,		FUNC_NULL,
	"%d",	"height",	(stroff_t)&height,		FUNC_NULL,
	"%f",	"angle",	(stroff_t)&rt_perspective,	FUNC_NULL,
	"indir", "View Module",	(stroff_t)view_parse,		FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,			FUNC_NULL
d462 1
a462 1
			set_parse, (stroff_t)0 );
d466 1
a466 1
		rt_structparse( argv[1], set_parse, (stroff_t)0 );
d508 6
@


8.15
log
@Added compenstation of results for parallel processors
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.14 89/02/27 00:08:58 mike Locked $ (BRL)";
d67 2
d613 14
d628 18
a645 1
	 *  Deal with CPU limits and priorities, where appropriate.
d671 4
a674 16
	do_prep( rtip );

	fprintf(stderr,"shooting at %d solids in %d regions\n",
		rtip->nsolids, rtip->nregions );
	if( rtip->HeadSolid == SOLTAB_NULL )  {
		fprintf(stderr,"rt ERROR: No solids\n");
		exit(3);
	}
	fprintf(stderr,"model X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
		rtip->mdl_min[X], rtip->mdl_max[X],
		rtip->mdl_min[Y], rtip->mdl_max[Y],
		rtip->mdl_min[Z], rtip->mdl_max[Z] );

	if(rdebug&RDEBUG_RTMEM)
		rt_g.debug |= DEBUG_MEM;	/* Just for the tracing */

a751 4
	grid_setup();
	fprintf(stderr,"Beam radius=%g mm, divergence=%g mm/1mm\n",
		ap.a_rbeam, ap.a_diverge );

d754 3
@


8.14
log
@#endif comments removed
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.13 89/02/10 22:53:28 mike Locked $ (BRL)";
d779 15
@


8.13
log
@A better way of telling the difference between old and new RT scripts.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.12 89/01/25 05:37:57 mike Locked $ (BRL)";
d727 1
a727 1
#endif CRAY_COS
d808 1
a808 1
#endif CRAY_COS
d834 1
a834 1
#endif CRAY_COS
d840 1
a840 1
#endif STAT_PARALLEL
@


8.12
log
@Added "opt" command.
Note that it does not necessarily handle side-effects.
(eg, giving -w after grid has been built).
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.11 89/01/25 04:14:44 mike Locked $ (BRL)";
d118 2
d121 17
@


8.11
log
@Moved rt_cmdtab to do.c
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.10 89/01/20 03:19:16 mike Locked $ (BRL)";
d464 13
d950 2
@


8.10
log
@Split do_prep() out of do_frame(), for the benefit of REMRT
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.9 89/01/09 06:07:16 mike Locked $ (BRL)";
d452 11
d907 33
@


8.9
log
@Moved env_region into do.c, sigh.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.8 89/01/09 05:43:32 mike Locked $ (BRL)";
d474 1
a474 1
 *			D O _ F R A M E
d476 1
a476 3
 *  Do all the actual work to run a frame.
 *
 *  Returns -1 on error, 0 if OK.
d478 3
a480 2
do_frame( framenumber )
int framenumber;
a481 4
	char outbuf[132];
	char framename[128];		/* File name to hold current frame */
	struct rt_i *rtip = ap.a_rt_i;
	static double utime;
d483 1
a483 2
	int	npix;			/* # of pixel values to be done */
	int	lim;
a484 30
	fprintf(stderr, "\n...................Frame %5d...................\n",
		framenumber);

	/*
	 *  Deal with CPU limits and priorities, where appropriate.
	 *  Because limits exist, they better be adequate.
	 *  We assume that the Cray can produce MINRATE pixels/sec
	 *  on images with extreme amounts of glass & mirrors.
	 */
#ifdef CRAY2
#define MINRATE	35
#else
#define MINRATE	65
#endif
	npix = width*height*(hypersample+1);
	if( (lim = rt_cpuget()) > 0 )  {
		rt_cpuset( lim + npix / MINRATE + 100 );
	}

	/*
	 *  If this image is unlikely to be for debugging,
	 *  be gentle to the machine.
	 */
	if( !interactive )  {
		if( npix > 256*256 )
			rt_pri_set(10);
		else if( npix > 512*512 )
			rt_pri_set(14);
	}

d546 50
@


8.8
log
@Added code to "clean" command to eliminate the environment map too.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.7 89/01/09 05:11:56 mike Locked $ (BRL)";
d100 4
a397 1
	extern struct region	env_region;
@


8.7
log
@Added support for "lookat_pt" command in animation scripts
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.6 89/01/02 18:25:52 mike Locked $ (BRL)";
d393 2
a394 1
	register struct region *regp;
d399 1
a399 1
	for( regp=ap.a_rt_i->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )
d401 4
@


8.6
log
@Changed from read_cmd() to rt_read_cmd()
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.5 88/12/27 16:34:07 mike Locked $ (BRL)";
d217 26
@


8.5
log
@Converted matparse --> structparse
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.4 88/12/15 03:32:27 mike Locked $ (BRL)";
d171 2
a172 2
	char ibuf[512];
	int frame;
d181 1
a181 1
	while( read_cmd( stdin, ibuf, sizeof(ibuf) ) >= 0 )  {
d184 1
a184 1
		cp = ibuf;
d190 1
@


8.4
log
@added view_parse hooks for application specific "set" variables.
took bounces and ireflect out.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.3 88/12/06 04:45:24 phil Locked $ (BRL)";
a378 7
/* generic settable parameters */
struct matparse set_parse[] = {
	"width",	(mp_off_ty)&width,			"%d",
	"height",	(mp_off_ty)&height,			"%d",
	"angle",	(mp_off_ty)&rt_perspective,		"%f",
	(char *)0,	(mp_off_ty)0,				(char *)0
};
d380 1
a380 1
extern struct matparse view_parse[];
d383 13
d405 2
a406 2
		mlib_print( "Application Values:", view_parse, (mp_off_ty)0 );
		mlib_print( "Generic Values:", set_parse, (mp_off_ty)0 );
d410 1
a410 1
		mlib_parse2( argv[1], view_parse, set_parse, (mp_off_ty)0 );
@


8.3
log
@Added code so that even in PARALLEL mode, scanlines are written to
the output file as they are completed.
Also, fixed things so that restarting in the middle of an output file
in parallel mode would work right.
(This means having to read in the image so far, first ).
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.2 88/10/21 17:37:54 phil Exp $ (BRL)";
d379 1
a383 2
	"bounces",	(mp_off_ty)&max_bounces,		"%d",
	"ireflect",	(mp_off_ty)&max_ireflect,		"%d",
d386 2
d399 2
a400 1
		mlib_print( "Variable Values:", set_parse, (mp_off_ty)0 );
d404 1
a404 1
		mlib_parse( argv[1], set_parse, (mp_off_ty)0 );
@


8.2
log
@spelling (from Carl Moore)
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 8.1 88/10/05 00:32:41 phil Locked $ (BRL)";
d607 2
a608 3
					if( (fd = open( framename, 1 )) < 0 ||
					    lseek( fd, (long)des_pos, 0 ) < 0 ||
					    (outfp = fdopen( fd, "w" )) == NULL )  {
d613 5
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.15 88/09/19 22:44:13 mike Exp $ (BRL)";
d628 1
a628 1
	fprintf(stderr,"Beam radius=%g mm, divergance=%g mm/1mm\n",
@


7.15
log
@atof() is adequately "extern'ed" in <math.h>, and
re-defining in locally sometimes produced clashes,
so local definitions were removed.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.14 88/08/23 02:31:53 mike Locked $ (BRL)";
@


7.14
log
@Added "using_mlib" variable, to determine whether to call
mlib_setup() or not.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.13 88/08/20 07:21:28 mike Locked $ (BRL)";
a46 1
extern double	atof();
@


7.13
log
@added "set" command and initial collection of setable variables
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.12 88/08/14 21:04:27 phil Locked $ (BRL)";
d58 1
d490 1
a490 1
			switch( mlib_setup( regp ) )  {
@


7.12
log
@Fixed problem with mid-frame restart capability not
resetting pix_start and pix_end values for next frame.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.11 88/07/26 01:25:26 mike Exp $ (BRL)";
d69 1
d95 5
d376 30
@


7.11
log
@Modifications to -i (incr_mode) that cause each scanline to be
written when finished, rather than waiting for whole frame to finish.
Also, changed to not display the first 4 iterations, which tend to
be boring and consume network and framebuffer bandwidth.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.10 88/06/17 02:50:27 mike Exp $ (BRL)";
d624 4
@


7.10
log
@Fixed newly added restart feature to avoid SYSV bug of not permitting
fseek() calls on files fopen'ed for append mode.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.9 88/06/17 00:23:41 mike Locked $ (BRL)";
d617 2
@


7.9
log
@On UNIX systems, if the output file already exists and has pixels in
it, RT starts computing there, rather than starting over at the beginning.
This is a valuable feature when machines are not staying up a lot.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.8 88/06/16 02:52:23 mike Locked $ (BRL)";
d544 1
d550 1
a550 1
				register int pixoff, byteoff;
d552 1
a552 1
				byteoff = pixoff * sizeof(RGBpixel);
d554 1
a554 1
					fprintf(stderr, "Continuing with pixel %d (%d, %d)\n",
d557 3
a559 1
						pixoff / width );
d561 13
a573 2
					/* Append to existing file */
					if( (outfp = fopen( framename, "a" )) == NULL )  {
a576 9
					}
					/*  Ensure that positioning is precisely right.
					 *  The file size is almost certainly not
					 *  an exact multiple of three bytes.
					 */
					if( fseek( outfp, (long)byteoff, 0 ) != 0 )  {
						perror("fseek");
						fclose( outfp );
						outfp = NULL;
@


7.8
log
@sign change on az el, aspect dependent viewsize computation
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.7 88/05/14 02:28:08 phil Locked $ (BRL)";
d35 5
d539 39
a577 1
		if( (outfp = fopen( framename, "w" )) == NULL )  {
@


7.7
log
@lint fixes
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.6 88/01/27 07:01:02 mike Locked $ (BRL)";
d61 1
d264 1
a264 1
		-35,   0,
d269 3
a271 3
		-25, -90,
		-30, -30, -30, -30, -30, -30, -30,
		-60, -60, -60, -60, -60, -60, -60
d655 8
a662 11
 *  Compute the rotation specified by the azimuth and
 *  elevation parameters.  First, note that these are
 *  specified relative to the GIFT "front view", ie,
 *  model (X,Y,Z) is view (Z,X,Y):  looking down X axis.
 *  Then, a positive azimuth represents rotating the *model*
 *  around the Y axis, or, rotating the *eye* in -Y.
 *  A positive elevation represents rotating the *model*
 *  around the X axis, or, rotating the *eye* in -X.
 *  This is the "Gwyn compatable" azim/elev interpretation.
 *  Note that GIFT azim/elev values are the negatives of
 *  this interpretation.
d692 1
a692 1
	mat_angles( Viewrotscale, 270.0-elev, 0.0, 270.0+azim );
d707 1
a707 1
	if( viewsize <= 0 )
d709 5
@


7.6
log
@Accomodated revisions to machine.c
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.5 88/01/27 04:36:02 mike Locked $ (BRL)";
d88 3
d372 1
d666 1
d723 1
@


7.5
log
@Duplicated code from librt/tree.c/rt_prep() to cause auto-size
code to compute expected viewsize.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.4 88/01/26 05:57:09 mike Locked $ (BRL)";
a70 1
extern int	parallel;		/* Trying to use multi CPUs */
d75 1
a75 1
/***** variables shared with do.c *****/
d85 2
a86 1
/***** end variables shared with do.c *****/
d399 2
d404 28
a431 1
	set_priority( width*height*(hypersample+1) );
d477 1
a477 1
	if( parallel && resource[0].re_seg == SEG_NULL )  {
d713 22
@


7.4
log
@Added mlib_one(), incorporated new mlib_setup() return code convention,
so that a material setup routine can indicate that this region is to
be destroyed.  Used with lights that become implicit.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.3 88/01/22 20:58:02 mike Locked $ (BRL)";
d643 15
@


7.3
log
@added variable perspective eye_backoff
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.2 87/11/05 00:35:46 phil Locked $ (BRL)";
a403 3
		/* Allow RT library to prepare itself */
		rt_prep_timer();
		rt_prep(rtip);
d405 12
a416 3
		/* Initialize the material library for all regions */
		for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
			if( mlib_setup( regp ) < 0 )  {
d418 2
a419 1
			} else {
d421 11
d435 1
d437 1
d439 5
@


7.2
log
@Put back "desiredframe" seeking on old-way scripts.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 7.1 87/11/02 23:36:00 mike Locked $ (BRL)";
d62 1
d642 1
a642 1
	VSET( temp, 0, 0, 1.414 );
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 6.6 87/10/15 02:16:58 mike Exp $ (BRL)";
d109 3
a111 1
		do_frame( curframe++ );
@


6.6
log
@New multiview list.  Multiview can be used after existing frame.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 6.5 87/10/14 23:30:48 mike Locked $ (BRL)";
@


6.5
log
@In command mode, if no view matrix or azim/elev specified by
"end" statement, use azim/elev parameters from command line.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 6.4 87/10/14 21:20:19 mike Locked $ (BRL)";
d255 1
d257 1
a257 1
		-35,
d262 1
a262 1
		-25,
d264 1
a264 1
		  0,   0,   0,   0,   0,   0,   0
d270 3
a272 3
	for( curframe=0; curframe<(sizeof(a)/sizeof(a[0])); curframe++ )  {
		do_ae( (double)a[curframe], (double)e[curframe] );
		(void)do_frame( curframe );
@


6.4
log
@Added "at_root" arg to rt_add_anim, and related processing.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 6.3 87/10/14 21:12:52 mike Exp $ (BRL)";
d50 1
d219 5
d612 3
d617 2
a618 1
	fprintf(stderr,"Viewing %g azimuth, %g elevation off of front view\n",
@


6.3
log
@Added check for rooted animation.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 6.2 87/09/03 01:30:14 mike Locked $ (BRL)";
d285 1
a285 1
	int	rooted = 0;
d288 1
a288 1
		rooted = 1;
d291 2
a292 2
	if( rooted && i == 1 )
		i = 0;		/* special ROOTED flag to rt_add_anim */
d321 1
a321 1
	if( rt_add_anim( rtip, anp ) < 0 )  {
@


6.2
log
@Added incremental resolution capability.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 6.1 87/07/11 07:58:16 mike Rel $ (BRL)";
d285 1
d287 2
a288 1
	/* Eventually might want to note leading slash or not */
d291 2
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 5.5 87/07/10 02:56:53 mike Exp $ (BRL)";
d66 3
d494 8
a501 1
	do_run( pix_start, pix_end );
@


5.5
log
@Moved code from rt.c to get dynamic memory for parallel execution.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 5.4 87/07/09 03:28:11 mike Exp $ (BRL)";
@


5.4
log
@Changed parallel support from #ifdef to runtime determination.
Added 3 types of libfb interaction
Misc. cleanups.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 5.3 87/07/03 05:46:13 mike Locked $ (BRL)";
d405 18
@


5.3
log
@Added new param to mf_print() routines.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 5.2 87/06/26 05:56:57 mike Exp $ (BRL)";
d59 1
d66 1
d385 1
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 5.1 87/06/24 22:14:15 mike Locked $ (BRL)";
d395 1
a395 1
						mf_print( regp );
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 1.7 87/05/31 04:48:06 mike Exp $ (BRL)";
d30 1
d394 2
a395 1
					regp->reg_mfuncs->mf_print( regp );
@


1.7
log
@Split do.c into do.c and machine.c, so that rtshot.c can have
the use of machine.c routines.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 1.6 87/05/30 07:03:06 mike Locked $ (BRL)";
@


1.6
log
@Added code for non-square views, single pixel (-b) debugging.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 1.5 87/04/30 17:40:54 mike Locked $ (BRL)";
a79 10
#ifdef PARALLEL
static int	lock_tab[12];		/* Lock usage counters */
static char	*all_title[12] = {
	"syscall",
	"worker",
	"stats",
	"results",
	"???"
};

a80 35
 *			L O C K _ P R
 */
lock_pr()
{
	register int i;
	for( i=0; i<3; i++ )  {
		if(lock_tab[i] == 0)  continue;
		fprintf(stderr,"%10d %s\n", lock_tab[i], all_title[i]);
	}
}
#endif PARALLEL

/*
 *			R E S _ P R
 */
res_pr()
{
	register struct resource *res;
	register int i;

	res = &resource[0];
	for( i=0; i<npsw; i++, res++ )  {
		fprintf(stderr,"cpu%d seg  len=%10d get=%10d free=%10d\n",
			i,
			res->re_seglen, res->re_segget, res->re_segfree );
		fprintf(stderr,"cpu%d part len=%10d get=%10d free=%10d\n",
			i,
			res->re_partlen, res->re_partget, res->re_partfree );
		fprintf(stderr,"cpu%d bitv len=%10d get=%10d free=%10d\n",
			i,
			res->re_bitvlen, res->re_bitvget, res->re_bitvfree );
	}
}

/*
a593 163

#ifdef cray
#ifdef PARALLEL
RES_INIT(p)
register int *p;
{
	register int i = p - (&rt_g.res_syscall);
	if(rdebug&RDEBUG_PARALLEL) 
		fprintf(stderr,"RES_INIT 0%o, i=%d, rt_g=0%o\n", p, i, &rt_g);
	LOCKASGN(p);
	if(rdebug&RDEBUG_PARALLEL) 
		fprintf(stderr,"    start value = 0%o\n", *p );
}
RES_ACQUIRE(p)
register int *p;
{
	register int i = p - (&rt_g.res_syscall);
	if( i < 0 || i > 12 )  {
		fprintf("RES_ACQUIRE(0%o)? %d?\n", p, i);
		abort();
	}
	lock_tab[i]++;		/* Not interlocked */
	if(rdebug&RDEBUG_PARALLEL) fputc( 'A'+i, stderr );
	LOCKON(p);
	if(rdebug&RDEBUG_PARALLEL) fputc( '0'+i, stderr );
}
RES_RELEASE(p)
register int *p;
{
	register int i = p - (&rt_g.res_syscall);
	if(rdebug&RDEBUG_PARALLEL) fputc( 'a'+i, stderr );
	LOCKOFF(p);
	if(rdebug&RDEBUG_PARALLEL) fputc( '\n', stderr);
}
#else
RES_INIT() {}
RES_ACQUIRE() {}
RES_RELEASE() {}
#endif PARALLEL
#endif cray

#ifdef sgi
/* Horrible bug in 3.3.1 and 3.4 and 3.5 -- hypot ruins stack! */
long float
hypot(a,b)
double a,b;
{
	return(sqrt(a*a+b*b));
}
#endif

#ifdef alliant
RES_ACQUIRE(p)
register int *p;		/* known to be a5 */
{
	register int i;
	i = p - (&rt_g.res_syscall);

#ifdef PARALLEL
	asm("loop:");
	do  {
		/* Just wasting time anyways, so log it */
		lock_tab[i]++;	/* non-interlocked */
	} while( *p );
	asm("	tas	a5@@");
	asm("	bne	loop");
#endif
}

#ifdef never
MAT4X3PNT( o, m, i )
register fastf_t *o;	/* a5 */
register fastf_t *m;	/* a4 */
register fastf_t *i;	/* a3 */
{
#ifdef NON_VECTOR
	FAST fastf_t f;
	f = 1.0/((m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]);
	(o)[X]=((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z] + (m)[3]) * f;
	(o)[Y]=((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z] + (m)[7]) * f;
	(o)[Z]=((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11])* f;
#else
	register int i;		/* d7 */
	register int vm;	/* d6, vector mask */
	register int vi;	/* d5, vector increment */
	register int vl;	/* d4, vector length */

	vm = -1;
	vi = 4;
	vl = 4;

	asm("fmoved	a3@@, fp0");
	asm("vmuld	a4@@, fp0, v7");

	asm("fmoved	a3@@(8), fp0");
	asm("vmuadd	fp0, a4@@(8), v7, v7");

	asm("fmoved	a3@@(16), fp0");
	asm("vmuadd	fp0, a4@@(16), v7, v7");

	asm("vaddd	a4@@(24), v7, v7");

#ifdef RECIPROCAL
	asm("moveq	#1, d0");
	asm("fmoveld	d0, fp0");
	asm("fdivd	a4@@(120), fp0, fp0");
	asm("vmuld	v7, fp0, v7");
#else
	asm("fmovedd	a4@@(120), fp7");
	asm("vrdivd	v7, fp7, v7");
#endif

	vi = 1;
	asm("vmoved	v7, a5@@");
#endif
}
/* Apply a 4x4 matrix to a 3-tuple which is a relative Vector in space */
MAT4X3VEC( o, m, i )
register fastf_t *o;
register fastf_t *m;
register fastf_t *i;
{
#ifdef NON_VECTOR
	FAST fastf_t f;
	f = 1.0/((m)[15]);
	(o)[X] = ((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z]) * f;
	(o)[Y] = ((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z]) * f;
	(o)[Z] = ((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z]) * f;
#else
	register int i;		/* d7 */
	register int vm;	/* d6, vector mask */
	register int vi;	/* d5, vector increment */
	register int vl;	/* d4, vector length */

	vm = -1;
	vi = 4;
	vl = 3;

	asm("fmoved	a3@@, fp0");
	asm("vmuld	a4@@, fp0, v7");

	asm("fmoved	a3@@(8), fp0");
	asm("vmuadd	fp0, a4@@(8), v7, v7");

	asm("fmoved	a3@@(16), fp0");
	asm("vmuadd	fp0, a4@@(16), v7, v7");

#ifdef RECIPROCAL
	asm("moveq	#1, d0");
	asm("fmoveld	d0, fp0");
	asm("fdivd	a4@@(120), fp0, fp0");
	asm("vmuld	v7, fp0, v7");
#else
	asm("fmovedd	a4@@(120), fp7");
	asm("vrdivd	v7, fp7, v7");
#endif

	vi = 1;
	asm("vmoved	v7, a5@@");
#endif
}
#endif never
#endif alliant
@


1.5
log
@limited chmod to output files only!
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 1.4 87/04/10 20:11:41 phil Locked $ (BRL)";
d58 3
a60 2
extern point_t	eye_model;	/* model-space location of eye */
extern int	npts;		/* # of points to shoot: x,y */
d63 1
a63 1
extern char	*scanbuf;	/* For optional output buffering */
d69 2
d513 1
a513 1
	do_run( 0, npts*npts - 1 );
d540 1
a540 1
		npts*npts, utime, (double)(npts*npts)/utime );
@


1.4
log
@Moved chmod after output is finished.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 1.3 87/04/10 08:13:49 mike Exp $ (BRL)";
d574 2
a575 1
		chmod( framename, 0444 );
@


1.3
log
@Added extern.
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: do.c,v 1.1 87/04/10 07:04:10 mike Exp $ (BRL)";
a481 1
		chmod( framename, 0444 );
d572 3
@


1.2
log
@Moved more parallel support code to do.c
from rt.c
@
text
@d44 1
a44 1
int		rdebug;			/* RT program debugging (not library) */
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.14 87/04/01 02:34:36 mike Exp $ (BRL)";
d63 2
d76 45
@
