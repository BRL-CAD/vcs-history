head	11.36;
access;
symbols
	ansi-20040405-merged:11.31.2.2
	postmerge-20040405-ansi:11.34
	premerge-20040404-ansi:11.33
	postmerge-autoconf:11.33
	autoconf-freeze:11.32.2.2
	premerge-autoconf:11.33
	postmerge-20040315-windows:11.33
	premerge-20040315-windows:11.33
	windows-20040315-freeze:11.31.4.1
	autoconf-20031203:11.32
	autoconf-20031202:11.32
	autoconf-branch:11.32.0.2
	phong-branch:11.31.0.8
	photonmap-branch:11.31.0.6
	rel-6-1-DP:11.31
	windows-branch:11.31.0.4
	rel-6-0-2:11.29
	ansi-branch:11.31.0.2
	rel-6-0-1-branch:11.29.0.2
	hartley-6-0-post:11.30
	hartley-6-0-pre:11.29
	rel-6-0-1:11.29
	rel-6-0:11.28
	rel-5-4:11.15.2.6
	offsite-5-3-pre:11.23
	rel-5-3:11.15.2.6
	rel-5-2:11.15
	rel-5-1-branch:11.15.0.2
	rel-5-1:11.15
	rel-5-0:11.11
	rel-5-0-beta:11.10
	rel-4-5:11.8
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.36
date	2004.05.21.17.31.09;	author morrison;	state dead;
branches;
next	11.35;

11.35
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.34;

11.34
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches
	11.32.2.1;
next	11.31;

11.31
date	2002.08.20.17.08.39;	author jra;	state Exp;
branches
	11.31.2.1
	11.31.4.1;
next	11.30;

11.30
date	2002.08.15.20.55.50;	author hartley;	state Exp;
branches;
next	11.29;

11.29
date	2002.07.23.18.11.10;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2001.05.17.20.06.07;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2001.04.05.19.36.04;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.04.02.21.38.31;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2001.04.02.15.05.14;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	2001.03.19.22.20.15;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	2001.01.22.20.28.57;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	2000.12.05.15.49.12;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2000.11.01.19.00.27;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2000.10.11.17.34.06;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.17.19.30.53;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.08.17.02.41.39;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.27.19.32.53;	author butler;	state Exp;
branches;
next	11.16;

11.16
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2000.05.19.18.00.51;	author jra;	state Exp;
branches
	11.15.2.1;
next	11.14;

11.14
date	2000.05.18.21.08.34;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	2000.05.18.20.23.28;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	99.11.24.22.17.07;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.07.02.22.19.46;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.05.28.01.19.29;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	98.09.22.00.21.29;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.12.16.00.20.11;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.01.02.21.04.59;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.10.15.17.35.34;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.12.06.17.57.53;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.08.16.17.48.51;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.26;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.11.05.03.07.01;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.08.22.19.34.25;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.08.11.02.46.34;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.03.01.18.07.49;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.02.28.14.21.10;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	92.06.03.15.23.35;	author sue;	state Exp;
branches;
next	10.2;

10.2
date	92.05.12.08.31.41;	author sue;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.20;	author mike;	state Rel4_0;
branches;
next	9.20;

9.20
date	91.08.19.21.55.57;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.07.06.00.35.29;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.06.19.20.55.47;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.06.19.00.00.21;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.06.05.09.10.04;	author sue;	state Exp;
branches;
next	9.15;

9.15
date	91.06.03.15.54.53;	author sue;	state Exp;
branches;
next	9.14;

9.14
date	91.03.19.11.53.20;	author sue;	state Exp;
branches;
next	9.13;

9.13
date	91.03.13.21.29.59;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.03.08.19.40.38;	author sue;	state Exp;
branches;
next	9.11;

9.11
date	91.03.02.03.03.22;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.03.02.02.21.44;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.03.02.02.05.39;	author sue;	state Exp;
branches;
next	9.8;

9.8
date	91.03.01.15.03.06;	author sue;	state Exp;
branches;
next	9.7;

9.7
date	91.02.20.00.51.32;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.05.03.09.24;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.12.16.35.17;	author butler;	state Exp;
branches;
next	9.4;

9.4
date	90.12.07.00.55.06;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.11.26.13.24.09;	author sue;	state Exp;
branches;
next	9.2;

9.2
date	90.11.14.15.43.39;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.55;	author mike;	state Rel3_5;
branches
	9.1.1.1;
next	1.30;

1.30
date	89.05.11.01.21.24;	author phil;	state Exp;
branches;
next	1.29;

1.29
date	89.05.09.15.30.48;	author stay;	state Exp;
branches;
next	1.28;

1.28
date	89.04.24.08.56.38;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	89.04.24.08.53.28;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	89.04.10.21.33.33;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	89.04.10.21.10.39;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	89.04.10.20.59.04;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	89.04.04.14.19.02;	author sue;	state Exp;
branches;
next	1.22;

1.22
date	89.04.04.05.02.25;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	89.04.03.13.07.29;	author sue;	state Exp;
branches;
next	1.20;

1.20
date	89.03.30.21.08.13;	author sue;	state Exp;
branches;
next	1.19;

1.19
date	89.03.30.20.54.59;	author sue;	state Exp;
branches;
next	1.18;

1.18
date	89.03.21.09.42.32;	author sue;	state Exp;
branches;
next	1.17;

1.17
date	89.03.17.14.52.30;	author sue;	state Exp;
branches;
next	1.16;

1.16
date	89.03.15.19.28.16;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	89.03.14.17.13.43;	author sue;	state Exp;
branches;
next	1.14;

1.14
date	89.03.14.12.06.11;	author sue;	state Exp;
branches;
next	1.13;

1.13
date	89.03.13.16.54.51;	author sue;	state Exp;
branches;
next	1.12;

1.12
date	89.03.11.23.28.55;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	89.03.10.04.58.23;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	89.03.08.19.19.03;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	89.03.08.19.14.38;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	89.03.08.18.51.08;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	89.03.08.17.49.21;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.02.23.21.00.35;	author sue;	state Exp;
branches;
next	1.5;

1.5
date	89.02.13.22.26.12;	author sue;	state Exp;
branches;
next	1.4;

1.4
date	89.02.13.09.00.40;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.02.11.23.55.08;	author sue;	state Exp;
branches;
next	1.2;

1.2
date	89.02.11.23.14.48;	author sue;	state Exp;
branches;
next	1.1;

1.1
date	89.02.11.21.48.07;	author sue;	state Exp;
branches;
next	;

9.1.1.1
date	91.03.14.03.57.28;	author mike;	state Exp;
branches;
next	;

11.15.2.1
date	2000.10.25.19.03.11;	author jra;	state Exp;
branches;
next	11.15.2.2;

11.15.2.2
date	2000.10.26.12.48.52;	author jra;	state Exp;
branches;
next	11.15.2.3;

11.15.2.3
date	2000.11.01.18.41.05;	author jra;	state Exp;
branches;
next	11.15.2.4;

11.15.2.4
date	2000.11.01.18.46.55;	author jra;	state Exp;
branches;
next	11.15.2.5;

11.15.2.5
date	2000.11.22.13.37.09;	author jra;	state Exp;
branches;
next	11.15.2.6;

11.15.2.6
date	2001.01.22.20.26.54;	author jra;	state Exp;
branches;
next	;

11.31.2.1
date	2002.09.19.18.02.16;	author morrison;	state Exp;
branches;
next	11.31.2.2;

11.31.2.2
date	2004.03.17.21.23.01;	author morrison;	state Exp;
branches;
next	;

11.31.4.1
date	2004.03.11.23.48.08;	author morrison;	state Exp;
branches;
next	;

11.32.2.1
date	2004.02.12.19.37.14;	author erikg;	state Exp;
branches;
next	11.32.2.2;

11.32.2.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@RT output module that produces GIFT 3 component format shotline files.
@


11.36
log
@moved to src/rt/
@
text
@/*
 *			V I E W G 3
 *
 *  Ray Tracing program RTG3 bottom half.
 *
 *  This module turns RT library partition lists into
 *  the old GIFT type shotlines with three components per card,
 *  and with both the entrance and exit obliquity angles.
 *  The output format is:
 *	overall header card
 *		view header card
 *			ray (shotline) header card
 *				component card(s)
 *			ray (shotline) header card
 *			 :
 *			 :
 *
 *  At present, the main use for this format ray file is
 *  to drive the JTCG-approved COVART2 and COVART3 applications.
 *
 *  Authors -
 *	Susanne L. Muuss, J.D.
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrayg3[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/viewg3.c,v 11.35 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ext.h"
#include "../librt/debug.h"
#include "plot3.h"
#include "rtprivate.h"

#define	MM2IN	0.03937008		/* mm times MM2IN gives inches */
#define TOL 0.01/MM2IN			/* GIFT has a 0.01 inch tolerance */

void	part_compact(register struct application *ap, register struct partition *PartHeadp, fastf_t tolerance);

extern fastf_t	gift_grid_rounding;
extern point_t	viewbase_model;

extern int	npsw;			/* number of worker PSWs to run */

int		use_air = 1;		/* Handling of air in librt */

extern int 	 rpt_overlap;

extern fastf_t  rt_cline_radius;        /* from g_cline.c */

extern struct bu_vls    ray_data_file;  /* file name for ray data output (declared in do.c) */
FILE    *shot_fp;               /* FILE pointer for ray data output */
static long     line_num;               /* count of lines output to shotline file */

/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
	{"",	0, (char *)0,	0,		BU_STRUCTPARSE_FUNC_NULL }
};

static mat_t	model2hv;		/* model coords to GIFT h,v in inches */

static FILE	*plotfp;		/* optional plotting file */
static long	line_num;		/* count of lines output to shotline file */

const char usage[] = "\
Usage:  rtg3 [options] model.g objects... >file.ray\n\
Options:\n\
 -s #		Grid size in pixels, default 512\n\
 -a Az		Azimuth in degrees	(conflicts with -M)\n\
 -e Elev	Elevation in degrees	(conflicts with -M)\n\
 -M		Read model2view matrix on stdin (conflicts with -a, -e)\n\
 -g #		Grid cell width in millimeters (conflicts with -s)\n\
 -G #		Grid cell height in millimeters (conflicts with -s)\n\
 -J #		Jitter.  Default is off.  Any non-zero number is on\n\
 -o model.g3	Specify output file, GIFT-3 format (default=stdout)\n\
 -U #		Set use_air boolean to # (default=1)\n\
 -c \"set ray_data_file=ray_file_name\"         Specify ray data output file (az el x_start y_start z_start x_dir y_dir z_dir line_number_in_shotline_file ray_first_hit_x ray_first_hit_y ray_first_hit_z)\n\
 -c \"set save_overlaps=1\"     Reproduce FASTGEN behavior for regions flagged as FASTGEN regions\n\
 -c \"set rt_cline_radius=radius\"      Additional radius to be added to CLINE solids\n\
 -x #		Set librt debug flags\n\
";

int	rayhit(register struct application *ap, struct partition *PartHeadp);
int     raymiss(register struct application *ap);

/*
 *  			V I E W _ I N I T
 *
 *  This routine is called by main().  It prints the overall shotline
 *  header. Furthermore, pointers to rayhit() and raymiss() are set up
 *  and are later called from do_run().
 */

static char * save_file;
static char * save_obj;

int
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{
	line_num = 1;

	if( !minus_o )
		outfp = stdout;
	
	save_file = file;
	save_obj = obj;

	if( ray_data_file.vls_magic == BU_VLS_MAGIC ) {
		if( (shot_fp=fopen( bu_vls_addr( &ray_data_file ), "w" )) == NULL ) {
			perror( "RTG3" );
			bu_log( "Cannot open ray data output file %s\n", bu_vls_addr( &ray_data_file ) );
			bu_bomb( "Cannot open ray data output file\n" );
		}
	}

	/*
	 *  Cause grid_setup() to align the grid on one inch boundaries,
	 *  or cell_width boundaries, if it is given.
	 */
	if( cell_width > 0 )
		gift_grid_rounding = cell_width;
	else if( cell_height > 0 )
		gift_grid_rounding = cell_height;
	else
		gift_grid_rounding = 25.4;		/* one inch */

	ap->a_hit = rayhit;
	ap->a_miss = raymiss;
	ap->a_onehit = 0;

	if( !rpt_overlap )
		 ap->a_logoverlap = rt_silent_logoverlap;

	output_is_binary = 0;		/* output is printable ascii */

	if(R_DEBUG & RDEBUG_RAYPLOT) {
		plotfp = fopen("rtg3.pl", "w");
		if( npsw > 1 )  {
			bu_log("Note: writing rtg3.pl file can only be done using only 1 processor\n");
			npsw = 1;
		}
	}

	return(0);		/* No framebuffer needed */
}

/*
 *			V I E W _ 2 I N I T
 *
 *  View_2init is called by do_frame(), which in turn is called by
 *  main() in rt.c.  It writes the view-specific COVART header.
 * 
 */
void
view_2init(struct application *ap)
{
	if( outfp == NULL )
		rt_bomb("outfp is NULL\n");

	/*
	 *  Overall header, to be read by COVART format:
	 *  9220 FORMAT( BZ, I5, 10A4 )
	 *	number of views, title
	 *  Initially, do only one view per run of RTG3.
	 */
	fprintf(outfp,"%5d %s %s\n", 1, save_file, save_obj);

	/*
	 *  Header for each view, to be read by COVART format:
	 *  9230 FORMAT( BZ, 2( 5X, E15.8), 30X, E10.3 )
	 *	azimuth, elevation, grid_spacing
	 * NOTE that GIFT provides several other numbers that are not used
	 * by COVART;  this should be investigated.
	 * NOTE that grid_spacing is assumed to be square (by COVART),
	 * and that the units have been converted from MM to IN.
	 * COVART, given the appropriate code, will take, IN, M, 
	 * FT, MM, and CM.  However, GIFT  output is expected to be IN.
	 * NOTE that variables "azimuth and elevation" are not valid
	 * when the -M flag is used.
	 * NOTE:  %10g was changed to %10f so that a decimal point is generated
	 * even when the number is an integer.  Otherwise the client codes
	 * get confused get confused and are unable to convert the number to
	 * scientific notation.
	 */
	fprintf(outfp,
		"     %-15.8f     %-15.8f                              %10f\n",
		azimuth, elevation, cell_width*MM2IN );

	/*
	 *  GIFT uses an H,V coordinate system that is anchored at the
	 *  model origin, but rotated according to the view.
	 *  For convenience later, build a matrix that will take
	 *  a point in model space (with units of mm), and convert it
	 *  to a point in HV space, with units of inches.
	 */
	MAT_COPY( model2hv, Viewrotscale );
	model2hv[15] = 1/MM2IN;

	line_num += 2;
}

/*
 *			R A Y M I S S
 *
 *  Null function -- handle a miss
 *  This function is called by rt_shootray(), which is called by
 *  do_frame().
 */
int
raymiss(register struct application *ap)
{
	return(0);
}

/*
 *			V I E W _ P I X E L
 *
 *  This routine is called from do_run(), and in this case does nothing.
 */
void
view_pixel(void)
{
	return;
}

/*
 *			R A Y H I T
 *
 *  Rayhit() is called by rt_shootray() when the ray hits one or more objects.
 *  A per-shotline header record is written, followed by information about
 *  each object hit.
 *
 *  Note that the GIFT-3 format uses a different convention for the "zero"
 *  distance along the ray.  RT has zero at the ray origin (emanation plain),
 *  while GIFT has zero at the screen plain translated so that it contains
 *  the model origin.  This difference is compensated for by adding the
 *  'dcorrection' distance correction factor.
 *
 *  Also note that the GIFT-3 format requires information about the start
 *  point of the ray in two formats.  First, the h,v coordinates of the
 *  grid cell CENTERS (in screen space coordinates) are needed.
 *  Second, the ACTUAL h,v coordinates fired from are needed.
 *
 *  An optional rtg3.pl UnixPlot file is written, permitting a
 *  color vector display of ray-model intersections.
 */
int
rayhit(struct application *ap, register struct partition *PartHeadp)
{
	register struct partition *pp = PartHeadp->pt_forw;
	int 			comp_count;	/* component count */
	fastf_t			dfirst, dlast;	/* ray distances */
	static fastf_t		dcorrection = 0; /* RT to GIFT dist corr */
	int			card_count;	/* # comp. on this card */
	char			*fmt;		/* printf() format string */
	struct bu_vls		str;
	char			buf[128];	/* temp. sprintf() buffer */
	point_t			hv;		/* GIFT h,v coords, in inches */
	point_t			hvcen;
	int			prev_id=-1;
	point_t			first_hit;
	int			first;

	if( pp == PartHeadp )
		return(0);		/* nothing was actually hit?? */

	if( ap->a_rt_i->rti_save_overlaps )
		rt_rebuild_overlaps( PartHeadp, ap, 1 );

	part_compact(ap, PartHeadp, TOL);

	/* count components in partitions */
	comp_count = 0;
	for( pp=PartHeadp->pt_forw; pp!=PartHeadp; pp=pp->pt_forw )  {
		if( pp->pt_regionp->reg_regionid > 0 ) {
			prev_id = pp->pt_regionp->reg_regionid;
			comp_count++;
		} else if( prev_id <= 0 ) {
			/* normally air would be output along with a solid partition, but this will require a '111' partition */
			prev_id = pp->pt_regionp->reg_regionid;
			comp_count++;
		} else
			prev_id = pp->pt_regionp->reg_regionid;
	}
	pp = PartHeadp->pt_back;
	if( pp!=PartHeadp && pp->pt_regionp->reg_regionid <= 0 )
		comp_count++;  /* a trailing '111' ident */
	if( comp_count == 0 )
		return( 0 );

	/* Set up variable length string, to buffer this shotline in.
	 * Note that there is one component per card, and that each card
	 * (line) is 80 characters long.  Hence the parameters given to
	 * rt-vls-extend().
	 */

	bu_vls_init( &str );
	bu_vls_extend( &str, 80 * (comp_count+1) );

	/*
	 *  Find the H,V coordinates of the grid cell center.
	 *  RT uses the lower left corner of each cell.
	 */
	{
		point_t		center;
		fastf_t		dx;
		fastf_t		dy;

		dx = ap->a_x + 0.5;
		dy = ap->a_y + 0.5;
		VJOIN2( center, viewbase_model, dx, dx_model, dy, dy_model );
		MAT4X3PNT( hvcen, model2hv, center );
	}

	/*
	 *  Find exact h,v coordinates of actual ray start by
	 *  projecting start point into GIFT h,v coordinates.
	 */
	MAT4X3PNT( hv, model2hv, ap->a_ray.r_pt );

	/*
	 *  In RT, rays are launched from the plane of the screen,
	 *  and ray distances are relative to the start point.
	 *  In GIFT-3 output files, ray distances are relative to
	 *  the (H,V) plane translated so that it contains the origin.
	 *  A distance correction is required to convert between the two.
	 *  Since this really should be computed only once, not every time,
	 *  the trip_count flag was added.
	 */
	{

		static int  trip_count;
		vect_t	tmp;
		vect_t	viewZdir;

		if( trip_count == 0) {

			VSET( tmp, 0, 0, -1 );		/* viewing direction */
			MAT4X3VEC( viewZdir, view2model, tmp );
			VUNITIZE( viewZdir );
			/* dcorrection will typically be negative */
			dcorrection = VDOT( ap->a_ray.r_pt, viewZdir );
			trip_count = 1;
		}
	}

	/* This code is for diagnostics.
	 * bu_log("dcorrection=%g\n", dcorrection);
	 */

	/* dfirst and dlast have been made negative to account for GIFT looking
	 * in the opposite direction of RT.
	 */

	dfirst = -(PartHeadp->pt_forw->pt_inhit->hit_dist + dcorrection);
	dlast = -(PartHeadp->pt_back->pt_outhit->hit_dist + dcorrection);
#if 0
	/* This code is to note any occurances of negative distances. */
		if( PartHeadp->pt_forw->pt_inhit->hit_dist < 0)  {
			bu_log("ERROR: dfirst=%g at partition x%x\n", dfirst , PartHeadp->pt_forw );
			bu_log("\tdcorrection = %f\n" , dcorrection );
			bu_log("\tray start point is ( %f %f %f ) in direction ( %f %f %f )\n" , V3ARGS( ap->a_ray.r_pt ) , V3ARGS( ap->a_ray.r_dir ) );
			VJOIN1( PartHeadp->pt_forw->pt_inhit->hit_point , ap->a_ray.r_pt ,PartHeadp->pt_forw->pt_inhit->hit_dist , ap->a_ray.r_dir );
			VJOIN1( PartHeadp->pt_back->pt_outhit->hit_point , ap->a_ray.r_pt ,PartHeadp->pt_forw->pt_outhit->hit_dist , ap->a_ray.r_dir );
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "Defective partion:");
		}
	/* End of bug trap. */
#endif
	/*
	 *  Output the ray header.  The GIFT statements that
	 *  would have generated this are:
	 *  410	write(1,411) hcen,vcen,h,v,ncomp,dfirst,dlast,a,e
	 *  411	format(2f7.1,2f9.3,i3,2f8.2,' A',f6.1,' E',f6.1)
	 */

#define	SHOT_FMT	"%7.1f%7.1f%9.3f%9.3f%3d%8.2f%8.2f A%6.1f E%6.1f"

	if( rt_perspective > 0 )  {
		bn_ae_vec( &azimuth, &elevation, ap->a_ray.r_dir );
	}

	bu_vls_printf( &str, SHOT_FMT,
		hvcen[0], hvcen[1],
		hv[0], hv[1],
		comp_count,
		dfirst * MM2IN, dlast * MM2IN,
		azimuth, elevation );

	/*
	 *  As an aid to debugging, take advantage of the fact that
	 *  there are more than 80 columns on UNIX "cards", and
	 *  add debugging information to the end of the line to
	 *  allow this shotline to be reproduced offline.
	 *   -b gives the shotline x,y coordinates when re-running RTG3,
	 *   -p and -d are used with RTSHOT
	 *  The easy way to activate this is with the harmless -!1 option
	 *  when running RTG3.
	 */
	if( R_DEBUG || bu_debug || RT_G_DEBUG )  {
		bu_vls_printf( &str, "   -b%d,%d -p %26.20e %26.20e %26.20e -d %26.20e %26.20e %26.20e\n",
			ap->a_x, ap->a_y,
			V3ARGS(ap->a_ray.r_pt),
			V3ARGS(ap->a_ray.r_dir) );
	} else {
		bu_vls_putc( &str, '\n' );
	}

	/* loop here to deal with individual components */
	card_count = 0;
	prev_id = -1;
	first = 1;
	for( pp=PartHeadp->pt_forw; pp!=PartHeadp; pp=pp->pt_forw )  {
		/*
		 *  The GIFT statements that would have produced
		 *  this output are:
		 *	do 632 i=icomp,iend
		 *	if(clos(icomp).gt.999.99.or.slos(i).gt.999.9) goto 635
		 * 632	continue
		 * 	write(1,633)(item(i),clos(i),cangi(i),cango(i),
		 * &			kspac(i),slos(i),i=icomp,iend)
		 * 633	format(1x,3(i4,f6.2,2f5.1,i1,f5.1))
		 *	goto 670
		 * 635	write(1,636)(item(i),clos(i),cangi(i),cango(i),
		 * &			kspac(i),slos(i),i=icomp,iend)
		 * 636	format(1x,3(i4,f6.1,2f5.1,i1,f5.0))
		 */
		fastf_t	comp_thickness;	/* component line of sight thickness */
		fastf_t	in_obliq;	/* in obliquity angle */
		fastf_t	out_obliq;	/* out obliquity angle */
		int	region_id;	/* solid region's id */
		int	air_id;		/* air id */
		fastf_t	dot_prod;	/* dot product of normal and ray dir */
		fastf_t	air_thickness;	/* air line of sight thickness */
		vect_t	normal;		/* surface normal */
		register struct partition	*nextpp = pp->pt_forw;

		region_id = pp->pt_regionp->reg_regionid;

		if( region_id <= 0 && prev_id > 0 )
		{
			/* air region output with previous partition */
			prev_id = region_id;
			continue;
		}
		comp_thickness = pp->pt_outhit->hit_dist -
				 pp->pt_inhit->hit_dist;

		/* The below code is meant to catch components with zero or
		 * negative thicknesses.  This is not supposed to be possible,
		 * but the condition has been seen.
		 */
#if 0
		if( comp_thickness <= 0 )  {
			VJOIN1( pp->pt_inhit->hit_point , ap->a_ray.r_pt ,pp->pt_inhit->hit_dist , ap->a_ray.r_dir );
			VJOIN1( pp->pt_outhit->hit_point , ap->a_ray.r_pt ,pp->pt_outhit->hit_dist , ap->a_ray.r_dir );
			bu_log("ERROR: comp_thickness=%g for region id = %d at h=%g, v=%g (x=%d, y=%d), partition at x%x\n",
				comp_thickness, region_id, hv[0], hv[1], ap->a_x, ap->a_y , pp );
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "Defective partion:");
			bu_log("Send this output to Sue Muuss (sue@@brl.mil)\n");
			if ( ! (RT_G_DEBUG & DEBUG_ARB8)) {
				rt_g.debug |= DEBUG_ARB8;
				rt_shootray(ap);
				rt_g.debug &= ~DEBUG_ARB8;
			}
		}
#endif

		if( nextpp == PartHeadp )  {
			if( region_id <= 0 ) {
				/* last partition is air, need a 111 'phantom armor' before AND after */
				bu_log( "WARNING: adding 'phantom armor' (id=111) with zero thickness before and after air region %s\n",
					 pp->pt_regionp->reg_name );
				region_id = 111;
				air_id = pp->pt_regionp->reg_aircode;
				air_thickness = comp_thickness;
				comp_thickness = 0.0;
			} else {
				/* Last partition, no air follows, use code 9 */
				air_id = 9;
				air_thickness = 0.0;
			}
		} else if( region_id <= 0 ) {
			/* air region, need a 111 'phantom armor' */
			bu_log( "WARNING: adding 'phantom armor' (id=111) with zero thickness before air region %s\n",
				 pp->pt_regionp->reg_name );
			prev_id = region_id;
			region_id = 111;
			air_id = pp->pt_regionp->reg_aircode;
			air_thickness = comp_thickness;
			comp_thickness = 0.0;
		} else if( nextpp->pt_regionp->reg_regionid <= 0 &&
			nextpp->pt_regionp->reg_aircode != 0 )  {
			/* Next partition is air region */
			air_id = nextpp->pt_regionp->reg_aircode;
			air_thickness = nextpp->pt_outhit->hit_dist -
				nextpp->pt_inhit->hit_dist;
			prev_id = air_id;
		} else {
			/* 2 solid regions, maybe with gap */
			air_id = 0;
			air_thickness = nextpp->pt_inhit->hit_dist -
				pp->pt_outhit->hit_dist;
			if( air_thickness < 0.0 )
				air_thickness = 0.0;
			if( !NEAR_ZERO( air_thickness, 0.1 ) )  {
				air_id = 1;	/* air gap */
				if( R_DEBUG & RDEBUG_HITS )
					bu_log("air gap added\n");
			} else {
				air_thickness = 0.0;
			}
			prev_id = region_id;
		}

		/*
		 *  Compute the obliquity angles in degrees, ie,
		 *  the "declension" angle down off the normal vector.
		 *  RT normals always point outwards;
		 *  the "inhit" normal points opposite the ray direction,
		 *  the "outhit" normal points along the ray direction.
		 *  Hence the one sign change.
		 *  XXX this should probably be done with atan2()
		 */

		if( first ) {
			first = 0;
			VJOIN1( first_hit, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
		}
out:
		RT_HIT_NORMAL( normal, pp->pt_inhit, pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip );
		dot_prod = VDOT( ap->a_ray.r_dir, normal );
		if( dot_prod > 1.0 )
			dot_prod = 1.0;
		if( dot_prod < -1.0 )
			dot_prod = (-1.0);

		in_obliq = acos( -dot_prod ) *
			bn_radtodeg;
		RT_HIT_NORMAL( normal, pp->pt_outhit, pp->pt_outseg->seg_stp, &(ap->a_ray), pp->pt_outflip );
		dot_prod = VDOT( ap->a_ray.r_dir, normal );
		if( dot_prod > 1.0 )
			dot_prod = 1.0;
		if( dot_prod < -1.0 )
			dot_prod = (-1.0);

		out_obliq = acos( dot_prod ) *
			bn_radtodeg;

		/* Check for exit obliquties greater than 90 degrees. */
#if 0
		if( in_obliq > 90 || in_obliq < 0 )  {
			bu_log("ERROR: in_obliquity=%g\n", in_obliq);
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "Defective partion:");
		}
		if( out_obliq > 90 || out_obliq < 0 )  {
			bu_log("ERROR: out_obliquity=%g\n", out_obliq);
			VPRINT(" r_dir", ap->a_ray.r_dir);
			VPRINT("normal", normal);
			bu_log("dot=%g, acos(dot)=%g\n",
				VDOT( ap->a_ray.r_dir, normal ),
				acos( VDOT( ap->a_ray.r_dir, normal ) ) );
			/* Print the defective one */
			rt_pr_pt( ap->a_rt_i, pp );
			/* Print the whole ray's partition list */
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "Defective partion:");
		}
#endif

		if( in_obliq > 90.0 )
			in_obliq = 90.0;
		if( in_obliq < 0.0 )
			in_obliq = 0.0;
		if( out_obliq > 90.0 )
			out_obliq = 90.0;
		if( out_obliq < 0.0 )
			out_obliq = 0.0;

		/*
		 *  Handle 3-components per card output format, with
		 *  a leading space in front of the first component.
		 */
		if( card_count == 0 )  {
			bu_vls_strcat( &str, " " );
		}
		comp_thickness *= MM2IN;
		/* Check thickness fields for format overflow */
		if( comp_thickness > 999.99 || air_thickness*MM2IN > 999.9 )
			fmt = "%4d%6.1f%5.1f%5.1f%1d%5.0f";
		else
			fmt = "%4d%6.2f%5.1f%5.1f%1d%5.1f";
#ifdef SPRINTF_NOT_PARALLEL
		bu_semaphore_acquire( BU_SEM_SYSCALL );
#endif
		sprintf(buf, fmt,
			region_id,
			comp_thickness,
			in_obliq, out_obliq,
			air_id, air_thickness*MM2IN );
#ifdef SPRINTF_NOT_PARALLEL
		bu_semaphore_release( BU_SEM_SYSCALL );
#endif
		bu_vls_strcat( &str, buf );
		card_count++;
		if( card_count >= 3 )  {
			bu_vls_strcat( &str, "\n" );
			card_count = 0;
		}

		/* A color rtg3.pl UnixPlot file of output commands
		 * is generated.  This is processed by plot(1)
		 * plotting filters such as pl-fb or pl-sgi.
		 * Portions of a ray passing through air within the
		 * model are represented in blue, while portions 
		 * passing through a solid are assigned green.
		 * This will always be done single CPU,
		 * to prevent output garbling.  (See view_init).
		 */
		if(R_DEBUG & RDEBUG_RAYPLOT) {
			vect_t     inpt;
			vect_t     outpt;
			VJOIN1(inpt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
				ap->a_ray.r_dir);
			VJOIN1(outpt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist,
				ap->a_ray.r_dir);
				pl_color(plotfp, 0, 255, 0);	/* green */
			pdv_3line(plotfp, inpt,outpt);
			
			if(air_thickness > 0) {
				vect_t     air_end;
				VJOIN1(air_end, ap->a_ray.r_pt,
					pp->pt_outhit->hit_dist + air_thickness,
					ap->a_ray.r_dir);
				pl_color(plotfp, 0, 0, 255);	/* blue */
				pdv_3cont(plotfp, air_end);
			}
		}
		if( nextpp == PartHeadp && air_id != 9 ) {
			/* need to output a 111 'phantom armor' at end of shotline */
			air_id = 9;
			air_thickness = 0.0;
			region_id = 111;
			comp_thickness = 0.0;
			goto out;
		}
	}

	/* If partway through building the line, add a newline */
	if( card_count > 0 )  {
		/*
		 *  Note that GIFT zero-fills the unused component slots,
		 *  but neither COVART II nor COVART III require it,
		 *  so just end the line here.
		 */
		bu_vls_strcat( &str, "\n" );
	}

	/* Single-thread through file output.
	 * COVART will accept non-sequential ray data provided the
	 * ray header and its associated data are not separated.  CAVEAT:
	 * COVART will not accept headers out of sequence.
	 */
	bu_semaphore_acquire( BU_SEM_SYSCALL );

	fputs( bu_vls_addr( &str ), outfp );

	if( shot_fp )
	{
		fprintf( shot_fp, "%.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %ld %.5f %.5f %.5f\n",
			azimuth, elevation, V3ARGS( ap->a_ray.r_pt ), V3ARGS( ap->a_ray.r_dir ),
			 line_num, V3ARGS( first_hit) );

		line_num +=  1 + (comp_count / 3 );
		if( comp_count % 3 )
			line_num++;
	}

	/* End of single-thread region */
	bu_semaphore_release( BU_SEM_SYSCALL );

	/* Release vls storage */
	bu_vls_free( &str );

	return(0);
}

/*
 *			V I E W _ E O L
 *
 *  View_eol() is called by rt_shootray() in do_run().  In this case,
 *  it does nothing.
 */
void	view_eol(void)
{
}

/*
 *			V I E W _ E N D
 *
 *  View_end() is called by rt_shootray in do_run().  It
 *  outputs a special 999.9 "end of view" marker, composed of
 *  a "999.9" shotline header, with one all-zero component record.
 *  This is the way GIFT did it.  Note that the component count must also
 *  be zero on this shotline, or else the client codes get confused.
 */
void
view_end(void)
{
	fprintf(outfp, SHOT_FMT,
		999.9, 999.9,
		999.9, 999.9,
		0,			/* component count */
		0.0, 0.0,
		azimuth, elevation );
	/* An abbreviated component record:  just give item code 0.  This is
	 * not required since GIFT truncates the above line at the first
	 * 999.9: putting out the abovementioned 0 caused a lot of oscillation
	 * over the last year, so the line has been removed. 
	 */

	fflush(outfp);
}

void view_setup(void) {}
void view_cleanup(void) {}


/*
 *			P A R T _ C O M P A C T
 *
 * This routine takes at partition-head pointer, an application
 * structure pointer,  and a tolerance.  It goes through the partition
 * list shot-line by shot-line and checks for regions with identical
 * region-ids abutting.  If one is found, and the distance
 * between the two abbutting regions is less than the tolerance, the two
 * corresponding partions are collapsed into one, and the outhit from the
 * second partions becomes the governing outhit.  This will prevent the
 * occurance of multiple hits per same region.
 *
 */

void
part_compact(register struct application *ap, register struct partition *PartHeadp, fastf_t tolerance)
{

	fastf_t				gap;
	struct partition		*pp;
	struct partition		*nextpp;

	/* first eliminate zero thickness partitions */
	pp = PartHeadp->pt_forw;
	while( pp != PartHeadp )
	{
		fastf_t comp_thickness;

		nextpp = pp->pt_forw;
		comp_thickness = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
		if( comp_thickness <= 0.0 )
		{
			DEQUEUE_PT( pp );
			FREE_PT( pp, ap->a_resource);
		}
		pp = nextpp;
	}

	for(pp = PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw)  {
top:		nextpp = pp->pt_forw;
		if(nextpp == PartHeadp)  {
			break;
		}
		if( pp->pt_regionp->reg_regionid > 0 && nextpp->pt_regionp->reg_regionid > 0 ) {
			if(pp->pt_regionp->reg_regionid != nextpp->pt_regionp->reg_regionid)  {
				continue;
			}
		} else if( pp->pt_regionp->reg_regionid <= 0 && nextpp->pt_regionp->reg_regionid <= 0 ) {
			if( pp->pt_regionp->reg_aircode != nextpp->pt_regionp->reg_aircode ) {
				continue;
			}
		} else
			continue;

		gap = nextpp->pt_inhit->hit_dist - pp->pt_outhit->hit_dist;

		/* The following line is a diagnostic that is worth reusing:
		 * bu_log("gap=%e\n", gap);
		 */

		if(gap > tolerance)  {
			continue;
		}

		/* Eliminate the gap by collapsing the two partitions
		 * into one.  The below lines have been commented out but
		 * should be retained for debugging purposes.
		 */
#if 0
		  bu_log("part_comp: collapsing gap of %e mm between id=%d and id=%d air=%d and air=%d\n",
		 	gap, pp->pt_regionp->reg_regionid, 
		 	nextpp->pt_regionp->reg_regionid, pp->pt_regionp->reg_aircode, nextpp->pt_regionp->reg_aircode);
#endif
		  pp->pt_outseg = nextpp->pt_outseg;
		  pp->pt_outhit = nextpp->pt_outhit;
		  pp->pt_outflip = nextpp->pt_outflip;


		/*
		 *  Dequeue and free the unwanted partition structure.
		 *  Referenced segments, etc, will be freed by rt_shootray().
		 */
		DEQUEUE_PT(nextpp);
		FREE_PT(nextpp, ap->a_resource);

		goto top;
	}

}

void application_init (void) {}
@


11.35
log
@change conf.h to a wrapped config.h
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /cvs/brlcad/rt/viewg3.c,v 11.34 2004/04/05 05:45:59 morrison Exp $ (BRL)";
@


11.34
log
@merge of ansi-6-0-branch into head
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header$ (BRL)";
d38 5
a42 1
#include "conf.h"
@


11.33
log
@update copyright to include span through 2003
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.32 2003/09/27 01:11:25 morrison Exp $ (BRL)";
d60 1
a60 1
void	part_compact();
d105 2
a106 1
int	rayhit(), raymiss();
d120 1
a120 3
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
d177 1
a177 2
view_2init( ap )
struct application	*ap;
d232 1
a232 1
raymiss()
d243 1
a243 1
view_pixel()
d270 1
a270 3
rayhit( ap, PartHeadp )
struct application *ap;
register struct partition *PartHeadp;
d714 1
a714 1
void	view_eol()
d728 1
a728 1
view_end()
d745 2
a746 2
void view_setup() {}
void view_cleanup() {}
d764 1
a764 4
part_compact(ap, PartHeadp, tolerance)
register struct application		*ap;
register struct partition		*PartHeadp;
fastf_t					tolerance;
d839 1
a839 1
void application_init () {}
@


11.32
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d31 1
a31 1
 *	This software is Copyright (C) 1989 by the United States Army.
d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.31 2002/08/20 17:08:39 jra Exp $ (BRL)";
@


11.32.2.1
log
@merge from HEAD
@
text
@d31 1
a31 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.33 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.32.2.2
log
@merge from head
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.32.2.1 2004/02/12 19:37:14 erikg Exp $ (BRL)";
@


11.31
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.29 2002/07/23 18:11:10 jra Exp $ (BRL)";
d159 1
a159 1
	if(rdebug & RDEBUG_RAYPLOT) {
d425 1
a425 1
	if( rdebug || bu_debug || RT_G_DEBUG )  {
d533 1
a533 1
				if( rdebug & RDEBUG_HITS )
d644 1
a644 1
		if(rdebug & RDEBUG_RAYPLOT) {
@


11.31.4.1
log
@sync to HEAD...
@
text
@d31 1
a31 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/viewg3.c,v 11.33 2004/02/02 17:39:39 morrison Exp $ (BRL)";
d159 1
a159 1
	if(R_DEBUG & RDEBUG_RAYPLOT) {
d425 1
a425 1
	if( R_DEBUG || bu_debug || RT_G_DEBUG )  {
d533 1
a533 1
				if( R_DEBUG & RDEBUG_HITS )
d644 1
a644 1
		if(R_DEBUG & RDEBUG_RAYPLOT) {
@


11.31.2.1
log
@Initial ANSIfication
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.31 2002/08/20 17:08:39 jra Exp $ (BRL)";
d60 1
a60 1
void	part_compact(register struct application *ap, register struct partition *PartHeadp, fastf_t tolerance);
d105 1
a105 2
int	rayhit(register struct application *ap, struct partition *PartHeadp);
int     raymiss(register struct application *ap);
d119 3
a121 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d178 2
a179 1
view_2init(struct application *ap)
d234 1
a234 1
raymiss(register struct application *ap)
d245 1
a245 1
view_pixel(void)
d272 3
a274 1
rayhit(struct application *ap, register struct partition *PartHeadp)
d718 1
a718 1
void	view_eol(void)
d732 1
a732 1
view_end(void)
d749 2
a750 2
void view_setup(void) {}
void view_cleanup(void) {}
d768 4
a771 1
part_compact(register struct application *ap, register struct partition *PartHeadp, fastf_t tolerance)
d846 1
a846 1
void application_init (void) {}
@


11.31.2.2
log
@sync branch with HEAD
@
text
@d31 1
a31 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header$ (BRL)";
d158 1
a158 1
	if(R_DEBUG & RDEBUG_RAYPLOT) {
d421 1
a421 1
	if( R_DEBUG || bu_debug || RT_G_DEBUG )  {
d529 1
a529 1
				if( R_DEBUG & RDEBUG_HITS )
d640 1
a640 1
		if(R_DEBUG & RDEBUG_RAYPLOT) {
@


11.30
log
@Converted from K&R to ANSI C - RFH
@
text
@d60 1
a60 1
void	part_compact(register struct application *ap, register struct partition *PartHeadp, fastf_t tolerance);
d105 1
a105 2
int	rayhit(register struct application *ap, struct partition *PartHeadp);
int     raymiss(register struct application *ap);
d119 3
a121 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d178 2
a179 1
view_2init(struct application *ap)
d234 1
a234 1
raymiss(register struct application *ap)
d245 1
a245 1
view_pixel(void)
d272 3
a274 1
rayhit(struct application *ap, register struct partition *PartHeadp)
d718 1
a718 1
void	view_eol(void)
d732 1
a732 1
view_end(void)
d749 2
a750 2
void view_setup(void) {}
void view_cleanup(void) {}
d768 4
a771 1
part_compact(register struct application *ap, register struct partition *PartHeadp, fastf_t tolerance)
d846 1
a846 1
void application_init (void) {}
@


11.29
log
@Added first hit location to data output by '-c "set ray_data_file=ray_file_name"'
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.28 2001/05/17 20:06:07 morrison Exp $ (BRL)";
d60 1
a60 1
void	part_compact();
d105 2
a106 1
int	rayhit(), raymiss();
d120 1
a120 3
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
d177 1
a177 2
view_2init( ap )
struct application	*ap;
d232 1
a232 1
raymiss()
d243 1
a243 1
view_pixel()
d270 1
a270 3
rayhit( ap, PartHeadp )
struct application *ap;
register struct partition *PartHeadp;
d714 1
a714 1
void	view_eol()
d728 1
a728 1
view_end()
d745 2
a746 2
void view_setup() {}
void view_cleanup() {}
d764 1
a764 4
part_compact(ap, PartHeadp, tolerance)
register struct application		*ap;
register struct partition		*PartHeadp;
fastf_t					tolerance;
d839 1
a839 1
void application_init () {}
@


11.28
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.27 2001/04/05 19:36:04 morrison Exp $ (BRL)";
d99 1
a99 1
 -c \"set ray_data_file=ray_file_name\"         Specify ray data output file (az el x_start y_start z_start x_dir y_dir z_dir line_number_in_shotline_file)\n\
d287 2
d437 1
d550 5
d694 3
a696 2
		fprintf( shot_fp, "%.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %ld\n",
			azimuth, elevation, V3ARGS( ap->a_ray.r_pt ), V3ARGS( ap->a_ray.r_dir ), line_num );
@


11.27
log
@updated SIGNED to signed
updated CONST to const
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.26 2001/04/02 21:38:31 morrison Exp $ (BRL)";
d423 1
a423 1
	if( rdebug || bu_debug || rt_g.debug )  {
d483 1
a483 1
			if ( ! (rt_g.debug & DEBUG_ARB8)) {
@


11.26
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.25 2001/04/02 15:05:14 jra Exp $ (BRL)";
d87 1
a87 1
CONST char usage[] = "\
@


11.25
log
@Lint
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.24 2001/03/19 22:20:15 butler Exp $ (BRL)";
d220 1
a220 1
	bn_mat_copy( model2hv, Viewrotscale );
@


11.24
log
@patches to merge 5.3 into 6.0
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /d/CVS/brlcad/rt/viewg3.c,v 11.23 2001/01/22 20:28:57 jra Exp $ (BRL)";
d42 6
@


11.23
log
@Ray data output now gets 5 digits after decimal point
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.22 2000/12/05 15:49:12 jra Exp $ (BRL)";
d79 1
d117 1
a160 1

d216 2
d809 5
a813 6

		 /* bu_log("part_comp: collapsing gap of %e mm between id=%d and id=%d\n",
		  *	gap, pp->pt_regionp->reg_regionid, 
		  *	nextpp->pt_regionp->reg_regionid);
		  */
		
@


11.22
log
@Added support for rt_cline_radius and ray_data_file
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.21 2000/11/01 19:00:27 jra Exp $ (BRL)";
d677 1
a677 1
		fprintf( shot_fp, "%g %g %g %g %g %g %g %g %ld\n",
@


11.21
log
@Corrected air handling
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.20 2000/10/11 17:34:06 jra Exp $ (BRL)";
d65 6
d92 3
d123 8
d674 10
@


11.20
log
@Missing parens in usage statement
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.19 2000/08/17 19:30:53 mike Exp $ (BRL)";
d260 1
d270 1
a270 1
	/*  comp components in partitions */
d273 9
a281 1
		comp_count++;
d283 3
d408 1
d434 7
a440 3
		if( (region_id = pp->pt_regionp->reg_regionid) <= 0 )  {
			bu_log("air region '%s' found when solid region expected, using id=111\n", pp->pt_regionp->reg_name);
			region_id = 111;
d466 22
a487 3
			/* Last partition, no air follows, use code 9 */
			air_id = 9;
			air_thickness = 0.0;
d494 1
d509 1
d521 1
d629 8
d754 9
a762 1
		if(pp->pt_regionp->reg_regionid != nextpp->pt_regionp->reg_regionid)  {
d764 1
a764 1
		}
@


11.19
log
@
Added additional debugging output
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.18 2000/08/17 02:41:39 mike Exp $ (BRL)";
d81 2
a82 2
 -g #		Grid cell width in millimeters (conflicts with -s\n\
 -G #		Grid cell height in millimeters (conflicts with -s\n\
@


11.18
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d35 1
a35 1
static const char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.17 2000/07/27 19:32:53 butler Exp $ (BRL)";
d362 1
a362 1
#define	SHOT_FMT	"%7.1f%7.1f%9.3f%9.3f%3d%8.2f%8.2f A%6.1f E%6.1f\n"
d368 1
a368 6
#ifdef SPRINTF_NOT_PARALLEL
	/* On some systems, sprintf() is not parallel! ^%@@#&^@@^&#% */
	bu_semaphore_acquire( BU_SEM_SYSCALL );
#endif

	sprintf(buf, SHOT_FMT,
d374 19
a392 4
#ifdef SPRINTF_NOT_PARALLEL
	bu_semaphore_release( BU_SEM_SYSCALL );
#endif
	bu_vls_strcat( &str, buf );
@


11.17
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.16 2000/07/25 16:39:48 butler Exp $ (BRL)";
@


11.16
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.15 2000/05/19 18:00:51 jra Exp $ (BRL)";
d48 1
a48 1

@


11.15
log
@Added support for -R option
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.14 2000/05/18 21:08:34 jra Exp $ (BRL)";
d49 1
a49 1
#include "rdebug.h"
@


11.15.2.1
log
@Added "ray_data_file" as a settable variable to get optional ray data output in rtg3
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.15 2000/05/19 18:00:51 jra Exp $ (BRL)";
a64 3
struct bu_vls	ray_data_file;	/* file name for ray data output */
FILE	*shot_fp;		/* FILE pointer for ray data output */

a72 1
static long	line_num;		/* count of lines output to shotline file */
a85 2
 -c \"set ray_data_file=ray_file_name\"		Specify ray data output file (az el x_start y_start z_start x_dir y_dir z_dir line_number_in_shotline_file)\n\
 -c \"set save_overlaps=1\"	Reproduce FASTGEN behavior for regions flagged as FASTGEN regions\n\
a106 1
	line_num = 1;
a113 8
	if( ray_data_file.vls_magic == BU_VLS_MAGIC ) {
		if( (shot_fp=fopen( bu_vls_addr( &ray_data_file ), "w" )) == NULL ) {
			perror( "RTG3" );
			bu_log( "Cannot open ray data output file %s\n", bu_vls_addr( &ray_data_file ) );
			bu_bomb( "Cannot open ray data output file\n" );
		}
	}

a197 2

	line_num += 2;
a599 10

	if( shot_fp )
	{
		fprintf( shot_fp, "%g %g %g %g %g %g %g %g %d\n",
			azimuth, elevation, V3ARGS( ap->a_ray.r_pt ), V3ARGS( ap->a_ray.r_dir ), line_num );

		line_num +=  1 + (comp_count / 3 );
		if( comp_count % 3 )
			line_num++;
	}
@


11.15.2.2
log
@Moved definition of ray_data_file from viewg3.c to do.c
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.15.2.1 2000/10/25 19:03:11 jra Exp $ (BRL)";
d65 1
a65 1
extern struct bu_vls	ray_data_file;	/* file name for ray data output (declared in do.c) */
@


11.15.2.3
log
@Corrected handling of air
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.15.2.2 2000/10/26 12:48:52 jra Exp $ (BRL)";
a276 1
	int			prev_id=-1;
d286 1
a286 1
	/* count components in partitions */
d289 1
a289 9
		if( pp->pt_regionp->reg_regionid > 0 ) {
			prev_id = pp->pt_regionp->reg_regionid;
			comp_count++;
		} else if( prev_id <= 0 ) {
			/* normally air would be output along with a solid partition, but this will require a '111' partition */
			prev_id = pp->pt_regionp->reg_regionid;
			comp_count++;
		} else
			prev_id = pp->pt_regionp->reg_regionid;
a290 3
	pp = PartHeadp->pt_back;
	if( pp!=PartHeadp && pp->pt_regionp->reg_regionid <= 0 )
		comp_count++;  /* a trailing '111' ident */
a402 1
	prev_id = -1;
d428 3
a430 7
		region_id = pp->pt_regionp->reg_regionid;

		if( region_id <= 0 && prev_id > 0 )
		{
			/* air region output with previous partition */
			prev_id = region_id;
			continue;
d456 3
a458 22
			if( region_id <= 0 ) {
				/* last partition is air, need a 111 'phantom armor' before AND after */
				bu_log( "WARNING: adding 'phantom armor' (id=111) with zero thickness before and after air region %s\n",
					 pp->pt_regionp->reg_name );
				region_id = 111;
				air_id = pp->pt_regionp->reg_aircode;
				air_thickness = comp_thickness;
				comp_thickness = 0.0;
			} else {
				/* Last partition, no air follows, use code 9 */
				air_id = 9;
				air_thickness = 0.0;
			}
		} else if( region_id <= 0 ) {
			/* air region, need a 111 'phantom armor' */
			bu_log( "WARNING: adding 'phantom armor' (id=111) with zero thickness before air region %s\n",
				 pp->pt_regionp->reg_name );
			prev_id = region_id;
			region_id = 111;
			air_id = pp->pt_regionp->reg_aircode;
			air_thickness = comp_thickness;
			comp_thickness = 0.0;
a464 1
			prev_id = air_id;
a478 1
			prev_id = region_id;
a489 1
out:
a596 8
		if( nextpp == PartHeadp && air_id != 9 ) {
			/* need to output a 111 'phantom armor' at end of shotline */
			air_id = 9;
			air_thickness = 0.0;
			region_id = 111;
			comp_thickness = 0.0;
			goto out;
		}
d724 1
a724 9
		if( pp->pt_regionp->reg_regionid > 0 && nextpp->pt_regionp->reg_regionid > 0 ) {
			if(pp->pt_regionp->reg_regionid != nextpp->pt_regionp->reg_regionid)  {
				continue;
			}
		} else if( pp->pt_regionp->reg_regionid <= 0 && nextpp->pt_regionp->reg_regionid <= 0 ) {
			if( pp->pt_regionp->reg_aircode != nextpp->pt_regionp->reg_aircode ) {
				continue;
			}
		} else
d726 1
a726 1

d742 4
a745 4
		  bu_log("part_comp: collapsing gap of %e mm between id=%d and id=%d air=%d and air=%d\n",
		 	gap, pp->pt_regionp->reg_regionid, 
		 	nextpp->pt_regionp->reg_regionid, pp->pt_regionp->reg_aircode, nextpp->pt_regionp->reg_aircode);
		 
@


11.15.2.4
log
@ifdef'd out some debug prints
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.15.2.3 2000/11/01 18:41:05 jra Exp $ (BRL)";
d796 1
a796 1
#if 0
d800 2
a801 1
#endif
@


11.15.2.5
log
@Mods to support CLINE radius addition
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.15.2.4 2000/11/01 18:46:55 jra Exp $ (BRL)";
a64 2
extern fastf_t	rt_cline_radius;	/* from g_cline.c */

a91 1
 -c \"set rt_cline_radius=radius\"	Additional radius to be added to CLINE solids\n\
d156 1
@


11.15.2.6
log
@Ray data output now gets 5 digits after decimal point
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.15.2.5 2000/11/22 13:37:09 jra Exp $ (BRL)";
d669 1
a669 1
		fprintf( shot_fp, "%.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %d\n",
@


11.14
log
@
Added code to check for negative air gap caused by FASTGEN plate mode overlap handling.
If found, sets air gap to zero.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.13 2000/05/18 20:23:28 jra Exp $ (BRL)";
d63 2
d128 3
@


11.13
log
@
Mods for the new FASTGEN entities.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.12 1999/11/24 22:17:07 mike Exp $ (BRL)";
d448 2
@


11.12
log
@
Removed obsolete header files
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.11 1999/07/02 22:19:46 mike Exp $ (BRL)";
d258 3
@


11.11
log
@
Removed dependence on compat4.h
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.10 1999/05/28 01:19:29 mike Exp $ (BRL)";
a44 1
#include "rtstring.h"
@


11.10
log
@
sed4
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.9 1998/09/22 00:21:29 mike Exp $ (BRL)";
d66 1
a66 1
	{"",	0, (char *)0,	0,		FUNC_NULL }
d358 1
a358 1
		ae_vec( &azimuth, &elevation, ap->a_ray.r_dir );
@


11.9
log
@Doesn't need material.h
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewg3.c,v 11.8 1997/12/16 00:20:11 mike Exp $ (BRL)";
d133 1
a133 1
			rt_log("Note: writing rtg3.pl file can only be done using only 1 processor\n");
d192 1
a192 1
	mat_copy( model2hv, Viewrotscale );
d252 1
a252 1
	struct rt_vls		str;
d276 2
a277 2
	rt_vls_init( &str );
	rt_vls_extend( &str, 80 * (comp_count+1) );
d327 1
a327 1
	 * rt_log("dcorrection=%g\n", dcorrection);
d339 3
a341 3
			rt_log("ERROR: dfirst=%g at partition x%x\n", dfirst , PartHeadp->pt_forw );
			rt_log("\tdcorrection = %f\n" , dcorrection );
			rt_log("\tray start point is ( %f %f %f ) in direction ( %f %f %f )\n" , V3ARGS( ap->a_ray.r_pt ) , V3ARGS( ap->a_ray.r_dir ) );
d375 1
a375 1
	rt_vls_strcat( &str, buf );
d405 1
a405 1
			rt_log("air region '%s' found when solid region expected, using id=111\n", pp->pt_regionp->reg_name);
d419 1
a419 1
			rt_log("ERROR: comp_thickness=%g for region id = %d at h=%g, v=%g (x=%d, y=%d), partition at x%x\n",
d422 1
a422 1
			rt_log("Send this output to Sue Muuss (sue@@brl.mil)\n");
d449 1
a449 1
					rt_log("air gap added\n");
d472 1
a472 1
			mat_radtodeg;
d481 1
a481 1
			mat_radtodeg;
d486 1
a486 1
			rt_log("ERROR: in_obliquity=%g\n", in_obliq);
d490 1
a490 1
			rt_log("ERROR: out_obliquity=%g\n", out_obliq);
d493 1
a493 1
			rt_log("dot=%g, acos(dot)=%g\n",
d517 1
a517 1
			rt_vls_strcat( &str, " " );
d536 1
a536 1
		rt_vls_strcat( &str, buf );
d539 1
a539 1
			rt_vls_strcat( &str, "\n" );
d580 1
a580 1
		rt_vls_strcat( &str, "\n" );
d590 1
a590 1
	fputs( rt_vls_addr( &str ), outfp );
d596 1
a596 1
	rt_vls_free( &str );
d694 1
a694 1
		 * rt_log("gap=%e\n", gap);
d706 1
a706 1
		 /* rt_log("part_comp: collapsing gap of %e mm between id=%d and id=%d\n",
@


11.8
log
@Converted to bu_semaphore_acquire()
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 11.7 1997/01/02 21:04:59 jra Exp mike $ (BRL)";
a46 1
#include "./material.h"
@


11.7
log
@removed extra declaration of "extern double mat_radtodeg".
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 11.6 1996/10/15 17:35:34 jra Exp jra $ (BRL)";
d364 1
a364 1
	RES_ACQUIRE( &rt_g.res_syscall );
d374 1
a374 1
	RES_RELEASE( &rt_g.res_syscall );
d527 1
a527 1
		RES_ACQUIRE( &rt_g.res_syscall );
d535 1
a535 1
		RES_RELEASE( &rt_g.res_syscall );
d589 1
a589 1
	RES_ACQUIRE( &rt_g.res_syscall );
d594 1
a594 1
	RES_RELEASE( &rt_g.res_syscall );
@


11.6
log
@Removed excess error message and corrected gift_grid_rounding value assignment.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 11.5 1996/08/30 00:08:21 butler Exp jra $ (BRL)";
a60 1
extern double	mat_radtodeg;
@


11.5
log
@structparse moved to libbu
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 11.4 1996/03/29 23:20:55 mike Exp butler $ (BRL)";
d121 2
a700 7
		}
		if(pp->pt_regionp == nextpp->pt_regionp)  {
			/* If same region, then is a librt problem */
			rt_log("WARNING: part_comp: region_id's are identical %d\n last=%s\n next=%s\n",
				pp->pt_regionp->reg_regionid,
				pp->pt_regionp->reg_name,
				nextpp->pt_regionp->reg_name );
@


11.4
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 11.3 1995/12/06 17:57:53 pjt Exp mike $ (BRL)";
d67 1
a67 1
struct structparse view_parse[] = {
@


11.3
log
@Added a stub for application_init()
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 11.2 1995/08/16 17:48:51 jra Exp pjt $ (BRL)";
d464 1
a464 7
		/* next macro must be on one line for 3d compiler */
		RT_HIT_NORM( pp->pt_inhit, pp->pt_inseg->seg_stp, &(ap->a_ray) );
		if( pp->pt_inflip )  {
			VREVERSE( normal, pp->pt_inhit->hit_normal );
		} else {
			VMOVE( normal, pp->pt_inhit->hit_normal );
		}
d473 1
a473 7
		/* next macro must be on one line for 3d compiler */
		RT_HIT_NORM( pp->pt_outhit, pp->pt_outseg->seg_stp, &(ap->a_ray) );
		if( pp->pt_outflip )  {
			VREVERSE( normal, pp->pt_outhit->hit_normal );
		} else {
			VMOVE( normal, pp->pt_outhit->hit_normal );
		}
@


11.2
log
@Fixed bug in obliquity calculation, mod to part compact to eliminate zero length partitions.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 11.1 95/01/04 10:01:26 mike Rel4_4 $ (BRL)";
d746 2
@


11.1
log
@Release_4.4
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 10.8 94/11/05 03:07:01 mike Exp $ (BRL)";
d267 2
d336 1
a336 1

d347 1
a347 1

d399 1
d415 1
a422 1
#if 0
d428 1
a429 1
		}
d471 7
a477 1
		in_obliq = acos( -VDOT( ap->a_ray.r_dir, normal ) ) *
d486 7
a492 1
		out_obliq = acos( VDOT( ap->a_ray.r_dir, normal ) ) *
d496 1
d513 10
d679 15
@


10.8
log
@Irix 6
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 10.7 94/08/22 19:34:25 gdurf Exp Locker: mike $ (BRL)";
@


10.7
log
@Factored ifdefs
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 10.6 1994/08/11 02:46:34 gdurf Exp gdurf $ (BRL)";
d75 1
a75 1
char usage[] = "\
a152 6

	point_t		model_origin;		/* origin in model coordinates */
	point_t		v_model_origin;		/* model origin shifted to view space coordinates */
	vect_t		temp;
	vect_t		m_temp, g_tmp;

a246 2
	struct partition	*np;	/* next partition */
	struct partition	air;
@


10.6
log
@Added include of conf.h
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 10.5 1994/03/01 18:07:49 jra Exp gdurf $ (BRL)";
d367 2
a368 2
#ifdef SYSV
	/* On SysV, sprintf() is not parallel! ^%@@#&^@@^&#% */
d378 1
a378 1
#ifdef SYSV
d519 1
a519 1
#ifdef SYSV
d527 1
a527 1
#ifdef SYSV
@


10.5
log
@Added even more debug outbut
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 10.4 94/02/28 14:21:10 jra Exp Locker: jra $ (BRL)";
d37 2
@


10.4
log
@improved error messages for partitions with 0 or negative component thickness.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 10.3 92/06/03 15:23:35 sue Exp Locker: jra $ (BRL)";
d47 1
d343 5
a347 1
			rt_log("ERROR: dfirst=%g\n", dfirst);
d425 7
@


10.3
log
@Changed some comments and recompiled.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 10.2 92/05/12 08:31:41 sue Exp Locker: sue $ (BRL)";
d414 4
a417 2
			rt_log("ERROR: comp_thickness=%g at h=%g, v=%g (x=%d, y=%d)\n",
				comp_thickness, hv[0], hv[1], ap->a_x, ap->a_y);
@


10.2
log
@Commented out the warning message about compacting shotlines.  The 
message was panicking Dirk so he wanted it out.  The lines ought to be
left in the code so that they can be used for debugging purposes.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 10.1 91/10/12 06:42:20 mike Rel4_0 Locker: sue $ (BRL)";
a678 3
		  * pp->pt_outseg = nextpp->pt_outseg;
		  * pp->pt_outhit = nextpp->pt_outhit;
		  * pp->pt_outflip = nextpp->pt_outflip;
d680 5
@


10.1
log
@Release_4.0
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.20 91/08/19 21:55:57 mike Exp $ (BRL)";
d672 2
a673 1
		 * into one.
d675 8
a682 6
		rt_log("part_comp: collapsing gap of %e mm between id=%d and id=%d\n",
			gap, pp->pt_regionp->reg_regionid, 
			nextpp->pt_regionp->reg_regionid);
		pp->pt_outseg = nextpp->pt_outseg;
		pp->pt_outhit = nextpp->pt_outhit;
		pp->pt_outflip = nextpp->pt_outflip;
@


9.20
log
@Fixed serious bug in part compactor.
Enhanced diagnostics somewhat.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.19 91/07/06 00:35:29 mike Exp $ (BRL)";
@


9.19
log
@ANSI structure initialization
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.18 91/06/19 20:55:47 mike Exp $ (BRL)";
d330 1
a330 1
	 * fprintf(stderr, "dcorrection=%g\n", dcorrection);
d403 1
a403 1
			rt_log("air region found when solid region expected, using id=111\n");
d484 3
d620 2
a621 1
/*		P A R T _ C O M P A C T E R
d657 1
a657 1
		 * fprintf(stderr, "gap=%g \n", gap);
d663 6
a668 4
		if(pp->pt_regionp->reg_regionid == nextpp->pt_regionp->reg_regionid)  {
			/* librt problem */
			rt_log("WARNING: part_comp: region_id's are identical %d\n",
				pp->pt_regionp->reg_regionid);
d674 1
a674 1
		fprintf(stderr, "part_comp: collapsing gap of %gmm between id=%d and id=%d\n",
d677 2
a678 1
		pp->pt_outhit->hit_dist = nextpp->pt_outhit->hit_dist;
a679 1
		
d681 4
a684 1
		/* Now dequeue and free the nextpp */
@


9.18
log
@If cell width is given, use that to drive GIFT grid rounding.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.17 91/06/19 00:00:21 mike Exp $ (BRL)";
d65 1
a65 1
	"",	0, (char *)0,	0,		FUNC_NULL
@


9.17
log
@Simplified conversion into GIFT H,V space
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.16 91/06/05 09:10:04 sue Exp $ (BRL)";
d112 8
a119 2
	/* Cause grid_setup() to align the grid on inch boundaries */
	gift_grid_rounding = 25.4;
@


9.16
log
@Added a partition compacting subroutine to handle cases where a component
is made up of regions that are within a certain distance of one another
and all have the same region-id.  These should report as one component
rather than as a set of multiple components.  Part_comp() checks for this
condition and then collapses the partitions so that a component of this
nature is seen by only one inhit and oune outhit.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.15 91/06/03 15:54:53 sue Exp $ (BRL)";
d55 2
d68 2
a70 2
fastf_t		h_offset;
fastf_t		v_offset;
d112 3
d147 2
d180 1
a180 1
		azimuth, elevation, MAGNITUDE(dx_model)*MM2IN );
d182 6
a187 3
	/* Calculate the offset of the screen_space origin to the
	 * model_space origin.  First set the model origin to 0, 0, 0,
	 * and then convert it to view space coordinates.
d189 2
a190 7

	VSET(model_origin, 0, 0, 0);
	MAT4X3PNT(v_model_origin, model2view, model_origin);
	
	h_offset = (v_model_origin[X] + 1) * 0.5 * width * MAGNITUDE(dx_model);
	v_offset = (v_model_origin[Y] + 1) * 0.5 * height * MAGNITUDE(dy_model);

a246 2
	fastf_t			h, v;		/* h,v actual ray pos */
	fastf_t			hcen, vcen;	/* h,v cell center */
d253 2
d277 2
a278 2
	 *  GIFT format wants grid coordinates, which are the
	 *  h,v coordinates of the screen plain projected into model space.
d280 4
a283 11
	hcen = (ap->a_x + 0.5) * MAGNITUDE(dx_model) - h_offset;
	vcen = (ap->a_y + 0.5) * MAGNITUDE(dy_model) - v_offset;
	if( jitter )  {
		vect_t	hv;
		/*
		 *  Find exact h,v coordinates of ray by
		 *  projecting start point back into view coordinates,
		 *  and converting from view coordinates (-1..+1) to
		 *  screen (pixel) coordinates for h,v.
		 */
		MAT4X3PNT( hv, model2view, ap->a_ray.r_pt );
d285 4
a288 6
		h = (hv[X]+1)*0.5 * width * MAGNITUDE(dx_model) - h_offset;
		v = (hv[Y]+1)*0.5 * height * MAGNITUDE(dy_model) - v_offset;
	} else {
		/* h,v coordinates of ray are of the lower left corner */
		h = ap->a_x * MAGNITUDE(dx_model) - h_offset;
		v = ap->a_y * MAGNITUDE(dy_model) - v_offset;
d291 7
a297 4
	/* This code is for diagnostics.
	 *	fprintf(stderr, " h_offset=%g, v_offset=%g, hcen=%g, vcen=%g, h=%g, v=%g\n",
	 *	h_offset, v_offset, hcen, vcen, h);
	 *
d301 1
a301 1
	 *  the screen plane translated so that it contains the origin.
d360 2
a361 2
		hcen * MM2IN, vcen * MM2IN,
		h * MM2IN, v * MM2IN,
d409 1
a409 1
				comp_thickness, h , v, ap->a_x, ap->a_y);
@


9.15
log
@Moved the RT emanation plane to coincide with the GIFT grid plane.  This
produced results that John Hundley (Ketron) and Dirk T. Broek and John
Anderson of ASB found to be fine.  Also removed the trailing 0: it tunrs
out that that was supperfluous and GIFT just truncated the  last full line
I put out to just show the first 999.9.  Dirk and Bob Stadter (Ketron)
agreed I should leave the whole lijen in but just take oout the last 0.
Asked about  trailing 0 suppression in floatiing pooint numbers, the consensus was 
to leave them in.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.14 91/03/19 11:53:20 sue Exp $ (BRL)";
a50 1
#ifdef
d53 1
a53 2
 void	part_compact();
#endif
d55 1
d254 2
a255 3
/*	part_compacter(ap, Partheadp, TOL);
 *
 */
d258 1
a258 1
	for( pp=PartHeadp->pt_forw; pp!=PartHeadp; pp=pp->pt_forw )
d260 1
d626 1
a626 1
part_compacter(ap, PartHeadp, tolerance)
d636 2
a637 1
	for(pp = PartHeadp; pp != PartHeadp; pp = pp->pt_forw)  {
d639 1
a639 1
		if(nextpp == PartHeadp)
d641 2
a642 1
		if(pp->pt_regionp->reg_regionid != nextpp->pt_regionp->reg_regionid)
d644 8
a651 2
		gap = nextpp->pt_inhit->hit_dist - pp->pt_inhit->hit_dist;
		if(gap > tolerance)
d653 1
d656 2
a657 1
			rt_log("WARNING: region_id's are identical %d\n");
d663 3
a665 1

d671 3
a673 3
/*		DEQUEUE_PT(nextpp);
 *		FREE_PT(nextpp, ap->a_resource);
 */
@


9.14
log
@Added code to compact partition lists if regions with identical region
id abut and are less than a certain tolerance distance appart.  Some of
the code has been commented out since I'm still waiting on a figure to
use for the tolernce.
@
text
@d22 1
a22 1
 *	Dr. Susanne L. Muuss
d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.13 91/03/13 21:29:59 mike Exp $ (BRL)";
d51 2
a52 4
/* #define TOL
 *
 * void	part_compact();
 */
d54 3
d68 2
d78 3
a80 2
 -g		Grid cell width in millimeters\n\
 -G		Grid cell height in millimeters\n\
d141 3
d176 11
a186 1
	regionfix( ap, "rtray.regexp" );		/* XXX */
d246 1
a246 1
	fastf_t			dcorrection = 0; /* RT to GIFT dist corr */
d255 1
a255 1
/*	part_compacter(Partheadp, TOL);
d276 2
a277 2
	hcen = (ap->a_x + 0.5) * MAGNITUDE(dx_model);
	vcen = (ap->a_y + 0.5) * MAGNITUDE(dy_model);
d288 2
a289 2
		h = (hv[X]+1)*0.5 * width * MAGNITUDE(dx_model);
		v = (hv[Y]+1)*0.5 * height * MAGNITUDE(dy_model);
d292 2
a293 2
		h = ap->a_x * MAGNITUDE(dx_model);
		v = ap->a_y * MAGNITUDE(dy_model);
d296 5
a300 2
	/*
	 *  In RT, rays are launched from the plain of the screen,
d303 1
a303 1
	 *  the screen plain translated so that it contains the origin.
a323 2
	dfirst = PartHeadp->pt_forw->pt_inhit->hit_dist + dcorrection;
	dlast = PartHeadp->pt_back->pt_outhit->hit_dist + dcorrection;
d325 11
d337 1
a337 1
		if( dfirst < 0)  {
d587 2
a588 2
 *  a "999.9" shotline header, with one
 *  all-zero component record.  Note that the component count must also
d600 6
a605 2
	/* An abbreviated component record:  just give item code 0 */
	fprintf(outfp, " %4d\n", 0 );
d615 4
a618 3
 * This routine takes at partition-head pointer and a tolerance.  It goes
 * throught the partition list shot-line by shot-line and checks for regions
 * with identical region-id abutting.  If one is found, and the distance
d627 2
a628 1
part_compacter(PartHeadp, tolerance)
d661 1
a661 1
 *		free(nextpp);
@


9.13
log
@Added some debugging code that was useful in tracking down the
TGC problem, but may also be generally useful.
Since it is very cheap, it might as well stay in.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.12 91/03/08 19:40:38 sue Exp $ (BRL)";
d51 4
d238 3
d307 1
a307 1
/* This code is to note any occurances of negative distances. */
d312 2
a313 1
/* End of bug trap. */
d578 54
@


9.12
log
@Added an extension to the comments about the variable length strings.
Made permanent the error-checking code that is to look for greater
than 90 degree out-obliquities.  For the moment have in place code to
check for and highlight negative in-hit distances.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.11 91/03/02 03:03:22 mike Exp $ (BRL)";
d358 1
d415 3
a417 3
			VREVERSE( pp->pt_inhit->hit_normal,
				  pp->pt_inhit->hit_normal );
			pp->pt_inflip = 0;
d419 2
a420 2
		in_obliq = acos( -VDOT( ap->a_ray.r_dir,
			pp->pt_inhit->hit_normal ) ) * mat_radtodeg;
d424 3
a426 3
			VREVERSE( pp->pt_outhit->hit_normal,
				  pp->pt_outhit->hit_normal );
			pp->pt_outflip = 0;
d428 2
a429 2
		out_obliq = acos( VDOT( ap->a_ray.r_dir,
			pp->pt_outhit->hit_normal ) ) * mat_radtodeg;
d432 5
a436 2

		if( out_obliq > 90)  {
d438 5
@


9.11
log
@On SGIs, (and probably most other SysV machines), sprintf()
can not be used in parallel!  Ouch!
Have to protect sprintf with critical sections.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.10 91/03/02 02:21:44 mike Exp $ (BRL)";
d239 6
a244 1
	/* Set up variable length string, to buffer this shotline in */
d300 6
d312 1
d314 1
d318 1
d323 1
d429 7
@


9.10
log
@Modified so that RDEBUG_PLOT will force single CPU only.
(To prevent output garbling in the plot file).
Modified to reduce the size of the critical section
in view_hit down to just one fputs().
Used Variable Length String (rt_vls) package to make it easy.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.9 91/03/02 02:05:39 sue Exp $ (BRL)";
d305 4
d315 3
d428 3
d436 3
@


9.9
log
@Added error checking code to learn more about negative thickness.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.8 91/03/01 15:03:06 sue Exp $ (BRL)";
d43 1
d53 1
a55 1
int		using_mlib = 0;		/* Material routines NOT used */
d111 4
d228 2
d239 4
a266 7
	/* Single-thread through the printf()s.
	 * COVART will accept non-sequential ray data provided the
	 * ray header and its associated data are not separated.  CAVEAT:
	 * COVART will not accept headers out of sequence.
	 */
	RES_ACQUIRE( &rt_g.res_syscall );

d305 1
a305 1
	fprintf(outfp, SHOT_FMT,
d311 1
d413 1
a413 1
			putc( ' ', outfp );
d421 1
a421 1
		fprintf(outfp, fmt,
d426 1
d429 1
a429 1
			putc( '\n', outfp );
d439 2
a441 1

d470 1
a470 1
		putc( '\n', outfp );
d473 9
d484 3
@


9.8
log
@Added code for catching negative component thicknesses.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.7 91/02/20 00:51:32 mike Exp $ (BRL)";
d340 9
a348 9
/* The following code has been added to track an ellusive problem with
 * negative thicknesses.  It will be removed when the bug is found.
 */

		if(comp_thickness == 0 || comp_thickness < 0 )  {
			rt_log("WARNING: comp_thickness=%g at position h=%g, v=%g in partition list:\n",
				comp_thickness, h , v);
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "whatdoyouwant?");
			rt_log("Contact Sue Muuss (sue@@brl) with this information\n");
a350 2
/* End of bug-report code. */
			
@


9.7
log
@Added new view-module interface called view_setup() which is used
for initializing material properties, lights, etc.
It compliments view_cleanup(), and finally removed knowledge of
the view.c materials (and all the shaders) from the RT "top half".
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.6 91/01/05 03:09:24 mike Exp $ (BRL)";
d339 14
@


9.6
log
@Converted to new format for fmt entry in structparse
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.5 90/12/12 16:35:17 butler Exp $ (BRL)";
d493 1
@


9.5
log
@modified to reflect changes in structparse format
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.4 90/12/07 00:55:06 mike Exp $ (BRL)";
d58 1
a58 1
	(char *)0, 0, (char *)0,	0,		FUNC_NULL
@


9.4
log
@lint
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.3 90/11/26 13:24:09 sue Exp $ (BRL)";
d58 1
a58 1
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.3
log
@Made two changes: changed the grid size output format to %f to preserve
a decimal point even for integers.  The client codes need the decimal
point in order to get the grid size correct.  Also changed the component
count on the last line from 1 to 0, since it is possible to have a valid
shotline of the sort listed there is there is one component for that
shotline.  Apparently, a lot of the client codes key more on the zero
component than on the 999.99's on the last line.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.2 90/11/14 15:43:39 mike Exp $ (BRL)";
d220 1
a220 1
	fastf_t			dcorrection;	/* RT to GIFT dist corr */
@


9.2
log
@As part of "clean" command, call "view_cleanup()", to allow
viewing module the opportunity to clean up things like implicit
light sources, etc.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.1 89/05/19 05:59:55 mike Rel3_5 $ (BRL)";
d151 4
d157 1
a157 1
		"     %-15.8f     %-15.8f                              %10g\n",
d476 2
a477 1
 *  all-zero component record.
d485 1
a485 1
		1,			/* component count */
@


9.1
log
@Release_3.5
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.30 89/05/11 01:21:24 phil Exp $ (BRL)";
d487 2
@


9.1.1.1
log
@This is the 13-March-91 version of viewg3.c,
back-ported to operate in the environment of BRL-CAD Release 3.7
@
text
@a0 4
/* This is the 13-March-91 version of viewg3.c,
 * back-ported to operate in the environment of BRL-CAD Release 3.7
 */

d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: /m/cad/rt/RCS/viewg3.c,v 9.13 91/03/13 21:29:59 mike Exp $ (BRL)";
a51 1
extern int	npsw;			/* number of worker PSWs to run */
d58 1
a58 1
	"",	(char *)0,	0,		FUNC_NULL
a109 4
		if( npsw > 1 )  {
			rt_log("Note: writing rtg3.pl file can only be done using only 1 processor\n");
			npsw = 1;
		}
a150 4
	 * NOTE:  %10g was changed to %10f so that a decimal point is generated
	 * even when the number is an integer.  Otherwise the client codes
	 * get confused get confused and are unable to convert the number to
	 * scientific notation.
d153 1
a153 1
		"     %-15.8f     %-15.8f                              %10f\n",
d216 1
a216 1
	fastf_t			dcorrection = 0; /* RT to GIFT dist corr */
a227 6
	/* Set up variable length string, to buffer this shotline in.
	 * Note that there is one component per card, and that each card
	 * (line) is 80 characters long.  Hence the parameters given to
	 * rt-vls-extend().
	 */

d252 7
a286 6
/* This code is to note any occurances of negative distances. */
		if( dfirst < 0)  {
			rt_log("ERROR: dfirst=%g\n", dfirst);
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "Defective partion:");
		}
/* End of bug trap. */
a292 1

a293 1

a296 5

#ifdef SYSV
	/* On SysV, sprintf() is not parallel! ^%@@#&^@@^&#% */
	RES_ACQUIRE( &rt_g.res_syscall );
#endif
a302 3
#ifdef SYSV
	RES_RELEASE( &rt_g.res_syscall );
#endif
a326 1
		vect_t	normal;		/* surface normal */
a334 12

		/* The below code is meant to catch components with zero or
		 * negative thicknesses.  This is not supposed to be possible,
		 * but the condition has been seen.
		 */
		if( comp_thickness <= 0 )  {
			rt_log("ERROR: comp_thickness=%g at h=%g, v=%g (x=%d, y=%d)\n",
				comp_thickness, h , v, ap->a_x, ap->a_y);
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "Defective partion:");
			rt_log("Send this output to Sue Muuss (sue@@brl.mil)\n");
		}

d371 3
a373 3
			VREVERSE( normal, pp->pt_inhit->hit_normal );
		} else {
			VMOVE( normal, pp->pt_inhit->hit_normal );
d375 2
a376 2
		in_obliq = acos( -VDOT( ap->a_ray.r_dir, normal ) ) *
			mat_radtodeg;
d380 3
a382 3
			VREVERSE( normal, pp->pt_outhit->hit_normal );
		} else {
			VMOVE( normal, pp->pt_outhit->hit_normal );
d384 2
a385 2
		out_obliq = acos( VDOT( ap->a_ray.r_dir, normal ) ) *
			mat_radtodeg;
a386 15
		/* Check for exit obliquties greater than 90 degrees. */
		if( in_obliq > 90 || in_obliq < 0 )  {
			rt_log("ERROR: in_obliquity=%g\n", in_obliq);
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "Defective partion:");
		}
		if( out_obliq > 90 || out_obliq < 0 )  {
			rt_log("ERROR: out_obliquity=%g\n", out_obliq);
			VPRINT(" r_dir", ap->a_ray.r_dir);
			VPRINT("normal", normal);
			rt_log("dot=%g, acos(dot)=%g\n",
				VDOT( ap->a_ray.r_dir, normal ),
				acos( VDOT( ap->a_ray.r_dir, normal ) ) );
			rt_pr_partitions(ap->a_rt_i, PartHeadp, "Defective partion:");
		}

d392 1
a392 1
			fprintf(outfp," ");
a399 3
#ifdef SYSV
		RES_ACQUIRE( &rt_g.res_syscall );
#endif
a404 3
#ifdef SYSV
		RES_RELEASE( &rt_g.res_syscall );
#endif
d407 1
a407 1
			fprintf(outfp, "\n");
a416 2
		 * This will always be done single CPU,
		 * to prevent output garbling.  (See view_init).
d418 1
d447 1
a447 1
		fprintf(outfp, "\n");
a449 7
	/* Single-thread through file output.
	 * COVART will accept non-sequential ray data provided the
	 * ray header and its associated data are not separated.  CAVEAT:
	 * COVART will not accept headers out of sequence.
	 */
	RES_ACQUIRE( &rt_g.res_syscall );

d472 1
a472 2
 *  all-zero component record.  Note that the component count must also
 *  be zero on this shotline, or else the client codes get confused.
d480 1
a480 1
		0,			/* component count */
a486 3

void view_setup() {}
void view_cleanup() {}
@


1.30
log
@added "millimeters" comment to usage message per John Anderson
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.29 89/05/09 15:30:48 phil Locked $ (BRL)";
@


1.29
log
@fixed the minus_o problem and allowed for other
than stdout. Also moved the header record write
down to view_2init so if -o filename the filename will
get opened first.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.28 89/04/24 08:56:38 stay Locked $ (BRL)";
d70 2
a71 2
 -g		Grid cell width\n\
 -G		Grid cell height\n\
@


1.28
log
@I missed the 2nd use of RT_HIT_NORM -- same problem on the 3d.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.27 89/04/24 08:53:28 mike Locked $ (BRL)";
d86 4
d96 1
a96 1
	if( outfp == NULL )
d98 3
a107 6
	/*
	 *  Overall header, to be read by COVART format:
	 *  9220 FORMAT( BZ, I5, 10A4 )
	 *	number of views, title
	 *  Initially, do only one view per run of RTG3.
	 */
a111 1
	fprintf(outfp,"%5d %s %s\n", 1, file, obj);
d130 8
@


1.27
log
@RT_HIT_NORM macro invocation had to be placed all on one line to
satisfy the sgi 3D compiler (ugh).
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.26 89/04/10 21:33:33 mike Locked $ (BRL)";
d369 2
a370 2
		RT_HIT_NORM( pp->pt_outhit,
			pp->pt_outseg->seg_stp, &(ap->a_ray) );
@


1.26
log
@Changed "air_thickness" to always be in mm.
This fixes the air plotting
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.25 89/04/10 21:10:39 mike Locked $ (BRL)";
d360 2
a361 2
		RT_HIT_NORM( pp->pt_inhit,
			pp->pt_inseg->seg_stp, &(ap->a_ray) );
@


1.25
log
@Moved many external declarations into ext.h
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.24 89/04/10 20:59:04 mike Locked $ (BRL)";
a386 1
		air_thickness *= MM2IN;
d388 1
a388 1
		if( comp_thickness > 999.99 || air_thickness > 999.9 )
d396 1
a396 1
			air_id, air_thickness );
@


1.24
log
@Handled azimuth/elevation derivation in perspecitve case.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.23 89/04/04 14:19:02 mike Locked $ (BRL)";
d45 1
a52 16
/***** view.c variables imported from rt.c *****/
extern int	output_is_binary;	/* !0 means output file is binary */
extern mat_t	view2model;
extern mat_t	model2view;

/***** worker.c variables imported from rt.c *****/
extern int	jitter;			/* jitter ray starting positions */
extern fastf_t	aspect;			/* view aspect ratio X/Y */
extern vect_t	dx_model;		/* view delta-X as model-space vect */
extern vect_t	dy_model;		/* view delta-Y as model-space vect */
extern point_t	eye_model;		/* model-space location of eye */
extern fastf_t	rt_perspective;		/* persp (degrees X) 0 => ortho */
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
/*****/

a53 1

d61 1
a61 5
FILE            *plotfp;		/* optional plotting file */

extern FILE	*outfp;			/* optional output file */

extern double	azimuth, elevation;
@


1.23
log
@Added cell-size options: grid cell_width and grid cell_height.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.22 89/04/04 05:02:25 sue Locked $ (BRL)";
d63 1
a81 1
extern vect_t	dx_model;		/* view delta-X as model-space vect */
a303 3
	 *
	 *  NOTE:  azimuth and elevation should really be computed
	 *  from ap->a_ray.r_dir;  for now, assume all rays are parallel.
d306 3
@


1.22
log
@Converted to new way of representing structure offsets.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.21 89/04/03 13:07:29 mike Locked $ (BRL)";
d90 2
@


1.21
log
@Updated and expanded comments.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.20 89/03/30 21:08:13 sue Locked $ (BRL)";
d72 3
a74 3
 struct structparse view_parse[] = {
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
 };
@


1.20
log
@Added support for parallel processing.
It is unknown whether COVART can handle rays being stored in
the file out-of-order.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.19 89/03/30 20:54:59 sue Locked $ (BRL)";
d201 2
a202 2
 *  distance along the ray.  RT has zero at the ray origin (emanation plane),
 *  while GIFT has zero at the screen plane translated so that it contains
d240 1
a240 1
	 *  h,v coordinates of the screen plane projected into model space.
d262 5
a266 1
	/* Single-thread through the printf()s */
d270 1
a270 1
	 *  In RT, rays are launched from the plane of the screen,
d273 1
a273 1
	 *  the screen plane translated so that it contains the origin.
@


1.19
log
@Improved and expended comments.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.18 89/03/21 09:42:32 sue Locked $ (BRL)";
a232 2


d262 3
d449 4
a452 2
		/* May need to zero-fill unused component slots
		 *  Not needed for COVART III, unknown for COVART II.
d456 4
@


1.18
log
@Added a trip_count fag to prevent the distance correction to be
recomputed for every ray.  Also, added a pl_color() prior to
pdv_3line() so that the first line will be colored, and changed the
pdv_3move() to pdv_cont() since the air_thickness was not supposed
to be skipped, but should be drawn in color.  Rtg3 compiles and 
"try" produces the expected results.  The color and plotting 
routines could not be tested due to lack of proper equipment at
my end.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.17 89/03/17 14:52:30 sue Locked $ (BRL)";
d137 1
a137 1
 *  View_2init is called by do_frame, which in turn is called by
d196 17
a212 10
 *  Rayhit() is called by rt_shootray() when a hit is detected.  It
 *  writes a hit to the ray file.
 *  This routine sets up the grid that will be used to fire rays at
 *  the model.  First, the grid origen is moved to the model's center
 *  to satisfy GIFT.  Likewise, the ray's starting position is adjusted
 *  to coincide with the cell-center, rather than its lower left corner.
 *  This too is a GIFT requirement.
 *  An optional rtg3.pl UnixPlot file is written, permitting the
 *  color graphic display of ray-model intersections.
 *  Finally, the individual ray headers are written.
d419 4
a422 3
		 * plotting filters such as pl-fb or pl-xxx.
		 * Inhits are assigned green; outhits are assigned
		 * blue.
@


1.17
log
@Comments concerning the optional UnixPlot file output were added.
A suggestion on where to move the viewing direction calculations
was made, and is pending approval..


@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.16 89/03/15 19:28:16 sue Locked $ (BRL)";
a226 1
/*  NOTE: wish to insert  "viewing direction" stuff here if feasible     */
d263 2
a264 1
	 *  XXX This really should be computed only once, not every time.
d267 2
d272 9
a280 5
		VSET( tmp, 0, 0, -1 );		/* viewing direction */
		MAT4X3VEC( viewZdir, view2model, tmp );
		VUNITIZE( viewZdir );
		/* dcorrection will typically be negative */
		dcorrection = VDOT( ap->a_ray.r_pt, viewZdir );
d424 1
d433 1
a433 2
				pdv_3move(plotfp, air_end);
				pl_color(plotfp, 0, 255, 0);	/* green */
@


1.16
log
@fixed minor typos.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.15 89/03/14 17:13:43 mike Locked $ (BRL)";
d203 2
d226 3
d403 7
@


1.15
log
@An optional plotting routine was added.  CAVEAT: this routine does not
compile as of this time.
Also, the comments were fleshed out further.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.14 89/03/14 12:06:11 sue Locked $ (BRL)";
d402 1
a402 1
			VJOIN(inpt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
d404 1
a404 1
			VJOIN(outpt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist,
d406 1
a406 1
			pd3v_line(plotfp, inpt,outpt);
d410 1
a410 1
				VJOIN(air_end, ap->a_ray.r_pt,
d413 3
a415 1
				pd3v_move(plotfp, air_end);
@


1.14
log
@More comments were fleshed out.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.13 89/03/13 16:54:51 sue Locked $ (BRL)";
d76 1
d101 2
a102 1
 *  header.
d125 3
a127 1
        fprintf(outfp,"%5d %s %s\n", 1, file, obj);
d129 2
d184 2
d196 8
a203 2
 *  Write a hit to the ray file.
 *  Also generate various forms of "paint".
d398 18
d430 3
d441 2
a442 1
 *  Output special 999.9 "end of view" marker, composed of
@


1.13
log
@Added some comments. 
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.12 89/03/11 23:28:55 sue Locked $ (BRL)";
d130 4
d150 3
a152 1
	 * and that (for now), the units are MM.
d167 2
@


1.12
log
@fixed usage message
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.11 89/03/10 04:58:23 mike Locked $ (BRL)";
d98 3
@


1.11
log
@Fixed outfp defaulting.
Rearranged subroutines into more logical order,
reflecting layout of output file
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.10 89/03/08 19:19:03 mike Locked $ (BRL)";
d89 2
a90 2
 -o model.ray	Specify output file, ray(5V) format (default=stdout)\n\
 -U #		Set use_air boolean to #\n\
@


1.10
log
@Moved "air gap" diagnostic onto a debugging flag.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.9 89/03/08 19:14:38 mike Locked $ (BRL)";
d94 1
a94 2
/* Null function -- handle a miss */
int	raymiss() { return(0); }
d96 8
a103 1
void	view_pixel() {}
d105 20
d126 49
a385 25
 *  			V I E W _ I N I T
 */
int
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
{
	ap->a_hit = rayhit;
	ap->a_miss = raymiss;
	ap->a_onehit = 0;

	output_is_binary = 0;		/* output is printable ascii */

	/*
	 *  Overall header, to be read by COVART format:
	 *  9220 FORMAT( BZ, I5, 10A4 )
	 *	number of views, title
	 *  Initially, do only one view per run of RTG3.
	 */
        fprintf(outfp,"%5d %s %s\n", 1, file, obj);

	return(0);		/* No framebuffer needed */
}

/*
a410 29
}

/*
 *			V I E W _ 2 I N I T
 */
void
view_2init( ap )
struct application	*ap;
{

	if( outfp == NULL )
		rt_bomb("outfp is NULL\n");

	/*
	 *  Header for each view, to be read by COVART format:
	 *  9230 FORMAT( BZ, 2( 5X, E15.8), 30X, E10.3 )
	 *	azimuth, elevation, grid_spacing
	 * NOTE that GIFT provides several other numbers that are not used
	 * by COVART;  this should be investigated.
	 * NOTE that grid_spacing is assumed to be square (by COVART),
	 * and that (for now), the units are MM.
	 * NOTE that variables "azimuth and elevation" are not valid
	 * when the -M flag is used.
	 */
	fprintf(outfp,
		"     %-15.8f     %-15.8f                              %10g\n",
		azimuth, elevation, MAGNITUDE(dx_model)*MM2IN );

	regionfix( ap, "rtray.regexp" );		/* XXX */
@


1.9
log
@Modified to send output via outfp.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.8 89/03/08 18:51:08 mike Locked $ (BRL)";
d239 2
a240 1
				rt_log("air gap added\n");
@


1.8
log
@This version outputs distances in inches (not mm).
999.9 end-of-view marker is output.
Variable component format selection implemented
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.7 89/03/08 17:49:21 mike Locked $ (BRL)";
d53 1
d184 1
a184 1
	fprintf(stdout, SHOT_FMT,
d278 1
a278 1
			putc( ' ', stdout );
d287 1
a287 1
		fprintf(stdout, fmt,
d294 1
a294 1
			putc( '\n', stdout );
d304 1
a304 1
		putc( '\n', stdout );
d321 1
a321 2
	if( minus_o )
		rt_bomb("error is only to stdout\n");
d329 1
a329 1
        fprintf(stdout,"%5d %s %s\n", 1, file, obj);
d351 1
a351 1
	fprintf(stdout, SHOT_FMT,
d358 2
a359 2
	fprintf(stdout, " %4d\n", 0 );
	fflush(stdout);
d370 2
a371 2
	if( stdout == NULL )
		rt_bomb("stdout is NULL\n");
d384 1
a384 1
	fprintf(stdout,
@


1.7
log
@Per-component data is now output 3 per line.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.6 89/02/23 21:00:35 mike Locked $ (BRL)";
d48 2
d118 1
d182 4
a185 2
	fprintf(stdout,"%7.1f%7.1f%9.3f%9.3f%3d%8.2f%8.2f A%6.1f E%6.1f\n",
		hcen, vcen, h, v,
d187 1
a187 1
		dfirst, dlast,
d246 5
a250 4
		 *  the "elevation/declension" angle off the normal vector.
		 *  RT normals always point outwards, but the obliquity
		 *  angle seems be interpreted differently between
		 *  in_obliq and out_obliq, hence the sign change.  Check this.
d279 8
a286 1
		fprintf(stdout,"%4d%6.2f%5.1f%5.1f%1d%5.1f",
d334 6
a339 1
void	view_eol() {;}
d341 7
d351 8
a358 1
	/* Need to output special 999.9 record here */
d362 3
d386 1
a386 1
		azimuth, elevation, MAGNITUDE(dx_model) );
@


1.6
log
@Component record seems to be printing nicely.
Still need to convert units to inches,
bunch up 3 components/line.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.5 89/02/13 22:26:12 sue Locked $ (BRL)";
d110 1
a110 1
	int 			count;
d115 1
d120 2
a121 2
	/*  count components in partitions */
	count = 0;
d123 1
a123 1
		count++;
d181 1
a181 1
		count,
d186 1
d266 8
a273 1
		fprintf(stdout,"%4d%6.2f%5.1f%5.1f%1d%5.1f\n",
d278 5
d285 7
@


1.5
log
@Shotline header record now prints nicely.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.4 89/02/13 09:00:40 sue Locked $ (BRL)";
d39 1
d48 2
d154 1
a156 1
#if 0
d162 2
a163 1
VPRINT("viewZdir", viewZdir);
a164 4
printf("dcorr=%g\n", dcorrection);
#else
dcorrection = 0.0;	/* hack, for now */
#endif
d200 7
a206 3
		fprintf(stdout," component and air data for '%s'\n",
			pp->pt_regionp->reg_name );
	}
d208 3
a210 18
#if 0
	/* "1st entry" paint */
	RT_HIT_NORM( pp->pt_inhit, pp->pt_inseg->seg_stp, &(ap->a_ray) );
	if( pp->pt_inflip )  {
		VREVERSE( pp->pt_inhit->hit_normal, pp->pt_inhit->hit_normal );
		pp->pt_inflip = 0;
	}

	wraypaint( pp->pt_inhit->hit_point, pp->pt_inhit->hit_normal,
		PAINT_FIRST_ENTRY, ap, outfp );

	for( ; pp != PartHeadp; pp = pp->pt_forw )  {
		/* Write the ray for this partition */
		RT_HIT_NORM( pp->pt_inhit, pp->pt_inseg->seg_stp, &(ap->a_ray) );
		if( pp->pt_inflip )  {
			VREVERSE( pp->pt_inhit->hit_normal,
				  pp->pt_inhit->hit_normal );
			pp->pt_inflip = 0;
d212 22
a233 8

		if( pp->pt_outhit->hit_dist < INFINITY )  {
			RT_HIT_NORM( pp->pt_outhit,
				pp->pt_outseg->seg_stp, &(ap->a_ray) );
			if( pp->pt_outflip )  {
				VREVERSE( pp->pt_outhit->hit_normal,
					  pp->pt_outhit->hit_normal );
				pp->pt_outflip = 0;
a235 1
		wray( pp, ap, outfp );
a236 1

d238 6
a243 3
		 * If there is a subsequent partition that does not
		 * directly join this one, output an invented
		 * "air" partition between them.
d245 6
a250 9
		if( (np = pp->pt_forw) == PartHeadp )
			break;		/* end of list */

		/* Obtain next inhit normals & hit point, for code below */
		RT_HIT_NORM( np->pt_inhit, np->pt_inseg->seg_stp, &(ap->a_ray) );
		if( np->pt_inflip )  {
			VREVERSE( np->pt_inhit->hit_normal,
				  np->pt_inhit->hit_normal );
			np->pt_inflip = 0;
d252 8
a259 29

		if( rt_fdiff( pp->pt_outhit->hit_dist,
			      np->pt_inhit->hit_dist) >= 0 )  {
			/*
			 *  The two partitions touch (or overlap!).
			 *  If both are air, or both are solid, then don't
			 *  output any paint.
			 */
			if( pp->pt_regionp->reg_regionid > 0 )  {
				/* Exiting a solid */
				if( np->pt_regionp->reg_regionid > 0 )
					continue;	/* both are solid */
				/* output "internal exit" paint */
/*				 wraypaint( pp->pt_outhit->hit_point,
 *			       		pp->pt_outhit->hit_normal,
 *				 	PAINT_INTERN_EXIT, ap, outfp );
*/				

			} else {
				/* Exiting air */
				if( np->pt_regionp->reg_regionid <= 0 )
					continue;	/* both are air */
				/* output "internal entry" paint */
/*				 wraypaint( np->pt_inhit->hit_point,
 *				 	np->pt_inhit->hit_normal,
*/					PAINT_INTERN_ENTRY, ap, outfp );

			}
			continue;
d261 2
d264 5
a268 21
		/*
		 *  The two partitions do not touch.
		 *  Put "internal exit" paint on out point,
		 *  Install "general air" in between,
		 *  and put "internal entry" paint on in point.
		 */
/*		 wraypaint( pp->pt_outhit->hit_point,
 *		 	pp->pt_outhit->hit_normal,
 *		 	PAINT_INTERN_EXIT, ap, outfp );
*/		

		wraypts( pp->pt_outhit->hit_point,
			pp->pt_outhit->hit_normal,
			np->pt_inhit->hit_point,
			PAINT_AIR, ap, outfp );

/*		 wraypaint( np->pt_inhit->hit_point,
 *		 	np->pt_inhit->hit_normal,
 *		 	PAINT_INTERN_ENTRY, ap, outfp );
*/		

a269 12

#endif


	/* "final exit" paint -- ray va(r)nishes off into the sunset */
	pp = PartHeadp->pt_back;
/*	if( pp->pt_outhit->hit_dist < INFINITY )  {
 *		wraypaint( pp->pt_outhit->hit_point,
 *			pp->pt_outhit->hit_normal,
 *			PAINT_FINAL_EXIT, ap, outfp );
 *	}
*/
@


1.4
log
@Changed to take advantage of regionfix() subroutine.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.3 89/02/11 23:55:08 mike Locked $ (BRL)";
d47 14
a92 9
#if 0
 /* "paint" types are negative ==> interpret as "special" air codes */
 #define PAINT_FIRST_ENTRY	(-999)
 #define PAINT_INTERN_EXIT	(-998)
 #define PAINT_INTERN_ENTRY	(-997)
 #define PAINT_FINAL_EXIT	(-996)
 #define PAINT_AIR		(-1)
#endif

d108 4
d121 15
a135 1
	fprintf(stdout,"ray header, count=%d\n",count);
d137 47
d186 14
d341 1
a341 1
        fprintf(stdout,"%5d%s %s\n", 1, file, obj);
d351 1
a358 10
	char	*file = "rtray.regexp";			/* XXX */
	FILE	*fp;
	char	*line;
	char	*tabp;
	int	linenum = 0;
	char	*err;
	register struct region	*rp;
	int	ret;
	int	oldid;
	int	newid;
@


1.3
log
@The first two headers now work.
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewg3.c,v 1.2 89/02/11 23:14:48 sue Locked $ (BRL)";
a38 6
#include <ctype.h>
#ifdef BSD
#include <strings.h>
#else
#include <string.h>
#endif
a46 4
extern char	*strchr();
extern char	*re_comp();
extern int	re_exec();

d303 1
a303 70
	/*
	 *  Apply any deltas to reg_regionid values
	 *  to allow old applications that use the reg_regionid number
	 *  to distinguish between different instances of the same
	 *  prototype region.
	 */
	if( (fp = fopen( file, "r" )) == NULL )	 {
		perror(file);
		return;
	}

	while( (line = rt_read_cmd( fp )) != (char *) 0 )  {
		linenum++;
		/*  For now, establish a simple format:
		 *  regexp TAB formula SEMICOLON
		 */
		if( (tabp = strchr( line, '\t' )) == (char *)0 )  {
			rt_log("%s: missing TAB on line %d:\n%s\n", file, linenum, line );
			continue;		/* just ignore it */
		}
		*tabp++ = '\0';
		while( *tabp && isspace( *tabp ) )  tabp++;
		if( (err = re_comp(line)) != (char *)0 )  {
			rt_log("%s: line %d, re_comp error '%s'\n", file, line, err );
			continue;		/* just ignore it */
		}
		
		rp = ap->a_rt_i->HeadRegion;
		for( ; rp != REGION_NULL; rp = rp->reg_forw )  {
			ret = re_exec(rp->reg_name);
			if(rdebug&RDEBUG_INSTANCE)  {
				rt_log("'%s' %s '%s'\n", line,
					ret==1 ? "==" : "!=",
					rp->reg_name);
			}
			if( (ret) == 0  )
				continue;	/* didn't match */
			if( ret == -1 )  {
				rt_log("%s: line %d, invalid regular expression\n", file, linenum);
				break;		/* on to next RE */
			}
			/*
			 *  RE matched this name, perform indicated operation
			 *  For now, choices are limited.  Later this might
			 *  become an interpreted expression.  For now:
			 *	99	replace old region id with "num"
			 *	+99	increment old region id with "num"
			 *		(which may itself be a negative number)
			 *	+uses	increment old region id by the
			 *		current instance (use) count.
			 */
			oldid = rp->reg_regionid;
			if( strcmp( tabp, "+uses" ) == 0  )  {
				newid = oldid + rp->reg_instnum;
			} else if( *tabp == '+' )  {
				newid = oldid + atoi( tabp+1 );
			} else {
				newid = atoi( tabp );
				if( newid == 0 )  rt_log("%s, line %d Warning:  new id = 0\n", file, linenum );
			}
			if(rdebug&RDEBUG_INSTANCE)  {
				rt_log("%s instance %d:  region id changed from %d to %d\n",
					rp->reg_name, rp->reg_instnum,
					oldid, newid );
			}
			rp->reg_regionid = newid;
		}
		rt_free( line, "reg_expr line");
	}
	fclose( fp );
@


1.2
log
@This version prints dummy strings for each of the 4 output formats
@
text
@d35 1
a35 1
static char RCSrayg3[] = "@@(#)$Header: viewray.c,v 8.5 89/01/19 22:17:57 mike Exp $ (BRL)";
d69 3
d261 7
a267 1
        fprintf(stdout,"overall headder\n");
a268 1

d298 14
a311 1
	fprintf(stdout, "view header\n");
@


1.1
log
@Initial revision
@
text
@d62 1
a62 1
struct structparse view_parse[] = {
d64 1
a64 1
};
d66 1
d70 1
a70 1
Usage:  rtray [options] model.g objects... >file.ray\n\
d86 8
a93 6
/* "paint" types are negative ==> interpret as "special" air codes */
#define PAINT_FIRST_ENTRY	(-999)
#define PAINT_INTERN_EXIT	(-998)
#define PAINT_INTERN_ENTRY	(-997)
#define PAINT_FINAL_EXIT	(-996)
#define PAINT_AIR		(-1)
d109 1
d114 14
d134 1
d158 1
d187 5
a191 3
				wraypaint( pp->pt_outhit->hit_point,
					pp->pt_outhit->hit_normal,
					PAINT_INTERN_EXIT, ap, outfp );
d197 4
a200 3
				wraypaint( np->pt_inhit->hit_point,
					np->pt_inhit->hit_normal,
					PAINT_INTERN_ENTRY, ap, outfp );
d211 4
a214 3
		wraypaint( pp->pt_outhit->hit_point,
			pp->pt_outhit->hit_normal,
			PAINT_INTERN_EXIT, ap, outfp );
d221 5
a225 3
		wraypaint( np->pt_inhit->hit_point,
			np->pt_inhit->hit_normal,
			PAINT_INTERN_ENTRY, ap, outfp );
d228 3
d233 7
a239 5
	if( pp->pt_outhit->hit_dist < INFINITY )  {
		wraypaint( pp->pt_outhit->hit_point,
			pp->pt_outhit->hit_normal,
			PAINT_FINAL_EXIT, ap, outfp );
	}
d255 6
d269 1
a269 1
	fflush(outfp);
d287 4
a290 2
	if( outfp == NULL )
		rt_bomb("outfp is NULL\n");
@
