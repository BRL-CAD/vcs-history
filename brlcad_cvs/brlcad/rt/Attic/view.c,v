head	11.107;
access;
symbols
	ansi-20040405-merged:11.93.2.2
	postmerge-20040405-ansi:11.105
	premerge-20040404-ansi:11.104
	postmerge-autoconf:11.104
	autoconf-freeze:11.101.2.3
	premerge-autoconf:11.104
	postmerge-20040315-windows:11.104
	premerge-20040315-windows:11.104
	windows-20040315-freeze:11.93.4.1
	autoconf-20031203:11.101.2.1
	autoconf-20031202:11.101
	autoconf-branch:11.101.0.2
	phong-branch:11.100.0.2
	photonmap-branch:11.97.0.2
	rel-6-1-DP:11.94
	windows-branch:11.93.0.4
	rel-6-0-2:11.91
	ansi-branch:11.93.0.2
	rel-6-0-1-branch:11.91.0.2
	hartley-6-0-post:11.92
	hartley-6-0-pre:11.91
	rel-6-0-1:11.91
	rel-6-0:11.89
	rel-5-4:11.73.2.3
	offsite-5-3-pre:11.80
	rel-5-3:11.73.2.3
	rel-5-2:11.73
	rel-5-1-branch:11.73.0.2
	rel-5-1:11.73
	rel-5-0:11.63
	rel-5-0-beta:11.63
	rel-4-5:11.41
	ctj-4-5-post:11.33
	ctj-4-5-pre:11.33
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.4
	rel-1-10:4.1
	rt-2:2.1
	rt:1.1;
locks; strict;
comment	@ * @;


11.107
date	2004.05.21.17.31.08;	author morrison;	state dead;
branches;
next	11.106;

11.106
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.105;

11.105
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	11.104;

11.104
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.103;

11.103
date	2003.10.29.15.49.21;	author jra;	state Exp;
branches;
next	11.102;

11.102
date	2003.10.08.17.34.41;	author morrison;	state Exp;
branches;
next	11.101;

11.101
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches
	11.101.2.1;
next	11.100;

11.100
date	2003.09.05.15.22.36;	author justin;	state Exp;
branches
	11.100.2.1;
next	11.99;

11.99
date	2003.08.27.19.18.28;	author justin;	state Exp;
branches;
next	11.98;

11.98
date	2003.06.19.16.01.08;	author butler;	state Exp;
branches;
next	11.97;

11.97
date	2003.04.07.18.01.15;	author jra;	state Exp;
branches
	11.97.2.1;
next	11.96;

11.96
date	2003.01.31.21.47.03;	author jra;	state Exp;
branches;
next	11.95;

11.95
date	2002.12.31.14.46.03;	author jra;	state Exp;
branches;
next	11.94;

11.94
date	2002.09.26.19.58.06;	author jra;	state Exp;
branches;
next	11.93;

11.93
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.93.2.1
	11.93.4.1;
next	11.92;

11.92
date	2002.08.15.20.55.50;	author hartley;	state Exp;
branches;
next	11.91;

11.91
date	2002.07.16.19.38.39;	author morrison;	state Exp;
branches;
next	11.90;

11.90
date	2002.07.16.19.29.27;	author morrison;	state Exp;
branches;
next	11.89;

11.89
date	2002.03.13.14.44.28;	author jra;	state Exp;
branches;
next	11.88;

11.88
date	2002.03.12.21.36.23;	author jra;	state Exp;
branches;
next	11.87;

11.87
date	2002.01.22.19.00.14;	author jra;	state Exp;
branches;
next	11.86;

11.86
date	2001.10.17.07.40.06;	author morrison;	state Exp;
branches;
next	11.85;

11.85
date	2001.10.12.18.39.36;	author butler;	state Exp;
branches;
next	11.84;

11.84
date	2001.06.27.17.50.04;	author rbowers;	state Exp;
branches;
next	11.83;

11.83
date	2001.05.16.21.38.18;	author morrison;	state Exp;
branches;
next	11.82;

11.82
date	2001.04.05.19.36.04;	author morrison;	state Exp;
branches;
next	11.81;

11.81
date	2001.03.19.22.20.14;	author butler;	state Exp;
branches;
next	11.80;

11.80
date	2000.11.01.04.16.33;	author mike;	state Exp;
branches;
next	11.79;

11.79
date	2000.10.20.18.55.01;	author mike;	state Exp;
branches;
next	11.78;

11.78
date	2000.09.08.05.54.46;	author mike;	state Exp;
branches;
next	11.77;

11.77
date	2000.08.17.02.41.37;	author mike;	state Exp;
branches;
next	11.76;

11.76
date	2000.07.31.02.01.16;	author butler;	state Exp;
branches;
next	11.75;

11.75
date	2000.07.27.19.32.52;	author butler;	state Exp;
branches;
next	11.74;

11.74
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.73;

11.73
date	2000.02.02.20.02.27;	author mike;	state Exp;
branches
	11.73.2.1;
next	11.72;

11.72
date	2000.01.22.03.51.44;	author mike;	state Exp;
branches;
next	11.71;

11.71
date	2000.01.13.20.30.23;	author mike;	state Exp;
branches;
next	11.70;

11.70
date	99.12.30.05.49.29;	author butler;	state Exp;
branches;
next	11.69;

11.69
date	99.12.23.05.59.01;	author mike;	state Exp;
branches;
next	11.68;

11.68
date	99.12.22.02.28.05;	author mike;	state Exp;
branches;
next	11.67;

11.67
date	99.12.03.23.33.50;	author mike;	state Exp;
branches;
next	11.66;

11.66
date	99.11.24.22.16.07;	author mike;	state Exp;
branches;
next	11.65;

11.65
date	99.10.30.03.53.05;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	99.10.30.03.06.27;	author butler;	state Exp;
branches;
next	11.63;

11.63
date	99.05.28.03.19.29;	author mike;	state Exp;
branches;
next	11.62;

11.62
date	99.05.20.06.39.11;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	99.05.20.05.16.46;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	99.01.28.03.50.57;	author mike;	state Exp;
branches;
next	11.59;

11.59
date	99.01.13.22.07.35;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	98.12.10.03.35.49;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	98.09.22.01.43.12;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	98.06.25.07.40.56;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	98.06.03.06.15.04;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	98.06.03.05.11.23;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	98.06.03.05.09.30;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	98.06.03.05.01.39;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	98.05.28.04.21.39;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	98.05.22.21.01.14;	author mike;	state Exp;
branches;
next	11.49;

11.49
date	98.05.22.05.49.25;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	98.05.22.04.54.40;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	98.05.13.02.40.10;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	98.05.12.22.52.09;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	98.05.06.04.40.45;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	98.03.19.04.37.45;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	98.03.19.03.57.14;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	98.03.08.19.53.15;	author butler;	state Exp;
branches;
next	11.41;

11.41
date	98.01.23.02.01.50;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	97.11.21.04.43.55;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	97.11.20.23.06.42;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	97.11.18.07.03.07;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	97.11.17.19.30.50;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	97.11.14.04.40.23;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	97.10.31.19.20.20;	author butler;	state Exp;
branches;
next	11.34;

11.34
date	97.08.28.23.47.39;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	97.07.22.23.19.51;	author butler;	state Exp;
branches;
next	11.32;

11.32
date	97.07.16.14.14.08;	author gdurf;	state Exp;
branches;
next	11.31;

11.31
date	97.05.19.17.13.32;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	97.01.07.23.44.35;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	97.01.07.22.57.13;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	96.11.04.21.20.02;	author pjt;	state Exp;
branches;
next	11.27;

11.27
date	96.11.01.20.43.34;	author pjt;	state Exp;
branches;
next	11.26;

11.26
date	96.10.31.20.27.46;	author pjt;	state Exp;
branches;
next	11.25;

11.25
date	96.10.31.14.01.23;	author pjt;	state Exp;
branches;
next	11.24;

11.24
date	96.09.17.04.37.31;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.22;

11.22
date	96.07.22.20.34.18;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	96.07.12.14.55.42;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	96.06.25.20.43.35;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	96.06.24.21.03.41;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	96.06.24.20.53.36;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	96.05.09.10.43.50;	author butler;	state Exp;
branches;
next	11.16;

11.16
date	96.05.07.19.25.35;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	96.03.29.21.55.48;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	96.03.28.19.27.22;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	96.03.28.04.33.49;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	95.12.06.17.36.18;	author pjt;	state Exp;
branches;
next	11.10;

11.10
date	95.11.07.21.02.51;	author adam;	state Exp;
branches;
next	11.9;

11.9
date	95.10.20.04.50.56;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	95.08.24.14.56.52;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.08.22.02.23.51;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	95.08.19.05.08.09;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	95.06.02.23.34.05;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.06.02.23.30.40;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.03.03.10.43.31;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.28.00.09.44;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.21;	author mike;	state Rel4_4;
branches;
next	10.14;

10.14
date	95.01.04.08.13.09;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	95.01.03.21.51.38;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.11.09.15.14.02;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.11.05.03.28.17;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.11.05.02.46.54;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.10.31.22.22.43;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.10.29.03.23.57;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.10.29.02.47.11;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.11.01.43.25;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	93.09.25.06.32.31;	author cjohnson;	state Exp;
branches;
next	10.4;

10.4
date	93.07.21.22.14.38;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.07.20.15.44.14;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.07.21.17.04.55;	author mm;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.15;	author mike;	state Rel4_0;
branches;
next	9.20;

9.20
date	91.08.30.02.47.58;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.07.06.00.38.56;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.07.06.00.35.25;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.06.29.23.02.10;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.03.13.21.15.41;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.03.11.23.08.37;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.02.20.01.16.16;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.02.20.00.51.29;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.02.19.19.51.09;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.01.05.03.09.20;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.01.04.00.41.29;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.12.19.06.38.43;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.12.16.35.13;	author butler;	state Exp;
branches;
next	9.7;

9.7
date	90.11.14.15.43.35;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.11.10.19.36.33;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.06.06.20.34.02;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.02.08.02.23.12;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.02.03.23.56.26;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.02.58;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.49;	author mike;	state Rel3_5;
branches;
next	8.17;

8.17
date	89.05.19.03.19.57;	author mike;	state Exp;
branches;
next	8.16;

8.16
date	89.05.19.03.08.59;	author mike;	state Exp;
branches;
next	8.15;

8.15
date	89.04.30.21.26.13;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.04.28.06.22.36;	author phil;	state Exp;
branches;
next	8.13;

8.13
date	89.04.27.22.23.40;	author phil;	state Exp;
branches;
next	8.12;

8.12
date	89.04.14.13.15.54;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.04.04.05.02.13;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.03.28.16.33.57;	author phil;	state Exp;
branches;
next	8.9;

8.9
date	89.03.04.03.35.01;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.02.17.11.02.35;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.02.10.03.52.37;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.01.09.04.52.22;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.08.23.04.41;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	88.12.27.16.35.21;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.15.03.30.18;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.04.48.11;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.34;	author mike;	state Rel3_0;
branches;
next	7.20;

7.20
date	88.09.17.08.44.01;	author mike;	state Exp;
branches;
next	7.19;

7.19
date	88.08.23.02.32.44;	author mike;	state Exp;
branches;
next	7.18;

7.18
date	88.08.20.07.14.29;	author mike;	state Exp;
branches;
next	7.17;

7.17
date	88.07.26.01.18.00;	author mike;	state Exp;
branches;
next	7.16;

7.16
date	88.06.22.22.17.59;	author phil;	state Exp;
branches;
next	7.14;

7.14
date	88.06.21.00.55.03;	author mike;	state Exp;
branches;
next	7.13;

7.13
date	88.06.16.02.53.28;	author phil;	state Exp;
branches;
next	7.12;

7.12
date	88.05.20.03.26.33;	author mike;	state Exp;
branches;
next	7.11;

7.11
date	88.05.14.02.28.30;	author mike;	state Exp;
branches;
next	7.10;

7.10
date	88.02.27.07.46.33;	author mike;	state Exp;
branches;
next	7.9;

7.9
date	88.02.27.03.10.00;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.02.25.00.50.57;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.01.26.05.35.07;	author phil;	state Exp;
branches;
next	7.6;

7.6
date	88.01.25.22.38.47;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.01.25.21.19.28;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.01.22.20.52.55;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.01.20.08.47.55;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.15.14.52.02;	author stay;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.44;	author mike;	state Rel;
branches;
next	6.9;

6.9
date	87.10.16.00.49.06;	author mike;	state Exp;
branches;
next	6.8;

6.8
date	87.10.15.16.59.02;	author mike;	state Exp;
branches;
next	6.7;

6.7
date	87.09.11.02.08.32;	author mike;	state Exp;
branches;
next	6.6;

6.6
date	87.09.10.07.12.50;	author mike;	state Exp;
branches;
next	6.5;

6.5
date	87.09.10.01.46.24;	author mike;	state Exp;
branches;
next	6.4;

6.4
date	87.09.04.03.43.41;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.09.03.01.30.42;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.08.10.04.57.23;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.59.31;	author mike;	state Rel;
branches;
next	5.11;

5.11
date	87.07.11.02.59.40;	author mike;	state Exp;
branches;
next	5.10;

5.10
date	87.07.10.07.33.09;	author mike;	state Exp;
branches;
next	5.9;

5.9
date	87.07.09.03.31.10;	author mike;	state Exp;
branches;
next	5.8;

5.8
date	87.07.06.15.28.59;	author mike;	state Exp;
branches;
next	5.7;

5.7
date	87.07.02.06.18.18;	author mike;	state Exp;
branches;
next	5.6;

5.6
date	87.06.27.06.46.29;	author phil;	state Exp;
branches;
next	5.5;

5.5
date	87.06.27.03.47.39;	author mike;	state Exp;
branches;
next	5.4;

5.4
date	87.06.26.06.25.18;	author mike;	state Exp;
branches;
next	5.3;

5.3
date	87.06.26.05.58.05;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.24.23.35.17;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.15.36;	author mike;	state Rel;
branches;
next	4.15;

4.15
date	87.06.13.03.20.38;	author mike;	state Exp;
branches;
next	4.14;

4.14
date	87.06.13.01.40.26;	author mike;	state Exp;
branches;
next	4.13;

4.13
date	87.05.30.07.04.05;	author mike;	state Exp;
branches;
next	4.12;

4.12
date	87.04.28.00.29.34;	author phil;	state Exp;
branches;
next	4.11;

4.11
date	87.04.10.07.03.00;	author mike;	state Exp;
branches;
next	4.10;

4.10
date	87.04.07.20.54.29;	author phil;	state Exp;
branches;
next	4.9;

4.9
date	87.04.01.04.51.45;	author mike;	state Exp;
branches;
next	4.8;

4.8
date	87.03.28.05.23.42;	author mike;	state Exp;
branches;
next	4.7;

4.7
date	87.03.23.23.47.55;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.03.17.22.31.06;	author mike;	state Exp;
branches;
next	4.5;

4.5
date	87.03.17.20.19.17;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.02.13.00.02.58;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.01.28.21.03.02;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.03.20.08.02;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.48.55;	author mike;	state Rel1;
branches;
next	3.20;

3.20
date	86.12.19.23.11.12;	author mike;	state Exp;
branches;
next	3.19;

3.19
date	86.12.18.16.02.15;	author mike;	state Exp;
branches;
next	3.18;

3.18
date	86.11.25.03.36.46;	author mike;	state Exp;
branches;
next	3.17;

3.17
date	86.11.07.02.46.30;	author mike;	state Exp;
branches;
next	3.16;

3.16
date	86.11.07.01.47.32;	author mike;	state Exp;
branches;
next	3.15;

3.15
date	86.10.26.17.06.50;	author mike;	state Exp;
branches;
next	3.14;

3.14
date	86.10.25.12.11.34;	author mike;	state Exp;
branches;
next	3.13;

3.13
date	86.10.12.00.27.06;	author mike;	state Exp;
branches;
next	3.12;

3.12
date	86.10.12.00.20.59;	author mike;	state Exp;
branches;
next	3.11;

3.11
date	86.10.03.02.26.38;	author mike;	state Exp;
branches;
next	3.10;

3.10
date	86.08.12.05.51.03;	author mike;	state Exp;
branches;
next	3.9;

3.9
date	86.08.06.19.59.09;	author mike;	state Exp;
branches;
next	3.8;

3.8
date	86.08.06.05.41.33;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.07.29.20.22.58;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.07.24.06.05.50;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.22.03.52.39;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.19.04.40.40;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.17.18.33.14;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.06.17.14.27.14;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.11.00.14.45;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.32;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	86.06.09.21.49.50;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.03.14.21.06.30;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.02.18.16.21.43;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.01.24.11.46.50;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.01.23.13.29.48;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.09.15.09.18.28;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.09.14.07.09.56;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.09.12.23.05.59;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.09.11.23.53.16;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.09.09.23.42.46;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.06.02.31.20;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.05.02.23.48;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.08.12;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	85.07.30.05.56.34;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	85.06.05.15.44.03;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	85.06.05.01.35.05;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	85.06.04.23.24.16;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	85.05.29.00.15.32;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	85.05.01.19.58.54;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	85.03.25.17.47.14;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	85.03.25.11.47.52;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	85.02.07.19.20.15;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	84.11.29.07.04.49;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	84.11.27.06.58.08;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	84.11.24.03.03.19;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	84.11.20.20.15.26;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.11.16.06.30.26;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.10.19.01.39.42;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.10.19.00.08.18;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.08.28.03.08.25;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.08.24.01.04.47;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.08.22.03.20.03;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.05.05.04.43.32;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.05.04.09.16.13;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.05.03.06.56.04;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.05.01.06.40.13;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.04.26.05.43.35;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.04.18.02.21.10;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.02.16.42.30;	author mike;	state Exp;
branches;
next	;

11.73.2.1
date	2000.11.28.00.04.30;	author jra;	state Exp;
branches;
next	11.73.2.2;

11.73.2.2
date	2000.11.29.19.15.49;	author jra;	state Exp;
branches;
next	11.73.2.3;

11.73.2.3
date	2001.01.05.21.27.21;	author jra;	state Exp;
branches;
next	;

11.93.2.1
date	2002.09.19.18.02.16;	author morrison;	state Exp;
branches;
next	11.93.2.2;

11.93.2.2
date	2004.03.17.21.23.00;	author morrison;	state Exp;
branches;
next	;

11.93.4.1
date	2004.03.11.23.48.07;	author morrison;	state Exp;
branches;
next	;

11.97.2.1
date	2003.08.07.22.07.00;	author justin;	state Exp;
branches;
next	11.97.2.2;

11.97.2.2
date	2003.08.12.03.56.39;	author justin;	state Exp;
branches;
next	11.97.2.3;

11.97.2.3
date	2003.08.12.23.07.28;	author justin;	state Exp;
branches;
next	11.97.2.4;

11.97.2.4
date	2003.08.13.22.07.48;	author justin;	state Exp;
branches;
next	11.97.2.5;

11.97.2.5
date	2003.08.24.23.28.53;	author justin;	state Exp;
branches;
next	11.97.2.6;

11.97.2.6
date	2003.08.26.13.55.54;	author justin;	state Exp;
branches;
next	;

11.100.2.1
date	2003.09.10.22.03.38;	author butler;	state Exp;
branches;
next	;

11.101.2.1
date	2003.12.03.16.25.44;	author erikg;	state Exp;
branches;
next	11.101.2.2;

11.101.2.2
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	11.101.2.3;

11.101.2.3
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@Lighting Model
@


11.107
log
@moved to src/rt/
@
text
@/*
 *			V I E W . C
 *
 *	Ray Tracing program, lighting model manager.
 *
 *  Output is either interactive to a frame buffer, or written in a file.
 *  The output format is a .PIX file (a byte stream of R,G,B as u_char's).
 *
 *  The extern "lightmodel" selects which one is being used:
 *	0	Full lighting model (default)
 *	1	1-light, from the eye.
 *	2	Spencer's surface-normals-as-colors display
 *	3	(removed)
 *	4	curvature debugging display (inv radius of curvature)
 *	5	curvature debugging (principal direction)
 *	6	UV Coord
 *	7	Photon Mapping
 *
 *  Notes -
 *	The normals on all surfaces point OUT of the solid.
 *	The incomming light rays point IN.
 *
 *  Authors -
 *	Michael John Muuss
 *	Gary S. Moss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSview[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/view.c,v 11.106 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include <math.h>

#ifdef HAVE_UNIX_IO
# include <sys/types.h>
# include <sys/stat.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "fb.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "./ext.h"
#include "rtprivate.h"
#include "light.h"
#include "plot3.h"
#include "photonmap.h"

char usage[] = "\
Usage:  rt [options] model.g objects...\n\
Options:\n\
 -s #		Square grid size in pixels (default 512)\n\
 -w # -n #	Grid size width and height in pixels\n\
 -V #		View (pixel) aspect ratio (width/height)\n\
 -a #		Azimuth in deg\n\
 -e #		Elevation in deg\n\
 -M		Read matrix+cmds on stdin\n\
 -N #		NMG debug flags\n\
 -o model.pix	Output file, .pix format (default=fb)\n\
 -x #		librt debug flags\n\
 -X #		rt debug flags\n\
 -p #		Perspective, degrees side to side\n\
 -P #		Set number of processors\n\
 -T #/#		Tolerance: distance/angular\n\
 -r		Report overlaps\n\
 -R		Do not report overlaps\n\
";

int		use_air = 0;		/* Handling of air in librt */

extern FBIO	*fbp;			/* Framebuffer handle */

extern int	max_bounces;		/* from refract.c */
extern int	max_ireflect;		/* from refract.c */
extern int	curframe;		/* from main.c */
extern fastf_t	frame_delta_t;		/* from main.c */
extern double	airdensity;		/* from opt.c */
extern double	haze[3];		/* from opt.c */

extern struct floatpixel	*curr_float_frame;	/* buffer of full frame */

extern int viewshade(struct application *ap,
		     register const struct partition *pp,
		     register struct shadework *swp);



extern struct region	env_region;		/* environment map region */

vect_t ambient_color = { 1, 1, 1 };	/* Ambient white light */

extern vect_t	background;
int	ibackground[3] = {0};			/* integer 0..255 version */
int	inonbackground[3] = {0};		/* integer non-background */

#ifdef RTSRV
extern int	srv_startpix;		/* offset for view_pixel */
extern int	srv_scanlen;		/* BUFMODE_RTSRV buffer length */
extern char	*scanbuf;		/* scanline(s) buffer */
#endif

void		free_scanlines(void);

static int	buf_mode=0;
#define BUFMODE_UNBUF	1		/* No output buffering */
#define BUFMODE_DYNAMIC	2		/* Dynamic output buffering */
#define BUFMODE_INCR	3		/* incr_mode set, dynamic buffering */
#define BUFMODE_RTSRV	4		/* output buffering into scanbuf */
#define BUFMODE_FULLFLOAT 5		/* buffer entire frame as floats */
#define BUFMODE_SCANLINE 6		/* Like _DYNAMIC, one scanline/cpu */

static struct scanline {
	int	sl_left;		/* # pixels left on this scanline */
	char	*sl_buf;		/* ptr to buffer for scanline */
} *scanline;

static short int	pwidth;			/* Width of each pixel (in bytes) */

struct mfuncs *mfHead = MF_NULL;	/* Head of list of shaders */

fastf_t	gamma_corr = 0.0;			/* gamma correction if !0 */

/* The default a_onehit = -1 requires at least one non-air hit,
 * (stop at first surface) and stops ray/geometry intersection after that.
 * Set to 0 to turn off first hit optimization, with -c 'set a_onehit=0'
 */
int a_onehit = -1;

/*
 * Overlay
 *
 * If in overlay mode, and writeing to a framebuffer, 
 * only write non-background pixels.
 */
static int overlay = 0;

/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
#if !defined(__alpha)   /* XXX Alpha does not support this initialization! */
	{"%f",	1, "gamma",	bu_byteoffset(gamma_corr),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "bounces",	bu_byteoffset(max_bounces),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "ireflect",	bu_byteoffset(max_ireflect),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "a_onehit",	bu_byteoffset(a_onehit),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f", ELEMENTS_PER_VECT, "background",bu_byteoffset(background[0]),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d", 1, "overlay",	bu_byteoffset(overlay),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d", 1, "ov", bu_byteoffset(overlay),	BU_STRUCTPARSE_FUNC_NULL },
#endif
	{"",	0, (char *)0,	0,				BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *  			V I E W _ P I X E L
 *  
 *  Arrange to have the pixel output.
 *  a_uptr has region pointer, for reference.
 */
void
view_pixel(register struct application *ap)
{
	register int	r,g,b;
	register char	*pixelp;
	register struct scanline	*slp;
	register int	do_eol = 0;
	unsigned char	dist[8];	/* pixel distance (in IEEE format) */

	if (rpt_dist)
	    htond(dist, (unsigned char *)&(ap->a_dist), 1);

	if( ap->a_user == 0 )  {
		/* Shot missed the model, don't dither */
		r = ibackground[0];
		g = ibackground[1];
		b = ibackground[2];
		VSETALL( ap->a_color, -1e-20 );	/* background flag */
	} else {
		/*
		 *  To prevent bad color aliasing, add some color dither.
		 *  Be certain to NOT output the background color here.
		 *  Random numbers in the range 0 to 1 are used, so
		 *  that integer valued colors (eg, from texture maps)
		 *  retain their original values.
		 */
		if( gamma_corr != 0 )  {
			/*
			 * Perform gamma correction in floating-point space,
			 * and avoid nasty mach bands in dark areas
			 * from doing it in 0..255 space later.
			 */
			double ex = 1.0/gamma_corr;
			r = pow(ap->a_color[0], ex)*255.+
				bn_rand0to1(ap->a_resource->re_randptr);
			g = pow(ap->a_color[1], ex)*255.+
				bn_rand0to1(ap->a_resource->re_randptr);
			b = pow(ap->a_color[2], ex)*255.+
				bn_rand0to1(ap->a_resource->re_randptr);
		} else {
			r = ap->a_color[0]*255.+bn_rand0to1(ap->a_resource->re_randptr);
			g = ap->a_color[1]*255.+bn_rand0to1(ap->a_resource->re_randptr);
			b = ap->a_color[2]*255.+bn_rand0to1(ap->a_resource->re_randptr);
		}
		if( r > 255 ) r = 255;
		else if( r < 0 )  r = 0;
		if( g > 255 ) g = 255;
		else if( g < 0 )  g = 0;
		if( b > 255 ) b = 255;
		else if( b < 0 )  b = 0;
		if( r == ibackground[0] && g == ibackground[1] &&
		    b == ibackground[2] )  {
		    	r = inonbackground[0];
		    	g = inonbackground[1];
		    	b = inonbackground[2];
		}

		/* Make sure it's never perfect black */
		if (r==0 && g==0 && b==0 && benchmark==0)
		  b = 1;
	}

	if(R_DEBUG&RDEBUG_HITS) bu_log("rgb=%3d,%3d,%3d xy=%3d,%3d (%g,%g,%g)\n",
		r,g,b, ap->a_x, ap->a_y,
		V3ARGS(ap->a_color) );

	switch( buf_mode )  {

	case BUFMODE_FULLFLOAT:
		{
			/* No output semaphores required for word-width memory writes */
			register struct floatpixel	*fp;
			fp = &curr_float_frame[ap->a_y*width + ap->a_x];
			fp->ff_frame = curframe;
			fp->ff_color[0] = r;
			fp->ff_color[1] = g;
			fp->ff_color[2] = b;
			fp->ff_x = ap->a_x;
			fp->ff_y = ap->a_y;
			if( ap->a_user == 0 )  {
				fp->ff_dist = -INFINITY;	/* shot missed model */
				fp->ff_frame = -1;		/* Don't cache misses */
				return;
			}
			/* XXX a_dist is negative and misleading when eye is in air */
			fp->ff_dist = (float)ap->a_dist;
			VJOIN1( fp->ff_hitpt, ap->a_ray.r_pt,
				ap->a_dist, ap->a_ray.r_dir );
			fp->ff_regp = (struct region *)ap->a_uptr;
			RT_CK_REGION(fp->ff_regp);
#if 0
{
	point_t	new_view_pt;
	MAT4X3PNT( new_view_pt, model2view, fp->ff_hitpt );
}
#endif
			/*
			 *  This pixel was just computed.
			 *  Look at next pixel on scanline, 
			 *  and if it is a reprojected old value
			 *  and hit a different region than this pixel,
			 *  then recompute it too.
			 */
			if( ap->a_x >= width-1 )  return;
			if( fp[1].ff_frame <= 0 )  return;	/* not valid, will be recomputed. */
			if( fp[1].ff_regp == fp->ff_regp )
				return;				/* OK */
			/* Next pixel is probably out of date, mark it for re-computing */
			fp[1].ff_frame = -1;
			return;
		}

	case BUFMODE_UNBUF:
		{
			RGBpixel	p;
			int		npix;

			p[0] = r ;
			p[1] = g ;
			p[2] = b ;

			if( outfp != NULL )  {
				bu_semaphore_acquire( BU_SEM_SYSCALL );
				if( fseek( outfp, (ap->a_y*width*pwidth) + (ap->a_x*pwidth), 0 ) != 0 )
					fprintf(stderr, "fseek error\n");
				if( fwrite( p, 3, 1, outfp ) != 1 )
					rt_bomb("pixel fwrite error");
				if( rpt_dist &&
				    ( fwrite( dist, 8, 1, outfp ) != 1 ))
					rt_bomb("pixel fwrite error");
				bu_semaphore_release( BU_SEM_SYSCALL);
			}

			if( fbp != FBIO_NULL )  {
				/* Framebuffer output */
				bu_semaphore_acquire( BU_SEM_SYSCALL );
				npix = fb_write( fbp, ap->a_x, ap->a_y,
					(unsigned char *)p, 1 );
				bu_semaphore_release( BU_SEM_SYSCALL);
				if( npix < 1 )  rt_bomb("pixel fb_write error");
			}
		}
		return;

#ifdef RTSRV
	case BUFMODE_RTSRV:
		/* Multi-pixel buffer */
		pixelp = scanbuf+ pwidth * 
			((ap->a_y*width) + ap->a_x - srv_startpix);
		bu_semaphore_acquire( RT_SEM_RESULTS );
		*pixelp++ = r ;
		*pixelp++ = g ;
		*pixelp++ = b ;
		if (rpt_dist)
		{
		    *pixelp++ = dist[0];
		    *pixelp++ = dist[1];
		    *pixelp++ = dist[2];
		    *pixelp++ = dist[3];
		    *pixelp++ = dist[4];
		    *pixelp++ = dist[5];
		    *pixelp++ = dist[6];
		    *pixelp++ = dist[7];
		}
		bu_semaphore_release( RT_SEM_RESULTS );
		return;
#endif

	/*
	 *  Store results into pixel buffer.
	 *  Don't depend on interlocked hardware byte-splice.
	 *  Need to protect scanline[].sl_left when in parallel mode.
	 */

	case BUFMODE_DYNAMIC:
		slp = &scanline[ap->a_y];
		bu_semaphore_acquire( RT_SEM_RESULTS );
		if( slp->sl_buf == (char *)0 )  {
			slp->sl_buf = bu_calloc( width, pwidth, "sl_buf scanline buffer" );
		}
		pixelp = slp->sl_buf+(ap->a_x*pwidth);
		*pixelp++ = r ;
		*pixelp++ = g ;
		*pixelp++ = b ;
		if (rpt_dist)
		{
		    *pixelp++ = dist[0];
		    *pixelp++ = dist[1];
		    *pixelp++ = dist[2];
		    *pixelp++ = dist[3];
		    *pixelp++ = dist[4];
		    *pixelp++ = dist[5];
		    *pixelp++ = dist[6];
		    *pixelp++ = dist[7];
		}
		if( --(slp->sl_left) <= 0 )
			do_eol = 1;
		bu_semaphore_release( RT_SEM_RESULTS );
		break;

	/*
	 *  Only one CPU is working on this scanline,
	 *  no parallel interlock required!  Much faster.
	 */
	case BUFMODE_SCANLINE:
		slp = &scanline[ap->a_y];
		if( slp->sl_buf == (char *)0 )  {
			slp->sl_buf = bu_calloc( width, pwidth, "sl_buf scanline buffer" );
		}
		pixelp = slp->sl_buf+(ap->a_x*pwidth);
		*pixelp++ = r ;
		*pixelp++ = g ;
		*pixelp++ = b ;
		if (rpt_dist)
		{
		    *pixelp++ = dist[0];
		    *pixelp++ = dist[1];
		    *pixelp++ = dist[2];
		    *pixelp++ = dist[3];
		    *pixelp++ = dist[4];
		    *pixelp++ = dist[5];
		    *pixelp++ = dist[6];
		    *pixelp++ = dist[7];
		}
		if( --(slp->sl_left) <= 0 )
			do_eol = 1;
		break;

	case BUFMODE_INCR:
		{
			register int dx,dy;
			register int spread;

			spread = 1<<(incr_nlevel-incr_level);

			bu_semaphore_acquire( RT_SEM_RESULTS );
			for( dy=0; dy<spread; dy++ )  {
				if( ap->a_y+dy >= height )  break;
				slp = &scanline[ap->a_y+dy];
				if( slp->sl_buf == (char *)0 )
					slp->sl_buf = bu_calloc( width+32,
						pwidth, "sl_buf scanline buffer" );

				pixelp = slp->sl_buf+(ap->a_x*pwidth);
				for( dx=0; dx<spread; dx++ )  {
					*pixelp++ = r ;
					*pixelp++ = g ;
					*pixelp++ = b ;
					if (rpt_dist)
					{
					    *pixelp++ = dist[0];
					    *pixelp++ = dist[1];
					    *pixelp++ = dist[2];
					    *pixelp++ = dist[3];
					    *pixelp++ = dist[4];
					    *pixelp++ = dist[5];
					    *pixelp++ = dist[6];
					    *pixelp++ = dist[7];
					}
				}
			}
			/* First 3 incremental iterations are boring */
			if( incr_level > 3 )  {
				if( --(scanline[ap->a_y].sl_left) <= 0 )
					do_eol = 1;
			}
			bu_semaphore_release( RT_SEM_RESULTS );
		}
		break;

	default:
		rt_bomb("bad buf_mode");
	}


	if( !do_eol )  return;

	switch( buf_mode )  {
	case BUFMODE_INCR:
		if( fbp == FBIO_NULL )  rt_bomb("Incremental rendering with no framebuffer?");
		{
			register int dy, yy;
			register int spread;
			int		npix = 0;

			spread = (1<<(incr_nlevel-incr_level))-1;
			bu_semaphore_acquire( BU_SEM_SYSCALL );
			for( dy=spread; dy >= 0; dy-- )  {
				yy = ap->a_y + dy;
				if( sub_grid_mode )  {
					if( dy < sub_ymin || dy > sub_ymax )
						continue;
					npix = fb_write( fbp, sub_xmin, yy,
						(unsigned char *)scanline[yy].sl_buf+3*sub_xmin,
						sub_xmax-sub_xmin+1 );
					if( npix != sub_xmax-sub_xmin+1 )  break;
				} else {
					npix = fb_write( fbp, 0, yy,
						(unsigned char *)scanline[yy].sl_buf,
						width );
					if( npix != width )  break;
				}
			}
			bu_semaphore_release( BU_SEM_SYSCALL);
			if( npix != width )  rt_bomb("fb_write error (incremental res)");
		}
		break;

	case BUFMODE_SCANLINE:
	case BUFMODE_DYNAMIC:
		if( fbp != FBIO_NULL )  {
			int		npix;
			bu_semaphore_acquire( BU_SEM_SYSCALL );
			if( sub_grid_mode )  {
				npix = fb_write( fbp, sub_xmin, ap->a_y,
				    (unsigned char *)scanline[ap->a_y].sl_buf+3*sub_xmin,
				    sub_xmax-sub_xmin+1 );
			} else {
				npix = fb_write( fbp, 0, ap->a_y,
				    (unsigned char *)scanline[ap->a_y].sl_buf, width );
			}
			bu_semaphore_release( BU_SEM_SYSCALL);
			if( sub_grid_mode )  {
				if( npix < sub_xmax-sub_xmin-1 )  rt_bomb("scanline fb_write error");
			} else {
				if( npix < width )  rt_bomb("scanline fb_write error");
			}
		}
		if( outfp != NULL )  {
			int	count;

			bu_semaphore_acquire( BU_SEM_SYSCALL );
			if( fseek( outfp, ap->a_y*width*pwidth, 0 ) != 0 )
				fprintf(stderr, "fseek error\n");
			count = fwrite( scanline[ap->a_y].sl_buf,
				sizeof(char), width*pwidth, outfp );
			bu_semaphore_release( BU_SEM_SYSCALL);
			if( count != width*pwidth )
				rt_bomb("view_pixel:  fwrite failure\n");
		}
		bu_free( scanline[ap->a_y].sl_buf, "sl_buf scanline buffer" );
		scanline[ap->a_y].sl_buf = (char *)0;
	}
}

/*
 *  			V I E W _ E O L
 *  
 *  This routine is not used;  view_pixel() determines when the last
 *  pixel of a scanline is really done, for parallel considerations.
 */
void
view_eol(register struct application *ap)
{
	return;
}

/*
 *			V I E W _ E N D
 */
void
view_end(struct application *ap)
{
	if( fullfloat_mode )  {
		struct floatpixel	*tmp;
		/* Transmitting scanlines, is done by rtsync before calling here. */
		/* Exchange previous and current buffers.  No freeing. */
		if( reproject_mode != 2 )  {
			tmp = prev_float_frame;
			prev_float_frame = curr_float_frame;
			curr_float_frame = tmp;
		}
	}

	if( scanline )  free_scanlines();
}

/*
 *			V I E W _ S E T U P
 *
 *  Called before rt_prep() in do.c
 */
void
view_setup(struct rt_i *rtip)
{
	register struct region *regp;

	RT_CHECK_RTI(rtip);
	/*
	 *  Initialize the material library for all regions.
	 *  As this may result in some regions being dropped,
	 *  (eg, light solids that become "implicit" -- non drawn),
	 *  this must be done before allowing the library to prep
	 *  itself.  This is a slight layering violation;  later it
	 *  may be clear how to repackage this operation.
	 */
	regp = BU_LIST_FIRST( region, &rtip->HeadRegion );
	while( BU_LIST_NOT_HEAD( regp, &rtip->HeadRegion ) )  {
		switch( mlib_setup( &mfHead, regp, rtip ) )  {
		case -1:
		default:
			bu_log("mlib_setup failure on %s\n", regp->reg_name);
			break;
		case 0:
			if(R_DEBUG&RDEBUG_MATERIAL)
				bu_log("mlib_setup: drop region %s\n", regp->reg_name);
			{
				struct region *r = BU_LIST_NEXT( region, &regp->l );
				/* zap reg_udata? beware of light structs */
				rt_del_regtree( rtip, regp, &rt_uniresource );
				regp = r;
				continue;
			}
		case 1:
			/* Full success */
			if( R_DEBUG&RDEBUG_MATERIAL &&
			    ((struct mfuncs *)(regp->reg_mfuncs))->mf_print )  {
				((struct mfuncs *)(regp->reg_mfuncs))->
					mf_print( regp, regp->reg_udata );
			}
			/* Perhaps this should be a function? */
			break;
	        case 2:
			/* Full success, and this region should get dropped later */
			/* Add to list of regions to drop */
			bu_ptbl_ins( &rtip->delete_regs, (long *)regp );
			break;
		}
		regp = BU_LIST_NEXT( region, &regp->l );
	}
}

/*
 *			V I E W _ R E _ S E T U P
 *
 *	This routine is used to do a "mlib_setup" on reprepped regions.
 *	only regions with a NULL reg_mfuncs pointer will be processed.
 */
void
view_re_setup( struct rt_i *rtip )
{
	struct region *rp;

	rp = BU_LIST_FIRST( region, &(rtip->HeadRegion) );
	while( BU_LIST_NOT_HEAD( rp, &(rtip->HeadRegion) ) ) {
		if( !rp->reg_mfuncs ) {
			switch( mlib_setup( &mfHead, rp, rtip ) ) {
			default:
			case -1:
				bu_log( "view_re_setup(): mlib_setup failed for region %s\n", rp->reg_name );
				break;
			case 0:
				{
					struct region *r = BU_LIST_NEXT( region, &rp->l );
					/* zap reg_udata? beware of light structs */
					rt_del_regtree( rtip, rp, &rt_uniresource );
					rp = r;
					continue;
				}
			case 1:
				break;
			}
		}
		rp = BU_LIST_NEXT( region, &rp->l );
	}
}

/*
 *			V I E W _ C L E A N U P
 *
 *  Called before rt_clean() in do.c
 */
void view_cleanup(struct rt_i	*rtip)
{
	register struct region	*regp;

	RT_CHECK_RTI(rtip);
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		mlib_free( regp );
	}
	if( env_region.reg_mfuncs )  {
		bu_free( (char *)env_region.reg_name, "env_region.reg_name" );
		env_region.reg_name = (char *)0;
		mlib_free( &env_region );
	}

	light_cleanup();
}

/*
 *			H I T _ N O T H I N G
 *
 *  a_miss() routine called when no part of the model is hit.
 *  Background texture mapping could be done here.
 *  For now, return a pleasant dark blue.
 */
static int hit_nothing(register struct application *ap)
{
	if( R_DEBUG&RDEBUG_MISSPLOT )  {
		vect_t	out;

		/* XXX length should be 1 model diameter */
		VJOIN1( out, ap->a_ray.r_pt,
			10000, ap->a_ray.r_dir );	/* to imply direction */
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		pl_color( stdout, 190, 0, 0 );
		pdv_3line( stdout, ap->a_ray.r_pt, out );
		bu_semaphore_release( BU_SEM_SYSCALL );
	}

	if( env_region.reg_mfuncs )  {
		struct gunk {
			struct partition part;
			struct hit	hit;
			struct shadework sw;
		} u;

		memset( (char *)&u, 0, sizeof(u) );
		/* Make "miss" hit the environment map */
		/* Build up the fakery */
		u.part.pt_magic = PT_MAGIC;
		u.part.pt_inhit = u.part.pt_outhit = &u.hit;
		u.part.pt_regionp = &env_region;
		u.hit.hit_magic = RT_HIT_MAGIC;
		u.hit.hit_dist = ap->a_rt_i->rti_radius * 2;	/* model diam */
		u.hit.hit_rayp = &ap->a_ray;

		u.sw.sw_transmit = u.sw.sw_reflect = 0.0;
		u.sw.sw_refrac_index = 1.0;
		u.sw.sw_extinction = 0;
		u.sw.sw_xmitonly = 1;		/* don't shade env map! */

		/* "Surface" Normal points inward, UV is azim/elev of ray */
		u.sw.sw_inputs = MFI_NORMAL|MFI_UV;
		VREVERSE( u.sw.sw_hit.hit_normal, ap->a_ray.r_dir );
		/* U is azimuth, atan() range: -pi to +pi */
		u.sw.sw_uv.uv_u = bn_atan2( ap->a_ray.r_dir[Y],
			ap->a_ray.r_dir[X] ) * bn_inv2pi;
		if( u.sw.sw_uv.uv_u < 0 )
			u.sw.sw_uv.uv_u += 1.0;
		/*
		 *  V is elevation, atan() range: -pi/2 to +pi/2,
		 *  because sqrt() ensures that X parameter is always >0
		 */
		u.sw.sw_uv.uv_v = bn_atan2( ap->a_ray.r_dir[Z],
			sqrt( ap->a_ray.r_dir[X] * ap->a_ray.r_dir[X] +
			ap->a_ray.r_dir[Y] * ap->a_ray.r_dir[Y]) ) *
			bn_invpi + 0.5;
		u.sw.sw_uv.uv_du = u.sw.sw_uv.uv_dv = 0;

		VSETALL( u.sw.sw_color, 1 );
		VSETALL( u.sw.sw_basecolor, 1 );

		if (R_DEBUG&RDEBUG_SHADE)
			bu_log("hit_nothing calling viewshade\n");

		(void)viewshade( ap, &u.part, &u.sw );

		VMOVE( ap->a_color, u.sw.sw_color );
		ap->a_user = 1;		/* Signal view_pixel:  HIT */
		ap->a_uptr = (genptr_t)&env_region;
		return(1);
	}

	ap->a_user = 0;		/* Signal view_pixel:  MISS */
	VMOVE( ap->a_color, background );	/* In case someone looks */
	return(0);
}

/*
 *			C O L O R V I E W
 *
 *  Manage the coloring of whatever it was we just hit.
 *  This can be a recursive procedure.
 */
int
colorview(register struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
{
	register struct partition *pp;
	register struct hit *hitp;
	struct shadework sw;

	pp = PartHeadp->pt_forw;
	if( ap->a_flag == 1 )
	{
		/* This ray is an escaping internal ray after refraction through glass.
		 * Sometimes, after refraction and starting a new ray at the glass exit,
		 * the new ray hits a sliver of the same glass, and gets confused. This bit
		 * of code attempts to spot this behavior and skip over the glass sliver.
		 * Any sliver less than 0.05mm thick will be skipped (0.05 is a SWAG).
		 */
		if( (genptr_t)pp->pt_regionp == ap->a_uptr &&
			pp->pt_forw != PartHeadp &&
			pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist < 0.05 )
				pp = pp->pt_forw;
	}

	for( ; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 ) break;

	if( pp == PartHeadp )  {
		bu_log("colorview:  no hit out front?\n");
		return(0);
	}


	RT_CK_PT(pp);
	hitp = pp->pt_inhit;
	RT_CK_HIT(hitp);
	RT_CK_RAY(hitp->hit_rayp);
	ap->a_uptr = (genptr_t)pp->pt_regionp;	/* note which region was shaded */

	if(R_DEBUG&RDEBUG_HITS)  {
		bu_log("colorview: lvl=%d coloring %s\n",
			ap->a_level,
			pp->pt_regionp->reg_name);
		rt_pr_pt( ap->a_rt_i, pp );
	}
	if( hitp->hit_dist >= INFINITY )  {
		bu_log("colorview:  entry beyond infinity\n");
		VSET( ap->a_color, .5, 0, 0 );
		ap->a_user = 1;		/* Signal view_pixel:  HIT */
		ap->a_dist = hitp->hit_dist;
		goto out;
	}

	/* Check to see if eye is "inside" the solid
	 * It might only be worthwhile doing all this in perspective mode
	 * XXX Note that hit_dist can be faintly negative, e.g. -1e-13
	 *
	 * XXX we should certainly only do this if the eye starts out inside
	 *  an opaque solid.  If it starts out inside glass or air we don't
	 *  really want to do this
	 */

	if( hitp->hit_dist < 0.0 && pp->pt_regionp->reg_aircode == 0 ) {
		struct application sub_ap;
		FAST fastf_t f;

		if( pp->pt_outhit->hit_dist >= INFINITY ||
		    ap->a_level > max_bounces )  {
		    	if( R_DEBUG&RDEBUG_SHOWERR )  {
				VSET( ap->a_color, 9, 0, 0 );	/* RED */
				bu_log("colorview:  eye inside %s (x=%d, y=%d, lvl=%d)\n",
					pp->pt_regionp->reg_name,
					ap->a_x, ap->a_y, ap->a_level);
		    	} else {
		    		VSETALL( ap->a_color, 0.18 );	/* 18% Grey */
		    	}
			ap->a_user = 1;		/* Signal view_pixel:  HIT */
			ap->a_dist = hitp->hit_dist;
			goto out;
		}
		/* Push on to exit point, and trace on from there */
		sub_ap = *ap;	/* struct copy */
		sub_ap.a_level = ap->a_level+1;
		f = pp->pt_outhit->hit_dist+hitp->hit_dist+0.0001;
		VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt, f, ap->a_ray.r_dir);
		sub_ap.a_purpose = "pushed eye position";
		(void)rt_shootray( &sub_ap );

		/* The eye is inside a solid and we are "Looking out" so
		 * we are going to darken what we see beyond to give a visual
		 * cue that something is wrong.
		 */
		VSCALE( ap->a_color, sub_ap.a_color, 0.80 );

		ap->a_user = 1;		/* Signal view_pixel: HIT */
		ap->a_dist = f + sub_ap.a_dist;
		ap->a_uptr = sub_ap.a_uptr;	/* which region */
		goto out;
	}

	if( R_DEBUG&RDEBUG_RAYWRITE )  {
		/* Record the approach path */
		if( hitp->hit_dist > 0.0001 )  {
			VJOIN1( hitp->hit_point, ap->a_ray.r_pt,
				hitp->hit_dist, ap->a_ray.r_dir );
			wraypts( ap->a_ray.r_pt,
				ap->a_ray.r_dir,
				hitp->hit_point,
				-1, ap, stdout );	/* -1 = air */
		}
	}
	if( R_DEBUG&(RDEBUG_RAYPLOT|RDEBUG_RAYWRITE|RDEBUG_REFRACT) )  {
		/*  There are two parts to plot here.
		 *  Ray start to inhit (purple),
		 *  and inhit to outhit (grey).
		 */
		if( hitp->hit_dist > 0.0001 )  {
			register int i, lvl;
			fastf_t out;
			vect_t inhit, outhit;

			lvl = ap->a_level % 100;
			if( lvl < 0 )  lvl = 0;
			else if( lvl > 3 )  lvl = 3;
			i = 255 - lvl * (128/4);

			VJOIN1( inhit, ap->a_ray.r_pt,
				hitp->hit_dist, ap->a_ray.r_dir );
			if( R_DEBUG&RDEBUG_RAYPLOT )  {
				bu_semaphore_acquire( BU_SEM_SYSCALL );
				pl_color( stdout, i, 0, i );
				pdv_3line( stdout, ap->a_ray.r_pt, inhit );
				bu_semaphore_release( BU_SEM_SYSCALL );
			}
			bu_log("From ray start to inhit (purple):\n \
vdraw open oray;vdraw params c %2.2x%2.2x%2.2x;vdraw write n 0 %g %g %g;vdraw write n 1 %g %g %g;vdraw send\n",
				i, 0, i,
				V3ARGS(ap->a_ray.r_pt),
				V3ARGS(inhit) );

			if( (out = pp->pt_outhit->hit_dist) >= INFINITY )
				out = 10000;	/* to imply the direction */
			VJOIN1( outhit,
				ap->a_ray.r_pt, out,
				ap->a_ray.r_dir );
			if( R_DEBUG&RDEBUG_RAYPLOT )  {
				bu_semaphore_acquire( BU_SEM_SYSCALL );
				pl_color( stdout, i, i, i );
				pdv_3line( stdout, inhit, outhit );
				bu_semaphore_release( BU_SEM_SYSCALL );
			}
			bu_log("From inhit to outhit (grey):\n \
vdraw open iray;vdraw params c %2.2x%2.2x%2.2x;vdraw write n 0 %g %g %g;vdraw write n 1 %g %g %g;vdraw send\n",
				i, i, i,
				V3ARGS(inhit), V3ARGS(outhit) );
		}
	}

	memset( (char *)&sw, 0, sizeof(sw) );
	sw.sw_transmit = sw.sw_reflect = 0.0;
	sw.sw_refrac_index = 1.0;
	sw.sw_extinction = 0;
	sw.sw_xmitonly = 0;		/* want full data */
	sw.sw_inputs = 0;		/* no fields filled yet */
	sw.sw_frame = curframe;
	sw.sw_pixeltime = sw.sw_frametime = curframe * frame_delta_t;
	sw.sw_segs = finished_segs;
	VSETALL( sw.sw_color, 1 );
	VSETALL( sw.sw_basecolor, 1 );

	if (R_DEBUG&RDEBUG_SHADE)
		bu_log("colorview calling viewshade\n");

	/* individual shaders must handle reflection & refraction */
	(void)viewshade( ap, pp, &sw );

	VMOVE( ap->a_color, sw.sw_color );
	ap->a_user = 1;		/* Signal view_pixel:  HIT */
	/* XXX This is always negative when eye is inside air solid */
	ap->a_dist = hitp->hit_dist;

out:
	/*
	 *  e ^(-density * distance)
	 */
	if (airdensity != 0.0) {
	    double g;
	    double f = exp(-hitp->hit_dist * airdensity);
	    g = (1.0 - f);

	    VSCALE(ap->a_color, ap->a_color, f);
	    VJOIN1(ap->a_color, ap->a_color, g, haze);
	}
	RT_CK_REGION(ap->a_uptr);
	if(R_DEBUG&RDEBUG_HITS)  {
		bu_log("colorview: lvl=%d ret a_user=%d %s\n",
			ap->a_level,
			ap->a_user,
			pp->pt_regionp->reg_name);
		VPRINT("color   ", ap->a_color);
	}
	return(1);
}



/*
 *			V I E W I T
 *
 *  a_hit() routine for simple lighting model.
 */
int viewit(register struct application *ap,
	   struct partition *PartHeadp,
	   struct seg	*segHeadp)
{
	register struct partition *pp;
	register struct hit *hitp;
	LOCAL fastf_t	diffuse0 = 0;
	LOCAL fastf_t	cosI0 = 0;
	LOCAL vect_t work0, work1;
	LOCAL struct light_specific *lp;
	vect_t		normal;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		bu_log("viewit:  no hit out front?\n");
		return(0);
	}
	hitp = pp->pt_inhit;
	RT_HIT_NORMAL( normal, hitp, pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip );

	/*
	 * Diffuse reflectance from each light source
	 */
	switch( lightmodel )  {
	case 1:
		/* Light from the "eye" (ray source).  Note sign change */
		lp = BU_LIST_FIRST( light_specific, &(LightHead.l) );
		diffuse0 = 0;
		if( (cosI0 = -VDOT(normal, ap->a_ray.r_dir)) >= 0.0 )
			diffuse0 = cosI0 * ( 1.0 - AmbientIntensity);
		VSCALE( work0, lp->lt_color, diffuse0 );

		/* Add in contribution from ambient light */
		VSCALE( work1, ambient_color, AmbientIntensity );
		VADD2( ap->a_color, work0, work1 );
		break;
	case 2:
		/* Store surface normals pointing inwards */
		/* (For Spencer's moving light program) */
		ap->a_color[0] = (normal[0] * (-.5)) + .5;
		ap->a_color[1] = (normal[1] * (-.5)) + .5;
		ap->a_color[2] = (normal[2] * (-.5)) + .5;
		break;
	case 4:
	 	{
			LOCAL struct curvature cv;
			FAST fastf_t f;

			RT_CURVATURE( &cv, hitp, pp->pt_inflip, pp->pt_inseg->seg_stp );
	
			f = cv.crv_c1;
			f *= 10;
			if( f < -0.5 )  f = -0.5;
			if( f > 0.5 )  f = 0.5;
			ap->a_color[0] = 0.5 + f;
			ap->a_color[1] = 0;

			f = cv.crv_c2;
			f *= 10;
			if( f < -0.5 )  f = -0.5;
			if( f > 0.5 )  f = 0.5;
			ap->a_color[2] = 0.5 + f;
		}
		break;
	case 5:
	 	{
			LOCAL struct curvature cv;

			RT_CURVATURE( &cv, hitp, pp->pt_inflip, pp->pt_inseg->seg_stp );

			ap->a_color[0] = (cv.crv_pdir[0] * (-.5)) + .5;
			ap->a_color[1] = (cv.crv_pdir[1] * (-.5)) + .5;
			ap->a_color[2] = (cv.crv_pdir[2] * (-.5)) + .5;
	 	}
		break;
	case 6:
		{
			LOCAL struct uvcoord uv;

			/* Exactly like 'testmap' shader: UV debug */
			RT_HIT_UVCOORD( ap, pp->pt_inseg->seg_stp, hitp, &uv );

			BU_ASSERT( uv.uv_u >= 0 );
			BU_ASSERT( uv.uv_u <= 1 );
			BU_ASSERT( uv.uv_v >= 0 );
			BU_ASSERT( uv.uv_v <= 1 );

			VSET( ap->a_color, uv.uv_u, 0, uv.uv_v );
		}
		break;
	case 7:
		{
		}
		break;
	}

	if(R_DEBUG&RDEBUG_HITS)  {
		rt_pr_hit( " In", hitp );
		bu_log("cosI0=%f, diffuse0=%f   ", cosI0, diffuse0 );
		VPRINT("RGB", ap->a_color);
	}
	ap->a_user = 1;		/* Signal view_pixel:  HIT */
	return(0);
}

void
free_scanlines(void)
{
	register int	y;

	for( y=0; y<height; y++ )  {
		if( scanline[y].sl_buf )  {
			bu_free( scanline[y].sl_buf, "sl_buf scanline buffer" );
			scanline[y].sl_buf = (char *)0;
		}
	}
	bu_free( (char *)scanline, "struct scanline[height]" );
	scanline = (struct scanline *)0;
}

/*
 *  			V I E W _ I N I T
 *
 *  Called once, early on in RT setup, before view size is set.
 */
int
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{
	extern char	liboptical_version[];

	if (rt_verbosity & VERBOSE_LIBVERSIONS)
		bu_log("%s", liboptical_version+5);

	optical_shader_init(&mfHead);	/* in liboptical/init.c */

	if( minus_o )  {
		/* Output is destined for a pixel file */
		return(0);		/* don't open framebuffer */
	}  else
	{
	    if (rpt_dist)
	    {
		bu_log("Warning: -d ignored.  Writing to frame buffer\n");
		rpt_dist = 0;
	    }
	    return(1);		/* open a framebuffer */
	}
}

/*
 *			R E P R O J E C T _ S P L A T
 *
 *  Called when the reprojected value lies on the current screen.
 *  Write the reprojected value into the screen,
 *  checking *screen* Z values if the new location is already occupied.
 *
 *  May be run in parallel.
 */
int	rt_scr_lim_dist_sq = 100;	/* dist**2 pixels allowed to move */

int
reproject_splat(int ix, int iy, register struct floatpixel *ip, const fastf_t *new_view_pt)
{
	register struct floatpixel	*op;
	int	count = 1;
#if 0
	static int foo;
#endif

	/* Reprojection lies on screen, see if dest pixel already occupied */
	op = &curr_float_frame[iy*width + ix];

	/* Don't reproject again if new val is more distant */
	if( op->ff_frame >= 0 )  {
		point_t o_pt;
		/* Recompute both distances from current eye_pt! */
		/* Inefficient, only need Z component. */
		MAT4X3PNT(o_pt, model2view, op->ff_hitpt);
#if 0
		if( foo != curframe )  {
			extern int print_on;
			foo = curframe;
			print_on = 1;
			bu_log("  ip=(%g,%g,%g) ip_view=(%g,%g,%g)\n  op=(%g,%g,%g), o_pt=(%g,%g,%g)\n",
				V3ARGS(ip->ff_hitpt), V3ARGS(new_view_pt),
				V3ARGS(op->ff_hitpt), V3ARGS(o_pt) );
		}
#endif
		if( o_pt[Z] > new_view_pt[Z] )
			return 0;	/* previous val closer to eye, leave it be. */
		else
			count = 0;	/* Already reproj, don't double-count */
	}

	/* re-use old pixel as new pixel */
	*op = *ip;	/* struct copy */

	return count;
}

/* Local communication a.la. worker() */
extern int per_processor_chunk;	/* how many pixels to do at once */
extern int cur_pixel;		/* current pixel number, 0..last_pixel */
extern int last_pixel;		/* last pixel number */

/*
 *			R E P R O J E C T _ W O R K E R
 */
void
reproject_worker(int cpu, genptr_t arg)
{
	int	pixel_start;
	int	pixelnum;
	register struct floatpixel	*ip;
	int	count = 0;

	/* The more CPUs at work, the bigger the bites we take */
	if( per_processor_chunk <= 0 )  per_processor_chunk = npsw;

	while(1)  {

		bu_semaphore_acquire( RT_SEM_WORKER );
		pixel_start = cur_pixel;
		cur_pixel += per_processor_chunk;
		bu_semaphore_release( RT_SEM_WORKER );

		for( pixelnum = pixel_start; pixelnum < pixel_start+per_processor_chunk; pixelnum++ )  {
			point_t	new_view_pt;
			int	ix, iy;

			if( pixelnum > last_pixel )
				goto out;

			ip = &prev_float_frame[pixelnum];

			if( ip->ff_frame < 0 )
				continue;	/* Not valid */
			if( ip->ff_dist <= -INFINITY )
				continue;	/* was a miss */
			/* new model2view has been computed before here */
			MAT4X3PNT( new_view_pt, model2view, ip->ff_hitpt );

			/* Convert from -1..+1 range to pixel subscript */
			ix = (new_view_pt[X] + 1) * 0.5 * width;
			iy = (new_view_pt[Y] + 1) * 0.5 * height;

			/*  If not in reproject-only mode,
			 *  apply quality-preserving heuristics.
			 */
			if( reproject_mode != 2 )  {
				register int dx, dy;
				int	agelim;

				/* Don't reproject if too pixel moved too far on the screen */
				dx = ix - ip->ff_x;
				dy = iy - ip->ff_y;
				if( dx*dx + dy*dy > rt_scr_lim_dist_sq )
					continue;	/* moved too far */

				/* Don't reproject for too many frame-times */
				/* See if old pixel is more then N frames old */
				/* Temporal load-spreading: Don't have 'em all die at the same age! */
				agelim = ((iy+ix)&03)+4;
				if( curframe - ip->ff_frame >= agelim )
					continue;	/* too old */
			}

			/* 4-way splat.  See if reprojects off of screen */
			if( ix >= 0 && ix < width && iy >= 0 && iy < height )
				count += reproject_splat( ix, iy, ip, new_view_pt );

			ix++;
			if( ix >= 0 && ix < width && iy >= 0 && iy < height )
				count += reproject_splat( ix, iy, ip, new_view_pt );

			iy++;
			if( ix >= 0 && ix < width && iy >= 0 && iy < height )
				count += reproject_splat( ix, iy, ip, new_view_pt );

			ix--;
			if( ix >= 0 && ix < width && iy >= 0 && iy < height )
				count += reproject_splat( ix, iy, ip, new_view_pt );
		}
	}

	/* Deposit the statistics */
out:
	bu_semaphore_acquire( RT_SEM_WORKER );
	reproj_cur += count;
	bu_semaphore_release( RT_SEM_WORKER );
}

void
collect_soltabs( struct bu_ptbl *stp_list, union tree *tr )
{
	switch( tr->tr_op ) {
	case OP_UNION:
	case OP_INTERSECT:
	case OP_XOR:
		collect_soltabs( stp_list, tr->tr_b.tb_left );
		collect_soltabs( stp_list, tr->tr_b.tb_right );
		break;
	case OP_SUBTRACT:
		collect_soltabs( stp_list, tr->tr_b.tb_left );
		break;
	case OP_SOLID:
		bu_ptbl_ins( stp_list, (long *)tr->tr_a.tu_stp );
		break;
	}
}

/*
 *  			V I E W 2 _ I N I T
 *
 *  Called each time a new image is about to be done.
 */
void
view_2init(register struct application *ap, char *framename)
{
	register int i;
	struct bu_ptbl stps;
#ifdef HAVE_UNIX_IO
	struct stat sb;
#endif

	ap->a_refrac_index = 1.0;	/* RI_AIR -- might be water? */
	ap->a_cumlen = 0.0;
	ap->a_miss = hit_nothing;
	ap->a_onehit = a_onehit;

	if (rpt_dist)
		pwidth = 3+8;
	else
		pwidth = 3;

	/* Always allocate the scanline[] array
	 * (unless we already have one in incremental mode)
	 */
	if( (!incr_mode || !scanline) && !fullfloat_mode )
	{
		if( scanline )  free_scanlines();
		scanline = (struct scanline *)bu_calloc(
			height, sizeof(struct scanline),
			"struct scanline[height]" );
	}

#ifdef RTSRV
	buf_mode = BUFMODE_RTSRV;		/* multi-pixel buffering */
#else
	if( fullfloat_mode )  {
		buf_mode = BUFMODE_FULLFLOAT;
	} else if( incr_mode )  {
		buf_mode = BUFMODE_INCR;
	} else if( width <= 96 )  {
		buf_mode = BUFMODE_UNBUF;
	} else if( npsw <= height/4 )  {
	    	/* Have each CPU do a whole scanline.
	    	 * Saves lots of semaphore overhead.
		 * For load balancing make sure each CPU has several lines to do.
	    	 */
		per_processor_chunk = width;
	    	buf_mode = BUFMODE_SCANLINE;
	}  else  {
		buf_mode = BUFMODE_DYNAMIC;
	}
#endif

	switch( buf_mode )  {
	case BUFMODE_UNBUF:
		bu_log("Single pixel I/O, unbuffered\n");
		break;	
	case BUFMODE_FULLFLOAT:
		if( !curr_float_frame )  {
bu_log("mallocing curr_float_frame\n");
			curr_float_frame = (struct floatpixel *)bu_malloc(
				width * height * sizeof(struct floatpixel),
				"floatpixel frame");
		}

		/* Mark entire current frame as "not computed" */
		{
			register struct floatpixel	*fp;

			for( fp = &curr_float_frame[width*height-1];
			     fp >= curr_float_frame; fp--
			) {
				fp->ff_frame = -1;
			}
		}

		/* Reproject previous frame */
		if( prev_float_frame && reproject_mode )  {
			reproj_cur = 0;	/* incremented by reproject_worker */
			reproj_max = width*height;

			cur_pixel = 0;
			last_pixel = width*height-1;
			if( npsw == 1 )
				reproject_worker(0,NULL);
			else
				bu_parallel( reproject_worker, npsw, NULL );
		} else {
			reproj_cur = reproj_max = 0;
		}
		break;
#ifdef RTSRV
	case BUFMODE_RTSRV:
		scanbuf = bu_malloc( srv_scanlen*pwidth + sizeof(long),
			"scanbuf [multi-line]" );
		break;
#endif
	case BUFMODE_INCR:
		{
			register int j = 1<<incr_level;
			register int w = 1<<(incr_nlevel-incr_level);

			bu_log("Incremental resolution %d\n", j);

			/* Diminish buffer expectations on work-saved lines */
			for( i=0; i<j; i++ )  {
				if( sub_grid_mode )  {
					/* ???? */
					if( (i & 1) == 0 )
						scanline[i*w].sl_left = j/2;
					else
						scanline[i*w].sl_left = j;
				} else {
					if( (i & 1) == 0 )
						scanline[i*w].sl_left = j/2;
					else
						scanline[i*w].sl_left = j;
				}
			}
		}
		if( incr_level > 1 )
				return;		 /* more res to come */
		break;

	case BUFMODE_SCANLINE:
		bu_log("Low overhead scanline-per-CPU buffering\n");
		/* Fall through... */
	case BUFMODE_DYNAMIC:
		if( buf_mode == BUFMODE_DYNAMIC &&
		    rt_verbosity & VERBOSE_OUTPUTFILE)
			bu_log("Dynamic scanline buffering\n");
		if( sub_grid_mode )  {
			for( i=sub_ymin; i<=sub_ymax; i++ )
				scanline[i].sl_left = sub_xmax-sub_xmin+1;
		} else {
			for( i=0; i<height; i++ )
				scanline[i].sl_left = width;
		}

#ifdef HAVE_UNIX_IO
		/*
		 *  This code allows the computation of a particular frame
		 *  to a disk file to be resumed automaticly.
		 *  This is worthwhile crash protection.
		 *  This use of stat() and fseek() is UNIX-specific.
		 *
		 *  This code depends on the file having already been opened
		 *  for both reading and writing for this special circumstance
		 *  of having a pre-existing file with partial results.
		 *  Ensure that positioning is precisely pixel aligned.
		 *  The file size is almost certainly
		 *  not an exact multiple of three bytes.
		 */
		if( outfp != NULL && pix_start == 0 &&
		    stat( framename, &sb ) >= 0 &&
		    sb.st_size > 0 )  {
			/* File exists, with partial results */
			register int	xx, yy;
		    	int		got;

			/* Replaced with new method of looking through whole image and calculating black pixels */
			/* pix_start = sb.st_size / sizeof(RGBpixel); */

		    	/* Protect against file being too large */
			if( pix_start > pix_end )  pix_start = pix_end;

		    	/* XXX Need to check for black interior regions! */

			xx = pix_start % width;
			yy = pix_start / width;
			fprintf(stderr,
				"Continuing with pixel %d (%d, %d) [size=%ld]\n",
				pix_start,
				xx, yy,
				(long)sb.st_size );

			scanline[yy].sl_buf = bu_calloc( width,
				sizeof(RGBpixel), 
				"sl_buf scanline buffer (for continuation scanline)");
			if( fseek( outfp, yy*width*pwidth, 0 ) != 0 )
		    		bu_log("fseek error\n");
		    	/* Read the fractional scanline */
			got = fread( scanline[yy].sl_buf, sizeof(RGBpixel),
			    xx, outfp );
		    	if( got != xx )
		    		bu_log("Unable to fread fractional scanline, wanted %d, got %d pixels\n", xx, got);

			/* Account for pixels that don't need to be done */
			scanline[yy].sl_left -= xx;
			for( i = yy-1; i >= 0; i-- )
				scanline[i].sl_left = 0;
		}
#endif
		break;
	default:
		rt_bomb("bad buf_mode");
	}

	/* This is where we do Preperations for each Lighting Model if it needs it.
	   Set Photon Mapping Off by default */
	PM_Activated= 0;
	switch( lightmodel )  {
	case 0:
		ap->a_hit = colorview;

		/* If user did not specify any light sources then 
		 *	create default light sources
		 */
		if( BU_LIST_IS_EMPTY( &(LightHead.l) )  ||
		    BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
			if(R_DEBUG&RDEBUG_SHOWERR)bu_log("No explicit light\n");
			light_maker(3, view2model);
		}
		break;
	case 2:
		VSETALL( background, 0 );	/* Neutral Normal */
		/* FALL THROUGH */
	case 1:
	case 4:
	case 5:
	case 6:
		ap->a_hit = viewit;
		light_maker(3, view2model);
		break;
	case 7:
		{
		struct	application	bakapp;

		memcpy(&bakapp,ap,sizeof(struct application));

		/* If user did not specify any light sources then create one */
		if (BU_LIST_IS_EMPTY(&(LightHead.l)) || BU_LIST_UNINITIALIZED(&(LightHead.l))) {
			if (rdebug&RDEBUG_SHOWERR)
				bu_log("No explicit light\n");
			light_maker(1, view2model);
		}

                /* Build Photon Map */
		PM_Activated= 1;
		BuildPhotonMap(ap,eye_model,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5],(int)pmargs[6],(int)pmargs[7],pmargs[8],pmfile);

		memcpy(ap,&bakapp,sizeof(struct application));
		/* Set callback for ray hit */
		ap -> a_hit= colorview;

		}
		break;
	default:
		rt_bomb("bad lighting model #");
	}
	ap->a_rt_i->rti_nlights = light_init(ap);


	/* Now OK to delete invisible light regions.
	 * Actually we just remove the references to these regions
	 * from the soltab structures in the space paritioning tree
	 */
	bu_ptbl_init( &stps, 8, "soltabs to delete" );
	if (R_DEBUG & RDEBUG_LIGHT) {
		bu_log( "deleting %d invisible light regions\n", BU_PTBL_LEN( &ap->a_rt_i->delete_regs ) );
	}
	for( i=0 ; i<BU_PTBL_LEN( &ap->a_rt_i->delete_regs ) ; i++ ) {
		struct region *rp;
		struct soltab *stp;
		int j;
		

		rp = (struct region *)BU_PTBL_GET( &ap->a_rt_i->delete_regs, i );

		/* make a list of soltabs containing primitives referenced by 
		 * invisible light regions
		 */
		collect_soltabs( &stps, rp->reg_treetop );

		/* remove the invisible light region pointers from the soltab structs */
		if (R_DEBUG & RDEBUG_LIGHT) {
			bu_log( "Removing invisible light region pointers from %d soltabs\n",
				BU_PTBL_LEN( &stps ) );
		}
		for( j=0 ; j<BU_PTBL_LEN( &stps ) ; j++ ) {
			int k;
			struct region *rp2;
			stp = (struct soltab *)BU_PTBL_GET( &stps, j );

			k = BU_PTBL_LEN( &stp->st_regions ) - 1;
			for( ; k>=0 ; k-- ) {
				rp2 = (struct region *)BU_PTBL_GET( &stp->st_regions, k );
				if( rp2 == rp ) {
					if (R_DEBUG & RDEBUG_LIGHT) {
						bu_log( "\tRemoving region %s from soltab for %s\n", rp2->reg_name, stp->st_dp->d_namep );
					}
					bu_ptbl_rm( &stp->st_regions, (long *)rp2 );
				}
			}

		}

		bu_ptbl_reset( &stps );
	}
	bu_ptbl_free( &stps );

	/* Create integer version of background color */
	inonbackground[0] = ibackground[0] = background[0] * 255.0 + 0.5;
	inonbackground[1] = ibackground[1] = background[1] * 255.0 + 0.5;
	inonbackground[2] = ibackground[2] = background[2] * 255.0 + 0.5;

	/*
	 * If a non-background pixel comes out the same color as the
	 * background, modify it slightly, to permit compositing.
	 * Perturb the background color channel with the largest intensity.
	 */
	if( inonbackground[0] > inonbackground[1] )  {
    		if( inonbackground[0] > inonbackground[2] )  i = 0;
    		else i = 2;
    	} else {
		if( inonbackground[1] > inonbackground[2] ) i = 1;
    		else i = 2;
    	}
	if( inonbackground[i] < 127 ) inonbackground[i]++;
    	else inonbackground[i]--;

}

/*
 *  		A P P L I C A T I O N _ I N I T
 *
 *  Called once, very early on in RT setup, even before command line
 *	is processed.
 */
void application_init (void)
{
  /*    rpt_overlap = 1; */
}
@


11.106
log
@change conf.h to a wrapped config.h
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /cvs/brlcad/rt/view.c,v 11.105 2004/04/05 05:45:59 morrison Exp $ (BRL)";
@


11.105
log
@merge of ansi-6-0-branch into head
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header$ (BRL)";
d40 5
a44 1
#include "conf.h"
@


11.104
log
@update copyright to include span through 2003
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.103 2003/10/29 15:49:21 jra Exp $ (BRL)";
d118 1
a118 1
void		free_scanlines();
d174 1
a174 2
view_pixel(ap)
register struct application *ap;
d525 1
a525 2
view_eol(ap)
register struct application *ap;
d556 1
a556 2
view_setup(rtip)
struct rt_i	*rtip;
d669 1
a669 2
static int hit_nothing( ap )
register struct application *ap;
d749 1
a749 4
colorview( ap, PartHeadp, finished_segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *finished_segs;
d1064 1
a1064 1
free_scanlines()
d1084 1
a1084 4
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
int minus_o;
d1119 1
a1119 5
reproject_splat( ix, iy, ip, new_view_pt )
int	ix;
int	iy;
register struct floatpixel	*ip;
const point_t			new_view_pt;
d1167 1
a1167 3
reproject_worker(cpu, arg)
int		cpu;
genptr_t	arg;
d1275 1
a1275 3
view_2init( ap, framename )
register struct application *ap;
char	*framename;
d1601 1
a1601 1
void application_init ()
@


11.103
log
@Mods to view_re_setup() to setup any region with a NULL mfuncs pointer.
@
text
@d33 1
a33 1
 *	This software is Copyright (C) 1985 by the United States Army.
d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.102 2003/10/08 17:34:41 morrison Exp $ (BRL)";
@


11.102
log
@Fix bug where pixels that have no blue component are off by one.
Added initialization of background to desired color in front-end now that background is provided by the liboptical.
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.101 2003/09/27 01:11:25 morrison Exp $ (BRL)";
d612 1
a612 1
 *	only regions whose bit number is greater than "old_nregions" will be processed.
d615 1
a615 1
view_re_setup( struct rt_i *rtip, int old_nregions, struct resource *resp )
d621 1
a621 1
		if( rp->reg_bit >= old_nregions ) {
@


11.101
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.100 2003/09/05 15:22:36 justin Exp $ (BRL)";
d109 2
a110 2
int	ibackground[3];			/* integer 0..255 version */
int	inonbackground[3];		/* integer non-background */
d232 2
a233 2
		if (b == 0)
		  b= 1;
@


11.101.2.1
log
@updates from HEAD, part 1
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.103 2003/10/29 15:49:21 jra Exp $ (BRL)";
d109 2
a110 2
int	ibackground[3] = {0};			/* integer 0..255 version */
int	inonbackground[3] = {0};		/* integer non-background */
d232 2
a233 2
		if (r==0 && g==0 && b==0 && benchmark==0)
		  b = 1;
d612 1
a612 1
 *	only regions with a NULL reg_mfuncs pointer will be processed.
d615 1
a615 1
view_re_setup( struct rt_i *rtip )
d621 1
a621 1
		if( !rp->reg_mfuncs ) {
@


11.101.2.2
log
@merge from HEAD
@
text
@d33 1
a33 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.104 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.101.2.3
log
@merge from head
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.101.2.2 2004/02/12 19:37:13 erikg Exp $ (BRL)";
@


11.100
log
@updated to support re-rendering of black pixels
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.99 2003/08/27 19:18:28 justin Exp $ (BRL)";
a64 2
int		use_air = 0;		/* Handling of air in librt */

d85 2
d96 2
d104 1
a104 1
struct region	env_region;		/* environment map region */
d108 1
a108 5
#if 0
vect_t	background = { 0.25, 0, 0.5 };	/* Dark Blue Background */
#else
vect_t	background = { 0, 0, 1.0/255 };	/* Nearly Black */
#endif
d236 1
a236 1
	if(rdebug&RDEBUG_HITS) bu_log("rgb=%3d,%3d,%3d xy=%3d,%3d (%g,%g,%g)\n",
d580 1
a580 1
			if(rdebug&RDEBUG_MATERIAL)
d591 1
a591 1
			if( rdebug&RDEBUG_MATERIAL &&
d675 1
a675 1
	if( rdebug&RDEBUG_MISSPLOT )  {
d730 1
a730 1
		if (rdebug&RDEBUG_SHADE)
d792 1
a792 1
	if(rdebug&RDEBUG_HITS)  {
d821 1
a821 1
		    	if( rdebug&RDEBUG_SHOWERR )  {
d853 1
a853 1
	if( rdebug&RDEBUG_RAYWRITE )  {
d864 1
a864 1
	if( rdebug&(RDEBUG_RAYPLOT|RDEBUG_RAYWRITE|RDEBUG_REFRACT) )  {
d881 1
a881 1
			if( rdebug&RDEBUG_RAYPLOT )  {
d898 1
a898 1
			if( rdebug&RDEBUG_RAYPLOT )  {
d923 1
a923 1
	if (rdebug&RDEBUG_SHADE)
d947 1
a947 1
	if(rdebug&RDEBUG_HITS)  {
d1061 1
a1061 1
	if(rdebug&RDEBUG_HITS)  {
d1500 1
a1500 1
			if(rdebug&RDEBUG_SHOWERR)bu_log("No explicit light\n");
d1548 1
a1548 1
	if (rdebug & RDEBUG_LIGHT) {
d1565 1
a1565 1
		if (rdebug & RDEBUG_LIGHT) {
d1578 1
a1578 1
					if (rdebug & RDEBUG_LIGHT) {
@


11.100.2.1
log
@Added photon mapping args for sphere invalidation
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.100 2003/09/05 15:22:36 justin Exp $ (BRL)";
d1531 1
a1531 1
		BuildPhotonMap(ap,eye_model,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5],(int)pmargs[6],(int)pmargs[7],pmargs[8],pmargs[9],pmargs[10],pmargs[11],pmargs[12],pmargs[13],pmfile);
@


11.99
log
@Updated for use with photon mapping (pmargs) and the lighting argument
is now more intelligent (-l).
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.97.2.6 2003/08/26 13:55:54 justin Exp $ (BRL)";
d232 4
d1452 2
a1453 1
			pix_start = sb.st_size / sizeof(RGBpixel);
@


11.98
log
@Added support for haze shading of void before eye point
@
text
@d16 2
d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.97 2003/04/07 18:01:15 jra Exp $ (BRL)";
d63 1
d955 2
d1053 4
d1485 3
d1511 23
d1538 1
@


11.97
log
@view_setup() now handles code 2 return from mlib_setup (from light_setup) by
adding the region to the "delete_regs" list in rt_i.
view2_init() now processes regions on the "delete_regs" list immediately
after calling light_init(). All references to these regions are deleted
from soltabs in the space partitioning tree.
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.96 2003/01/31 21:47:03 jra Exp $ (BRL)";
d90 2
d930 11
@


11.97.2.1
log
@updates to view for photonmapping
@
text
@a15 2
 *	6	UV Coord
 *	7	Photon Mapping
d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.97 2003/04/07 18:01:15 jra Exp $ (BRL)";
a60 1
#include "photonmap.h"
a938 2


a1034 4
	case 7:
		{
		}
		break;
a1462 3
	/* This is where we do Preperations for each Lighting Model if it needs it.
	   Set Photon Mapping Off by default */
	PM_Activated= 0;
a1485 36
	case 7:
		{
		point_t	m1,m2;

                m1[0]= ap -> a_ray.r_pt[0];
                m1[1]= ap -> a_ray.r_pt[1];
                m1[2]= ap -> a_ray.r_pt[2];

                m2[0]= ap -> a_ray.r_dir[0];
                m2[1]= ap -> a_ray.r_dir[1];
                m2[2]= ap -> a_ray.r_dir[2];

		/* If user did not specify any light sources then create one */
		if (BU_LIST_IS_EMPTY(&(LightHead.l)) || BU_LIST_UNINITIALIZED(&(LightHead.l))) {
			if (rdebug&RDEBUG_SHOWERR)
				bu_log("No explicit light\n");
			light_maker(1, view2model);
		}

                /* Build Photon Map */
		PM_Activated= 1;
		BuildPhotonMap(ap,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5]);

                ap -> a_ray.r_pt[0]= m1[0];
                ap -> a_ray.r_pt[1]= m1[1];
                ap -> a_ray.r_pt[2]= m1[2];

                ap -> a_ray.r_dir[0]= m2[0];
                ap -> a_ray.r_dir[1]= m2[1];
                ap -> a_ray.r_dir[2]= m2[2];

		/* Set callback for ray hit */
		ap -> a_hit = colorview;

		}
		break;
a1489 1

@


11.97.2.2
log
@Light Intensity
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.97.2.1 2003/08/07 22:07:00 justin Exp $ (BRL)";
d1519 1
a1519 1
		BuildPhotonMap(ap,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5],pmargs[6]);
@


11.97.2.3
log
@Visualization of Irradiance
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.97.2.2 2003/08/12 03:56:39 justin Exp $ (BRL)";
d1519 1
a1519 1
		BuildPhotonMap(ap,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5],(int)pmargs[6],pmargs[7]);
@


11.97.2.4
log
@more updates
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.97.2.3 2003/08/12 23:07:28 justin Exp $ (BRL)";
d1519 1
a1519 1
		BuildPhotonMap(ap,eye_model,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5],(int)pmargs[6],(int)pmargs[7],pmargs[8]);
@


11.97.2.5
log
@updated
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.97.2.4 2003/08/13 22:07:48 justin Exp $ (BRL)";
d1500 1
a1500 1
		struct	application	bakapp;
d1502 7
a1508 1
		memcpy(&bakapp,ap,sizeof(struct application));
d1519 9
a1527 1
		BuildPhotonMap(ap,eye_model,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5],(int)pmargs[6],(int)pmargs[7],pmargs[8],pmfile);
a1528 1
		memcpy(ap,&bakapp,sizeof(struct application));
d1530 1
a1530 1
		ap -> a_hit= colorview;
@


11.97.2.6
log
@updated for merging
@
text
@d37 1
a37 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.97.2.5 2003/08/24 23:28:53 justin Exp $ (BRL)";
a92 2
extern double	airdensity;		/* from opt.c */
extern double	haze[3];		/* from opt.c */
a930 11
	/*
	 *  e ^(-density * distance)
	 */
	if (airdensity != 0.0) {
	    double g;
	    double f = exp(-hitp->hit_dist * airdensity);
	    g = (1.0 - f);

	    VSCALE(ap->a_color, ap->a_color, f);
	    VJOIN1(ap->a_color, ap->a_color, g, haze);
	}
@


11.96
log
@view_2init() now creates 3 default lights if no expicit lights are being used
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.95 2002/12/31 14:46:03 jra Exp $ (BRL)";
d591 5
d1242 19
d1272 1
d1490 48
@


11.95
log
@Moved overlap reporting option handling to main.c
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.94 2002/09/26 19:58:06 jra Exp $ (BRL)";
d1448 1
a1448 1
			light_maker(1, view2model);
@


11.94
log
@Added view_re_setup() routine. Used for re-prepping.
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.93 2002/08/20 17:08:38 jra Exp $ (BRL)";
a1254 5
	bu_log( "rpt_overlap = %d\n", rpt_overlap );
	if (rpt_overlap)
		ap->a_logoverlap = ((void (*)())0);
	else
		ap->a_logoverlap = rt_silent_logoverlap;
@


11.93
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.91 2002/07/16 19:38:39 morrison Exp $ (BRL)";
d593 35
@


11.93.4.1
log
@sync to HEAD...
@
text
@a15 2
 *	6	UV Coord
 *	7	Photon Mapping
d31 1
a31 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/view.c,v 11.104 2004/02/02 17:39:39 morrison Exp $ (BRL)";
d61 2
a62 1
#include "photonmap.h"
a83 2
int		use_air = 0;		/* Handling of air in librt */

a89 4
extern double	airdensity;		/* from opt.c */
extern double	haze[3];		/* from opt.c */

extern struct floatpixel	*curr_float_frame;	/* buffer of full frame */
d97 1
a97 1
extern struct region	env_region;		/* environment map region */
d101 7
a107 3
extern vect_t	background;
int	ibackground[3] = {0};			/* integer 0..255 version */
int	inonbackground[3] = {0};		/* integer non-background */
a226 4

		/* Make sure it's never perfect black */
		if (r==0 && g==0 && b==0 && benchmark==0)
		  b = 1;
d229 1
a229 1
	if(R_DEBUG&RDEBUG_HITS) bu_log("rgb=%3d,%3d,%3d xy=%3d,%3d (%g,%g,%g)\n",
d573 1
a573 1
			if(R_DEBUG&RDEBUG_MATERIAL)
d584 1
a584 1
			if( R_DEBUG&RDEBUG_MATERIAL &&
a590 5
	        case 2:
			/* Full success, and this region should get dropped later */
			/* Add to list of regions to drop */
			bu_ptbl_ins( &rtip->delete_regs, (long *)regp );
			break;
a596 35
 *			V I E W _ R E _ S E T U P
 *
 *	This routine is used to do a "mlib_setup" on reprepped regions.
 *	only regions with a NULL reg_mfuncs pointer will be processed.
 */
void
view_re_setup( struct rt_i *rtip )
{
	struct region *rp;

	rp = BU_LIST_FIRST( region, &(rtip->HeadRegion) );
	while( BU_LIST_NOT_HEAD( rp, &(rtip->HeadRegion) ) ) {
		if( !rp->reg_mfuncs ) {
			switch( mlib_setup( &mfHead, rp, rtip ) ) {
			default:
			case -1:
				bu_log( "view_re_setup(): mlib_setup failed for region %s\n", rp->reg_name );
				break;
			case 0:
				{
					struct region *r = BU_LIST_NEXT( region, &rp->l );
					/* zap reg_udata? beware of light structs */
					rt_del_regtree( rtip, rp, &rt_uniresource );
					rp = r;
					continue;
				}
			case 1:
				break;
			}
		}
		rp = BU_LIST_NEXT( region, &rp->l );
	}
}

/*
d628 1
a628 1
	if( R_DEBUG&RDEBUG_MISSPLOT )  {
d683 1
a683 1
		if (R_DEBUG&RDEBUG_SHADE)
d745 1
a745 1
	if(R_DEBUG&RDEBUG_HITS)  {
d774 1
a774 1
		    	if( R_DEBUG&RDEBUG_SHOWERR )  {
d806 1
a806 1
	if( R_DEBUG&RDEBUG_RAYWRITE )  {
d817 1
a817 1
	if( R_DEBUG&(RDEBUG_RAYPLOT|RDEBUG_RAYWRITE|RDEBUG_REFRACT) )  {
d834 1
a834 1
			if( R_DEBUG&RDEBUG_RAYPLOT )  {
d851 1
a851 1
			if( R_DEBUG&RDEBUG_RAYPLOT )  {
d876 1
a876 1
	if (R_DEBUG&RDEBUG_SHADE)
a887 11
	/*
	 *  e ^(-density * distance)
	 */
	if (airdensity != 0.0) {
	    double g;
	    double f = exp(-hitp->hit_dist * airdensity);
	    g = (1.0 - f);

	    VSCALE(ap->a_color, ap->a_color, f);
	    VJOIN1(ap->a_color, ap->a_color, g, haze);
	}
d889 1
a889 1
	if(R_DEBUG&RDEBUG_HITS)  {
a898 2


a994 4
	case 7:
		{
		}
		break;
d997 1
a997 1
	if(R_DEBUG&RDEBUG_HITS)  {
a1201 19
void
collect_soltabs( struct bu_ptbl *stp_list, union tree *tr )
{
	switch( tr->tr_op ) {
	case OP_UNION:
	case OP_INTERSECT:
	case OP_XOR:
		collect_soltabs( stp_list, tr->tr_b.tb_left );
		collect_soltabs( stp_list, tr->tr_b.tb_right );
		break;
	case OP_SUBTRACT:
		collect_soltabs( stp_list, tr->tr_b.tb_left );
		break;
	case OP_SOLID:
		bu_ptbl_ins( stp_list, (long *)tr->tr_a.tu_stp );
		break;
	}
}

a1212 1
	struct bu_ptbl stps;
d1220 5
d1371 1
a1371 2
			/* Replaced with new method of looking through whole image and calculating black pixels */
			/* pix_start = sb.st_size / sizeof(RGBpixel); */
a1407 3
	/* This is where we do Preperations for each Lighting Model if it needs it.
	   Set Photon Mapping Off by default */
	PM_Activated= 0;
d1417 2
a1418 2
			if(R_DEBUG&RDEBUG_SHOWERR)bu_log("No explicit light\n");
			light_maker(3, view2model);
a1430 23
	case 7:
		{
		struct	application	bakapp;

		memcpy(&bakapp,ap,sizeof(struct application));

		/* If user did not specify any light sources then create one */
		if (BU_LIST_IS_EMPTY(&(LightHead.l)) || BU_LIST_UNINITIALIZED(&(LightHead.l))) {
			if (rdebug&RDEBUG_SHOWERR)
				bu_log("No explicit light\n");
			light_maker(1, view2model);
		}

                /* Build Photon Map */
		PM_Activated= 1;
		BuildPhotonMap(ap,eye_model,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5],(int)pmargs[6],(int)pmargs[7],pmargs[8],pmfile);

		memcpy(ap,&bakapp,sizeof(struct application));
		/* Set callback for ray hit */
		ap -> a_hit= colorview;

		}
		break;
a1434 49


	/* Now OK to delete invisible light regions.
	 * Actually we just remove the references to these regions
	 * from the soltab structures in the space paritioning tree
	 */
	bu_ptbl_init( &stps, 8, "soltabs to delete" );
	if (R_DEBUG & RDEBUG_LIGHT) {
		bu_log( "deleting %d invisible light regions\n", BU_PTBL_LEN( &ap->a_rt_i->delete_regs ) );
	}
	for( i=0 ; i<BU_PTBL_LEN( &ap->a_rt_i->delete_regs ) ; i++ ) {
		struct region *rp;
		struct soltab *stp;
		int j;
		

		rp = (struct region *)BU_PTBL_GET( &ap->a_rt_i->delete_regs, i );

		/* make a list of soltabs containing primitives referenced by 
		 * invisible light regions
		 */
		collect_soltabs( &stps, rp->reg_treetop );

		/* remove the invisible light region pointers from the soltab structs */
		if (R_DEBUG & RDEBUG_LIGHT) {
			bu_log( "Removing invisible light region pointers from %d soltabs\n",
				BU_PTBL_LEN( &stps ) );
		}
		for( j=0 ; j<BU_PTBL_LEN( &stps ) ; j++ ) {
			int k;
			struct region *rp2;
			stp = (struct soltab *)BU_PTBL_GET( &stps, j );

			k = BU_PTBL_LEN( &stp->st_regions ) - 1;
			for( ; k>=0 ; k-- ) {
				rp2 = (struct region *)BU_PTBL_GET( &stp->st_regions, k );
				if( rp2 == rp ) {
					if (R_DEBUG & RDEBUG_LIGHT) {
						bu_log( "\tRemoving region %s from soltab for %s\n", rp2->reg_name, stp->st_dp->d_namep );
					}
					bu_ptbl_rm( &stp->st_regions, (long *)rp2 );
				}
			}

		}

		bu_ptbl_reset( &stps );
	}
	bu_ptbl_free( &stps );
@


11.93.2.1
log
@Initial ANSIfication
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.93 2002/08/20 17:08:38 jra Exp $ (BRL)";
d115 1
a115 1
void		free_scanlines(void);
d171 2
a172 1
view_pixel(register struct application *ap)
d519 2
a520 1
view_eol(register struct application *ap)
d551 2
a552 1
view_setup(struct rt_i *rtip)
d625 2
a626 1
static int hit_nothing(register struct application *ap)
d706 4
a709 1
colorview(register struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
d1007 1
a1007 1
free_scanlines(void)
d1027 4
a1030 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d1065 5
a1069 1
reproject_splat(int ix, int iy, register struct floatpixel *ip, const fastf_t *new_view_pt)
d1117 3
a1119 1
reproject_worker(int cpu, genptr_t arg)
d1208 3
a1210 1
view_2init(register struct application *ap, char *framename)
d1464 1
a1464 1
void application_init (void)
@


11.93.2.2
log
@sync branch with HEAD
@
text
@a15 2
 *	6	UV Coord
 *	7	Photon Mapping
d31 1
a31 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d35 1
a35 1
static const char RCSview[] = "@@(#)$Header$ (BRL)";
d61 2
a62 1
#include "photonmap.h"
a83 2
int		use_air = 0;		/* Handling of air in librt */

a89 4
extern double	airdensity;		/* from opt.c */
extern double	haze[3];		/* from opt.c */

extern struct floatpixel	*curr_float_frame;	/* buffer of full frame */
d97 1
a97 1
extern struct region	env_region;		/* environment map region */
d101 7
a107 3
extern vect_t	background;
int	ibackground[3] = {0};			/* integer 0..255 version */
int	inonbackground[3] = {0};		/* integer non-background */
a225 4

		/* Make sure it's never perfect black */
		if (r==0 && g==0 && b==0 && benchmark==0)
		  b = 1;
d228 1
a228 1
	if(R_DEBUG&RDEBUG_HITS) bu_log("rgb=%3d,%3d,%3d xy=%3d,%3d (%g,%g,%g)\n",
d570 1
a570 1
			if(R_DEBUG&RDEBUG_MATERIAL)
d581 1
a581 1
			if( R_DEBUG&RDEBUG_MATERIAL &&
a587 5
	        case 2:
			/* Full success, and this region should get dropped later */
			/* Add to list of regions to drop */
			bu_ptbl_ins( &rtip->delete_regs, (long *)regp );
			break;
a593 35
 *			V I E W _ R E _ S E T U P
 *
 *	This routine is used to do a "mlib_setup" on reprepped regions.
 *	only regions with a NULL reg_mfuncs pointer will be processed.
 */
void
view_re_setup( struct rt_i *rtip )
{
	struct region *rp;

	rp = BU_LIST_FIRST( region, &(rtip->HeadRegion) );
	while( BU_LIST_NOT_HEAD( rp, &(rtip->HeadRegion) ) ) {
		if( !rp->reg_mfuncs ) {
			switch( mlib_setup( &mfHead, rp, rtip ) ) {
			default:
			case -1:
				bu_log( "view_re_setup(): mlib_setup failed for region %s\n", rp->reg_name );
				break;
			case 0:
				{
					struct region *r = BU_LIST_NEXT( region, &rp->l );
					/* zap reg_udata? beware of light structs */
					rt_del_regtree( rtip, rp, &rt_uniresource );
					rp = r;
					continue;
				}
			case 1:
				break;
			}
		}
		rp = BU_LIST_NEXT( region, &rp->l );
	}
}

/*
d624 1
a624 1
	if( R_DEBUG&RDEBUG_MISSPLOT )  {
d679 1
a679 1
		if (R_DEBUG&RDEBUG_SHADE)
d738 1
a738 1
	if(R_DEBUG&RDEBUG_HITS)  {
d767 1
a767 1
		    	if( R_DEBUG&RDEBUG_SHOWERR )  {
d799 1
a799 1
	if( R_DEBUG&RDEBUG_RAYWRITE )  {
d810 1
a810 1
	if( R_DEBUG&(RDEBUG_RAYPLOT|RDEBUG_RAYWRITE|RDEBUG_REFRACT) )  {
d827 1
a827 1
			if( R_DEBUG&RDEBUG_RAYPLOT )  {
d844 1
a844 1
			if( R_DEBUG&RDEBUG_RAYPLOT )  {
d869 1
a869 1
	if (R_DEBUG&RDEBUG_SHADE)
a880 11
	/*
	 *  e ^(-density * distance)
	 */
	if (airdensity != 0.0) {
	    double g;
	    double f = exp(-hitp->hit_dist * airdensity);
	    g = (1.0 - f);

	    VSCALE(ap->a_color, ap->a_color, f);
	    VJOIN1(ap->a_color, ap->a_color, g, haze);
	}
d882 1
a882 1
	if(R_DEBUG&RDEBUG_HITS)  {
a891 2


a987 4
	case 7:
		{
		}
		break;
d990 1
a990 1
	if(R_DEBUG&RDEBUG_HITS)  {
a1185 19
void
collect_soltabs( struct bu_ptbl *stp_list, union tree *tr )
{
	switch( tr->tr_op ) {
	case OP_UNION:
	case OP_INTERSECT:
	case OP_XOR:
		collect_soltabs( stp_list, tr->tr_b.tb_left );
		collect_soltabs( stp_list, tr->tr_b.tb_right );
		break;
	case OP_SUBTRACT:
		collect_soltabs( stp_list, tr->tr_b.tb_left );
		break;
	case OP_SOLID:
		bu_ptbl_ins( stp_list, (long *)tr->tr_a.tu_stp );
		break;
	}
}

a1194 1
	struct bu_ptbl stps;
d1202 5
d1353 1
a1353 2
			/* Replaced with new method of looking through whole image and calculating black pixels */
			/* pix_start = sb.st_size / sizeof(RGBpixel); */
a1389 3
	/* This is where we do Preperations for each Lighting Model if it needs it.
	   Set Photon Mapping Off by default */
	PM_Activated= 0;
d1399 2
a1400 2
			if(R_DEBUG&RDEBUG_SHOWERR)bu_log("No explicit light\n");
			light_maker(3, view2model);
a1412 23
	case 7:
		{
		struct	application	bakapp;

		memcpy(&bakapp,ap,sizeof(struct application));

		/* If user did not specify any light sources then create one */
		if (BU_LIST_IS_EMPTY(&(LightHead.l)) || BU_LIST_UNINITIALIZED(&(LightHead.l))) {
			if (rdebug&RDEBUG_SHOWERR)
				bu_log("No explicit light\n");
			light_maker(1, view2model);
		}

                /* Build Photon Map */
		PM_Activated= 1;
		BuildPhotonMap(ap,eye_model,npsw,width,height,hypersample,(int)pmargs[0],pmargs[1],(int)pmargs[2],pmargs[3],(int)pmargs[4],(int)pmargs[5],(int)pmargs[6],(int)pmargs[7],pmargs[8],pmfile);

		memcpy(ap,&bakapp,sizeof(struct application));
		/* Set callback for ray hit */
		ap -> a_hit= colorview;

		}
		break;
a1416 49


	/* Now OK to delete invisible light regions.
	 * Actually we just remove the references to these regions
	 * from the soltab structures in the space paritioning tree
	 */
	bu_ptbl_init( &stps, 8, "soltabs to delete" );
	if (R_DEBUG & RDEBUG_LIGHT) {
		bu_log( "deleting %d invisible light regions\n", BU_PTBL_LEN( &ap->a_rt_i->delete_regs ) );
	}
	for( i=0 ; i<BU_PTBL_LEN( &ap->a_rt_i->delete_regs ) ; i++ ) {
		struct region *rp;
		struct soltab *stp;
		int j;
		

		rp = (struct region *)BU_PTBL_GET( &ap->a_rt_i->delete_regs, i );

		/* make a list of soltabs containing primitives referenced by 
		 * invisible light regions
		 */
		collect_soltabs( &stps, rp->reg_treetop );

		/* remove the invisible light region pointers from the soltab structs */
		if (R_DEBUG & RDEBUG_LIGHT) {
			bu_log( "Removing invisible light region pointers from %d soltabs\n",
				BU_PTBL_LEN( &stps ) );
		}
		for( j=0 ; j<BU_PTBL_LEN( &stps ) ; j++ ) {
			int k;
			struct region *rp2;
			stp = (struct soltab *)BU_PTBL_GET( &stps, j );

			k = BU_PTBL_LEN( &stp->st_regions ) - 1;
			for( ; k>=0 ; k-- ) {
				rp2 = (struct region *)BU_PTBL_GET( &stp->st_regions, k );
				if( rp2 == rp ) {
					if (R_DEBUG & RDEBUG_LIGHT) {
						bu_log( "\tRemoving region %s from soltab for %s\n", rp2->reg_name, stp->st_dp->d_namep );
					}
					bu_ptbl_rm( &stp->st_regions, (long *)rp2 );
				}
			}

		}

		bu_ptbl_reset( &stps );
	}
	bu_ptbl_free( &stps );
@


11.92
log
@Converted from K&R to ANSI C - RFH
@
text
@d115 1
a115 1
void		free_scanlines(void);
d171 2
a172 1
view_pixel(register struct application *ap)
d519 2
a520 1
view_eol(register struct application *ap)
d551 2
a552 1
view_setup(struct rt_i *rtip)
d625 2
a626 1
static int hit_nothing(register struct application *ap)
d706 4
a709 1
colorview(register struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
d1007 1
a1007 1
free_scanlines(void)
d1027 4
a1030 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d1065 5
a1069 1
reproject_splat(int ix, int iy, register struct floatpixel *ip, const fastf_t *new_view_pt)
d1117 3
a1119 1
reproject_worker(int cpu, genptr_t arg)
d1208 3
a1210 1
view_2init(register struct application *ap, char *framename)
d1464 1
a1464 1
void application_init (void)
@


11.91
log
@Moved the non-local-only header file (light.h) from rt/ into the header directory since it is used by multiple targets (liboptical, rt, etc)
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.90 2002/07/16 19:29:27 morrison Exp $ (BRL)";
d115 1
a115 1
void		free_scanlines();
d171 1
a171 2
view_pixel(ap)
register struct application *ap;
d518 1
a518 2
view_eol(ap)
register struct application *ap;
d549 1
a549 2
view_setup(rtip)
struct rt_i	*rtip;
d622 1
a622 2
static int hit_nothing( ap )
register struct application *ap;
d702 1
a702 4
colorview( ap, PartHeadp, finished_segs )
register struct application *ap;
struct partition *PartHeadp;
struct seg *finished_segs;
d1000 1
a1000 1
free_scanlines()
d1020 1
a1020 4
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
int minus_o;
d1055 1
a1055 5
reproject_splat( ix, iy, ip, new_view_pt )
int	ix;
int	iy;
register struct floatpixel	*ip;
const point_t			new_view_pt;
d1103 1
a1103 3
reproject_worker(cpu, arg)
int		cpu;
genptr_t	arg;
d1192 1
a1192 3
view_2init( ap, framename )
register struct application *ap;
char	*framename;
d1446 1
a1446 1
void application_init ()
@


11.90
log
@Fixed an SMP race-condition bug when raytracing out to a file and the image size is less that 96 (BUFMODE_UNBUF).  An unprotected fwrite was causing incorrect pixel values to be written and possible segfaults.  Fix was to add an explicit fseek (since the fwrites are not atomic or thread-safe the passed file pointer may get corrupted) and semaphore protect the seek/write.
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.89 2002/03/13 14:44:28 jra Exp $ (BRL)";
d59 1
a59 1
#include "./light.h"
@


11.89
log
@Replaced calls to rint() with just an add of 0.5
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.88 2002/03/12 21:36:23 jra Exp $ (BRL)";
d130 1
a130 1
static int	pwidth;			/* Width of each pixel (in bytes) */
d283 1
d289 3
d297 1
d299 1
d1389 1
a1389 1
			if( fseek( outfp, yy*width*3L, 0 ) != 0 )
@


11.88
log
@Added a call to rint() when calculating integer background color
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.87 2002/01/22 19:00:14 jra Exp $ (BRL)";
d1431 3
a1433 3
	inonbackground[0] = ibackground[0] = rint( background[0] * 255 );
	inonbackground[1] = ibackground[1] = rint( background[1] * 255 );
	inonbackground[2] = ibackground[2] = rint( background[2] * 255 );
@


11.87
log
@rt now honors the -R option
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.86 2001/10/17 07:40:06 morrison Exp $ (BRL)";
d718 1
a718 1
		if( pp->pt_regionp == ap->a_uptr &&
d1431 3
a1433 3
	inonbackground[0] = ibackground[0] = background[0] * 255;
	inonbackground[1] = ibackground[1] = background[1] * 255;
	inonbackground[2] = ibackground[2] = background[2] * 255;
@


11.86
log
@Mac OS X warning and error fixes for non-production build
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.85 2001/10/12 18:39:36 butler Exp $ (BRL)";
d1214 1
d1218 1
a1218 1
		ap->a_overlap = rt_overlap_quietly;
d1460 1
a1460 1
    rpt_overlap = 1;
@


11.85
log
@forced rt_g.debug printing for certain cases, updated the "vdraw" debugging
output to match current syntax.
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.84 2001/06/27 17:50:04 rbowers Exp $ (BRL)";
d148 1
a148 1
int overlay = 0;
@


11.84
log
@-* Added ooclusion mode 3 (dithered transparency)!!!!!!
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.83 2001/05/16 21:38:18 morrison Exp $ (BRL)";
d835 1
a835 1
vdraw o oray;vdraw p c %2.2x%2.2x%2.2x;vdraw w n 0 %g %g %g;vdraw w n 1 %g %g %g;vdraw s\n",
d852 1
a852 1
vdraw o iray;vdraw p c %2.2x%2.2x%2.2x;vdraw w n 0 %g %g %g;vdraw w n 1 %g %g %g;vdraw s\n",
@


11.83
log
@PRODUCTION optimizations
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.82 2001/04/05 19:36:04 morrison Exp $ (BRL)";
d142 8
d158 2
@


11.82
log
@updated SIGNED to signed
updated CONST to const
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.81 2001/03/19 22:20:14 butler Exp $ (BRL)";
d631 1
a631 1
		bzero( (char *)&u, sizeof(u) );
d848 1
a848 1
	bzero( (char *)&sw, sizeof(sw) );
@


11.81
log
@patches to merge 5.3 into 6.0
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /d/CVS/brlcad/rt/view.c,v 11.80 2000/11/01 04:16:33 mike Exp $ (BRL)";
d1053 1
a1053 1
CONST point_t			new_view_pt;
@


11.80
log
@
Allow a_onehit to be set from the command line. e.g.
 -c "set a_onehit=0;set"
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.79 2000/10/20 18:55:01 mike Exp $ (BRL)";
d699 18
a716 2
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
d721 2
d1205 1
a1205 1
		ap->a_overlap = RT_AFN_NULL;
d1209 1
@


11.79
log
@
Locking for making plot files in parallel.
Keeps CPUs from tripping over each other.
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.78 2000/09/08 05:54:46 mike Exp $ (BRL)";
d136 6
d148 1
d1190 1
a1190 1
	ap->a_onehit = -1;		/* Require at least one non-air hit */
@


11.78
log
@
Modified tree routines to take resource pointer.
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.77 2000/08/17 02:41:37 mike Exp $ (BRL)";
d611 1
d614 1
d794 1
d797 1
d811 1
d814 1
@


11.77
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d35 1
a35 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.76 2000/07/31 02:01:16 butler Exp $ (BRL)";
d555 1
a555 1
				rt_del_regtree( rtip, regp );
@


11.76
log
@Support for a new method for light sample pts.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.75 2000/07/27 19:32:52 butler Exp $ (BRL)";
@


11.75
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.74 2000/07/25 16:39:48 butler Exp $ (BRL)";
d1385 1
a1385 1
	ap->a_rt_i->rti_nlights = light_init();
@


11.74
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.73 2000/02/02 20:02:27 mike Exp $ (BRL)";
d91 6
d602 1
a602 1
static hit_nothing( ap )
@


11.73
log
@
Use BUFMODE_DYNAMIC even with one CPU.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.72 2000/01/22 03:51:44 mike Exp $ (BRL)";
d41 1
d58 1
a58 1
#include "./rdebug.h"
d60 1
d499 2
a500 2
view_end(ap)
struct application *ap;
a513 1
	return(0);		/* OK */
d572 1
a572 3
void
view_cleanup(rtip)
struct rt_i	*rtip;
d851 3
a853 4
viewit( ap, PartHeadp, segHeadp )
register struct application *ap;
struct partition *PartHeadp;
struct seg	*segHeadp;
d973 1
d977 1
@


11.73.2.1
log
@Fixed bug where an escaping ray after refraction would see a sliver of the
glass that it was supposed to escape from. Uses new "a_flag" field of
application structure.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.73 2000/02/02 20:02:27 mike Exp $ (BRL)";
d685 2
a686 18
	pp = PartHeadp->pt_forw;
	if( ap->a_flag == 1 )
	{
		/* This ray is an escaping internal ray after refraction through glass.
		 * Sometimes, after refraction and starting a new ray at the glass exit,
		 * the new ray hits a sliver of the same glass, and gets confused. This bit
		 * of code attempts to spot this behavior and skip over the glass sliver.
		 * Any sliver less than 0.02mm thick will be skipped (0.02 is a SWAG).
		 */
		if( pp->pt_regionp == ap->a_uptr &&
			pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist < 0.02 &&
			pp->pt_forw != PartHeadp )
				pp = pp->pt_forw;
	}

	for( ; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 ) break;

a690 2


@


11.73.2.2
log
@A couple kludges to avoid errors where refracted or reflected rays
unexpectedly hit/miss the glass region.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.73.2.1 2000/11/28 00:04:30 jra Exp $ (BRL)";
d692 1
a692 1
		 * Any sliver less than 0.05mm thick will be skipped (0.05 is a SWAG).
d695 2
a696 2
			pp->pt_forw != PartHeadp &&
			pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist < 0.05 )
@


11.73.2.3
log
@rt finally honors the -R option (do not report overlaps)
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.73.2.2 2000/11/29 19:15:49 jra Exp $ (BRL)";
d1186 1
a1186 1
		ap->a_logoverlap = ((void (*)())0);
d1188 1
a1188 1
		ap->a_logoverlap = rt_silent_logoverlap;
@


11.72
log
@
Added additional error checking of magic numbers.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.71 2000/01/13 20:30:23 mike Exp $ (BRL)";
a1194 10
	} else if( rt_g.rtg_parallel )  {
		if( npsw > 1 && npsw <= height )  {
		    	/* Have each CPU do a whole scanline.
		    	 * Saves lots of semaphore overhead.
		    	 */
			per_processor_chunk = width;
		    	buf_mode = BUFMODE_SCANLINE;
		} else {
			buf_mode = BUFMODE_DYNAMIC;
		}
d1197 7
@


11.71
log
@
Added lighmodel -l6 to RT, to debug UV parameterization.
Exactly like applying 'testmap' to every region.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.70 1999/12/30 05:49:29 butler Exp $ (BRL)";
d694 1
@


11.70
log
@additions for -v flag to rt
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.69 1999/12/23 05:59:01 mike Exp $ (BRL)";
d928 15
d1374 1
@


11.69
log
@
struct region is now a bu_list
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.68 1999/12/22 02:28:05 mike Exp $ (BRL)";
d965 2
a966 1
	bu_log("%s", liboptical_version+5);
d1271 2
a1272 1
		if( buf_mode == BUFMODE_DYNAMIC )
@


11.68
log
@
Removed dead vars
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.67 1999/12/03 23:33:50 mike Exp $ (BRL)";
d535 2
a536 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; )  {
d546 1
a546 1
				struct region *r = regp->reg_forw;
d562 1
a562 1
		regp = regp->reg_forw;
d578 1
a578 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
@


11.67
log
@
Added cut-n-paste debug for one-step-at-a-time debugging
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.66 1999/11/24 22:16:07 mike Exp $ (BRL)";
d1052 1
a1052 1
	register struct floatpixel	*ip, *op;
@


11.66
log
@
Removed obsolete include files
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.65 1999/10/30 03:53:05 mike Exp $ (BRL)";
d767 1
a767 1
	if( rdebug&RDEBUG_RAYPLOT )  {
d784 9
a792 2
			pl_color( stdout, i, 0, i );
			pdv_3line( stdout, ap->a_ray.r_pt, inhit );
d799 8
a806 2
			pl_color( stdout, i, i, i );
			pdv_3line( stdout, inhit, outhit );
@


11.65
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.64 1999/10/30 03:06:27 butler Exp $ (BRL)";
a51 1
#include "rtlist.h"
@


11.64
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.63 1999/05/28 03:19:29 mike Exp $ (BRL)";
d620 1
d623 1
d625 1
d691 1
d693 1
@


11.63
log
@
Added "set gamma=2.2" support in view.c
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.62 1999/05/20 06:39:11 mike Exp $ (BRL)";
a58 1
#include "./mathtab.h"
d181 1
a181 1
				rand0to1(ap->a_resource->re_randptr);
d183 1
a183 1
				rand0to1(ap->a_resource->re_randptr);
d185 1
a185 1
				rand0to1(ap->a_resource->re_randptr);
d187 3
a189 3
			r = ap->a_color[0]*255.+rand0to1(ap->a_resource->re_randptr);
			g = ap->a_color[1]*255.+rand0to1(ap->a_resource->re_randptr);
			b = ap->a_color[2]*255.+rand0to1(ap->a_resource->re_randptr);
@


11.62
log
@
Kick in the performance boost with just 2 cpus.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.61 1999/05/20 05:16:46 mike Exp $ (BRL)";
d128 1
d133 1
d174 18
a191 3
		r = ap->a_color[0]*255.+rand0to1(ap->a_resource->re_randptr);
		g = ap->a_color[1]*255.+rand0to1(ap->a_resource->re_randptr);
		b = ap->a_color[2]*255.+rand0to1(ap->a_resource->re_randptr);
@


11.61
log
@
Implemented significant performance boost for renderings with
large number of CPUs.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.60 1999/01/28 03:50:57 mike Exp $ (BRL)";
d1145 1
a1145 1
		if( npsw >= 4 && npsw <= height )  {
@


11.60
log
@Incorporated performance enhancement inspired by patent application.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.59 1999/01/13 22:07:35 mike Exp $ (BRL)";
d117 1
d321 28
d429 1
d1145 9
a1153 1
		buf_mode = BUFMODE_DYNAMIC;
d1232 3
d1236 2
a1237 1
		bu_log("Dynamic scanline buffering\n");
d1271 2
@


11.59
log
@Fixed args to htond()
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.58 1998/12/10 03:35:49 mike Exp $ (BRL)";
a938 1
	int	agelim;
a967 16
	/* If not in reproject-only mode, apply heuristics */
	if( reproject_mode != 2 )  {
		register int dx, dy;
		/* Don't reproject if too pixel moved too far on the screen */
		dx = ix - ip->ff_x;
		dy = iy - ip->ff_y;
		if( dx*dx + dy*dy > rt_scr_lim_dist_sq )  return 0;

		/* Don't reproject for too many frame-times */
		/* See if old pixel is more then N frames old */
		/* Temporal load-spreading: Don't have 'em all die at the same age! */
		agelim = ((iy+ix)&03)+4;
		if( curframe - ip->ff_frame >= agelim )
			return 0;
	}

d1017 1
d1021 23
a1043 1
			/* See if reprojects off of screen */
@


11.58
log
@env_region is defined here and exported to lib*/sh_text.c, not the
other way around.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.57 1998/09/22 01:43:12 mike Exp $ (BRL)";
d155 1
a155 1
	    htond(dist, &(ap->a_dist), 1);
@


11.57
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.56 1998/06/25 07:40:56 mike Exp $ (BRL)";
d91 1
a91 1
extern struct region	env_region;	/* from text.c */
@


11.56
log
@Port to sun4
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/view.c,v 11.55 1998/06/03 06:15:04 mike Exp $ (BRL)";
d55 2
a58 1
#include "./material.h"
d125 1
d127 1
d491 1
a491 1
		switch( mlib_setup( regp, rtip ) )  {
d899 3
d903 1
a903 51
	/*
	 *  Connect up material library interfaces
	 *  Note that plastic.c defines the required "default" entry.
	 */
	{
		extern struct mfuncs phg_mfuncs[];
		extern struct mfuncs light_mfuncs[];
		extern struct mfuncs cloud_mfuncs[];
		extern struct mfuncs spm_mfuncs[];
		extern struct mfuncs txt_mfuncs[];
		extern struct mfuncs stk_mfuncs[];
		extern struct mfuncs cook_mfuncs[];
		extern struct mfuncs marble_mfuncs[];
		extern struct mfuncs stxt_mfuncs[];
		extern struct mfuncs points_mfuncs[];
		extern struct mfuncs toyota_mfuncs[];
		extern struct mfuncs wood_mfuncs[];
		extern struct mfuncs camo_mfuncs[]; 
		extern struct mfuncs scloud_mfuncs[];
		extern struct mfuncs air_mfuncs[];
		extern struct mfuncs rtrans_mfuncs[];
		extern struct mfuncs fire_mfuncs[];
		extern struct mfuncs brdf_mfuncs[];
		extern struct mfuncs gauss_mfuncs[];
		extern struct mfuncs gravel_mfuncs[];
		extern struct mfuncs prj_mfuncs[];
		extern struct mfuncs grass_mfuncs[];

		mlib_add( phg_mfuncs );
		mlib_add( light_mfuncs );
		mlib_add( cloud_mfuncs );
		mlib_add( spm_mfuncs );
		mlib_add( txt_mfuncs );
		mlib_add( stk_mfuncs );
		mlib_add( cook_mfuncs );
		mlib_add( marble_mfuncs );
		mlib_add( stxt_mfuncs );
		mlib_add( points_mfuncs );
		mlib_add( toyota_mfuncs );
		mlib_add( wood_mfuncs );
		mlib_add( camo_mfuncs );
		mlib_add( scloud_mfuncs );
		mlib_add( air_mfuncs );
		mlib_add( rtrans_mfuncs );
		mlib_add( fire_mfuncs );
		mlib_add( brdf_mfuncs );
		mlib_add( gauss_mfuncs );
		mlib_add( gravel_mfuncs );
		mlib_add( prj_mfuncs );
		mlib_add( grass_mfuncs );
	}
@


11.55
log
@Fixed pixel motion test
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.54 1998/06/03 05:11:23 mike Exp mike $ (BRL)";
d1068 1
a1068 1
				return;
d1100 1
@


11.54
log
@Don't initialize an extern on IRIX, or it will make a new variable.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.53 1998/06/03 05:09:30 mike Exp mike $ (BRL)";
d1017 2
a1018 2
		dx = ix - op->ff_x;
		dy = iy - op->ff_y;
@


11.53
log
@Re-use variables from worker
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.52 1998/06/03 05:01:39 mike Exp mike $ (BRL)";
d1036 1
a1036 1
extern int	per_processor_chunk = 0;	/* how many pixels to do at once */
@


11.52
log
@Eliminated debugging store of orange pixels
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.51 1998/05/28 04:21:39 mike Exp mike $ (BRL)";
d1036 3
a1038 3
int		per_processor_chunk = 0;	/* how many pixels to do at once */
HIDDEN int cur_pixel;		/* current pixel number, 0..last_pixel */
HIDDEN int last_pixel;		/* last pixel number */
@


11.51
log
@Added additional heuristic to not reproject pixels very far.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.50 1998/05/22 21:01:14 mike Exp mike $ (BRL)";
a1179 1
fp->ff_color[0] = fp->ff_color[1] = 50; fp->ff_color[2] = 0;	/* orange -- sanity */
@


11.50
log
@Converted reprojection to run in parallel
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.49 1998/05/22 05:49:25 mike Exp mike $ (BRL)";
d200 2
d972 2
d1013 1
a1013 1
	/* Don't reproject too many frame-times */
d1015 7
d1024 1
a1024 1
		agelim = ((iy+ix)&03)+2;
@


11.49
log
@Split out reproject_splat().
Now do 4-pixel splat.
Employs correct Z comparison.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.48 1998/05/22 04:54:40 mike Exp mike $ (BRL)";
d963 6
d1024 70
d1175 2
a1176 7
			register struct floatpixel	*ip, *op;
			int	count = 0;
			for( ip = &prev_float_frame[width*height-1];
			     ip >= prev_float_frame; ip--
			) {
				point_t	new_view_pt;
				int	ix, iy;
d1178 6
a1183 27
				if( ip->ff_frame < 0 )
					continue;	/* Not valid */
				if( ip->ff_dist <= -INFINITY )
					continue;	/* was a miss */
				/* new model2view has been computed before here */
				MAT4X3PNT( new_view_pt, model2view, ip->ff_hitpt );
				/* Convert from -1..+1 range to pixel subscript */
				ix = (new_view_pt[X] + 1) * 0.5 * width;
				iy = (new_view_pt[Y] + 1) * 0.5 * height;
				/* See if reprojects off of screen */
				if( ix >= 0 && ix < width && iy >= 0 && iy < height )
					count += reproject_splat( ix, iy, ip, new_view_pt );

				ix++;
				if( ix >= 0 && ix < width && iy >= 0 && iy < height )
					count += reproject_splat( ix, iy, ip, new_view_pt );

				iy++;
				if( ix >= 0 && ix < width && iy >= 0 && iy < height )
					count += reproject_splat( ix, iy, ip, new_view_pt );

				ix--;
				if( ix >= 0 && ix < width && iy >= 0 && iy < height )
					count += reproject_splat( ix, iy, ip, new_view_pt );
			}
			reproj_cur = count;
			reproj_max = width*height;
@


11.48
log
@Support for reproject_mode 2:  reproject without re-raytracing.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.47 1998/05/13 02:40:10 mike Exp mike $ (BRL)";
d962 57
a1105 1
				int	agelim;
d1113 1
d1117 14
a1130 37
				if( ix < 0 || ix >= width )  continue;
				if( iy < 0 || iy >= height )  continue;
				/* Reprojection lies on screen, see if pixel already occupied */
				op = &curr_float_frame[iy*width + ix];
				/* Don't reproject again if new val is more distant */
				if( op->ff_frame >= 0 )  {
					point_t o_pt;
#if 0
static int foo;
#endif
					/* Recompute both distances from current eye_pt! */
					/* Inefficient, only need Z component. */
					MAT4X3PNT(o_pt, model2view, op->ff_hitpt);
#if 0
if( foo != curframe )  {
extern int print_on;
	foo = curframe;
	print_on = 1;
	bu_log("  ip=(%g,%g,%g) ip_view=(%g,%g,%g)\n  op=(%g,%g,%g), o_pt=(%g,%g,%g)\n",
		V3ARGS(ip->ff_hitpt), V3ARGS(new_view_pt),
		V3ARGS(op->ff_hitpt), V3ARGS(o_pt) );
}
#endif
					if( o_pt[Z] > new_view_pt[Z] )  continue;
					else count--;	/* Don't double-count */
				}
				/* Don't reproject too many times */
				/* See if old pixel is more then N frames old */
#if 0
				agelim = ((iy+ix)&03)+2;
agelim = 30;
				if( curframe - ip->ff_frame >= agelim )
					continue;
#endif
				/* re-use old pixel as new pixel */
				*op = *ip;	/* struct copy */
				count++;
@


11.47
log
@Image reprojection has begun working!
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.46 1998/05/12 22:52:09 mike Exp mike $ (BRL)";
d454 5
a458 3
		tmp = prev_float_frame;
		prev_float_frame = curr_float_frame;
		curr_float_frame = tmp;
d1036 1
d1066 18
a1083 3
					/* XXX Need to recompute both distances from current eye_pt! */
/* XXXXXX This is main source of speckles */
					if( op->ff_dist < ip->ff_dist )  continue;
d1088 1
d1090 1
d1093 1
@


11.46
log
@Initial reprojection support
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.45 1998/05/06 04:40:45 mike Exp mike $ (BRL)";
d139 1
d202 1
d209 21
d604 1
d636 1
d682 1
a682 1
		f = pp->pt_outhit->hit_dist+0.0001;
d694 2
a695 1
		ap->a_dist = hitp->hit_dist;
d762 1
d764 1
d1046 1
d1048 2
d1054 2
a1055 2
				ix = new_view_pt[X] * width;
				iy = new_view_pt[Y] * height;
d1059 1
d1061 8
d1070 3
@


11.45
log
@Additions to pixel reprojection code.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.44 1998/03/19 04:37:45 mike Exp mike $ (BRL)";
a123 10
int	fullfloat_mode = 0;
struct floatpixel {
	double	ff_dist;		/* range to ff_hitpt[], <-INFINITY for miss */
	float	ff_hitpt[3];
	char	ff_color[3];
	int	ff_frame;		/* >= 0 means pixel was reprojected */
};
struct floatpixel	*curr_float_frame;	/* buffer of full frame */
struct floatpixel	*prev_float_frame;
/* XXX should record width&height, in case size changes on-the-fly */
d427 1
a427 1
	if( buf_mode == BUFMODE_FULLFLOAT )  {
d429 1
a429 1
		/* Transmit scanlines, if not done by rtsync? */
d992 1
d1010 1
a1010 1
		if( prev_float_frame )  {
d1012 1
d1021 1
a1021 1
/* XXX has new model2view been computed yet? */
d1023 2
a1024 2
				ix = new_view_pt[X];
				iy = new_view_pt[Y];
d1032 1
d1034 4
@


11.44
log
@64-bit
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.43 1998/03/19 03:57:14 mike Exp mike $ (BRL)";
d129 1
d133 1
d205 1
d438 4
a441 3
		if( prev_float_frame )  {
			bu_free( (genptr_t)prev_float_frame, "floatpixel frame");
		}
d443 1
a443 3
		curr_float_frame = (struct floatpixel *)bu_malloc(
			width * height * sizeof(struct floatpixel),
			"floatpixel frame");
d1005 36
@


11.43
log
@Made paramters match for a_hit and a_miss
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.42 1998/03/08 19:53:15 butler Exp mike $ (BRL)";
d1077 1
a1077 1
				"Continuing with pixel %d (%d, %d) [size=%d]\n",
d1080 1
a1080 1
				sb.st_size );
@


11.42
log
@removed paint shader, going with prj shader
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.41 1998/01/23 02:01:50 mike Exp butler $ (BRL)";
d529 1
a529 1
static hit_nothing( ap, PartHeadp )
a530 1
struct partition *PartHeadp;
d760 1
a760 1
viewit( ap, PartHeadp )
d763 1
@


11.41
log
@Added support for -j flag (just these scanlines).
Support for incremental mode not finished.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.40 1997/11/21 04:43:55 mike Exp mike $ (BRL)";
a896 1
		extern struct mfuncs paint_mfuncs[];
a919 1
		mlib_add( paint_mfuncs );
@


11.40
log
@Actually fixed memory leak.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.39 1997/11/20 23:06:42 mike Exp mike $ (BRL)";
d360 13
a372 4
				npix = fb_write( fbp, 0, yy,
					(unsigned char *)scanline[yy].sl_buf,
					width );
				if( npix != width )  break;
d383 8
a390 2
			npix = fb_write( fbp, 0, ap->a_y,
			    (unsigned char *)scanline[ap->a_y].sl_buf, width );
d392 5
a396 1
			if( npix < width )  rt_bomb("scanline fb_write error");
d1022 12
a1033 4
				if( (i & 1) == 0 )
					scanline[i*w].sl_left = j/2;
				else
					scanline[i*w].sl_left = j;
d1042 7
a1048 2
		for( i=0; i<height; i++ )
			scanline[i].sl_left = width;
@


11.39
log
@Fixing memory leak
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.38 1997/11/18 07:03:07 mike Exp mike $ (BRL)";
a417 1
			prev_float_frame = curr_float_frame;
d419 1
@


11.38
log
@Added BUFMODE_FULLFLOAT for supporting remrt/rtnode with
real-time output.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.37 1997/11/17 19:30:50 mike Exp mike $ (BRL)";
d416 7
a422 1
		/* For now, disposal of the frame is handled elsewhere */
d828 1
d982 4
a985 3
		if( prev_float_frame )  {
			bu_free( (genptr_t)prev_float_frame, "floatpixel frame");
			prev_float_frame = curr_float_frame;
a986 3
		curr_float_frame = (struct floatpixel *)bu_malloc(
			width * height * sizeof(struct floatpixel),
			"floatpixel frame");
@


11.37
log
@Changed to bu_
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.36 1997/11/14 04:40:23 mike Exp mike $ (BRL)";
d115 1
d124 9
d194 1
a194 1
		ap->a_color[0], ap->a_color[1], ap->a_color[2] );
d198 19
d415 5
a419 1
	free_scanlines();
d718 1
d946 1
a946 1
	if( !incr_mode || !scanline )
d957 3
a959 1
	if( incr_mode )  {
d974 9
@


11.36
log
@Added resolution level to print
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.35 1997/10/31 19:20:20 butler Exp $ (BRL)";
d126 3
a128 3
	{"%d",	1, "bounces",	bu_byteoffset(max_bounces),		FUNC_NULL },
	{"%d",	1, "ireflect",	bu_byteoffset(max_ireflect),		FUNC_NULL },
	{"%f", ELEMENTS_PER_VECT, "background",bu_byteoffset(background[0]),	FUNC_NULL },
d130 1
a130 1
	{"",	0, (char *)0,	0,				FUNC_NULL }
d182 1
a182 1
	if(rdebug&RDEBUG_HITS) rt_log("rgb=%3d,%3d,%3d xy=%3d,%3d (%g,%g,%g)\n",
d205 1
a205 1
				RES_ACQUIRE( &rt_g.res_syscall );
d208 1
a208 1
				RES_RELEASE( &rt_g.res_syscall );
d219 1
a219 1
		RES_ACQUIRE( &rt_g.res_results );
d234 1
a234 1
		RES_RELEASE( &rt_g.res_results );
d246 1
a246 1
		RES_ACQUIRE( &rt_g.res_results );
d248 1
a248 1
			slp->sl_buf = rt_calloc( width, pwidth, "sl_buf scanline buffer" );
d267 1
a267 1
		RES_RELEASE( &rt_g.res_results );
d277 1
a277 1
			RES_ACQUIRE( &rt_g.res_results );
d282 1
a282 1
					slp->sl_buf = rt_calloc( width+32,
d308 1
a308 1
			RES_RELEASE( &rt_g.res_results );
d328 1
a328 1
			RES_ACQUIRE( &rt_g.res_syscall );
d336 1
a336 1
			RES_RELEASE( &rt_g.res_syscall );
d344 1
a344 1
			RES_ACQUIRE( &rt_g.res_syscall );
d347 1
a347 1
			RES_RELEASE( &rt_g.res_syscall );
d353 1
a353 1
			RES_ACQUIRE( &rt_g.res_syscall );
d358 1
a358 1
			RES_RELEASE( &rt_g.res_syscall );
d362 1
a362 1
		rt_free( scanline[ap->a_y].sl_buf, "sl_buf scanline buffer" );
d414 1
a414 1
			rt_log("mlib_setup failure on %s\n", regp->reg_name);
d418 1
a418 1
				rt_log("mlib_setup: drop region %s\n", regp->reg_name);
d456 1
a456 1
		rt_free( (char *)env_region.reg_name, "env_region.reg_name" );
d508 2
a509 2
		u.sw.sw_uv.uv_u = mat_atan2( ap->a_ray.r_dir[Y],
			ap->a_ray.r_dir[X] ) * rt_inv2pi;
d516 1
a516 1
		u.sw.sw_uv.uv_v = mat_atan2( ap->a_ray.r_dir[Z],
d519 1
a519 1
			rt_invpi + 0.5;
d526 1
a526 1
			rt_log("hit_nothing calling viewshade\n");
d559 1
a559 1
		rt_log("colorview:  no hit out front?\n");
d565 1
a565 1
		rt_log("colorview: lvl=%d coloring %s\n",
d571 1
a571 1
		rt_log("colorview:  entry beyond infinity\n");
d595 1
a595 1
				rt_log("colorview:  eye inside %s (x=%d, y=%d, lvl=%d)\n",
d678 1
a678 1
		rt_log("colorview calling viewshade\n");
d688 1
a688 1
		rt_log("colorview: lvl=%d ret a_user=%d %s\n",
d717 1
a717 1
		rt_log("viewit:  no hit out front?\n");
d729 1
a729 1
		lp = RT_LIST_FIRST( light_specific, &(LightHead.l) );
d782 1
a782 1
		rt_log("cosI0=%f, diffuse0=%f   ", cosI0, diffuse0 );
d795 1
a795 1
			rt_free( scanline[y].sl_buf, "sl_buf scanline buffer" );
d799 1
a799 1
	rt_free( (char *)scanline, "struct scanline[height]" );
d915 1
a915 1
		scanline = (struct scanline *)rt_calloc(
d936 1
a936 1
		rt_log("Single pixel I/O, unbuffered\n");
d940 1
a940 1
		scanbuf = rt_malloc( srv_scanlen*pwidth + sizeof(long),
d949 1
a949 1
			rt_log("Incremental resolution %d\n", j);
d964 1
a964 1
		rt_log("Dynamic scanline buffering\n");
d1002 1
a1002 1
			scanline[yy].sl_buf = rt_calloc( width,
d1006 1
a1006 1
		    		rt_log("fseek error\n");
d1011 1
a1011 1
		    		rt_log("Unable to fread fractional scanline, wanted %d, got %d pixels\n", xx, got);
d1031 3
a1033 3
		if( RT_LIST_IS_EMPTY( &(LightHead.l) )  ||
		    RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
			if(rdebug&RDEBUG_SHOWERR)rt_log("No explicit light\n");
@


11.35
log
@added grass shader to complilation
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.34 1997/08/28 23:47:39 mike Exp butler $ (BRL)";
a944 1
		rt_log("Incremental resolution\n");
d948 2
@


11.34
log
@Changed use of a_onehit to require at least one NON-AIR hit.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.33 1997/07/22 23:19:51 butler Exp mike $ (BRL)";
d840 1
d864 1
@


11.33
log
@fixed nested semaphore problem
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.32 1997/07/16 14:14:08 gdurf Exp butler $ (BRL)";
d901 1
a901 4
	if (use_air)
		ap->a_onehit = 3;
	else
		ap->a_onehit = 1;
@


11.32
log
@No changes
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.31 1997/05/19 17:13:32 butler Exp gdurf $ (BRL)";
d355 1
a355 1
				rt_log("fseek error\n");
@


11.31
log
@consolidated noise shaders, added prj shader
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.30 1997/01/07 23:44:35 mike Exp butler $ (BRL)";
d830 1
a830 1
		extern struct mfuncs camo_mfuncs[];
@


11.30
log
@Changed to bu_byteoffset()
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.29 1997/01/07 22:57:13 butler Exp mike $ (BRL)";
a829 1
		extern struct mfuncs Nfbm_mfuncs[];
d838 2
a852 1
		mlib_add( Nfbm_mfuncs );
d861 2
d1027 4
a1030 1
		/* If present, use user-specified light solids */
@


11.29
log
@We all agreed that we liked the "darken the view beyond the solid" for an
effect when the eye/ray starts out inside the solid.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.28 1996/11/04 21:20:02 pjt Exp butler $ (BRL)";
a122 15
#if CRAY
#	define byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if IRIX > 5
#	define byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define byteoffset(_i)	((int)((char *)&(_i)))
#    else
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#    endif
#  endif
#endif
d126 3
a128 3
	{"%d",	1, "bounces",	byteoffset(max_bounces),		FUNC_NULL },
	{"%d",	1, "ireflect",	byteoffset(max_ireflect),		FUNC_NULL },
	{"%f", ELEMENTS_PER_VECT, "background",byteoffset(background[0]),	FUNC_NULL },
@


11.28
log
@Extended -d option to all buffer modes
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.27 1996/11/01 20:43:34 pjt Exp pjt $ (BRL)";
d627 5
a631 4
#if 0
	/* XXX This is taken out because we tend to have air and 
	 * vapor "solids" these days which typically fill space
	 */
a632 3
#else
		VMOVE( ap->a_color, sub_ap.a_color);
#endif
@


11.27
log
@1. -d works in unbuffered mode
2. -d disabled when writing to a frame buffer
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.26 1996/10/31 20:27:46 pjt Exp $ (BRL)";
d121 2
a160 1
	register int	pwidth;		/* Width of each pixel (in bytes) */
a163 2
	{
	    pwidth = 3+8;
a164 3
	}
	else
	    pwidth = 3;
d232 1
a232 1
		pixelp = scanbuf+ 3 * 
d238 11
d263 1
a263 1
			slp->sl_buf = rt_calloc( width, 3, "sl_buf scanline buffer" );
d265 1
a265 1
		pixelp = slp->sl_buf+(ap->a_x*3);
d269 11
d298 1
a298 1
						3, "sl_buf scanline buffer" );
d300 1
a300 1
				pixelp = slp->sl_buf+(ap->a_x*3);
d305 11
d369 1
a369 1
			if( fseek( outfp, ap->a_y*width*3L, 0 ) != 0 )
d372 1
a372 1
				sizeof(char), width*3, outfp );
d374 1
a374 1
			if( count != width*3 )
d920 4
d956 1
a956 1
		scanbuf = rt_malloc( srv_scanlen*3 + sizeof(long),
@


11.26
log
@Replaced the single assignment to ap->a_dist
with multiples (one per case) to avoid cache misses
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.25 1996/10/31 14:01:23 pjt Exp $ (BRL)";
d162 7
a168 2
	pwidth = rpt_dist ? 3+8 : 3;
	htond(dist, (double) ap->a_dist, 1);
d218 2
a219 1
				if( fwrite( dist, 8, 1, outfp ) != 1 )
d854 8
a861 2
	}  else  {
		return(1);		/* open a framebuffer */
@


11.25
log
@When in unbuffered mode, rt should now be able to produce
pixd output (provide, of course, that the user interface
were prepared to allow the user to request it!)
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.24 1996/09/17 04:37:31 butler Exp $ (BRL)";
a549 1
	ap->a_dist = hitp->hit_dist;
d554 1
d582 1
d602 1
d667 1
@


11.24
log
@added "paint" shader
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.23 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d159 2
d162 3
d213 2
d550 1
@


11.23
log
@structparse moved to libbu
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.22 1996/07/22 20:34:18 jra Exp butler $ (BRL)";
d809 1
d831 1
@


11.22
log
@Minor Mods for IRIX 6.2
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.21 1996/07/12 14:55:42 jra Exp jra $ (BRL)";
d137 1
a137 1
struct structparse view_parse[] = {
@


11.21
log
@Minor mod for IRIX 6.2
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.20 1996/06/25 20:43:35 butler Exp jra $ (BRL)";
d121 15
d138 5
a142 3
	{"%d",	1, "bounces",	(long)&max_bounces,		FUNC_NULL },
	{"%d",	1, "ireflect",	(long)&max_ireflect,		FUNC_NULL },
	{"%f", ELEMENTS_PER_VECT, "background",(long)background,	FUNC_NULL },
@


11.20
log
@added gauss shader
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.19 1996/06/24 21:03:41 butler Exp butler $ (BRL)";
d108 2
d742 1
a742 1

@


11.19
log
@added passing of finished_segs to shaders
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/view.c,v 11.18 1996/06/24 20:53:36 jra Exp butler $ (BRL)";
d789 1
d810 1
@


11.18
log
@Added simple brdf shader.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.17 1996/05/09 10:43:50 butler Exp jra $ (BRL)";
d501 1
a501 1
colorview( ap, PartHeadp )
d504 1
d565 3
d626 1
@


11.17
log
@comments
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.16 1996/05/07 19:25:35 jra Exp butler $ (BRL)";
d783 1
d803 1
@


11.16
log
@Colorview() no longer calls rr_render().
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.15 1996/03/29 23:20:55 mike Exp jra $ (BRL)";
d530 8
a537 3
	/* Check to see if eye is "inside" the solid */
	/* It might only be worthwhile doing all this in perspective mode */
	/* XXX Note that hit_dist can be faintly negative, e.g. -1e-13 */
d563 1
d565 4
@


11.15
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.14 1996/03/29 21:55:48 mike Exp mike $ (BRL)";
d618 1
a619 4

	/* As a special case for now, handle reflection & refraction */
	if( sw.sw_reflect > 0 || sw.sw_transmit > 0 )
		(void)rr_render( ap, pp, &sw );
@


11.14
log
@Changed to use new curvature macro.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.13 1996/03/28 19:27:22 jra Exp mike $ (BRL)";
d661 1
a661 1
	RT_HIT_NORM( hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );
a665 5
	if( pp->pt_inflip )  {
		VREVERSE( normal, hitp->hit_normal );
	} else {
		VMOVE( normal, hitp->hit_normal );
	}
@


11.13
log
@Eliminated srand48 from sh_rtrans and put sh_rtrans back in.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.12 1996/03/28 04:33:49 butler Exp jra $ (BRL)";
d652 1
d667 3
a669 1
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
d676 1
a676 1
		if( (cosI0 = -VDOT(hitp->hit_normal, ap->a_ray.r_dir)) >= 0.0 )
d687 3
a689 3
		ap->a_color[0] = (hitp->hit_normal[0] * (-.5)) + .5;
		ap->a_color[1] = (hitp->hit_normal[1] * (-.5)) + .5;
		ap->a_color[2] = (hitp->hit_normal[2] * (-.5)) + .5;
d696 1
a696 1
			RT_CURVE( &cv, hitp, pp->pt_inseg->seg_stp );
d716 1
a716 1
			RT_CURVE( &cv, hitp, pp->pt_inseg->seg_stp );
@


11.12
log
@removed sh_rtrans from compilation for BSD/OS since srand48 is tainted code
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/view.c,v 11.11 1995/12/06 17:36:18 pjt Exp butler $ (BRL)";
a775 2
#ifndef __bsdi__
		/* John:  srand48 is not portable */
a776 1
#endif
a794 1
#ifndef __bsdi__
a795 1
#endif
@


11.11
log
@Implemented -r and -R options to control reporting of overlaps.
This required a trivial application_init()
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.10 1995/11/07 21:02:51 adam Exp $ (BRL)";
d776 2
d779 1
d798 1
d800 1
@


11.10
log
@Matching malloc and free messages -- sl_buf scanline buffer
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.9 1995/10/20 04:50:56 butler Exp adam $ (BRL)";
d79 2
d425 1
a425 1
hit_nothing( ap, PartHeadp )
a817 1
	extern int hit_nothing();
d825 4
d992 11
@


11.9
log
@added fire
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.8 1995/08/24 14:56:52 jra Exp butler $ (BRL)";
d222 1
a222 1
			slp->sl_buf = rt_calloc( width, 3, "sl_buf" );
d246 1
a246 1
						3, "sl_buf" );
d314 1
a314 1
		rt_free( scanline[ap->a_y].sl_buf, "scanline buf" );
d735 1
a735 1
			rt_free( scanline[y].sl_buf, "scanline buf" );
d922 2
a923 1
				sizeof(RGBpixel), "sl_buf for continuation scanline");
@


11.8
log
@Added random transparency shader.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.7 1995/08/22 02:23:51 butler Exp jra $ (BRL)";
d775 1
d794 1
@


11.7
log
@changed a_onehit to be 3 in cases where there might be air present
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.6 1995/08/19 05:08:09 butler Exp $ (BRL)";
d774 1
d792 1
@


11.6
log
@added a number of shaders
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.5 1995/06/02 23:34:05 mike Exp butler $ (BRL)";
d530 3
a532 2
#if 0
	if( hitp->hit_dist < 0.0 )  {
d560 1
a560 1
#endif
d820 4
a823 1
	ap->a_onehit = 1;
@


11.5
log
@mlib_setup() and the XXX->mf_setup() routines now take rtip as final arg.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.4 1995/06/02 23:30:40 butler Exp mike $ (BRL)";
d85 2
d477 3
d530 1
d559 1
a559 1

d607 2
d612 3
d769 1
a769 1
		extern struct mfuncs fbm_mfuncs[];
d771 2
d786 1
a786 1
		mlib_add( fbm_mfuncs );
d788 2
@


11.4
log
@added sh_camo shader
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.3 1995/03/03 10:43:31 mike Exp butler $ (BRL)";
d361 1
a361 1
		switch( mlib_setup( regp ) )  {
@


11.3
log
@Added -T
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.2 95/01/28 00:09:44 butler Exp Locker: mike $ (BRL)";
d758 2
d773 2
@


11.2
log
@added -N to list of flags printed in Options messsage
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 11.1 1995/01/04 10:01:21 mike Rel4_4 butler $ (BRL)";
d69 8
a76 8
 -a #		Azimuth in degrees\n\
 -e #		Elevation in degrees\n\
 -M		Read matrix, cmds on stdin\n\
 -N #		Set NMG debug flags\n\
 -o model.pix	Specify output file, .pix format (default=fb)\n\
 -x #		Set librt debug flags\n\
 -X #		Set rt debug flags\n\
 -p #		Perspective viewing, in degrees side to side\n\
d78 1
@


11.1
log
@Release_4.4
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.14 95/01/04 08:13:09 mike Exp $ (BRL)";
d72 1
@


10.14
log
@Cray C90
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.13 95/01/03 21:51:38 mike Exp Locker: mike $ (BRL)";
@


10.13
log
@Fixed fractional scanline message.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.12 94/11/09 15:14:02 jra Exp Locker: mike $ (BRL)";
d632 2
a633 1
	LOCAL fastf_t diffuse0, cosI0;
@


10.12
log
@Fixed -i option.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.11 94/11/05 03:28:17 mike Exp Locker: jra $ (BRL)";
d876 1
d895 5
a899 3
			if( fread( scanline[yy].sl_buf, sizeof(RGBpixel),
			    width, outfp ) != width )
		    		rt_log("fread error\n");
@


10.11
log
@Irix 6 hack.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.10 94/11/05 02:46:54 mike Exp Locker: mike $ (BRL)";
a285 5
			for( dy=spread; dy >= 0; dy-- )  {
				yy = ap->a_y + dy;
				rt_free( scanline[yy].sl_buf, "scanline buf" );
				scanline[yy].sl_buf = (char *)0;
			}
a333 5

	if( incr_mode )  {
		if( incr_level < incr_nlevel )
			return(0);		 /* more res to come */
	}
d799 10
a808 5
	/* Always allocate the scanline[] array */
	if( scanline )  free_scanlines();
	scanline = (struct scanline *)rt_calloc(
		height, sizeof(struct scanline),
		"struct scanline[height]" );
d848 1
a848 2
		if( incr_level > 0 )  {
			if( incr_level < incr_nlevel )
a849 1
		}
@


10.10
log
@Irix 6, unused vars
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.9 94/10/31 22:22:43 mike Exp Locker: mike $ (BRL)";
d115 3
a117 3
	{"%d",	1, "bounces",	(int)&max_bounces,		FUNC_NULL },
	{"%d",	1, "ireflect",	(int)&max_ireflect,		FUNC_NULL },
	{"%f", ELEMENTS_PER_VECT, "background",(int)background,	FUNC_NULL },
@


10.9
log
@Added Bill Laut's wood shader.  See bug #156
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.8 94/10/29 03:23:57 mike Exp Locker: mike $ (BRL)";
a111 1
static int	pixel_width = 3;	/* # bytes/pixel */
a507 1
	register struct mfuncs *mfp;
a641 2
	LOCAL fastf_t diffuse2, cosI2;
	LOCAL fastf_t diffuse1, cosI1;
a684 1
			auto int ival;
a704 2
			FAST fastf_t f;
			auto int ival;
@


10.8
log
@Vain debug attempt on -i flag, which is still busted.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.7 94/10/29 02:47:11 mike Exp Locker: mike $ (BRL)";
d771 1
d784 1
@


10.7
log
@Spread was not being calculated correctly.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.6 94/08/11 01:43:25 gdurf Exp Locker: mike $ (BRL)";
d239 1
d242 1
a242 1
					slp->sl_buf = rt_calloc( width,
@


10.6
log
@Factored ifdefs
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.5 1993/09/25 06:32:31 cjohnson Exp gdurf $ (BRL)";
d275 1
a275 1
			spread = 1<<(incr_nlevel-incr_level)-1;
@


10.5
log
@Change over to unsigned char from RGBpixels
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.4 1993/07/21 22:14:38 mike Exp cjohnson $ (BRL)";
d38 1
a38 1
#include "machine.h"	/* comes before looking at __unix */
d43 1
a43 1
#if defined(unix) || defined(__unix)
d48 2
d804 1
a804 1
#if defined(unix) || defined(__unix)
d868 1
a868 1
#if defined(unix) || defined(__unix)
@


10.4
log
@Added casts for fb_write()
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.3 93/07/20 15:44:14 mike Exp Locker: mike $ (BRL)";
d187 1
a187 1
					(RGBpixel *)p, 1 );
d278 1
a278 1
					(RGBpixel *)scanline[yy].sl_buf,
d297 1
a297 1
			    (RGBpixel *)scanline[ap->a_y].sl_buf, width );
@


10.3
log
@comment in comment
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.2 92/07/21 17:04:55 mm Exp Locker: mike $ (BRL)";
d187 1
a187 1
					(char *)p, 1 );
d278 1
a278 1
					scanline[yy].sl_buf,
d297 1
a297 1
			    scanline[ap->a_y].sl_buf, width );
@


10.2
log
@Added sh_toyota.c
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 10.1 91/10/12 06:42:15 mike Rel4_0 Locker: mm $ (BRL)";
d86 3
a88 1
/*vect_t	background = { 0.25, 0, 0.5 };	/* Dark Blue Background */
d90 1
@


10.1
log
@Release_4.0
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.20 91/08/30 02:47:58 mike Exp $ (BRL)";
d764 1
d776 1
@


9.20
log
@must include machine.h before looking at __unix symbol
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.19 91/07/06 00:38:56 mike Exp $ (BRL)";
@


9.19
log
@unix --> __unix in ANSI
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.18 91/07/06 00:35:25 mike Exp $ (BRL)";
d38 2
a47 1
#include "machine.h"
@


9.18
log
@ANSI structure initialization
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.17 91/06/29 23:02:10 mike Exp $ (BRL)";
d41 1
a41 1
#ifdef unix
d796 1
a796 1
#ifdef unix
d860 1
a860 1
#ifdef unix
@


9.17
log
@ANSI lint
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.16 91/03/13 21:15:41 mike Exp $ (BRL)";
d110 4
a113 4
	"%d",	1, "bounces",	(int)&max_bounces,		FUNC_NULL,
	"%d",	1, "ireflect",	(int)&max_ireflect,		FUNC_NULL,
	"%f", ELEMENTS_PER_VECT, "background",(int)background,	FUNC_NULL,
	"",	0, (char *)0,	0,				FUNC_NULL
@


9.16
log
@Changed default background color to 0/0/1.
Note that this makes any pixel that would otherwise have been
colored 0/0/1 become 0/0/2.
Avoid 0/0/0 to prevent wasting time in checkpoint/restart operations,
which recompute any pixel with value 0/0/0 (empty file region).
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.15 91/03/11 23:08:37 mike Exp $ (BRL)";
d408 1
a408 1
		rt_free( env_region.reg_name, "env_region.reg_name" );
@


9.15
log
@Deferr dealing with width & height until view_2init.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.14 91/02/20 01:16:16 mike Exp $ (BRL)";
d85 2
a86 1
vect_t	background = { 0.25, 0, 0.5 };	/* Dark Blue Background */
@


9.14
log
@Changed handling of env_region to be sensitive to the fact that
reg_name, reg_treetop, etc, pointers will go away,
and thus need to be explicitly duplicated if needed.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.13 91/02/20 00:51:29 mike Exp $ (BRL)";
d733 2
d740 1
a740 1
 *  Called once, early on in RT setup.
a746 43
	/* Always allocate the scanline[] array */
	if( ! scanline )  {
		scanline = (struct scanline *)rt_calloc(
			height, sizeof(struct scanline),
			"struct scanline[height]" );
	} else {
		free_scanlines();
	}

#ifdef RTSRV
	buf_mode = BUFMODE_RTSRV;		/* multi-pixel buffering */
#else
	if( incr_mode )  {
		buf_mode = BUFMODE_INCR;
	} else if( rt_g.rtg_parallel )  {
		buf_mode = BUFMODE_DYNAMIC;
	} else if( width <= 96 )  {
		buf_mode = BUFMODE_UNBUF;
	}  else  {
		buf_mode = BUFMODE_DYNAMIC;
	}
#endif

	switch( buf_mode )  {
	case BUFMODE_UNBUF:
		rt_log("Single pixel I/O, unbuffered\n");
		break;	
	case BUFMODE_DYNAMIC:
		rt_log("Dynamic scanline buffering\n");
		break;
	case BUFMODE_INCR:
		rt_log("Incremental resolution\n");
		break;
#ifdef RTSRV
	case BUFMODE_RTSRV:
		scanbuf = rt_malloc( srv_scanlen*3 + sizeof(long),
			"scanbuf [multi-line]" );
		break;
#endif
	default:
		rt_bomb("bad buf_mode");
	}

d804 20
d825 9
d835 1
d855 1
d908 1
a908 1
		break;
@


9.13
log
@Added new view-module interface called view_setup() which is used
for initializing material properties, lights, etc.
It compliments view_cleanup(), and finally removed knowledge of
the view.c materials (and all the shaders) from the RT "top half".
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.12 91/02/19 19:51:09 mike Exp $ (BRL)";
d407 2
d436 1
a436 1
	if( env_region.reg_mfuncs  /* && ap->a_level > 0 */ )  {
d448 1
a448 1
		u.hit.hit_dist = 0.0;	/* XXX should be = 1 model diameter */
@


9.12
log
@Added error checking.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.11 91/01/05 03:09:20 mike Exp $ (BRL)";
a58 1
int		using_mlib = 1;		/* Material routines used */
d342 50
d394 1
a394 1
 *  Called after rt_clean() in do.c
d397 2
a398 1
view_cleanup()
d400 10
@


9.11
log
@Converted to new format for fmt entry in structparse
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.10 91/01/04 00:41:29 mike Exp $ (BRL)";
d301 2
a302 1
			fseek( outfp, ap->a_y*width*3L, 0 );
d842 5
a846 3
			fseek( outfp, yy*width*3L, 0 );
			fread( scanline[yy].sl_buf, sizeof(RGBpixel),
				width, outfp );
@


9.10
log
@Fixed Cray warning about possibly using npix variable before
assigning a value.
It "couldn't happen", but it seemed wise to silence the warning.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.9 90/12/19 06:38:43 mike Exp $ (BRL)";
d113 1
a113 1
	(char *)0, 0, (char *)0,	0,			FUNC_NULL
@


9.9
log
@If fb_write() fails, call rt_bomb().
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.8 90/12/12 16:35:13 butler Exp $ (BRL)";
a128 1
	int		npix;
d170 1
d267 1
d290 1
@


9.8
log
@modified to reflect changes in structparse format
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.7 90/11/14 15:43:35 mike Exp $ (BRL)";
d129 1
d182 2
a183 1
				fb_write( fbp, ap->a_x, ap->a_y, (char *)p, 1 );
d185 1
d272 1
a272 1
				fb_write( fbp, 0, yy,
d275 1
d278 1
d290 1
a290 1
			fb_write( fbp, 0, ap->a_y,
d293 1
@


9.7
log
@As part of "clean" command, call "view_cleanup()", to allow
viewing module the opportunity to clean up things like implicit
light sources, etc.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.6 90/11/10 19:36:33 mike Exp $ (BRL)";
d110 4
a113 4
	"%d",	"bounces",	(int)&max_bounces,		FUNC_NULL,
	"%d",	"ireflect",	(int)&max_ireflect,		FUNC_NULL,
	"%V",	"background",	(int)background,		FUNC_NULL,
	(char *)0,(char *)0,	0,				FUNC_NULL
@


9.6
log
@Modified light_specific structure to use rtlist.h macros.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.5 90/06/06 20:34:02 mike Exp $ (BRL)";
d330 11
a341 1
	return(0);		/* OK */
@


9.5
log
@lint
@
text
@d10 1
a10 1
 *	0	model with color, based on Moss's LGT
d13 1
a13 1
 *	3	3-light debugging model
d35 1
a35 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/view.c,v 9.4 90/02/08 02:23:12 mike Exp $ (BRL)";
d49 1
a83 1
extern struct light_specific *LightHeadp;
a323 1
	register struct light_specific *lp, *nlp;
d330 1
a330 13

	/* Eliminate invisible lights (typ. implicit lights) */
	lp=LightHeadp;
	while( lp != LIGHT_NULL )  {
		if( lp->lt_invisible )  {
			nlp = lp->lt_forw;
			light_free( (char *)lp );
			lp = nlp;
			continue;
		}
		/* will be cleaned by mlib_free() */
		lp = lp->lt_forw;
	}
d559 1
d579 1
d583 1
a583 1
		VSCALE( work0, LightHeadp->lt_color, diffuse0 );
a588 28
	case 3:
		/* Simple attempt at a 3-light model. */
		{
			struct light_specific *l0, *l1, *l2;
			l0 = LightHeadp;
			l1 = l0->lt_forw;
			l2 = l1->lt_forw;

			diffuse0 = 0;
			if( (cosI0 = VDOT(hitp->hit_normal, l0->lt_vec)) >= 0.0 )
				diffuse0 = cosI0 * l0->lt_fraction;
			diffuse1 = 0;
			if( (cosI1 = VDOT(hitp->hit_normal, l1->lt_vec)) >= 0.0 )
				diffuse1 = cosI1 * l1->lt_fraction;
			diffuse2 = 0;
			if( (cosI2 = VDOT(hitp->hit_normal, l2->lt_vec)) >= 0.0 )
				diffuse2 = cosI2 * l2->lt_fraction;

			VSCALE( work0, l0->lt_color, diffuse0 );
			VSCALE( work1, l1->lt_color, diffuse1 );
			VADD2( work0, work0, work1 );
			VSCALE( work1, l2->lt_color, diffuse2 );
			VADD2( work0, work0, work1 );
		}
		/* Add in contribution from ambient light */
		VSCALE( work1, ambient_color, AmbientIntensity );
		VADD2( ap->a_color, work0, work1 );
		break;
d841 3
a843 2
		/* If present, use user-specified light solid */
		if( LightHeadp == LIGHT_NULL )  {
a851 1
	case 3:
d870 1
a870 1
	 * Peterb the background color channel with the largest intensity.
@


9.4
log
@Checkpoint-restart feature moved from do.c into view.c
Also implemented dynamic scanline buffering for nearly all
pixel output.
This avoids having to allocate a buffer large enough to hold
the entire image when running in parallel mode.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 9.3 90/02/03 23:56:26 mike Locked $ (BRL)";
d687 1
a687 1
			rt_free( scanline[y].sl_buf );
@


9.3
log
@Eliminated support for -O hex_out facility.
@
text
@d29 1
a29 1
 *  
d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 9.2 89/10/10 16:02:58 mike Locked $ (BRL)";
d41 5
d88 1
d92 2
a93 1
extern int	srv_scanlen;		/* buf_mode=4 buffer length */
a94 2
static int	buf_mode=0;	/* 0=pixel, 1=line, 2=frame, ... */
static int	*npix_left;	/* only used in buf_mode=2 */
d96 12
a119 10
 *
 *  The buffering strategy for output files:
 *	In serial mode, let stdio handle the buffering.
 *	In parallel mode, save whole image until the end (view_end).
 *  The buffering strategy for an "online" libfb framebuffer:
 *	buf_mode = 0	single pixel I/O
 *	buf_mode = 1	line buffering
 *	buf_mode = 2	full frame buf, dump to fb+file at end of scanline
 *	buf_mode = 3	full frame buf, dump to fb+file at end of frame
 *	buf_mode = 4	multi-line buffering for RTSRV
d125 4
a128 1
	register int r,g,b;
d135 1
d155 3
a157 21
		    	register int i;
		    	int newcolor[3];
		    	/*  Find largest color channel to perterb.
		    	 *  It should happen infrequently.
		    	 *  If you have a faster algorithm, tell me.
		    	 */
		    	if( r > g )  {
		    		if( r > b )  i = 0;
		    		else i = 2;
		    	} else {
		    		if( g > b ) i = 1;
		    		else i = 2;
		    	}
		    	newcolor[0] = r;
		    	newcolor[1] = g;
		    	newcolor[2] = b;
			if( newcolor[i] < 127 ) newcolor[i]++;
		    	else newcolor[i]--;
		    	r = newcolor[0];
		    	g = newcolor[1];
		    	b = newcolor[2];
d161 3
a163 1
	if(rdebug&RDEBUG_HITS) rt_log("rgb=%3d,%3d,%3d xy=%3d,%3d\n", r,g,b, ap->a_x, ap->a_y);
d165 3
a167 6
	/*
	 *  Handle file output in the simple cases where we let stdio
	 *  do the buffering.
	 */
	if( buf_mode <= 1 && outfp != NULL )  {
		/* Single pixel I/O or "line buffering" (to screen) case */
d169 15
a183 6
			unsigned char p[4];
			p[0] = r;
			p[1] = g;
			p[2] = b;
			if( fwrite( (char *)p, 3, 1, outfp ) != 1 )
				rt_bomb("pixel fwrite error");
d185 1
a185 1
	}
d187 13
d201 3
a203 1
	 *  Handle framebuffer output
a204 2
	if( buf_mode == 0 )  {
		/* Single Pixel I/O */
d206 5
a210 8
		if( fbp != FBIO_NULL )  {
			RGBpixel p;
			p[RED] = r;
			p[GRN] = g;
			p[BLU] = b;
			RES_ACQUIRE( &rt_g.res_syscall );
			fb_write( fbp, ap->a_x, ap->a_y, p, 1 );
			RES_RELEASE( &rt_g.res_syscall );
d212 8
a219 3
	} else {
		register char *pixelp;
		register int do_eol = 0;
d221 2
a222 20
		switch( buf_mode )  {
		case 1:
			/* Here, the buffer is only one line long */
			pixelp = scanbuf+ap->a_x*3;
			break;
		case 2:
		case 3:
			/* Buffering a full frame */
			pixelp = scanbuf+((ap->a_y*width)+ap->a_x)*3;
#ifdef RTSRV
		case 4:
			/* Multi-pixel buffer */
			pixelp = scanbuf+ 3 * 
				((ap->a_y*width) + ap->a_x - srv_startpix);
#endif
		}

		/* Don't depend on interlocked hardware byte-splice */
		RES_ACQUIRE( &rt_g.res_results );
		if( incr_mode )  {
d227 2
d230 6
a235 2
				pixelp = scanbuf+
					(((ap->a_y+dy)*width)+ap->a_x)*3;
d242 3
a244 3
			/* If incremental, first 3 iterations are boring */
			if( buf_mode == 2 && incr_level > 3 )  {
				if( --(npix_left[ap->a_y]) <= 0 )
d247 1
a247 6
		} else {
			*pixelp++ = r ;
			*pixelp++ = g ;
			*pixelp++ = b ;
			if( buf_mode == 2 && --(npix_left[ap->a_y]) <= 0 )
				do_eol = 1;
d249 1
a249 1
		RES_RELEASE( &rt_g.res_results );
d251 3
a253 7
		if( do_eol )  {
			/* buf_mode == 2 if we got here */
			if( fbp != FBIO_NULL )  {
				RES_ACQUIRE( &rt_g.res_syscall );
				if( incr_mode )  {
					register int dy, yy;
					register int spread;
a254 14
					spread = 1<<(incr_nlevel-incr_level);
					for( dy=0; dy<spread; dy++ )  {
						yy = ap->a_y + dy;
						fb_write( fbp, 0, yy,
						    scanbuf+yy*width*3, width );
					}
				} else {
					fb_write( fbp, 0, ap->a_y,
					    scanbuf+ap->a_y*width*3, width );
				}
				RES_RELEASE( &rt_g.res_syscall );
			}
			if( outfp != NULL )  {
				int	count;
d256 16
a271 7
				RES_ACQUIRE( &rt_g.res_syscall );
				fseek( outfp, ap->a_y*width*3L, 0 );
				count = fwrite( scanbuf+ap->a_y*width*3,
					sizeof(char), width*3, outfp );
				RES_RELEASE( &rt_g.res_syscall );
				if( count != width*3 )
					rt_bomb("view_pixel:  fwrite failure\n");
d273 6
d280 22
d308 2
a309 5
 *  This routine is called by main when the last pixel of a scanline
 *  has been finished.  When in parallel mode, this routine is not
 *  used;  the do_eol check in view_pixel() handles things.
 *  This routine handles framebuffer output only, all file output
 *  is done elsewhere.
d315 1
a315 16
	if( buf_mode <= 0 || fbp == FBIO_NULL )
		return;

	switch( buf_mode )  {
	case 4:
		break;
	case 3:
		break;
	case 2:
		break;
	default:
		RES_ACQUIRE( &rt_g.res_syscall );
		fb_write( fbp, 0, ap->a_y, scanbuf, width );
		RES_RELEASE( &rt_g.res_syscall );
		break;
	}
a325 17
	if( buf_mode == 3 )  {
		if( fbp != FBIO_NULL )  {
			/* Dump full screen */
			if( fb_getwidth(fbp) == width && fb_getheight(fbp) == height )  {
				fb_write( fbp, 0, 0, scanbuf, width*height );
			} else {
				register int y;
				for( y=0; y<height; y++ )
					fb_write( fbp, 0, y, scanbuf+y*width*3, width );
			}
		}
		if( (outfp != NULL) &&
		    fwrite( scanbuf, sizeof(char), width*height*3, outfp ) != width*height*3 )  {
			fprintf(stderr,"view_end:  fwrite failure\n");
			return(-1);		/* BAD */
		}
	}
d330 1
d681 12
d703 9
d713 1
a713 1
	buf_mode = 4;			/* multi-pixel buffering */
a714 1
	/* buf_mode = 3 presently can't be set, but still is supported */
d716 1
a716 1
		buf_mode = 2;		/* Frame buffering, write each line */
d718 1
a718 1
		buf_mode = 2;		/* frame buffering, write each line */
d720 1
a720 1
		buf_mode = 0;		/* single-pixel I/O */
d722 1
a722 1
		buf_mode = 1;		/* line buffering */
d727 1
a727 2
	case 0:
		scanbuf = (char *)0;
d730 2
a731 4
	case 1:
		scanbuf = rt_malloc( width*3 + sizeof(long),
			"scanbuf [line]" );
		rt_log("Buffering single scanlines\n");
d733 2
a734 6
	case 2:
		scanbuf = rt_malloc( width*height*3 + sizeof(long),
			"scanbuf [frame]" );
		npix_left = (int *)rt_malloc( height*sizeof(int),
			"npix_left[]" );
		rt_log("Buffering full frames, fb write at end of line\n");
a735 5
	case 3:
		scanbuf = rt_malloc( width*height*3 + sizeof(long),
			"scanbuf [frame]" );
		rt_log("Buffering full frames, fb write at end of frame\n");
		break;
d737 1
a737 1
	case 4:
d788 1
a788 1
view_2init( ap )
d790 1
d794 3
d804 2
a805 2
	case 2:
		if( incr_mode )  {
d812 1
a812 1
					npix_left[i*w] = j/2;
d814 1
a814 1
					npix_left[i*w] = j;
a815 3
		} else {
			for( i=0; i<height; i++ )
				npix_left[i] = width;
d817 5
d823 17
a839 2
		/* If not starting with pixel offset > 0,
		 * read in existing pixels first
d841 5
a845 5
		if( outfp != NULL && pix_start > 0 )  {
			/* We depend on file being r+w in this case */
			rewind( outfp );
			if( fread( scanbuf, 3, pix_start, outfp ) != pix_start )
				rt_log("view_2init:  bad initial fread\n");
d847 19
d867 3
a869 4
			i = pix_start/width;
			npix_left[i] -= pix_start%width;
			for( i--; i >= 0; i-- )
				npix_left[i] = 0;
d871 1
a875 4
	if( incr_mode && incr_level > 0 )  {
		if( incr_level < incr_nlevel )
			return;		 /* more res to come */
	}
d901 20
a920 3
	ibackground[0] = background[0] * 255;
	ibackground[1] = background[1] * 255;
	ibackground[2] = background[2] * 255;
@


9.2
log
@Added option to only plot missed rays.
Added conservative code to zero out automatic structures.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 9.1 89/05/19 05:59:49 mike Rel3_5 $ (BRL)";
d176 1
a176 3
		if( hex_out )  {
			fprintf(outfp, "%2.2x%2.2x%2.2x\n", r, g, b);
		} else {
@


9.1
log
@Release_3.5
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.17 89/05/19 03:19:57 mike Exp $ (BRL)";
d376 1
a376 1
	if( rdebug&RDEBUG_RAYPLOT )  {
d379 1
d387 5
a391 3
		struct partition part;
		struct hit	hit;
		struct shadework sw;
d393 1
d396 3
a398 3
		part.pt_inhit = part.pt_outhit = &hit;
		part.pt_regionp = &env_region;
		hit.hit_dist = 0.0;	/* XXX should be = 1 model diameter */
d400 4
a403 4
		sw.sw_transmit = sw.sw_reflect = 0.0;
		sw.sw_refrac_index = 1.0;
		sw.sw_extinction = 0;
		sw.sw_xmitonly = 1;		/* don't shade env map! */
d406 2
a407 2
		sw.sw_inputs = MFI_NORMAL|MFI_UV;
		VREVERSE( sw.sw_hit.hit_normal, ap->a_ray.r_dir );
d409 1
a409 1
		sw.sw_uv.uv_u = mat_atan2( ap->a_ray.r_dir[Y],
d411 2
a412 2
		if( sw.sw_uv.uv_u < 0 )
			sw.sw_uv.uv_u += 1.0;
d417 1
a417 1
		sw.sw_uv.uv_v = mat_atan2( ap->a_ray.r_dir[Z],
d421 1
a421 1
		sw.sw_uv.uv_du = sw.sw_uv.uv_dv = 0;
d423 2
a424 2
		VSETALL( sw.sw_color, 1 );
		VSETALL( sw.sw_basecolor, 1 );
d426 1
a426 1
		(void)viewshade( ap, &part, &sw );
d428 1
a428 1
		VMOVE( ap->a_color, sw.sw_color );
d518 3
a520 2
		/* There are two parts to plot here.
		 *  Ray start to in hit, and inhit to outhit.
@


8.17
log
@Moved viewshade() and shade_inputs() to shade.c
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.16 89/05/19 03:08:59 mike Locked $ (BRL)";
@


8.16
log
@Further incorporated ext.h by removing unnecessary external declarations.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.15 89/04/30 21:26:13 mike Locked $ (BRL)";
a77 1
extern int light_hit(), light_miss();	/* in light.c */
a90 2
void	shade_inputs();

a567 271
}

/*
 *			V I E W S H A D E
 *
 *  Call the material-specific shading function, after making certain
 *  that all shadework fields desired have been provided.
 *
 *  Returns -
 *	0 on failure
 *	1 on success
 */
int
viewshade( ap, pp, swp )
struct application *ap;
register struct partition *pp;
register struct shadework *swp;
{
	register struct mfuncs *mfp;
	register struct region *rp;
	register struct light_specific *lp;
	register int	want;

	swp->sw_hit = *(pp->pt_inhit);		/* struct copy */

	if( (mfp = (struct mfuncs *)pp->pt_regionp->reg_mfuncs) == MF_NULL )  {
		rt_log("viewshade:  reg_mfuncs NULL\n");
		return(0);
	}
	if( mfp->mf_magic != MF_MAGIC )  {
		rt_log("viewshade:  reg_mfuncs bad magic, %x != %x\n",
			mfp->mf_magic, MF_MAGIC );
		return(0);
	}
	if( (rp=pp->pt_regionp) == REGION_NULL )  {
		rt_log("viewshade: bad region pointer\n");
		return(0);
	}

	/* Default color is white (uncolored) */
	if( rp->reg_mater.ma_override )  {
		VMOVE( swp->sw_color, rp->reg_mater.ma_color );
	}
	VMOVE( swp->sw_basecolor, swp->sw_color );

	if( swp->sw_hit.hit_dist < 0.0 )
		swp->sw_hit.hit_dist = 0.0;	/* Eye inside solid */
	ap->a_cumlen += swp->sw_hit.hit_dist;

	want = mfp->mf_inputs;

	/* If light information is not needed, set the light
	 * array to "safe" values,
	 * and claim that the light is visible, in case they are used.
	 */
	if( swp->sw_xmitonly )  want &= ~MFI_LIGHT;
	if( !(want & MFI_LIGHT) )  {
		register int	i;

		for( i = ap->a_rt_i->rti_nlights*3 - 1; i >= 0; i-- )
			swp->sw_intensity[i] = 1;

		for( i=0, lp=LightHeadp; lp; lp = lp->lt_forw, i++ )
			swp->sw_visible[i] = (char *)lp;
	}

	/* If optional inputs are required, have them computed */
	if( want & (MFI_HIT|MFI_NORMAL|MFI_LIGHT|MFI_UV) )  {
		VJOIN1( swp->sw_hit.hit_point, ap->a_ray.r_pt,
			swp->sw_hit.hit_dist, ap->a_ray.r_dir );
		swp->sw_inputs |= MFI_HIT;
	}
	if( (swp->sw_inputs & want) != want )
		shade_inputs( ap, pp, swp, want );

	if( rdebug&RDEBUG_SHADE ) {
		pr_shadework( "before mf_render", swp );
	}

	/* Invoke the actual shader (may be a tree of them) */
	(void)mfp->mf_render( ap, pp, swp, rp->reg_udata );

	return(1);
}

/*
 *			S H A D E _ I N P U T S
 *
 *  Compute the necessary fields in the shadework structure.
 *
 *  Note that only hit_dist is valid in pp_inhit.
 *  RT_HIT_NORM() must be called if hit_norm is needed,
 *  after which pt_inflip must be handled.
 *  ft_uv() routines must have hit_point computed
 *  in advance.
 *
 *  If MFI_LIGHT is not on, the presumption is that the sw_visible[]
 *  array is not needed, or has been handled elsewhere.
 */
void
shade_inputs( ap, pp, swp, want )
struct application *ap;
register struct partition *pp;
register struct shadework *swp;
register int	want;
{
	register struct light_specific *lp;
	register int	have;

	/* These calcuations all have MFI_HIT as a pre-requisite */
	if( want & (MFI_NORMAL|MFI_LIGHT|MFI_UV) )
		want |= MFI_HIT;

	have = swp->sw_inputs;
	want &= ~have;		/* we don't want what we already have */

	if( want & MFI_HIT )  {
		VJOIN1( swp->sw_hit.hit_point, ap->a_ray.r_pt,
			swp->sw_hit.hit_dist, ap->a_ray.r_dir );
		have |= MFI_HIT;
	}

	if( want & MFI_NORMAL )  {
		if( pp->pt_inhit->hit_dist < 0.0 )  {
			/* Eye inside solid, orthoview */
			VREVERSE( swp->sw_hit.hit_normal, ap->a_ray.r_dir );
		} else {
			FAST fastf_t f;
			/* Get surface normal for hit point */
			/* Stupid SysV CPP needs this on one line */
			RT_HIT_NORM( &(swp->sw_hit), pp->pt_inseg->seg_stp, &(ap->a_ray) );

#ifdef never
			if( swp->sw_hit.hit_normal[X] < -1.01 || swp->sw_hit.hit_normal[X] > 1.01 ||
			    swp->sw_hit.hit_normal[Y] < -1.01 || swp->sw_hit.hit_normal[Y] > 1.01 ||
			    swp->sw_hit.hit_normal[Z] < -1.01 || swp->sw_hit.hit_normal[Z] > 1.01 )  {
			    	VPRINT("shade_inputs: N", swp->sw_hit.hit_normal);
				VSET( swp->sw_color, 9, 9, 0 );	/* Yellow */
				return;
			}
#endif
			if( pp->pt_inflip )  {
				VREVERSE( swp->sw_hit.hit_normal, swp->sw_hit.hit_normal );
				pp->pt_inflip = 0;	/* shouldnt be needed now??? */
			}

			/* Temporary check to make sure normals are OK */
			if( (f=VDOT( ap->a_ray.r_dir, swp->sw_hit.hit_normal )) > 0 )  {
				rt_log("shade_inputs: flipped normal %d %d %s dot=%g\n",
					ap->a_x, ap->a_y,
					pp->pt_inseg->seg_stp->st_name, f);
				VPRINT("Dir ", ap->a_ray.r_dir);
				VPRINT("Norm", swp->sw_hit.hit_normal);
			}
		}
		have |= MFI_NORMAL;
	}
	if( want & MFI_UV )  {
		if( pp->pt_inhit->hit_dist < 0.0 )  {
			/* Eye inside solid, orthoview */
			swp->sw_uv.uv_u = swp->sw_uv.uv_v = 0.5;
			swp->sw_uv.uv_du = swp->sw_uv.uv_dv = 0;
		} else {
			rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
				ap, pp->pt_inseg->seg_stp,
				&(swp->sw_hit), &(swp->sw_uv) );
		}
		if( swp->sw_uv.uv_u < 0 || swp->sw_uv.uv_u > 1 ||
		    swp->sw_uv.uv_v < 0 || swp->sw_uv.uv_v > 1 )  {
			rt_log("shade_inputs:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
				swp->sw_uv.uv_u, swp->sw_uv.uv_v,
				swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
				pp->pt_inseg->seg_stp->st_name );
			VSET( swp->sw_color, 0, 9, 0 );	/* Green */
			return;
		}
		have |= MFI_UV;
	}
	if( want & MFI_LIGHT )  {
		register int	i;
		register fastf_t *intensity, *tolight;
		register fastf_t f;
		struct application sub_ap;

		/*
		 *  Determine light visibility
		 */
		for( i=0, lp=LightHeadp, intensity = swp->sw_intensity, tolight = swp->sw_tolight;
			lp;
			lp = lp->lt_forw, i++, intensity += 3, tolight += 3
		)  {
			/* compute the light direction */
			if( lp->lt_infinite ) {
				/* XXX infinte lights need penumbras? */
				VMOVE( tolight, lp->lt_vec );
			} else {
				/*
				 *  Dither light pos for penumbra by +/- 0.5 light radius;
				 *  this presently makes a cubical light source distribution.
				 */
				f = lp->lt_radius * 0.9;
				tolight[X] = lp->lt_pos[X] +
					rand_half(ap->a_resource->re_randptr)*f -
					swp->sw_hit.hit_point[X];
				tolight[Y] = lp->lt_pos[Y] +
					rand_half(ap->a_resource->re_randptr)*f -
					swp->sw_hit.hit_point[Y];
				tolight[Z] = lp->lt_pos[Z] +
					rand_half(ap->a_resource->re_randptr)*f -
					swp->sw_hit.hit_point[Z];
			}

			/*
			 *  If we have a normal, test against light direction
			 */
			if( (have & MFI_NORMAL) && (swp->sw_transmit == 0) )  {
				if( VDOT(swp->sw_hit.hit_normal,tolight) < 0 ) {
					/* backfacing, opaque */
					swp->sw_visible[i] = (char *)0;
					continue;
				}
			}
			VUNITIZE( tolight );

			/*
			 * See if ray from hit point to light lies within light beam
			 * Note: this is should always be true for infinite lights!
			 */
			if( -VDOT(tolight, lp->lt_aim) < lp->lt_cosangle )  {
				/* dark (outside of light beam) */
				swp->sw_visible[i] = (char *)0;
				continue;
			}
			if( !(lp->lt_shadows) )  {
				/* "fill light" in beam, don't care about shadows */
				swp->sw_visible[i] = (char *)lp;
				VSETALL( intensity, 1 );
				continue;
			}

			/*
			 *  Fire ray at light source to check for shadowing.
			 *  (This SHOULD actually return an energy value)
			 */
			sub_ap = *ap;			/* struct copy */
			VMOVE( sub_ap.a_ray.r_dir, tolight );
			VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
			sub_ap.a_hit = light_hit;
			sub_ap.a_miss = light_miss;
			sub_ap.a_user = (int)lp;	/* so we can tell.. */
			sub_ap.a_level = 0;

			VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
			sub_ap.a_purpose = lp->lt_name;	/* name of light shot at */
			if( rt_shootray( &sub_ap ) )  {
				/* light visible */
				swp->sw_visible[i] = (char *)lp;
				VMOVE( intensity, sub_ap.a_color );
			} else {
				/* dark (light obscured) */
				swp->sw_visible[i] = (char *)0;
			}
		}
		have |= MFI_LIGHT;
	}

	/* Record which fields were filled in */
	swp->sw_inputs = have;

	if( (want & have) != want )
		rt_log("shade_inputs:  unable to satisfy request for x%x\n", want);
@


8.15
log
@The rand() macros now require a parameter which is the random number
table pointer to be used.  This provides perfectly "safe" access to
the random number tables in a parallel processing environment.
Each processor is seeded differently in worker.c
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.14 89/04/28 06:22:36 mike Locked $ (BRL)";
a71 1
extern FILE	*outfp;			/* optional output file */
a72 13
extern int	width;
extern int	height;

extern int	lightmodel;		/* lighting model # to use */
extern mat_t	view2model;
extern mat_t	model2view;
extern int	hex_out;		/* Output format, 0=binary, !0=hex */
extern char	*scanbuf;		/* Optional output buffer */
extern int	incr_mode;		/* !0 for incremental resolution */
extern int	incr_level;		/* current incremental level */
extern int	incr_nlevel;		/* number of levels */
extern int	pix_start;		/* pixel to start at */

a80 1
extern double AmbientIntensity;
@


8.14
log
@added a pr_shadework() hook on RDEBUG_SHADE
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.13 89/04/27 22:23:40 phil Locked $ (BRL)";
d151 3
a153 3
		r = ap->a_color[0]*255.+rand0to1();
		g = ap->a_color[1]*255.+rand0to1();
		b = ap->a_color[2]*255.+rand0to1();
d787 9
a795 3
				tolight[X] = lp->lt_pos[X] + rand_half()*f - swp->sw_hit.hit_point[X];
				tolight[Y] = lp->lt_pos[Y] + rand_half()*f - swp->sw_hit.hit_point[Y];
				tolight[Z] = lp->lt_pos[Z] + rand_half()*f - swp->sw_hit.hit_point[Z];
@


8.13
log
@Changed UV mapping for sphere (U==0 now on X axis)
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.12 89/04/14 13:15:54 phil Locked $ (BRL)";
d661 4
a1155 1

@


8.12
log
@Removed unnecessary extra parameter to rr_render.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.11 89/04/04 05:02:13 mike Exp $ (BRL)";
d424 3
a426 1
			ap->a_ray.r_dir[X] ) * rt_inv2pi + 0.5;
@


8.11
log
@Converted to new way of representing structure offsets.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.10 89/03/28 16:33:57 mike Locked $ (BRL)";
d46 1
d558 1
d571 1
a571 1
		(void)rr_render( ap, pp, &sw, pp->pt_regionp->reg_udata );
@


8.10
log
@added points shader
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.9 89/03/04 03:35:01 phil Locked $ (BRL)";
d110 4
a113 4
	"%d",	"bounces",	(stroff_t)&max_bounces,			FUNC_NULL,
	"%d",	"ireflect",	(stroff_t)&max_ireflect,		FUNC_NULL,
	"%V",	"background",	(stroff_t)background,			FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
@


8.9
log
@Eliminated needless log message
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.8 89/02/17 11:02:35 mike Locked $ (BRL)";
d1040 1
d1051 1
@


8.8
log
@Phil noted that the uv_v calculation using atan2() was not right.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.7 89/02/10 03:52:37 mike Locked $ (BRL)";
a1019 1
		rt_log("Buffering up to %d pixel scanlines\n", srv_scanlen);
@


8.7
log
@New buf_mode=4 support for rtsrv
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.6 89/01/09 04:52:22 mike Locked $ (BRL)";
d421 1
d424 4
d431 1
a431 1
			rt_inv2pi + 0.5;
@


8.6
log
@Fixed atan2 scaling
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.5 89/01/08 23:04:41 mike Locked $ (BRL)";
d99 5
a103 1
static int	buf_mode=0;	/* 0=pixel, 1=line, 2=frame */
d129 1
d224 2
a225 1
		if( buf_mode == 1 )  {
d228 3
a230 1
		} else {
d233 6
d323 2
d974 3
a976 1
#ifndef RTSRV
d984 1
a984 3
	}  else
#endif not RTSRV
	{
d987 1
d995 2
a996 1
		scanbuf = rt_malloc( width*3 + sizeof(long), "scanbuf [line]" );
d1000 4
a1003 2
		scanbuf = rt_malloc( width*height*3 + sizeof(long), "scanbuf [frame]" );
		npix_left = (int *)rt_malloc( height*sizeof(int), "npix_left[]" );
d1007 2
a1008 1
		scanbuf = rt_malloc( width*height*3 + sizeof(long), "scanbuf [frame]" );
d1011 7
@


8.5
log
@Replaced asin() with mat_atan2() formulation, which is more stable.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.4 88/12/27 16:35:21 mike Locked $ (BRL)";
d395 1
a395 1
		hit.hit_dist = 0.0;
d410 1
a410 1
			rt_invpi + 0.5;
@


8.4
log
@Converted matparse --> structparse
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.3 88/12/15 03:30:18 mike Locked $ (BRL)";
d407 4
a410 1
		sw.sw_uv.uv_v = asin( ap->a_ray.r_dir[Z] ) * rt_invpi + 0.5;
@


8.3
log
@removed ireflect, maxbounce stubs.  put in view_parse stub instead.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.2 88/12/06 04:48:11 phil Locked $ (BRL)";
d105 5
a109 5
struct matparse view_parse[] = {
	"bounces",	(mp_off_ty)&max_bounces,		"%d",
	"ireflect",	(mp_off_ty)&max_ireflect,		"%d",
	"background",	(mp_off_ty)background,			"%V",
	(char *)0,	(mp_off_ty)0,				(char *)0
@


8.2
log
@Added code so that even in PARALLEL mode, scanlines are written to
the output file as they are completed.
Also, fixed things so that restarting in the middle of an output file
in parallel mode would work right.
(This means having to read in the image so far, first ).
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.1 88/10/05 00:33:34 mike Locked $ (BRL)";
d87 1
d103 8
@


8.1
log
@Release_3.0
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.20 88/09/17 08:44:01 mike Exp $ (BRL)";
d84 1
d114 2
a115 2
 *	buf_mode = 2	full frame buffering, dump to fb at end of scanline
 *	buf_mode = 3	full frame buffering, dump to fb at end of frame
d174 2
a175 1
	 *  Handle file output
d177 2
a178 1
	if( !rt_g.rtg_parallel && outfp != NULL )  {
d248 7
a254 5
		if( do_eol && fbp != FBIO_NULL )  {
			RES_ACQUIRE( &rt_g.res_syscall );
			if( incr_mode )  {
				register int dy, yy;
				register int spread;
d256 9
a264 5
				spread = 1<<(incr_nlevel-incr_level);
				for( dy=0; dy<spread; dy++ )  {
					yy = ap->a_y + dy;
					fb_write( fbp, 0, yy,
					    scanbuf+yy*width*3, width );
d266 1
a266 3
			} else {
				fb_write( fbp, 0, ap->a_y,
				    scanbuf+ap->a_y*width*3, width );
d268 11
a278 1
			RES_RELEASE( &rt_g.res_syscall );
d287 4
a290 2
 *  has been finished.  When in parallel mode, there is no guarantee
 *  that the last few pixels are done -- just send off the buffer.
d321 9
a329 7
		/* Dump full screen */
		if( fb_getwidth(fbp) == width && fb_getheight(fbp) == height )  {
			fb_write( fbp, 0, 0, scanbuf, width*height );
		} else {
			register int y;
			for( y=0; y<height; y++ )
				fb_write( fbp, 0, y, scanbuf+y*width*3, width );
a330 6
	}
	if( incr_mode )  {
		if( incr_level < incr_nlevel )
			return(0);		 /* more res to come */
	}
	if( rt_g.rtg_parallel )  {
d337 4
d1049 16
@


7.20
log
@Adjusted documentation on -P flag to reflect new DEFAULT_PSW setting
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.19 88/08/23 02:32:44 mike Locked $ (BRL)";
@


7.19
log
@Added using_mlib=1, to ensure that mlib_setup() is called.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.18 88/08/20 07:14:29 mike Locked $ (BRL)";
d67 1
a67 1
 -P #		Set number of processors (default 1)\n\
@


7.18
log
@Improved some debugging, absorbed mlib_setup() function.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.17 88/07/26 01:18:00 mike Locked $ (BRL)";
d52 1
@


7.17
log
@Modifications to -i (incr_mode) that cause each scanline to be
written when finished, rather than waiting for whole frame to finish.
Also, changed to not display the first 4 iterations, which tend to
be boring and consume network and framebuffer bandwidth.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.16 88/06/22 22:17:59 mike Locked $ (BRL)";
a71 1
extern int	rt_perspective;
d402 1
d421 3
d430 1
a430 1
		return(1);
d444 1
a444 1
					pp->pt_inseg->seg_stp->st_name,
d450 1
a450 1
			return(1);
d461 1
a461 1
		return(1);
d520 8
d962 25
a986 1
	mlib_init();			/* initialize material library */
@


7.16
log
@Improved color dither.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.15 88/06/21 02:48:18 phil Locked $ (BRL)";
d231 5
d247 14
a260 1
			fb_write( fbp, 0, ap->a_y, scanbuf+ap->a_y*width*3, width );
d310 2
d916 1
d918 1
a918 1
		buf_mode = 3;		/* Frame buffering, dump at end */
d920 1
a920 1
		buf_mode = 2;		/* frame buffering */
d978 26
a1030 9

	switch( buf_mode )  {
	case 2:
		for( i=0; i<height; i++ )
			npix_left[i] = width;
		break;
	default:
		break;
	}
@


7.14
log
@Implicit lights have become invisible lights.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.13 88/06/16 02:53:28 mike Locked $ (BRL)";
d131 3
d135 3
a137 3
		r = ap->a_color[0]*255.+rand_half();
		g = ap->a_color[1]*255.+rand_half();
		b = ap->a_color[2]*255.+rand_half();
@


7.13
log
@usage message
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.12 88/05/20 03:26:33 phil Locked $ (BRL)";
d300 1
a300 1
	/* Eliminate implicit lights */
d303 1
a303 1
		if( lp->lt_implicit )  {
@


7.12
log
@Added use_air variable.
changed for new wraypts() calling sequence
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.11 88/05/14 02:28:30 mike Locked $ (BRL)";
d56 3
a58 1
 -s #		Grid size in pixels (default 512)\n\
d65 1
a65 1
 -p #		Perspective viewing, focal length scaling\n\
@


7.11
log
@lint fixes
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.10 88/02/27 07:46:33 mike Locked $ (BRL)";
d51 2
d442 1
d444 1
a444 1
				ap, stdout );
@


7.10
log
@Added support for material "envmap" -- an environment map,
with an arbitrary shader attached.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.9 88/02/27 03:10:00 mike Locked $ (BRL)";
d96 2
d112 1
d248 1
d585 1
d937 1
@


7.9
log
@Converted remaining "parallel" vars to "rt_g.rtg_parallel".
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.8 88/02/25 00:50:57 mike Locked $ (BRL)";
d83 2
d326 35
@


7.8
log
@Modified for new 3-D floating point UNIX-plot
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.7 88/01/26 05:35:07 mike Locked $ (BRL)";
a70 1
extern int	parallel;		/* Trying to use multi CPUs */
d163 1
a163 1
	if( !parallel && outfp != NULL )  {
d282 1
a282 1
	if( parallel )  {
d848 1
a848 1
	} else if( parallel )  {
@


7.7
log
@implicit and infinite lights, tolight vector list
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.6 88/01/25 22:38:47 phil Locked $ (BRL)";
d323 1
a323 2
		rt_drawvec( stdout, ap->a_rt_i,
			ap->a_ray.r_pt, out );
d421 1
a421 2
			rt_drawvec( stdout, ap->a_rt_i,
				ap->a_ray.r_pt, inhit );
d429 1
a429 2
			rt_drawvec( stdout, ap->a_rt_i,
				inhit, outhit );
@


7.6
log
@Added setup for refractive index, changed max_bounces to an extern.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.5 88/01/25 21:19:28 mike Locked $ (BRL)";
d294 4
a297 3
		if( lp->lt_explicit )  {
			/* will be cleaned by mlib_free() */
			lp = lp->lt_forw;
d300 2
a301 3
		nlp = lp->lt_forw;
		light_free( (char *)lp );
		lp = nlp;
d438 1
d500 1
d628 1
a628 1
		register fastf_t *intensity;
a629 1
		vect_t to_light;
d635 1
a635 1
		for( i=0, lp=LightHeadp, intensity = swp->sw_intensity;
d637 1
a637 1
			lp = lp->lt_forw, i++, intensity += 3
d639 8
a646 3
			if( !(lp->lt_explicit) )  {
				/* If this is an implicit light,
			  	 * then just claim the light is visible.
d648 4
a651 3
				swp->sw_visible[i] = (char *)lp;
				VSETALL( intensity, 1 );
				continue;
d655 1
a655 4
			 *  An explicit light source, and the shader desires
			 *  light visibility information.
			 *  Dither light pos for penumbra by +/- 0.5 light radius;
			 *  this presently makes a cubical light source distribution.
d657 3
a659 7
			f = lp->lt_radius * 0.9;
			to_light[X] = lp->lt_pos[X] + rand_half()*f - swp->sw_hit.hit_point[X];
			to_light[Y] = lp->lt_pos[Y] + rand_half()*f - swp->sw_hit.hit_point[Y];
			to_light[Z] = lp->lt_pos[Z] + rand_half()*f - swp->sw_hit.hit_point[Z];
			if( have & MFI_NORMAL )  {
				if( VDOT(swp->sw_hit.hit_normal,to_light) < 0 ) {
					/* backfacing */
d664 1
a664 1
			VUNITIZE( to_light );
d668 1
d670 1
a670 1
			if( -VDOT(to_light, lp->lt_aim) < lp->lt_cosangle )  {
d687 1
a687 1
			VMOVE( sub_ap.a_ray.r_dir, to_light );
d691 1
@


7.5
log
@oops, oversight in previous revision
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.4 88/01/22 20:52:55 phil Locked $ (BRL)";
d82 2
a91 3
#define MAX_IREFLECT	9	/* Maximum internal reflection level */
#define MAX_BOUNCE	4	/* Maximum recursion level */

d371 1
a371 1
		    ap->a_level > MAX_BOUNCE )  {
d903 2
@


7.4
log
@added normal dotting optimization on light visibility computation
delayed sub_ap struct copy until we absolutely needed it
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.3 88/01/20 08:47:55 phil Locked $ (BRL)";
d670 1
a670 1
			if( -VDOT(sub_ap.a_ray.r_dir, lp->lt_aim) < lp->lt_cosangle )  {
@


7.3
log
@Split out shade_inputs() function, so that reflect/refract
routine could obtain accurate NORMALs, if they were not already
computed.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.2 88/01/15 14:52:02 mike Locked $ (BRL)";
d629 1
a650 2
			 *  Fire ray at light source to check for shadowing.
			 *  (This SHOULD actually return an energy value)
a653 1
			sub_ap = *ap;			/* struct copy */
d655 11
a665 4
			sub_ap.a_ray.r_dir[X] =  lp->lt_pos[X] + rand_half()*f - swp->sw_hit.hit_point[X];
			sub_ap.a_ray.r_dir[Y] =  lp->lt_pos[Y] + rand_half()*f - swp->sw_hit.hit_point[Y];
			sub_ap.a_ray.r_dir[Z] =  lp->lt_pos[Z] + rand_half()*f - swp->sw_hit.hit_point[Z];
			VUNITIZE( sub_ap.a_ray.r_dir );
d681 7
@


7.2
log
@perspective is a common library name in some graphics librariues
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 7.1 87/11/02 23:56:44 stay Locked $ (BRL)";
d440 1
d444 1
a444 1
	viewshade( ap, pp, &sw );
d452 1
a452 1
	return(1);		/* "ret" isn't reliable yet */
d458 2
a459 1
 *  Call the material-specific shading function.
a460 6
 *  Note that only hit_dist is valid in pp_inhit.
 *  RT_HIT_NORM() must be called if hit_norm is needed,
 *  after which pt_inflip must be handled.
 *  ft_uv() routines must have hit_point computed
 *  in advance.
 *
d474 1
a474 1
	int i;
d500 20
a519 1
	if( mfp->mf_inputs & (MFI_HIT|MFI_NORMAL|MFI_LIGHT|MFI_UV) )  {
d522 1
d524 46
a569 1
	if( mfp->mf_inputs & MFI_NORMAL )  {
d576 1
a576 1
			/* Stupid SysV PCC needs this on one line */
d579 1
a579 1
			/* Temporary check to make sure normals are OK */
d583 1
a583 1
			    	VPRINT("viewshade: N", swp->sw_hit.hit_normal);
d585 1
a585 1
				return(0);
d587 1
d592 2
a593 1
			/* More temporary checking */
d595 1
a595 1
				rt_log("viewshade: flipped normal %d %d %s dot=%g\n",
d602 1
d604 1
a604 1
	if( mfp->mf_inputs & MFI_UV )  {
d616 1
a616 1
			rt_log("viewshade:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
d621 1
a621 1
			return(1);
d623 1
d625 3
a627 4
	/*
	 *  Determine light visibility
	 */
	for( i=0, lp=LightHeadp; lp; lp = lp->lt_forw, i++ )  {
a628 1
		register fastf_t *intensity;
d631 15
a645 1
		intensity = swp->sw_intensity+3*i;
d647 7
a653 9
		if( !(lp->lt_explicit) ||
		    !(mfp->mf_inputs & MFI_LIGHT) ||
		    swp->sw_xmitonly
		  )  {
			/* IF:
		  	 *  -- this is an implicit light, or
		  	 *  -- the shader does not want visibility info, or
		  	 *  -- this is visibility ray wanting xmit data only
		  	 * THEN just claim the light is visible
d655 6
a660 4
			swp->sw_visible[i] = (char *)lp;
			VSETALL( intensity, 1 );
			continue;
		}
d662 18
a679 14
		/*
		 *  An explicit light source, and the shader desires
		 *  light visibility information.
		 *  Fire ray at light source to check for shadowing.
		 *  (This SHOULD actually return an energy value)
		 *  Dither light pos for penumbra by +/- 0.5 light radius;
		 *  this presently makes a cubical light source distribution.
		 */
		sub_ap = *ap;			/* struct copy */
		f = lp->lt_radius * 0.9;
		sub_ap.a_ray.r_dir[X] =  lp->lt_pos[X] + rand_half()*f - swp->sw_hit.hit_point[X];
		sub_ap.a_ray.r_dir[Y] =  lp->lt_pos[Y] + rand_half()*f - swp->sw_hit.hit_point[Y];
		sub_ap.a_ray.r_dir[Z] =  lp->lt_pos[Z] + rand_half()*f - swp->sw_hit.hit_point[Z];
		VUNITIZE( sub_ap.a_ray.r_dir );
d681 10
a690 7
		/*
		 * See if ray from hit point to light lies within light beam
		 */
		if( -VDOT(sub_ap.a_ray.r_dir, lp->lt_aim) < lp->lt_cosangle )  {
			/* dark (outside of light beam) */
			swp->sw_visible[i] = (char *)0;
			continue;
d692 1
a692 21
		if( !(lp->lt_shadows) )  {
			/* "fill light" in beam, don't care about shadows */
			swp->sw_visible[i] = (char *)lp;
			VSETALL( intensity, 1 );
			continue;
		}
		VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
		sub_ap.a_hit = light_hit;
		sub_ap.a_miss = light_miss;
		sub_ap.a_level = 0;

		VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
		sub_ap.a_purpose = lp->lt_name;	/* name of light shot at */
		if( rt_shootray( &sub_ap ) )  {
			/* light visible */
			swp->sw_visible[i] = (char *)lp;
			VMOVE( intensity, sub_ap.a_color );
		} else {
			/* dark (light obscured) */
			swp->sw_visible[i] = (char *)0;
		}
d695 2
a696 2
	/* Invoke the actual shader (may be a tree of them) */
	(void)mfp->mf_render( ap, pp, swp, rp->reg_udata );
d698 2
a699 1
	return(1);
@


7.1
log
@Release 2.3
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.9 87/10/16 00:49:06 mike Exp $ (BRL)";
d68 1
a68 1
extern int	perspective;
@


6.9
log
@Added setting and use of lt_name, for better multi-light debugging.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.8 87/10/15 16:59:02 mike Locked $ (BRL)";
@


6.8
log
@Added MFI_HIT, for handling just hit point.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.7 87/09/11 02:08:32 mike Locked $ (BRL)";
d620 1
a620 1
		sub_ap.a_purpose = "light visibility?";
@


6.7
log
@Added directional lights, and lights that don't cast shadows
for "fill lighting".
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.6 87/09/10 07:12:50 mike Exp $ (BRL)";
d504 1
a504 1
	if( mfp->mf_inputs )  {
@


6.6
log
@Light visibility is now determined in viewshade();
supporting light hit&miss routines moved to light.c
plastic.c now merely implements Phong shading.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.5 87/09/10 01:46:24 mike Locked $ (BRL)";
d469 1
a469 2
static char *light_hack = "light visibility?";

d589 3
a591 1
		 *  This SHOULD actually return an energy value
d593 1
a593 8
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_hit = light_hit;
		sub_ap.a_miss = light_miss;
		sub_ap.a_level = 0;
		VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
			
		/* Dither light pos for penumbra by +/- 0.5 light radius */
		/* This presently makes a cubical light source distribution */
d599 20
d620 1
a620 2
/**		sub_ap.a_purpose = "light visibility?"; **/
		sub_ap.a_purpose = light_hack;
@


6.5
log
@Reinit # of pixels to do, for each frame.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.4 87/09/04 03:43:41 mike Locked $ (BRL)";
d82 1
a331 9
static struct shadework shade_default = {
	0.0,				/* xmit */
	0.0,				/* reflect */
	1.0,				/* refractive index */
	1.0, 1.0, 1.0,			/* color: white */
	1.0, 1.0, 1.0,			/* basecolor: white */
	/* rest are zeros */
};

d437 5
a441 1
	sw = shade_default;			/* struct copy */
d469 2
d478 2
d561 7
a567 1
	/*** Should determine light visibility here ***/
d569 49
d839 1
a839 1
	light_init();
@


6.4
log
@Fixed parallel mode with interactive framebuffer
to send each scanline only when all pixels are done.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.3 87/09/03 01:30:42 mike Locked $ (BRL)";
a701 1
	register int i;
a727 2
		for( i=0; i<height; i++ )
			npix_left[i] = width;
d756 1
d789 10
@


6.3
log
@Added incremental resolution capability.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.1 87/07/11 07:59:31 mike Rel $ (BRL)";
d93 1
d194 1
d224 2
d228 6
a249 1
	RES_ACQUIRE( &rt_g.res_syscall );
a253 1
		fb_write( fbp, 0, ap->a_y, scanbuf+ap->a_y*width*3, width );
d256 1
d258 1
a260 1
	RES_RELEASE( &rt_g.res_syscall );
d273 7
a279 1
		fb_write( fbp, 0, 0, scanbuf, width*height );
d702 1
d728 3
@


6.2
log
@Changed view_pixel to use res_results semaphore.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 6.1 87/07/11 07:59:31 mike Locked $ (BRL)";
d78 3
d105 2
a106 1
 *	buf_mode = 2	full frame buffering
d204 19
a222 3
		*pixelp++ = r ;
		*pixelp++ = g ;
		*pixelp++ = b ;
d241 4
a244 1
	if( buf_mode == 2 )
d246 2
a247 1
	else
d249 2
d262 6
d288 1
d689 4
a692 5
	if( parallel )  {
		/* frame buffering */
		scanbuf = rt_malloc( width*height*3 + sizeof(long), "scanbuf [frame]" );
		buf_mode = 2;
		rt_log("Buffering full frames\n");
d694 1
a694 4
		/* single-pixel I/O */
		scanbuf = (char *)0;
		buf_mode = 0;
		rt_log("Single pixel I/O, unbuffered\n");
d698 9
a706 1
		/* line buffering */
a707 1
		buf_mode = 1;
d709 11
@


6.1
log
@Release 2.0
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.11 87/07/11 02:59:40 mike Exp $ (BRL)";
d199 1
a199 1
		RES_ACQUIRE( &rt_g.res_worker );	/* XXX need extra semaphore */
d203 1
a203 1
		RES_RELEASE( &rt_g.res_worker );
@


5.11
log
@Added sw_basecolor for dealing with glass filters.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.10 87/07/10 07:33:09 mike Locked $ (BRL)";
@


5.10
log
@Background darkening on "eye inside solid" MISS case fixed.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.9 87/07/09 03:31:10 mike Locked $ (BRL)";
d288 1
d453 1
@


5.9
log
@Changed parallel support from #ifdef to runtime determination.
Added 3 types of libfb interaction
Misc. cleanups.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.8 87/07/06 15:28:59 mike Locked $ (BRL)";
d279 1
d349 1
a349 1
		ap->a_user = rt_shootray( &sub_ap );	/* Signal view_pixel*/
d351 1
@


5.8
log
@Moved common processing to viewshade().
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.7 87/07/02 06:18:18 mike Locked $ (BRL)";
d71 2
d89 1
a89 13
/*
 *			H I T _ N O T H I N G
 *
 *  a_miss() routine called when no part of the model is hit.
 *  Background texture mapping could be done here.
 *  For now, return a pleasant dark blue.
 */
hit_nothing( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	if( rdebug&RDEBUG_RAYPLOT )  {
		vect_t	out;
a90 10
		VJOIN1( out, ap->a_ray.r_pt,
			10000, ap->a_ray.r_dir );	/* to imply direction */
		pl_color( stdout, 190, 0, 0 );
		rt_drawvec( stdout, ap->a_rt_i,
			ap->a_ray.r_pt, out );
	}
	ap->a_user = 0;		/* Signal view_pixel:  MISS */
	return(0);
}

a91 124
 *			V I E W I T
 *
 *  a_hit() routine for simple lighting model.
 */
viewit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	register struct partition *pp;
	register struct hit *hitp;
	LOCAL fastf_t diffuse2, cosI2;
	LOCAL fastf_t diffuse1, cosI1;
	LOCAL fastf_t diffuse0, cosI0;
	LOCAL vect_t work0, work1;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		rt_log("viewit:  no hit out front?\n");
		return(0);
	}
	hitp = pp->pt_inhit;
	RT_HIT_NORM( hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );

	/*
	 * Diffuse reflectance from each light source
	 */
	if( pp->pt_inflip )  {
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
	}
	switch( lightmodel )  {
	case 1:
		/* Light from the "eye" (ray source).  Note sign change */
		diffuse0 = 0;
		if( (cosI0 = -VDOT(hitp->hit_normal, ap->a_ray.r_dir)) >= 0.0 )
			diffuse0 = cosI0 * ( 1.0 - AmbientIntensity);
		VSCALE( work0, LightHeadp->lt_color, diffuse0 );

		/* Add in contribution from ambient light */
		VSCALE( work1, ambient_color, AmbientIntensity );
		VADD2( ap->a_color, work0, work1 );
		break;
	case 3:
		/* Simple attempt at a 3-light model. */
		{
			struct light_specific *l0, *l1, *l2;
			l0 = LightHeadp;
			l1 = l0->lt_forw;
			l2 = l1->lt_forw;

			diffuse0 = 0;
			if( (cosI0 = VDOT(hitp->hit_normal, l0->lt_vec)) >= 0.0 )
				diffuse0 = cosI0 * l0->lt_fraction;
			diffuse1 = 0;
			if( (cosI1 = VDOT(hitp->hit_normal, l1->lt_vec)) >= 0.0 )
				diffuse1 = cosI1 * l1->lt_fraction;
			diffuse2 = 0;
			if( (cosI2 = VDOT(hitp->hit_normal, l2->lt_vec)) >= 0.0 )
				diffuse2 = cosI2 * l2->lt_fraction;

			VSCALE( work0, l0->lt_color, diffuse0 );
			VSCALE( work1, l1->lt_color, diffuse1 );
			VADD2( work0, work0, work1 );
			VSCALE( work1, l2->lt_color, diffuse2 );
			VADD2( work0, work0, work1 );
		}
		/* Add in contribution from ambient light */
		VSCALE( work1, ambient_color, AmbientIntensity );
		VADD2( ap->a_color, work0, work1 );
		break;
	case 2:
		/* Store surface normals pointing inwards */
		/* (For Spencer's moving light program) */
		ap->a_color[0] = (hitp->hit_normal[0] * (-.5)) + .5;
		ap->a_color[1] = (hitp->hit_normal[1] * (-.5)) + .5;
		ap->a_color[2] = (hitp->hit_normal[2] * (-.5)) + .5;
		break;
	case 4:
	 	{
			LOCAL struct curvature cv;
			FAST fastf_t f;
			auto int ival;

			RT_CURVE( &cv, hitp, pp->pt_inseg->seg_stp );
	
			f = cv.crv_c1;
			f *= 10;
			if( f < -0.5 )  f = -0.5;
			if( f > 0.5 )  f = 0.5;
			ap->a_color[0] = 0.5 + f;
			ap->a_color[1] = 0;

			f = cv.crv_c2;
			f *= 10;
			if( f < -0.5 )  f = -0.5;
			if( f > 0.5 )  f = 0.5;
			ap->a_color[2] = 0.5 + f;
		}
		break;
	case 5:
	 	{
			LOCAL struct curvature cv;
			FAST fastf_t f;
			auto int ival;

			RT_CURVE( &cv, hitp, pp->pt_inseg->seg_stp );

			ap->a_color[0] = (cv.crv_pdir[0] * (-.5)) + .5;
			ap->a_color[1] = (cv.crv_pdir[1] * (-.5)) + .5;
			ap->a_color[2] = (cv.crv_pdir[2] * (-.5)) + .5;
	 	}
		break;
	}

	if(rdebug&RDEBUG_HITS)  {
		rt_pr_hit( " In", hitp );
		rt_log("cosI0=%f, diffuse0=%f   ", cosI0, diffuse0 );
		VPRINT("RGB", ap->a_color);
	}
	ap->a_user = 1;		/* Signal view_pixel:  HIT */
	return(0);
}

/*
d95 8
d154 6
a159 9
#if !defined(PARALLEL) && !defined(RTSRV)
	if( fbp != FBIO_NULL )  {
		RGBpixel p;
		p[RED] = r;
		p[GRN] = g;
		p[BLU] = b;
		fb_write( fbp, ap->a_x, ap->a_y, p, 1 );
	}
	if( outfp != NULL )  {
d171 17
a187 2
#else PARALLEL or RTSRV
	{
d190 8
a197 7
		/* .pix files go bottom to top */
#ifdef RTSRV
		/* Here, the buffer is only one line long */
		pixelp = scanbuf+ap->a_x*3;
#else RTSRV
		pixelp = scanbuf+((ap->a_y*width)+ap->a_x)*3;
#endif RTSRV
a204 2
#endif PARALLEL or RTSRV
	if(rdebug&RDEBUG_HITS) rt_log("rgb=%3d,%3d,%3d\n", r,g,b);
d207 75
d464 2
a465 2
			RT_HIT_NORM( &(swp->sw_hit), pp->pt_inseg->seg_stp,
				&(ap->a_ray) );
d518 3
a520 4
 *  			V I E W _ E O L
 *  
 *  This routine is called by main when the end of a scanline is
 *  reached.
d522 1
a522 1
view_eol(ap)
d524 1
d526 6
a531 9
#ifdef PARALLEL
	if( fbp ==FBIO_NULL )
		return;
	/* We make no guarantee that the last few pixels are done */
	RES_ACQUIRE( &rt_g.res_syscall );
	fb_write( fbp, 0, ap->a_y, scanbuf+ap->a_y*width*3, width );
	RES_RELEASE( &rt_g.res_syscall );
#endif PARALLEL
}
d533 8
a540 7
/*
 *			V I E W _ E N D
 */
view_end(ap)
struct application *ap;
{
	register struct light_specific *lp, *nlp;
d542 5
a546 5
#ifdef PARALLEL
	if( (outfp != NULL) &&
	    fwrite( scanbuf, sizeof(char), width*height*3, outfp ) != width*height*3 )  {
		fprintf(stderr,"view_end:  fwrite failure\n");
		return(-1);		/* BAD */
d548 7
a554 1
#endif PARALLEL
d556 27
a582 7
	/* Eliminate implicit lights */
	lp=LightHeadp;
	while( lp != LIGHT_NULL )  {
		if( lp->lt_explicit )  {
			/* will be cleaned by mlib_free() */
			lp = lp->lt_forw;
			continue;
d584 46
a629 3
		nlp = lp->lt_forw;
		light_free( (char *)lp );
		lp = nlp;
d631 8
d651 19
a669 3
#ifdef PARALLEL
	scanbuf = rt_malloc( width*height*3 + sizeof(long), "scanbuf" );
#endif
@


5.7
log
@Added computation for hit_point.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.6 87/06/27 06:46:29 phil Exp $ (BRL)";
d397 1
d444 1
a444 9
	/*
	 *  Call the material-handling function.
	 *  Note that only hit_dist is valid in pp_inhit.
	 *  RT_HIT_NORM() must be called if hit_norm is needed,
	 *  after which pt_inflip must be handled.
	 *  ft_uv() routines must have hit_point computed
	 *  in advance.
	 */
	sw = shade_default;	/* struct copy */
d446 36
d483 1
a483 1
		rt_log("colorview:  reg_mfuncs NULL\n");
d487 1
a487 1
		rt_log("colorview:  reg_mfuncs bad magic, %x != %x\n",
d491 4
d496 3
a498 15
	/* Get color-by-ident for this region id */
	{
		register struct region *rp;
		if( (rp=pp->pt_regionp) == REGION_NULL )  {
			rt_log("bad region pointer\n");
			return(0);
		}
		if( rp->reg_mater.ma_override )  {
			VSET( sw.sw_color,
				rp->reg_mater.ma_color[0],
				rp->reg_mater.ma_color[1],
				rp->reg_mater.ma_color[2] );
		} else {
			/* Default color is white (uncolored) */
		}
d501 2
a502 3
	sw.sw_hit = *(pp->pt_inhit);		/* struct copy */
	if( sw.sw_hit.hit_dist < 0.0 )
		sw.sw_hit.hit_dist = 0.0;	/* Eye inside solid */
d504 2
a505 2
		VJOIN1( sw.sw_hit.hit_point, ap->a_ray.r_pt,
			sw.sw_hit.hit_dist, ap->a_ray.r_dir );
d510 1
a510 1
			VREVERSE( sw.sw_hit.hit_normal, ap->a_ray.r_dir );
d512 1
a512 1
			fastf_t f;
d514 1
a514 1
			RT_HIT_NORM( &(sw.sw_hit), pp->pt_inseg->seg_stp,
d518 5
a522 5
			if( sw.sw_hit.hit_normal[X] < -1.01 || sw.sw_hit.hit_normal[X] > 1.01 ||
			    sw.sw_hit.hit_normal[Y] < -1.01 || sw.sw_hit.hit_normal[Y] > 1.01 ||
			    sw.sw_hit.hit_normal[Z] < -1.01 || sw.sw_hit.hit_normal[Z] > 1.01 )  {
			    	VPRINT("colorview: N", sw.sw_hit.hit_normal);
				VSET( ap->a_color, 9, 9, 0 );	/* Yellow */
d526 1
a526 1
				VREVERSE( sw.sw_hit.hit_normal, sw.sw_hit.hit_normal );
d530 2
a531 2
			if( (f=VDOT( ap->a_ray.r_dir, sw.sw_hit.hit_normal )) > 0 )  {
				rt_log("colorview: flipped normal %d %d %s dot=%g\n",
d535 1
a535 1
				VPRINT("Norm", sw.sw_hit.hit_normal);
d542 2
a543 2
			sw.sw_uv.uv_u = sw.sw_uv.uv_v = 0.5;
			sw.sw_uv.uv_du = sw.sw_uv.uv_dv = 0;
d547 1
a547 1
				&(sw.sw_hit), &(sw.sw_uv) );
d549 5
a553 5
		if( sw.sw_uv.uv_u < 0 || sw.sw_uv.uv_u > 1 ||
		    sw.sw_uv.uv_v < 0 || sw.sw_uv.uv_v > 1 )  {
			rt_log("colorview:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
				sw.sw_uv.uv_u, sw.sw_uv.uv_v,
				sw.sw_uv.uv_du, sw.sw_uv.uv_dv,
d555 1
a555 1
			VSET( sw.sw_color, 0, 1, 0 );	/* Green */
d559 1
d562 1
a562 1
	(void)mfp->mf_render( ap, pp, &sw, pp->pt_regionp->reg_udata );
d564 1
a564 7
	/* As a special case for now, handle reflection & refraction */
	if( sw.sw_reflect > 0 || sw.sw_transmit > 0 )
		(void)rr_render( ap, pp, &sw, pp->pt_regionp->reg_udata );

	VMOVE( ap->a_color, sw.sw_color );
	ap->a_user = 1;		/* Signal view_pixel:  HIT */
	return(1);		/* "ret" isn't reliable yet */
@


5.6
log
@rendering parameter changes
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.5 87/06/27 03:47:39 phil Locked $ (BRL)";
d405 2
@


5.5
log
@Improved ray plotting, rgb->color, etc.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.4 87/06/26 06:25:18 mike Locked $ (BRL)";
d539 1
a539 1
	(void)mfp->mf_render( ap, pp, &sw );
d543 1
a543 1
		(void)rr_render( ap, pp, &sw );
@


5.4
log
@Fixed typo.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.3 87/06/26 05:58:05 mike Locked $ (BRL)";
d98 9
d411 3
d416 3
a418 1
			vect_t hit;
d420 14
a433 5
			if( lvl > 3 )  lvl = 3;
			i = 127 + lvl * (128/4);
			/* Should check for INFINITY here.  XXX */
			VJOIN1( hit,
				ap->a_ray.r_pt, pp->pt_outhit->hit_dist,
d437 1
a437 1
				ap->a_ray.r_pt, hit );
d470 3
a472 3
				rp->reg_mater.ma_rgb[0]/255.,
				rp->reg_mater.ma_rgb[1]/255.,
				rp->reg_mater.ma_rgb[2]/255. );
d527 9
d542 2
a543 1
	(void)rr_render( ap, pp, &sw );
@


5.3
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.2 87/06/24 23:35:17 mike Locked $ (BRL)";
d490 1
a490 1
				VPRINT("Norm", sw.sw_hit.hit_norm);
@


5.2
log
@Release 1.24 (with fix)
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 5.1 87/06/24 22:15:36 mike Locked $ (BRL)";
d47 1
d68 1
d323 7
d343 2
d365 1
d388 2
a389 3
		(void)rt_shootray( &sub_ap );
		VSCALE( ap->a_color, sub_ap.a_color, 0.8 );
		ap->a_user = 1;		/* Signal view_pixel:  HIT */
d421 2
d424 1
a424 6
	 *  in advance, which is responsibility of reg_ufunc() routines.
	 *  RT_HIT_NORM() must also be called if hit_norm is needed,
	 *  after which pt_inflip must be handled.
	 *  These operations have been pushed down to the individual
	 *  material-handling functions for efficiency reasons,
	 *  because not all materials need the normals.
d426 13
d440 3
a442 5
		register struct mfuncs *mfp = pp->pt_regionp->reg_mfuncs;
		register int ret;

		if( mfp == MF_NULL )  {
			rt_log("colorview:  reg_mfuncs NULL\n");
d445 7
a451 4
		if( mfp->mf_magic != MF_MAGIC )  {
			rt_log("colorview:  reg_mfuncs bad magic, %x != %x\n",
				mfp->mf_magic, MF_MAGIC );
			return(0);
a452 3
		ret = mfp->mf_render( ap, pp );
		ap->a_user = 1;		/* Signal view_pixel:  HIT */
		return(1);		/* "ret" isn't reliable yet */
d454 61
@


5.1
log
@Release 1.24
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.15 87/06/13 03:20:38 mike Exp $ (BRL)";
d433 1
a433 1
		return(ret);
@


4.15
log
@Switched non-background code to non-iterative strategy.
Especially important when running in BENCHMARK mode,
because rand_half() will always give 0.0.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.14 87/06/13 01:40:26 mike Locked $ (BRL)";
@


4.14
log
@Changed to allow arbitrary background.  Missing the model
(hitting background) is now flagged in a_user.
Background is NOT dithered, and hit colors are dithered AWAY
from the background color, to be able to pixmerge in new
backgrounds with confidence.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.13 87/05/30 07:04:05 mike Locked $ (BRL)";
d242 1
a242 2
		 *  Be certain to NOT output the background color here;
		 *  dither away from it.
d244 33
a276 13
		do {
			r = ap->a_color[0]*255.+rand_half();
			g = ap->a_color[1]*255.+rand_half();
			b = ap->a_color[2]*255.+rand_half();
			if( r > 255 ) r = 255;
			else if( r < 0 )  r = 0;
			if( g > 255 ) g = 255;
			else if( g < 0 )  g = 0;
			if( b > 255 ) b = 255;
			else if( b < 0 )  b = 0;
		} while( r == ibackground[0] &&
			 g == ibackground[1] &&
			 b == ibackground[2] );
@


4.13
log
@Added code for non-square views, single pixel (-b) debugging.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.12 87/04/28 00:29:34 mike Locked $ (BRL)";
d79 3
d86 15
d220 1
d234 24
a257 12
	/* To prevent bad color aliasing, add some color dither */
	r = ap->a_color[0]*255.+rand_half();
	g = ap->a_color[1]*255.+rand_half();
	b = ap->a_color[2]*255.+rand_half();
	if( r > 255 ) r = 255;
	if( g > 255 ) g = 255;
	if( b > 255 ) b = 255;
	if( r<0 || g<0 || b<0 )  {
		VPRINT("@@@@ Negative RGB @@@@", ap->a_color);
		r = 0x80;
		g = 0xFF;
		b = 0x80;
d330 1
d349 1
d359 1
d401 1
d412 3
a414 1
		return( mfp->mf_render( ap, pp ) );
d513 3
a516 1
	case 2:
d527 4
@


4.12
log
@changed RT_CURVE and lighting model 4
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.11 87/04/10 07:03:00 phil Locked $ (BRL)";
d53 4
a56 4
 -f #		Grid size in pixels, default 512, max 1024\n\
 -a Az		Azimuth in degrees\n\
 -e Elev	Elevation in degrees\n\
 -M		Read model2view matrix on stdin\n\
d61 1
d64 2
a65 2
extern FBIO	*fbp;		/* Framebuffer handle */
extern FILE	*outfp;		/* optional output file */
d67 7
a73 6
extern int lightmodel;		/* lighting model # to use */
extern mat_t view2model;
extern mat_t model2view;
extern int npts;
extern int hex_out;		/* Output format, 0=binary, !0=hex */
extern char *scanbuf;		/* Optional output buffer */
d258 1
a258 1
		pixelp = scanbuf+((ap->a_y*npts)+ap->a_x)*3;
d395 1
a395 1
	fb_write( fbp, 0, ap->a_y, scanbuf+ap->a_y*npts*3, npts );
d410 1
a410 1
	    fwrite( scanbuf, sizeof(char), npts*npts*3, outfp ) != npts*npts*3 )  {
d435 1
a435 1
view_init( ap, file, obj, npts, minus_o )
d441 1
a441 1
	scanbuf = rt_malloc( npts*npts*3 + sizeof(long), "scanbuf" );
@


4.11
log
@Minor changes to split rt.c into rt.c and do.c,
plus reintegration with remrt/rtsrv.c
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.10 87/04/07 20:54:29 phil Exp $ (BRL)";
d153 1
a153 1
		/* (For Spencer's moving light program */
d164 1
a164 1
			RT_CURVE( &cv, hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );
d167 4
a170 4
			f /= 64;
			if( f<0 )  f = -f;
			if( f > 1 )  f = 1;
			ap->a_color[0] = 1.0 - f;
d174 4
a177 4
			f /= 64;
			if( f<0 )  f = -f;
			if( f > 1 )  f = 1;
			ap->a_color[2] = 1.0 - f;
d186 1
a186 1
			RT_CURVE( &cv, hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );
@


4.10
log
@fixed rt_pr_pt arg list
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.9 87/04/01 04:51:45 phil Locked $ (BRL)";
d71 1
a71 8

#ifdef RTSRV
extern char scanbuf[];
#else
#ifdef PARALLEL
extern char *scanbuf;		/*** Output buffering, for parallelism */
#endif
#endif
@


4.9
log
@Added RDEBUG_PLOTRAY flag, and code to support it.
Gives direct UNIX-plot output of ray paths, clipped to model RPP.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.8 87/03/28 05:23:42 mike Exp $ (BRL)";
d299 1
a299 1
		rt_pr_pt(pp);
@


4.8
log
@Fixed PARALLEL case to only write when desired.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.7 87/03/23 23:47:55 mike Locked $ (BRL)";
d340 16
@


4.7
log
@Revised for new material property interface.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.6 87/03/17 22:31:06 mike Exp $ (BRL)";
d398 2
a399 1
	if( fwrite( scanbuf, sizeof(char), npts*npts*3, outfp ) != npts*npts*3 )  {
@


4.6
log
@Cleaned up parallel support code, moved some functions
into view.c
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.5 87/03/17 20:19:17 mike Locked $ (BRL)";
d354 13
a366 3
	if( !(pp->pt_regionp->reg_ufunc) )  {
		rt_log("colorview:  no reg_ufunc\n");
		return(0);
a367 1
	return( pp->pt_regionp->reg_ufunc( ap, pp ) );
d383 1
a383 1
	RES_ACQUIRE( &rt_g.res_malloc );
d385 1
a385 1
	RES_RELEASE( &rt_g.res_malloc );
d395 21
d420 2
d427 7
@


4.5
log
@Added multiple lights, added beginnings of command-driven
input capability.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.3 87/01/28 21:03:02 mike Exp $ (BRL)";
d69 1
a69 1

d261 1
a261 1
		pixelp = scanbuf+a.a_x*3;
d263 1
a263 1
		pixelp = scanbuf+((a.a_y*npts)+a.a_x)*3;
d367 2
a368 1
view_eol()
d370 8
d383 2
a384 1
view_end()
a385 2
	if( fbp != FBIO_NULL )
		fb_close(fbp);
@


4.4
log
@Release 1.20 -- First Formal Release
@
text
@d48 1
d72 9
a80 4
struct soltab *l0stp = SOLTAB_NULL;	/* ptr to light solid tab entry */
vect_t l0color = {  1,  1,  1 };		/* White */
vect_t l1color = {  1, .1, .1 };
vect_t l2color = { .1, .1,  1 };		/* R, G, B */
a81 4
vect_t l0vec;			/* 0th light vector */
vect_t l1vec;			/* 1st light vector */
vect_t l2vec;			/* 2st light vector */
vect_t l0pos;			/* pos of light0 (overrides l0vec) */
d124 1
a124 1
		VSCALE( work0, l0color, diffuse0 );
d132 5
a136 9
		diffuse0 = 0;
		if( (cosI0 = VDOT(hitp->hit_normal, l0vec)) >= 0.0 )
			diffuse0 = cosI0 * 0.5;		/* % from this src */
		diffuse1 = 0;
		if( (cosI1 = VDOT(hitp->hit_normal, l1vec)) >= 0.0 )
			diffuse1 = cosI1 * 0.5;		/* % from this src */
		diffuse2 = 0;
		if( (cosI2 = VDOT(hitp->hit_normal, l2vec)) >= 0.0 )
			diffuse2 = cosI2 * 0.2;		/* % from this src */
d138 9
a146 10
#ifdef notyet
		/* Specular reflectance from first light source */
		/* reflection = (2 * cos(i) * NormalVec) - IncidentVec */
		/* cos(s) = -VDOT(reflection, r_dir) = cosI0 */
		f = 2 * cosI1;
		VSCALE( work, hitp->hit_normal, f );
		VSUB2( reflection, work, l1vec );
		if( not_shadowed && cosI0 > cosAcceptAngle )
			/* Do specular return */;
#endif notyet
d148 6
a153 6
		VSCALE( work0, l0color, diffuse0 );
		VSCALE( work1, l1color, diffuse1 );
		VADD2( work0, work0, work1 );
		VSCALE( work1, l2color, diffuse2 );
		VADD2( work0, work0, work1 );

d234 1
d254 19
a342 10
	/* XXX Hack to see if we hit the light */
	{
		register struct soltab *stp;
		stp = pp->pt_inseg->seg_stp;
		if( stp == l0stp )  {
			VMOVE( ap->a_color, l0color );
			return(1);
		}
	}

a403 1
	vect_t temp;
d412 3
a414 4
		if( (l0stp=rt_find_solid(ap->a_rt_i,"LIGHT")) != SOLTAB_NULL )  {
			VMOVE( l0pos, l0stp->st_center );
			VPRINT("LIGHT0 at", l0pos);
			break;
d416 1
a416 2
		if(rdebug&RDEBUG_SHOWERR)rt_log("No explicit light\n");
		goto debug_lighting;
d423 1
a423 17
debug_lighting:
		/* Determine the Light location(s) in view space */
		/* 0:  At left edge, 1/2 high */
		VSET( temp, -1, 0, 1 );
		MAT4X3VEC( l0pos, view2model, temp );
		VMOVE( l0vec, l0pos );
		VUNITIZE(l0vec);

		/* 1: At right edge, 1/2 high */
		VSET( temp, 1, 0, 1 );
		MAT4X3VEC( l1vec, view2model, temp );
		VUNITIZE(l1vec);

		/* 2:  Behind, and overhead */
		VSET( temp, 0, 1, -0.5 );
		MAT4X3VEC( l2vec, view2model, temp );
		VUNITIZE(l2vec);
d428 1
@


4.3
log
@Release 1.16:  Added debug lighting models 4 & 5 to display curvature.
@
text
@d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.2 87/01/03 20:08:02 mike Locked $ (BRL)";
@


4.2
log
@Made "eye inside xxx" conditional on RDEBUG_SHOWERR
@
text
@d14 2
d35 1
a35 1
static char RCSview[] = "@@(#)$Header: view.c,v 4.1 86/12/29 03:48:55 mike Locked $ (BRL)";
d116 2
a117 1
	if( lightmodel == 1 )  {
d127 2
a128 1
	}  else if( lightmodel == 3 )  {
d160 2
a161 2
	} else {
		/* lightmodel == 2 */
d167 36
d416 2
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.20 86/12/19 23:11:12 mike Exp $ (BRL)";
d259 3
a264 3
			rt_log("colorview:  eye inside %s (x=%d, y=%d, lvl=%d)\n",
				pp->pt_inseg->seg_stp->st_name,
				ap->a_x, ap->a_y, ap->a_level);
@


3.20
log
@Removed Cray debug write.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.19 86/12/18 16:02:15 mike Locked $ (BRL)";
@


3.19
log
@rdebug.h separated from librt/debug.h
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.18 86/11/25 03:36:46 mike Locked $ (BRL)";
a211 3
#ifdef cray
rt_log("fwrite( 0%o, 3, 1, 0%o )\n", p, outfp);
#endif
@


3.18
log
@Updated usage message,
fb_open moved to rt.c
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.17 86/11/07 02:46:30 mike Locked $ (BRL)";
d44 1
a44 1
#include "../librt/debug.h"
d55 2
a56 1
 -x #		Set debug flags\n\
d61 1
d66 1
a68 6
#define MAX_LINE	(1024*8)	/* Max pixels/line */
/* Current arrangement is definitely non-parallel! */
static char scanline[MAX_LINE*3];	/* 1 scanline pixel buffer, R,G,B */
static char *pixelp;			/* pointer to first empty pixel */
static FILE *pixfp = NULL;		/* fd of .pix file */

d165 1
a165 1
	if(rt_g.debug&DEBUG_HITS)  {
d204 1
a204 1
	if( pixfp != NULL )  {
d206 1
a206 1
			fprintf(pixfp, "%2.2x%2.2x%2.2x\n", r, g, b);
d208 9
a216 3
			*pixelp++ = r;
			*pixelp++ = g;
			*pixelp++ = b;
d219 1
a219 1
	if(rt_g.debug&DEBUG_HITS) rt_log("rgb=%3d,%3d,%3d\n", r,g,b);
d244 1
a244 1
	if(rt_g.debug&DEBUG_HITS)  {
d260 1
a260 1
		    	if( rt_g.debug )  {
d280 1
a280 1
	if( rt_g.debug&DEBUG_RAYWRITE )  {
a324 18
	register int cnt;
	register int i;
	if( pixfp != NULL )  {
		if( hex_out )  return;
		cnt = pixelp - scanline;
		if( cnt <= 0 || cnt > sizeof(scanline) )  {
			rt_log("corrupt pixelp=x%x, scanline=x%x, cnt=%d\n",
				pixelp, scanline, cnt );
			pixelp = scanline;
			return;
		}
		i = fwrite( (char *)scanline, cnt, 1, pixfp );
		if( i != 1 )  {
			rt_log("view_eol: fwrite returned %d\n", i);
			rt_bomb("write error");
		}			
		pixelp = &scanline[0];
	}
a342 4
	if( npts > MAX_LINE )  {
		rt_log("view:  %d pixels/line > %d\n", npts, MAX_LINE);
		exit(12);
	}
a344 1
		pixelp = &scanline[0];
d356 1
a356 1
view_2init( ap, outfp )
a357 1
FILE *outfp;
a361 1
	pixfp = outfp;
d374 1
a374 1
		if(rt_g.debug)rt_log("No explicit light\n");
@


3.17
log
@Changed so that computation of hit_point and hit_norm is done
in the individual material routines, and only as much as needed.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.16 86/11/07 01:47:32 mike Locked $ (BRL)";
d50 3
a52 3
 -f#		Grid size in pixels, default 512, max 1024\n\
 -aAz		Azimuth in degrees\n\
 -eElev		Elevation in degrees\n\
d55 2
a56 2
 -x#		Set debug flags\n\
 -p[#]		Perspective viewing, focal length scaling\n\
d59 1
a59 1
FBIO	*fbp = FBIO_NULL;	/* Framebuffer handle */
d365 1
d367 1
a367 21
		int width;

		/* Output interactively to framebuffer */
		if( npts <= 512 )
			width = 512;
		else {
			if( npts <= 1024 )
				width = 1024;
			else
				width = npts;
		}

		if( (fbp = fb_open( NULL, width, width )) == FBIO_NULL )  {
			rt_log("view:  can't open frame buffer\n");
			exit(12);
		}
		fb_clear( fbp, PIXEL_NULL );
		fb_wmap( fbp, COLORMAP_NULL );
		/* KLUDGE ALERT:  The library want zoom before window! */
		fb_zoom( fbp, width/npts, width/npts );
		fb_window( fbp, npts/2, npts/2 );
@


3.16
log
@Changed to perform RT_HIT_NORM() macros where hit_point and hit_norm
are needed.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.15 86/10/26 17:06:50 mike Locked $ (BRL)";
a239 2
	/* XXX  This should be pushed down into materials routines */
	RT_HIT_NORM( hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );
a242 1
		rt_pr_hit( "colorview", pp->pt_inhit);
a243 10

	/* Temporary check to make sure normals are OK */
	if( hitp->hit_normal[X] < -1.01 || hitp->hit_normal[X] > 1.01 ||
	    hitp->hit_normal[Y] < -1.01 || hitp->hit_normal[Y] > 1.01 ||
	    hitp->hit_normal[Z] < -1.01 || hitp->hit_normal[Z] > 1.01 )  {
		rt_log("colorview: N=(%f,%f,%f)?\n",
			hitp->hit_normal[X],hitp->hit_normal[Y],hitp->hit_normal[Z]);
		VSET( ap->a_color, 1, 1, 0 );
		return(1);
	}
d279 1
a279 1
		if( hitp->hit_dist > 0.0001 )
d283 1
d286 1
a286 1
	/* Check to see if we hit something special */
d296 11
a306 5
	if( pp->pt_inflip )  {
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
		pp->pt_inflip = 0;
	}

@


3.15
log
@Minor improvements to error colors
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.14 86/10/25 12:11:34 mike Locked $ (BRL)";
d109 1
d240 2
@


3.14
log
@Converted to RGBpixel
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.13 86/10/12 00:27:06 mike Locked $ (BRL)";
d265 1
a265 1
		if( rt_g.debug || pp->pt_outhit->hit_dist >= INFINITY ||
d267 5
a271 1
			VSET( ap->a_color, 1, 0, 0 );
@


3.13
log
@Added missing #include
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.12 86/10/12 00:20:59 mike Locked $ (BRL)";
d200 5
a204 5
		Pixel p;
		p.red = r;
		p.green = g;
		p.blue = b;
		fb_write( fbp, ap->a_x, ap->a_y, &p, 1 );
@


3.12
log
@Added color aliasing prevention.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.11 86/10/03 02:26:38 mike Exp $ (BRL)";
d38 1
d45 1
@


3.11
log
@Adapted for new FB library.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.10 86/08/12 05:51:03 mike Exp $ (BRL)";
d183 4
a186 3
	r = ap->a_color[0]*255.;
	g = ap->a_color[1]*255.;
	b = ap->a_color[2]*255.;
@


3.10
log
@Changed to find #include files with CC -I../h
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.9 86/08/06 19:59:09 mike Exp $ (BRL)";
d57 1
a57 1
int fbfd = -1;			/* framebuffer file descriptor */
d196 1
a196 1
	if( fbfd > 0 )  {
d201 1
a201 1
		fbwrite( ap->a_x, ap->a_y, &p, 1 );
d343 2
a344 2
	if( fbfd > 0 )
		fbclose(fbfd);
d367 6
a372 2
		else
			width = 1024;
d374 1
a374 2
		fbsetsize( width );
		if( (fbfd = fbopen( NULL, APPEND )) < 0 )  {
d378 2
a379 2
		fbclear();
		fb_wmap( NULL );
d381 2
a382 2
		fbzoom( width/npts, width/npts );
		fbwindow( npts/2, npts/2 );
@


3.9
log
@Switched to more compact ASCII output format.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.8 86/08/06 05:41:33 mike Exp $ (BRL)";
d38 5
a42 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/mater.h"
#include "../h/raytrace.h"
a43 1
#include "../h/fb.h"
@


3.8
log
@Changed Improved error checking, added ASCII output.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.7 86/07/29 20:22:58 mike Exp $ (BRL)";
d205 1
a205 1
			fprintf(pixfp, "%2.2x %2.2x %2.2x\n", r, g, b);
@


3.7
log
@Moved initialization of materials to rt.c
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.6 86/07/24 06:05:50 mike Exp $ (BRL)";
d62 1
a67 1
static int scanbytes;			/* # bytes in scanline to write */
d204 7
a210 3
		*pixelp++ = r & 0xFF;
		*pixelp++ = g & 0xFF;
		*pixelp++ = b & 0xFF;
d318 1
d321 11
a331 3
		i = fwrite( (char *)scanline, 1, scanbytes, pixfp );
		if( i != scanbytes )  {
			rt_log("view_eol: wrote %d, got %d\n", scanbytes, i);
a360 1
		scanbytes = npts * 3;
@


3.6
log
@Added uvcoord code, conical ray divergance.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.5 86/07/22 03:52:39 mike Exp $ (BRL)";
a298 1
	/* This really needs to be done in prep stage */
d300 2
a301 4
		if( mlib_setup( pp->pt_regionp ) == 0 )  {
			rt_log("mlib_setup failure");
			return(0);
		}
@


3.5
log
@Additional debugging.
Added ability to handle partitions behind the eye.
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.4 86/07/19 04:40:40 mike Exp $ (BRL)";
d170 1
a246 1

d299 1
d394 1
a394 1
		if( (l0stp=rt_find_solid("LIGHT")) != SOLTAB_NULL )  {
@


3.4
log
@cleanup
@
text
@d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.3 86/07/17 18:33:14 mike Exp $ (BRL)";
d93 2
a94 2
	register struct partition *pp = PartHeadp->pt_forw;
	register struct hit *hitp= pp->pt_inhit;
d100 8
d221 2
a222 2
	register struct partition *pp = PartHeadp->pt_forw;
	register struct hit *hitp= pp->pt_inhit;
d224 8
d234 1
a234 1
		rt_pr_hit( "view", pp->pt_inhit);
d247 6
d258 2
a259 1
		if( rt_g.debug || ap->a_level > MAX_BOUNCE )  {
@


3.3
log
@Names shortened for non-FLEXNAMES systems (cray),
and converted to using stdio for all I/O.
@
text
@d2 1
a2 1
 *			V I E W
d4 1
a4 2
 * Ray Tracing program, sample lighting models.  Part of the
 * RT program proper.
d6 1
a6 1
 *  Many varied and wonderous "lighting models" are implemented.
d17 1
a17 1
 *	The incomming light rays point IN.  Thus the sign change.
d33 1
a33 1
static char RCSview[] = "@@(#)$Header: view.c,v 3.2 86/06/17 14:27:14 mike Exp $ (BRL)";
d63 1
a63 1
#define MAX_LINE	1024		/* Max pixels/line */
d204 1
a204 37
	Color pixel based on the energy of a point light source (Eps)
	plus some diffuse illumination (Epd) reflected from the point
	<x,y> :

				E = Epd + Eps		(1)

	The energy reflected from diffuse illumination is the product
	of the reflectance coefficient at point P (Rp) and the diffuse
	illumination (Id) :

				Epd = Rp * Id		(2)

	The energy reflected from the point light source is calculated
	by the sum of the diffuse reflectance (Rd) and the specular
	reflectance (Rs), multiplied by the intensity of the light
	source (Ips) :

				Eps = (Rd + Rs) * Ips	(3)

	The diffuse reflectance is calculated by the product of the
	reflectance coefficient (Rp) and the cosine of the angle of
	incidence (I) :

				Rd = Rp * cos(I)	(4)

	The specular reflectance is calculated by the product of the
	specular reflectance coeffient and (the cosine of the angle (S)
	raised to the nth power) :

				Rs = W(I) * cos(S)**n	(5)

	Where,
		I is the angle of incidence.
		S is the angle between the reflected ray and the observer.
		W returns the specular reflection coefficient as a function
	of the angle of incidence.
		n (roughly 1 to 10) represents the shininess of the surface.
d206 2
a207 24
	This is the heart of the lighting model which is based on a model
	developed by Bui-Tuong Phong, [see Wm M. Newman and R. F. Sproull,
	"Principles of Interactive Computer Graphics", 	McGraw-Hill, 1979]

	Er = Ra(m)*cos(Ia) + Rd(m)*cos(I1) + W(I1,m)*cos(s)^^n
	where,
 
	Er	is the energy reflected in the observer's direction.
	Ra	is the diffuse reflectance coefficient at the point
		of intersection due to ambient lighting.
	Ia	is the angle of incidence associated with the ambient
		light source (angle between ray direction (negated) and
		surface normal).
	Rd	is the diffuse reflectance coefficient at the point
		of intersection due to primary lighting.
	I1	is the angle of incidence associated with the primary
		light source (angle between light source direction and
		surface normal).
	m	is the material identification code.
	W	is the specular reflectance coefficient,
		a function of the angle of incidence, range 0.0 to 1.0,
		for the material.
	s	is the angle between the reflected ray and the observer.
	n	'Shininess' of the material,  range 1 to 10.
d303 4
d330 2
a331 1
		/* Output directly to Ikonas */
d339 1
a339 1
			rt_log("Can't get frame buffer\n");
d351 1
a351 1
 *  			V I E W _ I N I T
a382 1
		/* lightmodel 0 does this in view.c */
@


3.2
log
@Converted to libfb interface.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 3.1 86/06/11 00:14:45 mike Exp $ (BRL)";
d44 1
a44 1
#include "fb.h"				/* /vld/lib/fb.h */
a55 5
 -l#		Select lighting model\n\
 	0	Two lights, one at eye (default)\n\
	1	One light, from eye (diffuse)\n\
	2	Surface-normals as colors\n\
	3	Three light debugging model (diffuse)\n\
d69 1
a69 1
static int pixfd;			/* fd of .pix file */
a84 3
HIDDEN int	rfr_hit(), rfr_miss();
HIDDEN int	refract();

d195 1
a195 1
	if( pixfd > 0 )  {
d314 1
a314 1
		if( hitp->hit_dist > EPSILON )
d336 2
a337 2
		if( matlib_setup( pp->pt_regionp ) == 0 )  {
			rt_log("matlib_setup failure");
a344 103
 *			R F R _ M I S S
 */
HIDDEN int
/*ARGSUSED*/
rfr_miss( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	rt_log("rfr_miss: Refracted ray missed!\n" );
	/* Return entry point as exit point */
	VREVERSE( ap->a_color, ap->a_ray.r_dir );	/* inward pointing */
	VMOVE( ap->a_uvec, ap->a_ray.r_pt );
	return(0);
}

/*
 *			R F R _ H I T
 */
HIDDEN int
rfr_hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	register struct hit	*hitp = PartHeadp->pt_forw->pt_outhit;
	register struct soltab *stp;

	stp = PartHeadp->pt_forw->pt_outseg->seg_stp;
	rt_functab[stp->st_id].ft_norm(
		hitp, stp, &(ap->a_ray) );
	VMOVE( ap->a_uvec, hitp->hit_point );
	/* For refraction, want exit normal to point inward. */
	VREVERSE( ap->a_color, hitp->hit_normal );
	return(1);
}

/*
 *			R E F R A C T
 *
 *	Compute the refracted ray 'v_2' from the incident ray 'v_1' with
 *	the refractive indices 'ri_2' and 'ri_1' respectively.
 *	Using Schnell's Law:
 *
 *		theta_1 = angle of v_1 with surface normal
 *		theta_2 = angle of v_2 with reversed surface normal
 *		ri_1 * sin( theta_1 ) = ri_2 * sin( theta_2 )
 *
 *		sin( theta_2 ) = ri_1/ri_2 * sin( theta_1 )
 *		
 *	The above condition is undefined for ri_1/ri_2 * sin( theta_1 )
 *	being greater than 1, and this represents the condition for total
 *	reflection, the 'critical angle' is the angle theta_1 for which
 *	ri_1/ri_2 * sin( theta_1 ) equals 1.
 *
 *  Returns TRUE if refracted, FALSE if reflected.
 *
 *  Note:  output (v_2) can be same storage as an input.
 */
HIDDEN int
refract( v_1, norml, ri_1, ri_2, v_2 )
register vect_t	v_1;
register vect_t	norml;
double	ri_1, ri_2;
register vect_t	v_2;
{
	LOCAL vect_t	w, u;
	FAST fastf_t	beta;

	if( NEAR_ZERO(ri_1) || NEAR_ZERO( ri_2 ) )  {
		rt_log("refract:ri1=%f, ri2=%f\n", ri_1, ri_2 );
		beta = 1;
	} else {
		beta = ri_1/ri_2;		/* temp */
	}
	VSCALE( w, v_1, beta );
	VCROSS( u, w, norml );
	/*
	 *	|w X norml| = |w||norml| * sin( theta_1 )
	 *	        |u| = ri_1/ri_2 * sin( theta_1 ) = sin( theta_2 )
	 */
	if( (beta = VDOT( u, u )) > 1.0 )  {
		/*  Past critical angle, total reflection.
		 *  Calculate reflected (bounced) incident ray.
		 */
		VREVERSE( u, v_1 );
		beta = 2 * VDOT( u, norml );
		VSCALE( w, norml, beta );
		VSUB2( v_2, w, u );
		return(0);		/* reflected */
	} else {
		/*
		 * 1 - beta = 1 - sin( theta_2 )^^2
		 *	    = cos( theta_2 )^^2.
		 *     beta = -1.0 * cos( theta_2 ) - Dot( w, norml ).
		 */
		beta = -sqrt( 1.0 - beta) - VDOT( w, norml );
		VSCALE( u, norml, beta );
		VADD2( v_2, w, u );
		return(1);		/* refracted */
	}
	/* NOTREACHED */
}

/*
d353 2
a354 2
	if( pixfd > 0 )  {
		i = write( pixfd, (char *)scanline, scanbytes );
d409 1
a409 1
view_2init( ap, outfd )
d411 1
d416 1
a416 1
	pixfd = outfd;
@


3.1
log
@New somewhat object-oriented material-property version
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 3.0 86/06/10 01:32:32 mike Exp $ (BRL)";
d44 1
d63 1
a63 2
extern int ikfd;		/* defined in iklib.o */
extern int ikhires;		/* defined in iklib.o */
d196 7
a202 4
#ifdef vax
	if( ikfd > 0 )
		ikwpixel( ap->a_x, ap->a_y, (b<<16)|(g<<8)|(r) );
#endif
d473 5
a477 1
view_end() {}
d495 1
d497 4
a500 2
		if( npts > 512 )
			ikhires = 1;
d502 4
a505 18
		ikopen();
		load_map(1);		/* Standard map: linear */
		ikclear();
		if( npts <= 32 )  {
			ikzoom( 15, 15 );	/* 1 pixel gives 16 */
			ikwindow( (0)*4, 4063+31 );
		} else if( npts <= 50 )  {
			ikzoom( 9, 9 );		/* 1 pixel gives 10 */
			ikwindow( (0)*4, 4063+31 );
		} else if( npts <= 64 )  {
			ikzoom( 7, 7 );		/* 1 pixel gives 8 */
			ikwindow( (0)*4, 4063+29 );
		} else if( npts <= 128 )  {
			ikzoom( 3, 3 );		/* 1 pixel gives 4 */
			ikwindow( (0)*4, 4063+25 );
		} else if ( npts <= 256 )  {
			ikzoom( 1, 1 );		/* 1 pixel gives 2 */
			ikwindow( (0)*4, 4063+17 );
d507 5
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.13 86/06/09 21:49:50 mike Exp $ (BRL)";
a44 2
#include "mat_db.h"

a92 7
#define RI_AIR		1.0    /* Refractive index of air.		*/
#define RI_GLASS	1.3    /* Refractive index of glass.		*/

#ifdef BENCHMARK
#define rand0to1()	(0.5)
#define rand_half()	(0)
#else BENCHMARK
a93 93
 *  			R A N D 0 T O 1
 *
 *  Returns a random number in the range 0 to 1
 */
double rand0to1()
{
	FAST fastf_t f;
	/* On BSD, might want to use random() */
	/* / (double)0x7FFFFFFFL */
	f = ((double)rand()) *
		0.00000000046566128752457969241057508271679984532147;
	if( f > 1.0 || f < 0 )  {
		rt_log("rand0to1 out of range\n");
		return(0.42);
	}
	return(f);
}

/*
 *  			R A N D _ H A L F
 *
 *  Returns a random number in the range -0.5 to +0.5
 */
#define rand_half()	(rand0to1()-0.5)

#endif BENCHMARK

/*
 *  			I P O W
 *  
 *  Raise a floating point number to an integer power
 */
double
ipow( d, cnt )
double d;
register int cnt;
{
	FAST fastf_t result;

	if( d < 1e-8 )  return(0.0);
	result = 1;
	while( cnt-- > 0 )
		result *= d;
	return( result );
}

/* These shadow functions return a boolean "light_visible" */
light_hit(ap, PartHeadp)
struct application *ap;
struct partition *PartHeadp;
{
	/* Check to see if we hit the light source */
	if( PartHeadp->pt_forw->pt_inseg->seg_stp == l0stp )
		return(1);		/* light_visible = 1 */
	return(0);			/* light_visible = 0 */
}

/*
 *  			L I G H T _ M I S S
 *  
 *  If there is no explicit light solid in the model, we will always "miss"
 *  the light, so return light_visible = TRUE.
 */
/* ARGSUSED */
light_miss(ap, PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	return(1);			/* light_visible = 1 */
}

/* Null function */
nullf() { ; }

/*
 *			H I T _ N O T H I N G
 *
 *  a_miss() routine called when no part of the model is hit.
 *  Background texture mapping could be done here.
 *  For now, return a pleasant dark blue.
 */
hit_nothing( ap )
register struct application *ap;
{
	if( lightmodel == 2 )  {
		VSET( ap->a_color, 0, 0, 0 );
	}  else  {
		VSET( ap->a_color, .25, 0, .5 );	/* Background */
	}
	return(0);
}

/*
a278 12
	auto struct application sub_ap;
	auto int light_visible;
	auto fastf_t	Rd1;
	auto fastf_t	d_a;		/* ambient diffuse */
	auto double	cosI1, cosI2;
	auto fastf_t	f;
	auto vect_t	work;
	auto vect_t	reflected;
	auto vect_t	to_eye;
	auto vect_t	to_light;
	auto point_t	mcolor;		/* Material color */
	Mat_Db_Entry	*entry = &mat_dfl_entry;
d292 1
a292 1
		goto finish;
d297 3
d305 1
a305 1
			goto finish;
d314 1
a314 1
		goto finish;
d328 1
a328 2
		register char *cp;
		cp = (stp = pp->pt_inseg->seg_stp)->st_name;
d331 1
a331 1
			goto finish;
a332 31
		/* Clouds "Texture" map */
		if( *cp == 'C' && strncmp( cp, "CLOUD", 5 )==0 )  {
			auto fastf_t uv[2];
			double inten;
			extern double texture();
			rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
				pp->pt_inseg->seg_stp, hitp, uv );
			inten = texture( uv[0], uv[1], 1.0, 2.0, 1.0 );
			skycolor( inten, ap->a_color, 0.35, 0.3 );
			goto finish;
		}
		/* "Texture" map from file */
		if( *cp == 'T' && strncmp( cp, "TEXT", 4 )==0 )  {
			auto fastf_t uv[2];
			register unsigned char *cp;
			extern unsigned char *text_uvget();
			rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
				pp->pt_inseg->seg_stp, hitp, uv );
			cp = text_uvget( 0, uv );	/* tp hack */
			VSET( mcolor, *cp++/255., *cp++/255., *cp++/255.);
			goto colorit;
		}
		/* Debug map */
		if( *cp == 'M' && strncmp( cp, "MAP", 3 )==0 )  {
			auto fastf_t uv[2];
			rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
				pp->pt_inseg->seg_stp, hitp, uv );
			if(rt_g.debug&DEBUG_HITS) rt_log("uv=%f,%f\n", uv[0], uv[1]);
			VSET( ap->a_color, uv[0], 0, uv[1] );
			goto finish;
		}
a334 22
	/* Try to look up material in Moss's database */
	if( (entry = mat_Get_Db_Entry(pp->pt_regionp->reg_material))==MAT_DB_NULL
	    || !(entry->mode_flag&MF_USED) )
		entry = &mat_dfl_entry;
	else  {
		VSET( mcolor, entry->df_rgb[0]/255., entry->df_rgb[1]/255., entry->df_rgb[2]/255.);
		goto colorit;
	}

	/* Get default color-by-ident for region.			*/
	{
		register struct mater *mp;
		if( pp->pt_regionp == REGION_NULL )  {
			rt_log("bad region pointer\n");
			VSET( ap->a_color, 0.7, 0.7, 0.7 );
			goto finish;
		}
		mp = (struct mater *)pp->pt_regionp->reg_materp;
		VSET( mcolor, mp->mt_r/255., mp->mt_g/255., mp->mt_b/255.);
	}
colorit:

d337 1
a338 1
	VREVERSE( to_eye, ap->a_ray.r_dir );
d340 4
a343 14
	/* Diminish intensity of reflected light the as a function of
	 * the distance from your eye.
	 */
/**	dist_gradient = kCons / (hitp->hit_dist + cCons);  */

	/* Diffuse reflectance from primary light source. */
	VSUB2( to_light, l0pos, hitp->hit_point );
	VUNITIZE( to_light );
	Rd1 = 0;
	if( (cosI1 = VDOT( hitp->hit_normal, to_light )) > 0.0 )  {
		if( cosI1 > 1 )  {
			rt_log("cosI1=%f (x%d,y%d,lvl%d)\n", cosI1,
				ap->a_x, ap->a_y, ap->a_level);
			cosI1 = 1;
a344 1
		Rd1 = cosI1 * (1 - AmbientIntensity);
d346 1
a346 156

	/* Diffuse reflectance from secondary light source (at eye) */
	d_a = 0;
	if( (cosI2 = VDOT( hitp->hit_normal, to_eye )) > 0.0 )  {
		if( cosI2 > 1 )  {
			rt_log("cosI2=%f (x%d,y%d,lvl%d)\n", cosI2,
				ap->a_x, ap->a_y, ap->a_level);
			cosI2 = 1;
		}
		d_a = cosI2 * AmbientIntensity;
	}

	/* Apply secondary (ambient) (white) lighting. */
	VSCALE( ap->a_color, mcolor, d_a );
	if( l0stp )  {
		/* An actual light solid exists */
		FAST fastf_t f;

		/* Fire ray at light source to check for shadowing */
		/* This SHOULD actually return an energy value */
		sub_ap.a_hit = light_hit;
		sub_ap.a_miss = light_miss;
		sub_ap.a_onehit = 1;
		sub_ap.a_level = ap->a_level + 1;
		sub_ap.a_x = ap->a_x;
		sub_ap.a_y = ap->a_y;
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );

		/* Dither light pos for penumbra by +/- 0.5 light radius */
		f = l0stp->st_aradius * 0.9;
		sub_ap.a_ray.r_dir[X] =  l0pos[X] + rand_half()*f - hitp->hit_point[X];
		sub_ap.a_ray.r_dir[Y] =  l0pos[Y] + rand_half()*f - hitp->hit_point[Y];
		sub_ap.a_ray.r_dir[Z] =  l0pos[Z] + rand_half()*f - hitp->hit_point[Z];
		VUNITIZE( sub_ap.a_ray.r_dir );
		light_visible = rt_shootray( &sub_ap );
	} else {
		light_visible = 1;
	}
	
	/* If not shadowed add primary lighting. */
	if( light_visible )  {
		auto fastf_t specular;
		auto fastf_t cosS;

		/* Diffuse */
		VJOIN1( ap->a_color, ap->a_color, Rd1, mcolor );

		/* Calculate specular reflectance.
		 *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
		 * 	Cos(s) = Reflected ray DOT Incident ray.
		 */
		cosI1 *= 2;
		VSCALE( work, hitp->hit_normal, cosI1 );
		VSUB2( reflected, work, to_light );
		if( (cosS = VDOT( reflected, to_eye )) > 0 )  {
			if( cosS > 1 )  {
				rt_log("cosS=%f (x%d,y%d,lvl%d)\n", cosS,
					ap->a_x, ap->a_y, ap->a_level);
				cosS = 1;
			}
			specular = entry->wgt_specular *
				ipow(cosS,(int)entry->shine);
			VJOIN1( ap->a_color, ap->a_color, specular, l0color );
		}
	}

	if( (entry->transmission <= 0 && entry->transparency <= 0) ||
	    ap->a_level > MAX_BOUNCE )  {
		if( rt_g.debug&DEBUG_RAYWRITE )  {
			register struct soltab *stp;
			/* Record passing through the solid */
			stp = pp->pt_outseg->seg_stp;
			rt_functab[stp->st_id].ft_norm(
				pp->pt_outhit, stp, &(ap->a_ray) );
			wray( pp, ap, stdout );
		}
		/* Nothing more to do for this ray */
		goto finish;
	}

	/* Add in contributions from mirror reflection & transparency */
	f = 1 - (entry->transmission + entry->transparency);
	VSCALE( ap->a_color, ap->a_color, f );
	if( entry->transmission > 0 )  {
		/* Mirror reflection */
		sub_ap.a_level = ap->a_level+1;
		sub_ap.a_hit = colorview;
		sub_ap.a_miss = hit_nothing;
		sub_ap.a_onehit = 1;
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
		f = 2 * VDOT( to_eye, hitp->hit_normal );
		VSCALE( work, hitp->hit_normal, f );
		/* I have been told this has unit length */
		VSUB2( sub_ap.a_ray.r_dir, work, to_eye );
		(void)rt_shootray( &sub_ap );
		VJOIN1( ap->a_color, ap->a_color,
			entry->transmission, sub_ap.a_color );
	}
	if( entry->transparency > 0 )  {
		/* Calculate refraction at entrance. */
		sub_ap.a_level = ap->a_level * 100;	/* flag */
		sub_ap.a_x = ap->a_x;
		sub_ap.a_y = ap->a_y;
		if( !refract(ap->a_ray.r_dir, /* Incident ray (IN) */
			hitp->hit_normal,
			RI_AIR, entry->refrac_index,
			sub_ap.a_ray.r_dir	/* Refracted ray (OUT) */
		) )  {
			/* Reflected back outside solid */
			VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
			goto do_exit;
		}
		/* Find new exit point from the inside. */
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
do_inside:
		sub_ap.a_hit =  rfr_hit;
		sub_ap.a_miss = rfr_miss;
		(void) rt_shootray( &sub_ap );
		/* NOTE: rfr_hit returns EXIT point in sub_ap.a_uvec,
		 *  and returns EXIT normal in sub_ap.a_color.
		 */
		if( rt_g.debug&DEBUG_RAYWRITE )  {
			wraypts( sub_ap.a_ray.r_pt, sub_ap.a_uvec,
				ap, stdout );
		}
		VMOVE( sub_ap.a_ray.r_pt, sub_ap.a_uvec );

		/* Calculate refraction at exit. */
		if( !refract( sub_ap.a_ray.r_dir,	/* input direction */
			sub_ap.a_color,			/* exit normal */
			entry->refrac_index, RI_AIR,
			sub_ap.a_ray.r_dir		/* output direction */
		) )  {
			/* Reflected internally -- keep going */
			if( ++sub_ap.a_level > 100+MAX_IREFLECT )  {
				rt_log("Excessive internal reflection (x%d,y%d, lvl%d)\n",
					sub_ap.a_x, sub_ap.a_y, sub_ap.a_level );
				if(rt_g.debug) {
					VSET( ap->a_color, 0, 1, 0 );	/* green */
				} else {
					VSET( ap->a_color, .16, .16, .16 );	/* grey */
				}
				goto finish;
			}
			goto do_inside;
		}
do_exit:
		sub_ap.a_hit =  colorview;
		sub_ap.a_miss = hit_nothing;
		sub_ap.a_level++;
		(void) rt_shootray( &sub_ap );
		VJOIN1( ap->a_color, ap->a_color,
			entry->transparency, sub_ap.a_color );
	}
finish:
	return(1);
a511 6

	/* Moss's material database hooks */
	if( mat_Open_Db( "mat.db" ) != NULL )  {
		mat_Asc_Read_Db();
		mat_Close_Db();
	}
d522 1
@


2.13
log
@rt and librt separated
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.12 86/03/14 21:06:30 mike Exp $ (BRL)";
d115 1
a115 1
		rtlog("rand0to1 out of range\n");
d268 3
a270 3
	if(debug&DEBUG_HITS)  {
		pr_hit( " In", hitp );
		rtlog("cosI0=%f, diffuse0=%f   ", cosI0, diffuse0 );
d307 1
a307 1
	if(debug&DEBUG_HITS) rtlog("rgb=%3d,%3d,%3d\n", r,g,b);
d394 3
a396 3
	if(debug&DEBUG_HITS)  {
		pr_pt(pp);
		pr_hit( "view", pp->pt_inhit);
d403 1
a403 1
		rtlog("colorview: N=(%f,%f,%f)?\n",
d411 1
a411 1
		if( debug || ap->a_level > MAX_BOUNCE )  {
d413 1
a413 1
			rtlog("colorview:  eye inside %s (x=%d, y=%d, lvl=%d)\n",
d423 1
a423 1
		(void)shootray( &sub_ap );
d428 1
a428 1
	if( debug&DEBUG_RAYWRITE )  {
d450 1
a450 1
			functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
d461 1
a461 1
			functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
d470 1
a470 1
			functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
d472 1
a472 1
			if(debug&DEBUG_HITS) rtlog("uv=%f,%f\n", uv[0], uv[1]);
d491 1
a491 1
			rtlog("bad region pointer\n");
d516 1
a516 1
			rtlog("cosI1=%f (x%d,y%d,lvl%d)\n", cosI1,
d527 1
a527 1
			rtlog("cosI2=%f (x%d,y%d,lvl%d)\n", cosI2,
d556 1
a556 1
		light_visible = shootray( &sub_ap );
d578 1
a578 1
				rtlog("cosS=%f (x%d,y%d,lvl%d)\n", cosS,
d590 1
a590 1
		if( debug&DEBUG_RAYWRITE )  {
d594 1
a594 1
			functab[stp->st_id].ft_norm(
d616 1
a616 1
		(void)shootray( &sub_ap );
d639 1
a639 1
		(void) shootray( &sub_ap );
d643 1
a643 1
		if( debug&DEBUG_RAYWRITE )  {
d657 1
a657 1
				rtlog("Excessive internal reflection (x%d,y%d, lvl%d)\n",
d659 1
a659 1
				if(debug) {
d672 1
a672 1
		(void) shootray( &sub_ap );
d689 1
a689 1
	rtlog("rfr_miss: Refracted ray missed!\n" );
d708 1
a708 1
	functab[stp->st_id].ft_norm(
d749 1
a749 1
		rtlog("refract:ri1=%f, ri2=%f\n", ri_1, ri_2 );
d795 2
a796 2
			rtlog("view_eol: wrote %d, got %d\n", scanbytes, i);
			rtbomb("write error");
d811 1
a811 1
		rtlog("view:  %d pixels/line > %d\n", npts, MAX_LINE);
d869 1
a869 1
		if( (l0stp=find_solid("LIGHT")) != SOLTAB_NULL )  {
d874 1
a874 1
		if(debug)rtlog("No explicit light\n");
d900 1
a900 1
		rtbomb("bad lighting model #");
@


2.12
log
@Improved internal reflection.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.11 86/02/18 16:21:43 mike Exp $ (BRL)";
d42 2
a43 2
#include "raytrace.h"
#include "debug.h"
@


2.11
log
@Increased internal reflection to 6 levels.
It seems to happen at tangents only.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.10 86/01/24 11:46:50 mike Exp $ (BRL)";
d89 2
a90 2
#define MAX_IREFLECT	6	/* Maximum internal reflection level */
#define MAX_BOUNCE	3	/* Maximum recursion level */
d659 5
a663 1
				VSET( ap->a_color, 0, 1, 0 );	/* green */
@


2.10
log
@Added #ifdef vax around ikwpixel.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.9 86/01/23 13:29:48 mike Exp $ (BRL)";
d89 1
a89 1
#define MAX_IREFLECT	3	/* Maximum internal reflection level */
d870 1
a870 1
		rtlog("No explicit light\n");
@


2.9
log
@Added conditional BENCHMARK to turn off penumbra, etc.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.8 85/09/15 09:18:28 mike Exp $ (BRL)";
d298 1
d301 1
@


2.8
log
@Modified handling of "-o" so that each frame of a multi-frame
sequence is stored in a separate file.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.7 85/09/14 07:09:56 mike Exp $ (BRL)";
d98 4
d128 1
@


2.7
log
@Improved handling of eye-inside-solid condition,
plus some more (temporary) error checking.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.6 85/09/12 23:05:59 mike Exp $ (BRL)";
d795 1
a795 1
view_init( ap, file, obj, npts, outfd )
a798 1
	pixfd = outfd;
d800 1
a800 1
		rtlog("view:  %d pixels/line is too many\n", npts);
d803 1
a803 1
	if( pixfd > 0 )  {
d845 1
a845 1
view_2init( ap )
d850 1
@


2.6
log
@bullet-proofed ipow().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.5 85/09/11 23:53:16 mike Exp $ (BRL)";
d392 10
d404 14
a417 4
		VSET( ap->a_color, 1, 0, 0 );
		rtlog("colorview:  eye inside %s (x=%d, y=%d, lvl=%d)\n",
			pp->pt_inseg->seg_stp->st_name,
			ap->a_x, ap->a_y, ap->a_level);
d507 6
a512 1
	if( (cosI1 = VDOT( hitp->hit_normal, to_light )) > 0.0 )
d514 1
d518 6
a523 1
	if( (cosI2 = VDOT( hitp->hit_normal, to_eye )) > 0.0 )
d525 1
a528 10

	/* Fire ray at light source to check for shadowing */
	/* This SHOULD actually return an energy value */
	sub_ap.a_hit = light_hit;
	sub_ap.a_miss = light_miss;
	sub_ap.a_onehit = 1;
	sub_ap.a_level = ap->a_level + 1;
	sub_ap.a_x = ap->a_x;
	sub_ap.a_y = ap->a_y;
	VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
d531 12
a543 1
		FAST fastf_t f;
d556 2
a557 2
		register fastf_t specular;
		register fastf_t cosS;
@


2.5
log
@Improved to better handle case of no explicit light.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.4 85/09/09 23:42:46 mike Exp $ (BRL)";
d137 1
d537 5
@


2.4
log
@Shortened usage message, switched to rand() for portability.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.3 85/09/06 02:31:20 mike Exp $ (BRL)";
d507 1
d514 2
d517 1
a517 1
		VSUB2( sub_ap.a_ray.r_dir, l0pos, hitp->hit_point );
a518 2
	VUNITIZE( sub_ap.a_ray.r_dir );
	light_visible = shootray( &sub_ap );
d741 1
d743 5
a747 2
		write( pixfd, (char *)scanline, scanbytes );
		bzero( (char *)scanline, scanbytes );
@


2.3
log
@Minor housekeeping, added Ambient light factor to colorview().
@
text
@d8 1
a8 1
 *  The output format is a .PIX file
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.2 85/09/05 02:23:48 mike Exp $ (BRL)";
d51 4
a54 4
 -aAz		Azimuth in degrees	(conflicts with -M)\n\
 -eElev		Elevation in degrees	(conflicts with -M)\n\
 -M		Read model2view matrix on stdin (conflicts with -a, -e)\n\
 -o model.pix	Specify output file, .pix format (default=framebuffer)\n\
d59 1
a59 1
	1	One light, from eye\n\
d61 1
a61 1
	3	Three light debugging model\n\
d106 4
a109 1
	f = ((double)random()) / (double)017777777777L;
@


2.2
log
@Added ray writing capability, improved refraction code.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 2.1 85/08/31 06:08:12 mike Exp $ (BRL)";
a363 16

/*	d i f f R e f l e c ( )
 *	Return the diffuse reflectance from 'light' source.
 */
double
diffReflec( norml, light, illum, cosI )
double	*norml, *light;
double	illum;
double	*cosI;	/* Cosine of the angle of incidence */
{
	if( (*cosI = VDOT( norml, light )) < 0.0 ) {
		return	0.0;
	} else
		return	*cosI * illum;
}

d411 1
a411 1
			VSET( ap->a_color, 1, 1, 1 );	/* White */
d421 1
a421 1
			inten = texture( uv[0], uv[1], 1.0, 2.2, 1.0 );
d482 3
a484 2
#define illum_pri_src	0.7
	Rd1 = diffReflec( hitp->hit_normal, to_light, illum_pri_src, &cosI1 );
d487 3
a489 2
#define illum_sec_src	0.4
	d_a = diffReflec( hitp->hit_normal, to_eye, illum_sec_src, &cosI2 );
@


2.1
log
@Version 2 of RT
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.26 85/07/30 05:56:34 mike Exp $ (BRL)";
d56 1
a56 1
 -p[#]		Perspective viewing, optional focal length scaling\n\
d89 3
d93 1
a93 1
HIDDEN void	refract();
d141 1
a141 1
func_hit(ap, PartHeadp)
a144 3
	register struct soltab *stp;
	register char *cp;

d146 1
a146 1
	if( (stp = PartHeadp->pt_forw->pt_inseg->seg_stp) == l0stp )
a147 4
	if( *(cp=stp->st_name) == 'L' && strncmp( cp, "LIGHT", 5 )==0 )  {
		l0stp = stp;
		return(1);		/* light_visible = 1 */
	}
a149 1
func_miss() {return(1);}
d151 14
d300 1
a300 1
/*	l g t _ P i x e l ( )
d338 4
d343 20
d395 1
d397 1
a397 1
	Mat_Db_Entry	*entry;
d413 8
d426 1
a426 3
		if( stp == l0stp ||
		    (*cp == 'L'  &&  strncmp( cp, "LIGHT", 5 )==0 ) )  {
			l0stp = stp;
d496 2
a497 2
	VSUB2( l0vec, l0pos, hitp->hit_point );
	VUNITIZE( l0vec );
d499 1
a499 1
	Rd1 = diffReflec( hitp->hit_normal, l0vec, illum_pri_src, &cosI1 );
d502 1
a502 1
#define illum_sec_src	0.5
d510 2
a511 2
	sub_ap.a_hit = func_hit;
	sub_ap.a_miss = func_miss;
d544 1
a544 1
		VSUB2( reflected, work, l0vec );
d553 9
a561 1
	    ap->a_level > 3 )  {
d570 1
d586 4
a589 1
		refract(ap->a_ray.r_dir, /* Incident ray.*/
d591 10
a600 5
			RI_AIR,		/* Ref. index of air.*/
			entry->refrac_index,
			sub_ap.a_ray.r_dir	/* Refracted ray. */
			);
		/* Find new exit point. */
a602 2
		sub_ap.a_level = ap->a_level + 1;
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
d604 8
a611 2
		/* HACK:  modifies sub_ap.a_ray.r_pt to be EXIT point! */
		/* returns EXIT normal in sub_ap.a_color, leaves r_dir */
d614 15
a628 6
		refract( sub_ap.a_ray.r_dir,	/* input direction */
			sub_ap.a_color,		/* exit normal */
			entry->refrac_index,
			RI_AIR,
			sub_ap.a_ray.r_dir	/* output direction */
			);
d631 1
a631 1
		sub_ap.a_level = ap->a_level + 1;
d640 2
a641 1
/*	d o _ E r r o r ( )
a648 2
	static int	ref_missed = 0;

d650 1
a650 1
	/* Return entry point as exit point in a_ray.r_pt */
d652 1
d656 2
a657 1
/*	d o _ P r o b e ( )
a659 1
/*ARGSUSED*/
d665 1
d667 4
a670 1
	VMOVE( ap->a_ray.r_pt, hitp->hit_point );
d673 1
a673 1
	return	1;
d676 2
a677 1
/*	r e f r a c t ( )
d681 1
d683 13
d698 1
a698 1
HIDDEN void
d708 6
a713 1
	beta = ri_1/ri_2;		/* temp */
d716 4
d728 1
a728 1
		return;
d730 5
d738 1
d740 1
d825 2
a826 2
		if( solid_pos( "LIGHT", l0pos ) >= 0 )  {
			/* NEED A WAY TO FIND l0stp here! */
@


1.26
log
@Changes for merged GED & RT vmath.h
@
text
@d8 2
a9 1
 *  The notion of output format is randomly mixed in as well.
d14 1
a14 3
 *	3	GIFT format .PP (pretty picture) files
 *	4	Gwyn format ray files
 *	5	3-light debugging model
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.25 85/06/05 15:44:03 mike Exp $ (BRL)";
d38 1
d45 1
a45 18
/* /vld/include/ray.h -- ray segment data format (D A Gwyn) */
/* binary ray segment data record; see ray(4V) */
struct vldray  {
	float	ox;			/* origin coordinates */
	float	oy;
	float	oz;
	float	rx;			/* ray vector */
	float	ry;
	float	rz;
	float	na;			/* origin surface normal */
	float	ne;
	/* the following are in 2 pieces for binary file portability: */
	short	ob_lo;			/* object code low 16 bits */
	short	ob_hi;			/* object code high 16 bits */
	short	rt_lo;			/* ray tag low 16 bits */
	short	rt_hi;			/* ray tag high 16 bits */
};
static struct vldray vldray;
d47 17
a66 2
extern int outfd;		/* defined in rt.c */
extern FILE *outfp;		/* defined in rt.c */
d68 2
a69 1
extern int one_hit_flag;
d76 1
d78 10
a87 6
/* Stuff for pretty-picture output format */
static struct soltab *last_solidp;	/* pointer to last solid hit */
static int last_item;			/* item number of last region hit */
static int last_ihigh;			/* last inten_high */
static int ntomiss;			/* number of pixels to miss */
static int col;				/* column; for PP 75 char/line crap */
d89 2
a90 2
#define BACKGROUND	0x00800040		/* Blue/Green */
#define GREY_BACKGROUND	0x00404040		/* Grey */
d92 2
a93 9
vect_t l0color = {  28,  28, 255 };		/* R, G, B */
vect_t l1color = { 255,  28,  28 };
vect_t l2color = { 255, 255, 255 };		/* White */
vect_t ambient_color = { 255, 255, 255 };	/* Ambient white light */
extern vect_t l0vec;
extern vect_t l1vec;
extern vect_t l2vec;
extern vect_t l0pos;			/* pos of light0 (overrides l0vec) */
extern double AmbientIntensity;
d95 42
d142 2
a143 1
	register struct partition *pp = PartHeadp->pt_forw;
d146 1
a146 1
	if( strncmp( pp->pt_inseg->seg_stp->st_name, "LIGHT", 5 )==0 )
d148 5
a152 1
	return(0);	/* light_visible = 0 */
d159 8
a166 1
l3init(ap, title1, title2 )
d169 4
a172 28
	extern double azimuth, elevation;
	extern int npts;

	fprintf(outfp, "%s: %s (RT)\n", title1, title2 );
	fprintf(outfp, "%10d%10d", (int)azimuth, (int)elevation );
	fprintf(outfp, "%10d%10d\n", npts, npts );
}

/* Support for Gwyn's ray files -- write a hit */
l4hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	register struct partition *pp = PartHeadp->pt_forw;
	register int i;	/* XXX */

	for( ; pp != PartHeadp; pp = pp->pt_forw )  {
		VMOVE( &(vldray.ox), pp->pt_inhit->hit_point );
		VSUB2( &(vldray.rx), pp->pt_outhit->hit_point,
			pp->pt_inhit->hit_point );
		/* Check pt_inflip, pt_outflip for normals! */
		vldray.na = vldray.ne = 0.0;	/* need angle/azim */
		i = pp->pt_regionp->reg_regionid;
		vldray.ob_lo = i & 0xFFFF;
		vldray.ob_hi = (i>>16) & 0xFFFF;
		vldray.rt_lo = ap->a_x;
		vldray.rt_hi = ap->a_y;
		fwrite( &vldray, sizeof(struct vldray), 1, outfp );
d174 1
a176 45
/* Support for pretty-picture files */
l3hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	register struct partition *pp = PartHeadp->pt_forw;
	register struct hit *hitp= pp->pt_inhit;
	LOCAL double cosI0;
	register int i,j;

#define pchar(c) {putc(c,outfp);if(col++==74){putc('\n',outfp);col=0;}}

	cosI0 = -VDOT(hitp->hit_normal, ap->a_ray.r_dir);
	if( pp->pt_inflip )
		cosI0 = -cosI0;
	if( cosI0 <= 0.0 )  {
		ntomiss++;
		return;
	}
	if( ntomiss > 0 )  {
		pchar(' ');	/* miss target cmd */
		pknum( ntomiss );
		ntomiss = 0;
		last_solidp = SOLTAB_NULL;
	}
	if( last_item != pp->pt_regionp->reg_regionid )  {
		last_item = pp->pt_regionp->reg_regionid;
		pchar( '#' );	/* new item cmd */
		pknum( last_item );
		last_solidp = SOLTAB_NULL;
	}
	if( last_solidp != pp->pt_inseg->seg_stp )  {
		last_solidp = pp->pt_inseg->seg_stp;
		pchar( '!' );		/* new solid cmd */
	}
	i = cosI0 * 255.0;		/* integer angle */
	j = (i>>5) & 07;
	if( j != last_ihigh )  {
		last_ihigh = j;
		pchar( '0'+j );		/* new inten high */
	}
	j = i & 037;
	pchar( '@@'+j );			/* low bits of pixel */
}

a191 1
	LOCAL int r,g,b;
d208 2
a209 2
		VADD2( work0, work0, work1 );
	}  else if( lightmodel == 5 )  {
d240 3
a242 2
		VADD2( work0, work0, work1 );
	} else if( lightmodel == 2 )  {
d245 3
a247 3
		work0[0] = (hitp->hit_normal[0] * (-127)) + 128;
		work0[1] = (hitp->hit_normal[1] * (-127)) + 128;
		work0[2] = (hitp->hit_normal[2] * (-127)) + 128;
d251 3
a253 3
		hit_print( " In", hitp );
		fprintf(stderr,"cosI0=%f, diffuse0=%f   ", cosI0, diffuse0 );
		VPRINT("RGB", work0);
d255 1
d257 13
a269 3
	r = work0[0];
	g = work0[1];
	b = work0[2];
d274 1
a274 1
		VPRINT("@@@@ Negative RGB @@@@", work0);
d282 1
a282 1
	if( outfd > 0 )  {
d287 1
d353 11
a363 3
	LOCAL struct application shadow_ap;
	LOCAL int r,g,b;
	LOCAL int light_visible;
d365 4
a368 8
	double	Rd1, Rd2;
	double	cosI1, cosI2;
	double	cosS;
	vect_t	work;
	double	dist_gradient = 1.0;
	int	red, grn, blu;
	LOCAL vect_t	reflected;
	LOCAL vect_t	to_eye;
a369 5
	/* Check to see if we hit the light source */
	if( strncmp( pp->pt_inseg->seg_stp->st_name, "LIGHT", 5 )==0 )  {
		r = g = b = 0xFF;	/* White */
		goto done;
	}
d372 5
a376 4
		r = 0xFF;
		g = b = 0;
		fprintf(stderr,"colorview:  eye inside solid\n");
		goto done;
d379 66
d458 1
a458 1
#define illum_pri_src	0.6
a459 1
	Rd1 *= dist_gradient;
d462 2
a463 3
#define illum_sec_src	0.4
	Rd2 = diffReflec( hitp->hit_normal, to_eye, illum_sec_src, &cosI2 );
	Rd2 *= dist_gradient;
a464 17
	/* Calculate specular reflectance.
	 *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
	 * 	Cos(s) = dot product of Reflected ray with Shotline vector.
	 */
	VSCALE( work, hitp->hit_normal, 2 * cosI1 );
	VSUB2( reflected, work, l0vec );
	cosS = VDOT( reflected, to_eye );

	/* Get default color-by-ident for region.			*/
	{
		register struct mater *mp;
		mp = ((struct mater *)pp->pt_inseg->seg_tp->tr_materp);
		red = mp->mt_r;
		grn = mp->mt_g;
		blu = mp->mt_b;
	}

d466 1
a466 3
	r = (double) red * Rd2;
	g = (double) grn * Rd2;
	b = (double) blu * Rd2;
d469 20
a488 6
	shadow_ap.a_hit = func_hit;
	shadow_ap.a_miss = func_miss;
	VMOVE( shadow_ap.a_ray.r_pt, hitp->hit_point );
	VSUB2( shadow_ap.a_ray.r_dir, l0pos, hitp->hit_point );
	VUNITIZE( shadow_ap.a_ray.r_dir );
	light_visible = shootray( &shadow_ap );
d490 1
a490 4
	/* If not shadowed add primary lighting.			*/
#define lgt1_red_coef	1
#define lgt1_grn_coef	1
#define lgt1_blu_coef	1
d492 2
a493 3
		red = r + (int)((double)red * Rd1 * lgt1_red_coef);
		grn = g + (int)((double)grn * Rd1 * lgt1_grn_coef);
		blu = b + (int)((double)blu * Rd1 * lgt1_blu_coef);
d495 2
a496 5
		/* Check for specular reflection. */
#define cosSRAngle 0.9
		if( cosS >= cosSRAngle )  {
			/* We have a specular return.	*/
			double	spec_intensity = 0.0;
d498 11
a508 9
			if( cosSRAngle < 1.0 )	{
				spec_intensity = (cosS-cosSRAngle)/(1.0-cosSRAngle);
			}
#define redSpecComponent 255
#define grnSpecComponent 255
#define bluSpecComponent 255
			red += ((redSpecComponent-red) * spec_intensity);
			grn += ((grnSpecComponent-grn) * spec_intensity);
			blu += ((bluSpecComponent-blu) * spec_intensity);
a509 3
		r = red;
		g = grn;
		b = blu;
d512 4
a515 8
	if( r > 255 ) r = 255;
	if( g > 255 ) g = 255;
	if( b > 255 ) b = 255;
	if( r<0 || g<0 || b<0 )  {
		fprintf(stderr,"colorview: negative RGB\n");
		r = 0x80;
		g = 0xFF;
		b = 0x80;
d517 17
a533 7
done:
	if( ikfd > 0 )
		ikwpixel( ap->a_x, ap->a_y, (b<<16)|(g<<8)|(r) );
	if( outfd > 0 )  {
		*pixelp++ = r & 0xFF;
		*pixelp++ = g & 0xFF;
		*pixelp++ = b & 0xFF;
d535 33
d570 14
a583 3
l3miss()  {
	last_solidp = SOLTAB_NULL;
	ntomiss++;
d586 1
a586 4
/*
 *			W B A C K G R O U N D
 *
 *  a_miss() routine.
d588 3
a590 1
wbackground( ap )
d592 1
d594 1
a594 1
	register long bg;
d596 39
a634 11
	if( lightmodel == 2 )
		bg = 0;
	else
		bg = BACKGROUND;
		
	if( ikfd > 0 )
		ikwpixel( ap->a_x, ap->a_y, bg );
	if( outfd > 0 )  {
		*pixelp++ = bg & 0xFF;		/* R */
		*pixelp++ = (bg>>8) & 0xFF;	/* G */
		*pixelp++ = (bg>>16) & 0xFF;	/* B */
d639 4
a642 1
 *  			H I T _ P R I N T
d644 1
a644 3
hit_print( str, hitp )
char *str;
register struct hit *hitp;
d646 5
a650 3
	fprintf(stderr,"** %s HIT, dist=%f\n", str, hitp->hit_dist );
	VPRINT("** Point ", hitp->hit_point );
	VPRINT("** Normal", hitp->hit_normal );
d652 1
d655 1
a655 4
 *  			D E V _ S E T U P
 *  
 *  Prepare the Ikonas display for operation with
 *  npts x npts of useful pixels.
d657 3
a659 2
dev_setup(n)
int n;
d661 3
a663 2
	if( n > MAX_LINE )  {
		fprintf(stderr,"view:  %d pixels/line is too many\n", n);
d666 1
a666 1
	if( outfd > 0 )  {
d669 1
a669 4
		if( n > 512 )
			scanbytes = MAX_LINE * 3;
		else
			scanbytes = 512 * 3;
d672 1
a672 1
		if( n > 512 )
d678 7
a684 1
		if( n <= 64 )  {
d687 1
a687 1
		} else if( n <= 128 )  {
d690 1
a690 1
		} else if ( n <= 256 )  {
a694 1
}
d696 4
a699 19
l3eol()
{
		pchar( '.' );		/* End of scanline */
		last_solidp = SOLTAB_NULL;
		ntomiss = 0;
}

/*
 *  			D E V _ E O L
 *  
 *  This routine is called by main when the end of a scanline is
 *  reached.
 */
dev_eol()
{
	if( outfd > 0 )  {
		write( outfd, (char *)scanline, scanbytes );
		bzero( (char *)scanline, scanbytes );
		pixelp = &scanline[0];
a703 27
 *  Called when the picture is finally done.
 */
l3end()
{
	fprintf( outfp, "/\n" );	/* end of view */
	fflush( outfp );
}

/*
 *  			P K N U M
 *  
 *  Oddball 5-bits in a char ('@@', 'A', ... on up) number packing.
 *  Number is written 5 bits at a time, right to left (low to high)
 *  until there are no more non-zero bits remaining.
 */
pknum( arg )
int arg;
{
	register long i = arg;

	do {
		pchar( (int)('@@'+(i & 037)) );
		i >>= 5;
	} while( i > 0 );
}

/*
d705 2
d708 1
a708 1
view_init( ap )
d711 1
a711 1
	struct soltab *stp;
d713 2
a714 3
	/* Initialize the application selected */
	ap->a_hit = ap->a_miss = nullf;	/* ?? */
	ap->a_init = ap->a_eol = ap->a_end = nullf;
a718 3
		ap->a_miss = wbackground;
		ap->a_eol = dev_eol;
		one_hit_flag = 1;
d720 7
a726 3
		(void)solid_pos( "LIGHT", l0pos );
VPRINT("LIGHT0 at", l0pos);
		break;
d729 1
a729 1
	case 5:
d731 18
a748 3
		ap->a_miss = wbackground;
		ap->a_eol = dev_eol;
		one_hit_flag = 1;
a749 13
	case 3:
		ap->a_hit = l3hit;
		ap->a_miss = l3miss;
		ap->a_init = l3init;
		ap->a_end = l3end;
		ap->a_eol = l3eol;
		one_hit_flag = 1;
		break;
	case 4:
		ap->a_hit = l4hit;
		ap->a_miss = nullf;
		ap->a_eol = nullf;
		break;
a752 6

	if( lightmodel == 3 || lightmodel == 4 )
		if( outfd > 0 )
			outfp = fdopen( outfd, "w" );
		else
			rtbomb("No output file specified");
@


1.25
log
@Added more warning prints
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.24 85/06/05 01:35:05 mike Exp $ (BRL)";
d39 3
a41 1
#include "vmath.h"
a43 1
#include "../h/mater.h"
@


1.24
log
@Minor improvements to the generation of .pix files.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.23 85/06/04 23:24:16 mike Exp $ (BRL)";
d379 1
a379 1
		if(debug)fprintf(stderr,"colorview:  eye inside solid\n");
d469 1
d507 1
a507 1
		*pixelp++ = bg & 0xFF;	/* R */
@


1.23
log
@Various little changed needed to make the HEP version work.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.22 85/05/29 00:15:32 mike Exp $ (BRL)";
a203 1
	LOCAL long inten;
d280 3
a282 5
		inten = 0x0080FF80;
	} else {
		inten = (b << 16) |		/* B */
			(g <<  8) |		/* G */
			(r);			/* R */
d286 1
a286 1
		ikwpixel( ap->a_x, ap->a_y, inten);
d288 3
a290 3
		*pixelp++ = inten & 0xFF;	/* R */
		*pixelp++ = (inten>>8) & 0xFF;	/* G */
		*pixelp++ = (inten>>16) & 0xFF;	/* B */
a357 1
	LOCAL long inten;
d372 1
a372 1
		inten = 0x00FFFFFF;	/* white */
d377 2
a378 1
		inten = 0xffL;		/* red */
d469 3
a471 5
		inten = 0x0080FF80;
	} else {
		inten = (b << 16) |		/* B */
			(g <<  8) |		/* G */
			(r);			/* R */
d475 1
a475 1
		ikwpixel( ap->a_x, ap->a_y, inten);
d477 3
a479 3
		*pixelp++ = inten & 0xFF;	/* R */
		*pixelp++ = (inten>>8) & 0xFF;	/* G */
		*pixelp++ = (inten>>16) & 0xFF;	/* B */
@


1.22
log
@Moved region and material pointer from solid structure to tree (leaf)
nodes, added path matrix and use count to solid structure, to permit
solids referenced with identical path matrices to "share",
resulting in far greater speed.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.21 85/05/01 19:58:54 mike Exp $ (BRL)";
d71 5
a75 4
#define MAX_LINE	1024	/* Max pixels/line */
static long scanline[MAX_LINE];	/* 1 scanline pixel buffer */
static long *pixelp;		/* pointer to first empty pixel */
static int scanbytes;		/* # of bytes of scanline to be written */
d155 1
a155 1
	static double cosI0;
d204 6
a209 6
	static long inten;
	static fastf_t diffuse2, cosI2;
	static fastf_t diffuse1, cosI1;
	static fastf_t diffuse0, cosI0;
	static vect_t work0, work1;
	static int r,g,b;
d290 5
a294 2
	if( outfd > 0 )
		*pixelp++ = inten;
d360 4
a363 4
	struct application shadow_ap;
	static long inten;
	static int r,g,b;
	int light_visible;
d371 2
a372 2
	static vect_t	reflected;
	static vect_t	to_eye;
d381 1
a381 1
		inten = 0L;		/* black */
d481 5
a485 2
	if( outfd > 0 )
		*pixelp++ = inten;
d510 5
a514 2
	if( outfd > 0 )
		*pixelp++ = bg;
d546 1
a546 1
			scanbytes = MAX_LINE * sizeof(long);
d548 1
a548 1
			scanbytes = 512 * sizeof(long);
@


1.21
log
@Added eye-inside-solid checking.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.20 85/03/25 17:47:14 mike Exp $ (BRL)";
d104 1
a104 1
	if( strcmp( pp->pt_inseg->seg_stp->st_name, "/LIGHT" )==0 )
d371 1
a371 1
	if( strcmp( pp->pt_inseg->seg_stp->st_name, "/LIGHT" )==0 )  {
d415 1
a415 1
		mp = ((struct mater *)pp->pt_inseg->seg_stp->st_materp);
@


1.20
log
@Added support for material code
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.19 85/03/25 11:47:52 mike Exp $ (BRL)";
d373 6
@


1.19
log
@Housekeeping
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.18 85/02/07 19:20:15 mike Exp $ (BRL)";
d42 1
d407 7
a413 1
	lookupColor( &red, &grn, &blu, pp->pt_regionp->reg_regionid );
a654 104
}

/********/
/*
 *  These routines map GIFT region ID values to
 *  an RGB color.  This belongs in a separate file.
 */

/* Standard colors defined in 'spectra[]' in 'glob.c'.			*/
#define BLACK		0
#define PURPLE		1
#define AZURE		2
#define	BLUE		3
#define LT_BLUE		4
#define LAVENDER	5
#define GREEN		6
#define	LT_GREEN	7
#define YELLOW		8
#define ORANGE		9
#define	RED		10
#define PINK		11
#define WHITE		12
#define LT_ORANGE	13
#define INDIGO		14
#define GRAY		15

#define MAX_COLOR	15

#define GRAD_SLOPE	0.6

/* Ikonas frame buffer style pixels.					*/
typedef struct { /* Intensities (0-255) in each color.			*/
	unsigned char	R; /* Red.					*/
	unsigned char	G; /* Green.					*/
	unsigned char	B; /* Blue.					*/
	unsigned char	U; /* Unused memory.				*/
} Pixel;

Pixel	spectra[] = {
      {   0,   0,   0,   0 },	/* Black */
      { 180,  90, 180,   0 },   /* Purple */
      {  80, 100, 255,   0 },   /* Azure */
      {  80, 150, 230,   0 },   /* Blue */
      { 100, 190, 190,   0 },   /* Light blue */
      { 255, 100, 255,   0 },	/* Lavender */    
      {	100, 210, 100,   0 },   /* Green */	
      { 167, 255,  80,   0 },   /* Light green */
      { 240, 240,   0,   0 },   /* Yellow */
      { 240, 120,  80,   0 },   /* Red-orange */
      {	255, 100, 100,   0 },   /* Red */
      { 255, 120, 120,   0 },	/* Pink */
      { 255, 255, 255,   0 },	/* White */
      { 255, 170,  30,   0 },   /* Light orange */
      {  50,  50, 200,   0 },   /* Dark blue */
      { 200, 200, 200,   0 }	/* Gray */
};
	
#define getColor(c)	*redP=spectra[c].R;\
			*grnP=spectra[c].G;\
			*bluP=spectra[c].B;

/*	l o o k u p C o l o r ( )
	Get default color for by number.
 */
lookupColor( redP, grnP, bluP, id )
register int	*redP, *grnP, *bluP;
register int	id;
{
	if( id >=    1 && id <= 599  ) {
		getColor( PURPLE );
	} else
	if( id >=  600 && id <= 999  ) {
		getColor( AZURE );
	} else
	if( id >= 1000 && id <= 1999 ) {
		getColor( BLUE );
	} else
	if( id >= 2000 && id <= 2999 ) {
		getColor( LT_BLUE );
	} else
	if( id >= 3000 && id <= 3999 ) {
		getColor( LAVENDER );
	} else
	if( id >= 4000 && id <= 4999 ) {
		getColor( GREEN );
	} else
	if( id >= 5000 && id <= 5999 ) {
		getColor( LT_GREEN );
	} else
	if( id >= 6000 && id <= 6999 ) {
		getColor( YELLOW );
	} else
	if( id >= 7000 && id <= 7999 ) {
		getColor( ORANGE );
	} else
	if( id >= 8000 && id <= 8999 ) {
		getColor( RED );
	} else
	if( id >= 9000 && id <= 9999 ) {
		getColor( PINK );
	} else { /* default color */
		getColor( WHITE );
	}
	return;
@


1.18
log
@Added shadowing
@
text
@d4 2
a5 1
 * Ray Tracing program, lighting model
d17 1
a17 8
 * Authors -
 *	Michael John Muuss
 *	Gary Moss
 *
 *	U. S. Army Ballistic Research Laboratory
 *	March 27, 1984
 *
 * Notes -
d21 12
a32 1
 * $Revision: 1.17 $
d35 1
a35 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.17 84/11/29 07:04:49 mike Exp $ (BRL)";
@


1.17
log
@Old 3-light model is now #5, new default light model
is now Moss-based specular reflection code.
@
text
@d27 1
a27 1
 * $Revision: 1.16 $
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.16 84/11/27 06:58:08 mike Exp $ (BRL)";
d77 3
a79 1
#define BACKGROUND	0x00404040		/* Grey */
d87 1
d90 14
d350 1
d353 1
a353 1
	int inshadow = 0;	/* 1 => shadowed */
d364 6
d378 1
a378 1
/**	dist_gradient = kCons / (hitp->hit_dist + cCons);
d381 2
d408 8
d420 1
a420 1
	if( !inshadow )  {
d456 1
a456 1

d597 2
d609 3
@


1.16
log
@Changed to match new raytrace.h definition of partition.
@
text
@d6 11
a16 1
 * Author -
d18 1
d27 1
a27 1
 * $Revision: 1.15 $
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.15 84/11/24 03:03:19 mike Exp $ (BRL)";
d203 1
a203 1
	}  else if( lightmodel == 0 )  {
d270 159
d569 5
d576 1
d604 104
@


1.15
log
@Added pt_inflip and pt_outflip flags to (finally) get the
normal vectors right in all cases.
Note that the application must interpret these flags!
@
text
@d16 1
a16 1
 * $Revision: 1.14 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.14 84/11/20 20:15:26 mike Exp $ (BRL)";
d144 2
a145 2
	if( last_solidp != pp->pt_instp )  {
		last_solidp = pp->pt_instp;
@


1.14
log
@General cleanup
@
text
@d16 1
a16 1
 * $Revision: 1.13 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.13 84/11/16 06:30:26 mike Exp $ (BRL)";
a98 1
		/* TODO: Not all may have both in & out points! */
d102 1
d124 5
a128 1
	if( (cosI0 = -VDOT(hitp->hit_normal, ap->a_ray.r_dir)) <= 0.0 )  {
d179 3
@


1.13
log
@header file shuffle
@
text
@d16 1
a16 1
 * $Revision: 1.12 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.12 84/10/19 01:39:42 mike Exp $ (BRL)";
d52 1
a52 1
extern int view_only;
d227 1
a227 1
		printf("cosI0=%f, diffuse0=%f   ", cosI0, diffuse0 );
d285 1
a285 1
	printf("** %s HIT, dist=%f\n", str, hitp->hit_dist );
d296 2
a297 2
dev_setup(npts)
int npts;
d299 2
a300 2
	if( npts > MAX_LINE )  {
		printf("view:  %d pixels/line is too many\n", npts);
d306 1
a306 1
		if( npts > 512 )
d312 1
a312 1
		if( npts > 512 )
d318 1
a318 1
		if( npts <= 64 )  {
d321 1
a321 1
		} else if( npts <= 128 )  {
d324 1
a324 1
		} else if ( npts <= 256 )  {
d375 1
a375 1
		pchar( '@@'+(i & 037) );
d397 1
a397 1
		view_only = 1;
d405 1
a405 1
		view_only = 1;
d413 1
a413 1
		bomb("bad lighting model #");
d420 1
a420 1
			bomb("No output file specified");
@


1.12
log
@Lint corrections
@
text
@d16 1
a16 1
 * $Revision: 1.11 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.11 84/10/19 00:08:18 mike Exp $ (BRL)";
d24 1
a24 1
#include "ray.h"
@


1.11
log
@Reorganization of functions for separation of application from ray functions.
@
text
@d16 1
a16 1
 * $Revision: 1.10 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.10 84/08/28 03:08:25 mike Exp $ (BRL)";
d78 1
a95 1
	register struct hit *hitp= pp->pt_inhit;
d120 1
a120 4
	static fastf_t diffuse2, cosI2;
	static fastf_t diffuse1, cosI1;
	static fastf_t diffuse0, cosI0;
	static vect_t work0, work1;
d369 2
a370 2
pknum( i )
register long i;
d372 2
@


1.10
log
@Added support for VLD binary ray-files
@
text
@d16 1
a16 1
 * $Revision: 1.9 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.9 84/08/24 01:04:47 mike Exp $ (BRL)";
d52 1
d76 16
a91 1
viewit( PartHeadp, rayp, xscreen, yscreen )
a92 2
struct ray *rayp;
int xscreen, yscreen;
d94 26
a119 1
	static long inten;
d124 1
a124 3
	static int r,g,b;
	register struct partition *pp;
	register struct hit *hitp;
d126 3
a128 3
	pp = PartHeadp->pt_forw;
	if( pp == PartHeadp )  {
		printf("viewit:  null partition list\n");
d131 5
a135 19
	hitp = pp->pt_inhit;

	/* Support for Gwyn's ray files */
	if( lightmodel == 4 )  {
		register int i;	/* XXX */
		for( ; pp != PartHeadp; pp = pp->pt_forw )  {
			/* TODO: Not all may have both in & out points! */
			VMOVE( &(vldray.ox), pp->pt_inhit->hit_point );
			VSUB2( &(vldray.rx), pp->pt_outhit->hit_point,
				pp->pt_inhit->hit_point );
			vldray.na = vldray.ne = 0.0;	/* need angle/azim */
			i = pp->pt_regionp->reg_regionid;
			vldray.ob_lo = i & 0xFFFF;
			vldray.ob_hi = (i>>16) & 0xFFFF;
			vldray.rt_lo = xscreen;
			vldray.rt_hi = yscreen;
			fwrite( &vldray, sizeof(struct vldray), 1, outfp );
		}
		return;
d137 19
d157 17
a173 3
	/* Support for pretty-picture files */
	if( lightmodel == 3 )  {
		register int i,j;
a174 32
#define pchar(c) {putc(c,outfp);if(col++==74){putc('\n',outfp);col=0;}}
		if( (cosI0 = -VDOT(hitp->hit_normal, rayp->r_dir)) <= 0.0 )  {
			ntomiss++;
			return;
		}
		if( ntomiss > 0 )  {
			pchar(' ');	/* miss target cmd */
			pknum( ntomiss );
			ntomiss = 0;
			last_solidp = SOLTAB_NULL;
		}
		if( last_item != pp->pt_regionp->reg_regionid )  {
			last_item = pp->pt_regionp->reg_regionid;
			pchar( '#' );	/* new item cmd */
			pknum( last_item );
			last_solidp = SOLTAB_NULL;
		}
		if( last_solidp != pp->pt_instp )  {
			last_solidp = pp->pt_instp;
			pchar( '!' );		/* new solid cmd */
		}
		i = cosI0 * 255.0;		/* integer angle */
		j = (i>>5) & 07;
		if( j != last_ihigh )  {
			last_ihigh = j;
			pchar( '0'+j );		/* new inten high */
		}
		j = i & 037;
		pchar( '@@'+j );			/* low bits of pixel */
		return;		
	}

d181 1
a181 1
		if( (cosI0 = -VDOT(hitp->hit_normal, rayp->r_dir)) >= 0.0 )
d250 1
a250 1
		ikwpixel( xscreen, yscreen, inten);
d255 12
a266 2
wbackground( x, y )
int x, y;
d268 1
a268 1
	register int bg;
a269 7
	if( lightmodel == 4 )
		return;
	if( lightmodel == 3 )  {
		last_solidp = SOLTAB_NULL;
		ntomiss++;
		return;
	}
d276 1
a276 1
		ikwpixel( x, y, bg );
d334 7
d347 1
a347 2
dev_eol( y )
int y;
a348 8
	if( lightmodel == 4 )
		return;
	if( lightmodel == 3 )  {
		pchar( '.' );		/* End of scanline */
		last_solidp = SOLTAB_NULL;
		ntomiss = 0;
		return;
	}
a356 2
 *  			D E V _ E N D
 *  
d359 1
a359 1
dev_end()
d361 2
a362 4
	if( lightmodel == 3 )  {
		fprintf( outfp, "/\n" );	/* end of view */
		fflush( outfp );
	}
d379 43
@


1.9
log
@Now capable of selecting one of several lighting models.
Added ability to write .PP (GIFT pretty-picture) files,
and Spencer Thomas "normals" images (for moving light program).
@
text
@d16 1
a16 1
 * $Revision: 1.8 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.8 84/08/22 03:20:03 mike Exp $ (BRL)";
d27 19
d96 19
d236 2
d316 2
@


1.8
log
@Added ambient light
@
text
@d16 1
a16 1
 * $Revision: 1.7 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.7 84/05/05 04:43:32 mike Exp $ (BRL)";
d31 2
d39 7
d77 36
d116 6
a121 17
#ifdef ONE_LIGHT
	/* Light from the "eye" (ray source).  Note sign change */
	diffuse0 = 0;
	if( (cosI0 = -VDOT(hitp->hit_normal, rayp->r_dir)) >= 0.0 )
		diffuse0 = cosI0 * ( 1.0 - AmbientIntensity);
	VSCALE( work0, l0color, diffuse0 );
#else
	/* Crude attempt at a 3-light model.  It works, but... */
	diffuse0 = 0;
	if( (cosI0 = VDOT(hitp->hit_normal, l0vec)) >= 0.0 )
		diffuse0 = cosI0 * 0.5;		/* % from this src */
	diffuse1 = 0;
	if( (cosI1 = VDOT(hitp->hit_normal, l1vec)) >= 0.0 )
		diffuse1 = cosI1 * 0.5;		/* % from this src */
	diffuse2 = 0;
	if( (cosI2 = VDOT(hitp->hit_normal, l2vec)) >= 0.0 )
		diffuse2 = cosI2 * 0.2;		/* % from this src */
d123 15
d139 8
a146 8
	/* Specular reflectance from first light source */
	/* reflection = (2 * cos(i) * NormalVec) - IncidentVec */
	/* cos(s) = -VDOT(reflection, r_dir) = cosI0 */
	f = 2 * cosI1;
	VSCALE( work, hitp->hit_normal, f );
	VSUB2( reflection, work, l1vec );
	if( not_shadowed && cosI0 > cosAcceptAngle )
		/* Do specular return */;
d149 5
a153 6
	VSCALE( work0, l0color, diffuse0 );
	VSCALE( work1, l1color, diffuse1 );
	VADD2( work0, work0, work1 );
	VSCALE( work1, l2color, diffuse2 );
	VADD2( work0, work0, work1 );
#endif ONE_LIGHT
d155 10
a164 5
	/*
	 *  Add in contribution from ambient light
	 */
	VSCALE( work1, ambient_color, AmbientIntensity );
	VADD2( work0, work0, work1 );
d196 12
d209 1
a209 1
		ikwpixel( x, y, BACKGROUND );
d211 1
a211 1
		*pixelp++ = BACKGROUND;
d276 6
d287 29
@


1.7
log
@Incorporated all display-specific stuff,
added ability to write raw pixel files with -o flag,
rather than tying up a display for hours.
@
text
@d16 1
a16 1
 * $Revision: 1.6 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.6 84/05/04 09:16:13 mike Exp $ (BRL)";
d41 1
d45 1
d53 3
a55 3
	static double diffuse2, cosI2;
	static double diffuse1, cosI1;
	static double diffuse0, cosI0;
d71 2
a72 2

	/* For light from eye, use l0vec = rayp->r_dir, -VDOT */
d74 6
a88 5
	if(debug&DEBUG_HITS)  {
		hit_print( " In", hitp );
		printf("cosI0=%f, diffuse0=%f   ", cosI0, diffuse0 );
	}

d105 13
a117 1
	if(debug&DEBUG_HITS)  VPRINT("RGB", work0);
@


1.6
log
@Minor hacks
@
text
@d16 1
a16 1
 * $Revision: 1.5 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.5 84/05/03 06:56:04 mike Exp $ (BRL)";
a26 3
#define XOFFSET	0
#define YOFFSET 0

d28 1
d30 8
d40 1
a40 1
vect_t l2color = { 255, 255, 255 };		/* Grey */
d120 3
a122 1
		ikwpixel( xscreen+XOFFSET, yscreen+YOFFSET, inten);
d125 12
a145 7
wbackground( x, y )
int x, y;
{
	if( ikfd > 0 )
		ikwpixel( x+XOFFSET, y+YOFFSET, 0x00404040 );	/* Grey */
}

d155 45
a199 12
	ikopen();
	load_map(1);
	ikclear();
	if( npts <= 64 )  {
		ikzoom( 7, 7 );		/* 1 pixel gives 8 */
		ikwindow( (0)*4, 4063+29 );
	} else if( npts <= 128 )  {
		ikzoom( 3, 3 );		/* 1 pixel gives 4 */
		ikwindow( (0)*4, 4063+25 );
	} else if ( npts <= 256 )  {
		ikzoom( 1, 1 );		/* 1 pixel gives 2 */
		ikwindow( (0)*4, 4063+17 );
@


1.5
log
@Performance enhancements, ARS fixes.
@
text
@d16 1
a16 1
 * $Revision: 1.4 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.4 84/05/01 06:40:13 mike Exp $ (BRL)";
d32 1
a32 1
vect_t l0color = {  28,  28, 255 };
d34 1
a34 1
vect_t l2color = { 255, 100,   0 };
d131 24
@


1.4
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d16 1
a16 1
 * $Revision: 1.3 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.3 84/04/26 05:43:35 mike Exp $ (BRL)";
d27 2
a28 2
#define XOFFSET	30
#define YOFFSET 30
@


1.3
log
@Selected more appealing colors
@
text
@d16 1
a16 1
 * $Revision: 1.2 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.2 84/04/18 02:21:10 mike Exp $ (BRL)";
d45 3
a47 3
	static float diffuse2, cosI2;
	static float diffuse1, cosI1;
	static float diffuse0, cosI0;
@


1.2
log
@Boolean operation support
@
text
@d16 1
a16 1
 * $Revision: 1.1 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: view.c,v 1.1 84/04/02 16:42:30 mike Exp $ (BRL)";
d32 3
a34 3
vect_t l0color = { 128, 128, 255 };
vect_t l1color = { 255, 128, 128 };
vect_t l2color = {   0, 255,   0 };
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
 * $Revision$
d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d27 2
a28 2
#define XOFFSET	20
#define YOFFSET 80
d30 2
d33 5
d39 2
a40 2
viewit( segp, rayp, xscreen, yscreen )
struct seg *segp;
d44 5
a48 4
	long inten;
	float diffuse1, cosI1;
	float diffuse0, cosI0;
	static vect_t work;
d50 2
d53 3
a55 4
	/* Really ought to find "nearest" intersection, but gap() should
	 *  do that for us.  Just use top of list. */
	if( !(segp->seg_flag & SEG_IN) )  {
		printf("viewit:  No entry point\n");
d58 1
d63 5
d69 5
a73 4
#ifdef later
	if( (cosI1 = -VDOT(segp->seg_in.hit_normal, l1vec)) >= 0.0 )
		diffuse1 = cosI1 * 0.5;	/* % from this src */
#endif
a74 5
	diffuse0 = 0;		/* From EYE */
	if( (cosI0 = -VDOT(segp->seg_in.hit_normal, rayp->r_dir)) >= 0.0 )  {
		diffuse0 = cosI0 * 1.0;		/* % from this src */
	}

d76 1
a76 6
		if( segp->seg_flag & SEG_IN )
			hit_print( " In", &segp->seg_in );
#ifdef never
		if( segp->seg_flag & SEG_OUT )
			hit_print( "Out", &segp->seg_out );
#endif never
d85 1
a85 1
	VSCALE( work, segp->seg_in.hit_normal, f );
d91 6
a96 2
	VSCALE( work, l0color, diffuse0 );
	if(debug&DEBUG_HITS)  VPRINT("RGB", work);
d98 3
a100 3
	r = work[0];
	g = work[1];
	b = work[2];
d105 1
a105 1
		VPRINT("@@@@ Negative RGB @@@@", work);
d113 2
a114 1
	ikwpixel( xscreen+XOFFSET, yscreen+YOFFSET, inten);
d129 2
a130 1
	ikwpixel( x+XOFFSET, y+YOFFSET, 0x00808080 );		/* Grey */
@
