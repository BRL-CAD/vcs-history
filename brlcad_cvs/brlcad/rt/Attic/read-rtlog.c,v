head	11.12;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.2
	premerge-autoconf:11.9
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.21.17.31.04;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.38;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.03.31.01.57.31;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.17.02.41.35;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.06.03.01.48.37;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.05.28.01.17.24;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.08.27.03.48.59;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.47;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.11.05.03.08.51;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.22.19.34.15;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.00.37.16;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.52;	author mike;	state Rel4_0;
branches;
next	1.4;

1.4
date	91.07.05.09.26.16;	author sue;	state Exp;
branches;
next	1.3;

1.3
date	91.06.26.16.43.18;	author sue;	state Exp;
branches;
next	1.2;

1.2
date	91.06.26.01.22.16;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.05.31.14.04.14;	author sue;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.22.57;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.48.06;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	11.8.10.2;

11.8.10.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@This is a routine that reads an rtlog file to extract model size, view,
orientation, and eye-pos. to construct a model2view matrix.
@


11.12
log
@moved to src/rt/
@
text
@/*
*			R E A D - R T L O G . C
*
*  This is a program will read an RT log file.  It is meant to be
*  used by any other program that needs to read an RT log file to
*  extract the model size, orientation, eye position, azimuth, and 
*  elevation from the log file.
*  
*
*  Authors -
*	Susanne L. Muuss, J.D.
*	
*
*  Source -
*	SECAD/VLD Computing Consortium, Bldg. 394
*	The U. S. Army Ballistic Reasearch Laboratory
*	Aberdeen Proving Ground, Maryland  21005
*
*  Copyright Notice -
*	This software is Copyright (C) 1991-2004 by the United States Army.
*	All rights reserved.
*/
#ifndef lint
static const char RCSreadfile[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/read-rtlog.c,v 11.11 2004/05/10 15:30:49 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"

#define BUFF_LEN 256
#define FALSE 0
#define TRUE 1


extern int	verbose;


/*		R E A D _ R T _ F I L E
 *
 * Read an RT program's log file line by line until it either finds
 * view, orientation, eye_postion, and size of the model, or it hits the
 * end of file.  When a colon is found, sscanf() retrieves the
 * necessary information.  It takes a file pointer, file name, and a matrix
 * pointer as parameters.  It returns 0 okay or < 0 failure.
 */

int
read_rt_file(FILE *infp, char *name, fastf_t *model2view)
{
	FILE		*fp;
	fastf_t		azimuth;		/* part of the view */
	fastf_t		elevation;		/* part of the view */
	quat_t		orientation;		/* orientation */
	point_t		eye_pos;
	fastf_t		m_size;			/* size of model in mm */
	char		*ret;			/* return code for fgets */
	char		string[BUFF_LEN];	/* temporary buffer */
	char		*arg_ptr;		/* place holder */
	char		forget_it[9];		/* "azimuth" catcher, then forget */
	int		i;			/* reusable counter */
	int		num;			/* return code for sscanf */
	int		seen_view;		/* these are flags.  */
	int		seen_orientation;
	int		seen_eye_pos;
	int		seen_size;

	mat_t		rotate, xlate;


	/* Open the incoming file for reading */

	fp = fopen(name, "r");
	if( fp == NULL )  {
		perror(name);
		exit(-1);
	}

	/* Set all flags to ready state.  */

	seen_view = FALSE;
	seen_orientation = FALSE;
	seen_eye_pos = FALSE;
	seen_size = FALSE;

	if(verbose)  {
		fprintf(stderr, "set flags: view:%d, orient:%d, eye_pos:%d, size:%d\n",
		seen_view, seen_orientation, seen_eye_pos, seen_size);
	}

	/* feof returns 1 on failure */

	while( feof(infp) == 0 )  {

		/* clear the buffer */	
		for( i = 0; i < BUFF_LEN; i++ )  {
			string[i] = '\0';
		}
		ret = fgets(string, BUFF_LEN, infp);

		if( ret == NULL )  {
			/* There are two times when NULL might be seen:
			 * at the end of the file (handled above) and
			 * when the process dies horriblely and unexpectedly.
			 */

			if( feof(infp) )
				break;
			
			/* This needs to be seen only if there is an
			 * unexpected end.
			 */
			fprintf(stderr, "read_rt_file: read failure on file %s\n",
 				name);
 			return(-1);
		}

		/* Check the first for a colon in the buffer.  If there is
		 * one, replace it with a NULL, and set a pointer to the
		 * next space.  Then feed the buffer to
		 * strcmp see whether it is the view, the orientation,
		 * the eye_position, or the size.  If it is, then sscanf()
		 * the needed information into the appropriate variables.
		 * If the keyword is not found, go back for another line.
		 *
		 * Set arg_ptr to NULL so it can be used as a flag to verify
		 * finding a colon in the input buffer.
		 */

		arg_ptr = NULL;

		for( i = 0; i < BUFF_LEN; i++ )  {
			/* Check to make sure the first char. is not a NULL;
			 * if it is, go back for a new line.
			 */
			if( string[i] == '\0' )  {
				break;
			}
			if( string[i] == ':')  {
				/* If a colon is found, set arg_ptr to the
				 * address of the colon, and break: no need to
				 * look for more colons on this line.
				 */

				if(verbose)  {
					fprintf(stderr, "found colon\n");
				}

				string[i] = '\0';
				arg_ptr = &string[++i];		/* increment before using */
				break;
			}
		}

		/* Check to see if a colon has been found.  If not, get another
		 * input line.
		 */

		if( arg_ptr == NULL )  {
			continue;
		}

		/* Now compare the first word in the buffer with the
		 * key words wanted.  If there is a match, read the
		 * information that follows into the appropriate
		 * variable, and set a flag to indicate that the
		 * magic thing has been seen.
		 *
		 * Note two points of interest: scanf() does not like %g;
		 * use %lf.  Likewise, don't use %g for printing out info:
		 * it might get rounded to the nearest integer.  Use %.6f
		 * instead.
		 * Also, if loading a whole array of characters
		 * with %s, then the name of the array can be used for the
		 * destination.  However, if the characters are loaded 
		 * individually into the subsripted spots with %c (or equiv),
		 * the address of the location must be provided: &eye_pos[0].
		 */

		if(strcmp(string, "View") == 0)  {
			num = sscanf(arg_ptr, "%lf %s %lf", &azimuth, forget_it, &elevation);
			if( num != 3)  {
				fprintf(stderr, "View= %.6f %s %.6f elevation\n", azimuth, forget_it, elevation);
				return(-1);
			}
			seen_view = TRUE;
		} else if(strcmp(string, "Orientation") == 0)  {
			num = sscanf(arg_ptr, "%lf, %lf, %lf, %lf",
				&orientation[0], &orientation[1], &orientation[2],
				&orientation[3]);

 			if(num != 4)  {
				fprintf(stderr, "Orientation= %.6f, %.6f, %.6f, %.6f\n",
				 	V4ARGS(orientation) );
				return(-1);
			}
			seen_orientation = TRUE;
		} else if(strcmp(string, "Eye_pos") == 0)  {
			num = sscanf(arg_ptr, "%lf, %lf, %lf", &eye_pos[0],
				&eye_pos[1], &eye_pos[2]);
			if( num != 3)  {
				fprintf(stderr, "Eye_pos= %.6f, %.6f, %.6f\n",
					V3ARGS(eye_pos) );
				return(-1);
			}
			seen_eye_pos = TRUE;
		} else if(strcmp(string, "Size") == 0)  {
			num = sscanf(arg_ptr, "%lf", &m_size);
			if(num != 1)  {
				fprintf(stderr, "Size=%.6f\n", m_size);
				return(-1);
			}
			seen_size = TRUE;
		}
	}

	/* Check that all the information to proceed is available */

	if( seen_view != TRUE )  {
		fprintf(stderr, "View not read for %s!\n", name);
		return(-1);
	}

	if( seen_orientation != TRUE )  {
		fprintf(stderr, "Orientation not read for %s!\n", name);
		return(-1);
	}

	if( seen_eye_pos != TRUE )  {
		fprintf(stderr, "Eye_pos not read for %s!\n", name);
		return(-1);
	}

	if ( seen_size != TRUE )  {
		fprintf(stderr, "Size not read for %s!\n", name);
		return(-1);
	}

	if( verbose )  {
		/* Take your chances on the %g with the orientation: it is difficult
		 * to say how many figures it will take to print the orientation back,
		 * and it is disconcerting to have it come back as 0.
		 */

		fprintf(stderr, "logfile: %s\n", name);
		fprintf(stderr, "view: azimuth %.6f; elevation: %.6f\n", azimuth, elevation);
		fprintf(stderr, "orientation: %g, %g, %g, %g\n", V4ARGS(orientation) );
		fprintf(stderr, "eye_pos: %.6f, %.6f, %.6f\n", V3ARGS(eye_pos) );
		fprintf(stderr, "size: %.6fmm\n", m_size);
	}
		
	/* Build the view2model matrix. */

	quat_quat2mat( rotate, orientation );
	rotate[15] = 0.5 * m_size;
	MAT_IDN( xlate );
	MAT_DELTAS( xlate, -eye_pos[0], -eye_pos[1], -eye_pos[2] );
	bn_mat_mul( model2view, rotate, xlate );

	if(verbose)  {
		 bn_mat_print("model2view", model2view);
	}

	fclose(fp);		/* clean up */
	return(0);
}

@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /cvs/brlcad/rt/read-rtlog.c,v 11.10 2004/04/05 05:45:58 morrison Exp $";
@


11.10
log
@merge of ansi-6-0-branch into head
@
text
@d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header$";
d27 5
a31 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.8 2002/08/20 17:08:38 jra Exp $";
d60 1
a60 4
read_rt_file(infp, name, model2view)
FILE	*infp;
char	*name;
mat_t 	model2view;
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
*	This software is Copyright (C) 1991 by the United States Army.
d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.6 2001/03/31 01:57:31 morrison Exp $";
@


11.8.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/read-rtlog.c,v 11.9 2004/02/02 17:39:38 morrison Exp $";
@


11.8.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.9 2004/02/02 17:39:38 morrison Exp $";
@


11.8.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.8.10.1 2004/02/12 19:37:13 erikg Exp $";
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.8 2002/08/20 17:08:38 jra Exp $";
d60 4
a63 1
read_rt_file(FILE *infp, char *name, fastf_t *model2view)
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header$";
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d60 4
a63 1
read_rt_file(FILE *infp, char *name, fastf_t *model2view)
@


11.6
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.5 2000/08/17 02:41:35 mike Exp $";
d60 1
a60 4
read_rt_file(infp, name, model2view)
FILE	*infp;
char	*name;
mat_t 	model2view;
@


11.5
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d24 1
a24 1
static const char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.4 1999/06/03 01:48:37 mike Exp $";
d270 1
a270 1
	bn_mat_idn( xlate );
@


11.4
log
@
Tidy up of comments and messages
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.3 1999/05/28 01:17:24 mike Exp $";
@


11.3
log
@
sed4
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /c/CVS/brlcad/rt/read-rtlog.c,v 11.2 1996/08/27 03:48:59 mike Exp $";
d52 1
a52 1
 * This routine reads an rt_log file line by line until it either finds
d127 1
a127 1
			fprintf(stderr, "read_rt_log: read failure on file %s\n",
@


11.2
log
@Added more header files
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /m/cad/rt/RCS/read-rtlog.c,v 11.1 1995/01/04 10:00:47 mike Rel4_4 mike $";
d270 1
a270 1
	mat_idn( xlate );
d272 1
a272 1
	mat_mul( model2view, rotate, xlate );
d275 1
a275 1
		 mat_print("model2view", model2view);
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /m/cad/rt/RCS/read-rtlog.c,v 10.4 94/11/05 03:08:51 mike Exp $";
d37 1
d39 2
a40 1

@


10.4
log
@Irix 6
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /m/cad/rt/RCS/read-rtlog.c,v 10.3 94/08/22 19:34:15 gdurf Exp Locker: mike $";
@


10.3
log
@Factored ifdefs
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /m/cad/rt/RCS/read-rtlog.c,v 10.2 1994/08/11 00:37:16 gdurf Exp gdurf $";
a80 1
	mat_t		tmp_mat;
@


10.2
log
@Added include of conf.h and string[s].h
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /m/cad/rt/RCS/read-rtlog.c,v 10.1 1991/10/12 06:41:52 mike Rel4_0 gdurf $";
d34 1
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /m/cad/rt/RCS/read-rtlog.c,v 1.4 91/07/05 09:26:16 sue Exp $";
d27 2
d30 4
@


1.4
log
@Changed %.6f back to %g for the printing out of the orientatin: this way
something othern than 0 will be printed.  Made the confirmatory prints
part of the future verbose option.
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /m/cad/rt/RCS/read-rtlog.c,v 1.3 91/06/26 16:43:18 sue Exp $";
@


1.3
log
@Converted %g's to %.6f to prevent rounding to ints.
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/read-rtlog.c,v 1.2 91/06/03 15:28:01 sue Exp $";
d245 5
a249 1
	/* For now, just print the stuff */
d251 7
a257 6
	fprintf(stderr, "logfile: %s\n", name);
	fprintf(stderr, "view: %.6f; azimuth: %.6f; elevation: %.6f\n", azimuth, elevation);
	fprintf(stderr, "orientation: %.6f, %.6f, %.6f, %.6f\n", V4ARGS(orientation) );
	fprintf(stderr, "eye_pos: %.6f, %.6f, %.6f\n", V3ARGS(eye_pos) );
	fprintf(stderr, "size: %.6fmm\n", m_size);

@


1.2
log
@Removed printing
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/read-rtlog.c,v 1.1 91/05/31 14:04:14 sue Exp $";
d38 3
d92 5
d98 1
d150 5
d176 4
a179 1
		 * use %lf.  Also, if loading a whole array of characters
d189 1
a189 1
				fprintf(stderr, "View= %g %s %g elevation\n", azimuth, forget_it, elevation);
d199 1
a199 1
				fprintf(stderr, "Orientation= %g, %g, %g, %g\n",
d208 1
a208 1
				fprintf(stderr, "Eye_pos= %g, %g, %g\n",
d216 1
a216 1
				fprintf(stderr, "Size=%g\n", m_size);
a244 1
#if 0
d246 1
d248 4
a251 5
	fprintf(stderr, "view= %g azimuth, %g elevation\n", azimuth, elevation);
	fprintf(stderr, "orientation= %g, %g, %g, %g\n", V4ARGS(orientation) );
	fprintf(stderr, "eye_pos= %g, %g, %g\n", V3ARGS(eye_pos) );
	fprintf(stderr, "size= %gmm\n", m_size);
#endif
d260 4
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSreadfile[] = "@@(#)$Header: $";
a88 4
/* fprintf(stderr, "set flags: view=%d, orient.=%d, eye_pos=%d, size=%d\n",
 *	seen_view, seen_orientation, seen_eye_pos, seen_size);
 */

a89 1

a140 3

/* fprintf(stderr, "found colon\n");
 */
d228 1
a229 1

d235 1
a243 2

 mat_print("model2view", model2view);
@
