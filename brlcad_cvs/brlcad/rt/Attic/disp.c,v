head	1.23;
access;
symbols
	rel-4-5:1.12
	ctj-4-5-post:1.12
	ctj-4-5-pre:1.12;
locks; strict;
comment	@ * @;


1.23
date	98.11.17.19.15.24;	author mike;	state dead;
branches;
next	1.22;

1.22
date	98.10.09.21.45.25;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	98.10.09.21.32.14;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	98.10.09.21.17.28;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	98.10.09.05.52.30;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	98.10.09.02.19.05;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	98.10.07.22.28.57;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.10.07.07.49.56;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	98.10.07.07.37.11;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	98.09.30.04.31.49;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	98.09.30.02.22.18;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	96.04.06.04.30.54;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.04.06.01.09.12;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	96.03.16.00.52.32;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	96.03.14.07.25.02;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	96.03.14.04.58.40;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.03.09.05.37.45;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	96.03.09.03.21.08;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.03.09.01.01.01;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	96.03.09.00.50.42;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.03.08.05.53.35;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.03.08.03.04.09;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.03.01.06.03.46;	author mike;	state Exp;
branches;
next	;


desc
@Thermal display program
@


1.23
log
@Moved rttherm and it's pieces into ../rttherm directory
@
text
@/*
 *			D I S P . C
 *
 *  Quickie program to display spectral curves on the framebuffer.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.22 1998/10/09 21:45:25 mike Exp mike $ (ARL)";
#endif

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "tabdata.h"
#include "spectrum.h"
#include "fb.h"
#include "tcl.h"
#include "tk.h"

int	width = 64;				/* Linked with TCL */
int	height = 64;				/* Linked with TCL */

char	*basename = "mtherm";
char	spectrum_name[100];

FBIO	*fbp;

struct rt_table		*spectrum;

struct rt_tabdata	*data;

struct rt_tabdata	*atmosphere_orig;
struct rt_tabdata	*atmosphere;
int			use_atmosphere = 0;	/* Linked with TCL */

struct rt_tabdata	*cie_x;
struct rt_tabdata	*cie_y;
struct rt_tabdata	*cie_z;
int			use_cie_xyz = 0;	/* Linked with TCL */
mat_t			xyz2rgb;
/* mat_t			rgb2xyz; */

struct rt_tabdata	*ntsc_r;
struct rt_tabdata	*ntsc_g;
struct rt_tabdata	*ntsc_b;

unsigned char	*pixels;		/* en-route to framebuffer */

fastf_t	maxval, minval;				/* Linked with TCL */

Tcl_Interp	*interp;
Tk_Window	tkwin;

int	doit(), doit1();
void	find_minmax();
void	rescale(BU_ARGS(int wav));
void	show_color(BU_ARGS(int off));

char			*first_command = "no_command?";

/*
 *		A S S I G N _ T A B D A T A _ T O _ T C L _ V A R
 *
 *  Assign the given "C" rt_tabdata structure to the named Tcl variable,
 *  and add the name of that variable to the Tcl result string.
 */
void
assign_tabdata_to_tcl_var( interp, name, tabp )
Tcl_Interp	*interp;
CONST char	*name;
CONST struct rt_tabdata *tabp;
{
	struct bu_vls	str;

	RT_CK_TABDATA(tabp);

	bu_vls_init(&str);

	rt_tabdata_to_tcl(&str, tabp);
	Tcl_SetVar( interp, (char *)name, bu_vls_addr(&str), 0 );
	Tcl_AppendResult( interp, name, " ", (char *)NULL );

	bu_vls_free(&str);
}

/*
 *  Temporary testing function
 *  Takes no args, sets three Tcl variables, ntsc_r, ntsc_g, ntsc_b
 */
int
getntsccurves( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
	extern struct rt_tabdata *rt_NTSC_r_tabdata;
	extern struct rt_tabdata *rt_NTSC_g_tabdata;
	extern struct rt_tabdata *rt_NTSC_b_tabdata;

	/* These are the curves as sampled to our spectrum intervals */
	assign_tabdata_to_tcl_var( interp, "ntsc_r_samp", ntsc_r );
	assign_tabdata_to_tcl_var( interp, "ntsc_g_samp", ntsc_g );
	assign_tabdata_to_tcl_var( interp, "ntsc_b_samp", ntsc_b );

#if 0
	/* These are the curves from the data tables in the library */
	assign_tabdata_to_tcl_var( interp, "ntsc_r_orig", rt_NTSC_r_tabdata );
	assign_tabdata_to_tcl_var( interp, "ntsc_g_orig", rt_NTSC_g_tabdata );
	assign_tabdata_to_tcl_var( interp, "ntsc_b_orig", rt_NTSC_b_tabdata );
#endif

	/* Sum togther the sampled curves */
	{
		struct rt_tabdata	*sum;
		RT_GET_TABDATA( sum, ntsc_r->table );
		rt_tabdata_add( sum, ntsc_r, ntsc_g );
		rt_tabdata_add( sum, sum, ntsc_b );
		assign_tabdata_to_tcl_var( interp, "ntsc_sum", sum );
		bu_free( sum, "rt_tabdata sum" );
	}

#if 0
	/* Check out the RGB to spectrum curves */
	{
		struct rt_tabdata	*r, *g, *b, *sum;
		point_t		rgb;

		RT_GET_TABDATA( r, ntsc_r->table );
		RT_GET_TABDATA( g, ntsc_r->table );
		RT_GET_TABDATA( b, ntsc_r->table );
		RT_GET_TABDATA( sum, ntsc_r->table );

		VSET( rgb, 1, 0, 0 );
		rt_spect_reflectance_rgb( r, rgb );
		assign_tabdata_to_tcl_var( interp, "reflectance_r", r );

		VSET( rgb, 0, 1, 0 );
		rt_spect_reflectance_rgb( g, rgb );
		assign_tabdata_to_tcl_var( interp, "reflectance_g", g );

		VSET( rgb, 0, 0, 1 );
		rt_spect_reflectance_rgb( b, rgb );
		assign_tabdata_to_tcl_var( interp, "reflectance_b", b );

		rt_tabdata_add( sum, r, g );
		rt_tabdata_add( sum, sum, b );
		assign_tabdata_to_tcl_var( interp, "reflectance_sum", sum );

		bu_free( r, "r" );
		bu_free( g, "g" );
		bu_free( b, "b" );
		bu_free( sum, "sum" );
	}
#endif

	/* Check out the black body curves */
	{
		struct rt_tabdata	*a, *b, *c;

		RT_GET_TABDATA( a, ntsc_r->table );
		RT_GET_TABDATA( b, ntsc_r->table );
		RT_GET_TABDATA( c, ntsc_r->table );

		rt_spect_black_body_fast( a, 5000.0 );
		assign_tabdata_to_tcl_var( interp, "a_5000", a );

		rt_spect_black_body_fast( b, 6500.0 );
		assign_tabdata_to_tcl_var( interp, "b_6500", b );

		rt_spect_black_body_fast( c, 10000.0 );
		assign_tabdata_to_tcl_var( interp, "c_10000", c );

		bu_free( a, "a" );
		bu_free( b, "b" );
		bu_free( c, "c" );
	}

	return TCL_OK;
}

/*
 *
 *  With no args, returns the number of wavelengths.
 *  With an integer arg, returns the i-th wavelength.
 *
 *  spectrum pointer should be an arg, not implicit.
 */
int
getspectrum( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
	int	wl;

	RT_CK_TABLE(spectrum);

	if( argc <= 1 )  {
		sprintf( interp->result, "%d", spectrum->nx );
		return TCL_OK;
	}
	if( argc != 2 )  {
		interp->result = "Usage: getspectrum [wl]";
		return TCL_ERROR;
	}
	wl = atoi(argv[2]);

	if( wl < 0 || wl > spectrum->nx )  {
		sprintf( interp->result, "getspectrum: wavelength %d out of range 0..%d",
			wl, spectrum->nx);
		return TCL_ERROR;
	}
	sprintf( interp->result, "%g", spectrum->x[wl] );
	return TCL_OK;
}

int
getspectval( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
	struct rt_tabdata	*sp;
	int	x, y, wl;
	char	*cp;
	fastf_t	val;

	if( argc != 4 )  {
		interp->result = "Usage: getspect x y wl";
		return TCL_ERROR;
	}
	x = atoi(argv[1]);
	y = atoi(argv[2]);
	wl = atoi(argv[3]);

	RT_CK_TABLE(spectrum);

	if( x < 0 || x > width || y < 0 || y > height )  {
		interp->result = "x or y out of range";
		return TCL_ERROR;
	}
	if( wl < 0 || wl >= spectrum->nx )  {
		interp->result = "wavelength out of range";
		return TCL_ERROR;
	}

	if( !data )  {
		interp->result = "pixel data table not loaded yet";
		return TCL_ERROR;
	}

	cp = (char *)data;
	cp = cp + (y * width + x) * RT_SIZEOF_TABDATA(spectrum);
	sp = (struct rt_tabdata *)cp;
	RT_CK_TABDATA(sp);
	val = sp->y[wl];
	if( use_atmosphere )
		val *= atmosphere->y[wl];
	sprintf( interp->result, "%g", val );
	return TCL_OK;
}

/*
 *			G E T S P E C T X Y
 *
 *  Given the x,y coordinates of a pixel in the multi-spectral image,
 *  return the spectral data found there in Tcl string form.
 */
int
getspectxy( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
	struct rt_tabdata	*sp;
	int	x, y;
	char	*cp;
	struct bu_vls	str;

	if( argc != 3 )  {
		interp->result = "Usage: getspectxy x y";
		return TCL_ERROR;
	}
	x = atoi(argv[1]);
	y = atoi(argv[2]);

	RT_CK_TABLE(spectrum);

	if( x < 0 || x > width || y < 0 || y > height )  {
		interp->result = "x or y out of range";
		return TCL_ERROR;
	}

	if( !data )  {
		interp->result = "pixel data table not loaded yet";
		return TCL_ERROR;
	}
	cp = (char *)data;
	cp = cp + (y * width + x) * RT_SIZEOF_TABDATA(spectrum);
	sp = (struct rt_tabdata *)cp;
	RT_CK_TABDATA(sp);

	bu_vls_init(&str);
	rt_tabdata_to_tcl( &str, sp );
	Tcl_SetResult( interp, bu_vls_addr(&str), TCL_VOLATILE);
	bu_vls_free(&str);

	return TCL_OK;
}

/*
 *  TCL interface to LIBFB.
 *  Points at lower left corner of selected pixel.
 */
int
tcl_fb_cursor( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
	FBIO	*ifp;
	int	mode, x, y;

	if( argc != 5 )  {
		interp->result = "Usage: fb_cursor fbp mode x y";
		return TCL_ERROR;
	}
	ifp = (FBIO *)atoi(argv[1]);
	mode = atoi(argv[2]);
	x = atoi(argv[3]);
	y = atoi(argv[4]);

	ifp = fbp;	/* XXX hack, ignore tcl arg. */

	FB_CK_FBIO(ifp);
	if( fb_cursor( ifp, mode, x, y ) < 0 )  {
		interp->result = "fb_cursor got error from library";
		return TCL_ERROR;
	}
	return TCL_OK;
}

/*
 *  Return value of one pixel as RGB tripple, in decimal
 */
int
tcl_fb_readpixel( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
	FBIO	*ifp;
	int	mode, x, y;
	unsigned char	pixel[4];

	if( argc != 4 )  {
		interp->result = "Usage: fb_readpixel fbp x y";
		return TCL_ERROR;
	}
	ifp = (FBIO *)atoi(argv[1]);
	x = atoi(argv[2]);
	y = atoi(argv[3]);

	ifp = fbp;	/* XXX hack, ignore tcl arg. */

	FB_CK_FBIO(ifp);
	if( fb_read( ifp, x, y, pixel, 1 ) < 0 )  {
		interp->result = "fb_readpixel got error from library";
		return TCL_ERROR;
	}
	sprintf(interp->result, "%d %d %d", pixel[RED], pixel[GRN], pixel[BLU] );
	return TCL_OK;
}

int
tcl_appinit(inter)
Tcl_Interp	*inter;
{
	interp = inter;	/* set global var */
	if( Tcl_Init(interp) == TCL_ERROR )  {
		return TCL_ERROR;
	}

	/* Run tk.tcl script */
	if( Tk_Init(interp) == TCL_ERROR )  return TCL_ERROR;

	/* Add commands offered by the libraries */
	bu_tcl_setup(interp);
	rt_tcl_setup(interp);

	/* Add commands offered by this program */
	Tcl_CreateCommand(interp, "fb_cursor", tcl_fb_cursor, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "fb_readpixel", tcl_fb_readpixel, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	Tcl_CreateCommand(interp, "doit", doit, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "doit1", doit1, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	Tcl_CreateCommand(interp, "getspectval", getspectval, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "getspectrum", getspectrum, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "getspectxy", getspectxy, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "getntsccurves", getntsccurves, (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	Tcl_LinkVar( interp, "minval", (char *)&minval, TCL_LINK_DOUBLE );
	Tcl_LinkVar( interp, "maxval", (char *)&maxval, TCL_LINK_DOUBLE );

	Tcl_LinkVar( interp, "width", (char *)&width, TCL_LINK_INT );
	Tcl_LinkVar( interp, "height", (char *)&height, TCL_LINK_INT );
	Tcl_LinkVar( interp, "use_atmosphere", (char *)&use_atmosphere, TCL_LINK_INT );
	Tcl_LinkVar( interp, "use_cie_xyz", (char *)&use_cie_xyz, TCL_LINK_INT );

	/* Tell Tcl script what to do first */
	Tcl_SetVar( interp, "first_command", first_command, 0 );

	/* Specify startup file to invoke when run interactively */
	/* Source the TCL part of this lashup */
	/* Tcl7 way:  tcl_RcFileName = "./disp.tcl"; */
	Tcl_SetVar(interp, "tcl_rcFileName", "../rt/disp.tcl", TCL_GLOBAL_ONLY);

	return TCL_OK;
}

void check( double x, double y, double z);

/* Check identity of XYZ->RGB->spectrum->XYZ->RGB */
void
check( x, y, z )
double x, y, z;
{
	point_t	xyz;
	point_t	rgb;
	point_t	xyz2, rgb2;
	struct rt_tabdata	*tabp;
	FAST fastf_t	tab_area;

	RT_GET_TABDATA( tabp, spectrum );
	xyz[X] = x;
	xyz[Y] = y;
	xyz[Z] = z;
	VPRINT( "\nstarting xyz", xyz );

#if 0
	/* XXX No way to do this yet!! */
	rt_spect_xyz_to_curve( tabp, xyz, cie_x, cie_y, cie_z );
#else
	MAT3X3VEC( rgb, xyz2rgb, xyz );
	VPRINT( "rgb", rgb );
	rt_spect_reflectance_rgb( tabp, rgb );
#endif
	rt_pr_table_and_tabdata( "/dev/tty", tabp );
	tab_area = rt_tabdata_area2( tabp );
	bu_log(" tab_area = %g\n", tab_area);

	rt_spect_curve_to_xyz( xyz2, tabp, cie_x, cie_y, cie_z );

	VPRINT( "xyz2", xyz2 );
	MAT3X3VEC( rgb2, xyz2rgb, xyz2 );
	VPRINT( "rgb2", rgb2 );

	rt_free( (char *)tabp, "struct rt_tabdata" );
exit(2);
}

void
conduct_tests()
{
	struct rt_tabdata	*flat;
	vect_t			xyz;

	/* Code for testing library routines */
	spectrum = rt_table_make_uniform( 20, 340.0, 760.0 );
	rt_spect_make_CIE_XYZ( &cie_x, &cie_y, &cie_z, spectrum );
bu_log("X:\n");rt_pr_table_and_tabdata( "/dev/tty", cie_x );
bu_log("Y:\n");rt_pr_table_and_tabdata( "/dev/tty", cie_y );
bu_log("Z:\n");rt_pr_table_and_tabdata( "/dev/tty", cie_z );

	rt_spect_make_NTSC_RGB( &ntsc_r, &ntsc_g, &ntsc_b, spectrum );
bu_log("R:\n");rt_pr_table_and_tabdata( "/dev/tty", ntsc_r );
bu_log("G:\n");rt_pr_table_and_tabdata( "/dev/tty", ntsc_g );
bu_log("B:\n");rt_pr_table_and_tabdata( "/dev/tty", ntsc_b );
	{
		struct bu_vls str;
		bu_vls_init(&str);
		rt_tabdata_to_tcl( &str, ntsc_r );
		bu_log("ntsc_r tcl:  %s\n", bu_vls_addr(&str) );
		bu_vls_free(&str);
	}

/* "A flat spectral curve is represente by equal XYZ values".  Hall pg 52 */
	flat = rt_tabdata_get_constval( 42.0, spectrum );
	bu_log("flat:\n");rt_pr_table_and_tabdata( "/dev/tty", flat );
	rt_spect_curve_to_xyz(xyz, flat, cie_x, cie_y, cie_z );
	VPRINT("flat xyz?", xyz);

return;

	/* Check identity of XYZ->RGB->spectrum->XYZ->RGB */
	check( 0.313,     0.329,      0.358);	/* D6500 white */
	check( 0.670,     0.330,      0.000);	/* NTSC red primary */
	check( 0.210,     0.710,      0.080);	/* NTSC green primary */
	check( 0.140,     0.080,      0.780);	/* NTSC blue primary */
	check( .5, .5, .5 );
	check( 1, 0, 0 );
	check( 0, 1, 0 );
	check( 0, 0, 1 );
	check( 1, 1, 1 );
	check( 1, 1, 0 );
	check( 1, 0, 1 );
	check( 0, 1, 1 );
}

/*
 *			M A I N
 */
int
main( argc, argv )
char	**argv;
{

	rt_g.debug = 1;

	rt_make_ntsc_xyz2rgb( xyz2rgb );

	if( argc > 1 )  {
		conduct_tests();
		first_command = "do_testing";
		Tk_Main( 1, argv, tcl_appinit );
		/* NOTREACHED */
		exit(0);
	}
	first_command = "doit1 42";

	if( (fbp = fb_open( NULL, width, height )) == FBIO_NULL )  {
		rt_bomb("Unable to open fb\n");
	}
	fb_view( fbp, width/2, height/2, fb_getwidth(fbp)/width, fb_getheight(fbp)/height );

	/* Read spectrum definition */
	sprintf( spectrum_name, "%s.spect", basename );
	spectrum = (struct rt_table *)rt_table_read( spectrum_name );
	if( spectrum == NULL )  {
		rt_bomb("Unable to read spectrum\n");
	}

	/* Read atmosphere curve -- input is in microns, not nm */
	atmosphere_orig = rt_read_table_and_tabdata( "std_day_1km.dat" );
	rt_table_scale( (struct rt_table *)(atmosphere_orig->table), 1000.0 );
	atmosphere = rt_tabdata_resample_max( spectrum, atmosphere_orig );

	/* Allocate and read 2-D spectrum array */
	data = rt_tabdata_binary_read( basename, width*height, spectrum );

	/* Allocate framebuffer image buffer */
	pixels = (unsigned char *)bu_malloc( width * height * 3, "pixels[]" );

	find_minmax();
	rt_log("min = %g, max=%g Watts\n", minval, maxval );

	Tk_Main( 1, argv, tcl_appinit );
	/* NOTREACHED */

	return 0;
}

int
doit( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
	int	wl;
	char	cmd[96];

	for( wl = 0; wl < spectrum->nx; wl++ )  {
		sprintf( cmd, "doit1 %d", wl );
		Tcl_Eval( interp, cmd );
	}
	return TCL_OK;
}

int
doit1( cd, interp, argc, argv )
ClientData	cd;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
	int	wl;
	char	buf[32];

	if( argc != 2 )  {
		interp->result = "Usage: doit1 wavel#";
		return TCL_ERROR;
	}
	wl = atoi(argv[1]);
	if( wl < 0 || wl >= spectrum->nx )  {
		interp->result = "Wavelength number out of range";
		return TCL_ERROR;
	}

	if( !data )  {
		interp->result = "pixel data table not loaded yet";
		return TCL_ERROR;
	}

	rt_log("doit1 %d: %g um to %g um\n",
		wl,
		spectrum->x[wl] * 0.001,
		spectrum->x[wl+1] * 0.001 );
	if( use_cie_xyz )
		show_color(wl);
	else
		rescale(wl);
	fb_writerect( fbp, 0, 0, width, height, pixels );
	fb_poll(fbp);

	/* export C variables to TCL, one-way */
	/* These are being traced by Tk, this will cause update */
	sprintf(buf, "%d", wl);
	Tcl_SetVar(interp, "x", buf, TCL_GLOBAL_ONLY);
	sprintf(buf, "%g", spectrum->x[wl] * 0.001);
	Tcl_SetVar(interp, "lambda", buf, TCL_GLOBAL_ONLY);

	return TCL_OK;
}

/*
 */
void
find_minmax()
{
	char			*cp;
	int			todo;
	register fastf_t	max, min;
	int		nbytes;
	int		j;

	cp = (char *)data;
	nbytes = RT_SIZEOF_TABDATA(spectrum);

	max = -INFINITY;
	min =  INFINITY;

	for( todo = width * height; todo > 0; todo--, cp += nbytes )  {
		struct rt_tabdata	*sp;
		sp = (struct rt_tabdata *)cp;
		RT_CK_TABDATA(sp);
		for( j = 0; j < spectrum->nx; j++ )  {
			register fastf_t	v;

			if( (v = sp->y[j]) > max )  max = v;
			if( v < min )  min = v;
		}
	}
	maxval = max;
	minval = min;
}

/*
 *			R E S C A L E
 *
 *  Create monochrome image from the spectral data, at wavelength 'wav',
 *  given current min & max values.
 */
void
rescale(wav)
int	wav;
{
	char		*cp;
	unsigned char	*pp;
	int		todo;
	int		nbytes;
	fastf_t		scale;
	fastf_t		atmos_scale;

	cp = (char *)data;
	nbytes = RT_SIZEOF_TABDATA(spectrum);

	pp = pixels;

	scale = 255 / (maxval - minval);

	if( use_atmosphere )
		atmos_scale = atmosphere->y[wav];
	else
		atmos_scale = 1;

	for( todo = width * height; todo > 0; todo--, cp += nbytes, pp += 3 )  {
		struct rt_tabdata	*sp;
		register int		val;

		sp = (struct rt_tabdata *)cp;
		RT_CK_TABDATA(sp);

		val = (sp->y[wav] * atmos_scale - minval) * scale;
		if( val > 255 )  val = 255;
		else if( val < 0 ) val = 0;
		pp[0] = pp[1] = pp[2] = val;
	}
}


/*
 *			S H O W _ C O L O R
 *
 *  Create color image from spectral curve,
 *  given current min & max values, and frequency offset (in nm).
 *  Go via CIE XYZ space.
 */
void
show_color(off)
int	off;
{
	char		*cp;
	unsigned char	*pp;
	int		todo;
	int		nbytes;
	fastf_t		scale;

	cp = (char *)data;
	nbytes = RT_SIZEOF_TABDATA(spectrum);

	pp = pixels;

	scale = 255 / (maxval - minval);

	/* Build CIE curves */
	rt_spect_make_CIE_XYZ( &cie_x, &cie_y, &cie_z, spectrum );

	if( use_atmosphere )  {
		rt_tabdata_mul( cie_x, cie_x, atmosphere );
		rt_tabdata_mul( cie_y, cie_y, atmosphere );
		rt_tabdata_mul( cie_z, cie_z, atmosphere );
	}

	for( todo = width * height; todo > 0; todo--, cp += nbytes, pp += 3 )  {
		struct rt_tabdata	*sp;
		point_t			xyz;
		point_t			rgb;
		register int		val;

		sp = (struct rt_tabdata *)cp;
		RT_CK_TABDATA(sp);

		/* rt_spect_curve_to_xyz( xyz, sp, cie_x, cie_y, cie_z ); */
		xyz[X] = rt_tabdata_mul_area1( sp, cie_x );
		xyz[Y] = rt_tabdata_mul_area1( sp, cie_y );
		xyz[Z] = rt_tabdata_mul_area1( sp, cie_z );

		MAT3X3VEC( rgb, xyz2rgb, xyz );

		val = (rgb[RED] - minval) * scale;
		if( val > 255 )  val = 255;
		else if( val < 0 ) val = 0;
		pp[RED] = val;

		val = (rgb[GRN] - minval) * scale;
		if( val > 255 )  val = 255;
		else if( val < 0 ) val = 0;
		pp[GRN] = val;

		val = (rgb[BLU] - minval) * scale;
		if( val > 255 )  val = 255;
		else if( val < 0 ) val = 0;
		pp[BLU] = val;
	}
}
@


1.22
log
@Expanded to show blackbody curves
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.21 1998/10/09 21:32:14 mike Exp $ (ARL)";
@


1.21
log
@Added code to plot the rgb reflectance curves.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.20 1998/10/09 21:17:28 mike Exp $ (ARL)";
d138 1
d169 23
@


1.20
log
@Added assign_tabdata_to_tcl_var().
Now an arbitrary collection of curves can be sent up to the Tcl code
for plotting.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.19 1998/10/09 05:52:30 mike Exp $ (ARL)";
d95 2
a96 2
	Tcl_SetVar( interp, name, bu_vls_addr(&str), 0 );
	Tcl_AppendResult( interp, (char *)name, " ", (char *)NULL );
d121 1
d126 43
@


1.19
log
@Changed rt_tabdata_resample(), which had bad aliasing, into
rt_tabdata_resample_max() and rt_tabdata_resample_avg().
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.18 1998/10/09 02:19:05 mike Exp $ (ARL)";
d77 25
a111 21
	struct bu_vls	str;

	bu_vls_init(&str);

	/* These are the curves as fitted to our spectrum sampling */
	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, ntsc_r);
	Tcl_SetVar( interp, "ntsc_r", bu_vls_addr(&str), 0 );

	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, ntsc_g);
	Tcl_SetVar( interp, "ntsc_g", bu_vls_addr(&str), 0 );

	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, ntsc_b);
	Tcl_SetVar( interp, "ntsc_b", bu_vls_addr(&str), 0 );

	Tcl_AppendResult( interp, "ntsc_r ntsc_g ntsc_b", (char *)NULL );

	{
	/* These are the curves from the data tables in the library */
d116 4
a119 12
	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, rt_NTSC_r_tabdata);
	Tcl_SetVar( interp, "ntsc_r_orig", bu_vls_addr(&str), 0 );

	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, rt_NTSC_g_tabdata);
	Tcl_SetVar( interp, "ntsc_g_orig", bu_vls_addr(&str), 0 );

	bu_vls_trunc(&str, 0);
	rt_tabdata_to_tcl(&str, rt_NTSC_b_tabdata);
	Tcl_SetVar( interp, "ntsc_b_orig", bu_vls_addr(&str), 0 );
	}
d121 4
a124 1
	bu_vls_free(&str);
a125 1
	Tcl_AppendResult( interp, "ntsc_r_orig ntsc_g_orig ntsc_b_orig", (char *)NULL );
@


1.18
log
@disp.c: broke out testing support separate from file display functions.
disp.tcl: decent support for plotting spectra
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.17 1998/10/07 22:28:57 mike Exp $ (ARL)";
d502 1
a502 1
	atmosphere = rt_tabdata_resample( spectrum, atmosphere_orig );
@


1.17
log
@Added additional error checking.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.16 1998/10/07 07:49:56 mike Exp $ (ARL)";
d74 57
d198 6
d246 5
d342 5
d356 1
d366 3
d372 1
a372 1
	Tcl_SetVar(interp, "tcl_rcFileName", "./disp.tcl", TCL_GLOBAL_ONLY);
d418 2
a419 3
int
main( argc, argv )
char	**argv;
d421 2
a422 2

	rt_g.debug = 1;
d424 3
a426 9
	rt_make_ntsc_xyz2rgb( xyz2rgb );

#if 1
{
struct rt_tabdata	*flat;
vect_t			xyz;
/* Code for testing library routines */
spectrum = rt_table_make_uniform( 20, 380.0, 770.0 );
rt_spect_make_CIE_XYZ( &cie_x, &cie_y, &cie_z, spectrum );
d431 1
a431 1
rt_spect_make_NTSC_RGB( &ntsc_r, &ntsc_g, &ntsc_b, spectrum );
d444 33
a476 4
flat = rt_tabdata_get_constval( 42.0, spectrum );
bu_log("flat:\n");rt_pr_table_and_tabdata( "/dev/tty", flat );
rt_spect_curve_to_xyz(xyz, flat, cie_x, cie_y, cie_z );
VPRINT("flat xyz?", xyz);
d478 8
a485 16
/* Check identity of XYZ->RGB->spectrum->XYZ->RGB */
check( 0.313,     0.329,      0.358);	/* D6500 white */
check( 0.670,     0.330,      0.000);	/* NTSC red primary */
check( 0.210,     0.710,      0.080);	/* NTSC green primary */
check( 0.140,     0.080,      0.780);	/* NTSC blue primary */
check( .5, .5, .5 );
check( 1, 0, 0 );
check( 0, 1, 0 );
check( 0, 0, 1 );
check( 1, 1, 1 );
check( 1, 1, 0 );
check( 1, 0, 1 );
check( 0, 1, 1 );
exit(1);
}
#endif
d513 1
a513 1
	Tk_Main( argc, argv, tcl_appinit );
d556 6
a561 1
	rt_log("%d: %g um to %g um\n",
@


1.16
log
@Improved testing.
Check identity of XYZ->RGB->spectrum->XYZ->RGB
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.15 1998/10/07 07:37:11 mike Exp $ (ARL)";
d153 44
d282 1
d325 1
a325 1
	rt_spect_rgb_to_curve( tabp, rgb, ntsc_r, ntsc_g, ntsc_b );
d355 1
a355 1
spectrum = rt_table_make_uniform( 10, 380.0, 770.0 );
d365 7
d380 5
a391 1
check( .5, .5, .5 );
@


1.15
log
@Called rt_spect_make_NTSC_RGB() to test support tables and routines.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.14 1998/09/30 04:31:49 mike Exp $ (ARL)";
d56 1
d257 1
a257 1
/* Check XYZ value to spectrum and back */
d263 2
a264 1
	point_t	new;
d274 2
d277 5
d286 5
a290 1
	rt_spect_curve_to_xyz( new, tabp, cie_x, cie_y, cie_z );
a291 1
	VPRINT( "new xyz", new );
d303 2
d327 1
a327 1
/* Check identity of XYZ->spectrum->XYZ */
a338 2

	rt_make_ntsc_xyz2rgb( xyz2rgb );
@


1.14
log
@Expanding on validation tests.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.13 1998/09/30 02:22:18 mike Exp $ (ARL)";
d57 4
d301 5
@


1.13
log
@Upgraded for Tcl8.0
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/disp.c,v 1.12 1996/04/06 04:30:54 mike Exp $ (ARL)";
d260 1
d266 1
a266 1
	VPRINT( "\nxyz", xyz );
d270 2
d275 1
a275 1
	VPRINT( "new", new );
d287 4
a290 1
#if 0
d294 11
a304 3
rt_pr_table_and_tabdata( "/dev/tty", cie_x );
rt_pr_table_and_tabdata( "/dev/tty", cie_y );
rt_pr_table_and_tabdata( "/dev/tty", cie_z );
d314 1
@


1.12
log
@Added some testing code.
Changed xyz conversion, probably still not right.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.11 1996/04/06 01:09:12 mike Exp mike $ (ARL)";
d22 1
d24 2
d27 1
a27 1
#include "rtstring.h"
d57 1
a57 1
char	*pixels;		/* en-route to framebuffer */
d65 3
d242 1
d244 2
a245 1
	tcl_RcFileName = "./disp.tcl";
d250 2
a251 1
extern check( double x, double y, double z);
d253 1
d277 1
d325 1
a325 1
	pixels = rt_malloc( width * height * 3, "pixels[]" );
d350 1
a350 1

d396 1
d432 1
d437 1
a437 1
	char		*pp;
d477 1
d482 1
a482 1
	char		*pp;
@


1.11
log
@Added new header file.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.10 1996/03/16 00:52:32 mike Exp mike $ (ARL)";
d242 25
d273 18
d307 1
a307 1
	rt_table_scale( atmosphere_orig->table, 1000.0 );
a471 1
	struct rt_tabdata	*xyzsamp;
a476 1
	RT_GET_TABDATA(xyzsamp, spectrum);
d498 4
a501 3
		/* XXX For efficiency, these two steps could be done together */
		rt_tabdata_mul( xyzsamp, sp, cie_x );
		xyz[X] = rt_tabdata_area1( xyzsamp );
a502 6
		rt_tabdata_mul( xyzsamp, sp, cie_y );
		xyz[Y] = rt_tabdata_area1( xyzsamp );

		rt_tabdata_mul( xyzsamp, sp, cie_z );
		xyz[Z] = rt_tabdata_area1( xyzsamp );

a519 1
	rt_free( (char *)xyzsamp, "xyz sample");
@


1.10
log
@Converting over to table data structures.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.9 1996/03/14 07:25:02 mike Exp $ (ARL)";
d26 1
d457 1
@


1.9
log
@Added real conversion from XYZ to RGB space.
@
text
@d2 2
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.8 1996/03/14 04:58:40 mike Exp mike $ (ARL)";
d39 1
a39 1
struct rt_spectrum	*spectrum;
d41 1
a41 1
struct rt_spect_sample	*ss;
d43 2
a44 2
struct rt_spect_sample	*atmosphere_orig;
struct rt_spect_sample	*atmosphere;
d47 3
a49 3
struct rt_spect_sample	*cie_x;
struct rt_spect_sample	*cie_y;
struct rt_spect_sample	*cie_z;
d78 1
a78 1
	RT_CK_SPECTRUM(spectrum);
d81 1
a81 1
		sprintf( interp->result, "%d", spectrum->nwave );
d90 1
a90 1
	if( wl < 0 || wl > spectrum->nwave )  {
d92 1
a92 1
			wl, spectrum->nwave);
d95 1
a95 1
	sprintf( interp->result, "%g", spectrum->wavel[wl] );
d106 1
a106 1
	struct rt_spect_sample	*sp;
d119 1
a119 1
	RT_CK_SPECTRUM(spectrum);
d125 1
a125 1
	if( wl < 0 || wl >= spectrum->nwave )  {
d129 5
a133 5
	cp = (char *)ss;
	cp = cp + (y * width + x) * RT_SIZEOF_SPECT_SAMPLE(spectrum);
	sp = (struct rt_spect_sample *)cp;
	RT_CK_SPECT_SAMPLE(sp);
	val = sp->val[wl];
d135 1
a135 1
		val *= atmosphere->val[wl];
a240 43
/*
 */
struct rt_spect_sample *
rt_spect_sample_binary_read( filename, num, spect )
CONST char			*filename;
int				num;
CONST struct rt_spectrum	*spect;
{
	struct rt_spect_sample	*ss;
	char	*cp;
	int	nbytes;
	int	len;
	int	fd;
	int	i;

	RT_CK_SPECTRUM(spect);

	nbytes = RT_SIZEOF_SPECT_SAMPLE(spect);
	len = num * nbytes;
	ss = (struct rt_spect_sample *)rt_malloc( len+8, "rt_spect_sample[]" );

	if( (fd = open(basename, 0)) <= 0 )  {
		perror(basename);
		rt_bomb("Unable to open spectral samples\n");
	}
	if( read( fd, (char *)ss, len ) != len )  {
		rt_bomb("Read of spectral samples failed\n");
	}
	close(fd);

	/* Connect ss[i].spectrum pointer to spect */
	cp = (char *)ss;
	for( i = num-1; i >= 0; i--, cp += nbytes )  {
		register struct rt_spect_sample	*sp;

		sp = (struct rt_spect_sample *)cp;
		RT_CK_SPECT_SAMPLE(sp);
		sp->spectrum = spect;
	}

	return ss;
}

d256 1
a256 1
	spectrum = (struct rt_spectrum *)rt_read_spectrum( spectrum_name );
d262 3
a264 3
	atmosphere_orig = rt_read_spectrum_and_samples( "std_day_1km.dat" );
	rt_spectrum_scale( atmosphere_orig->spectrum, 1000.0 );
	atmosphere = rt_spect_resample( spectrum, atmosphere_orig );
d267 1
a267 1
	ss = rt_spect_sample_binary_read( basename, width*height, spectrum );
d291 1
a291 1
	for( wl = 0; wl < spectrum->nwave; wl++ )  {
d313 1
a313 1
	if( wl < 0 || wl >= spectrum->nwave )  {
d320 2
a321 2
		spectrum->wavel[wl] * 0.001,
		spectrum->wavel[wl+1] * 0.001 );
d332 2
a333 2
	Tcl_SetVar(interp, "wavel", buf, TCL_GLOBAL_ONLY);
	sprintf(buf, "%g", spectrum->wavel[wl] * 0.001);
d349 2
a350 2
	cp = (char *)ss;
	nbytes = RT_SIZEOF_SPECT_SAMPLE(spectrum);
d356 4
a359 4
		struct rt_spect_sample	*sp;
		sp = (struct rt_spect_sample *)cp;
		RT_CK_SPECT_SAMPLE(sp);
		for( j = 0; j < spectrum->nwave; j++ )  {
d362 1
a362 1
			if( (v = sp->val[j]) > max )  max = v;
d386 2
a387 2
	cp = (char *)ss;
	nbytes = RT_SIZEOF_SPECT_SAMPLE(spectrum);
d394 1
a394 1
		atmos_scale = atmosphere->val[wav];
d399 1
a399 1
		struct rt_spect_sample	*sp;
d402 2
a403 2
		sp = (struct rt_spect_sample *)cp;
		RT_CK_SPECT_SAMPLE(sp);
d405 1
a405 1
		val = (sp->val[wav] * atmos_scale - minval) * scale;
d428 1
a428 1
	struct rt_spect_sample	*xyzsamp;
d430 2
a431 2
	cp = (char *)ss;
	nbytes = RT_SIZEOF_SPECT_SAMPLE(spectrum);
d434 1
a434 1
	RT_GET_SPECT_SAMPLE(xyzsamp, spectrum);
d442 3
a444 3
		rt_spect_mul( cie_x, cie_x, atmosphere );
		rt_spect_mul( cie_y, cie_y, atmosphere );
		rt_spect_mul( cie_z, cie_z, atmosphere );
d448 1
a448 1
		struct rt_spect_sample	*sp;
d453 2
a454 2
		sp = (struct rt_spect_sample *)cp;
		RT_CK_SPECT_SAMPLE(sp);
d456 2
a457 2
		rt_spect_mul( xyzsamp, sp, cie_x );
		xyz[X] = rt_spect_area1( xyzsamp );
d459 2
a460 2
		rt_spect_mul( xyzsamp, sp, cie_y );
		xyz[Y] = rt_spect_area1( xyzsamp );
d462 2
a463 2
		rt_spect_mul( xyzsamp, sp, cie_z );
		xyz[Z] = rt_spect_area1( xyzsamp );
@


1.8
log
@Added CIE display
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.7 1996/03/09 05:37:45 mike Exp mike $ (ARL)";
d49 1
d288 2
d490 2
a491 1
		fastf_t			x, y, z;
d498 1
a498 1
		x = rt_spect_area1( xyzsamp );
d501 1
a501 1
		y = rt_spect_area1( xyzsamp );
d504 1
a504 1
		z = rt_spect_area1( xyzsamp );
d506 3
a508 1
		val = (x - minval) * scale;
d511 1
a511 1
		pp[0] = val;
d513 1
a513 1
		val = (y - minval) * scale;
d516 1
a516 1
		pp[1] = val;
d518 1
a518 1
		val = (z - minval) * scale;
d521 1
a521 1
		pp[2] = val;
@


1.7
log
@Added support for "Standard" atmosphere.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.6 1996/03/09 03:21:08 mike Exp $ (ARL)";
d45 5
d230 1
d238 7
a244 2
main( argc, argv )
char	**argv;
d246 3
d253 32
d304 4
a307 2
	len = width * height * RT_SIZEOF_SPECT_SAMPLE(spectrum);
	ss = (struct rt_spect_sample *)rt_malloc( len, "rt_spect_sample" );
a309 10
	if( (fd = open(basename, 0)) <= 0 )  {
		perror(basename);
		rt_bomb("Unable to open spectral samples\n");
	}
	if( read( fd, (char *)ss, len ) != len )  {
		rt_bomb("Read of spectral samples failed\n");
	}
	close(fd);


d360 4
a363 1
	rescale(wl);
d448 70
@


1.6
log
@Addef fb_readpixel support
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.5 1996/03/09 01:01:01 mike Exp $ (ARL)";
d29 2
a30 2
int	width = 64;
int	height = 64;
d41 3
a43 1
char	*pixels;
d45 1
a45 1
fastf_t	maxval, minval;
d47 2
d101 1
d125 4
a128 1
	sprintf( interp->result, "%g", sp->val[wl] );
d224 1
d239 2
d253 5
d326 2
a327 1
	/* set global variables */
d368 4
d381 1
d390 5
d402 1
a402 1
		val = (sp->val[wav] - minval) * scale;
@


1.5
log
@Improvements
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.4 1996/03/09 00:50:42 mike Exp mike $ (ARL)";
d157 3
d161 30
d203 1
@


1.4
log
@Working version
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.3 1996/03/08 05:53:35 mike Exp mike $ (ARL)";
d50 7
d66 6
d73 1
a73 1
		interp->result = "Usage: getspectrum wl";
d78 3
a80 4
	RT_CK_SPECTRUM(spectrum);

	if( wl < 0 || wl >= spectrum->nwave )  {
		interp->result = "wavelength out of range";
d182 3
@


1.3
log
@More complete TCL/Tk interface.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.2 1996/03/08 03:04:09 mike Exp mike $ (ARL)";
d112 4
d117 29
d157 2
a317 3
#if 1
	rt_log(" scale = %g, 255 =? %g\n", scale, maxval * scale);
#endif
@


1.2
log
@Initial TCL/Tk support
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/disp.c,v 1.1 1996/03/01 06:03:46 mike Exp mike $ (ARL)";
d51 25
d104 2
a105 1
	cp = pixels + (y * RT_SIZEOF_SPECT_SAMPLE(spectrum) + x) * RT_SIZEOF_SPECT_SAMPLE(spectrum);
d120 4
d127 2
a128 3
	tkwin = Tk_CreateMainWindow( interp, (char *)NULL, "disp", "disp" );
	if( tkwin == NULL )  return TCL_ERROR;
	Tk_GeometryRequest(tkwin, 100, 20);
d130 2
a131 2
	/* Run tk.tcl script */
	if( Tk_Init(interp) == TCL_ERROR )  return TCL_ERROR;
d133 2
a134 3
	/* Handle any delayed events which result */
	while (Tk_DoOneEvent(TK_DONT_WAIT | TK_ALL_EVENTS))
		;
d175 1
a175 1
	Tcl_Main( argc, argv, tcl_appinit );
d206 1
d225 8
a280 4

	/* Hack the scaling */
	minval = maxval * 0.001;
	maxval = maxval * 0.9;
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/spectrum.c,v 1.9 1996/02/28 03:21:17 mike Exp $ (ARL)";
d26 2
d45 66
d112 1
d143 1
d147 19
a165 6
	for( i = 0; i < spectrum->nwave; i++ )  {
		rt_log("%g um to %g um\n", spectrum->wavel[i] * 0.001,
			spectrum->wavel[i+1] * 0.001 );
		rescale(i);
		fb_writerect( fbp, 0, 0, width, height, pixels );
		fb_poll(fbp);
d167 29
a195 1
	return 0;
@
