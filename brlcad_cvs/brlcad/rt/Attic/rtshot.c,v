head	11.31;
access;
symbols
	ansi-20040405-merged:11.24.2.2
	postmerge-20040405-ansi:11.29
	premerge-20040404-ansi:11.28
	postmerge-autoconf:11.28
	autoconf-freeze:11.27.2.2
	premerge-autoconf:11.28
	postmerge-20040315-windows:11.28
	premerge-20040315-windows:11.28
	windows-20040315-freeze:11.24.4.1
	autoconf-20031203:11.27
	autoconf-20031202:11.27
	autoconf-branch:11.27.0.2
	phong-branch:11.26.0.2
	photonmap-branch:11.24.0.6
	rel-6-1-DP:11.24
	windows-branch:11.24.0.4
	rel-6-0-2:11.22
	ansi-branch:11.24.0.2
	rel-6-0-1-branch:11.22.0.2
	hartley-6-0-post:11.23
	hartley-6-0-pre:11.22
	rel-6-0-1:11.22
	rel-6-0:11.22
	rel-5-4:11.14
	offsite-5-3-pre:11.17
	rel-5-3:11.14
	rel-5-2:11.14
	rel-5-1-branch:11.14.0.2
	rel-5-1:11.14
	rel-5-0:11.9
	rel-5-0-beta:11.9
	rel-4-5:11.8
	ctj-4-5-post:11.8
	ctj-4-5-pre:11.8
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.31
date	2004.05.21.17.31.07;	author morrison;	state dead;
branches;
next	11.30;

11.30
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.29;

11.29
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches
	11.27.2.1;
next	11.26;

11.26
date	2003.09.03.17.58.59;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2003.08.13.15.24.02;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.24.2.1
	11.24.4.1
	11.24.6.1;
next	11.23;

11.23
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.22;

11.22
date	2001.12.18.16.21.32;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2001.08.11.13.18.27;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	2001.06.22.20.43.17;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2001.05.29.19.06.58;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2001.04.02.15.05.14;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	2000.08.17.02.41.36;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.07.27.19.32.52;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	2000.05.23.02.43.25;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.05.19.14.35.24;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	2000.05.19.14.18.50;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2000.05.18.20.23.28;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	99.12.22.02.28.04;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.05.28.01.17.26;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.05.28.14.40.46;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	97.01.21.20.47.16;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	97.01.02.21.08.10;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.03.29.21.55.48;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.03.29.21.00.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.25.15.54.10;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.59;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.08.11.00.40.44;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.00.40.01;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.06.28.10.33.39;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.03;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.08.31.06.54.10;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.25;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	88.10.06.03.24.30;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.33.18;	author mike;	state Rel3_0;
branches;
next	7.9;

7.9
date	88.09.19.22.45.01;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.07.07.22.25.53;	author phil;	state Exp;
branches;
next	7.7;

7.7
date	88.07.07.21.51.41;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.05.20.03.23.20;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.05.14.02.28.20;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.02.27.03.09.49;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.12.01.10.19;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.04.58.24;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.19;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.28.19.48.41;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.59.14;	author mike;	state Rel;
branches;
next	5.2;

5.2
date	87.07.09.03.31.00;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.15.18;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.05.31.04.47.40;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.05.30.04.55.45;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.05.29.05.19.32;	author mike;	state Exp;
branches;
next	;

11.24.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	11.24.2.2;

11.24.2.2
date	2004.03.17.21.22.59;	author morrison;	state Exp;
branches;
next	;

11.24.4.1
date	2004.03.11.23.48.07;	author morrison;	state Exp;
branches;
next	;

11.24.6.1
date	2003.08.26.13.56.38;	author justin;	state Exp;
branches;
next	;

11.27.2.1
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	11.27.2.2;

11.27.2.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@Shoot a single ray at a model.  For debugging.
@


11.31
log
@moved to src/rt/
@
text
@/*
 *			R T S H O T . C 
 *
 *  Demonstration Ray Tracing main program, using RT library.
 *  Fires a single ray, given any two of these three parameters:
 *	start point
 *	at point
 *	direction vector
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/rtshot.c,v 11.30 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <ctype.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "../librt/debug.h"
#include "plot3.h"

extern void rt_raybundle_maker( struct xray	*rp,
				double		radius,
				const vect_t	avec,
				const vect_t	bvec,
				int		rays_per_ring,
				int		nring);

extern int rt_shootray_bundle( struct application *ap,
			       struct xray		*rays,
			       int			nrays);

char	usage[] = "\
Usage:  rtshot [options] model.g objects...\n\
 -U #		Set use_air flag\n\
 -u #		Set libbu debug flag\n\
 -x #		Set librt debug flags\n\
 -X #		Set rt program debug flags\n\
 -N #		Set NMG debug flags\n\
 -d # # #	Set direction vector\n\
 -p # # #	Set starting point\n\
 -a # # #	Set shoot-at point\n\
 -t #		Set number of triangles per piece for BOT's (default is 4)\n\
 -b #		Set threshold number of triangles to use pieces (default is 32)\n\
 -O #		Set overlap-claimant handling\n\
 -o #		Set onehit flag\n\
 -r #		Set ray length\n\
 -n #		Set number of rings for ray bundle\n\
 -c #		Set number of rays per ring for ray bundle\n\
 -R #		Set radius for ray bundle\n\
 -v \"attribute_name1 attribute_name2 ...\" Show attribute values\n";

static FILE	*plotfp;		/* For plotting into */

struct application	ap;

int		set_dir = 0;
int		set_pt = 0;
int		set_at = 0;
int		set_onehit = 0;
fastf_t		set_ray_length = 0.0;
vect_t		at_vect;
int		overlap_claimant_handling = 0;
int		use_air = 0;		/* Handling of air */
int		rays_per_ring = 0;
int		num_rings = 0;
fastf_t		bundle_radius = 0.0;

extern int hit(struct application *ap, struct partition *PartHeadp), miss(register struct application *ap);
extern int rt_bot_tri_per_piece;
extern int rt_bot_minpieces;

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	static struct rt_i *rtip;
	char *title_file;
	char idbuf[132];		/* First ID record info */
	char *ptr;
	int attr_count=0, i;
	char **attrs = (char **)NULL;

	if( argc < 3 )  {
		(void)fputs(usage, stderr);
		exit(1);
	}

	bzero( &ap, sizeof( struct application ) );

	argc--;
	argv++;
	while( argv[0][0] == '-' ) switch( argv[0][1] )  {
	case 'R':
		bundle_radius = atof( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'n':
		num_rings = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'c':
		rays_per_ring = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'v':
		/* count the number of attribute names provided */
		ptr = argv[1];
		while( *ptr ) {
			while( *ptr && isspace( *ptr ) )
				ptr++;
			if( *ptr )
				attr_count++;
			while( *ptr && !isspace( *ptr ) )
				ptr++;
		}

		if( attr_count == 0 ) {
			bu_log( "missing list of attribute names!!!\n" );
			(void)fputs(usage, stderr);
			exit( 1 );
		}

		/* allocate enough for a null terminated list */
		attrs = (char **)bu_calloc( attr_count + 1, sizeof( char *), "attrs" );

		/* use strtok to actually grab the names */
		i = 0;
		ptr = strtok( argv[1], "\t " );
		while( ptr && i < attr_count ) {
			attrs[i] = bu_strdup( ptr );
			ptr = strtok( (char *)NULL, "\t " );
			i++;
		}
		argc -= 2;
		argv += 2;
		break;
	case 't':
		rt_bot_tri_per_piece = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'b':
		rt_bot_minpieces = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'o':
		sscanf( argv[1], "%d", &set_onehit );
		argc -= 2;
		argv += 2;
		break;
	case 'r':
		{
			float ray_len;

			sscanf( argv[1], "%f", &ray_len );
			set_ray_length = ray_len;
		}
		argc -= 2;
		argv += 2;
		break;
	case 'U':
		sscanf( argv[1], "%d", &use_air );
		argc -= 2;
		argv += 2;
		break;
	case 'u':
		sscanf( argv[1], "%x", (unsigned int *)&bu_debug );
		fprintf(stderr,"librt bu_debug=x%x\n", bu_debug);
		argc -= 2;
		argv += 2;
		break;
	case 'x':
		sscanf( argv[1], "%x", (unsigned int *)&rt_g.debug );
		fprintf(stderr,"librt rt_g.debug=x%x\n", rt_g.debug);
		argc -= 2;
		argv += 2;
		break;
	case 'X':
		sscanf( argv[1], "%x", (unsigned int *)&rdebug );
		fprintf(stderr,"rdebug=x%x\n", rdebug);
		argc -= 2;
		argv += 2;
		break;
	case 'N':
		sscanf( argv[1], "%x", (unsigned int *)&rt_g.NMG_debug);
		fprintf(stderr,"librt rt_g.NMG_debug=x%x\n", rt_g.NMG_debug);
		argc -= 2;
		argv += 2;
		break;
	case 'd':
		if( argc < 4 )  goto err;
		ap.a_ray.r_dir[X] = atof( argv[1] );
		ap.a_ray.r_dir[Y] = atof( argv[2] );
		ap.a_ray.r_dir[Z] = atof( argv[3] );
		set_dir = 1;
		argc -= 4;
		argv += 4;
		continue;

	case 'p':
		if( argc < 4 )  goto err;
		ap.a_ray.r_pt[X] = atof( argv[1] );
		ap.a_ray.r_pt[Y] = atof( argv[2] );
		ap.a_ray.r_pt[Z] = atof( argv[3] );
		set_pt = 1;
		argc -= 4;
		argv += 4;
		continue;

	case 'a':
		if( argc < 4 )  goto err;
		at_vect[X] = atof( argv[1] );
		at_vect[Y] = atof( argv[2] );
		at_vect[Z] = atof( argv[3] );
		set_at = 1;
		argc -= 4;
		argv += 4;
		continue;

	case 'O':
		{
			if( !strcmp( argv[1], "resolve" ) || !strcmp( argv[1], "0") )
				overlap_claimant_handling = 0;
			else if( !strcmp( argv[1], "rebuild_fastgen" ) || !strcmp( argv[1], "1") )
				overlap_claimant_handling = 1;
			else if( !strcmp( argv[1], "rebuild_all" ) || !strcmp( argv[1], "2") )
				overlap_claimant_handling = 2;
			else if( !strcmp( argv[1], "retain" ) || !strcmp( argv[1], "3") )
				overlap_claimant_handling = 3;
			else
			{
				bu_log( "Illegal argument (%s) to '-O' option.  Must be:\n", argv[1] );
				bu_log( "\t'resolve' or '0'\n");
				bu_log( "\t'rebuild_fastgen' or '1'\n");
				bu_log( "\t'rebuild_all' or '2'\n");
				bu_log( "\t'retain' or '3'\n");
				exit( 1 );
			}
			argc -= 2;
			argv += 2;
		}
		continue;

	default:
err:
		(void)fputs(usage, stderr);
		exit(1);
	}
	if( argc < 2 )  {
		fprintf(stderr,"rtshot: MGED database not specified\n");
		(void)fputs(usage, stderr);
		exit(1);
	}

	if( set_dir + set_pt + set_at != 2 )  goto err;

	if( num_rings != 0 || rays_per_ring != 0 || bundle_radius != 0.0 ) {
		if( num_rings <= 0 || rays_per_ring <= 0 || bundle_radius <= 0.0 ) {
			fprintf( stderr, "Must have all of \"-R\", \"-n\", and \"-c\" set\n" );
			goto err;
		}
	}

	/* Load database */
	title_file = argv[0];
	argv++;
	argc--;
	if( (rtip=rt_dirbuild(title_file, idbuf, sizeof(idbuf))) == RTI_NULL ) {
		fprintf(stderr,"rtshot:  rt_dirbuild failure\n");
		exit(2);
	}

	if( overlap_claimant_handling )
		rtip->rti_save_overlaps = 1;

	ap.a_rt_i = rtip;
	fprintf(stderr, "db title:  %s\n", idbuf);
	rtip->useair = use_air;

	/* Walk trees */
	if( rt_gettrees_muves( rtip, (const char **)attrs, argc, (const char **)argv, 1 ) ) {
		fprintf(stderr,"rt_gettrees FAILED\n");
		exit( 1 );
	}
	ap.attrs = attrs;

	rt_prep(rtip);

	if( R_DEBUG&RDEBUG_RAYPLOT )  {
		if( (plotfp = fopen("rtshot.plot", "w")) == NULL )  {
			perror("rtshot.plot");
			exit(1);
		}
		pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
	}

	/* Compute r_dir and r_pt from the inputs */
	if( set_at )  {
		if( set_dir ) {
			vect_t	diag;
			fastf_t	viewsize;
			VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
			viewsize = MAGNITUDE( diag );
			VJOIN1( ap.a_ray.r_pt, at_vect,
				-viewsize/2.0, ap.a_ray.r_dir );
		} else {
			/* set_pt */
			VSUB2( ap.a_ray.r_dir, at_vect, ap.a_ray.r_pt );
		}
	}
	VUNITIZE( ap.a_ray.r_dir );

	if( rays_per_ring ) {
		bu_log( "Central Ray:\n" );
	}
	VPRINT( "Pnt", ap.a_ray.r_pt );
	VPRINT( "Dir", ap.a_ray.r_dir );

	if( set_onehit )
		ap.a_onehit = set_onehit;
	else
		ap.a_onehit = 0;

	if( set_ray_length > 0.0 )
		ap.a_ray_length = set_ray_length;
	else
		ap.a_ray_length = 0.0;

	/* Shoot Ray */
	ap.a_purpose = "main ray";
	ap.a_hit = hit;
	ap.a_miss = miss;

	if( rays_per_ring ) {
		vect_t avec, bvec;
		struct xray *rp;

		/* create orthogonal rays for basis of bundle */
		bn_vec_ortho( avec, ap.a_ray.r_dir );
		VCROSS( bvec, ap.a_ray.r_dir, avec );
		VUNITIZE( bvec );

		rp = (struct xray *)bu_calloc( sizeof( struct xray ),
					       (rays_per_ring * num_rings) + 1,
					       "ray bundle" );
		rp[0] = ap.a_ray;	/* struct copy */
		rp[0].magic = RT_RAY_MAGIC;
		rt_raybundle_maker( rp, bundle_radius, avec, bvec, rays_per_ring, num_rings );
		(void)rt_shootray_bundle( &ap, rp, (rays_per_ring * num_rings) + 1 );
	} else {
		(void)rt_shootray( &ap );
	}

	return(0);
}

int hit(register struct application *ap, struct partition *PartHeadp)
{
	register struct partition *pp;
	register struct soltab *stp;
	struct curvature cur;
	fastf_t out;
	point_t inpt, outpt;
	vect_t	inormal, onormal;

	if( (pp=PartHeadp->pt_forw) == PartHeadp )
		return(0);		/* Nothing hit?? */

	if( overlap_claimant_handling == 1 )
		rt_rebuild_overlaps( PartHeadp, ap, 1 );
	else if( overlap_claimant_handling == 2 )
		rt_rebuild_overlaps( PartHeadp, ap, 0 );

	/* First, plot ray start to inhit */
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
		if( pp->pt_inhit->hit_dist > 0.0001 )  {
			VJOIN1( inpt, ap->a_ray.r_pt,
				pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
			pl_color( plotfp, 0, 0, 255 );
			pdv_3line( plotfp, ap->a_ray.r_pt, inpt );
		}
	}
	for( ; pp != PartHeadp; pp = pp->pt_forw )  {
		matp_t inv_mat;
		Tcl_HashEntry *entry;

		bu_log("\n--- Hit region %s (in %s, out %s) reg_bit = %d\n",
			pp->pt_regionp->reg_name,
			pp->pt_inseg->seg_stp->st_name,
			pp->pt_outseg->seg_stp->st_name,
		        pp->pt_regionp->reg_bit);

		entry = Tcl_FindHashEntry( (Tcl_HashTable *)ap->a_rt_i->Orca_hash_tbl,
					   (char *)pp->pt_regionp->reg_bit );
		if( !entry ) {
			inv_mat = (matp_t)NULL;
		}
		else {
			inv_mat = (matp_t)Tcl_GetHashValue( entry );
			bn_mat_print( "inv_mat", inv_mat );
		}

		if( pp->pt_overlap_reg )
		{
			struct region *pp_reg;
			int j=-1;

			bu_log( "    Claiming regions:\n" );
			while( (pp_reg=pp->pt_overlap_reg[++j]) )
				bu_log( "        %s\n", pp_reg->reg_name );
		}

		/* inhit info */
		stp = pp->pt_inseg->seg_stp;
		VJOIN1( inpt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
		RT_HIT_NORMAL( inormal, pp->pt_inhit, stp, &(ap->a_ray), pp->pt_inflip );
		RT_CURVATURE( &cur, pp->pt_inhit, pp->pt_inflip, stp );

		rt_pr_hit( "  In", pp->pt_inhit );
		VPRINT(    "  Ipoint", inpt );
		VPRINT(    "  Inormal", inormal );
		bu_log(    "   PDir (%g, %g, %g) c1=%g, c2=%g\n",
			V3ARGS(cur.crv_pdir), cur.crv_c1, cur.crv_c2);

		if( inv_mat ) {
			point_t in_trans;

			MAT4X3PNT( in_trans, inv_mat, inpt );
			bu_log( "\ttransformed ORCA inhit = (%g %g %g)\n", V3ARGS( in_trans ) );
		}

		/* outhit info */
		stp = pp->pt_outseg->seg_stp;
		VJOIN1( outpt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir );
		RT_HIT_NORMAL( onormal, pp->pt_outhit, stp, &(ap->a_ray), pp->pt_outflip );
		RT_CURVATURE( &cur, pp->pt_outhit, pp->pt_outflip, stp );

		rt_pr_hit( "  Out", pp->pt_outhit );
		VPRINT(    "  Opoint", outpt );
		VPRINT(    "  Onormal", onormal );
		bu_log(    "   PDir (%g, %g, %g) c1=%g, c2=%g\n",
			V3ARGS(cur.crv_pdir), cur.crv_c1, cur.crv_c2);

		if( inv_mat ) {
			point_t out_trans;
			vect_t dir_trans;

			MAT4X3PNT( out_trans, inv_mat, outpt );
			MAT4X3VEC( dir_trans, inv_mat, ap->a_ray.r_dir );
			VUNITIZE( dir_trans );
			bu_log( "\ttranformed ORCA outhit = (%g %g %g)\n", V3ARGS( out_trans ) );
			bu_log( "\ttransformed ORCA ray direction = (%g %g %g)\n", V3ARGS( dir_trans ) );
		}

		/* Plot inhit to outhit */
		if( R_DEBUG&RDEBUG_RAYPLOT )  {
			if( (out = pp->pt_outhit->hit_dist) >= INFINITY )
				out = 10000;	/* to imply the direction */

			VJOIN1( outpt,
				ap->a_ray.r_pt, out,
				ap->a_ray.r_dir );
			pl_color( plotfp, 0, 255, 255 );
			pdv_3line( plotfp, inpt, outpt );
		}

		{
			struct region *regp = pp->pt_regionp;
			int i;

			if( ap->attrs ) {
				bu_log( "\tattribute values:\n" );
				i = 0;
				while( ap->attrs[i] && regp->attr_values[i] ) {
					bu_log( "\t\t%s:\n", ap->attrs[i] );
					bu_log( "\t\t\tstring rep = %s\n",
						BU_MRO_GETSTRING(regp->attr_values[i]));
					bu_log( "\t\t\tlong rep = %d\n",
						BU_MRO_GETLONG(regp->attr_values[i])); 
					bu_log( "\t\t\tdouble rep = %f\n",
						BU_MRO_GETDOUBLE(regp->attr_values[i]));
					i++;
				}
			}
		}
	}
	return(1);
}

int miss(register struct application *ap)
{
	bu_log("missed\n");
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
		vect_t	out;

		VJOIN1( out, ap->a_ray.r_pt,
			10000, ap->a_ray.r_dir );	/* to imply direction */
		pl_color( plotfp, 190, 0, 0 );
		pdv_3line( plotfp, ap->a_ray.r_pt, out );
	}
	return(0);
}
@


11.30
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/rtshot.c,v 11.29 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.29
log
@merge of ansi-6-0-branch into head
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.28
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.27 2003/09/27 01:11:25 morrison Exp $ (BRL)";
d93 1
a93 1
extern int hit(), miss();
d101 1
a101 3
main(argc, argv)
int argc;
char **argv;
d388 1
a388 3
int hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
d521 1
a521 2
int miss( ap )
register struct application *ap;
@


11.27
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1987 by the United States Army.
d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.26 2003/09/03 17:58:59 jra Exp $ (BRL)";
@


11.27.2.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.28 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.27.2.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.27.2.1 2004/02/12 19:37:13 erikg Exp $ (BRL)";
@


11.26
log
@Added transformed ORCA ray direction output
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.25 2003/08/13 15:24:02 jra Exp $ (BRL)";
a76 1
int		rdebug;			/* RT program debugging (not library) */
d322 1
a322 1
	if( rdebug&RDEBUG_RAYPLOT )  {
d410 1
a410 1
	if( rdebug&RDEBUG_RAYPLOT )  {
d491 1
a491 1
		if( rdebug&RDEBUG_RAYPLOT )  {
d529 1
a529 1
	if( rdebug&RDEBUG_RAYPLOT )  {
@


11.25
log
@Added ray bundle capability
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.24 2002/08/20 17:08:38 jra Exp $ (BRL)";
d465 1
a465 1
			bu_log( "\ttranslated ORCA inhit = (%g %g %g)\n", V3ARGS( in_trans ) );
d482 1
d485 4
a488 1
			bu_log( "\ttranslated ORCA outhit = (%g %g %g)\n", V3ARGS( out_trans ) );
@


11.24
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.22 2001/12/18 16:21:32 jra Exp $ (BRL)";
d46 11
d72 3
d90 3
d118 2
d123 15
d291 7
d347 3
d367 20
a386 1
	(void)rt_shootray( &ap );
@


11.24.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/rtshot.c,v 11.28 2004/02/02 17:39:39 morrison Exp $ (BRL)";
a45 11
extern void rt_raybundle_maker( struct xray	*rp,
				double		radius,
				const vect_t	avec,
				const vect_t	bvec,
				int		rays_per_ring,
				int		nring);

extern int rt_shootray_bundle( struct application *ap,
			       struct xray		*rays,
			       int			nrays);

a60 3
 -n #		Set number of rings for ray bundle\n\
 -c #		Set number of rays per ring for ray bundle\n\
 -R #		Set radius for ray bundle\n\
d63 1
a75 3
int		rays_per_ring = 0;
int		num_rings = 0;
fastf_t		bundle_radius = 0.0;
a100 2
	bzero( &ap, sizeof( struct application ) );

a103 15
	case 'R':
		bundle_radius = atof( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'n':
		num_rings = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'c':
		rays_per_ring = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
a256 7
	if( num_rings != 0 || rays_per_ring != 0 || bundle_radius != 0.0 ) {
		if( num_rings <= 0 || rays_per_ring <= 0 || bundle_radius <= 0.0 ) {
			fprintf( stderr, "Must have all of \"-R\", \"-n\", and \"-c\" set\n" );
			goto err;
		}
	}

d282 1
a282 1
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
a305 3
	if( rays_per_ring ) {
		bu_log( "Central Ray:\n" );
	}
d323 1
a323 20

	if( rays_per_ring ) {
		vect_t avec, bvec;
		struct xray *rp;

		/* create orthogonal rays for basis of bundle */
		bn_vec_ortho( avec, ap.a_ray.r_dir );
		VCROSS( bvec, ap.a_ray.r_dir, avec );
		VUNITIZE( bvec );

		rp = (struct xray *)bu_calloc( sizeof( struct xray ),
					       (rays_per_ring * num_rings) + 1,
					       "ray bundle" );
		rp[0] = ap.a_ray;	/* struct copy */
		rp[0].magic = RT_RAY_MAGIC;
		rt_raybundle_maker( rp, bundle_radius, avec, bvec, rays_per_ring, num_rings );
		(void)rt_shootray_bundle( &ap, rp, (rays_per_ring * num_rings) + 1 );
	} else {
		(void)rt_shootray( &ap );
	}
d348 1
a348 1
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
d402 1
a402 1
			bu_log( "\ttransformed ORCA inhit = (%g %g %g)\n", V3ARGS( in_trans ) );
a418 1
			vect_t dir_trans;
d421 1
a421 4
			MAT4X3VEC( dir_trans, inv_mat, ap->a_ray.r_dir );
			VUNITIZE( dir_trans );
			bu_log( "\ttranformed ORCA outhit = (%g %g %g)\n", V3ARGS( out_trans ) );
			bu_log( "\ttransformed ORCA ray direction = (%g %g %g)\n", V3ARGS( dir_trans ) );
d425 1
a425 1
		if( R_DEBUG&RDEBUG_RAYPLOT )  {
d463 1
a463 1
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
@


11.24.6.1
log
@updated for merging
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.25 2003/08/13 15:24:02 jra Exp $ (BRL)";
a45 11
extern void rt_raybundle_maker( struct xray	*rp,
				double		radius,
				const vect_t	avec,
				const vect_t	bvec,
				int		rays_per_ring,
				int		nring);

extern int rt_shootray_bundle( struct application *ap,
			       struct xray		*rays,
			       int			nrays);

a60 3
 -n #		Set number of rings for ray bundle\n\
 -c #		Set number of rays per ring for ray bundle\n\
 -R #		Set radius for ray bundle\n\
a75 3
int		rays_per_ring = 0;
int		num_rings = 0;
fastf_t		bundle_radius = 0.0;
a100 2
	bzero( &ap, sizeof( struct application ) );

a103 15
	case 'R':
		bundle_radius = atof( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'n':
		num_rings = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'c':
		rays_per_ring = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
a256 7
	if( num_rings != 0 || rays_per_ring != 0 || bundle_radius != 0.0 ) {
		if( num_rings <= 0 || rays_per_ring <= 0 || bundle_radius <= 0.0 ) {
			fprintf( stderr, "Must have all of \"-R\", \"-n\", and \"-c\" set\n" );
			goto err;
		}
	}

a305 3
	if( rays_per_ring ) {
		bu_log( "Central Ray:\n" );
	}
d323 1
a323 20

	if( rays_per_ring ) {
		vect_t avec, bvec;
		struct xray *rp;

		/* create orthogonal rays for basis of bundle */
		bn_vec_ortho( avec, ap.a_ray.r_dir );
		VCROSS( bvec, ap.a_ray.r_dir, avec );
		VUNITIZE( bvec );

		rp = (struct xray *)bu_calloc( sizeof( struct xray ),
					       (rays_per_ring * num_rings) + 1,
					       "ray bundle" );
		rp[0] = ap.a_ray;	/* struct copy */
		rp[0].magic = RT_RAY_MAGIC;
		rt_raybundle_maker( rp, bundle_radius, avec, bvec, rays_per_ring, num_rings );
		(void)rt_shootray_bundle( &ap, rp, (rays_per_ring * num_rings) + 1 );
	} else {
		(void)rt_shootray( &ap );
	}
@


11.24.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.24 2002/08/20 17:08:38 jra Exp $ (BRL)";
d77 1
a77 1
extern int hit(struct application *ap, struct partition *PartHeadp), miss(register struct application *ap);
d85 3
a87 1
main(int argc, char **argv)
d328 3
a330 1
int hit(register struct application *ap, struct partition *PartHeadp)
d459 2
a460 1
int miss(register struct application *ap)
@


11.24.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
a45 11
extern void rt_raybundle_maker( struct xray	*rp,
				double		radius,
				const vect_t	avec,
				const vect_t	bvec,
				int		rays_per_ring,
				int		nring);

extern int rt_shootray_bundle( struct application *ap,
			       struct xray		*rays,
			       int			nrays);

a60 3
 -n #		Set number of rings for ray bundle\n\
 -c #		Set number of rays per ring for ray bundle\n\
 -R #		Set radius for ray bundle\n\
d63 1
a75 3
int		rays_per_ring = 0;
int		num_rings = 0;
fastf_t		bundle_radius = 0.0;
a98 2
	bzero( &ap, sizeof( struct application ) );

a101 15
	case 'R':
		bundle_radius = atof( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'n':
		num_rings = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
	case 'c':
		rays_per_ring = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
a254 7
	if( num_rings != 0 || rays_per_ring != 0 || bundle_radius != 0.0 ) {
		if( num_rings <= 0 || rays_per_ring <= 0 || bundle_radius <= 0.0 ) {
			fprintf( stderr, "Must have all of \"-R\", \"-n\", and \"-c\" set\n" );
			goto err;
		}
	}

d280 1
a280 1
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
a303 3
	if( rays_per_ring ) {
		bu_log( "Central Ray:\n" );
	}
d321 1
a321 20

	if( rays_per_ring ) {
		vect_t avec, bvec;
		struct xray *rp;

		/* create orthogonal rays for basis of bundle */
		bn_vec_ortho( avec, ap.a_ray.r_dir );
		VCROSS( bvec, ap.a_ray.r_dir, avec );
		VUNITIZE( bvec );

		rp = (struct xray *)bu_calloc( sizeof( struct xray ),
					       (rays_per_ring * num_rings) + 1,
					       "ray bundle" );
		rp[0] = ap.a_ray;	/* struct copy */
		rp[0].magic = RT_RAY_MAGIC;
		rt_raybundle_maker( rp, bundle_radius, avec, bvec, rays_per_ring, num_rings );
		(void)rt_shootray_bundle( &ap, rp, (rays_per_ring * num_rings) + 1 );
	} else {
		(void)rt_shootray( &ap );
	}
d344 1
a344 1
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
d398 1
a398 1
			bu_log( "\ttransformed ORCA inhit = (%g %g %g)\n", V3ARGS( in_trans ) );
a414 1
			vect_t dir_trans;
d417 1
a417 4
			MAT4X3VEC( dir_trans, inv_mat, ap->a_ray.r_dir );
			VUNITIZE( dir_trans );
			bu_log( "\ttranformed ORCA outhit = (%g %g %g)\n", V3ARGS( out_trans ) );
			bu_log( "\ttransformed ORCA ray direction = (%g %g %g)\n", V3ARGS( dir_trans ) );
d421 1
a421 1
		if( R_DEBUG&RDEBUG_RAYPLOT )  {
d458 1
a458 1
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
@


11.23
log
@Converted from K&R to ANSI C - RFH
@
text
@d77 1
a77 1
extern int hit(struct application *ap, struct partition *PartHeadp), miss(register struct application *ap);
d85 3
a87 1
main(int argc, char **argv)
d328 3
a330 1
int hit(register struct application *ap, struct partition *PartHeadp)
d459 2
a460 1
int miss(register struct application *ap)
@


11.22
log
@Added -t and -b options for pieces
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.21 2001/08/11 13:18:27 butler Exp $ (BRL)";
d77 1
a77 1
extern int hit(), miss();
d85 1
a85 3
main(argc, argv)
int argc;
char **argv;
d326 1
a326 3
int hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
d455 1
a455 2
int miss( ap )
register struct application *ap;
@


11.21
log
@misc compiler warning changes
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.20 2001/06/22 20:43:17 jra Exp $ (BRL)";
d56 2
d78 2
d136 10
d274 4
a277 2
	if( rt_gettrees_muves( rtip, (const char **)attrs, argc, (const char **)argv, 1 ) )
	fprintf(stderr,"rt_gettrees FAILED\n");
d279 1
@


11.20
log
@The ORCA hash table is now stashed in the rt_i structure
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.19 2001/05/29 19:06:58 jra Exp $ (BRL)";
d153 1
a153 1
		sscanf( argv[1], "%x", &bu_debug );
d159 1
a159 1
		sscanf( argv[1], "%x", &rt_g.debug );
d165 1
a165 1
		sscanf( argv[1], "%x", &rdebug );
d171 1
a171 1
		sscanf( argv[1], "%x", &rt_g.NMG_debug);
@


11.19
log
@Added "-v" option for attributes, also added code to list attributes and to calculate
hit points transformed to "ORCA standing man coordinates"
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.18 2001/04/02 15:05:14 jra Exp $ (BRL)";
a85 1
	Tcl_HashTable tbl;
d260 1
a260 1
	if( rt_gettrees_muves( rtip, (const char **)attrs, &tbl, argc, (const char **)argv, 1 ) )
a262 1
	ap.a_uptr = (genptr_t)&tbl;
d349 1
a349 1
		entry = Tcl_FindHashEntry( (Tcl_HashTable *)ap->a_uptr,
@


11.18
log
@Lint
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.17 2000/08/17 02:41:36 mike Exp $ (BRL)";
d58 2
a59 1
 -r #		Set ray length\n";
d86 1
d89 3
d97 1
d100 12
d113 20
a132 1
	while( argv[0][0] == '-' ) switch( argv[0][1] )  {
d261 4
a264 6
	while( argc > 0 )  {
		if( rt_gettree(rtip, argv[0]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[0]);
		argc--;
		argv++;
	}
d342 4
a345 1
		bu_log("\n--- Hit region %s (in %s, out %s)\n",
d348 12
a359 1
			pp->pt_outseg->seg_stp->st_name );
d383 7
d402 7
d419 20
@


11.17
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.16 2000/07/27 19:32:52 butler Exp $ (BRL)";
d29 7
@


11.16
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.15 2000/07/25 16:39:48 butler Exp $ (BRL)";
@


11.15
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.14 2000/05/23 02:43:25 mike Exp $ (BRL)";
d37 1
d72 1
d271 1
a271 1
hit( ap, PartHeadp )
d354 1
a354 1
miss( ap )
@


11.14
log
@
Added a_purpose string.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.13 2000/05/19 14:35:24 jra Exp $ (BRL)";
d35 1
a35 1
#include "./rdebug.h"
@


11.13
log
@Added code to list claiming regions for partitions
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.12 2000/05/19 14:18:50 jra Exp $ (BRL)";
d261 1
@


11.12
log
@Modified to use options consistent with nirt
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.11 2000/05/18 20:23:28 jra Exp $ (BRL)";
d301 10
@


11.11
log
@
Mods for the new FASTGEN entities.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.10 1999/12/22 02:28:04 mike Exp $ (BRL)";
d48 1
a48 1
 -f		Set emulate FASTGEN mode\n\
d63 1
a63 1
int		emulate_fastgen = 0;
d161 22
a182 4
	case 'f':
		emulate_fastgen = 1;
		argc--;
		argv++;
d207 1
a207 1
	if( emulate_fastgen )
d282 1
a282 1
	if( emulate_fastgen )
d284 2
@


11.10
log
@
Removed dead vars
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.9 1999/05/28 01:17:26 mike Exp $ (BRL)";
d48 1
d63 1
d160 7
d188 4
d263 3
@


11.9
log
@
sed4
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtshot.c,v 11.8 1997/05/28 14:40:46 jra Exp $ (BRL)";
a241 1
	register struct hit *hitp;
@


11.8
log
@Added options to set onehit and ray_length flags.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 11.7 1997/01/21 20:47:16 jra Exp jra $ (BRL)";
d262 1
a262 1
		rt_log("\n--- Hit region %s (in %s, out %s)\n",
d276 1
a276 1
		rt_log(    "   PDir (%g, %g, %g) c1=%g, c2=%g\n",
d288 1
a288 1
		rt_log(    "   PDir (%g, %g, %g) c1=%g, c2=%g\n",
d309 1
a309 1
	rt_log("missed\n");
@


11.7
log
@was calculating out hit point using in hit distance.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 11.6 1997/01/02 21:08:10 jra Exp jra $ (BRL)";
d47 3
a49 1
 -a # # #	Set shoot-at point\n";
d59 2
d85 15
d218 10
@


11.6
log
@Added -u flag for bu_debug.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 11.5 1996/03/29 23:20:55 mike Exp jra $ (BRL)";
d252 1
a252 1
		VJOIN1( outpt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
@


11.5
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 11.4 1996/03/29 21:55:48 mike Exp mike $ (BRL)";
d41 1
d83 6
@


11.4
log
@Changed to use new curvature macro.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 11.3 1996/03/29 21:00:36 mike Exp mike $ (BRL)";
d210 2
a211 3
	vect_t inpt, outpt;
	struct hit	inhit;
	struct hit	outhit;
d233 8
a240 8
		inhit = *pp->pt_inhit;		/* struct copy */
		RT_HIT_NORM( &inhit, stp, &(ap->a_ray) );
		if( pp->pt_inflip ) {
			VREVERSE( inhit.hit_normal, inhit.hit_normal );
		}
		rt_pr_hit( "  In", &inhit );
		RT_CURVATURE( &cur, &inhit, pp->pt_inflip, stp );
		rt_log("    PDir (%g, %g, %g) c1=%g, c2=%g\n",
a243 1
		outhit = *pp->pt_outhit;	/* struct copy */
d245 8
a252 7
		RT_HIT_NORM( &outhit, stp, &(ap->a_ray) );
		if( pp->pt_outflip ) {
			VREVERSE( outhit.hit_normal, outhit.hit_normal );
		}
		rt_pr_hit( " Out", &outhit );
		RT_CURVATURE( &cur, &outhit, pp->pt_outflip, stp );
		rt_log("    PDir (%g, %g, %g) c1=%g, c2=%g\n",
a259 2
			VJOIN1( inpt, ap->a_ray.r_pt,
				inhit.hit_dist, ap->a_ray.r_dir );
@


11.3
log
@Fixed to not damage original copy of hit_hormal.
Added printing of exit curvature.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 11.2 1995/01/25 15:54:10 jra Exp mike $ (BRL)";
d240 1
a240 1
		RT_CURVE( &cur, &inhit, stp );
d252 1
a252 1
		RT_CURVE( &cur, &outhit, stp );
@


11.2
log
@Added existing options to usage string.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/rtshot.c,v 11.1 95/01/04 10:00:59 mike Rel4_4 Locker: jra $ (BRL)";
d210 3
a212 1
	vect_t inhit, outhit;
d220 1
a220 1
			VJOIN1( inhit, ap->a_ray.r_pt,
d223 1
a223 1
			pdv_3line( plotfp, ap->a_ray.r_pt, inhit );
a232 1
		hitp = pp->pt_inhit;
d234 2
a235 1
		RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
d237 1
a237 2
			VREVERSE( hitp->hit_normal, hitp->hit_normal );
			pp->pt_inflip = 0;
d239 2
a240 2
		rt_pr_hit( "  In", hitp );
		RT_CURVE( &cur, hitp, stp );
d244 2
a245 2
		/* outhit info - out curvature? */
		hitp = pp->pt_outhit;
d247 1
a247 1
		RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
d249 1
a249 2
			VREVERSE( hitp->hit_normal, hitp->hit_normal );
			pp->pt_outflip = 0;
d251 4
a254 1
		rt_pr_hit( " Out", hitp );
d261 3
a263 3
			VJOIN1( inhit, ap->a_ray.r_pt,
				hitp->hit_dist, ap->a_ray.r_dir );
			VJOIN1( outhit,
d267 1
a267 1
			pdv_3line( plotfp, inhit, outhit );
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 10.4 94/08/11 00:40:44 gdurf Exp $ (BRL)";
d42 2
@


10.4
log
@Added include of externs.h
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 10.3 1994/08/11 00:40:01 gdurf Exp gdurf $ (BRL)";
@


10.3
log
@Added include of conf.h
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 10.2 1994/06/28 10:33:39 butler Exp gdurf $ (BRL)";
d32 1
a36 4

extern int	getopt();
extern char	*optarg;
extern int	optind;
@


10.2
log
@Added command line parsing for setting rt_g.NMG_debug
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 10.1 91/10/12 06:42:03 mike Rel4_0 Locker: butler $ (BRL)";
d25 2
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 9.2 91/08/31 06:54:10 mike Exp $ (BRL)";
d96 6
a101 1

a130 1

@


9.2
log
@Moved curvature data onto a single line of output
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtshot.c,v 9.1 89/05/19 05:59:25 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 8.2 88/10/06 03:24:30 mike Rel3_0 $ (BRL)";
d235 2
a236 3
		VPRINT("PDir", cur.crv_pdir );
		rt_log(" c1=%g\n", cur.crv_c1);
		rt_log(" c2=%g\n", cur.crv_c2);
@


8.2
log
@Fixed but that could cause 'hitp' to be used before initialized
if RDEBUG_RAYPLOT was enabled.
really Rel 3.0
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 8.1 88/10/05 00:33:18 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.9 88/09/19 22:45:01 mike Exp $ (BRL)";
d207 3
d212 1
a212 1
		if( hitp->hit_dist > 0.0001 )  {
d214 1
a214 1
				hitp->hit_dist, ap->a_ray.r_dir );
d219 1
a219 1
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
@


7.9
log
@atof() is adequately "extern'ed" in <math.h>, and
re-defining in locally sometimes produced clashes,
so local definitions were removed.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.8 88/07/07 22:25:53 mike Locked $ (BRL)";
@


7.8
log
@ye old if() MACRO without {} bug (on normal flips)
we aren't linked with rt and aren't in parallel so I removed a bunch
of unneeded stuff (this has become our canonical example after all)
slight cosmetic changes
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.7 88/07/07 21:51:41 phil Locked $ (BRL)";
a45 2

extern double	atof();
@


7.7
log
@added ray plotting
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.6 88/05/20 03:23:20 mike Locked $ (BRL)";
a47 1
extern char	*sbrk();
a51 4
int		npsw = 1;		/* Run serially */
int		interactive = 0;	/* human is watching results */

struct resource		resource;
a69 1
	static vect_t temp;
a72 5
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );

a192 1
	ap.a_resource = &resource;
d219 4
a222 3
		stp = pp->pt_inseg->seg_stp;
		rt_log("\n--- Hit %s of region %s\n",
			stp->st_name, pp->pt_regionp->reg_name );
d224 1
d226 1
d228 1
a228 1
		if( pp->pt_inflip )
d230 2
d238 2
a239 1
		/* outhit - no solid name, no curvature? */
a240 1
		hitp = pp->pt_outhit;
d242 1
a242 1
		if( pp->pt_outflip )
d244 2
d262 1
a262 1
	return(0);
a278 15

#if defined(SYSV)
#if !defined(bcopy)
bcopy(from,to,count)
{
	memcpy( to, from, count );
}
#endif
#if !defined(bzero)
bzero(str,n)
{
	memset( str, '\0', n );
}
#endif
#endif
@


7.6
log
@Added use_air variable.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.5 88/05/14 02:28:20 mike Locked $ (BRL)";
d51 1
d103 6
d172 1
d174 8
d218 2
d221 9
d252 14
d270 2
a271 1
miss()
d274 8
@


7.5
log
@lint fixes
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.4 88/02/27 03:09:49 mike Locked $ (BRL)";
d41 1
d62 1
d91 5
d156 1
@


7.4
log
@Converted remaining "parallel" vars to "rt_g.rtg_parallel".
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.3 88/02/12 01:10:19 mike Locked $ (BRL)";
d218 1
d224 1
@


7.3
log
@added autosizing with -d -a parameter pair
included region name in output
handled flip flags and fixed outhit region pointer bug
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.2 87/11/05 04:58:24 phil Locked $ (BRL)";
a51 1
int		parallel = 0;
@


7.2
log
@Also do outhit.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 7.1 87/11/02 23:56:19 mike Locked $ (BRL)";
a137 1
	/* Compute r_dir and r_pt from the inputs */
a138 10
	if( set_at )  {
		if( set_dir ) {
			VJOIN1( ap.a_ray.r_pt, at_vect,
				-1000, ap.a_ray.r_dir );
		} else {
			/* set_pt */
			VSUB2( ap.a_ray.r_dir, at_vect, ap.a_ray.r_pt );
		}
	}
	VUNITIZE( ap.a_ray.r_dir );
a139 3
	VPRINT( "Pnt", ap.a_ray.r_pt );
	VPRINT( "Dir", ap.a_ray.r_dir );

d159 19
d198 2
a199 1
		rt_log("\n--- Hit %s\n", stp->st_name);
d203 2
d211 2
d215 2
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 6.2 87/09/28 19:48:41 mike Exp $ (BRL)";
a191 1
		hitp = pp->pt_inhit;
d194 2
d202 4
@


6.2
log
@Added "interactive" variable and code for bcopy and bzero.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 6.1 87/07/11 07:59:14 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 5.2 87/07/09 03:31:00 mike Exp $ (BRL)";
d53 1
d208 15
@


5.2
log
@Changed parallel support from #ifdef to runtime determination.
Added 3 types of libfb interaction
Misc. cleanups.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 5.1 87/06/24 22:15:18 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 1.3 87/05/31 04:47:40 mike Exp $ (BRL)";
d52 1
@


1.3
log
@Split do.c into do.c and machine.c, so that rtshot.c can have
the use of machine.c routines.
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 1.2 87/05/30 04:55:45 mike Locked $ (BRL)";
@


1.2
log
@Fixed error with -x
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 1.1 87/05/29 05:19:32 mike Locked $ (BRL)";
d50 2
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.18 87/05/28 21:53:05 mike Exp $ (BRL)";
d89 2
a90 2
		argc--;
		argv++;
@
