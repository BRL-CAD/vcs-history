head	11.20;
access;
symbols
	rel-4-5:11.17
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.20
date	98.09.22.01.43.12;	author mike;	state dead;
branches;
next	11.19;

11.19
date	98.07.13.19.12.16;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	98.06.30.22.54.19;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	97.11.21.20.59.34;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.08.01.18.01.15;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.07.02.21.15.37;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	96.12.04.02.55.51;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.10.19.06.17.00;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.07.22.20.34.18;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.05.07.19.26.36;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	95.09.16.00.28.34;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.06.02.23.34.05;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.11.02.24.14;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.13;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.12.19.19.54.28;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.11.30.19.23.24;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.15.21.57.51;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.11.05.02.53.18;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.29.02.38.11;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.02.29.04;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.03.09.17.57.53;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.13;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.07.06.00.35.24;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.02.20.01.16.58;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.02.17.20.15.56;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.02.17.18.50.56;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.05.03.09.18;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.03.22.58.23;	author butler;	state Exp;
branches;
next	9.6;

9.6
date	90.12.12.16.35.12;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	90.12.10.21.14.44;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.08.58.13;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	90.12.08.08.30.46;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.08.08.20.14;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.46;	author mike;	state Rel3_5;
branches;
next	8.10;

8.10
date	89.04.30.21.26.16;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.04.28.06.16.04;	author phil;	state Exp;
branches;
next	8.8;

8.8
date	89.04.05.01.47.01;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.04.05.02.11;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.03.29.15.32.34;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.03.11.05.27.17;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.01.09.06.07.25;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.27.16.35.17;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.13.03.16.57;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.31;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.09.17.07.20.58;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.06.21.02.53.43;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.06.19.05.43.22;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.02.28.28;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.27.07.47.10;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.26.05.55.04;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.39;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.09.16.04.33.56;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.03.01.30.37;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.59.26;	author mike;	state Rel;
branches;
next	5.6;

5.6
date	87.07.10.05.06.07;	author mike;	state Exp;
branches;
next	5.5;

5.5
date	87.07.06.15.09.30;	author mike;	state Exp;
branches;
next	5.4;

5.4
date	87.06.27.06.46.23;	author phil;	state Exp;
branches;
next	5.3;

5.3
date	87.06.27.03.58.31;	author phil;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.55.17;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.15.31;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.03.23.23.48.04;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.02.54;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.48.51;	author mike;	state Rel1;
branches;
next	3.15;

3.15
date	86.12.24.04.27.12;	author mike;	state Exp;
branches;
next	3.14;

3.14
date	86.12.18.16.02.09;	author mike;	state Exp;
branches;
next	3.13;

3.13
date	86.11.07.02.46.25;	author mike;	state Exp;
branches;
next	3.12;

3.12
date	86.11.04.21.05.57;	author mike;	state Exp;
branches;
next	3.11;

3.11
date	86.10.29.04.51.18;	author mike;	state Exp;
branches;
next	3.10;

3.10
date	86.09.23.17.12.41;	author mike;	state Exp;
branches;
next	3.9;

3.9
date	86.08.12.05.50.59;	author mike;	state Exp;
branches;
next	3.8;

3.8
date	86.07.31.08.29.37;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.07.30.03.56.40;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.07.28.22.52.56;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.24.06.05.39;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.24.03.58.22;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.19.04.40.07;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.17.18.33.10;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.11.00.14.40;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.29;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	86.06.09.21.49.44;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.06.54;	author mike;	state Exp;
branches;
next	;


desc
@Apply a texture map from a file.
@


11.20
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@/*
 *  			T E X T . C
 *  
 *  Texture map lookup
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCStext[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_text.c,v 11.19 1998/07/13 19:12:16 jra Exp mike $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <ctype.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"

struct region	env_region;			/* share with view.c */

HIDDEN int	bwtxt_render();
HIDDEN int	txt_setup(), txt_render();
HIDDEN int	ckr_setup(), ckr_render();
HIDDEN int	bmp_setup(), bmp_render();
HIDDEN void	bwtxtprint(), bwtxtfree();
HIDDEN void	txt_print(), txt_free();
HIDDEN void	ckr_print(), ckr_free();
HIDDEN void	bmp_print(), bmp_free();
HIDDEN void	txt_transp_hook();
HIDDEN int tstm_render();
HIDDEN int star_render();
HIDDEN int envmap_setup();
extern int mlib_zero(), mlib_one();
extern void	mlib_void();

struct mfuncs txt_mfuncs[] = {
	{MF_MAGIC,	"texture",	0,		MFI_UV,		0,
	txt_setup,	txt_render,	txt_print,	txt_free },

	{MF_MAGIC,	"bwtexture",	0,		MFI_UV,		0,
	txt_setup,	bwtxt_render,	txt_print,	txt_free },

	{MF_MAGIC,	"checker",	0,		MFI_UV,		0,
	ckr_setup,	ckr_render,	ckr_print,	ckr_free },

	{MF_MAGIC,	"testmap",	0,		MFI_UV,		0,
	mlib_one,	tstm_render,	mlib_void,	mlib_void },

	{MF_MAGIC,	"fakestar",	0,		0,		0,
	mlib_one,	star_render,	mlib_void,	mlib_void },

	{MF_MAGIC,	"bump",		0,		MFI_UV|MFI_NORMAL, 0,
	txt_setup,	bmp_render,	txt_print,	txt_free },

	{MF_MAGIC,	"envmap",	0,		0,		0,
	envmap_setup,	mlib_zero,	mlib_void,	mlib_void },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

#define TXT_NAME_LEN 128
struct txt_specific {
	int	tx_transp[3];	/* RGB for transparency */
	char	tx_file[TXT_NAME_LEN];	/* Filename */
	int	tx_w;		/* Width of texture in pixels */
	int	tx_n;		/* Number of scanlines */
	int	tx_trans_valid;	/* boolean: is tx_transp valid ? */
	struct rt_mapped_file	*mp;
};
#define TX_NULL	((struct txt_specific *)0)
#define TX_O(m)	offsetof(struct txt_specific, m)

struct bu_structparse txt_parse[] = {
	{"%d",	1, "transp",	offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook },
	{"%s",	TXT_NAME_LEN, "file", offsetofarray(struct txt_specific, tx_file),		FUNC_NULL },
	{"%d",	1, "w",		TX_O(tx_w),		FUNC_NULL },
	{"%d",	1, "n",		TX_O(tx_n),		FUNC_NULL },
	{"%d",	1, "l",		TX_O(tx_n),		FUNC_NULL }, /*compat*/
	{"%d",	1, "trans_valid",	TX_O(tx_trans_valid),	FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
};

/*
 *			T X T _ T R A N S P _ H O O K
 *
 *  Hooked function, called by bu_structparse
 */
HIDDEN void
txt_transp_hook( ptab, name, cp, value )
struct bu_structparse *ptab;
char	*name;
char	*cp;
char	*value;
{
	register struct txt_specific *tp =
		(struct txt_specific *)cp;

	if (!strcmp(name, txt_parse[0].sp_name) && ptab == txt_parse) {
		tp->tx_trans_valid = 1;
	} else {
		rt_log("file:%s, line:%d txt_transp_hook name:(%s) instead of (%s)\n",
			__FILE__, __LINE__, name, txt_parse[0].sp_name);
	}
}

/*
 *  			T X T _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  return a pointer to the relevant pixel.
 *
 *  Note that .pix files are stored left-to-right, bottom-to-top,
 *  which works out very naturally for the indexing scheme.
 */
HIDDEN int
txt_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
{
	register struct txt_specific *tp =
		(struct txt_specific *)dp;
	fastf_t xmin, xmax, ymin, ymax;
	int line;
	int dx, dy;
	int x,y;
	register fastf_t r,g,b;

	if( rdebug & RDEBUG_SHADE )
		bu_log( "in txt_render(): du=%g, dv=%g\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv );
	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug colors
	 */
	if( tp->tx_file[0] == '\0' || !tp->mp )  {
		VSET( swp->sw_color, swp->sw_uv.uv_u, 0, swp->sw_uv.uv_v );
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}

	/* u is left->right index, v is line number bottom->top */
	/* Don't filter more than 1/8 of the texture for 1 pixel! */
	if( swp->sw_uv.uv_du > 0.125 )  swp->sw_uv.uv_du = 0.125;
	if( swp->sw_uv.uv_dv > 0.125 )  swp->sw_uv.uv_dv = 0.125;

	if( swp->sw_uv.uv_du < 0 || swp->sw_uv.uv_dv < 0 )  {
		rt_log("txt_render uv=%g,%g, du dv=%g %g seg=%s\n",
			swp->sw_uv.uv_u, swp->sw_uv.uv_v, swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
			pp->pt_inseg->seg_stp->st_name );
		swp->sw_uv.uv_du = swp->sw_uv.uv_dv = 0;
	}

	xmin = swp->sw_uv.uv_u - swp->sw_uv.uv_du;
	xmax = swp->sw_uv.uv_u + swp->sw_uv.uv_du;
	ymin = swp->sw_uv.uv_v - swp->sw_uv.uv_dv;
	ymax = swp->sw_uv.uv_v + swp->sw_uv.uv_dv;
	if( xmin < 0 )  xmin = 0;
	if( ymin < 0 )  ymin = 0;
	if( xmax > 1 )  xmax = 1;
	if( ymax > 1 )  ymax = 1;

	if( rdebug & RDEBUG_SHADE )
		bu_log( "footprint in texture space is (%g %g) <-> (%g %g)\n",
			xmin * (tp->tx_w-1), ymin * (tp->tx_n-1),
			xmax * (tp->tx_w-1), ymax * (tp->tx_n-1) );
			
#if 1
	dx = (int)(xmax * (tp->tx_w-1)) - (int)(xmin * (tp->tx_w-1));
	dy = (int)(ymax * (tp->tx_n-1)) - (int)(ymin * (tp->tx_n-1));

	if( rdebug & RDEBUG_SHADE )
		bu_log( "\tdx = %d, dy = %d\n", dx, dy );
	if( dx == 0 && dy == 0 )
	{
		/* No averaging necessary */

		register unsigned char *cp;

		cp = ((unsigned char *)(tp->mp->buf)) +
			(int)(ymin * (tp->tx_n-1)) * tp->tx_w * 3 +
			(int)(xmin * (tp->tx_w-1)) * 3;
		r = *cp++;
		g = *cp++;
		b = *cp;
	}
	else
	{
		/* Calculate weighted average of cells in footprint */

		fastf_t tot_area=0.0;
		fastf_t cell_area;
		int start_line, stop_line, line;
		int start_col, stop_col, col;
		fastf_t xstart, xstop, ystart, ystop;
		fastf_t u, v;

		xstart = xmin * (tp->tx_w-1);
		xstop = xmax * (tp->tx_w-1);
		ystart = ymin * (tp->tx_n-1);
		ystop = ymax * (tp->tx_n-1);

		start_line = ystart;
		stop_line = ystop;
		start_col = xstart;
		stop_col = xstop;

		r = g = b = 0.0;

		if( rdebug & RDEBUG_SHADE )
		{
			bu_log( "\thit in texture space = (%g %g)\n", swp->sw_uv.uv_u * (tp->tx_w-1), swp->sw_uv.uv_v * (tp->tx_n-1) );
			bu_log( "\t averaging from  (%g %g) to (%g %g)\n", xstart, ystart, xstop, ystop );
			bu_log( "\tcontributions to average:\n" );
		}

		for( line = start_line ; line <= stop_line ; line++ )
		{
			register unsigned char *cp;
			register unsigned char *ep;
			fastf_t line_factor;
			fastf_t line_upper, line_lower;

			line_upper = line + 1.0;
			if( line_upper > ystop )
				line_upper = ystop;
			line_lower = line;
			if( line_lower < ystart )
				line_lower = ystart;
			line_factor = line_upper - line_lower;
			cp = ((unsigned char *)(tp->mp->buf)) +
				line * tp->tx_w * 3 + (int)(xstart) * 3;

			for( col = start_col ; col <= stop_col ; col++ )
			{
				fastf_t col_upper, col_lower;

				col_upper = col + 1.0;
				if( col_upper > xstop )
					col_upper = xstop;
				col_lower = col;
				if( col_lower < xstart )
					col_lower = xstart;
				cell_area = line_factor * (col_upper - col_lower);
				tot_area += cell_area;

				if( rdebug & RDEBUG_SHADE )
					bu_log( "\t %d %d %d weight=%g (from col=%d line=%d)\n", *cp, *(cp+1), *(cp+2), cell_area, col, line );

				r += (*cp++) * cell_area;
				g += (*cp++) * cell_area;
				b += (*cp++) * cell_area;
			}
		}
		r /= tot_area;
		g /= tot_area;
		b /= tot_area;
	}
	
	if( rdebug & RDEBUG_SHADE )
		bu_log( " average: %g %g %g\n", r, g, b );
#else
	x = xmin * (tp->tx_w-1);
	y = ymin * (tp->tx_n-1);
	dx = (xmax - xmin) * (tp->tx_w-1);
	dy = (ymax - ymin) * (tp->tx_n-1);
	if( dx < 1 )  dx = 1;
	if( dy < 1 )  dy = 1;

	if( rdebug & RDEBUG_SHADE )
		bu_log(" in txt_render(): x=%d y=%d, dx=%d, dy=%d\n", x, y, dx, dy);

	r = g = b = 0;
	for( line=0; line<dy; line++ )  {
		register unsigned char *cp;
		register unsigned char *ep;
		cp = ((unsigned char *)(tp->mp->buf)) +
		     (y+line) * tp->tx_w * 3  +  x * 3;
		ep = cp + 3*dx;
		while( cp < ep )  {
			if( rdebug & RDEBUG_SHADE )
				bu_log( "\tAdding %d %d %d\n", *cp, *(cp+1), *(cp+2) );
			r += *cp++;
			g += *cp++;
			b += *cp++;
		}
	}
	if( rdebug & RDEBUG_SHADE )
		bu_log( "Totals: %d %d %d,", r, g, b );
	r /= (dx*dy);
	g /= (dx*dy);
	b /= (dx*dy);
	if( rdebug & RDEBUG_SHADE )
		bu_log( " average: %d %d %d\n", r, g, b );
#endif

	if (!tp->tx_trans_valid) {
opaque:
		VSET( swp->sw_color,
			r * rt_inv255,
			g * rt_inv255,
			b * rt_inv255 );
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}
	/* This circumlocution needed to keep expression simple for Cray,
	 * and others
	 */
	if( r != ((long)tp->tx_transp[0]) )  goto opaque;
	if( g != ((long)tp->tx_transp[1]) )  goto opaque;
	if( b != ((long)tp->tx_transp[2]) )  goto opaque;

	/*
	 *  Transparency mapping is enabled, and we hit a transparent spot.
	 *  Let higher level handle it in reflect/refract code.
	 */
	swp->sw_transmit = 1.0;
	swp->sw_reflect = 0.0;
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
	return(1);
}

/*
 *  			B W T X T _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  return the filtered intensity.
 *
 *  Note that .bw files are stored left-to-right, bottom-to-top,
 *  which works out very naturally for the indexing scheme.
 */
HIDDEN int
bwtxt_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
{
	register struct txt_specific *tp =
		(struct txt_specific *)dp;
	fastf_t xmin, xmax, ymin, ymax;
	int line;
	int dx, dy;
	int x,y;
	register long bw;

	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug colors
	 */
	if( tp->tx_file[0] == '\0' || !tp->mp )  {
		VSET( swp->sw_color, swp->sw_uv.uv_u, 0, swp->sw_uv.uv_v );
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}

	/* u is left->right index, v is line number bottom->top */
	/* Don't filter more than 1/8 of the texture for 1 pixel! */
	if( swp->sw_uv.uv_du > 0.125 )  swp->sw_uv.uv_du = 0.125;
	if( swp->sw_uv.uv_dv > 0.125 )  swp->sw_uv.uv_dv = 0.125;

	if( swp->sw_uv.uv_du < 0 || swp->sw_uv.uv_dv < 0 )  {
		rt_log("bwtxt_render uv=%g,%g, du dv=%g %g seg=%s\n",
			swp->sw_uv.uv_u, swp->sw_uv.uv_v, swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
			pp->pt_inseg->seg_stp->st_name );
		swp->sw_uv.uv_du = swp->sw_uv.uv_dv = 0;
	}
	xmin = swp->sw_uv.uv_u - swp->sw_uv.uv_du;
	xmax = swp->sw_uv.uv_u + swp->sw_uv.uv_du;
	ymin = swp->sw_uv.uv_v - swp->sw_uv.uv_dv;
	ymax = swp->sw_uv.uv_v + swp->sw_uv.uv_dv;
	if( xmin < 0 )  xmin = 0;
	if( ymin < 0 )  ymin = 0;
	if( xmax > 1 )  xmax = 1;
	if( ymax > 1 )  ymax = 1;
	x = xmin * (tp->tx_w-1);
	y = ymin * (tp->tx_n-1);
	dx = (xmax - xmin) * (tp->tx_w-1);
	dy = (ymax - ymin) * (tp->tx_n-1);
	if( dx < 1 )  dx = 1;
	if( dy < 1 )  dy = 1;
	bw = 0;
	for( line=0; line<dy; line++ )  {
		register unsigned char *cp;
		register unsigned char *ep;
		cp = ((unsigned char *)(tp->mp->buf)) +
		     (y+line) * tp->tx_w  +  x;
		ep = cp + dx;
		while( cp < ep )  {
			bw += *cp++;
		}
	}

	if (!tp->tx_trans_valid) {
opaque:
		VSETALL( swp->sw_color,
			bw * rt_inv255 / (dx*dy) );
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}
	/* This circumlocution needed to keep expression simple for Cray,
	 * and others
	 */
	if( bw / (dx*dy) != ((long)tp->tx_transp[0]) )  goto opaque;

	/*
	 *  Transparency mapping is enabled, and we hit a transparent spot.
	 *  Let higher level handle it in reflect/refract code.
	 */
	swp->sw_transmit = 1.0;
	swp->sw_reflect = 0.0;
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
	return(1);
}

/*
 *			T X T _ S E T U P
 */
HIDDEN int
txt_setup( rp, matparm, dpp, mfp, rtip )
register struct region	*rp;
struct rt_vls		*matparm;
char			**dpp;
CONST struct mfuncs	*mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
{
	register struct txt_specific *tp;
	int		pixelbytes = 3;

	RT_VLS_CHECK( matparm );
	GETSTRUCT( tp, txt_specific );
	*dpp = (char *)tp;

	tp->tx_file[0] = '\0';
	tp->tx_w = tp->tx_n = -1;
	tp->tx_trans_valid = 0;
	if( bu_struct_parse( matparm, txt_parse, (char *)tp ) < 0 )  {
		rt_free( (char *)tp, "txt_specific" );
		return(-1);
	}
	if( tp->tx_w < 0 )  tp->tx_w = 512;
	if( tp->tx_n < 0 )  tp->tx_n = tp->tx_w;

	if( tp->tx_trans_valid )
		rp->reg_transmit = 1;

	if( tp->tx_file[0] == '\0' )  return -1;	/* FAIL, no file */
	if( !(tp->mp = rt_open_mapped_file( tp->tx_file, NULL )) )
		return -1;				/* FAIL */

	/* Ensure file is large enough */
	if( strcmp( mfp->mf_name, "bwtexture" ) == 0 )
		pixelbytes = 1;
	if( tp->mp->buflen < tp->tx_w * tp->tx_n * pixelbytes )  {
		rt_log("\ntxt_setup() ERROR %s %s needs %d bytes, '%s' only has %d\n",
			rp->reg_name,
			mfp->mf_name,
			tp->tx_w * tp->tx_n * pixelbytes,
			tp->mp->name,
			tp->mp->buflen );
		return -1;				/* FAIL */
	}

	return 1;				/* OK */
}

/*
 *			T X T _ P R I N T
 */
HIDDEN void
txt_print( rp )
register struct region *rp;
{
	bu_struct_print(rp->reg_name, txt_parse, (char *)rp->reg_udata);
}

/*
 *			T X T _ F R E E
 */
HIDDEN void
txt_free( cp )
char *cp;
{
	struct txt_specific *tp =
		(struct txt_specific *)cp;

	if( tp->mp )  rt_close_mapped_file( tp->mp );
	rt_free( cp, "txt_specific" );
}

struct ckr_specific  {
	int	ckr_a[3];	/* first RGB */
	int	ckr_b[3];	/* second RGB */
};
#define CKR_NULL	((struct ckr_specific *)0)
#define CKR_O(m)	offsetof(struct ckr_specific, m)

struct bu_structparse ckr_parse[] = {
	{"%d",	3, "a",	offsetofarray(struct ckr_specific, ckr_a), FUNC_NULL },
	{"%d",	3, "b",	offsetofarray(struct ckr_specific, ckr_b), FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
};

/*
 *			C K R _ R E N D E R
 */
HIDDEN int
ckr_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
register struct shadework	*swp;
char	*dp;
{
	register struct ckr_specific *ckp =
		(struct ckr_specific *)dp;
	register int *cp;

	if( (swp->sw_uv.uv_u < 0.5 && swp->sw_uv.uv_v < 0.5) ||
	    (swp->sw_uv.uv_u >=0.5 && swp->sw_uv.uv_v >=0.5) )  {
		cp = ckp->ckr_a;
	} else {
		cp = ckp->ckr_b;
	}
	VSET( swp->sw_color,
		(unsigned char)cp[0] * rt_inv255,
		(unsigned char)cp[1] * rt_inv255,
		(unsigned char)cp[2] * rt_inv255 );

	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

/*
 *			C K R _ S E T U P
 */
HIDDEN int
ckr_setup( rp, matparm, dpp, mfp, rtip )
register struct region	 *rp;
struct rt_vls		*matparm;
char			**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
{
	register struct ckr_specific *ckp;

	/* Default will be white and black checkers */
	GETSTRUCT( ckp, ckr_specific );
	*dpp = (char *)ckp;
	ckp->ckr_a[0] = ckp->ckr_a[1] = ckp->ckr_a[2] = 255;
	if( bu_struct_parse( matparm, ckr_parse, (char *)ckp ) < 0 )  {
		rt_free( (char *)ckp, "ckr_specific" );
		return(-1);
	}
	ckp->ckr_a[0] &= 0x0ff;
	ckp->ckr_a[1] &= 0x0ff;
	ckp->ckr_a[2] &= 0x0ff;
	ckp->ckr_b[0] &= 0x0ff;
	ckp->ckr_b[1] &= 0x0ff;
	ckp->ckr_b[2] &= 0x0ff;
	return(1);
}

/*
 *			C K R _ P R I N T
 */
HIDDEN void
ckr_print( rp )
register struct region *rp;
{
	bu_struct_print(rp->reg_name, ckr_parse, rp->reg_udata);
}

/*
 *			C K R _ F R E E
 */
HIDDEN void
ckr_free( cp )
char *cp;
{
	rt_free( cp, "ckr_specific" );
}

/*
 *			T S T M _ R E N D E R
 *
 *  Render a map which varries red with U and blue with V values.
 *  Mostly useful for debugging ft_uv() routines.
 */
HIDDEN
tstm_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
register struct shadework	*swp;
char	*dp;
{
	VSET( swp->sw_color, swp->sw_uv.uv_u, 0, swp->sw_uv.uv_v );

	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

static vect_t star_colors[] = {
	{ 0.825769, 0.415579, 0.125303 },	/* 3000 */
	{ 0.671567, 0.460987, 0.258868 },
	{ 0.587580, 0.480149, 0.376395 },
	{ 0.535104, 0.488881, 0.475879 },
	{ 0.497639, 0.493881, 0.556825 },
	{ 0.474349, 0.494836, 0.624460 },
	{ 0.456978, 0.495116, 0.678378 },
	{ 0.446728, 0.493157, 0.727269 },	/* 10000 */
	{ 0.446728, 0.493157, 0.727269 },	/* fake 11000 */
#if 0
	{ 0.446728, 0.493157, 0.727269 },	/* fake 12000 */
	{ 0.446728, 0.493157, 0.727269 },	/* fake 13000 */
	{ 0.446728, 0.493157, 0.727269 },	/* fake 14000 */
	{ 0.446728, 0.493157, 0.727269 },	/* fake 15000 */
	{ 0.393433 0.488079 0.940423 }		/* 20000 */
#endif
};

/*
 *			S T A R _ R E N D E R
 */
HIDDEN
star_render( ap, pp, swp, dp )
register struct application *ap;
register struct partition *pp;
struct shadework	*swp;
char	*dp;
{
	/* Probably want to diddle parameters based on what part of sky */
	if( rand0to1(ap->a_resource->re_randptr) >= 0.98 )  {
		register int i;
		FAST fastf_t f;
		i = (sizeof(star_colors)-1) / sizeof(star_colors[0]);

		/* "f" used for intermediate result to avoid an SGI compiler error */
		f = rand0to1(ap->a_resource->re_randptr);
		i = ((double)i) * f;

		f = rand0to1(ap->a_resource->re_randptr);
		VSCALE( swp->sw_color, star_colors[i], f );
	} else {
		VSETALL( swp->sw_color, 0 );
	}

	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

/*
 *  			B M P _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  compute a new surface normal.
 *  For now we come up with a local coordinate system, and
 *  make bump perturbations from the red and blue channels of
 *  an RGB image.
 *
 *  Note that .pix files are stored left-to-right, bottom-to-top,
 *  which works out very naturally for the indexing scheme.
 */
HIDDEN
bmp_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
{
	register struct txt_specific *tp =
		(struct txt_specific *)dp;
	unsigned char *cp;
	fastf_t	pertU, pertV;
	vect_t	y;		/* world coordinate axis vectors */
	vect_t	u, v;		/* surface coord system vectors */
	int	i, j;		/* bump map pixel indicies */

	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug color.
	 */
	if( tp->tx_file[0] == '\0' || !tp->mp )  {
		VSET( swp->sw_color, swp->sw_uv.uv_u, 0, swp->sw_uv.uv_v );
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}
	/* u is left->right index, v is line number bottom->top */
	if( swp->sw_uv.uv_u < 0 || swp->sw_uv.uv_u > 1 || swp->sw_uv.uv_v < 0 || swp->sw_uv.uv_v > 1 )  {
		rt_log("bmp_render:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
			swp->sw_uv.uv_u, swp->sw_uv.uv_v,
			swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
			pp->pt_inseg->seg_stp->st_name );
		VSET( swp->sw_color, 0, 1, 0 );
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}

	/* Find a local coordinate system */
	VSET( y, 0, 1, 0 );
	VCROSS( u, y, swp->sw_hit.hit_normal );
	VUNITIZE( u );
	VCROSS( v, swp->sw_hit.hit_normal, u );

	/* Find our RGB value */
	i = swp->sw_uv.uv_u * (tp->tx_w-1);
	j = swp->sw_uv.uv_v * (tp->tx_n-1);
	cp = ((unsigned char *)(tp->mp->buf)) +
	     (j) * tp->tx_w * 3  +  i * 3;
	pertU = ((fastf_t)(*cp) - 128.0) / 128.0;
	pertV = ((fastf_t)(*(cp+2)) - 128.0) / 128.0;

	if( rdebug&RDEBUG_LIGHT ) {
		VPRINT("normal", swp->sw_hit.hit_normal);
		VPRINT("u", u );
		VPRINT("v", v );
		rt_log("cu = %d, cv = %d\n", *cp, *(cp+2));
		rt_log("pertU = %g, pertV = %g\n", pertU, pertV);
	}
	VJOIN2( swp->sw_hit.hit_normal, swp->sw_hit.hit_normal, pertU, u, pertV, v );
	VUNITIZE( swp->sw_hit.hit_normal );
	if( rdebug&RDEBUG_LIGHT ) {
		VPRINT("after", swp->sw_hit.hit_normal);
	}

	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

/*
 *			E N V M A P _ S E T U P
 */
HIDDEN int
envmap_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct rt_vls *matparm;
char	**dpp;
CONST struct mfuncs	*mfp;
struct rt_i	*rtip;
{
	register char	*cp;
	struct rt_vls	material;

	RT_VLS_CHECK( matparm );
	RT_CK_RTI(rtip);
	if( env_region.reg_mfuncs )  {
		rt_log("envmap_setup:  second environment map ignored\n");
		return(0);		/* drop region */
	}
	env_region = *rp;		/* struct copy */
	/* Get copies of, or eliminate, references to dynamic structures */
	env_region.reg_name = rt_strdup( rp->reg_name );
	env_region.reg_treetop = TREE_NULL;
	env_region.reg_forw = REGION_NULL;
	env_region.reg_mfuncs = (char *)0;

	env_region.reg_mater.ma_shader = bu_vls_strdup( matparm );

	if( mlib_setup( &env_region, rtip ) < 0 )
		rt_log("envmap_setup() material '%s' failed\n", env_region.reg_mater );

	return(0);		/* This region should be dropped */
}
@


11.19
log
@envmap_setup() was ignoring parameters for passed shader.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_text.c,v 11.18 1998/06/30 22:54:19 mike Exp $ (BRL)";
@


11.18
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_text.c,v 11.17 1997/12/31 09:01:40 mike Exp $ (BRL)";
d787 1
a787 16
	rt_vls_init( &material );
	rt_vls_vlscat( &material, matparm );
	/* Expect "material SPACE args", find space */
	cp = RT_VLS_ADDR( &material );
	while( *cp != '\0' )  {
		if( !isascii(*cp) || isspace(*cp) )  break;
		cp++;
	}
	if( *cp == '\0' )  {
		/*  Null was encountered while searching for space,
		 *  leave "cp" pointing at null, e.g., no parameter string.
		 */
	} else {
		/* Replace space with null, advance "cp" to parameter */
		*cp++ = '\0';
	}
a788 2
	env_region.reg_mater.ma_shader = bu_vls_strdup( &material );

d791 1
a791 1
	rt_vls_free( &material );
@


11.17
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.16 1997/11/25 22:16:43 butler Exp mike $ (BRL)";
d50 1
a50 1
CONST struct mfuncs txt_mfuncs[] = {
@


11.16
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.15 1997/11/21 20:59:34 jra Exp butler $ (BRL)";
d50 3
a52 3
struct mfuncs txt_mfuncs[] = {
	"texture",	0,		0,		MFI_UV,		0,
	txt_setup,	txt_render,	txt_print,	txt_free,
d54 2
a55 2
	"bwtexture",	0,		0,		MFI_UV,		0,
	txt_setup,	bwtxt_render,	txt_print,	txt_free,
d57 2
a58 2
	"checker",	0,		0,		MFI_UV,		0,
	ckr_setup,	ckr_render,	ckr_print,	ckr_free,
d60 2
a61 2
	"testmap",	0,		0,		MFI_UV,		0,
	mlib_one,	tstm_render,	mlib_void,	mlib_void,
d63 2
a64 2
	"fakestar",	0,		0,		0,		0,
	mlib_one,	star_render,	mlib_void,	mlib_void,
d66 2
a67 2
	"bump",		0,		0,		MFI_UV|MFI_NORMAL, 0,
	txt_setup,	bmp_render,	txt_print,	txt_free,
d69 2
a70 2
	"envmap",	0,		0,		0,		0,
	envmap_setup,	mlib_zero,	mlib_void,	mlib_void,
d72 2
a73 2
	(char *)0,	0,		0,		0,		0,
	0,		0,		0,		0
@


11.15
log
@Added a debug print.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.14 1997/08/01 18:01:15 jra Exp jra $ (BRL)";
d441 1
a441 1
txt_setup( rp, matparm, dpp, mfp )
d446 1
d560 1
a560 1
ckr_setup( rp, matparm, dpp )
d564 2
@


11.14
log
@Modified txt_render to compute weighted average of texture pixels within hit footprint.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.13 1997/07/02 21:15:37 butler Exp jra $ (BRL)";
d178 6
@


11.13
log
@checkpoint
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.12 1996/12/04 02:55:51 mike Exp butler $ (BRL)";
d143 1
a143 1
	register long r,g,b;
d145 2
d169 1
d178 95
d279 4
a282 1
/** rt_log("x=%d y=%d, dx=%d, dy=%d\n", x, y, dx, dy); **/
d291 2
d298 2
d303 3
@


11.12
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.11 1996/10/19 06:17:00 mike Exp mike $ (BRL)";
d405 2
a406 8
#if CRAY && !__STDC__
	/* Hack for old Cray compilers */
	{"%d",	1, "a",		0,			FUNC_NULL },
	{"%d",	1, "b",		1,			FUNC_NULL },
#else
	{"%d",	1, "a",	offsetofarray(struct ckr_specific, ckr_a), FUNC_NULL },
	{"%d",	1, "b",	offsetofarray(struct ckr_specific, ckr_b), FUNC_NULL },
#endif
@


11.11
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.10 1996/08/31 08:46:01 butler Exp mike $ (BRL)";
d693 1
a693 2
	env_region.reg_mater.ma_matname = bu_vls_strdup( &material );
	env_region.reg_mater.ma_matparm = bu_strdup( cp );
@


11.10
log
@bu_struct_print
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.9 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d693 2
a694 4
	strncpy( env_region.reg_mater.ma_matname, RT_VLS_ADDR(&material),
		sizeof(rp->reg_mater.ma_matname) );
	strncpy( env_region.reg_mater.ma_matparm, cp,
		sizeof(rp->reg_mater.ma_matparm) );
@


11.9
log
@bu_struct_parse
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.8 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d380 1
a380 1
	bu_structprint(rp->reg_name, txt_parse, (char *)rp->reg_udata);
d482 1
a482 1
	bu_structprint(rp->reg_name, ckr_parse, rp->reg_udata);
@


11.8
log
@structparse moved to libbu
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.7 1996/07/22 20:34:18 jra Exp butler $ (BRL)";
d343 1
a343 1
	if( bu_structparse( matparm, txt_parse, (char *)tp ) < 0 )  {
d462 1
a462 1
	if( bu_structparse( matparm, ckr_parse, (char *)ckp ) < 0 )  {
@


11.7
log
@Minor Mods for IRIX 6.2
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.6 1996/05/07 19:26:36 jra Exp jra $ (BRL)";
d88 1
a88 1
struct structparse txt_parse[] = {
d101 1
a101 1
 *  Hooked function, called by rt_structparse
d105 1
a105 1
struct structparse *ptab;
d343 1
a343 1
	if( rt_structparse( matparm, txt_parse, (char *)tp ) < 0 )  {
d380 1
a380 1
	rt_structprint(rp->reg_name, txt_parse, (char *)rp->reg_udata);
d404 1
a404 1
struct structparse ckr_parse[] = {
d462 1
a462 1
	if( rt_structparse( matparm, ckr_parse, (char *)ckp ) < 0 )  {
d482 1
a482 1
	rt_structprint(rp->reg_name, ckr_parse, rp->reg_udata);
@


11.6
log
@Individual shaders now call rr_render() directly.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.5 1995/10/20 04:43:53 butler Exp jra $ (BRL)";
d550 5
a554 1
		i = ((double)i) * rand0to1(ap->a_resource->re_randptr);
@


11.5
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.4 1995/09/16 00:28:34 mike Exp butler $ (BRL)";
d151 2
d205 2
d222 2
d257 2
d303 2
d318 2
d440 4
d509 4
d556 4
d596 2
d607 2
d638 3
@


11.4
log
@Oops, envmap_setup() was missing an argument.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/sh_text.c,v 11.3 1995/06/02 23:34:05 mike Exp mike $ (BRL)";
d51 1
a51 1
	"texture",	0,		0,		MFI_UV,
d54 1
a54 1
	"bwtexture",	0,		0,		MFI_UV,
d57 1
a57 1
	"checker",	0,		0,		MFI_UV,
d60 1
a60 1
	"testmap",	0,		0,		MFI_UV,
d63 1
a63 1
	"fakestar",	0,		0,		0,
d66 1
a66 1
	"bump",		0,		0,		MFI_UV|MFI_NORMAL,
d69 1
a69 1
	"envmap",	0,		0,		0,
d72 1
a72 1
	(char *)0,	0,		0,		0,
@


11.3
log
@mlib_setup() and the XXX->mf_setup() routines now take rtip as final arg.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.2 1995/03/11 02:24:14 mike Exp mike $ (BRL)";
d618 1
a618 1
envmap_setup( rp, matparm, dpp, rtip )
d622 1
@


11.2
log
@Added mfp parameter to mf_setup() call.
This allows the shader setup routine to know what name it was invoked by.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.1 95/01/04 10:01:13 mike Rel4_4 Locker: mike $ (BRL)";
d618 1
a618 1
envmap_setup( rp, matparm, dpp )
d622 1
d628 1
d662 1
a662 1
	if( mlib_setup( &env_region ) < 0 )
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.8 94/12/19 19:54:28 mike Exp $ (BRL)";
d315 1
a315 1
txt_setup( rp, matparm, dpp )
d319 1
d346 1
a346 1
	if( strcmp( rp->reg_mater.ma_matname, "bwtexture" ) == 0 )
d349 1
a349 1
		rt_log("\nERROR %s %s needs %d bytes, '%s' only has %d\n",
d351 1
a351 1
			rp->reg_mater.ma_matname,
@


10.8
log
@Bug 237 -- check size of texture file.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.7 94/11/30 19:23:24 mike Exp Locker: mike $ (BRL)";
@


10.7
log
@Added error message
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.6 94/11/15 21:57:51 mike Exp Locker: mike $ (BRL)";
a80 1
	int	tx_fw;		/* File width of texture in pixels */
a93 1
	{"%d",	1, "fw",	TX_O(tx_fw),		FUNC_NULL },
d321 1
d328 1
a328 1
	tp->tx_w = tp->tx_fw = tp->tx_n = -1;
a335 1
	if( tp->tx_fw < 0 )  tp->tx_fw = tp->tx_w;
d341 17
a357 3
	if( tp->mp = rt_open_mapped_file( tp->tx_file, NULL ) )
		return 1;				/* OK */
	return -1;					/* FAIL */
@


10.6
log
@Added "bwtexture" shader.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.5 94/11/05 02:53:18 mike Exp Locker: mike $ (BRL)";
d647 2
a648 1
	(void)mlib_setup( &env_region );
@


10.5
log
@Irix 6
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.4 94/10/29 02:38:11 mike Exp Locker: mike $ (BRL)";
d35 1
d39 1
d54 3
a89 5
#if CRAY && !__STDC__
	/* Hack for old Cray compilers */
	{"%d",	1, "transp",	0,			txt_transp_hook },
	{"%s",	TXT_NAME_LEN, "file",	3,		FUNC_NULL },
#else
a91 1
#endif
d213 90
@


10.4
log
@Converted over to using rt_open_mapped_file().
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.3 94/08/11 02:29:04 gdurf Exp Locker: mike $ (BRL)";
d404 7
a410 5
/***	{ 0.446728, 0.493157, 0.727269 },	/* fake 12000 */
/***	{ 0.446728, 0.493157, 0.727269 },	/* fake 13000 */
/***	{ 0.446728, 0.493157, 0.727269 },	/* fake 14000 */
/***	{ 0.446728, 0.493157, 0.727269 }	/* fake 15000 */
/***	{ 0.393433 0.488079 0.940423 },	/* 20000 */
d460 1
a460 1
	vect_t	x, y;		/* world coordinate axis vectors */
a462 1
	char *save;
a482 1
	VSET( x, 1, 0, 0 );
@


10.3
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.2 1994/03/09 17:57:53 mike Exp gdurf $ (BRL)";
a77 1
	char	*tx_pixels;	/* Pixel holding area */
d79 1
a123 1

a124 43
 *			T X T _ R E A D
 *
 *  Load the texture into memory.
 *  Returns 0 on failure, 1 on success.
 */
HIDDEN int
txt_read( tp )
register struct txt_specific *tp;
{
	char *linebuf;
	register FILE *fp;
	register int	i;
	register int	got;

	if( (fp = fopen(tp->tx_file, "r")) == NULL )  {
		rt_log("txt_read(%s):  can't open\n", tp->tx_file);
		tp->tx_file[0] = '\0';
		return(0);
	}
	linebuf = rt_malloc(tp->tx_fw*3,"texture file line");
	tp->tx_pixels = rt_malloc(
		tp->tx_w * tp->tx_n * 3,
		tp->tx_file );
	for( i=0; i<tp->tx_n; i++ )  {
		got = fread(linebuf, 1, tp->tx_fw*3, fp);
		if( got != tp->tx_fw*3 ) {
			rt_log("txt_read: read error on %s\n", tp->tx_file);
			rt_log("txt_read: wanted %d, got %d on line %d\n", tp->tx_fw*3, got, i);
			(void)fclose(fp);
			rt_free( tp->tx_pixels, tp->tx_file );
			rt_free(linebuf,"file line, error");
			tp->tx_file[0] = '\0';
			tp->tx_n = -1;
			return(0);
		}
		bcopy( linebuf, tp->tx_pixels + i*tp->tx_w*3, tp->tx_w*3 );
	}
	(void)fclose(fp);
	rt_free(linebuf,"texture file line");
	return(1);	/* OK */
}

/*
d152 1
a152 2
	if( tp->tx_file[0] == '\0'  ||
	    ( tp->tx_pixels == (char *)0 && txt_read(tp) == 0 ) )  {
d187 2
a188 2
		cp = (unsigned char *)(tp->tx_pixels +
		     (y+line) * tp->tx_w * 3  +  x * 3);
a248 1
	tp->tx_pixels = (char *)0;
d253 4
a256 4
	if( txt_read(tp) == 0 )
		return(-1);
	else
		return(1);
d276 4
a279 3
	if( ((struct txt_specific *)cp)->tx_pixels )
		rt_free( ((struct txt_specific *)cp)->tx_pixels,
			((struct txt_specific *)cp)->tx_file );
d467 1
a467 2
	if( tp->tx_file[0] == '\0'  ||
	    ( tp->tx_pixels == (char *)0 && txt_read(tp) == 0 ) )  {
d491 2
a492 2
	cp = (unsigned char *)(tp->tx_pixels +
	     (j) * tp->tx_w * 3  +  i * 3);
@


10.2
log
@Eliminiated dead code.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.1 91/10/12 06:42:13 mike Rel4_0 Locker: mike $ (BRL)";
d21 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.12 91/07/06 00:35:24 mike Exp $ (BRL)";
a477 11
struct phong_specific {
	int	shine;
	double	wgt_specular;
	double	wgt_diffuse;
	double	transmit;	/* Moss "transparency" */
	double	reflect;	/* Moss "transmission" */
	double	refrac_index;
} junk = {
	10, 0.7, 0.3, 0, 0, 1.0
};

a552 1
	/*phong_render( ap, pp, swp, &junk );*/
@


9.12
log
@ANSI structure initialization
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.11 91/02/20 01:16:58 mike Exp $ (BRL)";
@


9.11
log
@Changed handling of env_region to be sensitive to the fact that
reg_name, reg_treetop, etc, pointers will go away,
and thus need to be explicitly duplicated if needed.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.10 91/02/17 20:15:56 mike Exp $ (BRL)";
d85 2
a86 2
	"%d",	1, "transp",	0,			txt_transp_hook,
	"%s",	TXT_NAME_LEN, "file",	3,		FUNC_NULL,
d88 2
a89 2
	"%d",	1, "transp",	offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook,
	"%s",	TXT_NAME_LEN, "file", offsetofarray(struct txt_specific, tx_file),		FUNC_NULL,
d91 6
a96 6
	"%d",	1, "w",		TX_O(tx_w),		FUNC_NULL,
	"%d",	1, "n",		TX_O(tx_n),		FUNC_NULL,
	"%d",	1, "l",		TX_O(tx_n),		FUNC_NULL, /*compat*/
	"%d",	1, "fw",	TX_O(tx_fw),		FUNC_NULL,
	"%d",	1, "trans_valid",	TX_O(tx_trans_valid),	FUNC_NULL,
	"",	0, (char *)0,	0,			FUNC_NULL
d336 2
a337 2
	"%d",	1, "a",		0,			FUNC_NULL,
	"%d",	1, "b",		1,			FUNC_NULL,
d339 2
a340 2
	"%d",	1, "a",	offsetofarray(struct ckr_specific, ckr_a), FUNC_NULL,
	"%d",	1, "b",	offsetofarray(struct ckr_specific, ckr_b), FUNC_NULL,
d342 1
a342 1
	"",	0, (char *)0,	0,			FUNC_NULL
@


9.10
log
@Check return code from rt_structparse()
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.9 91/02/17 18:50:56 mike Exp $ (BRL)";
d31 1
a31 1
extern struct region	env_region;		/* in do.c */
d586 4
d596 2
a597 1
	while( *cp != '\0' && isascii(*cp) && !isspace(*cp) )
d599 9
a607 1
	*cp++ = '\0';
@


9.9
log
@Added extra vls check
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.8 91/01/05 03:09:18 mike Exp $ (BRL)";
d285 4
a288 1
	rt_structparse( matparm, txt_parse, (char *)tp );
d387 4
a390 1
	rt_structparse( matparm, ckr_parse, (char *)ckp );
@


9.8
log
@Converted to new format for fmt entry in structparse
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.7 91/01/03 22:58:23 butler Exp $ (BRL)";
d278 1
@


9.7
log
@updates to work with new structparse routines
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.6 90/12/12 16:35:12 butler Exp $ (BRL)";
d94 1
a94 1
	"%d",	1, "fw",		TX_O(tx_fw),	FUNC_NULL,
d96 1
a96 1
	(char *)0, 0,(char *)0,	0,			FUNC_NULL
d338 1
a338 1
	(char *)0, 0, (char *)0,	0,		FUNC_NULL
@


9.6
log
@modified to reflect changes in structparse format
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.5 90/12/10 21:14:44 mike Exp $ (BRL)";
d71 1
a71 1
	unsigned char tx_transp[8];	/* RGB for transparency */
d77 1
a77 1
	int	trans_valid;	/* boolean: is tx_transp valid ? */
d85 2
a86 2
	"%C",	1, "transp",	0,			txt_transp_hook,
	"%s",	TXT_NAME_LEN, "file",	1,			FUNC_NULL,
d88 1
a88 1
	"%C",	1, "transp",	offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook,
d94 2
a95 2
	"%d",	1, "fw",		TX_O(tx_fw),		FUNC_NULL,
	"%d",	1, "trans_valid",	TX_O(trans_valid),	FUNC_NULL,
d115 1
a115 1
		tp->trans_valid = 1;
d243 1
a243 1
	if( tp->tx_transp[3] == 0 )  {
d251 6
a256 4
	/* This circumlocution needed to keep expression simple for Cray, others */
	if( r != (tp->tx_transp[0]) )  goto opaque;
	if( g != (tp->tx_transp[1]) )  goto opaque;
	if( b != (tp->tx_transp[2]) )  goto opaque;
d283 1
d290 1
a290 1
	if( tp->trans_valid )
d323 2
a324 2
	unsigned char	ckr_a[8];	/* first RGB */
	unsigned char	ckr_b[8];	/* second RGB */
d332 2
a333 2
	"%C",	1, "a",		0,			FUNC_NULL,
	"%C",	1, "b",		1,			FUNC_NULL,
d335 2
a336 2
	"%C",	1, "a",	offsetofarray(struct ckr_specific, ckr_a), FUNC_NULL,
	"%C",	1, "b",	offsetofarray(struct ckr_specific, ckr_b), FUNC_NULL,
d353 1
a353 1
	register unsigned char *cp;
d362 3
a364 3
		cp[0] * rt_inv255,
		cp[1] * rt_inv255,
		cp[2] * rt_inv255 );
d384 6
@


9.5
log
@Improved handling of environment maps.
Copy the string before banging nulls into it.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.4 90/12/08 08:58:13 butler Exp $ (BRL)";
d69 1
d72 1
a72 1
	char	tx_file[128];	/* Filename */
d85 2
a86 2
	"%C",	"transp",	0,			txt_transp_hook,
	"%s",	"file",		1,			FUNC_NULL,
d88 2
a89 2
	"%C",	"transp",	offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook,
	"%s",	"file",		offsetofarray(struct txt_specific, tx_file),		FUNC_NULL,
d91 6
a96 6
	"%d",	"w",		TX_O(tx_w),		FUNC_NULL,
	"%d",	"n",		TX_O(tx_n),		FUNC_NULL,
	"%d",	"l",		TX_O(tx_n),		FUNC_NULL, /*compat*/
	"%d",	"fw",		TX_O(tx_fw),		FUNC_NULL,
	"%d",	"trans_valid",	TX_O(trans_valid),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
d329 2
a330 2
	"%C",	"a",		0,			FUNC_NULL,
	"%C",	"b",		1,			FUNC_NULL,
d332 2
a333 2
	"%C",	"a",		offsetofarray(struct ckr_specific, ckr_a),		FUNC_NULL,
	"%C",	"b",		offsetofarray(struct ckr_specific, ckr_b),		FUNC_NULL,
d335 1
a335 1
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.4
log
@changed material property parameter to be struct rt_vls
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.3 90/12/08 08:30:46 mike Exp $ (BRL)";
d23 1
d561 1
d571 2
d574 2
a575 2
	cp = RT_VLS_ADDR( matparm );
	while( *cp != '\0' && *cp != ' ' )
d579 3
a581 1
	strncpy( env_region.reg_mater.ma_matparm, cp++,
a583 7
	/* truncate the string to just the material name */
	rt_vls_trunc( matparm, (int)(--cpp - RT_VLS_ADDR(matparm)) );

	strncpy( env_region.reg_mater.ma_matname, RT_VLS_ADDR(matparm),
		sizeof(rp->reg_mater.ma_matname) );


d585 1
@


9.3
log
@fixed bugs
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.2 90/12/08 08:20:14 mike Exp $ (BRL)";
d556 1
a556 1
char	*matparm;
d561 1
d570 1
a570 1
	cp = matparm;
d574 8
a581 1
	strncpy( env_region.reg_mater.ma_matname, matparm,
d583 2
a584 2
	strncpy( env_region.reg_mater.ma_matparm, cp,
		sizeof(rp->reg_mater.ma_matparm) );
@


9.2
log
@Changed to using rt_structparse's hooked function feature,
rather than the magic [3] element of RGB arrays.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.1 89/05/19 05:59:46 mike Rel3_5 $ (BRL)";
d268 3
a270 3
register struct region *rp;
char	*matparm;
char	**dpp;
d368 3
a370 3
register struct region *rp;
char	*matparm;
char	**dpp;
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: sh_text.c,v 8.10 89/04/30 21:26:16 mike Exp $ (BRL)";
d38 1
d75 1
d83 1
a83 1
	"%C",	"transp",	0,			FUNC_NULL,
d86 1
a86 1
	"%C",	"transp",	offsetofarray(struct txt_specific, tx_transp),	FUNC_NULL,
d91 1
a91 1
	"%d",	"l",		TX_O(tx_n),		FUNC_NULL,	/*compat*/
d93 1
d98 24
d284 2
a285 1
	if( tp->tx_transp[3] != 0 )
d287 1
@


8.10
log
@The rand() macros now require a parameter which is the random number
table pointer to be used.  This provides perfectly "safe" access to
the random number tables in a parallel processing environment.
Each processor is seeded differently in worker.c
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: sh_text.c,v 8.9 89/04/28 06:16:04 mike Locked $ (BRL)";
@


8.9
log
@Fixed fixed Cray hack
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: sh_text.c,v 8.8 89/04/05 01:47:01 phil Locked $ (BRL)";
d418 1
a418 1
	if( rand0to1() >= 0.98 )  {
d422 2
a423 2
		i = ((double)i) * rand0to1();
		f = rand0to1();
@


8.8
log
@Fixed up Cray hack
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.7 89/04/04 05:02:11 mike Locked $ (BRL)";
d82 1
a82 1
	"%s",	"file",		8,			FUNC_NULL,
d299 1
a299 1
	"%C",	"b",		8,			FUNC_NULL,
@


8.7
log
@Converted to new way of representing structure offsets.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.6 89/03/29 15:32:34 mike Locked $ (BRL)";
d79 5
a83 1
#ifndef CRAY
a85 3
#else
	"%C",	"transp",	0,			FUNC_NULL,
	"%s",	"file",		1,			FUNC_NULL,
d296 5
a300 1
#ifndef CRAY
a302 3
#else
	"%C",	"a",		0,			FUNC_NULL,
	"%C",	"b",		1,			FUNC_NULL,
@


8.6
log
@removed color bias in texture and checker
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.5 89/03/11 05:27:17 phil Locked $ (BRL)";
d76 1
d80 2
a81 2
	"%C",	"transp",	(stroff_t)(TX_NULL->tx_transp),		FUNC_NULL,
	"%s",	"file",		(stroff_t)(TX_NULL->tx_file),		FUNC_NULL,
d83 2
a84 2
	"%C",	"transp",	(stroff_t)0,				FUNC_NULL,
	"%s",	"file",		(stroff_t)1,				FUNC_NULL,
d86 5
a90 5
	"%d",	"w",		(stroff_t)&(TX_NULL->tx_w),		FUNC_NULL,
	"%d",	"n",		(stroff_t)&(TX_NULL->tx_n),		FUNC_NULL,
	"%d",	"l",		(stroff_t)&(TX_NULL->tx_n),		FUNC_NULL,	/*compat*/
	"%d",	"fw",		(stroff_t)&(TX_NULL->tx_fw),		FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d251 1
a251 1
	rt_structparse( matparm, txt_parse, (stroff_t)tp );
d271 1
a271 1
	rt_structprint(rp->reg_name, txt_parse, (stroff_t)rp->reg_udata);
d291 2
a292 1
#define CKR_NULL ((struct ckr_specific *)0)
d296 2
a297 2
	"%C",	"a",		(stroff_t)(CKR_NULL->ckr_a),		FUNC_NULL,
	"%C",	"b",		(stroff_t)(CKR_NULL->ckr_b),		FUNC_NULL,
d299 2
a300 2
	"%C",	"a",		(stroff_t)0,				FUNC_NULL,
	"%C",	"b",		(stroff_t)1,				FUNC_NULL,
d302 1
a302 1
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d347 1
a347 1
	rt_structparse( matparm, ckr_parse, (stroff_t)ckp );
d358 1
a358 1
	rt_structprint(rp->reg_name, ckr_parse, (stroff_t)rp->reg_udata);
@


8.5
log
@Type conversion problem in the bump mapping routine.  Added some
debugging in the process.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.4 89/01/09 06:07:25 phil Locked $ (BRL)";
d215 3
a217 3
			(r+0.5) * rt_inv255,
			(g+0.5) * rt_inv255,
			(b+0.5) * rt_inv255 );
d324 3
a326 3
		(cp[0]+0.5) * rt_inv255,
		(cp[1]+0.5) * rt_inv255,
		(cp[2]+0.5) * rt_inv255 );
@


8.4
log
@Moved env_region into do.c, sigh.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.3 88/12/27 16:35:17 mike Locked $ (BRL)";
d497 2
a498 2
	pertU = (*cp - 128) / 128.0;
	pertV = (*(cp+2) - 128) / 128.0;
d500 7
d509 3
@


8.3
log
@Converted matparse --> structparse
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.2 88/12/13 03:16:57 mike Locked $ (BRL)";
d30 1
a30 1
struct region	env_region;
@


8.2
log
@Improved complaints on error in texture file.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.1 88/10/05 00:33:31 mike Locked $ (BRL)";
d77 1
a77 1
struct matparse txt_parse[] = {
d79 2
a80 2
	"transp",	(mp_off_ty)(TX_NULL->tx_transp),"%C",
	"file",		(mp_off_ty)(TX_NULL->tx_file),	"%s",
d82 2
a83 2
	"transp",	(mp_off_ty)0,			"%C",
	"file",		(mp_off_ty)1,			"%s",
d85 5
a89 5
	"w",		(mp_off_ty)&(TX_NULL->tx_w),	"%d",
	"n",		(mp_off_ty)&(TX_NULL->tx_n),	"%d",
	"l",		(mp_off_ty)&(TX_NULL->tx_n),	"%d",	/*compat*/
	"fw",		(mp_off_ty)&(TX_NULL->tx_fw),	"%d",
	(char *)0,	(mp_off_ty)0,			(char *)0
d250 1
a250 1
	mlib_parse( matparm, txt_parse, (mp_off_ty)tp );
d270 1
a270 1
	mlib_print(rp->reg_name, txt_parse, (mp_off_ty)rp->reg_udata);
d292 1
a292 1
struct matparse ckr_parse[] = {
d294 2
a295 2
	"a",		(mp_off_ty)(CKR_NULL->ckr_a),	"%C",
	"b",		(mp_off_ty)(CKR_NULL->ckr_b),	"%C",
d297 2
a298 2
	"a",		(mp_off_ty)0,			"%C",
	"b",		(mp_off_ty)1,			"%C",
d300 1
a300 1
	(char *)0,	(mp_off_ty)0,			(char *)0
d345 1
a345 1
	mlib_parse( matparm, ckr_parse, (mp_off_ty)ckp );
d356 1
a356 1
	mlib_print(rp->reg_name, ckr_parse, (mp_off_ty)rp->reg_udata);
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.7 88/09/17 07:20:58 mike Exp $ (BRL)";
d104 2
a105 1
	register int i;
d117 2
a118 1
		if( fread(linebuf,1,tp->tx_fw*3,fp) != tp->tx_fw*3 ) {
d120 1
a120 1
			tp->tx_file[0] = '\0';
d122 1
d124 2
@


7.7
log
@cray-->CRAY.  The C compiler bug still remains.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.6 88/06/21 02:53:43 mike Locked $ (BRL)";
@


7.6
log
@Made number of scanlines (height) parameter be "n",
and width be "w", to be consistent with the BRLCAD convention,
as exhibited by pix-fb and many others.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.5 88/06/19 05:43:22 mike Locked $ (BRL)";
d78 1
a78 1
#ifndef cray
d288 1
a288 1
#ifndef cray
@


7.5
log
@Changed maximum bump map perturbation from 45 degrees to 90 degrees.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.4 88/05/14 02:28:28 mike Locked $ (BRL)";
d72 1
a72 1
	int	tx_l;		/* Length of pixels in lines */
d86 2
a87 1
	"l",		(mp_off_ty)&(TX_NULL->tx_l),	"%d",
d113 1
a113 1
		tp->tx_w * tp->tx_l * 3,
d115 1
a115 1
	for( i=0; i<tp->tx_l; i++ )  {
d184 1
a184 1
	y = ymin * (tp->tx_l-1);
d186 1
a186 1
	dy = (ymax - ymin) * (tp->tx_l-1);
d244 1
a244 1
	tp->tx_w = tp->tx_fw = tp->tx_l = -1;
d247 1
a247 1
	if( tp->tx_l < 0 )  tp->tx_l = tp->tx_w;
d489 1
a489 1
	j = swp->sw_uv.uv_v * (tp->tx_l-1);
@


7.4
log
@lint fixes
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.3 88/02/27 07:47:10 mike Locked $ (BRL)";
d491 2
a492 2
	pertU = (*cp - 128) / 256.0;
	pertV = (*(cp+2) - 128) / 256.0;
@


7.3
log
@Added support for material "envmap" -- an environment map,
with an arbitrary shader attached.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.2 88/01/26 05:55:04 mike Locked $ (BRL)";
d32 6
a37 3
HIDDEN int txt_setup(), txt_render(), txt_print(), txt_free();
HIDDEN int ckr_setup(), ckr_render(), ckr_print(), ckr_free();
HIDDEN int bmp_setup(), bmp_render(), bmp_print(), bmp_free();
d42 1
d52 1
a52 1
	mlib_one,	tstm_render,	mlib_zero,	mlib_zero,
d55 1
a55 1
	mlib_one,	star_render,	mlib_zero,	mlib_zero,
d61 1
a61 1
	envmap_setup,	mlib_zero,	mlib_zero,	mlib_zero,
d138 1
a138 1
HIDDEN
d260 1
a260 1
HIDDEN int
d270 1
a270 1
HIDDEN int
d321 1
d346 1
a346 1
HIDDEN int
d356 1
a356 1
HIDDEN int
d418 1
@


7.2
log
@Changed return codes from setup routines to 1, to honor new
return code convention for mlib_setup().
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.1 87/11/02 23:56:39 mike Locked $ (BRL)";
d30 2
d37 1
d56 3
d493 31
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 6.3 87/09/16 04:33:56 mike Exp $ (BRL)";
d35 1
a35 1
extern int mlib_zero();
d45 1
a45 1
	mlib_zero,	tstm_render,	mlib_zero,	mlib_zero,
d48 1
a48 1
	mlib_zero,	star_render,	mlib_zero,	mlib_zero,
d241 4
a244 1
	return( txt_read(tp) );
@


6.3
log
@Default checker pattern is now white and black, rather than all black.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 6.2 87/09/03 01:30:37 mike Locked $ (BRL)";
@


6.2
log
@Added incremental resolution capability.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 6.1 87/07/11 07:59:26 mike Rel $ (BRL)";
d321 1
d324 1
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.6 87/07/10 05:06:07 mike Exp $ (BRL)";
d196 2
a197 4
	if( tp->tx_transp[3] == 0 ||
	    r != (tp->tx_transp[0]) ||
	    g != (tp->tx_transp[1]) ||
	    b != (tp->tx_transp[2]) )  {
d204 4
@


5.6
log
@When converting integer RGB to 0..1 floats, changed to
add 0.5 and multiply by rt_inv255.
Also changed to handle transparency in the reflect/refract routines
at a higher level.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.5 87/07/06 15:09:30 mike Locked $ (BRL)";
@


5.5
log
@First stages of support for reg_transmit
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.4 87/06/27 06:46:23 mike Locked $ (BRL)";
d195 1
a195 6
	/*
	 * Transparency mapping is enabled, and we hit a transparent spot.
	 * Fire another ray to determine the actual color
	 */
#ifndef crayXX
/* UNICOS 2.0 BUG */
d200 4
a203 3
		FAST fastf_t f;
		f = 1.0 / 255.0;
		VSET( swp->sw_color, r * f, g * f, b * f );
d206 7
a212 19
#endif
	if( pp->pt_outhit->hit_dist >= INFINITY )  {
		rt_log("txt_render:  transparency on infinite object?\n");
		VSET( swp->sw_color, 0, 1, 0 );
		return(1);
	}
	if( (ap->a_level%100) > 5 )  {
		VSET( swp->sw_color, .1, .1, .1);
		return(1);
	}
	{
		auto struct application sub_ap;
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_level = ap->a_level+1;
		VJOIN1( sub_ap.a_ray.r_pt, ap->a_ray.r_pt,
			pp->pt_outhit->hit_dist, ap->a_ray.r_dir );
		(void)rt_shootray( &sub_ap );
		VMOVE( swp->sw_color, sub_ap.a_color );
	}
a293 1
	auto struct uvcoord uv;
a294 1
	FAST fastf_t f;
d302 4
a305 2
	f = 1.0/255.;
	VSET( swp->sw_color, cp[0]*f, cp[1]*f, cp[2]*f );
@


5.4
log
@rendering parameter changes
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.3 87/06/27 03:58:31 phil Locked $ (BRL)";
d253 2
@


5.3
log
@added crude bump mapping
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.2 87/06/26 05:55:17 phil Locked $ (BRL)";
d129 1
a129 1
txt_render( ap, pp, swp )
d133 1
d136 1
a136 1
		(struct txt_specific *)pp->pt_regionp->reg_udata;
d236 1
a236 1
txt_setup( rp )
d238 2
d244 1
a244 1
	rp->reg_udata = (char *)tp;
d248 1
a248 1
	mlib_parse( rp->reg_mater.ma_matparm, txt_parse, (mp_off_ty)tp );
d300 1
a300 1
ckr_render( ap, pp, swp )
d304 1
d307 1
a307 1
		(struct ckr_specific *)pp->pt_regionp->reg_udata;
d326 1
a326 1
ckr_setup( rp )
d328 2
d334 2
a335 2
	rp->reg_udata = (char *)ckp;
	mlib_parse( rp->reg_mater.ma_matparm, ckr_parse, (mp_off_ty)ckp );
d366 1
a366 1
tstm_render( ap, pp, swp )
d370 1
d397 1
a397 1
star_render( ap, pp, swp )
d401 1
d440 1
a440 1
bmp_render( ap, pp, swp )
d444 1
d447 1
a447 1
		(struct txt_specific *)pp->pt_regionp->reg_udata;
d492 1
a492 4
	save = pp->pt_regionp->reg_udata;
	pp->pt_regionp->reg_udata = (char *)&junk;
	phong_render( ap, pp, swp );
	pp->pt_regionp->reg_udata = save;
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.1 87/06/24 22:15:31 mike Locked $ (BRL)";
d32 1
d50 3
d151 1
a152 8
	if( swp->sw_uv.uv_u < 0 || swp->sw_uv.uv_u > 1 || swp->sw_uv.uv_v < 0 || swp->sw_uv.uv_v > 1 )  {
		rt_log("txt_render:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
			swp->sw_uv.uv_u, swp->sw_uv.uv_v,
			swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
			pp->pt_inseg->seg_stp->st_name );
		VSET( swp->sw_color, 0, 1, 0 );
		return(1);
	}
d406 82
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 4.3 87/03/23 23:48:04 mike Exp $ (BRL)";
d37 1
a37 1
	"texture",	0,		0,
d40 1
a40 1
	"checker",	0,		0,
d43 1
a43 1
	"testmap",	0,		0,
d46 1
a46 1
	"fakestar",	0,		0,
d49 1
a49 1
	(char *)0,	0,		0,
d92 1
a92 1
		rt_log("txt_render(%s):  can't open\n", tp->tx_file);
d125 4
a128 3
txt_render( ap, pp )
struct application *ap;
struct partition *pp;
a131 1
	auto struct uvcoord uv;
a137 5
	VJOIN1( pp->pt_inhit->hit_point, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
		ap, pp->pt_inseg->seg_stp, pp->pt_inhit, &uv );

d144 1
a144 1
		VSET( ap->a_color, uv.uv_u, 0, uv.uv_v );
d148 1
a148 1
	if( uv.uv_u < 0 || uv.uv_u > 1 || uv.uv_v < 0 || uv.uv_v > 1 )  {
d150 2
a151 2
			uv.uv_u, uv.uv_v,
			uv.uv_du, uv.uv_dv,
d153 1
a153 1
		VSET( ap->a_color, 0, 1, 0 );
d157 2
a158 2
	if( uv.uv_du > 0.125 )  uv.uv_du = 0.125;
	if( uv.uv_dv > 0.125 )  uv.uv_dv = 0.125;
d160 1
a160 1
	if( uv.uv_du < 0 || uv.uv_dv < 0 )  {
d162 1
a162 1
			uv.uv_u, uv.uv_v, uv.uv_du, uv.uv_dv,
d164 1
a164 1
		uv.uv_du = uv.uv_dv = 0;
d166 4
a169 4
	xmin = uv.uv_u - uv.uv_du;
	xmax = uv.uv_u + uv.uv_du;
	ymin = uv.uv_v - uv.uv_dv;
	ymax = uv.uv_v + uv.uv_dv;
d209 1
a209 1
		VSET( ap->a_color, r * f, g * f, b * f );
d215 1
a215 1
		VSET( ap->a_color, 0, 1, 0 );
d219 1
a219 1
		VSET( ap->a_color, .1, .1, .1);
d229 1
a229 1
		VMOVE( ap->a_color, sub_ap.a_color );
d300 4
a303 3
ckr_render( ap, pp )
register struct application *ap;
register struct partition *pp;
d311 2
a312 7
	VJOIN1( pp->pt_inhit->hit_point, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
		ap, pp->pt_inseg->seg_stp, pp->pt_inhit, &uv );

	if( (uv.uv_u < 0.5 && uv.uv_v < 0.5) ||
	    (uv.uv_u >=0.5 && uv.uv_v >=0.5) )  {
d318 1
a318 1
	VSET( ap->a_color, cp[0]*f, cp[1]*f, cp[2]*f );
d363 4
a366 3
tstm_render( ap, pp )
register struct application *ap;
register struct partition *pp;
d368 1
a368 7
	auto struct uvcoord uv;

	VJOIN1( pp->pt_inhit->hit_point, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
		ap, pp->pt_inseg->seg_stp, pp->pt_inhit, &uv );
	VSET( ap->a_color, uv.uv_u, 0, uv.uv_v );
d393 1
a393 1
star_render( ap, pp )
d396 1
d405 1
a405 1
		VSCALE( ap->a_color, star_colors[i], f );
d407 1
a407 1
		VSETALL( ap->a_color, 0 );
@


4.3
log
@Revised for new material property interface.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 4.2 87/02/13 00:02:54 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 4.1 86/12/29 03:48:51 mike Rel1 $ (BRL)";
d30 23
d242 1
a242 1
int
a248 1
	rp->reg_ufunc = txt_render;
a257 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, txt_parse, (mp_off_ty)tp);
d261 23
d304 1
a304 1
HIDDEN
d333 1
a333 1
int
a339 2
	bzero( (char *)ckp, sizeof(struct ckr_specific) );
	rp->reg_ufunc = ckr_render;
a341 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, ckr_parse, (mp_off_ty)ckp);
d346 21
a366 1
 *			T E S T M A P _ R E N D E R
d372 1
a372 1
testmap_render( ap, pp )
a385 12
/*
 *			T M A P _ S E T U P
 */
tmap_setup( rp )
register struct region *rp;
{
	rp->reg_ufunc = testmap_render;
	rp->reg_udata = (char *)0;
	return(1);
}


a421 12
}

/*
 *			S T A R _ S E T U P
 */
int
star_setup( rp )
register struct region *rp;
{
	rp->reg_ufunc = star_render;
	rp->reg_udata = (char *)0;
	return(1);
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.15 86/12/24 04:27:12 mike Locked $ (BRL)";
@


3.15
log
@Made checker patterns work right.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.14 86/12/18 16:02:09 mike Locked $ (BRL)";
@


3.14
log
@rdebug.h separated from librt/debug.h
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.13 86/11/07 02:46:25 mike Locked $ (BRL)";
a113 1
	fastf_t f;
d126 1
a126 1
		VSET( ap->a_color, uv.uv_u*255, 0, uv.uv_v*255 );
d189 1
d242 2
a243 2
	char	ckr_a[8];	/* first RGB */
	char	ckr_b[8];	/* second RGB */
d269 2
a270 1
	register char *cp;
d283 2
a284 1
	VSET( ap->a_color, cp[0]*255, cp[1]*255, cp[2]*255 );
@


3.13
log
@Changed so that computation of hit_point and hit_norm is done
in the individual material routines, and only as much as needed.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.12 86/11/04 21:05:57 mike Locked $ (BRL)";
d28 1
d31 1
a31 1
	char	tx_transp[4];	/* RGB for transparency */
d42 5
a46 2
	"transp",	(int)(TX_NULL->tx_transp),	"%C",
	"file",		(int)(TX_NULL->tx_file),	"%s",
d48 4
a51 4
	"w",		(int)&(TX_NULL->tx_w),		"%d",
	"l",		(int)&(TX_NULL->tx_l),		"%d",
	"fw",		(int)&(TX_NULL->tx_fw),		"%d",
	(char *)0,	0,				(char *)0
d184 1
a184 1
#ifndef cray
d187 3
a189 3
	    r != (tp->tx_transp[0]&0xFF) ||
	    g != (tp->tx_transp[1]&0xFF) ||
	    b != (tp->tx_transp[2]&0xFF) )  {
d231 1
a231 1
	mlib_parse( rp->reg_mater.ma_matparm, txt_parse, (char *)tp );
d236 2
a237 1
mlib_print("txt_setup", txt_parse, (char *)tp);
d242 2
a243 3
	int	ckr_r[2];
	int	ckr_g[2];
	int	ckr_b[2];
d248 8
a255 6
	"r",		(int)&(CKR_NULL->ckr_r[0]),	"%d",
	"g",		(int)&(CKR_NULL->ckr_g[0]),	"%d",
	"b",		(int)&(CKR_NULL->ckr_b[0]),	"%d",
	"R",		(int)&(CKR_NULL->ckr_r[1]),	"%d",
	"G",		(int)&(CKR_NULL->ckr_g[1]),	"%d",
	"B",		(int)&(CKR_NULL->ckr_b[1]),	"%d"
d269 1
d278 1
a278 1
		VSET( ap->a_color, ckp->ckr_r[0], ckp->ckr_g[0], ckp->ckr_b[0] );
d280 1
a280 1
		VSET( ap->a_color, ckp->ckr_r[1], ckp->ckr_g[1], ckp->ckr_b[1] );
d282 1
d298 3
a300 1
	mlib_parse( rp->reg_mater.ma_matparm, ckr_parse, (char *)ckp );
d383 1
@


3.12
log
@Improved fake stars

@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.11 86/10/29 04:51:18 mike Locked $ (BRL)";
d112 2
d264 2
d307 2
@


3.11
log
@Added fakestar function
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.10 86/09/23 17:12:41 mike Locked $ (BRL)";
d320 18
d347 7
a353 6
	if( rand0to1() > 0.95 )  {
		/* Stars have color.  may overflow 1.0 */
		VSET( ap->a_color,
			rand0to1()+0.5,
			rand0to1()+0.5,
			rand0to1()+0.5 );
@


3.10
log
@Minor cray nits.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.9 86/08/12 05:50:59 mike Exp $ (BRL)";
d27 1
d317 31
@


3.9
log
@Changed to find #include files with CC -I../h
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.8 86/07/31 08:29:37 mike Exp $ (BRL)";
d29 1
a34 1
	char	tx_transp[4];	/* RGB for transparency */
d39 2
d42 1
a45 3
#ifndef cray
	"transp",	(int)(TX_NULL->tx_transp),	"%C",
#endif
d101 1
a101 1
	struct txt_specific *tp =
d177 2
d187 1
@


3.8
log
@Cray braindamage
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.7 86/07/30 03:56:40 mike Exp $ (BRL)";
d23 4
a26 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "material.h"
@


3.7
log
@Preload texture maps at prep time.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.6 86/07/28 22:52:56 mike Exp $ (BRL)";
d29 1
a29 1
	char	*tx_file[128];	/* Filename */
d34 1
a34 1
	unsigned char tx_transp[4];	/* RGB for transparency */
d39 1
a39 1
	"file",		(int)&(TX_NULL->tx_file[0]),	"%s",
d43 3
a45 1
	"transp",	(int)&(TX_NULL->tx_transp[0]),	"%C",
d178 3
a180 3
	    r != tp->tx_transp[0] ||
	    g != tp->tx_transp[1] ||
	    b != tp->tx_transp[2] )  {
@


3.6
log
@Added support for transparent textures.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.5 86/07/24 06:05:39 mike Exp $ (BRL)";
d225 1
a225 1
	return(1);
@


3.5
log
@Added uvcoord code, conical ray divergance.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.4 86/07/24 03:58:22 mike Exp $ (BRL)";
d34 1
d39 1
a39 1
	"file",		(int)(TX_NULL->tx_file),	"%s",
d43 1
d158 1
a158 1
		register int i;
d161 2
a162 1
		for( i=0; i<dx; i++ )  {
d168 33
a200 2
	f = 1.0 / ( 255 * dx * dy );
	VSET( ap->a_color, r * f, g * f, b * f );
d224 1
@


3.4
log
@Conversion to uvcoord, general cleanup.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.3 86/07/19 04:40:07 mike Exp $ (BRL)";
d94 2
a95 2
register struct application *ap;
register struct partition *pp;
d97 1
a97 1
	register struct txt_specific *tp =
d100 6
a105 1
	register unsigned char *cp;
d119 48
a166 5
	/* u is left->right index, v is line number */
	cp = (unsigned char *)tp->tx_pixels +
	     ((int) (uv.uv_v*(tp->tx_l-1))) * tp->tx_w * 3 +	/* v */
	     ((int) (uv.uv_u*(tp->tx_w-1))) * 3;
	VSET( ap->a_color, *cp++/255., *cp++/255., *cp++/255.);
@


3.3
log
@Added checker texture
@
text
@d10 1
a10 1
v *	SECAD/VLD Computing Consortium, Bldg 394
d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.2 86/07/17 18:33:10 mike Exp $ (BRL)";
d45 13
d59 24
d99 1
a99 1
	auto fastf_t uv[2];
d103 1
a103 1
		pp->pt_inseg->seg_stp, pp->pt_inhit, uv );
d105 7
a111 4
	/* If File could not be opened -- give debug colors */
top:
	if( tp->tx_file[0] == '\0' )  {
		VSET( ap->a_color, uv[0]*255, 0, uv[1]*255 );
a113 28
	/* Dynamic load of file -- don't read until first pixel needed */
	if( tp->tx_pixels == (char *)0 )  {
		char *linebuf;
		register FILE *fp;
		register int i;

		if( (fp = fopen(tp->tx_file, "r")) == NULL )  {
			rt_log("txt_render(%s):  can't open\n", tp->tx_file);
			tp->tx_file[0] = '\0';
			goto top;
		}
		linebuf = rt_malloc(tp->tx_fw*3,"texture file line");
		tp->tx_pixels = rt_malloc(
			tp->tx_w * tp->tx_l * 3,
			tp->tx_file );
		for( i=0; i<tp->tx_l; i++ )  {
			if( fread(linebuf,1,tp->tx_fw*3,fp) != tp->tx_fw*3 ) {
				rt_log("text_uvget: read error on %s\n", tp->tx_file);
				tp->tx_file[0] = '\0';
				(void)fclose(fp);
				rt_free(linebuf,"file line, error");
				goto top;
			}
			bcopy( linebuf, tp->tx_pixels + i*tp->tx_w*3, tp->tx_w*3 );
		}
		(void)fclose(fp);
		rt_free(linebuf,"texture file line");
	}
d116 2
a117 2
	     ((int) (uv[1]*(tp->tx_l-1))) * tp->tx_w * 3 +	/* v */
	     ((int) (uv[0]*(tp->tx_w-1))) * 3;
d171 1
a171 1
	auto fastf_t uv[2];
d174 1
a174 1
		pp->pt_inseg->seg_stp, pp->pt_inhit, uv );
d176 2
a177 2
	if( (uv[0] < 0.5 && uv[1] < 0.5) ||
	    (uv[0] >=0.5 && uv[1] >=0.5) )  {
d205 1
a205 1
 *  Mostly useful for debugging ft_fv() routines.
d212 1
a212 1
	auto fastf_t uv[2];
d215 2
a216 2
		pp->pt_inseg->seg_stp, pp->pt_inhit, uv );
	VSET( ap->a_color, uv[0], 0, uv[1] );
@


3.2
log
@Names shortened for non-FLEXNAMES systems (cray),
and converted to using stdio for all I/O.
@
text
@d10 1
a10 1
 *	SECAD/VLD Computing Consortium, Bldg 394
d19 1
a19 1
static char RCStext[] = "@@(#)$Header: rt.c,v 3.1 86/06/17 21:13:54 mike Exp $ (BRL)";
a44 1
extern txt_render();
a45 21
int
txt_setup( rp )
register struct region *rp;
{
	register struct txt_specific *tp;

	GETSTRUCT( tp, txt_specific );
	rp->reg_ufunc = txt_render;
	rp->reg_udata = (char *)tp;

	tp->tx_file[0] = '\0';
	tp->tx_w = tp->tx_fw = tp->tx_l = -1;
	mlib_parse( rp->reg_mater.ma_matparm, txt_parse, (char *)tp );
	if( tp->tx_w < 0 )  tp->tx_w = 512;
	if( tp->tx_l < 0 )  tp->tx_l = tp->tx_w;
	if( tp->tx_fw < 0 )  tp->tx_fw = tp->tx_w;
	tp->tx_pixels = (char *)0;
	return(1);
}


d55 1
d111 79
d195 1
@


3.1
log
@New somewhat object-oriented material-property version
@
text
@d5 12
d18 4
d28 1
a28 1
struct texture_specific {
d35 1
a35 1
#define TX_NULL	((struct texture_specific *)0)
d37 1
a37 1
struct matparse texture_parse[] = {
d45 1
a45 1
extern texture_render();
d48 1
a48 1
texture_setup( rp )
d51 1
a51 1
	register struct texture_specific *tp;
d53 2
a54 2
	GETSTRUCT( tp, texture_specific );
	rp->reg_ufunc = texture_render;
d59 1
a59 1
	matlib_parse( rp->reg_mater.ma_matparm, texture_parse, (char *)tp );
a63 1
	matlib_print( "texture", texture_parse, (char *)tp );
d69 1
a69 1
 *  			T E X T U R E _ R E N D E R
d77 1
a77 1
texture_render( ap, pp )
d81 2
a82 2
	register struct texture_specific *tp =
		(struct texture_specific *)pp->pt_regionp->reg_udata;
d98 1
a98 1
		register int fd;
d101 2
a102 2
		if( (fd = open(tp->tx_file, 0)) < 0 )  {
			rt_log("texture_render(%s):  can't open\n", tp->tx_file);
d111 1
a111 1
			if( read(fd,linebuf,tp->tx_fw*3) != tp->tx_fw*3 )  {
d114 1
a114 1
				(void)close(fd);
d120 1
a120 1
		(void)close(fd);
d150 1
a150 1
 *			T E S T M A P _ S E T U P
d152 1
a152 1
testmap_setup( rp )
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d8 3
a10 1
#include "text.h"
d12 8
a19 1
extern char *rt_malloc();
d21 6
a26 6
struct texture txt = {
	"./text.pix",
	512,
	512,
	512,
	0
d28 25
d54 1
a54 1
 *  			T E X T _ U V G E T
d62 3
a64 4
unsigned char *
text_uvget( tp, uvp )
register struct texture *tp;
fastf_t *uvp;
d66 9
a74 2
tp = &txt;	/* HACK */
	/* If File could not be opened -- give rt_g.debug colors */
d76 3
a78 6
	if( tp->tx_file == (char *)0 )  {
		static char ret[3];
		ret[0] = uvp[0]*255;
		ret[1] = 0;
		ret[2] = uvp[1]*255;
		return((unsigned char *)ret);
d87 2
a88 2
			perror(tp->tx_file);
			tp->tx_file = (char *)0;
d98 1
a98 1
				tp->tx_file = (char *)0;
d109 34
a142 3
	return( (unsigned char *)tp->tx_pixels +
		((int) (uvp[1]*(tp->tx_l-1))) * tp->tx_w * 3 +	/* v */
		((int) (uvp[0]*(tp->tx_w-1))) * 3 );
@


2.2
log
@rt and librt separated
@
text
@d10 1
a10 1
extern char *vmalloc();
d34 1
a34 1
	/* If File could not be opened -- give debug colors */
d54 2
a55 2
		linebuf = vmalloc(tp->tx_fw*3,"texture file line");
		tp->tx_pixels = vmalloc(
d60 1
a60 1
				rtlog("text_uvget: read error on %s\n", tp->tx_file);
d63 1
a63 1
				vfree(linebuf,"file line, error");
d69 1
a69 1
		vfree(linebuf,"texture file line");
@


2.1
log
@Version 2 of RT
@
text
@a13 1
	64,
d15 2
a16 1
	64,
@
