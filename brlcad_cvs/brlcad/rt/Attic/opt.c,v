head	11.41;
access;
symbols
	ansi-20040405-merged:11.35.4.1
	postmerge-20040405-ansi:11.39
	premerge-20040404-ansi:11.39
	postmerge-autoconf:11.39
	autoconf-freeze:11.38.2.2
	premerge-autoconf:11.39
	postmerge-20040315-windows:11.39
	premerge-20040315-windows:11.39
	windows-20040315-freeze:11.35.6.1
	autoconf-20031203:11.38
	autoconf-20031202:11.38
	autoconf-branch:11.38.0.2
	phong-branch:11.37.0.2
	photonmap-branch:11.35.0.8
	rel-6-1-DP:11.35
	windows-branch:11.35.0.6
	rel-6-0-2:11.35
	ansi-branch:11.35.0.4
	rel-6-0-1-branch:11.35.0.2
	hartley-6-0-post:11.35
	hartley-6-0-pre:11.35
	rel-6-0-1:11.35
	rel-6-0:11.34
	rel-5-4:11.25.2.1
	offsite-5-3-pre:11.28
	rel-5-3:11.25.2.1
	rel-5-2:11.25
	rel-5-1-branch:11.25.0.2
	rel-5-1:11.25
	rel-5-0:11.19
	rel-5-0-beta:11.19
	rel-4-5:11.16
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.41
date	2004.05.21.17.31.04;	author morrison;	state dead;
branches;
next	11.40;

11.40
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.39;

11.39
date	2004.02.02.17.39.38;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches
	11.38.2.1;
next	11.37;

11.37
date	2003.08.27.19.18.28;	author justin;	state Exp;
branches
	11.37.2.1;
next	11.36;

11.36
date	2003.06.19.16.01.07;	author butler;	state Exp;
branches;
next	11.35;

11.35
date	2002.04.05.14.05.59;	author jra;	state Exp;
branches
	11.35.4.1
	11.35.6.1
	11.35.8.1;
next	11.34;

11.34
date	2002.03.14.14.08.11;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	2002.01.22.19.00.13;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	2001.11.19.19.36.31;	author butler;	state Exp;
branches;
next	11.31;

11.31
date	2001.08.11.13.18.27;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	2001.05.17.20.06.07;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2001.03.19.22.20.14;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	2000.08.17.02.41.34;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.07.27.19.32.52;	author butler;	state Exp;
branches;
next	11.26;

11.26
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.25;

11.25
date	2000.02.03.06.33.40;	author butler;	state Exp;
branches
	11.25.2.1;
next	11.24;

11.24
date	2000.01.13.19.54.18;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	99.12.30.05.49.28;	author butler;	state Exp;
branches;
next	11.22;

11.22
date	99.12.28.23.13.42;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.11.16.01.17.28;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.10.30.03.06.27;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	99.05.28.01.17.24;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	98.12.11.22.53.21;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	98.03.19.04.37.11;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.01.23.02.00.49;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	97.09.02.17.57.34;	author gdurf;	state Exp;
branches;
next	11.14;

11.14
date	97.08.22.22.39.47;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.07.21.21.54.30;	author gdurf;	state Exp;
branches;
next	11.12;

11.12
date	97.07.15.13.10.11;	author gdurf;	state Exp;
branches;
next	11.11;

11.11
date	97.07.08.15.29.11;	author gdurf;	state Exp;
branches;
next	11.10;

11.10
date	97.07.07.13.12.20;	author gdurf;	state Exp;
branches;
next	11.9;

11.9
date	97.06.13.02.53.55;	author gdurf;	state Exp;
branches;
next	11.8;

11.8
date	97.03.07.06.12.28;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.10.31.18.37.36;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	95.12.06.17.58.58;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	95.08.19.05.04.02;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	95.03.11.02.19.02;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.03.03.10.44.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.01.03.43.18;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.45;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.09.30.16.03.30;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.00.35.53;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.06.28.10.35.41;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	94.06.28.10.33.22;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	93.04.05.21.17.00;	author phil;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.50;	author mike;	state Rel4_0;
branches;
next	9.7;

9.7
date	91.06.22.00.14.23;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.02.28.15.47.16;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.01.24.15.23.01;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.04.09.00.44;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.02.04.00.07.07;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.28.02.26.02;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.04;	author mike;	state Rel3_5;
branches;
next	1.7;

1.7
date	89.04.29.05.31.27;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.04.10.21.15.36;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.04.03.20.25.51;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.03.15.12.22.31;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.02.13.23.31.29;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.01.25.05.34.23;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.01.20.03.20.40;	author mike;	state Exp;
branches;
next	;

11.25.2.1
date	2001.02.23.20.19.53;	author jra;	state Exp;
branches;
next	;

11.35.4.1
date	2004.03.17.21.22.57;	author morrison;	state Exp;
branches;
next	;

11.35.6.1
date	2004.03.11.23.48.06;	author morrison;	state Exp;
branches;
next	;

11.35.8.1
date	2003.08.07.22.19.51;	author justin;	state Exp;
branches;
next	11.35.8.2;

11.35.8.2
date	2003.08.12.03.56.07;	author justin;	state Exp;
branches;
next	11.35.8.3;

11.35.8.3
date	2003.08.12.23.07.42;	author justin;	state Exp;
branches;
next	11.35.8.4;

11.35.8.4
date	2003.08.13.22.08.09;	author justin;	state Exp;
branches;
next	11.35.8.5;

11.35.8.5
date	2003.08.24.23.29.13;	author justin;	state Exp;
branches;
next	11.35.8.6;

11.35.8.6
date	2003.08.26.13.58.31;	author justin;	state Exp;
branches;
next	;

11.37.2.1
date	2003.09.10.22.03.38;	author butler;	state Exp;
branches;
next	;

11.38.2.1
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	11.38.2.2;

11.38.2.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@Option processing for RT and REMRT
@


11.41
log
@moved to src/rt/
@
text
@/*
 *			O P T . C
 *
 *  Option handling for Ray Tracing main program.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/opt.c,v 11.40 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./ext.h"

#include "rtprivate.h"
#include "../librt/debug.h"

extern int	rdebug;			/* RT program debugging */

int		rpt_dist = 0;		/* report distance to each pixel */
int		width;			/* # of pixels in X */
int		height;			/* # of lines in Y */


/***** Variables shared with viewing model *** */
int		doubles_out = 0;	/* u_char or double .pix output file */
double		azimuth, elevation;
int		lightmodel = 0;		/* Select lighting model */
int		rpt_overlap = 1;	/* report overlapping region names */
/***** end of sharing with viewing model *****/

/***** variables shared with worker() ******/
int		query_x;
int		query_y;
int		Query_one_pixel;
int		query_rdebug;
int		query_debug;
int		stereo = 0;		/* stereo viewing */
int		hypersample=0;		/* number of extra rays to fire */
unsigned int	jitter=0;		/* ray jitter control variable */
fastf_t		rt_perspective=0;	/* presp (degrees X) 0 => ortho */
fastf_t		aspect = 1;		/* view aspect ratio X/Y */
vect_t		dx_model;		/* view delta-X as model-space vect */
vect_t		dy_model;		/* view delta-Y as model-space vect */
vect_t		dx_unit;		/* view delta-X as unit-len vect */
vect_t		dy_unit;		/* view delta-Y as unit-len vect */
fastf_t		cell_width;		/* model space grid cell width */
fastf_t		cell_height;		/* model space grid cell height */
int		cell_newsize=0;		/* new grid cell size */
point_t		eye_model;		/* model-space location of eye */
fastf_t         eye_backoff = 1.414;	/* dist from eye to center */
extern int		width;			/* # of pixels in X */
extern int		height;			/* # of lines in Y */
mat_t		Viewrotscale;
fastf_t		viewsize=0;
int		incr_mode = 0;		/* !0 for incremental resolution */
int		incr_level;		/* current incremental level */
int		incr_nlevel;		/* number of levels */
int		npsw = 1;		/* number of worker PSWs to run */
struct resource	resource[MAX_PSW];	/* memory resources */
int		transpose_grid = 0;     /* reverse the order of grid traversal */
/***** end variables shared with worker() *****/

/***** Photon Mapping Variables *****/
double		pmargs[9];
char		pmfile[255];
/***** ************************ *****/

/***** variables shared with do.c *****/
char		*string_pix_start;	/* string spec of starting pixel */
char		*string_pix_end;	/* string spec of ending pixel */
int		pix_start = -1;		/* pixel to start at */
int		pix_end;		/* pixel to end at */
int		nobjs;			/* Number of cmd-line treetops */
char		**objtab;		/* array of treetop strings */
int		matflag = 0;		/* read matrix from stdin */
int		desiredframe = 0;	/* frame to start at */
int		finalframe = -1;	/* frame to halt at */
int		curframe = 0;		/* current frame number,
					 * also shared with view.c */
char		*outputfile = (char *)0;/* name of base of output file */
int		interactive = 0;	/* human is watching results */
int		benchmark = 0;		/* No random numbers:  benchmark */

int		sub_grid_mode = 0;	/* mode to raytrace a rectangular portion of view */
int		sub_xmin = 0;		/* lower left of sub rectangle */
int		sub_ymin = 0;
int		sub_xmax = 0;		/* upper right of sub rectangle */
int		sub_ymax = 0;
/***** end variables shared with do.c *****/


/***** variables shared with view.c *****/
fastf_t		frame_delta_t = 1./30.; /* 1.0 / frames_per_second_playback */
double		airdensity;    /* is the scene hazy (we shade the void space */
double		haze[3] = { 0.8, 0.9, 0.99 };	      /* color of the haze */

/***** end variables shared with view.c *****/

/* temporary kludge to get rt to use a tighter tolerance for raytracing */
fastf_t		rt_dist_tol = 0.0005;	/* Value for rti_tol.dist */

fastf_t		rt_perp_tol = 0;	/* Value for rti_tol.perp */
char		*framebuffer;		/* desired framebuffer */

int		space_partition = 	/*space partitioning algorithm to use*/
			RT_PART_NUBSPT;
int		nugrid_dimlimit = 0;	/* limit to each dimension of
					   the nugrid */
double		nu_gfactor = RT_NU_GFACTOR_DEFAULT;
		      /* constant factor in NUgrid algorithm, if applicable */

#define MAX_WIDTH	(32*1024)

extern struct command_tab	rt_cmdtab[];

/*
 *			G E T _ A R G S
 */
int get_args( int argc, register char **argv )
{
	register int c;
	register int i;

	bu_optind = 1;		/* restart */


#define GETOPT_STR	\
	".:,:@@:a:b:c:d:e:f:g:h:ij:l:n:o:p:q:rs:tv:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:X:!:"

	while( (c=bu_getopt( argc, argv, GETOPT_STR )) != EOF )  {
		switch( c )  {
		case 'q':
			i = atoi(bu_optarg);
			if (i <= 0) {
				bu_log("-q %d is < 0\n", i);
				bu_bomb("");
			}
			if ( i > BN_RANDHALFTABSIZE) {
				bu_log("-q %d is > maximum (%d)\n",
				       i, BN_RANDHALFTABSIZE);
				bu_bomb("");
			}
			bn_randhalftabsize = i;
			break;
		case 'h':
		    i = sscanf(bu_optarg, "%lg,%lg,%lg,%lg", 
			       &airdensity, &haze[X], &haze[Y], &haze[Z]);
		    break;
		case 't':
			transpose_grid = 1;
			break;
		case 'j':
			{
				register char	*cp = bu_optarg;

				sub_xmin = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				sub_ymin = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				sub_xmax = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				sub_ymax = atoi(cp);

				bu_log("Sub-rectangle: (%d,%d) (%d,%d)\n",
					sub_xmin, sub_ymin,
					sub_xmax, sub_ymax );
				if( sub_xmin >= 0 && sub_xmin < sub_xmax &&
				    sub_ymin >= 0 && sub_ymin < sub_ymax )  {
					sub_grid_mode = 1;
				} else {
					sub_grid_mode = 0;
					bu_log("ERROR, bad sub-rectangle, ignored\n");
				}
			}
			break;
		case '.':
			nu_gfactor = (double)atof( bu_optarg );
			break;
		case ',':
			space_partition = atoi(bu_optarg);
			break;
		case '@@':
			nugrid_dimlimit = atoi(bu_optarg);
			break;
		case 'c':
			(void)rt_do_cmd( (struct rt_i *)0, bu_optarg, rt_cmdtab );
			break;
		case 'C':
			{
				char		buf[128];
				int		r,g,b;
				register char	*cp = bu_optarg;

				r = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				g = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				b = atoi(cp);

				if( r < 0 || r > 255 )  r = 255;
				if( g < 0 || g > 255 )  g = 255;
				if( b < 0 || b > 255 )  b = 255;

				sprintf(buf,"set background=%f/%f/%f",
					r/255., g/255., b/255. );
				(void)rt_do_cmd( (struct rt_i *)0, buf,
					rt_cmdtab );
			}
			break;
		case 'T':
			{
				double		f;
				char		*cp;
				f = 0;
				if( sscanf( bu_optarg, "%lf", &f ) == 1 )  {
					if( f > 0 )
						rt_dist_tol = f;
				}
				f = 0;
				if( (cp = strchr(bu_optarg, '/')) ||
				    (cp = strchr(bu_optarg, ',')) )  {
					if( sscanf( cp+1, "%lf", &f ) == 1 )  {
						if( f > 0 && f < 1 )
							rt_perp_tol = f;
					}
				}
				bu_log("Using tolerance %lg", f);
				break;
			}
		case 'U':
			use_air = atoi( bu_optarg );
			break;
		case 'I':
			interactive = 1;
			break;
		case 'i':
			incr_mode = 1;
			break;
		case 'S':
			stereo = 1;
			break;
		case 'J':
			sscanf( bu_optarg, "%x", &jitter );
			break;
		case 'H':
			hypersample = atoi( bu_optarg );
			if( hypersample > 0 )
				jitter = 1;
			break;
		case 'F':
			framebuffer = bu_optarg;
			break;
		case 'D':
			desiredframe = atoi( bu_optarg );
			break;
		case 'K':
			finalframe = atoi( bu_optarg );
			break;
		case 'N':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.NMG_debug);
			bu_log("NMG_debug=0x%x\n", rt_g.NMG_debug);
			break;
		case 'M':
			matflag = 1;
			break;
		case 'A':
			AmbientIntensity = atof( bu_optarg );
			break;
		case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( bu_optarg, "%x", (unsigned int *)&rdebug );
			break;
		case '!':
			sscanf( bu_optarg, "%x", (unsigned int *)&bu_debug );
			break;

		case 's':
			/* Square size */
			i = atoi( bu_optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"squaresize=%d out of range\n", i);
			else
				width = height = i;
			break;
		case 'n':
			i = atoi( bu_optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"height=%d out of range\n", i);
			else
				height = i;
			break;
		case 'w':
			i = atoi( bu_optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"width=%d out of range\n", i);
			else
				width = i;
			break;
		case 'g':
			cell_width = atof( bu_optarg );
			cell_newsize = 1;
			break;
		case 'G':
			cell_height = atof( bu_optarg );
			cell_newsize = 1;
			break;

		case 'a':
			/* Set azimuth */
			azimuth = atof( bu_optarg );
			matflag = 0;
			break;
		case 'e':
			/* Set elevation */
			elevation = atof( bu_optarg );
			matflag = 0;
			break;
		case 'l':
			{
				char	*item;

				/* Select lighting model # */
				lightmodel= 1;	/* Initialize with Full Lighting Model */
				item= strtok(bu_optarg,",");
				lightmodel= atoi(item);

				if (lightmodel == 7) {					/* Process the photon mapping arguments */
					item= strtok(NULL,",");
 					pmargs[0]= item ? atoi(item) : 16384;		/* Number of Global Photons */
					item= strtok(NULL,",");
					pmargs[1]= item ? atof(item) : 50;		/* Percent of Global Photons that should be used for Caustic Photons */
					item= strtok(NULL,",");
					pmargs[2]= item ? atoi(item) : 10;		/* Number of Irradiance Sample Rays, Total Rays is this number squared */
					item= strtok(NULL,",");
					pmargs[3]= item ? atof(item) : 60.0;		/* Angular Tolerance */
					item= strtok(NULL,",");
					pmargs[4]= item ? atoi(item) : 0;		/* Random Seed */
					item= strtok(NULL,",");
					pmargs[5]= item ? atoi(item) : 0;		/* Importance Mapping */
					item= strtok(NULL,",");
					pmargs[6]= item ? atoi(item) : 0;		/* Irradiance Hypersampling */
					item= strtok(NULL,",");
					pmargs[7]= item ? atoi(item) : 0;		/* Visualize Irradiance */
					item= strtok(NULL,",");
					pmargs[8]= item ? atof(item) : 1.0;		/* Scale Lumens */
					item= strtok(NULL,",");
					if (item) { strcpy(pmfile,item); } else { pmfile[0]= 0; }
/*					item ? strcpy(pmfile,item) : pmfile[0]= 0;*/	/* Scale Lumens */
				}
			}
			break;
		case 'O':
			/* Output pixel file name, double precision format */
			outputfile = bu_optarg;
			doubles_out = 1;
			break;
		case 'o':
			/* Output pixel file name, unsigned char format */
			outputfile = bu_optarg;
			doubles_out = 0;
			break;
		case 'p':
			rt_perspective = atof( bu_optarg );
			if( rt_perspective < 0 || rt_perspective > 179 ) {
				fprintf(stderr,"persp=%g out of range\n", rt_perspective);
				rt_perspective = 0;
			}
			break;
		case 'v': /* Set level of "non-debug" debugging output */
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_verbosity );
			bu_printb( "Verbosity:", rt_verbosity,
				VERBOSE_FORMAT);
			bu_log("\n");
			break;
		case 'E':
			eye_backoff = atof( bu_optarg );
			break;

		case 'P':
			/* Number of parallel workers */
			{
				int avail_cpus;

				avail_cpus = bu_avail_cpus();

				npsw = atoi( bu_optarg );

				if( npsw > avail_cpus ) {
					fprintf( stderr, "Requesting %d cpus, only %d available. ",
						 npsw, avail_cpus );
					fprintf( stderr, "Will use %d.\n", avail_cpus );
					npsw = avail_cpus;
				}
				if( npsw == 0 || npsw < -MAX_PSW || npsw > MAX_PSW )  {
					fprintf(stderr,"abs(npsw) out of range 1..%d, using -P%d\n",
						MAX_PSW, MAX_PSW);
					npsw = MAX_PSW;
				}
			}
			break;
		case 'Q':
			Query_one_pixel = ! Query_one_pixel;
			sscanf(bu_optarg, "%d,%d\n", &query_x, &query_y);
			break;
		case 'B':
			/*  Remove all intentional random effects
			 *  (dither, etc) for benchmarking purposes.
			 */
			benchmark = 1;
			bn_mathtab_constant();
			break;
		case 'b':
			/* Specify a single pixel to be done */
			/* Actually processed in do_frame() */
			string_pix_start = bu_optarg;
			npsw = 1;	/* Cancel running in parallel */
			break;
		case 'f':
			/* set expected playback rate in frames-per-second.
			 * This actually gets stored as the delta-t per frame.
			 */
			if ( (frame_delta_t=atof( bu_optarg )) == 0.0) {
				fprintf(stderr, "Invalid frames/sec (%s) == 0.0\n",
					bu_optarg);
				frame_delta_t = 30.0;
			}
			frame_delta_t = 1.0 / frame_delta_t;
			break;
#if 0
		case ?:
			/* XXX what letter to use? */
			/* Specify the pixel to end at */
			/* Actually processed in do_frame() */
			string_pix_end = bu_optarg;
			break;
#endif
		case 'V':
			/* View aspect */
			{
				fastf_t xx, yy;
				register char *cp = bu_optarg;

				xx = atof(cp);
				while( (*cp >= '0' && *cp <= '9')
					|| *cp == '.' )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				yy = atof(cp);
				if( yy == 0 )
					aspect = xx;
				else
					aspect = xx/yy;
				if( aspect == 0 ) {
					fprintf(stderr,"Bogus aspect %g, using 1.0\n", aspect);
					aspect = 1;
				}
			}
			break;
		case 'r':
			/* report overlapping region names */
			rpt_overlap = 1;
			break;
		case 'R':
			/* DON'T report overlapping region names */
			rpt_overlap = 0;
			break;
		case 'd':
			rpt_dist = atoi( bu_optarg );
			break;
		default:		/* '?' */
			fprintf(stderr,"unknown option %c\n", c);
			return(0);	/* BAD */
		}
	}

	/* Compat */
	if( RT_G_DEBUG || R_DEBUG || rt_g.NMG_debug )
		bu_debug |= BU_DEBUG_COREDUMP;

	if( RT_G_DEBUG & DEBUG_MEM_FULL )  bu_debug |= BU_DEBUG_MEM_CHECK;
	if( RT_G_DEBUG & DEBUG_MEM )  bu_debug |= BU_DEBUG_MEM_LOG;
	if( RT_G_DEBUG & DEBUG_PARALLEL )  bu_debug |= BU_DEBUG_PARALLEL;
	if( RT_G_DEBUG & DEBUG_MATH )  bu_debug |= BU_DEBUG_MATH;

	if( R_DEBUG & RDEBUG_RTMEM_END )  bu_debug |= BU_DEBUG_MEM_CHECK;

	return(1);			/* OK */
}
@


11.40
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/opt.c,v 11.39 2004/02/02 17:39:38 morrison Exp $ (BRL)";
@


11.39
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.38 2003/09/27 01:11:25 morrison Exp $ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.38
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1989 by the United States Army.
d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.37 2003/08/27 19:18:28 justin Exp $ (BRL)";
@


11.38.2.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.39 2004/02/02 17:39:38 morrison Exp $ (BRL)";
@


11.38.2.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.38.2.1 2004/02/12 19:37:13 erikg Exp $ (BRL)";
@


11.37
log
@Updated for use with photon mapping (pmargs) and the lighting argument
is now more intelligent (-l).
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.35.8.6 2003/08/26 13:58:31 justin Exp $ (BRL)";
d43 6
a48 1
extern int	rdebug;			/* RT program debugging (not library) */
a51 1
double		AmbientIntensity = 0.4;	/* Ambient light intensity */
a54 1
int		rpt_dist = 0;		/* report distance to each pixel */
d77 2
a78 2
int		width;			/* # of pixels in X */
int		height;			/* # of lines in Y */
d509 1
a509 1
	if( RT_G_DEBUG || rdebug || rt_g.NMG_debug )
d517 1
a517 1
	if( rdebug & RDEBUG_RTMEM_END )  bu_debug |= BU_DEBUG_MEM_CHECK;
@


11.37.2.1
log
@Added photon mapping args for sphere invalidation
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.37 2003/08/27 19:18:28 justin Exp $ (BRL)";
d87 1
a87 1
double		pmargs[14];
a376 10
					pmargs[9]= item ? atof(item) : 0.0;		/* Sphere Invalidation X Coordinate */
					item= strtok(NULL,",");
					pmargs[10]= item ? atof(item) : 0.0;		/* Sphere Invalidation Y Coordinate */
					item= strtok(NULL,",");
					pmargs[11]= item ? atof(item) : 0.0;		/* Sphere Invalidation Z Coordinate */
					item= strtok(NULL,",");
					pmargs[12]= item ? atof(item) : 0.0;		/* Sphere Invalidation Radius */
					item= strtok(NULL,",");
					pmargs[13]= item ? atof(item) : 0.0;		/* Sphere Invalidation Emit Radius */
					item= strtok(NULL,",");
d378 1
@


11.36
log
@Added support for haze shading of void before eye point
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.35 2002/04/05 14:05:59 jra Exp $ (BRL)";
d86 5
d349 32
a380 2
			/* Select lighting model # */
			lightmodel = atoi( bu_optarg );
@


11.35
log
@Bob Parker's "transpose grid" option (reverses order of rays)
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.34 2002/03/14 14:08:11 jra Exp $ (BRL)";
d112 3
d146 1
a146 1
	".:,:@@:a:b:c:d:e:f:g:ij:l:n:o:p:q:rs:tv:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:X:!:"
d163 4
@


11.35.4.1
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d43 1
a43 6
extern int	rdebug;			/* RT program debugging */

int		rpt_dist = 0;		/* report distance to each pixel */
int		width;			/* # of pixels in X */
int		height;			/* # of lines in Y */

d47 1
d51 1
d74 2
a75 2
extern int		width;			/* # of pixels in X */
extern int		height;			/* # of lines in Y */
a85 5
/***** Photon Mapping Variables *****/
double		pmargs[9];
char		pmfile[255];
/***** ************************ *****/

a111 3
double		airdensity;    /* is the scene hazy (we shade the void space */
double		haze[3] = { 0.8, 0.9, 0.99 };	      /* color of the haze */

d143 1
a143 1
	".:,:@@:a:b:c:d:e:f:g:h:ij:l:n:o:p:q:rs:tv:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:X:!:"
a159 4
		case 'h':
		    i = sscanf(bu_optarg, "%lg,%lg,%lg,%lg", 
			       &airdensity, &haze[X], &haze[Y], &haze[Z]);
		    break;
d337 2
a338 32
			{
				char	*item;

				/* Select lighting model # */
				lightmodel= 1;	/* Initialize with Full Lighting Model */
				item= strtok(bu_optarg,",");
				lightmodel= atoi(item);

				if (lightmodel == 7) {					/* Process the photon mapping arguments */
					item= strtok(NULL,",");
 					pmargs[0]= item ? atoi(item) : 16384;		/* Number of Global Photons */
					item= strtok(NULL,",");
					pmargs[1]= item ? atof(item) : 50;		/* Percent of Global Photons that should be used for Caustic Photons */
					item= strtok(NULL,",");
					pmargs[2]= item ? atoi(item) : 10;		/* Number of Irradiance Sample Rays, Total Rays is this number squared */
					item= strtok(NULL,",");
					pmargs[3]= item ? atof(item) : 60.0;		/* Angular Tolerance */
					item= strtok(NULL,",");
					pmargs[4]= item ? atoi(item) : 0;		/* Random Seed */
					item= strtok(NULL,",");
					pmargs[5]= item ? atoi(item) : 0;		/* Importance Mapping */
					item= strtok(NULL,",");
					pmargs[6]= item ? atoi(item) : 0;		/* Irradiance Hypersampling */
					item= strtok(NULL,",");
					pmargs[7]= item ? atoi(item) : 0;		/* Visualize Irradiance */
					item= strtok(NULL,",");
					pmargs[8]= item ? atof(item) : 1.0;		/* Scale Lumens */
					item= strtok(NULL,",");
					if (item) { strcpy(pmfile,item); } else { pmfile[0]= 0; }
/*					item ? strcpy(pmfile,item) : pmfile[0]= 0;*/	/* Scale Lumens */
				}
			}
d464 1
a464 1
	if( RT_G_DEBUG || R_DEBUG || rt_g.NMG_debug )
d472 1
a472 1
	if( R_DEBUG & RDEBUG_RTMEM_END )  bu_debug |= BU_DEBUG_MEM_CHECK;
@


11.35.6.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/opt.c,v 11.39 2004/02/02 17:39:38 morrison Exp $ (BRL)";
d43 1
a43 6
extern int	rdebug;			/* RT program debugging */

int		rpt_dist = 0;		/* report distance to each pixel */
int		width;			/* # of pixels in X */
int		height;			/* # of lines in Y */

d47 1
d51 1
d74 2
a75 2
extern int		width;			/* # of pixels in X */
extern int		height;			/* # of lines in Y */
a85 5
/***** Photon Mapping Variables *****/
double		pmargs[9];
char		pmfile[255];
/***** ************************ *****/

a111 3
double		airdensity;    /* is the scene hazy (we shade the void space */
double		haze[3] = { 0.8, 0.9, 0.99 };	      /* color of the haze */

d143 1
a143 1
	".:,:@@:a:b:c:d:e:f:g:h:ij:l:n:o:p:q:rs:tv:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:X:!:"
a159 4
		case 'h':
		    i = sscanf(bu_optarg, "%lg,%lg,%lg,%lg", 
			       &airdensity, &haze[X], &haze[Y], &haze[Z]);
		    break;
d337 2
a338 32
			{
				char	*item;

				/* Select lighting model # */
				lightmodel= 1;	/* Initialize with Full Lighting Model */
				item= strtok(bu_optarg,",");
				lightmodel= atoi(item);

				if (lightmodel == 7) {					/* Process the photon mapping arguments */
					item= strtok(NULL,",");
 					pmargs[0]= item ? atoi(item) : 16384;		/* Number of Global Photons */
					item= strtok(NULL,",");
					pmargs[1]= item ? atof(item) : 50;		/* Percent of Global Photons that should be used for Caustic Photons */
					item= strtok(NULL,",");
					pmargs[2]= item ? atoi(item) : 10;		/* Number of Irradiance Sample Rays, Total Rays is this number squared */
					item= strtok(NULL,",");
					pmargs[3]= item ? atof(item) : 60.0;		/* Angular Tolerance */
					item= strtok(NULL,",");
					pmargs[4]= item ? atoi(item) : 0;		/* Random Seed */
					item= strtok(NULL,",");
					pmargs[5]= item ? atoi(item) : 0;		/* Importance Mapping */
					item= strtok(NULL,",");
					pmargs[6]= item ? atoi(item) : 0;		/* Irradiance Hypersampling */
					item= strtok(NULL,",");
					pmargs[7]= item ? atoi(item) : 0;		/* Visualize Irradiance */
					item= strtok(NULL,",");
					pmargs[8]= item ? atof(item) : 1.0;		/* Scale Lumens */
					item= strtok(NULL,",");
					if (item) { strcpy(pmfile,item); } else { pmfile[0]= 0; }
/*					item ? strcpy(pmfile,item) : pmfile[0]= 0;*/	/* Scale Lumens */
				}
			}
d464 1
a464 1
	if( RT_G_DEBUG || R_DEBUG || rt_g.NMG_debug )
d472 1
a472 1
	if( R_DEBUG & RDEBUG_RTMEM_END )  bu_debug |= BU_DEBUG_MEM_CHECK;
@


11.35.8.1
log
@updated opt.c for more intelligent lighting arguments
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.35 2002/04/05 14:05:59 jra Exp $ (BRL)";
a85 4
/***** Photon Mapping Variables *****/
double		pmargs[6];
/***** ************************ *****/

d337 2
a338 23
			{
				char	*item;

				/* Select lighting model # */
				lightmodel= 1;	/* Initialize with Full Lighting Model */
				item= strtok(bu_optarg,",");
				lightmodel= atoi(item);

				if (lightmodel == 7) {				/* Process the photon mapping arguments */
					item= strtok(NULL,",");
 					pmargs[0]= item ? atoi(item) : 16384;	/* Number of Global Photons */
					item= strtok(NULL,",");
					pmargs[1]= item ? atof(item) : 50;	/* Percent of Global Photons that should be used for Caustic Photons */
					item= strtok(NULL,",");
					pmargs[2]= item ? atoi(item) : 10;	/* Number of Irradiance Sample Rays, Total Rays is this number squared */
					item= strtok(NULL,",");
					pmargs[3]= item ? atof(item) : 60.0;	/* Angular Tolerance */
					item= strtok(NULL,",");
					pmargs[4]= item ? atoi(item) : 0;	/* Random Seed */
					item= strtok(NULL,",");
					pmargs[5]= item ? atoi(item) : 0;	/* Irradiance Hypersampling */
				}
			}
@


11.35.8.2
log
@Light Intensity
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.35.8.1 2003/08/07 22:19:51 justin Exp $ (BRL)";
d87 1
a87 1
double		pmargs[7];
a361 2
					item= strtok(NULL,",");
					pmargs[6]= item ? atof(item) : 5.0;	/* Light Intensity */
@


11.35.8.3
log
@Visualization of Irradiance
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.35.8.2 2003/08/12 03:56:07 justin Exp $ (BRL)";
d87 1
a87 1
double		pmargs[8];
d363 1
a363 3
					pmargs[6]= item ? atoi(item) : 0;	/* Visualize Irradiance */
					item= strtok(NULL,",");
					pmargs[7]= item ? atof(item) : 1.0;	/* Light Intensity */
@


11.35.8.4
log
@more updates
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.35.8.3 2003/08/12 23:07:42 justin Exp $ (BRL)";
d87 1
a87 1
double		pmargs[9];
d361 1
a361 1
					pmargs[5]= item ? atoi(item) : 0;	/* Importance Mapping */
d363 1
a363 1
					pmargs[6]= item ? atoi(item) : 0;	/* Irradiance Hypersampling */
d365 1
a365 3
					pmargs[7]= item ? atoi(item) : 0;	/* Visualize Irradiance */
					item= strtok(NULL,",");
					pmargs[8]= item ? atof(item) : 1.0;	/* Light Intensity */
@


11.35.8.5
log
@updated
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.35.8.4 2003/08/13 22:08:09 justin Exp $ (BRL)";
a87 1
char		pmfile[255];
d349 1
a349 1
				if (lightmodel == 7) {					/* Process the photon mapping arguments */
d351 1
a351 1
 					pmargs[0]= item ? atoi(item) : 16384;		/* Number of Global Photons */
d353 1
a353 1
					pmargs[1]= item ? atof(item) : 50;		/* Percent of Global Photons that should be used for Caustic Photons */
d355 1
a355 1
					pmargs[2]= item ? atoi(item) : 10;		/* Number of Irradiance Sample Rays, Total Rays is this number squared */
d357 1
a357 1
					pmargs[3]= item ? atof(item) : 60.0;		/* Angular Tolerance */
d359 1
a359 1
					pmargs[4]= item ? atoi(item) : 0;		/* Random Seed */
d361 1
a361 1
					pmargs[5]= item ? atoi(item) : 0;		/* Importance Mapping */
d363 1
a363 1
					pmargs[6]= item ? atoi(item) : 0;		/* Irradiance Hypersampling */
d365 1
a365 1
					pmargs[7]= item ? atoi(item) : 0;		/* Visualize Irradiance */
d367 1
a367 4
					pmargs[8]= item ? atof(item) : 1.0;		/* Scale Lumens */
					item= strtok(NULL,",");
					if (item) { strcpy(pmfile,item); } else { pmfile[0]= 0; }
/*					item ? strcpy(pmfile,item) : pmfile[0]= 0;*/	/* Scale Lumens */
@


11.35.8.6
log
@updated for merging
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.35.8.5 2003/08/24 23:29:13 justin Exp $ (BRL)";
a116 3
double		airdensity;    /* is the scene hazy (we shade the void space */
double		haze[3] = { 0.8, 0.9, 0.99 };	      /* color of the haze */

d148 1
a148 1
	".:,:@@:a:b:c:d:e:f:g:h:ij:l:n:o:p:q:rs:tv:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:X:!:"
a164 4
		case 'h':
		    i = sscanf(bu_optarg, "%lg,%lg,%lg,%lg", 
			       &airdensity, &haze[X], &haze[Y], &haze[Z]);
		    break;
@


11.34
log
@getargs() will now limit number of procs to bu_avail_cpus()
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.33 2002/01/22 19:00:13 jra Exp $ (BRL)";
d83 1
d143 1
a143 1
	".:,:@@:a:b:c:d:e:f:g:ij:l:n:o:p:q:rs:v:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:X:!:"
d159 3
@


11.33
log
@rt now honors the -R option
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.32 2001/11/19 19:36:31 butler Exp $ (BRL)";
d365 18
a382 5
			npsw = atoi( bu_optarg );
			if( npsw == 0 || npsw < -MAX_PSW || npsw > MAX_PSW )  {
				fprintf(stderr,"abs(npsw) out of range 1..%d, using -P%d\n",
					MAX_PSW, MAX_PSW);
				npsw = MAX_PSW;
@


11.32
log
@rt and friends will now print the tolerance when it gets set
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.31 2001/08/11 13:18:27 butler Exp $ (BRL)";
d50 1
a50 1
int		rpt_overlap = 0;	/* report overlapping region names */
@


11.31
log
@misc compiler warning changes
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.30 2001/05/17 20:06:07 morrison Exp $ (BRL)";
d239 2
@


11.30
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.29 2001/03/19 22:20:14 butler Exp $ (BRL)";
d62 1
a62 1
int		jitter=0;		/* jitter ray starting positions */
d270 1
a270 1
			sscanf( bu_optarg, "%x", &rt_g.NMG_debug);
d280 1
a280 1
			sscanf( bu_optarg, "%x", &rt_g.debug );
d283 1
a283 1
			sscanf( bu_optarg, "%x", &rdebug );
d286 1
a286 1
			sscanf( bu_optarg, "%x", &bu_debug );
d352 1
a352 1
			sscanf( bu_optarg, "%x", &rt_verbosity );
@


11.29
log
@patches to merge 5.3 into 6.0
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /d/CVS/brlcad/rt/opt.c,v 11.28 2000/08/17 02:41:34 mike Exp $ (BRL)";
d445 1
a445 1
	if( rt_g.debug || rdebug || rt_g.NMG_debug )
d448 4
a451 4
	if( rt_g.debug & DEBUG_MEM_FULL )  bu_debug |= BU_DEBUG_MEM_CHECK;
	if( rt_g.debug & DEBUG_MEM )  bu_debug |= BU_DEBUG_MEM_LOG;
	if( rt_g.debug & DEBUG_PARALLEL )  bu_debug |= BU_DEBUG_PARALLEL;
	if( rt_g.debug & DEBUG_MATH )  bu_debug |= BU_DEBUG_MATH;
@


11.28
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.27 2000/07/27 19:32:52 butler Exp $ (BRL)";
d113 2
a115 1
fastf_t		rt_dist_tol = 0;	/* Value for rti_tol.dist */
@


11.27
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.26 2000/07/25 16:39:48 butler Exp $ (BRL)";
@


11.26
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.25 2000/02/03 06:33:40 butler Exp $ (BRL)";
d55 5
d139 1
d141 1
a141 1
	".:,:@@:a:b:c:d:e:f:g:ij:l:n:o:p:q:rs:v:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:!:"
d368 4
@


11.25
log
@changes to support the new light visibility computations
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.24 2000/01/13 19:54:18 butler Exp $ (BRL)";
d40 1
a40 1
#include "./rdebug.h"
d127 1
a127 2
get_args( argc, argv )
register char **argv;
@


11.25.2.1
log
@Default raytracing tolerance for rt family of codes is now 0.0005
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.25 2000/02/03 06:33:40 butler Exp $ (BRL)";
a107 2
/* temporary kludge to get rt to use a tighter tolerance for raytracing */
fastf_t		rt_dist_tol = 0.0005;	/* Value for rti_tol.dist */
d109 1
@


11.24
log
@Added printing for verbosity flags
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.23 1999/12/30 05:49:28 butler Exp $ (BRL)";
d136 1
a136 1
	".:,:@@:a:b:c:d:e:f:g:ij:l:n:o:p:v:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:!:"
d140 13
@


11.23
log
@additions for -v flag to rt
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.22 1999/12/28 23:13:42 mike Exp $ (BRL)";
d334 3
@


11.22
log
@
If -b is specified, don't use multiple cpus.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.21 1999/11/16 01:17:28 mike Exp $ (BRL)";
d136 1
a136 1
	".:,:@@:a:b:c:d:e:f:g:ij:l:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:!:"
d331 3
@


11.21
log
@
Added storage for dx_unit
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.20 1999/10/30 03:06:27 butler Exp $ (BRL)";
d356 1
@


11.20
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.19 1999/05/28 01:17:24 mike Exp $ (BRL)";
d62 2
@


11.19
log
@
sed4
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.18 1998/12/11 22:53:21 mike Exp $ (BRL)";
d348 1
a348 1
			mathtab_constant();
@


11.18
log
@Converted from rt_tabdata to bn_tabdata.

Added -!0100 flag to opt.c to allow setting of libbu debug bits from
command line.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/opt.c,v 11.17 1998/03/19 04:37:11 mike Exp $ (BRL)";
d250 1
a250 1
			rt_log("NMG_debug=0x%x\n", rt_g.NMG_debug);
@


11.17
log
@Bad printf spec
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.16 1998/01/23 02:00:49 mike Exp mike $ (BRL)";
d134 1
a134 1
	".:,:@@:a:b:c:d:e:f:g:ij:l:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:"
d263 3
@


11.16
log
@With help from JRA, added -j option
(just these scanlines).
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.15 1997/09/02 17:57:34 gdurf Exp jra $ (BRL)";
d387 1
a387 1
					fprintf(stderr,"Bogus aspect %d, using 1.0\n", aspect);
@


11.15
log
@Added support for -@@ option (rt_nugrid_dimlimit)
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.14 1997/08/22 22:39:47 mike Exp gdurf $ (BRL)";
d93 6
d134 1
a134 1
	".:,:@@:a:b:c:d:e:f:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:"
d138 27
@


11.14
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.13 1997/07/21 21:54:30 gdurf Exp mike $ (BRL)";
d107 2
d128 1
a128 1
	".:,:a:b:c:d:e:f:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:"
d137 3
@


11.13
log
@Set default to NUBSPT
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.12 1997/07/15 13:10:11 gdurf Exp gdurf $ (BRL)";
d123 1
a123 1
	optind = 1;		/* restart */
d128 1
a128 1
	while( (c=getopt( argc, argv, GETOPT_STR )) != EOF )  {
d131 1
a131 1
			nu_gfactor = (double)atof( optarg );
d134 1
a134 1
			space_partition = atoi(optarg);
d137 1
a137 1
			(void)rt_do_cmd( (struct rt_i *)0, optarg, rt_cmdtab );
d143 1
a143 1
				register char	*cp = optarg;
d168 1
a168 1
				if( sscanf( optarg, "%lf", &f ) == 1 )  {
d173 2
a174 2
				if( (cp = strchr(optarg, '/')) ||
				    (cp = strchr(optarg, ',')) )  {
d182 1
a182 1
			use_air = atoi( optarg );
d194 1
a194 1
			sscanf( optarg, "%x", &jitter );
d197 1
a197 1
			hypersample = atoi( optarg );
d202 1
a202 1
			framebuffer = optarg;
d205 1
a205 1
			desiredframe = atoi( optarg );
d208 1
a208 1
			finalframe = atoi( optarg );
d211 1
a211 1
			sscanf( optarg, "%x", &rt_g.NMG_debug);
d218 1
a218 1
			AmbientIntensity = atof( optarg );
d221 1
a221 1
			sscanf( optarg, "%x", &rt_g.debug );
d224 1
a224 1
			sscanf( optarg, "%x", &rdebug );
d229 1
a229 1
			i = atoi( optarg );
d236 1
a236 1
			i = atoi( optarg );
d243 1
a243 1
			i = atoi( optarg );
d250 1
a250 1
			cell_width = atof( optarg );
d254 1
a254 1
			cell_height = atof( optarg );
d260 1
a260 1
			azimuth = atof( optarg );
d265 1
a265 1
			elevation = atof( optarg );
d270 1
a270 1
			lightmodel = atoi( optarg );
d274 1
a274 1
			outputfile = optarg;
d279 1
a279 1
			outputfile = optarg;
d283 1
a283 1
			rt_perspective = atof( optarg );
d290 1
a290 1
			eye_backoff = atof( optarg );
d295 1
a295 1
			npsw = atoi( optarg );
d312 1
a312 1
			string_pix_start = optarg;
d318 1
a318 1
			if ( (frame_delta_t=atof( optarg )) == 0.0) {
d320 1
a320 1
					optarg);
d330 1
a330 1
			string_pix_end = optarg;
d337 1
a337 1
				register char *cp = optarg;
d363 1
a363 1
			rpt_dist = atoi( optarg );
@


11.12
log
@gfactor now defaults to RT_NU_GFACTOR_DEFAULT
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.11 1997/07/08 15:29:11 gdurf Exp gdurf $ (BRL)";
d106 1
a106 1
			RT_PART_NUGRID;
@


11.11
log
@Added "nu_gfactor" variable to control constant when computing number
of cuts to make for the NUgrid algorithm
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.10 1997/07/07 13:12:20 gdurf Exp gdurf $ (BRL)";
d107 2
a108 2
double		nu_gfactor = 1.3;	/* constant factor in NUgrid algorithm,
					   if applicable */
@


11.10
log
@Default space partitioning method is NUBSPT.  (faster?)
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.9 1997/06/13 02:53:55 gdurf Exp gdurf $ (BRL)";
d105 4
a108 2
int		space_partition = 1;	/* space partitioning algorithm
					   to use. */
d126 1
a126 1
	",:a:b:c:d:e:f:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:"
d130 3
@


11.9
log
@Added the outrageously-poorly-named option -, for selecting space partitioning
method
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.8 1997/03/07 06:12:28 mike Exp gdurf $ (BRL)";
d105 1
a105 1
int		space_partition = 0;	/* space partitioning algorithm
@


11.8
log
@Moved bu_debug compat settings from main.c to opt.c.
Moved rt_init_resource() call from main.c to worker.c
Both to support remrt/rtsync.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.7 1996/10/31 18:37:36 pjt Exp mike $ (BRL)";
d105 3
d124 1
a124 1
	"a:b:c:d:e:f:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:"
d128 3
@


11.7
log
@Added the -d option
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.6 1995/12/06 17:58:58 pjt Exp $ (BRL)";
d359 12
@


11.6
log
@Implemented -R option, don't report overlaps
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.5 1995/08/19 05:04:02 butler Exp $ (BRL)";
d51 1
d121 1
a121 1
	"a:b:c:e:f:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:RST:U:V:X:"
d350 3
@


11.5
log
@added frame_delta option parsing
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.4 1995/03/11 02:19:02 mike Exp butler $ (BRL)";
d120 1
a120 1
	"a:b:c:e:f:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:ST:U:V:X:"
d345 4
@


11.4
log
@Small bug in -T setting of angular tolerance.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.3 95/03/03 10:44:36 mike Exp Locker: mike $ (BRL)";
d87 2
a88 1
int		curframe = 0;		/* current frame number */
d94 6
d120 1
a120 1
	"a:b:c:e:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:ST:U:V:X:"
d301 11
@


11.3
log
@Fixed bug in -T
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.2 95/03/01 03:43:18 mike Exp Locker: mike $ (BRL)";
d156 1
a156 1
					if( sscanf( optarg, "%lf", &f ) == 1 )  {
@


11.2
log
@Implemented -T to allow setting calculation tolerance.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 11.1 95/01/04 10:00:45 mike Rel4_4 Locker: mike $ (BRL)";
d146 1
a146 1
				fastf_t		f;
d148 2
a149 1
				if( sscanf( optarg, "%f", &f ) == 1 )  {
d153 1
d156 1
a156 1
					if( sscanf( optarg, "%f", &f ) == 1 )  {
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 10.6 94/09/30 16:03:30 mike Exp $ (BRL)";
d27 6
d93 2
d113 1
a113 1
	"a:b:c:e:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:SU:V:X:"
d144 16
@


10.6
log
@Lee added printing of NMG_debug value set by -N
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 10.5 94/08/11 00:35:53 gdurf Exp Locker: butler $ (BRL)";
@


10.5
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 10.4 1994/06/28 10:35:41 butler Exp gdurf $ (BRL)";
d167 1
@


10.4
log
@Forgot to add "N:" to getopt string last time
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 10.3 94/06/28 10:33:22 butler Exp Locker: butler $ (BRL)";
d21 2
@


10.3
log
@Added command line parsing for setting rt_g.NMG_debug
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 10.2 93/04/05 21:17:00 phil Exp Locker: butler $ (BRL)";
d103 1
a103 1
	"a:b:c:e:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MO:P:SU:V:X:"
@


10.2
log
@Added cell_newsize to indicate to worker when a new cell_width or
cell_height has been specified.  In an animation script, view
parameters can change on every frame so they need to be recomputed.
We can't count on initial zero values to tell us which parameter
(e.g. width or cell_width) was set.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 10.1 1991/10/12 06:41:50 mike Rel4_0 phil $ (BRL)";
d162 3
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 9.7 91/06/22 00:14:23 mike Exp $ (BRL)";
d55 1
d200 1
d204 1
@


9.7
log
@Updated supported options
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 9.6 91/02/28 15:47:16 mike Exp $ (BRL)";
@


9.6
log
@Defer handling of -b (only pixel) command until do_frame(),
so that image width is known.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 9.5 91/01/24 15:23:01 mike Exp $ (BRL)";
d26 1
a34 4
extern int	getopt();
extern char	*optarg;
extern int	optind;

d38 1
a38 1
int		hex_out = 0;		/* Binary or Hex .pix output file */
d102 1
a102 1
	"a:b:c:e:f:g:il:n:o:p:rs:w:x:A:BC:D:E:F:G:H:IJ:K:MO:P:SU:V:X:"
a174 2
		case 'f':
			/* "Fast" - arg's worth of pixels - historical */
d219 1
a219 1
			/* Output pixel file name, Hex format */
d221 1
a221 1
			hex_out = 1;
d224 1
a224 1
			/* Output pixel file name, binary format */
d226 1
a226 1
			hex_out = 0;
@


9.5
log
@Allowed negative args on -P
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 9.5 91/01/24 15:13:05 mike Exp $ (BRL)";
d72 2
d91 1
d105 1
a105 1
	"E:SJ:H:F:D:K:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iIU:V:g:G:r"
d109 27
d255 1
a255 1
			 *  (dither, etc) for benchmarking.
d262 2
a263 14
			{
				int xx, yy;
				register char *cp = optarg;

				xx = atoi(cp);
				while( *cp >= '0' && *cp <= '9' )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				yy = atoi(cp);
				fprintf(stderr,"only pixel %d %d\n", xx, yy);
				if( xx * yy >= 0 )  {
					pix_start = yy * width + xx;
					pix_end = pix_start;
				}
			}
d265 8
@


9.4
log
@Added -K flag to indicate what frame in an animation to "kill" ourselves
at.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/opt.c,v 9.3 90/02/04 00:07:07 mike Exp $ (BRL)";
d217 4
a220 3
			if( npsw < 1 || npsw > MAX_PSW )  {
				fprintf(stderr,"npsw out of range 1..%d\n", MAX_PSW);
				npsw = 1;
@


9.3
log
@Eliminated stray references to scanbuf.
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 9.2 89/10/28 02:26:02 mike Locked $ (BRL)";
d78 1
d102 1
a102 1
	"E:SJ:H:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iIU:V:g:G:r"
d131 3
@


9.2
log
@Added Dan Dender -r option for rtcheck summary
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 9.1 89/05/19 05:59:04 phil Locked $ (BRL)";
a63 1
char		*scanbuf;		/* For optional output buffering */
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 1.7 89/04/29 05:31:27 mike Exp $ (BRL)";
d45 1
d102 1
a102 1
	"E:SJ:H:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iIU:V:g:G:"
d263 4
@


1.7
log
@Don't need mathtab.h
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 1.6 89/04/10 21:15:36 mike Locked $ (BRL)";
@


1.6
log
@changed to ext.h
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 1.5 89/04/03 20:25:51 mike Locked $ (BRL)";
a28 1
#include "./mathtab.h"
@


1.5
log
@Added cell_width and cell_height options (-g and -G)
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 1.4 89/03/15 12:22:31 mike Locked $ (BRL)";
d30 2
a45 1
extern int	use_air;		/* Handling of air in librt */
@


1.4
log
@Store state of benchmark (-B) flag in a variable, for
use by REMRT
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 1.3 89/02/13 23:31:29 mike Locked $ (BRL)";
d55 2
d100 4
a103 1
	while( (c=getopt( argc, argv, "E:SJ:H:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iIU:V:" )) != EOF )  {
d167 6
@


1.3
log
@npsw=1, re-determined in rt.c
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 1.2 89/01/25 05:34:23 mike Locked $ (BRL)";
d79 1
d211 1
@


1.2
log
@Made serially re-entrant
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: opt.c,v 1.1 89/01/20 03:20:40 mike Locked $ (BRL)";
d65 1
a65 1
int		npsw = DEFAULT_PSW;	/* number of worker PSWs to run */
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.5 89/01/09 05:11:41 mike Locked $ (BRL)";
d94 2
@
