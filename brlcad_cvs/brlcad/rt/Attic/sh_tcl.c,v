head	1.13;
access;
symbols
	ansi-20040405-merged:1.9.2.2
	postmerge-20040405-ansi:1.11
	premerge-20040404-ansi:1.10
	postmerge-autoconf:1.10
	autoconf-freeze:1.9.10.2
	premerge-autoconf:1.10
	postmerge-20040315-windows:1.10
	premerge-20040315-windows:1.10
	windows-20040315-freeze:1.9.4.1
	autoconf-20031203:1.9
	autoconf-20031202:1.9
	autoconf-branch:1.9.0.10
	phong-branch:1.9.0.8
	photonmap-branch:1.9.0.6
	rel-6-1-DP:1.9
	windows-branch:1.9.0.4
	rel-6-0-2:1.7
	ansi-branch:1.9.0.2
	rel-6-0-1-branch:1.7.0.2
	hartley-6-0-post:1.8
	hartley-6-0-pre:1.7
	rel-6-0-1:1.7
	rel-6-0:1.7
	rel-5-4:1.6
	offsite-5-3-pre:1.7
	rel-5-3:1.6
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6
	rel-5-0:1.4
	rel-5-0-beta:1.4
	rel-4-5:1.3
	ctj-4-5-post:1.2
	ctj-4-5-pre:1.2;
locks; strict;
comment	@ * @;


1.13
date	2004.05.21.17.31.08;	author morrison;	state dead;
branches;
next	1.12;

1.12
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	1.9.2.1
	1.9.4.1
	1.9.10.1;
next	1.8;

1.8
date	2002.08.15.20.55.50;	author hartley;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.17.02.41.37;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.07.21.24.51;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	99.12.07.04.11.30;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	98.09.22.01.43.12;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.12.30.10.22.08;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.03.06.10.11.29;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	97.03.06.08.33.35;	author mike;	state Exp;
branches;
next	;

1.9.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2004.03.17.21.23.00;	author morrison;	state Exp;
branches;
next	;

1.9.4.1
date	2004.03.11.23.48.07;	author morrison;	state Exp;
branches;
next	;

1.9.10.1
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@Tcl interfaces to RT program's material & shader library.
@


1.13
log
@moved to src/rt/
@
text
@/*
 *			S H _ T C L . C
 *
 *  Tcl interfaces to RT material & shader routines.
 *
 *  These routines are not for casual command-line use;
 *  as a result, the Tcl name for the function should be exactly
 *  the same as the C name for the underlying function.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/sh_tcl.c,v 1.12 2004/05/10 15:30:49 erikg Exp $ (ARL)";
#endif


#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "externs.h"
#include "shadefuncs.h"

extern struct mfuncs	*mfHead;	/* rt/view.c */

/*
 *			S H _ D I R E C T C H A N G E _ R G B
 *
 *  Go poke the rgb values of a region, on the fly.
 *  This does not update the inmemory database,
 *  so any changes will vanish on next re-prep unless other measures
 *  are taken.
 */
sh_directchange_rgb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_i	*rtip;
	struct region	*regp;
	struct directory *dp;
	float		r,g,b;
	char		buf[64];

	if( argc != 6 )  {
		Tcl_AppendResult(interp, "Usage: sh_directchange_rgb $rtip comb r g b\n", NULL);
		return TCL_ERROR;
	}

	r = atoi(argv[3+0]) / 255.;
	g = atoi(argv[3+1]) / 255.;
	b = atoi(argv[3+2]) / 255.;

	rtip = (struct rt_i *)atoi(argv[1]);
	RT_CK_RTI_TCL(interp, rtip);

	if( rtip->needprep )  {
		Tcl_AppendResult(interp, "rt_prep() hasn't been called yet, error.\n", NULL);
		return TCL_ERROR;
	}

	if( (dp = db_lookup( rtip->rti_dbip, argv[2], LOOKUP_NOISY)) == DIR_NULL )  {
		Tcl_AppendResult(interp, argv[2], ": not found\n", NULL);
		return TCL_ERROR;
	}

	/* Find all region names which match /comb/ pattern */
	for( BU_LIST_FOR( regp, region, &rtip->HeadRegion ) )  {
		if( dp->d_flags & DIR_REGION )  {
			/* name will occur at end of region string w/leading slash */
		} else {
			/* name will occur anywhere, bracked by slashes */
		}

		/* XXX quick hack */
		if( strstr( regp->reg_name, argv[2] ) == NULL )  continue;

		/* Modify the region's color */
bu_log("sh_directchange_rgb() changing %s\n", regp->reg_name);
		VSET( regp->reg_mater.ma_color, r, g, b );

		/* Update the shader */
		mlib_free(regp);
		if( mlib_setup( &mfHead, regp, rtip ) != 1 )  {
			Tcl_AppendResult(interp, regp->reg_name, ": mlib_setup() failure\n", NULL);
		}
	}

	return TCL_OK;
}


/*
 *			S H _ D I R E C T C H A N G E _ S H A D E R
 *
 *  Go poke the rgb values of a region, on the fly.
 *  This does not update the inmemory database,
 *  so any changes will vanish on next re-prep unless other measures
 *  are taken.
 */
sh_directchange_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_i	*rtip;
	struct region	*regp;
	struct directory *dp;
	struct bu_vls	shader;
	char		buf[64];

	if( argc < 4 )  {
		Tcl_AppendResult(interp, "Usage: sh_directchange_shader $rtip comb shader_arg(s)\n", NULL);
		return TCL_ERROR;
	}

	rtip = (struct rt_i *)atoi(argv[1]);
	RT_CK_RTI_TCL(interp, rtip);

	if( rtip->needprep )  {
		Tcl_AppendResult(interp, "rt_prep() hasn't been called yet, error.\n", NULL);
		return TCL_ERROR;
	}

	if( (dp = db_lookup( rtip->rti_dbip, argv[2], LOOKUP_NOISY)) == DIR_NULL )  {
		Tcl_AppendResult(interp, argv[2], ": not found\n", NULL);
		return TCL_ERROR;
	}

	bu_vls_init(&shader);
	bu_vls_from_argv(&shader, argc-3, argv+3);
	bu_vls_trimspace(&shader);

	/* Find all region names which match /comb/ pattern */
	for( BU_LIST_FOR( regp, region, &rtip->HeadRegion ) )  {
		if( dp->d_flags & DIR_REGION )  {
			/* name will occur at end of region string w/leading slash */
		} else {
			/* name will occur anywhere, bracked by slashes */
		}

		/* XXX quick hack */
		if( strstr( regp->reg_name, argv[2] ) == NULL )  continue;

		/* Modify the region's shader string */
bu_log("sh_directchange_shader() changing %s\n", regp->reg_name);
		if( regp->reg_mater.ma_shader )
			bu_free( (genptr_t)regp->reg_mater.ma_shader, "reg_mater.ma_shader");
		regp->reg_mater.ma_shader = bu_vls_strdup(&shader);

		/* Update the shader */
		mlib_free(regp);
		if( mlib_setup( &mfHead, regp, rtip ) != 1 )  {
			Tcl_AppendResult(interp, regp->reg_name, ": mlib_setup() failure\n", NULL);
		}
	}

	bu_vls_free(&shader);
	return TCL_OK;
}

/*
 *			S H _ O P T
 *
 *  Process RT-style command-line options.
 */
sh_opt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct rt_i	*rtip;
	struct region	*regp;
	struct directory *dp;
	float		r,g,b;
	char		buf[64];

	if( argc < 2 )  {
		Tcl_AppendResult(interp, "Usage: sh_opt command_line_option(s)\n", NULL);
		return TCL_ERROR;
	}
	if( get_args( argc, argv ) <= 0 )
		return TCL_ERROR;
	return TCL_OK;
}

/*
 *			S H _ T C L _ S E T U P
 *
 *  Add all the supported Tcl interfaces to RT material/shader routines to
 *  the list of commands known by the given interpreter.
 */
void
sh_tcl_setup(Tcl_Interp *interp)
{
	(void)Tcl_CreateCommand(interp, "sh_directchange_rgb", sh_directchange_rgb,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "sh_directchange_shader", sh_directchange_shader,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "sh_opt", sh_opt,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
}
@


1.12
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/rt/sh_tcl.c,v 1.11 2004/04/05 05:45:59 morrison Exp $ (ARL)";
@


1.11
log
@merge of ansi-6-0-branch into head
@
text
@d27 6
a32 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a35 1
#include "conf.h"
@


1.10
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.9 2002/08/20 17:08:38 jra Exp $ (ARL)";
d61 1
a61 5
sh_directchange_rgb( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d125 1
a125 5
sh_directchange_shader( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d188 1
a188 5
sh_opt( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d212 1
a212 2
sh_tcl_setup(interp)
Tcl_Interp *interp;
@


1.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1997 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.7 2000/08/17 02:41:37 mike Exp $ (ARL)";
@


1.9.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/sh_tcl.c,v 1.10 2004/02/02 17:39:39 morrison Exp $ (ARL)";
@


1.9.10.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.10 2004/02/02 17:39:39 morrison Exp $ (ARL)";
@


1.9.10.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.9.10.1 2004/02/12 19:37:13 erikg Exp $ (ARL)";
@


1.9.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.9 2002/08/20 17:08:38 jra Exp $ (ARL)";
d61 5
a65 1
sh_directchange_rgb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d129 5
a133 1
sh_directchange_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d196 5
a200 1
sh_opt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d224 2
a225 1
sh_tcl_setup(Tcl_Interp *interp)
@


1.9.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d61 5
a65 1
sh_directchange_rgb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d129 5
a133 1
sh_directchange_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d196 5
a200 1
sh_opt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d224 2
a225 1
sh_tcl_setup(Tcl_Interp *interp)
@


1.7
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.6 2000/01/07 21:24:51 mike Exp $ (ARL)";
d61 1
a61 5
sh_directchange_rgb( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d125 1
a125 5
sh_directchange_shader( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d188 1
a188 5
sh_opt( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d212 1
a212 2
sh_tcl_setup(interp)
Tcl_Interp *interp;
@


1.6
log
@
Fixed RegionHead type change.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.5 1999/12/07 04:11:30 mike Exp $ (ARL)";
@


1.5
log
@
Changed to using macro from raytrace.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.4 1998/09/22 01:43:12 mike Exp $ (ARL)";
d96 1
a96 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
d164 1
a164 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
@


1.4
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_tcl.c,v 1.3 1997/12/30 10:22:08 mike Exp $ (ARL)";
a52 3
#define RT_CK_DBI_TCL(_p)	BU_CKMAG_TCL(interp,_p,DBI_MAGIC,"struct db_i")
#define RT_CK_RTI_TCL(_p)	BU_CKMAG_TCL(interp,_p, RTI_MAGIC, "struct rt_i")

d83 1
a83 1
	RT_CK_RTI_TCL(rtip);
d147 1
a147 1
	RT_CK_RTI_TCL(rtip);
@


1.3
log
@Made sh_directchange_shader() actually work.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_tcl.c,v 1.2 1997/03/06 10:11:29 mike Exp mike $ (ARL)";
d49 1
d51 2
d115 1
a115 1
		if( mlib_setup( regp, rtip ) != 1 )  {
d185 1
a185 1
		if( mlib_setup( regp, rtip ) != 1 )  {
@


1.2
log
@Added sh_opt and sh_directchange_shader.
Implementation details are still grungy.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_tcl.c,v 1.1 1997/03/06 08:33:35 mike Exp mike $ (ARL)";
d141 1
a141 1
	if( argc != 6 )  {
d161 1
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.3 1997/03/06 07:34:23 mike Exp mike $ (ARL)";
d50 2
d121 19
d141 49
d191 26
d227 4
@
