head	11.9;
access;
symbols
	rel-4-5:11.7
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.9
date	98.09.22.01.43.11;	author mike;	state dead;
branches;
next	11.8;

11.8
date	98.06.30.22.54.18;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.09;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.08.04.13.35;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.02.26.05;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.11;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.07.06.00.35.21;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.02.17.20.15.54;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.01.05.03.09.14;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.12.16.35.08;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.12.08.08.58.12;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.40;	author mike;	state Rel3_5;
branches;
next	1.2;

1.2
date	89.04.04.05.02.04;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.04.03.20.21.05;	author phil;	state Exp;
branches;
next	;


desc
@A shader for a collection of points (e.g. stars)
@


11.9
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@/*
 *			P O I N T S . C
 *
 *  Reads a file of u,v point locations and associated RGB color values.
 *  For each u,v texture mapping cell, this routine fills in the color
 *  of the "brightest" point contained in that cell (if any).
 *
 *  This routine was born in order to environment map the Yale Bright
 *  Star catalog data without under or over sampling the point sources.
 *  It was soon realized that making it "star" specific limited its
 *  usefulness.
 *
 *  Author -
 *	Phillip Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_points.c,v 11.8 1998/06/30 22:54:18 mike Exp mike $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "spm.h"
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"

#define PT_NAME_LEN 128
struct points_specific {
	char	pt_file[PT_NAME_LEN];	/* Filename */
	int	pt_size;	/* number of bins around equator */
	spm_map_t *pt_map;	/* stuff */
};
#define POINTS_NULL	((struct points_specific *)0)
#define POINTS_O(m)	offsetof(struct points_specific, m)

struct bu_structparse points_parse[] = {
	{"%s",	PT_NAME_LEN, "file", offsetofarray(struct points_specific, pt_file),	FUNC_NULL },
	{"%d",	1, "size",		POINTS_O(pt_size),	FUNC_NULL },
	{"%d",	1, "w",			POINTS_O(pt_size),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
};

HIDDEN int	points_setup(), points_render();
HIDDEN void	points_print(), points_mfree();

struct mfuncs points_mfuncs[] = {
	{MF_MAGIC,	"points",	0,		MFI_UV,		0,
	points_setup,	points_render,	points_print,	points_mfree },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

HIDDEN
struct points {
	fastf_t	u;			/* u location */
	fastf_t	v;			/* v location */
	vect_t	color;			/* color of point */
	struct points	*next;		/* next point in list */
};

/*
 *			P O I N T S _ S E T U P
 *
 *  Returns -
 *	<0	failed
 *	>0	success
 */
HIDDEN int
points_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct rt_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
{
	register struct points_specific *ptp;
	char	buf[513];
	FILE	*fp;

	RT_VLS_CHECK( matparm );
	GETSTRUCT( ptp, points_specific );
	*dpp = (char *)ptp;

	/* get or default shader parameters */
	ptp->pt_file[0] = '\0';
	ptp->pt_size = -1;
	if( bu_struct_parse( matparm, points_parse, (char *)ptp ) < 0 )  {
		rt_free( (char *)ptp, "points_specific" );
		return(-1);
	}
	if( ptp->pt_size < 0 )
		ptp->pt_size = 512;
	if( ptp->pt_file[0] == '\0' )
		strcpy( ptp->pt_file, "points.ascii" );

	/* create a spherical data structure to bin point lists into */
	if( (ptp->pt_map = spm_init( ptp->pt_size, sizeof(struct points) )) == SPM_NULL )
		goto fail;

	/* read in the data */
	if( (fp = fopen(ptp->pt_file, "r")) == NULL ) {
		rt_log("points_setup: can't open \"%s\"\n", ptp->pt_file);
		goto fail;
	}
	while( fgets(buf,512,fp) != NULL ) {
		double	u, v, mag;
		struct points	*headp, *pp;

		if( buf[0] == '#' )
			continue;		/* comment */

		pp = (struct points *)rt_calloc(1, sizeof(struct points), "point");
		sscanf( buf, "%lf%lf%lf", &u, &v, &mag );
		pp->u = u;
		pp->v = v;
		pp->color[0] = mag;
		pp->color[1] = mag;
		pp->color[2] = mag;

		/* find a home for it */
		headp = (struct points *)spm_get( ptp->pt_map, u, v );
		pp->next = headp->next;
		headp->next = pp;
	}
	(void)fclose(fp);

	return(1);
fail:
	rt_free( (char *)ptp, "points_specific" );
	return(-1);
}

/*
 *  			P O I N T S _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  and a "size" of the pixel being rendered (du, dv), fill in the
 *  color of the "brightest" point (if any) within that region.
 */
HIDDEN int
points_render( ap, partp, swp, dp )
struct application *ap;
struct partition *partp;
struct shadework	*swp;
char	*dp;
{
	register struct points_specific *ptp =
		(struct points_specific *)dp;
	register spm_map_t	*mapp;
	fastf_t	umin, umax, vmin, vmax;
	int	xmin, xmax, ymin, ymax;
	register int	x, y;
	register struct points	*pp;
	fastf_t	mag;

swp->sw_uv.uv_du = ap->a_diverge;
swp->sw_uv.uv_dv = ap->a_diverge;
	/*rt_log( "du,dv = %g %g\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv);*/

	/* compute and clip bounds in u,v space */
	umin = swp->sw_uv.uv_u - swp->sw_uv.uv_du;
	umax = swp->sw_uv.uv_u + swp->sw_uv.uv_du;
	vmin = swp->sw_uv.uv_v - swp->sw_uv.uv_dv;
	vmax = swp->sw_uv.uv_v + swp->sw_uv.uv_dv;
	if( umin < 0 )  umin = 0;
	if( vmin < 0 )  vmin = 0;
	if( umax > 1 )  umax = 1;
	if( vmax > 1 )  vmax = 1;

	mapp = ptp->pt_map;

	mag = 0;
	ymin = vmin * mapp->ny;
	ymax = vmax * mapp->ny;
	/* for each latitude band */
	for( y = ymin; y < ymax; y++ ) {
		xmin = umin * mapp->nx[y];
		xmax = umax * mapp->nx[y];
		/* for each bin spanned in that band */
		for( x = xmin; x < xmax; x++ ) {
			pp = (struct points *)&(mapp->xbin[y][x*mapp->elsize]);
			while( pp != NULL ) {
				if(  pp->u < umax && pp->u >= umin
				  && pp->v < vmax && pp->v >= vmin
				  && pp->color[0] > mag ) {
					mag = pp->color[0];
				}
				pp = pp->next;
			}
		}
	}

	/*rt_log( "points_render ([%g %g][%g %g]) = %g\n",
		umin, umax, vmin, vmax, mag );*/

	if( mag == 0 ) {
		VSET( swp->sw_color, 0, 0, 0 );
	} else {
		VSET( swp->sw_color, mag/255.0, mag/255.0, mag/255.0 );
	}

	return(1);
}

/*
 *			P O I N T S _ P R I N T
 */
HIDDEN void
points_print( rp, dp )
register struct region *rp;
char	*dp;
{
	bu_struct_print("points_setup", points_parse, (char *)dp);
	/* Should be more here */
}

HIDDEN void
points_mfree( cp )
char *cp;
{
	/* XXX - free linked lists in every bin! */
	spm_free( (spm_map_t *)cp );
}
@


11.8
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_points.c,v 11.7 1997/12/31 09:01:40 mike Exp $ (BRL)";
@


11.7
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.6 1997/11/25 22:16:43 butler Exp mike $ (BRL)";
d61 1
a61 1
CONST struct mfuncs points_mfuncs[] = {
@


11.6
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.5 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d61 2
a62 2
struct mfuncs points_mfuncs[] = {
	{"points",	0,		0,		MFI_UV,		0,
d65 1
a65 1
	{(char *)0,	0,		0,		0,		0,
@


11.5
log
@bu_struct_print
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.4 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d85 1
a85 1
points_setup( rp, matparm, dpp )
d89 2
@


11.4
log
@bu_struct_parse
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.3 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d227 1
a227 1
	bu_structprint("points_setup", points_parse, (char *)dp);
@


11.3
log
@structparse moved to libbu
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.2 1995/10/20 04:43:53 butler Exp butler $ (BRL)";
d101 1
a101 1
	if( bu_structparse( matparm, points_parse, (char *)ptp ) < 0 )  {
@


11.2
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.1 1995/01/04 10:01:09 mike Rel4_4 butler $ (BRL)";
d51 1
a51 1
struct structparse points_parse[] = {
d101 1
a101 1
	if( rt_structparse( matparm, points_parse, (char *)ptp ) < 0 )  {
d227 1
a227 1
	rt_structprint("points_setup", points_parse, (char *)dp);
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 10.3 94/11/08 04:13:35 mike Exp $ (BRL)";
d62 1
a62 1
	{"points",	0,		0,		MFI_UV,
d65 1
a65 1
	{(char *)0,	0,		0,		0,
@


10.3
log
@Irix 6
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 10.2 94/08/11 02:26:05 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 10.1 1991/10/12 06:42:11 mike Rel4_0 gdurf $ (BRL)";
a167 1
	register unsigned char	*cp;
@


10.1
log
@Release_4.0
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.6 91/07/06 00:35:21 mike Exp $ (BRL)";
d28 2
@


9.6
log
@ANSI structure initialization
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.5 91/02/17 20:15:54 mike Exp $ (BRL)";
@


9.5
log
@Check return code from rt_structparse()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.4 91/01/05 03:09:14 mike Exp $ (BRL)";
d50 4
a53 4
	"%s",	PT_NAME_LEN, "file", offsetofarray(struct points_specific, pt_file),	FUNC_NULL,
	"%d",	1, "size",		POINTS_O(pt_size),	FUNC_NULL,
	"%d",	1, "w",			POINTS_O(pt_size),	FUNC_NULL,
	"",	0, (char *)0,		0,			FUNC_NULL
d60 2
a61 2
	"points",	0,		0,		MFI_UV,
	points_setup,	points_render,	points_print,	points_mfree,
d63 2
a64 2
	(char *)0,	0,		0,
	0,		0,		0,		0
@


9.4
log
@Converted to new format for fmt entry in structparse
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.3 90/12/12 16:35:08 butler Exp $ (BRL)";
d99 4
a102 1
	rt_structparse( matparm, points_parse, (char *)ptp );
@


9.3
log
@modified to reflect changes in structparse format
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.2 90/12/08 08:58:12 butler Exp $ (BRL)";
d53 1
a53 1
	(char *)0, 0, (char *)0,	0,			FUNC_NULL
@


9.2
log
@changed material property parameter to be struct rt_vls
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.1 89/05/19 05:59:40 mike Rel3_5 $ (BRL)";
d40 1
d42 1
a42 1
	char	pt_file[128];	/* Filename */
d50 4
a53 4
	"%s",	"file",		offsetofarray(struct points_specific, pt_file),	FUNC_NULL,
	"%d",	"size",		POINTS_O(pt_size),	FUNC_NULL,
	"%d",	"w",		POINTS_O(pt_size),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.1
log
@Release_3.5
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: sh_points.c,v 1.2 89/04/04 05:02:04 mike Exp $ (BRL)";
d84 1
a84 1
char	*matparm;
d91 1
@


1.2
log
@Converted to new way of representing structure offsets.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: points.c,v 1.1 89/04/03 20:21:05 mike Locked $ (BRL)";
@


1.1
log
@First cut.  Not debugged yet (need to fix divergence stuff)
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: points.c,v 1.1 88/12/27 16:35:08 phil Exp $ (BRL)";
d46 1
d49 4
a52 4
	"%s",	"file",		(stroff_t)(POINTS_NULL->pt_file),	FUNC_NULL,
	"%d",	"size",		(stroff_t)&(POINTS_NULL->pt_size),	FUNC_NULL,
	"%d",	"w",		(stroff_t)&(POINTS_NULL->pt_size),	FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d97 1
a97 1
	rt_structparse( matparm, points_parse, (stroff_t)ptp );
d221 1
a221 1
	rt_structprint("points_setup", points_parse, (stroff_t)dp);
@
