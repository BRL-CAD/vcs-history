head	11.20;
access;
symbols
	ansi-20040405-merged:11.15.2.2
	postmerge-20040405-ansi:11.18
	premerge-20040404-ansi:11.17
	postmerge-autoconf:11.17
	autoconf-freeze:11.16.2.2
	premerge-autoconf:11.17
	postmerge-20040315-windows:11.17
	premerge-20040315-windows:11.17
	windows-20040315-freeze:11.15.4.1
	autoconf-20031203:11.16
	autoconf-20031202:11.16
	autoconf-branch:11.16.0.2
	phong-branch:11.15.0.8
	photonmap-branch:11.15.0.6
	rel-6-1-DP:11.15
	windows-branch:11.15.0.4
	rel-6-0-2:11.13
	ansi-branch:11.15.0.2
	rel-6-0-1-branch:11.13.0.2
	hartley-6-0-post:11.14
	hartley-6-0-pre:11.13
	rel-6-0-1:11.13
	rel-6-0:11.13
	rel-5-4:11.8
	offsite-5-3-pre:11.12
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.8
	rel-5-0-beta:11.8
	rel-4-5:11.7
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1;
locks; strict;
comment	@ * @;


11.20
date	2004.05.21.17.31.07;	author morrison;	state dead;
branches;
next	11.19;

11.19
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.18;

11.18
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches
	11.16.2.1;
next	11.15;

11.15
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.15.2.1
	11.15.4.1;
next	11.14;

11.14
date	2002.08.15.20.55.50;	author hartley;	state Exp;
branches;
next	11.13;

11.13
date	2001.08.11.13.18.27;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	2000.09.08.05.54.46;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.08.17.02.41.37;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.27.19.32.52;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	99.05.28.01.17.27;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.12.16.00.48.49;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.12.16.00.21.34;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.12.16.00.20.11;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.08.22.22.39.47;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.03.29.21.55.48;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.01;	author mike;	state Rel4_4;
branches;
next	10.9;

10.9
date	94.11.05.03.05.00;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.08.11.00.42.43;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.08.11.00.42.05;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.05.05.23.04.29;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.05.05.22.33.57;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.05.05.20.23.26;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.11.11.00.41.31;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.16.21.28.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.04;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.06.30.22.07.56;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.10.07.21.04.16;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.06.06.20.42.14;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.28;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.29.09.44.27;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.35.41;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.22;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.19.22.45.03;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.02.28.22;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.27.03.09.54;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.25.00.50.51;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.24;	author mike;	state Rel;
branches;
next	1.8;

1.8
date	87.10.30.17.57.43;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	87.10.27.22.29.05;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	87.10.21.01.34.37;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	87.10.21.00.34.19;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	87.10.21.00.11.35;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.10.20.07.36.45;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.10.20.06.24.13;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.10.20.04.56.03;	author mike;	state Exp;
branches;
next	;

11.15.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	11.15.2.2;

11.15.2.2
date	2004.03.17.21.23.00;	author morrison;	state Exp;
branches;
next	;

11.15.4.1
date	2004.03.11.23.48.07;	author morrison;	state Exp;
branches;
next	;

11.16.2.1
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	11.16.2.2;

11.16.2.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@Program for computing a path through a database,
using ray-tracing.
@


11.20
log
@moved to src/rt/
@
text
@/*
 *			R T W A L K . C 
 *
 *  Demonstration Ray Tracing main program, using RT library.
 *  Walk a path *without running into any geometry*,
 *  given the start and goal points.
 *
 *  Authors -
 *	Michael John Muuss
 *	Robert J. Reschly, Jr.
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/rtwalk.c,v 11.19 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "../librt/debug.h"
#include "plot3.h"

char	usage[] = "\
Usage:  rtwalk [options] startXYZ destXYZ model.g objects...\n\
 -X #		Set debug flags\n\
	1	plots on stdout\n\
	2	plots, attempts in red\n\
	3	all plots, plus printing\n\
 -x #		Set librt debug flags\n\
 -n #		Number of steps\n\
 -v #		Viewsize\n\
(output is rtwalk.mats)\n\
";

double		viewsize = 42;

/*
 *	0 - off
 *	1 - plots
 *	2 - plots with attempted rays in red
 *	3 - lots of printfs too
 */

int		npsw = 1;		/* Run serially */
int		interactive = 0;	/* human is watching results */

struct application	ap;

point_t		start_point;
point_t		goal_point;

vect_t		dir_prev_step;		/* Dir used on last step */
point_t		pt_prev_step;
vect_t		norm_prev_step = {0, 0, 0};

vect_t		norm_cur_try;		/* normal vector at current hit pt */
point_t		hit_cur_try;
struct curvature curve_cur;

int		nsteps = 10;
fastf_t		incr_dist;
double		clear_dist = 0.0;
double		max_dist_togo;

extern int hit(struct application *ap, struct partition *PartHeadp);
extern int miss(register struct application *ap);

FILE		*plotfp;
FILE		*outfp = NULL;

void		proj_goal(void);
void		write_matrix(int frame);

/*
 *			G E T _ A R G S
 */
int
get_args(int argc, register char **argv)
{
	register int c;

	while( (c=bu_getopt( argc, argv, "x:X:n:v:" )) != EOF )  {
		switch( c )  {
		case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
			fprintf(stderr,"librt rt_g.debug=x%x\n", rt_g.debug);
			break;
		case 'X':
			sscanf( bu_optarg, "%x", (unsigned int *)&rdebug );
			fprintf(stderr,"rt rdebug=x%x\n", rdebug);
			break;

		case 'n':
			nsteps = atoi( bu_optarg );
			break;
		case 'v':
			viewsize = atof( bu_optarg );
			break;

		default:		/* '?' */
			fprintf(stderr,"unknown option %c\n", c);
			return(0);	/* BAD */
		}
	}
	return(1);			/* OK */
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	static struct rt_i *rtip;
	char	*title_file;
	char	idbuf[132];		/* First ID record info */
	int	curstep;
	vect_t	first_dir;		/* First dir chosen on a step */
	int	i;

	bu_semaphore_init( RT_SEM_LAST );

	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit(1);
	}
	if( bu_optind+7 >= argc )  {
		(void)fputs(usage, stderr);
		exit(1);
	}

	/* Start point */
	start_point[X] = atof( argv[bu_optind] );
	start_point[Y] = atof( argv[bu_optind+1] );
	start_point[Z] = atof( argv[bu_optind+2] );

	/* Destination point */
	goal_point[X] = atof( argv[bu_optind+3] );
	goal_point[Y] = atof( argv[bu_optind+4] );
	goal_point[Z] = atof( argv[bu_optind+5] );
	bu_optind += 6;

	VSUB2( first_dir, goal_point, start_point );
	incr_dist = MAGNITUDE(first_dir) / nsteps;
	VMOVE( ap.a_ray.r_pt, start_point );
	VMOVE( ap.a_ray.r_dir, first_dir );
	VUNITIZE( ap.a_ray.r_dir );	/* initial dir, for dir_prev_step */

	fprintf(stderr,"nsteps = %d, incr_dist = %gmm\n", nsteps, incr_dist );
	fprintf(stderr,"viewsize = %gmm\n", viewsize);

	/* Load database */
	title_file = argv[bu_optind++];
	if( (rtip=rt_dirbuild(title_file, idbuf, sizeof(idbuf))) == RTI_NULL ) {
		fprintf(stderr,"rtwalk:  rt_dirbuild failure\n");
		exit(2);
	}
	ap.a_rt_i = rtip;
	fprintf(stderr, "db title:  %s\n", idbuf);

	/* Walk trees */
	for( i=bu_optind; i < argc; i++ )  {
		if( rt_gettree(rtip, argv[bu_optind]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[bu_optind]);
		bu_optind++;
	}

	/* Prep finds the model RPP, needed for the plotting step */
	rt_prep(rtip);

	/*
	 *  With stdout for the plot file, and stderr for
	 *  remarks, the output must go into a file.
	 */
	if( (outfp=fopen("rtwalk.mats", "w")) == NULL )  {
		perror("rtwalk.mats");
		exit(1);
	}
	plotfp = stdout;

	/* Plot all of the solids */
	if( R_DEBUG > 0 )  {
		pl_color( plotfp, 150, 150, 150 );
		rt_plot_all_solids( plotfp, rtip, &rt_uniresource );
	}

	/* Take a walk */
	for( curstep = 0; curstep < nsteps*4; curstep++ )  {
		mat_t	mat;
		int	failed_try;

		/*
		 *  In order to be able to compute deltas from the
		 *  previous to the current step, here we handle
		 *  the results of the last iteration.
		 *  The first and last iterations result in no output
		 */
		if(R_DEBUG>=3) {
			VPRINT("pos", ap.a_ray.r_pt);
		}
		if( curstep > 0 )  {
			if( R_DEBUG > 0 )  {
				if( curstep&1 )
					pl_color( plotfp, 0, 255, 0 );
				else
					pl_color( plotfp, 0, 0, 255 );
				pdv_3line( plotfp,
					pt_prev_step, ap.a_ray.r_pt );
			}
			write_matrix(curstep);
		}
		VMOVE( pt_prev_step, ap.a_ray.r_pt );
		VMOVE( dir_prev_step, ap.a_ray.r_dir );
		VSETALL( norm_cur_try, 0 );	/* sanity */

		/* See if goal has been reached */
		VSUB2( first_dir, goal_point, ap.a_ray.r_pt );
		if( (max_dist_togo=MAGNITUDE(first_dir)) < 1.0 )  {
			fprintf(stderr,"Complete in %d steps\n", curstep);
			exit(0);
		}

		/*  See if there is significant clear space ahead
		 *  Avoid taking small steps.
		 */
		if( clear_dist < incr_dist * 0.25 )
			clear_dist = 0.0;
		if( clear_dist > 0.0 )
			goto advance;

		/*
		 * Initial direction:  Head directly towards the goal.
		 */
		VUNITIZE( first_dir );
		VMOVE( ap.a_ray.r_dir, first_dir );

		for( failed_try=0; failed_try<100; failed_try++ )  {
			vect_t	out;
			int	i;

			/* Shoot Ray */
			if(R_DEBUG>=3)fprintf(stderr,"try=%d, maxtogo=%g  ",
				failed_try, max_dist_togo);
			ap.a_hit = hit;
			ap.a_miss = miss;
			ap.a_onehit = 1;
			if( rt_shootray( &ap ) == 0 )  {
				/* A miss, the way is clear all the way */
				clear_dist = max_dist_togo*2;
				break;
			}
			/* Hit, check distance to closest obstacle */
			if( clear_dist >= incr_dist )  {
				/* Clear for at least one more step.
				 * Zap memory of prev normal --
				 * this probe ahead does not count.
				 * Current normal has no significance,
				 * because object is more than one step away.
				 */
				VSETALL( norm_cur_try, 0 );
				break;
			}
			/*
			 * Failed, try another direction
			 */

			if(R_DEBUG > 2 )   {
				/* Log attempted ray in Red */
				VJOIN1( out, ap.a_ray.r_pt,
					incr_dist*4, ap.a_ray.r_dir );
				pl_color( plotfp, 255, 0, 0 );
				pdv_3line( plotfp,
					pt_prev_step, out );
			}

			/* Initial try was in direction of goal, it failed. */
			if( failed_try == 0 )  {
				/*  First recovery attempt.
				 *  If hit normal has not changed, continue
				 *  the direction of the last step.
				 *  Otherwise, head on tangent plane.
				 */
				if( VEQUAL( norm_cur_try, norm_prev_step ) )  {
					if(R_DEBUG>=3)fprintf(stderr,
						"Try prev dir\n");
					VMOVE( ap.a_ray.r_dir, dir_prev_step );
					continue;
				}
				if(R_DEBUG>=3)fprintf(stderr,"Try tangent\n");
				proj_goal();
				continue;
			} else if( failed_try <= 7 )  {
				/* Try 7 azimuthal escapes, 1..7 */
				i = failed_try-1+1;	/*  1..7 */
				if(R_DEBUG>=3)fprintf(stderr,"Try az %d\n", i);
				bn_mat_ae( mat, i*45.0, 0.0 );
			} else if( failed_try <= 14 ) {
				/* Try 7 Elevations to escape, 8..14 */
				i = failed_try-8+1;	/*     1..7 */
				if(R_DEBUG>=3)fprintf(stderr,"Try el %d\n", i);
				bn_mat_ae( mat, 0.0, i*45.0 );
			} else {
				fprintf(stderr,"trapped, giving up on escape\n");
				exit(1);
			}
			MAT4X3VEC( ap.a_ray.r_dir, mat, first_dir );

			/*
			 *  If new ray is nearly perpendicular to
			 *  the tangent plane, it is doomed to failure;
			 *  pick any tangent and use that instead.
			 */
			if( (VDOT( ap.a_ray.r_dir, norm_cur_try )) < -0.9995 )  {
				vect_t	olddir;

				VMOVE( olddir, ap.a_ray.r_dir );
				VCROSS( ap.a_ray.r_dir, olddir, norm_cur_try );
			}
		}
		if( failed_try > 0 )  {
			/* Extra trys were required, prevent runaways */
			if( clear_dist > incr_dist )
				clear_dist = incr_dist;
		}

		/* One simple attempt at not overshooting the goal.
		 * Really should measure distance point-to-line
		 */
		if( clear_dist > max_dist_togo )
			clear_dist = max_dist_togo;

		/* Advance position along ray */
advance:	;
		if( clear_dist > 0.0 )  {
			fastf_t	step;
			if( clear_dist < incr_dist )
				step = clear_dist;
			else
				step = incr_dist;
			VJOIN1( ap.a_ray.r_pt, ap.a_ray.r_pt,
				step, ap.a_ray.r_dir );
			clear_dist -= step;
		}

		/* Save status */
		VMOVE( norm_prev_step, norm_cur_try );
	}
	fprintf(stderr,"%d steps used without reaching goal by %gmm\n", curstep, max_dist_togo);
	exit(1);
}

int hit(register struct application *ap, struct partition *PartHeadp)
{
	register struct partition *pp;
	register struct soltab *stp;
	register struct hit *hitp;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		bu_log("hit:  no hit out front?\n");
		return(0);
	}
	hitp = pp->pt_inhit;
	stp = pp->pt_inseg->seg_stp;
	VJOIN1( hit_cur_try, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	RT_HIT_NORMAL( norm_cur_try, hitp, stp, &(ap->a_ray), pp->pt_inflip );
	RT_CURVATURE( &curve_cur, hitp, pp->pt_inflip, stp );

	clear_dist = hitp->hit_dist - 1;	/* Decrease 1mm */

	return(1);	/* HIT */
}

int
miss(register struct application *ap)
{
	return(0);
}

/*
 *			P R O J _ G O A L
 *
 *  When progress towards the goal is blocked by an object,
 *  head off "towards the side" to try to get around.
 *  Project the goal point onto the plane tangent to the object
 *  at the hit point.  Head for the projection of the goal point,
 *  which should keep things moving in the right general direction,
 *  except perhaps for concave objects.
 */
void
proj_goal(void)
{
	vect_t	goal_dir;
	vect_t	goal_proj;
	vect_t	newdir;
	fastf_t	k;

	if( VDOT( ap.a_ray.r_dir, norm_cur_try ) < -0.9995 )  {
		/* Projected goal will be right where we are now.
		 * Pick any tangent at all.
		 * Use principle dir of curvature.
		 */
		VMOVE( ap.a_ray.r_dir, curve_cur.crv_pdir );
		return;
	}

	VSUB2( goal_dir, hit_cur_try, goal_point );
	k = VDOT( goal_dir, norm_cur_try );
	VJOIN1( goal_proj, goal_point,
		k, norm_cur_try );
	VSUB2( newdir, goal_proj, hit_cur_try );
	VUNITIZE( newdir );
	VMOVE( ap.a_ray.r_dir, newdir );
}

/*
 *			W R I T E _ M A T R I X
 */
void
write_matrix(int frame)
{
	fprintf(outfp, "start %d;\n", frame);
	fprintf(outfp, "clean;\n");
	fprintf(outfp, "viewsize %g;\n", viewsize);
	fprintf(outfp, "eye_pt %g %g %g;\n", V3ARGS(pt_prev_step) );
	fprintf(outfp, "lookat_pt %g %g %g  0;\n", V3ARGS(goal_point) );
	fprintf(outfp, "end;\n\n" );
}
@


11.19
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/rtwalk.c,v 11.18 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.18
log
@merge of ansi-6-0-branch into head
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.17
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.16 2003/09/27 01:11:25 morrison Exp $ (BRL)";
d81 2
a82 1
extern int hit(), miss();
d87 2
a88 2
void		proj_goal();
void		write_matrix();
d94 1
a94 2
get_args( argc, argv )
register char **argv;
d128 1
a128 3
main(argc, argv)
int argc;
char **argv;
d368 1
a368 3
int hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
d392 1
a392 1
miss()
d408 1
a408 1
proj_goal()
d437 1
a437 1
write_matrix(frame)
@


11.16
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1987 by the United States Army.
d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.15 2002/08/20 17:08:38 jra Exp $ (BRL)";
@


11.16.2.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.17 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.16.2.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.16.2.1 2004/02/12 19:37:13 erikg Exp $ (BRL)";
@


11.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.13 2001/08/11 13:18:27 butler Exp $ (BRL)";
a58 1
int		rdebug;			/* program debugging (not library) */
d200 1
a200 1
	if( rdebug > 0 )  {
d216 1
a216 1
		if(rdebug>=3) {
d220 1
a220 1
			if( rdebug > 0 )  {
d260 1
a260 1
			if(rdebug>=3)fprintf(stderr,"try=%d, maxtogo=%g  ",
d285 1
a285 1
			if(rdebug > 2 )   {
d302 1
a302 1
					if(rdebug>=3)fprintf(stderr,
d307 1
a307 1
				if(rdebug>=3)fprintf(stderr,"Try tangent\n");
d313 1
a313 1
				if(rdebug>=3)fprintf(stderr,"Try az %d\n", i);
d318 1
a318 1
				if(rdebug>=3)fprintf(stderr,"Try el %d\n", i);
@


11.15.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/rtwalk.c,v 11.17 2004/02/02 17:39:39 morrison Exp $ (BRL)";
d59 1
d201 1
a201 1
	if( R_DEBUG > 0 )  {
d217 1
a217 1
		if(R_DEBUG>=3) {
d221 1
a221 1
			if( R_DEBUG > 0 )  {
d261 1
a261 1
			if(R_DEBUG>=3)fprintf(stderr,"try=%d, maxtogo=%g  ",
d286 1
a286 1
			if(R_DEBUG > 2 )   {
d303 1
a303 1
					if(R_DEBUG>=3)fprintf(stderr,
d308 1
a308 1
				if(R_DEBUG>=3)fprintf(stderr,"Try tangent\n");
d314 1
a314 1
				if(R_DEBUG>=3)fprintf(stderr,"Try az %d\n", i);
d319 1
a319 1
				if(R_DEBUG>=3)fprintf(stderr,"Try el %d\n", i);
@


11.15.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.15 2002/08/20 17:08:38 jra Exp $ (BRL)";
d82 1
a82 2
extern int hit(struct application *ap, struct partition *PartHeadp);
extern int miss(register struct application *ap);
d87 2
a88 2
void		proj_goal(void);
void		write_matrix(int frame);
d94 2
a95 1
get_args(int argc, register char **argv)
d129 3
a131 1
main(int argc, char **argv)
d371 3
a373 1
int hit(register struct application *ap, struct partition *PartHeadp)
d397 1
a397 1
miss(register struct application *ap)
d413 1
a413 1
proj_goal(void)
d442 1
a442 1
write_matrix(int frame)
@


11.15.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d59 1
d199 1
a199 1
	if( R_DEBUG > 0 )  {
d215 1
a215 1
		if(R_DEBUG>=3) {
d219 1
a219 1
			if( R_DEBUG > 0 )  {
d259 1
a259 1
			if(R_DEBUG>=3)fprintf(stderr,"try=%d, maxtogo=%g  ",
d284 1
a284 1
			if(R_DEBUG > 2 )   {
d301 1
a301 1
					if(R_DEBUG>=3)fprintf(stderr,
d306 1
a306 1
				if(R_DEBUG>=3)fprintf(stderr,"Try tangent\n");
d312 1
a312 1
				if(R_DEBUG>=3)fprintf(stderr,"Try az %d\n", i);
d317 1
a317 1
				if(R_DEBUG>=3)fprintf(stderr,"Try el %d\n", i);
@


11.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d82 1
a82 2
extern int hit(struct application *ap, struct partition *PartHeadp);
extern int miss(register struct application *ap);
d87 2
a88 2
void		proj_goal(void);
void		write_matrix(int frame);
d94 2
a95 1
get_args(int argc, register char **argv)
d129 3
a131 1
main(int argc, char **argv)
d371 3
a373 1
int hit(register struct application *ap, struct partition *PartHeadp)
d397 1
a397 1
miss(register struct application *ap)
d413 1
a413 1
proj_goal(void)
d442 1
a442 1
write_matrix(int frame)
@


11.13
log
@misc compiler warning changes
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.12 2000/09/08 05:54:46 mike Exp $ (BRL)";
d82 2
a83 1
extern int hit(), miss();
d88 2
a89 2
void		proj_goal();
void		write_matrix();
d95 1
a95 2
get_args( argc, argv )
register char **argv;
d129 1
a129 3
main(argc, argv)
int argc;
char **argv;
d369 1
a369 3
int hit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
d393 1
a393 1
miss()
d409 1
a409 1
proj_goal()
d438 1
a438 1
write_matrix(frame)
@


11.12
log
@
Modified tree routines to take resource pointer.
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.11 2000/08/17 02:41:37 mike Exp $ (BRL)";
d102 1
a102 1
			sscanf( bu_optarg, "%x", &rt_g.debug );
d106 1
a106 1
			sscanf( bu_optarg, "%x", &rdebug );
@


11.11
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.10 2000/07/27 19:32:52 butler Exp $ (BRL)";
d203 1
a203 1
		rt_plot_all_solids( plotfp, rtip );
@


11.10
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.9 2000/07/25 16:39:48 butler Exp $ (BRL)";
@


11.9
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.8 1999/05/28 01:17:27 mike Exp $ (BRL)";
d37 1
d93 1
d128 1
d371 1
a371 1
hit( ap, PartHeadp )
d396 1
@


11.8
log
@
sed4
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtwalk.c,v 11.7 1997/12/16 00:48:49 mike Exp $ (BRL)";
d35 1
a35 1
#include "./rdebug.h"
@


11.7
log
@Changed to use new symbol RT_SEM_LAST
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 11.6 1997/12/16 00:21:34 mike Exp mike $ (BRL)";
d312 1
a312 1
				mat_ae( mat, i*45.0, 0.0 );
d317 1
a317 1
				mat_ae( mat, 0.0, i*45.0 );
d379 1
a379 1
		rt_log("hit:  no hit out front?\n");
@


11.6
log
@Converted to bu_semaphore_acquire()
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 11.5 1997/12/16 00:20:11 mike Exp mike $ (BRL)";
d137 1
a137 1
	bu_semaphore_init( BU_SEM_LAST );
@


11.5
log
@Converted to bu_semaphore_acquire()
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 11.4 1997/08/22 22:39:47 mike Exp mike $ (BRL)";
d137 1
a137 5
	RES_INIT( BU_SEM_SYSCALL );
	RES_INIT( RT_SEM_WORKER );
	RES_INIT( RT_SEM_STATS );
	RES_INIT( RT_SEM_RESULTS );
	RES_INIT( RT_SEM_MODEL );
@


11.4
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 11.3 1996/03/29 23:20:55 mike Exp mike $ (BRL)";
d137 5
a141 5
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );
	RES_INIT( &rt_g.res_model );
@


11.3
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 11.2 1996/03/29 21:55:48 mike Exp mike $ (BRL)";
d97 1
a97 1
	while( (c=getopt( argc, argv, "x:X:n:v:" )) != EOF )  {
d100 1
a100 1
			sscanf( optarg, "%x", &rt_g.debug );
d104 1
a104 1
			sscanf( optarg, "%x", &rdebug );
d109 1
a109 1
			nsteps = atoi( optarg );
d112 1
a112 1
			viewsize = atof( optarg );
d147 1
a147 1
	if( optind+7 >= argc )  {
d153 3
a155 3
	start_point[X] = atof( argv[optind] );
	start_point[Y] = atof( argv[optind+1] );
	start_point[Z] = atof( argv[optind+2] );
d158 4
a161 4
	goal_point[X] = atof( argv[optind+3] );
	goal_point[Y] = atof( argv[optind+4] );
	goal_point[Z] = atof( argv[optind+5] );
	optind += 6;
d173 1
a173 1
	title_file = argv[optind++];
d182 4
a185 4
	for( i=optind; i < argc; i++ )  {
		if( rt_gettree(rtip, argv[optind]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[optind]);
		optind++;
@


11.2
log
@Changed to use new curvature macro.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 11.1 1995/01/04 10:01:01 mike Rel4_4 mike $ (BRL)";
d388 2
a389 1
	RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
a390 2
	VMOVE( hit_cur_try, hitp->hit_point );
	VMOVE( norm_cur_try, hitp->hit_normal );
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.9 94/11/05 03:05:00 mike Exp $ (BRL)";
d389 1
a389 1
	RT_CURVE( &curve_cur, hitp, stp );
@


10.9
log
@Irix 6
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.8 94/08/11 00:42:43 gdurf Exp Locker: mike $ (BRL)";
@


10.8
log
@Added include of externs.h
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.7 1994/08/11 00:42:05 gdurf Exp gdurf $ (BRL)";
a95 1
	register int i;
a130 1
	static vect_t temp;
a258 1
			fastf_t	dot;
d333 1
a333 1
			if( (dot=VDOT( ap.a_ray.r_dir, norm_cur_try )) < -0.9995 )  {
a444 5
	mat_t	viewrot;
	int	i;
	vect_t	model;
	vect_t	view;

@


10.7
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.6 1994/05/05 23:04:29 mike Exp gdurf $ (BRL)";
d30 1
d32 1
@


10.6
log
@Added a 'clean' command, to keep things simple.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.5 94/05/05 22:33:57 mike Exp Locker: mike $ (BRL)";
d25 2
a35 4
extern int	getopt();
extern char	*optarg;
extern int	optind;

a46 2

extern char	*sbrk();
@


10.5
log
@A tidy output routine now.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.4 94/05/05 20:23:26 mike Exp Locker: mike $ (BRL)";
d456 1
@


10.4
log
@Changed to use new "lookat_pt" directive.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.3 92/11/11 00:41:31 mike Exp Locker: mike $ (BRL)";
d455 1
d457 1
a457 18
	fprintf(outfp, "eye_pt %g %g %g;\n",
		pt_prev_step[X],
		pt_prev_step[Y],
		pt_prev_step[Z]);
#if 0
	/* Build viewrot matrix */
	VSUB2( model, goal_point, pt_prev_step );
	VUNITIZE( model );

	mat_lookat( viewrot, model, 0 );
	fprintf(outfp, "viewrot ");
	for( i=0; i < 16; i++ ) {
		(void)fprintf(outfp, "%.9e ", viewrot[i] );
		if( (i%4) == 3 )
			(void)fprintf(outfp, "\n");
	}
	(void)fprintf(outfp,";\n");
#else
a458 2
#endif
	fprintf(outfp, "start %d;\n", frame);
@


10.3
log
@Elimiated bad setting of a_resource
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.2 92/03/16 21:28:41 mike Exp Locker: mike $ (BRL)";
d455 6
a461 1
/*	VSUB2( model, hit_cur_try, pt_prev_step );	/* Look to next step */
a465 21

#if 0
	/* Old way */
	fprintf(outfp, "%g\n", viewsize);
	fprintf(outfp, "%g %g %g",
		pt_prev_step[X],
		pt_prev_step[Y],
		pt_prev_step[Z]);

	for( i=0; i < 16; i++ ) {
		if( (i%4) == 0 )  (void)fprintf(outfp, "\n");
		(void)fprintf( outfp, "%.9e ", viewrot[i] );
	}
	(void)fprintf(outfp,"\n\n");
#else
	/* New way */
	fprintf(outfp, "viewsize %g;\n", viewsize);
	fprintf(outfp, "eye_pt %g %g %g;\n",
		pt_prev_step[X],
		pt_prev_step[Y],
		pt_prev_step[Z]);
d473 3
a477 1
#endif
a478 15

#if defined(SYSV)
#if !defined(bcopy)
bcopy(from,to,count)
{
	memcpy( to, from, count );
}
#endif
#if !defined(bzero)
bzero(str,n)
{
	memset( str, '\0', n );
}
#endif
#endif
@


10.2
log
@IRIX 4.0.1
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 10.1 91/10/12 06:42:04 mike Rel4_0 Locker: mike $ (BRL)";
a64 1
struct resource		resource;
a270 1
			ap.a_resource = &resource;
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 9.4 91/06/30 22:07:56 mike Exp $ (BRL)";
d86 1
a86 1
FILE		*plotfp = stdout;
d204 1
@


9.4
log
@Changed to use rt_plot_all_solids
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 9.3 90/10/07 21:04:16 mike Exp $ (BRL)";
@


9.3
log
@Modified to plot the solids, rather than the bounding boxes.
Modified for new raytrace.h
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 9.2 90/06/06 20:42:14 mike Exp $ (BRL)";
a206 3
		register struct soltab *stp;

		pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
d208 1
a208 6

		for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
			if( stp->st_aradius >= INFINITY )
				continue;
			(void)rt_plot_solid( plotfp, rtip, stp );
		}
@


9.2
log
@lint
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rtwalk.c,v 9.1 89/05/19 05:59:28 mike Rel3_5 $ (BRL)";
d205 1
a205 1
	/* Plot all of the solid RPPs in a light grey */
d212 1
a212 1
		for(stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
d215 1
a215 1
			pdv_3box( plotfp, stp->st_min, stp->st_max );
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 8.3 89/04/29 09:44:27 mike Exp $ (BRL)";
d469 1
a469 1
	mat_lookat( viewrot, model );
@


8.3
log
@Added RES_INIT for res_model.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 8.2 88/12/06 00:35:41 mike Locked $ (BRL)";
@


8.2
log
@Produce new style animation scripts
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: /cad/d/mike/cad/rt/RCS/rtwalk.c,v 1.1 88/10/30 01:35:13 mike Exp $ (BRL)";
d146 1
a146 1

@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 7.5 88/09/19 22:45:03 mike Exp $ (BRL)";
d471 2
a472 1
/*	fprintf(outfp, "start %d;\n", frame); */
d484 17
@


7.5
log
@atof() is adequately "extern'ed" in <math.h>, and
re-defining in locally sometimes produced clashes,
so local definitions were removed.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 7.4 88/05/14 02:28:22 mike Locked $ (BRL)";
@


7.4
log
@lint fixes
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 7.3 88/02/27 03:09:54 mike Exp $ (BRL)";
a49 1
extern double	atof();
@


7.3
log
@Converted remaining "parallel" vars to "rt_g.rtg_parallel".
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 7.2 88/02/25 00:50:51 mike Locked $ (BRL)";
d90 3
d428 1
d457 1
@


7.2
log
@Modified for new 3-D floating point UNIX-plot
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 7.1 87/11/02 23:56:24 mike Locked $ (BRL)";
a63 1
int		parallel = 0;
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 1.8 87/10/30 17:57:43 mike Exp $ (BRL)";
d208 1
a208 1
		pl_3space( plotfp, 0,0,0, 4096, 4096, 4096);
d214 1
a214 1
			rt_draw_box( plotfp, rtip, stp->st_min, stp->st_max );
d238 1
a238 1
				rt_drawvec( plotfp, ap.a_rt_i,
d305 1
a305 1
				rt_drawvec( plotfp, ap.a_rt_i,
@


1.8
log
@getopt version
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 1.7 87/10/27 22:29:05 mike Locked $ (BRL)";
@


1.7
log
@Fixed rdebug extern for machine.c, added -X for setting rdebug.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 1.6 87/10/21 01:34:37 mike Locked $ (BRL)";
d39 5
a43 1
Usage:  rtwalk [options] model.g objects...\n\
a44 2
 -p # # #	Set starting point\n\
 -a # # #	Set shoot-at point (destination)\n\
d47 1
d70 1
a70 2
int		set_pt = 0;
int		set_at = 0;
d92 35
d139 1
a145 6
	if( argc < 3 )  {
		(void)fputs(usage, stderr);
		exit(1);
	}
	argc--;
	argv++;
d147 1
a147 51
	while( argv[0][0] == '-' ) switch( argv[0][1] )  {
	case 'x':
		sscanf( argv[1], "%x", &rt_g.debug );
		fprintf(stderr,"librt rt_g.debug=x%x\n", rt_g.debug);
		argc -= 2;
		argv += 2;
		break;

	case 'X':
		sscanf( argv[1], "%x", rdebug );
		fprintf(stderr,"rdebug=x%x\n", rdebug);
		argc -= 2;
		argv += 2;
		break;

	case 'p':
		if( argc < 4 )  goto err;
		ap.a_ray.r_pt[X] = atof( argv[1] );
		ap.a_ray.r_pt[Y] = atof( argv[2] );
		ap.a_ray.r_pt[Z] = atof( argv[3] );
		set_pt = 1;
		argc -= 4;
		argv += 4;
		continue;

	case 'a':
		if( argc < 4 )  goto err;
		goal_point[X] = atof( argv[1] );
		goal_point[Y] = atof( argv[2] );
		goal_point[Z] = atof( argv[3] );
		set_at = 1;
		argc -= 4;
		argv += 4;
		continue;

	case 'n':
		if( argc < 2 )  goto err;
		nsteps = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		continue;

	case 'v':
		if( argc < 2 )  goto err;
		viewsize = atof( argv[1] );
		argc -= 2;
		argv += 2;
		continue;

	default:
err:
d151 1
a151 2
	if( argc < 2 )  {
		fprintf(stderr,"rtwalk: MGED database not specified\n");
d156 4
a159 1
	if( set_pt + set_at != 2 )  goto err;
d161 7
a167 1
	VSUB2( first_dir, goal_point, ap.a_ray.r_pt );
d169 1
d177 1
a177 3
	title_file = argv[0];
	argv++;
	argc--;
d186 4
a189 5
	while( argc > 0 )  {
		if( rt_gettree(rtip, argv[0]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[0]);
		argc--;
		argv++;
d205 1
a205 3
	pl_3space( plotfp, 0,0,0, 4096, 4096, 4096);
	pl_color( plotfp, 150, 150, 150 );
	{
d207 4
d233 8
a240 6
			if( curstep&1 )
				pl_color( plotfp, 0, 255, 0 );
			else
				pl_color( plotfp, 0, 0, 255 );
			rt_drawvec( plotfp, ap.a_rt_i,
				pt_prev_step, ap.a_ray.r_pt );
@


1.6
log
@Minor cleanup of rotational escape epilogue.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 1.5 87/10/21 00:34:19 mike Locked $ (BRL)";
d58 1
a58 1
int		debug;			/* program debugging (not library) */
d123 7
d239 1
a239 1
		if(debug>=3) {
d282 1
a282 1
			if(debug>=3)fprintf(stderr,"try=%d, maxtogo=%g  ",
d308 1
a308 1
			if(debug > 2 )   {
d325 1
a325 1
					if(debug>=3)fprintf(stderr,
d330 1
a330 1
				if(debug>=3)fprintf(stderr,"Try tangent\n");
d336 1
a336 1
				if(debug>=3)fprintf(stderr,"Try az %d\n", i);
d341 1
a341 1
				if(debug>=3)fprintf(stderr,"Try el %d\n", i);
@


1.5
log
@Moved mat_lookat and mat_fromto to librt/mat.c
Neatened comments slightly.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtwalk.c,v 1.4 87/10/21 00:11:35 mike Locked $ (BRL)";
d342 4
a345 4
			/* Limit new direction to lie "above" or on
			 * the tangent plane at the current hit point,
			 * to prevent constantly banging into the
			 * object we just hit.
d347 1
a347 1
			if( (dot=VDOT( ap.a_ray.r_dir, norm_cur_try )) < 0 )  {
d350 2
a351 7
				if( dot <= -0.9995 )  {
					/* Pick any tangent */
					VMOVE( olddir, ap.a_ray.r_dir );
					VCROSS( ap.a_ray.r_dir, olddir, norm_cur_try );
				} else {
					proj_goal();
				}
@


1.4
log
@Small-step avoidance.
Serious cleanups to mat_fromto() and mat_lookat().
@
text
@d6 1
a6 3
 *  given any two of these three parameters:
 *	start point
 *	at point
d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rtshot.c,v 6.1 87/07/11 07:59:14 mike Locked $ (BRL)";
a85 2
static double deg2rad = 57.29577951125853957129;

d101 1
a101 1
	vect_t	first_dir;	/* First dir chosen on a step */
a122 1

d226 9
a234 2
		/* Record this step */
		if(debug>=3) {VPRINT("pos", ap.a_ray.r_pt);}
d337 1
a337 1
				fprintf(stderr,"giving up on escape\n");
a501 90

/* wrapper for atan2.  On SGI (and perhaps others), x==0 returns infinity */
double
xatan2(y,x)
double	y,x;
{
	if( x > -1.0e-20 && x < 1.0e-20 )  {
		/* X is equal to zero, check Y */
		if( y < -1.0e-20 )  return( -3.14159265358979323/2 );
		if( y >  1.0e-20 )  return(  3.14159265358979323/2 );
		return(0.0);
	}
	return( atan2( y, x ) );
}
/*
 *			M A T _ F R O M T O
 *
 *  Given two vectors, compute a rotation matrix that will transform
 *  space by the angle between the two.  Since there are many
 *  candidate matricies, the method used here is to convert the vectors
 *  to azimuth/elevation form (azimuth is +X, elevation is +Z),
 *  take the difference, and form the rotation matrix.
 *  See mat_ae for that algorithm.
 *
 *  The input 'from' and 'to' vectors must be unit length.
 */
mat_fromto( m, from, to )
mat_t	m;
vect_t	from;
vect_t	to;
{
	double	az, el;
	LOCAL double sin_az, sin_el;
	LOCAL double cos_az, cos_el;

	az = xatan2( to[Y], to[X] ) - xatan2( from[Y], from[X] );
	el = asin( to[Z] ) - asin( from[Z] );

	sin_az = sin(az);
	cos_az = cos(az);
	sin_el = sin(el);
	cos_el = cos(el);

	m[0] = cos_el * cos_az;
	m[1] = -sin_az;
	m[2] = -sin_el * cos_az;
	m[3] = 0;

	m[4] = cos_el * sin_az;
	m[5] = cos_az;
	m[6] = -sin_el * sin_az;
	m[7] = 0;

	m[8] = sin_el;
	m[9] = 0;
	m[10] = cos_el;
	m[11] = 0;

	m[12] = m[13] = m[14] = 0;
	m[15] = 1.0;
}

/*
 *			M A T _ L O O K A T
 *
 *  Given a direction vector D, product a matrix suitable for use
 *  as a "model2view" matrix that transforms the vector D
 *  into the -Z ("view") axis.
 *
 *  Note that due to the special property of mat_fromto()
 *  that prevents "twist" on the vector by orienting on the X-Y
 *  plane, we must first find the transformation that maps
 *  D into the +X axis, and then rotate to the -Z axis.
 */
mat_lookat( rot, dir )
mat_t rot;
vect_t dir;
{
	mat_t	second;
	mat_t	first;
	vect_t	x;

	/* Rotate from Dir to +X */
	VSET( x, 1, 0, 0 );
	mat_fromto( first, dir, x );

	/* Rotate so that +X is now -Z axis */
	mat_angles( second, -90.0, 0.0, 90.0 );
	mat_mul( rot, second, first );
}
@


1.3
log
@Fixed problem with "double framing" when avoiding obstacles.
@
text
@a103 1
	vect_t	diff;
d105 1
a106 1

d175 5
a179 2
	VSUB2( diff, ap.a_ray.r_pt, goal_point );
	incr_dist = MAGNITUDE(diff) / nsteps;
d201 2
d205 4
d214 1
a215 1
/**	rt_plot_cut( plotfp, rtip, &rtip->rti_CutHead, 0 );**/
a227 1
		vect_t	first_dir;	/* First dir chosen on this try */
d247 2
a248 3
		VSUB2( diff, goal_point, ap.a_ray.r_pt );
		if( (max_dist_togo=MAGNITUDE(diff)) < 1.0 )  {
			/* Walk is complete */
d253 7
a259 2
		/* See if additional clear space ahead */
		if( clear_dist > 0.0 )  goto advance;
a263 1
		VSUB2( first_dir, goal_point, ap.a_ray.r_pt );
d362 4
a365 2
		/* One simple attempt at not overshooting the goal */
		/* Really should measure distance point-to-line */
d386 1
a386 1
	return(0);
d420 10
a431 3
	/* Head towards projection of
	 * goal onto tangent plane
	 */
d455 31
d562 12
a573 40
write_matrix(frame)
{
	mat_t	xlate;
	mat_t	rot;
	mat_t	model2view;
	int	i;
	vect_t	from;
	vect_t	to;

	/* Build model2view matrix */
/*	VSUB2( from, hit_cur_try, pt_prev_step );	/* Look to next step */
	VSUB2( from, goal_point, pt_prev_step );
	VSET( to, 0, 0, -1 );
	VUNITIZE( from );
	VUNITIZE( to );

	mat_idn(xlate);
	MAT_DELTAS( xlate,
		-pt_prev_step[X],
		-pt_prev_step[Y],
		-pt_prev_step[Z]);
/**	mat_fromto( rot, from, to ); **/
	mat_lookat( rot, from );
	mat_mul( model2view, rot, xlate );

/*	fprintf(outfp, "start %d;\n", frame); */
	fprintf(outfp, "%g\n", viewsize);
	fprintf(outfp, "%g %g %g",
		pt_prev_step[X],
		pt_prev_step[Y],
		pt_prev_step[Z]);

	for( i=0; i < 16; i++ ) {
		if( (i%4) == 0 )  (void)fprintf(outfp, "\n");
		(void)fprintf( outfp, "%.9e ", rot[i] );
	}
	(void)fprintf(outfp,"\n\n");

}

d578 3
a580 1
	mat_t left, down, t;
d582 7
a588 13
	VUNITIZE( dir );
	mat_idn( rot );
	mat_idn( left );
	mat_idn( down );
	mat_idn( t );
	mat_ae( t,
		atan2(dir[Y],dir[X])*deg2rad ,/* az */
		asin(dir[Z]) * deg2rad ); /* elev */
	mat_inv( rot, t );
	mat_angles( left, 0.0, 0.0, 90.0 );
	mat_angles( down, -90.0, 0.0, 0.0 );
	mat_mul( t, left, rot );
	mat_mul( rot, down, t );
@


1.2
log
@Added RT matrix output stuff.
@
text
@d247 2
a248 11
		if( clear_dist > 0.0 )  {
			fastf_t	step;
			if( clear_dist < incr_dist )
				step = clear_dist;
			else
				step = incr_dist;
			VJOIN1( ap.a_ray.r_pt, ap.a_ray.r_pt,
				step, ap.a_ray.r_dir );
			clear_dist -= step;
			continue;
		}
d357 14
@


1.1
log
@Initial revision
@
text
@d46 1
d52 2
d88 2
d91 1
d156 7
d179 1
d201 5
d208 1
a208 1
	pl_color( plotfp, 200, 200, 200 );
d233 1
d243 1
d445 122
@
