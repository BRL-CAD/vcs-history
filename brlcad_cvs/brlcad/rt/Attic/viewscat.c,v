head	11.17;
access;
symbols
	ansi-20040405-merged:11.13.4.1
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.14.2.2
	premerge-autoconf:11.15
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.13.6.1
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.2
	phong-branch:11.13.0.10
	photonmap-branch:11.13.0.8
	rel-6-1-DP:11.13
	windows-branch:11.13.0.6
	rel-6-0-2:11.13
	ansi-branch:11.13.0.4
	rel-6-0-1-branch:11.13.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.13
	rel-6-0-1:11.13
	rel-6-0:11.12
	rel-5-4:11.9
	offsite-5-3-pre:11.11
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.9
	rel-5-0-beta:11.8
	rel-4-5:11.5
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.17.31.10;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches
	11.14.2.1;
next	11.13;

11.13
date	2002.06.21.21.07.21;	author morrison;	state Exp;
branches
	11.13.4.1
	11.13.6.1;
next	11.12;

11.12
date	2001.04.05.19.36.04;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2000.08.17.02.41.42;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.25.16.39.49;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	99.07.02.22.19.46;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.05.28.01.19.30;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	98.09.22.00.21.02;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	98.09.11.17.05.09;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.03.29.21.55.48;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.06.17.57.53;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.32;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.02.47.39;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.24;	author mike;	state Rel4_0;
branches;
next	1.5;

1.5
date	91.02.20.00.51.36;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.02.20.00.32.24;	author stay;	state Exp;
branches;
next	1.3;

1.3
date	90.11.14.15.52.09;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.11.14.15.43.44;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.11.14.15.39.20;	author mike;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.17.21.23.01;	author morrison;	state Exp;
branches;
next	;

11.13.6.1
date	2004.03.11.23.48.08;	author morrison;	state Exp;
branches;
next	;

11.14.2.1
date	2004.02.12.19.37.14;	author erikg;	state Exp;
branches;
next	11.14.2.2;

11.14.2.2
date	2004.03.15.14.08.08;	author erikg;	state Exp;
branches;
next	;


desc
@RT backscatter radar code view module
@


11.17
log
@moved to src/rt/
@
text
@/*
 *			V I E W S C A T . C
 *
 *  Ray Tracing program RTRAD bottom half.
 *
 *  This module takes the first hit from rt_shootray(), and produces
 *  a GIFT/SRIM format Radar file.  It tracks specular direction
 *  reflections.
 *
 *  Author -
 *	Phillip Dykstra
 *	Paul R. Stay		(Added parallelization and physics code)
 *	From viewpp.c and viewray.c by
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSppview[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/viewscat.c,v 11.16 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "rad.h"

#ifndef M_PI
#define M_PI            3.14159265358979323846
#endif

#define	MAXREFLECT	16
#define	DEFAULTREFLECT	16

int		use_air = 0;		/* Handling of air in librt */
int		using_mlib = 0;		/* Material routines NOT used */

extern	FILE	*outfp;
extern	point_t	viewbase_model;		/* lower_left of viewing plane */
extern	mat_t	view2model;
extern	fastf_t	viewsize;
extern 	int 	npsw;			/* number of processors */

extern	int	width;
extern	int	height;

int	numreflect = DEFAULTREFLECT;	/* max number of reflections */

/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
	"%d",	1, "maxreflect",	(int)&numreflect,	BU_STRUCTPARSE_FUNC_NULL,
	"%f",	1, "wavelength",	(int)&wavelength,	BU_STRUCTPARSE_FUNC_NULL,
	"%f",	1, "xhpol",	(int)&xhpol,		BU_STRUCTPARSE_FUNC_NULL,
	"%f",	1, "xvpol",	(int)&xvpol,		BU_STRUCTPARSE_FUNC_NULL,
	"%f",	1, "rhpol",	(int)&rhpol,		BU_STRUCTPARSE_FUNC_NULL,
	"%f",	1, "rvpol",	(int)&rvpol,		BU_STRUCTPARSE_FUNC_NULL,
	"%f",	1, "epsilon",	(int)&epsilon,		BU_STRUCTPARSE_FUNC_NULL,
	"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL
};

void		dumpray();
void		dumpall();
static int	isvisible();

char usage[] = "\
Usage:  rtrad [options] model.g objects... >file.rad\n\
Options:\n\
 -s #		Grid size in pixels, default 512\n\
 -n #		Vertical # rays \n\
 -w #		Horizontal # rays \n\
 -a Az		Azimuth in degrees\n\
 -e Elev	Elevation in degrees\n\
 -g #		ray horizontal tube size (cell_width)\n\
 -G #		ray vertical tube size (cell_heigth)\n\
 -M		Read matrix, cmds on stdin\n\
 -o file.rad	Output file name, else stdout\n\
 -x #		Set librt debug flags\n\
";

struct rayinfo rayinfo[MAX_PSW][MAXREFLECT];
struct xray firstray[MAX_PSW];

static int radhit();
static int radmiss();

vect_t uhoriz;	/* horizontal emanation plane unit vector. */
vect_t unorml;	/* normal unit vector to emanation plane. */
vect_t cemant;	/* center vector of emanation plane. */
vect_t uvertp;	/* vertical emanation plane unit vector. */
fastf_t wavelength = 1.0;	/* Radar wavelength */
fastf_t xhpol = 0.0;	/* Transmitter vertical polarization */
fastf_t xvpol = 1.0;	/* Transmitter horizontal polarization */ 
fastf_t rhpol = 0.0;	/* Receiver vertical polarization */
fastf_t rvpol = 1.0;	/* Receiver horizontal polarization */
fastf_t epsilon = 1.0e-07;
fastf_t totali;
fastf_t totalq;

/*
 *  			V I E W _ I N I T
 *
 *  Called at the start of a run.
 *  Returns 1 if framebuffer should be opened, else 0.
 */
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
{
	ap->a_hit = radhit;
	ap->a_miss = radmiss;
	ap->a_onehit = 1;

#ifdef SAR
	sar_init(ap, file, obj, minus_o);
#endif	
	return(0);		/* no framebuffer needed */
}

/* beginning of a frame */
void
view_2init( ap )
struct application *ap;
{
	extern fastf_t azimuth, elevation;
	fastf_t elvang, aziang;
	vect_t temp, aimpt;
	fastf_t backoff;
	

	if( numreflect > MAXREFLECT ) {
		bu_log("Warning: maxreflect too large (%d), using %d\n",
			numreflect, MAXREFLECT );
		numreflect = MAXREFLECT;
	}

	elvang = elevation * M_PI / 180.0;	
	aziang = azimuth * M_PI / 180.0;	

	uhoriz[0] = (fastf_t) sin(aziang);
	uhoriz[1] = (fastf_t) -cos(aziang);
	uhoriz[3] = (fastf_t) 0.0;
	VUNITIZE( uhoriz );

	unorml[0] = (fastf_t) cos(elvang) * uhoriz[1];
	unorml[1] = (fastf_t) -cos(elvang) * uhoriz[0];
	unorml[2] = (fastf_t) -sin(elvang);
	VUNITIZE( unorml );

	/* this doesn't seem to be quite right emanat.f */
	uvertp[0] = uhoriz[1] * unorml[2] - unorml[1]* uhoriz[2];
	uvertp[1] = uhoriz[2] * unorml[0] - unorml[2]* uhoriz[0];
	uvertp[2] = uhoriz[0] * unorml[1] - unorml[0]* uhoriz[1];
	VUNITIZE( uvertp );
	VPRINT("uhoriz",uhoriz);
	VPRINT("unorml",unorml);
	VPRINT("uvertp",uvertp);
	totali = 0.0;
	totalq = 0.0;

	VSET(temp, 0.0, 0.0, -1.414 );
	MAT4X3PNT( aimpt,view2model, temp);
	bu_log("aim point %f %f %f\n", aimpt[0], aimpt[1], aimpt[2]);
	bu_log("viewsize %f\n", viewsize);
	backoff = 1.414 * viewsize/2.0;
	bu_log("backoff %f\n", backoff);

#ifdef SAR
	sar_2init( ap );
#endif
}

/* end of each pixel */
void	view_pixel() {}

/* end of each line */
void	view_eol() {}

void	view_setup() {}
/* Associated with "clean" command, before new tree is loaded  */
void	view_cleanup() {}

/* end of a frame */
void
view_end()
{
	fastf_t rcs;
	fastf_t iret, qret;
	LOCAL int cpu_num, cpus;

	iret = 0.0;
	qret = 0.0;
	rcs = 0.0;

	iret = totali;
	qret = totalq;

	rcs = (iret * iret) + (qret * qret);

	bu_log("Az %2.1f Ele %2.1f totali %1.4E totalq %1.4E rcs %1.4E\n",
		azimuth, elevation, iret, qret, rcs );
}

static int
radhit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	register struct partition *pp;
	register struct hit *hitp;
	LOCAL struct application sub_ap;
	LOCAL struct rayinfo *rayp;
	LOCAL fastf_t	f;
	LOCAL vect_t	to_eye, work;
	LOCAL int	depth;
	LOCAL int	cpu_num;
	
	
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		bu_log("radhit:  no hit out front?\n");
		return(0);
	}

	if(R_DEBUG&RDEBUG_HITS)  {
		rt_pr_pt( ap->a_rt_i, pp );
	}

	hitp = pp->pt_inhit;
	if( hitp->hit_dist >= INFINITY )  {
		bu_log("radhit:  entry beyond infinity\n");
		return(1);
	}
	/* Check to see if eye is "inside" the solid */
	if( hitp->hit_dist < 0 )  {
		/* XXX */
		return(0);
	}

	if(R_DEBUG&RDEBUG_HITS)  {
		rt_pr_hit( " In", hitp );
	}
	
	if ( ap->a_resource == RESOURCE_NULL)
		cpu_num = 0;
	else
		cpu_num = ap->a_resource->re_cpu;

	rayp = &rayinfo[cpu_num][ ap->a_level +1 ];
	rayp->x = ap->a_x;
	rayp->y = ap->a_y;
	rayp->dist = hitp->hit_dist;
	rayp->reg = pp->pt_regionp->reg_regionid;
	rayp->sol = pp->pt_inseg->seg_stp->st_id;
	rayp->surf = hitp->hit_surfno;
	RT_HIT_NORMAL( rayp->norm, hitp, pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip );
	RT_CURVATURE( &(rayp->curvature), hitp, pp->pt_inflip, pp->pt_inseg->seg_stp );
	if( VDOT( hitp->hit_normal, ap->a_ray.r_dir ) < 0 ) {
		bu_log(" debug: curvature flip\n");
		rayp->curvature.crv_c1 = - rayp->curvature.crv_c1;
		rayp->curvature.crv_c2 = - rayp->curvature.crv_c2;
	}
	VMOVE( rayp->ip, hitp->hit_point );
	VMOVE( rayp->dir, ap->a_ray.r_dir);

	/* Compute the specular direction */
	VREVERSE( to_eye, ap->a_ray.r_dir );
	f = 2 * VDOT( to_eye, rayp->norm );
	VSCALE( work, rayp->norm, f );
	/* I have been told this has unit length */
	VSUB2( rayp->spec, work, to_eye );
	VUNITIZE( rayp->spec );

	/* Save info for 1st ray */
	if( ap->a_level == 0 ) {
		firstray[cpu_num] = ap->a_ray;	/* struct copy */
		rayp->sight = 1;	/* the 1st intersect is always visible */
	} else {
		/* Check for visibility */
		rayp->sight = isvisible( ap, hitp, rayp->norm );
	}

	/*
	 * Shoot another ray in the specular direction.
	 */
	if( ap->a_level < numreflect-1 ) {
		sub_ap = *ap;	/* struct copy */
		sub_ap.a_level = ap->a_level+1;
		sub_ap.a_purpose = "secondary ray";
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
		VMOVE( sub_ap.a_ray.r_dir, rayp->spec );
		depth = rt_shootray( &sub_ap );
	} else {
		depth = 0;
	}

	if( ap->a_level == 0 ) {
		rayinfo[cpu_num][0].x = ap->a_x;
		rayinfo[cpu_num][0].y = ap->a_y;
		rayinfo[cpu_num][0].surf = depth+1;
		rayinfo[cpu_num][0].ip[0] = ap->a_ray.r_pt[0];
		rayinfo[cpu_num][0].ip[1] = ap->a_ray.r_pt[1];
		rayinfo[cpu_num][0].ip[2] = ap->a_ray.r_pt[2];
		radar_physics( cpu_num, depth + 1 );
#ifdef SAR
		dumpall( ap, cpu_num, depth + 1); 
#endif
	}

	return(depth+1);	/* report hit to main routine */
}


static int
radmiss()  {
	return(0);
}

/*********** Eye Visibility Routines ************/
/*
 *  True if the intersection distance is >= distance back to the
 *  origin of the first ray in a chain.
 *  Called via isvisible on a hit.
 */
static int
hiteye( ap, PartHeadp )
struct application *ap;
struct partition *PartHeadp;
{
	register struct partition *pp;
	register struct hit *hitp;
	LOCAL vect_t work;
	LOCAL int cpu_num;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist > 0 )  break;
	if( pp == PartHeadp )  {
		bu_log("hiteye:  no hit out front?\n");
		return(1);
	}
	hitp = pp->pt_inhit;
	if( hitp->hit_dist >= INFINITY )  {
		bu_log("hiteye:  entry beyond infinity\n");
		return(1);
	}
	/* The current ray segment exits "in front" of me,
	 * find out where it went in.
	 * Check to see if eye is "inside" of the solid.
	 */
	if( hitp->hit_dist < -1.0e-10 )  {
		return(0);
	}

	if ( ap->a_resource == RESOURCE_NULL)
		cpu_num = 0;
	else
		cpu_num = ap->a_resource->re_cpu;

	VSUB2( work, firstray[cpu_num].r_pt, ap->a_ray.r_pt );
	if( hitp->hit_dist * hitp->hit_dist > MAGSQ(work) )
		return(1);
	else
		return(0);
}

/*
 *  Always true
 *  Called via isvisible on a miss.
 */
static int
hittrue( ap, PartHeadp )
struct application *ap;
struct partition *PartHeadp;
{
	return(1);
}

/*
 *  Determine whether the current hitpoint along a series of
 *  reflections is visible from the origin of the ray.
 *  (which is the location of our "point" eye for now)
 *
 *  Strategy: we shoot back toward the origin of the ray
 *   If we don't hit anything (i.e. miss) we made it.
 *   If we hit something we made it if that distance is greater
 *   than the distance back to the eye.
 */
static int
isvisible( ap, hitp, norm )
struct application *ap;
struct hit *hitp;
const vect_t	norm;
{
	LOCAL int cpu_num;
	LOCAL struct application sub_ap;
	LOCAL vect_t	rdir;

	if ( ap->a_resource == RESOURCE_NULL)
		cpu_num = 0;
	else
		cpu_num = ap->a_resource->re_cpu;

	/* compute the ray direction */
	VSUB2( rdir, firstray[cpu_num].r_pt, hitp->hit_point );
	VUNITIZE( rdir );
	if( VDOT(rdir, norm) < 0 )
		return( 0 );	/* backfacing */

	sub_ap = *ap;	/* struct copy */
	sub_ap.a_level = ap->a_level+1;
	sub_ap.a_onehit = 1;
	sub_ap.a_purpose = "sight";
	sub_ap.a_hit = hiteye;
	sub_ap.a_miss = hittrue;
	/*
	 * New origin is one unit in the ray direction in
	 * order to get away from the surface we intersected.
	 */
	VADD2( sub_ap.a_ray.r_pt, hitp->hit_point, rdir );
	VMOVE( sub_ap.a_ray.r_dir, rdir );

	return( rt_shootray( &sub_ap ) );
}

void application_init () {}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /cvs/brlcad/rt/viewscat.c,v 11.15 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.15
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.14 2003/09/27 01:11:25 morrison Exp $ (BRL)";
d29 5
a33 1
#include "conf.h"
@


11.14
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1985 by the United States Army.
d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.13 2002/06/21 21:07:21 morrison Exp $ (BRL)";
@


11.14.2.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.15 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.14.2.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.14.2.1 2004/02/12 19:37:14 erikg Exp $ (BRL)";
@


11.13
log
@invalid include fixed (was pointing to librad)
@
text
@d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.12 2001/04/05 19:36:04 morrison Exp $ (BRL)";
d236 1
a236 1
	if(rdebug&RDEBUG_HITS)  {
d251 1
a251 1
	if(rdebug&RDEBUG_HITS)  {
@


11.13.4.1
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header$ (BRL)";
d236 1
a236 1
	if(R_DEBUG&RDEBUG_HITS)  {
d251 1
a251 1
	if(R_DEBUG&RDEBUG_HITS)  {
@


11.13.6.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/viewscat.c,v 11.15 2004/02/02 17:39:39 morrison Exp $ (BRL)";
d236 1
a236 1
	if(R_DEBUG&RDEBUG_HITS)  {
d251 1
a251 1
	if(R_DEBUG&RDEBUG_HITS)  {
@


11.12
log
@updated SIGNED to signed
updated CONST to const
@
text
@d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.11 2000/08/17 02:41:42 mike Exp $ (BRL)";
d37 1
a37 1
#include "../librad/rad.h"
@


11.11
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d26 1
a26 1
static const char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.10 2000/07/25 16:39:49 butler Exp $ (BRL)";
d403 1
a403 1
CONST vect_t	norm;
@


11.10
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.9 1999/07/02 22:19:46 mike Exp $ (BRL)";
@


11.9
log
@
Removed dependence on compat4.h
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.8 1999/05/28 01:19:30 mike Exp $ (BRL)";
d36 1
a36 1
#include "./rdebug.h"
@


11.8
log
@
sed4
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.7 1998/09/22 00:21:02 mike Exp $ (BRL)";
d62 8
a69 8
	"%d",	1, "maxreflect",	(int)&numreflect,	FUNC_NULL,
	"%f",	1, "wavelength",	(int)&wavelength,	FUNC_NULL,
	"%f",	1, "xhpol",	(int)&xhpol,		FUNC_NULL,
	"%f",	1, "xvpol",	(int)&xvpol,		FUNC_NULL,
	"%f",	1, "rhpol",	(int)&rhpol,		FUNC_NULL,
	"%f",	1, "rvpol",	(int)&rvpol,		FUNC_NULL,
	"%f",	1, "epsilon",	(int)&epsilon,		FUNC_NULL,
	"",	0, (char *)0,	0,			FUNC_NULL
@


11.7
log
@Doesn't need material.h
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.6 1998/09/11 17:05:09 bparker Exp $ (BRL)";
d142 1
a142 1
		rt_log("Warning: maxreflect too large (%d), using %d\n",
d173 2
a174 2
	rt_log("aim point %f %f %f\n", aimpt[0], aimpt[1], aimpt[2]);
	rt_log("viewsize %f\n", viewsize);
d176 1
a176 1
	rt_log("backoff %f\n", backoff);
d210 1
a210 1
	rt_log("Az %2.1f Ele %2.1f totali %1.4E totalq %1.4E rcs %1.4E\n",
d232 1
a232 1
		rt_log("radhit:  no hit out front?\n");
d242 1
a242 1
		rt_log("radhit:  entry beyond infinity\n");
d270 1
a270 1
		rt_log(" debug: curvature flip\n");
d349 1
a349 1
		rt_log("hiteye:  no hit out front?\n");
d354 1
a354 1
		rt_log("hiteye:  entry beyond infinity\n");
@


11.6
log
@*- #define M_PI if not already defined
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewscat.c,v 11.5 1996/08/30 00:08:21 butler Exp $ (BRL)";
a35 1
#include "./material.h"
@


11.5
log
@structparse moved to libbu
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 11.4 1996/03/29 23:20:55 mike Exp butler $ (BRL)";
d39 4
@


11.4
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 11.3 1996/03/29 21:55:48 mike Exp mike $ (BRL)";
d58 1
a58 1
struct structparse view_parse[] = {
@


11.3
log
@Changed to use new curvature macro.
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 11.2 1995/12/06 17:57:53 pjt Exp mike $ (BRL)";
a247 5
	RT_HIT_NORM( hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );
	if( pp->pt_inflip ) {
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
	}

d264 1
a271 1
	VMOVE( rayp->norm, hitp->hit_normal );
d276 2
a277 2
	f = 2 * VDOT( to_eye, hitp->hit_normal );
	VSCALE( work, hitp->hit_normal, f );
d288 1
a288 1
		rayp->sight = isvisible( ap, hitp );
d397 1
a397 1
isvisible( ap, hitp )
d400 1
d414 1
a414 1
	if( VDOT(rdir, hitp->hit_normal) < 0 )
@


11.2
log
@Added a stub for application_init()
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 11.1 1995/01/04 10:01:32 mike Rel4_4 pjt $ (BRL)";
a250 1
		pp->pt_inflip = 0;
d268 2
a269 2
	rayp->surf = 1;	/* XXX no surface numbers in RT */
	RT_CURVE( &(rayp->curvature), hitp, pp->pt_inseg->seg_stp );
d271 1
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 10.2 94/08/11 02:47:39 gdurf Exp $ (BRL)";
d436 2
@


10.2
log
@Added include of conf.h
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 10.1 1991/10/12 06:42:24 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 1.5 91/02/20 00:51:36 mike Exp $ (BRL)";
d28 2
@


1.5
log
@Added new view-module interface called view_setup() which is used
for initializing material properties, lights, etc.
It compliments view_cleanup(), and finally removed knowledge of
the view.c materials (and all the shaders) from the RT "top half".
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 1.4 91/02/20 00:32:24 stay Exp $ (BRL)";
@


1.4
log
@More initializations, some #ifdef SAR code.
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 1.3 90/11/14 15:52:09 mike Exp $ (BRL)";
d184 1
@


1.3
log
@Added view-specific variable settings
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 1.2 90/11/14 15:43:44 mike Exp $ (BRL)";
d36 1
a36 1
#include "./scat.h"
d57 8
a64 9
	"%d",	"maxreflect",	(int)&numreflect,	FUNC_NULL,
	"%d",	"reflect",	(int)&r_reflections,	FUNC_NULL,
	"%f",	"wavelength",	(int)&wavelength,	FUNC_NULL,
	"%f",	"xhpol",	(int)&xhpol,		FUNC_NULL,
	"%f",	"xvpol",	(int)&xvpol,		FUNC_NULL,
	"%f",	"rhpol",	(int)&rhpol,		FUNC_NULL,
	"%f",	"rvpol",	(int)&rvpol,		FUNC_NULL,
	"%f",	"epsilon",	(int)&epsilon,		FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
d87 1
a87 1
static struct xray firstray[MAX_PSW];
d96 5
a100 6
fastf_t r_reflections;	/* Number of maximum reflections */
fastf_t wavelength;	/* Radar wavelength */
fastf_t xhpol;	/* Transmitter vertical polarization */
fastf_t xvpol;	/* Transmitter horizontal polarization */ 
fastf_t rhpol;	/* Receiver vertical polarization */
fastf_t rvpol;	/* Receiver horizontal polarization */
d119 3
d132 3
a135 2
	numreflect = r_reflections;

d160 16
d314 4
a317 1
		radar_physics( cpu_num, depth+1 );
@


1.2
log
@As part of "clean" command, call "view_cleanup()", to allow
viewing module the opportunity to clean up things like implicit
light sources, etc.
@
text
@d2 1
a2 1
 *			V I E W R A D
d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: /m/cad/rt/RCS/viewscat.c,v 1.1 90/11/14 15:39:20 mike Exp $ (BRL)";
d58 7
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
static char RCSppview[] = "@@(#)$Header: viewrad.c,v 9.1 89/05/19 06:00:01 mike Rel3_5 $ (BRL)";
d159 1
a159 1
/* end of processing */
@
