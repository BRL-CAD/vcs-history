head	11.62;
access;
symbols
	ansi-20040405-merged:11.52.2.2
	postmerge-20040405-ansi:11.60
	premerge-20040404-ansi:11.59
	postmerge-autoconf:11.59
	autoconf-freeze:11.56.2.4
	premerge-autoconf:11.59
	postmerge-20040315-windows:11.59
	premerge-20040315-windows:11.58
	windows-20040315-freeze:11.52.4.2
	autoconf-20031203:11.56.2.1
	autoconf-20031202:11.56
	autoconf-branch:11.56.0.2
	phong-branch:11.55.0.2
	photonmap-branch:11.53.0.2
	rel-6-1-DP:11.52
	windows-branch:11.52.0.4
	rel-6-0-2:11.50
	ansi-branch:11.52.0.2
	rel-6-0-1-branch:11.50.0.2
	hartley-6-0-post:11.51
	hartley-6-0-pre:11.50
	rel-6-0-1:11.50
	rel-6-0:11.49
	rel-5-4:11.34.2.1
	offsite-5-3-pre:11.43
	rel-5-3:11.34.2.1
	rel-5-2:11.34
	rel-5-1-branch:11.34.0.2
	rel-5-1:11.34
	rel-5-0:11.27
	rel-5-0-beta:11.27
	rel-4-5:11.24
	ctj-4-5-post:11.19
	ctj-4-5-pre:11.19
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.4
	rel-1-10:4.1
	rt-2:2.1
	rt:1.1;
locks; strict;
comment	@ * @;


11.62
date	2004.05.21.17.31.03;	author morrison;	state dead;
branches;
next	11.61;

11.61
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.60;

11.60
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.59;

11.59
date	2004.03.16.22.07.05;	author morrison;	state Exp;
branches;
next	11.58;

11.58
date	2003.12.01.16.24.49;	author morrison;	state Exp;
branches;
next	11.57;

11.57
date	2003.10.08.17.34.41;	author morrison;	state Exp;
branches;
next	11.56;

11.56
date	2003.09.27.01.11.25;	author morrison;	state Exp;
branches
	11.56.2.1;
next	11.55;

11.55
date	2003.09.09.15.14.48;	author justin;	state Exp;
branches;
next	11.54;

11.54
date	2003.09.05.15.22.18;	author justin;	state Exp;
branches;
next	11.53;

11.53
date	2002.12.31.14.42.34;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	2002.08.20.17.08.37;	author jra;	state Exp;
branches
	11.52.2.1
	11.52.4.1;
next	11.51;

11.51
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.50;

11.50
date	2002.06.10.13.06.46;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	2001.12.04.23.57.14;	author morrison;	state Exp;
branches;
next	11.48;

11.48
date	2001.10.12.18.39.35;	author butler;	state Exp;
branches;
next	11.47;

11.47
date	2001.07.09.17.38.29;	author morrison;	state Exp;
branches;
next	11.46;

11.46
date	2001.05.17.20.06.07;	author morrison;	state Exp;
branches;
next	11.45;

11.45
date	2001.05.16.21.38.18;	author morrison;	state Exp;
branches;
next	11.44;

11.44
date	2001.03.19.22.20.14;	author butler;	state Exp;
branches;
next	11.43;

11.43
date	2000.10.19.19.19.47;	author butler;	state Exp;
branches;
next	11.42;

11.42
date	2000.09.08.05.54.46;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	2000.09.07.19.51.51;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	2000.09.07.19.35.42;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	2000.09.06.22.13.46;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	2000.09.06.03.11.57;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	2000.09.06.03.10.01;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.08.17.02.41.34;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.07.25.16.39.47;	author butler;	state Exp;
branches;
next	11.34;

11.34
date	2000.05.18.21.10.09;	author jra;	state Exp;
branches
	11.34.2.1;
next	11.33;

11.33
date	2000.03.08.06.37.03;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.02.09.03.03.53;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.01.29.04.24.08;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.01.21.22.52.45;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	99.12.30.05.49.28;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	99.10.30.03.06.27;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	99.05.28.01.17.23;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	98.03.19.04.36.24;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	98.03.19.04.09.18;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	97.12.16.07.47.32;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	97.12.16.00.48.49;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	97.12.16.00.19.56;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	97.09.02.17.56.54;	author gdurf;	state Exp;
branches;
next	11.20;

11.20
date	97.08.26.06.49.04;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	97.07.08.15.29.30;	author gdurf;	state Exp;
branches;
next	11.18;

11.18
date	97.06.13.02.54.18;	author gdurf;	state Exp;
branches;
next	11.17;

11.17
date	97.03.07.06.12.28;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	97.01.10.15.31.57;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.01.09.20.52.57;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.01.09.16.13.51;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	96.11.01.15.41.35;	author pjt;	state Exp;
branches;
next	11.12;

11.12
date	96.08.31.08.55.36;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.08.31.03.19.22;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.29.02.14.51;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.08.27.03.38.08;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.12.06.17.34.05;	author pjt;	state Exp;
branches;
next	11.7;

11.7
date	95.11.07.14.31.31;	author adam;	state Exp;
branches;
next	11.6;

11.6
date	95.08.25.21.59.41;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.07.18.02.54.25;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.06.13.21.00.07;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.03.20.11.36.30;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.03.01.03.43.29;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.40;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.12.21.14.43.18;	author stay;	state Exp;
branches;
next	10.5;

10.5
date	94.11.24.02.56.24;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.17.23.00.58;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.17.36.07;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.00.29.43;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.45;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.04.08.23.33.56;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.03.11.23.08.18;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.01.24.15.23.12;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.10.21.48.02;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.22.01.36.40;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.22.01.34.55;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.19.06.38.11;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.13.16.20.06;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.11.21.52.18;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.11.16.55.54;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.11.27.00.40.55;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.14;	author mike;	state Rel3_5;
branches;
next	8.18;

8.18
date	89.04.30.20.43.44;	author mike;	state Exp;
branches;
next	8.17;

8.17
date	89.04.29.09.44.18;	author mike;	state Exp;
branches;
next	8.16;

8.16
date	89.04.12.01.18.08;	author mike;	state Exp;
branches;
next	8.15;

8.15
date	89.04.10.21.15.50;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.04.03.20.50.20;	author mike;	state Exp;
branches;
next	8.13;

8.13
date	89.03.19.23.51.40;	author mike;	state Exp;
branches;
next	8.12;

8.12
date	89.03.15.16.26.42;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.03.10.04.47.08;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.03.10.04.33.13;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.03.08.19.13.59;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.02.14.00.29.01;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.01.25.04.14.33;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.01.20.03.20.13;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.09.05.11.41;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.01.02.18.25.22;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.27.16.45.52;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.02.45.58;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.08;	author mike;	state Rel3_0;
branches;
next	7.17;

7.17
date	88.09.19.22.44.59;	author mike;	state Exp;
branches;
next	7.16;

7.16
date	88.09.17.08.38.08;	author mike;	state Exp;
branches;
next	7.15;

7.15
date	88.09.17.07.08.56;	author mike;	state Exp;
branches;
next	7.14;

7.14
date	88.09.16.23.59.31;	author phil;	state Exp;
branches;
next	7.13;

7.13
date	88.08.20.07.20.01;	author phil;	state Exp;
branches;
next	7.12;

7.12
date	88.08.09.17.52.07;	author phil;	state Exp;
branches;
next	7.11;

7.11
date	88.06.20.20.22.06;	author mike;	state Exp;
branches;
next	7.10;

7.10
date	88.06.16.02.57.52;	author phil;	state Exp;
branches;
next	7.9;

7.9
date	88.06.16.02.50.44;	author phil;	state Exp;
branches;
next	7.8;

7.8
date	88.05.20.03.40.44;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.03.01.23.12.02;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.02.27.03.09.12;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.01.25.23.43.06;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.01.22.21.10.16;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.01.22.21.04.13;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.15.14.51.28;	author stay;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.09;	author mike;	state Rel;
branches;
next	6.6;

6.6
date	87.09.20.09.47.37;	author mike;	state Exp;
branches;
next	6.5;

6.5
date	87.09.04.03.42.34;	author mike;	state Exp;
branches;
next	6.4;

6.4
date	87.09.03.23.04.37;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.09.03.01.30.32;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.03.00.53.04;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.59.03;	author mike;	state Rel;
branches;
next	5.3;

5.3
date	87.07.09.03.30.46;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.27.03.51.51;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.15.05;	author mike;	state Rel;
branches;
next	4.19;

4.19
date	87.05.30.07.03.57;	author mike;	state Exp;
branches;
next	4.18;

4.18
date	87.05.28.21.53.05;	author mike;	state Exp;
branches;
next	4.17;

4.17
date	87.05.28.21.00.10;	author mike;	state Exp;
branches;
next	4.16;

4.16
date	87.04.10.07.15.06;	author mike;	state Exp;
branches;
next	4.15;

4.15
date	87.04.10.07.03.38;	author mike;	state Exp;
branches;
next	4.14;

4.14
date	87.04.01.02.34.36;	author mike;	state Exp;
branches;
next	4.13;

4.13
date	87.03.28.03.02.13;	author mike;	state Exp;
branches;
next	4.12;

4.12
date	87.03.23.23.47.00;	author mike;	state Exp;
branches;
next	4.11;

4.11
date	87.03.19.05.01.20;	author mike;	state Exp;
branches;
next	4.10;

4.10
date	87.03.19.03.05.53;	author mike;	state Exp;
branches;
next	4.9;

4.9
date	87.03.19.01.22.51;	author mike;	state Exp;
branches;
next	4.8;

4.8
date	87.03.18.23.45.04;	author mike;	state Exp;
branches;
next	4.7;

4.7
date	87.03.17.22.30.14;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.03.17.20.19.08;	author mike;	state Exp;
branches;
next	4.5;

4.5
date	87.03.16.21.02.07;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.02.13.00.02.00;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.01.17.04.10.47;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.07.07.14.55;	author mike;	state Rel1;
branches;
next	4.1;

4.1
date	86.12.29.03.48.38;	author mike;	state Rel1;
branches;
next	3.32;

3.32
date	86.12.29.01.57.18;	author mike;	state Exp;
branches;
next	3.31;

3.31
date	86.12.28.16.55.48;	author mike;	state Exp;
branches;
next	3.30;

3.30
date	86.12.24.08.57.01;	author mike;	state Exp;
branches;
next	3.29;

3.29
date	86.12.24.08.30.58;	author mike;	state Exp;
branches;
next	3.28;

3.28
date	86.12.18.16.01.55;	author mike;	state Exp;
branches;
next	3.27;

3.27
date	86.12.05.23.57.41;	author mike;	state Exp;
branches;
next	3.26;

3.26
date	86.11.26.04.02.36;	author mike;	state Exp;
branches;
next	3.25;

3.25
date	86.11.25.04.07.51;	author mike;	state Exp;
branches;
next	3.24;

3.24
date	86.11.15.06.46.39;	author mike;	state Exp;
branches;
next	3.23;

3.23
date	86.11.10.21.53.18;	author mike;	state Exp;
branches;
next	3.22;

3.22
date	86.11.07.08.00.58;	author mike;	state Exp;
branches;
next	3.21;

3.21
date	86.11.07.01.47.12;	author mike;	state Exp;
branches;
next	3.20;

3.20
date	86.10.28.23.25.25;	author mike;	state Exp;
branches;
next	3.19;

3.19
date	86.10.27.04.52.20;	author mike;	state Exp;
branches;
next	3.18;

3.18
date	86.10.26.18.37.50;	author mike;	state Exp;
branches;
next	3.17;

3.17
date	86.10.12.00.20.44;	author mike;	state Exp;
branches;
next	3.16;

3.16
date	86.10.12.00.04.26;	author mike;	state Exp;
branches;
next	3.15;

3.15
date	86.10.11.01.49.53;	author mike;	state Exp;
branches;
next	3.14;

3.14
date	86.10.11.00.11.55;	author mike;	state Exp;
branches;
next	3.13;

3.13
date	86.09.23.17.06.39;	author mike;	state Exp;
branches;
next	3.12;

3.12
date	86.08.12.05.50.53;	author mike;	state Exp;
branches;
next	3.11;

3.11
date	86.08.12.04.29.41;	author mike;	state Exp;
branches;
next	3.10;

3.10
date	86.08.07.20.42.55;	author mike;	state Exp;
branches;
next	3.9;

3.9
date	86.08.06.05.38.58;	author mike;	state Exp;
branches;
next	3.8;

3.8
date	86.07.31.05.37.45;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.07.29.20.22.32;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.07.24.06.05.23;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.22.04.32.20;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.19.04.39.09;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.18.00.22.25;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.17.18.45.31;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.17.21.13.54;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.21;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	86.06.09.21.49.13;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	86.06.09.20.41.53;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	86.06.05.23.15.49;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	85.11.20.17.06.15;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	85.09.24.18.35.05;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	85.09.18.01.27.12;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	85.09.15.09.17.56;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.09.15.08.46.15;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.09.11.23.50.16;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.09.11.20.23.13;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.09.11.19.40.09;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.09.11.01.17.59;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.09.10.01.06.07;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.10.00.33.30;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.06.02.29.25;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.06.08;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	85.07.30.05.55.06;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	85.07.30.02.02.41;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	85.06.05.00.26.16;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	85.06.04.23.24.38;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	85.03.25.12.00.59;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	85.03.25.11.46.46;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	85.02.07.19.19.36;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	84.11.30.04.04.13;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	84.11.29.07.04.33;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	84.11.27.06.59.47;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	84.11.24.02.48.46;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	84.11.23.20.54.28;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	84.11.20.20.14.43;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	84.11.16.23.58.08;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	84.11.16.23.49.49;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	84.11.16.06.28.56;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	84.11.15.21.47.50;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	84.10.19.01.57.55;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	84.10.19.01.38.26;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	84.10.19.00.07.46;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	84.09.06.03.29.22;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.08.28.03.08.02;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.08.24.01.04.26;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.08.22.03.19.12;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.08.21.01.18.58;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.05.05.04.43.06;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.05.04.09.14.50;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.05.03.06.55.17;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.05.02.05.09.57;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.05.01.06.39.53;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.04.26.05.47.52;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.04.26.05.41.30;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.04.18.02.20.32;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.04.02.16.42.12;	author mike;	state Exp;
branches;
next	;

11.34.2.1
date	2000.11.28.00.04.30;	author jra;	state Exp;
branches;
next	;

11.52.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	11.52.2.2;

11.52.2.2
date	2004.03.17.21.22.57;	author morrison;	state Exp;
branches;
next	;

11.52.4.1
date	2002.09.26.23.04.15;	author morrison;	state Exp;
branches;
next	11.52.4.2;

11.52.4.2
date	2004.03.11.23.48.06;	author morrison;	state Exp;
branches;
next	;

11.56.2.1
date	2003.12.03.16.25.43;	author erikg;	state Exp;
branches;
next	11.56.2.2;

11.56.2.2
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	11.56.2.3;

11.56.2.3
date	2004.03.15.14.08.06;	author erikg;	state Exp;
branches;
next	11.56.2.4;

11.56.2.4
date	2004.03.18.18.10.32;	author erikg;	state Exp;
branches;
next	;


desc
@Ray Trace mainline
@


11.62
log
@moved to src/rt/
@
text
@/*
 *			M A I N . C
 *
 *  Ray Tracing User Interface (RTUIF) main program, using LIBRT library.
 *
 *  Invoked by MGED for quick pictures.
 *  Is linked with each of several "back ends":
 *	view.c, viewpp.c, viewray.c, viewcheck.c, etc
 *  to produce different executable programs:
 *	rt, rtpp, rtray, rtcheck, etc.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985,1987 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/main.c,v 11.61 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <ctype.h>
#include <signal.h>
#include <math.h>
#ifndef WIN32
#include <unistd.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "fb.h"
#include "./ext.h"
#include "rtprivate.h"
#include "../librt/debug.h"

#ifdef WIN32
#include <fcntl.h>
#endif

extern char	usage[];

extern int	rdebug;			/* RT program debugging */
int		rt_verbosity = -1;	/* blather incesantly by default */

/***** Variables shared with viewing model *** */
FBIO		*fbp = FBIO_NULL;	/* Framebuffer handle */
FILE		*outfp = NULL;		/* optional pixel output file */
int		output_is_binary = 1;	/* !0 means output file is binary */
mat_t		view2model;
mat_t		model2view;
/***** end of sharing with viewing model *****/

/***** variables shared with worker() ******/
struct application ap;
vect_t		left_eye_delta;
int		report_progress;	/* !0 = user wants progress report */
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
extern int	incr_mode;		/* !0 for incremental resolution */
extern int	incr_nlevel;		/* number of levels */
extern int	npsw;			/* number of worker PSWs to run */
/***** end variables shared with worker() *****/

/***** variables shared with do.c *****/
extern int	pix_start;		/* pixel to start at */
extern int	pix_end;		/* pixel to end at */
extern int	nobjs;			/* Number of cmd-line treetops */
extern char	**objtab;		/* array of treetop strings */
char		*beginptr;		/* sbrk() at start of program */
long		n_malloc;		/* Totals at last check */
long		n_free;
long		n_realloc;
extern int	matflag;		/* read matrix from stdin */
extern int	desiredframe;		/* frame to start at */
extern int	curframe;		/* current frame number,
					 * also shared with view.c */
extern char	*outputfile;		/* name of base of output file */
extern int	interactive;		/* human is watching results */
/***** end variables shared with do.c *****/


extern fastf_t	rt_dist_tol;		/* Value for rti_tol.dist */
extern fastf_t	rt_perp_tol;		/* Value for rti_tol.perp */
extern char	*framebuffer;		/* desired framebuffer */

extern struct command_tab	rt_cmdtab[];

extern char	version[];		/* From vers.c */

extern struct resource	resource[];	/* from opt.c */

int	save_overlaps=0;	/* flag for setting rti_save_overlaps */

/*
 *			S I G I N F O _ H A N D L E R
 */
void
siginfo_handler(int arg)
{
	report_progress = 1;
#ifdef SIGUSR1
	(void)signal( SIGUSR1, siginfo_handler );
#endif
#ifdef SIGINFO
	(void)signal( SIGINFO, siginfo_handler );
#endif
}

/*
 *			M E M O R Y _ S U M M A R Y
 */
void
memory_summary(void)
{
#ifdef HAVE_SBRK_DECL
	if (rt_verbosity & VERBOSE_STATS)  {
		long	mdelta = bu_n_malloc - n_malloc;
		long	fdelta = bu_n_free - n_free;
		fprintf(stderr,
			"Additional mem=%ld., #malloc=%ld, #free=%ld, #realloc=%ld (%ld retained)\n",
			(long)((char *)sbrk(0)-beginptr),
			mdelta,
			fdelta,
			bu_n_realloc - n_realloc,
			mdelta - fdelta);
	}
	beginptr = (char *) sbrk(0);
#endif
	n_malloc = bu_n_malloc;
	n_free = bu_n_free;
	n_realloc = bu_n_realloc;
}

/*
 *			M A I N
 */
int main(int argc, char **argv)
{
	static struct rt_i *rtip;
	char *title_file, *title_obj;	/* name of file and first object */
	register int	x;
	char idbuf[132];		/* First ID record info */
	void	application_init();
	struct bu_vls	times;
	int i;

#ifdef WIN32
	_fmode = _O_BINARY;
#endif

	bu_setlinebuf( stderr );

#ifdef HAVE_SBRK_DECL
	beginptr = (char *) sbrk(0);
#endif
	azimuth = 35.0;			/* GIFT defaults */
	elevation = 25.0;

	AmbientIntensity=0.4;
	background[0] = background[1] = 0.0;
	background[2] = 1.0/255.0; /* slightly non-black */

	/* Before option processing, get default number of processors */
	npsw = bu_avail_cpus();		/* Use all that are present */
	if( npsw > DEFAULT_PSW )  npsw = DEFAULT_PSW;
	if( npsw > MAX_PSW )  npsw = MAX_PSW;

	/* Before option processing, do application-specific initialization */
	RT_APPLICATION_INIT( &ap );
	application_init();

	/* Process command line options */
	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit(1);
	}
	/* Identify the versions of the libraries we are using. */
	if (rt_verbosity & VERBOSE_LIBVERSIONS) {
		(void)fprintf(stderr, "%s%s%s%s\n",
			version+5,
			rt_version+5,
			bn_version+5,
			bu_version+5
		      );	/* +5 to skip @@(#) */
	}
#ifdef PRODUCTION
	(void)fprintf(stderr, "Running with production compilation\n");
#endif

	/* Identify what host we're running on */
	if (rt_verbosity & VERBOSE_LIBVERSIONS) {
		char	hostname[512];
		hostname[0] = '\0';
#ifndef WIN32
		if( gethostname( hostname, sizeof(hostname) ) >= 0 &&
		    hostname[0] != '\0' )
			(void)fprintf(stderr, "Running on %s\n", hostname);
#else
	sprintf(hostname,"Microsoft Windows");
	(void)fprintf(stderr, "Running on %s\n", hostname);
#endif
	}

	if( bu_optind >= argc )  {
		fprintf(stderr,"rt:  MGED database not specified\n");
		(void)fputs(usage, stderr);
		exit(1);
	}

	if (rpt_overlap)
		ap.a_logoverlap = ((void (*)())0);
	else
		ap.a_logoverlap = rt_silent_logoverlap;

	/* If user gave no sizing info at all, use 512 as default */
	if( width <= 0 && cell_width <= 0 )
		width = 512;
	if( height <= 0 && cell_height <= 0 )
		height = 512;

	if( sub_grid_mode ) {
		/* check that we have a legal subgrid */
		if( sub_xmax >= width || sub_ymax >= height ) {
			fprintf( stderr, "rt: illegal values for subgrid %d,%d,%d,%d\n", 
				 sub_xmin, sub_ymin, sub_xmax, sub_ymax );
			fprintf( stderr, "\tFor a %d X %d image, the subgrid must be within 0,0,%d,%d\n",
				 width, height, width-1, height-1 );
			exit( 1 );
		}
	}

	if( incr_mode )  {
		x = height;
		if( x < width )  x = width;
		incr_nlevel = 1;
		while( (1<<incr_nlevel) < x )
			incr_nlevel++;
		height = width = 1<<incr_nlevel;
		if (rt_verbosity & VERBOSE_INCREMENTAL)
			fprintf(stderr, 
			    "incremental resolution, nlevels = %d, width=%d\n",
			    incr_nlevel, width);
	}

	/*
	 *  Handle parallel initialization, if applicable.
	 */
#ifndef PARALLEL
	npsw = 1;			/* force serial */
#endif
	if( npsw < 0 )  {
		/* Negative number means "all but" npsw */
		npsw = bu_avail_cpus() + npsw;
	}
	if( npsw > MAX_PSW )  npsw = MAX_PSW;
	if( npsw > 1 )  {
	    rt_g.rtg_parallel = 1;
	    if (rt_verbosity & VERBOSE_MULTICPU)
	        fprintf(stderr,"Planning to run with %d processors\n", npsw );
	} else
		rt_g.rtg_parallel = 0;

	/* Initialize parallel processor support */
	bu_semaphore_init( RT_SEM_LAST );

	/*
	 *  Do not use bu_log() or bu_malloc() before this point!
	 */

	if( bu_debug )  {
		bu_printb( "libbu bu_debug", bu_debug, BU_DEBUG_FORMAT );
		bu_log("\n");
	}

	if( RT_G_DEBUG )  {
		bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
		bu_log("\n");
	}
	if( rdebug )  {
		bu_printb( "rt rdebug", rdebug, RDEBUG_FORMAT );
		bu_log("\n");
	}

	/* We need this to run rt_dirbuild */
	rt_init_resource( &rt_uniresource, MAX_PSW, NULL );
	bn_rand_init( rt_uniresource.re_randptr, 0 );

	title_file = argv[bu_optind];
	title_obj = argv[bu_optind+1];
	nobjs = argc - bu_optind - 1;
	objtab = &(argv[bu_optind+1]);

	if( nobjs <= 0 )  {
		bu_log("%s: no objects specified -- raytrace aborted\n", argv[0]);
		exit(1);
	}

	/* Echo back the command line arugments as given, in 3 Tcl commands */
	if (rt_verbosity & VERBOSE_MODELTITLE) {
		struct bu_vls str;
		bu_vls_init(&str);
		bu_vls_from_argv( &str, bu_optind, argv );
		bu_vls_strcat( &str, "\nopendb "  );
		bu_vls_strcat( &str, title_file );
		bu_vls_strcat( &str, ";\ntree " );
		bu_vls_from_argv( &str,
			nobjs <= 16 ? nobjs : 16,
			argv+bu_optind+1 );
		if( nobjs > 16 )
			bu_vls_strcat( &str, " ...");
		else
			bu_vls_putc( &str, ';' );
		bu_log("%s\n", bu_vls_addr(&str) );
		bu_vls_free(&str);
	}

	/* Build directory of GED database */
	bu_vls_init( &times );
	rt_prep_timer();
	if( (rtip=rt_dirbuild(title_file, idbuf, sizeof(idbuf))) == RTI_NULL ) {
		bu_log("rt:  rt_dirbuild(%s) failure\n", title_file);
		exit(2);
	}
	ap.a_rt_i = rtip;
	(void)rt_get_timer( &times, NULL );
	if (rt_verbosity & VERBOSE_MODELTITLE)
		bu_log("db title:  %s\n", idbuf);
	if (rt_verbosity & VERBOSE_STATS)
		bu_log("DIRBUILD: %s\n", bu_vls_addr(&times) );
	bu_vls_free( &times );
	memory_summary();

	/* Copy values from command line options into rtip */
	rtip->rti_space_partition = space_partition;
	rtip->rti_nugrid_dimlimit = nugrid_dimlimit;
	rtip->rti_nu_gfactor = nu_gfactor;
	rtip->useair = use_air;
	rtip->rti_save_overlaps = save_overlaps;
	if( rt_dist_tol > 0 )  {
		rtip->rti_tol.dist = rt_dist_tol;
		rtip->rti_tol.dist_sq = rt_dist_tol * rt_dist_tol;
	}
	if( rt_perp_tol > 0 )  {
		rtip->rti_tol.perp = rt_perp_tol;
		rtip->rti_tol.para = 1 - rt_perp_tol;
	}
	if (rt_verbosity & VERBOSE_TOLERANCE)
		rt_pr_tol( &rtip->rti_tol );

	/* before view_init */
	if( outputfile && strcmp( outputfile, "-") == 0 )
		outputfile = (char *)0;

	/* 
	 *  Initialize application.
	 *  Note that width & height may not have been set yet,
	 *  since they may change from frame to frame.
	 */
	if( view_init( &ap, title_file, title_obj, outputfile!=(char *)0 ) != 0 )  {
		/* Framebuffer is desired */
		register int xx, yy;
		int	zoom;

		/* Ask for a fb big enough to hold the image, at least 512. */
		/* This is so MGED-invoked "postage stamps" get zoomed up big enough to see */
		xx = yy = 512;
		if( width > xx || height > yy )  {
			xx = width;
			yy = height;
		}
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		fbp = fb_open( framebuffer, xx, yy );
		bu_semaphore_release( BU_SEM_SYSCALL );
		if( fbp == FBIO_NULL )  {
			fprintf(stderr,"rt:  can't open frame buffer\n");
			exit(12);
		}

		bu_semaphore_acquire( BU_SEM_SYSCALL );
		/* If fb came out smaller than requested, do less work */
		if( fb_getwidth(fbp) < width )  width = fb_getwidth(fbp);
		if( fb_getheight(fbp) < height )  height = fb_getheight(fbp);

		/* If the fb is lots bigger (>= 2X), zoom up & center */
		if( width > 0 && height > 0 )  {
			zoom = fb_getwidth(fbp)/width;
			if( fb_getheight(fbp)/height < zoom )
				zoom = fb_getheight(fbp)/height;
		} else {
			zoom = 1;
		}
		(void)fb_view( fbp, width/2, height/2,
			zoom, zoom );
		bu_semaphore_release( BU_SEM_SYSCALL );
	} else if( outputfile == (char *)0 )  {
		/* If not going to framebuffer, or to a file, then use stdout */
		if( outfp == NULL )  outfp = stdout;
		/* output_is_binary is changed by view_init, as appropriate */
		if( output_is_binary && isatty(fileno(outfp)) )  {
			fprintf(stderr,"rt:  attempting to send binary output to terminal, aborting\n");
			exit(14);
		}
	}

	/*
	 *  Initialize all the per-CPU memory resources.
	 *  The number of processors can change at runtime, init them all.
	 */
	for( i=0; i < MAX_PSW; i++ )  {
		rt_init_resource( &resource[i], i, rtip );
		bn_rand_init( resource[i].re_randptr, i );
	}
	memory_summary();

#ifdef SIGUSR1
	(void)signal( SIGUSR1, siginfo_handler );
#endif
#ifdef SIGINFO
	(void)signal( SIGINFO, siginfo_handler );
#endif

	if( !matflag )  {
		def_tree( rtip );		/* Load the default trees */
		do_ae( azimuth, elevation );
		(void)do_frame( curframe );
	} else if( !isatty(fileno(stdin)) && old_way( stdin ) )  {
		; /* All is done */
	} else {
		register char	*buf;
		register int	ret;
		/*
		 * New way - command driven.
		 * Process sequence of input commands.
		 * All the work happens in the functions
		 * called by rt_do_cmd().
		 */
		while( (buf = rt_read_cmd( stdin )) != (char *)0 )  {
			if( R_DEBUG&RDEBUG_PARSE )
				fprintf(stderr,"cmd: %s\n", buf );
			ret = rt_do_cmd( rtip, buf, rt_cmdtab );
			bu_free( buf, "rt_read_cmd command buffer" );
			if( ret < 0 )
				break;
		}
		if( curframe < desiredframe )  {
			fprintf(stderr,
				"rt:  Desired frame %d not reached, last was %d\n",
				desiredframe, curframe);
		}
	}

	/* Release the framebuffer, if any */
	if( fbp != FBIO_NULL )
		fb_close(fbp);

	return(0);
}
@


11.61
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/main.c,v 11.60 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.60
log
@merge of ansi-6-0-branch into head
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.59
log
@merge of windows-6-0-branch into head
@
text
@d114 1
a114 2
siginfo_handler( arg )
int	arg;
d129 1
a129 1
memory_summary()
@


11.58
log
@use RT_G_DEBUG define for if statements
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.57 2003/10/08 17:34:41 morrison Exp $ (BRL)";
d37 1
d39 1
d52 4
d164 4
d211 1
d215 4
@


11.57
log
@Fix bug where pixels that have no blue component are off by one.
Added initialization of background to desired color in front-end now that background is provided by the liboptical.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.56 2003/09/27 01:11:25 morrison Exp $ (BRL)";
d277 2
a278 2
	if( rt_g.debug )  {
		bu_printb( "librt RT_G_DEBUG", rt_g.debug, DEBUG_FORMAT );
@


11.56
log
@updated rdebug var usages to the R_DEBUG define for performance during production builds; moved certain shared globals to liboptical
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.55 2003/09/09 15:14:48 justin Exp $ (BRL)";
d167 2
@


11.56.2.1
log
@updates from HEAD, part 1
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.58 2003/12/01 16:24:49 morrison Exp $ (BRL)";
a166 2
	background[0] = background[1] = 0.0;
	background[2] = 1.0/255.0; /* slightly non-black */
d275 2
a276 2
	if( RT_G_DEBUG )  {
		bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
@


11.56.2.2
log
@merge from HEAD
@
text
@@


11.56.2.3
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.56.2.2 2004/02/12 19:37:13 erikg Exp $ (BRL)";
@


11.56.2.4
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
a36 1
#ifndef WIN32
a37 1
#endif
a49 4
#ifdef WIN32
#include <fcntl.h>
#endif

a157 4
#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a200 1
#ifndef WIN32
a203 4
#else
	sprintf(hostname,"Microsoft Windows");
	(void)fprintf(stderr, "Running on %s\n", hostname);
#endif
@


11.55
log
@Migrated pixmap for black pixel rendering to do.c
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.54 2003/09/05 15:22:18 justin Exp $ (BRL)";
d52 1
a52 1
int		rdebug;			/* RT program debugging (not library) */
d166 2
d438 1
a438 1
			if( rdebug&RDEBUG_PARSE )
@


11.54
log
@updated to support re-rendering of black pixels (added pixmap)
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.53 2002/12/31 14:42:34 jra Exp $ (BRL)";
a56 1
unsigned	char	*pixmap = NULL;	/* Pixel Map for rerendering of black pixels */
a218 5
	/* Allocate data for pixel map for rerendering of black pixels */
	pixmap= (unsigned char*)malloc(sizeof(RGBpixel)*width*height);
	for (i= 0; i < width*height*sizeof(RGBpixel); i++)
		pixmap[i]= 0;

a453 1
	free(pixmap);
@


11.53
log
@Moved overlap reporting settings to main so that ALL rt codes use it.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.52 2002/08/20 17:08:37 jra Exp $ (BRL)";
d57 1
d220 5
d460 1
@


11.52
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.50 2002/06/10 13:06:46 jra Exp $ (BRL)";
d207 5
@


11.52.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.52 2002/08/20 17:08:37 jra Exp $ (BRL)";
a36 1
#ifndef WIN32
a37 1
#endif
a49 4
#ifdef WIN32
#include <fcntl.h>
#endif

a157 4
#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a196 1
#ifndef WIN32
a199 4
#else
	sprintf(hostname,"Microsoft Windows");
	(void)fprintf(stderr, "Running on %s\n", hostname);
#endif
@


11.52.4.2
log
@sync to HEAD...
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/main.c,v 11.52.4.1 2002/09/26 23:04:15 morrison Exp $ (BRL)";
d58 1
a58 1
extern int	rdebug;			/* RT program debugging */
a175 4
	AmbientIntensity=0.4;
	background[0] = background[1] = 0.0;
	background[2] = 1.0/255.0; /* slightly non-black */

a222 5
	if (rpt_overlap)
		ap.a_logoverlap = ((void (*)())0);
	else
		ap.a_logoverlap = rt_silent_logoverlap;

d283 2
a284 2
	if( RT_G_DEBUG )  {
		bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
d446 1
a446 1
			if( R_DEBUG&RDEBUG_PARSE )
@


11.52.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.52 2002/08/20 17:08:37 jra Exp $ (BRL)";
d108 2
a109 1
siginfo_handler(int arg)
d124 1
a124 1
memory_summary(void)
@


11.52.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
a36 1
#ifndef WIN32
a37 1
#endif
a49 4
#ifdef WIN32
#include <fcntl.h>
#endif

d52 1
a52 1
extern int	rdebug;			/* RT program debugging */
a156 4
#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a164 4
	AmbientIntensity=0.4;
	background[0] = background[1] = 0.0;
	background[2] = 1.0/255.0; /* slightly non-black */

a195 1
#ifndef WIN32
a198 4
#else
	sprintf(hostname,"Microsoft Windows");
	(void)fprintf(stderr, "Running on %s\n", hostname);
#endif
a206 5
	if (rpt_overlap)
		ap.a_logoverlap = ((void (*)())0);
	else
		ap.a_logoverlap = rt_silent_logoverlap;

d267 2
a268 2
	if( RT_G_DEBUG )  {
		bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
d430 1
a430 1
			if( R_DEBUG&RDEBUG_PARSE )
@


11.51
log
@Converted from K&R to ANSI C - RFH
@
text
@d108 2
a109 1
siginfo_handler(int arg)
d124 1
a124 1
memory_summary(void)
@


11.50
log
@rt family of codes now check if specified subgrid is leagal
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.49 2001/12/04 23:57:14 morrison Exp $ (BRL)";
d108 1
a108 2
siginfo_handler( arg )
int	arg;
d123 1
a123 1
memory_summary()
@


11.49
log
@added notification that the raytrace was aborted if no objects are displayed
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.48 2001/10/12 18:39:35 butler Exp $ (BRL)";
d213 11
@


11.48
log
@forced rt_g.debug printing for certain cases, updated the "vdraw" debugging
output to match current syntax.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.47 2001/07/09 17:38:29 morrison Exp $ (BRL)";
d276 1
a276 1
		bu_log("%s: no objects specified\n", argv[0]);
@


11.47
log
@Fixed a minor typo in conf.h with HAVE_SBRK define.  Should have been a HAVE_SBRK_DECL define.
Most references checked whether HAVE_SBRK_DECL is defined (which didn't exist), and it is a declaration check anyways.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.46 2001/05/17 20:06:07 morrison Exp $ (BRL)";
d257 2
a258 2
	if( RT_G_DEBUG )  {
		bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
@


11.46
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.45 2001/05/16 21:38:18 morrison Exp $ (BRL)";
d126 1
a126 1
#ifdef HAVE_SBRK
d160 1
a160 1
#ifdef HAVE_SBRK
@


11.45
log
@PRODUCTION optimizations
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.44 2001/03/19 22:20:14 butler Exp $ (BRL)";
d257 2
a258 2
	if( rt_g.debug )  {
		bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
@


11.44
log
@patches to merge 5.3 into 6.0
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /d/CVS/brlcad/rt/main.c,v 11.43 2000/10/19 19:19:47 butler Exp $ (BRL)";
d189 4
@


11.43
log
@Changes to compile under RedHat 7.0
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.42 2000/09/08 05:54:46 mike Exp $ (BRL)";
d172 1
@


11.42
log
@
Modified tree routines to take resource pointer.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.41 2000/09/07 19:51:51 mike Exp $ (BRL)";
d31 3
@


11.41
log
@
Print number of malloc blocks retained.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.40 2000/09/07 19:35:42 mike Exp $ (BRL)";
d258 4
a382 2
	rt_init_resource( &rt_uniresource, 0 );
	bn_rand_init( rt_uniresource.re_randptr, 0 );
d384 1
a384 1
		rt_init_resource( &resource[i], i );
@


11.40
log
@
Broke out memory_summary() routine, added malloc/free logging.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.39 2000/09/06 22:13:46 mike Exp $ (BRL)";
d118 1
d125 2
d128 1
a128 1
			"Additional mem=%ld., #malloc=%ld, #free=%ld, #realloc=%ld\n",
d130 4
a133 3
			bu_n_malloc - n_malloc,
			bu_n_free - n_free,
			bu_n_realloc - n_realloc );
@


11.39
log
@
Log the actual invocation of RT, so it can be reconstructed later
from the log file.
Printed as 3 Tcl commands.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.38 2000/09/06 03:11:57 mike Exp $ (BRL)";
d77 3
d117 20
d297 1
a297 7

#ifdef HAVE_SBRK
	if (rt_verbosity & VERBOSE_STATS)
		bu_log("Additional dynamic memory used=%ld. bytes\n",
			(long)((char *)sbrk(0)-beginptr) );
	beginptr = (char *) sbrk(0);
#endif
d381 1
a381 7

#ifdef HAVE_SBRK
	if (rt_verbosity & VERBOSE_STATS)
		fprintf(stderr,"initial dynamic memory use=%ld.\n",
			(long)((char *)sbrk(0)-beginptr) );
	beginptr = (char *) sbrk(0);
#endif
@


11.38
log
@
It helps to record all the statistics.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.37 2000/09/06 03:10:01 mike Exp $ (BRL)";
d239 19
@


11.37
log
@
Added additional logging for Chris.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.36 2000/08/17 02:41:34 mike Exp $ (BRL)";
d249 1
@


11.36
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.35 2000/07/25 16:39:47 butler Exp $ (BRL)";
d125 1
d242 2
d251 10
@


11.35
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.34 2000/05/18 21:10:09 jra Exp $ (BRL)";
@


11.34
log
@
Added "save_overlaps" as a settable variable.
It value is given to rti_save_overlaps in do.c.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.33 2000/03/08 06:37:03 mike Exp $ (BRL)";
d34 1
d44 1
a44 1
#include "./rdebug.h"
d118 1
a118 3
main(argc, argv)
int argc;
char **argv;
@


11.34.2.1
log
@Fixed bug where an escaping ray after refraction would see a sliver of the
glass that it was supposed to escape from. Uses new "a_flag" field of
application structure.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.34 2000/05/18 21:10:09 jra Exp $ (BRL)";
a141 1
	RT_APPLICATION_INIT( &ap );
@


11.33
log
@
Added support for ^T on FreeBSD, and SIGUSR1 everywhere,
to report progress of ray-tracing.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.32 2000/02/09 03:03:53 mike Exp $ (BRL)";
d95 2
d255 1
@


11.32
log
@
Indicate in the logfile what host RT is running on.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.31 2000/01/29 04:24:08 mike Exp $ (BRL)";
d32 1
d62 1
d96 17
d335 7
@


11.31
log
@
As a favor to the library, init rt_uniresource too.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.30 2000/01/21 22:52:45 mike Exp $ (BRL)";
d137 8
d216 1
a216 1
		bu_log("rt: no objects specified\n");
@


11.30
log
@
fixed error preventing -s50 from rendering a full framebuffer-sized
image rather than a zoomed-up 50x50 pixel image.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.29 1999/12/30 05:49:28 butler Exp $ (BRL)";
d296 2
@


11.29
log
@additions for -v flag to rt
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.28 1999/10/30 03:06:27 butler Exp $ (BRL)";
d268 2
a269 2
		if( fb_getwidth(fbp) < xx )  width = fb_getwidth(fbp);
		if( fb_getheight(fbp) < yy )  height = fb_getheight(fbp);
@


11.28
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.27 1999/05/28 01:17:23 mike Exp $ (BRL)";
d48 1
a108 8
	/* Identify the versions of the libraries we are using. */
	(void)fprintf(stderr, "%s%s%s%s\n",
		version+5,
		rt_version+5,
		bn_version+5,
		bu_version+5
	      );	/* +5 to skip @@(#) */

d128 10
d157 4
a160 2
		fprintf(stderr, "incremental resolution, nlevels = %d, width=%d\n",
			incr_nlevel, width);
d176 2
a177 1
	    fprintf(stderr,"Planning to run with %d processors\n", npsw );
d218 2
a219 1
	bu_log("db title:  %s\n", idbuf);
d234 2
a235 1
	rt_pr_tol( &rtip->rti_tol );
d302 3
a304 2
	fprintf(stderr,"initial dynamic memory use=%ld.\n",
		(long)((char *)sbrk(0)-beginptr) );
@


11.27
log
@
sed4
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /c/CVS/brlcad/rt/main.c,v 11.26 1998/03/19 04:36:24 mike Exp $ (BRL)";
a40 1
#include "./mathtab.h"
d290 1
a290 1
		rand_init( resource[i].re_randptr, i );
@


11.26
log
@64-bit
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.25 1998/03/19 04:09:18 mike Exp mike $ (BRL)";
d124 1
a124 1
	npsw = rt_avail_cpus();		/* Use all that are present */
d167 1
a167 1
		npsw = rt_avail_cpus() + npsw;
d319 1
a319 1
			rt_free( buf, "rt_read_cmd command buffer" );
@


11.25
log
@Added code to framebuffer setup so that if rt options request
larger image size than framebuffer can hold, then the number of
pixels to be computed is reduced.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.24 1997/12/16 07:47:32 mike Exp mike $ (BRL)";
d295 2
a296 1
	fprintf(stderr,"initial dynamic memory use=%d.\n", (char *)sbrk(0)-beginptr );
@


11.24
log
@Number of processors can change at runtime, init them all.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.23 1997/12/16 00:48:49 mike Exp mike $ (BRL)";
d259 5
a264 1
		bu_semaphore_acquire( BU_SEM_SYSCALL );
@


11.23
log
@Changed to use new symbol RT_SEM_LAST
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.22 1997/12/16 00:19:56 mike Exp mike $ (BRL)";
d283 1
d285 1
a285 1
	for( i=0; i < npsw; i++ )  {
@


11.22
log
@Converted to bu_semaphore_acquire()
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.21 1997/09/02 17:56:54 gdurf Exp mike $ (BRL)";
d177 1
a177 1
	bu_semaphore_init( BU_SEM_LAST );
@


11.21
log
@Added rt_nugrid_dimlimit support
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.20 1997/08/26 06:49:04 mike Exp gdurf $ (BRL)";
a174 5
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );
	RES_INIT( &rt_g.res_model );
d176 3
d180 1
a180 1
	 *  Do not use rt_log() or rt_malloc() before this point!
d251 1
a251 1
		RES_ACQUIRE( &rt_g.res_syscall );
d253 1
a253 1
		RES_RELEASE( &rt_g.res_syscall );
d260 1
a260 1
		RES_ACQUIRE( &rt_g.res_syscall );
d270 1
a270 1
		RES_RELEASE( &rt_g.res_syscall );
@


11.20
log
@Moved rt_init_resource() from worker() into main().
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.19 1997/07/08 15:29:30 gdurf Exp mike $ (BRL)";
d219 1
@


11.19
log
@Updated use of "nu_gfactor" variable
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.18 1997/06/13 02:54:18 gdurf Exp gdurf $ (BRL)";
d41 1
d136 1
a136 1
	if( optind >= argc )  {
d199 4
a202 4
	title_file = argv[optind];
	title_obj = argv[optind+1];
	nobjs = argc - optind - 1;
	objtab = &(argv[optind+1]);
d281 9
@


11.18
log
@Added -, option for space partitioning selection
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.17 1997/03/07 06:12:28 mike Exp gdurf $ (BRL)";
d218 1
@


11.17
log
@Moved bu_debug compat settings from main.c to opt.c.
Moved rt_init_resource() call from main.c to worker.c
Both to support remrt/rtsync.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.16 1997/01/10 15:31:57 jra Exp mike $ (BRL)";
d217 1
@


11.16
log
@Added calls to rt_init_resource().
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.15 1997/01/09 20:52:57 jra Exp jra $ (BRL)";
d125 1
a179 7
	/* initialize per process resources */
	for( i=0 ; i<npsw ; i++ )
	{
		resource[i].re_magic = RESOURCE_MAGIC;
		rt_init_resource( &resource[i] );
	}

a182 9

	/* Compat */
	if( rt_g.debug || rdebug )  bu_debug |= BU_DEBUG_COREDUMP;
	if( rt_g.debug & DEBUG_MEM_FULL )  bu_debug |= BU_DEBUG_MEM_CHECK;
	if( rt_g.debug & DEBUG_MEM )  bu_debug |= BU_DEBUG_MEM_LOG;
	if( rt_g.debug & DEBUG_PARALLEL )  bu_debug |= BU_DEBUG_PARALLEL;
	if( rt_g.debug & DEBUG_MATH )  bu_debug |= BU_DEBUG_MATH;

	if( rdebug & RDEBUG_RTMEM_END )  bu_debug |= BU_DEBUG_MEM_CHECK;
@


11.15
log
@removed erroneous initialization.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.14 1997/01/09 16:13:51 jra Exp jra $ (BRL)";
d90 2
d104 1
d178 8
@


11.14
log
@Added initialization for NMG hitmiss freelist.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.13 1996/11/01 15:41:35 pjt Exp jra $ (BRL)";
a174 1
	BU_LIST_INIT( &rt_g.rtg_nmgfree );
@


11.13
log
@Changed some indenting
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.12 1996/08/31 08:55:36 mike Exp pjt $ (BRL)";
d175 1
@


11.12
log
@Have LIBBN print version number too.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.11 1996/08/31 03:19:22 mike Exp mike $ (BRL)";
d166 2
a167 2
		rt_g.rtg_parallel = 1;
		fprintf(stderr,"Planning to run with %d processors\n", npsw );
@


11.11
log
@If memory debugging on 'clean' is desired, need to turn on checking
right from the start.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.10 1996/08/29 02:14:51 mike Exp mike $ (BRL)";
d36 1
d38 1
a38 1
#include "bu.h"
d106 1
a106 1
	(void)fprintf(stderr, "%s%s%s\n",
d109 1
@


11.10
log
@Added some compatability flags for -x bits driving bu_debug bits.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.9 1996/08/27 03:38:08 mike Exp mike $ (BRL)";
d183 2
@


11.9
log
@Also print out version string from LIBBU
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.8 1995/12/06 17:34:05 pjt Exp mike $ (BRL)";
d102 1
a102 1
	port_setlinebuf( stderr );
d177 12
d190 2
a191 2
		rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
		rt_log("\n");
d194 2
a195 2
		rt_printb( "rt rdebug", rdebug, RDEBUG_FORMAT );
		rt_log("\n");
d204 1
a204 1
		fprintf(stderr,"rt: no objects specified\n");
d210 1
a210 1
		fprintf(stderr,"rt:  rt_dirbuild(%s) failure\n", title_file);
d214 1
a214 1
	fprintf(stderr, "db title:  %s\n", idbuf);
@


11.8
log
@main() now calls application_init() at the very top
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.7 1995/11/07 14:31:31 adam Exp $ (BRL)";
d37 1
a99 1

d104 2
a105 1
	(void)fprintf(stderr, "%s%s\n",
d107 3
a109 1
		rt_version+5 );	/* +5 to skip @@(#) */
@


11.7
log
@Matching malloc and free messages -- rt_read_cmd command buffer
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.6 1995/08/25 21:59:41 mike Exp adam $ (BRL)";
d100 2
d117 3
@


11.6
log
@Compressed printing of LIBRT version.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.5 1995/07/18 02:54:25 mike Exp mike $ (BRL)";
d282 1
a282 1
			rt_free( buf, "cmd buf" );
@


11.5
log
@Irix 6.0.1
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.4 1995/06/13 21:00:07 butler Exp mike $ (BRL)";
d102 3
a104 2
	(void)fprintf(stderr, "%s\n", version+5);	/* skip @@(#) */
	(void)fprintf(stderr, "Using librt version:\n%s\n", rt_version+5);
@


11.4
log
@changed comment on main.c to reflect use of curframe variable in view.c
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.3 1995/03/20 11:36:30 jra Exp butler $ (BRL)";
a86 1
extern char	rt_version[];		/* From librt/vers.c */
@


11.3
log
@Added output of librt version used.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.2 95/03/01 03:43:29 mike Exp $ (BRL)";
d73 2
a74 1
extern int	curframe;		/* current frame number */
d78 1
@


11.2
log
@Implemented -T to allow setting calculation tolerance.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 11.1 95/01/04 10:00:40 mike Rel4_4 Locker: mike $ (BRL)";
d85 1
d102 1
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 10.6 94/12/21 14:43:18 stay Exp $ (BRL)";
d78 2
d191 2
d194 9
@


10.6
log
@fixed sbrk call to cast to char 8
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 10.5 94/11/24 02:56:24 mike Exp Locker: stay $ (BRL)";
@


10.5
log
@sbrk() now returns (void *) -- need to cast it to (char *) to do subtraction.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 10.4 94/10/17 23:00:58 mike Exp Locker: mike $ (BRL)";
d101 1
a101 1
	beginptr = sbrk(0);
d243 1
a243 1
	beginptr = sbrk(0);
@


10.4
log
@Make images larger than 512x512 be sized exactly.
Make images smaller come out 512x512, so that MGED users don't need
magnifying glasses.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 10.3 94/08/23 17:36:07 gdurf Exp Locker: mike $ (BRL)";
d242 1
a242 1
	fprintf(stderr,"initial dynamic memory use=%d.\n",sbrk(0)-beginptr );
@


10.3
log
@Removed unnecessary definition
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 10.2 1994/08/11 00:29:43 gdurf Exp gdurf $ (BRL)";
d205 7
a211 5
		xx = yy = 512;		/* SGI 3D users may want 768 */
		while( xx < width )
			xx <<= 1;
		while( yy < width )
			yy <<= 1;
d219 2
@


10.2
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 10.1 1991/10/12 06:41:45 mike Rel4_0 gdurf $ (BRL)";
a41 4

#ifdef HAVE_SBRK
extern char	*sbrk();
#endif
@


10.1
log
@Release_4.0
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 9.12 91/04/08 23:33:56 mike Exp $ (BRL)";
d28 2
d33 1
d35 1
d43 1
a43 3
extern int	getopt();
extern char	*optarg;
extern int	optind;
d45 1
d100 1
a100 12
#ifdef BSD
	setlinebuf( stderr );
#else
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2) && \
	 !defined(n16)
		(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#	endif
#	if defined(sgi) && defined(mips)
		if( setlinebuf( stderr ) != 0 )
			perror("setlinebuf(stderr)");
#	endif
#endif
d104 1
d106 1
d241 1
d244 1
@


9.12
log
@Changed rt.c to main.c, to prevent confusion between that one source
module, and the RT program.
@
text
@d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/main.c,v 9.11 91/03/11 23:08:18 mike Exp $ (BRL)";
@


9.11
log
@Deal with case of width & height being zero.
@
text
@d2 1
a2 1
 *			R T . C 
d4 2
a5 1
 *  Ray Tracing main program, using RT library.
d25 1
a25 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.10 91/01/24 15:23:12 mike Exp $ (BRL)";
@


9.10
log
@Negative numbers on -P mean "all but" that many CPUs.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.9 91/01/10 21:48:02 mike Exp $ (BRL)";
d206 2
d227 7
a233 3
		zoom = fb_getwidth(fbp)/width;
		if( fb_getheight(fbp)/height < zoom )
			zoom = fb_getheight(fbp)/height;
@


9.9
log
@Fixed auto-zooming of framebuffer to preserve square pixels.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.8 90/12/22 01:36:40 mike Exp $ (BRL)";
d153 5
@


9.8
log
@Become ultra-conservative about locking fb operations
(In this instance, it is slightly possible that the
initial database operations may have run in parallel).
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.7 90/12/22 01:34:55 mike Exp $ (BRL)";
d205 3
a207 1
		xx = yy = 512;		/* SGI users may want 768 */
a218 1
		/* New way:  center, zoom */
d220 5
a224 2
		fb_view( fbp, width/2, height/2,
			fb_getwidth(fbp)/width, fb_getheight(fbp)/height );
@


9.7
log
@Paul Stay found this bug with cell size not working.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.6 90/12/19 06:38:11 mike Exp $ (BRL)";
d210 4
a213 1
		if( (fbp = fb_open( framebuffer, xx, yy )) == FBIO_NULL )  {
d218 1
d221 1
@


9.6
log
@Changed SGI to be line buffered on rt_log.
Chagned parallel processor notice message.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.5 90/12/13 16:20:06 mike Exp $ (BRL)";
a111 1
	width = height = 512;
d129 6
@


9.5
log
@Changed to new LIBFB calls.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.4 90/12/11 21:52:18 mike Exp $ (BRL)";
d103 4
d150 1
a150 1
		fprintf(stderr,"rt:  running with %d processors\n", npsw );
@


9.4
log
@Added printing of version string,
to help distinguish output from different versions of the program.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.3 90/12/11 16:55:54 mike Exp $ (BRL)";
d205 3
a207 3
		/* ALERT:  The library wants zoom before window! */
		fb_zoom( fbp, fb_getwidth(fbp)/width, fb_getheight(fbp)/height );
		fb_window( fbp, width/2, height/2 );
@


9.3
log
@If output is not a framebuffer, or an output file, then use stdout
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.2 90/11/27 00:40:55 mike Exp $ (BRL)";
d82 2
d104 2
@


9.2
log
@setvbuf() does not work on Encore Multi-Max
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: /m/cad/rt/RCS/rt.c,v 9.1 89/05/19 05:59:14 mike Rel3_5 $ (BRL)";
d205 2
d208 1
a208 1
		if( output_is_binary && outfp && isatty(fileno(outfp)) )  {
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.18 89/04/30 20:43:44 mike Exp $ (BRL)";
d97 2
a98 1
#	if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2)
@


8.18
log
@No longer needs mathtab.h
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.17 89/04/29 09:44:18 mike Locked $ (BRL)";
@


8.17
log
@Added RES_INIT for res_model.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.16 89/04/12 01:18:08 mike Locked $ (BRL)";
a33 1
#include "./mathtab.h"
@


8.16
log
@Added file name to dirbuild failure message
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.15 89/04/10 21:15:50 mike Locked $ (BRL)";
d149 1
@


8.15
log
@Changed to ext.h
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.14 89/04/03 20:50:20 mike Locked $ (BRL)";
d174 1
a174 1
		fprintf(stderr,"rt:  rt_dirbuild failure\n");
@


8.14
log
@Added support for -g cell_width and -G cell_height options,
which included rearranging some calculations, because
grid_setup() can now change the values of width and height.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.13 89/03/19 23:51:40 mike Locked $ (BRL)";
d35 1
a50 4
extern int	hex_out;		/* Binary or Hex .pix output file */
extern double	AmbientIntensity;	/* Ambient light intensity */
extern double	azimuth, elevation;
extern int	lightmodel;		/* Select lighting model */
a53 1
extern int	use_air;		/* Handling of air in librt */
@


8.13
log
@If # of available CPUs is greater than DEFAULT_PSW,
then only use that many by default.
Useful mostly for the SGI 4D machines.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.12 89/03/15 16:26:42 mike Locked $ (BRL)";
a137 4
	if( pix_start == -1 )  {
		pix_start = 0;
		pix_end = height * width - 1;
	}
@


8.12
log
@Removed unused vars
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.11 89/03/10 04:47:08 mike Locked $ (BRL)";
d114 1
@


8.11
log
@Finally seem to have gotten outputfile & outfp stuff coordinated.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.10 89/03/10 04:33:13 mike Locked $ (BRL)";
a94 1
	static vect_t temp;
d96 1
a96 2
	register int x,y;
	char outbuf[132];
@


8.10
log
@Fixed stupid pointer error
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.9 89/03/08 19:13:59 mike Locked $ (BRL)";
a190 1
	if( outfp == NULL )  outfp = stdout;
d214 1
a214 1
		if( output_is_binary && isatty(fileno(outfp)) )  {
@


8.9
log
@Modified to better handle viewXXX modules which create printable
ascii output.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.8 89/02/14 00:29:01 mike Locked $ (BRL)";
d192 1
a192 1
	if( strcmp( outputfile, "-") == 0 )
@


8.8
log
@Added call to rt_avail_cpus
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.7 89/01/25 04:14:33 mike Locked $ (BRL)";
d54 1
d190 5
d213 3
a215 3
	} else if( outputfile == (char *)0 || strcmp( outputfile, "-") == 0 )  {
		outputfile = (char *)0;
		if( isatty(fileno(stdout)) )  {
a218 1
		outfp = stdout;
@


8.7
log
@Moved rt_cmdtab to do.c
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.6 89/01/20 03:20:13 mike Locked $ (BRL)";
d113 4
@


8.6
log
@Moved RT option processing from rt.c into opt.c
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.5 89/01/09 05:11:41 mike Locked $ (BRL)";
d84 1
a84 11
extern int	cm_start();
extern int	cm_vsize();
extern int	cm_eyept();
extern int	cm_lookat_pt();
extern int	cm_vrot();
extern int	cm_end();
extern int	cm_multiview();
extern int	cm_anim();
extern int	cm_tree();
extern int	cm_clean();
extern int	cm_set();
a85 27
static struct command_tab cmdtab[] = {
	"start", "frame number", "start a new frame",
		cm_start,	2, 2,
	"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2,
	"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4,
	"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5,
	"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17,
	"end", 	"", "end of frame setup, begin raytrace",
		cm_end,		1, 1,
	"multiview", "", "produce stock set of views",
		cm_multiview,	1, 1,
	"anim", 	"path type args", "specify articulation animation",
		cm_anim,	4, 999,
	"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_tree,	1, 999,
	"clean", "", "clean articulation from previous frame",
		cm_clean,	1, 1,
	"set", 	"", "show or set parameters",
		cm_set,		1, 999,
	(char *)0, (char *)0, (char *)0,
		0,		0, 0	/* END */
};

d232 1
a232 1
			ret = rt_do_cmd( rtip, buf, cmdtab );
@


8.5
log
@Added support for "lookat_pt" command in animation scripts
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.4 89/01/02 18:25:22 mike Locked $ (BRL)";
d50 4
a53 4
int		hex_out = 0;		/* Binary or Hex .pix output file */
double		AmbientIntensity = 0.4;	/* Ambient light intensity */
double		azimuth, elevation;
int		lightmodel;		/* Select lighting model */
a60 1
int		stereo = 0;		/* stereo viewing */
d62 5
a66 18
int		hypersample=0;		/* number of extra rays to fire */
int		jitter=0;		/* jitter ray starting positions */
fastf_t		rt_perspective=0;	/* presp (degrees X) 0 => ortho */
fastf_t		aspect = 1;		/* view aspect ratio X/Y */
vect_t		dx_model;		/* view delta-X as model-space vect */
vect_t		dy_model;		/* view delta-Y as model-space vect */
point_t		eye_model;		/* model-space location of eye */
fastf_t         eye_backoff = 1.414;	/* dist from eye to center */
int		width;			/* # of pixels in X */
int		height;			/* # of lines in Y */
mat_t		Viewrotscale;
fastf_t		viewsize=0;
char		*scanbuf;		/* For optional output buffering */
int		incr_mode;		/* !0 for incremental resolution */
int		incr_level;		/* current incremental level */
int		incr_nlevel;		/* number of levels */
int		npsw = DEFAULT_PSW;	/* number of worker PSWs to run */
struct resource	resource[MAX_PSW];	/* memory resources */
d70 4
a73 4
int		pix_start = -1;		/* pixel to start at */
int		pix_end;		/* pixel to end at */
int		nobjs;			/* Number of cmd-line treetops */
char		**objtab;		/* array of treetop strings */
d75 5
a79 5
int		matflag = 0;		/* read matrix from stdin */
int		desiredframe = 0;	/* frame to start at */
int		curframe = 0;		/* current frame number */
char		*outputfile = (char *)0;/* name of base of output file */
int		interactive = 0;	/* human is watching results */
d82 1
a82 1
static char	*framebuffer;		/* desired framebuffer */
a83 3
#define MAX_WIDTH	(32*1024)


a123 170
 *			G E T _ A R G S
 */
get_args( argc, argv )
register char **argv;
{
	register int c;
	register int i;

	while( (c=getopt( argc, argv, "E:SJ:H:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iIU:V:" )) != EOF )  {
		switch( c )  {
		case 'U':
			use_air = atoi( optarg );
			break;
		case 'I':
			interactive = 1;
			break;
		case 'i':
			incr_mode = 1;
			break;
		case 'S':
			stereo = 1;
			break;
		case 'J':
			sscanf( optarg, "%x", &jitter );
			break;
		case 'H':
			hypersample = atoi( optarg );
			if( hypersample > 0 )
				jitter = 1;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 'D':
			desiredframe = atoi( optarg );
			break;
		case 'M':
			matflag = 1;
			break;
		case 'A':
			AmbientIntensity = atof( optarg );
			break;
		case 'x':
			sscanf( optarg, "%x", &rt_g.debug );
			break;
		case 'X':
			sscanf( optarg, "%x", &rdebug );
			break;

		case 'f':
			/* "Fast" - arg's worth of pixels - historical */
		case 's':
			/* Square size */
			i = atoi( optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"squaresize=%d out of range\n", i);
			else
				width = height = i;
			break;
		case 'n':
			i = atoi( optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"height=%d out of range\n", i);
			else
				height = i;
			break;
		case 'w':
			i = atoi( optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"width=%d out of range\n", i);
			else
				width = i;
			break;

		case 'a':
			/* Set azimuth */
			azimuth = atof( optarg );
			matflag = 0;
			break;
		case 'e':
			/* Set elevation */
			elevation = atof( optarg );
			matflag = 0;
			break;
		case 'l':
			/* Select lighting model # */
			lightmodel = atoi( optarg );
			break;
		case 'O':
			/* Output pixel file name, Hex format */
			outputfile = optarg;
			hex_out = 1;
			break;
		case 'o':
			/* Output pixel file name, binary format */
			outputfile = optarg;
			hex_out = 0;
			break;
		case 'p':
			rt_perspective = atof( optarg );
			if( rt_perspective < 0 || rt_perspective > 179 ) {
				fprintf(stderr,"persp=%g out of range\n", rt_perspective);
				rt_perspective = 0;
			}
			break;
		case 'E':
			eye_backoff = atof( optarg );
			break;

		case 'P':
			/* Number of parallel workers */
			npsw = atoi( optarg );
			if( npsw < 1 || npsw > MAX_PSW )  {
				fprintf(stderr,"npsw out of range 1..%d\n", MAX_PSW);
				npsw = 1;
			}
			break;
		case 'B':
			/*  Remove all intentional random effects
			 *  (dither, etc) for benchmarking.
			 */
			mathtab_constant();
			break;
		case 'b':
			/* Specify a single pixel to be done */
			{
				int xx, yy;
				register char *cp = optarg;

				xx = atoi(cp);
				while( *cp >= '0' && *cp <= '9' )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				yy = atoi(cp);
				fprintf(stderr,"only pixel %d %d\n", xx, yy);
				if( xx * yy >= 0 )  {
					pix_start = yy * width + xx;
					pix_end = pix_start;
				}
			}
			break;
		case 'V':
			/* View aspect */
			{
				fastf_t xx, yy;
				register char *cp = optarg;

				xx = atof(cp);
				while( (*cp >= '0' && *cp <= '9')
					|| *cp == '.' )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				yy = atof(cp);
				if( yy == 0 )
					aspect = xx;
				else
					aspect = xx/yy;
				if( aspect == 0 ) {
					fprintf(stderr,"Bogus aspect %d, using 1.0\n", aspect);
					aspect = 1;
				}
			}
			break;
		default:		/* '?' */
			fprintf(stderr,"unknown option %c\n", c);
			return(0);	/* BAD */
		}
	}
	return(1);			/* OK */
}

/*
d139 5
a143 4
#endif BSD
#if defined( SYSV ) && !defined( sgi ) && !defined(CRAY2)
	(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#endif SYSV
d207 5
@


8.4
log
@Changed from local do_cmd() to rt_do_cmd() in librt/.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.3 88/12/27 16:45:52 mike Locked $ (BRL)";
d104 1
d120 2
@


8.3
log
@Fixed printf
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.2 88/12/06 02:45:58 mike Locked $ (BRL)";
d98 1
a98 1
#define MAX_WIDTH	(8*1024)
d100 37
a319 1
	char cbuf[512];			/* Input command buffer */
d436 2
d442 1
a442 1
		 * called by do_cmd().
d444 1
a444 1
		while( read_cmd( stdin, cbuf, sizeof(cbuf) ) >= 0 )  {
d446 5
a450 2
				fprintf(stderr,"cmd: %s\n", cbuf );
			if( do_cmd( cbuf ) < 0 )  break;
@


8.2
log
@pix_start & pix_end need to be computed after final changes to height
and width variables.
Also, if height != width in incr_mode, wierd things happened.
Final image becomes square.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 8.1 88/10/05 00:33:08 mike Locked $ (BRL)";
d202 1
a202 1
				fprintf(stderr,"persp=%d out of range\n", rt_perspective);
@


8.1
log
@Release_3.0
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.17 88/09/19 22:44:59 mike Exp $ (BRL)";
a305 4
	if( pix_start == -1 )  {
		pix_start = 0;
		pix_end = height * width - 1;
	}
d313 3
a315 2
		fprintf(stderr, "incremental resolution, nlevels = %d\n",
			incr_nlevel);
d318 4
@


7.17
log
@atof() is adequately "extern'ed" in <math.h>, and
re-defining in locally sometimes produced clashes,
so local definitions were removed.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.16 88/09/17 08:38:08 mike Locked $ (BRL)";
@


7.16
log
@Changed initial setting of npsw from MAX_PSW to DEFAULT_PSW,
a new define in machine.h
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.15 88/09/17 07:08:56 mike Locked $ (BRL)";
d41 1
a43 3

extern double	atof();
extern char	*sbrk();
@


7.15
log
@cray-->CRAY
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.14 88/09/16 23:59:31 mike Locked $ (BRL)";
d81 1
a81 1
int		npsw = MAX_PSW;		/* number of worker PSWs to run */
a297 3
#ifdef CRAY1
	npsw = 1;			/* >1 on GOS crashes system */
#endif
@


7.14
log
@made -J take a hex argument for future expansion
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.13 88/08/20 07:20:01 phil Locked $ (BRL)";
d300 1
a300 1
#endif cray
@


7.13
log
@new debug printb call, skip old style input if isatty()
persp_angle went away (rt_perspective == 0 implies ortho)
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.12 88/08/09 17:52:07 phil Locked $ (BRL)";
d111 1
a111 1
	while( (c=getopt( argc, argv, "E:SJH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iIU:V:" )) != EOF )  {
d126 1
a126 1
			jitter = 1;
@


7.12
log
@added -J jitter flag (may someday be a randomization bit vector?)
-H turns on jitter.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.11 88/06/20 20:22:06 phil Locked $ (BRL)";
d67 1
a67 2
int		rt_perspective=0;	/* perspective view -vs- parallel */
fastf_t		persp_angle = 90;	/* prespective angle (degrees X) */
a146 1
			fprintf(stderr,"librt rt_g.debug=x%x\n", rt_g.debug);
a149 1
			fprintf(stderr,"rt rdebug=x%x\n", rdebug);
d202 5
a206 4
			rt_perspective = 1;
			persp_angle = atof( optarg );
			if( persp_angle <= 1 )  persp_angle = 90;
			if( persp_angle > 179 )  persp_angle = 90;
a327 1
	 *  Do not use rt_log() or rt_malloc() before this point.
d341 3
d345 9
d401 1
a401 1
	} else if( old_way( stdin ) )  {
@


7.11
log
@Allows "-o -" to send output to stdout.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.10 88/06/16 02:57:52 mike Locked $ (BRL)";
d66 1
d112 1
a112 1
	while( (c=getopt( argc, argv, "E:SH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iIU:V:" )) != EOF )  {
d126 3
d131 2
@


7.10
log
@removed gratuitous aspect printf (oops)
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.9 88/06/16 02:50:44 phil Locked $ (BRL)";
d371 2
a372 1
	} else if( outputfile == (char *)0 )  {
@


7.9
log
@added -V to set aspect ratio
changed signs of az el to cannonical form
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.8 88/05/20 03:40:44 phil Locked $ (BRL)";
a257 1
				printf("Aspect = %f\n", aspect);
@


7.8
log
@Added -U option to load boolean variable use_air.
@
text
@d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.7 88/03/01 23:12:02 mike Locked $ (BRL)";
d68 1
a68 1
fastf_t		aspect = 1;		/* aspect ratio Y/X */
d111 1
a111 1
	while( (c=getopt( argc, argv, "E:SH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iIU:" )) != EOF )  {
d149 2
d152 1
a152 3
			/* Square size -- fall through */
		case 'f':
			/* "Fast" -- arg's worth of pixels */
d201 1
a201 1
			if( persp_angle < 1 )  persp_angle = 90;
d207 1
d239 22
d293 2
a294 2
	azimuth = -35.0;			/* GIFT defaults */
	elevation = -25.0;
@


7.7
log
@Allowed parallel operation to be non-XMP default
@
text
@d6 4
a9 2
 *  Is linked with each of three "back ends" (view.c, viewpp.c, viewray.c)
 *  to produce three executable programs:  rt, rtpp, rtray.
d24 1
a24 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.6 88/02/27 03:09:12 mike Locked $ (BRL)";
d58 1
d111 1
a111 1
	while( (c=getopt( argc, argv, "E:SH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iI" )) != EOF )  {
d113 3
d329 1
@


7.6
log
@Converted remaining "parallel" vars to "rt_g.rtg_parallel".
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.5 88/01/25 23:43:06 mike Locked $ (BRL)";
d266 1
a266 1
#ifdef cray
@


7.5
log
@aspect and perspective angle control
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.4 88/01/22 21:10:16 phil Locked $ (BRL)";
a77 1
int		parallel=0;		/* Trying to use multi CPUs */
d301 2
a302 3
	if( npsw > 1 )
		parallel = 1;
	if( parallel )
d304 2
@


7.4
log
@added variable eye_backoff on perspective
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.3 88/01/22 21:04:13 phil Locked $ (BRL)";
d64 2
a73 1
fastf_t		zoomout=1;		/* >0 zoom out, 0..1 zoom in */
d195 3
a197 2
			zoomout = atof( optarg );
			if( zoomout <= 0 )  zoomout = 1;
@


7.3
log
@Changed single-pixel (-b) option to take an arbitrary separator
character between the X and Y coordinate, to allow use of
comma or slash, permitting passing as a single arg through shell scripts.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.1 87/11/02 23:56:09 mike Rel $ (BRL)";
d67 1
d108 1
a108 1
	while( (c=getopt( argc, argv, "SH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:iI" )) != EOF )  {
d196 3
@


7.2
log
@perspective is a common library name in some graphics librariues
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 7.1 87/11/02 23:56:09 stay Locked $ (BRL)";
d214 6
a219 1
				(void)sscanf( optarg, "%d%d", &xx, &yy );
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 6.6 87/09/20 09:47:37 mike Exp $ (BRL)";
d63 1
a63 1
int		perspective=0;		/* perspective view -vs- parallel */
d192 1
a192 1
			perspective = 1;
@


6.6
log
@Added -I for interactive mode (no renice).
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 6.5 87/09/04 03:42:34 mike Locked $ (BRL)";
@


6.5
log
@Fixed parallel mode with interactive framebuffer
to send each scanline only when all pixels are done.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 6.4 87/09/03 23:04:37 mike Locked $ (BRL)";
d91 1
d107 1
a107 1
	while( (c=getopt( argc, argv, "SH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:i" )) != EOF )  {
d109 3
@


6.4
log
@Reorganized intialization of parallel code.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 6.3 87/09/03 01:30:32 mike Locked $ (BRL)";
a251 1

d276 2
a277 1
		rt_log("incremental resolution, nlevels = %d\n", incr_nlevel);
d280 4
a283 1
	/* Handle parallel initialization, if applicable */
d285 1
a285 1
	npsw = 1;		/* serial */
@


6.3
log
@Added incremental resolution capability.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 6.2 87/09/03 00:53:04 mike Locked $ (BRL)";
d280 1
a280 5
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );

d288 4
@


6.2
log
@Eliminated setvbuf() for Cray-2,
when not PARALLEL, forced npsw=1
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 6.1 87/07/11 07:59:03 mike Rel $ (BRL)";
d73 3
d106 1
a106 1
	while( (c=getopt( argc, argv, "SH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:Bb:n:w:" )) != EOF )  {
d108 3
d269 9
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 5.3 87/07/09 03:30:46 mike Exp $ (BRL)";
d238 1
a238 1
#if defined( SYSV) && !defined( sgi )
d270 3
@


5.3
log
@Changed parallel support from #ifdef to runtime determination.
Added 3 types of libfb interaction
Misc. cleanups.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 5.2 87/06/27 03:51:51 mike Locked $ (BRL)";
@


5.2
log
@Added print of parameters to "-b" option, because getting the double number
input right with getopt() is hard.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 5.1 87/06/24 22:15:05 mike Locked $ (BRL)";
d73 1
d235 7
d256 1
a256 1
		fprintf(stderr,"rt: MGED database not specified\n");
d270 5
d308 1
a308 1
			fprintf(stderr,"rt: binary output to terminal\n");
a314 4

#ifdef PARALLEL
	fprintf(stderr,"PARALLEL: npsw=%d\n", npsw );
#endif PARALLEL
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.19 87/05/30 07:03:57 mike Exp $ (BRL)";
d204 1
@


4.19
log
@Added code for non-square views, single pixel (-b) debugging.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.18 87/05/28 21:53:05 mike Locked $ (BRL)";
@


4.18
log
@Removed fb_clear and fb_wmap operations;  Phil convinced me they
don't belong in RT itself.
@
text
@d4 1
a4 1
 *  Demonstration Ray Tracing main program, using RT library.
d18 1
a18 1
 *	This software is Copyright (C) 1985 by the United States Army.
d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.17 87/05/28 21:00:10 mike Locked $ (BRL)";
d60 1
a60 1
int		stereo = 0;	/* stereo viewing */
d62 7
a68 6
int		hypersample=0;	/* number of extra rays to fire */
int		perspective=0;	/* perspective view -vs- parallel view */
vect_t		dx_model;	/* view delta-X as model-space vector */
vect_t		dy_model;	/* view delta-Y as model-space vector */
point_t		eye_model;	/* model-space location of eye */
int		npts;		/* # of points to shoot: x,y */
d71 2
a72 2
fastf_t		zoomout=1;	/* >0 zoom out, 0..1 zoom in */
char		*scanbuf;	/* For optional output buffering */
d78 2
d91 2
d100 1
d102 1
a102 1
	while( (c=getopt( argc, argv, "SH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:B" )) != EOF )  {
d130 1
d135 5
a139 5
			npts = atoi( optarg );
			if( npts < 2 || npts > (1024*8) )  {
				fprintf(stderr,"npts=%d out of range\n", npts);
				npts = 50;
			}
d141 15
d199 11
d234 1
a234 1
	npts = 512;
d251 4
d277 1
a277 1
	if( view_init( &ap, title_file, title_obj, npts, outputfile!=(char *)0 ) != 0 )  {
d279 8
a286 5
		register int sz = 512;
		while( sz < npts )
			sz <<= 1;
		if( (fbp = fb_open( framebuffer, sz, sz )) == FBIO_NULL )  {
			rt_log("rt:  can't open frame buffer\n");
d290 2
a291 2
		fb_zoom( fbp, fb_getwidth(fbp)/npts, fb_getheight(fbp)/npts );
		fb_window( fbp, npts/2, npts/2 );
d293 4
a296 1
		/* Perhaps the isatty check here? */
@


4.17
log
@Changed BENCHMARK flag from a compile-time option to a run-time
option (-B).
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.16 87/04/10 07:15:06 mike Locked $ (BRL)";
d249 1
a249 3
		fb_clear( fbp, PIXEL_NULL );
		fb_wmap( fbp, COLORMAP_NULL );
		/* KLUDGE ALERT:  The library want zoom before window! */
@


4.16
log
@Moved more parallel support code to do.c
from rt.c
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.15 87/04/10 07:03:38 mike Exp $ (BRL)";
d96 1
a96 1
	while( (c=getopt( argc, argv, "SH:F:D:MA:x:X:s:f:a:e:l:O:o:p:P:" )) != EOF )  {
d170 6
@


4.15
log
@Minor changes to split rt.c into rt.c and do.c,
plus reintegration with remrt/rtsrv.c
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.14 87/04/01 02:34:36 mike Exp $ (BRL)";
a86 45

#ifdef PARALLEL
static int	lock_tab[12];		/* Lock usage counters */
static char	*all_title[12] = {
	"syscall",
	"worker",
	"stats",
	"results",
	"???"
};

/*
 *			L O C K _ P R
 */
lock_pr()
{
	register int i;
	for( i=0; i<3; i++ )  {
		if(lock_tab[i] == 0)  continue;
		fprintf(stderr,"%10d %s\n", lock_tab[i], all_title[i]);
	}
}
#endif PARALLEL

/*
 *			R E S _ P R
 */
res_pr()
{
	register struct resource *res;
	register int i;

	res = &resource[0];
	for( i=0; i<npsw; i++, res++ )  {
		fprintf(stderr,"cpu%d seg  len=%10d get=%10d free=%10d\n",
			i,
			res->re_seglen, res->re_segget, res->re_segfree );
		fprintf(stderr,"cpu%d part len=%10d get=%10d free=%10d\n",
			i,
			res->re_partlen, res->re_partget, res->re_partfree );
		fprintf(stderr,"cpu%d bitv len=%10d get=%10d free=%10d\n",
			i,
			res->re_bitvlen, res->re_bitvget, res->re_bitvfree );
	}
}
@


4.14
log
@Added missing break statement for -x flag.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.13 87/03/28 03:02:13 mike Exp $ (BRL)";
a35 7
#ifdef HEP
# include <synch.h>
# undef stderr
# define stderr stdout
# define PARALLEL 1
#endif

a41 2
extern void	wray(), wraypts();

a57 2
extern void	grid_setup();
extern void	worker();
a66 1
point_t		viewbase_model;	/* model-space location of viewplane corner */
d71 2
a72 6

#ifdef PARALLEL
char		*scanbuf;	/*** Output buffering, for parallelism */
#endif

int		npsw = 1;		/* number of worker PSWs to run */
d74 1
a74 1
/***** end variables shared with worker() */
d76 9
a84 6
static char	*beginptr;		/* sbrk() at start of program */
static int	matflag = 0;		/* read matrix from stdin */
static int	desiredframe = 0;
static int	curframe = 0;
static char	*outputfile = (char *)0;/* name of base of output file */
static char	*framebuffer = NULL;	/* Name of framebuffer */
d86 1
a86 2
static int	nobjs;			/* Number of cmd-line treetops */
static char	**objtab;		/* array of treetop strings */
d244 4
a302 6
#ifdef HEP
	for( x=0; x<npsw; x++ )  {
		/* This is expensive when GEMINUS>1 */
		Dcreate( worker, x );
	}
#endif HEP
a327 6
#ifdef HEP
	fprintf(stderr,"rt: killing workers\n");
	for( x=0; x<npsw; x++ )
		Diawrite( &work_word, -1 );
	fprintf(stderr,"rt: exit\n");
#endif
a334 675

/*
 *			O L D _ W A Y
 * 
 *  Determine if input file is old or new format, and if
 *  old format, handle process *  Returns 0 if new way, 1 if old way (and all done).
 *  Note that the rewind() will fail on ttys, pipes, and sockets (sigh).
 */
int
old_way( fp )
FILE *fp;
{
	viewsize = -42.0;
	if( old_frame( fp ) < 0 || viewsize <= 0.0 )  {
		rewind( fp );
		return(0);		/* Not old way */
	}
	rt_log("Interpreting command stream in old format\n");

	def_tree( ap.a_rt_i );		/* Load the default trees */

	curframe = 0;
	do {
		do_frame( curframe++ );
	}  while( old_frame( fp ) >= 0 && viewsize > 0.0 );
	return(1);			/* old way, all done */
}

/*
 *			O L D _ F R A M E
 *
 *  Acquire particulars about a frame, in the old format.
 *  Returns -1 if unable to acquire info, 0 if successful.
 */
int
old_frame( fp )
FILE *fp;
{
	register int i;
	char number[128];

	/* Visible part is from -1 to +1 in view space */
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	viewsize = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[X] = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[Y] = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
	eye_model[Z] = atof(number);
	for( i=0; i < 16; i++ )  {
		if( fscanf( fp, "%s", number ) != 1 )
			return(-1);
		Viewrotscale[i] = atof(number);
	}
	return(0);		/* OK */
}

/*
 *			C M _ S T A R T
 *
 *  Process "start" command in new format input stream
 */
cm_start( argc, argv )
int	argc;
char	**argv;
{
	char ibuf[512];
	int frame;

	frame = atoi(argv[1]);
	if( frame >= desiredframe )  {
		curframe = frame;
		return(0);
	}

	/* Skip over unwanted frames -- find next frame start */
	while( read_cmd( stdin, ibuf, sizeof(ibuf) ) >= 0 )  {
		register char *cp;

		cp = ibuf;
		while( *cp && isspace(*cp) )  cp++;	/* skip spaces */
		if( strncmp( cp, "start", 5 ) != 0 )  continue;
		while( *cp && !isspace(*cp) )  cp++;	/* skip keyword */
		while( *cp && isspace(*cp) )  cp++;	/* skip spaces */
		frame = atoi(cp);
		if( frame >= desiredframe )  {
			curframe = frame;
			return(0);
		}
	}
	return(-1);		/* EOF */
}

cm_vsize( argc, argv )
int	argc;
char	**argv;
{
	viewsize = atof( argv[1] );
	return(0);
}

cm_eyept( argc, argv )
int	argc;
char	**argv;
{
	register int i;

	for( i=0; i<3; i++ )
		eye_model[i] = atof( argv[i+1] );
	return(0);
}

cm_vrot( argc, argv )
int	argc;
char	**argv;
{
	register int i;

	for( i=0; i<16; i++ )
		Viewrotscale[i] = atof( argv[i+1] );
	return(0);
}

cm_end( argc, argv )
int	argc;
char	**argv;
{
	struct rt_i *rtip = ap.a_rt_i;

	if( rtip->HeadRegion == REGION_NULL )  {
		def_tree( rtip );		/* Load the default trees */
	}
	if( do_frame( curframe ) < 0 )  return(-1);
	return(0);
}

cm_tree( argc, argv )
int	argc;
char	**argv;
{
	register struct rt_i *rtip = ap.a_rt_i;
	char outbuf[132];
	register int i;

	if( argc <= 1 )  {
		def_tree( rtip );		/* Load the default trees */
		return(0);
	}
	rt_prep_timer();
	for( i=1; i < argc; i++ )  {
		if( rt_gettree(rtip, argv[i]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[i]);
	}
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	fprintf(stderr,"GETTREE: %s\n", outbuf);
	return(0);
}

cm_multiview( argc, argv )
int	argc;
char	**argv;
{
	register struct rt_i *rtip = ap.a_rt_i;
	static int a[] = {
		-35,
		  0,  90, 135, 180, 225, 270, 315,
		  0,  90, 135, 180, 225, 270, 315
	};
	static int e[] = {
		-25,
		-30, -30, -30, -30, -30, -30, -30,
		  0,   0,   0,   0,   0,   0,   0
	};

	if( rtip->HeadRegion == REGION_NULL )  {
		def_tree( rtip );		/* Load the default trees */
	}
	for( curframe=0; curframe<(sizeof(a)/sizeof(a[0])); curframe++ )  {
		do_ae( (double)a[curframe], (double)e[curframe] );
		(void)do_frame( curframe );
	}
	return(-1);	/* end RT by returning an error */
}

/*
 *			C M _ A N I M
 *
 *  Experimental animation code
 *
 *  Usage:  anim <path> <type> args
 */
cm_anim( argc, argv )
int	argc;
char	**argv;
{
	struct rt_i *rtip = ap.a_rt_i;
	struct animate *anp;
	struct directory **dir;
	int i;

	/* Eventually might want to note leading slash or not */
	if( (i = rt_plookup( rtip, &dir, argv[1], LOOKUP_NOISY )) <= 0 )
		return(-1);		/* error */

	GETSTRUCT( anp, animate );
	anp->an_path = dir;
	anp->an_pathlen = i;

	if( strcmp( argv[2], "matrix" ) == 0 )  {
		anp->an_type = AN_MATRIX;
		if( strcmp( argv[3], "rstack" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RSTACK;
		else if( strcmp( argv[3], "rarc" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RARC;
		else if( strcmp( argv[3], "lmul" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_LMUL;
		else if( strcmp( argv[3], "rmul" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RMUL;
		else if( strcmp( argv[3], "rboth" ) == 0 )
			anp->an_u.anu_m.anm_op = ANM_RBOTH;
		else  {
			fprintf(stderr,"cm_anim:  Matrix op %s unknown\n",
				argv[3]);
			goto bad;
		}
		for( i=0; i<16; i++ )
			anp->an_u.anu_m.anm_mat[i] = atof( argv[i+4] );
	} else {
		fprintf(stderr,"cm_anim:  type %s unknown\n", argv[2]);
		goto bad;
	}
	if( rt_add_anim( rtip, anp ) < 0 )  {
		fprintf(stderr,"cm_anim:  %s %s failed\n", argv[1], argv[2]);
		goto bad;
	}
	return(0);
bad:
	rt_free( (char *)dir, "directory []");
	rt_free( (char *)anp, "animate");
	return(-1);		/* BAD */
}

/*
 *			C M _ C L E A N
 *
 *  Clean out results of last rt_prep(), and start anew.
 */
cm_clean( argc, argv )
int	argc;
char	**argv;
{
	register struct region *regp;

	/* The linkage here needs to be much better for things
	 * like rtrad, etc. XXXX
	 */
	for( regp=ap.a_rt_i->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )
		mlib_free( regp );
	rt_clean( ap.a_rt_i );
	if(rdebug&RDEBUG_RTMEM)
		rt_prmem( "After rt_clean" );
	return(0);
}

/*
 *			D E F _ T R E E
 *
 *  Load default tree list, from command line.
 */
def_tree( rtip )
register struct rt_i	*rtip;
{
	char outbuf[132];
	register int i;

	rt_prep_timer();
	for( i=0; i < nobjs; i++ )  {
		if( rt_gettree(rtip, objtab[i]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", objtab[i]);
	}
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	fprintf(stderr,"GETTREE: %s\n", outbuf);
}

/*
 *			D O _ F R A M E
 *
 *  Do all the actual work to run a frame.
 *
 *  Returns -1 on error, 0 if OK.
 */
do_frame( framenumber )
int framenumber;
{
	char outbuf[132];
	char framename[128];		/* File name to hold current frame */
	struct rt_i *rtip = ap.a_rt_i;
	static double utime;
	register struct region *regp;

	fprintf(stderr, "\n...................Frame %5d...................\n",
		framenumber);
	if( rtip->needprep )  {
		/* Allow RT library to prepare itself */
		rt_prep_timer();
		rt_prep(rtip);

		/* Initialize the material library for all regions */
		for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
			if( mlib_setup( regp ) < 0 )  {
				rt_log("mlib_setup failure on %s\n", regp->reg_name);
			} else {
				if(rdebug&RDEBUG_MATERIAL)
					regp->reg_mfuncs->mf_print( regp );
				/* Perhaps this should be a function? */
			}
		}
		(void)rt_read_timer( outbuf, sizeof(outbuf) );
		fprintf(stderr, "PREP: %s\n", outbuf );
	}
	fprintf(stderr,"shooting at %d solids in %d regions\n",
		rtip->nsolids, rtip->nregions );
	if( rtip->HeadSolid == SOLTAB_NULL )  {
		fprintf(stderr,"rt ERROR: No solids\n");
		exit(3);
	}
	fprintf(stderr,"model X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
		rtip->mdl_min[X], rtip->mdl_max[X],
		rtip->mdl_min[Y], rtip->mdl_max[Y],
		rtip->mdl_min[Z], rtip->mdl_max[Z] );

	if(rdebug&RDEBUG_RTMEM)
		rt_g.debug |= DEBUG_MEM;	/* Just for the tracing */

	if( outputfile != (char *)0 )  {
#ifdef CRAY_COS
		/* Dots in COS file names make them permanant files. */
		sprintf( framename, "F%d", framenumber );
		if( (outfp = fopen( framename, "w" )) == NULL )  {
			perror( framename );
			if( matflag )  return(0);
			return(-1);
		}
		/* Dispose to shell script starts with "!" */
		if( framenumber <= 0 || outputfile[0] == '!' )  {
			sprintf( framename, outputfile );
		}  else  {
			sprintf( framename, "%s.%d", outputfile, framenumber );
		}
#else
		if( framenumber <= 0 )  {
			sprintf( framename, outputfile );
		}  else  {
			sprintf( framename, "%s.%d", outputfile, framenumber );
		}
		if( (outfp = fopen( framename, "w" )) == NULL )  {
			perror( framename );
			if( matflag )  return(0);	/* OK */
			return(-1);			/* Bad */
		}
		chmod( framename, 0444 );
#endif CRAY_COS
		fprintf(stderr,"Output file is '%s'\n", framename);
	}

	grid_setup();
	fprintf(stderr,"Beam radius=%g mm, divergance=%g mm/1mm\n",
		ap.a_rbeam, ap.a_diverge );

	/* initialize lighting */
	view_2init( &ap );

	rtip->nshots = 0;
	rtip->nmiss_model = 0;
	rtip->nmiss_tree = 0;
	rtip->nmiss_solid = 0;
	rtip->nmiss = 0;
	rtip->nhits = 0;
	rtip->rti_nrays = 0;

	fprintf(stderr,"\n");
	fflush(stdout);
	fflush(stderr);

	/*
	 *  Compute the image
	 *  It may prove desirable to do this in chunks
	 */
	rt_prep_timer();
	do_run( 0, npts*npts - 1 );
	utime = rt_read_timer( outbuf, sizeof(outbuf) );

	/*
	 *  End of application.  Done outside of timing section.
	 *  Typically, writes any remaining results out.
	 */
	view_end( &ap );

	if(rdebug&RDEBUG_RTMEM)
		rt_g.debug &= ~DEBUG_MEM;	/* Stop until next frame */

	/*
	 *  All done.  Display run statistics.
	 */
	fprintf(stderr,"SHOT: %s\n", outbuf );
	fprintf(stderr,"Additional dynamic memory used=%d. bytes\n",
		sbrk(0)-beginptr );
		beginptr = sbrk(0);
	fprintf(stderr,"%ld solid/ray intersections: %ld hits + %ld miss\n",
		rtip->nshots, rtip->nhits, rtip->nmiss );
	fprintf(stderr,"pruned %.1f%%:  %ld model RPP, %ld dups skipped, %ld solid RPP\n",
		rtip->nshots>0?((double)rtip->nhits*100.0)/rtip->nshots:100.0,
		rtip->nmiss_model, rtip->nmiss_tree, rtip->nmiss_solid );
	fprintf(stderr,
		"Frame %5d: %8d pixels in %10.2f sec = %10.2f pixels/sec\n",
		framenumber,
		npts*npts, utime, (double)(npts*npts)/utime );
	fprintf(stderr,
		"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/sec (RTFM)\n",
		framenumber,
		rtip->rti_nrays, utime, (double)(rtip->rti_nrays)/utime );

	if( outfp != NULL )  {
#ifdef CRAY_COS
		int status;
		char dn[16];
		char message[128];

		strncpy( dn, outfp->ldn, sizeof(outfp->ldn) );	/* COS name */
#endif CRAY_COS
		(void)fclose(outfp);
		outfp = NULL;
#ifdef CRAY_COS
		status = 0;
		if( hex_out )  {
			(void)DISPOSE( &status, "DN      ", dn,
				"TEXT    ", framename,
				"NOWAIT  " );
		} else {
			/* Binary out */
			(void)DISPOSE( &status, "DN      ", dn,
				"TEXT    ", framename,
				"NOWAIT  ",
				"DF      ", "BB      " );
		}
		sprintf(message,
			"%s Dispose,dn='%s',text='%s'.  stat=0%o",
			(status==0) ? "Good" : "---BAD---",
			dn, framename, status );
		fprintf(stderr, "%s\n", message);
		remark(message);	/* Send to log files */
#endif CRAY_COS
	}

#ifdef STAT_PARALLEL
	lock_pr();
	res_pr();
#endif STAT_PARALLEL

	fprintf(stderr,"\n");
	return(0);		/* OK */
}

/*
 *			D O _ A E
 *
 *  Compute the rotation specified by the azimuth and
 *  elevation parameters.  First, note that these are
 *  specified relative to the GIFT "front view", ie,
 *  model (X,Y,Z) is view (Z,X,Y):  looking down X axis.
 *  Then, a positive azimuth represents rotating the *model*
 *  around the Y axis, or, rotating the *eye* in -Y.
 *  A positive elevation represents rotating the *model*
 *  around the X axis, or, rotating the *eye* in -X.
 *  This is the "Gwyn compatable" azim/elev interpretation.
 *  Note that GIFT azim/elev values are the negatives of
 *  this interpretation.
 */
do_ae( azim, elev )
double azim, elev;
{
	vect_t	temp;
	vect_t	diag;
	mat_t	toEye;
	struct rt_i *rtip = ap.a_rt_i;

	mat_idn( Viewrotscale );
	mat_angles( Viewrotscale, 270.0-elev, 0.0, 270.0+azim );
	fprintf(stderr,"Viewing %g azimuth, %g elevation off of front view\n",
		azim, elev);

	/* Look at the center of the model */
	mat_idn( toEye );
	toEye[MDX] = -(rtip->mdl_max[X]+rtip->mdl_min[X])/2;
	toEye[MDY] = -(rtip->mdl_max[Y]+rtip->mdl_min[Y])/2;
	toEye[MDZ] = -(rtip->mdl_max[Z]+rtip->mdl_min[Z])/2;

	/* Fit a sphere to the model RPP, diameter is viewsize,
	 * unless viewsize command used to override.
	 */
	VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
	if( viewsize <= 0 )
		viewsize = MAGNITUDE( diag );
	fprintf(stderr,"view size = %g\n", viewsize);

	Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
	mat_mul( model2view, Viewrotscale, toEye );
	mat_inv( view2model, model2view );
	VSET( temp, 0, 0, 1.414 );
	MAT4X3PNT( eye_model, view2model, temp );
}

#ifdef cray
#ifdef PARALLEL
RES_INIT(p)
register int *p;
{
	register int i = p - (&rt_g.res_syscall);
	if(rdebug&RDEBUG_PARALLEL) 
		fprintf(stderr,"RES_INIT 0%o, i=%d, rt_g=0%o\n", p, i, &rt_g);
	LOCKASGN(p);
	if(rdebug&RDEBUG_PARALLEL) 
		fprintf(stderr,"    start value = 0%o\n", *p );
}
RES_ACQUIRE(p)
register int *p;
{
	register int i = p - (&rt_g.res_syscall);
	if( i < 0 || i > 12 )  {
		fprintf("RES_ACQUIRE(0%o)? %d?\n", p, i);
		abort();
	}
	lock_tab[i]++;		/* Not interlocked */
	if(rdebug&RDEBUG_PARALLEL) fputc( 'A'+i, stderr );
	LOCKON(p);
	if(rdebug&RDEBUG_PARALLEL) fputc( '0'+i, stderr );
}
RES_RELEASE(p)
register int *p;
{
	register int i = p - (&rt_g.res_syscall);
	if(rdebug&RDEBUG_PARALLEL) fputc( 'a'+i, stderr );
	LOCKOFF(p);
	if(rdebug&RDEBUG_PARALLEL) fputc( '\n', stderr);
}
#else
RES_INIT() {}
RES_ACQUIRE() {}
RES_RELEASE() {}
#endif PARALLEL
#endif cray

#ifdef sgi
/* Horrible bug in 3.3.1 and 3.4 and 3.5 -- hypot ruins stack! */
long float
hypot(a,b)
double a,b;
{
	return(sqrt(a*a+b*b));
}
#endif

#ifdef alliant
RES_ACQUIRE(p)
register int *p;		/* known to be a5 */
{
	register int i;
	i = p - (&rt_g.res_syscall);

#ifdef PARALLEL
	asm("loop:");
	do  {
		/* Just wasting time anyways, so log it */
		lock_tab[i]++;	/* non-interlocked */
	} while( *p );
	asm("	tas	a5@@");
	asm("	bne	loop");
#endif
}

#ifdef never
MAT4X3PNT( o, m, i )
register fastf_t *o;	/* a5 */
register fastf_t *m;	/* a4 */
register fastf_t *i;	/* a3 */
{
#ifdef NON_VECTOR
	FAST fastf_t f;
	f = 1.0/((m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]);
	(o)[X]=((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z] + (m)[3]) * f;
	(o)[Y]=((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z] + (m)[7]) * f;
	(o)[Z]=((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11])* f;
#else
	register int i;		/* d7 */
	register int vm;	/* d6, vector mask */
	register int vi;	/* d5, vector increment */
	register int vl;	/* d4, vector length */

	vm = -1;
	vi = 4;
	vl = 4;

	asm("fmoved	a3@@, fp0");
	asm("vmuld	a4@@, fp0, v7");

	asm("fmoved	a3@@(8), fp0");
	asm("vmuadd	fp0, a4@@(8), v7, v7");

	asm("fmoved	a3@@(16), fp0");
	asm("vmuadd	fp0, a4@@(16), v7, v7");

	asm("vaddd	a4@@(24), v7, v7");

#ifdef RECIPROCAL
	asm("moveq	#1, d0");
	asm("fmoveld	d0, fp0");
	asm("fdivd	a4@@(120), fp0, fp0");
	asm("vmuld	v7, fp0, v7");
#else
	asm("fmovedd	a4@@(120), fp7");
	asm("vrdivd	v7, fp7, v7");
#endif

	vi = 1;
	asm("vmoved	v7, a5@@");
#endif
}
/* Apply a 4x4 matrix to a 3-tuple which is a relative Vector in space */
MAT4X3VEC( o, m, i )
register fastf_t *o;
register fastf_t *m;
register fastf_t *i;
{
#ifdef NON_VECTOR
	FAST fastf_t f;
	f = 1.0/((m)[15]);
	(o)[X] = ((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z]) * f;
	(o)[Y] = ((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z]) * f;
	(o)[Z] = ((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z]) * f;
#else
	register int i;		/* d7 */
	register int vm;	/* d6, vector mask */
	register int vi;	/* d5, vector increment */
	register int vl;	/* d4, vector length */

	vm = -1;
	vi = 4;
	vl = 3;

	asm("fmoved	a3@@, fp0");
	asm("vmuld	a4@@, fp0, v7");

	asm("fmoved	a3@@(8), fp0");
	asm("vmuadd	fp0, a4@@(8), v7, v7");

	asm("fmoved	a3@@(16), fp0");
	asm("vmuadd	fp0, a4@@(16), v7, v7");

#ifdef RECIPROCAL
	asm("moveq	#1, d0");
	asm("fmoveld	d0, fp0");
	asm("fdivd	a4@@(120), fp0, fp0");
	asm("vmuld	v7, fp0, v7");
#else
	asm("fmovedd	a4@@(120), fp7");
	asm("vrdivd	v7, fp7, v7");
#endif

	vi = 1;
	asm("vmoved	v7, a5@@");
#endif
}
#endif never
#endif alliant
@


4.13
log
@Added def_tree() call to multiview.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.12 87/03/23 23:47:00 mike Exp $ (BRL)";
d178 1
@


4.12
log
@Revised for new material property interface.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.11 87/03/19 05:01:20 mike Exp $ (BRL)";
d519 1
d531 3
@


4.11
log
@Added "clean" command.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.10 87/03/19 03:05:53 mike Exp $ (BRL)";
d105 1
a105 1
	"malloc",
d108 1
d267 1
a267 1
	RES_INIT( &rt_g.res_malloc );
d270 1
a270 3
#ifdef PARALLEL
	scanbuf = rt_malloc( npts*npts*3 + sizeof(long), "scanbuf" );
#endif
a271 3
	if(rdebug&RDEBUG_RTMEM)
		rt_g.debug |= DEBUG_MEM;

d302 3
a305 7

	/* Get some dynamic memory to keep from making malloc sbrk() early */
	for( x=0; x<npsw; x++ )  {
		rt_get_pt(&resource[x]);
		rt_get_seg(&resource[x]);
		rt_get_bitv(&resource[x]);
	}
d604 7
d612 2
d662 1
a662 1
			if( mlib_setup( regp ) == 0 )  {
d664 4
d684 3
d751 3
a782 6
#ifdef PARALLEL
		if( fwrite( scanbuf, sizeof(char), npts*npts*3, outfp ) != npts*npts*3 )  {
			fprintf(stderr,"%s: fwrite failure\n", framename);
			return(-1);		/* BAD */
		}
#endif PARALLEL
d870 1
a870 1
	register int i = p - (&rt_g.res_malloc);
d880 1
a880 1
	register int i = p - (&rt_g.res_malloc);
d893 1
a893 1
	register int i = p - (&rt_g.res_malloc);
d920 1
a920 1
	i = p - (&rt_g.res_malloc);
@


4.10
log
@First version with working animation, driven from command file.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.7 87/03/17 22:30:14 mike Exp $ (BRL)";
d601 13
@


4.9
log
@Rearranged command parsing to be better,
more preparations for animation.
@
text
@d509 4
d520 1
d545 7
a551 1
/** experimental animation code ***/
d556 4
a559 3
	static struct directory *dir[4];
	static struct animate a;
	int k;
d561 40
a600 12
#ifdef never
	dir[0] = rt_dir_lookup("tor.r", LOOKUP_NOISY);
	a.an_path = dir;
	a.an_pathlen = 1;
	a.an_type = AN_MATRIX;
	a.an_u.anu_m.anm_op = ANM_RMUL;
	mat_idn( a.an_u.anu_m.anm_mat );
	MAT_DELTAS( a.an_u.anu_m.anm_mat, 0, 60, 0 );
	k = rt_add_anim( rtip, &a );
	rt_log("return=%d\n", k);
	rt_pr_dir(rtip);
#endif
@


4.8
log
@Code rearrangement in preparation for animation.
@
text
@a307 3
	/* Load the trees */
	def_tree( rtip );

d314 2
a317 6
#ifdef HEP
	/* This isn't useful with the Caltech malloc() in most systems,
	 * but is very helpful with the ordinary malloc(). */
	rt_free( rt_malloc( (20+npsw)*8192, "worker prefetch"), "worker");
#endif HEP

d319 1
a325 1
#endif PARALLEL
a326 3
	fprintf(stderr,"initial dynamic memory use=%d.\n",sbrk(0)-beginptr );
	beginptr = sbrk(0);

d328 1
d341 2
d382 3
d427 3
a429 2
cm_start( cmd, arg )
char *cmd, *arg;
d434 1
a434 1
	frame = atoi(arg);
d458 3
a460 5
static
fget( fp, cp, cnt )
register fastf_t *fp;
register char *cp;
register int cnt;
d462 2
a463 5
	while( cnt-- > 0 )  {
		while( *cp && isspace(*cp) )  cp++;
		*fp++ = atof(cp);
		while( *cp && !isspace(*cp) ) cp++;
	}
d466 3
a468 2
cm_vsize( cmd, arg )
char *cmd, *arg;
d470 4
a473 1
	fget( &viewsize, arg, 1 );
d477 3
a479 2
cm_eyept( cmd, arg )
char *cmd, *arg;
d481 4
a484 1
	fget( eye_model, arg, 3 );
d488 3
a490 2
cm_vrot( cmd, arg )
char *cmd, *arg;
d492 6
a497 1
	fget( Viewrotscale, arg, 16 );
d501 3
a503 2
cm_end( cmd, arg )
char *cmd, *arg;
d505 11
a515 2
	if( do_frame( curframe ) < 0 )  return(-1);
	return(0);
d518 3
a520 2
cm_multiview( cmd, arg )
char *cmd, *arg;
d541 3
a543 2
cm_anim( cmd, arg )
char *cmd, *arg;
@


4.7
log
@Cleaned up parallel support code, moved some functions
into view.c
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.6 87/03/17 20:19:08 mike Locked $ (BRL)";
d99 3
a249 1
	static struct region *regp;
d260 2
a261 2
	if( optind+1 >= argc )  {
		fprintf(stderr,"database & object(s) list missing\n");
d273 3
d278 2
a280 2
	rt_prep_timer();		/* Start timing preparations */

d282 1
a282 1
	if( (rtip=rt_dirbuild(argv[optind++], idbuf, sizeof(idbuf))) == RTI_NULL ) {
a288 45
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	fprintf(stderr,"DB TOC: %s\n", outbuf);
	rt_prep_timer();

#ifdef never
/** experimental animation code ***/
{
	static struct directory *dir[4];
	static struct animate a;
	int k;
	dir[0] = rt_dir_lookup("tor.r", LOOKUP_NOISY);
	a.an_path = dir;
	a.an_pathlen = 1;
	a.an_type = AN_MATRIX;
	a.an_u.anu_m.anm_op = ANM_RMUL;
	mat_idn( a.an_u.anu_m.anm_mat );
	MAT_DELTAS( a.an_u.anu_m.anm_mat, 0, 60, 0 );
	k = rt_add_anim( rtip, &a );
	rt_log("return=%d\n", k);
	rt_pr_dir(rtip);
}
#endif

	/* Load the desired portion of the model */
	for( ; optind < argc; optind++ )  {
		if( rt_gettree(rtip, argv[optind]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[optind]);
	}
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	fprintf(stderr,"DB WALK: %s\n", outbuf);
#ifdef CRAY_COS
	remark(outbuf);		/* Info for JStat */
#endif CRAY_COS

	/* Allow library to prepare itself */
	rt_prep_timer();
	rt_prep(rtip);

	/* Initialize the material library for all regions */
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
		if( mlib_setup( regp ) == 0 )  {
			rt_log("mlib_setup failure on %s\n", regp->reg_name);
		}
	}

d308 2
a309 2
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	fprintf(stderr, "PREP: %s\n", outbuf );
d311 1
a311 17
	if( rtip->HeadSolid == SOLTAB_NULL )  {
		fprintf(stderr,"rt: No solids remain after prep.\n");
		exit(3);
	}
	fprintf(stderr,"shooting at %d solids in %d regions\n",
		rtip->nsolids, rtip->nregions );

	fprintf(stderr,"model X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
		rtip->mdl_min[X], rtip->mdl_max[X],
		rtip->mdl_min[Y], rtip->mdl_max[Y],
		rtip->mdl_min[Z], rtip->mdl_max[Z] );

	if(rdebug&RDEBUG_RTMEM)
		rt_g.debug |= DEBUG_MEM;

#ifdef PARALLEL
	/* Get enough dynamic memory to keep from making malloc sbrk() */
d317 2
d333 1
d335 1
d376 1
a376 2
 *  old format, handle processing of it.
 *  Returns 0 if new way, 1 if old way (and all done).
d523 22
d546 20
d575 1
a577 1
	char outbuf[132];
d579 1
d581 27
d654 1
d675 4
a678 2
	fprintf(stderr,"Dynamic memory use=%d.\n",sbrk(0)-beginptr );
	fprintf(stderr, "SHOT: %s\n", outbuf );
d684 3
a686 1
	fprintf(stderr,"%d pixels in %.2f sec = %.2f pixels/sec\n",
d688 2
a689 1
	fprintf(stderr,"Frame %d: %d rays in %.2f sec = %.2f rays/sec\n",
@


4.6
log
@Added multiple lights, added beginnings of command-driven
input capability.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.3 87/01/17 04:10:47 mike Exp $ (BRL)";
d88 1
a88 1
int		npsw = MAX_PSW;		/* number of worker PSWs to run */
d416 5
d648 5
a652 3
#ifndef PARALLEL
	view_end( &ap );		/* End of application */
#endif
a706 6

#ifdef PARALLEL
	/* No live fb display yet */
	if( fbp )
		fb_write( fbp, 0, 0, scanbuf, npts*npts );
#endif PARALLEL
@


4.5
log
@Changed so npsw=1 by default -- you need to ask for parallelism.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.4 87/02/13 00:02:00 mike Locked $ (BRL)";
d26 1
d81 1
a81 1
fastf_t		viewsize;
d88 1
a88 1
int		npsw = 1;		/* number of worker PSWs to run */
d95 1
a241 1
	static double utime;
a243 1
	char framename[128];		/* File name to hold current frame */
d246 1
a246 1
	int framenumber = 0;
d288 19
a388 1
do_more:
d390 5
a394 3
		vect_t	diag;
		mat_t	toEye;

d396 4
a399 11
		 *  Compute the rotation specified by the azimuth and
		 *  elevation parameters.  First, note that these are
		 *  specified relative to the GIFT "front view", ie,
		 *  model (X,Y,Z) is view (Z,X,Y):  looking down X axis.
		 *  Then, a positive azimuth represents rotating the *model*
		 *  around the Y axis, or, rotating the *eye* in -Y.
		 *  A positive elevation represents rotating the *model*
		 *  around the X axis, or, rotating the *eye* in -X.
		 *  This is the "Gwyn compatable" azim/elev interpretation.
		 *  Note that GIFT azim/elev values are the negatives of
		 *  this interpretation.
d401 17
a417 4
		mat_idn( Viewrotscale );
		mat_angles( Viewrotscale, 270.0-elevation, 0.0, 270.0+azimuth );
		fprintf(stderr,"Viewing %g azimuth, %g elevation off of front view\n",
			azimuth, elevation);
d419 24
a442 5
		/* Look at the center of the model */
		mat_idn( toEye );
		toEye[MDX] = -(rtip->mdl_max[X]+rtip->mdl_min[X])/2;
		toEye[MDY] = -(rtip->mdl_max[Y]+rtip->mdl_min[Y])/2;
		toEye[MDZ] = -(rtip->mdl_max[Z]+rtip->mdl_min[Z])/2;
d444 12
a455 4
		/* Fit a sphere to the model RPP, diameter is viewsize */
		VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
		viewsize = MAGNITUDE( diag );
		fprintf(stderr,"view size = %g\n", viewsize);
d457 16
a472 8
		Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
		mat_mul( model2view, Viewrotscale, toEye );
		mat_inv( view2model, model2view );
		VSET( temp, 0, 0, 1.414 );
		MAT4X3PNT( eye_model, view2model, temp );
	}  else  {
		register int i;
		char number[128];
d474 30
a503 13
		/* Visible part is from -1 to +1 in view space */
		if( fscanf( stdin, "%s", number ) != 1 )  goto out;
		viewsize = atof(number);
		if( fscanf( stdin, "%s", number ) != 1 )  goto out;
		eye_model[X] = atof(number);
		if( fscanf( stdin, "%s", number ) != 1 )  goto out;
		eye_model[Y] = atof(number);
		if( fscanf( stdin, "%s", number ) != 1 )  goto out;
		eye_model[Z] = atof(number);
		for( i=0; i < 16; i++ )  {
			if( fscanf( stdin, "%s", number ) != 1 )
				goto out;
			Viewrotscale[i] = atof(number);
d506 2
a507 1
	if( framenumber++ < desiredframe )  goto do_more;
d509 77
d589 1
a589 1
		sprintf( framename, "F%d", framenumber-1 );
d592 2
a593 2
			if( matflag )  goto do_more;
			exit(22);
d596 1
a596 1
		if( framenumber-1 <= 0 || outputfile[0] == '!' )  {
d599 1
a599 1
			sprintf( framename, "%s.%d", outputfile, framenumber-1 );
d602 1
a602 1
		if( framenumber-1 <= 0 )  {
d605 1
a605 1
			sprintf( framename, "%s.%d", outputfile, framenumber-1 );
d609 2
a610 2
			if( matflag )  goto do_more;
			exit(22);
d660 1
a660 1
		framenumber-1,
d673 2
a674 2
			fprintf(stderr,"fwrite failure\n");
			goto out;
d710 1
a710 1
#endif PARALLEL
d712 51
a762 14
	if( matflag )  goto do_more;
out:
	if( framenumber < desiredframe )  {
		fprintf(stderr,
			"rt:  Desired frame %d not reached, last was %d\n",
			desiredframe, framenumber);
	}
#ifdef HEP
	fprintf(stderr,"rt: killing workers\n");
	for( x=0; x<npsw; x++ )
		Diawrite( &work_word, -1 );
	fprintf(stderr,"rt: exit\n");
#endif
	return(0);
@


4.4
log
@Release 1.20 -- First Formal Release
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.3 87/01/17 04:10:47 mike Exp $ (BRL)";
d87 1
a87 1
int		npsw = MAX_PSW;		/* number of worker PSWs to run */
@


4.3
log
@Fixed auto-sizing and auto-positioning code in azim/elev case.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.2 87/01/07 07:14:55 mike Locked $ (BRL)";
@


4.2
log
@Added warning when desired frame not reached.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 4.1 86/12/29 03:48:38 mike Rel1 $ (BRL)";
d372 1
a372 2
		vect_t	view_min;	/* view position of rtip->mdl_min */
		vect_t	view_max;	/* view position of rtip->mdl_max */
a373 1
		fastf_t	f;
d375 13
d393 5
a397 6
		rt_viewbounds( view_min, view_max, Viewrotscale );
		viewsize = (view_max[X]-view_min[X]);
		f = (view_max[Y]-view_min[Y]);
		if( f > viewsize )  viewsize = f;
		f = (view_max[Z]-view_min[Z]);
		if( f > viewsize )  viewsize = f;
d399 5
a403 5
		/* First, go to view center, then back off for eye pos */
		mat_idn( toEye );
		toEye[MDX] = -(view_max[X]+view_min[X])/2;
		toEye[MDY] = -(view_max[Y]+view_min[Y])/2;
		toEye[MDZ] = -(view_max[Z]+view_min[Z])/2;
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.32 86/12/29 01:57:18 mike Locked $ (BRL)";
d548 5
@


3.32
log
@fb_write correct number of points, #ifdef'ed out parallel statistics code.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.31 86/12/28 16:55:48 mike Locked $ (BRL)";
@


3.31
log
@Added RDEBUG_RTMEM support,
made default npsw be MAX_PSW for general production use.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.30 86/12/24 08:57:01 mike Locked $ (BRL)";
d538 1
a538 1
		fb_write( fbp, 0, 0, scanbuf, npts*npts*3 );
d541 1
a541 1
#ifdef PARALLEL
@


3.30
log
@Neatened printf.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.29 86/12/24 08:30:58 mike Locked $ (BRL)";
d33 1
d87 1
a87 2
/* Eventually, npsw = MAX_PSW by default */
int		npsw = 1;		/* number of worker PSWs to run */
d343 3
@


3.29
log
@Updated for resource struct
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.28 86/12/18 16:01:55 mike Locked $ (BRL)";
d129 2
a130 1
		fprintf(stderr,"seg  len=%10d get=%10d free=%10d\n",
d132 2
a133 1
		fprintf(stderr,"part len=%10d get=%10d free=%10d\n",
d135 2
a136 1
		fprintf(stderr,"bitv len=%10d get=%10d free=%10d\n",
@


3.28
log
@rdebug.h separated from librt/debug.h
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.27 86/12/05 23:57:41 mike Locked $ (BRL)";
d88 1
a99 2
	"partition",
	"seg",
a100 2
	"printf",
	"bitv",
d105 4
d112 1
a112 1
	for( i=0; i<8; i++ )  {
d119 22
a260 2
	RES_INIT( &rt_g.res_pt );
	RES_INIT( &rt_g.res_seg );
a261 2
	RES_INIT( &rt_g.res_printf );
	RES_INIT( &rt_g.res_bitv );
d344 3
a346 3
		rt_get_pt(x);
		rt_get_seg(x);
		rt_get_bitv(x);
d537 1
d556 1
a556 1
	register int i = p - (&rt_g.res_pt);
d566 1
a566 1
	register int i = p - (&rt_g.res_pt);
d579 1
a579 1
	register int i = p - (&rt_g.res_pt);
d606 1
a606 1
	i = p - (&rt_g.res_pt);
@


3.27
log
@Several slightly ugly additions for running RT on COS.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.26 86/11/26 04:02:36 mike Locked $ (BRL)";
d26 1
d32 1
d52 2
d56 2
a62 1
int		hex_out = 0;	/* Binary or Hex .pix output file */
d96 22
d123 1
a123 1
	while( (c=getopt( argc, argv, "SH:F:D:MA:x:s:f:a:e:l:O:o:p:P:" )) != EOF )  {
d145 4
a148 1
			fprintf(stderr,"rt_g.debug=x%x\n", rt_g.debug);
a215 1
	static FILE *outfp = NULL;	/* optional pixel output file */
d241 1
a242 1
	RES_INIT( &rt_g.res_printf );
d273 3
a275 1
	rt_prep_timer();
d278 1
d284 1
a284 1
			rt_log("mlib_setup failure\n");
d325 3
a327 3
		rt_get_pt();
		rt_get_seg();
		rt_get_bitv();
d339 1
a339 1
		Dcreate( worker );
d431 1
a431 1
	view_2init( &ap, outfp );
d433 8
d471 1
a471 1
#ifdef PARALLEL
d479 2
d485 1
a485 6
#else
		if( write( fileno(outfp), scanbuf, npts*npts*3 ) != npts*npts*3 )  {
			perror("pixel output write");
			goto out;
		}
#endif CRAY_COS
d490 11
a500 4
		(void)DISPOSE( &status, "DN      ", dn,
			"TEXT    ", framename,
			"NOWAIT  ",
			"DF      ", "BB      " );
d502 3
a504 3
			"Dispose,dn='%s',text='%s',nowait,df=bb.  Status = 0%o (%s)",
			dn, framename, status,
			(status==0) ? "Good" : "---BAD---" );
d509 3
d514 1
d516 2
a517 3
#ifdef alliant
	alliant_pr();
#endif alliant
d532 3
a534 2
#ifndef PARALLEL
LOCKASGN(p)
d536 6
d543 2
a544 1
LOCKON(p)
d546 9
d556 2
a557 1
LOCKOFF(p)
d559 4
d564 6
a569 2
#endif
#endif
d572 2
a573 2
/* Horrible bug in 3.3.1 and 3.4 -- hypot ruins stack! */
double
a576 1
	extern double sqrt();
d582 2
a583 12
int alliant_tab[8];
char *all_title[8] = {
	"partition",
	"seg",
	"malloc",
	"printf",
	"bitv",
	"worker",
	"stats",
	"???"
};
alliant_pr()
d586 1
a586 5
	for( i=0; i<8; i++ )  {
		if(alliant_tab[i] == 0)  continue;
		fprintf(stderr,"%10d %s\n", alliant_tab[i], all_title[i]);
	}
}
a587 3
RES_ACQUIRE(p)
register int *p;
{
d590 1
a590 1
	while( *p )   {
d592 2
a593 4
		register int i;
		i = p - (&rt_g.res_pt);
		alliant_tab[i]++;	/* non-interlocked */
	}
@


3.26
log
@Added getopt flag for -x
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.25 86/11/25 04:07:51 mike Locked $ (BRL)";
d301 1
a301 1
#endif
d309 2
a310 2
#endif
#endif
d364 10
a373 1
		if( framenumber-1 <= 0 )
d375 1
a375 1
		else
d377 7
d390 2
a391 1
		fprintf(stderr,"Output file is %s\n", framename);
d432 32
a463 5
	{
	if( outfp != NULL &&
	    write( fileno(outfp), scanbuf, npts*npts*3 ) != npts*npts*3 )  {
		perror("pixel output write");
		goto out;
d467 1
a467 2
	}
#endif
d470 2
a471 1
#endif
a472 4
	if( outfp != NULL )  {
		(void)fclose(outfp);
		outfp = NULL;
	}
@


3.25
log
@Converted to getopt().
Moved fb_open back to rt.c
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.24 86/11/15 06:46:39 mike Locked $ (BRL)";
d96 1
a96 1
	while( (c=getopt( argc, argv, "SH:F:D:MA:s:f:a:e:l:O:o:p:P:" )) != EOF )  {
@


3.24
log
@sbrk typo.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.23 86/11/10 21:53:18 mike Locked $ (BRL)";
d29 1
a31 4
#ifdef PARALLEL
# include "fb.h"
#endif

d39 3
a41 1
extern char usage[];
d43 1
a43 3
extern void wray(), wraypts();
extern double atof();
extern char *sbrk();
d45 5
d51 7
a57 6
double AmbientIntensity = 0.4;	/* Ambient light intensity */
double azimuth, elevation;
int lightmodel;		/* Select lighting model */
mat_t view2model;
mat_t model2view;
int hex_out = 0;	/* Binary or Hex .pix output file */
d60 2
a61 2
extern void grid_setup();
extern void worker();
d64 12
a75 13
int	stereo = 0;	/* stereo viewing */
vect_t left_eye_delta;
int	hypersample=0;	/* number of extra rays to fire */
int	perspective=0;	/* perspective view -vs- parallel view */
vect_t	dx_model;	/* view delta-X as model-space vector */
vect_t	dy_model;	/* view delta-Y as model-space vector */
point_t	eye_model;	/* model-space location of eye */
point_t	viewbase_model;	/* model-space location of viewplane corner */
int npts;	/* # of points to shoot: x,y */
mat_t Viewrotscale;
mat_t toEye;
fastf_t viewsize;
fastf_t	zoomout=1;	/* >0 zoom out, 0..1 zoom in */
d78 1
a78 1
char *scanbuf;		/*** Output buffering, for parallelism */
d82 1
a82 1
int npsw = 1;		/* number of worker PSWs to run */
d85 5
a89 1
static char *beginptr;	/* sbrk() at start of program */
d91 2
a92 6
/*
 *			M A I N
 */
main(argc, argv)
int argc;
char **argv;
d94 1
a94 14
	static struct rt_i *rtip;
	static vect_t temp;
	static int matflag = 0;		/* read matrix from stdin */
	static double utime;
	char *title_file, *title_obj;	/* name of file and first object */
	char *outputfile = (char *)0;	/* name of base of output file */
	static FILE *outfp = NULL;	/* optional pixel output file */
	register int x,y;
	char framename[128];		/* File name to hold current frame */
	char outbuf[132];
	char idbuf[132];		/* First ID record info */
	int framenumber = 0;
	int desiredframe = 0;
	static struct region *regp;
d96 2
a97 13
	beginptr = sbrk(0);
	npts = 512;
	azimuth = -35.0;			/* GIFT defaults */
	elevation = -25.0;

	if( argc <= 1 )  {
		fprintf(stderr, usage);
		exit(1);
	}

	argc--; argv++;
	while( argc > 0 && argv[0][0] == '-' )  {
		switch( argv[0][1] )  {
d101 2
a102 2
		case 'h':
			hypersample = atoi( &argv[0][2] );
d105 1
a105 1
			desiredframe = atoi( &argv[0][2] );
d107 3
d114 1
a114 1
			AmbientIntensity = atof( &argv[0][2] );
d117 1
a117 1
			sscanf( &argv[0][2], "%x", &rt_g.debug );
d120 2
d123 2
a124 2
			/* "Fast" -- just a few pixels.  Or, arg's worth */
			npts = atoi( &argv[0][2] );
d126 1
d132 1
a132 1
			azimuth = atof( &argv[0][2] );
d137 1
a137 1
			elevation = atof( &argv[0][2] );
d142 1
a142 1
			lightmodel = atoi( &argv[0][2] );
d146 1
a146 1
			outputfile = argv[1];
a147 1
			argc--; argv++;
d151 2
a152 2
			outputfile = argv[1];
			argc--; argv++;
d156 1
a156 2
			if( argv[0][2] != '\0' )
				zoomout = atof( &argv[0][2] );
d161 3
a163 2
			npsw = atoi( &argv[0][2] );
			if( npsw < 1 || npsw > MAX_PSW )
d165 1
d167 3
a169 4
		default:
			fprintf(stderr,"rt:  Option '%c' unknown\n", argv[0][1]);
			fprintf(stderr, usage);
			break;
a170 1
		argc--; argv++;
d172 2
d175 27
a201 3
	if( argc < 2 )  {
		fprintf(stderr, usage);
		exit(2);
d203 6
d220 2
a221 2
	title_file = argv[0];
	title_obj = argv[1];
d226 1
a226 1
	if( (rtip=rt_dirbuild(argv[0], idbuf, sizeof(idbuf))) == RTI_NULL ) {
a231 1
	argc--; argv++;
d238 3
a240 4
	while( argc > 0 )  {
		if( rt_gettree(rtip, argv[0]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[0]);
		argc--; argv++;
d256 18
a273 2
	/* initialize application */
	view_init( &ap, title_file, title_obj, npts, outputfile!=(char *)0 );
d315 4
a318 3
		vect_t view_min;		/* view position of rtip->mdl_min */
		vect_t view_max;		/* view position of rtip->mdl_max */
		fastf_t f;
a415 1
		extern FBIO *fbp;
@


3.23
log
@Alliant resource locking additions
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.21 86/11/07 01:47:12 mike Locked $ (BRL)";
d46 1
a76 1
extern char *sbrk();
@


3.22
log
@Added missing extern in PARALLEL case
@
text
@d83 1
a83 2
extern int end;		/* Conventionally, end of initial memory */
static char *endptr = (char *)&end;
d107 1
d270 2
a271 1
	/* This isn't useful with the Caltech malloc() in most systems */
a281 1
	fprintf(stderr,"initial dynamic memory use=%d.\n",sbrk(0)-endptr );
d283 1
d373 1
d397 3
d442 20
d467 6
a472 1
	while( *p )  ;
@


3.21
log
@Changed to perform RT_HIT_NORM() macros where hit_point and hit_norm
are needed.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.20 86/10/28 23:25:25 mike Locked $ (BRL)";
d76 1
@


3.20
log
@Parallel reorganization
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.19 86/10/27 04:52:20 mike Locked $ (BRL)";
d82 3
d280 1
a280 1
	fprintf(stderr,"initial memory use=%d.\n",sbrk(0) );
@


3.19
log
@Changes inspired by the Alliant
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.18 86/10/26 18:37:50 mike Locked $ (BRL)";
a39 1
# define MAX_PSW 128
a68 2
int cur_pixel;		/* current pixel number, 0..last_pixel */
int last_pixel;		/* last pixel number */
a75 7
#ifdef cray
#define MAX_PSW		4
struct taskcontrol {
	int	tsk_len;
	int	tsk_id;
	int	tsk_value;
} taskcontrol[MAX_PSW];
d78 2
a79 4
#ifdef alliant
#define MAX_PSW	8
#endif
#endif
a81 5
static int npsw = 1;		/* number of worker PSWs to run */
#ifndef MAX_PSW
#define MAX_PSW 1
#endif

d195 3
a197 1
	RES_INIT( &rt_g.res_printf );	/* HACK: used by worker */
d270 2
a271 1
	fprintf(stderr,"PARALLEL: %d workers\n", npsw );
d273 1
a273 1
#ifdef HEP
d275 1
a276 5
#ifdef cray
		taskcontrol[x].tsk_len = 3;
		taskcontrol[x].tsk_value = x;
#endif
	}
a352 3
	cur_pixel = 0;
	last_pixel = npts*npts - 1;

d355 1
d357 3
a359 27
	rt_prep_timer();	/* start timing actual run */
#ifdef PARALLEL
#ifdef cray
	/* Create any extra worker tasks */
	for( x=0; x<npsw; x++ ) {
		TSKSTART( &taskcontrol[x], worker );
	}
	/* Wait for them to finish */
	for( x=0; x<npsw; x++ )  {
		TSKWAIT( &taskcontrol[x] );
	}
#endif
#ifdef alliant
	{
		asm("	cstart	_npsw");
		asm("super_loop:");
			asm("	cawait	cs1,#0");
			asm("	cadvance	cs1");
			worker();
		asm("	crepeat	super_loop");
	}
#endif
#else
	/* Simple serial case */
	worker();
#endif
	utime = rt_read_timer( outbuf, sizeof(outbuf) );	/* final time */
d443 1
@


3.18
log
@split off worker.c
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.17 86/10/12 00:20:44 mike Locked $ (BRL)";
d31 4
d131 1
a131 1
	while( argv[0][0] == '-' )  {
d280 2
d283 1
d295 1
a295 1
	fprintf(stderr,"creates done, DMend=%d.\n",sbrk(0) );
d331 1
a331 1
		if( scanf( "%s", number ) != 1 )  goto out;
d333 1
a333 1
		if( scanf( "%s", number ) != 1 )  goto out;
d335 1
a335 1
		if( scanf( "%s", number ) != 1 )  goto out;
d337 1
a337 1
		if( scanf( "%s", number ) != 1 )  goto out;
d340 1
a340 1
			if( scanf( "%s", number ) != 1 )
d424 4
a427 1
	if( write( fileno(outfp), scanbuf, npts*npts*3 ) != npts*npts*3 )  {
d431 3
a475 1
#ifdef PARALLEL
a476 1

d480 1
d485 1
d580 1
a580 2
#endif
#endif
@


3.17
log
@Added color aliasing prevention.
@
text
@d2 1
a2 1
 *			R T
d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.16 86/10/12 00:04:26 mike Locked $ (BRL)";
d53 5
a57 3
/***** variables shared with worker() */
static struct application ap;
static int	stereo = 0;	/* stereo viewing */
d59 2
a60 2
static int	hypersample=0;	/* number of extra rays to fire */
static int	perspective=0;	/* perspective view -vs- parallel view */
d63 3
a65 5
static point_t	eye_model;	/* model-space location of eye */
static point_t	viewbase_model;	/* model-space location of viewplane corner */
static int npts;	/* # of points to shoot: x,y */
int npsw = 1;		/* PARALLEL: number of worker PSWs to run */
void worker();
d68 4
d90 1
a107 1
	static float	zoomout=1;	/* >0 zoom out, 0..1 zoom in */
a112 3
	mat_t Viewrotscale;
	mat_t toEye;
	fastf_t viewsize;
d354 1
a354 42
	/* model2view takes us to eye_model location & orientation */
	mat_idn( toEye );
	toEye[MDX] = -eye_model[X];
	toEye[MDY] = -eye_model[Y];
	toEye[MDZ] = -eye_model[Z];
	Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
	mat_mul( model2view, Viewrotscale, toEye );
	mat_inv( view2model, model2view );

	/* Chop -1.0..+1.0 range into npts parts */
	VSET( temp, 2.0/npts, 0, 0 );
	MAT4X3VEC( dx_model, view2model, temp );
	VSET( temp, 0, 2.0/npts, 0 );
	MAT4X3VEC( dy_model, view2model, temp );
	if( stereo )  {
		/* Move left 2.5 inches (63.5mm) */
		VSET( temp, 2.0*(-63.5/viewsize), 0, 0 );
		rt_log("red eye: moving %f relative screen (left)\n", temp[X]);
		MAT4X3VEC( left_eye_delta, view2model, temp );
		VPRINT("left_eye_delta", left_eye_delta);
	}

	/* "Lower left" corner of viewing plane */
	if( perspective )  {
		VSET( temp, -1, -1, -zoomout );	/* viewing plane */
		/*
		 * Divergance is (0.5 * viewsize / npts) mm at
		 * a ray distance of (viewsize * zoomout) mm.
		 */
		ap.a_diverge = (0.5 / npts) / zoomout;
		ap.a_rbeam = 0;
	}  else  {
		VSET( temp, 0, 0, -1 );
		MAT4X3VEC( ap.a_ray.r_dir, view2model, temp );
		VUNITIZE( ap.a_ray.r_dir );

		VSET( temp, -1, -1, 0 );	/* eye plane */
		ap.a_rbeam = 0.5 * viewsize / npts;
		ap.a_diverge = 0;
	}
	MAT4X3PNT( viewbase_model, view2model, temp );

a435 115
}

#define CRT_BLEND(v)	(0.26*(v)[X] + 0.66*(v)[Y] + 0.08*(v)[Z])
#define NTSC_BLEND(v)	(0.30*(v)[X] + 0.59*(v)[Y] + 0.11*(v)[Z])

/*
 *  			W O R K E R
 *  
 *  Compute one pixel, and store it.
 */
void
worker()
{
	LOCAL struct application a;
	LOCAL vect_t point;		/* Ref point on eye or view plane */
	LOCAL vect_t colorsum;
	register int com;

	a.a_onehit = 1;
	while(1)  {
		RES_ACQUIRE( &rt_g.res_printf );	/* HACK */
		com = cur_pixel++;
		RES_RELEASE( &rt_g.res_printf );	/* HACK */

		if( com > last_pixel )  return;
		/* Note: ap.... not valid until first time here */
		a.a_x = com%npts;
		a.a_y = com/npts;
		a.a_hit = ap.a_hit;
		a.a_miss = ap.a_miss;
		a.a_rt_i = ap.a_rt_i;
		a.a_rbeam = ap.a_rbeam;
		a.a_diverge = ap.a_diverge;
		VSETALL( colorsum, 0 );
		for( com=0; com<=hypersample; com++ )  {
			if( hypersample )  {
				FAST fastf_t dx, dy;
				dx = a.a_x + rand_half();
				dy = a.a_y + rand_half();
				VJOIN2( point, viewbase_model,
					dx, dx_model, dy, dy_model );
			}  else  {
				VJOIN2( point, viewbase_model,
					a.a_x, dx_model,
					a.a_y, dy_model );
			}
			if( perspective )  {
				VSUB2( a.a_ray.r_dir,
					point, eye_model );
				VUNITIZE( a.a_ray.r_dir );
				VMOVE( a.a_ray.r_pt, eye_model );
			} else {
				VMOVE( a.a_ray.r_pt, point );
			 	VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );
			}
			a.a_level = 0;		/* recursion level */
			rt_shootray( &a );

			if( stereo )  {
				FAST fastf_t right,left;

				right = CRT_BLEND(a.a_color);

				VADD2(  point, point,
					left_eye_delta );
				if( perspective )  {
					VSUB2( a.a_ray.r_dir,
						point, eye_model );
					VUNITIZE( a.a_ray.r_dir );
					VMOVE( a.a_ray.r_pt, eye_model );
				} else {
					VMOVE( a.a_ray.r_pt, point );
				}
				a.a_level = 0;		/* recursion level */
				rt_shootray( &a );

				left = CRT_BLEND(a.a_color);
				VSET( a.a_color, left, 0, right );
			}
			VADD2( colorsum, colorsum, a.a_color );
		}
		if( hypersample )  {
			FAST fastf_t f;
			f = 1.0 / (hypersample+1);
			VSCALE( a.a_color, colorsum, f );
		}
#ifndef PARALLEL
		view_pixel( &a );
		if( a.a_x == npts-1 )
			view_eol( &a );		/* End of scan line */
#else
		{
			register char *pixelp;
			register int r,g,b;
			/* .pix files go bottom to top */
			pixelp = scanbuf+((a.a_y*npts)+a.a_x)*3;
			r = a.a_color[0]*255.+rand_half();
			g = a.a_color[1]*255.+rand_half();
			b = a.a_color[2]*255.+rand_half();
			/* Truncate glints, etc */
			if( r > 255 )  r=255;
			if( g > 255 )  g=255;
			if( b > 255 )  b=255;
			if( r<0 || g<0 || b<0 )  {
				rt_log("Negative RGB %d,%d,%d\n", r, g, b );
				r = 0x80;
				g = 0xFF;
				b = 0x80;
			}
			*pixelp++ = r ;
			*pixelp++ = g ;
			*pixelp++ = b ;
		}
#endif
	}
@


3.16
log
@Added Alliant support.

@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.15 86/10/11 01:49:53 mike Locked $ (BRL)";
d572 3
a574 3
			r = a.a_color[0]*255.;
			g = a.a_color[1]*255.;
			b = a.a_color[2]*255.;
@


3.15
log
@Fixed missing arg to fprintf
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.14 86/10/11 00:11:55 mike Locked $ (BRL)";
d79 3
d83 1
d422 10
d433 1
d616 107
@


3.14
log
@Converted to first quadrant coordinates
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.13 86/09/23 17:06:39 mike Locked $ (BRL)";
d229 1
a229 1
			fprintf("rt_gettree(%s) FAILED\n", argv[0]);
@


3.13
log
@Reformatted for better parallelism.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.12 86/08/12 05:50:53 mike Exp $ (BRL)";
d488 1
a488 1
		a.a_y = npts-1 - com/npts;
d499 1
a499 1
				dy = (npts-a.a_y-1) + rand_half();
a502 1
				register int yy = npts-a.a_y-1;
d505 1
a505 1
					yy, dy_model );
d556 1
a556 1
			pixelp = scanbuf+(((npts-a.a_y-1)*npts)+a.a_x)*3;
d590 11
@


3.12
log
@Changed to find #include files with CC -I../h
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.11 86/08/12 04:29:41 mike Exp $ (BRL)";
d35 2
d54 1
d64 1
a64 1
int npsw = 1;		/* HEP: number of worker PSWs to run */
d66 4
a69 2
int work_word;		/* semaphored (x<<16)|y */
#ifdef HEP
d71 7
d79 1
d82 4
a92 1
	static struct application ap;
d184 2
d199 6
a204 5
	RES_RELEASE( &rt_g.res_pt );
	RES_RELEASE( &rt_g.res_seg );
	RES_RELEASE( &rt_g.res_malloc );
	RES_RELEASE( &rt_g.res_bitv );
#ifdef HEP
d264 1
a264 4
#ifdef HEP
	(void)Disete( &work_word );
	if( npsw < 1 || npsw > 128 )
		npsw = 4;
d269 1
a269 1
		get_bitv();
d273 1
a273 1
	fprintf(stderr,"creating %d worker PSWs\n", npsw );
d275 7
a281 1
		Dcreate( worker, &ap );
d399 7
d407 11
a417 6

	for( y = npts-1; y >= 0; y--)  {
		for( x = 0; x < npts; x++)  {
#ifndef HEP
			work_word = (x<<16) | y;
			worker( &ap );
d419 1
a419 2
			/* Wait until empty, then fill */
			Diawrite( &work_word, (x<<16) | y );
a420 5
		}
#ifndef HEP
		view_eol( &ap );	/* End of scan line */
#endif
	}
d422 2
a423 1
#ifndef HEP
d441 1
a441 1
#ifdef HEP
d472 1
a472 2
worker( ap )
register struct application *ap;
a479 4
#ifndef HEP
	{
		com = work_word;
#else
d481 13
a493 11
		if( (com = Diaread( &work_word )) < 0 )
			return;
		/* Note: ap->... not valid until first time here */
#endif
		a.a_x = (com>>16)&0xFFFF;
		a.a_y = (com&0xFFFF);
		a.a_hit = ap->a_hit;
		a.a_miss = ap->a_miss;
		a.a_rt_i = ap->a_rt_i;
		a.a_rbeam = ap->a_rbeam;
		a.a_diverge = ap->a_diverge;
d515 1
a515 1
			 	VMOVE( a.a_ray.r_dir, ap->a_ray.r_dir );
d548 1
a548 1
#ifndef HEP
d550 2
d578 14
@


3.11
log
@Converted from scanf() to atof(), so that porting to systems
with broken scanf() can be accomplished by writing an atof() routine.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.10 86/08/07 20:42:55 mike Exp $ (BRL)";
d26 4
a29 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "mathtab.h"
@


3.10
log
@Added -S for Stereo (red/blue) image generation
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.9 86/08/06 05:38:58 mike Exp $ (BRL)";
d294 1
a294 1
		float d;
d297 8
a304 8
		if( scanf( "%f", &d ) != 1 )  goto out;
		viewsize = d;
		if( scanf( "%f", &d ) != 1 )  goto out;
		eye_model[X] = d;
		if( scanf( "%f", &d ) != 1 )  goto out;
		eye_model[Y] = d;
		if( scanf( "%f", &d ) != 1 )  goto out;
		eye_model[Z] = d;
d306 1
a306 1
			if( scanf( "%f", &d ) != 1 )
d308 1
a308 1
			Viewrotscale[i] = d;
a549 14

#ifdef CRAY_COS
/* Routines that seem to be missing under COS on the XMP. */
perror(str)
char *str;
{
	fprintf(stderr,"%s:  file access failure\n");
}
chmod(str,val)
char *str;
{
	;
}
#endif
@


3.9
log
@Added -O flag for ASCII output
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.8 86/07/31 05:37:45 mike Exp $ (BRL)";
d52 2
d108 3
d341 7
d434 3
d447 1
a447 1
	LOCAL vect_t tempdir;
d474 1
a474 1
				VJOIN2( a.a_ray.r_pt, viewbase_model,
d478 1
a478 1
				VJOIN2( a.a_ray.r_pt, viewbase_model,
d484 1
a484 1
					a.a_ray.r_pt, eye_model );
d488 1
a490 1

d493 22
d551 1
a551 1
#ifdef cray
@


3.8
log
@Changed %f to %g
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.7 86/07/29 20:22:32 mike Exp $ (BRL)";
d48 1
d143 6
d150 1
a150 1
			/* Output pixel file name */
d315 2
a316 1
			goto do_more;
@


3.7
log
@Moved initialization of materials to rt.c
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.6 86/07/24 06:05:23 mike Exp $ (BRL)";
d228 1
a228 1
	fprintf(stderr,"model X(%f,%f), Y(%f,%f), Z(%f,%f)\n",
d260 1
a260 1
		fprintf(stderr,"Viewing %f azimuth, %f elevation off of front view\n",
@


3.6
log
@Added uvcoord code, conical ray divergance.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.5 86/07/22 04:32:20 mike Exp $ (BRL)";
d29 1
d91 1
d208 7
d425 1
d445 1
d447 12
a458 4
			/* NEED to multiply a_x,y by +/-0.5 for dithering!! */
			VJOIN2( a.a_ray.r_pt, viewbase_model,
				a.a_x, dx_model, 
				(npts-a.a_y-1), dy_model );
d470 7
d478 1
a478 1
			view_pixel( &a );
d480 17
a496 21
			{
				register char *pixelp;
				register int r,g,b;
				/* .pix files go bottom to top */
				pixelp = scanbuf+(((npts-a.a_y-1)*npts)+a.a_x)*3;
				r = a.a_color[0]*255.;
				g = a.a_color[1]*255.;
				b = a.a_color[2]*255.;
				/* Truncate glints, etc */
				if( r > 255 )  r=255;
				if( g > 255 )  g=255;
				if( b > 255 )  b=255;
				if( r<0 || g<0 || b<0 )  {
					rt_log("Negative RGB %d,%d,%d\n", r, g, b );
					r = 0x80;
					g = 0xFF;
					b = 0x80;
				}
				*pixelp++ = r ;
				*pixelp++ = g ;
				*pixelp++ = b ;
d498 4
a502 1
		}
@


3.5
log
@Minor improvements
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.4 86/07/19 04:39:09 mike Exp $ (BRL)";
a313 3
	fprintf(stderr,"Deltas=%f (model units between rays)\n",
		viewsize/npts );

d323 6
d335 2
d340 3
d433 2
@


3.4
log
@Added rt_i support
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.3 86/07/18 00:22:25 mike Exp $ (BRL)";
d50 1
d103 3
d122 1
a122 1
			if( npts < 2 || npts > 1024 )  {
d425 13
a437 11
		VJOIN2( a.a_ray.r_pt, viewbase_model,
			a.a_x, dx_model, 
			(npts-a.a_y-1), dy_model );
		if( perspective )  {
			VSUB2( a.a_ray.r_dir,
				a.a_ray.r_pt, eye_model );
			VUNITIZE( a.a_ray.r_dir );
			VMOVE( a.a_ray.r_pt, eye_model );
		} else {
		 	VMOVE( a.a_ray.r_dir, ap->a_ray.r_dir );
		}
d439 2
a440 2
		a.a_level = 0;		/* recursion level */
		rt_shootray( &a );
d442 1
a442 1
		view_pixel( &a );
d444 21
a464 17
		{
			register char *pixelp;
			register int r,g,b;
			/* .pix files go bottom to top */
			pixelp = scanbuf+(((npts-a.a_y-1)*npts)+a.a_x)*3;
			r = a.a_color[0]*255.;
			g = a.a_color[1]*255.;
			b = a.a_color[2]*255.;
			/* Truncate glints, etc */
			if( r > 255 )  r=255;
			if( g > 255 )  g=255;
			if( b > 255 )  b=255;
			if( r<0 || g<0 || b<0 )  {
				rt_log("Negative RGB %d,%d,%d\n", r, g, b );
				r = 0x80;
				g = 0xFF;
				b = 0x80;
d466 1
a466 3
			*pixelp++ = r ;
			*pixelp++ = g ;
			*pixelp++ = b ;
a467 1
#endif
@


3.3
log
@Error checking added.
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.2 86/07/17 18:45:31 mike Exp $ (BRL)";
d72 1
d177 1
a177 1
	if( rt_dirbuild( argv[0], idbuf, sizeof(idbuf) ) < 0 )  {
d181 1
d191 1
a191 1
		if( rt_gettree(argv[0]) < 0 )
d200 1
a200 1
	rt_prep();
d208 1
a208 1
	if( rt_i.HeadSolid == SOLTAB_NULL )  {
d213 1
a213 1
		rt_i.nsolids, rt_i.nregions );
d216 3
a218 3
		rt_i.mdl_min[X], rt_i.mdl_max[X],
		rt_i.mdl_min[Y], rt_i.mdl_max[Y],
		rt_i.mdl_min[Z], rt_i.mdl_max[Z] );
d241 2
a242 2
		vect_t view_min;		/* view position of rt_i.mdl_min */
		vect_t view_max;		/* view position of rt_i.mdl_max */
d362 1
a362 1
		rt_i.nshots, rt_i.nhits, rt_i.nmiss );
d364 5
a368 3
		rt_i.nshots>0?((double)rt_i.nhits*100.0)/rt_i.nshots:100.0,
		rt_i.nmiss_model, rt_i.nmiss_tree, rt_i.nmiss_solid );
	fprintf(stderr,"Frame %d: %d output rays in %f sec = %f rays/sec\n",
d370 1
a370 1
		npts*npts, utime, (double)(npts*npts/utime) );
d420 1
@


3.2
log
@Conversion to stdio
@
text
@d22 1
a22 1
static char RCSrt[] = "@@(#)$Header: rt.c,v 3.1 86/06/17 21:13:54 mike Exp $ (BRL)";
d189 2
a190 1
		(void)rt_gettree(argv[0]);
@


3.1
log
@To humor the SGI "long float" peculiarity,
the scanf()s are done into floats now.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 3.0 86/06/10 01:32:21 mike Exp $ (BRL)";
d38 1
d78 1
a78 1
	static int outfd = -1;		/* fd of optional pixel output file */
d290 1
a290 1
		if( (outfd = creat( framename, 0444 )) <= 0 )  {
d294 1
d329 1
a329 1
	view_2init( &ap, outfd );
d367 1
a367 1
	if( write( outfd, scanbuf, npts*npts*3 ) != npts*npts*3 )  {
d373 4
a376 2
	(void)close(outfd);
	outfd = -1;
d457 14
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.16 86/06/09 21:49:13 mike Exp $ (BRL)";
d265 1
a265 1
		double d;
d268 1
a268 1
		if( scanf( "%lf", &d ) != 1 )  goto out;
d270 1
a270 1
		if( scanf( "%lf", &d ) != 1 )  goto out;
d272 1
a272 1
		if( scanf( "%lf", &d ) != 1 )  goto out;
d274 1
a274 1
		if( scanf( "%lf", &d ) != 1 )  goto out;
d277 1
a277 1
			if( scanf( "%lf", &d ) != 1 )
@


2.16
log
@rt and librt separated
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.15 86/06/09 20:41:53 mike Exp $ (BRL)";
a28 1
extern int debug;
d110 2
a111 2
			sscanf( &argv[0][2], "%x", &debug );
			fprintf(stderr,"debug=x%x\n", debug);
d161 4
a164 4
	RES_RELEASE( &res_pt );
	RES_RELEASE( &res_seg );
	RES_RELEASE( &res_malloc );
	RES_RELEASE( &res_bitv );
d166 1
a166 1
	scanbuf = vmalloc( npts*npts*3 + sizeof(long), "scanbuf" );
d172 1
a172 1
	prep_timer();		/* Start timing preparations */
d175 2
a176 2
	if( dir_build( argv[0], idbuf, sizeof(idbuf) ) < 0 )  {
		fprintf(stderr,"rt:  dir_build failure\n");
d182 1
a182 1
	(void)read_timer( outbuf, sizeof(outbuf) );
d184 1
a184 1
	prep_timer();
d188 1
a188 1
		(void)get_tree(argv[0]);
d191 1
a191 1
	(void)read_timer( outbuf, sizeof(outbuf) );
d193 1
a193 1
	prep_timer();
d201 1
a201 1
	(void)read_timer( outbuf, sizeof(outbuf) );
d204 1
a204 1
	if( HeadSolid == SOLTAB_NULL )  {
d209 1
a209 1
		nsolids, nregions );
d212 3
a214 3
		mdl_min[X], mdl_max[X],
		mdl_min[Y], mdl_max[Y],
		mdl_min[Z], mdl_max[Z] );
d222 2
a223 2
		get_pt();
		get_seg();
d226 1
a226 1
	vfree( vmalloc( (20+npsw)*8192, "worker prefetch"), "worker");
d237 2
a238 2
		vect_t view_min;		/* view position of mdl_min */
		vect_t view_max;		/* view position of mdl_max */
d246 1
a246 1
		viewbounds( view_min, view_max, Viewrotscale );
d331 1
a331 1
	prep_timer();	/* start timing actual run */
d347 1
a347 1
	utime = read_timer( outbuf, sizeof(outbuf) );	/* final time */
d357 1
a357 1
		nshots, nhits, nmiss );
d359 2
a360 2
		nshots>0?((double)nhits*100.0)/nshots:100.0,
		nmiss_model, nmiss_tree, nmiss_solid );
d424 1
a424 1
		shootray( &a );
d441 1
a441 1
				rtlog("Negative RGB %d,%d,%d\n", r, g, b );
@


2.15
log
@Minor changes.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.14 86/06/05 23:15:49 mike Exp $ (BRL)";
d28 2
a29 2
#include "raytrace.h"
#include "debug.h"
@


2.14
log
@Fix from Stephen Willson <willson@@nrtc.arpa> for scanf() into doubles.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.13 85/11/20 17:06:15 mike Exp $ (BRL)";
d51 2
a52 2
static vect_t	dx_model;	/* view delta-X as model-space vector */
static vect_t	dy_model;	/* view delta-Y as model-space vector */
d315 1
a315 1
	/* "Upper left" corner of viewing plane */
@


2.13
log
@Fixed small bug with invoking RT with no args.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.12 85/09/24 18:35:05 mike Exp $ (BRL)";
d266 1
d269 10
a278 6
		if( scanf( "%f", &viewsize ) != 1 )  goto out;
		if( scanf( "%f", &eye_model[X] ) != 1 )  goto out;
		if( scanf( "%f", &eye_model[Y] ) != 1 )  goto out;
		if( scanf( "%f", &eye_model[Z] ) != 1 )  goto out;
		for( i=0; i < 16; i++ )
			if( scanf( "%f", &Viewrotscale[i] ) != 1 )
d280 2
@


2.12
log
@Changed to match new calling sequence to dir_build().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.11 85/09/18 01:27:12 mike Exp $ (BRL)";
d93 1
a93 1
	if( argc < 1 )  {
@


2.11
log
@Changed shootray() to have bitvector free queues, rather than
calling vmalloc() and vfree() all the time.  While not too costly
on serial machines, this is inside the critical section on parallel
machines like the HEP, and was a serious performance bottleneck.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.10 85/09/15 09:17:56 mike Exp $ (BRL)";
d82 1
d176 1
a176 1
	if( dir_build( argv[0], 1 ) < 0 )  {
d180 1
@


2.10
log
@Modified handling of "-o" so that each frame of a multi-frame
sequence is stored in a separate file.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.8 85/09/11 23:50:16 mike Exp $ (BRL)";
d164 1
d223 1
@


2.9
log
@Added frame numbering capability.
@
text
@d33 2
d76 1
d78 1
a78 1
	static int outfd;		/* fd of optional pixel output file */
d80 1
d136 1
a136 4
			if( (outfd = creat( argv[1], 0444 )) <= 0 )  {
				perror( argv[1] );
				exit(10);
			}
d197 1
a197 1
	view_init( &ap, title_file, title_obj, npts, outfd );
d218 7
a224 1
	vfree( vmalloc( (20+npsw)*2048, "worker prefetch"), "worker");
d229 1
a229 1
	fprintf(stderr,"creates done\n");
d274 12
d317 1
a317 1
	view_2init( &ap );
d351 1
a351 1
	fprintf(stderr,"Frame %d:  %d output rays in %f sec = %f rays/sec\n",
d357 1
a357 1
		exit(1);
d361 2
@


2.8
log
@Version which reads newer input files:  viewsize, eye_model position,
and rotation matrix for view direction.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.7 85/09/11 20:23:13 mike Exp $ (BRL)";
d81 2
d96 3
d265 2
d332 2
a333 1
	fprintf(stderr,"%d output rays in %f sec = %f rays/sec\n",
@


2.7
log
@Minor cleanups.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.6 85/09/11 19:40:09 mike Exp $ (BRL)";
d78 3
a223 1
		mat_t Viewrot, toViewcenter;
a224 1
		fastf_t viewsize;
d226 2
a227 7
		/*
		 * Unrotated view is TOP.
		 * Rotation of 270,0,270 takes us to a front view.
		 * Standard GIFT view is -35 azimuth, -25 elevation off front.
		 */
		mat_idn( Viewrot );
		mat_angles( Viewrot, 270.0-elevation, 0.0, 270.0+azimuth );
d231 1
a231 1
		viewbounds( view_min, view_max, Viewrot );
d238 10
a247 7
		mat_idn( toViewcenter );
		toViewcenter[MDX] = -(view_max[X]+view_min[X])/2;
		toViewcenter[MDY] = -(view_max[Y]+view_min[Y])/2;
		toViewcenter[MDZ] = -(view_max[Z]+view_min[Z])/2;

		mat_mul( model2view, Viewrot, toViewcenter );
		model2view[15] = 0.5*viewsize;	/* Viewscale */
d252 4
d257 1
a257 1
			if( scanf( "%f", &model2view[i] ) != 1 )
d260 7
d270 1
a270 1
		model2view[15]*2/npts );
a277 3
	VSET( temp, 0, 0, zoomout );
	MAT4X3PNT( eye_model, view2model, temp );	/* perspective only */

d280 1
a280 1
		VSET( temp, -1, -1, 0 );	/* viewing plane */
d286 1
a286 1
		VSET( temp, -1, -1, 1.1 );	/* eye plane */
d323 1
a323 1
		((double)nhits*100.0)/nshots,
a371 1
	 	VMOVE( a.a_ray.r_dir, ap->a_ray.r_dir );
d380 2
@


2.6
log
@Accomodates new timer interface.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.5 85/09/11 01:17:59 mike Exp $ (BRL)";
d210 1
a210 1
	rtlog("creating %d worker PSWs\n", npsw );
d214 1
a214 1
	rtlog("creates done\n");
a261 4
	VSET( temp, 0, 0, -1 );
	MAT4X3VEC( ap.a_ray.r_dir, view2model, temp );
	VUNITIZE( ap.a_ray.r_dir );

d275 4
@


2.5
log
@Minor reogranization for parallel operation.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.4 85/09/10 01:06:07 mike Exp $ (BRL)";
d74 2
a75 2
	float	zoomout=1;	/* >0 zoom out factor, 0..1 zoom in factor */
	static int outfd;	/* fd of optional pixel output file */
d77 1
d171 2
a172 1
	(void)pr_timer("DB TOC");
d180 2
a181 1
	(void)pr_timer("DB WALK");
d190 2
a191 1
	(void)pr_timer("PREP");
d255 1
a255 1
				exit(0);
d304 1
a306 2
#else
	write( outfd, scanbuf, npts*npts*3 );
d312 2
a313 2
	utime = pr_timer("SHOT");
	fprintf(stderr,"ft_shot(): %ld = %ld hits + %ld miss\n",
d315 2
a316 1
	fprintf(stderr,"pruned:  %ld model RPP, %ld sub-tree RPP, %ld solid RPP\n",
a317 2
	fprintf(stderr,"pruning efficiency %.1f%%\n",
		((double)nhits*100.0)/nshots );
d320 6
d328 7
d357 2
a358 1
		com = Diaread( &work_word );
@


2.4
log
@Moved eye plane back slightly in non-perspective view
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.3 85/09/10 00:33:30 mike Exp $ (BRL)";
a335 3
	VMOVE( a.a_ray.r_dir, ap->a_ray.r_dir );
	a.a_hit = ap->a_hit;
	a.a_miss = ap->a_miss;
d343 1
d347 3
@


2.3
log
@Merged in code for parallel execution from HEP
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.2 85/09/06 02:29:25 mike Exp $ (BRL)";
d275 1
a275 1
		VSET( temp, -1, -1, 1 );	/* eye plane */
@


2.2
log
@Changed rtbomb calls to normal fprintf() output, with exit().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.1 85/08/31 06:06:08 mike Exp $ (BRL)";
d31 4
d40 1
a40 1
double AmbientIntensity = 0.3;	/* Ambient light intensity */
d47 15
a73 1
	int	perspective=0;	/* perspective view -vs- parallel view */
a74 4
	vect_t	dx_model;	/* view delta-X as model-space vector */
	vect_t	dy_model;	/* view delta-Y as model-space vector */
	point_t	eye_model;	/* model-space location of eye */
	point_t	viewbase_model;	/* model-space location of viewplane corner */
d76 1
a76 1
	static int npts;	/* # of points to shoot: x,y */
d135 4
d151 6
d201 12
d286 9
a294 15
	for( ap.a_y = npts-1; ap.a_y >= 0; ap.a_y--)  {
		for( ap.a_x = 0; ap.a_x < npts; ap.a_x++)  {
			VJOIN2( ap.a_ray.r_pt, viewbase_model,
				ap.a_x, dx_model, 
				(npts-ap.a_y-1), dy_model );
			if( perspective )  {
				VSUB2( ap.a_ray.r_dir,
					ap.a_ray.r_pt, eye_model );
				VUNITIZE( ap.a_ray.r_dir );
				VMOVE( ap.a_ray.r_pt, eye_model );
			}

			ap.a_level = 0;		/* recursion level */
			shootray( &ap );
			view_pixel( &ap );
d296 1
d298 1
d300 1
d302 3
d321 67
@


2.1
log
@Version 2 of RT
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.34 85/07/30 05:55:06 mike Exp $ (BRL)";
d36 1
a36 1
double AmbientIntensity = 0.1;	/* Ambient light intensity */
d140 4
a143 2
	if( dir_build( argv[0], 1 ) < 0 )
		rtbomb("Unable to continue");
d166 2
a167 2
		rtbomb("No solids remain after prep.\n");
		/* NOTREACHED */
@


1.34
log
@Changes for merged GED & RT vmath.h
@
text
@d6 2
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.33 85/07/30 02:02:41 mike Exp $ (BRL)";
d31 1
a31 3
static char usage[] = "\
Usage:  rt [options] model.vg object [objects]\n\
Options:  -f[#] -x# -aAz -eElev -A%Ambient -l# [-o model.pix]\n";
a32 3
/* Used for autosizing */
static vect_t base;		/* view position of mdl_min */
static fastf_t deltas;		/* distance between rays */
a36 4
vect_t l0vec;			/* 0th light vector */
vect_t l1vec;			/* 1st light vector */
vect_t l2vec;			/* 2st light vector */
vect_t l0pos;			/* 0th light position */
a37 2
int outfd;		/* fd of optional pixel output file */
FILE *outfp;		/* used to write .PP files */
d39 2
a40 1
int npts;		/* # of points to shoot: x,y */
d51 1
a51 3
	static mat_t view2model;
	static mat_t model2view;
	static vect_t tempdir;
d55 8
d115 6
d144 3
d152 2
d155 2
a156 3
	/* initialize application based upon lightmodel # */
	view_init( &ap );
	ap.a_init( &ap, title_file, title_obj );
d158 3
d164 2
a165 2
		fprintf(stderr, "No solids remain after prep, exiting.\n");
		exit(11);
a169 3
	/* Set up the online display and/or the display file */
	dev_setup(npts);

d175 1
d177 6
d188 2
a189 2
		mat_idn( model2view );
		mat_angles( model2view, 270.0-elevation, 0.0, 270.0+azimuth );
a191 1
		mat_inv( view2model, model2view );
d193 14
a206 2
		autosize( model2view, npts );
		VSET( tempdir, 0, 0, -1 );
d208 1
a208 1
		static int i;
d210 1
a210 1
		/* Visible part is from -1 to +1 */
d212 2
a213 6
			scanf( "%f", &model2view[i] );

		base[X] = base[Y] = base[Z] = -1;
		deltas = 2.0 / ((double)npts);
		mat_inv( view2model, model2view );
		VSET( tempdir, 0, 0, -1 );
d215 1
d217 5
a221 1
	MAT4X3VEC( ap.a_ray.r_dir, view2model, tempdir );
d224 5
a228 1
	MAT4X3PNT( ap.a_ray.r_pt, view2model, base );
d230 2
a231 1
	fprintf(stderr,"Ambient light at %f%%\n", AmbientIntensity * 100.0 );
d233 5
a237 24
	if( lightmodel != 0 )  {
		/* Determine the Light location(s) in view space */
		/* lightmodel 0 does this in view.c */
		/* 0:  Blue, at left edge, 1/2 high */
		tempdir[0] = 2 * (base[X]);
		tempdir[1] = (2/2) * (base[Y]);
		tempdir[2] = 2 * (base[Z] + npts*deltas);
		MAT4X3VEC( l0pos, view2model, tempdir );
		VMOVE( l0vec, l0pos );
		VUNITIZE(l0vec);

		/* 1: Red, at right edge, 1/2 high */
		tempdir[0] = 2 * (base[X] + npts*deltas);
		tempdir[1] = (2/2) * (base[Y]);
		tempdir[2] = 2 * (base[Z] + npts*deltas);
		MAT4X3VEC( l1vec, view2model, tempdir );
		VUNITIZE(l1vec);

		/* 2:  Grey, behind, and overhead */
		tempdir[0] = 2 * (base[X] + (npts/2)*deltas);
		tempdir[1] = 2 * (base[Y] + npts*deltas);
		tempdir[2] = 2 * (base[Z] + (npts/2)*deltas);
		MAT4X3VEC( l2vec, view2model, tempdir );
		VUNITIZE(l2vec);
d239 1
d241 2
a242 1
	prep_timer();	/* start timing actual run */
d244 1
d246 1
d250 9
a258 5
			VSET( tempdir,
				base[X] + ap.a_x * deltas,
				base[Y] + (npts-ap.a_y-1) * deltas,
				base[Z] +  2*npts*deltas );
			MAT4X3PNT( ap.a_ray.r_pt, view2model, tempdir );
d260 1
d262 1
d264 1
a264 1
		ap.a_eol( &ap );	/* End of scan line */
d266 1
a266 1
	ap.a_end( &ap );		/* End of application */
d280 2
a282 68
}

/*
 *			A U T O S I Z E
 */
autosize( m2v, n )
matp_t m2v;
int n;
{
	register struct soltab *stp;
	static fastf_t xmin, xmax;
	static fastf_t ymin, ymax;
	static fastf_t zmin, zmax;
	static vect_t xlated;
	vect_t top;
	FAST double f;

#ifdef later
	/* NEW WAY */
	/* Need to find all 8 corners of (rotated) model bounding RPP */
	MAT4X3PNT( base, m2v, mdl_min );
	MAT4X3PNT( top, m2v, mdl_max );

	deltas = (top[X]-base[X])/n;
	f = (top[Y]-base[Y])/n;
	if( f > deltas )  deltas = f;
	fprintf(stderr,"Nview  X(%f,%f), Y(%f,%f), Z(%f,%f)\n",
		base[X], top[X],
		base[Y], top[Y],
		base[Z], top[Z] );
	fprintf(stderr,"NDeltas=%f (units between rays)\n", deltas );
#endif

	/* OLD WAY */
	/* init maxima and minima */
	xmax = ymax = zmax = -100000000.0;
	xmin = ymin = zmin =  100000000.0;

	for( stp=HeadSolid; stp != 0; stp=stp->st_forw ) {
		FAST fastf_t rad;

		rad = sqrt(stp->st_radsq);
		MAT4X3PNT( xlated, m2v, stp->st_center );
#define MIN(v,t) {FAST fastf_t rt; rt=(t); if(rt<v) v = rt;}
#define MAX(v,t) {FAST fastf_t rt; rt=(t); if(rt>v) v = rt;}
		MIN( xmin, xlated[0]-rad );
		MAX( xmax, xlated[0]+rad );
		MIN( ymin, xlated[1]-rad );
		MAX( ymax, xlated[1]+rad );
		MIN( zmin, xlated[2]-rad );
		MAX( zmax, xlated[2]+rad );
	}

	/* Provide a slight border */
	xmin -= xmin * 0.03;
	ymin -= ymin * 0.03;
	zmin -= zmin * 0.03;
	xmax *= 1.03;
	ymax *= 1.03;
	zmax *= 1.03;

	VSET( base, xmin, ymin, zmin );

	deltas = (xmax-xmin)/n;
	MAX( deltas, (ymax-ymin)/n );
	fprintf(stderr,"view X(%f,%f), Y(%f,%f), Z(%f,%f)\n",
		xmin, xmax, ymin, ymax, zmin, zmax );
	fprintf(stderr,"Deltas=%f (units between rays)\n", deltas );
@


1.33
log
@Added "noisy" arg to dir_build() to control printout.
per Moss.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.32 85/06/05 00:26:16 mike Exp $ (BRL)";
d24 2
a25 1
#include "vmath.h"
d275 1
d277 1
d284 1
a284 1
	fprintf(stderr,"view  X(%f,%f), Y(%f,%f), Z(%f,%f)\n",
d288 2
a289 1
	fprintf(stderr,"Deltas=%f (units between rays)\n", deltas );
d323 1
a323 1
	fprintf(stderr,"Oview X(%f,%f), Y(%f,%f), Z(%f,%f)\n",
d325 1
a325 1
	fprintf(stderr,"ODeltas=%f (units between rays)\n", deltas );
@


1.32
log
@timer_print, timer_prep changed to prep_timer, pr_timer
to accomodate compilers that only look at the first 8 chars.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.31 85/06/04 23:24:38 mike Exp $ (BRL)";
d135 1
a135 1
	if( dir_build( argv[0] ) < 0 )
d258 1
a258 1
#ifdef never
d263 1
a263 1
register matp_t m2v;
d267 4
d272 1
a272 1
	double f;
d274 1
a285 2
}
#else
d287 1
a287 13
/*
 *			A U T O S I Z E
 */
autosize( m2v, n )
matp_t m2v;
int n;
{
	register struct soltab *stp;
	static fastf_t xmin, xmax;
	static fastf_t ymin, ymax;
	static fastf_t zmin, zmax;
	static vect_t xlated;

d319 1
a319 1
	fprintf(stderr,"view X(%f,%f), Y(%f,%f), Z(%f,%f)\n",
d321 1
a321 1
	fprintf(stderr,"Deltas=%f (units between rays)\n", deltas );
a322 1
#endif
@


1.31
log
@Various little changed needed to make the HEP version work.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.30 85/03/25 12:00:59 mike Exp $ (BRL)";
d132 1
a132 1
	timer_prep();		/* Start timing preparations */
d149 1
a149 1
	(void)timer_print("PREP");
d226 1
a226 1
	timer_prep();	/* start timing actual run */
d247 1
a247 1
	utime = timer_print("SHOT");
@


1.30
log
@Purged QUICKIE option
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.29 85/03/25 11:46:46 mike Exp $ (BRL)";
d33 1
a33 1
static vect_t base;		/* view position of model_min */
d162 3
a164 3
		model_min[X], model_max[X],
		model_min[Y], model_max[Y],
		model_min[Z], model_max[Z] );
d270 2
a271 2
	MAT4X3PNT( base, m2v, model_min );
	MAT4X3PNT( top, m2v, model_max );
@


1.29
log
@Housekeeping
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.28 85/02/07 19:19:36 mike Exp $ (BRL)";
d159 1
a159 2
	if( !(debug&DEBUG_QUICKIE) )
		dev_setup(npts);
d178 1
a178 2
		if( !(debug&DEBUG_QUICKIE) )  {
			autosize( model2view, npts );
a179 8
		} else {
			base[X] = -3;
			base[Y] = -3;
			base[Z] = -10;
			deltas = 1;
			npts = 8;
			VSET( tempdir, 0, 0, 1 );
		}
@


1.28
log
@Reorganized for lighting model improvements
@
text
@d4 2
a5 1
 * Ray Tracing program
d7 1
a7 1
 * Author -
d10 8
a17 4
 *	U. S. Army Ballistic Research Laboratory
 *	March 27, 1984
 *
 * $Revision: 1.27 $
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.27 84/11/30 04:04:13 mike Exp $ (BRL)";
@


1.27
log
@Added more statistics on success of pruning algorithm.
@
text
@d12 1
a12 1
 * $Revision: 1.26 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.26 84/11/29 07:04:33 mike Exp $ (BRL)";
d37 1
d58 1
d124 2
a125 3
	/* initialize application based upon lightmodel # */
	view_init( &ap );
	ap.a_init( &ap, argv[0], argv[1] );
d130 2
a131 1
	dir_build( argv[0] );
d136 1
a136 1
		get_tree(argv[0]);
d139 5
d205 10
a214 7
	/* Determine the Light location(s) in view space */
	/* 0:  Blue, at left edge, 1/2 high */
	tempdir[0] = 2 * (base[X]);
	tempdir[1] = (2/2) * (base[Y]);
	tempdir[2] = 2 * (base[Z] + npts*deltas);
	MAT4X3VEC( l0vec, view2model, tempdir );
	VUNITIZE(l0vec);
d216 6
a221 6
	/* 1: Red, at right edge, 1/2 high */
	tempdir[0] = 2 * (base[X] + npts*deltas);
	tempdir[1] = (2/2) * (base[Y]);
	tempdir[2] = 2 * (base[Z] + npts*deltas);
	MAT4X3VEC( l1vec, view2model, tempdir );
	VUNITIZE(l1vec);
d223 7
a229 6
	/* 2:  Grey, behind, and overhead */
	tempdir[0] = 2 * (base[X] + (npts/2)*deltas);
	tempdir[1] = 2 * (base[Y] + npts*deltas);
	tempdir[2] = 2 * (base[Z] + (npts/2)*deltas);
	MAT4X3VEC( l2vec, view2model, tempdir );
	VUNITIZE(l2vec);
@


1.26
log
@Random changes.
@
text
@d12 1
a12 1
 * $Revision: 1.25 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.25 84/11/27 06:59:47 mike Exp $ (BRL)";
d56 1
d241 9
a249 10
	{
		FAST double utime;
		utime = timer_print("SHOT");
		fprintf(stderr,"%ld calls to ft_shot(), %ld calls pruned\n",
			nshots, (long)nmiss );
		fprintf(stderr,"%ld calls in %f sec = %f calls/sec\n",
			nshots, utime, (double)(nshots/utime) );
		fprintf(stderr,"%d output rays in %f sec = %f rays/sec\n",
			npts*npts, utime, (double)(npts*npts/utime) );
	}
@


1.25
log
@Reorganized min/max strategy, began developing better
autosize strategy.
@
text
@d12 1
a12 1
 * $Revision: 1.24 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.24 84/11/24 02:48:46 mike Exp $ (BRL)";
a153 1
	VSET( tempdir, 0, 0, -1 );
d168 1
d187 1
d193 1
a193 2
	VSET( tempdir, 	base[X], base[Y], base[Z] );
	MAT4X3PNT( ap.a_ray.r_pt, view2model, tempdir );
d197 1
a197 1
	/* Determine the Light location(s) in model space, xlate to view */
@


1.24
log
@shuffled printfs
@
text
@d12 1
a12 1
 * $Revision: 1.23 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.23 84/11/23 20:54:28 mike Exp $ (BRL)";
d28 2
a29 2
static fastf_t xbase, ybase, zbase;
static fastf_t deltas;
d149 5
d168 1
a168 1
			autosize( view2model, npts );
d170 3
a172 3
			xbase = -3;
			ybase = -3;
			zbase = -10;
d184 1
a184 1
		xbase = ybase = zbase = -1;
d192 1
a192 1
	VSET( tempdir, 	xbase, ybase, zbase );
d199 3
a201 3
	tempdir[0] = 2 * (xbase);
	tempdir[1] = (2/2) * (ybase);
	tempdir[2] = 2 * (zbase + npts*deltas);
d206 3
a208 3
	tempdir[0] = 2 * (xbase + npts*deltas);
	tempdir[1] = (2/2) * (ybase);
	tempdir[2] = 2 * (zbase + npts*deltas);
d213 3
a215 3
	tempdir[0] = 2 * (xbase + (npts/2)*deltas);
	tempdir[1] = 2 * (ybase + npts*deltas);
	tempdir[2] = 2 * (zbase + (npts/2)*deltas);
d226 3
a228 3
				xbase + ap.a_x * deltas,
				ybase + (npts-ap.a_y-1) * deltas,
				zbase +  2*npts*deltas );
d252 11
d264 14
d281 2
a282 2
autosize( rot, n )
matp_t rot;
a289 1
	static mat_t invrot;		/* model2view */
a290 2
	mat_inv( invrot, rot );		/* Inverse rotation matrix */

d299 1
a299 1
		MAT4X3PNT( xlated, invrot, stp->st_center );
d318 1
a318 3
	xbase = xmin;
	ybase = ymin;
	zbase = zmin;
d322 1
a322 1
	fprintf(stderr,"X(%f,%f), Y(%f,%f), Z(%f,%f)\n",
d326 1
@


1.23
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d12 1
a12 1
 * $Revision: 1.22 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.22 84/11/20 20:14:43 mike Exp $ (BRL)";
a237 2
		fprintf(stderr,"%d output rays in %f sec = %f rays/sec\n",
			npts*npts, utime, (double)(npts*npts/utime) );
d242 2
@


1.22
log
@General cleanup
@
text
@d12 1
a12 1
 * $Revision: 1.21 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.21 84/11/16 23:58:08 mike Exp $ (BRL)";
d142 2
a148 2
	timer_prep();	/* start timing actual run */

d214 2
a237 2
		fprintf(stderr,"%d solids, %d regions\n",
			nsolids, nregions );
d240 1
a240 1
		fprintf(stderr,"%d solids shot at, %ld shots pruned\n",
d242 2
a243 3
		fprintf(stderr,"%ld total shots in %f sec = %f shots/sec\n",
			(long)nshots+nmiss,
			utime, (double)((nshots+nmiss)/utime) );
@


1.21
log
@More FLEXNAMES stuff
@
text
@a0 1
#define static /**/
d12 1
a12 1
 * $Revision: 1.20 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.20 84/11/16 23:49:49 mike Exp $ (BRL)";
d23 1
a23 56
extern int nul_prep(),	nul_print();
extern int tor_prep(),	tor_print();
extern int tgc_prep(),	tgc_print();
extern int ell_prep(),	ell_print();
extern int arb_prep(),	arb_print();
extern int haf_prep(),	haf_print();
extern int ars_prep();
extern int rec_print();

extern struct seg *nul_shot();
extern struct seg *tor_shot();
extern struct seg *tgc_shot();
extern struct seg *ell_shot();
extern struct seg *arb_shot();
extern struct seg *haf_shot();
extern struct seg *rec_shot();

struct functab functab[] = {
	nul_prep,	nul_shot,	nul_print,	"ID_NULL",
	tor_prep,	tor_shot,	tor_print,	"ID_TOR",
	tgc_prep,	tgc_shot,	tgc_print,	"ID_TGC",
	ell_prep,	ell_shot,	ell_print,	"ID_ELL",
	arb_prep,	arb_shot,	arb_print,	"ID_ARB8",
	ars_prep,	arb_shot,	arb_print,	"ID_ARS",
	haf_prep,	haf_shot,	haf_print,	"ID_HALF",
	nul_prep,	nul_shot,	nul_print,	">ID_NULL"
};

/*
 *  Hooks for unimplemented routines
 */
#define DEF(func)	func() { printf("func unimplemented\n"); }

DEF(haf_prep); struct seg * DEF(haf_shot); DEF(haf_print);
DEF(nul_prep); struct seg * DEF(nul_shot); DEF(nul_print);

double timer_print();

int debug = DEBUG_OFF;
int view_only;		/* non-zero if computation is for viewing only */
int lightmodel;		/* Select lighting model */

long nsolids;		/* total # of solids participating */
long nregions;		/* total # of regions participating */
long nshots;		/* # of ray-meets-solid "shots" */
long nmiss;		/* # of ray-misses-solid's-sphere "shots" */
int outfd;		/* fd of optional pixel output file */
FILE *outfp;		/* used to write .PP files */

struct soltab *HeadSolid = SOLTAB_NULL;

struct seg *FreeSeg = SEG_NULL;		/* Head of freelist */

extern int viewit(), wbackground();

char usage[] = "\
d32 5
a36 5
double AmbientIntensity = 0.1;		/* Ambient light intensity */
vect_t l0vec;		/* 0th light vector */
vect_t l1vec;		/* 1st light vector */
vect_t l2vec;		/* 2st light vector */

d38 5
a42 1
int npts;			/* # of points to shoot: x,y */
a43 2
static char ttyObuf[4096];

d62 1
a62 1
		printf(usage);
d77 1
a77 1
			printf("debug=x%x\n", debug);
d109 2
a110 2
			printf("rt:  Option '%c' unknown\n", argv[0][1]);
			printf(usage);
d117 1
a117 1
		printf(usage);
a124 4
	/* 4.2 BSD stdio debugging assist */
	if( debug )
		setbuffer( stdout, ttyObuf, sizeof(ttyObuf) );

d138 4
a141 1
	if( HeadSolid == 0 )  bomb("No solids");
d144 1
a144 1
	if( !(debug&DEBUG_QUICKIE) )  {
a145 1
	}
d158 1
a158 1
		printf("Viewing %f azimuth, %f elevation off of front view\n",
d190 1
a190 1
	printf("Ambient light at %f%%\n", AmbientIntensity * 100.0 );
d214 1
a214 1
	fflush(stdout);
a217 1
if(debug&DEBUG_ALLRAYS)printf("x,y=%d,%d\n", ap.a_x, ap.a_y);
d236 1
a236 1
		printf("%d solids, %d regions\n",
d238 1
a238 1
		printf("%d output rays in %f sec = %f rays/sec\n",
d240 5
a244 4
		printf("%d solids shot at, %d shots pruned\n",
			nshots, nmiss );
		printf("%d total shots in %f sec = %f shots/sec\n",
			nshots+nmiss, utime, (double)((nshots+nmiss)/utime) );
d252 1
a252 1
autosize( rot, npts )
d254 1
a254 1
int npts;
d296 3
a298 3
	deltas = (xmax-xmin)/npts;
	MAX( deltas, (ymax-ymin)/npts );
	printf("X(%f,%f), Y(%f,%f), Z(%f,%f)\n",
d300 1
a300 9
	printf("Deltas=%f (units between rays)\n", deltas );
}

bomb(str)
char *str;
{
	fflush(stdout);
	fprintf(stderr,"\nrt: %s.  FATAL ERROR.\n", str);
	exit(12);
@


1.20
log
@arb8 --> arb, for non-FLEXNAMES systems.
@
text
@d13 1
a13 1
 * $Revision: 1.19 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.19 84/11/16 06:28:56 mike Exp $ (BRL)";
d24 1
a24 1
extern int null_prep(),	null_print();
d27 1
a27 1
extern int ellg_prep(),	ellg_print();
d29 1
a29 1
extern int half_prep(),	half_print();
d33 1
a33 1
extern struct seg *null_shot();
d36 1
a36 1
extern struct seg *ellg_shot();
d38 1
a38 1
extern struct seg *half_shot();
d42 1
a42 1
	null_prep,	null_shot,	null_print,	"ID_NULL",
d45 1
a45 1
	ellg_prep,	ellg_shot,	ellg_print,	"ID_ELL",
d48 2
a49 2
	half_prep,	half_shot,	half_print,	"ID_HALF",
	null_prep,	null_shot,	null_print,	">ID_NULL"
d57 2
a58 2
DEF(half_prep); struct seg * DEF(half_shot); DEF(half_print);
DEF(null_prep); struct seg * DEF(null_shot); DEF(null_print);
@


1.19
log
@struct ray --> struct xray
Bounding RPP
@
text
@d13 1
a13 1
 * $Revision: 1.18 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.18 84/11/15 21:47:50 mike Exp $ (BRL)";
d28 1
a28 1
extern int arb8_prep(),	arb8_print();
d37 1
a37 1
extern struct seg *arb8_shot();
d46 2
a47 2
	arb8_prep,	arb8_shot,	arb8_print,	"ID_ARB8",
	ars_prep,	arb8_shot,	arb8_print,	"ID_ARS",
@


1.18
log
@Minor bug fixes.
@
text
@d13 1
a13 1
 * $Revision: 1.17 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.17 84/10/19 01:57:55 mike Exp $ (BRL)";
d21 1
a21 1
#include "ray.h"
@


1.17
log
@Fixed typo
@
text
@d1 1
d13 1
a13 1
 * $Revision: 1.16 $
d16 1
a16 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.16 84/10/19 01:38:26 mike Exp $ (BRL)";
a48 1
	null_prep,	rec_shot,	rec_print,	"ID_REC",
d274 1
@


1.16
log
@Lint corrections
@
text
@d12 1
a12 1
 * $Revision: 1.15 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.15 84/10/19 00:07:46 mike Exp $ (BRL)";
d55 1
d57 2
a58 8

#define UNIMPLEMENTED(type) \
	DEF(type/**/_prep) \
	struct seg * DEF(type/**/_shot) \
	DEF(type/**/_print)

half() { printf("half unimplemented\n"); }
null() { printf("null unimplemented\n"); }
@


1.15
log
@Reorganization of functions for separation of application from ray functions.
@
text
@d12 1
a12 1
 * $Revision: 1.14 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.14 84/09/06 03:29:22 mike Exp $ (BRL)";
a55 1
static char unimp[] = "Unimplemented Routine";
d62 2
a63 1
#define DEF(func)	func() { printf("func unimplemented\n"); }
a64 3
UNIMPLEMENTED(null);
UNIMPLEMENTED(half);

a112 1
	static mat_t mat1, mat2;	/* temporary matrices */
a113 1
	static fastf_t distsq;
@


1.14
log
@Added -M option to input matrix from GED.
@
text
@d12 1
a12 1
 * $Revision: 1.13 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.13 84/08/28 03:08:02 mike Exp $ (BRL)";
a69 2
extern struct partition *bool_regions();

d85 1
a85 1
struct seg *HeadSeg = SEG_NULL;
d101 3
d106 3
d113 1
a113 3
	register struct ray *rayp;
	register int xscreen, yscreen;
	static int npts;		/* # of points to shoot: x,y */
a117 1
	static struct partition *PartHeadp, *pp;
a118 1
	static double azimuth, elevation;
d185 3
a187 2
	if( lightmodel != 4 )
		view_only = 1;
a188 12
	if( lightmodel == 3 || lightmodel == 4 )
		if( outfd > 0 )
			outfp = fdopen( outfd, "w" );
		else
			bomb("No output file specified");

	if( lightmodel == 3 )  {
		fprintf(outfp, "%s: %s (RT)\n", argv[0], argv[1] );
		fprintf(outfp, "%10d%10d", (int)azimuth, (int)elevation );
		fprintf(outfp, "%10d%10d\n", npts, npts );
	}

a214 5
	/*
	 * Determine the view
	 */
	GETSTRUCT(rayp, ray);

d250 2
a251 2
	MAT4X3VEC( rayp->r_dir, view2model, tempdir );
	VUNITIZE( rayp->r_dir );
d254 1
a254 1
	MAT4X3PNT( rayp->r_pt, view2model, tempdir );
d282 2
a283 2
	for( yscreen = npts-1; yscreen >= 0; yscreen--)  {
		for( xscreen = 0; xscreen < npts; xscreen++)  {
d285 2
a286 2
				xbase + xscreen * deltas,
				ybase + (npts-yscreen-1) * deltas,
d288 1
a288 1
			MAT4X3PNT( rayp->r_pt, view2model, tempdir );
d290 1
a290 44
			shootray( rayp );
			/* Implicit return of HeadSeg chain */

			if( HeadSeg == SEG_NULL )  {
				wbackground( xscreen, yscreen );
				continue;
			}

			/*
			 *  All intersections of the ray with the model have
			 *  been computed.  Evaluate the boolean functions.
			 */
			PartHeadp = bool_regions( HeadSeg );
			if( PartHeadp->pt_forw == PartHeadp )  {
				wbackground( xscreen, yscreen );
			}  else  {
				/*
				 * Hand final partitioned intersection list
				 * to application.
				 */
				viewit( PartHeadp, rayp, xscreen, yscreen );
			}

			/*
			 * Processing of this ray is complete.
			 * Release resources.
			 *
			 * Free up Seg memory.
			 */
			while( HeadSeg != SEG_NULL )  {
				register struct seg *hsp;	/* XXX */

				hsp = HeadSeg->seg_next;
				FREE_SEG( HeadSeg );
				HeadSeg = hsp;
			}
			/* Free up partition list */
			for( pp = PartHeadp->pt_forw; pp != PartHeadp;  )  {
				register struct partition *newpp;
				newpp = pp;
				pp = pp->pt_forw;
				FREE_PART(newpp);
			}
			if( debug )  fflush(stdout);
d292 1
a292 2
		/* End of scan line */
		dev_eol( yscreen );
d294 1
a295 2
	dev_end();

d314 3
a373 11
}

pr_seg(segp)
register struct seg *segp;
{
	printf("%.8x: SEG %s (%f,%f) bin=%d\n",
		segp,
		segp->seg_stp->st_name,
		segp->seg_in.hit_dist,
		segp->seg_out.hit_dist,
		segp->seg_stp->st_bin );
@


1.13
log
@Added support for VLD binary ray-files
@
text
@d12 1
a12 1
 * $Revision: 1.12 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.12 84/08/24 01:04:26 mike Exp $ (BRL)";
d98 1
a98 1
double AmbientIntensity = 0.15;		/* Ambient light intensity */
d112 2
a113 2
	static mat_t viewrot;
	static mat_t invview;
d119 1
d133 3
d153 1
d158 1
a225 3
	/* Determine a view */
	GETSTRUCT(rayp, ray);

d227 1
a227 3
	 * Unrotated view is TOP.
	 * Rotation of 270,0,270 takes us to a front view.
	 * Standard GIFT view is -35 azimuth, -25 elevation off front.
d229 1
a229 3
	mat_angles( invview, 270.0-elevation, 0.0, 270.0+azimuth );
	printf("Viewing %f azimuth, %f elevation off of front view\n",
		azimuth, elevation);
d231 12
a242 1
	mat_trn( viewrot, invview );		/* inverse */
d244 20
a263 10
	if( !(debug&DEBUG_QUICKIE) )  {
		autosize( viewrot, npts );
		VSET( tempdir, 0, 0, -1 );
	} else {
		xbase = -3;
		ybase = -3;
		zbase = -10;
		deltas = 1;
		npts = 8;
		VSET( tempdir, 0, 0, 1 );
a264 5
	MAT3XVEC( rayp->r_dir, viewrot, tempdir );
	/* Sanity check */
	distsq = MAGSQ(rayp->r_dir) - 1.0;
	if( !NEAR_ZERO(distsq) )
		printf("ERROR: |r_dir|**2 - 1 = %f != 0\n", distsq);
d266 3
d270 1
a270 1
	MAT3XVEC( rayp->r_pt, viewrot, tempdir );
d279 1
a279 1
	MAT3XVEC( l0vec, viewrot, tempdir );
d286 1
a286 1
	MAT3XVEC( l1vec, viewrot, tempdir );
d293 1
a293 1
	MAT3XVEC( l2vec, viewrot, tempdir );
d304 1
a304 1
			MAT3XVEC( rayp->r_pt, viewrot, tempdir );
d384 1
a384 1
	static mat_t invrot;
d386 1
a386 1
	mat_trn( invrot, rot );		/* Inverse rotation matrix */
d396 1
a396 1
		MAT3XVEC( xlated, invrot, stp->st_center );
@


1.12
log
@Added lighting model selection,
and hooks for writing .PP files
@
text
@d12 1
a12 1
 * $Revision: 1.11 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.11 84/08/22 03:19:12 mike Exp $ (BRL)";
a120 1
	view_only = 1;
d179 11
a189 3
	if( lightmodel == 3  &&  outfd > 0 )  {
		outfp = fdopen( outfd, "w" );
		fprintf(outfp, "%s: %s - rt\n", argv[0], argv[1] );
@


1.11
log
@Added ambient light
@
text
@d12 1
a12 1
 * $Revision: 1.10 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.10 84/08/21 01:18:58 mike Exp $ (BRL)";
d74 1
d81 1
d91 1
a91 1
Options:  -f[#] -x# -aAz -eElev -A%Ambient [-o model.pix]\n";
d155 4
d180 7
d329 2
@


1.10
log
@Added TORUS, neatened slightly.
@
text
@d12 1
a12 1
 * $Revision: 1.9 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.9 84/05/05 04:43:06 mike Exp $ (BRL)";
d89 1
a89 1
Options:  -f[#] -x# -aAz -eElev [-o model.pix]\n";
d96 1
d131 3
d233 2
@


1.9
log
@Moved display specific stuff to view.c
@
text
@d12 1
a12 1
 * $Revision: 1.8 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.8 84/05/04 09:14:50 mike Exp $ (BRL)";
a65 1
UNIMPLEMENTED(tor);
d291 1
a291 1
			while( HeadSeg != 0 )  {
@


1.8
log
@Added command line settable azimuth/elevation;
moved dev_setup to view.c, moved shootray() to it's own module.
@
text
@d12 1
a12 1
 * $Revision: 1.7 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.7 84/05/03 06:55:17 mike Exp $ (BRL)";
d80 1
d88 3
a90 2
char usage[] = 
"Usage:  rt [-f[#]] [-x#] [-aAz] [-eElev] model.vg object [objects]\n";
d150 8
d159 1
a159 1
			printf("Unknown option '%c' ignored\n", argv[0][1]);
d175 2
a180 5
	if( !(debug&DEBUG_QUICKIE) )  {
		/* Set up the online display */
		dev_setup(npts);
	}

a181 1
	timer_prep();
a187 2
	timer_prep();

d190 7
d246 1
a246 1
	/* 2:  Green, behind, and overhead */
d308 2
d311 4
@


1.7
log
@Performance enhancements, ARS fixes.
@
text
@d12 1
a12 1
 * $Revision: 1.6 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.6 84/05/02 05:09:57 mike Exp $ (BRL)";
a74 1
int nsolids;		/* total # of solids participating */
d76 5
d85 1
a85 1
static struct seg *HeadSeg = SEG_NULL;
d87 2
a88 1
char usage[] = "Usage:  rt [-f[#]] [-x#] model.vg object [objects]\n";
d93 1
d110 1
d114 1
d116 1
a116 1
	npts = 200;
d118 2
d140 8
d170 2
a171 11
		/* Prepare the Ikonas display */
		ikopen();
		load_map(1);
		ikclear();
		if( npts <= 64 )  {
			ikzoom( 9, 9 );
			ikwindow( (0)*4, 4063+30 );
		} else if ( npts <= 256 )  {
			ikzoom( 1, 1 );
			ikwindow( (0)*4, 4063+17 );
		}
d189 8
a196 1
	mat_angles( invview, 295.0, 0.0, 235.0 );	/* GIFT 35,25 */
a198 1
	mat_print( "View Rotation", viewrot );
a224 1
VPRINT("Light0 Pos", tempdir);
a226 1
VPRINT("Light0 Vec", l0vec);
a231 1
VPRINT("Light1 Pos", tempdir);
a233 1
VPRINT("Light1 Vec", l1vec);
a238 1
VPRINT("Light2 Pos", tempdir);
d241 1
a241 1
VPRINT("Light2 Vec", l2vec);
d301 3
a303 2
		printf("%d solids, %d shots in %f sec = %f shots/sec\n",
			nsolids,
d305 4
a312 49
shootray( rayp )
register struct ray *rayp;
{
	register struct soltab *stp;
	static vect_t diff;	/* diff between shot base & solid center */
	FAST fastf_t distsq;	/* distance**2 */

	if(debug&DEBUG_ALLRAYS) {
		VPRINT("\nRay Start", rayp->r_pt);
		VPRINT("Ray Direction", rayp->r_dir);
	}

	HeadSeg = SEG_NULL;	/* Should check, actually */

	/*
	 * For now, shoot at all solids in model.
	 * This code is executed more often than any other part!
	 */
	for( stp=HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw ) {
		register struct seg *newseg;		/* XXX */

		/* Consider bounding sphere */
		VSUB2( diff, stp->st_center, rayp->r_pt );
		distsq = VDOT(rayp->r_dir, diff);
		if( (MAGSQ(diff) - distsq*distsq) > stp->st_radsq ) {
			continue;
		}
		newseg = functab[stp->st_id].ft_shot( stp, rayp );
		if( newseg == SEG_NULL )
			continue;

		/* First, some checking */
		if( newseg->seg_in.hit_dist > newseg->seg_out.hit_dist )  {
			struct hit temp;	/* XXX */
			printf("ERROR %s %s: in/out reversal (%f,%f)\n",
				functab[stp->st_id].ft_name,
				newseg->seg_stp->st_name,
				newseg->seg_in.hit_dist,
				newseg->seg_out.hit_dist );
			temp = newseg->seg_in;		/* struct copy */
			newseg->seg_in = newseg->seg_out; /* struct copy */
			newseg->seg_out = temp;		/* struct copy */
		}
		/* Add to list */
		newseg->seg_next = HeadSeg;
		HeadSeg = newseg;
	}
}

d359 3
a361 2
	printf("X(%f,%f), Y(%f,%f), Z(%f,%f)\nDeltas=%f\n",
		xmin, xmax, ymin, ymax, zmin, zmax, deltas );
@


1.6
log
@More ARS support, fixes of all kinds.
@
text
@d12 1
a12 1
 * $Revision: 1.5 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.5 84/05/01 06:39:53 mike Exp $ (BRL)";
d69 1
d74 2
d109 1
d144 2
a145 1
/**	setbuffer( stdout, ttyObuf, sizeof(ttyObuf) ); */
d156 1
a156 1
		if( npts <= 50 )  {
d158 4
a161 1
			ikwindow( (27-1)*4, 4063+56 );
d166 1
d171 1
d173 2
d257 6
a262 1
				continue;
a265 6
			 * Hand final partitioned intersection list
			 * to application.
			 */
			viewit( PartHeadp, rayp, xscreen, yscreen );

			/*
d288 7
d312 5
a316 2
	/* For now, shoot at all solids in model */
	for( stp=HeadSolid; stp != 0; stp=stp->st_forw ) {
a318 3
		if(debug&DEBUG_ALLRAYS)
			printf("Shooting at %s -- ", stp->st_name);

d322 1
a322 2
		if( (distsq=(MAGSQ(diff) - distsq*distsq)) > stp->st_radsq ) {
			if(debug&DEBUG_ALLRAYS)  printf("(Not close)\n");
a324 6
		if( distsq < -EPSILON )  {
			printf("ERROR in %s:  dist**2 = %f -- skipped\n",
				stp->st_name, distsq );
			continue;
		}

@


1.5
log
@Modifications for ARS, code unified to use fastf_t
@
text
@d12 1
a12 1
 * $Revision: 1.4 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.4 84/04/26 05:47:52 mike Exp $ (BRL)";
d90 2
d122 1
a122 1
			if( npts < 2 || npts > 1024 )
d124 1
d138 4
d151 4
d220 1
d274 1
d397 3
a399 2
	printf("SEG at %.8x:  flag=%x (%f,%f) solid=%s\n",
		segp, segp->seg_flag,
d402 1
a402 1
		segp->seg_stp->st_name );
@


1.4
log
@Fixed typo
@
text
@d12 1
a12 1
 * $Revision: 1.3 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.3 84/04/26 05:41:30 mike Exp $ (BRL)";
a27 1
extern int ars_prep(),	ars_print();
d29 2
a36 1
extern struct seg *ars_shot();
d38 1
d46 1
a46 1
	ars_prep,	ars_shot,	ars_print,	"ID_ARS",
d48 1
d52 18
d157 2
a158 6
	mat_idn( invview );
/**	mat_angles( invview, 290.0, 0.0, 310.0 ); */
	mat_angles( invview, 295.0, 0.0, 235.0 );
/**	mat_ae( invview, 360.-35.0, 360.-25.0 ); * */
/**	mat_ae( invview, -35.0, -25.0 ); * */
/**	mat_ae( invview, 180.0+35.0, 180.0+25.0 ); ** */
a173 1
VPRINT("Direction", rayp->r_dir);
a180 1
VPRINT("Starting point", tempdir );
d264 1
d328 3
a330 3
	static float xmin, xmax;
	static float ymin, ymax;
	static float zmin, zmax;
@


1.3
log
@Improved speed, fixed bugs.
@
text
@d12 1
a12 1
 * $Revision: 1.2 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.2 84/04/18 02:20:32 mike Exp $ (BRL)";
d330 2
a331 2
#define MIN(v,t) {FAST fastf_t rt=(t); if(rt<v) v = rt;}
#define MAX(v,t) {FAST fastf_t rt=(t); if(rt>v) v = rt;}
@


1.2
log
@Boolean operation support
@
text
@d12 1
a12 1
 * $Revision: 1.1 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.1 84/04/02 16:42:12 mike Exp $ (BRL)";
d56 2
d63 2
a64 2
static float xbase, ybase, zbase;
static float deltas;
d81 1
d158 5
d164 4
d214 1
a214 1
			 *  been computed.
d217 4
d238 1
a238 1
				free( HeadSeg );
d257 1
a257 1
	register float distsq;	/* distance**2 */
a262 3
	distsq = MAGSQ(rayp->r_dir) - 1.0;
	if( !NEAR_ZERO(distsq) )
		printf("ERROR: |r_dir|**2 - 1 = %f != 0\n", distsq);
d276 1
a276 1
		if( (distsq=MAGSQ(diff) - distsq*distsq) > stp->st_radsq )  {
d326 1
a326 1
		register float rad;
d330 2
a331 2
#define MIN(v,t) {register float rt=(t); if(rt<v) v = rt;}
#define MAX(v,t) {register float rt=(t); if(rt>v) v = rt;}
d339 9
a374 1

@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * $Revision$
d15 1
a15 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d23 7
a29 7
extern int null_prep(),	null_shot(),	null_print();
extern int tor_prep(),	tor_shot(),	tor_print();
extern int tgc_prep(),	tgc_shot(),	tgc_print();
extern int ellg_prep(),	ellg_shot(),	ellg_print();
extern int arb8_prep(),	arb8_shot(),	arb8_print();
extern int ars_prep(),	ars_shot(),	ars_print();
extern int half_prep(),	half_shot(),	half_print();
d31 8
d40 8
a47 8
	null_prep,	null_shot,	null_print,	/* ID_NULL */
	tor_prep,	tor_shot,	tor_print,	/* ID_TOR */
	tgc_prep,	tgc_shot,	tgc_print,	/* ID_TGC */
	ellg_prep,	ellg_shot,	ellg_print,	/* ID_ELL */
	arb8_prep,	arb8_shot,	arb8_print,	/* ID_ARB8 */
	ars_prep,	ars_shot,	ars_print,	/* ID_ARS */
	half_prep,	half_shot,	half_print,	/* ID_HALF */
	null_prep,	null_shot,	null_print,	/* ID_NULL */
d50 2
d54 1
a54 2
struct soltab *HeadSolid = 0;
struct seg *HeadSeg = 0;
d56 1
a56 1
char usage[] = "Usage:  rt [-d#] model.vg object [objects]";
d58 10
d72 3
a74 5
	static struct ray *rayp;
	static float xbase, ybase, zbase;
	static float dx, dy, dz;
	static int xscreen, yscreen;
	static int xpts, ypts;
d76 1
d78 1
a78 1
	static float *fp;
d80 2
d83 1
a83 1
		printf("%s\n", usage);
d90 1
a90 1
		case 'd':
d94 6
d102 1
a102 1
			printf("%s\n", usage);
a106 1
	/* Fetching database name, etc, here later */
d108 7
a114 3
	ikopen();
	load_map(1);
	ikclear();
d116 7
d124 5
a128 1
	get_tree("noname");
d134 7
a140 1
	ae_mat( viewrot, -35.0, -25.0 );
d144 1
a144 5
		xbase = -5.0; dx =  0.025;
		ybase =  6.0; dy = -0.025;
		zbase = 10.0;
		xpts = 400;
		ypts = 400;
d147 2
a148 2
		xbase = -3; dx = 1;
		ybase = -3; dy = 1;
d150 2
a151 2
		xpts = 8;
		ypts = 8;
d154 1
a154 2
	fp = &rayp->r_dir[0];
	MAT3XVEC( fp, viewrot, tempdir );
d156 30
a185 2
	for( yscreen = 0; yscreen < ypts; yscreen++)  {
		for( xscreen = 0; xscreen < xpts; xscreen++)  {
d187 3
a189 3
				xbase + xscreen * dx,
				ybase + yscreen * dy,
				zbase);
d195 1
a195 1
			if( HeadSeg == 0 )  {
d204 1
a204 1
			/* HeadSeg = closegaps( HeadSeg ) */
d207 2
a208 1
			 *  Hand final intersection list to application
d210 1
a210 1
			viewit( HeadSeg, rayp, xscreen, yscreen );
d212 6
a217 1
			/* Free up Seg memory.  Use freelist, later */
d225 7
a239 1
	static float f;
d247 3
a249 3
	f = MAGSQ(rayp->r_dir) - 1.0;
	if( !NEAR_ZERO(f) )
		printf("ERROR: |r_dir|**2 - 1 = %f != 0\n", f);
d251 1
a251 1
	HeadSeg = 0;	/* Should check, actually */
d255 2
d263 5
a267 2
		distsq = MAGSQ(diff) - distsq*distsq;
		if( distsq < 0.0 )  {
d272 3
a274 2
		if( distsq > stp->st_radsq )  {
			if(debug&DEBUG_ALLRAYS)  printf("(Not close)\n");
d276 12
d289 5
d295 30
a324 3
		functab[stp->st_id].ft_shot( stp, rayp );
		/* ret == 0 for HIT */
		/* Adds results to HeadSeg chain, if it hit */
d326 8
d339 2
a340 1
	fprintf(stderr, "\nrt: %s\nFATAL ERROR\n", str);
d344 2
a345 11
/*
 *  Compute a 4x4 rotation matrix given Azimuth and Elevation.
 *  
 *  Azimuth is +X, Elevation is +Z, both in degrees.
 *
 *  Formula due to Doug Gwyn, BRL.
 */
ae_mat( m, azimuth, elev )
register matp_t m;
float azimuth;
float elev;
d347 6
a352 4
	static float sin_az, sin_el;
	static float cos_az, cos_el;
	extern double sin(), cos();
	static double degtorad = 0.0174532925;
a353 26
	azimuth *= degtorad;
	elev *= degtorad;

	sin_az = sin(azimuth);
	cos_az = cos(azimuth);
	sin_el = sin(elev);
	cos_el = cos(elev);

	m[0] = cos_el * cos_az;
	m[1] = -sin_az;
	m[2] = -sin_el * cos_az;
	m[3] = 0;

	m[4] = cos_el * sin_az;
	m[5] = cos_az;
	m[6] = -sin_el * sin_az;
	m[7] = 0;

	m[8] = sin_el;
	m[9] = 0;
	m[10] = cos_el;
	m[11] = 0;

	m[12] = m[13] = m[14] = 0;
	m[15] = 1.0;
}
@
