head	11.17;
access;
symbols
	ansi-20040405-merged:11.13.2.2
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.13.10.2
	premerge-autoconf:11.14
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.13.4.1
	autoconf-20031203:11.13
	autoconf-20031202:11.13
	autoconf-branch:11.13.0.10
	phong-branch:11.13.0.8
	photonmap-branch:11.13.0.6
	rel-6-1-DP:11.13
	windows-branch:11.13.0.4
	rel-6-0-2:11.11
	ansi-branch:11.13.0.2
	rel-6-0-1-branch:11.11.0.2
	hartley-6-0-post:11.12
	hartley-6-0-pre:11.11
	rel-6-0-1:11.11
	rel-6-0:11.11
	rel-5-4:11.8
	offsite-5-3-pre:11.11
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.8
	rel-5-0-beta:11.8
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.17.31.09;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.05.45.59;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2002.08.20.17.08.39;	author jra;	state Exp;
branches
	11.13.2.1
	11.13.4.1
	11.13.10.1;
next	11.12;

11.12
date	2002.08.15.20.55.50;	author hartley;	state Exp;
branches;
next	11.11;

11.11
date	2000.08.17.02.41.40;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.27.19.32.53;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	99.05.28.01.19.29;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	98.09.22.00.21.29;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.01.08.00.01.55;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.01.02.21.07.31;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.06.17.57.53;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.27;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.11.05.03.08.05;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.02.46.46;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.05.04.15.55.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.21;	author mike;	state Rel4_0;
branches;
next	9.32;

9.32
date	91.07.16.00.30.51;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	91.07.16.00.13.28;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.07.06.00.35.30;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.07.03.13.19.40;	author pjt;	state Exp;
branches;
next	9.28;

9.28
date	91.02.20.00.51.33;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.02.13.11.09.04;	author sue;	state Exp;
branches;
next	9.26;

9.26
date	91.01.05.03.09.25;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.01.02.13.55.26;	author sue;	state Exp;
branches;
next	9.24;

9.24
date	90.12.18.20.18.32;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	90.12.14.22.07.10;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	90.12.12.16.35.19;	author butler;	state Exp;
branches;
next	9.21;

9.21
date	90.12.11.16.55.02;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	90.12.11.16.54.37;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	90.12.11.16.42.18;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	90.12.11.16.39.24;	author sue;	state Exp;
branches;
next	9.17;

9.17
date	90.11.14.15.43.40;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.11.02.09.18.59;	author sue;	state Exp;
branches;
next	9.15;

9.15
date	90.10.07.18.57.04;	author sue;	state Exp;
branches;
next	9.14;

9.14
date	90.10.05.21.35.35;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.10.03.13.00.29;	author sue;	state Exp;
branches;
next	9.12;

9.12
date	90.09.12.08.47.34;	author sue;	state Exp;
branches;
next	9.11;

9.11
date	90.09.07.11.18.22;	author sue;	state Exp;
branches;
next	9.10;

9.10
date	90.09.07.08.25.53;	author sue;	state Exp;
branches;
next	9.9;

9.9
date	90.08.31.11.04.24;	author sue;	state Exp;
branches;
next	9.8;

9.8
date	90.08.31.10.09.40;	author sue;	state Exp;
branches;
next	9.7;

9.7
date	90.08.29.08.57.05;	author sue;	state Exp;
branches;
next	9.6;

9.6
date	90.08.22.09.55.27;	author sue;	state Exp;
branches;
next	9.5;

9.5
date	90.08.21.12.46.50;	author sue;	state Exp;
branches;
next	9.4;

9.4
date	90.08.20.17.50.45;	author sue;	state Exp;
branches;
next	9.3;

9.3
date	90.08.17.09.23.42;	author sue;	state Exp;
branches;
next	9.2;

9.2
date	90.07.29.23.14.36;	author sue;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.57;	author mike;	state Rel3_5;
branches;
next	1.4;

1.4
date	89.05.07.20.38.31;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.04.04.05.02.29;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.04.03.15.25.42;	author sue;	state Exp;
branches;
next	1.1;

1.1
date	89.03.30.21.47.12;	author sue;	state Exp;
branches;
next	;

11.13.2.1
date	2002.09.19.18.02.16;	author morrison;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2004.03.17.21.23.01;	author morrison;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.11.23.48.08;	author morrison;	state Exp;
branches;
next	;

11.13.10.1
date	2004.02.12.19.37.14;	author erikg;	state Exp;
branches;
next	11.13.10.2;

11.13.10.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@Front end of a hidden line drawing application.
@


11.17
log
@moved to src/rt/
@
text
@/*
 *			V I E W H I D E
 *
 *  Ray Tracing program RTHIDE bottom half.
 *
 *  This module utilizes the RT library to interrogate a MGED
 *  model and plots a hidden-line removed UnixPlot file.
 *  This is accomplished by comparing region-id codes between
 *  pixels.  A vertical or horizontal line is plotted when a change in
 *  region-id codes is detected.
 *
 *  At present, the main use for this module is to generate
 *  UnixPlot file that can be read by various existing filters
 *  to produce a bas-relief line drawing of an MGED object: i.e.
 *  flat when viewed head-on, but with relief detail when seen at
 *  an angle.
 *  
 *  This is based on previous work done by Michael John Muuss.
 *
 *  Author -
 *	Susanne L. Muuss, J.D.
 *	Michael J. Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */


#ifndef lint
static const char RCSrayhide[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/viewhide.c,v 11.16 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ext.h"
#include "rtprivate.h"
#include "plot3.h"

#define SEEKING_START_PT 0
#define FOUND_START_PT 1
#define CELLNULL ( (struct cell *) 0)
#define ID_BACKGROUND (-999)

struct cell {
	float	c_dist;			/* distance from emanation plane to in_hit */
	int	c_id;			/* region_id of component hit */
	point_t	c_hit;			/* 3-space hit point of ray */
	vect_t	c_normal;		/* surface normal at the hit point */
	vect_t	c_rdir;			/* ray direction, permits perspective */
};

extern	int	width;			/* # of pixels in X; picture width */
extern	double	AmbientIntensity;	/* angle bet. surface normals; default of 5deg */
extern int	npsw;			/* number of worker PSWs to run */

fastf_t		pit_depth;		/* min. distance for drawing pits/mountains */
fastf_t		maxangle;		/* value of the cosine of the angle bet. surface normals that triggers shading */

void		swapbuff(struct cell **onepp, struct cell **twopp);
void		cleanline(struct cell *inbuffp, int file_width);
void		horiz_cmp(struct cell *botp, int mem_width, int y);
void		vert_cmp(struct cell *botp, struct cell *topp, int mem_width, int y);
struct cell	*find_cell(struct cell *cur_cellp, struct cell *next_cellp);
struct cell	*botp;			/* pointer to bottom line   */
struct cell	*topp;			/* pointer to top line	    */



int		use_air = 0;		/* Internal air recognition is off */

int		using_mlib = 0;		/* Material routines NOT used */

/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
	{"",	0, (char *)0,	0,	BU_STRUCTPARSE_FUNC_NULL }
};


char usage[] = "\
Usage:  rthide [options] model.g objects... >file.pl\n\
Options:\n\
 -s #		Grid size in pixels, default 512\n\
 -A angle	Angle between surface normals (default=5degrees)\n\
 -a Az		Azimuth in degrees	(conflicts with -M)\n\
 -e Elev	Elevation in degrees	(conflicts with -M)\n\
 -M		Read model2view matrix on stdin (conflicts with -a, -e)\n\
 -o output.pl	Specify output file (default=stdout)\n\
 -U #		Set use_air boolean to # (default=1)\n\
 -x #		Set librt debug flags\n\
";

int	rayhit(register struct application *ap, struct partition *PartHeadp), raymiss(register struct application *ap);

/*
 *  			V I E W _ I N I T
 *
 *  This routine is called by main().  It initializes the entire run, i.e.,
 *  it does things such as opening files, etc., which must be done before
 *  any other computations take place.  It is called only once per run.
 *  Pointers to rayhit() and raymiss() are set up and are later called from
 *  do_run().
 */

int
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{

	ap->a_hit = rayhit;
	ap->a_miss = raymiss;
	ap->a_onehit = 1;

	output_is_binary = 1;		/* output is binary */

	return(0);			/* No framebuffer needed */
}

/*
 *			V I E W _ 2 I N I T
 *
 *  A null-function.
 *  View_2init is called by do_frame(), which in turn is called by
 *  main() in rt.c.  This routine is called once per frame.  Static
 *  images only have one frame.  Animations have MANY frames, and bounding
 *  boxes, for example, need to be computed once per frame.
 *  Never preclude a new and nifty animation: rule: if it's a variable, it can
 *  change from frame to frame ( frame/picture width; angle between surface
 *  normals triggering shading.... etc).
 */

void
view_2init(struct application *ap)
{

	if( outfp == NULL )
		rt_bomb("outfp is NULL\n");

	/*
	 *  For now, RTHIDE does not operate in parallel, while ray-tracing.
	 *  However, not dropping out of parallel mode until here permits
	 *  tree walking and database prepping to still be done in parallel.
	 */
	if( npsw >= 1 )  {
		bu_log("Note: changing from %d cpus to 1 cpu\n", npsw );
		npsw = 1;		/* Disable parallel processing */
	}

	/* malloc() two buffers that have room for as many struct cell 's
	 * as the incoming file is wide (width), plus two for the border.
	 * Rather than using malloc(), though, bu_malloc() is used.  This
	 * has the advantage of inbuild error-checking and automatic aborting
	 * if there is no memory.  Also, bu_malloc() takes a string as its
	 * final parameter: this tells the usr exactly where memory ran out.
	 * The file_height is counted by using ap->a_y directly. The benefit
	 * of this is WHAT?
	 */


	botp = (struct cell *)bu_malloc(sizeof(struct cell) * (width + 2),
		"bottom cell buffer" );
	topp = (struct cell *)bu_malloc(sizeof(struct cell) * (width + 2),
		"top cell buffer" );

	/* Clear both in-buffers to ensure abscence of garbage.  Note 
	 * that the zero-filled "bottom" buffer now provides the first
	 * in-memory buffer for comparisons.
	 */

	cleanline(botp, width);
	cleanline(topp, width);


	/* Determine the angle between surface normal below which shading
	 * will take place.  The default is the for less than the cosine
	 * of 5 degrees, there will be shading.  With the -A option, the
	 * user can specify other number of degrees below which he wants
	 * shading to take place.  Note that the option for ambient light
	 * intensity had been reused since that will not be needed here.
	 * The default of 5 degrees is used when AmbientIntensity is less
	 * than 0.5 because it's default is set to 0.4, and the permissible
	 * range for light intensity is 0 -> 1.
	 */

	if( AmbientIntensity <= 0.5 )  {
		maxangle = cos( 5.0 * bn_degtorad);
	} else {
		maxangle = cos( AmbientIntensity * bn_degtorad);
	}

	/* Obtain the bounding boxes for the model from the rt_i(stance)
	 * structure and feed the maximum and minimum coordinates to
	 * pdv_3space.  This will allow the image to appear in the plot
	 * starting with the same size as the model.
	 */

	pdv_3space(outfp, ap->a_rt_i->rti_pmin, ap->a_rt_i->rti_pmax);

	/* Now calculated and store the minimun depth change that will
	 * trigger the drawing of "pits" and "pendula" (mountains).  In
	 * this case, a change in distance of 2 pixels was picked.  Note
	 * that the distance of one pixel in model space is MAGNITUDE(dx_model).
	 * This is calculated once per frame dx_model may be different in
	 * another frame.
	 */

	pit_depth = 4 * MAGNITUDE( dx_model );


}


/*
 *			R A Y M I S S
 *
 *  This function is called by rt_shootray(), which is called by
 *  do_frame(). Records coordinates where a miss is detected.
 */

int
raymiss(register struct application *ap)
{

	struct	cell	*posp;		/* store the current cell position */

	/* Getting defensive.... just in case. */
	if(ap->a_x > width)  {
		rt_bomb("raymiss: pixels exceed width\n");
	}

	posp = &(topp[ap->a_x + 1]);

	/*
	 * cleanline() zero-fills a buffer.  Therefore, it is possible to
	 * let this "line scrubber" do all the zero-filling for raymiss()
	 * by calling it before EVERY new topbuff is filled.  This would
	 * result in very inefficient code.  Thus, even on a miss, raymiss()
	 * will do its own zero-filling of the distance, region_id, surface
	 * normal, and the hit distance.  This prevents the image from being
	 * "smeared".
	 */

	posp->c_id = ID_BACKGROUND;
	posp->c_dist = 0;
	VSET(posp->c_hit, 0, 0, 0);
	VSET(posp->c_normal, 0, 0, 0);
	VSET(posp->c_rdir, 0, 0, 0);

	return(0);
}

/*
 *			V I E W _ P I X E L
 *
 *  This routine is called from do_run(), and in this case does nothing.
 */

void
view_pixel(void)
{
	return;
}

void view_setup(void) {}
void view_cleanup(void) {}


/*
 *			R A Y H I T
 *
 *  Rayhit() is called by rt_shootray() when a hit is detected.  It
 *  computes the hit distance, the region_id, the distance traveled by the
 *  ray, and the surface normal at the hit point.
 *  
 */

int
rayhit(struct application *ap, register struct partition *PartHeadp)
{
	register struct partition *pp = PartHeadp->pt_forw;
	struct	cell	*posp;			/* stores current cell position */
	register struct hit	*hitp;		/* which hit */

	if( pp == PartHeadp )
		return(0);		/* nothing was actually hit?? */


	/* Getting defensive.... just in case. */
	if(ap->a_x > width)  {
		rt_bomb("rayhit: pixels exceed width\n");
	}

	posp = &(topp[ap->a_x + 1]);

	/* Ensure that inhit is in front of emanation plane */
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_inhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		bu_log("rthide/rayhit:  no hit out front? x%d y%d lvl%d\n",
			ap->a_x, ap->a_y, ap->a_level);
		return(0);
	}
	hitp = pp->pt_inhit;

	VMOVE(posp->c_rdir, ap->a_ray.r_dir);
	VJOIN1( posp->c_hit, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );

	/* Calculate the hit normal and the hit distance. */
	RT_HIT_NORMAL( posp->c_normal, hitp, pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);


	/* Now store the distance and the region_id in the appropriate
	 * cell struct: i.e., ap->a_x (the x-coordinate) +1 within the
	 * array of cell structs.
	 * Extract the hit distance and the hit normals from the hit structure
	 * and store in the cell structure.
	 * Since repeatedly computing topp[ap->a_x + 1] is very inefficient,
	 * the value of ap->a_x + 1 will be stored in a struct cell pointer
	 * to vitiate the need to recompute this value repeatedly. LATER.
	 */
	posp->c_dist = hitp->hit_dist;

	/*
	 * Output the ray data: screen plane (pixel) coordinates
	 * for x and y positions of a ray, region_id, and hit_distance.
	 * The x and y positions are represented by ap->a_x and ap->a_y.
	 *
	 *  Assume all rays are parallel.
	 */

	posp->c_id = pp->pt_regionp->reg_regionid;

	/* make sure that if there is a hit, the region_id is not the
	 * same as the background.  If it is, set to 1.
	 */
	if(posp->c_id == ID_BACKGROUND)
		posp->c_id = 1;
	return(0);
}

/*
 *			V I E W _ E O L
 *
 *  View_eol() is called by rt_shootray() in do_run().
 *  This routine is called by worker.c whenever there is a full scanline.
 *  worker.c figures out what is a full scanline.  Whenever there
 *  are two full buffers in memory, the horizontal and the vertical compares
 *  are done, as well as any plotting.  Then the "bottom" buffer is "dropped",
 *  and a new one is read into memory until end-of-file is reached.
 */

void	view_eol(struct application *ap)
{


	/* Now add 2 pixels to file_width to convert it to memory_width
	 * for doing the comparisons and determining the boundaries around 
	 * the picture.  Note that the file_height is simply expressed as
	 * ap->a_y.  It is not necessary to add 2 pixels to it for the
	 * boundary because that is taken care of by originally allocating
	 * the bottom cell buffer, and at the end by doing one extra top
	 * cell buffer.
	 */

	horiz_cmp(botp, width + 2, ap->a_y);
	vert_cmp(botp, topp, width + 2, ap->a_y);
	swapbuff(&botp, &topp);

}


/*
 *			V I E W _ E N D
 *
 *  View_end() is called by rt_shootray in do_run().  It is necessary to
 *  iterate one more time through the horizontal and vertical comparisons
 *  to put down a top border.  This routine is responsible for doing this.
 *  Note also that since view_end() takes an application structure pointer,
 *  the file height can be expressed directly as ap->a_y.  One might consider
 *  allocating a height variable set to this value....
 */

void
view_end(struct application *ap)
{

	cleanline(topp, width);
	horiz_cmp(botp, width + 2, ap->a_y);
	vert_cmp(botp, topp, width + 2, ap->a_y);

	fflush(outfp);
}


/*
 *		H O R I Z O N T A L   C O M P A R I S O N
 *
 *  This routine takes three parameters: a pointer to a "bottom" buffer, the
 *  line width of the incoming file plus two border pixels (mem_width), and
 *  a y-coordinate (file_height).  It returns nothing.
 *
 *  Pixels on a scanline are compared to see if their region_id codes
 *  are the same.  If these are not identical, a vertical line is
 *  plotted to mark to boundary where the region_id codes change.  Likewise,
 *  the size of the angle between surface normals is checked: if it exceeds
 *  maxangle, then a line s drawn.
 */

void
horiz_cmp(struct cell *botp, int mem_width, int y)
{
	int		x;
	struct	cell	*cellp;
	vect_t		start;		/* start of vector */
	vect_t		stop;		/* end of vector */

	for (x=0; x < (mem_width-1); x++, botp++)  {

		/* If the region_ids of neighboring pixels do
		 * not match, compare their hit distances.  If
		 * either distance is zero, select the non-zero
		 * distance for plotting; otherwise, select the
		 * lesser of the two distances.
		 * Check the angle between surface normals to see
		 * whether a line needs to be drawn.  This is accomplished
		 * by finding the cosine of the angle between the two
		 * vectors with VDOT(), the dot product.  The result
		 * is compared against maxangle, which must be determined
		 * experimentally.  This scheme will prevent curved surfaces,
		 * on which practically "every point is a surface", from
		 * being represented as dark blobs.
		 * Note that maxangle needs to be greater than the cosine
		 * of the angle between the two vectors because as the angle
		 * between the increases, the cosine of said angle decreases.
		 * Also of interest is that one needs to say: plot if id's
		 * are not the same OR if either id is not 0 AND the cosine
		 * of the angle between the normals is less than maxangle. 
		 * This test prevents the background from being shaded in.
		 * Furthermore, it is necessary to select the hit_point.
		 * Check for pits and pendula.  The below if statement can
		 * be translated as follows: if(ids don't match ||
		 * (cur_id is not 0 && ( (there's a pit) || (there's a mtn) ).
		 */

		if (botp->c_id != (botp+1)->c_id ||
		   ( botp->c_id != ID_BACKGROUND && 
		   ( (botp->c_dist + pit_depth < (botp+1)->c_dist) ||
		     ((botp+1)->c_dist + pit_depth < botp->c_dist)  ||
 		     (VDOT(botp->c_normal, (botp + 1)->c_normal) < maxangle))))  {
							     
		   	cellp = find_cell(botp, (botp+1)); 

			/* Note that the coordinates must be expressed
		   	 * as MODEL coordinates.  This can be done by
		   	 * adding offsets to the hit_point.  Thus, 0.5*
		   	 * dx_model means moving 0.5 of a cell in model
		   	 * space, and replaces (x -1 +0.5) representing
		   	 * backing up one whole cell and then moving to
		   	 * the center of the new cell in file coordinates.
		   	 * In that case, the x represented the screen coords.
		   	 * Now, make the beginning point and the ending point.
			 */

		   	/* To make sure that all the vertical lines are in the
		   	 * correct place, if cellp is the same as botp, then
		   	 * to start,move half a cell right to start, else move half a
		   	 * cell left; and to end, move right and up one half cell.
		   	 */

		   	if(botp == cellp)  {
		   		VJOIN2(start, cellp->c_hit, 0.5, dx_model, -0.5, dy_model);
		   		VJOIN2(stop, cellp->c_hit, 0.5, dx_model, 0.5, dy_model);
		   	} else {
			   	VJOIN2(start, cellp->c_hit, -0.5, dx_model, -0.5, dy_model);
		   		VJOIN2(stop, cellp->c_hit, -0.5, dx_model, 0.5, dy_model);
		   	}

			pdv_3line(outfp, start, stop);
				
		}
	}
}

/*
 *		V E R T I C A L  C O M P A R I S O N
 *
 *  This routine takes four parameters: a pointer to a "top" buffer, a pointer
 *  to a "bottom" buffer, the file_width + two border pixels (mem_width), and
 *  a y-coordinate (line-count, or file_height).  It returns nothing.
 *
 *  Pixels residing on adjacent scanlines are compared to determine
 *  whether their region_id codes are the same.  If these are not
 *  identical, a horizontal line is plotted to mark the boundary where
 *  the region_id codes change.
 *
 */

void
vert_cmp(struct cell *botp, struct cell *topp, int mem_width, int y)
{

	register int	x;
	struct	 cell	*cellp;
	struct	 cell	*start_cellp;
	int		state;
	vect_t		start;
	vect_t		stop;
	
	VSET(start, 0, 0, 0);	/* cleans out start point... a safety */

	state = SEEKING_START_PT;

	/* If the region_ids are not equal OR either region_id is not 0 AND
	 * the cosine of the angle between the normals is less than maxangle,
	 * plot a line or shade the plot to produce surface normals or give
	 * a sense of curvature.
	 */

	for (x=0; x < mem_width; x++, botp++, topp++)  {

		/* If the id's are not the same, or if bottom id is not
		 * zero, find pits (botp->c_dist+pit_depth < topp->c_dist)
		 * and mountains (topp->c_dist+pit_depth < botp->c_dist).
		 */

		if (botp->c_id != topp->c_id ||
		   ( botp->c_id != ID_BACKGROUND && 
		     ((botp->c_dist + pit_depth < topp->c_dist) ||
		      (topp->c_dist + pit_depth < botp->c_dist) ||
		      (VDOT(botp->c_normal, topp->c_normal) < maxangle))))  {
			if( state == FOUND_START_PT ) {
				continue;
			} else {
				/* find the correct cell. */
				start_cellp = find_cell(botp, topp);		

				/* Move to and remember left point.  If start_cellp
				 * is botp, then move left and up half a cell.
				 */

				if(botp == start_cellp)  {
					VJOIN2(start, start_cellp->c_hit, -0.5, dx_model, 0.5, dy_model);
				} else  {
					VJOIN2(start, start_cellp->c_hit, -0.5, dx_model, -0.5, dy_model);
				}

				state = FOUND_START_PT;
			}
		} else {
			/* points are the same */

			if (state == FOUND_START_PT) {

				/* Draw to current left edge 
				 * Note that x and y must be converted back
				 * to file coordinates so that the file
				 * picture gets plotted.  The 0.5 factors
				 * are for centering. This is for (x-1-0.5),
				 * y-1+0.5).  These file coordinate must then
				 * be expressed in model space.  That is done
				 * by starting at the hit_pt and adding or
				 * subtracting 0.5 cell for centering.
				 */

				cellp = find_cell( (botp-1), (topp-1) );

				/* If botp-1 is cellp, then move right and up
				 * by half a cell.  Otherwise, move right and down
				 * by half a cell.
				 */

				if( (botp-1) == cellp)  {
					VJOIN2(stop, cellp->c_hit, 0.5, dx_model, 0.5, dy_model);
				} else {
					VJOIN2(stop, cellp->c_hit, 0.5, dx_model, -0.5, dy_model);
				}

				pdv_3line(outfp, start, stop);
				state = SEEKING_START_PT;
			} else {
				continue;
			}
		}
	}
		
	/* Now check for end of scan-line. */
	if (state == FOUND_START_PT) {

			/* Note that x and y must be converted back
			 * to file coordinates so that the file
			 * picture gets plotted.  The 0.5 factors
			 * are for centering.  This is for (x-1-0.5), (y-1+0.5).
			 * These file coordinates must then be expressed in
			 * model space.  That is done by starting at the
			 * hit_pt and adding or subtracting 0.5 cell for
			 * centering.
			 */

		cellp = find_cell( (botp-1), (topp-1) );

			/* If botp-1 is cellp, then move right and up
			 * by half a cell.  Otherwise, move right and down
			 * by half a cell.
			 */

		if( (botp-1) == cellp)  {
			VJOIN2(stop, cellp->c_hit, 0.5, dx_model, 0.5, dy_model);
		} else {
			VJOIN2(stop, cellp->c_hit, 0.5, dx_model, -0.5, dy_model);
		}

		pdv_3line(outfp, start, stop);
		state = SEEKING_START_PT;
	}
}



/*
 *	           F I N D_ C E L L
 *
 *  This routine takes pointers to two cells.  This is more efficient (takes
 *  less space) than sending the hit_distances.  Furthermore, by selecting
 *  a cell, rather than just a distance, more information becomes available
 *  to the calling routine.
 *  If the region_ids of neighboring pixels do not match, compare their
 *  respective hit_distances.  If either distance is zero, select the
 *  non-zero distance for plotting; otherwise, select the lesser of the
 *  two distances.  Return a pointer to the cell with the smaller hit_distance.
 *  Using this hit_distance will be more esthetically pleasing for the bas-
 *  relief.
 */

struct	cell	*
find_cell (struct cell *cur_cellp, struct cell *next_cellp)
{
	struct cell	*cellp;

	if (cur_cellp->c_dist == 0)
		cellp = next_cellp;
	else if (next_cellp->c_dist == 0)
		cellp = cur_cellp;
	else if (cur_cellp->c_dist < next_cellp->c_dist )
		cellp = cur_cellp;
	else
		cellp = next_cellp;

	return (cellp);
}


/*		S W A P B U F F
 *
 *  This routine serves to swap buffer pointers: i.e., one buffer is read
 *  at a time.  The first buffer read becomes the "bottom buffer" the new
 *  buffer becomes the "top buffer".  Once the vertical comparison between
 *  the two buffers has been done, the "top buffer" now becomes the "bottom
 *  buffer" and is retained, while the erstwhile "bottom buffer" is the new
 *  "top buffer", which is overwritten when the next line of information is
 *  read.
 *  This routine takes as its parameters the address of two pointers to buffers.
 *  It manipulates these, but returns nothing.
 */

void
swapbuff(struct cell **onepp, struct cell **twopp)
           	        		/* caveat: variables must start w/ letters */
            	        

{

	struct cell	*temp_p;	/* caveat: hyphens are read as "minus" */

	temp_p = *onepp;
	*onepp = *twopp;
	*twopp = temp_p;

}





/*		C L E A N L I N E
 *
 *  This routine takes as paramenters the address of a buffer and an integer
 *  reflecting the width of the file.  It proceeds to ZERO fill the buffer.
 *  This routine returns nothing.
 */

void
cleanline(struct cell *inbuffp, int file_width)
{

	int	i;

	for(i = 0; i < file_width + 2; i++, inbuffp++)  {
		inbuffp->c_id = ID_BACKGROUND;
		inbuffp->c_dist = 0;
		VSET(inbuffp->c_hit, 0, 0, 0);
		VSET(inbuffp->c_normal, 0, 0, 0);
		VSET(inbuffp->c_rdir, 0, 0, 0);
	}
}

void application_init (void) {}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header: /cvs/brlcad/rt/viewhide.c,v 11.15 2004/04/05 05:45:59 morrison Exp $ (BRL)";
@


11.15
log
@merge of ansi-6-0-branch into head
@
text
@d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header$ (BRL)";
d39 5
a43 1
#include "conf.h"
@


11.14
log
@update copyright to include span through 2003
@
text
@d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.13 2002/08/20 17:08:39 jra Exp $ (BRL)";
d71 5
a75 5
void		swapbuff();
void		cleanline();
void		horiz_cmp();
void		vert_cmp();
struct cell	*find_cell();
d104 1
a104 1
int	rayhit(), raymiss();
d117 1
a117 3
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
d143 1
a143 2
view_2init( ap )
struct application	*ap;
d231 1
a231 2
raymiss( ap )
register struct application	*ap;
d269 1
a269 1
view_pixel()
d274 2
a275 2
void view_setup() {}
void view_cleanup() {}
d288 1
a288 3
rayhit( ap, PartHeadp )
struct application *ap;
register struct partition *PartHeadp;
d362 1
a362 3
void	view_eol(ap)
struct application *ap;

d394 1
a394 2
view_end(ap)
struct application *ap;
d420 1
a420 5
horiz_cmp(botp, mem_width, y)
struct cell	*botp;
int		mem_width;
int		y;

d509 1
a509 6
vert_cmp(botp, topp, mem_width, y)
struct cell	*botp;
struct cell	*topp;
int		mem_width;
int		y;

d645 1
a645 3
find_cell ( cur_cellp, next_cellp)
struct	cell	*cur_cellp;
struct	cell	*next_cellp;
d676 3
a678 3
swapbuff(onepp, twopp)
struct cell	**onepp;		/* caveat: variables must start w/ letters */
struct cell 	**twopp;
d702 1
a702 4
cleanline(inbuffp, file_width)
struct cell	*inbuffp;
int		file_width;

d716 1
a716 1
void application_init () {}
@


11.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1989 by the United States Army.
d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.11 2000/08/17 02:41:40 mike Exp $ (BRL)";
@


11.13.4.1
log
@sync to HEAD...
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/viewhide.c,v 11.14 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.13.10.1
log
@merge from HEAD
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.14 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.13.10.2
log
@merge from head
@
text
@d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.13.10.1 2004/02/12 19:37:14 erikg Exp $ (BRL)";
@


11.13.2.1
log
@Initial ANSIfication
@
text
@d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.13 2002/08/20 17:08:39 jra Exp $ (BRL)";
d71 5
a75 5
void		swapbuff(struct cell **onepp, struct cell **twopp);
void		cleanline(struct cell *inbuffp, int file_width);
void		horiz_cmp(struct cell *botp, int mem_width, int y);
void		vert_cmp(struct cell *botp, struct cell *topp, int mem_width, int y);
struct cell	*find_cell(struct cell *cur_cellp, struct cell *next_cellp);
d104 1
a104 1
int	rayhit(register struct application *ap, struct partition *PartHeadp), raymiss(register struct application *ap);
d117 3
a119 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d145 2
a146 1
view_2init(struct application *ap)
d234 2
a235 1
raymiss(register struct application *ap)
d273 1
a273 1
view_pixel(void)
d278 2
a279 2
void view_setup(void) {}
void view_cleanup(void) {}
d292 3
a294 1
rayhit(struct application *ap, register struct partition *PartHeadp)
d368 3
a370 1
void	view_eol(struct application *ap)
d402 2
a403 1
view_end(struct application *ap)
d429 5
a433 1
horiz_cmp(struct cell *botp, int mem_width, int y)
d522 6
a527 1
vert_cmp(struct cell *botp, struct cell *topp, int mem_width, int y)
d663 3
a665 1
find_cell (struct cell *cur_cellp, struct cell *next_cellp)
d696 3
a698 3
swapbuff(struct cell **onepp, struct cell **twopp)
           	        		/* caveat: variables must start w/ letters */
            	        
d722 4
a725 1
cleanline(struct cell *inbuffp, int file_width)
d739 1
a739 1
void application_init (void) {}
@


11.13.2.2
log
@sync branch with HEAD
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header$ (BRL)";
@


11.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d71 5
a75 5
void		swapbuff(struct cell **onepp, struct cell **twopp);
void		cleanline(struct cell *inbuffp, int file_width);
void		horiz_cmp(struct cell *botp, int mem_width, int y);
void		vert_cmp(struct cell *botp, struct cell *topp, int mem_width, int y);
struct cell	*find_cell(struct cell *cur_cellp, struct cell *next_cellp);
d104 1
a104 1
int	rayhit(register struct application *ap, struct partition *PartHeadp), raymiss(register struct application *ap);
d117 3
a119 1
view_init(register struct application *ap, char *file, char *obj, int minus_o)
d145 2
a146 1
view_2init(struct application *ap)
d234 2
a235 1
raymiss(register struct application *ap)
d273 1
a273 1
view_pixel(void)
d278 2
a279 2
void view_setup(void) {}
void view_cleanup(void) {}
d292 3
a294 1
rayhit(struct application *ap, register struct partition *PartHeadp)
d368 3
a370 1
void	view_eol(struct application *ap)
d402 2
a403 1
view_end(struct application *ap)
d429 5
a433 1
horiz_cmp(struct cell *botp, int mem_width, int y)
d522 6
a527 1
vert_cmp(struct cell *botp, struct cell *topp, int mem_width, int y)
d663 3
a665 1
find_cell (struct cell *cur_cellp, struct cell *next_cellp)
d696 3
a698 3
swapbuff(struct cell **onepp, struct cell **twopp)
           	        		/* caveat: variables must start w/ letters */
            	        
d722 4
a725 1
cleanline(struct cell *inbuffp, int file_width)
d739 1
a739 1
void application_init (void) {}
@


11.11
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d36 1
a36 1
static const char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.10 2000/07/27 19:32:53 butler Exp $ (BRL)";
d71 5
a75 5
void		swapbuff();
void		cleanline();
void		horiz_cmp();
void		vert_cmp();
struct cell	*find_cell();
d104 1
a104 1
int	rayhit(), raymiss();
d117 1
a117 3
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
d143 1
a143 2
view_2init( ap )
struct application	*ap;
d231 1
a231 2
raymiss( ap )
register struct application	*ap;
d269 1
a269 1
view_pixel()
d274 2
a275 2
void view_setup() {}
void view_cleanup() {}
d288 1
a288 3
rayhit( ap, PartHeadp )
struct application *ap;
register struct partition *PartHeadp;
d362 1
a362 3
void	view_eol(ap)
struct application *ap;

d394 1
a394 2
view_end(ap)
struct application *ap;
d420 1
a420 5
horiz_cmp(botp, mem_width, y)
struct cell	*botp;
int		mem_width;
int		y;

d509 1
a509 6
vert_cmp(botp, topp, mem_width, y)
struct cell	*botp;
struct cell	*topp;
int		mem_width;
int		y;

d645 1
a645 3
find_cell ( cur_cellp, next_cellp)
struct	cell	*cur_cellp;
struct	cell	*next_cellp;
d676 3
a678 3
swapbuff(onepp, twopp)
struct cell	**onepp;		/* caveat: variables must start w/ letters */
struct cell 	**twopp;
d702 1
a702 4
cleanline(inbuffp, file_width)
struct cell	*inbuffp;
int		file_width;

d716 1
a716 1
void application_init () {}
@


11.10
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.9 2000/07/25 16:39:48 butler Exp $ (BRL)";
@


11.9
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.8 1999/05/28 01:19:29 mike Exp $ (BRL)";
d49 1
@


11.8
log
@
sed4
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.7 1998/09/22 00:21:29 mike Exp $ (BRL)";
d48 1
a48 1
#include "rdebug.h"
@


11.7
log
@Doesn't need material.h
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /c/CVS/brlcad/rt/viewhide.c,v 11.6 1997/01/08 00:01:55 mike Exp $ (BRL)";
d163 1
a163 1
	 * Rather than using malloc(), though, rt_malloc() is used.  This
d165 1
a165 1
	 * if there is no memory.  Also, rt_malloc() takes a string as its
d172 1
a172 1
	botp = (struct cell *)rt_malloc(sizeof(struct cell) * (width + 2),
d174 1
a174 1
	topp = (struct cell *)rt_malloc(sizeof(struct cell) * (width + 2),
@


11.6
log
@libbu / libbn
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 11.5 1997/01/02 21:07:31 jra Exp mike $ (BRL)";
a46 1
#include "./material.h"
@


11.5
log
@ removed extra "extern double mat_radtodeg".
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 11.4 1996/08/30 00:08:21 butler Exp jra $ (BRL)";
d87 1
a87 1
	{"",	0, (char *)0,	0,	FUNC_NULL }
d158 1
a158 1
		rt_log("Note: changing from %d cpus to 1 cpu\n", npsw );
d199 1
a199 1
		maxangle = cos( 5.0 * mat_degtorad);
d201 1
a201 1
		maxangle = cos( AmbientIntensity * mat_degtorad);
d315 1
a315 1
		rt_log("rthide/rayhit:  no hit out front? x%d y%d lvl%d\n",
@


11.4
log
@structparse moved to libbu
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 11.3 1996/03/29 23:20:55 mike Exp butler $ (BRL)";
a65 1
extern	double	mat_degtorad;		/* converts degrees to radians used by rt */
@


11.3
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 11.2 1995/12/06 17:57:53 pjt Exp mike $ (BRL)";
d87 1
a87 1
struct structparse view_parse[] = {
@


11.2
log
@Added a stub for application_init()
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 11.1 1995/01/04 10:01:27 mike Rel4_4 pjt $ (BRL)";
d322 5
a326 11
	/* Calculate the hit normal and the hit distance.  This is done
	 * by giving RT_HIT_NORM() the address of the hit partition so it
	 * can fill this in.  From there the hit point and the hit normal
	 * can be extracted.
	 *
	 *  Note:  In addition to giving the surface normal, it also
	 *  computes:
	 *  VJOIN1( hitp->hit_point, ap->a_ray.r_pt,
	 *	hitp->hit_dist, ap->a_ray.r_dir );
	 */
	RT_HIT_NORM(hitp, pp->pt_inseg->seg_stp, &(ap->a_ray));
d338 1
a354 4
	posp->c_dist = hitp->hit_dist;
	VMOVE(posp->c_hit, hitp->hit_point);
	VMOVE(posp->c_normal, hitp->hit_normal);
	VMOVE(posp->c_rdir, ap->a_ray.r_dir);
@


11.1
log
@Release_4.4
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 10.4 94/11/05 03:08:05 mike Exp $ (BRL)";
d748 2
@


10.4
log
@Irix 6
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 10.3 94/08/11 02:46:46 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@Added include of conf.h
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 10.2 1992/05/04 15:55:41 mike Exp gdurf $ (BRL)";
a298 2
	fastf_t			dist;   	/* ray distance */
	int			region_id;	/* solid region's id */
@


10.2
log
@regionfix is now in librt, automaticly invoked on rt_prep().
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 10.1 91/10/12 06:42:21 mike Rel4_0 Locker: mike $ (BRL)";
d38 2
@


10.1
log
@Release_4.0
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.32 91/07/16 00:30:51 mike Exp $ (BRL)";
a159 2

/***	regionfix( ap, "rtray.regexp" );		/* XXX */
@


9.32
log
@Added code to ensure that inhit is in front of emanation plane.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.31 91/07/16 00:13:28 mike Exp $ (BRL)";
@


9.31
log
@PJT improved usage message
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.30 91/07/06 00:35:30 mike Exp $ (BRL)";
d301 1
d314 10
d331 2
a332 2
	 *  VJOIN1( pp->pt_inhit->hit_point, ap->a_ray.r_pt,
	 *	pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
d334 1
a334 1
	RT_HIT_NORM(pp->pt_inhit, pp->pt_inseg->seg_stp, &(ap->a_ray));
d362 3
a364 3
	posp->c_dist = pp->pt_inhit->hit_dist;
	VMOVE(posp->c_hit, pp->pt_inhit->hit_point);
	VMOVE(posp->c_normal, pp->pt_inhit->hit_normal);
@


9.30
log
@ANSI structure initialization
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.29 91/07/03 13:19:40 pjt Exp $ (BRL)";
d91 1
a91 1
Usage:  rthide [options] model.g objects... >file.ray\n\
@


9.29
log
@Fixed the usage line, which had said "-o model.g",
and now says "-o output.pl"
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.28 91/02/20 00:51:33 mike Exp $ (BRL)";
d86 1
a86 1
	"",	0, (char *)0,	0,	FUNC_NULL
@


9.28
log
@Added new view-module interface called view_setup() which is used
for initializing material properties, lights, etc.
It compliments view_cleanup(), and finally removed knowledge of
the view.c materials (and all the shaders) from the RT "top half".
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.27 91/02/13 11:09:04 sue Exp $ (BRL)";
d98 1
a98 1
 -o model.g	Specify output file (default=stdout)\n\
@


9.27
log
@Changed the background setting from "0" to "-999" and made it a #define
called ID_BACKGROUND.  Also, I shut off the evaluation of internal air,
which had been 1 and is now 0.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/viewhide.c,v 9.26 91/01/05 03:09:25 mike Exp $ (BRL)";
d279 2
a280 4
void view_cleanup()
{

}
@


9.26
log
@Converted to new format for fmt entry in structparse
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.25 91/01/02 13:55:26 sue Exp $ (BRL)";
d52 1
d80 1
a80 1
int		use_air = 1;		/* Handling of air in librt */
d258 1
a258 1
	posp->c_id = 0;
d279 2
a280 1
void view_cleanup() {}
d282 3
d351 1
a351 1
	if(posp->c_id == 0)
d472 1
a472 1
		   ( botp->c_id != 0 && 
d558 1
a558 1
		   ( botp->c_id != 0 && 
d734 2
a735 2
		inbuffp->c_id = '\0';
		inbuffp->c_dist = '\0';
@


9.25
log
@Removed an extraneous rt_log() that  printed out the width of the
input file (originally for diagnostic purposes).
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/viewhide.c,v 9.24 90/12/18 20:18:32 mike Exp $ (BRL)";
d85 1
a85 1
	(char *)0, 0, (char *)0,	0,	FUNC_NULL
@


9.24
log
@Moved parallel processing shut-off code,
to allow RTHIDE to take advantage of parallel prepping where available.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.23 90/12/14 22:07:10 mike Exp $ (BRL)";
a171 1
	rt_log("view_init2: %d width\n", width);
@


9.23
log
@Added notice to user if requested parallel processing will not be used.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/viewhide.c,v 9.22 90/12/12 16:35:19 butler Exp $ (BRL)";
a119 5
	if( npsw != 1 )  {
		rt_log("Note: changing from %d to one cpu\n", npsw );
		npsw = 1;		/* Disable parallel processing */
	}

d149 10
@


9.22
log
@modified to reflect changes in structparse format
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.21 90/12/11 16:55:02 mike Exp $ (BRL)";
d120 4
a123 1
	npsw = 1;			/* Disable parallel processing */
@


9.21
log
@Commented out "region id" fix
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.20 90/12/11 16:54:37 mike Exp $ (BRL)";
d85 1
a85 1
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.20
log
@It is not necessary to use a framebuffer.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.19 90/12/11 16:42:18 mike Exp $ (BRL)";
d152 1
a152 1
	regionfix( ap, "rtray.regexp" );		/* XXX */
@


9.19
log
@For now, can't run in parallel.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.18 90/12/11 16:39:24 sue Exp $ (BRL)";
d128 1
a128 6
	if( minus_o )  {
		return(0);		/* No framebuffer needed */
	} else {
		/* write to stdout */
		return(1);
	}
@


9.18
log
@Adding -o support
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.17 90/11/14 15:43:40 mike Exp $ (BRL)";
d64 2
d119 2
@


9.17
log
@As part of "clean" command, call "view_cleanup()", to allow
viewing module the opportunity to clean up things like implicit
light sources, etc.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.16 90/11/02 09:18:59 sue Exp $ (BRL)";
a60 1
static FILE	*plotfp;
a117 3
	if( outfp == NULL )
		outfp = stdout;

d122 1
a122 1
	output_is_binary = 0;		/* output is printable ascii */
d124 5
a128 9

	/* Open a plotfile for writing and check that a valid file pointer
	 * has been acquired.
	 */

	plotfp = fopen("hide.pl", "w");
	if( plotfp == NULL)  {
		perror("hide.pl");
		exit(1);
a129 3


	return(0);		/* No framebuffer needed */
d204 1
a204 1
	pdv_3space(plotfp, ap->a_rt_i->rti_pmin, ap->a_rt_i->rti_pmax);
a401 3
	/* Close plotfile. */
	fclose(plotfp);

d493 1
a493 1
			pdv_3line(plotfp, start, stop);
d598 1
a598 1
				pdv_3line(plotfp, start, stop);
d632 1
a632 1
		pdv_3line(plotfp, start, stop);
@


9.16
log
@Added some "error checking" in the region_id determination code.  Now,
if there is a hit and the region_id is null or zero, it is set to 1
so the it will be distinguished from the background.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.15 90/10/07 18:57:04 sue Exp $ (BRL)";
d282 2
@


9.15
log
@This version gets the overlays right.  Hadn't noticed in the previous 
version that the mged overlays would not match up correctly. The bug
has been fixed.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.14 90/10/05 21:35:35 mike Exp $ (BRL)";
d345 6
@


9.14
log
@Added a comment.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /m/cad/rt/RCS/viewhide.c,v 9.13 90/10/03 13:00:29 sue Exp $ (BRL)";
a304 7
	/*
	 * Output the ray data: screen plane (pixel) coordinates
	 * for x and y positions of a ray, region_id, and hit_distance.
	 * The x and y positions are represented by ap->a_x and ap->a_y.
	 *
	 *  Assume all rays are parallel.
	 */
a305 3
	dist = pp->pt_inhit->hit_dist;
	region_id = pp->pt_regionp->reg_regionid;

d336 10
a345 2
	posp->c_id = region_id;
	posp->c_dist = dist;
a434 2
	point_t		beg;		/* beginning point of line */
	point_t		end;		/* end point of line */
d492 2
a493 2
		   		VJOIN2(beg, cellp->c_hit, 0.5, dx_model, -0.5, dy_model);
		   		VJOIN2(end, cellp->c_hit, 0.5, dx_model, 0.5, dy_model);
d495 2
a496 2
			   	VJOIN2(beg, cellp->c_hit, -0.5, dx_model, -0.5, dy_model);
		   		VJOIN2(end, cellp->c_hit, -0.5, dx_model, 0.5, dy_model);
a498 6

		   	/* Now fashion the starting and stopping vectors. */

		   	VJOIN1(start, beg, cellp->c_dist, cellp->c_rdir);
		   	VJOIN1(stop, end, cellp->c_dist, cellp->c_rdir);

a533 2
	point_t		beg;
	point_t		end;
d535 1
a535 1
	VSET(beg, 0, 0, 0);
a536 1

d568 1
a568 1
					VJOIN2(beg, start_cellp->c_hit, -0.5, dx_model, 0.5, dy_model);
d570 1
a570 1
					VJOIN2(beg, start_cellp->c_hit, -0.5, dx_model, -0.5, dy_model);
a572 1
				VJOIN1(start, beg, start_cellp->c_dist, start_cellp->c_rdir);
d599 1
a599 1
					VJOIN2(end, cellp->c_hit, 0.5, dx_model, 0.5, dy_model);
d601 1
a601 1
					VJOIN2(end, cellp->c_hit, 0.5, dx_model, -0.5, dy_model);
a603 1
				VJOIN1(stop, end, cellp->c_dist, cellp->c_rdir);
d633 1
a633 1
			VJOIN2(end, cellp->c_hit, 0.5, dx_model, 0.5, dy_model);
d635 1
a635 1
			VJOIN2(end, cellp->c_hit, 0.5, dx_model, -0.5, dy_model);
a636 2

		VJOIN1(stop, end, cellp->c_dist, cellp->c_rdir);
@


9.13
log
@This version has the dynamic memory allocation moved to view_init2.  This
time it works fine and doesn't have a problem with mged.  Also, some
logging (rt_log, et. al.) have been introduced.
@
text
@d36 1
a36 1
static char RCSrayhide[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/viewhide.c,v 9.2 90/07/29 23:14:36 sue Exp $ (BRL)";
d327 5
a332 1

@


9.12
log
@This version has the dynamic memory allocation moved into view_2init.
@
text
@d176 2
d245 5
d315 6
@


9.11
log
@This revision now supports the -A (angle) option. A user can now specify
the shading cut-off angle by using this option and a number of degrees.
@
text
@a127 9
	/* malloc() two buffers that have room for as many struct cell 's
	 * as the incoming file is wide (width), plus two for the border.
	 * Rather than using malloc(), though, rt_malloc() is used.  This
	 * has the advantage of inbuild error-checking and automatic aborting
	 * if there is no memory.  Also, rt_malloc() takes a string as its
	 * final parameter: this tells the usr exactly where memory ran out.
	 * The file_height is counted by using ap->a_y directly. The benefit
	 * of this is WHAT?
	 */
a128 5
	botp = (struct cell *)rt_malloc(sizeof(struct cell) * (width + 2),
		"bottom cell buffer" );
	topp = (struct cell *)rt_malloc(sizeof(struct cell) * (width + 2),
		"top cell buffer" );

a138 4
	/* Clear both in-buffers to ensure abscence of garbage.  Note 
	 * that the zero-filled "bottom" buffer now provides the first
	 * in-memory buffer for comparisons.
	 */
a139 3
	cleanline(botp, width);
	cleanline(topp, width);

d166 24
d224 2
@


9.10
log
@Support for pits and pendula has been added.  It now correctly shades
steep cliffs or abrupt changes in height.
@
text
@a51 1
#define MAXANGLE 0.9961947		/* cos 5 */
d63 2
d66 1
d92 1
d172 3
d187 17
d403 1
a403 1
 *  MAXANGLE, then a line s drawn.
d431 1
a431 1
		 * is compared against MAXANGLE, which must be determined
d435 1
a435 1
		 * Note that MAXANGLE needs to be greater than the cosine
d440 1
a440 1
		 * of the angle between the normals is less than MAXANGLE. 
d452 1
a452 1
 		     (VDOT(botp->c_normal, (botp + 1)->c_normal) < MAXANGLE))))  {
d531 1
a531 1
	 * the cosine of the angle between the normals is less that MAXANGLE,
d547 1
a547 1
		      (VDOT(botp->c_normal, topp->c_normal) < MAXANGLE))))  {
@


9.9
log
@The "space" command has just been successfully added.  The original image
now fills the screen when it comes up.
@
text
@d55 5
a59 5
	float	c_dist;		/* distance from emanation plane to in_hit */
	int	c_id;		/* region_id of component hit */
	point_t	c_hit;		/* 3-space hit point of ray */
	vect_t	c_normal;	/* surface normal at the hit point */
	vect_t	c_rdir;		/* ray direction, permits perspective */
d64 1
d188 10
d419 4
a422 1
		 * Furthermore, it is necessary to select the hit_point
d427 3
a429 1
		   (VDOT(botp->c_normal, (botp + 1)->c_normal) < MAXANGLE)))  {
d514 6
d522 3
a524 1
		   (VDOT(botp->c_normal, topp->c_normal) < MAXANGLE)))  {
@


9.8
log
@This version has had the 
"hair" on the left edge of the picture removed.  At this time, a
fully competent image is obtained.
@
text
@d165 3
a167 1
 *  main() in rt.c.
d179 8
d188 1
@


9.7
log
@The screen coordinates have now been converted to model space coordinates.
Caveat: the plot must be rotated to the same az./el. it was raytraced
at in order to look intelligible.  However, all the coordinates and the
distances are accurate.
The next task should be to optionally allow the plot to be viewed "looking"
right.... this will require the coordinates to lose their accuracy.
Also, it is necessary to allow the user to specify the cosine of the angle
between surface normals below which he wishes no shading to occur.
@
text
@d417 5
d423 7
a429 2
		   	VJOIN2(beg, cellp->c_hit, 0.5, dx_model, -0.5, dy_model);
		   	VJOIN2(end, cellp->c_hit, 0.5, dx_model, 0.5, dy_model);
d431 1
d489 1
a489 1
		   (VDOT(botp->c_normal, (botp + 1)->c_normal) < MAXANGLE)))  {
d496 10
a505 2
				/* Move to and remember left point */
				VJOIN2(beg, start_cellp->c_hit, -0.5, dx_model, 0.5, dy_model);
d515 1
a515 1
				/* Note that x and y must be converted back
d525 13
a537 2
				cellp = find_cell( start_cellp, find_cell( (botp-1), (topp-1) ) );
				VJOIN2(end, cellp->c_hit, -0.5, dx_model, 0.5, dy_model);
d540 1
a540 1
					state = SEEKING_START_PT;
d561 12
a572 1
		VJOIN2(end, cellp->c_hit, -0.5, dx_model, 0.5, dy_model);
@


9.6
log
@topp[ap->a_x + 1] was stored in a struct cell pointer to prevent its
having to be recomputed every time it is used.  This should speed up
rthide.
@
text
@d34 1
a34 1
/* Note, this produced a hide.p of 6660096 when it was aborted! */
d59 1
d69 1
a69 1
double		find_z();
d209 1
a210 1

d283 1
d369 5
a373 1
	double		z;
a374 1

d397 1
d404 1
a404 8
			if( botp->c_dist == 0  )
				z = (botp+1)->c_dist;
			else if( (botp+1)->c_dist == 0 )
				z = botp->c_dist;
			else if( botp->c_dist < (botp+1)->c_dist )
				z = botp->c_dist;
			else
				z = (botp+1)->c_dist;
d406 9
a414 5
			/* Note that x and y must be converted back
			 * to file coordinates so that the file
			 * picture gets plotted.  The 0.5 factors
			 * are for centering.  The x and y variables
			 * represent screen coordinates.
d417 10
a426 5
			pd_3line(plotfp,
				(x -1 +0.5), (y -1 -0.5), z,
				(x -1 +0.5), (y -1 +0.5), z);
printf("horiz_cmp: height %d; pixelpos %d; mem_width %d; id=%d; z=%g\n",
				y, x, mem_width, botp->c_id, z);
d455 3
d459 4
a462 4
	register int	x;
	double		start_x;
	double		start_y;
	double		start_z;
d464 1
a464 3
	start_x = 0;
	start_y = 0;
	start_z = 0;
d482 6
a487 7
		
				/* move to and remember left point */
				start_x = (x -1 - 0.5);
				start_y = (y -1 + 0.5);
				start_z = find_z(
					botp->c_dist,
					topp->c_dist );
d495 1
a495 2
				/* draw to current left edge */

d499 5
a503 1
				 * are for centering.
a504 1
printf("vert_cmp: plotting pixpos %d, height %d, start_z %g\n", x, y, start_z);
d506 4
a509 6
				pd_3line(plotfp,
					start_x, start_y, start_z,
					(x -1 -0.5), (y -1 +0.5),
					find_z( start_z, 
						find_z( (botp-1)->c_dist,
						(topp-1)->c_dist ) ) );
d521 1
a521 1
v			 * to file coordinates so that the file
d523 5
a527 1
			 * are for centering.
a528 1
printf("vert_cmp: eos: pixpos %d, height %d, start_z %g\n", x, y, start_z);
d530 5
a534 4
		pd_3line(start_x, start_y, start_z,
			(x -1 -0.5), (y -1 +0.5),
			find_z( (botp-1)->c_dist,
				(topp-1)->c_dist) );
d542 1
a542 1
 *	           F I N D_ Z 
d544 4
d551 3
a553 1
 *  two distances.
d556 4
a559 4
double
find_z ( cur_z, next_z)
double cur_z;
double next_z;
d561 1
a561 1
	double z;
d563 6
a568 6
	if (cur_z == 0)
		z = next_z;
	else if (next_z == 0)
		z = cur_z;
	else if (cur_z < next_z )
		z = cur_z;
d570 1
a570 1
		z = next_z;
d572 1
a572 2
printf("find_z(%g,%g)=%g\n", cur_z, next_z, z);
	return (z);
d629 1
@


9.5
log
@This version now has functioning horizontal and vertical surface normals.
@
text
@d190 4
d204 4
a207 4
	topp[ap->a_x + 1].c_id = 0;
	topp[ap->a_x + 1].c_dist = 0;
	VSET(topp[ap->a_x +1].c_hit, 0, 0, 0);
	VSET(topp[ap->a_x + 1].c_normal, 0, 0, 0);
d240 1
d257 1
d278 4
a281 4
	topp[ap->a_x + 1].c_id = region_id;
	topp[ap->a_x + 1].c_dist = dist;
	VMOVE(topp[ap->a_x + 1].c_hit, pp->pt_inhit->hit_point);
	VMOVE(topp[ap->a_x + 1].c_normal, pp->pt_inhit->hit_normal);
@


9.4
log
@Initial surface normals added to the horizontal comparison routine.
@
text
@d258 1
a258 4
printf("starting RT_HIT_NORM(pp->pt_inhit,....)\n");
/* pp->pt_inhit doesn't dump core, but does nothing for the picture; &()
 * dumps core.  hitp, as expected, does not compile.
 */
a259 1
printf("done RT_HIT_NORM()\n");
d261 1
d382 4
d453 7
d461 3
a463 1
		if (botp->c_id != topp->c_id)  {
@


9.3
log
@This version has the integration of hide.c and the original viewhide.c.
It works at this time and gives competent images.  It does not yet
do surface normals, and also, the coordinate system is still screen
coordinates.
@
text
@d34 1
d52 1
a53 1

d253 9
a261 1
	/* Calculate the hit normal and the hit distance */
d263 1
d351 3
a353 2
 *  plotted to mark to boundary where the region_id codes change.
 *
d374 11
d387 4
a390 1
		if (botp->c_id != (botp+1)->c_id)  {
@


9.2
log
@Changed a few strings, and changed a_onehit = 0 to a_onehit = 1.
@
text
@d1 1
a1 1
 /*
d7 4
a10 3
 *  model.  It consists of a front end that writes a ray data
 *  file, and a post-processor, which reads said file and is
 *  responsible for producing the UnixPlot file.
d17 1
a17 1
 *
d22 1
d33 1
d35 1
a35 1
static char RCSrayhide[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/viewhide.c,v 9.1 89/05/19 05:59:57 mike Rel3_5 $ (BRL)";
d48 3
a50 2
/* x, y, region_id, hit_dist */
#define	SHOT_FMT	"%d %d %d %g\n"
d52 21
d100 5
a104 3
 *  This routine is called by main().  
 *  Furthermore, pointers to rayhit() and raymiss() are set up
 *  and are later called from do_run().
d106 1
d122 33
d165 1
d190 7
a196 3
	 * The distance travelled by the ray and the region_id of the area
	 * missed are both set to 0.  However, the pixel coordinates where
	 * the miss occurred are calculated.
d198 7
a204 3
	fprintf( outfp, SHOT_FMT,
		ap->a_x, ap->a_y,
		0, 0.0 );
d213 1
d224 3
a226 2
 *  writes a hit to the ray file.
 *  An rt_hide file is written for the post-processor to read.
d228 1
a234 3
	register struct partition *nextpp = pp->pt_forw;
	struct partition	*np;	/* next partition */
	struct partition	air;
a235 1
	char			*fmt;		/* printf() format string */
d248 1
a250 4
	
	fprintf(outfp, SHOT_FMT,
		ap->a_x, ap->a_y,
		region_id, dist );
d252 17
d275 6
a280 2
 *  View_eol() is called by rt_shootray() in do_run().  In this case,
 *  it does nothing.
d282 4
a285 1
void	view_eol()
d287 15
d304 1
d308 6
a313 1
 *  View_end() is called by rt_shootray in do_run().
d315 1
d317 2
a318 1
view_end()
d321 7
d329 243
@


9.1
log
@Release_3.5
@
text
@d4 1
a4 1
 *  Ray Tracing program RT_HIDE bottom half.
d20 1
a20 1
 *	Dr. Susanne L. Muuss
d32 1
a32 1
static char RCSrayhide[] = "@@(#)$Header: viewhide.c,v 1.4 89/05/07 20:38:31 mike Exp $ (BRL)";
d59 1
a59 1
Usage:  rt_hide [options] model.g objects... >file.ray\n\
d90 1
a90 1
	ap->a_onehit = 0;
@


1.4
log
@Minor cleanups
@
text
@d32 1
a32 1
static char RCSrayhide[] = "@@(#)$Header: viewhide.c,v 1.3 89/04/04 05:02:29 mike Locked $ (BRL)";
@


1.3
log
@Converted to new way of representing structure offsets.
@
text
@d32 1
a32 1
static char RCSrayhide[] = "@@(#)$Header: viewhide.c,v 1.2 89/04/03 15:25:42 mike Locked $ (BRL)";
d42 1
a42 1

a47 8
/***** view.c variables imported from rt.c *****/
extern int	output_is_binary;	/* !0 means output file is binary */

/***** worker.c variables imported from rt.c *****/
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
/*****/

a56 1
FILE            *plotfp;		/* optional plotting file */
a57 3
extern FILE	*outfp;			/* optional output file */


a93 7
#ifdef
	if(rdebug & RDEBUG_RAYPLOT) {
		plotfp = fopen("rt_hide.pl", "w");
	}
#endif


a111 1
	
a168 2


a171 1
	
a178 1

a184 35

#ifdef
		if( (region_id = pp->pt_regionp->reg_regionid) <= 0 )  {
			region_id = 1;
		}


		/* A color rtg3.pl UnixPlot file of output commands
		 * is generated.  This is processed by plot(1)
		 * plotting filters such as pl-fb or pl-xxx.
		 * Inhits are assigned green; outhits are assigned
		 * blue.
		 */

		if(rdebug & RDEBUG_RAYPLOT) {
			vect_t     inpt;
			vect_t     outpt;
			VJOIN1(inpt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
				ap->a_ray.r_dir);
			VJOIN1(outpt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist,
				ap->a_ray.r_dir);
				pl_color(plotfp, 0, 255, 0);	/* green */
			pdv_3line(plotfp, inpt,outpt);
			
			if(air_thickness > 0) {
				vect_t     air_end;
				VJOIN1(air_end, ap->a_ray.r_pt,
					pp->pt_outhit->hit_dist + air_thickness,
					ap->a_ray.r_dir);
				pl_color(plotfp, 0, 0, 255);	/* blue */
				pdv_3cont(plotfp, air_end);
			}
		}
	}
#endif
@


1.2
log
@Improved comments.
@
text
@d32 1
a32 1
static char RCSrayhide[] = "@@(#)$Header: viewhide.c,v 1.1 89/03/30 21:47:12 sue Locked $ (BRL)";
d61 3
a63 3
 struct structparse view_parse[] = {
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
 };
@


1.1
log
@Initial revision
@
text
@a9 8
 *  The output format is:
 *  		view title
 *  			ray data
 *  		production of the UnixPlot file from the ray data
 *  
 *  
 *			 :
 *			 :
d13 3
a15 3
 *  to produce a three dimensional line drawing of an MGED object.
 *  Three dimensionality is is achieved through the rotation of the
 *  MGED model interrogated.
d17 3
a19 1
 *  Authors -
a20 1
 *	Michael John Muuss
d32 1
a32 1
static char RCSrayhide[] = "@@(#)$Header: viewhide.c,v sue Exp $ (BRL)";
d139 1
a139 2
 *  do_frame(). Writes out data necessary to record where a miss
 *  miss was scored.
d196 3
a198 3
	 * Output the ray data: distance to hit, region_id, screen
	 * plane (pixel) coordinates for x and y positions of a ray.
	 * These positions are represented by ap->a_x and ap->a_y.
@
