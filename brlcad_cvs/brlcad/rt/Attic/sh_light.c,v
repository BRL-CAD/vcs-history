head	11.22;
access;
symbols
	rel-4-5:11.19
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.14
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.22
date	98.09.22.01.43.11;	author mike;	state dead;
branches;
next	11.21;

11.21
date	98.06.30.22.54.18;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	98.03.26.08.06.43;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	98.01.13.11.45.36;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	98.01.13.10.42.10;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	97.12.09.04.46.58;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	97.03.04.05.46.36;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.02.27.04.38.09;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.02.14.09.22.36;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.02.14.09.07.06;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.08.14.03.45.51;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.07.24.17.07.38;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.07.22.20.34.18;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.05.09.03.24.58;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.08.19.05.07.15;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.06;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.11.05.02.51.28;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.10.31.23.15.16;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.10.31.23.11.26;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.02.22.48;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.05.06.03.27.40;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.05.06.01.17.38;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.05.05.23.00.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.08;	author mike;	state Rel4_0;
branches;
next	9.21;

9.21
date	91.09.18.14.01.22;	author butler;	state Exp;
branches;
next	9.20;

9.20
date	91.08.30.03.49.53;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.08.16.16.23.15;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.08.16.15.15.48;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.08.16.14.18.56;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.07.16.00.05.10;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.07.06.00.35.19;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.30.03.02.49;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.06.14.08.25.32;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.02.17.20.15.52;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.01.05.03.09.11;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.12.16.35.05;	author butler;	state Exp;
branches;
next	9.9;

9.9
date	90.12.08.08.58.08;	author butler;	state Exp;
branches;
next	9.8;

9.8
date	90.12.05.06.13.56;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.11.14.14.46.06;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.11.11.04.52.54;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.10.19.36.29;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.02.03.16.40;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.07.31.00.50.23;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.27.02.19.10;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.33;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.30.20.38.37;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.04.05.01.58;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.27.16.34.11;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.03.19.08;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.32.44;	author mike;	state Rel3_0;
branches;
next	7.6;

7.6
date	88.08.19.04.02.07;	author phil;	state Exp;
branches;
next	7.5;

7.5
date	88.06.21.00.56.01;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.02.28.11;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.27.02.31.28;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.26.05.39.53;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.53.53;	author mike;	state Rel;
branches;
next	6.8;

6.8
date	87.10.22.18.37.05;	author mike;	state Exp;
branches;
next	6.7;

6.7
date	87.10.16.00.48.40;	author mike;	state Exp;
branches;
next	6.6;

6.6
date	87.09.21.21.24.44;	author mike;	state Exp;
branches;
next	6.5;

6.5
date	87.09.16.04.27.59;	author mike;	state Exp;
branches;
next	6.4;

6.4
date	87.09.11.02.52.20;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.09.11.02.05.31;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.10.07.14.32;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.58.23;	author mike;	state Rel;
branches;
next	5.4;

5.4
date	87.06.27.06.46.04;	author phil;	state Exp;
branches;
next	5.3;

5.3
date	87.06.27.03.52.39;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.57.45;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.14.22;	author mike;	state Rel;
branches;
next	1.4;

1.4
date	87.05.31.04.35.16;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.05.30.04.20.27;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.03.23.23.48.33;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.03.17.20.21.12;	author mike;	state Exp;
branches;
next	;


desc
@Material property module for handling light sources.
@


11.22
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@/*
 *			L I G H T . C
 *
 *  Implement simple isotropic light sources as a material property.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1987 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSlight[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_light.c,v 11.21 1998/06/30 22:54:18 mike Exp mike $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "rtlist.h"
#include "raytrace.h"
#include "./material.h"
#include "./mathtab.h"
#include "./light.h"
#include "./rdebug.h"

#define LIGHT_O(m)	offsetof(struct light_specific, m)
#define LIGHT_OA(m)	offsetofarray(struct light_specific, m)

RT_EXTERN(HIDDEN void	aim_set, (CONST struct bu_structparse *sdp, CONST char *name,
			CONST char *base, char *value));

struct bu_structparse light_parse[] = {
	{"%f",	1, "inten",	LIGHT_O(lt_intensity),	FUNC_NULL },
	{"%f",	1, "angle",	LIGHT_O(lt_angle),	FUNC_NULL },
	{"%f",	1, "fract",	LIGHT_O(lt_fraction),	FUNC_NULL },
	{"%f",	3, "aim",	LIGHT_OA(lt_dir),	aim_set },
	{"%d",	1, "shadows",	LIGHT_O(lt_shadows),	FUNC_NULL },
	{"%d",	1, "infinite",	LIGHT_O(lt_infinite),	FUNC_NULL },
	{"%d",	1, "invisible",	LIGHT_O(lt_invisible),	FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
};

struct light_specific	LightHead;	/* Heads linked list of lights */

extern double AmbientIntensity;

HIDDEN int	light_setup(), light_render();
HIDDEN void	light_print();
void		light_free();

struct mfuncs light_mfuncs[] = {
	{MF_MAGIC,	"light",	0,		MFI_NORMAL,	0,
	light_setup,	light_render,	light_print,	light_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

/*
 *			A I M _ S E T
 *
 *  This routine is called by bu_struct_parse() if the "aim"
 *  qualifier is encountered, and causes lt_exaim to be set.
 */

HIDDEN void aim_set (sdp, name, base, value)
CONST struct bu_structparse *sdp;
CONST char *name;
CONST char *base;
char *value;
{
	register struct light_specific *lp =
		(struct light_specific *)base;

	lp->lt_exaim = 1;
}

/*
 *			L I G H T _ R E N D E R
 *
 *  If we have a direct view of the light, return it's color.
 *  A cosine term is needed in the shading of the light source,
 *  to make it have dimension and shape.  However, just a simple
 *  cosine of the angle between the normal and the direction vector
 *  leads to a pretty dim looking light.  Therefore, a cos/2 + 0.5
 *  term is used when the viewer is within the beam, and a cos/2 term
 *  when the beam points away.
 */
HIDDEN int
light_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
{
	register struct light_specific *lp =
		(struct light_specific *)dp;
	register fastf_t f;

	RT_CK_LIGHT(lp);

	/* Provide cosine/2 shading, to make light look round */
	if( (f = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )*0.5) < 0 )
		f = 0;

	/* See if surface normal falls in light beam direction */
	if( VDOT( lp->lt_aim, swp->sw_hit.hit_normal) < lp->lt_cosangle )  {
		/* dark, outside of light beam area */
		f *= lp->lt_fraction;
	} else {
		/* within beam area */
		f = (f+0.5) * lp->lt_fraction;
	}
	VSCALE( swp->sw_color, lp->lt_color, f );
	return(1);
}

/*
 *			L I G H T _ S E T U P
 *
 *  Called once for each light-emitting region.
 */
HIDDEN int
light_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct rt_vls	*matparm;
genptr_t	*dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
{
	register struct light_specific *lp;
	register struct soltab *stp;
	vect_t	work;
	fastf_t	f;

	RT_VLS_CHECK( matparm );
	GETSTRUCT( lp, light_specific );

	RT_LIST_MAGIC_SET( &(lp->l), LIGHT_MAGIC );
	lp->lt_intensity = 1000.0;	/* Lumens */
	lp->lt_fraction = -1.0;		/* Recomputed later */
	lp->lt_invisible = 0;		/* explicitly modeled */
	lp->lt_shadows = 1;		/* by default, casts shadows */
	lp->lt_angle = 180;		/* spherical emission by default */
	lp->lt_exaim = 0;		/* use default aiming mechanism */
	lp->lt_infinite = 0;
	lp->lt_rp = rp;
	lp->lt_name = rt_strdup( rp->reg_name );
	if( bu_struct_parse( matparm, light_parse, (char *)lp ) < 0 )  {
		rt_free( (char *)lp, "light_specific" );
		return(-1);
	}

	if( lp->lt_angle > 180 )  lp->lt_angle = 180;
	lp->lt_cosangle = cos( (double) lp->lt_angle * 0.0174532925199433 );

	/* Determine position and size */
	if( rp->reg_treetop->tr_op == OP_SOLID )  {

		stp = rp->reg_treetop->tr_a.tu_stp;
		VMOVE( lp->lt_pos, stp->st_center );
		lp->lt_radius = stp->st_aradius;
	} else {
		vect_t	min_rpp, max_rpp;
		vect_t	rad;
		register union tree *tp;

		if( rt_bound_tree( rp->reg_treetop, min_rpp, max_rpp ) < 0 )
			return(-1);

		if( max_rpp[X] >= INFINITY )  {
			rt_log("light_setup(%s) Infinitely large light sources not supported\n",
				lp->lt_name );
			return(-1);
		}
		VADD2SCALE( lp->lt_pos, min_rpp, max_rpp, 0.5 );
		VSUB2( rad, max_rpp, lp->lt_pos );
		/* Use smallest radius from center to max as light radius */
		/* Having the radius too large can give very poor lighting */
		if( rad[X] < rad[Y] )
			lp->lt_radius = rad[X];
		else
			lp->lt_radius = rad[Y];
		if( rad[Z] < lp->lt_radius )
			lp->lt_radius = rad[Z];

		/* Find first leaf node on left of tree */
		tp = rp->reg_treetop;
		while( tp->tr_op != OP_SOLID )
			tp = tp->tr_b.tb_left;
		stp = tp->tr_a.tu_stp;
	}

	/* Light is aimed down -Z in it's local coordinate system */
	{
		register matp_t	matp;
		if( (matp = stp->st_matp) == (matp_t)0 )
			matp = (matp_t)rt_identity;
		if (lp->lt_exaim) {
			VSUB2 (work, lp->lt_dir, lp->lt_pos);
			VUNITIZE (work);
			}
		   else VSET( work, 0, 0, -1 );
		MAT4X3VEC( lp->lt_aim, matp, work );
		VUNITIZE( lp->lt_aim );
	}

	if( rp->reg_mater.ma_override )  {
		VMOVE( lp->lt_color, rp->reg_mater.ma_color );
	} else {
		VSETALL( lp->lt_color, 1 );
	}

	VMOVE( lp->lt_vec, lp->lt_pos );
	f = MAGNITUDE( lp->lt_vec );
	if( f < SQRT_SMALL_FASTF ) {
		/* light at the origin, make its direction vector up */
		VSET( lp->lt_vec, 0, 0, 1 );
	} else {
		VSCALE( lp->lt_vec, lp->lt_vec, f );
	}

	/* Add to linked list of lights */
	if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		RT_LIST_INIT( &(LightHead.l) );
	}
	RT_LIST_INSERT( &(LightHead.l), &(lp->l) );

	if( lp->lt_invisible )  {
		lp->lt_rp = REGION_NULL;
		/* Note that *dpp (reg_udata) is left null */
		return(0);	/* don't show light, destroy it */
	}

	*dpp = (genptr_t)lp;	/* Associate lp with reg_udata */
	return(1);
}

/*
 *			L I G H T _ P R I N T
 */
HIDDEN void
light_print( rp, dp )
register struct region *rp;
char	*dp;
{
	bu_struct_print(rp->reg_name, light_parse, (char *)dp);
}

/*
 *			L I G H T _ F R E E
 */
void
light_free( cp )
char *cp;
{
	register struct light_specific *light =
		(struct light_specific *)cp;

	RT_CK_LIGHT(light);
	RT_LIST_DEQUEUE( &(light->l) );
	if( light->lt_name )  {
		rt_free( light->lt_name, "light name" );
		light->lt_name = (char *)0;
	}
	light->l.magic = 0;	/* sanity */
	rt_free( (char *)light, "light_specific" );
}

/*
 *			L I G H T _ M A K E R
 *
 *  Special hook called by view_2init to build 1 or 3 debugging lights.
 */
void
light_maker(num, v2m)
int	num;
mat_t	v2m;
{
	register struct light_specific *lp;
	register int i;
	vect_t	temp;
	vect_t	color;
	char	name[64];

	/* Determine the Light location(s) in view space */
	for( i=0; i<num; i++ )  {
		switch(i)  {
		case 0:
			/* 0:  At left edge, 1/2 high */
			VSET( color, 1,  1,  1 );	/* White */
			VSET( temp, -1, 0, 1 );
			break;

		case 1:
			/* 1: At right edge, 1/2 high */
			VSET( color,  1, .1, .1 );	/* Red-ish */
			VSET( temp, 1, 0, 1 );
			break;

		case 2:
			/* 2:  Behind, and overhead */
			VSET( color, .1, .1,  1 );	/* Blue-ish */
			VSET( temp, 0, 1, -0.5 );
			break;

		default:
			return;
		}
		GETSTRUCT( lp, light_specific );
		lp->l.magic = LIGHT_MAGIC;
		VMOVE( lp->lt_color, color );
		MAT4X3VEC( lp->lt_pos, v2m, temp );
		VMOVE( lp->lt_vec, lp->lt_pos );
		VUNITIZE( lp->lt_vec );

		sprintf(name, "Implicit light %d", i);
		lp->lt_name = rt_strdup(name);

		VSET( lp->lt_aim, 0, 0, -1 );	/* any direction: spherical */
		lp->lt_intensity = 1000.0;
		lp->lt_radius = 0.1;		/* mm, "point" source */
		lp->lt_invisible = 1;		/* NOT explicitly modeled */
		lp->lt_shadows = 0;		/* no shadows for speed */
		lp->lt_angle = 180;		/* spherical emission */
		lp->lt_cosangle = -1;		/* cos(180) */
		lp->lt_infinite = 0;
		lp->lt_rp = REGION_NULL;
		if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
			RT_LIST_INIT( &(LightHead.l) );
		}
		RT_LIST_INSERT( &(LightHead.l), &(lp->l) );
	}
}

/*
 *			L I G H T _ I N I T
 *
 *  Special routine called by view_2init() to determine the relative
 *  intensities of each light source.
 *
 *  Because of the limited dynamic range of RGB space (0..255),
 *  the strategy used here is a bit risky.  We find the brightest
 *  single light source in the model, and assume that the energy from
 *  multiple lights will not shine on a single location in such a way
 *  as to add up to an overload condition.
 *  We then account for the effect of ambient light, because it always
 *  adds it's contribution.  Even here we only expect 50% of the ambient
 *  intensity, to keep the pictures reasonably bright.
 */
int
light_init()
{
	register struct light_specific *lp;
	register int		nlights = 0;
	register fastf_t	inten = 0.0;

	if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		RT_LIST_INIT( &(LightHead.l) );
	}
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		nlights++;
		if( lp->lt_fraction > 0 )  continue;	/* overridden */
		if( lp->lt_intensity <= 0 )
			lp->lt_intensity = 1;		/* keep non-neg */
		if( lp->lt_intensity > inten )
			inten = lp->lt_intensity;
	}

	/* Compute total emitted energy, including ambient */
/**	inten *= (1 + AmbientIntensity); **/
	/* This is non-physical and risky, but gives nicer pictures for now */
	inten *= (1 + AmbientIntensity*0.5);

	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		if( lp->lt_fraction > 0 )  continue;	/* overridden */
		lp->lt_fraction = lp->lt_intensity / inten;
	}
	rt_log("Lighting: Ambient = %d%%\n", (int)(AmbientIntensity*100));
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		rt_log( "  %s: (%g, %g, %g), aimed at (%g, %g, %g)\n",
			lp->lt_name,
			lp->lt_pos[X], lp->lt_pos[Y], lp->lt_pos[Z],
			lp->lt_aim[X], lp->lt_aim[Y], lp->lt_aim[Z] );
		rt_log( "  %s: %s, %s, %g lumens (%d%%), halfang=%g\n",
			lp->lt_name,
			lp->lt_invisible ? "invisible":"visible",
			lp->lt_shadows ? "casts shadows":"no shadows",
			lp->lt_intensity,
			(int)(lp->lt_fraction*100),
			lp->lt_angle );
	}
	if( nlights > SW_NLIGHTS )  {
		rt_log("Number of lights limited to %d\n", SW_NLIGHTS);
		nlights = SW_NLIGHTS;
	}
	return(nlights);
}


/*
 *			L I G H T _ C L E A N U P
 *
 *  Called from view_end().
 *  Take care of releasing storage for any lights which will not
 *  be cleaned up by mlib_free():
 *	implicitly created lights, because they have no associated region, and
 *	invisible lights, because their region was destroyed.
 */
void
light_cleanup()
{
	register struct light_specific *lp, *zaplp;

	if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		RT_LIST_INIT( &(LightHead.l) );
		return;
	}
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		if( lp->lt_rp != REGION_NULL && lp->lt_invisible == 0 )  {
			/* Will be cleaned up by mlib_free() */
			continue;
		}
		zaplp = lp;
		lp = RT_LIST_PREV( light_specific, &(lp->l) );
		light_free( (genptr_t)zaplp );
	}
}
/**********************************************************************/
/* 
 *			L I G H T _ H I T
 *
 *  A light visibility test ray hit something.  Determine what this means.
 *
 *  Input -
 *	a_color[] contains the fraction of a the light that will be
 *	propagated back along the ray, so far.  If this gets too small,
 *	recursion through lots of glass ought to stop.
 *  Output -
 *	a_color[] contains the fraction of light that can be seen.
 *	RGB transmissions are separately indicated, to allow simplistic
 *	colored glass (with apologies to Roy Hall).
 *
 *  These shadow functions return a boolean "light_visible".
 * 
 *  This is a simplified algorithm, and could be improved.
 *  Reflected light can't be dealt with at all.
 *
 *  Would also be nice to return an actual energy level, rather than
 *  a boolean, which could account for distance, etc.
 */

int
light_hit(ap, PartHeadp, finished_segs )
struct application *ap;
struct partition *PartHeadp;
struct seg *finished_segs;
{
	register struct partition *pp;
	register struct region	*regp = NULL;
	struct application	sub_ap;
	struct shadework	sw;
	CONST struct light_specific	*lp;
	extern int	light_render();
	vect_t	filter_color;
	int	light_visible;
	int	air_sols_seen = 0;
	char	*reason = "???";

	RT_CK_LIST_HEAD(&finished_segs->l);

	lp = (struct light_specific *)(ap->a_uptr);
	RT_CK_LIGHT(lp);

	VSETALL( filter_color, 1 );

	/*XXX Bogus with Air.  We should check to see if it is the same 
	 * surface.
	 *
	 *  Since the light visibility ray started at the surface of a solid,
	 *  it is likely that the solid will be the first partition on
	 *  the list, with pt_outhit->hit_dist being roughly zero.
	 *  Don't start using partitions until pt_inhit->hit_dist is
	 *  slightly larger than zero, i.e., that the partition is not
	 *  including the start point.
	 *  The outhit distance needs to be checked too, so that if the
	 *  partition is heading through the solid toward the light
	 *  e.g. (-1,+50), then the fact that the light is obscured will
	 *  not be missed.
	 */
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
		if( pp->pt_regionp->reg_aircode != 0 )  {
			/* Accumulate transmission through each air lump */
			air_sols_seen++;

			/* Obtain opacity of this region, multiply */
			sw.sw_inputs = 0;
			sw.sw_transmit = sw.sw_reflect = 0.0;
			sw.sw_refrac_index = 1.0;
			sw.sw_xmitonly = 1;	/* only want sw_transmit */
			sw.sw_segs = finished_segs;
			VSETALL( sw.sw_color, 1 );
			VSETALL( sw.sw_basecolor, 1 );

			(void)viewshade( ap, pp, &sw );
			/* sw_transmit is only return */

			/* Clouds don't yet attenuate differently based on freq */
			VSCALE( filter_color, filter_color, sw.sw_transmit );
			continue;
		}
		if( pp->pt_inhit->hit_dist >= ap->a_rt_i->rti_tol.dist )
			break;
		if( pp->pt_outhit->hit_dist >= ap->a_rt_i->rti_tol.dist*10 )
			break;
	}
	if( pp == PartHeadp )  {
		pp=PartHeadp->pt_forw;
		RT_CK_PT(pp);

		if( lp->lt_invisible || lp->lt_infinite )  {
			light_visible = 1;
			VMOVE( ap->a_color, filter_color );
			reason = "Unobstructed invisible/infinite light";
			goto out;
		}

		if( air_sols_seen > 0 )  {
			light_visible = 1;
			VMOVE( ap->a_color, filter_color );
/* XXXXXXX This seems to happen with *every* light vis ray through air */
			reason = "Off end of partition list, air was seen";
			goto out;
		}

		if (pp->pt_inhit->hit_dist <= ap->a_rt_i->rti_tol.dist) {
			int retval;

			/* XXX This is bogus if air is being used */
			/* What has probably happened is that the shadow ray
			 * has produced an Out-hit from the current solid
			 * which looks valid, but is in fact an intersection
			 * with the current hit point.
			 */

			sub_ap = *ap;	/* struct copy */
			sub_ap.a_level++;
			/* pt_outhit->hit_point has not been calculated */
			VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt,
				pp->pt_outhit->hit_dist, ap->a_ray.r_dir);

			retval = rt_shootray( &sub_ap );

			ap->a_user = sub_ap.a_user;
			ap->a_uptr = sub_ap.a_uptr;
			ap->a_color[0] = sub_ap.a_color[0];
			ap->a_color[1] = sub_ap.a_color[1];
			ap->a_color[2] = sub_ap.a_color[2];
			VMOVE(ap->a_uvec, sub_ap.a_uvec);
			VMOVE(ap->a_vvec, sub_ap.a_vvec);
			ap->a_refrac_index = sub_ap.a_refrac_index;
			ap->a_cumlen = sub_ap.a_cumlen;
			ap->a_return = sub_ap.a_return;

			light_visible = retval;
			reason = "pressed on past start point";
			goto out;
		}


		rt_log("light_hit:  ERROR, nothing hit, sxy=%d,%d, dtol=%e\n",
			ap->a_x, ap->a_y,
			ap->a_rt_i->rti_tol.dist);
		rt_pr_partitions(ap->a_rt_i, PartHeadp, "light_hit pt list");
		light_visible = 0;
		reason = "error, nothing hit";
		goto out;
	}
	regp = pp->pt_regionp;

	/* Check to see if we hit the light source */
	if( lp->lt_rp == regp )  {
		VMOVE( ap->a_color, filter_color );
		light_visible = 1;
		reason = "hit light";
		goto out;
	}

	/* or something futher away than a finite invisible light */
	if( lp->lt_invisible && !(lp->lt_infinite) ) {
		vect_t	tolight;
		VSUB2( tolight, lp->lt_pos, ap->a_ray.r_pt );
		if( pp->pt_inhit->hit_dist >= MAGNITUDE(tolight) ) {
			VMOVE( ap->a_color, filter_color );
			light_visible = 1;
			reason = "hit behind invisible light ==> hit light";
			goto out;
		}
	}

	/* If we hit an entirely opaque object, this light is invisible */
	if( pp->pt_outhit->hit_dist >= INFINITY ||
	    (regp->reg_transmit == 0 /* XXX && Not procedural shader */) )  {
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
	    	reason = "hit opaque object";
		goto out;
	}

	/*  See if any further contributions will mater */
	if( ap->a_color[0] + ap->a_color[1] + ap->a_color[2] < 0.01 )  {
	    	/* Any light energy is "fully" attenuated by here */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		reason = "light fully attenuated before shading";
		goto out;
	}

	/*
	 *  Determine transparency parameters of this object.
	 *  All we really need here is the opacity information;
	 *  full shading is not required.
	 */
	sw.sw_inputs = 0;
	sw.sw_transmit = sw.sw_reflect = 0.0;
	sw.sw_refrac_index = 1.0;
	sw.sw_xmitonly = 1;		/* only want sw_transmit */
	sw.sw_segs = finished_segs;
	VSETALL( sw.sw_color, 1 );
	VSETALL( sw.sw_basecolor, 1 );

	(void)viewshade( ap, pp, &sw );
	/* sw_transmit is output */

	VSCALE( filter_color, filter_color, sw.sw_transmit );
	if( filter_color[0] + filter_color[1] + filter_color[2] < 0.01 )  {
	    	/* Any recursion won't be significant */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		reason = "light fully attenuated after shading";
		goto out;
	}

	/*
	 * Push on to exit point, and trace on from there.
	 * Transmission so far is passed along in sub_ap.a_color[];
	 * Don't even think of trying to refract, or we will miss the light!
	 */
	sub_ap = *ap;			/* struct copy */
	sub_ap.a_level = ap->a_level+1;
	{
		register fastf_t f;
		f = pp->pt_outhit->hit_dist + ap->a_rt_i->rti_tol.dist;
		VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt, f, ap->a_ray.r_dir);
	}
	sub_ap.a_purpose = "light transmission after filtering";
	light_visible = rt_shootray( &sub_ap );

	VELMUL( ap->a_color, sub_ap.a_color, filter_color );
	reason = "after filtering";
out:
	if( rdebug & RDEBUG_LIGHT ) bu_log("light vis=%d %s (%4.2f, %4.2f, %4.2f) %s %s\n",
		light_visible,
		lp->lt_name,
		V3ARGS(ap->a_color), reason,
		regp ? regp->reg_name : "" );
	return(light_visible);
}

/*
 *  			L I G H T _ M I S S
 *  
 *  If there is no explicit light solid in the model, we will always "miss"
 *  the light, so return light_visible = TRUE.
 */
/* ARGSUSED */
int
light_miss(ap)
register struct application *ap;
{
	struct light_specific *lp = (struct light_specific *)(ap->a_uptr);

	RT_CK_LIGHT(lp);
	if( lp->lt_invisible || lp->lt_infinite ) {
		VSETALL( ap->a_color, 1 );
		if( rdebug & RDEBUG_LIGHT ) rt_log("light_miss vis=1\n");
		return(1);		/* light_visible = 1 */
	}
	/* Missed light, either via blockage or dither.  Return black */
	VSETALL( ap->a_color, 0 );
	if( rdebug & RDEBUG_LIGHT ) rt_log("light_miss vis=0\n");
	return(0);			/* light_visible = 0 */
}

/*
 *			L I G H T _ V I S I B I L I T Y
 *
 *	Determine the visibility of each light source in the scene from a
 *	particular location.
 */
void
light_visibility(ap, swp, have)
struct application *ap;
struct shadework *swp;
int have;
{
		register struct light_specific *lp;
		register int	i;
		register fastf_t *intensity, *tolight;
		register fastf_t f;
		struct application sub_ap;

		if( rdebug & RDEBUG_LIGHT ) rt_log("computing Light visibility: start\n");

		/*
		 *  Determine light visibility
		 *
		 *  The sw_intensity field does NOT include the light's
		 *  emission spectrum (color), only path attenuation.
		 *  sw_intensity=(1,1,1) for no attenuation.
		 */
		i = 0;
		intensity = swp->sw_intensity;
		tolight = swp->sw_tolight;
		for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lp);
			/* compute the light direction */
			if( lp->lt_infinite ) {
				/* Infinite lights are point sources, no fuzzy penumbra */
				VMOVE( tolight, lp->lt_vec );
			} else {
				VSUB2(tolight, lp->lt_pos,
					swp->sw_hit.hit_point);
#if 0
		/*
		 *  Dither light pos for penumbra by +/- 0.5 light radius;
		 *  this presently makes a cubical light source distribution.
		 */
		f = lp->lt_radius * 0.9;
		tolight[X] = lp->lt_pos[X] +
			rand_half(ap->a_resource->re_randptr)*f -
			swp->sw_hit.hit_point[X];
		tolight[Y] = lp->lt_pos[Y] +
			rand_half(ap->a_resource->re_randptr)*f -
			swp->sw_hit.hit_point[Y];
		tolight[Z] = lp->lt_pos[Z] +
			rand_half(ap->a_resource->re_randptr)*f -
			swp->sw_hit.hit_point[Z];
#endif

			}

			/*
			 *  If we have a normal, test against light direction
			 */
			if( (have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
				if( VDOT(swp->sw_hit.hit_normal,tolight) < 0 ) {
					/* backfacing, opaque */
					if (rdebug & RDEBUG_LIGHT)
						bu_log("normal backfacing, opaque surface: %s\n", lp->lt_name);
					swp->sw_visible[i] = (char *)0;
					goto next;
				}
			}
			
			if (rdebug& RDEBUG_RAYPLOT) {
				point_t ray_endpt;

				pl_color(stdout, 200, 200, 200);
				VADD2(ray_endpt, swp->sw_hit.hit_point,
					tolight);
				pdv_3line(stdout, swp->sw_hit.hit_point,
					ray_endpt);
			}
			VUNITIZE( tolight );

			/*
			 * See if ray from hit point to light lies within light beam
			 * Note: this is should always be true for infinite lights!
			 */
			if( -VDOT(tolight, lp->lt_aim) < lp->lt_cosangle )  {
				/* dark (outside of light beam) */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("point outside beam, obscured: %s\n", lp->lt_name);

				swp->sw_visible[i] = (char *)0;
				goto next;
			}
			if( !(lp->lt_shadows) )  {
				/* "fill light" in beam, don't care about shadows */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("fill light, no shadow, visible: %s\n", lp->lt_name);
				swp->sw_visible[i] = (char *)lp;
				VSETALL( intensity, 1 );
				goto next;
			}

			/*
			 *  Fire ray at light source to check for shadowing.
			 *  (This SHOULD actually return an energy spectrum).
			 *  Advance start point slightly off surface.
			 */
			sub_ap = *ap;			/* struct copy */

			VMOVE( sub_ap.a_ray.r_dir, tolight );
			{
				register fastf_t f;
				f = ap->a_rt_i->rti_tol.dist;
				VJOIN1( sub_ap.a_ray.r_pt,
					swp->sw_hit.hit_point,
					f, tolight );
			}
			sub_ap.a_rbeam = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
			sub_ap.a_diverge = ap->a_diverge;

			sub_ap.a_hit = light_hit;
			sub_ap.a_miss = light_miss;
			sub_ap.a_user = -1;		/* sanity */
			sub_ap.a_uptr = (genptr_t)lp;	/* so we can tell.. */
			sub_ap.a_level = 0;
			/* Will need entry & exit pts, for filter glass ==> 2 */
			/* Continue going through air ==> negative */
			sub_ap.a_onehit = -2;

			VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
			sub_ap.a_purpose = lp->lt_name;	/* name of light shot at */

			RT_CK_LIGHT((struct light_specific *)(sub_ap.a_uptr));			


			if( rt_shootray( &sub_ap ) )  {
				/* light visible */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("light visible: %s\n", lp->lt_name);
				swp->sw_visible[i] = (char *)lp;
				VMOVE( intensity, sub_ap.a_color );
			} else {
				/* dark (light obscured) */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("light obscured: %s\n", lp->lt_name);
				swp->sw_visible[i] = (char *)0;
			}
next:
			/* Advance to next light */
			i++;
			intensity += 3;
			tolight += 3;
		}

		if( rdebug & RDEBUG_LIGHT ) rt_log("computing Light visibility: end\n");
}
@


11.21
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_light.c,v 11.20 1998/03/26 08:06:43 mike Exp $ (BRL)";
@


11.20
log
@light_miss doesn't get partition pointer.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.19 1998/01/13 11:45:36 mike Exp mike $ (BRL)";
d60 1
a60 1
CONST struct mfuncs light_mfuncs[] = {
@


11.19
log
@Added light name to visible/obscured debug messages
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.18 1998/01/13 10:42:10 mike Exp mike $ (BRL)";
d690 1
a690 1
light_miss(ap, PartHeadp)
a691 1
struct partition *PartHeadp;
@


11.18
log
@Added extra debug message
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.17 1997/12/31 09:01:40 mike Exp mike $ (BRL)";
d773 1
a773 1
						bu_log("backfacing, opaque\n");
d797 1
a797 1
					bu_log("outside beam\n");
d805 1
a805 1
					bu_log("fill light, no shadow\n");
d847 1
a847 1
					bu_log("light visible\n");
d853 1
a853 1
					bu_log("light obscured\n");
@


11.17
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.16 1997/12/09 04:46:58 butler Exp mike $ (BRL)";
d726 1
a726 1
		if( rdebug & RDEBUG_LIGHT ) rt_log("computing Light visibility\n");
d862 2
@


11.16
log
@misc debugging and now plots light visibility rays if RDEBUG_RAYPLOT set
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/sh_light.c,v 11.15 1997/11/25 22:16:43 butler Exp butler $ (BRL)";
d60 2
a61 2
struct mfuncs light_mfuncs[] = {
	{"light",	0,		0,		MFI_NORMAL,	0,
d64 1
a64 1
	{(char *)0,	0,		0,		0,		0,
@


11.15
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.14 1997/03/04 05:46:36 mike Exp butler $ (BRL)";
d726 2
d772 2
d778 10
d796 3
d804 2
d817 1
d826 3
d846 2
d852 2
@


11.14
log
@Process invisible and infinite lights.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.13 1997/02/27 04:38:09 mike Exp mike $ (BRL)";
d133 1
a133 1
light_setup( rp, matparm, dpp )
d137 2
@


11.13
log
@Clouds now cast shadows.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.12 1997/02/14 09:22:36 mike Exp mike $ (BRL)";
d482 3
d531 7
a591 2
	lp = (struct light_specific *)(ap->a_uptr);
	RT_CK_LIGHT(lp);
d672 5
a676 3
	if( rdebug & RDEBUG_LIGHT ) rt_log("light %s vis=%d (%4.2f, %4.2f, %4.2f) %s\n",
		regp ? regp->reg_name : "-miss-",
		light_visible, V3ARGS(ap->a_color), reason );
d726 4
@


11.12
log
@Got air "container" solids to stop casting shadows,
but the clouds inside the air don't cast shadows yet.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.11 1997/02/14 09:07:06 mike Exp mike $ (BRL)";
d470 1
a470 1
	register struct region	*regp;
d478 1
d482 2
d500 1
a500 1
			/* XXX Should be accumulating transmission through each */
d502 15
d528 7
a534 1
		if( air_sols_seen > 0 )  return 1;	/* light_visible = 1 */
d566 1
d575 3
a577 1
		return(0);		/* light_visible = 0 */
d585 1
a585 1
		VSETALL( ap->a_color, 1 );
d587 1
a587 1
		/* XXX Need to tally up air attenuation here */
d596 1
a596 1
			VSETALL( ap->a_color, 1 );
d598 1
a598 1
			/* XXX Need to tally up air attenuation here */
d608 1
d617 1
a620 2
	/* XXX Need to tally up air attenuation here */

d635 1
d637 1
a637 1
	VSCALE( filter_color, sw.sw_color, sw.sw_transmit );
d642 1
d662 1
d664 3
a666 1
	if( rdebug & RDEBUG_LIGHT ) rt_log("light %s vis=%d\n", regp->reg_name, light_visible);
@


11.11
log
@Additional butler comments.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.10 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d477 1
d496 5
d510 2
a515 1

d560 1
d571 1
d592 1
d665 3
a667 1
 *	Determine the visibility of each light source in the scen from a
d763 3
a765 2
			/* Will need entry & exit pts, for filter glass */
			sub_ap.a_onehit = 2;
@


11.10
log
@bu_struct_print
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.9 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d507 2
d569 1
a569 1
	    regp->reg_transmit == 0 )  {
@


11.9
log
@bu_struct_parse
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.8 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d254 1
a254 1
	bu_structprint(rp->reg_name, light_parse, (char *)dp);
@


11.8
log
@structparse moved to libbu
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.7 1996/08/14 03:45:51 butler Exp butler $ (BRL)";
d71 1
a71 1
 *  This routine is called by bu_structparse() if the "aim"
d156 1
a156 1
	if( bu_structparse( matparm, light_parse, (char *)lp ) < 0 )  {
@


11.7
log
@shadework structure "sw_segs" field needed to be filled in before calling viewshade
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/sh_light.c,v 11.6 1996/07/24 17:07:38 jra Exp butler $ (BRL)";
d38 1
a38 1
RT_EXTERN(HIDDEN void	aim_set, (CONST struct structparse *sdp, CONST char *name,
d41 1
a41 1
struct structparse light_parse[] = {
d71 1
a71 1
 *  This routine is called by rt_structparse() if the "aim"
d76 1
a76 1
CONST struct structparse *sdp;
d156 1
a156 1
	if( rt_structparse( matparm, light_parse, (char *)lp ) < 0 )  {
d254 1
a254 1
	rt_structprint(rp->reg_name, light_parse, (char *)dp);
@


11.6
log
@Added "sw.sw_inputs = 0;" to light_hit().
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.5 1996/07/22 20:34:18 jra Exp $ (BRL)";
d464 1
a464 1
light_hit(ap, PartHeadp)
d467 1
d478 1
d591 1
@


11.5
log
@Minor Mods for IRIX 6.2
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.4 1996/05/09 03:24:58 butler Exp jra $ (BRL)";
d585 1
@


11.4
log
@moved light visibility calculations in from shade.c
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.3 1995/10/20 04:43:53 butler Exp butler $ (BRL)";
d530 2
a531 1
			return ( retval );
d639 1
d644 1
@


11.3
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.2 1995/08/19 05:07:15 butler Exp butler $ (BRL)";
d31 1
d409 31
d462 2
d477 4
a480 1
	/*
d578 1
d628 1
d646 2
a647 7
 *			L I G H T _ C L E A N U P
 *
 *  Called from view_end().
 *  Take care of releasing storage for any lights which will not
 *  be cleaned up by mlib_free():
 *	implicitly created lights, because they have no associated region, and
 *	invisible lights, because their region was destroyed.
d650 4
a653 1
light_cleanup()
d655 67
a721 1
	register struct light_specific *lp, *zaplp;
d723 41
a763 9
	if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		RT_LIST_INIT( &(LightHead.l) );
		return;
	}
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		if( lp->lt_rp != REGION_NULL && lp->lt_invisible == 0 )  {
			/* Will be cleaned up by mlib_free() */
			continue;
a764 4
		zaplp = lp;
		lp = RT_LIST_PREV( light_specific, &(lp->l) );
		light_free( (genptr_t)zaplp );
	}
@


11.2
log
@cast viewshade to a void
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.1 1995/01/04 10:01:06 mike Rel4_4 butler $ (BRL)";
d60 1
a60 1
	{"light",	0,		0,		MFI_NORMAL,
d63 1
a63 1
	{(char *)0,	0,		0,
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.8 94/11/05 02:51:28 mike Exp $ (BRL)";
d552 1
a552 1
	viewshade( ap, pp, &sw );
@


10.8
log
@Irix 6, changed to a_uptr
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.7 94/10/31 23:15:16 mike Exp Locker: mike $ (BRL)";
@


10.7
log
@ANSI C nit.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.6 94/10/31 23:11:26 mike Exp Locker: mike $ (BRL)";
d506 1
a506 1
	lp = (struct light_specific *)(ap->a_user);
d594 1
a594 1
	struct light_specific *lp = (struct light_specific *)(ap->a_user);
@


10.6
log
@Bill Laut's new way of aiming lights.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.5 1994/08/11 02:22:48 gdurf Exp $ (BRL)";
d37 2
a38 1
HIDDEN int	aim_set (struct structparse *, char *, char *, char *);
@


10.5
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.4 1994/05/06 03:27:40 mike Exp gdurf $ (BRL)";
d35 1
d37 2
d43 1
d67 19
d150 1
d204 5
a208 1
		VSET( work, 0, 0, -1 );
@


10.4
log
@Fixed bug where pt_outhit->hit_point was not being calculated before used.
Sometimes, this would give signaling NaN's, which let me find it!
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.3 94/05/06 01:17:38 mike Exp Locker: mike $ (BRL)";
d21 2
@


10.3
log
@Changed to using new magic number checking routine.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.2 94/05/05 23:00:41 mike Exp Locker: mike $ (BRL)";
d351 1
d357 1
d407 1
a407 1
	struct light_specific	*lp;
d432 1
d445 3
a447 1
			VMOVE(sub_ap.a_ray.r_pt, pp->pt_outhit->hit_point);
@


10.2
log
@Fixed problem with light visibility checking.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.1 91/10/12 06:42:08 mike Rel4_0 Locker: mike $ (BRL)";
d82 2
d235 1
a235 1
	if( RT_LIST_MAGIC_WRONG( &(light->l), LIGHT_MAGIC ) )  rt_bomb("light_free magic");
d471 1
a471 1
	if( RT_LIST_MAGIC_WRONG( &(lp->l), LIGHT_MAGIC ) )  rt_bomb("light_hit magic");
d560 1
a560 1
	if( RT_LIST_MAGIC_WRONG( &(lp->l), LIGHT_MAGIC ) )  rt_bomb("light_miss magic");
d589 1
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/sh_light.c,v 9.21 91/09/18 14:01:22 butler Exp $ (BRL)";
d429 1
a429 1
		if (pp->pt_inhit->hit_dist <= 0.0) {
@


9.21
log
@Occasionally, the shadow ray will intersect the solid at the point where
the ray starts.  When this happens (inhit dist < 0 && outhit dist > 0)
we re-shoot the shadow ray starting at the outhit point of the previous ray.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.20 91/08/30 03:49:53 mike Exp $ (BRL)";
@


9.20
log
@Need to check outhit distance too, so that heading through the solid
towards the light won't be missed either.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.19 91/08/16 16:23:15 mike Exp $ (BRL)";
d428 31
@


9.19
log
@Added xy values to light_hit error message.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.18 91/08/16 15:15:48 mike Exp $ (BRL)";
d415 4
d420 6
a425 2
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_inhit->hit_dist >= ap->a_rt_i->rti_tol.dist )  break;
@


9.18
log
@Expanded diagnostics.
Changed ray advance distance from 0.0001 to rti_tol.dist
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.17 91/08/16 14:18:56 mike Exp $ (BRL)";
d420 3
a422 1
		rt_log("light_hit:  ERROR, nothing hit, vis=0, dtol=%e\n",ap->a_rt_i->rti_tol.dist);
@


9.17
log
@Made light_hit more robust, avoiding lights being shadowed by the
surface that the visibility ray was shot from.
Does not affect benchmark results, but seems like a good idea.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.16 91/07/16 00:05:10 mike Exp $ (BRL)";
d419 3
a421 1
		rt_log("light_hit:  ERROR, nothing hit, vis=0\n");
d491 2
a492 2
		FAST fastf_t f;
		f = pp->pt_outhit->hit_dist+0.0001;
@


9.16
log
@Slightly more conservative handling of *dpp (reg_udata)
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.15 91/07/06 00:35:19 mike Exp $ (BRL)";
d376 2
d408 8
d417 1
a417 1
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
@


9.15
log
@ANSI structure initialization
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.14 91/06/30 03:02:49 mike Exp $ (BRL)";
a115 1
	*dpp = (genptr_t)lp;
d204 1
d208 1
@


9.14
log
@ANSI oops
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.13 91/06/14 08:25:32 mike Exp $ (BRL)";
d35 7
a41 7
	"%f",	1, "inten",	LIGHT_O(lt_intensity),	FUNC_NULL,
	"%f",	1, "angle",	LIGHT_O(lt_angle),	FUNC_NULL,
	"%f",	1, "fract",	LIGHT_O(lt_fraction),	FUNC_NULL,
	"%d",	1, "shadows",	LIGHT_O(lt_shadows),	FUNC_NULL,
	"%d",	1, "infinite",	LIGHT_O(lt_infinite),	FUNC_NULL,
	"%d",	1, "invisible",	LIGHT_O(lt_invisible),	FUNC_NULL,
	"",	0, (char *)0,	0,			FUNC_NULL
d53 2
a54 2
	"light",	0,		0,		MFI_NORMAL,
	light_setup,	light_render,	light_print,	light_free,
d56 2
a57 2
	(char *)0,	0,		0,
	0,		0,		0,		0
@


9.13
log
@Changed st_pathmat to st_matp
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.12 91/02/17 20:15:52 mike Exp $ (BRL)";
d176 1
a176 1
			matp = rt_identity;
@


9.12
log
@Check return code from rt_structparse()
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.11 91/01/05 03:09:11 mike Exp $ (BRL)";
d173 8
a180 3
	VSET( work, 0, 0, -1 );
	MAT4X3VEC( lp->lt_aim, stp->st_pathmat, work );
	VUNITIZE( lp->lt_aim );
@


9.11
log
@Converted to new format for fmt entry in structparse
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.10 90/12/12 16:35:05 butler Exp $ (BRL)";
d127 4
a130 1
	rt_structparse( matparm, light_parse, (char *)lp );
@


9.10
log
@modified to reflect changes in structparse format
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.9 90/12/08 08:58:08 butler Exp $ (BRL)";
d41 1
a41 1
	(char *)0, 0,(char *)0,	0,			FUNC_NULL
@


9.9
log
@changed material property parameter to be struct rt_vls
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.8 90/12/05 06:13:56 mike Exp $ (BRL)";
d35 7
a41 7
	"%f",	"inten",	LIGHT_O(lt_intensity),	FUNC_NULL,
	"%f",	"angle",	LIGHT_O(lt_angle),	FUNC_NULL,
	"%f",	"fract",	LIGHT_O(lt_fraction),	FUNC_NULL,
	"%d",	"shadows",	LIGHT_O(lt_shadows),	FUNC_NULL,
	"%d",	"infinite",	LIGHT_O(lt_infinite),	FUNC_NULL,
	"%d",	"invisible",	LIGHT_O(lt_invisible),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.8
log
@Ooops, stray return statement.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.7 90/11/14 14:46:06 mike Exp $ (BRL)";
d106 1
a106 1
char		*matparm;
d114 1
@


9.7
log
@If light list is unitialized, initialize it, before proceeding.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.6 90/11/11 04:52:54 mike Exp $ (BRL)";
a322 1
		return;
@


9.6
log
@Invisible lights need special (non-mlib_free) cleanup.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.5 90/11/10 19:36:29 mike Exp $ (BRL)";
d321 4
d520 4
@


9.5
log
@Modified light_specific structure to use rtlist.h macros.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.4 90/11/02 03:16:40 mike Exp $ (BRL)";
d194 4
a197 2
	if( lp->lt_invisible )
		return(0);	/* don't show it */
d507 3
a509 1
 *  be cleaned up by mlib_free(), i.e., implicitly created lights.
d517 1
a517 1
		if( lp->lt_rp != REGION_NULL )  {
@


9.4
log
@Fixed error with freeing the light structure twice.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.3 90/07/31 00:50:23 mike Exp $ (BRL)";
d26 1
d44 1
a44 1
struct light_specific *LightHeadp = LIGHT_NULL;		/* Linked list of lights */
d106 2
a107 2
char	*matparm;
char	**dpp;
d115 1
a115 1
	*dpp = (char *)lp;
d117 1
d146 1
a146 1
			rt_log("light_setup(%s) Infinite light sources not supported\n",
d152 8
a159 2
		/* XXX This radius is way too big */
		lp->lt_radius = MAGNITUDE( rad );
a177 5
	rt_log( "%s at (%g, %g, %g), aimed at (%g, %g, %g), angle=%g\n",
		lp->lt_name,
		lp->lt_pos[X], lp->lt_pos[Y], lp->lt_pos[Z],
		lp->lt_aim[X], lp->lt_aim[Y], lp->lt_aim[Z],
		lp->lt_angle );
d189 4
a192 2
	lp->lt_forw = LightHeadp;
	LightHeadp = lp;
d221 2
a222 23
	if( LightHeadp == LIGHT_NULL )  {
		rt_log("light_free(x%x), list is null\n", cp);
		return;
	}
	if( LightHeadp == light )  {
		LightHeadp = LightHeadp->lt_forw;
	} else {
		register struct light_specific *lp;	/* current light */
		register struct light_specific **llp;	/* last light lt_forw */

		llp = &LightHeadp;
		lp = LightHeadp;
		while( lp != LIGHT_NULL )  {
			if( lp == light )  {
				*llp = lp->lt_forw;
				goto found;
			}
			llp = &(lp->lt_forw);
			lp = lp->lt_forw;
		}
		rt_log("light_free:  unable to find light in list\n");
	}
found:
d227 1
d272 1
d290 4
a293 2
		lp->lt_forw = LightHeadp;
		LightHeadp = lp;
d316 1
a316 1
	register int	nlights = 0;
d319 1
a319 1
	for( lp = LightHeadp; lp; lp = lp->lt_forw )  {
d333 1
a333 1
	for( lp = LightHeadp; lp; lp = lp->lt_forw )  {
d337 14
d401 1
a487 1
	extern struct light_specific *LightHeadp;
d490 1
d493 1
a493 1
		return( 1 );
d495 25
a519 4
	if( LightHeadp )  {
		/* Explicit lights exist, somehow we missed (dither?) */
		VSETALL( ap->a_color, 0 );
		return(0);		/* light_visible = 0 */
a520 4
	/* No explicit light -- it's hard to hit */
	rt_log( "light: warning - invisible light not on list?!\n" );
	VSETALL( ap->a_color, 1 );
	return(1);			/* light_visible = 1 */
a521 3

/* Null function */
nullf() { return(0); }
@


9.3
log
@Fixed problem with light_free skipping over first light in list.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.2 90/04/27 02:19:10 mike Exp $ (BRL)";
d213 2
d220 1
a220 1
	if( LightHeadp == (struct light_specific *)cp )  {
d229 1
a229 1
			if( lp == (struct light_specific *)cp )  {
d239 5
a243 3
	if( ((struct light_specific *)cp)->lt_name )
		rt_free( cp, "light name" );
	rt_free( cp, "light_specific" );
@


9.2
log
@Changed from using rt_rpp_tree to rt_bound_tree().
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: sh_light.c,v 9.1 89/05/19 05:59:33 mike Locked $ (BRL)";
d225 1
a225 1
		lp = LightHeadp->lt_forw;
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: sh_light.c,v 8.5 89/04/30 20:38:37 mike Exp $ (BRL)";
d136 2
a137 1
		vect_t	min_rpp, max_rpp, avg, rad;
d140 11
a150 7
		VSETALL( min_rpp,  INFINITY );
		VSETALL( max_rpp, -INFINITY );
		rt_rpp_tree( rp->reg_treetop, min_rpp, max_rpp );
		VADD2( avg, min_rpp, max_rpp );
		VSCALE( avg, avg, 0.5 );
		VMOVE( lp->lt_pos, avg );
		VSUB2( rad, max_rpp, avg );
@


8.5
log
@No longer depends on mathtab.h
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: sh_light.c,v 8.4 89/04/04 05:01:58 mike Locked $ (BRL)";
@


8.4
log
@Converted to new way of representing structure offsets.
@
text
@a0 1

d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 8.3 88/12/27 16:34:11 mike Locked $ (BRL)";
a27 1
#include "./mathtab.h"
@


8.3
log
@Converted matparse --> structparse
@
text
@d1 1
d20 1
a20 1
static char RCSlight[] = "@@(#)$Header: light.c,v 8.2 88/10/06 03:19:08 mike Locked $ (BRL)";
d33 1
d36 7
a42 7
	"%f",	"inten",	(stroff_t)&(LIGHT_NULL->lt_intensity),	FUNC_NULL,
	"%f",	"angle",	(stroff_t)&(LIGHT_NULL->lt_angle),	FUNC_NULL,
	"%f",	"fract",	(stroff_t)&(LIGHT_NULL->lt_fraction),	FUNC_NULL,
	"%d",	"shadows",	(stroff_t)&(LIGHT_NULL->lt_shadows),	FUNC_NULL,
	"%d",	"infinite",	(stroff_t)&(LIGHT_NULL->lt_infinite),	FUNC_NULL,
	"%d",	"invisible",	(stroff_t)&(LIGHT_NULL->lt_invisible),	FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d126 1
a126 1
	rt_structparse( matparm, light_parse, (stroff_t)lp );
d200 1
a200 1
	rt_structprint(rp->reg_name, light_parse, (stroff_t)dp);
@


8.2
log
@Fixed bug which could cause 'regp' to be dereferenced without having
been initialized, in the error recovery case.
really Rel 3.0
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 8.1 88/10/05 00:32:44 mike Rel3_0 $ (BRL)";
d33 8
a40 8
struct matparse light_parse[] = {
	"inten",	(mp_off_ty)&(LIGHT_NULL->lt_intensity),	"%f",
	"angle",	(mp_off_ty)&(LIGHT_NULL->lt_angle),	"%f",
	"fract",	(mp_off_ty)&(LIGHT_NULL->lt_fraction),	"%f",
	"shadows",	(mp_off_ty)&(LIGHT_NULL->lt_shadows),	"%d",
	"infinite",	(mp_off_ty)&(LIGHT_NULL->lt_infinite),	"%d",
	"invisible",	(mp_off_ty)&(LIGHT_NULL->lt_invisible),	"%d",
	(char *)0,	(mp_off_ty)0,				(char *)0
d124 1
a124 1
	mlib_parse( matparm, light_parse, (mp_off_ty)lp );
d198 1
a198 1
	mlib_print(rp->reg_name, light_parse, (mp_off_ty)dp);
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.6 88/08/19 04:02:07 phil Exp $ (BRL)";
d383 2
a384 3
		rt_log("light_hit:  no hit out front?\n");
		light_visible = 0;
		goto out;
@


7.6
log
@no shadows on default lights (for speed)
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.5 88/06/21 00:56:01 phil Locked $ (BRL)";
@


7.5
log
@Implicit lights have become invisible lights.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.4 88/05/14 02:28:11 mike Locked $ (BRL)";
d290 1
a290 1
		lp->lt_shadows = 1;		/* casts shadows */
@


7.4
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.3 88/02/27 02:31:28 mike Locked $ (BRL)";
d39 1
a39 1
	"implicit",	(mp_off_ty)&(LIGHT_NULL->lt_implicit),	"%d",
d118 1
a118 1
	lp->lt_implicit = 0;		/* explicitly modeled */
d184 1
a184 1
	if( lp->lt_implicit )
d289 1
a289 1
		lp->lt_implicit = 1;		/* NOT explicitly modeled */
d397 2
a398 2
	/* or something futher away than a finite implicit light */
	if( lp->lt_implicit && !(lp->lt_infinite) ) {
d480 1
a480 1
	if( lp->lt_implicit || lp->lt_infinite ) {
d490 1
a490 1
	rt_log( "light: warning - implicit light not on list?!\n" );
@


7.3
log
@Changed implicit light radius from 10 to 0.1 mm.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.2 88/01/26 05:39:53 mike Locked $ (BRL)";
d47 3
a49 2
HIDDEN int light_setup(), light_render(), light_print();
int light_free();
d94 1
d193 1
a193 1
HIDDEN int
d204 1
a204 1
int
d242 1
@


7.2
log
@infinite and implicit lights
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.1 87/11/02 23:53:53 phil Locked $ (BRL)";
d285 1
a285 1
		lp->lt_radius = 10.0;		/* 10 mm */
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.8 87/10/22 18:37:05 mike Exp $ (BRL)";
d36 1
d38 2
a39 1
	"fract",	(mp_off_ty)&(LIGHT_NULL->lt_fraction),	"%f",
d109 1
d116 1
a116 1
	lp->lt_explicit = 1;		/* explicitly modeled */
d119 2
d170 7
a176 1
	VUNITIZE( lp->lt_vec );
d182 3
d286 1
a286 1
		lp->lt_explicit = 0;		/* NOT explicitly modeled */
d290 2
d372 1
d386 3
a388 2
	/* Check to see if we hit a light source */
	if( ((struct mfuncs *)(regp->reg_mfuncs))->mf_render == light_render )  {
d394 11
d475 1
d477 4
d487 1
@


6.8
log
@Made default half-angle 180 degrees, instead of 90.
Spherical lights.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.7 87/10/16 00:48:40 mike Locked $ (BRL)";
@


6.7
log
@Added setting and use of lt_name, for better multi-light debugging.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.6 87/09/21 21:24:44 mike Locked $ (BRL)";
d115 1
a115 1
	lp->lt_angle = 90;		/* hemisphere emission by default */
@


6.6
log
@Added cosine shading to light sources
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.5 87/09/16 04:27:59 mike Exp $ (BRL)";
d116 1
d158 2
a159 1
	rt_log( "Light at (%g, %g, %g), aimed at (%g, %g, %g), angle=%g\n",
d216 2
d234 1
d265 3
@


6.5
log
@Looking at a directed light source now results in a reasonable
crescent shape -- the back side is half the intensity of the beam.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.4 87/09/11 02:52:20 mike Locked $ (BRL)";
d60 6
d76 1
a76 1
	register fastf_t f, dot;
d78 4
d83 1
a83 1
	if( (dot= VDOT( lp->lt_aim, swp->sw_hit.hit_normal)) < lp->lt_cosangle )  {
d85 1
a85 1
		f = lp->lt_fraction * 0.5;
d88 1
a88 1
		f = lp->lt_fraction;
@


6.4
log
@Added new parameters to implicit light routine as well.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.3 87/09/11 02:05:31 mike Locked $ (BRL)";
d49 1
a49 1
	"light",	0,		0,		0,
d72 2
a73 1
	if( (dot= -VDOT( ap->a_ray.r_dir, lp->lt_aim)) < lp->lt_cosangle )  {
@


6.3
log
@Added directional lights, and lights that don't cast shadows
for "fill lighting".
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.2 87/09/10 07:14:32 mike Locked $ (BRL)";
d249 2
d254 3
@


6.2
log
@Light visibility is now determined in viewshade();
supporting light hit&miss routines moved to light.c
plastic.c now merely implements Phong shading.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.1 87/07/11 07:58:23 mike Locked $ (BRL)";
d35 2
d70 1
d72 8
a79 1
	VSCALE( swp->sw_color, lp->lt_color, lp->lt_fraction );
d94 2
d103 2
d107 3
a111 1
		register struct soltab *stp;
d118 1
d128 6
d135 6
d146 5
a150 1
	VPRINT( "Light at", lp->lt_pos );
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 5.4 87/06/27 06:46:04 phil Exp $ (BRL)";
d239 1
d243 2
a244 2
	int nlights = 0;
	fastf_t	inten = 0.0;
d264 5
d270 132
@


5.4
log
@rendering parameter changes
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 5.3 87/06/27 03:52:39 phil Locked $ (BRL)";
@


5.3
log
@ma_rgb -> ma_color, changed to new multi-light intensity scaling.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 5.2 87/06/26 05:57:45 mike Locked $ (BRL)";
d60 1
a60 1
light_render( ap, pp, swp )
d64 1
d67 1
a67 1
		(struct light_specific *)pp->pt_regionp->reg_udata;
d78 1
a78 1
light_setup( rp )
d80 2
d86 1
a86 1
	rp->reg_udata = (char *)lp;
d91 1
a91 1
	mlib_parse( rp->reg_mater.ma_matparm, light_parse, (mp_off_ty)lp );
d132 1
a132 1
light_print( rp )
d134 1
d136 1
a136 1
	mlib_print(rp->reg_name, light_parse, (mp_off_ty)rp->reg_udata);
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 5.1 87/06/24 22:14:22 mike Locked $ (BRL)";
d110 1
a110 3
		VSET( lp->lt_color, rp->reg_mater.ma_rgb[0]/255.,
			rp->reg_mater.ma_rgb[1]/255.,
			rp->reg_mater.ma_rgb[2]/255. );
d225 9
d246 2
a247 1
		inten += lp->lt_intensity;
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 1.4 87/05/31 04:35:16 mike Exp $ (BRL)";
d47 1
a47 1
	"light",	0,		0,
d60 4
a63 3
light_render( ap, pp )
register struct application *ap;
register struct partition *pp;
d68 1
a68 1
	VSCALE( ap->a_color, lp->lt_color, lp->lt_fraction );
@


1.4
log
@Changed to using a non-physical exposure calculation to get
better pictures.  Switching to energy will make this correct.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 1.3 87/05/30 04:20:27 mike Exp $ (BRL)";
@


1.3
log
@Fixed bug in computing relative intensities of light source -vs-
ambient term.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 1.2 87/03/23 23:48:33 mike Locked $ (BRL)";
d242 3
a244 1
	inten *= (1 + AmbientIntensity);
@


1.2
log
@Revised for new material property interface.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 1.1 87/03/17 20:21:12 mike Exp $ (BRL)";
d236 2
d240 4
a243 1
	inten *= (1 - AmbientIntensity);
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 4.1 86/12/29 03:48:07 mike Rel1 $ (BRL)";
d43 2
d46 8
d59 1
d75 1
a75 1
int
a81 1
	rp->reg_ufunc = light_render;
a118 3
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, light_parse, (mp_off_ty)lp);

d124 44
@
