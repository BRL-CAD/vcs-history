head	11.16;
access;
symbols
	ansi-20040405-merged:11.12.2.2
	postmerge-20040405-ansi:11.14
	premerge-20040404-ansi:11.13
	postmerge-autoconf:11.13
	autoconf-freeze:11.12.10.2
	premerge-autoconf:11.13
	postmerge-20040315-windows:11.13
	premerge-20040315-windows:11.13
	windows-20040315-freeze:11.12.4.1
	autoconf-20031203:11.12
	autoconf-20031202:11.12
	autoconf-branch:11.12.0.10
	phong-branch:11.12.0.8
	photonmap-branch:11.12.0.6
	rel-6-1-DP:11.12
	windows-branch:11.12.0.4
	rel-6-0-2:11.10
	ansi-branch:11.12.0.2
	rel-6-0-1-branch:11.10.0.2
	hartley-6-0-post:11.11
	hartley-6-0-pre:11.10
	rel-6-0-1:11.10
	rel-6-0:11.10
	rel-5-4:11.4
	offsite-5-3-pre:11.8
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.16
date	2004.05.21.17.31.06;	author morrison;	state dead;
branches;
next	11.15;

11.15
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.14;

11.14
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2004.02.02.17.39.39;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.12.2.1
	11.12.4.1
	11.12.10.1;
next	11.11;

11.11
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.10;

11.10
date	2001.04.02.21.38.30;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2001.03.31.01.57.31;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2000.08.25.21.13.53;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.17.02.41.36;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.13.01.30.05;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.10.23.08.54;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.07.02.22.19.46;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.05.28.01.17.26;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.01.08.03.47.38;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.00.57;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.00.39.50;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.01;	author mike;	state Rel4_0;
branches;
next	1.19;

1.19
date	91.07.17.20.54.18;	author sue;	state Exp;
branches;
next	1.18;

1.18
date	91.07.10.13.45.51;	author sue;	state Exp;
branches;
next	1.17;

1.17
date	91.07.05.12.37.24;	author sue;	state Exp;
branches;
next	1.16;

1.16
date	91.06.26.16.43.47;	author sue;	state Exp;
branches;
next	1.15;

1.15
date	91.06.03.15.31.27;	author sue;	state Exp;
branches;
next	1.14;

1.14
date	91.06.03.15.20.28;	author sue;	state Exp;
branches;
next	1.13;

1.13
date	91.06.01.21.39.02;	author sue;	state Exp;
branches;
next	1.12;

1.12
date	91.05.31.21.02.15;	author sue;	state Exp;
branches;
next	1.11;

1.11
date	91.05.24.22.13.39;	author sue;	state Exp;
branches;
next	1.10;

1.10
date	91.05.22.12.11.43;	author sue;	state Exp;
branches;
next	1.9;

1.9
date	91.05.17.12.58.55;	author sue;	state Exp;
branches;
next	1.8;

1.8
date	91.05.16.11.07.46;	author sue;	state Exp;
branches;
next	1.7;

1.7
date	91.03.25.13.41.01;	author sue;	state Exp;
branches;
next	1.6;

1.6
date	91.03.22.15.09.09;	author sue;	state Exp;
branches;
next	1.5;

1.5
date	91.03.18.11.27.19;	author sue;	state Exp;
branches;
next	1.4;

1.4
date	91.03.15.15.20.50;	author sue;	state Exp;
branches;
next	1.3;

1.3
date	91.03.14.15.40.18;	author sue;	state Exp;
branches;
next	1.2;

1.2
date	91.03.04.12.26.45;	author sue;	state Exp;
branches;
next	1.1;

1.1
date	91.03.04.11.22.31;	author sue;	state Exp;
branches;
next	;

11.12.2.1
date	2002.09.19.18.02.15;	author morrison;	state Exp;
branches;
next	11.12.2.2;

11.12.2.2
date	2004.03.17.21.22.59;	author morrison;	state Exp;
branches;
next	;

11.12.4.1
date	2004.03.11.23.48.07;	author morrison;	state Exp;
branches;
next	;

11.12.10.1
date	2004.02.12.19.37.13;	author erikg;	state Exp;
branches;
next	11.12.10.2;

11.12.10.2
date	2004.03.15.14.08.07;	author erikg;	state Exp;
branches;
next	;


desc
@This program is supposed to put plotted scales on plot/pix files.
@


11.16
log
@moved to src/rt/
@
text
@/*                    R T S C A L E 
*
*  This is a program will compute and plot an appropriate scale in the lower
*  left corner of a given image.  The scale is layed out in view
*  space coordinates and then translated into model coordinates, where it is
*  plotted.  This plot can be overlayed onto any other UNIX-Plot file of onto
*  a pix file.
*  
*  The scale will be a simple line with a certain number of tick marks along
*  it.  It will always end with a "nice" number: that is, rounded to the 
*  nearest 10 as appropriate.
*
*  The program consists of three parts:
*	1) take view, orientation, eye_position, and size from the rt log 
*          file, and use this information to build up the view2model matrix;
*	2) lay out the scale in view-coordinates and convert all points to
*	   model coordinates for plotting in model coordinates;
*			and
*	3) concatenate the scales and a copy of the original image into a
*	   a composite that it printed on standard out.  For the moment this
*	   is achieved by saying " cat scale.pl file.pl >> out.file ".  
*	   The order of the files is very important: if not cat'ed in the
*	   right order, the scales will be lost when plrot is applied though
*	   they will still be seen with pl-sgi and mged. Later
*	   this will be handled by scale.c as an fread() and fwrite().
*
*
*  Authors -
*	Susanne L. Muuss, J.D.
*	
*
*  Source -
*	SECAD/VLD Computing Consortium, Bldg. 394
*	The U. S. Army Ballistic Research Laboratory
*	Aberdeen Proving Ground, Maryland  21005
*
*  Copyright Notice -
*	This software is Copyright (C) 1991-2004 by the United States Army.
*	All rights reserved.
*/
#ifndef lint
static const char RCSscale[] = "@@(#)$Header: /n/xoff/cvs/brlcad/rt/rtscale.c,v 11.15 2004/05/10 15:30:49 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "wdb.h"
#include "plot3.h"

#define BUFF_LEN 256
#define FALSE 0
#define TRUE 1


char usage[] = "\
Usage:  rtscale (width) (units) (interval) filename [string] >  file.pl\n\
	(width)		length of scale in model measurements\n\
	(units)		sting denoting the unit type,\n\
	(interval)	number of intervals on the scale\n\
	filename	name of log file to be read\n\
	[string]	optional, descriptive string\n";

int	layout_n_plot(FILE *outfp, char *label, fastf_t *v2mod, fastf_t *m2view, int intervals, fastf_t m_len, char *descript);
int	read_rt_file(FILE *infp, char *name, fastf_t *model2view);
int	drawscale(FILE *outfp, fastf_t *startpt, fastf_t len, fastf_t hgt, fastf_t *lenv, fastf_t *hgtv, fastf_t *inv_hgtv);
int	drawticks(FILE *outfp, fastf_t *centerpt, fastf_t *hgtv, fastf_t hgt, fastf_t *inv_hgtv);
int	overlay();
void	make_border(FILE *outfp, fastf_t *v2mod);
void	make_bounding_rpp(FILE *outfp, fastf_t *v2mod);

static FILE	*fp;
int		border;			/* flag for debugging; to be used later */
int		verbose;		/* flag for debugging; to be used later */
int		SEEN_DESCRIPT=0;	/* flag for descriptive string */

/*
 *
 *                     M A I N
 *
 *  Main exists to coordinate the actions of the three parts of this program.
 *  It also processes its own arguments (argc and argv).
 */
int
main(int argc, char **argv)
{

	mat_t		model2view;		/* matrix for converting from model to view space */
	mat_t		view2model;		/* matrix for converting from view to model space */
	char		units[BUFF_LEN];	/* string for units type */
	char		label[BUFF_LEN];	/* string for scale labeling */
	char		name[BUFF_LEN];		/* incoming file name */
	char		descript[BUFF_LEN];	/* descriptive string, optional */
	int		intervals;		/* number of intervals */
	int		ret;			/* function return code */
	fastf_t		m_len;			/* scale length in model size */

	MAT_IDN(view2model);			/* makes an identity matrix */
	MAT_IDN(model2view);

	/* Check to see that the correct format is given, else print
	 * usage message.
	 */

	if(argc < 5)  {
		fputs(usage, stderr);
		exit(-1);
	}

	/* Open an incoming file for reading */

	fp = fopen( argv[4], "r");
	if( fp == NULL )  {
		perror(argv[4]);
		exit(-1);
	}

	/* Now process the arguments from main */	

	strcpy(label, argv[1]);
	strcpy(units, argv[2]);
	strcat(label, units);
	strcpy(name, argv[4]);

	if( argc == 6 )  {
		strcpy( descript, argv[5] );
		SEEN_DESCRIPT = 1;
	}

	intervals = atof(argv[3]);

	m_len = atof(argv[1]) * bu_units_conversion(argv[2]);

	/* Check to make sure there has been a valid conversion. */
	if(m_len <= 0)  {
		fprintf(stderr, "Invalid length =%.6f\n", m_len);
		fputs(usage, stderr);
		exit(-1);
	}

	/* Send pointer read_rt_file() a pointer to local model2view matrix 
	 * and to stdin. Send lay_out_n_plot() a pointer to stdout and to
	 * the inverted private matrix, which is now view2model.  In inverting
	 * the matrix in main(), greater modularity and reusability is gained
	 * for lay_out_n_plot(). ( Note &view2model[0] can be used, but is
	 * not elegant.)
	 */

	ret = read_rt_file(fp, name,  model2view);
	if(ret < 0)  {
		exit(-1);
	}

	bn_mat_inv(view2model, model2view);

	if(verbose)  {
		fprintf(stderr, "label=%s\n", label);
		bn_mat_print("view2model", view2model);
	}

	/* Make a bounding rpp for the model and put out a space command. */
	make_bounding_rpp(stdout, view2model);

	ret = layout_n_plot(stdout, label, view2model, model2view, intervals, m_len, descript);
	if(ret < 0)  {
		exit(-1);
	}

	if(border)  {
		/* For diagnostic purposes, a border can be put out. */
		make_border(stdout, view2model);
	}

	exit(0);

}


/*
 *		L A Y O U T _ N _ P L O T
 *
 *  This routine lays out the scale in view coordinates.  These are then
 *  converted to model space.
 *  It receives pointers to stdout, a label, and a view2model matrix, as 
 *  well as a number of intervals and the length of the scale on model units.
 *  An optional, descriptive string is also taken.
 *  This makes it very general.  Lastly, it returns 0 okay, <0 failure.
 */

int
layout_n_plot(FILE *outfp, char *label, fastf_t *v2mod, fastf_t *m2view, int intervals, fastf_t m_len, char *descript)
{


	int		nticks;		/* number of tick marks required */
	int		tickno;		/* counter of tickmarks to be done */
	int		ret;		/* return code from functions */
	int		nchar;		/* number of characters in the label */
	double		v_char_width;	/* char. width in view space */
	double		m_char_width;	/* char. width in model space */
	mat_t		v2symbol;	/* view to symbol sapce matrix */
	float		v_len;		/* scale length in view space */
	float		v_tick_hgt;	/* total height of tick marks, view space */
	float		m_tick_hgt;	/* total height of tick marks, model space */
	float		m_free_space;	/* 80% of scale len, use for writing */
	float		v_free_space;	/* m_free_space's analogue in view space */
	float		v_x_offset;	/* distance the label is offset in x */
	float		v_y_offset;	/* distance the label is offset in y */
	float		v_y_des_offset;	/* descriptive string offset */
	point_t		v_offset;
	point_t		v_des_offset;
	vect_t		v_hgtv;		/* height vector for ticks, view space */
	vect_t		m_hgtv;		/* height vector for ticks, model space */
	vect_t		m_inv_hgtv;
	vect_t		v_lenv;		/* direction vector along x-axis, view space */
	vect_t		m_lenv;		/* direction vector along x-axis, model space */
	point_t		v_startpt;	/* starting point of scales, view space */
	point_t		m_startpt;	/* starting point in model space */
	point_t		v_label_st;	/* starting point of label, view space */
	point_t		m_label_st;	/* starting point of label, model space */
	point_t		v_descript_st;	/* starting point of description, view space */
	point_t		m_descript_st;	/* starting point of description, model space */
	point_t		centerpt;	/* point on scale where tick mark starts */


	/* Note that the view-coordinates start at the lower left corner (
	 * (0, 0) running to lower right corner (1, 0) in dx and to upper
	 * left corner (1, 0) in dy.  This is based on a first quadrant
	 * world.  So, if a mark is to appear in the lower left corner of the
	 * page, 10% of the way in, dx = -1.0 + 0.1 = -0.9; dy is calculated
	 * in a similar manner.
	 */

	nticks =  intervals - 1;
	v_tick_hgt = 0.05;

	if(verbose)  {
		fprintf(stderr, "plot: nticks=%d,\n", nticks);
	}

	/* Make the starting point (in view-coordinates) of the scale.
	 * Note that there is no Z coordinate since the view-coordinate
	 * system is a flat world.  The length and height vectors also
	 * are made in view coordinates.
	 */

	VSET(v_lenv, 1.0, 0.0, 0.0);
	VSET(v_hgtv, 0.0, 1.0, 0.0);

	/* If a second, descriptive string is given, move the printed
	 * material up by one line so that it will not be cut off by
	 * pl-fb, since the lettering rides right on the hairy edge
	 * height wise.
	 */

	if(SEEN_DESCRIPT)  {
		VSET(v_startpt, -0.9, -0.7, 0.0);
	} else {
		VSET(v_startpt, -0.9, -0.8, 0.0);
	}

	/* Now convert all necessary points and vectors to model coordinates.
	 * Unitize all direction vectors, and invert the height vector so
	 * it can be used to make the bottom half of the ticks.
	 */

	MAT4X3VEC(m_lenv, v2mod, v_lenv);
	VUNITIZE(m_lenv);
	MAT4X3VEC(m_hgtv, v2mod, v_hgtv);
	VUNITIZE(m_hgtv);
	VREVERSE(m_inv_hgtv, m_hgtv);
	MAT4X3PNT(m_startpt, v2mod, v_startpt);
	m_tick_hgt = v_tick_hgt / v2mod[15];		/* scale tick_hgt */

	if(verbose)  {
		fprintf(stderr, "layout: m_tick_hgt=%.6f, v_tick_hgt=%.6f\n", 
			m_tick_hgt, v_tick_hgt);
	}

	/* Lay out the label in view space.  Find the number of characters
	 * in the label and calculate their width.  Since characters are
	 * square, that will also be the char. height.  Use this to calculate
	 * the x- and y-offset of the label starting point in view space.
	 */

	nchar = strlen(label);
	m_free_space = m_len - (m_len * 0.2);
	v_free_space = m_free_space / m2view[15];
	v_char_width = v_free_space/nchar;
	m_char_width = v_char_width / v2mod[15];
	v_len = m_len / m2view[15];

	v_x_offset = 0.1 * v_len;
	v_y_offset = -(2 * v_tick_hgt + v_char_width);

	VSET(v_offset, v_x_offset, v_y_offset, 0 );

	VADD2(v_label_st, v_startpt, v_offset);

	/* Convert v_label_st to model space */
	MAT4X3PNT(m_label_st, v2mod, v_label_st);

	/* Now make the offset for the optional descriptive lable.
	 * The lable should appear beneath the begining of the scale and
	 * run the length of the paper if that is what it takes.
	 */

	v_y_des_offset = -( 4 * v_tick_hgt + v_char_width );
	VSET(v_des_offset, 0.0, v_y_des_offset, 0.0);
	VADD2(v_descript_st, v_startpt, v_des_offset);

	MAT4X3PNT(m_descript_st, v2mod, v_descript_st);


	/* Make a view to symbol matrix.  Copy the view2model matrix, set the
	 * MAT_DELTAS to 0, and set the scale to 1.
	 */

	MAT_COPY(v2symbol, v2mod);
	MAT_DELTAS(v2symbol, 0, 0, 0);
	v2symbol[15] = 1;

	/* Draw the basic scale with the two freebie end ticks.  Then,
	 * if nticks is 0, nothing further is needed.  If nticks is
	 * greater than zero, then tickmarks must be made.
	 */

	ret = drawscale(outfp, m_startpt, m_len, m_tick_hgt, m_lenv, m_hgtv, m_inv_hgtv);
	if( ret < 0 )  {
		fprintf(stderr, "Layout: drawscale failed\n");
		return(-1);
	}

	if(nticks >  0 )  {

		/* Now make the ticks within the basic scale.  The ticks should
		 * be half the height of the end ticks to be distinguishable.
		 */

		for( tickno = 1; tickno < nticks; tickno++ )  {

			VJOIN1(centerpt, m_startpt, m_len * tickno/nticks, m_lenv);

			if(verbose)  {
				VPRINT("centerpt", centerpt);
			}

			ret = drawticks(outfp, centerpt, m_hgtv, m_tick_hgt * 0.5, m_inv_hgtv );
			if( ret < 0 )  {
				fprintf(stderr, "layout: drawtick skipping tickno %d\n",
					tickno);
			}
		}

	}
	
	if(verbose)  {
		fprintf(stderr, "Now calling tp_3symbol( outfp, %s, m_lable_st= %.6f, %.6f, %.6f, m_char_width=%.6f\n",
		        label, V3ARGS(m_label_st), m_char_width);
		bn_mat_print("v2symbol", v2symbol);
	}

	/* Now put the label on the plot.  The first is the lable for
	 * numbers under the scale; the second is for an optional string.
	 */	

	tp_3symbol(outfp, label, m_label_st, v2symbol, m_char_width);
	tp_3symbol(outfp, descript, m_descript_st, v2symbol, m_char_width);
	return( 0 );		/* OK */
}

	

/*		D R A W S C A L E
 *
 * This routine draws the basic scale: it draws a line confined by two
 * end tick marks.  It return either 0 okay < 0 failure.
 * The parameters are a pointer to stdout, a start 
 * point, a height, a length vector, a height vector, and an inverse height
 * vector.
 */

int
drawscale(FILE *outfp, fastf_t *startpt, fastf_t len, fastf_t hgt, fastf_t *lenv, fastf_t *hgtv, fastf_t *inv_hgtv)
{

	point_t		endpt;

	/* Make an end point.  Call drawtick to make the two ticks. */

	VJOIN1(endpt, startpt, len, lenv);
	
	pdv_3move(outfp, startpt);
	pdv_3cont(outfp, endpt);

	if(verbose)  {
		fprintf(stderr, "drawscale invoked drawticks\n");
		VPRINT("startpt", startpt);
		VPRINT("endpt", endpt);
	}

	drawticks(outfp, startpt, hgtv, hgt, inv_hgtv);
	drawticks(outfp, endpt, hgtv, hgt, inv_hgtv);

	return(0);
}


/*		D R A W T I C K S
 *
 * This routine draws the tick marks for the scale.  It takes a out file
 * pointer, a center point whereat to start the tick mark, a height vector
 * for the tick, and a scalar for the tick height.  It returns either
 * 0 okay or < 0 failure.
 */

int
drawticks(FILE *outfp, fastf_t *centerpt, fastf_t *hgtv, fastf_t hgt, fastf_t *inv_hgtv)
{

	point_t		top;		/* top of tick mark */
	point_t		bot;		/* bottom of tick mark */

	if(verbose)  {
		VPRINT("hgtv", hgtv);
	}

	VJOIN1(top, centerpt, hgt, hgtv);
	VJOIN1(bot, centerpt, hgt, inv_hgtv);

	if(verbose)  {
		VPRINT("top", top);
		VPRINT("bot", bot);
		fprintf(stderr, "drawticks now using top, bot to plot\n");
	}

	pdv_3move(outfp, top);
	pdv_3cont(outfp, bot);

	return( 0 );
}

/*		M A K E _ B O R D E R
 *
 * This routine exists to draw an optional border around the image.  It
 * exists for diagnostic purposes.  It takes a view to model matrix and
 * a file pointer.  It lays out and plots the four corners of the image border.
 */

void
make_border(FILE *outfp, fastf_t *v2mod)
{

	point_t		v_lleft_pt;		/* lower left point, view space */
	point_t		v_lright_pt;		/*lower right point, view space */
	point_t		v_uleft_pt;		/* upper left point, view space */
	point_t 	v_uright_pt;		/* upper right point, view space */
	point_t		m_lleft_pt;		/* lower left point, mod. space */
	point_t 	m_lright_pt;		/* lower right point, mod. space */
	point_t		m_uleft_pt;		/* upper left point, mod. space */
	point_t		m_uright_pt;		/* upper right point, mod. space */

	/* Make all the points in view space. */

	VSET(v_lleft_pt, -1.0, -1.0, 0.0);
	VSET(v_lright_pt, 1.0, -1.0, 0.0);
	VSET(v_uleft_pt, -1.0, 1.0, 0.0);
	VSET(v_uright_pt, 1.0, 1.0, 0.0);

	/* Convert all the points to model space */
	MAT4X3PNT(m_lleft_pt, v2mod, v_lleft_pt);
	MAT4X3PNT(m_lright_pt, v2mod, v_lright_pt);
	MAT4X3PNT(m_uleft_pt, v2mod, v_uleft_pt);
	MAT4X3PNT(m_uright_pt, v2mod, v_uright_pt);

	/* Now plot the border in model space. */
	pdv_3move(outfp, m_lleft_pt);
	pdv_3cont(outfp, m_lright_pt);
	pdv_3cont(outfp, m_uright_pt);
	pdv_3cont(outfp, m_uleft_pt);
	pdv_3cont(outfp, m_lleft_pt);

	return;
}

/*
 *		M A K E _ B O U N D I N G _ R P P
 *
 * This routine takes a view2model matrix and a file pointer.  It calculates the  minimun and
 * the maximun points of the viewing cube in view space, and then translates
 * it to model space and rotates it so that it will not shrink when rotated and
 * cut off the geometry/image.  This routine returns nothing.
 */

void
make_bounding_rpp(FILE *outfp, fastf_t *v2mod)
{

	point_t		v_min;		/* view space minimum coordinate */
	point_t		v_max;		/* view space maximum coordinate */
	point_t		new_min;	/* new min of rotated viewing cube */
	point_t		new_max;	/* new max of rotated viewing cube */

	/* Make the min and max points of the view-space viewing cube */
	VSET(v_min, -1.0, -1.0, -1.0);
	VSET(v_max, 1.0, 1.0, 1.0);

	/* Now rotate the viewing cube and obtain new minimum and maximum. */

	bn_rotate_bbox(new_min, new_max, v2mod, v_min, v_max);

	/* Now issue the space command */

	pdv_3space(outfp, new_min, new_max);

	return;
}
@


11.15
log
@change conf.h to a wrapped config.h
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /cvs/brlcad/rt/rtscale.c,v 11.14 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.14
log
@merge of ansi-6-0-branch into head
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header$ (BRL)";
d45 5
a49 1
#include "conf.h"
@


11.13
log
@update copyright to include span through 2003
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.12 2002/08/20 17:08:38 jra Exp $ (BRL)";
d75 4
a78 4
int	layout_n_plot();
int	read_rt_file();
int	drawscale();
int	drawticks();
d80 2
a81 2
void	make_border();
void	make_bounding_rpp();
d96 1
a96 4
main(argc, argv)
int	argc;
char	**argv;

d202 1
a202 9
layout_n_plot(outfp, label, v2mod, m2view, intervals, m_len, descript)
FILE	*outfp;
char	*label;
mat_t	v2mod;
mat_t	m2view;
int	intervals;
fastf_t	m_len;
char	*descript;

d395 1
a395 8
drawscale(outfp, startpt, len, hgt, lenv, hgtv, inv_hgtv)
FILE		*outfp;
point_t		startpt;
fastf_t		len;
fastf_t		hgt;
vect_t		lenv;
vect_t		hgtv;
vect_t		inv_hgtv;
d429 1
a429 6
drawticks(outfp, centerpt, hgtv, hgt, inv_hgtv)
FILE		*outfp;
point_t		centerpt;
vect_t		hgtv;
fastf_t		hgt;
vect_t		inv_hgtv;
d462 1
a462 3
make_border(outfp, v2mod)
FILE	*outfp;
mat_t	v2mod;
d507 1
a507 3
make_bounding_rpp(outfp, v2mod)
FILE	*outfp;
mat_t	v2mod;
@


11.12
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d38 1
a38 1
*	This software is Copyright (C) 1991 by the United States Army.
d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.10 2001/04/02 21:38:30 morrison Exp $ (BRL)";
@


11.12.4.1
log
@sync to HEAD...
@
text
@d38 1
a38 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/rtscale.c,v 11.13 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.12.10.1
log
@merge from HEAD
@
text
@d38 1
a38 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.13 2004/02/02 17:39:39 morrison Exp $ (BRL)";
@


11.12.10.2
log
@merge from head
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.12.10.1 2004/02/12 19:37:13 erikg Exp $ (BRL)";
@


11.12.2.1
log
@Initial ANSIfication
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.12 2002/08/20 17:08:38 jra Exp $ (BRL)";
d75 4
a78 4
int	layout_n_plot(FILE *outfp, char *label, fastf_t *v2mod, fastf_t *m2view, int intervals, fastf_t m_len, char *descript);
int	read_rt_file(FILE *infp, char *name, fastf_t *model2view);
int	drawscale(FILE *outfp, fastf_t *startpt, fastf_t len, fastf_t hgt, fastf_t *lenv, fastf_t *hgtv, fastf_t *inv_hgtv);
int	drawticks(FILE *outfp, fastf_t *centerpt, fastf_t *hgtv, fastf_t hgt, fastf_t *inv_hgtv);
d80 2
a81 2
void	make_border(FILE *outfp, fastf_t *v2mod);
void	make_bounding_rpp(FILE *outfp, fastf_t *v2mod);
d96 4
a99 1
main(int argc, char **argv)
d205 9
a213 1
layout_n_plot(FILE *outfp, char *label, fastf_t *v2mod, fastf_t *m2view, int intervals, fastf_t m_len, char *descript)
d406 8
a413 1
drawscale(FILE *outfp, fastf_t *startpt, fastf_t len, fastf_t hgt, fastf_t *lenv, fastf_t *hgtv, fastf_t *inv_hgtv)
d447 6
a452 1
drawticks(FILE *outfp, fastf_t *centerpt, fastf_t *hgtv, fastf_t hgt, fastf_t *inv_hgtv)
d485 3
a487 1
make_border(FILE *outfp, fastf_t *v2mod)
d532 3
a534 1
make_bounding_rpp(FILE *outfp, fastf_t *v2mod)
@


11.12.2.2
log
@sync branch with HEAD
@
text
@d38 1
a38 1
*	This software is Copyright (C) 1991-2004 by the United States Army.
d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header$ (BRL)";
@


11.11
log
@Converted from K&R to ANSI C - RFH
@
text
@d75 4
a78 4
int	layout_n_plot(FILE *outfp, char *label, fastf_t *v2mod, fastf_t *m2view, int intervals, fastf_t m_len, char *descript);
int	read_rt_file(FILE *infp, char *name, fastf_t *model2view);
int	drawscale(FILE *outfp, fastf_t *startpt, fastf_t len, fastf_t hgt, fastf_t *lenv, fastf_t *hgtv, fastf_t *inv_hgtv);
int	drawticks(FILE *outfp, fastf_t *centerpt, fastf_t *hgtv, fastf_t hgt, fastf_t *inv_hgtv);
d80 2
a81 2
void	make_border(FILE *outfp, fastf_t *v2mod);
void	make_bounding_rpp(FILE *outfp, fastf_t *v2mod);
d96 4
a99 1
main(int argc, char **argv)
d205 9
a213 1
layout_n_plot(FILE *outfp, char *label, fastf_t *v2mod, fastf_t *m2view, int intervals, fastf_t m_len, char *descript)
d406 8
a413 1
drawscale(FILE *outfp, fastf_t *startpt, fastf_t len, fastf_t hgt, fastf_t *lenv, fastf_t *hgtv, fastf_t *inv_hgtv)
d447 6
a452 1
drawticks(FILE *outfp, fastf_t *centerpt, fastf_t *hgtv, fastf_t hgt, fastf_t *inv_hgtv)
d485 3
a487 1
make_border(FILE *outfp, fastf_t *v2mod)
d532 3
a534 1
make_bounding_rpp(FILE *outfp, fastf_t *v2mod)
@


11.10
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.9 2001/03/31 01:57:31 morrison Exp $ (BRL)";
d75 4
a78 4
int	layout_n_plot();
int	read_rt_file();
int	drawscale();
int	drawticks();
d80 2
a81 2
void	make_border();
void	make_bounding_rpp();
d96 1
a96 4
main(argc, argv)
int	argc;
char	**argv;

d202 1
a202 9
layout_n_plot(outfp, label, v2mod, m2view, intervals, m_len, descript)
FILE	*outfp;
char	*label;
mat_t	v2mod;
mat_t	m2view;
int	intervals;
fastf_t	m_len;
char	*descript;

d395 1
a395 8
drawscale(outfp, startpt, len, hgt, lenv, hgtv, inv_hgtv)
FILE		*outfp;
point_t		startpt;
fastf_t		len;
fastf_t		hgt;
vect_t		lenv;
vect_t		hgtv;
vect_t		inv_hgtv;
d429 1
a429 6
drawticks(outfp, centerpt, hgtv, hgt, inv_hgtv)
FILE		*outfp;
point_t		centerpt;
vect_t		hgtv;
fastf_t		hgt;
vect_t		inv_hgtv;
d462 1
a462 3
make_border(outfp, v2mod)
FILE	*outfp;
mat_t	v2mod;
d507 1
a507 3
make_bounding_rpp(outfp, v2mod)
FILE	*outfp;
mat_t	v2mod;
@


11.9
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.8 2000/08/25 21:13:53 mike Exp $ (BRL)";
d341 1
a341 1
	bn_mat_copy(v2symbol, v2mod);
@


11.8
log
@
lint
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.7 2000/08/17 02:41:36 mike Exp $ (BRL)";
d112 2
a113 2
	bn_mat_idn(view2model);			/* makes an identity matrix */
	bn_mat_idn(model2view);
@


11.7
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d42 1
a42 1
static const char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.6 2000/07/13 01:30:05 mike Exp $ (BRL)";
d48 5
d95 1
a95 1

@


11.6
log
@
NAMELEN not used
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.5 2000/07/10 23:08:54 mike Exp $ (BRL)";
@


11.5
log
@
wdb.h after raytrace.h
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.4 1999/07/02 22:19:46 mike Exp $ (BRL)";
a56 1
#define NAMELEN 40
@


11.4
log
@
Removed dependence on compat4.h
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.3 1999/05/28 01:17:26 mike Exp $ (BRL)";
d53 1
a54 1
#include "raytrace.h"
@


11.3
log
@
sed4
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /c/CVS/brlcad/rt/rtscale.c,v 11.2 1997/01/08 03:47:38 mike Exp $ (BRL)";
d142 1
a142 1
	m_len = atof(argv[1]) * rt_units_conversion(argv[2]);
@


11.2
log
@Added bu.h and bn.h
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /m/cad/rt/RCS/rtscale.c,v 11.1 1995/01/04 10:00:57 mike Rel4_4 mike $ (BRL)";
d108 2
a109 2
	mat_idn(view2model);			/* makes an identity matrix */
	mat_idn(model2view);
d164 1
a164 1
	mat_inv(view2model, model2view);
d168 1
a168 1
		mat_print("view2model", view2model);
d337 1
a337 1
	mat_copy(v2symbol, v2mod);
d378 1
a378 1
		mat_print("v2symbol", v2symbol);
d544 1
a544 1
	rt_rotate_bbox(new_min, new_max, v2mod, v_min, v_max);
@


11.1
log
@Release_4.4
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /m/cad/rt/RCS/rtscale.c,v 10.2 94/08/11 00:39:50 gdurf Exp $ (BRL)";
d50 1
d52 1
@


10.2
log
@Added include of conf.h
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /m/cad/rt/RCS/rtscale.c,v 10.1 1991/10/12 06:42:01 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /m/cad/rt/RCS/rtscale.c,v 1.19 91/07/17 20:54:18 sue Exp $ (BRL)";
d44 2
@


1.19
log
@Changed a few comments.  Added support for a descriptive text string
to ride below the scales.  This is an optional string, and the scale
is shifted up by one line only when this string is present.  This keeps
pl-fb from cutting off the last string.
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/rtscale.c,v 1.18 91/07/10 13:45:07 sue Exp $ (BRL)";
@


1.18
log
@Removed some stray diagnostic printf()'s.
@
text
@d6 1
a6 1
*  plotted.  This plot can be overlayed onto any other UNIXplot file of onto
d10 1
a10 1
*  it.  It will always end with a "nice" number: that is, rounded to the the
d13 1
a13 1
*  The program conisists of three parts:
d22 1
a22 1
*	   The order of the files is very important: if not cat'edin the
d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /m/cad/rt/RCS/rtscale.c,v 1.17 91/07/05 12:37:24 sue Exp $ (BRL)";
d58 1
d76 3
a78 2
int		border;		/* flag for debugging; to be used later */
int		verbose;	/* flag for debugging; to be used later */
d133 1
d225 1
a262 1
	VSET(v_startpt, -0.9, -0.8, 0.0);
d264 12
d323 2
a324 2
	VSET(v_offset, 0.0, v_y_des_offset, 0.0);
	VADD2(v_descript_st, v_startpt, v_offset);
@


1.17
log
@Added the ability to specify an optional descriptive string.
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /m/cad/rt/RCS/rtscale.c,v 1.16 91/06/26 16:43:47 sue Exp $ (BRL)";
d109 1
a109 1
	if(argc < 4)  {
d129 1
a129 1
	if( argv[5] != NULL )  {
@


1.16
log
@Converted %g's to %.6f to prevent rounding to ints.  Also changed
mk_cvt_factor to rt_units_conversion and added raytrace.h.
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/rtscale.c,v 1.15 91/06/03 15:29:45 sue Exp $ (BRL)";
d59 1
a59 1
Usage:  rtscale (width) (units) (interval)  filename > file.pl\n\
d62 3
a64 1
	(interval)	number of intervals on the scale\n";
d97 1
d109 1
a109 1
	if(argc != 5)  {
d129 4
d167 1
a167 1
	ret = layout_n_plot(stdout, label, view2model, model2view, intervals, m_len);
d189 1
d194 1
a194 1
layout_n_plot(outfp, label, v2mod, m2view, intervals, m_len)
d201 2
d220 1
d231 2
d302 12
d362 4
a365 1
	/* Now put the label on the plot. */
d367 1
@


1.15
log
@Added two comments.
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /m/cad/rt/RCS/rtscale.c,v 1.14 91/06/03 15:20:28 sue Exp $ (BRL)";
d50 1
d128 1
a128 1
	m_len = atof(argv[1]) * mk_cvt_factor(argv[2]);
d132 1
a132 1
		fprintf(stderr, "Invalid length =%d\n", m_len);
d262 1
a262 1
		fprintf(stderr, "layout: m_tick_hgt=%g, v_tick_hgt=%g\n", 
d332 1
a332 1
		fprintf(stderr, "Now calling tp_3symbol( outfp, %s, m_lable_st= %g, %g, %g, m_char_width=%g\n",
@


1.14
log
@Made the border part of the diagnostic tools.  Added a verbose flag for
future diagnostics.
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/rtscale.c,v 1.14 91/06/03 15:14:42 sue Exp $ (BRL)";
d72 2
a73 2
int		border;
int		verbose;
@


1.13
log
@Un-commented out the space command.  It works fine.  Noticed that the
scale.file must be cat'ed over top of the plot file if the scale is not
to disappear when plrot'ed.  The border is still shown.
@
text
@d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /n/wolf/vld/sue/develop/rtdir/RCS/rtscale.c,v 1.12 91/05/31 20:59:32 sue Exp $ (BRL)";
d72 2
a74 1

a124 2
fprintf(stderr, "label=%s\n", label);

d151 4
a154 2
/* mat_print("view2model", view2model);
 */
d164 4
a167 2
	/* For diagnostic purposes, a border can be put out. */
	make_border(stdout, view2model);
a168 1

d233 3
a236 2
/*  fprintf(stderr, "plot: nticks=%d,\n", nticks);
 */
d260 4
a263 2
/* fprintf(stderr, "layout: m_tick_hgt=%g, v_tick_hgt=%g\n", m_tick_hgt, v_tick_hgt);
 */
a315 2
/* VPRINT("centerpt", centerpt);
 */
d317 4
d330 5
a335 5
fprintf(stderr, "Now calling tp_3symbol( outfp, %s, m_lable_st= %g, %g, %g, m_char_width=%g\n",
        label, V3ARGS(m_label_st), m_char_width);
mat_print("v2symbol", v2symbol);


d372 5
a376 4
/* fprintf(stderr, "drawscale invoked drawticks\n");
 * VPRINT("startpt", startpt);
 * VPRINT("endpt", endpt);
 */
d405 3
a407 2
/* VPRINT("hgtv", hgtv);
 */
d412 6
a417 4
/* VPRINT("top", top);
 * VPRINT("bot", bot);
 * fprintf(stderr, "drawticks now using top, bot to plot\n");
 */
@


1.12
log
@Changed a couple of MAT4X3VEC's to MAT4X3PNT's.  Added a routine to make
a border. and also added a routine toput out a space command.  The border
is working nicely, but I had to pull up the view-space y-coordinate for
starting the scale so that the lettering would fit into the border.
@
text
@d21 4
a24 1
*	   is achieved by saying " cat file.pl scale.pl >> out.file ".  Later
d42 1
a42 1
static char RCSscale[] = "@@(#)$Header: /vld/sue/develop/rtdir/RCS/rtscale.c,v 1.11 91/05/24 22:13:39 sue Exp $ (BRL)";
d155 3
a165 3
	/* Make a bounding rpp for the model and put out a space command. */
/*	make_bounding_rpp(stdout, view2model);
 */
@


1.11
log
@Changed it so that rtscale now takes the input file as an argument.
This is in preparation for separating the file reading routine from
both it and rtregis.
@
text
@d31 1
a31 1
*	The U. S. Army Ballistic Reasearch Laboratory
d39 1
a39 1
static char RCSscale[] = "@@(#)$Header: /vld/sue/develop/scales/RCS/rtscale.c,v 1.10 91/05/22 12:11:43 sue Exp $ (BRL)";
d47 1
a47 1
#include "tig.h"
d55 1
a55 1
Usage:  scale (width) (units) (interval)  filename > file.pl\n\
d65 2
d89 1
d119 1
d142 1
a142 1
	ret = read_rt_file(fp, argv[4],  model2view);
d157 7
d239 1
a239 1
	VSET(v_startpt, -0.9, -0.9, 0.0);
d251 1
a251 1
	MAT4X3VEC(m_startpt, v2mod, v_startpt);
d278 1
a278 1
	MAT4X3VEC(m_label_st, v2mod, v_label_st);
a330 212
/*		R E A D _ R T _ F I L E
 *
 * This routine reads an rt_log file line by line until it either finds
 * view, orientation, eye_postion, and size of the model, or it hits the
 * end of file.  When a colon is found, sscanf() retrieves the
 * necessary information.  It takes a file pointer, incoming file
 * name and a matrix pointer as parameters.  
 * It returns 0 okay or < 0 failure.
 */

int
read_rt_file(infp, name, model2view)
FILE	*infp;
char	*name;
mat_t 	model2view;
{

	fastf_t		azimuth;		/* part of the view */
	fastf_t		elevation;		/* part of the view */
	quat_t		orientation;		/* orientation */
	point_t		eye_pos;
	fastf_t		m_size;			/* size of model in mm */
	char		*ret;			/* return code for fgets */
	char		string[BUFF_LEN];	/* temporary buffer */
	char		*arg_ptr;		/* place holder */
	char		forget_it[9];		/* "azimuth" catcher, then forget */
	int		i;			/* reusable counter */
	int		num;			/* return code for sscanf */
	int		seen_view;		/* these are flags.  */
	int		seen_orientation;
	int		seen_eye_pos;
	int		seen_size;

	mat_t		rotate, xlate;
	mat_t		tmp_mat;

	/* Set all flags to ready state.  */

	seen_view = FALSE;
	seen_orientation = FALSE;
	seen_eye_pos = FALSE;
	seen_size = FALSE;

/* fprintf(stderr, "set flags: view=%d, orient.=%d, eye_pos=%d, size=%d\n",
 *	seen_view, seen_orientation, seen_eye_pos, seen_size);
 */

	/* feof returns 1 on failure */

	while( feof(infp) == 0 )  {

		/* clear the buffer */	
		for( i = 0; i < BUFF_LEN; i++ )  {
			string[i] = '\0';
		}
		ret = fgets(string, BUFF_LEN, infp);
		if( ret == NULL )  {
			/* There are two situations for which NULL might be
			 * seen: end of file (handled above) and when the
			 * process dies a horrible death.  The latter is the
			 * condition to be caught here.
			 */

			if( feof(infp) )
				break;
			/* Else report that there is a problem. */

			fprintf(stderr, "read_rt_log: read failure on file %s\n",
				name);
			return(-1);
		}


		/* Check the first for a colon in the buffer.  If there is
		 * one, replace it with a NULL, and set a pointer to the
		 * next space.  Then feed the buffer to
		 * strcmp see whether it is the view, the orientation,
		 * the eye_position, or the size.  If it is, then sscanf()
		 * the needed information into the appropriate variables.
		 * If the keyword is not found, go back for another line.
		 *
		 * Set arg_ptr to NULL so it can be used as a flag to verify
		 * finding a colon in the input buffer.
		 */

		arg_ptr = NULL;

		for( i = 0; i < BUFF_LEN; i++ )  {
			/* Check to make sure the first char. is not a NULL;
			 * if it is, go back for a new line.
			 */
			if( string[i] == '\0' )  {
				break;
			}
			if( string[i] == ':')  {
				/* If a colon is found, set arg_ptr to the
				 * address of the colon, and break: no need to
				 * look for more colons on this line.
				 */

/* fprintf(stderr, "found colon\n");
 */
				string[i] = '\0';
				arg_ptr = &string[++i];		/* increment before using */
				break;
			}
		}

		/* Check to see if a colon has been found.  If not, get another
		 * input line.
		 */

		if( arg_ptr == NULL )  {
			continue;
		}

		/* Now compare the first word in the buffer with the
		 * key words wanted.  If there is a match, read the
		 * information that follows into the appropriate
		 * variable, and set a flag to indicate that the
		 * magic thing has been seen.
		 *
		 * Note two points of interest: scanf() does not like %g;
		 * use %lf.  Also, if loading a whole array of characters
		 * with %s, then the name of the array can be used for the
		 * destination.  However, if the characters are loaded 
		 * individually into the subsripted spots with %c (or equiv),
		 * the address of the location must be provided: &eye_pos[0].
		 */

		if(strcmp(string, "View") == 0)  {
			num = sscanf(arg_ptr, "%lf %s %lf", &azimuth, forget_it, &elevation);
			if( num != 3)  {
				fprintf(stderr, "View= %g %s %g elevation\n", azimuth, forget_it, elevation);
				return(-1);
			}
			seen_view = TRUE;
		} else if(strcmp(string, "Orientation") == 0)  {
			num = sscanf(arg_ptr, "%lf, %lf, %lf, %lf",
				&orientation[0], &orientation[1], &orientation[2],
				&orientation[3]);

 			if(num != 4)  {
				fprintf(stderr, "Orientation= %g, %g, %g, %g\n",
				 	orientation[0], orientation[1],
					orientation[2], orientation[3]);
				return(-1);
			}
			seen_orientation = TRUE;
		} else if(strcmp(string, "Eye_pos") == 0)  {
			num = sscanf(arg_ptr, "%lf, %lf, %lf", &eye_pos[0],
				&eye_pos[1], &eye_pos[2]);
			if( num != 3)  {
				fprintf(stderr, "Eye_pos= %g, %g, %g\n",
					eye_pos[0], eye_pos[1], eye_pos[2]);
				return(-1);
			}
			seen_eye_pos = TRUE;
		} else if(strcmp(string, "Size") == 0)  {
			num = sscanf(arg_ptr, "%lf", &m_size);
			if(num != 1)  {
				fprintf(stderr, "Size=%g\n", m_size);
				return(-1);
			}
			seen_size = TRUE;
		}
	}

	/* Check that all the information to proceed is available */

	if( seen_view != TRUE )  {
		fprintf(stderr, "View not read!\n");
		return(-1);
	}

	if( seen_orientation != TRUE )  {
		fprintf(stderr, "Orientation not read!\n");
		return(-1);
	}

	if( seen_eye_pos != TRUE )  {
		fprintf(stderr, "Eye_pos not read!\n");
		return(-1);
	}

	if ( seen_size != TRUE )  {
		fprintf(stderr, "Size not read!\n");
		return(-1);
	}

	/* For now, just print the stuff */

	fprintf(stderr, "view= %g azimuth, %g elevation\n", azimuth, elevation);
	fprintf(stderr, "orientation= %g, %g, %g, %g\n",
		orientation[0], orientation[1], orientation[2], orientation[3]);
	fprintf(stderr, "eye_pos= %g, %g, %g\n", eye_pos[0], eye_pos[1], eye_pos[2]);
	fprintf(stderr, "size= %gmm\n", m_size);

	/* Build the view2model matrix. */

	quat_quat2mat( rotate, orientation );
	rotate[15] = 0.5 * m_size;
	mat_idn( xlate );
	MAT_DELTAS( xlate, -eye_pos[0], -eye_pos[1], -eye_pos[2] );
	mat_mul( model2view, rotate, xlate );

/* mat_print("model2view", model2view);
 */	
	return(0);
}


d408 80
@


1.10
log
@Initialized a v_len variable.  Can now  center the lettering.
@
text
@d1 1
a1 1
/*                    S C A L E . P L O T
d39 1
a39 1
static char RCSscale[] = "@@(#)$Header: /vld/sue/develop/scales/RCS/scale.c,v 1.9 91/05/17 12:58:55 sue Exp $ (BRL)";
d55 1
a55 1
Usage:  scale (width) (units) (interval) < file > file.pl\n\
d66 3
d98 1
a98 1
	if(argc != 4)  {
d103 8
d138 1
a138 1
	ret = read_rt_file(stdin, model2view);
d325 3
a327 2
 * necessary information.  It takes a file pointer and a matrix
 * pointer as parameters.  It returns 0 okay or < 0 failure.
d331 1
a331 1
read_rt_file(infp, model2view)
d333 1
d388 1
a388 1
				string);
@


1.9
log
@The program will now write a credible scale.
@
text
@d39 1
a39 1
static char RCSscale[] = "@@(#)$Header: /vld/sue/develop/scales/RCS/scale.c,v 1.8 91/05/16 11:07:46 sue Exp $ (BRL)";
d246 1
d267 2
a268 1
	 * if nticks is 0, nothing further is needed.
d277 1
a277 7
	if(nticks <= 0 )  {
		return( 0 );
	}
	
	/* Now make the ticks within the basic scale.  The ticks should
	 * be half the height of the end ticks to be distinguishable.
	 */
d279 3
a281 1
	for( tickno = 1; tickno < nticks; tickno++ )  {
d283 3
a285 1
		VJOIN1(centerpt, m_startpt, m_len * tickno/nticks, m_lenv);
d289 5
a293 4
		ret = drawticks(outfp, centerpt, m_hgtv, m_tick_hgt * 0.5, m_inv_hgtv );
		if( ret < 0 )  {
			fprintf(stderr, "layout: drawtick skipping tickno %d\n",
				tickno);
d297 1
d306 1
a306 1

@


1.8
log
@Can now correctly handle an abort from an unexpected input file
termination.  tp_3symbol() still has he problem of not writing out the
string.
@
text
@d39 1
a39 1
static char RCSscale[] = "@@(#)$Header: /d/sue/develop/scales/RCS/scale.c,v 1.7 91/03/25 13:41:01 sue Exp $ (BRL)";
d172 2
a173 2
	int		m_char_width;	/* char. width in model space */
	int		v_char_width;	/* char. width in view space */
d244 2
d297 1
a297 1
fprintf(stderr, "Now calling tp_3symbol( outfp, %s, m_lable_st= %g, %g, %g, m_char_width=%d\n",
d300 1
@


1.7
log
@This version makes a scale with tick amrks that are .5 the height of the
end tick marks.  It also processes arguments from the user.
@
text
@d39 1
a39 1
static char RCSscale[] = "@@(#)$Header: /d/sue/develop/scales/RCS/scale.c,v 1.6 91/03/22 15:09:09 sue Exp $ (BRL)";
d47 1
d137 1
a137 1
	ret = layout_n_plot(stdout, label, view2model, intervals, m_len);
d158 1
a158 1
layout_n_plot(outfp, label, v2mod, intervals, m_len)
d162 1
d171 5
d178 5
d190 2
d234 29
d267 1
a267 1
	ret = drawscale(outfp, label, m_startpt, m_len, m_tick_hgt, m_lenv, m_hgtv, m_inv_hgtv);
d294 8
d359 13
a371 5
/*			fprintf(stderr, "read_rt_log: read failure on file %s\n",
 *				string);
 *			return(-1);
 */
			break;
d520 1
a520 1
 * The parameters are pointers to stdout  and a lable, as well as a start 
d526 1
a526 1
drawscale(outfp, label, startpt, len, hgt, lenv, hgtv, inv_hgtv)
a527 1
char		*label;
a536 1
	point_t		st_label;
a537 1

a544 7
	/* Lable the scale *

/*	VJOIN1(st_label, startpt, 3 * hgt, inv_hgtv);
 *	pdv_3move(outfp, st_label);
 *	pl_label(outfp, label);
 */
	
@


1.6
log
@Can now plot a scale in the lower left corner of model space, with any
number of tick marks (caveat: the internal tick marks are not distinguished
form the outer ones as yet.
@
text
@d39 1
a39 1
static char RCSscale[] = "@@(#)$Header: /d/sue/develop/scales/RCS/scale.c,v 1.5 91/03/18 11:27:19 sue Exp $ (BRL)";
a47 1
#define TICKS	10		/* a hack for now: needs to be a variable */
d81 5
a85 4
	char		units[BUFF_LEN];	/* string denoting the type of units */
	int		intervals;		/* number of intervals desired */
	int		ret;			/* return code from functions */
	fastf_t		m_len;			/* length of scale in model size */
a86 3
	fastf_t	len;				/* temporary */
	fastf_t	conv;				/* temporary */

d101 1
d103 4
a108 2
	len = atof(argv[1]);
	conv = mk_cvt_factor(argv[2]);
a110 2
fprintf(stderr, "len=%g, conv=%g, units=%s, m_len=%g\n", len, conv, units, m_len);

d133 2
a134 1
mat_print("view2model", view2model);
d136 1
a136 1
	ret = layout_n_plot(stdout, view2model, intervals, m_len);
d149 5
a153 3
 *  This routine lays out the scale in view coordinates.  It receives a
 *  pointer to a view2model matrix and to stdout.  This makes it very
 *  general.  Lastly, it returns 0 okay, <0 failure.
d157 1
a157 1
layout_n_plot(outfp, v2mod, intervals, m_len)
d159 1
d173 1
d190 1
a190 1
	v_tick_hgt = 100.0;
d193 2
a194 2
 fprintf(stderr, "plot: nticks=%d,\n", nticks);

d205 4
a208 1
	/* Now convert all necessary points to model coordinates */
d214 1
d216 1
a216 1
	m_tick_hgt = v_tick_hgt * v2mod[15];		/* scale tick_hgt */
d218 2
a219 2
fprintf(stderr, "layout: m_tick_hgt=%g, v_tick_hgt=%g\n", m_tick_hgt, v_tick_hgt);

d224 1
a224 1
	ret = drawscale(outfp, m_startpt, m_len, m_tick_hgt, m_lenv, m_hgtv);
d234 3
a236 1
	/* Now make the ticks within the basic scale */
d239 1
a239 1
fprintf(stderr, "making ticks tickno=%d\n", tickno);
d241 4
a244 2
VPRINT("centerpt", centerpt);
		ret = drawticks(outfp, centerpt, m_hgtv, m_tick_hgt * 0.75 );
d276 1
a276 1
	char		forget_it[9];		/* need for sscanf, then forget */
a373 3

/* fprintf(stderr, "found view\n");
 */
a380 3

/* fprintf(stderr, "found orientation\n");
 */
a392 3

/* fprintf(stderr, "found eye_pos\n");
 */
a401 3

/* fprintf(stderr, "found size\n");
 */
a412 2
/* fprintf(stderr, "now checking data\n");
 */
d441 1
a441 4
	/* Build the view2model matrix (matp points at this).  Variables 
	 * used only for this transaction are initialized here.
	 * 
	 */
a442 1

d449 2
a450 2
mat_print("model2view", model2view);
	
d461 3
a463 3
 * The parameters are an outfile pointer, a start point in model coordinates,
 * a direction vector, a total distance to go, the scalar height of the
 * tick marks, and the height vector of the tick marks.
d467 1
a467 1
drawscale(outfp, startpt, len, hgt, lenv, hgtv)
d469 1
d475 1
d479 1
d481 1
d489 1
a489 3
fprintf(stderr, "drawscale invoked drawticks\n");
VPRINT("startpt", startpt);
VPRINT("endpt", endpt);
d491 9
a499 2
	drawticks(outfp, startpt, hgtv, hgt);
	drawticks(outfp, endpt, hgtv, hgt);
d501 3
d517 1
a517 1
drawticks(outfp, centerpt, hgtv, hgt)
d522 1
a526 1
	vect_t		inv_hgtv;	/* height vector pointing down */
d528 2
a529 1
VPRINT("hgtv", hgtv);
a530 4
	VREVERSE(inv_hgtv, hgtv);

VPRINT("inv_hgtv", inv_hgtv);

d534 4
a537 4
VPRINT("top", top);
VPRINT("bot", bot);
fprintf(stderr, "drawticks now using top, bot to plot\n");

@


1.5
log
@Various changes:
	a) created private view2model matrix for main: it does inversion.
	b) pass ptr to private matrix read_rt_file and ptr to view2model
	   to layout_n_plot.
	c) both subroutines get a ptr to stin/stdout as appropriate.
@
text
@d39 1
a39 1
static char RCSscale[] = "@@(#)$Header: /d/sue/develop/scales/RCS/scale.c,v 1.4 91/03/15 15:20:50 sue Exp $ (BRL)";
d46 1
a47 1

a50 2
#define SUCCESS 1
#define ERROR -1
d55 4
a58 1
Usage:  scale < file > file.pl\n";
a59 1

d62 2
a65 8
mat_t		view2model = {
			1.0, 0.0, 0.0, 0.0,
			0.0, 1.0, 0.0, 0.0,
			0.0, 0.0, 1.0, 0.0,
			0.0, 0.0, 0.0, 1.0};	/* identity matrix for now */



d71 1
a71 1
 *
d74 1
a74 1
main(argc)
d76 2
d80 6
d87 2
a88 2
	mat_t		private;	/* local, for passing to read_rt_file */
	int		ret;		/* return code from functions */
d90 2
a92 2
	mat_idn(private);		/* makes an identity matrix */

d97 1
a97 1
	if(argc != 1)  {
d102 18
d124 2
a125 1
	 * for lay_out_n_plot().
d128 2
a129 2
	ret = read_rt_file(stdin, &private[0]);
	if(ret == ERROR)  {
d133 1
a133 1
	mat_inv(view2model, private);
d135 4
a138 2
	ret = layout_n_plot(stdout, &view2model[0]);
	if(ret == ERROR)  {
a149 3
 *	CAVEAT: this routine needs to be rewritten to allow for
 *		generalization and an arbitrary number of ticks!
 *
d152 1
a152 1
 *  general.  Lastly, it returns SUCCESS or ERROR.
d156 1
a156 1
layout_n_plot(outfp, matp)
d158 3
a160 1
mat_t	*matp;
a162 3
	/*  For now all the variables will be declared here.  If necessary,
	 *  some will become #defines, or external variables later.
	 */
a163 2
	int		height;		/* height of picture */
	int		width;		/* width of picture */
d165 11
a175 17
	float		ticklen;	/* distance between tick marks */
	float		tick_hgt;	/* total height of tick marks */
	point_t		v_ltick_top;	/* view coordinate left tick top */
	point_t		v_ltick_bot;	/* view coordinate left tick bottom */
	point_t		v_rtick_top;	/* view coordinate right tick top */
	point_t		v_rtick_bot;	/* view coordinate right tick bottom */
	point_t		m_ltick_top;	/* model coordinate left tick top */
	point_t		m_ltick_bot;	/* model coordinate left tick bottom */
	point_t		m_rtick_top;	/* model coordinate right tick top */
	point_t		m_rtick_bot;	/* model coordinate right tick bottom */
	point_t		v_leftpt;	/* view coordinate left point */
	point_t		v_rightpt;	/* view coordinate right point */
	point_t		m_leftpt;	/* model coordinate left point */
	point_t		m_rightpt;	/* model coordinate right point */
	fastf_t		dx;		/* view coord. x distance */
	fastf_t		dy;		/* view coord. y distance */
	fastf_t		len;		/* length of scale */
d180 4
a183 1
	 * left corner (1, 0) in dy.  Thus, 10% of the distance is 0.1.
d186 2
a187 5
	nticks =  TICKS;
	dx = 0.1;	
	dy = 0.1;
	len = 0.2;
	tick_hgt = dy/4;
a188 3
/* fprintf(stderr, "plot: nticks=%d, dx=%f, dy=%f, len=%f, tick_hgt=%f\n",
 *	nticks, dx, dy, len, tick_hgt);
 */
d190 2
d194 2
a195 1
	 * system is a flat world.
d198 3
d202 1
a202 2
	VSET(v_leftpt, dx, dy, 0);
	VSET(v_rightpt, dx + len, dy, 0);
d204 6
a209 4
	/* First and last ticks. */
	
	VSET(v_ltick_top, dx, (dy + (0.5 * tick_hgt)), 0);
	VSET(v_ltick_bot, dx, (dy - (0.5 * tick_hgt)), 0);
d211 1
a211 2
	VSET(v_rtick_top, (dx + len), (dy + (0.5 * tick_hgt)), 0);
	VSET(v_rtick_bot, (dx + len), (dy - (0.5 * tick_hgt)), 0);
d213 2
a214 14
/* Why don't I get my tick marks?  
 * fprintf(stderr, "v_ltick_top: x=%f, y=%f, z=%f\n", v_ltick_top[X],
 *	v_ltick_top[Y], v_ltick_top[Z]);
 * fprintf(stderr, "v_ltick_bot: x=%f, y=%f, z=%f\n", v_ltick_bot[X],
 *	v_ltick_bot[Y], v_ltick_bot[Z]);
 * fprintf(stderr, "v_rtick_top: x=%f, y=%f, z=%f\n", v_rtick_top[X],
 *	v_rtick_top[Y], v_rtick_top[Z]);
 * fprintf(stderr, "v_rtick_bot: x=%f, y=%f, z=%f\n", v_rtick_bot[X],
 *	v_rtick_bot[Y], v_rtick_bot[Z]);
 */

	/* Now convert the coordinates to model space using a translation
	 * matrix.  This section is just an outline of things to come.
	 * It is hokey, and not meant to compile at this time.
d217 5
a221 2
	MAT4X3PNT(m_leftpt, *matp, v_leftpt);
	MAT4X3PNT(m_rightpt, *matp, v_rightpt);
d223 5
a227 4
	MAT4X3PNT(m_ltick_top, *matp, v_ltick_top);
	MAT4X3PNT(m_ltick_bot, *matp, v_ltick_bot);
	MAT4X3PNT(m_rtick_top, *matp, v_rtick_top);
	MAT4X3PNT(m_rtick_bot, *matp, v_rtick_bot);
d229 9
a237 3
	/* Now plot these coordinates and the tick marks on the scale
	 * in model space.  Plot on stdout (later this should be outfp).
	 */
d239 1
a239 21
/* fprintf(stderr, "plot: now plotting:\n");
 * fprintf(stderr, "m_leftpt: %f, %f, %f\n", m_leftpt[0], m_leftpt[1], m_leftpt[2]);
 * fprintf(stderr, "m_rightpt: %f, %f, %f\n", m_rightpt[0], m_rightpt[1], m_rightpt[2]);
 * fprintf(stderr, "m_ltick_bot: %f, %f, %f\n", m_ltick_bot[0], m_ltick_bot[1], m_ltick_bot[2]);
 * fprintf(stderr, "m_ltick_top: %f, %f, %f\n", m_ltick_top[0], m_ltick_top[1], m_ltick_top[2]);
 * fprintf(stderr, "m_rtick_bot: %f, %f, %f\n", m_rtick_bot[0], m_rtick_bot[1], m_rtick_bot[2]);
 * fprintf(stderr, "m_rtick_top: %f, %f, %f\n", m_rtick_top[0], m_rtick_top[1], m_rtick_top[2]);
 */

	pdv_3move(outfp, m_leftpt);
	pdv_3cont(outfp, m_rightpt);

	/* Draw first and last tick marks */

	pdv_3move(outfp, m_ltick_bot);
	pdv_3cont(outfp, m_ltick_top);

	pdv_3move(outfp, m_rtick_bot);
	pdv_3cont(outfp, m_rtick_top);

	return(SUCCESS);
a241 1

d248 1
a248 1
 * pointer as parameters.  It returns SUCCESS or ERROR.
d252 1
a252 1
read_rt_file(infp, matp)
d254 1
a254 1
mat_t 	*matp;
d299 1
a299 1
 *			return(ERROR);
d369 1
a369 1
				return(ERROR);
d384 1
a384 1
				return(ERROR);
d396 1
a396 1
				return(ERROR);
d406 1
a406 1
				return(ERROR);
d418 1
a418 1
		return(ERROR);
d423 1
a423 1
		return(ERROR);
d428 1
a428 1
		return(ERROR);
d433 1
a433 1
		return(ERROR);
a449 2
mat_print("view2model", view2model);

d454 1
a454 1
	mat_mul( matp, rotate, xlate );
d456 1
a456 2
mat_print("tmp_mat", *matp);
mat_print("new view2model", view2model);
d458 82
a539 1
	return(SUCCESS);
@


1.4
log
@The model2view matrix is now loaded and inverted to give a view2model
matrix.  The plotted output, when plrot is supplied with the ae from
the input file, appears at center screen, and is a line with two tick
marks, as expected.  Location may be a problem.
@
text
@d20 3
a22 1
*	   a composite that it printed on standard out.
d39 1
a39 1
static char RCSscale[] = "@@(#)$Header: /d/sue/develop/scales/RCS/scale.c,v 1.3 91/03/14 15:40:18 sue Exp $ (BRL)";
d85 1
d89 2
d100 6
a105 2
	/* Send pointer to stdin to read_rt_file, and send pointer to
	 * to stdout to layout_n_plot. */
d107 1
a107 1
	ret = read_rt_file(&view2model[0]);
d111 4
a114 1
	ret = layout_n_plot(stdout);
d127 6
a132 4
 *  This routine lays out the scale in view coordinates.  It then translates
 *  all the points into model coordinates and plots them in a file.
 *  It takes stdout as its parameter: this makes it very general.  Lastly,
 *  it returns SUCCESS or ERROR.
d136 1
a136 1
layout_n_plot(outfp)
d138 1
a138 1

d215 2
a216 2
	MAT4X3PNT(m_leftpt, view2model, v_leftpt);
	MAT4X3PNT(m_rightpt, view2model, v_rightpt);
d218 4
a221 4
	MAT4X3PNT(m_ltick_top, view2model, v_ltick_top);
	MAT4X3PNT(m_ltick_bot, view2model, v_ltick_bot);
	MAT4X3PNT(m_rtick_top, view2model, v_rtick_top);
	MAT4X3PNT(m_rtick_bot, view2model, v_rtick_bot);
d256 2
a257 1
 * necessary information.  It returns SUCCESS or ERROR.
d261 2
a262 1
read_rt_file(matp)
d298 1
a298 1
	while( feof(stdin) == 0 )  {
d304 1
a304 1
		ret = fgets(string, BUFF_LEN, stdin);
d332 1
a332 1
			if( string[0] == NULL )  {
d453 3
a455 2
	/* Build the view2model matrix.  Variables used only for this
	 * transaction are initialized here.
d465 1
a465 1
	mat_mul( tmp_mat, rotate, xlate );
d467 1
a467 4
mat_print("tmp_mat", tmp_mat);

	mat_inv( matp, tmp_mat );

@


1.3
log
@Scale can now read an rt_log input file to find the view, orientation,
eye_pos, and size of the model, as well as put out a basic scale.  The
diagnostic fprintf()s are still in the code, though commented out.  They
are not indented.
@
text
@d37 1
a37 1
static char RCSscale[] = "@@(#)$Header: /n/wolf/d/sue/develop/scales/RCS/scale.c,v 1.2 91/03/04 12:26:45 sue Exp $ (BRL)";
d82 1
d85 1
d98 1
a98 1
	ret = read_rt_file();
d246 2
a247 1
read_rt_file()
d266 2
d437 19
a455 1
	/* Build the view2model matrix. */
@


1.2
log
@This version now produces the first and last ticks as expected.  Note
that the scale is drawn in the first quadrant (so on the terminal it
appears in the lower left of the upper right quadrant).
@
text
@d14 2
a15 2
*	1) take pertinent information from the rt log file (size, etc.) and
*	   setting up the view2model matrix;
d19 2
a20 2
*	3) overlaying the scales onto the original image (plrot and cat the
*	   files together.
d36 2
a37 2
#ifdef lint
static char RCSscale.plot[] = "@@(#)$Header: /d/sue/develop/scales/RCS/scale.c,v 1.1 91/03/04 11:22:31 sue Exp $ (BRL)";
d47 6
a53 1

d55 1
a55 1
Usage:  scale.plot < file.ray\n";
d58 3
a60 1
static FILE		*outfp;		/* file pointer for plotting */
a61 4
void	layout_n_plot();
void	get_info();
void	overlay();

d69 1
d71 6
a76 6
*
*                     M A I N
*
*  Main exists to coordinate the actions of the three parts of this program.
*
*/
d78 2
a79 1
main()
d82 1
a82 1
	layout_n_plot();
d84 21
d115 2
a116 1
 *  It takes no parameters and it returns nothing.
d119 4
a122 2
void
layout_n_plot()
d162 4
d183 10
a192 1
/* Why don't I get my tick marks?  */
a193 9
fprintf(stderr, "v_ltick_top: x=%f, y=%f, z=%f\n", v_ltick_top[X],
	v_ltick_top[Y], v_ltick_top[Z]);
fprintf(stderr, "v_ltick_bot: x=%f, y=%f, z=%f\n", v_ltick_bot[X],
	v_ltick_bot[Y], v_ltick_bot[Z]);
fprintf(stderr, "v_rtick_top: x=%f, y=%f, z=%f\n", v_rtick_top[X],
	v_rtick_top[Y], v_rtick_top[Z]);
fprintf(stderr, "v_rtick_bot: x=%f, y=%f, z=%f\n", v_rtick_bot[X],
	v_rtick_bot[Y], v_rtick_bot[Z]);

d208 1
a208 2
	 * in model space. Note that the -o option for renaming the output
	 * needs to be interfaced to this.
d211 8
a218 4
	outfp = fopen("scale.pl",  "w");
	if( outfp == NULL)  {
		perror("scale.pl");
	}
a219 2
	/* Draw the basic line. */

d231 1
a231 2
	fclose(outfp);
	return;
d234 201
@


1.1
log
@Initial revision
@
text
@d37 1
a37 1
static char RCSscale.plot[] = "@@(#)$Header: $ (BRL)";
a127 1
	tick_hgt = dy/4;
d131 1
d195 1
a195 1
	pdv_3move(outfp, m_rtick_top);
@
