head	11.9;
access;
symbols
	ansi-20040405-merged:11.8.2.1
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1
	windows-6-0-branch:11.8.0.4;
locks; strict;
comment	@ * @;


11.9
date	2003.09.27.00.56.11;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.40;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1;
next	11.7;

11.7
date	2002.08.15.20.55.51;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.05.19.36.05;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.17.02.41.43;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.05.28.01.17.28;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.03.29.23.21.54;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.03.19.22.12.41;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.34;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.02.48.32;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.27;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.00.06;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.02.17.11.02.48;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.08.23.00.52;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.13.03.26.04;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.48;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.07.14.21.06.29;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.20.03.40.15;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.13.21.17.03;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.11.16.28.35;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.57.04;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.59.51;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.15.57;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.03.20;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.49.11;	author mike;	state Rel1;
branches;
next	3.2;

3.2
date	86.08.12.05.51.14;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.17.18.44.34;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.52;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	86.06.09.21.50.14;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.05.02.24.38;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.09.04;	author mike;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.02.17;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.48.09;	author morrison;	state dead;
branches;
next	;


desc
@Routine to make write a ray in VLD-Standard format.
@


11.9
log
@moved a majority of the rt "back-end" to liboptical in order to decouple a symbol reference as well as to provide the functionality in a library
@
text
@/*
 *  			W R A Y . C
 *
 *  Write a VLD-standard ray on the given file pointer.
 *  VLD-standard rays are defined by /vld/include/ray.h,
 *  included here for portability.  A variety of VLD programs
 *  exist to manipulate these files, including rayvect.
 *
 *  To obtain a UNIX-plot of a ray file, the procedure is:
 *	/vld/bin/rayvect -mMM < file.ray > file.vect
 *	/vld/bin/vectplot -mMM < file.vect > file.plot
 *	tplot -Tmeg file.plot		# or equivalent
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSwray[] = "@@(#)$Header: /c/CVS/brlcad/rt/wray.c,v 11.8 2002/08/20 17:08:40 jra Exp $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"


/* /vld/include/ray.h -- ray segment data format (D A Gwyn) */
/* binary ray segment data record; see ray(4V) (SCCS vers 1.4) */
struct vldray
{
	float	ox;			/* origin coordinates */
	float	oy;
	float	oz;
	float	rx;			/* ray vector */
	float	ry;
	float	rz;
	float	na;			/* origin surface normal */
	float	ne;
	float	pa;			/* principal direction */
	float	pe;
	float	pc;			/* principal curvature */
	float	sc;			/* secondary curvature */
	long	ob;			/* object code */
	long	rt;			/* ray tag */
};

/*
 *  Convert the normal vector into an azimuth angle (from +X axis)
 *  and an elevation angle (up from XY plane).
 *  The normal is expected to be pointing out from the object.
 *  The elevation is most readily computed as:
 *
 *	_ray.ne = asin( _norm[Z] );
 *
 *  but the asin() function can't deal with floating point noize that
 *  might make _norm[Z] slightly outside of the range -1.0 to +1.0.
 *  A completely stable formulation is:
 *
 *	_ray.ne = bn_atan2( _norm[Z], hypot( _norm[X], _norm[Y] ) );
 *
 *  Note that the hypot() return is always positive, restricting the
 *  range of return values for elevation to between -pi/2 and +pi/2,
 *  while the range of return values for azimuth is between -pi and +pi.
 *
 *  Because the normal vector has unit length (in 3-space, not necessarily
 *  in the XY plane), the magnitude of the X and Y elements will be <= 1.0,
 *  so the hypot() function can safely be expanded inline
 *  using a sqrt() call.  This will often be more efficient, especially
 *  on machines with hardware sqrt().
 */
#define WRAY_NORMAL(_ray, _norm)	\
	_ray.na = bn_atan2( _norm[Y], _norm[X] ); \
	_ray.ne = bn_atan2( _norm[Z], \
		sqrt( _norm[X] * _norm[X] + _norm[Y] * _norm[Y]) );

/*
 *  The 32-bit ray tag field (rt) is encoded as follows:
 *	13 bits for screen X,
 *	13 bits for screen Y,
 *	 6 bits for ray level.
 *
 *  This admits of different ray tags for every ray in a raytrace
 *  up to 4096x4096 pixels, with up to 64 levels of recursion.
 *  It is not clear just why this had to be encoded; it would have
 *  been more useful for the file to have several fields for this.
 *
 *  0                   1                   2                   3 3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         Screen Y        |          Screen X       |    Level  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define WRAY_TAG(_ray, _ap)	{ \
		if( (_ray.rt = _ap->a_level) > 0x3F || _ray.rt < 0 ) \
			_ray.rt = 0x3F; \
		_ray.rt |= ((_ap->a_x & 0x1FFF) << 6 ) | \
			   ((_ap->a_y & 0x1FFF) << (6+13) ); \
	}

/*
 *  			W R A Y
 */
void
wray( pp, ap, fp, inormal )
register struct partition *pp;
register struct application *ap;
FILE *fp;
const vect_t	inormal;
{
	LOCAL struct vldray vldray;
	register struct hit *hitp= pp->pt_inhit;

	VMOVE( &(vldray.ox), hitp->hit_point );
	VSUB2( &(vldray.rx), pp->pt_outhit->hit_point,
		hitp->hit_point );

	WRAY_NORMAL( vldray, inormal );

	vldray.pa = vldray.pe = vldray.pc = vldray.sc = 0;	/* no curv */

	/*  Air is marked by zero or negative region ID codes.
	 *  When air is encountered, the air code is taken from reg_aircode.
	 *  The negative of the air code is used for the "ob" field, to
	 *  distinguish air from other regions.
	 */
	if( (vldray.ob = pp->pt_regionp->reg_regionid) <= 0 )
		vldray.ob = -(pp->pt_regionp->reg_aircode);

	WRAY_TAG( vldray, ap );

	if( fwrite( &vldray, sizeof(struct vldray), 1, fp ) != 1 )
		rt_bomb("rway:  write error");
}

/*
 *  			W R A Y P T S
 *  
 *  Write a VLD-standard ray for a section of a ray specified
 *  by the "in" and "out" distances along the ray.  This is usually
 *  used for logging passage through "air" (ie, no solid).
 *  The "inorm" flag holds an inward pointing normal (typ. a r_dir value)
 *  that will be flipped on output, so that the "air solid"
 *  has a proper outward pointing normal.
 */
void
wraypts( in, inorm, out, id, ap, fp )
vect_t	in;
vect_t	inorm;
vect_t	out;
int	id;
struct application *ap;
FILE	*fp;
{
	LOCAL struct vldray vldray;
	vect_t	norm;

	VMOVE( &(vldray.ox), in );
	VSUB2( &(vldray.rx), out, in );

	VREVERSE( norm, inorm );
	WRAY_NORMAL( vldray, norm );

	vldray.pa = vldray.pe = vldray.pc = vldray.sc = 0;	/* no curv */

	vldray.ob = id;

	WRAY_TAG( vldray, ap );

	fwrite( &vldray, sizeof(struct vldray), 1, fp );
}

/*
 *			W R A Y P A I N T
 *
 *  Write "paint" into a VLD standard rayfile.
 */
void
wraypaint( start, norm, paint, ap, fp )
vect_t start, norm;
struct application *ap;
FILE *fp;
{
	LOCAL struct vldray vldray;

	VMOVE( &(vldray.ox), start );
	VSETALL( &(vldray.rx), 0 );

	WRAY_NORMAL( vldray, norm );

	vldray.pa = vldray.pe = vldray.pc = vldray.sc = 0;	/* no curv */

	vldray.ob = paint;

	WRAY_TAG( vldray, ap );

	fwrite( &vldray, sizeof(struct vldray), 1, fp );
}
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d27 1
a27 1
static const char RCSwray[] = "@@(#)$Header: /c/CVS/brlcad/rt/wray.c,v 11.6 2001/04/05 19:36:05 morrison Exp $ (BRL)";
@


11.8.4.1
log
@sync to HEAD...
@
text
@d27 1
a27 1
static const char RCSwray[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/Attic/wray.c,v 11.8 2002/08/20 17:08:40 jra Exp $ (BRL)";
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSwray[] = "@@(#)$Header: /c/CVS/brlcad/rt/wray.c,v 11.8 2002/08/20 17:08:40 jra Exp $ (BRL)";
d116 5
a120 1
wray(register struct partition *pp, register struct application *ap, FILE *fp, const fastf_t *inormal)
d158 7
a164 1
wraypts(fastf_t *in, fastf_t *inorm, fastf_t *out, int id, struct application *ap, FILE *fp)
d190 4
a193 1
wraypaint(fastf_t *start, fastf_t *norm, int paint, struct application *ap, FILE *fp)
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d116 5
a120 1
wray(register struct partition *pp, register struct application *ap, FILE *fp, const fastf_t *inormal)
d158 7
a164 1
wraypts(fastf_t *in, fastf_t *inorm, fastf_t *out, int id, struct application *ap, FILE *fp)
d190 4
a193 1
wraypaint(fastf_t *start, fastf_t *norm, int paint, struct application *ap, FILE *fp)
@


11.6
log
@updated SIGNED to signed
updated CONST to const
@
text
@d27 1
a27 1
static const char RCSwray[] = "@@(#)$Header: /c/CVS/brlcad/rt/wray.c,v 11.5 2000/08/17 02:41:43 mike Exp $ (BRL)";
d116 1
a116 5
wray( pp, ap, fp, inormal )
register struct partition *pp;
register struct application *ap;
FILE *fp;
const vect_t	inormal;
d154 1
a154 7
wraypts( in, inorm, out, id, ap, fp )
vect_t	in;
vect_t	inorm;
vect_t	out;
int	id;
struct application *ap;
FILE	*fp;
d180 1
a180 4
wraypaint( start, norm, paint, ap, fp )
vect_t start, norm;
struct application *ap;
FILE *fp;
@


11.5
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d27 1
a27 1
static const char RCSwray[] = "@@(#)$Header: /c/CVS/brlcad/rt/wray.c,v 11.4 1999/05/28 01:17:28 mike Exp $ (BRL)";
d120 1
a120 1
CONST vect_t	inormal;
@


11.4
log
@
sed4
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: /c/CVS/brlcad/rt/wray.c,v 11.3 1996/03/29 23:21:54 mike Exp $ (BRL)";
@


11.3
log
@Changed calling sequence to wray().
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: /m/cad/rt/RCS/wray.c,v 11.2 1996/03/19 22:12:41 mike Exp mike $ (BRL)";
d71 1
a71 1
 *	_ray.ne = mat_atan2( _norm[Z], hypot( _norm[X], _norm[Y] ) );
d84 2
a85 2
	_ray.na = mat_atan2( _norm[Y], _norm[X] ); \
	_ray.ne = mat_atan2( _norm[Z], \
@


11.2
log
@Fixed potential inflip problem.
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: /m/cad/rt/RCS/wray.c,v 11.1 1995/01/04 10:01:34 mike Rel4_4 mike $ (BRL)";
d116 1
a116 1
wray( pp, ap, fp )
d120 1
a122 1
	vect_t	norm;
d129 1
a129 6
	if( pp->pt_inflip )  {
		VREVERSE( norm, hitp->hit_normal );
	} else {
		VMOVE( norm, hitp->hit_normal );
	}
	WRAY_NORMAL( vldray, norm );
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: /m/cad/rt/RCS/wray.c,v 10.2 94/08/11 02:48:32 gdurf Exp $ (BRL)";
d122 1
d130 3
a132 2
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
		pp->pt_inflip = 0;
d134 1
a134 1
	WRAY_NORMAL( vldray, hitp->hit_normal );
@


10.2
log
@Added include of conf.h
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: /m/cad/rt/RCS/wray.c,v 10.1 1991/10/12 06:42:27 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 9.1 89/05/19 06:00:06 mike Rel3_5 $ (BRL)";
d29 2
@


9.1
log
@Release_3.5
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 8.4 89/02/17 11:02:48 mike Exp $ (BRL)";
@


8.4
log
@Added some extra comments about the range of az and el
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 8.3 89/01/08 23:00:52 mike Locked $ (BRL)";
@


8.3
log
@Replaced asin() with a more stable formulation.
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 8.2 88/12/13 03:26:04 mike Locked $ (BRL)";
d71 4
d76 2
a77 1
 *  in the XY plane), the hypot() function can safely be expanded inline
@


8.2
log
@Changed from atan2 to mat_atan2
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 8.1 88/10/05 00:33:48 mike Locked $ (BRL)";
d57 19
a75 1
/* The normal is expected to be pointing out from the object */
d78 2
a79 1
	_ray.ne = asin( _norm[Z] );
@


8.1
log
@Release_3.0
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 7.5 88/07/14 21:06:29 mike Exp $ (BRL)";
d59 1
a59 1
	_ray.na = atan2( _norm[Y], _norm[X] ); \
@


7.5
log
@VLD convention for handling air regions is clarified:
if reg_regionid is > 0, region is solid.
if reg_regionid is <=0, region is air, and code comes from reg_aircode.
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 7.4 88/05/20 03:40:15 mike Locked $ (BRL)";
@


7.4
log
@changed for new wraypts() calling sequence,
added wraypaint
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 7.3 88/05/13 21:17:03 mike Locked $ (BRL)";
d110 7
a116 2
	/* Air is marked by negative region IDs */
	vldray.ob = pp->pt_regionp->reg_regionid;
@


7.3
log
@New encoding for VLD rayfile "rt" ray tag field.
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 7.2 88/02/11 16:28:35 mike Locked $ (BRL)";
d57 5
d63 24
d92 1
a92 1
struct application *ap;
a96 1
	register int i;
d104 1
d106 1
a106 2
	vldray.na = atan2( hitp->hit_normal[Y], hitp->hit_normal[X] );
	vldray.ne = asin( hitp->hit_normal[Z] );
d110 1
d113 1
a113 21
	/*
	 *  The 32-bit ray tag field (rt) is encoded as follows:
	 *	13 bits for screen X,
	 *	13 bits for screen Y,
	 *	 6 bits for ray level.
	 *
	 *  This admits of different ray tags for every ray in a raytrace
	 *  up to 4096x4096 pixels, with up to 64 levels of recursion.
	 *  It is not clear just why this is useful.
	 *
	 *  0                   1                   2                   3 3
	 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 * |         Screen Y        |          Screen X       |    Level  |
	 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 */
	if( (i = ap->a_level) > 0x3F || i < 0 )
		i = 0x3F;
	vldray.rt = (i << 0 ) |
		((ap->a_x & 0x1FFF) << 6 ) |
		((ap->a_y & 0x1FFF) << (6+13) );
d125 3
d130 5
a134 2
wraypts( in, out, ap, fp )
vect_t in, out;
d136 1
a136 1
FILE *fp;
d139 1
d144 2
a145 2
	vldray.na = atan2( ap->a_ray.r_dir[Y], ap->a_ray.r_dir[X] );
	vldray.ne = asin( ap->a_ray.r_dir[Z] );
d149 1
a149 1
	vldray.ob = 0;		/* might want to be something special */
d151 29
a179 1
	vldray.rt = (ap->a_y << 16) | (ap->a_level & 0xFFFF);
@


7.2
log
@changed to new vld standard ray format....
no curvature info yet though.
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 7.1 87/11/02 23:57:04 phil Locked $ (BRL)";
d83 25
a107 2
	vldray.rt = (ap->a_y << 16) | (ap->a_level & 0xFFFF);
	fwrite( &vldray, sizeof(struct vldray), 1, fp );
@


7.1
log
@Release 2.3
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 6.1 87/07/11 07:59:51 mike Rel $ (BRL)";
d38 3
a40 2
/* binary ray segment data record; see ray(4V) */
struct vldray  {
d49 6
a54 5
	/* the following are in 2 pieces for binary file portability: */
	short	ob_lo;			/* object code low 16 bits */
	short	ob_hi;			/* object code high 16 bits */
	short	rt_lo;			/* ray tag low 16 bits */
	short	rt_hi;			/* ray tag high 16 bits */
d80 4
a83 5
	i = pp->pt_regionp->reg_regionid;
	vldray.ob_lo = i & 0xFFFF;
	vldray.ob_hi = (i>>16) & 0xFFFF;
	vldray.rt_lo = ap->a_level;
	vldray.rt_hi = ap->a_y;
d88 1
a88 1
 *  			W R A Y D I S T
d108 1
a108 2
	vldray.ob_lo = 0;	/* might want to be something special */
	vldray.ob_hi = 0;
d110 3
a112 2
	vldray.rt_lo = ap->a_level;
	vldray.rt_hi = ap->a_y;
@


6.1
log
@Release 2.0
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 5.1 87/06/24 22:15:57 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 4.2 87/02/13 00:03:20 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 4.1 86/12/29 03:49:11 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 3.2 86/08/12 05:51:14 mike Exp $ (BRL)";
@


3.2
log
@Changed to find #include files with CC -I../h
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 3.1 86/07/17 18:44:34 mike Exp $ (BRL)";
@


3.1
log
@Changed RCSid symbol to be unique, for Cray bulk-loading.
@
text
@d27 1
a27 1
static char RCSwray[] = "@@(#)$Header: wray.c,v 3.0 86/06/10 01:32:52 mike Exp $ (BRL)";
d32 3
a34 3
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wray.c,v 2.3 86/06/09 21:50:14 mike Exp $ (BRL)";
@


2.3
log
@rt and librt separated
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wray.c,v 2.2 85/09/05 02:24:38 mike Exp $ (BRL)";
@


2.2
log
@Added computations for azimuth/elevation in output file.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wray.c,v 2.1 85/08/31 06:09:04 mike Exp $ (BRL)";
d34 1
a34 1
#include "raytrace.h"
@


2.1
log
@Version 2 of RT
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d31 1
d65 1
d68 1
a68 1
	VMOVE( &(vldray.ox), pp->pt_inhit->hit_point );
d70 1
a70 1
		pp->pt_inhit->hit_point );
d72 5
a76 2
	/* Check pt_inflip, pt_outflip for normals! */
	vldray.na = vldray.ne = 0.0;	/* need angle/azim!! */
d81 1
a81 1
	vldray.rt_lo = ap->a_x;
d83 29
a111 1
	/* Might encode a_level here too, somehow */
@
