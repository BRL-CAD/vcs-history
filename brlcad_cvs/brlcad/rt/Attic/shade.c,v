head	11.35;
access;
symbols
	ansi-20040405-merged:11.34.2.1
	phong-branch:11.34.0.8
	photonmap-branch:11.34.0.6
	rel-6-1-DP:11.34
	rel-6-0-2:11.32
	ansi-branch:11.34.0.2
	rel-6-0-1-branch:11.32.0.2
	hartley-6-0-post:11.33
	hartley-6-0-pre:11.32
	rel-6-0-1:11.32
	rel-6-0:11.31
	rel-5-4:11.25
	offsite-5-3-pre:11.30
	rel-5-3:11.25
	rel-5-2:11.25
	rel-5-1-branch:11.25.0.2
	rel-5-1:11.25
	rel-5-0:11.17
	rel-5-0-beta:11.17
	rel-4-5:11.9
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	windows-6-0-branch:11.34.0.4;
locks; strict;
comment	@ * @;


11.35
date	2003.09.27.00.56.11;	author morrison;	state dead;
branches;
next	11.34;

11.34
date	2002.08.20.17.08.38;	author jra;	state Exp;
branches
	11.34.2.1
	11.34.4.1;
next	11.33;

11.33
date	2002.08.15.20.55.50;	author hartley;	state Exp;
branches;
next	11.32;

11.32
date	2002.07.16.19.38.39;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2001.04.05.19.36.04;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2000.10.20.18.55.01;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.20.00.45.26;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	2000.08.17.02.41.37;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.07.27.19.32.52;	author butler;	state Exp;
branches;
next	11.26;

11.26
date	2000.07.25.16.39.48;	author butler;	state Exp;
branches;
next	11.25;

11.25
date	2000.02.11.20.22.14;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	2000.02.03.06.33.40;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	2000.01.22.03.51.44;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.12.29.03.38.44;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.12.18.02.13.45;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.11.24.22.16.07;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.10.30.03.53.05;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.10.30.03.06.27;	author butler;	state Exp;
branches;
next	11.17;

11.17
date	99.05.28.01.17.27;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.05.10.21.39.16;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	98.12.16.03.51.17;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	98.12.12.07.25.00;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	98.12.11.22.53.21;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	98.12.10.08.42.54;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	98.09.22.01.46.58;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	98.09.22.01.43.12;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	97.03.04.05.51.52;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.03.04.05.36.50;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.02.26.21.25.52;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.08.14.03.45.35;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.05.09.03.26.33;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.03.29.23.20.55;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.03.19.22.10.16;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.08.22.02.23.24;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.17;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.11.05.03.09.49;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.05.02.50.52;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.02.43.36;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.05.10.11.02.06;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.05.06.03.09.09;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.05.05.23.39.31;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.14;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.08.16.16.15.19;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.08.16.15.16.22;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.11.10.19.36.31;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.01.11.17.34;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.01.06.53.21;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.10.15.12.09.09;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.12.02.14.29;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.48;	author mike;	state Rel3_5;
branches;
next	1.1;

1.1
date	89.05.19.03.20.29;	author mike;	state Exp;
branches;
next	;

11.34.2.1
date	2002.09.19.18.02.16;	author morrison;	state Exp;
branches;
next	;

11.34.4.1
date	2004.03.11.23.48.07;	author morrison;	state dead;
branches;
next	;


desc
@lighting model shader interface
@


11.35
log
@moved a majority of the rt "back-end" to liboptical in order to decouple a symbol reference as well as to provide the functionality in a library
@
text
@/*
 *			S H A D E . C
 *
 *	Ray Tracing program, lighting model shader interface.
 *
 *  Notes -
 *	The normals on all surfaces point OUT of the solid.
 *	The incomming light rays point IN.
 *
 *  Authors -
 *	Michael John Muuss
 *	Phil Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.34 2002/08/20 17:08:38 jra Exp $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "./ext.h"
#include "rtprivate.h"
#include "light.h"
#include "plot3.h"



/*
 *			S H A D E _ I N P U T S
 *
 *  Compute the necessary fields in the shadework structure.
 *
 *  Note that only hit_dist is valid in pp_inhit.
 *  Must calculate it if hit_norm is needed,
 *  after which pt_inflip must be handled.
 *  RT_HIT_UVCOORD() must have hit_point computed
 *  in advance.
 *
 *  If MFI_LIGHT is not on, the presumption is that the sw_visible[]
 *  array is not needed, or has been handled elsewhere.
 */
void
shade_inputs( ap, pp, swp, want )
struct application *ap;
register const struct partition *pp;
register struct shadework *swp;
register int	want;
{
	register int	have;

	RT_CK_RAY( swp->sw_hit.hit_rayp );

	/* These calcuations all have MFI_HIT as a pre-requisite */
	if( want & (MFI_NORMAL|MFI_LIGHT|MFI_UV) )
		want |= MFI_HIT;

	have = swp->sw_inputs;
	want &= ~have;		/* we don't want what we already have */

	if( want & MFI_HIT )  {
		VJOIN1( swp->sw_hit.hit_point, ap->a_ray.r_pt,
			swp->sw_hit.hit_dist, ap->a_ray.r_dir );
		have |= MFI_HIT;
	}

	if( want & MFI_NORMAL )  {
		if( pp->pt_inhit->hit_dist < 0.0 )  {
			/* Eye inside solid, orthoview */
			VREVERSE( swp->sw_hit.hit_normal, ap->a_ray.r_dir );
		} else {
			FAST fastf_t f;
			/* Get surface normal for hit point */
			/* Stupid SysV CPP needs this on one line */
			RT_HIT_NORMAL( swp->sw_hit.hit_normal, &(swp->sw_hit), pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip );

#ifdef never
			if( swp->sw_hit.hit_normal[X] < -1.01 || swp->sw_hit.hit_normal[X] > 1.01 ||
			    swp->sw_hit.hit_normal[Y] < -1.01 || swp->sw_hit.hit_normal[Y] > 1.01 ||
			    swp->sw_hit.hit_normal[Z] < -1.01 || swp->sw_hit.hit_normal[Z] > 1.01 )  {
			    	VPRINT("shade_inputs: N", swp->sw_hit.hit_normal);
				VSET( swp->sw_color, 9, 9, 0 );	/* Yellow */
				return;
			}
#endif
			/* Check to make sure normals are OK */
			f = VDOT(ap->a_ray.r_dir,swp->sw_hit.hit_normal);
			if (f > 0.0 &&
			    !BN_VECT_ARE_PERP(f, &(ap->a_rt_i->rti_tol))) {
				bu_log("shade_inputs(%s) flip N xy=%d,%d %s surf=%d dot=%g\n",
				       pp->pt_inseg->seg_stp->st_name,
				       ap->a_x, ap->a_y,
				       rt_functab[
                                         pp->pt_inseg->seg_stp->st_id
				       ].ft_name,
				       swp->sw_hit.hit_surfno, f);
				if( rdebug&RDEBUG_SHADE ) {
					VPRINT("Dir ", ap->a_ray.r_dir);
					VPRINT("Norm", swp->sw_hit.hit_normal);
				}
			}
		}
		if( rdebug&(RDEBUG_RAYPLOT|RDEBUG_SHADE) )  {
			point_t		endpt;
			fastf_t		f;
			/* Plot the surface normal -- green/blue */
			/* plotfp */
			f = ap->a_rt_i->rti_radius * 0.02;
			VJOIN1( endpt, swp->sw_hit.hit_point,
				f, swp->sw_hit.hit_normal );
			if(rdebug&RDEBUG_RAYPLOT)  {
				bu_semaphore_acquire( BU_SEM_SYSCALL );
				pl_color( stdout, 0, 255, 255 );
				pdv_3line( stdout, swp->sw_hit.hit_point, endpt );
				bu_semaphore_release( BU_SEM_SYSCALL );
			}
			bu_log("Surface normal for shader:\n\
hit pt: %g %g %g end pt: %g %g %g\n",
				V3ARGS(swp->sw_hit.hit_point),
				V3ARGS(endpt) );

		}
		have |= MFI_NORMAL;
	}
	if( want & MFI_UV )  {
		if( pp->pt_inhit->hit_dist < 0.0 )  {
			/* Eye inside solid, orthoview */
			swp->sw_uv.uv_u = swp->sw_uv.uv_v = 0.5;
			swp->sw_uv.uv_du = swp->sw_uv.uv_dv = 0;
		} else {
			RT_HIT_UVCOORD(	ap, pp->pt_inseg->seg_stp,
				&(swp->sw_hit), &(swp->sw_uv) );
		}
		if( swp->sw_uv.uv_u < 0 || swp->sw_uv.uv_u > 1 ||
		    swp->sw_uv.uv_v < 0 || swp->sw_uv.uv_v > 1 )  {
			bu_log("shade_inputs:  bad u,v=%e,%e du,dv=%g,%g seg=%s %s surf=%d. xy=%d,%d Making green.\n",
				swp->sw_uv.uv_u, swp->sw_uv.uv_v,
				swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
				pp->pt_inseg->seg_stp->st_name,
		    		rt_functab[pp->pt_inseg->seg_stp->st_id].ft_name,
		    		pp->pt_inhit->hit_surfno,
				ap->a_x, ap->a_y );
#if RT_MULTISPECTRAL
		    	{
		    		static const vect_t green = {0,9,0};
				rt_spect_reflectance_rgb( swp->msw_color, green );
		    	}
#else
			VSET( swp->sw_color, 0, 9, 0 );	/* Hyper-Green */
#endif

			return;
		}
		have |= MFI_UV;
	}
	/* NOTE:  Lee has changed the shaders to do light themselves now. */
	/* This isn't where light visibility is determined any more. */
	if( want & MFI_LIGHT )  {
	light_obs(ap, swp, have);
		have |= MFI_LIGHT;
	}

	/* Record which fields were filled in */
	swp->sw_inputs = have;

	if( (want & have) != want )
		bu_log("shade_inputs:  unable to satisfy request for x%x\n", want);
}

/*
 *			V I E W S H A D E
 *
 *  Call the material-specific shading function, after making certain
 *  that all shadework fields desired have been provided.
 *
 *  Returns -
 *	0 on failure
 *	1 on success
 *
 *	But of course, nobody cares what this returns.
 *	Everyone calls us as (void)viewshade()
 */
int
viewshade( ap, pp, swp )
struct application *ap;
register const struct partition *pp;
register struct shadework *swp;
{
	register const struct mfuncs *mfp;
	register const struct region *rp;
	register const struct light_specific *lp;
	register int	want;

	RT_AP_CHECK(ap);
	RT_CK_RTI(ap->a_rt_i);
	RT_CK_PT(pp);
	RT_CK_HIT(pp->pt_inhit);
	RT_CK_RAY(pp->pt_inhit->hit_rayp);
	rp = pp->pt_regionp;
	RT_CK_REGION(rp);
	mfp = (struct mfuncs *)pp->pt_regionp->reg_mfuncs;
	RT_CK_MF(mfp);

	want = mfp->mf_inputs;

	if( rdebug&RDEBUG_SHADE ) {
		bu_log("viewshade(%s)\n Using \"%s\" shader, ",
			rp->reg_name, mfp->mf_name);
		bu_printb( "mfp_inputs", want, MFI_FORMAT );
		bu_log( "\n");
	}

	swp->sw_hit = *(pp->pt_inhit);		/* struct copy */

#if RT_MULTISPECTRAL
	/* XXX where does region get reflectance?  Default temperature? */
	BN_CK_TABDATA(swp->msw_color);
	BN_CK_TABDATA(swp->msw_basecolor);
	if( rp->reg_mater.ma_color_valid )  {
		rt_spect_reflectance_rgb( swp->msw_color, rp->reg_mater.ma_color );
	}
	bn_tabdata_copy(swp->msw_basecolor, swp->msw_color);
#else
	/* Default color is white (uncolored) */
	if( rp->reg_mater.ma_color_valid )  {
		VMOVE( swp->sw_color, rp->reg_mater.ma_color );
	}
	VMOVE( swp->sw_basecolor, swp->sw_color );
#endif

	if( swp->sw_hit.hit_dist < 0.0 )
		swp->sw_hit.hit_dist = 0.0;	/* Eye inside solid */
	ap->a_cumlen += swp->sw_hit.hit_dist;

	/* If light information is not needed, set the light
	 * array to "safe" values,
	 * and claim that the light is visible, in case they are used.
	 */
	if( swp->sw_xmitonly )  want &= ~MFI_LIGHT;
	if( !(want & MFI_LIGHT) )  {
		register int	i;

		/* sanity */
		i=0;
		for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lp);
			swp->sw_visible[i++] = (char *)lp;
		}
		for( ; i < SW_NLIGHTS; i++ )  {
			swp->sw_visible[i] = (char *)NULL;
		}
	}

	/* If optional inputs are required, have them computed */
	if( want & (MFI_HIT|MFI_NORMAL|MFI_LIGHT|MFI_UV) )  {
		VJOIN1( swp->sw_hit.hit_point, ap->a_ray.r_pt,
			swp->sw_hit.hit_dist, ap->a_ray.r_dir );
		swp->sw_inputs |= MFI_HIT;
	}
	if( (swp->sw_inputs & want) != want )  {
		shade_inputs( ap, pp, swp, want );
	} else if( !(want & MFI_LIGHT) )  {
		register int	i;

		/* sanity */
		for( i = SW_NLIGHTS-1; i >= 0; i-- )  {
			swp->sw_visible[i] = (char *)NULL;
		}
	}

	if( rdebug&RDEBUG_SHADE ) {
		pr_shadework( "before mf_render", swp );
	}


	/* Invoke the actual shader (may be a tree of them) */
	(void)mfp->mf_render( ap, pp, swp, rp->reg_udata );

	if( rdebug&RDEBUG_SHADE ) {
		pr_shadework( "after mf_render", swp );
		bu_log("\n");
	}

	return(1);
}





/*
 *			P R _ S H A D E W O R K
 *
 *  Pretty print a shadework structure.
 */
void
pr_shadework( str, swp )
const char *str;
register const struct shadework *swp;
{
	int	i;

	bu_log( "Shadework %s: 0x%x\n", str, swp );
	bu_printb( " sw_inputs", swp->sw_inputs, MFI_FORMAT );
	if (swp->sw_inputs && MFI_HIT)
		bu_log( " sw_hit.dist:%g  sw_hit.point(%g %g %g)\n",
			swp->sw_hit.hit_dist, 
			V3ARGS(swp->sw_hit.hit_point));
	else
		bu_log( " sw_hit.dist:%g\n", swp->sw_hit.hit_dist);

	if (swp->sw_inputs && MFI_NORMAL) 
		bu_log(" sw_hit.normal(%g %g %g)\n",
			V3ARGS(swp->sw_hit.hit_normal));


	bu_log( " sw_transmit %f\n", swp->sw_transmit );
	bu_log( " sw_reflect %f\n", swp->sw_reflect );
	bu_log( " sw_refract_index %f\n", swp->sw_refrac_index );
	bu_log( " sw_extinction %f\n", swp->sw_extinction );
#if RT_MULTISPECTRAL
	bn_pr_tabdata( "msw_color", swp->msw_color );
	bn_pr_tabdata( "msw_basecolor", swp->msw_basecolor );
#else
	VPRINT( " sw_color", swp->sw_color );
	VPRINT( " sw_basecolor", swp->sw_basecolor );
#endif
	bu_log( " sw_uv  %f %f\n", swp->sw_uv.uv_u, swp->sw_uv.uv_v );
	bu_log( " sw_dudv  %f %f\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv );
	bu_log( " sw_xmitonly %d\n", swp->sw_xmitonly );
	bu_log( "\n");
	if( swp->sw_inputs & MFI_LIGHT ) for( i=0; i < SW_NLIGHTS; i++ )  {
		if( swp->sw_visible[i] == (char *)0 )  continue;
		RT_CK_LIGHT( swp->sw_visible[i] );
#if RT_MULTISPECTRAL
		bu_log("   light %d visible, dir=(%g,%g,%g)\n",
			i,
			V3ARGS(&swp->sw_tolight[i*3]) );
		BN_CK_TABDATA(swp->msw_intensity[i]);
		bn_pr_tabdata("light intensity", swp->msw_intensity[i] );
#else
		bu_log("   light %d visible, intensity=%g, dir=(%g,%g,%g)\n",
			i,
			swp->sw_intensity[i],
			V3ARGS(&swp->sw_tolight[i*3]) );
#endif
	}
}
@


11.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.32 2002/07/16 19:38:39 morrison Exp $ (BRL)";
@


11.34.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
static const char RCSview[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/rt/Attic/shade.c,v 11.34 2002/08/20 17:08:38 jra Exp $ (BRL)";
@


11.34.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.34 2002/08/20 17:08:38 jra Exp $ (BRL)";
d59 5
a63 1
shade_inputs(struct application *ap, register const struct partition *pp, register struct shadework *swp, register int want)
d199 4
a202 1
viewshade(struct application *ap, register const struct partition *pp, register struct shadework *swp)
d312 3
a314 1
pr_shadework(const char *str, register const struct shadework *swp)
@


11.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d59 5
a63 1
shade_inputs(struct application *ap, register const struct partition *pp, register struct shadework *swp, register int want)
d199 4
a202 1
viewshade(struct application *ap, register const struct partition *pp, register struct shadework *swp)
d312 3
a314 1
pr_shadework(const char *str, register const struct shadework *swp)
@


11.32
log
@Moved the non-local-only header file (light.h) from rt/ into the header directory since it is used by multiple targets (liboptical, rt, etc)
@
text
@d24 1
a24 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.31 2001/04/05 19:36:04 morrison Exp $ (BRL)";
d59 1
a59 5
shade_inputs( ap, pp, swp, want )
struct application *ap;
register const struct partition *pp;
register struct shadework *swp;
register int	want;
d195 1
a195 4
viewshade( ap, pp, swp )
struct application *ap;
register const struct partition *pp;
register struct shadework *swp;
d305 1
a305 3
pr_shadework( str, swp )
const char *str;
register const struct shadework *swp;
@


11.31
log
@updated SIGNED to signed
updated CONST to const
@
text
@d24 1
a24 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.30 2000/10/20 18:55:01 mike Exp $ (BRL)";
d39 1
a39 1
#include "./light.h"
@


11.30
log
@
Locking for making plot files in parallel.
Keeps CPUs from tripping over each other.
@
text
@d24 1
a24 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.29 2000/08/20 00:45:26 butler Exp $ (BRL)";
d61 1
a61 1
register CONST struct partition *pp;
d160 1
a160 1
		    		static CONST vect_t green = {0,9,0};
d201 1
a201 1
register CONST struct partition *pp;
d204 3
a206 3
	register CONST struct mfuncs *mfp;
	register CONST struct region *rp;
	register CONST struct light_specific *lp;
d313 2
a314 2
CONST char *str;
register CONST struct shadework *swp;
@


11.29
log
@Rearranged code for better compilation
@
text
@d24 1
a24 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.28 2000/08/17 02:41:37 mike Exp $ (BRL)";
a122 1
			if(rdebug&RDEBUG_RAYPLOT) pl_color( stdout, 0, 255, 255 );
d126 6
a131 1
			if(rdebug&RDEBUG_RAYPLOT) pdv_3line( stdout, swp->sw_hit.hit_point, endpt );
@


11.28
log
@
Added "const" to RCSid, to quiet Gnu C compilers.
@
text
@d24 1
a24 1
static const char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.27 2000/07/27 19:32:52 butler Exp $ (BRL)";
a41 122
HIDDEN void	shade_inputs();


/*
 *			V I E W S H A D E
 *
 *  Call the material-specific shading function, after making certain
 *  that all shadework fields desired have been provided.
 *
 *  Returns -
 *	0 on failure
 *	1 on success
 *
 *	But of course, nobody cares what this returns.
 *	Everyone calls us as (void)viewshade()
 */
int
viewshade( ap, pp, swp )
struct application *ap;
register CONST struct partition *pp;
register struct shadework *swp;
{
	register CONST struct mfuncs *mfp;
	register CONST struct region *rp;
	register CONST struct light_specific *lp;
	register int	want;

	RT_AP_CHECK(ap);
	RT_CK_RTI(ap->a_rt_i);
	RT_CK_PT(pp);
	RT_CK_HIT(pp->pt_inhit);
	RT_CK_RAY(pp->pt_inhit->hit_rayp);
	rp = pp->pt_regionp;
	RT_CK_REGION(rp);
	mfp = (struct mfuncs *)pp->pt_regionp->reg_mfuncs;
	RT_CK_MF(mfp);

	want = mfp->mf_inputs;

	if( rdebug&RDEBUG_SHADE ) {
		bu_log("viewshade(%s)\n Using \"%s\" shader, ",
			rp->reg_name, mfp->mf_name);
		bu_printb( "mfp_inputs", want, MFI_FORMAT );
		bu_log( "\n");
	}

	swp->sw_hit = *(pp->pt_inhit);		/* struct copy */

#if RT_MULTISPECTRAL
	/* XXX where does region get reflectance?  Default temperature? */
	BN_CK_TABDATA(swp->msw_color);
	BN_CK_TABDATA(swp->msw_basecolor);
	if( rp->reg_mater.ma_color_valid )  {
		rt_spect_reflectance_rgb( swp->msw_color, rp->reg_mater.ma_color );
	}
	bn_tabdata_copy(swp->msw_basecolor, swp->msw_color);
#else
	/* Default color is white (uncolored) */
	if( rp->reg_mater.ma_color_valid )  {
		VMOVE( swp->sw_color, rp->reg_mater.ma_color );
	}
	VMOVE( swp->sw_basecolor, swp->sw_color );
#endif

	if( swp->sw_hit.hit_dist < 0.0 )
		swp->sw_hit.hit_dist = 0.0;	/* Eye inside solid */
	ap->a_cumlen += swp->sw_hit.hit_dist;

	/* If light information is not needed, set the light
	 * array to "safe" values,
	 * and claim that the light is visible, in case they are used.
	 */
	if( swp->sw_xmitonly )  want &= ~MFI_LIGHT;
	if( !(want & MFI_LIGHT) )  {
		register int	i;

		/* sanity */
		i=0;
		for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lp);
			swp->sw_visible[i++] = (char *)lp;
		}
		for( ; i < SW_NLIGHTS; i++ )  {
			swp->sw_visible[i] = (char *)NULL;
		}
	}

	/* If optional inputs are required, have them computed */
	if( want & (MFI_HIT|MFI_NORMAL|MFI_LIGHT|MFI_UV) )  {
		VJOIN1( swp->sw_hit.hit_point, ap->a_ray.r_pt,
			swp->sw_hit.hit_dist, ap->a_ray.r_dir );
		swp->sw_inputs |= MFI_HIT;
	}
	if( (swp->sw_inputs & want) != want )  {
		shade_inputs( ap, pp, swp, want );
	} else if( !(want & MFI_LIGHT) )  {
		register int	i;

		/* sanity */
		for( i = SW_NLIGHTS-1; i >= 0; i-- )  {
			swp->sw_visible[i] = (char *)NULL;
		}
	}

	if( rdebug&RDEBUG_SHADE ) {
		pr_shadework( "before mf_render", swp );
	}


	/* Invoke the actual shader (may be a tree of them) */
	(void)mfp->mf_render( ap, pp, swp, rp->reg_udata );

	if( rdebug&RDEBUG_SHADE ) {
		pr_shadework( "after mf_render", swp );
		bu_log("\n");
	}

	return(1);
}



d58 1
a58 1
HIDDEN void
d180 121
@


11.27
log
@Added -Q flag to rt, misc compilation warning fixes
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.26 2000/07/25 16:39:48 butler Exp $ (BRL)";
@


11.26
log
@Many patches for warning-free compilation on Linux.
Moved rdebug.h to h/rtprivate.h
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.25 2000/02/11 20:22:14 butler Exp $ (BRL)";
d40 1
@


11.25
log
@Made perpendicular test a little more "tol" erant.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.24 2000/02/03 06:33:40 butler Exp $ (BRL)";
d38 1
a38 1
#include "./rdebug.h"
d250 1
a250 1
vdraw o norm;vdraw p c 00ffff;vdraw w n 0 %g %g %g;vdraw w n 1 %g %g %g;vdraw s\n",
@


11.24
log
@changes to support the new light visibility computations
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.23 2000/01/22 03:51:44 mike Exp $ (BRL)";
d223 3
a225 1
			if( (f=VDOT( ap->a_ray.r_dir, swp->sw_hit.hit_normal )) > 0 )  {
d227 6
a232 4
					pp->pt_inseg->seg_stp->st_name,
					ap->a_x, ap->a_y,
					rt_functab[pp->pt_inseg->seg_stp->st_id].ft_name,
					swp->sw_hit.hit_surfno, f);
@


11.23
log
@
Added additional error checking of magic numbers.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.22 1999/12/29 03:38:44 mike Exp $ (BRL)";
d287 1
a287 1
		light_visibility(ap, swp, have);
@


11.22
log
@
Improved debugging of shadework preparations.
Added note about Lee moving light_visibility() into the shaders.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.21 1999/12/18 02:13:45 mike Exp $ (BRL)";
d72 1
d187 2
@


11.21
log
@
Additional debugging
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.20 1999/11/24 22:16:07 mike Exp $ (BRL)";
d63 3
a65 3
	register struct mfuncs *mfp;
	register struct region *rp;
	register struct light_specific *lp;
d72 4
d77 1
a77 1
	swp->sw_hit = *(pp->pt_inhit);		/* struct copy */
d79 5
a83 8
	if( (mfp = (struct mfuncs *)pp->pt_regionp->reg_mfuncs) == MF_NULL )  {
		bu_log("viewshade:  reg_mfuncs NULL\n");
		return(0);
	}
	if( mfp->mf_magic != MF_MAGIC )  {
		bu_log("viewshade:  reg_mfuncs bad magic, %x != %x\n",
			mfp->mf_magic, MF_MAGIC );
		return(0);
d86 1
a86 2
	rp = pp->pt_regionp;
	RT_CK_REGION(rp);
a107 2
	want = mfp->mf_inputs;

a144 2
		bu_log("About to shade %s: using \"%s\" shader\n",
			rp->reg_name, mfp->mf_name);
d181 1
a181 1
register struct partition *pp;
d281 2
d308 1
a334 2
	bu_printb( " sw_inputs", swp->sw_inputs,
		"\020\4HIT\3LIGHT\2UV\1NORMAL" );
@


11.20
log
@
Removed obsolete include files
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.19 1999/10/30 03:53:05 mike Exp $ (BRL)";
d235 16
@


11.19
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.18 1999/10/30 03:06:27 butler Exp $ (BRL)";
a33 1
#include "rtlist.h"
@


11.18
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.17 1999/05/28 01:17:27 mike Exp $ (BRL)";
d71 2
@


11.17
log
@
sed4
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.16 1999/05/10 21:39:16 mike Exp $ (BRL)";
a39 1
#include "./mathtab.h"
@


11.16
log
@ma_override to ma_color_valid
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.15 1998/12/16 03:51:17 mike Exp $ (BRL)";
d76 1
a76 1
		rt_log("viewshade:  reg_mfuncs NULL\n");
d80 1
a80 1
		rt_log("viewshade:  reg_mfuncs bad magic, %x != %x\n",
d120 1
a120 1
		for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
d147 1
a147 1
		rt_log("About to shade %s: using \"%s\" shader\n",
d158 1
a158 1
		rt_log("\n");
d225 1
a225 1
				rt_log("shade_inputs(%s) flip N xy=%d,%d %s surf=%d dot=%g\n",
d249 1
a249 1
			rt_log("shade_inputs:  bad u,v=%e,%e du,dv=%g,%g seg=%s %s surf=%d. xy=%d,%d Making green.\n",
d278 1
a278 1
		rt_log("shade_inputs:  unable to satisfy request for x%x\n", want);
d293 1
a293 1
	rt_log( "Shadework %s: 0x%x\n", str, swp );
d295 1
a295 1
		rt_log( " sw_hit.dist:%g  sw_hit.point(%g %g %g)\n",
d299 1
a299 1
		rt_log( " sw_hit.dist:%g\n", swp->sw_hit.hit_dist);
d302 1
a302 1
		rt_log(" sw_hit.normal(%g %g %g)\n",
d306 4
a309 4
	rt_log( " sw_transmit %f\n", swp->sw_transmit );
	rt_log( " sw_reflect %f\n", swp->sw_reflect );
	rt_log( " sw_refract_index %f\n", swp->sw_refrac_index );
	rt_log( " sw_extinction %f\n", swp->sw_extinction );
d317 4
a320 4
	rt_log( " sw_uv  %f %f\n", swp->sw_uv.uv_u, swp->sw_uv.uv_v );
	rt_log( " sw_dudv  %f %f\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv );
	rt_log( " sw_xmitonly %d\n", swp->sw_xmitonly );
	rt_printb( " sw_inputs", swp->sw_inputs,
d322 1
a322 1
	rt_log( "\n");
d333 1
a333 1
		rt_log("   light %d visible, intensity=%g, dir=(%g,%g,%g)\n",
@


11.15
log
@rt_pr_tabdata() now bn_pr_tabdata()
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.14 1998/12/12 07:25:00 mike Exp $ (BRL)";
d92 1
a92 1
	if( rp->reg_mater.ma_override )  {
d98 1
a98 1
	if( rp->reg_mater.ma_override )  {
@


11.14
log
@Added some error checking.
Fixed bug in pr_shadework()
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.13 1998/12/11 22:53:21 mike Exp $ (BRL)";
d311 2
a312 2
	rt_pr_tabdata( "msw_color", swp->msw_color );
	rt_pr_tabdata( "msw_basecolor", swp->msw_basecolor );
d331 1
a331 1
		rt_pr_tabdata("light intensity", swp->msw_intensity[i] );
@


11.13
log
@Converted from rt_tabdata to bn_tabdata.

Added -!0100 flag to opt.c to allow setting of libbu debug bits from
command line.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.12 1998/12/10 08:42:54 mike Exp $ (BRL)";
d323 1
a323 1
	for( i=0; i < SW_NLIGHTS; i++ )  {
d325 1
a326 1
		BN_CK_TABDATA(swp->msw_intensity[i]);
d330 1
a331 1

@


11.12
log
@Initial multi-spectral support
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.11 1998/09/22 01:46:58 mike Exp $ (BRL)";
a37 3
#if RT_MULTISPECTRAL
# include "tabdata.h"
#endif
d90 2
a91 2
	RT_CK_TABDATA(swp->msw_color);
	RT_CK_TABDATA(swp->msw_basecolor);
d95 1
a95 1
	rt_tabdata_copy(swp->msw_basecolor, swp->msw_color);
d326 1
a326 1
		RT_CK_TABDATA(swp->msw_intensity[i]);
@


11.11
log
@Moved pr_shadework() from material.c to shade.c, where it belongs.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.10 1998/09/22 01:43:12 mike Exp $ (BRL)";
d38 3
d91 9
d105 1
d259 9
a267 1
			VSET( swp->sw_color, 0, 9, 0 );	/* Green */
d313 4
d319 1
d328 8
d340 1
@


11.10
log
@Moved sh_*.c shaders from rt/ to liboptical/ directory.
Moved and split rt/material.h into h/shadefuncs.h and h/shadework.h
Changed calling sequence of mlib_setup() to get shader list head explicitly.
Initialization of shader library is now via optical_shader_init().

Note that the "proper" location of shade.c, material.c, and refract.c
(presently in the rt/ directory) are a bit muddled, as they will be
shared with libmultispectral/ shader functions, but aren't quite
wholesome and pure yet.  To minimize impact to Lee's ongoing shader
developments, they haven't been changed.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /c/CVS/brlcad/rt/shade.c,v 11.9 1997/03/04 05:51:52 mike Exp $ (BRL)";
d263 11
d275 33
@


11.9
log
@Removed incorrect sanity initialization.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 11.8 1997/03/04 05:36:50 mike Exp mike $ (BRL)";
d36 2
a39 1
#include "./material.h"
a41 2

extern int	light_hit(), light_miss();	/* in light.c */
@


11.8
log
@Improved sanity code, making for cleaner prints of shadework structure.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 11.7 1997/02/26 21:25:52 mike Exp mike $ (BRL)";
a115 1
			swp->sw_intensity[i] = -1;
a132 1
			swp->sw_intensity[i] = -1;
@


11.7
log
@Enhanced error message
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 11.6 1996/08/14 03:45:35 butler Exp mike $ (BRL)";
d109 1
a109 3
		for( i = ap->a_rt_i->rti_nlights*3 - 1; i >= 0; i-- )
			swp->sw_intensity[i] = 1;

d115 4
d127 1
a127 1
	if( (swp->sw_inputs & want) != want )
d129 9
@


11.6
log
@checkpoint
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/shade.c,v 11.5 1996/05/09 03:26:33 butler Exp butler $ (BRL)";
d231 1
a231 1
			rt_log("shade_inputs:  bad u,v=%e,%e du,dv=%g,%g seg=%s %s surf=%d.  Making green.\n",
d236 2
a237 1
		    		pp->pt_inhit->hit_surfno );
@


11.5
log
@light visibility calcualtions moved to sh_light.c
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 11.4 1996/03/29 23:20:55 mike Exp butler $ (BRL)";
d133 1
@


11.4
log
@Changed from RT_HIT_NORM() to RT_HIT_NORMAL().
Now pt_inflip stuff is always handled correctly.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 11.3 1996/03/19 22:10:16 mike Exp mike $ (BRL)";
d145 4
a169 1
	register struct light_specific *lp;
d242 1
a242 100
		register int	i;
		register fastf_t *intensity, *tolight;
		register fastf_t f;
		struct application sub_ap;

		/*
		 *  Determine light visibility
		 */
		i = 0;
		intensity = swp->sw_intensity;
		tolight = swp->sw_tolight;
		for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lp);
			/* compute the light direction */
			if( lp->lt_infinite ) {
				/* Infinite lights are point sources, no fuzzy penumbra */
				VMOVE( tolight, lp->lt_vec );
			} else {
				/*
				 *  Dither light pos for penumbra by +/- 0.5 light radius;
				 *  this presently makes a cubical light source distribution.
				 */
				f = lp->lt_radius * 0.9;
				tolight[X] = lp->lt_pos[X] +
					rand_half(ap->a_resource->re_randptr)*f -
					swp->sw_hit.hit_point[X];
				tolight[Y] = lp->lt_pos[Y] +
					rand_half(ap->a_resource->re_randptr)*f -
					swp->sw_hit.hit_point[Y];
				tolight[Z] = lp->lt_pos[Z] +
					rand_half(ap->a_resource->re_randptr)*f -
					swp->sw_hit.hit_point[Z];
			}

			/*
			 *  If we have a normal, test against light direction
			 */
			if( (have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
				if( VDOT(swp->sw_hit.hit_normal,tolight) < 0 ) {
					/* backfacing, opaque */
					swp->sw_visible[i] = (char *)0;
					goto next;
				}
			}
			VUNITIZE( tolight );

			/*
			 * See if ray from hit point to light lies within light beam
			 * Note: this is should always be true for infinite lights!
			 */
			if( -VDOT(tolight, lp->lt_aim) < lp->lt_cosangle )  {
				/* dark (outside of light beam) */
				swp->sw_visible[i] = (char *)0;
				goto next;
			}
			if( !(lp->lt_shadows) )  {
				/* "fill light" in beam, don't care about shadows */
				swp->sw_visible[i] = (char *)lp;
				VSETALL( intensity, 1 );
				goto next;
			}

			/*
			 *  Fire ray at light source to check for shadowing.
			 *  (This SHOULD actually return an energy spectrum).
			 *  Advance start point slightly off surface.
			 */
			sub_ap = *ap;			/* struct copy */
			VMOVE( sub_ap.a_ray.r_dir, tolight );
			{
				register fastf_t f;
				f = ap->a_rt_i->rti_tol.dist;
				VJOIN1( sub_ap.a_ray.r_pt,
					swp->sw_hit.hit_point,
					f, tolight );
			}
			sub_ap.a_hit = light_hit;
			sub_ap.a_miss = light_miss;
			sub_ap.a_user = -1;		/* sanity */
			sub_ap.a_uptr = (genptr_t)lp;	/* so we can tell.. */
			sub_ap.a_level = 0;
			/* Will need entry & exit pts, for filter glass */
			sub_ap.a_onehit = 2;

			VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
			sub_ap.a_purpose = lp->lt_name;	/* name of light shot at */
			if( rt_shootray( &sub_ap ) )  {
				/* light visible */
				swp->sw_visible[i] = (char *)lp;
				VMOVE( intensity, sub_ap.a_color );
			} else {
				/* dark (light obscured) */
				swp->sw_visible[i] = (char *)0;
			}
next:
			/* Advance to next light */
			i++;
			intensity += 3;
			tolight += 3;
		}
d252 2
@


11.3
log
@Fixed normal flipping bug.
Occured only when multiple transparent regions subtracted same solid.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 11.2 1995/08/22 02:23:24 butler Exp mike $ (BRL)";
d151 1
a151 1
 *  RT_HIT_NORM() must be called if hit_norm is needed,
d190 1
a190 1
			RT_HIT_NORM( &(swp->sw_hit), pp->pt_inseg->seg_stp, &(ap->a_ray) );
a200 7
			if( pp->pt_inflip )  {
				VREVERSE( swp->sw_hit.hit_normal, swp->sw_hit.hit_normal );
				/* Don't modify pp->pt_inflip here, it's the original.
				 * swp->sw_hit is a copy, not the original hit;
				 */
			}

@


11.2
log
@more verbose debugging
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 11.1 1995/01/04 10:01:17 mike Rel4_4 butler $ (BRL)";
d203 3
a205 1
				pp->pt_inflip = 0;	/* shouldnt be needed now??? */
d208 1
a208 1
			/* Temporary check to make sure normals are OK */
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 10.7 94/11/05 03:09:49 mike Exp $ (BRL)";
d56 3
d129 2
a130 1
		rt_log("About to shade %s:\n", rp->reg_name);
@


10.7
log
@Oops, typo.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 10.6 94/11/05 02:50:52 mike Exp Locker: mike $ (BRL)";
@


10.6
log
@Irix 6, changed to a_uptr
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 10.5 94/08/11 02:43:36 gdurf Exp Locker: mike $ (BRL)";
d318 1
a318 1
			sub_ab.a_user = -1;		/* sanity */
@


10.5
log
@Added include of conf.h
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 10.4 1994/05/10 11:02:06 mike Exp gdurf $ (BRL)";
d318 2
a319 1
			sub_ap.a_user = (int)lp;	/* so we can tell.. */
@


10.4
log
@Improved bad u,v message.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 10.3 94/05/06 03:09:09 mike Exp Locker: mike $ (BRL)";
d26 2
@


10.3
log
@Extra checking on light pointers
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 10.2 94/05/05 23:39:31 mike Exp Locker: mike $ (BRL)";
d226 1
a226 1
			rt_log("shade_inputs:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
d229 3
a231 1
				pp->pt_inseg->seg_stp->st_name );
@


10.2
log
@Unkinked a very ugly line of C.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 10.1 91/10/12 06:42:14 mike Rel4_0 Locker: mike $ (BRL)";
d58 1
a58 1
register struct partition *pp;
d66 3
a79 4
	if( (rp=pp->pt_regionp) == REGION_NULL )  {
		rt_log("viewshade: bad region pointer\n");
		return(0);
	}
d81 3
d108 2
a109 1
		for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )
d111 1
d248 1
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 9.8 91/08/16 16:15:19 mike Exp $ (BRL)";
d243 1
a243 3
		for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ),
		    i++, intensity += 3, tolight += 3
		)  {
d246 1
a246 1
				/* XXX infinte lights need penumbras? */
d272 1
a272 1
					continue;
d284 1
a284 1
				continue;
d290 1
a290 1
				continue;
d324 5
@


9.8
log
@Oops, standoff distance was bogus
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 9.7 91/08/16 15:16:22 mike Exp $ (BRL)";
@


9.7
log
@Now explicitly set a_onehit to 2 for light visibility rays,
to ensure getting a valid out hit (required for filter glass,
and almost always a no-cost option), rather than using main ray's
value of a_onehit, which might have been 0 (expensive!) or 1 (wrong!).

Added ray advance distance of rti_tol.dist up off surface, when
shooting light visibility rays.
This is necessary (at least) for viewing the Utah Teapot with
explicit lights.  It is unclear just how much the ray really should
be advanced.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 9.6 90/11/10 19:36:31 mike Exp $ (BRL)";
d304 1
a304 1
				f = pp->pt_inhit->hit_dist + ap->a_rt_i->rti_tol.dist;
@


9.6
log
@Modified light_specific structure to use rtlist.h macros.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 9.5 90/11/01 11:17:34 mike Exp $ (BRL)";
d297 2
a298 1
			 *  (This SHOULD actually return an energy value)
d302 7
a308 1
			VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
d313 2
@


9.5
log
@Added more debugging.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 9.4 90/11/01 06:53:21 mike Exp $ (BRL)";
d32 1
a41 2
extern struct light_specific	*LightHeadp;

d105 3
a107 2
		for( i=0, lp=LightHeadp; lp; lp = lp->lt_forw, i++ )
			swp->sw_visible[i] = (char *)lp;
d240 5
a244 3
		for( i=0, lp=LightHeadp, intensity = swp->sw_intensity, tolight = swp->sw_tolight;
			lp;
			lp = lp->lt_forw, i++, intensity += 3, tolight += 3
d270 1
a270 1
			if( (have & MFI_NORMAL) && (swp->sw_transmit == 0) )  {
@


9.4
log
@Improved error message.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 9.3 90/10/15 12:09:09 mike Exp $ (BRL)";
d120 1
d126 5
@


9.3
log
@Added surface number to "flipping normals" message.
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: /m/cad/rt/RCS/shade.c,v 9.2 90/04/12 02:14:29 mike Exp $ (BRL)";
d192 1
a192 1
				rt_log("shade_inputs(%s) flipped normal xy=%d,%d surf=%d dot=%g\n",
d195 1
d197 4
a200 2
				VPRINT("Dir ", ap->a_ray.r_dir);
				VPRINT("Norm", swp->sw_hit.hit_normal);
@


9.2
log
@Changed to using macro wrapper RT_HIT_UVCOORD
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: shade.c,v 9.1 89/05/19 05:59:48 mike Locked $ (BRL)";
d192 2
a193 1
				rt_log("shade_inputs: flipped normal %d %d %s dot=%g\n",
d195 1
a195 1
					pp->pt_inseg->seg_stp->st_name, f);
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: shade.c,v 1.1 89/05/19 03:20:29 mike Exp $ (BRL)";
d137 1
a137 1
 *  ft_uv() routines must have hit_point computed
d207 1
a207 2
			rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
				ap, pp->pt_inseg->seg_stp,
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSview[] = "@@(#)$Header: view.c,v 8.16 89/05/19 03:08:59 mike Locked $ (BRL)";
@
