head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.18.05.40;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.51.19;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.53;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.55.06;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2000.09.01.19.12.56;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	98.09.14.15.59.16;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.04.21;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.10.23.33.56;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.00.15.52;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.51;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.07.22.20.11.24;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.07.02.01.22.22;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.08.05.33.53;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.11.24.00.42.12;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.50.34;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.14.08.15.46;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.23.19.07.03;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.29.17;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.09.17.06.57.54;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.05.13.22.52.27;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.30.33;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.53.32;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.08.32;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.04.11.00.02.03;	author phil;	state Exp;
branches;
next	4.3;

4.3
date	87.02.12.22.09.53;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.04.26.44;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.50.17;	author mike;	state Rel1;
branches;
next	1.20;

1.20
date	86.12.20.07.45.23;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	86.11.14.22.10.00;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	86.10.27.04.37.16;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	86.10.03.06.30.53;	author phil;	state Exp;
branches;
next	1.16;

1.16
date	86.10.03.02.09.42;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.08.13.10.30.27;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.08.13.10.30.05;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.08.13.10.29.45;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.08.13.10.29.30;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.08.13.10.29.14;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.08.13.10.29.01;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.08.13.10.28.44;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.08.13.10.28.25;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.10.28.08;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.13.10.27.52;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.13.10.27.39;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.13.10.27.26;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.13.10.27.14;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.08.13.10.26.59;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.10.26.51;	author mike;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.01.28;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.8
log
@moved from top-level to src/other/.
@
text
@/*
 *			L I B R L E . C
 *
 *  These routines are appropriate for RLE encoding a framebuffer image
 *  from a program.
 *  This library is derived from 'ik-rle' code authored by :
 *	Mike Muuss, BRL.  10/18/83.
 *	[With a heavy debt to Spencer Thomas, U. of Utah,
 *	 for the RLE file format].
 *
 *  Author -
 *	Gary S. Moss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liborle/rle.c,v 11.7 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "orle.h"

#define PRNT_A1_DEBUG(_op,_n) \
	if(rle_debug) (void)fprintf(stderr,"%s(%d)\n",_op,_n)
#define PRNT_A2_DEBUG(_op,_n,_c) \
	if(rle_debug) (void)fprintf(stderr,"%s(%ld,%d)\n",_op,(long)(_n),_c)
#define CUR	RED		/* Must be rightmost part of Pixel.		*/

/*	States for run detection					*/
#define	DATA	0
#define	RUN2	1
#define	INRUN	2
#define UPPER 255			/* anything bigger ain't a byte */

/* An addition to the STDIO suite, to avoid using fwrite() for
	writing 2 bytes of data.
 */
#define putshort(s) \
	{register short v = s; \
	(void) putc( v & 0xFF, fp ); (void) putc( (v>>8) & 0xFF, fp );}

/* short instructions */
#define mk_short_1(oper,a1)		/* one argument short */ \
	{(void) putc( oper, fp ); (void) putc( a1, fp );}

#define mk_short_2(oper,a1,a2)		/* two argument short */ \
	{(void) putc( oper, fp ); (void) putc( a1, fp ); putshort( a2 )}

/* long instructions */
#define mk_long_1(oper,a1)		/* one argument long */ \
	{(void) putc( LONG|oper, fp ); (void) putc( 0, fp ); putshort( a1 )}

#define mk_long_2(oper,a1,a2)		/* two argument long */ \
	{(void) putc( LONG|oper, fp ); (void) putc( 0, fp ); putshort( a1 )\
		putshort( a2 )}

/* Choose between long and short format instructions.			*/
#define mk_inst_1(oper,a1)    /* one argument inst */ \
	{if( a1 > UPPER ) mk_long_1(oper,a1) else mk_short_1(oper,a1)}

#define mk_inst_2(oper,a1,a2) /* two argument inst */ \
	{if( a1 > UPPER ) mk_long_2(oper,a1,a2)	else mk_short_2(oper,a1,a2)}

/* Skip one or more blank lines in the RLE file.			*/
#define SkipBlankLines(nblank)	RSkipLines(nblank)

/* Select a color and do "carriage return" to start of scanline.
	color: 0 = Red, 1 = Green, 2 = Blue.
 */
#define SetColor(c)		RSetColor( _bw_flag ? 0 : c )

/* Skip a run of background.						*/
#define SkipPixels(nskip)	if( (nskip) > 0 ) RSkipPixels(nskip)

/* Output an enumerated set of intensities for current color channel.	*/
#define PutRun(color, num)	RRunData(num-1,color)

/* Opcode definitions.							*/
#define	RSkipLines(_n) \
	{PRNT_A1_DEBUG("Skip-Lines",_n); mk_inst_1(RSkipLinesOp,(_n))}

#define	RSetColor(_c) \
	{PRNT_A1_DEBUG("Set-Color",_c); mk_short_1(RSetColorOp,(_c))}

#define	RSkipPixels(_n) \
	{PRNT_A1_DEBUG("Skip-Pixels",_n); mk_inst_1(RSkipPixelsOp,(_n))}

#define	RByteData(_n) \
	{PRNT_A1_DEBUG("Byte-Data",_n); mk_inst_1(RByteDataOp,_n)}

#define	RRunData(_n,_c) \
	{PRNT_A2_DEBUG("Run-Data",_n,_c); mk_inst_2(RRunDataOp,(_n),(_c))}

#define NSEG	1024/3		/* Number of run segments of storage */
static struct runs
	{
	RGBpixel *first;
	RGBpixel *last;
	} runs[NSEG];		/* ptrs to non-background run segs */

/* Global data.								*/
int	_bg_flag;
int	_bw_flag;
int	_cm_flag;
RGBpixel	_bg_pixel;

int	_ncmap = 3;	/* Default : (3) channels in color map.		*/
int	_cmaplen = 8;	/* Default : (8) log base 2 entries in map.	*/
int	_pixelbits = 8;	/* Default : (8) bits per pixel.		*/
int	rle_debug = 0;
int	rle_verbose = 0;

#undef HIDDEN
#define HIDDEN static
HIDDEN void	_put_Data(register FILE *fp, register unsigned char *cp, int n);
HIDDEN int	_put_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg);
HIDDEN int	_put_Std_Map(FILE *fp);
HIDDEN int	_get_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg);

/* Functions to read instructions, depending on format.			*/
HIDDEN int	(*_func_Get_Inst)();	/* Ptr to appropriate function.	*/
HIDDEN int	_get_Old_Inst(register FILE *fp, register int *op, register int *dat);	/* Old format inst. reader.	*/
HIDDEN int	_get_New_Inst(register FILE *fp, register int *opcode, register int *datum);	/* New extended inst. reader.	*/
HIDDEN void	_enc_Color_Seg(FILE *fp, register int seg, register int color);
HIDDEN void	_enc_Segment(FILE *fp, register RGBpixel (*data_p), register RGBpixel (*last_p));
HIDDEN int	_bg_Get_Runs(register RGBpixel (*pixelp), register RGBpixel (*endpix));

void		prnt_XSetup(char *msg, register Xtnd_Rle_Header *setup);

static Xtnd_Rle_Header	w_setup;	/* Header being written out.	*/
static Xtnd_Rle_Header	r_setup;	/* Header being read in.	*/

void
rle_rlen(int *xlen, int *ylen)
{
	*xlen = r_setup.h_xlen;
	*ylen = r_setup.h_ylen;
	}

void
rle_wlen(int xlen, int ylen, int mode)
{
	if( mode == 0 )		/* Read mode.				*/
		{
		r_setup.h_xlen = xlen;
		r_setup.h_ylen = ylen;
		}
	else			/* Write mode.				*/
		{
		w_setup.h_xlen = xlen;
		w_setup.h_ylen = ylen;
		}
	return;
	}

void
rle_rpos(int *xpos, int *ypos)
{
	*xpos = r_setup.h_xpos;
	*ypos = r_setup.h_ypos;
	}

void
rle_wpos(int xpos, int ypos, int mode)
{
	if( mode == 0 )		/* Read mode.				*/
		{
		r_setup.h_xpos = xpos;
		r_setup.h_ypos = ypos;
		}
	else			/* Write mode.				*/
		{
		w_setup.h_xpos = xpos;
		w_setup.h_ypos = ypos;
		}
	return;
	}

/*	r l e _ r h d r ( )
	This routine should be called before 'rle_decode_ln()' or 'rle_rmap()'
	to position the file pointer correctily and set up the global flags
	_bw_flag and _cm_flag, and to fill in _bg_pixel if necessary, and
	to pass information back to the caller in flags and bgpixel.

	Returns -1 for failure, 0 otherwise.
 */
int
rle_rhdr(FILE *fp, int *flags, register unsigned char *bgpixel)
{
	static short	x_magic;
	static char	*verbage[] =
		{
		"Frame buffer image saved in Old Run Length Encoded form\n",
		"Frame buffer image saved in Old B&W RLE form\n",
		"File not in RLE format, can't display (magic=0x%x)\n",
		"Saved with background color %d %d %d\n",
		"Saved in overlay mode\n",
		"Saved as a straight box image\n",
		NULL
		};

	if( fp != stdin && fseek( fp, 0L, 0 ) == -1 )
		{
		(void) fprintf( stderr, "Seek to RLE header failed!\n" );
		return	-1;
		}
	if( fread( (char *)&x_magic, sizeof(short), 1, fp ) != 1 )
		{
		(void) fprintf( stderr, "Read of magic word failed!\n" );
		return	-1;
		}
	SWAB( x_magic );
	if( x_magic != XtndRMAGIC )
		{ Old_Rle_Header	setup;
		if( fread( (char *) &setup, sizeof(setup), 1, fp ) != 1 )
			{
			(void) fprintf( stderr,
					"Read of Old RLE header failed!\n"
					);
			return	-1;
			}
		SWAB( setup.xpos );
		SWAB( setup.ypos );
		SWAB( setup.xsize );
		SWAB( setup.ysize );
		r_setup.h_xpos = setup.xpos;
		r_setup.h_ypos = setup.ypos;
		r_setup.h_xlen = setup.xsize;
		r_setup.h_ylen = setup.ysize;
		switch( x_magic & ~0xff) {
		case RMAGIC :
			if( rle_verbose )
				(void) fprintf( stderr,	verbage[0] );
			r_setup.h_ncolors = 3;
			break;
		case WMAGIC :
			if( rle_verbose )
				(void) fprintf( stderr, verbage[1] );
			r_setup.h_ncolors = 1;
			break;
		default:
			(void) fprintf(	stderr, verbage[2], x_magic & ~0xff);
			return	-1;
		} /* End switch */
		switch( x_magic & 0xFF ) {
		case 'B' : /* Background given.				*/
			r_setup.h_flags = H_CLEARFIRST;
			r_setup.h_background[0] = setup.bg_r;
			r_setup.h_background[1] = setup.bg_g;
			r_setup.h_background[2] = setup.bg_b;
			break;
		default: /* Straight 'box' save.			*/
			r_setup.h_flags = H_BOXSAVE;
			r_setup.h_background[0] = 0;
			r_setup.h_background[1] = 0;
			r_setup.h_background[2] = 0;
			if( rle_verbose )
				(void) fprintf( stderr, verbage[5] );
			break;
		} /* End switch */
		r_setup.h_pixelbits = 8;
		r_setup.h_ncmap = setup.map ? 3 : 0;
		r_setup.h_cmaplen = 8;
		_func_Get_Inst = _get_Old_Inst;
		} /* End if */
	else
		{
		if( fread( (char *)&r_setup, sizeof(Xtnd_Rle_Header), 1, fp )
		    != 1
			)
			{
			(void) fprintf( stderr,
					"Read of RLE header failed!\n"
					);
			return	-1;
			}
		SWAB( r_setup.h_xpos );
		SWAB( r_setup.h_ypos );
		SWAB( r_setup.h_xlen );
		SWAB( r_setup.h_ylen );
		_func_Get_Inst = _get_New_Inst;
		}
	if( rle_verbose )
		(void) fprintf( stderr,
				"Positioned at (%d, %d), size (%d %d)\n",
				r_setup.h_xpos,
				r_setup.h_ypos,
				r_setup.h_xlen,
				r_setup.h_ylen
				);
	if( r_setup.h_flags == H_CLEARFIRST )
		{
		if( rle_verbose )
			(void) fprintf( stderr,
					verbage[3],
					r_setup.h_background[0],
					r_setup.h_background[1],
					r_setup.h_background[2]
					);
		if( bgpixel != RGBPIXEL_NULL )
			{
			/* No command-line backgr., use saved values.	*/
			_bg_pixel[RED] = r_setup.h_background[0];
			_bg_pixel[GRN] = r_setup.h_background[1];
			_bg_pixel[BLU] = r_setup.h_background[2];
			COPYRGB( bgpixel, _bg_pixel );
			}
		}
	_bw_flag = r_setup.h_ncolors == 1;
	if( r_setup.h_flags & H_CLEARFIRST )
		*flags = NO_BOX_SAVE;
	else
		*flags = 0;
	if( r_setup.h_ncmap == 0 )
		*flags |= NO_COLORMAP;
	if( r_setup.h_ncolors == 0 )
		*flags |= NO_IMAGE;
	if( rle_debug )
		{
		(void) fprintf( stderr, "Magic=0x%x\n", x_magic );
		prnt_XSetup( "Setup structure read", &r_setup );
		}
	return	0;
	}

/*	r l e _ w h d r ( )
 	This routine should be called after 'setfbsize()', unless the
	framebuffer image is the default size (512).
	This routine should be called before 'rle_encode_ln()' to set up
	the global data: _bg_flag, _bw_flag, _cm_flag, and _bg_pixel.
	Returns -1 for failure, 0 otherwise.
 */
int
rle_whdr(FILE *fp, int ncolors, int bgflag, int cmflag, unsigned char *bgpixel)
{
	/* Magic numbers for output file.				*/
	static short	x_magic = XtndRMAGIC; /* Extended magic number.	*/
	static RGBpixel	black = { 0, 0, 0 };

	/* safty check */
	if( bgpixel == NULL )
		bgpixel = black;

	/* If black and white mode, compute NTSC value of background.	*/
	if( ncolors == 1 )
		{
		register int	bbw;
		if( rle_verbose )
			(void) fprintf( stderr,
					"Image being saved as monochrome.\n"
					);
		bbw = 0.35 * bgpixel[RED] +
			0.55 * bgpixel[GRN] +
			0.10 * bgpixel[BLU];
		w_setup.h_background[0] = bbw;
		w_setup.h_background[1] = bbw;
		w_setup.h_background[2] = bbw;
		} else {
		w_setup.h_background[0] = bgpixel[RED];
		w_setup.h_background[1] = bgpixel[GRN];
		w_setup.h_background[2] = bgpixel[BLU];
		}
	w_setup.h_flags = bgflag ? H_CLEARFIRST : 0;
	w_setup.h_ncolors = ncolors;
	w_setup.h_pixelbits = _pixelbits;
	w_setup.h_ncmap = cmflag ? _ncmap : 0;
	w_setup.h_cmaplen = _cmaplen;

	if( fp != stdout && fseek( fp, 0L, 0 ) == -1 )
		{
		(void) fprintf( stderr, "Seek to RLE header failed!\n" );
		return	-1;
		}
	SWAB( x_magic );
	if( fwrite( (char *) &x_magic, sizeof(short), 1, fp ) != 1 )
		{
		(void) fprintf( stderr, "Write of magic number failed!\n" );
		return	-1;
		}
	SWAB( w_setup.h_xpos );
	SWAB( w_setup.h_ypos );
	SWAB( w_setup.h_xlen );
	SWAB( w_setup.h_ylen );
	if( fwrite( (char *) &w_setup, sizeof w_setup, 1, fp ) != 1 )
		{
		(void) fprintf( stderr, "Write of RLE header failed!\n" );
		return	-1;
		}
	SWAB( w_setup.h_xpos );
	SWAB( w_setup.h_ypos );
	SWAB( w_setup.h_xlen );
	SWAB( w_setup.h_ylen );
	if( rle_debug )
		{
		(void) fprintf( stderr, "Magic=0x%x\n", x_magic );
		prnt_XSetup( "Setup structure written", &w_setup );
		}
	_bg_flag = bgflag;
	_bw_flag = ncolors == 1;
	_cm_flag = cmflag;
	COPYRGB(_bg_pixel, bgpixel);
	return	0;
	}

/*	r l e _ r m a p ( )
	Read a color map in RLE format.
	Returns -1 upon failure, 0 otherwise.
 */
int
rle_rmap(FILE *fp, ColorMap *cmap)
{
	if( rle_verbose )
		(void) fprintf( stderr, "Reading color map\n");
	if(	_get_Color_Map_Seg( fp, cmap->cm_red ) == -1
	     ||	_get_Color_Map_Seg( fp, cmap->cm_green ) == -1
	     ||	_get_Color_Map_Seg( fp, cmap->cm_blue ) == -1
		)
		return	-1;
	else
		return	0;
	}

/*	r l e _ w m a p ( )
	Write a color map in RLE format.
	Returns -1 upon failure, 0 otherwise.
 */
int
rle_wmap(FILE *fp, ColorMap *cmap)
{
	if( w_setup.h_ncmap == 0 )
		{
		(void) fprintf( stderr,
		"Writing color map conflicts with header information!\n"
				);
		(void) fprintf( stderr,
				"rle_whdr(arg 2 == 0) No map written.\n"
				);
		return	-1;
		}
	if( rle_verbose )
		(void) fprintf( stderr, "Writing color map\n" );
	if( cmap == (ColorMap *) NULL )
		{
		return _put_Std_Map( fp );
		}		
	if(	_put_Color_Map_Seg( fp, cmap->cm_red ) == -1
	     ||	_put_Color_Map_Seg( fp, cmap->cm_green ) == -1
	     ||	_put_Color_Map_Seg( fp, cmap->cm_blue ) == -1
		)
		return	-1;
	else
		return	0;
	}

/*	r l e _ d e c o d e _ l n ( )
	Decode one scanline into 'scan_buf'.
	Buffer is assumed to be filled with background color.
	Returns -1 on failure, 1 if buffer is altered
	and 0 if untouched.
 */
int
rle_decode_ln(register FILE *fp, RGBpixel (*scan_buf))
{	static int	lines_to_skip = 0;
		static int	opcode, datum;
		static short	word;

		register int	n;
		register unsigned char	*pp;
		register int	dirty_flag = 0;

	if( lines_to_skip > 0 )
		{
		lines_to_skip--;
		return	dirty_flag;
		}
	pp = &(scan_buf[r_setup.h_xpos][RED]); /* Pointer into pixel. */
	while( (*_func_Get_Inst)( fp, &opcode, &datum ) != EOF )
		{
		switch( opcode )
			{
		case RSkipLinesOp :
			lines_to_skip = datum;
			PRNT_A1_DEBUG( "Skip-Lines", lines_to_skip );
			if( lines_to_skip-- < 1 )
				return	-1;
			return	dirty_flag;
		case RSetColorOp:
			/* Select "color channel" that following ops go to.
				Set `pp' to point to starting pixel element;
		 		by adding STRIDE to pp, will move to
				corresponding color element in next pixel.
				If Black & White image:  point to left-most
				byte (Red for Ikonas) in long, and Run and
				Data will ignore strides below.
		 	*/
			PRNT_A1_DEBUG( "Set-Color", datum );
			if( (n = _bw_flag ? 0 : datum) > 2 )
				{
				(void) fprintf( stderr,	"Bad color %d\n", n );
				if( ! rle_debug )
					return	-1;
				}
			pp = &(scan_buf[r_setup.h_xpos][n]);
			break;
		case RSkipPixelsOp: /* advance pixel ptr */
			n = datum;
			PRNT_A1_DEBUG( "Skip-Pixels", n );
			pp += n * STRIDE;
			break;
		case RByteDataOp:
			n = datum + 1;
			PRNT_A1_DEBUG( "Byte-Data", n );
			if( ! _bw_flag )
				{
#if 0
				/*
				 * This is the most common region of code.
				 * The STDIO getc() macro is actually quite
				 * expensive.  We utilize our knowledge of
				 * the bulk nature of this copy and the
				 * STDIO internals (sorry) to improve speed.
				 */
				if( fp->_cnt >= n )
					{ register unsigned char *cp = (unsigned char *)fp->_ptr;
					fp->_cnt -= n;
					while( n-- > 0 )
						{
						*pp = *cp++;
						pp += STRIDE;
						}
#if defined(BSD) && ! defined(sun)
					fp->_ptr = (char *)cp;
#else
					fp->_ptr = cp;
#endif
					}
				else
#endif
				while( n-- > 0 )
					{
					*pp = getc(fp);
					pp += STRIDE;
					}
				}
			else
				{ /* Ugh, black & white.		*/
				register unsigned char c;
				while( n-- > 0 )
					{
					/* Implicit knowledge of sizeof(RGBpixel) */
					*pp++ = c = getc( fp );
					*pp++ = c;
					*pp++ = c;
					}
				}
			if( (datum + 1) & 1 )
				{ /* word align file ptr		*/
				(void) getc( fp );
				}
			dirty_flag = 1;
			break;
		case RRunDataOp:
			n = datum + 1;
			{ register char *p = (char *) &word;
			*p++ = getc( fp );
			*p++ = getc( fp );
			SWAB( word );
			}
			PRNT_A2_DEBUG( "Run-Data", (long)n,	word );
			if( ! _bw_flag )
				{
				register unsigned char inten = (unsigned char)word;
				while( n-- > 0 )
					{
					*pp = inten;
					pp += STRIDE;
					}
				}
			else
				{ /* Ugh, black & white.		*/
				while( n-- > 0 )
					{
					/* Implicit knowledge of sizeof(RGBpixel) */
					*pp++ = (unsigned char) word;
					*pp++ = (unsigned char) word;
					*pp++ = (unsigned char) word;
					}
				}
			dirty_flag = 1;
			break;
		default:
			(void) fprintf( stderr,
					"Unrecognized opcode: %d (x%x x%x)\n",
					opcode, opcode, datum
					);
			if( ! rle_debug )
				return	-1;
			}
		}
	return	dirty_flag;
	}

/* 	r l e _ e n c o d e _ l n ( )
	Encode a given scanline of pixels into RLE format.
	Returns -1 upon failure, 0 otherwise.
 */
int
rle_encode_ln(register FILE *fp, RGBpixel (*scan_buf))
{	register RGBpixel *scan_p;
		register RGBpixel *last_p;
		register int	i;
		register int	color;		/* holds current color */
		register int	nseg;		/* number of non-bg run segments */

	scan_p = (RGBpixel *)&(scan_buf[w_setup.h_xpos][RED]);
	last_p = (RGBpixel *)&(scan_buf[w_setup.h_xpos+(w_setup.h_xlen-1)][RED]);
	if( _bg_flag )
		{
		if( (nseg = _bg_Get_Runs( scan_p, last_p )) == -1 )
			return	-1;
		if( nseg <= 0 )
			{
			RSkipLines( 1 );
			return	0;
			}
		}
	else
		{
		runs[0].first = scan_p;
		runs[0].last = last_p;
		nseg = 1;
		}
	if( _bw_flag )
		{	register RGBpixel *pixelp;
		/* Compute NTSC Black & White in blue row.		*/
		for( pixelp=scan_p; pixelp <= last_p; pixelp++ )
			(*pixelp)[BLU] =  .35 * (*pixelp)[RED] +
					.55 * (*pixelp)[GRN] +
					.10 * (*pixelp)[BLU];
		}

	/* do all 3 colors */
	for( color = 0; color < 3; color++ )
		{
		if( _bw_flag && color != 2 )
			continue;
		SetColor( color );
		if( runs[0].first != scan_p )
			{	register int	runlen = runs[0].first-scan_p;
			SkipPixels( runlen );
			}
		for( i = 0; i < nseg; i++ )
			{	register int	runlen = (runs[i+1].first-1) -
							 runs[i].last;
			_enc_Color_Seg( fp, i, color );
			/* Move along to next segment for encoding,
				if this was not the last segment.
			 */
			if( i < nseg-1 )
				SkipPixels( runlen );
			}
		}
	RSkipLines(1);
	return	0;
	}

/*	_ b g _ G e t _ R u n s ( )
	Fill the 'runs' segment array from 'pixelp' to 'endpix'.
	This routine will fail and return -1 if the array fills up
	before all pixels are processed, otherwise a 'nseg' is returned.
 */
HIDDEN int
_bg_Get_Runs(register RGBpixel (*pixelp), register RGBpixel (*endpix))
{	/* find non-background runs */
		register int	nseg = 0;
	while( pixelp <= endpix && nseg < NSEG )
		{
		if(	(*pixelp)[RED] != _bg_pixel[RED]
		    ||	(*pixelp)[GRN] != _bg_pixel[GRN]
		    ||	(*pixelp)[BLU] != _bg_pixel[BLU]
			)
			{
			/* We have found the start of a segment */
			runs[nseg].first = pixelp++;

			/* find the end of this run */
			while(	pixelp <= endpix
			    &&	 (	(*pixelp)[RED] != _bg_pixel[RED]
				   ||	(*pixelp)[GRN] != _bg_pixel[GRN]
				   ||	(*pixelp)[BLU] != _bg_pixel[BLU]
		    		 )
				)
				pixelp++;
			/* last pixel in segment */
			runs[nseg++].last = pixelp-1;
			}
		pixelp++;
		}
	if( nseg >= NSEG )
		{
		(void) fprintf( stderr,
		"Encoding incomplete, segment array 'runs[%d]' is full!\n",
				NSEG
				);
		return	-1;
		}
	return	nseg;
	}

/*	_ e n c _ C o l o r _ S e g ( )
	Encode a segment, 'seg', for specified 'color'.
 */
HIDDEN void
_enc_Color_Seg(FILE *fp, register int seg, register int color)
{	static RGBpixel *data_p;
		static RGBpixel *last_p;

	data_p = (RGBpixel *) &((*(runs[seg].first))[color]);
	last_p = (RGBpixel *) &((*(runs[seg].last))[color]);

	_enc_Segment( fp, data_p, last_p );
	return;
	}

/*	_ e n c _ S e g m e n t ( )
	Output code for segment.
 */
HIDDEN void
_enc_Segment(FILE *fp, register RGBpixel (*data_p), register RGBpixel (*last_p))
{	register RGBpixel	*pixelp;
		register RGBpixel	*runs_p = data_p;
		register int	state = DATA;
		register unsigned char	runval = (*data_p)[CUR];
	for( pixelp = data_p + 1; pixelp <= last_p; pixelp++ )
		{
		switch( state )
			{
		case DATA :
			if( runval == (*pixelp)[CUR] )
				/* 2 in a row, may be a run.		*/
				state = RUN2;
			else
				{
				/* Continue accumulating data, look for a
					new run starting here, too
				 */
				runval = (*pixelp)[CUR];
				runs_p = pixelp;
				}
			break;
		case RUN2:
			if( runval == (*pixelp)[CUR] )
				{
				/* 3 in a row is a run.			*/
				state = INRUN;
				/* Flush out data sequence encountered
					before this run
				 */
				if( runs_p > data_p )
					_put_Data(	fp,
							&((*data_p)[CUR]),
						 	runs_p-data_p
						 	);
				}
			else
				{ /* Not a run, but maybe this starts one. */
				state = DATA;
				runval = (*pixelp)[CUR];
				runs_p = pixelp;
				}
			break;
		case INRUN:
			if( runval != (*pixelp)[CUR] )
				{
				/* If run out				*/
				state = DATA;
				PutRun(	runval,	pixelp - runs_p );
				/* who knows, might be more */
				runval = (*pixelp)[CUR];
				runs_p = pixelp;
				/* starting new 'data' run */
				data_p = pixelp;
				}
			break;
			} /* end switch */
		} /* end for */
		/* Write out last portion of section being encoded.	*/
		if( state == INRUN )
			{
			PutRun( runval, pixelp - runs_p );
			}
		else
		if( pixelp > data_p )
			_put_Data( fp, &(*data_p)[CUR], pixelp - data_p );
	return;
	}

/*	_ p u t _ D a t a ( )
	Put one or more pixels of byte data into the output file.
 */
HIDDEN void
_put_Data(register FILE *fp, register unsigned char *cp, int n)
{	register int	count = n;
	RByteData(n-1);

#if 0
	/* More STDIO optimization, watch out...			*/
	if( fp->_cnt >= count )
		{ register unsigned char *op = (unsigned char *)fp->_ptr;
		fp->_cnt -= count;
		while( count-- > 0 )
			{
			*op++ = *cp;
			cp += STRIDE;
			}
#if defined(BSD) && ! defined(sun)
		fp->_ptr = (char *)op;
#else
		fp->_ptr = op;
#endif
		}
	else
#endif
	while( count-- > 0 )
		{
		(void) putc( (int) *cp, fp );
		cp += STRIDE;
		}
	if( n & 1 )
		(void) putc( 0, fp );	/* short align output */
	return;
	}

/*	_ g e t _ C o l o r _ M a p _ S e g ( )
	Read the color map stored in the RLE file.
	The RLE format stores color map entries as short integers
	RIGHT justified in the word, while libfb expects color
	maps to be LEFT justified within a short.
 */
HIDDEN int
_get_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg)
{	static unsigned short	rle_cmap[256];
		register unsigned short	*cm = rle_cmap;
		register int	i;
	if( fread( (char *) rle_cmap, sizeof(rle_cmap), 1, fp ) != 1 )
		{
		(void) fprintf( stderr,	"Failed to read color map!\n" );
		return	-1;
		}
	for( i = 0; i < 256; i++, cm++ )
		{
		SWAB( *cm );
		*cmap_seg++ = (*cm) << 8;
		}
	return	0;
	}

/*	_ p u t _ C o l o r _ M a p _ S e g ( )
	Output color map segment to RLE file as shorts.  See above.
 */
HIDDEN int
_put_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg)
{	static unsigned short	rle_cmap[256];
		register unsigned short	*cm = rle_cmap;
		register int	i;
	for( i = 0; i < 256; i++, cm++ )
		{
		*cm = *cmap_seg++ >> 8;
		SWAB( *cm );
		}
	if( fwrite( (char *) rle_cmap, sizeof(rle_cmap), 1, fp ) != 1 )
		{
		(void) fprintf(	stderr,
				"Write of color map segment failed!\n"
				);
		return	-1;
		}
	return	0;
	}

/*	_ p u t _ S t d _ M a p ( )
	Output standard color map to RLE file as shorts.
 */
HIDDEN int
_put_Std_Map(FILE *fp)
{	static unsigned short	rle_cmap[256*3];
		register unsigned short	*cm = rle_cmap;
		register int	i, segment;
	for( segment = 0; segment < 3; segment++ )
		for( i = 0; i < 256; i++, cm++ )
			{
			*cm = i;
			SWAB( *cm );
			}
	if( fwrite( (char *) rle_cmap, sizeof(rle_cmap), 1, fp ) != 1 )
		{
		(void) fprintf(	stderr,
				"Write of standard color map failed!\n"
				);
		return	-1;
		}
	return	0;
	}

HIDDEN int
_get_New_Inst(register FILE *fp, register int *opcode, register int *datum)
{
	static short	long_data;

	*opcode = getc( fp );
	*datum = getc( fp );
	if( *opcode & LONG )
		{ register char	*p = (char *) &long_data;
		*opcode &= ~LONG;
		*p++ = getc( fp );
		*p++ = getc( fp );
		SWAB( long_data );
		*datum = long_data;
		}
	if( feof( fp ) )
		return	EOF;
	return	1;
	}

HIDDEN int
_get_Old_Inst(register FILE *fp, register int *op, register int *dat)
{
	static Old_Inst	instruction;
	register char	*p;

	p = (char *) &instruction;

	*p++ = getc( fp );
	*p++ = getc( fp );
 	SWAB( *((short *)&instruction) );
	if( feof( fp ) )
		return	EOF;
#ifndef CRAY
	/* These only work on machines where sizeof(short) == 2 */
	*op = instruction.opcode;
	*dat = instruction.datum;
#endif
	return	1;
	}
	
void
prnt_XSetup(char *msg, register Xtnd_Rle_Header *setup)
{
	(void) fprintf( stderr, "%s : \n", msg );
	(void) fprintf( stderr,
			"\th_xpos=%d, h_ypos=%d\n\th_xlen=%d, h_ylen=%d\n",
			setup->h_xpos, setup->h_ypos,
			setup->h_xlen, setup->h_ylen
			);
	(void) fprintf( stderr,
			"\th_flags=0x%x\n\th_ncolors=%d\n\th_pixelbits=%d\n",
			setup->h_flags, setup->h_ncolors, setup->h_pixelbits
			);
	(void) fprintf( stderr,
			"\th_ncmap=%d\n\th_cmaplen=%d\n",
			setup->h_ncmap, setup->h_cmaplen
			);
	(void) fprintf( stderr,
			"\th_background=[%d %d %d]\n",
			setup->h_background[0],
			setup->h_background[1],
			setup->h_background[2]
			);
	return;
	}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liborle/rle.c,v 11.6 2004/04/05 07:51:19 morrison Exp $ (BRL)";
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liborle/rle.c,v 11.3 2000/09/01 19:12:56 mike Exp $ (BRL)";
d127 4
a130 4
HIDDEN void	_put_Data();
HIDDEN int	_put_Color_Map_Seg();
HIDDEN int	_put_Std_Map();
HIDDEN int	_get_Color_Map_Seg();
d134 5
a138 5
HIDDEN int	_get_Old_Inst();	/* Old format inst. reader.	*/
HIDDEN int	_get_New_Inst();	/* New extended inst. reader.	*/
HIDDEN void	_enc_Color_Seg();
HIDDEN void	_enc_Segment();
HIDDEN int	_bg_Get_Runs();
d140 1
a140 1
void		prnt_XSetup();
d146 2
a147 3
rle_rlen( xlen, ylen )
int	*xlen, *ylen;
	{
d153 2
a154 3
rle_wlen( xlen, ylen, mode )
int	xlen, ylen, mode;
	{
d169 2
a170 3
rle_rpos( xpos, ypos )
int	*xpos, *ypos;
	{
d176 2
a177 3
rle_wpos( xpos, ypos, mode )
int	xpos, ypos, mode;
	{
d200 2
a201 5
rle_rhdr( fp, flags, bgpixel )
FILE		*fp;
int		*flags;
register unsigned char	*bgpixel;
	{
d346 2
a347 5
rle_whdr( fp, ncolors, bgflag, cmflag, bgpixel )
FILE		*fp;
int		ncolors, bgflag, cmflag;
RGBpixel		bgpixel;
	{
d422 2
a423 4
rle_rmap( fp, cmap )
FILE		*fp;
ColorMap	*cmap;
	{
d440 2
a441 4
rle_wmap( fp, cmap )
FILE		*fp;
ColorMap	*cmap;
	{
d474 2
a475 4
rle_decode_ln( fp, scan_buf )
register FILE	*fp;
RGBpixel	*scan_buf;
	{	static int	lines_to_skip = 0;
d620 2
a621 4
rle_encode_ln( fp, scan_buf )
register FILE	*fp;
RGBpixel		*scan_buf;
	{	register RGBpixel *scan_p;
d685 2
a686 4
_bg_Get_Runs( pixelp, endpix )
register RGBpixel *pixelp;
register RGBpixel *endpix;
	{	/* find non-background runs */
d726 2
a727 5
_enc_Color_Seg( fp, seg, color )
FILE		*fp;
register int	seg;
register int	color;
	{	static RGBpixel *data_p;
d741 2
a742 5
_enc_Segment( fp, data_p, last_p )
FILE		*fp;
register RGBpixel	*data_p;
register RGBpixel	*last_p;
	{	register RGBpixel	*pixelp;
d814 2
a815 5
_put_Data( fp, cp, n )
register FILE	*fp;
register unsigned char *cp;
int		n;
	{	register int	count = n;
d853 2
a854 4
_get_Color_Map_Seg( fp, cmap_seg )
FILE	*fp;
register unsigned short	*cmap_seg;
	{	static unsigned short	rle_cmap[256];
d874 2
a875 4
_put_Color_Map_Seg( fp, cmap_seg )
FILE	*fp;
register unsigned short	*cmap_seg;
	{	static unsigned short	rle_cmap[256];
d897 2
a898 3
_put_Std_Map( fp )
FILE	*fp;
	{	static unsigned short	rle_cmap[256*3];
d918 2
a919 5
_get_New_Inst( fp, opcode, datum )
register FILE	*fp;
register int	*opcode;
register int	*datum;
	{
d938 2
a939 5
_get_Old_Inst( fp, op, dat )
register FILE	*fp;
register int	*op;
register int	*dat;
	{
d959 2
a960 4
prnt_XSetup( msg, setup )
char				*msg;
register Xtnd_Rle_Header	*setup;
	{
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liborle/rle.c,v 11.5 2002/08/20 17:07:53 jra Exp $ (BRL)";
d127 4
a130 4
HIDDEN void	_put_Data(register FILE *fp, register unsigned char *cp, int n);
HIDDEN int	_put_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg);
HIDDEN int	_put_Std_Map(FILE *fp);
HIDDEN int	_get_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg);
d134 5
a138 5
HIDDEN int	_get_Old_Inst(register FILE *fp, register int *op, register int *dat);	/* Old format inst. reader.	*/
HIDDEN int	_get_New_Inst(register FILE *fp, register int *opcode, register int *datum);	/* New extended inst. reader.	*/
HIDDEN void	_enc_Color_Seg(FILE *fp, register int seg, register int color);
HIDDEN void	_enc_Segment(FILE *fp, register RGBpixel (*data_p), register RGBpixel (*last_p));
HIDDEN int	_bg_Get_Runs(register RGBpixel (*pixelp), register RGBpixel (*endpix));
d140 1
a140 1
void		prnt_XSetup(char *msg, register Xtnd_Rle_Header *setup);
d146 3
a148 2
rle_rlen(int *xlen, int *ylen)
{
d154 3
a156 2
rle_wlen(int xlen, int ylen, int mode)
{
d171 3
a173 2
rle_rpos(int *xpos, int *ypos)
{
d179 3
a181 2
rle_wpos(int xpos, int ypos, int mode)
{
d204 5
a208 2
rle_rhdr(FILE *fp, int *flags, register unsigned char *bgpixel)
{
d353 5
a357 2
rle_whdr(FILE *fp, int ncolors, int bgflag, int cmflag, unsigned char *bgpixel)
{
d432 4
a435 2
rle_rmap(FILE *fp, ColorMap *cmap)
{
d452 4
a455 2
rle_wmap(FILE *fp, ColorMap *cmap)
{
d488 4
a491 2
rle_decode_ln(register FILE *fp, RGBpixel (*scan_buf))
{	static int	lines_to_skip = 0;
d636 4
a639 2
rle_encode_ln(register FILE *fp, RGBpixel (*scan_buf))
{	register RGBpixel *scan_p;
d703 4
a706 2
_bg_Get_Runs(register RGBpixel (*pixelp), register RGBpixel (*endpix))
{	/* find non-background runs */
d746 5
a750 2
_enc_Color_Seg(FILE *fp, register int seg, register int color)
{	static RGBpixel *data_p;
d764 5
a768 2
_enc_Segment(FILE *fp, register RGBpixel (*data_p), register RGBpixel (*last_p))
{	register RGBpixel	*pixelp;
d840 5
a844 2
_put_Data(register FILE *fp, register unsigned char *cp, int n)
{	register int	count = n;
d882 4
a885 2
_get_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg)
{	static unsigned short	rle_cmap[256];
d905 4
a908 2
_put_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg)
{	static unsigned short	rle_cmap[256];
d930 3
a932 2
_put_Std_Map(FILE *fp)
{	static unsigned short	rle_cmap[256*3];
d952 5
a956 2
_get_New_Inst(register FILE *fp, register int *opcode, register int *datum)
{
d975 5
a979 2
_get_Old_Inst(register FILE *fp, register int *op, register int *dat)
{
d999 4
a1002 2
prnt_XSetup(char *msg, register Xtnd_Rle_Header *setup)
{
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d127 4
a130 4
HIDDEN void	_put_Data(register FILE *fp, register unsigned char *cp, int n);
HIDDEN int	_put_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg);
HIDDEN int	_put_Std_Map(FILE *fp);
HIDDEN int	_get_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg);
d134 5
a138 5
HIDDEN int	_get_Old_Inst(register FILE *fp, register int *op, register int *dat);	/* Old format inst. reader.	*/
HIDDEN int	_get_New_Inst(register FILE *fp, register int *opcode, register int *datum);	/* New extended inst. reader.	*/
HIDDEN void	_enc_Color_Seg(FILE *fp, register int seg, register int color);
HIDDEN void	_enc_Segment(FILE *fp, register RGBpixel (*data_p), register RGBpixel (*last_p));
HIDDEN int	_bg_Get_Runs(register RGBpixel (*pixelp), register RGBpixel (*endpix));
d140 1
a140 1
void		prnt_XSetup(char *msg, register Xtnd_Rle_Header *setup);
d146 3
a148 2
rle_rlen(int *xlen, int *ylen)
{
d154 3
a156 2
rle_wlen(int xlen, int ylen, int mode)
{
d171 3
a173 2
rle_rpos(int *xpos, int *ypos)
{
d179 3
a181 2
rle_wpos(int xpos, int ypos, int mode)
{
d204 5
a208 2
rle_rhdr(FILE *fp, int *flags, register unsigned char *bgpixel)
{
d353 5
a357 2
rle_whdr(FILE *fp, int ncolors, int bgflag, int cmflag, unsigned char *bgpixel)
{
d432 4
a435 2
rle_rmap(FILE *fp, ColorMap *cmap)
{
d452 4
a455 2
rle_wmap(FILE *fp, ColorMap *cmap)
{
d488 4
a491 2
rle_decode_ln(register FILE *fp, RGBpixel (*scan_buf))
{	static int	lines_to_skip = 0;
d636 4
a639 2
rle_encode_ln(register FILE *fp, RGBpixel (*scan_buf))
{	register RGBpixel *scan_p;
d703 4
a706 2
_bg_Get_Runs(register RGBpixel (*pixelp), register RGBpixel (*endpix))
{	/* find non-background runs */
d746 5
a750 2
_enc_Color_Seg(FILE *fp, register int seg, register int color)
{	static RGBpixel *data_p;
d764 5
a768 2
_enc_Segment(FILE *fp, register RGBpixel (*data_p), register RGBpixel (*last_p))
{	register RGBpixel	*pixelp;
d840 5
a844 2
_put_Data(register FILE *fp, register unsigned char *cp, int n)
{	register int	count = n;
d882 4
a885 2
_get_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg)
{	static unsigned short	rle_cmap[256];
d905 4
a908 2
_put_Color_Map_Seg(FILE *fp, register short unsigned int *cmap_seg)
{	static unsigned short	rle_cmap[256];
d930 3
a932 2
_put_Std_Map(FILE *fp)
{	static unsigned short	rle_cmap[256*3];
d952 5
a956 2
_get_New_Inst(register FILE *fp, register int *opcode, register int *datum)
{
d975 5
a979 2
_get_Old_Inst(register FILE *fp, register int *op, register int *dat)
{
d999 4
a1002 2
prnt_XSetup(char *msg, register Xtnd_Rle_Header *setup)
{
@


11.3
log
@
lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liborle/rle.c,v 11.2 1998/09/14 15:59:16 bparker Exp $ (BRL)";
d127 4
a130 4
HIDDEN void	_put_Data();
HIDDEN int	_put_Color_Map_Seg();
HIDDEN int	_put_Std_Map();
HIDDEN int	_get_Color_Map_Seg();
d134 5
a138 5
HIDDEN int	_get_Old_Inst();	/* Old format inst. reader.	*/
HIDDEN int	_get_New_Inst();	/* New extended inst. reader.	*/
HIDDEN void	_enc_Color_Seg();
HIDDEN void	_enc_Segment();
HIDDEN int	_bg_Get_Runs();
d140 1
a140 1
void		prnt_XSetup();
d146 2
a147 3
rle_rlen( xlen, ylen )
int	*xlen, *ylen;
	{
d153 2
a154 3
rle_wlen( xlen, ylen, mode )
int	xlen, ylen, mode;
	{
d169 2
a170 3
rle_rpos( xpos, ypos )
int	*xpos, *ypos;
	{
d176 2
a177 3
rle_wpos( xpos, ypos, mode )
int	xpos, ypos, mode;
	{
d200 2
a201 5
rle_rhdr( fp, flags, bgpixel )
FILE		*fp;
int		*flags;
register unsigned char	*bgpixel;
	{
d346 2
a347 5
rle_whdr( fp, ncolors, bgflag, cmflag, bgpixel )
FILE		*fp;
int		ncolors, bgflag, cmflag;
RGBpixel		bgpixel;
	{
d422 2
a423 4
rle_rmap( fp, cmap )
FILE		*fp;
ColorMap	*cmap;
	{
d440 2
a441 4
rle_wmap( fp, cmap )
FILE		*fp;
ColorMap	*cmap;
	{
d474 2
a475 4
rle_decode_ln( fp, scan_buf )
register FILE	*fp;
RGBpixel	*scan_buf;
	{	static int	lines_to_skip = 0;
d620 2
a621 4
rle_encode_ln( fp, scan_buf )
register FILE	*fp;
RGBpixel		*scan_buf;
	{	register RGBpixel *scan_p;
d685 2
a686 4
_bg_Get_Runs( pixelp, endpix )
register RGBpixel *pixelp;
register RGBpixel *endpix;
	{	/* find non-background runs */
d726 2
a727 5
_enc_Color_Seg( fp, seg, color )
FILE		*fp;
register int	seg;
register int	color;
	{	static RGBpixel *data_p;
d741 2
a742 5
_enc_Segment( fp, data_p, last_p )
FILE		*fp;
register RGBpixel	*data_p;
register RGBpixel	*last_p;
	{	register RGBpixel	*pixelp;
d814 2
a815 5
_put_Data( fp, cp, n )
register FILE	*fp;
register unsigned char *cp;
int		n;
	{	register int	count = n;
d853 2
a854 4
_get_Color_Map_Seg( fp, cmap_seg )
FILE	*fp;
register unsigned short	*cmap_seg;
	{	static unsigned short	rle_cmap[256];
d874 2
a875 4
_put_Color_Map_Seg( fp, cmap_seg )
FILE	*fp;
register unsigned short	*cmap_seg;
	{	static unsigned short	rle_cmap[256];
d897 2
a898 3
_put_Std_Map( fp )
FILE	*fp;
	{	static unsigned short	rle_cmap[256*3];
d918 2
a919 5
_get_New_Inst( fp, opcode, datum )
register FILE	*fp;
register int	*opcode;
register int	*datum;
	{
d938 2
a939 5
_get_Old_Inst( fp, op, dat )
register FILE	*fp;
register int	*op;
register int	*dat;
	{
d959 2
a960 4
prnt_XSetup( msg, setup )
char				*msg;
register Xtnd_Rle_Header	*setup;
	{
@


11.2
log
@*- fix typos
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liborle/rle.c,v 11.1 1995/01/04 10:04:21 mike Rel4_4 $ (BRL)";
d38 1
a38 1
	if(rle_debug) (void)fprintf(stderr,"%s(%ld,%d)\n",_op,_n,_c)
d138 1
d203 1
d352 1
d431 1
d451 1
d487 1
d635 1
d702 1
d881 1
a881 1
HIDDEN
d904 1
a904 1
HIDDEN
d929 1
a929 1
HIDDEN
d951 1
a951 1
HIDDEN
d974 1
a974 1
HIDDEN
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/liborle/RCS/rle.c,v 10.3 94/08/10 23:33:56 gdurf Exp $ (BRL)";
d38 1
a38 1
	if(rle_debug) (void)fprintf(stderr,"%s(%d,%d)\n",_op,_n,_c)
d591 1
a591 1
			PRNT_A2_DEBUG( "Run-Data", n,	word );
@


10.3
log
@Factored ifdefs, removed dangerous FILE structure hacking
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/liborle/RCS/rle.c,v 10.2 1993/10/26 00:15:52 mike Exp gdurf $ (BRL)";
@


10.2
log
@New fb.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/liborle/RCS/rle.c,v 10.1 91/10/12 06:37:51 mike Rel4_0 Locker: mike $ (BRL)";
d26 2
d29 3
d537 1
d560 1
d839 1
d856 1
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/liborle/RCS/rle.c,v 9.5 91/07/22 20:11:24 mike Exp $ (BRL)";
d200 1
a200 1
register RGBpixel	*bgpixel;
d318 1
a318 1
			COPYRGB( *bgpixel, _bg_pixel );
@


9.5
log
@Eliminated u_char typedef, which interferred with system typedef of
same symbol on IBM
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/liborle/RCS/rle.c,v 9.4 91/07/02 01:22:22 mike Exp $ (BRL)";
@


9.4
log
@Change in header file name.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /f/cad/liborle/RCS/rle.c,v 1.1 91/01/04 00:04:35 butler Exp $ (BRL)";
a29 2
typedef unsigned char	u_char;

d485 1
a485 1
		register u_char	*pp;
d540 1
a540 1
					{ register u_char *cp = (u_char *)fp->_ptr;
d562 1
a562 1
				register u_char c;
d587 1
a587 1
				register u_char inten = (u_char)word;
d599 3
a601 3
					*pp++ = (u_char) word;
					*pp++ = (u_char) word;
					*pp++ = (u_char) word;
d756 1
a756 1
		register u_char	runval = (*data_p)[CUR];
d827 1
a827 1
register u_char *cp;
d834 1
a834 1
		{ register u_char *op = (u_char *)fp->_ptr;
@


9.3
log
@lint
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/liborle/RCS/rle.c,v 9.2 90/11/24 00:42:12 mike Exp $ (BRL)";
d28 1
a28 1
#include "rle.h"
@


9.2
log
@Fixed redefinition of HIDDEN
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/liborle/RCS/rle.c,v 9.1 89/05/19 05:50:34 mike Rel3_5 $ (BRL)";
a352 1
	register int	bbw;
d363 1
d371 7
a383 3
	w_setup.h_background[0] = ncolors == 1 ? bbw : bgpixel[RED];
	w_setup.h_background[1] = ncolors == 1 ? bbw : bgpixel[GRN];
	w_setup.h_background[2] = ncolors == 1 ? bbw : bgpixel[BLU];
d639 5
a649 5
		}
	if( nseg <= 0 )
		{
		RSkipLines( 1 );
		return	0;
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 8.3 89/04/14 08:15:46 mike Exp $ (BRL)";
d122 1
@


8.3
log
@Removed one superfluous static function declaration
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 8.2 88/10/23 19:07:03 mike Locked $ (BRL)";
@


8.2
log
@Lint issue.  Sun has an unsigned char pointer in stdio.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 8.1 88/10/05 00:29:17 phil Locked $ (BRL)";
a126 1
HIDDEN int	_get_Short();
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 7.3 88/09/17 06:57:54 mike Exp $ (BRL)";
d545 1
a545 1
#ifdef BSD
d839 1
a839 1
#ifdef BSD
@


7.3
log
@cray-->CRAY
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 7.2 88/05/13 22:52:27 mike Locked $ (BRL)";
@


7.2
log
@lint fixes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 7.1 87/11/02 23:30:33 mike Locked $ (BRL)";
d971 2
a972 1
#ifndef cray
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 6.1 87/07/11 07:53:32 mike Rel $ (BRL)";
d133 2
d136 2
d728 1
d746 1
d978 1
@


6.1
log
@Release 2.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 5.1 87/06/24 22:08:32 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 4.4 87/04/11 00:02:03 phil Exp $ (BRL)";
@


4.4
log
@several background color related fixes.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 4.3 87/02/12 22:09:53 phil Locked $ (BRL)";
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: rle.c,v 4.2 87/02/11 04:26:44 mike Exp $ (BRL)";
d351 1
d353 4
d373 3
a375 3
	w_setup.h_background[0] = ncolors == 0 ? bbw : bgpixel[RED];
	w_setup.h_background[1] = ncolors == 0 ? bbw : bgpixel[GRN];
	w_setup.h_background[2] = ncolors == 0 ? bbw : bgpixel[BLU];
d689 3
a691 3
		if(	*pixelp[RED] != _bg_pixel[RED]
		    ||	*pixelp[GRN] != _bg_pixel[GRN]
		    ||	*pixelp[BLU] != _bg_pixel[BLU]
@


4.2
log
@FLEXNAMES, and other Cray nits
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: librle.c,v 4.1 86/12/29 02:50:17 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: librle.c,v 1.20 86/12/20 07:45:23 mike Exp $ (BRL)";
d660 1
a660 1
			_encode_Seg_Color( fp, i, color );
d716 1
a716 1
/*	_ e n c o d e _ S e g _ C o l o r ( )
d719 1
a719 1
_encode_Seg_Color( fp, seg, color )
d729 1
a729 1
	_encode_Segment( fp, data_p, last_p );
d733 1
a733 1
/*	_ e n c o d e _ S e g m e n t ( )
d736 1
a736 1
_encode_Segment( fp, data_p, last_p )
d945 1
a945 1
_get_Old_Inst( fp, opcode, datum )
d947 2
a948 2
register int	*opcode;
register int	*datum;
d960 4
a963 2
	*opcode = instruction.opcode;
	*datum = instruction.datum;
@


1.20
log
@Fixed problem with B&W-encoded images
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: librle.c,v 1.19 86/11/14 22:10:00 mike Locked $ (BRL)";
@


1.19
log
@Quenched sysv compiler warnings which are due to difference
in stdio _ptr declaration.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: librle.c,v 1.18 86/10/27 04:37:16 mike Locked $ (BRL)";
d204 1
a204 1
		"Frame buffer image saved in B&W RLE form\n",
d503 1
a503 1
			switch( (n = _bw_flag ? 0 : datum) )
a504 10
			case 0:
				pp = &(scan_buf[r_setup.h_xpos][RED]);
				break;
			case 1:
				pp = &(scan_buf[r_setup.h_xpos][GRN]);
				break;
			case 2:
				pp = &(scan_buf[r_setup.h_xpos][BLU]);
				break;
			default:
d509 1
d554 1
a557 1
					*pp++ = c;
d587 1
a587 1
					*pp++ = (u_char) word;
@


1.18
log
@Converted to RGBpixel
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: librle.c,v 1.17 86/10/03 06:30:53 mike Locked $ (BRL)";
d545 1
d547 3
d837 1
d839 3
@


1.17
log
@To match latest libfb handling of colormaps,
convert between right-justified cmaps (RLE),
and left-justified cmaps (libfb).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d36 1
a36 1
#define CUR red		/* Must be rightmost part of Pixel.		*/
d106 2
a107 2
	Pixel *first;
	Pixel *last;
d114 1
a114 1
Pixel	_bg_pixel;
d198 1
a198 1
register Pixel	*bgpixel;
d310 1
a310 1
		if( bgpixel != (Pixel *) NULL )
d313 4
a316 4
			_bg_pixel.red = r_setup.h_background[0];
			_bg_pixel.green = r_setup.h_background[1];
			_bg_pixel.blue = r_setup.h_background[2];
			*bgpixel = _bg_pixel;
d346 1
a346 1
Pixel		*bgpixel;
d359 3
a361 1
		bbw = 0.35*bgpixel->red+0.55*bgpixel->green+0.1*bgpixel->blue;
d368 3
a370 3
	w_setup.h_background[0] = ncolors == 0 ? bbw : bgpixel->red;
	w_setup.h_background[1] = ncolors == 0 ? bbw : bgpixel->green;
	w_setup.h_background[2] = ncolors == 0 ? bbw : bgpixel->blue;
d404 1
a404 1
	_bg_pixel = *bgpixel;
d468 1
a468 1
Pixel	*scan_buf;
d482 1
a482 1
	pp = (u_char *) (scan_buf+r_setup.h_xpos); /* Pointer into pixel. */
d506 1
a506 1
				pp = &((scan_buf+r_setup.h_xpos)->red);
d509 1
a509 1
				pp = &((scan_buf+r_setup.h_xpos)->green);
d512 1
a512 1
				pp = &((scan_buf+r_setup.h_xpos)->blue);
d618 3
a620 3
Pixel		*scan_buf;
	{	register Pixel *scan_p = &scan_buf[w_setup.h_xpos];
		register Pixel *last_p = &scan_buf[w_setup.h_xpos+(w_setup.h_xlen-1)];
d624 3
d644 1
a644 1
		{	register Pixel *pixelp;
d647 3
a649 3
			pixelp->blue =  .35 * pixelp->red +
					.55 * pixelp->green +
					.10 * pixelp->blue;
d683 2
a684 2
register Pixel *pixelp;
register Pixel *endpix;
d689 3
a691 3
		if(	pixelp->red != _bg_pixel.red
		    ||	pixelp->green != _bg_pixel.green
		    ||	pixelp->blue != _bg_pixel.blue
d699 3
a701 3
			    &&	 (	pixelp->red != _bg_pixel.red
				   ||	pixelp->green != _bg_pixel.green
				   ||	pixelp->blue != _bg_pixel.blue
d728 6
a733 17
	{	static Pixel *data_p;
		static Pixel *last_p;
	switch( color )
		{
		case 0:
			data_p = (Pixel *) &(runs[seg].first->red);
			last_p = (Pixel *) &(runs[seg].last->red);
			break;
		case 1:
			data_p = (Pixel *) &(runs[seg].first->green);
			last_p = (Pixel *) &(runs[seg].last->green);
			break;
		case 2:
			data_p = (Pixel *) &(runs[seg].first->blue);
			last_p = (Pixel *) &(runs[seg].last->blue);
			break;
		}
d743 4
a746 4
register Pixel	*data_p;
register Pixel	*last_p;
	{	register Pixel	*pixelp;
		register Pixel	*runs_p = data_p;
d748 1
a748 1
		register u_char	runval = data_p->CUR;
d754 1
a754 1
			if( runval == pixelp->CUR )
d762 1
a762 1
				runval = pixelp->CUR;
d767 1
a767 1
			if( runval == pixelp->CUR )
d776 1
a776 1
							&(data_p->CUR),
d783 1
a783 1
				runval = pixelp->CUR;
d788 1
a788 1
			if( runval != pixelp->CUR )
d794 1
a794 1
				runval = pixelp->CUR;
d809 1
a809 1
			_put_Data( fp, &data_p->CUR, pixelp - data_p );
@


1.16
log
@Lint fixes.
@
text
@d2 19
a20 13
	SCCS id:	@@(#) librle.c	1.15
	Last edit: 	6/18/86 at 10:05:45	G S M
	Retrieved: 	8/13/86 at 10:30:20
	SCCS archive:	/m/cad/librle/RCS/s.librle.c

	Author : Gary S. Moss, BRL.

	These routines are appropriate for RLE encoding a framebuffer image
	from a program.
	This library is derived from 'ik-rle' code authored by :
		Mike Muuss, BRL.  10/18/83.
		[With a heavy debt to Spencer Thomas, U. of Utah,
		 for the RLE file format].
d22 2
a23 3
#if ! defined( lint )
static
char	sccsTag[] = "@@(#) librle.c	1.15	last edit 6/18/86 at 10:05:45";
d854 3
a856 2
	The RLE format stores color map entries as short integers, so
	we have to stuff them into u_chars.
d861 3
a863 3
register u_char	*cmap_seg;
	{	static short	rle_cmap[256];
		register short	*cm = rle_cmap;
d865 1
a865 1
	if( fread( (char *) rle_cmap, sizeof(short), 256, fp ) != 256 )
d873 1
a873 2
		*cmap_seg++ = (u_char) *cm;
		/* Must increment "cm" seperately due to bug in 4.2 BSD pcc. */
d879 1
a879 1
	Output color map segment to RLE file as shorts.
d884 3
a886 3
register u_char	*cmap_seg;
	{	static short	rle_cmap[256];
		register short	*cm = rle_cmap;
d890 1
a890 1
		*cm = (short) *cmap_seg++;
d909 2
a910 2
	{	static short	rle_cmap[256*3];
		register short	*cm = rle_cmap;
d915 1
a915 1
			*cm = (short) i;
@


1.15
log
@Had to accommodate bug in 4.2 BSD pcc involving register short pointers 
being incremented as their contents are being cast to unsigned chars...
@
text
@d20 1
d22 3
a24 2
#include <fb.h>
#include <rle.h>
d531 1
a531 1
					{ register u_char *cp = fp->_ptr;
d538 1
a538 1
					fp->_ptr = cp;
d827 1
a827 1
		{ register u_char *op = fp->_ptr;
d834 1
a834 1
		fp->_ptr = op;
@


1.14
log
@Fixed encoding bug caused by encoding 1 too many pixels.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.14
	Last edit: 	4/29/86 at 15:11:48	G S M
	Retrieved: 	8/13/86 at 10:29:59
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.14	last edit 4/29/86 at 15:11:48";
d862 1
a862 1
	for( i = 0; i < 256; i++ )
d865 2
a866 1
		*cmap_seg++ = (u_char) *cm++;
@


1.13
log
@Added byte swapping in colormap read/write routines for portability.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.13
	Last edit: 	3/12/86 at 16:48:37	G S M
	Retrieved: 	8/13/86 at 10:29:40
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.13	last edit 3/12/86 at 16:48:37";
d610 5
a614 7
	{
	register Pixel *scan_p = &scan_buf[w_setup.h_xpos];
	register Pixel *last_p = &scan_buf[w_setup.h_xpos+w_setup.h_xlen];
	register int	i;
	register int	color;		/* holds current color */
	register int	nseg;		/* number of non-bg run segments */

d632 1
a632 2
		{
		register Pixel *pixelp;
a644 1

d647 1
a647 2
			{	register int	runlen = (runs[0].first-1) -
							 scan_p;
d673 2
a674 3
	{
	/* find non-background runs */
	register int	nseg = 0;
a692 1

a697 2
	if( rle_verbose )
		(void) fprintf( stderr," (%d segments)\n", nseg );
d701 1
a701 3
				"Encoding incomplete, " );
		(void) fprintf( stderr, 
				"segment array 'runs[%d]' is full!\n",
d713 1
a713 1
FILE	*fp;
d716 2
a717 4
	{
	static Pixel *data_p;
	static Pixel *last_p;

d744 4
a747 6
	{
	register Pixel	*pixelp;
	register Pixel	*runs_p = data_p;
	register int	state = DATA;
	register u_char	runval = data_p->CUR;

d764 1
a764 1
				break;
d773 5
a777 4
				_put_Data(	fp,
						&(data_p->CUR),
					 	runs_p-data_p
					 	);
d807 1
d819 2
a820 5
int	n;
	{
	register int	count = n;
	if( count == 0 )
		return;
@


1.12
log
@Fixed to read/write same format on BIGENDIAN machines like the Goulds.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.12
	Last edit: 	3/7/86 at 15:56:58	G S M
	Retrieved: 	8/13/86 at 10:29:26
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.12	last edit 3/7/86 at 15:56:58";
d870 3
a872 5
	{
	static short	rle_cmap[256];
	register short	*cm = rle_cmap;
	register int	i;

d878 1
a878 1
	for( i = 0; i < 256; ++i )
d880 1
d893 4
a896 6
	{
	static short	rle_cmap[256];
	register short	*cm = rle_cmap;
	register int	i;

	for( i = 0; i < 256; ++i )
d898 2
a899 1
		*cm++ = (short) *cmap_seg++;
d917 3
a919 5
	{
	static short	rle_cmap[256*3];
	register short	*cm = rle_cmap;
	register int	i, segment;

d921 1
a921 1
		for( i = 0; i < 256; ++i )
d923 2
a924 1
			*cm++ = (short) i;
@


1.11
log
@Attempted to fix problem with overrunning pixel buffer by 1 in encoding 
phase.  SkipPixels seems to be the culprit.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.11
	Last edit: 	2/4/86 at 16:54:39	G S M
	Retrieved: 	8/13/86 at 10:29:11
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.11	last edit 2/4/86 at 16:54:39";
d215 1
d225 4
d280 4
d368 1
d374 4
d383 4
@


1.10
log
@Fixed so doesn't try to seek on stdin and stdout.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.10
	Last edit: 	10/15/85 at 15:27:36	G S M
	Retrieved: 	8/13/86 at 10:28:57
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.10	last edit 10/15/85 at 15:27:36";
d442 3
a444 4
	{
	static int	lines_to_skip = 0;
	static int	opcode, datum;
	static short	word;
d446 3
a448 3
	register int	n;
	register u_char	*pp;
	register int	dirty_flag = 0;
d633 3
a635 2
			{
			SkipPixels( runs[0].first - scan_p );
d638 2
a639 1
			{
d645 1
a645 1
				SkipPixels( runs[i+1].first-runs[i].last-1 );
@


1.9
log
@Seperated length and position information access from header access.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.9
	Last edit: 	6/6/85 at 17:30:53	G S M
	Retrieved: 	8/13/86 at 10:28:38
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.9	last edit 6/6/85 at 17:30:53";
d205 1
a205 1
	if( fseek( fp, 0L, 0 ) == -1 )
d354 1
a354 1
	if( fseek( fp, 0L, 0 ) == -1 )
@


1.8
log
@Backport from gould, fixed byte-swapping.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.8
	Last edit: 	5/28/85 at 10:10:48	G S M
	Retrieved: 	8/13/86 at 10:28:21
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.8	last edit 5/28/85 at 10:10:48";
d115 1
a115 1
#define HIDDEN
d130 3
a132 11
/*	r l e _ w h d r ( )
 	This routine should be called after 'setfbsize()', unless the
	framebuffer image is the default size (512).
	This routine should be called before 'rle_encode_ln()' to set up
	the global data: _bg_flag, _bw_flag, _cm_flag, and _bg_pixel.
	Returns -1 for failure, 0 otherwise.
 */
rle_whdr( fp, ncolors, bgflag, cmflag, bgpixel )
FILE		*fp;
int		ncolors, bgflag, cmflag;
Pixel		*bgpixel;
d134 3
a136 3
	/* Magic numbers for output file.				*/
	register int	bbw;
	static short	x_magic = XtndRMAGIC; /* Extended magic number.	*/
d138 5
a142 2
	/* If black and white mode, compute NTSC value of background.	*/
	if( ncolors == 1 )
d144 2
a145 5
		if( rle_verbose )
			(void) fprintf( stderr,
					"Image being saved as monochrome.\n"
					);
		bbw = 0.35*bgpixel->red+0.55*bgpixel->green+0.1*bgpixel->blue;
d147 1
a147 14
	w_setup.h_xpos = 0;
	w_setup.h_ypos = 0;
	w_setup.h_xlen = _fbsize;
	w_setup.h_ylen = _fbsize;
	w_setup.h_flags = bgflag ? H_CLEARFIRST : 0;
	w_setup.h_ncolors = ncolors;
	w_setup.h_pixelbits = _pixelbits;
	w_setup.h_ncmap = cmflag ? _ncmap : 0;
	w_setup.h_cmaplen = _cmaplen;
	w_setup.h_background[0] = ncolors == 0 ? bbw : bgpixel->red;
	w_setup.h_background[1] = ncolors == 0 ? bbw : bgpixel->green;
	w_setup.h_background[2] = ncolors == 0 ? bbw : bgpixel->blue;

	if( fseek( fp, 0L, 0 ) == -1 )
d149 2
a150 2
		(void) fprintf( stderr, "Seek to RLE header failed!\n" );
		return	-1;
d152 16
a167 1
	if( fwrite( (char *) &x_magic, sizeof(short), 1, fp ) != 1 )
d169 2
a170 2
		(void) fprintf( stderr, "Write of magic number failed!\n" );
		return	-1;
d172 1
a172 1
	if( fwrite( (char *) &w_setup, sizeof w_setup, 1, fp ) != 1 )
d174 2
a175 2
		(void) fprintf( stderr, "Write of RLE header failed!\n" );
		return	-1;
d177 1
a177 10
	if( rle_debug )
		{
		(void) fprintf( stderr, "Magic=0x%x\n", x_magic );
		prnt_XSetup( "Setup structure written", &w_setup );
		}
	_bg_flag = bgflag;
	_bw_flag = ncolors == 1;
	_cm_flag = cmflag;
	_bg_pixel = *bgpixel;
	return	0;
d184 2
a185 2
	to pass information back to the caller in flags, bgpixel, xlen,
	ylen, xpos and ypos.
d188 1
a188 1
rle_rhdr( fp, flags, bgpixel, xlen, ylen, xpos, ypos )
a191 2
int		*xlen, *ylen;
int		*xpos, *ypos;
a311 4
	*xlen = r_setup.h_xlen;
	*ylen = r_setup.h_ylen;
	*xpos = r_setup.h_xpos;
	*ypos = r_setup.h_ypos;
d320 61
d448 1
a448 1
	register u_char	*pp = (u_char *) scan_buf; /* Pointer into pixel. */
d456 1
d480 1
a480 1
				pp = &(scan_buf->red);
d483 1
a483 1
				pp = &(scan_buf->green);
d486 1
a486 1
				pp = &(scan_buf->blue);
d592 1
a592 1
Pixel	*scan_buf;
d594 2
a595 2
	register Pixel *scan_p = scan_buf;
	register Pixel *last_p = &scan_buf[w_setup.h_xlen];
d920 1
d943 1
@


1.7
log
@Appears to work well and fast since I put back the STDIO opts.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.7
	Last edit: 	3/27/85 at 20:47:02	G S M
	Retrieved: 	8/13/86 at 10:28:04
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.7	last edit 3/27/85 at 20:47:02";
d41 1
a41 1
	{register int v = s; \
d144 1
a144 1
	static int	x_magic = XtndRMAGIC; /* Extended magic number.	*/
d509 1
d893 1
a893 1
		SWAB(long_data);
d913 1
@


1.6
log
@Seems to work : reads both new and old formats, writes new format.
Must speed it up and remove some debug writes.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.6
	Last edit: 	3/26/85 at 17:47:29	G S M
	Retrieved: 	8/13/86 at 10:27:49
d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.6	last edit 3/26/85 at 17:47:29";
d25 4
d35 1
d41 2
a42 9
	do { register int v = s; \
		(void) putc( v & 0xFF, fp ); \
		(void) putc( (v>>8) & 0xFF, fp ); \
		if( rle_debug ) \
			{ \
			(void) putc( v & 0xFF, stderr ); \
			(void) putc( (v>>8) & 0xFF, stderr ); \
			} \
	} while( 0 )
a43 2
#define UPPER 255			/* anything bigger ain't a byte */

d46 1
a46 9
	do { \
		(void) putc( oper, fp ); \
		(void) putc( a1, fp ); \
		if( rle_debug ) \
			{ \
			(void) putc( oper, stderr ); \
			(void) putc( a1, stderr ); \
			} \
	} while( 0 )
d49 1
a49 10
	do { \
		(void) putc( oper, fp ); \
		(void) putc( a1, fp ); \
		if( rle_debug ) \
			{ \
			(void) putc( oper, stderr ); \
			(void) putc( a1, stderr ); \
			} \
		putshort( a2 ); \
	} while( 0 )
d52 2
a53 11
#define mk_long_1(oper,a1) \
	do { /* one argument long */ \
		(void) putc( LONG|(oper), fp ); \
		(void) putc( 0, fp ); \
		if( rle_debug ) \
			{ \
			(void) putc( LONG|(oper), stderr ); \
			(void) putc( 0, stderr ); \
			} \
		putshort( a1 ); \
	} while( 0 )
d55 3
a57 12
#define mk_long_2(oper,a1,a2) \
	do { /* two argument long */ \
		if( rle_debug ) \
			{ \
			(void) putc( LONG|(oper), stderr ); \
			(void) putc( 0, stderr ); \
			} \
		(void) putc( LONG|(oper), fp ); \
		(void) putc( 0, fp ); \
		putshort( a1 ); \
		putshort( a2 ); \
	} while( 0 )
d61 1
a61 4
	do { \
		if( a1 > UPPER )	mk_long_1(oper,a1); \
		else			mk_short_1(oper,a1); \
	} while( 0 )
d64 1
a64 4
	do { \
		if( a1 > UPPER )	mk_long_2(oper,a1,a2); \
		else			mk_short_2(oper,a1,a2); \
	} while( 0 )
d82 1
a82 5
		do { \
			if( rle_debug ) \
				(void)fprintf(stderr,"RSkipLines(%d)\n",(_n)); \
		  	mk_inst_1(RSkipLinesOp,(_n)); \
		} while( 0 )
d85 1
a85 5
		do { \
			if( rle_debug ) \
				(void)fprintf(stderr,"RSetColor(%d)\n",(_c)); \
			mk_short_1(RSetColorOp,(_c)); \
		} while( 0 )
d88 1
a88 5
		do { \
			if( rle_debug ) \
				(void)fprintf(stderr,"RSkipPixels(%d)\n",(_n)); \
			mk_inst_1(RSkipPixelsOp,(_n)); \
		} while( 0 )
d90 2
a91 6
#define	RNewLine() \
		do { \
			if( rle_debug ) \
				(void)fprintf(stderr,"RNewLine()\n"); \
			RSkipLines(1); \
		} while( 0 )
a92 6
#define	RByteData(_n) \
		do { \
			if( rle_debug ) \
				(void)fprintf(stderr,"RByteData(%d)\n",_n); \
			mk_inst_1(RByteDataOp,_n); \
		} while( 0 )
d94 1
a94 6
		do { \
			if( rle_debug ) \
				(void)fprintf(stderr, \
					"RRunData(%d,%d)\n",_n,_c); \
			mk_inst_2(RRunDataOp,(_n),(_c)); \
		} while( 0 )
a177 2
	if( rle_debug )
		(void) fprintf( stderr, "Magic=0x%x\n", x_magic );
d184 2
d187 1
a231 2
	if( rle_debug )
		(void) fprintf( stderr, "Magic=0x%x\n", x_magic );
d334 2
d337 1
d400 1
a400 1
FILE	*fp;
d420 20
a439 49
			case RSkipLinesOp :
				lines_to_skip = datum;
				if( rle_debug )
					(void) fprintf( stderr,
							"Skip Lines %d\n",
							lines_to_skip
							);
				if( lines_to_skip-- < 1 )
					return	-1;
				else
					return	dirty_flag;
			case RSetColorOp:
				if( rle_debug )
					(void) fprintf( stderr,
							"Set Color %d\n",
							datum
							);
			/*
			 * Select "color channel" that following ops go to.
			 *
			 * Set `pp' to point to starting pixel element;
			 * by adding STRIDE to pp, will move to corresponding
			 * color element in next pixel.
			 * If Black & White image:  point to left-most
			 * byte (Red for Ikonas) in long,
			 * and Run and Data will ignore strides below.
			 */
				if( _bw_flag )
					n = 0;
				else
					n = datum;
				switch( n )
					{
					case 0:
						pp = &(scan_buf->red);
						break;
					case 1:
						pp = &(scan_buf->green);
						break;
					case 2:
						pp = &(scan_buf->blue);
						break;
					default:
						(void) fprintf( stderr,
							"Bad color %d\n",
								n
								);
						return	-1;
					}
d441 2
a442 8
			case RSkipPixelsOp:
				n = datum;
				if( rle_debug )
					(void) fprintf( stderr,
							"Skip Pixels %d\n",
							n
							);
				pp += n * STRIDE; /* advance pixel ptr */
d444 29
a472 11
			case RByteDataOp:
				{ register int bytes = 0;
				n = datum + 1;
				if( rle_debug )
					(void) fprintf( stderr,
						"Byte Data, count=%d.\n",
							n
							);
	
				if( ! _bw_flag )
					{
d475 1
a475 1
						*pp = getc( fp );
a476 1
						bytes++;
d478 1
d481 1
a481 11
					{ /* Ugh, black & white.	*/
					register u_char c;
					while( n-- > 0 )
						{
						*pp++ = c = getc( fp );
						*pp++ = c;
						*pp++ = c;
						*pp++ = c;
						}
					}
				if( feof( fp ) )
d483 2
a484 4
					(void) fprintf( stderr,
				"unexpected EOF while reading BYTE DATA\N"
							);
					return	-1;
d486 5
a490 1
				if( (datum + 1) & 1 )
d492 4
a495 3
					/* word align file ptr */
					(void) getc( fp );
					bytes++;
d497 12
a508 4
				dirty_flag = 1;
				if( rle_debug )
					(void) fprintf( stderr, "%d bytes read.\n", bytes );
				break;
d510 2
a511 2
			case RRunDataOp:
				n = datum + 1;
d513 6
a518 3
				register char *p = (char *) &word;
				*p++ = getc( fp );
				*p++ = getc( fp );
d520 3
a522 8
				if(rle_debug)
					(void) fprintf( stderr,	
						"Run-Data(len=%d,inten=%d)\n",
							n,
							word
							);
	
				if( ! _bw_flag )
d524 4
a527 6
					register u_char inten = (u_char)word;
					while( n-- > 0 )
						{
						*pp = inten;
						pp += STRIDE;
						}
d529 5
a533 13
				else
					{ /* Ugh, black & white.		*/
					while( n-- > 0 )
						{
						*pp++ = (u_char) word;
						*pp++ = (u_char) word;
						*pp++ = (u_char) word;
						}
					}
				dirty_flag = 1;
				break;
			default:
				(void) fprintf( stderr,
d535 4
a538 4
						opcode, opcode, datum
						);
				if( ! rle_debug )
					return	-1;
d549 1
a549 1
FILE	*fp;
d605 1
a605 1
	RNewLine();
a663 1
int	color;
d665 1
d697 1
a698 1
	register Pixel	*pixelp;
d706 12
a717 15
			case DATA :
				if( runval == pixelp->CUR )
					{
					/* 2 in a row, may be a run */
					state = RUN2;
					}
				else
					{
					/* continue accumulating data, look
						for a new run starting here,
						too
					 */
					runval = pixelp->CUR;
					runs_p = pixelp;
					}
d719 12
a730 37
			case RUN2:
				if( runval == pixelp->CUR )
					{
					/* 3 in a row is a run */
					state = INRUN;
					/* Flush out data sequence
						encountered before this run
					 */
					_put_Data(	fp,
							&(data_p->CUR),
						 	runs_p-data_p
						 	);
					}
				else
					{
					/* not a run, */
					/* but maybe this starts one */
					state = DATA;
					runval = pixelp->CUR;
					runs_p = pixelp;
					}
				break;
			case INRUN:
				if( runval != pixelp->CUR )
					{
					/* if run out */
					state = DATA;
					PutRun(	runval,
						pixelp - runs_p
						);
					/* who knows, might be more */
					runval = pixelp->CUR;
					runs_p = pixelp;
					/* starting new 'data' run */
					data_p = pixelp;
					}
				break;
d732 22
a753 1
			}
a759 1
			{
a760 1
			}
a773 1
	register int	bytes = 0;
d778 12
a793 1
		++bytes;
a795 1
		{
a796 4
		++bytes;
		}
	if( rle_debug )
		(void) fprintf( stderr, "%d bytes written.\n", bytes );
d810 1
a810 1
	short	rle_cmap[256];
d834 1
a834 1
	short		rle_cmap[256];
d859 1
a859 1
	short		rle_cmap[256*3];
d879 3
a881 3
FILE	*fp;
int	*opcode;
int	*datum;
d883 10
a892 10
	Xtnd_Inst	instruction;
	if( fread( (char *) &instruction, sizeof(instruction), 1, fp ) != 1 )
		{
		return	EOF;
		}
	if( LONGP(instruction) )
		{ short	long_data;
		*opcode = OPCODE(instruction);
		if( _get_Short( fp, &long_data ) == EOF )
			return	EOF;
d895 2
a896 11
	else
		{
		*opcode = instruction.opcode;
		*datum = DATUM(instruction);
		}
	if( rle_debug )
		(void) fprintf( stderr,
				"op %d, datum %d\n",
				*opcode,
				*datum
				);
d901 3
a903 3
FILE	*fp;
int	*opcode;
int	*datum;
d905 8
a912 2
	Old_Inst	instruction;
	if( _get_Short( fp, (short *) &instruction ) == EOF )
a915 6
	if( rle_debug )
		(void) fprintf( stderr,
				"op %d, datum %d\n",
				*opcode,
				*datum
				);
a918 17

/*	_ g e t _ S h o r t ( )
 */
HIDDEN int
_get_Short( fp, word )
FILE	*fp;
short	*word;
	{
	if( fread( (char *) word, sizeof(short), 1, fp ) != 1 )
		{
		(void) fprintf( stderr, "get_Short() Read failed!\n" );
		return	EOF;
		}
	SWAB( *word );
	return	1;
	}

@


1.5
log
@Finished manual page, encoding stuff produces new extended RLE format.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.5
	Last edit: 	3/25/85 at 12:34:55	G S M
	Retrieved: 	8/13/86 at 10:27:36
a10 1

d18 1
a18 1
char	sccsTag[] = "@@(#) librle.c	1.5	last edit 3/25/85 at 12:34:55";
d26 2
a27 3
/* 
 * States for run detection
 */
d36 9
a44 5
	{ \
	register int v = s; \
	(void) putc( v & 0xFF, fp ); \
	(void) putc( (v>>8) & 0xFF, fp ); \
	}
d46 65
d112 1
a112 5
#define SkipBlankLines(nblank) \
	{ \
	putshort(RSkipLines(nblank)); \
	if( rle_debug ) (void) fprintf( stderr, "SkipLines %d\n", nblank ); \
	}
d117 1
a117 5
#define SetColor(c) \
	{ \
	putshort(RSetColor((_bw_flag ? 0 : c))); \
	if(rle_debug)  (void) fprintf( stderr, "SetColor %d\n", c); \
	}
d120 1
a120 9
#define SkipPixels(nskip) \
	{ \
	if( nskip > 0 ) \
		{ \
		putshort( RSkipPixels(nskip) ); \
		if( rle_debug) \
			 (void) fprintf( stderr, "SkipPixels %d\n", nskip); \
		} \
	}
d122 2
a123 9
/* Perform a newline action.  Since CR is implied by the Set Color
	operation, this is only used to switch to a new scanline when the
	current one has been fully described.
 */
#define NewScanLine() \
	{ \
	putshort(RNewLine); \
	if(rle_debug) (void) fprintf( stderr, "New Scan Line\n" ); \
	}
d125 43
a167 29
/* Output an enumerated set of intensities for current color channel.	*/
#define PutRun(color, num) \
	{ \
	putshort(RRunData(num)); \
	putshort(color); \
	if(rle_debug) \
		(void) fprintf( stderr, \
				"Run Data, len=%d, intensity=%d\n", \
				 num, color ); \
	}
/*
 * Opcode definitions
 */
#define	    RSkipLines(n)	    ((RSkipLinesOp<<12) | ((n) & 0x3ff))
#define	    RSetColor(c)	    ((RSetColorOp<<12) | ((c) & 03))
					/* has side effect of performing */
					/* "carriage return" action */
#define	    RSkipPixels(n)	    ((RSkipPixelsOp<<12) | ((n) & 0x3ff))
#define	    RNewLine		    RSkipLines(1)
#define	    RByteData(n)	    ((RByteDataOp<<12) | (((n)-1) & 0x3ff))
					/* followed by ((n+1)/2)*2 bytes */
					/* of data.  If n is odd, last */
					/* byte will be ignored */
					/* "cursor" is left at pixel */
					/* following last pixel written */
#define	    RRunData(n)		    ((RRunDataOp<<12) | (((n)-1) & 0x3ff))
					/* next word contains color data */
					/* "cursor" is left at pixel after */
					/* end of run */
a174 5
#define HIDDEN
HIDDEN void	_put_Data();
HIDDEN int	_put_Color_Map_Seg();
HIDDEN int	_get_Color_Map_Seg();

d187 12
d200 1
a200 1
static Rle_Header	r_setup;	/* Header being read in.	*/
d216 1
d220 5
d226 1
d229 2
a230 2
	w_setup.h_xsize = _fbsize;
	w_setup.h_ysize = _fbsize;
d236 3
a238 3
	w_setup.h_background[0] = ncolors == 0 ? bbw : bgpixel.red;
	w_setup.h_background[1] = ncolors == 0 ? bbw : bgpixel.green;
	w_setup.h_background[2] = ncolors == 0 ? bbw : bgpixel.blue;
d245 1
a245 1
	if( fwrite( &w_setup, sizeof w_setup, 1, fp ) != 1 )
d247 7
d257 2
d270 2
a271 2
	to pass information back to the caller in cmflag, bgpixel, xsize,
	ysize, xpos and ypos.
d274 1
a274 1
rle_rhdr( fp, cmflag, bgpixel, xsize, ysize, xpos, ypos )
d276 1
a276 1
int		*cmflag;
d278 1
a278 1
int		*xsize, *ysize;
d281 1
a281 2
	Rle_Header	setup;
	register int	mode;
d284 1
a284 1
		"Frame buffer image saved in ColorRun Length Encoded form\n",
d298 1
a298 1
	if( fread( (char *)&setup, sizeof(Rle_Header), 1, fp ) != 1 )
d300 1
a300 1
		(void) fprintf( stderr, "Read of RLE header failed!\n" );
d303 6
a308 21
	switch( setup.magic & ~0xff) {
	case RMAGIC :
		if( rle_verbose )
			(void) fprintf( stderr,	verbage[0] );
		_bw_flag = 0;
		mode = setup.magic & 0xFF;
		break;
	case WMAGIC :
		if( rle_verbose )
			(void) fprintf( stderr, verbage[1] );
		_bw_flag = 1;
		mode = setup.magic & 0xFF;
		break;
	default:
		(void) fprintf(	stderr, verbage[2], setup.magic );
		return	-1;
	}
#ifdef POSFLAG
	if( posflag )
		{
		if( rle_verbose )
d310 1
a310 2
					"Originally positioned at (%d, %d)\n",
					setup.xpos, setup.ypos
d312 1
a312 4
		if( posflag == 1 )
			{ /* Incremental positioning.			*/
			setup.xpos = (posx + setup.xpos) % _fbsize;
			setup.ypos = (posy + setup.ypos) % _fbsize;
d314 45
a358 1
		else
d360 4
a363 2
			setup.xpos = posx % _fbsize;
			setup.ypos = posy % _fbsize;
d365 1
a366 1
#endif POSFLAG
d370 4
a373 4
				setup.xpos,
				setup.ypos,
				setup.xsize,
				setup.ysize
d375 2
a376 2
	switch( mode ) {
	case 'B' : /* Background given.					*/
d380 3
a382 1
					setup.bg_r, setup.bg_g, setup.bg_b
d387 3
a389 3
			_bg_pixel.red = setup.bg_r;
			_bg_pixel.green = setup.bg_g;
			_bg_pixel.blue = setup.bg_b;
d392 16
a407 16
		break;
	case 'O': /* Overlay mode.					*/
		if( rle_verbose )
			(void) fprintf( stderr, verbage[4] );
		break;
	default:
		if( rle_verbose )
			(void) fprintf( stderr, verbage[5] );
		(void) fprintf( stderr, "unknown display mode x%x\n", mode );
		break;
	}
	*cmflag = setup.map;
	*xsize = setup.xsize;
	*ysize = setup.ysize;
	*xpos = setup.xpos;
	*ypos = setup.ypos;
d450 4
d473 2
a474 1
	static Rle_Word inst;
d476 1
a476 1
	static int	lines_to_skip = 0;
d486 1
a486 1
	while( _Get_Inst( fp, &inst ) != EOF )
d488 1
a488 7
		if( rle_debug )
			(void) fprintf( stderr,
					"op %d, datum %d\n",
					inst.opcode,
					inst.datum
					);
		switch( n = inst.opcode )
d491 1
a491 1
				lines_to_skip = inst.datum;
d505 1
a505 1
							inst.datum
d520 1
a520 1
					n = inst.datum;
d541 1
a541 1
				n = inst.datum;
d550 2
a551 1
				n = inst.datum + 1;
d564 1
d575 1
d581 1
a581 1
				"unexpected EOF while reading Byte Data\n"
d585 2
a586 1
				if( (inst.datum+1) & 01 )
d589 2
d592 2
d595 1
d597 1
a597 1
				n = inst.datum + 1;
d605 1
a605 1
							"Run-Data(len=%d,inten=%d)\n",
d632 2
a633 2
						"Unrecognized opcode: %d (x%x x%x)\n",
						inst.opcode, inst.opcode, inst.datum
d651 1
a651 1
	register Pixel *last_p = &scan_buf[_fbsize];
d669 1
a669 1
		SkipBlankLines( 1 );
d703 1
a703 1
	NewScanLine();
d880 2
a881 2
	register int count = n;

d884 1
a884 1
	putshort( RByteData(n) );
d886 1
a886 1
	if( fp->_cnt >= count )
d888 3
a890 8
		register u_char *op = fp->_ptr;
		fp->_cnt -= count;
		while( count-- > 0 )
			{
			*op++ = *cp;
			cp += STRIDE;
			}
		fp->_ptr = op;
d892 1
a892 1
	else
d894 2
a895 5
		while( count-- > 0 )
			{
			(void) putc( (int) *cp, fp );
			cp += STRIDE;
			}
a896 2
	if( n & 1 )
		(void) putc( 0, fp );	/* short align output */
d898 1
a898 1
		(void) fprintf( stderr, "Byte Data, len=%d\n", n );
d907 1
a907 1
static
d952 120
@


1.4
log
@Packaging.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.4
	Last edit: 	3/22/85 at 14:23:05	G S M
	Retrieved: 	8/13/86 at 10:27:22
d19 1
a19 1
char	sccsTag[] = "@@(#) librle.c	1.4	last edit 3/22/85 at 14:23:05";
a24 2
int	rle_debug = 0;
int	rle_verbose = 0;
d123 4
a126 4
int	_bg_flag = 2;
int	_bw_flag = 0;
int	_cm_flag = 0;
Pixel	_bg_pixel = { 0, 0, 0, 0 };
d128 5
d134 3
d144 1
a144 1
rle_whdr( fp, bwflag, bgflag, cmflag, bbw, bgpixel )
d146 1
a146 2
int		bwflag, bgflag, cmflag;
int		bbw;
d150 19
a168 16
	static char	tab_magic[] = "\0OB";
	Rle_Header	setup;
	_bg_flag = bgflag;
	_bw_flag = bwflag;
	_cm_flag = cmflag;
	_bg_pixel = *bgpixel;
	setup.magic = (_bw_flag ? WMAGIC : RMAGIC) | tab_magic[_bg_flag];
	setup.xpos = 0;
	setup.ypos = 0;
	setup.xsize = _fbsize;
	setup.ysize = _fbsize;
	setup.bg_r = _bw_flag ? bbw : _bg_pixel.red;
	setup.bg_g = _bw_flag ? bbw : _bg_pixel.green;
	setup.bg_b = _bw_flag ? bbw : _bg_pixel.blue;
	setup.map = _cm_flag;
	if( fwrite( &setup, sizeof setup, 1, fp ) != 1 )
d170 5
d178 4
d186 5
a190 2
	This routine should be called before 'rle_decode_ln()' to set up
	the global data: _bg_flag, _bw_flag, _cm_flag, and _bg_pixel.
d193 6
a198 7
rle_rhdr( fp, bgflag, bwflag, cmflag, olflag, bgpixel )
FILE	*fp;
int	bgflag;
int	*bwflag;
int	*cmflag;
int	olflag;
Pixel	*bgpixel;
d213 5
d259 1
a267 1
#endif POSFLAG
d275 1
a275 1
		if( bgflag == 0 )
d281 1
a293 26

	/*
	 * Checks
	 */
	if( setup.xsize > _fbsize )  {
		(void) fprintf( stderr,	"truncating xsize from %d to %d\n",
			setup.xsize,
			_fbsize
			);
		setup.xsize = _fbsize;
	}
	if( setup.ysize > _fbsize )  {
		(void) fprintf( stderr,	"truncating ysize from %d to %d\n",
			setup.ysize,
			_fbsize
			);
		setup.ysize = _fbsize;
	}
	if( olflag && bgflag )
		{
		(void) fprintf( stderr,
		"Error:  both overlay and background modes selected\n"
				);
		return	-1;
		}
	*bwflag = _bw_flag;
d295 4
a298 1
	*bgpixel = _bg_pixel;
d329 10
d558 1
a558 1
		/* Compute Black & White in blue row */
@


1.3
log
@First version ready for testing.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.3
	Last edit: 	3/22/85 at 13:59:56	G S M
	Retrieved: 	8/13/86 at 10:27:09
d19 1
a19 1
char	sccsTag[] = "@@(#) librle.c	1.3	last edit 3/22/85 at 13:59:56";
d24 3
a26 1
extern int	debug, verbose;
d50 1
a50 1
	if( debug ) (void) fprintf( stderr, "SkipLines %d\n", nblank ); \
d59 1
a59 1
	if(debug)  (void) fprintf( stderr, "SetColor %d\n", c); \
d68 2
a69 1
		if(debug) (void) fprintf( stderr, "SkipPixels %d\n", nskip); \
d80 1
a80 1
	if(debug) (void) fprintf( stderr, "New Scan Line\n" ); \
d88 1
a88 1
	if(debug) \
d201 1
a201 1
		if( verbose )
d207 1
a207 1
		if( verbose )
d219 1
a219 1
		if( verbose )
d235 1
a235 1
	if (verbose) 
d246 1
a246 1
		if( verbose )
d260 1
a260 1
		if( verbose )
d264 1
a264 1
		if( verbose )
d308 1
a308 1
	if(verbose)
d327 1
a327 1
	if(verbose)
d362 1
a362 1
		if( debug )
d372 1
a372 1
				if( debug )
d382 1
a382 1
				if( debug )
d422 1
a422 1
				if( debug )
d431 1
a431 1
				if( debug )
d474 1
a474 1
				if(debug)
d506 1
a506 1
				if( ! debug )
d613 1
a613 1
	if(verbose)
d778 1
a778 1
	if( debug )
@


1.2
log
@Works well, all options not tested, -i and -p option not 
supported, and buffering is needed.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.2
	Last edit: 	3/21/85 at 16:21:57	G S M
	Retrieved: 	8/13/86 at 10:26:53
d19 1
a19 1
char	sccsTag[] = "@@(#) librle.c	1.2	last edit 3/21/85 at 16:21:57";
d23 1
a23 2
typedef unsigned char	u_char;
#include "./rle.h"
d127 1
d338 2
d347 1
d350 1
a350 1
	static int	lines_to_skip = 0;
d354 2
a355 2
		--lines_to_skip;
		return	0;
d368 2
a369 2
				lines_to_skip = inst.datum - 1;
				if (debug)
d374 1
a374 1
				if( lines_to_skip < 0 )
d377 1
a377 1
					return	0;
a449 1
						*pp++ = c;
d462 1
a493 1
						*pp++ = (u_char) word;
d496 1
d507 1
a507 1
	return	0;
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
	SCCS id:	@@(#) librle.c	1.1
	Last edit: 	3/21/85 at 13:59:42	G S M
	Retrieved: 	8/13/86 at 10:26:47
d19 1
a19 1
char	sccsTag[] = "@@(#) librle.c	1.1	last edit 3/21/85 at 13:59:42";
d335 172
a824 172
		}
	return	0;
	}

/*	r l e _ d e c o d e _ l n ( )
	Decode one scanline into 'scan_buf'.
	Buffer is assumed to be filled with background color.
 */
rle_decode_ln( fp, scan_buf )
FILE	*fp;
Pixel	*scan_buf;
	{
	static Rle_Word inst;
	static short	word;
	register int	n;
	register u_char	*pp = (u_char *) scan_buf; /* Pointer into pixel. */
	static int	lines_to_skip = 0;

	if( lines_to_skip > 0 )
		{
		--lines_to_skip;
		return	0;
		}
	while( _Get_Inst( fp, &inst ) != EOF )
		{
		if( debug )
			(void) fprintf( stderr,
					"op %d, datum %d\n",
					inst.opcode,
					inst.datum
					);
		switch( n = inst.opcode )
			{
			case RSkipLinesOp :
				lines_to_skip = inst.datum;
				if (debug)
					(void) fprintf( stderr,
							"Skip Lines %d\n",
							lines_to_skip
							);
				if( lines_to_skip < 1 )
					return	-1;
				else
					return	0;
			case RSetColorOp:
				if( debug )
					(void) fprintf( stderr,
							"Set Color %d\n",
							inst.datum
							);
			/*
			 * Select "color channel" that following ops go to.
			 *
			 * Set `pp' to point to starting pixel element;
			 * by adding STRIDE to pp, will move to corresponding
			 * color element in next pixel.
			 * If Black & White image:  point to left-most
			 * byte (Red for Ikonas) in long,
			 * and Run and Data will ignore strides below.
			 */
				if( _bw_flag )
					n = 0;
				else
					n = inst.datum;
				switch( n )
					{
					case 0:
						pp = &(scan_buf->red);
						break;
					case 1:
						pp = &(scan_buf->green);
						break;
					case 2:
						pp = &(scan_buf->blue);
						break;
					default:
						(void) fprintf( stderr,
							"Bad color %d\n",
								n
								);
						return	-1;
					}
				break;
			case RSkipPixelsOp:
				n = inst.datum;
				if( debug )
					(void) fprintf( stderr,
							"Skip Pixels %d\n",
							n
							);
				pp += n * STRIDE; /* advance pixel ptr */
				break;
			case RByteDataOp:
				n = inst.datum + 1;
				if( debug )
					(void) fprintf( stderr,
						"Byte Data, count=%d.\n",
							n
							);
	
				if( ! _bw_flag )
					{
					while( n-- > 0 )
						{
						*pp = getc( fp );
						pp += STRIDE;
						}
					}
				else
					{ /* Ugh, black & white.	*/
					register u_char c;
					while( n-- > 0 )
						{
						*pp++ = c = getc( fp );
						*pp++ = c;
						*pp++ = c;
						*pp++ = c;
						}
					}
				if( feof( fp ) )
					{
					(void) fprintf( stderr,
				"unexpected EOF while reading Byte Data\n"
							);
					return	-1;
					}
				if( (inst.datum+1) & 01 )
					/* word align file ptr */
					(void) getc( fp );
				break;
			case RRunDataOp:
				n = inst.datum + 1;
				{
				register char *p = (char *) &word;
				*p++ = getc( fp );
				*p++ = getc( fp );
				}
				if(debug)
					(void) fprintf( stderr,	
							"Run-Data(len=%d,inten=%d)\n",
							n,
							word
							);
	
				if( ! _bw_flag )
					{
					register u_char inten = (u_char)word;
					while( n-- > 0 )
						{
						*pp = inten;
						pp += STRIDE;
						}
					}
				else
					{ /* Ugh, black & white.		*/
					while( n-- > 0 )
						{
						*pp++ = (u_char) word;
						*pp++ = (u_char) word;
						*pp++ = (u_char) word;
						*pp++ = (u_char) word;
						}
					}
				break;
			default:
				(void) fprintf( stderr,
						"Unrecognized opcode: %d (x%x x%x)\n",
						inst.opcode, inst.opcode, inst.datum
						);
				if( ! debug )
					return	-1;
			}
@
