head	11.3;
access;
symbols
	ansi-20040405-merged:11.1.6.1
	postmerge-20040405-ansi:11.2
	premerge-20040404-ansi:11.2
	postmerge-autoconf:11.2
	autoconf-freeze:11.2
	premerge-autoconf:11.2
	ansi-20040316-freeze:11.1
	postmerge-20040315-windows:11.2
	premerge-20040315-windows:11.2
	windows-20040315-freeze:11.1.8.1
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	autoconf-branch:11.2.0.6
	phong-branch:11.2.0.4
	photonmap-branch:11.2.0.2
	rel-6-1-DP:11.1
	windows-branch:11.1.0.8
	rel-6-0-2:11.1
	ansi-branch:11.1.0.6
	rel-6-0-1-branch:11.1.0.4
	hartley-6-0-post:11.1
	hartley-6-0-pre:11.1
	rel-6-0-1:11.1
	rel-6-0:11.1
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:1.8
	rel-1-10:1.7;
locks; strict;


11.3
date	2004.05.21.18.05.40;	author morrison;	state dead;
branches;
next	11.2;

11.2
date	2003.01.07.13.36.23;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.04.20;	author mike;	state Rel4_4;
branches
	11.1.6.1
	11.1.8.1;
next	10.1;

10.1
date	91.10.12.06.37.50;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.08.07.12.56.14;	author mmark;	state Exp;
branches;
next	9.2;

9.2
date	91.07.26.16.38.28;	author mmark;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.50.31;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	88.12.27.09.04.03;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.29.16;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.02.17.04.35;	author merritt;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.30.30;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.53.29;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.08.28;	author mike;	state Rel;
branches;
next	1.8;

1.8
date	87.02.12.22.09.50;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.10.26.39;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.13.10.26.33;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.13.10.26.20;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.13.10.26.11;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.13.10.26.06;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.08.13.10.26.00;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.10.25.58;	author mike;	state Exp;
branches;
next	;

11.1.6.1
date	2004.03.17.21.18.33;	author morrison;	state Exp;
branches;
next	;

11.1.8.1
date	2004.03.11.23.43.08;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.3
log
@moved from top-level to src/other/.
@
text
@.TH LIBORLE 3 BRL/CAD
.SH NAME
liborle \- old run-length encoded image library
.SH SYNOPSIS
.nf
.B #include <fb.h>
.B #include <rle.h>
.P
.B "int rle_rhdr( stream, flags, bgpixel )"
.B FILE *stream;
.B int *flags;
.B Pixel *bgpixel;
.P
.B "rle_whdr( stream, ncolors, bgflag, cmflag, bgpixel )"
.B FILE *stream;
.B Pixel *bgpixel;
.P
.B "rle_rlen( xlen, ylen )
.B int *xlen, *ylen;
.P
.B "rle_rpos( xpos, ypos )
.B int *xpos, *ypos;
.P
.B "rle_wlen( xlen, ylen, mode )
.B int xlen, ylen, mode;
.P
.B "rle_wpos( xpos, ypos, mode )
.B int xpos, ypos, mode;
.P
.B int rle_rmap( stream, cmap )
.B FILE *stream;
.B ColorMap *cmap;
.P
.B rle_wmap( stream, cmap )
.B FILE *stream;
.B ColorMap *cmap;
.P
.B rle_decode_ln( stream, scanline_buffer )
.B FILE *stream;
.B Pixel *scanline_buffer;
.P
.B rle_encode_ln( stream, scanline_buffer )
.B FILE *stream;
.B Pixel *scanline_buffer;
.fi
.SH DESCRIPTION
These routines are designed to provide a means of decoding or encoding
University of Utah Alpha_1 format Run-Length Encoded (RLE) files
from a
C
program.
There are separate routines for reading or writing the
RLE
header, reading
or writing the encoded color map, and decoding or encoding a scanline of a
raster image.
The program that loads this library can be ignorant of the
particular encoding
scheme being used.
This library does not need to know anything about
the available frame buffer hardware.
The frame buffer library,
.IR libfb\^ (3),
can also be used to free programs of hardware dependence.
.P
The following routines are used to decode an
RLE
file into a raster image:
.P
.I Rle_rhdr\^
will seek to the beginning of the given input
.I stream\^
and read the
setup information in the
RLE
header.
This routine
must be called first when decoding an
RLE
file.
If
.I bgpixel\^
is not
.BR \s-1NULL\s0 ,
the background color stored in the
RLE
header will be placed there.
.I Flags\^
is a flag word using a combination of single-bit flags
.BR \s-1NO_BOX_SAVE\s0 ,
.BR \s-1NO_COLORMAP\s0 ,
and
.B
.SM NO_IMAGE
(described in
.BR rle.h )
to indicate whether the image was saved with background,
whether the color map was saved,
and whether the image was saved or just the color map.
If the color map was saved,
.I rle_rmap\^
must be used next to read the color map from the
RLE
file and decode it into the buffer
pointed to by
.IR cmap\^ .
.I Rle_rlen
and
.I rle_rpos
are used after
.I rle_rhdr
to retrieve, from the header structure, the length and position of the image
in the locations specified by
.IR xlen\^ ,
.IR ylen\^ ,
.I xpos\^
and
.IR ypos\^ .
.P
.I Rle_decode_ln\^
is used to decode the next scanline (starting at the bottom) and
should be passed the address of a
.I scanline_buffer\^
large enough to store
.I xlen\^
plus
.I xpos\^
pixels.
Only foreground pixels are written;
it is the caller's responsibility
to fill the buffer first with the appropriate background.
If no
foreground pixels occur, zero is returned;
otherwise 1 is returned
to indicate that the buffer has been altered.
.P
The following routines are used to compress a raster image into an
RLE
file:
.P
.I Rle_whdr\^
is used first to specify the encoding scheme to use and to
write the
RLE
header which will contain this information
to the given output
.IR stream\^ .
The
.I ncolors\^
parameter specifies the number of color channels.
Normally, this should
be set to
.B \s-1\&3\s0
(for red, green, and blue channels).
If
.I ncolors\^
equals
.BR \s-1\&1\s0 ,
a monochrome (black and white) image is assumed, and if
it is
.BR \s-1\&0\s0 ,
only the color map will be saved.
.I Bgflag\^
specifies whether or not the image is saved with the background.
If
.I bgflag\^
is nonzero, only the foreground image is saved.
If
.I bgflag\^
is zero,
the entire image is encoded.
.I Rle_whdr\^
stores the background color along with the other setup information.
If a monochrome image has been specified, the
NTSC
standard is used to calculate the background color from
.IR bgpixel\^ ;
otherwise
.I bgpixel\^
is used as the background color.
.I Cmflag\^
is nonzero to indicate that the color map is to be saved, and this is
accomplished with
.I rle_wmap\^
which must be used next to encode the color map pointed to by
.I cmap\^
and write it to the
RLE
file.
If the value of
.I cmap\^
is
.BR \s-1NULL\s0 ,
a standard (linear) color map will be written.
.P
.I Rle_encode_ln\^
is used to encode the next scanline (starting at the bottom) and
should be passed the address of a
.I scanline_buffer\^
containing the pixels to be converted.
.P
The
.I Pixel\^
and
.I ColorMap\^
data types are defined in
.BR fb.h .
The color map and scanlines can be conveniently read from or written to
a file or supported frame buffer with compatible functions found in
.IR libfb\^ (3).
.SH WARNINGS
The current version of this library reads Edition-1 and Edition-2
RLE files.
The University of Utah is currently preparing Edition-3 of
this format.
All encoding is in Edition-2 format.
Note that Edition-1 formats are byte-order sensitive, so that they
cannot be transported around the network with
.IR rcp (1)
with abandon.
.P
The
RLE
files must be decoded seqentially from the bottom up, as it is the convention
that the origin be the lower left corner of the screen.
.I Rle_decode_ln\^
should fail if called more than
.I ylen\^
times, as it will attempt to read past the end of the input file.
Encoding an
RLE
file from the top down is considered anti-social behavior and will lead
to confusion if the installed frame buffer utilities are used.
.P
The library functions must be used
\fIin sequence\fR to read/write the header, followed
by the color map (if one exists) and then the image.
It is safe to process multiple images as long as the proper sequence
is followed.
Both
.I rle_rhdr\^
and
.I rle_whdr\^
seek to the beginning of
.I stream\^
before performing any I/O, but all other functions rely on sequential
read/write operations on the
RLE
file.
.P
Processing two images asynchronously is not recommended;
that is,
you should finish one before you begin the next.
The problem stems from the fact that some global information is stored by
.IR rle_rhdr\^ ,
and this information is clobbered by subsequent calls.
Therefore,
when switching back to an image that is partially decoded, the file offset
must be determined with
.IR ftell\^ (3S);
then
.I rle_rhdr\^
can be invoked again to set up things, and finally
.IR fseek\^ (3S)
can be used to reposition the file pointer.
.SH EXAMPLE
The library may be loaded as follows:
.RS
\|\fIcc \|program.c \|\-lrle.a\fP
.RE
.SH "SEE ALSO"
rle-fb(1), fb-rle(1),
libfb(3).
.SH DIAGNOSTICS
Upon error, all functions print a message and return \-1.
.SH AUTHORS
Gary S. Moss, BRL
.br
Mike J. Muuss, BRL
.br
Spencer W. Thomas, U. of Utah
.SH WARNING
This library is now obsolete.  The new library is
compatible with the Utah Raster Toolkit, and now bears the name ``librle''.
.SH BUGS
It would be nice to fix the problem of asynchronous calls by passing a
pointer to storage for the setup structure to the read/write header and
read/write scanline routines so that there is no global information
to contend with.
.SH SOURCE
SECAD/VLD Computing Consortium, Bldg 394
.br
The U. S. Army Ballistic Research Laboratory
.br
Aberdeen Proving Ground, Maryland  21005
.SH "BUG REPORTS"
Reports of bugs or problems should be submitted via electronic
mail to <CAD@@ARL.ARMY.MIL>.
@


11.2
log
@Corrected email address
@
text
@@


11.1
log
@Release_4.4
@
text
@d298 1
a298 1
mail to <CAD@@BRL.MIL>.
@


11.1.6.1
log
@sync branch with HEAD
@
text
@d298 1
a298 1
mail to <CAD@@ARL.ARMY.MIL>.
@


11.1.8.1
log
@sync to HEAD...
@
text
@d298 1
a298 1
mail to <CAD@@ARL.ARMY.MIL>.
@


10.1
log
@Release_4.0
@
text
@@


9.3
log
@fixed typo
@
text
@@


9.2
log
@fixed authorships
@
text
@d218 1
a218 1
can not be transported around the network with
@


9.1
log
@Release_3.5
@
text
@d277 1
a277 1
Gary S. Moss, BRL/VLD-VMB
d279 1
a279 1
Mike J. Muuss, BRL/SECAD
@


8.2
log
@-> liborle
@
text
@@


8.1
log
@Release_3.0
@
text
@d1 1
a1 1
.TH LIBRLE 3 BRL/CAD
d3 1
a3 1
librle \- run-length encoded image library
d282 3
@


7.2
log
@changed .ARPA to .MIL
@
text
@@


7.1
log
@Release 2.3
@
text
@d295 1
a295 1
mail to <CAD@@BRL.ARPA>.
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


1.8
log
@Release 1.20 -- First Formal Release
@
text
@@


1.7
log
@Pulled length and position parameters out of header access routines.
rle_whdr() and rle_rhdr() and added seperate access routines to set those parameters.
@
text
@d1 1
a1 3
.TH LIBRLE 3V VMB
'\"	last edit:	85/08/15	G S Moss
'\"	SCCS ID:	@@(#)librle.3	1.7
d6 2
a7 2
.B #include ``/vld/include/rle.h''
.B #include ``/vld/include/fb.h''
d63 1
a63 1
.IR libfb\^ (3V),
d210 1
a210 1
.IR libfb\^ (3V).
d212 10
d234 3
a236 1
The functions must be used in sequence to read/write the header, followed
d269 1
a269 1
$ \|\fIcc \|\-I/vld/include \|program.c \|\/vld/lib/librle.a\fP
a270 6
.SH FILES
/vld/include/rle.h
.br
/vld/include/fb.h
.br
/vld/lib/librle.a
d272 2
a273 1
libfb(3V).
d276 1
a276 1
.SH AUTHOR
d287 9
@


1.6
log
@*** empty log message ***
@
text
@d2 2
a3 2
'\"	last edit:	85/05/22	D A Gwyn
'\"	SCCS ID:	@@(#)librle.3	1.6
d11 1
a11 1
.B "int rle_rhdr( stream, flags, bgpixel, xsize, ysize, xpos, ypos )"
a14 2
.B int *xsize, *ysize;
.B int *xpos, *ypos;
d20 12
a89 10
The horizontal and vertical dimensions of the
image (in pixels) will be placed in
.I xsize\^
and
.IR ysize\^ ,
and the coordinates of the lower left corner of the image will be stored
in
.I xpos\^
and
.IR ypos\^ .
d109 12
d127 3
a129 1
.I xsize\^
d220 1
a220 1
.I ysize\^
@


1.5
log
@overhaul for VMB manual
@
text
@d3 1
a3 1
'\"	SCCS ID:	@@(#)librle.3	1.5
d91 1
a91 1
is a flag word using bit flags
d141 1
a141 1
.B 3
d145 6
a150 2
equals 1, a monochrome (black and white) image is assumed, and if
it is 0, only the color map will be saved.
d256 1
a256 1
All functions print a message and return a -1 upon error.
@


1.4
log
@Looks OK.
@
text
@d2 2
a3 2
'\"	last edit:	85/03/26	G. S. Moss
'\"	SCCS ID:	@@(#)librle.3	1.4
d11 1
a11 1
\fBint rle_rhdr( stream, flags, bgpixel, xsize, ysize, xpos, ypos )\fR
d18 1
a18 1
\fBrle_whdr( stream, ncolors, bgflag, cmflag, bgpixel )\fR
d37 1
a37 1
.P
d40 1
a40 1
\fIUniversity of Utah\fR format \fIRun-Length Encoded\fR (RLE) files
d42 1
a42 2
.B
.SM C
d44 2
a45 3
There are seperate routines for reading or writing the
.B
.SM RLE
d47 8
a54 7
or writing the encoded color map and decoding or encoding a scanline of a
raster image.  The program that loads this library can be ignorant of the
.B
.SM RLE
scheme being used.  This library does not need to know anything about
the framebuffer hardware being used.
The framebuffer library,
d56 1
a56 1
can be used to free the program of hardware dependence.
d58 3
a60 4
These routines are used to decode an
.B
.SM RLE
file into a raster image.
d63 7
a69 5
will seek to the beginning of the named input stream and reads the
set up information in the
.B
.SM RLE
header.  This routine
d71 1
a71 2
.B
.SM RLE
d76 1
a76 2
.B
.SM NULL,
a77 2
.B
.SM
d79 3
a81 2
header will be placed there.  The horizontal and vertical dimension of the
image in pixels will be placed in
d92 2
a93 4
.B
.SM NO_BOX_SAVE,
.B
.SM NO_COLORMAP,
d99 1
a99 1
to indicate whether or not the image was saved with background,
d101 1
a101 1
and whether or not the image was saved (or just the color map).
d105 1
a105 2
.B
.SM RLE
d108 1
a108 1
.I cmap\^.
d112 1
a112 1
should be passed the address of
d117 6
a122 3
Only foreground pixels are written, it is the caller's responsibility
to fill the buffer first with the appropriate background.  If no
foreground pixels occur, zero is returned, otherwise 1 is returned
d125 3
a127 4
These routines are used to compress a raster image into an
.B
.SM RLE
file.
d132 4
a135 3
.B
.SM RLE
header to the named output stream which will contain this information.
d138 6
a143 2
parameter specifies the number of color channels.  Normally, this should
be set to 3 for red, green, and blue channels.  If
d147 3
a149 1
The
d151 2
a152 1
specifies whether or not the image is saved with the background.  If
d154 1
a154 1
is set, only the foreground image is saved.  If the flag is reset,
d157 1
a157 1
stores the background color along with the other set up information.
d159 1
a159 2
.B
.SM NTSC
d161 1
a161 1
.IR bgpixel\^ ,
d165 2
a166 3
The
.I cmflag\^
is used to indicate that the color map is to be saved and this is
d172 3
a174 3
.B
.SM RLE
file.  If the value of
d177 1
a177 2
.B
.SM NULL,
d182 1
a182 1
should be passed the address of
d184 1
a184 1
which contains the pixels to be converted.
d192 3
a194 3
The color map and scanlines can be conveniently read or written from
a file or supported framebuffer with compatible functions found in
.IR libfb (3V).
d197 2
a198 3
.B
.SM RLE
files must be decoded seqentially from the bottom, up as it is the convention
d203 1
a203 1
times as it will attempt to read past the end of the input file.
d205 3
a207 4
.B
.SM RLE
file from the top, down is considered anti-social behavior and will lead
to confusion if the installed utilities are used.
d210 1
a210 1
It is fine to process multiple images as long as the proper sequence
d220 5
a224 3
.B
.SM RLE
file.  It is not recommended to process 2 images asynchronously, that is,
d228 1
a228 1
which is clobbered by subsequent calls.
d230 1
a230 1
if switching back to an image that is partially decoded, the file offset
d232 2
a233 2
.IR ftell\^ (3)
and then
d235 3
a237 8
can be envoked again to set up things and finally
.IR fseek\^ (3)
used to reposition the file pointer.
.SH DISCUSSION
It would be nice to fix the problem of asynchronous calls by passing a
pointer to storage for the set up structure to the read/write header and
read/write scanline routines so that there is no global information
to contend with.
d250 1
a250 1
libfb(3V)
d252 1
a252 1
All functions will print a message and return a -1 upon error.
d255 1
d257 1
d259 5
@


1.3
log
@Finished manual page, encoding stuff produces new extended RLE format.
@
text
@d2 2
a3 2
'\"	last edit:	85/03/25	G. S. Moss
'\"	SCCS ID:	@@(#)librle.3	1.3
d11 1
a11 1
\fBint rle_rhdr( stream, cmflag, bgpixel, xsize, ysize, xpos, ypos )\fR
d13 1
a13 1
.B int *cmflag;
d93 15
a107 3
.I Cmflag\^
will be set to indicate whether or not a color map is present.  If it is
set,
d172 6
a177 1
file.
@


1.2
log
@Looks ok.
@
text
@d2 2
a3 2
'\"	last edit:	85/03/22	G. S. Moss
'\"	SCCS ID:	@@(#)librle.3	1.2
d18 1
a18 1
\fBrle_whdr( stream, bwflag, bgflag, cmflag, bgpixel )\fR
d126 1
a126 4
header to the name output stream which will contain this information.
If
.I bwflag\^
is set, the image will saved as monochrome.
d128 7
d142 1
a142 3
If the
.I bwflag\^
is set, the
d149 1
a149 1
is used.
d206 3
a208 3
file.
The main problem would occur in decoding 2 images
asynchronously.  Since some global information is stored by
d210 2
d220 5
d242 2
@


1.1
log
@Initial revision
@
text
@d1 3
a3 5
'\" te	(causes both "tbl" and "eqn" to be invoked)
'\"	man_tem -- template for VMB software manual entry
.TH COMMAND 1V VMB
'\"	last edit:	85/03/22	Your name
'\"	SCCS ID:	@@(#)librle.3	1.1
d5 1
a5 1
command \- perform some action
d7 31
a37 4
.B command
[
.B \-x
] arg ...
d39 19
a57 2
.I Command\^
performs the following actions...
d59 79
d139 79
a217 30
.B \-x
option is supplied,
.I command\^
also does something else...
.SH DEFINITIONS
Special
.I terms\^
are defined here.
(This section should seldom be required.)
.SH DISCUSSION
Here is the theory of operation, \fIetc.\^\fR ...
(This section is rarely useful.)
.SH HINT(S)
This program is tricky.
Here are some helpful hints ...
(This section is rarely needed.)
.SH CAVEAT(S)
These are things to watch out for,
but are not actual problems ...
(This section is rare.)
.SH WARNING(S)
You can get in trouble
if you don't look out for ...
(This section is optional.)
.SH RESTRICTIONS
This program is not fully general ...
(This section is optional.)
.SH EXAMPLE(S)
The following invocation
does something neat:
d219 1
a219 8
$ \|\fIcommand \|\-x \|arg1 \|arg2
.br
User input is in italics.
.br
^D\fR
.br
Computer output is in roman font.
'\" Only show computer output if it is helpful.
d222 1
a222 1
.RI /usr/tmp/cmd ???
d224 3
a226 1
/vld/lib/man_tem
d228 1
a228 2
ash(1V), man(1), troff(1), man(5).
'\" All VMB documents have a "V" following the section number.
d230 3
a232 21
Errors cause the message
``Wow! I'm confused''
to be printed on the standard error output
and the following behavior ...
(This section may be omitted if errors ``can't happen''.)
.SH "EXIT CODES"
Exit status 0 is returned if the
.I command\^
succeeds;
otherwise various non-zero values
are returned.
(If this section is omitted,
then the
.I command\^
is assumed to return 0 status when it succeeds
and small positive non-zero values when it fails.)
.SH AUTHOR(S)
Your name, BRL/VLD-VMB
.SH BUGS
The following deficiencies are known ...
(This section may be omitted if there are no bugs.)
@
