head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	ansi-20040316-freeze:11.4.2.1
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.24.04.13.10;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.07.52.17;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.07.28;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.54.41;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2001.08.09.17.45.24;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.13.54;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.23.19.29.09;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.49.39;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	90.11.26.11.19.48;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.12.13;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.50.08;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.03.00.10.48;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.14.19;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.45.27;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.52.36;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.51.41;	author mike;	state Rel1;
branches;
next	1.3;

1.3
date	86.12.26.22.36.57;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.11.12.23.04.36;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.11.10.23.10.41;	author mike;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.00.50;	author morrison;	state Exp;
branches;
next	;


desc
@Gary Moss' Original Version
@


11.7
log
@moved to src/fbed/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6651 or DSN 298-6651
*/
#if ! defined( lint )
static const char RCSid[] = "@@(#) getinput.c 2.1, modified 12/9/86 at 15:56:41, archive /vld/moss/src/fbed/s.getinput.c";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "fb.h"

#include "./std.h"
#include "./ascii.h"
#include "./font.h"
#include "./try.h"
#include "./extern.h"

extern char *char_To_String(int i);

void
ring_Bell(void)
{
	(void) putchar( BEL );
	return;
	}

/*	g e t _ I n p u t ( )
	Get a line of input.
 */
int
get_Input(char *inbuf, int bufsz, char *msg)
{	static char buffer[BUFSIZ];
		register char *p = buffer;
		register int c;
	if( *cptr != NUL && *cptr != '@@' )
		{
		for( ; *cptr != NUL && *cptr != CR && *cptr != LF; cptr++ )
			{
			if( p - buffer >= BUFSIZ )
				{
				ring_Bell();
				fb_log( "get_Input() over-ran internal buffer.\n" );
				prnt_Prompt( "" );
				buffer[BUFSIZ-1] = NUL;
				return 0;
				}
			if( *cptr != Ctrl('V') )
				*p++ = *cptr;
			else
				*p++ = *++cptr;
			}
		if( *cptr == CR || *cptr == LF )
			cptr++;
		*p = NUL;
		(void) strncpy( inbuf, buffer, bufsz );
		return 1;
		}
	else
	/* Skip over '@@' and LF, which means "prompt user". */
	if( *cptr == '@@' )
		cptr += 2;
	prnt_Prompt( msg );
	*p = NUL;
	do
		{
		(void) fflush( stdout );
		c = get_Char();
		if( remembering )
			{
			*macro_ptr++ = c;
			*macro_ptr = NUL;
			}
		switch( c )
			{
		case Ctrl('A') : /* Cursor to beginning of line. */
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			for( ; p > buffer; p-- )
				(void) putchar( BS );
			break;
		case Ctrl('B') :
		case BS : /* Move cursor back one character. */
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			(void) putchar( BS );
			--p;
			break;
		case Ctrl('D') : /* Delete character under cursor. */
			{	register char *q = p;
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			for( ; *q != NUL; ++q )
				{
				*q = *(q+1);
				(void) putchar( *q != NUL ? *q : SP );
				}
			for( ; q > p; --q )
				(void) putchar( BS );
			break;
			}
		case Ctrl('E') : /* Cursor to end of line. */
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			(void) printf( "%s", p );
			p += strlen( p );
			break;
		case Ctrl('F') : /* Cursor forward one character. */
			if( *p == NUL || p-buffer >= bufsz-2 )
				{
				ring_Bell();
				break;
				}
			putchar( *p++ );
			break;
		case Ctrl('G') : /* Abort input. */
			ring_Bell();
			fb_log( "Aborted.\n" );
			prnt_Prompt( "" );
			return 0;
		case Ctrl('K') : /* Erase from cursor to end of line. */
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			ClrEOL();
			*p = NUL;
			break;
		case Ctrl('P') : /* Yank previous contents of "inbuf". */
			{	register int len = strlen( inbuf );
			if( (p + len) - buffer >= BUFSIZ )
				{
				ring_Bell();
				break;
				}
			(void) strncpy( p, inbuf, bufsz );
			(void) printf( "%s", p );
			p += len;
			break;
			}
		case Ctrl('U') : /* Erase from start of line to cursor. */
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			for( ; p > buffer; --p )
				{	register char *q = p;
				(void) putchar( BS );
				for( ; *(q-1) != NUL; ++q )
					{
					*(q-1) = *q;
					(void) putchar( *q != NUL ? *q : SP );
					}
				for( ; q > p; --q )
					(void) putchar( BS );
				}
			break;
		case Ctrl('R') : /* Print line, cursor doesn't move. */
			{	register int i;
			if( buffer[0] == NUL )
				break;
			for( i = p - buffer; i > 0; i-- )
				(void) putchar( BS );
			(void) printf( "%s", buffer );
			for( i = strlen( buffer ) - (p - buffer); i > 0; i-- )
				(void) putchar( BS );
			break;
			}
		case DEL : /* Delete character behind cursor. */
			{	register char *q = p;
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			(void) putchar( BS );
			for( ; *(q-1) != NUL; ++q )
				{
				*(q-1) = *q;
				(void) putchar( *q != NUL ? *q : SP );
				}
			for( ; q > p; --q )
				(void) putchar( BS );
			p--;
			break;
			}
		case CR :
		case LF :
		case EOF :
			(void) strncpy( inbuf, buffer, bufsz );
			prnt_Prompt( "" );
			return 1;
		case Ctrl('V') :
			/* Escape character, do not process next char. */
			c = get_Char();
			if( remembering )
				{
				*macro_ptr++ = c;
				*macro_ptr = NUL;
				}
			/* Fall through to default case! */
		default : /* Insert character at cursor. */
			{	register char *q = p;
				register int len = strlen( p );
			/* Print control characters as strings. */
			if( c >= NUL && c < SP )
				(void) printf( "%s", char_To_String( c ) );
			else
				(void) putchar( c );
			/* Scroll characters forward. */
			for( ; len >= 0; len--, q++ )
				(void) putchar( *q == NUL ? SP : *q );
			for( ; q > p; q-- )
				{
				(void) putchar( BS );
				*q = *(q-1);
				}
			*p++ = c;
			break;
			}
			} /* End switch. */
		}
	while( strlen( buffer ) < BUFSIZ );
	(void) strncpy( inbuf, buffer, bufsz );
	ring_Bell();
	fb_log( "Buffer full.\n" );
	prnt_Prompt( "" );
	return 0;
	}

/*	g e t _ F u n c _ N a m e ( )
	TENEX-style command completion.
 */
Func_Tab *
get_Func_Name(char *inbuf, int bufsz, char *msg)
{	extern Try	*try_rootp;
		extern Func_Tab	*get_Try(register char *name, register Try *tryp);
		static char buffer[BUFSIZ];
		register char *p = buffer;
		register int c;
		Func_Tab	*ftbl = FT_NULL;
	if( *cptr != NUL && *cptr != '@@' )
		{
		for( ; *cptr != NUL && *cptr != CR && *cptr != LF; cptr++ )
			{
			if( p - buffer >= BUFSIZ )
				{
				ring_Bell();
				fb_log( "get_Func_Name() over-ran internal buffer.\n" );
				prnt_Prompt( "" );
				buffer[BUFSIZ-1] = NUL;
				return 0;
				}
			if( *cptr != Ctrl('V') )
				*p++ = *cptr;
			else
				*p++ = *++cptr;
			}
		if( *cptr == CR || *cptr == LF )
			cptr++;
		*p = NUL;
		if( (ftbl = get_Try( buffer, try_rootp )) == FT_NULL )
			(void) putchar( BEL );
		else
			(void) strncpy( inbuf, buffer, bufsz );
		return ftbl;
		}
	else
	/* Skip over '@@' and LF, which means "prompt user". */
	if( *cptr == '@@' )
		cptr += 2;
	prnt_Prompt( msg );
	*p = NUL;
	do
		{
		(void) fflush( stdout );
		c = get_Char();
		if( remembering )
			{
			*macro_ptr++ = c;
			*macro_ptr = NUL;
			}
		switch( c )
			{
		case SP :
			{
			if( (ftbl = get_Try( buffer, try_rootp )) == FT_NULL )
				(void) putchar( BEL );
			for( ; p > buffer; p-- )
				(void) putchar( BS );
			(void) printf( "%s", buffer );
			(void) ClrEOL();
			(void) fflush( stdout );
			p += strlen( buffer );
			break;
			}
		case Ctrl('A') : /* Cursor to beginning of line. */
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			for( ; p > buffer; p-- )
				(void) putchar( BS );
			break;
		case Ctrl('B') :
		case BS : /* Move cursor back one character. */
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			(void) putchar( BS );
			--p;
			break;
		case Ctrl('D') : /* Delete character under cursor. */
			{	register char *q = p;
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			for( ; *q != NUL; ++q )
				{
				*q = *(q+1);
				(void) putchar( *q != NUL ? *q : SP );
				}
			for( ; q > p; --q )
				(void) putchar( BS );
			break;
			}
		case Ctrl('E') : /* Cursor to end of line. */
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			(void) printf( "%s", p );
			p += strlen( p );
			break;
		case Ctrl('F') : /* Cursor forward one character. */
			if( *p == NUL || p-buffer >= bufsz-2 )
				{
				ring_Bell();
				break;
				}
			putchar( *p++ );
			break;
		case Ctrl('G') : /* Abort input. */
			ring_Bell();
			fb_log( "Aborted.\n" );
			prnt_Prompt( "" );
			return ftbl;
		case Ctrl('K') : /* Erase from cursor to end of line. */
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			ClrEOL();
			*p = NUL;
			break;
		case Ctrl('P') : /* Yank previous contents of "inbuf". */
			{	register int len = strlen( inbuf );
			if( (p + len) - buffer >= BUFSIZ )
				{
				ring_Bell();
				break;
				}
			(void) strncpy( p, inbuf, bufsz );
			(void) printf( "%s", p );
			p += len;
			break;
			}
		case Ctrl('U') : /* Erase from start of line to cursor. */
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			for( ; p > buffer; --p )
				{	register char *q = p;
				(void) putchar( BS );
				for( ; *(q-1) != NUL; ++q )
					{
					*(q-1) = *q;
					(void) putchar( *q != NUL ? *q : SP );
					}
				for( ; q > p; --q )
					(void) putchar( BS );
				}
			break;
		case Ctrl('R') : /* Print line, cursor doesn't move. */
			{	register int i;
			if( buffer[0] == NUL )
				break;
			for( i = p - buffer; i > 0; i-- )
				(void) putchar( BS );
			(void) printf( "%s", buffer );
			for( i = strlen( buffer ) - (p - buffer); i > 0; i-- )
				(void) putchar( BS );
			break;
			}
		case DEL : /* Delete character behind cursor. */
			{	register char *q = p;
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			(void) putchar( BS );
			for( ; *(q-1) != NUL; ++q )
				{
				*(q-1) = *q;
				(void) putchar( *q != NUL ? *q : SP );
				}
			for( ; q > p; --q )
				(void) putchar( BS );
			p--;
			break;
			}
		case CR :
		case LF :
		case EOF :
			if( (ftbl = get_Try( buffer, try_rootp )) == FT_NULL )
				{
				(void) putchar( BEL );
				break;
				}
			else
				{
				(void) strncpy( inbuf, buffer, bufsz );
				prnt_Prompt( "" );
				prnt_Event( "" );
				return ftbl;
				}
		case Ctrl('V') :
			/* Escape character, do not process next char. */
			c = get_Char();
			if( remembering )
				{
				*macro_ptr++ = c;
				*macro_ptr = NUL;
				}
			/* Fall through to default case! */
		default : /* Insert character at cursor. */
			{	register char *q = p;
				register int len = strlen( p );
			/* Scroll characters forward. */
			if( c >= NUL && c < SP )
				(void) printf( "%s", char_To_String( c ) );
			else
				(void) putchar( c );
			for( ; len >= 0; len--, q++ )
				(void) putchar( *q == NUL ? SP : *q );
			for( ; q > p; q-- )
				{
				(void) putchar( BS );
				*q = *(q-1);
				}
			*p++ = c;
			break;
			}
			} /* End switch. */
		}
	while( strlen( buffer ) < BUFSIZ);
	ring_Bell();
	fb_log( "Buffer full.\n" );
	prnt_Prompt( "" );
	return ftbl;
	}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@@


11.5
log
@merge of ansi-6-0-branch into HEAD
@
text
@d12 5
a16 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d32 1
a32 1
extern char *char_To_String();
d35 2
a36 2
ring_Bell()
	{
d45 2
a46 5
get_Input( inbuf, bufsz, msg )
char  *inbuf;
int  bufsz;
char *msg;
	{	static char buffer[BUFSIZ];
d262 3
a264 6
get_Func_Name( inbuf, bufsz, msg )
char  *inbuf;
int  bufsz;
char *msg;
	{	extern Try	*try_rootp;
		extern Func_Tab	*get_Try();
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d32 1
a32 1
extern char *char_To_String(int i);
d35 2
a36 2
ring_Bell(void)
{
d45 5
a49 2
get_Input(char *inbuf, int bufsz, char *msg)
{	static char buffer[BUFSIZ];
d265 6
a270 3
get_Func_Name(char *inbuf, int bufsz, char *msg)
{	extern Try	*try_rootp;
		extern Func_Tab	*get_Try(register char *name, register Try *tryp);
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d32 1
a32 1
extern char *char_To_String(int i);
d35 2
a36 2
ring_Bell(void)
{
d45 5
a49 2
get_Input(char *inbuf, int bufsz, char *msg)
{	static char buffer[BUFSIZ];
d265 6
a270 3
get_Func_Name(char *inbuf, int bufsz, char *msg)
{	extern Try	*try_rootp;
		extern Func_Tab	*get_Try(register char *name, register Try *tryp);
@


11.2
log
@Lint
@
text
@d32 1
a32 1
extern char *char_To_String();
d35 2
a36 2
ring_Bell()
	{
d45 2
a46 5
get_Input( inbuf, bufsz, msg )
char  *inbuf;
int  bufsz;
char *msg;
	{	static char buffer[BUFSIZ];
d262 3
a264 6
get_Func_Name( inbuf, bufsz, msg )
char  *inbuf;
int  bufsz;
char *msg;
	{	extern Try	*try_rootp;
		extern Func_Tab	*get_Try();
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 2
static
char sccsTag[] = "@@(#) getinput.c 2.1, modified 12/9/86 at 15:56:41, archive /vld/moss/src/fbed/s.getinput.c";
d16 6
d44 1
@


10.2
log
@Made includes explicit
@
text
@@


10.1
log
@Release_4.0
@
text
@d13 2
d16 9
@


9.2
log
@Added some commands: draw-rectangle, fill-bounded-region, print-comment,
	change-region-color, set-tolerance-color-match.
Also, default rectangle is entire window.
Checked in for release 4.0.
@
text
@@


9.1
log
@Release_3.5
@
text
@a1 5
	SCCS id:	@@(#) getinput.c	2.1
	Modified: 	12/9/86 at 15:56:41
	Retrieved: 	12/26/86 at 21:54:22
	SCCS archive:	/vld/moss/src/fbed/s.getinput.c

d6 1
a6 1
			(301)278-6647 or AV-298-6647
d10 1
a10 1
char	sccsTag[] = "@@(#) getinput.c 2.1, modified 12/9/86 at 15:56:41, archive /vld/moss/src/fbed/s.getinput.c";
d16 1
a16 1
extern char	*char_To_String();
d29 6
a34 6
char	 *inbuf;
int	 bufsz;
char	*msg;
	{	static char	buffer[BUFSIZ];
		register char	*p = buffer;
		register int	c;
d45 1
a45 1
				return	0;
d56 1
a56 1
		return	1;
d59 1
a59 1
	/* Skip over '@@' and LF, which means "prompt user".		*/
d75 1
a75 1
		case Ctrl('A') : /* Cursor to beginning of line.	*/
d85 1
a85 1
		case BS : /* Move cursor back one character.		*/
d94 2
a95 2
		case Ctrl('D') : /* Delete character under cursor.	*/
			{	register char	*q = p;
d110 1
a110 1
		case Ctrl('E') : /* Cursor to end of line.		*/
d119 1
a119 1
		case Ctrl('F') : /* Cursor forward one character.	*/
d127 1
a127 1
		case Ctrl('G') : /* Abort input.			*/
d131 2
a132 2
			return	0;
		case Ctrl('K') : /* Erase from cursor to end of line.	*/
d141 2
a142 2
		case Ctrl('P') : /* Yank previous contents of "inbuf".	*/
			{	register int	len = strlen( inbuf );
d153 1
a153 1
		case Ctrl('U') : /* Erase from start of line to cursor.	*/
d160 1
a160 1
				{	register char	*q = p;
d171 2
a172 2
		case Ctrl('R') : /* Print line, cursor doesn't move.	*/
			{	register int	i;
d182 2
a183 2
		case DEL : /* Delete character behind cursor.		*/
			{	register char	*q = p;
d205 1
a205 1
			return	1;
d207 1
a207 1
			/* Escape character, do not process next char.	*/
d214 5
a218 5
			/* Fall through to default case!		*/
		default : /* Insert character at cursor.		*/
			{	register char	*q = p;
				register int	len = strlen( p );
			/* Print control characters as strings.		*/
d223 1
a223 1
			/* Scroll characters forward.			*/
d241 1
a241 1
	return	0;
d249 3
a251 3
char	 *inbuf;
int	 bufsz;
char	*msg;
d254 3
a256 3
		static char	buffer[BUFSIZ];
		register char	*p = buffer;
		register int	c;
d268 1
a268 1
				return	0;
d282 1
a282 1
		return	ftbl;
d285 1
a285 1
	/* Skip over '@@' and LF, which means "prompt user".		*/
d313 1
a313 1
		case Ctrl('A') : /* Cursor to beginning of line.	*/
d323 1
a323 1
		case BS : /* Move cursor back one character.		*/
d332 2
a333 2
		case Ctrl('D') : /* Delete character under cursor.	*/
			{	register char	*q = p;
d348 1
a348 1
		case Ctrl('E') : /* Cursor to end of line.		*/
d357 1
a357 1
		case Ctrl('F') : /* Cursor forward one character.	*/
d365 1
a365 1
		case Ctrl('G') : /* Abort input.			*/
d369 2
a370 2
			return	ftbl;
		case Ctrl('K') : /* Erase from cursor to end of line.	*/
d379 2
a380 2
		case Ctrl('P') : /* Yank previous contents of "inbuf".	*/
			{	register int	len = strlen( inbuf );
d391 1
a391 1
		case Ctrl('U') : /* Erase from start of line to cursor.	*/
d398 1
a398 1
				{	register char	*q = p;
d409 2
a410 2
		case Ctrl('R') : /* Print line, cursor doesn't move.	*/
			{	register int	i;
d420 2
a421 2
		case DEL : /* Delete character behind cursor.		*/
			{	register char	*q = p;
d451 1
a451 1
				return	ftbl;
d454 1
a454 1
			/* Escape character, do not process next char.	*/
d461 5
a465 5
			/* Fall through to default case!		*/
		default : /* Insert character at cursor.		*/
			{	register char	*q = p;
				register int	len = strlen( p );
			/* Scroll characters forward.			*/
d486 1
a486 1
	return	ftbl;
@


8.1
log
@Release_3.0
@
text
@@


7.1
log
@Release 2.3
@
text
@@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@@


1.3
log
@Latest version from Gary Moss
@
text
@@


1.2
log
@First version that compiles
@
text
@d2 4
a5 4
	SCCS id:	%Z% %M%	%I%
	Last edit: 	%G% at %U%
	Retrieved: 	%H% at %T%
	SCCS archive:	%P%
d10 3
a12 3
			Maryland 21005
			(301)278-6647 or AV-283-6647
 */
d15 1
a15 1
char	sccsTag[] = "%Z% %M%	%I%	last edit %G% at %U%";
d17 1
a18 2
#include "./ascii.h"
#include "./try.h"
d44 8
d72 1
a72 1
		c = getchar();
d134 1
a134 1
			prnt_Debug( "Aborted." );
d213 1
a213 1
			c = getchar();
d244 1
a244 1
	prnt_Debug( "Buffer full." );
d267 8
d298 1
a298 1
		c = getchar();
d372 1
a372 1
			prnt_Debug( "Aborted." );
d455 1
a455 1
				prnt_Debug( "" );
d460 1
a460 1
			c = getchar();
d489 1
a489 1
	prnt_Debug( "Buffer full." );
@


1.1
log
@Initial revision
@
text
@d18 4
a21 3
#include <rt/ascii.h>
#include "try.h"
#include "extern.h"
@
