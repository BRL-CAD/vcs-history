head	11.10;
access;
symbols
	ansi-20040405-merged:11.7.2.1
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.7
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.7.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.7
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.5
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.24.04.13.10;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.52.17;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.07.27;	author jra;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2002.08.15.20.54.40;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.08.09.17.45.24;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.24.22.55.35;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.01.31.16.05.01;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.07.17.12.41.27;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.13.51;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.12.30.11.16.45;	author jra;	state Exp;
branches;
next	10.7;

10.7
date	94.12.30.11.07.54;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.11.24.02.22.26;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.23.19.46.31;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.10.26.02.55.44;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.11.17.09.03.17;	author moss;	state Exp;
branches;
next	10.2;

10.2
date	91.12.13.10.55.40;	author moss;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.49.36;	author mike;	state Rel4_0;
branches;
next	9.9;

9.9
date	91.08.30.21.17.10;	author moss;	state Exp;
branches;
next	9.8;

9.8
date	91.07.25.15.22.54;	author moss;	state Exp;
branches;
next	9.7;

9.7
date	91.07.09.02.51.43;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.07.01.22.52.55;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.06.12.22.47.33;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.05.02.15.41.56;	author moss;	state Exp;
branches;
next	9.3;

9.3
date	90.11.26.11.19.41;	author moss;	state Exp;
branches;
next	9.2;

9.2
date	89.05.22.12.05.02;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.12.07;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.03.20.11.53.20;	author moss;	state Exp;
branches;
next	8.3;

8.3
date	89.03.17.17.08.25;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	89.03.17.14.47.57;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.45.02;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.10.04.20.09.35;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	88.03.01.15.15.03;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.10.31;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.13.59;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.45.04;	author mike;	state Rel;
branches;
next	4.7;

4.7
date	87.06.22.14.51.58;	author moss;	state Exp;
branches;
next	4.6;

4.6
date	87.06.19.09.27.47;	author moss;	state Exp;
branches;
next	4.5;

4.5
date	87.02.13.00.52.21;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.01.07.14.58.44;	author moss;	state Exp;
branches;
next	4.3;

4.3
date	87.01.05.17.01.22;	author moss;	state Exp;
branches;
next	4.2;

4.2
date	86.12.30.17.46.48;	author mike;	state Rel1;
branches;
next	4.1;

4.1
date	86.12.29.02.51.27;	author mike;	state Rel1;
branches;
next	1.8;

1.8
date	86.12.26.22.36.35;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.12.01.04.26.41;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.12.01.04.23.38;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.12.01.02.16.32;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.11.15.09.44.14;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.11.13.03.28.14;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.11.12.23.04.09;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.11.10.23.10.34;	author mike;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.00.49;	author morrison;	state Exp;
branches;
next	;


desc
@Gary Moss' Original Version
@


11.10
log
@moved to src/fbed/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6651 or DSN 298-6651
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/fbed/fbed.c,v 11.9 2004/05/10 15:30:42 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>

#include "machine.h"
#include "externs.h"
#include "fb.h"

#include "./std.h"
#include "./ascii.h"
#include "./font.h"
#include "./try.h"
#include "./extern.h"

#if !defined(NSIG)
# define NSIG	64		/* conservative */
#endif

static struct
	{
	int xbits, ybits;
	int xorig, yorig;
	unsigned char bits[16*2];
	} cursor = {
		16, 16,
		8, 8,
#include "./cursorbits.h"
	};

#define JUMP		(40/zoom_factor)
#define CLR_LEN		12
#define PROMPT_LEN	MAX_LN

typedef struct pointstack PtStack;
struct pointstack
	{
	Point pt;
	PtStack *next;
	};


bool AproxEqColor(unsigned char a, unsigned char b, int t)
{	int	c = a-b;
	if( Abs( c ) > t )
		return false;
	else
		return true;
	}

#define AproxPixel(a,b,t) \
	(AproxEqColor((a)[RED],(b)[RED],t) && \
	 AproxEqColor((a)[GRN],(b)[GRN],t) && \
	 AproxEqColor((a)[BLU],(b)[BLU],t))
	
#define Fgets_Bomb() \
		fb_log( "\%s\"(%d) EOF encountered prematurely.\n", \
				__FILE__, __LINE__ ); \
		return 0;

#define EqPixel(a,b) \
	 ((a)[RED] == (b)[RED] && (a)[GRN] == (b)[GRN] && (a)[BLU] == (b)[BLU])

static Panel panel;	      /* Current panel. */
static Point bitpad;
static Rectangle current;     /* Current saved rectangle. */
static int step;	      /* Current step size. */
static int size_viewport;
static int last_key;
static int pointpicked;
static int tolerance = 0;

STATIC RGBpixel *pixel_Avg();
STATIC bool drawRectangle(Rectangle *rectp, unsigned char *pixelp);
STATIC bool getColor(unsigned char *pixelp, char *prompt, char *buffer);
STATIC bool paintNonBorder(unsigned char *borderpix, Point *pt);
STATIC bool paintSolidRegion(unsigned char *regionpix, Point *pt);
STATIC bool popPoint(Point *pt, register PtStack **spp);
STATIC int do_Bitpad(register Point *pointp);
STATIC int fb_Setup(void);
STATIC int pars_Argv(int argc, register char **argv);
STATIC int push_Macro(char *buf);
#if STD_SIGNAL_DECLS
STATIC void general_Handler(int sig);
#else
STATIC int general_Handler();
#endif
STATIC void init_Try(void);
STATIC void fb_Paint(register int x0, register int y0, register int x1, register int y1, RGBpixel (*color));
STATIC void fb_Wind(void);
STATIC void get_Point(char *msg, register Point *pointp);
STATIC void clip_Rectangle(register Rectangle *rectp);
STATIC void get_Rectangle(char *name, register Rectangle *rectp);
STATIC void fillRectangle(register Rectangle *rectp, register RGBpixel (*pixelp));
STATIC void fix_Rectangle(register Rectangle *rectp);
STATIC void pushPoint(Point *pt, PtStack **spp);
STATIC void put_Fb_Panel(register Rectangle *rectp, register RGBpixel (*panel));

STATIC int	/* ^X  */ f_Exec_Function(char *buf),
		/* ^I  */ f_Nop(char *buf),
		/* ^H  */ f_Win_Lft(char *buf),
		/* ^J  */ f_Win_Dwn(char *buf),
		/* ^K  */ f_Win_Up(char *buf),
		/* ^L  */ f_Win_Rgt(char *buf),
		/* ^M  */ f_Reset_View(char *buf),
		/* ^R  */ f_Redraw(char *buf),
		/* ^Z  */ f_Stop(char *buf),
		/* ESC */ f_Iterations(char *buf),
		/* SP  */ f_Press(char *buf),
		/* #   */ f_Comment(char *buf),
		/* ,   */ f_Dec_Brush_Size(char *buf),
		/* .   */ f_Inc_Brush_Size(char *buf),
		/* <   */ f_Dec_Step_Size(char *buf),
		/* >   */ f_Inc_Step_Size(char *buf),
		/* ?   */ f_Menu(char *buf),
		/* A   */ f_Start_Macro(char *buf),
		/* B   */ f_Bind_Macro_To_Key(char *buf),
		/* C   */ f_Crunch_Image(char *buf),
		/* E   */ f_Erase_Fb(char *buf),
		/* F   */ f_Flip_Resolution(char *buf),
		/* G   */ f_Get_Panel(char *buf),
		/* H   */ f_Jump_Lft(char *buf),
		/* J   */ f_Jump_Dwn(char *buf),
		/* K   */ f_Jump_Up(char *buf),
		/* L   */ f_Jump_Rgt(char *buf),
		/* N   */ f_Name_Keyboard_Macro(char *buf),
		/* P   */ f_Put_Panel(char *buf),
		/* R   */ f_Restore_RLE(char *buf),
		/* S   */ f_Save_RLE(char *buf),
		/* T   */ f_Transliterate(char *buf),
		/* U   */ f_Write_Macros_To_File(char *buf),
		/* V   */ f_FillRegion(char *buf),
		/* W   */ f_Fill_Panel(char *buf),
		/* X   */ f_Bind_Key_To_Key(char *buf),
		/* Y   */ f_Bind_Name_To_Key(char *buf),
		/* Z   */ f_Stop_Macro(char *buf),
		/* a   */ f_Enter_Macro_Definition(char *buf),
		/* b   */ f_Set_Rectangle(char *buf),
		/* c   */ f_Center_Window(char *buf),
		/* d   */ f_DrawLine(char *buf),
		/* f   */ f_Rd_Font(char *buf),
		/* g   */ f_Set_Pixel(char *buf),
		/* h   */ f_Move_Lft(char *buf),
		/* i   */ f_Zoom_In(char *buf),
		/* j   */ f_Move_Dwn(char *buf),
		/* k   */ f_Move_Up(char *buf),
		/* l   */ f_Move_Rgt(char *buf),
		/* m   */ f_Status_Monitor(char *buf),
		/* n   */ f_Tolerance(char *buf),
		/* o   */ f_Zoom_Out(char *buf),
		/* p   */ f_Key_Set_Pixel(char *buf),
		/* q   */ f_Quit(char *buf),
		/* r   */ f_Rd_Fb(char *buf),
		/* s   */ f_String(char *buf),
		/* t   */ f_ChngRegionColor(char *buf),
		/* u   */ f_Rd_Macros_From_File(char *buf),
		/* v   */ f_DrawRectangle(char *buf),
		/* w   */ f_Put_Pixel(char *buf),
		/* x   */ f_Set_X_Pos(char *buf),
		/* y   */ f_Set_Y_Pos(char *buf),
		/* Unbound */ f_Exec_Macro(char *buf);

Func_Tab func_tab[] =
	{
{/* NUL */ f_Nop,			NULL,	"nop"},
{/* ^A  */ f_Nop,			NULL,	"nop"},
{/* ^B  */ f_Nop,			NULL,	"nop"},
{/* ^C  */ f_Nop,			NULL,	"nop"},
{/* ^D  */ f_Nop,			NULL,	"nop"},
{/* ^E  */ f_Nop,			NULL,	"nop"},
{/* ^F  */ f_Nop,			NULL,	"nop"},
{/* ^G  */ f_Nop,			NULL,	"nop"},
{/* ^H  */ f_Win_Lft,			NULL,	"move-window-left"},
{/* ^I  */ f_Nop,			NULL,	"nop"},
{/* ^J  */ f_Win_Dwn,			NULL,	"move-window-down"},
{/* ^K  */ f_Win_Up,			NULL,	"move-window-up"},
{/* ^L  */ f_Win_Rgt,			NULL,	"move-window-right"},
{/* ^M  */ f_Reset_View,			NULL,	"reset-view"},
{/* ^N  */ f_Nop,			NULL,	"nop"},
{/* ^O  */ f_Nop,			NULL,	"nop"},
{/* ^P  */ f_Nop,			NULL,	"nop"},
{/* ^Q  */ f_Nop,			NULL,	"nop"},
{/* ^R  */ f_Redraw,			NULL,	"redraw-tty-screen"},
{/* ^S  */ f_Nop,			NULL,	"nop"},
{/* ^T  */ f_Nop,			NULL,	"nop"},
{/* ^U  */ f_Nop,			NULL,	"nop"},
{/* ^V  */ f_Nop,			NULL,	"nop"},
{/* ^W  */ f_Nop,			NULL,	"nop"},
{/* ^X  */ f_Exec_Function,		NULL,	"execute-function-or-macro"},
{/* ^Y  */ f_Nop,			NULL,	"nop"},
{/* ^Z  */ f_Stop,			NULL,	"stop-program"},
{/* ESC */ f_Iterations,			NULL,	"argument-count"},
{/* FS  */ f_Nop,			NULL,	"nop"},
{/* GS  */ f_Nop,			NULL,	"nop"},
{/* RS  */ f_Nop,			NULL,	"nop"},
{/* US  */ f_Nop,			NULL,	"nop"},
{/* SP  */ f_Press,			NULL,	"pick-point"},
{/* !   */ f_Nop,			NULL,	"nop"},
{/* "   */ f_Nop,			NULL,	"nop"},
{/* #   */ f_Comment,			NULL,	"print-comment"},
{/* $   */ f_Nop,			NULL,	"nop"},
{/* %   */ f_Nop,			NULL,	"nop"},
{/* &   */ f_Nop,			NULL,	"nop"},
{/* `   */ f_Nop,			NULL,	"nop"},
{/* (   */ f_Nop,			NULL,	"nop"},
{/* )   */ f_Nop,			NULL,	"nop"},
{/* *   */ f_Nop,			NULL,	"nop"},
{/* +   */ f_Nop,			NULL,	"nop"},
{/* ,   */ f_Dec_Brush_Size,		NULL,	"decrement-brush-size"},
{/* -   */ f_Nop,			NULL,	"nop"},
{/* .   */ f_Inc_Brush_Size,		NULL,	"increment-brush-size"},
{/* /   */ f_Nop,			NULL,	"nop"},
{/* 0   */ f_Nop,			NULL,	"nop"},
{/* 1   */ f_Nop,			NULL,	"nop"},
{/* 2   */ f_Nop,			NULL,	"nop"},
{/* 3   */ f_Nop,			NULL,	"nop"},
{/* 4   */ f_Nop,			NULL,	"nop"},
{/* 5   */ f_Nop,			NULL,	"nop"},
{/* 6   */ f_Nop,			NULL,	"nop"},
{/* 7   */ f_Nop,			NULL,	"nop"},
{/* 8   */ f_Nop,			NULL,	"nop"},
{/* 9   */ f_Nop,			NULL,	"nop"},
{/* :   */ f_Nop,			NULL,	"nop"},
{/* ;   */ f_Nop,			NULL,	"nop"},
{/* <   */ f_Dec_Step_Size,		NULL,	"decrement-step-size"},
{/* =   */ f_Nop,			NULL,	"nop"},
{/* >   */ f_Inc_Step_Size,		NULL,	"increment-step-size"},
{/* ?   */ f_Menu,			NULL,	"print-bindings"},
{/* @@   */ f_Nop,			NULL,	"nop"},
{/* A   */ f_Start_Macro,		NULL,	"start-macro-definition"},
{/* B   */ f_Bind_Macro_To_Key,		NULL,	"bind-macro-to-key"},
{/* C   */ f_Crunch_Image,		NULL,	"shrink-image-by-half"},
{/* D   */ f_Nop,			NULL,	"nop"},
{/* E   */ f_Erase_Fb,			NULL,	"clear-framebuffer-memory"},
{/* F   */ f_Flip_Resolution,		NULL,	"flip-framebuffer-resolution"},
{/* G   */ f_Get_Panel,			NULL,	"get-current-rectangle"},
{/* H   */ f_Jump_Lft,			NULL,	"jump-cursor-left"},
{/* I   */ f_Nop,			NULL,	"nop"},
{/* J   */ f_Jump_Dwn,			NULL,	"jump-cursor-down"},
{/* K   */ f_Jump_Up,			NULL,	"jump-cursor-up"},
{/* L   */ f_Jump_Rgt,			NULL,	"jump-cursor-right"},
{/* M   */ f_Nop,			NULL,	"nop"},
{/* N   */ f_Name_Keyboard_Macro,	NULL,	"name-keyboard-macro"},
{/* O   */ f_Nop,			NULL,	"nop"},
{/* P   */ f_Put_Panel,			NULL,	"put-saved-rectangle"},
{/* Q   */ f_Nop,			NULL,	"nop"},
{/* R   */ f_Restore_RLE,		NULL,	"read-rle-fle"},
{/* S   */ f_Save_RLE,			NULL,	"write-rle-file"},
{/* T   */ f_Transliterate,		NULL,	"replace-pixel-current-rectangle"},
{/* U   */ f_Write_Macros_To_File,	NULL,	"write-macros-to-file"},
{/* V   */ f_FillRegion,			NULL,	"fill-bounded-region"},
{/* W   */ f_Fill_Panel,			NULL,	"fill-current-rectangle"},
{/* X   */ f_Bind_Key_To_Key,		NULL,	"bind-key-to-key"},
{/* Y   */ f_Bind_Name_To_Key,		NULL,	"bind-key-to-name"},
{/* Z   */ f_Stop_Macro,			NULL,	"stop-macro-definition"},
{/* [   */ f_Nop,			NULL,	"nop"},
{/* \   */ f_Nop,			NULL,	"nop"},
{/* ]   */ f_Nop,			NULL,	"nop"},
{/* ^   */ f_Nop,			NULL,	"nop"},
{/* _   */ f_Nop,			NULL,	"nop"},
{/* `   */ f_Nop,			NULL,	"nop"},
{/* a   */ f_Enter_Macro_Definition,	NULL,	"enter-macro-definition"},
{/* b   */ f_Set_Rectangle,		NULL,	"set-current-rectangle"},
{/* c   */ f_Center_Window,		NULL,	"window-center"},
{/* d   */ f_DrawLine,			NULL,	"draw-line"},
{/* e   */ f_Nop,			NULL,	"nop"},
{/* f   */ f_Rd_Font,			NULL,	"read-font"},
{/* g   */ f_Set_Pixel,			NULL,	"set-paint-to-current-pixel"},
{/* h   */ f_Move_Lft,			NULL,	"move-cursor-left"},
{/* i   */ f_Zoom_In,			NULL,	"zoom-in"},
{/* j   */ f_Move_Dwn,			NULL,	"move-cursor-down"},
{/* k   */ f_Move_Up,			NULL,	"move-cursor-up"},
{/* l   */ f_Move_Rgt,			NULL,	"move-cursor-right"},
{/* m   */ f_Status_Monitor,		NULL,	"set-monitor"},
{/* n   */ f_Tolerance,			NULL,	"set-tolerance-color-match"},
{/* o   */ f_Zoom_Out,			NULL,	"zoom-out"},
{/* p   */ f_Key_Set_Pixel,		NULL,	"set-paint-from-key"},
{/* q   */ f_Quit,			NULL,	"quit"},
{/* r   */ f_Rd_Fb,			NULL,	"read-framebuffer"},
{/* s   */ f_String,			NULL,	"put-string"},
{/* t   */ f_ChngRegionColor,		NULL,	"change-region-color"},
{/* u   */ f_Rd_Macros_From_File,	NULL,	"read-macros-from-file"},
{/* v   */ f_DrawRectangle,		NULL,	"draw-rectangle"},
{/* w   */ f_Put_Pixel,			NULL,	"put-pixel"},
{/* x   */ f_Set_X_Pos,			NULL,	"set-cursor-x-pos"},
{/* y   */ f_Set_Y_Pos,			NULL,	"set-cursor-y-pos"},
{/* z   */ f_Nop,			NULL,	"nop"},
{/* {   */ f_Nop,			NULL,	"nop"},
{/* |   */ f_Nop,			NULL,	"nop"},
{/* }   */ f_Nop,			NULL,	"nop"},
{/* ~   */ f_Nop,			NULL,	"nop"},
{/* DEL */ f_Nop,			NULL,	"nop"}
};

static Func_Tab	*bindings[DEL+1];
static Func_Tab	*macro_entry = FT_NULL; /* Last keyboard macro defined. */

FBIO *fbp;				/* Current framebuffer */
static int cur_width = 512;

/*	m a i n ( ) */
int
main(int argc, char **argv)
{
	if( ! pars_Argv( argc, argv ) )
		{
		prnt_Usage();
		return 1;
		}
	setbuf( stdout, malloc( BUFSIZ ) );	
	tty = isatty( 1 );
	if( ! InitTermCap( stdout ) )
		{
		(void) fprintf( stderr, "Could not initialize terminal.\n" );
		return 1;
		}
	init_Status();
	if( fb_Setup() == -1 )
		return 1;
	current.r_origin.p_x = 0;
	current.r_corner.p_x = fb_getwidth(fbp)-1;
	current.r_origin.p_y = 0;
	current.r_corner.p_y = fb_getheight(fbp)-1;
	prnt_Status();
	fb_Wind();
	init_Tty();
	init_Try();
	get_Font( FONTNAME );
	{	static char default_macro_file[MAX_LN];
		char *home;
	if( (home = getenv( "HOME" )) != NULL )
		{
		(void) strcpy( default_macro_file, home );
		home = default_macro_file + strlen( default_macro_file );
		*home++ = '/';
		}
	else
		home = default_macro_file;
	(void) strcpy( home, ".fbed_macros" );
	(void) f_Rd_Macros_From_File( default_macro_file );
	}
#define CBREAK_MODE		/* Signals are generated from keyboard. */
#if defined( CBREAK_MODE )
	{	register int sig;
	for( sig = 0; sig < NSIG; sig++ )
		if( signal( sig, general_Handler ) == SIG_IGN )
			(void) signal( sig, SIG_IGN );
	}
#endif
	(void) fb_flush( fbp );
	prnt_Prompt( "" );
	for( cread_buf[0] = NUL; ; )
		{
			register int status_change = false;
		for( ; *cptr != NUL; )
			{
			do_Key_Cmd( (int) *cptr++, 1 );
			status_change = true;
			}
		if( cptr > cread_buf )
			*(cptr = cread_buf) = NUL;
		else
			{	int c;
			if( reposition_cursor )
				{
				(void) fb_cursor(	fbp,
							1,
							cursor_pos.p_x,
							cursor_pos.p_y
							);
				status_change = true;
				reposition_cursor = false;
				}
			if( ! empty( tty_fd ) )
				{
				if( (c = get_Char()) != EOF )
					{
					do_Key_Cmd( c, 1 );
					status_change = true;
					}
				else	/* EOF detected. */
					break;
				}
			}
		if(   !	reposition_cursor
		    &&	(get_Mouse_Pos( &cursor_pos ))
		    	!= -1
			)
			status_change = true;
		if( status_change )
			{
			(void) fb_flush( fbp );
			if( report_status )
				prnt_Status();
			}
		}
	(void) f_Quit( (char *) NULL );
	/*NOTREACHED*/
	return 0; /* shut up stupid compilers */
	}

STATIC bool
drawRectangle(Rectangle *rectp, unsigned char *pixelp)
{	register int x, y;
	y = rectp->r_origin.p_y;
	x = rectp->r_origin.p_x;
	for( ; x < rectp->r_corner.p_x; x++ )
		if( fb_write( fbp, x, y, pixelp, 1 ) == -1 )
			return false;
	for( ; y < rectp->r_corner.p_y; y++ )
		if( fb_write( fbp, x, y, pixelp, 1 ) == -1 )
			return false;
	for( ; x > rectp->r_origin.p_x; x-- )
		if( fb_write( fbp, x, y, pixelp, 1 ) == -1 )
			return false;
	for( ; y > rectp->r_origin.p_y; y-- )
		if( fb_write( fbp, x, y, pixelp, 1 ) == -1 )
			return false;
	return true;
	}

STATIC void
fillRectangle(register Rectangle *rectp, register RGBpixel (*pixelp))
{	register int btm = rectp->r_origin.p_y;
		register int top = rectp->r_corner.p_y;
		register int rgt = rectp->r_corner.p_x;
		int lft = rectp->r_origin.p_x;
	if( isSGI )
		{ /* More efficient on IRIS. */
		if( top - btm < 10 || rgt - lft < 10 )
			{
			for( ; btm <= top; btm++ )
				{	register int x;
				for( x = lft; x <= rgt; x++ )
					(void) fb_write( fbp, x, btm,
						(unsigned char *)pixelp, 1 );
				}
			}
		}
	else
		{
		for( ; btm <= top; btm++ )
			{	register int x = lft;
			(void) fb_seek( fbp, x, btm );
			for( ; x <= rgt; x++ )
				FB_WPIXEL( fbp, *pixelp );
			}
		(void) fb_flush( fbp );
		}
	}

STATIC bool
paintNonBorder(unsigned char *borderpix, Point *pt)
{	RGBpixel currentpix;
	if(	pt->p_x < 0 || pt->p_x > fb_getwidth(fbp)
	    ||	pt->p_y < 0 || pt->p_y > fb_getheight(fbp) )
		return false; /* outside frame buffer memory */
	if( fb_read( fbp, pt->p_x, pt->p_y, (unsigned char *) currentpix, 1 ) == -1 )
		return false; /* read error */
	if( EqPixel( currentpix, borderpix ) )
		return false; /* hit border */
	else
	if( EqPixel( currentpix, paint ) )
		return false; /* already painted */
	else
	if( fb_write( fbp, pt->p_x, pt->p_y, (unsigned char *) paint, 1 ) == -1 )
		return false; /* write error */
	else
		return true;
	}

STATIC bool
paintSolidRegion(unsigned char *regionpix, Point *pt)
{	RGBpixel currentpix;
	if(	pt->p_x < 0 || pt->p_x > fb_getwidth(fbp)
	    ||	pt->p_y < 0 || pt->p_y > fb_getheight(fbp) )
		return false; /* outside frame buffer memory */
	if( fb_read( fbp, pt->p_x, pt->p_y, (unsigned char *) currentpix, 1 ) == -1 )
		return false; /* read error */
	if( ! AproxPixel( currentpix, regionpix, tolerance ) )
		return false; /* hit border */
	else
	if( fb_write( fbp, pt->p_x, pt->p_y, (unsigned char *) paint, 1 ) == -1 )
		return false; /* write error */
	else
		return true;
	}

STATIC void
pushPoint(Point *pt, PtStack **spp)
{	register PtStack *new;
	if( (new = (PtStack *) malloc( sizeof(PtStack) )) == NULL )
		{
		fb_log(	"\"%s\"(%d) Malloc() no more space.\n",
				__FILE__, __LINE__ );
		return;
		}
	new->pt = *pt; /* struct copy */
	new->next = *spp;
	*spp = new;
	}

STATIC bool
popPoint(Point *pt, register PtStack **spp)
{	register PtStack *next;
	if( (*spp) == NULL )
		return false;
	*pt = (*spp)->pt;	/* struct copy */
	next = (*spp)->next;
	free( (char *) *spp );
	*spp = next;
	return true;
	}
		
/*	i n i t _ T r y ( )
	Initialize "try" tree of function names, with key bindings.
 */
STATIC void
init_Try(void)
{	register int key;
		register int nop_key = EOF;
	/* Add all functions except NOP to tree. */
	for( key = NUL; key <= DEL; key++ )
		{
		bindings[key] = &func_tab[key];
		if( bindings[key]->f_func != f_Nop )
			add_Try( bindings[key], bindings[key]->f_name, &try_rootp );
		else
		if( nop_key == EOF )
			/* First key bound to NOP. */
			nop_key = key;
		}
	/* Add the NOP function to the tree once, although it may be bound
		to many keys.
	 */
	add_Try( &func_tab[nop_key], func_tab[nop_key].f_name, &try_rootp );
	return;
	}

STATIC int
push_Macro(char *buf)
{	register int curlen = strlen( cptr );
		register int buflen = strlen( buf );
	if( curlen + buflen > MACROBUFSZ - 1 )
		{
		fb_log( "Macro buffer would overflow.\n" );
		return 0;
		}
	(void) strcpy( macro_buf, cptr );
	(void) strncpy( cread_buf, buf, buflen ); /* Don't copy NUL. */
	(void) strcpy( cread_buf+buflen, macro_buf );
	cptr = cread_buf;
	return 1;
	}

/*	d o _ K e y _ C m d ( ) */
void
do_Key_Cmd(register int key, register int n)
{
	last_key = key;
	if( *cptr == NUL )
		{
		/*prnt_Prompt( "" );*/
		prnt_Event( "" );
		}
	if( remembering )
		{
		if( bindings[key]->f_func != f_Exec_Macro )
			{
			*macro_ptr++ = key;
			*macro_ptr = NUL;
			}
		}
	step = gain;
	while( n-- > 0 )
		{
		/* For now, ignore return values;
			-1 for illegal command.
			 0 for failed command.
		 	 1 for success.
		 */
		(void) (*bindings[key]->f_func)( bindings[key]->f_buff );
		}
	return;
	}

STATIC bool
getColor(unsigned char *pixelp, char *prompt, char *buffer)
{	static char promptbuf[PROMPT_LEN];
		static int red, grn, blu;
	(void) sprintf( promptbuf, "%s [r g b] : ", prompt );

	if( ! get_Input( buffer, CLR_LEN, promptbuf ) )
		return false;
	if(	sscanf( buffer, "%d %d %d", &red, &grn, &blu ) == 3
	    &&	red >= 0 && red <= 255
	    &&	grn >= 0 && grn <= 255
	    &&	blu >= 0 && blu <= 255
		)
		{
		pixelp[RED] = red;
		pixelp[GRN] = grn;
		pixelp[BLU] = blu;
		}
	else
	if( buffer[0] != '@@' )
		{
		fb_log( "You must enter 3 numbers (0..255).\n" );
		return false;
		}
	return true;
	}

STATIC int
/*ARGSUSED*/
f_Tolerance(char *buf)
{	static char tol_str[4];
	if( ! get_Input( tol_str, 4, "Enter tolerance for color match : " ) )
		return 0;
	if( sscanf( tol_str, "%d", &tolerance ) != 1 )
		tolerance = 0;
	fb_log( "Tolerance set to %d.\n", tolerance );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_ChngRegionColor(char *buf)
{	static int xoff1[] = { 0, 1,  0, -1 };
		static int yoff1[] = { 1, 0, -1,  0 };
		RGBpixel currentpix;
		Point pivot;
		PtStack *regionsp = NULL;

	/* Grab pixel color under cursor. */
	if( fb_read( fbp, cursor_pos.p_x, cursor_pos.p_y,
			(unsigned char *) currentpix, 1 ) == -1 )
		return 0; /* read error */
	pushPoint( &cursor_pos, &regionsp );
	if( ! paintSolidRegion( currentpix, &cursor_pos ) )
		return 0;
	while( popPoint( &pivot, &regionsp ) )
		{	register int i;
			register int length = sizeof(xoff1)/sizeof(int);
		for( i = 0; i < length; i++ )
			{	Point neighbor;
			neighbor.p_x = pivot.p_x + xoff1[i];
			neighbor.p_y = pivot.p_y + yoff1[i];
			if( paintSolidRegion( currentpix, &neighbor ) )
				pushPoint( &neighbor, &regionsp );
			}
		}
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_FillRegion(char *buf)
{	static int xoff1[] = { 0, 1,  0, -1 };
		static int yoff1[] = { 1, 0, -1,  0 };
		static char buffer[CLR_LEN];
		RGBpixel borderpix;
		Point pivot;
		PtStack *regionsp = NULL;

	if( ! getColor( borderpix, "Enter region border pixel color", buffer ) )
		return 0;
	pushPoint( &cursor_pos, &regionsp );
	if( ! paintNonBorder( borderpix, &cursor_pos ) )
		return 0;
	while( popPoint( &pivot, &regionsp ) )
		{	register int i;
			register int length = sizeof(xoff1)/sizeof(int);
		for( i = 0; i < length; i++ )
			{	Point neighbor;
			neighbor.p_x = pivot.p_x + xoff1[i];
			neighbor.p_y = pivot.p_y + yoff1[i];
			if( paintNonBorder( borderpix, &neighbor ) )
				pushPoint( &neighbor, &regionsp );
			}
		}
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Nop(char *buf)
{
	fb_log( "Unbound(%s).\n", char_To_String( last_key ) );
	putchar( BEL );
	return -1;
	}

STATIC int
/*ARGSUSED*/
f_Win_Lft(char *buf) /* Move window left. */
          
	{
	windo_center.p_x += gain;
	reposition_cursor = true;
	return fb_window( fbp, windo_center.p_x, windo_center.p_y ) != -1 ?
		1 : 0;
	}

STATIC int
/*ARGSUSED*/
f_Win_Dwn(char *buf) /* Move window down. */
          
	{
	windo_center.p_y -= gain;
	reposition_cursor = true;
	return fb_window( fbp, windo_center.p_x, windo_center.p_y ) != -1 ?
		1 : 0;
	}

STATIC int
/*ARGSUSED*/
f_Win_Up(char *buf) /* Move window up. */
          
	{
	windo_center.p_y += gain;
	reposition_cursor = true;
	return fb_window( fbp, windo_center.p_x, windo_center.p_y ) != -1 ?
		1 : 0;
	}

STATIC int
/*ARGSUSED*/
f_Win_Rgt(char *buf) /* Move window right. */
          
	{
	windo_center.p_x -= gain;
	reposition_cursor = true;
	return fb_window( fbp, windo_center.p_x, windo_center.p_y ) != -1 ?
		1 : 0;
	}

STATIC int
/*ARGSUSED*/
f_Reset_View(char *buf) /* Restore normal view. */
          
	{
	cursor_pos.p_x = image_center.p_x;
	cursor_pos.p_y = image_center.p_y;
	size_viewport = fb_getwidth(fbp);
	fb_Wind();
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Redraw(char *buf) /* Redraw screen. */
          
	{
	init_Status();
	prnt_Status();
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Stop(char *buf) /* Stop program. */
          
	{	int pid = getpid();
		int sig;
#ifdef SIGSTOP
	sig = SIGSTOP;
#else
	sig = 17;
#endif
	prnt_Event( "[%d] stopped.", pid );
	restore_Tty();
	if( kill( pid, sig ) == -1 )
		{
		extern int errno;
		perror( "(fbed.c) kill" );
		exit( errno );
		}
	init_Tty();
	init_Status();
	prnt_Event( "[%d] foreground.", pid );
	prnt_Status();
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Exec_Function(char *buf)
{	Func_Tab	*ftbl;
		static char name[MAX_LN];
	if( (ftbl = get_Func_Name( name, MAX_LN, ": " )) == FT_NULL )
		return 0;
	else
	if( strcmp( ftbl->f_name, name ) == 0 )
		return (*ftbl->f_func)( ftbl->f_buff );
	else
		{
		fb_log( "I seem to have lost my bindings.\n" );
		return 0;
		}
	}

#define MAX_DIGITS	4
STATIC int
/*ARGSUSED*/
f_Iterations(char *buf) /* Specify number of iterations of next command. */
          
	{	char iterate_buf[MAX_DIGITS+1];
		int iterate;
		register int c=0, i;
	if( remembering )
		/* Clobber "f_Iterations()" key-stroke. */
		*--macro_ptr = NUL;
	prnt_Prompt( "M-" );
	for( i = 0; i < MAX_DIGITS && isdigit( c = get_Char() ); i++ )
		{
		iterate_buf[i] = c;
		(void) putchar( c );
		(void) fflush( stdout );
		}
	if( i == MAX_DIGITS )
		c = get_Char();
	iterate_buf[i] = NUL;
	(void) putchar( ':' );
	(void) fflush( stdout );
	if( sscanf( iterate_buf, "%d", &iterate ) != 1 )
		{
		fb_log( "Iterations not set.\n" );
		return 0;
		}
	do_Key_Cmd( c, iterate );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Press(char *buf)
{
	pointpicked = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Comment(char *buf) /* Print comment. */
          
	{	static char comment[MAX_LN];
	if( ! get_Input( comment, MAX_LN, "Enter comment : " ) )
		return 0;
	fb_log( "%s\n", comment );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Dec_Brush_Size(char *buf) /* Decrement brush size. */
          
	{
	if( brush_sz > 0 )
		brush_sz -= 2;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Inc_Brush_Size(char *buf) /* Increment brush size. */
          
	{
	if( brush_sz < size_viewport )
		brush_sz += 2;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Menu(char *buf) /* Print menu. */
          
	{	register int lines = (PROMPT_LINE-BOTTOM_STATUS_AREA)-1;
		register int done = false;
		register int key;
	for( key = NUL; key <= DEL && ! done; )
		{	register int j;
		for( j = 0; key <= DEL && j < lines; key++ )
			{
			if( bindings[key]->f_func != f_Nop )
				{
				prnt_Scroll(	" '%s'\t%s",
						char_To_String( key ),
						bindings[key]->f_name
						);
				j++;
				}
			}
		/* See if there is any more output. */
		for( j = key; j <= DEL && bindings[j]->f_func == f_Nop; j++ )
			;
		if( j <= DEL )
			{
			SetStandout();
			prnt_Prompt( "-- More -- " );
			ClrStandout();
			(void) fflush( stdout );
			switch( *cptr != NUL ? *cptr++ : get_Char() )
				{
			case 'q' :
			case 'n' :
				done = true;
				break;
			case LF :
			case CR :
				lines = 1;
				break;
			default :
				lines =	(PROMPT_LINE-BOTTOM_STATUS_AREA)-1;
				break;
				}
			prnt_Prompt( "" );
			}
		}
	(void) fflush( stdout );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Dec_Step_Size(char *buf) /* Decrement gain on move operations. */
          
	{
	if( gain > 1 )
		gain--;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Inc_Step_Size(char *buf) /* Increment gain on move operations. */
          
	{
	if( gain < size_viewport )
		gain++;
	return 1;
	}

STATIC int
f_Exec_Macro(char *buf)
{
	push_Macro( buf );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Rd_Macros_From_File(char *buf)
{	register FILE	*macro_fp;
		register int nread = 1, room;
		char scratch[MAX_LN];
	if( buf != NULL )
		{
		if( (macro_fp = fopen( buf, "r" )) == NULL )
			return 1;
		else
			prnt_Event( "Reading macros from file \"%s\".", buf );
		}
	else
		{
		if( ! get_Input( scratch, MAX_LN, "Read macros from file : " ) )
			return 0;
		if( (macro_fp = fopen( scratch, "r" )) == NULL )
			{
			fb_log( "Can't open \"%s\" for reading.\n", scratch );
			return 0;
			}
		}
	/* Read and execute functions from file. */
	for( ; nread > 0 ; )
		{
		room = MACROBUFSZ - strlen( cread_buf );
		nread = fread( cptr, (int) sizeof(char), room , macro_fp );
		cread_buf[nread] = NUL;
		for( cptr = cread_buf; *cptr != NUL; )
			do_Key_Cmd( (int) *cptr++, 1 );
		*(cptr = cread_buf) = NUL;
		}
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Write_Macros_To_File(char *buf)
{	static char macro_file[MAX_LN];
		register FILE	*macro_fp;
		register int key;
	if( ! get_Input( macro_file, MAX_LN, "Write macros to file : " ) )
		return 0;
	if( (macro_fp = fopen( macro_file, "w" )) == NULL )
		{
		fb_log( "Can't open \"%s\" for writing.\n", macro_file );
		return 0;
		}
	for( key = NUL+1; key <= DEL; key++ )
		{
		if( bindings[key] != FT_NULL )
			{
			if( bindings[key]->f_func == f_Nop )
				continue; /* don't save unbound keys */
			if( bindings[key]->f_func == f_Exec_Macro )
				{
				(void) putc( Ctrl('X'), macro_fp );
				(void) fprintf(	macro_fp,
						"enter-macro-definition\n"
						);
				/* Output macro definition. */
				for(	macro_ptr = bindings[key]->f_buff;
					*macro_ptr != NUL;
					macro_ptr++
					)
					(void) putc( *macro_ptr, macro_fp );
				(void) putc( 'Z', macro_fp ); /* Mark end macro.*/
				(void) putc( Ctrl('X'), macro_fp );
				(void) fprintf( macro_fp, "name-keyboard-macro\n" );
				/* Output macro name, new-line terminated. */
				(void) fprintf(	macro_fp,
						"%s\n", bindings[key]->f_name
						);
				(void) putc( Ctrl('X'), macro_fp );
				(void) fprintf( macro_fp, "bind-macro-to-key\n" );
				/* Output key binding, new-line terminated. */
				if( key < SP || key == DEL )
					/* Escape control characters. */
					(void) putc( Ctrl('V'), macro_fp );
				(void) putc( key, macro_fp );
				(void) putc( '\n', macro_fp );
				}
			/* Write out current key binding. */
			if( key == Ctrl('X') || key == '@@' )
				continue;
			(void) putc( Ctrl('X'), macro_fp );
			(void) fprintf( macro_fp, "bind-key-to-name\n" );
			if( key < SP || key == DEL )
				(void) putc( Ctrl('V'), macro_fp );
			(void) putc( key, macro_fp );
			(void) putc( '\n', macro_fp );
			(void) fprintf( macro_fp, "%s\n",
					bindings[key]->f_name );
			}
		}
	(void) fflush( macro_fp );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Start_Macro(char *buf)
{
	if( remembering )
		{
		fb_log( "I am already remembering.\n" );
		*--macro_ptr = NUL;
		return 0;
		}
	*(macro_ptr = macro_buf) = NUL;
	remembering = true;
	prnt_Event( "Remembering..." );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Bind_Macro_To_Key(char *buf)
{	char key[2];
	if( macro_entry == FT_NULL )
		{
		fb_log( "Define macro first.\n" );
		return 0;
		}
	if( ! get_Input( key, 2, "Bind macro to key : " ) )
		return 0;
	if( key[0] == Ctrl('X') || key[0] == '@@' )
		{
		(void) putchar( BEL );
		fb_log(	"It is not permitted to change '%s' binding.\n",
				char_To_String( (int) key[0] )
				);
		return 0;
		}
	bindings[(int)key[0]] = macro_entry;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Name_Keyboard_Macro(char *buf)
{	static char macro_name[MAX_LN];
	if( macro_entry == FT_NULL )
		{
		fb_log( "Define macro first.\n" );
		return 0;
		}
	if( ! get_Input( macro_name, MAX_LN, "Name keyboard macro : " ) )
		return 0;
	macro_entry->f_name = malloc( (unsigned) strlen( macro_name )+1 );
	if( macro_entry->f_name == NULL )
		{
		Malloc_Bomb();
		}
	(void) strcpy( macro_entry->f_name, macro_name );
	add_Try( macro_entry, macro_entry->f_name, &try_rootp );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Crunch_Image(char *buf) /* Average image to half its size. */
          
	{	char answer[2];
		register int x, y;
		register RGBpixel *p1, *p2;
	if( ! get_Input( answer, 2, "Crunch image [n=no] ? " ) )
		return 0;
	if( answer[0] == 'n' )
		return 1;
	if( (p1 = (RGBpixel *) malloc( sizeof(RGBpixel) * fb_getwidth(fbp) ))
		== (RGBpixel *)RGBPIXEL_NULL
		)
		{
		Malloc_Bomb();
		}
	if( (p2 = (RGBpixel *) malloc( sizeof(RGBpixel) * fb_getwidth(fbp) ))
		== (RGBpixel *)RGBPIXEL_NULL
		)
		{
		Malloc_Bomb();
		}
	for( y = 0; y < fb_getheight(fbp); y += 2 )
		{	register RGBpixel *p_avg;
		fb_read( fbp, 0, y, (unsigned char *)p1, fb_getwidth(fbp));
		fb_read( fbp, 0, y+1, (unsigned char *)p2, fb_getwidth(fbp) );
		for( x = 0; x < fb_getwidth(fbp); x +=2 )
			{
			p_avg = pixel_Avg(	p1+x,
						p1+x+1,
						p2+x,
						p2+x+1
						);
			COPYRGB( p1[x/2], *p_avg );
			}
		fb_write( fbp, 0, y/2, (unsigned char *)p1, fb_getwidth(fbp)/2 );
		}
	free( (char *) p1 );
	free( (char *) p2 );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_DrawLine(char *buf)
{	Rectangle lineseg;
		register int majdelta;
		register int mindelta;
		register int xsign;
		register int ysign;
		register int error;
		register int x;
		register int de;
		int xmajor;

	get_Point( "Pick starting point of line", &lineseg.r_origin );
	get_Point( "Pick ending point of line", &lineseg.r_corner );

	/* Below is a implementation of Bresenham's algorithm written
		by Douglas A. Gwyn of BRL, as suggested by Newman and
		Sproull, "Principles of Interactive Computer Graphics",
		Second Edition, pages 25-26. */
	/* Arrange for X coordinate to increase from start point to
		end point. */
	if( lineseg.r_origin.p_x > lineseg.r_corner.p_x )
		{	Point temp;
		temp = lineseg.r_origin;
		lineseg.r_origin = lineseg.r_corner;
		lineseg.r_corner = temp;
		}
	majdelta = lineseg.r_corner.p_x - lineseg.r_origin.p_x;
	xsign = majdelta ? 1 : 0;
	mindelta = lineseg.r_corner.p_y - lineseg.r_origin.p_y;
	ysign = mindelta ? (mindelta > 0 ? 1 : -1) : 0;
	if( ysign < 0 )
		mindelta = -mindelta;
	/* If X is not really major, correct the assignments. */
	if( ! (xmajor = mindelta <= majdelta) )
		{	register int temp = mindelta;
		mindelta = majdelta;
		majdelta = temp;
		}

	error = majdelta / 2 - mindelta; /* Initial DDA error. */
	de = majdelta - mindelta;
	for( x = lineseg.r_origin.p_x; x <= lineseg.r_corner.p_x; )
		{
		(void) fb_write(	fbp,
					x, lineseg.r_origin.p_y, 
					(unsigned char *) paint,
					1
					);
		if( majdelta-- == 0 ) /* Done! */
			return 1;
		if( error < 0 )	 /* Advance major and minor. */
			{
			x += xsign;
			lineseg.r_origin.p_y += ysign;
			error += de;
			}
		else
			{		/* Advance major only. */
			if( xmajor )	/* X is major direction. */
				x++;
			else		/* Y is major direction. */
				lineseg.r_origin.p_y += ysign;
			error -= mindelta;
			}
		}
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_DrawRectangle(char *buf) /* Draw current rectangle with "paint" color. */
          
	{
	return drawRectangle( &current, (unsigned char *) paint ) ? 1 : 0;
	}

STATIC int
/*ARGSUSED*/
f_Fill_Panel(char *buf) /* Fill current rectangle with "paint" color. */
          
	{
	fillRectangle( &current, (RGBpixel *) paint );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Bind_Key_To_Key(char *buf) /* Bind new key to same function as old key. */
          
	{	char old_key[2], new_key[2];
	if( ! get_Input( new_key, 2, "Bind new key : " ) )
		return 0;
	if( new_key[0] == Ctrl('X') || new_key[0] == '@@' )
		{
		(void) putchar( BEL );
		fb_log(	"It is not permitted to change '%s' binding.\n",
				char_To_String( (int) new_key[0] )
				);
		return 0;
		}
	if( ! get_Input( old_key, 2, "To function bound to key : " ) )
		return 0;
	bindings[(int)new_key[0]] = bindings[(int)old_key[0]];
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Bind_Name_To_Key(char *buf) /* Bind key to function or macro. */
          
	{	char key[2];
		static char name[MAX_LN];
		Func_Tab	*ftbl;
	if( ! get_Input( key, 2, "Bind key : " ) )
		return 0;
	if( key[0] == Ctrl('X') || key[0] == '@@' )
		{
		(void) putchar( BEL );
		fb_log(	"It is not permitted to change '%s' binding.\n",
				char_To_String( (int) key[0] )
				);
		return 0;
		}
	if( (ftbl = get_Func_Name( name, MAX_LN, "To function/macro name : " ))
		== FT_NULL
		)
		return 0;
	if( strcmp( ftbl->f_name, name ) == 0 )
		{
		/* Key is still bound to this function/macro. */
		bindings[(int)key[0]] = ftbl;
		return 1;
		}
	else
		{
		fb_log( "I seem to have lost my bindings.\n" );
		return 0;
		}
	}

STATIC int
/*ARGSUSED*/
f_Erase_Fb(char *buf) /* Erase (clear) framebuffer. */
          
	{	char answer[2];
	if( ! get_Input( answer, 2, "Clear framebuffer [n=no] ? " ) )
		return 0;
	if( answer[0] != 'n' )
		{
		(void) fb_clear(fbp, RGBPIXEL_NULL);
		}
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Flip_Resolution(char *buf) /* Flip framebuffer resolution. */
          
	{	char answer[2];
		int is_hires = fb_getwidth(fbp) > 512;
	if( ! get_Input(	answer,
				2,
				is_hires ?
				"Flip framebuffer to low res [n=no] ? " :
				"Flip framebuffer to high res [n=no] ? "
				)
		)
		return 0;
	if( answer[0] == 'n' )
		return 1;
	(void) fb_cursor( fbp, 0, 0, 0 );	/* off */
	if( fb_close( fbp ) == -1 )
		return 0;
	cur_width = is_hires ? 512 : 1024;
	if( fb_Setup() == -1 )
		exit( 1 );
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Get_Panel(char *buf) /* Grab panel from framebuffer. */
          
	{
	if( panel.n_buf != (RGBpixel *) NULL )
		free( (char *) panel.n_buf );
	prnt_Rectangle(	"Storing rectangle", &current );
	panel.n_buf = get_Fb_Panel( &current );
	panel.n_wid  = current.r_corner.p_x - current.r_origin.p_x;
	panel.n_hgt = current.r_corner.p_y - current.r_origin.p_y;
	fb_log( "Rectangle saved.\n" );
	return 1; 
	}

STATIC int
/*ARGSUSED*/
f_Jump_Lft(char *buf) /* Move cursor left (big steps). */
          
	{
	if( cursor_pos.p_x >= JUMP )
		cursor_pos.p_x -= JUMP;
	else
		cursor_pos.p_x = 0;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Jump_Dwn(char *buf) /* Move cursor down. */
          
	{
	if( cursor_pos.p_y >= JUMP )
		cursor_pos.p_y -= JUMP;
	else
		cursor_pos.p_y = 0;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Jump_Up(char *buf) /* Move cursor up. */
          
	{
	if( cursor_pos.p_y < fb_getheight(fbp) - JUMP )
		cursor_pos.p_y += JUMP;
	else
		cursor_pos.p_y = fb_getheight(fbp) - 1;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Jump_Rgt(char *buf) /* Move cursor right. */
          
	{
	if( cursor_pos.p_x <= fb_getwidth(fbp) - JUMP )
		cursor_pos.p_x += JUMP;
	else
		cursor_pos.p_x = fb_getwidth(fbp) - 1;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Put_Panel(char *buf) /* Put grabbed panel to framebuffer. */
          
	{
	if( panel.n_buf == (RGBpixel *) NULL )
		{
		fb_log( "You must use \"get-current-rectangle\" first.\n" );
		return 0;
		}
	get_Point( "Pick lower-left corner of panel", &current.r_origin );
	current.r_corner.p_x = current.r_origin.p_x + panel.n_wid;
	current.r_corner.p_y = current.r_origin.p_y + panel.n_hgt;
	put_Fb_Panel( &current, panel.n_buf );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Restore_RLE(char *buf) /* Restore Run-Length Encoded image. */
          
	{	static char rle_file_nm[MAX_LN];
		static FILE	*rle_fp;
		static char *args[] =
			{
			"rle-fb", rle_file_nm, NULL
			};
	if( ! get_Input( rle_file_nm, MAX_LN, "Enter RLE file name : " ) )
		return 0;
	if( rle_file_nm[0] == NUL )
		{
		fb_log( "No default.\n" );
		return 0;
		}
	else
	if( (rle_fp = fopen( rle_file_nm, "r" )) == NULL )
		{
		fb_log( "Can't open \"%s\".\n", rle_file_nm );
		return 0;
		}
	prnt_Event( "Decoding \"%s\".", rle_file_nm );
	(void) fb_cursor( fbp, 0, 0, 0 );	/* off */
	reposition_cursor = true;
	if( fb_close( fbp ) == -1 )
		{
		(void) fclose( rle_fp );
		return 0;
		}
	(void) exec_Shell( args );
	if( fb_Setup() == -1 )
		exit( 1 );
	(void) fclose( rle_fp );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Save_RLE(char *buf) /* Save framebuffer image with Run-Length Encoding. */
          
	{	static char rle_file_nm[MAX_LN];
		static char *args[4] =
			{
			"fb-rle", rle_file_nm, NULL, NULL
			};
	if( fb_getwidth(fbp) == 1024 )
		{
		args[1] = "-h";
		args[2] = rle_file_nm;
		}
	if( ! get_Input( rle_file_nm, MAX_LN, "Enter RLE file name : " ) )
		return 0;
	if( rle_file_nm[0] == NUL )
		{
		fb_log( "No default.\n" );
		return 0;
		}
	if( access( rle_file_nm, 0 ) == 0 )
		{	char answer[2];
			char question[MAX_LN+32];
		(void) sprintf( question,
				"File \"%s\" exists, remove [n=no] ? ",
				rle_file_nm
				); 
		if( ! get_Input( answer, 2, question ) )
			return 0;
		if( answer[0] == 'n' )
			return 0;
		(void) unlink( rle_file_nm );
		}
	prnt_Event( "Encoding \"%s\".", rle_file_nm );
	if( fb_close( fbp ) == -1 )
		return 0;
	if( exec_Shell( args ) == 0 )
		fb_log( "Image saved in \"%s\".\n", rle_file_nm );
	else
		fb_log( "Image not saved.\n" );
	if( fb_Setup() == -1 )
		exit( 1 );
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Transliterate(char *buf) /* Transliterate pixels of color1 to target color2.*/
          
	{	RGBpixel old, new, cur;
		static char oldbuf[CLR_LEN];
		static char newbuf[CLR_LEN];
		register int x, y;
		register int lft, rgt, top, btm;
	lft = current.r_origin.p_x;
	rgt = current.r_corner.p_x;
	top = current.r_origin.p_y;
	btm = current.r_corner.p_y;
	if( ! getColor( old, "Enter old pixel color", oldbuf ) )
		return 0;
	if( ! getColor( new, "Enter new pixel color", newbuf ) )
		return 0;
	for( y = top; y <= btm ; y++ )
		{
		x = lft;
		(void) fb_seek( fbp, x, y );
		for( ; x <= rgt; x++ )
			{
			(void) fb_rpixel( fbp, (unsigned char *) cur );
			if( AproxPixel( cur, old, tolerance ) )
				{
				(void) fb_seek( fbp, x, y );
				FB_WPIXEL( fbp, new );
				}
			}
		}
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Stop_Macro(char *buf)
{
	if( ! remembering )
		{
		fb_log( "I was not remembering.\n" );
		return 0;
		}
	remembering = false;
	/* Clobber "f_Stop_Macro()" key-stroke or "f_Exec_Function()
		followed by "stop-macro-definition".
	 */
	if( *--macro_ptr == '\n' )
		while( *--macro_ptr != Ctrl('X') )
			*macro_ptr = NUL;
	*macro_ptr = NUL;
	macro_ptr = macro_buf;
	macro_entry = (Func_Tab *) malloc( sizeof(Func_Tab) );
	if( macro_entry == FT_NULL )
		{
		Malloc_Bomb();
		}
	macro_entry->f_func = f_Exec_Macro;
	macro_entry->f_buff = malloc( (unsigned) strlen( macro_buf )+1 );
	if( macro_entry->f_buff == NULL )
		{
		Malloc_Bomb();
		}
	(void) strcpy( macro_entry->f_buff, macro_buf );
	fb_log( "Keyboard macro defined.\n" );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Enter_Macro_Definition(char *buf)
{	register int interactive = *cptr == NUL;
	macro_ptr = macro_buf;
	*macro_ptr = NUL;
	if( interactive )
		{
		prnt_Prompt( "Enter macro definition : " );
		while( (*macro_ptr++ = get_Char()) != 'Z' )
			;
		}
	else
		while( (*macro_ptr++ = *cptr++) != 'Z' )
			;
	/* Clobber macro terminator. */
	*--macro_ptr = NUL;
	macro_ptr = macro_buf;
	macro_entry = (Func_Tab *) malloc( sizeof(Func_Tab) );
	if( macro_entry == FT_NULL )
		{
		Malloc_Bomb();
		}
	macro_entry->f_func = f_Exec_Macro;
	macro_entry->f_buff = malloc( (unsigned) strlen( macro_buf )+1 );
	if( macro_entry->f_buff == NULL )
		{
		Malloc_Bomb();
		}
	(void) strcpy( macro_entry->f_buff, macro_buf );
	if( interactive )
		fb_log( "Keyboard macro defined.\n" );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Set_Rectangle(char *buf) /* Set current rectangle. */
          
	{
	get_Rectangle( "rectangle", &current );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Center_Window(char *buf) /* Center window around cursor. */
          
	{
	fb_Wind();
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Rd_Font(char *buf) /* Set current font. */
          
	{	static char fontname[FONTNAMESZ];
	if( ! get_Input( fontname, FONTNAMESZ, "Enter font name : " ) )
		return 0;
	get_Font( fontname );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Set_Pixel(char *buf) /* Set "paint" pixel color. */
          
	{
	fb_Get_Pixel( paint );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Move_Lft(char *buf) /* Move cursor left. */
          
	{
	if( cursor_pos.p_x >= step )
		cursor_pos.p_x -= step;
	else
		cursor_pos.p_x = 0;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Zoom_In(char *buf) /* Halve window size. */
          
	{
	if( size_viewport > fb_getwidth(fbp) / 16 )
		{
		size_viewport /= 2;
		fb_Wind();
		reposition_cursor = true;
		}
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Move_Dwn(char *buf) /* Move cursor down. */
          
	{
	if( cursor_pos.p_y >= step )
		cursor_pos.p_y -= step;
	else
		cursor_pos.p_y = 0;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Move_Up(char *buf) /* Move cursor up. */
          
	{
	if( cursor_pos.p_y <= fb_getheight(fbp) - step )
		cursor_pos.p_y += step;
	else
		cursor_pos.p_y = fb_getheight(fbp) - 1;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Move_Rgt(char *buf) /* Move cursor right. */
          
	{
	if( cursor_pos.p_x <= fb_getwidth(fbp) - step )
		cursor_pos.p_x += step;
	else
		cursor_pos.p_x = fb_getwidth(fbp) - 1;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Status_Monitor(char *buf) /* Toggle status monitoring. */
          
	{
	Toggle( report_status );
	if( report_status )
		init_Status();
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Zoom_Out(char *buf) /* Double window size. */
          
	{
	if( size_viewport < fb_getwidth(fbp) )
		{
		size_viewport *= 2;
		fb_Wind();
		reposition_cursor = true;
		}
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Key_Set_Pixel(char *buf) /* User types in paint color. */
          
	{	static char buffer[CLR_LEN];
	if( ! getColor( paint, "Enter color", buffer ) )
		return 0;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Quit(char *buf)
{
	prnt_Event( "Bye..." );
	restore_Tty();
	exit( 0 );
	/*NOTREACHED*/
	}

STATIC int
/*ARGSUSED*/
f_Rd_Fb(char *buf) /* Read frame buffer image from file. */
          
	{	static char image[MAX_LN];
		static FBIO *imp;
	if( ! get_Input( image, MAX_LN, "Enter framebuffer name : " ) )
		return 0;
	if( image[0] == NUL )
		{
		fb_log( "No default.\n" );
		return 0;
		}
	else
	if( (imp = fb_open( image, 512, 512 )) == FBIO_NULL )	/* XXX */
		{
		fb_log(	"Can't open \"%s\" for reading.\n", image );
		return 0;
		}
	prnt_Event( "Reading \"%s\".", image );
	(void) fb_cursor( fbp, 0, 0, 0 );	/* off */
	reposition_cursor = true;
	{	register int y;
	unsigned char *scanbuf;
	if( (scanbuf = (unsigned char *)malloc(fb_getwidth(imp)*3)) == RGBPIXEL_NULL )
		{
		fb_log(	"malloc failure\n");
		return 0;
		}
	for( y = 0; y < fb_getheight( imp ); y++ )
		{
		if( fb_read( imp, 0, y, scanbuf, fb_getwidth( imp ) ) == -1 )
			{
			prnt_Scroll( "Read from <0,%d> failed.\n" );
			return 0;
			}
		if( fb_write( fbp, 0, y, scanbuf, fb_getwidth( imp ) ) == -1 )
			{
			prnt_Scroll( "Write to <0,%d> failed.\n" );
			return 0;
			}
		}
	(void)free( (char *)scanbuf );
	}
	(void) fb_close( imp );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_String(char *buf) /* Place label on picture. */
          
	{	static char label[MAX_LN];
	if( ! get_Input( label, MAX_LN, "Enter text string : " ) )
		return 0;
	prnt_Event( "Drawing \"%s\".", label );
	do_line( cursor_pos.p_x, cursor_pos.p_y, label, (RGBpixel *)NULL );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Put_Pixel(char *buf) /* Put pixel. */
          
	{	register int rectwid = brush_sz / 2;
	/* If brush size is 2 or more, fill rectangle. */
	if( rectwid == 0 )
		{ /* Avoid overhead if only writing one pixel. */
		if( isSGI )
			(void) fb_write( fbp, cursor_pos.p_x, cursor_pos.p_y,
					paint, 1 );
		else
			{
			(void) fb_seek( fbp, cursor_pos.p_x, cursor_pos.p_y );
			FB_WPIXEL( fbp, paint );
			}
		}
	else
		fb_Paint( cursor_pos.p_x - rectwid, cursor_pos.p_y - rectwid,
			  cursor_pos.p_x + rectwid, cursor_pos.p_y + rectwid,
			  (RGBpixel *) paint
			  );
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Set_X_Pos(char *buf) /* Move cursor's X location (image space). */
          
	{	static char x_str[5];
	if( ! get_Input( x_str, 5, "Enter X coordinate : " ) )
		return 0;
	if( x_str[0] == '+' )	/* relative move (+x) */
		{	int increment;
		if( sscanf( x_str+1, "%d", &increment ) == 1 )
			cursor_pos.p_x += increment;
		}
	else
	if( x_str[0] == '-' )	/* relative move (-x) */
		{	int decrement;
		if( sscanf( x_str+1, "%d", &decrement ) == 1 )
			cursor_pos.p_x -= decrement;
		}
	else			/* absolute move */
		(void) sscanf( x_str, "%d", &cursor_pos.p_x );
	if( cursor_pos.p_x > fb_getwidth(fbp) )
		cursor_pos.p_x = fb_getwidth(fbp);
	if( cursor_pos.p_x < 0 )
		cursor_pos.p_x = 0;
	reposition_cursor = true;
	return 1;
	}

STATIC int
/*ARGSUSED*/
f_Set_Y_Pos(char *buf) /* Move cursor's Y location (image space). */
          
	{	static char y_str[5];
	if( ! get_Input( y_str, 5, "Enter Y coordinate : " ) )
		return 0;
	if( y_str[0] == '+' )	/* relative move (+y) */
		{	int increment;
		if( sscanf( y_str+1, "%d", &increment ) == 1 )
			cursor_pos.p_y += increment;
		}
	else
	if( y_str[0] == '-' )	/* relative move (-y) */
		{	int decrement;
		if( sscanf( y_str+1, "%d", &decrement ) == 1 )
			cursor_pos.p_y -= decrement;
		}
	else
		(void) sscanf( y_str, "%d", &cursor_pos.p_y );
	if( cursor_pos.p_y > fb_getheight(fbp) )
		cursor_pos.p_y = fb_getheight(fbp);
	if( cursor_pos.p_y < 0 )
		cursor_pos.p_y = 0;
	reposition_cursor = true;
	return 1;
	}

/*	p a r s _ A r g v ( ) */
STATIC int
pars_Argv(int argc, register char **argv)
{	register int c;
		extern int optind;
		extern char *optarg;
	/* Parse options. */
	while( (c = getopt( argc, argv, "hp" )) != EOF )
		{
		switch( c )
			{
		case 'h' :
			cur_width = 1024;
			break;
		case 'p' :
			pad_flag = true;
			break;
		case '?' :
			return 0;
			}
		}
	if( argc != optind )
		{
		(void) fprintf( stderr, "Too many arguments!\n" );
		return 0;
		}
	return 1;
	}

/*	f b _ S e t u p ( ) */
STATIC int
fb_Setup(void)
{
	if( (fbp = fb_open( NULL, cur_width, cur_width )) == FBIO_NULL )
		{
		fb_log( "Could not open default frame buffer.\n" );
		return -1;
		}
	/* Set global flag to indicate whether we are running on an
		SGI with graphics. */
	isSGI = strncmp( fbp->if_name, "/dev/sgi", 8 ) == 0;

	fb_ioinit( fbp );
	if( fb_setcursor( fbp, cursor.bits, cursor.xbits, cursor.ybits,
	    cursor.xorig, cursor.yorig ) == -1 )
		{
		fb_log( "Can't set up cursor.\n" );
		return 0;
		}
	windo_center.p_x = cursor_pos.p_x = image_center.p_x =
		fb_getwidth(fbp) / 2;
	windo_center.p_y = cursor_pos.p_y = image_center.p_y =
		fb_getheight(fbp) / 2;
	size_viewport = fb_getwidth(fbp);
	return 0;
	}

/*	f b _ W i n d ( ) */
STATIC void
fb_Wind(void)
{
	zoom_factor = fb_getwidth(fbp) / size_viewport;
	(void) fb_zoom( fbp, zoom_factor, zoom_factor );
	windo_anchor.p_x = windo_center.p_x = cursor_pos.p_x;
	windo_anchor.p_y = windo_center.p_y = cursor_pos.p_y;
	(void) fb_window( fbp, windo_center.p_x, windo_center.p_y );
	return;
	}

/*	f b _ P a i n t ( ) */
STATIC void
fb_Paint(register int x0, register int y0, register int x1, register int y1, RGBpixel (*color))
{	Rectangle clipped_rect;
	clipped_rect.r_origin.p_x = x0;
	clipped_rect.r_corner.p_x = x1;
	clipped_rect.r_origin.p_y = y0;
	clipped_rect.r_corner.p_y = y1;
	clip_Rectangle( &clipped_rect );
	fillRectangle( &clipped_rect, color ); 
	return;
	}

/*	g e n e r a l _ H a n d l e r ( ) */
#if STD_SIGNAL_DECLS
STATIC void
#else
STATIC int
#endif
general_Handler(int sig)
{
	switch( sig )
		{
	case SIGHUP :
		prnt_Event( "Hangup." );
		restore_Tty();
		exit( sig );
		/*NOTREACHED*/
	case SIGINT :
		prnt_Event( "Interrupt." );
		restore_Tty();
		exit( sig );
		/*NOTREACHED*/
	case SIGQUIT :
		prnt_Event( "Quit (core dumped)." );
		restore_Tty();
		abort();
		/*NOTREACHED*/
	case SIGILL :
		prnt_Event( "Illegal instruction (core dumped)." );
		restore_Tty();
		abort();
		/*NOTREACHED*/
#if defined(SIGIOT)
	case SIGIOT :
		prnt_Event( "IOT trap (core dumped)." );
		restore_Tty();
		abort();
		/*NOTREACHED*/
#endif
#if defined(SIGBUS)
	case SIGBUS :
		prnt_Event( "Bus error (core dumped)." );
		restore_Tty();
		abort();
		/*NOTREACHED*/
#endif
	case SIGSEGV :
		prnt_Event( "Segmentation violation (core dumped)." );
		restore_Tty();
		abort();
		/*NOTREACHED*/
	case SIGALRM :
		break;
#ifdef SIGWINCH
	case SIGWINCH :
		break;
#endif
#if defined(SIGCLD)
	case SIGCLD :
		break;
#endif
#if defined(SIGCHLD) && (SIGCLD != SIGCHLD)
	case SIGCHLD :
		break;
#endif

#if defined(SIGSTOP) && defined(SIGTSTP) && defined(SIGCONT)
	case SIGSTOP :
	case SIGTSTP :
		(void) f_Stop( (char *) NULL );
		break;
	case SIGCONT :
		break;
#endif
	default :
		prnt_Event( "\"%s\", signal(%d).", __FILE__, sig );
		/* restore_Tty(); */
		break;
		}
	(void) signal( sig, general_Handler );
#if STD_SIGNAL_DECLS
	return;
#else
	return sig;
#endif
	}

/*	i n i t _ T t y ( ) */
void
init_Tty(void)
{
	if( pad_flag )
		{
		if( pad_open( fb_getwidth(fbp) ) == -1 )
			pad_flag = false;
		}
	save_Tty( tty_fd );
	set_Raw( tty_fd );
	clr_Tabs( tty_fd );
	clr_Echo( tty_fd );
	clr_CRNL( tty_fd );
#if HAS_SGIGL
	if( isSGI )
		sgi_Init();
#endif
	return;
	}

/*	r e s t o r e _ T t y ( ) */
void
restore_Tty(void)
{
	(void) fb_cursor( fbp, 0, 0, 0 );	/* off */
	MvCursor( 1, LI );
	if( pad_flag )
		pad_close();
	reset_Tty( tty_fd );
	return;
	}

/*	f b _ G e t _ P i x e l ( ) */
void
fb_Get_Pixel(unsigned char *pixel)
{
	if( isSGI )
		(void) fb_read( fbp, cursor_pos.p_x, cursor_pos.p_y, pixel, 1 );
	else
		{
		(void) fb_seek( fbp, cursor_pos.p_x, cursor_pos.p_y );
		(void) fb_rpixel( fbp, (unsigned char *) pixel );
		}
	return;
	}

/*	g e t _ F b _ P a n e l ( ) */
RGBpixel *
get_Fb_Panel( rectp )
register Rectangle *rectp;
	{	register int top;
		register int rectwid;
		int recthgt;
		int btm, lft, rgt;
		RGBpixel *panel;
		unsigned	u;
	lft = rectp->r_origin.p_x;
	rgt = rectp->r_corner.p_x;
	btm = rectp->r_origin.p_y;
	top = rectp->r_corner.p_y;
	if( lft > rgt )
		{
		lft = rgt;
		rgt = rectp->r_origin.p_x;
		}
	if( btm > top )
		{
		top = btm;
		btm = rectp->r_origin.p_y;
		}
	rectwid = rgt-lft + 1;
	recthgt = top-btm + 1;
	u = (rectwid*recthgt) * sizeof(RGBpixel);
	if( (panel = (RGBpixel *) malloc( u )) == (RGBpixel *)RGBPIXEL_NULL )
		fb_log(	"\"%s\" (%d), get_Fb_Panel() : malloc %d (%d*%d) failed.\n",
			__FILE__, __LINE__,
			u, rectwid, recthgt
			);
	else
		{	register int y = btm;
			RGBpixel *pixelp = panel;
		for( ; y <= top; y++, pixelp += rectwid )
			{
			if( fb_read( fbp, lft, y, (unsigned char *)pixelp, rectwid ) == -1 )
				{
				fb_log( "Read of %d pixels from <%d,%d> failed.\n",
					rectwid, lft, y
					);
				return panel;
				}
			}
		}
	return panel;
	}

/*	p u t _ F b _ P a n e l ( ) */
STATIC void
put_Fb_Panel(register Rectangle *rectp, register RGBpixel (*panel))
{	register int top, rectwid, y;
		int lft, rgt, btm;
	rectwid = rectp->r_corner.p_x - rectp->r_origin.p_x + 1;
	clip_Rectangle( rectp );
	lft = rectp->r_origin.p_x;
	rgt = rectp->r_corner.p_x;
	btm = rectp->r_origin.p_y;
	top = rectp->r_corner.p_y;
	for( y = btm; y <= top; y++, panel += rectwid )
		{
		if( fb_write( fbp, lft, y, (unsigned char *)panel, rgt-lft+1 ) == -1 )
			{
			fb_log( "Write of %d pixels to <%d,%d> failed.\n",
				rectwid, lft, btm
				);
			return;
			}
		}
	return;
	}

/*	g e t _ P o i n t ( ) */
STATIC void
get_Point(char *msg, register Point *pointp)
{	register int tag_point = -1;
		register int c = NUL;
	prnt_Prompt( msg );
	pointpicked = false;
	for( ; tag_point != 1 && !pointpicked; )
		{	register int status_change = false;
		if( *cptr != NUL )
			{
			c = *cptr++;
			do_Key_Cmd( c, 1 );
			}
		else
			{
			if( reposition_cursor )
				{
				(void) fb_cursor(	fbp,
							1,
							cursor_pos.p_x,
							cursor_pos.p_y
							);
				status_change = true;
				reposition_cursor = false;
				}
			if( ! empty( tty_fd ) )
				{
				if( (c = get_Char()) != EOF )
					{
					do_Key_Cmd( c, 1 );
					status_change = true;
					}
				else	/* EOF detected. */
					{
					prnt_Scroll( "Premature EOF.\n" );
					return;
					}
				}
			if(   !	reposition_cursor
			    &&	(tag_point = get_Mouse_Pos( &cursor_pos ))
				!= -1
				)
				status_change = true;
			}
		if( status_change )
			{
			(void) fb_flush( fbp );
			if( report_status )
				prnt_Status();
			}
		}
	prnt_Event( "Point picked" );
	prnt_Prompt( "" );
	*pointp = cursor_pos;
	return;
	}

/*	g e t _ R e c t a n g l e ( ) */
STATIC void
get_Rectangle(char *name, register Rectangle *rectp)
{	char buf[MAX_LN];
	(void) sprintf( buf, "Pick lower-left corner of %s.", name );
	get_Point( buf, &rectp->r_origin );
	(void) sprintf( buf, "Pick upper-right corner of %s.", name );
	get_Point( buf, &rectp->r_corner );
	fix_Rectangle( rectp );
	return;
	}

STATIC void
fix_Rectangle(register Rectangle *rectp)
{	register int i;
	if( rectp->r_origin.p_x > rectp->r_corner.p_x )
		{
		i = rectp->r_origin.p_x;
		rectp->r_origin.p_x = rectp->r_corner.p_x;
		rectp->r_corner.p_x = i;
		}
	if( rectp->r_origin.p_y > rectp->r_corner.p_y )
		{
		i = rectp->r_origin.p_y;
		rectp->r_origin.p_y = rectp->r_corner.p_y;
		rectp->r_corner.p_y = i;
		}
	return;
	}

STATIC void
clip_Rectangle(register Rectangle *rectp)
{
	rectp->r_origin.p_x = rectp->r_origin.p_x < 0 ? 0 : rectp->r_origin.p_x;
	rectp->r_corner.p_x = rectp->r_corner.p_x >= fb_getwidth(fbp) ? fb_getwidth(fbp) - 1 : rectp->r_corner.p_x;
	rectp->r_origin.p_y = rectp->r_origin.p_y < 0 ? 0 : rectp->r_origin.p_y;
	rectp->r_corner.p_y = rectp->r_corner.p_y >= fb_getheight(fbp) ? fb_getheight(fbp) - 1 : rectp->r_corner.p_y;
	return;
	}

STATIC RGBpixel *
pixel_Avg( p1, p2, p3, p4 )
register RGBpixel *p1, *p2, *p3, *p4;
	{	static RGBpixel p_avg;
	p_avg[RED] = ((int) (*p1)[RED] + (int) (*p2)[RED] + (int) (*p3)[RED] + (int) (*p4)[RED]) / 4;
	p_avg[GRN] = ((int) (*p1)[GRN] + (int) (*p2)[GRN] + (int) (*p3)[GRN] + (int) (*p4)[GRN]) / 4;
	p_avg[BLU] = ((int) (*p1)[BLU] + (int) (*p2)[BLU] + (int) (*p3)[BLU] + (int) (*p4)[BLU]) / 4;
	return (RGBpixel *)p_avg;
	}

char *
char_To_String(int i)
{	static char buf[4];
	if( i >= SP && i < DEL )
		{
		buf[0] = i;
		buf[1] = NUL;
		}
	else
	if( i >= NUL && i < SP )
		{
		buf[0] = '^';
		buf[1] = i + 64;
		buf[2] = NUL;
		}
	else
	if( i == DEL )
		return "DL";
	else
		return "EOF";
	return buf;
	}
int
get_Mouse_Pos(Point *pointp)
{
	if( pad_flag )
		return do_Bitpad( pointp );
	else
#if HAS_SGIGL
	if( isSGI )
		return sgi_Mouse_Pos( &cursor_pos );
	else
#endif
		return -1;
	}

/*	d o _ B i t p a d ( ) */
STATIC int
do_Bitpad(register Point *pointp)
{	int press;
	if( ! pad_flag )
		return -1;
	if( (press = getpos( &bitpad )) != -1 )
		{		
		pointp->p_x = windo_anchor.p_x +
				(bitpad.p_x-image_center.p_x)/zoom_factor;
		pointp->p_y = windo_anchor.p_y +
				(bitpad.p_y-image_center.p_y)/zoom_factor;
		(void) fb_cursor( fbp, 1, pointp->p_x, pointp->p_y );
		if( press == 1 )
			De_Bounce_Pen();
		return press;
		}
	return -1;
	}

int
get_Char(void)
{	int c;
#if 0
	if( isSGI )
		return (c = sgi_Getchar()) == EOF ? EOF : toascii( c );
	else
#endif
		return (c = getchar()) == EOF ? EOF : toascii( c );
	}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fbed/fbed.c,v 11.8 2004/04/05 07:52:17 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 5
a16 1
#include "conf.h"
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbed/fbed.c,v 11.5 2001/08/09 17:45:24 jra Exp $ (BRL)";
d55 10
a64 4
bool AproxEqColor(a,b,t)
unsigned char a, b;
int t;
	{	int	c = a-b;
d94 9
a102 9
STATIC bool drawRectangle();
STATIC bool getColor();
STATIC bool paintNonBorder();
STATIC bool paintSolidRegion();
STATIC bool popPoint();
STATIC int do_Bitpad();
STATIC int fb_Setup();
STATIC int pars_Argv();
STATIC int push_Macro();
d104 1
a104 1
STATIC void general_Handler();
d108 74
a181 74
STATIC void init_Try();
STATIC void fb_Paint();
STATIC void fb_Wind();
STATIC void get_Point();
STATIC void clip_Rectangle();
STATIC void get_Rectangle();
STATIC void fillRectangle();
STATIC void fix_Rectangle();
STATIC void pushPoint();
STATIC void put_Fb_Panel();

STATIC int	/* ^X  */ f_Exec_Function(),
		/* ^I  */ f_Nop(),
		/* ^H  */ f_Win_Lft(),
		/* ^J  */ f_Win_Dwn(),
		/* ^K  */ f_Win_Up(),
		/* ^L  */ f_Win_Rgt(),
		/* ^M  */ f_Reset_View(),
		/* ^R  */ f_Redraw(),
		/* ^Z  */ f_Stop(),
		/* ESC */ f_Iterations(),
		/* SP  */ f_Press(),
		/* #   */ f_Comment(),
		/* ,   */ f_Dec_Brush_Size(),
		/* .   */ f_Inc_Brush_Size(),
		/* <   */ f_Dec_Step_Size(),
		/* >   */ f_Inc_Step_Size(),
		/* ?   */ f_Menu(),
		/* A   */ f_Start_Macro(),
		/* B   */ f_Bind_Macro_To_Key(),
		/* C   */ f_Crunch_Image(),
		/* E   */ f_Erase_Fb(),
		/* F   */ f_Flip_Resolution(),
		/* G   */ f_Get_Panel(),
		/* H   */ f_Jump_Lft(),
		/* J   */ f_Jump_Dwn(),
		/* K   */ f_Jump_Up(),
		/* L   */ f_Jump_Rgt(),
		/* N   */ f_Name_Keyboard_Macro(),
		/* P   */ f_Put_Panel(),
		/* R   */ f_Restore_RLE(),
		/* S   */ f_Save_RLE(),
		/* T   */ f_Transliterate(),
		/* U   */ f_Write_Macros_To_File(),
		/* V   */ f_FillRegion(),
		/* W   */ f_Fill_Panel(),
		/* X   */ f_Bind_Key_To_Key(),
		/* Y   */ f_Bind_Name_To_Key(),
		/* Z   */ f_Stop_Macro(),
		/* a   */ f_Enter_Macro_Definition(),
		/* b   */ f_Set_Rectangle(),
		/* c   */ f_Center_Window(),
		/* d   */ f_DrawLine(),
		/* f   */ f_Rd_Font(),
		/* g   */ f_Set_Pixel(),
		/* h   */ f_Move_Lft(),
		/* i   */ f_Zoom_In(),
		/* j   */ f_Move_Dwn(),
		/* k   */ f_Move_Up(),
		/* l   */ f_Move_Rgt(),
		/* m   */ f_Status_Monitor(),
		/* n   */ f_Tolerance(),
		/* o   */ f_Zoom_Out(),
		/* p   */ f_Key_Set_Pixel(),
		/* q   */ f_Quit(),
		/* r   */ f_Rd_Fb(),
		/* s   */ f_String(),
		/* t   */ f_ChngRegionColor(),
		/* u   */ f_Rd_Macros_From_File(),
		/* v   */ f_DrawRectangle(),
		/* w   */ f_Put_Pixel(),
		/* x   */ f_Set_X_Pos(),
		/* y   */ f_Set_Y_Pos(),
		/* Unbound */ f_Exec_Macro();
d323 2
a324 3
main( argc, argv )
char *argv[];
	{
d423 2
a424 4
drawRectangle( rectp, pixelp )
Rectangle *rectp;
unsigned char *pixelp;
	{	register int x, y;
d443 2
a444 4
fillRectangle( rectp, pixelp )
register Rectangle *rectp;
register RGBpixel *pixelp;
	{	register int btm = rectp->r_origin.p_y;
d473 2
a474 4
paintNonBorder( borderpix, pt )
RGBpixel borderpix;
Point *pt;
	{	RGBpixel currentpix;
d493 2
a494 4
paintSolidRegion( regionpix, pt )
RGBpixel regionpix;
Point *pt;
	{	RGBpixel currentpix;
a508 7
typedef struct pointstack PtStack;
struct pointstack
	{
	Point pt;
	PtStack *next;
	};

d510 2
a511 4
pushPoint( pt, spp )
Point *pt;
PtStack **spp;
	{	register PtStack *new;
d524 2
a525 4
popPoint( pt, spp )
Point *pt;
register PtStack **spp;
	{	register PtStack *next;
d539 2
a540 2
init_Try()
	{	register int key;
d561 2
a562 3
push_Macro( buf )
char *buf;
	{	register int curlen = strlen( cptr );
d578 2
a579 4
do_Key_Cmd( key, n )
register int key;
register int n;
	{
d608 2
a609 5
getColor( pixelp, prompt, buffer )
RGBpixel pixelp;
char *prompt;
char *buffer;
	{	static char promptbuf[PROMPT_LEN];
d636 2
a637 3
f_Tolerance( buf )
char *buf;
	{	static char tol_str[4];
d648 2
a649 3
f_ChngRegionColor( buf )
char *buf;
	{	static int xoff1[] = { 0, 1,  0, -1 };
d678 2
a679 3
f_FillRegion( buf )
char *buf;
	{	static int xoff1[] = { 0, 1,  0, -1 };
d707 2
a708 3
f_Nop( buf )
char *buf;
	{
d716 2
a717 2
f_Win_Lft( buf ) /* Move window left. */
char *buf;
d727 2
a728 2
f_Win_Dwn( buf ) /* Move window down. */
char *buf;
d738 2
a739 2
f_Win_Up( buf ) /* Move window up. */
char *buf;
d749 2
a750 2
f_Win_Rgt( buf ) /* Move window right. */
char *buf;
d760 2
a761 2
f_Reset_View( buf ) /* Restore normal view. */
char *buf;
d773 2
a774 2
f_Redraw( buf ) /* Redraw screen. */
char *buf;
d783 2
a784 2
f_Stop( buf ) /* Stop program. */
char *buf;
d809 2
a810 3
f_Exec_Function( buf )
char *buf;
	{	Func_Tab	*ftbl;
d827 2
a828 2
f_Iterations( buf ) /* Specify number of iterations of next command. */
char *buf;
d858 2
a859 3
f_Press( buf )
char *buf;
	{
d866 2
a867 2
f_Comment( buf ) /* Print comment. */
char *buf;
d877 2
a878 2
f_Dec_Brush_Size( buf ) /* Decrement brush size. */
char *buf;
d887 2
a888 2
f_Inc_Brush_Size( buf ) /* Increment brush size. */
char *buf;
d897 2
a898 2
f_Menu( buf ) /* Print menu. */
char *buf;
d947 2
a948 2
f_Dec_Step_Size( buf ) /* Decrement gain on move operations. */
char *buf;
d957 2
a958 2
f_Inc_Step_Size( buf ) /* Increment gain on move operations. */
char *buf;
d966 2
a967 3
f_Exec_Macro( buf )
char *buf;
	{
d974 2
a975 3
f_Rd_Macros_From_File( buf )
char *buf;
	{	register FILE	*macro_fp;
d1010 2
a1011 3
f_Write_Macros_To_File( buf )
char *buf;
	{	static char macro_file[MAX_LN];
d1074 2
a1075 3
f_Start_Macro( buf )
char *buf;
	{
d1090 2
a1091 3
f_Bind_Macro_To_Key( buf )
char *buf;
	{	char key[2];
d1113 2
a1114 3
f_Name_Keyboard_Macro( buf )
char *buf;
	{	static char macro_name[MAX_LN];
d1134 2
a1135 2
f_Crunch_Image( buf ) /* Average image to half its size. */
char *buf;
d1177 2
a1178 3
f_DrawLine( buf )
char *buf;
	{	Rectangle lineseg;
d1247 2
a1248 2
f_DrawRectangle( buf ) /* Draw current rectangle with "paint" color. */
char *buf;
d1255 2
a1256 2
f_Fill_Panel( buf ) /* Fill current rectangle with "paint" color. */
char *buf;
d1264 2
a1265 2
f_Bind_Key_To_Key( buf ) /* Bind new key to same function as old key. */
char *buf;
d1285 2
a1286 2
f_Bind_Name_To_Key( buf ) /* Bind key to function or macro. */
char *buf;
d1319 2
a1320 2
f_Erase_Fb( buf ) /* Erase (clear) framebuffer. */
char *buf;
d1334 2
a1335 2
f_Flip_Resolution( buf ) /* Flip framebuffer resolution. */
char *buf;
d1360 2
a1361 2
f_Get_Panel( buf ) /* Grab panel from framebuffer. */
char *buf;
d1375 2
a1376 2
f_Jump_Lft( buf ) /* Move cursor left (big steps). */
char *buf;
d1388 2
a1389 2
f_Jump_Dwn( buf ) /* Move cursor down. */
char *buf;
d1401 2
a1402 2
f_Jump_Up( buf ) /* Move cursor up. */
char *buf;
d1414 2
a1415 2
f_Jump_Rgt( buf ) /* Move cursor right. */
char *buf;
d1427 2
a1428 2
f_Put_Panel( buf ) /* Put grabbed panel to framebuffer. */
char *buf;
d1444 2
a1445 2
f_Restore_RLE( buf ) /* Restore Run-Length Encoded image. */
char *buf;
d1482 2
a1483 2
f_Save_RLE( buf ) /* Save framebuffer image with Run-Length Encoding. */
char *buf;
d1529 2
a1530 2
f_Transliterate( buf ) /* Transliterate pixels of color1 to target color2.*/
char *buf;
d1563 2
a1564 3
f_Stop_Macro( buf )
char *buf;
	{
d1597 2
a1598 3
f_Enter_Macro_Definition( buf )
char *buf;
	{	register int interactive = *cptr == NUL;
d1632 2
a1633 2
f_Set_Rectangle( buf ) /* Set current rectangle. */
char *buf;
d1641 2
a1642 2
f_Center_Window( buf ) /* Center window around cursor. */
char *buf;
d1651 2
a1652 2
f_Rd_Font( buf ) /* Set current font. */
char *buf;
d1662 2
a1663 2
f_Set_Pixel( buf ) /* Set "paint" pixel color. */
char *buf;
d1671 2
a1672 2
f_Move_Lft( buf ) /* Move cursor left. */
char *buf;
d1684 2
a1685 2
f_Zoom_In( buf ) /* Halve window size. */
char *buf;
d1698 2
a1699 2
f_Move_Dwn( buf ) /* Move cursor down. */
char *buf;
d1711 2
a1712 2
f_Move_Up( buf ) /* Move cursor up. */
char *buf;
d1724 2
a1725 2
f_Move_Rgt( buf ) /* Move cursor right. */
char *buf;
d1737 2
a1738 2
f_Status_Monitor( buf ) /* Toggle status monitoring. */
char *buf;
d1748 2
a1749 2
f_Zoom_Out( buf ) /* Double window size. */
char *buf;
d1762 2
a1763 2
f_Key_Set_Pixel( buf ) /* User types in paint color. */
char *buf;
d1772 2
a1773 3
f_Quit( buf )
char *buf;
	{
d1782 2
a1783 2
f_Rd_Fb( buf ) /* Read frame buffer image from file. */
char *buf;
d1830 2
a1831 2
f_String( buf ) /* Place label on picture. */
char *buf;
d1836 1
a1836 1
	do_line( cursor_pos.p_x, cursor_pos.p_y, label, (unsigned char *)NULL );
d1842 2
a1843 2
f_Put_Pixel( buf ) /* Put pixel. */
char *buf;
d1860 1
a1860 1
			  (unsigned char *) paint
d1867 2
a1868 2
f_Set_X_Pos( buf ) /* Move cursor's X location (image space). */
char *buf;
d1895 2
a1896 2
f_Set_Y_Pos( buf ) /* Move cursor's Y location (image space). */
char *buf;
d1923 2
a1924 3
pars_Argv( argc, argv )
register char **argv;
	{	register int c;
d1952 2
a1953 2
fb_Setup()
	{
d1980 2
a1981 2
fb_Wind()
	{
d1992 2
a1993 4
fb_Paint( x0, y0, x1, y1, color )
register int x0, y0, x1, y1;
RGBpixel *color;
	{	Rectangle clipped_rect;
d2009 2
a2010 3
general_Handler( sig )
int sig;
	{
d2090 2
a2091 2
init_Tty()
	{
d2111 2
a2112 2
restore_Tty()
	{
d2123 2
a2124 3
fb_Get_Pixel( pixel )
RGBpixel pixel;
	{
d2186 2
a2187 4
put_Fb_Panel( rectp, panel )
register Rectangle *rectp;
register RGBpixel *panel;
	{	register int top, rectwid, y;
d2210 2
a2211 4
get_Point( msg, pointp )
char *msg;
register Point *pointp;
	{	register int tag_point = -1;
d2268 2
a2269 4
get_Rectangle( name, rectp )
char *name;
register Rectangle *rectp;
	{	char buf[MAX_LN];
d2279 2
a2280 3
fix_Rectangle( rectp )
register Rectangle *rectp;
	{	register int i;
d2297 2
a2298 3
clip_Rectangle( rectp )
register Rectangle *rectp;
	{
d2317 2
a2318 3
char_To_String( i )
int i;
	{	static char buf[4];
d2339 2
a2340 3
get_Mouse_Pos( pointp )
Point *pointp;
	{
d2354 2
a2355 3
do_Bitpad( pointp )
register Point *pointp;
	{	int press;
d2373 2
a2374 2
get_Char()
	{	int c;
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbed/fbed.c,v 11.7 2002/08/20 17:07:27 jra Exp $ (BRL)";
d55 4
a58 10
typedef struct pointstack PtStack;
struct pointstack
	{
	Point pt;
	PtStack *next;
	};


bool AproxEqColor(unsigned char a, unsigned char b, int t)
{	int	c = a-b;
d88 9
a96 9
STATIC bool drawRectangle(Rectangle *rectp, unsigned char *pixelp);
STATIC bool getColor(unsigned char *pixelp, char *prompt, char *buffer);
STATIC bool paintNonBorder(unsigned char *borderpix, Point *pt);
STATIC bool paintSolidRegion(unsigned char *regionpix, Point *pt);
STATIC bool popPoint(Point *pt, register PtStack **spp);
STATIC int do_Bitpad(register Point *pointp);
STATIC int fb_Setup(void);
STATIC int pars_Argv(int argc, register char **argv);
STATIC int push_Macro(char *buf);
d98 1
a98 1
STATIC void general_Handler(int sig);
d102 74
a175 74
STATIC void init_Try(void);
STATIC void fb_Paint(register int x0, register int y0, register int x1, register int y1, RGBpixel (*color));
STATIC void fb_Wind(void);
STATIC void get_Point(char *msg, register Point *pointp);
STATIC void clip_Rectangle(register Rectangle *rectp);
STATIC void get_Rectangle(char *name, register Rectangle *rectp);
STATIC void fillRectangle(register Rectangle *rectp, register RGBpixel (*pixelp));
STATIC void fix_Rectangle(register Rectangle *rectp);
STATIC void pushPoint(Point *pt, PtStack **spp);
STATIC void put_Fb_Panel(register Rectangle *rectp, register RGBpixel (*panel));

STATIC int	/* ^X  */ f_Exec_Function(char *buf),
		/* ^I  */ f_Nop(char *buf),
		/* ^H  */ f_Win_Lft(char *buf),
		/* ^J  */ f_Win_Dwn(char *buf),
		/* ^K  */ f_Win_Up(char *buf),
		/* ^L  */ f_Win_Rgt(char *buf),
		/* ^M  */ f_Reset_View(char *buf),
		/* ^R  */ f_Redraw(char *buf),
		/* ^Z  */ f_Stop(char *buf),
		/* ESC */ f_Iterations(char *buf),
		/* SP  */ f_Press(char *buf),
		/* #   */ f_Comment(char *buf),
		/* ,   */ f_Dec_Brush_Size(char *buf),
		/* .   */ f_Inc_Brush_Size(char *buf),
		/* <   */ f_Dec_Step_Size(char *buf),
		/* >   */ f_Inc_Step_Size(char *buf),
		/* ?   */ f_Menu(char *buf),
		/* A   */ f_Start_Macro(char *buf),
		/* B   */ f_Bind_Macro_To_Key(char *buf),
		/* C   */ f_Crunch_Image(char *buf),
		/* E   */ f_Erase_Fb(char *buf),
		/* F   */ f_Flip_Resolution(char *buf),
		/* G   */ f_Get_Panel(char *buf),
		/* H   */ f_Jump_Lft(char *buf),
		/* J   */ f_Jump_Dwn(char *buf),
		/* K   */ f_Jump_Up(char *buf),
		/* L   */ f_Jump_Rgt(char *buf),
		/* N   */ f_Name_Keyboard_Macro(char *buf),
		/* P   */ f_Put_Panel(char *buf),
		/* R   */ f_Restore_RLE(char *buf),
		/* S   */ f_Save_RLE(char *buf),
		/* T   */ f_Transliterate(char *buf),
		/* U   */ f_Write_Macros_To_File(char *buf),
		/* V   */ f_FillRegion(char *buf),
		/* W   */ f_Fill_Panel(char *buf),
		/* X   */ f_Bind_Key_To_Key(char *buf),
		/* Y   */ f_Bind_Name_To_Key(char *buf),
		/* Z   */ f_Stop_Macro(char *buf),
		/* a   */ f_Enter_Macro_Definition(char *buf),
		/* b   */ f_Set_Rectangle(char *buf),
		/* c   */ f_Center_Window(char *buf),
		/* d   */ f_DrawLine(char *buf),
		/* f   */ f_Rd_Font(char *buf),
		/* g   */ f_Set_Pixel(char *buf),
		/* h   */ f_Move_Lft(char *buf),
		/* i   */ f_Zoom_In(char *buf),
		/* j   */ f_Move_Dwn(char *buf),
		/* k   */ f_Move_Up(char *buf),
		/* l   */ f_Move_Rgt(char *buf),
		/* m   */ f_Status_Monitor(char *buf),
		/* n   */ f_Tolerance(char *buf),
		/* o   */ f_Zoom_Out(char *buf),
		/* p   */ f_Key_Set_Pixel(char *buf),
		/* q   */ f_Quit(char *buf),
		/* r   */ f_Rd_Fb(char *buf),
		/* s   */ f_String(char *buf),
		/* t   */ f_ChngRegionColor(char *buf),
		/* u   */ f_Rd_Macros_From_File(char *buf),
		/* v   */ f_DrawRectangle(char *buf),
		/* w   */ f_Put_Pixel(char *buf),
		/* x   */ f_Set_X_Pos(char *buf),
		/* y   */ f_Set_Y_Pos(char *buf),
		/* Unbound */ f_Exec_Macro(char *buf);
d317 3
a319 2
main(int argc, char **argv)
{
d418 4
a421 2
drawRectangle(Rectangle *rectp, unsigned char *pixelp)
{	register int x, y;
d440 4
a443 2
fillRectangle(register Rectangle *rectp, register RGBpixel (*pixelp))
{	register int btm = rectp->r_origin.p_y;
d472 4
a475 2
paintNonBorder(unsigned char *borderpix, Point *pt)
{	RGBpixel currentpix;
d494 4
a497 2
paintSolidRegion(unsigned char *regionpix, Point *pt)
{	RGBpixel currentpix;
d512 7
d520 4
a523 2
pushPoint(Point *pt, PtStack **spp)
{	register PtStack *new;
d536 4
a539 2
popPoint(Point *pt, register PtStack **spp)
{	register PtStack *next;
d553 2
a554 2
init_Try(void)
{	register int key;
d575 3
a577 2
push_Macro(char *buf)
{	register int curlen = strlen( cptr );
d593 4
a596 2
do_Key_Cmd(register int key, register int n)
{
d625 5
a629 2
getColor(unsigned char *pixelp, char *prompt, char *buffer)
{	static char promptbuf[PROMPT_LEN];
d656 3
a658 2
f_Tolerance(char *buf)
{	static char tol_str[4];
d669 3
a671 2
f_ChngRegionColor(char *buf)
{	static int xoff1[] = { 0, 1,  0, -1 };
d700 3
a702 2
f_FillRegion(char *buf)
{	static int xoff1[] = { 0, 1,  0, -1 };
d730 3
a732 2
f_Nop(char *buf)
{
d740 2
a741 2
f_Win_Lft(char *buf) /* Move window left. */
          
d751 2
a752 2
f_Win_Dwn(char *buf) /* Move window down. */
          
d762 2
a763 2
f_Win_Up(char *buf) /* Move window up. */
          
d773 2
a774 2
f_Win_Rgt(char *buf) /* Move window right. */
          
d784 2
a785 2
f_Reset_View(char *buf) /* Restore normal view. */
          
d797 2
a798 2
f_Redraw(char *buf) /* Redraw screen. */
          
d807 2
a808 2
f_Stop(char *buf) /* Stop program. */
          
d833 3
a835 2
f_Exec_Function(char *buf)
{	Func_Tab	*ftbl;
d852 2
a853 2
f_Iterations(char *buf) /* Specify number of iterations of next command. */
          
d883 3
a885 2
f_Press(char *buf)
{
d892 2
a893 2
f_Comment(char *buf) /* Print comment. */
          
d903 2
a904 2
f_Dec_Brush_Size(char *buf) /* Decrement brush size. */
          
d913 2
a914 2
f_Inc_Brush_Size(char *buf) /* Increment brush size. */
          
d923 2
a924 2
f_Menu(char *buf) /* Print menu. */
          
d973 2
a974 2
f_Dec_Step_Size(char *buf) /* Decrement gain on move operations. */
          
d983 2
a984 2
f_Inc_Step_Size(char *buf) /* Increment gain on move operations. */
          
d992 3
a994 2
f_Exec_Macro(char *buf)
{
d1001 3
a1003 2
f_Rd_Macros_From_File(char *buf)
{	register FILE	*macro_fp;
d1038 3
a1040 2
f_Write_Macros_To_File(char *buf)
{	static char macro_file[MAX_LN];
d1103 3
a1105 2
f_Start_Macro(char *buf)
{
d1120 3
a1122 2
f_Bind_Macro_To_Key(char *buf)
{	char key[2];
d1144 3
a1146 2
f_Name_Keyboard_Macro(char *buf)
{	static char macro_name[MAX_LN];
d1166 2
a1167 2
f_Crunch_Image(char *buf) /* Average image to half its size. */
          
d1209 3
a1211 2
f_DrawLine(char *buf)
{	Rectangle lineseg;
d1280 2
a1281 2
f_DrawRectangle(char *buf) /* Draw current rectangle with "paint" color. */
          
d1288 2
a1289 2
f_Fill_Panel(char *buf) /* Fill current rectangle with "paint" color. */
          
d1297 2
a1298 2
f_Bind_Key_To_Key(char *buf) /* Bind new key to same function as old key. */
          
d1318 2
a1319 2
f_Bind_Name_To_Key(char *buf) /* Bind key to function or macro. */
          
d1352 2
a1353 2
f_Erase_Fb(char *buf) /* Erase (clear) framebuffer. */
          
d1367 2
a1368 2
f_Flip_Resolution(char *buf) /* Flip framebuffer resolution. */
          
d1393 2
a1394 2
f_Get_Panel(char *buf) /* Grab panel from framebuffer. */
          
d1408 2
a1409 2
f_Jump_Lft(char *buf) /* Move cursor left (big steps). */
          
d1421 2
a1422 2
f_Jump_Dwn(char *buf) /* Move cursor down. */
          
d1434 2
a1435 2
f_Jump_Up(char *buf) /* Move cursor up. */
          
d1447 2
a1448 2
f_Jump_Rgt(char *buf) /* Move cursor right. */
          
d1460 2
a1461 2
f_Put_Panel(char *buf) /* Put grabbed panel to framebuffer. */
          
d1477 2
a1478 2
f_Restore_RLE(char *buf) /* Restore Run-Length Encoded image. */
          
d1515 2
a1516 2
f_Save_RLE(char *buf) /* Save framebuffer image with Run-Length Encoding. */
          
d1562 2
a1563 2
f_Transliterate(char *buf) /* Transliterate pixels of color1 to target color2.*/
          
d1596 3
a1598 2
f_Stop_Macro(char *buf)
{
d1631 3
a1633 2
f_Enter_Macro_Definition(char *buf)
{	register int interactive = *cptr == NUL;
d1667 2
a1668 2
f_Set_Rectangle(char *buf) /* Set current rectangle. */
          
d1676 2
a1677 2
f_Center_Window(char *buf) /* Center window around cursor. */
          
d1686 2
a1687 2
f_Rd_Font(char *buf) /* Set current font. */
          
d1697 2
a1698 2
f_Set_Pixel(char *buf) /* Set "paint" pixel color. */
          
d1706 2
a1707 2
f_Move_Lft(char *buf) /* Move cursor left. */
          
d1719 2
a1720 2
f_Zoom_In(char *buf) /* Halve window size. */
          
d1733 2
a1734 2
f_Move_Dwn(char *buf) /* Move cursor down. */
          
d1746 2
a1747 2
f_Move_Up(char *buf) /* Move cursor up. */
          
d1759 2
a1760 2
f_Move_Rgt(char *buf) /* Move cursor right. */
          
d1772 2
a1773 2
f_Status_Monitor(char *buf) /* Toggle status monitoring. */
          
d1783 2
a1784 2
f_Zoom_Out(char *buf) /* Double window size. */
          
d1797 2
a1798 2
f_Key_Set_Pixel(char *buf) /* User types in paint color. */
          
d1807 3
a1809 2
f_Quit(char *buf)
{
d1818 2
a1819 2
f_Rd_Fb(char *buf) /* Read frame buffer image from file. */
          
d1866 2
a1867 2
f_String(char *buf) /* Place label on picture. */
          
d1872 1
a1872 1
	do_line( cursor_pos.p_x, cursor_pos.p_y, label, (RGBpixel *)NULL );
d1878 2
a1879 2
f_Put_Pixel(char *buf) /* Put pixel. */
          
d1896 1
a1896 1
			  (RGBpixel *) paint
d1903 2
a1904 2
f_Set_X_Pos(char *buf) /* Move cursor's X location (image space). */
          
d1931 2
a1932 2
f_Set_Y_Pos(char *buf) /* Move cursor's Y location (image space). */
          
d1959 3
a1961 2
pars_Argv(int argc, register char **argv)
{	register int c;
d1989 2
a1990 2
fb_Setup(void)
{
d2017 2
a2018 2
fb_Wind(void)
{
d2029 4
a2032 2
fb_Paint(register int x0, register int y0, register int x1, register int y1, RGBpixel (*color))
{	Rectangle clipped_rect;
d2048 3
a2050 2
general_Handler(int sig)
{
d2130 2
a2131 2
init_Tty(void)
{
d2151 2
a2152 2
restore_Tty(void)
{
d2163 3
a2165 2
fb_Get_Pixel(unsigned char *pixel)
{
d2227 4
a2230 2
put_Fb_Panel(register Rectangle *rectp, register RGBpixel (*panel))
{	register int top, rectwid, y;
d2253 4
a2256 2
get_Point(char *msg, register Point *pointp)
{	register int tag_point = -1;
d2313 4
a2316 2
get_Rectangle(char *name, register Rectangle *rectp)
{	char buf[MAX_LN];
d2326 3
a2328 2
fix_Rectangle(register Rectangle *rectp)
{	register int i;
d2345 3
a2347 2
clip_Rectangle(register Rectangle *rectp)
{
d2366 3
a2368 2
char_To_String(int i)
{	static char buf[4];
d2389 3
a2391 2
get_Mouse_Pos(Point *pointp)
{
d2405 3
a2407 2
do_Bitpad(register Point *pointp)
{	int press;
d2425 2
a2426 2
get_Char(void)
{	int c;
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d55 4
a58 10
typedef struct pointstack PtStack;
struct pointstack
	{
	Point pt;
	PtStack *next;
	};


bool AproxEqColor(unsigned char a, unsigned char b, int t)
{	int	c = a-b;
d88 9
a96 9
STATIC bool drawRectangle(Rectangle *rectp, unsigned char *pixelp);
STATIC bool getColor(unsigned char *pixelp, char *prompt, char *buffer);
STATIC bool paintNonBorder(unsigned char *borderpix, Point *pt);
STATIC bool paintSolidRegion(unsigned char *regionpix, Point *pt);
STATIC bool popPoint(Point *pt, register PtStack **spp);
STATIC int do_Bitpad(register Point *pointp);
STATIC int fb_Setup(void);
STATIC int pars_Argv(int argc, register char **argv);
STATIC int push_Macro(char *buf);
d98 1
a98 1
STATIC void general_Handler(int sig);
d102 74
a175 74
STATIC void init_Try(void);
STATIC void fb_Paint(register int x0, register int y0, register int x1, register int y1, RGBpixel (*color));
STATIC void fb_Wind(void);
STATIC void get_Point(char *msg, register Point *pointp);
STATIC void clip_Rectangle(register Rectangle *rectp);
STATIC void get_Rectangle(char *name, register Rectangle *rectp);
STATIC void fillRectangle(register Rectangle *rectp, register RGBpixel (*pixelp));
STATIC void fix_Rectangle(register Rectangle *rectp);
STATIC void pushPoint(Point *pt, PtStack **spp);
STATIC void put_Fb_Panel(register Rectangle *rectp, register RGBpixel (*panel));

STATIC int	/* ^X  */ f_Exec_Function(char *buf),
		/* ^I  */ f_Nop(char *buf),
		/* ^H  */ f_Win_Lft(char *buf),
		/* ^J  */ f_Win_Dwn(char *buf),
		/* ^K  */ f_Win_Up(char *buf),
		/* ^L  */ f_Win_Rgt(char *buf),
		/* ^M  */ f_Reset_View(char *buf),
		/* ^R  */ f_Redraw(char *buf),
		/* ^Z  */ f_Stop(char *buf),
		/* ESC */ f_Iterations(char *buf),
		/* SP  */ f_Press(char *buf),
		/* #   */ f_Comment(char *buf),
		/* ,   */ f_Dec_Brush_Size(char *buf),
		/* .   */ f_Inc_Brush_Size(char *buf),
		/* <   */ f_Dec_Step_Size(char *buf),
		/* >   */ f_Inc_Step_Size(char *buf),
		/* ?   */ f_Menu(char *buf),
		/* A   */ f_Start_Macro(char *buf),
		/* B   */ f_Bind_Macro_To_Key(char *buf),
		/* C   */ f_Crunch_Image(char *buf),
		/* E   */ f_Erase_Fb(char *buf),
		/* F   */ f_Flip_Resolution(char *buf),
		/* G   */ f_Get_Panel(char *buf),
		/* H   */ f_Jump_Lft(char *buf),
		/* J   */ f_Jump_Dwn(char *buf),
		/* K   */ f_Jump_Up(char *buf),
		/* L   */ f_Jump_Rgt(char *buf),
		/* N   */ f_Name_Keyboard_Macro(char *buf),
		/* P   */ f_Put_Panel(char *buf),
		/* R   */ f_Restore_RLE(char *buf),
		/* S   */ f_Save_RLE(char *buf),
		/* T   */ f_Transliterate(char *buf),
		/* U   */ f_Write_Macros_To_File(char *buf),
		/* V   */ f_FillRegion(char *buf),
		/* W   */ f_Fill_Panel(char *buf),
		/* X   */ f_Bind_Key_To_Key(char *buf),
		/* Y   */ f_Bind_Name_To_Key(char *buf),
		/* Z   */ f_Stop_Macro(char *buf),
		/* a   */ f_Enter_Macro_Definition(char *buf),
		/* b   */ f_Set_Rectangle(char *buf),
		/* c   */ f_Center_Window(char *buf),
		/* d   */ f_DrawLine(char *buf),
		/* f   */ f_Rd_Font(char *buf),
		/* g   */ f_Set_Pixel(char *buf),
		/* h   */ f_Move_Lft(char *buf),
		/* i   */ f_Zoom_In(char *buf),
		/* j   */ f_Move_Dwn(char *buf),
		/* k   */ f_Move_Up(char *buf),
		/* l   */ f_Move_Rgt(char *buf),
		/* m   */ f_Status_Monitor(char *buf),
		/* n   */ f_Tolerance(char *buf),
		/* o   */ f_Zoom_Out(char *buf),
		/* p   */ f_Key_Set_Pixel(char *buf),
		/* q   */ f_Quit(char *buf),
		/* r   */ f_Rd_Fb(char *buf),
		/* s   */ f_String(char *buf),
		/* t   */ f_ChngRegionColor(char *buf),
		/* u   */ f_Rd_Macros_From_File(char *buf),
		/* v   */ f_DrawRectangle(char *buf),
		/* w   */ f_Put_Pixel(char *buf),
		/* x   */ f_Set_X_Pos(char *buf),
		/* y   */ f_Set_Y_Pos(char *buf),
		/* Unbound */ f_Exec_Macro(char *buf);
d317 3
a319 2
main(int argc, char **argv)
{
d418 4
a421 2
drawRectangle(Rectangle *rectp, unsigned char *pixelp)
{	register int x, y;
d440 4
a443 2
fillRectangle(register Rectangle *rectp, register RGBpixel (*pixelp))
{	register int btm = rectp->r_origin.p_y;
d472 4
a475 2
paintNonBorder(unsigned char *borderpix, Point *pt)
{	RGBpixel currentpix;
d494 4
a497 2
paintSolidRegion(unsigned char *regionpix, Point *pt)
{	RGBpixel currentpix;
d512 7
d520 4
a523 2
pushPoint(Point *pt, PtStack **spp)
{	register PtStack *new;
d536 4
a539 2
popPoint(Point *pt, register PtStack **spp)
{	register PtStack *next;
d553 2
a554 2
init_Try(void)
{	register int key;
d575 3
a577 2
push_Macro(char *buf)
{	register int curlen = strlen( cptr );
d593 4
a596 2
do_Key_Cmd(register int key, register int n)
{
d625 5
a629 2
getColor(unsigned char *pixelp, char *prompt, char *buffer)
{	static char promptbuf[PROMPT_LEN];
d656 3
a658 2
f_Tolerance(char *buf)
{	static char tol_str[4];
d669 3
a671 2
f_ChngRegionColor(char *buf)
{	static int xoff1[] = { 0, 1,  0, -1 };
d700 3
a702 2
f_FillRegion(char *buf)
{	static int xoff1[] = { 0, 1,  0, -1 };
d730 3
a732 2
f_Nop(char *buf)
{
d740 2
a741 2
f_Win_Lft(char *buf) /* Move window left. */
          
d751 2
a752 2
f_Win_Dwn(char *buf) /* Move window down. */
          
d762 2
a763 2
f_Win_Up(char *buf) /* Move window up. */
          
d773 2
a774 2
f_Win_Rgt(char *buf) /* Move window right. */
          
d784 2
a785 2
f_Reset_View(char *buf) /* Restore normal view. */
          
d797 2
a798 2
f_Redraw(char *buf) /* Redraw screen. */
          
d807 2
a808 2
f_Stop(char *buf) /* Stop program. */
          
d833 3
a835 2
f_Exec_Function(char *buf)
{	Func_Tab	*ftbl;
d852 2
a853 2
f_Iterations(char *buf) /* Specify number of iterations of next command. */
          
d883 3
a885 2
f_Press(char *buf)
{
d892 2
a893 2
f_Comment(char *buf) /* Print comment. */
          
d903 2
a904 2
f_Dec_Brush_Size(char *buf) /* Decrement brush size. */
          
d913 2
a914 2
f_Inc_Brush_Size(char *buf) /* Increment brush size. */
          
d923 2
a924 2
f_Menu(char *buf) /* Print menu. */
          
d973 2
a974 2
f_Dec_Step_Size(char *buf) /* Decrement gain on move operations. */
          
d983 2
a984 2
f_Inc_Step_Size(char *buf) /* Increment gain on move operations. */
          
d992 3
a994 2
f_Exec_Macro(char *buf)
{
d1001 3
a1003 2
f_Rd_Macros_From_File(char *buf)
{	register FILE	*macro_fp;
d1038 3
a1040 2
f_Write_Macros_To_File(char *buf)
{	static char macro_file[MAX_LN];
d1103 3
a1105 2
f_Start_Macro(char *buf)
{
d1120 3
a1122 2
f_Bind_Macro_To_Key(char *buf)
{	char key[2];
d1144 3
a1146 2
f_Name_Keyboard_Macro(char *buf)
{	static char macro_name[MAX_LN];
d1166 2
a1167 2
f_Crunch_Image(char *buf) /* Average image to half its size. */
          
d1209 3
a1211 2
f_DrawLine(char *buf)
{	Rectangle lineseg;
d1280 2
a1281 2
f_DrawRectangle(char *buf) /* Draw current rectangle with "paint" color. */
          
d1288 2
a1289 2
f_Fill_Panel(char *buf) /* Fill current rectangle with "paint" color. */
          
d1297 2
a1298 2
f_Bind_Key_To_Key(char *buf) /* Bind new key to same function as old key. */
          
d1318 2
a1319 2
f_Bind_Name_To_Key(char *buf) /* Bind key to function or macro. */
          
d1352 2
a1353 2
f_Erase_Fb(char *buf) /* Erase (clear) framebuffer. */
          
d1367 2
a1368 2
f_Flip_Resolution(char *buf) /* Flip framebuffer resolution. */
          
d1393 2
a1394 2
f_Get_Panel(char *buf) /* Grab panel from framebuffer. */
          
d1408 2
a1409 2
f_Jump_Lft(char *buf) /* Move cursor left (big steps). */
          
d1421 2
a1422 2
f_Jump_Dwn(char *buf) /* Move cursor down. */
          
d1434 2
a1435 2
f_Jump_Up(char *buf) /* Move cursor up. */
          
d1447 2
a1448 2
f_Jump_Rgt(char *buf) /* Move cursor right. */
          
d1460 2
a1461 2
f_Put_Panel(char *buf) /* Put grabbed panel to framebuffer. */
          
d1477 2
a1478 2
f_Restore_RLE(char *buf) /* Restore Run-Length Encoded image. */
          
d1515 2
a1516 2
f_Save_RLE(char *buf) /* Save framebuffer image with Run-Length Encoding. */
          
d1562 2
a1563 2
f_Transliterate(char *buf) /* Transliterate pixels of color1 to target color2.*/
          
d1596 3
a1598 2
f_Stop_Macro(char *buf)
{
d1631 3
a1633 2
f_Enter_Macro_Definition(char *buf)
{	register int interactive = *cptr == NUL;
d1667 2
a1668 2
f_Set_Rectangle(char *buf) /* Set current rectangle. */
          
d1676 2
a1677 2
f_Center_Window(char *buf) /* Center window around cursor. */
          
d1686 2
a1687 2
f_Rd_Font(char *buf) /* Set current font. */
          
d1697 2
a1698 2
f_Set_Pixel(char *buf) /* Set "paint" pixel color. */
          
d1706 2
a1707 2
f_Move_Lft(char *buf) /* Move cursor left. */
          
d1719 2
a1720 2
f_Zoom_In(char *buf) /* Halve window size. */
          
d1733 2
a1734 2
f_Move_Dwn(char *buf) /* Move cursor down. */
          
d1746 2
a1747 2
f_Move_Up(char *buf) /* Move cursor up. */
          
d1759 2
a1760 2
f_Move_Rgt(char *buf) /* Move cursor right. */
          
d1772 2
a1773 2
f_Status_Monitor(char *buf) /* Toggle status monitoring. */
          
d1783 2
a1784 2
f_Zoom_Out(char *buf) /* Double window size. */
          
d1797 2
a1798 2
f_Key_Set_Pixel(char *buf) /* User types in paint color. */
          
d1807 3
a1809 2
f_Quit(char *buf)
{
d1818 2
a1819 2
f_Rd_Fb(char *buf) /* Read frame buffer image from file. */
          
d1866 2
a1867 2
f_String(char *buf) /* Place label on picture. */
          
d1872 1
a1872 1
	do_line( cursor_pos.p_x, cursor_pos.p_y, label, (RGBpixel *)NULL );
d1878 2
a1879 2
f_Put_Pixel(char *buf) /* Put pixel. */
          
d1896 1
a1896 1
			  (RGBpixel *) paint
d1903 2
a1904 2
f_Set_X_Pos(char *buf) /* Move cursor's X location (image space). */
          
d1931 2
a1932 2
f_Set_Y_Pos(char *buf) /* Move cursor's Y location (image space). */
          
d1959 3
a1961 2
pars_Argv(int argc, register char **argv)
{	register int c;
d1989 2
a1990 2
fb_Setup(void)
{
d2017 2
a2018 2
fb_Wind(void)
{
d2029 4
a2032 2
fb_Paint(register int x0, register int y0, register int x1, register int y1, RGBpixel (*color))
{	Rectangle clipped_rect;
d2048 3
a2050 2
general_Handler(int sig)
{
d2130 2
a2131 2
init_Tty(void)
{
d2151 2
a2152 2
restore_Tty(void)
{
d2163 3
a2165 2
fb_Get_Pixel(unsigned char *pixel)
{
d2227 4
a2230 2
put_Fb_Panel(register Rectangle *rectp, register RGBpixel (*panel))
{	register int top, rectwid, y;
d2253 4
a2256 2
get_Point(char *msg, register Point *pointp)
{	register int tag_point = -1;
d2313 4
a2316 2
get_Rectangle(char *name, register Rectangle *rectp)
{	char buf[MAX_LN];
d2326 3
a2328 2
fix_Rectangle(register Rectangle *rectp)
{	register int i;
d2345 3
a2347 2
clip_Rectangle(register Rectangle *rectp)
{
d2366 3
a2368 2
char_To_String(int i)
{	static char buf[4];
d2389 3
a2391 2
get_Mouse_Pos(Point *pointp)
{
d2405 3
a2407 2
do_Bitpad(register Point *pointp)
{	int press;
d2425 2
a2426 2
get_Char(void)
{	int c;
@


11.5
log
@Lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbed/fbed.c,v 11.4 2000/08/24 22:55:35 mike Exp $ (BRL)";
d55 10
a64 4
bool AproxEqColor(a,b,t)
unsigned char a, b;
int t;
	{	int	c = a-b;
d94 9
a102 9
STATIC bool drawRectangle();
STATIC bool getColor();
STATIC bool paintNonBorder();
STATIC bool paintSolidRegion();
STATIC bool popPoint();
STATIC int do_Bitpad();
STATIC int fb_Setup();
STATIC int pars_Argv();
STATIC int push_Macro();
d104 1
a104 1
STATIC void general_Handler();
d108 74
a181 74
STATIC void init_Try();
STATIC void fb_Paint();
STATIC void fb_Wind();
STATIC void get_Point();
STATIC void clip_Rectangle();
STATIC void get_Rectangle();
STATIC void fillRectangle();
STATIC void fix_Rectangle();
STATIC void pushPoint();
STATIC void put_Fb_Panel();

STATIC int	/* ^X  */ f_Exec_Function(),
		/* ^I  */ f_Nop(),
		/* ^H  */ f_Win_Lft(),
		/* ^J  */ f_Win_Dwn(),
		/* ^K  */ f_Win_Up(),
		/* ^L  */ f_Win_Rgt(),
		/* ^M  */ f_Reset_View(),
		/* ^R  */ f_Redraw(),
		/* ^Z  */ f_Stop(),
		/* ESC */ f_Iterations(),
		/* SP  */ f_Press(),
		/* #   */ f_Comment(),
		/* ,   */ f_Dec_Brush_Size(),
		/* .   */ f_Inc_Brush_Size(),
		/* <   */ f_Dec_Step_Size(),
		/* >   */ f_Inc_Step_Size(),
		/* ?   */ f_Menu(),
		/* A   */ f_Start_Macro(),
		/* B   */ f_Bind_Macro_To_Key(),
		/* C   */ f_Crunch_Image(),
		/* E   */ f_Erase_Fb(),
		/* F   */ f_Flip_Resolution(),
		/* G   */ f_Get_Panel(),
		/* H   */ f_Jump_Lft(),
		/* J   */ f_Jump_Dwn(),
		/* K   */ f_Jump_Up(),
		/* L   */ f_Jump_Rgt(),
		/* N   */ f_Name_Keyboard_Macro(),
		/* P   */ f_Put_Panel(),
		/* R   */ f_Restore_RLE(),
		/* S   */ f_Save_RLE(),
		/* T   */ f_Transliterate(),
		/* U   */ f_Write_Macros_To_File(),
		/* V   */ f_FillRegion(),
		/* W   */ f_Fill_Panel(),
		/* X   */ f_Bind_Key_To_Key(),
		/* Y   */ f_Bind_Name_To_Key(),
		/* Z   */ f_Stop_Macro(),
		/* a   */ f_Enter_Macro_Definition(),
		/* b   */ f_Set_Rectangle(),
		/* c   */ f_Center_Window(),
		/* d   */ f_DrawLine(),
		/* f   */ f_Rd_Font(),
		/* g   */ f_Set_Pixel(),
		/* h   */ f_Move_Lft(),
		/* i   */ f_Zoom_In(),
		/* j   */ f_Move_Dwn(),
		/* k   */ f_Move_Up(),
		/* l   */ f_Move_Rgt(),
		/* m   */ f_Status_Monitor(),
		/* n   */ f_Tolerance(),
		/* o   */ f_Zoom_Out(),
		/* p   */ f_Key_Set_Pixel(),
		/* q   */ f_Quit(),
		/* r   */ f_Rd_Fb(),
		/* s   */ f_String(),
		/* t   */ f_ChngRegionColor(),
		/* u   */ f_Rd_Macros_From_File(),
		/* v   */ f_DrawRectangle(),
		/* w   */ f_Put_Pixel(),
		/* x   */ f_Set_X_Pos(),
		/* y   */ f_Set_Y_Pos(),
		/* Unbound */ f_Exec_Macro();
d323 2
a324 3
main( argc, argv )
char *argv[];
	{
d423 2
a424 4
drawRectangle( rectp, pixelp )
Rectangle *rectp;
unsigned char *pixelp;
	{	register int x, y;
d443 2
a444 4
fillRectangle( rectp, pixelp )
register Rectangle *rectp;
register RGBpixel *pixelp;
	{	register int btm = rectp->r_origin.p_y;
d473 2
a474 4
paintNonBorder( borderpix, pt )
RGBpixel borderpix;
Point *pt;
	{	RGBpixel currentpix;
d493 2
a494 4
paintSolidRegion( regionpix, pt )
RGBpixel regionpix;
Point *pt;
	{	RGBpixel currentpix;
a508 7
typedef struct pointstack PtStack;
struct pointstack
	{
	Point pt;
	PtStack *next;
	};

d510 2
a511 4
pushPoint( pt, spp )
Point *pt;
PtStack **spp;
	{	register PtStack *new;
d524 2
a525 4
popPoint( pt, spp )
Point *pt;
register PtStack **spp;
	{	register PtStack *next;
d539 2
a540 2
init_Try()
	{	register int key;
d561 2
a562 3
push_Macro( buf )
char *buf;
	{	register int curlen = strlen( cptr );
d578 2
a579 4
do_Key_Cmd( key, n )
register int key;
register int n;
	{
d608 2
a609 5
getColor( pixelp, prompt, buffer )
RGBpixel pixelp;
char *prompt;
char *buffer;
	{	static char promptbuf[PROMPT_LEN];
d636 2
a637 3
f_Tolerance( buf )
char *buf;
	{	static char tol_str[4];
d648 2
a649 3
f_ChngRegionColor( buf )
char *buf;
	{	static int xoff1[] = { 0, 1,  0, -1 };
d678 2
a679 3
f_FillRegion( buf )
char *buf;
	{	static int xoff1[] = { 0, 1,  0, -1 };
d707 2
a708 3
f_Nop( buf )
char *buf;
	{
d716 2
a717 2
f_Win_Lft( buf ) /* Move window left. */
char *buf;
d727 2
a728 2
f_Win_Dwn( buf ) /* Move window down. */
char *buf;
d738 2
a739 2
f_Win_Up( buf ) /* Move window up. */
char *buf;
d749 2
a750 2
f_Win_Rgt( buf ) /* Move window right. */
char *buf;
d760 2
a761 2
f_Reset_View( buf ) /* Restore normal view. */
char *buf;
d773 2
a774 2
f_Redraw( buf ) /* Redraw screen. */
char *buf;
d783 2
a784 2
f_Stop( buf ) /* Stop program. */
char *buf;
d809 2
a810 3
f_Exec_Function( buf )
char *buf;
	{	Func_Tab	*ftbl;
d827 2
a828 2
f_Iterations( buf ) /* Specify number of iterations of next command. */
char *buf;
d858 2
a859 3
f_Press( buf )
char *buf;
	{
d866 2
a867 2
f_Comment( buf ) /* Print comment. */
char *buf;
d877 2
a878 2
f_Dec_Brush_Size( buf ) /* Decrement brush size. */
char *buf;
d887 2
a888 2
f_Inc_Brush_Size( buf ) /* Increment brush size. */
char *buf;
d897 2
a898 2
f_Menu( buf ) /* Print menu. */
char *buf;
d947 2
a948 2
f_Dec_Step_Size( buf ) /* Decrement gain on move operations. */
char *buf;
d957 2
a958 2
f_Inc_Step_Size( buf ) /* Increment gain on move operations. */
char *buf;
d966 2
a967 3
f_Exec_Macro( buf )
char *buf;
	{
d974 2
a975 3
f_Rd_Macros_From_File( buf )
char *buf;
	{	register FILE	*macro_fp;
d1010 2
a1011 3
f_Write_Macros_To_File( buf )
char *buf;
	{	static char macro_file[MAX_LN];
d1074 2
a1075 3
f_Start_Macro( buf )
char *buf;
	{
d1090 2
a1091 3
f_Bind_Macro_To_Key( buf )
char *buf;
	{	char key[2];
d1113 2
a1114 3
f_Name_Keyboard_Macro( buf )
char *buf;
	{	static char macro_name[MAX_LN];
d1134 2
a1135 2
f_Crunch_Image( buf ) /* Average image to half its size. */
char *buf;
d1177 2
a1178 3
f_DrawLine( buf )
char *buf;
	{	Rectangle lineseg;
d1247 2
a1248 2
f_DrawRectangle( buf ) /* Draw current rectangle with "paint" color. */
char *buf;
d1255 2
a1256 2
f_Fill_Panel( buf ) /* Fill current rectangle with "paint" color. */
char *buf;
d1264 2
a1265 2
f_Bind_Key_To_Key( buf ) /* Bind new key to same function as old key. */
char *buf;
d1285 2
a1286 2
f_Bind_Name_To_Key( buf ) /* Bind key to function or macro. */
char *buf;
d1319 2
a1320 2
f_Erase_Fb( buf ) /* Erase (clear) framebuffer. */
char *buf;
d1334 2
a1335 2
f_Flip_Resolution( buf ) /* Flip framebuffer resolution. */
char *buf;
d1360 2
a1361 2
f_Get_Panel( buf ) /* Grab panel from framebuffer. */
char *buf;
d1375 2
a1376 2
f_Jump_Lft( buf ) /* Move cursor left (big steps). */
char *buf;
d1388 2
a1389 2
f_Jump_Dwn( buf ) /* Move cursor down. */
char *buf;
d1401 2
a1402 2
f_Jump_Up( buf ) /* Move cursor up. */
char *buf;
d1414 2
a1415 2
f_Jump_Rgt( buf ) /* Move cursor right. */
char *buf;
d1427 2
a1428 2
f_Put_Panel( buf ) /* Put grabbed panel to framebuffer. */
char *buf;
d1444 2
a1445 2
f_Restore_RLE( buf ) /* Restore Run-Length Encoded image. */
char *buf;
d1482 2
a1483 2
f_Save_RLE( buf ) /* Save framebuffer image with Run-Length Encoding. */
char *buf;
d1529 2
a1530 2
f_Transliterate( buf ) /* Transliterate pixels of color1 to target color2.*/
char *buf;
d1563 2
a1564 3
f_Stop_Macro( buf )
char *buf;
	{
d1597 2
a1598 3
f_Enter_Macro_Definition( buf )
char *buf;
	{	register int interactive = *cptr == NUL;
d1632 2
a1633 2
f_Set_Rectangle( buf ) /* Set current rectangle. */
char *buf;
d1641 2
a1642 2
f_Center_Window( buf ) /* Center window around cursor. */
char *buf;
d1651 2
a1652 2
f_Rd_Font( buf ) /* Set current font. */
char *buf;
d1662 2
a1663 2
f_Set_Pixel( buf ) /* Set "paint" pixel color. */
char *buf;
d1671 2
a1672 2
f_Move_Lft( buf ) /* Move cursor left. */
char *buf;
d1684 2
a1685 2
f_Zoom_In( buf ) /* Halve window size. */
char *buf;
d1698 2
a1699 2
f_Move_Dwn( buf ) /* Move cursor down. */
char *buf;
d1711 2
a1712 2
f_Move_Up( buf ) /* Move cursor up. */
char *buf;
d1724 2
a1725 2
f_Move_Rgt( buf ) /* Move cursor right. */
char *buf;
d1737 2
a1738 2
f_Status_Monitor( buf ) /* Toggle status monitoring. */
char *buf;
d1748 2
a1749 2
f_Zoom_Out( buf ) /* Double window size. */
char *buf;
d1762 2
a1763 2
f_Key_Set_Pixel( buf ) /* User types in paint color. */
char *buf;
d1772 2
a1773 3
f_Quit( buf )
char *buf;
	{
d1782 2
a1783 2
f_Rd_Fb( buf ) /* Read frame buffer image from file. */
char *buf;
d1830 2
a1831 2
f_String( buf ) /* Place label on picture. */
char *buf;
d1836 1
a1836 1
	do_line( cursor_pos.p_x, cursor_pos.p_y, label, (unsigned char *)NULL );
d1842 2
a1843 2
f_Put_Pixel( buf ) /* Put pixel. */
char *buf;
d1860 1
a1860 1
			  (unsigned char *) paint
d1867 2
a1868 2
f_Set_X_Pos( buf ) /* Move cursor's X location (image space). */
char *buf;
d1895 2
a1896 2
f_Set_Y_Pos( buf ) /* Move cursor's Y location (image space). */
char *buf;
d1923 2
a1924 3
pars_Argv( argc, argv )
register char **argv;
	{	register int c;
d1952 2
a1953 2
fb_Setup()
	{
d1980 2
a1981 2
fb_Wind()
	{
d1992 2
a1993 4
fb_Paint( x0, y0, x1, y1, color )
register int x0, y0, x1, y1;
RGBpixel *color;
	{	Rectangle clipped_rect;
d2009 2
a2010 3
general_Handler( sig )
int sig;
	{
d2090 2
a2091 2
init_Tty()
	{
d2111 2
a2112 2
restore_Tty()
	{
d2123 2
a2124 3
fb_Get_Pixel( pixel )
RGBpixel pixel;
	{
d2186 2
a2187 4
put_Fb_Panel( rectp, panel )
register Rectangle *rectp;
register RGBpixel *panel;
	{	register int top, rectwid, y;
d2210 2
a2211 4
get_Point( msg, pointp )
char *msg;
register Point *pointp;
	{	register int tag_point = -1;
d2268 2
a2269 4
get_Rectangle( name, rectp )
char *name;
register Rectangle *rectp;
	{	char buf[MAX_LN];
d2279 2
a2280 3
fix_Rectangle( rectp )
register Rectangle *rectp;
	{	register int i;
d2297 2
a2298 3
clip_Rectangle( rectp )
register Rectangle *rectp;
	{
d2317 2
a2318 3
char_To_String( i )
int i;
	{	static char buf[4];
d2339 2
a2340 3
get_Mouse_Pos( pointp )
Point *pointp;
	{
d2354 2
a2355 3
do_Bitpad( pointp )
register Point *pointp;
	{	int press;
d2373 2
a2374 2
get_Char()
	{	int c;
@


11.4
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbed/fbed.c,v 11.3 2000/01/31 16:05:01 jra Exp $ (BRL)";
d14 6
d179 128
a306 128
/* NUL */ f_Nop,			NULL,	"nop",
/* ^A  */ f_Nop,			NULL,	"nop",
/* ^B  */ f_Nop,			NULL,	"nop",
/* ^C  */ f_Nop,			NULL,	"nop",
/* ^D  */ f_Nop,			NULL,	"nop",
/* ^E  */ f_Nop,			NULL,	"nop",
/* ^F  */ f_Nop,			NULL,	"nop",
/* ^G  */ f_Nop,			NULL,	"nop",
/* ^H  */ f_Win_Lft,			NULL,	"move-window-left",
/* ^I  */ f_Nop,			NULL,	"nop",
/* ^J  */ f_Win_Dwn,			NULL,	"move-window-down",
/* ^K  */ f_Win_Up,			NULL,	"move-window-up",
/* ^L  */ f_Win_Rgt,			NULL,	"move-window-right",
/* ^M  */ f_Reset_View,			NULL,	"reset-view",
/* ^N  */ f_Nop,			NULL,	"nop",
/* ^O  */ f_Nop,			NULL,	"nop",
/* ^P  */ f_Nop,			NULL,	"nop",
/* ^Q  */ f_Nop,			NULL,	"nop",
/* ^R  */ f_Redraw,			NULL,	"redraw-tty-screen",
/* ^S  */ f_Nop,			NULL,	"nop",
/* ^T  */ f_Nop,			NULL,	"nop",
/* ^U  */ f_Nop,			NULL,	"nop",
/* ^V  */ f_Nop,			NULL,	"nop",
/* ^W  */ f_Nop,			NULL,	"nop",
/* ^X  */ f_Exec_Function,		NULL,	"execute-function-or-macro",
/* ^Y  */ f_Nop,			NULL,	"nop",
/* ^Z  */ f_Stop,			NULL,	"stop-program",
/* ESC */ f_Iterations,			NULL,	"argument-count",
/* FS  */ f_Nop,			NULL,	"nop",
/* GS  */ f_Nop,			NULL,	"nop",
/* RS  */ f_Nop,			NULL,	"nop",
/* US  */ f_Nop,			NULL,	"nop",
/* SP  */ f_Press,			NULL,	"pick-point",
/* !   */ f_Nop,			NULL,	"nop",
/* "   */ f_Nop,			NULL,	"nop",
/* #   */ f_Comment,			NULL,	"print-comment",
/* $   */ f_Nop,			NULL,	"nop",
/* %   */ f_Nop,			NULL,	"nop",
/* &   */ f_Nop,			NULL,	"nop",
/* `   */ f_Nop,			NULL,	"nop",
/* (   */ f_Nop,			NULL,	"nop",
/* )   */ f_Nop,			NULL,	"nop",
/* *   */ f_Nop,			NULL,	"nop",
/* +   */ f_Nop,			NULL,	"nop",
/* ,   */ f_Dec_Brush_Size,		NULL,	"decrement-brush-size",
/* -   */ f_Nop,			NULL,	"nop",
/* .   */ f_Inc_Brush_Size,		NULL,	"increment-brush-size",
/* /   */ f_Nop,			NULL,	"nop",
/* 0   */ f_Nop,			NULL,	"nop",
/* 1   */ f_Nop,			NULL,	"nop",
/* 2   */ f_Nop,			NULL,	"nop",
/* 3   */ f_Nop,			NULL,	"nop",
/* 4   */ f_Nop,			NULL,	"nop",
/* 5   */ f_Nop,			NULL,	"nop",
/* 6   */ f_Nop,			NULL,	"nop",
/* 7   */ f_Nop,			NULL,	"nop",
/* 8   */ f_Nop,			NULL,	"nop",
/* 9   */ f_Nop,			NULL,	"nop",
/* :   */ f_Nop,			NULL,	"nop",
/* ;   */ f_Nop,			NULL,	"nop",
/* <   */ f_Dec_Step_Size,		NULL,	"decrement-step-size",
/* =   */ f_Nop,			NULL,	"nop",
/* >   */ f_Inc_Step_Size,		NULL,	"increment-step-size",
/* ?   */ f_Menu,			NULL,	"print-bindings",
/* @@   */ f_Nop,			NULL,	"nop",
/* A   */ f_Start_Macro,		NULL,	"start-macro-definition",
/* B   */ f_Bind_Macro_To_Key,		NULL,	"bind-macro-to-key",
/* C   */ f_Crunch_Image,		NULL,	"shrink-image-by-half",
/* D   */ f_Nop,			NULL,	"nop",
/* E   */ f_Erase_Fb,			NULL,	"clear-framebuffer-memory",
/* F   */ f_Flip_Resolution,		NULL,	"flip-framebuffer-resolution",
/* G   */ f_Get_Panel,			NULL,	"get-current-rectangle",
/* H   */ f_Jump_Lft,			NULL,	"jump-cursor-left",
/* I   */ f_Nop,			NULL,	"nop",
/* J   */ f_Jump_Dwn,			NULL,	"jump-cursor-down",
/* K   */ f_Jump_Up,			NULL,	"jump-cursor-up",
/* L   */ f_Jump_Rgt,			NULL,	"jump-cursor-right",
/* M   */ f_Nop,			NULL,	"nop",
/* N   */ f_Name_Keyboard_Macro,	NULL,	"name-keyboard-macro",
/* O   */ f_Nop,			NULL,	"nop",
/* P   */ f_Put_Panel,			NULL,	"put-saved-rectangle",
/* Q   */ f_Nop,			NULL,	"nop",
/* R   */ f_Restore_RLE,		NULL,	"read-rle-fle",
/* S   */ f_Save_RLE,			NULL,	"write-rle-file",
/* T   */ f_Transliterate,		NULL,	"replace-pixel-current-rectangle",
/* U   */ f_Write_Macros_To_File,	NULL,	"write-macros-to-file",
/* V   */ f_FillRegion,			NULL,	"fill-bounded-region",
/* W   */ f_Fill_Panel,			NULL,	"fill-current-rectangle",
/* X   */ f_Bind_Key_To_Key,		NULL,	"bind-key-to-key",
/* Y   */ f_Bind_Name_To_Key,		NULL,	"bind-key-to-name",
/* Z   */ f_Stop_Macro,			NULL,	"stop-macro-definition",
/* [   */ f_Nop,			NULL,	"nop",
/* \   */ f_Nop,			NULL,	"nop",
/* ]   */ f_Nop,			NULL,	"nop",
/* ^   */ f_Nop,			NULL,	"nop",
/* _   */ f_Nop,			NULL,	"nop",
/* `   */ f_Nop,			NULL,	"nop",
/* a   */ f_Enter_Macro_Definition,	NULL,	"enter-macro-definition",
/* b   */ f_Set_Rectangle,		NULL,	"set-current-rectangle",
/* c   */ f_Center_Window,		NULL,	"window-center",
/* d   */ f_DrawLine,			NULL,	"draw-line",
/* e   */ f_Nop,			NULL,	"nop",
/* f   */ f_Rd_Font,			NULL,	"read-font",
/* g   */ f_Set_Pixel,			NULL,	"set-paint-to-current-pixel",
/* h   */ f_Move_Lft,			NULL,	"move-cursor-left",
/* i   */ f_Zoom_In,			NULL,	"zoom-in",
/* j   */ f_Move_Dwn,			NULL,	"move-cursor-down",
/* k   */ f_Move_Up,			NULL,	"move-cursor-up",
/* l   */ f_Move_Rgt,			NULL,	"move-cursor-right",
/* m   */ f_Status_Monitor,		NULL,	"set-monitor",
/* n   */ f_Tolerance,			NULL,	"set-tolerance-color-match",
/* o   */ f_Zoom_Out,			NULL,	"zoom-out",
/* p   */ f_Key_Set_Pixel,		NULL,	"set-paint-from-key",
/* q   */ f_Quit,			NULL,	"quit",
/* r   */ f_Rd_Fb,			NULL,	"read-framebuffer",
/* s   */ f_String,			NULL,	"put-string",
/* t   */ f_ChngRegionColor,		NULL,	"change-region-color",
/* u   */ f_Rd_Macros_From_File,	NULL,	"read-macros-from-file",
/* v   */ f_DrawRectangle,		NULL,	"draw-rectangle",
/* w   */ f_Put_Pixel,			NULL,	"put-pixel",
/* x   */ f_Set_X_Pos,			NULL,	"set-cursor-x-pos",
/* y   */ f_Set_Y_Pos,			NULL,	"set-cursor-y-pos",
/* z   */ f_Nop,			NULL,	"nop",
/* {   */ f_Nop,			NULL,	"nop",
/* |   */ f_Nop,			NULL,	"nop",
/* }   */ f_Nop,			NULL,	"nop",
/* ~   */ f_Nop,			NULL,	"nop",
/* DEL */ f_Nop,			NULL,	"nop"
d316 1
d856 1
a856 1
		register int c, i;
d1138 1
a1138 1
	bindings[key[0]] = macro_entry;
d1312 1
a1312 1
	bindings[new_key[0]] = bindings[old_key[0]];
d1340 1
a1340 1
		bindings[key[0]] = ftbl;
d2388 1
a2388 1

@


11.3
log
@Eliminated some unused variables
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/fbed/fbed.c,v 11.2 1996/07/17 12:41:27 jra Exp $ (BRL)";
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 11.1 1995/01/04 10:13:51 mike Rel4_4 jra $ (BRL)";
d2025 1
a2025 2
	{	register int x;
		Rectangle clipped_rect;
a2249 1
		register int status_change;
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 10.8 94/12/30 11:16:45 jra Exp $ (BRL)";
d1284 1
a1284 1
	fillRectangle( &current, (unsigned char *) paint );
@


10.8
log
@Cray does know about errno, just needed to  include errno.h.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 10.7 94/12/30 11:07:54 jra Exp Locker: jra $ (BRL)";
@


10.7
log
@Cray2 doesn't know about errno.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 10.6 1994/11/24 02:22:26 mike Exp jra $ (BRL)";
d18 1
a812 1
#ifndef CRAY2
a815 3
#else
		exit( 1 );
#endif
@


10.6
log
@GL
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 10.5 94/08/23 19:46:31 gdurf Exp Locker: mike $ (BRL)";
d811 3
a813 1
		{	extern int errno;
d816 3
@


10.5
log
@Made includes explicit
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 10.4 1993/10/26 02:55:44 mike Exp gdurf $ (BRL)";
d360 1
a360 1
		{	register int button_press;
d393 1
a393 1
		    &&	(button_press = get_Mouse_Pos( &cursor_pos ))
d2134 1
a2134 1
#if defined(sgi) || defined(__sgi)
d2388 1
a2388 1
#if defined(sgi) || defined(__sgi)
@


10.4
log
@New fb.h
POSIX
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 10.3 92/11/17 09:03:17 moss Exp Locker: mike $ (BRL)";
d12 2
d18 1
d21 6
d803 1
a803 1
#ifdef BSD
d2094 1
a2094 1
#if defined(SIGCHLD)
d2099 1
a2099 1
#ifdef BSD
a2105 7
#else
#	ifdef VLDSYSV
	case 18 :
	case SIGUSR2 :
		(void) f_Stop( (char *) NULL );
		break;
#	endif
@


10.3
log
@#ifdef'd out sgi_ code when not on an SGI.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/fbed/RCS/fbed.c,v 10.2 91/12/13 10:55:40 moss Exp Locker: moss $ (BRL)";
d403 1
a403 1
RGBpixel *pixelp;
d438 1
a438 1
							pixelp, 1 );
d462 1
a462 1
	if( fb_read( fbp, pt->p_x, pt->p_y, (RGBpixel *) currentpix, 1 ) == -1 )
d470 1
a470 1
	if( fb_write( fbp, pt->p_x, pt->p_y, (RGBpixel *) paint, 1 ) == -1 )
d484 1
a484 1
	if( fb_read( fbp, pt->p_x, pt->p_y, (RGBpixel *) currentpix, 1 ) == -1 )
d489 1
a489 1
	if( fb_write( fbp, pt->p_x, pt->p_y, (RGBpixel *) paint, 1 ) == -1 )
d662 1
a662 1
			(RGBpixel *) currentpix, 1 ) == -1 )
d1158 1
a1158 1
		== RGBPIXEL_NULL
d1164 1
a1164 1
		== RGBPIXEL_NULL
d1171 2
a1172 2
		fb_read( fbp, 0, y, p1, fb_getwidth(fbp));
		fb_read( fbp, 0, y+1, p2, fb_getwidth(fbp) );
d1182 1
a1182 1
		fb_write( fbp, 0, y/2, p1, fb_getwidth(fbp)/2 );
d1237 1
a1237 1
					(RGBpixel *) paint,
d1265 1
a1265 1
	return drawRectangle( &current, (RGBpixel *) paint ) ? 1 : 0;
d1273 1
a1273 1
	fillRectangle( &current, (RGBpixel *) paint );
d1565 1
a1565 1
			(void) fb_rpixel( fbp, (RGBpixel *) cur );
d1821 6
d1828 1
a1828 1
		{	RGBpixel scanbuf[1024];
d1840 1
d1854 1
a1854 1
	do_line( cursor_pos.p_x, cursor_pos.p_y, label, (RGBpixel *)NULL );
d1878 1
a1878 1
			  (RGBpixel *) paint
d2056 1
d2062 2
d2069 1
d2081 1
a2081 1
#ifdef SYSV
d2084 2
a2085 1
#else
d2161 1
a2161 1
		(void) fb_rpixel( fbp, (RGBpixel *) pixel );
d2193 1
a2193 1
	if( (panel = (RGBpixel *) malloc( u )) == RGBPIXEL_NULL )
d2203 1
a2203 1
			if( fb_read( fbp, lft, y, pixelp, rectwid ) == -1 )
d2230 1
a2230 1
		if( fb_write( fbp, lft, y, panel, rgt-lft+1 ) == -1 )
@


10.2
log
@Fixed fb_Setup() to set global flag (isSGI) when running on an SGI
with graphics.  This fixes the problem of getting a "CPS initialization"
error when running over a remote connection from an SGI.  #ifdef sgi
was used previously throughout the code rather than checking the name
of the device.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/fbed/RCS/fbed.c,v 10.1 91/10/12 06:49:36 mike Rel4_0 $ (BRL)";
d2120 1
d2123 1
d2374 1
d2378 1
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 9.9 91/08/30 21:17:10 moss Exp $ (BRL)";
d430 13
a442 2
#ifdef sgi /* More efficient on IRIS. */
	if( top - btm < 10 || rgt - lft < 10 )
d445 4
a448 3
			{	register int x;
			for( x = lft; x <= rgt; x++ )
				(void) fb_write( fbp, x, btm, pixelp, 1 );
d450 1
a450 1
		return;
a451 9
#endif
	for( ; btm <= top; btm++ )
		{	register int x = lft;
		(void) fb_seek( fbp, x, btm );
		for( ; x <= rgt; x++ )
			FB_WPIXEL( fbp, *pixelp );
		}
	(void) fb_flush( fbp );
	return;
d1859 8
a1866 6
#ifdef sgi
		(void) fb_write( fbp, cursor_pos.p_x, cursor_pos.p_y, paint, 1 );
#else
		(void) fb_seek( fbp, cursor_pos.p_x, cursor_pos.p_y );
		FB_WPIXEL( fbp, paint );
#endif
d1971 4
d1982 4
a1985 2
	windo_center.p_x = cursor_pos.p_x = image_center.p_x = fb_getwidth(fbp) / 2;
	windo_center.p_y = cursor_pos.p_y = image_center.p_y = fb_getheight(fbp) / 2;
d2120 2
a2121 3
#ifdef sgi
	sgi_Init();
#endif
d2142 7
a2148 6
#ifdef sgi
	(void) fb_read( fbp, cursor_pos.p_x, cursor_pos.p_y, pixel, 1 );
#else
	(void) fb_seek( fbp, cursor_pos.p_x, cursor_pos.p_y );
	(void) fb_rpixel( fbp, (RGBpixel *) pixel );
#endif
d2368 1
a2368 1
	{	extern FBIO *fbp;
d2371 5
a2375 5
#ifdef sgi
	return sgi_Mouse_Pos( &cursor_pos );
#else
	return -1;
#endif
d2402 4
a2405 4
#if defined( sgi ) && 0
	return (c = sgi_Getchar()) == EOF ? EOF : toascii( c );
#else
	return (c = getchar()) == EOF ? EOF : toascii( c );
d2407 1
@


9.9
log
@Shut up compilers
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/fbed/RCS/fbed.c,v 9.8 91/07/25 15:22:54 moss Exp $ (BRL)";
@


9.8
log
@Was immediately calling f_Quit() do to improper compiler workaround in
version 9.6.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 9.7 91/07/09 02:51:43 mike Exp $ (BRL)";
d396 2
d644 1
d660 1
a660 1
		return false; /* read error */
@


9.7
log
@If NSIG not defined, pick 64.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 9.6 91/07/01 22:52:55 mike Exp $ (BRL)";
a393 1
		(void) f_Quit( (char *) NULL );
d395 1
@


9.6
log
@Silenced SGI optimizer complaining about infinite loop.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 9.5 91/06/12 22:47:33 mike Exp $ (BRL)";
d19 4
@


9.5
log
@lint
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 9.4 91/05/02 15:41:56 moss Exp $ (BRL)";
d376 1
a376 1
					(void) f_Quit( (char *) NULL );
d390 1
@


9.4
log
@Changed variable names major/minor to majdelta/mindelta to prevent name
clashes with SunOS macros from sys/macros.h.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/fbed/RCS/fbed.c,v 9.3 90/11/26 11:19:41 moss Exp $ (BRL)";
d16 2
@


9.3
log
@Added some commands: draw-rectangle, fill-bounded-region, print-comment,
	change-region-color, set-tolerance-color-match.
Also, default rectangle is entire window.
Checked in for release 4.0.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 9.2 89/05/22 12:05:02 moss Locked $ (BRL)";
d1181 2
a1182 2
		register int major;
		register int minor;
d1205 4
a1208 4
	major = lineseg.r_corner.p_x - lineseg.r_origin.p_x;
	xsign = major ? 1 : 0;
	minor = lineseg.r_corner.p_y - lineseg.r_origin.p_y;
	ysign = minor ? (minor > 0 ? 1 : -1) : 0;
d1210 1
a1210 1
		minor = -minor;
d1212 4
a1215 4
	if( ! (xmajor = minor <= major) )
		{	register int temp = minor;
		minor = major;
		major = temp;
d1218 2
a1219 2
	error = major / 2 - minor; /* Initial DDA error. */
	de = major - minor;
d1227 1
a1227 1
		if( major-- == 0 ) /* Done! */
d1241 1
a1241 1
			error -= minor;
@


9.2
log
@Fixed 2nd arg of fb_rpixel to be RGBpixel ptr. rather than just RGBpixel
	in two places.
@
text
@d6 1
a6 1
			(301)278-6647 or AV-298-6647
d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 9.1 89/05/19 06:12:07 moss Locked $ (BRL)";
d20 2
a21 2
	int	xbits, ybits;
	int	xorig, yorig;
d31 17
d51 1
a51 1
		return	0;
d53 2
a54 6
static Panel	panel;	      /* Current panel.				*/
static Point	bitpad;
static Rectangle current;     /* Current saved rectangle.		*/
static int	step;	      /* Current step size.			*/
static int	size_viewport;
static int	last_key;
d56 19
a74 4
_LOCAL_ int	do_Bitpad();
_LOCAL_ int	fb_Setup();
_LOCAL_ int	pars_Argv();
_LOCAL_ int	push_Macro();
d76 1
a76 1
_LOCAL_ void	general_Handler();
d78 1
a78 1
_LOCAL_ int	general_Handler();
d80 10
a89 10
_LOCAL_ void	init_Try();
_LOCAL_ void	fb_Paint();
_LOCAL_ void	fb_Wind();
_LOCAL_ void	get_Point();
_LOCAL_ void	clip_Rectangle();
_LOCAL_ void	get_Rectangle();
_LOCAL_ void	fill_Rectangle();
_LOCAL_ void	fix_Rectangle();
_LOCAL_ void	put_Fb_Panel();
_LOCAL_ RGBpixel	*pixel_Avg();
d91 1
a91 1
_LOCAL_ int	/* ^X  */ f_Exec_Function(),
d102 1
a110 1
		/* D   */ f_Dump_FBC(),
d124 1
d132 1
a132 1
		/* d   */ f_Draw_Line(),
d141 1
d147 1
d149 1
d170 1
a170 1
/* ^M  */ f_Reset_View,		NULL,	"reset-view",
d184 1
a184 1
/* ESC */ f_Iterations,		NULL,	"argument-count",
d192 1
a192 1
/* #   */ f_Nop,			NULL,	"nop",
d225 1
a225 1
/* D   */ f_Dump_FBC,			NULL,	"dump-fbc-registers",
d243 2
a244 2
/* V   */ f_Nop,			NULL,	"nop",
/* W   */ f_Fill_Panel,		NULL,	"fill-current-rectangle",
d247 1
a247 1
/* Z   */ f_Stop_Macro,		NULL,	"stop-macro-definition",
d257 1
a257 1
/* d   */ f_Draw_Line,			NULL,	"draw-line",
d267 1
a267 1
/* n   */ f_Nop,			NULL,	"nop",
d273 1
a273 1
/* t   */ f_Nop,			NULL,	"nop",
d275 1
a275 1
/* v   */ f_Nop,			NULL,	"nop",
d288 1
a288 1
static Func_Tab	*macro_entry = FT_NULL; /* Last keyboard macro defined.	*/
d290 2
a291 2
FBIO	*fbp;				/* Current framebuffer */
static int	cur_width = 512;
d293 1
a293 1
/*	m a i n ( )							*/
d295 1
a295 1
char	*argv[];
d300 1
a300 1
		return	1;
d307 1
a307 1
		return	1;
d311 5
a315 1
		return	1;
d321 2
a322 2
	{	static char	default_macro_file[MAX_LN];
		char		*home;
d334 1
a334 1
#define CBREAK_MODE		/* Signals are generated from keyboard.	*/
d336 1
a336 1
	{	register int	sig;
d345 2
a346 2
		{	register int	button_press;
			register int	status_change = false;
d355 1
a355 1
			{	int	c;
d373 1
a373 1
				else	/* EOF detected.		*/
d391 31
a421 9
_LOCAL_ void
fill_Rectangle( rectp, pixelp )
register Rectangle	*rectp;
register RGBpixel	*pixelp;
	{	register int	btm = rectp->r_origin.p_y;
		register int	top = rectp->r_corner.p_y;
		register int	rgt = rectp->r_corner.p_x;
		int		lft = rectp->r_origin.p_x;
#ifdef sgi /* More efficient on IRIS.					*/
d425 1
a425 1
			{	register int	x;
d433 1
a433 1
		{	register int	x = lft;
d442 78
d523 1
a523 1
_LOCAL_ void
d525 3
a527 3
	{	register int	key;
		register int	nop_key = EOF;
	/* Add all functions except NOP to tree.			*/
d535 1
a535 1
			/* First key bound to NOP.			*/
d545 1
a545 1
_LOCAL_ int
d547 3
a549 3
char	*buf;
	{	register int	curlen = strlen( cptr );
		register int	buflen = strlen( buf );
d553 1
a553 1
		return	0;
d556 1
a556 1
	(void) strncpy( cread_buf, buf, buflen ); /* Don't copy NUL.	*/
d559 1
a559 1
	return	1;
d562 1
a562 1
/*	d o _ K e y _ C m d ( )						*/
d565 2
a566 2
register int	key;
register int	n;
d595 31
a625 1
_LOCAL_ int
d627 73
d701 1
a701 1
char	*buf;
d705 1
a705 1
	return	-1;
d708 1
a708 1
_LOCAL_ int
d710 2
a711 2
f_Win_Lft( buf ) /* Move window left.					*/
char	*buf;
d715 2
a716 1
	return	fb_window( fbp, windo_center.p_x, windo_center.p_y ) != -1 ? 1 : 0;
d719 1
a719 1
_LOCAL_ int
d721 2
a722 2
f_Win_Dwn( buf ) /* Move window down.					*/
char	*buf;
d726 2
a727 1
	return	fb_window( fbp, windo_center.p_x, windo_center.p_y ) != -1 ? 1 : 0;
d730 1
a730 1
_LOCAL_ int
d732 2
a733 2
f_Win_Up( buf ) /* Move window up.					*/
char	*buf;
d737 2
a738 1
	return	fb_window( fbp, windo_center.p_x, windo_center.p_y ) != -1 ? 1 : 0;
d741 1
a741 1
_LOCAL_ int
d743 2
a744 2
f_Win_Rgt( buf ) /* Move window right.					*/
char	*buf;
d748 2
a749 1
	return	fb_window( fbp, windo_center.p_x, windo_center.p_y ) != -1 ? 1 : 0;
d752 1
a752 1
_LOCAL_ int
d754 2
a755 2
f_Reset_View( buf ) /* Restore normal view.				*/
char	*buf;
d762 1
a762 1
	return	1;
d765 1
a765 1
_LOCAL_ int
d767 2
a768 2
f_Redraw( buf ) /* Redraw screen.					*/
char	*buf;
d772 1
a772 1
	return	1;
d775 1
a775 1
_LOCAL_ int
d777 4
a780 4
f_Stop( buf ) /* Stop program.						*/
char	*buf;
	{	int	pid = getpid();
		int	sig;
d789 1
a789 1
		{	extern int	errno;
d797 1
a797 1
	return	1;
d800 1
a800 1
_LOCAL_ int
d803 1
a803 1
char	*buf;
d805 1
a805 1
		static char	name[MAX_LN];
d807 1
a807 1
		return	0;
d810 1
a810 1
		return	(*ftbl->f_func)( ftbl->f_buff );
d814 1
a814 1
		return	0;
d819 1
a819 1
_LOCAL_ int
d821 5
a825 5
f_Iterations( buf ) /* Specify number of iterations of next command.	*/
char	*buf;
	{	char		iterate_buf[MAX_DIGITS+1];
		int		iterate;
		register int	c, i;
d827 1
a827 1
		/* Clobber "f_Iterations()" key-stroke.		*/
d844 1
a844 1
		return	0;
d847 1
a847 1
	return	1;
d850 1
a850 1
_LOCAL_ int
d853 1
a853 1
char	*buf;
d855 2
a856 1
	return	1;
d859 1
a859 1
_LOCAL_ int
d861 13
a873 2
f_Dec_Brush_Size( buf ) /* Decrement brush size.			*/
char	*buf;
d877 1
a877 1
	return	1;
d880 1
a880 1
_LOCAL_ int
d882 2
a883 2
f_Inc_Brush_Size( buf ) /* Increment brush size.			*/
char	*buf;
d887 1
a887 1
	return	1;
d890 1
a890 1
_LOCAL_ int
d892 5
a896 5
f_Menu( buf ) /* Print menu.						*/
char	*buf;
	{	register int	lines =	(PROMPT_LINE-BOTTOM_STATUS_AREA)-1;
		register int	done = false;
		register int	key;
d898 1
a898 1
		{	register int	j;
d910 1
a910 1
		/* See if there is any more output.			*/
d937 1
a937 1
	return	1;
d940 1
a940 1
_LOCAL_ int
d942 2
a943 2
f_Dec_Step_Size( buf ) /* Decrement gain on move operations.		*/
char	*buf;
d947 1
a947 1
	return	1;
d950 1
a950 1
_LOCAL_ int
d952 2
a953 2
f_Inc_Step_Size( buf ) /* Increment gain on move operations.		*/
char	*buf;
d957 1
a957 1
	return	1;
d960 1
a960 1
_LOCAL_ int
d962 1
a962 1
char	*buf;
d965 1
a965 1
	return	1;
d968 1
a968 1
_LOCAL_ int
d971 1
a971 1
char	*buf;
d973 2
a974 2
		register int	nread = 1, room;
		char		scratch[MAX_LN];
d978 1
a978 1
			return	1;
d985 1
a985 1
			return	0;
d989 1
a989 1
			return	0;
d992 1
a992 1
	/* Read and execute functions from file.			*/
d1002 1
a1002 1
	return	1;
d1005 1
a1005 1
_LOCAL_ int
d1008 2
a1009 2
char	*buf;
	{	static char	macro_file[MAX_LN];
d1011 1
a1011 1
		register int	key;
d1013 1
a1013 1
		return	0;
d1017 1
a1017 1
		return	0;
d1023 2
d1031 1
a1031 1
				/* Output macro definition.			*/
d1040 1
a1040 1
				/* Output macro name, new-line terminated.	*/
d1046 1
a1046 1
				/* Output key binding, new-line terminated.	*/
d1048 1
a1048 1
					/* Escape control characters.		*/
d1053 1
a1053 1
			/* Write out current key binding.		*/
d1062 2
a1063 1
			(void) fprintf( macro_fp, "%s\n", bindings[key]->f_name );
d1067 1
a1067 1
	return	1;
d1070 1
a1070 1
_LOCAL_ int
d1073 1
a1073 1
char	*buf;
d1079 1
a1079 1
		return	0;
d1084 1
a1084 1
	return	1;
d1087 1
a1087 1
_LOCAL_ int
d1090 2
a1091 2
char	*buf;
	{	char		key[2];
d1095 1
a1095 1
		return	0;
d1098 1
a1098 1
		return	0;
d1105 1
a1105 1
		return	0;
d1108 1
a1108 1
	return	1;
d1111 1
a1111 1
_LOCAL_ int
d1114 2
a1115 2
char	*buf;
	{	static char	macro_name[MAX_LN];
d1119 1
a1119 1
		return	0;
d1122 1
a1122 1
		return	0;
d1130 1
a1130 1
	return	1;
d1133 1
a1133 1
_LOCAL_ int
d1135 5
a1139 5
f_Crunch_Image( buf ) /* Average image to half its size.		*/
char	*buf;
	{	char	answer[2];
		register int	x, y;
		register RGBpixel	*p1, *p2;
d1141 1
a1141 1
		return	0;
d1143 1
a1143 1
		return	1;
d1157 1
a1157 1
		{	register RGBpixel	*p_avg;
d1173 1
a1173 1
	return	1;
d1176 1
a1176 1
_LOCAL_ int
d1178 11
a1188 11
f_Draw_Line( buf )
char	*buf;
	{	Rectangle	lineseg;
		register int	major;
		register int	minor;
		register int	xsign;
		register int	ysign;
		register int	error;
		register int	x;
		register int	de;
		int		xmajor;
d1196 1
a1196 1
		Second Edition, pages 25-26.				*/
d1198 1
a1198 1
		end point.						*/
d1200 1
a1200 1
		{	Point	temp;
d1211 1
a1211 1
	/* If X is not really major, correct the assignments.		*/
d1213 1
a1213 1
		{	register int	temp = minor;
d1218 1
a1218 1
	error = major / 2 - minor; /* Initial DDA error.		*/
d1227 3
a1229 3
		if( major-- == 0 ) /* Done!				*/
			return	1;
		if( error < 0 )	 /* Advance major and minor.		*/
d1236 2
a1237 2
			{		/* Advance major only.		*/
			if( xmajor )	/* X is major direction.	*/
d1239 1
a1239 1
			else		/* Y is major direction.	*/
d1244 1
a1244 1
	return	1;
d1247 1
a1247 1
_LOCAL_ int
d1249 2
a1250 2
f_Fill_Panel( buf ) /* Fill current rectangle with "paint" color.	*/
char	*buf;
d1252 1
a1252 2
	fill_Rectangle( &current, (RGBpixel *) paint );
	return	1;
d1255 1
a1255 1
_LOCAL_ int
d1257 12
a1268 3
f_Bind_Key_To_Key( buf ) /* Bind new key to same function as old key.	*/
char	*buf;
	{	char	old_key[2], new_key[2];
d1270 1
a1270 1
		return	0;
d1277 1
a1277 1
		return	0;
d1280 1
a1280 1
		return	0;
d1282 1
a1282 1
	return	1;
d1285 1
a1285 1
_LOCAL_ int
d1287 4
a1290 4
f_Bind_Name_To_Key( buf ) /* Bind key to function or macro.		*/
char	*buf;
	{	char	key[2];
		static char	name[MAX_LN];
d1293 1
a1293 1
		return	0;
d1300 1
a1300 1
		return	0;
d1305 1
a1305 1
		return	0;
d1308 1
a1308 1
		/* Key is still bound to this function/macro.		*/
d1310 1
a1310 1
		return	1;
d1315 1
a1315 1
		return	0;
d1319 1
a1319 1
_LOCAL_ int
d1321 3
a1323 12
f_Dump_FBC( buf ) /* Dump frame buffer controller (FBC) registers.	*/
char	*buf;
	{
	fb_log( "Dump_FBC unimplemented.\n" );
	return	1;
	}

_LOCAL_ int
/*ARGSUSED*/
f_Erase_Fb( buf ) /* Erase (clear) framebuffer.			*/
char	*buf;
	{	char	answer[2];
d1325 1
a1325 1
		return	0;
d1331 1
a1331 1
	return	1;
d1334 1
a1334 1
_LOCAL_ int
d1336 4
a1339 4
f_Flip_Resolution( buf ) /* Flip framebuffer resolution.		*/
char	*buf;
	{	char	answer[2];
		int	is_hires = fb_getwidth(fbp) > 512;
d1347 1
a1347 1
		return	0;
d1349 1
a1349 1
		return	1;
d1352 1
a1352 1
		return	0;
d1357 1
a1357 1
	return	1;
d1360 1
a1360 1
_LOCAL_ int
d1362 2
a1363 2
f_Get_Panel( buf ) /* Grab panel from framebuffer.			*/
char	*buf;
d1372 1
a1372 1
	return	1; 
d1375 1
a1375 1
_LOCAL_ int
d1377 2
a1378 2
f_Jump_Lft( buf ) /* Move cursor left (big steps).			*/
char	*buf;
d1385 1
a1385 1
	return	1;
d1388 1
a1388 1
_LOCAL_ int
d1390 2
a1391 2
f_Jump_Dwn( buf ) /* Move cursor down.					*/
char	*buf;
d1398 1
a1398 1
	return	1;
d1401 1
a1401 1
_LOCAL_ int
d1403 2
a1404 2
f_Jump_Up( buf ) /* Move cursor up.					*/
char	*buf;
d1411 1
a1411 1
	return	1;
d1414 1
a1414 1
_LOCAL_ int
d1416 2
a1417 2
f_Jump_Rgt( buf ) /* Move cursor right.				*/
char	*buf;
d1424 1
a1424 1
	return	1;
d1427 1
a1427 1
_LOCAL_ int
d1429 2
a1430 2
f_Put_Panel( buf ) /* Put grabbed panel to framebuffer.		*/
char	*buf;
d1435 1
a1435 1
		return	0;
d1441 1
a1441 1
	return	1;
d1444 1
a1444 1
_LOCAL_ int
d1446 3
a1448 3
f_Restore_RLE( buf ) /* Restore Run-Length Encoded image.		*/
char	*buf;
	{	static char	rle_file_nm[MAX_LN];
d1450 1
a1450 1
		static char	*args[] =
d1455 1
a1455 1
		return	0;
d1459 1
a1459 1
		return	0;
d1465 1
a1465 1
		return	0;
d1473 1
a1473 1
		return	0;
d1479 1
a1479 1
	return	1;
d1482 1
a1482 1
_LOCAL_ int
d1484 4
a1487 4
f_Save_RLE( buf ) /* Save framebuffer image with Run-Length Encoding.	*/
char	*buf;
	{	static char	rle_file_nm[MAX_LN];
		static char	*args[4] =
d1497 1
a1497 1
		return	0;
d1501 1
a1501 1
		return	0;
d1504 2
a1505 2
		{	char	answer[2];
			char	question[MAX_LN+32];
d1511 1
a1511 1
			return	0;
d1513 1
a1513 1
			return	0;
d1518 1
a1518 1
		return	0;
d1526 1
a1526 1
	return	1;
d1529 1
a1529 1
_LOCAL_ int
d1532 6
a1537 6
char	*buf;
	{	static char	old_color[CLR_LEN], new_color[CLR_LEN];
		static int	red, grn, blu;
		RGBpixel	old, new, cur;
		register int	x, y;
		register int	lft, rgt, top, btm;
d1542 4
a1545 34
	if( ! get_Input( old_color, CLR_LEN, "Enter old pixel color [r g b] : " ) )
		return	0;
	if(	sscanf( old_color, "%d %d %d", &red, &grn, &blu ) == 3
	    &&	red >= 0 && red <= 255
	    &&	grn >= 0 && grn <= 255
	    &&	blu >= 0 && blu <= 255
		)
		{
		old[RED] = red;
		old[GRN] = grn;
		old[BLU] = blu;
		}
	else
		{
		fb_log( "You must enter 3 numbers (0..255).\n" );
		return	0;
		}
	if( ! get_Input( new_color, CLR_LEN, "Enter new pixel color [r g b] : " ) )
		return	0;
	if(	sscanf( new_color, "%d %d %d", &red, &grn, &blu ) == 3
	    &&	red >= 0 && red <= 255
	    &&	grn >= 0 && grn <= 255
	    &&	blu >= 0 && blu <= 255
		)
		{
		new[RED] = red;
		new[GRN] = grn;
		new[BLU] = blu;
		}
	else
		{
		fb_log( "You must enter 3 numbers (0..255).\n" );
		return	0;
		}
d1553 1
a1553 4
			if(	cur[RED] == old[RED]
			    &&	cur[GRN] == old[GRN]
			    &&	cur[BLU] == old[BLU]
				)
d1560 1
a1560 1
	return	1;
d1563 1
a1563 1
_LOCAL_ int
d1566 1
a1566 1
char	*buf;
d1571 1
a1571 1
		return	0;
d1595 1
a1595 1
	return	1;
d1598 1
a1598 1
_LOCAL_ int
d1601 2
a1602 2
char	*buf;
	{	register int	interactive = *cptr == NUL;
d1614 1
a1614 1
	/* Clobber macro terminator.					*/
d1631 1
a1631 1
	return	1;
d1634 1
a1634 1
_LOCAL_ int
d1636 2
a1637 2
f_Set_Rectangle( buf ) /* Set current rectangle.			*/
char	*buf;
d1640 1
a1640 1
	return	1;
d1643 1
a1643 1
_LOCAL_ int
d1645 2
a1646 2
f_Center_Window( buf ) /* Center window around cursor.			*/
char	*buf;
d1650 1
a1650 1
	return	1;
d1653 1
a1653 1
_LOCAL_ int
d1655 3
a1657 3
f_Rd_Font( buf ) /* Set current font.				*/
char	*buf;
	{	static char	fontname[FONTNAMESZ];
d1659 1
a1659 1
		return	0;
d1661 1
a1661 1
	return	1;
d1664 1
a1664 1
_LOCAL_ int
d1666 2
a1667 2
f_Set_Pixel( buf ) /* Set "paint" pixel color.				*/
char	*buf;
d1670 1
a1670 1
	return	1;
d1673 1
a1673 1
_LOCAL_ int
d1675 2
a1676 2
f_Move_Lft( buf ) /* Move cursor left.					*/
char	*buf;
d1683 1
a1683 1
	return	1;
d1686 1
a1686 1
_LOCAL_ int
d1688 2
a1689 2
f_Zoom_In( buf ) /* Halve window size.					*/
char	*buf;
d1697 1
a1697 1
	return	1;
d1700 1
a1700 1
_LOCAL_ int
d1702 2
a1703 2
f_Move_Dwn( buf ) /* Move cursor down.					*/
char	*buf;
d1710 1
a1710 1
	return	1;
d1713 1
a1713 1
_LOCAL_ int
d1715 2
a1716 2
f_Move_Up( buf ) /* Move cursor up.					*/
char	*buf;
d1723 1
a1723 1
	return	1;
d1726 1
a1726 1
_LOCAL_ int
d1728 2
a1729 2
f_Move_Rgt( buf ) /* Move cursor right.				*/
char	*buf;
d1736 1
a1736 1
	return	1;
d1739 1
a1739 1
_LOCAL_ int
d1741 2
a1742 2
f_Status_Monitor( buf ) /* Toggle status monitoring.			*/
char	*buf;
d1747 1
a1747 1
	return	1;
d1750 1
a1750 1
_LOCAL_ int
d1752 2
a1753 2
f_Zoom_Out( buf ) /* Double window size.				*/
char	*buf;
d1761 1
a1761 1
	return	1;
d1764 1
a1764 1
_LOCAL_ int
d1766 6
a1771 22
f_Key_Set_Pixel( buf ) /* User types in paint color.			*/
char	*buf;
	{	static char	color[CLR_LEN];
		static int	red, grn, blu;
	if( ! get_Input( color, CLR_LEN, "Enter color [r g b] : " ) )
		return	0;
	if(	sscanf( color, "%d %d %d", &red, &grn, &blu ) == 3
	    &&	red >= 0 && red <= 255
	    &&	grn >= 0 && grn <= 255
	    &&	blu >= 0 && blu <= 255
		)
		{
		paint[RED] = red;
		paint[GRN] = grn;
		paint[BLU] = blu;
		}
	else
		{
		fb_log( "You must enter 3 numbers (0..255).\n" );
		return	0;
		}
	return	1;
d1774 1
a1774 1
_LOCAL_ int
d1777 1
a1777 1
char	*buf;
d1785 1
a1785 1
_LOCAL_ int
d1787 4
a1790 4
f_Rd_Fb( buf ) /* Read frame buffer image from file.			*/
char	*buf;
	{	static char	image[MAX_LN];
		static FBIO	*imp;
d1792 1
a1792 1
		return	0;
d1796 1
a1796 1
		return	0;
d1802 1
a1802 1
		return	0;
d1807 1
a1807 1
	{	register int	y;
d1809 1
a1809 1
		{	RGBpixel	scanbuf[1024];
d1813 1
a1813 1
			return	0;
d1818 1
a1818 1
			return	0;
d1823 1
a1823 1
	return	1;
d1826 1
a1826 1
_LOCAL_ int
d1828 3
a1830 3
f_String( buf ) /* Place label on picture.				*/
char	*buf;
	{	static char	label[MAX_LN];
d1832 1
a1832 1
		return	0;
d1835 1
a1835 1
	return	1;
d1838 1
a1838 1
_LOCAL_ int
d1840 4
a1843 4
f_Put_Pixel( buf ) /* Put pixel.					*/
char	*buf;
	{	register int	rectwid = brush_sz / 2;
	/* If brush size is 2 or more, fill rectangle.			*/
d1845 1
a1845 1
		{ /* Avoid overhead if only writing one pixel.		*/
d1858 1
a1858 1
	return	1;
d1861 1
a1861 1
_LOCAL_ int
d1863 3
a1865 3
f_Set_X_Pos( buf ) /* Move cursor's X location (image space).		*/
char	*buf;
	{	static char	x_str[5];
d1867 14
a1880 2
		return	0;
	(void) sscanf( x_str, "%d", &cursor_pos.p_x );
d1886 1
a1886 1
	return	1;
d1889 1
a1889 1
_LOCAL_ int
d1891 3
a1893 3
f_Set_Y_Pos( buf ) /* Move cursor's Y location (image space).		*/
char	*buf;
	{	static char	y_str[5];
d1895 14
a1908 2
		return	0;
	(void) sscanf( y_str, "%d", &cursor_pos.p_y );
d1914 1
a1914 1
	return	1;
d1917 2
a1918 2
/*	p a r s _ A r g v ( )						*/
_LOCAL_ int
d1920 5
a1924 5
register char	**argv;
	{	register int	c;
		extern int	optind;
		extern char	*optarg;
	/* Parse options.						*/
d1936 1
a1936 1
			return	0;
d1942 1
a1942 1
		return	0;
d1944 1
a1944 1
	return	1;
d1947 2
a1948 2
/*	f b _ S e t u p ( )						*/
_LOCAL_ int
d1954 1
a1954 1
		return	-1;
d1961 1
a1961 1
		return	0;
d1966 1
a1966 1
	return	0;
d1969 2
a1970 2
/*	f b _ W i n d ( )						*/
_LOCAL_ void
d1981 2
a1982 2
/*	f b _ P a i n t ( )						*/
_LOCAL_ void
d1984 4
a1987 4
register int	x0, y0, x1, y1;
RGBpixel		*color;
	{	register int	x;
		Rectangle	clipped_rect;
d1993 1
a1993 1
	fill_Rectangle( &clipped_rect, color ); 
d1997 1
a1997 1
/*	g e n e r a l _ H a n d l e r ( )				*/
d1999 1
a1999 1
_LOCAL_ void
d2001 1
a2001 1
_LOCAL_ int
d2004 1
a2004 1
int	sig;
d2081 1
a2081 1
	return	sig;
d2085 1
a2085 1
/*	i n i t _ T t y ( )						*/
d2105 1
a2105 1
/*	r e s t o r e _ T t y ( )					*/
d2117 1
a2117 1
/*	f b _ G e t _ P i x e l ( )					*/
d2120 1
a2120 1
RGBpixel	pixel;
d2131 2
a2132 2
/*	g e t _ F b _ P a n e l ( )					*/
RGBpixel	*
d2134 6
a2139 6
register Rectangle	*rectp;
	{	register int	top;
		register int	rectwid;
		int		recthgt;
		int		btm, lft, rgt;
		RGBpixel	*panel;
d2164 2
a2165 2
		{	register int	y = btm;
			RGBpixel	*pixelp = panel;
d2173 1
a2173 1
				return	panel;
d2177 1
a2177 1
	return	panel;
d2180 2
a2181 2
/*	p u t _ F b _ P a n e l ( )					*/
_LOCAL_ void
d2183 4
a2186 4
register Rectangle	*rectp;
register RGBpixel	*panel;
	{	register int	top, rectwid, y;
		int		lft, rgt, btm;
d2206 2
a2207 2
/*	g e t _ P o i n t ( )						*/
_LOCAL_ void
d2209 5
a2213 5
char		*msg;
register Point	*pointp;
	{	register int	tag_point = -1;
		register int	status_change;
		register int	c = NUL;
d2215 3
a2217 2
	for( ; tag_point != 1 && c != ' '; )
		{	register int	status_change = false;
d2242 1
a2242 1
				else	/* EOF detected.		*/
d2267 2
a2268 2
/*	g e t _ R e c t a n g l e ( )					*/
_LOCAL_ void
d2270 3
a2272 3
char			*name;
register Rectangle	*rectp;
	{	char	buf[MAX_LN];
d2281 1
a2281 1
_LOCAL_ void
d2283 2
a2284 2
register Rectangle	*rectp;
	{	register int	i;
d2300 1
a2300 1
_LOCAL_ void
d2302 1
a2302 1
register Rectangle	*rectp;
d2311 1
a2311 1
_LOCAL_ RGBpixel	*
d2313 2
a2314 2
register RGBpixel	*p1, *p2, *p3, *p4;
	{	static RGBpixel	p_avg;
d2318 1
a2318 1
	return	(RGBpixel *)p_avg;
d2321 1
a2321 1
char	*
d2323 2
a2324 2
int	i;
	{	static char	buf[4];
d2339 1
a2339 1
		return	"DL";
d2341 2
a2342 2
		return	"EOF";
	return	buf;
d2346 2
a2347 2
Point	*pointp;
	{	extern FBIO	*fbp;
d2349 1
a2349 1
		return	do_Bitpad( pointp );
d2351 1
a2351 1
	return	sgi_Mouse_Pos( &cursor_pos );
d2353 1
a2353 1
	return	-1;
d2357 2
a2358 2
/*	d o _ B i t p a d ( )						*/
_LOCAL_ int
d2360 2
a2361 2
register Point	*pointp;
	{	int	press;
d2363 1
a2363 1
		return	-1;
d2373 1
a2373 1
		return	press;
d2375 1
a2375 1
	return	-1;
d2380 1
a2380 1
	{	int	c;
d2382 1
a2382 1
	return	(c = sgi_Getchar()) == EOF ? EOF : toascii( c );
d2384 1
a2384 1
	return	(c = getchar()) == EOF ? EOF : toascii( c );
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 8.4 89/03/20 11:53:20 moss Exp $ (BRL)";
d1325 1
a1325 1
			(void) fb_rpixel( fbp, cur );
d1894 1
a1894 1
	(void) fb_rpixel( fbp, pixel );
@


8.4
log
@Added signal handling for SIGCONT. Made default handler not restore
the tty modes.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 8.2 89/03/17 14:47:57 moss Locked $ (BRL)";
@


8.3
log
@Added catcher for SIGWINCH which does nothing.
@
text
@d1830 2
d1842 1
a1842 1
		restore_Tty();
@


8.2
log
@Fixed signal declaration pre-processor switches.
Modified general signal handler to ignore SIGALRM (seems to be generated
	on the Sun 3/50 3.2, probably by the select call).
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 8.1 88/10/05 00:45:02 moss Locked $ (BRL)";
d1766 3
a1768 1
#if defined( BSD ) || defined( sgi )
a1769 2
#else
_LOCAL_ void
d1813 4
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 7.3 88/10/04 20:09:35 moss Exp $ (BRL)";
d47 3
a49 1
#if defined( BSD ) || defined( sgi )
a50 2
#else
_LOCAL_ void	general_Handler();
d1811 2
d1840 3
a1842 1
#if defined( BSD ) || defined( sgi )
a1843 2
#else
	return;
@


7.3
log
@Recent revisions
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 7.2 88/03/01 15:15:03 moss Locked $ (BRL)";
@


7.2
log
@Names of two functions were switched in function table for setting
the X and Y cursor positions.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 7.1 87/11/03 00:10:31 moss Locked $ (BRL)";
d2140 1
a2140 1
#ifdef sgi		
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 6.1 87/07/11 08:13:59 mike Rel $ (BRL)";
d245 2
a246 2
/* x   */ f_Set_X_Pos,			NULL,	"set-cursor-y-pos",
/* y   */ f_Set_Y_Pos,			NULL,	"set-cursor-x-pos",
@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 5.1 87/06/24 22:45:04 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 4.7 87/06/22 14:51:58 moss Exp $ (BRL)";
@


4.7
log
@Cray portability bugs fixed.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: fbed.c,v 4.6 87/06/19 09:27:47 moss Locked $ (BRL)";
@


4.6
log
@Misc. improvements.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d63 59
a121 59
_LOCAL_ int	/* ^X  */ ft_Execute_Function(),
		/* ^I  */ ft_Nop(),
		/* ^H  */ ft_Win_Lft(),
		/* ^J  */ ft_Win_Dwn(),
		/* ^K  */ ft_Win_Up(),
		/* ^L  */ ft_Win_Rgt(),
		/* ^M  */ ft_Reset_View(),
		/* ^R  */ ft_Redraw(),
		/* ^Z  */ ft_Stop(),
		/* ESC */ ft_Iterations(),
		/* SP  */ ft_Press(),
		/* ,   */ ft_Dec_Brush_Size(),
		/* .   */ ft_Inc_Brush_Size(),
		/* <   */ ft_Dec_Step_Size(),
		/* >   */ ft_Inc_Step_Size(),
		/* ?   */ ft_Menu(),
		/* A   */ ft_Start_Macro(),
		/* B   */ ft_Bind_Macro_To_Key(),
		/* C   */ ft_Crunch_Image(),
		/* D   */ ft_Dump_FBC(),
		/* E   */ ft_Erase_Fb(),
		/* F   */ ft_Flip_Resolution(),
		/* G   */ ft_Get_Panel(),
		/* H   */ ft_Jump_Lft(),
		/* J   */ ft_Jump_Dwn(),
		/* K   */ ft_Jump_Up(),
		/* L   */ ft_Jump_Rgt(),
		/* N   */ ft_Name_Keyboard_Macro(),
		/* P   */ ft_Put_Panel(),
		/* R   */ ft_Restore_RLE(),
		/* S   */ ft_Save_RLE(),
		/* T   */ ft_Transliterate(),
		/* U   */ ft_Write_Macros_To_File(),
		/* W   */ ft_Fill_Panel(),
		/* X   */ ft_Bind_Key_To_Key(),
		/* Y   */ ft_Bind_Key_To_Name(),
		/* Z   */ ft_Stop_Macro(),
		/* a   */ ft_Enter_Macro_Definition(),
		/* b   */ ft_Set_Rectangle(),
		/* c   */ ft_Center_Window(),
		/* d   */ ft_Draw_Line(),
		/* f   */ ft_Read_Font(),
		/* g   */ ft_Set_Pixel(),
		/* h   */ ft_Move_Lft(),
		/* i   */ ft_Zoom_In(),
		/* j   */ ft_Move_Dwn(),
		/* k   */ ft_Move_Up(),
		/* l   */ ft_Move_Rgt(),
		/* m   */ ft_Status_Monitor(),
		/* o   */ ft_Zoom_Out(),
		/* p   */ ft_Key_Set_Pixel(),
		/* q   */ ft_Quit(),
		/* r   */ ft_Read_Fb(),
		/* s   */ ft_String(),
		/* u   */ ft_Read_Macros_From_File(),
		/* w   */ ft_Put_Pixel(),
		/* x   */ ft_Set_X_Pos(),
		/* y   */ ft_Set_Y_Pos(),
		/* Unbound */ ft_Execute_Macro();
d125 128
a252 128
/* NUL */ ft_Nop,			NULL,	"nop",
/* ^A  */ ft_Nop,			NULL,	"nop",
/* ^B  */ ft_Nop,			NULL,	"nop",
/* ^C  */ ft_Nop,			NULL,	"nop",
/* ^D  */ ft_Nop,			NULL,	"nop",
/* ^E  */ ft_Nop,			NULL,	"nop",
/* ^F  */ ft_Nop,			NULL,	"nop",
/* ^G  */ ft_Nop,			NULL,	"nop",
/* ^H  */ ft_Win_Lft,			NULL,	"move-window-left",
/* ^I  */ ft_Nop,			NULL,	"nop",
/* ^J  */ ft_Win_Dwn,			NULL,	"move-window-down",
/* ^K  */ ft_Win_Up,			NULL,	"move-window-up",
/* ^L  */ ft_Win_Rgt,			NULL,	"move-window-right",
/* ^M  */ ft_Reset_View,		NULL,	"reset-view",
/* ^N  */ ft_Nop,			NULL,	"nop",
/* ^O  */ ft_Nop,			NULL,	"nop",
/* ^P  */ ft_Nop,			NULL,	"nop",
/* ^Q  */ ft_Nop,			NULL,	"nop",
/* ^R  */ ft_Redraw,			NULL,	"redraw-tty-screen",
/* ^S  */ ft_Nop,			NULL,	"nop",
/* ^T  */ ft_Nop,			NULL,	"nop",
/* ^U  */ ft_Nop,			NULL,	"nop",
/* ^V  */ ft_Nop,			NULL,	"nop",
/* ^W  */ ft_Nop,			NULL,	"nop",
/* ^X  */ ft_Execute_Function,		NULL,	"execute-function-or-macro",
/* ^Y  */ ft_Nop,			NULL,	"nop",
/* ^Z  */ ft_Stop,			NULL,	"stop-program",
/* ESC */ ft_Iterations,		NULL,	"argument-count",
/* FS  */ ft_Nop,			NULL,	"nop",
/* GS  */ ft_Nop,			NULL,	"nop",
/* RS  */ ft_Nop,			NULL,	"nop",
/* US  */ ft_Nop,			NULL,	"nop",
/* SP  */ ft_Press,			NULL,	"pick-point",
/* !   */ ft_Nop,			NULL,	"nop",
/* "   */ ft_Nop,			NULL,	"nop",
/* #   */ ft_Nop,			NULL,	"nop",
/* $   */ ft_Nop,			NULL,	"nop",
/* %   */ ft_Nop,			NULL,	"nop",
/* &   */ ft_Nop,			NULL,	"nop",
/* `   */ ft_Nop,			NULL,	"nop",
/* (   */ ft_Nop,			NULL,	"nop",
/* )   */ ft_Nop,			NULL,	"nop",
/* *   */ ft_Nop,			NULL,	"nop",
/* +   */ ft_Nop,			NULL,	"nop",
/* ,   */ ft_Dec_Brush_Size,		NULL,	"decrement-brush-size",
/* -   */ ft_Nop,			NULL,	"nop",
/* .   */ ft_Inc_Brush_Size,		NULL,	"increment-brush-size",
/* /   */ ft_Nop,			NULL,	"nop",
/* 0   */ ft_Nop,			NULL,	"nop",
/* 1   */ ft_Nop,			NULL,	"nop",
/* 2   */ ft_Nop,			NULL,	"nop",
/* 3   */ ft_Nop,			NULL,	"nop",
/* 4   */ ft_Nop,			NULL,	"nop",
/* 5   */ ft_Nop,			NULL,	"nop",
/* 6   */ ft_Nop,			NULL,	"nop",
/* 7   */ ft_Nop,			NULL,	"nop",
/* 8   */ ft_Nop,			NULL,	"nop",
/* 9   */ ft_Nop,			NULL,	"nop",
/* :   */ ft_Nop,			NULL,	"nop",
/* ;   */ ft_Nop,			NULL,	"nop",
/* <   */ ft_Dec_Step_Size,		NULL,	"decrement-step-size",
/* =   */ ft_Nop,			NULL,	"nop",
/* >   */ ft_Inc_Step_Size,		NULL,	"increment-step-size",
/* ?   */ ft_Menu,			NULL,	"print-bindings",
/* @@   */ ft_Nop,			NULL,	"nop",
/* A   */ ft_Start_Macro,		NULL,	"start-macro-definition",
/* B   */ ft_Bind_Macro_To_Key,		NULL,	"bind-macro-to-key",
/* C   */ ft_Crunch_Image,		NULL,	"shrink-image-by-half",
/* D   */ ft_Dump_FBC,			NULL,	"dump-fbc-registers",
/* E   */ ft_Erase_Fb,			NULL,	"clear-framebuffer-memory",
/* F   */ ft_Flip_Resolution,		NULL,	"flip-framebuffer-resolution",
/* G   */ ft_Get_Panel,			NULL,	"get-current-rectangle",
/* H   */ ft_Jump_Lft,			NULL,	"jump-cursor-left",
/* I   */ ft_Nop,			NULL,	"nop",
/* J   */ ft_Jump_Dwn,			NULL,	"jump-cursor-down",
/* K   */ ft_Jump_Up,			NULL,	"jump-cursor-up",
/* L   */ ft_Jump_Rgt,			NULL,	"jump-cursor-right",
/* M   */ ft_Nop,			NULL,	"nop",
/* N   */ ft_Name_Keyboard_Macro,	NULL,	"name-keyboard-macro",
/* O   */ ft_Nop,			NULL,	"nop",
/* P   */ ft_Put_Panel,			NULL,	"put-saved-rectangle",
/* Q   */ ft_Nop,			NULL,	"nop",
/* R   */ ft_Restore_RLE,		NULL,	"read-rle-fle",
/* S   */ ft_Save_RLE,			NULL,	"write-rle-file",
/* T   */ ft_Transliterate,		NULL,	"replace-pixel-current-rectangle",
/* U   */ ft_Write_Macros_To_File,	NULL,	"write-macros-to-file",
/* V   */ ft_Nop,			NULL,	"nop",
/* W   */ ft_Fill_Panel,		NULL,	"fill-current-rectangle",
/* X   */ ft_Bind_Key_To_Key,		NULL,	"bind-key-to-key",
/* Y   */ ft_Bind_Key_To_Name,		NULL,	"bind-key-to-name",
/* Z   */ ft_Stop_Macro,		NULL,	"stop-macro-definition",
/* [   */ ft_Nop,			NULL,	"nop",
/* \   */ ft_Nop,			NULL,	"nop",
/* ]   */ ft_Nop,			NULL,	"nop",
/* ^   */ ft_Nop,			NULL,	"nop",
/* _   */ ft_Nop,			NULL,	"nop",
/* `   */ ft_Nop,			NULL,	"nop",
/* a   */ ft_Enter_Macro_Definition,	NULL,	"enter-macro-definition",
/* b   */ ft_Set_Rectangle,		NULL,	"set-current-rectangle",
/* c   */ ft_Center_Window,		NULL,	"window-center",
/* d   */ ft_Draw_Line,			NULL,	"draw-line",
/* e   */ ft_Nop,			NULL,	"nop",
/* f   */ ft_Read_Font,			NULL,	"read-font",
/* g   */ ft_Set_Pixel,			NULL,	"set-paint-to-current-pixel",
/* h   */ ft_Move_Lft,			NULL,	"move-cursor-left",
/* i   */ ft_Zoom_In,			NULL,	"zoom-in",
/* j   */ ft_Move_Dwn,			NULL,	"move-cursor-down",
/* k   */ ft_Move_Up,			NULL,	"move-cursor-up",
/* l   */ ft_Move_Rgt,			NULL,	"move-cursor-right",
/* m   */ ft_Status_Monitor,		NULL,	"set-monitor",
/* n   */ ft_Nop,			NULL,	"nop",
/* o   */ ft_Zoom_Out,			NULL,	"zoom-out",
/* p   */ ft_Key_Set_Pixel,		NULL,	"set-paint-from-key",
/* q   */ ft_Quit,			NULL,	"quit",
/* r   */ ft_Read_Fb,			NULL,	"read-framebuffer",
/* s   */ ft_String,			NULL,	"put-string",
/* t   */ ft_Nop,			NULL,	"nop",
/* u   */ ft_Read_Macros_From_File,	NULL,	"read-macros-from-file",
/* v   */ ft_Nop,			NULL,	"nop",
/* w   */ ft_Put_Pixel,			NULL,	"put-pixel",
/* x   */ ft_Set_X_Pos,			NULL,	"set-cursor-y-pos",
/* y   */ ft_Set_Y_Pos,			NULL,	"set-cursor-x-pos",
/* z   */ ft_Nop,			NULL,	"nop",
/* {   */ ft_Nop,			NULL,	"nop",
/* |   */ ft_Nop,			NULL,	"nop",
/* }   */ ft_Nop,			NULL,	"nop",
/* ~   */ ft_Nop,			NULL,	"nop",
/* DEL */ ft_Nop,			NULL,	"nop"
d296 1
a296 1
	(void) ft_Read_Macros_From_File( default_macro_file );
d338 1
a338 1
					(void) ft_Quit( (char *) NULL );
d395 1
a395 1
		if( bindings[key]->f_func != ft_Nop )
d440 1
a440 1
		if( bindings[key]->f_func != ft_Execute_Macro )
d461 1
a461 1
ft_Nop( buf )
d471 1
a471 1
ft_Win_Lft( buf ) /* Move window left.					*/
d481 1
a481 1
ft_Win_Dwn( buf ) /* Move window down.					*/
d491 1
a491 1
ft_Win_Up( buf ) /* Move window up.					*/
d501 1
a501 1
ft_Win_Rgt( buf ) /* Move window right.					*/
d511 1
a511 1
ft_Reset_View( buf ) /* Restore normal view.				*/
d524 1
a524 1
ft_Redraw( buf ) /* Redraw screen.					*/
d534 1
a534 1
ft_Stop( buf ) /* Stop program.						*/
d559 1
a559 1
ft_Execute_Function( buf )
d578 1
a578 1
ft_Iterations( buf ) /* Specify number of iterations of next command.	*/
d584 1
a584 1
		/* Clobber "ft_Iterations()" key-stroke.		*/
d609 1
a609 1
ft_Press( buf )
d617 1
a617 1
ft_Dec_Brush_Size( buf ) /* Decrement brush size.			*/
d627 1
a627 1
ft_Inc_Brush_Size( buf ) /* Increment brush size.			*/
d637 1
a637 1
ft_Menu( buf ) /* Print menu.						*/
d646 1
a646 1
			if( bindings[key]->f_func != ft_Nop )
d656 1
a656 1
		for( j = key; j <= DEL && bindings[j]->f_func == ft_Nop; j++ )
d687 1
a687 1
ft_Dec_Step_Size( buf ) /* Decrement gain on move operations.		*/
d697 1
a697 1
ft_Inc_Step_Size( buf ) /* Increment gain on move operations.		*/
d706 1
a706 1
ft_Execute_Macro( buf )
d715 1
a715 1
ft_Read_Macros_From_File( buf )
d752 1
a752 1
ft_Write_Macros_To_File( buf )
d768 1
a768 1
			if( bindings[key]->f_func == ft_Execute_Macro )
d814 1
a814 1
ft_Start_Macro( buf )
d831 1
a831 1
ft_Bind_Macro_To_Key( buf )
d855 1
a855 1
ft_Name_Keyboard_Macro( buf )
d877 1
a877 1
ft_Crunch_Image( buf ) /* Average image to half its size.		*/
d920 1
a920 1
ft_Draw_Line( buf )
d991 1
a991 1
ft_Fill_Panel( buf ) /* Fill current rectangle with "paint" color.	*/
d1000 1
a1000 1
ft_Bind_Key_To_Key( buf ) /* Bind new key to same function as old key.	*/
d1021 1
a1021 1
ft_Bind_Key_To_Name( buf ) /* Bind key to function or macro.		*/
d1055 1
a1055 1
ft_Dump_FBC( buf ) /* Dump frame buffer controller (FBC) registers.	*/
d1064 1
a1064 1
ft_Erase_Fb( buf ) /* Erase (clear) framebuffer.			*/
d1079 1
a1079 1
ft_Flip_Resolution( buf ) /* Flip framebuffer resolution.		*/
d1105 1
a1105 1
ft_Get_Panel( buf ) /* Grab panel from framebuffer.			*/
d1120 1
a1120 1
ft_Jump_Lft( buf ) /* Move cursor left (big steps).			*/
d1133 1
a1133 1
ft_Jump_Dwn( buf ) /* Move cursor down.					*/
d1146 1
a1146 1
ft_Jump_Up( buf ) /* Move cursor up.					*/
d1159 1
a1159 1
ft_Jump_Rgt( buf ) /* Move cursor right.				*/
d1172 1
a1172 1
ft_Put_Panel( buf ) /* Put grabbed panel to framebuffer.		*/
d1189 1
a1189 1
ft_Restore_RLE( buf ) /* Restore Run-Length Encoded image.		*/
d1227 1
a1227 1
ft_Save_RLE( buf ) /* Save framebuffer image with Run-Length Encoding.	*/
d1274 1
a1274 1
ft_Transliterate( buf ) /* Transliterate pixels of color1 to target color2.*/
d1341 1
a1341 1
ft_Stop_Macro( buf )
d1350 1
a1350 1
	/* Clobber "ft_Stop_Macro()" key-stroke or "ft_Execute_Function()
d1363 1
a1363 1
	macro_entry->f_func = ft_Execute_Macro;
d1376 1
a1376 1
ft_Enter_Macro_Definition( buf )
d1398 1
a1398 1
	macro_entry->f_func = ft_Execute_Macro;
d1412 1
a1412 1
ft_Set_Rectangle( buf ) /* Set current rectangle.			*/
d1421 1
a1421 1
ft_Center_Window( buf ) /* Center window around cursor.			*/
d1431 1
a1431 1
ft_Read_Font( buf ) /* Set current font.				*/
d1442 1
a1442 1
ft_Set_Pixel( buf ) /* Set "paint" pixel color.				*/
d1451 1
a1451 1
ft_Move_Lft( buf ) /* Move cursor left.					*/
d1464 1
a1464 1
ft_Zoom_In( buf ) /* Halve window size.					*/
d1478 1
a1478 1
ft_Move_Dwn( buf ) /* Move cursor down.					*/
d1491 1
a1491 1
ft_Move_Up( buf ) /* Move cursor up.					*/
d1504 1
a1504 1
ft_Move_Rgt( buf ) /* Move cursor right.				*/
d1517 1
a1517 1
ft_Status_Monitor( buf ) /* Toggle status monitoring.			*/
d1528 1
a1528 1
ft_Zoom_Out( buf ) /* Double window size.				*/
d1542 1
a1542 1
ft_Key_Set_Pixel( buf ) /* User types in paint color.			*/
d1568 1
a1568 1
ft_Quit( buf )
d1579 1
a1579 1
ft_Read_Fb( buf ) /* Read frame buffer image from file.			*/
d1620 1
a1620 1
ft_String( buf ) /* Place label on picture.				*/
d1632 1
a1632 1
ft_Put_Pixel( buf ) /* Put pixel.					*/
d1655 1
a1655 1
ft_Set_X_Pos( buf ) /* Move cursor's X location (image space).		*/
d1671 1
a1671 1
ft_Set_Y_Pos( buf ) /* Move cursor's Y location (image space).		*/
d1811 4
a1814 2
#ifndef sgi
#ifdef BSD
d1817 3
d1822 2
d1825 1
a1825 2
	case SIGCLD :
		break;
d1828 1
a1828 2
#endif
		(void) ft_Stop( (char *) NULL );
d1830 1
a1830 3
#else
	case SIGCHLD :
		break;
@


4.5
log
@Release 1.20 -- First Formal Release
@
text
@a1 5
	SCCS id:	@@(#) fbed.c	2.7
	Modified: 	1/7/87 at 14:57:08
	Retrieved: 	1/7/87 at 14:57:48
	SCCS archive:	/vld/moss/src/fbed/s.fbed.c

d8 2
a9 3
#if ! defined( lint )
static
char	sccsTag[] = "@@(#) fbed.c 2.7, modified 1/7/87 at 14:57:08, archive /vld/moss/src/fbed/s.fbed.c";
d1114 1
a1718 5
	if( fbp != FBIO_NULL )
		{
		fb_log( "Closing previously opened frame buffer.\n" );
		(void)fb_close( fbp );
		}
d2012 1
a2012 1
			(void) fflush( fbp );
@


4.4
log
@Fixed bugs in restoring saved rectangles.  Added clip_Rectangle function.
@
text
@@


4.3
log
@Cleaned up interface to bitpad or mouse driven cursor and added support
for the SGI IRIS.  Added line-drawing command.  Added guard against user
attempting to put down a rectangle before getting one in "ft_Put_Panel".
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fbed.c	2.6
	Modified: 	1/5/87 at 16:56:54
	Retrieved: 	1/5/87 at 16:58:08
d15 1
a15 1
char	sccsTag[] = "@@(#) fbed.c 2.6, modified 1/5/87 at 16:56:54, archive /vld/moss/src/fbed/s.fbed.c";
d62 1
d373 3
a375 3
			{	register int	x = lft;
			for( ; x <= rgt; x++ )
				fb_write( fbp, x, btm, pixelp, 1 );
d386 1
a386 1
	(void) fb_flush(fbp);
d441 1
a441 1
		prnt_Prompt( "" );
d1766 5
a1770 4
	clipped_rect.r_origin.p_x = x0 < 0 ? 0 : x0;
	clipped_rect.r_corner.p_x = x1 >= fb_getwidth(fbp) ? fb_getwidth(fbp) - 1 : x1;
	clipped_rect.r_origin.p_y = y0 < 0 ? 0 : y0;
	clipped_rect.r_corner.p_y = y1 >= fb_getheight(fbp) ? fb_getheight(fbp) - 1 : y1;
d1954 2
a1959 11
	if( lft > rgt )
		{
		lft = rgt;
		rgt = rectp->r_origin.p_x;
		}
	if( btm > top )
		{
		top = btm;
		btm = rectp->r_origin.p_y;
		}
	rectwid = rgt-lft + 1;
d1962 1
a1962 1
		if( fb_write( fbp, lft, y, panel, rectwid ) == -1 )
d2027 2
a2028 1
	fb_log( "Point picked.\n" );
d2063 11
@


4.2
log
@Latest versions from Moss
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fbed.c	2.5
	Modified: 	12/29/86 at 16:16:06
	Retrieved: 	12/30/86 at 17:01:43
d15 1
a15 1
char	sccsTag[] = "@@(#) fbed.c 2.5, modified 12/29/86 at 16:16:06, archive /vld/moss/src/fbed/s.fbed.c";
d42 6
a47 12
static Panel		panel;	      /* Current panel.			*/
static Point		bitpad;
static Point		image_center; /* Center of image space.		*/
static Point		windo_center; /* Center of screen, image coords.*/
static Point		windo_anchor; /* Saved "windo_center".		*/
static Rectangle	current;      /* Current saved rectangle.	*/
static int		step;	      /* Current step size.		*/
static int		size_viewport;
static int		zoom_factor;
static int		pad_flag = false;
static int		menu_press;
static int		last_key;
d49 1
a51 1
_LOCAL_ int	in_Menu_Area();
a57 1
_LOCAL_ void	do_Menu_Press();
d61 5
a94 1
		/* M   */ ft_Pick_Popup(),
d108 1
d207 1
a207 1
/* M   */ ft_Pick_Popup,		NULL,	"popup-menu",
d230 1
a230 1
/* d   */ ft_Nop,			NULL,	"nop",
a264 1
static int	reposition_cursor = 1;
a315 1
		menu_press = false;
d332 2
a333 1
				reposition_cursor = 0;
d346 3
a348 12
		if( pad_flag )
			if( (button_press = do_Bitpad( &cursor_pos )) == 1 )
				{
				De_Bounce_Pen();
				do_Menu_Press();
				status_change = true;
				}
			else
			if( button_press != -1 )
				status_change = true;
		if(	pallet.on_flag
		    &&	in_Menu_Area( &pallet, cursor_pos.p_x, cursor_pos.p_y )
d350 1
a350 6
			fb_Pick_Menu( menu_press, &pallet );
		else
		if(	pick_one.on_flag
		    &&	in_Menu_Area( &pick_one, cursor_pos.p_x, cursor_pos.p_y )
			)
			fb_Pick_Menu( menu_press, &pick_one );
d353 1
a353 1
			(void) fb_flush(fbp);
d360 3
a362 3
void
fill_Rect( lft, rgt, btm, top, pixelp )
register int		lft, rgt, top;
d364 4
a367 2
int			btm;
	{	register int	y = btm;
d369 8
a376 4
	for( ; y <= top; y++ )
		{	register int	x = lft;
		for( ; x <= rgt; x++ )
			fb_write( fbp, x, y, pixelp, 1 );
d378 2
a379 2
#else
	for( ; y <= top; y++ )
d381 1
a381 1
		(void) fb_seek( fbp, x, y );
a385 1
#endif
d451 1
a451 7
	if( in_Menu_Area( &pick_one, cursor_pos.p_x, cursor_pos.p_y ) )
		step = pick_one.seg_hgt;
	else
	if( in_Menu_Area( &pallet, cursor_pos.p_x, cursor_pos.p_y ) )
		step = pallet.seg_hgt;
	else
		step = gain;
a616 1
	do_Menu_Press();
d925 71
d998 2
a999 11
	{	register int	x, y;
		register int	top, btm, lft, rgt;	
	lft = current.r_origin.p_x;
	rgt = current.r_corner.p_x;
	btm = current.r_origin.p_y;
	top = current.r_corner.p_y;
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
		fb_Off_Menu( &pick_one );
	fill_Rect( lft, rgt, btm, top, (RGBpixel *) paint );
a1097 4
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
		fb_Off_Menu( &pick_one );
a1112 4
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
		fb_Off_Menu( &pick_one );
d1176 1
a1176 1
ft_Pick_Popup( buf ) /* Toggle 'pick' menu.				*/
d1179 1
a1179 1
	if( menu_flag )
d1181 2
a1182 10
		prnt_Event( "Initializing popup menu." );
		fb_Init_Menu();
		menu_flag = false;
		if( fudge_flag )
			{
			prnt_Event( "Correcting image." );
			fudge_Picture( fbp, RESERVED_CMAP );
			fudge_flag = false;
			}
		fb_log( "Popup menu initialized.\n" );
a1183 19
	else
		Toggle( pick_one.on_flag );
	if( pick_one.on_flag )
		fb_On_Menu( &pick_one );
	else
		fb_Off_Menu( &pick_one );
	reposition_cursor = true;
	return	1;
	}

_LOCAL_ int
/*ARGSUSED*/
ft_Put_Panel( buf ) /* Put grabbed panel to framebuffer.		*/
char	*buf;
	{
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
	fb_Off_Menu( &pick_one );
a1214 4
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
		fb_Off_Menu( &pick_one );
a1224 1
	fudge_flag = true;
a1263 4
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
		fb_Off_Menu( &pick_one );
a1271 1
	fudge_flag = true;
a1288 4
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
		fb_Off_Menu( &pick_one );
a1576 5
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
		fb_Off_Menu( &pick_one );
	/*(void) fb_wmap( fbp, &cmap );*/
a1600 4
	if( pallet.on_flag )
		fb_Off_Menu( &pallet );
	if( pick_one.on_flag )
		fb_Off_Menu( &pick_one );
a1602 8
#if 0
	if( fudge_Picture( imp, RESERVED_CMAP ) == -1 )
		{
		fb_log( "Read of \"%s\" failed.\n", image );
		return	0;
		}
	fudge_flag = false;
#else
a1617 1
#endif
a1733 10
	/*if( fb_rmap( fbp, &cmap ) == -1 )
		{
		fb_log( "Can't read color map.\n" );
		return	0;
		}
	if( fb_wmap( fbp, &cmap ) == -1 )
		{
		fb_log( "Can't write color map.\n" );
		return	0;
		}*/
d1764 6
a1769 5
	x0 = x0 < 1 ? 1 : x0;
	x1 = x1 > fb_getwidth(fbp) ? fb_getwidth(fbp) : x1;
	y0 = y0 < 1 ? 1 : y0;
	y1 = y1 > fb_getheight(fbp) ? fb_getheight(fbp) : y1;
	fill_Rect( x0, x1, y0, y1, color ); 
d1882 4
a1885 3
/*	d o _ M e n u _ P r e s s ( )					*/
_LOCAL_ void
do_Menu_Press()
d1887 6
a1892 6
	if(	pick_one.on_flag
	    &&	in_Menu_Area( &pick_one, cursor_pos.p_x, cursor_pos.p_y )
	   ||	pallet.on_flag
	    &&	in_Menu_Area( &pallet, cursor_pos.p_x, cursor_pos.p_y )
		)
		menu_press = true;
d1896 18
a1913 15
/*	d o _ B i t p a d ( )						*/
int
do_Bitpad( pointp )
register Point	*pointp;
	{	int	press;
	if( ! pad_flag )
		return	-1;
	if( (press = getpos( &bitpad )) != -1 )
		{		
		pointp->p_x = windo_anchor.p_x +
				(bitpad.p_x-image_center.p_x)/zoom_factor;
		pointp->p_y = windo_anchor.p_y +
				(bitpad.p_y-image_center.p_y)/zoom_factor;
		(void) fb_cursor( fbp, 1, pointp->p_x, pointp->p_y );
		return	press;
d1915 28
a1942 1
	return	-1;
d1945 12
a1956 6
/*	f b _ G e t _ P i x e l ( )					*/
void
fb_Get_Pixel( pixel )
RGBpixel	pixel;
	{
	if( pallet.on_flag && in_Menu_Area( &pallet, cursor_pos.p_x, cursor_pos.p_y ) )
d1958 2
a1959 1
		COPYRGB( pixel, pallet.segs[pallet.last_pick-1].color );
d1961 1
a1961 1
	else
d1963 2
a1964 6
#ifdef sgi
		(void) fb_read( fbp, cursor_pos.p_x, cursor_pos.p_y, pixel, 1 );
#else
		(void) fb_seek( fbp, cursor_pos.p_x, cursor_pos.p_y );
		(void) fb_rpixel( fbp, pixel );
#endif
d1966 11
d1980 57
a2036 10
/*	i n _ M e n u _ A r e a ( )					*/
_LOCAL_ int
in_Menu_Area( menup, x, y )
register Menu	*menup;
register int	x, y;
	{
	return	x > menup->rect.r_origin.p_x
	   &&	x < menup->rect.r_corner.p_x
	   &&	y > menup->rect.r_origin.p_y + menup->seg_hgt
	   &&	y < menup->rect.r_corner.p_y;
d2039 33
d2104 33
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d2 3
a4 3
	SCCS id:	@@(#) fbed.c	2.2
	Modified: 	12/17/86 at 15:46:35
	Retrieved: 	12/26/86 at 21:54:07
d15 1
a15 1
char	sccsTag[] = "@@(#) fbed.c 2.2, modified 12/17/86 at 15:46:35, archive /vld/moss/src/fbed/s.fbed.c";
d1587 1
a1587 1
	(void) fb_wmap( fbp, &cmap );
d1758 1
a1758 1
	if( fb_rmap( fbp, &cmap ) == -1 )
d1767 1
a1767 1
		}
d2018 1
a2018 2
	if( ismex() && tty )
		return	(c = sgi_Getchar()) == EOF ? EOF : toascii( c );
@


1.8
log
@Latest version from Gary Moss
@
text
@@


1.7
log
@Added initial call to fb_cursor, to turn it on immediately.
@
text
@d2 4
a5 4
	SCCS id:	%Z% %M%	%I%
	Last edit: 	%G% at %U%
	Retrieved: 	%H% at %T%
	SCCS archive:	%P%
d10 3
a12 3
			Maryland 21005
			(301)278-6647 or AV-283-6647
 */
d15 1
a15 1
char	sccsTag[] = "%Z% %M%	%I%	last edit %G% at %U%";
a21 3
#include "fb.h"
#include "./std.h"
#include "./try.h"
d28 1
a28 1
	unsigned char bits[32*4];
d30 2
d38 1
a38 1
		prnt_Debug( "\%s\"(%d) EOF encountered prematurely.", \
d59 1
a59 1
#if defined( BSD )
d156 1
a156 1
/* ^X  */ ft_Execute_Function,		NULL,	"execute-function",
d266 2
a267 1
int	cur_width = 512;
a284 1
	getfont();
d292 1
d314 1
a324 5
		/*
		 * This is a golden opportunity for SELECT() here,
		 * monitoring both the bitpad and the keyboard.
		 * The current code in empty is a CPU-eater.
		 */
d328 10
a337 1
			{	char	c;
d339 2
a340 1
				if(  read( tty_fd, &c, 1 ) == 1 )
d342 1
a342 1
					do_Key_Cmd( (int) c, 1 );
d347 1
a369 1
			(void) fb_cursor( fbp, 1, cursor_pos.p_x, cursor_pos.p_y );
d377 24
d431 1
a431 1
	if( curlen + buflen > BUFSIZ-1 )
d433 1
a433 1
		prnt_Debug( "Macro buffer would overflow." );
d436 1
a436 1
	(void) strcpy( cread_buf+buflen, cptr );
d438 1
d453 1
a453 1
		prnt_Debug( "" );
d487 1
a487 1
	prnt_Debug( "Unbound(%s).", char_To_String( last_key ) );
d498 1
d508 1
d518 1
d528 1
d541 1
d566 1
a566 1
	prnt_Debug( "[%d] stopped.", pid );
d570 1
a570 1
		perror( "(%M%) kill" );
d575 1
a575 1
	prnt_Debug( "[%d] foreground.", pid );
d593 1
a593 1
		prnt_Debug( "I seem to have lost my bindings." );
d610 1
a610 1
	for( i = 0; i < MAX_DIGITS && isdigit( c = getchar() & 0xff ); i++ )
d614 1
d617 1
a617 1
		c = getchar() & 0xff;
d620 1
d623 1
a623 1
		prnt_Debug( "Iterations not set." );
d688 1
a688 1
			switch( *cptr != NUL ? *cptr++ : getchar() )
d749 1
a749 1
			prnt_Debug( "Reading macros from file \"%s\".", buf );
d757 1
a757 1
			prnt_Debug( "Can't open \"%s\" for reading.", scratch );
d764 1
a764 1
		room = sizeof( cread_buf ) - strlen( cread_buf );
d785 1
a785 1
		prnt_Debug( "Can't open \"%s\" for writing.", macro_file );
d843 1
a843 1
		prnt_Debug( "I am already remembering." );
d849 1
a849 1
	prnt_Debug( "Remembering..." );
d860 1
a860 1
		prnt_Debug( "Define macro first." );
d868 1
a868 1
		prnt_Debug(	"It is not permitted to change '%s' binding.",
d884 1
a884 1
		prnt_Debug( "Define macro first." );
d950 2
a951 2
	top = current.r_origin.p_y;
	btm = current.r_corner.p_y;
d956 1
a956 8
	for( y = top; y <= btm ; y++ )
		{
		x = lft;
		(void) fb_seek( fbp, x, y );
		for( ; x <= rgt; x++ )
			FB_WPIXEL( fbp, paint );
		}
	(void) fb_flush(fbp);
d965 1
a965 1
	if( ! get_Input( new_key, 2, "Bind key : " ) )
d970 1
a970 1
		prnt_Debug(	"It is not permitted to change '%s' binding.",
d975 1
a975 1
	if( ! get_Input( old_key, 2, "To key : " ) )
d993 1
a993 1
		prnt_Debug(	"It is not permitted to change '%s' binding.",
d1010 1
a1010 1
		prnt_Debug( "I seem to have lost my bindings." );
d1020 1
a1020 1
	prnt_Debug( "Dump_FBC unimplemented" );
d1035 1
d1065 1
d1080 1
a1080 6
	prnt_Debug(	"Storing rectangle [%d,%d],[%d,%d].",
			current.r_origin.p_x,
			current.r_origin.p_y,
			current.r_corner.p_x,
			current.r_corner.p_y
			);
d1096 1
d1105 2
a1106 2
	if( cursor_pos.p_y <= fb_getheight(fbp) - JUMP )
		cursor_pos.p_y += JUMP;
d1108 2
a1109 1
		cursor_pos.p_y = fb_getheight(fbp) - 1;
d1118 2
a1119 2
	if( cursor_pos.p_y >= JUMP )
		cursor_pos.p_y -= JUMP;
d1121 2
a1122 1
		cursor_pos.p_y = 0;
d1135 1
d1146 1
a1146 1
		prnt_Debug( "Initializing popup menu." );
d1151 1
a1151 1
			prnt_Debug( "Correcting image." );
d1155 1
a1155 1
		prnt_Debug( "Popup menu initialized." );
d1163 1
d1197 1
a1197 1
		prnt_Debug( "No default." );
d1203 1
a1203 1
		prnt_Debug( "Can't open \"%s\".", rle_file_nm );
d1206 1
a1206 1
	prnt_Debug( "Decoding \"%s\".", rle_file_nm );
d1212 1
d1244 1
a1244 1
		prnt_Debug( "No default." );
d1260 1
a1260 1
	prnt_Debug( "Encoding \"%s\".", rle_file_nm );
d1268 1
a1268 1
		prnt_Debug( "Image saved in \"%s\".", rle_file_nm );
d1270 1
a1270 1
		prnt_Debug( "Image not saved." );
d1274 1
d1284 1
a1284 1
		RGBpixel		old, new, cur;
d1309 1
a1309 1
		prnt_Debug( "You must enter 3 numbers (0..255)." );
d1326 1
a1326 1
		prnt_Debug( "You must enter 3 numbers (0..255)." );
d1356 1
a1356 1
		prnt_Debug( "I was not remembering." );
d1380 1
a1380 1
	prnt_Debug( "Keyboard macro defined." );
d1394 1
a1394 1
		while( (*macro_ptr++ = getchar()) != 'Z' )
d1416 1
a1416 1
		prnt_Debug( "Keyboard macro defined." );
d1435 1
d1443 2
a1444 2
	{
	if( ! get_Input( fontname, 128, "Enter font name : " ) )
d1446 1
a1446 1
	getfont();
d1468 1
d1481 1
d1491 2
a1492 2
	if( cursor_pos.p_y <= fb_getheight(fbp) - step )
		cursor_pos.p_y += step;
d1494 2
a1495 1
		cursor_pos.p_y = fb_getwidth(fbp) - 1;
d1504 2
a1505 2
	if( cursor_pos.p_y >= step )
		cursor_pos.p_y -= step;
d1507 2
a1508 1
		cursor_pos.p_y = 0;
d1521 1
d1545 1
d1556 1
a1556 1
	if( ! get_Input( color, MAX_LN, "Enter color [r g b] : " ) )
d1570 1
a1570 1
		prnt_Debug( "You must enter 3 numbers (0..255)." );
d1581 1
a1581 1
	prnt_Debug( "Bye..." );
d1602 1
a1602 1
		prnt_Debug( "No default." );
d1608 1
a1608 3
		prnt_Debug(	"Can't open \"%s\" for reading.",
				image
				);
d1611 1
a1611 1
	prnt_Debug( "Reading \"%s\".", image );
d1617 2
d1621 1
a1621 1
		prnt_Debug( "Read of \"%s\" failed.", image );
d1624 18
a1642 1
	fudge_flag = false;
d1653 1
a1653 1
	prnt_Debug( "Drawing \"%s\".", label );
d1663 15
a1677 4
	fb_Paint(	cursor_pos.p_x - rectwid, cursor_pos.p_y - rectwid,
			cursor_pos.p_x + rectwid, cursor_pos.p_y + rectwid,
			paint
			);
d1693 1
d1709 1
d1749 1
a1749 1
		prnt_Debug( "fb_open:  closing previous FB" );
d1754 1
a1754 1
		prnt_Debug( "fb_open(%d) failed", cur_width );
d1760 1
a1760 1
		prnt_Debug( "Can't read color map." );
d1765 1
a1765 1
		prnt_Debug( "Can't write color map." );
d1771 1
a1771 1
		prnt_Debug( "Can't set up cursor." );
a1773 1
	(void) fb_cursor( fbp, 1, cursor_pos.p_x, cursor_pos.p_y );
d1802 1
a1802 8
	for( ; y0 <= y1 ; ++y0 )
		{
		(void) fb_seek( fbp, x0, y0 );
		for( x = x0; x <= x1; ++x )
			{
			FB_WPIXEL( fbp, *color );
			}
		}
d1807 1
a1807 1
#if defined( BSD )
d1818 1
a1818 1
		prnt_Debug( "Hangup." );
d1823 1
a1823 1
		prnt_Debug( "Interrupt." );
d1828 1
a1828 1
		prnt_Debug( "Quit (core dumped)." );
d1833 1
a1833 1
		prnt_Debug( "Illegal instruction (core dumped)." );
d1838 1
a1838 1
		prnt_Debug( "IOT trap (core dumped)." );
d1843 1
a1843 1
		prnt_Debug( "Bus error (core dumped)." );
d1848 1
a1848 1
		prnt_Debug( "Segmentation violation (core dumped)." );
d1852 1
d1866 4
d1871 1
a1871 1
		prnt_Debug( "\"%s\", signal(%d).", __FILE__, sig );
d1876 1
a1876 1
#if defined( BSD )
d1897 3
d1958 3
d1963 1
d2012 11
@


1.6
log
@Minor modification to prevent constant updating of
fb_cursor when nothing is happening.
@
text
@d1702 1
@


1.5
log
@Fixed #include path
@
text
@d324 5
a332 1
			(void) fb_cursor( fbp, 1, cursor_pos.p_x, cursor_pos.p_y );
d363 1
@


1.4
log
@Phil's new style fb_cursor
@
text
@d33 1
a33 1
#include "cursorbits.h"
@


1.3
log
@Version that works with new libfb
@
text
@d27 1
a27 1
static long cursor[32] =
d29 4
d1691 2
a1692 1
	if( fb_setcursor( fbp, cursor ) == -1 )
@


1.2
log
@First version that compiles
@
text
@d858 1
a858 1
		RGBpixel	*p_buff;
d863 2
a864 2
	if( (p_buff = (RGBpixel *) malloc( sizeof(RGBpixel) * fb_getwidth(fbp) * 2 ))
		== (RGBpixel *) NULL
d869 6
d877 2
a878 1
		fb_read( fbp, 0, y, p_buff, fb_getwidth(fbp) * 2 );
d881 4
a884 4
			p_avg = pixel_Avg(	p_buff+x,
						p_buff+x+1,
						p_buff+x+fb_getwidth(fbp),
						p_buff+x+fb_getwidth(fbp)+1
d886 1
a886 2
			(void) fb_seek( fbp, x/2, y/2 );
			FB_WPIXEL( fbp, *p_avg );
d888 1
d890 2
a891 1
	free( (char *) p_buff );
d1134 1
a1134 1
	get_Point( "Pick top-left corner of panel", &current.r_origin );
d1897 3
a1899 3
	p_avg[RED] = ((int) p1[RED] + (int) p2[RED] + (int) p3[RED] + (int) p4[RED]) / 4;
	p_avg[GRN] = ((int) p1[GRN] + (int) p2[GRN] + (int) p3[GRN] + (int) p4[GRN]) / 4;
	p_avg[BLU] = ((int) p1[BLU] + (int) p2[BLU] + (int) p3[BLU] + (int) p4[BLU]) / 4;
@


1.1
log
@Initial revision
@
text
@d17 1
a19 1
#include <std.h>
d22 4
a25 3
#include <fb.h>
#include "try.h"
#include "extern.h"
d31 1
a61 1
_LOCAL_ void	init_Globs();
d65 1
a65 1
_LOCAL_ Pixel	*pixel_Avg();
d262 3
a280 1
	init_Globs();
d324 1
a324 1
			(void) fbcursor( 1, cursor_pos.p_x, cursor_pos.p_y );
d355 1
a355 1
			(void) fbflush();
d458 1
a458 1
	return	fbwindow( windo_center.p_x, windo_center.p_y ) != -1 ? 1 : 0;
d467 1
a467 1
	return	fbwindow( windo_center.p_x, windo_center.p_y ) != -1 ? 1 : 0;
d476 1
a476 1
	return	fbwindow( windo_center.p_x, windo_center.p_y ) != -1 ? 1 : 0;
d485 1
a485 1
	return	fbwindow( windo_center.p_x, windo_center.p_y ) != -1 ? 1 : 0;
d495 1
a495 1
	size_viewport = _fbsize;
d858 1
a858 1
		Pixel	*p_buff;
d863 2
a864 2
	if( (p_buff = (Pixel *) malloc( sizeof(Pixel) * _fbsize * 2 ))
		== (Pixel *) NULL
d869 4
a872 4
	for( y = 0; y < _fbsize; y += 2 )
		{	register Pixel	*p_avg;
		fbread( 0, y, p_buff, _fbsize * 2 );
		for( x = 0; x < _fbsize; x +=2 )
d876 2
a877 2
						p_buff+x+_fbsize,
						p_buff+x+_fbsize+1
d879 2
a880 2
			(void) fbseek( x/2, y/2 );
				(void) fbwpixel( p_avg );
d904 1
a904 1
		(void) fbseek( x, y );
d906 1
a906 1
			(void) fbwpixel( &paint );
d908 1
a908 1
	(void) fbflush();
d972 1
a972 2
	if( fbgettype() == FB_IKONAS )
		prnt_FBC();
d985 1
a985 2
		(void) fbclear();
		fbioinit();
d995 1
d998 1
a998 1
				fbgetsize() == 1024 ?
d1010 2
a1011 2
	(void) fbcursor( 0, cursor_pos.p_x, cursor_pos.p_y );
	if( fbclose( _fbfd ) == -1 )
d1013 1
a1013 2
	fbsetsize( fbgetsize() == 512 ? 1024 : 512 );
	init_Globs();
d1028 1
a1028 1
	if( panel.n_buf != (Pixel *) NULL )
d1059 1
a1059 1
	if( cursor_pos.p_y <= _fbsize - JUMP )
d1062 1
a1062 1
		cursor_pos.p_y = _fbsize - 1;
d1083 1
a1083 1
	if( cursor_pos.p_x <= _fbsize - JUMP )
d1086 1
a1086 1
		cursor_pos.p_x = _fbsize - 1;
d1103 1
a1103 1
			fudge_Picture( _fbfd, RESERVED_CMAP );
d1161 2
a1162 2
	(void) fbcursor( 0, cursor_pos.p_x, cursor_pos.p_y );
	if( fbclose( _fbfd ) == -1 )
d1184 1
a1184 1
	if( _fbsize == 1024 )
d1214 1
a1214 1
	if( fbclose( _fbfd ) == -1 )
d1232 1
a1232 1
		Pixel		old, new, cur;
d1251 3
a1253 3
		old.red = red;
		old.green = grn;
		old.blue = blu;
d1268 3
a1270 3
		new.red = red;
		new.green = grn;
		new.blue = blu;
d1280 1
a1280 1
		(void) fbseek( x, y );
d1283 4
a1286 4
			(void) fbrpixel( &cur );
			if(	cur.red == old.red
			    &&	cur.green == old.green
			    &&	cur.blue == old.blue
d1289 2
a1290 2
				(void) fbseek( x, y );
				(void) fbwpixel( &new );
d1402 1
a1402 1
	fb_Get_Pixel( &paint );
d1423 1
a1423 1
	if( size_viewport > _fbsize / 16 )
d1436 1
a1436 1
	if( cursor_pos.p_y <= _fbsize - step )
d1439 1
a1439 1
		cursor_pos.p_y = _fbsize - 1;
d1460 1
a1460 1
	if( cursor_pos.p_x <= _fbsize - step )
d1463 1
a1463 1
		cursor_pos.p_x = _fbsize - 1;
d1483 1
a1483 1
	if( size_viewport < _fbsize )
d1505 3
a1507 3
		paint.red = red;
		paint.green = grn;
		paint.blue = blu;
d1528 1
a1528 5
	/* Can't read cmap from Raster Tech.				*/
	if( _fbtype == FB_RASTER_TECH )
		(void) fb_wmap( (ColorMap *) NULL );
	else
		(void) fb_wmap( &cmap );
d1538 1
a1538 1
		static int	image_fd;
d1547 1
a1547 1
	if( (image_fd = open( image, O_RDONLY )) == -1 )
d1559 2
a1560 2
	(void) fbcursor( 0, cursor_pos.p_x, cursor_pos.p_y );
	if( fudge_Picture( image_fd, RESERVED_CMAP ) == -1 )
d1565 1
a1565 1
	(void) close( image_fd );
d1578 1
a1578 1
	do_line( cursor_pos.p_x, cursor_pos.p_y, label, (Pixel *)NULL );
d1589 1
a1589 1
			&paint
d1602 2
a1603 2
	if( cursor_pos.p_x > _fbsize )
		cursor_pos.p_x = _fbsize;
d1617 2
a1618 2
	if( cursor_pos.p_y > _fbsize )
		cursor_pos.p_y = _fbsize;
a1623 12
/*	i n i t _ G l o b s ( )
	Initialize things for normal view.
 */
_LOCAL_ void
init_Globs()
	{
	windo_center.p_x = cursor_pos.p_x = image_center.p_x = _fbsize / 2;
	windo_center.p_y = cursor_pos.p_y = image_center.p_y = _fbsize / 2;
	size_viewport = _fbsize;
	return;
	}

d1637 1
a1637 1
			fbsetsize( 1024 );
d1658 1
a1658 1
	if( fbopen( NULL, APPEND ) == -1 )
d1660 6
a1665 1
		prnt_Debug( "Can't open %s", _fbfile );
d1668 2
a1669 2
	fbioinit();
	if( fb_rmap( &cmap ) == -1 )
d1674 1
a1674 1
	if( fbsetcursor( cursor ) == -1 )
d1676 5
d1684 3
d1694 2
a1695 3
	zoom_factor = _fbsize / size_viewport;
	if( zoom_factor >= 1 && zoom_factor <= 16 )
		(void) fbzoom( zoom_factor, zoom_factor );
d1698 1
a1698 1
	(void) fbwindow( windo_center.p_x, windo_center.p_y );
d1706 1
a1706 1
Pixel		*color;
d1709 1
a1709 1
	x1 = x1 > _fbsize ? _fbsize : x1;
d1711 1
a1711 1
	y1 = y1 > _fbsize ? _fbsize : y1;
d1714 1
a1714 1
		(void) fbseek( x0, y0 );
d1716 3
a1718 1
			(void) fbwpixel( color );
d1801 1
a1801 1
		if( pad_open( _fbsize ) == -1 )
d1816 1
a1816 1
	(void) fbcursor( 0, cursor_pos.p_x, cursor_pos.p_y );
d1850 1
a1850 1
		(void) fbcursor( 1, pointp->p_x, pointp->p_y );
d1859 1
a1859 1
Pixel	*pixel;
d1862 3
a1864 1
		*pixel = pallet.segs[pallet.last_pick-1].color;
a1865 3
	if( _fbtype == FB_RASTER_TECH ) /* Optimization for Raster Tech. */
		(void) _rat_rpixel( cursor_pos.p_x, cursor_pos.p_y, pixel );
	else
d1867 2
a1868 2
		(void) fbseek( cursor_pos.p_x, cursor_pos.p_y );
		(void) fbrpixel( pixel );
d1885 1
a1885 1
_LOCAL_ Pixel	*
d1887 6
a1892 6
register Pixel	*p1, *p2, *p3, *p4;
	{	static Pixel	p_avg;
	p_avg.red = ((int) p1->red + (int) p2->red + (int) p3->red + (int) p4->red) / 4;
	p_avg.green = ((int) p1->green + (int) p2->green + (int) p3->green + (int) p4->green) / 4;
	p_avg.blue = ((int) p1->blue + (int) p2->blue + (int) p3->blue + (int) p4->blue) / 4;
	return	&p_avg;
@
