head	11.3;
access;
symbols
	ansi-20040405-merged:11.1.2.1
	postmerge-20040405-ansi:11.1
	premerge-20040404-ansi:11.1
	postmerge-autoconf:11.1
	autoconf-freeze:11.1.4.1
	premerge-autoconf:11.1
	postmerge-20040315-windows:11.1
	windows-20040315-freeze:1.1.2.1
	autoconf-branch:11.1.0.4
	windows-branch:1.1.0.2
	ansi-branch:11.1.0.2;
locks; strict;
comment	@ * @;


11.3
date	2004.05.21.17.47.43;	author morrison;	state dead;
branches;
next	11.2;

11.2
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.1;

11.1
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches
	11.1.2.1
	11.1.4.1;
next	1.1;

1.1
date	2002.09.26.23.04.11;	author morrison;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.09.26.23.04.11;	author morrison;	state Exp;
branches;
next	;

11.1.2.1
date	2004.03.17.21.21.59;	author morrison;	state Exp;
branches;
next	;

11.1.4.1
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.3
log
@moved to src/mged/
@
text
@/*
 *			F B S E R V . C
 *
 *  This code was developed by modifying the stand-alone version of fbserv to work
 *  within MGED.
 *
 *  Author -
 *	Robert Parker
 *
 *  Authors of the stand-alone fbserv -
 *	Phillip Dykstra
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/fbserv_win32.c,v 11.2 2004/05/10 15:30:48 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>

#include "tcl.h"
#include "machine.h"
#include "externs.h"		/* For malloc, getopt */
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "../libfb/pkgtypes.h"
#include "./fbserv.h"

#define NET_LONG_LEN	4	/* # bytes to network long */

void set_port();

#ifdef LOCAL_STATIC
#undef LOCAL_STATIC
#endif
#define LOCAL_STATIC static

LOCAL_STATIC void new_client();
LOCAL_STATIC void drop_client();
LOCAL_STATIC void new_client_handler();
LOCAL_STATIC void existing_client_handler();
LOCAL_STATIC void comm_error();
LOCAL_STATIC void setup_socket();


/*
 *			N E W _ C L I E N T
 */
LOCAL_STATIC void
new_client(pcp)
struct pkg_conn	*pcp;
{
    return;
}

/*
 *			D R O P _ C L I E N T
 */
LOCAL_STATIC void
drop_client(sub)
int sub;
{
    return;
}

/*
 *			S E T _ P O R T
 */
void
set_port()
{
    return;
}

/*
 * Accept any new client connections.
 */
LOCAL_STATIC void
new_client_handler(clientData, mask)
ClientData clientData;
int mask;
{
    return;
}

/*
 * Process arrivals from existing clients.
 */
LOCAL_STATIC void
existing_client_handler(clientData, mask)
ClientData clientData;
int mask;
{
    return;
}

LOCAL_STATIC void
setup_socket(fd)
int	fd;
{
    return;
}

/*
 *			C O M M _ E R R O R
 *
 *  Communication error.  An error occured on the PKG link.
 */
LOCAL_STATIC void
comm_error(str)
char *str;
{
    return;
}

/*
 * This is where we go for message types we don't understand.
 */
void
pkgfoo(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/******** Here's where the hooks lead *********/

void
rfbopen(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbclose(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbfree(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbclear(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbread(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbwrite(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B R E A D R E C T
 */
void
rfbreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B W R I T E R E C T
 */
void
rfbwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B B W R E A D R E C T
 */
void
rfbbwreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B B W W R I T E R E C T
 */
void
rfbbwwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbgetcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbsetcursor(pcp, buf)
struct pkg_conn *pcp;
char		*buf;
{
    return;
}

/*OLD*/
void
rfbscursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*OLD*/
void
rfbwindow(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*OLD*/
void
rfbzoom(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbgetview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbrmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B W M A P
 *
 *  Accept a color map sent by the client, and write it to the framebuffer.
 *  Network format is to send each entry as a network (IBM) order 2-byte
 *  short, 256 red shorts, followed by 256 green and 256 blue, for a total
 *  of 3*256*2 bytes.
 */
void
rfbwmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbflush(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbpoll(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *  At one time at least we couldn't send a zero length PKG
 *  message back and forth, so we receive a dummy long here.
 */
void
rfbhelp(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}
@


11.2
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/fbserv_win32.c,v 11.1 2004/03/16 21:15:11 morrison Exp $ (ARL)";
@


11.1
log
@merge of windows-6-0-branch into head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d31 5
a35 1
#include "conf.h"
@


11.1.4.1
log
@merge from head
@
text
@@


11.1.2.1
log
@sync branch with HEAD
@
text
@@


1.1
log
@file fbserv_win32.c was initially added on branch windows-6-0-branch.
@
text
@d1 356
@


1.1.2.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a0 356
/*
 *			F B S E R V . C
 *
 *  This code was developed by modifying the stand-alone version of fbserv to work
 *  within MGED.
 *
 *  Author -
 *	Robert Parker
 *
 *  Authors of the stand-alone fbserv -
 *	Phillip Dykstra
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/fbserv.c,v 1.11 2000/11/01 21:16:10 mike Exp $ (ARL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <ctype.h>

#include "tcl.h"
#include "machine.h"
#include "externs.h"		/* For malloc, getopt */
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "../libfb/pkgtypes.h"
#include "./fbserv.h"

#define NET_LONG_LEN	4	/* # bytes to network long */

void set_port();

#ifdef LOCAL_STATIC
#undef LOCAL_STATIC
#endif
#define LOCAL_STATIC static

LOCAL_STATIC void new_client();
LOCAL_STATIC void drop_client();
LOCAL_STATIC void new_client_handler();
LOCAL_STATIC void existing_client_handler();
LOCAL_STATIC void comm_error();
LOCAL_STATIC void setup_socket();


/*
 *			N E W _ C L I E N T
 */
LOCAL_STATIC void
new_client(pcp)
struct pkg_conn	*pcp;
{
    return;
}

/*
 *			D R O P _ C L I E N T
 */
LOCAL_STATIC void
drop_client(sub)
int sub;
{
    return;
}

/*
 *			S E T _ P O R T
 */
void
set_port()
{
    return;
}

/*
 * Accept any new client connections.
 */
LOCAL_STATIC void
new_client_handler(clientData, mask)
ClientData clientData;
int mask;
{
    return;
}

/*
 * Process arrivals from existing clients.
 */
LOCAL_STATIC void
existing_client_handler(clientData, mask)
ClientData clientData;
int mask;
{
    return;
}

LOCAL_STATIC void
setup_socket(fd)
int	fd;
{
    return;
}

/*
 *			C O M M _ E R R O R
 *
 *  Communication error.  An error occured on the PKG link.
 */
LOCAL_STATIC void
comm_error(str)
char *str;
{
    return;
}

/*
 * This is where we go for message types we don't understand.
 */
void
pkgfoo(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/******** Here's where the hooks lead *********/

void
rfbopen(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbclose(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbfree(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbclear(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbread(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbwrite(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B R E A D R E C T
 */
void
rfbreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B W R I T E R E C T
 */
void
rfbwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B B W R E A D R E C T
 */
void
rfbbwreadrect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B B W W R I T E R E C T
 */
void
rfbbwwriterect(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbgetcursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbsetcursor(pcp, buf)
struct pkg_conn *pcp;
char		*buf;
{
    return;
}

/*OLD*/
void
rfbscursor(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*OLD*/
void
rfbwindow(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*OLD*/
void
rfbzoom(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbgetview(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbrmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *			R F B W M A P
 *
 *  Accept a color map sent by the client, and write it to the framebuffer.
 *  Network format is to send each entry as a network (IBM) order 2-byte
 *  short, 256 red shorts, followed by 256 green and 256 blue, for a total
 *  of 3*256*2 bytes.
 */
void
rfbwmap(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbflush(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

void
rfbpoll(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}

/*
 *  At one time at least we couldn't send a zero length PKG
 *  message back and forth, so we receive a dummy long here.
 */
void
rfbhelp(pcp, buf)
struct pkg_conn *pcp;
char *buf;
{
    return;
}
@

