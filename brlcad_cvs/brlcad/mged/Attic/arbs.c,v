head	11.37;
access;
symbols
	ansi-20040405-merged:11.33.2.2
	postmerge-20040405-ansi:11.35
	premerge-20040404-ansi:11.34
	postmerge-autoconf:11.34
	autoconf-freeze:11.33.10.2
	premerge-autoconf:11.34
	postmerge-20040315-windows:11.34
	premerge-20040315-windows:11.34
	windows-20040315-freeze:11.33.4.1
	autoconf-20031203:11.33
	autoconf-20031202:11.33
	autoconf-branch:11.33.0.10
	phong-branch:11.33.0.8
	photonmap-branch:11.33.0.6
	rel-6-1-DP:11.33
	windows-branch:11.33.0.4
	rel-6-0-2:11.31
	ansi-branch:11.33.0.2
	rel-6-0-1-branch:11.31.0.2
	hartley-6-0-post:11.32
	hartley-6-0-pre:11.31
	rel-6-0-1:11.31
	rel-6-0:11.31
	rel-5-4:11.24
	offsite-5-3-pre:11.28
	rel-5-3:11.24
	rel-5-2:11.24
	rel-5-1-branch:11.24.0.2
	rel-5-1:11.24
	rel-5-0:11.22
	rel-5-0-beta:11.21
	rel-4-5:11.21
	ctj-4-5-post:11.19
	ctj-4-5-pre:11.19
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.37
date	2004.05.21.17.47.35;	author morrison;	state dead;
branches;
next	11.36;

11.36
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.35;

11.35
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	11.33.2.1
	11.33.4.1
	11.33.10.1;
next	11.32;

11.32
date	2002.08.15.20.55.31;	author hartley;	state Exp;
branches;
next	11.31;

11.31
date	2001.10.02.19.24.31;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	2001.06.01.19.23.22;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	2001.03.23.22.05.31;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2001.01.09.15.56.17;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	2000.10.24.15.17.48;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.09.08.05.55.47;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.19.03.10.40;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	99.12.29.23.23.17;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	99.11.24.14.26.41;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	99.09.01.18.55.08;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	97.06.19.22.32.04;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	97.05.20.23.05.08;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.03.24.18.25.37;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.02.25.14.19.54;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.09.23.18.40.01;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.03.17.41.27;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.08.28.15.08.31;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.07.15.20.33.09;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.02.18.03.08.41;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.37;	author mike;	state Rel4_4;
branches;
next	10.13;

10.13
date	94.12.16.19.35.24;	author gdurf;	state Exp;
branches;
next	10.12;

10.12
date	94.12.14.16.27.44;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.11.28.13.51.38;	author jra;	state Exp;
branches;
next	10.10;

10.10
date	94.11.10.12.06.01;	author jra;	state Exp;
branches;
next	10.9;

10.9
date	94.08.09.14.36.05;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.06.03.17.21.10;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.01.26.13.08.37;	author pjt;	state Exp;
branches;
next	10.6;

10.6
date	94.01.24.16.18.16;	author pjt;	state Exp;
branches;
next	10.5;

10.5
date	93.09.30.11.35.13;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	92.03.21.05.32.27;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.03.18.00.40.34;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.18.00.23.25;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.04;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.08.30.17.18.50;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.00.31.05;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.07.20.42.50;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.21.06.04.25;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.01.42;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.05.11.21.39.43;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.19.20.34;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	89.01.16.22.51.28;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.49.22;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.21;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.19.22.49.13;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.15.23.04.36;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.02.15.53.07;	author stay;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.03.17;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.22;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.01.26;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.17.35;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.02.13.00.05.15;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.05.38.47;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.18.55;	author mike;	state Rel1;
branches;
next	1.5;

1.5
date	86.09.23.17.39.32;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.09.09.22.16.39;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.12.06.46.26;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.07.16.17.54.09;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.03.10.21.45.52;	author mike;	state Exp;
branches;
next	;

11.33.2.1
date	2002.09.19.18.01.59;	author morrison;	state Exp;
branches;
next	11.33.2.2;

11.33.2.2
date	2004.03.17.21.21.54;	author morrison;	state Exp;
branches;
next	;

11.33.4.1
date	2004.03.11.23.46.32;	author morrison;	state Exp;
branches;
next	;

11.33.10.1
date	2004.02.12.18.34.12;	author erikg;	state Exp;
branches;
next	11.33.10.2;

11.33.10.2
date	2004.03.15.14.07.35;	author erikg;	state Exp;
branches;
next	;


desc
@Build ARB8s, given info.
@


11.37
log
@moved to src/mged/
@
text
@/*
 *			A R B S . C
 *
 *	f_3ptarb()	finds arb8 defined by 3 points, 2 coordinates of
 *			a 4th point, and a thickness
 *
 *	f_rfarb()	finds arb8 defined by rot & fallback angles, one point,
 *			2 coordinates of the 3 remaining points, and a thickness
 *
 *  Author -
 *	Keith A. Applin
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/arbs.c,v 11.36 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <signal.h>
#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <math.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "./cmd.h"

extern int	newargs;
extern char	**promp;

char *p_arb3pt[] = {
	"Enter X, Y, Z for point 1: ",
	"Enter Y, Z: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 2: ",
	"Enter Y, Z: ",
	"Enter Z: ",
	"Enter X, Y, Z for point 3: ",
	"Enter Y, Z: ",
	"Enter Z: "
};

/*
 *
 *	F _ 3 P T A R B ( ) :	finds arb8 given.....
 *				1.  3 points of one face
 *				2.  2 coordinates of the 4th point in that face
 *				3.  thickness
 *
 */
int
f_3ptarb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int			i, solve;
	vect_t			vec1;
	vect_t			vec2;
	fastf_t			pt4[2], length, thick;
	vect_t			norm;
	fastf_t			ndotv;
	struct directory	*dp;
	struct rt_db_internal	internal;
	struct rt_arb_internal	*aip;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

        if(argc < 1 || 27 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help 3ptarb");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* get the arb name */
	if( argc < 2 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter name for this arb: ", (char *)NULL);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip, argv[1], LOOKUP_QUIET) != DIR_NULL ) {
	  Tcl_AppendResult(interp, argv[1], ":  already exists\n", (char *)NULL);
	  return TCL_ERROR;
	}

	/* read the three points */
	promp = &p_arb3pt[0];
	if( argc < 11 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, promp[argc-2], (char *)NULL);
	  return TCL_ERROR;
	}

	/* preliminary calculations to check input so far */
	for(i=0; i<3; i++) {
		vec1[i] = atof(argv[i+2]) - atof(argv[i+5]);
		vec2[i] = atof(argv[i+2]) - atof(argv[i+8]);
	}
	VCROSS(norm, vec1, vec2);
	length = MAGNITUDE( norm );
	if(length == 0.0) {
	  Tcl_AppendResult(interp, "points are colinear\n", (char *)NULL);
	  return TCL_ERROR;
	}
	VSCALE(norm, norm, 1.0/length);

	if( argc < 12 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   "Enter coordinate to solve for (x, y, or z): ", (char *)NULL);
	  return TCL_ERROR;
	}

	switch( argv[11][0] ) {

	case 'x':
		if(norm[0] == 0.0) {
		  Tcl_AppendResult(interp, "X not unique in this face\n", (char *)NULL);
		  return TCL_ERROR;
		}
		solve = X;

		if( argc < 13 ) {			
		  Tcl_AppendResult(interp, MORE_ARGS_STR,
				   "Enter the Y, Z coordinate values: ", (char *)NULL);
		  return TCL_ERROR;
		}
		if( argc < 14 ) {
		  Tcl_AppendResult(interp, MORE_ARGS_STR,
				   "Enter the Z coordinate value: ", (char *)NULL);
		  return TCL_ERROR;
		}
		pt4[0] = atof( argv[12] ) * local2base;
		pt4[1] = atof( argv[13] ) * local2base;
		break;

	case 'y':
		if(norm[1] == 0.0) {
		  Tcl_AppendResult(interp, "Y not unique in this face\n", (char *)NULL);
		  return TCL_ERROR;
		}
		solve = Y;

		if ( argc < 13 ) {
		  Tcl_AppendResult(interp, MORE_ARGS_STR,
				   "Enter the X, Z coordinate values: ", (char *)NULL);
		  return TCL_ERROR;
		}
		if ( argc < 14 ) {
		  Tcl_AppendResult(interp, MORE_ARGS_STR,
				   "Enter the Z coordinate value: ", (char *)NULL);
		  return TCL_ERROR;
		}

		pt4[0] = atof( argv[12] ) * local2base;
		pt4[1] = atof( argv[13] ) * local2base;
		break;

	case 'z':
		if(norm[2] == 0.0) {
		  Tcl_AppendResult(interp, "Z not unique in this face\n", (char *)NULL);
		  return TCL_ERROR;
		}
		solve = Z;

		if ( argc < 13 ) {
		  Tcl_AppendResult(interp, MORE_ARGS_STR,
				   "Enter the X, Y coordinate values: ", (char *)NULL);
		  return TCL_ERROR;
		}
		if ( argc < 14 ) {
		  Tcl_AppendResult(interp, MORE_ARGS_STR,
				   "Enter the Y coordinate value: ", (char *)NULL);
		  return TCL_ERROR;
		}
		pt4[0] = atof( argv[12] ) * local2base;
		pt4[1] = atof( argv[13] ) * local2base;
		break;

	default:
	  Tcl_AppendResult(interp, "coordinate must be x, y, or z\n", (char *)NULL);
	  return TCL_ERROR;
	}


	if ( argc < 15 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   "Enter thickness for this arb: ", (char *)NULL);
	  return TCL_ERROR;
	}

	if( (thick = (atof( argv[14] ))) == 0.0 ) {
	  Tcl_AppendResult(interp, "thickness = 0.0\n", (char *)NULL);
	  return TCL_ERROR;
	}

	RT_INIT_DB_INTERNAL( &internal );
	internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	internal.idb_type = ID_ARB8;
	internal.idb_meth = &rt_functab[ID_ARB8];
	internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
	aip = (struct rt_arb_internal *)internal.idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;

	for(i=0; i<8; i++) {
		VSET( aip->pt[i] , 0.0 , 0.0 , 0.0 );
	}

	for(i=0; i<3; i++) {
		/* the three given vertices */
		VSET( aip->pt[i] , atof( argv[i*3+2] )*local2base , atof( argv[i*3+3] )*local2base , atof( argv[i*3+4] )*local2base );
	}

	thick *= local2base;

	ndotv = VDOT( aip->pt[0], norm );

	switch( solve ) {

		case X:
			/* solve for x-coord of 4th point */
			aip->pt[3][Y] = pt4[0];		/* y-coord */
			aip->pt[3][Z] = pt4[1]; 	/* z-coord */
			aip->pt[3][X] =  ( ndotv
					- norm[Y] * aip->pt[3][Y]
					- norm[Z] * aip->pt[3][Z])
					/ norm[X];	/* x-coord */
		break;

		case Y:
			/* solve for y-coord of 4th point */
			aip->pt[3][X] = pt4[0];		/* x-coord */
			aip->pt[3][Z] = pt4[1]; 	/* z-coord */
			aip->pt[3][Y] =  ( ndotv
					- norm[X] * aip->pt[3][X]
					- norm[Z] * aip->pt[3][Z])
					/ norm[Y];	/* y-coord */
		break;

		case Z:
			/* solve for z-coord of 4th point */
			aip->pt[3][X] = pt4[0];		/* x-coord */
			aip->pt[3][Y] = pt4[1]; 	/* y-coord */
			aip->pt[3][Z] =  ( ndotv
					- norm[X] * aip->pt[3][X]
					- norm[Y] * aip->pt[3][Y])
					/ norm[Z];	/* z-coord */
		break;

		default:
		  Tcl_AppendResult(interp, "bad coordinate to solve for\n", (char *)NULL);
		  return TCL_ERROR;
	}

	/* calculate the remaining 4 vertices */
	for(i=0; i<4; i++) {
		VJOIN1( aip->pt[i+4] , aip->pt[i] , thick , norm );
	}

	if( (dp = db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&internal.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to the directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &internal, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}

	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = argv[1]; /* depends on solid name being in argv[1] */
	  av[2] = NULL;

	  /* draw the "made" solid */
	  return cmd_draw( clientData, interp, 2, av );
	}
}



char *p_rfin[] = {
	"Enter X, Y, Z of the known point: ",
	"Enter Y,Z: ",
	"Enter Z: "
};

/*	F _ R F A R B ( ) :	finds arb8 given.....
 *
 *		1. one point
 *		2. 2 coordinates of 3 other points
 *		3. rot and fallback angles
 *		4. thickness
 */
int
f_rfarb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory	*dp;
	int			i;
	int			solve[3];
	fastf_t			pt[3][2];
	fastf_t			thick, rota, fba;
	vect_t			norm;
	fastf_t			ndotv;
	struct rt_db_internal	internal;
	struct rt_arb_internal	*aip;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 1 || 27 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help rfarb");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* get the arb name */
	if( argc < 2 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter name for this arb: ", (char *)NULL);
	  return TCL_ERROR;
	}
	if( db_lookup( dbip, argv[1], LOOKUP_QUIET) != DIR_NULL ) {
	  Tcl_AppendResult(interp, argv[1], ":  already exists\n", (char *)NULL);
	  return TCL_ERROR;
	}


	/* read the known point */
	promp = &p_rfin[0];
	if( argc < 5 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, promp[argc-2], (char *)NULL);
	  return TCL_ERROR;
	}

	if ( argc < 6 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter ROTATION angle (deg): ", (char *)NULL);
	  return TCL_ERROR;
	}

	rota = atof( argv[5] ) * degtorad;

	if ( argc < 7 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter FALL BACK angle (deg): ", (char *)NULL);
	  return TCL_ERROR;
	}

	fba = atof( argv[6] ) * degtorad;

	/* calculate plane defined by these angles */
	norm[0] = cos(fba) * cos(rota);
	norm[1] = cos(fba) * sin(rota);
	norm[2] = sin(fba);

	for(i=0; i<3; i++) {
	  if( argc < 8+3*i ) {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "POINT %d...\n",i+2);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), MORE_ARGS_STR,
			     "Enter coordinate to solve for (x, y, or z): ", (char *)NULL);
	    return TCL_ERROR;
	  }

	  switch( argv[7+3*i][0] ) {
		case 'x':
			if(norm[0] == 0.0) {
			  Tcl_AppendResult(interp, "X not unique in this face\n", (char *)NULL);
			  return TCL_ERROR;
			}
			solve[i] = X;

			if( argc < 7+3*i+2 ) {
			  Tcl_AppendResult(interp, MORE_ARGS_STR,
					   "Enter the Y, Z coordinate values: ", (char *)NULL);
			  return TCL_ERROR;
			}
			if( argc < 7+3*i+3 ) {
			  Tcl_AppendResult(interp, MORE_ARGS_STR,
					   "Enter the Z coordinate value: ", (char *)NULL);
			  return TCL_ERROR;
			}
			pt[i][0] = atof( argv[7+3*i+1] ) * local2base;
			pt[i][1] = atof( argv[7+3*i+2] ) * local2base;
			break;

		case 'y':
			if(norm[1] == 0.0) {
			  Tcl_AppendResult(interp, "Y not unique in this face\n", (char *)NULL);
			  return TCL_ERROR;
			}
			solve[i] = Y;

			if( argc < 7+3*i+2 ) {
			  Tcl_AppendResult(interp, MORE_ARGS_STR,
					   "Enter the X, Z coordinate values: ", (char *)NULL);
			  return TCL_ERROR;
			}
			if( argc < 7+3*i+3 ) {
			  Tcl_AppendResult(interp, MORE_ARGS_STR,
					   "Enter the Z coordinate value: ", (char *)NULL);
			  return TCL_ERROR;
			}
			pt[i][0] = atof( argv[7+3*i+1] ) * local2base;
			pt[i][1] = atof( argv[7+3*i+2] ) * local2base;
			break;

		case 'z':
			if(norm[2] == 0.0) {
			  Tcl_AppendResult(interp, "Z not unique in this face\n", (char *)NULL);
			  return TCL_ERROR;
			}
			solve[i] = Z;

			if( argc < 7+3*i+2 ) {
			  Tcl_AppendResult(interp, MORE_ARGS_STR,
					   "Enter the X, Y coordinate values: ", (char *)NULL);
			  return TCL_ERROR;
			}
			if( argc < 7+3*i+3 ) {
			  Tcl_AppendResult(interp, MORE_ARGS_STR,
					   "Enter the Y coordinate value: ", (char *)NULL);
			  return TCL_ERROR;
			}
			pt[i][0] = atof( argv[7+3*i+1] ) * local2base;
			pt[i][1] = atof( argv[7+3*i+2] ) * local2base;
			break;

		default:
		  Tcl_AppendResult(interp, "coordinate must be x, y, or z\n", (char *)NULL);
		  return TCL_ERROR;
		}
	}

	if( argc < 8+3*3 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   "Enter thickness for this arb: ", (char *)NULL);
	  return TCL_ERROR;
	}
	if( (thick = (atof( argv[7+3*3] ))) == 0.0 ) {
	  Tcl_AppendResult(interp, "thickness = 0.0\n", (char *)NULL);
	  return TCL_ERROR;
	}
	thick *= local2base;

	RT_INIT_DB_INTERNAL( &internal );
	internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	internal.idb_type = ID_ARB8;
	internal.idb_meth = &rt_functab[ID_ARB8];
	internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
	aip = (struct rt_arb_internal *)internal.idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;

	for(i=0; i<8; i++) {
		VSET( aip->pt[i] , 0.0 , 0.0 , 0.0 );
	}

	VSET( aip->pt[0] , atof(argv[2])*local2base , atof(argv[3])*local2base , atof(argv[4])*local2base );

	ndotv = VDOT( aip->pt[0], norm );

	/* calculate the unknown coordinate for points 2,3,4 */
	for(i=0; i<3; i++) {
		int j;
		j = i+1;

		switch( solve[i] ) {
			case X:
				aip->pt[j][Y] = pt[i][0];
				aip->pt[j][Z] = pt[i][1];
				aip->pt[j][X] = ( ndotv
					- norm[1] * aip->pt[j][Y]
					- norm[2] * aip->pt[j][Z])
					/ norm[0];
			break;
			case Y:
				aip->pt[j][X] = pt[i][0];
				aip->pt[j][Z] = pt[i][1];
				aip->pt[j][Y] = ( ndotv
					- norm[0] * aip->pt[j][X]
					- norm[2] * aip->pt[j][Z])
					/ norm[1];
			break;
			case Z:
				aip->pt[j][X] = pt[i][0];
				aip->pt[j][Y] = pt[i][1];
				aip->pt[j][Z] = ( ndotv
					- norm[0] * aip->pt[j][X]
					- norm[1] * aip->pt[j][Y])
					/ norm[2];
			break;

			default:
			  return TCL_ERROR;
		}
	}

	/* calculate the remaining 4 vertices */
	for(i=0; i<4; i++) {
		VJOIN1( aip->pt[i+4] , aip->pt[i] , thick , norm );
	}

	/* no interuprts */
	(void)signal( SIGINT, SIG_IGN );

	if( (dp = db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&internal.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to the directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &internal, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}

	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = argv[1]; /* depends on solid name being in argv[1] */
	  av[2] = NULL;

	  /* draw the "made" solid */
	  return cmd_draw( clientData, interp, 2, av );
	}
}

/* ------------------------------ new way ------------------------------ */
/*  rt_arb_get_cgtype(), rt_arb_std_type(), and rt_arb_centroid()
 *  moved to librt/g_arb.c
 */
@


11.36
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/arbs.c,v 11.35 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.35
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.34
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.33 2002/08/20 17:08:21 jra Exp $ (BRL)";
d71 1
a71 5
f_3ptarb( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d319 1
a319 5
f_rfarb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.33
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1986 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.31 2001/10/02 19:24:31 jra Exp $ (BRL)";
@


11.33.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/arbs.c,v 11.34 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.33.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.34 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.33.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.33.10.1 2004/02/12 18:34:12 erikg Exp $ (BRL)";
@


11.33.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.33 2002/08/20 17:08:21 jra Exp $ (BRL)";
d71 5
a75 1
f_3ptarb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d323 5
a327 1
f_rfarb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.33.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.32
log
@Converted from K&R to ANSI C - RFH
@
text
@d71 5
a75 1
f_3ptarb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d323 5
a327 1
f_rfarb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.31
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.30 2001/06/01 19:23:22 bparker Exp $ (BRL)";
d71 1
a71 5
f_3ptarb( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d319 1
a319 5
f_rfarb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.30
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.29 2001/03/23 22:05:31 jra Exp $ (BRL)";
d221 1
d482 1
@


11.29
log
@Support for major and minor types in directory structure
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/arbs.c,v 11.28 2001/01/09 15:56:17 jra Exp $ (BRL)";
d45 1
d302 1
a302 1
	  return f_edit( clientData, interp, 2, av );
d559 1
a559 1
	  return f_edit( clientData, interp, 2, av );
@


11.28
log
@Eliminated name length constraints
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.27 2000/10/24 15:17:48 mike Exp $ (BRL)";
d281 1
a281 1
	if( (dp = db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
d538 1
a538 1
	if( (dp = db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
@


11.27
log
@
lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.26 2000/09/08 05:55:47 mike Exp $ (BRL)";
a81 1
	char			name[NAMESIZE+2];
a109 13
	if( (int)strlen(argv[1]) >= NAMESIZE ) {
	  struct bu_vls tmp_str;

	  bu_vls_init(&tmp_str);
	  bu_vls_printf(&tmp_str, "Names are limited to %d characters\n",
			NAMESIZE-1);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_str), (char *)NULL);
	  bu_vls_free(&tmp_str);

	  return TCL_ERROR;
	}
	strcpy( name , argv[1] );

d281 1
a281 1
	if( (dp = db_diradd( dbip, name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
d283 1
a283 1
		Tcl_AppendResult(interp, "Cannot add ", name, " to the directory\n", (char *)NULL );
a329 1
	char			name[NAMESIZE+2];
a359 10
	if( (int)strlen(argv[1]) >= NAMESIZE ) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "Names are limited to %d charscters\n",NAMESIZE-1);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  return TCL_ERROR;
	}
	strcpy( name , argv[1] );
d538 1
a538 1
	if( (dp = db_diradd( dbip, name, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
d540 1
a540 1
		Tcl_AppendResult(interp, "Cannot add ", name, " to the directory\n", (char *)NULL );
@


11.26
log
@
Tree routines now need resource structure.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.25 2000/08/19 03:10:40 mike Exp $ (BRL)";
a47 2

static int	cgarbs();
@


11.25
log
@
const RCSid
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.24 1999/12/29 23:23:17 mike Exp $ (BRL)";
d303 1
a303 1
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )
d305 1
a305 1
		rt_db_free_internal( &internal );
d571 1
a571 1
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )
d573 1
a573 1
		rt_db_free_internal( &internal );
@


11.24
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.23 1999/11/24 14:26:41 jra Exp $ (BRL)";
@


11.23
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.22 1999/09/01 18:55:08 bparker Exp $ (BRL)";
d297 1
a297 1
	if( (dp = db_diradd( dbip, name, -1L, 0, DIR_SOLID)) == DIR_NULL )
d565 1
a565 1
	if( (dp = db_diradd( dbip, name, -1L, 0, DIR_SOLID)) == DIR_NULL )
@


11.22
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/arbs.c,v 11.21 1997/07/01 22:09:08 bparker Exp $ (BRL)";
d237 1
d508 1
@


11.21
log
@mods to run without a database
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.20 1997/06/19 22:32:04 jra Exp bparker $ (BRL)";
d89 1
a89 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d353 1
a353 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

@


11.20
log
@Moved rt_arb_get_cgtype(), rt_arb_std_type(), and rt_arb_centroid() to librt/g_arb.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.19 1997/05/20 23:05:08 mike Exp jra $ (BRL)";
d89 3
d354 3
@


11.19
log
@externs.h before raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.18 1997/04/24 18:03:58 bparker Exp mike $ (BRL)";
d586 2
a587 193
/* XXX This should move to librt/g_arb.c at some point */

#define NO	0
#define YES	1
	
/*
 *			R T _ A R B _ G E T _ C G T Y P E
 *
 * C G A R B S :   determines COMGEOM arb types from GED general arbs
 *
 *  Inputs -
 *
 *  Returns -
 *	#	Number of distinct edge vectors
 *		(Number of entries in uvec array)
 *
 *  Implicit returns -
 *	*cgtype		Comgeom type (number range 4..8;  ARB4 .. ARB8).
 *	uvec[8]
 *	svec[11]
 *			Entries [0] and [1] are special
 */
int
rt_arb_get_cgtype( cgtype, arb, tol, uvec, svec )
int			*cgtype;
struct rt_arb_internal	*arb;
CONST struct bn_tol	*tol;
register int *uvec;	/* array of unique points */
register int *svec;	/* array of like points */
{
	register int i,j;
	int	numuvec, unique, done;
	int	si;

	RT_ARB_CK_MAGIC(arb);
	BN_CK_TOL(tol);

	done = NO;		/* done checking for like vectors */

	svec[0] = svec[1] = 0;
	si = 2;

	for(i=0; i<7; i++) {
		unique = YES;
		if(done == NO)
			svec[si] = i;
		for(j=i+1; j<8; j++) {
			int tmp;
			vect_t vtmp;

			VSUB2( vtmp, arb->pt[i], arb->pt[j] );

			if( fabs(vtmp[0]) > tol->dist) tmp = 0;
			else 	if( fabs(vtmp[1]) > tol->dist) tmp = 0;
			else 	if( fabs(vtmp[2]) > tol->dist) tmp = 0;
			else tmp = 1;

			if( tmp ) {
				if( done == NO )
					svec[++si] = j;
				unique = NO;
			}
		}
		if( unique == NO ) {  	/* point i not unique */
			if( si > 2 && si < 6 ) {
				svec[0] = si - 1;
				if(si == 5 && svec[5] >= 6)
					done = YES;
				si = 6;
			}
			if( si > 6 ) {
				svec[1] = si - 5;
				done = YES;
			}
		}
	}

	if( si > 2 && si < 6 ) 
		svec[0] = si - 1;
	if( si > 6 )
		svec[1] = si - 5;
	for(i=1; i<=svec[1]; i++)
		svec[svec[0]+1+i] = svec[5+i];
	for(i=svec[0]+svec[1]+2; i<11; i++)
		svec[i] = -1;

	/* find the unique points */
	numuvec = 0;
	for(j=0; j<8; j++) {
		unique = YES;
		for(i=2; i<svec[0]+svec[1]+2; i++) {
			if( j == svec[i] ) {
				unique = NO;
				break;
			}
		}
		if( unique == YES )
			uvec[numuvec++] = j;
	}

	/* Figure out what kind of ARB this is */
	switch( numuvec ) {

	case 8:
		*cgtype = ARB8;		/* ARB8 */
		break;

	case 6:
		*cgtype = ARB7;		/* ARB7 */
		break;

	case 4:
		if(svec[0] == 2)
			*cgtype = ARB6;	/* ARB6 */
		else
			*cgtype = ARB5;	/* ARB5 */
		break;

	case 2:
		*cgtype = ARB4;		/* ARB4 */
		break;

	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "rt_arb_get_cgtype: bad number of unique vectors (%d)\n",
			  numuvec);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }

	  return(0);
	}
#if 0
	bu_log("uvec: ");
	for(j=0; j<8; j++) bu_log("%d, ", uvec[j]);
	bu_log("\nsvec: ");
	for(j=0; j<11; j++ ) bu_log("%d, ", svec[j]);
	bu_log("\n");
#endif
	return( numuvec );
}

/*
 *			R T _ A R B _ S T D _ T Y P E
 *
 *  Given an ARB in internal form, return it's specific ARB type.
 *
 *  Set tol.dist = 0.0001 to obtain past behavior.
 *
 *  Returns -
 *	0	Error in input ARB
 *	4	ARB4
 *	5	ARB5
 *	6	ARB6
 *	7	ARB7
 *	8	ARB8
 *
 *  Implicit return -
 *	rt_arb_internal pt[] array reorganized into GIFT "standard" order.
 */
int
rt_arb_std_type( ip, tol )
struct rt_db_internal	*ip;
CONST struct bn_tol	*tol;
{
	struct rt_arb_internal	*arb;
	int uvec[8], svec[11];
	int	cgtype = 0;

	RT_CK_DB_INTERNAL(ip);
	BN_CK_TOL(tol);

	if( ip->idb_type != ID_ARB8 )  bu_bomb("rt_arb_std_type: not ARB!\n");

	arb = (struct rt_arb_internal *)ip->idb_ptr;
	RT_ARB_CK_MAGIC(arb);

	if( rt_arb_get_cgtype( &cgtype, arb, tol, uvec, svec ) == 0 )
		return(0);

	return( cgtype );
}


/* 
 *			R T _ A R B _ C E N T R O I D
 *
 * Find the center point for the arb whose values are in the s array,
 * with the given number of verticies.  Return the point in center_pt.
 * WARNING: The s array is dbfloat_t's not fastf_t's.
a588 20
void
rt_arb_centroid( center_pt, arb, npoints )
point_t			center_pt;
struct rt_arb_internal	*arb;
int			npoints;
{
	register int	j;
	fastf_t		div;
	point_t		sum;

	RT_ARB_CK_MAGIC(arb);

	VSETALL(sum, 0);

	for( j=0; j < npoints; j++ )  {
		VADD2( sum, sum, arb->pt[j] );
	}
	div = 1.0 / npoints;
	VSCALE( center_pt, sum, div );
}
@


11.18
log
@modify calls to Tcl_Eval
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.17 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d38 1
a42 1
#include "externs.h"
@


11.17
log
@mods so that commands check args internally
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.16 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d92 6
a97 1
	  Tcl_Eval(interp, "help 3ptarb");
d355 6
a360 1
	  Tcl_Eval(interp, "help rfarb");
@


11.16
log
@Mods to support MGED's read-only mode.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.15 1997/03/24 18:25:37 jra Exp jra $ (BRL)";
d91 2
a92 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d94 1
d349 2
a350 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d352 1
@


11.15
log
@added check for read-only db.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.14 1997/03/12 20:45:46 jra Exp jra $ (BRL)";
d89 1
a90 6
	if( dbip->dbi_read_only )
	{
		TCL_READ_ONLY;
		return TCL_ERROR;
	}

d345 1
a345 5
	if( dbip->dbi_read_only )
	{
		TCL_READ_ONLY;
		return TCL_ERROR;
	}
@


11.14
log
@removed dependencies on db.h.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.13 1997/02/25 14:19:54 jra Exp jra $ (BRL)";
d89 7
d349 6
@


11.13
log
@Completed conversion to combination import/export.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.12 1997/01/02 19:35:05 bparker Exp jra $ (BRL)";
a39 1
#include "db.h"
@


11.12
log
@mods to use libbn and libbu
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.11 1996/09/23 18:40:01 bparker Exp bparker $ (BRL)";
a79 1
	int			ngran;
a87 1
	struct bu_external	external;
d287 1
a287 2
	/* Don't use local2base here, coordinates are already converted to mm above */
	if( rt_functab[internal.idb_type].ft_export( &external, &internal, (double)1.0 ) < 0 )
d289 2
a290 14
	  Tcl_AppendResult(interp, "f_3ptarb: export failure\n", (char *)NULL);
	  rt_functab[internal.idb_type].ft_ifree( &internal );
	  return TCL_ERROR;
	}
	rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */

	/* no interuprts */
	(void)signal( SIGINT, SIG_IGN );

	ngran = (external.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
	if( (dp = db_diradd( dbip, name, -1L, ngran, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 ) {
	    	db_free_external( &external );
	    	TCL_ALLOC_ERR_return;
d293 1
a293 1
	if (db_put_external( &external, dp, dbip ) < 0 ) 
d295 1
a295 1
		db_free_external( &external );
a297 1
	db_free_external( &external );
a335 1
	int			ngran;
a341 1
	struct bu_external	external;
a540 8
	if( rt_functab[internal.idb_type].ft_export( &external, &internal, local2base ) < 0 )
	{
	  Tcl_AppendResult(interp, "f_3ptarb: export failure\n", (char *)NULL);
	  rt_functab[internal.idb_type].ft_ifree( &internal );
	  return TCL_ERROR;
	}
	rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */

d544 5
a548 7
	ngran = (external.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
	if( (dp = db_diradd( dbip, name, -1L, ngran, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )
	    {
	    	db_free_external( &external );
	    	TCL_ALLOC_ERR_return;
	    }
d550 1
a550 1
	if (db_put_external( &external, dp, dbip ) < 0 )
d552 1
a552 1
		db_free_external( &external );
a554 1
	db_free_external( &external );
a564 161
	}
}

/* ------------------------------ old way ------------------------------ */

static void	points();

static union record input;		/* Holds an object file record */

/* TYPE_ARB()	returns specific ARB type of record rec.  The record rec
 *		is also rearranged to "standard" form.
 */
type_arb( rec )
union record *rec;
{
	int i;
	static int uvec[8], svec[11];

	if( rec->s.s_type != GENARB8 )
		return( 0 );

	input = *rec;		/* copy */

	/* convert input record to points */
	points();

	if( cgarbs(uvec, svec) == 0 )
		return(0);

	/* convert to vectors in the rec record */
	VMOVE(&rec->s.s_values[0], &input.s.s_values[0]);
	for(i=3; i<=21; i+=3) {
		VSUB2(&rec->s.s_values[i], &input.s.s_values[i], &input.s.s_values[0]);
	}

	return( input.s.s_cgtype );

}

#define NO	0
#define YES	1
	
/*
 * C G A R B S :   determines COMGEOM arb types from GED general arbs
 */
static int
cgarbs( uvec, svec )
register int *uvec;	/* array of unique points */
register int *svec;	/* array of like points */
{
	register int i,j;
	static int numuvec, unique, done;
	static int si;

	done = NO;		/* done checking for like vectors */

	svec[0] = svec[1] = 0;
	si = 2;

	for(i=0; i<7; i++) {
		unique = YES;
		if(done == NO)
			svec[si] = i;
		for(j=i+1; j<8; j++) {
			int tmp;
			vect_t vtmp;

			VSUB2( vtmp, &input.s.s_values[i*3], &input.s.s_values[j*3] );

			if( fabs(vtmp[0]) > 0.0001) tmp = 0;
			else 	if( fabs(vtmp[1]) > 0.0001) tmp = 0;
			else 	if( fabs(vtmp[2]) > 0.0001) tmp = 0;
			else tmp = 1;

			if( tmp ) {
				if( done == NO )
					svec[++si] = j;
				unique = NO;
			}
		}
		if( unique == NO ) {  	/* point i not unique */
			if( si > 2 && si < 6 ) {
				svec[0] = si - 1;
				if(si == 5 && svec[5] >= 6)
					done = YES;
				si = 6;
			}
			if( si > 6 ) {
				svec[1] = si - 5;
				done = YES;
			}
		}
	}

	if( si > 2 && si < 6 ) 
		svec[0] = si - 1;
	if( si > 6 )
		svec[1] = si - 5;
	for(i=1; i<=svec[1]; i++)
		svec[svec[0]+1+i] = svec[5+i];
	for(i=svec[0]+svec[1]+2; i<11; i++)
		svec[i] = -1;
	/* find the unique points */
	numuvec = 0;
	for(j=0; j<8; j++) {
		unique = YES;
		for(i=2; i<svec[0]+svec[1]+2; i++) {
			if( j == svec[i] ) {
				unique = NO;
				break;
			}
		}
		if( unique == YES )
			uvec[numuvec++] = j;
	}

	/* put comgeom solid typpe into s_cgtype */
	switch( numuvec ) {

	case 8:
		input.s.s_cgtype = ARB8;  /* ARB8 */
		break;

	case 6:
		input.s.s_cgtype = ARB7;	/* ARB7 */
		break;

	case 4:
		if(svec[0] == 2)
			input.s.s_cgtype = ARB6;	/* ARB6 */
		else
			input.s.s_cgtype = ARB5;	/* ARB5 */
		break;

	case 2:
		input.s.s_cgtype = ARB4;	/* ARB4 */
		break;

	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "solid: %s  bad number of unique vectors (%d)\n",
			  input.s.s_name, numuvec);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }

	  return(0);
	}
	return( numuvec );
}

static void
points()
{
	register int i;

	for(i=3; i<=21; i+=3) {
		VADD2(&input.s.s_values[i],&input.s.s_values[i],&input.s.s_values[0]);
@


11.11
log
@changed dm.h to mged_dm.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.10 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d89 1
a89 1
	struct rt_external	external;
d359 1
a359 1
	struct rt_external	external;
d785 1
a785 1
CONST struct rt_tol	*tol;
d794 1
a794 1
	RT_CK_TOL(tol);
d925 1
a925 1
CONST struct rt_tol	*tol;
d932 1
a932 1
	RT_CK_TOL(tol);
@


11.10
log
@rt_list ---> bu_list
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.9 1996/09/03 17:41:27 bparker Exp bparker $ (BRL)";
d45 1
a45 1
#include "./dm.h"
@


11.9
log
@Check in Lee's changes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.8 1996/08/28 15:08:31 bparker Exp butler $ (BRL)";
d38 1
a39 1
#include "bu.h"
a40 1
#include "rtlist.h"
@


11.8
log
@more conversions to libbu
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.7 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d39 1
@


11.7
log
@now using libbu
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.6 1996/07/15 20:33:09 bparker Exp bparker $ (BRL)";
d934 1
a934 1
	if( ip->idb_type != ID_ARB8 )  rt_bomb("rt_arb_std_type: not ARB!\n");
@


11.6
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.5 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d107 1
a107 1
	  struct rt_vls tmp_str;
d109 2
a110 2
	  rt_vls_init(&tmp_str);
	  rt_vls_printf(&tmp_str, "Names are limited to %d characters\n",
d112 2
a113 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_str), (char *)NULL);
	  rt_vls_free(&tmp_str);
d230 1
a230 1
	internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
d376 1
a376 1
	  struct rt_vls tmp_vls;
d378 4
a381 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "Names are limited to %d charscters\n",NAMESIZE-1);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d414 1
a414 1
	    struct rt_vls tmp_vls;
d416 3
a418 3
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "POINT %d...\n",i+2);
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), MORE_ARGS_STR,
d506 1
a506 1
	internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
d734 1
a734 1
	    struct rt_vls tmp_vls;
d736 2
a737 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "solid: %s  bad number of unique vectors (%d)\n",
d739 2
a740 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d883 1
a883 1
	    struct rt_vls tmp_vls;
d885 2
a886 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "rt_arb_get_cgtype: bad number of unique vectors (%d)\n",
d888 2
a889 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d895 5
a899 5
	rt_log("uvec: ");
	for(j=0; j<8; j++) rt_log("%d, ", uvec[j]);
	rt_log("\nsvec: ");
	for(j=0; j<11; j++ ) rt_log("%d, ", svec[j]);
	rt_log("\n");
@


11.5
log
@Still Tcl'ing the code
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.4 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d316 1
a316 1
	  char *av[] = {"e", NULL, NULL};
d318 1
d320 1
d586 1
a586 1
	  char *av[] = {"e", NULL, NULL};
d588 1
d590 1
@


11.4
log
@still tcl-converting
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.3 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
a94 3
	/* interupts */
	(void)signal( SIGINT, sig2 );

a361 3

	/* interupts */
	(void)signal( SIGINT, sig2 );
@


11.3
log
@convert commands to Tcl
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.2 1995/02/18 03:08:41 mike Exp bparker $ (BRL)";
d318 8
a325 2
	/* draw the "made" solid */
	return f_edit( clientData, interp, 2, argv ); /* depends on solid name being in argv[1] */
d589 8
a596 2
	/* draw the "made" solid */
	return f_edit( clientData, interp, 2, argv );	/* depends on solid name being in argv[1] */
@


11.2
log
@Eliminated local setting of "rt_tol" structures.
Everything now uses the global mged_tol.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 11.1 95/01/04 10:02:37 mike Rel4_4 $ (BRL)";
d73 3
a75 1
f_3ptarb( argc, argv )
d92 3
d100 2
a101 2
		rt_log("Enter name for this arb: ");
		return CMD_MORE;
d105 2
a106 2
		rt_log("%s:  already exists\n", argv[1]);
		return CMD_BAD;
d110 9
a118 2
		rt_log("Names are limited to %d charscters\n",NAMESIZE-1);
		return CMD_BAD;
d125 2
a126 2
		rt_log("%s", promp[argc-2]);
		return CMD_MORE;
d137 2
a138 2
		rt_log("points are colinear\n");
		return CMD_BAD;
d143 3
a145 2
		rt_log("Enter coordinate to solve for (x, y, or z): ");
		return CMD_MORE;
d152 2
a153 2
			rt_log("X not unique in this face\n");
			return CMD_BAD;
d158 3
a160 2
			rt_log("Enter the Y, Z coordinate values: ");
			return CMD_MORE;
d163 3
a165 2
			rt_log("Enter the Z coordinate value: ");
			return CMD_MORE;
d173 2
a174 2
			rt_log("Y not unique in this face\n");
			return CMD_BAD;
d179 3
a181 2
			rt_log("Enter the X, Z coordinate values: ");
			return CMD_MORE;
d184 3
a186 2
			rt_log("Enter the Z coordinate value: ");
			return CMD_MORE;
d195 2
a196 2
			rt_log("Z not unique in this face\n");
			return CMD_BAD;
d201 3
a203 2
			rt_log("Enter the X, Y coordinate values: ");
			return CMD_MORE;
d206 3
a208 2
			rt_log("Enter the Y coordinate value: ");
			return CMD_MORE;
d215 2
a216 2
		rt_log("coordinate must be x, y, or z\n");
		return CMD_BAD;
d221 3
a223 2
		rt_log("Enter thickness for this arb: ");
		return CMD_MORE;
d227 2
a228 2
		rt_log("thickness = 0.0\n");
		return CMD_BAD;
d283 2
a284 3
			rt_log("bad coordinate to solve for\n");
			return CMD_BAD;

d295 3
a297 3
		rt_log( "f_3ptarb: export failure\n" );
		rt_functab[internal.idb_type].ft_ifree( &internal );
		return CMD_BAD;
d308 1
a308 2
	    	ALLOC_ERR;
		return CMD_BAD;
d314 1
a314 2
		WRITE_ERR;
		return CMD_BAD;
d319 1
a319 1
	return f_edit( 2, argv ); /* depends on solid name being in argv[1] */
d338 3
a340 1
f_rfarb( argc, argv )
d357 3
d365 2
a366 2
		rt_log("Enter name for this arb: ");
		return CMD_MORE;
d369 2
a370 2
		rt_log("%s:  already exists\n", argv[1]);
		return CMD_BAD;
d374 7
a380 2
		rt_log("Names are limited to %d charscters\n",NAMESIZE-1);
		return CMD_BAD;
d387 2
a388 2
		rt_log("%s", promp[argc-2]);
		return CMD_MORE;
d392 2
a393 2
		rt_log("Enter ROTATION angle (deg): ");
		return CMD_MORE;
d399 2
a400 2
		rt_log("Enter FALL BACK angle (deg): ");
		return CMD_MORE;
d411 9
a419 5
		if( argc < 8+3*i ) {
			rt_log("POINT %d...",i+2);
			rt_log("Enter coordinate to solve for (x, y, or z): ");
			return CMD_MORE;
		}
d421 1
a421 1
		switch( argv[7+3*i][0] ) {
d424 2
a425 2
				rt_log("X not unique in this face\n");
				return CMD_BAD;
d430 3
a432 2
				rt_log("Enter the Y, Z coordinate values: ");
				return CMD_MORE;
d435 3
a437 2
				rt_log("Enter the Z coordinate value: ");
				return CMD_MORE;
d445 2
a446 2
				rt_log("Y not unique in this face\n");
				return CMD_BAD;
d451 3
a453 2
				rt_log("Enter the X, Z coordinate values: ");
				return CMD_MORE;
d456 3
a458 2
				rt_log("Enter the Z coordinate value: ");							
				return CMD_MORE;
d466 2
a467 2
				rt_log("Z not unique in this face\n");
				return CMD_BAD;
d472 3
a474 2
				rt_log("Enter the X, Y coordinate values: ");
				return CMD_MORE;
d477 3
a479 2
				rt_log("Enter the Y coordinate value: ");
				return CMD_MORE;
d486 2
a487 2
			rt_log("coordinate must be x, y, or z\n");
			return CMD_BAD;
d492 3
a494 2
		rt_log("Enter thickness for this arb: ");
		return CMD_MORE;
d497 2
a498 2
		rt_log("thickness = 0.0\n");
		return CMD_BAD;
d548 1
a548 1
				return CMD_BAD;
d559 3
a561 3
		rt_log( "f_3ptarb: export failure\n" );
		rt_functab[internal.idb_type].ft_ifree( &internal );
		return CMD_BAD;
d573 1
a573 2
	    	ALLOC_ERR;
		return CMD_BAD;
d579 1
a579 2
		WRITE_ERR;
		return CMD_BAD;
d584 1
a584 1
	return f_edit( 2, argv );	/* depends on solid name being in argv[1] */
d723 11
a733 3
		rt_log("solid: %s  bad number of unique vectors (%d)\n",
			input.s.s_name, numuvec);
		return(0);
d872 11
a882 3
		rt_log("rt_arb_get_cgtype: bad number of unique vectors (%d)\n",
			numuvec);
		return(0);
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.13 94/12/16 19:35:24 gdurf Exp $ (BRL)";
d731 1
a731 1
struct rt_tol		*tol;
d863 1
a863 1
struct rt_tol		*tol;
@


10.13
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.12 1994/12/14 16:27:44 jra Exp gdurf $ (BRL)";
@


10.12
log
@3ptarb was working in mm units but exporting with local2base.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/arbs.c,v 10.11 94/11/28 13:51:38 jra Exp Locker: jra $ (BRL)";
d95 1
a95 1
		(void)printf("Enter name for this arb: ");
d100 1
a100 1
		(void)printf("%s:  already exists\n", argv[1]);
d105 1
a105 1
		(void)printf("Names are limited to %d charscters\n",NAMESIZE-1);
d113 1
a113 1
		(void)printf("%s", promp[argc-2]);
d125 1
a125 1
		(void)printf("points are colinear\n");
d131 1
a131 1
		(void)printf("Enter coordinate to solve for (x, y, or z): ");
d139 1
a139 1
			(void)printf("X not unique in this face\n");
d145 1
a145 1
			(void)printf("Enter the Y, Z coordinate values: ");
d149 1
a149 1
			(void)printf("Enter the Z coordinate value: ");
d158 1
a158 1
			(void)printf("Y not unique in this face\n");
d164 1
a164 1
			(void)printf("Enter the X, Z coordinate values: ");
d168 1
a168 1
			(void)printf("Enter the Z coordinate value: ");
d178 1
a178 1
			(void)printf("Z not unique in this face\n");
d184 1
a184 1
			(void)printf("Enter the X, Y coordinate values: ");
d188 1
a188 1
			(void)printf("Enter the Y coordinate value: ");
d196 1
a196 1
		(void)printf("coordinate must be x, y, or z\n");
d202 1
a202 1
		(void)printf("Enter thickness for this arb: ");
d207 1
a207 1
		(void)printf("thickness = 0.0\n");
d263 1
a263 1
			(void)printf("bad coordinate to solve for\n");
d343 1
a343 1
		(void)printf("Enter name for this arb: ");
d347 1
a347 1
		(void)printf("%s:  already exists\n", argv[1]);
d352 1
a352 1
		(void)printf("Names are limited to %d charscters\n",NAMESIZE-1);
d360 1
a360 1
		(void)printf("%s", promp[argc-2]);
d365 1
a365 1
		(void)printf("Enter ROTATION angle (deg): ");
d372 1
a372 1
		(void)printf("Enter FALL BACK angle (deg): ");
d385 2
a386 2
			(void)printf("POINT %d...",i+2);
			(void)printf("Enter coordinate to solve for (x, y, or z): ");
d393 1
a393 1
				(void)printf("X not unique in this face\n");
d399 1
a399 1
				(void)printf("Enter the Y, Z coordinate values: ");
d403 1
a403 1
				(void)printf("Enter the Z coordinate value: ");
d412 1
a412 1
				(void)printf("Y not unique in this face\n");
d418 1
a418 1
				(void)printf("Enter the X, Z coordinate values: ");
d422 1
a422 1
				(void)printf("Enter the Z coordinate value: ");							
d431 1
a431 1
				(void)printf("Z not unique in this face\n");
d437 1
a437 1
				(void)printf("Enter the X, Y coordinate values: ");
d441 1
a441 1
				(void)printf("Enter the Y coordinate value: ");
d449 1
a449 1
			(void)printf("coordinate must be x, y, or z\n");
d455 1
a455 1
		(void)printf("Enter thickness for this arb: ");
d459 1
a459 1
		(void)printf("thickness = 0.0\n");
d687 1
a687 1
		(void)printf("solid: %s  bad number of unique vectors (%d)\n",
d833 5
a837 5
	printf("uvec: ");
	for(j=0; j<8; j++) printf("%d, ", uvec[j]);
	printf("\nsvec: ");
	for(j=0; j<11; j++ ) printf("%d, ", svec[j]);
	printf("\n");
@


10.11
log
@Fixed f_rfarb (argc checks were off by one).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.10 94/11/10 12:06:01 jra Exp Locker: jra $ (BRL)";
d273 2
a274 1
	if( rt_functab[internal.idb_type].ft_export( &external, &internal, local2base ) < 0 )
@


10.10
log
@Irix 6.0.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/arbs.c,v 10.9 1994/08/09 14:36:05 gdurf Exp jra $ (BRL)";
d397 1
a397 1
			if( argc < 7+3*i+1 ) {
d401 1
a401 1
			if( argc < 7+3*i+2 ) {
d416 1
a416 1
			if( argc < 7+3*i+1 ) {
d420 1
a420 1
			if( argc < 7+3*i+2 ) {
d435 1
a435 1
			if( argc < 7+3*i+1 ) {
d439 1
a439 1
			if( argc < 7+3*i+2 ) {
@


10.9
log
@Factored ifdefs
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.8 1994/06/03 17:21:10 gdurf Exp gdurf $ (BRL)";
a88 1
	struct rt_arb_internal	ai;
a129 2
coordin:  	/* sent here to input coordinate to find again */

a200 2
thickagain:

a382 1
coordagain:	/* sent here to redo a point */
a452 2
thckagain:

a841 25
 *			R T _ A R B _ P T M O V E
 *
 *  Note:  arbo and arbi must not point to same structure!
 */
static void
rt_arb_ptmove( arbo, arbi, p0, p1, p2, p3, p4, p5, p6, p7 )
struct rt_arb_internal	*arbo;
struct rt_arb_internal	*arbi;
int			p0, p1, p2, p3, p4, p5, p6, p7;
{

	RT_ARB_CK_MAGIC( arbo );
	RT_ARB_CK_MAGIC( arbi );

	VMOVE( arbo->pt[0], arbi->pt[p0] );
	VMOVE( arbo->pt[1], arbi->pt[p1] );
	VMOVE( arbo->pt[2], arbi->pt[p2] );
	VMOVE( arbo->pt[3], arbi->pt[p3] );
	VMOVE( arbo->pt[4], arbi->pt[p4] );
	VMOVE( arbo->pt[5], arbi->pt[p5] );
	VMOVE( arbo->pt[6], arbi->pt[p6] );
	VMOVE( arbo->pt[7], arbi->pt[p7] );
}

/*
a864 1
	int i;
a865 1
	int	nedge;
d876 1
a876 1
	if( (nedge = rt_arb_get_cgtype( &cgtype, arb, tol, uvec, svec )) == 0 )
@


10.8
log
@modified functions requiring input to use CMD_MORE
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.7 1994/01/26 13:08:37 pjt Exp gdurf $ (BRL)";
d26 2
d30 3
a32 1
#ifdef BSD
a33 2
#else
#include <string.h>
@


10.7
log
@Removed functions redoarb(), rt_arb_redo(), move(), and vectors()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.6 94/01/24 16:18:16 pjt Exp Locker: pjt $ (BRL)";
a44 2
extern int 	numargs;
extern char	*cmd_args[];
a45 2
extern int	args;
extern int	argcnt;
d70 1
a70 1
void
d87 1
a88 9
	RT_INIT_DB_INTERNAL( &internal );
	internal.idb_type = ID_ARB8;
	internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
	aip = (struct rt_arb_internal *)internal.idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;

	args = numargs;
	argcnt = 0;

a91 4
	for(i=0; i<8; i++) {
		VSET( aip->pt[i] , 0.0 , 0.0 , 0.0 );
	}

d93 1
a93 1
	while( args < 2 ) {
d95 1
a95 2
		argcnt = getcmd(args);
		args += argcnt;
d97 4
a100 3
	if( db_lookup( dbip, cmd_args[1], LOOKUP_QUIET) != DIR_NULL ) {
		(void)printf("%s:  already exists\n",cmd_args[1]);
		return;
d103 1
a103 1
	if( (int)strlen(cmd_args[1]) >= NAMESIZE ) {
d105 1
a105 1
		return;
d107 1
a107 1
	strcpy( name , cmd_args[1] );
d111 3
a113 5
	while( args < 11 ) {
		(void)printf("%s", promp[args-2]);
		if( (argcnt = getcmd(args)) < 0 )
			return;
		args += argcnt;
d118 2
a119 2
		vec1[i] = atof(cmd_args[(i+2)]) - atof(cmd_args[(i+5)]);
		vec2[i] = atof(cmd_args[(i+2)]) - atof(cmd_args[(i+8)]);
d125 1
a125 1
		return;
d129 5
a133 3
	for(i=0; i<3; i++) {
		/* the three given vertices */
		VSET( aip->pt[i] , atof( cmd_args[i*3+2] )*local2base , atof( cmd_args[i*3+3] )*local2base , atof( cmd_args[i*3+4] )*local2base );
d136 1
a136 1
coordin:  	/* sent here to input coordinate to find again */
d138 6
a143 3
	(void)printf("Enter coordinate to solve for (x, y, or z): ");
	argcnt = getcmd(args);
	switch( *cmd_args[args] ) {
d145 1
a145 8
		case 'x':
			if(norm[0] == 0.0) {
				(void)printf("X not unique in this face\n");
				args += argcnt;
				goto coordin;
			}
			solve = X;
			args += argcnt;
d147 8
a154 10
			argcnt = getcmd(args);
			pt4[0] = atof( cmd_args[args] ) * local2base;
			pt4[1] = atof( cmd_args[args+1] ) * local2base;
			args += argcnt;
			if( argcnt == 1 ) {
				(void)printf("Enter the Z coordinate value: ");
				argcnt = getcmd(args);
				pt4[1] = atof( cmd_args[args] ) * local2base;
				args += argcnt;
			}
d157 8
a164 8
		case 'y':
			if(norm[1] == 0.0) {
				(void)printf("Y not unique in this face\n");
				args += argcnt;
				goto coordin;
			}
			solve = Y;
			args += argcnt;
d166 9
a174 10
			argcnt = getcmd(args);
			pt4[0] = atof( cmd_args[args] ) * local2base;
			pt4[1] = atof( cmd_args[args+1] ) * local2base;
			args += argcnt;
			if( argcnt == 1 ) {
				(void)printf("Enter the Z coordinate value: ");
				argcnt = getcmd(args);
				pt4[1] = atof( cmd_args[args] ) * local2base;
				args += argcnt;
			}
d177 8
a184 8
		case 'z':
			if(norm[2] == 0.0) {
				(void)printf("Z not unique in this face\n");
				args += argcnt;
				goto coordin;
			}
			solve = Z;
			args += argcnt;
d186 8
a193 10
			argcnt = getcmd(args);
			pt4[0] = atof( cmd_args[args] ) * local2base;
			pt4[1] = atof( cmd_args[args+1] ) * local2base;
			args += argcnt;
			if( argcnt == 1 ) {
				(void)printf("Enter the Y coordinate value: ");
				argcnt = getcmd(args);
				pt4[1] = atof( cmd_args[args] ) * local2base;
				args += argcnt;
			}
d196 3
a198 4
		default:
			(void)printf("coordinate must be x, y, or z\n");
			args += argcnt;
			goto coordin;
d203 7
a209 3
	(void)printf("Enter thickness for this arb: ");
	argcnt = getcmd(args);
	if( (thick = (atof( cmd_args[args] ))) == 0.0 ) {
d211 16
a226 2
		args += argcnt;
		goto thickagain;
d228 1
a228 1
	args += argcnt;
d267 1
a267 1
			return;
d280 1
a280 1
		return;
d289 1
a289 2
	    db_alloc( dbip, dp, 1 ) < 0 )
	    {
d291 3
a293 2
	    	ALLOC_ERR_return;
	    }
d295 1
a295 1
	if (db_put_external( &external, dp, dbip ) < 0 )
d298 2
a299 1
		WRITE_ERR_return;
d304 1
a304 1
	f_edit( 2, cmd_args );	/* depends on solid name being in cmd_args[1] */
d322 1
a322 1
void
a339 6
	RT_INIT_DB_INTERNAL( &internal );
	internal.idb_type = ID_ARB8;
	internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
	aip = (struct rt_arb_internal *)internal.idb_ptr;
	aip->magic = RT_ARB_INTERNAL_MAGIC;

a342 7
	args = numargs;
	argcnt = 0;

	for(i=0; i<8; i++) {
		VSET( aip->pt[i] , 0.0 , 0.0 , 0.0 );
	}

d344 1
a344 1
	while( args < 2 ) {
d346 1
a346 2
		argcnt = getcmd(args);
		args += argcnt;
d348 3
a350 3
	if( db_lookup( dbip, cmd_args[1], LOOKUP_QUIET) != DIR_NULL ) {
		(void)printf("%s:  already exists\n",cmd_args[1]);
		return;
d353 1
a353 1
	if( (int)strlen(cmd_args[1]) >= NAMESIZE ) {
d355 1
a355 1
		return;
d357 1
a357 1
	strcpy( name , cmd_args[1] );
d361 18
a378 17
	while( args < 5 ) {
		(void)printf("%s", promp[args-2]);
		if( (argcnt = getcmd(args)) < 0 )
			return;
		args += argcnt;
	}

	VSET( aip->pt[0] , atof(cmd_args[2])*local2base , atof(cmd_args[3])*local2base , atof(cmd_args[4])*local2base );

	(void)printf("Enter ROTATION angle (deg): ");
	argcnt = getcmd(args);
	rota = atof( cmd_args[args] ) * degtorad;
	args += argcnt;
	(void)printf("Enter FALL BACK angle (deg): ");
	argcnt = getcmd(args);
	fba = atof( cmd_args[args] ) * degtorad;
	args += argcnt;
d387 13
a399 4
		(void)printf("POINT %d...",i+2);
		(void)printf("Enter coordinate to solve for (x, y, or z): ");
		argcnt = getcmd(args);
		switch( *cmd_args[args] ) {
d401 1
a401 8
			case 'x':
				if(norm[0] == 0.0) {
					(void)printf("X not unique in this face\n");
					args += argcnt;
					goto coordagain;
				}
				solve[i] = X;
				args += argcnt;
d403 8
a410 10
				argcnt = getcmd(args);
				pt[i][0] = atof( cmd_args[args] ) * local2base;
				pt[i][1] = atof( cmd_args[args+1] ) * local2base;
				args += argcnt;
				if( argcnt == 1 ) {
					(void)printf("Enter the Z coordinate value: ");
					argcnt = getcmd(args);
					pt[i][1] = atof( cmd_args[args] ) * local2base;
					args += argcnt;
				}
d413 8
a420 8
			case 'y':
				if(norm[1] == 0.0) {
					(void)printf("Y not unique in this face\n");
					args += argcnt;
					goto coordagain;
				}
				solve[i] = Y;
				args += argcnt;
d422 8
a429 10
				argcnt = getcmd(args);
				pt[i][0] = atof( cmd_args[args] ) * local2base;
				pt[i][1] = atof( cmd_args[args+1] ) * local2base;
				args += argcnt;
				if( argcnt == 1 ) {
					(void)printf("Enter the Z coordinate value: ");
					argcnt = getcmd(args);
					pt[i][1] = atof( cmd_args[args] ) * local2base;
					args += argcnt;
				}
d432 8
a439 8
			case 'z':
				if(norm[2] == 0.0) {
					(void)printf("Z not unique in this face\n");
					args += argcnt;
					goto coordagain;
				}
				solve[i] = Z;
				args += argcnt;
d441 8
a448 10
				argcnt = getcmd(args);
				pt[i][0] = atof( cmd_args[args] ) * local2base;
				pt[i][1] = atof( cmd_args[args+1] ) * local2base;
				args += argcnt;
				if( argcnt == 1 ) {
					(void)printf("Enter the Y coordinate value: ");
					argcnt = getcmd(args);
					pt[i][1] = atof( cmd_args[args] ) * local2base;
					args += argcnt;
				}
d451 3
a453 4
			default:
				(void)printf("coordinate must be x, y, or z\n");
				args += argcnt;
				goto coordagain;
d458 6
a463 3
	(void)printf("Enter thickness for this arb: ");
	argcnt = getcmd(args);
	if( (thick = (atof( cmd_args[args] ))) == 0.0 ) {
d465 1
a465 2
		args += argcnt;
		goto thckagain;
a466 1
	args += argcnt;
d469 12
d515 1
a515 1
			return;
d528 1
a528 1
		return;
d540 2
a541 1
	    	ALLOC_ERR_return;
d547 2
a548 1
		WRITE_ERR_return;
d553 1
a553 1
	f_edit( 2, cmd_args );	/* depends on solid name being in cmd_args[1] */
@


10.6
log
@type_arb() was calling redoarb(), which was rearranging vertices.
Is this correct?  I'm not sure, but I've commented out the call
for now.  In any event, it's certainly a nasty little side-effect
that you'd be excused for not expecting given the name of the
function (i.e. type_arb()) and the context in which it's called!
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.5 93/09/30 11:35:13 jra Exp $ (BRL)";
d568 1
a568 2
static void	move(), points(), vectors();
static int	redoarb();
d589 1
a589 1
	if( (i = cgarbs(uvec, svec)) == 0 )
a590 1
	printf("cgarbs() returned %d\n", i);
a591 5
#if 0
	if( redoarb(uvec, svec, i) == 0 )
		return( 0 );
#endif

a708 185
/*
 *  R E D O A R B :   rearranges arbs to be GIFT compatible
 */
static int
redoarb( uvec, svec, numvec )
register int *uvec, *svec;
int numvec;
{
	register int i, j;
	static int prod;

	switch( input.s.s_cgtype ) {

	case ARB8:
		/* do nothing */
		break;

	case ARB7:
		/* arb7 vectors: 0 1 2 3 4 5 6 4 */
		switch( svec[2] ) {
			case 0:
				/* 0 = 1, 3, or 4 */
				if(svec[3] == 1)
					move(4,7,6,5,1,4,3,1);
				if(svec[3] == 3)
					move(4,5,6,7,0,1,2,0);
				if(svec[3] == 4)
					move(1,2,6,5,0,3,7,0);
				break;
			case 1:
				/* 1 = 2 or 5 */
				if(svec[3] == 2)
					move(0,4,7,3,1,5,6,1);
				if(svec[3] == 5)
					move(0,3,7,4,1,2,6,1);
				break;
			case 2:
				/* 2 = 3 or 6 */
				if(svec[3] == 3)
					move(6,5,4,7,2,1,0,2);
				if(svec[3] == 6)
					move(3,0,4,7,2,1,5,2);
				break;
			case 3:
				/* 3 = 7 */
				move(2,1,5,6,3,0,4,3);
				break;
			case 4:
				/* 4 = 5 */
				/* if 4 = 7  do nothing */
				if(svec[3] == 5)
					move(1,2,3,0,5,6,7,5);
				break;
			case 5:
				/* 5 = 6 */
				move(2,3,0,1,6,7,4,6);
				break;
			case 6:
				/* 6 = 7 */
				move(3,0,1,2,7,4,5,7);
				break;
			default:
				(void)printf("redoarb: %s - bad arb7\n",
					input.s.s_name);
				return( 0 );
			}
			break;    	/* end of ARB7 case */

		case ARB6:
			/* arb6 vectors:  0 1 2 3 4 4 6 6 */

			prod = 1;
			for(i=0; i<numvec; i++)
				prod = prod * (uvec[i] + 1);
			switch( prod ) {
			case 24:
				/* 0123 unique */
				/* 4=7 and 5=6  OR  4=5 and 6=7 */
				if(svec[3] == 7)
					move(3,0,1,2,4,4,5,5);
				else
					move(0,1,2,3,4,4,6,6);
				break;
			case 1680:
				/* 4567 unique */
				/* 0=3 and 1=2  OR  0=1 and 2=3 */
				if(svec[3] == 3)
					move(7,4,5,6,0,0,1,1);
				else
					move(4,5,6,7,0,0,2,2);
				break;
			case 160:
				/* 0473 unique */
				/* 1=2 and 5=6  OR  1=5 and 2=6 */
				if(svec[3] == 2)
					move(0,3,7,4,1,1,5,5);
				else
					move(4,0,3,7,1,1,2,2);
				break;
			case 672:
				/* 3267 unique */
				/* 0=1 and 4=5  OR  0=4 and 1=5 */
				if(svec[3] == 1)
					move(3,2,6,7,0,0,4,4);
				else
					move(7,3,2,6,0,0,1,1);
				break;
			case 252:
				/* 1256 unique */
				/* 0=3 and 4=7  OR 0=4 and 3=7 */
				if(svec[3] == 3)
					move(1,2,6,5,0,0,4,4);
				else
					move(5,1,2,6,0,0,3,3);
				break;
			case 60:
				/* 0154 unique */
				/* 2=3 and 6=7  OR  2=6 and 3=7 */
				if(svec[3] == 3)
					move(0,1,5,4,2,2,6,6);
				else
					move(5,1,0,4,2,2,3,3);
				break;
			default:
				(void)printf("redoarb: %s: bad arb6\n",
					input.s.s_name);
				return( 0 );
			}
			break; 		/* end of ARB6 case */

		case ARB5:
			/* arb5 vectors:  0 1 2 3 4 4 4 4 */
			prod = 1;
			for(i=2; i<6; i++)
				prod = prod * (svec[i] + 1);
			switch( prod ) {
			case 24:
				/* 0=1=2=3 */
				move(4,5,6,7,0,0,0,0);
				break;
			case 1680:
				/* 4=5=6=7 */
				/* do nothing */
				break;
			case 160:
				/* 0=3=4=7 */
				move(1,2,6,5,0,0,0,0);
				break;
			case 672:
				/* 2=3=7=6 */
				move(0,1,5,4,2,2,2,2);
				break;
			case 252:
				/* 1=2=5=6 */
				move(0,3,7,4,1,1,1,1);
				break;
			case 60:
				/* 0=1=5=4 */
				move(3,2,6,7,0,0,0,0);
				break;
			default:
				(void)printf("redoarb: %s: bad arb5\n",
					input.s.s_name);
				return( 0 );
			}
			break;		/* end of ARB5 case */

		case ARB4:
			/* arb4 vectors:  0 1 2 0 4 4 4 4 */
			j = svec[6];
			if( svec[0] == 2 )
				j = svec[4];
			move(uvec[0],uvec[1],svec[2],uvec[0],j,j,j,j);
			break;

		default:
			(void)printf("redoarb %s: unknown arb type (%d)\n",
				input.s.s_name,input.s.s_cgtype);
			return( 0 );
	}

	return( 1 );
}


a709 40
move( p0, p1, p2, p3, p4, p5, p6, p7 )
int p0, p1, p2, p3, p4, p5, p6, p7;
{
	register int i, j;
	static int	pts[8];
	static fastf_t	copy[24];

	pts[0] = p0 * 3;
	pts[1] = p1 * 3;
	pts[2] = p2 * 3;
	pts[3] = p3 * 3;
	pts[4] = p4 * 3;
	pts[5] = p5 * 3;
	pts[6] = p6 * 3;
	pts[7] = p7 * 3;

	/* copy of the record */
	for(i=0; i<=21; i+=3) {
		VMOVE(&copy[i], &input.s.s_values[i]);
	}

	for(i=0; i<8; i++) {
		j = pts[i];
		VMOVE(&input.s.s_values[i*3], &copy[j]);
	}
}

static void
vectors()
{
	register int i;

	for(i=3; i<=21; i+=3) {
		VSUB2(&input.s.s_values[i],&input.s.s_values[i],&input.s.s_values[0]);
	}
}



static void
a882 202
 *			R T _ A R B _ R E D O
 *
 *  R E D O A R B :   rearranges arbs to be GIFT compatible
 *
 *  Note:  arbo and arbi must not point to same structure!
 *
 *  Returns -
 *	0	FAIL
 *	1	OK
 *
 *  Implicit returns -
 *	arb->pt[] array reorganized.
 */
static int
rt_arb_redo( arbo, arbi, uvec, svec, numvec, cgtype )
struct rt_arb_internal	*arbo;
struct rt_arb_internal	*arbi;
register int		*uvec;
register int		*svec;
int			numvec;
int			cgtype;
{
	register int i, j;
	int	prod;

	RT_ARB_CK_MAGIC( arbo );
	RT_ARB_CK_MAGIC( arbi );

	/* By default, let output be the input */
	*arbo = *arbi;		/* struct copy */

	switch( cgtype ) {

	case ARB8:
		/* do nothing */
		break;

	case ARB7:
		/* arb7 vectors: 0 1 2 3 4 5 6 4 */
		switch( svec[2] ) {
		case 0:
			/* 0 = 1, 3, or 4 */
			if(svec[3] == 1)
				rt_arb_ptmove( arbo, arbi,4,7,6,5,1,4,3,1);
			else if(svec[3] == 3)
				rt_arb_ptmove( arbo, arbi,4,5,6,7,0,1,2,0);
			else if(svec[3] == 4)
				rt_arb_ptmove( arbo, arbi,1,2,6,5,0,3,7,0);
			break;
		case 1:
			/* 1 = 2 or 5 */
			if(svec[3] == 2)
				rt_arb_ptmove( arbo, arbi,0,4,7,3,1,5,6,1);
			else if(svec[3] == 5)
				rt_arb_ptmove( arbo, arbi,0,3,7,4,1,2,6,1);
			break;
		case 2:
			/* 2 = 3 or 6 */
			if(svec[3] == 3)
				rt_arb_ptmove( arbo, arbi,6,5,4,7,2,1,0,2);
			else if(svec[3] == 6)
				rt_arb_ptmove( arbo, arbi,3,0,4,7,2,1,5,2);
			break;
		case 3:
			/* 3 = 7 */
			rt_arb_ptmove( arbo, arbi,2,1,5,6,3,0,4,3);
			break;
		case 4:
			/* 4 = 5 */
			/* if 4 = 7  do nothing */
			if(svec[3] == 5)
				rt_arb_ptmove( arbo, arbi,1,2,3,0,5,6,7,5);
			break;
		case 5:
			/* 5 = 6 */
			rt_arb_ptmove( arbo, arbi,2,3,0,1,6,7,4,6);
			break;
		case 6:
			/* 6 = 7 */
			rt_arb_ptmove( arbo, arbi,3,0,1,2,7,4,5,7);
			break;
		default:
			rt_log("rt_arb_redo: bad arb7\n");
			return( 0 );
		}
		break;    	/* end of ARB7 case */

	case ARB6:
		/* arb6 vectors:  0 1 2 3 4 4 6 6 */
		prod = 1;
		for(i=0; i<numvec; i++)
			prod = prod * (uvec[i] + 1);

		switch( prod ) {
		case 24:
			/* 0123 unique */
			/* 4=7 and 5=6  OR  4=5 and 6=7 */
			if(svec[3] == 7)
				rt_arb_ptmove( arbo, arbi,3,0,1,2,4,4,5,5);
			else
				rt_arb_ptmove( arbo, arbi,0,1,2,3,4,4,6,6);
			break;
		case 1680:
			/* 4567 unique */
			/* 0=3 and 1=2  OR  0=1 and 2=3 */
			if(svec[3] == 3)
				rt_arb_ptmove( arbo, arbi,7,4,5,6,0,0,1,1);
			else
				rt_arb_ptmove( arbo, arbi,4,5,6,7,0,0,2,2);
			break;
		case 160:
			/* 0473 unique */
			/* 1=2 and 5=6  OR  1=5 and 2=6 */
			if(svec[3] == 2)
				rt_arb_ptmove( arbo, arbi,0,3,7,4,1,1,5,5);
			else
				rt_arb_ptmove( arbo, arbi,4,0,3,7,1,1,2,2);
			break;
		case 672:
			/* 3267 unique */
			/* 0=1 and 4=5  OR  0=4 and 1=5 */
			if(svec[3] == 1)
				rt_arb_ptmove( arbo, arbi,3,2,6,7,0,0,4,4);
			else
				rt_arb_ptmove( arbo, arbi,7,3,2,6,0,0,1,1);
			break;
		case 252:
			/* 1256 unique */
			/* 0=3 and 4=7  OR 0=4 and 3=7 */
			if(svec[3] == 3)
				rt_arb_ptmove( arbo, arbi,1,2,6,5,0,0,4,4);
			else
				rt_arb_ptmove( arbo, arbi,5,1,2,6,0,0,3,3);
			break;
		case 60:
			/* 0154 unique */
			/* 2=3 and 6=7  OR  2=6 and 3=7 */
			if(svec[3] == 3)
				rt_arb_ptmove( arbo, arbi,0,1,5,4,2,2,6,6);
			else
				rt_arb_ptmove( arbo, arbi,5,1,0,4,2,2,3,3);
			break;
		default:
			rt_log("rt_arb_redo: bad arb6\n");
			return( 0 );
		}
		break; 		/* end of ARB6 case */

	case ARB5:
		/* arb5 vectors:  0 1 2 3 4 4 4 4 */
		prod = 1;
		for(i=2; i<6; i++)
			prod = prod * (svec[i] + 1);

		switch( prod ) {
		case 24:
			/* 0=1=2=3 */
			rt_arb_ptmove( arbo, arbi,4,5,6,7,0,0,0,0);
			break;
		case 1680:
			/* 4=5=6=7 */
			/* do nothing */
			break;
		case 160:
			/* 0=3=4=7 */
			rt_arb_ptmove( arbo, arbi,1,2,6,5,0,0,0,0);
			break;
		case 672:
			/* 2=3=7=6 */
			rt_arb_ptmove( arbo, arbi,0,1,5,4,2,2,2,2);
			break;
		case 252:
			/* 1=2=5=6 */
			rt_arb_ptmove( arbo, arbi,0,3,7,4,1,1,1,1);
			break;
		case 60:
			/* 0=1=5=4 */
			rt_arb_ptmove( arbo, arbi,3,2,6,7,0,0,0,0);
			break;
		default:
			rt_log("rt_arb_redo: bad arb5\n");
			return( 0 );
		}
		break;		/* end of ARB5 case */

	case ARB4:
		/* arb4 vectors:  0 1 2 0 4 4 4 4 */
		j = svec[6];
		if( svec[0] == 2 )
			j = svec[4];
		rt_arb_ptmove( arbo, arbi,uvec[0],uvec[1],svec[2],uvec[0],j,j,j,j);
		break;

	default:
		rt_log("rt_arb_redo: unknown arb type (%d)\n",
			cgtype);
		return( 0 );
	}
	return( 1 );
}

/*
d885 1
a885 2
 *  Given an ARB in internal form, return it's specific ARB type,
 *  and reorganize the points to be in GIFT "standard" order.
a905 1
	struct rt_arb_internal	arbo;
a921 5
	arbo.magic = RT_ARB_INTERNAL_MAGIC;
	if( rt_arb_redo( &arbo, arb, uvec, svec, nedge, cgtype) == 0 )
		return( 0 );

	*arb = arbo;		/* struct copy of reorganized arb */
@


10.5
log
@modified f_rfarb() and f_3ptarb() to use import/export routines
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.4 92/03/21 05:32:27 mike Exp Locker: jra $ (BRL)";
d592 1
d594 1
d597 1
@


10.4
log
@Eliminated a static
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.3 92/03/18 00:40:34 mike Exp Locker: mike $ (BRL)";
a51 1
static union record record;
a53 4
#define XCOORD 0
#define YCOORD 1
#define ZCOORD 2

d79 12
a90 7
	int i, solve;
	vect_t	vec1;
	vect_t	vec2;
	fastf_t	pt4[2], length, thick;
	vect_t	norm;
	fastf_t	ndotv;
	struct directory *dp;
d92 6
d104 2
a105 2
	for(i=0; i<24; i++) {
		record.s.s_values[i] = 0.0;
d123 1
a123 1
	NAMEMOVE( cmd_args[1], record.s.s_name );
d149 1
a149 3
		record.s.s_values[i] = atof( cmd_args[(i+2)] ) * local2base;
		record.s.s_values[(i+3)] = atof( cmd_args[(i+5)] ) * local2base;
		record.s.s_values[(i+6)] = atof( cmd_args[(i+8)] ) * local2base;
d164 1
a164 1
			solve = XCOORD;
d185 1
a185 1
			solve = YCOORD;
d206 1
a206 1
			solve = ZCOORD;
d239 1
a239 3
	record.s.s_id = ID_SOLID;
	record.s.s_type = GENARB8;
	record.s.s_cgtype = ARB8;
a240 2
	ndotv = VDOT( &record.s.s_values[0], norm );

d243 1
a243 1
		case XCOORD:
d245 6
a250 6
			record.s.s_values[10] = pt4[0];	/* y-coord */
			record.s.s_values[11] = pt4[1]; 	/* z-coord */
			record.s.s_values[9] =  ( ndotv
						- norm[1] * record.s.s_values[10]
						- norm[2] * record.s.s_values[11])
						/ norm[0];	/* x-coord */
d253 1
a253 1
		case YCOORD:
d255 6
a260 6
			record.s.s_values[9] = pt4[0];	/* x-coord */
			record.s.s_values[11] = pt4[1]; 	/* z-coord */
			record.s.s_values[10] =  ( ndotv
						- norm[0] * record.s.s_values[9]
						- norm[2] * record.s.s_values[11])
						/ norm[1];	/* y-coord */
d263 1
a263 1
		case ZCOORD:
d265 6
a270 6
			record.s.s_values[9] = pt4[0];	/* x-coord */
			record.s.s_values[10] = pt4[1]; 	/* y-coord */
			record.s.s_values[11] =  ( ndotv
						- norm[0] * record.s.s_values[9]
						- norm[1] * record.s.s_values[10])
						/ norm[2];	/* z-coord */
d280 2
a281 9
	for(i=0; i<3; i++) {
		record.s.s_values[(i+12)] = record.s.s_values[i]
						+ (thick * norm[i]);
		record.s.s_values[(i+15)] = record.s.s_values[(i+3)]
						+ (thick * norm[i]);
		record.s.s_values[(i+18)] = record.s.s_values[(i+6)]
						+ (thick * norm[i]);
		record.s.s_values[(i+21)] = record.s.s_values[(i+9)]
						+ (thick * norm[i]);
d284 5
a288 4
	/* convert to vector notation */
	for(i=3; i<=21; i+=3) {
		VSUB2(&record.s.s_values[i], &record.s.s_values[i],
			&record.s.s_values[0]);
d290 1
d295 5
a299 2
	if( (dp = db_diradd( dbip, record.s.s_name, -1, 0, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )  {
a301 1
	if( db_put( dbip,  dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
d303 7
d311 1
a311 1
	f_edit( 2, cmd_args );	/* depends on name being in cmd_args[1] */
d334 12
a345 7
	struct directory *dp;
	int	i;
	int	solve[3];
	fastf_t	pt[3][2];
	fastf_t	thick, rota, fba;
	vect_t	norm;
	fastf_t	ndotv;
d347 6
d359 2
a360 2
	for(i=0; i<24; i++) {
		record.s.s_values[i] = 0.0;
d378 1
a378 1
	NAMEMOVE( cmd_args[1], record.s.s_name );
a387 3
	for(i=0; i<3; i++) {
		record.s.s_values[i] = atof(cmd_args[i+2]) * local2base;
	}
d389 2
d418 1
a418 1
				solve[i] = XCOORD;
d439 1
a439 1
				solve[i] = YCOORD;
d460 1
a460 1
				solve[i] = ZCOORD;
d493 1
a493 3
	record.s.s_id = ID_SOLID;
	record.s.s_type = GENARB8;
	record.s.s_cgtype = ARB8;
a494 2
	ndotv = VDOT( &record.s.s_values[0], norm );

d497 2
d501 6
a506 6
			case XCOORD:
				record.s.s_values[3*i+4] = pt[i][0];
				record.s.s_values[3*i+5] = pt[i][1];
				record.s.s_values[3*i+3] = ( ndotv
					- norm[1] * record.s.s_values[3*i+4]
					- norm[2] * record.s.s_values[3*i+5])
d509 6
a514 6
			case YCOORD:
				record.s.s_values[3*i+3] = pt[i][0];
				record.s.s_values[3*i+5] = pt[i][1];
				record.s.s_values[3*i+4] = ( ndotv
					- norm[0] * record.s.s_values[3*i+3]
					- norm[2] * record.s.s_values[3*i+5])
d517 6
a522 6
			case ZCOORD:
				record.s.s_values[3*i+3] = pt[i][0];
				record.s.s_values[3*i+4] = pt[i][1];
				record.s.s_values[3*i+5] = ( ndotv
					- norm[0] * record.s.s_values[3*i+3]
					- norm[1] * record.s.s_values[3*i+4])
d532 2
a533 9
	for(i=0; i<3; i++) {
		record.s.s_values[(i+12)] = record.s.s_values[i]
						+ (thick * norm[i]);
		record.s.s_values[(i+15)] = record.s.s_values[(i+3)]
						+ (thick * norm[i]);
		record.s.s_values[(i+18)] = record.s.s_values[(i+6)]
						+ (thick * norm[i]);
		record.s.s_values[(i+21)] = record.s.s_values[(i+9)]
						+ (thick * norm[i]);
d536 5
a540 4
	/* convert to vector notation */
	for(i=3; i<=21; i+=3) {
		VSUB2(&record.s.s_values[i], &record.s.s_values[i],
			&record.s.s_values[0]);
d542 1
d547 5
a551 2
	if( (dp = db_diradd( dbip, record.s.s_name, -1, 0, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0  )  {
d553 6
d560 1
a560 1
	if( db_put( dbip,  dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
d563 1
a563 1
	f_edit( 2, cmd_args );	/* depends on name being in cmd_args[1] */
@


10.3
log
@Removed debugging prints
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.3 92/03/18 00:38:17 mike Exp $ (BRL)";
d955 1
a955 1
static int
@


10.2
log
@Added some new functions to deal with ARBs in the "new way".
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 10.1 91/10/12 06:43:04 mike Rel4_0 Locker: mike $ (BRL)";
d550 1
d932 2
a933 1
/* -------------------------------- */
d1060 7
a1066 5
printf("uvec: ");
for(j=0; j<8; j++) printf("%d, ", uvec[j]);
printf("\nsvec: ");
for(j=0; j<11; j++ ) printf("%d, ", svec[j]);
printf("\n");
a1334 3
	for( i=0; i<8; i++)  {
		VPRINT("before pt[]", arb->pt[i]);
	}
a1343 3
	for( i=0; i<8; i++)  {
		VPRINT("after pt[]", arb->pt[i]);
	}
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 9.5 91/08/30 17:18:50 mike Exp $ (BRL)";
d38 2
d929 447
@


9.5
log
@strlen returns unsigned, ANSI comparison with int requires cast.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 9.4 90/12/08 00:31:05 mike Exp $ (BRL)";
@


9.4
log
@Added error checking around calls to db_*() routines
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 9.3 90/12/07 20:42:50 mike Exp $ (BRL)";
d111 1
a111 1
	if( strlen(cmd_args[1]) >= NAMESIZE ) {
d357 1
a357 1
	if( strlen(cmd_args[1]) >= NAMESIZE ) {
@


9.3
log
@Error checking
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/arbs.c,v 9.2 90/04/21 06:04:25 mike Exp $ (BRL)";
d298 5
a302 7
	if( (dp = db_diradd( dbip, record.s.s_name, -1, 0, DIR_SOLID)) == DIR_NULL )
		return;
	if( db_alloc( dbip, dp, 1 ) < 0 || 
	    db_put( dbip,  dp, &record, 0, 1 ) < 0 )  {
	    	printf("error, aborting\n");
	    	return;
	}
d538 3
a540 6
	if( (dp = db_diradd( dbip, record.s.s_name, -1, 0, DIR_SOLID)) == DIR_NULL )
		return;
	if( db_alloc( dbip, dp, 1 ) < 0  ||
	    db_put( dbip,  dp, &record, 0, 1 ) < 0 )  {
	    	printf("error, aborting\n");
	    	return;
d542 1
@


9.2
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 9.1 89/05/19 06:01:42 mike Locked $ (BRL)";
d39 1
a42 2
extern char *strcat(), *strcpy();

d300 5
a304 2
	db_alloc( dbip, dp, 1 );
	db_put( dbip,  dp, &record, 0, 1 );
d326 3
a328 1
f_rfarb()
d542 5
a546 2
	db_alloc( dbip, dp, 1 );
	db_put( dbip,  dp, &record, 0, 1 );
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 8.5 89/05/11 21:39:43 phil Exp $ (BRL)";
d79 3
a81 1
f_3ptarb(  )
d303 3
a305 4
	drawtree( dp );
	dmp->dmr_colorchange();
	dmaflag = 1;
	return;
d540 3
a542 4
	drawtree( dp );
	dmp->dmr_colorchange();
	dmaflag = 1;
	return;
@


8.5
log
@db_diradd had the length and flags parameters backward
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 8.4 89/04/06 19:20:34 phil Locked $ (BRL)";
@


8.4
log
@removed MAXLINE (unused)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 8.3 89/01/16 22:51:28 phil Locked $ (BRL)";
d297 1
a297 1
	if( (dp = db_diradd( dbip, record.s.s_name, -1, DIR_SOLID, 0)) == DIR_NULL )
d535 1
a535 1
	if( (dp = db_diradd( dbip, record.s.s_name, -1, DIR_SOLID, 0)) == DIR_NULL )
@


8.3
log
@drawHobj() --> drawtree()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 8.2 88/12/06 00:49:22 mike Locked $ (BRL)";
a53 1
#define MAXLINE	512
@


8.2
log
@Converted to new db_*() routines.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/arbs.c,v 1.2 88/10/23 13:55:30 mike Exp $ (BRL)";
d302 1
a302 1
	drawHobj(dp, ROOT, 0, identity);
d540 1
a540 1
	drawHobj(dp, ROOT, 0, identity);
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 7.5 88/09/19 22:49:13 mike Exp $ (BRL)";
d38 1
a39 1
#include "./objdir.h"
d106 1
a106 1
	if( lookup(cmd_args[1], LOOKUP_QUIET) != DIR_NULL ) {
d298 1
a298 1
	if( (dp = dir_add(record.s.s_name, -1, DIR_SOLID, 0)) == DIR_NULL )
d300 2
a301 2
	db_alloc( dp, 1 );
	db_putrec( dp, &record, 0 );
d350 1
a350 1
	if( lookup(cmd_args[1], LOOKUP_QUIET) != DIR_NULL ) {
d536 1
a536 1
	if( (dp = dir_add(record.s.s_name, -1, DIR_SOLID, 0)) == DIR_NULL )
d538 2
a539 2
	db_alloc( dp, 1 );
	db_putrec( dp, &record, 0 );
@


7.5
log
@atof() is better defined in <math.h>
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 7.4 88/05/15 23:04:36 mike Locked $ (BRL)";
@


7.4
log
@lint fixes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 7.3 88/05/02 15:53:07 mike Locked $ (BRL)";
a41 1
extern double atof();
@


7.3
log
@FIXED arb8 --> arb6 bug 
removed the routine comparevec which was somehow messed up
and was only called once so I put in inline ...
Maybe should become a MACRO call in vmath.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 7.2 87/11/05 05:03:17 mike Exp $ (BRL)";
a41 1
extern void aexists();
a44 2
double fabs();

d53 1
d80 1
a80 1

d324 1
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 7.1 87/11/02 23:58:22 mike Rel $ (BRL)";
a549 1
static int	comparvec();
d589 1
a589 1

d612 11
a622 1
			if(comparvec(&input.s.s_values[i*3], &input.s.s_values[j*3]) == YES) {
d641 1
a905 17



static int
comparvec( x, y )
register vect_t	x,y;
{
	if( fabs( x[0] - y[0] ) > 0.0001 )
		return(0);   /* different */
	if( fabs( x[1] - y[1] ) > 0.0001 )
		return(0);   /* different */
	if( fabs( x[2] - y[2] ) > 0.0001 )
		return(0);   /* different */

	return(1);  /* same */
}

@


7.1
log
@Release 2.3
@
text
@a0 1

d23 1
a23 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 6.1 87/07/11 08:01:26 mike Rel $ (BRL)";
d35 1
a35 1
#include "./machine.h"
d86 5
a90 2
	float vec1[3], vec2[3], pt4[2], length, thick;
	double norm[4];
a92 1

d240 1
a240 3
	norm[3] =  record.s.s_values[0] * norm[0]
                 + record.s.s_values[1] * norm[1]
   		 + record.s.s_values[2] * norm[2];
a241 1

d248 1
a248 1
			record.s.s_values[9] =  ( norm[3]
d258 1
a258 1
			record.s.s_values[10] =  ( norm[3]
d268 1
a268 1
			record.s.s_values[11] =  ( norm[3]
d329 6
a334 3
	int i, solve[3];
	float pt[3][2], thick, rota, fba;
	double norm[4];
a335 1

d481 1
a481 3
	norm[3] =  record.s.s_values[0] * norm[0]
                 + record.s.s_values[1] * norm[1]
   		 + record.s.s_values[2] * norm[2];
d490 1
a490 1
				record.s.s_values[3*i+3] = ( norm[3]
d498 1
a498 1
				record.s.s_values[3*i+4] = ( norm[3]
d506 1
a506 1
				record.s.s_values[3*i+5] = ( norm[3]
d874 2
a875 2
	static int pts[8];
	static float copy[24];
d901 1
a901 1
register float *x,*y;
d903 6
a908 1
	register int i;
a909 4
	for(i=0; i<3; i++) {
		if( fabs( *x++ - *y++ ) > 0.0001 )
			return(0);   /* different */
	}
@


6.1
log
@Release 2.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 5.1 87/06/24 22:17:35 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 4.3 87/02/13 00:05:15 mike Exp $ (BRL)";
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 4.2 87/02/11 05:38:47 mike Exp $ (BRL)";
@


4.2
log
@Minor cleanups inspired by the Cray
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 4.1 86/12/29 03:18:55 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 1.5 86/09/23 17:39:32 mike Exp $ (BRL)";
d51 4
a54 4
int		newargs;
int		args;
int		argcnt;
char		**promp;
@


1.5
log
@Minor cleanup for cray
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: arbs.c,v 1.4 86/09/09 22:16:39 mike Exp $ (BRL)";
@


1.4
log
@Added header
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d29 1
d31 4
@


1.3
log
@Changed #includes for CC -I../h
@
text
@d11 11
d23 3
@


1.2
log
@Imported type_arb() and associated routines.
@
text
@d16 1
d18 5
a22 6
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "objdir.h"
#include <math.h>
#include "dm.h"
@


1.1
log
@Initial revision
@
text
@d532 3
d536 1
d538 379
@
