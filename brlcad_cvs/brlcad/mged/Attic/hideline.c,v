head	11.19;
access;
symbols
	ansi-20040405-merged:11.16.4.1
	postmerge-20040405-ansi:11.17
	premerge-20040404-ansi:11.17
	postmerge-autoconf:11.17
	autoconf-freeze:11.17
	premerge-autoconf:11.17
	postmerge-20040315-windows:11.17
	premerge-20040315-windows:11.17
	windows-20040315-freeze:11.16.6.1
	autoconf-20031203:11.17
	autoconf-20031202:11.17
	autoconf-branch:11.17.0.4
	phong-branch:11.17.0.2
	photonmap-branch:11.16.0.8
	rel-6-1-DP:11.16
	windows-branch:11.16.0.6
	rel-6-0-2:11.16
	ansi-branch:11.16.0.4
	rel-6-0-1-branch:11.16.0.2
	hartley-6-0-post:11.16
	hartley-6-0-pre:11.16
	rel-6-0-1:11.16
	rel-6-0:11.16
	rel-5-4:11.13
	offsite-5-3-pre:11.15
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.13
	rel-5-0-beta:11.12
	rel-4-5:11.10
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.19
date	2004.05.21.17.47.44;	author morrison;	state dead;
branches;
next	11.18;

11.18
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.17;

11.17
date	2003.05.17.00.37.14;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2001.11.05.21.20.07;	author morrison;	state Exp;
branches
	11.16.4.1
	11.16.6.1
	11.16.8.1;
next	11.15;

11.15
date	2000.10.20.05.04.38;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.19.03.10.46;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.09.01.18.55.10;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	98.11.06.22.32.41;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	98.06.11.19.41.46;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.09.23.18.25.49;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.03.22.18.33.29;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.12.27.22.36.36;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.13;	author mike;	state Rel4_4;
branches;
next	10.9;

10.9
date	94.12.27.18.15.42;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.12.23.23.02.34;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.12.20.16.42.33;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.12.16.19.36.51;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.11.05.03.52.54;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.21.32.05;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.09.15.10.11;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.06.03.17.27.21;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.46;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.07.08.23.42.36;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.02.02.00.01.14;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.05.09.20.00.52;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.19;	author mike;	state Rel3_5;
branches;
next	1.6;

1.6
date	89.04.06.20.40.05;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.03.07.00.15.42;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.02.14.06.25.20;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.02.13.07.13.24;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.02.13.07.06.46;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	89.01.24.17.20.25;	author phil;	state Exp;
branches;
next	;

11.16.4.1
date	2004.03.17.21.21.59;	author morrison;	state Exp;
branches;
next	;

11.16.6.1
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

11.16.8.1
date	2003.08.26.14.03.43;	author justin;	state Exp;
branches;
next	;


desc
@Hidden line routine
@


11.19
log
@moved to src/mged/
@
text
@/* 
 *			H I D E L I N E . C
 * 
 * Description -
 *	Takes the vector  list for the  current  display  and  raytraces
 *	along those vectors.  If the first point hit in the model is the
 *	same as that  vector,  continue  the line  through  that  point;
 *	otherwise,  stop  drawing  that  vector  or  draw  dotted  line.
 *	Produces Unix-plot type output.
 *
 *	The command is "H file.pl [stepsize] [%epsilon]". Stepsize is the
 *	number of segments into which the window size should be broken.
 *	%Epsilon specifies how close two points must be before they are
 *	considered equal. A good values for stepsize and %epsilon are 128
 *	and 1, respectively.
 *
 * Author -  
 *	Mark Huston Bowden  
 *
 * History -
 *	01 Aug 88		Began initial coding
 *  
 *  Source -
 *	Research  Institute,  E-47 
 *	University of Alabama in Huntsville  
 *	Huntsville, AL 35899
 *	(205) 895-6467	UAH
 *	(205) 876-1089	Redstone Arsenal
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/hideline.c,v 11.18 2004/05/10 15:30:48 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "solid.h"
#include "./mged_dm.h"

#define MAXOBJECTS	3000

#define VIEWSIZE	(2*view_state->vs_Viewscale)
#define TRUE	1
#define FALSE	0

#define MOVE(v)	  VMOVE(last_move,(v))

#define DRAW(v)	{ vect_t a,b;\
		  MAT4X3PNT(a,view_state->vs_model2view,last_move);\
		  MAT4X3PNT(b,view_state->vs_model2view,(v));\
		  pdv_3line(plotfp, a, b ); }

extern struct db_i *dbip;	/* current database instance */

fastf_t epsilon;
vect_t aim_point;
struct solid *sp;

/*
 * hit_headon - routine called by rt_shootray if ray hits model
 */

static int
hit_headon(ap,PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	register char diff_solid;
	vect_t	diff;
	register fastf_t len;

	if (PartHeadp->pt_forw->pt_forw != PartHeadp)
	  Tcl_AppendResult(interp, "hit_headon: multiple partitions\n", (char *)NULL);

	VJOIN1(PartHeadp->pt_forw->pt_inhit->hit_point,ap->a_ray.r_pt,
	    PartHeadp->pt_forw->pt_inhit->hit_dist, ap->a_ray.r_dir);
	VSUB2(diff,PartHeadp->pt_forw->pt_inhit->hit_point,aim_point);

	diff_solid = (FIRST_SOLID(sp) !=
		PartHeadp->pt_forw->pt_inseg->seg_stp->st_dp);
	len = MAGNITUDE(diff);

	if (	NEAR_ZERO(len,epsilon)
	    ||
	    ( diff_solid &&
	    VDOT(diff,ap->a_ray.r_dir) > 0 )
	    )
		return(1);
	else
		return(0);
}

/*
 * hit_tangent - routine called by rt_shootray if ray misses model
 *
 *     We know we are shooting at the model since we are aiming at the
 *     vector list MGED created. However, shooting at an edge or shooting
 *     tangent to a curve produces only one intersection point at which
 *     time rt_shootray reports a miss. Therefore, this routine is really
 *     a "hit" routine.
 */

static int
hit_tangent(ap,PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	return(1);		/* always a hit */
}

/*
 * hit_overlap - called by rt_shootray if ray hits an overlap
 */

static int
hit_overlap(ap,PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	return(0);		/* never a hit */
}

/*
 *			F _ H I D E L I N E
 */
int
f_hideline(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	FILE 	*plotfp;
	char 	visible;
	int 	i,numobjs;
	char 	*objname[MAXOBJECTS],title[1];
	fastf_t 	len,u,step;
	FAST float 	ratio;
	vect_t	last_move;
	struct rt_i	*rtip;
	struct resource resource;
	struct application a;
	vect_t temp;
	vect_t last,dir;
	register struct rt_vlist	*vp;

	CHECK_DBI_NULL;

	if(argc < 2 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help H");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if ((plotfp = fopen(argv[1],"w")) == NULL) {
	  Tcl_AppendResult(interp, "f_hideline: unable to open \"", argv[1],
			   "\" for writing.\n", (char *)NULL);
	  return TCL_ERROR;
	}
	pl_space(plotfp,(int)GED_MIN,(int)GED_MIN,(int)GED_MAX,(int)GED_MAX);

	/*  Build list of objects being viewed */
	numobjs = 0;
	FOR_ALL_SOLIDS(sp) {
		for (i = 0; i < numobjs; i++)  {
			if( objname[i] == FIRST_SOLID(sp)->d_namep )
				break;
		}
		if (i == numobjs)
			objname[numobjs++] = FIRST_SOLID(sp)->d_namep;
	}

	Tcl_AppendResult(interp, "Generating hidden-line drawing of the following regions:\n",
			 (char *)NULL);
	for (i = 0; i < numobjs; i++)
	  Tcl_AppendResult(interp, "\t", objname[i], "\n", (char *)NULL);

	/* Initialization for librt */
	if ((rtip = rt_dirbuild(dbip->dbi_filename,title,0)) == RTI_NULL) {
	  Tcl_AppendResult(interp, "f_hideline: unable to open model file \"",
			   dbip->dbi_filename, "\"\n", (char *)NULL);
	  return TCL_ERROR;
	}
	a.a_hit = hit_headon;
	a.a_miss = hit_tangent;
	a.a_overlap = hit_overlap;
	a.a_rt_i = rtip;
	a.a_resource = &resource;
	a.a_level = 0;
	a.a_onehit = 1;
	a.a_diverge = 0;
	a.a_rbeam = 0;

	if (argc > 2) {
		sscanf(argv[2],"%f",&step);
		step = view_state->vs_Viewscale/step;
		sscanf(argv[3],"%f",&epsilon);
		epsilon *= view_state->vs_Viewscale/100;
	} else {
		step = view_state->vs_Viewscale/256;
		epsilon = 0.1*view_state->vs_Viewscale;
	}

	for (i = 0; i < numobjs; i++)
	  if (rt_gettree(rtip,objname[i]) == -1)
	    Tcl_AppendResult(interp, "f_hideline: rt_gettree failed on \"",
			     objname[i], "\"\n", (char *)NULL);

	/* Crawl along the vectors raytracing as we go */
	VSET(temp, 0.0, 0.0, -1.0);				/* looking at model */
	MAT4X3VEC(a.a_ray.r_dir,view_state->vs_view2model,temp);
	VUNITIZE(a.a_ray.r_dir);

	FOR_ALL_SOLIDS(sp) {

		ratio = sp->s_size / VIEWSIZE;		/* ignore if small or big */
		if (ratio >= dmp->dmr_bound || ratio < 0.001)
			continue;

		Tcl_AppendResult(interp, "Primitive\n", (char *)NULL);
		for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
			register int	i;
			register int	nused = vp->nused;
			register int	*cmd = vp->cmd;
			register point_t *pt = vp->pt;
			for( i = 0; i < nused; i++,cmd++,pt++ )  {
			  Tcl_AppendResult(interp, "\tVector\n", (char *)NULL);
				switch( *cmd )  {
				case RT_VLIST_POLY_START:
				case RT_VLIST_POLY_VERTNORM:
					break;
				case RT_VLIST_POLY_MOVE:
				case RT_VLIST_LINE_MOVE:
					/* move */
					VMOVE(last, *pt);
					MOVE(last);
					break;
				case RT_VLIST_POLY_DRAW:
				case RT_VLIST_POLY_END:
				case RT_VLIST_LINE_DRAW:
					/* setup direction && length */
					VSUB2(dir, *pt, last);
					len = MAGNITUDE(dir);
					VUNITIZE(dir);
					visible = FALSE;
					{
					  struct bu_vls tmp_vls;

					  bu_vls_init(&tmp_vls);
					  bu_vls_printf(&tmp_vls, "\t\tDraw 0 -> %g, step %g\n", len, step);
					  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
					  bu_vls_free(&tmp_vls);
					}
					for (u = 0; u <= len; u += step) {
						VJOIN1(aim_point,last,u,dir);
						MAT4X3PNT(temp,view_state->vs_model2view,aim_point);
						temp[Z] = 100;			/* parallel project */
						MAT4X3PNT(a.a_ray.r_pt,view_state->vs_view2model,temp);
						if (rt_shootray(&a)) {
							if (!visible) {
								visible = TRUE;
								MOVE(aim_point);
							}
						} else {
							if (visible) {
								visible = FALSE;
								DRAW(aim_point);
							}
						}
					}
					if (visible)
						DRAW(aim_point);
					VMOVE(last, *pt); /* new last vertex */
				}
			}
		}
	}
	fclose(plotfp);
	return TCL_OK;
}
@


11.18
log
@change conf.h to a wrapped config.h
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/hideline.c,v 11.17 2003/05/17 00:37:14 morrison Exp $ (ARL)";
@


11.17
log
@re-fixed defines so that mged will build undependantly -- X is not *required*
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/hideline.c,v 11.16 2001/11/05 21:20:07 morrison Exp $ (ARL)";
d37 5
a41 1
#include "conf.h"
@


11.16
log
@Solid to Primitive naming convention conversions
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/hideline.c,v 11.15 2000/10/20 05:04:38 mike Exp $ (ARL)";
d52 1
a52 1
#include "./solid.h"
@


11.16.4.1
log
@sync branch with HEAD
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d52 1
a52 1
#include "solid.h"
@


11.16.6.1
log
@sync to HEAD...
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/hideline.c,v 11.17 2003/05/17 00:37:14 morrison Exp $ (ARL)";
d52 1
a52 1
#include "solid.h"
@


11.16.8.1
log
@updated for merging
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/hideline.c,v 11.17 2003/05/17 00:37:14 morrison Exp $ (ARL)";
d52 1
a52 1
#include "solid.h"
@


11.15
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/hideline.c,v 11.14 2000/08/19 03:10:46 mike Exp $ (ARL)";
d239 1
a239 1
		Tcl_AppendResult(interp, "Solid\n", (char *)NULL);
@


11.14
log
@
const RCSid
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/hideline.c,v 11.13 1999/09/01 18:55:10 bparker Exp $ (ARL)";
d94 2
a95 2
	diff_solid = strcmp(sp->s_path[0]->d_namep,
	    PartHeadp->pt_forw->pt_inseg->seg_stp->st_name);
d185 1
a185 1
			if( objname[i] == sp->s_path[0]->d_namep )
d189 1
a189 1
			objname[numobjs++] = sp->s_path[0]->d_namep;
@


11.13
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/hideline.c,v 11.12 1998/11/06 22:32:41 bparker Exp $ (ARL)";
@


11.12
log
@*- use new structures
*- cleanup
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/hideline.c,v 11.11 1998/06/11 19:41:46 bparker Exp $ (ARL)";
d162 1
a162 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.11
log
@*- using floating point literals to initialize floats
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/hideline.c,v 11.10 1997/07/01 22:09:08 bparker Exp $ (ARL)";
d57 1
a57 1
#define VIEWSIZE	(2*Viewscale)
d64 2
a65 2
		  MAT4X3PNT(a,model2view,last_move);\
		  MAT4X3PNT(b,model2view,(v));\
d180 1
a180 1
	pl_space(plotfp,-2048,-2048,2048,2048);
d216 1
a216 1
		step = Viewscale/step;
d218 1
a218 1
		epsilon *= Viewscale/100;
d220 2
a221 2
		step = Viewscale/256;
		epsilon = 0.1*Viewscale;
d231 1
a231 1
	MAT4X3VEC(a.a_ray.r_dir,view2model,temp);
d276 1
a276 1
						MAT4X3PNT(temp,model2view,aim_point);
d278 1
a278 1
						MAT4X3PNT(a.a_ray.r_pt,view2model,temp);
@


11.10
log
@mods to run without a database
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.9 1997/04/24 18:03:58 bparker Exp bparker $ (ARL)";
d230 1
a230 1
	VSET(temp,0,0,-1);				/* looking at model */
@


11.9
log
@modify calls to Tcl_Eval
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.8 1997/04/16 20:23:49 bparker Exp bparker $ (ARL)";
d161 3
@


11.8
log
@mods so that commands check args internally
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.7 1996/09/23 18:25:49 bparker Exp bparker $ (ARL)";
d163 6
a168 1
	  Tcl_Eval(interp, "help H");
@


11.7
log
@changed dm.h to mged_dm.h
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.6 1996/09/03 20:02:37 bparker Exp bparker $ (ARL)";
d162 2
a163 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d165 1
@


11.6
log
@rt_list ---> bu_list
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.5 1996/08/27 20:30:05 bparker Exp bparker $ (ARL)";
d53 1
a53 1
#include "./dm.h"
@


11.5
log
@now using libbu
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.4 1996/04/18 20:28:43 bparker Exp bparker $ (ARL)";
d48 1
d231 1
a231 1
		for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
@


11.4
log
@convert commands to Tcl
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.3 1996/03/22 18:33:29 bparker Exp bparker $ (ARL)";
d256 1
a256 1
					  struct rt_vls tmp_vls;
d258 4
a261 4
					  rt_vls_init(&tmp_vls);
					  rt_vls_printf(&tmp_vls, "\t\tDraw 0 -> %g, step %g\n", len, step);
					  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
					  rt_vls_free(&tmp_vls);
@


11.3
log
@cleanup.c
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.2 1995/12/27 22:36:36 bparker Exp bparker $ (ARL)";
d87 1
a87 1
		rt_log("hit_headon: multiple partitions\n");
d141 3
a143 1
f_hideline(argc, argv)
d161 3
d165 3
a167 3
		rt_log("f_hideline: unable to open \"%s\" for writing.\n",
		    argv[1]);
		return CMD_BAD;
d182 2
a183 1
	rt_log("Generating hidden-line drawing of the following regions:\n");
d185 1
a185 1
		rt_log("\t%s\n",objname[i]);
d189 3
a191 3
		rt_log("f_hideline: unable to open model file \"%s\"\n",
		    dbip->dbi_filename);
		return CMD_BAD;
d214 3
a216 2
		if (rt_gettree(rtip,objname[i]) == -1)
			rt_log("f_hideline: rt_gettree failed on \"%s\"\n",objname[i]);
d229 1
a229 1
		rt_log("Solid\n");
d236 1
a236 1
				rt_log("\tVector\n");
d255 8
a262 1
					rt_log("\t\tDraw 0 -> %g, step %g\n", len, step);
d288 1
a288 1
	return CMD_OK;
@


11.2
log
@*** empty log message ***
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 11.1 1995/01/04 10:03:13 mike Rel4_4 bparker $ (ARL)";
a67 6

#ifndef MULTI_ATTACH
extern mat_t view2model;
extern mat_t model2view;
#endif

@


11.1
log
@Release_4.4
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/hideline.c,v 10.9 94/12/27 18:15:42 mike Exp $ (ARL)";
d69 1
d72 2
@


10.9
log
@Added RCSid
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


10.8
log
@Skip per vertex normal.
@
text
@d19 5
d29 3
a31 3
 *
 * History -
 *	01 Aug 88		Began initial coding
d33 3
@


10.7
log
@Mod for CRAY.
@
text
@d227 1
@


10.6
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@a141 1
	extern int 	hit_headon(),hit_tangent(),hit_overlap();
@


10.5
log
@Irix 6
@
text
@d82 1
a82 1
		printf("hit_headon: multiple partitions\n");
d156 1
a156 1
		(void)printf("f_hideline: unable to open \"%s\" for writing.\n",
d173 1
a173 1
	(void)printf("Generating hidden-line drawing of the following regions:\n");
d175 1
a175 1
		printf("\t%s\n",objname[i]);
d179 1
a179 1
		printf("f_hideline: unable to open model file \"%s\"\n",
d205 1
a205 1
			printf("f_hideline: rt_gettree failed on \"%s\"\n",objname[i]);
d218 1
a218 1
		printf("Solid\n");
d225 1
a225 1
				printf("\tVector\n");
d243 1
a243 1
					printf("\t\tDraw 0 -> %g, step %g\n", len, step);
@


10.4
log
@ged.h goes first
@
text
@d143 1
a143 1
	int 	i,j,numobjs;
@


10.3
log
@Factored ifdefs
@
text
@d39 1
d42 1
a42 1
#include "externs.h"
a44 1
#include "./ged.h"
@


10.2
log
@Modified functions to use new command return codes.
@
text
@d29 2
d32 3
a34 1
#ifdef BSD
a35 2
#else
#include <string.h>
a45 3
#ifdef gould
#define MAXOBJECTS	1000
#else
d47 1
a47 1
#endif /* gould */
@


10.1
log
@Release_4.0
@
text
@d42 1
a61 1
extern float Viewscale;
d159 1
a159 1
		return(1);
d182 1
a182 1
		return(1);
d270 1
a270 1
	return(0);
@


9.4
log
@changed to argc/argv.
Reorganized so static functions are known before referenced.
@
text
@@


9.3
log
@Modified for new rt_vlist structures
@
text
@d60 1
a60 2
extern int numargs;
extern char *cmd_args[];	/* array of pointers to args */
d69 67
d137 3
a139 1
f_hideline()
d156 1
a156 1
	if ((plotfp = fopen(cmd_args[1],"w")) == NULL) {
d158 1
a158 1
		    cmd_args[1]);
d194 2
a195 2
	if (numargs > 2) {
		sscanf(cmd_args[2],"%f",&step);
d197 1
a197 1
		sscanf(cmd_args[3],"%f",&epsilon);
a270 64
}

/*
 * hit_headon - routine called by rt_shootray if ray hits model
 */

static int
hit_headon(ap,PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	register char diff_solid;
	vect_t	diff;
	register fastf_t len;

	if (PartHeadp->pt_forw->pt_forw != PartHeadp)
		printf("hit_headon: multiple partitions\n");

	VJOIN1(PartHeadp->pt_forw->pt_inhit->hit_point,ap->a_ray.r_pt,
	    PartHeadp->pt_forw->pt_inhit->hit_dist, ap->a_ray.r_dir);
	VSUB2(diff,PartHeadp->pt_forw->pt_inhit->hit_point,aim_point);

	diff_solid = strcmp(sp->s_path[0]->d_namep,
	    PartHeadp->pt_forw->pt_inseg->seg_stp->st_name);
	len = MAGNITUDE(diff);

	if (	NEAR_ZERO(len,epsilon)
	    ||
	    ( diff_solid &&
	    VDOT(diff,ap->a_ray.r_dir) > 0 )
	    )
		return(1);
	else
		return(0);
}

/*
 * hit_tangent - routine called by rt_shootray if ray misses model
 *
 *     We know we are shooting at the model since we are aiming at the
 *     vector list MGED created. However, shooting at an edge or shooting
 *     tangent to a curve produces only one intersection point at which
 *     time rt_shootray reports a miss. Therefore, this routine is really
 *     a "hit" routine.
 */

static int
hit_tangent(ap,PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	return(1);		/* always a hit */
}

/*
 * hit_overlap - called by rt_shootray if ray hits an overlap
 */

static int
hit_overlap(ap,PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	return(0);		/* never a hit */
@


9.2
log
@Changed "enmg" to "ev", for "evaluate".
Move parallel processsing startup from hideline to ged.c
@
text
@d54 4
a57 5
#define DRAW(v)	{ vect_t t;\
		  MAT4X3PNT(t,model2view,last_move);\
		  pl_move(plotfp,(int)(2048*t[X]),(int)(2048*t[Y]));\
		  MAT4X3PNT(t,model2view,(v));\
		  pl_cont(plotfp,(int)(2048*t[X]),(int)(2048*t[Y])); }
d73 14
a86 14
    FILE 	*plotfp;
    char 	visible;
    extern int 	hit_headon(),hit_tangent(),hit_overlap();
    int 	i,j,numobjs;
    char 	*objname[MAXOBJECTS],title[1];
    fastf_t 	len,u,step;
    FAST float 	ratio;
    vect_t	last_move;
    struct rt_i	*rtip;
    struct resource resource;
    struct application a;
    vect_t temp;
    vect_t last,dir;
    register struct vlist *vp;
d88 6
a93 9
/*
 * Open Unix-plot file and initialize
 */
    if ((plotfp = fopen(cmd_args[1],"w")) == NULL) {
	(void)printf("f_hideline: unable to open \"%s\" for writing.\n",
								cmd_args[1]);
	return(1);
    }
    pl_space(plotfp,-2048,-2048,2048,2048);
d95 9
a103 8
/*
 * Build list of objects being viewed
 */
    numobjs = 0;
    FOR_ALL_SOLIDS(sp) {
	for (i = 0; i < numobjs; i++)  {
		if( objname[i] == sp->s_path[0]->d_namep )
			break;
a104 3
	if (i == numobjs)
	    objname[numobjs++] = sp->s_path[0]->d_namep;
    }
d106 3
a108 6
    (void)printf("Generating hidden-line drawing of the following regions:\n");
    for (i = 0; i < numobjs; i++)
	printf("\t%s\n",objname[i]);
/*
 * Initialization for librt
 */
d110 15
a124 14
    if ((rtip = rt_dirbuild(dbip->dbi_filename,title,0)) == RTI_NULL) {
	printf("f_hideline: unable to open model file \"%s\"\n",
		dbip->dbi_filename);
	return(1);
    }
    a.a_hit = hit_headon;
    a.a_miss = hit_tangent;
    a.a_overlap = hit_overlap;
    a.a_rt_i = rtip;
    a.a_resource = &resource;
    a.a_level = 0;
    a.a_onehit = 1;
    a.a_diverge = 0;
    a.a_rbeam = 0;
d126 9
a134 9
    if (numargs > 2) {
	sscanf(cmd_args[2],"%f",&step);
	step = Viewscale/step;
	sscanf(cmd_args[3],"%f",&epsilon);
	epsilon *= Viewscale/100;
    } else {
	step = Viewscale/256;
	epsilon = 0.1*Viewscale;
    }
d136 3
a138 9
    for (i = 0; i < numobjs; i++)
	if (rt_gettree(rtip,objname[i]) == -1)
	    printf("f_hideline: rt_gettree failed on \"%s\"\n",objname[i]);
/*
 * Crawl along the vectors raytracing as we go
 */
    VSET(temp,0,0,-1);				/* looking at model */
    MAT4X3VEC(a.a_ray.r_dir,view2model,temp);
    VUNITIZE(a.a_ray.r_dir);
d140 4
a143 1
    FOR_ALL_SOLIDS(sp) {
d145 53
a197 25
	ratio = sp->s_size / VIEWSIZE;		/* ignore if small or big */
	if (ratio >= dmp->dmr_bound || ratio < 0.001)
	    continue;
	
printf("Solid\n");
	for (vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw ) {
printf("\tVector\n");
	    if (vp->vl_draw == 0) {		/* move */
		VMOVE(last,vp->vl_pnt);
		MOVE(last);
	    } else {
		VSUB2(dir,vp->vl_pnt,last);	/* setup direction && length */
		len = MAGNITUDE(dir);
		VUNITIZE(dir);
		visible = FALSE;
printf("\t\tDraw 0 -> %g, step %g\n", len, step);
		for (u = 0; u <= len; u += step) {
		    VJOIN1(aim_point,last,u,dir);
		    MAT4X3PNT(temp,model2view,aim_point);
		    temp[Z] = 100;			/* parallel project */
		    MAT4X3PNT(a.a_ray.r_pt,view2model,temp);
		    if (rt_shootray(&a)) {
			if (!visible) {
			    visible = TRUE;
			    MOVE(aim_point);
a198 6
		    } else {
			if (visible) {
			    visible = FALSE;
			    DRAW(aim_point);
			}
		    }
a199 4
		if (visible)
		    DRAW(aim_point);
		VMOVE(last,vp->vl_pnt);		/* new last vertex */
	    }
d201 2
a202 4
    }
    fprintf(plotfp,"PG;");
    fclose(plotfp);
    return(0);
d214 3
a216 3
    register char diff_solid;
    vect_t	diff;
    register fastf_t len;
d218 2
a219 2
    if (PartHeadp->pt_forw->pt_forw != PartHeadp)
	printf("hit_headon: multiple partitions\n");
d221 3
a223 3
    VJOIN1(PartHeadp->pt_forw->pt_inhit->hit_point,ap->a_ray.r_pt,
	   PartHeadp->pt_forw->pt_inhit->hit_dist, ap->a_ray.r_dir);
    VSUB2(diff,PartHeadp->pt_forw->pt_inhit->hit_point,aim_point);
d225 3
a227 3
    diff_solid = strcmp(sp->s_path[0]->d_namep,
		 PartHeadp->pt_forw->pt_inseg->seg_stp->st_name);
    len = MAGNITUDE(diff);
d229 8
a236 8
    if (	NEAR_ZERO(len,epsilon)
       ||
		( diff_solid &&
	          VDOT(diff,ap->a_ray.r_dir) > 0 )
       )
	return(1);
    else
	return(0);
d254 1
a254 1
    return(1);		/* always a hit */
d266 1
a266 1
    return(0);		/* never a hit */
@


9.1
log
@Release_3.5
@
text
@a117 4
    RES_INIT( &rt_g.res_syscall );
    RES_INIT( &rt_g.res_worker );
    RES_INIT( &rt_g.res_stats );
    RES_INIT( &rt_g.res_results );
@


1.6
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@@


1.5
log
@ansii cleanup
@
text
@d39 1
@


1.4
log
@string -vs- strings
@
text
@d83 3
a85 3
    register struct application a;
    register vect_t temp;
    register vect_t last,dir;
d213 1
a213 1
    register vect_t diff;
@


1.3
log
@Changed to reduce stack usage by 40X;  needed to get stack
to fit into 64k on sgi 3d.
@
text
@d30 3
d34 2
@


1.2
log
@Initial cleanups
@
text
@a38 1
#define NAMELEN		40
a40 1
#define NAMELEN		80
d72 1
a72 1
    char 	objname[MAXOBJECTS][NAMELEN],title[1];
d98 4
a101 3
	for (i = 0; i < numobjs; i++)
	    if (!strcmp(objname[i],sp->s_path[0]->d_namep))
		break;
d103 1
a103 1
	    strncpy(objname[numobjs++],sp->s_path[0]->d_namep,NAMELEN);
@


1.1
log
@As received from UA Huntsville (based on 2.3)
@
text
@a10 5
 *	cmd.c must be changed to allow this routine to be called. Since
 *	MGED currently uses floats and libfb uses doubles, a special version
 *	of libfb.a must be created using floats. This means that a special
 *	version of raytrace.h is needed too.
 *
d31 1
a31 1
#include "./machine.h"		/* special copy */
d33 3
a35 3
#include "solid.h"
#include "./raytrace.h"		/* special copy w/out GETSTRUCT def */
#include "dm.h"
d37 4
d43 1
d56 1
a56 1
extern char *filename;		/* file name of database */
d73 1
a73 1
    int 	i,j,n,numobjs;
d83 1
a83 1
    register struct veclist *vp;
d91 1
a91 1
	return(0);
d98 1
d118 3
a120 2
    if ((rtip = rt_dirbuild(filename,title,0)) == RTI_NULL) {
	printf("f_hideline: unable to open model file \"%s\"\n",filename);
d159 4
a162 3
	n = sp->s_vlen;
	for (vp = sp->s_vlist; n--; vp++)
	    if (vp->vl_pen == PEN_UP) {
d170 1
d181 1
a181 1
		    } else
d186 1
d192 1
d196 1
@
