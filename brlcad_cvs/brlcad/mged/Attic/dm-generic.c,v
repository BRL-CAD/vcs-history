head	1.36;
access;
symbols
	ansi-20040405-merged:1.32.4.1
	postmerge-20040405-ansi:1.34
	premerge-20040404-ansi:1.34
	postmerge-autoconf:1.34
	autoconf-freeze:1.33.4.1
	premerge-autoconf:1.34
	postmerge-20040315-windows:1.34
	premerge-20040315-windows:1.33
	windows-20040315-freeze:1.32.6.2
	autoconf-20031203:1.33
	autoconf-20031202:1.33
	autoconf-branch:1.33.0.4
	phong-branch:1.33.0.2
	photonmap-branch:1.32.0.8
	rel-6-1-DP:1.32
	windows-branch:1.32.0.6
	rel-6-0-2:1.32
	ansi-branch:1.32.0.4
	rel-6-0-1-branch:1.32.0.2
	hartley-6-0-post:1.32
	hartley-6-0-pre:1.32
	rel-6-0-1:1.32
	rel-6-0:1.32
	rel-5-4:1.22.2.4
	offsite-5-3-pre:1.26
	rel-5-3:1.22.2.4
	rel-5-2:1.22
	rel-5-1-branch:1.22.0.2
	rel-5-1:1.22
	rel-5-0:1.20
	rel-5-0-beta:1.18;
locks; strict;
comment	@ * @;


1.36
date	2004.05.21.17.47.39;	author morrison;	state dead;
branches;
next	1.35;

1.35
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.17.00.37.14;	author morrison;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	2001.10.17.07.40.04;	author morrison;	state Exp;
branches
	1.32.4.1
	1.32.6.1
	1.32.8.1;
next	1.31;

1.31
date	2001.06.18.19.24.23;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.01.19.23.23;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.05.19.35.44;	author morrison;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.02.18.10.11;	author jra;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.16.22.43.43;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.23.14.30.59;	author jra;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.20.21.51.40;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.18.14.23.14;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	99.12.30.20.24.14;	author jra;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	99.12.01.14.06.36;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	99.09.01.21.27.04;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	99.07.09.13.47.33;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	99.04.07.16.45.31;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	99.03.09.21.38.56;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	98.12.30.22.10.09;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	98.11.13.22.30.49;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	98.11.06.22.30.19;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	98.10.21.17.08.24;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	98.06.29.20.49.14;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	98.06.15.18.52.14;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	98.06.12.19.45.38;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	98.06.11.14.28.10;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	98.05.18.19.35.09;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	98.05.01.21.13.12;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	98.04.23.12.52.54;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	98.04.10.18.22.12;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.04.07.14.58.53;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.04.01.22.24.38;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.03.06.22.31.20;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.02.26.15.59.36;	author bparker;	state Exp;
branches;
next	;

1.22.2.1
date	2000.10.18.14.03.07;	author bparker;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2000.10.20.21.50.46;	author bparker;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.01.05.15.12.32;	author jra;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.02.09.15.26.31;	author bparker;	state Exp;
branches;
next	;

1.32.4.1
date	2004.03.17.21.21.56;	author morrison;	state Exp;
branches;
next	;

1.32.6.1
date	2002.09.26.23.04.09;	author morrison;	state Exp;
branches;
next	1.32.6.2;

1.32.6.2
date	2004.03.11.23.46.34;	author morrison;	state Exp;
branches;
next	;

1.32.8.1
date	2003.08.26.14.03.43;	author justin;	state Exp;
branches;
next	;

1.33.4.1
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Routines common to MGED's interface to LIBDM.
@


1.36
log
@moved to src/mged/
@
text
@/*
 *			D M - G E N E R I C . C
 *
 * Routines common to MGED's interface to LIBDM.
 *
 * Author -
 *	Robert G. Parker
 *
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <ctype.h>
#include <sys/types.h>

#ifdef DM_X 
#  include "tk.h"
#  include <X11/Xutil.h>
#  include "dm_xvars.h"
#else
#  include "tcl.h"
#endif

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "./ged.h"
#include "./sedit.h"
#include "./mged_dm.h"

extern point_t e_axes_pos;
extern point_t curr_e_axes_pos;
extern int scroll_select();		/* defined in scroll.c */
extern int menu_select();		/* defined in menu.c */
extern void rect_view2image();		/* defined in rect.c */
extern void rb_set_dirty_flag();

int doMotion = 0;

#ifdef DM_X
struct bu_structparse dm_xvars_vparse[] = {
	{"%x",	1,	"dpy",			XVARS_MV_O(dpy),	BU_STRUCTPARSE_FUNC_NULL },
	{"%x",	1,	"win",			XVARS_MV_O(win),	BU_STRUCTPARSE_FUNC_NULL },
	{"%x",	1,	"top",			XVARS_MV_O(top),	BU_STRUCTPARSE_FUNC_NULL },
	{"%x",	1,	"tkwin",		XVARS_MV_O(xtkwin),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1,	"depth",		XVARS_MV_O(depth),	BU_STRUCTPARSE_FUNC_NULL },
	{"%x",	1,	"cmap",			XVARS_MV_O(cmap),	BU_STRUCTPARSE_FUNC_NULL },
	{"%x",	1,	"vip",			XVARS_MV_O(vip),	BU_STRUCTPARSE_FUNC_NULL },
	{"%x",	1,	"fontstruct",		XVARS_MV_O(fontstruct),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1,	"devmotionnotify",	XVARS_MV_O(devmotionnotify),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1,	"devbuttonpress",	XVARS_MV_O(devbuttonpress),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1,	"devbuttonrelease",	XVARS_MV_O(devbuttonrelease),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0,	(char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};
#endif

/*
 *  Based upon new state, possibly do extra stuff,
 *  including enabling continuous tablet tracking,
 *  object highlighting.
 *
 *  This routine was taken and modified from the original dm-X.c
 *  that was written by Phil Dykstra.
 */
void
stateChange(a, b)
int a, b;
{
  switch( b )  {
  case ST_VIEW:
    /* constant tracking OFF */
    doMotion = 0;
    break;
  case ST_S_PICK:
  case ST_O_PICK:
  case ST_O_PATH:
  case ST_S_VPICK:
    /* constant tracking ON */
    doMotion = 1;
    break;
  case ST_O_EDIT:
  case ST_S_EDIT:
    /* constant tracking OFF */
    doMotion = 0;
    break;
  default:
    bu_log("statechange: unknown state %s\n", state_str[b]);
    break;
  }

  ++update_views;
}

int
common_dm(argc, argv)
int argc;
char **argv;
{
  int status;
  struct bu_vls vls;

  if (dbip == DBI_NULL)
	  return TCL_OK;

  if(!strcmp(argv[0], "idle")){
    am_mode = AMM_IDLE;
    scroll_active = 0;
    if(rubber_band->rb_active){
      rubber_band->rb_active = 0;

      if(mged_variables->mv_mouse_behavior == 'p')
	rb_set_dirty_flag();
      else if(mged_variables->mv_mouse_behavior == 'r')
	rt_rect_area();
      else if(mged_variables->mv_mouse_behavior == 'z')
	zoom_rect_area();
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "m")){
    int x;
    int y;
    int old_orig_gui;
    int stolen = 0;
    fastf_t fx, fy;

    if(argc < 3){
      Tcl_AppendResult(interp, "dm m: need more parameters\n",
		       "dm m xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    old_orig_gui = mged_variables->mv_orig_gui;

    fx = dm_Xx2Normal(dmp, atoi(argv[1]));
    fy = dm_Xy2Normal(dmp, atoi(argv[2]), 0);
    x = fx * GED_MAX;
    y = fy * GED_MAX;

    if(mged_variables->mv_faceplate &&
       mged_variables->mv_orig_gui){
#define        MENUXLIM        (-1250)

      if(x >= MENUXLIM && scroll_select(x, y, 0)){
	stolen = 1;
	goto end;
      }

      if(x < MENUXLIM && mmenu_select(y, 0)){
	stolen = 1;
	goto end;
      }
    }

    mged_variables->mv_orig_gui = 0;
    fy = dm_Xy2Normal(dmp, atoi(argv[2]), 1);
    y = fy * GED_MAX;

end:
    bu_vls_init(&vls);
    if(mged_variables->mv_mouse_behavior == 'q' && !stolen){
      point_t view_pt;
      point_t model_pt;

      if(grid_state->gr_snap)
	snap_to_grid(&fx, &fy);

      if( mged_variables->mv_perspective_mode )
            VSET(view_pt, fx, fy, 0.0)
      else
            VSET(view_pt, fx, fy, 1.0)

      MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
      VSCALE(model_pt, model_pt, base2local);
      if(dmp->dm_zclip)
	bu_vls_printf(&vls, "qray_nirt %lf %lf %lf",
		      model_pt[X], model_pt[Y], model_pt[Z]);
      else
	bu_vls_printf(&vls, "qray_nirt -b %lf %lf %lf",
		      model_pt[X], model_pt[Y], model_pt[Z]);
    }else if((mged_variables->mv_mouse_behavior == 'p' ||
	      mged_variables->mv_mouse_behavior == 'r' ||
	      mged_variables->mv_mouse_behavior == 'z') && !stolen){

      if(grid_state->gr_snap)
	snap_to_grid(&fx, &fy);

      rubber_band->rb_active = 1;
      rubber_band->rb_x = fx;
      rubber_band->rb_y = fy;
      rubber_band->rb_width = 0.0;
      rubber_band->rb_height = 0.0;
      rect_view2image();
      rb_set_dirty_flag();
    }else if(mged_variables->mv_mouse_behavior == 's' && !stolen){
#if 0
      if(grid_state->gr_snap){
	snap_to_grid(&fx, &fy);
	x = fx * GED_MAX;
	y = fy * GED_MAX;
      }
#endif
      bu_vls_printf(&vls, "mouse_solid_edit_select %d %d", x, y);
    }else if(mged_variables->mv_mouse_behavior == 'm' && !stolen){
#if 0
      if(grid_state->gr_snap){
	snap_to_grid(&fx, &fy);
	x = fx * GED_MAX;
	y = fy * GED_MAX;
      }
#endif
      bu_vls_printf(&vls, "mouse_matrix_edit_select %d %d", x, y);
    }else if(mged_variables->mv_mouse_behavior == 'c' && !stolen){
#if 0
      if(grid_state->gr_snap){
	snap_to_grid(&fx, &fy);
	x = fx * GED_MAX;
	y = fy * GED_MAX;
      }
#endif
      bu_vls_printf(&vls, "mouse_comb_edit_select %d %d", x, y);
    } else if(mged_variables->mv_mouse_behavior == 'o' && !stolen){
#if 0
      if(grid_state->gr_snap){
	snap_to_grid(&fx, &fy);
	x = fx * GED_MAX;
	y = fy * GED_MAX;
      }
#endif
      bu_vls_printf(&vls, "mouse_rt_obj_select %d %d", x, y);
    }else if(adc_state->adc_draw && mged_variables->mv_transform == 'a' && !stolen) {
      point_t model_pt;
      point_t view_pt;

      if(grid_state->gr_snap)
	snap_to_grid(&fx, &fy);

      VSET(view_pt, fx, fy, 1.0);
      MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
      VSCALE(model_pt, model_pt, base2local);
      bu_vls_printf(&vls, "adc xyz %lf %lf %lf\n", model_pt[X], model_pt[Y], model_pt[Z]);
    } else if (grid_state->gr_snap && !stolen &&
	       SEDIT_TRAN && mged_variables->mv_transform == 'e') {
	    point_t view_pt;
	    point_t model_pt;

	    snap_to_grid(&fx, &fy);
	    MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
	    VSCALE(model_pt, model_pt, base2local);
	    bu_vls_printf(&vls, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
    } else if (grid_state->gr_snap && !stolen &&
	       OEDIT_TRAN && mged_variables->mv_transform == 'e') {
	    point_t view_pt;
	    point_t model_pt;

	    snap_to_grid(&fx, &fy);
	    MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
	    VSCALE(model_pt, model_pt, base2local);
	    bu_vls_printf(&vls, "translate %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
    } else if (grid_state->gr_snap && !stolen &&
	       state != ST_S_PICK && state != ST_O_PICK &&
	       state != ST_O_PATH && !SEDIT_PICK && !EDIT_SCALE) {
	    point_t view_pt;
	    point_t model_pt;
	    point_t vcenter;

	    snap_to_grid(&fx, &fy);
	    MAT_DELTAS_GET_NEG(vcenter, view_state->vs_vop->vo_center);
	    MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, vcenter);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
	    VSCALE(model_pt, model_pt, base2local);
	    bu_vls_printf(&vls, "center %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
    } else
	    bu_vls_printf(&vls, "M 1 %d %d\n", x, y);

    status = Tcl_Eval(interp, bu_vls_addr(&vls));
    mged_variables->mv_orig_gui = old_orig_gui;
    bu_vls_free(&vls);

    return status;
  }

  if(!strcmp(argv[0], "am")){
    if(argc < 4){
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "dm am <r|t|s> xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    dml_omx = atoi(argv[2]);
    dml_omy = atoi(argv[3]);

    switch(*argv[1]){
    case 'r':
      am_mode = AMM_ROT;
      break;
    case 't':
      am_mode = AMM_TRAN;

      if(grid_state->gr_snap){
	int save_edflag;

	if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	   mged_variables->mv_transform == 'e'){
	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_TRAN)
	      es_edflag = STRANS;
	  }else{
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }

	  snap_keypoint_to_grid();

	  if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	  else
	    edobj = save_edflag;
	}else
	  snap_view_center_to_grid();
      }

      break;
    case 's':
      if(state == ST_S_EDIT && mged_variables->mv_transform == 'e' &&
	 NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	acc_sc_sol = 1.0;
      else if(state == ST_O_EDIT && mged_variables->mv_transform == 'e'){
	edit_absolute_scale = acc_sc_obj - 1.0;
	if(edit_absolute_scale > 0.0)
	  edit_absolute_scale /= 3.0;
      }

      am_mode = AMM_SCALE;
      break;
    default:
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "dm am <r|t|s> xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "adc")){
    fastf_t fx, fy;
    fastf_t td; /* tick distance */

    if(argc < 4){
      Tcl_AppendResult(interp, "dm adc: need more parameters\n",
		       "dm adc 1|2|t|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    dml_omx = atoi(argv[2]);
    dml_omy = atoi(argv[3]);

    switch(*argv[1]){
    case '1':
      fx = dm_Xx2Normal(dmp, dml_omx) * GED_MAX - adc_state->adc_dv_x;
      fy = dm_Xy2Normal(dmp, dml_omy, 1) * GED_MAX - adc_state->adc_dv_y;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc a1 %lf\n", RAD2DEG*atan2(fy, fx));
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_ANG1;
      break;
    case '2':
      fx = dm_Xx2Normal(dmp, dml_omx) * GED_MAX - adc_state->adc_dv_x;
      fy = dm_Xy2Normal(dmp, dml_omy, 1) * GED_MAX - adc_state->adc_dv_y;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc a2 %lf\n", RAD2DEG*atan2(fy, fx));
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_ANG2;
      break;
    case 't':
      {
	point_t model_pt;
	point_t view_pt;

	bu_vls_init(&vls);

	VSET(view_pt, dm_Xx2Normal(dmp, dml_omx), dm_Xy2Normal(dmp, dml_omy, 1), 0.0);

	if(grid_state->gr_snap)
	  snap_to_grid(&view_pt[X], &view_pt[Y]);

	MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);

	bu_vls_printf(&vls, "adc xyz %lf %lf %lf\n", model_pt[X], model_pt[Y], model_pt[Z]);
	Tcl_Eval(interp, bu_vls_addr(&vls));

	bu_vls_free(&vls);
	am_mode = AMM_ADC_TRAN;
      }

      break;
    case 'd':
      fx = (dm_Xx2Normal(dmp, dml_omx) * GED_MAX -
	    adc_state->adc_dv_x) * view_state->vs_vop->vo_scale * base2local * INV_GED;
      fy = (dm_Xy2Normal(dmp, dml_omy, 1) * GED_MAX -
	    adc_state->adc_dv_y) * view_state->vs_vop->vo_scale * base2local * INV_GED;

      td = sqrt(fx * fx + fy * fy);
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc dst %lf\n", td);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_DIST;
      break;
      default:
	Tcl_AppendResult(interp, "dm adc: unrecognized parameter - ", argv[1],
			 "\ndm adc 1|2|t|d xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "con")){
    if(argc < 5){
      Tcl_AppendResult(interp, "dm con: need more parameters\n",
		       "dm con r|t|s x|y|z xpos ypos\n",
		       "dm con a x|y|1|2|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    dml_omx = atoi(argv[3]);
    dml_omy = atoi(argv[4]);

    switch(*argv[1]){
    case 'a':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_XADC;
	break;
      case 'y':
	am_mode = AMM_CON_YADC;
	break;
      case '1':
	am_mode = AMM_CON_ANG1;
	break;
      case '2':
	am_mode = AMM_CON_ANG2;
	break;
      case 'd':
	am_mode = AMM_CON_DIST;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con a x|y|1|2|d xpos ypos\n", (char *)NULL);
      }
      break;
    case 'r':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_ROT_X;
	break;
      case 'y':
	am_mode = AMM_CON_ROT_Y;
	break;
      case 'z':
	am_mode = AMM_CON_ROT_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    case 't':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_TRAN_X;
	break;
      case 'y':
	am_mode = AMM_CON_TRAN_Y;
	break;
      case 'z':
	am_mode = AMM_CON_TRAN_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    case 's':
      switch(*argv[2]){
      case 'x':
	if(state == ST_S_EDIT && mged_variables->mv_transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->mv_transform == 'e'){
	  edit_absolute_scale = acc_sc[0] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_X;
	break;
      case 'y':
	if(state == ST_S_EDIT && mged_variables->mv_transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->mv_transform == 'e'){
	  edit_absolute_scale = acc_sc[1] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_Y;
	break;
      case 'z':
	if(state == ST_S_EDIT && mged_variables->mv_transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->mv_transform == 'e'){
	  edit_absolute_scale = acc_sc[2] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    default:
      Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[1],
		       "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "size")){
    int width, height;

    /* get the window size */
    if(argc == 1){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d", dmp->dm_width, dmp->dm_height);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }

    /* set the window size */
    if( argc == 3 ){
      width = atoi( argv[1] );
      height = atoi( argv[2] );

#ifdef DM_X
#  if 0
      Tk_ResizeWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, width, height);
#  else
      Tk_GeometryRequest(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, width, height);
#  endif
#endif

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "Usage: dm size [width height]\n", (char *)NULL);
    return TCL_ERROR;
  }

#ifdef DM_X
  if(!strcmp(argv[0], "getx")){
    if(argc == 1){
      struct bu_vls tmp_vls;

      bu_vls_init(&tmp_vls);
      /* Bare set command, print out current settings */
      bu_vls_struct_print2(&tmp_vls, "dm internal X variables", dm_xvars_vparse,
		      (const char *)dmp->dm_vars.pub_vars);
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);
    }else if(argc == 2){
      bu_vls_init(&vls);
      bu_vls_struct_item_named(&vls, dm_xvars_vparse, argv[1],
			       (const char *)dmp->dm_vars.pub_vars, ',');
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
    }

    return TCL_OK;
  }
#endif

  if(!strcmp(argv[0], "bg")){
    int r, g, b;

    if(argc != 1 && argc != 4){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "Usage: dm bg [r g b]");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    /* return background color of current display manager */
    if (argc == 1) {
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d %d",
		    dmp->dm_bg[0],
		    dmp->dm_bg[1],
		    dmp->dm_bg[2]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
      
      return TCL_OK;
    }

    if(sscanf(argv[1], "%d", &r) != 1 ||
       sscanf(argv[2], "%d", &g) != 1 ||
       sscanf(argv[3], "%d", &b) != 1){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "Usage: dm bg r g b");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    dirty = 1;
    return DM_SET_BGCOLOR(dmp, r, g, b);
  }

  Tcl_AppendResult(interp, "dm: bad command - ", argv[0], "\n", (char *)NULL);
  return TCL_ERROR;
}
@


1.35
log
@change conf.h to a wrapped config.h
@
text
@@


1.34
log
@merge of windows-6-0-branch into head
@
text
@d16 5
a20 1
#include "conf.h"
@


1.33
log
@re-fixed defines so that mged will build undependantly -- X is not *required*
@
text
@d23 1
a23 1
#ifdef DM_X
@


1.33.4.1
log
@merge from head
@
text
@d23 1
a23 1
#ifdef DM_X 
@


1.32
log
@Mac OS X warning and error fixes for non-production build
@
text
@d26 1
a42 1
#include "dm_xvars.h"
d56 1
d71 1
d593 2
a594 1
#if 0
d596 1
a596 1
#else
d598 1
d608 1
d629 1
@


1.32.4.1
log
@sync branch with HEAD
@
text
@d23 1
a23 1
#ifdef DM_X 
a25 1
#  include "dm_xvars.h"
d42 1
a55 1
#ifdef DM_X
a69 1
#endif
d591 1
a591 2
#ifdef DM_X
#  if 0
d593 1
a593 1
#  else
a594 1
#  endif
a603 1
#ifdef DM_X
a623 1
#endif
@


1.32.8.1
log
@updated for merging
@
text
@a25 1
#  include "dm_xvars.h"
d42 1
a55 1
#ifdef DM_X
a69 1
#endif
d591 1
a591 2
#ifdef DM_X
#  if 0
d593 1
a593 1
#  else
a594 1
#  endif
a603 1
#ifdef DM_X
a623 1
#endif
@


1.32.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d23 1
a23 1
#ifdef DM_X 
@


1.32.6.2
log
@sync to HEAD...
@
text
@a25 1
#  include "dm_xvars.h"
d42 1
a55 1
#ifdef DM_X
a69 1
#endif
d591 1
a591 2
#ifdef DM_X
#  if 0
d593 1
a593 1
#  else
a594 1
#  endif
a603 1
#ifdef DM_X
a623 1
#endif
@


1.31
log
@*- remove use of start/stop_catching_output().
   Use routines that write directly to a vls.
@
text
@d23 6
a28 2
#include "tk.h"
#include <X11/Xutil.h>
@


1.30
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@a604 2
      start_catching_output(&tmp_vls);

d606 1
a606 1
      bu_struct_print("dm internal X variables", dm_xvars_vparse,
a607 2

      stop_catching_output(&tmp_vls);
@


1.29
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@a184 1
#ifdef MGED_USE_VIEW_OBJ
a185 3
#else
      MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
#endif
a250 1
#ifdef MGED_USE_VIEW_OBJ
a251 3
#else
      MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
#endif
a259 1
#ifdef MGED_USE_VIEW_OBJ
a263 6
#else
	    MAT4X3PNT(view_pt, view_state->vs_model2view, curr_e_axes_pos);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
#endif
a271 1
#ifdef MGED_USE_VIEW_OBJ
a275 6
#else
	    MAT4X3PNT(view_pt, view_state->vs_model2view, curr_e_axes_pos);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
#endif
a285 1
#ifdef MGED_USE_VIEW_OBJ
a290 7
#else
	    MAT_DELTAS_GET_NEG(vcenter, view_state->vs_toViewcenter);
	    MAT4X3PNT(view_pt, view_state->vs_model2view, vcenter);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
#endif
a413 1
#ifdef MGED_USE_VIEW_OBJ
a414 3
#else
	MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
#endif
a425 1
#ifdef MGED_USE_VIEW_OBJ
a429 6
#else
      fx = (dm_Xx2Normal(dmp, dml_omx) * GED_MAX -
	    adc_state->adc_dv_x) * view_state->vs_Viewscale * base2local * INV_GED;
      fy = (dm_Xy2Normal(dmp, dml_omy, 1) * GED_MAX -
	    adc_state->adc_dv_y) * view_state->vs_Viewscale * base2local * INV_GED;
#endif
@


1.28
log
@updated SIGNED to signed
updated CONST to const
@
text
@d185 3
d189 1
d255 3
d259 1
d268 6
d278 1
d287 6
d297 1
d308 7
d320 1
d444 3
d448 1
d460 6
d470 1
@


1.27
log
@Lint
@
text
@d609 1
a609 1
		      (CONST char *)dmp->dm_vars.pub_vars);
d617 1
a617 1
			       (CONST char *)dmp->dm_vars.pub_vars, ',');
@


1.26
log
@*- check if (dbip == DBI_NULL) before doing anything
@
text
@d26 6
@


1.25
log
@Mods to get query ray to work in perspective mode
@
text
@d106 3
@


1.24
log
@No snapping applied to solid, object,
comb or rt-object select.
@
text
@d171 5
a175 1
      VSET(view_pt, fx, fy, 1.0);
@


1.23
log
@Mods to make snap-to-grid work while in Object Edit.
@
text
@d195 1
d201 1
a201 1
      
d204 1
d210 1
a210 1
      
d213 1
d219 1
a219 1
      
d222 1
d228 1
a228 1
      
@


1.22
log
@Eliminated an unused variable
@
text
@d237 41
a277 53
    }else if(grid_state->gr_snap && !stolen &&
	     state != ST_S_PICK && state != ST_O_PICK &&
	     state != ST_O_PATH && !SEDIT_PICK){
      point_t view_pt;
      point_t model_pt;

      snap_to_grid(&fx, &fy);

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->mv_transform == 'e'){

#if 0
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}
#endif

	MAT4X3PNT(view_pt, view_state->vs_model2view, curr_e_axes_pos);
	view_pt[X] = fx;
	view_pt[Y] = fy;
	MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);
	bu_vls_printf(&vls, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	status = Tcl_Eval(interp, bu_vls_addr(&vls));

#if 0
	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;
#endif

	mged_variables->mv_orig_gui = old_orig_gui;
	bu_vls_free(&vls);
	return status;
      }else{
	point_t vcenter;

	MAT_DELTAS_GET_NEG(vcenter, view_state->vs_toViewcenter);
	MAT4X3PNT(view_pt, view_state->vs_model2view, vcenter);
	view_pt[X] = fx;
	view_pt[Y] = fy;
	MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);
	bu_vls_printf(&vls, "center %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
      }
    }else
      bu_vls_printf(&vls, "M 1 %d %d\n", x, y);
@


1.22.2.1
log
@Mods to make snap-to-grid work in Object Edit
@
text
@d237 53
a289 41
    } else if (grid_state->gr_snap && !stolen &&
	       SEDIT_TRAN && mged_variables->mv_transform == 'e') {
	    point_t view_pt;
	    point_t model_pt;

	    snap_to_grid(&fx, &fy);
	    MAT4X3PNT(view_pt, view_state->vs_model2view, curr_e_axes_pos);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
	    VSCALE(model_pt, model_pt, base2local);
	    bu_vls_printf(&vls, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
    } else if (grid_state->gr_snap && !stolen &&
	       OEDIT_TRAN && mged_variables->mv_transform == 'e') {
	    point_t view_pt;
	    point_t model_pt;

	    snap_to_grid(&fx, &fy);
	    MAT4X3PNT(view_pt, view_state->vs_model2view, curr_e_axes_pos);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
	    VSCALE(model_pt, model_pt, base2local);
	    bu_vls_printf(&vls, "translate %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
    } else if (grid_state->gr_snap && !stolen &&
	       state != ST_S_PICK && state != ST_O_PICK &&
	       state != ST_O_PATH && !SEDIT_PICK && !EDIT_SCALE) {
	    point_t view_pt;
	    point_t model_pt;
	    point_t vcenter;

	    snap_to_grid(&fx, &fy);
	    MAT_DELTAS_GET_NEG(vcenter, view_state->vs_toViewcenter);
	    MAT4X3PNT(view_pt, view_state->vs_model2view, vcenter);
	    view_pt[X] = fx;
	    view_pt[Y] = fy;
	    MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
	    VSCALE(model_pt, model_pt, base2local);
	    bu_vls_printf(&vls, "center %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
    } else
	    bu_vls_printf(&vls, "M 1 %d %d\n", x, y);
@


1.22.2.2
log
@No snapping applied to solid, object,
comb or rt-object select.
@
text
@a194 1
#if 0
d200 1
a200 1
#endif
a202 1
#if 0
d208 1
a208 1
#endif
a210 1
#if 0
d216 1
a216 1
#endif
a218 1
#if 0
d224 1
a224 1
#endif
@


1.22.2.3
log
@Mods to get query ray to work in perspective mode
@
text
@d171 1
a171 4
      if( mged_variables->mv_perspective_mode )
	      VSET(view_pt, fx, fy, 0.0)
      else
	      VSET(view_pt, fx, fy, 1.0)
@


1.22.2.4
log
@Mods that check if dbip==DBI_NULL
@
text
@a105 3
  if (dbip == DBI_NULL)
	  return TCL_OK;

@


1.21
log
@*- mods to reflect changes in struct dm
@
text
@a246 1
	int save_edflag = -1;
@


1.20
log
@*- modified common_dm to call qray_nirt instead of nirt
@
text
@d174 1
a174 1
      if(*zclip_ptr)
a622 1
    struct bu_vls vls;
d633 12
a644 2
    if(argc == 1)
      return DM_GET_BGCOLOR(dmp, interp);
@


1.19
log
@*- comment out code that temporarily
   changes es_edflag and edobj
@
text
@d175 1
a175 1
	bu_vls_printf(&vls, "nirt %lf %lf %lf",
d178 1
a178 1
	bu_vls_printf(&vls, "nirt -b %lf %lf %lf",
@


1.18
log
@*- added code to use new mouse_behavior
@
text
@d249 1
d258 1
d268 1
d273 1
@


1.17
log
@*- fixed bug found by jra that caused improper translations
@
text
@d218 8
@


1.16
log
@*- call mouse_matrix_edit_select instead of mouse_object_edit_select
@
text
@d38 1
d250 1
a250 1
	MAT4X3PNT(view_pt, view_state->vs_model2view, e_axes_pos);
@


1.15
log
@*- change mouse_behavior's 'o' to 'm' for matrix.
@
text
@d208 1
a208 1
      bu_vls_printf(&vls, "mouse_object_edit_select %d %d", x, y);
@


1.14
log
@*- use new structures
@
text
@d201 1
a201 1
    }else if(mged_variables->mv_mouse_behavior == 'o' && !stolen){
@


1.13
log
@*- replace some literals with macros
@
text
@d40 2
d108 2
a109 3
    if(rubber_band_active){
      rubber_band_active = 0;
      dirty = 1;
d111 3
a113 1
      if(mged_variables->mouse_behavior == 'r')
d115 1
a115 1
      else if(mged_variables->mouse_behavior == 'z')
d135 1
a135 1
    old_orig_gui = mged_variables->orig_gui;
d142 2
a143 2
    if(mged_variables->faceplate &&
       mged_variables->orig_gui){
d157 1
a157 1
    mged_variables->orig_gui = 0;
d163 1
a163 1
    if(mged_variables->mouse_behavior == 'q' && !stolen){
d167 1
a167 1
      if(mged_variables->grid_snap)
d171 1
a171 1
      MAT4X3PNT(model_pt, view2model, view_pt);
d179 3
a181 3
    }else if((mged_variables->mouse_behavior == 'p' ||
	      mged_variables->mouse_behavior == 'r' ||
	      mged_variables->mouse_behavior == 'z') && !stolen){
d183 1
a183 1
      if(mged_variables->grid_snap)
d186 9
a194 9
      rubber_band_active = 1;
      rect_x = fx;
      rect_y = fy;
      rect_width = 0.0;
      rect_height = 0.0;

      dirty = 1;
    }else if(mged_variables->mouse_behavior == 's' && !stolen){
      if(mged_variables->grid_snap){
d201 2
a202 2
    }else if(mged_variables->mouse_behavior == 'o' && !stolen){
      if(mged_variables->grid_snap){
d209 2
a210 2
    }else if(mged_variables->mouse_behavior == 'c' && !stolen){
      if(mged_variables->grid_snap){
d217 1
a217 1
    }else if(adc_draw && mged_variables->transform == 'a' && !stolen) {
d221 1
a221 1
      if(mged_variables->grid_snap)
d225 1
a225 1
      MAT4X3PNT(model_pt, view2model, view_pt);
d228 1
a228 1
    }else if(mged_variables->grid_snap && !stolen &&
d237 1
a237 1
	 mged_variables->transform == 'e'){
d249 1
a249 1
	MAT4X3PNT(view_pt, model2view, e_axes_pos);
d252 1
a252 1
	MAT4X3PNT(model_pt, view2model, view_pt);
d262 1
a262 1
	mged_variables->orig_gui = old_orig_gui;
d268 2
a269 2
	MAT_DELTAS_GET_NEG(vcenter, toViewcenter);
	MAT4X3PNT(view_pt, model2view, vcenter);
d272 1
a272 1
	MAT4X3PNT(model_pt, view2model, view_pt);
d280 1
a280 1
    mged_variables->orig_gui = old_orig_gui;
d303 1
a303 1
      if(mged_variables->grid_snap){
d307 1
a307 1
	   mged_variables->transform == 'e'){
d329 1
a329 1
      if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
d332 1
a332 1
      else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
d364 2
a365 2
      fx = dm_Xx2Normal(dmp, dml_omx) * GED_MAX - dv_xadc;
      fy = dm_Xy2Normal(dmp, dml_omy, 1) * GED_MAX - dv_yadc;
d375 2
a376 2
      fx = dm_Xx2Normal(dmp, dml_omx) * GED_MAX - dv_xadc;
      fy = dm_Xy2Normal(dmp, dml_omy, 1) * GED_MAX - dv_yadc;
d394 1
a394 1
	if(mged_variables->grid_snap)
d397 1
a397 1
	MAT4X3PNT(model_pt, view2model, view_pt);
d410 1
a410 1
	    dv_xadc) * Viewscale * base2local * INV_GED;
d412 1
a412 1
	    dv_yadc) * Viewscale * base2local * INV_GED;
d502 1
a502 1
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
d505 1
a505 1
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
d514 1
a514 1
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
d517 1
a517 1
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
d526 1
a526 1
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
d529 1
a529 1
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
@


1.12
log
@*- modified common_dm() to handle more cases of snap_to_grid
@
text
@d136 2
a137 2
    x = fx * 2047.0;
    y = fy * 2047.0;
d156 1
a156 1
    y = fy * 2047.0;
d193 2
a194 2
	x = fx * 2047.0;
	y = fy * 2047.0;
d201 2
a202 2
	x = fx * 2047.0;
	y = fy * 2047.0;
d209 2
a210 2
	x = fx * 2047.0;
	y = fy * 2047.0;
d361 2
a362 2
      fx = dm_Xx2Normal(dmp, dml_omx) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, dml_omy, 1) * 2047.0 - dv_yadc;
d372 2
a373 2
      fx = dm_Xx2Normal(dmp, dml_omx) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, dml_omy, 1) * 2047.0 - dv_yadc;
d406 4
a409 4
      fx = (dm_Xx2Normal(dmp, dml_omx) * 2047.0 -
	    dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Xy2Normal(dmp, dml_omy, 1) * 2047.0 -
	    dv_yadc) * Viewscale * base2local / 2047.0;
@


1.11
log
@*- mods to common_dm() (i.e. dm bg  -----> returns background
	rgb of display manager window)
@
text
@d120 6
d132 1
a132 13
    {
      int x;
      int y;
      int old_orig_gui;
      int stolen = 0;
      fastf_t fx, fy;

      old_orig_gui = mged_variables->orig_gui;

      fx = dm_Xx2Normal(dmp, atoi(argv[1]));
      fy = dm_Xy2Normal(dmp, atoi(argv[2]), 0);
      x = fx * 2047.0;
      y = fy * 2047.0;
d134 7
a140 2
      if(mged_variables->faceplate &&
	 mged_variables->orig_gui){
d143 4
a146 4
	if(x >= MENUXLIM && scroll_select(x, y, 0)){
	  stolen = 1;
	  goto end;
	}
d148 3
a150 4
	if(x < MENUXLIM && mmenu_select(y, 0)){
	  stolen = 1;
	  goto end;
	}
d152 1
d154 3
a156 3
      mged_variables->orig_gui = 0;
      fy = dm_Xy2Normal(dmp, atoi(argv[2]), 1);
      y = fy * 2047.0;
d159 7
a165 4
      bu_vls_init(&vls);
      if(mged_variables->mouse_behavior == 'q' && !stolen){
	point_t view_pt;
	point_t model_pt;
d167 12
a178 24
	VSET(view_pt, fx, fy, 1.0);
	MAT4X3PNT(model_pt, view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);
	if(*zclip_ptr)
	  bu_vls_printf(&vls, "nirt %lf %lf %lf",
			model_pt[X], model_pt[Y], model_pt[Z]);
	else
	  bu_vls_printf(&vls, "nirt -b %lf %lf %lf",
			model_pt[X], model_pt[Y], model_pt[Z]);
      }else if((mged_variables->mouse_behavior == 'p' ||
		mged_variables->mouse_behavior == 'r' ||
		mged_variables->mouse_behavior == 'z') && !stolen){
	rubber_band_active = 1;
	rect_x = fx;
	rect_y = fy;
	rect_width = 0.0;
	rect_height = 0.0;

	dirty = 1;
      }else if(mged_variables->grid_snap && !stolen &&
	       state != ST_S_PICK && state != ST_O_PICK &&
	       state != ST_O_PATH && !SEDIT_PICK){
	point_t view_pt;
	point_t model_pt;
d180 1
d183 34
a216 3
	if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	   mged_variables->transform == 'e'){
	  int save_edflag = -1;
d218 2
a219 8
	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_TRAN)
	      es_edflag = STRANS;
	  }else{
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
d221 24
a244 7
	  MAT4X3PNT(view_pt, model2view, e_axes_pos);
	  view_pt[X] = fx;
	  view_pt[Y] = fy;
	  MAT4X3PNT(model_pt, view2model, view_pt);
	  VSCALE(model_pt, model_pt, base2local);
	  bu_vls_printf(&vls, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));
d246 7
a252 4
	  if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	  else
	    edobj = save_edflag;
d254 4
a257 5
	  mged_variables->orig_gui = old_orig_gui;
	  bu_vls_free(&vls);
	  return status;
	}else{
	  point_t vcenter;
d259 16
a274 16
	  MAT_DELTAS_GET_NEG(vcenter, toViewcenter);
	  MAT4X3PNT(view_pt, model2view, vcenter);
	  view_pt[X] = fx;
	  view_pt[Y] = fy;
	  MAT4X3PNT(model_pt, view2model, view_pt);
	  VSCALE(model_pt, model_pt, base2local);
	  bu_vls_printf(&vls, "center %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	}
      }else if(mged_variables->mouse_behavior == 's' && !stolen){
	bu_vls_printf(&vls, "mouse_solid_edit_select %d %d", x, y);
      }else if(mged_variables->mouse_behavior == 'o' && !stolen){
	bu_vls_printf(&vls, "mouse_object_edit_select %d %d", x, y);
      }else if(mged_variables->mouse_behavior == 'c' && !stolen){
	bu_vls_printf(&vls, "mouse_comb_edit_select %d %d", x, y);
      }else
	bu_vls_printf(&vls, "M 1 %d %d\n", x, y);
d276 3
a278 3
      status = Tcl_Eval(interp, bu_vls_addr(&vls));
      mged_variables->orig_gui = old_orig_gui;
      bu_vls_free(&vls);
d280 1
a280 2
      return status;
    }
d390 4
d588 1
a588 1
      bu_struct_print("dm internal variables", dm_xvars_vparse,
@


1.10
log
@*- added "bg" command to common_dm()
@
text
@d571 1
a571 1
    if(argc != 4){
d573 1
a573 1
      bu_vls_printf(&vls, "Usage: dm bg r g b");
d579 3
@


1.9
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d567 28
@


1.8
log
@*- mods for pjt demo
@
text
@a105 1
#ifdef DO_RUBBER_BAND
a114 1
#endif    
a134 1
#ifdef USE_RT_ASPECT
a136 4
#else
      fx = dm_Xx2Normal(dmp, atoi(argv[1]), 0);
      fy = dm_Xy2Normal(dmp, atoi(argv[2]));
#endif
a155 1
#ifdef USE_RT_ASPECT
a157 4
#else
      fx = dm_Xx2Normal(dmp, atoi(argv[1]), 1);
      x = fx * 2047.0;
#endif
a173 1
#ifdef DO_RUBBER_BAND
a183 2
#endif
#ifdef DO_SNAP_TO_GRID
a231 1
#endif
a326 1
#ifdef USE_RT_ASPECT
d329 1
a329 4
#else
      fx = dm_Xx2Normal(dmp, dml_omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, dml_omy) * 2047.0 - dv_yadc;
#endif
a337 1
#ifdef USE_RT_ASPECT
d340 1
a340 4
#else
      fx = dm_Xx2Normal(dmp, dml_omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, dml_omy) * 2047.0 - dv_yadc;
#endif
a367 1
#ifdef USE_RT_ASPECT
a371 6
#else
      fx = (dm_Xx2Normal(dmp, dml_omx, 1) * 2047.0 -
	    dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Xy2Normal(dmp, dml_omy) * 2047.0 -
	    dv_yadc) * Viewscale * base2local / 2047.0;
#endif
@


1.7
log
@call new tcl scripts: mouse_solid_edit_select, mouse_object_edit_select
	and mouse_comb_edit_select
@
text
@d560 3
d564 1
@


1.6
log
@mods to common_dm()
@
text
@d249 1
a249 1
	bu_vls_printf(&vls, "ray_build_edit_menu s %d %d", x, y);
d251 1
a251 1
	bu_vls_printf(&vls, "ray_build_edit_menu o %d %d", x, y);
d253 1
a253 1
	bu_vls_printf(&vls, "ray_build_comb_menu %d %d", x, y);
@


1.5
log
@*- modified common_dm() to look for mouse_behavior == c
	to initiate picking combinations using the mouse
@
text
@d569 1
a569 1
  if(!strcmp(argv[0], "get")){
@


1.4
log
@*- mods to common_dm()
@
text
@d252 2
@


1.3
log
@*- mods to common_dm() ---- added "get" to access readonly data
	out of "struct dm_xvars"
@
text
@d151 1
a151 1
	if(x >= MENUXLIM && scroll_select( x, y, 0 )){
d156 1
a156 1
	if(x < MENUXLIM && mmenu_select( y, 0)){
d248 4
@


1.2
log
@*- mods to use rt's notion of aspect (i.e. width/height)
@
text
@d43 15
d121 2
a122 2
  if( !strcmp( argv[0], "m" )){
    if( argc < 3){
d260 1
a260 1
    if( argc < 4){
d536 1
a536 1
  if( !strcmp( argv[0], "size" )){
d540 1
a540 1
    if( argc == 1 ){
d561 25
@


1.1
log
@Initial revision
@
text
@d122 4
d128 1
d148 4
d154 1
d322 4
d328 1
d330 1
a330 1
      bu_vls_printf(&vls, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));
d337 4
d343 1
d345 1
a345 1
      bu_vls_printf(&vls, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));
d352 16
a367 8
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc hv %lf %lf\n",
		    dm_Xx2Normal(dmp, dml_omx, 1) *
		    Viewscale * base2local,
		    dm_Xy2Normal(dmp, dml_omy) *
		    Viewscale * base2local);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
a368 1
      am_mode = AMM_ADC_TRAN;
d371 6
d381 1
@
