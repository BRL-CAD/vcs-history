head	11.29;
access;
symbols
	ansi-20040405-merged:11.25.2.2
	postmerge-20040405-ansi:11.27
	premerge-20040404-ansi:11.26
	postmerge-autoconf:11.26
	autoconf-freeze:11.25.10.2
	premerge-autoconf:11.26
	postmerge-20040315-windows:11.26
	premerge-20040315-windows:11.26
	windows-20040315-freeze:11.25.4.1
	autoconf-20031203:11.25
	autoconf-20031202:11.25
	autoconf-branch:11.25.0.10
	phong-branch:11.25.0.8
	photonmap-branch:11.25.0.6
	rel-6-1-DP:11.25
	windows-branch:11.25.0.4
	rel-6-0-2:11.23
	ansi-branch:11.25.0.2
	rel-6-0-1-branch:11.23.0.2
	hartley-6-0-post:11.24
	hartley-6-0-pre:11.23
	rel-6-0-1:11.23
	rel-6-0:11.23
	rel-5-4:11.19
	offsite-5-3-pre:11.21
	rel-5-3:11.19
	rel-5-2:11.19
	rel-5-1-branch:11.19.0.2
	rel-5-1:11.19
	rel-5-0:11.19
	rel-5-0-beta:11.18
	rel-4-5:11.18
	ctj-4-5-post:11.17
	ctj-4-5-pre:11.17
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.29
date	2004.05.21.17.47.42;	author morrison;	state dead;
branches;
next	11.28;

11.28
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.27;

11.27
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2002.08.20.17.08.23;	author jra;	state Exp;
branches
	11.25.2.1
	11.25.4.1
	11.25.10.1;
next	11.24;

11.24
date	2002.08.15.20.55.34;	author hartley;	state Exp;
branches;
next	11.23;

11.23
date	2001.10.04.19.36.09;	author rbowers;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.05.19.35.45;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.08.19.03.10.14;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.09.01.18.55.10;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.05.12.13.24.16;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.02.28.21.34.33;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.03.17.42.55;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.21.14.21.22;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.03.01.19.31.28;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.02.18.03.08.58;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.45;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.08;	author mike;	state Rel4_4;
branches;
next	10.12;

10.12
date	94.12.16.19.36.46;	author gdurf;	state Exp;
branches;
next	10.11;

10.11
date	94.09.02.15.57.02;	author jra;	state Exp;
branches;
next	10.10;

10.10
date	94.08.25.00.33.02;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.08.25.00.29.09;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.08.09.15.20.12;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.06.03.17.25.54;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.06.01.16.33.17;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	92.03.23.22.23.38;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.03.23.21.46.37;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.03.23.16.07.49;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.12.18.07.46.15;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.42;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	90.04.21.06.06.04;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.27.21.30.57;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.09;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.06.20.40.01;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.20.47;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.51;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.21.02.32.10;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.11.14.05.02.38;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.04;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.00.52;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.04;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.20.49;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.02.13.00.07.42;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.05.31.32;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.21.43;	author mike;	state Rel1;
branches;
next	1.2;

1.2
date	86.09.10.19.43.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.09.10.01.37.57;	author mike;	state Exp;
branches;
next	;

11.25.2.1
date	2002.09.19.18.02.02;	author morrison;	state Exp;
branches;
next	11.25.2.2;

11.25.2.2
date	2004.03.17.21.21.59;	author morrison;	state Exp;
branches;
next	;

11.25.4.1
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

11.25.10.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	11.25.10.2;

11.25.10.2
date	2004.03.15.14.07.38;	author erikg;	state Exp;
branches;
next	;


desc
@Routines for defining ARB faces
@


11.29
log
@moved to src/mged/
@
text
@/*
 *			F A C E D E F . C
 *  Authors -
 *	Daniel C. Dender
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/facedef.c,v 11.28 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <signal.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./ged.h"
#include "./sedit.h"
#include "./mged_solid.h"

extern struct rt_db_internal	es_int;	/* from edsol.c */
extern struct bn_tol		mged_tol;		/* from ged.c */

char *p_rotfb[] = {
	"Enter rot, fb angles: ",
	"Enter fb angle: ",
	"Enter fixed vertex(v#) or point(X Y Z): ",
	"Enter Y, Z of point: ",
	"Enter Z of point: "
};

char *p_3pts[] = {
	"Enter X,Y,Z of point",
	"Enter Y,Z of point",
	"Enter Z of point"
};

char *p_pleqn[] = {
	"Enter A,B,C,D of plane equation: ",
	"Enter B,C,D of plane equation: ",
	"Enter C,D of plane equation: ",
	"Enter D of plane equation: "
};

char *p_nupnt[] = {
	"Enter X,Y,Z of fixed point: ",
	"Enter Y,Z of fixed point: ",
	"Enter Z of fixed point: "
};

static void	get_pleqn(fastf_t *plane, char **argv), get_rotfb(fastf_t *plane, char **argv, const struct rt_arb_internal *arb), get_nupnt(fastf_t *plane, char **argv);
static int	get_3pts(fastf_t *plane, char **argv, const struct bn_tol *tol);

/*
 *			F _ F A C E D E F
 *
 * Redefines one of the defining planes for a GENARB8. Finds
 * which plane to redefine and gets input, then shuttles the process over to
 * one of four functions before calculating new vertices.
 */
int
f_facedef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	short int 	i;
	int		face,prod,plane;
	struct rt_db_internal	intern;
	struct rt_arb_internal	*arb;
	struct rt_arb_internal	*arbo;
	plane_t		planes[6];
	int status = TCL_OK;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help facedef");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;

	if( state != ST_S_EDIT ){
	  Tcl_AppendResult(interp, "Facedef: must be in solid edit mode\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}
	if( es_int.idb_type != ID_ARB8 )  {
	   Tcl_AppendResult(interp, "Facedef: solid type must be ARB\n");
	   status = TCL_ERROR;
	   goto end;
	}	

	/* apply es_mat editing to parameters.  "new way" */
	transform_editing_solid( &intern, es_mat, &es_int, 0 );

	arb = (struct rt_arb_internal *)intern.idb_ptr;
	RT_ARB_CK_MAGIC(arb);

	/* find new planes to account for any editing */
	if( rt_arb_calc_planes( planes, arb, es_type, &mged_tol ) < 0 )  {
	  Tcl_AppendResult(interp, "Unable to determine plane equations\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	/* get face, initialize args and argcnt */
	face = atoi( argv[1] );
	
	/* use product of vertices to distinguish faces */
	for(i=0,prod=1;i<4;i++)  {
		if( face > 0 ){
			prod *= face%10;
			face /= 10;
		}
	}

	switch( prod ){
		case    6:			/* face  123 of arb4 */
		case   24:plane=0;		/* face 1234 of arb8 */
						/* face 1234 of arb7 */
						/* face 1234 of arb6 */
						/* face 1234 of arb5 */
			  if(es_type==4 && prod==24)
				plane=2; 	/* face  234 of arb4 */
			  break;
		case    8:			/* face  124 of arb4 */
		case  180: 			/* face 2365 of arb6 */
		case  210:			/* face  567 of arb7 */
		case 1680:plane=1;      	/* face 5678 of arb8 */
			  break;
		case   30:			/* face  235 of arb5 */
		case  120:			/* face 1564 of arb6 */
		case   20:      		/* face  145 of arb7 */
		case  160:plane=2;		/* face 1584 of arb8 */
			  if(es_type==5)
				plane=4; 	/* face  145 of arb5 */
			  break;
		case   12:			/* face  134 of arb4 */
		case   10:			/* face  125 of arb6 */
		case  252:plane=3;		/* face 2376 of arb8 */
						/* face 2376 of arb7 */
			  if(es_type==5)
				plane=1; 	/* face  125 of arb5 */
		 	  break;
		case   72:               	/* face  346 of arb6 */
		case   60:plane=4;	 	/* face 1265 of arb8 */
						/* face 1265 of arb7 */
			  if(es_type==5)
				plane=3; 	/* face  345 of arb5 */
			  break;
		case  420:			/* face 4375 of arb7 */
		case  672:plane=5;		/* face 4378 of arb8 */
			  break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "bad face (product=%d)\n", prod);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		    status = TCL_ERROR;
		    goto end;
		  }
	}

	if( argc < 3 ){
	  /* menu of choices for plane equation definition */
	  Tcl_AppendResult(interp,
			   "\ta   planar equation\n",
			   "\tb   3 points\n",
			   "\tc   rot,fb angles + fixed pt\n",
			   "\td   same plane thru fixed pt\n",
			   "\tq   quit\n\n",
			   MORE_ARGS_STR, "Enter form of new face definition: ", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	switch( argv[2][0] ){
	case 'a': 
	  /* special case for arb7, because of 2 4-pt planes meeting */
	  if( es_type == 7 )
	    if( plane!=0 && plane!=3 ){
	      Tcl_AppendResult(interp, "Facedef: can't redefine that arb7 plane\n", (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	  if( argc < 7 ){  	/* total # of args under this option */
	    Tcl_AppendResult(interp, MORE_ARGS_STR, p_pleqn[argc-3], (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  get_pleqn( planes[plane], &argv[3] );
	  break;
	case 'b': 
	  /* special case for arb7, because of 2 4-pt planes meeting */
	  if( es_type == 7 )
	    if( plane!=0 && plane!=3 ){
	      Tcl_AppendResult(interp, "Facedef: can't redefine that arb7 plane\n", (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	  if( argc < 12 ){           /* total # of args under this option */
	    struct bu_vls tmp_vls;

	     bu_vls_init(&tmp_vls);
	     bu_vls_printf(&tmp_vls, "%s%s %d: ", MORE_ARGS_STR, p_3pts[(argc-3)%3], argc/3);
	     Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	     bu_vls_free(&tmp_vls);
	     status = TCL_ERROR;
	     goto end;
	  }
	  if( get_3pts( planes[plane], &argv[3], &mged_tol) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;
	case 'c': 
	  /* special case for arb7, because of 2 4-pt planes meeting */
	  if( es_type == 7 && (plane != 0 && plane != 3) ) {
	    if( argc < 5 ){ 	/* total # of args under this option */
	      Tcl_AppendResult(interp, MORE_ARGS_STR, p_rotfb[argc-3], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }

	    argv[5] = "Release 6";
	    Tcl_AppendResult(interp, "Fixed point is vertex five.\n");
	  }
	  /* total # of as under this option */
	  else if( argc < 8 && (argc > 5 ? argv[5][0] != 'R' : 1)) { 
	    Tcl_AppendResult(interp, MORE_ARGS_STR, p_rotfb[argc-3], (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  get_rotfb(planes[plane], &argv[3], arb);
	  break;
	case 'd': 
	  /* special case for arb7, because of 2 4-pt planes meeting */
	  if( es_type == 7 )
	    if( plane!=0 && plane!=3 ){
	      Tcl_AppendResult(interp, "Facedef: can't redefine that arb7 plane\n", (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	  if( argc < 6 ){  	/* total # of args under this option */
	    Tcl_AppendResult(interp, MORE_ARGS_STR, p_nupnt[argc-3], (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  get_nupnt(planes[plane], &argv[3]);
	  break;
	case 'q': 
	  return TCL_OK;
	default:
	  Tcl_AppendResult(interp, "Facedef: '", argv[2], "' is not an option\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	/* find all vertices from the plane equations */
	if( rt_arb_calc_points( arb, es_type, planes, &mged_tol ) < 0 )  {
	  Tcl_AppendResult(interp, "facedef:  unable to find points\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}
	/* Now have 8 points, which is the internal form of an ARB8. */

	/* Transform points back before es_mat changes */
	/* This is the "new way" */
	arbo = (struct rt_arb_internal *)es_int.idb_ptr;
	RT_ARB_CK_MAGIC(arbo);

	for(i=0; i<8; i++){
		MAT4X3PNT( arbo->pt[i], es_invmat, arb->pt[i] );
	}
	rt_db_free_internal(&intern, &rt_uniresource);

	/* draw the new solid */
	replot_editing_solid();

end:
	(void)signal( SIGINT, SIG_IGN );
	return status;
}


/*
 * 			G E T _ P L E Q N
 *
 * Gets the planar equation from the array argv[]
 * and puts the result into 'plane'.
 */
static void
get_pleqn(fastf_t *plane, char **argv)
{
	int i;

	if(dbip == DBI_NULL)
	  return;

	for(i=0; i<4; i++)
		plane[i]= atof(argv[i]);
	VUNITIZE( &plane[0] );
	plane[3] *= local2base;
	return;	
}


/*
 * 			G E T _ 3 P T S
 *
 *  Gets three definite points from the array argv[]
 *  and finds the planar equation from these points.
 *  The resulting plane equation is stored in 'plane'.
 *
 *  Returns -
 *	 0	success
 *	-1	failure
 */
static int
get_3pts(fastf_t *plane, char **argv, const struct bn_tol *tol)
{
	int i;
	point_t	a,b,c;

	CHECK_DBI_NULL;

	for(i=0; i<3; i++)
		a[i] = atof(argv[0+i]) * local2base;
	for(i=0; i<3; i++)
		b[i] = atof(argv[3+i]) * local2base;
	for(i=0; i<3; i++)
		c[i] = atof(argv[6+i]) * local2base;

	if( bn_mk_plane_3pts( plane, a, b, c, tol ) < 0 )  {
	  Tcl_AppendResult(interp, "Facedef: not a plane\n", (char *)NULL);
	  return(-1);		/* failure */
	}
	return(0);			/* success */
}
	
/*
 * 			G E T _ R O T F B
 *
 * Gets information from the array argv[].
 * Finds the planar equation given rotation and fallback angles, plus a
 * fixed point. Result is stored in 'plane'. The vertices
 * pointed to by 's_recp' are used if a vertex is chosen as fixed point.
 */
static void
get_rotfb(fastf_t *plane, char **argv, const struct rt_arb_internal *arb)
{
	fastf_t rota, fb;
	short int i,temp;
	point_t		pt;

	if(dbip == DBI_NULL)
	  return;

	rota= atof(argv[0]) * degtorad;
	fb  = atof(argv[1]) * degtorad;
	
	/* calculate normal vector (length=1) from rot,fb */
	plane[0] = cos(fb) * cos(rota);
	plane[1] = cos(fb) * sin(rota);
	plane[2] = sin(fb);

	if( argv[2][0] == 'v' ){     	/* vertex given */
		/* strip off 'v', subtract 1 */
		temp = atoi(argv[2]+1) - 1;
		plane[3]= VDOT(&plane[0], arb->pt[temp]);
	} else {		         /* definite point given */
		for(i=0; i<3; i++)
			pt[i]=atof(argv[2+i]) * local2base;
		plane[3]=VDOT(&plane[0], pt);
	}
}

/*
 * 			G E T _ N U P N T
 *
 * Gets a point from the three strings in the 'argv' array.
 * The value of D of 'plane' is changed such that the plane
 * passes through the input point.
 */
static void
get_nupnt(fastf_t *plane, char **argv)
{
	int	i;
	point_t	pt;

	if(dbip == DBI_NULL)
	  return;

	for(i=0; i<3; i++)
		pt[i] = atof(argv[i]) * local2base;
	plane[3] = VDOT(&plane[0], pt);
}
@


11.28
log
@change conf.h to a wrapped config.h
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/facedef.c,v 11.27 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.27
log
@merge of ansi-6-0-branch into HEAD
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d19 5
a23 1
#include "conf.h"
@


11.26
log
@update copyright to include span through 2003
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.25 2002/08/20 17:08:23 jra Exp $ (BRL)";
d64 2
a65 2
static void	get_pleqn(), get_rotfb(), get_nupnt();
static int	get_3pts();
d75 1
a75 5
f_facedef(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d314 1
a314 3
get_pleqn( plane, argv )
plane_t	plane;
char	*argv[];
d341 1
a341 4
get_3pts( plane, argv, tol)
plane_t		plane;
char		*argv[];
const struct bn_tol	*tol;
d371 1
a371 4
get_rotfb(plane, argv, arb)
plane_t	plane;
char	*argv[];
const struct rt_arb_internal	*arb;
d407 1
a407 3
get_nupnt(plane, argv)
plane_t	plane;
char	*argv[];
@


11.25
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1986 by the United States Army.
d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.23 2001/10/04 19:36:09 rbowers Exp $ (BRL)";
@


11.25.4.1
log
@sync to HEAD...
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/facedef.c,v 11.26 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.25.10.1
log
@merge from HEAD
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.26 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.25.10.2
log
@merge from head
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.25.10.1 2004/02/12 18:34:14 erikg Exp $ (BRL)";
@


11.25.2.1
log
@Initial ANSIfication
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.25 2002/08/20 17:08:23 jra Exp $ (BRL)";
d64 2
a65 2
static void	get_pleqn(fastf_t *plane, char **argv), get_rotfb(fastf_t *plane, char **argv, const struct rt_arb_internal *arb), get_nupnt(fastf_t *plane, char **argv);
static int	get_3pts(fastf_t *plane, char **argv, const struct bn_tol *tol);
d75 5
a79 1
f_facedef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d318 3
a320 1
get_pleqn(fastf_t *plane, char **argv)
d347 4
a350 1
get_3pts(fastf_t *plane, char **argv, const struct bn_tol *tol)
d380 4
a383 1
get_rotfb(fastf_t *plane, char **argv, const struct rt_arb_internal *arb)
d419 3
a421 1
get_nupnt(fastf_t *plane, char **argv)
@


11.25.2.2
log
@sync branch with HEAD
@
text
@d12 1
a12 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.24
log
@Converted from K&R to ANSI C - RFH
@
text
@d64 2
a65 2
static void	get_pleqn(fastf_t *plane, char **argv), get_rotfb(fastf_t *plane, char **argv, const struct rt_arb_internal *arb), get_nupnt(fastf_t *plane, char **argv);
static int	get_3pts(fastf_t *plane, char **argv, const struct bn_tol *tol);
d75 5
a79 1
f_facedef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d318 3
a320 1
get_pleqn(fastf_t *plane, char **argv)
d347 4
a350 1
get_3pts(fastf_t *plane, char **argv, const struct bn_tol *tol)
d380 4
a383 1
get_rotfb(fastf_t *plane, char **argv, const struct rt_arb_internal *arb)
d419 3
a421 1
get_nupnt(fastf_t *plane, char **argv)
@


11.23
log
@-* modified to eliminate user-visible v4 references.
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.22 2001/04/05 19:35:45 morrison Exp $ (BRL)";
d64 2
a65 2
static void	get_pleqn(), get_rotfb(), get_nupnt();
static int	get_3pts();
d75 1
a75 5
f_facedef(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d314 1
a314 3
get_pleqn( plane, argv )
plane_t	plane;
char	*argv[];
d341 1
a341 4
get_3pts( plane, argv, tol)
plane_t		plane;
char		*argv[];
const struct bn_tol	*tol;
d371 1
a371 4
get_rotfb(plane, argv, arb)
plane_t	plane;
char	*argv[];
const struct rt_arb_internal	*arb;
d407 1
a407 3
get_nupnt(plane, argv)
plane_t	plane;
char	*argv[];
@


11.22
log
@updated SIGNED to signed
updated CONST to const
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.21 2000/09/08 05:55:48 mike Exp $ (BRL)";
d250 1
a250 1
	    argv[5] = "v5";
d253 2
a254 2
	  /* total # of args under this option */
	  else if( argc < 8 && (argc > 5 ? argv[5][0] != 'v' : 1)) { 
@


11.21
log
@
Tree routines now need resource structure.
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.20 2000/08/19 03:10:14 mike Exp $ (BRL)";
d350 1
a350 1
CONST struct bn_tol	*tol;
d383 1
a383 1
CONST struct rt_arb_internal	*arb;
@


11.20
log
@
Reduced use of MAXARGS
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.19 1999/09/01 18:55:10 bparker Exp $ (BRL)";
d300 1
a300 1
	rt_db_free_internal(&intern);
@


11.19
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/facedef.c,v 11.18 1997/07/01 22:09:08 bparker Exp $ (BRL)";
d89 1
a89 1
	if(argc < 2 || MAXARGS < argc){
@


11.18
log
@mods to run without a database
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.17 1997/05/12 13:24:16 jra Exp bparker $ (BRL)";
d355 1
a355 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.17
log
@fixed bug in  f_facedef() (was going into infinite loop when rot,fb option was chosen).
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.16 1997/04/24 18:03:58 bparker Exp jra $ (BRL)";
d324 3
d355 3
d390 3
d426 3
@


11.16
log
@modify calls to Tcl_Eval
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.15 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d254 1
a254 1
	  else if( argc < 8 && (argc >= 5 ? argv[5][0] != 'v' : 1)) { 
@


11.15
log
@mods so that commands check args internally
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.14 1997/02/28 21:34:33 jra Exp bparker $ (BRL)";
d90 6
a95 1
	  Tcl_Eval(interp, "help facedef");
@


11.14
log
@removed include of db.hg
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.13 1997/01/02 19:35:05 bparker Exp jra $ (BRL)";
d89 2
a90 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d92 1
@


11.13
log
@mods to use libbn and libbu
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.12 1996/10/01 17:26:29 bparker Exp bparker $ (BRL)";
a27 1
#include "db.h"
@


11.12
log
@ignore SIGINT
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.11 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d36 1
a36 1
extern struct rt_tol		mged_tol;		/* from ged.c */
d341 1
a341 1
CONST struct rt_tol	*tol;
d353 1
a353 1
	if( rt_mk_plane_3pts( plane, a, b, c, tol ) < 0 )  {
@


11.11
log
@include mged_solid.h
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.10 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d88 1
d100 2
a101 1
	  return TCL_ERROR;
d105 2
a106 1
	   return TCL_ERROR;
d118 2
a119 1
	  return TCL_ERROR;
d178 2
a179 1
		    return TCL_ERROR;
d192 2
a193 1
	  return TCL_ERROR;
d202 2
a203 1
	      return TCL_ERROR;
d207 2
a208 1
	    return TCL_ERROR;
d217 2
a218 1
	      return TCL_ERROR;
d227 2
a228 1
	     return TCL_ERROR;
d231 2
a232 1
	    return TCL_ERROR;			/* failure */
d240 2
a241 1
	      return TCL_ERROR;
d250 2
a251 1
	    return TCL_ERROR;
d260 2
a261 1
	      return TCL_ERROR;
d265 2
a266 1
	    return TCL_ERROR;
d274 2
a275 1
	  return TCL_ERROR;
d281 2
a282 1
	  return TCL_ERROR;
d298 4
a301 1
	return TCL_OK;				/* everything OK */
@


11.10
log
@rt_list ---> bu_list
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.9 1996/09/03 17:42:55 bparker Exp bparker $ (BRL)";
d23 1
d33 1
a33 2
#include "./solid.h"
#include <signal.h>
@


11.9
log
@Check in Lee's changes
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.8 1996/08/27 20:30:05 bparker Exp butler $ (BRL)";
d26 1
a27 2
#include "vmath.h"
#include "rtlist.h"
@


11.8
log
@now using libbu
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.7 1996/08/21 14:21:22 jra Exp bparker $ (BRL)";
d25 1
@


11.7
log
@Minor mod for IRIX 6.2.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.6 1996/05/02 21:33:02 bparker Exp jra $ (BRL)";
d168 1
a168 1
		    struct rt_vls tmp_vls;
d170 4
a173 4
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "bad face (product=%d)\n", prod);
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		    rt_vls_free(&tmp_vls);
d212 1
a212 1
	    struct rt_vls tmp_vls;
d214 4
a217 4
	     rt_vls_init(&tmp_vls);
	     rt_vls_printf(&tmp_vls, "%s%s %d: ", MORE_ARGS_STR, p_3pts[(argc-3)%3], argc/3);
	     Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	     rt_vls_free(&tmp_vls);
@


11.6
log
@Still Tcl'ing the code
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.5 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d384 2
a385 2
void
static get_nupnt(plane, argv)
@


11.5
log
@convert commands to Tcl
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.4 1996/03/01 19:31:28 bparker Exp bparker $ (BRL)";
d92 4
a95 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
@


11.4
log
@remove unused XMGED stuff
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.3 1995/02/18 03:08:58 mike Exp bparker $ (BRL)";
d76 3
a78 1
f_facedef(argc, argv)
d89 3
d95 2
a96 2
		rt_log("Facedef: must be in solid edit mode\n");
		return CMD_BAD;
d99 2
a100 2
		rt_log("Facedef: solid type must be ARB\n");
		return CMD_BAD;
d111 2
a112 2
		rt_log("Unable to determine plane equations\n");
		return CMD_BAD;
d164 9
a172 2
			  rt_log("bad face (product=%d)\n", prod);
			  return CMD_BAD;
d176 9
a184 10

		/* menu of choices for plane equation definition */
		rt_log("\ta   planar equation\n");
		rt_log("\tb   3 points\n");
		rt_log("\tc   rot,fb angles + fixed pt\n");
		rt_log("\td   same plane thru fixed pt\n");
		rt_log("\tq   quit\n\n");

		rt_log("Enter form of new face definition: ");
		return CMD_MORE;
d189 12
a200 12
		/* special case for arb7, because of 2 4-pt planes meeting */
		if( es_type == 7 )
			if( plane!=0 && plane!=3 ){
				rt_log("Facedef: can't redefine that arb7 plane\n");
				return CMD_BAD;
			}
		if( argc < 7 ){  	/* total # of args under this option */
			rt_log("%s",p_pleqn[argc-3]);
			return CMD_MORE;
		}
		get_pleqn( planes[plane], &argv[3] );
		break;
d202 19
a220 14
		/* special case for arb7, because of 2 4-pt planes meeting */
		if( es_type == 7 )
			if( plane!=0 && plane!=3 ){
				rt_log("Facedef: can't redefine that arb7 plane\n");
				return CMD_BAD;
			}
		if( argc < 12 ){           /* total # of args under this option */
			rt_log("%s %d: ", p_3pts[(argc-3)%3], argc/3);
			return CMD_MORE;
		}
		if( get_3pts( planes[plane], &argv[3], &mged_tol) ){
			return CMD_BAD;			/* failure */
		}
		break;
d222 17
a238 16
		/* special case for arb7, because of 2 4-pt planes meeting */
		if( es_type == 7 && (plane != 0 && plane != 3) ) {
			if( argc < 5 ){ 	/* total # of args under this option */
				rt_log("%s",p_rotfb[argc-3]);
				return CMD_MORE;
			}
			argv[5] = "v5";
			rt_log("Fixed point is vertex five.\n");
		}
                                    /* total # of args under this option */
		else if( argc < 8 && (argc >= 5 ? argv[5][0] != 'v' : 1)) { 
			rt_log("%s",p_rotfb[argc-3]);
			return CMD_MORE;
		}
		get_rotfb(planes[plane], &argv[3], arb);
		break;
d240 12
a251 12
		/* special case for arb7, because of 2 4-pt planes meeting */
		if( es_type == 7 )
			if( plane!=0 && plane!=3 ){
				rt_log("Facedef: can't redefine that arb7 plane\n");
				return CMD_BAD;
			}
		if( argc < 6 ){  	/* total # of args under this option */
			rt_log("%s",p_nupnt[argc-3]);
			return CMD_MORE;
		}
		get_nupnt(planes[plane], &argv[3]);
		break;
d253 4
a256 4
		return CMD_OK;
	default:  
		rt_log("Facedef: '%s' is not an option\n", argv[2]);
		return CMD_BAD;
d261 2
a262 2
		rt_log("facedef:  unable to find points\n");
		return CMD_BAD;
d278 1
a278 1
	return CMD_OK;				/* everything OK */
d331 2
a332 2
		rt_log("Facedef: not a plane\n");
		return(-1);		/* failure */
@


11.3
log
@Eliminated local setting of "rt_tol" structures.
Everything now uses the global mged_tol.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 11.2 95/01/17 13:04:45 bparker Exp Locker: mike $ (BRL)";
a86 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );		/* allow interrupts */
#else
a87 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/facedef.c,v 11.2 95/01/17 11:43:06 bparker Exp $ (BRL)";
d36 1
a81 1
	struct rt_tol	tol;
a86 7
	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d109 1
a109 1
	if( rt_arb_calc_planes( planes, arb, es_type, &tol ) < 0 )  {
d205 1
a205 1
		if( get_3pts( planes[plane], &argv[3], &tol) ){
d247 1
a247 1
	if( rt_arb_calc_points( arb, es_type, planes, &tol ) < 0 )  {
d305 1
a305 1
struct rt_tol	*tol;
@


11.1
log
@Release_4.4
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.12 94/12/16 19:36:46 gdurf Exp $ (BRL)";
d94 6
a99 1
	(void)signal( SIGINT, sig2 );		/* allow interrupts */
@


10.12
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.11 1994/09/02 15:57:02 jra Exp gdurf $ (BRL)";
@


10.11
log
@Removed all blocks of code that didn't use the "new way".
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.10 94/08/25 00:33:02 mike Exp Locker: jra $ (BRL)";
d96 1
a96 1
		(void)printf("Facedef: must be in solid edit mode\n");
d100 1
a100 1
		(void)printf("Facedef: solid type must be ARB\n");
d165 1
a165 1
			  (void)printf("bad face (product=%d)\n", prod);
d172 5
a176 5
		(void)printf("\ta   planar equation\n");
		(void)printf("\tb   3 points\n");
		(void)printf("\tc   rot,fb angles + fixed pt\n");
		(void)printf("\td   same plane thru fixed pt\n");
		(void)printf("\tq   quit\n\n");
d178 1
a178 1
		(void)printf("Enter form of new face definition: ");
d187 1
a187 1
				(void)printf("Facedef: can't redefine that arb7 plane\n");
d191 1
a191 1
			(void)printf("%s",p_pleqn[argc-3]);
d200 1
a200 1
				(void)printf("Facedef: can't redefine that arb7 plane\n");
d204 1
a204 1
			(void)printf("%s %d: ", p_3pts[(argc-3)%3], argc/3);
d215 1
a215 1
				(void)printf("%s",p_rotfb[argc-3]);
d219 1
a219 1
			(void)printf("Fixed point is vertex five.\n");
d223 1
a223 1
			(void)printf("%s",p_rotfb[argc-3]);
d232 1
a232 1
				(void)printf("Facedef: can't redefine that arb7 plane\n");
d236 1
a236 1
			(void)printf("%s",p_nupnt[argc-3]);
d244 1
a244 1
		(void)printf("Facedef: '%s' is not an option\n", argv[2]);
@


10.10
log
@Moved rt_arb_calc_points() into librt/g_arb.c
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.9 94/08/25 00:29:09 mike Exp Locker: mike $ (BRL)";
a263 8

	/* For compatability, here is the "old way" */
	MAT4X3PNT( &es_rec.s.s_values[3*0], es_invmat, arb->pt[0] );
	for(i=1; i<8; i++){
		vect_t	diff;
		VSUB2( diff, arb->pt[i], arb->pt[0] );
		MAT4X3VEC( &es_rec.s.s_values[3*i], es_invmat, diff );
	}
@


10.9
log
@Added support for "old way", and fixed "new way" code.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.8 94/08/09 15:20:12 gdurf Exp Locker: mike $ (BRL)";
a388 34
}

/*
 *			R T _ A R B _ C A L C _ P O I N T S
 *
 * Takes the planes[] array and intersects the planes to find the vertices
 * of a GENARB8.  The vertices are stored into arb->pt[].
 * This is an analog of rt_arb_calc_planes().
 */
int
rt_arb_calc_points( arb, cgtype, planes, tol )
struct rt_arb_internal	*arb;
int		cgtype;
plane_t		planes[6];
struct rt_tol	*tol;
{
	int	i;
	point_t	pt[8];

	RT_ARB_CK_MAGIC(arb);

	/* find new points for entire solid */
	for(i=0; i<8; i++){
		if( rt_arb_3face_intersect( pt[i], planes, cgtype, i*3 ) < 0 )  {
			rt_log("rt_arb_calc_points: Intersection of planes fails %d\n", i);
			return -1;			/* FAIL */
		}
	}

	/* Move new points to arb */
	for( i=0; i<8; i++ )  {
		VMOVE( arb->pt[i], pt[i] );
	}
	return 0;					/* success */
@


10.8
log
@Added include of conf.h
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.7 1994/06/03 17:25:54 gdurf Exp gdurf $ (BRL)";
d104 1
a104 1
	/* apply es_mat editing to parameters */
d165 1
a165 1
			  (void)printf("bad face\n");
d253 1
d255 2
a256 1
	/* Transform points back to before es_mat changes */
d260 7
a266 1
	MAT4X3PNT( arbo->pt[0], es_invmat, arb->pt[0] );
d268 3
a270 1
		MAT4X3VEC( arbo->pt[i], es_invmat, arb->pt[i] );
a271 1
	rt_db_free_internal(&intern);
@


10.7
log
@Modified routines requiring input to use CMD_MORE.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.6 1994/06/01 16:33:17 gdurf Exp gdurf $ (BRL)";
d18 2
@


10.6
log
@Converted f_facedef to use new command return codes.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.5 1992/03/23 22:23:38 mike Exp gdurf $ (BRL)";
a34 5
extern int numargs;   			/* number of arguments */
extern int args;       			/* total number of args available */
extern int argcnt;     			/* holder for number of args added later */
extern char *cmd_args[];    		/* array of pointers to args */

d73 3
a75 1
f_facedef()
d115 1
a115 3
	face = atoi( cmd_args[1] );
	args = numargs;
	argcnt = 0;
d167 1
a167 1
	while( args < 3 ){
d177 1
a177 2
		argcnt = getcmd(args);
		args += argcnt;
d180 1
a180 1
	switch( cmd_args[2][0] ){
d188 3
a190 7
		while( args < 7 ){  	/* total # of args under this option */
			(void)printf("%s",p_pleqn[args-3]);
			if( (argcnt = getcmd(args)) < 0 ){
				(void)printf("Facedef: input bad\n");
				return CMD_BAD;
			}
			args += argcnt;
d192 1
a192 1
		get_pleqn( planes[plane], &cmd_args[3] );
d201 3
a203 7
		while( args < 12 ){           /* total # of args under this option */
			(void)printf("%s %d: ", p_3pts[(args-3)%3] ,args/3);
			if( (argcnt = getcmd(args)) < 0 ){
				(void)printf("Facedef: input bad\n");
				return CMD_BAD;
			}
			args += argcnt;
d205 1
a205 1
		if( get_3pts( planes[plane], &cmd_args[3], &tol) ){
d212 3
a214 7
			while( args < 5 ){ 	/* total # of args under this option */
				(void)printf("%s",p_rotfb[args-3]);
				if( (argcnt = getcmd(args)) < 0){
					(void)printf("Facedef: input bad\n");
					return CMD_BAD;
				}
				args += argcnt;
d216 1
a216 1
			cmd_args[5] = "v5";
d219 4
a222 9
		else while( args < 8 ){         /* total # of args under this option */	
			if( args > 5 && cmd_args[5][0] == 'v' )       /* vertex point given,stop */
				break;
			(void)printf("%s",p_rotfb[args-3]);
			if( (argcnt = getcmd(args)) < 0 ){
				(void)printf("Facedef: input bad\n");
				return CMD_BAD;
			}
			args += argcnt;
d224 1
a224 1
		get_rotfb(planes[plane], &cmd_args[3], arb);
d233 3
a235 7
		while( args < 6 ){  	/* total # of args under this option */
			(void)printf("%s",p_nupnt[args-3]);
			if( (argcnt = getcmd(args)) < 0 ){
				(void)printf("Facedef: input bad\n");
				return CMD_BAD;
			}
			args += argcnt;
d237 1
a237 1
		get_nupnt(planes[plane], &cmd_args[3]);
d242 1
a242 1
		(void)printf("Facedef: '%s' is not an option\n", cmd_args[2]);
@


10.5
log
@Converted facedef.c to "new way".
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.4 92/03/23 21:46:37 mike Exp Locker: mike $ (BRL)";
d77 1
a77 1
void
d98 1
a98 1
		return;
d102 1
a102 1
		return;
d114 1
a114 1
		return;
d169 1
a169 1
			  return;
d192 1
a192 1
				return;
d198 1
a198 1
				return;
d209 1
a209 1
				return;
d215 1
a215 1
				return;
d220 1
a220 1
			return;				/* failure */
d230 1
a230 1
					return;
d243 1
a243 1
				return;
d254 1
a254 1
				return;
d260 1
a260 1
				return;
d267 1
a267 1
		return;
d270 1
a270 1
		return;
d276 1
a276 1
		return;
d291 1
a291 1
	return;				/* everything OK */
@


10.4
log
@FOrmatting changes, added rt_arb_calc_points().
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.3 92/03/23 16:07:49 mike Exp Locker: mike $ (BRL)";
d33 2
a66 2
void	f_facedef();

d70 3
a72 1
/*			F _ F A C E D E F ( )
d80 2
a81 2
	short int 	i,face,prod,plane;
	static vect_t 	tempvec;	/* because MAT4X3PNT,MAT4X3VEC corrupts the vector */
d83 4
d97 1
a97 1
		(void)printf("Facedef: must be in solid edit\n");
d100 2
a101 2
	if( es_rec.s.s_type != GENARB8 ){
		(void)printf("Facedef: type must be GENARB8\n");
d105 2
a106 9
	/* apply es_mat editing to parameters,put into es_rec.s */
	VMOVE( tempvec, &es_rec.s.s_values[0] );
	MAT4X3PNT( &es_rec.s.s_values[0], es_mat, tempvec );
	for(i=1; i<8; i++){
		VMOVE( tempvec, &es_rec.s.s_values[i*3] );
		MAT4X3VEC( 	&es_rec.s.s_values[i*3],
				es_mat,
				tempvec			);
	}
d108 3
d112 4
a115 1
	calc_planes( &es_rec.s, es_rec.s.s_cgtype );
d123 1
a123 1
	for(i=0,prod=1;i<4;i++)
d128 1
d136 1
a136 1
			  if(es_rec.s.s_cgtype==ARB4 && prod==24)
d148 1
a148 1
			  if(es_rec.s.s_cgtype==ARB5)
d155 1
a155 1
			  if(es_rec.s.s_cgtype==ARB5)
d161 1
a161 1
			  if(es_rec.s.s_cgtype==ARB5)
d189 1
a189 1
		if( es_rec.s.s_cgtype == ARB7 )
d202 1
a202 1
		get_pleqn( es_peqn[plane], &cmd_args[3] );
d206 1
a206 1
		if( es_rec.s.s_cgtype == ARB7 )
d219 1
a219 3
		if( get_3pts( es_peqn[plane], &cmd_args[3], &tol) ){
			/* clean up array es_peqn for anyone else */
			calc_planes( &es_rec.s, es_rec.s.s_cgtype );
d225 1
a225 1
		if( es_rec.s.s_cgtype == ARB7 && (plane != 0 && plane != 3) ) {
d247 1
a247 1
		get_rotfb(es_peqn[plane], &cmd_args[3], &es_rec.s);
d251 1
a251 1
		if( es_rec.s.s_cgtype == ARB7 )
d264 1
a264 1
		get_nupnt(es_peqn[plane], &cmd_args[3]);
d273 5
a277 2
	/* find all vertices, put in vector notation */
	calc_pnts( &es_rec.s, es_rec.s.s_cgtype, es_peqn );
d279 5
a283 3
	/* go back to before es_mat changes */
	VMOVE( tempvec, &es_rec.s.s_values[0] );
	MAT4X3PNT( &es_rec.s.s_values[0], es_invmat, tempvec );
d285 1
a285 4
		VMOVE( tempvec, &es_rec.s.s_values[i*3] );
		MAT4X3VEC(	&es_rec.s.s_values[i*3],
				es_invmat,
				tempvec			);
d287 1
a290 3

	/* update display information */
	dmaflag = 1;
d359 1
a359 1
get_rotfb(plane, argv, s_recp)
d362 1
a362 1
struct solidrec *s_recp;
d379 2
a380 7
		if(temp > 0){
			VADD2( &pt[0], &s_recp->s_values[0], &s_recp->s_values[temp*3] );
			plane[3]= VDOT(&plane[0], pt);
		} else {
			plane[3]= VDOT(&plane[0],&s_recp->s_values[0]);
		}
	} else {				         /* definite point given */
a406 39
/* 			C A L C _ P N T S (  )
 * XXX replaced by rt_arb_calc_points
 *
 * Takes the array es_peqn[] and intersects the planes to find the vertices
 * of a GENARB8.  The vertices are stored in the solid record 'old_srec' which
 * is of type 'type'.  If intersect fails, the points (in vector notation) of
 * 'old_srec' are used to clean up the array es_peqn[] for anyone else. The
 * vertices are put in 'old_srec' in vector notation.  This is an analog to
 * calc_planes().
 */
void
calc_pnts( old_srec, type )
struct solidrec *old_srec;
int type;
{
	struct solidrec temp_srec;
	short int i;

	/* find new points for entire solid */
	for(i=0; i<8; i++){
		/* use temp_srec until we know intersect doesn't fail */
		if( intersect(type,i*3,i,&temp_srec) ){
			(void)printf("Intersection of planes fails\n");
			/* clean up array es_peqn for anyone else */
			calc_planes( old_srec, type );
			return;				/* failure */
		}
	}

	/* back to vector notation */
	VMOVE( &old_srec->s_values[0], &temp_srec.s_values[0] );
	for(i=3; i<=21; i+=3){
		VSUB2(	&old_srec->s_values[i],
			&temp_srec.s_values[i],
			&temp_srec.s_values[0]  );
	}
	return;						/* success */
}

a411 2
 * If the intersect fails, the existing points of arb->pt[]
 * are used to clean up the planes[] array for anyone else.
a429 2
			/* clean up planes[] for anyone else */
			(void)rt_arb_calc_planes( planes, arb, cgtype, tol );
@


10.3
log
@Minor cleanups.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.2 91/12/18 07:46:15 mike Exp Locker: mike $ (BRL)";
d22 1
d25 2
a29 1
#include "externs.h"
a67 1
void	calc_pnts();
d94 1
a94 1
	else if( es_rec.s.s_type != GENARB8 ){
d180 7
a186 15
	switch( *cmd_args[2] ){
		case 'a': 
			/* special case for arb7, because of 2 4-pt planes meeting */
			if( es_rec.s.s_cgtype == ARB7 )
				if( plane!=0 && plane!=3 ){
					(void)printf("Facedef: can't redefine that arb7 plane\n");
					return;
				}
			while( args < 7 ){  	/* total # of args under this option */
				(void)printf("%s",p_pleqn[args-3]);
				if( (argcnt = getcmd(args)) < 0 ){
					(void)printf("Facedef: input bad\n");
					return;
				}
				args += argcnt;
d188 5
a192 16
			get_pleqn( es_peqn[plane], &cmd_args[3] );
			break;
		case 'b': 
			/* special case for arb7, because of 2 4-pt planes meeting */
			if( es_rec.s.s_cgtype == ARB7 )
				if( plane!=0 && plane!=3 ){
					(void)printf("Facedef: can't redefine that arb7 plane\n");
					return;
				}
			while( args < 12 ){           /* total # of args under this option */
				(void)printf("%s %d: ", p_3pts[(args-3)%3] ,args/3);
				if( (argcnt = getcmd(args)) < 0 ){
					(void)printf("Facedef: input bad\n");
					return;
				}
				args += argcnt;
d194 10
a203 4
			if( get_3pts( es_peqn[plane], &cmd_args[3], &tol) ){
				/* clean up array es_peqn for anyone else */
				calc_planes( &es_rec.s, es_rec.s.s_cgtype );
				return;				/* failure */
d205 5
a209 14
			break;
		case 'c': 
			/* special case for arb7, because of 2 4-pt planes meeting */
			if( es_rec.s.s_cgtype == ARB7 && (plane != 0 && plane != 3) ) {
				while( args < 5 ){ 	/* total # of args under this option */
					(void)printf("%s",p_rotfb[args-3]);
					if( (argcnt = getcmd(args)) < 0){
						(void)printf("Facedef: input bad\n");
						return;
					}
					args += argcnt;
				}
				cmd_args[5] = "v5";
				(void)printf("Fixed point is vertex five.\n");
d211 12
a222 3
			else while( args < 8 ){         /* total # of args under this option */	
				if( args > 5 && cmd_args[5][0] == 'v' )       /* vertex point given,stop */
					break;
d224 1
a224 1
				if( (argcnt = getcmd(args)) < 0 ){
d230 10
a239 16
			get_rotfb(es_peqn[plane], &cmd_args[3], &es_rec.s);
			break;
		case 'd': 
			/* special case for arb7, because of 2 4-pt planes meeting */
			if( es_rec.s.s_cgtype == ARB7 )
				if( plane!=0 && plane!=3 ){
					(void)printf("Facedef: can't redefine that arb7 plane\n");
					return;
				}
			while( args < 6 ){  	/* total # of args under this option */
				(void)printf("%s",p_nupnt[args-3]);
				if( (argcnt = getcmd(args)) < 0 ){
					(void)printf("Facedef: input bad\n");
					return;
				}
				args += argcnt;
d241 26
a266 7
			get_nupnt(es_peqn[plane], &cmd_args[3]);
			break;
		case 'q': 
			return;
		default:  
			(void)printf("Facedef: not an option\n");
			return;
d270 1
a270 1
	calc_pnts( &es_rec.s, es_rec.s.s_cgtype );
d315 1
a315 1
 *  Gets three definite points from the array cmd_args[]
d409 2
d445 38
@


10.2
log
@Eliminated now useless calls to pr_solid().
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/facedef.c,v 10.1 91/10/12 06:43:42 mike Rel4_0 Locker: mike $ (BRL)";
a63 2
void	get_pleqn(), get_rotfb(), get_nupnt(), calc_pnts();
int	get_3pnts();
d65 4
d79 1
d81 7
d195 1
a195 1
			get_pleqn(3,plane);
d212 1
a212 1
			if( get_3pts(3,plane) ){
d242 1
a242 1
			get_rotfb(3,plane,&es_rec.s);
d259 1
a259 1
			get_nupnt(3,plane);
d290 5
a294 3
/* 			G E T _ P L E Q N ( )
 * Gets the planar equation from the array cmd_args[] starting at the position 'arr_loc'
 * and puts the result at 'loc' of the array es_peqn.
d296 4
a299 4
void
get_pleqn(arr_loc,loc)
int arr_loc;
int loc;
d304 3
a306 3
		es_peqn[loc][i]= atof(cmd_args[arr_loc+i]);
	VUNITIZE( &es_peqn[loc][0] );
	es_peqn[loc][3] *= local2base;
d311 10
a320 4
/* 			G E T _ 3 P T S (  )
 * Gets three definite points from the array cmd_args[] starting at the position
 * 'arr_loc' and finds the planar equation from these points.  The result is stored
 * at 'loc' in the array es_peqn.
d322 5
a326 4
int
get_3pts(arr_loc,loc)
int arr_loc;
int loc;
d329 1
a329 1
	struct solidrec plane_pts;
d331 10
a340 5
	for(i=0; i<9; i++)
		plane_pts.s_values[i]=atof(cmd_args[arr_loc+i]) * local2base;
	if( planeqn(loc,0,1,2,&plane_pts) ){
		(void)printf("Facedef: not a plane\n");
		return(1);		/* failure */
d345 2
a346 1
/* 			G E T _ R O T F B (  )
d348 1
a348 2
 * Gets information from the array cmd_args[] starting at the position
 * 'arr_loc'.
d350 1
a350 1
 * fixed point. Result is stored in 'loc' of array es_peqn. The values
d353 4
a356 4
void
get_rotfb(arr_loc,loc,s_recp)
int arr_loc;
int loc;	
d361 1
a361 1
	struct solidrec plane_pts;
d363 2
a364 2
	rota= atof(cmd_args[arr_loc++]) * degtorad;
	fb  = atof(cmd_args[arr_loc++]) * degtorad;
d367 3
a369 3
	es_peqn[loc][0] = cos(fb) * cos(rota);
	es_peqn[loc][1] = cos(fb) * sin(rota);
	es_peqn[loc][2] = sin(fb);
d371 3
a373 3
	if( cmd_args[arr_loc][0] == 'v' ){     	/* vertex given */

		temp = atoi(++cmd_args[arr_loc]) - 1;	/* strip off 'v', subtract 1 */
d375 2
a376 2
			VADD2( &plane_pts.s_values[0], &s_recp->s_values[0], &s_recp->s_values[temp*3] );
			es_peqn[loc][3]= VDOT(&es_peqn[loc][0],&plane_pts.s_values[0]);
d378 1
a378 1
			es_peqn[loc][3]= VDOT(&es_peqn[loc][0],&s_recp->s_values[0]);
d380 1
a380 2
	}
	else{				         /* definite point given */
d382 2
a383 2
			plane_pts.s_values[i]=atof(cmd_args[arr_loc+i]) * local2base;
		es_peqn[loc][3]=VDOT(&es_peqn[loc][0], &plane_pts.s_values[0]);
d387 5
a391 3
/* 			G E T _ N U P N T ( )
 * Gets a point from the array cmd_arg[] starting at the  position 'arr_loc'.
 * The value of D at 'loc' in the array es_peqn is changed such that the plane
d395 3
a397 3
get_nupnt(arr_loc,loc)
int arr_loc;
int loc;
d399 2
a400 2
	short int i;
	struct solidrec plane_pts;
d403 2
a404 2
		plane_pts.s_values[i]= atof(cmd_args[arr_loc+i]) * local2base;
	es_peqn[loc][3]=VDOT(&es_peqn[loc][0], &plane_pts.s_values[0]);
@


10.1
log
@Release_4.0
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 9.3 90/04/21 06:06:04 mike Exp $ (BRL)";
a274 1
	pr_solid( &es_rec.s );
@


9.3
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 9.2 89/10/27 21:30:57 mike Locked $ (BRL)";
@


9.2
log
@Allow interrupts.  Let the user choose any vertex of a solid for
a face rotation and fallback angle.  From Dan Dender.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 9.1 89/05/19 06:03:09 phil Locked $ (BRL)";
d272 1
a272 1
	illump = redraw( illump, &es_rec, es_mat );
@


9.1
log
@Release_3.5
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 8.3 89/04/06 20:40:01 mike Exp $ (BRL)";
d29 1
d78 1
d349 1
d351 6
a356 3
		es_peqn[loc][3]=
			VDOT(&es_peqn[loc][0],
			     &s_recp->s_values[temp*3]);
d361 1
a361 2
		es_peqn[loc][3]=VDOT(&es_peqn[loc][0],
				     &plane_pts.s_values[0]);
@


8.3
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 8.2 88/12/06 01:20:47 mike Locked $ (BRL)";
@


8.2
log
@objdir.h --> raytrace.h
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/facedef.c,v 1.2 88/10/23 13:56:32 mike Exp $ (BRL)";
d27 1
@


8.1
log
@Release_3.0
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 7.4 88/09/21 02:32:10 mike Exp $ (BRL)";
d24 1
a25 1
#include "./objdir.h"
@


7.4
log
@get atof() extern from math.h
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 7.3 87/11/14 05:02:38 mike Locked $ (BRL)";
@


7.3
log
@Added dir_getmrec() to get all records for an item,
using malloc.
Added total path matrix as explicit arg to redraw().
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 7.2 87/11/05 05:06:04 mike Locked $ (BRL)";
a27 2

extern double atof();
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 7.1 87/11/03 00:00:52 mike Rel $ (BRL)";
d271 1
a271 1
	illump = redraw( illump, &es_rec );
@


7.1
log
@Release 2.3
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 6.1 87/07/11 08:04:04 mike Rel $ (BRL)";
d21 1
a21 1
#include "./machine.h"  /* a special copy */
d322 3
a324 1
 * Gets information from the array cmd_args[] starting at the position 'arr_loc'.
d335 1
a335 1
	float rota, fb;
@


6.1
log
@Release 2.0
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 5.1 87/06/24 22:20:49 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 4.3 87/02/13 00:07:42 mike Exp $ (BRL)";
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 4.2 87/02/11 05:31:32 mike Exp $ (BRL)";
@


4.2
log
@Latest fixes from Keith
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 4.1 86/12/29 03:21:43 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 1.2 86/09/10 19:43:20 mike Exp $ (BRL)";
d32 2
a33 2
int args;       			/* total number of args available */
int argcnt;     			/* holder for number of args added later */
d209 1
a209 1
			if( es_rec.s.s_cgtype == ARB7 ){
d222 1
a222 1
				if( cmd_args[5][0] == 'v' )       /* vertex point given,stop */
@


1.2
log
@"Invalid Author Specification"
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: facedef.c,v 1.1 86/09/10 01:37:57 mike Exp $ (BRL)";
@


1.1
log
@Initial revision
@
text
@a3 1
 *	Keith A. Applin
d16 1
a16 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@
