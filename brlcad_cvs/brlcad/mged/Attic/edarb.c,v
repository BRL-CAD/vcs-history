head	11.42;
access;
symbols
	ansi-20040405-merged:11.38.2.2
	postmerge-20040405-ansi:11.40
	premerge-20040404-ansi:11.39
	postmerge-autoconf:11.39
	autoconf-freeze:11.38.10.2
	premerge-autoconf:11.39
	postmerge-20040315-windows:11.39
	premerge-20040315-windows:11.39
	windows-20040315-freeze:11.38.4.1
	autoconf-20031203:11.38
	autoconf-20031202:11.38
	autoconf-branch:11.38.0.10
	phong-branch:11.38.0.8
	photonmap-branch:11.38.0.6
	rel-6-1-DP:11.38
	windows-branch:11.38.0.4
	rel-6-0-2:11.36
	ansi-branch:11.38.0.2
	rel-6-0-1-branch:11.36.0.2
	hartley-6-0-post:11.37
	hartley-6-0-pre:11.36
	rel-6-0-1:11.36
	rel-6-0:11.36
	rel-5-4:11.25.2.1
	offsite-5-3-pre:11.31
	rel-5-3:11.25
	rel-5-2:11.25
	rel-5-1-branch:11.25.0.2
	rel-5-1:11.25
	rel-5-0:11.23
	rel-5-0-beta:11.22
	rel-4-5:11.21
	ctj-4-5-post:11.20
	ctj-4-5-pre:11.20
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.5;
locks; strict;
comment	@ * @;


11.42
date	2004.05.21.17.47.41;	author morrison;	state dead;
branches;
next	11.41;

11.41
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.40;

11.40
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2002.08.20.17.08.22;	author jra;	state Exp;
branches
	11.38.2.1
	11.38.4.1
	11.38.10.1;
next	11.37;

11.37
date	2002.08.15.20.55.34;	author hartley;	state Exp;
branches;
next	11.36;

11.36
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	2001.04.03.17.41.09;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	2001.03.23.22.05.34;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	2000.09.15.20.06.08;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.09.07.02.43.21;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.09.07.01.55.31;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.08.19.03.10.45;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.06.28.16.59.16;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	99.12.29.23.23.23;	author mike;	state Exp;
branches
	11.25.2.1;
next	11.24;

11.24
date	99.11.24.14.26.41;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	99.09.01.18.55.10;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	98.11.06.22.32.39;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.04.09.20.32.06;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.02.27.21.13.49;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.12.30.22.40.47;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.09.23.18.29.33;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.07.30.21.34.10;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.07.15.20.35.44;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	95.11.07.22.57.16;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.02.18.03.08.49;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.37;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.04;	author mike;	state Rel4_4;
branches;
next	10.18;

10.18
date	94.12.30.01.07.52;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.12.16.19.41.48;	author gdurf;	state Exp;
branches;
next	10.16;

10.16
date	94.12.16.19.36.36;	author gdurf;	state Exp;
branches;
next	10.15;

10.15
date	94.11.10.12.06.06;	author jra;	state Exp;
branches;
next	10.14;

10.14
date	94.09.02.15.53.51;	author jra;	state Exp;
branches;
next	10.13;

10.13
date	94.08.31.17.08.25;	author jra;	state Exp;
branches;
next	10.12;

10.12
date	94.08.31.15.50.08;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.08.25.00.56.13;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.08.25.00.39.51;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.08.09.15.05.57;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.06.01.15.10.44;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.01.06.12.32.13;	author pjt;	state Exp;
branches;
next	10.6;

10.6
date	94.01.05.16.55.26;	author pjt;	state Exp;
branches;
next	10.5;

10.5
date	94.01.05.13.17.38;	author pjt;	state Exp;
branches;
next	10.4;

10.4
date	93.07.13.21.05.55;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.03.23.22.30.47;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.21.05.32.58;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.40;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.05.18.03.30.23;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.06.16.30.50;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.29.02;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.01;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.06.20.39.55;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.03.07.00.01.55;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.19.17;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.45;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.17.02.35.16;	author reschly;	state Exp;
branches;
next	7.3;

7.3
date	88.06.11.02.24.27;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.05.40;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.00.36;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.03.48;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.20.26;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.07.26;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.21.25;	author mike;	state Rel1;
branches;
next	2.10;

2.10
date	86.09.23.17.41.23;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.09.09.22.29.31;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.08.12.06.49.23;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.09.14.05.36.18;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.09.12.00.26.09;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.08.07.05.18.47;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.07.30.01.17.33;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.06.06.22.33.14;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.05.10.00.54.18;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.55.56;	author mike;	state Prod;
branches;
next	1.3;

1.3
date	85.02.14.00.51.30;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.01.16.01.57.51;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.50.26;	author mike;	state Exp;
branches;
next	;

11.25.2.1
date	2001.07.11.12.32.08;	author jra;	state Exp;
branches;
next	;

11.38.2.1
date	2002.09.19.18.02.01;	author morrison;	state Exp;
branches;
next	11.38.2.2;

11.38.2.2
date	2004.03.17.21.21.57;	author morrison;	state Exp;
branches;
next	;

11.38.4.1
date	2004.03.11.23.46.34;	author morrison;	state Exp;
branches;
next	;

11.38.10.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	11.38.10.2;

11.38.10.2
date	2004.03.15.14.07.36;	author erikg;	state Exp;
branches;
next	;


desc
@Edit an ARB
@


11.42
log
@moved to src/mged/
@
text
@/*
 *			E D A R B . C
 *
 * Functions -
 *	editarb		edit ARB edge (and move points)
 *	planeqn		finds plane equation given 3 points
 *	intersect	finds intersection point of three planes
 *	mv_edge		moves an arb edge
 *	f_extrude	"extrude" command -- project an ARB face
 *	f_arbdef	define ARB8 using rot fb angles to define face
 *	f_mirface	mirror an ARB face
 *	f_permute	permute ARB vertex labels
 *
 *  Author -
 *	Keith A. Applin
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/edarb.c,v 11.41 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <signal.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "rtgeom.h"
#include "./sedit.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./cmd.h"

void	ext4to6(int pt1, int pt2, int pt3, register struct rt_arb_internal *arb),old_ext4to6();

extern struct rt_db_internal	es_int;
extern struct rt_db_internal	es_int_orig;
extern struct bn_tol		mged_tol;		/* from ged.c */

/* face definitions for each arb type */
int arb_faces[5][24] = {
	{0,1,2,3, 0,1,4,5, 1,2,4,5, 0,2,4,5, -1,-1,-1,-1, -1,-1,-1,-1},	/* ARB4 */
	{0,1,2,3, 4,0,1,5, 4,1,2,5, 4,2,3,5, 4,3,0,5, -1,-1,-1,-1},	/* ARB5 */
	{0,1,2,3, 1,2,4,6, 0,4,6,3, 4,1,0,5, 6,2,3,7, -1,-1,-1,-1},	/* ARB6 */
	{0,1,2,3, 4,5,6,7, 0,3,4,7, 1,2,6,5, 0,1,5,4, 3,2,6,4},		/* ARB7 */
	{0,1,2,3, 4,5,6,7, 0,4,7,3, 1,2,6,5, 0,1,5,4, 3,2,6,7},		/* ARB8 */
};

/*
 *  			E D I T A R B
 *  
 *  An ARB edge is moved by finding the direction of
 *  the line containing the edge and the 2 "bounding"
 *  planes.  The new edge is found by intersecting the
 *  new line location with the bounding planes.  The
 *  two "new" planes thus defined are calculated and the
 *  affected points are calculated by intersecting planes.
 *  This keeps ALL faces planar.
 *
 */

/*  The storage for the "specific" ARB types is :
 *
 *	ARB4	0 1 2 0 3 3 3 3
 *	ARB5	0 1 2 3 4 4 4 4
 *	ARB6	0 1 2 3 4 4 5 5
 *	ARB7	0 1 2 3 4 5 6 4
 *	ARB8	0 1 2 3 4 5 6 7
 */

/* Another summary of how the vertices of ARBs are stored:
 *
 * Vertices:	1	2	3	4	5	6	7	8
 * Location----------------------------------------------------------------
 *	ARB8	0	1	2	3	4	5	6	7
 *	ARB7	0	1	2	3	4,7	5	6
 *	ARB6	0	1	2	3	4,5	6,7
 * 	ARB5	0	1	2	3	4,5,6,7
 *	ARB4	0,3	1	2	4,5,6,7
 */

/* The following arb editing arrays generally contain the following:
 *
 *	location 	comments
 *------------------------------------------------------------------------
 *	0,1		edge end points
 * 	2,3		bounding planes 1 and 2
 *	4, 5,6,7	plane 1 to recalculate, using next 3 points
 *	8, 9,10,11	plane 2 to recalculate, using next 3 points
 *	12, 13,14,15	plane 3 to recalculate, using next 3 points
 *	16,17		points (vertices) to recalculate
 *
 *
 * Each line is repeated for each edge (or point) to move
*/

/* edit array for arb8's */
#if 1
short earb8[12][18] = {
#else
static short earb8[12][18] = {
#endif
	{0,1, 2,3, 0,0,1,2, 4,0,1,4, -1,0,0,0, 3,5},	/* edge 12 */
	{1,2, 4,5, 0,0,1,2, 3,1,2,5, -1,0,0,0, 3,6},	/* edge 23 */
	{2,3, 3,2, 0,0,2,3, 5,2,3,6, -1,0,0,0, 1,7},	/* edge 34 */
	{0,3, 4,5, 0,0,1,3, 2,0,3,4, -1,0,0,0, 2,7},	/* edge 41 */
	{0,4, 0,1, 2,0,4,3, 4,0,1,4, -1,0,0,0, 7,5},	/* edge 15 */
	{1,5, 0,1, 4,0,1,5, 3,1,2,5, -1,0,0,0, 4,6},	/* edge 26 */
	{4,5, 2,3, 4,0,5,4, 1,4,5,6, -1,0,0,0, 1,7},	/* edge 56 */
	{5,6, 4,5, 3,1,5,6, 1,4,5,6, -1,0,0,0, 2,7},	/* edge 67 */
	{6,7, 3,2, 5,2,7,6, 1,4,6,7, -1,0,0,0, 3,4},	/* edge 78 */
	{4,7, 4,5, 2,0,7,4, 1,4,5,7, -1,0,0,0, 3,6},	/* edge 58 */
	{2,6, 0,1, 3,1,2,6, 5,2,3,6, -1,0,0,0, 5,7},	/* edge 37 */
	{3,7, 0,1, 2,0,3,7, 5,2,3,7, -1,0,0,0, 4,6},	/* edge 48 */
};

/* edit array for arb7's */
#if 1
short earb7[12][18] = {
#else
static short earb7[12][18] = {
#endif
	{0,1, 2,3, 0,0,1,2, 4,0,1,4, -1,0,0,0, 3,5},	/* edge 12 */
	{1,2, 4,5, 0,0,1,2, 3,1,2,5, -1,0,0,0, 3,6},	/* edge 23 */
	{2,3, 3,2, 0,0,2,3, 5,2,3,6, -1,0,0,0, 1,4},	/* edge 34 */
	{0,3, 4,5, 0,0,1,3, 2,0,3,4, -1,0,0,0, 2,-1},	/* edge 41 */
	{0,4, 0,5, 4,0,5,4, 2,0,3,4, 1,4,5,6, 1,-1},	/* edge 15 */
	{1,5, 0,1, 4,0,1,5, 3,1,2,5, -1,0,0,0, 4,6},	/* edge 26 */
	{4,5, 5,3, 2,0,3,4, 4,0,5,4, 1,4,5,6, 1,-1},	/* edge 56 */
	{5,6, 4,5, 3,1,6,5, 1,4,5,6, -1,0,0,0, 2, -1},	/* edge 67 */
	{2,6, 0,1, 5,2,3,6, 3,1,2,6, -1,0,0,0, 4,5},	/* edge 37 */
	{4,6, 4,3, 2,0,3,4, 5,3,4,6, 1,4,5,6, 2,-1},	/* edge 57 */
	{3,4, 0,1, 4,0,1,4, 2,0,3,4, 5,2,3,4, 5,6},	/* edge 45 */
	{-1,-1, -1,-1, 5,2,3,4, 4,0,1,4, 8,2,1,-1, 6,5},	/* point 5 */
};

/* edit array for arb6's */
#if 1
short earb6[10][18] = {
#else
static short earb6[10][18] = {
#endif
	{0,1, 2,1, 3,0,1,4, 0,0,1,2, -1,0,0,0, 3,-1},	/* edge 12 */
	{1,2, 3,4, 1,1,2,5, 0,0,1,2, -1,0,0,0, 3,4},	/* edge 23 */
	{2,3, 1,2, 4,2,3,5, 0,0,2,3, -1,0,0,0, 1,-1},	/* edge 34 */
	{0,3, 3,4, 2,0,3,5, 0,0,1,3, -1,0,0,0, 4,2},	/* edge 14 */
	{0,4, 0,1, 3,0,1,4, 2,0,3,4, -1,0,0,0, 6,-1},	/* edge 15 */
	{1,4, 0,2, 3,0,1,4, 1,1,2,4, -1,0,0,0, 6,-1},	/* edge 25 */
	{2,6, 0,2, 4,6,2,3, 1,1,2,6, -1,0,0,0, 4,-1},	/* edge 36 */
	{3,6, 0,1, 4,6,2,3, 2,0,3,6, -1,0,0,0, 4,-1},	/* edge 46 */
	{-1,-1, -1,-1, 2,0,3,4, 1,1,2,4, 3,0,1,4, 6,-1},/* point 5 */
	{-1,-1, -1,-1, 2,0,3,6, 1,1,2,6, 4,2,3,6, 4,-1},/* point 6 */
};

/* edit array for arb5's */
#if 1
short earb5[9][18] = {
#else
static short earb5[9][18] = {
#endif
	{0,1, 4,2, 0,0,1,2, 1,0,1,4, -1,0,0,0, 3,-1},	/* edge 12 */
	{1,2, 1,3, 0,0,1,2, 2,1,2,4, -1,0,0,0, 3,-1},	/* edge 23 */
	{2,3, 2,4, 0,0,2,3, 3,2,3,4, -1,0,0,0, 1,-1},	/* edge 34 */
	{0,3, 1,3, 0,0,1,3, 4,0,3,4, -1,0,0,0, 2,-1},	/* edge 14 */
	{0,4, 0,2, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* edge 15 */
	{1,4, 0,3, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* edge 25 */
	{2,4, 0,4, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1}, 	/* edge 35 */
	{3,4, 0,1, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* edge 45 */
	{-1,-1, -1,-1, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* point 5 */
};

/* edit array for arb4's */
#if 1
short earb4[5][18] = {
#else
static short earb4[5][18] = {
#endif
	{-1,-1, -1,-1, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* point 1 */
	{-1,-1, -1,-1, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* point 2 */
	{-1,-1, -1,-1, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* point 3 */
	{-1,-1, -1,-1, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* dummy */
	{-1,-1, -1,-1, 9,0,0,0, 9,0,0,0, 9,0,0,0, -1,-1},	/* point 4 */
};


int
editarb( vect_t pos_model )
{
	static int pt1, pt2, bp1, bp2, newp, p1, p2, p3;
	short *edptr;		/* pointer to arb edit array */
	short *final;		/* location of points to redo */
	static int i, *iptr;
	struct rt_arb_internal *arb;

	arb = (struct rt_arb_internal *)es_int.idb_ptr;
	RT_ARB_CK_MAGIC( arb );

	/* set the pointer */
	switch( es_type ) {

	        case ARB4:
		        edptr = &earb4[es_menu][0];
			final = &earb4[es_menu][16];
		break;

		case ARB5:
			edptr = &earb5[es_menu][0];
			final = &earb5[es_menu][16];
			if(es_edflag == PTARB) {
				edptr = &earb5[8][0];
				final = &earb5[8][16];
			}
		break;

		case ARB6:
			edptr = &earb6[es_menu][0];
			final = &earb6[es_menu][16];
			if(es_edflag == PTARB) {
				i = 9;
				if(es_menu == 4)
					i = 8;
				edptr = &earb6[i][0];
				final = &earb6[i][16];
			}
		break;

		case ARB7:
			edptr = &earb7[es_menu][0];
			final = &earb7[es_menu][16];
			if(es_edflag == PTARB) {
				edptr = &earb7[11][0];
				final = &earb7[11][16];
			}
		break;

		case ARB8:
		        edptr = &earb8[es_menu][0];
			final = &earb8[es_menu][16];
		break;

		default:
 		  Tcl_AppendResult(interp, "edarb: unknown ARB type\n", (char *)NULL);

		return(1);
	}

	/* do the arb editing */

	if( es_edflag == PTARB ) {
		/* moving a point - not an edge */
		VMOVE( arb->pt[es_menu] , pos_model );
		edptr += 4;
	} else if( es_edflag == EARB ) {
		vect_t	edge_dir;

		/* moving an edge */
		pt1 = *edptr++;
		pt2 = *edptr++;
		/* direction of this edge */
		if( newedge ) {
			/* edge direction comes from edgedir() in pos_model */
			VMOVE( edge_dir, pos_model );
			VMOVE(pos_model, arb->pt[pt1]);
			newedge = 0;
		} else {
			/* must calculate edge direction */
			VSUB2(edge_dir, arb->pt[pt2], arb->pt[pt1]);
		}
		if(MAGNITUDE(edge_dir) == 0.0) 
			goto err;
		/* bounding planes bp1,bp2 */
		bp1 = *edptr++;
		bp2 = *edptr++;

		/* move the edge */
/*
bu_log("moving edge: %d%d  bound planes: %d %d\n",pt1+1,pt2+1,bp1+1,bp2+1);
*/
		if( mv_edge(pos_model, bp1, bp2, pt1, pt2, edge_dir) )
			goto err;
	}

	/* editing is done - insure planar faces */
	/* redo plane eqns that changed */
	newp = *edptr++; 	/* plane to redo */

	if( newp == 9 )	/* special flag --> redo all the planes */
		if( rt_arb_calc_planes( es_peqn , arb , es_type , &mged_tol ) )
			goto err;

	if(newp >= 0 && newp < 6) {
		for(i=0; i<3; i++) {
			/* redo this plane (newp), use points p1,p2,p3 */
			p1 = *edptr++;
			p2 = *edptr++;
			p3 = *edptr++;
/*
bu_log("redo plane %d with points %d %d %d\n",newp+1,p1+1,p2+1,p3+1);
*/
			if( bn_mk_plane_3pts( es_peqn[newp], arb->pt[p1], arb->pt[p2],
						arb->pt[p3], &mged_tol ) )
				goto err;

			/* next plane */
			if( (newp = *edptr++) == -1 || newp == 8 )
				break;
		}
	}
	if(newp == 8) {
		/* special...redo next planes using pts defined in faces */
		for(i=0; i<3; i++) {
			if( (newp = *edptr++) == -1 )
				break;
			iptr = &arb_faces[es_type-4][4*newp];
			p1 = *iptr++;
			p2 = *iptr++;
			p3 = *iptr++;
/*
bu_log("REdo plane %d with points %d %d %d\n",newp+1,p1+1,p2+1,p3+1);
*/
			if( bn_mk_plane_3pts( es_peqn[newp], arb->pt[p1], arb->pt[p2],
					arb->pt[p3], &mged_tol ))
				goto err;
		}
	}

	/* the changed planes are all redone
	 *	push necessary points back into the planes
	 */
	edptr = final;	/* point to the correct location */
	for(i=0; i<2; i++) {
		if( (p1 = *edptr++) == -1 )
			break;
		/* intersect proper planes to define vertex p1 */
/*
bu_log("intersect: type=%d   point = %d\n",es_type,p1+1);
*/
		if( rt_arb_3face_intersect( arb->pt[p1], (const plane_t *)es_peqn, es_type, p1*3 ))
			goto err;
	}

	/* Special case for ARB7: move point 5 .... must
	 *	recalculate plane 2 = 456
	 */
	if(es_type == ARB7 && es_edflag == PTARB) {
/*
bu_log("redo plane 2 == 5,6,7 for ARB7\n");
*/
		if(  bn_mk_plane_3pts( es_peqn[2], arb->pt[4], arb->pt[5], arb->pt[6], &mged_tol ))
			goto err;
	}

	/* carry along any like points */
	switch( es_type ) {
		case ARB8:
		break;

		case ARB7:
			VMOVE( arb->pt[7] , arb->pt[4] )
			break;

		case ARB6:
			VMOVE( arb->pt[5] , arb->pt[4] );
			VMOVE( arb->pt[7] , arb->pt[6] );
			break;

		case ARB5:
			for( i=5 ; i<8 ; i++ )
				VMOVE( arb->pt[i] , arb->pt[4] )
			break;

		case ARB4:
			VMOVE( arb->pt[3] , arb->pt[0] );
			for( i=5 ; i<8 ; i++ )
				VMOVE( arb->pt[i] , arb->pt[4] )
		break;
	}

	return(0);		/* OK */

err:
	/* Error handling */
	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "cannot move edge: %d%d\n", pt1+1,pt2+1);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	es_edflag = IDLE;

	return(1);		/* BAD */
}

/*  MV_EDGE:
 *	Moves an arb edge (end1,end2) with bounding
 *	planes bp1 and bp2 through point "thru".
 *	The edge has (non-unit) slope "dir".
 *	Note that the fact that the normals here point in rather than
 *	out makes no difference for computing the correct intercepts.
 *	After the intercepts are found, they should be checked against
 *	the other faces to make sure that they are always "inside".
 */
int
mv_edge(
	vect_t thru,
	int bp1, int bp2, int end1, int end2,
	const vect_t	dir)
{
	struct rt_arb_internal *arb;
	fastf_t	t1, t2;

	if( bn_isect_line3_plane( &t1, thru, dir, es_peqn[bp1], &mged_tol ) < 0 ||
	    bn_isect_line3_plane( &t2, thru, dir, es_peqn[bp2], &mged_tol ) < 0 )  {
	  Tcl_AppendResult(interp, "edge (direction) parallel to face normal\n", (char *)NULL);
	  return( 1 );
	}

	arb = (struct rt_arb_internal *)es_int.idb_ptr;
	RT_ARB_CK_MAGIC( arb );

	VJOIN1( arb->pt[end1] , thru, t1, dir );
	VJOIN1( arb->pt[end2] , thru, t2, dir );

	return( 0 );
}

/* Extrude command - project an arb face */
/* Format: extrude face distance	*/
int
f_extrude(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i, j;
	static int face;
	static int pt[4];
	static int prod;
	static fastf_t dist;
	struct rt_arb_internal larb;	/* local copy of arb for new way */

	CHECK_DBI_NULL;

	if(argc < 3 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help extrude");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_S_EDIT, "Extrude" ) )
		return TCL_ERROR;

	if( es_int.idb_type != ID_ARB8 )
	{
	  Tcl_AppendResult(interp, "Extrude: solid type must be ARB\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if(es_type != ARB8 && es_type != ARB6 && es_type != ARB4) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "ARB%d: extrusion of faces not allowed\n",es_type);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  return TCL_ERROR;
	}

	face = atoi( argv[1] );

	/* get distance to project face */
	dist = atof( argv[2] );
	/* apply es_mat[15] to get to real model space */
	/* convert from the local unit (as input) to the base unit */
	dist = dist * es_mat[15] * local2base;

	bcopy( (char *)es_int.idb_ptr , (char *)&larb , sizeof( struct rt_arb_internal ) );

	if( (es_type == ARB6 || es_type == ARB4) && face < 1000 ) {
		/* 3 point face */
		pt[0] = face / 100;
		i = face - (pt[0]*100);
		pt[1] = i / 10;
		pt[2] = i - (pt[1]*10);
		pt[3] = 1;
	}
	else {
		pt[0] = face / 1000;
		i = face - (pt[0]*1000);
		pt[1] = i / 100;
		i = i - (pt[1]*100);
		pt[2] = i / 10;
		pt[3] = i - (pt[2]*10);
	}

	/* user can input face in any order - will use product of
	 * face points to distinguish faces:
	 *    product       face
	 *       24         1234 for ARB8
	 *     1680         5678 for ARB8
	 *      252         2367 for ARB8
	 *      160         1548 for ARB8
	 *      672         4378 for ARB8
	 *       60         1256 for ARB8
	 *	 10	    125 for ARB6
	 *	 72	    346 for ARB6
	 * --- special case to make ARB6 from ARB4
	 * ---   provides easy way to build ARB6's
	 *        6	    123 for ARB4
	 *	  8	    124 for ARB4
 	 *	 12	    134 for ARB4
	 *	 24	    234 for ARB4
	 */
	prod = 1;
	for( i = 0; i <= 3; i++ )  {
		prod *= pt[i];
		if(es_type == ARB6 && pt[i] == 6)
			pt[i]++;
		if(es_type == ARB4 && pt[i] == 4)
			pt[i]++;
		pt[i]--;
		if( pt[i] > 7 )  {
		  Tcl_AppendResult(interp, "bad face: ", argv[1], "\n", (char *)NULL);
		  return TCL_ERROR;
		}
	}

	/* find plane containing this face */
	if( bn_mk_plane_3pts( es_peqn[6], larb.pt[pt[0]], larb.pt[pt[1]],
				larb.pt[pt[2]], &mged_tol ) )
	{
	  Tcl_AppendResult(interp, "face: ", argv[1], " is not a plane\n", (char *)NULL);
	  return TCL_ERROR;
	}

	/* get normal vector of length == dist */
	for( i = 0; i < 3; i++ )
		es_peqn[6][i] *= dist;

	/* protrude the selected face */
	switch( prod )  {

	case 24:   /* protrude face 1234 */
		if(es_type == ARB6) {
		  Tcl_AppendResult(interp, "ARB6: extrusion of face ", argv[1],
				   " not allowed\n", (char *)NULL);
		  return TCL_ERROR;
		}
		if(es_type == ARB4)
			goto a4toa6;	/* extrude face 234 of ARB4 to make ARB6 */

		for( i = 0; i < 4; i++ )  {
			j = i + 4;
			VADD2( larb.pt[j] , larb.pt[i] , es_peqn[6] );
		}
		break;

	case 6:		/* extrude ARB4 face 123 to make ARB6 */
	case 8:		/* extrude ARB4 face 124 to make ARB6 */
	case 12:	/* extrude ARB4 face 134 to Make ARB6 */
a4toa6:
		ext4to6(pt[0], pt[1], pt[2], &larb);
		es_type = ARB6;
		sedit_menu();
	break;

	case 1680:   /* protrude face 5678 */
		for( i = 0; i < 4; i++ )  {
			j = i + 4;
			VADD2( larb.pt[i] , larb.pt[j] , es_peqn[6] );
		}
		break;

	case 60:   /* protrude face 1256 */
	case 10:   /* extrude face 125 of ARB6 */
		VADD2( larb.pt[3] , larb.pt[0] , es_peqn[6] );
		VADD2( larb.pt[2] , larb.pt[1] , es_peqn[6] );
		VADD2( larb.pt[7] , larb.pt[4] , es_peqn[6] );
		VADD2( larb.pt[6] , larb.pt[5] , es_peqn[6] );
		break;

	case 672:   /* protrude face 4378 */
	case 72:	/* extrude face 346 of ARB6 */
		VADD2( larb.pt[0] , larb.pt[3] , es_peqn[6] );
		VADD2( larb.pt[1] , larb.pt[2] , es_peqn[6] );
		VADD2( larb.pt[5] , larb.pt[6] , es_peqn[6] );
		VADD2( larb.pt[4] , larb.pt[7] , es_peqn[6] );
		break;

	case 252:   /* protrude face 2367 */
		VADD2( larb.pt[0] , larb.pt[1] , es_peqn[6] );
		VADD2( larb.pt[3] , larb.pt[2] , es_peqn[6] );
		VADD2( larb.pt[4] , larb.pt[5] , es_peqn[6] );
		VADD2( larb.pt[7] , larb.pt[6] , es_peqn[6] );
		break;

	case 160:   /* protrude face 1548 */
		VADD2( larb.pt[1] , larb.pt[0] , es_peqn[6] );
		VADD2( larb.pt[5] , larb.pt[4] , es_peqn[6] );
		VADD2( larb.pt[2] , larb.pt[3] , es_peqn[6] );
		VADD2( larb.pt[6] , larb.pt[7] , es_peqn[6] );
		break;

	case 120:
	case 180:
	  Tcl_AppendResult(interp, "ARB6: extrusion of face ", argv[1],
			   " not allowed\n", (char *)NULL);
	  return TCL_ERROR;

	default:
	  Tcl_AppendResult(interp, "bad face: ", argv[1], "\n", (char *)NULL);
	  return TCL_ERROR;
	}

	/* redo the plane equations */
	if( rt_arb_calc_planes( es_peqn , &larb , es_type , &mged_tol ) )
	{
	  Tcl_AppendResult(interp, "Cannot calculate new plane equations for faces\n",
			   (char *)NULL);
	  return TCL_ERROR;
	}

	/* copy local copy back to original */
	bcopy( (char *)&larb , (char *)es_int.idb_ptr , sizeof( struct rt_arb_internal ) );
		
	/* draw the updated solid */
	replot_editing_solid();
	update_views = 1;

	return TCL_OK;
}

/* define an arb8 using rot fb angles to define a face */
/* Format: a name rot fb	*/
int
f_arbdef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *dp;
	struct rt_db_internal	internal;
	struct rt_arb_internal	*arb;
	int i, j;
	fastf_t rota, fb;
	vect_t norm1,norm2,norm3;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help arb");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip,  argv[1] , LOOKUP_QUIET ) != DIR_NULL )  {
	  aexists( argv[1] );
	  return TCL_ERROR;
	}

	/* get rotation angle */
	rota = atof( argv[2] ) * degtorad;

	/* get fallback angle */
	fb = atof( argv[3] ) * degtorad;

	BU_GETSTRUCT( arb, rt_arb_internal );
	RT_INIT_DB_INTERNAL( &internal );
	internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	internal.idb_type = ID_ARB8;
	internal.idb_meth = &rt_functab[ID_ARB8];
	internal.idb_ptr = (genptr_t)arb;
	arb->magic = RT_ARB_INTERNAL_MAGIC;

	/* put vertex of new solid at center of screen */
	VSET(arb->pt[0], -view_state->vs_vop->vo_center[MDX], -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);

	/* calculate normal vector defined by rot,fb */
	norm1[0] = cos(fb) * cos(rota);
	norm1[1] = cos(fb) * sin(rota);
	norm1[2] = sin(fb);

	/* find two perpendicular vectors which are perpendicular to norm */
	j = 0;
	for( i = 0; i < 3; i++ )  {
		if( fabs(norm1[i]) < fabs(norm1[j]) )
			j = i;
	}
	VSET( norm2 , 0.0 , 0.0 , 0.0 );
	norm2[j] = 1.0;
	VCROSS( norm3 , norm2 , norm1 );
	VCROSS( norm2 , norm3 , norm1 );

	/* create new rpp 20x20x2 */
	/* the 20x20 faces are in rot,fb plane */
	VUNITIZE( norm2 );
	VUNITIZE( norm3 );
	VJOIN1( arb->pt[1] , arb->pt[0] , 508.0 , norm2 );
	VJOIN1( arb->pt[3] , arb->pt[0] , -508.0 , norm3 );
	VJOIN2( arb->pt[2] , arb->pt[0] , 508.0 , norm2 , -508.0 , norm3 );
	for( i=0 ; i<4 ; i++ )
		VJOIN1( arb->pt[i+4] , arb->pt[i] , -50.8 , norm1 );

	/* no interrupts */
	(void)signal( SIGINT, SIG_IGN );

	if( (dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&internal.idb_type)) == DIR_NULL )
	{
		rt_db_free_internal( &internal, &rt_uniresource );
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &internal, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}

	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = argv[1]; /* depends on solid name being in argv[1] */
	  av[2] = NULL;

	  /* draw the "made" solid */
	  return cmd_draw( clientData, interp, 2, av );
	}
}

/* Mirface command - mirror an arb face */
/* Format: mirror face axis	*/
int
f_mirface(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i, j, k;
	static int face;
	static int pt[4];
	static int prod;
	static vect_t work;
	struct rt_arb_internal *arb;
	struct rt_arb_internal larb;	/* local copy of solid */

	if(argc < 3 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help mirface");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_S_EDIT, "Mirface" ) )
	  return TCL_ERROR;

	if( es_int.idb_type != ID_ARB8 )
	{
	  Tcl_AppendResult(interp, "Mirface: solid type must be ARB\n", (char *)NULL);
	  return TCL_ERROR;
	}

	arb = (struct rt_arb_internal *)es_int.idb_ptr;
	RT_ARB_CK_MAGIC( arb );

	if(es_type != ARB8 && es_type != ARB6) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "ARB%d: mirroring of faces not allowed\n",es_type);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);

	  return TCL_ERROR;
	}
	face = atoi( argv[1] );
	if( face > 9999 || (face < 1000 && es_type != ARB6) ) {
	  Tcl_AppendResult(interp, "ERROR: ", argv[1], " bad face\n", (char *)NULL);
	  return TCL_ERROR;
	}
	/* check which axis */
	k = -1;
	if( strcmp( argv[2], "x" ) == 0 )
		k = 0;
	if( strcmp( argv[2], "y" ) == 0 )
		k = 1;
	if( strcmp( argv[2], "z" ) == 0 )
		k = 2;
	if( k < 0 ) {
	  Tcl_AppendResult(interp, "axis must be x, y or z\n", (char *)NULL);
	  return TCL_ERROR;
	}

	work[0] = work[1] = work[2] = 1.0;
	work[k] = -1.0;

	/* make local copy of arb */
	bcopy( (char *)arb , (char *)&larb , sizeof( struct rt_arb_internal ) );

	if(es_type == ARB6 && face < 1000) { 	/* 3 point face */
		pt[0] = face / 100;
		i = face - (pt[0]*100);
		pt[1] = i / 10;
		pt[2] = i - (pt[1]*10);
		pt[3] = 1;
	}
	else {
		pt[0] = face / 1000;
		i = face - (pt[0]*1000);
		pt[1] = i / 100;
		i = i - (pt[1]*100);
		pt[2] = i / 10;
		pt[3] = i - (pt[2]*10);
	}

	/* user can input face in any order - will use product of
	 * face points to distinguish faces:
	 *    product       face
	 *       24         1234 for ARB8
	 *     1680         5678 for ARB8
	 *      252         2367 for ARB8
	 *      160         1548 for ARB8
	 *      672         4378 for ARB8
	 *       60         1256 for ARB8
	 *	 10	    125 for ARB6
	 *	 72	    346 for ARB6
	 */
	prod = 1;
	for( i = 0; i <= 3; i++ )  {
		prod *= pt[i];
		pt[i]--;
		if( pt[i] > 7 )  {
		  Tcl_AppendResult(interp, "bad face: ", argv[1], "\n", (char *)NULL);
		  return TCL_ERROR;
		}
	}

	/* mirror the selected face */
	switch( prod )  {

	case 24:   /* mirror face 1234 */
		if(es_type == ARB6) {
		  Tcl_AppendResult(interp, "ARB6: mirroring of face ", argv[1],
				   " not allowed\n", (char *)NULL);
		  return TCL_ERROR;
		}
		for( i = 0; i < 4; i++ )  {
			j = i + 4;
			VELMUL( larb.pt[j] , larb.pt[i] , work );
		}
		break;

	case 1680:   /* mirror face 5678 */
		for( i = 0; i < 4; i++ )  {
			j = i + 4;
			VELMUL( larb.pt[i] , larb.pt[j] , work );
		}
		break;

	case 60:   /* mirror face 1256 */
	case 10:	/* mirror face 125 of ARB6 */
		VELMUL( larb.pt[3] , larb.pt[0] , work );
		VELMUL( larb.pt[2] , larb.pt[1] , work );
		VELMUL( larb.pt[7] , larb.pt[4] , work );
		VELMUL( larb.pt[6] , larb.pt[5] , work );
		break;

	case 672:   /* mirror face 4378 */
	case 72:	/* mirror face 346 of ARB6 */
		VELMUL( larb.pt[0] , larb.pt[3] , work );
		VELMUL( larb.pt[1] , larb.pt[2] , work );
		VELMUL( larb.pt[5] , larb.pt[6] , work );
		VELMUL( larb.pt[4] , larb.pt[7] , work );
		break;

	case 252:   /* mirror face 2367 */
		VELMUL( larb.pt[0] , larb.pt[1] , work );
		VELMUL( larb.pt[3] , larb.pt[2] , work );
		VELMUL( larb.pt[4] , larb.pt[5] , work );
		VELMUL( larb.pt[7] , larb.pt[6] , work );
		break;

	case 160:   /* mirror face 1548 */
		VELMUL( larb.pt[1] , larb.pt[0] , work );
		VELMUL( larb.pt[5] , larb.pt[4] , work );
		VELMUL( larb.pt[2] , larb.pt[3] , work );
		VELMUL( larb.pt[6] , larb.pt[7] , work );
		break;

	case 120:
	case 180:
	  Tcl_AppendResult(interp, "ARB6: mirroring of face ", argv[1],
			   " not allowed\n", (char *)NULL);
	  return TCL_ERROR;
	default:
	  Tcl_AppendResult(interp, "bad face: ", argv[1], "\n", (char *)NULL);
	  return TCL_ERROR;
	}

	/* redo the plane equations */
	if( rt_arb_calc_planes( es_peqn , &larb , es_type , &mged_tol ) )
	  return TCL_ERROR;

	/* copy to original */
	bcopy( (char *)&larb , (char *)arb , sizeof( struct rt_arb_internal ) );

	/* draw the updated solid */
	replot_editing_solid();
	view_state->vs_flag = 1;

	return TCL_OK;
}

/* Edgedir command:  define the direction of an arb edge being moved
 *	Format:  edgedir deltax deltay deltaz
	     OR  edgedir rot fb
 */

int
f_edgedir(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;
	vect_t slope;
	FAST fastf_t rot, fb;

	if(argc < 3 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help edgedir");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_S_EDIT, "Edgedir" ) )
	  return TCL_ERROR;

	if( es_edflag != EARB ) {
	  Tcl_AppendResult(interp, "Not moving an ARB edge\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( es_int.idb_type != ID_ARB8 )
	{
	  Tcl_AppendResult(interp, "Edgedir: solid type must be an ARB\n", (char *)NULL);
	  return TCL_ERROR;
	}

	/* set up slope -
	 *	if 2 values input assume rot, fb used
	 *	else assume delta_x, delta_y, delta_z
	 */
	if( argc == 3 ) {
		rot = atof( argv[1] ) * degtorad;
		fb = atof( argv[2] ) * degtorad;
		slope[0] = cos(fb) * cos(rot);
		slope[1] = cos(fb) * sin(rot);
		slope[2] = sin(fb);
	} 
	else {
		for(i=0; i<3; i++) {
			/* put edge slope in slope[] array */
			slope[i] = atof( argv[i+1] );
		}
	}

	if(MAGNITUDE(slope) == 0) {
	  Tcl_AppendResult(interp, "BAD slope\n", (char *)NULL);
	  return TCL_ERROR;
	}

	/* get it done */
	newedge = 1;
	editarb( slope );
#if 1
	sedit();
	return TCL_OK;
#else
	sedraw++;

	return TCL_ERROR;
#endif
}


/*	EXT4TO6():	extrudes face pt1 pt2 pt3 of an ARB4 "distance"
 *			to produce ARB6
 */
void
ext4to6(int pt1, int pt2, int pt3, register struct rt_arb_internal *arb)
{
	point_t pts[8];
	register int i;

	VMOVE(pts[0], arb->pt[pt1]);
	VMOVE(pts[1], arb->pt[pt2]);
	VMOVE(pts[4], arb->pt[pt3]);
	VMOVE(pts[5], arb->pt[pt3]);

	/* extrude "distance" to get remaining points */
	VADD2(pts[2], pts[1], &es_peqn[6][0]);
	VADD2(pts[3], pts[0], &es_peqn[6][0]);
	VADD2(pts[6], pts[4], &es_peqn[6][0]);
	VMOVE(pts[7], pts[6]);

	/* copy to the original record */
	for( i=0 ; i<8 ; i++ )
		VMOVE(arb->pt[i], pts[i])

}

/* Permute command - permute the vertex labels of an ARB
 * Format: permute tuple	*/

/*
 *	     Minimum and maximum tuple lengths
 *     ------------------------------------------------
 *	Solid	# vertices needed	# vertices
 *	type	 to disambiguate	in THE face
 *     ------------------------------------------------
 *	ARB4		3		    3
 *	ARB5		2		    4
 *	ARB6		2		    4
 *	ARB7		1		    4
 *	ARB8		3		    4
 *     ------------------------------------------------
 */
int
f_permute(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    /*
     *	1) Why were all vars declared static?
     *	2) Recompute plane equations?
     */
    register int 	vertex, i, k;
    int			arglen;
    int			face_size;	/* # vertices in THE face */
    char		**p;
    struct rt_arb_internal	*arb;
    struct rt_arb_internal	larb;		/* local copy of solid */
    struct rt_arb_internal	tarb;		/* temporary copy of solid */
    static int		min_tuple_size[9] = {0, 0, 0, 0, 3, 2, 2, 1, 3};
    /*
     *			The Permutations
     *
     *	     Each permutation is encoded as an 8-character string,
     *	where the ith character specifies which of the current vertices
     *	(1 through n for an ARBn) should assume the role of vertex i.
     *	Wherever the internal representation of the ARB as an ARB8
     *	stores a redundant copy of a vertex, the string contains a '*'.
     */
    static char 	*perm4[4][7] =
    {
	{"123*4***", "124*3***", "132*4***", "134*2***", "142*3***",
	 "143*2***", 0},
	{"213*4***", "214*3***", "231*4***", "234*1***", "241*3***",
	 "243*1***", 0},
	{"312*4***", "314*2***", "321*4***", "324*1***", "341*2***",
	 "342*1***", 0},
	{"412*3***", "413*2***", "421*3***", "423*1***", "431*2***",
	 "432*1***", 0}
    };
    static char 	*perm5[5][3] =
    {
	{"12345***", "14325***", 0},
	{"21435***", "23415***", 0},
	{"32145***", "34125***", 0},
	{"41235***", "43215***", 0},
	{0, 0, 0}
    };
    static char 	*perm6[6][3] =
    {
	{"12345*6*", "15642*3*", 0},
	{"21435*6*", "25631*4*", 0},
	{"34126*5*", "36524*1*", 0},
	{"43216*5*", "46513*2*", 0},
	{"51462*3*", "52361*4*", 0},
	{"63254*1*", "64153*2*", 0}
    };
    static char		*perm7[7][2] =
    {
	{"1234567*", 0},
	{0, 0},
	{0, 0},
	{"4321576*", 0},
	{0, 0},
	{"6237514*", 0},
	{"7326541*", 0}
    };
    static char		*perm8[8][7] =
    {
	{"12345678", "12654378", "14325876", "14852376",
	 "15624873", "15842673", 0},
	{"21436587", "21563487", "23416785", "23761485",
	 "26513784", "26731584", 0},
	{"32147658", "32674158", "34127856", "34872156",
	 "37624851", "37842651", 0},
	{"41238567", "41583267", "43218765", "43781265",
	 "48513762", "48731562", 0},
	{"51268437", "51486237", "56218734", "56781234",
	 "58416732", "58761432", 0},
	{"62157348", "62375148", "65127843", "65872143",
	 "67325841", "67852341", 0},
	{"73268415", "73486215", "76238514", "76583214",
	 "78436512", "78563412", 0},
	{"84157326", "84375126", "85147623", "85674123",
	 "87345621", "87654321", 0}
    };
    static int	vert_loc[] =
    {
	/*		-----------------------------
	 *		   Array locations in which
	 *		   the vertices are stored
	 *		-----------------------------
	 *		1   2   3   4   5   6   7   8
	 *		-----------------------------
	 * ARB4 */	0,  1,  2,  4, -1, -1, -1, -1,
	/* ARB5 */	0,  1,  2,  3,  4, -1, -1, -1,
	/* ARB6 */	0,  1,  2,  3,  4,  6, -1, -1,
	/* ARB7 */	0,  1,  2,  3,  4,  5,  6, -1,
	/* ARB8 */	0,  1,  2,  3,  4,  5,  6,  7
    };
#define		ARB_VERT_LOC(n,v)	vert_loc[((n) - 4) * 8 + (v) - 1]

    CHECK_DBI_NULL;
    CHECK_READ_ONLY;

    if(argc < 2 || 2 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help permute");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    if (not_state(ST_S_EDIT, "Permute"))
      return TCL_ERROR;

    if( es_int.idb_type != ID_ARB8 )
    {
      Tcl_AppendResult(interp, "Permute: solid type must be an ARB\n", (char *)NULL);
      return TCL_ERROR;
    }

    if ((es_type < 4) || (es_type > 8))
    {
      struct bu_vls tmp_vls;
      
      bu_vls_init(&tmp_vls);
      bu_vls_printf(&tmp_vls, "Permute: es_type=%d\nThis shouldn't happen\n", es_type);
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);
      return TCL_ERROR;
    }

    arb = (struct rt_arb_internal *)es_int.idb_ptr;
    RT_ARB_CK_MAGIC( arb );

    /* make a local copy of the solid */
    bcopy( (char *)arb , (char *)&larb , sizeof( struct rt_arb_internal ) );

    /*
     *	Find the encoded form of the specified permutation,
     *	if it exists
     */
    arglen = strlen(argv[1]);
    if (arglen < min_tuple_size[es_type])
    {
      struct bu_vls tmp_vls;

      bu_vls_init(&tmp_vls);
      bu_vls_printf(&tmp_vls, "ERROR: tuple '%s' too short to disambiguate ARB%d face\n",
		    argv[1], es_type);
      bu_vls_printf(&tmp_vls, "Need at least %d vertices\n", min_tuple_size[es_type]);
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);

      return TCL_ERROR;
    }
    face_size = (es_type == 4) ? 3 : 4;
    if (arglen > face_size)
    {
      struct bu_vls tmp_vls;

      bu_vls_init(&tmp_vls);
      bu_vls_printf(&tmp_vls, "ERROR: tuple '%s' length exceeds ARB%d face size of %d\n",
		    argv[1], es_type, face_size);
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);
      
      return TCL_ERROR;
    }
    vertex = argv[1][0] - '1';
    if ((vertex < 0) || (vertex >= es_type))
    {
      struct bu_vls tmp_vls;

      bu_vls_init(&tmp_vls);
      bu_vls_printf(&tmp_vls, "ERROR: invalid vertex %c\n", argv[1][0]);
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);
      return TCL_ERROR;
    }
    p = (es_type == 4) ? perm4[vertex] :
	(es_type == 5) ? perm5[vertex] :
	(es_type == 6) ? perm6[vertex] :
	(es_type == 7) ? perm7[vertex] : perm8[vertex];
    for ( ;; ++p)
    {
	if (*p == 0)
	{
	  Tcl_AppendResult(interp, "ERROR: invalid vertex tuple: '",
			   argv[1], "'\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if (strncmp(*p, argv[1], arglen) == 0)
	    break;
    }

    /*
     *	Collect the vertices in the specified order
     */
    for (i = 0; i < 8; ++i)
    {
	char	buf[2];

	if ((*p)[i] == '*')
	    continue;
	sprintf(buf, "%c", (*p)[i]);
	k = atoi(buf);
	VMOVE( tarb.pt[i], larb.pt[ARB_VERT_LOC(es_type, k)]);
    }

#if 0
    bu_log("After collection...\n");
    for (i = 0; i < 8 ; i++ )
    {
	char	string[1024];

	sprintf(string, "vertex %d", i + 1);
	VPRINT(string, tarb.pt[i]);
    }
    bu_log("...\n");
#endif

    /*
     *	Reinstall the permuted vertices back into the temporary buffer,
     *	copying redundant vertices as necessay
     *
     *		-------+-------------------------
     *		 Solid |    Redundant storage
     *		  Type | of some of the vertices
     *		-------+-------------------------
     *		 ARB4  |    3=0, 5=6=7=4
     *		 ARB5  |    5=6=7=4
     *		 ARB6  |    5=4, 7=6
     *		 ARB7  |    7=4
     *		 ARB8  |
     *		-------+-------------------------
     */
    for (i = 0; i < 8; i++ )
    {
	VMOVE( larb.pt[i], tarb.pt[i]);
    }
    switch (es_type)
    {
	case ARB4:
	    VMOVE(larb.pt[3], larb.pt[0]);
	    /* break intentionally left out */
	case ARB5:
	    VMOVE(larb.pt[5], larb.pt[4]);
	    VMOVE(larb.pt[6], larb.pt[4]);
	    VMOVE(larb.pt[7], larb.pt[4]);
	    break;
	case ARB6:
	    VMOVE(larb.pt[5], larb.pt[4]);
	    VMOVE(larb.pt[7], larb.pt[6]);
	    break;
	case ARB7:
	    VMOVE(larb.pt[7], larb.pt[4]);
	    break;
	case ARB8:
	    break;
	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "%s: %d: This shouldn't happen\n", __FILE__, __LINE__);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	    return TCL_ERROR;
	  }
    }

    /* copy back to original arb */
    bcopy( (char *)&larb , (char *)arb , sizeof( struct rt_arb_internal ) );

    /* draw the updated solid */
    replot_editing_solid();
    view_state->vs_flag = 1;

    return TCL_OK;
}
@


11.41
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/edarb.c,v 11.40 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.40
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d30 5
a34 1
#include "conf.h"
@


11.39
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.38 2002/08/20 17:08:22 jra Exp $ (BRL)";
d53 1
a53 1
void	ext4to6(),old_ext4to6();
d452 1
a452 5
f_extrude(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d659 1
a659 5
f_arbdef(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d682 1
a682 1
	  aexists( interp, argv[1] );
d760 1
a760 5
f_mirface(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d946 1
a946 5
f_edgedir(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1017 1
a1017 3
ext4to6(pt1, pt2, pt3, arb)
int pt1, pt2, pt3;
register struct rt_arb_internal *arb;
d1056 1
a1056 6
f_permute(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;

@


11.38
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.36 2001/10/02 19:24:32 jra Exp $ (BRL)";
@


11.38.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/edarb.c,v 11.39 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.38.10.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.39 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.38.10.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.38.10.1 2004/02/12 18:34:14 erikg Exp $ (BRL)";
@


11.38.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.38 2002/08/20 17:08:22 jra Exp $ (BRL)";
d53 1
a53 1
void	ext4to6(int pt1, int pt2, int pt3, register struct rt_arb_internal *arb),old_ext4to6();
d452 5
a456 1
f_extrude(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d663 5
a667 1
f_arbdef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d690 1
a690 1
	  aexists( argv[1] );
d768 5
a772 1
f_mirface(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d958 5
a962 1
f_edgedir(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1033 3
a1035 1
ext4to6(int pt1, int pt2, int pt3, register struct rt_arb_internal *arb)
d1074 6
a1079 1
f_permute(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.38.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.37
log
@Converted from K&R to ANSI C - RFH
@
text
@d53 1
a53 1
void	ext4to6(int pt1, int pt2, int pt3, register struct rt_arb_internal *arb),old_ext4to6();
d452 5
a456 1
f_extrude(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d663 5
a667 1
f_arbdef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d690 1
a690 1
	  aexists( argv[1] );
d768 5
a772 1
f_mirface(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d958 5
a962 1
f_edgedir(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1033 3
a1035 1
ext4to6(int pt1, int pt2, int pt3, register struct rt_arb_internal *arb)
d1074 6
a1079 1
f_permute(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.36
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.35 2001/06/05 15:51:41 bparker Exp $ (BRL)";
d53 1
a53 1
void	ext4to6(),old_ext4to6();
d452 1
a452 5
f_extrude(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d659 1
a659 5
f_arbdef(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d682 1
a682 1
	  aexists( interp, argv[1] );
d760 1
a760 5
f_mirface(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d946 1
a946 5
f_edgedir(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1017 1
a1017 3
ext4to6(pt1, pt2, pt3, arb)
int pt1, pt2, pt3;
register struct rt_arb_internal *arb;
d1056 1
a1056 6
f_permute(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;

@


11.35
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.34 2001/06/01 19:23:24 bparker Exp $ (BRL)";
d702 1
@


11.34
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.33 2001/04/03 17:41:09 jra Exp $ (BRL)";
a707 1
#ifdef MGED_USE_VIEW_OBJ
a708 3
#else
	VSET( arb->pt[0] , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ] );
#endif
@


11.33
log
@Corrected f_arbdef() to eliminate double freeing of rt_arb_internal
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.32 2001/03/23 22:05:34 jra Exp $ (BRL)";
d51 1
d708 3
d712 1
d764 1
a764 1
	  return f_edit( clientData, interp, 2, av );
@


11.32
log
@Support for major and minor types in directory structure
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/edarb.c,v 11.31 2000/09/15 20:06:08 bparker Exp $ (BRL)";
d670 1
a670 1
	struct rt_arb_internal	arb;
d699 1
d703 2
a704 2
	internal.idb_ptr = (genptr_t)&arb;
	arb.magic = RT_ARB_INTERNAL_MAGIC;
d707 1
a707 1
	VSET( arb.pt[0] , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ] );
d729 3
a731 3
	VJOIN1( arb.pt[1] , arb.pt[0] , 508.0 , norm2 );
	VJOIN1( arb.pt[3] , arb.pt[0] , -508.0 , norm3 );
	VJOIN2( arb.pt[2] , arb.pt[0] , 508.0 , norm2 , -508.0 , norm3 );
d733 1
a733 1
		VJOIN1( arb.pt[i+4] , arb.pt[i] , -50.8 , norm1 );
d740 1
@


11.31
log
@Cast es_peqn to (const plane_t *)
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.30 2000/09/08 05:55:48 mike Exp $ (BRL)";
d737 1
a737 1
	if( (dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
@


11.30
log
@
Tree routines now need resource structure.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.29 2000/09/07 02:43:21 mike Exp $ (BRL)";
d356 1
a356 1
		if( rt_arb_3face_intersect( arb->pt[p1], es_peqn, es_type, p1*3 ))
@


11.29
log
@
More externs to ged.h to silence lint
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.28 2000/09/07 01:55:31 mike Exp $ (BRL)";
d743 1
a743 1
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )
d745 1
a745 1
		rt_db_free_internal( &internal );
@


11.28
log
@
Moved 2 routines from mged/edarb.c to librt/g_arb.c
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.27 2000/08/19 03:10:45 mike Exp $ (BRL)";
d205 1
a205 2
editarb( pos_model )
vect_t pos_model;
d425 4
a428 4
mv_edge(thru, bp1, bp2, end1, end2, dir)
vect_t thru;
int bp1, bp2, end1, end2;
vect_t	dir;
@


11.27
log
@
const RCSid
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.26 2000/06/28 16:59:16 mike Exp $ (BRL)";
a415 9
/* planes to define ARB vertices */
CONST int rt_arb_planes[5][24] = {
	{0,1,3, 0,1,2, 0,2,3, 0,1,3, 1,2,3, 1,2,3, 1,2,3, 1,2,3},	/* ARB4 */
	{0,1,4, 0,1,2, 0,2,3, 0,3,4, 1,2,4, 1,2,4, 1,2,4, 1,2,4},	/* ARB5 */
	{0,2,3, 0,1,3, 0,1,4, 0,2,4, 1,2,3, 1,2,3, 1,2,4, 1,2,4},	/* ARB6 */
	{0,2,4, 0,3,4, 0,3,5, 0,2,5, 1,4,5, 1,3,4, 1,3,5, 1,2,4},	/* ARB7 */
	{0,2,4, 0,3,4, 0,3,5, 0,2,5, 1,2,4, 1,3,4, 1,3,5, 1,2,5},	/* ARB8 */
};

a1352 69
}

/* --- General ARB8 utility routines --- */

/*
 *			R T _ A R B _ C A L C _ P O I N T S
 *
 * Takes the planes[] array and intersects the planes to find the vertices
 * of a GENARB8.  The vertices are stored into arb->pt[].
 * This is an analog of rt_arb_calc_planes().
 */
int
rt_arb_calc_points( arb, cgtype, planes, tol )
struct rt_arb_internal	*arb;
int		cgtype;
plane_t		planes[6];
CONST struct bn_tol	*tol;
{
	int	i;
	point_t	pt[8];

	RT_ARB_CK_MAGIC(arb);

	/* find new points for entire solid */
	for(i=0; i<8; i++){
		if( rt_arb_3face_intersect( pt[i], planes, cgtype, i*3 ) < 0 )  {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "rt_arb_calc_points: Intersection of planes fails %d\n", i);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  return -1;			/* FAIL */
		}
	}

	/* Move new points to arb */
	for( i=0; i<8; i++ )  {
		VMOVE( arb->pt[i], pt[i] );
	}
	return 0;					/* success */
}

/*
 *			R T _ A R B _ 3 F A C E _ I N T E R S E C T
 *
 *	Finds the intersection point of three faces of an ARB.
 *
 *  Returns -
 *	  0	success
 *	 -1	failure
 */
int
rt_arb_3face_intersect( point, planes, type, loc )
point_t			point;
plane_t			planes[6];
int			type;		/* 4..8 */
int			loc;
{
	int	j;
	int	i1, i2, i3;

	j = type - 4;

	i1 = rt_arb_planes[j][loc];
	i2 = rt_arb_planes[j][loc+1];
	i3 = rt_arb_planes[j][loc+2];

	return bn_mkpoint_3planes( point, planes[i1], planes[i2], planes[i3] );
@


11.26
log
@
Removed unnecessary reference to es_ext.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.25 1999/12/29 23:23:23 mike Exp $ (BRL)";
@


11.25
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.24 1999/11/24 14:26:41 jra Exp $ (BRL)";
a53 1
extern struct bu_external	es_ext;
@


11.25.2.1
log
@Backporting bug fixes for release 5.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.25 1999/12/29 23:23:23 mike Exp $ (BRL)";
d681 1
a681 1
	struct rt_arb_internal	*arb;
a709 1
	BU_GETSTRUCT( arb, rt_arb_internal );
d713 2
a714 2
	internal.idb_ptr = (genptr_t)arb;
	arb->magic = RT_ARB_INTERNAL_MAGIC;
d717 1
a717 1
	VSET( arb->pt[0] , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ] );
d739 3
a741 3
	VJOIN1( arb->pt[1] , arb->pt[0] , 508.0 , norm2 );
	VJOIN1( arb->pt[3] , arb->pt[0] , -508.0 , norm3 );
	VJOIN2( arb->pt[2] , arb->pt[0] , 508.0 , norm2 , -508.0 , norm3 );
d743 1
a743 1
		VJOIN1( arb->pt[i+4] , arb->pt[i] , -50.8 , norm1 );
a749 1
		rt_db_free_internal( &internal );
@


11.24
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.23 1999/09/01 18:55:10 bparker Exp $ (BRL)";
d748 1
a748 1
	if( (dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID)) == DIR_NULL )
@


11.23
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.22 1998/11/06 22:32:39 bparker Exp $ (BRL)";
d712 1
@


11.22
log
@*- use new structures
*- cleanup
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/edarb.c,v 11.21 1997/07/01 22:09:08 bparker Exp $ (BRL)";
d475 1
a475 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d686 1
a686 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1181 1
a1181 3
    if(dbip == DBI_NULL)
      return TCL_OK;

@


11.21
log
@mods to run without a database
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.20 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d719 1
a719 1
	VSET( arb.pt[0] , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ] );
d956 1
a956 1
	dmaflag = 1;
d1364 1
a1364 1
    dmaflag = 1;
@


11.20
log
@modify calls to Tcl_Eval
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.19 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d475 3
d687 3
d1183 3
@


11.19
log
@mods so that commands check args internally
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.18 1997/04/09 20:32:06 bparker Exp bparker $ (BRL)";
d476 6
a481 1
	  Tcl_Eval(interp, "help extrude");
d687 6
a692 1
	  Tcl_Eval(interp, "help arb");
d786 6
a791 1
	  Tcl_Eval(interp, "help mirface");
d972 6
a977 1
	  Tcl_Eval(interp, "help edgedir");
d1181 6
a1186 1
      Tcl_Eval(interp, "help permute");
@


11.18
log
@fixed typos in f_permute
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.17 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d475 2
a476 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d478 1
d681 2
a682 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d684 1
d775 2
a776 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d778 1
d956 2
a957 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d959 1
d1158 1
a1158 1
	CHECK_READ_ONLY;
d1160 2
a1161 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1163 1
@


11.17
log
@Mods to support MGED's read-only mode.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.16 1997/03/12 20:45:46 jra Exp jra $ (BRL)";
d1192 1
a1192 1
		    es_type);
d1206 1
a1206 1
		    es_type, face_size);
@


11.16
log
@removed dependencies on db.h.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.15 1997/02/27 21:13:49 jra Exp jra $ (BRL)";
d677 2
d1149 2
@


11.15
log
@Minor mods to eliminate use of "union record".
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.14 1997/01/02 19:35:05 bparker Exp jra $ (BRL)";
a43 1
#include "db.h"
a416 24
/*   PLANEQN:
 *	finds equation of a plane defined by 3 points use1,use2,use3
 *	of solid record sp.  Equation is stored at "loc" of es_peqn
 *	array.
 *
 *  Returns -
 *	 0	success
 *	-1	failure
 */
int
planeqn(loc, use1, use2, use3, sp)
int loc, use1, use2, use3;
struct solidrec *sp;
{
	vect_t	a,b,c;

	/* XXX This converts data types as well! */
	VMOVE( a, &sp->s_values[use1*3] );
	VMOVE( b, &sp->s_values[use2*3] );
	VMOVE( c, &sp->s_values[use3*3] );

	return( bn_mk_plane_3pts( es_peqn[loc], a, b, c, &mged_tol ) );
}

a425 38
/*	INTERSECT:
 *	Finds intersection point of three planes.
 *		The planes are at es_planes[type][loc] and
 *		the result is stored at "pos" in solid struct sp.
 *
 *  XXX replaced by rt_arb_3face_intersect().
 *
 *  Returns -
 *	 0	success
 *	 1	failure
 */
int
intersect( type, loc, pos, sp )
int type, loc, pos;
struct solidrec *sp;
{
	struct rt_arb_internal *arb;
	vect_t	vec1;
	int	j;
	int	i1, i2, i3;

	j = type - 4;

	i1 = rt_arb_planes[j][loc];
	i2 = rt_arb_planes[j][loc+1];
	i3 = rt_arb_planes[j][loc+2];

	if( bn_mkpoint_3planes( vec1, es_peqn[i1], es_peqn[i2],
	    es_peqn[i3] ) < 0 )
		return(1);

	arb = (struct rt_arb_internal *)es_int.idb_ptr;
	RT_ARB_CK_MAGIC( arb );
	VMOVE( arb->pt[pos] , vec1 )

	return( 0 );
}

a1027 24
}
void
old_ext4to6(pt1, pt2, pt3, sp)
int pt1, pt2, pt3;
register struct solidrec *sp;
{
	struct solidrec tmp;
	register int i;

	VMOVE(&tmp.s_values[0], &sp->s_values[pt1*3]);
	VMOVE(&tmp.s_values[3], &sp->s_values[pt2*3]);
	VMOVE(&tmp.s_values[12], &sp->s_values[pt3*3]);
	VMOVE(&tmp.s_values[15], &sp->s_values[pt3*3]);

	/* extrude "distance" to get remaining points */
	VADD2(&tmp.s_values[6], &tmp.s_values[3], &es_peqn[6][0]);
	VADD2(&tmp.s_values[9], &tmp.s_values[0], &es_peqn[6][0]);
	VADD2(&tmp.s_values[18], &tmp.s_values[12], &es_peqn[6][0]);
	VMOVE(&tmp.s_values[21], &tmp.s_values[18]);

	/* copy to the original record */
	for(i=0; i<=21; i+=3) {
		VMOVE(&sp->s_values[i], &tmp.s_values[i]);
	}
@


11.14
log
@mods to use libbn and libbu
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.13 1996/12/30 22:40:47 bparker Exp bparker $ (BRL)";
a734 1
	struct bu_external	external;
a738 1
	int ngran;
a787 6
	if( rt_functab[internal.idb_type].ft_export( &external, &internal, 1.0 ) < 0 )
	{
	   Tcl_AppendResult(interp, "f_make: export failure\n", (char *)NULL);
	   return TCL_ERROR;
	}

d791 5
a795 7
	ngran = (external.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
	if( (dp = db_diradd( dbip, argv[1], -1L, ngran, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )
	    {
	    	db_free_external( &external );
	    	TCL_ALLOC_ERR_return;
	    }
d797 1
a797 1
	if (db_put_external( &external, dp, dbip ) < 0 )
d799 1
a799 1
		db_free_external( &external );
a801 1
	db_free_external( &external );
@


11.13
log
@call sedit() directly
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.12 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d55 1
a55 1
extern struct rt_external	es_ext;
d58 1
a58 1
extern struct rt_tol		mged_tol;		/* from ged.c */
d321 1
a321 1
			if( rt_mk_plane_3pts( es_peqn[newp], arb->pt[p1], arb->pt[p2],
d342 1
a342 1
			if( rt_mk_plane_3pts( es_peqn[newp], arb->pt[p1], arb->pt[p2],
d370 1
a370 1
		if(  rt_mk_plane_3pts( es_peqn[2], arb->pt[4], arb->pt[5], arb->pt[6], &mged_tol ))
d439 1
a439 1
	return( rt_mk_plane_3pts( es_peqn[loc], a, b, c, &mged_tol ) );
d478 1
a478 1
	if( rt_mkpoint_3planes( vec1, es_peqn[i1], es_peqn[i2],
d507 2
a508 2
	if( rt_isect_line3_plane( &t1, thru, dir, es_peqn[bp1], &mged_tol ) < 0 ||
	    rt_isect_line3_plane( &t2, thru, dir, es_peqn[bp2], &mged_tol ) < 0 )  {
d620 1
a620 1
	if( rt_mk_plane_3pts( es_peqn[6], larb.pt[pt[0]], larb.pt[pt[1]],
d735 1
a735 1
	struct rt_external	external;
d1433 1
a1433 1
CONST struct rt_tol	*tol;
d1485 1
a1485 1
	return rt_mkpoint_3planes( point, planes[i1], planes[i2], planes[i3] );
@


11.12
log
@include mged_solid.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.11 1996/09/23 18:29:33 bparker Exp bparker $ (BRL)";
d1065 4
d1070 1
d1072 1
@


11.11
log
@changed dm.h to mged_dm.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.10 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d50 1
a50 1
#include "./solid.h"
@


11.10
log
@rt_list ---> bu_list
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.9 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d51 1
a51 1
#include "./dm.h"
@


11.9
log
@now using libbu
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.8 1996/07/30 21:34:10 bparker Exp bparker $ (BRL)";
d42 1
@


11.8
log
@fixed bad return value in f_extrude
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.7 1996/07/15 20:35:44 bparker Exp bparker $ (BRL)";
d297 1
a297 1
rt_log("moving edge: %d%d  bound planes: %d %d\n",pt1+1,pt2+1,bp1+1,bp2+1);
d318 1
a318 1
rt_log("redo plane %d with points %d %d %d\n",newp+1,p1+1,p2+1,p3+1);
d339 1
a339 1
rt_log("REdo plane %d with points %d %d %d\n",newp+1,p1+1,p2+1,p3+1);
d356 1
a356 1
rt_log("intersect: type=%d   point = %d\n",es_type,p1+1);
d367 1
a367 1
rt_log("redo plane 2 == 5,6,7 for ARB7\n");
d404 1
a404 1
	  struct rt_vls tmp_vls;
d406 4
a409 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "cannot move edge: %d%d\n", pt1+1,pt2+1);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d550 1
a550 1
	  struct rt_vls tmp_vls;
d552 4
a555 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "ARB%d: extrusion of faces not allowed\n",es_type);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d858 1
a858 1
	  struct rt_vls tmp_vls;
d860 4
a863 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "ARB%d: mirroring of faces not allowed\n",es_type);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d1253 1
a1253 1
      struct rt_vls tmp_vls;
d1255 4
a1258 4
      rt_vls_init(&tmp_vls);
      rt_vls_printf(&tmp_vls, "Permute: es_type=%d\nThis shouldn't happen\n", es_type);
      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
      rt_vls_free(&tmp_vls);
d1275 1
a1275 1
      struct rt_vls tmp_vls;
d1277 2
a1278 2
      rt_vls_init(&tmp_vls);
      rt_vls_printf(&tmp_vls, "ERROR: tuple '%s' too short to disambiguate ARB%d face\n",
d1280 3
a1282 3
      rt_vls_printf(&tmp_vls, "Need at least %d vertices\n", min_tuple_size[es_type]);
      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
      rt_vls_free(&tmp_vls);
d1289 1
a1289 1
      struct rt_vls tmp_vls;
d1291 2
a1292 2
      rt_vls_init(&tmp_vls);
      rt_vls_printf(&tmp_vls, "ERROR: tuple '%s' length exceeds ARB%d face size of %d\n",
d1294 2
a1295 2
      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
      rt_vls_free(&tmp_vls);
d1302 1
a1302 1
      struct rt_vls tmp_vls;
d1304 4
a1307 4
      rt_vls_init(&tmp_vls);
      rt_vls_printf(&tmp_vls, "ERROR: invalid vertex %c\n", argv[1][0]);
      Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
      rt_vls_free(&tmp_vls);
d1341 1
a1341 1
    rt_log("After collection...\n");
d1349 1
a1349 1
    rt_log("...\n");
d1392 1
a1392 1
	    struct rt_vls tmp_vls;
d1394 4
a1397 4
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "%s: %d: This shouldn't happen\n", __FILE__, __LINE__);
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d1436 1
a1436 1
		  struct rt_vls tmp_vls;
d1438 4
a1441 4
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "rt_arb_calc_points: Intersection of planes fails %d\n", i);
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
@


11.7
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.6 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d720 1
a720 1
	return CMD_OK;
@


11.6
log
@still tcl-converting
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.5 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d814 1
a814 1
	  char *av[] = {"e", NULL, NULL};
d816 1
d818 1
@


11.5
log
@convert commands to Tcl
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.4 1995/11/07 22:57:16 bparker Exp bparker $ (BRL)";
d813 8
a820 2
	/* draw the "made" solid */
	return f_edit( clientData, interp, 2, argv );	/* depends on name being in argv[1] */
@


11.4
log
@unleashed a few xmged commands
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.3 1995/02/18 03:08:49 mike Exp bparker $ (BRL)";
d221 2
a222 2
		case ARB4:
			edptr = &earb4[es_menu][0];
d257 1
a257 1
			edptr = &earb8[es_menu][0];
d262 2
a263 1
			rt_log("edarb: unknown ARB type\n");
d403 9
a411 1
	rt_log("cannot move edge: %d%d\n", pt1+1,pt2+1);
d508 2
a509 2
		rt_log("edge (direction) parallel to face normal\n");
		return( 1 );
d524 3
a526 1
f_extrude( argc, argv )
d537 3
d541 1
a541 1
		return CMD_BAD;
d545 2
a546 2
		rt_log("Extrude: solid type must be ARB\n");
		return CMD_BAD;
d550 7
a556 2
		rt_log("ARB%d: extrusion of faces not allowed\n",es_type);
		return CMD_BAD;
d613 2
a614 2
			rt_log("bad face: %d\n",face);
			return CMD_BAD;
d622 2
a623 2
		rt_log("face: %d is not a plane\n",face);
		return CMD_BAD;
d635 3
a637 2
			rt_log("ARB6: extrusion of face %d not allowed\n",face);
			return CMD_BAD;
d696 3
a698 2
		rt_log("ARB6: extrusion of face %d not allowed\n",face);
		return CMD_BAD;
d701 2
a702 2
		rt_log("bad face: %d\n", face );
		return CMD_BAD;
d708 3
a710 2
		rt_log( "Cannot calculate new plane equations for faces\n" );
		return CMD_BAD;
d718 1
a718 1
	dmaflag = 1;
d726 3
a728 1
f_arbdef( argc, argv )
d741 3
d745 2
a746 2
		aexists( argv[1] );
		return CMD_BAD;
d791 2
a792 2
		rt_log( "f_make: export failure\n" );
		return CMD_BAD;
d795 1
a795 1
	/* no interuprts */
d803 1
a803 2
	    	ALLOC_ERR;
		return CMD_BAD;
d809 1
a809 2
		WRITE_ERR;
		return CMD_BAD;
d814 1
a814 1
	return f_edit( 2, argv );	/* depends on name being in argv[1] */
d820 3
a822 1
f_mirface( argc, argv )
d834 3
d838 1
a838 1
		return CMD_BAD;
d842 2
a843 2
		rt_log("Mirface: solid type must be ARB\n");
		return CMD_BAD;
d850 8
a857 2
		rt_log("ARB%d: mirroring of faces not allowed\n",es_type);
		return CMD_BAD;
d861 2
a862 2
		rt_log("ERROR: %d bad face\n",face);
		return CMD_BAD;
d873 2
a874 2
		rt_log("axis must be x, y or z\n");
		return CMD_BAD;
d916 2
a917 2
			rt_log("bad face: %d\n",face);
			return CMD_BAD;
d926 3
a928 2
			rt_log("ARB6: mirroring of face %d not allowed\n",face);
			return CMD_BAD;
d975 3
a977 3
		rt_log("ARB6: mirroring of face %d not allowed\n",face);
		return CMD_BAD;

d979 2
a980 2
		rt_log("bad face: %d\n", face );
		return CMD_BAD;
d985 1
a985 1
		return CMD_BAD;
d994 1
a994 1
	return CMD_OK;
d1003 3
a1005 1
f_edgedir( argc, argv )
d1013 3
d1017 1
a1017 1
		return CMD_BAD;
d1020 2
a1021 2
		rt_log("Not moving an ARB edge\n");
		return CMD_BAD;
d1026 2
a1027 2
		rt_log("Edgedir: solid type must be an ARB\n");
		return CMD_BAD;
d1049 2
a1050 2
		rt_log("BAD slope\n");
		return CMD_BAD;
d1057 1
a1057 2
	return CMD_OK;

d1130 3
a1132 2
f_permute( argc, argv )

d1231 3
d1235 1
a1235 1
	return CMD_BAD;
d1239 2
a1240 2
	rt_log("Permute: solid type must be an ARB\n");
	return CMD_BAD;
d1245 7
a1251 3
	rt_log("Permute: es_type=%d\nThis shouldn't happen\n",
		      es_type);
	return CMD_BAD;
d1254 2
a1255 2
	arb = (struct rt_arb_internal *)es_int.idb_ptr;
	RT_ARB_CK_MAGIC( arb );
d1257 2
a1258 2
	/* make a local copy of the solid */
	bcopy( (char *)arb , (char *)&larb , sizeof( struct rt_arb_internal ) );
d1267 10
a1276 7
	char *s;
	
	s = "ERROR: tuple '%s' too short to disambiguate ARB%d face\n";
	rt_log(s, argv[1], es_type);
	rt_log("Need at least %d vertices\n",
	min_tuple_size[es_type]);
	return CMD_BAD;
d1281 9
a1289 5
	char *s;
	
	s = "ERROR: tuple '%s' length exceeds ARB%d face size of %d\n";
	rt_log(s, argv[1], es_type, face_size);
	return CMD_BAD;
d1294 7
a1300 2
	rt_log("ERROR: invalid vertex %c\n", argv[1][0]);
	return CMD_BAD;
d1310 3
a1312 2
	    rt_log("ERROR: invalid vertex tuple: '%s'\n", argv[1]);
	    return CMD_BAD;
d1383 9
a1391 3
	    rt_log("%s: %d: This shouldn't happen\n",
		__FILE__, __LINE__);
	    return CMD_BAD;
d1394 2
a1395 2
	/* copy back to original arb */
	bcopy( (char *)&larb , (char *)arb , sizeof( struct rt_arb_internal ) );
d1401 1
a1401 1
    return CMD_OK;
d1428 7
a1434 2
			rt_log("rt_arb_calc_points: Intersection of planes fails %d\n", i);
			return -1;			/* FAIL */
@


11.3
log
@Eliminated local setting of "rt_tol" structures.
Everything now uses the global mged_tol.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 11.2 95/01/17 13:04:37 bparker Exp Locker: mike $ (BRL)";
d117 1
a117 1
#ifdef XMGED
d137 1
a137 1
#ifdef XMGED
d157 1
a157 1
#ifdef XMGED
d175 1
a175 1
#ifdef XMGED
d192 1
a192 1
#ifdef XMGED
@


11.2
log
@merging xmged sources
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/edarb.c,v 11.2 95/01/17 11:42:54 bparker Exp $ (BRL)";
a422 1
	struct rt_tol	tol;
a423 7
	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d429 1
a429 1
	return( rt_mk_plane_3pts( es_peqn[loc], a, b, c, &tol ) );
a495 1
	struct rt_tol	tol;
d497 2
a498 9
	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	if( rt_isect_line3_plane( &t1, thru, dir, es_peqn[bp1], &tol ) < 0 ||
	    rt_isect_line3_plane( &t2, thru, dir, es_peqn[bp2], &tol ) < 0 )  {
d1350 1
a1350 1
struct rt_tol	*tol;
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.18 94/12/30 01:07:52 mike Exp $ (BRL)";
d117 3
d121 1
d137 3
d141 1
d157 3
d161 1
d175 3
d179 1
d192 3
d196 1
@


10.18
log
@DEC Alpha
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.17 94/12/16 19:41:48 gdurf Exp Locker: mike $ (BRL)";
@


10.17
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.16 1994/12/16 19:36:36 gdurf Exp gdurf $ (BRL)";
d544 1
a544 1
	bcopy( es_int.idb_ptr , &larb , sizeof( struct rt_arb_internal ) );
d688 1
a688 1
	bcopy( &larb , es_int.idb_ptr , sizeof( struct rt_arb_internal ) );
d841 1
a841 1
	bcopy( arb , &larb , sizeof( struct rt_arb_internal ) );
d947 1
a947 1
	bcopy( &larb , arb , sizeof( struct rt_arb_internal ) );
d1205 1
a1205 1
	bcopy( arb , &larb , sizeof( struct rt_arb_internal ) );
d1323 1
a1323 1
	bcopy( &larb , arb , sizeof( struct rt_arb_internal ) );
@


10.16
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.15 1994/11/10 12:06:06 jra Exp gdurf $ (BRL)";
d276 1
a276 1
printf("moving edge: %d%d  bound planes: %d %d\n",pt1+1,pt2+1,bp1+1,bp2+1);
d297 1
a297 1
printf("redo plane %d with points %d %d %d\n",newp+1,p1+1,p2+1,p3+1);
d318 1
a318 1
printf("REdo plane %d with points %d %d %d\n",newp+1,p1+1,p2+1,p3+1);
d335 1
a335 1
printf("intersect: type=%d   point = %d\n",es_type,p1+1);
d346 1
a346 1
printf("redo plane 2 == 5,6,7 for ARB7\n");
@


10.15
log
@Irix 6.0.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/edarb.c,v 10.14 1994/09/02 15:53:51 jra Exp jra $ (BRL)";
d242 1
a242 1
			(void)printf("edarb: unknown ARB type\n");
d382 1
a382 1
	(void)printf("cannot move edge: %d%d\n", pt1+1,pt2+1);
d495 1
a495 1
		(void)printf("edge (direction) parallel to face normal\n");
d527 1
a527 1
		(void)printf("Extrude: solid type must be ARB\n");
d532 1
a532 1
		(void)printf("ARB%d: extrusion of faces not allowed\n",es_type);
d590 1
a590 1
			(void)printf("bad face: %d\n",face);
d599 1
a599 1
		(void)printf("face: %d is not a plane\n",face);
d612 1
a612 1
			(void)printf("ARB6: extrusion of face %d not allowed\n",face);
d672 1
a672 1
		(void)printf("ARB6: extrusion of face %d not allowed\n",face);
d676 1
a676 1
		(void)printf("bad face: %d\n", face );
d683 1
a683 1
		(void)printf( "Cannot calculate new plane equations for faces\n" );
d808 1
a808 1
		(void)printf("Mirface: solid type must be ARB\n");
d816 1
a816 1
		(void)printf("ARB%d: mirroring of faces not allowed\n",es_type);
d821 1
a821 1
		(void)printf("ERROR: %d bad face\n",face);
d833 1
a833 1
		(void)printf("axis must be x, y or z\n");
d876 1
a876 1
			(void)printf("bad face: %d\n",face);
d886 1
a886 1
			(void)printf("ARB6: mirroring of face %d not allowed\n",face);
d934 1
a934 1
		(void)printf("ARB6: mirroring of face %d not allowed\n",face);
d938 1
a938 1
		(void)printf("bad face: %d\n", face );
d974 1
a974 1
		(void)printf("Not moving an ARB edge\n");
d980 1
a980 1
		(void)printf("Edgedir: solid type must be an ARB\n");
d1003 1
a1003 1
		(void)printf("BAD slope\n");
d1190 1
a1190 1
	(void) printf("Permute: solid type must be an ARB\n");
d1196 1
a1196 1
	(void) printf("Permute: es_type=%d\nThis shouldn't happen\n",
d1217 2
a1218 2
	(void) printf(s, argv[1], es_type);
	(void) printf("Need at least %d vertices\n",
d1228 1
a1228 1
	(void) printf(s, argv[1], es_type, face_size);
d1234 1
a1234 1
	(void) printf("ERROR: invalid vertex %c\n", argv[1][0]);
d1245 1
a1245 1
	    (void) printf("ERROR: invalid vertex tuple: '%s'\n", argv[1]);
d1267 1
a1267 1
    printf("After collection...\n");
d1275 1
a1275 1
    printf("...\n");
d1317 1
a1317 1
	    (void) printf("%s: %d: This shouldn't happen\n",
@


10.14
log
@Removed all blocks of code that didn't use the "new way".
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.13 94/08/31 17:08:25 jra Exp Locker: jra $ (BRL)";
a191 1
	register dbfloat_t *op;
a519 1
	static struct solidrec lsolid;	/* local copy of solid */
a707 1
	union record record;
a799 1
	static struct solidrec lsolid;	/* local copy of solid */
d1069 1
a1069 1
/* Format: permute tuple	*/
@


10.13
log
@Checkpoint (conversion to using import/export).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.12 94/08/31 15:50:08 jra Exp Locker: jra $ (BRL)";
a53 1
static int new_way = 1;
a246 10
	if( !new_way )
	{
		/* convert to point notation (in place ----- DANGEROUS) */
		for(i=3; i<=21; i+=3)
		{
			op = &es_rec.s.s_values[i];
			VADD2( op, op, &es_rec.s.s_values[0] );
		}
	}

d251 1
a251 4
		if( new_way )
			VMOVE( arb->pt[es_menu] , pos_model )
		else
			VMOVE(&es_rec.s.s_values[es_menu*3], &pos_model[0])
d260 8
a267 11
		if( new_way )
		{
			if( newedge ) {
				/* edge direction comes from edgedir() in pos_model */
				VMOVE( edge_dir, pos_model );
				VMOVE(pos_model, arb->pt[pt1]);
				newedge = 0;
			} else {
				/* must calculate edge direction */
				VSUB2(edge_dir, arb->pt[pt2], arb->pt[pt1]);
			}
a268 12
		else
		{
			if( newedge ) {
				/* edge direction comes from edgedir() in pos_model */
				VMOVE( edge_dir, pos_model );
				VMOVE(pos_model, &es_rec.s.s_values[pt1*3]);
				newedge = 0;
			} else {
				/* must calculate edge direction */
				VSUB2(edge_dir, &es_rec.s.s_values[3*pt2], &es_rec.s.s_values[3*pt1]);
			}
		}
d286 5
a290 26
	if( new_way )
	{
		if( newp == 9 )	/* special flag --> redo all the planes */
			if( rt_arb_calc_planes( es_peqn , arb , es_type , &mged_tol ) )
				goto err;
	}
	else
	{
		if( newp == 9 ) {
			/* special flag --> redo all the planes */
			iptr = &arb_faces[es_type-4][0];
			for(i=0; i<6; i++) {
				p1 = *iptr++;
				p2 = *iptr++;
				p3 = *iptr++;
				iptr++;
/*
printf("REDO plane %d with points %d %d %d\n",i+1,p1+1,p2+1,p3+1);
*/
				if( planeqn(i, p1, p2, p3, &es_rec.s) )
					goto err;
				if( *iptr == -1 )
					break;		/* finished */
			}
		}
	}
d300 4
a303 11
			if( new_way )
			{
				if( rt_mk_plane_3pts( es_peqn[newp], arb->pt[p1], arb->pt[p2],
							arb->pt[p3], &mged_tol ) )
					goto err;
			}
			else
			{
				if( planeqn(newp, p1, p2, p3, &es_rec.s) )
					goto err;
			}
d321 3
a323 9
			if( new_way )
			{
				if( rt_mk_plane_3pts( es_peqn[newp], arb->pt[p1], arb->pt[p2],
						arb->pt[p3], &mged_tol ))
					goto err;
			}
			else
				if( planeqn(newp, p1, p2, p3, &es_rec.s) )
					goto err;
d338 2
a339 6
		if( new_way )
			if( rt_arb_3face_intersect( arb->pt[p1], es_peqn, es_type, p1*3 ))
				goto err;
		else
			if( intersect( es_type, p1*3, p1, &es_rec.s ) )
				goto err;
d349 2
a350 6
		if( new_way )
			if(  rt_mk_plane_3pts( es_peqn[2], arb->pt[4], arb->pt[5], arb->pt[6], &mged_tol ))
				goto err;
		else
			if( planeqn(2, 4, 5, 6, &es_rec.s) )
				goto err;
d359 2
a360 5
			if( new_way )
				VMOVE( arb->pt[7] , arb->pt[4] )
			else
				VMOVE(&es_rec.s.s_values[21], &es_rec.s.s_values[12])
		break;
d363 3
a365 11
			if( new_way )
			{
				VMOVE( arb->pt[5] , arb->pt[4] );
				VMOVE( arb->pt[7] , arb->pt[6] );
			}
			else
			{
				VMOVE(&es_rec.s.s_values[15], &es_rec.s.s_values[12]);
				VMOVE(&es_rec.s.s_values[21], &es_rec.s.s_values[18]);
			}
		break;
d368 3
a370 11
			if( new_way )
			{
				for( i=5 ; i<8 ; i++ )
					VMOVE( arb->pt[i] , arb->pt[4] );
			}
			else
			{
				for(i=15; i<=21; i+=3)
					VMOVE(&es_rec.s.s_values[i], &es_rec.s.s_values[12])
			}
		break;
d373 3
a375 12
			if( new_way )
			{
				VMOVE( arb->pt[3] , arb->pt[0] );
				for( i=5 ; i<8 ; i++ )
					VMOVE( arb->pt[i] , arb->pt[4] );
			}
			else
			{
				VMOVE(&es_rec.s.s_values[9], &es_rec.s.s_values[0]);
				for(i=15; i<=21; i+=3)
					VMOVE(&es_rec.s.s_values[i], &es_rec.s.s_values[12])
			}
a378 9
	/* back to vector notation */
	if( !new_way )
	{
		for(i=3; i<=21; i+=3)
		{
			op = &es_rec.s.s_values[i];
			VSUB2( op, op, &es_rec.s.s_values[0] );
		}
	}
a385 9
	/* back to vector notation */
	if( !new_way )
	{
		for(i=3; i<=21; i+=3)
		{
			op = &es_rec.s.s_values[i];
			VSUB2(op, op, &es_rec.s.s_values[0]);
		}
	}
d446 1
d461 3
a463 3
	if( new_way )
	{
		struct rt_arb_internal *arb;
a464 7
		arb = (struct rt_arb_internal *)es_int.idb_ptr;
		RT_ARB_CK_MAGIC( arb );
		VMOVE( arb->pt[pos] , vec1 )
	}
	else
		VMOVE( &sp->s_values[pos*3], vec1 )	/* XXX type conversion too */

d483 1
d500 2
a501 3
	if( new_way )
	{
		struct rt_arb_internal *arb;
d503 2
a504 2
		arb = (struct rt_arb_internal *)es_int.idb_ptr;
		RT_ARB_CK_MAGIC( arb );
a505 14
		VJOIN1( arb->pt[end1] , thru, t1, dir );
		VJOIN1( arb->pt[end2] , thru, t2, dir );
	}
	else
	{
		dbfloat_t *op;

		op = &es_rec.s.s_values[end1*3];
		VJOIN1( op, thru, t1, dir );

		op = &es_rec.s.s_values[end2*3];
		VJOIN1( op, thru, t2, dir );
	}

d527 1
a527 1
	if( new_way )
d529 2
a530 5
		if( es_int.idb_type != ID_ARB8 )
		{
			(void)printf("Extrude: solid type must be ARB\n");
			return CMD_BAD;
		}
a531 7
	else
	{
		if( es_rec.s.s_type != GENARB8 )  {
			(void)printf("Extrude: solid type must be ARB\n");
			return CMD_BAD;
		}
	}
d546 1
a546 12
	if( new_way )
	{
		bcopy( es_int.idb_ptr , &larb , sizeof( struct rt_arb_internal ) );
	}
	else
	{
		/* convert to point notation in temporary buffer */
		VMOVE( &lsolid.s_values[0], &es_rec.s.s_values[0] );
		for( i = 3; i <= 21; i += 3 )  {  
			VADD2(&lsolid.s_values[i], &es_rec.s.s_values[i], &lsolid.s_values[0]);
		}
	}
d598 2
a599 1
	if( new_way )
d601 2
a602 6
		if( rt_mk_plane_3pts( es_peqn[6], larb.pt[pt[0]], larb.pt[pt[1]],
					larb.pt[pt[2]], &mged_tol ) )
		{
			(void)printf("face: %d is not a plane\n",face);
			return CMD_BAD;
		}
d604 1
a604 7
	else
	{
		if( planeqn(6, pt[0], pt[1], pt[2], &lsolid) ) {
			(void)printf("face: %d is not a plane\n",face);
			return CMD_BAD;
		}
	}
d622 1
a622 4
			if( new_way )
				VADD2( larb.pt[j] , larb.pt[i] , es_peqn[6] )
			else
				VADD2( &lsolid.s_values[j*3],&lsolid.s_values[i*3],&es_peqn[6][0])
d630 2
a631 10
		if( new_way )
		{
			ext4to6(pt[0], pt[1], pt[2], &larb);
			es_type = ARB6;
		}
		else
		{
			old_ext4to6(pt[0], pt[1], pt[2], &lsolid);
			es_rec.s.s_cgtype = ARB6;
		}
d638 1
a638 4
			if( new_way )
				VADD2( larb.pt[i] , larb.pt[j] , es_peqn[6] )
			else
				VADD2( &lsolid.s_values[i*3],&lsolid.s_values[j*3],&es_peqn[6][0] )
d644 4
a647 14
		if( new_way )
		{
			VADD2( larb.pt[3] , larb.pt[0] , es_peqn[6] );
			VADD2( larb.pt[2] , larb.pt[1] , es_peqn[6] );
			VADD2( larb.pt[7] , larb.pt[4] , es_peqn[6] );
			VADD2( larb.pt[6] , larb.pt[5] , es_peqn[6] );
		}
		else
		{
			VADD2( &lsolid.s_values[9],&lsolid.s_values[0],	&es_peqn[6][0] );
			VADD2( &lsolid.s_values[6],&lsolid.s_values[3],	&es_peqn[6][0] );
			VADD2( &lsolid.s_values[21],&lsolid.s_values[12],&es_peqn[6][0] );
			VADD2( &lsolid.s_values[18],&lsolid.s_values[15],&es_peqn[6][0] );
		}
d652 4
a655 14
		if( new_way )
		{
			VADD2( larb.pt[0] , larb.pt[3] , es_peqn[6] );
			VADD2( larb.pt[1] , larb.pt[2] , es_peqn[6] );
			VADD2( larb.pt[5] , larb.pt[6] , es_peqn[6] );
			VADD2( larb.pt[4] , larb.pt[7] , es_peqn[6] );
		}
		else
		{
			VADD2( &lsolid.s_values[0],&lsolid.s_values[9],	&es_peqn[6][0] );
			VADD2( &lsolid.s_values[3],&lsolid.s_values[6],	&es_peqn[6][0] );
			VADD2( &lsolid.s_values[15],&lsolid.s_values[18],&es_peqn[6][0] );
			VADD2( &lsolid.s_values[12],&lsolid.s_values[21],&es_peqn[6][0] );
		}
d659 4
a662 14
		if( new_way )
		{
			VADD2( larb.pt[0] , larb.pt[1] , es_peqn[6] );
			VADD2( larb.pt[3] , larb.pt[2] , es_peqn[6] );
			VADD2( larb.pt[4] , larb.pt[5] , es_peqn[6] );
			VADD2( larb.pt[7] , larb.pt[6] , es_peqn[6] );
		}
		else
		{
			VADD2( &lsolid.s_values[0],&lsolid.s_values[3],&es_peqn[6][0] );
			VADD2( &lsolid.s_values[9],&lsolid.s_values[6],&es_peqn[6][0] );
			VADD2( &lsolid.s_values[12],&lsolid.s_values[15],&es_peqn[6][0] );
			VADD2( &lsolid.s_values[21],&lsolid.s_values[18],&es_peqn[6][0] );
		}
d666 4
a669 14
		if( new_way )
		{
			VADD2( larb.pt[1] , larb.pt[0] , es_peqn[6] );
			VADD2( larb.pt[5] , larb.pt[4] , es_peqn[6] );
			VADD2( larb.pt[2] , larb.pt[3] , es_peqn[6] );
			VADD2( larb.pt[6] , larb.pt[7] , es_peqn[6] );
		}
		else
		{
			VADD2( &lsolid.s_values[3],&lsolid.s_values[0],&es_peqn[6][0] );
			VADD2( &lsolid.s_values[15],&lsolid.s_values[12],&es_peqn[6][0] );
			VADD2( &lsolid.s_values[6],&lsolid.s_values[9],	&es_peqn[6][0] );
			VADD2( &lsolid.s_values[18],&lsolid.s_values[21],&es_peqn[6][0] );
		}
d682 2
a683 1
	if( new_way )
d685 3
a687 6
		/* redo the plane equations */
		if( rt_arb_calc_planes( es_peqn , &larb , es_type , &mged_tol ) )
		{
			(void)printf( "Cannot calculate new plane equations for faces\n" );
			return CMD_BAD;
		}
d689 2
a690 2
		/* copy local copy back to original */
		bcopy( &larb , es_int.idb_ptr , sizeof( struct rt_arb_internal ) );
a691 24
	}
	else
	{
		/* redo the plane equations */
		for(i=0; i<6; i++) {
			if(arb_faces[es_type-4][i*4] == -1)
				break;
			pt[0] = arb_faces[es_type-4][i*4];
			pt[1] = arb_faces[es_type-4][i*4+1];
			pt[2] = arb_faces[es_type-4][i*4+2];
			if(planeqn(i, pt[0], pt[1], pt[2], &lsolid)) {
				(void)printf("No equation for face %d%d%d%d\n",
					pt[0]+1,pt[1]+1,pt[2]+1,arb_faces[es_type-4][i*4+3]);
				return CMD_BAD;
			}
		}

		/* Convert back to point&vector notation */
		VMOVE( &es_rec.s.s_values[0], &lsolid.s_values[0] );
		for( i = 3; i <= 21; i += 3 )  {  
			VSUB2( &es_rec.s.s_values[i], &lsolid.s_values[i], &lsolid.s_values[0]);
		}
	}

d713 2
a714 1
	vect_t	norm;
d727 4
a730 4
	if( new_way )
	{
		vect_t norm1,norm2,norm3;
		int ngran;
d732 2
a733 4
		RT_INIT_DB_INTERNAL( &internal );
		internal.idb_type = ID_ARB8;
		internal.idb_ptr = (genptr_t)&arb;
		arb.magic = RT_ARB_INTERNAL_MAGIC;
d735 4
a738 2
		/* put vertex of new solid at center of screen */
		VSET( arb.pt[0] , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ] );
d740 10
a749 4
		/* calculate normal vector defined by rot,fb */
		norm1[0] = cos(fb) * cos(rota);
		norm1[1] = cos(fb) * sin(rota);
		norm1[2] = sin(fb);
d751 9
a759 10
		/* find two perpendicular vectors which are perpendicular to norm */
		j = 0;
		for( i = 0; i < 3; i++ )  {
			if( fabs(norm1[i]) < fabs(norm1[j]) )
				j = i;
		}
		VSET( norm2 , 0.0 , 0.0 , 0.0 );
		norm2[j] = 1.0;
		VCROSS( norm3 , norm2 , norm1 );
		VCROSS( norm2 , norm3 , norm1 );
d761 5
a765 9
		/* create new rpp 20x20x2 */
		/* the 20x20 faces are in rot,fb plane */
		VUNITIZE( norm2 );
		VUNITIZE( norm3 );
		VJOIN1( arb.pt[1] , arb.pt[0] , 508.0 , norm2 );
		VJOIN1( arb.pt[3] , arb.pt[0] , -508.0 , norm3 );
		VJOIN2( arb.pt[2] , arb.pt[0] , 508.0 , norm2 , -508.0 , norm3 );
		for( i=0 ; i<4 ; i++ )
			VJOIN1( arb.pt[i+4] , arb.pt[i] , -50.8 , norm1 );
d767 2
a768 5
		if( rt_functab[internal.idb_type].ft_export( &external, &internal, 1.0 ) < 0 )
		{
			rt_log( "f_make: export failure\n" );
			return CMD_BAD;
		}
d770 8
a777 2
		/* no interuprts */
		(void)signal( SIGINT, SIG_IGN );
d779 2
a780 15
		ngran = (external.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
		if( (dp = db_diradd( dbip, argv[1], -1L, ngran, DIR_SOLID)) == DIR_NULL ||
		    db_alloc( dbip, dp, 1 ) < 0 )
		    {
		    	db_free_external( &external );
		    	ALLOC_ERR;
			return CMD_BAD;
		    }

		if (db_put_external( &external, dp, dbip ) < 0 )
		{
			db_free_external( &external );
			WRITE_ERR;
			return CMD_BAD;
		}
d782 2
d785 1
a785 11
	else
	{
		if( (dp = db_diradd( dbip,  argv[1], -1, 1, DIR_SOLID )) == DIR_NULL ||
		    db_alloc( dbip, dp, 1 ) < 0 )  {
			ALLOC_ERR;
			return CMD_BAD;
		}
		NAMEMOVE( argv[1], record.s.s_name );
		record.s.s_id = ID_SOLID;
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB8;
a786 53
		/* put vertex of new solid at center of screen */
		record.s.s_values[0] = -toViewcenter[MDX];
		record.s.s_values[1] = -toViewcenter[MDY];
		record.s.s_values[2] = -toViewcenter[MDZ];

		/* calculate normal vector (length = 2) defined by rot,fb */
		norm[0] = cos(fb) * cos(rota) * -50.8;
		norm[1] = cos(fb) * sin(rota) * -50.8;
		norm[2] = sin(fb) * -50.8;

		for( i = 3; i < 24; i++ )
			record.s.s_values[i] = 0.0;

		/* find two perpendicular vectors which are perpendicular to norm */
		j = 0;
		for( i = 0; i < 3; i++ )  {
			if( fabs(norm[i]) < fabs(norm[j]) )
				j = i;
		}
		record.s.s_values[j+3] = 1.0;
		VCROSS( &record.s.s_values[9], &record.s.s_values[3], norm );
		VCROSS( &record.s.s_values[3], &record.s.s_values[9], norm );

		/* create new rpp 20x20x2 */
		/* the 20x20 faces are in rot,fb plane */
		VUNITIZE( &record.s.s_values[3] );
		VUNITIZE( &record.s.s_values[9] );
		VSCALE(&record.s.s_values[3], &record.s.s_values[3], 508.0);
		VSCALE(&record.s.s_values[9], &record.s.s_values[9], 508.0);
		VADD2( &record.s.s_values[6],
			&record.s.s_values[3],
			&record.s.s_values[9] );
		VMOVE( &record.s.s_values[12], norm );
		for( i = 3; i < 12; i += 3 )  {
			j = i + 12;
			VADD2( &record.s.s_values[j], &record.s.s_values[i], norm );
		}

		/* update dbip->dbi_fd and draw new arb8 */
		if( db_put( dbip, dp, &record, 0, 1 ) < 0 ) {
			WRITE_ERR;
			return CMD_BAD;
		}

		if( no_memory )  {
			(void)printf(
				"ARB8 (%s) created but no memory left to draw it\n",
				argv[1] );
			return CMD_BAD;
		}
	}


d810 1
a810 1
	if( new_way )
d812 2
a813 8
		if( es_int.idb_type != ID_ARB8 )
		{
			(void)printf("Mirface: solid type must be ARB\n");
			return CMD_BAD;
		}

		arb = (struct rt_arb_internal *)es_int.idb_ptr;
		RT_ARB_CK_MAGIC( arb );
a814 7
	else
	{
		if( es_rec.s.s_type != GENARB8 )  {
			(void)printf("Mirface: solid type must be ARB\n");
			return CMD_BAD;
		}
	}
d816 3
d844 2
a845 13
	if( new_way )
	{
		/* make local copy of arb */
		bcopy( arb , &larb , sizeof( struct rt_arb_internal ) );
	}
	else
	{
		/* convert to point notation in temporary buffer */
		VMOVE( &lsolid.s_values[0], &es_rec.s.s_values[0] );
		for( i = 3; i <= 21; i += 3 )  {  
			VADD2(&lsolid.s_values[i], &es_rec.s.s_values[i], &lsolid.s_values[0]);
		}
	}
d895 1
a895 4
			if( new_way )
				VELMUL( larb.pt[j] , larb.pt[i] , work )
			else
				VELMUL( &lsolid.s_values[j*3],&lsolid.s_values[i*3],work)
d902 1
a902 4
			if( new_way )
				VELMUL( larb.pt[i] , larb.pt[j] , work )
			else
				VELMUL( &lsolid.s_values[i*3],&lsolid.s_values[j*3],work )
d908 4
a911 14
		if( new_way )
		{
			VELMUL( larb.pt[3] , larb.pt[0] , work );
			VELMUL( larb.pt[2] , larb.pt[1] , work );
			VELMUL( larb.pt[7] , larb.pt[4] , work );
			VELMUL( larb.pt[6] , larb.pt[5] , work );
		}
		else
		{
			VELMUL( &lsolid.s_values[9],&lsolid.s_values[0],work );
			VELMUL( &lsolid.s_values[6],&lsolid.s_values[3],work );
			VELMUL( &lsolid.s_values[21],&lsolid.s_values[12],work );
			VELMUL( &lsolid.s_values[18],&lsolid.s_values[15],work );
		}
d916 4
a919 14
		if( new_way )
		{
			VELMUL( larb.pt[0] , larb.pt[3] , work );
			VELMUL( larb.pt[1] , larb.pt[2] , work );
			VELMUL( larb.pt[5] , larb.pt[6] , work );
			VELMUL( larb.pt[4] , larb.pt[7] , work );
		}
		else
		{
			VELMUL( &lsolid.s_values[0],&lsolid.s_values[9],work );
			VELMUL( &lsolid.s_values[3],&lsolid.s_values[6],work );
			VELMUL( &lsolid.s_values[15],&lsolid.s_values[18],work );
			VELMUL( &lsolid.s_values[12],&lsolid.s_values[21],work );
		}
d923 4
a926 14
		if( new_way )
		{
			VELMUL( larb.pt[0] , larb.pt[1] , work );
			VELMUL( larb.pt[3] , larb.pt[2] , work );
			VELMUL( larb.pt[4] , larb.pt[5] , work );
			VELMUL( larb.pt[7] , larb.pt[6] , work );
		}
		else
		{
			VELMUL( &lsolid.s_values[0],&lsolid.s_values[3],work );
			VELMUL( &lsolid.s_values[9],&lsolid.s_values[6],work );
			VELMUL( &lsolid.s_values[12],&lsolid.s_values[15],work );
			VELMUL( &lsolid.s_values[21],&lsolid.s_values[18],work );
		}
d930 4
a933 14
		if( new_way )
		{
			VELMUL( larb.pt[1] , larb.pt[0] , work );
			VELMUL( larb.pt[5] , larb.pt[4] , work );
			VELMUL( larb.pt[2] , larb.pt[3] , work );
			VELMUL( larb.pt[6] , larb.pt[7] , work );
		}
		else
		{
			VELMUL( &lsolid.s_values[3],&lsolid.s_values[0],work );
			VELMUL( &lsolid.s_values[15],&lsolid.s_values[12],work );
			VELMUL( &lsolid.s_values[6],&lsolid.s_values[9],work );
			VELMUL( &lsolid.s_values[18],&lsolid.s_values[21],work );
		}
d947 2
a948 4
	if( new_way )
	{
		if( rt_arb_calc_planes( es_peqn , &larb , es_type , &mged_tol ) )
			return CMD_BAD;
d950 2
a951 17
		/* copy to original */
		bcopy( &larb , arb , sizeof( struct rt_arb_internal ) );
	}
	else
	{
		for(i=0; i<6; i++) {
			if(arb_faces[es_type-4][i*4] == -1)
				break;
			pt[0] = arb_faces[es_type-4][i*4];
			pt[1] = arb_faces[es_type-4][i*4+1];
			pt[2] = arb_faces[es_type-4][i*4+2];
			if(planeqn(i, pt[0], pt[1], pt[2], &lsolid)) {
				(void)printf("No equation for face %d%d%d%d\n",
					pt[0]+1,pt[1]+1,pt[2]+1,arb_faces[es_type-4][i*4+3]);
				return CMD_BAD;
			}
		}
a952 7
		/* Convert back to point&vector notation */
		VMOVE( &es_rec.s.s_values[0], &lsolid.s_values[0] );
		for( i = 3; i <= 21; i += 3 )  {  
			VSUB2( &es_rec.s.s_values[i], &lsolid.s_values[i], &lsolid.s_values[0]);
		}
	}

d982 1
a982 1
	if( new_way )
d984 2
a985 12
		if( es_int.idb_type != ID_ARB8 )
		{
			(void)printf("Edgedir: solid type must be an ARB\n");
			return CMD_BAD;
		}
	}
	else
	{
		if( es_rec.s.s_type != GENARB8 ) {
			(void)printf("Edgedir: solid type must be an ARB\n");
			return CMD_BAD;
		}
@


10.12
log
@Checkpoint (converting to use of es_int rather than es_rec).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.11 94/08/25 00:56:13 mike Exp Locker: jra $ (BRL)";
d1520 3
a1522 2
    struct solidrec	lsolid;		/* local copy of solid */
    struct solidrec	tsolid;		/* temporary copy of solid */
d1608 2
a1609 1
    if (es_rec.s.s_type != GENARB8)
d1614 1
d1622 6
a1672 8
    /* Convert to point notation in temporary buffer */
    VMOVE(&lsolid.s_values[0], &es_rec.s.s_values[0]);
    for(i = 3; i <= 21; i += 3)
    {  
	VADD2(&lsolid.s_values[i],
		&es_rec.s.s_values[i], &lsolid.s_values[0]);
    }

a1678 1
	int	a, b;
d1684 1
a1684 3
	a = 3 * i;
	b = 3 * ARB_VERT_LOC(es_type, k);
	VMOVE(&tsolid.s_values[a], &lsolid.s_values[b]);
d1689 1
a1689 1
    for (i = 0; i <= 21; i += 3)
d1693 2
a1694 2
	sprintf(string, "vertex %d", i / 3 + 1);
	VPRINT(string, &tsolid.s_values[i]);
d1714 1
a1714 1
    for (i = 0; i <= 21; i += 3)
d1716 1
a1716 1
	VMOVE(&lsolid.s_values[i], &tsolid.s_values[i]);
d1721 1
a1721 1
	    VMOVE(&lsolid.s_values[9], &lsolid.s_values[0]);
d1724 3
a1726 3
	    VMOVE(&lsolid.s_values[15], &lsolid.s_values[12]);
	    VMOVE(&lsolid.s_values[18], &lsolid.s_values[12]);
	    VMOVE(&lsolid.s_values[21], &lsolid.s_values[12]);
d1729 2
a1730 2
	    VMOVE(&lsolid.s_values[15], &lsolid.s_values[12]);
	    VMOVE(&lsolid.s_values[21], &lsolid.s_values[18]);
d1733 1
a1733 1
	    VMOVE(&lsolid.s_values[21], &lsolid.s_values[12]);
d1743 2
a1744 7
    /* Convert back to point&vector notation */
    VMOVE(&es_rec.s.s_values[0], &lsolid.s_values[0]);
    for (i = 3; i <= 21; i += 3)
    {  
	VSUB2(&es_rec.s.s_values[i],
		&lsolid.s_values[i], &lsolid.s_values[0]);
    }
@


10.11
log
@It compiles now.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.10 94/08/25 00:39:51 mike Exp Locker: mike $ (BRL)";
d33 1
d52 1
a52 1
void	ext4to6();
d54 6
d195 1
d197 3
d248 8
a255 4
	/* convert to point notation (in place ----- DANGEROUS) */
	for(i=3; i<=21; i+=3) {
		op = &es_rec.s.s_values[i];
		VADD2( op, op, &es_rec.s.s_values[0] );
d262 4
a265 1
		VMOVE(&es_rec.s.s_values[es_menu*3], &pos_model[0]);
d274 11
a284 8
		if( newedge ) {
			/* edge direction comes from edgedir() in pos_model */
			VMOVE( edge_dir, pos_model );
			VMOVE(pos_model, &es_rec.s.s_values[pt1*3]);
			newedge = 0;
		} else {
			/* must calculate edge direction */
			VSUB2(edge_dir, &es_rec.s.s_values[3*pt2], &es_rec.s.s_values[3*pt1]);
d286 12
d315 16
a330 8
	if( newp == 9 ) {
		/* special flag --> redo all the planes */
		iptr = &arb_faces[es_type-4][0];
		for(i=0; i<6; i++) {
			p1 = *iptr++;
			p2 = *iptr++;
			p3 = *iptr++;
			iptr++;
d334 5
a338 4
			if( planeqn(i, p1, p2, p3, &es_rec.s) )
				goto err;
			if( *iptr == -1 )
				break;		/* finished */
d350 11
a360 2
			if( planeqn(newp, p1, p2, p3, &es_rec.s) )
				goto err;
d378 9
a386 2
			if( planeqn(newp, p1, p2, p3, &es_rec.s) )
				goto err;
d401 6
a406 2
		if( intersect( es_type, p1*3, p1, &es_rec.s ) )
			goto err;
d416 6
a421 2
		if( planeqn(2, 4, 5, 6, &es_rec.s) )
			goto err;
d430 4
a433 1
			VMOVE(&es_rec.s.s_values[21], &es_rec.s.s_values[12]);
d437 10
a446 2
			VMOVE(&es_rec.s.s_values[15], &es_rec.s.s_values[12]);
			VMOVE(&es_rec.s.s_values[21], &es_rec.s.s_values[18]);
d450 4
a453 2
			for(i=15; i<=21; i+=3) {
				VMOVE(&es_rec.s.s_values[i], &es_rec.s.s_values[12]);
d455 5
d463 5
a467 3
			VMOVE(&es_rec.s.s_values[9], &es_rec.s.s_values[0]);
			for(i=15; i<=21; i+=3) {
				VMOVE(&es_rec.s.s_values[i], &es_rec.s.s_values[12]);
d469 6
d479 7
a485 3
	for(i=3; i<=21; i+=3) {
		op = &es_rec.s.s_values[i];
		VSUB2( op, op, &es_rec.s.s_values[0] );
d495 7
a501 3
	for(i=3; i<=21; i+=3) {
		op = &es_rec.s.s_values[i];
		VSUB2(op, op, &es_rec.s.s_values[0]);
d576 12
a587 1
	VMOVE( &sp->s_values[pos*3], vec1 );	/* XXX type conversion too */
a605 1
	dbfloat_t *op;
d622 3
a624 2
	op = &es_rec.s.s_values[end1*3];
	VJOIN1( op, thru, t1, dir );
d626 2
a627 2
	op = &es_rec.s.s_values[end2*3];
	VJOIN1( op, thru, t2, dir );
d629 14
d659 1
d664 7
a670 3
	if( es_rec.s.s_type != GENARB8 )  {
		(void)printf("Extrude: solid type must be ARB\n");
		return CMD_BAD;
d672 7
d693 3
a695 4
	/* convert to point notation in temporary buffer */
	VMOVE( &lsolid.s_values[0], &es_rec.s.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VADD2(&lsolid.s_values[i], &es_rec.s.s_values[i], &lsolid.s_values[0]);
d697 8
d756 8
a763 3
	if( planeqn(6, pt[0], pt[1], pt[2], &lsolid) ) {
		(void)printf("face: %d is not a plane\n",face);
		return CMD_BAD;
d765 7
d789 4
a792 3
			VADD2( &lsolid.s_values[j*3],
				&lsolid.s_values[i*3],
				&es_peqn[6][0]);
d800 10
a809 2
		ext4to6(pt[0], pt[1], pt[2], &lsolid);
		es_rec.s.s_cgtype = ARB6;
d816 4
a819 3
			VADD2( &lsolid.s_values[i*3],
				&lsolid.s_values[j*3],
				&es_peqn[6][0] );
d825 14
a838 12
		VADD2( &lsolid.s_values[9],
			&lsolid.s_values[0],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[6],
			&lsolid.s_values[3],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[21],
			&lsolid.s_values[12],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[18],
			&lsolid.s_values[15],
			&es_peqn[6][0] );
d843 14
a856 12
		VADD2( &lsolid.s_values[0],
			&lsolid.s_values[9],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[3],
			&lsolid.s_values[6],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[15],
			&lsolid.s_values[18],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[12],
			&lsolid.s_values[21],
			&es_peqn[6][0] );
d860 14
a873 12
		VADD2( &lsolid.s_values[0],
			&lsolid.s_values[3],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[9],
			&lsolid.s_values[6],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[12],
			&lsolid.s_values[15],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[21],
			&lsolid.s_values[18],
			&es_peqn[6][0] );
d877 14
a890 12
		VADD2( &lsolid.s_values[3],
			&lsolid.s_values[0],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[15],
			&lsolid.s_values[12],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[6],
			&lsolid.s_values[9],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[18],
			&lsolid.s_values[21],
			&es_peqn[6][0] );
d903 6
a908 10
	/* redo the plane equations */
	for(i=0; i<6; i++) {
		if(arb_faces[es_type-4][i*4] == -1)
			break;
		pt[0] = arb_faces[es_type-4][i*4];
		pt[1] = arb_faces[es_type-4][i*4+1];
		pt[2] = arb_faces[es_type-4][i*4+2];
		if(planeqn(i, pt[0], pt[1], pt[2], &lsolid)) {
			(void)printf("No equation for face %d%d%d%d\n",
				pt[0]+1,pt[1]+1,pt[2]+1,arb_faces[es_type-4][i*4+3]);
d911 4
d916 15
d932 5
a936 4
	/* Convert back to point&vector notation */
	VMOVE( &es_rec.s.s_values[0], &lsolid.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VSUB2( &es_rec.s.s_values[i], &lsolid.s_values[i], &lsolid.s_values[0]);
d954 3
d973 4
a976 9
	if( (dp = db_diradd( dbip,  argv[1], -1, 1, DIR_SOLID )) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )  {
		ALLOC_ERR;
		return CMD_BAD;
	}
	NAMEMOVE( argv[1], record.s.s_name );
	record.s.s_id = ID_SOLID;
	record.s.s_type = GENARB8;
	record.s.s_cgtype = ARB8;
d978 4
a981 4
	/* put vertex of new solid at center of screen */
	record.s.s_values[0] = -toViewcenter[MDX];
	record.s.s_values[1] = -toViewcenter[MDY];
	record.s.s_values[2] = -toViewcenter[MDZ];
d983 2
a984 4
	/* calculate normal vector (length = 2) defined by rot,fb */
	norm[0] = cos(fb) * cos(rota) * -50.8;
	norm[1] = cos(fb) * sin(rota) * -50.8;
	norm[2] = sin(fb) * -50.8;
d986 4
a989 2
	for( i = 3; i < 24; i++ )
		record.s.s_values[i] = 0.0;
d991 10
a1000 9
	/* find two perpendicular vectors which are perpendicular to norm */
	j = 0;
	for( i = 0; i < 3; i++ )  {
		if( fabs(norm[i]) < fabs(norm[j]) )
			j = i;
	}
	record.s.s_values[j+3] = 1.0;
	VCROSS( &record.s.s_values[9], &record.s.s_values[3], norm );
	VCROSS( &record.s.s_values[3], &record.s.s_values[9], norm );
d1002 9
a1010 14
	/* create new rpp 20x20x2 */
	/* the 20x20 faces are in rot,fb plane */
	VUNITIZE( &record.s.s_values[3] );
	VUNITIZE( &record.s.s_values[9] );
	VSCALE(&record.s.s_values[3], &record.s.s_values[3], 508.0);
	VSCALE(&record.s.s_values[9], &record.s.s_values[9], 508.0);
	VADD2( &record.s.s_values[6],
		&record.s.s_values[3],
		&record.s.s_values[9] );
	VMOVE( &record.s.s_values[12], norm );
	for( i = 3; i < 12; i += 3 )  {
		j = i + 12;
		VADD2( &record.s.s_values[j], &record.s.s_values[i], norm );
	}
d1012 25
a1036 4
	/* update dbip->dbi_fd and draw new arb8 */
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 ) {
		WRITE_ERR;
		return CMD_BAD;
d1038 11
d1050 50
a1099 5
	if( no_memory )  {
		(void)printf(
			"ARB8 (%s) created but no memory left to draw it\n",
			argv[1] );
		return CMD_BAD;
d1102 1
d1120 2
d1126 10
a1135 3
	if( es_rec.s.s_type != GENARB8 )  {
		(void)printf("Mirface: solid type must be ARB\n");
		return CMD_BAD;
d1137 7
d1170 4
a1173 4
	/* convert to point notation in temporary buffer */
	VMOVE( &lsolid.s_values[0], &es_rec.s.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VADD2(&lsolid.s_values[i], &es_rec.s.s_values[i], &lsolid.s_values[0]);
d1175 8
d1232 4
a1235 3
			VELMUL( &lsolid.s_values[j*3],
				&lsolid.s_values[i*3],
				work);
d1242 4
a1245 3
			VELMUL( &lsolid.s_values[i*3],
				&lsolid.s_values[j*3],
				work );
d1251 14
a1264 12
		VELMUL( &lsolid.s_values[9],
			&lsolid.s_values[0],
			work );
		VELMUL( &lsolid.s_values[6],
			&lsolid.s_values[3],
			work );
		VELMUL( &lsolid.s_values[21],
			&lsolid.s_values[12],
			work );
		VELMUL( &lsolid.s_values[18],
			&lsolid.s_values[15],
			work );
d1269 14
a1282 12
		VELMUL( &lsolid.s_values[0],
			&lsolid.s_values[9],
			work );
		VELMUL( &lsolid.s_values[3],
			&lsolid.s_values[6],
			work );
		VELMUL( &lsolid.s_values[15],
			&lsolid.s_values[18],
			work );
		VELMUL( &lsolid.s_values[12],
			&lsolid.s_values[21],
			work );
d1286 14
a1299 12
		VELMUL( &lsolid.s_values[0],
			&lsolid.s_values[3],
			work );
		VELMUL( &lsolid.s_values[9],
			&lsolid.s_values[6],
			work );
		VELMUL( &lsolid.s_values[12],
			&lsolid.s_values[15],
			work );
		VELMUL( &lsolid.s_values[21],
			&lsolid.s_values[18],
			work );
d1303 14
a1316 12
		VELMUL( &lsolid.s_values[3],
			&lsolid.s_values[0],
			work );
		VELMUL( &lsolid.s_values[15],
			&lsolid.s_values[12],
			work );
		VELMUL( &lsolid.s_values[6],
			&lsolid.s_values[9],
			work );
		VELMUL( &lsolid.s_values[18],
			&lsolid.s_values[21],
			work );
d1330 3
a1332 9
	for(i=0; i<6; i++) {
		if(arb_faces[es_type-4][i*4] == -1)
			break;
		pt[0] = arb_faces[es_type-4][i*4];
		pt[1] = arb_faces[es_type-4][i*4+1];
		pt[2] = arb_faces[es_type-4][i*4+2];
		if(planeqn(i, pt[0], pt[1], pt[2], &lsolid)) {
			(void)printf("No equation for face %d%d%d%d\n",
				pt[0]+1,pt[1]+1,pt[2]+1,arb_faces[es_type-4][i*4+3]);
d1334 17
a1351 1
	}
d1353 5
a1357 4
	/* Convert back to point&vector notation */
	VMOVE( &es_rec.s.s_values[0], &lsolid.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VSUB2( &es_rec.s.s_values[i], &lsolid.s_values[i], &lsolid.s_values[0]);
d1389 7
a1395 3
	if( es_rec.s.s_type != GENARB8 ) {
		(void)printf("Edgedir: solid type must be an ARB\n");
		return CMD_BAD;
d1397 7
d1438 1
a1438 1
 *			to produce ARB6 using solid record "sp"
d1441 25
a1465 1
ext4to6(pt1, pt2, pt3, sp)
@


10.10
log
@Pulled in rt_arb_calc_points()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.10 94/08/25 00:35:02 mike Exp Locker: mike $ (BRL)";
d43 3
a46 1
#include "raytrace.h"
a47 1
#include "externs.h"
@


10.9
log
@Factored ifdefs
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.8 1994/06/01 15:10:44 gdurf Exp gdurf $ (BRL)";
a478 28
/*
 *			R T _ A R B _ 3 F A C E _ I N T E R S E C T
 *
 *	Finds the intersection point of three faces of an ARB.
 *
 *  Returns -
 *	  0	success
 *	 -1	failure
 */
int
rt_arb_3face_intersect( point, planes, type, loc )
point_t			point;
plane_t			planes[6];
int			type;		/* 4..8 */
int			loc;
{
	int	j;
	int	i1, i2, i3;

	j = type - 4;

	i1 = rt_arb_planes[j][loc];
	i2 = rt_arb_planes[j][loc+1];
	i3 = rt_arb_planes[j][loc+2];

	return rt_mkpoint_3planes( point, planes[i1], planes[i2], planes[i3] );
}

d1415 64
@


10.8
log
@Converted f_ functions to use new command return codes.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.7 1994/01/06 12:32:13 pjt Exp gdurf $ (BRL)";
d30 2
d34 3
a36 1
#ifdef BSD
a37 2
#else
#include <string.h>
@


10.7
log
@Finished extending f_permute to handle all ARBs,
but there's a bug remaining for the ARB4 case.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.6 94/01/05 16:55:26 pjt Exp Locker: pjt $ (BRL)";
d548 1
a548 1
void
d561 1
a561 1
		return;
d565 1
a565 1
		return;
d570 1
a570 1
		return;
d632 1
a632 1
			return;
d639 1
a639 1
		return;
d651 1
a651 1
			return;
d747 1
a747 1
		return;
d751 1
a751 1
		return;
d764 1
a764 1
			return;
d777 2
d783 1
a783 1
void
d796 1
a796 1
		return;
d807 2
a808 1
	    	ALLOC_ERR_return;
d854 5
a858 1
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
d863 1
a863 1
		return;
d867 1
a867 1
	f_edit( 2, argv );	/* depends on name being in argv[1] */
d872 1
a872 1
void
d885 1
a885 1
		return;
d889 1
a889 1
		return;
d894 1
a894 1
		return;
d899 1
a899 1
		return;
d911 1
a911 1
		return;
d957 1
a957 1
			return;
d967 1
a967 1
			return;
d1051 1
a1051 1
		return;
d1055 1
a1055 1
		return;
d1068 1
a1068 1
			return;
d1081 2
d1090 1
a1090 1
void
d1100 1
a1100 1
		return;
d1104 1
a1104 1
		return;
d1109 1
a1109 1
		return;
d1122 1
a1122 1
	}
d1132 1
a1132 1
		return;
d1139 1
d1188 1
a1188 1
void
d1289 1
a1289 1
	return;
d1293 1
a1293 1
	return;
d1298 2
a1299 2
	es_type);
	return;
d1315 1
a1315 1
	return;
d1324 1
a1324 1
	return;
d1330 1
a1330 1
	return;
d1341 1
a1341 1
	    return;
d1425 1
a1425 1
	    return;
d1439 2
@


10.6
log
@Partially completed attempt to extend permute command
to handle all ARBs, not just ARB8s
@
text
@d12 1
a12 1
 *	f_permute	permute ARB8 vertex labels
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.5 94/01/05 13:17:38 pjt Exp Locker: pjt $ (BRL)";
d1163 1
a1163 1
/* Format: permute jkl	*/
d1166 11
a1176 11
 *     --------------------------------------------
 *		# vertices	# vertices needed
 *	Solid	in THE face	 to disambiguate
 *	type	(face_size)	      (mts)
 *     --------------------------------------------
 *	ARB4	    3			3
 *	ARB5	    4			2
 *	ARB6	    4			2
 *	ARB7	    4			1
 *	ARB8	    4			3
 *     --------------------------------------------
a1190 3
    int 		number;		/* integer argument */
    int			min_nm;		/* smallest legal value for number */
    int			mts;
d1195 10
a1204 2
    static int		min_tuple_size[9] =
	{0, 0, 0, 0, 3, 2, 2, 1, 3};	/* # vertices needed to disambiguate */
d1207 8
a1214 4
	{"1234", "1243", "1324", "1342", "1423", "1432", 0},
	{"2134", "2143", "2314", "2341", "2413", "2431", 0},
	{"3124", "3142", "3214", "3241", "3412", "3421", 0},
	{"4123", "4132", "4213", "4231", "4312", "4321", 0}
d1218 4
a1221 4
	{"12345", "14325", 0},
	{"21435", "23415", 0},
	{"32145", "34125", 0},
	{"41235", "43215", 0},
d1226 6
a1231 6
	{"123456", "156423", 0},
	{"214356", "256314", 0},
	{"341265", "365241", 0},
	{"432165", "465132", 0},
	{"514623", "523614", 0},
	{"632541", "641532", 0}
d1235 1
a1235 1
	{"1234567", 0},
d1238 1
a1238 1
	{"4321576", 0},
d1240 2
a1241 2
	{"6237514", 0},
	{"7326541", 0}
d1262 15
d1287 2
a1288 1
	(void) printf("Permute: es_type=%d\nThis shouldn't happen\n", es_type);
a1290 2
    face_size = (es_type == 4) ? 3 : 4;
    mts = min_tuple_size[es_type];
d1296 2
a1297 2
    number = atoi(argv[1]);
    for (i = 0, min_nm = 0; i < mts; ++i)
d1299 7
a1305 2
	min_nm *= 10;
	min_nm += i + 1;
d1307 2
a1308 1
    if (number < min_nm)
d1310 4
a1313 1
	(void) printf("ERROR: bad vertex tuple: %d\n", argv[1]);
d1316 2
a1317 3

    arglen = strlen(argv[1]);
    if (arglen > face_size)
d1319 1
a1319 1
	(void) printf("ERROR: bad vertex tuple: %d\n", argv[1]);
a1321 2

    vertex = argv[1][0] - '1';
d1328 1
a1328 1
	if (p == 0)
d1330 1
a1330 1
	    (void) printf("ERROR: bad vertex tuple: %d\n", argv[1]);
a1344 8
    for (i = 0; i <= 21; i += 3)
    {
	char	string[1024];

	sprintf(string, "vertex %d", i / 3 + 1);
	VPRINT(string, &lsolid.s_values[i]);
    }

d1348 1
a1348 1
    for (i = 0; i < es_type; ++i)
d1350 2
a1351 1
	char	buf[1024];
d1353 2
d1356 4
a1359 3
	k = atoi(buf) - 1;
	printf("vertex %d going to %d\n", i + 1, k + 1);
	VMOVE(&tsolid.s_values[3 * i], &lsolid.s_values[3 * k]);
d1362 2
d1369 1
a1369 1
	VPRINT(string, &lsolid.s_values[i]);
d1371 2
d1375 2
a1376 1
     *	Reinstall the permuted vertices back into the temporary buffer
d1378 10
a1387 12
     *	------+---------------------------+----------------------------
     *	      | Array locations in which  |	   Redundant storage
     *	      | to store the vertices	  |	of some of the vertices
     *	------+---------------------------+----------------------------
     *	      | 1 2 3 4 5 6 7 8		  |
     *	      +---------------------------+
     *	ARB4  |	0 1 2 4			  |	3=0, 5=6=7=4
     *	ARB5  |	0 1 2 3 4		  |	5=6=7=4
     *	ARB6  |	0 1 2 3 4 6		  |	5=4, 7=6
     *	ARB7  |	0 1 2 3 4 5 6		  |	7=4
     *	ARB8  |	0 1 2 3 4 5 6 7		  |
     *	------+---------------------------+----------------------------
d1389 4
a1395 4
	    for (i = 0; i <= 6; i += 3)
	    {
		VMOVE(&lsolid.s_values[i], &tsolid.s_values[i]);
	    }
d1397 5
a1401 5
	    VMOVE(&lsolid.s_values[12], &tsolid.s_values[9]);
	    for (i = 15; i <= 21; i += 3)
	    {
		VMOVE(&lsolid.s_values[i], &lsolid.s_values[12]);
	    }
a1402 1
	case ARB5:
a1403 4
	    for (i = 0; i <= 12; i += 3)
	    {
		VMOVE(&lsolid.s_values[i], &tsolid.s_values[i]);
	    }
a1404 8
	    if (es_type == ARB5)
	    {
		VMOVE(&lsolid.s_values[18], &lsolid.s_values[12]);
	    }
	    else
	    {
		VMOVE(&lsolid.s_values[18], &tsolid.s_values[15]);
	    }
a1407 4
	    for (i = 0; i <= 18; i += 3)
	    {
		VMOVE(&lsolid.s_values[i], &tsolid.s_values[i]);
	    }
a1410 4
	    for (i = 0; i <= 21; i += 3)
	    {
		VMOVE(&lsolid.s_values[i], &tsolid.s_values[i]);
	    }
@


10.5
log
@Added f_permute
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.4 93/07/13 21:05:55 gdurf Exp Locker: pjt $ (BRL)";
d1162 1
a1162 1
/* Permute command - permute the vertex labels of an ARB8
d1164 14
d1189 12
a1200 7
    register int vertex, i, j, k;
    int triple;
    int	modulus;
    int	*p;
    struct solidrec lsolid;	/* local copy of solid */
    struct solidrec tsolid;	/* temporary copy of solid */
    static int perm_array[8][7] =
d1202 4
a1205 8
	{12345678, 12654378, 14325876, 14852376, 15624873, 15842673, 0},
	{21436587, 21563487, 23416785, 23761485, 26513784, 26731584, 0},
	{32147658, 32674158, 34127856, 34872156, 37624851, 37842651, 0},
	{41238567, 41583267, 43218765, 43781265, 48513762, 48731562, 0},
	{51268437, 51486237, 56218734, 56781234, 58416732, 58761432, 0},
	{62157348, 62375148, 65127843, 65872143, 67325841, 67852341, 0},
	{73268415, 73486215, 76238514, 76583214, 78436512, 78563412, 0},
	{84157326, 84375126, 85147623, 85674123, 87345621, 87654321, 0}
d1207 46
d1256 1
a1256 1
    if ((es_rec.s.s_type != GENARB8) || (es_type != ARB8))
d1258 1
a1258 1
	(void) printf("Permute: solid type must be ARB8\n");
d1261 7
d1273 2
a1274 2
    triple = atoi(argv[1]);
    if ((triple < 123) || (triple > 876))
d1276 2
a1277 2
	(void) printf("ERROR: bad vertex triple: %d\n", triple);
	return;
d1279 1
a1279 2
    vertex = triple / 100;
    for (p = perm_array[vertex - 1]; *p > 0; ++p)
d1281 2
a1282 2
	if (*p / 100000 == triple)
	    break;
d1284 3
a1286 1
    if (*p == 0)
d1288 1
a1288 1
	(void) printf("ERROR: bad vertex triple: %d\n", triple);
d1292 16
a1315 1
#if 0
a1322 1
#endif
d1327 1
a1327 2
    modulus = 100000000;
    for (j = 0; j <= 21; j += 3)
d1329 6
a1334 3
	k = ((*p % modulus) * 10) / modulus - 1;
	VMOVE(&tsolid.s_values[j], &lsolid.s_values[3 * k]);
	modulus /= 10;
d1336 9
d1347 13
d1361 1
a1361 1
    for (j = 0; j <= 21; j += 3)
d1363 46
a1408 1
	VMOVE(&lsolid.s_values[j], &tsolid.s_values[j]);
@


10.4
log
@Changed from rt_isect_ray_plane to rt_isect_line3_plane(), added tolerance
parameters
@
text
@d12 1
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.3 1992/03/23 22:30:47 mike Exp gdurf $ (BRL)";
d1160 110
@


10.3
log
@Moved ARB editing routines from chgmodel.c to edarb.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.2 92/03/21 05:32:58 mike Exp Locker: mike $ (BRL)";
d521 1
d523 9
a531 2
	if( rt_isect_ray_plane( &t1, thru, dir, es_peqn[bp1] ) < 0 ||
	    rt_isect_ray_plane( &t2, thru, dir, es_peqn[bp2] ) < 0 )  {
@


10.2
log
@Added rt_arb_3face_intersect()
@
text
@d9 3
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 10.1 91/10/12 06:43:40 mike Rel4_0 Locker: mike $ (BRL)";
d47 2
d535 616
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 9.4 91/05/18 03:30:23 mike Exp $ (BRL)";
a52 9
/* planes to define ARB vertices */
int arb_planes[5][24] = {
	{0,1,3, 0,1,2, 0,2,3, 0,1,3, 1,2,3, 1,2,3, 1,2,3, 1,2,3},	/* ARB4 */
	{0,1,4, 0,1,2, 0,2,3, 0,3,4, 1,2,4, 1,2,4, 1,2,4, 1,2,4},	/* ARB5 */
	{0,2,3, 0,1,3, 0,1,4, 0,2,4, 1,2,3, 1,2,3, 1,2,4, 1,2,4},	/* ARB6 */
	{0,2,4, 0,3,4, 0,3,5, 0,2,5, 1,4,5, 1,3,4, 1,3,5, 1,2,4},	/* ARB7 */
	{0,2,4, 0,3,4, 0,3,5, 0,2,5, 1,2,4, 1,3,4, 1,3,5, 1,2,5},	/* ARB8 */
};

d429 9
d443 2
d460 3
a462 3
	i1 = arb_planes[j][loc];
	i2 = arb_planes[j][loc+1];
	i3 = arb_planes[j][loc+2];
d469 28
@


9.4
log
@Converted to new tolerance interface
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 9.3 90/12/06 16:30:50 mike Exp $ (BRL)";
@


9.3
log
@Added extra arg to rt_mk_plane_3pts
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/edarb.c,v 9.2 89/10/10 16:29:02 mike Exp $ (BRL)";
d421 1
d423 7
d435 1
a435 1
	return( rt_mk_plane_3pts( es_peqn[loc], a, b, c, 0.000001 ) );
@


9.2
log
@Eliminated es_m[].
Converted intersect and plane equation routines to using the
more general subroutines in librt.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 9.1 89/05/19 06:03:01 mike Rel3_5 $ (BRL)";
d427 1
a427 1
	return( rt_mk_plane_3pts( es_peqn[loc], a, b, c ) );
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 8.4 89/04/06 20:39:55 mike Exp $ (BRL)";
a43 2
static int	dbcompar();

d249 2
a250 1
	}
a251 1
	if( es_edflag == EARB ) {
d257 2
a258 1
			/* edge direction comes from edgedir() */
d261 1
a261 2
		}
		else {
d263 1
a263 1
			VSUB2(es_m, &es_rec.s.s_values[3*pt2], &es_rec.s.s_values[3*pt1]);
d265 1
a265 1
		if(MAGNITUDE(es_m) == 0.0) 
d275 1
a275 1
		if( mv_edge(pos_model, bp1, bp2, pt1, pt2) )
a405 16

static int
dbcompar( x, y )
register dbfloat_t *x,*y;
{

	int i;

	for(i=0; i<3; i++) {
		if( *x++ != *y++ )
			return(0);   /* different */
	}
	return(1);  /* same */
}


d410 4
d420 1
a420 2
	vect_t	work, worc;
	fastf_t	mag;
d422 6
a427 14
	if( dbcompar(&sp->s_values[use1*3],&sp->s_values[use2*3]) )
		return(1);
	if( dbcompar(&sp->s_values[use2*3],&sp->s_values[use3*3]) )
		return(1);
	if( dbcompar(&sp->s_values[use1*3],&sp->s_values[use3*3]) )
		return(1);
	VSUB2(work,&sp->s_values[use2*3],&sp->s_values[use1*3]);
	VSUB2(worc,&sp->s_values[use3*3],&sp->s_values[use1*3]);
	VCROSS(&es_peqn[loc][0],work,worc);
	if( (mag = MAGNITUDE(&es_peqn[loc][0])) == 0.0 )  
		return(1);
	VSCALE(&es_peqn[loc][0],&es_peqn[loc][0],1.0/mag);
	es_peqn[loc][3] = VDOT(&es_peqn[loc][0],&sp->s_values[use1*3]);
	return(0);
d434 4
d444 3
a446 3
	vect_t	vec1, vec2, vec3;
	fastf_t	d;
	int i, j, i1, i2, i3;
a452 3
/*
printf("intersect planes are %d %d %d\n",i1+1,i2+1,i3+1);
*/
d454 4
a457 13
	VCROSS(vec1, &es_peqn[i2][0], &es_peqn[i3][0]);
	if( (d = VDOT(&es_peqn[i1][0], vec1)) == 0.0 ) 
		return( 1 );
	d = 1.0 / d;
	VCROSS(vec2, &es_peqn[i1][0], &es_peqn[i3][0]);
	VCROSS(vec3, &es_peqn[i1][0], &es_peqn[i2][0]);
	for(i=0; i<3; i++) {
		j = pos * 3 + i;
		sp->s_values[j] = d * ((es_peqn[i1][3] * vec1[i])
					  - (es_peqn[i2][3] * vec2[i])
					  + (es_peqn[i3][3] * vec3[i]));
	}

a460 1

d463 6
a468 1
 *	planes bp1 and bp2 through point "thru"
d471 1
a471 1
mv_edge(thru, bp1, bp2, end1, end2)
d474 1
d477 1
a477 1
	fastf_t	t;
d479 3
a481 3
	if( VDOT(&es_peqn[bp1][0], es_m) == 0 ||
	    VDOT(&es_peqn[bp2][0], es_m) == 0 ) {
		(void)printf("edge (direction) parallel to face\n");
d484 1
a484 1
	t = (es_peqn[bp1][3] - VDOT(&es_peqn[bp1][0], thru)) / VDOT(&es_peqn[bp1][0], es_m);
d486 1
a486 1
	VJOIN1( op, thru, t, es_m );
a487 1
	t = (es_peqn[bp2][3] - VDOT(&es_peqn[bp2][0], thru)) / VDOT(&es_peqn[bp2][0], es_m);
d489 1
a489 1
	VJOIN1( op, thru, t, es_m );
a492 3



@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 8.3 89/03/07 00:01:55 mike Locked $ (BRL)";
@


8.3
log
@asnii
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 8.2 88/12/06 01:19:17 mike Locked $ (BRL)";
d40 1
@


8.2
log
@objdir.h --> raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/edarb.c,v 1.2 88/10/23 13:56:26 mike Exp $ (BRL)";
a41 2

extern int	printf();
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 7.4 88/09/17 02:35:16 reschly Exp $ (BRL)";
d38 1
a40 1
#include "./objdir.h"
@


7.4
log
@added stdio include.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 7.3 88/06/11 02:24:27 reschly Locked $ (BRL)";
@


7.3
log
@Removed unused indirection
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 7.2 87/11/05 05:05:40 mike Locked $ (BRL)";
d26 1
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 7.1 87/11/03 00:00:36 mike Rel $ (BRL)";
d291 1
a291 1
			*iptr++;
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 6.1 87/07/11 08:03:48 mike Rel $ (BRL)";
d33 1
a33 1
#include "./machine.h"	/* special copy */
d44 1
a44 1
static int	compar();
d188 1
a188 1
	register float *op;
d410 2
a411 2
compar( x, y )
float *x,*y;
d434 2
a435 1
	float work[3],worc[3],mag;
d437 1
a437 1
	if( compar(&sp->s_values[use1*3],&sp->s_values[use2*3]) )
d439 1
a439 1
	if( compar(&sp->s_values[use2*3],&sp->s_values[use3*3]) )
d441 1
a441 1
	if( compar(&sp->s_values[use1*3],&sp->s_values[use3*3]) )
d463 2
a464 2
	float vec1[3], vec2[3], vec3[3];
	float d;
a489 1

d502 2
a503 2
	float *op;
	double t;
@


6.1
log
@Release 2.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 5.1 87/06/24 22:20:26 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 4.2 87/02/13 00:07:26 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 4.1 86/12/29 03:21:25 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.10 86/09/23 17:41:23 mike Exp $ (BRL)";
@


2.10
log
@Minor cleanup for cray
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.9 86/09/09 22:29:31 mike Exp $ (BRL)";
@


2.9
log
@One line change to ARB7 table
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.8 86/08/12 06:49:23 mike Exp $ (BRL)";
d27 3
d31 2
@


2.8
log
@Changed #includes for CC -I../h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.7 85/09/14 05:36:18 mike Exp $ (BRL)";
d55 1
a55 1
	{0,2,4, 0,3,4, 0,3,5, 0,2,5, 1,2,4, 1,3,4, 1,3,5, 1,2,4},	/* ARB7 */
@


2.7
log
@Lint-inspired cleanup.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.6 85/09/12 00:26:09 mike Exp $ (BRL)";
d26 2
a27 2
#include	<math.h>
#include	<string.h>
d29 7
a35 7
#include "../h/vmath.h"
#include "../h/db.h"
#include "sedit.h"
#include "ged.h"
#include "solid.h"
#include "objdir.h"
#include "dm.h"
@


2.6
log
@Minor fix from KAA
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.5 85/08/07 05:18:47 mike Exp $ (BRL)";
d41 18
d180 1
a180 2
	static double t;
	static int pt1, pt2, bp1, bp2, newp, p1, p2, p3, p4;
d281 1
a281 1
		iptr = &faces[es_type-4][0];
d286 1
a286 1
			p4 = *iptr++;
d317 1
a317 1
			iptr = &faces[es_type-4][4*newp];
d463 3
a465 3
	i1 = planes[j][loc];
	i2 = planes[j][loc+1];
	i3 = planes[j][loc+2];
@


2.5
log
@Changed to use common ../h/vmath.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.4 85/07/30 01:17:33 mike Exp $ (BRL)";
d461 1
a461 1
		es_rec.s.s_values[j] = d * ((es_peqn[i1][3] * vec1[i])
@


2.4
log
@Change to support new ARB editing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.3 85/06/06 22:33:14 mike Exp $ (BRL)";
d28 2
a29 1
#include "ged_types.h"
a31 1
#include "../h/vmath.h"
d490 1
a490 1
	VCOMP1( op, thru, t, es_m );
d494 1
a494 1
	VCOMP1( op, thru, t, es_m );
@


2.3
log
@KAA, added f_edgedir() support
@
text
@d5 4
a8 4
 *	editarb		edit ARB edge
 *	do_new_edge	internal routine for editarb()
 *	plane		attempts to find equation of plane
 *	planeqn		?
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.2 85/05/10 00:54:18 mike Exp $ (BRL)";
d39 1
a39 2
static void	findsam();
static int	compar(), special();
d44 7
a50 4
 *  An ARB edge is moved by finding the slope of the
 *  line containing the edge, moving this line to the
 *  desired location, and intersecting the new line
 *  with the 2 bounding planes to define the new edge.
a51 1
 *  If es_menu = (a*10)+b then moving edge ab.
d53 105
d162 4
d167 1
a167 5
	register float *opp;
	static double t;
	register int i;
	static int j, k;
	static int pt1, pt2;
d169 48
d223 23
a245 3
	if( newedge > 0 ) {
		newedge = 0;
		if( do_new_edge() < 0 )
d247 10
d259 52
a310 1
	/* Now we have line and planes data - move the edge */
d312 14
a325 2
	pt1 = (es_menu / 10) - 1;
	pt2 = (es_menu % 10) - 1;
d327 2
a328 3
	/* 
	 * Line containing edge must now go throug
	 * point contained in pos_model[] array
d330 6
a335 5

	if( VDOT(es_plano, es_m) == 0 ||
	    VDOT(es_plant, es_m) == 0 ) {
		(void)printf("edge (slope) parallel to face\n");
		goto err;
a336 3
	t = (es_plano[3] - VDOT(es_plano, pos_model)) / VDOT(es_plano, es_m);
	op = &es_rec.s.s_values[pt1*3];
	VCOMP1( op, pos_model, t, es_m );
d338 4
a341 3
	t = (es_plant[3] - VDOT(es_plant, pos_model)) / VDOT(es_plant, es_m);
	op = &es_rec.s.s_values[pt2*3];
	VCOMP1( op, pos_model, t, es_m );
d343 21
a363 10
	/* move along any like points */
	k = pt1;
	for(i=0; i<6; i++) {
		if(i >= 3)
			k = pt2;
		if( (j = es_same[i]) > -1 ) {
			op = &es_rec.s.s_values[j*3];
			opp = &es_rec.s.s_values[k*3];
			VMOVE(op, opp);
		}
d368 2
a369 2
		opp = &es_rec.s.s_values[i];
		VSUB2( opp, opp, &es_rec.s.s_values[0] );
d375 1
a375 1
	(void)printf("cannot move edge: %d\n", es_menu);
d380 2
a381 2
		opp = &es_rec.s.s_values[i];
		VSUB2(opp, opp, &es_rec.s.s_values[0]);
d386 4
a389 10
/*
 *  			D O _ N E W _ E D G E
 *  
 *  Internal routine for editarb(), called whenever a new
 *  edge has been selected for editing.
 *  
 *  Find the line equation, and the equations of the bounding planes.
 */
int
do_new_edge()
a390 4
	register float *op;
	register float *opp;
	static int i, j;
	static int pt1,pt2;
d392 1
a392 3
	/* find line data */
	pt1 = (es_menu / 10) - 1;
	pt2 = (es_menu % 10) - 1;
d394 3
a396 106
	for(i=0; i<6; i++)
		es_same[i] = -1;

	/* find any equal points to move along with the edge */
	findsam(0, pt1, &es_rec.s);
	findsam(3, pt2, &es_rec.s);
	pt1*=3;
	pt2*=3;

	/* find slope of line containing edge pt1, pt2 */
	op = &es_rec.s.s_values[pt2];
	opp = &es_rec.s.s_values[pt1];
	VSUB2(es_m, op, opp);
	if(MAGNITUDE(es_m) == 0.0)
		return(-1);

	/* find bounding planes and equations */
	/* put equation coefficients in plano[] and plant[] arrays */
	if( es_menu == 15 ||
	    es_menu == 26 ||
	    es_menu == 37 ||
	    es_menu == 48) {
		/*
		 * plane() returns:
		 *  -1  if successful
		 *   0  if unsuccessful
		 *  >0  if degenerate plane (special case)
		 */
		if( (j = plane(0, 1, 2, 3, &es_rec.s)) > 0 ) { 
			/* special case */
			i = 2;
			if( j == 3 )
				i = 1;
			/* try to find a substitute
			   plane for the degenerate plane */
			if((j = special(i, pt1, &es_rec.s))>0)
				return(-1);
		}
		if(j == 0)
			return(-1);

		VMOVE(&es_plano[0], &es_plant[0]);
		es_plano[3] = es_plant[3];

		if( (j = plane(4, 5, 6, 7, &es_rec.s)) > 0 ) {
			i = 2;
			if(j == 47)
				i = 1;
			if( (j = special(i, pt1, &es_rec.s)) > 0)
				return(-1);
		}
		if(j == 0)
			return(-1);
	} else if(
	    es_menu == 12 ||
	    es_menu == 56 ||
	    es_menu == 87 ||
	    es_menu == 43
	) {
		if( (j = plane(0, 3, 7, 4, &es_rec.s)) > 0 ) {
			i = 3;
			if(j == 3)
				i = 1;
			if( (j =special(i, pt1, &es_rec.s)) > 0 )
				return(-1);
		}
		if(j == 0)
			return(-1);

		VMOVE(&es_plano[0], &es_plant[0]);
		es_plano[3] = es_plant[3];

		if( (j = plane(1, 2, 6, 5, &es_rec.s)) > 0 ) {
			i = 3;
			if(j == 12)
				i = 1;
			if( (j = special(i, pt1, &es_rec.s)) > 0 ) {
				return(-1);
			}
		}
		if(j == 0)
			return(-1);
	} else {
		if( (j = plane(0, 1, 5, 4, &es_rec.s)) > 0 ) {
			i = 3;
			if(j == 1)
				i = 2;
			if( (j = special(i, pt1, &es_rec.s)) > 0)
				return(-1);
		}
		if(j == 0)
			return(-1);

		VMOVE(&es_plano[0], &es_plant[0]);
		es_plano[3] = es_plant[3];

		if( (j = plane(2, 3, 7, 6, &es_rec.s)) > 0 ) {
			i = 3;
			if(j == 23)
				i = 2;
			if( (j = special(i, pt1, &es_rec.s)) > 0 ) {
				return(-1);
			}
		}
		if(j == 0)
			return(-1);
d398 1
a398 1
	return(0);		/* OK */
d401 5
a405 9
/*
 * 			P L A N E
 * 
 * Attempts to find equation of plane abcd
 *
 *   returns  >0 if plane abcd is degenerate
 *	    -1 if equation of plane abcd is found
 *	     0 if cannot find equation of plane abcd
 *		  yet plane is NOT degenerate
d408 2
a409 1
plane( a, b, c, d, sp )
a410 1
int a,b,c,d;
d412 1
d414 13
a426 20
	/* check for special case (degenerate plane) */
	if(compar(&sp->s_values[a*3],&sp->s_values[b*3]) && 
	   compar(&sp->s_values[c*3],&sp->s_values[d*3])) 
		return((a*10 + b));
	if(compar(&sp->s_values[a*3],&sp->s_values[c*3]) && 
	   compar(&sp->s_values[b*3],&sp->s_values[d*3])) 
		return((a*10 + c));
	if(compar(&sp->s_values[a*3],&sp->s_values[d*3]) &&
	   compar(&sp->s_values[b*3],&sp->s_values[c*3])) 
		return((a*10 + d));

	/* find equation of plane abcd */
	if( planeqn(a,b,c,sp) )
		return(-1);
	if( planeqn(a,b,d,sp) )
		return(-1);
	if( planeqn(a,c,d,sp) )
		return(-1);
	if( planeqn(b,c,d,sp) )
		return(-1);
d430 4
a433 2
/*
 *  			S P E C I A L
d435 3
a437 2
static int
special( a , b, sp )
a438 1
int a,b;
d440 3
a442 2
	b /= 3;
	switch( a ) {
d444 1
a444 5
	case 1:
		if( b == 0 || b == 1 || b == 4 )
			return( plane(2,3,6,7,sp) );
		else
			return( plane(0,1,5,4,sp) );
d446 6
a451 5
	case 2:
		if( b == 1 || b == 2 || b == 5 )
			return( plane(0,4,3,7,sp) );
		else
			return( plane(1,2,6,5,sp) );
d453 12
a464 5
	case 3:
		if( b == 4 || b == 5 || b == 7 )
			return( plane(0,1,2,3,sp) );
		else
			return( plane(4,5,6,7,sp) );
d466 2
a467 5
	default:
		(void)printf("subroutine special: edge input error\n");
		return(0);
	}
	/*NOTREACHED*/
d471 8
a478 3
static int
compar( x, y )
float *x,*y;
d480 2
d483 4
a486 5
	int i;

	for(i=0; i<3; i++) {
		if( *x++ != *y++ )
			return(0);   /* different */
d488 3
a490 2
	return(1);  /* same */
}
d492 3
d496 1
a496 12
static void
findsam( flag, pt, sp )
int flag,pt;
struct solidrec *sp;
{
	int i;

	for(i=0; i<8; i++) {
		if( (compar(&sp->s_values[i*3],&sp->s_values[pt*3])) &&
								(i != pt) ) 
			es_same[flag++] = i;
	}
a499 7
int
planeqn( a, b, c, sp )
int a,b,c;
struct solidrec *sp;
{
	int i;
	float work[3],worc[3],mag;
a500 16
	if( compar(&sp->s_values[a*3],&sp->s_values[b*3]) )
		return(0);
	if( compar(&sp->s_values[b*3],&sp->s_values[c*3]) )
		return(0);
	if( compar(&sp->s_values[a*3],&sp->s_values[c*3]) )
		return(0);
	VSUB2(work,&sp->s_values[b*3],&sp->s_values[a*3]);
	VSUB2(worc,&sp->s_values[c*3],&sp->s_values[a*3]);
	VCROSS(es_plant,work,worc);
	if( (mag = MAGNITUDE(es_plant)) == 0.0 )  
		return(0);
	VSCALE(es_plant,es_plant,1.0/mag);
	i = a*3;
	es_plant[3] = VDOT(es_plant,&sp->s_values[i]);
	return(1);
}
@


2.2
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: edarb.c,v 2.1 85/03/11 23:55:56 mike Prod $ (BRL)";
d84 6
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a35 1
#include "menu.h"
@


1.3
log
@KAA made planeqn() extern instead of static.
@
text
@d5 4
a8 6
 *	redraw		redraw a single solid, given matrix and record.
 *	init_sedit	set up for a Solid Edit
 *	sedit		Apply Solid Edit transformation(s)
 *	findang		Given a normal vector, find rotation & fallback angles
 *	pr_solid	Print a description of a solid
 *	plane
d10 11
d22 3
d29 1
a29 1
#include "db.h"
d31 1
a31 1
#include "vmath.h"
d34 1
a34 1
#include "dir.h"
a42 1

d53 1
d133 1
@


1.2
log
@pre-Keith version
@
text
@d29 1
a29 1
static int	compar(), planeqn(), special();
d348 1
a348 1
static int
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
#include "3d.h"
@
