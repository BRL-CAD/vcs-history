head	11.91;
access;
symbols
	ansi-20040405-merged:11.86.2.3
	postmerge-20040405-ansi:11.89
	premerge-20040404-ansi:11.88
	postmerge-autoconf:11.88
	autoconf-freeze:11.87.6.2
	premerge-autoconf:11.88
	postmerge-20040315-windows:11.88
	premerge-20040315-windows:11.88
	windows-20040315-freeze:11.86.4.1
	autoconf-20031203:11.87
	autoconf-20031202:11.87
	autoconf-branch:11.87.0.6
	phong-branch:11.87.0.4
	photonmap-branch:11.87.0.2
	rel-6-1-DP:11.86
	windows-branch:11.86.0.4
	rel-6-0-2:11.83
	ansi-branch:11.86.0.2
	rel-6-0-1-branch:11.83.0.2
	hartley-6-0-post:11.85
	hartley-6-0-pre:11.84
	rel-6-0-1:11.83
	rel-6-0:11.83
	rel-5-4:11.73
	offsite-5-3-pre:11.75
	rel-5-3:11.73
	rel-5-2:11.73
	rel-5-1-branch:11.73.0.2
	rel-5-1:11.73
	rel-5-0:11.70
	rel-5-0-beta:11.70
	rel-4-5:11.60
	ctj-4-5-post:11.43
	ctj-4-5-pre:11.43
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.91
date	2004.05.21.17.47.49;	author morrison;	state dead;
branches;
next	11.90;

11.90
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.89;

11.89
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.88;

11.88
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.87;

11.87
date	2003.04.02.15.27.25;	author jra;	state Exp;
branches
	11.87.6.1;
next	11.86;

11.86
date	2002.08.20.17.08.25;	author jra;	state Exp;
branches
	11.86.2.1
	11.86.4.1;
next	11.85;

11.85
date	2002.08.15.20.55.38;	author hartley;	state Exp;
branches;
next	11.84;

11.84
date	2002.08.11.02.07.56;	author morrison;	state Exp;
branches;
next	11.83;

11.83
date	2002.03.04.12.33.09;	author jra;	state Exp;
branches;
next	11.82;

11.82
date	2002.02.28.21.45.25;	author jra;	state Exp;
branches;
next	11.81;

11.81
date	2001.09.07.19.48.24;	author bparker;	state Exp;
branches;
next	11.80;

11.80
date	2001.08.14.18.28.01;	author bparker;	state Exp;
branches;
next	11.79;

11.79
date	2001.07.19.15.35.38;	author bparker;	state Exp;
branches;
next	11.78;

11.78
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	11.77;

11.77
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.76;

11.76
date	2001.04.05.19.35.45;	author morrison;	state Exp;
branches;
next	11.75;

11.75
date	2000.10.24.19.05.08;	author mike;	state Exp;
branches;
next	11.74;

11.74
date	2000.08.19.03.10.49;	author mike;	state Exp;
branches;
next	11.73;

11.73
date	2000.01.21.15.24.53;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	99.12.30.20.10.34;	author jra;	state Exp;
branches;
next	11.71;

11.71
date	99.12.17.16.26.52;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	99.04.20.20.27.45;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	99.02.23.22.49.13;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	99.01.12.17.57.38;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	98.11.06.22.32.43;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	98.10.21.16.59.25;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	98.06.25.07.37.24;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	98.06.11.14.28.17;	author bparker;	state Exp;
branches;
next	11.63;

11.63
date	98.03.19.18.03.20;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	98.03.06.22.29.42;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	98.02.20.23.09.41;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	98.02.06.21.55.37;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	98.01.28.15.34.28;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	98.01.16.21.56.30;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	97.12.23.14.20.26;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	97.11.26.21.30.01;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	97.11.19.21.47.35;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	97.11.19.15.47.10;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	97.11.12.21.59.44;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	97.11.06.20.04.33;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	97.11.03.15.16.21;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	97.10.27.19.24.59;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	97.09.08.19.46.09;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	97.09.08.18.15.38;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	97.09.03.14.15.48;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	97.08.20.19.23.33;	author jra;	state Exp;
branches;
next	11.45;

11.45
date	97.07.25.20.50.19;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	97.06.24.21.29.53;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	97.05.29.14.17.15;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	97.03.06.13.58.33;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	97.02.28.21.41.55;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	97.02.04.22.09.46;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	97.01.24.21.00.54;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	97.01.08.21.54.19;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.12.30.22.42.20;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.12.17.22.43.05;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.09.23.18.20.15;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.09.03.17.21.14;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.08.29.23.37.36;	author butler;	state Exp;
branches;
next	11.25;

11.25
date	96.08.29.23.22.39;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	96.08.29.23.17.52;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	96.08.28.15.05.26;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.08.22.20.55.14;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.07.30.21.33.01;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.07.25.19.01.15;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.06.21.16.06.16;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.03.22.18.32.35;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.02.28.21.34.29;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.02.12.21.47.04;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.02.09.22.15.38;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.01.17.22.03.57;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	95.12.11.22.43.11;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	95.12.04.21.59.32;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	95.11.07.22.52.55;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	95.10.26.15.38.09;	author cjohnson;	state Exp;
branches;
next	11.6;

11.6
date	95.08.03.21.48.47;	author gdurf;	state Exp;
branches;
next	11.5;

11.5
date	95.07.25.18.48.01;	author gdurf;	state Exp;
branches;
next	11.4;

11.4
date	95.07.25.18.47.11;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	95.06.15.20.22.42;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.04;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.36;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.23.23.03.06;	author gdurf;	state Exp;
branches;
next	10.10;

10.10
date	94.12.16.19.37.20;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.08.09.18.28.57;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.06.01.17.18.01;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	93.07.15.21.22.39;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.08.24.19.51.28;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.06.25.21.06.20;	author butler;	state Exp;
branches;
next	10.4;

10.4
date	92.04.18.00.40.52;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.04.04.00.12.07;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.04.03.19.45.04;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.18;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.09.21.03.07.21;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	91.08.31.07.34.59;	author mike;	state Exp;
branches;
next	;

11.86.2.1
date	2002.09.19.18.02.04;	author morrison;	state Exp;
branches;
next	11.86.2.2;

11.86.2.2
date	2002.09.25.19.39.26;	author morrison;	state Exp;
branches;
next	11.86.2.3;

11.86.2.3
date	2004.03.17.21.22.04;	author morrison;	state Exp;
branches;
next	;

11.86.4.1
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

11.87.6.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.87.6.2;

11.87.6.2
date	2004.03.15.14.07.41;	author erikg;	state Exp;
branches;
next	;


desc
@MGED "set" command.
@


11.91
log
@moved to src/mged/
@
text
@/*
 *			S E T . C
 *  Authors -
 *	Lee A. Butler
 *      Glenn Durfee
 *	Robert G. Parker
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/set.c,v 11.90 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./sedit.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

#include "tcl.h"

extern void predictor_hook(void);		/* in ged.c */

extern void set_port(void);

extern void set_perspective(void);

static void set_dirty_flag(void);
static void nmg_eu_dist_set(void);
static void set_dlist(void);
static void establish_perspective(void);
static void toggle_perspective(void);
static void set_coords(void);
static void set_rotate_about(void);

static char *read_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);
static char *write_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);
static char *unset_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);

void set_scroll_private(void);
void set_absolute_tran(void);
void set_absolute_view_tran(void);
void set_absolute_model_tran(void);

static int perspective_table[] = { 90, 30, 45, 60 };

struct _mged_variables default_mged_variables = {
/* mv_rc */			1,
/* mv_autosize */		1,
/* mv_rateknobs */		0,
/* mv_sliders */		0,
/* mv_faceplate */		1,
/* mv_orig_gui */		1,
/* mv_linewidth */		1,
/* mv_linestyle */		's',
/* mv_hot_key */		0,
/* mv_context */		1,
/* mv_dlist */			0,
/* mv_use_air */		0,
/* mv_listen */			0,
/* mv_port */			0,
/* mv_fb */			0,
/* mv_fb_all */			1,
/* mv_fb_overlay */		0,
/* mv_mouse_behavior */		'd',
/* mv_coords */			'v',
/* mv_rotate_about */		'v',
/* mv_transform */		'v',
/* mv_predictor */		0,
/* mv_predictor_advance */	1.0,
/* mv_predictor_length */	2.0,
/* mv_perspective */		-1,
/* mv_perspective_mode */	0,
/* mv_toggle_perspective */	1,
/* mv_nmg_eu_dist */		0.05,
/* mv_eye_sep_dist */		0.0,
/* mv_union lexeme */		"u",
/* mv_intersection lexeme */	"n",
/* mv_difference lexeme */	"-"
};

#define MV_O(_m)	offsetof(struct _mged_variables, _m)
#define MV_OA(_m)	offsetofarray(struct _mged_variables, _m)
struct bu_structparse mged_vparse[] = {
	{"%d",	1, "autosize",		MV_O(mv_autosize),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "rateknobs",		MV_O(mv_rateknobs),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "sliders",		MV_O(mv_sliders),	set_scroll_private },
	{"%d",	1, "faceplate",		MV_O(mv_faceplate),	set_dirty_flag },
	{"%d",	1, "orig_gui",		MV_O(mv_orig_gui),	        set_dirty_flag },
	{"%d",	1, "linewidth",		MV_O(mv_linewidth),	set_dirty_flag },
	{"%c",	1, "linestyle",		MV_O(mv_linestyle),	set_dirty_flag },
	{"%d",  1, "hot_key",		MV_O(mv_hot_key),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "context",		MV_O(mv_context),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "dlist",		MV_O(mv_dlist),		set_dlist },
	{"%d",  1, "use_air",		MV_O(mv_use_air),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "listen",		MV_O(mv_listen),		set_port },
	{"%d",  1, "port",		MV_O(mv_port),		set_port },
	{"%d",  1, "fb",		MV_O(mv_fb),		set_dirty_flag },
	{"%d",  1, "fb_all",		MV_O(mv_fb_all),		set_dirty_flag },
	{"%d",  1, "fb_overlay",	MV_O(mv_fb_overlay),	set_dirty_flag },
	{"%c",  1, "mouse_behavior",	MV_O(mv_mouse_behavior),	BU_STRUCTPARSE_FUNC_NULL },
	{"%c",  1, "coords",            MV_O(mv_coords),	set_coords },
	{"%c",  1, "rotate_about",      MV_O(mv_rotate_about),     set_rotate_about },
	{"%c",  1, "transform",         MV_O(mv_transform),        BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "predictor",		MV_O(mv_predictor),	predictor_hook },
	{"%f",	1, "predictor_advance",	MV_O(mv_predictor_advance),predictor_hook },
	{"%f",	1, "predictor_length",	MV_O(mv_predictor_length),	predictor_hook },
	{"%f",	1, "perspective",	MV_O(mv_perspective),	set_perspective },
	{"%d",  1, "perspective_mode",  MV_O(mv_perspective_mode),establish_perspective },
	{"%d",  1, "toggle_perspective",MV_O(mv_toggle_perspective),toggle_perspective },
	{"%f",  1, "nmg_eu_dist",	MV_O(mv_nmg_eu_dist),	nmg_eu_dist_set },
	{"%f",  1, "eye_sep_dist",	MV_O(mv_eye_sep_dist),	set_dirty_flag },
	{"%s",  MAXLINE, "union_op",	MV_O(mv_union_lexeme[0]),	BU_STRUCTPARSE_FUNC_NULL },
	{"%s",  MAXLINE, "intersection_op",MV_O(mv_intersection_lexeme[0]),	BU_STRUCTPARSE_FUNC_NULL },
	{"%s",  MAXLINE, "difference_op",	MV_O(mv_difference_lexeme[0]),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0,  (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

static void
set_dirty_flag(void)
{
  struct dm_list *dmlp;

  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
    if(dmlp->dml_mged_variables == mged_variables)
      dmlp->dml_dirty = 1;
}

static void
nmg_eu_dist_set(void)
{
  extern double nmg_eue_dist;
  struct bu_vls tmp_vls;

  nmg_eue_dist = mged_variables->mv_nmg_eu_dist;

  bu_vls_init(&tmp_vls);
  bu_vls_printf(&tmp_vls, "New nmg_eue_dist = %g\n", nmg_eue_dist);
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
}

/**
 **            R E A D _ V A R
 **
 ** Callback used when an MGED variable is read with either the Tcl "set"
 ** command or the Tcl dereference operator '$'.
 **
 **/

static char *
read_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
                             /* Contains pointer to bu_struct_parse entry */
                   
                    
          
{
    struct bu_structparse *sp = (struct bu_structparse *)clientData;
    struct bu_vls str;

    /* Ask the libbu structparser for the value of the variable */

    bu_vls_init( &str );
    bu_vls_struct_item( &str, sp, (const char *)mged_variables, ' ');

    /* Next, set the Tcl variable to this value */
    (void)Tcl_SetVar(interp, sp->sp_name, bu_vls_addr(&str),
		     (flags&TCL_GLOBAL_ONLY)|TCL_LEAVE_ERR_MSG);

    bu_vls_free(&str);

    return NULL;
}

/**
 **            W R I T E _ V A R
 **
 ** Callback used when an MGED variable is set with the Tcl "set" command.
 **
 **/

static char *
write_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
{
    struct bu_structparse *sp = (struct bu_structparse *)clientData;
    struct bu_vls str;
    const char *newvalue;

    newvalue = Tcl_GetVar(interp, sp->sp_name,
			  (flags&TCL_GLOBAL_ONLY)|TCL_LEAVE_ERR_MSG);
    bu_vls_init( &str );
    bu_vls_printf( &str, "%s=\"%s\"", name1, newvalue );
    if( bu_struct_parse( &str, mged_vparse, (char *)mged_variables ) < 0) {
      Tcl_AppendResult(interp, "ERROR OCCURED WHEN SETTING ", name1,
		       " TO ", newvalue, "\n", (char *)NULL);
    }

    bu_vls_free(&str);
    return read_var(clientData, interp, name1, name2,
		    (flags&(~TCL_TRACE_WRITES))|TCL_TRACE_READS);
}

/**
 **            U N S E T _ V A R
 **
 ** Callback used when an MGED variable is unset.  This function undoes that.
 **
 **/

static char *
unset_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
{
    struct bu_structparse *sp = (struct bu_structparse *)clientData;

    if( flags & TCL_INTERP_DESTROYED )
	return NULL;

    Tcl_AppendResult(interp, "mged variables cannot be unset\n", (char *)NULL);
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_READS,
		  (Tcl_VarTraceProc *)read_var,
		  (ClientData)sp );
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_WRITES,
		  (Tcl_VarTraceProc *)write_var,
		  (ClientData)sp );
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_UNSETS,
		  (Tcl_VarTraceProc *)unset_var,
 		  (ClientData)sp );
    read_var(clientData, interp, name1, name2,
	     (flags&(~TCL_TRACE_UNSETS))|TCL_TRACE_READS);
    return NULL;
}


/**
 **           M G E D _ V A R I A B L E _ S E T U P
 **
 ** Sets the variable traces for each of the MGED variables so they can be
 ** accessed with the Tcl "set" and "$" operators.
 **
 **/

void
mged_variable_setup(Tcl_Interp *interp)
{
  register struct bu_structparse *sp;

  for( sp = &mged_vparse[0]; sp->sp_name != NULL; sp++ ) {
    read_var( (ClientData)sp, interp, sp->sp_name, (char *)NULL, 0 );
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_READS|TCL_GLOBAL_ONLY,
		  (Tcl_VarTraceProc *)read_var, (ClientData)sp );
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_WRITES|TCL_GLOBAL_ONLY,
		  (Tcl_VarTraceProc *)write_var, (ClientData)sp );
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_UNSETS|TCL_GLOBAL_ONLY,
		  (Tcl_VarTraceProc *)unset_var, (ClientData)sp );
  }
}

int
f_set(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct bu_vls vls;

  bu_vls_init(&vls);

  if(argc < 1 || 2 < argc){
    bu_vls_printf(&vls, "help vars");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  mged_vls_struct_parse_old(&vls, "mged variables", mged_vparse,
			    (char *)&mged_variables, argc, argv);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

void
set_scroll_private(void)
{
  struct dm_list *dmlp;
  struct dm_list *save_dmlp;

  save_dmlp = curr_dm_list;

  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
    if (dmlp->dml_mged_variables == save_dmlp->dml_mged_variables) {
      curr_dm_list = dmlp;

      if (mged_variables->mv_faceplate && mged_variables->mv_orig_gui) {
	if (mged_variables->mv_sliders)	/* zero slider variables */
	  mged_svbase();

	set_scroll();		/* set scroll_array for drawing the scroll bars */
	dirty = 1;
      }
    }

  curr_dm_list = save_dmlp;
}

void
set_absolute_tran(void)
{
  /* calculate absolute_tran */
  set_absolute_view_tran();

  /* calculate absolute_model_tran */
  set_absolute_model_tran();
}

void
set_absolute_view_tran(void)
{
  /* calculate absolute_tran */
  MAT4X3PNT(view_state->vs_absolute_tran, view_state->vs_vop->vo_model2view, view_state->vs_orig_pos);
  /* This is used in f_knob()  ---- needed in case absolute_tran is set from Tcl */
  VMOVE(view_state->vs_last_absolute_tran, view_state->vs_absolute_tran);
}

void
set_absolute_model_tran(void)
{
  point_t new_pos;
  point_t diff;

  /* calculate absolute_model_tran */
  MAT_DELTAS_GET_NEG(new_pos, view_state->vs_vop->vo_center);
  VSUB2(diff, view_state->vs_orig_pos, new_pos);
  VSCALE(view_state->vs_absolute_model_tran, diff, 1/view_state->vs_vop->vo_scale);
  /* This is used in f_knob()  ---- needed in case absolute_model_tran is set from Tcl */
  VMOVE(view_state->vs_last_absolute_model_tran, view_state->vs_absolute_model_tran);
}

static void
set_dlist(void)
{
  struct dm_list *dlp1;
  struct dm_list *dlp2;
  struct dm_list *save_dlp;

  /* save current display manager */
  save_dlp = curr_dm_list;

  if(mged_variables->mv_dlist){
    /* create display lists */

    /* for each display manager dlp1 that shares its' dml_mged_variables with save_dlp */
    FOR_ALL_DISPLAYS(dlp1, &head_dm_list.l) {
      if (dlp1->dml_mged_variables != save_dlp->dml_mged_variables) {
	continue;
      }

      if (dlp1->dml_dmp->dm_displaylist &&
	  dlp1->dml_dlist_state->dl_active == 0) {
	curr_dm_list = dlp1;
	createDLists(&dgop->dgo_headSolid);
	dlp1->dml_dlist_state->dl_active = 1;
	dlp1->dml_dirty = 1;
      }
    }
  }else{
    /*
     * Free display lists if not being used by another display manager
     */

    /* for each display manager dlp1 that shares its' dml_mged_variables with save_dlp */
    FOR_ALL_DISPLAYS(dlp1, &head_dm_list.l) {
      if (dlp1->dml_mged_variables != save_dlp->dml_mged_variables)
	continue;

      if (dlp1->dml_dlist_state->dl_active) {
	/* for each display manager dlp2 that is sharing display lists with dlp1 */
	FOR_ALL_DISPLAYS(dlp2, &head_dm_list.l) {
	  if (dlp2->dml_dlist_state != dlp1->dml_dlist_state) {
	    continue;
	  }

	  /* found a dlp2 that is actively using dlp1's display lists */
	  if (dlp2->dml_mged_variables->mv_dlist)
	    break;
	}

	/* these display lists are not being used, so free them */
	if (BU_LIST_IS_HEAD(dlp2, &head_dm_list.l)) {
	  dlp1->dml_dlist_state->dl_active = 0;
	  DM_FREEDLISTS(dlp1->dml_dmp,
			BU_LIST_FIRST(solid, &dgop->dgo_headSolid)->s_dlist,
			BU_LIST_LAST(solid, &dgop->dgo_headSolid)->s_dlist -
			BU_LIST_FIRST(solid, &dgop->dgo_headSolid)->s_dlist + 1);
	}
      }
    }
  }

  /* restore current display manager */
  curr_dm_list = save_dlp;
}

extern void
set_perspective(void)
{
	/* if perspective is set to something greater than 0, turn perspective mode on */
	if (mged_variables->mv_perspective > 0)
		mged_variables->mv_perspective_mode = 1;
	else
		mged_variables->mv_perspective_mode = 0;

	/* keep view object in sync */
	view_state->vs_vop->vo_perspective = mged_variables->mv_perspective;

	/* keep display manager in sync */
	dmp->dm_perspective = mged_variables->mv_perspective_mode;

	set_dirty_flag();
}

static void
establish_perspective(void)
{
	mged_variables->mv_perspective = mged_variables->mv_perspective_mode ?
		perspective_table[perspective_angle] : -1;

	/* keep view object in sync */
	view_state->vs_vop->vo_perspective = mged_variables->mv_perspective;

	/* keep display manager in sync */
	dmp->dm_perspective = mged_variables->mv_perspective_mode;

	set_dirty_flag();
}

/*
   This routine toggles the perspective_angle if the
   toggle_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (toggle_perspective - 1).
*/
static void
toggle_perspective(void)
{
  /* set perspective matrix */
  if(mged_variables->mv_toggle_perspective > 0)
    perspective_angle = mged_variables->mv_toggle_perspective <= 4 ?
      mged_variables->mv_toggle_perspective - 1: 3;
  else if (--perspective_angle < 0) /* toggle perspective matrix */
    perspective_angle = 3;

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  mged_variables->mv_toggle_perspective = 1;

  if(!mged_variables->mv_perspective_mode)
    return;

  mged_variables->mv_perspective = perspective_table[perspective_angle];

  /* keep view object in sync */
  view_state->vs_vop->vo_perspective = mged_variables->mv_perspective;

  /* keep display manager in sync */
  dmp->dm_perspective = mged_variables->mv_perspective_mode;

  set_dirty_flag();
}

static void
set_coords(void)
{
	view_state->vs_vop->vo_coord = mged_variables->mv_coords;
}

static void
set_rotate_about(void)
{
	view_state->vs_vop->vo_rotate_about = mged_variables->mv_rotate_about;
}
@


11.90
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/set.c,v 11.89 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.89
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d21 5
a25 1
#include "conf.h"
@


11.88
log
@update copyright to include span through 2003
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.87 2003/04/02 15:27:25 jra Exp $ (BRL)";
d35 1
a35 1
extern void predictor_hook();		/* in ged.c */
d37 1
a37 1
extern void set_port();
d39 18
a56 17
static void set_dirty_flag();
static void nmg_eu_dist_set();
static void set_dlist();
void set_perspective();
static void establish_perspective();
static void toggle_perspective();
static void set_coords();
static void set_rotate_about();

static char *read_var();
static char *write_var();
static char *unset_var();

void set_scroll_private();
void set_absolute_tran();
void set_absolute_view_tran();
void set_absolute_model_tran();
d133 1
a133 1
set_dirty_flag()
d143 1
a143 1
nmg_eu_dist_set()
d165 5
a169 5
read_var(clientData, interp, name1, name2, flags)
ClientData clientData;       /* Contains pointer to bu_struct_parse entry */
Tcl_Interp *interp;
char *name1, *name2;
int flags;
d196 1
a196 5
write_var(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;
char *name1, *name2;
int flags;
d224 1
a224 5
unset_var(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;
char *name1, *name2;
int flags;
d272 1
a272 5
f_set(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
d319 1
a319 1
set_absolute_tran()
d329 1
a329 1
set_absolute_view_tran()
d338 1
a338 1
set_absolute_model_tran()
d352 1
a352 1
set_dlist()
d416 2
a417 2
void
set_perspective()
d435 1
a435 1
establish_perspective()
d455 1
a455 1
toggle_perspective()
d485 1
a485 1
set_coords()
d491 1
a491 1
set_rotate_about()
@


11.87
log
@Added some casts to quiet the compiler
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1990 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.86 2002/08/20 17:08:25 jra Exp $ (BRL)";
@


11.87.6.1
log
@merge from HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.88 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.87.6.2
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.87.6.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.86
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.84 2002/08/11 02:07:56 morrison Exp $ (BRL)";
d203 1
a203 1
    char *newvalue;
d239 2
a240 1
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_READS, read_var,
d242 2
a243 1
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_WRITES, write_var,
d245 2
a246 1
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_UNSETS, unset_var,
d270 1
a270 1
		  read_var, (ClientData)sp );
d272 1
a272 1
		  write_var, (ClientData)sp );
d274 1
a274 1
		  unset_var, (ClientData)sp );
@


11.86.4.1
log
@sync to HEAD...
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/set.c,v 11.88 2004/02/02 17:39:35 morrison Exp $ (BRL)";
d203 1
a203 1
    const char *newvalue;
d239 1
a239 2
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_READS,
		  (Tcl_VarTraceProc *)read_var,
d241 1
a241 2
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_WRITES,
		  (Tcl_VarTraceProc *)write_var,
d243 1
a243 2
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_UNSETS,
		  (Tcl_VarTraceProc *)unset_var,
d267 1
a267 1
		  (Tcl_VarTraceProc *)read_var, (ClientData)sp );
d269 1
a269 1
		  (Tcl_VarTraceProc *)write_var, (ClientData)sp );
d271 1
a271 1
		  (Tcl_VarTraceProc *)unset_var, (ClientData)sp );
@


11.86.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.86 2002/08/20 17:08:25 jra Exp $ (BRL)";
d35 1
a35 1
extern void predictor_hook(void);		/* in ged.c */
d37 1
a37 1
extern void set_port(void);
d39 17
a55 17
static void set_dirty_flag(void);
static void nmg_eu_dist_set(void);
static void set_dlist(void);
static void set_perspective(void);
static void establish_perspective(void);
static void toggle_perspective(void);
static void set_coords(void);
static void set_rotate_about(void);

static char *read_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);
static char *write_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);
static char *unset_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);

void set_scroll_private(void);
void set_absolute_tran(void);
void set_absolute_view_tran(void);
void set_absolute_model_tran(void);
d132 1
a132 1
set_dirty_flag(void)
d142 1
a142 1
nmg_eu_dist_set(void)
d164 5
a168 5
read_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
                             /* Contains pointer to bu_struct_parse entry */
                   
                    
          
d195 5
a199 1
write_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
d227 5
a231 1
unset_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
d276 5
a280 1
f_set(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d327 1
a327 1
set_absolute_tran(void)
d337 1
a337 1
set_absolute_view_tran(void)
d346 1
a346 1
set_absolute_model_tran(void)
d360 1
a360 1
set_dlist(void)
d424 2
a425 2
static void
set_perspective(void)
d443 1
a443 1
establish_perspective(void)
d463 1
a463 1
toggle_perspective(void)
d493 1
a493 1
set_coords(void)
d499 1
a499 1
set_rotate_about(void)
@


11.86.2.2
log
@fixed compiler type consistency errors being reported
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.86.2.1 2002/09/19 18:02:04 morrison Exp $ (BRL)";
a38 2
extern void set_perspective(void);

d42 1
d412 1
a412 1
extern void
@


11.86.2.3
log
@sync branch with HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d200 1
a200 1
    const char *newvalue;
d232 1
a232 2
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_READS,
		  (Tcl_VarTraceProc *)read_var,
d234 1
a234 2
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_WRITES,
		  (Tcl_VarTraceProc *)write_var,
d236 1
a236 2
    Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_UNSETS,
		  (Tcl_VarTraceProc *)unset_var,
d260 1
a260 1
		  (Tcl_VarTraceProc *)read_var, (ClientData)sp );
d262 1
a262 1
		  (Tcl_VarTraceProc *)write_var, (ClientData)sp );
d264 1
a264 1
		  (Tcl_VarTraceProc *)unset_var, (ClientData)sp );
@


11.85
log
@Converted from K&R to ANSI C - RFH
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.83 2002/03/04 12:33:09 jra Exp $ (BRL)";
d35 1
a35 1
extern void predictor_hook(void);		/* in ged.c */
d37 1
a37 1
extern void set_port(void);
d39 17
a55 17
static void set_dirty_flag(void);
static void nmg_eu_dist_set(void);
static void set_dlist(void);
static void set_perspective(void);
static void establish_perspective(void);
static void toggle_perspective(void);
static void set_coords(void);
static void set_rotate_about(void);

static char *read_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);
static char *write_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);
static char *unset_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags);

void set_scroll_private(void);
void set_absolute_tran(void);
void set_absolute_view_tran(void);
void set_absolute_model_tran(void);
d132 1
a132 1
set_dirty_flag(void)
d142 1
a142 1
nmg_eu_dist_set(void)
d164 5
a168 5
read_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
                             /* Contains pointer to bu_struct_parse entry */
                   
                    
          
d195 5
a199 1
write_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
d227 5
a231 1
unset_var(ClientData clientData, Tcl_Interp *interp, char *name1, char *name2, int flags)
d276 5
a280 1
f_set(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d327 1
a327 1
set_absolute_tran(void)
d337 1
a337 1
set_absolute_view_tran(void)
d346 1
a346 1
set_absolute_model_tran(void)
d360 1
a360 1
set_dlist(void)
d424 2
a425 2
static void
set_perspective(void)
d443 1
a443 1
establish_perspective(void)
d463 1
a463 1
toggle_perspective(void)
d493 1
a493 1
set_coords(void)
d499 1
a499 1
set_rotate_about(void)
@


11.84
log
@made set_perspective non-static so that it could be used in other files (loadview command)
@
text
@d35 1
a35 1
extern void predictor_hook();		/* in ged.c */
d37 1
a37 1
extern void set_port();
d39 17
a55 17
static void set_dirty_flag();
static void nmg_eu_dist_set();
static void set_dlist();
void set_perspective();
static void establish_perspective();
static void toggle_perspective();
static void set_coords();
static void set_rotate_about();

static char *read_var();
static char *write_var();
static char *unset_var();

void set_scroll_private();
void set_absolute_tran();
void set_absolute_view_tran();
void set_absolute_model_tran();
d132 1
a132 1
set_dirty_flag()
d142 1
a142 1
nmg_eu_dist_set()
d164 5
a168 5
read_var(clientData, interp, name1, name2, flags)
ClientData clientData;       /* Contains pointer to bu_struct_parse entry */
Tcl_Interp *interp;
char *name1, *name2;
int flags;
d195 1
a195 5
write_var(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;
char *name1, *name2;
int flags;
d223 1
a223 5
unset_var(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;
char *name1, *name2;
int flags;
d268 1
a268 5
f_set(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
d315 1
a315 1
set_absolute_tran()
d325 1
a325 1
set_absolute_view_tran()
d334 1
a334 1
set_absolute_model_tran()
d348 1
a348 1
set_dlist()
d412 2
a413 2
void
set_perspective()
d431 1
a431 1
establish_perspective()
d451 1
a451 1
toggle_perspective()
d481 1
a481 1
set_coords()
d487 1
a487 1
set_rotate_about()
@


11.83
log
@toggle_perspective() was not keeping display manager up-to-date.
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.82 2002/02/28 21:45:25 jra Exp $ (BRL)";
d42 1
a42 1
static void set_perspective();
d424 1
a424 1
static void
@


11.82
log
@set_perspective() was not keeping display manager in sync
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.81 2001/09/07 19:48:24 bparker Exp $ (BRL)";
d485 3
@


11.81
log
@*- added set_rotate_about
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.80 2001/08/14 18:28:01 bparker Exp $ (BRL)";
d435 3
@


11.80
log
@*** empty log message ***
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.79 2001/07/19 15:35:38 bparker Exp $ (BRL)";
d46 1
d115 1
a115 1
	{"%c",  1, "rotate_about",      MV_O(mv_rotate_about),     BU_STRUCTPARSE_FUNC_NULL },
d490 6
@


11.79
log
@*- add set_coords procedure
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.78 2001/06/05 15:51:42 bparker Exp $ (BRL)";
d426 5
a430 4
  if(mged_variables->mv_perspective > 0)
    mged_variables->mv_perspective_mode = 1;
  else
    mged_variables->mv_perspective_mode = 0;
d432 2
a433 2
  /* keep view object in sync */
  view_state->vs_vop->vo_perspective = mged_variables->mv_perspective;
d435 1
a435 1
  set_dirty_flag();
d441 2
a442 2
  mged_variables->mv_perspective = mged_variables->mv_perspective_mode ?
    perspective_table[perspective_angle] : -1;
d444 2
a445 2
  /* keep view object in sync */
  view_state->vs_vop->vo_perspective = mged_variables->mv_perspective;
d447 2
a448 2
  /* keep display manager in sync */
  dmp->dm_perspective = mged_variables->mv_perspective_mode;
d450 1
a450 1
  set_dirty_flag();
@


11.78
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.77 2001/06/01 19:23:25 bparker Exp $ (BRL)";
d45 1
d113 1
a113 1
	{"%c",  1, "coords",            MV_O(mv_coords),           BU_STRUCTPARSE_FUNC_NULL },
d482 6
@


11.77
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.76 2001/04/05 19:35:45 morrison Exp $ (BRL)";
a337 1
#ifdef MGED_USE_VIEW_OBJ
a338 3
#else
  MAT4X3PNT(view_state->vs_absolute_tran, view_state->vs_model2view, view_state->vs_orig_pos);
#endif
a349 1
#ifdef MGED_USE_VIEW_OBJ
a352 5
#else
  MAT_DELTAS_GET_NEG(new_pos, view_state->vs_toViewcenter);
  VSUB2(diff, view_state->vs_orig_pos, new_pos);
  VSCALE(view_state->vs_absolute_model_tran, diff, 1/view_state->vs_Viewscale);
#endif
d430 3
d442 3
d476 3
@


11.76
log
@updated SIGNED to signed
updated CONST to const
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.75 2000/10/24 19:05:08 mike Exp $ (BRL)";
d338 3
d342 1
d354 5
d362 1
d389 1
a389 1
	createDLists(&HeadSolid);
d420 3
a422 2
			HeadSolid.s_dlist,
			BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist - HeadSolid.s_dlist + 1);
@


11.75
log
@
Fixed compiler lint, function declarations.
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.74 2000/08/19 03:10:49 mike Exp $ (BRL)";
d174 1
a174 1
    bu_vls_struct_item( &str, sp, (CONST char *)mged_variables, ' ');
@


11.74
log
@
const RCSid
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.73 2000/01/21 15:24:53 bparker Exp $ (BRL)";
a37 1
extern void set_scroll();
d258 1
a258 2
mged_variable_setup(interp)
Tcl_Interp *interp;    
d293 1
a293 1
			    (CONST char *)mged_variables, argc, argv);
d301 1
a301 1
set_scroll_private()
@


11.73
log
@*- mods to always have a framebuffer
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.72 1999/12/30 20:10:34 jra Exp $ (BRL)";
@


11.72
log
@Eliminated some unused variables
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.71 1999/12/17 16:26:52 bparker Exp $ (BRL)";
a37 2
extern void mged_fb_open();
extern void mged_fb_close();
a41 1
static void set_fb();
d109 1
a109 1
	{"%d",  1, "fb",		MV_O(mv_fb),		set_fb },
a470 15

  set_dirty_flag();
}

static void
set_fb()
{
  if(mged_variables->mv_fb && !fbp){
    mged_fb_open();
    if(!fbp)
      mged_variables->mv_fb = 0;
  }else if(!mged_variables->mv_fb && fbp){
    set_port();
    mged_fb_close();
  }
@


11.71
log
@*- update display manager's perspective member
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.70 1999/04/20 20:27:45 bparker Exp $ (BRL)";
a173 1
    register int i;
a364 2
  int save_dlist_id = 0;
  struct dm_list *dlp;
@


11.70
log
@*- change fb_all default to 1
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.69 1999/02/23 22:49:13 bparker Exp $ (BRL)";
d445 3
@


11.69
log
@*- change slidersflag back to sliders
*- remove rt_output and send_key
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.68 1999/01/12 17:57:38 bparker Exp $ (BRL)";
d77 1
a77 1
/* mv_fb_all */			0,
@


11.68
log
@*- code to support sharing display lists
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.67 1998/11/06 22:32:43 bparker Exp $ (BRL)";
d65 1
a65 1
/* mv_slidersflag */		0,
a67 1
/* mv_rt_output */		1,
a69 1
/* mv_send_key */		0,
d101 1
a101 1
	{"%d",	1, "slidersflag",	MV_O(mv_slidersflag),      set_scroll_private },
a103 1
	{"%d",	1, "rt_output",		MV_O(mv_rt_output),        BU_STRUCTPARSE_FUNC_NULL },
a105 1
	{"%d",  1, "send_key",		MV_O(mv_send_key),		BU_STRUCTPARSE_FUNC_NULL },
d319 1
a319 1
	if (mged_variables->mv_slidersflag)	/* zero slider variables */
@


11.67
log
@*- use new structures
*- cleanup
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.66 1998/10/21 16:59:25 bparker Exp $ (BRL)";
d74 1
a74 1
/* mv_dlist */			1,
d370 5
a374 2
  struct dm_list *dmlp;
  struct dm_list *save_dmlp;
d376 2
a377 1
  save_dmlp = curr_dm_list;
a378 1
#ifdef DO_DISPLAY_LISTS
d381 4
a384 2
    FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
      if(dmlp->dml_mged_variables != save_dmlp->dml_mged_variables)
d386 1
a386 2

      curr_dm_list = dmlp;
d388 6
a393 8
      /* if display manager supports display lists */
      if(displaylist){
	dirty = 1;
#ifdef DO_SINGLE_DISPLAY_LIST
	createDList(&HeadSolid);
#else
	createDLists(&HeadSolid); 
#endif
d397 7
a403 3
    /* free display lists */
    FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
      if(dmlp->dml_mged_variables != save_dmlp->dml_mged_variables)
d406 19
a424 12
      curr_dm_list = dmlp;

      /* if display manager supports display lists */
      if(displaylist){
	dirty = 1;
#ifdef DO_SINGLE_DISPLAY_LIST
	DM_FREEDLISTS(dmp, HeadSolid.s_dlist, 1);
#else
	DM_FREEDLISTS(dmp, HeadSolid.s_dlist,
			   BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist -
			   HeadSolid.s_dlist + 1);
#endif
a427 1
#endif
d429 2
a430 2
  /* restore */
  curr_dm_list = save_dmlp;
@


11.66
log
@*- remove color variables
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.65 1998/06/25 07:37:24 mike Exp $ (BRL)";
d40 4
a44 64

struct _mged_variables default_mged_variables = {
/* autosize */			1,
/* rateknobs */			0,
/* slidersflag */               0,
/* sgi_win_size */		0,
/* sgi_win_origin */		{ 0, 0 },
/* faceplate */			1,
/* orig_gui */                  1,
/* rt_output */			1,
/* m_axes */    	        0,
/* m_axes_size */		500,
/* m_axes_linewidth */		1,
/* m_axes_pos */		{ 0.0, 0.0, 0.0 },
/* v_axes */    	        0,
/* v_axes_size */		500,
/* v_axes_linewidth */		1,
/* v_axes_pos */                { 0, 0 },
/* e_axes */            	0,
/* e_axes_size1 */		500,
/* e_axes_size2 */		500,
/* e_axes_linewidth1 */		1,
/* e_axes_linewidth2 */		1,
/* linewidth */                 1,
/* linestyle */                 's',
/* send_key */                  0,
/* hot_key */                   0,
/* context */                   1,
/* dlist */                     1,
/* use_air */			0,
/* listen */			0,
/* port */			0,
/* fb */			0,
/* fb_all */			0,
/* fb_overlay */		0,
/* rubber_band */		0,
/* rubber_band_linewidth */	1,
/* rubber_band_linestyle */	's',
/* grid_draw */			0,
/* grid_snap */			0,
/* grid_anchor */		{ 0.0, 0.0, 0.0 },
/* grid_res_h */		1.0,
/* grid_res_v */		1.0,
/* grid_res_major_h */		5,
/* grid_res_major_v */		5,
/* mouse_behavior */            'd',
/* coords */                    'v',
/* rotate_about */              'v',
/* transform */                 'v',
/* predictor */			0,
/* predictor_advance */		1.0,
/* predictor_length */		2.0,
/* perspective */		-1,
/* perspective_mode */           0,
/* toggle_perspective */         1,
/* nmg_eu_dist */		0.05,
/* eye_sep_dist */		0.0,
/* union lexeme */		"u",
/* intersection lexeme */	"n",
/* difference lexeme */		"-"
};

static int perspective_table[] = { 90, 30, 45, 60 };

d49 6
a54 4
static void set_grid_draw();
static void set_grid_res();
void set_dirty_flag();
void set_scroll();
d59 78
a136 3
/*
 *  Cause screen to be refreshed when all cmds have been processed.
 */
a137 6
refresh_hook()
{
	dmaflag = 1;
}

void
d143 2
a144 2
    if(dmlp->_mged_variables == mged_variables)
      dmlp->_dirty = 1;
d153 1
a153 1
  nmg_eue_dist = mged_variables->nmg_eu_dist;
a160 64
#define MV_O(_m)	offsetof(struct _mged_variables, _m)
#define MV_OA(_m)	offsetofarray(struct _mged_variables, _m)
struct bu_structparse mged_vparse[] = {
	{"%d",	1, "autosize",		MV_O(autosize),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "rateknobs",		MV_O(rateknobs),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "slidersflag",	MV_O(slidersflag),      set_dirty_flag },
	{"%d",	1, "sgi_win_size",	MV_O(sgi_win_size),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	2, "sgi_win_origin",	MV_OA(sgi_win_origin),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "faceplate",		MV_O(faceplate),	set_dirty_flag },
	{"%d",	1, "orig_gui",		MV_O(orig_gui),	        set_dirty_flag },
	{"%d",	1, "rt_output",		MV_O(rt_output),        BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "m_axes",		MV_O(m_axes),		set_dirty_flag },
	{"%d",  1, "m_axes_size",	MV_O(m_axes_size),	set_dirty_flag },
	{"%d",  1, "m_axes_linewidth",	MV_O(m_axes_linewidth),	set_dirty_flag },
	{"%f",	3, "m_axes_pos",	MV_OA(m_axes_pos),	set_dirty_flag },
	{"%d",  1, "v_axes",		MV_O(v_axes),		set_dirty_flag },
	{"%d",  1, "v_axes_size",	MV_O(v_axes_size),	set_dirty_flag },
	{"%d",  1, "v_axes_linewidth",	MV_O(v_axes_linewidth),	set_dirty_flag },
	{"%d",  2, "v_axes_pos",        MV_OA(v_axes_pos),	set_dirty_flag },
	{"%d",  1, "e_axes",		MV_O(e_axes),		set_dirty_flag },
	{"%d",  1, "e_axes_size1",	MV_O(e_axes_size1),	set_dirty_flag },
	{"%d",  1, "e_axes_size2",	MV_O(e_axes_size2),	set_dirty_flag },
	{"%d",  1, "e_axes_linewidth1",	MV_O(e_axes_linewidth1),set_dirty_flag },
	{"%d",  1, "e_axes_linewidth2",	MV_O(e_axes_linewidth2),set_dirty_flag },
	{"%d",	1, "linewidth",		MV_O(linewidth),	set_dirty_flag },
	{"%c",	1, "linestyle",		MV_O(linestyle),	set_dirty_flag },
	{"%d",  1, "send_key",		MV_O(send_key),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "hot_key",		MV_O(hot_key),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "context",		MV_O(context),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "dlist",		MV_O(dlist),		set_dlist },
	{"%d",  1, "use_air",		MV_O(use_air),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "listen",		MV_O(listen),		set_port },
	{"%d",  1, "port",		MV_O(port),		set_port },
	{"%d",  1, "fb",		MV_O(fb),		set_fb },
	{"%d",  1, "fb_all",		MV_O(fb_all),		set_dirty_flag },
	{"%d",  1, "fb_overlay",	MV_O(fb_overlay),	set_dirty_flag },
	{"%d",  1, "rubber_band",	MV_O(rubber_band),	set_dirty_flag },
	{"%d",  1, "rubber_band_linewidth",	MV_O(rubber_band_linewidth),	set_dirty_flag },
	{"%c",  1, "rubber_band_linestyle",	MV_O(rubber_band_linestyle),	set_dirty_flag },
	{"%d",  1, "grid_draw",		MV_O(grid_draw),	set_grid_draw },
	{"%d",  1, "grid_snap",		MV_O(grid_snap),	set_dirty_flag },
	{"%f",	3, "grid_anchor",	MV_OA(grid_anchor),	set_dirty_flag },
	{"%f",	1, "grid_res_h",	MV_O(grid_res_h),	set_grid_res },
	{"%f",	1, "grid_res_v",	MV_O(grid_res_v),	set_grid_res },
	{"%d",  1, "grid_res_major_h",	MV_O(grid_res_major_h),	set_grid_res },
	{"%d",  1, "grid_res_major_v",	MV_O(grid_res_major_v),	set_grid_res },
	{"%c",  1, "mouse_behavior",	MV_O(mouse_behavior),	BU_STRUCTPARSE_FUNC_NULL },
	{"%c",  1, "coords",            MV_O(coords),           BU_STRUCTPARSE_FUNC_NULL },
	{"%c",  1, "rotate_about",      MV_O(rotate_about),     BU_STRUCTPARSE_FUNC_NULL },
	{"%c",  1, "transform",         MV_O(transform),        BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "predictor",		MV_O(predictor),	predictor_hook },
	{"%f",	1, "predictor_advance",	MV_O(predictor_advance),predictor_hook },
	{"%f",	1, "predictor_length",	MV_O(predictor_length),	predictor_hook },
	{"%f",	1, "perspective",	MV_O(perspective),	set_perspective },
	{"%d",  1, "perspective_mode",  MV_O(perspective_mode),establish_perspective },
	{"%d",  1, "toggle_perspective",MV_O(toggle_perspective),toggle_perspective },
	{"%f",  1, "nmg_eu_dist",	MV_O(nmg_eu_dist),	nmg_eu_dist_set },
	{"%f",  1, "eye_sep_dist",	MV_O(eye_sep_dist),	set_dirty_flag },
	{"%s",  MAXLINE, "union_op",	MV_O(union_lexeme[0]),	BU_STRUCTPARSE_FUNC_NULL },
	{"%s",  MAXLINE, "intersection_op",MV_O(intersection_lexeme[0]),	BU_STRUCTPARSE_FUNC_NULL },
	{"%s",  MAXLINE, "difference_op",	MV_O(difference_lexeme[0]),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0,  (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

d169 1
a169 1
char *
d201 1
a201 1
char *
d233 1
a233 1
char *
d292 2
a294 1
    bu_vls_init(&vls);
d302 3
a304 10
  bu_vls_init(&vls);
  if (argc == 1) {
    start_catching_output(&vls);
    bu_struct_print("mged variables", mged_vparse, (CONST char *)mged_variables);
    stop_catching_output(&vls);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  } else if (argc == 2) {
    bu_vls_strcpy(&vls, argv[1]);
    bu_struct_parse(&vls, mged_vparse, (char *)mged_variables);
  }
d311 1
a311 1
set_scroll()
d313 4
a316 3
  struct bu_vls vls;
  struct bu_vls save_result1_vls;
  struct bu_vls save_result2_vls;
d318 3
a320 2
  if(!strcmp("nu", bu_vls_addr(&pathName)))
    return;
d322 3
a324 4
  bu_vls_init(&vls);
  bu_vls_init(&save_result1_vls);
  bu_vls_init(&save_result2_vls);
  bu_vls_strcpy(&save_result1_vls, interp->result);
d326 4
a329 4
  if( mged_variables->slidersflag )
    bu_vls_printf(&vls, "sliders on");
  else
    bu_vls_printf(&vls, "sliders off");
d331 1
a331 8
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_strcpy(&save_result2_vls, interp->result);
  Tcl_SetResult(interp, bu_vls_addr(&save_result1_vls), TCL_VOLATILE);
  Tcl_AppendResult(interp, bu_vls_addr(&save_result2_vls), (char *)NULL);
  
  bu_vls_free(&vls);
  bu_vls_free(&save_result1_vls);
  bu_vls_free(&save_result2_vls);
d348 1
a348 1
  MAT4X3PNT(absolute_tran, model2view, orig_pos);
d350 1
a350 1
  VMOVE(last_absolute_tran, absolute_tran);
d360 3
a362 3
  MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
  VSUB2(diff, orig_pos, new_pos);
  VSCALE(absolute_model_tran, diff, 1/Viewscale);
d364 1
a364 1
  VMOVE(last_absolute_model_tran, absolute_model_tran);
d376 1
a376 1
  if(mged_variables->dlist){
d379 1
a379 1
      if(dmlp->_mged_variables != save_dmlp->_mged_variables)
d397 1
a397 1
      if(dmlp->_mged_variables != save_dmlp->_mged_variables)
d424 2
a425 2
  if(mged_variables->perspective > 0)
    mged_variables->perspective_mode = 1;
d427 1
a427 1
    mged_variables->perspective_mode = 0;
d435 1
a435 1
  mged_variables->perspective = mged_variables->perspective_mode ?
d450 3
a452 3
  if(mged_variables->toggle_perspective > 0)
    perspective_angle = mged_variables->toggle_perspective <= 4 ?
      mged_variables->toggle_perspective - 1: 3;
d460 1
a460 1
  mged_variables->toggle_perspective = 1;
d462 1
a462 1
  if(!mged_variables->perspective_mode)
d465 1
a465 1
  mged_variables->perspective = perspective_table[perspective_angle];
d473 1
a473 1
  if(mged_variables->fb && !fbp){
d476 2
a477 2
      mged_variables->fb = 0;
  }else if(!mged_variables->fb && fbp){
a482 32
}

static void
set_grid_draw()
{
  struct dm_list *dlp;

  set_dirty_flag();

  /* This gets done at most one time. */
  if(grid_auto_size && mged_variables->grid_draw){
    fastf_t res = VIEWSIZE*base2local / 64.0;

    mged_variables->grid_res_h = res;
    mged_variables->grid_res_v = res;
    FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
      if(dlp->_mged_variables == mged_variables)
	dlp->_grid_auto_size = 0;
  }
}

static void
set_grid_res()
{
  struct dm_list *dlp;

  set_dirty_flag();

  if(grid_auto_size)
    FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
      if(dlp->_mged_variables == mged_variables)
	dlp->_grid_auto_size = 0;
@


11.65
log
@Port to sun4.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/set.c,v 11.64 1998/06/11 14:28:17 bparker Exp $ (BRL)";
a51 2
/* m_axes_color */		{ 100, 255, 100 },
/* m_axes_label_color */	{ 255, 255, 0 },
a55 2
/* v_axes_color */		{ 100, 100, 255 },
/* v_axes_label_color */	{ 255, 255, 0 },
a59 4
/* e_axes_color1 */		{ 255, 255, 255 },
/* e_axes_color2 */		{ 255, 255, 255 },
/* e_axes_label_color1 */	{ 255, 255, 0 },
/* e_axes_label_color2 */	{ 255, 255, 0 },
a76 1
/* rubber_band_color */		{ 255, 255, 255 },
a80 1
/* grid_color */		{ 255, 255, 255 },
a161 2
	{"%d",  3, "m_axes_color",	MV_OA(m_axes_color),	set_dirty_flag },
	{"%d",  3, "m_axes_label_color",MV_OA(m_axes_label_color),set_dirty_flag },
a165 2
	{"%d",  3, "v_axes_color",	MV_OA(v_axes_color),	set_dirty_flag },
	{"%d",  3, "v_axes_label_color",MV_OA(v_axes_label_color),set_dirty_flag },
d168 1
a168 1
	{"%d",  2, "v_axes_pos",        MV_OA(v_axes_pos),       set_dirty_flag },
a169 4
	{"%d",  3, "e_axes_color1",	MV_OA(e_axes_color1),	set_dirty_flag },
	{"%d",  3, "e_axes_color2",	MV_OA(e_axes_color2),	set_dirty_flag },
	{"%d",  3, "e_axes_label_color1",MV_OA(e_axes_label_color1),set_dirty_flag },
	{"%d",  3, "e_axes_label_color2",MV_OA(e_axes_label_color2),set_dirty_flag },
d176 4
a179 4
	{"%d",  1, "send_key",          MV_O(send_key),         BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "hot_key",           MV_O(hot_key),          BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "context",           MV_O(context),          BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "dlist",             MV_O(dlist),            set_dlist },
a186 1
	{"%d",  3, "rubber_band_color",	MV_OA(rubber_band_color),set_dirty_flag },
a190 1
	{"%d",  3, "grid_color",	MV_OA(grid_color),	set_dirty_flag },
a323 1
  register int i;
d325 9
a333 9
    for( sp = &mged_vparse[0]; sp->sp_name != NULL; sp++ ) {
	read_var( (ClientData)sp, interp, sp->sp_name, (char *)NULL, 0 );
	Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_READS|TCL_GLOBAL_ONLY,
		      read_var, (ClientData)sp );
	Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_WRITES|TCL_GLOBAL_ONLY,
		      write_var, (ClientData)sp );
	Tcl_TraceVar( interp, sp->sp_name, TCL_TRACE_UNSETS|TCL_GLOBAL_ONLY,
		      unset_var, (ClientData)sp );
    }
@


11.64
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/set.c,v 11.63 1998/03/19 18:03:20 bparker Exp $ (BRL)";
d161 1
d167 1
a167 1
	{"%d",	2, "sgi_win_origin",	MV_O(sgi_win_origin[0]),BU_STRUCTPARSE_FUNC_NULL },
d172 2
a173 2
	{"%d",  3, "m_axes_color",	MV_O(m_axes_color),	set_dirty_flag },
	{"%d",  3, "m_axes_label_color",MV_O(m_axes_label_color),set_dirty_flag },
d176 1
a176 1
	{"%f",	3, "m_axes_pos",	MV_O(m_axes_pos),	set_dirty_flag },
d178 2
a179 2
	{"%d",  3, "v_axes_color",	MV_O(v_axes_color),	set_dirty_flag },
	{"%d",  3, "v_axes_label_color",MV_O(v_axes_label_color),set_dirty_flag },
d182 1
a182 1
	{"%d",  2, "v_axes_pos",        MV_O(v_axes_pos),       set_dirty_flag },
d184 4
a187 4
	{"%d",  3, "e_axes_color1",	MV_O(e_axes_color1),	set_dirty_flag },
	{"%d",  3, "e_axes_color2",	MV_O(e_axes_color2),	set_dirty_flag },
	{"%d",  3, "e_axes_label_color1",MV_O(e_axes_label_color1),set_dirty_flag },
	{"%d",  3, "e_axes_label_color2",MV_O(e_axes_label_color2),set_dirty_flag },
d205 1
a205 1
	{"%d",  3, "rubber_band_color",	MV_O(rubber_band_color),set_dirty_flag },
d210 2
a211 2
	{"%d",  3, "grid_color",	MV_O(grid_color),	set_dirty_flag },
	{"%f",	3, "grid_anchor",	MV_O(grid_anchor),	set_dirty_flag },
@


11.63
log
@ADC variables and "Query Ray" variables are
no longer mged_variables
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.62 1998/03/06 22:29:42 bparker Exp bparker $ (BRL)";
a36 1
#ifdef USE_FRAMEBUFFER
a40 1
#endif
a78 1
#ifdef USE_FRAMEBUFFER
a83 2
#endif
#ifdef DO_RUBBER_BAND
a87 2
#endif
#ifdef DO_SNAP_TO_GRID
a95 1
#endif
a197 1
#ifdef USE_FRAMEBUFFER
a202 2
#endif
#ifdef DO_RUBBER_BAND
a206 2
#endif
#ifdef DO_SNAP_TO_GRID
a214 1
#endif
a554 1
#ifdef USE_FRAMEBUFFER
a568 1
#endif
@


11.62
log
@*- added set_adc_xyz_grid(), set_adc_xyz()
*- added support for ADC's mged_variables
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.61 1998/02/20 23:09:41 bparker Exp bparker $ (BRL)";
a35 4
extern void adc_xyz_To_dv_xyadc();	/* in adc.c */
extern void adc_xyz_grid_To_dv_xyadc();	/* in adc.c */
extern void dv_xyadc_To_adc_xyz();	/* in adc.c */
extern void dv_xyadc_To_adc_xyz_grid();	/* in adc.c */
a46 1
/* adcflag */                   0,
a80 17
/* query_ray_cmd_echo */		0,
/* query_ray_color_odd */	{ 0, 255, 255 },
/* query_ray_color_even */	{ 255, 255, 0 },
/* query_ray_color_void */	{ 255, 0, 255 },
/* query_ray_color_overlap */	{ 255, 255, 255 },
/* adc_xyz */			{ 0.0, 0.0, 0.0 },
/* adc_xyz_grid */		{ 0.0, 0.0 },
/* adc_a1 */			45.0,
/* adc_a2 */			45.0,
/* adc_dst */			0.0,
/* adc_anchor_xyz */		0,
/* adc_anchor_a1 */		0,
/* adc_anchor_pt_a1 */		{ 0.0, 0.0, 0.0 },
/* adc_anchor_a2 */		0,
/* adc_anchor_pt_a2 */		{ 0.0, 0.0, 0.0 },
/* adc_anchor_tick */		0,
/* adc_anchor_pt_tick */	{ 0.0, 0.0, 0.0 },
a104 1
/* query_ray_behavior */             't',
a133 2
void set_adc_xyz();
void set_adc_xyz_grid();
a171 1
	{"%d",	1, "adcflag",		MV_O(adcflag),          set_dirty_flag },
a205 17
	{"%d",  1, "query_ray_cmd_echo",MV_O(query_ray_cmd_echo),BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  3, "query_ray_color_odd",MV_O(query_ray_color_odd),BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  3, "query_ray_color_even",MV_O(query_ray_color_even),BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  3, "query_ray_color_void",MV_O(query_ray_color_void),BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  3, "query_ray_color_overlap",MV_O(query_ray_color_overlap),BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "adc_xyz",		MV_O(adc_xyz),		set_adc_xyz },
	{"%f",  2, "adc_xyz_grid",	MV_O(adc_xyz_grid),	set_adc_xyz_grid },
	{"%f",  1, "adc_a1",		MV_O(adc_a1),		set_dirty_flag },
	{"%f",  1, "adc_a2",		MV_O(adc_a2),		set_dirty_flag },
	{"%f",  1, "adc_dst",		MV_O(adc_dst),		set_dirty_flag },
	{"%d",  1, "adc_anchor_xyz",	MV_O(adc_anchor_xyz),	set_dirty_flag },
	{"%d",  1, "adc_anchor_a1",	MV_O(adc_anchor_a1),	set_dirty_flag },
	{"%f",  3, "adc_anchor_pt_a1",	MV_O(adc_anchor_pt_a1),	set_dirty_flag },
	{"%d",  1, "adc_anchor_a2",	MV_O(adc_anchor_a2),	set_dirty_flag },
	{"%f",  3, "adc_anchor_pt_a2",	MV_O(adc_anchor_pt_a2),	set_dirty_flag },
	{"%d",  1, "adc_anchor_tick",	MV_O(adc_anchor_tick),	set_dirty_flag },
	{"%f",  3, "adc_anchor_pt_tick",MV_O(adc_anchor_pt_tick),set_dirty_flag },
a229 1
	{"%c",  1, "query_ray_behavior",MV_O(query_ray_behavior),BU_STRUCTPARSE_FUNC_NULL },
a615 32
}

void
set_adc_xyz()
{
  struct dm_list *dlp;

  adc_xyz_To_dv_xyadc();
  dv_xyadc_To_adc_xyz_grid();

  set_dirty_flag();

  if(adc_auto)
    FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
      if(dlp->_mged_variables == mged_variables)
	dlp->_adc_auto = 0;
}

void
set_adc_xyz_grid()
{
  struct dm_list *dlp;

  adc_xyz_grid_To_dv_xyadc();
  dv_xyadc_To_adc_xyz();

  set_dirty_flag();

  if(adc_auto)
    FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
      if(dlp->_mged_variables == mged_variables)
	dlp->_adc_auto = 0;
@


11.61
log
@add code to autosize the grid parameters if first
time drawing and not modified by user
@
text
@d6 1
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.60 1998/02/06 21:55:37 bparker Exp bparker $ (BRL)";
d35 5
a39 1
extern void	predictor_hook();		/* in ged.c */
d86 1
a86 1
/* echo_query_ray_cmd */		0,
d90 13
d157 2
d232 1
a232 1
	{"%d",  1, "echo_query_ray_cmd",	MV_O(echo_query_ray_cmd),	BU_STRUCTPARSE_FUNC_NULL },
d236 13
d660 32
@


11.60
log
@add support for new mged_variables
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.59 1998/01/28 15:34:28 bparker Exp bparker $ (BRL)";
d52 1
d105 2
a106 2
/* grid_res_major_h */		1,
/* grid_res_major_v */		1,
d132 2
d183 1
d189 1
a189 1
	{"%f",  3, "m_axes_pos",	MV_O(m_axes_pos),	set_dirty_flag },
d230 1
a230 1
	{"%d",  1, "grid_draw",		MV_O(grid_draw),	set_dirty_flag },
d233 5
a237 5
	{"%f",  3, "grid_anchor",	MV_O(grid_anchor),	set_dirty_flag },
	{"%f",  1, "grid_res_h",	MV_O(grid_res_h),	set_dirty_flag },
	{"%f",  1, "grid_res_v",	MV_O(grid_res_v),	set_dirty_flag },
	{"%d",  1, "grid_res_major_h",	MV_O(grid_res_major_h),	set_dirty_flag },
	{"%d",  1, "grid_res_major_v",	MV_O(grid_res_major_v),	set_dirty_flag },
d596 32
@


11.59
log
@*- added set_fb()
*- got rid of ecoords and erotate_about
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.58 1998/01/16 21:56:30 bparker Exp bparker $ (BRL)";
d53 5
d59 5
a63 1
/* v_axes_pos */                0,
d65 8
d74 1
a74 1
/* linestyle */                 0,
d80 4
a83 1
/* echo_nirt_cmd */		0,
d93 3
d97 10
d108 1
a108 1
/* nirt_behavior */             't',
d180 21
a200 4
	{"%d",  1, "m_axes",            MV_O(m_axes),           set_dirty_flag },
	{"%d",  1, "v_axes",            MV_O(v_axes),           set_dirty_flag },
	{"%d",  1, "v_axes_pos",        MV_O(v_axes_pos),       set_dirty_flag },
	{"%d",  1, "e_axes",            MV_O(e_axes),           set_dirty_flag },
d202 1
a202 1
	{"%d",	1, "linestyle",		MV_O(linestyle),	set_dirty_flag },
d208 4
a211 1
	{"%d",  1, "echo_nirt_cmd",	MV_O(echo_nirt_cmd),	BU_STRUCTPARSE_FUNC_NULL },
d221 13
d236 1
a236 1
	{"%c",  1, "nirt_behavior",     MV_O(nirt_behavior),    BU_STRUCTPARSE_FUNC_NULL },
d588 2
@


11.58
log
@add a few mged_variables
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.57 1997/12/23 14:20:26 bparker Exp bparker $ (BRL)";
d38 3
a61 1
/* nirt_behavior */             0,
d74 2
a75 1
/* mouse_behavior */            'm',
a76 1
/* ecoords */                   'o',
a77 1
/* erotate_about */             'k',
d140 3
a142 3
	{"%d",	1, "rateknobs",		MV_O(rateknobs),	set_scroll },
	{"%d",	1, "adcflag",		MV_O(adcflag),          set_scroll },
	{"%d",	1, "slidersflag",	MV_O(slidersflag),      set_scroll },
a156 1
	{"%d",  1, "nirt_behavior",     MV_O(nirt_behavior),    BU_STRUCTPARSE_FUNC_NULL },
d162 1
a162 1
	{"%d",  1, "fb",		MV_O(fb),		set_dirty_flag },
d170 1
a171 1
	{"%c",  1, "ecoords",           MV_O(ecoords),          BU_STRUCTPARSE_FUNC_NULL },
a172 1
	{"%c",  1, "erotate_about",     MV_O(erotate_about),    BU_STRUCTPARSE_FUNC_NULL },
d509 15
@


11.57
log
@*- remover scroll_edit
*- add new mged_variables: nirt_behavior, mouse_nirt, use_air, echo_nirt_cmd
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.56 1997/11/26 21:30:01 bparker Exp bparker $ (BRL)";
d36 4
a59 1
/* mouse_nirt */                0,
d62 11
a156 1
	{"%d",  1, "mouse_nirt",        MV_O(mouse_nirt),       BU_STRUCTPARSE_FUNC_NULL },
d159 11
@


11.56
log
@mods to set_absolute_tran(), read_var(), write_var()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.55 1997/11/19 21:47:35 bparker Exp bparker $ (BRL)";
d55 4
d142 4
a326 5

  if(es_edclass && mged_variables->transform == 'e')
    scroll_edit = es_edclass;
  else
    scroll_edit = EDIT_CLASS_NULL;
@


11.55
log
@mods to set_scroll()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.54 1997/11/19 15:47:10 bparker Exp bparker $ (BRL)";
d82 2
d185 2
d216 2
d351 19
a378 5

  /* calculate absolute_tran */
  MAT4X3PNT(absolute_tran, model2view, orig_pos);
  /* This is used in f_knob()  ---- needed in case absolute_tran is set from Tcl */
  VMOVE(last_absolute_tran, absolute_tran);
@


11.54
log
@mods to f_set()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.53 1997/11/12 21:59:44 bparker Exp bparker $ (BRL)";
d311 2
d323 3
d333 4
d338 2
@


11.53
log
@add two mged_variables:
	perspective_mode - used to toggle perspective viewing on/off
	toggle_perspective - used to toggle through values in perspective_table[]
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.52 1997/11/06 20:04:33 bparker Exp bparker $ (BRL)";
d281 1
a281 2
	struct bu_vls vls;
	int bad = 0;
d283 20
a302 2
	if(argc < 1 || 2 < argc){
	  struct bu_vls vls;
d304 1
a304 28
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help vars");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init(&vls);

	if (argc == 1) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  start_catching_output(&tmp_vls);
	  bu_struct_print("mged variables", mged_vparse, (CONST char *)mged_variables);
	  bu_log("%s", bu_vls_addr(&vls) );
	  stop_catching_output(&tmp_vls);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	} else if (argc == 2) {
		bu_vls_strcpy(&vls, argv[1]);
		bu_struct_parse(&vls, mged_vparse, (char *)mged_variables);
	}

	bu_vls_free(&vls);

	dmaflag = 1;
	return bad ? TCL_ERROR : TCL_OK;
@


11.52
log
@*- use new mged variables: ecoords and erotate_about
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.51 1997/11/03 15:16:21 bparker Exp bparker $ (BRL)";
d64 2
d73 2
d76 3
d144 3
a146 1
	{"%f",	1, "perspective",	MV_O(perspective),	set_dirty_flag },
d412 49
@


11.51
log
@use LIBDM macros
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.50 1997/10/27 19:24:59 bparker Exp bparker $ (BRL)";
d56 1
d58 1
a71 1
static void set_v_axes_pos();
d114 1
a114 1
	{"%d",	1, "slidersflag",	MV_O(slidersflag),   set_scroll },
d121 1
a121 1
	{"%d",  1, "v_axes_pos",        MV_O(v_axes_pos),       set_v_axes_pos },
d127 1
a127 1
	{"%d",  1, "context",           MV_O(context),          set_dirty_flag },
d129 5
a133 3
	{"%c",  1, "coords",            MV_O(coords),           set_absolute_tran },
	{"%c",  1, "rotate_about",      MV_O(rotate_about),     set_dirty_flag },
	{"%c",  1, "transform",         MV_O(transform),        set_dirty_flag },
a351 7
set_v_axes_pos()
{
  if(mged_variables->v_axes)
    set_dirty_flag();
}

static void
d367 2
d385 2
@


11.50
log
@mods to set_absolute_tran()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.49 1997/09/08 19:46:09 bparker Exp bparker $ (BRL)";
a333 1
#if 1
d335 11
a345 40
    /* calculate absolute_model_tran */
    MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
    VSUB2(diff, orig_pos, new_pos);
    VSCALE(absolute_model_tran, diff, 1/Viewscale);
    /* This is used in f_knob()  ---- needed in case absolute_model_tran is set from Tcl */
    VMOVE(last_absolute_model_tran, absolute_model_tran);

    /* calculate absolute_tran */
    MAT4X3PNT(absolute_tran, model2view, orig_pos);
    /* This is used in f_knob()  ---- needed in case absolute_tran is set from Tcl */
    VMOVE(last_absolute_tran, absolute_tran);

#else
  struct dm_list *dmlp;
  struct dm_list *save_dmlp;

  save_dmlp = curr_dm_list;

  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
    if(dmlp->_mged_variables != save_dmlp->_mged_variables)
      continue;

    curr_dm_list = dmlp;

    /* calculate absolute_model_tran */
    MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
    VSUB2(diff, orig_pos, new_pos);
    VSCALE(absolute_model_tran, diff, 1/Viewscale);

    /* calculate absolute_tran */
    MAT4X3PNT(absolute_tran, model2view, orig_pos);

    if(mged_variables->faceplate && mged_variables->orig_gui)
      dirty = 1;
  }

  /* restore */
  curr_dm_list = save_dmlp;

#endif
d390 1
a390 1
	dmp->dm_freeDLists(dmp, HeadSolid.s_dlist + displaylist, 1);
d392 1
a392 1
	dmp->dm_freeDLists(dmp, HeadSolid.s_dlist + displaylist,
@


11.49
log
@remove reference to reattach()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.48 1997/09/08 18:15:38 bparker Exp bparker $ (BRL)";
d332 17
a350 2
  point_t new_pos;
  point_t diff;
d374 2
@


11.48
log
@*- mged_variables is now a pointer
*- use new macro FOR_ALL_DISPLAYS
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.47 1997/09/03 14:15:48 bparker Exp bparker $ (BRL)";
a34 1
extern void	reattach();			/* in attach.c */
@


11.47
log
@mods to implement new display lists
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.46 1997/08/20 19:23:33 jra Exp bparker $ (BRL)";
d39 1
a39 1
/* rateknobs */			1,
d48 1
d55 1
a55 1
/* dlist */                     0,
d71 2
a72 1
static void set_v_axes();
d85 2
a86 2
static void
dirty_hook()
d88 5
a92 1
  dirty = 1;
d101 1
a101 1
  nmg_eue_dist = mged_variables.nmg_eu_dist;
d117 8
a124 7
	{"%d",	1, "faceplate",		MV_O(faceplate),	dirty_hook },
	{"%d",	1, "orig_gui",		MV_O(orig_gui),	        dirty_hook },
	{"%d",  1, "m_axes",            MV_O(m_axes),           dirty_hook },
	{"%d",  1, "v_axes",            MV_O(v_axes),           set_v_axes },
	{"%d",  1, "e_axes",            MV_O(e_axes),           dirty_hook },
	{"%d",	1, "linewidth",		MV_O(linewidth),	dirty_hook },
	{"%d",	1, "linestyle",		MV_O(linestyle),	dirty_hook },
d127 1
a127 1
	{"%d",  1, "context",           MV_O(context),          dirty_hook },
d130 2
a131 2
	{"%c",  1, "rotate_about",      MV_O(rotate_about),     dirty_hook },
	{"%c",  1, "transform",         MV_O(transform),        dirty_hook },
d135 1
a135 1
	{"%f",	1, "perspective",	MV_O(perspective),	dirty_hook },
d137 1
a137 1
	{"%f",  1, "eye_sep_dist",	MV_O(eye_sep_dist),	reattach },
d166 1
a166 1
    bu_vls_struct_item( &str, sp, (CONST char *)&mged_variables, ' ');
d197 1
a197 1
    if( bu_struct_parse( &str, mged_vparse, (char *)&mged_variables ) < 0) {
d290 1
a290 1
	  bu_struct_print("mged variables", mged_vparse, (CONST char *)&mged_variables);
d297 1
a297 1
		bu_struct_parse(&vls, mged_vparse, (char *)&mged_variables);
d311 1
a311 1
  if(es_edclass && mged_variables.transform == 'e')
d321 1
a321 1
  if( mged_variables.slidersflag )
d333 2
d338 1
a338 4
  /* calculate absolute_model_tran */
  MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
  VSUB2(diff, orig_pos, new_pos);
  VSCALE(absolute_model_tran, diff, 1/Viewscale);
d340 3
a342 2
  /* calculate absolute_tran */
  MAT4X3PNT(absolute_tran, model2view, orig_pos);
d344 1
a344 3
  if(mged_variables.faceplate && mged_variables.orig_gui)
    dirty = 1;
}
d346 4
a349 4
static void
set_v_axes()
{
  dirty = 1;
d351 2
a352 2
  if(mged_variables.v_axes == 0)
    return;
d354 2
a355 3
  if(mged_variables.v_axes == 1){
    mged_variables.v_axes = last_v_axes;
    return;
d358 2
a359 1
  last_v_axes = mged_variables.v_axes;
d363 7
d372 5
d378 1
a378 1
  if(mged_variables.dlist){
d380 7
a386 2
    if(displaylist){
      dirty = 1;
d388 1
a388 1
      createDList(&HeadSolid);
d390 1
a390 1
      createDLists(&HeadSolid); 
d392 1
d396 7
a402 2
    if(displaylist){
      dirty = 1;
d404 1
a404 1
      dmp->dm_freeDLists(dmp, HeadSolid.s_dlist + dmp->dm_displaylist, 1);
d406 3
a408 3
      dmp->dm_freeDLists(dmp, HeadSolid.s_dlist + dmp->dm_displaylist,
			 BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist -
			 HeadSolid.s_dlist + 1);
d410 1
d414 3
@


11.46
log
@Minor mods for IRIX 6.4.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.45 1997/07/25 20:50:19 bparker Exp jra $ (BRL)";
d29 1
d54 1
d69 1
d121 1
d355 30
@


11.45
log
@2 new mged variables ---- linewidth and linestyle (0 - solid  1 - dashed)
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.44 1997/06/24 21:29:53 bparker Exp bparker $ (BRL)";
d234 1
@


11.44
log
@*- mods to mged_variables
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.43 1997/05/29 14:17:15 bparker Exp bparker $ (BRL)";
d48 2
d113 2
d331 3
@


11.43
log
@changed scroll_enabled to slidersflag
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.42 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d40 1
a40 1
/* slidersflag */            0,
d44 2
a45 2
/* show_menu */                 1,
/* w_axes */    	        0,
a49 2
/* view */                      0,
/* edit */                      0,
d51 3
a53 1
/* eyerot */                    0,
a64 1
static void set_view();
d67 1
a67 2
void set_rateknobs();
void set_adcflag();
a68 1

d101 2
a102 2
	{"%d",	1, "rateknobs",		MV_O(rateknobs),	set_rateknobs },
	{"%d",	1, "adcflag",		MV_O(adcflag),          set_adcflag },
d107 2
a108 2
	{"%d",	1, "show_menu",		MV_O(show_menu),	dirty_hook },
	{"%d",  1, "w_axes",            MV_O(w_axes),           dirty_hook },
a112 2
	{"%d",  1, "view",              MV_O(view),             set_view },
	{"%d",  1, "edit",              MV_O(edit),             set_scroll },
d114 3
a116 1
	{"%d",  1, "mged_rotate_view_around_eye",           MV_O(eyerot),          refresh_hook },
a143 17
#if TRY_NEW_MGED_VARS
    struct bu_structparse *sp = (struct bu_structparse *)clientData;
    struct bu_vls str;
    register int i = (int)clientData;

    /* Ask the libbu structparser for the value of the variable */

    bu_vls_init( &str );
    bu_vls_struct_item( &str, &mged_vparse[i], (CONST char *)&mged_variables, ' ');

    /* Next, set the Tcl variable to this value */
    (void)Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->s_info->mged_variable_names[i]),
		     bu_vls_addr(&str), (flags&TCL_GLOBAL_ONLY)|TCL_LEAVE_ERR_MSG);

    bu_vls_free(&str);
    return NULL;
#else
a157 1
#endif
a173 18
#if TRY_NEW_MGED_VARS
    struct bu_vls str;
    char *newvalue;
    register int i = (int)clientData;

    newvalue = Tcl_GetVar(interp,
			  bu_vls_addr(&curr_dm_list->s_info->mged_variable_names[i]),
			  (flags&TCL_GLOBAL_ONLY)|TCL_LEAVE_ERR_MSG);
    bu_vls_init( &str );
    bu_vls_printf( &str, "%s=\"%s\"", mged_vparse[i].sp_name, newvalue );
    if( bu_struct_parse( &str, mged_vparse, (char *)&mged_variables ) < 0) {
      Tcl_AppendResult(interp, "ERROR OCCURED WHEN SETTING ", mged_vparse[i].sp_name,
		       " TO ", newvalue, "\n", (char *)NULL);
    }
    bu_vls_free(&str);
    return read_var(clientData, interp, name1, name2,
		    (flags&(~TCL_TRACE_WRITES))|TCL_TRACE_READS);
#else
a187 1
#endif
a203 16
#if TRY_NEW_MGED_VARS
  if( flags & TCL_INTERP_DESTROYED )
            return NULL;

  Tcl_AppendResult(interp, "mged variables cannot be unset\n", (char *)NULL);
  Tcl_TraceVar( interp, name1, TCL_TRACE_READS, read_var,
		clientData );
  Tcl_TraceVar( interp, name1, TCL_TRACE_WRITES, write_var,
		clientData );
  Tcl_TraceVar( interp, name1, TCL_TRACE_UNSETS, unset_var,
		clientData );
  read_var(clientData, interp, name1, name2,
	   (flags&(~TCL_TRACE_UNSETS))|TCL_TRACE_READS);

  return NULL;
#else
a218 1
#endif
a229 51
#if TRY_NEW_MGED_VARS
void
mged_variable_setup(p)
struct dm_list *p;
{
  register int i;

  for(i = 0; mged_vparse[i].sp_name != NULL; ++i){
    bu_vls_init(&p->s_info->mged_variable_names[i]);
    bu_vls_printf(&p->s_info->mged_variable_names[i], "mged_variable(%S,%s)",
		  &p->_dmp->dm_pathName, mged_vparse[i].sp_name);
    read_var( (ClientData)i, interp,
	      bu_vls_addr(&p->s_info->mged_variable_names[i]), (char *)NULL, 0 );
    Tcl_TraceVar( interp, bu_vls_addr(&p->s_info->mged_variable_names[i]),
		  TCL_TRACE_READS|TCL_GLOBAL_ONLY,
		  read_var, (ClientData)i );
    Tcl_TraceVar( interp, bu_vls_addr(&p->s_info->mged_variable_names[i]),
		  TCL_TRACE_WRITES|TCL_GLOBAL_ONLY,
		  write_var, (ClientData)i );
    Tcl_TraceVar( interp, bu_vls_addr(&p->s_info->mged_variable_names[i]),
		  TCL_TRACE_UNSETS|TCL_GLOBAL_ONLY,
		  unset_var, (ClientData)i );
  }
}


mged_variable_free_vls(p)
struct dm_list *p;
{
  register int i;

  for(i = 0; mged_vparse[i].sp_name != NULL; ++i){
    Tcl_UntraceVar( interp, bu_vls_addr(&p->s_info->mged_variable_names[i]),
		    TCL_TRACE_READS|TCL_GLOBAL_ONLY,
		    read_var, (ClientData)i);
    Tcl_UntraceVar( interp, bu_vls_addr(&p->s_info->mged_variable_names[i]),
		    TCL_TRACE_WRITES|TCL_GLOBAL_ONLY,
		    write_var, (ClientData)i);
    Tcl_UntraceVar( interp, bu_vls_addr(&p->s_info->mged_variable_names[i]),
		    TCL_TRACE_UNSETS|TCL_GLOBAL_ONLY,
		    unset_var, (ClientData)i);
    bu_vls_free(&p->s_info->mged_variable_names[i]);
  }
}





#else
void
a245 2
#endif

a289 30
static void
set_view()
{
  point_t model_pos;
  point_t new_pos;

  /* save current view */
  bn_mat_copy(viewrot_table[current_view], Viewrot);

  /* save current Viewscale */
  viewscale_table[current_view] = Viewscale;

  /* toggle forward */
  if(mged_variables.view){
    if(++current_view > VIEW_TABLE_SIZE - 1)
      current_view = 0;
  }else{
    /* toggle backward */
    if(--current_view < 0)
      current_view = VIEW_TABLE_SIZE - 1;
  }

  /* restore previously saved view and Viewscale */
  bn_mat_copy(Viewrot, viewrot_table[current_view]);
  Viewscale = viewscale_table[current_view];
  new_mats();

  (void)mged_svbase();
}

d295 1
a295 1
  if(es_edclass && mged_variables.edit)
a313 1

d315 1
a315 1
set_rateknobs()
d317 2
a318 4
  (void)Tcl_SetVar(interp, "rateknobs", mged_variables.rateknobs ? "1" : "0",
		   TCL_GLOBAL_ONLY);
  set_scroll();
}
d320 4
d325 2
a326 6
void
set_adcflag()
{
  (void)Tcl_SetVar(interp, "adcflag", mged_variables.adcflag ? "1" : "0",
		   TCL_GLOBAL_ONLY);
  set_scroll();
@


11.42
log
@modify calls to Tcl_Eval
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.41 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d40 1
a40 1
/* scroll_enabled */            0,
d106 1
a106 1
	{"%d",	1, "scroll_enabled",	MV_O(scroll_enabled),   set_scroll },
d445 1
a445 1
  if( mged_variables.scroll_enabled )
@


11.41
log
@mods so that commands check args internally
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.40 1997/03/06 13:58:33 bparker Exp bparker $ (BRL)";
d368 6
a373 1
	  Tcl_Eval(interp, "help vars");
d433 2
d443 2
d446 1
a446 1
    Tcl_Eval(interp, "sliders on");
d448 4
a451 1
    Tcl_Eval(interp, "sliders off");
@


11.40
log
@*- mods to set v_axes to last position if toggled on
*- mods to accommodate making mged_variables private
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.39 1997/02/28 21:41:55 bparker Exp bparker $ (BRL)";
d367 2
a368 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d370 1
@


11.39
log
@*** empty log message ***
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.38 1997/02/04 22:09:46 bparker Exp bparker $ (BRL)";
d66 1
d82 6
d109 5
a113 5
	{"%d",	1, "faceplate",		MV_O(faceplate),	refresh_hook },
	{"%d",	1, "show_menu",		MV_O(show_menu),	refresh_hook },
	{"%d",  1, "w_axes",            MV_O(w_axes),           refresh_hook },
	{"%d",  1, "v_axes",            MV_O(v_axes),           refresh_hook },
	{"%d",  1, "e_axes",            MV_O(e_axes),           refresh_hook },
d118 1
a118 1
	{"%d",  1, "context",           MV_O(context),          refresh_hook },
d123 1
a123 1
	{"%f",	1, "perspective",	MV_O(perspective),	refresh_hook },
a437 4

#if 0
  dmaflag = 1;
#endif
d456 16
@


11.38
log
@add mged variable -- mged_rotate_view_around_eye (internal name is eyerot)
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.37 1997/01/24 21:00:54 bparker Exp bparker $ (BRL)";
d67 2
d97 2
a98 2
	{"%d",	1, "rateknobs",		MV_O(rateknobs),	set_scroll },
	{"%d",	1, "adcflag",		MV_O(adcflag),          set_scroll },
d108 1
a108 1
	{"%d",  1, "hot_key",           MV_O(hot_key),         BU_STRUCTPARSE_FUNC_NULL },
d140 1
d143 1
d148 16
a166 1

d169 1
d171 1
d188 18
d220 1
d237 16
d268 1
d271 1
d280 50
d334 2
a335 2
    register struct bu_structparse *sp;
    register int i;
d347 2
d424 3
d432 1
d434 19
@


11.37
log
@mods to update sliders
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.36 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d53 1
d110 1
d303 1
a303 6
  if(absolute_slew[X] != 0.0 ||
     absolute_slew[Y] != 0.0 ||
     absolute_slew[Z] != 0.0){
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
  }
@


11.36
log
@checkin for weekend
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.35 1997/01/08 21:54:19 bparker Exp bparker $ (BRL)";
d65 1
a65 1
static void set_scroll();
d309 1
a309 1
static void
d312 5
d321 2
@


11.35
log
@*** empty log message ***
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.34 1997/01/02 19:35:05 bparker Exp bparker $ (BRL)";
d313 3
a315 1
    Tcl_Eval( interp, "sliders on");
@


11.34
log
@mods to use libbn and libbu
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.33 1996/12/30 22:42:20 bparker Exp bparker $ (BRL)";
d293 1
a293 1
            current_view = VIEW_TABLE_SIZE - 1;
a295 4
#if 0
  if(EDIT_TRAN)
    MAT4X3PNT(model_pos, view2model, edit_absolute_tran);
#endif
a299 4
#if 0
  if(EDIT_TRAN)
    MAT4X3PNT(edit_absolute_tran, model2view, model_pos);
#endif
@


11.33
log
@added mged variable
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.32 1996/12/17 22:43:05 bparker Exp bparker $ (BRL)";
d93 1
a93 1
	{"%d",	1, "autosize",		MV_O(autosize),		FUNC_NULL },
d97 2
a98 2
	{"%d",	1, "sgi_win_size",	MV_O(sgi_win_size),	FUNC_NULL },
	{"%d",	2, "sgi_win_origin",	MV_O(sgi_win_origin[0]),FUNC_NULL },
d104 2
a105 2
	{"%d",  1, "send_key",          MV_O(send_key),         FUNC_NULL },
	{"%d",  1, "hot_key",           MV_O(hot_key),         FUNC_NULL },
d115 4
a118 4
	{"%s",  MAXLINE, "union_op",	MV_O(union_lexeme[0]),	FUNC_NULL },
	{"%s",  MAXLINE, "intersection_op",MV_O(intersection_lexeme[0]),	FUNC_NULL },
	{"%s",  MAXLINE, "difference_op",	MV_O(difference_lexeme[0]),	FUNC_NULL },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
d281 1
a281 1
  mat_copy(viewrot_table[current_view], Viewrot);
d301 1
a301 1
  mat_copy(Viewrot, viewrot_table[current_view]);
@


11.32
log
@mod's to eliminate jumpy sliders
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.31 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d52 1
d108 1
@


11.31
log
@experimentation
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.30 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d306 7
a312 2
  VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, new_pos);
@


11.30
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.29 1996/09/23 18:20:15 bparker Exp bparker $ (BRL)";
d294 1
d297 1
a297 1

d302 1
a302 1

d305 1
a305 1

@


11.29
log
@changed dm.h to mged_dm.h
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.28 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d51 1
d93 1
a93 1
	{"%d",	1, "rateknobs",		MV_O(rateknobs),	FUNC_NULL },
d106 1
d295 1
a295 1
    MAT4X3PNT(model_pos, view2model, absolute_slew);
d302 5
a306 6
  if(EDIT_TRAN){
    MAT4X3PNT(absolute_slew, model2view, model_pos);
  }else{
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
  }
d312 2
a313 4
  /* pre-toggle scroll_enabled */
  mged_variables.scroll_enabled = !mged_variables.scroll_enabled;

  sl_toggle_scroll();
@


11.28
log
@rt_list ---> bu_list
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.27 1996/09/03 17:21:14 bparker Exp bparker $ (BRL)";
d29 1
a29 1
#include "./dm.h"
@


11.27
log
@Check in Lee's changes
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.26 1996/08/29 23:37:36 butler Exp butler $ (BRL)";
d24 1
a25 2
#include "rtstring.h"
#include "bu.h"
@


11.26
log
@structparse moved to libbu
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.25 1996/08/29 23:22:39 butler Exp butler $ (BRL)";
d128 1
a128 1
ClientData clientData;       /* Contains pointer to bu_structparse entry */
d139 1
a139 1
    bu_vls_item_print( &str, sp, (CONST char *)&mged_variables );
d170 1
a170 1
    if( bu_structparse( &str, mged_vparse, (char *)&mged_variables ) < 0) {
d255 1
a255 1
	  bu_structprint("mged variables", mged_vparse, (CONST char *)&mged_variables);
d262 1
a262 1
		bu_structparse(&vls, mged_vparse, (char *)&mged_variables);
@


11.25
log
@structparse moved to libbu
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.24 1996/08/29 23:17:52 butler Exp butler $ (BRL)";
d139 1
a139 1
    rt_vls_item_print( &str, sp, (CONST char *)&mged_variables );
@


11.24
log
@structparse moved to libbu
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.23 1996/08/28 15:05:26 bparker Exp butler $ (BRL)";
d128 1
a128 1
ClientData clientData;       /* Contains pointer to structparse entry */
d162 1
a162 1
    struct bu_structparse *sp = (struct structparse *)clientData;
@


11.23
log
@update absolute_view within set_view()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.22 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d26 1
d91 1
a91 1
struct structparse mged_vparse[] = {
d133 1
a133 1
    struct structparse *sp = (struct structparse *)clientData;
d136 1
a136 1
    /* Ask the librt structparser for the value of the variable */
d162 1
a162 1
    struct structparse *sp = (struct structparse *)clientData;
d170 1
a170 1
    if( rt_structparse( &str, mged_vparse, (char *)&mged_variables ) < 0) {
d192 1
a192 1
    struct structparse *sp = (struct structparse *)clientData;
d221 1
a221 1
    register struct structparse *sp;
d255 1
a255 1
	  rt_structprint("mged variables", mged_vparse, (CONST char *)&mged_variables);
d262 1
a262 1
		rt_structparse(&vls, mged_vparse, (char *)&mged_variables);
@


11.22
log
@now using libbu
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.21 1996/08/22 20:55:14 bparker Exp bparker $ (BRL)";
d27 1
d273 3
d292 3
d299 7
@


11.21
log
@*** empty log message ***
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.20 1996/07/30 21:33:01 bparker Exp bparker $ (BRL)";
d78 1
a78 1
  struct rt_vls tmp_vls;
d82 4
a85 4
  rt_vls_init(&tmp_vls);
  rt_vls_printf(&tmp_vls, "New nmg_eue_dist = %g\n", nmg_eue_dist);
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
d132 1
a132 1
    struct rt_vls str;
d136 1
a136 1
    rt_vls_init( &str );
d141 1
a141 1
    (void)Tcl_SetVar(interp, sp->sp_name, rt_vls_addr(&str),
d161 1
a161 1
    struct rt_vls str;
d166 2
a167 2
    rt_vls_init( &str );
    rt_vls_printf( &str, "%s=\"%s\"", name1, newvalue );
d240 1
a240 1
	struct rt_vls vls;
d246 1
a246 1
	rt_vls_init(&vls);
d249 1
a249 1
	  struct rt_vls tmp_vls;
d251 1
a251 1
	  rt_vls_init(&tmp_vls);
d254 1
a254 1
	  rt_log("%s", rt_vls_addr(&vls) );
d256 2
a257 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d259 1
a259 1
		rt_vls_strcpy(&vls, argv[1]);
d263 1
a263 1
	rt_vls_free(&vls);
@


11.20
log
@*** empty log message ***
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.19 1996/07/25 19:01:15 bparker Exp bparker $ (BRL)";
d223 1
a223 1
	read_var( (ClientData)sp, interp, sp->sp_name, NULL, 0 );
@


11.19
log
@make use of viewrot_table and viewscale_table in struct dm
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.18 1996/06/21 16:06:16 bparker Exp bparker $ (BRL)";
d44 3
a46 3
/* w_axis */    	        0,
/* v_axis */    	        0,
/* e_axis */            	0,
d98 3
a100 3
	{"%d",  1, "w_axis",            MV_O(w_axis),           refresh_hook },
	{"%d",  1, "v_axis",            MV_O(v_axis),           refresh_hook },
	{"%d",  1, "e_axis",            MV_O(e_axis),           refresh_hook },
@


11.18
log
@added adcflag and scroll_enabled to mged_variables
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.17 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
a60 5

#define VIEW_TABLE_SIZE 7
static int current_view = 0;
static mat_t view_table[VIEW_TABLE_SIZE];
static fastf_t view_scale_table[VIEW_TABLE_SIZE];
a230 6

    /* Initialize view_table and view_scale_table */
    for(i = 0; i < VIEW_TABLE_SIZE; ++i){
      mat_idn(view_table[i]);
      view_scale_table[i] = 1;
    }
d273 1
a273 1
  mat_copy(view_table[current_view], Viewrot);
d276 1
a276 1
  view_scale_table[current_view] = Viewscale;
d289 2
a290 2
  mat_copy(Viewrot, view_table[current_view]);
  Viewscale = view_scale_table[current_view];
@


11.17
log
@convert commands to Tcl
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.16 1996/03/22 18:32:35 bparker Exp bparker $ (BRL)";
d38 2
d66 2
a67 1
static void     set_view();
d97 2
d303 9
@


11.16
log
@cleanup
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.15 1996/02/28 21:34:29 bparker Exp bparker $ (BRL)";
d79 2
a80 1
	extern double nmg_eue_dist;
d82 1
a82 1
	nmg_eue_dist = mged_variables.nmg_eu_dist;
d84 4
a87 1
	rt_log( "New nmg_eue_dist = %g\n", nmg_eue_dist);
d169 2
a170 2
	rt_log("ERROR OCCURED WHEN SETTING %s TO %s\n",
	       name1, newvalue);
d195 1
a195 1
    rt_log( "mged variables cannot be unset\n" );
d240 5
a244 3
f_set(ac,av)
int ac;
char *av[];
d249 3
d254 12
a265 5
	if (ac <= 1) {
		rt_structprint("mged variables", mged_vparse, (CONST char *)&mged_variables);
		rt_log("%s", rt_vls_addr(&vls) );
	} else if (ac == 2) {
		rt_vls_strcpy(&vls, av[1]);
a266 3
	} else {
		rt_log("Usage: set\t\t- prints all options\n\tset opt=val\t- sets an option\n");
		bad = 1;
d268 1
d272 1
a272 1
	return bad ? CMD_BAD : CMD_OK;
@


11.15
log
@added hot_key
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.14 1996/02/12 21:47:04 bparker Exp bparker $ (BRL)";
a27 1
#ifdef MULTI_ATTACH
a28 1
#endif
a34 1
#ifdef MULTI_ATTACH
a35 3
#else
struct mged_variables mged_variables = {
#endif
a44 1
#ifdef SEND_KEY_DOWN_PIPE
a46 1
#endif
a85 1
#ifdef MULTI_ATTACH
a86 3
#else
#define MV_O(_m)	offsetof(struct mged_variables, _m)
#endif
a96 1
#ifdef SEND_KEY_DOWN_PIPE
a98 1
#endif
d257 1
a257 3
#ifdef MULTI_ATTACH
	update_views = 1;
#endif
a283 2

  dmaflag = 1;
@


11.14
log
@*** empty log message ***
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.13 1996/02/09 22:15:38 bparker Exp bparker $ (BRL)";
d53 1
d111 1
@


11.13
log
@adding virtual trackball stuff
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.12 1996/01/17 22:03:57 bparker Exp bparker $ (BRL)";
d51 3
a53 1
/* focus */                     0,
d108 3
a110 1
	{"%d",  1, "focus",             MV_O(focus),            FUNC_NULL },
@


11.12
log
@added mged_variable show_menu for toggling the menu on/off
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.11 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
a50 1
/* predictor */			0,
d53 1
d106 1
a107 2
	{"%d",  1, "focus",             MV_O(focus),            FUNC_NULL },

@


11.11
log
@Just playing it safe
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.10 1995/12/11 22:43:11 bparker Exp bparker $ (BRL)";
d47 1
d90 1
d102 1
@


11.10
log
@also need to save Viewscale
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.9 1995/12/04 21:59:32 bparker Exp bparker $ (BRL)";
d28 3
a33 4
#ifdef XMGED
extern int update_views;
#endif

d37 3
d41 1
d89 3
d93 1
d263 1
a263 1
#ifdef XMGED
@


11.9
log
@added two mged variables: view and focus
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.8 1995/11/07 22:52:55 bparker Exp bparker $ (BRL)";
d64 1
d227 2
a228 3

    /* Initialize view_table */
    for(i = 0; i < VIEW_TABLE_SIZE; ++i)
d230 2
d268 3
d281 1
a281 1
  /* restore previously saved view */
d283 1
@


11.8
log
@turned on axis
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.7 1995/10/26 15:38:09 cjohnson Exp bparker $ (BRL)";
d48 2
d60 7
d95 3
d214 1
d225 5
d260 19
d280 2
@


11.7
log
@A little lint clean up for irix5.2
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.6 1995/08/03 21:48:47 gdurf Exp cjohnson $ (BRL)";
a43 1
#ifdef XMGED
a46 1
#endif
a82 1
#ifdef XMGED
a85 1
#endif
@


11.6
log
@*** empty log message ***
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.5 1995/07/25 18:48:01 gdurf Exp gdurf $ (BRL)";
d96 3
a98 3
	{"%s",  MAXLINE, "union_op",	MV_O(union_lexeme),	FUNC_NULL },
	{"%s",  MAXLINE, "intersection_op",MV_O(intersection_lexeme),	FUNC_NULL },
	{"%s",  MAXLINE, "difference_op",	MV_O(difference_lexeme),	FUNC_NULL },
@


11.5
log
@Removed #ifndef XMGED directives
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.4 1995/07/25 18:47:11 gdurf Exp gdurf $ (BRL)";
a118 1
    char *curvalue;
@


11.4
log
@Changes by pjt
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.3 1995/06/15 20:22:42 gdurf Exp $ (BRL)";
a28 1
#ifndef XMGED
a29 1
#endif
a101 2
#ifndef XMGED

a217 2

#endif
@


11.3
log
@Added Tcl links to MGED variables
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 11.2 1995/01/17 13:05:04 bparker Exp gdurf $ (BRL)";
d41 5
a45 5
/* autosize */		1,
/* rateknobs */		1,
/* sgi_win_size */	0,
/* sgi_win_origin */	{ 0, 0 },
/* faceplate */		1,
d47 3
a49 3
/* w_axis */            0,
/* v_axis */            0,
/* e_axis */            0,
d51 9
a59 6
/* predictor */		0,
/* predictor_advance */	1.0,
/* predictor_length */	2.0,
/* perspective */	-1,
/* nmg_eu_dist */	0.05,
/* eye_sep_dist */	0.0
d98 3
@


11.2
log
@merging xmged sources
@
text
@d3 1
a3 1
 *  Author -
d5 1
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/set.c,v 11.2 95/01/17 11:44:25 bparker Exp $ (BRL)";
d29 4
d67 1
d98 121
d246 2
@


11.1
log
@Release_4.4
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.11 94/12/23 23:03:06 gdurf Exp $ (BRL)";
d28 4
d41 5
d78 5
d114 3
@


10.11
log
@Removed superfluous fflush
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.10 94/12/16 19:37:20 gdurf Exp Locker: gdurf $ (BRL)";
@


10.10
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.9 1994/08/09 18:28:57 gdurf Exp gdurf $ (BRL)";
a90 1
		fflush(stdout);
a96 1
		fflush(stdout);
@


10.9
log
@Added include of conf.h
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.8 1994/06/01 17:18:01 gdurf Exp gdurf $ (BRL)";
d60 1
a60 1
	fprintf(stderr, "New nmg_eue_dist = %g\n", nmg_eue_dist);
d90 1
a90 1
		printf("%s", rt_vls_addr(&vls) );
d96 1
a96 1
		printf("Usage: set\t\t- prints all options\n\tset opt=val\t- sets an option\n");
@


10.8
log
@Converted f_set to use new command return codes.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.7 1993/07/15 21:22:39 mike Exp gdurf $ (BRL)";
d18 2
@


10.7
log
@Added "rateknobs".
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.6 92/08/24 19:51:28 mike Exp Locker: mike $ (BRL)";
d76 1
a76 1
void
d82 1
d95 1
d99 2
@


10.6
log
@Added new variable "eye_sep_dist" to support Stereo viewing.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.5 92/06/25 21:06:20 butler Exp Locker: mike $ (BRL)";
d31 1
d63 1
@


10.5
log
@added support for setting NMG edgeuse offset variable "nmg_eu_dist"
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.4 92/04/18 00:40:52 mike Exp Locker: butler $ (BRL)";
d27 1
d38 2
a39 1
/* nmg_eu_dist */	0.05
d70 1
@


10.4
log
@Added perspective variable
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.3 92/04/04 00:12:07 mike Exp Locker: mike $ (BRL)";
d36 2
a37 1
/* perspective */	-1
d48 4
d53 4
d67 1
@


10.3
log
@Added predictor support
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.2 92/04/03 19:45:04 mike Exp Locker: mike $ (BRL)";
d35 2
a36 1
/* predictor_length */	2.0
d57 1
@


10.2
log
@Implemented set faceplate=0 support, per idea from Lee.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 10.1 1991/10/12 06:44:18 mike Rel4_0 butler $ (BRL)";
d26 2
d32 4
a35 1
/* faceplate */		1
d53 3
@


10.1
log
@Release_4.0
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 1.2 91/09/21 03:07:21 butler Exp $ (BRL)";
d29 2
a30 1
/* sgi_win_origin */	{ 0, 0 }
d33 9
d47 1
@


1.2
log
@initialized variables structure
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/set.c,v 1.1 91/08/31 07:34:59 mike Exp $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
struct mged_variables mged_variables;
@
