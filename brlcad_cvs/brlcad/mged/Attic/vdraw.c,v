head	1.33;
access;
symbols
	ansi-20040405-merged:1.31
	postmerge-20040405-ansi:1.31
	premerge-20040404-ansi:1.31
	postmerge-autoconf:1.31
	autoconf-freeze:1.31
	premerge-autoconf:1.31
	postmerge-20040315-windows:1.31
	premerge-20040315-windows:1.31
	windows-20040315-freeze:1.31
	autoconf-20031203:1.31
	autoconf-20031202:1.31
	autoconf-branch:1.31.0.12
	phong-branch:1.31.0.10
	photonmap-branch:1.31.0.8
	rel-6-1-DP:1.31
	windows-branch:1.31.0.6
	rel-6-0-2:1.31
	ansi-branch:1.31.0.4
	rel-6-0-1-branch:1.31.0.2
	hartley-6-0-post:1.31
	hartley-6-0-pre:1.31
	rel-6-0-1:1.31
	rel-6-0:1.31
	rel-5-4:1.28
	offsite-5-3-pre:1.29
	rel-5-3:1.28
	rel-5-2:1.28
	rel-5-1-branch:1.28.0.2
	rel-5-1:1.28
	rel-5-0:1.26
	rel-5-0-beta:1.26
	rel-4-5:1.22
	ctj-4-5-post:1.22
	ctj-4-5-pre:1.22;
locks; strict;
comment	@ * @;


1.33
date	2004.05.21.17.47.51;	author morrison;	state dead;
branches;
next	1.32;

1.32
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.01.19.23.26;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.19.03.10.19;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.19.02.14.03;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	99.12.30.20.26.03;	author jra;	state Exp;
branches;
next	1.26;

1.26
date	99.01.21.18.31.19;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	98.11.06.22.32.44;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	98.06.11.19.41.49;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	98.03.19.14.38.51;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	97.03.20.14.46.45;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	97.01.29.02.54.25;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	96.10.04.15.07.29;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	96.10.03.20.52.10;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	96.09.23.18.18.52;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	96.08.22.20.50.13;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	96.07.31.00.49.30;	author cnuzman;	state Exp;
branches;
next	1.9;

1.9
date	96.07.17.18.24.17;	author cnuzman;	state Exp;
branches;
next	1.8;

1.8
date	96.07.17.18.02.39;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	96.06.29.00.01.20;	author cnuzman;	state Exp;
branches;
next	1.6;

1.6
date	96.06.26.13.49.55;	author cnuzman;	state Exp;
branches;
next	1.5;

1.5
date	96.06.19.21.17.14;	author cnuzman;	state Exp;
branches;
next	1.4;

1.4
date	96.06.19.16.24.49;	author cnuzman;	state Exp;
branches;
next	1.3;

1.3
date	96.06.14.21.28.52;	author cnuzman;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	95.09.01.23.26.12;	author cnuzman;	state Exp;
branches;
next	;


desc
@mged command for editing pseudo-solid vector lists
@


1.33
log
@moved to src/mged/
@
text
@/*******************************************************************

CMD_VDRAW - edit vector lists and display them as pseudosolids

OPEN COMMAND
vdraw	open			- with no argument, asks if there is
	  			  an open vlist (1 yes, 0 no)

		name		- opens the specified vlist
				  returns 1 if creating new vlist
				          0 if opening an existing vlist
	
EDITING COMMANDS - no return value

vdraw	write	i	c x y z	- write params into i-th vector
		next	c x y z	- write params to end of vector list
		rpp	x y z x y z - write RPP outline at end of vector list

vdraw	insert	i	c x y z	- insert params in front of i-th vector

vdraw	delete 	i		- delete i-th vector
		last		- delete last vector on list
		all		- delete all vectors on list

PARAMETER SETTING COMMAND - no return value
vdraw	params	color		- set the current color with 6 hex digits
				  representing rrggbb
		name		- change the name of the current vlist

QUERY COMMAND
vdraw	read	i		- returns contents of i-th vector "c x y z"
		color		- return the current color in hex
		length		- return number of vectors in list
		name		- return name of current vlist

DISPLAY COMMAND - 
vdraw	send			- send the current vlist to the display
				  returns 0 on success, -1 if the name
				  conflicts with an existing true solid

CURVE COMMANDS
vdraw	vlist	list		- return list of all existing vlists
vdraw	vlist	delete	name	- delete the named vlist

All textual arguments can be replaced by their first letter.
(e.g. "vdraw d a" instead of "vdraw delete all"

In the above listing:

"i" refers to an integer 
"c" is an integer representing one of the following rt_vlist commands:
	 RT_VLIST_LINE_MOVE	0	/ begin new line /
	 RT_VLIST_LINE_DRAW	1	/ draw line /
	 RT_VLIST_POLY_START	2	/ pt[] has surface normal /
	 RT_VLIST_POLY_MOVE	3	/ move to first poly vertex /
	 RT_VLIST_POLY_DRAW	4	/ subsequent poly vertex /
	 RT_VLIST_POLY_END	5	/ last vert (repeats 1st), draw poly /
	 RT_VLIST_POLY_VERTNORM	6	/ per-vertex normal, for interpoloation /

"x y z" refer to floating point values which represent a point or normal
	vector. For commands 0,1,3,4, and 5, they represent a point, while
	for commands 2 and 6 they represent normal vectors

author - Carl Nuzman

Example Use -
	vdraw open rays
	vdraw delete all
	foreach partition $ray {
		...stuff...
		vdraw write next 0 $inpt
		vdraw write next 1 $outpt
	}
	vdraw send


********************************************************************/
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include <signal.h>
#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "mater.h"
#include "nmg.h"
#include "raytrace.h"
#include "externs.h"
#include "./sedit.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

#include "../librt/debug.h"	/* XXX */

#if 0
#ifndef M_SQRT2
#define M_SQRT2		1.41421356237309504880
#endif


#define VDRW_PREFIX		"_VDRW"
#define VDRW_PREFIX_LEN	6
#define VDRW_MAXNAME	31
#define VDRW_DEF_COLOR	0xffff00
#define REV_BU_LIST_FOR(p,structure,hp)	\
	(p)=BU_LIST_LAST(structure,hp);	\
	BU_LIST_NOT_HEAD(p,hp);		\
	(p)=BU_LIST_PLAST(structure,p)

static struct bu_list vdraw_head;
struct rt_curve {
	struct bu_list	l;
	char		name[VDRW_MAXNAME+1]; 	/* name array */
	long		rgb;	/* color */
	struct bu_list	vhd;	/* head of list of vertices */
};


/*XXX Not being called. */
int my_final_check(hp)
struct bu_list *hp;
{
	struct rt_vlist *vp;

	for ( BU_LIST_FOR( vp, rt_vlist, hp) ) {
		RT_CK_VLIST( vp );
		printf("num_used = %d\n", vp->nused);
	}
}
#endif

#if 0
int
cmd_read_center(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	char result_string[90];
	point_t pos;

	if(argc < 1 || 1 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help read_center");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	MAT_DELTAS_GET_NEG(pos, view_state->vs_toViewcenter);
	sprintf(result_string,"%.12e %.12e %.12e", pos[0], pos[1], pos[2]);
	Tcl_AppendResult(interp, result_string, (char *)NULL);
	return TCL_OK;

}

int
cmd_read_scale(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	char result_string[90];

	if(argc < 1 || 1 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help read_scale");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	sprintf(result_string,"%.12e", view_state->vs_Viewscale);
	Tcl_AppendResult(interp, result_string, (char *)NULL);
	return TCL_OK;

}

int 
cmd_viewget(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	char result_string[90];
	point_t pos, temp;
	quat_t quat;
	mat_t mymat;
	char c;

	if(argc < 2 || 2 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helpdevel viewget");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* center, size, eye, ypr */
	c = argv[1][0];
	switch(	c ) {
	case 'c': 	/*center*/
		MAT_DELTAS_GET_NEG(pos, view_state->vs_toViewcenter);
		sprintf(result_string,"%.12g %.12g %.12g", pos[0], pos[1], pos[2]);
		Tcl_AppendResult(interp, result_string, (char *)NULL);
		return TCL_OK;
	case 's':	/*size*/
		/* don't use base2local, because rt doesn't */
		sprintf(result_string,"%.12g", view_state->vs_Viewscale * 2.0);
		Tcl_AppendResult(interp, result_string, (char *)NULL);
		return TCL_OK;
	case 'e':	/*eye*/
		VSET(temp, 0.0, 0.0, 1.0);
		MAT4X3PNT(pos, view_state->vs_view2model, temp);
		sprintf(result_string,"%.12g %.12g %.12g",pos[0],pos[1],pos[2]);
		Tcl_AppendResult(interp, result_string, (char *)NULL);
		return TCL_OK;
	case 'y':	/*ypr*/
		bn_mat_trn( mymat, view_state->vs_Viewrot);
		anim_v_unpermute(mymat);
		c = anim_mat2ypr(temp, mymat);
		if (c==2) { 
			Tcl_AppendResult(interp, "mat2ypr - matrix is not a rotation matrix", (char *)NULL);
			return TCL_ERROR;
		}
		VSCALE(temp, temp, bn_radtodeg);	
		sprintf(result_string,"%.12g %.12g %.12g",temp[0],temp[1],temp[2]);
		Tcl_AppendResult(interp, result_string, (char *)NULL);
		return TCL_OK;
	case 'a': 	/* aet*/
		bn_mat_trn(mymat,view_state->vs_Viewrot);
		anim_v_unpermute(mymat);
		c = anim_mat2ypr(temp, mymat);
		if (c==2) { 
			Tcl_AppendResult(interp, "mat2ypr - matrix is not a rotation matrix", (char *)NULL);
			return TCL_ERROR;
		}
		VSCALE(temp, temp, bn_radtodeg);	
		if (temp[0] >= 180.0 ) temp[0] -= 180;
		if (temp[0] < 180.0 ) temp[0] += 180;
		temp[1] = -temp[1];
		temp[2] = -temp[2];
		sprintf(result_string,"%.12g %.12g %.12g",temp[0],temp[1],temp[2]);
		Tcl_AppendResult(interp, result_string, (char *)NULL);
		return TCL_OK;
	case 'q':	/*quat*/
		quat_mat2quat(quat,view_state->vs_Viewrot);
		sprintf(result_string,"%.12g %.12g %.12g %.12g", quat[0],quat[1],quat[2],quat[3]);
		Tcl_AppendResult(interp, result_string, (char *)NULL);
		return TCL_OK;
	default:				
		Tcl_AppendResult(interp, 
			"cmd_viewget: invalid argument. Must be one of center,size,eye,ypr.",
			(char *)NULL);
		return TCL_ERROR;
			
	}
}

int 
cmd_viewset(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	char result_string[90];
	quat_t quat;
	point_t center, eye;
	vect_t ypr, aet;
	fastf_t size;
	int in_quat, in_center, in_eye, in_ypr, in_aet, in_size;
	int i, res;
	vect_t dir, norm, temp;
	mat_t mymat;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helpdevel viewset");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	in_quat = in_center = in_eye = in_ypr = in_aet = in_size = 0.0;
	i = 1;
	while(i < argc) {
		switch( argv[i][0] ) {
		case 'q':	/* quaternion */
			if (i+4 >= argc) {
				Tcl_AppendResult(interp, "viewset: quat options requires four parameters", (char *)NULL);
				return TCL_ERROR;
			}
			res = sscanf(argv[i+1],"%lf",quat);
			res += sscanf(argv[i+2],"%lf",quat+1);
			res += sscanf(argv[i+3],"%lf",quat+2);
			res += sscanf(argv[i+4],"%lf",quat+3);
			if (res < 4) {
				Tcl_AppendResult(interp, "viewset: quat option requires four parameters", (char *)NULL);
				return TCL_ERROR;
			}
			in_quat = 1;
			i += 5;
			break;
		case 'y':	/* yaw,pitch,roll */
			if (i+3 >= argc) {
				Tcl_AppendResult(interp, "viewset: ypr option requires three parameters", (char *)NULL);
				return TCL_ERROR;
			}
			res = sscanf(argv[i+1],"%lf",ypr);
			res += sscanf(argv[i+2],"%lf",ypr+1);
			res += sscanf(argv[i+3],"%lf",ypr+2);
			if (res < 3) {
				Tcl_AppendResult(interp, "viewset: ypr option requires three parameters", (char *)NULL);
				return TCL_ERROR;
			}
			in_ypr = 1;
			i += 4;
			break;
		case 'a':	/* azimuth,elevation,twist */
			if (i+3 >= argc) {
				Tcl_AppendResult(interp, "viewset: aet option requires three parameters", (char *)NULL);
				return TCL_ERROR;
			}
			res = sscanf(argv[i+1],"%lf",aet);
			res += sscanf(argv[i+2],"%lf",aet+1);
			res += sscanf(argv[i+3],"%lf",aet+2);
			if (res < 3) {
				Tcl_AppendResult(interp, "viewset: aet option requires three parameters", (char *)NULL);
				return TCL_ERROR;
			}
			in_aet = 1;
			i += 4;
			break;
		case 'c':	/* center point */
			if (i+3 >= argc) {
				Tcl_AppendResult(interp, "viewset: center option requires three parameters", (char *)NULL);
				return TCL_ERROR;
			}
			res = sscanf(argv[i+1],"%lf",center);
			res += sscanf(argv[i+2],"%lf",center+1);
			res += sscanf(argv[i+3],"%lf",center+2);
			if (res < 3) {
				Tcl_AppendResult(interp, "viewset: center option requires three parameters", (char *)NULL);
				return TCL_ERROR;
			}
			in_center = 1;
			i += 4;
			break;
		case 'e':	/* eye_point */
			if (i+3 >= argc) {
				Tcl_AppendResult(interp, "viewset: eye option requires three parameters", (char *)NULL);
				return TCL_ERROR;
			}
			res = sscanf(argv[i+1],"%lf",eye);
			res += sscanf(argv[i+2],"%lf",eye+1);
			res += sscanf(argv[i+3],"%lf",eye+2);
			if (res < 3) {
				Tcl_AppendResult(interp, "viewset: eye option requires three parameters", (char *)NULL);
				return TCL_ERROR;
			}
			in_eye = 1;
			i += 4;
			break;
		case 's': 	/* view size */
			if (i+1 >= argc) {
				Tcl_AppendResult(interp, "viewset: size option requires a parameter", (char *)NULL);
				return TCL_ERROR;
			}
			res = sscanf(argv[i+1],"%lf",&size);
			if (res<1) {
				Tcl_AppendResult(interp, "viewset: size option requires a parameter", (char *)NULL);
				return TCL_ERROR;
			}
			in_size = 1;
			i += 2;
			break;
		default:
			sprintf(result_string,"viewset: Unknown option %.40s.", argv[i]);
			Tcl_AppendResult(interp, result_string, (char *)NULL);
			return TCL_ERROR;
		}
	}

	/* do size set - don't use units (local2base) because rt doesn't */
	if (in_size) {
		if (size < 0.0001) size = 0.0001;
		view_state->vs_Viewscale = size * 0.5;
	}


	/* overrides */
	if (in_center&&in_eye) {
		in_ypr = in_aet = in_quat = 0;
	}

	if (in_quat) {
		quat_quat2mat( view_state->vs_Viewrot, quat);
	} else if (in_ypr) {
		anim_dy_p_r2mat(mymat, ypr[0], ypr[1], ypr[2]);
		anim_v_permute(mymat);
		bn_mat_trn(view_state->vs_Viewrot, mymat);
	} else if (in_aet) {
		anim_dy_p_r2mat(mymat, aet[0]+180.0, -aet[1], -aet[2]);
		anim_v_permute(mymat);
		bn_mat_trn(view_state->vs_Viewrot, mymat);
	} else if (in_center && in_eye) {
		VSUB2( dir, center, eye);
		view_state->vs_Viewscale = MAGNITUDE(dir);
		if (view_state->vs_Viewscale < 0.00005) view_state->vs_Viewscale = 0.00005;
		/* use current eye norm as backup if dir vertical*/
		VSET(norm, -view_state->vs_Viewrot[0], -view_state->vs_Viewrot[1], 0.0);
		anim_dirn2mat(mymat, dir, norm);
		anim_v_permute(mymat);
		bn_mat_trn(view_state->vs_Viewrot, mymat);
	}

	if (in_center) {
		MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, center);
	} else if (in_eye) {
		VSET(temp, 0.0, 0.0, view_state->vs_Viewscale);
		bn_mat_trn(mymat, view_state->vs_Viewrot);
		MAT4X3PNT( dir, mymat, temp);
		VSUB2(temp, dir, eye);
		MAT_DELTAS_VEC( view_state->vs_toViewcenter, temp);
	}

	new_mats();

	return TCL_OK;

}
#endif
@


1.32
log
@change conf.h to a wrapped config.h
@
text
@@


1.31
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d78 5
a82 1
#include "conf.h"
@


1.30
log
@*- remove Tk dependencies
@
text
@d104 1
a127 1
#if 0
d141 1
a141 518
/*
 *			C M D _ V D R A W
 */
int
cmd_vdraw(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	static struct rt_curve *curhead;
	static int initialized = 0;
	struct rt_curve *rcp, *rcp2;
	struct rt_vlist *vp, *cp, *wp;
	int i, index, uind;
	int length;
	long rgb;
	struct bu_vls killstr;
	struct directory *dp;
	char result_string[90]; /* make sure there's room */
	static char temp_name[VDRW_MAXNAME+1];
	char solid_name [VDRW_MAXNAME+VDRW_PREFIX_LEN+1];
	static int real_flag;

	if(argc < 2 || 7 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help vdraw");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if (!initialized){
		if (BU_LIST_UNINITIALIZED( &rt_g.rtg_vlfree ))
			BU_LIST_INIT( &rt_g.rtg_vlfree );
		BU_LIST_INIT( &vdraw_head );
		curhead = (struct rt_curve *) NULL;
		initialized = 1;
	}

	switch ( argv[1][0] ) {
	case 'w': /*write*/
		if (!curhead) {
			Tcl_AppendResult(interp, "vdraw write: no vlist is currently open.", (char *)NULL);
			return TCL_ERROR;
		}
		if (argc < 5){
			Tcl_AppendResult(interp, "vdraw write: not enough args\n", (char *)NULL);
			return TCL_ERROR;
		}
		if (argv[2][0] == 'n') { /* next */
			for (REV_BU_LIST_FOR(vp, rt_vlist, &(curhead->vhd))){
				if (vp->nused > 0){
					break;
				}
			}
			if (BU_LIST_IS_HEAD(vp,&(curhead->vhd))){
				/* we went all the way through */
				vp = BU_LIST_PNEXT(rt_vlist, vp);
				if (BU_LIST_IS_HEAD(vp,&(curhead->vhd))){
					RT_GET_VLIST(vp);
					BU_LIST_INSERT( &(curhead->vhd), &(vp->l) );
				}
			}
			if (vp->nused >= RT_VLIST_CHUNK){
				vp = BU_LIST_PNEXT(rt_vlist, vp);
				if (BU_LIST_IS_HEAD(vp,&(curhead->vhd))){
					RT_GET_VLIST(vp);
					BU_LIST_INSERT(&(curhead->vhd),&(vp->l));
				}
			}
			cp = vp;
			index = vp->nused;
		} else if (argv[2][0] == 'r') { /* rpp_append */
			point_t	minn, maxx;
			if( argc == 5 )  {
				/* vdraw write rpp {1 2 3} {4 5 6} */
				bn_decode_vect( minn, argv[3] );
				bn_decode_vect( maxx, argv[4] );
			} else if( argc == 9 )  {
				VSET( minn, atof(argv[3]), atof(argv[4]), atof(argv[5]) );
				VSET( maxx, atof(argv[6]), atof(argv[7]), atof(argv[8]) );
			} else {
				Tcl_AppendResult(interp,
					 "vdraw write rpp: wrong # args, 'vdraw write rpp min max'\n",
					(char *)NULL);
				return TCL_ERROR;
			}

			/* Draw outline of the RPP */
			bn_vlist_rpp( &(curhead->vhd), minn, maxx );
			return TCL_OK;
		} else if (sscanf(argv[2], "%d", &uind)<1) {
			Tcl_AppendResult(interp, "vdraw: write index not an integer\n", (char *)NULL);
			return TCL_ERROR;
		} else {
			/* uind holds user-specified index */
			/* only allow one past the end */

			for (BU_LIST_FOR(vp, rt_vlist, &(curhead->vhd)) ){
				if (uind < RT_VLIST_CHUNK){
					/* this is the right vlist */
					break;
				}
				if (vp->nused == 0){
					break;
				}
				uind -= vp->nused;
			}

			if (BU_LIST_IS_HEAD(vp,&(curhead->vhd))){
				if (uind > 0){
					Tcl_AppendResult(interp, "vdraw: write out of range\n", (char *)NULL);
					return TCL_ERROR;
				}
				RT_GET_VLIST(vp);
				BU_LIST_INSERT(&(curhead->vhd),&(vp->l));
			}
			if (uind > vp->nused) {
				Tcl_AppendResult(interp, "vdraw: write out of range\n", (char *)NULL);
				return TCL_ERROR;
			}
			cp = vp;
			index = uind;
		}

		if(sscanf(argv[3],"%d",&(cp->cmd[index])) < 1){
			Tcl_AppendResult(interp, "vdraw: cmd not an integer\n", (char *)NULL);
			return TCL_ERROR;
		}
		if( argc == 7 )  {
			cp->pt[index][0] = atof(argv[4]);
			cp->pt[index][1] = atof(argv[5]);
			cp->pt[index][2] = atof(argv[6]);
		} else {
			if( argc != 5 ||
			    bn_decode_vect( cp->pt[index], argv[4] ) != 3 )  {
				Tcl_AppendResult(interp,
					"vdraw write: wrong # args, need either x y z or {x y z}\n", (char *)NULL);
				return TCL_ERROR;
			}
		}
		/* increment counter only if writing onto end */
		if (index == cp->nused)
			cp->nused++;

		return TCL_OK;
	case 'i': /*insert*/
		if (!curhead) {
			Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
			return TCL_ERROR;
		}
		if (argc < 7){
			Tcl_AppendResult(interp, "vdraw: not enough args", (char *)NULL);
			return TCL_ERROR;
		}
		if (sscanf(argv[2], "%d", &uind)<1) {
			Tcl_AppendResult(interp, "vdraw: insert index not an integer\n", (char *)NULL);
			return TCL_ERROR;
		} 

		/* uinds hold user specified index */
		for (BU_LIST_FOR(vp, rt_vlist, &(curhead->vhd)) ){
			if (uind < RT_VLIST_CHUNK){
				/* this is the right vlist */
				break;
			}
			if (vp->nused == 0){
				break;
			}
			uind -= vp->nused;
		}

		if (BU_LIST_IS_HEAD(vp,&(curhead->vhd))){
			if (uind > 0){
				Tcl_AppendResult(interp, "vdraw: insert out of range\n", (char *)NULL);
				return TCL_ERROR;
			}
			RT_GET_VLIST(vp);
			BU_LIST_INSERT(&(curhead->vhd),&(vp->l));
		}
		if (uind > vp->nused) {
			Tcl_AppendResult(interp, "vdraw: insert out of range\n", (char *)NULL);
			return TCL_ERROR;
		}


		cp = vp;
		index = uind;

		vp = BU_LIST_LAST(rt_vlist, &(curhead->vhd));
		vp->nused++;

		while (vp != cp){
			for (i=vp->nused-1; i > 0; i--){
				vp->cmd[i] = vp->cmd[i-1];
				VMOVE(vp->pt[i],vp->pt[i-1]);
			}
			wp = BU_LIST_PLAST(rt_vlist,vp);
			vp->cmd[0] = wp->cmd[RT_VLIST_CHUNK-1];
			VMOVE(vp->pt[0],wp->pt[RT_VLIST_CHUNK-1]);
			vp = wp;
		} 
		
		for ( i=vp->nused-1; i>index; i--){
			vp->cmd[i] = vp->cmd[i-1];
			VMOVE(vp->pt[i],vp->pt[i-1]);
		}
		if(sscanf(argv[3],"%d",&(vp->cmd[index])) < 1){
			Tcl_AppendResult(interp, "vdraw: cmd not an integer\n", (char *)NULL);
			return TCL_ERROR;
		}
		vp->pt[index][0] = atof(argv[4]);
		vp->pt[index][1] = atof(argv[5]);
		vp->pt[index][2] = atof(argv[6]);
		return TCL_OK;
	case 'd': /*delete*/
		if (!curhead) {
			Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
			return TCL_ERROR;
		}
		if (argc < 3){
			Tcl_AppendResult(interp, "vdraw: not enough args\n", (char *)NULL);
			return TCL_ERROR;
		}
		if (argv[2][0] == 'a') {
			/* delete all */
			for ( BU_LIST_FOR( vp, rt_vlist, &(curhead->vhd)) ){
				vp->nused = 0;
			}
			return TCL_OK;
		} 
		if (argv[2][0] == 'l') {
			/* delete last */
			for ( REV_BU_LIST_FOR( vp, rt_vlist, &(curhead->vhd)) ){
				if (vp->nused > 0){
					vp->nused--;
					break;
				}
			}
			return TCL_OK;
		}
		if (sscanf(argv[2], "%d", &uind)<1) {
			Tcl_AppendResult(interp, "vdraw: delete index not an integer\n", (char *)NULL);
			return TCL_ERROR;
		}  

		for ( BU_LIST_FOR(vp, rt_vlist, &(curhead->vhd)) ){
			if (uind < RT_VLIST_CHUNK){
				/* this is the right vlist */
				break;
			}
			if ( vp->nused == 0) {
				/* no point going further */
				break;
			}
			uind -= vp->nused;
		}
		
		if (uind >= vp->nused){
			Tcl_AppendResult(interp, "vdraw: delete out of range\n", (char *)NULL);
			return TCL_ERROR;
		}

		for ( i = uind; i < vp->nused - 1; i++) {
			vp->cmd[i] = vp->cmd[i+1];
			VMOVE(vp->pt[i],vp->pt[i+1]);
		}
		
		wp = BU_LIST_PNEXT(rt_vlist, vp);
		while ( BU_LIST_NOT_HEAD(wp, &(curhead->vhd)) ){
			if (wp->nused == 0) {
				break;
			}

			vp->cmd[RT_VLIST_CHUNK-1] = wp->cmd[0];
			VMOVE(vp->pt[RT_VLIST_CHUNK-1],wp->pt[0]);

			for(i=0; i< wp->nused - 1; i++){
				wp->cmd[i] = wp->cmd[i+1];
				VMOVE(wp->pt[i],wp->pt[i+1]);
			}
			vp = wp;
			wp = BU_LIST_PNEXT(rt_vlist, vp);
		}

		if (vp->nused <= 0) {
			/* this shouldn't happen */
			Tcl_AppendResult(interp, "vdraw: vlist corrupt", (char *)NULL);
			return TCL_ERROR;
		}
		vp->nused--;

		return TCL_OK;
	case 'r': /*read*/
		if (!curhead) {
			Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
			return TCL_ERROR;
		}
		if (argc < 3) {
			Tcl_AppendResult(interp, "vdraw: need index to read\n", (char *)NULL);
			return TCL_ERROR;
		}
		if (argv[2][0] == 'c') {
			/* read color of current solid */
			sprintf(result_string, "%.6lx", curhead->rgb);
			Tcl_AppendResult(interp, result_string, (char *)NULL);
			return TCL_OK;
		}
		if (argv[2][0] == 'n') {
			/*read name of currently open solid*/
			sprintf(result_string, "%.89s", curhead->name);
			Tcl_AppendResult(interp, result_string, (char *)NULL);
			return TCL_OK;
		}
		if (argv[2][0] == 'l') {
			/* return lenght of list */
			length = 0;
			vp = BU_LIST_FIRST(rt_vlist, &(curhead->vhd));
			while ( !BU_LIST_IS_HEAD(vp, &(curhead->vhd)) ) {
				length += vp->nused;
				vp = BU_LIST_PNEXT(rt_vlist, vp);
			}
			sprintf(result_string, "%d", length);
			Tcl_AppendResult(interp, result_string, (char *)NULL);
			return TCL_OK;
		}
		if (sscanf(argv[2], "%d", &uind) < 1) {
			Tcl_AppendResult(interp, "vdraw: read index not an integer\n", (char *)NULL);
			return TCL_ERROR;
		}

		for ( BU_LIST_FOR(vp, rt_vlist, &(curhead->vhd)) ){
			if (uind < RT_VLIST_CHUNK){
				/* this is the right vlist */
				break;
			}
			if ( vp->nused == 0) {
				/* no point going further */
				break;
			}
			uind -= vp->nused;
		}
		
		if (uind >= vp->nused){
			Tcl_AppendResult(interp, "vdraw: read out of range\n", (char *)NULL);
			return TCL_ERROR;
		}

		sprintf(result_string, "%d %.12e %.12e %.12e", 
			vp->cmd[uind], vp->pt[uind][0],
			vp->pt[uind][1],vp->pt[uind][2]);
		Tcl_AppendResult(interp, result_string, (char *)NULL);
		return TCL_OK;
	case 's': /*send*/
		if (!curhead) {
			Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
			return TCL_ERROR;
		}
		sprintf(solid_name, VDRW_PREFIX);
		strncat(solid_name, curhead->name, VDRW_MAXNAME);
		if (( dp = db_lookup( dbip, solid_name, LOOKUP_QUIET )) == DIR_NULL ) {
			real_flag = 0;
		} else {
			real_flag = (dp->d_addr == RT_DIR_PHONY_ADDR) ? 0 : 1;
		}
		if (real_flag){
			/* solid exists - don't kill */
			Tcl_AppendResult(interp, "-1", (char *)NULL);
			return TCL_OK;
		}
		if( !dbip->dbi_read_only ) {
		  char *av[4];

		  av[0] = "kill";
		  av[1] = "-f";
		  av[2] = solid_name;
		  av[3] = NULL;

		  (void)f_kill(clientData, interp, 3, av);
		}
		index = 0;
		index = invent_solid( solid_name, &(curhead->vhd), curhead->rgb, 1);
		sprintf(result_string,"%d",index);
		/* 0 means OK, -1 means conflict with real solid name */
		Tcl_AppendResult(interp, result_string, (char *)NULL);
		return TCL_OK;
	case 'p':  /* params */
		if (!curhead) {
			Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
			return TCL_ERROR;
		}
		if (argc < 4) {
			Tcl_AppendResult(interp, "vdraw: need params to set\n", (char *)NULL);
			return TCL_ERROR;
		}
		if (argv[2][0] == 'c'){
			if (sscanf(argv[3],"%lx", &rgb)>0)
				curhead->rgb = rgb;
			return TCL_OK;
		}
		if (argv[2][0] == 'n'){
			/* check for conflicts with existing vlists*/
			for ( BU_LIST_FOR( rcp, rt_curve, &vdraw_head) ) {
				if (!strncmp( rcp->name, argv[3], VDRW_MAXNAME)) {
					sprintf(result_string,"vdraw: name %.40s is already in use\n", argv[3]);
					Tcl_AppendResult(interp,result_string,(char *)NULL);
					return TCL_ERROR;
				}
			}
			/* otherwise name not yet used */
			strncpy(curhead->name, argv[3], VDRW_MAXNAME);
			curhead->name[VDRW_MAXNAME] = (char) NULL;
			Tcl_AppendResult(interp,"0",(char *)NULL);
			return TCL_OK;
		}
		break;
	case 'o': /* open */
		if (argc < 3) {
			if (curhead) {
				Tcl_AppendResult(interp, "1", (char *)NULL);
				return TCL_OK;
			} else {
				Tcl_AppendResult(interp, "0", (char *)NULL);
				return TCL_OK;
			}
		}
		strncpy(temp_name, argv[2], VDRW_MAXNAME);
		temp_name[VDRW_MAXNAME] = (char) NULL;
		curhead = (struct rt_curve *) NULL;
		for ( BU_LIST_FOR( rcp, rt_curve, &vdraw_head) ) {
			if (!strncmp( rcp->name, temp_name, VDRW_MAXNAME)) {
				curhead = rcp;
				break;
			}
		}
		if (!curhead) { /* create new entry */
			BU_GETSTRUCT( rcp, rt_curve );
			BU_LIST_APPEND( &vdraw_head, &(rcp->l) );
			strcpy( rcp->name, temp_name);
			rcp->name[VDRW_MAXNAME] = (char) NULL;
			rcp->rgb = VDRW_DEF_COLOR;
			BU_LIST_INIT(&(rcp->vhd));
			RT_GET_VLIST(vp);
			BU_LIST_APPEND( &(rcp->vhd), &(vp->l) );
			curhead = rcp;
			/* 1 means new entry */
			Tcl_AppendResult(interp, "1", (char *)NULL);
			return TCL_OK;
		} else { /* entry already existed */
			if (BU_LIST_IS_EMPTY(&(curhead->vhd))){
				RT_GET_VLIST(vp);
				BU_LIST_APPEND( &(curhead->vhd), &(vp->l) );
			}
			curhead->name[VDRW_MAXNAME] = (char) NULL; /*safety*/
			/* 0 means entry already existed*/
			Tcl_AppendResult(interp, "0", (char *)NULL);
			return TCL_OK;
		}
	case 'v':
		if (argc<3) {
			Tcl_AppendResult(interp,"vdraw: need more args",(char *)NULL);
			return TCL_ERROR;
		}
		switch  (argv[2][0]) {
		case 'l':
			bu_vls_init(&killstr);
			for ( BU_LIST_FOR( rcp, rt_curve, &vdraw_head) ) {
				bu_vls_strcat( &killstr, rcp->name);
				bu_vls_strcat( &killstr, " ");
			}

			Tcl_AppendResult(interp, bu_vls_addr(&killstr), (char *)NULL);
			bu_vls_free(&killstr);
			return TCL_OK;
		case 'd':
			if (argc<4) {
				Tcl_AppendResult(interp,"vdraw: need name of vlist to delete", (char *)NULL);
				return TCL_ERROR;
			}
			rcp2 = (struct rt_curve *)NULL;
			for ( BU_LIST_FOR( rcp, rt_curve, &vdraw_head) ) {
				if (!strncmp(rcp->name,argv[3],VDRW_MAXNAME)){
					rcp2 = rcp;
					break;
				}
			}
			if (!rcp2) {
				sprintf(result_string,"vdraw: vlist %.40s not found", argv[3]);
				Tcl_AppendResult(interp, result_string, (char *)NULL);
				return TCL_ERROR;
			}
			BU_LIST_DEQUEUE(&(rcp2->l));
			if (curhead == rcp2) {
				if ( BU_LIST_IS_EMPTY( &vdraw_head ) ){
					curhead = (struct rt_curve *)NULL;
				} else {
					curhead = BU_LIST_LAST(rt_curve,&vdraw_head);
				}
			}
			RT_FREE_VLIST(&(rcp2->vhd));
			bu_free((genptr_t) rcp2, "rt_curve");
			return TCL_OK;
		default:
			Tcl_AppendResult(interp,"vdraw: unknown option to vdraw vlist", (char *)NULL);
			return TCL_ERROR;
		}
	default:
		Tcl_AppendResult(interp, "vdraw: see vdraw.c for help\n", (char *)NULL);
		return TCL_ERROR;
	}
		
	return TCL_OK;
}


d453 1
@


1.29
log
@
Reduced use of MAXARGS
@
text
@a88 2
#include "tk.h"

@


1.28
log
@
Added rpp_append capability to rpp.
Eliminated error message on read-only database.
@
text
@d81 5
d814 1
a814 1
	if(argc < 3 || MAXARGS < argc){
@


1.27
log
@Eliminated some unused variables
@
text
@d17 1
d43 1
a43 1
		delete	name	- delete the named vlist
d49 1
d213 19
d511 1
a511 1
		{
@


1.26
log
@*- use helpdevel for help on developer commands
@
text
@a145 1
	char *str;
d150 1
a150 1
	int i, index, uind, blocks, change;
a151 1
	int found;
a152 1
	static long my_rgb;
a153 1
	struct solid *sp, *sp2;
a155 1
	static char vdraw_name[VDRW_MAXNAME+1];
a156 1
	static char def_name[] = "_vdraw_sol_";
a669 1
	point_t pos;
@


1.25
log
@*- use new structures
*- cleanup
@
text
@d711 1
a711 1
	  bu_vls_printf(&vls, "help viewget");
d799 1
a799 1
	  bu_vls_printf(&vls, "help viewset");
@


1.24
log
@*- using floating point literals to initialize floats
@
text
@d661 1
a661 1
	MAT_DELTAS_GET_NEG(pos, toViewcenter);
d688 1
a688 1
	sprintf(result_string,"%.12e", Viewscale);
d721 1
a721 1
		MAT_DELTAS_GET_NEG(pos, toViewcenter);
d727 1
a727 1
		sprintf(result_string,"%.12g", Viewscale * 2.0);
d732 1
a732 1
		MAT4X3PNT(pos, view2model, temp);
d737 1
a737 1
		bn_mat_trn( mymat, Viewrot);
d749 1
a749 1
		bn_mat_trn(mymat,Viewrot);
d765 1
a765 1
		quat_mat2quat(quat,Viewrot);
d908 1
a908 1
		Viewscale = size * 0.5;
d918 1
a918 1
		quat_quat2mat( Viewrot, quat);
d922 1
a922 1
		bn_mat_trn(Viewrot, mymat);
d926 1
a926 1
		bn_mat_trn(Viewrot, mymat);
d929 2
a930 2
		Viewscale = MAGNITUDE(dir);
		if (Viewscale < 0.00005) Viewscale = 0.00005;
d932 1
a932 1
		VSET(norm, -Viewrot[0], -Viewrot[1], 0.0);
d935 1
a935 1
		bn_mat_trn(Viewrot, mymat);
d939 1
a939 1
		MAT_DELTAS_VEC_NEG( toViewcenter, center);
d941 2
a942 2
		VSET(temp, 0.0, 0.0, Viewscale);
		bn_mat_trn(mymat, Viewrot);
d945 1
a945 1
		MAT_DELTAS_VEC( toViewcenter, temp);
@


1.23
log
@Modified so that 'vdraw write' would take vectors (lists) as
the xyz parameters, in addition to separate arguments for each.
@
text
@d731 1
a731 1
		VSET(temp, 0, 0, 1);
@


1.22
log
@modify calls to Tcl_Eval
@
text
@d63 12
d136 3
d187 1
a187 1
			Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
d190 2
a191 2
		if (argc < 7){
			Tcl_AppendResult(interp, "vdraw: not enough args\n", (char *)NULL);
d255 12
a266 3
		cp->pt[index][0] = atof(argv[4]);
		cp->pt[index][1] = atof(argv[5]);
		cp->pt[index][2] = atof(argv[6]);
@


1.21
log
@mods so that commands check args internally
@
text
@d152 6
a157 1
	  Tcl_Eval(interp, "help vdraw");
d628 6
a633 1
	  Tcl_Eval(interp, "help read_center");
d655 6
a660 1
	  Tcl_Eval(interp, "help read_scale");
d684 6
a689 1
	  Tcl_Eval(interp, "help viewget");
d772 6
a777 1
	  Tcl_Eval(interp, "help viewset");
@


1.20
log
@*** empty log message ***
@
text
@d151 2
a152 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d154 1
d622 2
a623 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d625 1
d644 2
a645 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d647 1
d668 2
a669 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d671 1
d751 2
a752 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d754 1
@


1.19
log
@Don't need db.h
@
text
@a552 1
		break;
a600 1
		break;
@


1.18
log
@mods to use libbn and libbu
@
text
@a75 1
#include "db.h"
@


1.17
log
@cast bu_free's 1st argument to genptr_t
@
text
@d688 1
a688 1
		mat_trn( mymat, Viewrot);
d695 1
a695 1
		VSCALE(temp, temp, rt_radtodeg);	
d700 1
a700 1
		mat_trn(mymat,Viewrot);
d707 1
a707 1
		VSCALE(temp, temp, rt_radtodeg);	
d866 1
a866 1
		mat_trn(Viewrot, mymat);
d870 1
a870 1
		mat_trn(Viewrot, mymat);
d879 1
a879 1
		mat_trn(Viewrot, mymat);
d886 1
a886 1
		mat_trn(mymat, Viewrot);
@


1.16
log
@get rid of extra cmdline() uses
@
text
@d597 1
a597 1
			bu_free((char *) rcp2, "rt_curve");
@


1.15
log
@include mged_solid.h
@
text
@d466 10
a475 4
		bu_vls_init(&killstr);
		bu_vls_printf( &killstr, "kill -f %s\n", solid_name );
		(void)cmdline( &killstr, FALSE );
		bu_vls_free(&killstr);
d567 3
a569 3
			/* also does free */
			str = bu_vls_strgrab(&killstr);
			Tcl_AppendResult(interp, str, (char *)NULL);
@


1.14
log
@changed dm.h to mged_dm.h
@
text
@d83 1
a83 1
#include "./solid.h"
@


1.13
log
@rt_list ---> bu_list
@
text
@d84 1
a84 1
#include "./dm.h"
@


1.12
log
@now using libbu
@
text
@d66 1
a68 1
#include <stdio.h>
d74 1
d78 1
a78 1
#include "rtstring.h"
a79 1
#include "nmg.h"
d97 4
a100 4
#define REV_RT_LIST_FOR(p,structure,hp)	\
	(p)=RT_LIST_LAST(structure,hp);	\
	RT_LIST_NOT_HEAD(p,hp);		\
	(p)=RT_LIST_PLAST(structure,p)
d102 1
a102 1
static struct rt_list vdraw_head;
d104 1
a104 1
	struct rt_list	l;
d107 1
a107 1
	struct rt_list	vhd;	/* head of list of vertices */
d114 1
a114 1
struct rt_list *hp;
d118 1
a118 1
	for ( RT_LIST_FOR( vp, rt_vlist, hp) ) {
d156 3
a158 3
		if (RT_LIST_UNINITIALIZED( &rt_g.rtg_vlfree ))
			RT_LIST_INIT( &rt_g.rtg_vlfree );
		RT_LIST_INIT( &vdraw_head );
d174 1
a174 1
			for (REV_RT_LIST_FOR(vp, rt_vlist, &(curhead->vhd))){
d179 1
a179 1
			if (RT_LIST_IS_HEAD(vp,&(curhead->vhd))){
d181 2
a182 2
				vp = RT_LIST_PNEXT(rt_vlist, vp);
				if (RT_LIST_IS_HEAD(vp,&(curhead->vhd))){
d184 1
a184 1
					RT_LIST_INSERT( &(curhead->vhd), &(vp->l) );
d188 2
a189 2
				vp = RT_LIST_PNEXT(rt_vlist, vp);
				if (RT_LIST_IS_HEAD(vp,&(curhead->vhd))){
d191 1
a191 1
					RT_LIST_INSERT(&(curhead->vhd),&(vp->l));
d203 1
a203 1
			for (RT_LIST_FOR(vp, rt_vlist, &(curhead->vhd)) ){
d214 1
a214 1
			if (RT_LIST_IS_HEAD(vp,&(curhead->vhd))){
d220 1
a220 1
				RT_LIST_INSERT(&(curhead->vhd),&(vp->l));
d257 1
a257 1
		for (RT_LIST_FOR(vp, rt_vlist, &(curhead->vhd)) ){
d268 1
a268 1
		if (RT_LIST_IS_HEAD(vp,&(curhead->vhd))){
d274 1
a274 1
			RT_LIST_INSERT(&(curhead->vhd),&(vp->l));
d285 1
a285 1
		vp = RT_LIST_LAST(rt_vlist, &(curhead->vhd));
d293 1
a293 1
			wp = RT_LIST_PLAST(rt_vlist,vp);
d322 1
a322 1
			for ( RT_LIST_FOR( vp, rt_vlist, &(curhead->vhd)) ){
d329 1
a329 1
			for ( REV_RT_LIST_FOR( vp, rt_vlist, &(curhead->vhd)) ){
d342 1
a342 1
		for ( RT_LIST_FOR(vp, rt_vlist, &(curhead->vhd)) ){
d364 2
a365 2
		wp = RT_LIST_PNEXT(rt_vlist, vp);
		while ( RT_LIST_NOT_HEAD(wp, &(curhead->vhd)) ){
d378 1
a378 1
			wp = RT_LIST_PNEXT(rt_vlist, vp);
d413 2
a414 2
			vp = RT_LIST_FIRST(rt_vlist, &(curhead->vhd));
			while ( !RT_LIST_IS_HEAD(vp, &(curhead->vhd)) ) {
d416 1
a416 1
				vp = RT_LIST_PNEXT(rt_vlist, vp);
d427 1
a427 1
		for ( RT_LIST_FOR(vp, rt_vlist, &(curhead->vhd)) ){
d492 1
a492 1
			for ( RT_LIST_FOR( rcp, rt_curve, &vdraw_head) ) {
d519 1
a519 1
		for ( RT_LIST_FOR( rcp, rt_curve, &vdraw_head) ) {
d527 1
a527 1
			RT_LIST_APPEND( &vdraw_head, &(rcp->l) );
d531 1
a531 1
			RT_LIST_INIT(&(rcp->vhd));
d533 1
a533 1
			RT_LIST_APPEND( &(rcp->vhd), &(vp->l) );
d539 1
a539 1
			if (RT_LIST_IS_EMPTY(&(curhead->vhd))){
d541 1
a541 1
				RT_LIST_APPEND( &(curhead->vhd), &(vp->l) );
d557 1
a557 1
			for ( RT_LIST_FOR( rcp, rt_curve, &vdraw_head) ) {
d571 1
a571 1
			for ( RT_LIST_FOR( rcp, rt_curve, &vdraw_head) ) {
d582 1
a582 1
			RT_LIST_DEQUEUE(&(rcp2->l));
d584 1
a584 1
				if ( RT_LIST_IS_EMPTY( &vdraw_head ) ){
d587 1
a587 1
					curhead = RT_LIST_LAST(rt_curve,&vdraw_head);
@


1.11
log
@removed breaks that were never reached.
@
text
@d142 1
a142 1
	struct rt_vls killstr;
d466 2
a467 2
		rt_vls_init(&killstr);
		rt_vls_printf( &killstr, "kill -f %s\n", solid_name );
d469 1
a469 1
		rt_vls_free(&killstr);
d526 1
a526 1
			GETSTRUCT( rcp, rt_curve );
d556 1
a556 1
			rt_vls_init(&killstr);
d558 2
a559 2
				rt_vls_strcat( &killstr, rcp->name);
				rt_vls_strcat( &killstr, " ");
d562 1
a562 1
			str = rt_vls_strgrab(&killstr);
d591 1
a591 1
			rt_free((char *) rcp2, "rt_curve");
@


1.10
log
@name changes
@
text
@d111 2
a112 1

d123 1
a123 1

d134 1
a134 1
	static initialized = 0;
a241 1
		break;
a310 1
		break;
a388 1
		break;
a448 1
		break;
a475 1
		break;
a564 1
			break;
a592 1
			break;
a600 1
		break;
@


1.9
log
@removed outdated options
@
text
@d7 1
a7 1
	  			  an open curve (1 yes, 0 no)
d9 3
a11 3
		name		- opens the specified curve
				  returns 1 if creating new curve
				          0 if opening an existing curve
d27 1
a27 1
		name		- change the name of the current curve
d33 1
a33 1
		name		- return name of current curve
a34 4
CURVE COMMANDS
vdraw	curve	list		- return list of all existing curves
		delete	name	- delete the named curve

d36 1
a36 1
vdraw	send			- send the current curve to the display
d40 4
d165 1
a165 1
			Tcl_AppendResult(interp, "vdraw: no curve is currently open.", (char *)NULL);
d244 1
a244 1
			Tcl_AppendResult(interp, "vdraw: no curve is currently open.", (char *)NULL);
d314 1
a314 1
			Tcl_AppendResult(interp, "vdraw: no curve is currently open.", (char *)NULL);
d393 1
a393 1
			Tcl_AppendResult(interp, "vdraw: no curve is currently open.", (char *)NULL);
d402 1
a402 1
			sprintf(result_string, "%lx", curhead->rgb);
d408 1
a408 1
			sprintf(result_string, "%s", curhead->name);
d454 1
a454 1
			Tcl_AppendResult(interp, "vdraw: no curve is currently open.", (char *)NULL);
d482 1
a482 1
			Tcl_AppendResult(interp, "vdraw: no curve is currently open.", (char *)NULL);
d495 1
a495 1
			/* check for conflicts with existing curves*/
d498 3
a500 2
					Tcl_AppendResult(interp,"-1",(char *)NULL);
					return TCL_OK;
d548 1
a548 1
			/* 0 means new entry */
d553 1
a553 1
	case 'c':
d572 1
a572 1
				Tcl_AppendResult(interp,"vdraw: need name of curve to delete", (char *)NULL);
d583 1
a583 1
				sprintf(result_string,"vdraw: curve %s not found", argv[3]);
d600 1
a600 1
			Tcl_AppendResult(interp,"vdraw: unknown option to vdraw curve", (char *)NULL);
d654 1
a654 1
cmd_vget(clientData, interp, argc, argv)
d723 1
a723 1
			"cmd_vget: invalid argument. Must be one of center,size,eye,ypr.",
d844 1
a844 1
			sprintf(result_string,"viewset: Unknown option %s.", argv[i]);
@


1.8
log
@Changed M_PI to rt_pi.
@
text
@a43 6
DEBUGGING COMMAND
vdraw	help	1		- returns the number of vlist chunks
		2	i	- prints the nused param of the i-th chunk

vdraw verbose 			-toggle verbose thing

d93 4
a96 4
#define PREFIX		"_VDRW"
#define PREFIX_LEN	6
#define MAX_NAME	31
#define DEF_COLOR	0xffff00
d105 1
a105 1
	char		name[MAX_NAME+1]; 	/* name array */
a133 1
	static int verbose = 0;
d145 2
a146 2
	static char vdraw_name[MAX_NAME+1];
	static char temp_name[MAX_NAME+1];
d148 1
a148 1
	char solid_name [MAX_NAME+PREFIX_LEN+1];
d457 2
a458 2
		sprintf(solid_name, PREFIX);
		strncat(solid_name, curhead->name, MAX_NAME);
d497 1
a497 1
				if (!strncmp( rcp->name, argv[3], MAX_NAME)) {
d503 2
a504 2
			strncpy(curhead->name, argv[3], MAX_NAME);
			curhead->name[MAX_NAME] = (char) NULL;
a508 27
	case 'h': /* help */
		if (!curhead) {
			Tcl_AppendResult(interp, "vdraw: no curve is currently open.", (char *)NULL);
			return TCL_ERROR;
		}
		if (argv[2][0]=='1'){
			uind = 0;
			for ( RT_LIST_FOR( vp, rt_vlist, &(curhead->vhd))){
				uind++;
			}
			sprintf(result_string, "%d", uind);
			Tcl_AppendResult(interp, result_string, (char *)NULL);
			return TCL_OK;
		}
		if (argv[2][0]=='2'){
			uind = 0;
			sscanf(argv[3], "%d", &index);
			for ( RT_LIST_FOR( vp, rt_vlist, &(curhead->vhd))){
				if (index==uind)
					break;
				uind ++;
			}
			sprintf(result_string, "chunk %d nused %d", index, vp->nused);
			Tcl_AppendResult(interp, result_string, (char *)NULL);
			return TCL_OK;
		}
		break;
d519 2
a520 2
		strncpy(temp_name, argv[2], MAX_NAME);
		temp_name[MAX_NAME] = (char) NULL;
d523 1
a523 1
			if (!strncmp( rcp->name, temp_name, MAX_NAME)) {
d532 2
a533 2
			rcp->name[MAX_NAME] = (char) NULL;
			rcp->rgb = DEF_COLOR;
d546 1
a546 1
			curhead->name[MAX_NAME] = (char) NULL; /*safety*/
d576 1
a576 1
				if (!strncmp(rcp->name,argv[3],MAX_NAME)){
a602 3
	case 'v':
		verbose = (verbose + 1)%2;
		break;
d604 1
a604 1
		Tcl_AppendResult(interp, "vdraw: see drawline.c for help\n", (char *)NULL);
d695 1
a695 1
		VSCALE(temp, temp, 180.0/rt_pi);	
d707 1
a707 1
		VSCALE(temp, temp, 180.0/rt_pi);	
@


1.7
log
@reworked to keep dynamic list of curves in memory, rather than
reading pseudosolids
@
text
@d732 1
a732 1
		VSCALE(temp, temp, 180.0/M_PI);	
d744 1
a744 1
		VSCALE(temp, temp, 180.0/M_PI);	
@


1.6
log
@switched to anim_dirn2mat rather than anim_dirz2mat.
@
text
@d3 1
a3 1
CMD_VDRAW - edit, query, and display a vector list as a pseudosolid
d6 2
a7 4
vdraw	open	name		- select the current pseudo-solid
				  returns 1 if creating new pseudo-solid
				          0 if reading an existing solid vlist
					  -1 if solid not opened (see *)
d9 4
a12 1

d27 1
a27 1
		name		- change the name of the current pseudosolid
d33 5
a37 1
		name		- return name of current pseudo-solid
d40 1
a40 1
vdraw	send			- send the current list to the display
a67 7
* note - if name is an existing displayed solid, vdraw will read its 
vector list. It can be edited like any list, but can't be sent until
the name is changed.
	open will fail non-destructively (-1) if a solid exists but is 
not displayed.


a97 1
static struct rt_list head;
d99 3
a101 1
#define MAX_NAME	30
d108 10
d137 2
d141 1
d152 2
a153 2
	static char vdraw_name[MAX_NAME];
	static char temp_name[MAX_NAME];
d155 1
d164 2
a165 6
		RT_LIST_INIT( &head );
		RT_GET_VLIST(vp);
		RT_LIST_APPEND( &head, &(vp->l) );
		strncpy(vdraw_name, def_name, MAX_NAME);
		my_rgb = DEF_COLOR;
		real_flag = 0;
a168 6
	/* following code assumes list non-empty */
	if (RT_LIST_IS_EMPTY(&head)){
		RT_GET_VLIST(vp);
		RT_LIST_APPEND( &head, &(vp->l) );
	}

d171 4
d180 1
a180 1
			for (REV_RT_LIST_FOR(vp, rt_vlist, &head)){
d185 1
a185 1
			if (RT_LIST_IS_HEAD(vp,&head)){
d188 1
a188 1
				if (RT_LIST_IS_HEAD(vp,&head)){
d190 1
a190 1
					RT_LIST_INSERT( &head, &(vp->l) );
d195 1
a195 1
				if (RT_LIST_IS_HEAD(vp,&head)){
d197 1
a197 1
					RT_LIST_INSERT(&head,&(vp->l));
d209 1
a209 1
			for (RT_LIST_FOR(vp, rt_vlist, &head) ){
d220 1
a220 1
			if (RT_LIST_IS_HEAD(vp,&head)){
d226 1
a226 1
				RT_LIST_INSERT(&head,&(vp->l));
d250 4
d264 1
a264 1
		for (RT_LIST_FOR(vp, rt_vlist, &head) ){
d275 1
a275 1
		if (RT_LIST_IS_HEAD(vp,&head)){
d281 1
a281 1
			RT_LIST_INSERT(&head,&(vp->l));
d292 1
a292 1
		vp = RT_LIST_LAST(rt_vlist, &head);
d320 4
d330 1
a330 1
			for ( RT_LIST_FOR( vp, rt_vlist, &head) ){
d337 1
a337 1
			for ( REV_RT_LIST_FOR( vp, rt_vlist, &head) ){
d350 1
a350 1
		for ( RT_LIST_FOR(vp, rt_vlist, &head) ){
d373 1
a373 1
		while ( RT_LIST_NOT_HEAD(wp, &head) ){
d399 4
d409 1
a409 1
			sprintf(result_string, "%lx", my_rgb);
d415 2
a416 1
			Tcl_AppendResult(interp, vdraw_name, (char *)NULL);
d422 2
a423 2
			vp = RT_LIST_FIRST(rt_vlist, &head);
			while ( !RT_LIST_IS_HEAD(vp, &head) ) {
d436 1
a436 1
		for ( RT_LIST_FOR(vp, rt_vlist, &head) ){
d460 7
a466 1
		if (( dp = db_lookup( dbip, vdraw_name, LOOKUP_QUIET )) == DIR_NULL ) {
d477 1
a477 1
		rt_vls_printf( &killstr, "kill -f %s*\n", vdraw_name );
d481 1
a481 3
		if (verbose)
			my_final_check(&head);
		index = invent_solid( vdraw_name, &head, my_rgb, 1);
d488 4
d498 1
a498 1
				my_rgb = rgb;
d502 11
a512 1
			strncpy(vdraw_name, argv[3], MAX_NAME);
d517 4
d523 1
a523 1
			for ( RT_LIST_FOR( vp, rt_vlist, &head)){
d533 1
a533 1
			for ( RT_LIST_FOR( vp, rt_vlist, &head)){
a543 1
		
d545 16
a560 3
			strncpy(temp_name, def_name, MAX_NAME);
		} else {
			strncpy(temp_name, argv[2], MAX_NAME);
d562 7
a568 4
		if ( (dp = db_lookup( dbip, temp_name, LOOKUP_QUIET))== DIR_NULL ) {
			/* release old list */
			RT_FREE_VLIST( &head);
			/* initialize new list */
d570 3
a572 5
			RT_LIST_INIT( &head );
			RT_LIST_APPEND( &head, &(vp->l) );
			my_rgb = DEF_COLOR;
			/* new pseudo-solid created */
			strncpy(vdraw_name, temp_name, MAX_NAME);
d575 38
a612 9
		} else {
			found = 0;
			FOR_ALL_SOLIDS( sp ) {
				int j;
				for ( j = sp->s_last; j>=0; j--) {
					if (sp->s_path[j] == dp) {
						found = 1;
						break;
					}
d614 5
a618 2
				if (found)
					break;
d620 7
a626 4
			if (!found) {
				/* solid exists but is not displayed */
				Tcl_AppendResult(interp, "-1", (char *)NULL);
				return TCL_OK;
d628 2
a629 12
			/* release old list */
			RT_FREE_VLIST( &head);
			/* get copy of new list */
			rt_vlist_copy( &head   , &(sp->s_vlist));

			my_rgb = ((sp->s_color[0])<<16) |
				  ((sp->s_color[1])<<8) |
				       (sp->s_color[2]);

			/* existing displayed solid used */
			strncpy(vdraw_name, temp_name, MAX_NAME);
			Tcl_AppendResult(interp, "0", (char *)NULL);
d631 4
@


1.5
log
@added return value to viewset
@
text
@d626 1
a626 1
		sprintf(result_string,"%.12e %.12e %.12e", pos[0], pos[1], pos[2]);
d631 1
a631 1
		sprintf(result_string,"%.12e", Viewscale * 2.0);
d637 1
a637 1
		sprintf(result_string,"%.12e %.12e %.12e",pos[0],pos[1],pos[2]);
d649 1
a649 1
		sprintf(result_string,"%.12e %.12e %.12e",temp[0],temp[1],temp[2]);
d665 1
a665 1
		sprintf(result_string,"%.12e %.12e %.12e",temp[0],temp[1],temp[2]);
d670 1
a670 1
		sprintf(result_string,"%.12e %.12e %.12e %.12e", quat[0],quat[1],quat[2],quat[3]);
d696 1
a696 1
	vect_t dir, dirz, temp;
d828 3
a830 14
		/* use current vehicle z-dir as backup */
		VSET(temp, 0.0, 1.0, 0.0);
		mat_trn( mymat, Viewrot);
		MAT4X3PNT( dirz, mymat, temp);
		if ((fabs(dirz[0]) < VDIVIDE_TOL)&&(fabs(dirz[1])<VDIVIDE_TOL)){
			/* or use vehicle -x as backup */
			if ( dir[2] >= 0.0) {
				VSET(temp, 0.0, 0.0, 1.0);
			} else {
				VSET(temp, 0.0, 0.0, -1.0);
			}
			MAT4X3PNT( dirz, mymat, temp);
		}
		anim_dirz2mat(mymat, dir, dirz);
@


1.4
log
@added vget and viewset
@
text
@d857 3
@


1.3
log
@verbose option for debugging
@
text
@d604 254
@


1.2
log
@convert commands to Tcl
@
text
@d43 2
d109 12
d129 1
d455 2
d552 3
@


1.1
log
@Initial revision
@
text
@d130 2
a131 4
	if (argc < 2) {
		Tcl_SetResult(interp, "vdraw: need a function name\n", TCL_STATIC);
		return TCL_ERROR;
	}
d154 1
a154 1
			Tcl_SetResult(interp, "vdraw: not enough args\n", TCL_STATIC);
d181 1
a181 1
			Tcl_SetResult(interp, "vdraw: write index not an integer\n", TCL_STATIC);
d200 1
a200 1
					Tcl_SetResult(interp, "vdraw: write out of range\n", TCL_STATIC);
d207 1
a207 1
				Tcl_SetResult(interp, "vdraw: write out of range\n", TCL_STATIC);
d215 1
a215 1
			Tcl_SetResult(interp, "vdraw: cmd not an integer\n", TCL_STATIC);
d229 1
a229 1
			Tcl_SetResult(interp, "vdraw: not enough args", TCL_STATIC);
d233 1
a233 1
			Tcl_SetResult(interp, "vdraw: insert index not an integer\n", TCL_STATIC);
d251 1
a251 1
				Tcl_SetResult(interp, "vdraw: insert out of range\n", TCL_STATIC);
d258 1
a258 1
			Tcl_SetResult(interp, "vdraw: insert out of range\n", TCL_STATIC);
d285 1
a285 1
			Tcl_SetResult(interp, "vdraw: cmd not an integer\n", TCL_STATIC);
d295 1
a295 1
			Tcl_SetResult(interp, "vdraw: not enough args\n", TCL_STATIC);
d316 1
a316 1
			Tcl_SetResult(interp, "vdraw: delete index not an integer\n", TCL_STATIC);
d333 1
a333 1
			Tcl_SetResult(interp, "vdraw: delete out of range\n", TCL_STATIC);
d361 1
a361 1
			Tcl_SetResult(interp, "vdraw: vlist corrupt", TCL_STATIC);
d370 1
a370 1
			Tcl_SetResult(interp, "vdraw: need index to read\n", TCL_STATIC);
d376 1
a376 1
			Tcl_SetResult(interp, result_string, TCL_VOLATILE);
d381 1
a381 1
			Tcl_SetResult(interp, vdraw_name, TCL_VOLATILE);
d393 1
a393 1
			Tcl_SetResult(interp, result_string, TCL_VOLATILE);
d397 1
a397 1
			Tcl_SetResult(interp, "vdraw: read index not an integer\n", TCL_STATIC);
d414 1
a414 1
			Tcl_SetResult(interp, "vdraw: read out of range\n", TCL_STATIC);
d421 1
a421 1
		Tcl_SetResult(interp, result_string, TCL_VOLATILE);
d432 1
a432 1
			Tcl_SetResult(interp, "-1", TCL_STATIC);
d443 1
a443 1
		Tcl_SetResult(interp, result_string, TCL_VOLATILE);
d448 1
a448 1
			Tcl_SetResult(interp, "vdraw: need params to set\n", TCL_STATIC);
d468 1
a468 1
			Tcl_SetResult(interp, result_string, TCL_VOLATILE);
d480 1
a480 1
			Tcl_SetResult(interp, result_string, TCL_VOLATILE);
d501 1
a501 1
			Tcl_SetResult(interp, "1", TCL_STATIC);
d518 1
a518 1
				Tcl_SetResult(interp, "-1", TCL_VOLATILE);
d532 1
a532 1
			Tcl_SetResult(interp, "0", TCL_STATIC);
d537 1
a537 1
		Tcl_SetResult(interp, "vdraw: see drawline.c for help\n", TCL_STATIC);
d556 3
d561 1
a561 1
	Tcl_SetResult(interp, result_string, TCL_VOLATILE);
d576 3
d580 1
a580 1
	Tcl_SetResult(interp, result_string, TCL_VOLATILE);
@
