head	11.35;
access;
symbols
	ansi-20040405-merged:11.30.2.4
	postmerge-20040405-ansi:11.33
	premerge-20040404-ansi:11.32
	postmerge-autoconf:11.32
	autoconf-freeze:11.30.10.3
	premerge-autoconf:11.32
	postmerge-20040315-windows:11.32
	premerge-20040315-windows:11.31
	windows-20040315-freeze:11.30.4.2
	autoconf-20031203:11.30
	autoconf-20031202:11.30
	autoconf-branch:11.30.0.10
	phong-branch:11.30.0.8
	photonmap-branch:11.30.0.6
	rel-6-1-DP:11.30
	windows-branch:11.30.0.4
	rel-6-0-2:11.28
	ansi-branch:11.30.0.2
	rel-6-0-1-branch:11.28.0.2
	hartley-6-0-post:11.29
	hartley-6-0-pre:11.28
	rel-6-0-1:11.28
	rel-6-0:11.27
	rel-5-4:11.21
	offsite-5-3-pre:11.24
	rel-5-3:11.21
	rel-5-2:11.21
	rel-5-1-branch:11.21.0.2
	rel-5-1:11.21
	rel-5-0:11.20
	rel-5-0-beta:11.18
	rel-4-5:11.15
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.14
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.3;
locks; strict;
comment	@ * @;


11.35
date	2004.05.21.17.47.50;	author morrison;	state dead;
branches;
next	11.34;

11.34
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.33;

11.33
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2004.03.16.21.15.12;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2002.08.20.17.08.26;	author jra;	state Exp;
branches
	11.30.2.1
	11.30.4.1
	11.30.10.1;
next	11.29;

11.29
date	2002.08.15.20.55.38;	author hartley;	state Exp;
branches;
next	11.28;

11.28
date	2002.06.18.14.28.15;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2001.11.05.21.20.07;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.08.14.18.26.06;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	2001.04.03.19.01.59;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	2000.09.07.02.58.52;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.08.19.03.10.49;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.06.28.16.59.17;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	99.12.28.19.43.11;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	99.09.01.18.55.11;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	99.08.05.20.17.02;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.02.24.14.19.33;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	99.02.08.16.32.59;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	98.11.06.22.32.43;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	97.03.25.14.44.26;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.02.28.21.45.05;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.23.18.19.41;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.21.13.59.15;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.03.22.18.32.45;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.03.01.19.27.28;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.12.27.22.34.34;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.06;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.38;	author mike;	state Rel4_4;
branches;
next	10.10;

10.10
date	94.12.16.19.37.23;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.11.05.03.49.47;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.10.17.12.47.55;	author jra;	state Exp;
branches;
next	10.7;

10.7
date	94.09.02.00.23.57;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.30.14.10.59;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.08.23.18.28.45;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.06.03.19.07.23;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.06.03.17.33.57;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	91.12.18.07.46.16;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.20;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.10.11.11.33.02;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	91.01.12.08.03.39;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.21.06.06.16;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.57;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.03.07.00.15.27;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.02.32.45;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.24;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.03.02.23.20.24;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.01.13.16.38.26;	author stay;	state Exp;
branches;
next	7.3;

7.3
date	87.11.14.05.02.33;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.54;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.01.55;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.05.21;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.22.13;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.13.05;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.23.05;	author mike;	state Rel1;
branches;
next	2.6;

2.6
date	86.10.21.02.49.39;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	86.08.13.00.08.47;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.08.12.06.50.48;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.08.07.05.19.51;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.14.05.04.41;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.57.06;	author mike;	state Prod;
branches;
next	1.6;

1.6
date	85.03.08.20.54.03;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.02.01.19.51.58;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.02.01.00.51.17;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.01.16.01.58.42;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.04.25.34;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.17.05.38.13;	author mike;	state Exp;
branches;
next	;

11.30.2.1
date	2002.09.19.18.02.04;	author morrison;	state Exp;
branches;
next	11.30.2.2;

11.30.2.2
date	2003.01.31.00.11.55;	author morrison;	state Exp;
branches;
next	11.30.2.3;

11.30.2.3
date	2003.02.02.06.12.45;	author morrison;	state Exp;
branches;
next	11.30.2.4;

11.30.2.4
date	2004.03.17.21.22.04;	author morrison;	state Exp;
branches;
next	;

11.30.4.1
date	2002.09.26.23.04.13;	author morrison;	state Exp;
branches;
next	11.30.4.2;

11.30.4.2
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

11.30.10.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	11.30.10.2;

11.30.10.2
date	2004.03.15.14.07.41;	author erikg;	state Exp;
branches;
next	11.30.10.3;

11.30.10.3
date	2004.03.18.18.10.31;	author erikg;	state Exp;
branches;
next	;


desc
@Routine to invoke a text editor on the parameters of a solid,
for the ultimate in fine control.
@


11.35
log
@moved to src/mged/
@
text
@/*
 *  			T E D I T . C
 *
 * Functions -
 *	f_tedit		Run text editor on numerical parameters of solid
 *	writesolid	Write numerical parameters of solid into a file
 *	readsolid	Read numerical parameters of solid from file
 *	editit		Run $EDITOR on temp file
 *
 *  Author -
 *	Michael John Muuss
 *	(Inspired by 4.2 BSD program "vipw")
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/tedit.c,v 11.34 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <signal.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "externs.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "./ged.h"
#include "./sedit.h"
#include "./mged_dm.h"

#define LINELEN		256	/* max length of input line */
#define	DEFEDITOR	"/bin/ed"
#define V3BASE2LOCAL( _pt )	(_pt)[X]*base2local , (_pt)[Y]*base2local , (_pt)[Z]*base2local
#define V4BASE2LOCAL( _pt )	(_pt)[X]*base2local , (_pt)[Y]*base2local , (_pt)[Z]*base2local , (_pt)[W]*base2local

extern struct rt_db_internal	es_int;
extern struct rt_db_internal	es_int_orig;

static char	tmpfil[17];
#ifndef WIN32
static char	*tmpfil_init = "/tmp/GED.aXXXXXX";
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif

int writesolid(void), readsolid(void);
int editit(const char *file);

int
f_tedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 1 || 1 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help ted");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* Only do this if in solid edit state */
	if( not_state( ST_S_EDIT, "Primitive Text Edit" ) )
	  return TCL_ERROR;

	strcpy(tmpfil, tmpfil_init);
#ifdef WIN32
	(void)mktemp(tmpfil);
	i=creat(tmpfil, 0600);
#else
	i = mkstemp(tmpfil);
#endif
	if( i < 0 )
	{
	  perror(tmpfil);
	  return TCL_ERROR;
	}
	(void)close(i);

	if( writesolid() )
	{
	  (void)unlink(tmpfil);
	  return TCL_ERROR;
	}

	if( editit( tmpfil ) )
	{
		if( readsolid() )
		{
		  (void)unlink(tmpfil);
		  return TCL_ERROR;
		}

		/* Update the display */
		replot_editing_solid();
		view_state->vs_flag = 1;
		Tcl_AppendResult(interp, "done\n", (char *)NULL);
	}
	(void)unlink(tmpfil);

	return TCL_OK;
}

/* Write numerical parameters of a solid into a file */
int
writesolid(void)
{
	register int i;
	FILE *fp;

	CHECK_DBI_NULL;

	fp = fopen(tmpfil, "w");

	/* Print solid parameters, 1 vector or point per line */
	switch( es_int.idb_type )
	{
		struct rt_tor_internal *tor;
		struct rt_tgc_internal *tgc;
		struct rt_ell_internal *ell;
		struct rt_arb_internal *arb;
		struct rt_half_internal *haf;
		struct rt_grip_internal *grip;
		struct rt_rpc_internal *rpc;
		struct rt_rhc_internal *rhc;
		struct rt_epa_internal *epa;
		struct rt_ehy_internal *ehy;
		struct rt_eto_internal *eto;
		struct rt_part_internal *part;
		struct rt_superell_internal *superell;

		default:
		  Tcl_AppendResult(interp, "Cannot text edit this solid type\n", (char *)NULL);
		  (void)fclose(fp);
		  return( 1 );
		case ID_TOR:
			tor = (struct rt_tor_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( tor->v ) );
			(void)fprintf( fp , "Normal: %.9f %.9f %.9f\n", V3BASE2LOCAL( tor->h ) );
			(void)fprintf( fp , "radius_1: %.9f\n", tor->r_a*base2local );
			(void)fprintf( fp , "radius_2: %.9f\n", tor->r_h*base2local );
			break;
		case ID_TGC:
		case ID_REC:
			tgc = (struct rt_tgc_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->v ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->h ) );
			(void)fprintf( fp , "A: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->a ) );
			(void)fprintf( fp , "B: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->b ) );
			(void)fprintf( fp , "C: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->c ) );
			(void)fprintf( fp , "D: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->d ) );
			break;
		case ID_ELL:
		case ID_SPH:
			ell = (struct rt_ell_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( ell->v ) );
			(void)fprintf( fp , "A: %.9f %.9f %.9f\n", V3BASE2LOCAL( ell->a ) );
			(void)fprintf( fp , "B: %.9f %.9f %.9f\n", V3BASE2LOCAL( ell->b ) );
			(void)fprintf( fp , "C: %.9f %.9f %.9f\n", V3BASE2LOCAL( ell->c ) );
			break;
		case ID_ARB8:
			arb = (struct rt_arb_internal *)es_int.idb_ptr;
			for( i=0 ; i<8 ; i++ )
				(void)fprintf( fp , "pt[%d]: %.9f %.9f %.9f\n", i+1 , V3BASE2LOCAL( arb->pt[i] ) );
			break;
		case ID_HALF:
			haf = (struct rt_half_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Plane: %.9f %.9f %.9f %.9f\n" , V4BASE2LOCAL( haf->eqn ) );
			break;
		case ID_GRIP:
			grip = (struct rt_grip_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Center: %.9f %.9f %.9f\n" , V3BASE2LOCAL( grip->center ) );
			(void)fprintf( fp , "Normal: %.9f %.9f %.9f\n" , V3BASE2LOCAL( grip->normal ) );
			(void)fprintf( fp , "Magnitude: %.9f\n" , grip->mag*base2local );
			break;
		case ID_PARTICLE:
			part = (struct rt_part_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( part->part_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( part->part_H ) );
			(void)fprintf( fp , "v radius: %.9f\n", part->part_vrad * base2local );
			(void)fprintf( fp , "h radius: %.9f\n", part->part_hrad * base2local );
			break;
		case ID_RPC:
			rpc = (struct rt_rpc_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rpc->rpc_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rpc->rpc_H ) );
			(void)fprintf( fp , "Breadth: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rpc->rpc_B ) );
			(void)fprintf( fp , "Half-width: %.9f\n" , rpc->rpc_r * base2local );
			break;
		case ID_RHC:
			rhc = (struct rt_rhc_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rhc->rhc_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rhc->rhc_H ) );
			(void)fprintf( fp , "Breadth: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rhc->rhc_B ) );
			(void)fprintf( fp , "Half-width: %.9f\n" , rhc->rhc_r * base2local );
			(void)fprintf( fp , "Dist_to_asymptotes: %.9f\n" , rhc->rhc_c * base2local );
			break;
		case ID_EPA:
			epa = (struct rt_epa_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( epa->epa_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( epa->epa_H ) );
			(void)fprintf( fp , "Semi-major axis: %.9f %.9f %.9f\n" , V3ARGS( epa->epa_Au ) );
			(void)fprintf( fp , "Semi-major length: %.9f\n" , epa->epa_r1 * base2local );
			(void)fprintf( fp , "Semi-minor length: %.9f\n" , epa->epa_r2 * base2local );
			break;
		case ID_EHY:
			ehy = (struct rt_ehy_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( ehy->ehy_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( ehy->ehy_H ) );
			(void)fprintf( fp , "Semi-major axis: %.9f %.9f %.9f\n" , V3ARGS( ehy->ehy_Au ) );
			(void)fprintf( fp , "Semi-major length: %.9f\n" , ehy->ehy_r1 * base2local );
			(void)fprintf( fp , "Semi-minor length: %.9f\n" , ehy->ehy_r2 * base2local );
			(void)fprintf( fp , "Dist to asymptotes: %.9f\n" , ehy->ehy_c * base2local );
			break;
		case ID_ETO:
			eto = (struct rt_eto_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( eto->eto_V ) );
			(void)fprintf( fp , "Normal: %.9f %.9f %.9f\n" , V3BASE2LOCAL( eto->eto_N ) );
			(void)fprintf( fp , "Semi-major axis: %.9f %.9f %.9f\n" , V3BASE2LOCAL( eto->eto_C ) );
			(void)fprintf( fp , "Semi-minor length: %.9f\n" , eto->eto_rd * base2local );
			(void)fprintf( fp , "Radius of roation: %.9f\n" , eto->eto_r * base2local );
			break;
		case ID_SUPERELL:
			superell = (struct rt_superell_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->v ) );
			(void)fprintf( fp , "A: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->a ) );
			(void)fprintf( fp , "B: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->b ) );
			(void)fprintf( fp , "C: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->c ) );
			(void)fprintf( fp , "<n,e>: <%.9f, %.9f>\n", superell->n, superell->e);
			break;
	}
	
	(void)fclose(fp);
	return( 0 );
}

static char *
Get_next_line(FILE *fp)
{
	static char line[LINELEN];
	int i;
	int len;

	if( fgets( line , sizeof( line ) , fp ) == NULL )
		return( (char *)NULL );

	len = strlen( line );

	i = 0;
	while( i<len && line[i++] != ':' );

	if( i == len || line[i] == '\0' )
		return( (char *)NULL );

	return( &line[i] );
}

/* Read numerical parameters of solid from file */
int
readsolid(void)
{
	register int i;
	FILE *fp;
	int ret_val=0;

	CHECK_DBI_NULL;

	fp = fopen(tmpfil, "r");
	if( fp == NULL )  {
		perror(tmpfil);
		return 1;	/* FAIL */
	}

	switch( es_int.idb_type )
	{
		struct rt_tor_internal *tor;
		struct rt_tgc_internal *tgc;
		struct rt_ell_internal *ell;
		struct rt_arb_internal *arb;
		struct rt_half_internal *haf;
		struct rt_grip_internal *grip;
		struct rt_rpc_internal *rpc;
		struct rt_rhc_internal *rhc;
		struct rt_epa_internal *epa;
		struct rt_ehy_internal *ehy;
		struct rt_eto_internal *eto;
		struct rt_part_internal *part;
		struct rt_superell_internal *superell;
		char *str;
		double a,b,c,d;

		default:
		  Tcl_AppendResult(interp, "Cannot text edit this solid type\n", (char *)NULL);
		  ret_val = 1;
		  break;
		case ID_TOR:
			tor = (struct rt_tor_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tor->v , a , b , c );
			VSCALE( tor->v , tor->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tor->h , a , b , c );
			VUNITIZE( tor->h );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			tor->r_a = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			tor->r_h = a * local2base;
			break;
		case ID_TGC:
		case ID_REC:
			tgc = (struct rt_tgc_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->v , a , b , c );
			VSCALE( tgc->v , tgc->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->h , a , b , c );
			VSCALE( tgc->h , tgc->h , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->a , a , b , c );
			VSCALE( tgc->a , tgc->a , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->b , a , b , c );
			VSCALE( tgc->b , tgc->b , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->c , a , b , c );
			VSCALE( tgc->c , tgc->c , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->d , a , b , c );
			VSCALE( tgc->d , tgc->d , local2base );

			break;
		case ID_ELL:
		case ID_SPH:
			ell = (struct rt_ell_internal *)es_int.idb_ptr;

			fprintf(stderr, "ID_SPH\n");

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ell->v , a , b , c );
			VSCALE( ell->v , ell->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ell->a , a , b , c );
			VSCALE( ell->a , ell->a , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ell->b , a , b , c );
			VSCALE( ell->b , ell->b , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ell->c , a , b , c );
			VSCALE( ell->c , ell->c , local2base );
			break;
		case ID_ARB8:
			arb = (struct rt_arb_internal *)es_int.idb_ptr;
			for( i=0 ; i<8 ; i++ )
			{
				if( (str=Get_next_line( fp )) == NULL )
				{
					ret_val = 1;
					break;
				}
				(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
				VSET( arb->pt[i] , a , b , c );
				VSCALE( arb->pt[i] , arb->pt[i] , local2base );
			}
			break;
		case ID_HALF:
			haf = (struct rt_half_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf %lf" , &a , &b , &c , &d );
			VSET( haf->eqn , a , b , c );
			haf->eqn[W] = d * local2base;
			break;
		case ID_GRIP:
			grip = (struct rt_grip_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( grip->center , a , b , c );
			VSCALE( grip->center , grip->center , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( grip->normal , a , b , c );
			break;
		case ID_PARTICLE:
			part = (struct rt_part_internal *)es_int.idb_ptr;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( part->part_V , a , b , c );
			VSCALE( part->part_V , part->part_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( part->part_H , a , b , c );
			VSCALE( part->part_H , part->part_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			part->part_vrad = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			part->part_hrad = a * local2base;

			break;
		case ID_RPC:
			rpc = (struct rt_rpc_internal *)es_int.idb_ptr;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rpc->rpc_V , a , b , c );
			VSCALE( rpc->rpc_V , rpc->rpc_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rpc->rpc_H , a , b , c );
			VSCALE( rpc->rpc_H , rpc->rpc_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rpc->rpc_B , a , b , c );
			VSCALE( rpc->rpc_B , rpc->rpc_B , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			rpc->rpc_r = a * local2base;
			break;
		case ID_RHC:
			rhc = (struct rt_rhc_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rhc->rhc_V , a , b , c );
			VSCALE( rhc->rhc_V , rhc->rhc_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rhc->rhc_H , a , b , c );
			VSCALE( rhc->rhc_H , rhc->rhc_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rhc->rhc_B , a , b , c );
			VSCALE( rhc->rhc_B , rhc->rhc_B , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			rhc->rhc_r = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			rhc->rhc_c = a * local2base;
			break;
		case ID_EPA:
			epa = (struct rt_epa_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( epa->epa_V , a , b , c );
			VSCALE( epa->epa_V , epa->epa_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( epa->epa_H , a , b , c );
			VSCALE( epa->epa_H , epa->epa_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( epa->epa_Au , a , b , c );
			VUNITIZE( epa->epa_Au );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			epa->epa_r1 = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			epa->epa_r2 = a * local2base;
			break;
		case ID_EHY:
			ehy = (struct rt_ehy_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ehy->ehy_V , a , b , c );
			VSCALE( ehy->ehy_V , ehy->ehy_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ehy->ehy_H , a , b , c );
			VSCALE( ehy->ehy_H , ehy->ehy_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ehy->ehy_Au , a , b , c );
			VUNITIZE( ehy->ehy_Au );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			ehy->ehy_r1 = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			ehy->ehy_r2 = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			ehy->ehy_c = a * local2base;
			break;
		case ID_ETO:
			eto = (struct rt_eto_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( eto->eto_V , a , b , c );
			VSCALE( eto->eto_V , eto->eto_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( eto->eto_N , a , b , c );
			VUNITIZE( eto->eto_N );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( eto->eto_C , a , b , c );
			VSCALE( eto->eto_C , eto->eto_C , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			eto->eto_rd = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			eto->eto_r = a * local2base;
			break;
		case ID_SUPERELL:
			superell = (struct rt_superell_internal *)es_int.idb_ptr;

			fprintf(stderr, "ID_SUPERELL\n");

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->v , a , b , c );
			VSCALE( superell->v , superell->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->a , a , b , c );
			VSCALE( superell->a , superell->a , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->b , a , b , c );
			VSCALE( superell->b , superell->b , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->c , a , b , c );
			VSCALE( superell->c , superell->c , local2base );
			
			if ( (str=Get_next_line( fp )) == NULL ) {
			  ret_val = 1;
			  break;
			}
			(void) sscanf( str, "%lf %lf", &superell->n, &superell->e);
			break;	
	}

	(void)fclose(fp);
	return( ret_val );
}


#ifdef WIN32

/* Run $EDITOR on temp file */
editit( file )
const char *file;
{
   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   char line[1024];

   sprintf(line,"notepad %s",file);

   
      si.cb = sizeof(STARTUPINFO);
      si.lpReserved = NULL;
      si.lpReserved2 = NULL;
      si.cbReserved2 = 0;
      si.lpDesktop = NULL;
      si.dwFlags = 0;

      CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     NORMAL_PRIORITY_CLASS,
                     NULL,
                     NULL,
                     &si,
                     &pi );
      WaitForSingleObject( pi.hProcess, INFINITE );
   
	return 1;
}

#else
/* else win32 is not defined */

/* Run $EDITOR on temp file 
 * 
 * BUGS -- right now we only check at compile time whether or not to pop up an
 *         X window to display into (for editors that do not open their own
 *         window like vi or jove).  If we have X support, we automatically use
 *         xterm (regardless of whether the user is running mged in console
 *         mode!)
 */
int
editit(const char *file)
{
	register int pid, xpid;
	register char *ed;
	int stat;
	void (*s2)(), (*s3)();

	if ((ed = getenv("EDITOR")) == (char *)0)
		ed = DEFEDITOR;
	bu_log("Invoking %s %s\n", ed, file);

	s2 = signal( SIGINT, SIG_IGN );
	s3 = signal( SIGQUIT, SIG_IGN );
	if ((pid = fork()) < 0) {
		perror("fork");
		return (0);
	}
	if (pid == 0) {
		register int i;
		/* Don't call bu_log() here in the child! */

		/* XXX do not want to close all io if we are in console mode
		 * and the editor needs to use stdout...
		 */
#	if defined(DM_X) || defined(DM_OGL)
		/* close all stdout/stderr (XXX except do not close 0==stdin) */
		for( i=1; i < 20; i++ )
			(void)close(i);
#	else
		/* leave stdin/out/err alone */
		for( i=3; i < 20; i++ )
			(void)close(i);
#	endif

		(void)signal( SIGINT, SIG_DFL );
		(void)signal( SIGQUIT, SIG_DFL );

		/* if we have x support, we pop open the editor in an xterm.
		 * otherwise, we use whatever the user gave as EDITOR
		 */
#	if defined(DM_X) || defined(DM_OGL)
		(void)execlp("xterm", "xterm", "-e", ed, file, (char *)0);
#	else
		(void)execlp(ed, ed, file, 0);
#	endif
		perror(ed);
		exit(1);
	}


	while ((xpid = wait(&stat)) >= 0)
		if (xpid == pid)
			break;

	(void)signal(SIGINT, s2);
	(void)signal(SIGQUIT, s3);

	return (!stat);
}
#endif
/* end check if win32 defined */
@


11.34
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/tedit.c,v 11.33 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.33
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 5
a31 1
#include "conf.h"
@


11.32
log
@merge of windows-6-0-branch into head
@
text
@d62 2
a63 2
int writesolid(), readsolid();
int editit();
d66 1
a66 5
f_tedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d127 1
a127 1
writesolid()
d151 1
d244 8
d259 1
a259 2
Get_next_line( fp )
FILE *fp;
d281 1
a281 1
readsolid()
d309 1
d415 2
d761 47
@


11.31
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.30 2002/08/20 17:08:26 jra Exp $ (BRL)";
d56 1
d58 3
d92 1
a92 1
#if 0
d760 39
d832 1
a832 1
#if defined(DM_X) || defined(DM_OGL)
d836 1
a836 1
#else
d840 1
a840 1
#endif
d848 1
a848 1
#if defined(DM_X) || defined(DM_OGL)
d850 1
a850 1
#else
d852 1
a852 1
#endif
d867 2
@


11.30
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.28 2002/06/18 14:28:15 morrison Exp $ (BRL)";
@


11.30.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.31 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.30.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.30.10.1 2004/02/12 18:34:16 erikg Exp $ (BRL)";
@


11.30.10.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a55 1
#ifndef WIN32
a56 3
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif
d88 1
a88 1
#ifdef WIN32
a755 39

#ifdef WIN32

/* Run $EDITOR on temp file */
editit( file )
const char *file;
{
   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   char line[1024];

   sprintf(line,"notepad %s",file);

   
      si.cb = sizeof(STARTUPINFO);
      si.lpReserved = NULL;
      si.lpReserved2 = NULL;
      si.cbReserved2 = 0;
      si.lpDesktop = NULL;
      si.dwFlags = 0;

      CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     NORMAL_PRIORITY_CLASS,
                     NULL,
                     NULL,
                     &si,
                     &pi );
      WaitForSingleObject( pi.hProcess, INFINITE );
   
	return 1;
}

#else
/* else win32 is not defined */

d789 1
a789 1
#	if defined(DM_X) || defined(DM_OGL)
d793 1
a793 1
#	else
d797 1
a797 1
#	endif
d805 1
a805 1
#	if defined(DM_X) || defined(DM_OGL)
d807 1
a807 1
#	else
d809 1
a809 1
#	endif
a823 2
#endif
/* end check if win32 defined */
@


11.30.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.30 2002/08/20 17:08:26 jra Exp $ (BRL)";
a55 1
#ifndef WIN32
a56 3
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif
d88 1
a88 1
#ifdef WIN32
a755 39

#ifdef WIN32

/* Run $EDITOR on temp file */
editit( file )
const char *file;
{
   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   char line[1024];

   sprintf(line,"notepad %s",file);

   
      si.cb = sizeof(STARTUPINFO);
      si.lpReserved = NULL;
      si.lpReserved2 = NULL;
      si.cbReserved2 = 0;
      si.lpDesktop = NULL;
      si.dwFlags = 0;

      CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     NORMAL_PRIORITY_CLASS,
                     NULL,
                     NULL,
                     &si,
                     &pi );
      WaitForSingleObject( pi.hProcess, INFINITE );
   
	return 1;
}

#else
/* else win32 is not defined */

d789 1
a789 1
#	if defined(DM_X) || defined(DM_OGL)
d793 1
a793 1
#	else
d797 1
a797 1
#	endif
d805 1
a805 1
#	if defined(DM_X) || defined(DM_OGL)
d807 1
a807 1
#	else
d809 1
a809 1
#	endif
a823 2
#endif
/* end check if win32 defined */
@


11.30.4.2
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/tedit.c,v 11.30.4.1 2002/09/26 23:04:13 morrison Exp $ (BRL)";
@


11.30.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.30 2002/08/20 17:08:26 jra Exp $ (BRL)";
d58 2
a59 2
int writesolid(void), readsolid(void);
int editit(const char *file);
d62 5
a66 1
f_tedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d127 1
a127 1
writesolid(void)
d250 2
a251 1
Get_next_line(FILE *fp)
d273 1
a273 1
readsolid(void)
@


11.30.2.2
log
@Added initial stubbed support for a new primitive -- a superquadric ellipsoid.  The primitive may be created in mged, but it has the same guts as the ellipsoid
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.30.2.1 2002/09/19 18:02:04 morrison Exp $ (BRL)";
a146 1
		struct rt_superell_internal *superell;
a238 7
		case ID_SUPERELL:
			superell = (struct rt_superell_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->v ) );
			(void)fprintf( fp , "A: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->a ) );
			(void)fprintf( fp , "B: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->b ) );
			(void)fprintf( fp , "C: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->c ) );
			break;
a295 1
		struct rt_superell_internal *superell;
a743 39
			break;
		case ID_SUPERELL:
			superell = (struct rt_superell_internal *)es_int.idb_ptr;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->v , a , b , c );
			VSCALE( superell->v , superell->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->a , a , b , c );
			VSCALE( superell->a , superell->a , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->b , a , b , c );
			VSCALE( superell->b , superell->b , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->c , a , b , c );
			VSCALE( superell->c , superell->c , local2base );
@


11.30.2.3
log
@Added the superell specific options and database support for <n,e>, the north-south and east-west curvature params.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.30.2.2 2003/01/31 00:11:55 morrison Exp $ (BRL)";
a245 1
			(void)fprintf( fp , "<n,e>: <%.9f, %.9f>\n", superell->n, superell->e);
a409 2
			fprintf(stderr, "ID_SPH\n");

a756 2
			fprintf(stderr, "ID_SUPERELL\n");

d792 1
a792 7
			
			if ( (str=Get_next_line( fp )) == NULL ) {
			  ret_val = 1;
			  break;
			}
			(void) sscanf( str, "%lf %lf", &superell->n, &superell->e);
			break;	
@


11.30.2.4
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a55 1
#ifndef WIN32
a56 3
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif
d84 1
a84 1
#ifdef WIN32
a809 39

#ifdef WIN32

/* Run $EDITOR on temp file */
editit( file )
const char *file;
{
   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   char line[1024];

   sprintf(line,"notepad %s",file);

   
      si.cb = sizeof(STARTUPINFO);
      si.lpReserved = NULL;
      si.lpReserved2 = NULL;
      si.cbReserved2 = 0;
      si.lpDesktop = NULL;
      si.dwFlags = 0;

      CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     NORMAL_PRIORITY_CLASS,
                     NULL,
                     NULL,
                     &si,
                     &pi );
      WaitForSingleObject( pi.hProcess, INFINITE );
   
	return 1;
}

#else
/* else win32 is not defined */

d843 1
a843 1
#	if defined(DM_X) || defined(DM_OGL)
d847 1
a847 1
#	else
d851 1
a851 1
#	endif
d859 1
a859 1
#	if defined(DM_X) || defined(DM_OGL)
d861 1
a861 1
#	else
d863 1
a863 1
#	endif
a877 2
#endif
/* end check if win32 defined */
@


11.29
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 2
a59 2
int writesolid(void), readsolid(void);
int editit(const char *file);
d62 5
a66 1
f_tedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d127 1
a127 1
writesolid(void)
d250 2
a251 1
Get_next_line(FILE *fp)
d273 1
a273 1
readsolid(void)
@


11.28
log
@Added checks to editit() for an X display manager when attempting to fire off an Xterm for external edits.  If there is not X display support, we assume console mode behavior and do what the console mged did (edit in the current console).  XXX It would be ideal if mged was a full console so we did not have to spawn external xterms.tedit.c

Also fixed a minor bug where the forked child process closes all of its file descriptors (incluing stdin) that causes some platforms to immediately close the execd process (since no input is supposedly available).  This happened on OSX.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.27 2001/11/05 21:20:07 morrison Exp $ (BRL)";
d58 2
a59 2
int writesolid(), readsolid();
int editit();
d62 1
a62 5
f_tedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d123 1
a123 1
writesolid()
d246 1
a246 2
Get_next_line( fp )
FILE *fp;
d268 1
a268 1
readsolid()
@


11.27
log
@Solid to Primitive naming convention conversions
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.26 2001/08/14 18:26:06 bparker Exp $ (BRL)";
d756 8
a763 1
/* Run $EDITOR on temp file */
d786 9
a794 1
#if 0
d796 1
a796 2
#else
		for( i=0; i < 20; i++ )
a797 1
			(void)close(i);
d801 7
a807 1
#if 0
a808 2
#else
		(void)execlp("xterm", "xterm", "-e", ed, file, (char *)0);
d813 1
@


11.26
log
@*- mods to editit to prevent xterm squaking
   from making its way to the GUI
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.25 2001/04/03 19:01:59 bparker Exp $ (BRL)";
d84 1
a84 1
	if( not_state( ST_S_EDIT, "Solid Text Edit" ) )
@


11.25
log
@*- get rid of warnings
*- use mkstemp instead of mktemp
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.24 2000/09/07 02:58:52 mike Exp $ (BRL)";
d779 1
d781 3
@


11.24
log
@
Added externs to ged.h to quiet down lint
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.23 2000/08/19 03:10:49 mike Exp $ (BRL)";
d88 1
d91 3
d758 1
a758 1
editit( const char *file )
a759 35
#if 0
#ifdef BSD
	register pid, xpid;
	int stat, omask;

#define	mask(s)	(1<<((s)-1))
	omask = sigblock(mask(SIGINT)|mask(SIGQUIT)|mask(SIGHUP));

	if ((pid = fork()) < 0) {
		perror("fork");
		return (0);
	}
	if (pid == 0) {
		register char *ed;

		sigsetmask(omask);
		if ((ed = getenv("EDITOR")) == (char *)0)
			ed = DEFEDITOR;

		bu_log("Invoking %s...\n", ed);
#if 0
		(void)execlp(ed, ed, file, 0);
#else
		(void)execlp("xterm", "xterm", "-e", ed, file, (char *)0);
#endif
		perror(ed);
		exit(1);
	}
	while ((xpid = wait(&stat)) >= 0)
		if (xpid == pid)
			break;
	sigsetmask(omask);
	return (!stat);
#endif
#else
d799 1
a799 1
#endif
@


11.23
log
@
const RCSid
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.22 2000/06/28 16:59:17 mike Exp $ (BRL)";
d753 2
a754 2
editit( file )
char *file;
@


11.22
log
@
Removed unnecessary reference to es_ext.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.21 1999/12/28 19:43:11 bparker Exp $ (BRL)";
@


11.21
log
@*- mktemp requires six X's in the template; the template must also
   be declared as an array of char's
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.20 1999/09/01 18:55:11 bparker Exp $ (BRL)";
a51 1
extern struct bu_external	es_ext;
@


11.20
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.19 1999/08/05 20:17:02 mike Exp $ (BRL)";
d56 2
a57 1
static char	tmpfil[] = "/tmp/GED.aXXXXX";
d88 1
@


11.19
log
@
Fixed to not call bu_log() in fork() after closing down all the
file descriptors!
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.18 1999/02/24 14:19:33 bparker Exp $ (BRL)";
d70 1
a70 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d127 1
a127 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d274 1
a274 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.18
log
@*- modified editit() to call editor from xterm
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.17 1999/02/08 16:32:59 bparker Exp $ (BRL)";
d795 1
d799 4
a809 1
		register char *ed;
d811 1
a817 3
		if ((ed = getenv("EDITOR")) == (char *)0)
			ed = DEFEDITOR;
		bu_log("Invoking %s...\n", ed);
@


11.17
log
@add support for particle solid
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.16 1998/11/06 22:32:43 bparker Exp $ (BRL)";
d779 1
d781 3
d816 1
d818 3
@


11.16
log
@*- use new structures
*- cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/tedit.c,v 11.15 1997/07/01 22:09:08 bparker Exp $ (BRL)";
d148 1
d194 7
d299 1
d484 38
@


11.15
log
@mods to run without a database
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.14 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d114 1
a114 1
		dmaflag = 1;
@


11.14
log
@modify calls to Tcl_Eval
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.13 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d70 3
d129 3
d268 3
@


11.13
log
@mods so that commands check args internally
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.12 1997/03/25 14:44:26 jra Exp bparker $ (BRL)";
d73 6
a78 1
	  Tcl_Eval(interp, "help ted");
@


11.12
log
@Mods to support MGED's read-only mode.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.11 1997/02/28 21:45:05 jra Exp jra $ (BRL)";
d72 2
a73 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d75 1
@


11.11
log
@removed include of db.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.10 1997/01/02 19:35:05 bparker Exp jra $ (BRL)";
d69 2
@


11.10
log
@mods to use libbn and libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.9 1996/09/23 18:19:41 bparker Exp bparker $ (BRL)";
a39 1
#include "db.h"
@


11.9
log
@changed dm.h to mged_dm.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.8 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d53 1
a53 1
extern struct rt_external	es_ext;
@


11.8
log
@now using libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.7 1996/08/21 13:59:15 jra Exp bparker $ (BRL)";
d46 1
a46 1
#include "./dm.h"
@


11.7
log
@Minor mods for IRIX 6.2.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.6 1996/04/18 20:28:43 bparker Exp jra $ (BRL)";
d714 1
a714 1
		rt_log("Invoking %s...\n", ed);
d747 1
a747 1
		rt_log("Invoking %s...\n", ed);
@


11.6
log
@convert commands to Tcl
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.5 1996/03/22 18:32:45 bparker Exp bparker $ (BRL)";
d726 1
a726 1
	register pid, xpid;
@


11.5
log
@cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.4 1996/03/01 19:27:28 bparker Exp bparker $ (BRL)";
d63 3
a65 1
f_tedit(argc, argv)
d71 3
d76 1
a76 1
		return CMD_BAD;
d82 2
a83 2
		perror(tmpfil);
		return CMD_BAD;
d89 2
a90 2
		(void)unlink(tmpfil);
		return CMD_BAD;
d97 2
a98 2
			(void)unlink(tmpfil);
			return CMD_BAD;
d104 1
a104 1
		rt_log("done\n");
d108 1
a108 1
	return CMD_OK;
d136 3
a138 3
			rt_log( "Cannot text edit this solid type\n" );
			(void)fclose(fp);
			return( 1 );
d278 3
a280 3
			rt_log( "Cannot text edit this solid type\n" );
			ret_val = 1;
			break;
d713 1
@


11.4
log
@remove unused XMGED stuff
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.3 1995/12/27 22:34:34 bparker Exp bparker $ (BRL)";
a45 1
#ifdef MULTI_ATTACH
a46 1
#endif
@


11.3
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 11.2 1995/01/17 13:05:06 bparker Exp bparker $ (BRL)";
a54 3
#ifdef XMGED
extern  int     mged_wait();
#endif
a229 4
#ifdef XMGED
	if( mged_fgets( line , sizeof( line ) , fp ) == NULL )
                return( (char *)NULL );
#else
a231 1
#endif
a725 4
#ifdef XMGED
  alarm((unsigned)0);
#endif

a748 3
#ifdef XMGED
	while ((xpid = mged_wait(&stat)) >= 0)
#else
a749 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/tedit.c,v 11.3 95/01/17 11:44:27 bparker Exp $ (BRL)";
d46 3
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.10 94/12/16 19:37:23 gdurf Exp $ (BRL)";
d52 3
d230 4
d236 1
d731 4
d757 4
d762 1
d765 1
@


10.10
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.9 1994/11/05 03:49:47 mike Exp gdurf $ (BRL)";
@


10.9
log
@Irix 6
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.8 94/10/17 12:47:55 jra Exp Locker: mike $ (BRL)";
d98 1
a98 1
		(void)printf("done\n");
d130 1
a130 1
			(void)printf( "Cannot text edit this solid type\n" );
d272 1
a272 1
			(void)printf( "Cannot text edit this solid type\n" );
d707 1
a707 1
		(void)printf("Invoking %s...\n", ed);
d740 1
a740 1
		(void)printf("Invoking %s...\n", ed);
@


10.8
log
@modified declaration of line in Get_next_line.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.7 94/09/02 00:23:57 mike Exp Locker: jra $ (BRL)";
a132 1
			break;
d443 1
a443 1
			HSCALE( grip->center , grip->center , local2base );
@


10.7
log
@Added a return code, so it would compile on VAPOR.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.6 94/08/30 14:10:59 jra Exp Locker: mike $ (BRL)";
d224 1
a224 1
	char line[LINELEN];
@


10.6
log
@Updated to use es_int rather than es_rec and added labels.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.5 94/08/23 18:28:45 gdurf Exp Locker: jra $ (BRL)";
d253 1
a253 1
		return;
@


10.5
log
@Cleaned up includes
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.4 1994/06/03 19:07:23 gdurf Exp gdurf $ (BRL)";
d31 5
d38 1
d42 2
d47 1
d49 2
d52 4
d58 1
a58 1
void writesolid(), readsolid();
a66 1
	struct solidrec lsolid;		/* local copy of solid */
a71 5
	if( es_rec.u_id != ID_SOLID ) {
		(void)printf("tedit: not a solid\n");
		return CMD_BAD;
	}

d74 2
a75 1
	if( i < 0 )  {
d81 4
a84 9
	if( es_rec.s.s_type == GENARB8 )  {
		/* convert to point notation in temporary buffer */
		VMOVE( &lsolid.s_values[0], &es_rec.s.s_values[0] );
		for( i = 3; i <= 21; i += 3 )  {  
			VADD2(&lsolid.s_values[i], &es_rec.s.s_values[i], &lsolid.s_values[0]);
		}
		writesolid( &lsolid );
	} else {
		writesolid( &es_rec.s );
d87 6
a92 11
	if( editit( tmpfil ) )  {
		if( es_rec.s.s_type == GENARB8 )  {
			readsolid( &lsolid );

			/* Convert back to point&vector notation */
			VMOVE( &es_rec.s.s_values[0], &lsolid.s_values[0] );
			for( i = 3; i <= 21; i += 3 )  {  
				VSUB2( &es_rec.s.s_values[i], &lsolid.s_values[i], &lsolid.s_values[0]);
			}
		}  else  {
			readsolid( &es_rec.s );
d106 2
a107 3
void
writesolid( sp )
register struct solidrec *sp;
d115 101
a215 6
	/* TODO:  This should be type-specific, with labels */
	for( i = 0; i < 24; i+=3 )
		(void)fprintf(fp,"%.9f %.9f %.9f\n",
			sp->s_values[i]*base2local,
			sp->s_values[i+1]*base2local,
			sp->s_values[i+2]*base2local );
d217 1
d220 22
d243 2
a244 3
void
readsolid( sp )
register struct solidrec *sp;
a246 1
	char line[256];
d248 1
d256 19
a274 3
	/* Read solid parameters, 1 vector or point per line */
	for( i = 0; i < 24; i+=3 )  {
		if (fgets(line, sizeof (line), fp) == NULL)
d276 404
a679 8
		
		(void)sscanf( line, "%e %e %e",
			&sp->s_values[i],
			&sp->s_values[i+1],
			&sp->s_values[i+2] );
		sp->s_values[i] *= local2base;
		sp->s_values[i+1] *= local2base;
		sp->s_values[i+2] *= local2base;
d681 1
d683 1
@


10.4
log
@removed unnecessary extern declaration
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.3 1994/06/03 17:33:57 gdurf Exp gdurf $ (BRL)";
d27 2
d160 1
d189 1
a189 2
#ifdef SYSV
	/* System V */
a191 3
#if defined(sgi) && !defined(mips)
	int (*s2)(), (*s3)();
#else
a192 1
#endif
d221 1
a222 1
#endif
@


10.3
log
@Converted f_tedit to use new command return codes.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.2 1991/12/18 07:46:16 mike Exp gdurf $ (BRL)";
a37 2

extern int	numargs;	/* number of args */
@


10.2
log
@Eliminated now useless calls to pr_solid().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 10.1 91/10/12 06:44:20 mike Rel4_0 Locker: mike $ (BRL)";
a39 1
extern char	*cmd_args[];	/* array of pointers to args */
d46 4
a49 2
void
f_tedit()
d56 1
a56 1
		return;
d60 1
a60 1
		return;
d67 1
a67 1
		return;
d101 2
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 9.4 91/10/11 11:33:02 butler Exp $ (BRL)";
a95 1
		pr_solid( &es_rec.s );
@


9.4
log
@mods to make SGI 3030 happy
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 9.3 91/01/12 08:03:39 mike Exp Locker: butler $ (BRL)";
@


9.3
log
@externs.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/tedit.c,v 9.2 90/04/21 06:06:16 mike Exp $ (BRL)";
d190 3
d194 1
@


9.2
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 9.1 89/05/19 06:03:57 mike Locked $ (BRL)";
d31 1
a36 3
extern void	exit(), perror();
extern char	*mktemp();

a42 1
extern char	*getenv();
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 8.3 89/03/07 00:15:27 mike Exp $ (BRL)";
d98 1
a98 1
		illump = redraw( illump, &es_rec, es_mat );
@


8.3
log
@ansii
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 8.2 88/12/06 02:32:45 mike Locked $ (BRL)";
@


8.2
log
@raytrace.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/tedit.c,v 1.2 88/10/23 13:56:54 mike Exp $ (BRL)";
a192 1
#ifdef mips
a193 3
#else
	int (*s2)(), (*s3)();
#endif
@


8.1
log
@Release_3.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 7.5 88/03/02 23:20:24 phil Exp $ (BRL)";
d32 1
@


7.5
log
@made last changed mips specific (signal returning void)
someday this will probably be SYSVR3... sigh.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 7.4 88/01/13 16:38:26 phil Locked $ (BRL)";
@


7.4
log
@added a call to mged_finish
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 7.3 87/11/14 05:02:33 stay Locked $ (BRL)";
d192 1
d194 3
@


7.3
log
@Added dir_getmrec() to get all records for an item,
using malloc.
Added total path matrix as explicit arg to redraw().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 7.2 87/11/05 05:06:54 mike Locked $ (BRL)";
d192 1
a192 1
	int (*s2)(), (*s3)();
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 7.1 87/11/03 00:01:55 mike Rel $ (BRL)";
d97 1
a97 1
		illump = redraw( illump, &es_rec );
@


7.1
log
@Release 2.3
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 6.1 87/07/11 08:05:21 mike Rel $ (BRL)";
d29 1
a29 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 5.1 87/06/24 22:22:13 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 4.2 87/02/13 00:13:05 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 4.1 86/12/29 03:23:05 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 2.6 86/10/21 02:49:39 mike Exp $ (BRL)";
@


2.6
log
@Sys5 lint fix
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 2.5 86/08/13 00:08:47 mike Locked $ (BRL)";
@


2.5
log
@Converted from BSD42 to BSD and SYSV defines to select UNIX type.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 2.4 86/08/12 06:50:48 mike Exp $ (BRL)";
d192 1
a192 1
	void (*s2)(), (*s3)();
@


2.4
log
@Changed #includes for CC -I../h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 2.3 85/08/07 05:19:51 mike Exp $ (BRL)";
d160 1
a160 1
#ifdef BSD42
d187 2
a188 1
#else
@


2.3
log
@Changed to use common ../h/vmath.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 2.2 85/03/14 05:04:41 mike Exp $ (BRL)";
d30 4
a33 4
#include "../h/vmath.h"
#include "ged.h"
#include "../h/db.h"
#include "sedit.h"
@


2.2
log
@Various support for mater.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: tedit.c,v 2.1 85/03/11 23:57:06 mike Prod $ (BRL)";
d29 2
a30 1
#include "ged_types.h"
a33 1
#include "../h/vmath.h"
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d83 1
a83 1
	if( editit() )  {
d157 2
a158 1
editit()
d178 1
a178 1
		(void)execlp(ed, ed, tmpfil, 0);
d211 1
a211 1
		(void)execlp(ed, ed, tmpfil, 0);
@


1.6
log
@USNA changes which formalize state changes.
@
text
@d3 19
d23 4
d31 1
a31 1
#include "db.h"
d33 1
a33 1
#include "vmath.h"
d35 3
d46 3
d64 1
a64 1
	mktemp(tmpfil);
a71 1

d83 1
a83 1
	if (editit())  {
d102 1
a102 1
	unlink(tmpfil);
d105 2
d122 1
a122 1
	fclose(fp);
d125 2
d145 1
a145 1
		sscanf( line, "%e %e %e",
d153 1
a153 1
	fclose(fp);
d156 1
d177 1
a177 1
		execlp(ed, ed, tmpfil, 0);
d187 1
a187 1
	/* System 5 */
d189 1
a189 1
	int stat, omask;
d210 1
a210 1
		execlp(ed, ed, tmpfil, 0);
@


1.5
log
@Moved #ifdef to make ctags happy.
@
text
@d27 1
a27 2
	if( state != ST_S_EDIT )  {
		state_err( "Solid Text Edit" );
a28 1
	}
@


1.4
log
@Keith's global/local units additions
@
text
@a125 1
#ifdef BSD42
d128 1
a154 1
}
d156 1
a156 3
/* System 5 */
editit()
{
d189 1
a190 1
#endif
@


1.3
log
@pre-Keith version
@
text
@d91 3
a93 3
			sp->s_values[i],
			sp->s_values[i+1],
			sp->s_values[i+2] );
d119 3
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d8 1
a8 1
#include "3d.h"
@


1.1
log
@Initial revision
@
text
@d46 9
a54 4
	/* convert to point notation in temporary buffer */
	VMOVE( &lsolid.s_values[0], &es_rec.s.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VADD2(&lsolid.s_values[i], &es_rec.s.s_values[i], &lsolid.s_values[0]);
a55 1
	writesolid( &lsolid );
d58 2
a59 1
		readsolid( &lsolid );
d61 7
a67 4
		/* Convert back to point&vector notation */
		VMOVE( &es_rec.s.s_values[0], &lsolid.s_values[0] );
		for( i = 3; i <= 21; i += 3 )  {  
			VSUB2( &es_rec.s.s_values[i], &lsolid.s_values[i], &lsolid.s_values[0]);
@
