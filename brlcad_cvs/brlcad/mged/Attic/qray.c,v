head	1.11;
access;
symbols
	ansi-20040405-merged:1.6.2.2
	postmerge-20040405-ansi:1.9
	premerge-20040404-ansi:1.8
	postmerge-autoconf:1.8
	autoconf-freeze:1.6.10.2
	premerge-autoconf:1.8
	postmerge-20040315-windows:1.8
	premerge-20040315-windows:1.7
	windows-20040315-freeze:1.6.4.2
	autoconf-20031203:1.6
	autoconf-20031202:1.6
	autoconf-branch:1.6.0.10
	phong-branch:1.6.0.8
	photonmap-branch:1.6.0.6
	rel-6-1-DP:1.6
	windows-branch:1.6.0.4
	rel-6-0-2:1.4
	ansi-branch:1.6.0.2
	rel-6-0-1-branch:1.4.0.2
	hartley-6-0-post:1.5
	hartley-6-0-pre:1.4
	rel-6-0-1:1.4
	rel-6-0:1.4
	rel-5-4:1.3
	offsite-5-3-pre:1.3
	rel-5-3:1.3
	rel-5-2:1.3
	rel-5-1-branch:1.3.0.2
	rel-5-1:1.3
	rel-5-0:1.3
	rel-5-0-beta:1.1;
locks; strict;
comment	@ * @;


1.11
date	2004.05.21.17.47.48;	author morrison;	state dead;
branches;
next	1.10;

1.10
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.16.21.15.12;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.02.17.39.34;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.20.17.08.24;	author jra;	state Exp;
branches
	1.6.2.1
	1.6.4.1
	1.6.10.1;
next	1.5;

1.5
date	2002.08.15.20.55.36;	author hartley;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.02.18.10.11;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.20.19.27;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	99.06.11.20.16.04;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.03.19.17.46.57;	author bparker;	state Exp;
branches;
next	;

1.6.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2004.03.17.21.22.01;	author morrison;	state Exp;
branches;
next	;

1.6.4.1
date	2002.09.26.23.04.13;	author morrison;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

1.6.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2004.03.18.18.10.31;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to set and get "Query Ray" variables.
@


1.11
log
@moved to src/mged/
@
text
@/*
 *			Q R A Y . C
 *
 * Routines to set and get "Query Ray" variables.
 *
 * Source -
 *      SLAD CAD Team
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005
 *
 * Author -
 *      Robert G. Parker
 *
 * Copyright Notice -
 *      This software is Copyright (C) 1998-2004 by the United States Army.
 *      All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "./qray.h"

static void qray_print_fmts(void);
static void qray_print_vars(void);
static int qray_get_fmt_index(char c);

struct bu_vls qray_basename;
struct bu_vls qray_script;
char qray_effects = 'b';
int qray_cmd_echo = 0;
struct qray_fmt *qray_fmts;
static struct qray_color qray_odd_color = { 0, 255, 255 };
static struct qray_color qray_even_color = { 255, 255, 0 };
static struct qray_color qray_void_color = { 255, 0, 255 };
static struct qray_color qray_overlap_color = { 255, 255, 255 };

#ifndef WIN32
static struct qray_fmt_data def_qray_fmt_data[] = {
  {'r', "\"Origin (x y z) = (%.2f %.2f %.2f)  (h v d) = (%.2f %.2f %.2f)\\nDirection (x y z) = (%.4f %.4f %.4f)  (az el) = (%.2f %.2f)\\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e"},
  {'h', "\"    Region Name               Entry (x y z)              LOS  Obliq_in\\n\""},
  {'p', "\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f\\n\" reg_name x_in y_in z_in los obliq_in"},
  {'f', "\"\""},
  {'m', "\"You missed the target\\n\""},
  {'o', "\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\\n\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"},
  {(char)NULL, (char *)NULL}
};
#else
static struct qray_fmt_data def_qray_fmt_data[] = {
  {'r', "\\\"Origin (x y z) = (%.2f %.2f %.2f)  (h v d) = (%.2f %.2f %.2f)\\\\nDirection (x y z) = (%.4f %.4f %.4f)  (az el) = (%.2f %.2f)\\\\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e"},
  {'h', "\\\"    Region Name               Entry (x y z)              LOS  Obliq_in\\\\n\\\""},
  {'p', "\\\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f\\\\n\\\" reg_name x_in y_in z_in los obliq_in"},
  {'f', "\\\"\\\""},
  {'m', "\\\"You missed the target\\\\n\\\""},
  {'o', "\\\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\\\\n\\\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"},
  {(char)NULL, (char *)NULL}
};
#endif

static char qray_syntax[] = "\
 qray vars			print a list of all variables (i.e. var = val)\n\
 qray basename [str]		set or get basename for query ray solids\n\
 qray effects [t|g|b]		set or get effects (i.e. text, graphical or both)\n\
 qray echo [0|1]		set or get command echo\n\
 qray oddcolor [r g b]		set or get color of odd partitions\n\
 qray evencolor [r g b]		set or get color of even partitions\n\
 qray voidcolor [r g b]		set or get color of void areas\n\
 qray overlapcolor [r g b]	set or get color of overlap areas\n\
 qray fmt [r|h|p|f|m|o [str]]	set or get format string(s)\n\
 qray script [str]		set or get the nirt script string\n\
 qray [help]			print this help message\n\
";

int
f_qray(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct bu_vls vls;

  if(6 < argc){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help qray");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  /* print help message */
  if(argc == 1){
    Tcl_AppendResult(interp, "Usage:\n", qray_syntax, (char *)NULL);
    return TCL_OK;
  }

  if(strcmp(argv[1], "fmt") == 0){
    int i;

    if(argc == 2){			/* get all format strings */
      qray_print_fmts();
      return TCL_OK;
    }else if(argc == 3){		/* get particular format string */
      if((i = qray_get_fmt_index(*argv[2])) < 0){
	Tcl_AppendResult(interp,
			  "qray: unrecognized format type: '",
			 argv[2], "'\nUsage:\n", qray_syntax, (char *)NULL);
	return TCL_ERROR;
      }

      Tcl_AppendResult(interp, bu_vls_addr(&qray_fmts[i].fmt), (char *)NULL);
      return TCL_OK;
    }else if(argc == 4){		/* set value */
      if((i = qray_get_fmt_index(*argv[2])) < 0){
	Tcl_AppendResult(interp,
			  "qray: unrecognized format type: '",
			 argv[2], "'\nUsage:\n", qray_syntax, (char *)NULL);
	return TCL_ERROR;
      }

      bu_vls_trunc(&qray_fmts[i].fmt, 0);
      bu_vls_printf(&qray_fmts[i].fmt, "%s", argv[3]);
      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray fmt' command accepts 0, 1, or 2 arguments\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "basename") == 0){
    if(argc == 2){		/* get value */
      Tcl_AppendResult(interp, bu_vls_addr(&qray_basename), (char *)NULL);

      return TCL_OK;
    }else if(argc == 3){		/* set value */
      bu_vls_strcpy(&qray_basename, argv[2]);
      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray basename' command accepts 0 or 1 argument\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "script") == 0){
    if(argc == 2){		/* get value */
      Tcl_AppendResult(interp, bu_vls_addr(&qray_script), (char *)NULL);

      return TCL_OK;
    }else if(argc == 3){		/* set value */
      bu_vls_strcpy(&qray_script, argv[2]);
      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray script' command accepts 0 or 1 argument\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "effects") == 0){
    if(argc == 2){		/* get value */
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%c", qray_effects);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 3){		/* set value */
      if(*argv[2] != 't' && *argv[2] != 'g' && *argv[2] != 'b'){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "qray effects: bad value - %s", argv[2]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_ERROR;
      }

      qray_effects = *argv[2];

      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray effects' command accepts 0 or 1 argument\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "echo") == 0){
    if(argc == 2){		/* get value */
      if(qray_cmd_echo)
	Tcl_AppendResult(interp, "1", (char *)NULL);
      else
	Tcl_AppendResult(interp, "0", (char *)NULL);

      return TCL_OK;
    }else if(argc == 3){		/* set value */
      int ival;

      if(sscanf(argv[2], "%d", &ival) < 1){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "qray echo: bad value - %s", argv[2]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_ERROR;
      }

      if(ival)
	qray_cmd_echo = 1;
      else
	qray_cmd_echo = 0;

      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray echo' command accepts 0 or 1 argument\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "oddcolor") == 0){
    if(argc == 2){		/* get value */
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d %d",
		    qray_odd_color.r, qray_odd_color.g, qray_odd_color.b);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 5){		/* set value */
      int r, g, b;

      if(sscanf(argv[2], "%d", &r) != 1 ||
	 sscanf(argv[3], "%d", &g) != 1 ||
	 sscanf(argv[4], "%d", &b) != 1 ||
	 r < 0 || g < 0 || b < 0 ||
	 255 < r || 255 < g || 255 < b){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "qray oddcolor %s %s %s - bad value",
		      argv[2], argv[3], argv[4]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
      }

      qray_odd_color.r = r;
      qray_odd_color.g = g;
      qray_odd_color.b = b;

      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray oddcolor' command accepts 0 or 3 arguments\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "evencolor") == 0){
    if(argc == 2){		/* get value */
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d %d",
		    qray_even_color.r, qray_even_color.g, qray_even_color.b);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 5){		/* set value */
      int r, g, b;

      if(sscanf(argv[2], "%d", &r) != 1 ||
	 sscanf(argv[3], "%d", &g) != 1 ||
	 sscanf(argv[4], "%d", &b) != 1 ||
	 r < 0 || g < 0 || b < 0 ||
	 255 < r || 255 < g || 255 < b){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "qray evencolor %s %s %s - bad value",
		      argv[2], argv[3], argv[4]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
      }

      qray_even_color.r = r;
      qray_even_color.g = g;
      qray_even_color.b = b;

      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray evencolor' command accepts 0 or 3 arguments\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "voidcolor") == 0){
    if(argc == 2){		/* get value */
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d %d",
		    qray_void_color.r, qray_void_color.g, qray_void_color.b);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 5){		/* set value */
      int r, g, b;

      if(sscanf(argv[2], "%d", &r) != 1 ||
	 sscanf(argv[3], "%d", &g) != 1 ||
	 sscanf(argv[4], "%d", &b) != 1 ||
	 r < 0 || g < 0 || b < 0 ||
	 255 < r || 255 < g || 255 < b){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "qray voidcolor %s %s %s - bad value",
		      argv[2], argv[3], argv[4]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
      }

      qray_void_color.r = r;
      qray_void_color.g = g;
      qray_void_color.b = b;

      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray voidcolor' command accepts 0 or 3 arguments\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "overlapcolor") == 0){
    if(argc == 2){		/* get value */
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d %d",
		    qray_overlap_color.r, qray_overlap_color.g, qray_overlap_color.b);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 5){		/* set value */
      int r, g, b;

      if(sscanf(argv[2], "%d", &r) != 1 ||
	 sscanf(argv[3], "%d", &g) != 1 ||
	 sscanf(argv[4], "%d", &b) != 1 ||
	 r < 0 || g < 0 || b < 0 ||
	 255 < r || 255 < g || 255 < b){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "qray overlapcolor %s %s %s - bad value",
		      argv[2], argv[3], argv[4]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
      }

      qray_overlap_color.r = r;
      qray_overlap_color.g = g;
      qray_overlap_color.b = b;

      return TCL_OK;
    }

    Tcl_AppendResult(interp,
		     "The 'qray overlapcolor' command accepts 0 or 3 arguments\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "vars") == 0){
    qray_print_vars();
    return TCL_OK;
  }

  if(strcmp(argv[1], "help") == 0){
    Tcl_AppendResult(interp, "Usage:\n", qray_syntax, (char *)NULL);
    return TCL_OK;
  }

  Tcl_AppendResult(interp, "qray: unrecognized command: '",
		   argv[1], "'\nUsage:\n", qray_syntax, (char *)NULL);
  return TCL_ERROR;
}

static void
qray_print_fmts(void)
{
  int i;

  for(i = 0; qray_fmts[i].type != (char)NULL; ++i)
    Tcl_AppendResult(interp, bu_vls_addr(&qray_fmts[i].fmt),
		     "\n", (char *)NULL);
}

static void
qray_print_vars(void)
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "basename = %s\n", bu_vls_addr(&qray_basename));
  bu_vls_printf(&vls, "script = %s\n", bu_vls_addr(&qray_script));
  bu_vls_printf(&vls, "effects = %c\n", qray_effects);
  bu_vls_printf(&vls, "echo = %d\n", qray_cmd_echo);
  bu_vls_printf(&vls, "oddcolor = %d %d %d\n",
		qray_odd_color.r, qray_odd_color.g, qray_odd_color.b);
  bu_vls_printf(&vls, "evencolor = %d %d %d\n",
		qray_even_color.r, qray_even_color.g, qray_even_color.b);
  bu_vls_printf(&vls, "voidcolor = %d %d %d\n",
		qray_void_color.r, qray_void_color.g, qray_void_color.b);
  bu_vls_printf(&vls, "overlapcolor = %d %d %d\n",
		qray_overlap_color.r, qray_overlap_color.g, qray_overlap_color.b);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  qray_print_fmts();
}

static int
qray_get_fmt_index(char c)
{
  int i;

  for(i = 0; qray_fmts[i].type != (char)NULL; ++i)
    if(c == qray_fmts[i].type)
      return i;

  return -1;
}

void
init_qray(void)
{
  register int i;
  register int n = 0;
  struct qray_fmt_data *qfdp;

  bu_vls_init(&qray_basename);
  bu_vls_strcpy(&qray_basename, QRAY_BASENAME);
  bu_vls_init(&qray_script);

  /* count the number of default format types */
  for(qfdp = def_qray_fmt_data; qfdp->fmt != (char *)NULL; ++qfdp)
    ++n;

  qray_fmts = (struct qray_fmt *)bu_malloc(sizeof(struct qray_fmt) * n + 1, "qray_fmts");

  for(i = 0; i < n; ++i){
    qray_fmts[i].type = def_qray_fmt_data[i].type;
    bu_vls_init(&qray_fmts[i].fmt);
    bu_vls_strcpy(&qray_fmts[i].fmt, def_qray_fmt_data[i].fmt);
  }

  qray_fmts[i].type = (char)NULL;
}

void
qray_data_to_vlist(struct bn_vlblock *vbp, struct qray_dataList *headp, fastf_t *dir, int do_overlaps)
{
  register int i = 1;			/* start out odd */
  register struct bu_list *vhead;
  register struct qray_dataList *ndlp;
  vect_t in_pt, out_pt;
  vect_t last_out_pt;

  for(BU_LIST_FOR(ndlp, qray_dataList, &headp->l)){
    if(do_overlaps)
      vhead = rt_vlblock_find(vbp,
			      qray_overlap_color.r,
			      qray_overlap_color.g,
			      qray_overlap_color.b);
    else if(i % 2)
      vhead = rt_vlblock_find(vbp,
			      qray_odd_color.r,
			      qray_odd_color.g,
			      qray_odd_color.b);
    else
      vhead = rt_vlblock_find(vbp,
			      qray_even_color.r,
			      qray_even_color.g,
			      qray_even_color.b);

    VSET(in_pt, ndlp->x_in, ndlp->y_in, ndlp->z_in);
    VJOIN1(out_pt, in_pt, ndlp->los, dir);
    VSCALE(in_pt, in_pt, local2base);
    VSCALE(out_pt, out_pt, local2base);
    RT_ADD_VLIST( vhead, in_pt, RT_VLIST_LINE_MOVE );
    RT_ADD_VLIST( vhead, out_pt, RT_VLIST_LINE_DRAW );

    if(!do_overlaps && i > 1 && !VAPPROXEQUAL(last_out_pt,in_pt,SQRT_SMALL_FASTF)){
      vhead = rt_vlblock_find(vbp,
			      qray_void_color.r,
			      qray_void_color.g,
			      qray_void_color.b);
      RT_ADD_VLIST( vhead, last_out_pt, RT_VLIST_LINE_MOVE );
      RT_ADD_VLIST( vhead, in_pt, RT_VLIST_LINE_DRAW );
    }

    VMOVE(last_out_pt, out_pt);
    ++i;
  }
}
@


1.10
log
@change conf.h to a wrapped config.h
@
text
@@


1.9
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 5
a23 1
#include "conf.h"
@


1.8
log
@merge of windows-6-0-branch into head
@
text
@d38 3
a40 3
static void qray_print_fmts();
static void qray_print_vars();
static int qray_get_fmt_index();
d89 1
a89 5
f_qray(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d402 1
a402 1
qray_print_fmts()
d412 1
a412 1
qray_print_vars()
d436 1
a436 2
qray_get_fmt_index(c)
char c;
d448 1
a448 1
init_qray()
d474 1
a474 5
qray_data_to_vlist(vbp, headp, dir, do_overlaps)
struct rt_vlblock *vbp;
struct qray_dataList *headp;
vect_t dir;
int do_overlaps;
@


1.7
log
@update copyright to include span through 2003
@
text
@d52 1
d62 11
@


1.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *      This software is Copyright (C) 1998 by the United States Army.
@


1.6.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *      This software is Copyright (C) 1998-2004 by the United States Army.
@


1.6.10.2
log
@merge from head
@
text
@a51 1
#ifndef WIN32
a60 11
#else
static struct qray_fmt_data def_qray_fmt_data[] = {
  {'r', "\\\"Origin (x y z) = (%.2f %.2f %.2f)  (h v d) = (%.2f %.2f %.2f)\\\\nDirection (x y z) = (%.4f %.4f %.4f)  (az el) = (%.2f %.2f)\\\\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e"},
  {'h', "\\\"    Region Name               Entry (x y z)              LOS  Obliq_in\\\\n\\\""},
  {'p', "\\\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f\\\\n\\\" reg_name x_in y_in z_in los obliq_in"},
  {'f', "\\\"\\\""},
  {'m', "\\\"You missed the target\\\\n\\\""},
  {'o', "\\\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\\\\n\\\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"},
  {(char)NULL, (char *)NULL}
};
#endif
@


1.6.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a51 1
#ifndef WIN32
a60 11
#else
static struct qray_fmt_data def_qray_fmt_data[] = {
  {'r', "\\\"Origin (x y z) = (%.2f %.2f %.2f)  (h v d) = (%.2f %.2f %.2f)\\\\nDirection (x y z) = (%.4f %.4f %.4f)  (az el) = (%.2f %.2f)\\\\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e"},
  {'h', "\\\"    Region Name               Entry (x y z)              LOS  Obliq_in\\\\n\\\""},
  {'p', "\\\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f\\\\n\\\" reg_name x_in y_in z_in los obliq_in"},
  {'f', "\\\"\\\""},
  {'m', "\\\"You missed the target\\\\n\\\""},
  {'o', "\\\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\\\\n\\\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"},
  {(char)NULL, (char *)NULL}
};
#endif
@


1.6.4.2
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *      This software is Copyright (C) 1998-2004 by the United States Army.
@


1.6.2.1
log
@Initial ANSIfication
@
text
@d38 3
a40 3
static void qray_print_fmts(void);
static void qray_print_vars(void);
static int qray_get_fmt_index(char c);
d77 5
a81 1
f_qray(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d394 1
a394 1
qray_print_fmts(void)
d404 1
a404 1
qray_print_vars(void)
d428 2
a429 1
qray_get_fmt_index(char c)
d441 1
a441 1
init_qray(void)
d467 5
a471 1
qray_data_to_vlist(struct bn_vlblock *vbp, struct qray_dataList *headp, fastf_t *dir, int do_overlaps)
@


1.6.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *      This software is Copyright (C) 1998-2004 by the United States Army.
a51 1
#ifndef WIN32
a60 11
#else
static struct qray_fmt_data def_qray_fmt_data[] = {
  {'r', "\\\"Origin (x y z) = (%.2f %.2f %.2f)  (h v d) = (%.2f %.2f %.2f)\\\\nDirection (x y z) = (%.4f %.4f %.4f)  (az el) = (%.2f %.2f)\\\\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e"},
  {'h', "\\\"    Region Name               Entry (x y z)              LOS  Obliq_in\\\\n\\\""},
  {'p', "\\\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f\\\\n\\\" reg_name x_in y_in z_in los obliq_in"},
  {'f', "\\\"\\\""},
  {'m', "\\\"You missed the target\\\\n\\\""},
  {'o', "\\\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\\\\n\\\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"},
  {(char)NULL, (char *)NULL}
};
#endif
@


1.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d38 3
a40 3
static void qray_print_fmts(void);
static void qray_print_vars(void);
static int qray_get_fmt_index(char c);
d77 5
a81 1
f_qray(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d394 1
a394 1
qray_print_fmts(void)
d404 1
a404 1
qray_print_vars(void)
d428 2
a429 1
qray_get_fmt_index(char c)
d441 1
a441 1
init_qray(void)
d467 5
a471 1
qray_data_to_vlist(struct bn_vlblock *vbp, struct qray_dataList *headp, fastf_t *dir, int do_overlaps)
@


1.4
log
@Lint
@
text
@d38 3
a40 3
static void qray_print_fmts();
static void qray_print_vars();
static int qray_get_fmt_index();
d77 1
a77 5
f_qray(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d390 1
a390 1
qray_print_fmts()
d400 1
a400 1
qray_print_vars()
d424 1
a424 2
qray_get_fmt_index(c)
char c;
d436 1
a436 1
init_qray()
d462 1
a462 5
qray_data_to_vlist(vbp, headp, dir, do_overlaps)
struct rt_vlblock *vbp;
struct qray_dataList *headp;
vect_t dir;
int do_overlaps;
@


1.3
log
@Changed the default query-ray effect from "text" to "both" [text and graphics]
@
text
@d22 7
@


1.2
log
@*- add script option to qray command for storing a nirt script
@
text
@d37 1
a37 1
char qray_effects = 't';
@


1.1
log
@Initial revision
@
text
@d36 1
d65 1
d144 16
d403 1
d442 1
@

