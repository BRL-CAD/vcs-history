head	11.8;
access;
symbols
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:8.2
	rel-3-5:8.2
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.5;
locks; strict;
comment	@ * @;


11.8
date	2000.03.04.05.40.44;	author mike;	state dead;
branches;
next	11.7;

11.7
date	2000.03.04.05.40.15;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.10.04.15.04.45;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.09.23.18.22.47;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.24;	author mike;	state Rel4_4;
branches;
next	8.2;

8.2
date	88.12.06.01.40.37;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.13;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.02.25.05.07.53;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	87.11.05.07.08.32;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.11.05.05.59.26;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.34;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.01.36;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.52;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.21.47;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.06.16.05.27.02;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.12.45;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.22.35;	author mike;	state Rel1;
branches;
next	2.11;

2.11
date	86.08.12.06.50.19;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.07.17.17.36.54;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.03.27.21.23.17;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.03.14.20.42.22;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.03.11.00.11.45;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.09.14.05.37.17;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.08.07.05.19.29;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.02.20.16.25;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.15.05.06.21;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.04.07.26;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.56.43;	author mike;	state Prod;
branches;
next	1.3;

1.3
date	85.01.16.01.58.24;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.04.25.10;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.52.29;	author mike;	state Exp;
branches;
next	;


desc
@Traverse the tree until leaf nodes are found
@


11.8
log
@
This file isn't part of MGED any longer, no need to carry it around.
@
text
@/*
 *			P A T H . C
 *
 * Functions -
 *	drawHobj	Call drawsolid for all solids in an object
 *	pathHmat	Find matrix across a given path
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/path.c,v 11.7 2000/03/04 05:40:15 mike Exp $ (BRL)";
#endif

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db.h"
#include "./mged_solid.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"

int	regmemb;	/* # of members left to process in a region */
char	memb_oper;	/* operation for present member of processed region */
int	reg_pathpos;	/* pathpos of a processed region */

struct directory	*cur_path[MAX_PATH];	/* Record of current path */

/*
 *			D R A W H O B J
 *
 * This routine is used to get an object drawn.
 * The actual drawing of solids is performed by drawsolid(),
 * but all transformations down the path are done here.
 */
void
drawHobj( dp, flag, pathpos, old_xlate, regionid )
register struct directory *dp;
matp_t old_xlate;
{
	union record	*rp;
	auto mat_t	new_xlate;	/* Accumulated translation matrix */
	auto int	i;
	struct bu_vls vls;

	bu_vls_init(&vls);

	if( pathpos >= MAX_PATH )  {
	  bu_vls_printf(&vls, "nesting exceeds %d levels\n", MAX_PATH );
	  for(i=0; i<MAX_PATH; i++)
	    bu_vls_printf(&vls, "/%s", cur_path[i]->d_namep );
	  bu_vls_strcat(&vls, "\n");

	  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	  bu_vls_free(&vls);
	  return;			/* ERROR */
	}

	/*
	 * Load the record into local record buffer
	 */
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
		return;

	if( rp[0].u_id == ID_SOLID ||
	    rp[0].u_id == ID_ARS_A ||
	    rp[0].u_id == ID_BSOLID ||
	    rp[0].u_id == ID_P_HEAD )  {
		register struct solid *sp;
		/*
		 * Enter new solid (or processed region) into displaylist.
		 */
		cur_path[pathpos] = dp;

		GET_SOLID(sp, &FreeSolid.l);
		if( sp == SOLID_NULL )
			return;		/* ERROR */
		if( drawHsolid( sp, flag, pathpos, old_xlate, rp, regionid ) != 1 ) {
			FREE_SOLID(sp, &FreeSolid.l);
		}
		goto out;
	}

	if( rp[0].u_id != ID_COMB )  {
		(void)printf("drawobj:  defective input '%c'\n", rp[0].u_id );
		goto out;		/* ERROR */
	}
	if( dp->d_len <= 1 )  {
	  Tcl_AppendResult(interp, "Warning: combination with zero members \"",
			   dp->d_namep, "\".\n", (char *)NULL);
	  goto out;			/* non-fatal ERROR */
	}
	if( rp[0].c.c_flags != DBV4_NON_REGION )  {
	  if( regionid != 0 ){
	    bu_vls_printf(&vls, "regionid %d overriden by %d\n",
			  regionid, rp[0].c.c_regionid );
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	  }
	  regionid = rp[0].c.c_regionid;
	}

	/*
	 *  This node is a combination (eg, a directory).
	 *  Process all the arcs (eg, directory members).
	 */
	if( drawreg && rp[0].c.c_flags != DBV4_NON_REGION && dp->d_len > 1 ) {
	  if( regmemb >= 0  ) {
	    Tcl_AppendResult(interp, "ERROR: region (", dp->d_namep,
			     ") is member of region (", cur_path[reg_pathpos]->d_namep,
			     ")\n", (char *)NULL);
	    goto out;	/* ERROR */
	  }
	  /* Well, we are processing regions and this is a region */
	  /* if region has only 1 member, don't process as a region */
	  if( dp->d_len > 2) {
	    regmemb = dp->d_len-1;
	    reg_pathpos = pathpos;
	  }
	}

	/* Process all the member records */
	for( i=1; i < dp->d_len; i++ )  {
		register struct member	*mp;
		register struct directory *nextdp;
		static mat_t		xmat;	/* temporary fastf_t matrix */

		mp = &(rp[i].M);
		if( mp->m_id != ID_MEMB )  {
		  Tcl_AppendResult(interp, "drawHobj:  ", dp->d_namep,
				   " bad member rec\n", (char *)NULL);
		  goto out;			/* ERROR */
		}
		cur_path[pathpos] = dp;
		if( regmemb > 0  ) { 
			regmemb--;
			memb_oper = mp->m_relation;
		}
		if( (nextdp = db_lookup( dbip,  mp->m_instname, LOOKUP_NOISY )) == DIR_NULL )
			continue;

		/* s' = M3 . M2 . M1 . s
		 * Here, we start at M3 and descend the tree.
		 * convert matrix to fastf_t from disk format.
		 */
		rt_mat_dbmat( xmat, mp->m_mat );
		bn_mat_mul(new_xlate, old_xlate, xmat);

		/* Recursive call */
		drawHobj(
			nextdp,
			(mp->m_relation != SUBTRACT) ? ROOT : INNER,
			pathpos + 1,
			new_xlate,
			regionid
		);
	}
out:
	bu_vls_free(&vls);
	bu_free( (genptr_t)rp, "drawHobj recs");
}

/*
 *  			P A T H h M A T
 *  
 *  Find the transformation matrix obtained when traversing
 *  the arc indicated in sp->s_path[] to the indicated depth.
 *  Be sure to omit s_path[sp->s_last] -- it's a solid.
 */
void
pathHmat( sp, matp, depth )
register struct solid *sp;
matp_t matp;
{
	register union record	*rp;
	register struct directory *parentp;
	register struct directory *kidp;
	register int		j;
	auto mat_t		tmat;
	register int		i;

	bn_mat_idn( matp );
	for( i=0; i <= depth; i++ )  {
		parentp = sp->s_path[i];
		kidp = sp->s_path[i+1];
		if( !(parentp->d_flags & DIR_COMB) )  {
			printf("pathHmat:  %s is not a combination\n",
				parentp->d_namep);
			return;		/* ERROR */
		}
		if( (rp = db_getmrec( dbip, parentp )) == (union record *)0 )
			return;		/* ERROR */
		for( j=1; j < parentp->d_len; j++ )  {
			static mat_t xmat;	/* temporary fastf_t matrix */

			/* Examine Member records */
			if( strcmp( kidp->d_namep, rp[j].M.m_instname ) != 0 )
				continue;

			/* convert matrix to fastf_t from disk format */
			rt_mat_dbmat( xmat, rp[j].M.m_mat );
			bn_mat_mul( tmat, matp, xmat );
			bn_mat_copy( matp, tmat );
			goto next_level;
		}
		(void)printf("pathHmat: unable to follow %s/%s path\n",
			parentp->d_namep, kidp->d_namep );
		return;			/* ERROR */
next_level:
		bu_free( (genptr_t)rp, "pathHmat recs");
	}
}
@


11.7
log
@
Added FASTGEN support, fixed some typos
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/path.c,v 11.6 1997/01/02 19:35:05 bparker Exp $ (BRL)";
@


11.6
log
@mods to use libbn and libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/path.c,v 11.5 1996/10/04 15:04:45 bparker Exp bparker $ (BRL)";
d62 1
a62 1
	  bu_vls_printf("nesting exceeds %d levels\n", MAX_PATH );
d64 1
a64 1
	    bu_vls_printf("/%s", cur_path[i]->d_namep );
d106 1
a106 1
	if( rp[0].c.c_flags == 'R' )  {
d119 1
a119 1
	if( drawreg && rp[0].c.c_flags == 'R' && dp->d_len > 1 ) {
@


11.5
log
@-cast bu_free's 1st argument to genptr_t
-use Tcl_AppendResult instead of (f)printf
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/path.c,v 11.4 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d25 1
d27 1
d29 1
d159 1
a159 1
		mat_mul(new_xlate, old_xlate, xmat);
d194 1
a194 1
	mat_idn( matp );
d214 2
a215 2
			mat_mul( tmat, matp, xmat );
			mat_copy( matp, tmat );
@


11.4
log
@now using more generalized solid macros
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/path.c,v 11.3 1996/09/23 18:22:47 bparker Exp bparker $ (BRL)";
d54 1
d56 2
d59 8
a66 5
		(void)printf("nesting exceeds %d levels\n", MAX_PATH );
		for(i=0; i<MAX_PATH; i++)
			(void)printf("/%s", cur_path[i]->d_namep );
		(void)putchar('\n');
		return;			/* ERROR */
d99 3
a101 3
		(void)printf("Warning: combination with zero members \"%s\".\n",
			dp->d_namep );
		goto out;			/* non-fatal ERROR */
d104 6
a109 4
		if( regionid != 0 )
			(void)printf("regionid %d overriden by %d\n",
				regionid, rp[0].c.c_regionid );
		regionid = rp[0].c.c_regionid;
d117 12
a128 13
		if( regmemb >= 0  ) {
			(void)printf(
			"ERROR: region (%s) is member of region (%s)\n",
				dp->d_namep,
				cur_path[reg_pathpos]->d_namep);
			goto out;	/* ERROR */
		}
		/* Well, we are processing regions and this is a region */
		/* if region has only 1 member, don't process as a region */
		if( dp->d_len > 2) {
			regmemb = dp->d_len-1;
			reg_pathpos = pathpos;
		}
d139 3
a141 3
			fprintf(stderr,"drawHobj:  %s bad member rec\n",
				dp->d_namep);
			goto out;			/* ERROR */
d168 2
a169 1
	bu_free( (char *)rp, "drawHobj recs");
d219 1
a219 1
		bu_free( (char *)rp, "pathHmat recs");
@


11.3
log
@changed dm.h to mged_dm.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/path.c,v 11.2 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d28 1
a28 1
#include "./solid.h"
d79 1
a79 1
		GET_SOLID( sp );
d83 1
a83 1
			FREE_SOLID( sp );
@


11.2
log
@now using libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/path.c,v 11.1 1995/01/04 10:03:24 mike Rel4_4 bparker $ (BRL)";
d31 1
a31 1
#include "./dm.h"
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/path.c,v 8.2 88/12/06 01:40:37 mike Exp Locker: mike $ (BRL)";
d161 1
a161 1
	rt_free( (char *)rp, "drawHobj recs");
d211 1
a211 1
		rt_free( (char *)rp, "pathHmat recs");
@


8.2
log
@Converted to new db_*() routines.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/path.c,v 1.3 88/10/29 22:50:32 mike Exp $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 7.5 88/02/25 05:07:53 mike Exp $ (BRL)";
d29 1
a29 1
#include "./objdir.h"
d51 3
a53 4
	static union record rec;	/* local record buffer */
	auto mat_t new_xlate;		/* Accumulated xlation matrix */
	auto int i;
	union record *members;		/* ptr to array of member recs */
d66 2
a67 1
	db_getrec( dp, &rec, 0 );
d69 4
a72 4
	if( rec.u_id == ID_SOLID ||
	    rec.u_id == ID_ARS_A ||
	    rec.u_id == ID_BSOLID ||
	    rec.u_id == ID_P_HEAD )  {
d82 1
a82 1
		if( drawHsolid( sp, flag, pathpos, old_xlate, &rec, regionid ) != 1 ) {
d85 1
a85 1
		return;
d88 3
a90 3
	if( rec.u_id != ID_COMB )  {
		(void)printf("drawobj:  defective input '%c'\n", rec.u_id );
		return;			/* ERROR */
d92 4
a95 4
	if( rec.c.c_length <= 0 )  {
		(void)printf("Warning: combination with zero members \"%.16s\".\n",
			rec.c.c_name );
		return;			/* non-fatal ERROR */
d97 1
a97 1
	if( rec.c.c_flags == 'R' )  {
d100 2
a101 2
				regionid, rec.c.c_regionid );
		regionid = rec.c.c_regionid;
d108 1
a108 1
	if( drawreg && rec.c.c_flags == 'R' && dp->d_len > 1 ) {
d112 1
a112 1
				rec.c.c_name,
d114 1
a114 1
			return;	/* ERROR */
a121 1

d124 5
a128 8
	/* Read all the member records */
	i = sizeof(union record) * (dp->d_len-1);
	if( i <= 0 )  return;				/* OK */
	if( (members = (union record *)malloc(i)) == (union record *)0  )  {
		fprintf(stderr,"drawHobj:  %s malloc failure\n", dp->d_namep);
	    	return;					/* ERROR */
	}
	db_getmany( dp, members, 1, dp->d_len-1 );
d130 1
a130 6
	for( i=0; i < dp->d_len-1; i++ )  {
		register struct member *mp;		/* XXX */
		register struct directory *nextdp;	/* temporary */
		static mat_t xmat;		/* temporary fastf_t matrix */

		mp = &(members[i].M);
d134 1
a134 2
			free( (char *)members );
			return;				/* ERROR */
d141 1
a141 1
		if( (nextdp = lookup( mp->m_instname, LOOKUP_NOISY )) == DIR_NULL )
d160 2
a161 1
	free( (char *)members );
d176 1
d179 3
a181 3
	register int i, j;
	auto mat_t tmat;
	auto union record rec;
d187 7
d198 1
a198 2
			db_getrec( parentp, &rec, j );
			if( strcmp( kidp->d_namep, rec.M.m_instname ) != 0 )
d202 1
a202 1
			rt_mat_dbmat( xmat, rec.M.m_mat );
d209 1
a209 1
		return;
d211 1
a211 1
		;
@


7.5
log
@Added include for dm.h, to handle FREE_VL.
Can be remove when switched to include raytrace.h.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 7.4 87/11/05 07:08:32 mike Locked $ (BRL)";
@


7.4
log
@Changed to use rt_mat_dbmat and rt_dbmat_mat
to convert between database and internal formats.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 7.3 87/11/05 05:59:26 mike Locked $ (BRL)";
d31 1
@


7.3
log
@Added conversion from dbfloat_t to local matrix type.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 7.2 87/11/05 05:06:34 mike Locked $ (BRL)";
d136 1
d155 1
d157 2
a158 8
		/* convert matrix to fastf_t from disk format */
		{
			register int k;
			static mat_t xmat;	/* temporary fastf_t matrix */
			for( k=0; k<4*4; k++ )
				xmat[k] = mp->m_mat[k];
			mat_mul(new_xlate, old_xlate, xmat);
		}
a194 1
			register int k;
d203 1
a203 2
			for( k=0; k<4*4; k++ )
				xmat[k] = rec.M.m_mat[k];
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 7.1 87/11/03 00:01:36 mike Rel $ (BRL)";
d199 3
d204 9
a212 5
			if( strcmp( kidp->d_namep, rec.M.m_instname ) == 0 ) {
				    mat_mul( tmat, matp, rec.M.m_mat );
				    mat_copy( matp, tmat );
				    goto next_level;
			}
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 6.1 87/07/11 08:04:52 mike Rel $ (BRL)";
d25 1
a25 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 5.1 87/06/24 22:21:47 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 4.3 87/06/16 05:27:02 mike Exp $ (BRL)";
@


4.3
log
@More conservative checking of malloc size.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 4.2 87/02/13 00:12:45 mike Locked $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 4.1 86/12/29 03:22:35 mike Rel1 $ (BRL)";
d126 1
d129 1
a129 1
	    	return;
d142 1
a142 1
			return;
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.11 86/08/12 06:50:19 mike Exp $ (BRL)";
@


2.11
log
@Changed #includes for CC -I../h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.10 86/07/17 17:36:54 mike Exp $ (BRL)";
@


2.10
log
@Improved version of fixes from Davisson and Applin
Additional argument added to pathHmat().
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.9 86/03/27 21:23:17 mike Exp $ (BRL)";
d24 1
a24 1
#include	<stdio.h>
d26 5
a30 5
#include "../h/vmath.h"
#include "../h/db.h"
#include "solid.h"
#include "objdir.h"
#include "ged.h"
@


2.9
log
@Added fix from Moss to check for zero length combinations.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.8 86/03/14 20:42:22 mike Exp $ (BRL)";
d179 2
a180 1
 *  the arc indicated in sp->s_path[].
d183 1
a183 1
pathHmat( sp, matp )
d194 1
a194 2
	/* Omit s_path[sp->s_last] -- it's a solid */
	for( i=0; i < sp->s_last; i++ )  {
@


2.8
log
@Added support for the new spline format.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.7 86/03/11 00:11:45 mike Exp $ (BRL)";
d90 5
@


2.7
log
@Changed drawHobj to use db_getmany(), with a
significant speedup as a result.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.6 85/09/14 05:37:17 mike Exp $ (BRL)";
d70 1
a70 1
	    rec.u_id == ID_B_SPL_HEAD ||
d72 1
a72 1
		register struct solid *sp;	/* XXX */
@


2.6
log
@Lint-inspired cleanup.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.5 85/08/07 05:19:29 mike Exp $ (BRL)";
d53 1
d119 9
a127 1
	for( i=1; i < dp->d_len; i++ )  {
d131 7
a137 2
		db_getrec( dp, &rec, i );
		mp = &rec.M;
d141 1
a141 1
			memb_oper = rec.M.m_relation;
d149 8
a156 1
		mat_mul(new_xlate, old_xlate, mp->m_mat);
d167 1
@


2.5
log
@Changed to use common ../h/vmath.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.4 85/05/02 20:16:25 mike Exp $ (BRL)";
d36 1
a36 1
struct directory	*path[MAX_PATH];	/* Record of current path */
d57 1
a57 1
			(void)printf("/%s", path[i]->d_namep );
d75 1
a75 1
		path[pathpos] = dp;
d106 1
a106 1
				path[reg_pathpos]->d_namep);
d124 1
a124 1
		path[pathpos] = dp;
@


2.4
log
@Eliminated silly M_brname stuff.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.3 85/03/15 05:06:21 mike Exp $ (BRL)";
d25 2
a26 1
#include "ged_types.h"
@


2.3
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.2 85/03/12 04:07:26 mike Exp $ (BRL)";
a129 15
		if( mp->m_brname[0] != '\0' )  {
			register struct directory *tdp;		/* XXX */
			/*
			 * Create an alias.  First step towards full
			 * branch naming.  User is responsible for his
			 * branch names being unique.
			 */
			tdp = lookup( mp->m_brname, LOOKUP_QUIET );
			if( tdp != DIR_NULL )
				nextdp = tdp; /* use existing alias */
			else
				nextdp = dir_add( mp->m_brname,
					nextdp->d_addr,	DIR_BRANCH,
					nextdp->d_len );
		}
d172 1
a172 2
			if( strcmp( kidp->d_namep, rec.M.m_instname ) == 0 ||
			    strcmp( kidp->d_namep, rec.M.m_brname ) == 0 )  {
@


2.2
log
@Paul Stay's Spline code.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: path.c,v 2.1 85/03/11 23:56:43 mike Prod $ (BRL)";
d42 1
a42 2
 * but all transformations down the path are done here in
 * drawHobj().
d45 1
a45 1
drawHobj( dp, flag, pathpos, old_xlate )
a60 4
	/* if no memory left DO NOT go further */
	if(no_memory > 0)
		return;

d79 1
a79 1
		if( drawHsolid( sp, flag, pathpos, old_xlate, &rec ) != 1 ) {
d89 6
d156 2
a157 1
			new_xlate
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d73 1
@


1.3
log
@pre-Keith version
@
text
@d1 2
a2 1
/*			P A T H . C
d5 2
a6 2
 *	drawHobj		Call drawsolid for all solids in an object
 *	pathHmat		Find matrix across a given path
d8 11
a18 1
 * The U. S. Army Ballistic Research Laboratory
d20 3
d26 1
a26 1
#include "db.h"
d28 1
a28 1
#include "dir.h"
d165 1
d191 1
a191 1
		printf("pathHmat: unable to follow %s/%s path\n",
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d12 1
a12 1
#include "3d.h"
@


1.1
log
@Initial revision
@
text
@a17 1
long	memb_loc;	/* disk loc of present member of processed region */
d21 1
a21 2
#define	MAXLEVELS	8
struct directory	*path[MAXLEVELS];	/* Record of current path */
d40 3
a42 3
	if( pathpos >= MAXLEVELS )  {
		(void)printf("nesting exceeds %d levels\n", MAXLEVELS );
		for(i=0; i<MAXLEVELS; i++)
a64 1
		memb_loc = dp->d_addr;
d112 1
a112 1
		if( (nextdp = lookup( mp->m_instname, NOISY )) == DIR_NULL )
d121 1
a121 1
			tdp = lookup( mp->m_brname, QUIET );
@
