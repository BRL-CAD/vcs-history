head	1.28;
access;
symbols
	ansi-20040405-merged:1.23.2.2
	postmerge-20040405-ansi:1.25
	premerge-20040404-ansi:1.24
	postmerge-autoconf:1.24
	autoconf-freeze:1.23.10.1
	premerge-autoconf:1.24
	postmerge-20040315-windows:1.24
	premerge-20040315-windows:1.24
	windows-20040315-freeze:1.23.4.1
	autoconf-20031203:1.23
	autoconf-20031202:1.23
	autoconf-branch:1.23.0.10
	phong-branch:1.23.0.8
	photonmap-branch:1.23.0.6
	rel-6-1-DP:1.23
	windows-branch:1.23.0.4
	rel-6-0-2:1.21
	ansi-branch:1.23.0.2
	rel-6-0-1-branch:1.21.0.2
	hartley-6-0-post:1.22
	hartley-6-0-pre:1.21
	rel-6-0-1:1.21
	rel-6-0:1.21
	rel-5-4:1.13.2.3
	offsite-5-3-pre:1.17
	rel-5-3:1.13.2.3
	rel-5-2:1.13
	rel-5-1-branch:1.13.0.2
	rel-5-1:1.13
	rel-5-0:1.11
	rel-5-0-beta:1.11
	rel-4-5:1.1;
locks; strict;
comment	@ * @;


1.28
date	2004.05.21.17.47.43;	author morrison;	state dead;
branches;
next	1.27;

1.27
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.02.17.39.33;	author morrison;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.20.17.08.23;	author jra;	state Exp;
branches
	1.23.2.1
	1.23.4.1
	1.23.10.1;
next	1.22;

1.22
date	2002.08.15.20.55.35;	author hartley;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.05.19.35.45;	author morrison;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.19.22.20.02;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.16.22.43.43;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.18.14.23.14;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.07.02.58.52;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.19.03.10.46;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.02.17.08.41;	author bparker;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.12.30.20.28.41;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	98.12.29.20.34.29;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	98.12.21.21.33.23;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	98.11.06.22.32.41;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	98.10.21.17.05.03;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	98.06.12.19.46.21;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	98.06.11.14.28.14;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	98.05.18.19.35.10;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.04.23.12.54.28;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.02.26.16.18.28;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.02.20.23.06.40;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.02.06.22.27.15;	author bparker;	state Exp;
branches;
next	;

1.13.2.1
date	2000.10.18.14.03.07;	author bparker;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2000.10.18.14.19.18;	author bparker;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.02.09.15.26.31;	author bparker;	state Exp;
branches;
next	;

1.23.2.1
date	2002.09.19.18.02.02;	author morrison;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2004.03.17.21.21.59;	author morrison;	state Exp;
branches;
next	;

1.23.4.1
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

1.23.10.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	;


desc
@routines to draw a grid and "snap" to it
@


1.28
log
@moved to src/mged/
@
text
@/*
 *			G R I D . C
 *
 * Routines to implement MGED's snap to grid capability.
 *
 * Functions -
 *	draw_grid			Draw the grid according to user specifications
 *	snap_to_grid			Snap values to the nearest grid point
 *	snap_view_center_to_grid	Make the grid point nearest the view center
 *					the new view center.
 *
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Author -
 *	Robert G. Parker
 *
 * Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <math.h>
#include <stdio.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"

extern void mged_vls_struct_parse(struct bu_vls *vls, char *title, struct bu_structparse *how_to_parse, char *structp, int argc, char **argv); /* defined in vparse.c */
extern point_t e_axes_pos;  /* from edsol.c */
extern point_t curr_e_axes_pos;  /* from edsol.c */

void draw_grid(void);
void snap_to_grid(fastf_t *mx, fastf_t *my);
static void grid_set_dirty_flag(void);
static void set_grid_draw(void);
static void set_grid_res(void);

struct _grid_state default_grid_state = {
/* gr_rc */		1,
/* gr_draw */		0,
/* gr_snap */		0,
/* gr_anchor */		{ 0.0, 0.0, 0.0 },
/* gr_res_h */		1.0,
/* gr_res_v */		1.0,
/* gr_res_major_h */	5,
/* gr_res_major_v */	5,
};

#define GRID_O(_m)        offsetof(struct _grid_state, _m)
#define GRID_OA(_m)       offsetofarray(struct _grid_state, _m)
struct bu_structparse grid_vparse[] = {
	{"%d",  1, "draw",		GRID_O(gr_draw),		set_grid_draw },
	{"%d",  1, "snap",		GRID_O(gr_snap),		grid_set_dirty_flag },
	{"%f",	3, "anchor",		GRID_OA(gr_anchor),	grid_set_dirty_flag },
	{"%f",	1, "rh",		GRID_O(gr_res_h),		set_grid_res },
	{"%f",	1, "rv",		GRID_O(gr_res_v),		set_grid_res },
	{"%d",  1, "mrh",		GRID_O(gr_res_major_h),	set_grid_res },
	{"%d",  1, "mrv",		GRID_O(gr_res_major_v),	set_grid_res },
	{"",	0,  (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

static void
grid_set_dirty_flag(void)
{
  struct dm_list *dmlp;

  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
    if(dmlp->dml_grid_state == grid_state)
      dmlp->dml_dirty = 1;
}

static void
set_grid_draw(void)
{
  struct dm_list *dlp;

  if (dbip == DBI_NULL) {
	  grid_state->gr_draw = 0;
	  return;
  }

  grid_set_dirty_flag();

  /* This gets done at most one time. */
  if(grid_auto_size && grid_state->gr_draw){
    fastf_t res = view_state->vs_vop->vo_size*base2local / 64.0;

    grid_state->gr_res_h = res;
    grid_state->gr_res_v = res;
    FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
      if(dlp->dml_grid_state == grid_state)
	dlp->dml_grid_auto_size = 0;
  }
}

static void
set_grid_res(void)
{
  struct dm_list *dlp;

  grid_set_dirty_flag();

  if(grid_auto_size)
    FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
      if(dlp->dml_grid_state == grid_state)
	dlp->dml_grid_auto_size = 0;
}

void
draw_grid(void)
{
	register int		i, j;
	register int		nh, nv;
	register int		nv_dots, nh_dots;
	register fastf_t	fx, fy;
	register fastf_t	sf;
	register fastf_t	inv_sf;
	point_t			model_grid_anchor;
	point_t			view_grid_anchor;
	point_t			view_lleft_corner;
	point_t 		view_grid_anchor_local;
	point_t 		view_lleft_corner_local;
	point_t 		view_grid_start_pt_local;
	fastf_t 		inv_grid_res_h;
	fastf_t 		inv_grid_res_v;
	fastf_t 		inv_aspect;

	if (dbip == DBI_NULL ||
	    NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
	    NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
		return;

	inv_grid_res_h= 1.0 / grid_state->gr_res_h;
	inv_grid_res_v= 1.0 / grid_state->gr_res_v;

	sf = view_state->vs_vop->vo_scale*base2local;
	inv_sf = 1.0 / sf;
	inv_aspect = 1.0 / dmp->dm_aspect; 

	nv_dots = 2.0 * inv_aspect * sf * inv_grid_res_v + (2 * grid_state->gr_res_major_v);
	nh_dots = 2.0 * sf * inv_grid_res_h + (2 * grid_state->gr_res_major_h);

	/* sanity - don't draw the grid if it would fill the screen */
	{
		int	nh_lines;
		int	nv_lines;
		int	ngridpoints;
		int	npixels;

		nh_lines = nv_dots / grid_state->gr_res_major_v + 1;
		nv_lines = nh_dots / grid_state->gr_res_major_h + 1;
		npixels = dmp->dm_width * dmp->dm_height;
		ngridpoints = (nh_dots * nh_lines + nv_dots * nv_lines) * 2;

		if (ngridpoints > npixels)
			return;
	}
	

	VSCALE(model_grid_anchor, grid_state->gr_anchor, local2base);
	MAT4X3PNT(view_grid_anchor, view_state->vs_vop->vo_model2view, model_grid_anchor);
	VSCALE(view_grid_anchor_local, view_grid_anchor, sf);

	VSET(view_lleft_corner, -1.0, -inv_aspect, 0.0);
	VSCALE(view_lleft_corner_local, view_lleft_corner, sf);
	nh = (view_grid_anchor_local[X] - view_lleft_corner_local[X]) * inv_grid_res_h;
	nv = (view_grid_anchor_local[Y] - view_lleft_corner_local[Y]) * inv_grid_res_v;

	{
		int nmh, nmv;

		nmh = nh / grid_state->gr_res_major_h + 1;
		nmv = nv / grid_state->gr_res_major_v + 1;
		VSET(view_grid_start_pt_local,
		     view_grid_anchor_local[X] - (nmh * grid_state->gr_res_h * grid_state->gr_res_major_h),
		     view_grid_anchor_local[Y] - (nmv * grid_state->gr_res_v * grid_state->gr_res_major_v),
		     0.0);
	}

	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_grid[0], 
		       color_scheme->cs_grid[1],
		       color_scheme->cs_grid[2], 1, 1.0);
	DM_SET_LINE_ATTR(dmp, 1, 0);		/* solid lines */

	/* draw horizontal dots */
	for (i = 0; i < nv_dots; i += grid_state->gr_res_major_v) {
		fy = (view_grid_start_pt_local[Y] + (i * grid_state->gr_res_v)) * inv_sf;

		for (j = 0; j < nh_dots; ++j) {
			fx = (view_grid_start_pt_local[X] + (j * grid_state->gr_res_h)) * inv_sf;
			DM_DRAW_POINT_2D(dmp, fx, fy * dmp->dm_aspect);
		}
	}

	/* draw vertical dots */
	if (grid_state->gr_res_major_v != 1) {
		for (i = 0; i < nh_dots; i += grid_state->gr_res_major_h) {
			fx = (view_grid_start_pt_local[X] + (i * grid_state->gr_res_h)) * inv_sf;

			for (j = 0; j < nv_dots; ++j) {
				fy = (view_grid_start_pt_local[Y] + (j * grid_state->gr_res_v)) * inv_sf;
				DM_DRAW_POINT_2D(dmp, fx, fy * dmp->dm_aspect);
			}
		}
	}
}

void
snap_to_grid(
	fastf_t *mx,		/* input and return values */
	fastf_t *my)		/* input and return values */
{
  register int nh, nv;		/* whole grid units */
  point_t view_pt;
  point_t view_grid_anchor;
  point_t model_grid_anchor;
  fastf_t grid_units_h;		/* eventually holds only fractional horizontal grid units */
  fastf_t grid_units_v;		/* eventually holds only fractional vertical grid units */
  register fastf_t sf;
  register fastf_t inv_sf;

  if (dbip == DBI_NULL ||
      NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
      NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
    return;

  sf = view_state->vs_vop->vo_scale*base2local;
  inv_sf = 1 / sf;

  VSET(view_pt, *mx, *my, 0.0);
  VSCALE(view_pt, view_pt, sf);  /* view_pt now in local units */

  VSCALE(model_grid_anchor, grid_state->gr_anchor, local2base);
  MAT4X3PNT(view_grid_anchor, view_state->vs_vop->vo_model2view, model_grid_anchor);
  VSCALE(view_grid_anchor, view_grid_anchor, sf);  /* view_grid_anchor now in local units */

  grid_units_h = (view_grid_anchor[X] - view_pt[X]) / grid_state->gr_res_h;
  grid_units_v = (view_grid_anchor[Y] - view_pt[Y]) / grid_state->gr_res_v;
  nh = grid_units_h;
  nv = grid_units_v;

  grid_units_h -= nh;		/* now contains only the fraction part */
  grid_units_v -= nv;		/* now contains only the fraction part */

  if(grid_units_h <= -0.5)
    *mx = view_grid_anchor[X] - ((nh - 1) * grid_state->gr_res_h);
  else if(0.5 <= grid_units_h)
    *mx = view_grid_anchor[X] - ((nh + 1) * grid_state->gr_res_h);
  else
    *mx = view_grid_anchor[X] - (nh * grid_state->gr_res_h);

  if(grid_units_v <= -0.5)
    *my = view_grid_anchor[Y] - ((nv - 1) * grid_state->gr_res_v);
  else if(0.5 <= grid_units_v)
    *my = view_grid_anchor[Y] - ((nv + 1) * grid_state->gr_res_v);
  else
    *my = view_grid_anchor[Y] - (nv  * grid_state->gr_res_v);

  *mx *= inv_sf;
  *my *= inv_sf;
}

void
snap_keypoint_to_grid(void)
{
  point_t view_pt;
  point_t model_pt;
  struct bu_vls cmd;

  if (dbip == DBI_NULL)
	  return;

  if (state != ST_S_EDIT && state != ST_O_EDIT) {
	  bu_log("snap_keypoint_to_grid: must be in an edit state\n");
	  return;
  }

  if (state == ST_S_EDIT) {
	  MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
  } else {
	  MAT4X3PNT(model_pt, modelchanges, e_axes_pos);
	  MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, model_pt);
  }
  snap_to_grid(&view_pt[X], &view_pt[Y]);
  MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
  VSCALE(model_pt, model_pt, base2local);

  bu_vls_init(&cmd);
  if (state == ST_S_EDIT)
	  bu_vls_printf(&cmd, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
  else
	  bu_vls_printf(&cmd, "translate %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
  (void)Tcl_Eval(interp, bu_vls_addr(&cmd));
  bu_vls_free(&cmd);

  /* save model_pt in local units */
  VMOVE(dml_work_pt, model_pt);
  dml_mouse_dx = dml_mouse_dy = 0;
}

void
snap_view_center_to_grid(void)
{
	point_t view_pt, model_pt;

	if (dbip == DBI_NULL)
		return;

	MAT_DELTAS_GET_NEG(model_pt, view_state->vs_vop->vo_center);
	MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, model_pt);
	snap_to_grid(&view_pt[X], &view_pt[Y]);
	MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);

	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, model_pt);
	new_mats();

	VSCALE(model_pt, model_pt, base2local);

	/* save new center in local units */
	VMOVE(dml_work_pt, model_pt);
	dml_mouse_dx = dml_mouse_dy = 0;
}

/*
 * Expect values in the +-2.0 range,
 * Return values in the +-2.0 range that have been snapped to the nearest grid distance.
 */
void
round_to_grid(fastf_t *view_dx, fastf_t *view_dy)
{
  fastf_t grid_units_h, grid_units_v;
  fastf_t sf, inv_sf;
  int nh, nv;

  if (dbip == DBI_NULL ||
      NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
      NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
    return;

  sf = view_state->vs_vop->vo_scale*base2local;
  inv_sf = 1 / sf;

  /* convert mouse distance to grid units */
  grid_units_h = *view_dx * sf / grid_state->gr_res_h;
  grid_units_v = *view_dy * sf /  grid_state->gr_res_v;
  nh = grid_units_h;
  nv = grid_units_v;
  grid_units_h -= nh;
  grid_units_v -= nv;

  if(grid_units_h <= -0.5)
    *view_dx = (nh - 1) * grid_state->gr_res_h;
  else if(0.5 <= grid_units_h)
    *view_dx = (nh + 1) * grid_state->gr_res_h;
  else
    *view_dx = nh * grid_state->gr_res_h;

  if(grid_units_v <= -0.5)
    *view_dy = (nv - 1) * grid_state->gr_res_v;
  else if(0.5 <= grid_units_v)
    *view_dy = (nv + 1) * grid_state->gr_res_v;
  else
    *view_dy = nv * grid_state->gr_res_v;

  *view_dx *= inv_sf;
  *view_dy *= inv_sf;
}

void
snap_view_to_grid(fastf_t view_dx, fastf_t view_dy)
{
  point_t model_pt, view_pt;
  point_t vcenter, diff;

  if (dbip == DBI_NULL ||
      NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
      NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
    return;

  round_to_grid(&view_dx, &view_dy);

  VSET(view_pt, view_dx, view_dy, 0.0);

  MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
  MAT_DELTAS_GET_NEG(vcenter, view_state->vs_vop->vo_center);
  VSUB2(diff, model_pt, vcenter);
  VSCALE(diff, diff, base2local);
  VSUB2(model_pt, dml_work_pt, diff);

  VSCALE(model_pt, model_pt, local2base);
  MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, model_pt);
  new_mats();
}

void
update_grids(fastf_t sf)
{
  register struct dm_list *dlp;
  struct bu_vls save_result;
  struct bu_vls cmd;

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l){
    dlp->dml_grid_state->gr_res_h *= sf;
    dlp->dml_grid_state->gr_res_v *= sf;
    VSCALE(dlp->dml_grid_state->gr_anchor, dlp->dml_grid_state->gr_anchor, sf);
  }

  bu_vls_init(&save_result);
  bu_vls_init(&cmd);

  bu_vls_strcpy(&save_result, interp->result);

  bu_vls_printf(&cmd, "grid_control_update %lf\n", sf);
  (void)Tcl_Eval(interp, bu_vls_addr(&cmd));

  Tcl_SetResult(interp, bu_vls_addr(&save_result), TCL_VOLATILE);

  bu_vls_free(&save_result);
  bu_vls_free(&cmd);
}

int
f_grid_set (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct bu_vls vls;

  bu_vls_init(&vls);

  if(argc < 1 || 5 < argc){
    bu_vls_printf(&vls, "help grid_set");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  mged_vls_struct_parse(&vls, "Grid", grid_vparse,
			(const char *)grid_state, argc, argv);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}
@


1.27
log
@change conf.h to a wrapped config.h
@
text
@@


1.26
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d28 5
a32 1
#include "conf.h"
@


1.25
log
@merge of ansi-6-0-branch into HEAD
@
text
@d195 1
a195 1
		       color_scheme->cs_grid[2], 1);
@


1.24
log
@update copyright to include span through 2003
@
text
@d40 1
a40 1
extern void mged_vls_struct_parse(); /* defined in vparse.c */
d44 5
a48 5
void draw_grid();
void snap_to_grid();
static void grid_set_dirty_flag();
static void set_grid_draw();
static void set_grid_res();
d75 1
a75 1
grid_set_dirty_flag()
d85 1
a85 1
set_grid_draw()
d109 1
a109 1
set_grid_res()
d122 1
a122 1
draw_grid()
d277 1
a277 1
snap_keypoint_to_grid()
d315 1
a315 1
snap_view_center_to_grid()
d409 1
a409 2
update_grids(sf)
fastf_t sf;
d436 1
a436 5
f_grid_set (clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
@


1.23
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1998 by the United States Army.
@


1.23.4.1
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
@


1.23.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
@


1.23.2.1
log
@Initial ANSIfication
@
text
@d40 1
a40 1
extern void mged_vls_struct_parse(struct bu_vls *vls, char *title, struct bu_structparse *how_to_parse, char *structp, int argc, char **argv); /* defined in vparse.c */
d44 5
a48 5
void draw_grid(void);
void snap_to_grid(fastf_t *mx, fastf_t *my);
static void grid_set_dirty_flag(void);
static void set_grid_draw(void);
static void set_grid_res(void);
d75 1
a75 1
grid_set_dirty_flag(void)
d85 1
a85 1
set_grid_draw(void)
d109 1
a109 1
set_grid_res(void)
d122 1
a122 1
draw_grid(void)
d277 1
a277 1
snap_keypoint_to_grid(void)
d315 1
a315 1
snap_view_center_to_grid(void)
d409 2
a410 1
update_grids(fastf_t sf)
d437 5
a441 1
f_grid_set (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.23.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
@


1.22
log
@Converted from K&R to ANSI C - RFH
@
text
@d40 1
a40 1
extern void mged_vls_struct_parse(struct bu_vls *vls, char *title, struct bu_structparse *how_to_parse, char *structp, int argc, char **argv); /* defined in vparse.c */
d44 5
a48 5
void draw_grid(void);
void snap_to_grid(fastf_t *mx, fastf_t *my);
static void grid_set_dirty_flag(void);
static void set_grid_draw(void);
static void set_grid_res(void);
d75 1
a75 1
grid_set_dirty_flag(void)
d85 1
a85 1
set_grid_draw(void)
d109 1
a109 1
set_grid_res(void)
d122 1
a122 1
draw_grid(void)
d277 1
a277 1
snap_keypoint_to_grid(void)
d315 1
a315 1
snap_view_center_to_grid(void)
d409 2
a410 1
update_grids(fastf_t sf)
d437 5
a441 1
f_grid_set (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.21
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d40 1
a40 1
extern void mged_vls_struct_parse(); /* defined in vparse.c */
d44 5
a48 5
void draw_grid();
void snap_to_grid();
static void grid_set_dirty_flag();
static void set_grid_draw();
static void set_grid_res();
d75 1
a75 1
grid_set_dirty_flag()
d85 1
a85 1
set_grid_draw()
d109 1
a109 1
set_grid_res()
d122 1
a122 1
draw_grid()
d277 1
a277 1
snap_keypoint_to_grid()
d315 1
a315 1
snap_view_center_to_grid()
d409 1
a409 2
update_grids(sf)
fastf_t sf;
d436 1
a436 5
f_grid_set (clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
@


1.20
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@a97 1
#ifdef MGED_USE_VIEW_OBJ
a98 3
#else
    fastf_t res = VIEWSIZE*base2local / 64.0;
#endif
a147 1
#ifdef MGED_USE_VIEW_OBJ
a148 3
#else
	sf = view_state->vs_Viewscale*base2local;
#endif
a172 1
#ifdef MGED_USE_VIEW_OBJ
a173 3
#else
	MAT4X3PNT(view_grid_anchor, view_state->vs_model2view, model_grid_anchor);
#endif
a239 1
#ifdef MGED_USE_VIEW_OBJ
a240 3
#else
  sf = view_state->vs_Viewscale*base2local;
#endif
a246 1
#ifdef MGED_USE_VIEW_OBJ
a247 3
#else
  MAT4X3PNT(view_grid_anchor, view_state->vs_model2view, model_grid_anchor);
#endif
a290 1
#ifdef MGED_USE_VIEW_OBJ
a298 10
#else
  if (state == ST_S_EDIT) {
	  MAT4X3PNT(view_pt, view_state->vs_model2view, curr_e_axes_pos);
  } else {
	  MAT4X3PNT(model_pt, modelchanges, e_axes_pos);
	  MAT4X3PNT(view_pt, view_state->vs_model2view, model_pt);
  }
  snap_to_grid(&view_pt[X], &view_pt[Y]);
  MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
#endif
a321 1
#ifdef MGED_USE_VIEW_OBJ
a327 8
#else
	MAT_DELTAS_GET_NEG(model_pt, view_state->vs_toViewcenter);
	MAT4X3PNT(view_pt, view_state->vs_model2view, model_pt);
	snap_to_grid(&view_pt[X], &view_pt[Y]);
	MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);

	MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, model_pt);
#endif
a352 1
#ifdef MGED_USE_VIEW_OBJ
a353 3
#else
  sf = view_state->vs_Viewscale*base2local;
#endif
a396 1
#ifdef MGED_USE_VIEW_OBJ
a398 4
#else
  MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
  MAT_DELTAS_GET_NEG(vcenter, view_state->vs_toViewcenter);
#endif
a403 1
#ifdef MGED_USE_VIEW_OBJ
a404 3
#else
  MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, model_pt);
#endif
@


1.19
log
@updated SIGNED to signed
updated CONST to const
@
text
@d98 3
d102 1
d152 3
d156 1
d181 3
d185 1
d252 3
d256 1
d263 3
d267 1
d311 10
d329 1
d348 1
a348 1
  point_t view_pt, model_pt;
d350 2
a351 2
  if (dbip == DBI_NULL)
	  return;
d353 22
a374 13
  MAT_DELTAS_GET_NEG(model_pt, view_state->vs_toViewcenter);
  MAT4X3PNT(view_pt, view_state->vs_model2view, model_pt);
  snap_to_grid(&view_pt[X], &view_pt[Y]);
  MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);

  MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, model_pt);
  new_mats();

  VSCALE(model_pt, model_pt, base2local);

  /* save new center in local units */
  VMOVE(dml_work_pt, model_pt);
  dml_mouse_dx = dml_mouse_dy = 0;
d393 3
d397 1
d440 5
a445 1

d447 1
d453 3
d457 1
@


1.18
log
@patches to merge 5.3 into 6.0
@
text
@d456 1
a456 1
			(CONST char *)grid_state, argc, argv);
@


1.17
log
@*- check if (dbip == DBI_NULL) before doing anything
@
text
@d93 1
@


1.16
log
@Mods to make snap-to-grid work while in Object Edit.
@
text
@d89 4
d139 2
a140 1
	if (NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
d234 3
a236 2
  if(NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
     NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
d282 3
d318 3
d347 3
a349 2
  if(NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
     NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
d387 3
a389 2
  if(NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
     NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
@


1.15
log
@
Added externs to ged.h to quiet down lint
@
text
@d41 2
a42 1
extern vect_t curr_e_axes_pos;  /* from edsol.c */
d276 11
a286 1
  MAT4X3PNT(view_pt, view_state->vs_model2view, curr_e_axes_pos);
d292 4
a295 1
  bu_vls_printf(&cmd, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
@


1.14
log
@
const RCSid
@
text
@d215 3
a217 3
snap_to_grid(mx, my)
fastf_t *mx;		/* input and return values */
fastf_t *my;		/* input and return values */
d315 1
a315 2
round_to_grid(view_dx, view_dy)
fastf_t *view_dx, *view_dy;
d355 1
a355 2
snap_view_to_grid(view_dx, view_dy)
fastf_t view_dx, view_dy;
@


1.13
log
@Don't draw the grid if it would fill the screen.
@
text
@d25 1
a25 1
static char RCSid[] = "";
@


1.13.2.1
log
@Mods to make snap-to-grid work in Object Edit
@
text
@a40 1
extern point_t e_axes_pos;  /* from edsol.c */
d275 1
a275 6
  if (state == ST_S_EDIT) {
	  MAT4X3PNT(view_pt, view_state->vs_model2view, curr_e_axes_pos);
  } else {
	  MAT4X3PNT(model_pt, modelchanges, e_axes_pos);
	  MAT4X3PNT(view_pt, view_state->vs_model2view, model_pt);
  }
@


1.13.2.2
log
@More code from the developmental sources
to support snap-to-grid while in Object Edit.
@
text
@d287 1
a287 4
  if (state == ST_S_EDIT)
	  bu_vls_printf(&cmd, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
  else
	  bu_vls_printf(&cmd, "translate %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
@


1.13.2.3
log
@Mods that check if dbip==DBI_NULL
@
text
@a88 5
  if (dbip == DBI_NULL) {
	  grid_state->gr_draw = 0;
	  return;
  }

d135 1
a135 2
	if (dbip == DBI_NULL ||
	    NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
d229 2
a230 3
  if (dbip == DBI_NULL ||
      NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
      NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
a275 8
  if (dbip == DBI_NULL)
	  return;

  if (state != ST_S_EDIT && state != ST_O_EDIT) {
	  bu_log("snap_keypoint_to_grid: must be in an edit state\n");
	  return;
  }

a303 3
  if (dbip == DBI_NULL)
	  return;

d331 2
a332 3
  if (dbip == DBI_NULL ||
      NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
      NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
d371 2
a372 3
  if (dbip == DBI_NULL ||
      NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
      NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
@


1.12
log
@Eliminated some unused variables
@
text
@d118 94
a211 77
  register int i, j;
  register int nh, nv;
  register int nh_lines, nv_lines;
  register fastf_t fx, fy;
  register fastf_t sf;
  register fastf_t inv_sf;
  point_t model_grid_anchor;
  point_t view_grid_anchor;
  point_t view_lleft_corner;
  point_t view_grid_anchor_local;
  point_t view_lleft_corner_local;
  point_t view_grid_start_pt_local;
  fastf_t inv_grid_res_h;
  fastf_t inv_grid_res_v;
  fastf_t inv_aspect;

  if(NEAR_ZERO(grid_state->gr_res_h, (fastf_t)SMALL_FASTF) ||
     NEAR_ZERO(grid_state->gr_res_v, (fastf_t)SMALL_FASTF))
    return;

  inv_grid_res_h= 1.0 / grid_state->gr_res_h;
  inv_grid_res_v= 1.0 / grid_state->gr_res_v;

  sf = view_state->vs_Viewscale*base2local;
  inv_sf = 1.0 / sf;
  inv_aspect = 1.0 / dmp->dm_aspect; 

  VSCALE(model_grid_anchor, grid_state->gr_anchor, local2base);
  MAT4X3PNT(view_grid_anchor, view_state->vs_model2view, model_grid_anchor);
  VSCALE(view_grid_anchor_local, view_grid_anchor, sf);

  VSET(view_lleft_corner, -1.0, -inv_aspect, 0.0);
  VSCALE(view_lleft_corner_local, view_lleft_corner, sf);
  nh = (view_grid_anchor_local[X] - view_lleft_corner_local[X]) * inv_grid_res_h;
  nv = (view_grid_anchor_local[Y] - view_lleft_corner_local[Y]) * inv_grid_res_v;

  {
    int nmh, nmv;

    nmh = nh / grid_state->gr_res_major_h + 1;
    nmv = nv / grid_state->gr_res_major_v + 1;
    VSET(view_grid_start_pt_local,
	 view_grid_anchor_local[X] - (nmh * grid_state->gr_res_h * grid_state->gr_res_major_h),
	 view_grid_anchor_local[Y] - (nmv * grid_state->gr_res_v * grid_state->gr_res_major_v),
	 0.0);
  }

  nh_lines = 2.0 * inv_aspect * sf * inv_grid_res_v + (2 * grid_state->gr_res_major_v);
  nv_lines = 2.0 * sf * inv_grid_res_h + (2 * grid_state->gr_res_major_h);

  DM_SET_FGCOLOR(dmp,
	       color_scheme->cs_grid[0], 
	       color_scheme->cs_grid[1],
	       color_scheme->cs_grid[2], 1);
  DM_SET_LINE_ATTR(dmp, 1, 0);		/* solid lines */

  /* draw horizontal dots */
  for(i = 0; i < nh_lines; i += grid_state->gr_res_major_v){
    fy = (view_grid_start_pt_local[Y] + (i * grid_state->gr_res_v)) * inv_sf;

    for(j = 0; j < nv_lines; ++j){
      fx = (view_grid_start_pt_local[X] + (j * grid_state->gr_res_h)) * inv_sf;
      DM_DRAW_POINT_2D(dmp, fx, fy * dmp->dm_aspect);
    }
  }

  /* draw vertical dots */
  if(grid_state->gr_res_major_v != 1){
    for(i = 0; i < nv_lines; i += grid_state->gr_res_major_h){
      fx = (view_grid_start_pt_local[X] + (i * grid_state->gr_res_h)) * inv_sf;

      for(j = 0; j < nh_lines; ++j){
	fy = (view_grid_start_pt_local[Y] + (j * grid_state->gr_res_v)) * inv_sf;
	DM_DRAW_POINT_2D(dmp, fx, fy * dmp->dm_aspect);
      }
    }
  }
@


1.11
log
@*- add declaration for mged_vls_struct_parse()
@
text
@a126 1
  point_t grid_start_pt;
a129 2
  point_t mpt1, mpt2;
  point_t vpt1, vpt2;
a302 1
  fastf_t dx, dy;
@


1.10
log
@*- mods to draw grid properly with non-square windows
@
text
@d40 1
@


1.9
log
@*- use new structures
*- cleanup
@
text
@d134 1
d144 2
a145 1
  inv_sf = 1 / sf;
d151 1
a151 1
  VSET(view_lleft_corner, -1.0, -1.0, 0.0);
d167 1
a167 1
  nh_lines = 2.0 * sf * inv_grid_res_v + (2 * grid_state->gr_res_major_v);
@


1.8
log
@*- use color scheme variables
@
text
@d7 1
a7 1
 *	draw_grid			Draw the grid according to user specification
d44 27
d72 31
a102 6
#if 0
f_grid(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d104 8
a112 1
#endif
d135 2
a136 2
  if(NEAR_ZERO(mged_variables->grid_res_h, (fastf_t)SMALL_FASTF) ||
     NEAR_ZERO(mged_variables->grid_res_v, (fastf_t)SMALL_FASTF))
d139 2
a140 2
  inv_grid_res_h= 1.0 / mged_variables->grid_res_h;
  inv_grid_res_v= 1.0 / mged_variables->grid_res_v;
d142 1
a142 1
  sf = Viewscale*base2local;
d145 2
a146 2
  VSCALE(model_grid_anchor, mged_variables->grid_anchor, local2base);
  MAT4X3PNT(view_grid_anchor, model2view, model_grid_anchor);
d157 2
a158 2
    nmh = nh / mged_variables->grid_res_major_h + 1;
    nmv = nv / mged_variables->grid_res_major_v + 1;
d160 2
a161 2
	 view_grid_anchor_local[X] - (nmh * mged_variables->grid_res_h * mged_variables->grid_res_major_h),
	 view_grid_anchor_local[Y] - (nmv * mged_variables->grid_res_v * mged_variables->grid_res_major_v),
d165 2
a166 2
  nh_lines = 2.0 * sf * inv_grid_res_v + (2 * mged_variables->grid_res_major_v);
  nv_lines = 2.0 * sf * inv_grid_res_h + (2 * mged_variables->grid_res_major_h);
d169 3
a171 3
	       color_scheme->grid[0], 
	       color_scheme->grid[1],
	       color_scheme->grid[2], 1);
d175 2
a176 2
  for(i = 0; i < nh_lines; i += mged_variables->grid_res_major_v){
    fy = (view_grid_start_pt_local[Y] + (i * mged_variables->grid_res_v)) * inv_sf;
d179 1
a179 1
      fx = (view_grid_start_pt_local[X] + (j * mged_variables->grid_res_h)) * inv_sf;
d185 3
a187 3
  if(mged_variables->grid_res_major_v != 1){
    for(i = 0; i < nv_lines; i += mged_variables->grid_res_major_h){
      fx = (view_grid_start_pt_local[X] + (i * mged_variables->grid_res_h)) * inv_sf;
d190 1
a190 1
	fy = (view_grid_start_pt_local[Y] + (j * mged_variables->grid_res_v)) * inv_sf;
d211 2
a212 2
  if(NEAR_ZERO(mged_variables->grid_res_h, (fastf_t)SMALL_FASTF) ||
     NEAR_ZERO(mged_variables->grid_res_v, (fastf_t)SMALL_FASTF))
d215 1
a215 1
  sf = Viewscale*base2local;
d221 2
a222 2
  VSCALE(model_grid_anchor, mged_variables->grid_anchor, local2base);
  MAT4X3PNT(view_grid_anchor, model2view, model_grid_anchor);
d225 2
a226 2
  grid_units_h = (view_grid_anchor[X] - view_pt[X]) / mged_variables->grid_res_h;
  grid_units_v = (view_grid_anchor[Y] - view_pt[Y]) / mged_variables->grid_res_v;
d234 1
a234 1
    *mx = view_grid_anchor[X] - ((nh - 1) * mged_variables->grid_res_h);
d236 1
a236 1
    *mx = view_grid_anchor[X] - ((nh + 1) * mged_variables->grid_res_h);
d238 1
a238 1
    *mx = view_grid_anchor[X] - (nh * mged_variables->grid_res_h);
d241 1
a241 1
    *my = view_grid_anchor[Y] - ((nv - 1) * mged_variables->grid_res_v);
d243 1
a243 1
    *my = view_grid_anchor[Y] - ((nv + 1) * mged_variables->grid_res_v);
d245 1
a245 1
    *my = view_grid_anchor[Y] - (nv  * mged_variables->grid_res_v);
d258 1
a258 1
  MAT4X3PNT(view_pt, model2view, curr_e_axes_pos);
d260 1
a260 1
  MAT4X3PNT(model_pt, view2model, view_pt);
d278 2
a279 2
  MAT_DELTAS_GET_NEG(model_pt, toViewcenter);
  MAT4X3PNT(view_pt, model2view, model_pt);
d281 1
a281 1
  MAT4X3PNT(model_pt, view2model, view_pt);
d283 1
a283 1
  MAT_DELTAS_VEC_NEG(toViewcenter, model_pt);
d306 2
a307 2
  if(NEAR_ZERO(mged_variables->grid_res_h, (fastf_t)SMALL_FASTF) ||
     NEAR_ZERO(mged_variables->grid_res_v, (fastf_t)SMALL_FASTF))
d310 1
a310 1
  sf = Viewscale*base2local;
d314 2
a315 2
  grid_units_h = *view_dx * sf / mged_variables->grid_res_h;
  grid_units_v = *view_dy * sf /  mged_variables->grid_res_v;
d322 1
a322 1
    *view_dx = (nh - 1) * mged_variables->grid_res_h;
d324 1
a324 1
    *view_dx = (nh + 1) * mged_variables->grid_res_h;
d326 1
a326 1
    *view_dx = nh * mged_variables->grid_res_h;
d329 1
a329 1
    *view_dy = (nv - 1) * mged_variables->grid_res_v;
d331 1
a331 1
    *view_dy = (nv + 1) * mged_variables->grid_res_v;
d333 1
a333 1
    *view_dy = nv * mged_variables->grid_res_v;
d346 2
a347 2
  if(NEAR_ZERO(mged_variables->grid_res_h, (fastf_t)SMALL_FASTF) ||
     NEAR_ZERO(mged_variables->grid_res_v, (fastf_t)SMALL_FASTF))
d353 1
a353 1
  MAT4X3PNT(model_pt, view2model, view_pt);
d355 1
a355 1
  MAT_DELTAS_GET_NEG(vcenter, toViewcenter);
d361 1
a361 1
  MAT_DELTAS_VEC_NEG(toViewcenter, model_pt);
d374 3
a376 3
    dlp->_mged_variables->grid_res_h *= sf;
    dlp->_mged_variables->grid_res_v *= sf;
    VSCALE(dlp->_mged_variables->grid_anchor, dlp->_mged_variables->grid_anchor, sf);
d391 27
@


1.7
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@d110 3
a112 3
	       mged_variables->grid_color[0], 
	       mged_variables->grid_color[1],
	       mged_variables->grid_color[2], 1);
@


1.6
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d109 1
a109 1
  DM_SET_COLOR(dmp,
@


1.5
log
@*- mods for pjt demo
@
text
@a27 1
#ifdef DO_SNAP_TO_GRID
a332 1
#endif
@


1.4
log
@*** empty log message ***
@
text
@d122 1
a122 1
      DM_DRAW_POINT_2D(dmp, fx, fy);
d133 1
a133 1
	DM_DRAW_POINT_2D(dmp, fx, fy);
@


1.3
log
@*- added snap_keypoint_to_grid(), round_to_grid()
*- mods to draw_grid()
@
text
@d46 10
@


1.2
log
@*- added update_grids(), snap_view_to_grid() and snap_grid_to_view_center()
*- mods to draw_grid()
@
text
@d9 1
a9 1
 *	snap_grid_to_view_center	Make the grid point nearest the view center
d41 2
d184 23
a206 1
snap_grid_to_view_center()
a208 1
  struct bu_vls vls;
d225 4
d230 2
a231 2
snap_view_to_grid(view_dx, view_dy)
fastf_t view_dx, view_dy;
a232 3
  struct bu_vls vls;
  point_t model_pt, view_pt;
  point_t vcenter, diff;
d246 2
a247 2
  grid_units_h = view_dx * sf / mged_variables->grid_res_h;
  grid_units_v = view_dy * sf /  mged_variables->grid_res_v;
d254 1
a254 1
    dx = (nh - 1) * mged_variables->grid_res_h;
d256 1
a256 1
    dx = (nh + 1) * mged_variables->grid_res_h;
d258 1
a258 1
    dx = nh * mged_variables->grid_res_h;
d261 1
a261 1
    dy = (nv - 1) * mged_variables->grid_res_v;
d263 1
a263 1
    dy = (nv + 1) * mged_variables->grid_res_v;
d265 18
a282 1
    dy = nv * mged_variables->grid_res_v;
d284 1
a284 2
  VSET(view_pt, dx, dy, 0.0);
  VSCALE(view_pt, view_pt, inv_sf);
@


1.1
log
@Initial revision
@
text
@d7 4
a10 2
 *	draw_grid	draw the grid according to user specification
 *	snap_to_grid	snap values to the nearest grid point
d48 2
a49 2
  register nh, nv;
  register nh_lines, nv_lines;
d65 3
a67 2
  sf = Viewscale*base2local;
  inv_sf = 1 / sf;
d72 3
a82 4
  VSET(view_grid_start_pt_local,
       view_grid_anchor_local[X] - (nh * mged_variables->grid_res_h),
       view_grid_anchor_local[Y] - (nv * mged_variables->grid_res_v),
       0.0);
d84 2
a85 2
  nh_lines = 2.0 * sf * inv_grid_res_v + 2;
  nv_lines = 2.0 * sf * inv_grid_res_h + 2;
d87 11
d102 1
d132 1
a132 1
  register int nh, nv;
d136 2
a137 2
  fastf_t grid_units_h;
  fastf_t grid_units_v;
d141 4
d179 104
@
