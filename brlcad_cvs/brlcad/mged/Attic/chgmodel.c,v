head	11.147;
access;
symbols
	ansi-20040405-merged:11.140.2.4
	postmerge-20040405-ansi:11.145
	premerge-20040404-ansi:11.144
	postmerge-autoconf:11.144
	autoconf-freeze:11.142.6.3
	premerge-autoconf:11.144
	postmerge-20040315-windows:11.144
	premerge-20040315-windows:11.143
	windows-20040315-freeze:11.140.4.2
	autoconf-20031203:11.142
	autoconf-20031202:11.142
	autoconf-branch:11.142.0.6
	phong-branch:11.142.0.4
	photonmap-branch:11.142.0.2
	rel-6-1-DP:11.140
	windows-branch:11.140.0.4
	rel-6-0-2:11.138
	ansi-branch:11.140.0.2
	rel-6-0-1-branch:11.138.0.2
	hartley-6-0-post:11.139
	hartley-6-0-pre:11.138
	rel-6-0-1:11.138
	rel-6-0:11.137
	rel-5-4:11.98.2.2
	offsite-5-3-pre:11.110
	rel-5-3:11.98.2.2
	rel-5-2:11.98
	rel-5-1-branch:11.98.0.2
	rel-5-1:11.98
	rel-5-0:11.82
	rel-5-0-beta:11.79
	rel-4-5:11.62
	ctj-4-5-post:11.57
	ctj-4-5-pre:11.57
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.8;
locks; strict;
comment	@ * @;


11.147
date	2004.05.21.17.47.36;	author morrison;	state dead;
branches;
next	11.146;

11.146
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.145;

11.145
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.144;

11.144
date	2004.03.16.21.15.10;	author morrison;	state Exp;
branches;
next	11.143;

11.143
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.142;

11.142
date	2003.01.31.13.39.05;	author jra;	state Exp;
branches
	11.142.6.1;
next	11.141;

11.141
date	2002.11.27.13.43.47;	author jra;	state Exp;
branches;
next	11.140;

11.140
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	11.140.2.1
	11.140.4.1;
next	11.139;

11.139
date	2002.08.15.20.55.32;	author hartley;	state Exp;
branches;
next	11.138;

11.138
date	2002.04.16.02.34.58;	author jra;	state Exp;
branches;
next	11.137;

11.137
date	2001.11.15.22.07.05;	author bparker;	state Exp;
branches;
next	11.136;

11.136
date	2001.10.10.22.05.53;	author bparker;	state Exp;
branches;
next	11.135;

11.135
date	2001.10.09.21.05.38;	author bparker;	state Exp;
branches;
next	11.134;

11.134
date	2001.10.05.20.38.19;	author butler;	state Exp;
branches;
next	11.133;

11.133
date	2001.10.05.17.44.58;	author jra;	state Exp;
branches;
next	11.132;

11.132
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	11.131;

11.131
date	2001.09.19.22.23.14;	author bparker;	state Exp;
branches;
next	11.130;

11.130
date	2001.08.22.15.27.45;	author jra;	state Exp;
branches;
next	11.129;

11.129
date	2001.08.21.14.04.17;	author jra;	state Exp;
branches;
next	11.128;

11.128
date	2001.08.11.13.16.11;	author butler;	state Exp;
branches;
next	11.127;

11.127
date	2001.08.10.21.22.12;	author morrison;	state Exp;
branches;
next	11.126;

11.126
date	2001.08.02.17.38.43;	author jra;	state Exp;
branches;
next	11.125;

11.125
date	2001.06.05.15.51.40;	author bparker;	state Exp;
branches;
next	11.124;

11.124
date	2001.06.01.19.23.23;	author bparker;	state Exp;
branches;
next	11.123;

11.123
date	2001.05.04.14.43.27;	author bparker;	state Exp;
branches;
next	11.122;

11.122
date	2001.05.04.14.20.45;	author bparker;	state Exp;
branches;
next	11.121;

11.121
date	2001.05.02.17.14.00;	author bparker;	state Exp;
branches;
next	11.120;

11.120
date	2001.04.05.19.35.42;	author morrison;	state Exp;
branches;
next	11.119;

11.119
date	2001.04.03.19.01.59;	author bparker;	state Exp;
branches;
next	11.118;

11.118
date	2001.04.03.14.24.27;	author bparker;	state Exp;
branches;
next	11.117;

11.117
date	2001.04.02.21.38.18;	author morrison;	state Exp;
branches;
next	11.116;

11.116
date	2001.03.31.01.57.20;	author morrison;	state Exp;
branches;
next	11.115;

11.115
date	2001.03.23.22.05.31;	author jra;	state Exp;
branches;
next	11.114;

11.114
date	2001.03.22.18.23.00;	author bparker;	state Exp;
branches;
next	11.113;

11.113
date	2001.03.22.16.19.38;	author bparker;	state Exp;
branches;
next	11.112;

11.112
date	2001.03.21.22.15.58;	author bparker;	state Exp;
branches;
next	11.111;

11.111
date	2001.03.21.20.16.29;	author bparker;	state Exp;
branches;
next	11.110;

11.110
date	2001.02.16.22.43.44;	author bparker;	state Exp;
branches;
next	11.109;

11.109
date	2001.02.05.21.26.50;	author jra;	state Exp;
branches;
next	11.108;

11.108
date	2001.01.29.20.29.38;	author jra;	state Exp;
branches;
next	11.107;

11.107
date	2000.10.24.19.54.26;	author mike;	state Exp;
branches;
next	11.106;

11.106
date	2000.10.24.19.05.04;	author mike;	state Exp;
branches;
next	11.105;

11.105
date	2000.10.20.04.12.27;	author mike;	state Exp;
branches;
next	11.104;

11.104
date	2000.09.08.05.55.47;	author mike;	state Exp;
branches;
next	11.103;

11.103
date	2000.09.07.02.23.41;	author mike;	state Exp;
branches;
next	11.102;

11.102
date	2000.08.19.03.10.11;	author mike;	state Exp;
branches;
next	11.101;

11.101
date	2000.07.13.01.10.14;	author mike;	state Exp;
branches;
next	11.100;

11.100
date	2000.07.05.22.11.22;	author mike;	state Exp;
branches;
next	11.99;

11.99
date	2000.06.30.19.58.09;	author mike;	state Exp;
branches;
next	11.98;

11.98
date	2000.06.08.21.38.42;	author bparker;	state Exp;
branches
	11.98.2.1;
next	11.97;

11.97
date	2000.06.05.21.55.54;	author bparker;	state Exp;
branches;
next	11.96;

11.96
date	2000.03.31.18.09.46;	author bparker;	state Exp;
branches;
next	11.95;

11.95
date	2000.03.16.13.39.28;	author jra;	state Exp;
branches;
next	11.94;

11.94
date	2000.01.31.14.37.32;	author jra;	state Exp;
branches;
next	11.93;

11.93
date	2000.01.07.04.21.19;	author mike;	state Exp;
branches;
next	11.92;

11.92
date	2000.01.07.02.26.11;	author mike;	state Exp;
branches;
next	11.91;

11.91
date	2000.01.06.22.38.59;	author mike;	state Exp;
branches;
next	11.90;

11.90
date	99.12.30.19.28.30;	author jra;	state Exp;
branches;
next	11.89;

11.89
date	99.12.30.14.24.27;	author jra;	state Exp;
branches;
next	11.88;

11.88
date	99.12.29.23.23.17;	author mike;	state Exp;
branches;
next	11.87;

11.87
date	99.12.28.19.43.11;	author bparker;	state Exp;
branches;
next	11.86;

11.86
date	99.12.15.15.29.05;	author jra;	state Exp;
branches;
next	11.85;

11.85
date	99.11.26.23.03.29;	author mike;	state Exp;
branches;
next	11.84;

11.84
date	99.11.24.14.26.41;	author jra;	state Exp;
branches;
next	11.83;

11.83
date	99.10.18.12.49.45;	author jra;	state Exp;
branches;
next	11.82;

11.82
date	99.09.01.18.55.09;	author bparker;	state Exp;
branches;
next	11.81;

11.81
date	99.07.23.20.59.15;	author jra;	state Exp;
branches;
next	11.80;

11.80
date	99.07.02.22.18.38;	author mike;	state Exp;
branches;
next	11.79;

11.79
date	99.05.15.08.04.31;	author mike;	state Exp;
branches;
next	11.78;

11.78
date	99.04.23.17.51.45;	author bparker;	state Exp;
branches;
next	11.77;

11.77
date	99.04.19.19.24.09;	author jra;	state Exp;
branches;
next	11.76;

11.76
date	99.02.24.01.01.47;	author jra;	state Exp;
branches;
next	11.75;

11.75
date	99.01.21.18.25.25;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	99.01.12.18.23.15;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	99.01.06.16.39.50;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	98.12.30.08.30.23;	author mike;	state Exp;
branches;
next	11.71;

11.71
date	98.11.06.22.15.58;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	98.06.25.07.37.24;	author mike;	state Exp;
branches;
next	11.69;

11.69
date	98.06.11.19.41.38;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	98.05.01.21.16.21;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	98.04.23.12.50.37;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	98.04.10.18.18.41;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	98.04.07.14.07.59;	author jra;	state Exp;
branches;
next	11.64;

11.64
date	98.03.19.15.04.31;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	98.02.20.23.08.31;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	98.01.07.04.17.25;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	97.11.03.15.23.30;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	97.09.08.19.06.38;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	97.07.11.14.24.46;	author jra;	state Exp;
branches;
next	11.58;

11.58
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	97.06.03.16.03.59;	author pjt;	state Exp;
branches;
next	11.56;

11.56
date	97.05.27.12.36.01;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	97.05.22.18.27.51;	author jra;	state Exp;
branches;
next	11.54;

11.54
date	97.05.22.09.29.07;	author butler;	state Exp;
branches;
next	11.53;

11.53
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	97.03.28.17.46.51;	author pjt;	state Exp;
branches;
next	11.50;

11.50
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	97.03.24.13.11.35;	author pjt;	state Exp;
branches;
next	11.48;

11.48
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.47;

11.47
date	97.03.06.21.42.59;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	97.01.31.21.51.07;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	97.01.30.04.39.15;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	97.01.30.02.57.32;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	97.01.30.02.48.26;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	97.01.30.02.07.31;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	97.01.30.01.51.25;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	97.01.30.01.48.57;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	97.01.29.20.06.35;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	97.01.29.07.30.21;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	97.01.29.07.18.53;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	97.01.29.07.08.16;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	97.01.29.06.02.01;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	97.01.29.05.48.25;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	97.01.24.20.54.54;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	97.01.02.19.36.55;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.12.16.20.33.18;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	96.12.13.18.58.33;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	96.12.13.18.51.33;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.11.19.21.51.23;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.10.04.14.57.57;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.09.23.18.37.34;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	96.09.17.21.17.06;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.08.26.15.12.25;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.08.22.21.07.23;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.08.02.18.06.43;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.07.19.21.07.03;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.07.15.20.37.06;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.05.24.18.32.39;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.04.03.22.05.50;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.04.02.18.43.13;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.03.25.21.49.06;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.03.22.18.32.07;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.03.01.19.17.10;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.02.09.22.14.51;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.09.26.20.21.21;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	95.07.28.19.17.52;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.07.18.22.52.58;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.25;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.42;	author mike;	state Rel4_4;
branches;
next	10.27;

10.27
date	94.12.20.16.28.21;	author jra;	state Exp;
branches;
next	10.26;

10.26
date	94.12.16.19.35.36;	author gdurf;	state Exp;
branches;
next	10.25;

10.25
date	94.11.17.17.06.13;	author jra;	state Exp;
branches;
next	10.24;

10.24
date	94.11.16.16.58.31;	author jra;	state Exp;
branches;
next	10.23;

10.23
date	94.11.14.17.20.30;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	94.11.08.04.20.53;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	94.10.12.02.24.10;	author butler;	state Exp;
branches;
next	10.20;

10.20
date	94.10.06.13.01.21;	author jra;	state Exp;
branches;
next	10.19;

10.19
date	94.08.19.16.13.42;	author pjt;	state Exp;
branches;
next	10.18;

10.18
date	94.08.19.13.51.10;	author pjt;	state Exp;
branches;
next	10.17;

10.17
date	94.08.09.14.51.28;	author gdurf;	state Exp;
branches;
next	10.16;

10.16
date	94.08.03.13.46.43;	author gdurf;	state Exp;
branches;
next	10.15;

10.15
date	94.06.13.19.04.43;	author gdurf;	state Exp;
branches;
next	10.14;

10.14
date	94.06.01.16.26.23;	author gdurf;	state Exp;
branches;
next	10.13;

10.13
date	94.04.05.17.20.17;	author cjohnson;	state Exp;
branches;
next	10.12;

10.12
date	93.09.30.15.11.31;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	93.02.26.06.15.46;	author butler;	state Exp;
branches;
next	10.10;

10.10
date	93.02.26.06.12.28;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	92.11.23.18.53.13;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.07.23.05.03.42;	author butler;	state Exp;
branches;
next	10.7;

10.7
date	92.06.25.20.48.36;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.03.23.22.33.29;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.03.23.22.30.59;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.02.05.20.00.17;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.12.20.02.27.33;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.12.18.07.46.03;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.10;	author mike;	state Rel4_0;
branches;
next	9.10;

9.10
date	91.07.01.02.05.36;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.06.30.21.14.43;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.12.08.25.43;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.08.00.31.08;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.07.19.52.09;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.07.19.48.03;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.04.21.06.05.14;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.28.15.10.23;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.30.02;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.01.52;	author mike;	state Rel3_5;
branches;
next	8.9;

8.9
date	89.05.11.21.41.42;	author phil;	state Exp;
branches;
next	8.8;

8.8
date	89.05.11.21.11.54;	author phil;	state Exp;
branches;
next	8.7;

8.7
date	89.05.08.21.45.17;	author phil;	state Exp;
branches;
next	8.6;

8.6
date	89.04.06.20.38.51;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.18.01.49.01;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.01.16.22.51.38;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.09.05.08.20;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.56.05;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.30;	author mike;	state Rel3_0;
branches;
next	7.6;

7.6
date	88.08.20.06.47.26;	author phil;	state Exp;
branches;
next	7.5;

7.5
date	88.05.15.23.04.46;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.01.26.06.02.25;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.11.05.07.09.12;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.03.35;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.39;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.01.52;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.17.57;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.05.35;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.19.15;	author mike;	state Rel1;
branches;
next	2.18;

2.18
date	86.12.03.18.33.14;	author mike;	state Exp;
branches;
next	2.17;

2.17
date	86.09.09.22.03.12;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	86.08.12.06.46.51;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	86.06.12.00.08.20;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	86.03.14.20.41.03;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	86.03.10.21.37.49;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.02.17.17.01.58;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	85.09.27.19.09.58;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	85.09.14.05.33.55;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.09.12.00.17.12;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.08.07.05.16.47;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.07.30.01.17.07;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.06.06.22.32.48;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.05.29.15.04.35;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.07.23.55.31;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.15.05.02.51;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.04.06.28;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.53.48;	author mike;	state Prod;
branches;
next	1.11;

1.11
date	85.03.08.20.53.24;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	85.02.14.00.58.50;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.02.14.00.21.03;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.02.02.01.39.46;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.02.01.01.45.46;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.02.01.00.49.20;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.01.16.03.40.58;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.01.56.25;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.20.04.22.39;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.17.05.35.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.47.59;	author mike;	state Exp;
branches;
next	;

11.98.2.1
date	2001.01.29.20.31.41;	author jra;	state Exp;
branches;
next	11.98.2.2;

11.98.2.2
date	2001.02.09.15.26.32;	author bparker;	state Exp;
branches;
next	;

11.140.2.1
date	2002.09.19.18.01.59;	author morrison;	state Exp;
branches;
next	11.140.2.2;

11.140.2.2
date	2003.01.31.00.11.54;	author morrison;	state Exp;
branches;
next	11.140.2.3;

11.140.2.3
date	2003.02.02.06.12.44;	author morrison;	state Exp;
branches;
next	11.140.2.4;

11.140.2.4
date	2004.03.17.21.21.55;	author morrison;	state Exp;
branches;
next	;

11.140.4.1
date	2002.09.26.23.04.08;	author morrison;	state Exp;
branches;
next	11.140.4.2;

11.140.4.2
date	2004.03.11.23.46.33;	author morrison;	state Exp;
branches;
next	;

11.142.6.1
date	2004.02.12.18.34.12;	author erikg;	state Exp;
branches;
next	11.142.6.2;

11.142.6.2
date	2004.03.15.14.07.35;	author erikg;	state Exp;
branches;
next	11.142.6.3;

11.142.6.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Implement keyboard commands to change the model
@


11.147
log
@moved to src/mged/
@
text
@/*
 *			C H G M O D E L
 *
 * This module contains functions which change particulars of the
 * model, generally on a single solid or combination.
 * Changes to the tree structure of the model are done in chgtree.c
 *
 * Functions -
 *	f_itemair	add/modify item and air codes of a region
 *	f_mater		modify material information
 *	f_mirror	mirror image
 *	f_edcomb	modify combination record info
 *	f_units		change local units of description
 *	f_title		change current title of description
 *	aexists		announce already exists
 *	f_make		create new solid of given type
 *	f_rot_obj	allow precise changes to object rotation
 *	f_sc_obj	allow precise changes to object scaling
 *	f_tr_obj	allow precise changes to object translation
 *
 *  Author -
 *	Michael John Muuss
 *	Keith A. Applin
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/chgmodel.c,v 11.146 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "externs.h"
#include "nmg.h"
#include "nurb.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "wdb.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./sedit.h"
#include "./cmd.h"

extern struct bn_tol mged_tol;

void set_tran();
void	aexists(char *name);

static char	tmpfil[17];
#ifndef WIN32
static char	*tmpfil_init = "/tmp/GED.aXXXXXX";
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif

int		newedge;		/* new edge for arb editing */

/* Add/modify item and air codes of a region */
/* Format: item region item <air>	*/
int
f_itemair(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *dp;
	int			ident, air, GIFTmater=0, los=0;
	int			GIFTmater_set, los_set;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 3 || 6 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help item");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;
	if( (dp->d_flags & DIR_COMB) == 0 )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( (dp->d_flags & DIR_REGION) == 0 )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a region\n", (char *)NULL);
	  return TCL_ERROR;
	}

	air = ident = 0;
	GIFTmater_set = los_set = 0;
	ident = atoi( argv[2] );

	/*
	 * If <air> is not included, it is assumed to be zero.
	 * If, on the other hand, either of <GIFTmater> and <los>
	 * is not included, it is left unchanged.
	 */
	if( argc > 3 )  {
		air = atoi( argv[3] );
	}
	if( argc > 4 )  {
		GIFTmater = atoi( argv[4] );
		GIFTmater_set = 1;
	}
	if( argc > 5 )  {
		los = atoi( argv[5] );
		los_set = 1;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR_return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);
	comb->region_id = ident;
	comb->aircode = air;
	if ( GIFTmater_set )  {
		comb->GIFTmater = GIFTmater;
	}
	if ( los_set )  {
		comb->los = los;
	}
	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

/* Modify material information */
/* Usage:  mater region_name shader r g b inherit */
int
f_mater(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *dp;
	int r=0, g=0, b=0;
	int skip_args = 0;
	char inherit;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2 || 8 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help mater");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}
	
	if( (dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;
	if( (dp->d_flags & DIR_COMB) == 0 )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR_return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	if( argc >= 3 )  {
	  if( strncmp( argv[2], "del", 3 ) != 0 )  {
		/* Material */
	  	bu_vls_trunc( &comb->shader, 0 );
	  	if( bu_shader_to_tcl_list( argv[2], &comb->shader ))
	  	{
	  		Tcl_AppendResult(interp, "Problem with shader string: ", argv[2], (char *)NULL );
	  		return TCL_ERROR;
	  	}
	  }else{
	  	bu_vls_free( &comb->shader );
	  }
	}else{
	  /* Shader */
	  struct bu_vls tmp_vls;

	  bu_vls_init( &tmp_vls );
	  if( bu_vls_strlen( &comb->shader ) )
	  {
	  	if( bu_shader_to_key_eq( bu_vls_addr(&comb->shader), &tmp_vls ) )
	  	{
	  		Tcl_AppendResult(interp, "Problem with on disk shader string: ", bu_vls_addr(&comb->shader), (char *)NULL );
	  		bu_vls_free( &tmp_vls );
	  		return TCL_ERROR;
	  	}
	  }
	  curr_cmd_list->cl_quote_string = 1;
	  Tcl_AppendResult(interp, "Shader = ", bu_vls_addr(&tmp_vls),
			"\n", MORE_ARGS_STR,
			"Shader?  ('del' to delete, CR to skip) ", (char *)NULL);

	  if( bu_vls_strlen( &comb->shader ) == 0 )
	    bu_vls_printf(&curr_cmd_list->cl_more_default, "del");
	  else
	    bu_vls_printf(&curr_cmd_list->cl_more_default, "\"%S\"", &tmp_vls );

	  bu_vls_free( &tmp_vls );

	  goto fail;
	}

	if(argc >= 4){
	  if( strncmp(argv[3], "del", 3) == 0 ){
	    /* leave color as is */
	  	comb->rgb_valid = 0;
		skip_args = 2;
	  }else if(argc < 6){	/* prompt for color */
	    goto color_prompt;
	  }else{	/* change color */
	    sscanf(argv[3], "%d", &r);
	    sscanf(argv[4], "%d", &g);
	    sscanf(argv[5], "%d", &b);
	    comb->rgb[0] = r;
	    comb->rgb[1] = g;
	    comb->rgb[2] = b;
	    comb->rgb_valid = 1;
	  }
	}else{
	/* Color */
color_prompt:
	  if( comb->rgb_valid ){
	    struct bu_vls tmp_vls;
	    
	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "Color = %d %d %d\n",
			  comb->rgb[0], comb->rgb[1], comb->rgb[2] );
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);

	    bu_vls_printf(&curr_cmd_list->cl_more_default, "%d %d %d",
			  comb->rgb[0],
			  comb->rgb[1],
			  comb->rgb[2] );
	  }else{
	    Tcl_AppendResult(interp, "Color = (No color specified)\n", (char *)NULL);
	    bu_vls_printf(&curr_cmd_list->cl_more_default, "del");
	  }

	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   "Color R G B (0..255)? ('del' to delete, CR to skip) ", (char *)NULL);
	  goto fail;
	}

	if(argc >= 7 - skip_args){
	  inherit = *argv[6 - skip_args];
	}else{
	  /* Inherit */
	  switch( comb->inherit )  {
	  case 0:
	    Tcl_AppendResult(interp, "Inherit = 0:  lower nodes (towards leaves) override\n",
			     (char *)NULL);
	    break;
	  default:
	    Tcl_AppendResult(interp, "Inherit = 1:  higher nodes (towards root) override\n",
			     (char *)NULL);
	    break;
	  }

	  Tcl_AppendResult(interp, MORE_ARGS_STR,
			   "Inheritance (0|1)? (CR to skip) ", (char *)NULL);
	  switch( comb->inherit ) {
	  default:
	    bu_vls_printf(&curr_cmd_list->cl_more_default, "1");
	    break;
	  case 0:
	    bu_vls_printf(&curr_cmd_list->cl_more_default, "0");
	    break;
	  }

	  goto fail;
	}

	switch( inherit )  {
	case '1':
		comb->inherit = 1;
		break;
	case '0':
		comb->inherit = 0;
		break;
	case '\0':
	case '\n':
		break;
	default:
	  Tcl_AppendResult(interp, "Unknown response ignored\n", (char *)NULL);
	  break;
	}		

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
fail:
	rt_db_free_internal( &intern, &rt_uniresource );
	return TCL_ERROR;
}

int
f_edmater(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int i;
  int status;

  char **av;
  
  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help edmater");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  strcpy(tmpfil, tmpfil_init);
#ifdef WIN32
  (void)mktemp(tmpfil);
  i=creat(tmpfil, 0600);
#else
  i = mkstemp(tmpfil);
#endif
  if( i < 0 ){
    perror(tmpfil);
    return TCL_ERROR;
  }

  (void)close(i);

  av = (char **)bu_malloc(sizeof(char *)*(argc + 2), "f_edmater: av");
  av[0] = "wmater";
  av[1] = tmpfil;
  for(i = 2; i < argc + 1; ++i)
    av[i] = argv[i-1];

  av[i] = NULL;

  if( f_wmater(clientData, interp, argc + 1, av) == TCL_ERROR ){
    (void)unlink(tmpfil);
    bu_free((genptr_t)av, "f_edmater: av");
    return TCL_ERROR;
  }

  if( editit(tmpfil) ){
    av[0] = "rmater";
    av[2] = NULL;
    status = f_rmater(clientData, interp, 2, av);
  }else
    status = TCL_ERROR;

  (void)unlink(tmpfil);
  bu_free((genptr_t)av, "f_edmater: av");
  return status;
}


int
f_wmater(
	ClientData clientData,
	Tcl_Interp *interp,
	int     argc,
	char    *argv[])
{
  int i;
  int status = TCL_OK;
  FILE *fp;
  register struct directory *dp;
  struct rt_db_internal	intern;
  struct rt_comb_internal	*comb;

  CHECK_DBI_NULL;

  if(argc < 3){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help wmater");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if((fp = fopen(argv[1], "a")) == NULL){
    Tcl_AppendResult(interp, "f_wmater: Failed to open file - ", argv[1], (char *)NULL);
    return TCL_ERROR;
  }

  for(i = 2; i < argc; ++i){
    if( (dp = db_lookup( dbip,  argv[i], LOOKUP_NOISY )) == DIR_NULL ){
      Tcl_AppendResult(interp, "f_wmater: Failed to find ", argv[i], "\n", (char *)NULL);
      status = TCL_ERROR;
      continue;
    }
    if( (dp->d_flags & DIR_COMB) == 0 )  {
      Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
      status = TCL_ERROR;
      continue;
    }
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR;
		status = TCL_ERROR;
		continue;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	fprintf(fp, "\"%s\"\t\"%s\"\t%d\t%d\t%d\t%d\t%d\n", argv[i],
		bu_vls_strlen(&comb->shader) > 0 ?
			bu_vls_addr(&comb->shader) : "-",
	  	comb->rgb[0], comb->rgb[1], comb->rgb[2],
	  	comb->rgb_valid, comb->inherit);
	rt_db_free_internal( &intern, &rt_uniresource );
  }

  (void)fclose(fp);
  return status;
}


int
f_rmater(
	ClientData clientData,
	Tcl_Interp *interp,
	int     argc,
	char    *argv[])
{
#ifndef LINELEN
#define LINELEN 256
#endif
  int status = TCL_OK;
  FILE *fp;
  register struct directory *dp;
  struct rt_db_internal	intern;
  struct rt_comb_internal	*comb;
  char line[LINELEN];
  char name[128];
  char shader[256]; 
  int r,g,b;
  int override;
  int inherit;

  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  if(argc < 2 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help rmater");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if((fp = fopen(argv[1], "r")) == NULL){
    Tcl_AppendResult(interp, "f_rcodes: Failed to read file - ", argv[1], (char *)NULL);
    return TCL_ERROR;
  }

  while(fgets( line , LINELEN, fp ) != NULL){
	if((extract_mater_from_line(line, name, shader,
			    &r, &g, &b, &override, &inherit)) == TCL_ERROR)
	continue;

	if( (dp = db_lookup( dbip,  name, LOOKUP_NOISY )) == DIR_NULL ){
		Tcl_AppendResult(interp, "f_rmater: Failed to find ", name, "\n", (char *)NULL);
		status = TCL_ERROR;
		continue;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR;
		status = TCL_ERROR;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	/* Assign new values */
	if(shader[0] == '-')
  		bu_vls_free( &comb->shader );
  	else
  		bu_vls_strcpy( &comb->shader, shader );

  	comb->rgb[0] = (unsigned char)r;
  	comb->rgb[1] = (unsigned char)g;
  	comb->rgb[2] = (unsigned char)b;
  	comb->rgb_valid = override;
  	comb->inherit = inherit;

	/* Write new values to database */
	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR;
		status = TCL_ERROR;
	}
  }

  (void)fclose(fp);
  return status;
}

int
extract_mater_from_line(
	char *line,
	char *name,
	char *shader,
	int *r, int *g, int *b,
	int *override,
	int *inherit)
{
  int i,j,k;
  char *str[3];

  str[0] = name;
  str[1] = shader;

  /* Extract first 2 strings. */
  for(i=j=0; i < 2; ++i){

    /* skip white space */
    while(line[j] == ' ' || line[j] == '\t')
      ++j;

    if(line[j] == '\0')
      return TCL_ERROR;

    /* We found a double quote, so use everything between the quotes */
    if(line[j] == '"'){
      for(k = 0, ++j; line[j] != '"' && line[j] != '\0'; ++j, ++k)
	str[i][k] = line[j];
    }else{
      for(k = 0; line[j] != ' ' && line[j] != '\t' && line[j] != '\0'; ++j, ++k)
	str[i][k] = line[j];
    }

    if(line[j] == '\0')
      return TCL_ERROR;

    str[i][k] = '\0';
    ++j;
  }

  if((sscanf(line + j, "%d%d%d%d%d", r, g, b, override, inherit)) != 5)
    return TCL_ERROR;

  return TCL_OK;
}


/*
 *			F _ C O M B _ C O L O R
 *
 *  Simple command-line way to set object color
 *  Usage: ocolor combination R G B
 */
int
f_comb_color(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    int				i;
    int				val;
    register struct directory	*dp;
    struct rt_db_internal	intern;
    struct rt_comb_internal	*comb;

    CHECK_DBI_NULL;
    CHECK_READ_ONLY;

    if(argc < 5 || 5 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help comb_color");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    if ((dp = db_lookup(dbip,  argv[1], LOOKUP_NOISY)) == DIR_NULL)
      return TCL_ERROR;
    if( (dp->d_flags & DIR_COMB) == 0 )  {
      Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
      return TCL_ERROR;
    }

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR_return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

    for (i = 0; i < 3; ++i)  {
	if (((val = atoi(argv[i + 2])) < 0) || (val > 255))
	{
	  Tcl_AppendResult(interp, "RGB value out of range: ", argv[i + 2],
			   "\n", (char *)NULL);
	  rt_db_free_internal( &intern, &rt_uniresource );
	  return TCL_ERROR;
	}
	else
	    comb->rgb[i] = val;
    }

	comb->rgb_valid = 1;
	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

/*
 *			F _ S H A D E R
 *
 *  Simpler, command-line version of 'mater' command.
 *  Usage: shader combination shader_material [shader_argument(s)]
 */
int
f_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;

	CHECK_DBI_NULL;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help shader");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;
	if( (dp->d_flags & DIR_COMB) == 0 )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR_return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	if(argc == 2)  {
		/* Return the current shader string */
		Tcl_AppendResult( interp, bu_vls_addr(&comb->shader), (char *)NULL);
		rt_db_free_internal( &intern, &rt_uniresource );
	} else {
		CHECK_READ_ONLY;

		/* Replace with new shader string from command line */
		bu_vls_free( &comb->shader );

		/* Bunch up the rest of the args, space separated */
		bu_vls_from_argv( &comb->shader, argc-2, argv+2 );

		if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
			TCL_WRITE_ERR_return;
		}
		/* Internal representation has been freed by rt_db_put_internal */
	}
	return TCL_OK;
}


/* Mirror image */
/* Format: m oldobject newobject axis	*/
int
f_mirror(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *proto;
	register struct directory *dp;
	register int i, j, k;
	struct rt_db_internal	internal;
	int			id;
	mat_t mirmat;
	mat_t temp;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help mirror");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (proto = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;

	if( db_lookup( dbip,  argv[2], LOOKUP_QUIET ) != DIR_NULL )  {
	  aexists( argv[2] );
	  return TCL_ERROR;
	}

	k = -1;
	if( strcmp( argv[3], "x" ) == 0 )
		k = 0;
	if( strcmp( argv[3], "y" ) == 0 )
		k = 1;
	if( strcmp( argv[3], "z" ) == 0 )
		k = 2;
	if( k < 0 ) {
	  Tcl_AppendResult(interp, "axis must be x, y or z\n", (char *)NULL);
	  return TCL_ERROR;
	}

	id = rt_db_get_internal( &internal, proto, dbip, NULL, &rt_uniresource );
	if( id < 0 )  {
	  Tcl_AppendResult(interp, "f_mirror(", argv[1], argv[2],
		   "):  solid import failure\n", (char *)NULL);
	  return TCL_ERROR;				/* FAIL */
	}
	RT_CK_DB_INTERNAL( &internal );

	/* Build mirror transform matrix, for those who need it. */
	MAT_IDN( mirmat );
	mirmat[k*5] = -1.0;

	switch( id )
	{
		case ID_TOR:
		{
			struct rt_tor_internal *tor;

			tor = (struct rt_tor_internal *)internal.idb_ptr;
			RT_TOR_CK_MAGIC( tor );

			tor->v[k] *= -1.0;
			tor->h[k] *= -1.0;

			break;
		}
		case ID_TGC:
		case ID_REC:
		{
			struct rt_tgc_internal *tgc;

			tgc = (struct rt_tgc_internal *)internal.idb_ptr;
			RT_TGC_CK_MAGIC( tgc );

			tgc->v[k] *= -1.0;
			tgc->h[k] *= -1.0;
			tgc->a[k] *= -1.0;
			tgc->b[k] *= -1.0;
			tgc->c[k] *= -1.0;
			tgc->d[k] *= -1.0;

			break;
		}
		case ID_ELL:
		case ID_SPH:
		{
			struct rt_ell_internal *ell;

			ell = (struct rt_ell_internal *)internal.idb_ptr;
			RT_ELL_CK_MAGIC( ell );

			ell->v[k] *= -1.0;
			ell->a[k] *= -1.0;
			ell->b[k] *= -1.0;
			ell->c[k] *= -1.0;

			break;
		}
		case ID_ARB8:
		{
			struct rt_arb_internal *arb;

			arb = (struct rt_arb_internal *)internal.idb_ptr;
			RT_ARB_CK_MAGIC( arb );

			for( i=0 ; i<8 ; i++ )
				arb->pt[i][k] *= -1.0;
			break;
		}
		case ID_HALF:
		{
			struct rt_half_internal *haf;

			haf = (struct rt_half_internal *)internal.idb_ptr;
                                RT_HALF_CK_MAGIC( haf );

			haf->eqn[k] *= -1.0;

			break;
		}
		case ID_GRIP:
		{
			struct rt_grip_internal *grp;

			grp = (struct rt_grip_internal *)internal.idb_ptr;
			RT_GRIP_CK_MAGIC( grp );

			grp->center[k] *= -1.0;
			grp->normal[k] *= -1.0;

			break;
		}
		case ID_POLY:
		{
			struct rt_pg_internal *pg;
			fastf_t *verts;
			fastf_t *norms;

			pg = (struct rt_pg_internal *)internal.idb_ptr;
			RT_PG_CK_MAGIC( pg );

			verts = (fastf_t *)bu_calloc( pg->max_npts*3, sizeof( fastf_t ), "f_mirror: verts" );
			norms = (fastf_t *)bu_calloc( pg->max_npts*3, sizeof( fastf_t ), "f_mirror: norms" );

			for( i=0 ; i<pg->npoly ; i++ )
			{
				int last;

				last = (pg->poly[i].npts - 1)*3;
				/* mirror coords and temporarily store in reverse order */
				for( j=0 ; j<pg->poly[i].npts*3 ; j += 3 )
				{
					pg->poly[i].verts[j+k] *= -1.0;
					VMOVE( &verts[last-j], &pg->poly[i].verts[j] )
					pg->poly[i].norms[j+k] *= -1.0;
					VMOVE( &norms[last-j], &pg->poly[i].norms[j] )
				}

				/* write back mirrored and reversed face loop */
				for( j=0 ; j<pg->poly[i].npts*3 ; j += 3 )
				{
					VMOVE( &pg->poly[i].norms[j], &norms[j] )
					VMOVE( &pg->poly[i].verts[j], &verts[j] )
				}
			}

			bu_free( (char *)verts, "f_mirror: verts" );
			bu_free( (char *)norms, "f_mirror: norms" );

			break;
		}
		case ID_BSPLINE:
		{
			struct rt_nurb_internal *nurb;

			nurb = (struct rt_nurb_internal *)internal.idb_ptr;
			RT_NURB_CK_MAGIC( nurb );

			for( i=0 ; i<nurb->nsrf ; i++ )
			{
				fastf_t *ptr;
				int tmp;
				int orig_size[2];
				int ncoords;
				int m;
				int l;

				/* swap knot vetcors between u and v */
				ptr = nurb->srfs[i]->u.knots;
				tmp = nurb->srfs[i]->u.k_size;

				nurb->srfs[i]->u.knots = nurb->srfs[i]->v.knots;
				nurb->srfs[i]->u.k_size = nurb->srfs[i]->v.k_size;
				nurb->srfs[i]->v.knots = ptr;
				nurb->srfs[i]->v.k_size = tmp;

				/* swap order */
				tmp = nurb->srfs[i]->order[0];
				nurb->srfs[i]->order[0] = nurb->srfs[i]->order[1];
				nurb->srfs[i]->order[1] = tmp;

				/* swap mesh size */
				orig_size[0] = nurb->srfs[i]->s_size[0];
				orig_size[1] = nurb->srfs[i]->s_size[1];

				nurb->srfs[i]->s_size[0] = orig_size[1];
				nurb->srfs[i]->s_size[1] = orig_size[0];

				/* allocat memory for a new control mesh */
				ncoords = RT_NURB_EXTRACT_COORDS( nurb->srfs[i]->pt_type );
				ptr = (fastf_t *)bu_calloc( orig_size[0]*orig_size[1]*ncoords, sizeof( fastf_t ), "f_mirror: ctl mesh ptr" );

				/* mirror each control point */
				for( j=0 ; j<orig_size[0]*orig_size[1] ; j++ )
					nurb->srfs[i]->ctl_points[j*ncoords+k] *= -1.0;

				/* copy mirrored control points into new mesh
				 * while swaping u and v */
				m = 0;
				for( j=0 ; j<orig_size[0] ; j++ )
				{
					for( l=0 ; l<orig_size[1] ; l++ )
					{
						VMOVEN( &ptr[(l*orig_size[0]+j)*ncoords], &nurb->srfs[i]->ctl_points[m*ncoords], ncoords )
						m++;
					}
				}

				/* free old mesh */
				bu_free( (char *)nurb->srfs[i]->ctl_points , "f_mirror: ctl points" );

				/* put new mesh in place */
				nurb->srfs[i]->ctl_points = ptr;
			}

			break;
		}
		case ID_ARBN:
		{
			struct rt_arbn_internal *arbn;

			arbn = (struct rt_arbn_internal *)internal.idb_ptr;
			RT_ARBN_CK_MAGIC( arbn );

			for( i=0 ; i<arbn->neqn ; i++ )
				arbn->eqn[i][k] *= -1.0;

			break;
		}
		case ID_PIPE:
		{
			struct rt_pipe_internal *pipe;
			struct wdb_pipept *ps;

			pipe = (struct rt_pipe_internal *)internal.idb_ptr;
			RT_PIPE_CK_MAGIC( pipe );

			for( BU_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
				ps->pp_coord[k] *= -1.0;

			break;
		}
		case ID_PARTICLE:
		{
			struct rt_part_internal *part;

			part = (struct rt_part_internal *)internal.idb_ptr;
			RT_PART_CK_MAGIC( part );

			part->part_V[k] *= -1.0;
			part->part_H[k] *= -1.0;

			break;
		}
		case ID_RPC:
		{
			struct rt_rpc_internal *rpc;

			rpc = (struct rt_rpc_internal *)internal.idb_ptr;
			RT_RPC_CK_MAGIC( rpc );

			rpc->rpc_V[k] *= -1.0;
			rpc->rpc_H[k] *= -1.0;
			rpc->rpc_B[k] *= -1.0;

			break;
		}
		case ID_RHC:
		{
			struct rt_rhc_internal *rhc;

			rhc = (struct rt_rhc_internal *)internal.idb_ptr;
			RT_RHC_CK_MAGIC( rhc );

			rhc->rhc_V[k] *= -1.0;
			rhc->rhc_H[k] *= -1.0;
			rhc->rhc_B[k] *= -1.0;

			break;
		}
		case ID_EPA:
		{
			struct rt_epa_internal *epa;

			epa = (struct rt_epa_internal *)internal.idb_ptr;
			RT_EPA_CK_MAGIC( epa );

			epa->epa_V[k] *= -1.0;
			epa->epa_H[k] *= -1.0;
			epa->epa_Au[k] *= -1.0;

			break;
		}
		case ID_ETO:
		{
			struct rt_eto_internal *eto;

			eto = (struct rt_eto_internal *)internal.idb_ptr;
			RT_ETO_CK_MAGIC( eto );

			eto->eto_V[k] *= -1.0;
			eto->eto_N[k] *= -1.0;
			eto->eto_C[k] *= -1.0;

			break;
		}
		case ID_NMG:
		{
			struct model *m;
			struct nmgregion *r;
			struct shell *s;
			struct bu_ptbl table;
			struct vertex *v;

			m = (struct model *)internal.idb_ptr;
			NMG_CK_MODEL( m );

			/* move every vertex */
			nmg_vertex_tabulate( &table, &m->magic );
			for( i=0 ; i<BU_PTBL_END( &table ) ; i++ )
			{
				v = (struct vertex *)BU_PTBL_GET( &table, i );
				NMG_CK_VERTEX( v );

				v->vg_p->coord[k] *= -1.0;
			}

			bu_ptbl_reset( &table );

			nmg_face_tabulate( &table, &m->magic );
			for( i=0 ; i<BU_PTBL_END( &table ) ; i++ )
			{
				struct face *f;

				f = (struct face *)BU_PTBL_GET( &table, i );
				NMG_CK_FACE( f );

				if( !f->g.magic_p )
					continue;

				if( *f->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
				{
					Tcl_AppendResult(interp, "Sorry, Can only mirror NMG solids with planar faces", (char *)0 );
					bu_ptbl_free( &table );
					rt_db_free_internal( &internal, &rt_uniresource );
					return TCL_ERROR;
				}

				
			}

			for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
				for( BU_LIST_FOR( s, shell, &r->s_hd ) )
					nmg_invert_shell( s, &mged_tol );


			for( i=0 ; i<BU_PTBL_END( &table ) ; i++ )
			{
				struct face *f;
				struct faceuse *fu;

				f = (struct face *)BU_PTBL_GET( &table, i );
				NMG_CK_FACE( f );

				fu = f->fu_p;
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;
				if( fu->orientation != OT_SAME )
				{
					Tcl_AppendResult(interp, "nmg_calc_face_g() failed", (char *)0 );
					bu_ptbl_free( &table );
					rt_db_free_internal( &internal, &rt_uniresource );
					return TCL_ERROR;
				}

				if( nmg_calc_face_g( fu ) )
				{
					Tcl_AppendResult(interp, "nmg_calc_face_g() failed", (char *)0 );
					bu_ptbl_free( &table );
					rt_db_free_internal( &internal, &rt_uniresource );
					return TCL_ERROR;
				}
			}

			bu_ptbl_free( &table );
			nmg_rebound( m, &mged_tol );

			break;
		}
		case ID_ARS:
		{
			struct rt_ars_internal *ars;
			fastf_t *tmp_curve;

			ars = (struct rt_ars_internal *)internal.idb_ptr;
			RT_ARS_CK_MAGIC( ars );

			/* mirror each vertex */
			for( i=0 ; i<ars->ncurves ; i++ )
			{
				for( j=0 ; j<ars->pts_per_curve ; j++ )
					ars->curves[i][j*3+k] *= -1.0;
			}

			/* now reverse order of vertices in each curve */
			tmp_curve = (fastf_t *)bu_calloc( 3*ars->pts_per_curve, sizeof( fastf_t ), "f_mirror: tmp_curve" );
			for( i=0 ; i<ars->ncurves ; i++ )
			{
				/* reverse vertex order */
				for( j=0 ; j<ars->pts_per_curve ; j++ )
					VMOVE( &tmp_curve[(ars->pts_per_curve-j-1)*3], &ars->curves[i][j*3] )

				/* now copy back */
				bcopy( tmp_curve, ars->curves[i], ars->pts_per_curve*3*sizeof( fastf_t ) );
			}

			bu_free( (char *)tmp_curve, "f_mirror: tmp_curve" );

			break;
		}
		case ID_EBM:
		{
			struct rt_ebm_internal *ebm;

			ebm = (struct rt_ebm_internal *)internal.idb_ptr;
			RT_EBM_CK_MAGIC( ebm );

			bn_mat_mul( temp, mirmat, ebm->mat );
			MAT_COPY( ebm->mat, temp );

			break;
		}
		case ID_DSP:
		{
			struct rt_dsp_internal *dsp;
			
			dsp = (struct rt_dsp_internal *)internal.idb_ptr;
			RT_DSP_CK_MAGIC( dsp );
			
			bn_mat_mul( temp, mirmat, dsp->dsp_mtos);
			MAT_COPY( dsp->dsp_mtos, temp);
			
			break;
		}
		case ID_VOL:
		{
			struct rt_vol_internal *vol;

			vol = (struct rt_vol_internal *)internal.idb_ptr;
			RT_VOL_CK_MAGIC( vol );

			bn_mat_mul( temp, mirmat, vol->mat );
			MAT_COPY( vol->mat, temp );

			break;
		}
		case ID_SUPERELL:
		{
			struct rt_superell_internal *superell;

			superell = (struct rt_superell_internal *)internal.idb_ptr;
			RT_SUPERELL_CK_MAGIC( superell );

			superell->v[k] *= -1.0;
			superell->a[k] *= -1.0;
			superell->b[k] *= -1.0;
			superell->c[k] *= -1.0;
			superell->n = 1.0;
			superell->e = 1.0;

			break;
		}
		case ID_COMBINATION:
		{
			struct rt_comb_internal	*comb;

			comb = (struct rt_comb_internal *)internal.idb_ptr;
			RT_CK_COMB(comb);

			if( comb->tree )
				db_tree_mul_dbleaf( comb->tree, mirmat );
			break;
		}
		default:
		{
			rt_db_free_internal( &internal, &rt_uniresource );
			Tcl_AppendResult(interp, "Cannot mirror this solid type\n", (char *)NULL);
			return TCL_ERROR;
		}
	}

	/* no interuprts */
	(void)signal( SIGINT, SIG_IGN );

	if( (dp = db_diradd( dbip, argv[2], -1L, 0, proto->d_flags, (genptr_t)&internal.idb_type)) == DIR_NULL )  {
	    	TCL_ALLOC_ERR_return;
	}
	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}

	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = argv[2]; /* depends on solid name being in argv[2] */
	  av[2] = NULL;

	  return cmd_draw( clientData, interp, 2, av );
	}
}

/* Modify Combination record information */
/* Format: edcomb combname Regionflag regionid air los GIFTmater */
int
f_edcomb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *dp;
	int regionid, air, mat, los;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 6 || 7 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help edcomb");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;
	if( (dp->d_flags & DIR_COMB) == 0 )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
	}

	regionid = atoi( argv[3] );
	air = atoi( argv[4] );
	los = atoi( argv[5] );
	mat = atoi( argv[6] );

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR_return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	if( argv[2][0] == 'R' )
		comb->region_flag = 1;
	else
		comb->region_flag = 0;
	comb->region_id = regionid;
	comb->aircode = air;
	comb->los = los;
	comb->GIFTmater = mat;
	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

/* tell him it already exists */
void
aexists(char *name)
{
  Tcl_AppendResult(interp, name, ":  already exists\n", (char *)NULL);
}

/*
 *  			F _ M A K E
 *  
 *  Create a new solid of a given type
 *  (Generic, or explicit)
 */
int
f_make(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	register struct directory *dp;
	int i;
	struct rt_db_internal	internal;
	struct rt_arb_internal	*arb_ip;
	struct rt_ars_internal	*ars_ip;
	struct rt_tgc_internal	*tgc_ip;
	struct rt_ell_internal	*ell_ip;
	struct rt_tor_internal	*tor_ip;
	struct rt_grip_internal	*grp_ip;
	struct rt_half_internal *half_ip;
	struct rt_rpc_internal *rpc_ip;
	struct rt_rhc_internal *rhc_ip;
	struct rt_epa_internal *epa_ip;
	struct rt_ehy_internal *ehy_ip;
	struct rt_eto_internal *eto_ip;
	struct rt_part_internal *part_ip;
	struct rt_pipe_internal *pipe_ip;
	struct rt_sketch_internal *sketch_ip;
	struct rt_extrude_internal *extrude_ip;
	struct rt_bot_internal *bot_ip;
	struct rt_arbn_internal *arbn_ip;
	struct rt_superell_internal	*superell_ip;

	if(argc == 2){
	  struct bu_vls vls;

	  if(argv[1][0] == '-' && argv[1][1] == 't'){
	    Tcl_AppendElement(interp, "arb8");
	    Tcl_AppendElement(interp, "arb7");
	    Tcl_AppendElement(interp, "arb6");
	    Tcl_AppendElement(interp, "arb5");
	    Tcl_AppendElement(interp, "arb4");
	    Tcl_AppendElement(interp, "arbn");
	    Tcl_AppendElement(interp, "ars");
	    Tcl_AppendElement(interp, "bot");
	    Tcl_AppendElement(interp, "ehy");
	    Tcl_AppendElement(interp, "ell");
	    Tcl_AppendElement(interp, "ell1");
	    Tcl_AppendElement(interp, "epa");
	    Tcl_AppendElement(interp, "eto");
	    Tcl_AppendElement(interp, "extrude");
	    Tcl_AppendElement(interp, "grip");
	    Tcl_AppendElement(interp, "half");
	    Tcl_AppendElement(interp, "nmg");
	    Tcl_AppendElement(interp, "part");
	    Tcl_AppendElement(interp, "pipe");
	    Tcl_AppendElement(interp, "rcc");
	    Tcl_AppendElement(interp, "rec");
	    Tcl_AppendElement(interp, "rhc");
	    Tcl_AppendElement(interp, "rpc");
	    Tcl_AppendElement(interp, "rpp");
	    Tcl_AppendElement(interp, "sketch");
	    Tcl_AppendElement(interp, "sph");
	    Tcl_AppendElement(interp, "tec");
	    Tcl_AppendElement(interp, "tgc");
	    Tcl_AppendElement(interp, "tor");
	    Tcl_AppendElement(interp, "trc");
	    Tcl_AppendElement(interp, "superell");

	    return TCL_OK;
	  }

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help make");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc != 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help make");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip,  argv[1], LOOKUP_QUIET ) != DIR_NULL )  {
	  aexists( argv[1] );
	  return TCL_ERROR;
	}

	RT_INIT_DB_INTERNAL( &internal );

	/* make name <arb8 | arb7 | arb6 | arb5 | arb4 | ellg | ell | superell
	 * sph | tor | tgc | rec | trc | rcc | grp | half | nmg | bot | sketch | extrude> */
	if (strcmp(argv[2], "arb8") == 0 ||
	    strcmp(argv[2],  "rpp") == 0)  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0] ,
			-view_state->vs_vop->vo_center[MDX] +view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDY] -view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDZ] -view_state->vs_vop->vo_scale );
		for( i=1 ; i<8 ; i++ )			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_vop->vo_scale*2.0;
		for( i=4 ; i<8 ; i++ )
			arb_ip->pt[i][X] -= view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[5][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[6][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[6][Z] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[7][Z] += view_state->vs_vop->vo_scale*2.0;
	} else if( strcmp( argv[2], "arb7" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0] ,
			-view_state->vs_vop->vo_center[MDX] +view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDY] -view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDZ] -(0.5*view_state->vs_vop->vo_scale) );
		for( i=1 ; i<8 ; i++ )
			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_vop->vo_scale;
		for( i=4 ; i<8 ; i++ )
			arb_ip->pt[i][X] -= view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[5][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[6][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[6][Z] += view_state->vs_vop->vo_scale;
	} else if( strcmp( argv[2], "arb6" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0],
			-view_state->vs_vop->vo_center[MDX] +view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDY] -view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDZ] -view_state->vs_vop->vo_scale );
		for( i=1 ; i<8 ; i++ )
			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_vop->vo_scale*2.0;
		for( i=4 ; i<8 ; i++ )
			arb_ip->pt[i][X] -= view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[4][Y] += view_state->vs_vop->vo_scale;
		arb_ip->pt[5][Y] += view_state->vs_vop->vo_scale;
		arb_ip->pt[6][Y] += view_state->vs_vop->vo_scale;
		arb_ip->pt[6][Z] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[7][Y] += view_state->vs_vop->vo_scale;
		arb_ip->pt[7][Z] += view_state->vs_vop->vo_scale*2.0;
	} else if( strcmp( argv[2], "arb5" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0] ,
			-view_state->vs_vop->vo_center[MDX] +view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDY] -view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDZ] -view_state->vs_vop->vo_scale );
		for( i=1 ; i<8 ; i++ )
			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_vop->vo_scale*2.0;
		for( i=4 ; i<8 ; i++ )
		{
			arb_ip->pt[i][X] -= view_state->vs_vop->vo_scale*2.0;
			arb_ip->pt[i][Y] += view_state->vs_vop->vo_scale;
			arb_ip->pt[i][Z] += view_state->vs_vop->vo_scale;
		}
	} else if( strcmp( argv[2], "arb4" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0] ,
			-view_state->vs_vop->vo_center[MDX] +view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDY] -view_state->vs_vop->vo_scale,
			-view_state->vs_vop->vo_center[MDZ] -view_state->vs_vop->vo_scale );
		for( i=1 ; i<8 ; i++ )
			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[3][Y] += view_state->vs_vop->vo_scale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_vop->vo_scale*2.0;
		for( i=4 ; i<8 ; i++ )
		{
			arb_ip->pt[i][X] -= view_state->vs_vop->vo_scale*2.0;
			arb_ip->pt[i][Y] += view_state->vs_vop->vo_scale*2.0;
		}
	} else if( strcmp( argv[2], "arbn") == 0 ) {
		point_t view_center;

		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ARBN;
		internal.idb_meth = &rt_functab[ID_ARBN];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof( struct rt_arbn_internal), "rt_arbn_internal" );
		arbn_ip = (struct rt_arbn_internal *)internal.idb_ptr;
		arbn_ip->magic = RT_ARBN_INTERNAL_MAGIC;
		arbn_ip->neqn = 8;
		arbn_ip->eqn = (plane_t *)bu_calloc( arbn_ip->neqn,
			     sizeof( plane_t ), "arbn plane eqns" );
		VSET( arbn_ip->eqn[0], 1, 0, 0 );
		arbn_ip->eqn[0][3] = view_state->vs_vop->vo_scale;
		VSET( arbn_ip->eqn[1], -1, 0, 0 );
		arbn_ip->eqn[1][3] = view_state->vs_vop->vo_scale;
		VSET( arbn_ip->eqn[2], 0, 1, 0 );
		arbn_ip->eqn[2][3] = view_state->vs_vop->vo_scale;
		VSET( arbn_ip->eqn[3], 0, -1, 0 );
		arbn_ip->eqn[3][3] = view_state->vs_vop->vo_scale;
		VSET( arbn_ip->eqn[4], 0, 0, 1 );
		arbn_ip->eqn[4][3] = view_state->vs_vop->vo_scale;
		VSET( arbn_ip->eqn[5], 0, 0, -1 );
		arbn_ip->eqn[5][3] = view_state->vs_vop->vo_scale;
		VSET( arbn_ip->eqn[6], 0.57735, 0.57735, 0.57735 );
		arbn_ip->eqn[6][3] = view_state->vs_vop->vo_scale;
		VSET( arbn_ip->eqn[7], -0.57735, -0.57735, -0.57735 );
		arbn_ip->eqn[7][3] = view_state->vs_vop->vo_scale;
		VSET( view_center, 
			-view_state->vs_vop->vo_center[MDX],
			-view_state->vs_vop->vo_center[MDY],
		        -view_state->vs_vop->vo_center[MDZ] );
		for( i=0 ; i<arbn_ip->neqn ; i++ ) {
			arbn_ip->eqn[i][3] +=
				VDOT( view_center, arbn_ip->eqn[i] );
		}
	} else if( strcmp( argv[2], "ars" ) == 0 )  {
	        int curve;
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ARS;
		internal.idb_meth = &rt_functab[ID_ARS];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ars_internal) , "rt_ars_internal" );
		ars_ip = (struct rt_ars_internal *)internal.idb_ptr;
		ars_ip->magic = RT_ARS_INTERNAL_MAGIC;
		ars_ip->ncurves = 3;
		ars_ip->pts_per_curve = 3;
		ars_ip->curves = (fastf_t **)bu_malloc((ars_ip->ncurves+1) * sizeof(fastf_t **), "ars curve ptrs" );
		
		for ( curve=0 ; curve < ars_ip->ncurves ; curve++ ) {
		    ars_ip->curves[curve] = (fastf_t *)bu_calloc(
			     (ars_ip->pts_per_curve + 1) * 3,
			     sizeof(fastf_t), "ARS points");

		    if (curve == 0) {
			VSET( &(ars_ip->curves[0][0]),
			      -view_state->vs_vop->vo_center[MDX],
			      -view_state->vs_vop->vo_center[MDY],
			      -view_state->vs_vop->vo_center[MDZ] );
			VMOVE(&(ars_ip->curves[curve][3]), &(ars_ip->curves[curve][0]));
			VMOVE(&(ars_ip->curves[curve][6]), &(ars_ip->curves[curve][0]));
		    } else if (curve == (ars_ip->ncurves - 1) ) {
			VSET( &(ars_ip->curves[curve][0]),
			      -view_state->vs_vop->vo_center[MDX],
			      -view_state->vs_vop->vo_center[MDY],
			      -view_state->vs_vop->vo_center[MDZ]+curve*(0.25*view_state->vs_vop->vo_scale));
			VMOVE(&(ars_ip->curves[curve][3]), &(ars_ip->curves[curve][0]));
			VMOVE(&(ars_ip->curves[curve][6]), &(ars_ip->curves[curve][0]));

		    } else {
			fastf_t x, y, z;
			x = -view_state->vs_vop->vo_center[MDX]+curve*(0.25*view_state->vs_vop->vo_scale);
			y = -view_state->vs_vop->vo_center[MDY]+curve*(0.25*view_state->vs_vop->vo_scale);
			z = -view_state->vs_vop->vo_center[MDZ]+curve*(0.25*view_state->vs_vop->vo_scale);

			VSET(&ars_ip->curves[curve][0], 
			      -view_state->vs_vop->vo_center[MDX],
			      -view_state->vs_vop->vo_center[MDY],
			     z);
			VSET(&ars_ip->curves[curve][3], 
			     x,
			      -view_state->vs_vop->vo_center[MDY],
			     z);
			VSET(&ars_ip->curves[curve][6], 
			     x, y, z);
		    }
		}

	} else if( strcmp( argv[2], "sph" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ELL;
		internal.idb_meth = &rt_functab[ID_ELL];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
		ell_ip = (struct rt_ell_internal *)internal.idb_ptr;
		ell_ip->magic = RT_ELL_INTERNAL_MAGIC;
		VSET( ell_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ] );
		VSET( ell_ip->a, (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );	/* A */
		VSET( ell_ip->b, 0.0, (0.5*view_state->vs_vop->vo_scale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.5*view_state->vs_vop->vo_scale) );	/* C */
	} else if(( strcmp( argv[2], "grp" ) == 0 ) ||
		  ( strcmp( argv[2], "grip") == 0 )) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_GRIP;
		internal.idb_meth = &rt_functab[ID_GRIP];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_grip_internal), "rt_grp_internal" );
		grp_ip = (struct rt_grip_internal *) internal.idb_ptr;
		grp_ip->magic = RT_GRIP_INTERNAL_MAGIC;
		VSET( grp_ip->center, -view_state->vs_vop->vo_center[MDX], -view_state->vs_vop->vo_center[MDY],
		    -view_state->vs_vop->vo_center[MDZ]);
		VSET( grp_ip->normal, 1.0, 0.0, 0.0);
		grp_ip->mag = view_state->vs_vop->vo_scale*0.75;
	} else if( strcmp( argv[2], "ell1" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ELL;
		internal.idb_meth = &rt_functab[ID_ELL];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
		ell_ip = (struct rt_ell_internal *)internal.idb_ptr;
		ell_ip->magic = RT_ELL_INTERNAL_MAGIC;
		VSET( ell_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ] );
		VSET( ell_ip->a, (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );	/* A */
		VSET( ell_ip->b, 0.0, (0.25*view_state->vs_vop->vo_scale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.25*view_state->vs_vop->vo_scale) );	/* C */
	} else if( strcmp( argv[2], "ell" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ELL;
		internal.idb_meth = &rt_functab[ID_ELL];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
		ell_ip = (struct rt_ell_internal *)internal.idb_ptr;
		ell_ip->magic = RT_ELL_INTERNAL_MAGIC;
		VSET( ell_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ] );
		VSET( ell_ip->a, view_state->vs_vop->vo_scale, 0.0, 0.0 );		/* A */
		VSET( ell_ip->b, 0.0, (0.5*view_state->vs_vop->vo_scale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.25*view_state->vs_vop->vo_scale) );	/* C */
	} else if( strcmp( argv[2], "tor" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_TOR;
		internal.idb_meth = &rt_functab[ID_TOR];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tor_internal) , "rt_tor_internal" );
		tor_ip = (struct rt_tor_internal *)internal.idb_ptr;
		tor_ip->magic = RT_TOR_INTERNAL_MAGIC;
		VSET( tor_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ] );
		VSET( tor_ip->h , 1.0 , 0.0 , 0.0 );	/* unit normal */
		tor_ip->r_h = 0.5*view_state->vs_vop->vo_scale;
		tor_ip->r_a = view_state->vs_vop->vo_scale;
		tor_ip->r_b = view_state->vs_vop->vo_scale;
		VSET( tor_ip->a , 0.0 , view_state->vs_vop->vo_scale , 0.0 );
		VSET( tor_ip->b , 0.0 , 0.0 , view_state->vs_vop->vo_scale );
	} else if( strcmp( argv[2], "tgc" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_vop->vo_scale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*view_state->vs_vop->vo_scale), 0.0 );
		VSET( tgc_ip->c,  (0.25*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.5*view_state->vs_vop->vo_scale), 0.0 );
	} else if( strcmp( argv[2], "tec" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_vop->vo_scale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*view_state->vs_vop->vo_scale), 0.0 );
		VSET( tgc_ip->c,  (0.25*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.125*view_state->vs_vop->vo_scale), 0.0 );
	} else if( strcmp( argv[2], "rec" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_vop->vo_scale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*view_state->vs_vop->vo_scale), 0.0 );
		VSET( tgc_ip->c,  (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.25*view_state->vs_vop->vo_scale), 0.0 );
	} else if( strcmp( argv[2], "trc" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_vop->vo_scale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.5*view_state->vs_vop->vo_scale), 0.0 );
		VSET( tgc_ip->c,  (0.25*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.25*view_state->vs_vop->vo_scale), 0.0 );
	} else if( strcmp( argv[2], "rcc" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_vop->vo_scale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.5*view_state->vs_vop->vo_scale), 0.0 );
		VSET( tgc_ip->c,  (0.5*view_state->vs_vop->vo_scale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.5*view_state->vs_vop->vo_scale), 0.0 );
	} else if( strcmp( argv[2], "half" ) == 0 ) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_HALF;
		internal.idb_meth = &rt_functab[ID_HALF];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_half_internal) , "rt_half_internal" );
		half_ip = (struct rt_half_internal *)internal.idb_ptr;
		half_ip->magic = RT_HALF_INTERNAL_MAGIC;
		VSET( half_ip->eqn , 0.0 , 0.0 , 1.0 );
		half_ip->eqn[3] = (-view_state->vs_vop->vo_center[MDZ]);
	} else if( strcmp( argv[2], "rpc" ) == 0 ) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_RPC;
		internal.idb_meth = &rt_functab[ID_RPC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_rpc_internal) , "rt_rpc_internal" );
		rpc_ip = (struct rt_rpc_internal *)internal.idb_ptr;
		rpc_ip->rpc_magic = RT_RPC_INTERNAL_MAGIC;
		VSET( rpc_ip->rpc_V, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale*0.5 );
		VSET( rpc_ip->rpc_H, 0.0, 0.0, view_state->vs_vop->vo_scale );
		VSET( rpc_ip->rpc_B, 0.0, (view_state->vs_vop->vo_scale*0.5), 0.0 );
		rpc_ip->rpc_r = view_state->vs_vop->vo_scale*0.25;
	} else if( strcmp( argv[2], "rhc" ) == 0 ) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_RHC;
		internal.idb_meth = &rt_functab[ID_RHC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_rhc_internal) , "rt_rhc_internal" );
		rhc_ip = (struct rt_rhc_internal *)internal.idb_ptr;
		rhc_ip->rhc_magic = RT_RHC_INTERNAL_MAGIC;
		VSET( rhc_ip->rhc_V, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale*0.5 );
		VSET( rhc_ip->rhc_H, 0.0, 0.0, view_state->vs_vop->vo_scale );
		VSET( rhc_ip->rhc_B, 0.0, (view_state->vs_vop->vo_scale*0.5), 0.0 );
		rhc_ip->rhc_r = view_state->vs_vop->vo_scale*0.25;
		rhc_ip->rhc_c = view_state->vs_vop->vo_scale*0.10;
	} else if( strcmp( argv[2], "epa" ) == 0 ) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_EPA;
		internal.idb_meth = &rt_functab[ID_EPA];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_epa_internal) , "rt_epa_internal" );
		epa_ip = (struct rt_epa_internal *)internal.idb_ptr;
		epa_ip->epa_magic = RT_EPA_INTERNAL_MAGIC;
		VSET( epa_ip->epa_V, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale*0.5 );
		VSET( epa_ip->epa_H, 0.0, 0.0, view_state->vs_vop->vo_scale );
		VSET( epa_ip->epa_Au, 0.0, 1.0, 0.0 );
		epa_ip->epa_r1 = view_state->vs_vop->vo_scale*0.5;
		epa_ip->epa_r2 = view_state->vs_vop->vo_scale*0.25;
	} else if( strcmp( argv[2], "ehy" ) == 0 ) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_EHY;
		internal.idb_meth = &rt_functab[ID_EHY];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ehy_internal) , "rt_ehy_internal" );
		ehy_ip = (struct rt_ehy_internal *)internal.idb_ptr;
		ehy_ip->ehy_magic = RT_EHY_INTERNAL_MAGIC;
		VSET( ehy_ip->ehy_V, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale*0.5 );
		VSET( ehy_ip->ehy_H, 0.0, 0.0, view_state->vs_vop->vo_scale );
		VSET( ehy_ip->ehy_Au, 0.0, 1.0, 0.0 );
		ehy_ip->ehy_r1 = view_state->vs_vop->vo_scale*0.5;
		ehy_ip->ehy_r2 = view_state->vs_vop->vo_scale*0.25;
		ehy_ip->ehy_c = ehy_ip->ehy_r2;
	} else if( strcmp( argv[2], "eto" ) == 0 ) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_ETO;
		internal.idb_meth = &rt_functab[ID_ETO];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_eto_internal) , "rt_eto_internal" );
		eto_ip = (struct rt_eto_internal *)internal.idb_ptr;
		eto_ip->eto_magic = RT_ETO_INTERNAL_MAGIC;
		VSET( eto_ip->eto_V, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ] );
		VSET( eto_ip->eto_N, 0.0, 0.0, 1.0 );
		VSET( eto_ip->eto_C, view_state->vs_vop->vo_scale*0.1, 0.0, view_state->vs_vop->vo_scale*0.1 );
		eto_ip->eto_r = view_state->vs_vop->vo_scale*0.5;
		eto_ip->eto_rd = view_state->vs_vop->vo_scale*0.05;
	} else if( strcmp( argv[2], "part" ) == 0 ) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_PARTICLE;
		internal.idb_meth = &rt_functab[ID_PARTICLE];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_part_internal) , "rt_part_internal" );
		part_ip = (struct rt_part_internal *)internal.idb_ptr;
		part_ip->part_magic = RT_PART_INTERNAL_MAGIC;
		VSET( part_ip->part_V, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale*0.5 );
		VSET( part_ip->part_H, 0.0, 0.0, view_state->vs_vop->vo_scale );
		part_ip->part_vrad = view_state->vs_vop->vo_scale*0.5;
		part_ip->part_hrad = view_state->vs_vop->vo_scale*0.25;
		part_ip->part_type = RT_PARTICLE_TYPE_CONE;
	} else if( strcmp( argv[2], "nmg" ) == 0 ) {
		struct model *m;
		struct nmgregion *r;
		struct shell *s;

		m = nmg_mm();
		r = nmg_mrsv( m );
		s = BU_LIST_FIRST( shell , &r->s_hd );
		nmg_vertex_g( s->vu_p->v_p, -view_state->vs_vop->vo_center[MDX], -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);
		(void)nmg_meonvu( s->vu_p );
		(void)nmg_ml( s );
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_NMG;
		internal.idb_meth = &rt_functab[ID_NMG];
		internal.idb_ptr = (genptr_t)m;
	} else if( strcmp( argv[2], "pipe" ) == 0 ) {
		struct wdb_pipept *ps;

		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_PIPE;
		internal.idb_meth = &rt_functab[ID_PIPE];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_pipe_internal), "rt_pipe_internal" );
		pipe_ip = (struct rt_pipe_internal *)internal.idb_ptr;
		pipe_ip->pipe_magic = RT_PIPE_INTERNAL_MAGIC;
		BU_LIST_INIT( &pipe_ip->pipe_segs_head );
		BU_GETSTRUCT( ps, wdb_pipept );
		ps->l.magic = WDB_PIPESEG_MAGIC;
		VSET( ps->pp_coord, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		ps->pp_od = 0.5*view_state->vs_vop->vo_scale;
		ps->pp_id = 0.5*ps->pp_od;
		ps->pp_bendradius = ps->pp_od;
		BU_LIST_INSERT( &pipe_ip->pipe_segs_head, &ps->l );
		BU_GETSTRUCT( ps, wdb_pipept );
		ps->l.magic = WDB_PIPESEG_MAGIC;
		VSET( ps->pp_coord, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]+view_state->vs_vop->vo_scale );
		ps->pp_od = 0.5*view_state->vs_vop->vo_scale;
		ps->pp_id = 0.5*ps->pp_od;
		ps->pp_bendradius = ps->pp_od;
		BU_LIST_INSERT( &pipe_ip->pipe_segs_head, &ps->l );
	} else if( strcmp( argv[2], "bot" ) == 0 ) {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_BOT;
		internal.idb_meth = &rt_functab[ID_BOT];
		BU_GETSTRUCT( bot_ip, rt_bot_internal );
		internal.idb_ptr = (genptr_t)bot_ip;
		bot_ip = (struct rt_bot_internal *)internal.idb_ptr;
		bot_ip->magic = RT_BOT_INTERNAL_MAGIC;
		bot_ip->mode = RT_BOT_SOLID;
		bot_ip->orientation = RT_BOT_UNORIENTED;
		bot_ip->num_vertices = 4;
		bot_ip->num_faces = 4;
		bot_ip->faces = (int *)bu_calloc( bot_ip->num_faces * 3, sizeof( int ), "BOT faces" );
		bot_ip->vertices = (fastf_t *)bu_calloc( bot_ip->num_vertices * 3, sizeof( fastf_t ), "BOT vertices" );
		bot_ip->thickness = (fastf_t *)NULL;
		bot_ip->face_mode = (struct bu_bitv *)NULL;
		VSET( &bot_ip->vertices[0],  -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]+view_state->vs_vop->vo_scale );
		VSET( &bot_ip->vertices[3], -view_state->vs_vop->vo_center[MDX]-0.5*view_state->vs_vop->vo_scale , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		VSET( &bot_ip->vertices[6], -view_state->vs_vop->vo_center[MDX]-0.5*view_state->vs_vop->vo_scale , -view_state->vs_vop->vo_center[MDY]-0.5*view_state->vs_vop->vo_scale , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		VSET( &bot_ip->vertices[9], -view_state->vs_vop->vo_center[MDX]+0.5*view_state->vs_vop->vo_scale , -view_state->vs_vop->vo_center[MDY]-0.5*view_state->vs_vop->vo_scale , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale );
		VSET( &bot_ip->faces[0], 0, 1, 3 );
		VSET( &bot_ip->faces[3], 0, 1, 2 );
		VSET( &bot_ip->faces[6], 0, 2, 3 );
		VSET( &bot_ip->faces[9], 1, 2, 3 );
	} else if( strcmp( argv[2], "extrude" ) == 0 ) {
		char *av[3];

		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_EXTRUDE;
		internal.idb_meth = &rt_functab[ID_EXTRUDE];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof( struct rt_extrude_internal), "rt_extrude_internal" );
		extrude_ip = (struct rt_extrude_internal *)internal.idb_ptr;
		extrude_ip->magic = RT_EXTRUDE_INTERNAL_MAGIC;
		VSET( extrude_ip->V, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale*0.5 );
		VSET( extrude_ip->h, 0.0, 0.0, view_state->vs_vop->vo_scale/3.0 );
		VSET( extrude_ip->u_vec, 1.0, 0.0, 0.0 );
		VSET( extrude_ip->v_vec, 0.0, 1.0, 0.0 );
		extrude_ip->keypoint = 0;
		av[0] = "make_name";
		av[1] = "skt_";
		Tcl_ResetResult( interp );
		cmd_make_name( (ClientData)NULL, interp, 2, av );
		extrude_ip->sketch_name = bu_strdup( interp->result );
		Tcl_ResetResult( interp );
		extrude_ip->skt = (struct rt_sketch_internal *)NULL;
		av[0] = "make";
		av[1] = extrude_ip->sketch_name;
		av[2] = "sketch";
		f_make( clientData, interp, 3, av );
	} else if( strcmp( argv[2], "sketch" ) == 0 ) {
		struct carc_seg *csg;
		struct line_seg *lsg;

		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_SKETCH;
		internal.idb_meth = &rt_functab[ID_SKETCH];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_sketch_internal), "rt_sketch_internal" );
		sketch_ip = (struct rt_sketch_internal *)internal.idb_ptr;
		sketch_ip->magic = RT_SKETCH_INTERNAL_MAGIC;
		VSET( sketch_ip->u_vec, 1.0, 0.0, 0.0 );
		VSET( sketch_ip->v_vec, 0.0, 1.0, 0.0 );
		VSET( sketch_ip->V, -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ]-view_state->vs_vop->vo_scale*0.5 );
		sketch_ip->vert_count = 7;
		sketch_ip->verts = (point2d_t *)bu_calloc( sketch_ip->vert_count, sizeof( point2d_t ), "sketch_ip->verts" );
		sketch_ip->verts[0][0] = 0.25*view_state->vs_vop->vo_scale;
		sketch_ip->verts[0][1] = 0.0;
		sketch_ip->verts[1][0] = 0.5*view_state->vs_vop->vo_scale;
		sketch_ip->verts[1][1] = 0.0;
		sketch_ip->verts[2][0] = 0.5*view_state->vs_vop->vo_scale;
		sketch_ip->verts[2][1] = 0.5*view_state->vs_vop->vo_scale;
		sketch_ip->verts[3][0] = 0.0;
		sketch_ip->verts[3][1] = 0.5*view_state->vs_vop->vo_scale;
		sketch_ip->verts[4][0] = 0.0;
		sketch_ip->verts[4][1] = 0.25*view_state->vs_vop->vo_scale;
		sketch_ip->verts[5][0] = 0.25*view_state->vs_vop->vo_scale;
		sketch_ip->verts[5][1] = 0.25*view_state->vs_vop->vo_scale;
		sketch_ip->verts[6][0] = 0.125*view_state->vs_vop->vo_scale;
		sketch_ip->verts[6][1] = 0.125*view_state->vs_vop->vo_scale;
		sketch_ip->skt_curve.seg_count = 6;
		sketch_ip->skt_curve.reverse = (int *)bu_calloc( sketch_ip->skt_curve.seg_count, sizeof( int ), "sketch_ip->skt_curve.reverse" );
		sketch_ip->skt_curve.segments = (genptr_t *)bu_calloc( sketch_ip->skt_curve.seg_count, sizeof( genptr_t ), "sketch_ip->skt_curve.segments" );

		csg = (struct carc_seg *)bu_calloc( 1, sizeof( struct carc_seg ), "segments" );
		sketch_ip->skt_curve.segments[0] = (genptr_t)csg;
		csg->magic = CURVE_CARC_MAGIC;
		csg->start = 4;
		csg->end = 0;
		csg->radius = 0.25*view_state->vs_vop->vo_scale;
		csg->center_is_left = 1;
		csg->orientation = 0;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->skt_curve.segments[1] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 0;
		lsg->end = 1;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->skt_curve.segments[2] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 1;
		lsg->end = 2;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->skt_curve.segments[3] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 2;
		lsg->end = 3;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->skt_curve.segments[4] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 3;
		lsg->end = 4;

		csg = (struct carc_seg *)bu_calloc( 1, sizeof( struct carc_seg ), "segments" );
		sketch_ip->skt_curve.segments[5] = (genptr_t)csg;
		csg->magic = CURVE_CARC_MAGIC;
		csg->start = 6;
		csg->end = 5;
		csg->radius = -1.0;
		csg->center_is_left = 1;
		csg->orientation = 0;
	} else if( strcmp( argv[2], "superell" ) == 0 )  {


		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_SUPERELL;
		internal.idb_meth = &rt_functab[ID_SUPERELL];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_superell_internal) , "rt_superell_internal" );
		superell_ip = (struct rt_superell_internal *)internal.idb_ptr;
		superell_ip->magic = RT_SUPERELL_INTERNAL_MAGIC;
		VSET( superell_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ] );
		VSET( superell_ip->a, view_state->vs_vop->vo_scale, 0.0, 0.0 );		/* A */
		VSET( superell_ip->b, 0.0, (0.5*view_state->vs_vop->vo_scale), 0.0 );	/* B */
		VSET( superell_ip->c, 0.0, 0.0, (0.25*view_state->vs_vop->vo_scale) );	/* C */
		superell_ip->n = 1.0;
		superell_ip->e = 1.0;
	  fprintf(stdout, "superell being made with %f and %f\n", superell_ip->n, superell_ip->e);

	} else if (strcmp(argv[2], "hf") == 0) {
		Tcl_AppendResult(interp, "make: the height field is deprecated and not supported by this command.\nUse the dsp primitive.\n", (char *)NULL);
		return TCL_ERROR;
	} else if (strcmp(argv[2], "pg") == 0 ||
		   strcmp(argv[2], "poly") == 0) {
		Tcl_AppendResult(interp, "make: the polysolid is deprecated and not supported by this command.\nUse the bot primitive.\n", (char *)NULL);
		return TCL_ERROR;
	} else if (strcmp(argv[2], "cline") == 0 ||
		   strcmp(argv[2], "dsp") == 0 ||
		   strcmp(argv[2], "ebm") == 0 ||
		   strcmp(argv[2], "nurb") == 0 ||
		   strcmp(argv[2], "spline") == 0 ||
		   strcmp(argv[2], "submodel") == 0 ||
		   strcmp(argv[2], "vol") == 0) {
		Tcl_AppendResult(interp, "make: the ", argv[2], " primitive is not supported by this command.\n", (char *)NULL);
		return TCL_ERROR;
	} else {
	  Tcl_AppendResult(interp, "make:  ", argv[2], " is not a known primitive\n",
			   "\tchoices are: arb8, arb7, arb6, arb5, arb4, arbn, ars, bot,\n",
			   "\t\tehy, ell, ell1, epa, eto, extrude, grip, half, nmg,\n",
			   "\t\tpart, pipe, rcc, rec, rhc, rpc, sketch, sph, tec,\n",
			   "\t\ttgc, tor, trc\n",  /* , superell\n", */
			   (char *)NULL);
	  return TCL_ERROR;
	}

	/* no interuprts */
	(void)signal( SIGINT, SIG_IGN );

	if( (dp = db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&internal.idb_type)) == DIR_NULL )  {
	    	TCL_ALLOC_ERR_return;
	}
	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}

	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = argv[1]; /* depends on name being in argv[1] */
	  av[2] = NULL;

	  /* draw the "made" solid */
	  return cmd_draw( clientData, interp, 2, av );
	}
}

int
mged_rot_obj(Tcl_Interp *interp, int iflag, fastf_t *argvect)
{
	point_t model_pt;
	point_t point;
	point_t s_point;
	mat_t temp;
	vect_t v_work;

  update_views = 1;

  if(movedir != ROTARROW) {
    /* NOT in object rotate mode - put it in obj rot */
    movedir = ROTARROW;
  }

  /* find point for rotation to take place wrt */
#if 0
  MAT4X3PNT(model_pt, es_mat, es_keypoint);
#else
  VMOVE(model_pt, es_keypoint);
#endif
  MAT4X3PNT(point, modelchanges, model_pt);

  /* Find absolute translation vector to go from "model_pt" to
   * 	"point" without any of the rotations in "modelchanges"
   */
  VSCALE(s_point, point, modelchanges[15]);
  VSUB2(v_work, s_point, model_pt);

  /* REDO "modelchanges" such that:
   *	1. NO rotations (identity)
   *	2. trans == v_work
   *	3. same scale factor
   */
  MAT_IDN(temp);
  MAT_DELTAS(temp, v_work[X], v_work[Y], v_work[Z]);
  temp[15] = modelchanges[15];
  MAT_COPY(modelchanges, temp);

  /* build new rotation matrix */
  MAT_IDN(temp);
  bn_mat_angles(temp, argvect[0], argvect[1], argvect[2]);

  if(iflag){
    /* apply accumulated rotations */
    bn_mat_mul2(acc_rot_sol, temp);
  }

  /*XXX*/ MAT_COPY(acc_rot_sol, temp); /* used to rotate solid/object axis */
  
  /* Record the new rotation matrix into the revised
   *	modelchanges matrix wrt "point"
   */
  wrt_point(modelchanges, temp, modelchanges, point);

#ifdef DO_NEW_EDIT_MATS
  new_edit_mats();
#else
  new_mats();
#endif

  return TCL_OK;
}


/* allow precise changes to object rotation */
int
f_rot_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int iflag = 0;
  vect_t argvect;

  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  if(argc < 4 || 5 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if( not_state( ST_O_EDIT, "Object Rotation" ) )
    return TCL_ERROR;

  /* Check for -i option */
  if(argv[1][0] == '-' && argv[1][1] == 'i'){
    iflag = 1;  /* treat arguments as incremental values */
    ++argv;
    --argc;
  }

  if(argc != 4)
    return TCL_ERROR;

  argvect[0] = atof(argv[1]);
  argvect[1] = atof(argv[2]);
  argvect[2] = atof(argv[3]);

  return mged_rot_obj(interp, iflag, argvect);
}

/* allow precise changes to object scaling, both local & global */
int
f_sc_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	mat_t incr;
	vect_t point, temp;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2 || 2 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help oscale");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_O_EDIT, "Object Scaling" ) )
	  return TCL_ERROR;

	if( atof(argv[1]) <= 0.0 ) {
	  Tcl_AppendResult(interp, "ERROR: scale factor <=  0\n", (char *)NULL);
	  return TCL_ERROR;
	}

	update_views = 1;

#if 0
	if(movedir != SARROW) {
		/* Put in global object scale mode */
		if( edobj == 0 )
			edobj = BE_O_SCALE;	/* default is global scaling */
		movedir = SARROW;
	}
#endif

	MAT_IDN(incr);

	/* switch depending on type of scaling to do */
	switch( edobj ) {
	default:
	case BE_O_SCALE:
		/* global scaling */
		incr[15] = 1.0 / (atof(argv[1]) * modelchanges[15]);
		break;
	case BE_O_XSCALE:
		/* local scaling ... X-axis */
		incr[0] = atof(argv[1]) / acc_sc[0];
		acc_sc[0] = atof(argv[1]);
		break;
	case BE_O_YSCALE:
		/* local scaling ... Y-axis */
		incr[5] = atof(argv[1]) / acc_sc[1];
		acc_sc[1] = atof(argv[1]);
		break;
	case BE_O_ZSCALE:
		/* local scaling ... Z-axis */
		incr[10] = atof(argv[1]) / acc_sc[2];
		acc_sc[2] = atof(argv[1]);
		break;
	}

	/* find point the scaling is to take place wrt */
#if 0
	MAT4X3PNT(temp, es_mat, es_keypoint);
#else
	VMOVE(temp, es_keypoint);
#endif
	MAT4X3PNT(point, modelchanges, temp);

	wrt_point(modelchanges, incr, modelchanges, point);
#ifdef DO_NEW_EDIT_MATS
	new_edit_mats();
#else
	new_mats();
#endif

	return TCL_OK;
}

/*
 *			F _ T R _ O B J
 *
 *  Bound to command "translate"
 *
 *  Allow precise changes to object translation
 */
int
f_tr_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;
	mat_t incr, old;
	vect_t model_sol_pt, model_incr, ed_sol_pt, new_vertex;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help translate");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( state == ST_S_EDIT )  {
		/* In solid edit mode,
		 * perform the equivalent of "press sxy" and "p xyz"
		 */
		if( be_s_trans(clientData, interp, argc, argv) == TCL_ERROR )
			return TCL_ERROR;
		return f_param(clientData, interp, argc, argv);
	}

	if( not_state( ST_O_EDIT, "Object Translation") )
	  return TCL_ERROR;

	/* Remainder of code concerns object edit case */

	update_views = 1;

	MAT_IDN(incr);
	MAT_IDN(old);

	if( (movedir & (RARROW|UARROW)) == 0 ) {
		/* put in object trans mode */
		movedir = UARROW | RARROW;
	}

	for(i=0; i<3; i++) {
		new_vertex[i] = atof(argv[i+1]) * local2base;
	}
#if 0
	MAT4X3PNT(model_sol_pt, es_mat, es_keypoint);
#else
	VMOVE(model_sol_pt, es_keypoint);
#endif
	MAT4X3PNT(ed_sol_pt, modelchanges, model_sol_pt);
	VSUB2(model_incr, new_vertex, ed_sol_pt);
	MAT_DELTAS(incr, model_incr[0], model_incr[1], model_incr[2]);
	MAT_COPY(old,modelchanges);
	bn_mat_mul(modelchanges, incr, old);
#ifdef DO_NEW_EDIT_MATS
	new_edit_mats();
#else
	new_mats();
#endif

	return TCL_OK;
}

/* Change the default region ident codes: item air los mat
 */
int
f_regdef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if (argc == 1) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "ident %d air %d los %d material %d",
		  item_default, air_default, los_default, mat_default);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  if(argc < 2 || 5 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help regdef");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  view_state->vs_flag = 1;
  item_default = atoi(argv[1]);
  wdbp->wdb_item_default = item_default;

  if(argc == 2)
    return TCL_OK;

  air_default = atoi(argv[2]);
  wdbp->wdb_air_default = air_default;
  if(air_default) {
    item_default = 0;
    wdbp->wdb_item_default = 0;
  }

  if(argc == 3)
    return TCL_OK;

  los_default = atoi(argv[3]);
  wdbp->wdb_los_default = los_default;

  if(argc == 4)
    return TCL_OK;

  mat_default = atoi(argv[4]);
  wdbp->wdb_mat_default = mat_default;

  return TCL_OK;
}

static int frac_stat;
void
mged_add_nmg_part(char *newname, struct model *m)
{
	struct rt_db_internal	new_intern;
	struct directory *new_dp;
	struct nmgregion *r;

	if(dbip == DBI_NULL)
	  return;

	if( db_lookup( dbip,  newname, LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( newname );
		/* Free memory here */
		nmg_km(m);
		frac_stat = 1;
		return;
	}

	if( (new_dp=db_diradd( dbip, newname, -1, 0, DIR_SOLID, (genptr_t)&new_intern.idb_type)) == DIR_NULL )  {
	    	TCL_ALLOC_ERR;
		return;
	}

	/* make sure the geometry/bounding boxes are up to date */
	for (BU_LIST_FOR(r, nmgregion, &m->r_hd))
		nmg_region_a(r, &mged_tol);


	/* Export NMG as a new solid */
	RT_INIT_DB_INTERNAL(&new_intern);
	new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	new_intern.idb_type = ID_NMG;
	new_intern.idb_meth = &rt_functab[ID_NMG];
	new_intern.idb_ptr = (genptr_t)m;

	if( rt_db_put_internal( new_dp, dbip, &new_intern, &rt_uniresource ) < 0 )  {
		/* Free memory */
		nmg_km(m);
		Tcl_AppendResult(interp, "rt_db_put_internal() failure\n", (char *)NULL);
		frac_stat = 1;
		return;
	}
	/* Internal representation has been freed by rt_db_put_internal */
	new_intern.idb_ptr = (genptr_t)NULL;
	frac_stat = 0;
}
/*
 *			F _ F R A C T U R E
 *
 * Usage: fracture nmgsolid [prefix]
 *
 *	given an NMG solid, break it up into several NMG solids, each
 *	containing a single shell with a single sub-element.
 */
int
f_fracture(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;
	struct directory *old_dp;
	struct rt_db_internal	old_intern;
	struct model	*m, *new_model;
	char		newname[32];
	char		prefix[32];
	int	maxdigits;
	struct nmgregion *r, *new_r;
	struct shell *s, *new_s;
	struct faceuse *fu;
	struct vertex *v_new, *v;
	unsigned long tw, tf, tp;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help fracture");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	Tcl_AppendResult(interp, "fracture:", (char *)NULL);
	for (i=0 ; i < argc ; i++)
		Tcl_AppendResult(interp, " ", argv[i], (char *)NULL);
	Tcl_AppendResult(interp, "\n", (char *)NULL);

	if( (old_dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &old_intern, old_dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )  {
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( old_intern.idb_type != ID_NMG )
	{
		Tcl_AppendResult(interp, argv[1], " is not an NMG solid!!\n", (char *)NULL );
		rt_db_free_internal( &old_intern, &rt_uniresource );
		return TCL_ERROR;
	}

	m = (struct model *)old_intern.idb_ptr;
	NMG_CK_MODEL(m);

	/* how many characters of the solid names do we reserve for digits? */
	nmg_count_shell_kids(m, &tf, &tw, &tp);
	
	maxdigits = (int)(log10((double)(tf+tw+tp)) + 1.0);

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "%d = %d digits\n", tf+tw+tp, maxdigits);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	/*	for(maxdigits=1,i=tf+tw+tp ; i > 0 ; i /= 10)
	 *	maxdigits++;
	 */

	/* get the prefix for the solids to be created. */
	bzero(prefix, sizeof(prefix));
	strncpy(prefix, argv[argc-1], sizeof(prefix)-2-maxdigits);
	strcat(prefix, "_");

	/* Bust it up here */

	i = 1;
	for (BU_LIST_FOR(r, nmgregion, &m->r_hd)) {
		NMG_CK_REGION(r);
		for (BU_LIST_FOR(s, shell, &r->s_hd)) {
			NMG_CK_SHELL(s);
			if (s->vu_p) {
				NMG_CK_VERTEXUSE(s->vu_p);
				NMG_CK_VERTEX(s->vu_p->v_p);
				v = s->vu_p->v_p;

/*	nmg_start_dup(m); */
				new_model = nmg_mm();
				new_r = nmg_mrsv(new_model);
				new_s = BU_LIST_FIRST(shell, &r->s_hd);
				v_new = new_s->vu_p->v_p;
				if (v->vg_p) {
					nmg_vertex_gv(v_new, v->vg_p->coord);
				}
/*	nmg_end_dup(); */

				sprintf(newname, "%s%0*d", prefix, maxdigits, i++);

				mged_add_nmg_part(newname, new_model);
				if (frac_stat) return CMD_BAD;
				continue;
			}
			for (BU_LIST_FOR(fu, faceuse, &s->fu_hd)) {
				if (fu->orientation != OT_SAME)
					continue;

				NMG_CK_FACEUSE(fu);

				new_model = nmg_mm();
				NMG_CK_MODEL(new_model);
				new_r = nmg_mrsv(new_model);
				NMG_CK_REGION(new_r);
				new_s = BU_LIST_FIRST(shell, &new_r->s_hd);
				NMG_CK_SHELL(new_s);
/*	nmg_start_dup(m); */
				NMG_CK_SHELL(new_s);
				nmg_dup_face(fu, new_s);
/*	nmg_end_dup(); */

				sprintf(newname, "%s%0*d", prefix, maxdigits, i++);
				mged_add_nmg_part(newname, new_model);
				if (frac_stat) return CMD_BAD;
			}
#if 0
			while (BU_LIST_NON_EMPTY(&s->lu_hd)) {
				lu = BU_LIST_FIRST(loopuse, &s->lu_hd);
				new_model = nmg_mm();
				r = nmg_mrsv(new_model);
				new_s = BU_LIST_FIRST(shell, &r->s_hd);

				nmg_dup_loop(lu, new_s);
				nmg_klu(lu);

				sprintf(newname, "%s%0*d", prefix, maxdigits, i++);
				mged_add_nmg_part(newname, new_model);
				if (frac_stat) return CMD_BAD;
			}
			while (BU_LIST_NON_EMPTY(&s->eu_hd)) {
				eu = BU_LIST_FIRST(edgeuse, &s->eu_hd);
				new_model = nmg_mm();
				r = nmg_mrsv(new_model);
				new_s = BU_LIST_FIRST(shell, &r->s_hd);

				nmg_dup_edge(eu, new_s);
				nmg_keu(eu);

				sprintf(newname, "%s%0*d", prefix, maxdigits, i++);

				mged_add_nmg_part(newname, new_model);
				if (frac_stat) return TCL_ERROR;
			}
#endif
		}
	}
	return TCL_OK;

}
/*
 *			F _ Q O R O T
 *
 * Usage: qorot x y z dx dy dz theta
 *
 *	rotate an object through a specified angle
 *	about a specified ray.
 */
int
f_qorot(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	mat_t temp;
	vect_t s_point, point, v_work, model_pt;
	vect_t	specified_pt, direc;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 8 || 8 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help qorot");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_O_EDIT, "Object Rotation" ) )
	  return TCL_ERROR;

	if(movedir != ROTARROW) {
		/* NOT in object rotate mode - put it in obj rot */
		movedir = ROTARROW;
	}
	VSET(specified_pt, atof(argv[1]), atof(argv[2]), atof(argv[3]));
	VSCALE(specified_pt, specified_pt, dbip->dbi_local2base);
	VSET(direc, atof(argv[4]), atof(argv[5]), atof(argv[6]));

	/* find point for rotation to take place wrt */
	MAT4X3PNT(model_pt, es_mat, specified_pt);
	MAT4X3PNT(point, modelchanges, model_pt);

	/* Find absolute translation vector to go from "model_pt" to
	 * 	"point" without any of the rotations in "modelchanges"
	 */
	VSCALE(s_point, point, modelchanges[15]);
	VSUB2(v_work, s_point, model_pt);

	/* REDO "modelchanges" such that:
	 *	1. NO rotations (identity)
	 *	2. trans == v_work
	 *	3. same scale factor
	 */
	MAT_IDN(temp);
	MAT_DELTAS(temp, v_work[X], v_work[Y], v_work[Z]);
	temp[15] = modelchanges[15];
	MAT_COPY(modelchanges, temp);

	/* build new rotation matrix */
	MAT_IDN(temp);
	bn_mat_angles(temp, 0.0, 0.0, atof(argv[7]));

	/* Record the new rotation matrix into the revised
	 *	modelchanges matrix wrt "point"
	 */
	wrt_point_direc(modelchanges, temp, modelchanges, point, direc);

#ifdef DO_NEW_EDIT_MATS
	new_edit_mats();
#else
	new_mats();
#endif

	return TCL_OK;
}

void
set_localunit_TclVar(void)
{
  struct bu_vls vls;
  struct bu_vls units_vls;
  const char	*str;

  if (dbip == DBI_NULL)
	  return;

  bu_vls_init(&vls);
  bu_vls_init(&units_vls);

  str = bu_units_string(dbip->dbi_local2base);
  if(str)
	bu_vls_strcpy(&units_vls, str);
  else
	bu_vls_printf(&units_vls, "%gmm", dbip->dbi_local2base);

  bu_vls_strcpy(&vls, "localunit");
  Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&units_vls), TCL_GLOBAL_ONLY);

  bu_vls_free(&vls);
  bu_vls_free(&units_vls);
}


int
f_binary(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char 		**argv)
{
	CHECK_DBI_NULL;

	return wdb_binary_cmd(wdbp, interp, argc, argv);
}

int cmd_smooth_bot( ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char 		**argv)
{
	CHECK_DBI_NULL;

	return wdb_smooth_bot_cmd( wdbp, interp, argc, argv );
}
@


11.146
log
@change conf.h to a wrapped config.h
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/chgmodel.c,v 11.145 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.145
log
@merge of ansi-6-0-branch into HEAD
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d38 5
a42 1
#include "conf.h"
@


11.144
log
@merge of windows-6-0-branch into head
@
text
@d69 1
a69 1
void	aexists();
d83 1
a83 5
f_itemair(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d158 1
a158 5
f_mater(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d330 1
a330 5
f_edmater(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    *argv[];
d590 1
a590 5
f_comb_color(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d650 1
a650 5
f_shader(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d706 1
a706 5
f_mirror(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1185 16
d1244 1
a1244 5
f_edcomb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1298 1
a1298 2
aexists( name )
char	*name;
d1336 1
d1372 1
d1404 1
a1404 1
	/* make name <arb8 | arb7 | arb6 | arb5 | arb4 | ellg | ell |
d1976 17
d2014 1
a2014 1
			   "\t\ttgc, tor, trc\n",
d2042 1
a2042 4
mged_rot_obj(interp, iflag, argvect)
Tcl_Interp *interp;
int iflag;
vect_t argvect;
d2109 1
a2109 5
f_rot_obj(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2149 1
a2149 5
f_sc_obj(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2238 1
a2238 5
f_tr_obj(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2306 1
a2306 5
f_regdef(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2362 1
a2362 3
mged_add_nmg_part(newname, m)
char *newname;
struct model *m;
d2416 1
a2416 5
f_fracture(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2582 1
a2582 5
f_qorot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2651 1
a2651 1
set_localunit_TclVar()
@


11.143
log
@update copyright to include span through 2003
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.142 2003/01/31 13:39:05 jra Exp $ (BRL)";
d72 1
d74 3
d363 1
a363 1
#if 0
@


11.142
log
@Added "smooth_bot" command
@
text
@d31 1
a31 1
 *	This software is Copyright (C) 1985 by the United States Army.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.141 2002/11/27 13:43:47 jra Exp $ (BRL)";
@


11.142.6.1
log
@merge from HEAD
@
text
@d31 1
a31 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.143 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.142.6.2
log
@merge from head
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.142.6.1 2004/02/12 18:34:12 erikg Exp $ (BRL)";
@


11.142.6.3
log
@merge from head
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a71 1
#ifndef WIN32
a72 3
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d359 1
a359 1
#ifdef WIN32
@


11.141
log
@BOT primitives can now have vertex normals
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.140 2002/08/20 17:08:21 jra Exp $ (BRL)";
d2705 10
@


11.140
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.138 2002/04/16 02:34:58 jra Exp $ (BRL)";
d1864 2
a1865 1
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof( struct rt_bot_internal ), "rt_bot_internal" );
a1869 1
		bot_ip->error_mode = 0;
@


11.140.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.140 2002/08/20 17:08:21 jra Exp $ (BRL)";
a71 1
#ifndef WIN32
a72 3
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d359 1
a359 1
#ifdef WIN32
@


11.140.4.2
log
@sync to HEAD...
@
text
@d31 1
a31 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/chgmodel.c,v 11.140.4.1 2002/09/26 23:04:08 morrison Exp $ (BRL)";
d1868 1
a1868 2
		BU_GETSTRUCT( bot_ip, rt_bot_internal );
		internal.idb_ptr = (genptr_t)bot_ip;
d1873 1
a2708 10
}

int cmd_smooth_bot( ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char 		**argv)
{
	CHECK_DBI_NULL;

	return wdb_smooth_bot_cmd( wdbp, interp, argc, argv );
@


11.140.2.1
log
@Initial ANSIfication
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.140 2002/08/20 17:08:21 jra Exp $ (BRL)";
d69 1
a69 1
void	aexists(char *name);
d79 5
a83 1
f_itemair(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d158 5
a162 1
f_mater(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d334 5
a338 1
f_edmater(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d598 5
a602 1
f_comb_color(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d662 5
a666 1
f_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d722 5
a726 1
f_mirror(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1248 5
a1252 1
f_edcomb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1306 2
a1307 1
aexists(char *name)
d2032 4
a2035 1
mged_rot_obj(Tcl_Interp *interp, int iflag, fastf_t *argvect)
d2102 5
a2106 1
f_rot_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2146 5
a2150 1
f_sc_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2239 5
a2243 1
f_tr_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2311 5
a2315 1
f_regdef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2371 3
a2373 1
mged_add_nmg_part(char *newname, struct model *m)
d2427 5
a2431 1
f_fracture(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2597 5
a2601 1
f_qorot(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2670 1
a2670 1
set_localunit_TclVar(void)
@


11.140.2.2
log
@Added initial stubbed support for a new primitive -- a superquadric ellipsoid.  The primitive may be created in mged, but it has the same guts as the ellipsoid
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.140.2.1 2002/09/19 18:01:59 morrison Exp $ (BRL)";
a1180 14
		case ID_SUPERELL:
		{
			struct rt_superell_internal *superell;

			superell = (struct rt_superell_internal *)internal.idb_ptr;
			RT_SUPERELL_CK_MAGIC( superell );

			superell->v[k] *= -1.0;
			superell->a[k] *= -1.0;
			superell->b[k] *= -1.0;
			superell->c[k] *= -1.0;

			break;
		}
a1315 1
	struct rt_superell_internal	*superell_ip;
a1350 1
	    Tcl_AppendElement(interp, "superell");
d1382 1
a1382 1
	/* make name <arb8 | arb7 | arb6 | arb5 | arb4 | ellg | ell | superell
a1953 11
	} else if( strcmp( argv[2], "superell" ) == 0 )  {
		internal.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		internal.idb_type = ID_SUPERELL;
		internal.idb_meth = &rt_functab[ID_SUPERELL];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_superell_internal) , "rt_superell_internal" );
		superell_ip = (struct rt_superell_internal *)internal.idb_ptr;
		superell_ip->magic = RT_SUPERELL_INTERNAL_MAGIC;
		VSET( superell_ip->v , -view_state->vs_vop->vo_center[MDX] , -view_state->vs_vop->vo_center[MDY] , -view_state->vs_vop->vo_center[MDZ] );
		VSET( superell_ip->a, view_state->vs_vop->vo_scale, 0.0, 0.0 );		/* A */
		VSET( superell_ip->b, 0.0, (0.5*view_state->vs_vop->vo_scale), 0.0 );	/* B */
		VSET( superell_ip->c, 0.0, 0.0, (0.25*view_state->vs_vop->vo_scale) );	/* C */
d1975 1
a1975 1
			   "\t\ttgc, tor, trc, superell\n",
@


11.140.2.3
log
@Added the superell specific options and database support for <n,e>, the north-south and east-west curvature params.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.140.2.2 2003/01/31 00:11:54 morrison Exp $ (BRL)";
a1191 2
			superell->n = 1.0;
			superell->e = 1.0;
a1970 2


a1980 4
		superell_ip->n = 1.0;
		superell_ip->e = 1.0;
	  fprintf(stdout, "superell being made with %f and %f\n", superell_ip->n, superell_ip->e);

@


11.140.2.4
log
@sync branch with HEAD
@
text
@d31 1
a31 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a71 1
#ifndef WIN32
a72 3
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d347 1
a347 1
#ifdef WIN32
d1853 1
a1853 2
		BU_GETSTRUCT( bot_ip, rt_bot_internal );
		internal.idb_ptr = (genptr_t)bot_ip;
d1858 1
a2681 10
}

int cmd_smooth_bot( ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char 		**argv)
{
	CHECK_DBI_NULL;

	return wdb_smooth_bot_cmd( wdbp, interp, argc, argv );
@


11.139
log
@Converted from K&R to ANSI C - RFH
@
text
@d69 1
a69 1
void	aexists(char *name);
d79 5
a83 1
f_itemair(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d158 5
a162 1
f_mater(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d334 5
a338 1
f_edmater(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d598 5
a602 1
f_comb_color(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d662 5
a666 1
f_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d722 5
a726 1
f_mirror(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1248 5
a1252 1
f_edcomb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1306 2
a1307 1
aexists(char *name)
d2032 4
a2035 1
mged_rot_obj(Tcl_Interp *interp, int iflag, fastf_t *argvect)
d2102 5
a2106 1
f_rot_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2146 5
a2150 1
f_sc_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2239 5
a2243 1
f_tr_obj(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2311 5
a2315 1
f_regdef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2371 3
a2373 1
mged_add_nmg_part(char *newname, struct model *m)
d2427 5
a2431 1
f_fracture(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2597 5
a2601 1
f_qorot(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2670 1
a2670 1
set_localunit_TclVar(void)
@


11.138
log
@The "regdef" command now also sets the defaults in the rt_wdb structure.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.137 2001/11/15 22:07:05 bparker Exp $ (BRL)";
d69 1
a69 1
void	aexists();
d79 1
a79 5
f_itemair(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d154 1
a154 5
f_mater(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d326 1
a326 5
f_edmater(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    *argv[];
d586 1
a586 5
f_comb_color(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d646 1
a646 5
f_shader(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d702 1
a702 5
f_mirror(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1224 1
a1224 5
f_edcomb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1278 1
a1278 2
aexists( name )
char	*name;
d2003 1
a2003 4
mged_rot_obj(interp, iflag, argvect)
Tcl_Interp *interp;
int iflag;
vect_t argvect;
d2070 1
a2070 5
f_rot_obj(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2110 1
a2110 5
f_sc_obj(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2199 1
a2199 5
f_tr_obj(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2267 1
a2267 5
f_regdef(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2323 1
a2323 3
mged_add_nmg_part(newname, m)
char *newname;
struct model *m;
d2377 1
a2377 5
f_fracture(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2543 1
a2543 5
f_qorot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2612 1
a2612 1
set_localunit_TclVar()
@


11.137
log
@*- modified f_binary to use wdb_binary_cmd
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.136 2001/10/10 22:05:53 bparker Exp $ (BRL)";
d2342 1
d2348 2
a2349 1
  if(air_default) 
d2351 2
d2358 1
d2364 1
@


11.136
log
@*- minor mods to f_make's warning messages
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.135 2001/10/09 21:05:38 bparker Exp $ (BRL)";
d2691 5
a2695 17
f_binary(     ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char 		**argv)
{
	int c;
	struct bu_vls	vls;
	unsigned int major_type=0;
	unsigned int minor_type=0;
	char *obj_name;
	char *file_name;
	int input_mode=0;
	int output_mode=0;
	struct rt_binunif_internal *bip;
	struct rt_db_internal intern;
	struct directory *dp;

d2698 1
a2698 172
	optind = 1;
	while( (c=getopt(argc, argv, "iou:")) != -1 ) {
		switch( c ) {
			case 'i':
				input_mode = 1;
				break;
			case 'o':
				output_mode = 1;
				break;
			case 'u':
				major_type=DB5_MAJORTYPE_BINARY_UNIF;
				switch( *optarg ) {
				case 'f':
					minor_type = DB5_MINORTYPE_BINU_FLOAT;
					break;
				case 'd':
					minor_type = DB5_MINORTYPE_BINU_DOUBLE;
					break;
				case 'c':
					minor_type = DB5_MINORTYPE_BINU_8BITINT;
					break;
				case 's':
					minor_type = DB5_MINORTYPE_BINU_16BITINT;
					break;
				case 'i':
					minor_type = DB5_MINORTYPE_BINU_32BITINT;
					break;
				case 'l':
					minor_type = DB5_MINORTYPE_BINU_64BITINT;
					break;
				case 'C':
					minor_type = DB5_MINORTYPE_BINU_8BITINT_U;
					break;
				case 'S':
					minor_type = DB5_MINORTYPE_BINU_16BITINT_U;
					break;
				case 'I':
					minor_type = DB5_MINORTYPE_BINU_32BITINT_U;
					break;
				case 'L':
					minor_type = DB5_MINORTYPE_BINU_64BITINT_U;
					break;
				default:
					bu_vls_init( &vls );
					bu_vls_printf(&vls, "Unrecognized argument for '-u' option: %s",
						      optarg);
					Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
					bu_vls_free(&vls);
					return TCL_ERROR;
				}
				break;
			default:
				bu_vls_init( &vls );
				bu_vls_printf(&vls, "Unrecognized option - %c", c);
				Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
				bu_vls_free(&vls);
				return TCL_ERROR;
				
		}
	}

	if( input_mode + output_mode != 1 ) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help binary");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	argc -= optind;
	argv += optind;

	if( argc < 2 ) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib wdb_binary");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if( input_mode ) {
		if( minor_type == 0 ) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "helplib wdb_binary");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		obj_name = *argv;
		if( db_lookup( dbip, obj_name, LOOKUP_QUIET ) != DIR_NULL ) {
			bu_vls_init( &vls );
			bu_vls_printf( &vls, "Object %s already exists", obj_name );
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free( &vls );
			return TCL_ERROR;
		}

		argc--;
		argv++;

		file_name = *argv;

		if( mk_binunif( wdbp, obj_name, file_name, minor_type ) ) {
			Tcl_AppendResult(interp, "Error creating ", obj_name,
					 (char *)NULL );
			return TCL_ERROR;
		}

		return TCL_OK;

	} else if( output_mode ) {
		FILE *fd;
		int id;

		file_name = *argv;

		argc--;
		argv++;

		obj_name = *argv;

		if( (dp=db_lookup(dbip, obj_name, LOOKUP_NOISY )) == DIR_NULL ) { 
			return TCL_ERROR;
		}
		
		if( (fd=fopen( file_name, "w+")) == NULL ) {
			Tcl_AppendResult(interp, "Error: cannot open file ", file_name,
					 " for writing", (char *)NULL );
			return TCL_ERROR;
		}

		if( (id=rt_db_get_internal( &intern, dp, dbip, NULL,
					 &rt_uniresource )) < 0 ) {
			Tcl_AppendResult(interp, "Error reading ", dp->d_namep,
					 " from database", (char *)NULL );
			fclose( fd );
			return TCL_ERROR;
		}

		RT_CK_DB_INTERNAL( &intern );

		bip = (struct rt_binunif_internal *)intern.idb_ptr;
		if( bip->count < 1 ) {
			Tcl_AppendResult(interp, obj_name, " has no contents", (char *)NULL );
			fclose( fd );
			rt_db_free_internal( &intern, &rt_uniresource );
			return TCL_ERROR;
		}

		if( fwrite( bip->u.int8, bip->count * db5_type_sizeof_h_binu( bip->type ),
			    1, fd) != 1 ) {
			Tcl_AppendResult(interp, "Error writing contents to file",
					 (char *)NULL );
			fclose( fd );
			rt_db_free_internal( &intern, &rt_uniresource );
			return TCL_ERROR;
		}

		fclose( fd );
		rt_db_free_internal( &intern, &rt_uniresource );
		return TCL_OK;
	} else {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib wdb_binary");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* should never get here */
	/* return TCL_ERROR; */
@


11.135
log
@*- Modified MGED's make command to handle an rpp and to return more
   appropriate messages to the user about valid primitives not supported
   by make.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.134 2001/10/05 20:38:19 butler Exp $ (BRL)";
d1984 1
a1984 1
		Tcl_AppendResult(interp, "make: the height field is not supported by this command\nand is also deprecated. Use the dsp primitive.\n", (char *)NULL);
d1988 1
a1988 1
		Tcl_AppendResult(interp, "make: the polysolid is not supported by this command\nand is also deprecated. Use the bot primitive.\n", (char *)NULL);
@


11.134
log
@added support to "make" an ars
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.133 2001/10/05 17:44:58 jra Exp $ (BRL)";
d1373 1
d1413 2
a1414 1
	if( strcmp( argv[2], "arb8" ) == 0 )  {
d1983 16
a1998 10
	} else if( strcmp( argv[2], "ars" ) == 0 ||
		   strcmp( argv[2], "poly" ) == 0 ||
		   strcmp( argv[2], "ebm" ) == 0 ||
		   strcmp( argv[2], "dsp" ) == 0 ||
		   strcmp( argv[2], "vol" ) == 0 ||
		   strcmp( argv[2], "arbn" ) == 0 ||
		   strcmp( argv[2], "nurb" ) == 0 ||
		   strcmp( argv[2], "spline" ) == 0 )  {
	  Tcl_AppendResult(interp, "make ", argv[2], " not implimented yet\n", (char *)NULL);
	  return TCL_ERROR;
d2001 4
a2004 4
			   "\tchoices are: arb8, arb7, arb6, arb5, arb4, bot, ehy,\n",
			   "\t\tell, ell1, epa, eto, extrude, grip, half, nmg,\n",
			   "\t\tpart, pipe, rcc, rec, rhc, rpc, sketch, sph,\n",
			   "\t\ttec, tgc, tor, trc\n",
@


11.133
log
@Added arbn support to "make" command
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.132 2001/10/02 19:24:32 jra Exp $ (BRL)";
d1328 1
d1356 1
d1563 51
@


11.132
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.131 2001/09/19 22:23:14 bparker Exp $ (BRL)";
d1343 1
d1354 1
d1524 36
@


11.131
log
@*- add CHECK_DBI_NULL to f_binary()
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.130 2001/08/22 15:27:45 jra Exp $ (BRL)";
d1409 1
d1431 1
d1453 1
d1478 1
d1501 1
d1524 1
d1536 1
d1547 1
d1558 1
d1569 1
d1583 1
d1596 1
d1609 1
d1622 1
d1635 1
d1648 1
d1657 1
d1668 1
d1680 1
d1692 1
d1705 1
d1717 1
d1739 1
d1746 1
d1768 1
d1794 1
d1820 1
d2297 1
@


11.130
log
@commented out an unreachable line
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.129 2001/08/21 14:04:17 jra Exp $ (BRL)";
d2580 2
@


11.129
log
@"binary" command now displays its help message
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.128 2001/08/11 13:16:11 butler Exp $ (BRL)";
d2752 1
a2752 1
	return TCL_ERROR;
@


11.128
log
@misc compiler warning changes
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.127 2001/08/10 21:22:12 morrison Exp $ (BRL)";
d2644 1
a2644 1
		bu_vls_printf(&vls, "helplib wdb_binary");
@


11.127
log
@needed stdlib.h (I think)
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.126 2001/08/02 17:38:43 jra Exp $ (BRL)";
a2576 1
	struct bu_mapped_file *bu_fd;
a2675 1
			bu_close_mapped_file( bu_fd );
@


11.126
log
@Added "binary" command
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.125 2001/06/05 15:51:40 bparker Exp $ (BRL)";
d42 1
@


11.125
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.124 2001/06/01 19:23:23 bparker Exp $ (BRL)";
d2559 195
@


11.124
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.123 2001/05/04 14:43:27 bparker Exp $ (BRL)";
a1406 1
#ifdef MGED_USE_VIEW_OBJ
a1880 361
#else
	if( strcmp( argv[2], "arb8" ) == 0 )  {
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0] ,
			-view_state->vs_toViewcenter[MDX] +view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDY] -view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDZ] -view_state->vs_Viewscale );
		for( i=1 ; i<8 ; i++ )			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_Viewscale*2.0;
		for( i=4 ; i<8 ; i++ )
			arb_ip->pt[i][X] -= view_state->vs_Viewscale*2.0;
		arb_ip->pt[5][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[6][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[6][Z] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[7][Z] += view_state->vs_Viewscale*2.0;
	} else if( strcmp( argv[2], "arb7" ) == 0 )  {
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0] ,
			-view_state->vs_toViewcenter[MDX] +view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDY] -view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDZ] -(0.5*view_state->vs_Viewscale) );
		for( i=1 ; i<8 ; i++ )
			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_Viewscale;
		for( i=4 ; i<8 ; i++ )
			arb_ip->pt[i][X] -= view_state->vs_Viewscale*2.0;
		arb_ip->pt[5][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[6][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[6][Z] += view_state->vs_Viewscale;
	} else if( strcmp( argv[2], "arb6" ) == 0 )  {
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0],
			-view_state->vs_toViewcenter[MDX] +view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDY] -view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDZ] -view_state->vs_Viewscale );
		for( i=1 ; i<8 ; i++ )
			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_Viewscale*2.0;
		for( i=4 ; i<8 ; i++ )
			arb_ip->pt[i][X] -= view_state->vs_Viewscale*2.0;
		arb_ip->pt[4][Y] += view_state->vs_Viewscale;
		arb_ip->pt[5][Y] += view_state->vs_Viewscale;
		arb_ip->pt[6][Y] += view_state->vs_Viewscale;
		arb_ip->pt[6][Z] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[7][Y] += view_state->vs_Viewscale;
		arb_ip->pt[7][Z] += view_state->vs_Viewscale*2.0;
	} else if( strcmp( argv[2], "arb5" ) == 0 )  {
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0] ,
			-view_state->vs_toViewcenter[MDX] +view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDY] -view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDZ] -view_state->vs_Viewscale );
		for( i=1 ; i<8 ; i++ )
			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_Viewscale*2.0;
		for( i=4 ; i<8 ; i++ )
		{
			arb_ip->pt[i][X] -= view_state->vs_Viewscale*2.0;
			arb_ip->pt[i][Y] += view_state->vs_Viewscale;
			arb_ip->pt[i][Z] += view_state->vs_Viewscale;
		}
	} else if( strcmp( argv[2], "arb4" ) == 0 )  {
		internal.idb_type = ID_ARB8;
		internal.idb_meth = &rt_functab[ID_ARB8];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
		arb_ip = (struct rt_arb_internal *)internal.idb_ptr;
		arb_ip->magic = RT_ARB_INTERNAL_MAGIC;
		VSET( arb_ip->pt[0] ,
			-view_state->vs_toViewcenter[MDX] +view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDY] -view_state->vs_Viewscale,
			-view_state->vs_toViewcenter[MDZ] -view_state->vs_Viewscale );
		for( i=1 ; i<8 ; i++ )
			VMOVE( arb_ip->pt[i] , arb_ip->pt[0] );
		arb_ip->pt[1][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[2][Z] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[3][Y] += view_state->vs_Viewscale*2.0;
		arb_ip->pt[3][Z] += view_state->vs_Viewscale*2.0;
		for( i=4 ; i<8 ; i++ )
		{
			arb_ip->pt[i][X] -= view_state->vs_Viewscale*2.0;
			arb_ip->pt[i][Y] += view_state->vs_Viewscale*2.0;
		}
	} else if( strcmp( argv[2], "sph" ) == 0 )  {
		internal.idb_type = ID_ELL;
		internal.idb_meth = &rt_functab[ID_ELL];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
		ell_ip = (struct rt_ell_internal *)internal.idb_ptr;
		ell_ip->magic = RT_ELL_INTERNAL_MAGIC;
		VSET( ell_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ] );
		VSET( ell_ip->a, (0.5*view_state->vs_Viewscale), 0.0, 0.0 );	/* A */
		VSET( ell_ip->b, 0.0, (0.5*view_state->vs_Viewscale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.5*view_state->vs_Viewscale) );	/* C */
	} else if(( strcmp( argv[2], "grp" ) == 0 ) ||
		  ( strcmp( argv[2], "grip") == 0 )) {
		internal.idb_type = ID_GRIP;
		internal.idb_meth = &rt_functab[ID_GRIP];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_grip_internal), "rt_grp_internal" );
		grp_ip = (struct rt_grip_internal *) internal.idb_ptr;
		grp_ip->magic = RT_GRIP_INTERNAL_MAGIC;
		VSET( grp_ip->center, -view_state->vs_toViewcenter[MDX], -view_state->vs_toViewcenter[MDY],
		    -view_state->vs_toViewcenter[MDZ]);
		VSET( grp_ip->normal, 1.0, 0.0, 0.0);
		grp_ip->mag = view_state->vs_Viewscale*0.75;
	} else if( strcmp( argv[2], "ell1" ) == 0 )  {
		internal.idb_type = ID_ELL;
		internal.idb_meth = &rt_functab[ID_ELL];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
		ell_ip = (struct rt_ell_internal *)internal.idb_ptr;
		ell_ip->magic = RT_ELL_INTERNAL_MAGIC;
		VSET( ell_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ] );
		VSET( ell_ip->a, (0.5*view_state->vs_Viewscale), 0.0, 0.0 );	/* A */
		VSET( ell_ip->b, 0.0, (0.25*view_state->vs_Viewscale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.25*view_state->vs_Viewscale) );	/* C */
	} else if( strcmp( argv[2], "ell" ) == 0 )  {
		internal.idb_type = ID_ELL;
		internal.idb_meth = &rt_functab[ID_ELL];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
		ell_ip = (struct rt_ell_internal *)internal.idb_ptr;
		ell_ip->magic = RT_ELL_INTERNAL_MAGIC;
		VSET( ell_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ] );
		VSET( ell_ip->a, view_state->vs_Viewscale, 0.0, 0.0 );		/* A */
		VSET( ell_ip->b, 0.0, (0.5*view_state->vs_Viewscale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.25*view_state->vs_Viewscale) );	/* C */
	} else if( strcmp( argv[2], "tor" ) == 0 )  {
		internal.idb_type = ID_TOR;
		internal.idb_meth = &rt_functab[ID_TOR];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tor_internal) , "rt_tor_internal" );
		tor_ip = (struct rt_tor_internal *)internal.idb_ptr;
		tor_ip->magic = RT_TOR_INTERNAL_MAGIC;
		VSET( tor_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ] );
		VSET( tor_ip->h , 1.0 , 0.0 , 0.0 );	/* unit normal */
		tor_ip->r_h = 0.5*view_state->vs_Viewscale;
		tor_ip->r_a = view_state->vs_Viewscale;
		tor_ip->r_b = view_state->vs_Viewscale;
		VSET( tor_ip->a , 0.0 , view_state->vs_Viewscale , 0.0 );
		VSET( tor_ip->b , 0.0 , 0.0 , view_state->vs_Viewscale );
	} else if( strcmp( argv[2], "tgc" ) == 0 )  {
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*view_state->vs_Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.25*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.5*view_state->vs_Viewscale), 0.0 );
	} else if( strcmp( argv[2], "tec" ) == 0 )  {
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*view_state->vs_Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.25*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.125*view_state->vs_Viewscale), 0.0 );
	} else if( strcmp( argv[2], "rec" ) == 0 )  {
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*view_state->vs_Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.5*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.25*view_state->vs_Viewscale), 0.0 );
	} else if( strcmp( argv[2], "trc" ) == 0 )  {
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.5*view_state->vs_Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.25*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.25*view_state->vs_Viewscale), 0.0 );
	} else if( strcmp( argv[2], "rcc" ) == 0 )  {
		internal.idb_type = ID_TGC;
		internal.idb_meth = &rt_functab[ID_TGC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
		tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;
		tgc_ip->magic = RT_TGC_INTERNAL_MAGIC;
		VSET( tgc_ip->v , -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (view_state->vs_Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.5*view_state->vs_Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.5*view_state->vs_Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.5*view_state->vs_Viewscale), 0.0 );
	} else if( strcmp( argv[2], "half" ) == 0 ) {
		internal.idb_type = ID_HALF;
		internal.idb_meth = &rt_functab[ID_HALF];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_half_internal) , "rt_half_internal" );
		half_ip = (struct rt_half_internal *)internal.idb_ptr;
		half_ip->magic = RT_HALF_INTERNAL_MAGIC;
		VSET( half_ip->eqn , 0.0 , 0.0 , 1.0 );
		half_ip->eqn[3] = (-view_state->vs_toViewcenter[MDZ]);
	} else if( strcmp( argv[2], "rpc" ) == 0 ) {
		internal.idb_type = ID_RPC;
		internal.idb_meth = &rt_functab[ID_RPC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_rpc_internal) , "rt_rpc_internal" );
		rpc_ip = (struct rt_rpc_internal *)internal.idb_ptr;
		rpc_ip->rpc_magic = RT_RPC_INTERNAL_MAGIC;
		VSET( rpc_ip->rpc_V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale*0.5 );
		VSET( rpc_ip->rpc_H, 0.0, 0.0, view_state->vs_Viewscale );
		VSET( rpc_ip->rpc_B, 0.0, (view_state->vs_Viewscale*0.5), 0.0 );
		rpc_ip->rpc_r = view_state->vs_Viewscale*0.25;
	} else if( strcmp( argv[2], "rhc" ) == 0 ) {
		internal.idb_type = ID_RHC;
		internal.idb_meth = &rt_functab[ID_RHC];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_rhc_internal) , "rt_rhc_internal" );
		rhc_ip = (struct rt_rhc_internal *)internal.idb_ptr;
		rhc_ip->rhc_magic = RT_RHC_INTERNAL_MAGIC;
		VSET( rhc_ip->rhc_V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale*0.5 );
		VSET( rhc_ip->rhc_H, 0.0, 0.0, view_state->vs_Viewscale );
		VSET( rhc_ip->rhc_B, 0.0, (view_state->vs_Viewscale*0.5), 0.0 );
		rhc_ip->rhc_r = view_state->vs_Viewscale*0.25;
		rhc_ip->rhc_c = view_state->vs_Viewscale*0.10;
	} else if( strcmp( argv[2], "epa" ) == 0 ) {
		internal.idb_type = ID_EPA;
		internal.idb_meth = &rt_functab[ID_EPA];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_epa_internal) , "rt_epa_internal" );
		epa_ip = (struct rt_epa_internal *)internal.idb_ptr;
		epa_ip->epa_magic = RT_EPA_INTERNAL_MAGIC;
		VSET( epa_ip->epa_V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale*0.5 );
		VSET( epa_ip->epa_H, 0.0, 0.0, view_state->vs_Viewscale );
		VSET( epa_ip->epa_Au, 0.0, 1.0, 0.0 );
		epa_ip->epa_r1 = view_state->vs_Viewscale*0.5;
		epa_ip->epa_r2 = view_state->vs_Viewscale*0.25;
	} else if( strcmp( argv[2], "ehy" ) == 0 ) {
		internal.idb_type = ID_EHY;
		internal.idb_meth = &rt_functab[ID_EHY];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_ehy_internal) , "rt_ehy_internal" );
		ehy_ip = (struct rt_ehy_internal *)internal.idb_ptr;
		ehy_ip->ehy_magic = RT_EHY_INTERNAL_MAGIC;
		VSET( ehy_ip->ehy_V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale*0.5 );
		VSET( ehy_ip->ehy_H, 0.0, 0.0, view_state->vs_Viewscale );
		VSET( ehy_ip->ehy_Au, 0.0, 1.0, 0.0 );
		ehy_ip->ehy_r1 = view_state->vs_Viewscale*0.5;
		ehy_ip->ehy_r2 = view_state->vs_Viewscale*0.25;
		ehy_ip->ehy_c = ehy_ip->ehy_r2;
	} else if( strcmp( argv[2], "eto" ) == 0 ) {
		internal.idb_type = ID_ETO;
		internal.idb_meth = &rt_functab[ID_ETO];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_eto_internal) , "rt_eto_internal" );
		eto_ip = (struct rt_eto_internal *)internal.idb_ptr;
		eto_ip->eto_magic = RT_ETO_INTERNAL_MAGIC;
		VSET( eto_ip->eto_V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ] );
		VSET( eto_ip->eto_N, 0.0, 0.0, 1.0 );
		VSET( eto_ip->eto_C, view_state->vs_Viewscale*0.1, 0.0, view_state->vs_Viewscale*0.1 );
		eto_ip->eto_r = view_state->vs_Viewscale*0.5;
		eto_ip->eto_rd = view_state->vs_Viewscale*0.05;
	} else if( strcmp( argv[2], "part" ) == 0 ) {
		internal.idb_type = ID_PARTICLE;
		internal.idb_meth = &rt_functab[ID_PARTICLE];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_part_internal) , "rt_part_internal" );
		part_ip = (struct rt_part_internal *)internal.idb_ptr;
		part_ip->part_magic = RT_PART_INTERNAL_MAGIC;
		VSET( part_ip->part_V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale*0.5 );
		VSET( part_ip->part_H, 0.0, 0.0, view_state->vs_Viewscale );
		part_ip->part_vrad = view_state->vs_Viewscale*0.5;
		part_ip->part_hrad = view_state->vs_Viewscale*0.25;
		part_ip->part_type = RT_PARTICLE_TYPE_CONE;
	} else if( strcmp( argv[2], "nmg" ) == 0 ) {
		struct model *m;
		struct nmgregion *r;
		struct shell *s;

		m = nmg_mm();
		r = nmg_mrsv( m );
		s = BU_LIST_FIRST( shell , &r->s_hd );
		nmg_vertex_g( s->vu_p->v_p, -view_state->vs_toViewcenter[MDX], -view_state->vs_toViewcenter[MDY], -view_state->vs_toViewcenter[MDZ]);
		(void)nmg_meonvu( s->vu_p );
		(void)nmg_ml( s );
		internal.idb_type = ID_NMG;
		internal.idb_meth = &rt_functab[ID_NMG];
		internal.idb_ptr = (genptr_t)m;
	} else if( strcmp( argv[2], "pipe" ) == 0 ) {
		struct wdb_pipept *ps;

		internal.idb_type = ID_PIPE;
		internal.idb_meth = &rt_functab[ID_PIPE];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_pipe_internal), "rt_pipe_internal" );
		pipe_ip = (struct rt_pipe_internal *)internal.idb_ptr;
		pipe_ip->pipe_magic = RT_PIPE_INTERNAL_MAGIC;
		BU_LIST_INIT( &pipe_ip->pipe_segs_head );
		BU_GETSTRUCT( ps, wdb_pipept );
		ps->l.magic = WDB_PIPESEG_MAGIC;
		VSET( ps->pp_coord, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		ps->pp_od = 0.5*view_state->vs_Viewscale;
		ps->pp_id = 0.5*ps->pp_od;
		ps->pp_bendradius = ps->pp_od;
		BU_LIST_INSERT( &pipe_ip->pipe_segs_head, &ps->l );
		BU_GETSTRUCT( ps, wdb_pipept );
		ps->l.magic = WDB_PIPESEG_MAGIC;
		VSET( ps->pp_coord, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]+view_state->vs_Viewscale );
		ps->pp_od = 0.5*view_state->vs_Viewscale;
		ps->pp_id = 0.5*ps->pp_od;
		ps->pp_bendradius = ps->pp_od;
		BU_LIST_INSERT( &pipe_ip->pipe_segs_head, &ps->l );
	} else if( strcmp( argv[2], "bot" ) == 0 ) {
		internal.idb_type = ID_BOT;
		internal.idb_meth = &rt_functab[ID_BOT];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof( struct rt_bot_internal ), "rt_bot_internal" );
		bot_ip = (struct rt_bot_internal *)internal.idb_ptr;
		bot_ip->magic = RT_BOT_INTERNAL_MAGIC;
		bot_ip->mode = RT_BOT_SOLID;
		bot_ip->orientation = RT_BOT_UNORIENTED;
		bot_ip->error_mode = 0;
		bot_ip->num_vertices = 4;
		bot_ip->num_faces = 4;
		bot_ip->faces = (int *)bu_calloc( bot_ip->num_faces * 3, sizeof( int ), "BOT faces" );
		bot_ip->vertices = (fastf_t *)bu_calloc( bot_ip->num_vertices * 3, sizeof( fastf_t ), "BOT vertices" );
		bot_ip->thickness = (fastf_t *)NULL;
		bot_ip->face_mode = (struct bu_bitv *)NULL;
		VSET( &bot_ip->vertices[0],  -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]+view_state->vs_Viewscale );
		VSET( &bot_ip->vertices[3], -view_state->vs_toViewcenter[MDX]-0.5*view_state->vs_Viewscale , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		VSET( &bot_ip->vertices[6], -view_state->vs_toViewcenter[MDX]-0.5*view_state->vs_Viewscale , -view_state->vs_toViewcenter[MDY]-0.5*view_state->vs_Viewscale , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		VSET( &bot_ip->vertices[9], -view_state->vs_toViewcenter[MDX]+0.5*view_state->vs_Viewscale , -view_state->vs_toViewcenter[MDY]-0.5*view_state->vs_Viewscale , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale );
		VSET( &bot_ip->faces[0], 0, 1, 3 );
		VSET( &bot_ip->faces[3], 0, 1, 2 );
		VSET( &bot_ip->faces[6], 0, 2, 3 );
		VSET( &bot_ip->faces[9], 1, 2, 3 );
	} else if( strcmp( argv[2], "extrude" ) == 0 ) {
		char *av[3];
a1881 114
		internal.idb_type = ID_EXTRUDE;
		internal.idb_meth = &rt_functab[ID_EXTRUDE];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof( struct rt_extrude_internal), "rt_extrude_internal" );
		extrude_ip = (struct rt_extrude_internal *)internal.idb_ptr;
		extrude_ip->magic = RT_EXTRUDE_INTERNAL_MAGIC;
		VSET( extrude_ip->V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale*0.5 );
		VSET( extrude_ip->h, 0.0, 0.0, view_state->vs_Viewscale/3.0 );
		VSET( extrude_ip->u_vec, 1.0, 0.0, 0.0 );
		VSET( extrude_ip->v_vec, 0.0, 1.0, 0.0 );
		extrude_ip->keypoint = 0;
		av[0] = "make_name";
		av[1] = "skt_";
		Tcl_ResetResult( interp );
		cmd_make_name( (ClientData)NULL, interp, 2, av );
		extrude_ip->sketch_name = bu_strdup( interp->result );
		Tcl_ResetResult( interp );
		extrude_ip->skt = (struct rt_sketch_internal *)NULL;
		av[0] = "make";
		av[1] = extrude_ip->sketch_name;
		av[2] = "sketch";
		f_make( clientData, interp, 3, av );
	} else if( strcmp( argv[2], "sketch" ) == 0 ) {
		struct carc_seg *csg;
		struct line_seg *lsg;

		internal.idb_type = ID_SKETCH;
		internal.idb_meth = &rt_functab[ID_SKETCH];
		internal.idb_ptr = (genptr_t)bu_malloc( sizeof(struct rt_sketch_internal), "rt_sketch_internal" );
		sketch_ip = (struct rt_sketch_internal *)internal.idb_ptr;
		sketch_ip->magic = RT_SKETCH_INTERNAL_MAGIC;
		VSET( sketch_ip->u_vec, 1.0, 0.0, 0.0 );
		VSET( sketch_ip->v_vec, 0.0, 1.0, 0.0 );
		VSET( sketch_ip->V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale*0.5 );
		sketch_ip->vert_count = 7;
		sketch_ip->verts = (point2d_t *)bu_calloc( sketch_ip->vert_count, sizeof( point2d_t ), "sketch_ip->verts" );
		sketch_ip->verts[0][0] = 0.25*view_state->vs_Viewscale;
		sketch_ip->verts[0][1] = 0.0;
		sketch_ip->verts[1][0] = 0.5*view_state->vs_Viewscale;
		sketch_ip->verts[1][1] = 0.0;
		sketch_ip->verts[2][0] = 0.5*view_state->vs_Viewscale;
		sketch_ip->verts[2][1] = 0.5*view_state->vs_Viewscale;
		sketch_ip->verts[3][0] = 0.0;
		sketch_ip->verts[3][1] = 0.5*view_state->vs_Viewscale;
		sketch_ip->verts[4][0] = 0.0;
		sketch_ip->verts[4][1] = 0.25*view_state->vs_Viewscale;
		sketch_ip->verts[5][0] = 0.25*view_state->vs_Viewscale;
		sketch_ip->verts[5][1] = 0.25*view_state->vs_Viewscale;
		sketch_ip->verts[6][0] = 0.125*view_state->vs_Viewscale;
		sketch_ip->verts[6][1] = 0.125*view_state->vs_Viewscale;
		sketch_ip->skt_curve.seg_count = 6;
		sketch_ip->skt_curve.reverse = (int *)bu_calloc( sketch_ip->skt_curve.seg_count, sizeof( int ), "sketch_ip->skt_curve.reverse" );
		sketch_ip->skt_curve.segments = (genptr_t *)bu_calloc( sketch_ip->skt_curve.seg_count, sizeof( genptr_t ), "sketch_ip->skt_curve.segments" );

		csg = (struct carc_seg *)bu_calloc( 1, sizeof( struct carc_seg ), "segments" );
		sketch_ip->skt_curve.segments[0] = (genptr_t)csg;
		csg->magic = CURVE_CARC_MAGIC;
		csg->start = 4;
		csg->end = 0;
		csg->radius = 0.25*view_state->vs_Viewscale;
		csg->center_is_left = 1;
		csg->orientation = 0;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->skt_curve.segments[1] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 0;
		lsg->end = 1;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->skt_curve.segments[2] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 1;
		lsg->end = 2;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->skt_curve.segments[3] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 2;
		lsg->end = 3;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->skt_curve.segments[4] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 3;
		lsg->end = 4;

		csg = (struct carc_seg *)bu_calloc( 1, sizeof( struct carc_seg ), "segments" );
		sketch_ip->skt_curve.segments[5] = (genptr_t)csg;
		csg->magic = CURVE_CARC_MAGIC;
		csg->start = 6;
		csg->end = 5;
		csg->radius = -1.0;
		csg->center_is_left = 1;
		csg->orientation = 0;
	} else if( strcmp( argv[2], "ars" ) == 0 ||
		   strcmp( argv[2], "poly" ) == 0 ||
		   strcmp( argv[2], "ebm" ) == 0 ||
		   strcmp( argv[2], "dsp" ) == 0 ||
		   strcmp( argv[2], "vol" ) == 0 ||
		   strcmp( argv[2], "arbn" ) == 0 ||
		   strcmp( argv[2], "nurb" ) == 0 ||
		   strcmp( argv[2], "spline" ) == 0 )  {
	  Tcl_AppendResult(interp, "make ", argv[2], " not implimented yet\n", (char *)NULL);
	  return TCL_ERROR;
	} else {
	  Tcl_AppendResult(interp, "make:  ", argv[2], " is not a known primitive\n",
			   "\tchoices are: arb8, arb7, arb6, arb5, arb4, bot, ehy,\n",
			   "\t\tell, ell1, epa, eto, extrude, grip, half, nmg,\n",
			   "\t\tpart, pipe, rcc, rec, rhc, rpc, sketch, sph,\n",
			   "\t\ttec, tgc, tor, trc\n",
			   (char *)NULL);
	  return TCL_ERROR;
	}
#endif
@


11.123
log
@*- fix minor stuff
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.122 2001/05/04 14:20:45 bparker Exp $ (BRL)";
d1240 1
a1240 1
	  return f_edit( clientData, interp, 2, av );
d1318 4
a1321 5
f_make(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1407 476
d2357 1
a2357 1

d2376 1
a2376 1
	  return f_edit( clientData, interp, 2, av );
d2425 1
a2425 4
  buildHrot(temp,
	    argvect[0]*degtorad,
	    argvect[1]*degtorad,
	    argvect[2]*degtorad );
d2995 1
a2995 1
	buildHrot(temp, 0.0, 0.0, atof(argv[7])*degtorad);
@


11.122
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.121 2001/05/02 17:14:00 bparker Exp $ (BRL)";
a66 2
extern void update_grids();
void set_localunit_TclVar();
@


11.121
log
@*- modified commands to use new librt routines
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.120 2001/04/05 19:35:42 morrison Exp $ (BRL)";
a1304 51
/*
 *			F _ U N I T S
 *
 * Change the local units of the description.
 * Base unit is fixed in mm, so this just changes the current local unit
 * that the user works in.
 */
int
f_units(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	int		ret;
	fastf_t		sf;

	CHECK_DBI_NULL;

	sf = dbip->dbi_base2local;
	ret = wdb_units_cmd(wdbp, interp, argc, argv);

	set_localunit_TclVar();
	sf = dbip->dbi_base2local / sf;
	update_grids(sf);
	update_views = 1;

	return ret;
}

/*
 *	Change the current title of the description
 */
int
f_title(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	int	ret;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	ret = wdb_title_cmd(wdbp, interp, argc, argv);
	view_state->vs_flag = 1;

	return ret;
}

d1784 1
a1784 1
		f_make_name( (ClientData)NULL, interp, 2, av );
@


11.120
log
@updated SIGNED to signed
updated CONST to const
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.119 2001/04/03 19:01:59 bparker Exp $ (BRL)";
d1325 1
a1325 1
	ret = invoke_db_wrapper(interp, argc, argv);
d1350 1
a1350 1
	ret = invoke_db_wrapper(interp, argc, argv);
@


11.119
log
@*- get rid of warnings
*- use mkstemp instead of mktemp
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.118 2001/04/03 14:24:27 bparker Exp $ (BRL)";
d2597 1
a2597 1
  CONST char	*str;
@


11.118
log
@*- initialize sf in f_units()
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.117 2001/04/02 21:38:18 morrison Exp $ (BRL)";
d360 1
d363 3
@


11.117
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.116 2001/03/31 01:57:20 morrison Exp $ (BRL)";
d1320 1
@


11.116
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.115 2001/03/23 22:05:31 jra Exp $ (BRL)";
d1174 1
a1174 1
			bn_mat_copy( ebm->mat, temp );
d1186 1
a1186 1
			bn_mat_copy( dsp->dsp_mtos, temp);
d1198 1
a1198 1
			bn_mat_copy( vol->mat, temp );
d1994 1
a1994 1
  bn_mat_copy(modelchanges, temp);
d2008 1
a2008 1
  /*XXX*/ bn_mat_copy(acc_rot_sol, temp); /* used to rotate solid/object axis */
d2222 1
a2222 1
	bn_mat_copy(old,modelchanges);
d2567 1
a2567 1
	bn_mat_copy(modelchanges, temp);
@


11.115
log
@Support for major and minor types in directory structure
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgmodel.c,v 11.114 2001/03/22 18:23:00 bparker Exp $ (BRL)";
d775 1
a775 1
	bn_mat_idn( mirmat );
d1991 1
a1991 1
  bn_mat_idn(temp);
d1997 1
a1997 1
  bn_mat_idn(temp);
d2112 1
a2112 1
	bn_mat_idn(incr);
d2203 2
a2204 2
	bn_mat_idn(incr);
	bn_mat_idn(old);
d2564 1
a2564 1
	bn_mat_idn(temp);
d2570 1
a2570 1
	bn_mat_idn(temp);
@


11.114
log
@*- modify f_title to use LIBRT's wdb_title_tcl method
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgmodel.c,v 11.113 2001/03/22 16:19:38 bparker Exp $ (BRL)";
d1224 1
a1224 1
	if( (dp = db_diradd( dbip, argv[2], -1L, 0, proto->d_flags, NULL)) == DIR_NULL )  {
d1934 1
a1934 1
	if( (dp = db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )  {
d2309 1
a2309 1
	if( (new_dp=db_diradd( dbip, newname, -1, 0, DIR_SOLID, NULL)) == DIR_NULL )  {
@


11.113
log
@*- mods to f_make
*- mods to f_units
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgmodel.c,v 11.112 2001/03/21 22:15:58 bparker Exp $ (BRL)";
d1340 1
a1340 4
#if 0
#else
	struct bu_vls	title;
	int bad = 0;
a1342 16

	if(argc < 1){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help title");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if (argc == 1) {
	  Tcl_AppendResult(interp, dbip->dbi_title, "\n", (char *)NULL);
	  return TCL_OK;
	}

d1345 1
a1345 9
	bu_vls_init( &title );
	bu_vls_from_argv( &title, argc-1, argv+1 );

	if( db_update_ident( dbip, bu_vls_addr(&title), dbip->dbi_base2local ) < 0 )  {
	  Tcl_AppendResult(interp, "Error: unable to change database title\n");
	  bad = 1;
	}

	bu_vls_free( &title );
d1348 1
a1348 2
	return bad ? TCL_ERROR : TCL_OK;
#endif
@


11.112
log
@*- mods to use invoke_db_wrapper
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgmodel.c,v 11.111 2001/03/21 20:16:29 bparker Exp $ (BRL)";
a1319 1
#if 1
a1320 6
#else
	bu_vls_init(&vls);
	bu_build_cmd_vls(&vls, MGED_DB_NAME, argc, argv);
	ret = Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
#endif
d1340 2
d1376 1
d1435 1
d1445 1
a1450 2
	    Tcl_AppendElement(interp, "extrude");
	    Tcl_AppendElement(interp, "sketch");
d1951 4
a1954 2
			   "\tchoices are: arb8, arb7, arb6, arb5, arb4, bot, sph, ell, ellg, grip, tor,\n",
			   "\t\ttgc, tec, rec, trc, rcc, half, rpc, rhc, epa, ehy, eto, part, sketch extrude\n",
@


11.111
log
@*- modify f_units to use LIBRT's wdb_units_tcl method
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgmodel.c,v 11.110 2001/02/16 22:43:44 bparker Exp $ (BRL)";
a1315 1
	struct bu_vls	vls;
d1320 3
d1327 1
@


11.110
log
@*- check if (dbip == DBI_NULL) before doing anything
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.109 2001/02/05 21:26:50 jra Exp $ (BRL)";
d1315 3
a1317 5
	double	loc2mm;
	struct bu_vls vls;
	CONST char	*str;
	fastf_t sf;
	int sflag = 0;
d1322 3
a1324 46
	if(argc < 1 || 2 < argc){
	  bu_vls_printf(&vls, "help units");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if(argc == 2 && strcmp(argv[1], "-s") == 0){
	  --argc;
	  ++argv;

	  sflag = 1;
	}

	if( argc < 2 )  {
	  str = bu_units_string(dbip->dbi_local2base);
	  if(!str) str = "Unknown_unit";

	  if(sflag)
	    bu_vls_printf(&vls, "%s", str);
	  else
	    bu_vls_printf(&vls, "You are editing in '%s'.  1 %s = %g mm \n",
			  str, str, dbip->dbi_local2base );

	  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	  bu_vls_free(&vls);
	  return TCL_OK;
	}

	sf = dbip->dbi_base2local;

	/* Allow inputs of the form "25cm" or "3ft" */
	if( (loc2mm = bu_mm_value(argv[1]) ) <= 0 )  {
		  Tcl_AppendResult(interp, argv[1], ": unrecognized unit\n",
			   "valid units: <um|mm|cm|m|km|in|ft|yd|mi>\n", (char *)NULL);
		return TCL_ERROR;
	}

	if( db_update_ident( dbip, dbip->dbi_title, loc2mm ) < 0 )  {
		  Tcl_AppendResult(interp,
			   "Warning: unable to stash working units into database\n",
			   (char *)NULL);
	}

	dbip->dbi_local2base = loc2mm;
	dbip->dbi_base2local = 1.0 / loc2mm;
a1328 7

	str = bu_units_string(dbip->dbi_local2base);
	if(!str) str = "Unknown_unit";
	bu_vls_printf(&vls, "You are now editing in '%s'.  1 %s = %g mm \n",
			str, str, dbip->dbi_local2base );
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
d1331 1
a1331 1
	return TCL_OK;
@


11.109
log
@extrusion code in f_make() needed to bu_strdup() the sketch name
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.108 2001/01/29 20:29:38 jra Exp $ (BRL)";
d2672 3
@


11.108
log
@make now correctly distiguishes "ell" and "ell1"
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.107 2000/10/24 19:54:26 mike Exp $ (BRL)";
d1912 1
a1912 1
		strcpy( extrude_ip->sketch_name, interp->result );
@


11.107
log
@
Possible uninit
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.106 2000/10/24 19:05:04 mike Exp $ (BRL)";
d1485 1
a1485 1
	    Tcl_AppendElement(interp, "ellg");
d1668 1
a1668 1
	} else if( strcmp( argv[2], "ell" ) == 0 )  {
d1678 1
a1678 1
	} else if( strcmp( argv[2], "ellg" ) == 0 )  {
@


11.106
log
@
Fixed compiler lint, function declarations.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.105 2000/10/20 04:12:27 mike Exp $ (BRL)";
d87 1
a87 1
	int			ident, air, GIFTmater, los;
@


11.105
log
@
Eliminated 2 unused variables.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.104 2000/09/08 05:55:47 mike Exp $ (BRL)";
d63 1
@


11.104
log
@
Tree routines now need resource structure.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.103 2000/09/07 02:23:41 mike Exp $ (BRL)";
a1314 1
	int	new_unit = 0;
a1396 1
	int code;
@


11.103
log
@
Added externs to ged.h to fix lint
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.102 2000/08/19 03:10:11 mike Exp $ (BRL)";
d136 1
a136 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d149 1
a149 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d191 1
a191 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d324 1
a324 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d329 1
a329 1
	rt_db_free_internal( &intern );
d437 1
a437 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d450 1
a450 1
	rt_db_free_internal( &intern );
d509 1
a509 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d529 1
a529 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d626 1
a626 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d637 1
a637 1
	  rt_db_free_internal( &intern );
d645 1
a645 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d687 1
a687 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d696 1
a696 1
		rt_db_free_internal( &intern );
d706 1
a706 1
		if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d765 1
a765 1
	id = rt_db_get_internal( &internal, proto, dbip, NULL );
d1089 1
a1089 1
					rt_db_free_internal( &internal );
d1116 1
a1116 1
					rt_db_free_internal( &internal );
d1124 1
a1124 1
					rt_db_free_internal( &internal );
d1214 1
a1214 1
			rt_db_free_internal( &internal );
d1226 1
a1226 1
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )  {
d1280 1
a1280 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d1294 1
a1294 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d2017 1
a2017 1
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )  {
d2405 1
a2405 1
	if( rt_db_put_internal( new_dp, dbip, &new_intern ) < 0 )  {
d2465 1
a2465 1
	if( rt_db_get_internal( &old_intern, old_dp, dbip, bn_mat_identity ) < 0 )  {
d2473 1
a2473 1
		rt_db_free_internal( &old_intern );
@


11.102
log
@
Reduced use of MAXARGS
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.101 2000/07/13 01:10:14 mike Exp $ (BRL)";
d396 5
a400 5
f_wmater(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    *argv[];
d459 5
a463 5
f_rmater(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    *argv[];
d540 7
a546 8
extract_mater_from_line(line, name, shader, r, g, b, override, inherit)
char *line;
char *name;
char *shader;
int *r, *g, *b;
int *override;

int *inherit;
@


11.101
log
@
Changed to use db_update_ident().
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.100 2000/07/05 22:11:22 mike Exp $ (BRL)";
d323 1
a323 1
out:
d348 1
a348 1
  if(argc < 2 || MAXARGS < argc){
d411 1
a411 1
  if(argc < 3 || MAXARGS < argc){
d671 1
a671 1
	if(argc < 2 || MAXARGS < argc){
d1403 1
a1403 1
	if(argc < 1 || MAXARGS < argc){
a1922 1
		struct nurb_seg *nsg;
@


11.100
log
@
I have extended the "translate" command so that it also operates in
solid-edit mode.  Previously it was restricted to object-edit mode,
for no good reason.  In solid edit mode, "translate x y z" has the
effect of "press sxy" and "p x y z".
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.99 2000/06/30 19:58:09 mike Exp $ (BRL)";
d1363 1
a1363 6
	/* See if this is a known v4 database unit */
	if( (new_unit = db_v4_get_units_code(bu_units_string(loc2mm))) >= 0 ) {
		/* One of the recognized db.h units */
		/* change database to remember the new local unit */
		if( dbip->dbi_read_only ||
		 db_ident( dbip, dbip->dbi_title, new_unit ) < 0 )
a1366 8
	} else {
		/*
		 *  Can't stash requested units into the database for next session,
		 *  but there is no problem with the user editing in these units.
		 */
		Tcl_AppendResult(interp, "\
Due to a database restriction in the current format of .g files,\n\
this choice of units will not be remembered on your next editing session.\n", (char *)NULL);
d1368 1
d1423 1
a1423 2
	code = db_v4_get_units_code(bu_units_string(dbip->dbi_base2local));
	if( db_ident( dbip, bu_vls_addr(&title), code ) < 0 ) {
@


11.99
log
@
ft_ifree calls replaced properly
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.98 2000/06/08 21:38:42 bparker Exp $ (BRL)";
d2251 7
a2257 1
/* allow precise changes to object translation */
d2282 9
d2293 2
@


11.98
log
@Mods to f_sc_obj():
	1) no longer applying es_mat to es_keypoint a second time
	2) ignoring movedir - if edobj isn't one of
	   the recognized scale types, use overall scale
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.97 2000/06/05 21:55:54 bparker Exp $ (BRL)";
d1090 1
a1090 1
					rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */
d1117 1
a1117 1
					rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */
d1125 1
a1125 1
					rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */
d1215 1
a1215 1
			rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */
@


11.98.2.1
log
@make command now correctly distiguishes between "ell" and "ell1"
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.98 2000/06/08 21:38:42 bparker Exp $ (BRL)";
d1500 1
a1500 1
	    Tcl_AppendElement(interp, "ell1");
d1683 1
a1683 1
	} else if( strcmp( argv[2], "ell1" ) == 0 )  {
d1693 1
a1693 1
	} else if( strcmp( argv[2], "ell" ) == 0 )  {
@


11.98.2.2
log
@Mods that check if dbip==DBI_NULL
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.98.2.1 2001/01/29 20:31:41 jra Exp $ (BRL)";
a2670 3

  if (dbip == DBI_NULL)
	  return;
@


11.97
log
@*- mods to f_tr_obj and mged_rot_obj
   to not apply es_mat to the keypoint again
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.96 2000/03/31 18:09:46 bparker Exp $ (BRL)";
d2198 1
d2205 1
d2211 4
a2214 4

		case BE_O_SCALE:
			/* global scaling */
			incr[15] = 1.0 / (atof(argv[1]) * modelchanges[15]);
d2216 4
a2219 5

		case BE_O_XSCALE:
			/* local scaling ... X-axis */
			incr[0] = atof(argv[1]) / acc_sc[0];
			acc_sc[0] = atof(argv[1]);
d2221 4
a2224 5

		case BE_O_YSCALE:
			/* local scaling ... Y-axis */
			incr[5] = atof(argv[1]) / acc_sc[1];
			acc_sc[1] = atof(argv[1]);
d2226 4
a2229 5

		case BE_O_ZSCALE:
			/* local scaling ... Z-axis */
			incr[10] = atof(argv[1]) / acc_sc[2];
			acc_sc[2] = atof(argv[1]);
a2230 1

d2234 1
d2236 3
@


11.96
log
@*- fixed bug in f_title that
   disallowed returning the title in
   read-only mode
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.95 2000/03/16 13:39:28 jra Exp $ (BRL)";
d2068 1
d2070 3
d2290 1
d2292 3
@


11.95
log
@Sketch solid can only have one curve now
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.94 2000/01/31 14:37:32 jra Exp $ (BRL)";
a1413 1
	CHECK_READ_ONLY;
d1425 1
a1425 1
	if( argc < 2 )  {
d1429 2
@


11.94
log
@Extrusion/Sketch support in "make" command
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.93 2000/01/07 04:21:19 mike Exp $ (BRL)";
a1927 1
		strcpy( extrude_ip->curve_name, "curve0" );
d1962 3
a1964 6
		sketch_ip->curve_count = 1;
		sketch_ip->curves = (struct curve *)bu_calloc( sketch_ip->curve_count, sizeof( struct curve ), "sketch_ip->curves" );
		strcpy( sketch_ip->curves[0].crv_name, "curve0" );
		sketch_ip->curves[0].seg_count = 6;
		sketch_ip->curves[0].reverse = (int *)bu_calloc( sketch_ip->curves[0].seg_count, sizeof( int ), "sketch_ip->curves[0].reverse" );
		sketch_ip->curves[0].segments = (genptr_t *)bu_calloc( sketch_ip->curves[0].seg_count, sizeof( genptr_t ), "sketch_ip->curves[0].segments" );
d1967 1
a1967 1
		sketch_ip->curves[0].segments[0] = (genptr_t)csg;
a1973 2
		csg->curve_count = 1;
		csg->curves = &sketch_ip->curves;
d1976 1
a1976 1
		sketch_ip->curves[0].segments[1] = (genptr_t)lsg;
a1979 2
		lsg->curve_count = 1;
		lsg->curves = &sketch_ip->curves;
d1982 1
a1982 1
		sketch_ip->curves[0].segments[2] = (genptr_t)lsg;
a1985 2
		lsg->curve_count = 1;
		lsg->curves = &sketch_ip->curves;
d1988 1
a1988 1
		sketch_ip->curves[0].segments[3] = (genptr_t)lsg;
a1991 2
		lsg->curve_count = 1;
		lsg->curves = &sketch_ip->curves;
d1994 1
a1994 1
		sketch_ip->curves[0].segments[4] = (genptr_t)lsg;
a1997 2
		lsg->curve_count = 1;
		lsg->curves = &sketch_ip->curves;
d2000 1
a2000 1
		sketch_ip->curves[0].segments[5] = (genptr_t)csg;
a2006 2
		csg->curve_count = 1;
		csg->curves = &sketch_ip->curves;
@


11.93
log
@
Eliminated dbi_localunit.  This is a v4 database anachronism.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.92 2000/01/07 02:26:11 mike Exp $ (BRL)";
a1515 1
#if 1
a1517 1
#endif
d1918 1
a1920 1
		VSET( extrude_ip->h, 0.0, 0.0, view_state->vs_Viewscale );
d1937 1
a1943 1
		VSET( sketch_ip->V, -view_state->vs_toViewcenter[MDX] , -view_state->vs_toViewcenter[MDY] , -view_state->vs_toViewcenter[MDZ]-view_state->vs_Viewscale*0.5 );
d1946 2
a1947 2
#if 1
		sketch_ip->vert_count = 5;
d1949 14
a1962 10
		sketch_ip->verts[0][0] = -view_state->vs_Viewscale;
		sketch_ip->verts[0][1] = -view_state->vs_Viewscale*0.8;
		sketch_ip->verts[1][0] = -view_state->vs_Viewscale*0.8;
		sketch_ip->verts[1][1] = -view_state->vs_Viewscale;
		sketch_ip->verts[2][0] = view_state->vs_Viewscale;
		sketch_ip->verts[2][1] = -view_state->vs_Viewscale;
		sketch_ip->verts[3][0] = -view_state->vs_Viewscale*0.5;
		sketch_ip->verts[3][1] = -view_state->vs_Viewscale*0.5;
		sketch_ip->verts[4][0] = -view_state->vs_Viewscale;
		sketch_ip->verts[4][1] = view_state->vs_Viewscale;
d1966 1
a1966 1
		sketch_ip->curves[0].seg_count = 2;
d1973 4
a1976 3
		csg->start = 0;
		csg->end = 1;
		csg->radius = view_state->vs_Viewscale * 0.2;
a1977 1
		csg->center_is_left = 1;
d1979 1
a1979 1
		csg->curves = &sketch_ip->curves; 
d1981 31
a2011 36
		nsg = (struct nurb_seg *)bu_calloc( 1, sizeof( struct nurb_seg ), "segments" );
		sketch_ip->curves[0].segments[1] = (genptr_t)nsg;
		nsg->magic = CURVE_NURB_MAGIC;
		nsg->order = 3;
		nsg->pt_type = RT_NURB_MAKE_PT_TYPE( 2, 1, 0 );
		nsg->c_size = 5;
		nsg->ctl_points = (int *)bu_malloc( nsg->c_size * sizeof( int ), "ctl_points" );
		nsg->ctl_points[0] = 1;
		nsg->ctl_points[1] = 2;
		nsg->ctl_points[2] = 3;
		nsg->ctl_points[3] = 4;
		nsg->ctl_points[4] = 0;
		nsg->weights = (fastf_t *)NULL;
		nsg->k.k_size = nsg->order + nsg->c_size;
		nsg->k.knots = bu_malloc( nsg->k.k_size*sizeof( fastf_t ), "knots" );
		for( i=0 ; i<nsg->order ; i++ )
			nsg->k.knots[i] = 0.0;
		for( i=nsg->order ; i<=nsg->c_size ; i++ )
			nsg->k.knots[i] = nsg->k.knots[i-1] + 1.0;
		for( i=nsg->c_size+1 ; i<nsg->order + nsg->c_size ; i++ )
			nsg->k.knots[i] = nsg->k.knots[i-1];
		nsg->curve_count = 1;
		nsg->curves = &sketch_ip->curves;
#else
		sketch_ip->vert_count = 2;
		sketch_ip->verts = (point2d_t *)bu_calloc( sketch_ip->vert_count, sizeof( point2d_t ), "sketch_ip->verts" );
		sketch_ip->verts[0][0] = 0.0;
		sketch_ip->verts[0][1] = 0.0;
		sketch_ip->verts[1][0] = view_state->vs_Viewscale*0.5;
		sketch_ip->verts[1][1] = 0.0;
		sketch_ip->curve_count = 1;
		sketch_ip->curves = (struct curve *)bu_calloc( sketch_ip->curve_count, sizeof( struct curve ), "sketch_ip->curves" );
		strcpy( sketch_ip->curves[0].crv_name, "curve0" );
		sketch_ip->curves[0].seg_count = 1;
		sketch_ip->curves[0].reverse = (int *)bu_calloc( sketch_ip->curves[0].seg_count, sizeof( int ), "sketch_ip->curves[0].reverse" );
		sketch_ip->curves[0].segments = (genptr_t *)bu_calloc( sketch_ip->curves[0].seg_count, sizeof( genptr_t ), "sketch_ip->curves[0].segments" );
d2014 1
a2014 1
		sketch_ip->curves[0].segments[0] = (genptr_t)csg;
d2016 2
a2017 2
		csg->start = 1;
		csg->end = 0;
d2019 1
a2022 1
#endif
@


11.92
log
@
Improved handling of units command so that
"units 3ft" is correctly recognized as editing in yards.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.91 2000/01/06 22:38:59 mike Exp $ (BRL)";
a1363 1

d1366 1
a1366 3
		/* change to the new local unit */
		db_conversions( dbip, new_unit );

a1376 3
		dbip->dbi_localunit = ID_MM_UNIT;
		dbip->dbi_local2base = loc2mm;
		dbip->dbi_base2local = 1.0 / loc2mm;
d1381 2
d1411 1
d1434 2
a1435 1
	if( db_ident( dbip, bu_vls_addr(&title), dbip->dbi_localunit ) < 0 ) {
d2678 1
d2683 5
a2687 30
  switch(localunit){
  case ID_UM_UNIT:
    bu_vls_strcpy(&units_vls, "um");
    break;
  case ID_MM_UNIT:
    bu_vls_strcpy(&units_vls, "mm");
    break;
  case ID_CM_UNIT:
    bu_vls_strcpy(&units_vls, "cm");
    break;
  case ID_M_UNIT:
    bu_vls_strcpy(&units_vls, "m");
    break;
  case ID_KM_UNIT:
    bu_vls_strcpy(&units_vls, "km");
    break;
  case ID_IN_UNIT:
    bu_vls_strcpy(&units_vls, "in");
    break;
  case ID_FT_UNIT:
    bu_vls_strcpy(&units_vls, "ft");
    break;
  case ID_YD_UNIT:
    bu_vls_strcpy(&units_vls, "yd");
    break;
  case ID_NO_UNIT:
  default:
    bu_vls_strcpy(&units_vls, "none");
    break;
  }
@


11.91
log
@
Modified to use new routine db_v4_get_units_code()
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.90 1999/12/30 19:28:30 jra Exp $ (BRL)";
d1341 1
d1346 1
a1346 1
	    bu_vls_printf(&vls, "You are currently editing in '%s'.  1 %s = %g mm \n",
d1355 11
a1365 1
	if( (new_unit = db_v4_get_units_code(argv[1])) >= 0 ) {
d1373 2
a1374 3
				   "Warning: unable to stash working units into database\n",
				   (char *)NULL);

d1376 8
a1383 14
		/* Allows inputs of the form "25cm" */
		if( (loc2mm = bu_mm_value(argv[1]) ) <= 0 )  {
			  Tcl_AppendResult(interp, argv[1], ": unrecognized unit\n",
				   "valid units: <um|mm|cm|m|km|in|ft|yd|mi>\n", (char *)NULL);
			return TCL_ERROR;
		} else {
			/*
			 *  Can't stash requested units into the database for next session,
			 *  but there is no problem with the user editing in these units.
			 */
			dbip->dbi_localunit = ID_MM_UNIT;
			dbip->dbi_local2base = loc2mm;
			dbip->dbi_base2local = 1.0 / loc2mm;
			Tcl_AppendResult(interp, "\
a1385 1
		}
d1393 2
a1394 1
	bu_vls_printf(&vls, "You will now be editing in '%s'.  1 %s = %g mm \n",
@


11.90
log
@Eliminated some unused variables
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.89 1999/12/30 14:24:27 jra Exp $ (BRL)";
a1352 27
	if( strcmp(argv[1], "mm") == 0 || strcmp(argv[1], "millimeters") == 0 ) 
		new_unit = ID_MM_UNIT;
	else
	if( strcmp(argv[1], "um") == 0 || strcmp(argv[1], "micrometers") == 0) 
		new_unit = ID_UM_UNIT;
	else
	if( strcmp(argv[1], "cm") == 0 || strcmp(argv[1], "centimeters") == 0) 
		new_unit = ID_CM_UNIT;
	else
	if( strcmp(argv[1],"m")==0 || strcmp(argv[1],"meters")==0 ) 
		new_unit = ID_M_UNIT;
	else
	if( strcmp(argv[1], "km") == 0 || strcmp(argv[1], "kilometers") == 0) 
		new_unit = ID_KM_UNIT;
	else
	if( strcmp(argv[1],"in")==0 || strcmp(argv[1],"inches")==0 || strcmp(argv[1],"inch")==0 ) 
		new_unit = ID_IN_UNIT;
	else
	if( strcmp(argv[1],"ft")==0 || strcmp(argv[1],"feet")==0 || strcmp(argv[1],"foot")==0 ) 
		new_unit = ID_FT_UNIT;
	else
	if( strcmp(argv[1],"yd")==0 || strcmp(argv[1],"yards")==0 || strcmp(argv[1],"yard")==0 ) 
		new_unit = ID_YD_UNIT;
	else
	if( strcmp(argv[1],"mi")==0 || strcmp(argv[1],"miles")==0 || strcmp(argv[1],"mile")==0 ) 
		new_unit = ID_MI_UNIT;

d1354 1
a1354 1
	if( new_unit ) {
a1364 4
	} else if( (loc2mm = bu_units_conversion(argv[1]) ) <= 0 )  {
	  Tcl_AppendResult(interp, argv[1], ": unrecognized unit\n",
			   "valid units: <um|mm|cm|m|km|in|ft|yd|mi>\n", (char *)NULL);
	  return TCL_ERROR;
d1366 14
a1379 8
		/*
		 *  Can't stash requested units into the database for next session,
		 *  but there is no problem with the user editing in these units.
		 */
		dbip->dbi_localunit = ID_MM_UNIT;
		dbip->dbi_local2base = loc2mm;
		dbip->dbi_base2local = 1.0 / loc2mm;
		Tcl_AppendResult(interp, "\
d1382 1
@


11.89
log
@make sketch now makes a  more complex sketch
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.88 1999/12/29 23:23:17 mike Exp $ (BRL)";
a667 1
	struct bu_vls		args;
a1078 1
				struct face_g_plane *fg;
a1104 1
				struct face_g_plane *fg;
a1958 1
		struct line_seg *lsg;
a2165 2
  mat_t temp;
  vect_t s_point, point, v_work, model_pt;
@


11.88
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.87 1999/12/28 19:43:11 bparker Exp $ (BRL)";
d1949 6
a1954 1
		strcpy( extrude_ip->sketch_name, "sketch_test" );
d1958 1
a1958 1
		av[1] = "sketch_test";
d1963 2
d1974 2
a1975 1
		sketch_ip->vert_count = 4;
d1978 2
a1979 2
		sketch_ip->verts[0][1] = -view_state->vs_Viewscale;
		sketch_ip->verts[1][0] = view_state->vs_Viewscale;
d1981 54
a2034 4
		sketch_ip->verts[2][0] = -view_state->vs_Viewscale*0.5;
		sketch_ip->verts[2][1] = -view_state->vs_Viewscale*0.5;
		sketch_ip->verts[3][0] = -view_state->vs_Viewscale;
		sketch_ip->verts[3][1] = view_state->vs_Viewscale;
d2038 1
a2038 1
		sketch_ip->curves[0].seg_count = 4;
d2042 10
a2051 31
		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->curves[0].segments[0] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 0;
		lsg->end = 1;
		lsg->curve_count = 1;
		lsg->curves = &sketch_ip->curves;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->curves[0].segments[1] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 1;
		lsg->end = 2;
		lsg->curve_count = 1;
		lsg->curves = &sketch_ip->curves;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->curves[0].segments[2] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 2;
		lsg->end = 3;
		lsg->curve_count = 1;
		lsg->curves = &sketch_ip->curves;

		lsg = (struct line_seg *)bu_calloc( 1, sizeof( struct line_seg ), "segments" );
		sketch_ip->curves[0].segments[3] = (genptr_t)lsg;
		lsg->magic = CURVE_LSEG_MAGIC;
		lsg->start = 3;
		lsg->end = 0;
		lsg->curve_count = 1;
		lsg->curves = &sketch_ip->curves;
@


11.87
log
@*- mktemp requires six X's in the template; the template must also
   be declared as an array of char's
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.86 1999/12/15 15:29:05 jra Exp $ (BRL)";
d1227 1
a1227 1
	if( (dp = db_diradd( dbip, argv[2], -1L, 0, proto->d_flags)) == DIR_NULL )  {
d2036 1
a2036 1
	if( (dp = db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID)) == DIR_NULL )  {
d2386 1
a2386 1
	if( (new_dp=db_diradd( dbip, newname, -1, 0, DIR_SOLID)) == DIR_NULL )  {
@


11.86
log
@Added "bot" to the "make" command
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.85 1999/11/26 23:03:29 mike Exp $ (BRL)";
d71 3
a341 1
  char *tmpfil = "/tmp/GED.aXXXXX";
d358 1
@


11.85
log
@
Lint
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.84 1999/11/24 14:26:41 jra Exp $ (BRL)";
d1507 1
d1518 1
d1538 1
a1538 1
#if 0
d1574 1
a1574 1
	 * sph | tor | tgc | rec | trc | rcc | grp | half | nmg | sketch | extrude> */
d1910 23
d2024 1
a2024 1
			   "\tchoices are: arb8, arb7, arb6, arb5, arb4, sph, ell, ellg, grip, tor,\n",
@


11.84
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.83 1999/10/18 12:49:45 jra Exp $ (BRL)";
d133 1
a133 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d188 1
a188 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d434 1
a434 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d506 1
a506 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d624 1
a624 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d686 1
a686 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d1281 1
a1281 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
@


11.83
log
@f_edcomb() was always returning TCL_ERROR.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.82 1999/09/01 18:55:09 bparker Exp $ (BRL)";
d1575 1
d1596 1
d1617 1
d1641 1
d1663 1
d1685 1
d1696 1
d1706 1
d1716 1
d1726 1
d1739 1
d1751 1
d1763 1
d1775 1
d1787 1
d1799 1
d1807 1
d1817 1
d1828 1
d1839 1
d1851 1
d1862 1
d1883 1
d1889 1
d1912 1
d1932 1
d2371 1
@


11.82
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.81 1999/07/23 20:59:15 jra Exp $ (BRL)";
d1298 1
a1298 1
	return TCL_ERROR;
@


11.81
log
@Reordered (alphabetically) the response that 'make -t' supplies
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.80 1999/07/02 22:18:38 mike Exp $ (BRL)";
d88 1
a88 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d168 1
a168 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d343 1
a343 3
  if(dbip == DBI_NULL)
    return TCL_OK;

d406 1
a406 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d477 1
a477 3
  if(dbip == DBI_NULL)
    return TCL_OK;

d604 1
a604 3
    if(dbip == DBI_NULL)
      return TCL_OK;

d667 1
a667 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
a678 1

d731 1
a731 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1256 1
a1256 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1322 1
a1322 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1436 1
a1436 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1551 1
a1551 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d2082 1
a2082 3
  if(dbip == DBI_NULL)
    return TCL_OK;

d2126 1
a2126 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d2212 1
a2212 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d2386 1
a2386 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d2547 1
a2547 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

@


11.80
log
@
Removed dependence on compat4.h
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.79 1999/05/15 08:04:31 mike Exp $ (BRL)";
d1537 1
a1537 2
	    Tcl_AppendElement(interp, "sph");
	    Tcl_AppendElement(interp, "grip");
a1539 9
	    Tcl_AppendElement(interp, "tor");
	    Tcl_AppendElement(interp, "tgc");
	    Tcl_AppendElement(interp, "tec");
	    Tcl_AppendElement(interp, "rec");
	    Tcl_AppendElement(interp, "trc");
	    Tcl_AppendElement(interp, "rcc");
	    Tcl_AppendElement(interp, "half");
	    Tcl_AppendElement(interp, "rpc");
	    Tcl_AppendElement(interp, "rhc");
a1540 1
	    Tcl_AppendElement(interp, "ehy");
d1542 3
a1545 1
	    Tcl_AppendElement(interp, "nmg");
d1547 9
@


11.79
log
@Allow change of units even if database is read-only.
Have "center" command echo back current setting, so it can be used
in Tcl scripts.  Have "center" command without args print current center
in current units, also for use in Tcl scripts.
Have "overlay" command echo back list of phantom-solids created,
for use in Tcl scripts.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.78 1999/04/23 17:51:45 bparker Exp $ (BRL)";
d1358 1
a1358 1
	  str = rt_units_string(dbip->dbi_local2base);
d1431 1
a1431 1
	str = rt_units_string(dbip->dbi_local2base);
@


11.78
log
@*- mods to regdef
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.77 1999/04/19 19:24:09 jra Exp $ (BRL)";
a1341 2
	CHECK_READ_ONLY;

d1404 2
a1405 1
		if( db_ident( dbip, dbip->dbi_title, new_unit ) < 0 )
@


11.77
log
@ifdef'd out the extrusion and sketch from "make -t".
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.76 1999/02/24 01:01:47 jra Exp $ (BRL)";
d2294 12
d2313 1
@


11.76
log
@mater command is back to using keyword=value form for shaders
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.75 1999/01/21 18:25:25 bparker Exp $ (BRL)";
d1557 1
d1560 1
@


11.75
log
@*- always allow f_make to return solid types
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.74 1999/01/12 18:23:15 bparker Exp $ (BRL)";
d201 6
a206 1
	  	bu_vls_strcpy( &comb->shader, argv[2] );
d212 12
d225 1
a225 1
	  Tcl_AppendResult(interp, "Shader = ", bu_vls_addr(&comb->shader),
d232 3
a234 1
	    bu_vls_printf(&curr_cmd_list->cl_more_default, "\"%S\"", &comb->shader);
@


11.74
log
@*- mods to f_make
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.73 1999/01/06 16:39:50 bparker Exp $ (BRL)";
a1509 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1550 3
@


11.73
log
@*- allow "make -t" to return a list of
   the acceptable solid types even if the
   database is read-only.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.72 1998/12/30 08:30:23 mike Exp $ (BRL)";
d1556 1
a1556 1
	if(argc < 2 || 3 < argc){
@


11.72
log
@Port to SunOS 4.1.4 -- missing pointer cast.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.71 1998/11/06 22:15:58 bparker Exp $ (BRL)";
a1512 12
	CHECK_READ_ONLY;

	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help make");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

d1546 12
@


11.71
log
@*- use new structures
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.70 1998/06/25 07:37:24 mike Exp $ (BRL)";
d1933 1
a1933 1
		sketch_ip->curves[0].segments[0] = lsg;
d1941 1
a1941 1
		sketch_ip->curves[0].segments[1] = lsg;
d1949 1
a1949 1
		sketch_ip->curves[0].segments[2] = lsg;
d1957 1
a1957 1
		sketch_ip->curves[0].segments[3] = lsg;
@


11.70
log
@Port to sun4.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgmodel.c,v 11.69 1998/06/11 19:41:38 bparker Exp $ (BRL)";
d207 1
a207 1
	  curr_cmd_list->quote_string = 1;
d213 1
a213 1
	    bu_vls_printf(&curr_cmd_list->more_default, "del");
d215 1
a215 1
	    bu_vls_printf(&curr_cmd_list->more_default, "\"%S\"", &comb->shader);
d248 1
a248 1
	    bu_vls_printf(&curr_cmd_list->more_default, "%d %d %d",
d254 1
a254 1
	    bu_vls_printf(&curr_cmd_list->more_default, "del");
d281 1
a281 1
	    bu_vls_printf(&curr_cmd_list->more_default, "1");
d284 1
a284 1
	    bu_vls_printf(&curr_cmd_list->more_default, "0");
d1465 1
a1465 1
	dmaflag = 1;
d1581 3
a1583 3
			-toViewcenter[MDX] +Viewscale,
			-toViewcenter[MDY] -Viewscale,
			-toViewcenter[MDZ] -Viewscale );
d1585 4
a1588 4
		arb_ip->pt[1][Y] += Viewscale*2.0;
		arb_ip->pt[2][Y] += Viewscale*2.0;
		arb_ip->pt[2][Z] += Viewscale*2.0;
		arb_ip->pt[3][Z] += Viewscale*2.0;
d1590 5
a1594 5
			arb_ip->pt[i][X] -= Viewscale*2.0;
		arb_ip->pt[5][Y] += Viewscale*2.0;
		arb_ip->pt[6][Y] += Viewscale*2.0;
		arb_ip->pt[6][Z] += Viewscale*2.0;
		arb_ip->pt[7][Z] += Viewscale*2.0;
d1601 3
a1603 3
			-toViewcenter[MDX] +Viewscale,
			-toViewcenter[MDY] -Viewscale,
			-toViewcenter[MDZ] -(0.5*Viewscale) );
d1606 4
a1609 4
		arb_ip->pt[1][Y] += Viewscale*2.0;
		arb_ip->pt[2][Y] += Viewscale*2.0;
		arb_ip->pt[2][Z] += Viewscale*2.0;
		arb_ip->pt[3][Z] += Viewscale;
d1611 4
a1614 4
			arb_ip->pt[i][X] -= Viewscale*2.0;
		arb_ip->pt[5][Y] += Viewscale*2.0;
		arb_ip->pt[6][Y] += Viewscale*2.0;
		arb_ip->pt[6][Z] += Viewscale;
d1621 3
a1623 3
			-toViewcenter[MDX] +Viewscale,
			-toViewcenter[MDY] -Viewscale,
			-toViewcenter[MDZ] -Viewscale );
d1626 4
a1629 4
		arb_ip->pt[1][Y] += Viewscale*2.0;
		arb_ip->pt[2][Y] += Viewscale*2.0;
		arb_ip->pt[2][Z] += Viewscale*2.0;
		arb_ip->pt[3][Z] += Viewscale*2.0;
d1631 7
a1637 7
			arb_ip->pt[i][X] -= Viewscale*2.0;
		arb_ip->pt[4][Y] += Viewscale;
		arb_ip->pt[5][Y] += Viewscale;
		arb_ip->pt[6][Y] += Viewscale;
		arb_ip->pt[6][Z] += Viewscale*2.0;
		arb_ip->pt[7][Y] += Viewscale;
		arb_ip->pt[7][Z] += Viewscale*2.0;
d1644 3
a1646 3
			-toViewcenter[MDX] +Viewscale,
			-toViewcenter[MDY] -Viewscale,
			-toViewcenter[MDZ] -Viewscale );
d1649 4
a1652 4
		arb_ip->pt[1][Y] += Viewscale*2.0;
		arb_ip->pt[2][Y] += Viewscale*2.0;
		arb_ip->pt[2][Z] += Viewscale*2.0;
		arb_ip->pt[3][Z] += Viewscale*2.0;
d1655 3
a1657 3
			arb_ip->pt[i][X] -= Viewscale*2.0;
			arb_ip->pt[i][Y] += Viewscale;
			arb_ip->pt[i][Z] += Viewscale;
d1665 3
a1667 3
			-toViewcenter[MDX] +Viewscale,
			-toViewcenter[MDY] -Viewscale,
			-toViewcenter[MDZ] -Viewscale );
d1670 5
a1674 5
		arb_ip->pt[1][Y] += Viewscale*2.0;
		arb_ip->pt[2][Y] += Viewscale*2.0;
		arb_ip->pt[2][Z] += Viewscale*2.0;
		arb_ip->pt[3][Y] += Viewscale*2.0;
		arb_ip->pt[3][Z] += Viewscale*2.0;
d1677 2
a1678 2
			arb_ip->pt[i][X] -= Viewscale*2.0;
			arb_ip->pt[i][Y] += Viewscale*2.0;
d1685 4
a1688 4
		VSET( ell_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ] );
		VSET( ell_ip->a, (0.5*Viewscale), 0.0, 0.0 );	/* A */
		VSET( ell_ip->b, 0.0, (0.5*Viewscale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.5*Viewscale) );	/* C */
d1695 2
a1696 2
		VSET( grp_ip->center, -toViewcenter[MDX], -toViewcenter[MDY],
		    -toViewcenter[MDZ]);
d1698 1
a1698 1
		grp_ip->mag = Viewscale*0.75;
d1704 4
a1707 4
		VSET( ell_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ] );
		VSET( ell_ip->a, (0.5*Viewscale), 0.0, 0.0 );	/* A */
		VSET( ell_ip->b, 0.0, (0.25*Viewscale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.25*Viewscale) );	/* C */
d1713 4
a1716 4
		VSET( ell_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ] );
		VSET( ell_ip->a, Viewscale, 0.0, 0.0 );		/* A */
		VSET( ell_ip->b, 0.0, (0.5*Viewscale), 0.0 );	/* B */
		VSET( ell_ip->c, 0.0, 0.0, (0.25*Viewscale) );	/* C */
d1722 1
a1722 1
		VSET( tor_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ] );
d1724 5
a1728 5
		tor_ip->r_h = 0.5*Viewscale;
		tor_ip->r_a = Viewscale;
		tor_ip->r_b = Viewscale;
		VSET( tor_ip->a , 0.0 , Viewscale , 0.0 );
		VSET( tor_ip->b , 0.0 , 0.0 , Viewscale );
d1734 6
a1739 6
		VSET( tgc_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.25*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.5*Viewscale), 0.0 );
d1745 6
a1750 6
		VSET( tgc_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.25*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.125*Viewscale), 0.0 );
d1756 6
a1761 6
		VSET( tgc_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.25*Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.5*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.25*Viewscale), 0.0 );
d1767 6
a1772 6
		VSET( tgc_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.5*Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.25*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.25*Viewscale), 0.0 );
d1778 6
a1783 6
		VSET( tgc_ip->v , -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale );
		VSET( tgc_ip->h,  0.0, 0.0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->b,  0.0, (0.5*Viewscale), 0.0 );
		VSET( tgc_ip->c,  (0.5*Viewscale), 0.0, 0.0 );
		VSET( tgc_ip->d,  0.0, (0.5*Viewscale), 0.0 );
d1790 1
a1790 1
		half_ip->eqn[3] = (-toViewcenter[MDZ]);
d1796 4
a1799 4
		VSET( rpc_ip->rpc_V, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale*0.5 );
		VSET( rpc_ip->rpc_H, 0.0, 0.0, Viewscale );
		VSET( rpc_ip->rpc_B, 0.0, (Viewscale*0.5), 0.0 );
		rpc_ip->rpc_r = Viewscale*0.25;
d1805 5
a1809 5
		VSET( rhc_ip->rhc_V, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale*0.5 );
		VSET( rhc_ip->rhc_H, 0.0, 0.0, Viewscale );
		VSET( rhc_ip->rhc_B, 0.0, (Viewscale*0.5), 0.0 );
		rhc_ip->rhc_r = Viewscale*0.25;
		rhc_ip->rhc_c = Viewscale*0.10;
d1815 2
a1816 2
		VSET( epa_ip->epa_V, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale*0.5 );
		VSET( epa_ip->epa_H, 0.0, 0.0, Viewscale );
d1818 2
a1819 2
		epa_ip->epa_r1 = Viewscale*0.5;
		epa_ip->epa_r2 = Viewscale*0.25;
d1825 2
a1826 2
		VSET( ehy_ip->ehy_V, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale*0.5 );
		VSET( ehy_ip->ehy_H, 0.0, 0.0, Viewscale );
d1828 2
a1829 2
		ehy_ip->ehy_r1 = Viewscale*0.5;
		ehy_ip->ehy_r2 = Viewscale*0.25;
d1836 1
a1836 1
		VSET( eto_ip->eto_V, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ] );
d1838 3
a1840 3
		VSET( eto_ip->eto_C, Viewscale*0.1, 0.0, Viewscale*0.1 );
		eto_ip->eto_r = Viewscale*0.5;
		eto_ip->eto_rd = Viewscale*0.05;
d1846 4
a1849 4
		VSET( part_ip->part_V, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale*0.5 );
		VSET( part_ip->part_H, 0.0, 0.0, Viewscale );
		part_ip->part_vrad = Viewscale*0.5;
		part_ip->part_hrad = Viewscale*0.25;
d1859 1
a1859 1
		nmg_vertex_g( s->vu_p->v_p, -toViewcenter[MDX], -toViewcenter[MDY], -toViewcenter[MDZ]);
d1874 2
a1875 2
		VSET( ps->pp_coord, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale );
		ps->pp_od = 0.5*Viewscale;
d1881 2
a1882 2
		VSET( ps->pp_coord, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]+Viewscale );
		ps->pp_od = 0.5*Viewscale;
d1893 1
a1893 1
		VSET( extrude_ip->V, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale*0.5 );
d1896 1
a1896 1
		VSET( extrude_ip->h, 0.0, 0.0, Viewscale );
d1912 1
a1912 1
		VSET( sketch_ip->V, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale*0.5 );
d1917 8
a1924 8
		sketch_ip->verts[0][0] = -Viewscale;
		sketch_ip->verts[0][1] = -Viewscale;
		sketch_ip->verts[1][0] = Viewscale;
		sketch_ip->verts[1][1] = -Viewscale;
		sketch_ip->verts[2][0] = -Viewscale*0.5;
		sketch_ip->verts[2][1] = -Viewscale*0.5;
		sketch_ip->verts[3][0] = -Viewscale;
		sketch_ip->verts[3][1] = Viewscale;
d2283 1
a2283 1
  dmaflag = 1;
@


11.69
log
@*- using floating point literals to initialize floats
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/chgmodel.c,v 11.68 1998/05/01 21:16:21 bparker Exp $ (BRL)";
d1932 1
a1932 1
		lsg = bu_calloc( 1, sizeof( struct line_seg ), "segments" );
d1940 1
a1940 1
		lsg = bu_calloc( 1, sizeof( struct line_seg ), "segments" );
d1948 1
a1948 1
		lsg = bu_calloc( 1, sizeof( struct line_seg ), "segments" );
d1956 1
a1956 1
		lsg = bu_calloc( 1, sizeof( struct line_seg ), "segments" );
@


11.68
log
@*- mods to f_make()
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/chgmodel.c,v 11.67 1998/04/23 12:50:37 bparker Exp $ (BRL)";
d1686 3
a1688 3
		VSET( ell_ip->a, (0.5*Viewscale), 0, 0 );	/* A */
		VSET( ell_ip->b, 0, (0.5*Viewscale), 0 );	/* B */
		VSET( ell_ip->c, 0, 0, (0.5*Viewscale) );	/* C */
d1705 3
a1707 3
		VSET( ell_ip->a, (0.5*Viewscale), 0, 0 );	/* A */
		VSET( ell_ip->b, 0, (0.25*Viewscale), 0 );	/* B */
		VSET( ell_ip->c, 0, 0, (0.25*Viewscale) );	/* C */
d1714 3
a1716 3
		VSET( ell_ip->a, Viewscale, 0, 0 );		/* A */
		VSET( ell_ip->b, 0, (0.5*Viewscale), 0 );	/* B */
		VSET( ell_ip->c, 0, 0, (0.25*Viewscale) );	/* C */
d1735 5
a1739 5
		VSET( tgc_ip->h,  0, 0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0, 0 );
		VSET( tgc_ip->b,  0, (0.25*Viewscale), 0 );
		VSET( tgc_ip->c,  (0.25*Viewscale), 0, 0 );
		VSET( tgc_ip->d,  0, (0.5*Viewscale), 0 );
d1746 5
a1750 5
		VSET( tgc_ip->h,  0, 0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0, 0 );
		VSET( tgc_ip->b,  0, (0.25*Viewscale), 0 );
		VSET( tgc_ip->c,  (0.25*Viewscale), 0, 0 );
		VSET( tgc_ip->d,  0, (0.125*Viewscale), 0 );
d1757 5
a1761 5
		VSET( tgc_ip->h,  0, 0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0, 0 );
		VSET( tgc_ip->b,  0, (0.25*Viewscale), 0 );
		VSET( tgc_ip->c,  (0.5*Viewscale), 0, 0 );
		VSET( tgc_ip->d,  0, (0.25*Viewscale), 0 );
d1768 5
a1772 5
		VSET( tgc_ip->h,  0, 0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0, 0 );
		VSET( tgc_ip->b,  0, (0.5*Viewscale), 0 );
		VSET( tgc_ip->c,  (0.25*Viewscale), 0, 0 );
		VSET( tgc_ip->d,  0, (0.25*Viewscale), 0 );
d1779 5
a1783 5
		VSET( tgc_ip->h,  0, 0, (Viewscale*2) );
		VSET( tgc_ip->a,  (0.5*Viewscale), 0, 0 );
		VSET( tgc_ip->b,  0, (0.5*Viewscale), 0 );
		VSET( tgc_ip->c,  (0.5*Viewscale), 0, 0 );
		VSET( tgc_ip->d,  0, (0.5*Viewscale), 0 );
d1789 1
a1789 1
		VSET( half_ip->eqn , 0 , 0 , 1 );
d1797 2
a1798 2
		VSET( rpc_ip->rpc_H, 0, 0, Viewscale );
		VSET( rpc_ip->rpc_B, 0, (Viewscale*0.5), 0 );
d1806 2
a1807 2
		VSET( rhc_ip->rhc_H, 0, 0, Viewscale );
		VSET( rhc_ip->rhc_B, 0, (Viewscale*0.5), 0 );
d1816 2
a1817 2
		VSET( epa_ip->epa_H, 0, 0, Viewscale );
		VSET( epa_ip->epa_Au, 0, 1, 0 );
d1826 2
a1827 2
		VSET( ehy_ip->ehy_H, 0, 0, Viewscale );
		VSET( ehy_ip->ehy_Au, 0, 1, 0 );
d1837 2
a1838 2
		VSET( eto_ip->eto_N, 0, 0, 1 );
		VSET( eto_ip->eto_C, Viewscale*0.1, 0, Viewscale*0.1 );
d1847 1
a1847 1
		VSET( part_ip->part_H, 0, 0, Viewscale );
d1894 3
a1896 3
		VSET( extrude_ip->u_vec, 1, 0, 0 );
		VSET( extrude_ip->v_vec, 0, 1, 0 );
		VSET( extrude_ip->h, 0, 0, Viewscale );
d1913 2
a1914 2
		VSET( sketch_ip->u_vec, 1, 0, 0 );
		VSET( sketch_ip->v_vec, 0, 1, 0 );
@


11.67
log
@add -s option to the units command
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.66 1998/04/10 18:18:41 bparker Exp bparker $ (BRL)";
d1515 1
a1515 1
	if(argc < 3 || 3 < argc){
d1517 41
@


11.66
log
@use extern when declaring update_grids()
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.65 1998/04/07 14:07:59 jra Exp bparker $ (BRL)";
d1318 1
d1333 7
d1342 7
a1348 2
	  bu_vls_printf(&vls, "You are currently editing in '%s'.  1 %s = %g mm \n",
			str, str, dbip->dbi_local2base );
@


11.65
log
@Added "extrude" and "sketch" to "make" command.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.64 1998/03/19 15:04:31 jra Exp jra $ (BRL)";
d66 1
a66 1
void update_grids();
@


11.64
log
@Added "sketch" to f_make()
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.63 1998/02/20 23:08:31 bparker Exp jra $ (BRL)";
d1495 1
d1520 1
a1520 1
	 * sph | tor | tgc | rec | trc | rcc | grp | half | nmg | sketch> */
d1832 19
d1922 1
a1922 1
			   "\t\ttgc, tec, rec, trc, rcc, half, rpc, rhc, epa, ehy, eto, part, sketch\n",
@


11.63
log
@*- added set_localunit_TclVar()
*- mods to f_units()
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.62 1998/01/07 04:17:25 mike Exp bparker $ (BRL)";
d1494 1
d1519 1
a1519 1
	 * sph | tor | tgc | rec | trc | rcc | grp | half | nmg> */
d1831 58
d1902 1
a1902 1
			   "\t\ttgc, tec, rec, trc, rcc, half, rpc, rhc, epa, ehy, eto, part\n",
@


11.62
log
@Modified "shader" command so that it returns current shader if
a new material string isn't given.
Even on a read-only database.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.61 1997/11/03 15:23:30 bparker Exp mike $ (BRL)";
d66 2
a67 1

d1317 1
d1368 1
d1395 5
d1405 1
a1405 1
	dmaflag = 1;
d2473 47
@


11.61
log
@some clean up
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.60 1997/09/08 19:06:38 bparker Exp bparker $ (BRL)";
d661 1
a661 3
	CHECK_READ_ONLY;

	if(argc < 3 || MAXARGS < argc){
d671 1
a683 1
	bu_vls_free( &comb->shader );
d685 17
a701 5
	/* Bunch up the rest of the args, space separated */
	bu_vls_from_argv( &comb->shader, argc-2, argv+2 );

	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
		TCL_WRITE_ERR_return;
@


11.60
log
@remove some old display list stuff
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.59 1997/07/11 14:24:46 jra Exp bparker $ (BRL)";
a1867 5
#if 0
    dmp->dm_light( dmp, LIGHT_ON, BE_O_ROTATE );
    dmp->dm_light( dmp, LIGHT_OFF, BE_O_SCALE );
    dmp->dm_light( dmp, LIGHT_OFF, BE_O_XY );
#endif
a2005 4
#if 0
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_ROTATE );
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_XY );
#endif
a2007 3
#if 0
		dmp->dm_light( dmp, LIGHT_ON, edobj );
#endif
a2091 5
#if 0
		dmp->dm_light( dmp, LIGHT_ON, BE_O_XY );
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_SCALE );
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_ROTATE );
#endif
a2412 5
#if 0
		dmp->dm_light( dmp, LIGHT_ON, BE_O_ROTATE );
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_SCALE );
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_XY );
#endif
@


11.59
log
@fracture command needed to check that its argument was an NMG.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.58 1997/07/01 22:09:08 bparker Exp jra $ (BRL)";
a1213 6
	}

	if( no_memory )  {
	  Tcl_AppendResult(interp, "Mirror image (", argv[2],
			   ") created but NO memory left to draw it\n", (char *)NULL);
	  return TCL_ERROR;
@


11.58
log
@mods to run without a database
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.57 1997/06/03 16:03:59 pjt Exp bparker $ (BRL)";
d2279 7
@


11.57
log
@Added units um, km, yd, mi, and other minor improvements
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.56 1997/05/27 12:36:01 jra Exp $ (BRL)";
d87 3
d169 3
d327 3
d392 3
d464 3
d593 3
d658 3
d714 3
d1247 3
d1313 3
d1411 3
d1483 3
d1944 3
d1990 3
d2085 3
d2188 3
d2253 3
d2408 3
@


11.56
log
@modified f_wmater() to append to file rather then overwriting.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.55 1997/05/22 18:27:51 jra Exp jra $ (BRL)";
d1283 1
d1288 1
a1289 3
	  struct bu_vls vls;

	  bu_vls_init(&vls);
a1296 3
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
d1298 1
a1298 1
	  bu_vls_printf(&tmp_vls, "You are currently editing in '%s'.  1%s = %gmm \n",
d1300 2
a1301 2
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
d1308 3
d1317 3
d1325 6
d1344 1
a1344 1
			   "valid units: <mm|cm|m|in|ft|meters|inches|feet>\n", (char *)NULL);
d1358 5
a1362 2
	Tcl_AppendResult(interp, "New editing units = '", rt_units_string(dbip->dbi_local2base),
			 "'\n", (char *)NULL);
@


11.55
log
@Added different forms of inch, foot, ... for legal units.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.54 1997/05/22 09:29:07 butler Exp jra $ (BRL)";
d393 1
a393 1
  if((fp = fopen(argv[1], "w")) == NULL){
@


11.54
log
@added support for dsp solid
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.53 1997/04/24 18:03:58 bparker Exp butler $ (BRL)";
d1309 1
a1309 1
	if( strcmp(argv[1], "mm") == 0 ) 
d1312 1
a1312 1
	if( strcmp(argv[1], "cm") == 0 ) 
d1318 1
a1318 1
	if( strcmp(argv[1],"in")==0 || strcmp(argv[1],"inches")==0 ) 
d1321 1
a1321 1
	if( strcmp(argv[1],"ft")==0 || strcmp(argv[1],"feet")==0 ) 
@


11.53
log
@modify calls to Tcl_Eval
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.52 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d1139 12
d1774 1
@


11.52
log
@mods so that commands check args internally
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.51 1997/03/28 17:46:51 pjt Exp bparker $ (BRL)";
d90 6
a95 1
	  Tcl_Eval(interp, "help item");
d169 6
a174 1
	  Tcl_Eval(interp, "help mater");
d324 6
a329 1
    Tcl_Eval(interp, "help edmater");
d384 6
a389 1
    Tcl_Eval(interp, "help wmater");
d455 6
a460 1
    Tcl_Eval(interp, "help rmater");
d581 6
a586 1
      Tcl_Eval(interp, "help comb_color");
d643 6
a648 1
	  Tcl_Eval(interp, "help shader");
d696 6
a701 1
	  Tcl_Eval(interp, "help mirror");
d1214 6
a1219 1
	  Tcl_Eval(interp, "help edcomb");
d1276 6
a1281 1
	  Tcl_Eval(interp, "help units");
d1322 1
a1322 1
	} else if( (loc2mm = rt_units_conversion(argv[1]) ) <= 0 )  {
d1361 6
a1366 1
	  Tcl_Eval(interp, "help title");
d1430 6
a1435 1
	  Tcl_Eval(interp, "help make");
d1930 6
a1935 1
	  Tcl_Eval(interp, "help oscale");
d2022 6
a2027 1
	  Tcl_Eval(interp, "help translate");
d2077 6
a2082 1
    Tcl_Eval(interp, "help regdef");
d2184 6
a2189 1
	  Tcl_Eval(interp, "help fracture");
d2337 6
a2342 1
	  Tcl_Eval(interp, "help qorot");
@


11.51
log
@Enhanced item command to support setting GIFTmater and los, too
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.50 1997/03/25 14:43:44 jra Exp $ (BRL)";
d89 2
a90 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d92 1
d163 2
a164 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d166 1
d311 1
a311 1
	CHECK_READ_ONLY;
d313 2
a314 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d316 1
d365 2
a366 2
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
d368 2
a369 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d371 1
d423 2
a424 2
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
d432 1
a432 1
	CHECK_READ_ONLY;
d434 2
a435 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d437 1
d550 2
a551 2
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
d553 1
a553 1
	CHECK_READ_ONLY;
d555 2
a556 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d558 1
d612 2
a613 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d615 1
d660 2
a661 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d663 1
d1173 2
a1174 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1176 1
d1230 2
a1231 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1233 1
d1310 2
a1311 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1313 1
d1374 2
a1375 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1377 1
d1824 4
a1827 1
	CHECK_READ_ONLY;
d1829 4
a1832 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1834 1
d1869 2
a1870 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1872 1
d1956 2
a1957 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1959 1
d2006 2
a2007 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2009 1
d2108 2
a2109 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2111 1
d2256 2
a2257 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2259 1
@


11.50
log
@Mods to support MGED's read-only mode.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.49 1997/03/24 13:11:35 pjt Exp jra $ (BRL)";
d82 2
a83 1
	int ident, air;
d104 1
d107 6
a112 2
	/* If <air> is not included, it is assumed to be zero */
	if( argc == 4 )  {
d115 8
d131 6
@


11.49
log
@qorot now interprets the point in local rather than base (i.e. mm) units
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.48 1997/03/12 20:45:46 jra Exp $ (BRL)";
d86 2
d139 2
d287 2
d404 2
d523 2
d578 2
d624 2
d1135 2
d1190 2
d1268 2
d1330 2
d1780 2
d1816 2
d1901 2
d2049 2
d2194 2
@


11.48
log
@removed dependencies on db.h.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.47 1997/03/06 21:42:59 bparker Exp jra $ (BRL)";
d2181 1
@


11.47
log
@call new_edit_mats instead of new_mats
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.46 1997/01/31 21:51:07 bparker Exp bparker $ (BRL)";
a53 1
#include "db.h"			/* Needed for ID_MM_UNIT only */
@


11.46
log
@mod to f_mater --- put double quotes around
the shader parameters to prevent tcl from dicing it up
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.45 1997/01/30 04:39:15 mike Exp $ (BRL)";
d1736 3
d1740 1
d1855 3
d1859 1
d1906 3
d1910 1
d2213 3
d2217 1
@


11.45
log
@Converted over to new combination import/export routines
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.44 1997/01/30 02:57:32 mike Exp mike $ (BRL)";
d171 1
a171 1
	    bu_vls_vlscat(&curr_cmd_list->more_default, &comb->shader);
@


11.44
log
@Clenaed up.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.43 1997/01/30 02:48:26 mike Exp mike $ (BRL)";
d54 1
a54 1
#include "db.h"
d334 2
a335 1
  union record record;
d356 7
d364 6
a369 11
    if( db_get( dbip, dp, &record, 0 , 1) < 0 ){
      TCL_READ_ERR;
      status = TCL_ERROR;
      continue;
    }

    fprintf(fp, "\"%s\"\t\"%s\"\t\"%s\"\t%d\t%d\t%d\t%d\t%d\n", argv[i],
	    record.c.c_matname[0] ? record.c.c_matname : "-",
	    record.c.c_matparm[0] ? record.c.c_matparm : "-",
	    (int)record.c.c_rgb[0], (int)record.c.c_rgb[1], (int)record.c.c_rgb[2],
	    (int)record.c.c_override, (int)record.c.c_inherit);
d390 2
a391 1
  union record record;
d393 2
a394 3
  char name[NAMESIZE];
  char matname[32]; 
  char parm[60];
d408 1
a408 1
    if((extract_mater_from_line(line, name, matname, parm,
d410 1
a410 1
      continue;
d412 5
a416 5
    if( (dp = db_lookup( dbip,  name, LOOKUP_NOISY )) == DIR_NULL ){
      Tcl_AppendResult(interp, "f_rmater: Failed to find ", name, "\n", (char *)NULL);
      status = TCL_ERROR;
      continue;
    }
d418 6
a423 2
    if( db_get( dbip, dp, &record, 0, 1) < 0 )
      continue;
d425 5
a429 5
    /* Assign new values */
    if(matname[0] == '-')
      record.c.c_matname[0] = '\0';
    else
      strcpy(record.c.c_matname, matname);
d431 5
a435 4
    if(parm[0] == '-')
      record.c.c_matparm[0] = '\0';
    else
      strcpy(record.c.c_matparm, parm);
d437 5
a441 12
    record.c.c_rgb[0] = (unsigned char)r;
    record.c.c_rgb[1] = (unsigned char)g;
    record.c.c_rgb[2] = (unsigned char)b;
    record.c.c_override = (char)override;
    record.c.c_inherit = (char)inherit;

    /* Write new values to database */
    if( db_put( dbip, dp, &record, 0, 1 ) < 0 ){
      Tcl_AppendResult(interp, "Database write error, aborting.\n",
		       (char *)NULL);
      return TCL_ERROR;
    }
d449 1
a449 1
extract_mater_from_line(line, name, matname, parm, r, g, b, override, inherit)
d452 1
a452 2
char *matname;
char *parm;
d455 1
d462 1
a462 2
  str[1] = matname;
  str[2] = parm;
d464 2
a465 2
  /* Extract first 3 strings. */
  for(i=j=0; i < 3; ++i){
@


11.43
log
@Further conversion to new import/export interface.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.42 1997/01/30 02:07:31 mike Exp mike $ (BRL)";
d267 1
a267 1
	rt_comb_ifree( &intern );
d537 1
@


11.42
log
@Mirror command greatly cleaned up.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.41 1997/01/30 01:51:25 mike Exp mike $ (BRL)";
d513 2
a514 1
    union record		record;
d526 5
a530 4
    if (db_get(dbip,  dp, &record, 0 , 1) < 0)
    {
      TCL_READ_ERR_return;
    }
d532 1
a532 1
    for (i = 0; i < 3; ++i)
d540 1
a540 6
	    record.c.c_rgb[i] = val;
    record.c.c_override = 1;

    if (db_put( dbip, dp, &record, 0, 1) < 0)
    {
      TCL_WRITE_ERR_return;
d543 5
a547 1
    return TCL_OK;
a610 1
	int ngran;
a1116 1
	union record record;
d1118 2
d1136 2
a1137 2
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 ) {
	  TCL_READ_ERR_return;
d1139 2
d1143 1
a1143 1
		record.c.c_flags = 'R';
d1145 7
a1151 7
		record.c.c_flags =' ';
	record.c.c_regionid = regionid;
	record.c.c_aircode = air;
	record.c.c_los = los;
	record.c.c_material = mat;
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 ) {
	  TCL_WRITE_ERR_return;
a1152 1

a1293 1
	int ngran;
a1295 1
	struct bu_external	external;
a1649 8
	if( rt_functab[internal.idb_type].ft_export( &external, &internal, 1.0 ) < 0 )
	{
	  Tcl_AppendResult(interp, "f_make: export failure\n", (char *)NULL);
	  rt_functab[internal.idb_type].ft_ifree( &internal );
	  return TCL_ERROR;
	}
	rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */

d1653 1
a1653 5
	ngran = (external.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
	if( (dp = db_diradd( dbip, argv[1], -1L, ngran, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )
	    {
	    	db_free_external( &external );
d1655 2
a1656 5
	    }

	if (db_put_external( &external, dp, dbip ) < 0 )
	{
		db_free_external( &external );
a1658 1
	db_free_external( &external );
@


11.41
log
@Expunging rt_get_comb()
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.40 1997/01/30 01:48:57 mike Exp mike $ (BRL)";
d607 1
d635 7
a641 3
	if( proto->d_flags & DIR_SOLID )
	{
		int			id;
d643 3
a645 7
		id = rt_db_get_internal( &internal, proto, dbip, NULL );
		if( id < 0 )  {
		  Tcl_AppendResult(interp, "f_mirror(", argv[1], argv[2],
			   "):  solid import failure\n", (char *)NULL);
		  return TCL_ERROR;				/* FAIL */
		}
		RT_CK_DB_INTERNAL( &internal );
d647 3
a649 1
		switch( id )
d651 1
a651 3
			case ID_TOR:
			{
				struct rt_tor_internal *tor;
d653 2
a654 2
				tor = (struct rt_tor_internal *)internal.idb_ptr;
				RT_TOR_CK_MAGIC( tor );
d656 2
a657 2
				tor->v[k] *= -1.0;
				tor->h[k] *= -1.0;
d659 6
a664 6
				break;
			}
			case ID_TGC:
			case ID_REC:
			{
				struct rt_tgc_internal *tgc;
d666 2
a667 2
				tgc = (struct rt_tgc_internal *)internal.idb_ptr;
				RT_TGC_CK_MAGIC( tgc );
d669 6
a674 6
				tgc->v[k] *= -1.0;
				tgc->h[k] *= -1.0;
				tgc->a[k] *= -1.0;
				tgc->b[k] *= -1.0;
				tgc->c[k] *= -1.0;
				tgc->d[k] *= -1.0;
d676 6
a681 6
				break;
			}
			case ID_ELL:
			case ID_SPH:
			{
				struct rt_ell_internal *ell;
d683 2
a684 2
				ell = (struct rt_ell_internal *)internal.idb_ptr;
				RT_ELL_CK_MAGIC( ell );
d686 4
a689 4
				ell->v[k] *= -1.0;
				ell->a[k] *= -1.0;
				ell->b[k] *= -1.0;
				ell->c[k] *= -1.0;
d691 5
a695 5
				break;
			}
			case ID_ARB8:
			{
				struct rt_arb_internal *arb;
d697 2
a698 2
				arb = (struct rt_arb_internal *)internal.idb_ptr;
				RT_ARB_CK_MAGIC( arb );
d700 7
a706 7
				for( i=0 ; i<8 ; i++ )
					arb->pt[i][k] *= -1.0;
				break;
			}
			case ID_HALF:
			{
				struct rt_half_internal *haf;
d708 1
a708 1
				haf = (struct rt_half_internal *)internal.idb_ptr;
d711 1
a711 1
				haf->eqn[k] *= -1.0;
d713 5
a717 5
				break;
			}
			case ID_GRIP:
			{
				struct rt_grip_internal *grp;
d719 2
a720 2
				grp = (struct rt_grip_internal *)internal.idb_ptr;
				RT_GRIP_CK_MAGIC( grp );
d722 2
a723 2
				grp->center[k] *= -1.0;
				grp->normal[k] *= -1.0;
d725 7
a731 7
				break;
			}
			case ID_POLY:
			{
				struct rt_pg_internal *pg;
				fastf_t *verts;
				fastf_t *norms;
d733 2
a734 2
				pg = (struct rt_pg_internal *)internal.idb_ptr;
				RT_PG_CK_MAGIC( pg );
d736 2
a737 2
				verts = (fastf_t *)bu_calloc( pg->max_npts*3, sizeof( fastf_t ), "f_mirror: verts" );
				norms = (fastf_t *)bu_calloc( pg->max_npts*3, sizeof( fastf_t ), "f_mirror: norms" );
d739 7
a745 1
				for( i=0 ; i<pg->npoly ; i++ )
d747 5
a751 1
					int last;
d753 5
a757 16
					last = (pg->poly[i].npts - 1)*3;
					/* mirror coords and temporarily store in reverse order */
					for( j=0 ; j<pg->poly[i].npts*3 ; j += 3 )
					{
						pg->poly[i].verts[j+k] *= -1.0;
						VMOVE( &verts[last-j], &pg->poly[i].verts[j] )
						pg->poly[i].norms[j+k] *= -1.0;
						VMOVE( &norms[last-j], &pg->poly[i].norms[j] )
					}

					/* write back mirrored and reversed face loop */
					for( j=0 ; j<pg->poly[i].npts*3 ; j += 3 )
					{
						VMOVE( &pg->poly[i].norms[j], &norms[j] )
						VMOVE( &pg->poly[i].verts[j], &verts[j] )
					}
d759 1
d761 2
a762 2
				bu_free( (char *)verts, "f_mirror: verts" );
				bu_free( (char *)norms, "f_mirror: norms" );
d764 5
a768 5
				break;
			}
			case ID_BSPLINE:
			{
				struct rt_nurb_internal *nurb;
d770 2
a771 2
				nurb = (struct rt_nurb_internal *)internal.idb_ptr;
				RT_NURB_CK_MAGIC( nurb );
d773 8
a780 8
				for( i=0 ; i<nurb->nsrf ; i++ )
				{
					fastf_t *ptr;
					int tmp;
					int orig_size[2];
					int ncoords;
					int m;
					int l;
d782 3
a784 3
					/* swap knot vetcors between u and v */
					ptr = nurb->srfs[i]->u.knots;
					tmp = nurb->srfs[i]->u.k_size;
d786 4
a789 4
					nurb->srfs[i]->u.knots = nurb->srfs[i]->v.knots;
					nurb->srfs[i]->u.k_size = nurb->srfs[i]->v.k_size;
					nurb->srfs[i]->v.knots = ptr;
					nurb->srfs[i]->v.k_size = tmp;
d791 4
a794 4
					/* swap order */
					tmp = nurb->srfs[i]->order[0];
					nurb->srfs[i]->order[0] = nurb->srfs[i]->order[1];
					nurb->srfs[i]->order[1] = tmp;
d796 3
a798 3
					/* swap mesh size */
					orig_size[0] = nurb->srfs[i]->s_size[0];
					orig_size[1] = nurb->srfs[i]->s_size[1];
d800 2
a801 2
					nurb->srfs[i]->s_size[0] = orig_size[1];
					nurb->srfs[i]->s_size[1] = orig_size[0];
d803 3
a805 3
					/* allocat memory for a new control mesh */
					ncoords = RT_NURB_EXTRACT_COORDS( nurb->srfs[i]->pt_type );
					ptr = (fastf_t *)bu_calloc( orig_size[0]*orig_size[1]*ncoords, sizeof( fastf_t ), "f_mirror: ctl mesh ptr" );
d807 3
a809 3
					/* mirror each control point */
					for( j=0 ; j<orig_size[0]*orig_size[1] ; j++ )
						nurb->srfs[i]->ctl_points[j*ncoords+k] *= -1.0;
d811 6
a816 4
					/* copy mirrored control points into new mesh
					 * while swaping u and v */
					m = 0;
					for( j=0 ; j<orig_size[0] ; j++ )
d818 2
a819 5
						for( l=0 ; l<orig_size[1] ; l++ )
						{
							VMOVEN( &ptr[(l*orig_size[0]+j)*ncoords], &nurb->srfs[i]->ctl_points[m*ncoords], ncoords )
							m++;
						}
a820 6

					/* free old mesh */
					bu_free( (char *)nurb->srfs[i]->ctl_points , "f_mirror: ctl points" );

					/* put new mesh in place */
					nurb->srfs[i]->ctl_points = ptr;
d823 2
a824 5
				break;
			}
			case ID_ARBN:
			{
				struct rt_arbn_internal *arbn;
d826 2
a827 7
				arbn = (struct rt_arbn_internal *)internal.idb_ptr;
				RT_ARBN_CK_MAGIC( arbn );

				for( i=0 ; i<arbn->neqn ; i++ )
					arbn->eqn[i][k] *= -1.0;

				break;
a828 4
			case ID_PIPE:
			{
				struct rt_pipe_internal *pipe;
				struct wdb_pipept *ps;
d830 5
a834 2
				pipe = (struct rt_pipe_internal *)internal.idb_ptr;
				RT_PIPE_CK_MAGIC( pipe );
d836 2
a837 2
				for( BU_LIST_FOR( ps, wdb_pipept, &pipe->pipe_segs_head ) )
					ps->pp_coord[k] *= -1.0;
d839 2
a840 5
				break;
			}
			case ID_PARTICLE:
			{
				struct rt_part_internal *part;
d842 6
a847 2
				part = (struct rt_part_internal *)internal.idb_ptr;
				RT_PART_CK_MAGIC( part );
d849 2
a850 2
				part->part_V[k] *= -1.0;
				part->part_H[k] *= -1.0;
d852 2
a853 5
				break;
			}
			case ID_RPC:
			{
				struct rt_rpc_internal *rpc;
d855 5
a859 2
				rpc = (struct rt_rpc_internal *)internal.idb_ptr;
				RT_RPC_CK_MAGIC( rpc );
d861 2
a862 3
				rpc->rpc_V[k] *= -1.0;
				rpc->rpc_H[k] *= -1.0;
				rpc->rpc_B[k] *= -1.0;
d864 2
a865 5
				break;
			}
			case ID_RHC:
			{
				struct rt_rhc_internal *rhc;
d867 5
a871 2
				rhc = (struct rt_rhc_internal *)internal.idb_ptr;
				RT_RHC_CK_MAGIC( rhc );
d873 2
a874 3
				rhc->rhc_V[k] *= -1.0;
				rhc->rhc_H[k] *= -1.0;
				rhc->rhc_B[k] *= -1.0;
d876 3
a878 5
				break;
			}
			case ID_EPA:
			{
				struct rt_epa_internal *epa;
d880 5
a884 2
				epa = (struct rt_epa_internal *)internal.idb_ptr;
				RT_EPA_CK_MAGIC( epa );
d886 2
a887 3
				epa->epa_V[k] *= -1.0;
				epa->epa_H[k] *= -1.0;
				epa->epa_Au[k] *= -1.0;
d889 3
a891 5
				break;
			}
			case ID_ETO:
			{
				struct rt_eto_internal *eto;
d893 5
a897 2
				eto = (struct rt_eto_internal *)internal.idb_ptr;
				RT_ETO_CK_MAGIC( eto );
d899 2
a900 3
				eto->eto_V[k] *= -1.0;
				eto->eto_N[k] *= -1.0;
				eto->eto_C[k] *= -1.0;
d902 3
a904 9
				break;
			}
			case ID_NMG:
			{
				struct model *m;
				struct nmgregion *r;
				struct shell *s;
				struct bu_ptbl table;
				struct vertex *v;
d906 5
a910 2
				m = (struct model *)internal.idb_ptr;
				NMG_CK_MODEL( m );
d912 2
a913 6
				/* move every vertex */
				nmg_vertex_tabulate( &table, &m->magic );
				for( i=0 ; i<BU_PTBL_END( &table ) ; i++ )
				{
					v = (struct vertex *)BU_PTBL_GET( &table, i );
					NMG_CK_VERTEX( v );
d915 3
a917 2
					v->vg_p->coord[k] *= -1.0;
				}
d919 9
a927 1
				bu_ptbl_reset( &table );
d929 2
a930 5
				nmg_face_tabulate( &table, &m->magic );
				for( i=0 ; i<BU_PTBL_END( &table ) ; i++ )
				{
					struct face *f;
					struct face_g_plane *fg;
d932 6
a937 2
					f = (struct face *)BU_PTBL_GET( &table, i );
					NMG_CK_FACE( f );
d939 2
a940 2
					if( !f->g.magic_p )
						continue;
d942 1
a942 7
					if( *f->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
					{
						Tcl_AppendResult(interp, "Sorry, Can only mirror NMG solids with planar faces", (char *)0 );
						bu_ptbl_free( &table );
						rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */
						return TCL_ERROR;
					}
d944 5
a948 2
					
				}
d950 2
a951 3
				for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
					for( BU_LIST_FOR( s, shell, &r->s_hd ) )
						nmg_invert_shell( s, &mged_tol );
d953 2
d956 1
a956 1
				for( i=0 ; i<BU_PTBL_END( &table ) ; i++ )
d958 5
a962 3
					struct face *f;
					struct face_g_plane *fg;
					struct faceuse *fu;
d964 2
a965 2
					f = (struct face *)BU_PTBL_GET( &table, i );
					NMG_CK_FACE( f );
d967 3
a969 10
					fu = f->fu_p;
					if( fu->orientation != OT_SAME )
						fu = fu->fumate_p;
					if( fu->orientation != OT_SAME )
					{
						Tcl_AppendResult(interp, "nmg_calc_face_g() failed", (char *)0 );
						bu_ptbl_free( &table );
						rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */
						return TCL_ERROR;
					}
a970 8
					if( nmg_calc_face_g( fu ) )
					{
						Tcl_AppendResult(interp, "nmg_calc_face_g() failed", (char *)0 );
						bu_ptbl_free( &table );
						rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */
						return TCL_ERROR;
					}
				}
d972 1
a972 6
				bu_ptbl_free( &table );
				nmg_rebound( m, &mged_tol );

				break;
			}
			case ID_ARS:
d974 3
a976 2
				struct rt_ars_internal *ars;
				fastf_t *tmp_curve;
d978 2
a979 2
				ars = (struct rt_ars_internal *)internal.idb_ptr;
				RT_ARS_CK_MAGIC( ars );
d981 4
a984 2
				/* mirror each vertex */
				for( i=0 ; i<ars->ncurves ; i++ )
d986 4
a989 2
					for( j=0 ; j<ars->pts_per_curve ; j++ )
						ars->curves[i][j*3+k] *= -1.0;
d992 1
a992 3
				/* now reverse order of vertices in each curve */
				tmp_curve = (fastf_t *)bu_calloc( 3*ars->pts_per_curve, sizeof( fastf_t ), "f_mirror: tmp_curve" );
				for( i=0 ; i<ars->ncurves ; i++ )
d994 4
a997 6
					/* reverse vertex order */
					for( j=0 ; j<ars->pts_per_curve ; j++ )
						VMOVE( &tmp_curve[(ars->pts_per_curve-j-1)*3], &ars->curves[i][j*3] )

					/* now copy back */
					bcopy( tmp_curve, ars->curves[i], ars->pts_per_curve*3*sizeof( fastf_t ) );
d999 1
d1001 2
a1002 1
				bu_free( (char *)tmp_curve, "f_mirror: tmp_curve" );
d1004 15
a1018 1
				break;
d1020 4
a1023 1
			case ID_EBM:
d1025 3
a1027 1
				struct rt_ebm_internal *ebm;
d1029 3
a1031 2
				ebm = (struct rt_ebm_internal *)internal.idb_ptr;
				RT_EBM_CK_MAGIC( ebm );
d1033 1
a1033 4
				MAT_IDN( mirmat )
				mirmat[k*5] = -1.0;
				bn_mat_mul( temp, mirmat, ebm->mat );
				MAT_COPY( ebm->mat, temp )
d1035 5
a1039 5
				break;
			}
			case ID_VOL:
			{
				struct rt_vol_internal *vol;
d1041 2
a1042 2
				vol = (struct rt_vol_internal *)internal.idb_ptr;
				RT_VOL_CK_MAGIC( vol );
d1044 2
d1047 5
a1051 4
				MAT_IDN( mirmat )
				mirmat[k*5] = -1.0;
				bn_mat_mul( temp, mirmat, vol->mat );
				MAT_COPY( vol->mat, temp )
d1053 7
a1059 8
				break;
			}
			default:
			{
				rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */
				Tcl_AppendResult(interp, "Cannot mirror this solid type\n", (char *)NULL);
				return TCL_ERROR;
			}
d1061 3
d1065 2
a1066 2
		/* no interuprts */
		(void)signal( SIGINT, SIG_IGN );
d1068 3
a1070 2
		if( (dp = db_diradd( dbip, argv[2], -1L, 0, DIR_SOLID)) == DIR_NULL )  {
		    	TCL_ALLOC_ERR_return;
d1072 5
a1076 2
		if( rt_db_put_internal( dp, dbip, &internal ) < 0 )  {
			TCL_WRITE_ERR_return;
d1078 1
a1078 2
	} else if( proto->d_flags & DIR_COMB ) {
		struct rt_comb_internal	*comb;
d1080 2
a1081 11
		/* XXX should be able to use rt_db_get_internal() as above */
		if( rt_get_comb( &internal, proto, (mat_t *)NULL, dbip ) < 0 )  {
			Tcl_AppendResult(interp, "rt_get_comb(", proto->d_namep,
				") failure", (char *)NULL );
			TCL_READ_ERR_return;
		}
		comb = (struct rt_comb_internal *)internal.idb_ptr;
		bn_mat_idn( mirmat );
		mirmat[k*5] = -1.0;
		if( comb->tree )
			db_tree_mul_dbleaf( comb->tree, mirmat );
d1083 5
a1087 9
		if( (dp = db_diradd( dbip, argv[2], -1, 0, proto->d_flags ) ) == DIR_NULL )  {
			TCL_ALLOC_ERR_return;
		}
		if( rt_db_put_internal( dp, dbip, &internal ) < 0 )  {
			TCL_WRITE_ERR_return;
		}
	} else {
	  Tcl_AppendResult(interp, argv[2], ": Cannot mirror\n", (char *)NULL);
	  return TCL_ERROR;
@


11.40
log
@Modified "mirror" command to use combination import/export routines.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.39 1997/01/29 20:06:35 mike Exp mike $ (BRL)";
d148 2
a149 4
	if( rt_get_comb( &intern, dp, (mat_t *)NULL, dbip ) < 0 )  {
		Tcl_AppendResult(interp, "rt_get_comb(", dp->d_namep,
			") failure", (char *)NULL );
		return TCL_ERROR;
d152 1
d577 2
a578 4
	if( rt_get_comb( &intern, dp, (mat_t *)NULL, dbip ) < 0 )  {
		Tcl_AppendResult(interp, "rt_get_comb(", dp->d_namep,
			") failure", (char *)NULL );
		return TCL_ERROR;
d581 1
@


11.39
log
@Added comments of thigns to come.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.38 1997/01/29 07:30:21 mike Exp mike $ (BRL)";
d109 2
a110 4
	if( rt_get_comb( &intern, dp, (mat_t *)NULL, dbip ) < 0 )  {
		Tcl_AppendResult(interp, "rt_get_comb(", dp->d_namep,
			") failure", (char *)NULL );
		return TCL_ERROR;
d113 1
d608 1
a608 1
	union record	*rec;
a637 2
		struct rt_db_internal	internal;
		struct bu_external	ext;
d640 2
a641 9
		BU_INIT_EXTERNAL( &ext );
		RT_INIT_DB_INTERNAL( &internal );

/* XXX should be able to use rt_db_get_internal() */
		if( db_get_external( &ext, proto, dbip ) < 0 )
			return TCL_ERROR;

		id = rt_id_solid( &ext );
		if( rt_functab[id].ft_import( &internal, &ext, bn_mat_identity ) < 0 )  {
a643 2
		  if( internal.idb_ptr )  rt_functab[id].ft_ifree( &internal );
		  db_free_external( &ext );
a1074 9
/* XXX should be able to just db_diradd(), then rt_db_put_internal() */
		if( rt_functab[internal.idb_type].ft_export( &ext, &internal, 1.0 ) < 0 )
		{
		  Tcl_AppendResult(interp, "f_mirror: export failure\n", (char *)NULL);
		  rt_functab[internal.idb_type].ft_ifree( &internal );
		  return TCL_ERROR;
		}
		rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */

d1078 1
a1078 6
/* XXX shouldn't have to do ngran or db_alloc() here */
		ngran = (ext.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
		if( (dp = db_diradd( dbip, argv[2], -1L, ngran, DIR_SOLID)) == DIR_NULL ||
		    db_alloc( dbip, dp, 1 ) < 0 )
		    {
		    	db_free_external( &ext );
d1080 2
a1081 5
		    }

		if (db_put_external( &ext, dp, dbip ) < 0 )
		{
			db_free_external( &ext );
a1083 2
		db_free_external( &ext );

d1085 1
a1085 4
/*MIKE*/
		if( (rec = db_getmrec( dbip, proto )) == (union record *)0 ) {
		  TCL_READ_ERR_return;
		}
d1087 5
a1091 3
		if( (dp = db_diradd( dbip, argv[2], -1, proto->d_len, proto->d_flags ) ) == DIR_NULL ||
		    db_alloc( dbip, dp, proto->d_len ) < 0 )  {
		  TCL_ALLOC_ERR_return;
d1093 1
a1093 1
		NAMEMOVE(argv[2], rec[0].c.c_name);
d1096 2
a1097 3
/* use db_tree_mul_dbleaf( comb->tree ); */
		for( i=1; i < proto->d_len; i++) {
			mat_t	xmat;
d1099 2
a1100 7
			if(rec[i].u_id != ID_MEMB) {
			  Tcl_AppendResult(interp, "f_mirror: bad db record\n", (char *)NULL);
			  return TCL_ERROR;
			}
			rt_mat_dbmat( xmat, rec[i].M.m_mat );
			bn_mat_mul(temp, mirmat, xmat);
			rt_dbmat_mat( rec[i].M.m_mat, temp );
d1102 2
a1103 2
		if( db_put( dbip, dp, rec, 0, dp->d_len ) < 0 ) {
		  TCL_WRITE_ERR_return;
a1104 1
		bu_free((genptr_t)rec, "record");
@


11.38
log
@Changed 'shader' command over to new import/export interface
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.37 1997/01/29 07:18:53 mike Exp mike $ (BRL)";
d646 1
d1087 1
d1099 1
d1116 1
d1128 1
@


11.37
log
@Fixed inadvertent memory leak.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.36 1997/01/29 07:08:16 mike Exp mike $ (BRL)";
d565 2
a566 1
	union record		record;
d579 4
a582 2
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 ) {
	  TCL_READ_ERR_return;
d584 2
a586 3
	strncpy( record.c.c_matname, argv[2], sizeof(record.c.c_matname)-1 );
	record.c.c_matname[sizeof(record.c.c_matname)-1] = '\0';

d588 1
a588 5
	bu_vls_init( &args );
	bu_vls_from_argv( &args, argc-3, argv+3 );
	bu_vls_trunc( &args, sizeof(record.c.c_matparm)-1 );
	strcpy( record.c.c_matparm, bu_vls_addr( &args ) );
	bu_vls_free( &args );
d590 2
a591 2
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 ) {
	  TCL_WRITE_ERR_return;
a592 1

@


11.36
log
@Converted 'mater' command to new import/export interface.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.35 1997/01/29 06:02:01 mike Exp mike $ (BRL)";
d175 1
a175 1
	  return TCL_ERROR;
d217 1
a217 1
	  return TCL_ERROR;
d246 1
a246 1
	  return TCL_ERROR;
d268 3
@


11.35
log
@Changed "item" command over to new import/export interface.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.34 1997/01/29 05:48:25 mike Exp mike $ (BRL)";
d124 1
a124 1
/* Usage:  mater name */
a132 1
	union record record;
d136 2
d149 4
a152 2
	if( db_get( dbip, dp, &record, 0 , 1) < 0 ) {
	  TCL_READ_ERR_return;
d154 1
d158 2
a159 2
	    /* Material */
	    strcpy( record.c.c_matname, argv[2]);
d161 1
a161 11
	    if(record.c.c_matname[0] != '\0'){
#if 0
	      Tcl_AppendResult(interp, "Was ", record.c.c_matname, " ",
			       record.c.c_matparm, "\n", (char *)NULL);
#endif
	      record.c.c_matname[0] = '\0';
	      record.c.c_override = 0;
#if 0
	      goto out;
#endif
	    }
d164 5
a168 3
	  /* Material */
	  Tcl_AppendResult(interp, "Material = ", record.c.c_matname, "\n", MORE_ARGS_STR,
			   "Material?  ('del' to delete, CR to skip) ", (char *)NULL);
d170 1
a170 1
	  if(record.c.c_matname[0] == '\0')
d173 1
a173 1
	    bu_vls_printf(&curr_cmd_list->more_default, "%s", record.c.c_matname);
d179 1
a179 20
	  if( strncmp(argv[3],  "del", 3) == 0  )
	    record.c.c_matparm[0] = '\0';
	  else
	    strcpy( record.c.c_matparm, argv[3]);
	}else{
	  /* Parameters */
	  curr_cmd_list->quote_string = 1;
	  Tcl_AppendResult(interp, "Param = ", record.c.c_matparm, "\n", MORE_ARGS_STR,
			   "Parameter string? ('del' to delete, CR to skip) ", (char *)NULL);

	  if(record.c.c_matparm[0] == '\0')
	    bu_vls_printf(&curr_cmd_list->more_default, "del");
	  else
	    bu_vls_printf(&curr_cmd_list->more_default, "\"%s\"", record.c.c_matparm);

	  return TCL_ERROR;
	}

	if(argc >= 5){
	  if( strncmp(argv[4], "del", 3) == 0 ){
d181 3
a183 3
	    record.c.c_override = 0;
	    skip_args = 2;
	  }else if(argc < 7){	/* prompt for color */
d186 7
a192 7
	    sscanf(argv[4], "%d", &r);
	    sscanf(argv[5], "%d", &g);
	    sscanf(argv[6], "%d", &b);
	    record.c.c_rgb[0] = r;
	    record.c.c_rgb[1] = g;
	    record.c.c_rgb[2] = b;
	    record.c.c_override = 1;
d197 1
a197 1
	  if( record.c.c_override ){
d202 1
a202 1
			  record.c.c_rgb[0], record.c.c_rgb[1], record.c.c_rgb[2] );
d207 3
a209 3
			  record.c.c_rgb[0],
			  record.c.c_rgb[1],
			  record.c.c_rgb[2] );
d220 2
a221 2
	if(argc >= 8 - skip_args){
	  inherit = *argv[7 - skip_args];
d224 2
a225 6
	  switch( record.c.c_inherit )  {
	  default:
	    /* This is necessary to clean up old databases with grunge here */
	    record.c.c_inherit = DB_INH_LOWER;
	    /* Fall through */
	  case DB_INH_LOWER:
d229 1
a229 1
	  case DB_INH_HIGHER:
d237 2
a238 2
	  switch( record.c.c_inherit ) {
	  case DB_INH_HIGHER:
d241 1
a241 2
	  case DB_INH_LOWER:
	  default:
d251 1
a251 1
		record.c.c_inherit = DB_INH_HIGHER;
d254 1
a254 1
		record.c.c_inherit = DB_INH_LOWER;
d264 2
a265 2
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 ) {
	  TCL_WRITE_ERR_return;
a266 1

@


11.34
log
@Changed to use d_flags DIR_COMB bit, rather than reading disk record.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.33 1997/01/24 20:54:54 bparker Exp mike $ (BRL)";
d74 1
a74 1
/* Format: I region item <air>	*/
d84 2
a85 1
	union record record;
d96 4
d108 5
a112 2
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 ) {
	  TCL_READ_ERR_return;
d114 5
a118 3
	if( record.c.c_flags != 'R' ) {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a region\n", (char *)NULL);
	  return TCL_ERROR;
d120 1
a120 7
	record.c.c_regionid = ident;
	record.c.c_aircode = air;
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 ) {
	  TCL_WRITE_ERR_return;
	}

	return TCL_ERROR;
@


11.33
log
@mods to f_mater
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.32 1997/01/02 19:36:55 bparker Exp bparker $ (BRL)";
d91 4
a105 4
	if( record.u_id != ID_COMB ) {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
	}
d139 4
a147 5
	if( record.u_id != ID_COMB )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
	}

d374 2
a375 3

    if( db_get( dbip, dp, &record, 0 , 1) < 0 ){
      TCL_READ_ERR;
d380 2
a381 2
    if( record.u_id != ID_COMB ) {
      Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
d544 4
a553 6
    if (record.u_id != ID_COMB)
    {
      Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
      return TCL_ERROR;
    }

d595 4
a603 5
	if( record.u_id != ID_COMB )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
	}

d1204 4
a1215 4
	}
	if( record.u_id != ID_COMB ) {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
@


11.32
log
@mods to use libbn and libbu
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.31 1996/12/16 20:33:18 jra Exp bparker $ (BRL)";
d186 1
@


11.31
log
@Modified f_mirror() to use import/export for solids.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.30 1996/12/13 18:58:33 jra Exp jra $ (BRL)";
a39 1
#include <math.h>
d42 1
d52 1
d65 1
a65 1
extern struct rt_tol mged_tol;
d669 1
a669 1
		struct rt_external	ext;
d672 1
a672 1
		RT_INIT_EXTERNAL( &ext );
d679 1
a679 1
		if( rt_functab[id].ft_import( &internal, &ext, rt_identity ) < 0 )  {
d1063 1
a1063 1
				tmp_curve = (fastf_t *)rt_calloc( 3*ars->pts_per_curve, sizeof( fastf_t ), "f_mirror: tmp_curve" );
d1074 1
a1074 1
				rt_free( (char *)tmp_curve, "f_mirror: tmp_curve" );
d1087 1
a1087 1
				mat_mul( temp, mirmat, ebm->mat );
d1102 1
a1102 1
				mat_mul( temp, mirmat, vol->mat );
d1151 1
a1151 1
		mat_idn( mirmat );
d1161 1
a1161 1
			mat_mul(temp, mirmat, xmat);
d1378 1
a1378 1
	struct rt_external	external;
d1810 1
a1810 1
  mat_idn(temp);
d1813 1
a1813 1
  mat_copy(modelchanges, temp);
d1816 1
a1816 1
  mat_idn(temp);
d1824 1
a1824 1
    mat_mul2(acc_rot_sol, temp);
d1827 1
a1827 1
  /*XXX*/ mat_copy(acc_rot_sol, temp); /* used to rotate solid/object axis */
d1914 1
a1914 1
	mat_idn(incr);
d1974 2
a1975 2
	mat_idn(incr);
	mat_idn(old);
d1994 2
a1995 2
	mat_copy(old,modelchanges);
	mat_mul(modelchanges, incr, old);
d2119 1
a2119 1
	if( rt_db_get_internal( &old_intern, old_dp, dbip, rt_identity ) < 0 )  {
d2285 1
a2285 1
	mat_idn(temp);
d2288 1
a2288 1
	mat_copy(modelchanges, temp);
d2291 1
a2291 1
	mat_idn(temp);
@


11.30
log
@Added some missing declarations.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.29 1996/12/13 18:51:33 bparker Exp jra $ (BRL)";
d55 1
d64 3
d640 1
d665 454
a1118 9
	if( (rec = db_getmrec( dbip, proto )) == (union record *)0 ) {
	  TCL_READ_ERR_return;
	}
	if( rec[0].u_id == ID_SOLID ||
		rec[0].u_id == ID_ARS_A
	)  {
		if( (dp = db_diradd( dbip,  argv[2], -1, proto->d_len, proto->d_flags )) == DIR_NULL ||
		    db_alloc( dbip, dp, proto->d_len ) < 0 )  {
		  TCL_ALLOC_ERR_return;
d1120 12
d1133 4
a1136 11
		/* create mirror image */
		if( rec[0].u_id == ID_ARS_A )  {
			NAMEMOVE( argv[2], rec[0].a.a_name );
			for( i = 1; i < proto->d_len; i++ )  {
				for( j = k; j < 24; j += 3 )
					rec[i].b.b_values[j] *= -1.0;
			}
		} else  {
			for( i = k; i < 24; i += 3 )
				rec[0].s.s_values[i] *= -1.0;
			NAMEMOVE( argv[2], rec[0].s.s_name );
d1138 5
a1142 2
		if( db_put( dbip, dp, rec, 0, dp->d_len ) < 0 ) {
		  TCL_WRITE_ERR_return;
d1144 1
a1144 2
		bu_free((genptr_t)rec, "record");
	} else if( rec[0].u_id == ID_COMB ) {
a2043 1
	extern struct rt_tol mged_tol;
@


11.29
log
@added fast path to the guts of f_rot_obj
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.28 1996/11/19 21:51:23 bparker Exp bparker $ (BRL)";
d1319 6
@


11.28
log
@add -i option to f_rot_obj()
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.27 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
a1312 1
/* allow precise changes to object rotation */
d1314 1
a1314 2
f_rot_obj(clientData, interp, argc, argv)
ClientData clientData;
d1316 2
a1317 2
int	argc;
char	**argv;
a1318 17
  int iflag = 0;
  mat_t temp;
  vect_t s_point, point, v_work, model_pt;

  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  if( not_state( ST_O_EDIT, "Object Rotation" ) )
    return TCL_ERROR;

  /* Check for -i option */
  if(argv[1][0] == '-' && argv[1][1] == 'i'){
    iflag = 1;  /* treat arguments as incremental values */
    ++argv;
    --argc;
  }

d1324 3
a1326 3
		dmp->dm_light( dmp, LIGHT_ON, BE_O_ROTATE );
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_SCALE );
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_XY );
d1328 1
a1328 1
		movedir = ROTARROW;
d1353 4
a1356 3
  buildHrot(temp, atof(argv[1])*degtorad,
	    atof(argv[2])*degtorad,
	    atof(argv[3])*degtorad );
d1373 37
@


11.27
log
@hacks to use latest libdm
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.26 1996/10/04 14:57:57 bparker Exp $ (BRL)";
d1321 6
a1326 2
	mat_t temp;
	vect_t s_point, point, v_work, model_pt;
d1328 2
a1329 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d1331 6
a1336 2
	if( not_state( ST_O_EDIT, "Object Rotation" ) )
	  return TCL_ERROR;
d1338 1
a1338 1
	update_views = 1;
d1340 2
a1341 2
	if(movedir != ROTARROW) {
		/* NOT in object rotate mode - put it in obj rot */
d1348 32
a1379 1
	}
d1381 6
a1386 32
	/* find point for rotation to take place wrt */
	MAT4X3PNT(model_pt, es_mat, es_keypoint);
	MAT4X3PNT(point, modelchanges, model_pt);

	/* Find absolute translation vector to go from "model_pt" to
	 * 	"point" without any of the rotations in "modelchanges"
	 */
	VSCALE(s_point, point, modelchanges[15]);
	VSUB2(v_work, s_point, model_pt);

	/* REDO "modelchanges" such that:
	 *	1. NO rotations (identity)
	 *	2. trans == v_work
	 *	3. same scale factor
	 */
	mat_idn(temp);
	MAT_DELTAS(temp, v_work[X], v_work[Y], v_work[Z]);
	temp[15] = modelchanges[15];
	mat_copy(modelchanges, temp);

	/* build new rotation matrix */
	mat_idn(temp);
	buildHrot(temp, atof(argv[1])*degtorad,
			atof(argv[2])*degtorad,
			atof(argv[3])*degtorad );

/*XXX*/ mat_copy(acc_rot_sol, temp); /* used to rotate solid/object axis */

	/* Record the new rotation matrix into the revised
	 *	modelchanges matrix wrt "point"
	 */
	wrt_point(modelchanges, temp, modelchanges, point);
d1388 1
a1388 1
	new_mats();
d1390 1
a1390 1
	return TCL_OK;
@


11.26
log
@cast bu_free's 1st argument to genptr_t
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.25 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d1334 5
a1338 3
		dmp->dmr_light( dmp, LIGHT_ON, BE_O_ROTATE );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_SCALE );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_XY );
d1406 4
a1409 2
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_ROTATE );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_XY );
d1412 3
a1414 1
		dmp->dmr_light( dmp, LIGHT_ON, edobj );
d1483 5
a1487 3
		dmp->dmr_light( dmp, LIGHT_ON, BE_O_XY );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_SCALE );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_ROTATE );
d1765 5
a1769 3
		dmp->dmr_light( dmp, LIGHT_ON, BE_O_ROTATE );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_SCALE );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_XY );
@


11.25
log
@include mged_solid.h
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.24 1996/09/23 18:37:34 bparker Exp bparker $ (BRL)";
d325 1
a325 1
    bu_free((char *)av, "f_edmater: av");
d337 1
a337 1
  bu_free((char *)av, "f_edmater: av");
d686 1
a686 1
		bu_free( (char *)rec, "record" );
d709 1
a709 1
		bu_free( (char *)rec, "record" );
@


11.24
log
@ use LIBDM permanently
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.23 1996/09/17 21:17:06 bparker Exp bparker $ (BRL)";
d59 1
a59 1
#include "./solid.h"
@


11.23
log
@prepare to use libdm
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.22 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d60 1
a60 1
#include "./dm.h"
a1333 1
#ifdef USE_LIBDM
a1336 5
#else
		dmp->dmr_light( LIGHT_ON, BE_O_ROTATE );
		dmp->dmr_light( LIGHT_OFF, BE_O_SCALE );
		dmp->dmr_light( LIGHT_OFF, BE_O_XY );
#endif
a1403 1
#ifdef USE_LIBDM
a1405 4
#else
		dmp->dmr_light( LIGHT_OFF, BE_O_ROTATE );
		dmp->dmr_light( LIGHT_OFF, BE_O_XY );
#endif
a1407 1
#ifdef USE_LIBDM
a1408 3
#else
		dmp->dmr_light( LIGHT_ON, edobj );
#endif
a1476 1
#ifdef USE_LIBDM
a1479 5
#else
		dmp->dmr_light( LIGHT_ON, BE_O_XY );
		dmp->dmr_light( LIGHT_OFF, BE_O_SCALE );
		dmp->dmr_light( LIGHT_OFF, BE_O_ROTATE );
#endif
a1756 1
#ifdef USE_LIBDM
a1759 5
#else
		dmp->dmr_light( LIGHT_ON, BE_O_ROTATE );
		dmp->dmr_light( LIGHT_OFF, BE_O_SCALE );
		dmp->dmr_light( LIGHT_OFF, BE_O_XY );
#endif
@


11.22
log
@rt_list ---> bu_list
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.21 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d1334 5
d1342 1
d1410 4
d1416 1
d1419 3
d1423 1
d1492 5
d1500 1
d1778 5
d1786 1
@


11.21
log
@now using libbu
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.20 1996/08/26 15:12:25 bparker Exp bparker $ (BRL)";
d50 1
a53 1
#include "rtstring.h"
d1230 1
a1230 1
		s = RT_LIST_FIRST( shell , &r->s_hd );
d1243 1
a1243 1
		RT_LIST_INIT( &pipe_ip->pipe_segs_head );
d1250 1
a1250 1
		RT_LIST_INSERT( &pipe_ip->pipe_segs_head, &ps->l );
d1257 1
a1257 1
		RT_LIST_INSERT( &pipe_ip->pipe_segs_head, &ps->l );
d1557 1
a1557 1
	for (RT_LIST_FOR(r, nmgregion, &m->r_hd))
d1650 1
a1650 1
	for (RT_LIST_FOR(r, nmgregion, &m->r_hd)) {
d1652 1
a1652 1
		for (RT_LIST_FOR(s, shell, &r->s_hd)) {
d1662 1
a1662 1
				new_s = RT_LIST_FIRST(shell, &r->s_hd);
d1675 1
a1675 1
			for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
d1685 1
a1685 1
				new_s = RT_LIST_FIRST(shell, &new_r->s_hd);
d1697 2
a1698 2
			while (RT_LIST_NON_EMPTY(&s->lu_hd)) {
				lu = RT_LIST_FIRST(loopuse, &s->lu_hd);
d1701 1
a1701 1
				new_s = RT_LIST_FIRST(shell, &r->s_hd);
d1710 2
a1711 2
			while (RT_LIST_NON_EMPTY(&s->eu_hd)) {
				eu = RT_LIST_FIRST(edgeuse, &s->eu_hd);
d1714 1
a1714 1
				new_s = RT_LIST_FIRST(shell, &r->s_hd);
@


11.20
log
@modify f_rmater() to call extract_mater_from_line() to handle
material info that contains whitespace
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.19 1996/08/22 21:07:23 bparker Exp bparker $ (BRL)";
d167 1
a167 1
	    rt_vls_printf(&curr_cmd_list->more_default, "del");
d169 1
a169 1
	    rt_vls_printf(&curr_cmd_list->more_default, "%s", record.c.c_matname);
d185 1
a185 1
	    rt_vls_printf(&curr_cmd_list->more_default, "del");
d187 1
a187 1
	    rt_vls_printf(&curr_cmd_list->more_default, "\"%s\"", record.c.c_matparm);
d212 1
a212 1
	    struct rt_vls tmp_vls;
d214 2
a215 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "Color = %d %d %d\n",
d217 2
a218 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d220 1
a220 1
	    rt_vls_printf(&curr_cmd_list->more_default, "%d %d %d",
d226 1
a226 1
	    rt_vls_printf(&curr_cmd_list->more_default, "del");
d257 1
a257 1
	    rt_vls_printf(&curr_cmd_list->more_default, "1");
d261 1
a261 1
	    rt_vls_printf(&curr_cmd_list->more_default, "0");
d315 1
a315 1
  av = (char **)rt_malloc(sizeof(char *)*(argc + 2), "f_edmater: av");
d325 1
a325 1
    rt_free((char *)av, "f_edmater: av");
d337 1
a337 1
  rt_free((char *)av, "f_edmater: av");
d586 1
a586 1
	struct rt_vls		args;
d607 5
a611 5
	rt_vls_init( &args );
	rt_vls_from_argv( &args, argc-3, argv+3 );
	rt_vls_trunc( &args, sizeof(record.c.c_matparm)-1 );
	strcpy( record.c.c_matparm, rt_vls_addr( &args ) );
	rt_vls_free( &args );
d686 1
a686 1
		rt_free( (char *)rec, "record" );
d709 1
a709 1
		rt_free( (char *)rec, "record" );
d801 1
a801 1
	  struct rt_vls tmp_vls;
d803 1
a803 1
	  rt_vls_init(&tmp_vls);
d805 1
a805 1
	  rt_vls_printf(&tmp_vls, "You are currently editing in '%s'.  1%s = %gmm \n",
d807 2
a808 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d870 1
a870 1
	struct rt_vls	title;
d881 2
a882 2
	rt_vls_init( &title );
	rt_vls_from_argv( &title, argc-1, argv+1 );
d884 1
a884 1
	if( db_ident( dbip, rt_vls_addr(&title), dbip->dbi_localunit ) < 0 ) {
d889 1
a889 1
	rt_vls_free( &title );
d949 1
a949 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
d969 1
a969 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
d989 1
a989 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
d1012 1
a1012 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
d1033 1
a1033 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_arb_internal) , "rt_arb_internal" );
d1054 1
a1054 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
d1064 1
a1064 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_grip_internal), "rt_grp_internal" );
d1073 1
a1073 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
d1082 1
a1082 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_ell_internal) , "rt_ell_internal" );
d1091 1
a1091 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tor_internal) , "rt_tor_internal" );
d1103 1
a1103 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
d1114 1
a1114 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
d1125 1
a1125 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
d1136 1
a1136 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
d1147 1
a1147 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_tgc_internal) , "rt_tgc_internal" );
d1158 1
a1158 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_half_internal) , "rt_half_internal" );
d1165 1
a1165 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_rpc_internal) , "rt_rpc_internal" );
d1174 1
a1174 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_rhc_internal) , "rt_rhc_internal" );
d1184 1
a1184 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_epa_internal) , "rt_epa_internal" );
d1194 1
a1194 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_ehy_internal) , "rt_ehy_internal" );
d1205 1
a1205 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_eto_internal) , "rt_eto_internal" );
d1215 1
a1215 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_part_internal) , "rt_part_internal" );
d1240 1
a1240 1
		internal.idb_ptr = (genptr_t)rt_malloc( sizeof(struct rt_pipe_internal), "rt_pipe_internal" );
d1244 1
a1244 1
		GETSTRUCT( ps, wdb_pipept );
d1251 1
a1251 1
		GETSTRUCT( ps, wdb_pipept );
d1630 1
a1630 1
	  struct rt_vls tmp_vls;
d1632 4
a1635 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "%d = %d digits\n", tf+tw+tp, maxdigits);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
@


11.19
log
@added new commands - f_edmater, f_wmater, f_rmater.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.18 1996/08/02 18:06:43 bparker Exp bparker $ (BRL)";
d382 1
a382 2
    /*XXX Still need to handle matparm that contains spaces */
    fprintf(fp, "%s\t%s\t%s\t%d\t%d\t%d\t%d\t%d\n", argv[i],
d425 2
a426 3
    /*XXX Still need to handle a matparm that contains spaces */
    if(sscanf(line, "%s%s%s%d%d%d%d%d", name, matname, parm, &r, &g, &b,
	      &override, &inherit) != 8)
d465 49
@


11.18
log
@fixed yab (yet another bug) in f_mater ---- my oversight
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.17 1996/07/19 21:07:03 bparker Exp bparker $ (BRL)";
d289 180
@


11.17
log
@repaired f_mater
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.16 1996/07/15 20:37:06 bparker Exp bparker $ (BRL)";
d187 1
a187 1
	    rt_vls_printf(&curr_cmd_list->more_default, "%s", record.c.c_matparm);
@


11.16
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.15 1996/05/24 18:32:39 bparker Exp bparker $ (BRL)";
d149 11
a159 5
	    Tcl_AppendResult(interp, "Was ", record.c.c_matname, " ",
			     record.c.c_matparm, "\n", (char *)NULL);
	    record.c.c_matname[0] = '\0';
	    record.c.c_override = 0;
	    goto out;
a233 16
	/* Inherit */
	switch( record.c.c_inherit )  {
	default:
	  /* This is necessary to clean up old databases with grunge here */
	  record.c.c_inherit = DB_INH_LOWER;
	  /* Fall through */
	case DB_INH_LOWER:
	  Tcl_AppendResult(interp, "Inherit = 0:  lower nodes (towards leaves) override\n",
			   (char *)NULL);
	  break;
	case DB_INH_HIGHER:
	   Tcl_AppendResult(interp, "Inherit = 1:  higher nodes (towards root) override\n",
			    (char *)NULL);
	   break;
	}

d235 1
a235 1
	  record.c.c_inherit = inherit = *argv[7 - skip_args];
d237 16
@


11.15
log
@*** empty log message ***
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.14 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d489 1
a489 1
	  char *av[] = {"e", NULL, NULL};
d491 1
d493 1
d1069 1
a1069 1
	  char *av[] = {"e", NULL, NULL};
d1071 1
d1073 1
@


11.14
log
@still tcl-converting
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.13 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
a1091 6

	if(!rot_set){
	  rot_x = atof(argv[1]);
	  rot_y = atof(argv[2]);
	  rot_z = atof(argv[3]);
	}
@


11.13
log
@convert commands to Tcl
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.12 1996/04/03 22:05:50 bparker Exp bparker $ (BRL)";
d488 7
a494 2
	/* draw the "made" solid */
	return f_edit(clientData, interp, 2, argv+1 ); /* depends on name being in argv[2] ! */
d1066 8
a1073 2
	/* draw the "made" solid */
	return f_edit( clientData, interp, 2, argv );	/* depends on name being in argv[1] */
@


11.12
log
@fix mater command so that it also works with
Tcl/Tk command windows
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.11 1996/04/02 18:43:13 bparker Exp bparker $ (BRL)";
d71 3
a73 1
f_itemair( argc, argv )
d81 3
d85 1
a85 1
		return CMD_BAD;
d95 1
a95 2
		READ_ERR;
		return CMD_BAD;
d98 2
a99 2
		rt_log("%s: not a combination\n", dp->d_namep );
		return CMD_BAD;
d102 2
a103 2
		rt_log("%s: not a region\n", dp->d_namep );
		return CMD_BAD;
d108 1
a108 2
		WRITE_ERR;
		return CMD_BAD;
d111 1
a111 1
	return CMD_OK;
d117 3
a119 1
f_mater( argc, argv )
d126 1
d129 3
d133 1
a133 1
		return CMD_BAD;
d136 1
a136 2
		READ_ERR;
		return CMD_BAD;
d140 2
a141 2
		rt_log("%s: not a combination\n", dp->d_namep );
		return CMD_BAD;
d149 2
a150 2
	    (void)rt_log( "Was %s %s\n", record.c.c_matname,
			  record.c.c_matparm);
d157 2
a158 1
	  (void)rt_log( "Material = %s\nMaterial?  ('del' to delete, CR to skip) ", record.c.c_matname);
d165 1
a165 1
	  return CMD_MORE;
d175 2
a176 1
	  (void)rt_log( "Param = %s\nParameter string? ('del' to delete, CR to skip) ", record.c.c_matparm);
d183 1
a183 1
	  return CMD_MORE;
d190 1
d206 8
a213 4
	    (void)rt_log( "Color = %d %d %d\n", 
			  record.c.c_rgb[0],
			  record.c.c_rgb[1],
			  record.c.c_rgb[2] );
d218 4
a221 2
	  }else
	    (void)rt_log( "Color = (No color specified)\n");
d223 3
a225 2
	  (void)rt_log( "Color R G B (0..255)? ('del' to delete, CR to skip) ");
	  return CMD_MORE;
d231 3
a233 3
		/* This is necessary to clean up old databases with grunge here */
		record.c.c_inherit = DB_INH_LOWER;
		/* Fall through */
d235 3
a237 2
		(void)rt_log( "Inherit = 0:  lower nodes (towards leaves) override\n");
		break;
d239 3
a241 2
		(void)rt_log( "Inherit = 1:  higher nodes (towards root) override\n");
		break;
d244 2
a245 2
	if(argc >= 8){
	  record.c.c_inherit = inherit = *argv[7];
d247 2
a248 1
	  (void)rt_log( "Inheritance (0|1)? (CR to skip) ");
d259 1
a259 1
	  return CMD_MORE;
d273 2
a274 2
		rt_log("Unknown response ignored\n");
		break;
d278 1
a278 2
		WRITE_ERR;
		return CMD_BAD;
d281 1
a281 1
	return CMD_OK;
d291 3
a293 2
f_comb_color( argc, argv )

a295 1

d302 3
d306 1
a306 1
	return CMD_BAD;
d310 1
a310 2
	READ_ERR;
	return CMD_BAD;
d315 2
a316 2
	rt_log("%s: not a combination\n", dp->d_namep);
	return CMD_BAD;
d322 3
a324 2
	    rt_log("RGB value out of range: %d\n", val);
	    return CMD_BAD;
d332 1
a332 2
	WRITE_ERR;
	return CMD_BAD;
d335 1
a335 1
    return CMD_OK;
d345 3
a347 1
f_shader( argc, argv )
d355 3
d359 1
a359 1
		return CMD_BAD;
d362 1
a362 2
		READ_ERR;
		return CMD_BAD;
d366 2
a367 2
		rt_log("%s: not a combination\n", dp->d_namep );
		return CMD_BAD;
d381 1
a381 2
		WRITE_ERR;
		return CMD_BAD;
d384 1
a384 1
	return CMD_OK;
d391 3
a393 1
f_mirror( argc, argv )
d404 3
d408 1
a408 1
		return CMD_BAD;
d411 2
a412 2
		aexists( argv[2] );
		return CMD_BAD;
d414 1
d423 2
a424 2
		rt_log("axis must be x, y or z\n");
		return CMD_BAD;
d428 1
a428 2
		READ_ERR;
		return CMD_BAD;
d435 1
a435 2
		    	ALLOC_ERR;
			return CMD_BAD;
d451 1
a451 2
			WRITE_ERR;
			return CMD_BAD;
d457 1
a457 2
		    	ALLOC_ERR;
			return CMD_BAD;
d466 2
a467 2
				rt_log("f_mirror: bad db record\n");
				return CMD_BAD;
d474 1
a474 2
			WRITE_ERR;
			return CMD_BAD;
d478 2
a479 2
		rt_log("%s: Cannot mirror\n",argv[2]);
		return CMD_BAD;
d483 3
a485 4
		rt_log(
		"Mirror image (%s) created but NO memory left to draw it\n",
			argv[2] );
		return CMD_BAD;
d489 1
a489 1
	return f_edit( 2, argv+1 ); /* depends on name being in argv[2] ! */
d495 3
a497 1
f_edcomb( argc, argv )
d505 3
d509 1
a509 1
		return CMD_BAD;
d517 1
a517 2
		READ_ERR;
		return CMD_BAD;
d520 2
a521 2
		rt_log("%s: not a combination\n", dp->d_namep );
		return CMD_BAD;
d533 1
a533 2
		WRITE_ERR;
		return CMD_BAD;
d536 1
a536 1
	return CMD_OK;
d547 3
a549 1
f_units( argc, argv )
d557 3
d561 5
a565 2
		str = rt_units_string(dbip->dbi_local2base);
		rt_log("You are currently editing in '%s'.  1%s = %gmm \n",
d567 3
a569 1
		return CMD_OK;
d593 3
a595 1
			rt_log("Warning: unable to stash working units into database\n");
d598 3
a600 3
		rt_log("%s: unrecognized unit\n", argv[1]);
		rt_log("valid units: <mm|cm|m|in|ft|meters|inches|feet>\n");
		return CMD_BAD;
d609 1
a609 1
		rt_log("\
d611 1
a611 1
this choice of units will not be remembered on your next editing session.\n");
d613 2
a614 2
	rt_log("New editing units = '%s'\n",
		rt_units_string(dbip->dbi_local2base) );
d617 1
a617 1
	return CMD_OK;
d624 3
a626 1
f_title( argc, argv )
d633 3
d637 2
a638 2
		rt_log("%s\n", dbip->dbi_title);
		return CMD_OK;
d645 2
a646 2
		rt_log("Error: unable to change database title\n");
		bad = 1;
d652 1
a652 1
	return bad ? CMD_BAD : CMD_OK;
d660 1
a660 1
	rt_log( "%s:  already exists\n", name );
d670 3
a672 1
f_make( argc, argv )
d695 3
d699 2
a700 2
		aexists( argv[1] );
		return CMD_BAD;
d1025 2
a1026 2
		rt_log("make %s not implimented yet\n", argv[2]);
		return CMD_BAD;
d1028 5
a1032 4
		rt_log("make:  %s is not a known primitive\n", argv[2]);
		rt_log("\tchoices are: arb8, arb7, arb6, arb5, arb4, sph, ell, ellg, grip, tor,\n" );
		rt_log("\t\ttgc, tec, rec, trc, rcc, half, rpc, rhc, epa, ehy, eto, part\n" );
		return CMD_BAD;
d1037 3
a1039 3
		rt_log( "f_make: export failure\n" );
		rt_functab[internal.idb_type].ft_ifree( &internal );
		return CMD_BAD;
d1051 1
a1051 2
	    	ALLOC_ERR;
		return CMD_BAD;
d1057 1
a1057 2
		WRITE_ERR;
		return CMD_BAD;
d1062 1
a1062 1
	return f_edit( 2, argv );	/* depends on name being in argv[1] */
d1067 3
a1069 1
f_rot_obj( argc, argv )
d1076 3
d1080 1
a1080 1
		return CMD_BAD;
d1133 1
a1133 1
	return CMD_OK;
d1138 3
a1140 1
f_sc_obj( argc, argv )
d1147 3
d1151 1
a1151 1
		return CMD_BAD;
d1154 2
a1155 2
		rt_log("ERROR: scale factor <=  0\n");
		return CMD_BAD;
d1207 1
a1207 1
	return CMD_OK;
d1212 3
a1214 1
f_tr_obj( argc, argv )
d1222 3
d1226 1
a1226 1
		return CMD_BAD;
d1252 1
a1252 1
	return CMD_OK;
d1258 3
a1260 1
f_regdef( argc, argv )
d1264 2
d1267 2
a1268 2
	dmaflag = 1;
	item_default = atoi(argv[1]);
d1270 2
a1271 2
	if(argc == 2)
		return CMD_OK;
d1273 3
a1275 3
	air_default = atoi(argv[2]);
	if(air_default) 
		item_default = 0;
d1277 2
a1278 2
	if(argc == 3)
		return CMD_OK;
d1280 1
a1280 1
	los_default = atoi(argv[3]);
d1282 2
a1283 2
	if(argc == 4)
		return CMD_OK;
d1285 1
a1285 1
	mat_default = atoi(argv[4]);
d1287 1
a1287 1
	return CMD_OK;
d1310 2
a1311 1
	    	ALLOC_ERR_return;
d1327 1
a1327 1
		rt_log("rt_db_put_internal() failure\n");
d1344 3
a1346 1
f_fracture( argc, argv )
d1363 4
a1366 1
	rt_log("fracture:");
d1368 2
a1369 2
		rt_log(" %s", argv[i]);
	rt_log("\n");
d1372 1
a1372 1
		return CMD_BAD;
d1375 2
a1376 2
		rt_log("rt_db_get_internal() error\n");
		return CMD_BAD;
a1381 1

d1387 8
a1394 1
	rt_log("%d = %d digits\n", tf+tw+tp, maxdigits);
d1480 1
a1480 1
				if (frac_stat) return CMD_BAD;
d1485 1
a1485 1
	return CMD_OK;
d1497 3
a1499 1
f_qorot( argc, argv )
d1507 3
d1511 1
a1511 1
		return CMD_BAD;
d1554 1
a1554 1
	return CMD_OK;
@


11.11
log
@saving just in case I want this change later on
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.10 1996/03/25 21:49:06 bparker Exp bparker $ (BRL)";
a120 6
	int num_params = 0;
	static int mark = 0;
	static int skip1 = 0;
	static int skip2 = 0;
	static int skip3 = 0;
	static struct cmd_list *clp = (struct cmd_list *)NULL;
a122 7
	if(clp == (struct cmd_list *)NULL)
	  clp = curr_cmd_list;
	else if(curr_cmd_list != clp){
	  rt_log("f_mater: Currently being used by %s.\n", clp->name);
	  return CMD_OK;
	}

a135 3
	if(skip1)
	  goto Mark1;

d148 2
a149 4
	  if(mark){
	    skip1 = 1;
	    goto Mark1;
	  }
d151 4
a154 1
	  mark = 1;
a155 2
	  /* Material */
	  (void)rt_log( "Material = %s\nMaterial?  ('del' to delete, CR to skip) ", record.c.c_matname);
d159 2
a160 6
Mark1:
	if(skip2)
	  goto Mark2;

	if(argc >= 4 - skip1){
	  if( strncmp(argv[3 - skip1],  "del", 3) == 0  )
d163 1
a163 1
	    strcpy( record.c.c_matparm, argv[3 - skip1]);
d165 2
a166 4
	  if(mark == 2){
	    skip2 = 1;
	    goto Mark2;
	  }
d168 4
a171 1
	  mark = 2;
a172 2
	  /* Parameters */
	  (void)rt_log( "Param = %s\nParameter string? ('del' to delete, CR to skip) ", record.c.c_matparm);
d176 2
a177 6
Mark2:
	if(skip3 == 3)
	  goto Mark3;

	if(argc >= 5 - skip2 - skip1){
	  if( strncmp(argv[4 - skip2 - skip1], "del", 3) == 0 ){
d180 1
a180 2
	    skip3 = 2;
	  }else if(argc < 7 - skip2 - skip1){	/* prompt for color */
d183 3
a185 3
	    sscanf(argv[4 - skip2 - skip1], "%d", &r);
	    sscanf(argv[5 - skip2 - skip1], "%d", &g);
	    sscanf(argv[6 - skip2 - skip1], "%d", &b);
d194 1
a194 7
	  if(mark == 3 && argc == 5 - skip2 - skip1 - 1){
	    skip3 = 3;
	    goto Mark3;
	  }

	  mark = 3;
	  if( record.c.c_override )
d199 5
a203 1
	  else
a209 1
Mark3:
d224 2
a225 3
	if(argc >= 8 - skip3 - skip2 - skip1){
		sscanf(argv[8 - skip3 - skip2 - skip1 - 1], "%c", &record.c.c_inherit);
		inherit = *argv[8 - skip3 - skip2 - skip1 - 1];
d227 9
a235 3
	  if(mark == 4){
	    inherit = '\0';
	    goto Mark4;
a237 2
	  mark = 4;
	  (void)rt_log( "Inheritance (0|1)? (CR to skip) ");
d240 1
a240 1
Mark4:
a260 3
	mark = 0;
	skip1 = skip2 = skip3 = 0;
	clp = (struct cmd_list *)NULL;
@


11.10
log
@modified the mater command to use CMD_MORE
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.9 1996/03/22 18:32:07 bparker Exp bparker $ (BRL)";
d126 1
a127 1
	char	*nlp;
d129 7
d170 1
d192 1
d290 1
@


11.9
log
@cleanup
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.8 1996/03/01 19:17:10 bparker Exp bparker $ (BRL)";
a118 1
	char line[80];
d121 6
d132 1
a132 1
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 ) {
d142 3
a144 1
#if 0
d146 10
a155 10
		if( strncmp( argv[2], "del", 3 ) != 0 )  {
		/* Material */
			strcpy( record.c.c_matname, argv[2]);
		}else{
			(void)rt_log( "Was %s %s\n", record.c.c_matname,
						record.c.c_matparm);
			record.c.c_matname[0] = '\0';
			record.c.c_override = 0;
			goto out;
		}
d157 20
a176 10
		/* Material */
		(void)rt_log( "Material = %s\nMaterial?  ('del' to delete, CR to skip) ", record.c.c_matname);
		return CMD_MORE;
	}

	if(argc >= 4){
		if( strncmp(argv[3],  "del", 3) == 0  )
			record.c.c_matparm[0] = '\0';
		else
			strcpy( record.c.c_matparm, argv[3]);
d178 31
a208 21
		/* Parameters */
		(void)rt_log( "Param = %s\nParameter string? ('del' to delete, CR to skip) ", record.c.c_matparm);
		return CMD_MORE;
	}

	if(argc >= 5){
		if( strncmp(argv[4], "del", 3) == 0 ){
			/* leave color as is */
			record.c.c_override = 0;
			num_params = 6;
		}else if(argc < 7){	/* prompt for color */
			goto color_prompt;
		}else{	/* change color */
			sscanf(argv[4], "%d", &r);
			sscanf(argv[5], "%d", &g);
			sscanf(argv[6], "%d", &b);
			record.c.c_rgb[0] = r;
			record.c.c_rgb[1] = g;
			record.c.c_rgb[2] = b;
			record.c.c_override = 1;
		}
d212 16
a227 9
	if( record.c.c_override )
		(void)rt_log( "Color = %d %d %d\n", 
			record.c.c_rgb[0],
			record.c.c_rgb[1],
			record.c.c_rgb[2] );
	else
		(void)rt_log( "Color = (No color specified)\n");
	(void)rt_log( "Color R G B (0..255)? ('del' to delete, CR to skip) ");
	return CMD_MORE;
d230 1
d245 3
a247 3
	if(argc >= num_params){
		sscanf(argv[num_params - 1], "%c", &record.c.c_inherit);
		line[0] = *argv[num_params - 1];
d249 8
a256 74
		(void)rt_log( "Inheritance (0|1)? (CR to skip) ");
		return CMD_MORE;
	}
#else
	if( argc >= 3 )  {
		if( strncmp( argv[2], "del", 3 ) != 0 )  {
			rt_log("Use 'mater name del' to delete\n");
			return CMD_BAD;
		}
		rt_log("Was %s %s\n", record.c.c_matname, record.c.c_matparm);
		record.c.c_matname[0] = '\0';
		record.c.c_override = 0;
		goto out;
	}

	/* Material */
	rt_log("Material = %s\nMaterial?  ('del' to delete, CR to skip) ", record.c.c_matname);
	(void)fgets(line,sizeof(line),stdin);
	nlp = strchr( line, '\n' );
	if( strncmp(line, "del", 3) == 0 )  {
		record.c.c_matname[0] = '\0';
	} else if( line[0] != '\n' && line[0] != '\0' ) {
		if( nlp != NULL )  *nlp = '\0';
		strncpy( record.c.c_matname, line,
			sizeof(record.c.c_matname)-1);
	}

	/* Parameters */
	rt_log("Param = %s\nParameter string? ('del' to delete, CR to skip) ", record.c.c_matparm);
	(void)fgets(line,sizeof(line),stdin);
	nlp = strchr( line, '\n' );
	if( strncmp(line, "del", 3) == 0  )  {
		record.c.c_matparm[0] = '\0';
	} else if( line[0] != '\n' && line[0] != '\0' ) {
		if( nlp != NULL )  *nlp = '\0';
		strncpy( record.c.c_matparm, line,
			sizeof(record.c.c_matparm)-1 );
	}

	/* Color */
	if( record.c.c_override )
		rt_log("Color = %d %d %d\n", 
			record.c.c_rgb[0],
			record.c.c_rgb[1],
			record.c.c_rgb[2] );
	else
		rt_log("Color = (No color specified)\n");
	rt_log("Color R G B (0..255)? ('del' to delete, CR to skip) ");
	/* XXX This is bad!!!  Should use CMD_MORE return*/
	(void)fgets(line,sizeof(line),stdin);
	if( strncmp(line, "del", 3) == 0 ) {
		record.c.c_override = 0;
	} else if( sscanf(line, "%d %d %d", &r, &g, &b) >= 3 )  {
		record.c.c_rgb[0] = r;
		record.c.c_rgb[1] = g;
		record.c.c_rgb[2] = b;
		record.c.c_override = 1;
	} else {
		/* Else, leave it unchanged */
		rt_log(" (color unchanged)\n");
	}

	/* Inherit */
	switch( record.c.c_inherit )  {
	default:
		/* This is necessary to clean up old databases with grunge here */
		record.c.c_inherit = DB_INH_LOWER;
		/* Fall through */
	case DB_INH_LOWER:
		rt_log("Inherit = 0:  lower nodes (towards leaves) override\n");
		break;
	case DB_INH_HIGHER:
		rt_log("Inherit = 1:  higher nodes (towards root) override\n");
		break;
d258 2
a259 4
	rt_log("Inheritance (0|1)? (CR to skip) ");
	(void)fgets(line,sizeof(line),stdin);
#endif
	switch( line[0] )  {
d279 2
@


11.8
log
@remove unused XMGED stuff
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.7 1996/02/09 22:14:51 bparker Exp bparker $ (BRL)";
a62 1
#ifdef VIRTUAL_TRACKBALL
a63 2
#endif

a1078 1
#ifdef VIRTUAL_TRACKBALL
a1084 2
#endif
#ifdef MULTI_ATTACH
a1085 1
#endif
a1120 1
#ifdef VIRTUAL_TRACKBALL
a1121 1
#endif
a1128 1
	dmaflag = 1;
a1149 1
#ifdef MULTI_ATTACH
a1150 1
#endif
a1214 1
#ifdef MULTI_ATTACH
a1215 1
#endif
a1518 1
	dmaflag = 1;
@


11.7
log
@adding virtual trackball stuff
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.6 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
a63 5
extern void (*tran_hook)();
extern void (*rot_hook)();
extern int rot_set;
extern int tran_set;

a125 3
#ifdef XMGED
	int	num_params = 8;	/* number of parameters */
#endif
d140 1
a140 1
#ifdef XMGED
a1139 5
#ifdef VIRTUAL_TRACKBALL
	if(rot_hook)
          (*rot_hook)();
#endif

a1251 8

#ifdef VIRTUAL_TRACKBALL
	if(!tran_set) /*   not calling from f_tran()   */
	  set_tran(new_vertex[0], new_vertex[1], new_vertex[2]);

	if(tran_hook)
	  (*tran_hook)();
#endif
@


11.6
log
@Just playing it safe
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.5 1995/09/26 20:21:21 pjt Exp bparker $ (BRL)";
d63 1
a63 1
#ifdef XMGED
d66 1
a66 4
extern int irot_set;
extern double irot_x;
extern double irot_y;
extern double irot_z;
a67 3
extern double tran_x;
extern double tran_y;
extern double tran_z;
d1090 5
a1094 5
#ifdef XMGED
	if(!irot_set){
	  irot_x = atof(argv[1]);
	  irot_y = atof(argv[2]);
	  irot_z = atof(argv[3]);
d1136 1
a1136 1
#ifdef XMGED
d1148 1
a1148 1
#ifdef XMGED
d1266 1
a1266 1
#ifdef XMGED
@


11.5
log
@Implemented comb_color command
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.4 1995/07/28 19:17:52 jra Exp $ (BRL)";
a73 1
extern int      update_views;
d1103 2
d1179 1
a1179 1
#ifdef XMGED
d1246 1
a1246 1
#ifdef XMGED
@


11.4
log
@Mods for new definition of pipe solid.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.3 1995/07/18 22:52:58 jra Exp jra $ (BRL)";
d331 52
@


11.3
log
@Added pipe to make command
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 11.2 1995/01/17 13:04:25 bparker Exp jra $ (BRL)";
d964 1
a964 1
		struct wdb_pipeseg *ps;
d971 1
a971 2
		GETSTRUCT( ps, wdb_pipeseg );
		ps->ps_type = WDB_PIPESEG_TYPE_LINEAR;
d973 4
a976 3
		VSET( ps->ps_start, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]-Viewscale );
		ps->ps_od = 0.5*Viewscale;
		ps->ps_id = 0.5*ps->ps_od;
d978 1
a978 2
		GETSTRUCT( ps, wdb_pipeseg );
		ps->ps_type = WDB_PIPESEG_TYPE_END;
d980 4
a983 3
		VSET( ps->ps_start, -toViewcenter[MDX] , -toViewcenter[MDY] , -toViewcenter[MDZ]+Viewscale );
		ps->ps_od = 0.5*Viewscale;
		ps->ps_id = 0.5*ps->ps_od;
@


11.2
log
@merging xmged sources
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/chgmodel.c,v 11.2 95/01/17 11:41:57 bparker Exp $ (BRL)";
d57 1
d663 1
d963 22
a989 1
		   strcmp( argv[2], "pipe" ) == 0 ||
@


11.1
log
@Release_4.4
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.27 94/12/20 16:28:21 jra Exp $ (BRL)";
d62 16
d137 3
d153 2
d157 80
d308 1
d1022 10
d1066 4
d1078 5
d1103 4
d1170 4
d1195 9
@


10.27
log
@Mods for CRAY.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.26 1994/12/16 19:35:36 gdurf Exp gdurf $ (BRL)";
@


10.26
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.25 1994/11/17 17:06:13 jra Exp gdurf $ (BRL)";
a146 1
	fflush(stdout);
a158 1
	fflush(stdout);
a177 1
	fflush(stdout);
a205 1
	fflush(stdout);
a559 1
	struct rt_nmg_internal *nmg_ip;
d1102 1
a1102 1
mged_add_nmg_part(newname, m, old_dp)
a1104 1
struct directory *old_dp;
d1227 1
a1227 2
				mged_add_nmg_part(newname, new_model,
							dbip);
d1249 1
a1249 2
				mged_add_nmg_part(newname, new_model,
							dbip);
d1263 1
a1263 2
				mged_add_nmg_part(newname, new_model,
							dbip);
d1277 1
a1277 2
				mged_add_nmg_part(newname, new_model,
							dbip, old_dp);
@


10.25
log
@Added nmg_ml call to f_make for NMG case.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/chgmodel.c,v 10.24 94/11/16 16:58:31 jra Exp Locker: jra $ (BRL)";
d92 1
a92 1
		(void)printf("%s: not a combination\n", dp->d_namep );
d96 1
a96 1
		(void)printf("%s: not a region\n", dp->d_namep );
d131 1
a131 1
		(void)printf("%s: not a combination\n", dp->d_namep );
d136 1
a136 1
			(void)printf("Use 'mater name del' to delete\n");
d139 1
a139 1
		(void)printf("Was %s %s\n", record.c.c_matname, record.c.c_matparm);
d146 1
a146 1
	(void)printf("Material = %s\nMaterial?  ('del' to delete, CR to skip) ", record.c.c_matname);
d159 1
a159 1
	(void)printf("Param = %s\nParameter string? ('del' to delete, CR to skip) ", record.c.c_matparm);
d173 1
a173 1
		(void)printf("Color = %d %d %d\n", 
d178 2
a179 2
		(void)printf("Color = (No color specified)\n");
	(void)printf("Color R G B (0..255)? ('del' to delete, CR to skip) ");
d192 1
a192 1
		printf(" (color unchanged)\n");
d202 1
a202 1
		(void)printf("Inherit = 0:  lower nodes (towards leaves) override\n");
d205 1
a205 1
		(void)printf("Inherit = 1:  higher nodes (towards root) override\n");
d208 1
a208 1
	(void)printf("Inheritance (0|1)? (CR to skip) ");
d222 1
a222 1
		(void)printf("Unknown response ignored\n");
d258 1
a258 1
		(void)printf("%s: not a combination\n", dp->d_namep );
d310 1
a310 1
		(void)printf("axis must be x, y or z\n");
d357 1
a357 1
				(void)printf("f_mirror: bad db record\n");
d370 1
a370 1
		(void)printf("%s: Cannot mirror\n",argv[2]);
d375 1
a375 1
		(void)printf(
d409 1
a409 1
		(void)printf("%s: not a combination\n", dp->d_namep );
d447 1
a447 1
		(void)printf("You are currently editing in '%s'.  1%s = %gmm \n",
d473 1
a473 1
			printf("Warning: unable to stash working units into database\n");
d476 2
a477 2
		(void)printf("%s: unrecognized unit\n", argv[1]);
		(void)printf("valid units: <mm|cm|m|in|ft|meters|inches|feet>\n");
d487 1
a487 1
		(void)printf("\
d491 1
a491 1
	(void)printf("New editing units = '%s'\n",
d510 1
a510 1
		(void)printf("%s\n", dbip->dbi_title);
d518 1
a518 1
		printf("Error: unable to change database title\n");
d533 1
a533 1
	(void)printf( "%s:  already exists\n", name );
d872 1
a872 1
		(void)printf("make %s not implimented yet\n", argv[2]);
d875 3
a877 3
		(void)printf("make:  %s is not a known primitive\n", argv[2]);
		(void)printf("\tchoices are: arb8, arb7, arb6, arb5, arb4, sph, ell, ellg, grip, tor,\n" );
		(void)printf("\t\ttgc, tec, rec, trc, rcc, half, rpc, rhc, epa, ehy, eto, part\n" );
d983 1
a983 1
		(void)printf("ERROR: scale factor <=  0\n");
d1142 1
a1142 1
		printf("rt_db_put_internal() failure\n");
d1185 1
a1185 1
		(void)printf("rt_db_get_internal() error\n");
@


10.24
log
@added NMG to make command.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/chgmodel.c,v 10.23 94/11/14 17:20:30 mike Exp Locker: jra $ (BRL)";
d861 1
@


10.23
log
@Added 'shader' command, to substitute for grungy 'mater' command.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.22 94/11/08 04:20:53 mike Exp Locker: mike $ (BRL)";
d564 1
d574 1
a574 1
	 * sph | tor | tgc | rec | trc | rcc | grp | half> */
d851 12
a864 1
		   strcmp( argv[2], "nmg" ) == 0 ||
@


10.22
log
@Irix 6
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.21 94/10/12 02:24:10 butler Exp Locker: mike $ (BRL)";
d181 1
d233 47
@


10.21
log
@added call to nmg_region_a to mged_add_nmg_part() so that facetize command
would work again.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.20 1994/10/06 13:01:21 jra Exp butler $ (BRL)";
a1104 1
	struct rt_db_internal	new_intern;
a1111 2
	struct loopuse *lu;
	struct edgeuse *eu;
d1173 1
a1173 1
							dbip, old_dp);
d1196 1
a1196 1
							dbip, old_dp);
d1211 1
a1211 1
							dbip, old_dp);
@


10.20
log
@Added ERIM solids, part, and half to make command.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.19 94/08/19 16:13:42 pjt Exp Locker: jra $ (BRL)";
d1053 2
d1067 5
@


10.19
log
@Improved (fixed?) f_qorot
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.18 94/08/19 13:51:10 pjt Exp Locker: pjt $ (BRL)";
d509 7
d525 1
a525 1
	 * sph | tor | tgc | rec | trc | rcc | grp> */
d735 77
a811 2
	} else if( strcmp( argv[2], "ars" ) == 0 )  {
		(void)printf("make ars not implimented yet\n");
d815 2
@


10.18
log
@First (half-way working) version of f_qorot
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.17 1994/08/09 14:51:28 gdurf Exp $ (BRL)";
a1160 1
	vect_t	specified_pt;
d1162 1
d1174 2
a1175 3
	specified_pt[X] = atof(argv[1]);
	specified_pt[Y] = atof(argv[2]);
	specified_pt[Z] = atof(argv[3]);
d1199 1
a1199 1
	buildHrot(temp, 0.0, atof(argv[7])*degtorad, 0,0);
d1204 1
a1204 1
	wrt_point(modelchanges, temp, modelchanges, point);
@


10.17
log
@Factored ifdefs
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.16 1994/08/03 13:46:43 gdurf Exp gdurf $ (BRL)";
d1147 16
d1164 48
@


10.16
log
@ixed reference to log10() to work on Convex
F
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.15 1994/06/13 19:04:43 gdurf Exp cjohnson $ (BRL)";
d38 2
d43 3
a45 1
#ifdef BSD
a46 2
#else
#include <string.h>
a1025 3
#ifndef log10
	double log10();
#endif
@


10.15
log
@Corrected typo
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.14 1994/06/01 16:26:23 gdurf Exp gdurf $ (BRL)";
d734 1
a734 1
	if( rt_functab[internal.idb_type].ft_export( &external, &internal, local2base ) < 0 )
d1024 1
d1026 1
@


10.14
log
@Converted f_ functions to use new command return codes.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.13 1994/04/05 17:20:17 cjohnson Exp gdurf $ (BRL)";
d955 1
a955 1
	return CMK_OK;
@


10.13
log
@Add "make name grip|grp"
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.12 1993/09/30 15:11:31 jra Exp cjohnson $ (BRL)";
d66 1
a66 1
void
d76 1
a76 1
		return;
d85 4
a88 1
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 )  READ_ERR_return;
d91 1
a91 1
		return;
d95 1
a95 1
		return;
d99 6
a104 1
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
d109 1
a109 1
void
d121 6
a126 1
		return;
a127 1
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 )  READ_ERR_return;
d130 1
a130 1
		return;
d135 1
a135 1
			return;
d223 6
a228 1
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )   WRITE_ERR_return;
d233 1
a233 1
void
d246 1
a246 1
		return;
d250 1
a250 1
		return;
d261 1
a261 1
		return;
d264 4
a267 2
	if( (rec = db_getmrec( dbip, proto )) == (union record *)0 )
		READ_ERR_return;
d273 2
a274 1
		    	ALLOC_ERR_return;
d289 4
a292 1
		if( db_put( dbip, dp, rec, 0, dp->d_len ) < 0 )  WRITE_ERR_return;
d297 2
a298 1
		    	ALLOC_ERR_return;
d308 1
a308 1
				return;
d314 4
a317 1
		if( db_put( dbip, dp, rec, 0, dp->d_len ) < 0 )  WRITE_ERR_return;
d321 1
a321 1
		return;
d328 1
a328 1
		return;
d332 1
a332 1
	f_edit( 2, argv+1 );	/* depends on name being in argv[2] ! */
d337 1
a337 1
void
d347 1
a347 1
		return;
d354 4
a357 1
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 )  READ_ERR_return;
d360 1
a360 1
		return;
d371 6
a376 1
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
d386 1
a386 1
void
d399 1
a399 1
		return;
d428 1
a428 1
		return;
d444 2
d451 1
a451 1
void
d457 1
d461 1
a461 1
		return;
d467 1
a467 1
	if( db_ident( dbip, rt_vls_addr(&title), dbip->dbi_localunit ) < 0 )
d469 2
d474 2
d492 1
a492 1
void
d510 1
a510 1
		return;
d728 1
a728 1
		return;
d731 1
a731 1
		return;
d738 1
a738 1
		return;
d750 2
a751 1
	    	ALLOC_ERR_return;
d757 2
a758 1
		WRITE_ERR_return;
d763 1
a763 1
	f_edit( 2, argv );	/* depends on name being in argv[1] */
d767 1
a767 1
void
d776 1
a776 1
		return;
d819 2
d824 1
a824 1
void
d833 1
a833 1
		return;
d837 1
a837 1
		return;
d886 2
d891 1
a891 1
void
d901 1
a901 1
		return;
d924 1
a924 1
	return;
d929 1
a929 1
void
d939 1
a939 1
		return;
d946 1
a946 1
		return;
d951 1
a951 1
		return;
d954 2
d1004 1
a1004 1
void
d1032 1
a1032 1
		return;
d1036 1
a1036 1
		return;
d1085 1
a1085 1
				if (frac_stat) return;
d1108 1
a1108 1
				if (frac_stat) return;
d1123 1
a1123 1
				if (frac_stat) return;
d1138 1
a1138 1
				if (frac_stat) return;
d1143 1
@


10.12
log
@modified f_make to use import/export
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.11 93/02/26 06:15:46 butler Exp Locker: jra $ (BRL)";
d464 1
d473 2
a474 1
	/* make name <arb8|arb7|arb6|arb5|arb4|ellg|ell|sph|tor|tgc|rec|trc|rcc> */
d589 10
@


10.11
log
@missed a set of calls to nmg_start_dup()/nmg_end_dup() in last edit
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.10 1993/02/26 06:12:28 butler Exp butler $ (BRL)";
d54 1
d456 1
a456 1
	union record record;
d458 6
a468 5
	/* Position this solid at view center */
	record.s.s_values[0] = -toViewcenter[MDX];
	record.s.s_values[1] = -toViewcenter[MDY];
	record.s.s_values[2] = -toViewcenter[MDZ];
	record.s.s_id = ID_SOLID;
d470 1
a470 4
	/* Zero out record.s.s_values[] */
	for( i = 3; i < 24; i++ )  {
		record.s.s_values[i] = 0.0;
	}
d474 5
a478 3
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB8;
		VSET( &record.s.s_values[0*3],
d482 11
a492 7
		VSET( &record.s.s_values[1*3],  0, (Viewscale*2), 0 );
		VSET( &record.s.s_values[2*3],  0, (Viewscale*2), (Viewscale*2) );
		VSET( &record.s.s_values[3*3],  0, 0, (Viewscale*2) );
		VSET( &record.s.s_values[4*3],  -(Viewscale*2), 0, 0 );
		VSET( &record.s.s_values[5*3],  -(Viewscale*2), (Viewscale*2), 0 );
		VSET( &record.s.s_values[6*3],  -(Viewscale*2), (Viewscale*2), (Viewscale*2) );
		VSET( &record.s.s_values[7*3],  -(Viewscale*2), 0, (Viewscale*2)  );
d494 5
a498 3
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB7;
		VSET( &record.s.s_values[0*3],
d502 11
a512 7
		VSET( &record.s.s_values[1*3],  0, (Viewscale*2), 0 );
		VSET( &record.s.s_values[2*3],  0, (Viewscale*2), (Viewscale*2) );
		VSET( &record.s.s_values[3*3],  0, 0, Viewscale );
		VSET( &record.s.s_values[4*3],  -(Viewscale*2), 0, 0 );
		VSET( &record.s.s_values[5*3],  -(Viewscale*2), (Viewscale*2), 0 );
		VSET( &record.s.s_values[6*3],  -(Viewscale*2), (Viewscale*2), Viewscale );
		VSET( &record.s.s_values[7*3],  -(Viewscale*2), 0, 0  );
d514 5
a518 3
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB6;
		VSET( &record.s.s_values[0*3],
d522 14
a535 7
		VSET( &record.s.s_values[1*3],  0, (Viewscale*2), 0 );
		VSET( &record.s.s_values[2*3],  0, (Viewscale*2), (Viewscale*2) );
		VSET( &record.s.s_values[3*3],  0, 0, (Viewscale*2) );
		VSET( &record.s.s_values[4*3],  -(Viewscale*2), Viewscale, 0 );
		VSET( &record.s.s_values[5*3],  -(Viewscale*2), Viewscale, 0 );
		VSET( &record.s.s_values[6*3],  -(Viewscale*2), Viewscale, (Viewscale*2) );
		VSET( &record.s.s_values[7*3],  -(Viewscale*2), Viewscale, (Viewscale*2)  );
d537 5
a541 3
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB5;
		VSET( &record.s.s_values[0*3],
d545 12
a556 7
		VSET( &record.s.s_values[1*3],  0, (Viewscale*2), 0 );
		VSET( &record.s.s_values[2*3],  0, (Viewscale*2), (Viewscale*2) );
		VSET( &record.s.s_values[3*3],  0, 0, (Viewscale*2) );
		VSET( &record.s.s_values[4*3],  -(Viewscale*2), Viewscale, Viewscale );
		VSET( &record.s.s_values[5*3],  -(Viewscale*2), Viewscale, Viewscale );
		VSET( &record.s.s_values[6*3],  -(Viewscale*2), Viewscale, Viewscale );
		VSET( &record.s.s_values[7*3],  -(Viewscale*2), Viewscale, Viewscale  );
d558 5
a562 3
		record.s.s_type = GENARB8;
		record.s.s_cgtype = ARB4;
		VSET( &record.s.s_values[0*3],
d566 12
a577 7
		VSET( &record.s.s_values[1*3],  0, (Viewscale*2), 0 );
		VSET( &record.s.s_values[2*3],  0, (Viewscale*2), (Viewscale*2) );
		VSET( &record.s.s_values[3*3],  0, (Viewscale*2), (Viewscale*2) );
		VSET( &record.s.s_values[4*3],  -(Viewscale*2), (Viewscale*2), 0 );
		VSET( &record.s.s_values[5*3],  -(Viewscale*2), (Viewscale*2), 0 );
		VSET( &record.s.s_values[6*3],  -(Viewscale*2), (Viewscale*2), 0 );
		VSET( &record.s.s_values[7*3],  -(Viewscale*2), (Viewscale*2), 0  );
d579 8
a586 5
		record.s.s_type = GENELL;
		record.s.s_cgtype = SPH;
		VSET( &record.s.s_values[1*3], (0.5*Viewscale), 0, 0 );	/* A */
		VSET( &record.s.s_values[2*3], 0, (0.5*Viewscale), 0 );	/* B */
		VSET( &record.s.s_values[3*3], 0, 0, (0.5*Viewscale) );	/* C */
d588 8
a595 5
		record.s.s_type = GENELL;
		record.s.s_cgtype = ELL;
		VSET( &record.s.s_values[1*3], (0.5*Viewscale), 0, 0 );	/* A */
		VSET( &record.s.s_values[2*3], 0, (0.25*Viewscale), 0 );	/* B */
		VSET( &record.s.s_values[3*3], 0, 0, (0.25*Viewscale) );	/* C */
d597 8
a604 5
		record.s.s_type = GENELL;
		record.s.s_cgtype = ELL;
		VSET( &record.s.s_values[1*3], Viewscale, 0, 0 );	/* A */
		VSET( &record.s.s_values[2*3], 0, (0.5*Viewscale), 0 );	/* B */
		VSET( &record.s.s_values[3*3], 0, 0, (0.25*Viewscale) );	/* C */
d606 11
a616 9
		record.s.s_type = TOR;
		record.s.s_cgtype = TOR;
		VSET( &record.s.s_values[1*3], (0.5*Viewscale), 0, 0 );	/* N with mag = r2 */
		VSET( &record.s.s_values[2*3], 0, Viewscale, 0 );	/* A == r1 */
		VSET( &record.s.s_values[3*3], 0, 0, Viewscale );	/* B == r1 */
		VSET( &record.s.s_values[4*3], 0, (0.5*Viewscale), 0 );	/* A == r1-r2 */
		VSET( &record.s.s_values[5*3], 0, 0, (0.5*Viewscale) );	/* B == r1-r2 */
		VSET( &record.s.s_values[6*3], 0, (1.5*Viewscale), 0 );	/* A == r1+r2 */
		VSET( &record.s.s_values[7*3], 0, 0, (1.5*Viewscale) );	/* B == r1+r2 */
d618 10
a627 7
		record.s.s_type = GENTGC;
		record.s.s_cgtype = TGC;
		VSET( &record.s.s_values[1*3],  0, 0, (Viewscale*2) );
		VSET( &record.s.s_values[2*3],  (0.5*Viewscale), 0, 0 );
		VSET( &record.s.s_values[3*3],  0, (0.25*Viewscale), 0 );
		VSET( &record.s.s_values[4*3],  (0.25*Viewscale), 0, 0 );
		VSET( &record.s.s_values[5*3],  0, (0.5*Viewscale), 0 );
d629 10
a638 7
		record.s.s_type = GENTGC;
		record.s.s_cgtype = TEC;
		VSET( &record.s.s_values[1*3],  0, 0, (Viewscale*2) );
		VSET( &record.s.s_values[2*3],  (0.5*Viewscale), 0, 0 );
		VSET( &record.s.s_values[3*3],  0, (0.25*Viewscale), 0 );
		VSET( &record.s.s_values[4*3],  (0.25*Viewscale), 0, 0 );
		VSET( &record.s.s_values[5*3],  0, 31.75, 0 );
d640 10
a649 7
		record.s.s_type = GENTGC;
		record.s.s_cgtype = REC;
		VSET( &record.s.s_values[1*3],  0, 0, (Viewscale*2) );
		VSET( &record.s.s_values[2*3],  (0.5*Viewscale), 0, 0 );
		VSET( &record.s.s_values[3*3],  0, (0.25*Viewscale), 0 );
		VSET( &record.s.s_values[4*3],  (0.5*Viewscale), 0, 0 );
		VSET( &record.s.s_values[5*3],  0, (0.25*Viewscale), 0 );
d651 10
a660 7
		record.s.s_type = GENTGC;
		record.s.s_cgtype = TRC;
		VSET( &record.s.s_values[1*3],  0, 0, (Viewscale*2) );
		VSET( &record.s.s_values[2*3],  (0.5*Viewscale), 0, 0 );
		VSET( &record.s.s_values[3*3],  0, (0.5*Viewscale), 0 );
		VSET( &record.s.s_values[4*3],  (0.25*Viewscale), 0, 0 );
		VSET( &record.s.s_values[5*3],  0, (0.25*Viewscale), 0 );
d662 10
a671 7
		record.s.s_type = GENTGC;
		record.s.s_cgtype = RCC;
		VSET( &record.s.s_values[1*3],  0, 0, (Viewscale*2) );
		VSET( &record.s.s_values[2*3],  (0.5*Viewscale), 0, 0 );
		VSET( &record.s.s_values[3*3],  0, (0.5*Viewscale), 0 );
		VSET( &record.s.s_values[4*3],  (0.5*Viewscale), 0, 0 );
		VSET( &record.s.s_values[5*3],  0, (0.5*Viewscale), 0 );
d680 16
a695 3
	/* Add to in-core directory */
	if( (dp = db_diradd( dbip,  argv[1], -1, 0, DIR_SOLID )) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )  {
d697 6
d704 1
a704 3

	NAMEMOVE( argv[1], record.s.s_name );
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
@


10.10
log
@nmg_start_dup() and nmg_end_dup() have disappeared.  The calls to these
routines in the "fracture" command support have been commented out for
now.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.9 1992/11/23 18:53:13 mike Exp butler $ (BRL)";
d961 1
a961 1
	nmg_start_dup(m);
d964 1
a964 1
	nmg_end_dup();
@


10.9
log
@Made types match.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.8 92/07/23 05:03:42 butler Exp Locker: mike $ (BRL)";
d932 1
a932 1
	nmg_start_dup(m);
d940 1
a940 1
	nmg_end_dup();
@


10.8
log
@added the "fracture" command for NMG's
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.7 92/06/25 20:48:36 mike Exp Locker: butler $ (BRL)";
d884 1
a884 1
	int tw, tf, tp;
@


10.7
log
@Prototype "fracture" command
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.6 92/03/23 22:33:29 mike Exp Locker: mike $ (BRL)";
d819 38
d862 2
a863 2
 *
 *
d874 1
a874 1
	struct model	*m;
d876 10
a885 1
	struct directory *new_dp;
d903 17
a920 1
	sprintf( newname, "newname" );
d922 9
a930 5
	if( db_lookup( dbip,  newname, LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( newname );
		/* Free memory here */
		return;
	}
d932 9
a940 3
	if( (new_dp=db_diradd( dbip, newname, -1, 0, old_dp->d_flags)) == DIR_NULL )  {
	    	ALLOC_ERR_return;
	}
d942 1
a942 4
	/* Export NMG as a new solid */
	RT_INIT_DB_INTERNAL(&new_intern);
	new_intern.idb_type = ID_NMG;
	new_intern.idb_ptr = (genptr_t)m;
d944 59
a1002 4
	if( rt_db_put_internal( new_dp, dbip, &new_intern ) < 0 )  {
		/* Free memory */
		printf("rt_db_put_internal() failure\n");
		return;
d1004 1
a1004 2
	/* Internal representation has been freed by rt_db_put_internal */
	new_intern.idb_ptr = (genptr_t)NULL;
d1006 1
@


10.6
log
@Adopted es_keypoint
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.5 92/03/23 22:30:59 mike Exp Locker: mike $ (BRL)";
d49 1
d52 1
a54 1
#include "externs.h"
d817 64
@


10.5
log
@Moved ARB editing routines from chgmodel.c to edarb.c
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.4 92/02/05 20:00:17 mike Exp Locker: mike $ (BRL)";
d653 1
a653 2
	/* XXX should have an es_keypoint for this */
	MAT4X3PNT(model_pt, es_mat, es_rec.s.s_values);
d745 1
a745 2
	/* XXX should have an es_keypoint for this */
	MAT4X3PNT(temp, es_mat, es_rec.s.s_values);
d779 1
a779 2
	/* XXX should have an es_keypoint for this */
	MAT4X3PNT(model_sol_pt, es_mat, es_rec.s.s_values);
@


10.4
log
@Changed es_gentype to es_rec.s.s_type, preparatory to getting rid of it.
@
text
@a11 2
 *	f_extrude	"extrude" command -- project an ARB face
 *	f_arbdef	define ARB8 using rot fb angles to define face
a12 1
 *	f_mirface	mirror an ARB face
d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.3 91/12/20 02:27:33 mike Exp Locker: mike $ (BRL)";
a58 1
void	ext4to6();
a305 317
/* Extrude command - project an arb face */
/* Format: extrude face distance	*/
void
f_extrude( argc, argv )
int	argc;
char	**argv;
{
	register int i, j;
	static int face;
	static int pt[4];
	static int prod;
	static fastf_t dist;
	static struct solidrec lsolid;	/* local copy of solid */

	if( not_state( ST_S_EDIT, "Extrude" ) )
		return;

	if( es_rec.s.s_type != GENARB8 )  {
		(void)printf("Extrude: solid type must be ARB\n");
		return;
	}

	if(es_type != ARB8 && es_type != ARB6 && es_type != ARB4) {
		(void)printf("ARB%d: extrusion of faces not allowed\n",es_type);
		return;
	}

	face = atoi( argv[1] );

	/* get distance to project face */
	dist = atof( argv[2] );
	/* apply es_mat[15] to get to real model space */
	/* convert from the local unit (as input) to the base unit */
	dist = dist * es_mat[15] * local2base;

	/* convert to point notation in temporary buffer */
	VMOVE( &lsolid.s_values[0], &es_rec.s.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VADD2(&lsolid.s_values[i], &es_rec.s.s_values[i], &lsolid.s_values[0]);
	}

	if( (es_type == ARB6 || es_type == ARB4) && face < 1000 ) {
		/* 3 point face */
		pt[0] = face / 100;
		i = face - (pt[0]*100);
		pt[1] = i / 10;
		pt[2] = i - (pt[1]*10);
		pt[3] = 1;
	}
	else {
		pt[0] = face / 1000;
		i = face - (pt[0]*1000);
		pt[1] = i / 100;
		i = i - (pt[1]*100);
		pt[2] = i / 10;
		pt[3] = i - (pt[2]*10);
	}

	/* user can input face in any order - will use product of
	 * face points to distinguish faces:
	 *    product       face
	 *       24         1234 for ARB8
	 *     1680         5678 for ARB8
	 *      252         2367 for ARB8
	 *      160         1548 for ARB8
	 *      672         4378 for ARB8
	 *       60         1256 for ARB8
	 *	 10	    125 for ARB6
	 *	 72	    346 for ARB6
	 * --- special case to make ARB6 from ARB4
	 * ---   provides easy way to build ARB6's
	 *        6	    123 for ARB4
	 *	  8	    124 for ARB4
 	 *	 12	    134 for ARB4
	 *	 24	    234 for ARB4
	 */
	prod = 1;
	for( i = 0; i <= 3; i++ )  {
		prod *= pt[i];
		if(es_type == ARB6 && pt[i] == 6)
			pt[i]++;
		if(es_type == ARB4 && pt[i] == 4)
			pt[i]++;
		pt[i]--;
		if( pt[i] > 7 )  {
			(void)printf("bad face: %d\n",face);
			return;
		}
	}

	/* find plane containing this face */
	if( planeqn(6, pt[0], pt[1], pt[2], &lsolid) ) {
		(void)printf("face: %d is not a plane\n",face);
		return;
	}
	/* get normal vector of length == dist */
	for( i = 0; i < 3; i++ )
		es_peqn[6][i] *= dist;

	/* protrude the selected face */
	switch( prod )  {

	case 24:   /* protrude face 1234 */
		if(es_type == ARB6) {
			(void)printf("ARB6: extrusion of face %d not allowed\n",face);
			return;
		}
		if(es_type == ARB4)
			goto a4toa6;	/* extrude face 234 of ARB4 to make ARB6 */

		for( i = 0; i < 4; i++ )  {
			j = i + 4;
			VADD2( &lsolid.s_values[j*3],
				&lsolid.s_values[i*3],
				&es_peqn[6][0]);
		}
		break;

	case 6:		/* extrude ARB4 face 123 to make ARB6 */
	case 8:		/* extrude ARB4 face 124 to make ARB6 */
	case 12:	/* extrude ARB4 face 134 to Make ARB6 */
a4toa6:
		ext4to6(pt[0], pt[1], pt[2], &lsolid);
		es_rec.s.s_cgtype = ARB6;
		sedit_menu();
	break;

	case 1680:   /* protrude face 5678 */
		for( i = 0; i < 4; i++ )  {
			j = i + 4;
			VADD2( &lsolid.s_values[i*3],
				&lsolid.s_values[j*3],
				&es_peqn[6][0] );
		}
		break;

	case 60:   /* protrude face 1256 */
	case 10:   /* extrude face 125 of ARB6 */
		VADD2( &lsolid.s_values[9],
			&lsolid.s_values[0],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[6],
			&lsolid.s_values[3],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[21],
			&lsolid.s_values[12],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[18],
			&lsolid.s_values[15],
			&es_peqn[6][0] );
		break;

	case 672:   /* protrude face 4378 */
	case 72:	/* extrude face 346 of ARB6 */
		VADD2( &lsolid.s_values[0],
			&lsolid.s_values[9],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[3],
			&lsolid.s_values[6],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[15],
			&lsolid.s_values[18],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[12],
			&lsolid.s_values[21],
			&es_peqn[6][0] );
		break;

	case 252:   /* protrude face 2367 */
		VADD2( &lsolid.s_values[0],
			&lsolid.s_values[3],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[9],
			&lsolid.s_values[6],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[12],
			&lsolid.s_values[15],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[21],
			&lsolid.s_values[18],
			&es_peqn[6][0] );
		break;

	case 160:   /* protrude face 1548 */
		VADD2( &lsolid.s_values[3],
			&lsolid.s_values[0],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[15],
			&lsolid.s_values[12],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[6],
			&lsolid.s_values[9],
			&es_peqn[6][0] );
		VADD2( &lsolid.s_values[18],
			&lsolid.s_values[21],
			&es_peqn[6][0] );
		break;

	case 120:
	case 180:
		(void)printf("ARB6: extrusion of face %d not allowed\n",face);
		return;

	default:
		(void)printf("bad face: %d\n", face );
		return;
	}

	/* redo the plane equations */
	for(i=0; i<6; i++) {
		if(arb_faces[es_type-4][i*4] == -1)
			break;
		pt[0] = arb_faces[es_type-4][i*4];
		pt[1] = arb_faces[es_type-4][i*4+1];
		pt[2] = arb_faces[es_type-4][i*4+2];
		if(planeqn(i, pt[0], pt[1], pt[2], &lsolid)) {
			(void)printf("No equation for face %d%d%d%d\n",
				pt[0]+1,pt[1]+1,pt[2]+1,arb_faces[es_type-4][i*4+3]);
			return;
		}
	}

	/* Convert back to point&vector notation */
	VMOVE( &es_rec.s.s_values[0], &lsolid.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VSUB2( &es_rec.s.s_values[i], &lsolid.s_values[i], &lsolid.s_values[0]);
	}

	/* draw the updated solid */
	replot_editing_solid();
	dmaflag = 1;
}

/* define an arb8 using rot fb angles to define a face */
/* Format: a name rot fb	*/
void
f_arbdef( argc, argv )
int	argc;
char	**argv;
{
	register struct directory *dp;
	union record record;
	int i, j;
	fastf_t rota, fb;
	vect_t	norm;

	if( db_lookup( dbip,  argv[1] , LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( argv[1] );
		return;
	}

	/* get rotation angle */
	rota = atof( argv[2] ) * degtorad;

	/* get fallback angle */
	fb = atof( argv[3] ) * degtorad;

	if( (dp = db_diradd( dbip,  argv[1], -1, 1, DIR_SOLID )) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )  {
	    	ALLOC_ERR_return;
	}
	NAMEMOVE( argv[1], record.s.s_name );
	record.s.s_id = ID_SOLID;
	record.s.s_type = GENARB8;
	record.s.s_cgtype = ARB8;

	/* put vertex of new solid at center of screen */
	record.s.s_values[0] = -toViewcenter[MDX];
	record.s.s_values[1] = -toViewcenter[MDY];
	record.s.s_values[2] = -toViewcenter[MDZ];

	/* calculate normal vector (length = 2) defined by rot,fb */
	norm[0] = cos(fb) * cos(rota) * -50.8;
	norm[1] = cos(fb) * sin(rota) * -50.8;
	norm[2] = sin(fb) * -50.8;

	for( i = 3; i < 24; i++ )
		record.s.s_values[i] = 0.0;

	/* find two perpendicular vectors which are perpendicular to norm */
	j = 0;
	for( i = 0; i < 3; i++ )  {
		if( fabs(norm[i]) < fabs(norm[j]) )
			j = i;
	}
	record.s.s_values[j+3] = 1.0;
	VCROSS( &record.s.s_values[9], &record.s.s_values[3], norm );
	VCROSS( &record.s.s_values[3], &record.s.s_values[9], norm );

	/* create new rpp 20x20x2 */
	/* the 20x20 faces are in rot,fb plane */
	VUNITIZE( &record.s.s_values[3] );
	VUNITIZE( &record.s.s_values[9] );
	VSCALE(&record.s.s_values[3], &record.s.s_values[3], 508.0);
	VSCALE(&record.s.s_values[9], &record.s.s_values[9], 508.0);
	VADD2( &record.s.s_values[6],
		&record.s.s_values[3],
		&record.s.s_values[9] );
	VMOVE( &record.s.s_values[12], norm );
	for( i = 3; i < 12; i += 3 )  {
		j = i + 12;
		VADD2( &record.s.s_values[j], &record.s.s_values[i], norm );
	}

	/* update dbip->dbi_fd and draw new arb8 */
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
	if( no_memory )  {
		(void)printf(
			"ARB8 (%s) created but no memory left to draw it\n",
			argv[1] );
		return;
	}

	/* draw the "made" solid */
	f_edit( 2, argv );	/* depends on name being in argv[1] */
}

a341 213
/* Mirface command - mirror an arb face */
/* Format: mirror face axis	*/
void
f_mirface( argc, argv )
int	argc;
char	**argv;
{
	register int i, j, k;
	static int face;
	static int pt[4];
	static int prod;
	static vect_t work;
	static struct solidrec lsolid;	/* local copy of solid */

	if( not_state( ST_S_EDIT, "Mirface" ) )
		return;

	if( es_rec.s.s_type != GENARB8 )  {
		(void)printf("Mirface: solid type must be ARB\n");
		return;
	}

	if(es_type != ARB8 && es_type != ARB6) {
		(void)printf("ARB%d: mirroring of faces not allowed\n",es_type);
		return;
	}
	face = atoi( argv[1] );
	if( face > 9999 || (face < 1000 && es_type != ARB6) ) {
		(void)printf("ERROR: %d bad face\n",face);
		return;
	}
	/* check which axis */
	k = -1;
	if( strcmp( argv[2], "x" ) == 0 )
		k = 0;
	if( strcmp( argv[2], "y" ) == 0 )
		k = 1;
	if( strcmp( argv[2], "z" ) == 0 )
		k = 2;
	if( k < 0 ) {
		(void)printf("axis must be x, y or z\n");
		return;
	}

	work[0] = work[1] = work[2] = 1.0;
	work[k] = -1.0;

	/* convert to point notation in temporary buffer */
	VMOVE( &lsolid.s_values[0], &es_rec.s.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VADD2(&lsolid.s_values[i], &es_rec.s.s_values[i], &lsolid.s_values[0]);
	}

	if(es_type == ARB6 && face < 1000) { 	/* 3 point face */
		pt[0] = face / 100;
		i = face - (pt[0]*100);
		pt[1] = i / 10;
		pt[2] = i - (pt[1]*10);
		pt[3] = 1;
	}
	else {
		pt[0] = face / 1000;
		i = face - (pt[0]*1000);
		pt[1] = i / 100;
		i = i - (pt[1]*100);
		pt[2] = i / 10;
		pt[3] = i - (pt[2]*10);
	}

	/* user can input face in any order - will use product of
	 * face points to distinguish faces:
	 *    product       face
	 *       24         1234 for ARB8
	 *     1680         5678 for ARB8
	 *      252         2367 for ARB8
	 *      160         1548 for ARB8
	 *      672         4378 for ARB8
	 *       60         1256 for ARB8
	 *	 10	    125 for ARB6
	 *	 72	    346 for ARB6
	 */
	prod = 1;
	for( i = 0; i <= 3; i++ )  {
		prod *= pt[i];
		pt[i]--;
		if( pt[i] > 7 )  {
			(void)printf("bad face: %d\n",face);
			return;
		}
	}

	/* mirror the selected face */
	switch( prod )  {

	case 24:   /* mirror face 1234 */
		if(es_type == ARB6) {
			(void)printf("ARB6: mirroring of face %d not allowed\n",face);
			return;
		}
		for( i = 0; i < 4; i++ )  {
			j = i + 4;
			VELMUL( &lsolid.s_values[j*3],
				&lsolid.s_values[i*3],
				work);
		}
		break;

	case 1680:   /* mirror face 5678 */
		for( i = 0; i < 4; i++ )  {
			j = i + 4;
			VELMUL( &lsolid.s_values[i*3],
				&lsolid.s_values[j*3],
				work );
		}
		break;

	case 60:   /* mirror face 1256 */
	case 10:	/* mirror face 125 of ARB6 */
		VELMUL( &lsolid.s_values[9],
			&lsolid.s_values[0],
			work );
		VELMUL( &lsolid.s_values[6],
			&lsolid.s_values[3],
			work );
		VELMUL( &lsolid.s_values[21],
			&lsolid.s_values[12],
			work );
		VELMUL( &lsolid.s_values[18],
			&lsolid.s_values[15],
			work );
		break;

	case 672:   /* mirror face 4378 */
	case 72:	/* mirror face 346 of ARB6 */
		VELMUL( &lsolid.s_values[0],
			&lsolid.s_values[9],
			work );
		VELMUL( &lsolid.s_values[3],
			&lsolid.s_values[6],
			work );
		VELMUL( &lsolid.s_values[15],
			&lsolid.s_values[18],
			work );
		VELMUL( &lsolid.s_values[12],
			&lsolid.s_values[21],
			work );
		break;

	case 252:   /* mirror face 2367 */
		VELMUL( &lsolid.s_values[0],
			&lsolid.s_values[3],
			work );
		VELMUL( &lsolid.s_values[9],
			&lsolid.s_values[6],
			work );
		VELMUL( &lsolid.s_values[12],
			&lsolid.s_values[15],
			work );
		VELMUL( &lsolid.s_values[21],
			&lsolid.s_values[18],
			work );
		break;

	case 160:   /* mirror face 1548 */
		VELMUL( &lsolid.s_values[3],
			&lsolid.s_values[0],
			work );
		VELMUL( &lsolid.s_values[15],
			&lsolid.s_values[12],
			work );
		VELMUL( &lsolid.s_values[6],
			&lsolid.s_values[9],
			work );
		VELMUL( &lsolid.s_values[18],
			&lsolid.s_values[21],
			work );
		break;

	case 120:
	case 180:
		(void)printf("ARB6: mirroring of face %d not allowed\n",face);
		return;

	default:
		(void)printf("bad face: %d\n", face );
		return;
	}

	/* redo the plane equations */
	for(i=0; i<6; i++) {
		if(arb_faces[es_type-4][i*4] == -1)
			break;
		pt[0] = arb_faces[es_type-4][i*4];
		pt[1] = arb_faces[es_type-4][i*4+1];
		pt[2] = arb_faces[es_type-4][i*4+2];
		if(planeqn(i, pt[0], pt[1], pt[2], &lsolid)) {
			(void)printf("No equation for face %d%d%d%d\n",
				pt[0]+1,pt[1]+1,pt[2]+1,arb_faces[es_type-4][i*4+3]);
			return;
		}
	}

	/* Convert back to point&vector notation */
	VMOVE( &es_rec.s.s_values[0], &lsolid.s_values[0] );
	for( i = 3; i <= 21; i += 3 )  {  
		VSUB2( &es_rec.s.s_values[i], &lsolid.s_values[i], &lsolid.s_values[0]);
	}

	/* draw the updated solid */
	replot_editing_solid();
	dmaflag = 1;
}

a819 90


/* Edgedir command:  define the direction of an arb edge being moved
 *	Format:  edgedir deltax deltay deltaz
	     OR  edgedir rot fb
 */

void
f_edgedir( argc, argv )
int	argc;
char	**argv;
{
	register int i;
	vect_t slope;
	FAST fastf_t rot, fb;

	if( not_state( ST_S_EDIT, "Edgedir" ) )
		return;

	if( es_edflag != EARB ) {
		(void)printf("Not moving an ARB edge\n");
		return;
	}

	if( es_rec.s.s_type != GENARB8 ) {
		(void)printf("Edgedir: solid type must be an ARB\n");
		return;
	}

	/* set up slope -
	 *	if 2 values input assume rot, fb used
	 *	else assume delta_x, delta_y, delta_z
	 */
	if( argc == 3 ) {
		rot = atof( argv[1] ) * degtorad;
		fb = atof( argv[2] ) * degtorad;
		slope[0] = cos(fb) * cos(rot);
		slope[1] = cos(fb) * sin(rot);
		slope[2] = sin(fb);
	}
	else {
		for(i=0; i<3; i++) {
			/* put edge slope in slope[] array */
			slope[i] = atof( argv[i+1] );
		}
	}

	if(MAGNITUDE(slope) == 0) {
		(void)printf("BAD slope\n");
		return;
	}

	/* get it done */
	newedge = 1;
	editarb( slope );
	sedraw++;

}


/*	EXT4TO6():	extrudes face pt1 pt2 pt3 of an ARB4 "distance"
 *			to produce ARB6 using solid record "sp"
 */
void
ext4to6(pt1, pt2, pt3, sp)
int pt1, pt2, pt3;
register struct solidrec *sp;
{
	struct solidrec tmp;
	register int i;

	VMOVE(&tmp.s_values[0], &sp->s_values[pt1*3]);
	VMOVE(&tmp.s_values[3], &sp->s_values[pt2*3]);
	VMOVE(&tmp.s_values[12], &sp->s_values[pt3*3]);
	VMOVE(&tmp.s_values[15], &sp->s_values[pt3*3]);

	/* extrude "distance" to get remaining points */
	VADD2(&tmp.s_values[6], &tmp.s_values[3], &es_peqn[6][0]);
	VADD2(&tmp.s_values[9], &tmp.s_values[0], &es_peqn[6][0]);
	VADD2(&tmp.s_values[18], &tmp.s_values[12], &es_peqn[6][0]);
	VMOVE(&tmp.s_values[21], &tmp.s_values[18]);

	/* copy to the original record */
	for(i=0; i<=21; i+=3) {
		VMOVE(&sp->s_values[i], &tmp.s_values[i]);
	}
}



@


10.3
log
@Setting of es_edflag now done in sedit_menu()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.2 91/12/18 07:46:03 mike Exp Locker: mike $ (BRL)";
d327 1
a327 1
	if( es_gentype != GENARB8 )  {
d680 1
a680 1
	if( es_gentype != GENARB8 )  {
d1378 1
a1378 1
	if( es_gentype != GENARB8 ) {
@


10.2
log
@Eliminated now useless calls to pr_solid().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 10.1 91/10/12 06:43:10 mike Rel4_0 Locker: mike $ (BRL)";
a433 2
		es_edflag = IDLE;
		es_menu = 0;
@


10.1
log
@Release_4.0
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 9.10 91/07/01 02:05:36 mike Exp $ (BRL)";
a541 1
	pr_solid( &es_rec.s );
a874 1
	pr_solid( &es_rec.s );
a941 2
	if(state == ST_S_EDIT)
		pr_solid( &es_rec.s );
@


9.10
log
@"title" command prints current title, if no args.
Changed to using rt_vls, to prevent buffer overflows.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 9.9 91/06/30 21:14:43 mike Exp $ (BRL)";
@


9.9
log
@Expanded UNITS command to allow any units know to librt,
even if the database can't remember it.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 9.8 91/01/12 08:25:43 mike Exp $ (BRL)";
d53 1
a53 1
#include "./sedit.h"
d59 1
d957 1
a957 2
	register int i;
	char	title[256];
d959 3
a961 4
	title[0] = '\0';
	for(i=1; i<argc; i++) {
		(void)strcat(title, argv[i]);
		(void)strcat(title, " ");
d964 4
a967 1
	if( db_ident( dbip, title, dbip->dbi_localunit ) < 0 )
d969 2
@


9.8
log
@externs.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 9.7 90/12/08 00:31:08 mike Exp $ (BRL)";
d880 2
d883 2
a884 1
 * Base unit is fixed so just changing the current local unit.
d891 3
a893 1
	int new_unit = 0;
d895 7
d918 1
d921 1
a921 4
		/* XXX - save local units */
		localunit = dbip->dbi_localunit;
		local2base = dbip->dbi_local2base;
		base2local = dbip->dbi_base2local;
a923 2
		if(state == ST_S_EDIT)
			pr_solid( &es_rec.s );
d925 3
a927 1
		dmaflag = 1;
d929 11
d941 5
a945 3

	(void)printf("%s: unrecognized unit\n", argv[1]);
	(void)printf("valid units: <mm|cm|m|in|ft|meters|inches|feet>\n");
@


9.7
log
@Added error checking around calls to db_*() routines
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 9.6 90/12/07 19:52:09 mike Exp $ (BRL)";
a58 2

extern char	*strchr();
@


9.6
log
@Error message in TITLE command improved.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 9.5 90/12/07 19:48:03 mike Exp $ (BRL)";
d88 1
a88 1
	db_get( dbip,  dp, &record, 0 , 1);
d99 1
a99 1
	db_put( dbip, dp, &record, 0, 1 );
d118 1
a118 1
	db_get( dbip,  dp, &record, 0 , 1);
d214 1
a214 1
	db_put( dbip, dp, &record, 0, 1 );
d227 1
a227 1
	union record record;
d250 4
a253 3
	db_get( dbip,  proto, &record, 0 , 1);
	if( record.u_id == ID_SOLID ||
		record.u_id == ID_ARS_A
d255 4
a258 3
		if( (dp = db_diradd( dbip,  argv[2], -1, proto->d_len, DIR_SOLID )) == DIR_NULL )
			return;
		db_alloc( dbip, dp, proto->d_len );
d261 2
a262 3
		if( record.u_id == ID_ARS_A )  {
			NAMEMOVE( argv[2], record.a.a_name );
			db_put( dbip, dp, &record, 0, 1 );
a263 1
				db_get( dbip,  proto, &record, i , 1);
d265 1
a265 2
					record.b.b_values[j] *= -1.0;
				db_put( dbip, dp, &record, i, 1 );
d269 2
a270 3
				record.s.s_values[i] *= -1.0;
			NAMEMOVE( argv[2], record.s.s_name );
			db_put( dbip, dp, &record, 0, 1 );
d272 8
a279 11
	} else if( record.u_id == ID_COMB ) {
		if( (dp = db_diradd( dbip, 
			argv[2], -1, proto->d_len,
				record.c.c_flags == 'R' ?
				DIR_COMB|DIR_REGION :
				DIR_COMB)
		) == DIR_NULL )
			return;
		db_alloc( dbip, dp, proto->d_len );
		NAMEMOVE(argv[2], record.c.c_name);
		db_put( dbip, dp, &record, 0, 1 );
d285 1
a285 2
			db_get( dbip, proto, &record, i, 1);
			if(record.u_id != ID_MEMB) {
d289 1
a289 1
			rt_mat_dbmat( xmat, record.M.m_mat );
d291 1
a291 2
			rt_dbmat_mat( record.M.m_mat, temp );
			db_put( dbip, dp, &record, i, 1 );
d293 2
d571 4
a574 3
	if( (dp = db_diradd( dbip,  argv[1], -1, 1, DIR_SOLID )) == DIR_NULL )
		return;
	db_alloc( dbip, dp, 1 );
d619 1
a619 1
	db_put( dbip, dp, &record, 0, 1 );
d650 1
a650 1
	db_get( dbip,  dp, &record, 0 , 1);
d664 1
a664 1
	db_put( dbip, dp, &record, 0, 1 );
d1135 4
a1138 3
	if( (dp = db_diradd( dbip,  argv[1], -1, 0, DIR_SOLID )) == DIR_NULL )
		return;
	db_alloc( dbip, dp, 1 );
d1141 1
a1141 1
	db_put( dbip, dp, &record, 0, 1 );
@


9.5
log
@If db_ident() fails, print warning
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgmodel.c,v 9.4 90/04/21 06:05:14 mike Exp $ (BRL)";
a59 4
extern void	perror();
extern int	atoi(), execl(), fork(), nice(), wait();
extern long	time();
extern char	*strcat();
d949 1
a949 1
		printf("error\n");
@


9.4
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 9.3 89/12/28 15:10:23 mike Locked $ (BRL)";
d922 2
a923 1
		db_ident( dbip, dbip->dbi_title, new_unit );
@


9.3
log
@Improved message details
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 9.2 89/10/10 16:30:02 mike Locked $ (BRL)";
a70 3
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */

d74 3
a76 1
f_itemair()
d82 1
a82 1
	if( (dp = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d86 1
a86 1
	ident = atoi( cmd_args[2] );
d89 2
a90 2
	if( numargs == 4 )  {
		air = atoi( cmd_args[3] );
d109 3
a111 1
f_mater()
d119 1
a119 1
	if( (dp = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d127 2
a128 2
	if( numargs >= 3 )  {
		if( strncmp( cmd_args[2], "del", 3 ) != 0 )  {
d224 3
a226 1
f_mirror()
d235 1
a235 1
	if( (proto = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d238 2
a239 2
	if( db_lookup( dbip,  cmd_args[2], LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( cmd_args[2] );
d243 1
a243 1
	if( strcmp( cmd_args[3], "x" ) == 0 )
d245 1
a245 1
	if( strcmp( cmd_args[3], "y" ) == 0 )
d247 1
a247 1
	if( strcmp( cmd_args[3], "z" ) == 0 )
d258 1
a258 1
		if( (dp = db_diradd( dbip,  cmd_args[2], -1, proto->d_len, DIR_SOLID )) == DIR_NULL )
d264 1
a264 1
			NAMEMOVE( cmd_args[2], record.a.a_name );
d275 1
a275 1
			NAMEMOVE( cmd_args[2], record.s.s_name );
d280 1
a280 1
			cmd_args[2], -1, proto->d_len,
d287 1
a287 1
		NAMEMOVE(cmd_args[2], record.c.c_name);
d305 1
a305 1
		(void)printf("%s: Cannot mirror\n",cmd_args[2]);
d312 1
a312 1
			cmd_args[2] );
d315 3
a317 3
	drawtree( dp );
	dmp->dmr_colorchange();		/* To color new solid */
	dmaflag = 1;
d323 3
a325 1
f_extrude()
d347 1
a347 1
	face = atoi( cmd_args[1] );
d350 1
a350 1
	dist = atof( cmd_args[2] );
d550 2
a551 4
	/* draw the new solid */
	illump = redraw( illump, &es_rec, es_mat );

	/* Update display information */
d559 3
a561 1
f_arbdef()
d569 2
a570 2
	if( db_lookup( dbip,  cmd_args[1] , LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( cmd_args[1] );
d575 1
a575 1
	rota = atof( cmd_args[2] ) * degtorad;
d578 1
a578 1
	fb = atof( cmd_args[3] ) * degtorad;
d580 1
a580 1
	if( (dp = db_diradd( dbip,  cmd_args[1], -1, 1, DIR_SOLID )) == DIR_NULL )
d583 1
a583 1
	NAMEMOVE( cmd_args[1], record.s.s_name );
d631 1
a631 1
			cmd_args[1] );
d634 3
a636 3
	drawtree( dp );
	dmp->dmr_colorchange();		/* To color new solid */
	dmaflag = 1;
d642 3
a644 1
f_edcomb()
d650 1
a650 1
	if( (dp = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d653 4
a656 4
	regionid = atoi( cmd_args[3] );
	air = atoi( cmd_args[4] );
	los = atoi( cmd_args[5] );
	mat = atoi( cmd_args[6] );
d664 1
a664 1
	if( cmd_args[2][0] == 'R' )
d678 3
a680 1
f_mirface()
d701 1
a701 1
	face = atoi( cmd_args[1] );
d708 1
a708 1
	if( strcmp( cmd_args[2], "x" ) == 0 )
d710 1
a710 1
	if( strcmp( cmd_args[2], "y" ) == 0 )
d712 1
a712 1
	if( strcmp( cmd_args[2], "z" ) == 0 )
d883 2
a884 4
	/* draw the new solid */
	illump = redraw( illump, &es_rec, es_mat );

	/* Update display information */
d894 3
a896 1
f_units()
d900 1
a900 1
	if( strcmp(cmd_args[1], "mm") == 0 ) 
d903 1
a903 1
	if( strcmp(cmd_args[1], "cm") == 0 ) 
d906 1
a906 1
	if( strcmp(cmd_args[1],"m")==0 || strcmp(cmd_args[1],"meters")==0 ) 
d909 1
a909 1
	if( strcmp(cmd_args[1],"in")==0 || strcmp(cmd_args[1],"inches")==0 ) 
d912 1
a912 1
	if( strcmp(cmd_args[1],"ft")==0 || strcmp(cmd_args[1],"feet")==0 ) 
d930 1
a930 1
	(void)printf("%s: unrecognized unit\n", cmd_args[1]);
d938 3
a940 1
f_title()
d946 2
a947 2
	for(i=1; i<numargs; i++) {
		(void)strcat(title, cmd_args[i]);
d971 4
a974 1
f_make()  {
d979 2
a980 2
	if( db_lookup( dbip,  cmd_args[1], LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( cmd_args[1] );
d995 1
a995 1
	if( strcmp( cmd_args[2], "arb8" ) == 0 )  {
d1009 1
a1009 1
	} else if( strcmp( cmd_args[2], "arb7" ) == 0 )  {
d1023 1
a1023 1
	} else if( strcmp( cmd_args[2], "arb6" ) == 0 )  {
d1037 1
a1037 1
	} else if( strcmp( cmd_args[2], "arb5" ) == 0 )  {
d1051 1
a1051 1
	} else if( strcmp( cmd_args[2], "arb4" ) == 0 )  {
d1065 1
a1065 1
	} else if( strcmp( cmd_args[2], "sph" ) == 0 )  {
d1071 1
a1071 1
	} else if( strcmp( cmd_args[2], "ell" ) == 0 )  {
d1077 1
a1077 1
	} else if( strcmp( cmd_args[2], "ellg" ) == 0 )  {
d1083 1
a1083 1
	} else if( strcmp( cmd_args[2], "tor" ) == 0 )  {
d1093 1
a1093 1
	} else if( strcmp( cmd_args[2], "tgc" ) == 0 )  {
d1101 1
a1101 1
	} else if( strcmp( cmd_args[2], "tec" ) == 0 )  {
d1109 1
a1109 1
	} else if( strcmp( cmd_args[2], "rec" ) == 0 )  {
d1117 1
a1117 1
	} else if( strcmp( cmd_args[2], "trc" ) == 0 )  {
d1125 1
a1125 1
	} else if( strcmp( cmd_args[2], "rcc" ) == 0 )  {
d1133 1
a1133 1
	} else if( strcmp( cmd_args[2], "ars" ) == 0 )  {
d1137 1
a1137 1
		(void)printf("make:  %s is not a known primitive\n", cmd_args[2]);
d1142 1
a1142 1
	if( (dp = db_diradd( dbip,  cmd_args[1], -1, 0, DIR_SOLID )) == DIR_NULL )
d1146 1
a1146 1
	NAMEMOVE( cmd_args[1], record.s.s_name );
d1148 1
d1150 1
a1150 3
	drawtree( dp );
	dmp->dmr_colorchange();		/* To color new solid */
	dmaflag = 1;
d1155 3
a1157 1
f_rot_obj()
d1196 3
a1198 3
	buildHrot(temp, atof(cmd_args[1])*degtorad,
			atof(cmd_args[2])*degtorad,
			atof(cmd_args[3])*degtorad );
d1211 3
a1213 1
f_sc_obj()
d1221 1
a1221 1
	if( atof(cmd_args[1]) <= 0.0 ) {
d1243 1
a1243 1
			incr[15] = 1.0 / (atof(cmd_args[1]) * modelchanges[15]);
d1248 2
a1249 2
			incr[0] = atof(cmd_args[1]) / acc_sc[0];
			acc_sc[0] = atof(cmd_args[1]);
d1254 2
a1255 2
			incr[5] = atof(cmd_args[1]) / acc_sc[1];
			acc_sc[1] = atof(cmd_args[1]);
d1260 2
a1261 2
			incr[10] = atof(cmd_args[1]) / acc_sc[2];
			acc_sc[2] = atof(cmd_args[1]);
d1277 3
a1279 1
f_tr_obj()
d1300 1
a1300 1
		new_vertex[i] = atof(cmd_args[i+1]) * local2base;
d1316 3
a1318 1
f_regdef()
d1322 1
a1322 1
	item_default = atoi(cmd_args[1]);
d1324 1
a1324 1
	if(numargs == 2)
d1327 1
a1327 1
	air_default = atoi(cmd_args[2]);
d1331 1
a1331 1
	if(numargs == 3)
d1334 1
a1334 1
	los_default = atoi(cmd_args[3]);
d1336 1
a1336 1
	if(numargs == 4)
d1339 1
a1339 1
	mat_default = atoi(cmd_args[4]);
d1349 3
a1351 1
f_edgedir()
d1374 3
a1376 3
	if( numargs == 3 ) {
		rot = atof( cmd_args[1] ) * degtorad;
		fb = atof( cmd_args[2] ) * degtorad;
d1384 1
a1384 1
			slope[i] = atof( cmd_args[i+1] );
@


9.2
log
@Eliminated es_m[]
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 9.1 89/05/19 06:01:52 mike Rel3_5 $ (BRL)";
d138 1
a138 1
	(void)printf("Material = %s\nMaterial?  (CR to skip) ", record.c.c_matname);
d151 1
a151 1
	(void)printf("Param = %s\nParameter string? (CR to skip) ", record.c.c_matparm);
@


9.1
log
@Release_3.5
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 8.9 89/05/11 21:41:42 phil Exp $ (BRL)";
d1159 1
d1250 1
d1283 1
d1331 1
a1331 1
	vect_t work;
d1354 3
a1356 3
		es_m[0] = cos(fb) * cos(rot);
		es_m[1] = cos(fb) * sin(rot);
		es_m[2] = sin(fb);
d1360 2
a1361 2
			/* put edge slope in es_m array */
			es_m[i] = atof( cmd_args[i+1] );
d1365 1
a1365 1
	if(MAGNITUDE(es_m) == 0) {
d1372 1
a1372 1
	editarb( work );
@


8.9
log
@db_diradd had the length and flags parameters backward
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 8.8 89/05/11 21:11:54 phil Locked $ (BRL)";
@


8.8
log
@save dbi_ units into local variables until we clean these up
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 8.7 89/05/08 21:45:17 phil Locked $ (BRL)";
d255 1
a255 1
		if( (dp = db_diradd( dbip,  cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d277 2
a278 1
			cmd_args[2], -1, record.c.c_flags == 'R' ?
d280 1
a280 2
				DIR_COMB,
			proto->d_len)
d575 1
a575 1
	if( (dp = db_diradd( dbip,  cmd_args[1], -1, DIR_SOLID, 1 )) == DIR_NULL )
d1128 1
a1128 1
	if( (dp = db_diradd( dbip,  cmd_args[1], -1, DIR_SOLID, 0 )) == DIR_NULL )
@


8.7
log
@fixed to use new db_conversions() routine to get non-mm scale factors
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 8.6 89/04/06 20:38:51 phil Locked $ (BRL)";
d909 4
@


8.6
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 8.5 89/01/18 01:49:01 mike Locked $ (BRL)";
d908 1
@


8.5
log
@Fixed "del" capability on material
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 8.4 89/01/16 22:51:38 mike Locked $ (BRL)";
d56 1
@


8.4
log
@drawHobj() --> drawtree()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 8.3 89/01/09 05:08:20 mike Locked $ (BRL)";
d141 1
a141 1
	if( strcmp(line, "del") == 0 || strcmp(line,"\"\"") == 0 )  {
d154 1
a154 1
	if( strcmp(line, "del") == 0 || strcmp(line,"\"\"") == 0 )  {
d173 1
a173 1
	if( strcmp(line, "del") == 0 || strcmp(line,"\"\"") == 0 ) {
@


8.3
log
@Fixed mater command to not always blast the previous color
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 8.2 88/12/06 00:56:05 mike Locked $ (BRL)";
d63 1
d311 1
a311 1
	drawHobj( dp, ROOT, 0, identity, 0 );
d628 1
a628 1
	drawHobj( dp, ROOT, 0, identity, 0 );
d1129 1
a1129 1
	drawHobj( dp, ROOT, 0, identity, 0 );
@


8.2
log
@Converted to new db_*() routines.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/chgmodel.c,v 1.2 88/10/23 13:55:37 mike Exp $ (BRL)";
d44 6
d106 1
a106 1
/* Usage:  mater name [del] */
d114 1
d138 3
a140 2
	(void)gets(line);
	if( strcmp(line, "del") == 0 || strcmp(line,"\"\"") == 0 )
d142 2
a143 1
	else if( line[0] != '\n' && line[0] != '\0' )
d146 1
d151 3
a153 2
	(void)gets(line);
	if( strcmp(line, "del") == 0 || strcmp(line,"\"\"") == 0 )
d155 5
a159 2
	else if( line[0] != '\n' && line[0] != '\0' )
		strncpy( record.c.c_matparm, line, sizeof(record.c.c_matparm)-1 );
d169 1
a169 1
	(void)printf("Color R G B (0..255)? (CR to skip) ");
d171 1
a171 1
	(void)gets(line);
d174 1
a174 2
	} else {
		sscanf(line, "%d %d %d", &r, &g, &b);
d179 3
d199 1
a199 1
	(void)gets(line);
@


8.1
log
@Release_3.0
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 7.6 88/08/20 06:47:26 phil Exp $ (BRL)";
d48 1
a49 1
#include "./objdir.h"
d75 1
a75 1
	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d85 1
a85 1
	db_getrec( dp, &record, 0 );
d96 1
a96 1
	db_putrec( dp, &record, 0 );
d109 1
a109 1
	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d112 1
a112 1
	db_getrec( dp, &record, 0 );
d199 1
a199 1
	db_putrec( dp, &record, 0 );
d214 1
a214 1
	if( (proto = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d217 1
a217 1
	if( lookup( cmd_args[2], LOOKUP_QUIET ) != DIR_NULL )  {
d233 1
a233 1
	db_getrec( proto, &record, 0 );
d237 1
a237 1
		if( (dp = dir_add( cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d239 1
a239 1
		db_alloc( dp, proto->d_len );
d244 1
a244 1
			db_putrec( dp, &record, 0 );
d246 1
a246 1
				db_getrec( proto, &record, i );
d249 1
a249 1
				db_putrec( dp, &record, i );
d255 1
a255 1
			db_putrec( dp, &record, 0 );
d258 1
a258 1
		if( (dp = dir_add(
d265 1
a265 1
		db_alloc( dp, proto->d_len );
d267 1
a267 1
		db_putrec(dp, &record, 0);
d273 1
a273 1
			db_getrec(proto, &record, i);
d281 1
a281 1
			db_putrec(dp, &record, i);
d546 1
a546 1
	if( lookup( cmd_args[1] , LOOKUP_QUIET ) != DIR_NULL )  {
d557 1
a557 1
	if( (dp = dir_add( cmd_args[1], -1, DIR_SOLID, 1 )) == DIR_NULL )
d559 1
a559 1
	db_alloc( dp, 1 );
d603 2
a604 2
	/* update objfd and draw new arb8 */
	db_putrec( dp, &record, 0 );
d625 1
a625 1
	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d633 1
a633 1
	db_getrec( dp, &record, 0 );
d647 1
a647 1
	db_putrec( dp, &record, 0 );
d890 1
a890 2
		dir_units( new_unit );
		localunit = new_unit;
d909 1
d911 1
a911 1
	cur_title[0] = '\0';
d913 2
a914 2
		(void)strcat(cur_title, cmd_args[i]);
		(void)strcat(cur_title, " ");
d917 2
a918 1
	dir_title();
d942 1
a942 1
	if( lookup( cmd_args[1], LOOKUP_QUIET ) != DIR_NULL )  {
d1105 1
a1105 1
	if( (dp = dir_add( cmd_args[1], -1, DIR_SOLID, 0 )) == DIR_NULL )
d1107 1
a1107 1
	db_alloc( dp, 1 );
d1110 1
a1110 1
	db_putrec( dp, &record, 0 );
@


7.6
log
@Hacked mater command.  You can now "del" material name, params, and color.
A color "override" flag is no longer needed.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 7.5 88/05/15 23:04:46 phil Locked $ (BRL)";
@


7.5
log
@lint fixes
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 7.4 88/01/26 06:02:25 mike Locked $ (BRL)";
d107 1
d127 2
d132 3
a134 1
	if( line[0] != '\n' && line[0] != '\0' )
d138 1
d142 3
a144 1
	if( line[0] != '\n' && line[0] != '\0' )
d147 1
d149 1
a149 1
		(void)printf("RGB Color = %d %d %d\n", 
d154 2
a155 2
		(void)printf("(No color specified)\n");
	(void)printf("Override material color (y|n|CR)[CR]? ");
d158 3
a160 4
	if( line[0] == 'y' )  {
		int r=0, g=0, b=0;
		(void)printf("R G B (0..255)? ");
		(void)gets(line);
a165 2
	} else if( line[0] == 'n' )  {
		record.c.c_override = 0;
d168 1
d175 1
a175 1
		(void)printf("inherit=0:  lower nodes (towards leaves) override\n");
d178 1
a178 1
		(void)printf("inherit=1:  higher nodes (towards root) override\n");
d181 1
a181 1
	(void)printf("Inheritance? (0|1|CR)[CR]? ");
@


7.4
log
@Reworked "mater" command.
new calling sequence for redraw()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 7.3 87/11/05 07:09:12 mike Locked $ (BRL)";
d59 1
d861 1
d899 1
d1347 1
@


7.3
log
@Changed to use rt_mat_dbmat and rt_dbmat_mat
to convert between database and internal formats.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 7.2 87/11/05 05:03:35 mike Locked $ (BRL)";
d99 1
a99 1
/* Usage:  mater name material */
d115 6
a120 2
	(void)printf("Was %s %s\n", record.c.c_matname, record.c.c_matparm);
	if( numargs <= 2 )  {
d122 8
a129 2
	} else {
		strncpy( record.c.c_matname, cmd_args[2],
d132 4
a135 3
		(void)printf("Parameter string? ");
		fflush(stdout);
		(void)gets(line);
d138 13
a150 2
		(void)printf("Override material color (y|n)[n]? ");
		fflush(stdout);
d152 7
a158 11
		if( line[0] == 'y' )  {
			int r,g,b;
			(void)printf("R G B (0..255)? ");
			scanf("%d %d %d", &r, &g, &b);
			record.c.c_rgb[0] = r;
			record.c.c_rgb[1] = g;
			record.c.c_rgb[2] = b;
			record.c.c_override = 1;
		} else {
			record.c.c_override = 0;
		}
d160 31
d520 1
a520 1
	illump = redraw( illump, &es_rec );
d849 1
a849 1
	illump = redraw( illump, &es_rec );
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 7.1 87/11/02 23:58:39 mike Rel $ (BRL)";
d214 2
d221 3
a223 2
			mat_mul(temp, mirmat, record.M.m_mat);
			mat_copy(record.M.m_mat, temp);
@


7.1
log
@Release 2.3
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 6.1 87/07/11 08:01:52 mike Rel $ (BRL)";
d44 1
a44 1
#include "./machine.h"	/* special copy */
d248 1
a248 1
	static float dist;
d483 1
a483 1
	float rota, fb;
d1243 1
a1243 1
	FAST float rot, fb;
@


6.1
log
@Release 2.0
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 5.1 87/06/24 22:17:57 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 4.2 87/02/13 00:05:35 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 4.1 86/12/29 03:19:15 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.18 86/12/03 18:33:14 mike Exp $ (BRL)";
@


2.18
log
@More conservative use of strings.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.17 86/09/09 22:03:12 mike Exp $ (BRL)";
@


2.17
log
@Dender:  relaxed error check for ARB6.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.16 86/08/12 06:46:51 mike Exp $ (BRL)";
d120 1
a120 1
			sizeof(record.c.c_matname));
d125 1
a125 1
		strncpy( record.c.c_matparm, line, sizeof(record.c.c_matparm) );
@


2.16
log
@Changed #includes for CC -I../h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.15 86/06/12 00:08:20 mike Exp $ (BRL)";
d615 2
a616 2
	if( face < 1000 || face > 9999 ) {
		(void)printf("ERROR: face must be 4 points\n");
@


2.15
log
@Added a printf.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.14 86/03/14 20:41:03 mike Exp $ (BRL)";
d45 7
a51 7
#include "../h/vmath.h"
#include "../h/db.h"
#include "sedit.h"
#include "ged.h"
#include "objdir.h"
#include "solid.h"
#include "dm.h"
@


2.14
log
@Added support for the new spline format.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.13 86/03/10 21:37:49 mike Exp $ (BRL)";
d115 1
@


2.13
log
@Latest revisions from Keith, including lots of new commands
and one-axis scaling.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.12 86/02/17 17:01:58 mike Exp $ (BRL)";
d177 1
a177 2
		record.u_id == ID_ARS_A ||
		record.u_id == ID_B_SPL_HEAD
a190 11
				db_putrec( dp, &record, i );
			}
		} else if( record.u_id == ID_B_SPL_HEAD )  {
			NAMEMOVE( cmd_args[2], record.d.d_name );
			db_putrec( dp, &record, 0 );
			for( i = 1; i < proto->d_len; i++ ) {
				db_getrec( proto, &record, i );
				if( record.u_id != ID_B_SPL_CTL )
					continue;
				for( j = k; j < 24; j += 3)
					record.l.l_pts[j] *= -1.0;
@


2.12
log
@Added mater command, changed order of args to edcomb command.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.11 85/09/27 19:09:58 mike Exp $ (BRL)";
d1118 1
a1118 1
/* allow precise changes to object scaling */
d1125 1
a1125 1
	if( not_state( ST_O_EDIT, "Object Scale" ) )
d1134 1
a1134 2
		/* Put in object scale mode */
		dmp->dmr_light( LIGHT_ON, BE_O_SCALE );
d1137 3
d1144 28
a1171 1
	incr[15] = 1.0 / (atof(cmd_args[1]) * modelchanges[15]);
@


2.11
log
@KAA new code to do what user intended.
@
text
@d10 1
a10 1
 *	f_modify	add/modify material code and los percent
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.10 85/09/14 05:33:55 mike Exp $ (BRL)";
d98 2
a99 2
/* Add/modify material code and los percent of a region */
/* Format: M region mat los	*/
d101 1
a101 1
f_modify()
d104 1
a104 1
	register int mat, los;
a109 4
	mat = los = 0;
	mat = atoi( cmd_args[2] );
	los = atoi( cmd_args[3] );
	/* Should check that los is in valid range */
d115 25
a139 3
	if( record.c.c_flags != 'R' )  {
		(void)printf("%s: not a region\n", dp->d_namep );
		return;
a140 2
	record.c.c_material = mat;
	record.c.c_los = los;
d568 1
a568 1
/* Format: edcomb combname flag item air mat los	*/
d574 1
a574 1
	int ident, air, mat, los;
d579 1
a579 2
	ident = air = mat = los = 0;
	ident = atoi( cmd_args[3] );
d581 2
a582 2
	mat = atoi( cmd_args[5] );
	los = atoi( cmd_args[6] );
d594 1
a594 1
	record.c.c_regionid = ident;
d596 1
a597 1
	record.c.c_los = los;
d1187 1
a1187 1
/* Change the default region ident codes: item air mat los
d1206 1
a1206 1
	mat_default = atoi(cmd_args[3]);
d1211 1
a1211 1
	los_default = atoi(cmd_args[4]);
@


2.10
log
@Lint-inspired cleanup.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.9 85/09/12 00:17:12 mike Exp $ (BRL)";
d1061 5
a1065 2
		(void)printf("Not in object rotate mode\n");
		return;
d1113 2
a1114 2
	if(movedir != SARROW) {
		(void)printf("Not in object scale mode\n");
d1118 8
d1151 6
a1156 12
	if(movedir & (RARROW|UARROW)) {
		for(i=0; i<3; i++) {
			new_vertex[i] = atof(cmd_args[i+1]) * local2base;
		}
		MAT4X3PNT(model_sol_pt, es_mat, es_rec.s.s_values);
		MAT4X3PNT(ed_sol_pt, modelchanges, model_sol_pt);
		VSUB2(model_incr, new_vertex, ed_sol_pt);
		MAT_DELTAS(incr, model_incr[0], model_incr[1], model_incr[2]);
		mat_copy(old,modelchanges);
		mat_mul(modelchanges, incr, old);
		new_mats();
		return;
d1158 12
a1169 1
	(void)printf("Not in object translate mode\n");
a1281 1

@


2.9
log
@Kermit's change to prevent core dumps.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.8 85/08/07 05:16:47 mike Exp $ (BRL)";
d354 1
a354 1
		ext4to6(pt[0], pt[1], pt[2], dist, &lsolid);
d444 1
a444 1
		if(faces[es_type-4][i*4] == -1)
d446 3
a448 3
		pt[0] = faces[es_type-4][i*4];
		pt[1] = faces[es_type-4][i*4+1];
		pt[2] = faces[es_type-4][i*4+2];
d451 1
a451 1
				pt[0]+1,pt[1]+1,pt[2]+1,faces[es_type-4][i*4+3]);
d774 1
a774 1
		if(faces[es_type-4][i*4] == -1)
d776 3
a778 3
		pt[0] = faces[es_type-4][i*4];
		pt[1] = faces[es_type-4][i*4+1];
		pt[2] = faces[es_type-4][i*4+2];
d781 1
a781 1
				pt[0]+1,pt[1]+1,pt[2]+1,faces[es_type-4][i*4+3]);
d1192 1
a1192 1
	int i, point;
d1194 1
a1194 1
	float rot, fb;
d1243 1
a1243 1
ext4to6(pt1, pt2, pt3, distance, sp)
d1245 1
a1245 2
float distance;
struct solidrec *sp;
d1247 2
a1249 3
	static struct solidrec tmp;
	int i;

a1264 2

	return;
@


2.8
log
@Changed to use common ../h/vmath.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.7 85/07/30 01:17:07 mike Exp $ (BRL)";
d873 1
d884 5
@


2.7
log
@Change to support new ARB editing.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.6 85/06/06 22:32:48 mike Exp $ (BRL)";
d41 5
a45 4
#include	<math.h>
#include	<signal.h>
#include	<stdio.h>
#include "ged_types.h"
a51 1
#include "../h/vmath.h"
@


2.6
log
@KAA, added f_edgedir() support
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.5 85/05/29 15:04:35 mike Exp $ (BRL)";
d253 3
a255 3
	face = atoi( cmd_args[1] );
	if( face < 1000 || face > 9999 ) {
		(void)printf("ERROR: face must be 4 points\n");
d258 3
a266 2
	newedge = 1;

d273 16
a288 6
	pt[0] = face / 1000;
	i = face - (pt[0]*1000);
	pt[1] = i / 100;
	i = i - (pt[1]*100);
	pt[2] = i / 10;
	pt[3] = i - (pt[2]*10);
d293 14
a306 6
	 *       24         1234
	 *     1680         5678
	 *      252         2367
	 *      160         1548
	 *      672         4378
	 *       60         1256
d311 5
a315 1
		--pt[i];
d321 1
d323 1
a323 1
	if( (j = plane( pt[0], pt[1], pt[2], pt[3], &lsolid )) >= 0 )  {
d329 1
a329 1
		es_plant[i] *= dist;
d335 7
d346 1
a346 1
				&es_plant[0]);
d350 11
d366 1
a366 1
				&es_plant[0] );
d371 1
d374 1
a374 1
			&es_plant[0] );
d377 1
a377 1
			&es_plant[0] );
d380 1
a380 1
			&es_plant[0] );
d383 1
a383 1
			&es_plant[0] );
d387 1
d390 1
a390 1
			&es_plant[0] );
d393 1
a393 1
			&es_plant[0] );
d396 1
a396 1
			&es_plant[0] );
d399 1
a399 1
			&es_plant[0] );
d405 1
a405 1
			&es_plant[0] );
d408 1
a408 1
			&es_plant[0] );
d411 1
a411 1
			&es_plant[0] );
d414 1
a414 1
			&es_plant[0] );
d420 1
a420 1
			&es_plant[0] );
d423 1
a423 1
			&es_plant[0] );
d426 1
a426 1
			&es_plant[0] );
d429 1
a429 1
			&es_plant[0] );
d432 5
d442 14
a491 4
	/* copy arb8 to the new name */
	if( (dp = lookup( "arb8", LOOKUP_NOISY )) == DIR_NULL )
		return;
	db_getrec( dp, &record, 0 );
d496 3
d505 4
a508 4
	/* calculate normal vector (length = .5) defined by rot,fb */
	norm[0] = cos(fb) * cos(rota) * -0.5;
	norm[1] = cos(fb) * sin(rota) * -0.5;
	norm[2] = sin(fb) * -0.5;
d523 2
a524 2
	/* create new rpp 5x5x.5 */
	/* the 5x5 faces are in rot,fb plane */
d527 2
d605 5
d637 15
a651 6
	pt[0] = face / 1000;
	i = face - (pt[0]*1000);
	pt[1] = i / 100;
	i = i - (pt[1]*100);
	pt[2] = i / 10;
	pt[3] = i - (pt[2]*10);
d656 8
a663 6
	 *       24         1234
	 *     1680         5678
	 *      252         2367
	 *      160         1548
	 *      672         4378
	 *       60         1256
d668 1
a668 1
		--pt[i];
d679 4
d701 1
d717 1
d762 5
d772 14
d1199 1
a1199 1
		(void)printf("Edgeslope: solid type must be an ARB\n");
a1202 8
	VMOVE(work, &es_rec.s.s_values[0]);
	if( (point = es_menu / 10 - 1) ) {
		VADD2(work, &es_rec.s.s_values[0], &es_rec.s.s_values[point*3]);
	}

	newedge = 1;
	editarb( work );

d1227 1
d1232 34
@


2.5
log
@Added calls to colorchange, modified MAKE command slightly.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.4 85/05/07 23:55:31 mike Exp $ (BRL)";
d1071 65
@


2.4
log
@KAA f_regdef() added.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.3 85/03/15 05:02:51 mike Exp $ (BRL)";
d230 1
d483 1
d784 10
a793 10
			-toViewcenter[MDX] +254,
			-toViewcenter[MDY] -254,
			-toViewcenter[MDZ] -254 );
		VSET( &record.s.s_values[1*3],  0, 508, 0 );
		VSET( &record.s.s_values[2*3],  0, 508, 508 );
		VSET( &record.s.s_values[3*3],  0, 0, 508 );
		VSET( &record.s.s_values[4*3],  -508, 0, 0 );
		VSET( &record.s.s_values[5*3],  -508, 508, 0 );
		VSET( &record.s.s_values[6*3],  -508, 508, 508 );
		VSET( &record.s.s_values[7*3],  -508, 0, 508  );
d798 10
a807 10
			-toViewcenter[MDX] +254,
			-toViewcenter[MDY] -254,
			-toViewcenter[MDZ] -127 );
		VSET( &record.s.s_values[1*3],  0, 508, 0 );
		VSET( &record.s.s_values[2*3],  0, 508, 508 );
		VSET( &record.s.s_values[3*3],  0, 0, 254 );
		VSET( &record.s.s_values[4*3],  -508, 0, 0 );
		VSET( &record.s.s_values[5*3],  -508, 508, 0 );
		VSET( &record.s.s_values[6*3],  -508, 508, 254 );
		VSET( &record.s.s_values[7*3],  -508, 0, 0  );
d812 10
a821 10
			-toViewcenter[MDX] +254,
			-toViewcenter[MDY] -254,
			-toViewcenter[MDZ] -254 );
		VSET( &record.s.s_values[1*3],  0, 508, 0 );
		VSET( &record.s.s_values[2*3],  0, 508, 508 );
		VSET( &record.s.s_values[3*3],  0, 0, 508 );
		VSET( &record.s.s_values[4*3],  -508, 254, 0 );
		VSET( &record.s.s_values[5*3],  -508, 254, 0 );
		VSET( &record.s.s_values[6*3],  -508, 254, 508 );
		VSET( &record.s.s_values[7*3],  -508, 254, 508  );
d826 10
a835 10
			-toViewcenter[MDX] +254,
			-toViewcenter[MDY] -254,
			-toViewcenter[MDZ] -254 );
		VSET( &record.s.s_values[1*3],  0, 508, 0 );
		VSET( &record.s.s_values[2*3],  0, 508, 508 );
		VSET( &record.s.s_values[3*3],  0, 0, 508 );
		VSET( &record.s.s_values[4*3],  -508, 254, 254 );
		VSET( &record.s.s_values[5*3],  -508, 254, 254 );
		VSET( &record.s.s_values[6*3],  -508, 254, 254 );
		VSET( &record.s.s_values[7*3],  -508, 254, 254  );
d840 10
a849 10
			-toViewcenter[MDX] +254,
			-toViewcenter[MDY] -254,
			-toViewcenter[MDZ] -254 );
		VSET( &record.s.s_values[1*3],  0, 508, 0 );
		VSET( &record.s.s_values[2*3],  0, 508, 508 );
		VSET( &record.s.s_values[3*3],  0, 508, 508 );
		VSET( &record.s.s_values[4*3],  -508, 508, 0 );
		VSET( &record.s.s_values[5*3],  -508, 508, 0 );
		VSET( &record.s.s_values[6*3],  -508, 508, 0 );
		VSET( &record.s.s_values[7*3],  -508, 508, 0  );
d853 3
a855 3
		VSET( &record.s.s_values[1*3], 127, 0, 0 );	/* A */
		VSET( &record.s.s_values[2*3], 0, 127, 0 );	/* B */
		VSET( &record.s.s_values[3*3], 0, 0, 127 );	/* C */
d859 3
a861 3
		VSET( &record.s.s_values[1*3], 127, 0, 0 );	/* A */
		VSET( &record.s.s_values[2*3], 0, 63.5, 0 );	/* B */
		VSET( &record.s.s_values[3*3], 0, 0, 63.5 );	/* C */
d865 3
a867 3
		VSET( &record.s.s_values[1*3], 254, 0, 0 );	/* A */
		VSET( &record.s.s_values[2*3], 0, 127, 0 );	/* B */
		VSET( &record.s.s_values[3*3], 0, 0, 63.5 );	/* C */
d871 7
a877 7
		VSET( &record.s.s_values[1*3], 127, 0, 0 );	/* N with mag = r2 */
		VSET( &record.s.s_values[2*3], 0, 254, 0 );	/* A == r1 */
		VSET( &record.s.s_values[3*3], 0, 0, 254 );	/* B == r1 */
		VSET( &record.s.s_values[4*3], 0, 127, 0 );	/* A == r1-r2 */
		VSET( &record.s.s_values[5*3], 0, 0, 127 );	/* B == r1-r2 */
		VSET( &record.s.s_values[6*3], 0, 381, 0 );	/* A == r1+r2 */
		VSET( &record.s.s_values[7*3], 0, 0, 381 );	/* B == r1+r2 */
d881 5
a885 5
		VSET( &record.s.s_values[1*3],  0, 0, 508 );
		VSET( &record.s.s_values[2*3],  127, 0, 0 );
		VSET( &record.s.s_values[3*3],  0, 63.5, 0 );
		VSET( &record.s.s_values[4*3],  63.5, 0, 0 );
		VSET( &record.s.s_values[5*3],  0, 127, 0 );
d889 4
a892 4
		VSET( &record.s.s_values[1*3],  0, 0, 508 );
		VSET( &record.s.s_values[2*3],  127, 0, 0 );
		VSET( &record.s.s_values[3*3],  0, 63.5, 0 );
		VSET( &record.s.s_values[4*3],  63.5, 0, 0 );
d897 5
a901 5
		VSET( &record.s.s_values[1*3],  0, 0, 508 );
		VSET( &record.s.s_values[2*3],  127, 0, 0 );
		VSET( &record.s.s_values[3*3],  0, 63.5, 0 );
		VSET( &record.s.s_values[4*3],  127, 0, 0 );
		VSET( &record.s.s_values[5*3],  0, 63.5, 0 );
d905 5
a909 5
		VSET( &record.s.s_values[1*3],  0, 0, 508 );
		VSET( &record.s.s_values[2*3],  127, 0, 0 );
		VSET( &record.s.s_values[3*3],  0, 127, 0 );
		VSET( &record.s.s_values[4*3],  63.5, 0, 0 );
		VSET( &record.s.s_values[5*3],  0, 63.5, 0 );
d913 5
a917 5
		VSET( &record.s.s_values[1*3],  0, 0, 508 );
		VSET( &record.s.s_values[2*3],  127, 0, 0 );
		VSET( &record.s.s_values[3*3],  0, 127, 0 );
		VSET( &record.s.s_values[4*3],  127, 0, 0 );
		VSET( &record.s.s_values[5*3],  0, 127, 0 );
d935 1
@


2.3
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.2 85/03/12 04:06:28 mike Exp $ (BRL)";
d1040 27
@


2.2
log
@Paul Stay's Spline code
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 2.1 85/03/11 23:53:48 mike Prod $ (BRL)";
d229 1
a229 1
	drawHobj( dp, ROOT, 0, identity );
d481 1
a481 1
	drawHobj( dp, ROOT, 0, identity );
d932 1
a932 1
	drawHobj(dp, ROOT, 0, identity);
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 1.11 85/03/08 20:53:24 mike Exp $ (BRL)";
d133 1
d135 1
d137 2
a138 3
	struct directory *proto;
	int i, j, k, ngran, nmemb;
	mat_t mirmat, temp;
d160 4
a163 1
	if( record.u_id == ID_SOLID || record.u_id == ID_ARS_A )  {
a170 1
			ngran = record.a.a_totlen;
d172 2
a173 2
			for( i = 0; i < ngran; i++ )  {
				db_getrec( proto, &record, i+1 );
d176 1
a176 1
				db_putrec( dp, &record, i+1 );
d178 11
a188 1

d195 7
a201 8
	}
	else
	if( record.u_id == ID_COMB ) {
		nmemb = record.c.c_length;
		if( (dp = dir_add(cmd_args[2],
				-1,
				record.c.c_flags == 'R' ? DIR_COMB|DIR_REGION : DIR_COMB,
				proto->d_len)) == DIR_NULL )
d208 2
a209 2
		for(i=0; i<nmemb; i++) {
			db_getrec(proto, &record, i+1);
d211 1
a211 2
				(void)printf("copied only %d of %d members\n",i+1,nmemb);
				(void)putchar( 7 );
d216 1
a216 1
			db_putrec(dp, &record, i+1);
d218 1
a218 2
	}
	else {
@


1.11
log
@USNA changes which formalize state changes.
@
text
@d9 14
d24 5
a28 1
 * Source -
d32 4
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 1.10 85/02/14 00:58:50 mike Exp $ (BRL)";
d45 1
a45 1
#include "db.h"
d48 1
a48 1
#include "dir.h"
d51 1
a51 1
#include "vmath.h"
d56 1
d730 2
a731 2
		strcat(cur_title, cmd_args[i]);
		strcat(cur_title, " ");
d773 2
a774 2
			-toViewcenter[MDX] -254,
			-toViewcenter[MDX] -254 );
d787 2
a788 2
			-toViewcenter[MDX] -254,
			-toViewcenter[MDX] -127 );
d801 2
a802 2
			-toViewcenter[MDX] -254,
			-toViewcenter[MDX] -254 );
d815 2
a816 2
			-toViewcenter[MDX] -254,
			-toViewcenter[MDX] -254 );
d829 2
a830 2
			-toViewcenter[MDX] -254,
			-toViewcenter[MDX] -254 );
d910 1
a910 1
		printf("make:  %s is not a known primitive\n", cmd_args[2]);
@


1.10
log
@Removed the (now redundant) "done" messages.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 1.9 85/02/14 00:21:03 mike Exp $ (BRL)";
d212 1
a212 2
	if( state != ST_S_EDIT )  {
		state_err( "Extrude" );
d214 1
a214 1
	}
d499 1
a499 2
	if( state != ST_S_EDIT )  {
		state_err( "Mirface" );
d501 1
a501 1
	}
d910 1
a910 2
	if(state != ST_O_EDIT) {
		state_err("Object Rotation");
a911 1
	}
d960 1
a960 2
	if(state != ST_O_EDIT) {
		state_err("Object Scale");
a961 1
	}
d987 1
a987 2
	if(state != ST_O_EDIT) {
		state_err("Object Translation");
a988 1
	}
@


1.9
log
@Latest KAA version.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 1.8 85/02/02 01:39:46 mike Exp $ (BRL)";
a72 1
	(void)printf("done\n");
a102 1
	(void)printf("done\n");
a197 1
	(void)printf("done\n");
a450 1
	(void)printf("done\n");
a485 1
	(void)printf("done\n");
a902 1
	(void)printf("done\n");
@


1.8
log
@Added (partial) MAKE command.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 1.7 85/02/01 01:45:46 mike Exp $ (BRL)";
d108 1
a108 1
/* Format: m oldsolid newsolid axis	*/
d115 2
a116 1
	int i, j, k, ngran;
d138 51
a188 2
	if( record.u_id != ID_SOLID && record.u_id != ID_ARS_A )  {
		(void)printf("%s: not a solid\n", proto->d_namep );
a190 3
	if( (dp = dir_add( cmd_args[2], -1, DIR_SOLID, 0 )) == DIR_NULL )
		return;
	db_alloc( dp, proto->d_len );
a191 18
	/* create mirror image */
	if( record.u_id == ID_ARS_A )  {
		NAMEMOVE( cmd_args[2], record.a.a_name );
		ngran = record.a.a_totlen;
		db_putrec( dp, &record, 0 );
		for( i = 0; i < ngran; i++ )  {
			db_getrec( proto, &record, i+1 );
			for( j = k; j < 24; j += 3 )
				record.b.b_values[j] *= -1.0;
			db_putrec( dp, &record, i+1 );
		}

	} else  {
		for( i = k; i < 24; i += 3 )
			record.s.s_values[i] *= -1.0;
		NAMEMOVE( cmd_args[2], record.s.s_name );
		db_putrec( dp, &record, 0 );
	}
d751 1
a751 1
	/* make name <arb8|ellg|tor|tgc> */
d756 66
a821 10
			-toViewcenter[MDX] +1,
			-toViewcenter[MDX] -1,
			-toViewcenter[MDX] -1 );
		VSET( &record.s.s_values[1*3],  0, 2, 0 );
		VSET( &record.s.s_values[2*3],  0, 2, 2 );
		VSET( &record.s.s_values[3*3],  0, 0, 2 );
		VSET( &record.s.s_values[4*3],  -2, 0, 0 );
		VSET( &record.s.s_values[5*3],  -2, 2, 0 );
		VSET( &record.s.s_values[6*3],  -2, 2, 2 );
		VSET( &record.s.s_values[7*3],  -2, 0, 2  );
d825 9
a833 3
		VSET( &record.s.s_values[1*3], 1, 0, 0 );	/* A */
		VSET( &record.s.s_values[2*3], 0, 1, 0 );	/* B */
		VSET( &record.s.s_values[3*3], 0, 0, 1 );	/* C */
d837 3
a839 1
		printf("unimplemented\n"); return;
d842 8
a849 1
		printf("unimplemented\n"); return;
d852 41
a892 1
		printf("unimplemented\n"); return;
d905 3
@


1.7
log
@Typos.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: chgmodel.c,v 1.6 85/02/01 00:49:20 mike Exp $ (BRL)";
d652 1
a652 1
	if( strcmp(cmd_args[1], "m") == 0 ) 
d655 1
a655 1
	if( strcmp(cmd_args[1], "in") == 0 ) 
d658 1
a658 1
	if( strcmp(cmd_args[1], "ft") == 0 ) 
d672 2
a673 3
	(void)printf("%s: unrecognized unit\n");
	(void)printf("<mm|cm|m|in|ft> are only recognized units\n");
	return;
d709 57
a765 1
	printf("unimplemented\n");
@


1.6
log
@Keith's global/local units additions
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d35 1
a35 1
static void	aexists();
d695 1
a695 1
static void
@


1.5
log
@Keith's added mirface command
@
text
@d4 4
d10 4
a13 1
 * The U. S. Army Ballistic Research Laboratory
d15 3
d35 2
a41 165
static void	aexists();

/* Rename an object */
/* Format: n oldname newname	*/
void
f_name()
{
	register struct directory *dp;
	union record record;

	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
		return;

	if( lookup( cmd_args[2], LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( cmd_args[2] );
		return;
	}

	dp->d_namep = strdup( cmd_args[2] );
	db_getrec( dp, &record, 0 );

	NAMEMOVE( cmd_args[2], record.c.c_name );
	db_putrec( dp, &record, 0 );
	(void)printf("done\n");
}

/* Copy a solid */
/* Format: c oldname newname	*/
void
f_copy()
{
	register struct directory *proto;
	register struct directory *dp;
	union record record;
	int i, ngran;

	if( (proto = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
		return;

	if( lookup( cmd_args[2], LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( cmd_args[2] );
		return;
	}

	db_getrec( proto, &record, 0 );

	if( record.u_id != ID_SOLID && record.u_id != ID_ARS_A ) {
		(void)printf("%s: not a solid\n", proto->d_namep );
		return;
	}

	/*
	 * Update the in-core directory
	 */
	if( (dp = dir_add( cmd_args[2], -1, DIR_SOLID, 0 )) == DIR_NULL )
		return;
	db_alloc( dp, proto->d_len );

	/*
	 * Update the disk record
	 */
	if(record.u_id == ID_ARS_A)  {
		NAMEMOVE( cmd_args[2], record.a.a_name );
		ngran = record.a.a_totlen;
		db_putrec( dp, &record, 0 );

		/* Process the rest of the ARS (b records)  */
		for( i = 0; i < ngran; i++ )  {
			db_getrec( proto, &record, i+1 );
			if( i == 0 )  {
				record.b.b_values[0] = -toViewcenter[MDX];
				record.b.b_values[1] = -toViewcenter[MDY];
				record.b.b_values[2] = -toViewcenter[MDZ];
			}
			db_putrec( dp, &record, i+1 );
		}
	}  else  {
		NAMEMOVE( cmd_args[2], record.s.s_name );
		record.s.s_values[0] = -toViewcenter[MDX];
		record.s.s_values[1] = -toViewcenter[MDY];
		record.s.s_values[2] = -toViewcenter[MDZ];
		db_putrec( dp, &record, 0 );
	}
	(void)printf("done\n");
}

/* Create an instance of something */
/* Format: i object combname instname [op]	*/
void
f_instance()
{
	register struct directory *dp;
	char oper;

	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
		return;

	oper = UNION;
	if( numargs == 5 )
		oper = cmd_args[4][0];
	if(oper != UNION && oper != SUBTRACT &&	oper != INTERSECT) {
		(void)printf("bad operation: %c\n", oper );
		return;
	}
	if( combadd( dp, cmd_args[2], cmd_args[3], '\0', oper, 0, 0 ) ==
	    DIR_NULL )
		return;
	(void)printf("done\n");
}

/* add solids to a region or create the region */
/* and then add solids */
/* Format: r regionname opr1 sol1 opr2 sol2 ... oprn soln */
void
f_region()
{
	register struct directory *dp;
	union record record;
	int i;
	int ident, air;
	char oper;

	ident = air = 0;
	/* Check for even number of arguments */
	if( numargs & 01 )  {
		printf("error in number of args!\n");
		return;
	}
	/* Get operation and solid name for each solid */
	for( i = 2; i < numargs; i += 2 )  {
		if( cmd_args[i][1] != '\0' )  {
			(void)printf("bad operation: %s skip member: %s\n",
				cmd_args[i], cmd_args[i+1] );
			continue;
		}
		oper = cmd_args[i][0];
		if( (dp = lookup( cmd_args[i + 1], LOOKUP_NOISY )) == DIR_NULL )  {
			(void)printf("skipping %s\n", cmd_args[i + 1] );
			continue;
		}

		if(oper != UNION && oper != SUBTRACT &&	oper != INTERSECT) {
			(void)printf("bad operation: %c skip member: %s\n",
				oper, dp->d_namep );
			continue;
		}

		db_getrec( dp, &record, 0 );
		if( record.u_id == ID_COMB ) {
			if( record.c.c_flags == 'R' ) {
				(void)printf(
				     "Note: %s is a region\n",
				     dp->d_namep );
			}
		}

		if( combadd( dp, cmd_args[1], (char *)NULL, 'r', oper, ident,
							air ) == DIR_NULL )  {
			(void)printf("error in combadd\n");
			return;
		}
	}
	(void)printf("done\n");
}

a106 40
/* Remove an object or several from the description */
/* Format: k object1 object2 .... objectn	*/
void
f_kill()
{
	register struct directory *dp;
	register int i;

	for( i = 1; i < numargs; i++ )  {
		if( (dp = lookup( cmd_args[i], LOOKUP_NOISY )) != DIR_NULL )  {
			eraseobj( dp );
			db_delete( dp );
			dir_delete( dp );
		}
	}
	dmaflag = 1;
	(void)printf("done\n");
}

/* Grouping command */
/* Format: g groupname object1 object2 .... objectn	*/
void
f_group()
{
	register struct directory *dp;
	register int i;

	/* get objects to add to group */
	for( i = 2; i < numargs; i++ )  {
		if( (dp = lookup( cmd_args[i], LOOKUP_NOISY)) != DIR_NULL )  {
			if( combadd( dp, cmd_args[1], (char *)NULL, 'g',
				UNION, 0, 0) == DIR_NULL )
				return;
		}
		else
			(void)printf("skip member %s\n", cmd_args[i]);
	}
	(void)printf("done\n");
}

d138 1
a138 1
		(void)printf("%s: not a solid\n", dp->d_namep );
a183 1
	static vect_t work;
d202 2
a203 1
	dist *= es_mat[15];
a347 38
/* Delete members of a combination */
/* Format: D comb memb1 memb2 .... membn	*/
void
f_delmem()
{
	register struct directory *dp;
	register int i, rec;
	union record record;

	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
		return;

	/* Examine all the Member records, one at a time */
	for( rec = 1; rec < dp->d_len; rec++ )  {
		db_getrec( dp, &record, rec );
top:
		/* Compare this member to each command arg */
		for( i = 2; i < numargs; i++ )  {
			if( strcmp( cmd_args[i], record.M.m_instname ) != 0 &&
			    strcmp( cmd_args[i], record.M.m_brname ) != 0 )
				continue;
			printf("deleting member %s\n", cmd_args[i] );

			/* If deleting last member, just truncate */
			if( rec == dp->d_len-1 ) {
				db_trunc(dp, 1);
				continue;
			}

			db_getrec( dp, &record, dp->d_len-1 );	/* last one */
			db_putrec( dp, &record, rec );		/* xch */
			db_trunc( dp, 1 );
			goto top;
		}
	}
	(void)printf("done\n");
}

a472 1
	static float dist;
d638 7
d646 48
d710 113
@


1.4
log
@pre-Keith version
@
text
@d395 3
d563 7
d694 176
@


1.3
log
@Vector lists saved, multiple display managers supported.
@
text
@d13 1
a13 1
#include "3d.h"
@


1.2
log
@Minor cleanups
@
text
@d40 1
a40 1
	if( (dp = lookup( cmd_args[1], NOISY )) == DIR_NULL )
d43 1
a43 1
	if( lookup( cmd_args[2], QUIET ) != DIR_NULL )  {
d66 1
a66 1
	if( (proto = lookup( cmd_args[1], NOISY )) == DIR_NULL )
d69 1
a69 1
	if( lookup( cmd_args[2], QUIET ) != DIR_NULL )  {
d124 1
a124 1
	if( (dp = lookup( cmd_args[1], NOISY )) == DIR_NULL )
d166 1
a166 1
		if( (dp = lookup( cmd_args[i + 1], NOISY )) == DIR_NULL )  {
d204 1
a204 1
	if( (dp = lookup( cmd_args[1], NOISY )) == DIR_NULL )
d238 1
a238 1
	if( (dp = lookup( cmd_args[1], NOISY )) == DIR_NULL )
d269 1
a269 1
		if( (dp = lookup( cmd_args[i], NOISY )) != DIR_NULL )  {
d289 1
a289 1
		if( (dp = lookup( cmd_args[i], NOISY)) != DIR_NULL )  {
d310 1
a310 1
	if( (proto = lookup( cmd_args[1], NOISY )) == DIR_NULL )
d313 1
a313 1
	if( lookup( cmd_args[2], QUIET ) != DIR_NULL )  {
d547 1
a547 1
	if( (dp = lookup( cmd_args[1], NOISY )) == DIR_NULL )
d580 1
a580 1
	if( lookup( cmd_args[1] , QUIET ) != DIR_NULL )  {
d592 1
a592 1
	if( (dp = lookup( "arb8", NOISY )) == DIR_NULL )
d658 1
a658 1
	if( (dp = lookup( cmd_args[1], NOISY )) == DIR_NULL )
@


1.1
log
@Initial revision
@
text
@d367 2
a368 2
/* Face command - project an arb face */
/* Format: f face distance	*/
d370 1
a370 1
f_face()
d372 4
a375 1
	static int i, j, face, pt[4], prod;
d378 1
d381 1
a381 1
		state_err( "Face Project" );
d385 1
a385 1
		(void)printf("ERROR: solid type must be generalized arb8\n");
d397 2
a398 2
	/* convert to point notation */
	VMOVE( &work[0], &es_rec.s.s_values[0] );
d400 1
a400 1
		VADD2(&es_rec.s.s_values[i], &es_rec.s.s_values[i], work);
d430 1
a430 1
	if( (j = plane( pt[0], pt[1], pt[2], pt[3], &es_rec.s )) >= 0 )  {
d444 2
a445 2
			VADD2( &es_rec.s.s_values[j*3],
				&es_rec.s.s_values[i*3],
d453 2
a454 2
			VADD2( &es_rec.s.s_values[i*3],
				&es_rec.s.s_values[j*3],
d460 2
a461 2
		VADD2( &es_rec.s.s_values[9],
			&es_rec.s.s_values[0],
d463 2
a464 2
		VADD2( &es_rec.s.s_values[6],
			&es_rec.s.s_values[3],
d466 2
a467 2
		VADD2( &es_rec.s.s_values[21],
			&es_rec.s.s_values[12],
d469 2
a470 2
		VADD2( &es_rec.s.s_values[18],
			&es_rec.s.s_values[15],
d475 2
a476 2
		VADD2( &es_rec.s.s_values[0],
			&es_rec.s.s_values[9],
d478 2
a479 2
		VADD2( &es_rec.s.s_values[3],
			&es_rec.s.s_values[6],
d481 2
a482 2
		VADD2( &es_rec.s.s_values[15],
			&es_rec.s.s_values[18],
d484 2
a485 2
		VADD2( &es_rec.s.s_values[12],
			&es_rec.s.s_values[21],
d490 2
a491 2
		VADD2( &es_rec.s.s_values[0],
			&es_rec.s.s_values[3],
d493 2
a494 2
		VADD2( &es_rec.s.s_values[9],
			&es_rec.s.s_values[6],
d496 2
a497 2
		VADD2( &es_rec.s.s_values[12],
			&es_rec.s.s_values[15],
d499 2
a500 2
		VADD2( &es_rec.s.s_values[21],
			&es_rec.s.s_values[18],
d505 2
a506 2
		VADD2( &es_rec.s.s_values[3],
			&es_rec.s.s_values[0],
d508 2
a509 2
		VADD2( &es_rec.s.s_values[15],
			&es_rec.s.s_values[12],
d511 2
a512 2
		VADD2( &es_rec.s.s_values[6],
			&es_rec.s.s_values[9],
d514 2
a515 2
		VADD2( &es_rec.s.s_values[18],
			&es_rec.s.s_values[21],
d524 6
d691 10
@
