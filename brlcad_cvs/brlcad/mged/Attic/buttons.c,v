head	11.80;
access;
symbols
	ansi-20040405-merged:11.76.2.2
	postmerge-20040405-ansi:11.78
	premerge-20040404-ansi:11.77
	postmerge-autoconf:11.77
	autoconf-freeze:11.76.10.2
	premerge-autoconf:11.77
	postmerge-20040315-windows:11.77
	premerge-20040315-windows:11.77
	windows-20040315-freeze:11.76.4.1
	autoconf-20031203:11.76
	autoconf-20031202:11.76
	autoconf-branch:11.76.0.10
	phong-branch:11.76.0.8
	photonmap-branch:11.76.0.6
	rel-6-1-DP:11.76
	windows-branch:11.76.0.4
	rel-6-0-2:11.74
	ansi-branch:11.76.0.2
	rel-6-0-1-branch:11.74.0.2
	hartley-6-0-post:11.75
	hartley-6-0-pre:11.74
	rel-6-0-1:11.74
	rel-6-0:11.74
	rel-5-4:11.60.2.1
	offsite-5-3-pre:11.67
	rel-5-3:11.60.2.1
	rel-5-2:11.60
	rel-5-1-branch:11.60.0.2
	rel-5-1:11.60
	rel-5-0:11.57
	rel-5-0-beta:11.57
	rel-4-5:11.53
	ctj-4-5-post:11.44
	ctj-4-5-pre:11.44
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.6;
locks; strict;
comment	@ * @;


11.80
date	2004.05.21.17.47.35;	author morrison;	state dead;
branches;
next	11.79;

11.79
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.78;

11.78
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.77;

11.77
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.76;

11.76
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	11.76.2.1
	11.76.4.1
	11.76.10.1;
next	11.75;

11.75
date	2002.08.15.20.55.31;	author hartley;	state Exp;
branches;
next	11.74;

11.74
date	2001.06.05.15.51.40;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	2001.06.01.19.23.22;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	2001.04.02.21.38.17;	author morrison;	state Exp;
branches;
next	11.71;

11.71
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	2001.04.02.18.10.10;	author jra;	state Exp;
branches;
next	11.69;

11.69
date	2001.03.31.01.57.20;	author morrison;	state Exp;
branches;
next	11.68;

11.68
date	2001.03.19.22.20.01;	author butler;	state Exp;
branches;
next	11.67;

11.67
date	2001.02.01.21.39.32;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	2000.09.07.02.23.41;	author mike;	state Exp;
branches;
next	11.65;

11.65
date	2000.08.19.03.10.41;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	2000.08.19.03.10.10;	author mike;	state Exp;
branches;
next	11.63;

11.63
date	2000.07.05.22.23.45;	author mike;	state Exp;
branches;
next	11.62;

11.62
date	2000.07.05.22.23.17;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	2000.07.05.20.50.23;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	2000.01.14.15.55.23;	author bparker;	state Exp;
branches
	11.60.2.1;
next	11.59;

11.59
date	99.12.30.19.38.09;	author jra;	state Exp;
branches;
next	11.58;

11.58
date	99.10.19.20.34.35;	author jra;	state Exp;
branches;
next	11.57;

11.57
date	98.11.06.22.06.00;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	98.08.13.12.03.15;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	98.03.19.18.09.50;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	98.02.26.16.06.13;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	97.12.17.14.54.57;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	97.11.06.19.58.41;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	97.11.03.15.23.55;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	97.10.08.13.48.14;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	97.09.08.19.04.49;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	97.07.31.14.46.17;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	97.07.25.20.49.45;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	97.07.17.20.53.15;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	97.06.25.13.43.29;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	97.05.29.14.03.34;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	97.04.23.18.30.43;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	97.03.07.21.37.37;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	97.02.28.21.36.58;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	97.02.04.22.15.01;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	97.02.03.15.27.00;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	97.01.29.05.37.06;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	97.01.24.20.58.12;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	97.01.08.19.45.35;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	97.01.02.19.38.47;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.12.30.22.38.28;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.12.20.22.53.10;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.12.13.23.10.54;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.11.19.21.43.44;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.10.18.13.53.51;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.10.04.14.55.17;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.10.03.20.22.42;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.09.23.18.37.58;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.09.17.21.20.27;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.08.21.14.26.42;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	96.08.13.14.20.43;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.07.30.21.32.52;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.07.11.19.26.54;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.06.28.20.53.16;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.05.24.19.08.46;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.04.18.20.26.00;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.03.22.18.36.23;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.03.01.19.34.30;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.01.17.22.10.04;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	95.12.27.22.33.27;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	95.12.11.22.44.28;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.11.29.21.56.05;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	95.11.07.22.58.34;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.08.03.21.43.59;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.19;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.39;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.24.01.06.20;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.12.23.14.26.12;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.12.16.15.57.09;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.12.16.15.56.23;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.12.16.15.55.35;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.11.08.04.16.42;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.09.14.56.54;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	92.02.05.23.12.07;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.12.20.02.27.45;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.12.02.16.57.01;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.06;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.06.25.16.06.46;	author pjt;	state Exp;
branches;
next	9.4;

9.4
date	91.06.12.22.17.51;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.04.21.06.05.09;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.27.21.18.45;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.01.49;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.04.21.04.56.44;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.07.00.21.19;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.20.38.49;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.03.06.17.26.05;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.55.40;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.28;	author mike;	state Rel3_0;
branches;
next	7.6;

7.6
date	88.09.16.02.50.34;	author reschly;	state Exp;
branches;
next	7.5;

7.5
date	88.05.15.23.04.43;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.02.04.12.00.05;	author stay;	state Exp;
branches;
next	7.3;

7.3
date	87.11.14.05.03.01;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.03.30;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.33;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.01.47;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.17.49;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.06.16.04.28.55;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.05.28;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.19.08;	author mike;	state Rel1;
branches;
next	2.13;

2.13
date	86.12.20.05.12.30;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.09.23.17.39.58;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.09.10.01.36.25;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.08.12.06.46.43;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.07.17.17.37.44;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.03.10.21.37.04;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.09.14.05.33.43;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.08.07.05.16.40;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.06.03.16.48.35;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.29.23.16.41;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.05.10.00.51.26;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.05.03.01.31.13;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.53.41;	author mike;	state Prod;
branches;
next	1.6;

1.6
date	85.03.08.20.52.45;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.01.17.07.27.52;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.02.58.04;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.01.16.01.56.21;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.04.22.15;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.47.53;	author mike;	state Exp;
branches;
next	;

11.60.2.1
date	2001.02.01.21.31.54;	author bparker;	state Exp;
branches;
next	;

11.76.2.1
date	2002.09.19.18.01.59;	author morrison;	state Exp;
branches;
next	11.76.2.2;

11.76.2.2
date	2004.03.17.21.21.55;	author morrison;	state Exp;
branches;
next	;

11.76.4.1
date	2004.03.11.23.46.33;	author morrison;	state Exp;
branches;
next	;

11.76.10.1
date	2004.02.12.18.34.12;	author erikg;	state Exp;
branches;
next	11.76.10.2;

11.76.10.2
date	2004.03.15.14.07.35;	author erikg;	state Exp;
branches;
next	;


desc
@Handle button presses
@


11.80
log
@moved to src/mged/
@
text
@/*
 *			B U T T O N S . C
 *
 * Functions -
 *	buttons		Process button-box functions
 *	press		button function request
 *	state_err	state error printer
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/buttons.c,v 11.79 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "externs.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./sedit.h"

#ifdef DM_X
extern void stateChange();		/* defined in dm-generic.c */
#endif
extern int mged_svbase(void);
extern void set_e_axes_pos(int both);
extern int mged_zoom(double val);
extern void set_absolute_tran(void);	/* defined in set.c */
extern void set_scroll_private(void);	/* defined in set.c */
extern void adc_set_scroll(void);		/* defined in adc.c */

/*
 * This flag indicates that Primitive editing is in effect.
 * edobj may not be set at the same time.
 * It is set to the 0 if off, or the value of the button function
 * that is currently in effect (eg, BE_S_SCALE).
 */
static int	edsol;

/* This flag indicates that Matrix editing is in effect.
 * edsol may not be set at the same time.
 * Value is 0 if off, or the value of the button function currently
 * in effect (eg, BE_O_XY).
 */
int	edobj;		/* object editing */
int	movedir;	/* RARROW | UARROW | SARROW | ROTARROW */

/*
 * The "accumulation" solid rotation matrix and scale factor
 */
mat_t	acc_rot_sol;
fastf_t	acc_sc_sol;
fastf_t	acc_sc_obj;     /* global object scale factor --- accumulations */
fastf_t	acc_sc[3];	/* local object scale factors --- accumulations */

struct buttons  {
	int	bu_code;	/* dm_values.dv_button */
	char	*bu_name;	/* keyboard string */
	int	(*bu_func)(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);	/* function to call */
}  button_table[] = {
	{BV_35_25,		"35,25",	bv_35_25},
	{BV_45_45,		"45,45",	bv_45_45},
	{BE_ACCEPT,		"accept",	be_accept},
	{BV_ADCURSOR,		"adc",		bv_adcursor},
	{BV_BOTTOM,		"bottom",	bv_bottom},
	{BV_FRONT,		"front",	bv_front},
	{BV_LEFT,		"left",		bv_left},
	{BE_O_ILLUMINATE,	"oill",		be_o_illuminate},
	{BE_O_ROTATE,		"orot",		be_o_rotate},
	{BE_O_SCALE,		"oscale",	be_o_scale},
	{BE_O_X,		"ox",		be_o_x},
	{BE_O_XY,		"oxy",		be_o_xy},
	{BE_O_XSCALE,		"oxscale",	be_o_xscale},
	{BE_O_Y,		"oy",		be_o_y},
	{BE_O_YSCALE,		"oyscale",	be_o_yscale},
	{BE_O_ZSCALE,		"ozscale",	be_o_zscale},
	{BV_REAR,		"rear",		bv_rear},
	{BE_REJECT,		"reject",	be_reject},
	{BV_RESET,		"reset",	bv_reset},
	{BV_VRESTORE,		"restore",	bv_vrestore},
	{BV_RIGHT,		"right",	bv_right},
	{BV_VSAVE,		"save",		bv_vsave},
	{BE_S_EDIT,		"sedit",	be_s_edit},
	{BE_S_ILLUMINATE,	"sill",		be_s_illuminate},
	{BE_S_ROTATE,		"srot",		be_s_rotate},
	{BE_S_SCALE,		"sscale",	be_s_scale},
	{BE_S_TRANS,		"sxy",		be_s_trans},
	{BV_TOP,		"top",		bv_top},
	{BV_ZOOM_IN,		"zoomin",	bv_zoomin},
	{BV_ZOOM_OUT,		"zoomout",	bv_zoomout},
	{BV_RATE_TOGGLE,	"rate",		bv_rate_toggle},
	{-1,			"-end-",	be_reject}
};

static mat_t sav_viewrot, sav_toviewcenter;
static fastf_t sav_vscale;
static int	vsaved = 0;	/* set iff view saved */

extern void color_soltab(void);
extern void	sl_halt_scroll(void);	/* in scroll.c */
extern void	sl_toggle_scroll(void);

void		btn_head_menu(int i, int menu, int item);
void		btn_item_hit(int arg, int menu, int item);

static struct menu_item first_menu[] = {
	{ "BUTTON MENU", btn_head_menu, 1 },		/* chg to 2nd menu */
	{ "", (void (*)())NULL, 0 }
};
struct menu_item second_menu[] = {
	{ "BUTTON MENU", btn_head_menu, 0 },	/* chg to 1st menu */
	{ "REJECT Edit", btn_item_hit, BE_REJECT },
	{ "ACCEPT Edit", btn_item_hit, BE_ACCEPT },
	{ "35,25", btn_item_hit, BV_35_25 },
	{ "Top", btn_item_hit, BV_TOP },
	{ "Right", btn_item_hit, BV_RIGHT },
	{ "Front", btn_item_hit, BV_FRONT },
	{ "45,45", btn_item_hit, BV_45_45 },
	{ "Restore View", btn_item_hit, BV_VRESTORE },
	{ "Save View", btn_item_hit, BV_VSAVE },
	{ "Ang/Dist Curs", btn_item_hit, BV_ADCURSOR },
	{ "Reset Viewsize", btn_item_hit, BV_RESET },
	{ "Zero Sliders", sl_halt_scroll, 0 },
	{ "Sliders", sl_toggle_scroll, 0 },
	{ "Rate/Abs", btn_item_hit, BV_RATE_TOGGLE },
	{ "Zoom In 2X", btn_item_hit, BV_ZOOM_IN },
	{ "Zoom Out 2X", btn_item_hit, BV_ZOOM_OUT },
	{ "Prim Illum", btn_item_hit, BE_S_ILLUMINATE },
	{ "Matrix Illum", btn_item_hit, BE_O_ILLUMINATE },
	{ "", (void (*)())NULL, 0 }
};
struct menu_item sed_menu[] = {
	{ "*PRIM EDIT*", btn_head_menu, 2 },
	{ "Edit Menu", btn_item_hit, BE_S_EDIT },
	{ "Rotate", btn_item_hit, BE_S_ROTATE },
	{ "Translate", btn_item_hit, BE_S_TRANS },
	{ "Scale", btn_item_hit, BE_S_SCALE },
	{ "", (void (*)())NULL, 0 }
};

struct menu_item oed_menu[] = {
	{ "*MATRIX EDIT*", btn_head_menu, 2 },
	{ "Scale", btn_item_hit, BE_O_SCALE },
	{ "X Move", btn_item_hit, BE_O_X },
	{ "Y Move", btn_item_hit, BE_O_Y },
	{ "XY Move", btn_item_hit, BE_O_XY },
	{ "Rotate", btn_item_hit, BE_O_ROTATE },
	{ "Scale X", btn_item_hit, BE_O_XSCALE },
	{ "Scale Y", btn_item_hit, BE_O_YSCALE },
	{ "Scale Z", btn_item_hit, BE_O_ZSCALE },
	{ "", (void (*)())NULL, 0 }
};

/*
 *			B U T T O N
 */
void
button(register int bnum)
{
	register struct buttons *bp;

	if( edsol && edobj )
	  bu_log("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj);

	/* Process the button function requested. */
	for( bp = button_table; bp->bu_code >= 0; bp++ )  {
		if( bnum != bp->bu_code )
			continue;

		bp->bu_func( (ClientData)NULL, interp, 0, NULL );
		return;
	}

	bu_log("button(%d):  Not a defined operation\n", bnum);
}

/*
 *			F _ P R E S S
 *
 * Hook for displays with no buttons
 *
 *  Given a string description of which button to press, simulate
 *  pressing that button on the button box.
 *
 *  These days, just hand off to the appropriate Tcl proc of the same name.
 */
int
f_press(ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	register int i;

	if(argc < 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help press");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( i = 1; i < argc; i++ )  {
		char *str = argv[i];
		register struct buttons *bp;
		struct menu_item	**m;
		int menu, item;
		register struct menu_item	*mptr;

		if( edsol && edobj ){
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}

		if(strcmp(str, "help") == 0) {
		  struct bu_vls vls;

		  bu_vls_init(&vls);

		  for( bp = button_table; bp->bu_code >= 0; bp++ )
		    vls_col_item(&vls, bp->bu_name);
		  vls_col_eol(&vls);

		  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		  bu_vls_free(&vls);
		  goto next;
		}

		/* Process the button function requested. */
		for( bp = button_table; bp->bu_code >= 0; bp++ )  {
			if( strcmp( str, bp->bu_name ) != 0 )
				continue;

			(void)bp->bu_func(clientData, interp, 2, argv+1);
			goto next;
		}

		for( menu=0, m=menu_state->ms_menus; m - menu_state->ms_menus < NMENU; m++,menu++ )  {
			if( *m == MENU_NULL )  continue;
			for( item=0, mptr = *m;
			     mptr->menu_string[0] != '\0';
			     mptr++, item++ )  {
			    if ( strcmp( str, mptr->menu_string ) != 0 )
				continue;
			
			    menu_state->ms_cur_item = item;
			    menu_state->ms_cur_menu = menu;
			    menu_state->ms_flag = 1;
			    /* It's up to the menu_func to set menu_state->ms_flag=0
			     * if no arrow is desired */
			    if( mptr->menu_func != ((void (*)())0) )
				(*(mptr->menu_func))(mptr->menu_arg, menu, item);

			    goto next;
			}
		}

		Tcl_AppendResult(interp, "press(", str,
			 "):  Unknown operation, type 'press help' for help\n", (char *)NULL);
next:		;
	}

	return TCL_OK;
}

/*
 *  			L A B E L _ B U T T O N
 *  
 *  For a given GED button number, return the "press" ID string.
 *  Useful for displays with programable button lables, etc.
 */
char *
label_button(int bnum)
{
	register struct buttons *bp;

	/* Process the button function requested. */
	for( bp = button_table; bp->bu_code >= 0; bp++ )  {
		if( bnum != bp->bu_code )
			continue;
		return( bp->bu_name );
	}

	{
	  struct bu_vls tmp_vls;
	  
	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "label_button(%d):  Not a defined operation\n", bnum);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	return("");
}

int
bv_zoomin(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  (void)mged_zoom(2.0);
  return TCL_OK;
}

int
bv_zoomout(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  (void)mged_zoom(0.5);
  return TCL_OK;
}

int
bv_rate_toggle(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  mged_variables->mv_rateknobs = !mged_variables->mv_rateknobs;
  set_scroll_private();
  return TCL_OK;
}

int
bv_top(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	/* Top view */
	setview(0.0, 0.0, 0.0);
	return TCL_OK;
}

int
bv_bottom(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	/* Bottom view */
	setview(180.0, 0.0, 0.0);
	return TCL_OK;
}

int
bv_right(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	/* Right view */
	setview(270.0, 0.0, 0.0);
	return TCL_OK;
}

int
bv_left(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	/* Left view */
	setview(270.0, 0.0, 180.0);
	return TCL_OK;
}

int
bv_front(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	/* Front view */
	setview(270.0, 0.0, 270.0);
	return TCL_OK;
}

int
bv_rear(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	/* Rear view */
	setview(270.0, 0.0, 90.0);
	return TCL_OK;
}

int
bv_vrestore(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
  /* restore to saved view */
	if (vsaved) {
		view_state->vs_vop->vo_scale = sav_vscale;
		MAT_COPY(view_state->vs_vop->vo_rotation, sav_viewrot);
		MAT_COPY(view_state->vs_vop->vo_center, sav_toviewcenter);
		new_mats();

		(void)mged_svbase();
	}

	return TCL_OK;
}

int
bv_vsave(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	/* save current view */
	sav_vscale = view_state->vs_vop->vo_scale;
	MAT_COPY(sav_viewrot, view_state->vs_vop->vo_rotation);
	MAT_COPY(sav_toviewcenter, view_state->vs_vop->vo_center);
	vsaved = 1;
	return TCL_OK;
}

/*
 *			B V _ A D C U R S O R
 *
 *  Toggle state of angle/distance cursor.
 *  "press adc"
 *  This command conflicts with existing "adc" command,
 *  can't be bound as "adc", only as "press adc".
 */
int
bv_adcursor(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if (adc_state->adc_draw)  {
    /* Was on, turn off */
    adc_state->adc_draw = 0;
  }  else  {
    /* Was off, turn on */
    adc_state->adc_draw = 1;
  }

  adc_set_scroll();
  return TCL_OK;
}

int
bv_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	/* Reset view such that all solids can be seen */
	size_reset();
	setview(0.0, 0.0, 0.0);
	(void)mged_svbase();
	return TCL_OK;
}

int
bv_45_45(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	setview(270.0+45.0, 0.0, 270.0-45.0);
	return TCL_OK;
}

int
bv_35_25(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	/* Use Azmuth=35, Elevation=25 in GIFT's backwards space */
	setview(270.0+25.0, 0.0, 270.0-35.0);
	return TCL_OK;
}

/* returns 0 if error, !0 if success */
static int
ill_common(void) {
	/* Common part of illumination */
	if(BU_LIST_IS_EMPTY(&dgop->dgo_headSolid)) {
	  Tcl_AppendResult(interp, "no solids in view\n", (char *)NULL);
	  return(0);	/* BAD */
	}

	illump = BU_LIST_NEXT(solid, &dgop->dgo_headSolid);/* any valid solid would do */
	illump->s_iflag = UP;
	edobj = 0;		/* sanity */
	edsol = 0;		/* sanity */
	movedir = 0;		/* No edit modes set */
	MAT_IDN( modelchanges );	/* No changes yet */

	return(1);		/* OK */
}

int
be_o_illuminate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_VIEW, "Matrix Illuminate" ) )
		return TCL_ERROR;

	if( ill_common() )  {
		(void)chg_state( ST_VIEW, ST_O_PICK, "Matrix Illuminate" );
	}
	/* reset accumulation local scale factors */
	acc_sc[0] = acc_sc[1] = acc_sc[2] = 1.0;

	/* reset accumulation global scale factors */
	acc_sc_obj = 1.0;
	return TCL_OK;
}

int
be_s_illuminate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_VIEW, "Prim Illuminate" ) )
		return TCL_ERROR;

	if( ill_common() )  {
		(void)chg_state( ST_VIEW, ST_S_PICK, "Prim Illuminate" );
	}
	return TCL_OK;
}

int
be_o_scale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_O_EDIT, "Matrix Scale" ) )
		return TCL_ERROR;

	edobj = BE_O_SCALE;
	movedir = SARROW;
	update_views = 1;
	set_e_axes_pos(1);

	edit_absolute_scale = acc_sc_obj - 1.0;
	if(edit_absolute_scale > 0.0)
	  edit_absolute_scale /= 3.0;
	return TCL_OK;
}

int
be_o_xscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_O_EDIT, "Matrix Local X Scale" ) )
		return TCL_ERROR;

	edobj = BE_O_XSCALE;
	movedir = SARROW;
	update_views = 1;
	set_e_axes_pos(1);

	edit_absolute_scale = acc_sc[0] - 1.0;
	if(edit_absolute_scale > 0.0)
	  edit_absolute_scale /= 3.0;
	return TCL_OK;
}

int
be_o_yscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_O_EDIT, "Matrix Local Y Scale" ) )
		return TCL_ERROR;

	edobj = BE_O_YSCALE;
	movedir = SARROW;
	update_views = 1;
	set_e_axes_pos(1);

	edit_absolute_scale = acc_sc[1] - 1.0;
	if(edit_absolute_scale > 0.0)
	  edit_absolute_scale /= 3.0;
	return TCL_OK;
}

int
be_o_zscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_O_EDIT, "Matrix Local Z Scale" ) )
		return TCL_ERROR;

	edobj = BE_O_ZSCALE;
	movedir = SARROW;
	update_views = 1;
	set_e_axes_pos(1);

	edit_absolute_scale = acc_sc[2] - 1.0;
	if(edit_absolute_scale > 0.0)
	  edit_absolute_scale /= 3.0;
	return TCL_OK;
}

int
be_o_x(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_O_EDIT, "Matrix X Motion" ) )
		return TCL_ERROR;

	edobj = BE_O_X;
	movedir = RARROW;
	update_views = 1;
	set_e_axes_pos(1);
	return TCL_OK;
}

int
be_o_y(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_O_EDIT, "Matrix Y Motion" ) )
		return TCL_ERROR;

	edobj = BE_O_Y;
	movedir = UARROW;
	update_views = 1;
	set_e_axes_pos(1);
	return TCL_OK;
}


int
be_o_xy(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_O_EDIT, "Matrix XY Motion" ) )
		return TCL_ERROR;

	edobj = BE_O_XY;
	movedir = UARROW | RARROW;
	update_views = 1;
	set_e_axes_pos(1);
	return TCL_OK;
}

int
be_o_rotate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	if( not_state( ST_O_EDIT, "Matrix Rotation" ) )
		return TCL_ERROR;

	edobj = BE_O_ROTATE;
	movedir = ROTARROW;
	update_views = 1;
	set_e_axes_pos(1);
	return TCL_OK;
}

int
be_accept(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	register struct solid *sp;
	register struct dm_list *dmlp;

	if( state == ST_S_EDIT )  {
		/* Accept a solid edit */
		edsol = 0;

		sedit_accept();		/* zeros "edsol" var */

		mmenu_set_all( MENU_L1, MENU_NULL );
		mmenu_set_all( MENU_L2, MENU_NULL );

		FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
			sp->s_iflag = DOWN;

		illump = SOLID_NULL;
		color_soltab();
		(void)chg_state( ST_S_EDIT, ST_VIEW, "Edit Accept" );
	}  else if( state == ST_O_EDIT )  {
		/* Accept an object edit */
		edobj = 0;
		movedir = 0;	/* No edit modes set */

		oedit_accept();

		mmenu_set_all( MENU_L2, MENU_NULL );

		illump = SOLID_NULL;
		color_soltab();
		(void)chg_state( ST_O_EDIT, ST_VIEW, "Edit Accept" );
	} else {
		if( not_state( ST_S_EDIT, "Edit Accept" ) )
			return TCL_ERROR;
		return TCL_OK;
	}

	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
	  if(dmlp->dml_mged_variables->mv_transform == 'e')
	    dmlp->dml_mged_variables->mv_transform = 'v';

	{
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_strcpy(&vls, "end_edit_callback");
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	}
	return TCL_OK;
}

int
be_reject(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	register struct solid *sp;
	register struct dm_list *dmlp;

	update_views = 1;

	/* Reject edit */

	switch( state )  {
	default:
		state_err( "Edit Reject" );
		return TCL_ERROR;

	case ST_S_EDIT:
		/* Reject a solid edit */
		mmenu_set_all( MENU_L1, MENU_NULL );
		mmenu_set_all( MENU_L2, MENU_NULL );

		sedit_reject();
		break;

	case ST_O_EDIT:
		mmenu_set_all( MENU_L2, MENU_NULL );

		oedit_reject();
		break;
	case ST_O_PICK:
		break;
	case ST_S_PICK:
		break;
	case ST_O_PATH:
		break;
	}

	menu_state->ms_flag = 0;
	movedir = 0;
	edsol = 0;
	edobj = 0;
	es_edflag = -1;
	illump = SOLID_NULL;		/* None selected */

	/* Clear illumination flags */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_iflag = DOWN;
	color_soltab();
	(void)chg_state( state, ST_VIEW, "Edit Reject" );

	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
	  if(dmlp->dml_mged_variables->mv_transform == 'e')
	    dmlp->dml_mged_variables->mv_transform = 'v';

	{
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_strcpy(&vls, "end_edit_callback");
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	}
	return TCL_OK;
}

int
be_s_edit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	/* solid editing */
	if( not_state( ST_S_EDIT, "Prim Edit (Menu)" ) )
		return TCL_ERROR;

	edsol = BE_S_EDIT;
	sedit_menu();		/* Install appropriate menu */
	return TCL_OK;
}

int
be_s_rotate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	/* rotate solid */
	if( not_state( ST_S_EDIT, "Prim Rotate" ) )
		return TCL_ERROR;

	es_edflag = SROT;
	edsol = BE_S_ROTATE;
	mmenu_set( MENU_L1, MENU_NULL );

        set_e_axes_pos(1);
	return TCL_OK;
}

int
be_s_trans(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	/* translate solid */
	if( not_state( ST_S_EDIT, "Prim Translate" ) )
		return TCL_ERROR;

	edsol = BE_S_TRANS;
	es_edflag = STRANS;
	movedir = UARROW | RARROW;
	mmenu_set( MENU_L1, MENU_NULL );

        set_e_axes_pos(1);
	return TCL_OK;
}

int
be_s_scale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)  {
	/* scale solid */
	if( not_state( ST_S_EDIT, "Prim Scale" ) )
		return TCL_ERROR;

	edsol = BE_S_SCALE;
	es_edflag = SSCALE;
	mmenu_set( MENU_L1, MENU_NULL );
	acc_sc_sol = 1.0;

        set_e_axes_pos(1);
	return TCL_OK;
}

/*
 *			N O T _ S T A T E
 *  
 *  Returns 0 if current state is as desired,
 *  Returns !0 and prints error message if state mismatch.
 */
int
not_state(int desired, char *str)
{
  if( state != desired ) {
    Tcl_AppendResult(interp, "Unable to do <", str, "> from ",
		     state_str[state], " state.\n", (char *)NULL);
    return -1;
  }

  return 0;
}

/*
 *  			C H G _ S T A T E
 *
 *  Returns 0 if state change is OK,
 *  Returns !0 and prints error message if error.
 */
int
chg_state(int from, int to, char *str)
{
  register struct dm_list *p;
  struct dm_list *save_dm_list;
  struct bu_vls vls;

  if(state != from){
    bu_log("Unable to do <%s> going from %s to %s state.\n", str, state_str[from], state_str[to]);
    return(1);	/* BAD */
  }

  state = to;

#ifdef DM_X
  stateChange(from, to);
#endif

  save_dm_list = curr_dm_list;
  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
    curr_dm_list = p;

#if 0
    if(to == ST_VIEW){
      mat_t o_toViewcenter;
      fastf_t o_Viewscale;

      /* save toViewcenter and Viewscale */
      MAT_COPY(o_toViewcenter, view_state->vs_toViewcenter);
      o_Viewscale = view_state->vs_Viewscale;

      /* get new orig_pos */
      size_reset();
      MAT_DELTAS_GET_NEG(view_state->vs_orig_pos, view_state->vs_toViewcenter);

      /* restore old toViewcenter and Viewscale */
      MAT_COPY(view_state->vs_toViewcenter, o_toViewcenter);
      view_state->vs_Viewscale = o_Viewscale;
    }
#endif
    new_mats();

#if 0
    /* recompute absolute_tran */
    set_absolute_tran();
#endif
  }

  curr_dm_list = save_dm_list;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "%s(state)", MGED_DISPLAY_VAR);
  Tcl_SetVar(interp, bu_vls_addr(&vls), state_str[state], TCL_GLOBAL_ONLY);
  bu_vls_free(&vls);

  return(0);		/* GOOD */
}

void
state_err(char *str)
{
  Tcl_AppendResult(interp, "Unable to do <", str, "> from ", state_str[state],
		   " state.\n", (char *)NULL);
}


/*
 *			B T N _ I T E M _ H I T
 *
 *  Called when a menu item is hit
 */
void
 btn_item_hit(int arg, int menu, int item) {
	button(arg);
	if( menu == MENU_GEN && 
	    ( arg != BE_O_ILLUMINATE && arg != BE_S_ILLUMINATE) )
		menu_state->ms_flag = 0;
}

/*
 *			B T N _ H E A D _ M E N U
 *
 *  Called to handle hits on menu heads.
 *  Also called from main() with arg 0 in init.
 */
void
btn_head_menu(int i, int menu, int item)  {
	switch(i)  {
	case 0:
		mmenu_set( MENU_GEN, first_menu );
		break;
	case 1:
		mmenu_set( MENU_GEN, second_menu );
		break;
	case 2:
		/* nothing happens */
		break;
	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "btn_head_menu(%d): bad arg\n", i);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }

	  break;
	}
}

void
chg_l2menu(int i)  {
	switch( i )  {
	case ST_S_EDIT:
		mmenu_set_all( MENU_L2, sed_menu );
		break;
	case ST_S_NO_EDIT:
		mmenu_set_all( MENU_L2, MENU_NULL );
		break;
	case ST_O_EDIT:
		mmenu_set_all( MENU_L2, oed_menu );
		break;
	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "chg_l2menu(%d): bad arg\n", i);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }

	  break;
	}
}
@


11.79
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/buttons.c,v 11.78 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.78
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.77
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.76 2002/08/20 17:08:21 jra Exp $ (BRL)";
d47 6
a52 6
extern int mged_svbase();
extern void set_e_axes_pos();
extern int mged_zoom();
extern void set_absolute_tran();	/* defined in set.c */
extern void set_scroll_private();	/* defined in set.c */
extern void adc_set_scroll();		/* defined in adc.c */
d121 3
a123 3
extern void color_soltab();
extern void	sl_halt_scroll();	/* in scroll.c */
extern void	sl_toggle_scroll();
d125 2
a126 2
void		btn_head_menu();
void		btn_item_hit();
d180 1
a180 2
button( bnum )
register int bnum;
d301 1
a301 2
label_button(bnum)
int bnum;
d474 1
a474 1
ill_common()  {
d809 1
a809 3
not_state( desired, str )
int desired;
char *str;
d827 1
a827 3
chg_state( from, to, str )
int from, to;
char *str;
d885 1
a885 2
state_err( str )
char *str;
d898 1
a898 1
 btn_item_hit(arg, menu, item)  {
@


11.76
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.74 2001/06/05 15:51:40 bparker Exp $ (BRL)";
@


11.76.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/buttons.c,v 11.77 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.76.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.77 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.76.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.76.10.1 2004/02/12 18:34:12 erikg Exp $ (BRL)";
@


11.76.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.76 2002/08/20 17:08:21 jra Exp $ (BRL)";
d47 6
a52 6
extern int mged_svbase(void);
extern void set_e_axes_pos(int both);
extern int mged_zoom(double val);
extern void set_absolute_tran(void);	/* defined in set.c */
extern void set_scroll_private(void);	/* defined in set.c */
extern void adc_set_scroll(void);		/* defined in adc.c */
d121 3
a123 3
extern void color_soltab(void);
extern void	sl_halt_scroll(void);	/* in scroll.c */
extern void	sl_toggle_scroll(void);
d125 2
a126 2
void		btn_head_menu(int i, int menu, int item);
void		btn_item_hit(int arg, int menu, int item);
d180 2
a181 1
button(register int bnum)
d302 2
a303 1
label_button(int bnum)
d476 1
a476 1
ill_common(void) {
d811 3
a813 1
not_state(int desired, char *str)
d831 3
a833 1
chg_state(int from, int to, char *str)
d891 2
a892 1
state_err(char *str)
d905 1
a905 1
 btn_item_hit(int arg, int menu, int item) {
@


11.76.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.75
log
@Converted from K&R to ANSI C - RFH
@
text
@d47 6
a52 6
extern int mged_svbase(void);
extern void set_e_axes_pos(int both);
extern int mged_zoom(double val);
extern void set_absolute_tran(void);	/* defined in set.c */
extern void set_scroll_private(void);	/* defined in set.c */
extern void adc_set_scroll(void);		/* defined in adc.c */
d121 3
a123 3
extern void color_soltab(void);
extern void	sl_halt_scroll(void);	/* in scroll.c */
extern void	sl_toggle_scroll(void);
d125 2
a126 2
void		btn_head_menu(int i, int menu, int item);
void		btn_item_hit(int arg, int menu, int item);
d180 2
a181 1
button(register int bnum)
d302 2
a303 1
label_button(int bnum)
d476 1
a476 1
ill_common(void) {
d811 3
a813 1
not_state(int desired, char *str)
d831 3
a833 1
chg_state(int from, int to, char *str)
d891 2
a892 1
state_err(char *str)
d905 1
a905 1
 btn_item_hit(int arg, int menu, int item) {
@


11.74
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.73 2001/06/01 19:23:22 bparker Exp $ (BRL)";
d47 6
a52 6
extern int mged_svbase();
extern void set_e_axes_pos();
extern int mged_zoom();
extern void set_absolute_tran();	/* defined in set.c */
extern void set_scroll_private();	/* defined in set.c */
extern void adc_set_scroll();		/* defined in adc.c */
d121 3
a123 3
extern void color_soltab();
extern void	sl_halt_scroll();	/* in scroll.c */
extern void	sl_toggle_scroll();
d125 2
a126 2
void		btn_head_menu();
void		btn_item_hit();
d180 1
a180 2
button( bnum )
register int bnum;
d301 1
a301 2
label_button(bnum)
int bnum;
d474 1
a474 1
ill_common()  {
d809 1
a809 3
not_state( desired, str )
int desired;
char *str;
d827 1
a827 3
chg_state( from, to, str )
int from, to;
char *str;
d885 1
a885 2
state_err( str )
char *str;
d898 1
a898 1
 btn_item_hit(arg, menu, item)  {
@


11.73
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.72 2001/04/02 21:38:17 morrison Exp $ (BRL)";
a403 1
#ifdef MGED_USE_VIEW_OBJ
a406 5
#else
		view_state->vs_Viewscale = sav_vscale;
		MAT_COPY( view_state->vs_Viewrot, sav_viewrot );
		MAT_COPY( view_state->vs_toViewcenter, sav_toviewcenter );
#endif
a420 1
#ifdef MGED_USE_VIEW_OBJ
a424 6
#else
	/* save current view */
	sav_vscale = view_state->vs_Viewscale;
	MAT_COPY( sav_viewrot, view_state->vs_Viewrot );
	MAT_COPY( sav_toviewcenter, view_state->vs_toViewcenter );
#endif
@


11.72
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.71 2001/04/02 21:20:40 bparker Exp $ (BRL)";
d351 3
a353 3
  /* Top view */
  setview( 0.0, 0.0, 0.0 );
  return TCL_OK;
d359 3
a361 3
  /* Bottom view */
  setview( 180.0, 0.0, 0.0 );
  return TCL_OK;
d367 3
a369 3
  /* Right view */
  setview( 270.0, 0.0, 0.0 );
  return TCL_OK;
d375 3
a377 3
  /* Left view */
  setview( 270.0, 0.0, 180.0 );
  return TCL_OK;
d383 3
a385 3
  /* Front view */
  setview( 270.0, 0.0, 270.0 );
  return TCL_OK;
d391 3
a393 3
  /* Rear view */
  setview( 270.0, 0.0, 90.0 );
  return TCL_OK;
d397 4
a400 1
bv_vrestore(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d403 11
a413 5
  if ( vsaved )  {
    view_state->vs_Viewscale = sav_vscale;
    MAT_COPY( view_state->vs_Viewrot, sav_viewrot );
    MAT_COPY( view_state->vs_toViewcenter, sav_toviewcenter );
    new_mats();
d415 4
a418 3
    (void)mged_svbase();
  }
  return TCL_OK;
d422 4
a425 1
bv_vsave(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d427 13
a439 6
  /* save current view */
  sav_vscale = view_state->vs_Viewscale;
  MAT_COPY( sav_viewrot, view_state->vs_Viewrot );
  MAT_COPY( sav_toviewcenter, view_state->vs_toViewcenter );
  vsaved = 1;
  return TCL_OK;
d467 5
a471 5
  /* Reset view such that all solids can be seen */
  size_reset();
  setview( 0.0, 0.0, 0.0 );
  (void)mged_svbase();
  return TCL_OK;
d476 2
a477 2
  setview( 270.0+45.0, 0.0, 270.0-45.0 );
  return TCL_OK;
d482 3
a484 3
  /* Use Azmuth=35, Elevation=25 in GIFT's backwards space */
  setview( 270.0+25.0, 0.0, 270.0-35.0 );
  return TCL_OK;
d491 1
a491 1
	if(BU_LIST_IS_EMPTY(&HeadSolid.l)) {
d496 1
a496 1
	illump = BU_LIST_NEXT(solid, &HeadSolid.l);/* any valid solid would do */
d660 1
a660 1
		FOR_ALL_SOLIDS(sp, &HeadSolid.l)
d742 1
a742 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)
@


11.71
log
@*- remove Tk dependencies
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.70 2001/04/02 18:10:10 jra Exp $ (BRL)";
d402 2
a403 2
    bn_mat_copy( view_state->vs_Viewrot, sav_viewrot );
    bn_mat_copy( view_state->vs_toViewcenter, sav_toviewcenter );
d416 2
a417 2
  bn_mat_copy( sav_viewrot, view_state->vs_Viewrot );
  bn_mat_copy( sav_toviewcenter, view_state->vs_toViewcenter );
d853 1
a853 1
      bn_mat_copy(o_toViewcenter, view_state->vs_toViewcenter);
d861 1
a861 1
      bn_mat_copy(view_state->vs_toViewcenter, o_toViewcenter);
@


11.70
log
@Lint
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.69 2001/03/31 01:57:20 morrison Exp $ (BRL)";
d44 1
d46 1
d838 2
d841 1
@


11.69
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.68 2001/03/19 22:20:01 butler Exp $ (BRL)";
d29 5
@


11.68
log
@patches to merge 5.3 into 6.0
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/buttons.c,v 11.67 2001/02/01 21:39:32 bparker Exp $ (BRL)";
d474 1
a474 1
	bn_mat_idn( modelchanges );	/* No changes yet */
@


11.67
log
@*- change "Solid" to "Prim"
*- change "Object" to "Matrix"
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.66 2000/09/07 02:23:41 mike Exp $ (BRL)";
d48 1
a48 1
 * This flag indicates that SOLID editing is in effect.
d55 1
a55 1
/* This flag indicates that OBJECT editing is in effect.
d148 1
a148 1
	{ "*SOLID EDIT*", btn_head_menu, 2 },
d157 1
a157 1
	{ "*OBJ EDIT*", btn_head_menu, 2 },
@


11.66
log
@
Added externs to ged.h to fix lint
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.65 2000/08/19 03:10:41 mike Exp $ (BRL)";
d143 2
a144 2
	{ "Solid Illum", btn_item_hit, BE_S_ILLUMINATE },
	{ "Object Illum", btn_item_hit, BE_O_ILLUMINATE },
d481 1
a481 1
	if( not_state( ST_VIEW, "Object Illuminate" ) )
d485 1
a485 1
		(void)chg_state( ST_VIEW, ST_O_PICK, "Object Illuminate" );
d497 1
a497 1
	if( not_state( ST_VIEW, "Solid Illuminate" ) )
d501 1
a501 1
		(void)chg_state( ST_VIEW, ST_S_PICK, "Solid Illuminate" );
d508 1
a508 1
	if( not_state( ST_O_EDIT, "Object Scale" ) )
d524 1
a524 1
	if( not_state( ST_O_EDIT, "Object Local X Scale" ) )
d540 1
a540 1
	if( not_state( ST_O_EDIT, "Object Local Y Scale" ) )
d556 1
a556 1
	if( not_state( ST_O_EDIT, "Object Local Z Scale" ) )
d572 1
a572 1
	if( not_state( ST_O_EDIT, "Object X Motion" ) )
d584 1
a584 1
	if( not_state( ST_O_EDIT, "Object Y Motion" ) )
d597 1
a597 1
	if( not_state( ST_O_EDIT, "Object XY Motion" ) )
d609 1
a609 1
	if( not_state( ST_O_EDIT, "Object Rotation" ) )
d738 1
a738 1
	if( not_state( ST_S_EDIT, "Solid Edit (Menu)" ) )
d749 1
a749 1
	if( not_state( ST_S_EDIT, "Solid Rotate" ) )
d763 1
a763 1
	if( not_state( ST_S_EDIT, "Solid Translate" ) )
d778 1
a778 1
	if( not_state( ST_S_EDIT, "Solid Scale" ) )
@


11.65
log
@
const RCSid
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.64 2000/08/19 03:10:10 mike Exp $ (BRL)";
a70 32
int bv_zoomin(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_zoomout(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_rate_toggle(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_top(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_bottom(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_right(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_left(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_front(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_rear(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_vrestore(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_vsave(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_adcursor(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_45_45(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_35_25(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_illuminate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_illuminate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_scale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_x(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_y(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_xy(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_rotate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_accept(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_reject(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_edit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_rotate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_trans(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_scale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_xscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_yscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_zscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

d902 1
a902 1
btn_head_menu(i, menu, item)  {
d928 1
a928 1
chg_l2menu(i)  {
@


11.64
log
@
Reduced use of MAXARGS
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.63 2000/07/05 22:23:45 mike Exp $ (BRL)";
@


11.63
log
@
extern for slicemode has been removed too
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.62 2000/07/05 22:23:17 mike Exp $ (BRL)";
d243 1
a243 1
	if(argc < 2 || MAXARGS < argc){
@


11.62
log
@
"press slice" command has been removed.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.61 2000/07/05 20:50:23 mike Exp $ (BRL)";
a94 1
int bv_slicemode(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
@


11.61
log
@
Modified button routines to have Tcl command interfaces.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.60 2000/01/14 15:55:23 bparker Exp $ (BRL)";
a132 1
	{BV_SLICEMODE,		"slice",	bv_slicemode},
a765 5
}

int
bv_slicemode(ClientData clientData, Tcl_Interp *interp, int argc, char **argv) {
	return TCL_ERROR;
@


11.60
log
@*- capitalize menu items
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.59 1999/12/30 19:38:09 jra Exp $ (BRL)";
d71 32
a102 10
static void bv_zoomin(), bv_zoomout(), bv_rate_toggle();
static void bv_top(), bv_bottom(), bv_right();
static void bv_left(), bv_front(), bv_rear();
static void bv_vrestore(), bv_vsave(), bv_adcursor(), bv_reset();
static void bv_45_45(), bv_35_25();
static void be_o_illuminate(), be_s_illuminate();
static void be_o_scale(), be_o_x(), be_o_y(), be_o_xy(), be_o_rotate();
static void be_accept(), be_reject(), bv_slicemode();
static void be_s_edit(), be_s_rotate(), be_s_trans(), be_s_scale();
static void be_o_xscale(), be_o_yscale(), be_o_zscale();
d107 1
a107 1
	void	(*bu_func)();	/* function to call */
d109 33
a141 33
	BV_35_25,	"35,25",	bv_35_25,
	BV_45_45,	"45,45",	bv_45_45,
	BE_ACCEPT,	"accept",	be_accept,
	BV_ADCURSOR,	"adc",		bv_adcursor,
	BV_BOTTOM,	"bottom",	bv_bottom,
	BV_FRONT,	"front",	bv_front,
	BV_LEFT,	"left",		bv_left,
	BE_O_ILLUMINATE,"oill",		be_o_illuminate,
	BE_O_ROTATE,	"orot",		be_o_rotate,
	BE_O_SCALE,	"oscale",	be_o_scale,
	BE_O_X,		"ox",		be_o_x,
	BE_O_XY,	"oxy",		be_o_xy,
	BE_O_XSCALE,	"oxscale",	be_o_xscale,
	BE_O_Y,		"oy",		be_o_y,
	BE_O_YSCALE,	"oyscale",	be_o_yscale,
	BE_O_ZSCALE,	"ozscale",	be_o_zscale,
	BV_REAR,	"rear",		bv_rear,
	BE_REJECT,	"reject",	be_reject,
	BV_RESET,	"reset",	bv_reset,
	BV_VRESTORE,	"restore",	bv_vrestore,
	BV_RIGHT,	"right",	bv_right,
	BV_VSAVE,	"save",		bv_vsave,
	BE_S_EDIT,	"sedit",	be_s_edit,
	BE_S_ILLUMINATE,"sill",		be_s_illuminate,
	BV_SLICEMODE,	"slice",	bv_slicemode,
	BE_S_ROTATE,	"srot",		be_s_rotate,
	BE_S_SCALE,	"sscale",	be_s_scale,
	BE_S_TRANS,	"sxy",		be_s_trans,
	BV_TOP,		"top",		bv_top,
	BV_ZOOM_IN,	"zoomin",	bv_zoomin,
	BV_ZOOM_OUT,	"zoomout",	bv_zoomout,
	BV_RATE_TOGGLE, "rate",		bv_rate_toggle,
	-1,		"-end-",	be_reject
d220 1
a220 1
		bp->bu_func();
d228 8
a235 1
 *  			P R E S S
d237 33
a269 7
void
press( str )
char *str;{
	register struct buttons *bp;
	struct menu_item	**m;
	int menu, item;
	register struct menu_item	*mptr;
d271 2
d274 1
a274 2
	if( edsol && edobj ){
	  struct bu_vls tmp_vls;
d276 8
a283 5
	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
d285 4
a288 2
	if(strcmp(str, "help") == 0) {
	  struct bu_vls vls;
d290 3
a292 19
	  bu_vls_init(&vls);

	  for( bp = button_table; bp->bu_code >= 0; bp++ )
	    vls_col_item(&vls, bp->bu_name);
	  vls_col_eol(&vls);

	  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	  bu_vls_free(&vls);
	  return;
	}

	/* Process the button function requested. */
	for( bp = button_table; bp->bu_code >= 0; bp++ )  {
		if( strcmp( str, bp->bu_name ) != 0 )
			continue;

		bp->bu_func();
		return;
	}
d294 7
a300 7
	for( menu=0, m=menu_state->ms_menus; m - menu_state->ms_menus < NMENU; m++,menu++ )  {
		if( *m == MENU_NULL )  continue;
		for( item=0, mptr = *m;
		     mptr->menu_string[0] != '\0';
		     mptr++, item++ )  {
		    if ( strcmp( str, mptr->menu_string ) != 0 )
			continue;
d302 7
a308 7
		    menu_state->ms_cur_item = item;
		    menu_state->ms_cur_menu = menu;
		    menu_state->ms_flag = 1;
		    /* It's up to the menu_func to set menu_state->ms_flag=0
		     * if no arrow is desired */
		    if( mptr->menu_func != ((void (*)())0) )
			(*(mptr->menu_func))(mptr->menu_arg, menu, item);
d310 2
a311 1
		    return;
d313 4
d319 1
a319 2
	Tcl_AppendResult(interp, "press(", str,
			 "):  Unknown operation, type 'press help' for help\n", (char *)NULL);
d321 1
d353 2
a354 2
static void
bv_zoomin()
d357 1
d360 2
a361 2
static void
bv_zoomout()
d364 1
d367 2
a368 2
static void
bv_rate_toggle()
d372 1
d375 2
a376 2
static void
bv_top()
d380 1
d383 2
a384 2
static void
bv_bottom()
d388 1
d391 2
a392 2
static void
bv_right()
d396 1
d399 2
a400 2
static void
bv_left()
d404 1
d407 2
a408 2
static void
bv_front()
d412 1
d415 2
a416 2
static void
bv_rear()
d420 1
d423 2
a424 2
static void
bv_vrestore()
d435 1
d438 2
a439 2
static void
bv_vsave()
d446 1
d449 10
a458 2
static void
bv_adcursor()
d469 1
d472 2
a473 2
static void
bv_reset()  {
d478 1
d481 2
a482 2
static void
bv_45_45()  {
d484 1
d487 2
a488 2
static void
bv_35_25()  {
d491 1
d513 2
a514 2
static void
be_o_illuminate()  {
d516 1
a516 1
		return;
d526 1
d529 2
a530 2
static void
be_s_illuminate()  {
d532 1
a532 1
		return;
d537 1
d540 2
a541 2
static void
be_o_scale()  {
d543 1
a543 1
		return;
d553 1
d556 2
a557 2
static void
be_o_xscale()  {
d559 1
a559 1
		return;
d569 1
d572 2
a573 2
static void
be_o_yscale()  {
d575 1
a575 1
		return;
d585 1
d588 2
a589 2
static void
be_o_zscale()  {
d591 1
a591 1
		return;
d601 1
d604 2
a605 2
static void
be_o_x()  {
d607 1
a607 1
		return;
d613 1
d616 2
a617 2
static void
be_o_y()  {
d619 1
a619 1
		return;
d625 1
d629 2
a630 2
static void
be_o_xy()  {
d632 1
a632 1
		return;
d638 1
d641 2
a642 2
static void
be_o_rotate()  {
d644 1
a644 1
		return;
d650 1
d653 2
a654 2
static void
be_accept()  {
d686 3
a688 2
		(void)not_state( ST_S_EDIT, "Edit Accept" );
		return;
d703 1
d706 2
a707 2
static void
be_reject()  {
d718 1
a718 1
		return;
d766 1
d769 3
a771 2
static void
bv_slicemode() {
d774 2
a775 2
static void
be_s_edit()  {
d778 1
a778 1
		return;
d782 1
d785 2
a786 2
static void
be_s_rotate()  {
d789 1
a789 1
		return;
d796 1
d799 2
a800 2
static void
be_s_trans()  {
d803 1
a803 1
		return;
d811 1
d814 2
a815 2
static void
be_s_scale()  {
d818 1
a818 1
		return;
d826 1
d843 1
a843 1
    return TCL_ERROR;
d846 1
a846 1
  return TCL_OK;
@


11.60.2.1
log
@*- changed "Solid" to "Prim"
*- changed "Object" to "Matrix"
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.60 2000/01/14 15:55:23 bparker Exp $ (BRL)";
d48 1
a48 1
 * This flag indicates that Primitive editing is in effect.
d55 1
a55 1
/* This flag indicates that Matrix editing is in effect.
d155 2
a156 2
	{ "Prim Illum", btn_item_hit, BE_S_ILLUMINATE },
	{ "Matrix Illum", btn_item_hit, BE_O_ILLUMINATE },
d160 1
a160 1
	{ "*PRIM EDIT*", btn_head_menu, 2 },
d169 1
a169 1
	{ "*MATRIX EDIT*", btn_head_menu, 2 },
d442 1
a442 1
	if( not_state( ST_VIEW, "Matrix Illuminate" ) )
d446 1
a446 1
		(void)chg_state( ST_VIEW, ST_O_PICK, "Matrix Illuminate" );
d457 1
a457 1
	if( not_state( ST_VIEW, "Prim Illuminate" ) )
d461 1
a461 1
		(void)chg_state( ST_VIEW, ST_S_PICK, "Prim Illuminate" );
d467 1
a467 1
	if( not_state( ST_O_EDIT, "Matrix Scale" ) )
d482 1
a482 1
	if( not_state( ST_O_EDIT, "Matrix Local X Scale" ) )
d497 1
a497 1
	if( not_state( ST_O_EDIT, "Matrix Local Y Scale" ) )
d512 1
a512 1
	if( not_state( ST_O_EDIT, "Matrix Local Z Scale" ) )
d527 1
a527 1
	if( not_state( ST_O_EDIT, "Matrix X Motion" ) )
d538 1
a538 1
	if( not_state( ST_O_EDIT, "Matrix Y Motion" ) )
d550 1
a550 1
	if( not_state( ST_O_EDIT, "Matrix XY Motion" ) )
d561 1
a561 1
	if( not_state( ST_O_EDIT, "Matrix Rotation" ) )
d690 1
a690 1
	if( not_state( ST_S_EDIT, "Prim Edit (Menu)" ) )
d700 1
a700 1
	if( not_state( ST_S_EDIT, "Prim Rotate" ) )
d713 1
a713 1
	if( not_state( ST_S_EDIT, "Prim Translate" ) )
d727 1
a727 1
	if( not_state( ST_S_EDIT, "Prim Scale" ) )
@


11.59
log
@Eliminated an unused variable
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.58 1999/10/19 20:34:35 jra Exp $ (BRL)";
d161 1
a161 1
	{ "edit menu", btn_item_hit, BE_S_EDIT },
d171 3
a173 3
	{ "X move", btn_item_hit, BE_O_X },
	{ "Y move", btn_item_hit, BE_O_Y },
	{ "XY move", btn_item_hit, BE_O_XY },
@


11.58
log
@Added editing for the FGP solid
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.57 1998/11/06 22:06:00 bparker Exp $ (BRL)";
a770 1
  point_t new_pos;
@


11.57
log
@*- use new structures
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.56 1998/08/13 12:03:15 bparker Exp $ (BRL)";
d881 3
@


11.56
log
@*- added end_edit_callback()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/buttons.c,v 11.55 1998/03/19 18:09:50 bparker Exp $ (BRL)";
d39 1
a39 1
extern void stateChange();	/* defined in dm-generic.c */
d43 3
a45 2
extern void set_scroll();  /* defined in set.c */
extern void set_absolute_tran(); /* defined in set.c */
d47 2
a48 1
/* This flag indicates that SOLID editing is in effect.
d249 1
a249 1
	for( menu=0, m=menu_array; m - menu_array < NMENU; m++,menu++ )  {
d257 4
a260 4
		    cur_item = item;
		    cur_menu = menu;
		    menuflag = 1;
		    /* It's up to the menu_func to set menuflag=0
d318 2
a319 2
  mged_variables->rateknobs = !mged_variables->rateknobs;
  set_scroll();
d369 3
a371 3
    Viewscale = sav_vscale;
    bn_mat_copy( Viewrot, sav_viewrot );
    bn_mat_copy( toViewcenter, sav_toviewcenter );
a374 4

#ifdef DO_SCROLL_UPDATES
    set_scroll();
#endif
d382 3
a384 3
  sav_vscale = Viewscale;
  bn_mat_copy( sav_viewrot, Viewrot );
  bn_mat_copy( sav_toviewcenter, toViewcenter );
d391 1
a391 1
  if (adc_draw)  {
d393 1
a393 1
    adc_draw = 0;
d396 1
a396 1
    adc_draw = 1;
d399 1
a399 1
  set_scroll();
a407 4

#ifdef DO_SCROLL_UPDATES
  set_scroll();
#endif
d608 2
a609 2
	  if(dmlp->_mged_variables->transform == 'e')
	    dmlp->_mged_variables->transform = 'v';
d656 1
a656 1
	menuflag = 0;
d670 2
a671 2
	  if(dmlp->_mged_variables->transform == 'e')
	    dmlp->_mged_variables->transform = 'v';
d792 2
a793 2
      bn_mat_copy(o_toViewcenter, toViewcenter);
      o_Viewscale = Viewscale;
d797 1
a797 1
      MAT_DELTAS_GET_NEG(orig_pos, toViewcenter);
d800 2
a801 2
      bn_mat_copy(toViewcenter, o_toViewcenter);
      Viewscale = o_Viewscale;
d841 1
a841 1
		menuflag = 0;
@


11.55
log
@ADC variables are no longer mged_variables
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.54 1998/02/26 16:06:13 bparker Exp bparker $ (BRL)";
d247 1
a247 1
	for( menu=0, m=menu_array; m < &menu_array[NMENU]; m++,menu++ )  {
a579 1
	struct bu_vls vls;
d617 8
a624 3
	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "undo_edit_menu");
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
a630 1
	struct bu_vls vls;
d679 8
a686 3
	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "undo_edit_menu");
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
d821 1
a821 1
  bu_vls_strcpy(&vls, "mged_display(state)");
@


11.54
log
@*- mods to chg_state()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.53 1997/12/17 14:54:57 bparker Exp bparker $ (BRL)";
d188 2
a189 8
	if( edsol && edobj ){
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
d200 1
a200 8
	{
	  struct bu_vls tmp_vls;
	  
	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "button(%d):  Not a defined operation\n", bnum);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
d393 1
a393 1
  if (mged_variables->adcflag)  {
d395 1
a395 1
    mged_variables->adcflag = 0;
d398 1
a398 1
    mged_variables->adcflag = 1;
@


11.53
log
@mods to ill_common
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.52 1997/11/06 19:58:41 bparker Exp bparker $ (BRL)";
d39 1
d780 9
a788 6
	if( state != from ) {
	  Tcl_AppendResult(interp, "Unable to do <", str, "> going from ",
			   state_str[from], " to ", state_str[to], " state.\n", (char *)NULL);
	  return(1);	/* BAD */
	}
	state = to;
d790 2
a791 4
	{
	  register struct dm_list *p;
	  struct dm_list *save_dm_list;
	  point_t new_pos;
d793 23
a815 3
	  save_dm_list = curr_dm_list;
	  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
	    curr_dm_list = p;
d817 5
a821 18
	    if(state_hook)
	      state_hook( from, to );

	    if(to == ST_VIEW){
	      mat_t o_toViewcenter;
	      fastf_t o_Viewscale;

	      /* save toViewcenter and Viewscale */
	      bn_mat_copy(o_toViewcenter, toViewcenter);
	      o_Viewscale = Viewscale;

	      /* get new orig_pos */
	      size_reset();
	      MAT_DELTAS_GET_NEG(orig_pos, toViewcenter);

	      /* restore old toViewcenter and Viewscale */
	      bn_mat_copy(toViewcenter, o_toViewcenter);
	      Viewscale = o_Viewscale;
d823 1
a823 1
	    }
d825 4
a828 17
	    new_mats();

	    /* recompute absolute_tran */
	    set_absolute_tran();
	  }

	  curr_dm_list = save_dm_list;
	}

	{
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_strcpy(&vls, "mged_display(state)");
	  Tcl_SetVar(interp, bu_vls_addr(&vls), state_str[state], TCL_GLOBAL_ONLY);
	  bu_vls_free(&vls);
	}
d830 1
a830 1
	return(0);		/* GOOD */
@


11.52
log
@mods to update mged_variables->transform
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.51 1997/11/03 15:23:55 bparker Exp bparker $ (BRL)";
d385 4
d422 4
d449 1
@


11.51
log
@some clean up
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.50 1997/10/08 13:48:14 bparker Exp bparker $ (BRL)";
d582 1
d617 4
d629 1
d674 4
@


11.50
log
@mods to use Tcl_SetVar with vls strings
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.49 1997/09/08 19:04:49 bparker Exp bparker $ (BRL)";
a395 3
#if 0
  dmp->dm_light( dmp, LIGHT_ON, BV_VRESTORE );
#endif
a403 3
#if 0
    dmp->dm_light( dmp, LIGHT_OFF, BV_ADCURSOR );
#endif
a406 3
#if 0
    dmp->dm_light( dmp, LIGHT_ON, BV_ADCURSOR );
#endif
a434 3
#if 0
	dmp->dm_light( dmp, LIGHT_ON, BE_REJECT );
#endif
a445 3
#if 0
	update_views = 1;
#endif
a453 3
#if 0
	dmp->dm_light( dmp, LIGHT_ON, BE_O_ILLUMINATE );
#endif
a455 3
#if 0
		new_mats();
#endif
a461 4

#if 0
	update_views = 1;
#endif
d478 1
a478 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edobj );
	dmp->dm_light( dmp, LIGHT_ON, edobj = BE_O_SCALE );
#endif
a493 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edobj );
	dmp->dm_light( dmp, LIGHT_ON, edobj = BE_O_XSCALE );
#endif
a508 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edobj );
	dmp->dm_light( dmp, LIGHT_ON, edobj = BE_O_YSCALE );
#endif
a523 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edobj );
	dmp->dm_light( dmp, LIGHT_ON, edobj = BE_O_ZSCALE );
#endif
a538 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edobj );
	dmp->dm_light( dmp, LIGHT_ON, edobj = BE_O_X );
#endif
a549 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edobj );
	dmp->dm_light( dmp, LIGHT_ON, edobj = BE_O_Y );
#endif
a561 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edobj );
	dmp->dm_light( dmp, LIGHT_ON, edobj = BE_O_XY );
#endif
a572 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edobj );
	dmp->dm_light( dmp, LIGHT_ON, edobj = BE_O_ROTATE );
#endif
a585 5
#if 0
		dmp->dm_light( dmp, LIGHT_OFF, BE_ACCEPT );
		dmp->dm_light( dmp, LIGHT_OFF, BE_REJECT );
		dmp->dm_light( dmp, LIGHT_OFF, edsol );
#endif
a591 3
#if 0
		dmp->dm_light( dmp, LIGHT_OFF, BE_S_EDIT );
#endif
a597 3
#if 0
		dmp->dm_colorchange(dmp);
#endif
a600 5
#if 0
		dmp->dm_light( dmp, LIGHT_OFF, BE_ACCEPT );
		dmp->dm_light( dmp, LIGHT_OFF, BE_REJECT );
		dmp->dm_light( dmp, LIGHT_OFF, edobj );
#endif
a609 3
#if 0
		dmp->dm_colorchange(dmp);
#endif
a628 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, BE_ACCEPT );
	dmp->dm_light( dmp, LIGHT_OFF, BE_REJECT );
#endif
a636 5
#if 0
		if( edsol )
			dmp->dm_light( dmp, LIGHT_OFF, edsol );
#endif

a643 7
#if 0
		if( edobj )
			dmp->dm_light( dmp, LIGHT_OFF, edobj );
#endif
#if 0
		mmenu_set( MENU_L1, MENU_NULL );
#endif
a648 4
#if 0
		dmp->dm_light( dmp, LIGHT_OFF, BE_O_ILLUMINATE );
#endif

a650 4
#if 0
		dmp->dm_light( dmp, LIGHT_OFF, BE_S_ILLUMINATE );
#endif

a666 3
#if 0
	dmp->dm_colorchange(dmp);
#endif
@


11.49
log
@*- new macro ---> FOR_ALL_DISPLAYS
*- mged_variables is now a pointer
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.48 1997/07/31 14:46:17 bparker Exp bparker $ (BRL)";
d908 8
a915 2
	Tcl_SetVar(interp, "mged_display(state)", state_str[state],
		    TCL_GLOBAL_ONLY);
@


11.48
log
@mods to chg_state()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.47 1997/07/25 20:49:45 bparker Exp bparker $ (BRL)";
d328 1
a328 1
  mged_variables.rateknobs = !mged_variables.rateknobs;
d404 1
a404 1
  if (mged_variables.adcflag)  {
d406 1
a406 1
    mged_variables.adcflag = 0;
d412 1
a412 1
    mged_variables.adcflag = 1;
d875 1
a875 1
	  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
a877 4
#if 0
	    /* Advise display manager of state change */
	    dmp->dm_statechange( from, to );
#else
a879 1
#endif
@


11.47
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.46 1997/07/17 20:53:15 bparker Exp bparker $ (BRL)";
d165 1
a165 1
static struct menu_item oed_menu[] = {
d912 3
@


11.46
log
@*- support for new interface edit menus
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.45 1997/06/25 13:43:29 bparker Exp bparker $ (BRL)";
a787 11
#if 0
	build_tcl_edit_menu();

	bn_mat_idn(acc_rot_sol);
	VSETALL( edit_absolute_rotate, 0.0 );
	VSETALL( edit_absolute_tran, 0.0 );
	edit_absolute_scale = 0;
	acc_sc_sol = 1;

	set_e_axes_pos(1);
#endif
@


11.45
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.44 1997/05/29 14:03:34 bparker Exp bparker $ (BRL)";
d493 1
a493 3
#if 0
	dmp->dm_light( dmp, LIGHT_ON, BE_S_ILLUMINATE );
#endif
a495 3
#if 0
		new_mats();
#endif
a496 3
#if 0
	update_views = 1;
#endif
a585 1

a600 1

a616 1

a631 1

d638 1
d690 4
d699 1
d770 4
d786 2
d789 1
a789 2
	if( edsol )
		dmp->dm_light( dmp, LIGHT_OFF, edsol );
d791 5
a795 4
	dmp->dm_light( dmp, LIGHT_ON, edsol = BE_S_EDIT );
#endif
	edsol = BE_S_EDIT;
	sedit_menu();		/* Install appropriate menu */
d798 1
d807 1
a807 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edsol );
	dmp->dm_light( dmp, LIGHT_ON, edsol = BE_S_ROTATE );
#endif
a809 2
	es_edflag = SROT;
	bn_mat_idn(acc_rot_sol);
a819 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edsol );
	dmp->dm_light( dmp, LIGHT_ON, edsol = BE_S_TRANS );
#endif
d824 1
a833 4
#if 0
	dmp->dm_light( dmp, LIGHT_OFF, edsol );
	dmp->dm_light( dmp, LIGHT_ON, edsol = BE_S_SCALE );
#endif
d838 1
@


11.44
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.43 1997/04/23 18:30:43 bparker Exp bparker $ (BRL)";
d43 1
a67 2
static void bv_edit_toggle(), bv_eyerot_toggle();
static void be_s_context();
a111 3
#if 0
	BE_S_CONTEXT,   "context",      be_s_context,
#endif
a115 2
	BV_EDIT_TOGGLE, "edit",		bv_edit_toggle,
	BV_EYEROT_TOGGLE, "eyerot",     bv_eyerot_toggle,
a149 2
	{ "Edit/View", btn_item_hit, BV_EDIT_TOGGLE },
	{ "Rotate About Eye", btn_item_hit, BV_EYEROT_TOGGLE },
a161 3
#if 0
	{ "Context", btn_item_hit, BE_S_CONTEXT },
#endif
a325 7
bv_edit_toggle()
{
  mged_variables.edit = !mged_variables.edit;
  set_scroll();
}

static void
a332 15
bv_eyerot_toggle()
{
  mged_variables.eyerot = !mged_variables.eyerot;

  ++dmaflag;
}

static void
be_s_context()
{
  mged_variables.context = !mged_variables.context;
  set_scroll();
}

static void
d917 1
a917 1
	      MAT_DELTAS_GET(orig_pos, toViewcenter);
d927 2
a928 3
	    /* recompute absolute_slew */
	    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
	    MAT4X3PNT(absolute_slew, model2view, new_pos);
a988 5

#if 0
	if(mged_variables.show_menu)
	  dmaflag = 1;
#endif
@


11.43
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.42 1997/03/07 21:37:37 bparker Exp bparker $ (BRL)";
d137 1
a137 1
	{ "(BUTTON MENU)", btn_head_menu, 1 },		/* chg to 2nd menu */
@


11.42
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.41 1997/02/28 21:36:58 bparker Exp bparker $ (BRL)";
a35 2
#include "./menu.h"
#include "./scroll.h"
@


11.41
log
@call mmenu_set_all instead of mmenu_set.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.40 1997/02/04 22:15:01 bparker Exp bparker $ (BRL)";
d493 1
d495 1
d509 1
d511 1
d519 1
d521 1
d533 1
d535 1
d537 1
a537 1

d539 1
@


11.40
log
@link mged_rotate_view_around_eye to a faceplate button
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.39 1997/02/03 15:27:00 bparker Exp bparker $ (BRL)";
a676 1
	mmenu_set( MENU_L2, MENU_NULL );
d688 2
a689 2
		mmenu_set( MENU_L1, MENU_NULL );
		mmenu_set( MENU_L2, MENU_NULL );
d715 2
d753 2
a754 2
		mmenu_set( MENU_L1, MENU_NULL );
		mmenu_set( MENU_L2, MENU_NULL );
d764 1
a764 1

d766 2
a767 1
		mmenu_set( MENU_L2, MENU_NULL );
d1027 1
a1027 1
		mmenu_set( MENU_L2, sed_menu );
d1030 1
a1030 1
		mmenu_set( MENU_L2, oed_menu );
@


11.39
log
@mods to bv_zoomin and bv_zoomout
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.38 1997/01/29 05:37:06 mike Exp bparker $ (BRL)";
d69 1
a69 1
void bv_edit_toggle();
d123 1
d159 1
d338 1
a338 1
void
d353 8
d418 2
@


11.38
log
@Don't need db.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.37 1997/01/24 20:58:12 bparker Exp $ (BRL)";
d327 1
a327 1
  (void)mged_zoom(0.5);
d333 1
a333 1
  (void)mged_zoom(2.0);
@


11.37
log
@mods to update sliders
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.36 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
a31 1
#include "db.h"
@


11.36
log
@checkin for weekend
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.35 1997/01/08 19:45:35 bparker Exp bparker $ (BRL)";
d42 1
d45 1
d341 1
a341 5

  if(mged_variables.scroll_enabled)
    Tcl_Eval(interp, "sliders on");

  dmaflag = 1;
d348 1
a348 5

  if(mged_variables.scroll_enabled)
    Tcl_Eval(interp, "sliders on");

  dmaflag = 1;
d355 1
a355 5

  if(mged_variables.scroll_enabled)
    Tcl_Eval(interp, "sliders on");

  dmaflag = 1;
d442 1
a442 14
  if(mged_variables.scroll_enabled){
#if 0
    char *av[3];

    av[0] = "sliders";
    av[1] = "on";
    av[2] = NULL;
    (void)cmd_sliders((ClientData)NULL, interp, 2, av);
#else
    Tcl_Eval(interp, "sliders on");
#endif
  }
  
  dmaflag = 1;
a448 1
  MAT_DELTAS_GET(orig_pos, toViewcenter);
d450 1
a450 3
  absolute_zoom = 0.0;
  VSETALL( absolute_rotate, 0.0 );
  VSETALL( absolute_slew, 0.0 );
@


11.35
log
@make calls to mged_zoom() from bv_zoomin/out
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.34 1997/01/02 19:38:47 bparker Exp bparker $ (BRL)";
d340 1
a340 1
  if(mged_variables.scroll_enabled){
a341 1
  }
d351 1
a351 1
  if(mged_variables.scroll_enabled){
a352 1
  }
d362 1
a362 1
  if(mged_variables.scroll_enabled){
a363 1
  }
d368 5
a372 3
static void bv_top()  {
	/* Top view */
	setview( 0.0, 0.0, 0.0 );
d375 5
a379 3
static void bv_bottom()  {
	/* Bottom view */
	setview( 180.0, 0.0, 0.0 );
d382 5
a386 3
static void bv_right()  {
	/* Right view */
	setview( 270.0, 0.0, 0.0 );
d389 5
a393 3
static void bv_left()  {
	/* Left view */
	setview( 270.0, 0.0, 180.0 );
d396 5
a400 3
static void bv_front()  {
	/* Front view */
	setview( 270.0, 0.0, 270.0 );
d403 5
a407 3
static void bv_rear()  {
	/* Rear view */
	setview( 270.0, 0.0, 90.0 );
d410 10
a419 8
static void bv_vrestore()  {
	/* restore to saved view */
	if ( vsaved )  {
		Viewscale = sav_vscale;
		bn_mat_copy( Viewrot, sav_viewrot );
		bn_mat_copy( toViewcenter, sav_toviewcenter );
		new_mats();
	}
d422 8
a429 6
static void bv_vsave()  {
	/* save current view */
	sav_vscale = Viewscale;
	bn_mat_copy( sav_viewrot, Viewrot );
	bn_mat_copy( sav_toviewcenter, toViewcenter );
	vsaved = 1;
d431 1
a431 1
	dmp->dm_light( dmp, LIGHT_ON, BV_VRESTORE );
d435 6
a440 4
static void bv_adcursor()  {
	if (mged_variables.adcflag)  {
		/* Was on, turn off */
		mged_variables.adcflag = 0;
d442 1
a442 1
		dmp->dm_light( dmp, LIGHT_OFF, BV_ADCURSOR );
d444 3
a446 3
	}  else  {
		/* Was off, turn on */
		mged_variables.adcflag = 1;
d448 1
a448 1
		dmp->dm_light( dmp, LIGHT_ON, BV_ADCURSOR );
d450 1
a450 1
	}
d452 3
a454 2
	if(mged_variables.scroll_enabled){
	  char *av[3];
d456 10
a465 7
	  av[0] = "sliders";
	  av[1] = "on";
	  av[2] = NULL;
	  (void)cmd_sliders((ClientData)NULL, interp, 2, av);
	}

	dmaflag = 1;
d468 9
a476 7
static void bv_reset()  {
	/* Reset view such that all solids can be seen */
	size_reset();
	setview( 0.0, 0.0, 0.0 );
	absolute_zoom = 0.0;
	VSETALL( absolute_rotate, 0.0 );
	VSETALL( absolute_slew, 0.0 );
d479 3
a481 2
static void bv_45_45()  {
	setview( 270.0+45.0, 0.0, 270.0-45.0 );
d484 4
a487 3
static void bv_35_25()  {
	/* Use Azmuth=35, Elevation=25 in GIFT's backwards space */
	setview( 270.0+25.0, 0.0, 270.0-35.0 );
@


11.34
log
@mods to use libbn and libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.33 1996/12/30 22:38:28 bparker Exp bparker $ (BRL)";
d43 1
d323 2
a324 1
static void bv_zoomin()
d326 1
a326 2
	Viewscale *= 0.5;
	new_mats();
d329 2
a330 1
static void bv_zoomout()
d332 1
a332 2
	Viewscale *= 2;
	new_mats();
@


11.33
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.32 1996/12/20 22:53:10 bparker Exp bparker $ (BRL)";
d404 2
a405 2
		mat_copy( Viewrot, sav_viewrot );
		mat_copy( toViewcenter, sav_toviewcenter );
d413 2
a414 2
	mat_copy( sav_viewrot, Viewrot );
	mat_copy( sav_toviewcenter, toViewcenter );
d482 1
a482 1
	mat_idn( modelchanges );	/* No changes yet */
d828 1
a828 1
	mat_idn(acc_rot_sol);
d927 1
a927 1
	      mat_copy(o_toViewcenter, toViewcenter);
d935 1
a935 1
	      mat_copy(toViewcenter, o_toViewcenter);
@


11.32
log
@add parameter to set_e_axes_pos()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.31 1996/12/13 23:10:54 bparker Exp bparker $ (BRL)";
d68 1
d113 3
d139 1
a139 1
static struct menu_item second_menu[] = {
d162 1
a162 1
static struct menu_item sed_menu[] = {
d168 3
d346 2
a347 1
static void bv_rate_toggle()
d350 12
@


11.31
log
@weekend checkin
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.30 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d515 1
a515 1
	set_e_axes_pos();
d534 1
a534 1
	set_e_axes_pos();
d553 1
a553 1
	set_e_axes_pos();
d572 1
a572 1
	set_e_axes_pos();
d592 1
a592 1
	set_e_axes_pos();
d608 1
a608 1
	set_e_axes_pos();
d625 1
a625 1
	set_e_axes_pos();
d641 1
a641 1
	set_e_axes_pos();
d792 1
a792 1
	set_e_axes_pos();
d810 1
a810 1
        set_e_axes_pos();
d827 1
a827 1
        set_e_axes_pos();
d844 1
a844 1
        set_e_axes_pos();
@


11.30
log
@experimentation
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.29 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d64 1
d67 2
a68 1
static void bv_zoomin(), bv_zoomout(), bv_rate_toggle(), bv_edit_toggle();
d327 1
a327 1
static void
d483 3
d515 5
d534 5
d553 5
d572 5
@


11.29
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.28 1996/11/19 21:43:44 bparker Exp bparker $ (BRL)";
d41 2
@


11.28
log
@set edobj and edsol
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.27 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d64 1
a64 1
static void bv_zoomin(), bv_zoomout(), bv_rate_toggle();
d112 1
d147 1
d323 12
a339 8
#if 0
    char *av[3];

    av[0] = "sliders";
    av[1] = "on";
    av[2] = NULL;
    (void)cmd_sliders((ClientData)NULL, interp, 2, av);
#else
a340 1
#endif
@


11.27
log
@hacks to use latest libdm
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.26 1996/10/18 13:53:51 bparker Exp $ (BRL)";
d326 1
d333 3
d500 1
d514 1
d528 1
d542 1
d556 1
d559 2
d572 1
d575 2
d589 1
d592 2
d605 1
d608 2
d757 1
a757 1

d773 1
a773 1

d791 1
a791 1

d808 1
a808 1

@


11.26
log
@call color_soltab before calling dmr_colorchange
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.25 1996/10/04 14:55:17 bparker Exp bparker $ (BRL)";
d383 3
a385 1
	dmp->dmr_light( dmp, LIGHT_ON, BV_VRESTORE );
d392 3
a394 1
		dmp->dmr_light( dmp, LIGHT_OFF, BV_ADCURSOR );
d398 3
a400 1
		dmp->dmr_light( dmp, LIGHT_ON, BV_ADCURSOR );
d437 3
a439 1
	dmp->dmr_light( dmp, LIGHT_ON, BE_REJECT );
d460 3
a462 1
	dmp->dmr_light( dmp, LIGHT_ON, BE_O_ILLUMINATE );
d477 3
a479 2

	dmp->dmr_light( dmp, LIGHT_ON, BE_S_ILLUMINATE );
d492 4
a495 3

	dmp->dmr_light( dmp, LIGHT_OFF, edobj );
	dmp->dmr_light( dmp, LIGHT_ON, edobj = BE_O_SCALE );
d505 4
a508 2
	dmp->dmr_light( dmp, LIGHT_OFF, edobj );
	dmp->dmr_light( dmp, LIGHT_ON, edobj = BE_O_XSCALE );
d518 4
a521 2
	dmp->dmr_light( dmp, LIGHT_OFF, edobj );
	dmp->dmr_light( dmp, LIGHT_ON, edobj = BE_O_YSCALE );
d531 4
a534 2
	dmp->dmr_light( dmp, LIGHT_OFF, edobj );
	dmp->dmr_light( dmp, LIGHT_ON, edobj = BE_O_ZSCALE );
d544 4
a547 2
	dmp->dmr_light( dmp, LIGHT_OFF, edobj );
	dmp->dmr_light( dmp, LIGHT_ON, edobj = BE_O_X );
d557 4
a560 2
	dmp->dmr_light( dmp, LIGHT_OFF, edobj );
	dmp->dmr_light( dmp, LIGHT_ON, edobj = BE_O_Y );
d571 4
a574 2
	dmp->dmr_light( dmp, LIGHT_OFF, edobj );
	dmp->dmr_light( dmp, LIGHT_ON, edobj = BE_O_XY );
d584 4
a587 2
	dmp->dmr_light( dmp, LIGHT_OFF, edobj );
	dmp->dmr_light( dmp, LIGHT_ON, edobj = BE_O_ROTATE );
d599 5
a603 3
		dmp->dmr_light( dmp, LIGHT_OFF, BE_ACCEPT );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_REJECT );
		dmp->dmr_light( dmp, LIGHT_OFF, edsol );
d610 3
a612 1
		dmp->dmr_light( dmp, LIGHT_OFF, BE_S_EDIT );
d619 3
a621 1
		dmp->dmr_colorchange(dmp);
d625 5
a629 3
		dmp->dmr_light( dmp, LIGHT_OFF, BE_ACCEPT );
		dmp->dmr_light( dmp, LIGHT_OFF, BE_REJECT );
		dmp->dmr_light( dmp, LIGHT_OFF, edobj );
d637 3
a639 1
		dmp->dmr_colorchange(dmp);
d654 4
a657 2
	dmp->dmr_light( dmp, LIGHT_OFF, BE_ACCEPT );
	dmp->dmr_light( dmp, LIGHT_OFF, BE_REJECT );
d666 1
d668 2
a669 1
			dmp->dmr_light( dmp, LIGHT_OFF, edsol );
d678 1
d680 2
a681 1
			dmp->dmr_light( dmp, LIGHT_OFF, edobj );
d689 3
a691 1
		dmp->dmr_light( dmp, LIGHT_OFF, BE_O_ILLUMINATE );
d695 3
a697 1
		dmp->dmr_light( dmp, LIGHT_OFF, BE_S_ILLUMINATE );
d715 3
a717 1
	dmp->dmr_colorchange(dmp);
d731 1
d733 1
a733 1
		dmp->dmr_light( dmp, LIGHT_OFF, edsol );
d735 2
a736 1
	dmp->dmr_light( dmp, LIGHT_ON, edsol = BE_S_EDIT );
d749 4
a752 2
	dmp->dmr_light( dmp, LIGHT_OFF, edsol );
	dmp->dmr_light( dmp, LIGHT_ON, edsol = BE_S_ROTATE );
d767 4
a770 2
	dmp->dmr_light( dmp, LIGHT_OFF, edsol );
	dmp->dmr_light( dmp, LIGHT_ON, edsol = BE_S_TRANS );
d784 4
a787 2
	dmp->dmr_light( dmp, LIGHT_OFF, edsol );
	dmp->dmr_light( dmp, LIGHT_ON, edsol = BE_S_SCALE );
d842 1
d844 5
a848 1
	    dmp->dmr_statechange( from, to );
@


11.25
log
@call vls_col_XXXX functions instead of col_XXXX
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.24 1996/10/03 20:22:42 bparker Exp bparker $ (BRL)";
d588 1
d602 1
d668 1
@


11.24
log
@get rid of extra cmdline() uses
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.23 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d233 11
a243 4
		for( bp = button_table; bp->bu_code >= 0; bp++ )
			col_item(bp->bu_name);
		col_eol();
		return;
@


11.23
log
@now using more generalized solid macros
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.22 1996/09/23 18:37:58 bparker Exp bparker $ (BRL)";
d319 1
a319 1
    struct bu_vls cmd;
d321 4
a324 4
    bu_vls_init(&cmd);
    bu_vls_strcpy( &cmd, "sliders on\n");
    (void)cmdline(&cmd, False);
    bu_vls_free(&cmd);
d391 1
a391 1
	  struct bu_vls cmd;
d393 4
a396 4
	  bu_vls_init(&cmd);
	  bu_vls_strcpy( &cmd, "sliders on\n");
	  (void)cmdline(&cmd, False);
	  bu_vls_free(&cmd);
@


11.22
log
@ use LIBDM permanently
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.21 1996/09/17 21:20:27 bparker Exp bparker $ (BRL)";
d36 1
a36 1
#include "./solid.h"
d425 1
a425 1
	if( HeadSolid.s_forw == &HeadSolid )  {
d429 2
a430 1
	illump = HeadSolid.s_forw;/* any valid solid would do */
d577 1
a577 1
		FOR_ALL_SOLIDS( sp )
d657 1
a657 1
	FOR_ALL_SOLIDS( sp )
@


11.21
log
@prepare to use libdm
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.20 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d39 1
a39 1
#include "./dm.h"
a118 1
#ifdef USE_LIBDM
a119 1
#endif
a375 1
#ifdef USE_LIBDM
a376 3
#else
	dmp->dmr_light( LIGHT_ON, BV_VRESTORE );
#endif
a382 1
#ifdef USE_LIBDM
a383 3
#else
		dmp->dmr_light( LIGHT_OFF, BV_ADCURSOR );
#endif
a386 1
#ifdef USE_LIBDM
a387 3
#else
		dmp->dmr_light( LIGHT_ON, BV_ADCURSOR );
#endif
a423 1
#ifdef USE_LIBDM
a424 3
#else
	dmp->dmr_light( LIGHT_ON, BE_REJECT );
#endif
a443 1
#ifdef USE_LIBDM
a444 3
#else
	dmp->dmr_light( LIGHT_ON, BE_O_ILLUMINATE );
#endif
a459 1
#ifdef USE_LIBDM
a460 3
#else
	dmp->dmr_light( LIGHT_ON, BE_S_ILLUMINATE );
#endif
a473 1
#ifdef USE_LIBDM
a475 4
#else
	dmp->dmr_light( LIGHT_OFF, edobj );
	dmp->dmr_light( LIGHT_ON, edobj = BE_O_SCALE );
#endif
a484 1
#ifdef USE_LIBDM
a486 4
#else
	dmp->dmr_light( LIGHT_OFF, edobj );
	dmp->dmr_light( LIGHT_ON, edobj = BE_O_XSCALE );
#endif
a495 1
#ifdef USE_LIBDM
a497 4
#else
	dmp->dmr_light( LIGHT_OFF, edobj );
	dmp->dmr_light( LIGHT_ON, edobj = BE_O_YSCALE );
#endif
a506 1
#ifdef USE_LIBDM
a508 4
#else
	dmp->dmr_light( LIGHT_OFF, edobj );
	dmp->dmr_light( LIGHT_ON, edobj = BE_O_ZSCALE );
#endif
a517 1
#ifdef USE_LIBDM
a519 4
#else
	dmp->dmr_light( LIGHT_OFF, edobj );
	dmp->dmr_light( LIGHT_ON, edobj = BE_O_X );
#endif
a528 1
#ifdef USE_LIBDM
a530 4
#else
	dmp->dmr_light( LIGHT_OFF, edobj );
	dmp->dmr_light( LIGHT_ON, edobj = BE_O_Y );
#endif
a540 1
#ifdef USE_LIBDM
a542 4
#else
	dmp->dmr_light( LIGHT_OFF, edobj );
	dmp->dmr_light( LIGHT_ON, edobj = BE_O_XY );
#endif
a551 1
#ifdef USE_LIBDM
a553 4
#else
	dmp->dmr_light( LIGHT_OFF, edobj );
	dmp->dmr_light( LIGHT_ON, edobj = BE_O_ROTATE );
#endif
a564 1
#ifdef USE_LIBDM
a567 5
#else
		dmp->dmr_light( LIGHT_OFF, BE_ACCEPT );
		dmp->dmr_light( LIGHT_OFF, BE_REJECT );
		dmp->dmr_light( LIGHT_OFF, edsol );
#endif
a573 1
#ifdef USE_LIBDM
a574 3
#else
		dmp->dmr_light( LIGHT_OFF, BE_S_EDIT );
#endif
a579 1
#ifdef USE_LIBDM
a580 3
#else
		dmp->dmr_colorchange();
#endif
a583 1
#ifdef USE_LIBDM
a586 5
#else
		dmp->dmr_light( LIGHT_OFF, BE_ACCEPT );
		dmp->dmr_light( LIGHT_OFF, BE_REJECT );
		dmp->dmr_light( LIGHT_OFF, edobj );
#endif
a592 1
#ifdef USE_LIBDM
a593 3
#else
		dmp->dmr_colorchange();
#endif
a607 1
#ifdef USE_LIBDM
a609 4
#else
	dmp->dmr_light( LIGHT_OFF, BE_ACCEPT );
	dmp->dmr_light( LIGHT_OFF, BE_REJECT );
#endif
a618 1
#ifdef USE_LIBDM
d620 1
a620 3
#else
			dmp->dmr_light( LIGHT_OFF, edsol );
#endif
a628 1
#ifdef USE_LIBDM
d630 1
a630 3
#else
			dmp->dmr_light( LIGHT_OFF, edobj );
#endif
a636 1
#ifdef USE_LIBDM
d638 1
a638 3
#else
		dmp->dmr_light( LIGHT_OFF, BE_O_ILLUMINATE );
#endif
a640 1
#ifdef USE_LIBDM
d642 1
a642 3
#else
		dmp->dmr_light( LIGHT_OFF, BE_S_ILLUMINATE );
#endif
a657 1
#ifdef USE_LIBDM
a658 3
#else
	dmp->dmr_colorchange();
#endif
a672 1
#ifdef USE_LIBDM
d674 1
d676 1
a676 4
#else
		dmp->dmr_light( LIGHT_OFF, edsol );
	dmp->dmr_light( LIGHT_ON, edsol = BE_S_EDIT );
#endif
a687 1
#ifdef USE_LIBDM
d690 1
a690 4
#else
	dmp->dmr_light( LIGHT_OFF, edsol );
	dmp->dmr_light( LIGHT_ON, edsol = BE_S_ROTATE );
#endif
a703 1
#ifdef USE_LIBDM
d706 1
a706 4
#else
	dmp->dmr_light( LIGHT_OFF, edsol );
	dmp->dmr_light( LIGHT_ON, edsol = BE_S_TRANS );
#endif
a718 1
#ifdef USE_LIBDM
d721 1
a721 4
#else
	dmp->dmr_light( LIGHT_OFF, edsol );
	dmp->dmr_light( LIGHT_ON, edsol = BE_S_SCALE );
#endif
@


11.20
log
@rt_list ---> bu_list
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.19 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d119 3
d378 3
d382 1
d389 3
d393 1
d397 3
d401 1
d438 3
d442 1
d462 3
d466 1
d482 3
d486 1
d500 4
d506 1
d516 4
d522 1
d532 4
d538 1
d548 4
d554 1
d564 4
d570 1
d580 4
d586 1
d597 4
d603 1
d613 4
d619 1
d631 5
d639 1
d646 3
d650 1
d656 3
d660 1
d664 5
d672 1
d679 3
d683 1
d698 4
d704 1
d714 3
d718 1
d727 3
d731 1
d738 3
d742 1
d745 3
d749 1
d765 3
d769 1
d784 4
d790 1
d802 4
d808 1
d822 4
d828 1
d841 4
d847 1
@


11.19
log
@now using libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.18 1996/08/21 14:26:42 jra Exp bparker $ (BRL)";
d30 1
d762 1
a762 1
	  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
@


11.18
log
@Minor mod for IRIX 6.2.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.17 1996/08/13 14:20:43 bparker Exp jra $ (BRL)";
d182 1
a182 1
	  struct rt_vls tmp_vls;
d184 4
a187 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d200 1
a200 1
	  struct rt_vls tmp_vls;
d202 4
a205 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "button(%d):  Not a defined operation\n", bnum);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d222 1
a222 1
	  struct rt_vls tmp_vls;
d224 4
a227 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d289 1
a289 1
	  struct rt_vls tmp_vls;
d291 4
a294 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "label_button(%d):  Not a defined operation\n", bnum);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d317 1
a317 1
    struct rt_vls cmd;
d319 2
a320 2
    rt_vls_init(&cmd);
    rt_vls_strcpy( &cmd, "sliders on\n");
d322 1
a322 1
    rt_vls_free(&cmd);
d389 1
a389 1
	  struct rt_vls cmd;
d391 2
a392 2
	  rt_vls_init(&cmd);
	  rt_vls_strcpy( &cmd, "sliders on\n");
d394 1
a394 1
	  rt_vls_free(&cmd);
d840 1
a840 1
	    struct rt_vls tmp_vls;
d842 4
a845 4
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "btn_head_menu(%d): bad arg\n", i);
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d868 1
a868 1
	    struct rt_vls tmp_vls;
d870 4
a873 4
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "chg_l2menu(%d): bad arg\n", i);
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
@


11.17
log
@update slider variables when resetting the view size
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.16 1996/07/30 21:32:52 bparker Exp bparker $ (BRL)";
d46 1
a46 1
static	edsol;
@


11.16
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.15 1996/07/11 19:26:54 bparker Exp bparker $ (BRL)";
d404 3
@


11.15
log
@recompute absolute_slew
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.14 1996/06/28 20:53:16 bparker Exp bparker $ (BRL)";
d668 1
a668 1
	set_e_axis_pos();
d683 1
a683 1
        set_e_axis_pos();
d697 1
a697 1
        set_e_axis_pos();
d711 1
a711 1
        set_e_axis_pos();
@


11.14
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.13 1996/05/24 19:08:46 bparker Exp bparker $ (BRL)";
d755 1
d779 1
d783 4
@


11.13
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.12 1996/04/18 20:26:00 bparker Exp bparker $ (BRL)";
d314 12
a325 4
	mged_variables.rateknobs = !mged_variables.rateknobs;
	rt_vls_printf( &dm_values.dv_string, "set sliders(rate) %d; sliders %s\n",
		       mged_variables.rateknobs, scroll_enabled ? "on" : "off");
	dmaflag = 1;
d378 1
a378 1
	if (adcflag)  {
d380 1
a380 1
		adcflag = 0;
d384 1
a384 1
		adcflag = 1;
d388 9
a396 2
	rt_vls_printf( &dm_values.dv_string, "set sliders(adc) %d; sliders %s\n",
		       adcflag, scroll_enabled ? "on" : "off");
d803 2
a804 1
void btn_item_hit(arg, menu, item)  {
@


11.12
log
@convert commands to Tcl
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.11 1996/03/22 18:36:23 bparker Exp bparker $ (BRL)";
d315 2
d380 2
@


11.11
log
@cleanup
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.10 1996/03/01 19:34:30 bparker Exp bparker $ (BRL)";
d181 2
a182 2
	if( edsol && edobj )
		(void)rt_log("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
d184 6
d199 8
a206 1
	(void)rt_log("button(%d):  Not a defined operation\n", bnum);
d221 8
a228 2
	if( edsol && edobj )
		(void)rt_log("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
d266 2
a267 2
	rt_log("press(%s):  Unknown operation, type 'press help' for help\n",
	       str);
d287 10
a296 1
	(void)rt_log("label_button(%d):  Not a defined operation\n", bnum);
d402 2
a403 2
		(void)rt_log("no solids in view\n");
		return(0);	/* BAD */
d706 7
a712 6
	if( state != desired ) {
		(void)rt_log("Unable to do <%s> from %s state.\n",
			str, state_str[state] );
		return(1);	/* BAD */
	}
	return(0);		/* GOOD */
d727 3
a729 3
		(void)rt_log("Unable to do <%s> going from %s to %s state.\n",
			str, state_str[from], state_str[to] );
		return(1);	/* BAD */
d774 2
a775 2
	(void)rt_log("Unable to do <%s> from %s state.\n",
		str, state_str[state] );
d810 10
a819 2
		rt_log("btn_head_menu(%d): bad arg\n", i);
		break;
d838 10
a847 2
		(void)rt_log("chg_l2menu(%d): bad arg\n");
		break;
@


11.10
log
@remove unused XMGED stuff,
add MULTI_ATTACH and VIRTUAL_TRACKBALL stuff
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.9 1996/01/17 22:10:04 bparker Exp bparker $ (BRL)";
a40 4
#ifndef MULTI_ATTACH
int	adcflag;	/* angle/distance cursor in use */
#endif

a242 2
		    if(mged_variables.show_menu)
		      dmaflag = 1;
a275 1
	dmaflag = 1;
a281 1
	dmaflag = 1;
a326 1
		dmaflag++;
d369 2
a370 1
static int ill_common()  {
d382 1
a382 2
	dmaflag++;
#ifdef MULTI_ATTACH
a383 1
#endif
d387 2
a388 1
static void be_o_illuminate()  {
d399 2
d403 2
a404 1
static void be_s_illuminate()  {
d413 2
d417 2
a418 1
static void be_o_scale()  {
d425 1
a425 1
	dmaflag++;
d428 2
a429 1
static void be_o_xscale()  {
d436 1
a436 1
	dmaflag++;
d439 2
a440 1
static void be_o_yscale()  {
d447 1
a447 1
	dmaflag++;
d450 2
a451 1
static void be_o_zscale()  {
d458 1
a458 1
	dmaflag++;
d461 2
a462 1
static void be_o_x()  {
d469 1
a469 1
	dmaflag++;
d472 2
a473 1
static void be_o_y()  {
d480 1
a480 1
	dmaflag++;
d484 2
a485 1
static void be_o_xy()  {
d492 1
a492 1
	dmaflag++;
d495 2
a496 1
static void be_o_rotate()  {
d503 1
a503 1
	dmaflag++;
d506 2
a507 1
static void be_accept()  {
a509 4
#ifdef MULTI_ATTACH
	update_views = 1;
#endif

a529 1
		dmaflag = 1;		/* show completion */
a542 1
		dmaflag = 1;		/* show completion */
d549 2
a550 1
static void be_reject()  {
a552 1
#ifdef MULTI_ATTACH
a553 1
#endif
a597 1
	dmaflag = 1;
d606 2
a607 1
static void bv_slicemode() {
d610 2
a611 1
static void be_s_edit()  {
d620 1
a620 1
	dmaflag++;
d624 2
a625 1
static void be_s_rotate()  {
d635 1
a635 1
	dmaflag++;
d639 2
a640 1
static void be_s_trans()  {
a649 1
	dmaflag++;
d653 2
a654 1
static void be_s_scale()  {
a663 1
	dmaflag++;
a703 1
#ifdef MULTI_ATTACH
d714 1
a714 1
#ifdef VIRTUAL_TRACKBALL
a730 1
#endif
a736 23
#else
	/* Advise display manager of state change */
	dmp->dmr_statechange( from, to );

#ifdef VIRTUAL_TRACKBALL
	if(to == ST_VIEW){
	  mat_t o_toViewcenter;
	  fastf_t o_Viewscale;

	  /* save toViewcenter and Viewscale */
	  mat_copy(o_toViewcenter, toViewcenter);
	  o_Viewscale = Viewscale;

	  /* get new orig_pos */
	  size_reset();
	  MAT_DELTAS_GET(orig_pos, toViewcenter);

	  /* restore old toViewcenter and Viewscale */
	  mat_copy(toViewcenter, o_toViewcenter);
	  Viewscale = o_Viewscale;
	}
#endif
#endif
d785 1
d788 1
@


11.9
log
@using mged_variables.show_menu instead of ignore_scroll_and_menu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.8 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
a40 6
#ifdef XMGED
extern point_t orig_pos;
extern mat_t	ModelDelta;
void (*adc_hook)();
#endif

d358 1
a358 4
#ifdef XMGED
		 if(adc_hook)
		   (*adc_hook)(0);  /* toggle adc button */
#endif
a363 3
#ifdef XMGED
/*XXXX*/        mat_idn( ModelDelta );
#endif
d703 37
d743 1
a743 1
#ifdef XMGED
d760 1
@


11.8
log
@Just playing it safe
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.7 1995/12/27 22:33:27 bparker Exp bparker $ (BRL)";
d253 1
a253 1
		    if(!ignore_scroll_and_menu)
d784 1
a784 1
	if(!ignore_scroll_and_menu)
@


11.7
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.6 1995/12/11 22:44:28 bparker Exp bparker $ (BRL)";
a42 1
extern int	update_views;
d403 1
a403 1
#ifdef XMGED
d517 1
a517 1
#ifdef XMGED
d565 1
a565 1
#ifdef XMGED
@


11.6
log
@added ignore_scroll_and_menu in two more places
in order to stop redraws from occuring unnecessarily
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.5 1995/11/29 21:56:05 bparker Exp bparker $ (BRL)";
d47 2
d50 1
@


11.5
log
@Cleaned up some old XMGED stuff relating to the press command
since it is no longer needed.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.4 1995/11/07 22:58:34 bparker Exp bparker $ (BRL)";
d250 3
a252 1
		    dmaflag = 1;
d781 3
a783 1
	dmaflag = 1;
@


11.4
log
@unleashed a few xmged commands
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.3 1995/08/03 21:43:59 gdurf Exp bparker $ (BRL)";
a44 7
extern struct menu_item edge8_menu[], edge7_menu[], edge6_menu[], edge5_menu[];
extern struct menu_item point4_menu[], tgc_menu[], tor_menu[], eto_menu[];
extern struct menu_item ell_menu[], ars_menu[], spline_menu[], nmg_menu[];
extern struct menu_item mv8_menu[], mv7_menu[], mv6_menu[], mv5_menu[], mv4_menu[];
extern struct menu_item rot8_menu[], rot7_menu[], rot6_menu[], rot5_menu[], rot4_menu[];
extern struct menu_item rpc_menu[], rhc_menu[], epa_menu[], ehy_menu[];

a70 9
#ifdef XMGED
static void p_help();
static void edge8_doit(), edge7_doit(), edge6_doit(), edge5_doit();
static void mp4_doit(), tgc_doit(), tor_doit(), eto_doit(), ell_doit();
static void ars_doit(), spline_doit(), nmg_doit();
static void mf8_doit(), mf7_doit(), mf6_doit(), mf5_doit(), mf4_doit();
static void rf8_doit(), rf7_doit(), rf6_doit(), rf5_doit(), rf4_doit();
static void cntrl_doit(), rpc_doit(), rhc_doit(), epa_doit(), ehy_doit();
#endif
a85 3
#ifdef XMGED
	int     bu_param;       /* parameter to pass to bu_func */
#endif
a86 178
#ifdef XMGED
	BV_35_25,	"35,25",	bv_35_25,		NULL,
	BV_45_45,	"45,45",	bv_45_45,		NULL,
	BE_ACCEPT,	"accept",	be_accept,		NULL,
	BV_ADCURSOR,	"adc",		bv_adcursor,		NULL,
	BV_BOTTOM,	"bottom",	bv_bottom,		NULL,
	BV_FRONT,	"front",	bv_front,		NULL,
	BV_LEFT,	"left",		bv_left,		NULL,
	BE_O_ILLUMINATE,"oill",		be_o_illuminate,	NULL,
	BE_O_ROTATE,	"orot",		be_o_rotate,		NULL,
	BE_O_SCALE,	"oscale",	be_o_scale,		NULL,
	BE_O_X,		"ox",		be_o_x,			NULL,
	BE_O_XY,	"oxy",		be_o_xy,		NULL,
	BE_O_XSCALE,	"oxscale",	be_o_xscale,		NULL,
	BE_O_Y,		"oy",		be_o_y,			NULL,
	BE_O_YSCALE,	"oyscale",	be_o_yscale,		NULL,
	BE_O_ZSCALE,	"ozscale",	be_o_zscale,		NULL,
	BV_REAR,	"rear",		bv_rear,		NULL,
	BE_REJECT,	"reject",	be_reject,		NULL,
	BV_RESET,	"reset",	bv_reset,		NULL,
	BV_VRESTORE,	"restore",	bv_vrestore,		NULL,
	BV_RIGHT,	"right",	bv_right,		NULL,
	BV_VSAVE,	"save",		bv_vsave,		NULL,
	BE_S_EDIT,	"sedit",	be_s_edit,		NULL,
	BE_S_ILLUMINATE,"sill",		be_s_illuminate,	NULL,
	BV_SLICEMODE,	"slice",	bv_slicemode,		NULL,
	BE_S_ROTATE,	"srot",		be_s_rotate,		NULL,
	BE_S_SCALE,	"sscale",	be_s_scale,		NULL,
	BE_S_TRANS,	"sxy",		be_s_trans,		NULL,
	BE_S_TRANS,	"stran",	be_s_trans,		NULL,
	BV_TOP,		"top",		bv_top,			NULL,
	BV_ZOOM_IN,	"zoomin",	bv_zoomin,              NULL,
	BV_ZOOM_OUT,	"zoomout",	bv_zoomout,             NULL,
	BV_RATE_TOGGLE, "rate",		bv_rate_toggle,         NULL,
	P_HELP,		"help",		p_help,			NULL,
	EDGE8_1,	"a8_me12",	edge8_doit,		1,
	EDGE8_2,	"a8_me23",	edge8_doit,		2,
	EDGE8_3,	"a8_me34",	edge8_doit,		3,
	EDGE8_4,	"a8_me14",	edge8_doit,		4,
	EDGE8_5,	"a8_me15",	edge8_doit,		5,
	EDGE8_6,	"a8_me26",	edge8_doit,		6,
	EDGE8_7,	"a8_me56",	edge8_doit,		7,
	EDGE8_8,	"a8_me67",	edge8_doit,		8,
	EDGE8_9,	"a8_me78",	edge8_doit,		9,
	EDGE8_10,	"a8_me58",	edge8_doit,		10,
	EDGE8_11,	"a8_me37",	edge8_doit,		11,
	EDGE8_12,	"a8_me48",	edge8_doit,		12,
	EDGE7_1,	"a7_me12",	edge7_doit,		1,
	EDGE7_2,	"a7_me23",	edge7_doit,		2,
	EDGE7_3,	"a7_me34",	edge7_doit,		3,
	EDGE7_4,	"a7_me14",	edge7_doit,		4,
	EDGE7_5,	"a7_me15",	edge7_doit,		5,
	EDGE7_6,	"a7_me26",	edge7_doit,		6,
	EDGE7_7,	"a7_me56",	edge7_doit,		7,
	EDGE7_8,	"a7_me67",	edge7_doit,		8,
	EDGE7_9,	"a7_me37",	edge7_doit,		9,
	EDGE7_10,	"a7_me57",	edge7_doit,		10,
	EDGE7_11,	"a7_me45",	edge7_doit,		11,
	EDGE7_12,	"a7_mp5",	edge7_doit,		12,
	EDGE6_1,	"a6_me12",	edge6_doit,		1,
	EDGE6_2,	"a6_me23",	edge6_doit,		2,
	EDGE6_3,	"a6_me34",	edge6_doit,		3,
	EDGE6_4,	"a6_me14",	edge6_doit,		4,
	EDGE6_5,	"a6_me15",	edge6_doit,		5,
	EDGE6_6,	"a6_me25",	edge6_doit,		6,
	EDGE6_7,	"a6_me36",	edge6_doit,		7,
	EDGE6_8,	"a6_me46",	edge6_doit,		8,
	EDGE6_9,	"a6_mp5",	edge6_doit,		9,
	EDGE6_10,	"a6_mp6",	edge6_doit,		10,
	EDGE5_1,	"a5_me12",	edge5_doit,		1,
	EDGE5_2,	"a5_me23",	edge5_doit,		2,
	EDGE5_3,	"a5_me34",	edge5_doit,		3,
	EDGE5_4,	"a5_me14",	edge5_doit,		4,
	EDGE5_5,	"a5_me15",	edge5_doit,		5,
	EDGE5_6,	"a5_me25",	edge5_doit,		6,
	EDGE5_7,	"a5_me35",	edge5_doit,		7,
	EDGE5_8,	"a5_me45",	edge5_doit,		8,
	EDGE5_9,	"a5_mp5",	edge5_doit,		9,
	POINT4_1,	"a4_mp1",	mp4_doit,		1,
	POINT4_2,	"a4_mp2",	mp4_doit,		2,
	POINT4_3,	"a4_mp3",	mp4_doit,		3,
	POINT4_4,	"a4_mp4",	mp4_doit,		4,
	TGC_1,		"tgc_sh",	tgc_doit,		1,
	TGC_2,		"tgc_sa",	tgc_doit,		2,
	TGC_3,		"tgc_sb",	tgc_doit,		3,
	TGC_4,		"tgc_sc",	tgc_doit,		4,
	TGC_5,		"tgc_sd",	tgc_doit,		5,
	TGC_6,		"tgc_sab",	tgc_doit,		6,
	TGC_7,		"tgc_scd",	tgc_doit,		7,
	TGC_8,		"tgc_sabcd",	tgc_doit,		8,
	TGC_9,		"tgc_rh",	tgc_doit,		9,
	TGC_10,		"tgc_raxb",	tgc_doit,		10,
	TGC_11,		"tgc_mh",	tgc_doit,		11,
	TGC_12,		"tgc_mhh",	tgc_doit,		12,
	TOR_1,		"tor_sr1",	tor_doit,		1,
	TOR_2,		"tor_sr2",	tor_doit,		2,
	ETO_1,		"eto_sr",	eto_doit,		1,
	ETO_2,		"eto_sd",	eto_doit,		2,
	ETO_3,		"eto_sc",	eto_doit,		3,
	ETO_4,		"eto_rc",	eto_doit,		4,
	ELL_1,		"ell_sa",	ell_doit,		1,
	ELL_2,		"ell_sb",	ell_doit,		2,
	ELL_3,		"ell_sc",	ell_doit,		3,
	ELL_4,		"ell_sabc",	ell_doit,		4,
	ARS_1,		"ars",		ars_doit,		1,
	SPLINE_1,	"spl_pv",	spline_doit,		1,
	SPLINE_2,	"spl_mv",	spline_doit,		2,
	NMG_1,          "nmg_pe",       nmg_doit,               1,
	NMG_2,          "nmg_me",       nmg_doit,               2,
        NMG_3,          "nmg_de",       nmg_doit,               3,
        NMG_4,          "nmg_se",       nmg_doit,               4,
        NMG_5,          "nmg_del",      nmg_doit,               5,
        NMG_6,          "nmg_neu",      nmg_doit,               6,
        NMG_7,          "nmg_peu",      nmg_doit,               7,
	NMG_8,          "nmg_reu",      nmg_doit,               8,
	MV8_1,		"a8_mf1234",	mf8_doit,		1,
	MV8_2,		"a8_mf5678",	mf8_doit,		2,
	MV8_3,		"a8_mf1584",	mf8_doit,		3,
	MV8_4,		"a8_mf2376",	mf8_doit,		4,
	MV8_5,		"a8_mf1265",	mf8_doit,		5,
	MV8_6,		"a8_mf4378",	mf8_doit,		6,
	MV7_1,		"a7_mf1234",	mf7_doit,		1,
	MV7_2,		"a7_mf2376",	mf7_doit,		2,
	MV6_1,		"a6_mf1234",	mf6_doit,		1,
	MV6_2,		"a6_mf2365",	mf6_doit,		2,
	MV6_3,		"a6_mf1564",	mf6_doit,		3,
	MV6_4,		"a6_mf125",	mf6_doit,		4,
	MV6_5,		"a6_mf346",	mf6_doit,		5,
	MV5_1,		"a5_mf1234",	mf5_doit,		1,
	MV5_2,		"a5_mf125",	mf5_doit,		2,
	MV5_3,		"a5_mf235",	mf5_doit,		3,
	MV5_4,		"a5_mf345",	mf5_doit,		4,
	MV5_5,		"a5_mf145",	mf5_doit,		5,
	MV4_1,		"a4_mf123",	mf4_doit,		1,
	MV4_2,		"a4_mf124",	mf4_doit,		2,
	MV4_3,		"a4_mf234",	mf4_doit,		3,
	MV4_4,		"a4_mf134",	mf4_doit,		4,
	ROT8_1,		"a8_rf1234",	rf8_doit,		1,
	ROT8_2,		"a8_rf5678",	rf8_doit,		2,
	ROT8_3,		"a8_rf1584",	rf8_doit,		3,
	ROT8_4,		"a8_rf2376",	rf8_doit,		4,
	ROT8_5,		"a8_rf1265",	rf8_doit,		5,
	ROT8_6,		"a8_rf4378",	rf8_doit,		6,
	ROT7_1,		"a7_rf1234",	rf7_doit,		1,
	ROT7_2,		"a7_rf567",	rf7_doit,		2,
	ROT7_3,		"a7_rf145",	rf7_doit,		3,
	ROT7_4,		"a7_rf2376",	rf7_doit,		4,
	ROT7_5,		"a7_rf1265",	rf7_doit,		5,
	ROT7_6,		"a7_rf4375",	rf7_doit,		6,
	ROT6_1,		"a6_rf1234",	rf6_doit,		1,
	ROT6_2,		"a6_rf2365",	rf6_doit,		2,
	ROT6_3,		"a6_rf1564",	rf6_doit,		3,
	ROT6_4,		"a6_rf125",	rf6_doit,		4,
	ROT6_5,		"a6_rf346",	rf6_doit,		5,
	ROT5_1,		"a5_rf1234",	rf5_doit,		1,
	ROT5_2,		"a5_rf125",	rf5_doit,		2,
	ROT5_3,		"a5_rf235",	rf5_doit,		3,
	ROT5_4,		"a5_rf345",	rf5_doit,		4,
	ROT5_5,		"a5_rf145",	rf5_doit,		5,
	ROT4_1,		"a4_rf123",	rf4_doit,		1,
	ROT4_2,		"a4_rf124",	rf4_doit,		2,
	ROT4_3,		"a4_rf234",	rf4_doit,		3,
	ROT4_4,		"a4_rf134",	rf4_doit,		4,
	RPC_1,		"rpc_sb",	rpc_doit,		1,
	RPC_2,		"rpc_sh",	rpc_doit,		2,
	RPC_3,		"rpc_sr",	rpc_doit,		3,
	RHC_1,		"rhc_sb",	rhc_doit,		1,
	RHC_2,		"rhc_sh",	rhc_doit,		2,
	RHC_3,		"rhc_sr",	rhc_doit,		3,
	RHC_4,		"rhc_sc",	rhc_doit,		4,
	EPA_1,		"epa_sh",	epa_doit,		1,
	EPA_2,		"epa_sa",	epa_doit,		2,
	EPA_3,		"epa_sb",	epa_doit,		3,
	EHY_1,		"ehy_sh",	ehy_doit,		1,
	EHY_2,		"ehy_sa",	ehy_doit,		2,
	EHY_3,		"ehy_sb",	ehy_doit,		3,
	EHY_4,		"ehy_sc",	ehy_doit,		4,
#else
a118 1
#endif
d196 1
a196 3
#ifdef XMGED
		bp->bu_func(bp->bu_param);
#else
a197 1
#endif
d230 1
a230 3
#ifdef XMGED
		bp->bu_func(bp->bu_param);
#else
a231 1
#endif
a278 199

#ifdef XMGED
/*
 * Help for press command
 */
static void
p_help(param)
int	param;
{
	register struct buttons *bp;

	for( bp = button_table; bp->bu_code >= 0; bp++ )
		col_item(bp->bu_name);
	col_eol();
	return;
}

static void
edge8_doit(param)
int	param;
{
	(*edge8_menu[param].menu_func)(edge8_menu[param].menu_arg);
}

static void
edge7_doit(param)
int	param;
{
	(*edge7_menu[param].menu_func)(edge7_menu[param].menu_arg);
}

static void
edge6_doit(param)
int	param;
{
	(*edge6_menu[param].menu_func)(edge6_menu[param].menu_arg);
}

static void
edge5_doit(param)
int	param;
{
	(*edge5_menu[param].menu_func)(edge5_menu[param].menu_arg);
}

static void
mp4_doit(param)
int	param;
{
	(*point4_menu[param].menu_func)(point4_menu[param].menu_arg);
}

static void
tgc_doit(param)
int	param;
{
	(*tgc_menu[param].menu_func)(tgc_menu[param].menu_arg);
}

static void
tor_doit(param)
int	param;
{
	(*tor_menu[param].menu_func)(tor_menu[param].menu_arg);
}

static void
eto_doit(param)
int	param;
{
	(*eto_menu[param].menu_func)(eto_menu[param].menu_arg);
}

static void
ell_doit(param)
int	param;
{
	(*ell_menu[param].menu_func)(ell_menu[param].menu_arg);
}

static void
ars_doit(param)
int	param;
{
	(*ars_menu[param].menu_func)(ars_menu[param].menu_arg);
}

static void
spline_doit(param)
int	param;
{
	(*spline_menu[param].menu_func)(spline_menu[param].menu_arg);
}

static void
nmg_doit(param)
int	param;
{
	(*nmg_menu[param].menu_func)(nmg_menu[param].menu_arg);
}

static void
mf8_doit(param)
int	param;
{
	(*mv8_menu[param].menu_func)(mv8_menu[param].menu_arg);
}

static void
mf7_doit(param)
int	param;
{
	(*mv7_menu[param].menu_func)(mv7_menu[param].menu_arg);
}

static void
mf6_doit(param)
int	param;
{
	(*mv6_menu[param].menu_func)(mv6_menu[param].menu_arg);
}

static void
mf5_doit(param)
int	param;
{
	(*mv5_menu[param].menu_func)(mv5_menu[param].menu_arg);
}

static void
mf4_doit(param)
int	param;
{
	(*mv4_menu[param].menu_func)(mv4_menu[param].menu_arg);
}

static void
rf8_doit(param)
int	param;
{
	(*rot8_menu[param].menu_func)(rot8_menu[param].menu_arg);
}

static void
rf7_doit(param)
int	param;
{
	(*rot7_menu[param].menu_func)(rot7_menu[param].menu_arg);
}

static void
rf6_doit(param)
int	param;
{
	(*rot6_menu[param].menu_func)(rot6_menu[param].menu_arg);
}

static void
rf5_doit(param)
int	param;
{
	(*rot5_menu[param].menu_func)(rot5_menu[param].menu_arg);
}

static void
rf4_doit(param)
int	param;
{
	(*rot4_menu[param].menu_func)(rot4_menu[param].menu_arg);
}

static void
rpc_doit(param)
int	param;
{
	(*rpc_menu[param].menu_func)(rpc_menu[param].menu_arg);
}

static void
rhc_doit(param)
int	param;
{
	(*rhc_menu[param].menu_func)(rhc_menu[param].menu_arg);
}

static void
epa_doit(param)
int	param;
{
	(*epa_menu[param].menu_func)(epa_menu[param].menu_arg);
}

static void
ehy_doit(param)
int	param;
{
	(*ehy_menu[param].menu_func)(ehy_menu[param].menu_arg);
}
#endif
@


11.3
log
@Added support for extended press() command
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 11.2 1995/01/17 13:04:19 bparker Exp gdurf $ (BRL)";
a1032 1
#ifdef XMGED
a1033 1
#endif
a1046 1
#ifdef XMGED
a1047 1
#endif
a1060 1
#ifdef XMGED
a1061 1
#endif
a1074 1
#ifdef XMGED
a1075 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/buttons.c,v 11.2 95/01/17 11:41:55 bparker Exp $ (BRL)";
d401 1
d412 4
d429 1
a429 1
		if( strcmp( str, bp->bu_name) )
d438 23
a460 2
	(void)rt_log("press(%s):  Unknown operation, type 'press help' for help\n",
		str);
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.11 94/12/24 01:06:20 mike Exp $ (BRL)";
d41 13
d78 9
d102 3
d106 178
d316 1
d394 3
d398 1
d426 3
d430 1
d444 1
d458 199
d737 4
d746 3
d776 3
d890 4
d938 4
d1007 3
d1023 3
d1039 3
d1055 3
d1098 20
@


10.11
log
@Added zoom in and out buttons, and rate toggle.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.10 94/12/23 14:26:12 gdurf Exp Locker: mike $ (BRL)";
@


10.10
log
@Converted menu_array[] = to menu_set()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.9 94/12/16 15:57:09 gdurf Exp Locker: gdurf $ (BRL)";
d65 1
d110 3
d145 3
d243 20
@


10.9
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.8 1994/12/16 15:56:23 gdurf Exp gdurf $ (BRL)";
d441 1
a441 1
	menu_array[MENU_L2] = MENU_NULL;
d451 2
a452 2
		menu_array[MENU_L1] = MENU_NULL;
		menu_array[MENU_L2] = MENU_NULL;
d498 2
a499 2
		menu_array[MENU_L1] = MENU_NULL;
		menu_array[MENU_L2] = MENU_NULL;
d507 2
a508 2
		menu_array[MENU_L1] = MENU_NULL;
		menu_array[MENU_L2] = MENU_NULL;
d559 1
a559 1
	menu_array[MENU_L1] = MENU_NULL;
d574 1
a574 1
	menu_array[MENU_L1] = MENU_NULL;
d586 1
a586 1
	menu_array[MENU_L1] = MENU_NULL;
d663 1
a663 1
		menu_array[MENU_GEN] = first_menu;
d666 1
a666 1
		menu_array[MENU_GEN] = second_menu;
d682 1
a682 1
		menu_array[MENU_L2] = sed_menu;
d685 1
a685 1
		menu_array[MENU_L2] = oed_menu;
@


10.8
log
@Reverted to revision 10.6
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.6 94/11/08 04:16:42 mike Exp $ (BRL)";
d177 1
a177 1
		(void)printf("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
d186 1
a186 1
	(void)printf("button(%d):  Not a defined operation\n", bnum);
d198 1
a198 1
		(void)printf("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
d214 1
a214 1
	(void)printf("press(%s):  Unknown operation, type 'press help' for help\n",
d234 1
a234 1
	(void)printf("label_button(%d):  Not a defined operation\n", bnum);
d321 1
a321 1
		(void)printf("no solids in view\n");
d603 1
a603 1
		(void)printf("Unable to do <%s> from %s state.\n",
d622 1
a622 1
		(void)printf("Unable to do <%s> going from %s to %s state.\n",
d636 1
a636 1
	(void)printf("Unable to do <%s> from %s state.\n",
d672 1
a672 1
		printf("btn_head_menu(%d): bad arg\n", i);
d688 1
a688 1
		(void)printf("chg_l2menu(%d): bad arg\n");
@


10.7
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.6 1994/11/08 04:16:42 mike Exp gdurf $ (BRL)";
d177 1
a177 1
		(voidrt_log("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
d186 1
a186 1
	(voidrt_log("button(%d):  Not a defined operation\n", bnum);
d198 1
a198 1
		(voidrt_log("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
d214 1
a214 1
	(voidrt_log("press(%s):  Unknown operation, type 'press help' for help\n",
d234 1
a234 1
	(voidrt_log("label_button(%d):  Not a defined operation\n", bnum);
d321 1
a321 1
		(voidrt_log("no solids in view\n");
d603 1
a603 1
		(voidrt_log("Unable to do <%s> from %s state.\n",
d622 1
a622 1
		(voidrt_log("Unable to do <%s> going from %s to %s state.\n",
d636 1
a636 1
	(voidrt_log("Unable to do <%s> from %s state.\n",
d672 1
a672 1
	rt_log("btn_head_menu(%d): bad arg\n", i);
d688 1
a688 1
		(voidrt_log("chg_l2menu(%d): bad arg\n");
@


10.6
log
@Irix 6
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.5 94/08/09 14:56:54 gdurf Exp Locker: mike $ (BRL)";
d177 1
a177 1
		(void)printf("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
d186 1
a186 1
	(void)printf("button(%d):  Not a defined operation\n", bnum);
d198 1
a198 1
		(void)printf("WARNING: State error: edsol=%x, edobj=%x\n", edsol, edobj );
d214 1
a214 1
	(void)printf("press(%s):  Unknown operation, type 'press help' for help\n",
d234 1
a234 1
	(void)printf("label_button(%d):  Not a defined operation\n", bnum);
d321 1
a321 1
		(void)printf("no solids in view\n");
d603 1
a603 1
		(void)printf("Unable to do <%s> from %s state.\n",
d622 1
a622 1
		(void)printf("Unable to do <%s> going from %s to %s state.\n",
d636 1
a636 1
	(void)printf("Unable to do <%s> from %s state.\n",
d672 1
a672 1
		printf("btn_head_menu(%d): bad arg\n", i);
d688 1
a688 1
		(void)printf("chg_l2menu(%d): bad arg\n");
@


10.5
log
@#include "conf.h"
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.4 1992/02/05 23:12:07 mike Exp gdurf $ (BRL)";
a200 1
		register int i=0;
@


10.4
log
@Calling sequence to vls_solid() changed.
More es_keypoint stuff.
Moved oedit_accept() and oedit_reject() from buttons.c to edsol.c
for better coupling to the editing support
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.3 91/12/20 02:27:45 mike Exp Locker: mike $ (BRL)";
d24 2
@


10.3
log
@Setting of es_edflag now done in sedit_menu()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.2 91/12/02 16:57:01 mike Exp Locker: mike $ (BRL)";
a438 7
	/* matrices used to accept editing done from a depth
	 *	>= 2 from the top of the illuminated path
	 */
	mat_t topm;	/* accum matrix from pathpos 0 to i-2 */
	mat_t inv_topm;	/* inverse */
	mat_t deltam;	/* final "changes":  deltam = (inv_topm)(modelchanges)(topm) */
	mat_t tempm;
a439 1

a467 16
		switch( ipathpos )  {
		case 0:
			moveHobj( illump->s_path[ipathpos], modelchanges );
			break;
		case 1:
			moveHinstance(
				illump->s_path[ipathpos-1],
				illump->s_path[ipathpos],
				modelchanges
			);
			break;
		default:
			mat_idn( topm );
			mat_idn( inv_topm );
			mat_idn( deltam );
			mat_idn( tempm );
d469 1
a469 1
			pathHmat( illump, topm, ipathpos-2 );
a470 32
			mat_inv( inv_topm, topm );

			mat_mul( tempm, modelchanges, topm );
			mat_mul( deltam, inv_topm, tempm );

			moveHinstance(
				illump->s_path[ipathpos-1],
				illump->s_path[ipathpos],
				deltam
			);
			break;
		}

		/*
		 *  Redraw all solids affected by this edit.
		 *  Regenerate a new control list which does not
		 *  include the solids about to be replaced,
		 *  so we can safely fiddle the displaylist.
		 */
		modelchanges[15] = 1000000000;	/* => small ratio */
		dmaflag=1;
		refresh();

		/* Now, recompute new chunks of displaylist */
		FOR_ALL_SOLIDS( sp )  {
			if( sp->s_iflag == DOWN )
				continue;
			(void)replot_original_solid( sp );
			sp->s_iflag = DOWN;
		}
		mat_idn( modelchanges );

d508 2
@


10.2
log
@Created sedit_accept() and sedit_reject(), in edsol.c
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 10.1 91/10/12 06:43:06 mike Rel4_0 Locker: mike $ (BRL)";
a600 1
	es_edflag = MENU;
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 9.5 91/06/25 16:06:46 pjt Exp $ (BRL)";
a452 3
		/* write editing changes out to disc */
		db_put( dbip, illump->s_path[illump->s_last], &es_rec, 0, 1 );

d455 3
a460 2
		es_edflag = -1;
		menuflag = 0;
d556 1
a556 2
		/* Restore the original solid */
		replot_original_solid( illump );
@


9.5
log
@Changed the args in all calls to setview
from int to double
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 9.4 91/06/12 22:17:51 mike Exp $ (BRL)";
@


9.4
log
@lint
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/buttons.c,v 9.3 90/04/21 06:05:09 mike Exp $ (BRL)";
d239 1
a239 1
	setview( 0, 0, 0 );
d244 1
a244 1
	setview( 180, 0, 0 );
d249 1
a249 1
	setview( 270, 0, 0 );
d254 1
a254 1
	setview( 270, 0, 180 );
d259 1
a259 1
	setview( 270, 0, 270 );
d264 1
a264 1
	setview( 270, 0, 90 );
d303 1
a303 1
	setview( 0, 0, 0 );
d307 1
a307 1
	setview( 270+45, 0, 270-45 );
d312 1
a312 1
	setview( 270+25, 0, 270-35 );
@


9.3
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 9.2 89/10/27 21:18:45 mike Locked $ (BRL)";
a118 2

void		state_err();
@


9.2
log
@Fixed press help message (from Dan Dender)
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 9.1 89/05/19 06:01:49 phil Locked $ (BRL)";
a523 3
			union record *recp;
			mat_t	curmat;

d526 1
a526 11
			if( sp->s_Eflag )  {
				(void)printf("Unable to-redraw evaluated things\n");
				continue;
			}
			pathHmat( sp, curmat, sp->s_last-1 );
			recp = db_getmrec( dbip, sp->s_path[sp->s_last]);

			illump = sp;	/* flag to drawHsolid! */
			(void)redraw( sp, recp, curmat );

			free( (char *)recp );
d561 1
a561 7
		{
			union record *recp;

			recp = db_getmrec( dbip,  illump->s_path[illump->s_last] );
			illump = redraw( illump, recp, es_mat );
			free( (char *)recp );
		}
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 8.6 89/04/21 04:56:44 mike Exp $ (BRL)";
d215 1
a215 1
	(void)printf("press(%s):  Unknown operation, type 'press ?' for help\n",
@


8.6
log
@Interface hooks for supporting scroll bars (aka sliders).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 8.5 89/04/07 00:21:19 mike Locked $ (BRL)";
@


8.5
log
@Removed redundant declarations.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 8.4 89/04/06 20:38:49 mike Locked $ (BRL)";
d35 1
d114 2
a115 3
void btn_head_menu();
void btn_item_hit();
void	state_err();
d117 5
d139 2
d153 1
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 8.3 89/03/06 17:26:05 mike Locked $ (BRL)";
a36 4

extern void	perror();
extern int	read();
extern long	lseek();
@


8.3
log
@ansii
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 8.2 88/12/06 00:55:40 mike Locked $ (BRL)";
d32 1
@


8.2
log
@Converted to new db_*() routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/buttons.c,v 1.3 88/10/29 22:53:06 mike Exp $ (BRL)";
d38 1
a38 1
extern int	printf(), read();
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 7.6 88/09/16 02:50:34 reschly Exp $ (BRL)";
d30 1
a31 1
#include "./objdir.h"
d298 2
a299 3
	/* Reset to initial viewing conditions */
	mat_idn( toViewcenter );
	Viewscale = maxview;
d451 1
a451 1
		db_putrec( illump->s_path[illump->s_last], &es_rec, 0 );
d529 1
a529 1
			recp = db_getmrec(sp->s_path[sp->s_last]);
d572 1
a572 1
			recp = db_getmrec( illump->s_path[illump->s_last] );
@


7.6
log
@alphabetized the button list, and cleaned up the "press ?" code; changing
the '?' to "help" and tabulating the listing.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 7.5 88/05/15 23:04:43 reschly Locked $ (BRL)";
@


7.5
log
@lint fixes
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 7.4 88/02/04 12:00:05 mike Locked $ (BRL)";
d25 1
d80 4
a83 1
	BV_TOP,		"top",		bv_top,
d85 1
a85 1
	BV_RIGHT,	"right",	bv_right,
a86 8
	BV_FRONT,	"front",	bv_front,
	BV_REAR,	"rear",		bv_rear,
	BV_VRESTORE,	"restore",	bv_vrestore,
	BV_VSAVE,	"save",		bv_vsave,
	BV_ADCURSOR,	"adc",		bv_adcursor,
	BV_RESET,	"reset",	bv_reset,
	BV_45_45,	"45,45",	bv_45_45,
	BV_35_25,	"35,25",	bv_35_25,
d88 1
a88 1
	BE_S_ILLUMINATE,"sill",		be_s_illuminate,
d90 2
d93 1
d96 1
a96 5
	BE_O_X,		"ox",		be_o_x,
	BE_O_Y,		"oy",		be_o_y,
	BE_O_XY,	"oxy",		be_o_xy,
	BE_O_ROTATE,	"orot",		be_o_rotate,
	BE_ACCEPT,	"accept",	be_accept,
d98 6
a104 1
	BE_S_EDIT,	"sedit",	be_s_edit,
d106 1
d108 1
a108 1
	BE_S_SCALE,	"sscale",	be_s_scale,
d195 1
a195 1
	if( str[0] == '?' )  {
d197 3
a199 7
		for( bp = button_table; bp->bu_code >= 0; bp++ )  {
			(void)printf("%s, ", bp->bu_name );
			if( ++i > 4 )  {
				(void)putchar('\n');
				i = 0;
			}
		}
@


7.4
log
@a call to db_getmrec needed to have the correct argument for rejection
of a solid edit.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 7.3 87/11/14 05:03:01 stay Locked $ (BRL)";
d117 1
d709 1
@


7.3
log
@Added dir_getmrec() to get all records for an item,
using malloc.
Added total path matrix as explicit arg to redraw().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 7.2 87/11/05 05:03:30 mike Exp $ (BRL)";
d575 1
a575 1
			recp = db_getmrec( illump );
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 7.1 87/11/02 23:58:33 mike Rel $ (BRL)";
d522 3
a526 2
			/* Rip off es_mat and es_rec for redraw() */
			pathHmat( sp, es_mat, sp->s_last-1 );
d529 1
a529 4
			} else {
				db_getrec(sp->s_path[sp->s_last], &es_rec, 0);
				illump = sp;	/* flag to drawHsolid! */
				redraw( sp, &es_rec );
d531 7
d571 8
a578 2
		/* Restore the saved original solid */
		illump = redraw( illump, &es_orig );
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 6.1 87/07/11 08:01:47 mike Rel $ (BRL)";
d26 1
a26 1
#include "./machine.h"	/* special copy */
d61 2
a62 2
float	acc_sc_sol;
float	acc_sc[3];	/* local object scale factors --- accumulations */
d112 1
a112 1
static float sav_vscale;
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 5.1 87/06/24 22:17:49 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 4.3 87/06/16 04:28:55 mike Exp $ (BRL)";
@


4.3
log
@Shortened string for angle/distance cursor
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 4.2 87/02/13 00:05:28 mike Locked $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 4.1 86/12/29 03:19:08 mike Rel1 $ (BRL)";
d133 1
a133 1
	{ "Angle/Dist Cursor", btn_item_hit, BV_ADCURSOR },
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.13 86/12/20 05:12:30 mike Exp $ (BRL)";
@


2.13
log
@Changed 90,90 to 45,45
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.12 86/09/23 17:39:58 mike Locked $ (BRL)";
@


2.12
log
@Minor cleanup for cray
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.11 86/09/10 01:36:25 mike Exp $ (BRL)";
d67 1
a67 1
static void bv_90_90(), bv_35_25();
d89 1
a89 1
	BV_90_90,	"90,90",	bv_90_90,
d130 1
a130 1
	{ "90,90", btn_item_hit, BV_90_90 },
d306 2
a307 3
static void bv_90_90()  {
	/* azm 90   elev 90 */
	setview( 360, 0, 180 );
d311 2
a312 2
	/* Use Azmuth=35, Elevation=25 in Keith's backwards space */
	setview( 295, 0, 235 );
@


2.11
log
@Minor cleanups and name changes for clarity.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.10 86/08/12 06:46:43 mike Exp $ (BRL)";
d112 1
a112 1
static float sav_viewscale;
d269 1
a269 1
		Viewscale = sav_viewscale;
d279 1
a279 1
	sav_viewscale = Viewscale;
@


2.10
log
@Changed #includes for CC -I../h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.9 86/07/17 17:37:44 mike Exp $ (BRL)";
d115 2
a116 1
void button_menu(), button_hit_menu();
d119 1
a119 1
	{ "BUTTON MENU", button_menu, 1 },		/* chg to 2nd menu */
d123 14
a136 14
	{ "***BUTTON MENU***", button_menu, 0 },	/* chg to 1st menu */
	{ "REJECT Edit", button_hit_menu, BE_REJECT },
	{ "ACCEPT Edit", button_hit_menu, BE_ACCEPT },
	{ "35,25", button_hit_menu, BV_35_25 },
	{ "Top", button_hit_menu, BV_TOP },
	{ "Right", button_hit_menu, BV_RIGHT },
	{ "Front", button_hit_menu, BV_FRONT },
	{ "90,90", button_hit_menu, BV_90_90 },
	{ "Restore View", button_hit_menu, BV_VRESTORE },
	{ "Save View", button_hit_menu, BV_VSAVE },
	{ "Angle/Dist Cursor", button_hit_menu, BV_ADCURSOR },
	{ "Reset Viewsize", button_hit_menu, BV_RESET },
	{ "Solid Illum", button_hit_menu, BE_S_ILLUMINATE },
	{ "Object Illum", button_hit_menu, BE_O_ILLUMINATE },
d140 5
a144 5
	{ "***SOLID EDIT***", button_menu, 2 },		/* turn off menu */
	{ "edit menu", button_hit_menu, BE_S_EDIT },
	{ "Rotate", button_hit_menu, BE_S_ROTATE },
	{ "Translate", button_hit_menu, BE_S_TRANS },
	{ "Scale", button_hit_menu, BE_S_SCALE },
d148 9
a156 9
	{ "***OBJ EDIT***", button_menu, 2 },		/* turn off menu */
	{ "Scale", button_hit_menu, BE_O_SCALE },
	{ "X move", button_hit_menu, BE_O_X },
	{ "Y move", button_hit_menu, BE_O_Y },
	{ "XY move", button_hit_menu, BE_O_XY },
	{ "Rotate", button_hit_menu, BE_O_ROTATE },
	{ "Scale X", button_hit_menu, BE_O_XSCALE },
	{ "Scale Y", button_hit_menu, BE_O_YSCALE },
	{ "Scale Z", button_hit_menu, BE_O_ZSCALE },
a624 1
	menuflag = 0;
a637 1
	menuflag = 0;
a650 1
	menuflag = 0;
d707 3
a709 1
 *  "Button Menu" stuff
d711 1
a711 1
void button_hit_menu(arg)  {
d713 3
a715 1
	menuflag = 0;
d718 6
d725 1
a725 1
button_menu(i)  {
d734 1
a734 1
		menu_array[MENU_L2] = MENU_NULL;
d737 1
a737 1
		printf("button_menu(%d): bad arg\n", i);
a739 1
	menuflag = 0;	/* no selected menu item */
@


2.9
log
@Improved version of fixes from Davisson and Applin
Additional argument added to pathHmat().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.9 86/07/17 17:23:45 mike Exp $ (BRL)";
d27 8
a34 8
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "objdir.h"
#include "solid.h"
#include "menu.h"
#include "dm.h"
#include "sedit.h"
@


2.8
log
@Latest revisions from Keith, including lots of new commands
and one-axis scaling.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.7 85/09/14 05:33:43 mike Exp $ (BRL)";
d439 7
d447 1
d478 2
a479 1
		if( ipathpos == 0 )  {
d481 2
a482 1
		}  else  {
d488 20
d525 1
a525 1
			pathHmat( sp, es_mat );
@


2.7
log
@Lint-inspired cleanup.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.6 85/08/07 05:16:40 mike Exp $ (BRL)";
d54 1
a54 1
static	edobj;		/* object editing */
d62 1
d72 1
d94 3
d153 3
d341 2
d362 30
@


2.6
log
@Changed to use common ../h/vmath.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.5 85/06/03 16:48:35 mike Exp $ (BRL)";
d63 2
a64 3
static	sliceflag;	/* 0 = depth cue mode, !0 = "slice" mode */

static void bv_top(), bv_bottom(), bv_right(), bv_left(), bv_front(), bv_rear();
a531 15
#ifdef SLICEMODE
	extern int inten_scale;

	if( sliceflag )  {
		/* depth cue mode */
		sliceflag = 0;
		inten_scale = 0x7FF0;
		dmp->dmr_light( LIGHT_OFF, BV_SLICEMODE );
	} else {
		/* slice mode */
		sliceflag = 1;
		inten_scale = 0xFFF0;
		dmp->dmr_light( LIGHT_ON, BV_SLICEMODE );
	}
#endif
@


2.5
log
@Fixes to allow compilation on System V on the IRIS.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.4 85/05/29 23:16:41 mike Exp $ (BRL)";
d25 4
a28 2
#include	<math.h>
#include "ged_types.h"
a33 1
#include "../h/db.h"
@


2.4
log
@Added MENU_L2 menu for solid/object edit buttons,
moved menus to left side of screen.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.3 85/05/10 00:51:26 mike Exp $ (BRL)";
d532 1
d546 1
@


2.3
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.2 85/05/03 01:31:13 mike Exp $ (BRL)";
d110 41
d400 1
d456 7
a462 3
			db_getrec(sp->s_path[sp->s_last], &es_rec, 0);
			illump = sp;	/* flag to drawHsolid! */
			redraw( sp, &es_rec );
d503 2
a568 1
	menu_array[MENU_L2] = MENU_NULL;
a584 1
	menu_array[MENU_L2] = MENU_NULL;
a597 1
	menu_array[MENU_L2] = MENU_NULL;
a653 1
void button_menu();
a658 20
static struct menu_item first_menu[] = {
	{ "BUTTON MENU", button_menu, 5 },
	{ "", (void (*)())NULL, 0 }
};
static struct menu_item second_menu[] = {
	{ "***BUTTON MENU***", button_menu, 0 },
	{ "REJECT Edit", button_hit_menu, BE_REJECT },
	{ "Top", button_hit_menu, BV_TOP },
	{ "Right", button_hit_menu, BV_RIGHT },
	{ "Front", button_hit_menu, BV_FRONT },
	{ "35,25", button_hit_menu, BV_35_25 },
	{ "90,90", button_hit_menu, BV_90_90 },
	{ "Restore View", button_hit_menu, BV_VRESTORE },
	{ "Reset Viewsize", button_hit_menu, BV_RESET },
	{ "Angle/Dist Cursor", button_hit_menu, BV_ADCURSOR },
	{ "Solid Illum", button_hit_menu, BE_S_ILLUMINATE },
	{ "Object Illum", button_hit_menu, BE_O_ILLUMINATE },
	{ "", (void (*)())NULL, 0 }
};

d661 2
a662 1
	if( i == 0 )
d664 2
a665 1
	else
d667 8
d677 15
@


2.2
log
@After doing an edit accept or reject, recompute colors,
by calling dmr_colorchange().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: buttons.c,v 2.1 85/03/11 23:53:41 mike Prod $ (BRL)";
d115 1
a115 1
register long bnum;
a278 1
	new_mats();
d288 1
a288 1
	if( ill_common() )
d290 2
d299 1
a299 1
	if( ill_common() )
d301 2
d368 2
a369 2
		MENU_ON(FALSE);
		MENU_INSTALL( (struct menu_item *)NULL );
d447 2
a448 2
		MENU_ON( FALSE );
		MENU_INSTALL( (struct menu_item *)NULL );
d484 2
d508 1
a508 2
	menuflag = 0;		/* No menu item selected yet */
	MENU_ON(TRUE);
d520 2
a521 1
	MENU_ON( FALSE );
d537 2
a538 1
	MENU_ON( FALSE );
d551 2
a552 1
	MENU_ON( FALSE );
d603 40
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d375 1
d419 1
d476 1
@


1.6
log
@USNA changes which formalize state changes.
@
text
@d6 14
d21 3
d28 1
a28 1
#include "dir.h"
d32 1
a32 1
#include "db.h"
d146 1
a146 1
			printf("%s, ", bp->bu_name );
d148 1
a148 1
				putchar('\n');
d183 1
@


1.5
log
@
Latest stuff
@
text
@d148 10
d159 7
a165 5
state_err( str )
char *str;
{
	(void)printf("Unable to do <%s> from %s state.\n",
		str, state_str[state] );
d248 2
a249 1
static void ill_common()  {
d254 1
a254 2
		state = ST_VIEW;
		return;
d263 1
d267 1
a267 2
	if( state != ST_VIEW )  {
		state_err( "Object Illuminate" );
d269 1
a269 2
	}
	state = ST_O_PICK;
d271 2
a272 1
	ill_common();
d276 1
a276 2
	if( state != ST_VIEW )  {
		state_err( "Solid Illuminate" );
d278 1
a278 2
	}
	state = ST_S_PICK;
d280 2
a281 1
	ill_common();
d285 1
a285 2
	if( state != ST_O_EDIT )  {
		state_err( "Object Scale" );
d287 1
a287 1
	}
d295 1
a295 2
	if( state != ST_O_EDIT )  {
		state_err( "Object X Motion" );
d297 1
a297 1
	}
d305 1
a305 2
	if( state != ST_O_EDIT )  {
		state_err( "Object Y Motion" );
d307 1
a307 1
	}
d316 1
a316 2
	if( state != ST_O_EDIT )  {
		state_err( "Object XY Motion" );
d318 1
a318 1
	}
d326 1
a326 2
	if( state != ST_O_EDIT )  {
		state_err( "Object Rotation" );
d328 1
a328 1
	}
a336 7
	/* Accept edit */
	if( state != ST_O_EDIT && state != ST_S_EDIT )  {
		state_err( "Edit Accept" );
		return;
	}
	dmp->dmr_light( LIGHT_OFF, BE_ACCEPT );
	dmp->dmr_light( LIGHT_OFF, BE_REJECT );
d340 2
d355 5
a359 1
	}  else  {
d361 2
d398 7
a405 4

	illump = SOLID_NULL;
	state = ST_VIEW;
	dmaflag = 1;		/* show completion */
d410 1
a411 5
	/* Reject is special -- it is OK in any edit state */
	if( state == ST_VIEW ) {
		state_err( "Edit Reject" );
		return;
	}
d415 6
a420 1
	if( state == ST_S_EDIT )  {
d429 14
a443 2
	if( state == ST_O_EDIT && edobj )
		dmp->dmr_light( LIGHT_OFF, edobj );
a444 2
	dmp->dmr_light( LIGHT_OFF, BE_O_ILLUMINATE );
	dmp->dmr_light( LIGHT_OFF, BE_S_ILLUMINATE );
d456 1
a456 1
	state = ST_VIEW;
d475 1
a475 2
	if( state != ST_S_EDIT )  {
		state_err( "Solid Edit (Menu)" );
d477 1
a477 1
	}
d489 1
a489 2
	if( state != ST_S_EDIT )  {
		state_err( "Solid Rotate" );
d491 1
a491 1
	}
d503 1
a503 2
	if( state != ST_S_EDIT )  {
		state_err( "Solid Translate" );
d505 1
a505 1
	}
d517 1
a517 2
	if( state != ST_S_EDIT )  {
		state_err( "Solid Scale" );
d519 1
a519 1
	}
d527 48
@


1.4
log
@accumulation solid rot mat & scale factor (KAA)
@
text
@d39 2
a40 2
/* KAA
 *	define the accumulation solid rot matrix and scale factor
d47 46
d100 1
a100 4
	static mat_t sav_viewrot, sav_toviewcenter;
	static float sav_viewscale;
	static int	vsaved = 0;	/* set iff view saved */
	register struct solid *sp;
a101 3
	/*
	 * Consistency checks
	 */
d105 9
a113 4
	/*
	 * Process the button function requested.
	 */
	switch( bnum )  {
d115 7
a121 3
	default:
		(void)printf("button(%d):  Not a defined operation\n", bnum);
		break;
d123 2
a124 4
	case BV_TOP:
		/* Top view */
		setview( 0, 0, 0 );
		break;
d126 11
a136 4
	case BV_BOTTOM:
		/* Bottom view */
		setview( 180, 0, 0 );
		break;
d138 10
a147 4
	case BV_RIGHT:
		/* Right view */
		setview( 270, 0, 0 );
		break;
d149 6
a154 4
	case BV_LEFT:
		/* Left view */
		setview( 270, 0, 180 );
		break;
d156 4
a159 4
	case BV_FRONT:
		/* Front view */
		setview( 270, 0, 270 );
		break;
d161 4
a164 4
	case BV_REAR:
		/* Rear view */
		setview( 270, 0, 90 );
		break;
d166 4
a169 10
	case BV_VRESTORE:
		/* restore to saved view */
		if ( vsaved )  {
			Viewscale = sav_viewscale;
			mat_copy( Viewrot, sav_viewrot );
			mat_copy( toViewcenter, sav_toviewcenter );
			new_mats();
			dmaflag++;
		}
		break;
d171 4
a174 21
	case BV_VSAVE:
		/* save current view */
		sav_viewscale = Viewscale;
		mat_copy( sav_viewrot, Viewrot );
		mat_copy( sav_toviewcenter, toViewcenter );
		vsaved = 1;
		dmp->dmr_light( LIGHT_ON, BV_VRESTORE );
		break;
			
	case BV_ADCURSOR:
		if (adcflag)  {
			/* Was on, turn off */
			adcflag = 0;
			dmp->dmr_light( LIGHT_OFF, BV_ADCURSOR );
		}  else  {
			/* Was off, turn on */
			adcflag = 1;
			dmp->dmr_light( LIGHT_ON, BV_ADCURSOR );
		}
		dmaflag = 1;
		break;
d176 4
a179 6
	case BV_RESET:
		/* Reset to initial viewing conditions */
		mat_idn( toViewcenter );
		Viewscale = maxview;
		setview( 270, 0, 0 );
		break;
d181 4
a184 4
	case BV_90_90:
		/* azm 90   elev 90 */
		setview( 360, 0, 180 );
		break;
d186 6
a191 33
	case BV_35_25:
		/* Use Azmuth=35, Elevation=25 in Keith's backwards space */
		setview( 295, 0, 235 );
		break;

	case BE_O_ILLUMINATE:
		if( state != ST_VIEW )  {
			state_err( "Object Illuminate" );
			break;
		}
		state = ST_O_PICK;
		dmp->dmr_light( LIGHT_ON, BE_O_ILLUMINATE );
		goto ill_common;

	case BE_S_ILLUMINATE:
		if( state != ST_VIEW )  {
			state_err( "Solid Illuminate" );
			break;
		}
		state = ST_S_PICK;
		dmp->dmr_light( LIGHT_ON, BE_S_ILLUMINATE );
ill_common:
		dmp->dmr_light( LIGHT_ON, BE_REJECT );
		if( HeadSolid.s_forw == &HeadSolid )  {
			(void)printf("no solids in view\n");
			state = ST_VIEW;
			break;
		}
		illump = HeadSolid.s_forw;/* any valid solid would do */
		edobj = 0;		/* sanity */
		edsol = 0;		/* sanity */
		movedir = 0;		/* No edit modes set */
		mat_idn( modelchanges );	/* No changes yet */
a192 1

d194 2
a195 1
		break;
d197 8
a204 10
	case BE_O_SCALE:
		if( state != ST_O_EDIT )  {
			state_err( "Object Scale" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, edobj );
		dmp->dmr_light( LIGHT_ON, edobj = BE_O_SCALE );
		movedir = SARROW;
		dmaflag++;
		break;
d206 12
a217 10
	case BE_O_X:
		if( state != ST_O_EDIT )  {
			state_err( "Object X Motion" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, edobj );
		dmp->dmr_light( LIGHT_ON, edobj = BE_O_X );
		movedir = RARROW;
		dmaflag++;
		break;
d219 6
a224 10
	case BE_O_Y:
		if( state != ST_O_EDIT )  {
			state_err( "Object Y Motion" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, edobj );
		dmp->dmr_light( LIGHT_ON, edobj = BE_O_Y );
		movedir = UARROW;
		dmaflag++;
		break;
d226 4
a229 10
	case BE_O_XY:
		if( state != ST_O_EDIT )  {
			state_err( "Object XY Motion" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, edobj );
		dmp->dmr_light( LIGHT_ON, edobj = BE_O_XY );
		movedir = UARROW | RARROW;
		dmaflag++;
		break;
d231 4
a234 10
	case BE_O_ROTATE:
		if( state != ST_O_EDIT )  {
			state_err( "Object Rotation" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, edobj );
		dmp->dmr_light( LIGHT_ON, edobj = BE_O_ROTATE );
		movedir = ROTARROW;
		dmaflag++;
		break;
d236 16
a251 8
	case BE_ACCEPT:
		/* Accept edit */
		if( state != ST_O_EDIT && state != ST_S_EDIT )  {
			state_err( "Edit Accept" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, BE_ACCEPT );
		dmp->dmr_light( LIGHT_OFF, BE_REJECT );
d253 9
a261 4
		if( state == ST_S_EDIT )  {
			/* Accept a solid edit */
			/* write editing changes out to disc */
			db_putrec( illump->s_path[illump->s_last], &es_rec, 0 );
d263 9
a271 7
			dmp->dmr_light( LIGHT_OFF, edsol );
			edsol = 0;
			MENU_ON(FALSE);
			MENU_INSTALL( (struct menu_item *)NULL );
			dmp->dmr_light( LIGHT_OFF, BE_S_EDIT );
			es_edflag = -1;
			menuflag = 0;
d273 10
a282 16
			FOR_ALL_SOLIDS( sp )
				sp->s_iflag = DOWN;
		}  else  {
			/* Accept an object edit */
			dmp->dmr_light( LIGHT_OFF, edobj );
			edobj = 0;
			movedir = 0;	/* No edit modes set */
			if( ipathpos == 0 )  {
				moveHobj( illump->s_path[ipathpos], modelchanges );
			}  else  {
				moveHinstance(
					illump->s_path[ipathpos-1],
					illump->s_path[ipathpos],
					modelchanges
				);
			}
d284 10
a293 9
			/*
			 *  Redraw all solids affected by this edit.
			 *  Regenerate a new control list which does not
			 *  include the solids about to be replaced,
			 *  so we can safely fiddle the displaylist.
			 */
			modelchanges[15] = 1000000000;	/* => small ratio */
			dmaflag=1;
			refresh();
d295 10
a304 13
			/* Now, recompute new chunks of displaylist */
			FOR_ALL_SOLIDS( sp )  {
				if( sp->s_iflag == DOWN )
					continue;
				/* Rip off es_mat and es_rec for redraw() */
				pathHmat( sp, es_mat );
				db_getrec(sp->s_path[sp->s_last], &es_rec, 0);
				illump = sp;	/* flag to drawHsolid! */
				redraw( sp, &es_rec );
				sp->s_iflag = DOWN;
			}
			mat_idn( modelchanges );
		}
a305 4
		illump = SOLID_NULL;
		state = ST_VIEW;
		dmaflag = 1;		/* show completion */
		break;
d307 10
a316 9
	case BE_REJECT:
		/* Reject edit */
		/* Reject is special -- it is OK in any edit state */
		if( state == ST_VIEW ) {
			state_err( "Edit Reject" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, BE_ACCEPT );
		dmp->dmr_light( LIGHT_OFF, BE_REJECT );
d318 10
a327 6
		if( state == ST_S_EDIT )  {
			/* Reject a solid edit */
			if( edsol )
				dmp->dmr_light( LIGHT_OFF, edsol );
			MENU_ON( FALSE );
			MENU_INSTALL( (struct menu_item *)NULL );
d329 9
a337 5
			/* Restore the saved original solid */
			illump = redraw( illump, &es_orig );
		}
		if( state == ST_O_EDIT && edobj )
			dmp->dmr_light( LIGHT_OFF, edobj );
d339 6
a344 4
		dmp->dmr_light( LIGHT_OFF, BE_O_ILLUMINATE );
		dmp->dmr_light( LIGHT_OFF, BE_S_ILLUMINATE );
		menuflag = 0;
		movedir = 0;
d346 3
a348 1
		edobj = 0;
d350 1
a350 2
		illump = SOLID_NULL;		/* None selected */
		dmaflag = 1;
a351 1
		/* Clear illumination flags */
d354 14
a367 2
		state = ST_VIEW;
		break;
d369 20
a388 11
	case BV_SLICEMODE:
		if( sliceflag )  {
			/* depth cue mode */
			sliceflag = 0;
			inten_scale = 0x7FF0;
			dmp->dmr_light( LIGHT_OFF, BV_SLICEMODE );
		} else {
			/* slice mode */
			sliceflag = 1;
			inten_scale = 0xFFF0;
			dmp->dmr_light( LIGHT_ON, BV_SLICEMODE );
d390 2
a391 1
		break;
d393 18
a410 6
	case BE_S_EDIT:
		/* solid editing */
		if( state != ST_S_EDIT )  {
			state_err( "Solid Edit (Menu)" );
			break;
		}
a412 16
		dmp->dmr_light( LIGHT_ON, edsol = BE_S_EDIT );
		es_edflag = MENU;
		menuflag = 0;		/* No menu item selected yet */
		MENU_ON(TRUE);
		dmaflag++;
		break;

	case BE_S_ROTATE:
		/* rotate solid */
		if( state != ST_S_EDIT )  {
			state_err( "Solid Rotate" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, edsol );
		dmp->dmr_light( LIGHT_ON, edsol = BE_S_ROTATE );
		menuflag = 0;
d414 1
a414 4
		es_edflag = SROT;
		mat_idn(acc_rot_sol);
		dmaflag++;
		break;
d416 43
a458 6
	case BE_S_TRANS:
		/* translate solid */
		if( state != ST_S_EDIT )  {
			state_err( "Solid Translate" );
			break;
		}
d460 6
a465 7
		dmp->dmr_light( LIGHT_ON, edsol = BE_S_TRANS );
		menuflag = 0;
		es_edflag = STRANS;
		movedir = UARROW | RARROW;
		MENU_ON( FALSE );
		dmaflag++;
		break;
d467 5
a471 14
	case BE_S_SCALE:
		/* scale solid */
		if( state != ST_S_EDIT )  {
			state_err( "Solid Scale" );
			break;
		}
		dmp->dmr_light( LIGHT_OFF, edsol );
		dmp->dmr_light( LIGHT_ON, edsol = BE_S_SCALE );
		menuflag = 0;
		es_edflag = SSCALE;
		MENU_ON( FALSE );
		acc_sc_sol = 1.0;
		dmaflag++;
		break;
d473 7
d482 28
a509 5
state_err( str )
char *str;
{
	(void)printf("Unable to do <%s> from %s state.\n",
		str, state_str[state] );
@


1.3
log
@pre-Keith version
@
text
@d39 6
d389 1
d419 1
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d15 1
a15 1
#include "3d.h"
@


1.1
log
@Initial revision
@
text
@d115 1
a115 1
		dm_light( LIGHT_ON, BV_VRESTORE );
d122 1
a122 1
			dm_light( LIGHT_OFF, BV_ADCURSOR );
d126 1
a126 1
			dm_light( LIGHT_ON, BV_ADCURSOR );
d154 1
a154 1
		dm_light( LIGHT_ON, BE_O_ILLUMINATE );
d163 1
a163 1
		dm_light( LIGHT_ON, BE_S_ILLUMINATE );
d165 1
a165 1
		dm_light( LIGHT_ON, BE_REJECT );
d186 2
a187 2
		dm_light( LIGHT_OFF, edobj );
		dm_light( LIGHT_ON, edobj = BE_O_SCALE );
d197 2
a198 2
		dm_light( LIGHT_OFF, edobj );
		dm_light( LIGHT_ON, edobj = BE_O_X );
d208 2
a209 2
		dm_light( LIGHT_OFF, edobj );
		dm_light( LIGHT_ON, edobj = BE_O_Y );
d219 2
a220 2
		dm_light( LIGHT_OFF, edobj );
		dm_light( LIGHT_ON, edobj = BE_O_XY );
d230 2
a231 2
		dm_light( LIGHT_OFF, edobj );
		dm_light( LIGHT_ON, edobj = BE_O_ROTATE );
d242 2
a243 2
		dm_light( LIGHT_OFF, BE_ACCEPT );
		dm_light( LIGHT_OFF, BE_REJECT );
d250 1
a250 1
			dm_light( LIGHT_OFF, edsol );
d254 1
a254 1
			dm_light( LIGHT_OFF, BE_S_EDIT );
d262 1
a262 1
			dm_light( LIGHT_OFF, edobj );
d311 2
a312 2
		dm_light( LIGHT_OFF, BE_ACCEPT );
		dm_light( LIGHT_OFF, BE_REJECT );
d317 1
a317 1
				dm_light( LIGHT_OFF, edsol );
d325 1
a325 1
			dm_light( LIGHT_OFF, edobj );
d327 2
a328 2
		dm_light( LIGHT_OFF, BE_O_ILLUMINATE );
		dm_light( LIGHT_OFF, BE_S_ILLUMINATE );
d348 1
a348 1
			dm_light( LIGHT_OFF, BV_SLICEMODE );
d353 1
a353 1
			dm_light( LIGHT_ON, BV_SLICEMODE );
d364 2
a365 2
			dm_light( LIGHT_OFF, edsol );
		dm_light( LIGHT_ON, edsol = BE_S_EDIT );
d378 2
a379 2
		dm_light( LIGHT_OFF, edsol );
		dm_light( LIGHT_ON, edsol = BE_S_ROTATE );
d392 2
a393 2
		dm_light( LIGHT_OFF, edsol );
		dm_light( LIGHT_ON, edsol = BE_S_TRANS );
d407 2
a408 2
		dm_light( LIGHT_OFF, edsol );
		dm_light( LIGHT_ON, edsol = BE_S_SCALE );
@
