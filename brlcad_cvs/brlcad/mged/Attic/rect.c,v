head	1.25;
access;
symbols
	ansi-20040405-merged:1.20.2.2
	postmerge-20040405-ansi:1.22
	premerge-20040404-ansi:1.21
	postmerge-autoconf:1.21
	autoconf-freeze:1.20.10.1
	premerge-autoconf:1.21
	postmerge-20040315-windows:1.21
	premerge-20040315-windows:1.21
	windows-20040315-freeze:1.20.4.1
	autoconf-20031203:1.20
	autoconf-20031202:1.20
	autoconf-branch:1.20.0.10
	phong-branch:1.20.0.8
	photonmap-branch:1.20.0.6
	rel-6-1-DP:1.20
	windows-branch:1.20.0.4
	rel-6-0-2:1.18
	ansi-branch:1.20.0.2
	rel-6-0-1-branch:1.18.0.2
	hartley-6-0-post:1.19
	hartley-6-0-pre:1.18
	rel-6-0-1:1.18
	rel-6-0:1.18
	rel-5-4:1.14
	offsite-5-3-pre:1.16
	rel-5-3:1.14
	rel-5-2:1.14
	rel-5-1-branch:1.14.0.2
	rel-5-1:1.14
	rel-5-0:1.13
	rel-5-0-beta:1.13
	rel-4-5:1.3;
locks; strict;
comment	@ * @;


1.25
date	2004.05.21.17.47.48;	author morrison;	state dead;
branches;
next	1.24;

1.24
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.02.17.39.34;	author morrison;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.20.17.08.24;	author jra;	state Exp;
branches
	1.20.2.1
	1.20.4.1
	1.20.10.1;
next	1.19;

1.19
date	2002.08.15.20.55.37;	author hartley;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.24.19.05.08;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.19.03.10.48;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	99.12.30.20.27.30;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	98.12.29.20.33.32;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	98.11.13.22.29.51;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	98.11.06.22.32.42;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	98.10.21.17.01.39;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	98.06.12.19.46.22;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	98.06.11.14.28.16;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	98.06.08.20.49.54;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	98.05.18.19.35.11;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	98.03.06.22.41.37;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.02.20.23.21.00;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.02.06.21.53.54;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.01.28.15.31.31;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.01.16.21.54.47;	author bparker;	state Exp;
branches;
next	;

1.20.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2004.03.17.21.22.02;	author morrison;	state Exp;
branches;
next	;

1.20.4.1
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

1.20.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	;


desc
@MGED's rubber band rectangle utilities
@


1.25
log
@moved to src/mged/
@
text
@/*
 *			R E C T . C
 *
 *  Routines to implement MGED's rubber band rectangle capability.
 *
 *  Author -
 *	Robert G. Parker
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <math.h>
#include <stdio.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"

extern int fb_refresh();  /* from libfb/tcl.c */

extern void mged_center(fastf_t *center); /* from chgview.c */
extern int mged_vscale(fastf_t sfactor);

static void adjust_rect_for_zoom(void);

struct _rubber_band default_rubber_band = {
/* rb_rc */		1,
/* rb_active */		0,
/* rb_draw */		0,
/* rb_linewidth */	0,
/* rb_linestyle */	's',
/* rb_pos */		{ 0, 0 },
/* rb_dim */		{ 0, 0 },
/* rb_x */		0.0,
/* rb_y */		0.0,
/* rb_width */		0.0,
/* rb_height */		0.0
};

#define RB_O(_m)        offsetof(struct _rubber_band, _m)
#define RB_OA(_m)	offsetofarray(struct _rubber_band, _m)
struct bu_structparse rubber_band_vparse[] = {
	{"%d",	1, "draw",	RB_O(rb_draw),		rb_set_dirty_flag },
	{"%d",	1, "linewidth",	RB_O(rb_linewidth),	rb_set_dirty_flag },
	{"%c",	1, "linestyle",	RB_O(rb_linestyle),	rb_set_dirty_flag },
	{"%d",	2, "pos",	RB_OA(rb_pos),		set_rect },
	{"%d",	2, "dim",	RB_OA(rb_dim),		set_rect },
	{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

void
rb_set_dirty_flag(void)
{
  struct dm_list *dmlp;

  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
    if(dmlp->dml_rubber_band == rubber_band)
      dmlp->dml_dirty = 1;
}

/*
 * Given position and dimensions in normalized view coordinates, calculate
 * position and dimensions in image coordinates.
 */
void
rect_view2image(void)
{
  rubber_band->rb_pos[X] = dm_Normal2Xx(dmp, rubber_band->rb_x);
  rubber_band->rb_pos[Y] = dmp->dm_height - dm_Normal2Xy(dmp, rubber_band->rb_y, 1);
  rubber_band->rb_dim[X] = rubber_band->rb_width * dmp->dm_width * 0.5;
  rubber_band->rb_dim[Y] = rubber_band->rb_height * dmp->dm_width * 0.5;
}

/*
 * Given position and dimensions in image coordinates, calculate
 * position and dimensions in normalized view coordinates.
 */
void
rect_image2view(void)
{
  rubber_band->rb_x = dm_Xx2Normal(dmp, rubber_band->rb_pos[X]);
  rubber_band->rb_y = dm_Xy2Normal(dmp, dmp->dm_height - rubber_band->rb_pos[Y], 1);
  rubber_band->rb_width = rubber_band->rb_dim[X] * 2.0 / (fastf_t)dmp->dm_width;
  rubber_band->rb_height = rubber_band->rb_dim[Y] * 2.0 / (fastf_t)dmp->dm_width;
}

void
set_rect(void)
{
  rect_image2view();
  rb_set_dirty_flag();
}

/*
 * Adjust the rubber band to have the same aspect ratio as the window.
 */
static void
adjust_rect_for_zoom(void)
{
  fastf_t width, height;

  if(rubber_band->rb_width >= 0.0)
    width = rubber_band->rb_width;
  else
    width = -rubber_band->rb_width;

  if(rubber_band->rb_height >= 0.0)
    height = rubber_band->rb_height;
  else
    height = -rubber_band->rb_height;

  if(width >= height){
    if(rubber_band->rb_height >= 0.0)
      rubber_band->rb_height = width / dmp->dm_aspect;
    else
      rubber_band->rb_height = -width / dmp->dm_aspect;
  }else{
    if(rubber_band->rb_width >= 0.0)
      rubber_band->rb_width = height * dmp->dm_aspect;
    else
      rubber_band->rb_width = -height * dmp->dm_aspect;
  }
}

void
draw_rect(void)
{
  int line_style;

  if(NEAR_ZERO(rubber_band->rb_width, (fastf_t)SMALL_FASTF) &&
     NEAR_ZERO(rubber_band->rb_height, (fastf_t)SMALL_FASTF))
    return;

  if(rubber_band->rb_linestyle == 'd')
    line_style = 1; /* dashed lines */
  else
    line_style = 0; /* solid lines */

  if(rubber_band->rb_active && mged_variables->mv_mouse_behavior == 'z')
    adjust_rect_for_zoom();

  /* draw rectangle */
  DM_SET_FGCOLOR(dmp,
	       color_scheme->cs_rubber_band[0],
	       color_scheme->cs_rubber_band[1],
	       color_scheme->cs_rubber_band[2], 1, 1.0);
  DM_SET_LINE_ATTR(dmp, rubber_band->rb_linewidth, line_style);

  DM_DRAW_LINE_2D(dmp,
		  rubber_band->rb_x,
		  rubber_band->rb_y * dmp->dm_aspect,
		  rubber_band->rb_x,
		  (rubber_band->rb_y + rubber_band->rb_height) * dmp->dm_aspect);
  DM_DRAW_LINE_2D(dmp,
		  rubber_band->rb_x,
		  (rubber_band->rb_y + rubber_band->rb_height) * dmp->dm_aspect,
		  rubber_band->rb_x + rubber_band->rb_width,
		  (rubber_band->rb_y + rubber_band->rb_height) * dmp->dm_aspect);
  DM_DRAW_LINE_2D(dmp,
		  rubber_band->rb_x + rubber_band->rb_width,
		  (rubber_band->rb_y + rubber_band->rb_height) * dmp->dm_aspect,
		  rubber_band->rb_x + rubber_band->rb_width,
		  rubber_band->rb_y * dmp->dm_aspect);
  DM_DRAW_LINE_2D(dmp,
		  rubber_band->rb_x + rubber_band->rb_width,
		  rubber_band->rb_y * dmp->dm_aspect,
		  rubber_band->rb_x,
		  rubber_band->rb_y * dmp->dm_aspect);
}

void
paint_rect_area(void)
{
  if(!fbp)
    return;

  (void)fb_refresh(fbp, rubber_band->rb_pos[X], rubber_band->rb_pos[Y],
		   rubber_band->rb_dim[X], rubber_band->rb_dim[Y]);
}

void
rt_rect_area(void)
{
  int xmin, xmax;
  int ymin, ymax;
  int width, height;
  struct bu_vls vls;

  if(!fbp)
    return;

  if(NEAR_ZERO(rubber_band->rb_width, (fastf_t)SMALL_FASTF) &&
     NEAR_ZERO(rubber_band->rb_height, (fastf_t)SMALL_FASTF))
    return;

  if(mged_variables->mv_port < 0){
    bu_log("rt_rect_area: invalid port number - %d\n", mged_variables->mv_port);
    return;
  }

  xmin = rubber_band->rb_pos[X];
  ymin = rubber_band->rb_pos[Y];
  width = rubber_band->rb_dim[X];
  height = rubber_band->rb_dim[Y];

  if(width >= 0){
    xmax = xmin + width;
  }else{
    xmax = xmin;
    xmin += width;
  }

  if(height >= 0){
    ymax = ymin + height;
  }else{
    ymax = ymin;
    ymin += height;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "rt -w %d -n %d -V %lf -F %d -j %d,%d,%d,%d -C%d/%d/%d",
		dmp->dm_width, dmp->dm_height, dmp->dm_aspect,
		mged_variables->mv_port, xmin, ymin, xmax, ymax,
		color_scheme->cs_bg[0], color_scheme->cs_bg[1], color_scheme->cs_bg[2]);
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  (void)Tcl_ResetResult(interp);
  bu_vls_free(&vls);
}

void
zoom_rect_area(void)
{
  fastf_t width, height;
  fastf_t sf;
  point_t old_model_center;
  point_t new_model_center;
  point_t old_view_center;
  point_t new_view_center;

  if(NEAR_ZERO(rubber_band->rb_width, (fastf_t)SMALL_FASTF) &&
     NEAR_ZERO(rubber_band->rb_height, (fastf_t)SMALL_FASTF))
    return;

  adjust_rect_for_zoom();

  /* find old view center */
  MAT_DELTAS_GET_NEG(old_model_center, view_state->vs_vop->vo_center);
  MAT4X3PNT(old_view_center, view_state->vs_vop->vo_model2view, old_model_center);

  /* calculate new view center */
  VSET(new_view_center,
       rubber_band->rb_x + rubber_band->rb_width / 2.0,
       rubber_band->rb_y + rubber_band->rb_height / 2.0,
       old_view_center[Z]);

  /* find new model center */
  MAT4X3PNT(new_model_center, view_state->vs_vop->vo_view2model, new_view_center);
  mged_center(new_model_center);

  /* zoom in to fill rectangle */
  if(rubber_band->rb_width >= 0.0)
    width = rubber_band->rb_width;
  else
    width = -rubber_band->rb_width;

  if(rubber_band->rb_height >= 0.0)
    height = rubber_band->rb_height;
  else
    height = -rubber_band->rb_height;

  if(width >= height)
    sf = width / 2.0;
  else
    sf = height / 2.0 * dmp->dm_aspect;

  mged_vscale(sf);

  rubber_band->rb_x = -1.0;
  rubber_band->rb_y = -1.0 / dmp->dm_aspect;
  rubber_band->rb_width = 2.0;
  rubber_band->rb_height = 2.0 / dmp->dm_aspect;

  rect_view2image();
  rb_set_dirty_flag();
}
@


1.24
log
@change conf.h to a wrapped config.h
@
text
@@


1.23
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d17 5
a21 1
#include "conf.h"
@


1.22
log
@merge of ansi-6-0-branch into HEAD
@
text
@d156 1
a156 1
	       color_scheme->cs_rubber_band[2], 1);
@


1.21
log
@update copyright to include span through 2003
@
text
@d31 2
a32 2
extern void mged_center(); /* from chgview.c */
extern int mged_vscale();
d34 1
a34 1
static void adjust_rect_for_zoom();
d108 1
a108 1
adjust_rect_for_zoom()
@


1.20
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d10 1
a10 1
 *	This software is Copyright (C) 1998 by the United States Army.
@


1.20.4.1
log
@sync to HEAD...
@
text
@d10 1
a10 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
@


1.20.10.1
log
@merge from HEAD
@
text
@d10 1
a10 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
@


1.20.2.1
log
@Initial ANSIfication
@
text
@d31 2
a32 2
extern void mged_center(fastf_t *center); /* from chgview.c */
extern int mged_vscale(fastf_t sfactor);
d34 1
a34 1
static void adjust_rect_for_zoom(void);
d108 1
a108 1
adjust_rect_for_zoom(void)
@


1.20.2.2
log
@sync branch with HEAD
@
text
@d10 1
a10 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
@


1.19
log
@Converted from K&R to ANSI C - RFH
@
text
@d31 2
a32 2
extern void mged_center(fastf_t *center); /* from chgview.c */
extern int mged_vscale(fastf_t sfactor);
d34 1
a34 1
static void adjust_rect_for_zoom(void);
d108 1
a108 1
adjust_rect_for_zoom(void)
@


1.18
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d31 2
a32 2
extern void mged_center(); /* from chgview.c */
extern int mged_vscale();
d34 1
a34 1
static void adjust_rect_for_zoom();
d108 1
a108 1
adjust_rect_for_zoom()
@


1.17
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@a256 1
#ifdef MGED_USE_VIEW_OBJ
a258 4
#else
  MAT_DELTAS_GET_NEG(old_model_center, view_state->vs_toViewcenter);
  MAT4X3PNT(old_view_center, view_state->vs_model2view, old_model_center);
#endif
a266 1
#ifdef MGED_USE_VIEW_OBJ
a267 3
#else
  MAT4X3PNT(new_model_center, view_state->vs_view2model, new_view_center);
#endif
@


1.16
log
@
Fixed compiler lint, function declarations.
@
text
@d257 4
d263 1
d272 3
d276 1
@


1.15
log
@
const RCSid
@
text
@a34 8
void rb_set_dirty_flag();
void draw_rect();
void rect_view2image();
void rect_image2view();
void set_rect();
void paint_rect_area();
void rt_rect_area();
void zoom_rect_area();
d62 1
a62 1
rb_set_dirty_flag()
d76 1
a76 1
rect_view2image()
d89 1
a89 1
rect_image2view()
d98 1
a98 1
set_rect()
d136 1
a136 1
draw_rect()
d182 1
a182 1
paint_rect_area()
d192 1
a192 1
rt_rect_area()
d241 1
a241 1
zoom_rect_area()
@


1.14
log
@Eliminated some unused variables
@
text
@d14 1
a14 1
static char RCSid[] = "";
@


1.13
log
@*- mods to rt_rect_area()
@
text
@a145 3
  point_t view_pt;
  point_t model_pt;
  point_t first_pt;
@


1.12
log
@*- when raytracing, use the display managers current background
   color as the background color for the raytracer.
@
text
@a233 1
  height *= dmp->dm_aspect;
@


1.11
log
@*- use new structures
*- cleanup
@
text
@d243 1
a243 1
  bu_vls_printf(&vls, "rt -w %d -n %d -V %lf -F %d -j %d,%d,%d,%d",
d245 2
a246 1
		mged_variables->mv_port, xmin, ymin, xmax, ymax);
@


1.10
log
@*- use color scheme variables
@
text
@d34 2
d37 2
a38 1
void get_rect();
d44 24
a67 2
int f_get_rect();
int f_set_rect();
d70 74
a148 1
  fastf_t width, height;
d151 2
a152 2
  if(NEAR_ZERO(rect_width, (fastf_t)SMALL_FASTF) &&
     NEAR_ZERO(rect_height, (fastf_t)SMALL_FASTF))
d155 1
a155 1
  if(mged_variables->rubber_band_linestyle == 'd')
d160 2
a161 23
  if(mged_variables->mouse_behavior == 'z'){
    if(rect_width >= 0.0)
      width = rect_width;
    else
      width = -rect_width;

    if(rect_height >= 0.0)
      height = rect_height;
    else
      height = -rect_height;

    if(width >= height){
      if(rect_height >= 0.0)
	rect_height = width;
      else
	rect_height = -width;
    }else{
      if(rect_width >= 0.0)
	rect_width = height;
      else
	rect_width = -height;
    }
  }
d165 25
a189 42
	       color_scheme->rubber_band[0],
	       color_scheme->rubber_band[1],
	       color_scheme->rubber_band[2], 1);
  DM_SET_LINE_ATTR(dmp, mged_variables->rubber_band_linewidth, line_style);

  DM_DRAW_LINE_2D(dmp, rect_x, rect_y * dmp->dm_aspect,
		  rect_x, (rect_y + rect_height) * dmp->dm_aspect);
  DM_DRAW_LINE_2D(dmp, rect_x, (rect_y + rect_height) * dmp->dm_aspect,
		  rect_x + rect_width, (rect_y + rect_height) * dmp->dm_aspect);
  DM_DRAW_LINE_2D(dmp, rect_x + rect_width, (rect_y + rect_height) * dmp->dm_aspect,
		  rect_x + rect_width, rect_y * dmp->dm_aspect);
  DM_DRAW_LINE_2D(dmp, rect_x + rect_width, rect_y * dmp->dm_aspect,
		  rect_x, rect_y * dmp->dm_aspect);
}

/*
 * Return the rectangle parameters in framebuffer/image format.
 */
void
get_rect(x, y, width, height)
int *x, *y;
int *width, *height;
{
  *x = dm_Normal2Xx(dmp, rect_x);
  *y = dmp->dm_height - dm_Normal2Xy(dmp, rect_y, 1);
  *width = rect_width * dmp->dm_width * 0.5;
  *height = rect_height * dmp->dm_height * 0.5;
}

/*
 * Given x, y, width and height in framebuffer/image format, calculate the
 * rectangle coordinates in normalized view coordinates.
 */
void
set_rect(x, y, width, height)
int x, y;
int width, height;
{
  rect_x = dm_Xx2Normal(dmp, x);
  rect_y = dm_Xy2Normal(dmp, dmp->dm_height - y, 1);
  rect_width = width * 2.0 / (fastf_t)dmp->dm_width;
  rect_height = height * 2.0 / (fastf_t)dmp->dm_height;
a194 3
  int x, y;
  int width, height;

d198 2
a199 4
  get_rect(&x, &y, &width, &height);
  height *= dmp->dm_aspect;

  (void)fb_refresh(fbp, x, y, width, height);
d213 2
a214 2
  if(NEAR_ZERO(rect_width, (fastf_t)SMALL_FASTF) &&
     NEAR_ZERO(rect_height, (fastf_t)SMALL_FASTF))
d217 2
a218 2
  if(mged_variables->port < 0){
    bu_log("rt_rect_area: invalid port number - %d\n", mged_variables->port);
d222 4
a225 1
  get_rect(&xmin, &ymin, &width, &height);
d244 2
a245 2
		dmp->dm_width, dmp->dm_height, (fastf_t)(dmp->dm_width/(fastf_t)dmp->dm_height),
		mged_variables->port, xmin, ymin, xmax, ymax);
d261 2
a262 2
  if(NEAR_ZERO(rect_width, (fastf_t)SMALL_FASTF) &&
     NEAR_ZERO(rect_height, (fastf_t)SMALL_FASTF))
d265 2
d268 2
a269 2
  MAT_DELTAS_GET_NEG(old_model_center, toViewcenter);
  MAT4X3PNT(old_view_center, model2view, old_model_center);
d273 2
a274 2
       rect_x + rect_width / 2.0,
       rect_y + rect_height / 2.0,
d278 1
a278 1
  MAT4X3PNT(new_model_center, view2model, new_view_center);
d282 2
a283 2
  if(rect_width >= 0.0)
    width = rect_width;
d285 1
a285 1
    width = -rect_width;
d287 2
a288 2
  if(rect_height >= 0.0)
    height = rect_height;
d290 1
a290 1
    height = -rect_height;
d295 1
a295 1
    sf = height / 2.0;
a297 88
}


/*
 *			T C L   C O M M A N D S
 */

int
f_get_rect(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct bu_vls vls;
  int x, y;
  int width, height;

  if(argc != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  get_rect(&x, &y, &width, &height);

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "%d %d %d %d", x, y, width, height);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

int
f_set_rect(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct bu_vls vls;
  int x, y;
  int width, height;

  if(argc != 5){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%d", &x) != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%d", &y) != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%d", &width) != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[4], "%d", &height) != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  set_rect(x, y, width, height);
d299 4
a302 2
  if(mged_variables->rubber_band)
    dirty = 1;
d304 2
a305 1
  return TCL_OK;
@


1.9
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@d88 3
a90 3
	       mged_variables->rubber_band_color[0],
	       mged_variables->rubber_band_color[1],
	       mged_variables->rubber_band_color[2], 1);
@


1.8
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d87 1
a87 1
  DM_SET_COLOR(dmp,
@


1.7
log
@*- mods to paint_rect_area()
@
text
@a16 1
#ifdef DO_RUBBER_BAND
a28 1
#ifdef USE_FRAMEBUFFER
a29 1
#endif
a110 1
#ifdef USE_RT_ASPECT
a112 4
#else
  *x = dm_Normal2Xx(dmp, rect_x, 1);
  *y = dmp->dm_height - dm_Normal2Xy(dmp, rect_y);
#endif
a125 1
#ifdef USE_RT_ASPECT
a127 4
#else
  rect_x = dm_Xx2Normal(dmp, x, 1);
  rect_y = dm_Xy2Normal(dmp, dmp->dm_height - y);
#endif
a140 1
#ifdef USE_FRAMEBUFFER
a144 1
#endif
a331 1
#endif
@


1.6
log
@*- mods for pjt demo
@
text
@d154 1
d156 1
a157 1
#ifdef USE_FRAMEBUFFER
@


1.5
log
@*- use aspect ratio when drawing rectangle
*- MGED's notion of aspect ratio has changed (i.e. width/height)
@
text
@d190 1
@


1.4
log
@mods to rt_rect_area()
@
text
@d96 8
a103 4
  DM_DRAW_LINE_2D(dmp, rect_x, rect_y, rect_x, rect_y + rect_height);
  DM_DRAW_LINE_2D(dmp, rect_x, rect_y + rect_height, rect_x + rect_width, rect_y + rect_height);
  DM_DRAW_LINE_2D(dmp, rect_x + rect_width, rect_y + rect_height, rect_x + rect_width, rect_y);
  DM_DRAW_LINE_2D(dmp, rect_x + rect_width, rect_y, rect_x, rect_y);
d114 4
d120 3
a122 2
  *width = rect_width * dmp->dm_width / 2.0;
  *height = rect_height * dmp->dm_height / 2.0;
d134 4
d140 1
d198 3
a200 3
  bu_vls_printf(&vls, "rt -s %d -F %d -j %d,%d,%d,%d",
		dmp->dm_width, mged_variables->port,
		xmin, ymin, xmax, ymax);
@


1.3
log
@*- now drawing rectangles directly (i.e. no longer using vlists)
*- using mged_variables to draw rectangles
@
text
@d188 1
@


1.2
log
@*- now using rt's new option to raytrace rectangular area of image
@
text
@a35 3
extern struct bu_vls rubber_band_color;         /* from cmd.c */
extern struct bu_vls rubber_band_line_width;
extern struct bu_vls rubber_band_line_style;
a49 7
  char *val;
  int r, g, b;
  int line_width;
  int line_style;
  struct rt_vlist h_vlist;
  struct rt_vlist vlist;
  fastf_t width, height;
d53 2
d60 3
a62 33
  /* get rubber band color */
  val = Tcl_GetVar(interp, bu_vls_addr(&rubber_band_color), TCL_GLOBAL_ONLY);
  if(sscanf(val, "%d %d %d", &r, &g, &b) != 3){
    /* use default - white */
    r = 255;
    g = 255;
    b = 255;
  }

  /* get rubber band line width */
  val = Tcl_GetVar(interp, bu_vls_addr(&rubber_band_line_width), TCL_GLOBAL_ONLY);
  if(sscanf(val, "%d", &line_width) != 1)
    line_width = 1;

  if(line_width < 0)
    line_width = 1;

  /* get rubber band line style */
  val = Tcl_GetVar(interp, bu_vls_addr(&rubber_band_line_style), TCL_GLOBAL_ONLY);
  if(sscanf(val, "%d", &line_style) != 1){
    char c;

    if(sscanf(val, "%c", &c) != 1)
      line_style = 0; /* solid lines */
    else{
      if(c == 'd')
	line_style = 1;
      else
	line_style = 0; /* solid lines */
    }
  }

  if(line_style < 0 || line_style > 1)
d89 11
a99 32
  BU_LIST_INIT(&h_vlist.l);
  BU_LIST_APPEND(&h_vlist.l, &vlist.l);

  VSET(view_pt, rect_x, rect_y, 1.0);
  MAT4X3PNT(first_pt, view2model, view_pt);
  VMOVE(vlist.pt[0], first_pt);
  vlist.cmd[0] = RT_VLIST_LINE_MOVE;

  VSET(view_pt, rect_x, rect_y + rect_height, 1.0);
  MAT4X3PNT(model_pt, view2model, view_pt);
  VMOVE(vlist.pt[1], model_pt);
  vlist.cmd[1] = RT_VLIST_LINE_DRAW;

  VSET(view_pt, rect_x + rect_width, rect_y + rect_height, 1.0);
  MAT4X3PNT(model_pt, view2model, view_pt);
  VMOVE(vlist.pt[2], model_pt);
  vlist.cmd[2] = RT_VLIST_LINE_DRAW;

  VSET(view_pt, rect_x + rect_width, rect_y, 1.0);
  MAT4X3PNT(model_pt, view2model, view_pt);
  VMOVE(vlist.pt[3], model_pt);
  vlist.cmd[3] = RT_VLIST_LINE_DRAW;

  VMOVE(vlist.pt[4], first_pt);
  vlist.cmd[4] = RT_VLIST_LINE_DRAW;

  vlist.nused = 5;

  /* draw axes */
  DM_SET_COLOR(dmp, r, g, b, 1);
  DM_SET_LINE_ATTR(dmp, line_width, line_style);
  DM_DRAW_VLIST(dmp, &h_vlist);
@


1.1
log
@Initial revision
@
text
@d196 3
d209 3
d214 3
d226 16
d243 3
a245 6

  /*XXX
   * For now, assume square windows --- eventually want to have rt
   * raytrace only the specified rectangle.
   */
  bu_vls_printf(&vls, "rt -s %d -F %d", dmp->dm_width, mged_variables->port);
@
