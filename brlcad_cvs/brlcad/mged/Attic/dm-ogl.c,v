head	1.100;
access;
symbols
	ansi-20040405-merged:1.96.4.1
	postmerge-20040405-ansi:1.97
	premerge-20040404-ansi:1.97
	postmerge-autoconf:1.97
	autoconf-freeze:1.96.12.1
	premerge-autoconf:1.97
	postmerge-20040315-windows:1.97
	premerge-20040315-windows:1.96
	windows-20040315-freeze:1.96.6.1
	autoconf-20031203:1.96
	autoconf-20031202:1.96
	autoconf-branch:1.96.0.12
	phong-branch:1.96.0.10
	photonmap-branch:1.96.0.8
	rel-6-1-DP:1.96
	windows-branch:1.96.0.6
	rel-6-0-2:1.96
	ansi-branch:1.96.0.4
	rel-6-0-1-branch:1.96.0.2
	hartley-6-0-post:1.96
	hartley-6-0-pre:1.96
	rel-6-0-1:1.96
	rel-6-0:1.96
	rel-5-4:1.87.2.2
	offsite-5-3-pre:1.89
	rel-5-3:1.87.2.2
	rel-5-2:1.87.2.1
	rel-5-1-branch:1.87.0.2
	rel-5-1:1.87
	rel-5-0:1.81
	rel-5-0-beta:1.80
	rel-4-5:1.70
	ctj-4-5-post:1.56
	ctj-4-5-pre:1.56;
locks; strict;
comment	@ * @;


1.100
date	2004.05.21.17.47.39;	author morrison;	state dead;
branches;
next	1.99;

1.99
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.98;

1.98
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	1.97;

1.97
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	1.96;

1.96
date	2001.08.14.18.34.51;	author bparker;	state Exp;
branches
	1.96.4.1
	1.96.6.1
	1.96.12.1;
next	1.95;

1.95
date	2001.06.18.19.24.23;	author bparker;	state Exp;
branches;
next	1.94;

1.94
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	1.93;

1.93
date	2001.06.01.19.23.23;	author bparker;	state Exp;
branches;
next	1.92;

1.92
date	2001.04.05.19.35.44;	author morrison;	state Exp;
branches;
next	1.91;

1.91
date	2001.04.03.19.02.23;	author bparker;	state Exp;
branches;
next	1.90;

1.90
date	2001.03.19.22.20.01;	author butler;	state Exp;
branches;
next	1.89;

1.89
date	2000.08.31.18.13.02;	author bparker;	state Exp;
branches;
next	1.88;

1.88
date	2000.08.19.03.10.44;	author mike;	state Exp;
branches;
next	1.87;

1.87
date	2000.01.21.15.24.53;	author bparker;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	99.12.30.20.22.44;	author jra;	state Exp;
branches;
next	1.85;

1.85
date	99.12.27.18.57.22;	author bparker;	state Exp;
branches;
next	1.84;

1.84
date	99.12.17.16.28.12;	author bparker;	state Exp;
branches;
next	1.83;

1.83
date	99.12.01.14.04.04;	author bparker;	state Exp;
branches;
next	1.82;

1.82
date	99.10.22.21.40.33;	author bparker;	state Exp;
branches;
next	1.81;

1.81
date	99.07.23.20.25.01;	author bparker;	state Exp;
branches;
next	1.80;

1.80
date	99.04.26.19.20.54;	author bparker;	state Exp;
branches;
next	1.79;

1.79
date	99.03.09.21.42.25;	author bparker;	state Exp;
branches;
next	1.78;

1.78
date	99.01.12.18.17.33;	author bparker;	state Exp;
branches;
next	1.77;

1.77
date	98.11.06.22.32.39;	author bparker;	state Exp;
branches;
next	1.76;

1.76
date	98.10.21.17.19.14;	author bparker;	state Exp;
branches;
next	1.75;

1.75
date	98.06.24.17.45.59;	author bparker;	state Exp;
branches;
next	1.74;

1.74
date	98.06.12.19.46.19;	author bparker;	state Exp;
branches;
next	1.73;

1.73
date	98.06.11.14.28.10;	author bparker;	state Exp;
branches;
next	1.72;

1.72
date	98.03.19.18.12.44;	author bparker;	state Exp;
branches;
next	1.71;

1.71
date	98.02.26.15.55.07;	author bparker;	state Exp;
branches;
next	1.70;

1.70
date	98.02.05.22.52.55;	author bparker;	state Exp;
branches;
next	1.69;

1.69
date	98.01.28.15.30.07;	author bparker;	state Exp;
branches;
next	1.68;

1.68
date	98.01.16.21.57.01;	author bparker;	state Exp;
branches;
next	1.67;

1.67
date	97.12.23.14.09.55;	author bparker;	state Exp;
branches;
next	1.66;

1.66
date	97.11.14.14.58.09;	author bparker;	state Exp;
branches;
next	1.65;

1.65
date	97.11.06.20.03.15;	author bparker;	state Exp;
branches;
next	1.64;

1.64
date	97.10.27.19.20.53;	author bparker;	state Exp;
branches;
next	1.63;

1.63
date	97.10.10.16.56.49;	author bparker;	state Exp;
branches;
next	1.62;

1.62
date	97.09.08.18.53.28;	author bparker;	state Exp;
branches;
next	1.61;

1.61
date	97.09.03.14.33.44;	author bparker;	state Exp;
branches;
next	1.60;

1.60
date	97.08.01.21.13.37;	author bparker;	state Exp;
branches;
next	1.59;

1.59
date	97.07.28.20.21.41;	author bparker;	state Exp;
branches;
next	1.58;

1.58
date	97.07.25.20.37.03;	author bparker;	state Exp;
branches;
next	1.57;

1.57
date	97.06.24.21.27.34;	author bparker;	state Exp;
branches;
next	1.56;

1.56
date	97.05.29.14.18.24;	author bparker;	state Exp;
branches;
next	1.55;

1.55
date	97.05.22.19.18.27;	author bparker;	state Exp;
branches;
next	1.54;

1.54
date	97.05.21.12.50.36;	author bparker;	state Exp;
branches;
next	1.53;

1.53
date	97.05.08.14.38.45;	author bparker;	state Exp;
branches;
next	1.52;

1.52
date	97.03.20.22.14.58;	author bparker;	state Exp;
branches;
next	1.51;

1.51
date	97.03.07.21.38.12;	author bparker;	state Exp;
branches;
next	1.50;

1.50
date	97.03.06.14.06.06;	author bparker;	state Exp;
branches;
next	1.49;

1.49
date	97.02.28.21.35.47;	author bparker;	state Exp;
branches;
next	1.48;

1.48
date	97.02.24.22.08.58;	author bparker;	state Exp;
branches;
next	1.47;

1.47
date	97.02.06.22.00.43;	author bparker;	state Exp;
branches;
next	1.46;

1.46
date	97.01.29.23.13.32;	author bparker;	state Exp;
branches;
next	1.45;

1.45
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	1.44;

1.44
date	97.01.02.19.37.38;	author bparker;	state Exp;
branches;
next	1.43;

1.43
date	96.12.23.22.39.14;	author bparker;	state Exp;
branches;
next	1.42;

1.42
date	96.12.17.22.35.05;	author bparker;	state Exp;
branches;
next	1.41;

1.41
date	96.12.11.22.40.57;	author bparker;	state Exp;
branches;
next	1.40;

1.40
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	1.39;

1.39
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	1.38;

1.38
date	96.12.06.21.55.11;	author bparker;	state Exp;
branches;
next	1.37;

1.37
date	96.12.04.21.13.14;	author bparker;	state Exp;
branches;
next	1.36;

1.36
date	96.11.01.22.10.04;	author bparker;	state Exp;
branches;
next	1.35;

1.35
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	96.10.18.14.05.43;	author bparker;	state Exp;
branches;
next	1.33;

1.33
date	96.10.04.20.35.51;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	96.10.03.20.52.10;	author bparker;	state Exp;
branches;
next	1.31;

1.31
date	96.09.30.19.42.58;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	96.09.26.20.38.22;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	96.09.25.20.04.58;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	96.09.23.18.41.43;	author bparker;	state Exp;
branches;
next	1.27;

1.27
date	96.09.17.21.21.19;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	96.09.03.15.52.52;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	96.08.29.23.14.10;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	96.08.28.19.44.38;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	96.08.14.20.27.25;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	96.08.02.18.11.52;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	96.07.25.17.45.29;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	96.07.19.20.51.38;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	96.06.25.21.01.13;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	96.06.21.15.58.23;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	96.06.14.20.09.16;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	96.06.11.17.37.36;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	96.05.24.18.44.44;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	96.05.16.20.59.26;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	96.04.26.19.01.17;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	95.09.01.23.44.22;	author cnuzman;	state Exp;
branches;
next	1.8;

1.8
date	95.09.01.23.25.29;	author cnuzman;	state Exp;
branches;
next	1.7;

1.7
date	95.09.01.22.15.58;	author cnuzman;	state Exp;
branches;
next	1.6;

1.6
date	95.09.01.15.08.58;	author stay;	state Exp;
branches;
next	1.5;

1.5
date	95.08.31.22.31.06;	author cnuzman;	state Exp;
branches;
next	1.4;

1.4
date	95.08.31.15.26.12;	author cnuzman;	state Exp;
branches;
next	1.3;

1.3
date	95.08.24.06.40.09;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	95.08.23.23.08.58;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	95.08.22.22.32.09;	author cnuzman;	state Exp;
branches;
next	;

1.87.2.1
date	2000.09.01.17.31.46;	author bparker;	state Exp;
branches;
next	1.87.2.2;

1.87.2.2
date	2000.11.09.21.22.47;	author bparker;	state Exp;
branches;
next	;

1.96.4.1
date	2004.03.17.21.21.57;	author morrison;	state Exp;
branches;
next	;

1.96.6.1
date	2002.09.26.23.04.10;	author morrison;	state Exp;
branches;
next	1.96.6.2;

1.96.6.2
date	2004.03.17.04.15.12;	author morrison;	state Exp;
branches;
next	;

1.96.12.1
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@OpenGL display manager
@


1.100
log
@moved to src/mged/
@
text
@/*
 *			D M - O G L . C
 *
 *  Routines specific to MGED's use of LIBDM's OpenGl display manager.
 *
 *  Author -
 *	Robert G. Parker
 *  
 *  Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header:";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <math.h>
#include "tk.h"

#ifndef WIN32
#ifdef USE_MESA_GL
#include <GL/glx.h>
#include <GL/gl.h>
#else
#include <GL/glx.h>
#include <GL/gl.h>
#include <gl/device.h>
#endif
#else
#include <GL/gl.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "dm_xvars.h"
#include "dm-ogl.h"
#include "./ged.h"
#include "./sedit.h"
#include "./mged_dm.h"

extern int _ogl_open_existing();	/* defined in libfb/if_ogl.c */
extern int common_dm();			/* defined in dm-generic.c */
extern void dm_var_init();		/* defined in attach.c */
extern void cs_set_bg();		/* defined in color_scheme.c */

static int	Ogl_dm();
static int	Ogl_doevent();
static void     Ogl_colorchange();
static void     establish_zbuffer();
static void     establish_lighting();
static void     establish_transparency();
static void     dirty_hook();
static void     zclip_hook();
static void     debug_hook();
static void     bound_hook();
static void     boundFlag_hook();
static void     do_fogHint();

struct bu_structparse Ogl_vparse[] = {
	{"%d",	1, "depthcue",		Ogl_MV_O(cueing_on),	Ogl_colorchange },
	{"%d",  1, "zclip",		Ogl_MV_O(zclipping_on),	zclip_hook },
	{"%d",  1, "zbuffer",		Ogl_MV_O(zbuffer_on),	establish_zbuffer },
	{"%d",  1, "lighting",		Ogl_MV_O(lighting_on),	establish_lighting },
	{"%d",  1, "transparency",	Ogl_MV_O(transparency_on), establish_transparency },
	{"%d",  1, "fastfog",		Ogl_MV_O(fastfog),	do_fogHint },
	{"%f",  1, "density",		Ogl_MV_O(fogdensity),	dirty_hook },
	{"%d",  1, "has_zbuf",		Ogl_MV_O(zbuf),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "has_rgb",		Ogl_MV_O(rgb),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "has_doublebuffer",	Ogl_MV_O(doublebuffer), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "depth",		Ogl_MV_O(depth),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "debug",		Ogl_MV_O(debug),	debug_hook },
	{"%f",  1, "bound",		Ogl_MV_O(bound),	bound_hook },
	{"%d",  1, "useBound",		Ogl_MV_O(boundFlag),	boundFlag_hook },
	{"",	0,  (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

#ifdef WIN32  
/* ??? not sure why this is needed? */
extern FBIO ogl_interface;
#endif

int
Ogl_dm_init(struct dm_list	*o_dm_list,
	    int			argc,
	    char		*argv[])
{
	struct bu_vls vls;

	dm_var_init(o_dm_list);

	/* register application provided routines */
	cmd_hook = Ogl_dm;

	Tk_DeleteGenericHandler(doEvent, (ClientData)NULL);

	if ((dmp = dm_open(interp, DM_TYPE_OGL, argc-1, argv)) == DM_NULL)
		return TCL_ERROR;

	/*XXXX this eventually needs to move into Ogl's private structure */
	dmp->dm_vp = &view_state->vs_vop->vo_scale;
	dmp->dm_perspective = mged_variables->mv_perspective_mode;

	eventHandler = Ogl_doevent;
	Tk_CreateGenericHandler(doEvent, (ClientData)NULL);
	(void)DM_CONFIGURE_WIN(dmp);

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "mged_bind_dm %s", bu_vls_addr(&pathName));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_OK;
}

void
Ogl_fb_open()
{
	char *ogl_name = "/dev/ogl";

	if ((fbp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL) {
		Tcl_AppendResult(interp, "Ogl_fb_open: failed to allocate framebuffer memory\n",
				 (char *)NULL);
		return;
	}

	*fbp = ogl_interface; /* struct copy */
	fbp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
	(void)strcpy(fbp->if_name, ogl_name);

	/* Mark OK by filling in magic number */
	fbp->if_magic = FB_MAGIC;
	_ogl_open_existing(fbp,
			   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
			   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
			   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
			   dmp->dm_width, dmp->dm_height,
			   ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc,
			   ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer, 0);
}

/*
   This routine is being called from doEvent() to handle Expose events.
*/
static int
Ogl_doevent(ClientData	clientData,
	    XEvent	*eventPtr)
{
#ifndef WIN32
	if (!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
			    ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc))
		/* allow further processing of this event */
		return TCL_OK;
#else
	  if (!wglMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->hdc,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc))
		return TCL_OK;
#endif

	if (eventPtr->type == Expose && eventPtr->xexpose.count == 0) {
#if 0
		glClearColor(0.0, 0.0, 0.0, 0.0);
#endif
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		dirty = 1;

		/* no further processing of this event */
		return TCL_RETURN;
	}

	/* allow further processing of this event */
	return TCL_OK;
}

/*
 *			O G L _ D M
 * 
 *  Implement display-manager specific commands, from MGED "dm" command.
 */
static int
Ogl_dm(int	argc,
       char	**argv)
{
	  if (!strcmp(argv[0], "set")) {
		  struct bu_vls	vls;

		  bu_vls_init(&vls);

		  if (argc < 2) {
			  /* Bare set command, print out current settings */
			  bu_vls_struct_print2(&vls,
					       "dm_ogl internal variables",
					       Ogl_vparse,
					       (const char *)&((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars);
		  } else if (argc == 2) {
			  bu_vls_struct_item_named(&vls,
						   Ogl_vparse,
						   argv[1],
						   (const char *)&((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars,
						   ',');
		  } else {
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, "%s=\"", argv[1]);
			  bu_vls_from_argv(&tmp_vls, argc-2, argv+2);
			  bu_vls_putc(&tmp_vls, '\"');
			  bu_struct_parse(&tmp_vls,
					  Ogl_vparse,
					  (char *)&((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars);
			  bu_vls_free(&tmp_vls);
		  }

		  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		  bu_vls_free(&vls);

		  return TCL_OK;
	  }

	  return common_dm(argc, argv);
}

static void
Ogl_colorchange()
{
	if (((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.cueing_on) {
		glEnable(GL_FOG);
	} else {
		glDisable(GL_FOG);
	}

	view_state->vs_flag = 1;
}

static void
establish_zbuffer()
{
	(void)DM_SET_ZBUFFER(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on);
	view_state->vs_flag = 1;
}

static void
establish_lighting()
{
	(void)DM_SET_LIGHT(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on);
	view_state->vs_flag = 1;
}

static void
establish_transparency()
{
	(void)DM_SET_TRANSPARENCY(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.transparency_on);
	view_state->vs_flag = 1;
}

static void
do_fogHint()
{
	dm_fogHint(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fastfog);
	view_state->vs_flag = 1;
}

static void
dirty_hook()
{
	dirty = 1;
}

static void
zclip_hook()
{
	dmp->dm_zclip = ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zclipping_on;
	view_state->vs_vop->vo_zclip = dmp->dm_zclip;
	dirty_hook();
}

static void
debug_hook()
{
	DM_DEBUG(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug);
}

static void
bound_hook()
{
	dmp->dm_bound =
		((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.bound;
	dirty_hook();
}

static void
boundFlag_hook()
{
	dmp->dm_boundFlag =
		((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.boundFlag;
	dirty_hook();
}
@


1.99
log
@change conf.h to a wrapped config.h
@
text
@@


1.98
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d20 5
a24 1
#include "conf.h"
@


1.97
log
@merge of windows-6-0-branch into head
@
text
@d66 1
d79 1
d263 7
@


1.96
log
@*- keep vo_zclip in sync with dm_zclip
@
text
@d31 1
d40 3
d90 5
d162 1
d168 5
@


1.96.12.1
log
@merge from head
@
text
@a30 1
#ifndef WIN32
a38 3
#else
#include <GL/gl.h>
#endif
a85 5
#ifdef WIN32  
/* ??? not sure why this is needed? */
extern FBIO ogl_interface;
#endif

a152 1
#ifndef WIN32
a157 5
#else
	  if (!wglMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->hdc,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc))
		return TCL_OK;
#endif
@


1.96.4.1
log
@sync branch with HEAD
@
text
@a30 1
#ifndef WIN32
a38 3
#else
#include <GL/gl.h>
#endif
a85 5
#ifdef WIN32  
/* ??? not sure why this is needed? */
extern FBIO ogl_interface;
#endif

a152 1
#ifndef WIN32
a157 5
#else
	  if (!wglMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->hdc,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc))
		return TCL_OK;
#endif
@


1.96.6.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a30 1
#ifndef WIN32
a38 3
#else
#include <GL/gl.h>
#endif
a85 4
#ifdef WIN32  /* ???????????????????*/
extern FBIO ogl_interface;
#endif

a152 1
#ifndef WIN32
a157 5
#else
	  if (!wglMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->hdc,
		      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc))
		return TCL_OK;
#endif
@


1.96.6.2
log
@remerge head into branch just in case someone checks out this branch later
@
text
@d90 1
a90 2
#ifdef WIN32  
/* ??? not sure why this is needed? */
@


1.95
log
@*- remove use of start/stop_catching_output().
   Use routines that write directly to a vls.
@
text
@d266 1
@


1.94
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d87 3
a89 4
Ogl_dm_init(o_dm_list, argc, argv)
struct dm_list *o_dm_list;
int argc;
char *argv[];
d91 1
a91 1
  struct bu_vls vls;
d93 1
a93 1
  dm_var_init(o_dm_list);
d95 2
a96 2
  /* register application provided routines */
  cmd_hook = Ogl_dm;
d98 1
a98 1
  Tk_DeleteGenericHandler(doEvent, (ClientData)NULL);
d100 2
a101 2
  if((dmp = dm_open(interp, DM_TYPE_OGL, argc-1, argv)) == DM_NULL)
    return TCL_ERROR;
d103 3
a105 3
  /*XXXX this eventually needs to move into Ogl's private structure */
  dmp->dm_vp = &view_state->vs_vop->vo_scale;
  dmp->dm_perspective = mged_variables->mv_perspective_mode;
d107 3
a109 3
  eventHandler = Ogl_doevent;
  Tk_CreateGenericHandler(doEvent, (ClientData)NULL);
  (void)DM_CONFIGURE_WIN(dmp);
d111 4
a114 4
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "mged_bind_dm %s", bu_vls_addr(&pathName));
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d116 1
a116 1
  return TCL_OK;
d122 1
a122 1
  char *ogl_name = "/dev/ogl";
d124 20
a143 20
  if ((fbp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL) {
    Tcl_AppendResult(interp, "Ogl_fb_open: failed to allocate framebuffer memory\n",
		     (char *)NULL);
    return;
  }

  *fbp = ogl_interface; /* struct copy */
  fbp->if_name = malloc((unsigned)strlen(ogl_name) + 1);
  (void)strcpy(fbp->if_name, ogl_name);

  /* Mark OK by filling in magic number */
  fbp->if_magic = FB_MAGIC;
  _ogl_open_existing(fbp,
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
		     dmp->dm_width, dmp->dm_height,
		     ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc,
		     ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer, 0);
d150 8
a157 9
Ogl_doevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  if(!glXMakeCurrent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
     ((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc))
    /* allow further processing of this event */
    return TCL_OK;
d159 1
a159 1
  if(eventPtr->type == Expose && eventPtr->xexpose.count == 0){
d161 1
a161 1
    glClearColor(0.0, 0.0, 0.0, 0.0);
d163 1
a163 1
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
d165 1
a165 1
    dirty = 1;
d167 3
a169 3
    /* no further processing of this event */
    return TCL_RETURN;
  }
d171 2
a172 2
  /* allow further processing of this event */
  return TCL_OK;
d181 38
a218 33
Ogl_dm(argc, argv)
int argc;
char **argv;
{
  struct bu_vls	vls;

  if( !strcmp( argv[0], "set" ) )  {
    struct bu_vls tmp_vls;

    bu_vls_init(&vls);
    bu_vls_init(&tmp_vls);
    start_catching_output(&tmp_vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      bu_struct_print("dm_ogl internal variables", Ogl_vparse, (const char *)&((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars );
    } else if( argc == 2 ) {
      bu_vls_struct_item_named( &vls, Ogl_vparse, argv[1], (const char *)&((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars, ',');
      bu_log( "%s", bu_vls_addr(&vls) );
    } else {
      bu_vls_printf( &vls, "%s=\"", argv[1] );
      bu_vls_from_argv( &vls, argc-2, argv+2 );
      bu_vls_putc( &vls, '\"' );
      bu_struct_parse( &vls, Ogl_vparse, (char *)&((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars );
    }

    bu_vls_free(&vls);

    stop_catching_output(&tmp_vls);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
    return TCL_OK;
  }
d220 1
a220 1
  return common_dm(argc, argv);
d226 5
a230 5
  if(((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.cueing_on) {
    glEnable(GL_FOG);
  }else{
    glDisable(GL_FOG);
  }
d232 1
a232 1
  view_state->vs_flag = 1;
d238 2
a239 2
  (void)DM_SET_ZBUFFER(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on);
  view_state->vs_flag = 1;
d245 2
a246 2
  (void)DM_SET_LIGHT(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on);
  view_state->vs_flag = 1;
d252 2
a253 2
  dm_fogHint(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fastfog);
  view_state->vs_flag = 1;
d259 1
a259 1
  dirty = 1;
d265 2
a266 2
  dmp->dm_zclip = ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zclipping_on;
  dirty_hook();
d272 1
a272 1
  DM_DEBUG(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.debug);
d278 3
a280 3
  dmp->dm_bound =
    ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.bound;
  dirty_hook();
d286 3
a288 3
  dmp->dm_boundFlag =
    ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.boundFlag;
  dirty_hook();
@


1.93
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@a104 1
#ifdef MGED_USE_VIEW_OBJ
a105 3
#else
  dmp->dm_vp = &view_state->vs_Viewscale;
#endif
@


1.92
log
@updated SIGNED to signed
updated CONST to const
@
text
@d105 3
d109 1
@


1.91
log
@*- get rid of warnings
@
text
@d198 1
a198 1
      bu_struct_print("dm_ogl internal variables", Ogl_vparse, (CONST char *)&((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars );
d200 1
a200 1
      bu_vls_struct_item_named( &vls, Ogl_vparse, argv[1], (CONST char *)&((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars, ',');
@


1.90
log
@patches to merge 5.3 into 6.0
@
text
@d22 6
@


1.89
log
@signature for dm_open() changed to include interp
@
text
@d223 1
a223 1
  ++view_state->vs_flag;
a228 4
#if 0
  dm_zbuffer(dmp,
	     ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on);
#else
d230 1
a230 2
#endif
  ++view_state->vs_flag;
a235 4
#if 0
  dm_lighting(dmp,
	      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on);
#else
d237 1
a237 2
#endif
  ++view_state->vs_flag;
d243 2
a244 3
  dm_fogHint(dmp,
	      ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fastfog);
  ++view_state->vs_flag;
@


1.88
log
@
const RCSid
@
text
@d95 1
a95 1
  if((dmp = dm_open(DM_TYPE_OGL, argc-1, argv)) == DM_NULL)
@


1.87
log
@*- mods to always have a framebuffer
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header:";
@


1.87.2.1
log
@dm_open has new signature (i.e. interp)
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header:";
d95 1
a95 1
  if((dmp = dm_open(interp, DM_TYPE_OGL, argc-1, argv)) == DM_NULL)
@


1.87.2.2
log
@A little house cleaning.
@
text
@d223 1
a223 1
  view_state->vs_flag = 1;
d229 4
d234 2
a235 1
  view_state->vs_flag = 1;
d241 4
d246 2
a247 1
  view_state->vs_flag = 1;
d253 3
a255 2
  dm_fogHint(dmp, ((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.fastfog);
  view_state->vs_flag = 1;
@


1.86
log
@Eliminated some unused variables
@
text
@d46 1
d117 1
a117 2
  int status;
  struct bu_vls vls;
d119 2
a120 19
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "fb_open_existing /dev/ogl %lu %lu %lu %lu %d %d %lu %d %d",
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
		dmp->dm_width, dmp->dm_height,
		(unsigned long)((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc,
		((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer, 0);
  status = Tcl_Eval(interp, bu_vls_addr(&vls));

  if(status == TCL_OK){
    if(sscanf(interp->result, "%lu", (unsigned long *)&fbp) != 1){
      fbp = (FBIO *)0;   /* sanity */
      Tcl_AppendResult(interp, "Ogl_fb_open: failed to get framebuffer pointer\n",
		       (char *)NULL);
    }
  }else
    Tcl_AppendResult(interp, "Ogl_fb_open: failed to get framebuffer\n",
d122 2
d125 14
a138 1
  bu_vls_free(&vls);
@


1.85
log
@*- use DM_CONFIGURE_WIN, DM_SET_ZBUFFER, and DM_SET_LIGHT
@
text
@a84 1
  int i;
a182 1
  int status;
@


1.84
log
@*- perspective is now a member of struct dm
@
text
@d104 1
a104 1
  dm_configureWindowShape(dmp);
d233 1
d236 3
d245 1
d248 3
@


1.83
log
@*- add display manager variables: bound, useBound
@
text
@d100 1
a100 1
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->perspective_mode = &mged_variables->mv_perspective_mode;
@


1.82
log
@*- update comments for dm-specific event handling routines
@
text
@d56 4
d64 1
a64 1
	{"%d",  1, "zclip",		Ogl_MV_O(zclipping_on),	dirty_hook },
d73 3
a75 1
	{"%d",  1, "debug",		Ogl_MV_O(debug),	BU_STRUCTPARSE_FUNC_NULL },
d101 1
a101 1
  zclip_ptr = &((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.zclipping_on;
d258 29
@


1.81
log
@*- mods to better support Mesa
@
text
@d139 1
a139 6
   This routine is being called from doEvent().
   It does not handle mouse button or key events. The key
   events are being processed via the TCL/TK bind command or are being
   piped to ged.c/stdin_input(). Eventually, I'd also like to have the
   dials+buttons bindable. That would leave this routine to handle only
   events like Expose and ConfigureNotify.
@


1.80
log
@*- add parameter to dm_zbuffer(), dm_lighting() and dm_fogHint()
@
text
@a24 1
#if 1
d26 2
a27 2
#include <MESA_GL/glx.h>
#include <MESA_GL/gl.h>
a31 1
#endif
@


1.79
log
@*- modified display manager specific dm command to return single
	values without a newline.
@
text
@d234 2
a235 1
  dm_zbuffer(dmp);
d242 2
a243 1
  dm_lighting(dmp);
d250 2
a251 1
  ogl_fogHint(dmp);
@


1.78
log
@*- some cleanup
@
text
@d200 1
a200 1
      bu_log( "%s\n", bu_vls_addr(&vls) );
@


1.77
log
@*- use new structures
*- cleanup
@
text
@a106 17
#if 0
  /*XXX Experimenting */
  bu_vls_printf(&vls1, "dm_info(%s)", bu_vls_addr(&dmp->dm_pathName));
  bu_vls_printf(&vls2, "%lu %lu %lu %lu %d %d %lu %d %d",
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
		dmp->dm_width, dmp->dm_height,
		(unsigned long)((struct ogl_vars *)dmp->dm_vars.priv_vars)->glxc,
		((struct ogl_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer, 0);
  Tcl_SetVar(interp, bu_vls_addr(&vls1), bu_vls_addr(&vls2), TCL_GLOBAL_ONLY);
#endif

  /* initialize the background color */
  cs_set_bg();

@


1.76
log
@*- add call to cs_set_bg to set the background color
@
text
@d84 2
a88 1
  dm_var_init(o_dm_list);
d95 2
a96 2
  dmp->dm_vp = &Viewscale;
  ((struct ogl_vars *)dmp->dm_vars.priv_vars)->perspective_mode = &mged_variables->perspective_mode;
a98 1
  curr_dm_list->s_info->opp = &pathName;
d245 1
a245 1
  ++dmaflag;
d252 1
a252 1
  ++dmaflag;
d259 1
a259 1
  ++dmaflag;
d266 1
a266 1
  ++dmaflag;
@


1.75
log
@*- remove use of color_soltab()
@
text
@d48 3
a50 1
extern int common_dm();				/* defined in dm-generic.c */
a51 4
extern void ogl_configureWindow();

extern void dm_var_init();

d120 3
@


1.74
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@a237 1
  color_soltab();
@


1.73
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d176 1
d178 1
@


1.72
log
@call init script after return from dm_open()
@
text
@a49 1
#ifdef USE_FRAMEBUFFER
a50 1
#endif
a125 1
#ifdef USE_FRAMEBUFFER
a154 1
#endif
@


1.71
log
@*- using new dm_vars structure
*- using code common to display managers that connect to an X server
@
text
@d86 1
a86 2
  char **av;
  struct bu_vls name_vls, value_vls;
a90 12
  /* stuff in a default initialization script */
  av = (char **)bu_malloc(sizeof(char *)*(argc + 2), "Ogl_dm_init: av");
  av[0] = "ogl_open";
  av[1] = "-i";
  av[2] = "mged_bind_dm";

  /* copy the rest except last */
  for(i = 1; i < argc-1; ++i)
    av[i+2] = argv[i];

  av[i+2] = (char *)NULL;

d93 2
a94 2
  if((dmp = dm_open(DM_TYPE_OGL, argc+1, av)) == DM_NULL){
    bu_free(av, "Ogl_dm_init: av");
a95 1
  }
a96 1
  bu_free(av, "Ogl_dm_init: av");
d106 4
a109 1
  bu_vls_init(&value_vls);
d111 1
a111 1
#if 1
d113 2
a114 3
  bu_vls_init(&name_vls);
  bu_vls_printf(&name_vls, "dm_info(%s)", bu_vls_addr(&dmp->dm_pathName));
  bu_vls_printf(&value_vls, "%lu %lu %lu %lu %d %d %lu %d %d",
d122 1
a122 3
  Tcl_SetVar(interp, bu_vls_addr(&name_vls), bu_vls_addr(&value_vls), TCL_GLOBAL_ONLY);
  bu_vls_free(&name_vls);
  bu_vls_free(&value_vls);
@


1.70
log
@using grid_snap in Ogl_dm()
@
text
@d4 4
d10 2
a11 2
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
d13 1
a13 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
d15 1
a21 1
#include <stdio.h>
a22 20
#include <termio.h>
#undef VMIN		/* is used in vmath.h, too */
#include <ctype.h>

#include <sys/types.h>
#include <sys/time.h>

#include <X11/X.h>
#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif
#if defined(linux)
#	undef   X_NOT_STDC_ENV
#	undef   X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
#include <X11/Xlib.h>
#include <X11/Xutil.h>

a23 3
#include <X11/extensions/XI.h>
#include <X11/extensions/XInput.h>
#include <X11/keysym.h>
d25 1
d34 1
d42 2
d45 1
a46 2
#include "./sedit.h"
#include "dm-ogl.h"
d48 1
a48 3
#ifdef DO_SNAP_TO_GRID
extern void snap_to_grid();
#endif
a53 5
#ifdef DO_RUBBER_BAND
extern void rt_rect_area(); /* from rect.c */
extern void zoom_rect_area();
#endif

a54 3
extern void mged_print_result();
extern point_t e_axes_pos;
extern point_t curr_e_axes_pos;
a55 2
static void     set_knob_offset();
static void     Ogl_statechange();
d61 1
a61 1
static void     refresh_hook();
d66 1
a66 1
	{"%d",  1, "zclip",		Ogl_MV_O(zclipping_on),	refresh_hook },
d70 1
a70 1
	{"%f",  1, "density",		Ogl_MV_O(fogdensity),	refresh_hook },
a78 40
#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
#endif

#ifdef IR_KNOBS
void ogl_dbtext();
/*
 *  Labels for knobs in help mode.
 */
static char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
static char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

static int OgldoMotion = 0;

a90 1
  state_hook = Ogl_statechange;
d114 2
a115 2
  ((struct ogl_vars *)dmp->dm_vars)->perspective_mode = &mged_variables->perspective_mode;
  zclip_ptr = &((struct ogl_vars *)dmp->dm_vars)->mvars.zclipping_on;
d128 4
a131 4
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->dpy,
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->win,
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->cmap,
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->vip,
d133 2
a134 2
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->glxc,
		((struct ogl_vars *)dmp->dm_vars)->mvars.doublebuffer, 0);
d152 4
a155 4
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->dpy,
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->win,
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->cmap,
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->vip,
d157 2
a158 2
		(unsigned long)((struct ogl_vars *)dmp->dm_vars)->glxc,
		((struct ogl_vars *)dmp->dm_vars)->mvars.doublebuffer, 0);
d188 4
a191 8
  static int button0  = 0;   /*  State of button 0 */
  static int knob_values[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  struct bu_vls cmd;
  int save_edflag = -1;

  if(!glXMakeCurrent(((struct ogl_vars *)dmp->dm_vars)->dpy,
     ((struct ogl_vars *)dmp->dm_vars)->win,
     ((struct ogl_vars *)dmp->dm_vars)->glxc))
d194 1
a194 23
  /* Forward key events to a command window */
  if(mged_variables->send_key && eventPtr->type == KeyPress){
    char buffer[2];
    KeySym keysym;
    struct dm_char_queue *dcqp;

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  &keysym, (XComposeStatus *)NULL);

    if(keysym == mged_variables->hot_key)
      return TCL_OK;

    BU_GETSTRUCT(dcqp, dm_char_queue);
    dcqp->dlp = curr_dm_list;
    BU_LIST_PUSH(&head_dm_char_queue.l, &dcqp->l);
    write(dm_pipe[1], buffer, 1);

    /* Use this so that these events won't propagate */
    return TCL_RETURN;
  }

  bu_vls_init(&cmd);
  if ( eventPtr->type == Expose && eventPtr->xexpose.count == 0 ) {
a198 3
    goto handled;
  } else if( eventPtr->type == ConfigureNotify ) {
    XConfigureEvent *conf = (XConfigureEvent *)eventPtr;
d200 2
a201 1209
    dm_configureWindowShape(dmp);
    dirty = 1;

#ifdef USE_FRAMEBUFFER
    if(fbp)
      ogl_configureWindow(fbp, conf->width, conf->height);
#endif

    goto handled;
  } else if( eventPtr->type == MapNotify ){
    mapped = 1;

    goto handled;
  } else if( eventPtr->type == UnmapNotify ){
    mapped = 0;

    goto handled;
  } else if( eventPtr->type == MotionNotify ) {
    int mx, my;
    int dx, dy;
    fastf_t f;
    fastf_t fx, fy;
    fastf_t td;

    mx = eventPtr->xmotion.x;
    my = eventPtr->xmotion.y;
    dx = mx - ((struct ogl_vars *)dmp->dm_vars)->omx;
    dy = my - ((struct ogl_vars *)dmp->dm_vars)->omy;

    switch(am_mode){
    case AMM_IDLE:
#if 1
      if(scroll_active)
#else
      if(scroll_active && eventPtr->xmotion.state & ((struct ogl_vars *)dmp->dm_vars)->mb_mask)
#endif
	bu_vls_printf( &cmd, "M 1 %d %d\n",
		       (int)(dm_Xx2Normal(dmp, mx, 0) * 2047.0),
		       (int)(dm_Xy2Normal(dmp, my) * 2047.0) );
#ifdef DO_RUBBER_BAND
#if 1
      else if(rubber_band_active){
#else
      else if(rubber_band_active && eventPtr->xmotion.state & ((struct ogl_vars *)dmp->dm_vars)->mb_mask){
#endif
	fastf_t x = dm_Xx2Normal(dmp, mx, 1);
	fastf_t y = dm_Xy2Normal(dmp, my);

	rect_width = x - rect_x;
	rect_height = y - rect_y;

	dirty = 1;
      }
#endif
      else if(OgldoMotion)
	/* do the regular thing */
	/* Constant tracking (e.g. illuminate mode) bound to M mouse */
	bu_vls_printf( &cmd, "M 0 %d %d\n",
		       (int)(dm_Xx2Normal(dmp, mx, 1) * 2047.0),
		       (int)(dm_Xy2Normal(dmp, my) * 2047.0) );
      else /* not doing motion */
	goto handled;

      break;
    case AMM_ROT:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	char save_coords;

	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	if(mged_variables->rateknobs)
	  bu_vls_printf(&cmd, "knob -i x %lf y %lf\n",
			dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
			dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
	else
	  bu_vls_printf(&cmd, "knob -i ax %lf ay %lf\n",
			dy * 0.25, dx * 0.25);

	(void)Tcl_Eval(interp, bu_vls_addr(&cmd));

	mged_variables->coords = save_coords;
	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct ogl_vars *)dmp->dm_vars)->omx = mx;
	((struct ogl_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      if(mged_variables->rateknobs)
	bu_vls_printf(&cmd, "knob -i -v x %lf y %lf\n",
		      dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
		      dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
      else
	bu_vls_printf(&cmd, "knob -i -v ax %lf ay %lf\n",
		      dy * 0.25, dx * 0.25);

      break;
    case AMM_TRAN:
      fx = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      fy = -dy / (fastf_t)dmp->dm_height * 2.0;
      
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	char save_coords;

	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}

	if(mged_variables->rateknobs)
	  bu_vls_printf(&cmd, "knob -i X %lf Y %lf\n", fx, fy);
	else
	  bu_vls_printf(&cmd, "knob -i aX %lf aY %lf\n",
			fx*Viewscale*base2local, fy*Viewscale*base2local);

	(void)Tcl_Eval(interp, bu_vls_addr(&cmd));

	mged_variables->coords = save_coords;
	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct ogl_vars *)dmp->dm_vars)->omx = mx;
	((struct ogl_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      /* otherwise, drag to translate the view */
      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i -v X %lf Y %lf\n", fx, fy );
      else
	bu_vls_printf( &cmd, "knob -i -v aX %lf aY %lf\n",
		       fx*Viewscale*base2local, fy*Viewscale*base2local );

      break;
    case AMM_SCALE:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_SCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_ADC_ANG1:
      fx = dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc;
      bu_vls_printf(&cmd, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));

      break;
    case AMM_ADC_ANG2:
      fx = dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc;
      bu_vls_printf(&cmd, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));

      break;
    case AMM_ADC_TRAN:
      bu_vls_printf(&cmd, "adc hv %lf %lf\n",
		    dm_Xx2Normal(dmp, mx, 1) * Viewscale * base2local,
		    dm_Xy2Normal(dmp, my) * Viewscale * base2local);

      break;
    case AMM_ADC_DIST:
      fx = (dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc) * Viewscale * base2local / 2047.0;
      td = sqrt(fx * fx + fy * fy);
      bu_vls_printf(&cmd, "adc dst %lf\n", td);

      break;
    case AMM_CON_ROT_X:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i x %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i ax %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct ogl_vars *)dmp->dm_vars)->omx = mx;
	((struct ogl_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      break;
    case AMM_CON_ROT_Y:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i y %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i ay %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct ogl_vars *)dmp->dm_vars)->omx = mx;
	((struct ogl_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      break;
    case AMM_CON_ROT_Z:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i z %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i az %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct ogl_vars *)dmp->dm_vars)->omx = mx;
	((struct ogl_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      break;
    case AMM_CON_TRAN_X:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_X;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i X %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aX %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_TRAN_Y:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_Y;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i Y %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aY %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_TRAN_Z:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i Z %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aZ %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_SCALE_X:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_XSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_SCALE_Y:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_YSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_SCALE_Z:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_ZSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_XADC:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i xadc %f\n",
		     f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0 );
      break;
    case AMM_CON_YADC:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i yadc %f\n",
		     f / (fastf_t)dmp->dm_height * 4095.0 );

      break;
    case AMM_CON_ANG1:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i ang1 %f\n",
		     f / (fastf_t)dmp->dm_width * 90.0 );

      break;
    case AMM_CON_ANG2:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i ang2 %f\n",
		     f / (fastf_t)dmp->dm_width * 90.0 );

      break;
    case AMM_CON_DIST:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i distadc %f\n",
		     f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0 );

      break;
    }

    ((struct ogl_vars *)dmp->dm_vars)->omx = mx;
    ((struct ogl_vars *)dmp->dm_vars)->omy = my;
  }
#if IR_KNOBS
  else if( eventPtr->type == ((struct ogl_vars *)dmp->dm_vars)->devmotionnotify ){
    XDeviceMotionEvent *M;
    int setting;
    fastf_t f;

    M = (XDeviceMotionEvent * ) eventPtr;

    if(button0){
      ogl_dbtext(
		(mged_variables->adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
      goto handled;
    }

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(mged_variables->adcflag) {
	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_1adc )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_1adc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob ang1 %f\n",
		       45.0 - 45.0*((double)setting)/2047.0);
      }else{
	if(mged_variables->rateknobs){
	  f = rate_model_rotate[Z];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	       M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob -m z %f\n", setting / 512.0 );
	}else{
	  f = absolute_model_rotate[Z];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob -m az %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL1:
      if(mged_variables->rateknobs){
	if(EDIT_SCALE && mged_variables->transform == 'e')
	  f = edit_rate_scale;
	else
	  f = rate_scale;

	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob S %f\n", setting / 512.0 );
      }else{
	if(EDIT_SCALE && mged_variables->transform == 'e')
	  f = edit_absolute_scale;
	else
	  f = absolute_scale;

	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob aS %f\n", setting / 512.0 );
      }
      break;
    case DIAL2:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_2adc )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_2adc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob ang2 %f\n",
		       45.0 - 45.0*((double)setting)/2047.0);
      }else {
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_rate_model_rotate[Z];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[Z];
	  else
	    f = rate_rotate[Z];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob z %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_absolute_model_rotate[Z];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[Z];
	  else
	    f = absolute_rotate[Z];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob az %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL3:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_distadc)
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_distadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob distadc %d\n", setting );
      }else {
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	    case 'o':
	      f = edit_rate_model_tran[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_tran[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_tran[Z];
	  else
	    f = rate_tran[Z];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob Z %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	    case 'o':
	      f = edit_absolute_model_tran[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_tran[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_tran[Z];
	  else
	    f = absolute_tran[Z];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf(&cmd, "knob aZ %f\n", setting / 512.0 * Viewscale * base2local);
	}
      }
      break;
    case DIAL4:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_yadc)
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_yadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob yadc %d\n", setting );
      }else{
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_rate_model_rotate[Y];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[Y];
	  else
	    f = rate_rotate[Y];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob y %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_absolute_model_rotate[Y];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[Y];
	  else
	    f = absolute_rotate[Y];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob ay %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL5:
      if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	    case 'o':
	      f = edit_rate_model_tran[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_tran[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_tran[Y];
	  else
	    f = rate_tran[Y];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob Y %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
	  case 'm':
	  case 'o':
	    f = edit_absolute_model_tran[Y];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_tran[Y];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_tran[Y];
	else
	  f = absolute_tran[Y];

	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] -
	    knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf(&cmd, "knob aY %f\n", setting / 512.0 * Viewscale * base2local);
      }
      break;
    case DIAL6:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_xadc)
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_xadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob xadc %d\n", setting );
      }else{
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_rate_model_rotate[X];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[X];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[X];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[X];
	  else
	    f = rate_rotate[X];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob x %f\n", setting / 512.0);
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_absolute_model_rotate[X];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[X];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[X];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[X];
	  else
	    f = absolute_rotate[X];

	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob ax %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL7:
      if(mged_variables->rateknobs){
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
	  case 'm':
	  case 'o':
	    f = edit_rate_model_tran[X];
	    break;
	  case 'v':
	  default:
	    f = edit_rate_view_tran[X];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = rate_model_tran[X];
	else
	  f = rate_tran[X];

	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob X %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
	  case 'm':
	  case 'o':
	    f = edit_absolute_model_tran[X];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_tran[X];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_tran[X];
	else
	  f = absolute_tran[X];

	if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf(&cmd, "knob aX %f\n", setting / 512.0 * Viewscale * base2local);
      }
      break;
    default:
      break;
    }

    /* Keep track of the knob values */
    knob_values[M->first_axis] = M->axis_data[0];
  }
#endif
#if IR_BUTTONS
  else if( eventPtr->type == ((struct ogl_vars *)dmp->dm_vars)->devbuttonpress ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      button0 = 1;
      goto handled;
    }

    if(button0){
      ogl_dbtext(label_button(bmap[B->button - 1]));
    }else if(B->button == 4){
      bu_vls_strcat(&cmd, "knob zero\n");
      set_knob_offset();
    }else
      bu_vls_printf(&cmd, "press %s\n",
		    label_button(bmap[B->button - 1]));
  }else if( eventPtr->type == ((struct ogl_vars *)dmp->dm_vars)->devbuttonrelease ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1)
      button0 = 0;

    goto handled;
  }
#endif
  else if(eventPtr->type == KeyPress){
    /*XXX Hack to prevent Tk from choking on certain control sequences */
    if(eventPtr->xkey.state & ControlMask){
      char buffer[1];
      KeySym keysym;

      XLookupString(&(eventPtr->xkey), buffer, 1,
		    &keysym, (XComposeStatus *)NULL);

      if(keysym == XK_c || keysym == XK_t || keysym == XK_v ||
	 keysym == XK_w || keysym == XK_x || keysym == XK_y)
	goto handled;
    }

    /* let other KeyPress events get processed by Tcl/Tk */
    goto not_handled;
  }else{
    /* allow all other events to be handled by Tcl/Tk */
    goto not_handled;
d204 1
a204 18
  (void)Tcl_Eval(interp, bu_vls_addr(&cmd));
  if(save_edflag != -1){
    if(SEDIT_TRAN || SEDIT_ROTATE || SEDIT_SCALE)
      es_edflag = save_edflag;
    else if(OEDIT_TRAN || OEDIT_ROTATE || OEDIT_SCALE)
      edobj = save_edflag;
  }

handled:
  bu_vls_free(&cmd);

  /* event handled here; prevent someone else from handling the event */
  return TCL_RETURN;

not_handled:
  bu_vls_free(&cmd);

  /* let someone else handle the event */
a207 36
static void
Ogl_statechange( a, b )
int	a, b;
{
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( b )  {
	case ST_VIEW:
	    /* constant tracking OFF */
	    OgldoMotion = 0;
	    break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	case ST_S_VPICK:
	    /* constant tracking ON */
	    OgldoMotion = 1;
	    break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	    /* constant tracking OFF */
	    OgldoMotion = 0;
	    break;
	default:
	  Tcl_AppendResult(interp, "Ogl_statechange: unknown state ",
			   state_str[b], "\n", (char *)NULL);
	  break;
	}

	/*Ogl_viewchange( DM_CHGV_REDO, SOLID_NULL );*/
	++dmaflag;
}

d215 2
a216 2
int	argc;
char	**argv;
d218 1
a219 4
  int status;
  char *av[6];
  char xstr[32];
  char ystr[32];
d230 1
a230 1
      bu_struct_print("dm_ogl internal variables", Ogl_vparse, (CONST char *)&((struct ogl_vars *)dmp->dm_vars)->mvars );
d232 1
a232 1
      bu_vls_struct_item_named( &vls, Ogl_vparse, argv[1], (CONST char *)&((struct ogl_vars *)dmp->dm_vars)->mvars, ',');
d238 1
a238 1
      bu_struct_parse( &vls, Ogl_vparse, (char *)&((struct ogl_vars *)dmp->dm_vars)->mvars );
d249 1
a249 468
  if(!strcmp(argv[0], "idle")){
    am_mode = AMM_IDLE;
    scroll_active = 0;
#ifdef DO_RUBBER_BAND
    if(rubber_band_active){
      rubber_band_active = 0;
      dirty = 1;

      if(mged_variables->mouse_behavior == 'r')
	rt_rect_area();
      else if(mged_variables->mouse_behavior == 'z')
	zoom_rect_area();
    }
#endif    

    return TCL_OK;
  }

  if( !strcmp( argv[0], "m" )){
    if( argc < 4){
      Tcl_AppendResult(interp, "dm m: need more parameters\n",
		       "dm m button xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    /* This assumes a 3-button mouse */
    switch(*argv[1]){
    case '1':
      ((struct ogl_vars *)dmp->dm_vars)->mb_mask = Button1Mask;
      break;
    case '2':
      ((struct ogl_vars *)dmp->dm_vars)->mb_mask = Button2Mask;
      break;
    case '3':
      ((struct ogl_vars *)dmp->dm_vars)->mb_mask = Button3Mask;
      break;
    default:
      Tcl_AppendResult(interp, "dm m: bad button value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    {
      int x;
      int y;
      int old_orig_gui;
      int stolen = 0;
      fastf_t fx, fy;

      old_orig_gui = mged_variables->orig_gui;

      fx = dm_Xx2Normal(dmp, atoi(argv[2]), 0);
      fy = dm_Xy2Normal(dmp, atoi(argv[3]));
      x = fx * 2047.0;
      y = fy * 2047.0;

      if(mged_variables->faceplate &&
	 mged_variables->orig_gui){
#define        MENUXLIM        (-1250)

#if 0
	if(scroll_active){
	  stolen = 1;
	  goto end;
	}
#endif

	if(x >= MENUXLIM && scroll_select( x, y, 0 )){
	  stolen = 1;
	  goto end;
	}

	if(x < MENUXLIM && mmenu_select( y, 0)){
	  stolen = 1;
	  goto end;
	}
      }

      mged_variables->orig_gui = 0;
      fx = dm_Xx2Normal(dmp, atoi(argv[2]), 1);
      x = fx * 2047.0;

end:
      bu_vls_init(&vls);
      if(mged_variables->mouse_behavior == 'q' && !stolen){
	point_t view_pt;
	point_t model_pt;

	VSET(view_pt, fx, fy, 1.0);
	MAT4X3PNT(model_pt, view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);
	if(*zclip_ptr)
	  bu_vls_printf(&vls, "nirt %lf %lf %lf",
			model_pt[X], model_pt[Y], model_pt[Z]);
	else
	  bu_vls_printf(&vls, "nirt -b %lf %lf %lf",
			model_pt[X], model_pt[Y], model_pt[Z]);
#ifdef DO_RUBBER_BAND
      }else if((mged_variables->mouse_behavior == 'p' ||
		mged_variables->mouse_behavior == 'r' ||
		mged_variables->mouse_behavior == 'z') && !stolen){
	rubber_band_active = 1;
	rect_x = fx;
	rect_y = fy;
	rect_width = 0.0;
	rect_height = 0.0;

	dirty = 1;
#endif
#ifdef DO_SNAP_TO_GRID
      }else if(mged_variables->grid_snap && !stolen &&
	       state != ST_S_PICK && state != ST_O_PICK &&
	       state != ST_O_PATH && !SEDIT_PICK){
	point_t view_pt;
	point_t model_pt;

	snap_to_grid(&fx, &fy);

	if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	   mged_variables->transform == 'e'){
	  char save_coords;
	  int save_edflag = -1;

	  save_coords = mged_variables->coords;
	  mged_variables->coords = 'v';

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_TRAN)
	      es_edflag = STRANS;
	  }else{
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }

	  MAT4X3PNT(view_pt, model2view, curr_e_axes_pos);
	  view_pt[X] = fx;
	  view_pt[Y] = fy;
	  MAT4X3PNT(model_pt, view2model, view_pt);
	  VSCALE(model_pt, model_pt, base2local);
	  bu_vls_printf(&vls, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));

	  mged_variables->coords = save_coords;
	  if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	  else
	    edobj = save_edflag;

	  mged_variables->orig_gui = old_orig_gui;
	  bu_vls_free(&vls);
	  return status;
	}else{
	  point_t vcenter;

	  MAT_DELTAS_GET_NEG(vcenter, toViewcenter);
	  MAT4X3PNT(view_pt, model2view, vcenter);
	  view_pt[X] = fx;
	  view_pt[Y] = fy;
	  MAT4X3PNT(model_pt, view2model, view_pt);
	  VSCALE(model_pt, model_pt, base2local);
	  bu_vls_printf(&vls, "center %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	}
#endif
      }else
	bu_vls_printf(&vls, "M 1 %d %d\n", x, y);

      status = Tcl_Eval(interp, bu_vls_addr(&vls));
      mged_variables->orig_gui = old_orig_gui;
      bu_vls_free(&vls);

      return status;
    }
  }

  if(!strcmp(argv[0], "am")){
#if 0
    scroll_active = 0;
#endif

    if( argc < 4){
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "dm am <r|t|s> xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct ogl_vars *)dmp->dm_vars)->omx = atoi(argv[2]);
    ((struct ogl_vars *)dmp->dm_vars)->omy = atoi(argv[3]);

    switch(*argv[1]){
    case 'r':
      am_mode = AMM_ROT;
      break;
    case 't':
      am_mode = AMM_TRAN;

      if(EDIT_TRAN && mged_variables->transform == 'e'){
	char save_coords;
	point_t mouse_view_pos;
	point_t ea_view_pos;
	point_t diff;

	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';

	MAT4X3PNT(ea_view_pos, model2view, e_axes_pos);
	mouse_view_pos[X] = dm_Xx2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1);
	mouse_view_pos[Y] = dm_Xy2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy);
	mouse_view_pos[Z] = ea_view_pos[Z];
	VSUB2(diff, mouse_view_pos, ea_view_pos);
	VSCALE(diff, diff, Viewscale * base2local);

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob aX %lf aY %lf\n", diff[X], diff[Y]);
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	mged_variables->coords = save_coords;
      }

      break;
    case 's':
      if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	 NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	acc_sc_sol = 1.0;
      else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	edit_absolute_scale = acc_sc_obj - 1.0;
	if(edit_absolute_scale > 0.0)
	  edit_absolute_scale /= 3.0;
      }

      am_mode = AMM_SCALE;
      break;
    default:
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "dm am <r|t|s> xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "adc")){
    fastf_t fx, fy;
    fastf_t td; /* tick distance */
#if 0
    scroll_active = 0;
#endif

    if(argc < 4){
      Tcl_AppendResult(interp, "dm adc: need more parameters\n",
		       "dm adc 1|2|t|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct ogl_vars *)dmp->dm_vars)->omx = atoi(argv[2]);
    ((struct ogl_vars *)dmp->dm_vars)->omy = atoi(argv[3]);

    switch(*argv[1]){
    case '1':
      fx = dm_Xx2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_ANG1;
      break;
    case '2':
      fx = dm_Xx2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_ANG2;
      break;
    case 't':
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc hv %lf %lf\n",
		    dm_Xx2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) *
		    Viewscale * base2local,
		    dm_Xy2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) *
		    Viewscale * base2local);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_TRAN;
      break;
    case 'd':
      fx = (dm_Xx2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
	    dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Xy2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 -
	    dv_yadc) * Viewscale * base2local / 2047.0;

      td = sqrt(fx * fx + fy * fy);
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc dst %lf\n", td);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_DIST;
      break;
      default:
	Tcl_AppendResult(interp, "dm adc: unrecognized parameter - ", argv[1],
			 "\ndm adc 1|2|t|d xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "con")){
#if 0
    scroll_active = 0;
#endif

    if(argc < 5){
      Tcl_AppendResult(interp, "dm con: need more parameters\n",
		       "dm con r|t|s x|y|z xpos ypos\n",
		       "dm con a x|y|1|2|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct ogl_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct ogl_vars *)dmp->dm_vars)->omy = atoi(argv[4]);

    switch(*argv[1]){
    case 'a':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_XADC;
	break;
      case 'y':
	am_mode = AMM_CON_YADC;
	break;
      case '1':
	am_mode = AMM_CON_ANG1;
	break;
      case '2':
	am_mode = AMM_CON_ANG2;
	break;
      case 'd':
	am_mode = AMM_CON_DIST;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con a x|y|1|2|d xpos ypos\n", (char *)NULL);
      }
      break;
    case 'r':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_ROT_X;
	break;
      case 'y':
	am_mode = AMM_CON_ROT_Y;
	break;
      case 'z':
	am_mode = AMM_CON_ROT_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    case 't':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_TRAN_X;
	break;
      case 'y':
	am_mode = AMM_CON_TRAN_Y;
	break;
      case 'z':
	am_mode = AMM_CON_TRAN_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    case 's':
      switch(*argv[2]){
      case 'x':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[0] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_X;
	break;
      case 'y':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[1] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_Y;
	break;
      case 'z':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[2] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    default:
      Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[1],
		       "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if( !strcmp( argv[0], "size" )){
    int width, height;

    /* get the window size */
    if( argc == 1 ){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d", dmp->dm_width, dmp->dm_height);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }

    /* set the window size */
    if( argc == 3 ){
      width = atoi( argv[1] );
      height = atoi( argv[2] );

      Tk_GeometryRequest(((struct ogl_vars *)dmp->dm_vars)->xtkwin, width, height);

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "Usage: dm size [width height]\n", (char *)NULL);
    return TCL_ERROR;
  }

  Tcl_AppendResult(interp, "dm: bad command - ", argv[0], "\n", (char *)NULL);
  return TCL_ERROR;
d256 1
a256 1
  if(((struct ogl_vars *)dmp->dm_vars)->mvars.cueing_on) {
d287 1
a287 16
refresh_hook()
{
  dmaflag = 1;
}

#if IR_KNOBS
void
ogl_dbtext(str)
{
  Tcl_AppendResult(interp, "dm-ogl: You pressed Help key and '",
		   str, "'\n", (char *)NULL);
}
#endif

static void
set_knob_offset()
d289 1
a289 4
  int i;

  for(i = 0; i < 8; ++i)
    ((struct ogl_vars *)dmp->dm_vars)->knobs[i] = 0;
@


1.69
log
@*- added Ogl_fb_open
*- now using coords instead of ecoords
@
text
@d67 4
d83 1
d1720 55
@


1.68
log
@*- mods to use/implement MGED's new rubber band capability
*- mods to use MGED's new framebuffer capability
@
text
@a188 31
#ifdef USE_FRAMEBUFFER
  {
    int status;
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "fb_open_existing /dev/ogl %lu %lu %lu %lu %d %d %lu %d %d",
		  (unsigned long)((struct ogl_vars *)dmp->dm_vars)->dpy,
		  (unsigned long)((struct ogl_vars *)dmp->dm_vars)->win,
		  (unsigned long)((struct ogl_vars *)dmp->dm_vars)->cmap,
		  (unsigned long)((struct ogl_vars *)dmp->dm_vars)->vip,
		  dmp->dm_width, dmp->dm_height,
		  (unsigned long)((struct ogl_vars *)dmp->dm_vars)->glxc,
		  ((struct ogl_vars *)dmp->dm_vars)->mvars.doublebuffer, 0);
    status = Tcl_Eval(interp, bu_vls_addr(&vls));

    if(status == TCL_OK){
      if(sscanf(interp->result, "%lu", (unsigned long *)&fbp) != 1){
	fbp = (FBIO *)0;   /* sanity */
	Tcl_AppendResult(interp, "Ogl_dm_init: failed to get framebuffer pointer\n",
			 (char *)NULL);
      }else
	bu_vls_printf(&value_vls, "%s ", interp->result);
    }else{
      Tcl_AppendResult(interp, "Ogl_dm_init: failed to get framebuffer\n",
		       (char *)NULL);
    }

    bu_vls_free(&vls);
  }
#endif
d210 32
d300 2
a301 1
    ogl_configureWindow(fbp, conf->width, conf->height);
d363 1
a363 1
	char save_ecoords;
d365 2
a366 2
	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';
d387 1
a387 1
	mged_variables->ecoords = save_ecoords;
d413 1
a413 1
	char save_ecoords;
d415 2
a416 2
	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';
d435 1
a435 1
	mged_variables->ecoords = save_ecoords;
d922 1
a922 1
	    switch(mged_variables->ecoords){
d962 1
a962 1
	    switch(mged_variables->ecoords){
d1019 1
a1019 1
	    switch(mged_variables->ecoords){
d1057 1
a1057 1
	    switch(mged_variables->ecoords){
d1112 1
a1112 1
	    switch(mged_variables->ecoords){
d1152 1
a1152 1
	    switch(mged_variables->ecoords){
d1196 1
a1196 1
	    switch(mged_variables->ecoords){
d1234 1
a1234 1
	  switch(mged_variables->ecoords){
d1289 1
a1289 1
	    switch(mged_variables->ecoords){
d1329 1
a1329 1
	    switch(mged_variables->ecoords){
d1373 1
a1373 1
	  switch(mged_variables->ecoords){
d1411 1
a1411 1
	  switch(mged_variables->ecoords){
d1691 1
a1691 1
      if(mged_variables->mouse_behavior == 'n' && !stolen){
d1749 1
a1749 1
	char save_ecoords;
d1754 2
a1755 2
	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';
d1768 1
a1768 1
	mged_variables->ecoords = save_ecoords;
@


1.67
log
@call nirt from Ogl_dm()
@
text
@a63 1
#include "./mged_solid.h"
d67 9
d153 1
d188 50
d293 2
d296 5
a301 1
    dirty = 1;
d325 3
d329 1
d331 17
a347 2
		       (int)(dm_X2Normal(dmp, mx, 0) * 2047.0),
		       (int)(dm_Y2Normal(dmp, my) * 2047.0) );
d352 2
a353 2
		       (int)(dm_X2Normal(dmp, mx, 1) * 2047.0),
		       (int)(dm_Y2Normal(dmp, my) * 2047.0) );
d476 2
a477 2
      fx = dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc;
d482 2
a483 2
      fx = dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc;
d489 2
a490 2
		    dm_X2Normal(dmp, mx, 1) * Viewscale * base2local,
		    dm_Y2Normal(dmp, my) * Viewscale * base2local);
d494 2
a495 2
      fx = (dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc) * Viewscale * base2local / 2047.0;
d1608 13
a1624 2
    scroll_active = 0;

d1652 1
d1656 4
a1659 2
      x = dm_X2Normal(dmp, atoi(argv[2]), 0) * 2047.0;
      y = dm_Y2Normal(dmp, atoi(argv[3])) * 2047.0;
d1664 2
d1670 1
d1684 2
a1685 1
      x = dm_X2Normal(dmp, atoi(argv[2]), 1) * 2047.0;
d1689 1
a1689 1
      if(mged_variables->mouse_nirt && !stolen){
a1691 1
	fastf_t sf = 1.0/2047.0;
d1693 1
a1693 2
	VSET(view_pt, x, y, 2047.0);
	VSCALE(view_pt, view_pt, sf);
d1702 12
d1726 1
d1728 1
d1756 2
a1757 2
	mouse_view_pos[X] = dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1);
	mouse_view_pos[Y] = dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy);
d1794 1
a1794 1

d1796 1
d1809 2
a1810 2
      fx = dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
d1819 2
a1820 2
      fx = dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
d1831 1
a1831 1
		    dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) *
d1833 1
a1833 1
		    dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) *
d1841 1
a1841 1
      fx = (dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
d1843 1
a1843 1
      fy = (dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 -
d1864 1
d1866 1
@


1.66
log
@*- move perspective stuff to set.c
*- mods to reflect name changes in LIBDM
@
text
@d173 1
d209 1
d217 3
d1556 1
d1566 4
a1569 2
	if(scroll_active)
	   goto end;
d1571 2
a1572 1
	if(x >= MENUXLIM && scroll_select( x, y, 0 ))
d1574 1
d1576 2
a1577 1
	if(x < MENUXLIM && mmenu_select( y, 0))
d1579 1
d1587 18
a1604 1
      bu_vls_printf(&vls, "M 1 %d %d\n", x, y);
@


1.65
log
@use new mged variable: ecoords
@
text
@a78 2
static void     establish_perspective();
static void     set_perspective();
d80 1
a80 1
static void     do_fog();
d82 14
a95 3
#if IR_KNOBS
void ogl_dbtext();
#endif
a115 17
struct bu_structparse Ogl_vparse[] = {
	{"%d",	1, "depthcue",		Ogl_MV_O(cueing_on),	Ogl_colorchange },
	{"%d",  1, "zclip",		Ogl_MV_O(zclipping_on),	refresh_hook },
	{"%d",  1, "zbuffer",		Ogl_MV_O(zbuffer_on),	establish_zbuffer },
	{"%d",  1, "lighting",		Ogl_MV_O(lighting_on),	establish_lighting },
 	{"%d",  1, "perspective",       Ogl_MV_O(perspective_mode), establish_perspective },
	{"%d",  1, "set_perspective",   Ogl_MV_O(dummy_perspective),  set_perspective },
	{"%d",  1, "fastfog",		Ogl_MV_O(fastfog),	do_fog },
	{"%f",  1, "density",		Ogl_MV_O(fogdensity),	refresh_hook },
	{"%d",  1, "has_zbuf",		Ogl_MV_O(zbuf),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "has_rgb",		Ogl_MV_O(rgb),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "has_doublebuffer",	Ogl_MV_O(doublebuffer), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "depth",		Ogl_MV_O(depth),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "debug",		Ogl_MV_O(debug),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0,  (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

d117 1
d172 1
d176 1
a176 1
  ogl_configure_window_shape(dmp);
d229 1
a229 1
    ogl_configure_window_shape(dmp);
d1891 1
a1891 1
  ogl_establish_zbuffer(dmp);
d1898 1
a1898 15
  ogl_establish_lighting(dmp);
  ++dmaflag;
}

static void
establish_perspective()
{
  ogl_establish_perspective(dmp);
  ++dmaflag;
}

static void
set_perspective()
{
  ogl_set_perspective(dmp);
d1903 1
a1903 1
do_fog()
d1905 1
a1905 1
  ogl_do_fog(dmp);
@


1.64
log
@mods to Ogl_dm()
@
text
@d278 1
a278 1
	char save_coords;
d280 2
a281 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d302 1
a302 1
	mged_variables->coords = save_coords;
d328 1
a328 1
	char save_coords;
d330 2
a331 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d350 1
a350 1
	mged_variables->coords = save_coords;
d837 1
a837 1
	    switch(mged_variables->coords){
d877 1
a877 1
	    switch(mged_variables->coords){
d934 1
a934 1
	    switch(mged_variables->coords){
d972 1
a972 1
	    switch(mged_variables->coords){
d1027 1
a1027 1
	    switch(mged_variables->coords){
d1067 1
a1067 1
	    switch(mged_variables->coords){
d1111 1
a1111 1
	    switch(mged_variables->coords){
d1149 1
a1149 1
	  switch(mged_variables->coords){
d1204 1
a1204 1
	    switch(mged_variables->coords){
d1244 1
a1244 1
	    switch(mged_variables->coords){
d1288 1
a1288 1
	  switch(mged_variables->coords){
d1326 1
a1326 1
	  switch(mged_variables->coords){
d1610 1
a1610 1
	char save_coords;
d1615 2
a1616 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d1629 1
a1629 1
	mged_variables->coords = save_coords;
d1890 1
a1890 3
#if 0
  dmp->dm_colorchange(dmp);
#endif
@


1.63
log
@*- mods to Ogl_doevent
*- mods to support using only one registered event handler within MGED
@
text
@d1523 5
d1531 1
a1531 1
    if( argc < 5){
d1533 1
a1533 1
		       "dm m button 1|0 xpos ypos\n", (char *)NULL);
d1560 2
a1561 2
      x = dm_X2Normal(dmp, atoi(argv[3]), 0) * 2047.0;
      y = dm_Y2Normal(dmp, atoi(argv[4])) * 2047.0;
d1564 1
a1564 2
	 mged_variables->orig_gui &&
	 *argv[2] == '1'){
d1577 1
a1577 1
      x = dm_X2Normal(dmp, atoi(argv[3]), 1) * 2047.0;
d1581 1
a1581 1
      bu_vls_printf(&vls, "M %s %d %d\n", argv[2], x, y);
a1590 2
    int buttonpress;

d1593 1
a1593 1
    if( argc < 5){
d1595 1
a1595 1
		       "dm am <r|t|s> 1|0 xpos ypos\n", (char *)NULL);
d1599 2
a1600 3
    buttonpress = atoi(argv[2]);
    ((struct ogl_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct ogl_vars *)dmp->dm_vars)->omy = atoi(argv[4]);
d1602 6
a1607 7
    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	am_mode = AMM_ROT;
	break;
      case 't':
	am_mode = AMM_TRAN;
d1609 15
a1623 29
	if(EDIT_TRAN && mged_variables->transform == 'e'){
	  char save_coords;
	  point_t mouse_view_pos;
	  point_t ea_view_pos;
	  point_t diff;

	  save_coords = mged_variables->coords;
	  mged_variables->coords = 'v';

	  MAT4X3PNT(ea_view_pos, model2view, e_axes_pos);
#if 1
	  mouse_view_pos[X] = dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1);
	  mouse_view_pos[Y] = dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy);
#else
	  mouse_view_pos[X] = (((struct ogl_vars *)dmp->dm_vars)->omx /
			       (fastf_t)dmp->dm_width - 0.5) / dmp->dm_aspect * 2.0;
	  mouse_view_pos[Y] = (0.5 - ((struct ogl_vars *)dmp->dm_vars)->omy /
			       (fastf_t)dmp->dm_height) * 2.0;
#endif
	  mouse_view_pos[Z] = ea_view_pos[Z];
	  VSUB2(diff, mouse_view_pos, ea_view_pos);
	  VSCALE(diff, diff, Viewscale * base2local);

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "knob aX %lf aY %lf\n", diff[X], diff[Y]);
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  mged_variables->coords = save_coords;
	}
d1625 6
a1630 10
	break;
      case 's':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc_obj - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}
d1632 9
a1640 6
	am_mode = AMM_SCALE;
	break;
      default:
	Tcl_AppendResult(interp, "dm am: need more parameters\n",
			 "dm am <r|t|s> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
d1643 6
a1648 1
      return TCL_OK;
a1650 1
    am_mode = AMM_IDLE;
a1654 1
    int buttonpress;
d1660 1
a1660 1
    if(argc < 5){
d1662 1
a1662 1
		       "dm adc 1|2|t|d 1|0 xpos ypos\n", (char *)NULL);
d1666 2
a1667 3
    buttonpress = atoi(argv[2]);
    ((struct ogl_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct ogl_vars *)dmp->dm_vars)->omy = atoi(argv[4]);
d1669 8
a1676 9
    if(buttonpress){
      switch(*argv[1]){
      case '1':
	fx = dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
	fy = dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1678 9
a1686 9
	am_mode = AMM_ADC_ANG1;
	break;
      case '2':
	fx = dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
	fy = dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1688 11
a1698 11
	am_mode = AMM_ADC_ANG2;
	break;
      case 't':
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc hv %lf %lf\n",
		      dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) *
		      Viewscale * base2local,
		      dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) *
		      Viewscale * base2local);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1700 7
a1706 7
	am_mode = AMM_ADC_TRAN;
	break;
      case 'd':
	fx = (dm_X2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
	      dv_xadc) * Viewscale * base2local / 2047.0;
	fy = (dm_Y2Normal(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) * 2047.0 -
	      dv_yadc) * Viewscale * base2local / 2047.0;
d1708 5
a1712 5
	td = sqrt(fx * fx + fy * fy);
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc dst %lf\n", td);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1714 2
a1715 2
	am_mode = AMM_ADC_DIST;
	break;
d1718 1
a1718 1
			  "\ndm adc 1|2|t|d 1|0 xpos ypos\n", (char *)NULL);
a1719 3
      }

      return TCL_OK;
a1721 1
    am_mode = AMM_IDLE;
a1725 2
    int buttonpress;

d1728 1
a1728 1
    if(argc < 6){
d1730 2
a1731 2
		       "dm con r|t|s x|y|z 1|0 xpos ypos\n",
		       "dm con a x|y|1|2|d 1|0 xpos ypos\n", (char *)NULL);
d1735 53
a1787 27
    buttonpress = atoi(argv[3]);
    ((struct ogl_vars *)dmp->dm_vars)->omx = atoi(argv[4]);
    ((struct ogl_vars *)dmp->dm_vars)->omy = atoi(argv[5]);

    if(buttonpress){
      switch(*argv[1]){
      case 'a':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_XADC;
	  break;
	case 'y':
	  am_mode = AMM_CON_YADC;
	  break;
	case '1':
	  am_mode = AMM_CON_ANG1;
	  break;
	case '2':
	  am_mode = AMM_CON_ANG2;
	  break;
	case 'd':
	  am_mode = AMM_CON_DIST;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			   "\ndm con a x|y|1|2|d 1|0 xpos ypos\n", (char *)NULL);
	}
d1789 16
a1804 15
      case 'r':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_ROT_X;
	  break;
	case 'y':
	  am_mode = AMM_CON_ROT_Y;
	  break;
	case 'z':
	  am_mode = AMM_CON_ROT_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
d1806 2
d1809 8
a1816 15
      case 't':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_TRAN_X;
	  break;
	case 'y':
	  am_mode = AMM_CON_TRAN_Y;
	  break;
	case 'z':
	  am_mode = AMM_CON_TRAN_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
d1818 2
d1821 8
a1828 42
      case 's':
	switch(*argv[2]){
	case 'x':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[0] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }

	  am_mode = AMM_CON_SCALE_X;
	  break;
	case 'y':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[1] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }

	  am_mode = AMM_CON_SCALE_Y;
	  break;
	case 'z':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[2] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }

	  am_mode = AMM_CON_SCALE_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
d1830 2
d1834 2
a1835 2
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[1],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1838 5
a1842 2

      return TCL_OK;
a1844 1
    am_mode = AMM_IDLE;
d1851 10
a1860 3
    if( argc < 3 ){
      Tcl_AppendResult(interp, "Usage: dm size width height\n", (char *)NULL);
      return TCL_ERROR;
d1863 4
a1866 2
    width = atoi( argv[1] );
    height = atoi( argv[2] );
d1868 1
a1868 1
    Tk_GeometryRequest(((struct ogl_vars *)dmp->dm_vars)->xtkwin, width, height);
d1870 5
a1874 1
    return TCL_OK;
@


1.62
log
@mged_variables is now a pointer
@
text
@d170 2
a171 2
  Tk_DeleteGenericHandler(Ogl_doevent, (ClientData)DM_TYPE_OGL);
  if((dmp = dm_open(DM_TYPE_OGL, DM_EVENT_HANDLER_NULL, argc+1, av)) == DM_NULL){
d179 1
a179 1
  dmp->dm_eventHandler = Ogl_doevent;
d181 1
a181 1
  Tk_CreateGenericHandler(Ogl_doevent, (ClientData)DM_TYPE_OGL);
d187 8
a202 3
  struct ogl_vars *p;
  register struct dm_list *save_dm_list;
  int status = TCL_OK;
a204 12
  GET_DM(p, ogl_vars, eventPtr->xany.window, &head_ogl_vars.l);
  if(p == (struct ogl_vars *)NULL || eventPtr->type == DestroyNotify)
    return TCL_OK;

  bu_vls_init(&cmd);
  save_dm_list = curr_dm_list;

  GET_DM_LIST(curr_dm_list, ogl_vars, eventPtr->xany.window);

  if(curr_dm_list == DM_LIST_NULL)
    goto end;

d208 1
a208 1
    goto end;
d219 1
a219 1
      goto end;
a222 3
    bu_vls_free(&cmd);
    curr_dm_list = save_dm_list;

d227 1
d233 1
a233 1
    goto end;
d238 1
a238 1
    goto end;
d241 2
a242 1
    goto end;
d245 2
a246 1
    goto end;
d272 1
a272 1
	goto end;
d310 1
a310 1
	goto end;
d358 1
a358 1
	goto end;
d449 1
a449 1
	goto end;
d485 1
a485 1
	goto end;
d521 1
a521 1
	goto end;
d728 1
a728 1
      goto end;
d1379 1
a1379 1
      goto end;
d1398 1
a1398 1
    goto end;
d1401 1
a1401 1
  else {
d1403 1
a1403 1
    if(eventPtr->type == KeyPress && eventPtr->xkey.state & ControlMask){
d1411 2
a1412 6
	 keysym == XK_w || keysym == XK_x || keysym == XK_y){
	bu_vls_free(&cmd);
	curr_dm_list = save_dm_list;

	return TCL_RETURN;
      }
d1415 5
a1419 1
    goto end;
d1422 1
a1422 1
  status = Tcl_Eval(interp, bu_vls_addr(&cmd));
d1429 8
a1436 1
end:
a1437 1
  curr_dm_list = save_dm_list;
d1439 2
a1440 1
  return status;
a1893 9
#if IR_KNOBS
void
ogl_dbtext(str)
{
  Tcl_AppendResult(interp, "dm-ogl: You pressed Help key and '",
		   str, "'\n", (char *)NULL);
}
#endif

d1949 9
@


1.61
log
@*** empty log message ***
@
text
@d218 1
a218 1
  if(mged_variables.send_key && eventPtr->type == KeyPress){
d225 1
a225 1
    if(keysym == mged_variables.hot_key)
d284 1
a284 1
	 mged_variables.transform == 'e'){
d287 2
a288 2
	save_coords = mged_variables.coords;
	mged_variables.coords = 'v';
d299 1
a299 1
	if(mged_variables.rateknobs)
d309 1
a309 1
	mged_variables.coords = save_coords;
d320 1
a320 1
      if(mged_variables.rateknobs)
d334 1
a334 1
	 mged_variables.transform == 'e'){
d337 2
a338 2
	save_coords = mged_variables.coords;
	mged_variables.coords = 'v';
d349 1
a349 1
	if(mged_variables.rateknobs)
d357 1
a357 1
	mged_variables.coords = save_coords;
d369 1
a369 1
      if(mged_variables.rateknobs)
d378 1
a378 1
	 mged_variables.transform == 'e'){
d393 1
a393 1
      if(mged_variables.rateknobs)
d430 1
a430 1
      if(mged_variables.rateknobs)
d437 1
a437 1
	 mged_variables.transform == 'e'){
d466 1
a466 1
      if(mged_variables.rateknobs)
d473 1
a473 1
	 mged_variables.transform == 'e'){
d502 1
a502 1
      if(mged_variables.rateknobs)
d509 1
a509 1
	 mged_variables.transform == 'e'){
d534 1
a534 1
	 mged_variables.transform == 'e'){
d549 1
a549 1
      if(mged_variables.rateknobs)
d557 1
a557 1
	 mged_variables.transform == 'e'){
d572 1
a572 1
      if(mged_variables.rateknobs)
d580 1
a580 1
	 mged_variables.transform == 'e'){
d595 1
a595 1
      if(mged_variables.rateknobs)
d603 1
a603 1
	 mged_variables.transform == 'e'){
d618 1
a618 1
      if(mged_variables.rateknobs)
d626 1
a626 1
	 mged_variables.transform == 'e'){
d641 1
a641 1
      if(mged_variables.rateknobs)
d649 1
a649 1
	 mged_variables.transform == 'e'){
d664 1
a664 1
      if(mged_variables.rateknobs)
d734 1
a734 1
		(mged_variables.adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
d740 1
a740 1
      if(mged_variables.adcflag) {
d754 1
a754 1
	if(mged_variables.rateknobs){
d788 2
a789 2
      if(mged_variables.rateknobs){
	if(EDIT_SCALE && mged_variables.transform == 'e')
d807 1
a807 1
	if(EDIT_SCALE && mged_variables.transform == 'e')
d827 1
a827 1
      if(mged_variables.adcflag){
d841 1
a841 1
	if(mged_variables.rateknobs){
d843 2
a844 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d864 1
a864 1
	  }else if(mged_variables.coords == 'm')
d883 2
a884 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d904 1
a904 1
	  }else if(mged_variables.coords == 'm')
d925 1
a925 1
      if(mged_variables.adcflag){
d938 1
a938 1
	if(mged_variables.rateknobs){
d940 2
a941 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d959 1
a959 1
	  }else if(mged_variables.coords == 'm')
d978 2
a979 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d997 1
a997 1
	  }else if(mged_variables.coords == 'm')
d1018 1
a1018 1
      if(mged_variables.adcflag){
d1031 1
a1031 1
	if(mged_variables.rateknobs){
d1033 2
a1034 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1054 1
a1054 1
	  }else if(mged_variables.coords == 'm')
d1073 2
a1074 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1094 1
a1094 1
	  }else if(mged_variables.coords == 'm')
d1115 1
a1115 1
      if(mged_variables.rateknobs){
d1117 2
a1118 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1136 1
a1136 1
	  }else if(mged_variables.coords == 'm')
d1155 2
a1156 2
	   && mged_variables.transform == 'e'){
	  switch(mged_variables.coords){
d1174 1
a1174 1
	}else if(mged_variables.coords == 'm')
d1195 1
a1195 1
      if(mged_variables.adcflag){
d1208 1
a1208 1
	if(mged_variables.rateknobs){
d1210 2
a1211 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1231 1
a1231 1
	  }else if(mged_variables.coords == 'm')
d1250 2
a1251 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1271 1
a1271 1
	  }else if(mged_variables.coords == 'm')
d1292 1
a1292 1
      if(mged_variables.rateknobs){
d1294 2
a1295 2
	   && mged_variables.transform == 'e'){
	  switch(mged_variables.coords){
d1313 1
a1313 1
	}else if(mged_variables.coords == 'm')
d1332 2
a1333 2
	   && mged_variables.transform == 'e'){
	  switch(mged_variables.coords){
d1351 1
a1351 1
	}else if(mged_variables.coords == 'm')
d1553 1
a1553 1
      old_orig_gui = mged_variables.orig_gui;
d1558 2
a1559 2
      if(mged_variables.faceplate &&
	 mged_variables.orig_gui &&
d1572 1
a1572 1
      mged_variables.orig_gui = 0;
d1579 1
a1579 1
      mged_variables.orig_gui = old_orig_gui;
d1609 1
a1609 1
	if(EDIT_TRAN && mged_variables.transform == 'e'){
d1615 2
a1616 2
	  save_coords = mged_variables.coords;
	  mged_variables.coords = 'v';
d1636 1
a1636 1
	  mged_variables.coords = save_coords;
d1641 1
a1641 1
	if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1644 1
a1644 1
	else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1820 1
a1820 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1823 1
a1823 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1832 1
a1832 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1835 1
a1835 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1844 1
a1844 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1847 1
a1847 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
@


1.60
log
@use dm_X2Normal() and dm_Y2Normal()
@
text
@d270 2
a271 1
		       dm_X2Normal(dmp, mx, 0) * 2047.0, dm_Y2Normal(dmp, my) * 2047.0 );
d276 2
a277 1
		       dm_X2Normal(dmp, mx, 1) * 2047.0, dm_Y2Normal(dmp, my) * 2047.0 );
@


1.59
log
@*** empty log message ***
@
text
@d15 1
a15 1
static char RCSid[] = "";
d244 1
a244 1
    ogl_configure_window_shape(curr_dm_list->_dmp);
d270 1
a270 1
		       ogl_irisX2ged(dmp, mx, 0), ogl_irisY2ged(dmp, my));
d275 1
a275 1
		       ogl_irisX2ged(dmp, mx, 1), ogl_irisY2ged(dmp, my));
d398 3
a400 3
      fx = ogl_irisX2ged(dmp, mx, 1) - dv_xadc;
      fy = ogl_irisY2ged(dmp, my) - dv_yadc;
      bu_vls_printf(&cmd, "adc a1 %lf\n", -DEGRAD*atan2(fx, fy));
d404 3
a406 3
      fx = ogl_irisX2ged(dmp, mx, 1) - dv_xadc;
      fy = ogl_irisY2ged(dmp, my) - dv_yadc;
      bu_vls_printf(&cmd, "adc a2 %lf\n", -DEGRAD*atan2(fx, fy));
d411 2
a412 2
		    ogl_irisX2ged(dmp, mx, 1) * Viewscale * base2local / 2047.0,
		    ogl_irisY2ged(dmp, my) * Viewscale * base2local / 2047.0);
d416 2
a417 2
      fx = (ogl_irisX2ged(dmp, mx, 1) - dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (ogl_irisY2ged(dmp, my) - dv_yadc) * Viewscale * base2local / 2047.0;;
d1553 2
a1554 2
      x = ogl_irisX2ged(dmp, atoi(argv[3]), 0);
      y = ogl_irisY2ged(dmp, atoi(argv[4]));
d1571 1
a1571 1
      x = ogl_irisX2ged(dmp, atoi(argv[3]), 1);
d1591 1
a1591 1
		       "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
a1607 1
#if 1
d1617 4
d1625 1
a1634 14
#else
	  point_t view_pos;

	  view_pos[X] = (((struct ogl_vars *)dmp->dm_vars)->omx /
			 (fastf_t)dmp->dm_width - 0.5) / dmp->dm_aspect * 2.0;
	  view_pos[Y] = (0.5 - ((struct ogl_vars *)dmp->dm_vars)->omy /
			 (fastf_t)dmp->dm_height) * 2.0;
	  view_pos[Z] = 0.0;

	  if(state == ST_S_EDIT)
	    sedit_mouse(view_pos);
	  else
	    objedit_mouse(view_pos);
#endif
d1652 1
a1652 1
			 "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d1683 2
a1684 2
	fx = ogl_irisX2ged(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) - dv_xadc;
	fy = ogl_irisY2ged(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) - dv_yadc;
d1686 1
a1686 1
	bu_vls_printf(&vls, "adc a1 %lf\n", -DEGRAD*atan2(fx, fy));
d1693 2
a1694 2
	fx = ogl_irisX2ged(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) - dv_xadc;
	fy = ogl_irisY2ged(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) - dv_yadc;
d1696 1
a1696 1
	bu_vls_printf(&vls, "adc a2 %lf\n", -DEGRAD*atan2(fx, fy));
d1705 4
a1708 4
		      ogl_irisX2ged(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) *
		      Viewscale * base2local / 2047.0,
		      ogl_irisY2ged(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) *
		      Viewscale * base2local / 2047.0);
d1715 4
a1718 4
	fx = (ogl_irisX2ged(dmp, ((struct ogl_vars *)dmp->dm_vars)->omx, 1) - dv_xadc) *
	  Viewscale * base2local / 2047.0;
	fy = (ogl_irisY2ged(dmp, ((struct ogl_vars *)dmp->dm_vars)->omy) - dv_yadc) *
	  Viewscale * base2local / 2047.0;;
@


1.58
log
@more mods for new interface
@
text
@a382 4
#if 0
	  save_movedir = movedir;
	  movedir = SARROW;
#endif
a538 4
#if 0
	  save_movedir = movedir;
	  movedir = RARROW;
#endif
a561 4
#if 0
	  save_movedir = movedir;
	  movedir = UARROW;
#endif
a584 4
#if 0
	  save_movedir = movedir;
	  movedir = UARROW | RARROW;
#endif
a607 4
#if 0
	  save_movedir = movedir;
	  movedir = SARROW;
#endif
a630 4
#if 0
	  save_movedir = movedir;
	  movedir = SARROW;
#endif
a653 4
#if 0
	  save_movedir = movedir;
	  movedir = SARROW;
#endif
a860 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a900 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a955 4
#if 0
	      save_movedir = movedir;
	      movedir = UARROW | RARROW;
#endif
a993 4
#if 0
	      save_movedir = movedir;
	      movedir = UARROW | RARROW;
#endif
a1050 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a1090 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a1132 4
#if 0
	      save_movedir = movedir;
	      movedir = UARROW | RARROW;
#endif
a1170 4
#if 0
	    save_movedir = movedir;
	    movedir = UARROW | RARROW;
#endif
a1227 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a1267 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a1309 4
#if 0
	    save_movedir = movedir;
	    movedir = UARROW | RARROW;
#endif
a1347 4
#if 0
	    save_movedir = movedir;
	    movedir = UARROW | RARROW;
#endif
d1431 1
a1431 1
    else if(OEDIT_TRAN || OEDIT_ROTATE || OEDIT_SCALE){
a1432 4
#if 0
      movedir = save_movedir;
#endif
    }
@


1.57
log
@mods to implement the lastest mouse interface
@
text
@a67 1
extern void vrot2mrot();
d70 1
a81 2
static void     set_linewidth();
static void     set_linestyle();
a107 2
	{"%d",  1, "linewidth",		Ogl_MV_O(linewidth),	set_linewidth },
	{"%d",  1, "linestyle",		Ogl_MV_O(linestyle),	set_linestyle },
d198 1
d258 2
d267 1
a267 1
    case ALT_IDLE:
d280 17
a296 31
    case ALT_ROT:
#if 0
/*XXX Experimenting */
      if(EDIT_ROTATE && mged_variables.transform == 'e'){
	mat_t mat;
	mat_t vrot;
	mat_t new_acc_rot_sol;
	mat_t invViewrot;
	vect_t view_direc, model_direc;
	point_t rot_point;

	bn_mat_idn(vrot);
	bn_mat_idn(new_acc_rot_sol);
	bn_mat_idn(incr_change);
	buildHrot(vrot, dy * 0.025, dx * 0.025, 0.0);
	bn_mat_inv(invViewrot, Viewrot);

	VSET(view_direc, 0, 0, 1);
	VSET(rot_point, 0, 0, 0);
	MAT4X3VEC(model_direc, invViewrot, view_direc);
	wrt_point_direc(incr_change, vrot, bn_mat_identity, rot_point, model_direc);

	incr_change[3] = incr_change[7] = incr_change[11] = 0.0;
	incr_change[15] = 1.0;

	bn_mat_mul(new_acc_rot_sol, incr_change, acc_rot_sol);
	bn_mat_copy(acc_rot_sol, new_acc_rot_sol);
	inpara = 0;
	sedit();
      }else{
#endif
d298 3
a300 3
	  bu_vls_printf( &cmd, "knob -i -v x %f y %f\n",
			 dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
			 dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
d302 2
a303 9
	  bu_vls_printf( &cmd, "knob -i -v ax %f ay %f\n",
			 dy * 0.25, dx * 0.25 );
#if 0
      }
#endif
      break;
    case ALT_TRAN:
      if(EDIT_TRAN && mged_variables.transform == 'e'){
	vect_t view_pos;
d305 1
a305 3
	view_pos[X] = (mx / (fastf_t)dmp->dm_width - 0.5) / dmp->dm_aspect * 2.0; 
	view_pos[Y] = (0.5 - my / (fastf_t)dmp->dm_height) * 2.0;
	view_pos[Z] = 0.0;
d307 1
d309 1
a309 1
	  sedit_mouse(view_pos);
d311 1
a311 1
	  objedit_mouse(view_pos);
d313 2
d316 9
a324 2
      }else{
	fastf_t fx, fy;
d326 20
a345 2
	fx = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
	fy = -dy / (fastf_t)dmp->dm_height * 2.0;
d348 1
a348 1
	  bu_vls_printf( &cmd, "knob -i -v X %f Y %f\n", fx, fy );
d350 14
a363 1
	  bu_vls_printf( &cmd, "knob -i -v aX %f aY %f\n", fx, fy );
d366 7
d374 16
a389 1
    case ALT_ZOOM:
d399 19
d419 5
a423 4
    case ALT_ADC:
      bu_vls_printf( &cmd, "knob -i xadc %f yadc %f\n",
		     dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0,
		     -dy / (fastf_t)dmp->dm_height * 4095.0 );
d426 1
a426 1
    case ALT_CON_ROT_X:
d429 1
a429 1
      else if(mged_variables.coords == 'm')
a430 2
      else
	f = dy;
d438 23
d462 1
a462 1
    case ALT_CON_ROT_Y:
d473 24
d498 1
a498 1
    case ALT_CON_ROT_Z:
d509 105
d615 16
a630 1
    case ALT_CON_TRAN_X:
d637 1
a637 2
	bu_vls_printf( &cmd, "knob -i X %f\n",
		       f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0 );
d639 2
a640 2
	bu_vls_printf( &cmd, "knob -i aX %f\n",
		       f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0 );
d642 16
a657 1
    case ALT_CON_TRAN_Y:
d664 1
a664 2
	bu_vls_printf( &cmd, "knob -i Y %f\n",
		       f / (fastf_t)dmp->dm_width * 2.0);
d666 1
a666 2
	bu_vls_printf( &cmd, "knob -i aY %f\n",
		       f / (fastf_t)dmp->dm_width * 2.0 );
d669 16
a684 1
    case ALT_CON_TRAN_Z:
d691 1
a691 2
	bu_vls_printf( &cmd, "knob -i Z %f\n",
		       f / (fastf_t)dmp->dm_width * 2.0);
d693 2
a694 2
	bu_vls_printf( &cmd, "knob -i aZ %f\n",
		       f / (fastf_t)dmp->dm_width * 2.0 );
d696 1
a696 1
    case ALT_CON_XADC:
d705 1
a705 1
    case ALT_CON_YADC:
d713 3
a715 2
	break;
    case ALT_CON_ANG1:
d723 3
a725 2
	break;
    case ALT_CON_ANG2:
d733 3
a735 2
	break;
    case ALT_CON_TICK:
d743 2
a744 1
	break;
d781 1
a781 1
	  f = rate_azimuth;
d794 1
a794 1
	  bu_vls_printf( &cmd, "knob azim %f\n", setting / 512.0 );
d796 1
a796 1
	  f = curr_dm_list->s_info->azimuth;
d806 1
a806 1
	       M->axis_data[0] - knob_values[M->first_axis];
d808 2
a809 2
	  f = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 1024.0;
	  bu_vls_printf( &cmd, "knob aazim %f\n", f * 360.0);
d818 1
a818 1
	  f = rate_zoom;
d836 1
a836 1
	  f = absolute_zoom;
d868 28
a895 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e')
	    f = edit_rate_rotate[Z];
d912 28
a939 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e')
	    f = edit_absolute_rotate[Z];
d973 26
a998 2
	  if(EDIT_TRAN && mged_variables.transform == 'e')
	    f = edit_rate_tran[Z];
d1015 26
a1040 2
	  if(EDIT_TRAN && mged_variables.transform == 'e')
	    f = edit_absolute_tran[Z];
d1055 1
a1055 1
	  bu_vls_printf( &cmd, "knob aZ %f\n", setting / 512.0 );
d1074 28
a1101 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e')
	    f = edit_rate_rotate[Y];
d1118 28
a1145 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e')
	    f = edit_absolute_rotate[Y];
d1166 26
a1191 2
	  if(EDIT_TRAN && mged_variables.transform == 'e')
	    f = edit_rate_tran[Y];
d1208 28
a1235 4
	  if(EDIT_TRAN && mged_variables.transform == 'e')
	    f = edit_absolute_tran[Y];
	  else
	    f = absolute_tran[Y];
d1237 10
a1246 10
	  if(-NOISE <= ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] -
	      knob_values[M->first_axis];
	  else
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];
d1248 2
a1249 2
	  setting = dm_limit(((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob aY %f\n", setting / 512.0 );
d1267 28
a1294 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e')
	    f = edit_rate_rotate[X];
d1311 28
a1338 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e')
	    f = edit_absolute_rotate[X];
d1359 26
a1384 2
	if(EDIT_TRAN && mged_variables.transform == 'e')
	  f = edit_rate_tran[X];
d1401 26
a1426 2
	if(EDIT_TRAN && mged_variables.transform == 'e')
	  f = edit_absolute_tran[X];
d1441 1
a1441 1
	bu_vls_printf( &cmd, "knob aX %f\n", setting / 512.0 );
d1504 10
d1651 1
a1652 11
      if(mged_variables.adcflag && mged_variables.transform == 'a'){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob xadc %d yadc %d\n", x, y);
	status = Tcl_Eval(interp, bu_vls_addr(&vls));
	mged_variables.orig_gui = old_orig_gui;
	bu_vls_free(&vls);

	return status;
      }

      x = ogl_irisX2ged(dmp, atoi(argv[3]), 1);
d1671 1
a1671 1
		       "dm am <a|r|t|z> 1|0 xpos ypos\n", (char *)NULL);
a1680 3
      case 'a':
	am_mode = ALT_ADC;
	break;
d1682 1
a1682 1
	am_mode = ALT_ROT;
d1685 2
a1686 1
	am_mode = ALT_TRAN;
d1688 25
a1712 1
	  vect_t view_pos;
d1715 1
a1715 2
			(fastf_t)dmp->dm_width - 0.5) /
	                dmp->dm_aspect * 2.0;
d1724 1
d1728 11
a1738 2
      case 'z':
	am_mode = ALT_ZOOM;
d1742 79
a1820 1
			 "dm am <a|r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d1827 1
a1827 1
    am_mode = ALT_IDLE;
d1836 1
a1836 1
    if( argc < 6){
d1838 2
a1839 2
		       "dm con r|t x|y|z 1|0 xpos ypos\n",
		       "dm con a x|y|1|2|t\n", (char *)NULL);
d1852 1
a1852 1
	  am_mode = ALT_CON_XADC;
d1855 1
a1855 1
	  am_mode = ALT_CON_YADC;
d1858 1
a1858 1
	  am_mode = ALT_CON_ANG1;
d1861 1
a1861 1
	  am_mode = ALT_CON_ANG2;
d1863 2
a1864 2
	case 't':
	  am_mode = ALT_CON_TICK;
d1868 1
a1868 1
			   "\ndm con a x|y|1|2|t\n", (char *)NULL);
d1874 1
a1874 1
	  am_mode = ALT_CON_ROT_X;
d1877 1
a1877 1
	  am_mode = ALT_CON_ROT_Y;
d1880 1
a1880 1
	  am_mode = ALT_CON_ROT_Z;
d1884 1
a1884 1
			 "\ndm con r|t x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1891 27
a1917 1
	  am_mode = ALT_CON_TRAN_X;
d1920 10
a1929 1
	  am_mode = ALT_CON_TRAN_Y;
d1932 10
a1941 1
	  am_mode = ALT_CON_TRAN_Z;
d1945 1
a1945 1
			 "\ndm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1951 1
a1951 1
			 "\ndm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1958 1
a1958 1
    am_mode = ALT_IDLE;
a2030 18
  ++dmaflag;
}

static void
set_linewidth()
{
  dmp->dm_setLineAttr(dmp,
		      ((struct ogl_vars *)dmp->dm_vars)->mvars.linewidth,
		      dmp->dm_lineStyle);
  ++dmaflag;
}

static void
set_linestyle()
{
  dmp->dm_setLineAttr(dmp,
		      dmp->dm_lineWidth,
		      ((struct ogl_vars *)dmp->dm_vars)->mvars.linestyle);
@


1.56
log
@add azimuth knob
@
text
@d68 1
d259 2
d264 2
d268 1
a268 1
    case ALT_MOUSE_MODE_IDLE:
d281 41
a321 4
    case ALT_MOUSE_MODE_ROTATE:
      bu_vls_printf( &cmd, "knob -i ax %f ay %f\n",
		     (my - ((struct ogl_vars *)dmp->dm_vars)->omy) * 0.25,
		     (mx - ((struct ogl_vars *)dmp->dm_vars)->omx) * 0.25 );
d323 2
a324 2
    case ALT_MOUSE_MODE_TRANSLATE:
      if(EDIT_TRAN && mged_variables.edit){
d326 3
a328 10
#if 0
	view_pos[X] = (mx/(fastf_t)dmp->dm_width
		       - 0.5) * 2.0;
#else
	view_pos[X] = (mx /
		      (fastf_t)dmp->dm_width - 0.5) /
	              dmp->dm_aspect * 2.0; 
#endif
	view_pos[Y] = (0.5 - my/
		       (fastf_t)dmp->dm_height) * 2.0;
d340 7
a346 11
#if 0
	fx = (mx - ((struct ogl_vars *)dmp->dm_vars)->omx)/
	  (fastf_t)dmp->dm_width * 2.0;
#else
	fx = (mx - ((struct ogl_vars *)dmp->dm_vars)->omx) /
	     (fastf_t)dmp->dm_width /
	     dmp->dm_aspect * 2.0;
#endif
	fy = (((struct ogl_vars *)dmp->dm_vars)->omy - my)/
	  (fastf_t)dmp->dm_height * 2.0;
	bu_vls_printf( &cmd, "knob -i aX %f aY %f\n", fx, fy);
d350 95
a444 4
    case ALT_MOUSE_MODE_ZOOM:
      bu_vls_printf( &cmd, "knob -i aS %f\n",
		     (((struct ogl_vars *)dmp->dm_vars)->omy - my)/
		      (fastf_t)dmp->dm_height);
d446 45
d493 2
a494 2
      ((struct ogl_vars *)dmp->dm_vars)->omx = mx;
      ((struct ogl_vars *)dmp->dm_vars)->omy = my;
d561 1
a561 1
	if(EDIT_SCALE && mged_variables.edit)
d579 1
a579 1
	if(EDIT_SCALE && mged_variables.edit)
d614 1
a614 1
	  if(EDIT_ROTATE && mged_variables.edit)
d632 1
a632 1
	  if(EDIT_ROTATE && mged_variables.edit)
d667 1
a667 1
	  if(EDIT_TRAN && mged_variables.edit)
d670 1
a670 1
	    f = rate_slew[Z];
d685 1
a685 1
	  if(EDIT_TRAN && mged_variables.edit)
d688 1
a688 1
	    f = absolute_slew[Z];
d720 1
a720 1
	  if(EDIT_ROTATE && mged_variables.edit)
d738 1
a738 1
	  if(EDIT_ROTATE && mged_variables.edit)
d760 1
a760 1
	  if(EDIT_TRAN && mged_variables.edit)
d763 1
a763 1
	    f = rate_slew[Y];
d778 1
a778 1
	  if(EDIT_TRAN && mged_variables.edit)
d781 1
a781 1
	    f = absolute_slew[Y];
d813 1
a813 1
	  if(EDIT_ROTATE && mged_variables.edit)
d831 1
a831 1
	  if(EDIT_ROTATE && mged_variables.edit)
d853 1
a853 1
	if(EDIT_TRAN && mged_variables.edit)
d856 1
a856 1
	  f = rate_slew[X];
d871 1
a871 1
	if(EDIT_TRAN && mged_variables.edit)
d874 1
a874 1
	  f = absolute_slew[X];
d929 1
a929 1
    /*XXX Hack to prevent Tk from choking on Ctrl-c */
d937 2
a938 1
      if(keysym == XK_c){
d1065 1
a1065 1
      int old_show_menu;
d1067 1
a1067 1
      old_show_menu = mged_variables.show_menu;
d1073 1
a1073 1
	 mged_variables.show_menu &&
d1086 12
a1098 1
      mged_variables.show_menu = 0;
d1101 1
a1101 1
      bu_vls_printf(&vls, "M %s %d %d", argv[2], x, y);
d1103 1
a1103 1
      mged_variables.show_menu = old_show_menu;
d1110 1
a1110 3
  status = TCL_OK;

  if( !strcmp( argv[0], "am" )){
d1117 1
a1117 1
		       "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d1127 3
d1131 1
a1131 1
	am_mode = ALT_MOUSE_MODE_ROTATE;
d1134 2
a1135 2
	am_mode = ALT_MOUSE_MODE_TRANSLATE;
	if(EDIT_TRAN && mged_variables.edit){
a1137 1
#if 0
a1138 4
			 (fastf_t)dmp->dm_width -
			 0.5) * 2.0;
#else
	  view_pos[X] = (((struct ogl_vars *)dmp->dm_vars)->omx /
a1140 1
#endif
d1153 1
a1153 1
	am_mode = ALT_MOUSE_MODE_ZOOM;
d1157 1
a1157 1
			 "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d1160 89
a1248 2
    }else{
      am_mode = ALT_MOUSE_MODE_IDLE;
d1251 2
a1252 1
    return status;
@


1.55
log
@mods to the event handler
@
text
@d358 32
d477 1
a477 1
	      dm_unlimit((int)(2.85 * f)) +
d583 1
a583 1
	      dm_unlimit((int)(2.85 * f)) +
d676 1
a676 1
	      dm_unlimit((int)(2.85 * f)) +
@


1.54
log
@*- mods to Ogl_dm_init
*- add set_linewidth() and set_linestyle()
@
text
@d250 6
@


1.53
log
@*- changed Ogl_ prefix to ogl_
*- call generic dm_open
*- fixed bug in knob event handler
@
text
@d14 3
d81 2
a82 1
static void     do_linewidth();
d109 2
a116 1
	{"%d",  1, "linewidth",		Ogl_MV_O(linewidth),	do_linewidth },
d183 1
a183 1
  curr_dm_list->s_info->opp = &tkName;
a190 1

d1028 10
a1037 1
do_linewidth()
d1039 3
a1041 1
  dmp->dm_setLineAttr(dmp, ((struct ogl_vars *)dmp->dm_vars)->mvars.linewidth, 0);
@


1.52
log
@move default -i option to beginning of argv
@
text
@d149 1
d155 9
a163 2
  for(i = argc-1; i-1; --i)
    argv[i] = argv[i-1];
d165 1
a165 2
  argv[0] = "-i";
  argv[1] = "mged_bind_dm";
d169 2
a170 1
  if((dmp = Ogl_open(DM_EVENT_HANDLER_NULL, argc, argv)) == DM_NULL)
d172 1
d174 1
d180 1
a180 1
  Ogl_configure_window_shape(dmp);
d186 1
d237 1
a237 4
    if (((struct ogl_vars *)dmp->dm_vars)->mvars.zbuf)
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    else
       glClear(GL_COLOR_BUFFER_BIT);
d242 1
a242 1
    Ogl_configure_window_shape(curr_dm_list->_dmp);
d256 1
a256 1
		       Ogl_irisX2ged(dmp, mx, 0), Ogl_irisY2ged(dmp, my));
d261 1
a261 1
		       Ogl_irisX2ged(dmp, mx, 1), Ogl_irisY2ged(dmp, my));
d336 2
a337 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d357 2
a358 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d375 2
a376 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d391 2
a392 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d410 2
a411 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d428 2
a429 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d445 2
a446 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d463 2
a464 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d481 2
a482 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d498 2
a499 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d516 2
a517 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d534 2
a535 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d556 2
a557 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d574 2
a575 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d591 2
a592 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d609 2
a610 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d627 2
a628 2
	  if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d649 2
a650 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d667 2
a668 2
	if(-NOISE < ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d859 2
a860 2
      x = Ogl_irisX2ged(dmp, atoi(argv[3]), 0);
      y = Ogl_irisY2ged(dmp, atoi(argv[4]));
d876 1
a876 1
      x = Ogl_irisX2ged(dmp, atoi(argv[3]), 1);
d998 1
a998 1
  Ogl_establish_zbuffer(dmp);
d1005 1
a1005 1
  Ogl_establish_lighting(dmp);
d1012 1
a1012 1
  Ogl_establish_perspective(dmp);
d1019 1
a1019 1
  Ogl_set_perspective(dmp);
d1033 1
a1033 1
  Ogl_do_fog(dmp);
@


1.51
log
@*** empty log message ***
@
text
@a148 3
#if 0
  char **av;
  struct dm *ogldmp;
d154 2
a155 8
  av = (char **)bu_malloc(sizeof(char *) * (argc + 3), "Ogl_dm_init: av");
  for(i = 0; i < argc; ++i)
    av[i] = argv[i];
  av[i + 1] = "-i";
  av[i + 2] = "mged_bind_dm";
  av[i + 3] = (char *)NULL;
  ogldmp = Ogl_open(Ogl_doevent, argc + 2, av);
  bu_free((genptr_t)av, "Ogl_dm_init: av");
d157 2
a158 11
  return ogldmp;
#else
  /* register application provided routines */
  cmd_hook = Ogl_dm;
  state_hook = Ogl_statechange;

  for(i = 2; i < argc; ++i)
    argv[i-2] = argv[i-1];

  argv[i-2] = "-i";
  argv[i-1] = "mged_bind_dm";
a159 1
#if DO_NEW_LIBDM_OPEN
a172 5
#else
   dmp->dm_eventHandler = Ogl_doevent;
  return Ogl_open(dmp, argc, argv);
#endif
#endif
@


1.50
log
@fixed typo
@
text
@a37 1
#include <X11/keysym.h>
d42 1
d744 1
a744 1
      if(*buffer == 'c'){
@


1.49
log
@added dm size command
@
text
@d744 1
a744 1
      if(*buffer = 'c'){
@


1.48
log
@mods to Ogl_doevent
@
text
@d967 16
@


1.47
log
@*-mods to use latest libdm
*-mods to allow use of non-square windows
@
text
@d184 1
a184 1
  /*XXXX this need to move into Ogl's private structure */
d187 1
a187 1
  curr_dm_list->s_info->opp = &pathName;
d291 1
a291 1
	view_pos[X] = (mx/(fastf_t)((struct ogl_vars *)dmp->dm_vars)->width
d295 2
a296 2
		      (fastf_t)((struct ogl_vars *)dmp->dm_vars)->width - 0.5) /
	              ((struct ogl_vars *)dmp->dm_vars)->aspect * 2.0; 
d299 1
a299 1
		       (fastf_t)((struct ogl_vars *)dmp->dm_vars)->height) * 2.0;
d313 1
a313 1
	  (fastf_t)((struct ogl_vars *)dmp->dm_vars)->width * 2.0;
d316 2
a317 2
	     (fastf_t)((struct ogl_vars *)dmp->dm_vars)->width /
	     ((struct ogl_vars *)dmp->dm_vars)->aspect * 2.0;
d320 1
a320 1
	  (fastf_t)((struct ogl_vars *)dmp->dm_vars)->height * 2.0;
d328 1
a328 1
		      (fastf_t)((struct ogl_vars *)dmp->dm_vars)->height);
d735 17
a751 1
  else
d753 1
d899 1
d934 1
a934 1
			 (fastf_t)((struct ogl_vars *)dmp->dm_vars)->width -
d938 2
a939 2
			(fastf_t)((struct ogl_vars *)dmp->dm_vars)->width - 0.5) /
	                ((struct ogl_vars *)dmp->dm_vars)->aspect * 2.0;
d942 1
a942 1
			 (fastf_t)((struct ogl_vars *)dmp->dm_vars)->height) * 2.0;
@


1.46
log
@experiment with libdm
@
text
@d65 1
d67 1
a67 1
struct dm       *Ogl_dm_init();
d142 3
a144 2
struct dm *
Ogl_dm_init(argc, argv)
d178 14
a191 2
#if 0
  return Ogl_open(Ogl_doevent, argc, argv);
d271 2
a272 1
	bu_vls_printf( &cmd, "M 1 %d %d\n", Ogl_irisX2ged(dmp, mx), Ogl_irisY2ged(dmp, my));
d276 2
a277 1
	bu_vls_printf( &cmd, "M 0 %d %d\n", Ogl_irisX2ged(dmp, mx), Ogl_irisY2ged(dmp, my));
d290 1
a290 1

d293 5
d311 1
d314 5
d851 34
a884 9
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d", argv[2],
		  Ogl_irisX2ged(dmp, atoi(argv[3])),
		  Ogl_irisY2ged(dmp, atoi(argv[4])));
    status = Tcl_Eval(interp, bu_vls_addr(&vls));
#if 0
    mged_print_result(status);
#endif
    return status;
d914 1
d918 5
@


1.45
log
@checkin for weekend
@
text
@a58 1
#include "dm-ogl.h"
d63 1
d66 1
a66 1
int      Ogl_dm_init();
d141 4
a144 2
int
Ogl_dm_init()
d146 20
a166 1
  dmp->dm_eventHandler = Ogl_doevent;
d170 13
a182 1
  return TCL_OK;
@


1.44
log
@mods to use libbn and libbu
@
text
@a208 1
    refresh();
a213 1
    refresh();
@


1.43
log
@mods to event handler
@
text
@d113 6
a118 6
	{"%d",  1, "has_zbuf",		Ogl_MV_O(zbuf),		FUNC_NULL },
	{"%d",  1, "has_rgb",		Ogl_MV_O(rgb),		FUNC_NULL },
	{"%d",  1, "has_doublebuffer",	Ogl_MV_O(doublebuffer), FUNC_NULL },
	{"%d",  1, "depth",		Ogl_MV_O(depth),	FUNC_NULL },
	{"%d",  1, "debug",		Ogl_MV_O(debug),	FUNC_NULL },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
@


1.42
log
@modified dial code to use global edit variables
where appropriate
@
text
@d304 2
a305 1
	bu_vls_printf( &cmd, "knob ang1 %d\n", setting );
d359 2
a360 1
	bu_vls_printf( &cmd, "knob ang2 %d\n", setting );
@


1.41
log
@experimenting
@
text
@d304 1
a304 2
	bu_vls_printf( &cmd, "knob ang1 %d\n",
		      setting );
d309 5
d316 1
a316 1
	   !rate_zoom )
d321 2
a322 2
	    dm_unlimit((int)(512.5 * rate_zoom)) + M->axis_data[0] -
	    knob_values[M->first_axis];
d325 1
a325 2
	bu_vls_printf( &cmd , "knob S %f\n",
		       setting / 512.0 );
d327 5
d334 3
a336 3
	   !absolute_zoom )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d339 2
a340 2
	    dm_unlimit((int)(512.5 * absolute_zoom)) + M->axis_data[0] -
	    knob_values[M->first_axis];
d343 1
a343 2
	bu_vls_printf( &cmd , "knob aS %f\n",
		       setting / 512.0 );
d351 2
a352 2
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d354 2
a355 2
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_2adc) +
	    M->axis_data[0] - knob_values[M->first_axis];
d358 1
a358 2
	bu_vls_printf( &cmd , "knob ang2 %d\n",
		      setting );
d361 5
d368 3
a370 3
	     !rate_rotate[Z] )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d373 1
a373 1
	      dm_unlimit((int)(512.5 * rate_rotate[Z])) +
d377 1
a377 2
	  bu_vls_printf( &cmd , "knob z %f\n",
			 setting / 512.0 );
d379 5
d386 3
a388 3
	     !absolute_rotate[Z] )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d391 1
a391 1
	      dm_unlimit((int)(2.85 * absolute_rotate[Z])) +
d395 1
a395 1
	  bu_vls_printf( &cmd , "knob az %f\n", dm_wrap(f) * 180.0);
d404 2
a405 2
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d407 2
a408 2
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_distadc) +
	    M->axis_data[0] - knob_values[M->first_axis];
d411 1
a411 2
	bu_vls_printf( &cmd , "knob distadc %d\n",
		       setting );
d414 5
d421 1
a421 1
	     !rate_slew[Z] )
d426 1
a426 1
	      dm_unlimit((int)(512.5 * rate_slew[Z])) +
d430 1
a430 2
	  bu_vls_printf( &cmd , "knob Z %f\n",
			 setting / 512.0 );
d432 5
d439 3
a441 2
	     !absolute_slew[Z] )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d444 1
a444 1
	      dm_unlimit((int)(512.5 * absolute_slew[Z])) +
d448 1
a448 2
	  bu_vls_printf( &cmd , "knob aZ %f\n",
			 setting / 512.0 );
d457 2
a458 2
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d460 2
a461 2
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_yadc) +
	    M->axis_data[0] - knob_values[M->first_axis];
d464 1
a464 2
	bu_vls_printf( &cmd , "knob yadc %d\n",
		      setting );
d467 5
d474 1
a474 1
	     !rate_rotate[Y] )
d479 1
a479 1
	      dm_unlimit((int)(512.5 * rate_rotate[Y])) +
d483 1
a483 2
	  bu_vls_printf( &cmd , "knob y %f\n",
			 setting / 512.0 );
d485 5
d492 3
a494 3
	     !absolute_rotate[Y] )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d497 1
a497 1
	      dm_unlimit((int)(2.85 * absolute_rotate[Y])) +
d501 1
a501 1
	  bu_vls_printf( &cmd , "knob ay %f\n", dm_wrap(f) * 180.0);
d507 5
d514 3
a516 3
	     !rate_slew[Y] )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d519 1
a519 1
	      dm_unlimit((int)(512.5 * rate_slew[Y])) +
d521 1
a521 1
	  
d523 1
a523 2
	  bu_vls_printf( &cmd , "knob Y %f\n",
			 setting / 512.0 );
d525 5
d532 3
a534 2
	     !absolute_slew[Y] )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d538 1
a538 1
	      dm_unlimit((int)(512.5 * absolute_slew[Y])) +
d542 1
a542 2
	  bu_vls_printf( &cmd , "knob aY %f\n",
			 setting / 512.0 );
d550 2
a551 2
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d553 2
a554 2
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_xadc) +
	    M->axis_data[0] - knob_values[M->first_axis];
d557 1
a557 2
	bu_vls_printf( &cmd , "knob xadc %d\n",
		       setting );
d560 5
d567 3
a569 3
	     !rate_rotate[X] )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d572 1
a572 1
	      dm_unlimit((int)(512.5 * rate_rotate[X])) +
d576 1
a576 2
	  bu_vls_printf( &cmd , "knob x %f\n",
			 setting / 512.0 );
d578 5
d585 3
a587 3
	     !absolute_rotate[X] )
	    ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d590 2
a591 2
	      dm_unlimit((int)(2.85 * absolute_rotate[X])) + M->axis_data[0] -
	      knob_values[M->first_axis];
d594 1
a594 1
	  bu_vls_printf( &cmd , "knob ax %f\n", dm_wrap(f) * 180.0);
d600 5
d607 3
a609 3
	   !rate_slew[X] )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d612 1
a612 1
	    dm_unlimit((int)(512.5 * rate_slew[X])) +
d616 1
a616 2
	bu_vls_printf( &cmd , "knob X %f\n",
		       setting / 512.0 );
d618 5
d625 3
a627 3
	   !absolute_slew[X] )
	  ((struct ogl_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d630 1
a630 1
	    dm_unlimit((int)(512.5 * absolute_slew[X])) +
d634 1
a634 2
	bu_vls_printf( &cmd , "knob aX %f\n",
		       setting / 512.0 );
@


1.40
log
@experimentation
@
text
@d241 16
a256 1
      {
d259 7
a265 12
	if(EDIT_TRAN && mged_variables.edit){
	  fx = (mx/(fastf_t)((struct ogl_vars *)dmp->dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)((struct ogl_vars *)dmp->dm_vars)->height) * 2;
	  bu_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy);
	}else{
	  fx = (mx - ((struct ogl_vars *)dmp->dm_vars)->omx)/
		(fastf_t)((struct ogl_vars *)dmp->dm_vars)->width * 2.0;
	  fy = (((struct ogl_vars *)dmp->dm_vars)->omy - my)/
		(fastf_t)((struct ogl_vars *)dmp->dm_vars)->height * 2.0;
	  bu_vls_printf( &cmd, "knob -i aX %f aY %f\n", fx, fy);
	}
      }	     
d771 13
a783 8
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "knob aX %f aY %f\n",
			(((struct ogl_vars *)dmp->dm_vars)->omx /
			 (fastf_t)((struct ogl_vars *)dmp->dm_vars)->width - 0.5) * 2,
			(0.5 - ((struct ogl_vars *)dmp->dm_vars)->omy /
			 (fastf_t)((struct ogl_vars *)dmp->dm_vars)->height) * 2);
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
@


1.39
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d244 1
a244 1
	if(EDIT_TRAN){
d760 1
a760 1
	if(EDIT_TRAN){
@


1.38
log
@not done yet --- working on allowing full view manipulation while editing
@
text
@a235 1
#if 0
a236 4
		     (my - ((struct ogl_vars *)dmp->dm_vars)->omy)/4.0,
		     (mx - ((struct ogl_vars *)dmp->dm_vars)->omx)/4.0 );
#else
      bu_vls_printf( &cmd, "vrot %f %f 0.0",
d238 1
a238 2
		     (mx - ((struct ogl_vars *)dmp->dm_vars)->omx) * 0.25);
#endif
d243 2
a244 9
#if 1
	fx = (mx - ((struct ogl_vars *)dmp->dm_vars)->omx)/
	  (fastf_t)((struct ogl_vars *)dmp->dm_vars)->width * 4095.0;
	fy = (((struct ogl_vars *)dmp->dm_vars)->omy - my)/
	  (fastf_t)((struct ogl_vars *)dmp->dm_vars)->height * 4095.0;
	bu_vls_printf( &cmd, "tran -i %f %f", fx, fy);
#else
	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
a254 1
#endif
d760 1
a760 3
#if 0
	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
d770 1
a770 1
#endif
@


1.37
log
@*** empty log message ***
@
text
@d236 1
d240 5
d249 7
a255 1

d268 1
d739 6
a744 9
    av[0] = "M";
    av[1] = argv[2];
    av[2] = xstr;
    av[3] = ystr;
    av[4] = NULL;

    sprintf(xstr, "%d", Ogl_irisX2ged(dmp, atoi(argv[3])));
    sprintf(ystr, "%d", Ogl_irisY2ged(dmp, atoi(argv[4])));
    status = f_mouse((ClientData)NULL, interp, 4, av);
d746 1
a746 1

d774 1
a774 1

a776 1
#if 1
d785 1
a785 13
#else
	  av[0] = "knob";
	  av[1] = "aX";
	  av[2] = xstr;
	  av[3] = "aY";
	  av[4] = ystr;
	  av[5] = NULL;

	  sprintf(xstr, "%f", (((struct ogl_vars *)dmp->dm_vars)->omx/
			       (fastf_t)((struct ogl_vars *)dmp->dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - ((struct ogl_vars *)dmp->dm_vars)->omy/
			       (fastf_t)((struct ogl_vars *)dmp->dm_vars)->height) * 2);
	  status = f_knob((ClientData)NULL, interp, 5, av);
a786 2
	}

@


1.36
log
@change iknob to knob -1
@
text
@a39 1
#include "tcl.h"
d80 4
d142 1
a142 3
Ogl_dm_init(argc, argv)
int argc;
char *argv[];
d149 1
a149 4
  if(dmp->dm_init(dmp, argc, argv) == TCL_ERROR)
    return TCL_ERROR;

  return dmp->dm_open(dmp);
d162 1
a162 1
  int status = CMD_OK;
d237 2
a238 2
		     (my - ((struct ogl_vars *)dmp->dm_vars)->omy)/512.0,
		     (mx - ((struct ogl_vars *)dmp->dm_vars)->omx)/512.0 );
d367 1
a367 1
	      dm_unlimit((int)(512.5 * absolute_rotate[Z])) +
d371 1
a371 1
	  bu_vls_printf( &cmd , "knob az %f\n", dm_wrap(f));
d457 1
a457 1
	      dm_unlimit((int)(512.5 * absolute_rotate[Y])) +
d461 1
a461 1
	  bu_vls_printf( &cmd , "knob ay %f\n", dm_wrap(f));
d533 1
a533 1
	      dm_unlimit((int)(512.5 * absolute_rotate[X])) + M->axis_data[0] -
d537 1
a537 1
	  bu_vls_printf( &cmd , "knob ax %f\n", dm_wrap(f));
d613 1
a613 1
  status = cmdline(&cmd, FALSE);
d618 1
a618 4
  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
d767 10
a776 1

d789 1
d813 1
@


1.35
log
@hacks to use latest libdm
@
text
@d238 1
a238 1
      bu_vls_printf( &cmd, "iknob ax %f ay %f\n",
d256 1
a256 1
	  bu_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy);
d261 1
a261 1
      bu_vls_printf( &cmd, "iknob aS %f\n",
@


1.34
log
@call mged_print_result after calling f_mouse in case it had something to say
@
text
@d144 3
a146 3
  dmp->dmr_eventhandler = Ogl_doevent;
  dmp->dmr_cmd = Ogl_dm;
  dmp->dmr_statechange = Ogl_statechange;
d148 1
a148 1
  if(dmp->dmr_init(dmp, argc, argv) == TCL_ERROR)
d151 1
a151 1
  return dmp->dmr_open(dmp);
d178 3
a180 3
  if(!glXMakeCurrent(((struct ogl_vars *)dm_vars)->dpy,
     ((struct ogl_vars *)dm_vars)->win,
     ((struct ogl_vars *)dm_vars)->glxc))
d205 1
a205 1
    if (((struct ogl_vars *)dm_vars)->mvars.zbuf)
d227 1
a227 1
      if(scroll_active && eventPtr->xmotion.state & ((struct ogl_vars *)dm_vars)->mb_mask)
d239 2
a240 2
		     (my - ((struct ogl_vars *)dm_vars)->omy)/512.0,
		     (mx - ((struct ogl_vars *)dm_vars)->omx)/512.0 );
d248 2
a249 2
	  fx = (mx/(fastf_t)((struct ogl_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)((struct ogl_vars *)dm_vars)->height) * 2;
d252 4
a255 4
	  fx = (mx - ((struct ogl_vars *)dm_vars)->omx)/
		(fastf_t)((struct ogl_vars *)dm_vars)->width * 2.0;
	  fy = (((struct ogl_vars *)dm_vars)->omy - my)/
		(fastf_t)((struct ogl_vars *)dm_vars)->height * 2.0;
d262 2
a263 2
		     (((struct ogl_vars *)dm_vars)->omy - my)/
		      (fastf_t)((struct ogl_vars *)dm_vars)->height);
d267 2
a268 2
      ((struct ogl_vars *)dm_vars)->omx = mx;
      ((struct ogl_vars *)dm_vars)->omy = my;
d271 1
a271 1
  else if( eventPtr->type == ((struct ogl_vars *)dm_vars)->devmotionnotify ){
d287 2
a288 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d290 1
a290 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] +=
d293 1
a293 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d296 1
a296 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d303 2
a304 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d306 1
a306 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] +=
d309 1
a309 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d313 1
a313 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d317 2
a318 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d320 1
a320 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d323 1
a323 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d327 1
a327 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d334 2
a335 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d337 1
a337 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d340 1
a340 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_2adc) +
d343 1
a343 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d348 2
a349 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d351 1
a351 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d354 1
a354 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d358 1
a358 1
	  setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d362 2
a363 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d365 1
a365 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d368 1
a368 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d372 1
a372 1
	  f = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]) / 512.0;
d379 2
a380 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d382 1
a382 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d385 1
a385 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_distadc) +
d388 1
a388 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d393 2
a394 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d396 1
a396 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] +=
d399 1
a399 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d403 1
a403 1
	  setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d407 2
a408 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d410 1
a410 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d412 1
a412 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d416 1
a416 1
	  setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d424 2
a425 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d427 1
a427 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d430 1
a430 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_yadc) +
d433 1
a433 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d438 2
a439 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d441 1
a441 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] +=
d444 1
a444 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d448 1
a448 1
	  setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d452 2
a453 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d455 1
a455 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d458 1
a458 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d462 1
a462 1
	  f = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]) / 512.0;
d469 2
a470 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d472 1
a472 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d475 1
a475 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d479 1
a479 1
	  setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d483 2
a484 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d486 1
a486 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d489 1
a489 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d493 1
a493 1
	  setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d500 2
a501 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d503 1
a503 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d506 1
a506 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_xadc) +
d509 1
a509 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d514 2
a515 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d517 1
a517 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d520 1
a520 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d524 1
a524 1
	  setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d528 2
a529 2
	  if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d531 1
a531 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d534 1
a534 1
	    ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d538 1
a538 1
	  f = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]) / 512.0;
d545 2
a546 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d548 1
a548 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d551 1
a551 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d555 1
a555 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d559 2
a560 2
	if(-NOISE < ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
d562 1
a562 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d565 1
a565 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] =
d569 1
a569 1
	setting = dm_limit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d583 1
a583 1
  else if( eventPtr->type == ((struct ogl_vars *)dm_vars)->devbuttonpress ){
d601 1
a601 1
  }else if( eventPtr->type == ((struct ogl_vars *)dm_vars)->devbuttonrelease ){
d687 1
a687 1
      bu_struct_print("dm_ogl internal variables", Ogl_vparse, (CONST char *)&((struct ogl_vars *)dm_vars)->mvars );
d689 1
a689 1
      bu_vls_struct_item_named( &vls, Ogl_vparse, argv[1], (CONST char *)&((struct ogl_vars *)dm_vars)->mvars, ',');
d695 1
a695 1
      bu_struct_parse( &vls, Ogl_vparse, (char *)&((struct ogl_vars *)dm_vars)->mvars );
d718 1
a718 1
      ((struct ogl_vars *)dm_vars)->mb_mask = Button1Mask;
d721 1
a721 1
      ((struct ogl_vars *)dm_vars)->mb_mask = Button2Mask;
d724 1
a724 1
      ((struct ogl_vars *)dm_vars)->mb_mask = Button3Mask;
d759 2
a760 2
    ((struct ogl_vars *)dm_vars)->omx = atoi(argv[3]);
    ((struct ogl_vars *)dm_vars)->omy = atoi(argv[4]);
d780 4
a783 4
	  sprintf(xstr, "%f", (((struct ogl_vars *)dm_vars)->omx/
			       (fastf_t)((struct ogl_vars *)dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - ((struct ogl_vars *)dm_vars)->omy/
			       (fastf_t)((struct ogl_vars *)dm_vars)->height) * 2);
d807 8
d819 8
a826 1
  dmp->dmr_colorchange(dmp);
d861 1
a861 1
  Ogl_do_linewidth(dmp);
d884 1
a884 1
    ((struct ogl_vars *)dm_vars)->knobs[i] = 0;
@


1.33
log
@- use dm_unlimit and dm_limit instead of Ogl_add_tol and Ogl_irlimit.
- use dm_wrap during absolute rotate
@
text
@d45 4
d52 1
d66 1
d626 1
a626 1
void
d667 1
a667 1
int
d740 1
d810 1
@


1.32
log
@get rid of extra cmdline() uses
@
text
@d268 1
d288 1
a288 1
	    Ogl_add_tol(dv_1adc) + M->axis_data[0] - knob_values[M->first_axis];
d290 1
a290 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d304 1
a304 1
	    Ogl_add_tol((int)(512.5 * rate_zoom)) + M->axis_data[0] -
d307 1
a307 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d318 1
a318 1
	    Ogl_add_tol((int)(512.5 * absolute_zoom)) + M->axis_data[0] -
d321 1
a321 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d334 1
a334 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] = Ogl_add_tol(dv_2adc) +
d337 1
a337 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d349 1
a349 1
	      Ogl_add_tol((int)(512.5 * rate_rotate[Z])) +
d352 1
a352 1
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d363 1
a363 1
	      Ogl_add_tol((int)(512.5 * absolute_rotate[Z])) +
d366 2
a367 3
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob az %f\n",
			 setting / 512.0 );
d379 1
a379 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] = Ogl_add_tol(dv_distadc) +
d382 1
a382 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d394 1
a394 1
	      Ogl_add_tol((int)(512.5 * rate_slew[Z])) +
d397 1
a397 1
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d407 1
a407 1
	      Ogl_add_tol((int)(512.5 * absolute_slew[Z])) +
d410 1
a410 1
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d424 1
a424 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] = Ogl_add_tol(dv_yadc) +
d427 1
a427 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d439 1
a439 1
	      Ogl_add_tol((int)(512.5 * rate_rotate[Y])) +
d442 1
a442 1
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d453 1
a453 1
	      Ogl_add_tol((int)(512.5 * absolute_rotate[Y])) +
d456 2
a457 3
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob ay %f\n",
			 setting / 512.0 );
d470 1
a470 1
	      Ogl_add_tol((int)(512.5 * rate_slew[Y])) +
d473 1
a473 1
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d484 1
a484 1
	      Ogl_add_tol((int)(512.5 * absolute_slew[Y])) +
d487 1
a487 1
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d500 1
a500 1
	  ((struct ogl_vars *)dm_vars)->knobs[M->first_axis] = Ogl_add_tol(dv_xadc) +
d503 1
a503 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d515 1
a515 1
	      Ogl_add_tol((int)(512.5 * rate_rotate[X])) +
d518 1
a518 1
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d529 1
a529 1
	      Ogl_add_tol((int)(512.5 * absolute_rotate[X])) + M->axis_data[0] -
d532 2
a533 3
	  setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob ax %f\n",
			 setting / 512.0 );
d546 1
a546 1
	    Ogl_add_tol((int)(512.5 * rate_slew[X])) +
d549 1
a549 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
d560 1
a560 1
	    Ogl_add_tol((int)(512.5 * absolute_slew[X])) +
d563 1
a563 1
	setting = Ogl_irlimit(((struct ogl_vars *)dm_vars)->knobs[M->first_axis]);
@


1.31
log
@more pruning
@
text
@d670 1
a670 1
  char *av[4];
a672 1
  char zstr[32];
d727 9
a735 8
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d\n", argv[2],
		  Ogl_irisX2ged(dmp, atoi(argv[3])), Ogl_irisY2ged(dmp, atoi(argv[4])));
    status = cmdline(&vls, FALSE);
    bu_vls_free(&vls);

    if(status == CMD_OK)
      return TCL_OK;
d737 1
a737 1
    return TCL_ERROR;
a766 1
	  fastf_t fx, fy;
d768 12
a779 8
	  bu_vls_init(&vls);
	  fx = (((struct ogl_vars *)dm_vars)->omx/
		(fastf_t)((struct ogl_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - ((struct ogl_vars *)dm_vars)->omy/
		(fastf_t)((struct ogl_vars *)dm_vars)->height) * 2;
	  bu_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	  (void)cmdline(&vls, FALSE);
	  bu_vls_free(&vls);
@


1.30
log
@changed parameters to dmr_object
@
text
@a100 5
	{"%d",  1, "has_zbuf",		Ogl_MV_O(zbuf),	refresh_hook },
	{"%d",  1, "has_rgb",		Ogl_MV_O(rgb),	Ogl_colorchange },
	{"%d",  1, "has_doublebuffer",	Ogl_MV_O(doublebuffer), refresh_hook },
	{"%d",  1, "depth",		Ogl_MV_O(depth),	FUNC_NULL },
	{"%d",  1, "debug",		Ogl_MV_O(debug),	FUNC_NULL },
d104 5
d155 2
a157 2
  register struct dm_list *p;
  struct bu_vls cmd;
d160 2
a161 1
  if(eventPtr->type == DestroyNotify)
a166 3
#if 0
  curr_dm_list = get_dm_list(eventPtr->xany.window);
#else
a167 1
#endif
d655 1
d803 1
d810 1
d817 1
d824 1
d831 1
d838 1
d845 1
a861 20

#if 0
static struct dm_list *
get_dm_list(window)
Window window;
{
  register struct ogl_vars *p;

  for( BU_LIST_FOR(p, ogl_vars, &head_ogl_vars.l) ){
    if(window == p->win){
      if (!glXMakeCurrent(p->dpy, p->win, p->glxc))
	return DM_LIST_NULL;

      return ((struct mged_ogl_vars *)p->app_vars)->dm_list;
    }
  }

  return DM_LIST_NULL;
}
#endif
@


1.29
log
@calling GET_DM_LIST macro instead of get_dm_list
@
text
@a65 1
static int      Ogl_close();  /* do application specific cleanup */
a73 3
#if 0
static struct dm_list *get_dm_list();
#endif
a136 3
  if(dmp->dmr_init(dmp, argc, argv) == TCL_ERROR)
    return TCL_ERROR;

d141 3
a143 3
#if 0
  dmp->dmr_app_close = Ogl_close;
#endif
a146 10

#if 0
int
Ogl_close(p)
genptr_t *p;
{
  bu_free(p, "mged_ogl_vars");
  return TCL_OK;
}
#endif
@


1.28
log
@use LIBDM permanently
@
text
@d58 1
a58 1
#include "./solid.h"
a60 2
extern void color_soltab();

d75 1
d77 1
a77 3

#define OGL_APP_VARS ((struct mged_ogl_vars *)((struct ogl_vars *)dm_vars)->app_vars)
#define MVARS (OGL_APP_VARS->mvars)
a97 4
struct mged_ogl_vars {
  struct dm_list *dm_list;
};

d141 1
a141 1
  if(dmp->dmr_init(dmp, color_soltab) == TCL_ERROR)
a151 11
  /*XXX This gets screwed up when tieing ---- needs fixing --- see also f_tie() */
  ((struct ogl_vars *)dmp->dmr_vars)->viewscale = &Viewscale;

  /* Allocate space for application specific Ogl variables */
  ((struct ogl_vars *)dm_vars)->app_vars =
    bu_malloc(sizeof(struct mged_ogl_vars), "mged_ogl_vars");
  bzero((void *)((struct ogl_vars *)dm_vars)->app_vars,
	sizeof(struct mged_ogl_vars));

  OGL_APP_VARS->dm_list = curr_dm_list;

d183 1
d185 3
d192 5
d875 1
d893 1
@


1.27
log
@prepare to use libdm
@
text
@d55 1
d57 1
a57 1
#include "./dm.h"
a60 3
#ifdef USE_LIBDM
#include "dm-ogl.h"

d144 3
a146 1
Ogl_dm_init()
a900 2393
#else
/* these are from /usr/include/gl.h could be device dependent */
#define XMAXSCREEN	1279
#define YMAXSCREEN	1023
#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

extern void color_soltab();
extern void sl_toggle_scroll();		/* from scroll.c */
extern Tk_Window tkwin;
extern struct device_values dm_values;	/* values read from devices */

static void     establish_perspective();
static void     set_perspective();
static void	establish_lighting();
static void	establish_zbuffer();
static int	Ogl_setup();
static void     set_knob_offset();
static void	Ogl_configure_window_shape();
static int	Ogl_doevent();
static void	Ogl_gen_color();
static void     Ogl_colorit();
static void     Ogl_load_startup();
static void     ogl_var_init();
static XVisualInfo *Ogl_set_visual();
static void     print_cmap();
static struct dm_list *get_dm_list();
static int irisX2ged();
static int irisY2ged();

/* Flags indicating whether the ogl and sgi display managers have been
 * attached.
 * These are necessary to decide whether or not to use direct rendering
 * with gl.
 */
char  ogl_ogl_used = 0;
char  ogl_sgi_used = 0;
char  ogl_is_direct = 0;

/* Display Manager package interface */
#define IRBOUND	4095.9	/* Max magnification in Rot matrix */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
int	Ogl_open();
int	Ogl_dm();
void	Ogl_close();
MGED_EXTERN(void	Ogl_input, (fd_set *input, int noblock) );
void	Ogl_prolog(), Ogl_epilog();
void	Ogl_normal(), Ogl_newrot();
void	Ogl_update();
void	Ogl_puts(), Ogl_2d_line(), Ogl_light();
int	Ogl_object();
unsigned Ogl_cvtvecs(), Ogl_load();
void	Ogl_statechange(), Ogl_viewchange(), Ogl_colorchange();
void	Ogl_window(), Ogl_debug(), Ogl_selectargs();

struct dm dm_ogl = {
	Ogl_open, Ogl_close,
	Ogl_input,
	Ogl_prolog, Ogl_epilog,
	Ogl_normal, Ogl_newrot,
	Ogl_update,
	Ogl_puts, Ogl_2d_line,
	Ogl_light,
	Ogl_object,	Ogl_cvtvecs, Ogl_load,
	Ogl_statechange,
	Ogl_viewchange,
	Ogl_colorchange,
	Ogl_window, Ogl_debug, Ogl_dm, Ogl_doevent,
	0,				/* no displaylist */
	0,				/* multi-window */
	IRBOUND,
	"ogl", "X Windows with OpenGL graphics",
	0,				/* mem map */
	0,
	0,
	0
};


/* ogl stuff */
#define NSLOTS		4080	/* The mostest possible - may be fewer */
#define dpy (((struct ogl_vars *)dm_vars)->_dpy)
#define win (((struct ogl_vars *)dm_vars)->_win)
#define xtkwin (((struct ogl_vars *)dm_vars)->_xtkwin)
#define mb_mask (((struct ogl_vars *)dm_vars)->_mb_mask)
#define omx (((struct ogl_vars *)dm_vars)->_omx)
#define omy (((struct ogl_vars *)dm_vars)->_omy)
#define perspective_angle (((struct ogl_vars *)dm_vars)->_perspective_angle)
#define devmotionnotify (((struct ogl_vars *)dm_vars)->_devmotionnotify)
#define devbuttonpress (((struct ogl_vars *)dm_vars)->_devbuttonpress)
#define devbuttonrelease (((struct ogl_vars *)dm_vars)->_devbuttonrelease)
#define knobs (((struct ogl_vars *)dm_vars)->_knobs)
#define stereo_is_on (((struct ogl_vars *)dm_vars)->_stereo_is_on)
#define aspect (((struct ogl_vars *)dm_vars)->_aspect)
#define glxc (((struct ogl_vars *)dm_vars)->_glxc)
#define fontstruct (((struct ogl_vars *)dm_vars)->_fontstruct)
#define fontOffset (((struct ogl_vars *)dm_vars)->_fontOffset)
#define ovec (((struct ogl_vars *)dm_vars)->_ovec)
#define ogl_is_direct (((struct ogl_vars *)dm_vars)->_ogl_is_direct)
#define ogl_index_size (((struct ogl_vars *)dm_vars)->_ogl_index_size)
#define ogl_nslots (((struct ogl_vars *)dm_vars)->_ogl_nslots)
#define slotsused (((struct ogl_vars *)dm_vars)->_slotsused)
#define ogl_rgbtab (((struct ogl_vars *)dm_vars)->_ogl_rgbtab)

struct modifiable_ogl_vars {
  int cueing_on;
  int zclipping_on;
  int zbuffer_on;
  int lighting_on;
  int perspective_mode;
  int dummy_perspective;
  int zbuf;
  int rgb;
  int doublebuffer;
  int depth;
  int debug;
  int linewidth;
  int fastfog;
  double fogdensity;
};

struct ogl_vars {
  struct bu_list l;
  struct dm_list *dm_list;
  Display *_dpy;
  Window _win;
  Tk_Window _xtkwin;
  Colormap cmap;
  GLdouble faceplate_mat[16];
  unsigned int _mb_mask;
  int face_flag;
  int width;
  int height;
  int _omx, _omy;
  int _perspective_angle;
  int _devmotionnotify;
  int _devbuttonpress;
  int _devbuttonrelease;
  int _knobs[8];
  int _stereo_is_on;
  fastf_t _aspect;
  GLXContext _glxc;
  XFontStruct *_fontstruct;
  int _fontOffset;
  int _ovec;		/* Old color map entry number */
  char    _ogl_is_direct;
  int _ogl_index_size;
/*
 * SGI Color Map table
 */
  int _ogl_nslots;		/* how many we have, <= NSLOTS */
  int _slotsused;		/* how many actually used */
  struct rgbtab {
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
  }_ogl_rgbtab[NSLOTS];
  struct modifiable_ogl_vars mvars;
};

#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
#endif

#ifdef IR_KNOBS
static int irlimit();			/* provides knob dead spot */
static int      Ogl_add_tol();
#define NOISE 32		/* Size of dead spot on knob */
/*
 *  Labels for knobs in help mode.
 */
static char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
static char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

static struct ogl_vars head_ogl_vars;
static int perspective_table[] = {
	30, 45, 60, 90 };
static double	xlim_view = 1.0;	/* args for glOrtho*/
static double	ylim_view = 1.0;

/* lighting parameters */
static float amb_three[] = {0.3, 0.3, 0.3, 1.0};

static float light0_position[] = {100.0, 200.0, 100.0, 0.0};
static float light1_position[] = {100.0, 30.0, 100.0, 0.0};
static float light2_position[] = {-100.0, 20.0, 20.0, 0.0};
static float light3_position[] = {0.0, -100.0, -100.0, 0.0};

static float light0_diffuse[] = {0.70, 0.70, 0.70, 1.0}; /* white */
static float light1_diffuse[] = {0.60, 0.10, 0.10, 1.0}; /* red */
static float light2_diffuse[] = {0.10, 0.30, 0.10, 1.0}; /* green */
static float light3_diffuse[] = {0.10, 0.10, 0.30, 1.0}; /* blue */

/* functions */
static void
refresh_hook()
{
	dmaflag = 1;
}

static void
do_linewidth()
{
	glLineWidth((GLfloat) ((struct ogl_vars *)dm_vars)->mvars.linewidth);
	dmaflag = 1;
}


static void
do_fog()
{
	glHint(GL_FOG_HINT, ((struct ogl_vars *)dm_vars)->mvars.fastfog ? GL_FASTEST : GL_NICEST);
	dmaflag = 1;
}

#define Ogl_MV_O(_m) offsetof(struct modifiable_ogl_vars, _m)
struct bu_structparse Ogl_vparse[] = {
	{"%d",	1, "depthcue",		Ogl_MV_O(cueing_on),	Ogl_colorchange },
	{"%d",  1, "zclip",		Ogl_MV_O(zclipping_on),	refresh_hook },
	{"%d",  1, "zbuffer",		Ogl_MV_O(zbuffer_on),	establish_zbuffer },
	{"%d",  1, "lighting",		Ogl_MV_O(lighting_on),	establish_lighting },
	{"%d",  1, "perspective",       Ogl_MV_O(perspective_mode), establish_perspective },
	{"%d",  1, "set_perspective",   Ogl_MV_O(dummy_perspective),  set_perspective },
	{"%d",  1, "has_zbuf",		Ogl_MV_O(zbuf),	refresh_hook },
	{"%d",  1, "has_rgb",		Ogl_MV_O(rgb),	Ogl_colorchange },
	{"%d",  1, "has_doublebuffer",	Ogl_MV_O(doublebuffer), refresh_hook },
	{"%d",  1, "depth",		Ogl_MV_O(depth),	FUNC_NULL },
	{"%d",  1, "debug",		Ogl_MV_O(debug),	FUNC_NULL },
	{"%d",  1, "linewidth",		Ogl_MV_O(linewidth),	do_linewidth },
	{"%d",  1, "fastfog",		Ogl_MV_O(fastfog),	do_fog },
	{"%f",  1, "density",		Ogl_MV_O(fogdensity),	refresh_hook },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
};

/* Map +/-2048 GED space into -1.0..+1.0 :: x/2048*/
#define GED2IRIS(x)	(((float)(x))*0.00048828125)

static int OgldoMotion = 0;

/*
 * Display coordinate conversion:
 *  GED is using -2048..+2048,
 *  X is 0..width,0..height
 */
#define	GED_TO_Xx(x)	(((x)/4096.0+0.5)*((struct ogl_vars *)dm_vars)->width)
#define	GED_TO_Xy(x)	((0.5-(x)/4096.0)*((struct ogl_vars *)dm_vars)->height)

/* get rid of when no longer needed */
#define USE_RAMP	(((struct ogl_vars *)dm_vars)->mvars.cueing_on || ((struct ogl_vars *)dm_vars)->mvars.lighting_on)
#define CMAP_BASE	32
#define CMAP_RAMP_WIDTH	16
#define MAP_ENTRY(x)	( USE_RAMP ? \
			((x) * CMAP_RAMP_WIDTH + CMAP_BASE) : \
			((x) + CMAP_BASE) )

/********************************************************************/

/*
 *  Mouse coordinates are in absolute screen space, not relative to
 *  the window they came from.  Convert to window-relative,
 *  then to MGED-style +/-2048 range.
 */
static int
irisX2ged(x)
register int x;
{
  return ((x/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 4095);
}

static int
irisY2ged(y)
register int y;
{
  return ((0.5 - y/(double)((struct ogl_vars *)dm_vars)->height) * 4095);
}


/*
 *			O G L _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
Ogl_open()
{
  ogl_var_init();

  return Ogl_setup(dname);
}

/*XXX Just experimenting */
static void
Ogl_load_startup()
{
  char *filename;

  bzero((void *)&head_ogl_vars, sizeof(struct ogl_vars));
  BU_LIST_INIT( &head_ogl_vars.l );

  if((filename = getenv("DM_OGL_RCFILE")) != (char *)NULL )
    Tcl_EvalFile(interp, filename);
}

/*
 *  			O G L _ C L O S E
 *  
 *  Gracefully release the display.
 */
void
Ogl_close()
{
  if(glxc != NULL){
#if 0
    glDrawBuffer(GL_FRONT);
    glClearColor(0.0, 0.0, 0.0, 0.0);
    /*	glClearDepth(0.0);*/
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glDrawBuffer(GL_BACK);
#endif
    glXDestroyContext(dpy, glxc);
  }

  if(xtkwin != NULL)
    Tk_DestroyWindow(xtkwin);

  if(((struct ogl_vars *)dm_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct ogl_vars *)dm_vars)->l);

  bu_free(dm_vars, "Ogl_close: dm_vars");

  if(BU_LIST_IS_EMPTY(&head_ogl_vars.l))
    Tk_DeleteGenericHandler(Ogl_doevent, (ClientData)NULL);
}

/*
 *			O G L _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
void
Ogl_prolog()
{
  GLint mm; 
  char i;
  char *str = "a";
  GLfloat fogdepth;

  if (((struct ogl_vars *)dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl_prolog\n", (char *)NULL);

  if (!glXMakeCurrent(dpy, win, glxc)){
    Tcl_AppendResult(interp, "Ogl_prolog: Couldn't make context current\n", (char *)NULL);
    return;
  }

  if (!((struct ogl_vars *)dm_vars)->mvars.doublebuffer){
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /*			return;*/
  }

  if (((struct ogl_vars *)dm_vars)->face_flag){
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
    ((struct ogl_vars *)dm_vars)->face_flag = 0;
    if (((struct ogl_vars *)dm_vars)->mvars.cueing_on){
      glEnable(GL_FOG);
      fogdepth = 2.2 * Viewscale; /* 2.2 is heuristic */
      glFogf(GL_FOG_END, fogdepth);
      fogdepth = (GLfloat) (0.5*((struct ogl_vars *)dm_vars)->mvars.fogdensity/Viewscale);
      glFogf(GL_FOG_DENSITY, fogdepth);
      glFogi(GL_FOG_MODE, ((struct ogl_vars *)dm_vars)->mvars.perspective_mode ? GL_EXP : GL_LINEAR);
    }
    if (((struct ogl_vars *)dm_vars)->mvars.lighting_on){
      glEnable(GL_LIGHTING);
    }
  }
	
  glLineWidth((GLfloat) ((struct ogl_vars *)dm_vars)->mvars.linewidth);
}

/*
 *			O G L _ E P I L O G
 */
void
Ogl_epilog()
{
  if (((struct ogl_vars *)dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl_epilog\n", (char *)NULL);

  /*
   * A Point, in the Center of the Screen.
   * This is drawn last, to always come out on top.
   */

  glColor3ub( (short)ogl_rgbtab[4].r, (short)ogl_rgbtab[4].g, (short)ogl_rgbtab[4].b );
  glBegin(GL_POINTS);
  glVertex2i(0,0);
  glEnd();
  /* end of faceplate */

  if(((struct ogl_vars *)dm_vars)->mvars.doublebuffer ){
    glXSwapBuffers(dpy, win);
    /* give Graphics pipe time to work */
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  }

  /* Prevent lag between events and updates */
  XSync(dpy, 0);

  if(((struct ogl_vars *)dm_vars)->mvars.debug){
    int error;
    struct bu_vls tmp_vls;

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "ANY ERRORS?\n");

    while((error = glGetError())!=0){
      bu_vls_printf(&tmp_vls, "Error: %x\n", error);
    }

    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }

  return;
}

/*
 *  			O G L _ N E W R O T
 *  load new rotation matrix onto top of stack
 */
void
Ogl_newrot(mat, which_eye)
mat_t mat;
int which_eye;
{
	register fastf_t *mptr;
	GLfloat gtmat[16], view[16];
	GLfloat *gtmatp;
	mat_t	newm;
	int	i;

	
	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_newrot()\n", (char *)NULL);

	if(((struct ogl_vars *)dm_vars)->mvars.debug){
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
	  bu_vls_printf(&tmp_vls, "newrot matrix = \n");
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	switch(which_eye)  {
	case 0:
		/* Non-stereo */
		break;
	case 1:
		/* R eye */
		glViewport(0,  0, (XMAXSCREEN)+1, ( YSTEREO)+1); 
		glScissor(0,  0, (XMAXSCREEN)+1, (YSTEREO)+1);
		Ogl_puts( "R", 2020, 0, 0, DM_RED );
		break;
	case 2:
		/* L eye */
		glViewport(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1, ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1); 
		glScissor(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1, ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1);
		break;
	}

	mptr = mat;

	gtmat[0] = *(mptr++) * aspect;
	gtmat[4] = *(mptr++) * aspect;
	gtmat[8] = *(mptr++) * aspect;
	gtmat[12] = *(mptr++) * aspect;

	gtmat[1] = *(mptr++) * aspect;
	gtmat[5] = *(mptr++) * aspect;
	gtmat[9] = *(mptr++) * aspect;
	gtmat[13] = *(mptr++) * aspect;

	gtmat[2] = *(mptr++);
	gtmat[6] = *(mptr++);
	gtmat[10] = *(mptr++);
	gtmat[14] = *(mptr++);

	gtmat[3] = *(mptr++);
	gtmat[7] = *(mptr++);
	gtmat[11] = *(mptr++);
	gtmat[15] = *(mptr++);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -1.0 );
	glMultMatrixf( gtmat );

	/* Make sure that new matrix is applied to the lights */
	if (((struct ogl_vars *)dm_vars)->mvars.lighting_on ){
		glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
		glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
		glLightfv(GL_LIGHT2, GL_POSITION, light2_position);
		glLightfv(GL_LIGHT3, GL_POSITION, light3_position);

	}
}



/*
 *  			O G L _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */

/* ARGSUSED */
int
Ogl_object( sp, mat, ratio, white_flag )
register struct solid *sp;
mat_t mat;
double ratio;
int white_flag;
{
	register struct rt_vlist	*vp;
	register int nvec;
	register float	*gtvec;
	register float material[4];
	char	gtbuf[16+3*sizeof(double)];
	int first;
	int i,j;

	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_Object()\n", (char *)NULL);

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

	if (sp->s_soldash)
		glEnable(GL_LINE_STIPPLE);		/* set dot-dash */

	if (white_flag && ((struct ogl_vars *)dm_vars)->mvars.cueing_on)
		glDisable(GL_FOG);	

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		register short	r, g, b;
		if( white_flag )  {
			r = g = b = 230;
		} else {
			r = (short)sp->s_color[0];
			g = (short)sp->s_color[1];
			b = (short)sp->s_color[2];
		}

		if(((struct ogl_vars *)dm_vars)->mvars.lighting_on)
		{

			/* Ambient = .2, Diffuse = .6, Specular = .2 */

			material[0] = 	.2 * ( r / 255.0);
			material[1] = 	.2 * ( g / 255.0);
			material[2] = 	.2 * ( b / 255.0);
			material[3] = 1.0;
			glMaterialfv(GL_FRONT, GL_AMBIENT, material);
			glMaterialfv(GL_FRONT, GL_SPECULAR, material);

			material[0] *= 3.0;
			material[1] *= 3.0;
			material[2] *= 3.0;
			glMaterialfv(GL_FRONT, GL_DIFFUSE, material);

		} else {
			glColor3ub( r,  g,  b );
		}
	} else {
		if (white_flag){
			ovec = MAP_ENTRY(DM_WHITE);
			glIndexi(ovec);
		} else if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
			glIndexi(nvec);
			ovec = nvec;
		}

		if (((struct ogl_vars *)dm_vars)->mvars.lighting_on){
			material[0] = ovec - CMAP_RAMP_WIDTH + 2;
			material[1] = ovec - CMAP_RAMP_WIDTH/2;
			material[2] = ovec - 1;
			glMaterialfv(GL_FRONT, GL_COLOR_INDEXES, material);
		}
	}


	/* Viewing region is from -1.0 to +1.0 */
	first = 1;
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					glEnd();
				first = 0;
				glBegin(GL_LINE_STRIP);
				glVertex3dv( *pt );
				break;
			case RT_VLIST_LINE_DRAW:
				/* Draw line */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					glEnd();
				glBegin(GL_POLYGON);
				/* Set surface normal (vl_pnt points outward) */
				VMOVE( gtvec, *pt );
				glNormal3fv(gtvec);
				break;
			case RT_VLIST_POLY_MOVE:
				/* Polygon Move */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_DRAW:
				/* Polygon Draw */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				glVertex3dv( *pt );
				glEnd();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				VMOVE( gtvec, *pt );
				glNormal3fv(gtvec);
				break;
			}
		}
	}
	if( first == 0 ) glEnd();

	if (sp->s_soldash)
		glDisable(GL_LINE_STIPPLE);	/* restore solid lines */

	if (white_flag && ((struct ogl_vars *)dm_vars)->mvars.cueing_on){
		glEnable(GL_FOG);
	}

	return(1);	/* OK */

}

/*
 *			O G L _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
Ogl_normal()
{
	GLint mm; 

	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_normal\n", (char *)NULL);

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		glColor3ub( 0,  0,  0 );
	} else {
		ovec = MAP_ENTRY(DM_BLACK);
		glIndexi( ovec );
	}

	if (!((struct ogl_vars *)dm_vars)->face_flag){
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
		glLoadMatrixd( ((struct ogl_vars *)dm_vars)->faceplate_mat );
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glLoadIdentity();
		((struct ogl_vars *)dm_vars)->face_flag = 1;
		if(((struct ogl_vars *)dm_vars)->mvars.cueing_on)
			glDisable(GL_FOG);
		if (((struct ogl_vars *)dm_vars)->mvars.lighting_on)
			glDisable(GL_LIGHTING);

	}

	return;
}

/*
 *			O G L _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
void
Ogl_update()
{
  if (((struct ogl_vars *)dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl_update()\n", (char *)NULL);

    XFlush(dpy);
}


/*
 *			XOGL _ P U T S
 *
 * Output a string.
 * The starting position of the beam is as specified.
 */
void
Ogl_puts( str, x, y, size, colour )
register char *str;
int x,y,size, colour;
{
	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_puts()\n", (char *)NULL);

	
/*	glRasterPos2f( GED2IRIS(x),  GED2IRIS(y));*/
	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		glColor3ub( (short)ogl_rgbtab[colour].r,  (short)ogl_rgbtab[colour].g,  (short)ogl_rgbtab[colour].b );
	} else {
		ovec = MAP_ENTRY(colour);
		glIndexi( ovec );
	}


/*	glRasterPos2i( x,  y);*/
	glRasterPos2f( GED2IRIS(x),  GED2IRIS(y));
	glListBase(fontOffset);
	glCallLists(strlen( str ), GL_UNSIGNED_BYTE,  str );
}


/*
 *			O G L _ 2 D _ L I N E
 *
 */
void
Ogl_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	register int nvec;

	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl_2d_line()\n", (char *)NULL);

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		/* Yellow */

		glColor3ub( (short)255,  (short)255,  (short) 0 );
	} else {
		if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
			glIndexi(nvec);
			ovec = nvec;
		}
	}
	
/*	glColor3ub( (short)255,  (short)255,  (short) 0 );*/

	if(((struct ogl_vars *)dm_vars)->mvars.debug){
	  GLfloat pmat[16];
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  glGetFloatv(GL_PROJECTION_MATRIX, pmat);
	  bu_vls_printf(&tmp_vls, "projection matrix:\n");
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
	  glGetFloatv(GL_MODELVIEW_MATRIX, pmat);
	  bu_vls_printf(&tmp_vls, "modelview matrix:\n");
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
	  bu_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);

	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	if( dashed )
		glEnable(GL_LINE_STIPPLE);
		
	glBegin(GL_LINES); 
	 glVertex2f( GED2IRIS(x1),  GED2IRIS(y1));
	 glVertex2f( GED2IRIS(x2),  GED2IRIS(y2));
	glEnd();

	if( dashed )		/* restore solid */
		glDisable(GL_LINE_STIPPLE); 
}


static int
Ogl_doevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  static int button0  = 0;   /*  State of button 0 */
  static int knob_values[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  register struct dm_list *save_dm_list;
  register struct dm_list *p;
  struct bu_vls cmd;
  int status = CMD_OK;

  bu_vls_init(&cmd);
  save_dm_list = curr_dm_list;

  curr_dm_list = get_dm_list(eventPtr->xany.window);

  if(curr_dm_list == DM_LIST_NULL)
    goto end;

  /* Forward key events to a command window */
  if(mged_variables.send_key && eventPtr->type == KeyPress){
    char buffer[2];
    KeySym keysym;

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  &keysym, (XComposeStatus *)NULL);

    if(keysym == mged_variables.hot_key)
      goto end;

    write(dm_pipe[1], buffer, 1);

    bu_vls_free(&cmd);
    curr_dm_list = save_dm_list;

    /* Use this so that these events won't propagate */
    return TCL_RETURN;
  }

  if ( eventPtr->type == Expose && eventPtr->xexpose.count == 0 ) {
    glClearColor(0.0, 0.0, 0.0, 0.0);
    if (((struct ogl_vars *)dm_vars)->mvars.zbuf)
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    else
       glClear(GL_COLOR_BUFFER_BIT);

    dirty = 1;
    refresh();
    goto end;
  } else if( eventPtr->type == ConfigureNotify ) {
    Ogl_configure_window_shape(dmp);

    dirty = 1;
    refresh();
    goto end;
  } else if( eventPtr->type == MotionNotify ) {
    int mx, my;

    mx = eventPtr->xmotion.x;
    my = eventPtr->xmotion.y;

    switch(am_mode){
    case ALT_MOUSE_MODE_IDLE:
      if(scroll_active && eventPtr->xmotion.state & mb_mask)
	bu_vls_printf( &cmd, "M 1 %d %d\n", irisX2ged(mx), irisY2ged(my));
      else if(OgldoMotion)
	/* do the regular thing */
	/* Constant tracking (e.g. illuminate mode) bound to M mouse */
	bu_vls_printf( &cmd, "M 0 %d %d\n", irisX2ged(mx), irisY2ged(my));
      else /* not doing motion */
	goto end;

      break;
    case ALT_MOUSE_MODE_ROTATE:
      bu_vls_printf( &cmd, "iknob ax %f ay %f\n",
		     (my - omy)/512.0, (mx - omx)/512.0 );
      break;
    case ALT_MOUSE_MODE_TRANSLATE:
      {
	fastf_t fx, fy;

	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
	  fx = (mx/(fastf_t)((struct ogl_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)((struct ogl_vars *)dm_vars)->height) * 2;
	  bu_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy);
	}else{
	  fx = (mx - omx)/(fastf_t)((struct ogl_vars *)dm_vars)->width * 2.0;
	  fy = (omy - my)/(fastf_t)((struct ogl_vars *)dm_vars)->height * 2.0;
	  bu_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy);
	}
      }	     
      break;
    case ALT_MOUSE_MODE_ZOOM:
      bu_vls_printf( &cmd, "iknob aS %f\n",
		     (omy - my)/(fastf_t)((struct ogl_vars *)dm_vars)->height);
      break;
    }

    omx = mx;
    omy = my;
  }
#if IR_KNOBS
  else if( eventPtr->type == devmotionnotify ){
    XDeviceMotionEvent *M;
    int setting;

    M = (XDeviceMotionEvent * ) eventPtr;

    if(button0){
      ogl_dbtext(
		(mged_variables.adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
      goto end;
    }

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(mged_variables.adcflag) {
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	                !dv_1adc )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol(dv_1adc) +
	                  M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob ang1 %d\n",
		      setting );
      }
      break;
    case DIAL1:
      if(mged_variables.rateknobs){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !rate_zoom )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * rate_zoom)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob S %f\n",
		       setting / 512.0 );
      }else{
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !absolute_zoom )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * absolute_zoom)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob aS %f\n",
		       setting / 512.0 );
      }
      break;
    case DIAL2:
      if(mged_variables.adcflag){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	                !dv_2adc )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol(dv_2adc) +
	                  M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob ang2 %d\n",
		      setting );
      }else {
	if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_rotate[Z] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * rate_rotate[Z])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob z %f\n",
		      setting / 512.0 );
	}else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[Z] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * absolute_rotate[Z])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob az %f\n",
			 setting / 512.0 );
	}
      }
      break;
    case DIAL3:
      if(mged_variables.adcflag){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !dv_distadc)
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol(dv_distadc) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob distadc %d\n",
		      setting );
      }else {
	if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_slew[Z] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * rate_slew[Z])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob Z %f\n",
			 setting / 512.0 );
	}else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_slew[Z] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * absolute_slew[Z])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob aZ %f\n",
			 setting / 512.0 );
	}
      }
      break;
    case DIAL4:
      if(mged_variables.adcflag){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !dv_yadc)
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol(dv_yadc) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob yadc %d\n",
		      setting );
      }else{
	if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_rotate[Y] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * rate_rotate[Y])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob y %f\n",
			 setting / 512.0 );
	}else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[Y] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * absolute_rotate[Y])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob ay %f\n",
			 setting / 512.0 );
	}
      }
      break;
    case DIAL5:
      if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_slew[Y] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * rate_slew[Y])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob Y %f\n",
		       setting / 512.0 );
      }else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_slew[Y] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * absolute_slew[Y])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob aY %f\n",
		       setting / 512.0 );
      }
      break;
    case DIAL6:
      if(mged_variables.adcflag){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !dv_xadc)
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol(dv_xadc) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob xadc %d\n",
		      setting );
      }else{
	if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_rotate[X] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * rate_rotate[X])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob x %f\n",
			 setting / 512.0 );
	}else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[X] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * absolute_rotate[X])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob ax %f\n",
			 setting / 512.0 );
	}
      }
      break;
    case DIAL7:
      if(mged_variables.rateknobs){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !rate_slew[X] )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * rate_slew[X])) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob X %f\n",
		       setting / 512.0 );
      }else{
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !absolute_slew[X] )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Ogl_add_tol((int)(512.5 * absolute_slew[X])) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob aX %f\n",
		       setting / 512.0 );
      }
      break;
    default:
      break;
    }

    /* Keep track of the knob values */
    knob_values[M->first_axis] = M->axis_data[0];
  }
#endif
#if IR_BUTTONS
  else if( eventPtr->type == devbuttonpress ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      button0 = 1;
      goto end;
    }

    if(button0){
      ogl_dbtext(label_button(bmap[B->button - 1]));
    }else if(B->button == 4){
      bu_vls_strcat(&cmd, "knob zero\n");
      set_knob_offset();
    }else
      bu_vls_printf(&cmd, "press %s\n",
		    label_button(bmap[B->button - 1]));
  }else if( eventPtr->type == devbuttonrelease ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1)
      button0 = 0;

    goto end;
  }
#endif
  else
    goto end;

  status = cmdline(&cmd, FALSE);
end:
  bu_vls_free(&cmd);
  curr_dm_list = save_dm_list;

  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
}
	    
/*
 *			O G L _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 *
 * DEPRECATED 
 *
 */
/* ARGSUSED */
void
Ogl_input( input, noblock )
fd_set		*input;
int		noblock;
{
    return;
}

/* 
 *			O G L _ L I G H T
 */
/* ARGSUSED */
void
Ogl_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	return;
}

/* ARGSUSED */
unsigned
Ogl_cvtvecs( sp )
struct solid *sp;
{
	return( 0 );
}

/*
 * Loads displaylist
 */
unsigned
Ogl_load( addr, count )
unsigned addr, count;
{
  struct bu_vls tmp_vls;

  bu_vls_init(&tmp_vls);
  bu_vls_printf(&tmp_vls, "Ogl_load(x%x, %d.)\n", addr, count );
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
  return( 0 );
}

void
Ogl_statechange( a, b )
int	a, b;
{
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( b )  {
	case ST_VIEW:
	    /* constant tracking OFF */
	    OgldoMotion = 0;
	    break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	case ST_S_VPICK:
	    /* constant tracking ON */
	    OgldoMotion = 1;
	    break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	    /* constant tracking OFF */
	    OgldoMotion = 0;
	    break;
	default:
	  Tcl_AppendResult(interp, "Ogl_statechange: unknown state ",
			   state_str[b], "\n", (char *)NULL);
	  break;
	}

	/*Ogl_viewchange( DM_CHGV_REDO, SOLID_NULL );*/
}

void
Ogl_viewchange()
{
}

void
Ogl_colorchange()
{
	register int i;
	register int nramp;
	XColor celltest;
	int count = 0;
	Colormap a_cmap;

	if( ((struct ogl_vars *)dm_vars)->mvars.debug )
	  Tcl_AppendResult(interp, "colorchange\n", (char *)NULL);

	/* Program the builtin colors */
	ogl_rgbtab[0].r=0; 
	ogl_rgbtab[0].g=0; 
	ogl_rgbtab[0].b=0;/* Black */
	ogl_rgbtab[1].r=255; 
	ogl_rgbtab[1].g=0; 
	ogl_rgbtab[1].b=0;/* Red */
	ogl_rgbtab[2].r=0; 
	ogl_rgbtab[2].g=0; 
	ogl_rgbtab[2].b=255;/* Blue */
	ogl_rgbtab[3].r=255; 
	ogl_rgbtab[3].g=255;
	ogl_rgbtab[3].b=0;/*Yellow */
	ogl_rgbtab[4].r = ogl_rgbtab[4].g = ogl_rgbtab[4].b = 255; /* White */
	slotsused = 5;

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		if(((struct ogl_vars *)dm_vars)->mvars.cueing_on) {
			glEnable(GL_FOG);
		} else {
			glDisable(GL_FOG);
		}

		glColor3ub( (short)255,  (short)255,  (short)255 );

		/* apply region-id based colors to the solid table */
		color_soltab();

		return;
	}

	if(USE_RAMP && (ogl_index_size < 7)) {
	  Tcl_AppendResult(interp, "Too few bitplanes: depthcueing and lighting disabled\n",
			   (char *)NULL);
	  ((struct ogl_vars *)dm_vars)->mvars.cueing_on = 0;
	  ((struct ogl_vars *)dm_vars)->mvars.lighting_on = 0;
	}
	/* number of slots is 2^indexsize */
	ogl_nslots = 1<<ogl_index_size;
	if( ogl_nslots > NSLOTS )  ogl_nslots = NSLOTS;
	if(USE_RAMP) {
		/* peel off reserved ones */
		ogl_nslots = (ogl_nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
	} else {
		ogl_nslots -= CMAP_BASE;	/* peel off the reserved entries */
	}

	ovec = -1;	/* Invalidate the old colormap entry */

	/* apply region-id based colors to the solid table */
	color_soltab();

	/* best to do this before the colorit */
	if (((struct ogl_vars *)dm_vars)->mvars.cueing_on && ((struct ogl_vars *)dm_vars)->mvars.lighting_on){
		((struct ogl_vars *)dm_vars)->mvars.lighting_on = 0;
		glDisable(GL_LIGHTING);
	}

	/* Map the colors in the solid table to colormap indices */
	Ogl_colorit();

	for( i=0; i < slotsused; i++ )  {
		Ogl_gen_color( i, ogl_rgbtab[i].r, ogl_rgbtab[i].g, ogl_rgbtab[i].b);
	}

	/* best to do this after the colorit */
	if (((struct ogl_vars *)dm_vars)->mvars.cueing_on){
		glEnable(GL_FOG);
	} else {
		glDisable(GL_FOG);
	}

	ovec = MAP_ENTRY(DM_WHITE);
	glIndexi( ovec );

}

/* ARGSUSED */
void
Ogl_debug(lvl)
{
  ((struct ogl_vars *)dm_vars)->mvars.debug = lvl;
  XFlush(dpy);
  Tcl_AppendResult(interp, "flushed\n", (char *)NULL);
}

void
Ogl_window(w)
register int w[];
{
}

/* the font used depends on the size of the window opened */
#define FONTBACK	"-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1"
#define FONT5	"5x7"
#define FONT6	"6x10"
#define FONT7	"7x13"
#define FONT8	"8x13"
#define FONT9	"9x15"

static int
Ogl_setup( name )
char	*name;
{
  static count = 0;
  char *cp, symbol;
  XGCValues gcv;
  XColor a_color;
  Visual *a_visual;
  int a_screen, num, i, success;
  int major, minor;
  Colormap  a_cmap;
  XVisualInfo *vip;
  int dsize, use, dbfr, rgba, red, blue, green, alpha, index;
  GLfloat backgnd[4];
  long supplied;
  int j, k;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  struct bu_vls str;
  Display *tmp_dpy;

  bu_vls_init(&str);

  /* Only need to do this once for this display manager */
  if(!count)
    Ogl_load_startup();

  if(BU_LIST_IS_EMPTY(&head_ogl_vars.l))
    Tk_CreateGenericHandler(Ogl_doevent, (ClientData)NULL);

  BU_LIST_APPEND(&head_ogl_vars.l, &((struct ogl_vars *)dm_vars)->l);

  bu_vls_printf(&pathName, ".dm_ogl%d", count++);

  /* this is important so that Ogl_configure_notify knows to set
   * the font */
  fontstruct = NULL;

  if((tmp_dpy = XOpenDisplay(name)) == NULL){
    bu_vls_free(&str);
    return -1;
  }

  ((struct ogl_vars *)dm_vars)->width = DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  ((struct ogl_vars *)dm_vars)->height = DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;

  /* Make window square */
  if(((struct ogl_vars *)dm_vars)->height < ((struct ogl_vars *)dm_vars)->width)
    ((struct ogl_vars *)dm_vars)->width = ((struct ogl_vars *)dm_vars)->height;
  else
    ((struct ogl_vars *)dm_vars)->height = ((struct ogl_vars *)dm_vars)->width;

  XCloseDisplay(tmp_dpy);

  /* Make xtkwin a toplevel window */
  xtkwin = Tk_CreateWindowFromPath(interp, tkwin, bu_vls_addr(&pathName), name);

  /* Open the display - XXX see what NULL does now */
  if( xtkwin == NULL ) {
    Tcl_AppendResult(interp, "dm-Ogl: Failed to open ", bu_vls_addr(&pathName),
		     "\n", (char *)NULL);
    return -1;
  }

  bu_vls_strcpy(&str, "init_ogl ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&pathName));

  if(cmdline(&str, FALSE) == CMD_BAD){
    bu_vls_free(&str);
    return -1;
  }

  dpy = Tk_Display(xtkwin);

  /* must do this before MakeExist */
  if ((vip=Ogl_set_visual(xtkwin))==NULL){
    Tcl_AppendResult(interp, "Ogl_open: Can't get an appropriate visual.\n", (char *)NULL);
    return -1;
  }

  Tk_GeometryRequest(xtkwin, ((struct ogl_vars *)dm_vars)->width, ((struct ogl_vars *)dm_vars)->height);
  Tk_MoveToplevelWindow(xtkwin, 1276 - 976, 0);
  Tk_MakeWindowExist(xtkwin);

  win = Tk_WindowId(xtkwin);

  a_screen = Tk_ScreenNumber(xtkwin);

  /* open GLX context */
  /* If the sgi display manager has been used, then we must use
   * an indirect context. Otherwise use direct, since it is usually
   * faster.
   */
  if ((glxc = glXCreateContext(dpy, vip, 0, ogl_sgi_used ? GL_FALSE : GL_TRUE))==NULL) {
    Tcl_AppendResult(interp, "Ogl_open: couldn't create glXContext.\n", (char *)NULL);
    return -1;
  }
  /* If we used an indirect context, then as far as sgi is concerned,
   * gl hasn't been used.
   */
  ogl_is_direct = (char) glXIsDirect(dpy, glxc);
  Tcl_AppendResult(interp, "Using ", ogl_is_direct ? "a direct" : "an indirect",
		   " OpenGL rendering context.\n", (char *)NULL);
  /* set ogl_ogl_used if the context was ever direct */
  ogl_ogl_used = (ogl_is_direct || ogl_ogl_used);

  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  olist = list = (XDeviceInfoPtr) XListInputDevices (dpy, &ndevices);

  /* IRIX 4.0.5 bug workaround */
  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(dpy, list->id)) == (XDevice *)NULL){
	  Tcl_AppendResult(interp, "Glx_open: Couldn't open the dials+buttons\n", (char *)NULL);
	  goto Done;
	}

	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
#if IR_BUTTONS
	  case ButtonClass:
	    DeviceButtonPress(dev, devbuttonpress, e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, devbuttonrelease, e_class[nclass]);
	    ++nclass;
	    break;
#endif
#if IR_KNOBS
	  case ValuatorClass:
	    DeviceMotionNotify(dev, devmotionnotify, e_class[nclass]);
	    ++nclass;
	    break;
#endif
	  default:
	    break;
	  }
	}

	XSelectExtensionEvent(dpy, win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);

  if (!glXMakeCurrent(dpy, win, glxc)){
    Tcl_AppendResult(interp, "Ogl_open: Couldn't make context current\n", (char *)NULL);
    return -1;
  }

  /* display list (fontOffset + char) will displays a given ASCII char */
  if ((fontOffset = glGenLists(128))==0){
    Tcl_AppendResult(interp, "dm-ogl: Can't make display lists for font.\n", (char *)NULL);
    return -1;
  }

  /* do viewport, ortho commands and initialize font*/
  Ogl_configure_window_shape();

  /* Lines will be solid when stippling disabled, dashed when enabled*/
  glLineStipple( 1, 0xCF33);
  glDisable(GL_LINE_STIPPLE);

  backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
  glFogi(GL_FOG_MODE, GL_LINEAR);
  glFogf(GL_FOG_START, 0.0);
  glFogf(GL_FOG_END, 2.0);
  if (((struct ogl_vars *)dm_vars)->mvars.rgb)
    glFogfv(GL_FOG_COLOR, backgnd);
  else
    glFogi(GL_FOG_INDEX, CMAP_RAMP_WIDTH - 1);
  glFogf(GL_FOG_DENSITY, VIEWFACTOR);	

  /* Initialize matrices */
  /* Leave it in model_view mode normally */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 2.0);
  glGetDoublev(GL_PROJECTION_MATRIX, ((struct ogl_vars *)dm_vars)->faceplate_mat);
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity(); 
  glTranslatef( 0.0, 0.0, -1.0); 
  glPushMatrix();
  glLoadIdentity();
  ((struct ogl_vars *)dm_vars)->face_flag = 1;	/* faceplate matrix is on top of stack */
		
  Tk_MapWindow(xtkwin);
  return 0;
}

/* currently, get a double buffered rgba visual that works with Tk and
 * OpenGL
 */
XVisualInfo *
Ogl_set_visual(tkwin)
Tk_Window tkwin;
{
	XVisualInfo *vip, vitemp, *vibase, *maxvip;
	int good[40];
	int num, i, j;
	int use, rgba, dbfr, stereo;
	int m_stereo, m_double, m_rgba;
	int tries, baddepth;

	/* m_stereo - try to get stereo 
	 * m_double - try to get double buffered
	 * m_rgba  - try to get rgb
	 */

	if( mged_variables.eye_sep_dist )  {
		m_stereo = 1;
	} else {
		m_stereo = 0;
	}

	m_double = 1;
	m_rgba = 1;
	
	/* Try to satisfy the above desires with a color visual of the
	 * greatest depth */

	vibase = XGetVisualInfo(dpy, 0,	&vitemp, &num);

	while (1) {
		for (i=0, j=0, vip=vibase; i<num; i++, vip++){
			/* requirements */
			glXGetConfig(dpy,vip, GLX_USE_GL, &use);
			if (!use)
				continue;
			/* desires */
			if (m_rgba){
				glXGetConfig(dpy, vip, GLX_RGBA, &rgba);
				if (!rgba)
					continue;
			} else if (vip->class != PseudoColor) {
				/* if index mode, accept only read/write*/
				continue;
			}
			if ( m_stereo ) {
				glXGetConfig(dpy, vip, GLX_STEREO, &stereo);
				if (!stereo)
					continue;
			}
			if (m_double ) {
				glXGetConfig(dpy, vip, GLX_DOUBLEBUFFER,&dbfr);
				if (!dbfr)
					continue;
			}
			
			/* this visual meets criteria */
			good[j++] = i;
		}

		/* j = number of acceptable visuals under consideration */
		if (j >= 1){
			baddepth = 1000;
			tries = 0;
			while (tries < j) {
				maxvip = vibase + good[0];
				for (i=1; i<j; i++) {
					vip = vibase + good[i];
					if ((vip->depth > maxvip->depth)&&(vip->depth < baddepth)){
						maxvip = vip;
					}
				}

				/* make sure Tk handles it */
				if (maxvip->class == PseudoColor)
					((struct ogl_vars *)dm_vars)->cmap = XCreateColormap(dpy,
						RootWindow(dpy, maxvip->screen),
						maxvip->visual, AllocAll);
				else
					((struct ogl_vars *)dm_vars)->cmap = XCreateColormap(dpy,
						RootWindow(dpy, maxvip->screen),
						maxvip->visual, AllocNone);

				if (Tk_SetWindowVisual(tkwin, maxvip->visual, maxvip->depth, ((struct ogl_vars *)dm_vars)->cmap)){
					((struct ogl_vars *)dm_vars)->mvars.doublebuffer = m_double;
					glXGetConfig(dpy, maxvip, GLX_DEPTH_SIZE, &((struct ogl_vars *)dm_vars)->mvars.depth);
					if (((struct ogl_vars *)dm_vars)->mvars.depth > 0)
						((struct ogl_vars *)dm_vars)->mvars.zbuf = 1;
					((struct ogl_vars *)dm_vars)->mvars.rgb = m_rgba;
					if (!m_rgba){
						glXGetConfig(dpy, maxvip, GLX_BUFFER_SIZE, &ogl_index_size);
					}
					stereo_is_on = m_stereo;
					return (maxvip); /* sucess */
				} else { 
					/* retry with lesser depth */
					baddepth = maxvip->depth;
					tries ++;
					XFreeColormap(dpy,((struct ogl_vars *)dm_vars)->cmap);
				}
			}
					
		}
				

		/* if no success at this point, relax a desire and try again */
		if ( m_stereo ){
		  m_stereo = 0;
		  Tcl_AppendResult(interp, "Stereo not available.\n", (char *)NULL);
		} else if (m_rgba) {
		  m_rgba = 0;
		  Tcl_AppendResult(interp, "RGBA not available.\n", (char *)NULL);
		} else if (m_double) {
		  m_double = 0;
		  Tcl_AppendResult(interp, "Doublebuffering not available. \n", (char *)NULL);
		} else {
			return(NULL); /* failure */
		}
	}
}

/* 
 *			O G L _ C O N F I G U R E _ W I N D O W _ S H A P E
 *
 *  Either initially, or on resize/reshape of the window,
 *  sense the actual size of the window, and perform any
 *  other initializations of the window configuration.
 *
 * also change font size if necessary
 */
void
Ogl_configure_window_shape()
{
	int		npix;
	GLint mm; 
	XWindowAttributes xwa;
	XFontStruct	*newfontstruct;

	XGetWindowAttributes( dpy, win, &xwa );
	((struct ogl_vars *)dm_vars)->height = xwa.height;
	((struct ogl_vars *)dm_vars)->width = xwa.width;
	
	glViewport(0,  0, (((struct ogl_vars *)dm_vars)->width), (((struct ogl_vars *)dm_vars)->height));
	glScissor(0,  0, (((struct ogl_vars *)dm_vars)->width)+1, (((struct ogl_vars *)dm_vars)->height)+1);

	if( ((struct ogl_vars *)dm_vars)->mvars.zbuffer_on )
	  establish_zbuffer();

	establish_lighting();

#if 0
	glDrawBuffer(GL_FRONT_AND_BACK);

	glClearColor(0.0, 0.0, 0.0, 0.0);
	if (((struct ogl_vars *)dm_vars)->mvars.zbuffer_on)
		glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	else
		glClear( GL_COLOR_BUFFER_BIT);

	if (((struct ogl_vars *)dm_vars)->mvars.doublebuffer)
		glDrawBuffer(GL_BACK);
	else
		glDrawBuffer(GL_FRONT);

	/*CJXX*/
	glFlush();
#endif
	/*CJXX this might cause problems in perspective mode? */
	glGetIntegerv(GL_MATRIX_MODE, &mm);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho( -xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0 );
	glMatrixMode(mm);
	aspect = (fastf_t)((struct ogl_vars *)dm_vars)->height/
	  (fastf_t)((struct ogl_vars *)dm_vars)->width;


	/* First time through, load a font or quit */
	if (fontstruct == NULL) {
	  if ((fontstruct = XLoadQueryFont(dpy, FONT9)) == NULL ) {
	    /* Try hardcoded backup font */
	    if ((fontstruct = XLoadQueryFont(dpy, FONTBACK)) == NULL) {
	      Tcl_AppendResult(interp, "dm-Ogl: Can't open font '", FONT9,
			       "' or '", FONTBACK, "'\n", (char *)NULL);
	      return;
	    }
	  }
	  glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
	}
		

	/* Always try to choose a the font that best fits the window size.
	 */

	if (((struct ogl_vars *)dm_vars)->width < 582) {
		if (fontstruct->per_char->width != 5) {
			if ((newfontstruct = XLoadQueryFont(dpy, FONT5)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	} else if (((struct ogl_vars *)dm_vars)->width < 679) {
		if (fontstruct->per_char->width != 6){
			if ((newfontstruct = XLoadQueryFont(dpy, FONT6)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	} else if (((struct ogl_vars *)dm_vars)->width < 776) {
		if (fontstruct->per_char->width != 7){
			if ((newfontstruct = XLoadQueryFont(dpy, FONT7)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	} else if (((struct ogl_vars *)dm_vars)->width < 873) {
		if (fontstruct->per_char->width != 8){
			if ((newfontstruct = XLoadQueryFont(dpy, FONT8)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	} else {
		if (fontstruct->per_char->width != 9){
			if ((newfontstruct = XLoadQueryFont(dpy, FONT9)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	}

	
}

/*
 *			O G L _ D M
 * 
 *  Implement display-manager specific commands, from MGED "dm" command.
 */
int
Ogl_dm(argc, argv)
int	argc;
char	**argv;
{
  struct bu_vls	vls;
  int status;
  char *av[4];
  char xstr[32];
  char ystr[32];
  char zstr[32];

  if( !strcmp( argv[0], "set" ) )  {
    struct bu_vls tmp_vls;

    bu_vls_init(&vls);
    bu_vls_init(&tmp_vls);
    start_catching_output(&tmp_vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      bu_struct_print("dm_ogl internal variables", Ogl_vparse, (CONST char *)&((struct ogl_vars *)dm_vars)->mvars );
    } else if( argc == 2 ) {
      bu_vls_struct_item_named( &vls, Ogl_vparse, argv[1], (CONST char *)&((struct ogl_vars *)dm_vars)->mvars, ',');
      bu_log( "%s\n", bu_vls_addr(&vls) );
    } else {
      bu_vls_printf( &vls, "%s=\"", argv[1] );
      bu_vls_from_argv( &vls, argc-2, argv+2 );
      bu_vls_putc( &vls, '\"' );
      bu_struct_parse( &vls, Ogl_vparse, (char *)&((struct ogl_vars *)dm_vars)->mvars );
    }

    bu_vls_free(&vls);

    stop_catching_output(&tmp_vls);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
    return TCL_OK;
  }

  if( !strcmp( argv[0], "m" )){
    scroll_active = 0;

    if( argc < 5){
      Tcl_AppendResult(interp, "dm m: need more parameters\n",
		       "dm m button 1|0 xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    /* This assumes a 3-button mouse */
    switch(*argv[1]){
    case '1':
      mb_mask = Button1Mask;
      break;
    case '2':
      mb_mask = Button2Mask;
      break;
    case '3':
      mb_mask = Button3Mask;
      break;
    default:
      Tcl_AppendResult(interp, "dm m: bad button value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d\n", argv[2],
		  irisX2ged(atoi(argv[3])), irisY2ged(atoi(argv[4])));
    status = cmdline(&vls, FALSE);
    bu_vls_free(&vls);

    if(status == CMD_OK)
      return TCL_OK;

    return TCL_ERROR;
  }

  status = TCL_OK;

  if( !strcmp( argv[0], "am" )){
    int buttonpress;

    scroll_active = 0;

    if( argc < 5){
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    buttonpress = atoi(argv[2]);
    omx = atoi(argv[3]);
    omy = atoi(argv[4]);

    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	am_mode = ALT_MOUSE_MODE_ROTATE;
	break;
      case 't':
	am_mode = ALT_MOUSE_MODE_TRANSLATE;

	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
	  fastf_t fx, fy;

	  bu_vls_init(&vls);
	  fx = (omx/(fastf_t)((struct ogl_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - omy/(fastf_t)((struct ogl_vars *)dm_vars)->height) * 2;
	  bu_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	  (void)cmdline(&vls, FALSE);
	  bu_vls_free(&vls);
	}

	break;
      case 'z':
	am_mode = ALT_MOUSE_MODE_ZOOM;
	break;
      default:
	Tcl_AppendResult(interp, "dm am: need more parameters\n",
			 "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
    }else{
      am_mode = ALT_MOUSE_MODE_IDLE;
    }

    return status;
  }

  Tcl_AppendResult(interp, "dm: bad command - ", argv[0], "\n", (char *)NULL);
  return TCL_ERROR;
}

void	
establish_lighting()
{


	if (!((struct ogl_vars *)dm_vars)->mvars.lighting_on) {
		/* Turn it off */
		glDisable(GL_LIGHTING);
		if (!((struct ogl_vars *)dm_vars)->mvars.rgb)
			Ogl_colorchange();
	} else {
		/* Turn it on */

		if (!((struct ogl_vars *)dm_vars)->mvars.rgb){
			if (((struct ogl_vars *)dm_vars)->mvars.cueing_on){
				((struct ogl_vars *)dm_vars)->mvars.cueing_on = 0;
				glDisable(GL_FOG);
			} 
			Ogl_colorchange();
		}

		glLightModelfv(GL_LIGHT_MODEL_AMBIENT, amb_three);
		glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);

		/* light positions specified in Ogl_newrot */

		glLightfv(GL_LIGHT0, GL_SPECULAR, light0_diffuse);
		glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
		glLightfv(GL_LIGHT1, GL_SPECULAR, light1_diffuse);
		glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
		glLightfv(GL_LIGHT2, GL_SPECULAR, light2_diffuse);
		glLightfv(GL_LIGHT2, GL_DIFFUSE, light2_diffuse);
		glLightfv(GL_LIGHT3, GL_SPECULAR, light3_diffuse);
		glLightfv(GL_LIGHT3, GL_DIFFUSE, light3_diffuse);

		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
		glEnable(GL_LIGHT1);
		glEnable(GL_LIGHT3);
		glEnable(GL_LIGHT2);
	}
	dmaflag = 1;
}	


static void	
establish_zbuffer()
{
	if( ((struct ogl_vars *)dm_vars)->mvars.zbuf == 0 ) {
	  Tcl_AppendResult(interp, "dm-Ogl: This machine has no Zbuffer to enable\n",
			   (char *)NULL);
	  ((struct ogl_vars *)dm_vars)->mvars.zbuffer_on = 0;
	}

	if (((struct ogl_vars *)dm_vars)->mvars.zbuffer_on)  {
		glEnable(GL_DEPTH_TEST);
	} else {
		glDisable(GL_DEPTH_TEST);
	}
	dmaflag = 1;
	
	return;
}

static void
establish_perspective()
{
  bu_vls_printf( &dm_values.dv_string,
		 "set perspective %d\n",
		 ((struct ogl_vars *)dm_vars)->mvars.perspective_mode ?
		 perspective_table[perspective_angle] :
		 -1 );
  dmaflag = 1;
}

/*
  This routine will toggle the perspective_angle if the
  dummy_perspective value is 0 or less. Otherwise, the
  perspective_angle is set to the value of (dummy_perspective - 1).
*/
static void
set_perspective()
{
  /* set perspective matrix */
  if(((struct ogl_vars *)dm_vars)->mvars.dummy_perspective > 0)
    perspective_angle = ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective <= 4 ? ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective - 1: 3;
  else if (--perspective_angle < 0) /* toggle perspective matrix */
    perspective_angle = 3;

  if(((struct ogl_vars *)dm_vars)->mvars.perspective_mode)
    bu_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[perspective_angle] );

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective = 1;

  dmaflag = 1;
}


static void
establish_am()
{
  return;
}

static void
Ogl_colorit()
{
	register struct solid	*sp;
	register struct rgbtab *rgb;
	register int i;
	register int r,g,b;

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  return;

	FOR_ALL_SOLIDS( sp )  {
		r = sp->s_color[0];
		g = sp->s_color[1];
		b = sp->s_color[2];
		if( (r == 255 && g == 255 && b == 255) ||
		    (r == 0 && g == 0 && b == 0) )  {
			sp->s_dmindex = DM_WHITE;
			continue;
		}

		/* First, see if this matches an existing color map entry */
		rgb = ogl_rgbtab;
		for( i = 0; i < slotsused; i++, rgb++ )  {
			if( rgb->r == r && rgb->g == g && rgb->b == b )  {
				sp->s_dmindex = i;
				goto next;
			}
		}

		/* If slots left, create a new color map entry, first-come basis */
		if( slotsused < ogl_nslots )  {
			rgb = &ogl_rgbtab[i=(slotsused++)];
			rgb->r = r;
			rgb->g = g;
			rgb->b = b;
			sp->s_dmindex = i;
			continue;
		}
		sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		
		;
	}
}


#if IR_KNOBS
ogl_dbtext(str)
{
  Tcl_AppendResult(interp, "dm-ogl: You pressed Help key and '",
		   str, "'\n", (char *)NULL);
}
#if 0
/*
 *			I R L I M I T
 *
 * Because the dials are so sensitive, setting them exactly to
 * zero is very difficult.  This function can be used to extend the
 * location of "zero" into "the dead zone".
 */
static int
irlimit(i)
int i;
{
  if( i > NOISE )
    return( i-NOISE );
  if( i < -NOISE )
    return( i+NOISE );
  return(0);
}

static int
Ogl_add_tol(i)
int i;\
{
  if( i > 0 )
    return( i + NOISE );
  if( i < 0 )
    return( i - NOISE );
  return(0);
}
#endif
#endif

/*			G E N _ C O L O R
 *
 *	maps a given color into the appropriate colormap entry
 *	for both depthcued and non-depthcued mode.  In depthcued mode,
 *	Ogl_gen_color also generates the colormap ramps.  Note that in depthcued
 *	mode, DM_BLACK uses map entry 0, and does not generate a ramp for it.
 *	Non depthcued mode skips the first CMAP_BASE colormap entries.
 *
 *	This routine is not called at all if ((struct ogl_vars *)dm_vars)->mvars.rgb is set.
 */
void
Ogl_gen_color(c)
int c;
{
	if(USE_RAMP) {

		/*  Not much sense in making a ramp for DM_BLACK.  Besides
		 *  which, doing so, would overwrite the bottom color
		 *  map entries, which is a no-no.
		 */
		if( c != DM_BLACK) {
			register int i, j;
			fastf_t r_inc, g_inc, b_inc;
			fastf_t red, green, blue;
			XColor cells[CMAP_RAMP_WIDTH];

			red = r_inc = ogl_rgbtab[c].r * (256/CMAP_RAMP_WIDTH);
			green = g_inc = ogl_rgbtab[c].g * (256/CMAP_RAMP_WIDTH);
			blue = b_inc = ogl_rgbtab[c].b * (256/CMAP_RAMP_WIDTH);

#if 0
			red = ogl_rgbtab[c].r * 256;
			green = ogl_rgbtab[c].g * 256;
			blue = ogl_rgbtab[c].b * 256;
#endif
			

			if (((struct ogl_vars *)dm_vars)->mvars.cueing_on){
				for(i = 0, j = MAP_ENTRY(c) + CMAP_RAMP_WIDTH - 1; 
					i < CMAP_RAMP_WIDTH;
				    i++, j--, red += r_inc, green += g_inc, blue += b_inc){
				    	cells[i].pixel = j;
				    	cells[i].red = (short)red;
				    	cells[i].green = (short)green;
				    	cells[i].blue = (short)blue;
				    	cells[i].flags = DoRed|DoGreen|DoBlue;
				}
			} else { /* ((struct ogl_vars *)dm_vars)->mvars.lighting_on */ 
				for(i = 0, j = MAP_ENTRY(c) - CMAP_RAMP_WIDTH + 1; 
					i < CMAP_RAMP_WIDTH;
				    i++, j++, red += r_inc, green += g_inc, blue += b_inc){
				    	cells[i].pixel = j;
				    	cells[i].red = (short)red;
				    	cells[i].green = (short)green;
				    	cells[i].blue = (short)blue;
				    	cells[i].flags = DoRed|DoGreen|DoBlue;
				    }
			}
			XStoreColors(dpy, ((struct ogl_vars *)dm_vars)->cmap, cells, CMAP_RAMP_WIDTH);
		}
	} else {
		XColor cell, celltest;

		cell.pixel = c + CMAP_BASE;
		cell.red = ogl_rgbtab[c].r * 256;
		cell.green = ogl_rgbtab[c].g * 256;
		cell.blue = ogl_rgbtab[c].b * 256;
		cell.flags = DoRed|DoGreen|DoBlue;
		XStoreColor(dpy, ((struct ogl_vars *)dm_vars)->cmap, &cell);

	}
}

static void
print_cmap()
{
	int i;
	XColor cell;

	for (i=0; i<112; i++){
		cell.pixel = i;
		XQueryColor(dpy, ((struct ogl_vars *)dm_vars)->cmap, &cell);
		printf("%d  = %d %d %d\n",i,cell.red,cell.green,cell.blue);
	}
}

static void
set_knob_offset()
{
  int i;

  for(i = 0; i < 8; ++i)
    knobs[i] = 0;
}

static void
ogl_var_init()
{
  dm_vars = bu_malloc(sizeof(struct ogl_vars),
					    "ogl_var_init: glx_vars");
  bzero((void *)dm_vars, sizeof(struct ogl_vars));
  devmotionnotify = LASTEvent;
  devbuttonpress = LASTEvent;
  devbuttonrelease = LASTEvent;
  ((struct ogl_vars *)dm_vars)->dm_list = curr_dm_list;
  perspective_angle = 3;
  aspect = 1.0;
  ovec = -1;

  /* initialize the modifiable variables */
  ((struct ogl_vars *)dm_vars)->mvars.cueing_on = 1;          /* Depth cueing flag - for colormap work */
  ((struct ogl_vars *)dm_vars)->mvars.zclipping_on = 1;       /* Z Clipping flag */
  ((struct ogl_vars *)dm_vars)->mvars.zbuffer_on = 1;         /* Hardware Z buffer is on */
  ((struct ogl_vars *)dm_vars)->mvars.linewidth = 1;      /* Line drawing width */
  ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective = 1;
  ((struct ogl_vars *)dm_vars)->mvars.fastfog = 1;
  ((struct ogl_vars *)dm_vars)->mvars.fogdensity = 1.0;
}

static struct dm_list *
get_dm_list(window)
Window window;
{
  register struct ogl_vars *p;

  for( BU_LIST_FOR(p, ogl_vars, &head_ogl_vars.l) ){
    if(window == p->_win){
      if (!glXMakeCurrent(p->_dpy, p->_win, p->_glxc)){
	return DM_LIST_NULL;
      }

      return p->dm_list;
    }
  }

  return DM_LIST_NULL;
}
#endif
@


1.26
log
@rt_list ---> bu_list
@
text
@d60 842
d908 2
d911 1
a911 2

extern void sl_toggle_scroll();		/* from scroll.c */
d969 1
a969 1
	Ogl_window, Ogl_debug,
d975 3
a977 1
	Ogl_dm
a1107 2
extern struct device_values dm_values;	/* values read from devices */

d1806 1
a1806 1
    Ogl_configure_window_shape();
a2404 4
  /* Only need to do this once */
  if(tkwin == NULL)
    gui_setup();

d2412 1
a2412 1
  BU_LIST_APPEND(&head_ogl_vars.l, &((struct ogl_vars *)curr_dm_list->_dm_vars)->l);
d2562 1
a2562 2
  glFogf(GL_FOG_DENSITY, VIEWFACTOR);
	
d3124 1
d3154 1
d3254 1
a3254 1
  dm_vars = (char *)bu_malloc(sizeof(struct ogl_vars),
d3293 1
@


1.25
log
@check in Lee's changes
@
text
@d51 1
a53 1
#include "bu.h"
d179 1
a179 1
  struct rt_list l;
d382 1
a382 1
  RT_LIST_INIT( &head_ogl_vars.l );
d410 2
a411 2
  if(((struct ogl_vars *)dm_vars)->l.forw != RT_LIST_NULL)
    RT_LIST_DEQUEUE(&((struct ogl_vars *)dm_vars)->l);
d415 1
a415 1
  if(RT_LIST_IS_EMPTY(&head_ogl_vars.l))
d700 1
a700 1
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d1570 1
a1570 1
  if(RT_LIST_IS_EMPTY(&head_ogl_vars.l))
d1573 1
a1573 1
  RT_LIST_APPEND(&head_ogl_vars.l, &((struct ogl_vars *)curr_dm_list->_dm_vars)->l);
d2441 1
a2441 1
  for( RT_LIST_FOR(p, ogl_vars, &head_ogl_vars.l) ){
@


1.24
log
@structparse moved to libbu
@
text
@d2012 1
a2012 1
      bu_structprint("dm_ogl internal variables", Ogl_vparse, (CONST char *)&((struct ogl_vars *)dm_vars)->mvars );
d2014 1
a2014 1
      bu_vls_name_print( &vls, Ogl_vparse, argv[1], (CONST char *)&((struct ogl_vars *)dm_vars)->mvars );
d2020 1
a2020 1
      bu_structparse( &vls, Ogl_vparse, (char *)&((struct ogl_vars *)dm_vars)->mvars );
@


1.23
log
@move alt_mouse_mode to dm.h and call it _am_mode
@
text
@d53 1
d301 1
a301 1
struct structparse Ogl_vparse[] = {
d2012 1
a2012 1
      rt_structprint("dm_ogl internal variables", Ogl_vparse, (CONST char *)&((struct ogl_vars *)dm_vars)->mvars );
d2014 1
a2014 1
      rt_vls_name_print( &vls, Ogl_vparse, argv[1], (CONST char *)&((struct ogl_vars *)dm_vars)->mvars );
d2020 1
a2020 1
      rt_structparse( &vls, Ogl_vparse, (char *)&((struct ogl_vars *)dm_vars)->mvars );
@


1.22
log
@now using libbu
@
text
@a174 1
  int alt_mouse_mode;
a314 1
	{"%d",  1, "alt_mouse_mode",	Ogl_MV_O(alt_mouse_mode),FUNC_NULL },
d973 2
a974 3
    switch(((struct ogl_vars *)dm_vars)->mvars.alt_mouse_mode){
    case ALT_MOUSE_MODE_OFF:
    case ALT_MOUSE_MODE_ON:
d2087 1
a2087 1
	((struct ogl_vars *)dm_vars)->mvars.alt_mouse_mode = ALT_MOUSE_MODE_ROTATE;
d2090 1
a2090 1
	((struct ogl_vars *)dm_vars)->mvars.alt_mouse_mode = ALT_MOUSE_MODE_TRANSLATE;
d2106 1
a2106 1
	((struct ogl_vars *)dm_vars)->mvars.alt_mouse_mode = ALT_MOUSE_MODE_ZOOM;
d2114 1
a2114 1
      ((struct ogl_vars *)dm_vars)->mvars.alt_mouse_mode = ALT_MOUSE_MODE_ON;
a2429 1
  ((struct ogl_vars *)dm_vars)->mvars.alt_mouse_mode = 1;
@


1.21
log
@mostly cleanup,
map window last in Ogl_setup
@
text
@d414 1
a414 1
  rt_free(dm_vars, "Ogl_close: dm_vars");
d501 1
a501 1
    struct rt_vls tmp_vls;
d503 2
a504 2
    rt_vls_init(&tmp_vls);
    rt_vls_printf(&tmp_vls, "ANY ERRORS?\n");
d507 1
a507 1
      rt_vls_printf(&tmp_vls, "Error: %x\n", error);
d510 2
a511 2
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d537 1
a537 1
	  struct rt_vls tmp_vls;
d539 7
a545 7
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
	  rt_vls_printf(&tmp_vls, "newrot matrix = \n");
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);
d547 2
a548 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d880 1
a880 1
	  struct rt_vls tmp_vls;
d882 1
a882 1
	  rt_vls_init(&tmp_vls);
d884 5
a888 5
	  rt_vls_printf(&tmp_vls, "projection matrix:\n");
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
d890 5
a894 5
	  rt_vls_printf(&tmp_vls, "modelview matrix:\n");
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
d896 2
a897 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d922 1
a922 1
  struct rt_vls cmd;
d925 1
a925 1
  rt_vls_init(&cmd);
d946 1
a946 1
    rt_vls_free(&cmd);
d979 1
a979 1
	rt_vls_printf( &cmd, "M 1 %d %d\n", irisX2ged(mx), irisY2ged(my));
d983 1
a983 1
	rt_vls_printf( &cmd, "M 0 %d %d\n", irisX2ged(mx), irisY2ged(my));
d989 1
a989 1
      rt_vls_printf( &cmd, "iknob ax %f ay %f\n",
d1000 1
a1000 1
	  rt_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy);
d1004 1
a1004 1
	  rt_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy);
d1009 1
a1009 1
      rt_vls_printf( &cmd, "iknob aS %f\n",
d1041 1
a1041 1
	rt_vls_printf( &cmd, "knob ang1 %d\n",
d1055 1
a1055 1
	rt_vls_printf( &cmd , "knob S %f\n",
d1066 1
a1066 1
	rt_vls_printf( &cmd , "knob aS %f\n",
d1080 1
a1080 1
	rt_vls_printf( &cmd , "knob ang2 %d\n",
d1092 1
a1092 1
	  rt_vls_printf( &cmd , "knob z %f\n",
d1103 1
a1103 1
	  rt_vls_printf( &cmd , "knob az %f\n",
d1118 1
a1118 1
	rt_vls_printf( &cmd , "knob distadc %d\n",
d1130 1
a1130 1
	  rt_vls_printf( &cmd , "knob Z %f\n",
d1141 1
a1141 1
	  rt_vls_printf( &cmd , "knob aZ %f\n",
d1156 1
a1156 1
	rt_vls_printf( &cmd , "knob yadc %d\n",
d1168 1
a1168 1
	  rt_vls_printf( &cmd , "knob y %f\n",
d1179 1
a1179 1
	  rt_vls_printf( &cmd , "knob ay %f\n",
d1194 1
a1194 1
	rt_vls_printf( &cmd , "knob Y %f\n",
d1205 1
a1205 1
	rt_vls_printf( &cmd , "knob aY %f\n",
d1219 1
a1219 1
	rt_vls_printf( &cmd , "knob xadc %d\n",
d1231 1
a1231 1
	  rt_vls_printf( &cmd , "knob x %f\n",
d1242 1
a1242 1
	  rt_vls_printf( &cmd , "knob ax %f\n",
d1257 1
a1257 1
	rt_vls_printf( &cmd , "knob X %f\n",
d1268 1
a1268 1
	rt_vls_printf( &cmd , "knob aX %f\n",
d1294 1
a1294 1
      rt_vls_strcat(&cmd, "knob zero\n");
d1297 1
a1297 1
      rt_vls_printf(&cmd, "press %s\n",
d1315 1
a1315 1
  rt_vls_free(&cmd);
d1375 1
a1375 1
  struct rt_vls tmp_vls;
d1377 4
a1380 4
  rt_vls_init(&tmp_vls);
  rt_vls_printf(&tmp_vls, "Ogl_load(x%x, %d.)\n", addr, count );
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
d1559 1
a1559 1
  struct rt_vls str;
d1562 1
a1562 1
  rt_vls_init(&str);
d1577 1
a1577 1
  rt_vls_printf(&pathName, ".dm_ogl%d", count++);
d1584 1
a1584 1
    rt_vls_free(&str);
d1600 1
a1600 1
  xtkwin = Tk_CreateWindowFromPath(interp, tkwin, rt_vls_addr(&pathName), name);
d1604 1
a1604 1
    Tcl_AppendResult(interp, "dm-Ogl: Failed to open ", rt_vls_addr(&pathName),
d1609 2
a1610 2
  rt_vls_strcpy(&str, "init_ogl ");
  rt_vls_printf(&str, "%s\n", rt_vls_addr(&pathName));
d1613 1
a1613 1
    rt_vls_free(&str);
d1998 1
a1998 1
  struct rt_vls	vls;
d2006 1
a2006 1
    struct rt_vls tmp_vls;
d2008 2
a2009 2
    rt_vls_init(&vls);
    rt_vls_init(&tmp_vls);
d2017 1
a2017 1
      rt_log( "%s\n", rt_vls_addr(&vls) );
d2019 3
a2021 3
      rt_vls_printf( &vls, "%s=\"", argv[1] );
      rt_vls_from_argv( &vls, argc-2, argv+2 );
      rt_vls_putc( &vls, '\"' );
d2025 1
a2025 1
    rt_vls_free(&vls);
d2028 2
a2029 2
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d2058 2
a2059 2
    rt_vls_init(&vls);
    rt_vls_printf(&vls, "M %s %d %d\n", argv[2],
d2062 1
a2062 1
    rt_vls_free(&vls);
d2099 1
a2099 1
	  rt_vls_init(&vls);
d2102 1
a2102 1
	  rt_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
d2104 1
a2104 1
	  rt_vls_free(&vls);
d2194 1
a2194 1
  rt_vls_printf( &dm_values.dv_string,
d2217 1
a2217 1
    rt_vls_printf( &dm_values.dv_string,
d2416 1
a2416 1
  dm_vars = (char *)rt_malloc(sizeof(struct ogl_vars),
@


1.20
log
@changed VIRTUAL_TRACKBALL to ALT_MOUSE_MODE
@
text
@a46 2
/*XXXX*/
#if 1
a47 1
#endif
d416 2
a417 6
#if 0
	Tk_DeleteGenericHandler(Ogl_doevent, (ClientData)curr_dm_list);
#else
	if(RT_LIST_IS_EMPTY(&head_ogl_vars.l))
	  Tk_DeleteGenericHandler(Ogl_doevent, (ClientData)NULL);
#endif
a440 4
#if 0
  Ogl_configure_window_shape();
#endif

a953 3
#if 0
    Ogl_configure_window_shape();
#else
a958 1
#endif
d1016 3
a1018 1
  }else if( eventPtr->type == devmotionnotify ){
d1278 4
a1281 1
  }else if( eventPtr->type == devbuttonpress ){
d1308 3
a1310 1
  }else
d1672 1
d1679 2
d1685 1
a1698 9
#if 0
  /* Register the file descriptor with the Tk event handler */
  Tk_CreateGenericHandler(Ogl_doevent, (ClientData)curr_dm_list);
#endif

#if 0
  Tk_SetWindowBackground(xtkwin, bg);
#endif

a1709 2
  Tk_MapWindow(xtkwin);

d1742 1
d2409 1
a2409 4
  for(i = 0; i < 8; ++i){
#if 0
    knobs_offset[i] = knobs[i];
#else
a2410 2
#endif
  }
@


1.19
log
@-now using autoloading
-modified the translate/slew interface
@
text
@d178 1
a178 1
  int virtual_trackball;
d319 1
a319 1
	{"%d",  1, "virtual_trackball",	Ogl_MV_O(virtual_trackball),FUNC_NULL },
d990 3
a992 3
    switch(((struct ogl_vars *)dm_vars)->mvars.virtual_trackball){
    case VIRTUAL_TRACKBALL_OFF:
    case VIRTUAL_TRACKBALL_ON:
d1003 1
a1003 1
    case VIRTUAL_TRACKBALL_ROTATE:
d1007 1
a1007 1
    case VIRTUAL_TRACKBALL_TRANSLATE:
d1023 1
a1023 1
    case VIRTUAL_TRACKBALL_ZOOM:
d2047 1
a2047 1
  if( !strcmp( argv[0], "mouse" )){
d2051 2
a2052 2
      Tcl_AppendResult(interp, "dm mouse: need more parameters\n",
		       "dm mouse button 1|0 xpos ypos\n", (char *)NULL);
d2068 1
a2068 1
      Tcl_AppendResult(interp, "dm mouse: bad button value - ", argv[1], "\n", (char *)NULL);
a2084 11
  if(((struct ogl_vars *)dm_vars)->mvars.virtual_trackball){
    if( !strcmp( argv[0], "vtb" )){
      int buttonpress;

      scroll_active = 0;

      if( argc < 5){
	Tcl_AppendResult(interp, "dm: need more parameters\n",
			 "vtb <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
d2086 2
a2087 11
      buttonpress = atoi(argv[2]);
      omx = atoi(argv[3]);
      omy = atoi(argv[4]);

      if(buttonpress){
	switch(*argv[1]){
	case 'r':
	  ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ROTATE;
	  break;
	case 't':
	  ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_TRANSLATE;
d2089 1
a2089 11
	  if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	     (edobj || es_edflag > 0)){
	    fastf_t fx, fy;

	    rt_vls_init(&vls);
	    fx = (omx/(fastf_t)((struct ogl_vars *)dm_vars)->width - 0.5) * 2;
	    fy = (0.5 - omy/(fastf_t)((struct ogl_vars *)dm_vars)->height) * 2;
	    rt_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	    (void)cmdline(&vls, FALSE);
	    rt_vls_free(&vls);
	  }
d2091 4
a2094 11
	  break;
	case 'z':
	  ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ZOOM;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm: need more parameters\n",
			   "vtb <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
	}
      }else{
	((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ON;
d2097 35
a2131 1
    return status;
d2133 1
a2133 1
  }else{
d2246 1
a2246 1
establish_vtb()
d2452 1
a2452 1
  ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = 1;
@


1.18
log
@ calling gui_setup to initalize tk stuff
@
text
@a43 1
#include "./oglinit.h"
d60 1
d82 1
a82 1
static int      Ogl_load_startup();
d380 1
a380 1
int
a382 3
  FILE    *fp;
  struct rt_vls str;
  char *path;
a384 3
/*XXX*/
#define DM_OGL_RCFILE "oglinit.tk"

d388 2
a389 41
  /* Start with internal default */
  Tcl_Eval( interp, ogl_init_str );

  rt_vls_init( &str );

  if((filename = getenv("DM_OGL_RCFILE")) == (char *)NULL )
    /* Use default file name */
    filename = DM_OGL_RCFILE;

  if((path = getenv("MGED_LIBRARY")) != (char *)NULL ){
    /* Use MGED_LIBRARY path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL ) {
      fclose(fp);
      (void)Tcl_EvalFile( interp, rt_vls_addr(&str) );
    }
  }

  if( (path = getenv("HOME")) != (char *)NULL )  {
    /* Use HOME path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );
    
    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL ){
      fclose(fp);
      (void)Tcl_EvalFile( interp, rt_vls_addr(&str) );
    }
  }

  /* Check current directory */
  if( (fp = fopen( filename, "r" )) != NULL )  {
    fclose(fp);
    (void)Tcl_EvalFile( interp, filename );
  }

  rt_vls_free(&str);
  return 0;
d1011 10
a1020 3
	fx = (mx/(fastf_t)((struct ogl_vars *)dm_vars)->width - 0.5) * 2;
	fy = (0.5 - my/(fastf_t)((struct ogl_vars *)dm_vars)->height) * 2;
	rt_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy);
d1025 1
a1025 1
		     (omy - my)/(double)((struct ogl_vars *)dm_vars)->height);
d1573 1
a1573 2
  if(tkwin == NULL){
#if 1
a1574 9
#else
    rt_vls_printf(&str, "loadtk %s\n", name);

    if(cmdline(&str, FALSE) == CMD_BAD){
      rt_vls_free(&str);
      return -1;
    }
#endif
  }
d1577 2
a1578 6
  if(!count){
    if( Ogl_load_startup() ){
      rt_vls_free(&str);
      return -1;
    }
  }
d2108 3
a2110 1
	  {
@


1.17
log
@handling knobs differently
@
text
@d1612 3
d1621 1
@


1.16
log
@using multiple command capability of knob
@
text
@d241 1
a1080 3
    setting = M->axis_data[0] - knob_values[M->first_axis];
    knob_values[M->first_axis] = M->axis_data[0];

d1084 9
a1092 1
	rt_vls_printf( &cmd, "iknob ang1 %d\n",
d1097 21
a1117 5
      if(mged_variables.rateknobs)
	rt_vls_printf( &cmd , "iknob S %f\n",
		       setting / 2048.0 );
      else
	rt_vls_printf( &cmd , "iknob aS %f\n",
d1119 1
d1122 10
a1131 2
      if(mged_variables.adcflag)
	rt_vls_printf( &cmd , "iknob ang2 %d\n",
d1133 22
a1154 6
      else {
	if(mged_variables.rateknobs)
	  rt_vls_printf( &cmd , "iknob z %f\n",
		      setting / 2048.0 );
	else
	  rt_vls_printf( &cmd , "iknob az %f\n",
d1156 1
d1160 10
a1169 2
      if(mged_variables.adcflag)
	rt_vls_printf( &cmd , "iknob distadc %d\n",
d1171 22
a1192 6
      else {
	if(mged_variables.rateknobs)
	  rt_vls_printf( &cmd , "iknob Z %f\n",
			 setting / 2048.0 );
	else
	  rt_vls_printf( &cmd , "iknob aZ %f\n",
d1194 1
d1198 10
a1207 2
      if(mged_variables.adcflag)
	rt_vls_printf( &cmd , "iknob yadc %d\n",
d1209 22
a1230 6
      else{
	if(mged_variables.rateknobs)
	  rt_vls_printf( &cmd , "iknob y %f\n",
			 setting / 2048.0 );
	else
	  rt_vls_printf( &cmd , "iknob ay %f\n",
d1232 1
d1236 21
a1256 5
      if(mged_variables.rateknobs)
	rt_vls_printf( &cmd , "iknob Y %f\n",
		       setting / 2048.0 );
      else
	rt_vls_printf( &cmd , "iknob aY %f\n",
d1258 1
d1261 10
a1270 2
      if(mged_variables.adcflag)
	rt_vls_printf( &cmd , "iknob xadc %d\n",
d1272 22
a1293 6
      else{
	if(mged_variables.rateknobs)
	  rt_vls_printf( &cmd , "iknob x %f\n",
			 setting / 2048.0 );
	else
	  rt_vls_printf( &cmd , "iknob ax %f\n",
d1295 1
d1299 21
a1319 5
      if(mged_variables.rateknobs)
	rt_vls_printf( &cmd , "iknob X %f\n",
		       setting / 2048.0 );
      else
	rt_vls_printf( &cmd , "iknob aX %f\n",
d1321 1
d1327 2
d2358 2
a2359 2
static 
int irlimit(i)
d2362 16
a2377 5
	if( i > NOISE )
		return( i-NOISE );
	if( i < -NOISE )
		return( i+NOISE );
	return(0);
@


1.15
log
@*** empty log message ***
@
text
@d1048 1
a1048 1
      rt_vls_printf( &cmd, "iknob ax %f; iknob ay %f\n",
d1057 1
a1057 17

#if 0
	if(fx > 0.000001)
	  fx += SL_TOL;
	else if(fx < 0.000001)
	  fx += -SL_TOL;
	else
	  fx = 0.0;

	if(fy > 0.000001)
	  fy += SL_TOL;
	else if(fy < 0.000001)
	  fy += -SL_TOL;
	else
	  fy = 0.0;
#endif
	rt_vls_printf( &cmd, "knob aX %f; knob aY %f\n", fx, fy );
d1061 2
a1062 2
      rt_vls_printf( &cmd, "zoom %lf\n",
		     (omy - my)/(double)((struct ogl_vars *)dm_vars)->height + 1.0);
d1076 1
a1076 1
		(adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
d1085 1
a1085 1
      if(adcflag) {
d1091 6
a1096 2
      rt_vls_printf( &cmd , "iknob S %f\n",
		    setting / 2048.0 );
d1099 1
a1099 1
      if(adcflag)
d1112 1
a1112 1
      if(adcflag)
d1125 1
a1125 1
      if(adcflag)
d1146 1
a1146 1
      if(adcflag)
d2003 1
a2003 17

#if 0
	    if(fx > 0.000001)
	      fx += SL_TOL;
	    else if(fx < 0.000001)
	      fx += -SL_TOL;
	    else
	      fx = 0.0;

	    if(fy > 0.000001)
	      fy += SL_TOL;
	    else if(fy < 0.000001)
	      fy += -SL_TOL;
	    else
	      fy = 0.0;
#endif
	    rt_vls_printf( &vls, "knob aX %f; knob aY %f\n", fx, fy);
@


1.14
log
@now loading all resource files.
@
text
@d999 1
a999 24
#if 0
    /* drawing window is being aimed at by a Tcl/Tk command window */
    if(curr_dm_list->aim &&
       strcmp(rt_vls_addr(&curr_dm_list->aim->name), "mged")){
#if 1
      /* This doesn't work because Tk ignores key events if the
	 text window we're sending to doesn't have the focus which defeats
	 the purpose. */
      Status status;
#if 1
      eventPtr->xkey.window = (Window)(curr_dm_list->aim->id);
      eventPtr->xkey.display = (Display *)(curr_dm_list->aim->sp);
#endif
      status = XSendEvent((Display *)(curr_dm_list->aim->sp), (Window)(curr_dm_list->aim->id),
		 True, KeyPressMask, eventPtr);
#else
      /* This doesn't properly handle control sequences or even \r */
      buffer[1] = '\0';
      rt_vls_printf(&cmd, "insert_text %s %s\n", curr_dm_list->aim->name, buffer);
      (void)cmdline(&cmd, FALSE);
#endif
    }else
#endif
      write(dm_pipe[1], buffer, 1);
a1030 6
#if 0
    if( !OgldoMotion &&
	(VIRTUAL_TRACKBALL_NOT_ACTIVE(struct ogl_vars *, mvars.virtual_trackball)) )
      goto end;
#endif

a1047 11
#if 0
      absolute_rotate[Y] += (mx - omx)/512.0;

      /* wrap around */
      if(absolute_rotate[Y] < -1.0)
	absolute_rotate[Y] = absolute_rotate[Y] + 2.0;
      else if(absolute_rotate[Y] > 1.0)
	absolute_rotate[Y] = absolute_rotate[Y] - 2.0;

      rt_vls_printf( &cmd, "iknob ax %f\n", (my - omy)/512.0);
#else
a1049 1
#endif
d1058 1
a1065 9
#if 1
	if( fy < -1.0 )
	  fy = -1.0;
	else if( fy > 1.0 )
	  fy = 1.0;
	
	absolute_slew[Y] = fy;
	rt_vls_printf( &cmd, "knob aX %f\n", fx);
#else
d1072 1
a1072 1

a1073 1
#endif
a2008 1
#if 1
d2016 1
a2023 9
#if 1
	    if( fy < -1.0 )
	      fy = -1.0;
	    else if( fy > 1.0 )
	      fy = 1.0;

	    absolute_slew[Y] = fy;
	    rt_vls_printf( &vls, "knob aX %f\n", fx);
#else
d2030 1
a2030 1

a2031 1
#endif
d2035 1
a2035 10
#else
	  sprintf(xstr, "%f", (omx/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - omy/(double)((struct ogl_vars *)dm_vars)->height) * 2);
	  sprintf(zstr, "%f", tran_z);
	  av[0] = "tran";
	  av[1] = xstr;
	  av[2] = ystr;
	  av[3] = zstr;
	  status = f_tran((ClientData)NULL, interp, 4, av);
#endif
@


1.13
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@a385 1
  int     found;
a389 1
#if 1
d392 3
a394 1
#endif
a395 1
  found = 0;
d408 3
a410 13
    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
  }

  if(!found){
    if( (path = getenv("HOME")) != (char *)NULL )  {
      /* Use HOME path */
      rt_vls_strcpy( &str, path );
      rt_vls_strcat( &str, "/" );
      rt_vls_strcat( &str, filename );

      if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
	found = 1;
d414 9
a422 5
  if( !found ) {
    /* Check current directory */
    if( (fp = fopen( filename, "r" )) != NULL )  {
      rt_vls_strcpy( &str, filename );
      found = 1;
d426 4
a429 15
  if(!found){
    rt_vls_free(&str);

    /* Using default */
    if(Tcl_Eval( interp, ogl_init_str ) == TCL_ERROR)
      return -1;

    return 0;
  }

  fclose( fp );

  if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
    rt_vls_free(&str);
    return -1;
a964 2


d988 1
d990 1
a990 1
    char buffer[1];
d999 25
a1023 1
    write(dm_pipe[1], buffer, 1);
d1077 11
d1090 1
d1106 9
d1123 1
d2074 9
d2091 1
@


1.12
log
@modifying sliders
@
text
@a993 1
  static int knobs_during_help[8] = {0, 0, 0, 0, 0, 0, 0, 0};
d1072 2
a1073 2
      rt_vls_printf( &cmd, "irot %f %f 0\n", (my - omy)/2.0,
		     (mx - omx)/2.0);
d1076 22
a1097 3
      rt_vls_printf( &cmd, "tran %f %f %f\n",
		     (mx/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 2,
		     (0.5 - my/(double)((struct ogl_vars *)dm_vars)->height) * 2, tran_z);
d1119 1
a1119 2
    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
    setting = irlimit(knobs[M->first_axis]);
d1125 1
a1125 1
	rt_vls_printf( &cmd, "knob ang1 %d\n",
d1130 1
a1130 1
      rt_vls_printf( &cmd , "knob S %f\n",
d1135 1
a1135 1
	rt_vls_printf( &cmd , "knob ang2 %d\n",
d1137 3
a1139 2
      else
	rt_vls_printf( &cmd , "knob z %f\n",
d1141 4
d1148 1
a1148 1
	rt_vls_printf( &cmd , "knob distadc %d\n",
d1150 8
a1157 3
      else
	rt_vls_printf( &cmd , "knob Z %f\n",
		      setting / 2048.0 );
d1161 1
a1161 1
	rt_vls_printf( &cmd , "knob yadc %d\n",
d1163 8
a1170 3
      else
	rt_vls_printf( &cmd , "knob y %f\n",
		      setting / 2048.0 );
d1173 6
a1178 2
      rt_vls_printf( &cmd , "knob Y %f\n",
		    setting / 2048.0 );
d1182 1
a1182 1
	rt_vls_printf( &cmd , "knob xadc %d\n",
d1184 8
a1191 3
      else
	rt_vls_printf( &cmd , "knob x %f\n",
		      setting / 2048.0 );
d1194 6
a1199 2
      rt_vls_printf( &cmd , "knob X %f\n",
		    setting / 2048.0 );
d2032 27
a2058 1

d2067 1
a2067 1
	  
@


1.11
log
@Still Tcl'ing the code
@
text
@a67 3
extern int dm_pipe[];

extern Tcl_Interp *interp;
d143 1
d189 1
a986 8
#define Ogl_NUM_SLID	7
#define Ogl_XSLEW	0
#define Ogl_YSLEW	1
#define Ogl_ZSLEW	2
#define Ogl_ZOOM	3
#define Ogl_XROT	4
#define Ogl_YROT	5
#define Ogl_ZROT	6
d1050 1
d1054 1
d1062 9
a1070 3
      /* do the regular thing */
      /* Constant tracking (e.g. illuminate mode) bound to M mouse */
      rt_vls_printf( &cmd, "M 0 %d %d\n", irisX2ged(mx), irisY2ged(my));
d1927 21
a1947 3
    if( argc < 4){
      Tcl_AppendResult(interp, "dm: need more parameters\n",
		       "mouse 1|0 xpos ypos\n", (char *)NULL);
d1952 2
a1953 2
    rt_vls_printf(&vls, "M %s %d %d\n", argv[1],
		  irisX2ged(atoi(argv[2])), irisY2ged(atoi(argv[3])));
d1967 2
@


1.10
log
@actions wrt X events are now handled via Tcl/Tk bind command
with the exception of Expose, Configure
-added support for dials+buttons
-generalized so that multiple instances of this display manager
  can be open at the same time
-added mouse and vtb options to Ogl_dm
etc.
@
text
@d1071 1
a1071 3
      rt_vls_printf( &cmd, "M 0 %d %d\n",
		     (mx/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 4095,
		     (0.5 - my/(double)((struct ogl_vars *)dm_vars)->height) * 4095);
a1908 1
      rt_log("%s", rt_vls_addr(&vls) );
a1933 10
#if 0
    sprintf(xstr, "%d", irisX2ged(atoi(argv[2])));
    sprintf(ystr, "%d", irisY2ged(atoi(argv[3])));

    av[0] = "M";
    av[1] = argv[1];
    av[2] = xstr;
    av[3] = ystr;
    return f_mouse((ClientData)NULL, interp, 4, av);
#else
a1943 1
#endif
@


1.9
log
@changed rgba flag
@
text
@d1 1
a1 1
 /*
a14 2
#define CJDEBUG 0

d42 3
d48 4
a51 1

d68 13
a80 1
static int	Ogl_xsetup();
d82 1
a82 1
static int	Ogldoevent();
d84 8
d93 2
a94 2
/* Flags indicating whether the gl and sgi display managers have been
 * attached. 
d98 3
a100 3
char	ogl_ogl_used = 0;
char	ogl_sgi_used = 0;
char	ogl_is_direct = 0;
a102 1

d135 1
a135 1
	"gl", "X Windows with OpenGL graphics",
d142 40
a181 53
static GLXContext glxc;
/*static Window wind;*/
static int ogl_has_dbfr;
static int ogl_depth_size;
static int ogl_has_rgb;
static int ogl_has_stereo;
static int ogl_index_size;
static Colormap cmap;

static int fontOffset;
static XVisualInfo *ogl_set_visual();

static GLdouble faceplate_mat[16];
static int ogl_face_flag;		/* 1: faceplate matrix on stack */

/*
 * These variables are visible and modifiable via a "dm set" command.
 */
static int	cueing_on = 1;		/* Depth cueing flag - for colormap work */
static int	zclipping_on = 1;	/* Z Clipping flag */
static int	zbuffer_on = 1;		/* Hardware Z buffer is on */
static int	lighting_on = 0;	/* Lighting model on */
static int	ogl_debug;		/* 2 for basic, 3 for full */
static int	no_faceplate = 0;	/* Don't draw faceplate */
static int	ogl_linewidth = 1;	/* Line drawing width */
static int	ogl_fastfog = 1;	/* 1 -> fast, 0 -> quality */
static double	ogl_fogdensity = 1.0;	/* Fog density parameter */
/*
 * These are derived from the hardware inventory -- user can change them,
 * but the results may not be pleasing.  Mostly, this allows them to be seen.
 */
static int	ogl_is_gt;		/* 0 for non-GT machines */
static int	ogl_has_zbuf;		/* 0 if no Z buffer */
static int	ogl_has_rgb;		/* 0 if mapped mode must be used */
static int	ogl_has_doublebuffer;	/* 0 if singlebuffer mode must be used */


/* End modifiable variables */

static int	ogl_fd;			/* GL file descriptor to select() on */
static CONST char ogl_title[] = "BRL MGED";
static int perspective_mode = 0;	/* Perspective flag */
static int perspective_angle =3;	/* GLfloat of perspective */
static int perspective_table[] = {
	30, 45, 60, 90 };
static int ovec = -1;		/* Old color map entry number */
static int kblights();
static double	xlim_view = 1.0;	/* args for glOrtho*/
static double	ylim_view = 1.0;
static mat_t	aspect_corr;
static int	stereo_is_on = 0;

void		ogl_colorit();
d183 25
d211 3
a213 4
#define NSLOTS		4080	/* The mostest possible - may be fewer */
static int ogl_nslots=0;		/* how many we have, <= NSLOTS */
static int slotsused;		/* how many actually used */
static struct rgbtab {
d217 22
a238 1
} ogl_rgbtab[NSLOTS];
d240 19
a258 1
extern struct device_values dm_values;	/* values read from devices */
d260 5
a264 1
extern void sl_toggle_scroll();		/* from scroll.c */
d266 1
a266 2
static void	establish_lighting();
static void	establish_zbuffer();
a281 3
void print_cmap();


d291 1
a291 1
	glLineWidth((GLfloat) ogl_linewidth);
d299 1
a299 1
	glHint(GL_FOG_HINT, ogl_fastfog ? GL_FASTEST : GL_NICEST);
d303 1
d305 16
a320 26
	{
		"%d",  1, "depthcue",		(int)&cueing_on,	Ogl_colorchange 	},
	{
		"%d",  1, "zclip",		(int)&zclipping_on,	refresh_hook 	}, /* doesn't seem to have any use*/
	{
		"%d",  1, "zbuffer",		(int)&zbuffer_on,	establish_zbuffer 	},
	{
		"%d",  1, "lighting",		(int)&lighting_on,	establish_lighting 	},
	{
		"%d",  1, "no_faceplate",	(int)&no_faceplate,	refresh_hook 	},
	{
		"%d",  1, "has_zbuf",		(int)&ogl_has_zbuf,	refresh_hook 	},
	{
		"%d",  1, "has_rgb",		(int)&ogl_has_rgb,	Ogl_colorchange 	},
	{
		"%d",  1, "has_doublebuffer",	(int)&ogl_has_doublebuffer, refresh_hook 	},
	{
		"%d",  1, "debug",		(int)&ogl_debug,		FUNC_NULL 	},
	{
		"%d",  1, "linewidth",		(int)&ogl_linewidth,	do_linewidth 	},
	{
		"%f",   1, "density",		(int)&ogl_fogdensity,  refresh	},
	{
		"%d",   1, "fastfog",		(int)&ogl_fastfog,  do_fog	},
	{
		"",	0,  (char *)0,		0,			FUNC_NULL 	}
a322 2
/*int ogl_winx_size, ogl_winy_size;*/

a325 3
static int height, width;
static Tcl_Interp *xinterp;
static Tk_Window xtkwin;
a327 9
static Display	*dpy;			/* X display pointer */
static Window	win;			/* X window */
static unsigned long black,gray,white,yellow,red,blue;
static unsigned long bd, bg, fg;   /*color of border, background, foreground */

static GC	gc;			/* X Graphics Context */
static int	is_monochrome = 0;
static XFontStruct *fontstruct;		/* X Font */

d333 2
a334 2
#define	GED_TO_Xx(x)	(((x)/4096.0+0.5)*width)
#define	GED_TO_Xy(x)	((0.5-(x)/4096.0)*height)
d337 1
a337 1
#define USE_RAMP	(cueing_on || lighting_on)
d346 18
d374 76
a449 29
        char	line[82];
        char	hostname[80];
	char	display[82];
	char	*envp;

	ogl_debug = CJDEBUG;

	/* get or create the default display */
	if( (envp = getenv("DISPLAY")) == NULL ) {
		/* Env not set, use local host */
		gethostname( hostname, 80 );
		hostname[79] = '\0';
		(void)sprintf( display, "%s:0", hostname );
		envp = display;
	}

	rt_log("X Display [%s]? ", envp );
	(void)fgets( line, sizeof(line), stdin );
	line[strlen(line)-1] = '\0';		/* remove newline */
	if( feof(stdin) )  quit();
	if( line[0] != '\0' ) {
		if( Ogl_xsetup(line) ) {
			return(1);		/* BAD */
		}
	} else {
		if( Ogl_xsetup(envp) ) {
			return(1);	/* BAD */
		}
	}
d451 2
a452 1
	return(0);			/* OK */
d463 13
a475 4
	glDrawBuffer(GL_FRONT);
	glClearColor(0.0, 0.0, 0.0, 0.0);
/*	glClearDepth(0.0);*/
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
d477 2
a478 1
	glXMakeCurrent(dpy, None, NULL);
d480 1
a480 1
	glXDestroyContext(dpy, glxc);
d482 6
a487 3
	Tk_DeleteGenericHandler(Ogldoevent, (ClientData)NULL);
	Tk_DestroyWindow(xtkwin);
	Tcl_DeleteInterp(xinterp);
d498 4
a501 14
	GLint mm; 
	char i;
	char *str = "a";
	GLfloat fogdepth;

	if (ogl_debug)
		rt_log( "Ogl_prolog\n");

	if (dmaflag) {
		if (!ogl_has_doublebuffer){
			glClearColor(0.0, 0.0, 0.0, 0.0);
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
/*			return;*/
		}
d503 2
a504 20
		if (ogl_face_flag){
			glMatrixMode(GL_PROJECTION);
			glPopMatrix();
			glMatrixMode(GL_MODELVIEW);
			glPopMatrix();
			ogl_face_flag = 0;
			if (cueing_on){
				glEnable(GL_FOG);
				fogdepth = 2.2 * Viewscale; /* 2.2 is heuristic */
				glFogf(GL_FOG_END, fogdepth);
				fogdepth = (GLfloat) (0.5*ogl_fogdensity/Viewscale);
				glFogf(GL_FOG_DENSITY, fogdepth);
				glFogi(GL_FOG_MODE, perspective_mode ? GL_EXP : GL_LINEAR);
			}
			if (lighting_on){
				glEnable(GL_LIGHTING);
			}
		}
	
		glLineWidth((GLfloat) ogl_linewidth);
d506 4
a509 1
	}
d511 3
d515 26
d549 2
a550 12
	if (ogl_debug)
		rt_log( "ogl_epilog\n");
	/*
	 * A Point, in the Center of the Screen.
	 * This is drawn last, to always come out on top.
	 */

	glColor3ub( (short)ogl_rgbtab[4].r, (short)ogl_rgbtab[4].g, (short)ogl_rgbtab[4].b );
	glBegin(GL_POINTS);
	 glVertex2i(0,0);
	glEnd();
	/* end of faceplate */
d552 24
a575 6
	if(ogl_has_doublebuffer )
	{
		glXSwapBuffers(dpy, win);
		/* give Graphics pipe time to work */
		glClearColor(0.0, 0.0, 0.0, 0.0);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
d577 2
a578 1
	}
d580 3
a582 6

	/* Prevent lag between events and updates */
	XSync(dpy, 0);

	if(CJDEBUG){
		int error;
d584 3
a586 6
		rt_log("ANY ERRORS?\n");
		while(	(error = glGetError())!=0){
			rt_log("Error: %x\n", error);
		}
	}

d588 1
a588 1
	return;
d606 14
d621 2
a622 7
	if(CJDEBUG){
		printf("which eye = %d\t", which_eye);
		printf("newrot matrix = \n");
		printf("%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
		printf("%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
		printf("%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
		printf("%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);
a624 3

	if (ogl_debug)
		rt_log( "Ogl_newrot()\n");
d644 9
a652 9
	gtmat[0] = *(mptr++) * aspect_corr[0];
	gtmat[4] = *(mptr++) * aspect_corr[0];
	gtmat[8] = *(mptr++) * aspect_corr[0];
	gtmat[12] = *(mptr++) * aspect_corr[0];

	gtmat[1] = *(mptr++) * aspect_corr[5];
	gtmat[5] = *(mptr++) * aspect_corr[5];
	gtmat[9] = *(mptr++) * aspect_corr[5];
	gtmat[13] = *(mptr++) * aspect_corr[5];
a663 80

	/* If all the display managers end up doing this maybe it's 
	 * dozoom that has a bug */
	gtmat[2]  = -gtmat[2];
	gtmat[6]  = -gtmat[6];
	gtmat[10]  = -gtmat[10];
	gtmat[14]  = -gtmat[14];

	/* we know that mat = P*T*M
	 *	where 	P = the perspective matrix based on the
	 *			eye at the origin
	 *		T = a translation of one in the -Z direction
	 *		M = model2view matrix
	 *
	 * Therefore P = mat*M'*T'
	 * 
	 * In order for depthcueing and lighting to work correctly, 
	 * P must be stored in the GL_PROJECTION matrix and T*M must
	 * be stored the the GL_MODELVIEW matrix.
	 */
	if ( perspective_mode){
		float inv_view[16];

		/* disassemble supplied matrix */

		/* convert from row-major to column-major and from double
		 * to float
		 */
		inv_view[0] = view2model[0];
		inv_view[1] = view2model[4];
		inv_view[2] = view2model[8];
		inv_view[3] = view2model[12];
		inv_view[4] = view2model[1];
		inv_view[5] = view2model[5];
		inv_view[6] = view2model[9];
		inv_view[7] = view2model[13];
		inv_view[8] = view2model[2];
		inv_view[9] = view2model[6];
		inv_view[10] = view2model[10];
		inv_view[11] = view2model[14];
		inv_view[12] = view2model[3];
		inv_view[13] = view2model[7];
		inv_view[14] = view2model[11];
		inv_view[15] = view2model[15];

		/* do P = P*T*M*M'*T' = mat*M'*T' (see explanation above) */
		glMatrixMode(GL_PROJECTION);
		glLoadMatrixf( gtmat );
		glMultMatrixf( inv_view );
		glTranslatef( 0.0, 0.0, 1.0);

	} else {
		/* Orthographic projection */
		glMatrixMode(	GL_PROJECTION);
		glLoadMatrixd( faceplate_mat);

	}


	/* convert from row-major to column-major and from double
	 * to float
	 */
	view[0] = model2view[0];
	view[1] = model2view[4];
	view[2] = model2view[8];
	view[3] = model2view[12];
	view[4] = model2view[1];
	view[5] = model2view[5];
	view[6] = model2view[9];
	view[7] = model2view[13];
	view[8] = model2view[2];
	view[9] = model2view[6];
	view[10] = model2view[10];
	view[11] = model2view[14];
	view[12] = model2view[3];
	view[13] = model2view[7];
	view[14] = model2view[11];
	view[15] = model2view[15];

	/* do T*M (see above explanation) */
d667 1
a667 2
	glMultMatrixf( view );

d670 1
a670 1
	if (lighting_on ){
a676 15


	if(CJDEBUG){
		GLfloat pmat[16];
		int mode;

		glGetIntegerv(GL_MATRIX_MODE, &mode);
		printf("matrix mode %s\n", (mode==GL_MODELVIEW) ? "modelview" : "projection");
		glGetFloatv(GL_MODELVIEW_MATRIX, pmat);
		printf("%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
		printf("%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
		printf("%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
		printf("%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
	}

d707 2
a708 2
	if (ogl_debug)
		rt_log( "Ogl_Object()\n");
a709 1

d722 1
a722 1
	if (white_flag && cueing_on)
d725 1
a725 1
	if( ogl_has_rgb )  {
d735 1
a735 1
		if(lighting_on)
d764 1
a764 1
		if (lighting_on){
d830 1
a830 1
	if (white_flag && cueing_on){
d850 2
a851 2
	if (ogl_debug)
		rt_log( "Ogl_normal\n");
d853 1
a853 1
	if( ogl_has_rgb )  {
d860 1
a860 1
	if (!ogl_face_flag){
d863 1
a863 1
		glLoadMatrixd( faceplate_mat );
d867 2
a868 2
		ogl_face_flag = 1;
		if(cueing_on)
d870 1
a870 1
		if (lighting_on)
d886 2
a887 2
	if (ogl_debug)
		rt_log( "Ogl_update()\n");
d904 2
a905 2
	if (ogl_debug)
		rt_log( "Ogl_puts()\n");
d909 1
a909 1
	if( ogl_has_rgb )  {
d916 1
d936 2
a937 2
	if (ogl_debug)
		rt_log( "Ogl_2d_line()\n");
d939 1
a939 1
	if( ogl_has_rgb )  {
d952 17
a968 14
	if(CJDEBUG){
		GLfloat pmat[16];
		glGetFloatv(GL_PROJECTION_MATRIX, pmat);
		printf("projection matrix:");
		printf("%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
		printf("%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
		printf("%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
		printf("%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
		glGetFloatv(GL_MODELVIEW_MATRIX, pmat);
		printf("modelview matrix:");
		printf("%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
		printf("%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
		printf("%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
		printf("%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
d970 2
d973 1
d988 8
a995 8
#define OGL_NUM_SLID	7
#define OGL_XSLEW	0
#define OGL_YSLEW	1
#define OGL_ZSLEW	2
#define OGL_ZOOM	3
#define OGL_XROT	4
#define OGL_YROT	5
#define OGL_ZROT	6
d997 2
a998 2
int
Ogldoevent(clientData, eventPtr)
d1002 160
a1161 71
    KeySym key;
    char keybuf[4];
    int cnt;
	float inc;
    XComposeStatus compose_stat;
	static int ogl_which_slid = OGL_XSLEW;

    if (eventPtr->xany.window != win)
	return 0;

    if (eventPtr->type == Expose ) {
	if (eventPtr->xexpose.count == 0) {
		glClearColor(0.0, 0.0, 0.0, 0.0);
		if (ogl_has_zbuf)
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		else
			glClear(GL_COLOR_BUFFER_BIT);
	    rt_vls_printf( &dm_values.dv_string, "refresh\n" );
		dmaflag = 1;
	}
    } else if( eventPtr->type == ConfigureNotify) {
    	Ogl_configure_window_shape();
    } else if( eventPtr->type == MotionNotify ) {
	int	x, y;
	if ( !OgldoMotion )
	    return 1;
	x = (eventPtr->xmotion.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xmotion.y/(double)height) * 4095;
	rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y );
    } else if( eventPtr->type == ButtonPress ) {
	/* There may also be ButtonRelease events */
	int	x, y;
	/* In MGED this is a "penpress" */
	x = (eventPtr->xbutton.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xbutton.y/(double)height) * 4095;
	switch( eventPtr->xbutton.button ) {
	case Button1:
	    /* Left mouse: Zoom out */
	    rt_vls_printf( &dm_values.dv_string, "L 1 %d %d\n", x, y);
	    break;
	case Button2:
	    /* Middle mouse, up to down transition */
	    rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n", x, y);
	    break;
	case Button3:
	    /* Right mouse: Zoom in */
	    rt_vls_printf( &dm_values.dv_string, "R 1 %d %d\n", x, y);
	    break;
	}
    } else if( eventPtr->type == ButtonRelease ) {
	int	x, y;
	x = (eventPtr->xbutton.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xbutton.y/(double)height) * 4095;
	switch( eventPtr->xbutton.button ) {
	case Button1:
	    rt_vls_printf( &dm_values.dv_string, "L 0 %d %d\n", x, y);
	    break;
	case Button2:
	    /* Middle mouse, down to up transition */
	    rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y);
	    break;
	case Button3:
	    rt_vls_printf( &dm_values.dv_string, "R 0 %d %d\n", x, y);
	    break;
	}
    } else if( eventPtr->type == KeyPress ) {
	register int i;
	/* Turn these into MGED "buttonpress" or knob functions */
	
	cnt = XLookupString(&eventPtr->xkey, keybuf, sizeof(keybuf),
			    &key, &compose_stat);
d1163 2
a1164 2
    	/* CJXX I think the following line is bad in X.c*/
/*	for(i=0 ; i < cnt ; i++){*/
d1166 1
a1166 200
	inc = 0.1;		
	switch( key ) {
	case '?':
		rt_log( "\n\t\tKey Help Menu:\n\
\n\tView Control Functions\n\
0, <F12>	Zero sliders (knobs)\n\
s		Toggle sliders\n\
x		Enable xrot slider\n\
y		Enable yrot slider\n\
z		Enable zrot slider\n\
X		Enable Xslew slider\n\
Y		Enable Yslew slider\n\
Z		Enable Zslew slider\n\
S		Enable Zoom (Scale) slider\n\
<Up Arrow>	Enable slider above the current slider\n\
<Down Arrow>	Enable slider below the current slider\n\
<Left Arrow>	Move enabled slider to the left (decrement)\n\
<Right Arrow>	Move enabled slider to the right (increment)\n\
f		Front view\n\
t		Top view\n\
b		Bottom view\n\
l		Left view\n\
r		Right view\n\
R		Rear view\n\
3		35,25 view\n\
4		45,45 view\n\
\n\tToggle Functions\n\
<F1>		Toggle depthcueing\n\
<F2>		Toggle zclipping\n\
<F3>		Toggle perspective\n\
<F4>		Toggle zbuffer status\n\
<F5>		Toggle smooth-shading\n\
<F6>		Change perspective angle\n\
<F7>,F		Toggle faceplate\n\
" );
		break;
	case 'w':
		print_cmap();
		break;
	case '0':
		rt_vls_printf( &dm_values.dv_string, "knob zero\n" );
		break;
	case 's':
		sl_toggle_scroll(); /* calls rt_vls_printf() */
		break;
	case 'S':
		ogl_which_slid = OGL_ZOOM;
		break;
	case 'x':
		/* 6 degrees per unit */
		ogl_which_slid = OGL_XROT;
		break;
	case 'y':
		ogl_which_slid = OGL_YROT;
		break;
	case 'z':
		ogl_which_slid = OGL_ZROT;
		break;
	case 'X':
		ogl_which_slid = OGL_XSLEW;
		break;
	case 'Y':
		ogl_which_slid = OGL_YSLEW;
		break;
	case 'Z':
		ogl_which_slid = OGL_ZSLEW;
		break;
	case 'f':
		rt_vls_strcat( &dm_values.dv_string, "press front\n");
		break;
	case 't':
		rt_vls_strcat( &dm_values.dv_string, "press top\n");
		break;
	case 'b':
		rt_vls_strcat( &dm_values.dv_string, "press bottom\n");
		break;
	case 'l':
		rt_vls_strcat( &dm_values.dv_string, "press left\n");
		break;
	case 'r':
		rt_vls_strcat( &dm_values.dv_string, "press right\n");
		break;
	case 'R':
		rt_vls_strcat( &dm_values.dv_string, "press rear\n");
		break;
	case '3':
		rt_vls_strcat( &dm_values.dv_string, "press 35,25\n");
		break;
	case '4':
		rt_vls_strcat( &dm_values.dv_string, "press 45,45\n");
		break;
	case 'F':
		no_faceplate = !no_faceplate;
		rt_vls_strcat( &dm_values.dv_string,
			      no_faceplate ?
			      "set faceplate 0\n" :
			      "set faceplate 1\n" );
		break;
	case XK_F1:			/* F1 key */
	    	rt_log("F1 botton!\n");
		rt_vls_printf( &dm_values.dv_string,
				"dm set depthcue !\n");
		break;
	case XK_F2:			/* F2 key */
		rt_vls_printf(&dm_values.dv_string,
				"dm set zclip !\n");
		break;
	case XK_F3:			/* F3 key */
		perspective_mode = 1-perspective_mode;
		rt_vls_printf( &dm_values.dv_string,
			    "set perspective %d\n",
			    perspective_mode ?
			    perspective_table[perspective_angle] :
			    -1 );
		dmaflag = 1;
		break;
	case XK_F4:			/* F4 key */
		/* toggle zbuffer status */
		rt_vls_printf(&dm_values.dv_string,
				"dm set zbuffer !\n");
		break;
	case XK_F5:			/* F5 key */
		/* toggle status */
		rt_vls_printf(&dm_values.dv_string,
		    "dm set lighting !\n");
	    	break;
	case XK_F6:			/* F6 key */
		/* toggle perspective matrix */
		if (--perspective_angle < 0) perspective_angle = 3;
		if(perspective_mode) rt_vls_printf( &dm_values.dv_string,
			    "set perspective %d\n",
			    perspective_table[perspective_angle] );
		dmaflag = 1;
		break;
	case XK_F7:			/* F7 key */
		/* Toggle faceplate on/off */
		no_faceplate = !no_faceplate;
		rt_vls_strcat( &dm_values.dv_string,
				    no_faceplate ?
				    "set faceplate 0\n" :
				    "set faceplate 1\n" );
		Ogl_configure_window_shape();
		dmaflag = 1;
		break;
	case XK_F12:			/* F12 key */
		rt_vls_printf( &dm_values.dv_string, "knob zero\n" );
		break;
	case XK_Up:
	    	if (ogl_which_slid-- == 0)
	    		ogl_which_slid = OGL_NUM_SLID - 1;
		break;
	case XK_Down:
	    	if (ogl_which_slid++ == OGL_NUM_SLID - 1)
	    		ogl_which_slid = 0;
		break;
	case XK_Left:
	    	/* set inc and fall through */
	    	inc = -0.1;
	case XK_Right:
	    	/* keep value of inc set at top of switch */
	    	switch(ogl_which_slid){
	    	case OGL_XSLEW:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob X %f\n", rate_slew[X] + inc);
	    		break;
	    	case OGL_YSLEW:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob Y %f\n", rate_slew[Y] + inc);
	    		break;
	    	case OGL_ZSLEW:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob Z %f\n", rate_slew[Z] + inc);
	    		break;
	    	case OGL_ZOOM:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob S %f\n", rate_zoom + inc);
	    		break;
	    	case OGL_XROT:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob x %f\n", rate_rotate[X] + inc);
	    		break;
	    	case OGL_YROT:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob y %f\n", rate_rotate[Y] + inc);
	    		break;
	    	case OGL_ZROT:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob z %f\n", rate_rotate[Z] + inc);
	    		break;
	    	default:
	    		break;
	    	}
		break;
	case XK_Shift_L:
	case XK_Shift_R:
		break;
	default:
		rt_log("dm-ogl: The key '%c' is not defined. Press '?' for help.\n", key);
		break;
	    }
d1168 3
a1170 3
/*	}  for loop */
    } else {
	return 1;
d1173 29
a1201 1
    return 1;
d1255 7
a1261 2
	rt_log("Ogl_load(x%x, %d.)\n", addr, count );
	return( 0 );
d1281 1
d1291 3
a1293 2
	    rt_log("Ogl_statechange: unknown state %s\n", state_str[b]);
	    break;
d1313 2
a1314 1
	if( ogl_debug )  rt_log("colorchange\n");
d1332 2
a1333 2
	if( ogl_has_rgb )  {
		if(cueing_on) {
d1348 4
a1351 3
		rt_log("Too few bitplanes: depthcueing and lighting disabled\n");
		cueing_on = 0;
		lighting_on = 0;
d1369 2
a1370 2
	if (cueing_on && lighting_on){
		lighting_on = 0;
d1375 1
a1375 1
	ogl_colorit();
d1382 1
a1382 1
	if (cueing_on){
d1397 3
a1399 3
	ogl_debug = lvl;
	XFlush(dpy);
	rt_log("flushed\n");
d1417 1
a1417 1
Ogl_xsetup( name )
d1420 33
a1452 61
	char *cp, symbol;
	XGCValues gcv;
	XColor a_color;
	Visual *a_visual;
	int a_screen, num, i, success;
	int major, minor;
	Colormap  a_cmap;
	XVisualInfo *vip;
	int dsize, use, dbfr, rgba, red, blue, green, alpha, index;
	GLfloat backgnd[4];
	XSizeHints *hints, gethints;
	long supplied;

	hints = XAllocSizeHints();

	/* this is important so that Ogl_configure_notify knows to set
	 * the font */
	fontstruct = NULL;

	width = height = 976;

	xinterp = Tcl_CreateInterp(); /* Dummy interpreter */
	xtkwin = Tk_CreateMainWindow(xinterp, name, "MGED", "MGED");

	/* Open the display - XXX see what NULL does now */
	if( xtkwin == NULL ) {
		rt_log( "dm-X: Can't open X display\n" );
		return -1;
	}
	dpy = Tk_Display(xtkwin);

	/* must do this before MakeExist */
	if ((vip=ogl_set_visual(xtkwin))==NULL){
		rt_log("Ogl_open: Can't get an appropriate visual.\n");
		return -1;
	}

	Tk_GeometryRequest(xtkwin, width+10, height+10);
	Tk_MoveToplevelWindow(xtkwin, 1276 - 976, 0);
	Tk_MakeWindowExist(xtkwin);

	win = Tk_WindowId(xtkwin);

	a_screen = Tk_ScreenNumber(xtkwin);

	/* open GLX context */
	/* If the sgi display manager has been used, then we must use
	 * an indirect context. Otherwise use direct, since it is usually
	 * faster.
	 */
	if ((glxc = glXCreateContext(dpy, vip, 0, ogl_sgi_used ? GL_FALSE : GL_TRUE))==NULL) {
		rt_log("Ogl_open: couldn't create glXContext.\n");
		return -1;
	}
	/* If we used an indirect context, then as far as sgi is concerned,
	 * gl hasn't been used.
	 */
	ogl_is_direct = (char) glXIsDirect(dpy, glxc);
	rt_log("Using %s OpenGL rendering context.\n", ogl_is_direct ? "a direct" : "an indirect");
	/* set ogl_ogl_used if the context was ever direct */
	ogl_ogl_used = (ogl_is_direct || ogl_ogl_used);
d1454 7
a1460 6
	/* Register the file descriptor with the Tk event handler */
#if 0
	Tk_CreateEventHandler(xtkwin, ExposureMask|ButtonPressMask|KeyPressMask|
			  PointerMotionMask
			  |StructureNotifyMask|FocusChangeMask,
			  (void (*)())Ogldoevent, (ClientData)NULL);
d1462 2
a1463 3
#else
	Tk_CreateGenericHandler(Ogldoevent, (ClientData)NULL);
#endif
d1465 1
a1465 1
	Tk_SetWindowBackground(xtkwin, bg);
d1467 1
a1467 4
	if (!glXMakeCurrent(dpy, win, glxc)){
		rt_log("Ogl_open: Couldn't make context current\n");
		return -1;
	}
d1469 106
a1574 4
	/* display list (fontOffset + char) will displays a given ASCII char */
	if ((fontOffset = glGenLists(128))==0){
		rt_log("dm-ogl: Can't make display lists for font.\n");
		return -1;
d1577 7
a1583 1
	Tk_MapWindow(xtkwin);
d1585 4
a1588 8
	/* Keep the window square */
	hints->min_aspect.x = 1;
	hints->min_aspect.y = 1;
	hints->max_aspect.x = 1;
	hints->max_aspect.y = 1;
	hints->flags = PAspect;
	XSetWMNormalHints(dpy, win, hints);
	XFree(hints);
d1590 3
a1592 7

	/* do viewport, ortho commands and initialize font*/
	Ogl_configure_window_shape();

	/* Lines will be solid when stippling disabled, dashed when enabled*/
	glLineStipple( 1, 0xCF33);
	glDisable(GL_LINE_STIPPLE);
d1594 29
a1622 9
	backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
	glFogi(GL_FOG_MODE, GL_LINEAR);
	glFogf(GL_FOG_START, 0.0);
	glFogf(GL_FOG_END, 2.0);
	if (ogl_has_rgb)
		glFogfv(GL_FOG_COLOR, backgnd);
	else
		glFogi(GL_FOG_INDEX, CMAP_RAMP_WIDTH - 1);
	glFogf(GL_FOG_DENSITY, VIEWFACTOR);
d1625 13
a1637 13
	/* Initialize matrices */
	/* Leave it in model_view mode normally */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 2.0);
	glGetDoublev(GL_PROJECTION_MATRIX, faceplate_mat);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity(); 
	glTranslatef( 0.0, 0.0, -1.0); 
	glPushMatrix();
	glLoadIdentity();
	ogl_face_flag = 1;	/* faceplate matrix is on top of stack */
d1639 1
a1639 1
	return 0;
d1646 1
a1646 1
ogl_set_visual(tkwin)
d1720 1
a1720 1
					cmap = XCreateColormap(dpy,
d1724 1
a1724 1
					cmap = XCreateColormap(dpy,
d1728 6
a1733 7
				if (Tk_SetWindowVisual(tkwin, maxvip->visual, maxvip->depth, cmap)){
					ogl_has_dbfr = m_double;
					ogl_has_doublebuffer = m_double;
					glXGetConfig(dpy, maxvip, GLX_DEPTH_SIZE, &ogl_depth_size);
					if (ogl_depth_size > 0)
						ogl_has_zbuf = 1;
					ogl_has_rgb = m_rgba;
d1737 1
a1737 1
					ogl_has_stereo = m_stereo;
d1743 1
a1743 1
					XFreeColormap(dpy,cmap);
d1752 2
a1753 2
			m_stereo = 0;
			rt_log("Stereo not available.\n");
d1755 2
a1756 2
			m_rgba = 0;
			rt_log("RGBA not available.\n");
d1758 2
a1759 2
			m_double = 0;
			rt_log("Doublebuffering not available. \n");
a1782 5
	xlim_view = 1.0;
	ylim_view = 1.0;
	mat_idn(aspect_corr);

#if 1
d1784 2
a1785 6
	height = xwa.height;
	width = xwa.width;
#else
	width = Tk_Width(xtkwin);
	height = Tk_Height(xtkwin);
#endif
d1787 5
a1791 2
	glViewport(0,  0, (width), (height));
	glScissor(0,  0, ( width)+1, ( height)+1);
a1792 1
	if( ogl_has_zbuf ) establish_zbuffer();
d1799 1
a1799 1
	if (ogl_has_zbuf)
d1804 1
a1804 1
	if (ogl_has_doublebuffer)
d1818 2
d1824 9
a1832 8
		if ((fontstruct = XLoadQueryFont(dpy, FONT9)) == NULL ) {
			/* Try hardcoded backup font */
			if ((fontstruct = XLoadQueryFont(dpy, FONTBACK)) == NULL) {
				rt_log( "dm-ogl: Can't open font '%s' or '%s'\n", FONT9, FONTBACK );
				return;
			}
		}
		glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
d1839 1
a1839 1
	if (width < 582) {
d1847 1
a1847 1
	} else if (width < 679) {
d1855 1
a1855 1
	} else if (width < 776) {
d1863 1
a1863 1
	} else if (width < 873) {
d1894 80
a1973 1
	struct rt_vls	vls;
d1975 7
a1981 1
	if( argc < 1 )  return -1;
d1983 17
a1999 19
	/* For now, only "set" command is implemented */
	if( strcmp( argv[0], "set" ) != 0 )  {
		rt_log("dm: command is not 'set'\n");
		return CMD_BAD;
	}

	rt_vls_init(&vls);
	if( argc < 2 )  {
		/* Bare set command, print out current settings */
		rt_structprint("dm_ogl internal variables", Ogl_vparse, (char *)0 );
		rt_log("%s", rt_vls_addr(&vls) );
	} else if( argc == 2 ) {
	        rt_vls_name_print( &vls, Ogl_vparse, argv[1], (char *)0 );
		rt_log( "%s\n", rt_vls_addr(&vls) );
  	} else {
	        rt_vls_printf( &vls, "%s=\"", argv[1] );
	        rt_vls_from_argv( &vls, argc-2, argv+2 );
		rt_vls_putc( &vls, '\"' );
		rt_structparse( &vls, Ogl_vparse, (char *)0 );
d2001 12
a2012 2
	rt_vls_free(&vls);
	return CMD_OK;
d2020 1
a2020 1
	if (!lighting_on) {
d2023 1
a2023 1
		if (!ogl_has_rgb)
d2028 3
a2030 3
		if (!ogl_has_rgb){
			if (cueing_on){
				cueing_on = 0;
d2060 1
a2060 1
void	
d2063 4
a2066 3
	if( ogl_has_zbuf == 0 ) {
		rt_log("dm-ogl: This machine has no Zbuffer to enable\n");
		zbuffer_on = 0;
d2069 1
a2069 1
	if (zbuffer_on)  {
d2079 45
d2125 2
a2126 2
void
ogl_colorit()
d2133 1
a2133 1
	if( ogl_has_rgb )  return;
d2170 25
d2203 1
a2203 1
 *	This routine is not called at all if ogl_has_rgb is set.
d2232 1
a2232 1
			if (cueing_on){
d2242 1
a2242 1
			} else { /* lighting_on */ 
d2253 1
a2253 1
			XStoreColors(dpy, cmap, cells, CMAP_RAMP_WIDTH);
d2263 1
a2263 1
		XStoreColor(dpy, cmap, &cell);
d2268 1
a2268 1
void
d2276 1
a2276 1
		XQueryColor(dpy, cmap, &cell);
d2279 58
@


1.8
log
@added lighting capability to index mode
@
text
@d1600 1
a1600 1
	m_rgba = 0;
@


1.7
log
@increased size of window
reversed order of cmap ramp so as to use a positive fog index
@
text
@d287 1
d290 1
a290 1
#define MAP_ENTRY(x)	((cueing_on) ? \
d718 7
d1369 2
a1370 2
	if(cueing_on && (ogl_index_size < 7)) {
		rt_log("Too few bitplanes: depthcueing disabled\n");
d1372 1
d1377 1
a1377 1
	if(cueing_on) {
a1379 1
		glEnable(GL_FOG);
a1381 1
		glDisable(GL_FOG);
d1389 6
d1402 7
d1862 1
a1862 3
	/* no lighting in index mode yet */
	if (!ogl_has_rgb)
		lighting_on = 0;
d1867 2
d1872 8
d1982 1
a1982 1
	if(cueing_on) {
d2003 1
d2005 20
a2024 8
			for(i = 0, j = MAP_ENTRY(c) + CMAP_RAMP_WIDTH - 1; 
				i < CMAP_RAMP_WIDTH;
			    i++, j--, red += r_inc, green += g_inc, blue += b_inc){
			    	cells[i].pixel = j;
			    	cells[i].red = (short)red;
			    	cells[i].green = (short)green;
			    	cells[i].blue = (short)blue;
			    	cells[i].flags = DoRed|DoGreen|DoBlue;
@


1.6
log
@changed rgba flag
@
text
@d206 1
d208 1
d1053 3
d1440 1
a1440 1
	width = height = 900;
d1459 1
a1459 1
	Tk_MoveToplevelWindow(xtkwin, 376, 0);
d1533 1
a1533 1
		glFogi(GL_FOG_INDEX, 1 - CMAP_RAMP_WIDTH);
d1842 4
d1964 1
a1964 1
			XColor cells[16];
d1966 3
a1968 3
			r_inc = ogl_rgbtab[c].r * 16;
			g_inc = ogl_rgbtab[c].g * 16;
			b_inc = ogl_rgbtab[c].b * 16;
d1970 1
d1974 1
d1976 3
a1978 2
			for(i = 15, j = MAP_ENTRY(c); i >= 0;
			    i--, j--, red -= r_inc, green -= g_inc, blue -= b_inc){
d1985 1
a1985 1
			XStoreColors(dpy, cmap, cells, 16);
d1997 13
@


1.5
log
@debugged index mode operation and cleaned up
@
text
@d1575 1
a1575 1
	m_rgba = 1;
@


1.4
log
@changed prompt from ogl to gl
@
text
@a63 4
#if 0
static void	label();
static void	draw();
#endif
a155 2
static int	min_scr_z;		/* based on (glGetIntegerv(XXX_ZMIN, &gdtmp), gdtmp) */
static int	max_scr_z;		/* based on (glGetIntegerv(XXX_ZMAX, &gdtmp), gdtmp) */
a245 4
		"%d",  1, "min_scr_z",		(int)&min_scr_z,	refresh_hook 	},
	{
		"%d",  1, "max_scr_z",		(int)&max_scr_z,	refresh_hook 	},
	{
a519 14
#if 0
	/* CJXX still necessary? I don't think so */
	/*
	 *  Convert between MGED's right handed coordinate system
	 *  where +Z comes out of the screen to the Silicon Graphics's
	 *  left handed coordinate system, where +Z goes INTO the screen.
	 */
	gtmat[0] = -gtmat[0];
	gtmat[1] = -gtmat[1];
	gtmat[2] = -gtmat[2];
	gtmat[3] = -gtmat[3];
#endif

	/*CJXX experimental */
d673 3
a675 1
	
d687 1
a687 1
		if(lighting_on) /* && ogl_is_gt)*/
a705 5
#if 0
			if (cueing_on){
				glEnable(GL_FOG);
			}
#endif
d708 6
a713 29

		if( white_flag ) {
			ovec = nvec = MAP_ENTRY(DM_WHITE);
			/* Use the *next* to the brightest white entry */
			if(cueing_on)  {
				glFogi(GL_FOG_INDEX, nvec + 1);
				glIndexi( nvec+1);
/*				lshaderange(nvec+1, nvec+1,
				    min_scr_z, max_scr_z );*/
			} else {
				glIndexi(nvec);
			}
		} else {
			if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
				/* Use only the middle 14 to allow for roundoff...
				 * Pity the poor fool who has defined a black object.
				 * The code will use the "reserved" color map entries
				 * to display it when in depthcued mode.
				 */
				if(cueing_on)  {
					glFogi(GL_FOG_INDEX, nvec+14);
					glIndexi(nvec+1);
/*					lshaderange(nvec+1, nvec+14,
					    min_scr_z, max_scr_z );*/
				} else {
					glIndexi(nvec);
				}
				ovec = nvec;
			}
d775 4
d801 2
a802 1
		glIndexi((int) MAP_ENTRY(DM_BLACK));
d857 2
a858 1
		glIndexi( MAP_ENTRY(colour) );
a887 1
#if 1
d889 1
a889 8
/*			if(cueing_on) lshaderange(nvec, nvec,
			    min_scr_z, max_scr_z );*/
			if(cueing_on) {
				glFogi(GL_FOG_INDEX, nvec + 1);
				glIndexi(nvec+1);
			} else {
				glIndexi( nvec );
			}
a891 1
#endif
d1355 1
a1355 1
#if 1
d1384 3
a1386 2
	glIndexi( MAP_ENTRY(DM_WHITE) );
#endif
a1401 9
#if 0
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
#endif
d1447 1
a1447 13
#if 0
	/*CJXX temporary */
	if (glXQueryExtension(dpy, NULL, NULL)){
		printf("glX extension exists\n");
		glXQueryVersion(dpy, &major, &minor);
		printf("version %d.%d\n", major, minor);
	} else {
		printf("glX extension doesn't exist\n");
	}
#endif

	/* must do this before Make Exist */

a1452 12
#if 0
	if (vip->class == PseudoColor){
		int npixels = 4096;
		unsigned long pixels[4096];

		while(!XAllocColorCells(dpy, cmap, 0, NULL, 0, pixels, npixels)){
			npixels /= 2;
		}
		printf("Allocated %d colorcells.\n",npixels);
	}
#endif
		
a1477 79
	/* CJXX We may not want color map indices **/
	/* In fact, lets rewrite code assuming rgba, and add index support
	 * later if we feel it's worthwhile 
	 */
#if 0
	if (!ogl_has_rgb){
		/* Get color map inddices for the colors we use. */
		black = BlackPixel( dpy, a_screen );
		white = WhitePixel( dpy, a_screen );

		a_cmap = Tk_Colormap(xtkwin);
		a_color.red = 255<<8;
		a_color.green=0;
		a_color.blue=0;
		a_color.flags = DoRed | DoGreen| DoBlue;
		if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
			rt_log( "dm-X: Can't Allocate red\n");
			return -1;
		}
		red = a_color.pixel;
		if ( red == white ) red = black;

		a_color.red = 200<<8;
		a_color.green=200<<8;
		a_color.blue=0<<8;
		a_color.flags = DoRed | DoGreen| DoBlue;
		if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
			rt_log( "dm-ogl: Can't Allocate yellow\n");
			return -1;
		}
		yellow = a_color.pixel;
		if (yellow == white) yellow = black;
    
		a_color.red = 0;
		a_color.green=0;
		a_color.blue=255<<8;
		a_color.flags = DoRed | DoGreen| DoBlue;
		if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
			rt_log( "dm-ogl: Can't Allocate blue\n");
			return -1;
		}
		blue = a_color.pixel;
		if (blue == white) blue = black;

		a_color.red = 128<<8;
		a_color.green=128<<8;
		a_color.blue= 128<<8;
		a_color.flags = DoRed | DoGreen| DoBlue;
		if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
			rt_log( "dm-ogl: Can't Allocate gray\n");
			return -1;
		}
		gray = a_color.pixel;
		if (gray == white) gray = black;

		/* Select border, background, foreground colors,
		 * and border width.
		 */
		/* if( a_visual->class == GrayScale || a_visual->class == StaticGray )  */
		if( vip->class == GrayScale || vip->class == StaticGray )  {
			is_monochrome = 1;
			bd = BlackPixel( dpy, a_screen );
			bg = WhitePixel( dpy, a_screen );
			fg = BlackPixel( dpy, a_screen );
		} else {
			/* Hey, it's a color server.  Ought to use 'em! */
			is_monochrome = 0;
			bd = WhitePixel( dpy, a_screen );
			bg = BlackPixel( dpy, a_screen );
			fg = WhitePixel( dpy, a_screen );
		}

		if( !is_monochrome && fg != red && red != black )  fg = red;

		gcv.foreground = fg;
		gcv.background = bg;
	}
#endif

a1490 1

a1503 1

a1512 7
	/* CJXX? */
	/* Don't draw polygon edges */

	/* CJXX? */
	/* Take off a smidgeon for wraparound, as suggested by SGI manual */
	min_scr_z = 0;
	max_scr_z = 1;
d1527 2
d1540 2
a1541 2
	glLoadIdentity(); /* object transformation matrix */
	glTranslatef( 0.0, 0.0, -1.0); /* new */
a1706 2
/* CJXX needed? */
#if 1
a1708 1
#endif
a1713 1
/*	glClearDepth(0.0);*/
a1734 8
#if 0
	/* CJXX not used */
	/* The glOrtho call really just makes this matrix */
	aspect_corr[0] = 1/xlim_view;
	aspect_corr[5] = 1/ylim_view;
#endif


d1846 1
a1846 11
/* CJXX positions specified in Ogl_newrot */
#if 0		
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glLoadIdentity();
		glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
		glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
		glLightfv(GL_LIGHT2, GL_POSITION, light2_position);
		glLightfv(GL_LIGHT3, GL_POSITION, light3_position);
		glPopMatrix();
#endif
a1865 245
#if 0
/*
 *  Some initial lighting model stuff
 *  Really, MGED needs to derive it's lighting from the database,
 *  but for now, this hack will suffice.
 *
 *  For materials, the definitions are:
 *	ALPHA		opacity.  1.0=opaque
 *	AMBIENT		ambient reflectance of the material  0..1
 *	DIFFUSE		diffuse reflectance of the material  0..1
 *	SPECULAR	specular reflectance of the material  0..1
 *	EMISSION	emission color ???
 *	SHININESS	specular scattering exponent, integer 0..128
 */
static float material_default[] = {
	ALPHA,		1.0,
	AMBIENT,	0.2, 0.2, 0.2,
	DIFFUSE,	0.8, 0.8, 0.8,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	0.0,
	SPECULAR,	0.0, 0.0, 0.0,
	LMNULL   };

/* Something like the RT default phong material */
static float material_rtdefault[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/* This was the "default" material in the demo */
static float material_xdefault[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_brass[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_shinybrass[] = {
	AMBIENT, 0.25, 0.15, 0.0,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.9, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_pewter[] = {
	AMBIENT, 0.0, 0.0,  0.0,
	DIFFUSE, 0.6, 0.55 , 0.65,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 10.0,
	LMNULL   };

static float mat_silver[] = {
	AMBIENT, 0.4, 0.4,  0.4,
	DIFFUSE, 0.3, 0.3, 0.3,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 30.0,
	LMNULL   };

static float mat_gold[] = {
	AMBIENT, 0.4, 0.2, 0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.7, 0.7, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_shinygold[] = {
	AMBIENT, 0.4, 0.2,  0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.9, 0.9, 0.0,
	SHININESS, 20.0,
	LMNULL   };

static float mat_plaster[] = {
	AMBIENT, 0.2, 0.2,  0.2,
	DIFFUSE, 0.95, 0.95, 0.95,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL   };

static float mat_redplastic[] = {
	AMBIENT, 0.3, 0.1, 0.1,
	DIFFUSE, 0.5, 0.1, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenplastic[] = {
	AMBIENT, 0.1, 0.3, 0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_blueplastic[] = {
	AMBIENT, 0.1, 0.1, 0.3,
	DIFFUSE, 0.1, 0.1, 0.5,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenflat[] = {
	EMISSION,   0.0, 0.4, 0.0,
	AMBIENT,    0.0, 0.0, 0.0,
	DIFFUSE,    0.0, 0.0, 0.0,
	SPECULAR,   0.0, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_greenshiny[]= {
	EMISSION, 0.0, 0.4, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.25, 0.9, 0.25,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueflat[] = {
	EMISSION, 0.0, 0.0, 0.4,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.0, 0.5, 0.5,
	SPECULAR,  0.0, 0.0, 0.9,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueshiny[] = {
	EMISSION, 0.0, 0.0, 0.6,
	AMBIENT,  0.1, 0.25, 0.5,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_redflat[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL
};

static float mat_redshiny[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_beigeshiny[] = {
	EMISSION, 0.5, 0.5, 0.6,
	AMBIENT,  0.35, 0.35, 0.0,
	DIFFUSE,  0.5, 0.5, 0.0,
	SPECULAR,  0.5, 0.5, 0.0,
	SHININESS, 10.0,
	LMNULL
};

/*
 *  Meanings of the parameters:
 *	AMBIENT		ambient light associated with this source ???, 0..1
 *	LCOLOR		light color, 0..1
 *	POSITION	position of light.  w=0 for infinite lights
 */
static float default_light[] = {
	AMBIENT,	0.0, 0.0, 0.0, 
	LCOLOR,		1.0, 1.0, 1.0, 
	POSITION,	0.0, 0.0, 1.0, 0.0,
	LMNULL};


static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, 200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, 100.0, 30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, -100.0, 20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, -100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};





/*
 *  Lighting model parameters
 *	AMBIENT		amount of ambient light present in the scene, 0..1
 *	ATTENUATION	fixed and variable attenuation factor, 0..1
 *	LOCALVIEWER	1=eye at (0,0,0), 0=eye at (0,0,+inf)
 */
static float	default_lmodel[] = {
	AMBIENT,	0.2,  0.2,  0.2,
	ATTENUATION,	1.0, 0.0, 
	LOCALVIEWER,	0.0, 
	LMNULL};

static float infinite[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 0.0, 
	LMNULL};

static float local[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 1.0, 
	ATTENUATION, 1.0, 0.0, 
	LMNULL};
a1866 4


#endif

d1957 7
a1963 7
			r_inc = ogl_rgbtab[c].r/16;
			g_inc = ogl_rgbtab[c].g/16;
			b_inc = ogl_rgbtab[c].b/16;

			red = ogl_rgbtab[c].r;
			green = ogl_rgbtab[c].g;
			blue = ogl_rgbtab[c].b;
d1965 1
a1965 1
			for(i = 15, j = MAP_ENTRY(c) + 15; i >= 0;
d1979 3
a1981 3
		cell.red = ogl_rgbtab[c].r;
		cell.green = ogl_rgbtab[c].g;
		cell.blue = ogl_rgbtab[c].b;
a1984 5
#if 0
		celltest.pixel = c + CMAP_BASE;
		XQueryColor(dpy, cmap, &celltest);
		printf("cell %d: %d %d %d\n", c + CMAP_BASE, celltest.red, celltest.green, celltest.blue);
#endif
@


1.3
log
@Changed to new L and R button press conventions.
@
text
@d2 1
a2 1
 *			D M - Ogl . C
a13 3
#ifndef lint
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ogl.c,v 1.2 1995/08/23 23:08:58 cnuzman Exp mike $ (BRL)";
#endif
d73 1
a73 1
/* Flags indicating whether the ogl and sgi display managers have been
d76 1
a76 1
 * with ogl.
d116 1
a116 1
	"ogl", "X Windows, drawn using OpenGL",
d306 1
a306 1
 *			Ogl _ O P E N
d347 1
a347 1
 *  			Ogl _ C L O S E
d369 1
a369 1
 *			Ogl _ P R O L O G
d418 1
a418 1
 *			Ogl _ E P I L O G
d463 1
a463 1
 *  			Ogl _ N E W R O T
d657 1
a657 1
 *  			Ogl _ O B J E C T
d830 1
a830 1
 *			Ogl _ N O R M A L
d869 1
a869 1
 *			Ogl _ U P D A T E
d913 1
a913 1
 *			Ogl _ 2 D _ L I N E
d1262 1
a1262 1
		rt_log("dm-ogl: The key '%c' is not defined in the drawing window.\n", key);
d1275 1
a1275 1
 *			Ogl _ I N P U T
d1299 1
a1299 1
 *			Ogl _ L I G H T
d1556 1
a1556 1
	 * ogl hasn't been used.
d1846 1
a1846 1
 *			Ogl _ C O N F I G U R E _ W I N D O W _ S H A P E
d1980 1
a1980 1
 *			Ogl _ D M
@


1.2
log
@hacked around bug which caused mged to crash when sgi and ogl were used
in the same session. Also added more key accelerators to manipulate the view.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-ogl.c,v 1.1 1995/08/22 22:32:09 cnuzman Exp cnuzman $ (BRL)";
d1034 1
a1034 1
	    rt_vls_strcat( &dm_values.dv_string, "zoom 0.5\n");
d1042 1
a1042 1
	    rt_vls_strcat( &dm_values.dv_string, "zoom 2\n");
d1051 1
a1051 1
	    /* Left mouse: Zoom out.  Do nothing more */
d1058 1
a1058 1
	    /* Right mouse: Zoom in.  Do nothing more. */
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.9 1995/07/20 13:20:10 gdurf Exp cnuzman $ (BRL)";
d76 8
d196 2
d322 1
d982 8
d999 1
d1001 1
d1068 1
a1068 1
    	/* CJXX I think this code is bad in X.c*/
d1071 18
a1088 10
	    switch( key ) {
	    case '?':
		rt_log( "\nKey Help Menu:\n\
0, <F12>	Zero 'knobs'\n\
x		Increase xrot\n\
y		Increase yrot\n\
z		Increase zrot\n\
X		Increase Xslew\n\
Y		Increase Yslew\n\
Z		Increase Zslew\n\
d1097 1
a1097 1
F,<F7>		Toggle faceplate\n\
d1103 2
a1104 1
<F6>		Toggle perspective matrix\n\
d1107 1
a1107 1
	    case '0':
d1110 7
a1116 1
	    case 'x':
d1118 1
a1118 1
		rt_vls_printf( &dm_values.dv_string, "knob +x 0.1\n" );
d1120 2
a1121 2
	    case 'y':
		rt_vls_printf( &dm_values.dv_string, "knob +y 0.1\n" );
d1123 2
a1124 2
	    case 'z':
		rt_vls_printf( &dm_values.dv_string, "knob +z 0.1\n" );
d1126 2
a1127 3
	    case 'X':
		/* viewsize per unit */
		rt_vls_printf( &dm_values.dv_string, "knob +X 0.1\n" );
d1129 2
a1130 2
	    case 'Y':
		rt_vls_printf( &dm_values.dv_string, "knob +Y 0.1\n" );
d1132 2
a1133 2
	    case 'Z':
		rt_vls_printf( &dm_values.dv_string, "knob +Z 0.1\n" );
d1135 1
a1135 1
	    case 'f':
d1138 1
a1138 1
	    case 't':
d1141 1
a1141 1
	    case 'b':
d1144 1
a1144 1
	    case 'l':
d1147 1
a1147 1
	    case 'r':
d1150 1
a1150 1
	    case 'R':
d1153 1
a1153 1
	    case '3':
d1156 1
a1156 1
	    case '4':
d1159 1
a1159 1
	    case 'F':
d1166 1
a1166 1
	    case XK_F1:			/* F1 key */
d1171 1
a1171 1
	    case XK_F2:			/* F2 key */
d1175 1
a1175 1
	    case XK_F3:			/* F3 key */
d1184 1
a1184 1
	    case XK_F4:			/* F4 key */
d1189 1
a1189 1
	    case XK_F5:			/* F5 key */
d1194 1
a1194 1
	    case XK_F6:			/* F6 key */
d1202 1
a1202 1
	    case XK_F7:			/* F7 key */
d1212 1
a1212 1
	    case XK_F12:			/* F12 key */
d1215 45
a1259 2
	    default:
		rt_log("dm-ogl: The key '%c' is not defined\n", key);
d1261 6
d1480 7
a1486 6
    char *cp, symbol;
    XGCValues gcv;
    XColor a_color;
    Visual *a_visual;
    int a_screen, num, i, success;
    Colormap  a_cmap;
d1499 4
a1502 1
    width = height = 900;
d1504 6
a1509 2
    xinterp = Tcl_CreateInterp(); /* Dummy interpreter */
    xtkwin = Tk_CreateMainWindow(xinterp, name, "MGED", "MGED");
d1511 10
a1520 6
    /* Open the display - XXX see what NULL does now */
    if( xtkwin == NULL ) {
	rt_log( "dm-X: Can't open X display\n" );
	return -1;
    }
    dpy = Tk_Display(xtkwin);
d1545 1
a1545 1
    win = Tk_WindowId(xtkwin);
d1547 1
a1547 1
    a_screen = Tk_ScreenNumber(xtkwin);
d1550 3
a1552 2
	/* The context must be indirect, or else errors occur when you
	 * try to attach the sgi display manager 
d1554 1
a1554 1
	if ((glxc = glXCreateContext(dpy, vip, 0, GL_TRUE))==NULL) {
d1558 7
a1569 2
	/* This the the X way, rather than the sgi way .
	 * go with sgi for the nonce */
d1645 1
a1645 1
    /* Register the file descriptor with the Tk event handler */
d1647 1
a1647 1
    Tk_CreateEventHandler(xtkwin, ExposureMask|ButtonPressMask|KeyPressMask|
d1653 1
a1653 1
    Tk_CreateGenericHandler(Ogldoevent, (ClientData)NULL);
d1656 1
a1656 1
    Tk_SetWindowBackground(xtkwin, bg);
d1720 1
a1720 1
    return 0;
@
