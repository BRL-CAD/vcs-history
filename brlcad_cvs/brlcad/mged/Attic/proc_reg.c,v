head	11.51;
access;
symbols
	rel-5-4:11.42
	offsite-5-3-pre:11.48
	rel-5-3:11.42
	rel-5-2:11.42
	rel-5-1-branch:11.42.0.2
	rel-5-1:11.42
	rel-5-0:11.29
	rel-5-0-beta:11.29
	rel-4-5:11.24
	ctj-4-5-post:11.20
	ctj-4-5-pre:11.20
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.4;
locks; strict;
comment	@ * @;


11.51
date	2001.06.01.19.24.40;	author bparker;	state dead;
branches;
next	11.50;

11.50
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	2001.05.03.18.53.46;	author jra;	state Exp;
branches;
next	11.48;

11.48
date	2000.10.24.19.58.14;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.10.24.19.05.07;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	2000.10.24.15.14.13;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	2000.09.08.05.55.49;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	2000.08.19.03.10.48;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.08.19.03.10.16;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	2000.06.21.12.21.06;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	2000.06.19.18.20.12;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	2000.06.19.17.35.53;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2000.06.06.21.05.17;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2000.06.05.21.03.26;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	2000.05.26.14.00.42;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	99.12.30.19.50.30;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	99.12.23.06.13.17;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	99.12.22.20.15.36;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	99.11.24.14.26.42;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	99.10.07.20.32.08;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	99.10.04.17.26.57;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	99.09.30.19.54.40;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	99.01.12.18.16.21;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	98.12.17.04.19.11;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	98.11.06.22.32.42;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	98.09.14.15.59.20;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	98.06.24.17.55.18;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	97.12.23.14.24.16;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	97.09.08.18.38.23;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	97.09.03.14.19.39;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	97.08.20.19.23.33;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.03.18.19.51.52;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.03.12.19.28.18;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	97.03.11.21.41.04;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.12.04.03.39.35;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.09.30.19.45.10;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.09.23.18.17.21;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.17.21.20.57;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.08.21.19.20.55;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.03.01.19.30.22;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.02.18.03.09.05;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.54;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.28;	author mike;	state Rel4_4;
branches;
next	10.9;

10.9
date	94.12.30.01.08.53;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.12.27.16.58.43;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.12.16.20.33.38;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.12.16.19.37.11;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.11.10.12.06.12;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.08.27.03.18.19;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.09.18.18.00;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.06.03.17.31.53;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.14;	author mike;	state Rel4_0;
branches;
next	9.13;

9.13
date	91.08.29.23.02.29;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.05.18.03.30.48;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.02.02.00.01.50;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.01.26.03.23.08;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.12.08.25.40;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.07.01.09.01;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.06.20.00.30;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.06.19.51.01;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.06.19.43.47;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.06.19.21.04;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.04.13.00.34.32;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.13.20.42.54;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.39;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	88.12.06.02.31.23;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.16;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.02.25.06.09.10;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.39;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.01.42;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.59;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.21.54;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.12.51;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.22.43;	author mike;	state Rel1;
branches;
next	2.13;

2.13
date	86.08.12.06.50.26;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.07.17.02.15.42;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.07.16.23.43.23;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.07.16.23.23.04;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.07.16.22.43.04;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.07.16.17.51.38;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.07.16.03.44.02;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.07.16.03.33.05;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	86.07.16.01.01.33;	author mike;	state Exp;
branches
	2.5.1.1;
next	2.4;

2.4
date	85.08.07.05.19.36;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.07.30.01.17.54;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.05.07.23.12.19;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.56.48;	author mike;	state Prod;
branches;
next	1.5;

1.5
date	85.01.16.01.58.29;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.11.20.04.25.15;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.19.02.59.48;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.17.05.37.57;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.52.58;	author mike;	state Exp;
branches;
next	;

2.5.1.1
date	86.08.14.22.45.03;	author mike;	state Exp;
branches;
next	;


desc
@produce an evaluated display of a region
@


11.51
log
@*- this now lives in librt/bigE.c
@
text
@/*		This module impliments the 'E' command
 *
 *  Author -
 *	John Anderson
 *  
 *  Source -
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1997 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.50 2001/06/01 19:23:25 bparker Exp $ (BRL)";
#endif

#if 0
#include "conf.h"

#include <stdio.h>
#include <signal.h>
#ifdef USE_STRING_H
#	include <string.h>
#else
#	include <strings.h>
#endif
#include <errno.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "externs.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include <ctype.h>
/* #define debug 1 */

extern struct bn_tol		mged_tol;
extern struct rt_tess_tol	mged_ttol;
extern int			mged_wireframe_color_override;
extern int			mged_wireframe_color[3];
static struct application	*ap=(struct application *)NULL;
static time_t			start_time, etime;
static struct bu_ptbl		leaf_list;
static long			nvectors;
static struct rt_i		*rtip;
static int			num_halfs;
static int			do_polysolids; /* if this is non-zero, convert all the solids to polysolids
						* for the raytracing (otherwise just raytrace the solids
						* themselves). Raytracing polysolids is slower, but produces
						* a better plot, since the polysolids exactly match the NMGs
						* that provide the starting edges.
						*/
union E_tree *build_etree();

/* segment types (stored in the "seg_stp" field of the (struct seg) */
#define	ON_SURF	(struct soltab *)0x1
#define IN_SOL  (struct soltab *)0x2
#define ON_INT	(struct soltab *)0x3

#define NOT_SEG_OVERLAP( _a, _b )	((_a->seg_out.hit_dist <= _b->seg_in.hit_dist) || (_b->seg_out.hit_dist <= _a->seg_in.hit_dist))

/* RT_FREE_SEG_LIST assumed list head is a "struct seg" */
#define MY_FREE_SEG_LIST( _segheadp, _res )	{ \
	register struct seg *_a; \
	while( BU_LIST_WHILE( _a, seg, (_segheadp) ) )  { \
		BU_LIST_DEQUEUE( &(_a->l) ); \
		RT_FREE_SEG( _a, _res ); \
	} }

/* stolen from g_half.c */
struct half_specific  {
        plane_t half_eqn;               /* Plane equation, outward normal */
        vect_t  half_Xbase;             /* "X" basis direction */
        vect_t  half_Ybase;             /* "Y" basis direction */
};
#define HALF_NULL       ((struct half_specific *)0)

/* structures for building a tree corresponding to the region to be drawn
 * uses the same "op" values as "union tree"
 */
union E_tree
{
	long magic;

	struct E_node	/* the operator nodes */
	{
		long magic;
		int op;
		union E_tree *left;
		union E_tree *right;
	} n;

	struct E_leaf	/* the leaf nodes */
	{
		long magic;
		int op;
		struct model *m;		/* NMG version of this leaf solid */
		struct bu_list seghead;		/* head of list of segments for this leaf solid */
		struct bu_ptbl edge_list;	/* list of edges from above NMG */
		struct soltab *stp;		/* the usual soltab pointer */
		unsigned char do_not_free_model; /* A flag indicating that the NMG model pointer is a reference to the
						 * NMG model in the soltab structure */
	} l;
};

#define	E_TREE_MAGIC		0x45545245
#define	CK_ETREE(_p)		BU_CKMAG( _p, E_TREE_MAGIC, "struct E_tree" )

void
Edrawtree( dp )
{
	return;
}

HIDDEN union E_tree *
add_solid( dp, mat )
struct directory *dp;
matp_t mat;
{
	union E_tree *eptr;
	struct nmgregion *r;
	struct rt_db_internal intern;
	int id;
	int solid_is_plate_mode_bot=0;

	BU_GETUNION( eptr, E_tree );
	eptr->magic = E_TREE_MAGIC;

	id = rt_db_get_internal( &intern, dp, dbip, mat, &rt_uniresource );
	if( id < 0 )
	{
		Tcl_AppendResult(interp, "Failed to get internal form of ",
			dp->d_namep, "\n", (char *)NULL );
		eptr->l.m = (struct model *)NULL;
		return( eptr );
	}
	if( id == ID_COMBINATION )
	{
		/* do explicit expansion of referenced combinations */

		struct rt_comb_internal *comb;

		bu_free( (char *)eptr, "eptr" );

		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB( comb );

		eptr = build_etree( comb->tree );
		rt_db_free_internal( &intern, &rt_uniresource );
		return( eptr );
	}
#if 0
	if( id == ID_BOT )
	{
		struct rt_bot_internal *bot = (struct rt_bot_internal *)intern.idb_ptr;

		/* if this is a plate mode BOT, lie to the tesselator to get
		 * an approximation
		 */

		RT_BOT_CK_MAGIC( bot );

		if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_PLATE_NOCOS )
		{
			solid_is_plate_mode_bot = 1;
			bot->mode = RT_BOT_SOLID;
		}
	}
#endif
	if( id == ID_HALF )
	{
		eptr->l.m = NULL;
		num_halfs++;
	}
	else if( id == ID_NMG )
	{
		/* steal the nmg model */
		eptr->l.m = (struct model *)intern.idb_ptr;
		eptr->l.do_not_free_model = 1;
	}
	else
	{
		/* create the NMG version of this solid */
		eptr->l.m = nmg_mm();
		if (rt_functab[id].ft_tessellate( &r, eptr->l.m, &intern,
			&mged_ttol, &mged_tol) < 0)
		{
			nmg_km( eptr->l.m );
			eptr->l.m = NULL;
		}
	}

	/* get the soltab stuff */
	BU_GETSTRUCT( eptr->l.stp, soltab );
	eptr->l.stp->l.magic = RT_SOLTAB_MAGIC;
	eptr->l.stp->l2.magic = RT_SOLTAB2_MAGIC;
	eptr->l.stp->st_dp = dp;
	eptr->l.stp->st_matp = mat;

	{
		struct rt_bot_internal *bot;
		struct rt_db_internal intern2;

		if( do_polysolids )
		{
			struct shell *s=(struct shell *)NULL;
			struct nmgregion *r=(struct nmgregion *)NULL;

			/* create and prep a BoT version of this solid */
			if( eptr->l.m ) {
				r = BU_LIST_FIRST( nmgregion, &eptr->l.m->r_hd );
				s = BU_LIST_FIRST( shell, &r->s_hd );
			}

			if( solid_is_plate_mode_bot ||
			    !eptr->l.m ||
			    (bot=nmg_bot( s, &mged_tol ) ) == (struct rt_bot_internal *)NULL )
			{
				eptr->l.stp->st_id = id;
				if( rt_functab[id].ft_prep( eptr->l.stp, &intern, rtip ) < 0 )
					Tcl_AppendResult(interp, "Prep failure for solid '", dp->d_namep,
						"'\n", (char *)NULL );
			}
			else
			{
				RT_INIT_DB_INTERNAL( &intern2 );
				intern2.idb_type = ID_BOT;
				intern2.idb_meth = &rt_functab[ID_BOT];
				intern2.idb_ptr = (genptr_t)bot;
				eptr->l.stp->st_id = ID_BOT;
				if (rt_functab[ID_BOT].ft_prep( eptr->l.stp, &intern2, rtip ) < 0 )
				{
					Tcl_AppendResult(interp, "Prep failure for solid '", dp->d_namep,
						"'\n", (char *)NULL );
				}

				rt_db_free_internal( &intern2, &rt_uniresource );
			}
		}
		else
		{
			/* prep this solid */

			eptr->l.stp->st_id = id;
			if( rt_functab[id].ft_prep( eptr->l.stp, &intern, rtip ) < 0 )
				Tcl_AppendResult(interp, "Prep failure for solid '", dp->d_namep,
					"'\n", (char *)NULL );
		}
	}

	if( id != ID_NMG )
		rt_db_free_internal( &intern, &rt_uniresource );

	/* add this leaf to the leaf list */
	bu_ptbl_ins( &leaf_list, (long *)eptr );

	return( eptr );
}

/* build an E_tree corresponding to the region tree (tp) */
union E_tree *
build_etree( tp )
union tree *tp;
{
	union E_tree *eptr = NULL;
	struct soltab *stp;
	struct directory *dp;

	RT_CK_TREE( tp );

	switch( tp->tr_op )
	{
		case OP_UNION:
		case OP_SUBTRACT:
		case OP_INTERSECT:
			BU_GETUNION( eptr, E_tree );
			eptr->magic = E_TREE_MAGIC;
			eptr->n.op = tp->tr_op;
			eptr->n.left = build_etree( tp->tr_b.tb_left );
			eptr->n.right = build_etree( tp->tr_b.tb_right );
			break;
		case OP_SOLID:
			stp = tp->tr_a.tu_stp;
			eptr = add_solid( stp->st_dp, stp->st_matp );
			eptr->l.op = tp->tr_op;
			BU_LIST_INIT( &eptr->l.seghead );
			break;
		case OP_DB_LEAF:
			if( (dp=db_lookup( dbip, tp->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
			{
				eptr->l.m = (struct model *)NULL;
				break;
			}
			eptr = add_solid( dp, tp->tr_l.tl_mat );
			eptr->l.op = tp->tr_op;
			BU_LIST_INIT( &eptr->l.seghead );
			break;
		case OP_NOP:
			/* add a NULL solid  */
			BU_GETUNION( eptr, E_tree );
			eptr->magic = E_TREE_MAGIC;
			eptr->l.m = (struct model *)NULL;
			break;
		default:
			bu_bomb("build_etree() Unknown tr_op\n");
	}
	return( eptr );
}

/* a handy routine (for debugging) that prints asegment list */
void
show_seg( seg, str )
struct bu_list *seg;
{
	struct seg *ptr;

	if( !seg )
		bu_log( "%s - NULL seg list\n", str );
	else
	{
		if( BU_LIST_IS_EMPTY( seg ) )
			bu_log( "%s - empty\n", str );
		else
		{
			bu_log( "%s:\n", str );
			for( BU_LIST_FOR( ptr, seg, seg ) )
			{
				if( ptr->seg_stp == ON_SURF )
					bu_log( "\t %g to %g (ON_SURF)\n", ptr->seg_in.hit_dist, ptr->seg_out.hit_dist );
				else if( ptr->seg_stp == ON_INT )
					bu_log( "\t %g to %g (ON_INT)\n", ptr->seg_in.hit_dist, ptr->seg_out.hit_dist );
				else if( ptr->seg_stp == IN_SOL )
					bu_log( "\t %g to %g (IN)\n", ptr->seg_in.hit_dist, ptr->seg_out.hit_dist );
				else
					bu_log( "\t %g to %g (??)\n", ptr->seg_in.hit_dist, ptr->seg_out.hit_dist );
			}
		}
	}
}

/* given a segment list, eliminate any overlaps in the segments */
HIDDEN  void
eliminate_overlaps( seghead )
struct bu_list *seghead;
{
	struct seg *a, *b, *nextb;

	a = BU_LIST_FIRST( seg, seghead );
	while( BU_LIST_NOT_HEAD( &a->l, seghead ) )
	{
		b = BU_LIST_PNEXT( seg, &a->l );
		if( BU_LIST_IS_HEAD( &b->l, seghead ) )
			break;

		while( BU_LIST_NOT_HEAD( &b->l, seghead ) )
		{
			nextb = BU_LIST_PNEXT( seg, &b->l );
			if( NOT_SEG_OVERLAP( a, b ) )
				break;

			if( b->seg_in.hit_dist < a->seg_out.hit_dist )
			{
				if( b->seg_out.hit_dist > a->seg_out.hit_dist )
					a->seg_out.hit_dist = b->seg_out.hit_dist;

				BU_LIST_DEQUEUE( &b->l );
				RT_FREE_SEG( b, ap->a_resource );
				b = nextb;
				continue;
			}

			b = nextb;
		}

		a = BU_LIST_PNEXT(seg, &a->l );
	}
}

/* perform the intersection of two segments
 * the result is assigned the provided type
 */
HIDDEN void
do_intersect( A, B, seghead, type )
struct seg *A;
struct seg *B;
struct bu_list *seghead;
struct soltab *type;
{
	struct seg *tmp=(struct seg *)NULL;

	if( NOT_SEG_OVERLAP( A, B ) )
		return;

	RT_GET_SEG( tmp, ap->a_resource );
	if( A->seg_in.hit_dist <= B->seg_in.hit_dist )
	{
		if( B->seg_out.hit_dist <= A->seg_out.hit_dist )
		{
			*tmp = *B;
			tmp->seg_stp = type;
		}
		else
		{
			tmp->seg_in.hit_dist = B->seg_in.hit_dist;
			tmp->seg_out.hit_dist = A->seg_out.hit_dist;
			tmp->seg_stp = type;
		}
	}
	else
	{
		if( B->seg_out.hit_dist >= A->seg_out.hit_dist )
		{
			*tmp = *A;
			tmp->seg_stp = type;
		}
		else
		{
			tmp->seg_in.hit_dist = A->seg_in.hit_dist;
			tmp->seg_out.hit_dist = B->seg_out.hit_dist;
			tmp->seg_stp = type;
		}
	}
	if( tmp )
		BU_LIST_INSERT( seghead, &tmp->l )
	return;
}

/* perform the subtraction of one segment from another
 * the result is assigned the type from segment A
 */
HIDDEN void
do_subtract( A, B, seghead )
struct seg *A;
struct seg *B;
struct bu_list *seghead;
{
	struct seg *tmp=(struct seg *)NULL;


	if( NOT_SEG_OVERLAP( A, B ) )
	{
		RT_GET_SEG( tmp, ap->a_resource )
		*tmp = *A;
		BU_LIST_INSERT( seghead, &tmp->l )
		return;
	}

	if( B->seg_in.hit_dist<= A->seg_in.hit_dist )
	{
		if( B->seg_out.hit_dist < A->seg_out.hit_dist )
		{
			RT_GET_SEG( tmp, ap->a_resource )
			*tmp = *A;
			tmp->seg_in.hit_dist = B->seg_out.hit_dist;
			BU_LIST_INSERT( seghead, &tmp->l )
			return;
		}
		else
			return;
	}
	else
	{
		if( B->seg_out.hit_dist >= A->seg_out.hit_dist )
		{
			RT_GET_SEG( tmp, ap->a_resource )
			*tmp = *A;
			tmp->seg_out.hit_dist = B->seg_in.hit_dist;
			BU_LIST_INSERT( seghead, &tmp->l )
			return;
		}
		else
		{
			RT_GET_SEG( tmp, ap->a_resource );
			tmp->seg_in.hit_dist = A->seg_in.hit_dist;
			tmp->seg_out.hit_dist = B->seg_in.hit_dist;
			tmp->seg_stp = A->seg_stp;
			BU_LIST_INSERT( seghead, &tmp->l )
			RT_GET_SEG( tmp, ap->a_resource );
			tmp->seg_in.hit_dist = B->seg_out.hit_dist;
			tmp->seg_out.hit_dist = A->seg_out.hit_dist;
			tmp->seg_stp = A->seg_stp;
			BU_LIST_INSERT( seghead, &tmp->l )
			return;
		}
	}
}

/* perform the union of two segments
 * the types of A and B should be the same
 */
HIDDEN void
do_union( A, B, seghead )
struct seg *A;
struct seg *B;
struct bu_list *seghead;
{
	struct seg *tmp;

	RT_GET_SEG( tmp, ap->a_resource )

	if( NOT_SEG_OVERLAP( A, B ) )
	{
		if( A->seg_in.hit_dist <= B->seg_in.hit_dist )
		{
			*tmp = *A;
			BU_LIST_INSERT( seghead, &tmp->l )
			RT_GET_SEG( tmp, ap->a_resource )
			*tmp = *B;
			BU_LIST_INSERT( seghead, &tmp->l )
		}
		else
		{
			*tmp = *B;
			BU_LIST_INSERT( seghead, &tmp->l )
			RT_GET_SEG( tmp, ap->a_resource )
			*tmp = *A;
			BU_LIST_INSERT( seghead, &tmp->l )
		}
		return;
	}

	if( A->seg_in.hit_dist <= B->seg_in.hit_dist )
	{
		*tmp = *A;
		if( B->seg_out.hit_dist > A->seg_out.hit_dist )
			tmp->seg_out.hit_dist = B->seg_out.hit_dist;
	}
	else
	{
		*tmp = *B;
		if( A->seg_out.hit_dist > B->seg_out.hit_dist )
			tmp->seg_out.hit_dist = B->seg_out.hit_dist;
	}

	BU_LIST_INSERT( seghead, &tmp->l )
}

HIDDEN void
promote_ints( head )
struct bu_list *head;
{
	struct seg *a, *b, *tmp;

	#ifdef debug
	bu_log( "In promote_ints():\n" );
	show_seg( head, "SEGS" );
	for( BU_LIST_FOR( a, seg, head ) )
	{
		b = BU_LIST_PNEXT( seg, &a->l );
		if( BU_LIST_IS_HEAD( &b->l, head ) )
			break;

		if( b->seg_in.hit_dist < a->seg_in.hit_dist )
			bu_log( "\tsegments out of order:\n" );
	}
	#endif

	a = BU_LIST_FIRST( seg, head );
	while( BU_LIST_NOT_HEAD( &a->l, head ) )
	{
		b = BU_LIST_PNEXT( seg, &a->l );
		while( BU_LIST_NOT_HEAD( &b->l, head ) )
		{
			if( a->seg_stp == ON_INT && b->seg_stp == ON_SURF )
			{
				if( NOT_SEG_OVERLAP( a, b ) )
				{
					b = BU_LIST_PNEXT( seg, &b->l );
					continue;
				}

				if( a->seg_in.hit_dist == b->seg_in.hit_dist &&
				    a->seg_out.hit_dist == b->seg_out.hit_dist )
				{
					a->seg_stp = ON_SURF;
					tmp = b;
					b = BU_LIST_PNEXT( seg, &b->l );
					BU_LIST_DEQUEUE( &tmp->l )
					RT_FREE_SEG( tmp, ap->a_resource )
					continue;;
				}

				if( a->seg_out.hit_dist == b->seg_out.hit_dist )
					a->seg_out.hit_dist = b->seg_in.hit_dist;
				else if( a->seg_out.hit_dist < b->seg_out.hit_dist )
				{
					if( b->seg_in.hit_dist > a->seg_in.hit_dist )
						a->seg_out.hit_dist = b->seg_in.hit_dist;
					else
					{
						tmp = a;
						a  = BU_LIST_PLAST( seg, &a->l );
						BU_LIST_DEQUEUE( &tmp->l )
						RT_FREE_SEG( tmp, ap->a_resource )
						break;
					}
				}
				else if( a->seg_in.hit_dist == b->seg_in.hit_dist )
				{
					fastf_t tmp_dist;

					tmp_dist = a->seg_out.hit_dist;
					a->seg_out.hit_dist = b->seg_out.hit_dist;
					b->seg_in.hit_dist = a->seg_out.hit_dist;
					b->seg_out.hit_dist = tmp_dist;
					a->seg_stp = ON_SURF;
					b->seg_stp = ON_INT;
				}
				else
				{
					RT_GET_SEG( tmp, ap->a_resource )
					*tmp = *a;
					tmp->seg_in.hit_dist = b->seg_out.hit_dist;
					a->seg_out.hit_dist = b->seg_in.hit_dist;
					BU_LIST_APPEND( &b->l, &tmp->l )
				}
			}
			else if( b->seg_stp == ON_INT && a->seg_stp == ON_SURF )
			{
				if( NOT_SEG_OVERLAP( b, a ) )
				{
					b = BU_LIST_PNEXT( seg, &b->l );
					continue;
				}

				if( b->seg_in.hit_dist == a->seg_in.hit_dist &&
				    b->seg_out.hit_dist == a->seg_out.hit_dist )
				{
					b->seg_stp = ON_SURF;
					tmp = a;
					a = BU_LIST_PLAST( seg, &a->l );
					BU_LIST_DEQUEUE( &tmp->l )
					RT_FREE_SEG( tmp, ap->a_resource )
					break;
				}

				if( b->seg_out.hit_dist == a->seg_out.hit_dist )
				{
					tmp = b;
					b = BU_LIST_PNEXT( seg, &b->l );
					BU_LIST_DEQUEUE( &tmp->l )
					RT_FREE_SEG( tmp, ap->a_resource )
				}
				else if( b->seg_out.hit_dist < a->seg_out.hit_dist )
				{
					if( a->seg_in.hit_dist > b->seg_in.hit_dist )
						b->seg_out.hit_dist = a->seg_in.hit_dist;
					else
					{
						tmp = b;
						b = BU_LIST_PNEXT( seg, &b->l );
						BU_LIST_DEQUEUE( &tmp->l )
						RT_FREE_SEG( tmp, ap->a_resource )
						continue;
					}
				}
				else if( b->seg_in.hit_dist == a->seg_in.hit_dist )
					b->seg_in.hit_dist = a->seg_out.hit_dist;
				else
				{
					RT_GET_SEG( tmp, ap->a_resource )
					*tmp = *b;
					tmp->seg_in.hit_dist = a->seg_out.hit_dist;
					b->seg_out.hit_dist = a->seg_in.hit_dist;
					BU_LIST_APPEND( &a->l, &tmp->l )
				}
			}
			
			if( (a->seg_stp != ON_INT) || (b->seg_stp != ON_INT) )
			{
				b = BU_LIST_PNEXT( seg, &b->l );
				continue;
			}

			if( NOT_SEG_OVERLAP( a, b ) )
			{
				b = BU_LIST_PNEXT( seg, &b->l );
				continue;
			}

			#ifdef debug
			bu_log( "\tfound overlapping ON_INT segs:\n" );
			#endif

			if( a->seg_in.hit_dist == b->seg_in.hit_dist &&
			    a->seg_out.hit_dist == b->seg_out.hit_dist )
			{
				#ifdef debug
				bu_log( "Promoting A, eliminating B\n" );
				#endif

				a->seg_stp = ON_SURF;
				BU_LIST_DEQUEUE( &b->l )
				RT_FREE_SEG( b, ap->a_resource )
				break;
			}

			if( a->seg_out.hit_dist == b->seg_out.hit_dist )
			{
				b->seg_stp = ON_SURF;
				a->seg_out.hit_dist = b->seg_in.hit_dist;

				#ifdef debug
				bu_log( "Promoting B, reducing A:\n" );
				#endif
			}
			else if( a->seg_out.hit_dist < b->seg_out.hit_dist )
			{
				if( b->seg_in.hit_dist > a->seg_in.hit_dist )
				{
					RT_GET_SEG( tmp, ap->a_resource )
					tmp->seg_stp = ON_SURF;
					tmp->seg_in.hit_dist = b->seg_in.hit_dist;
					tmp->seg_out.hit_dist = a->seg_out.hit_dist;
					b->seg_in.hit_dist = a->seg_out.hit_dist;
					a->seg_out.hit_dist = tmp->seg_in.hit_dist;
					BU_LIST_INSERT( &b->l, &tmp->l )

					#ifdef debug
					bu_log( "--==__ overlap\n" );
					#endif
				}
				else
				{
					b->seg_in.hit_dist = a->seg_out.hit_dist;
					a->seg_stp = ON_SURF;

					#ifdef debug
					bu_log( "A within B\n" );
					#endif
				}
			}
			else
			{
				if( a->seg_in.hit_dist == b->seg_in.hit_dist )
				{
					fastf_t tmp_dist;

					tmp_dist = a->seg_out.hit_dist;
					a->seg_out.hit_dist = b->seg_out.hit_dist;
					a->seg_stp = ON_SURF;
					b->seg_in.hit_dist = a->seg_out.hit_dist;
					b->seg_out.hit_dist = tmp_dist;					
				}
				else
				{
					RT_GET_SEG( tmp, ap->a_resource )
					*tmp = *a;
					tmp->seg_in.hit_dist = b->seg_out.hit_dist;
					a->seg_out.hit_dist = b->seg_in.hit_dist;
					b->seg_stp = ON_SURF;
					BU_LIST_APPEND( &b->l, &tmp->l )

					#ifdef debug
					bu_log( "B within A:\n" );
					#endif
				}
			}
			b = BU_LIST_PNEXT( seg, &b->l );
		}
		a = BU_LIST_PNEXT( seg, &a->l );
	}

	#ifdef debug
	bu_log( "Results of promote_ints()\n" );
	show_seg( head, "SEGS" );
	#endif
}

/* Evaluate an operation on the operands (segment lists) */
HIDDEN struct bu_list *
eval_op( A, op, B )
struct bu_list *A;
int op;
struct bu_list *B;
{
	struct seg *sega, *segb, *tmp, *next;
	struct bu_list ret, ons, ins;
	int inserted;

	BU_LIST_INIT( &ret );

	#ifdef debug
	bu_log( "In eval_op:\n" );
	show_seg( A, "\tA:" );
	show_seg( B, "\tB:" );
	#endif

	switch( op )
	{
		case OP_SUBTRACT:

			#ifdef debug
			bu_log( "\t\tSUBTACT\n" );
			#endif

			if( BU_LIST_IS_EMPTY( A ) )
			{
				MY_FREE_SEG_LIST( B, ap->a_resource );
				bu_free( (char *)B, "bu_list" );

				#ifdef debug
				show_seg( A, "Returning" );
				#endif

				return( A );
			}
			else if( BU_LIST_IS_EMPTY( B ) )
			{
				bu_free( (char *)B, "bu_list" );

				#ifdef debug
				show_seg( A, "Returning" );
				#endif

				return( A );
			}

			/* A - B:
			 *	keep segments:
			 *			ON_A - IN_B
			 * 			ON_A + ON_B
			 *			ON_B + IN_A
			 *			IN_A - IN_B
			 */
			for( BU_LIST_FOR( sega, seg, A ) )
			{
				for( BU_LIST_FOR( segb, seg, B ) )
				{
					if( sega->seg_stp == ON_INT && segb->seg_stp == ON_INT )
						do_intersect( sega, segb, &ret, ON_SURF );
					else if( sega->seg_stp == ON_SURF || sega->seg_stp == ON_INT )
					{
						if( segb->seg_stp == IN_SOL )
							do_subtract( sega, segb, &ret );
						else
							do_intersect( sega, segb, &ret, sega->seg_stp );
					}
					else if( segb->seg_stp == ON_SURF ||  segb->seg_stp == ON_INT )
						do_intersect( segb, sega, &ret, segb->seg_stp );
					else
						do_subtract( sega, segb, &ret );
				}
			}
			MY_FREE_SEG_LIST( B, ap->a_resource );
			bu_free( (char *)B, "bu_list" );
			MY_FREE_SEG_LIST( A, ap->a_resource );
			BU_LIST_INSERT_LIST( A, &ret )

			#ifdef debug
			show_seg( A, "Returning" );
			#endif

			return( A );
		case OP_INTERSECT:

			#ifdef debug
			bu_log( "\t\tINTERSECT\n" );
			#endif

			if( BU_LIST_IS_EMPTY( A ) || BU_LIST_IS_EMPTY( B ) )
			{
				MY_FREE_SEG_LIST( A, ap->a_resource );
				MY_FREE_SEG_LIST( B, ap->a_resource );
				bu_free( (char *)B, "bu_list" );

				#ifdef debug
				show_seg( A, "Returning" );
				#endif

				return( A );
			}
			/* A + B
			 *	This is merely the intersection of segments from A with those from B
			 *	The two different calls to "do_intersect" get the types (IN, ON) right
			 */
			for( BU_LIST_FOR( sega, seg, A ) )
			{
				for( BU_LIST_FOR( segb, seg, B ) )
				{
					if( sega->seg_stp == ON_INT && segb->seg_stp == ON_INT )
						do_intersect( sega, segb, &ret, ON_SURF );
					else if( sega->seg_stp == ON_SURF || sega->seg_stp == ON_INT )
						do_intersect( sega, segb, &ret, sega->seg_stp );
					else
						do_intersect( segb, sega, &ret, segb->seg_stp );
				}
			}
			MY_FREE_SEG_LIST( B, ap->a_resource );
			bu_free( (char *)B, "bu_list" );
			MY_FREE_SEG_LIST( A, ap->a_resource );
			BU_LIST_INSERT_LIST( A, &ret )

			#ifdef debug
			show_seg( A, "Returning" );
			#endif

			return( A );
		case OP_UNION:

			#ifdef debug
			bu_log( "\t\tUNION\n" );
			#endif

			if( BU_LIST_IS_EMPTY( A ) )
			{
				bu_free( (char *)A, "bu_list" );

				#ifdef debug
				show_seg( B, "Returning B (A is empty)" );
				#endif

				return( B );
			}
			if( BU_LIST_IS_EMPTY( B ) )
			{
				bu_free( (char *)B, "bu_list" );

				#ifdef debug
				show_seg( A, "Returning A (B is empty)" );
				#endif

				return( A );
			}
			/* A u B:
			 *	keep segments:
			 *		ON_A - IN_B (ON)
			 *		IN_B + ON_A (IN )
			 *		ON_B - IN_A (ON)
			 *		IN_A + ON_B (IN)
			 * 		all remaining unique ON or IN segments
			 */

			/* create two new lists, one with all the ON segments,
			 * the other with all the IN segments
			 */
			BU_LIST_INIT( &ons )
			BU_LIST_INIT( &ins )

			/* Put the A operand segments on the lists */
			while( BU_LIST_WHILE( sega, seg, A ) )
			{
				BU_LIST_DEQUEUE( &sega->l )

				if( sega->seg_stp == ON_SURF || sega->seg_stp == ON_INT )
					BU_LIST_INSERT( &ons, &sega->l )
				else
					BU_LIST_INSERT( &ins, &sega->l )
			}

			/* insert the B operand segments in the lists (maintaining order from smaller starting
			 * hit distance to larger
			 */
			while( BU_LIST_WHILE( segb, seg, B ) )
			{
				int inserted;
				BU_LIST_DEQUEUE( &segb->l )

				if( segb->seg_stp == IN_SOL )
				{
					inserted = 0;
					for( BU_LIST_FOR( tmp, seg, &ins ) )
					{
						if( tmp->seg_in.hit_dist >= segb->seg_in.hit_dist )
						{
							inserted = 1;
							BU_LIST_INSERT( &tmp->l, &segb->l )
							break;
						}
					}
					if( !inserted )
						BU_LIST_INSERT( &ins, &segb->l )
				}
				else
				{
					inserted = 0;
					for( BU_LIST_FOR( tmp, seg, &ons ) )
					{
						if( tmp->seg_in.hit_dist >= segb->seg_in.hit_dist )
						{
							inserted = 1;
							BU_LIST_INSERT( &tmp->l, &segb->l )
							break;
						}
					}
					if( !inserted )
						BU_LIST_INSERT( &ons, &segb->l )
				}
			}

			/* promote intersecting ON_INT's to ON_SURF */
			promote_ints( &ons );

			/* make sure the segments are unique */
			eliminate_overlaps( &ins );
			eliminate_overlaps( &ons );

			#ifdef debug
			show_seg( &ons, "ONS" );
			show_seg( &ins, "INS" );
			#endif

			/* subtract INS from ONS */
			#ifdef debug
			bu_log( "doing subtraction:\n" );
			#endif
			sega = BU_LIST_FIRST( seg, &ons );
			while( BU_LIST_NOT_HEAD( &sega->l, &ons ) )
			{
				next = BU_LIST_PNEXT( seg, &sega->l );

				#ifdef debug
				bu_log( "A is %g to %g:\n", sega->seg_in.hit_dist, sega->seg_out.hit_dist );
				#endif

				for( BU_LIST_FOR( segb, seg, &ins ) )
				{
					#ifdef debug
					bu_log( "\tcomparing to B %g to %g\n", segb->seg_in.hit_dist, segb->seg_out.hit_dist );
					#endif

					if( NOT_SEG_OVERLAP( sega, segb ) )
					{
						#ifdef debug
						bu_log( "\t\tNo overlap!!\n" );
						#endif

						continue;
					}

					if( segb->seg_in.hit_dist <= sega->seg_in.hit_dist &&
					    segb->seg_out.hit_dist >= sega->seg_out.hit_dist )
					{
						#ifdef debug
						bu_log( "\t\teliminating A\n" );
						#endif

						/* eliminate sega */
						BU_LIST_DEQUEUE( &sega->l )
						RT_FREE_SEG( sega, ap->a_resource )
						sega = next;
						break;
					}

					if( segb->seg_in.hit_dist > sega->seg_in.hit_dist &&
					    segb->seg_out.hit_dist < sega->seg_out.hit_dist )
					{
						/* split sega */
						RT_GET_SEG( tmp, ap->a_resource )
						*tmp = *sega;
						tmp->seg_in.hit_dist = segb->seg_out.hit_dist;
						sega->seg_out.hit_dist = segb->seg_in.hit_dist;
						BU_LIST_APPEND( &sega->l, &tmp->l )
						next = tmp;

						#ifdef debug
						bu_log( "\t\tsplit A into: %g to %g and %g to %g\n", sega->seg_in.hit_dist, sega->seg_out.hit_dist, tmp->seg_in.hit_dist, tmp->seg_out.hit_dist );
						#endif
					}
					else
					{
						/* subtract edges */
						if( segb->seg_in.hit_dist > sega->seg_in.hit_dist )
							sega->seg_out.hit_dist = segb->seg_in.hit_dist;
						if( segb->seg_out.hit_dist < sega->seg_out.hit_dist )
							sega->seg_in.hit_dist = segb->seg_out.hit_dist;

						#ifdef debug
						bu_log( "\t\tsubtracted A down to %g to %g\n", sega->seg_in.hit_dist, sega->seg_out.hit_dist );
						#endif
					}
				}
				sega = next;
			}

			/* put the resuling ONS list on the result list */
			BU_LIST_INSERT_LIST( &ret, &ons )

			/* add INS to the return list (maintain order) */
			while( BU_LIST_WHILE( sega, seg, &ins ) )
			{
				BU_LIST_DEQUEUE( &sega->l )

				inserted = 0;
				for( BU_LIST_FOR( segb, seg, &ret ) )
				{
					if( sega->seg_in.hit_dist < segb->seg_in.hit_dist )
					{
						BU_LIST_INSERT( &segb->l, &sega->l )
						inserted = 1;
						break;
					}
				}

				if( !inserted )
					BU_LIST_INSERT( &ret, &sega->l )
			}

			MY_FREE_SEG_LIST( B, ap->a_resource );
			bu_free( (char *)B, "bu_list" );
			MY_FREE_SEG_LIST( A, ap->a_resource );
			BU_LIST_INSERT_LIST( A, &ret )

			#ifdef debug
			show_seg( A, "Returning" );
			#endif

			return( A );
	}

	/* should never get here */
	MY_FREE_SEG_LIST( A, ap->a_resource );
	MY_FREE_SEG_LIST( B, ap->a_resource );
	bu_free( (char *)B, "bu_list" );

	#ifdef debug
	show_seg( A, "Returning (default)" );
	#endif

	return( A );
	
}

/* evaluate an E-tree */
HIDDEN struct bu_list *
eval_etree( eptr )
union E_tree *eptr;
{
	struct bu_list *A, *B;

	CK_ETREE( eptr );

	#ifdef debug
	bu_log( "In eval_etree:\n" );
	#endif

	switch( eptr->l.op )
	{
		case OP_DB_LEAF:
		case OP_SOLID:
			A = (struct bu_list *)bu_malloc( sizeof( struct bu_list ), "bu_list" );
			BU_LIST_INIT( A );
			BU_LIST_INSERT_LIST( A, &eptr->l.seghead )

			#ifdef debug
			show_seg( A, "LEAF:" );
			#endif

			return( A );
		case OP_SUBTRACT:
		case OP_INTERSECT:
		case OP_UNION:
			#ifdef debug
			bu_log( "Evaluating subtrees\n" );
			#endif

			A = eval_etree( eptr->n.left );
			B = eval_etree( eptr->n.right );
			return( eval_op( A, eptr->n.op, B ) );
	}

	/* should never get here */
	return( (struct bu_list *)NULL );	/* for the compilers */
}

/* Shoot rays (corresponding to possible edges in the result)
 * at the solids, put the results in the E-tree leaves as type IN_SOL.
 * Call eval_etree() and plot the results
 */
HIDDEN void
shoot_and_plot( start_pt, dir, vhead, edge_len, skip_leaf1, skip_leaf2, eptr, type )
point_t start_pt;
vect_t dir;
struct bu_list *vhead;
fastf_t edge_len;
int skip_leaf1, skip_leaf2;
union E_tree *eptr;
struct soltab *type;
{
	struct xray rp;
	struct ray_data rd;
	int shoot_leaf;
	struct bu_list *final_segs;

	if( bu_debug&BU_DEBUG_MEM_CHECK && bu_mem_barriercheck() )
		bu_log( "Error at start of shoot_and_plot()\n" );

	CK_ETREE( eptr );

	bzero( &rd, sizeof( struct ray_data ) );

	BU_GETSTRUCT( rd.seghead, seg );
	BU_LIST_INIT( &rd.seghead->l );

	VMOVE( rp.r_pt, start_pt )
	VMOVE( rp.r_dir, dir )
	/* Compute the inverse of the direction cosines */
	if( !NEAR_ZERO( rp.r_dir[X], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[X]=1.0/rp.r_dir[X];
	} else {
		rd.rd_invdir[X] = INFINITY;
		rp.r_dir[X] = 0.0;
	}
	if( !NEAR_ZERO( rp.r_dir[Y], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[Y]=1.0/rp.r_dir[Y];
	} else {
		rd.rd_invdir[Y] = INFINITY;
		rp.r_dir[Y] = 0.0;
	}
	if( !NEAR_ZERO( rp.r_dir[Z], SQRT_SMALL_FASTF ) )  {
		rd.rd_invdir[Z]=1.0/rp.r_dir[Z];
	} else {
		rd.rd_invdir[Z] = INFINITY;
		rp.r_dir[Z] = 0.0;
	}

	/* set up "ray_data" structure for nmg raytrace */
	rd.rp = &rp;
	rd.tol = &mged_tol;
	rd.ap = ap;
	rd.magic = NMG_RAY_DATA_MAGIC;
	rd.classifying_ray = 0;
	rd.hitmiss = (struct hitmiss **)NULL;

	/* shoot this ray at every leaf solid except the one this edge came from
	 * (or the two that this intersection line came from
	 */
	for( shoot_leaf=0 ; shoot_leaf < BU_PTBL_END( &leaf_list ) ; shoot_leaf++ )
	{
		union E_tree *shoot;
		int dont_shoot=0;

		shoot = (union E_tree *)BU_PTBL_GET( &leaf_list, shoot_leaf );

		if( BU_LIST_NON_EMPTY( &shoot->l.seghead ) )
		{
			MY_FREE_SEG_LIST( &shoot->l.seghead, ap->a_resource );
		}
		BU_LIST_INIT( &shoot->l.seghead );

		/* don't shoot rays at the leaves that were the source of this possible edge */
		if( shoot_leaf == skip_leaf1 || shoot_leaf == skip_leaf2 )
			dont_shoot = 1;
		else
		{
			/* don't shoot at duplicate solids either */
			union E_tree *leaf;

			if( skip_leaf1 >= 0 )
			{
				leaf = (union E_tree *)BU_PTBL_GET( &leaf_list, skip_leaf1 );
				if( leaf->l.stp->st_dp == shoot->l.stp->st_dp )
				{
					if( !leaf->l.stp->st_matp && !shoot->l.stp->st_matp )
						dont_shoot = 1;
					else if( bn_mat_is_equal( leaf->l.stp->st_matp, shoot->l.stp->st_matp, &mged_tol ) )
						dont_shoot = 1;
				}
			}
			if( !dont_shoot && skip_leaf2 >= 0 )
			{
				leaf = (union E_tree *)BU_PTBL_GET( &leaf_list, skip_leaf2 );
				if( leaf->l.stp->st_dp == shoot->l.stp->st_dp )
				{
					if( !leaf->l.stp->st_matp && !shoot->l.stp->st_matp )
						dont_shoot = 1;
					else if( bn_mat_is_equal( leaf->l.stp->st_matp, shoot->l.stp->st_matp, &mged_tol ) )
						dont_shoot = 1;
				}
			}
		}

		if( dont_shoot )
		{
			struct seg *seg;

			/* put entire edge in seg list and mark it as ON the surface */
			RT_GET_SEG( seg, ap->a_resource );
			seg->l.magic = RT_SEG_MAGIC;
			seg->seg_in.hit_dist = 0.0;
			seg->seg_out.hit_dist = edge_len;
			seg->seg_stp = type;
			BU_LIST_INSERT( &shoot->l.seghead, &seg->l );
			continue;
		}

		/* initialize the lists of things that have been hit/missed */
		rd.rd_m = shoot->l.m;
		BU_LIST_INIT(&rd.rd_hit);
		BU_LIST_INIT(&rd.rd_miss);

		rd.stp = shoot->l.stp;

		/* actually shoot the ray, assign segments to the leaf, and mark them as IN_SOL */
		if( rt_in_rpp( &rp, rd.rd_invdir, shoot->l.stp->st_min, shoot->l.stp->st_max ) )
		{
			if( rt_functab[shoot->l.stp->st_id].ft_shot( shoot->l.stp, &rp, ap, rd.seghead ) )
			{
				struct seg *seg;

				/* put the segments in the lead solid structure */
				while( BU_LIST_WHILE( seg, seg, &rd.seghead->l ) )
				{
					BU_LIST_DEQUEUE( &seg->l )
					/* clip segments to the edge being considered */
					if( seg->seg_in.hit_dist >= edge_len || seg->seg_out.hit_dist <= 0 )
						RT_FREE_SEG( seg, ap->a_resource )
					else
					{
						if( seg->seg_in.hit_dist < 0.0 )
							seg->seg_in.hit_dist = 0.0;
						if( seg->seg_out.hit_dist > edge_len )
							seg->seg_out.hit_dist = edge_len;
						seg->seg_stp = IN_SOL;
						BU_LIST_INSERT(  &shoot->l.seghead, &seg->l )
					}
				}
			}
		}
	}

	/* Evaluate the Boolean tree to get the "final" segments
	 * which are to be plotted.
	 */
	#ifdef debug
	bu_log( "EVALUATING ETREE:\n" );
	bu_log( "ray start (%g %g %g), dir=(%g %g %g)\n", V3ARGS( start_pt ), V3ARGS( dir ) );
	#endif

	final_segs = eval_etree( eptr );

	#ifdef debug
	show_seg( final_segs, "DRAWING" );
	#endif

	if( final_segs )
	{
		struct seg *seg;

		/* add the segemnts to the VLIST */
		for( BU_LIST_FOR( seg, seg, final_segs ) )
		{
			point_t pt;

			/* only plot the resulting segments that are ON the SURFace */
			if( seg->seg_stp != ON_SURF )
				continue;

			nvectors++;
			VJOIN1( pt, rp.r_pt, seg->seg_in.hit_dist, rp.r_dir )

			#ifdef debug
			bu_log( "\t\tDRAW (%g %g %g)", V3ARGS( pt ) );
			#endif

			RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
			VJOIN1( pt, rp.r_pt, seg->seg_out.hit_dist, rp.r_dir )

			#ifdef debug
			bu_log( "<->(%g %g %g)\n", V3ARGS( pt ) );
			#endif

			RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
		}
		
	}

	if( final_segs )
		MY_FREE_SEG_LIST( final_segs, ap->a_resource );
	bu_free( (char *)final_segs, "bu_list" );

	if( bu_debug&BU_DEBUG_MEM_CHECK && bu_mem_barriercheck() )
		bu_log( "Error at end of shoot_and_plot()\n" );

}

HIDDEN void
Eplot( eptr, vhead )
union E_tree *eptr;
struct bu_list *vhead;
{
	int leaf_no;
	union E_tree *leaf_ptr;
	int hit_count=0;

	if( bu_debug&BU_DEBUG_MEM_CHECK && bu_mem_barriercheck() )
		bu_log( "Error at start of Eplot()\n" );

	CK_ETREE( eptr );

	/* create an edge list for each leaf solid */
	for( leaf_no=0 ; leaf_no < BU_PTBL_END( &leaf_list ) ; leaf_no++ )
	{
		leaf_ptr = (union E_tree *)BU_PTBL_GET( &leaf_list, leaf_no );
		CK_ETREE( leaf_ptr );
		if( leaf_ptr->l.op != OP_DB_LEAF && leaf_ptr->l.op != OP_SOLID )
		{
			Tcl_AppendResult(interp, "Eplot: Bad leaf node!!!\n", (char *)NULL );
			return;
		}

		if( leaf_ptr->l.m )
			nmg_edge_tabulate( &leaf_ptr->l.edge_list, &leaf_ptr->l.m->magic );
		else
			bu_ptbl_init( &leaf_ptr->l.edge_list, 1, "edge_list" );
	}

	/* now plot appropriate parts of each solid */

	/* loop through every leaf solid */
	for( leaf_no=0 ; leaf_no < BU_PTBL_END( &leaf_list ) ; leaf_no++ )
	{
		int edge_no;

		leaf_ptr = (union E_tree *)BU_PTBL_GET( &leaf_list, leaf_no );

		if( !leaf_ptr->l.m )
			continue;

		/* do each edge of the current leaf solid */
		for( edge_no=0 ; edge_no < BU_PTBL_END( &leaf_ptr->l.edge_list ) ; edge_no++ )
		{
			struct edge *e;
			struct vertex_g *vg;
			struct vertex_g *vg2;
			vect_t dir;
			fastf_t edge_len;
			fastf_t inv_len;

			e = (struct edge *)BU_PTBL_GET( &leaf_ptr->l.edge_list, edge_no );
			NMG_CK_EDGE( e );
			vg = e->eu_p->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G( vg );

			vg2 = e->eu_p->eumate_p->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G( vg2 );

			/* set up a ray from vg towards vg2 */
			VSUB2( dir, vg2->coord, vg->coord );
			edge_len = MAGNITUDE( dir );
			if( edge_len < mged_tol.dist )
				continue;
			inv_len = 1.0/edge_len;
			VSCALE( dir, dir, inv_len );
			shoot_and_plot( vg->coord, dir, vhead, edge_len, leaf_no, -1, eptr, ON_SURF );

		}
	}

	/* Now draw solid intersection lines */
	for( leaf_no=0 ; leaf_no < BU_PTBL_END( &leaf_list ) ; leaf_no++ )
	{
		int leaf2;

		leaf_ptr = (union E_tree *)BU_PTBL_GET( &leaf_list, leaf_no );
		if( !leaf_ptr->l.m )
			continue;

		for( leaf2=leaf_no+1 ; leaf2 < BU_PTBL_END( &leaf_list ) ; leaf2++ )
		{
			union E_tree *leaf2_ptr;
			struct nmgregion *r1, *r2;
			struct shell *s1, *s2;
			struct faceuse *fu1, *fu2;
			struct face *f1, *f2;
			plane_t pl1, pl2;
			struct loopuse *lu1, *lu2;
			struct edgeuse *eu1, *eu2;
			struct vertex_g *vg1a, *vg1b, *vg2a, *vg2b;

			leaf2_ptr = (union E_tree *)BU_PTBL_GET( &leaf_list, leaf2 );
			if( !leaf2_ptr->l.m )
				continue;

			/* find intersection lines between these two NMG's */

			r1 = BU_LIST_FIRST( nmgregion, &leaf_ptr->l.m->r_hd );
			s1 = BU_LIST_FIRST( shell, &r1->s_hd );
			r2 = BU_LIST_FIRST( nmgregion, &leaf2_ptr->l.m->r_hd );
			s2 = BU_LIST_FIRST( shell, &r2->s_hd );

			for( BU_LIST_FOR( fu1, faceuse, &s1->fu_hd ) )
			{
				if( fu1->orientation != OT_SAME )
					continue;

				f1 = fu1->f_p;
				NMG_GET_FU_PLANE( pl1, fu1 );

				for( BU_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )
				{
					fastf_t dist;
					fastf_t len,start_len;
					point_t hits[4];
					point_t start_pt;
					vect_t dir;
					vect_t to_hit;
					fastf_t inv_len;
					fastf_t lena, lenb;
					vect_t diff;

					if( fu2->orientation != OT_SAME )
						continue;

					f2 = fu2->f_p;

					if ( !V3RPP_OVERLAP_TOL(f2->min_pt, f2->max_pt,
						f1->min_pt, f1->max_pt, &mged_tol) )
							continue;

					NMG_GET_FU_PLANE( pl2, fu2 );

					if( bn_coplanar( pl1, pl2, &mged_tol ) )
						continue;

					hit_count=0;
					for( BU_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )
					{
						if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_EDGEUSE_MAGIC )
							continue;

						for( BU_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )
						{
							vg1a = eu1->vu_p->v_p->vg_p;
							vg1b = eu1->eumate_p->vu_p->v_p->vg_p;
							VSUB2( dir, vg1b->coord, vg1a->coord );

							/* find intersection of this edge with fu2 */

							if( bn_isect_line3_plane( &dist, vg1a->coord, dir, pl2, &mged_tol ) < 1 )
								continue;
							if( dist < 0.0 || dist > 1.0 )
								continue;

							VJOIN1( hits[hit_count], vg1a->coord, dist, dir )
							if( hit_count == 1 )
							{
								VSUB2( diff, hits[hit_count], hits[hit_count-1] )
								len = MAGSQ( diff );
								if ( NEAR_ZERO( len, mged_tol.dist_sq ) )
									continue;
							}
							hit_count++;
							if( hit_count == 2 )
								break;
						}
						if( hit_count == 2 )
							break;
					}
					for( BU_LIST_FOR( lu2, loopuse, &fu2->lu_hd ) )
					{
						if( BU_LIST_FIRST_MAGIC( &lu2->down_hd ) != NMG_EDGEUSE_MAGIC )
							continue;

						for( BU_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )
						{
							vg2a = eu2->vu_p->v_p->vg_p;
							vg2b = eu2->eumate_p->vu_p->v_p->vg_p;
							VSUB2( dir, vg2b->coord, vg2a->coord );

							/* find intersection of this edge with fu1 */

							if( bn_isect_line3_plane( &dist, vg2a->coord, dir, pl1, &mged_tol ) < 1 )
								continue;

							if( dist < 0.0 || dist > 1.0 )
								continue;

							VJOIN1( hits[hit_count], vg2a->coord, dist, dir )
							if( hit_count == 3 )
							{
								VSUB2( diff, hits[hit_count], hits[hit_count-1] )
								len = MAGSQ( diff );
								if ( NEAR_ZERO( len, mged_tol.dist_sq ) )
									continue;
							}
							hit_count++;
							if( hit_count == 4 )
								break;
						}
						if( hit_count == 4 )
							break;
					}

					/* now should have 4 hit points along line of intersection */
					if( hit_count != 4 )
						continue;

					VSUB2( dir, hits[1], hits[0] )
					len = MAGNITUDE( dir );
					if( len < mged_tol.dist )
						continue;
					inv_len = 1.0/len;
					VSCALE( dir, dir, inv_len )
					VSUB2( to_hit, hits[2], hits[0] )
					lena = VDOT( to_hit, dir );
					VSUB2( to_hit, hits[3], hits[0] )
					lenb = VDOT( to_hit, dir );
					if( lena > lenb )
					{
						dist = lena;
						lena = lenb;
						lenb = dist;
						VMOVE( start_pt, hits[3] )
						VMOVE( hits[2], hits[3] )
						VMOVE( hits[3], start_pt )
					}

					if( lena > len )
						continue;
					if( lenb < 0.0 )
						continue;

					if( lena > 0.0 )
					{
						VMOVE( start_pt, hits[2] )
						start_len = lena;
					}
					else
					{
						VMOVE( start_pt, hits[0] )
						start_len = 0.0;
					}

					if( lenb < len )
						len = lenb;

					shoot_and_plot( start_pt, dir, vhead, len-start_len, leaf_no, leaf2, eptr, ON_INT );
				}
			}
		}
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK && bu_mem_barriercheck() )
		bu_log( "Error at end of Eplot()\n" );

}

HIDDEN void
free_etree( eptr )
union E_tree *eptr;
{
	CK_ETREE( eptr );

	switch( eptr->l.op )
	{
		case OP_UNION:
		case OP_SUBTRACT:
		case OP_INTERSECT:
			free_etree( eptr->n.left );
			free_etree( eptr->n.right );
			bu_free( (char *)eptr, "node pointer" );
			break;
		case OP_DB_LEAF:
		case OP_SOLID:
			if( eptr->l.m && !eptr->l.do_not_free_model )
			{
				nmg_km( eptr->l.m );
				eptr->l.m = (struct model *)NULL;
			}
			if( BU_LIST_NON_EMPTY( &eptr->l.seghead ) )
			{
				MY_FREE_SEG_LIST( &eptr->l.seghead, ap->a_resource );
			}
			if( BU_LIST_NON_EMPTY( &eptr->l.edge_list.l ) )
			{
				bu_ptbl_free( &eptr->l.edge_list );
			}
			if( eptr->l.stp )
			{
				if( eptr->l.stp->st_specific )
					rt_functab[eptr->l.stp->st_id].ft_free( eptr->l.stp );
				bu_free( (char *)eptr->l.stp, "struct soltab" );
			}

			bu_free( (char *)eptr, "leaf pointer" );
			break;
	}
}

/* convert all "half" solids to polysolids */
HIDDEN void
fix_halfs()
{
	point_t max, min;
	int i, count=0;

	VSETALL( max, -MAX_FASTF )
	VSETALL( min, MAX_FASTF )

	for( i=0 ; i<BU_PTBL_END( &leaf_list ) ; i++ )
	{
		union E_tree *tp;

		tp = (union E_tree *)BU_PTBL_GET( &leaf_list, i );

		if( tp->l.stp->st_id == ID_HALF )
			continue;

		VMINMAX( min, max, tp->l.stp->st_min )
		VMINMAX( min, max, tp->l.stp->st_max )
		count++;
	}

	if( !count )
	{
		Tcl_AppendResult(interp, "A 'half' solid is the only solid in a region (ignored)\n", (char *)NULL );
		return;
	}

	for( i=0 ; i<BU_PTBL_END( &leaf_list ) ; i++ )
	{
		union E_tree *tp;
		struct vertex *v[8];
		struct vertex **vp[4];
		struct nmgregion *r;
		struct shell *s;
		struct rt_pg_internal *pg;
		struct faceuse *fu;
		plane_t haf_pl;
		struct half_specific *hp;
		int j;

		tp = (union E_tree *)BU_PTBL_GET( &leaf_list, i );

		if( tp->l.stp->st_id != ID_HALF )
			continue;

		hp = (struct half_specific *)tp->l.stp->st_specific;

		HMOVE( haf_pl, hp->half_eqn )

		if( DIST_PT_PLANE( max, haf_pl ) >= -mged_tol.dist && DIST_PT_PLANE( min, haf_pl ) >= -mged_tol.dist )
			continue;

		/* make an NMG the size of our model bounding box */
		tp->l.m = nmg_mm();
		r = nmg_mrsv( tp->l.m );
		s = BU_LIST_FIRST( shell, &r->s_hd );

		for( j=0 ; j<8 ; j++ )
			v[j] = (struct vertex *)NULL;

		vp[0] = &v[0];
		vp[1] = &v[1];
		vp[2] = &v[2];
		vp[3] = &v[3];
		fu = nmg_cmface( s, vp, 4 );
		nmg_vertex_g( v[0], max[X], min[Y], min[Z] );
		nmg_vertex_g( v[1], max[X], max[Y], min[Z] );
		nmg_vertex_g( v[2], max[X], max[Y], max[Z] );
		nmg_vertex_g( v[3], max[X], min[Y], max[Z] );
		nmg_calc_face_g( fu );

		vp[0] = &v[4];
		vp[1] = &v[5];
		vp[2] = &v[6];
		vp[3] = &v[7];
		fu = nmg_cmface( s, vp, 4 );
		nmg_vertex_g( v[4], min[X], min[Y], min[Z] );
		nmg_vertex_g( v[5], min[X], min[Y], max[Z] );
		nmg_vertex_g( v[6], min[X], max[Y], max[Z] );
		nmg_vertex_g( v[7], min[X], max[Y], min[Z] );
		nmg_calc_face_g( fu );

		vp[0] = &v[0];
		vp[1] = &v[3];
		vp[2] = &v[5];
		vp[3] = &v[4];
		fu = nmg_cmface( s, vp, 4 );
		nmg_calc_face_g( fu );

		vp[0] = &v[1];
		vp[1] = &v[7];
		vp[2] = &v[6];
		vp[3] = &v[2];
		fu = nmg_cmface( s, vp, 4 );
		nmg_calc_face_g( fu );

		vp[0] = &v[3];
		vp[1] = &v[2];
		vp[2] = &v[6];
		vp[3] = &v[5];
		fu = nmg_cmface( s, vp, 4 );
		nmg_calc_face_g( fu );

		vp[0] = &v[1];
		vp[1] = &v[0];
		vp[2] = &v[4];
		vp[3] = &v[7];
		fu = nmg_cmface( s, vp, 4 );
		nmg_calc_face_g( fu );

		nmg_region_a( r, &mged_tol );

		for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
		{
			struct edgeuse *eu, *new_eu;
			struct loopuse *lu, *new_lu;
			plane_t pl;
			int count;
			struct vertexuse *vcut[2];
			point_t pt[2];
			struct edgeuse *eu_split[2];

			if( fu->orientation != OT_SAME )
				continue;

			NMG_GET_FU_PLANE( pl, fu );

			if( bn_coplanar( pl, haf_pl, &mged_tol ) > 0 )
				continue;

			lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );

			count = 0;
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				vect_t dir;
				struct vertex_g *v1g, *v2g;
				fastf_t dist;

				v1g = eu->vu_p->v_p->vg_p;
				v2g = eu->eumate_p->vu_p->v_p->vg_p;

				VSUB2( dir, v2g->coord, v1g->coord )

				if( bn_isect_line3_plane( &dist, v1g->coord, dir, haf_pl, &mged_tol ) < 1 )
					continue;

				if( dist < 0.0 || dist >=1.0 )
					continue;

				VJOIN1( pt[count], v1g->coord, dist, dir )
				eu_split[count] = eu;

				count++;
				if( count == 2 )
					break;
			}

			if( count != 2 )
				continue;

			new_eu = nmg_eusplit( (struct vertex *)NULL, eu_split[0], 1 );
			vcut[0] = new_eu->vu_p;
			nmg_vertex_gv( vcut[0]->v_p, pt[0] );

			new_eu = nmg_eusplit( (struct vertex *)NULL, eu_split[1], 1 );
			vcut[1] = new_eu->vu_p;
			nmg_vertex_gv( vcut[1]->v_p, pt[1] );

			new_lu = nmg_cut_loop( vcut[0], vcut[1] );
			nmg_lu_reorient( lu );
			nmg_lu_reorient( new_lu );

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				if( eu->vu_p->v_p == vcut[0]->v_p || eu->vu_p->v_p == vcut[1]->v_p )
					continue;

				if( DIST_PT_PLANE( eu->vu_p->v_p->vg_p->coord, haf_pl ) > mged_tol.dist )
				{
					nmg_klu( lu );
					break;
				}
				else
				{
					nmg_klu( new_lu );
					break;
				}
			}
		}

		/* kill any faces outside the half */
		fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
		if( fu->orientation != OT_SAME )
			fu = BU_LIST_PNEXT( faceuse, &fu->l );
		while( BU_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
		{
			struct faceuse *next_fu;
			struct loopuse *lu;
			int killfu=0;

			next_fu = BU_LIST_PNEXT( faceuse, &fu->l );
			if( fu->fumate_p == next_fu )
				next_fu = BU_LIST_PNEXT( faceuse, &next_fu->l );

			if( fu->orientation != OT_SAME )
			{
				fu = next_fu;
				continue;
			}

			lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
			while( BU_LIST_NOT_HEAD( &lu->l, &fu->lu_hd ) )
			{
				struct loopuse *next_lu;
				struct edgeuse *eu;
				int killit;

				next_lu = BU_LIST_PNEXT( loopuse, &lu->l );

				killit = 0;
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					struct vertex_g *vg;

					vg = eu->vu_p->v_p->vg_p;

					if( DIST_PT_PLANE( vg->coord, haf_pl ) > mged_tol.dist )
					{
						killit = 1;
						break;
					}
				}

				if( killit )
				{
					if( nmg_klu( lu ) )
					{
						killfu = 1;
						break;
					}
				}
				lu = next_lu;
			}

			if( killfu )
				nmg_kfu( fu );

			fu = next_fu;
		}

		nmg_rebound( tp->l.m, &mged_tol );
		nmg_model_fuse( tp->l.m, &mged_tol );
		nmg_close_shell( s, &mged_tol );
		nmg_rebound( tp->l.m, &mged_tol );

		BU_GETSTRUCT( pg, rt_pg_internal );

		if( !nmg_to_poly( tp->l.m, pg, &mged_tol ) )
		{
			bu_free( (char *)pg, "rt_pg_internal" );
			Tcl_AppendResult(interp, "Prep failure for solid '", tp->l.stp->st_dp->d_namep,
				"'\n", (char *)NULL );
		}
		else
		{
			struct rt_db_internal intern2;

			RT_INIT_DB_INTERNAL( &intern2 );
			intern2.idb_type = ID_POLY;
			intern2.idb_meth = &rt_functab[ID_POLY];
			intern2.idb_ptr = (genptr_t)pg;
			rt_functab[tp->l.stp->st_id].ft_free( tp->l.stp );
			tp->l.stp->st_specific = NULL;
			tp->l.stp->st_id = ID_POLY;
			VSETALL( tp->l.stp->st_max, -INFINITY );
			VSETALL( tp->l.stp->st_min,  INFINITY );
			if (rt_functab[ID_POLY].ft_prep( tp->l.stp, &intern2, rtip ) < 0 )
			{
				Tcl_AppendResult(interp, "Prep failure for polysolid version of solid '", tp->l.stp->st_dp->d_namep,
					"'\n", (char *)NULL );
			}

			rt_db_free_internal( &intern2, &rt_uniresource );
		}
	}
}

/*
 *			F _ E V E D I T
 *
 *  The "Big E" command.
 *  Evaluated Edit something (add to visible display)
 *  Usage: E object(s)
 */
int
f_evedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	int	initial_blank_screen;
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
	register struct cmd_list *save_cmd_list;
	int ret;

	CHECK_DBI_NULL;
	initial_blank_screen = BU_LIST_IS_EMPTY(&dgop->dgo_headSolid);

	if ((ret = dgo_E_cmd(dgop, interp, argc, argv)) != TCL_OK)
		return ret;

	update_views = 1;

	save_dmlp = curr_dm_list;
	save_cmd_list = curr_cmd_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
		curr_dm_list = dmlp;
		if (curr_dm_list->dml_tie)
			curr_cmd_list = curr_dm_list->dml_tie;
		else
			curr_cmd_list = &head_cmd_list;

		/* If we went from blank screen to non-blank, resize */
		if (mged_variables->mv_autosize  && initial_blank_screen &&
		    BU_LIST_NON_EMPTY(&dgop->dgo_headSolid)) {
			struct view_ring *vrp;

			size_reset();
			new_mats();
			(void)mged_svbase();

			for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
#ifdef MGED_USE_VIEW_OBJ
				vrp->vr_scale = view_state->vs_vop->vo_scale;
#else
			vrp->vr_scale = view_state->vs_Viewscale;
#endif
		}
	}

	curr_dm_list = save_dmlp;
	curr_cmd_list = save_cmd_list;

	return TCL_OK;
}
#endif
@


11.50
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d15 1
a15 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.49 2001/05/03 18:53:46 jra Exp $ (BRL)";
@


11.49
log
@the "E" command now uses BoT's instead of polysolids for intermediate calculations
@
text
@d15 1
a15 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.48 2000/10/24 19:58:14 mike Exp $ (BRL)";
d18 1
d780 1
a781 1
int op;
a1992 2
	char perf_message[128];
	register int    c;
d1996 1
d1998 2
a1999 2
	if(argc < 2){
	  struct bu_vls vls;
d2001 2
a2002 6
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help E");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}
d2004 1
a2004 136
/*	bu_debug = BU_DEBUG_MEM_CHECK; */
	if( bu_debug&BU_DEBUG_MEM_CHECK && bu_mem_barriercheck() )
		bu_log( "Error at start of 'E'\n" );

	do_polysolids = 0;
	mged_wireframe_color_override = 0;

	/* Parse options. */
	bu_optind = 1;          /* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"sC:")) != EOF ) {
		switch(c) {
		case 'C':
			{
				int		r,g,b;
				register char	*cp = bu_optarg;

				r = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				g = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				b = atoi(cp);

				if( r < 0 || r > 255 )  r = 255;
				if( g < 0 || g > 255 )  g = 255;
				if( b < 0 || b > 255 )  b = 255;

				mged_wireframe_color_override = 1;
				mged_wireframe_color[0] = r;
				mged_wireframe_color[1] = g;
				mged_wireframe_color[2] = b;
			}
			break;
		case 's':
			do_polysolids = 1;
			break;
		default:
			{
				struct bu_vls vls;

				bu_vls_init(&vls);
				bu_vls_printf(&vls, "help %s", argv[0]);
				Tcl_Eval(interp, bu_vls_addr(&vls));
				bu_vls_free(&vls);

				return TCL_ERROR;
			}
		}
	}
	argc -= bu_optind;
	argv += bu_optind;

	initial_blank_screen = BU_LIST_IS_EMPTY(&HeadSolid.l);
	eraseobjpath(interp, argc, argv, LOOKUP_QUIET, 0);

	mged_ttol.magic = RT_TESS_TOL_MAGIC;
	mged_ttol.abs = mged_abs_tol;
	mged_ttol.rel = mged_rel_tol;
	mged_ttol.norm = mged_nrm_tol;

	if( !ap )
	{
		ap = (struct application *)bu_calloc( 1, sizeof( struct application ), "Big E app" );
		ap->a_resource = &rt_uniresource;
		rt_uniresource.re_magic = RESOURCE_MAGIC;
		if( BU_LIST_UNINITIALIZED( &rt_uniresource.re_nmgfree ) )
			BU_LIST_INIT( &rt_uniresource.re_nmgfree );
	}

	bu_ptbl_init( &leaf_list, 8, "leaf_list" );

	if( setjmp( jmp_env ) == 0 )
		(void)signal( SIGINT, sig3 ); /* allow interupts */
	else
	{
		bu_ptbl_free( &leaf_list );
		return( TCL_OK );
	}

	rtip = rt_new_rti( dbip );
	rtip->rti_tol = mged_tol;	/* struct copy */
	ap->a_rt_i = rtip;

	nvectors = 0;
	(void)time( &start_time );

	if( rt_gettrees( rtip, argc, (const char **)argv, 1 ) )
	{
		bu_ptbl_free( &leaf_list );
		(void)signal( SIGINT, SIG_IGN );

		/* do not do an rt_free_rti() (closes the database!!!!) */
		rt_clean( rtip );

		bu_free( (char *)rtip, "rt_i structure for 'E'" );

		Tcl_AppendResult(interp, "Failed to get objects\n", (char *)NULL);
		return TCL_ERROR;
	}
	{
		struct region *rp;
		union E_tree *eptr;
		struct bu_list vhead;
		struct db_tree_state ts;
		struct db_full_path path;

		BU_LIST_INIT( &vhead );

		for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
			num_halfs = 0;
			eptr = build_etree( rp->reg_treetop );

			if( num_halfs )
				fix_halfs();

			Eplot( eptr, &vhead );
			free_etree( eptr );
			bu_ptbl_reset( &leaf_list );
			ts.ts_mater = rp->reg_mater;
			db_string_to_path( &path, dbip, rp->reg_name );
			drawH_part2( 0, &vhead, &path, &ts, SOLID_NULL );
			db_free_full_path( &path );
		}
		/* do not do an rt_free_rti() (closes the database!!!!) */
		rt_clean( rtip );

		bu_free( (char *)rtip, "rt_i structure for 'E'" );
	}

	(void)time( &etime );

	(void)signal( SIGINT, SIG_IGN );

	/* free leaf_list */
	bu_ptbl_free( &leaf_list );
d2009 5
a2013 18
	  curr_dm_list = dmlp;
	  if(curr_dm_list->dml_tie)
	    curr_cmd_list = curr_dm_list->dml_tie;
	  else
	    curr_cmd_list = &head_cmd_list;

	  /* If we went from blank screen to non-blank, resize */
	  if (mged_variables->mv_autosize  && initial_blank_screen &&
	      BU_LIST_NON_EMPTY(&HeadSolid.l)) {
	    struct view_ring *vrp;

	    size_reset();
	    new_mats();
	    (void)mged_svbase();

	    for(BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
	      vrp->vr_scale = view_state->vs_Viewscale;
	  }
d2015 16
a2030 1
	  color_soltab();
a2035 4
	sprintf(perf_message, "E: %ld vectors in %ld sec\n", nvectors, (long)(etime - start_time) );
	Tcl_AppendResult(interp, perf_message, (char *)NULL);

	update_views = 1;
d2038 1
@


11.48
log
@
Possible uninit
@
text
@d15 1
a15 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.47 2000/10/24 19:05:07 mike Exp $ (BRL)";
d206 1
a206 1
		struct rt_pg_internal *pg;
d211 2
a212 1
			/* create and prep a polysolid version of this solid */
d214 5
a218 1
			BU_GETSTRUCT( pg, rt_pg_internal );
d220 3
a222 1
			if( !solid_is_plate_mode_bot || !eptr->l.m || !nmg_to_poly( eptr->l.m, pg, &mged_tol ) )
a223 1
				bu_free( (char *)pg, "rt_pg_internal" );
d232 5
a236 5
				intern2.idb_type = ID_POLY;
				intern2.idb_meth = &rt_functab[ID_POLY];
				intern2.idb_ptr = (genptr_t)pg;
				eptr->l.stp->st_id = ID_POLY;
				if (rt_functab[ID_POLY].ft_prep( eptr->l.stp, &intern2, rtip ) < 0 )
@


11.47
log
@
Fixed compiler lint, function declarations.
@
text
@d15 1
a15 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.46 2000/10/24 15:14:13 mike Exp $ (BRL)";
d264 1
a264 1
	union E_tree *eptr;
d303 2
@


11.46
log
@
compiler lint
@
text
@d15 1
a15 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.45 2000/09/08 05:55:49 mike Exp $ (BRL)";
d34 1
a35 1
#include "rtgeom.h"
@


11.45
log
@
Tree routines now need resource structure.
@
text
@d15 1
a15 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.44 2000/08/19 03:10:48 mike Exp $ (BRL)";
a1982 1
	int i;
@


11.44
log
@
const RCSid
@
text
@d15 1
a15 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.43 2000/08/19 03:10:16 mike Exp $ (BRL)";
d134 1
a134 1
	id = rt_db_get_internal( &intern, dp, dbip, mat );
d154 1
a154 1
		rt_db_free_internal( &intern );
d236 1
a236 1
				rt_db_free_internal( &intern2 );
d251 1
a251 1
		rt_db_free_internal( &intern );
d1964 1
a1964 1
			rt_db_free_internal( &intern2 );
@


11.43
log
@
Reduced use of MAXARGS
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.42 2000/06/21 12:21:06 jra Exp $ (BRL)";
@


11.42
log
@Fixed a minor bug
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.41 2000/06/19 18:20:12 jra Exp $ (BRL)";
d1991 1
a1991 1
	if(argc < 2 || MAXARGS < argc){
@


11.41
log
@Plate mode bots now can be tessellated (sort of)
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.40 2000/06/19 17:35:53 jra Exp $ (BRL)";
a1655 2
				if( eptr->l.m == eptr->l.stp->st_specific )
					eptr->l.stp->st_specific = GENPTR_NULL;
@


11.40
log
@Fixed a bug in the "E" command. Plate mode BOTS are treated as solid BOTS.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.39 2000/06/06 21:05:17 jra Exp $ (BRL)";
d157 1
a157 1

d174 1
a174 1

@


11.39
log
@"E" command was bombing when given non-existent object names
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.38 2000/06/05 21:03:26 jra Exp $ (BRL)";
d106 2
d129 1
d158 17
d180 6
d215 1
a215 1
			if( ! eptr->l.m || !nmg_to_poly( eptr->l.m, pg, &mged_tol ) )
d250 2
a251 1
	rt_db_free_internal( &intern );
d1653 1
a1653 1
			if( eptr->l.m )
d1656 2
d1670 2
a1671 1
				rt_functab[eptr->l.stp->st_id].ft_free( eptr->l.stp );
@


11.38
log
@add_solid() routine wasn't setting magic numbers in soltab structure.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.37 2000/05/26 14:00:42 bparker Exp $ (BRL)";
d2061 6
a2066 1
		bu_bomb( "rt_gettrees failed!!\n" );
d2068 5
@


11.37
log
@*- mods that reflect parameter changes to
   eraseobj and eraseobjall
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.36 1999/12/30 19:50:30 jra Exp $ (BRL)";
d174 2
@


11.36
log
@Eliminated some unused variables
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.35 1999/12/23 06:13:17 mike Exp $ (BRL)";
a1953 1
	struct directory *dp;
d2025 1
a2025 8

	for( i=0; i<argc; i++ )
	{
		if( (dp = db_lookup( dbip,  argv[i], LOOKUP_QUIET )) != DIR_NULL )
		{
			eraseobj( dp );
		}
	}
@


11.35
log
@
struct region is now a bu_list
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.34 1999/12/22 20:15:36 mike Exp $ (BRL)";
a82 36

/*
 * The tree walker neds to have an initial state.  We could
 * steal it from doview.c but there is no real reason.
 */

static struct db_tree_state E_initial_tree_state = {
	0,			/* ts_dbip */
	0,			/* ts_sofar */
	0,0,0,			/* region, air, gmater */
	100,			/* GIFT los */
#if __STDC__
	{
#endif
		/* struct mater_info ts_mater */
		1.0, 0.0, 0.0,	/* color, RGB */
		-1.0,		/* Temperature */
		0,		/* override */
		0,		/* color inherit */
		0,		/* mater inherit */
#if 0
		""		/* shader */
#else
		NULL		/* shader */
#endif
#if __STDC__
	}
#endif
	,
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0,
};


d314 1
a314 1
	struct seg *a, *b, *nexta, *nextb;
d747 1
a747 1
	int found, inserted;
a1351 1
	struct ray_data rd;
a1391 1
			struct edgeuse *eu;
a1460 1
					fastf_t old_dist;
a1484 1
					old_dist = MAX_FASTF;
a1517 1
					old_dist = MAX_FASTF;
a1766 1
			struct vertexuse *vu;
a1788 1
				struct edgeuse *new_eu;
a1874 1
					fastf_t dist;
a1877 1
					dist = DIST_PT_PLANE( vg->coord, haf_pl );
a1984 1
				char		buf[128];
a2033 4

	E_initial_tree_state.ts_ttol = &mged_ttol;
	E_initial_tree_state.ts_tol  = &mged_tol;
	E_initial_tree_state.ts_stop_at_regions = 1;
@


11.34
log
@
Removed breaks after returns.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.33 1999/11/24 14:26:42 jra Exp $ (BRL)";
d2128 1
a2128 3
		rp = rtip->HeadRegion;
		while( rp )
		{
a2141 2

			rp = rp->reg_forw;
@


11.33
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.32 1999/10/07 20:32:08 jra Exp $ (BRL)";
a858 1
			break;
a902 1
			break;
a1112 1
			break;
@


11.32
log
@Added handling for dead solids (NOP) in region trees
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.31 1999/10/04 17:26:57 jra Exp $ (BRL)";
d235 1
d1969 1
@


11.31
log
@Mods to use rt_gettrees() (so that non-union operations above regions will work)
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.30 1999/09/30 19:54:40 jra Exp $ (BRL)";
d302 6
@


11.30
log
@Modified "E" command to get more accurate results
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.29 1999/01/12 18:16:21 bparker Exp $ (BRL)";
d51 1
d58 1
d63 1
d75 8
d154 111
d271 1
a271 1
	struct nmgregion *r;
a272 2
	struct rt_db_internal intern;
	int id;
a275 3
	BU_GETUNION( eptr, E_tree );
	eptr->magic = E_TREE_MAGIC;

d281 2
d287 3
a289 1
		case OP_DB_LEAF:
d292 2
d299 3
a301 80
			id = rt_db_get_internal( &intern, dp, dbip, tp->tr_l.tl_mat );
			if( id < 0 )
			{
				Tcl_AppendResult(interp, "Failed to get internal form of ",
					dp->d_namep, "\n", (char *)NULL );
				eptr->l.m = (struct model *)NULL;
				break;
			}
			if( id == ID_COMBINATION )
			{
				/* do explicit expansion of referenced combinations */

				struct rt_comb_internal *comb;

				bu_free( (char *)eptr, "eptr" );

				comb = (struct rt_comb_internal *)intern.idb_ptr;
				RT_CK_COMB( comb );

				eptr = build_etree( comb->tree );
				rt_db_free_internal( &intern );
				break;
			}

			/* create the NMG version of this solid */
			eptr->l.m = nmg_mm();
			if (rt_functab[id].ft_tessellate( &r, eptr->l.m, &intern,
				&mged_ttol, &mged_tol) < 0)
			{
				Tcl_AppendResult(interp, "Tessellation failed for ", dp->d_namep,
					"\n", (char *)NULL );
			}

			/* get the soltab stuff */
			BU_GETSTRUCT( eptr->l.stp, soltab );
			eptr->l.stp->st_dp = dp;
			eptr->l.stp->st_matp = tp->tr_l.tl_mat;

			{
				struct rt_pg_internal *pg;
				struct rt_db_internal intern2;

				if( do_polysolids )
				{
					/* create and prep a polysolid version of this solid */

					eptr->l.stp->st_id = ID_POLY;
					BU_GETSTRUCT( pg, rt_pg_internal );

					if( !nmg_to_poly( eptr->l.m, pg, &mged_tol ) )
					{
						Tcl_AppendResult(interp, "Failed to convert '",
							dp->d_namep, "' to a polysolid\n", (char *)NULL );
					}
					RT_INIT_DB_INTERNAL( &intern2 );
					intern2.idb_type = ID_POLY;
					intern2.idb_ptr = (genptr_t)pg;
					if (rt_functab[ID_POLY].ft_prep( eptr->l.stp, &intern2, rtip ) < 0 )
					{
						Tcl_AppendResult(interp, "Prep failure for solid '", dp->d_namep,
							"'\n", (char *)NULL );
					}

					rt_db_free_internal( &intern2 );
				}
				else
				{
					/* prep this solid */

					eptr->l.stp->st_id = id;
					if( rt_functab[id].ft_prep( eptr->l.stp, &intern, rtip ) < 0 )
						Tcl_AppendResult(interp, "Prep failure for solid '", dp->d_namep,
							"'\n", (char *)NULL );
				}
			}

			rt_db_free_internal( &intern );

			/* add this leaf to the leaf list */
			bu_ptbl_ins( &leaf_list, (long *)eptr );
d326 3
a328 1
					bu_log( "\t %g to %g (ON)\n", ptr->seg_in.hit_dist, ptr->seg_out.hit_dist );
d360 3
a362 1
				a->seg_out.hit_dist = b->seg_out.hit_dist;
d377 1
a377 1
 * the result is assigned the type from segment A
d380 1
a380 1
do_intersect( A, B, seghead )
d384 1
d397 1
a397 1
			tmp->seg_stp = A->seg_stp;
d403 1
a403 1
			tmp->seg_stp = A->seg_stp;
d411 1
d417 1
a417 1
			tmp->seg_stp = A->seg_stp;
d535 232
d827 3
a829 1
					if( sega->seg_stp == ON_SURF )
d834 1
a834 1
							do_intersect( sega, segb, &ret );
d836 2
a837 2
					else if( segb->seg_stp == ON_SURF )
						do_intersect( segb, sega, &ret );
d879 4
a882 2
					if( sega->seg_stp == ON_SURF )
						do_intersect( sega, segb, &ret );
d884 1
a884 1
						do_intersect( segb, sega, &ret );
d944 1
a944 1
				if( sega->seg_stp == ON_SURF )
d990 3
d1140 1
d1171 1
a1171 1
shoot_and_plot( start_pt, dir, vhead, edge_len, skip_leaf1, skip_leaf2, eptr )
d1178 1
d1282 1
a1282 1
			seg->seg_stp = ON_SURF;
d1397 1
a1397 1
		if( leaf_ptr->l.op != OP_DB_LEAF )
d1447 1
a1447 1
			shoot_and_plot( vg->coord, dir, vhead, edge_len, leaf_no, -1, eptr );
d1633 1
a1633 1
					shoot_and_plot( start_pt, dir, vhead, len-start_len, leaf_no, leaf2, eptr );
d1660 1
d1685 3
a1687 5
HIDDEN union tree *
E_region_end( tsp, pathp, curtree )
register struct db_tree_state *tsp;
struct db_full_path     *pathp;
union tree              *curtree;
d1689 2
a1690 9
	struct directory *dp;
	struct bu_vls vls;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	union E_tree *etree;
	union tree *ret_tree;
	struct bu_list vhead;
	int id;
	int simple_solid=0;
d1692 2
a1693 2
	if( bu_debug&BU_DEBUG_MEM_CHECK && bu_mem_barriercheck() )
		bu_log( "Error at start of E_region_end()\n" );
d1695 3
a1697 3
	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	RT_CK_FULL_PATH(pathp)
d1699 1
a1699 1
	bu_vls_init( &vls );
d1701 2
a1702 2
	dp = DB_FULL_PATH_CUR_DIR( pathp );
	RT_CK_DIR( dp );
d1704 4
a1707 4
	BU_LIST_INIT( &vhead );

	if( dp->d_flags & DIR_SOLID )
		simple_solid = 1;
d1709 1
a1709 2
	id = rt_db_get_internal( &intern, dp, dbip, tsp->ts_mat );
	if( id < 0 )
d1711 2
a1712 3
		Tcl_AppendResult(interp, "Unable to get internal form of ", dp->d_namep,
			"\n", (char *)NULL );
		return( curtree );
d1715 1
a1715 1
	if( simple_solid )
d1717 3
a1719 1
		struct model *m;
d1721 97
d1819 60
a1878 6
		m = nmg_mm();
		if (rt_functab[id].ft_tessellate( &r, m, &intern,
			&mged_ttol, &mged_tol) < 0)
		{
			Tcl_AppendResult(interp, "Tessellation failed for ", dp->d_namep,
				"\n", (char *)NULL );
d1881 26
a1906 2
		nmg_m_to_vlist( &vhead, m, 0 );
		rt_db_free_internal( &intern );
d1908 1
a1908 7
		db_free_tree( curtree );
		ret_tree =  (union tree *)NULL;
	}
	else
	{
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB( comb );
d1910 5
a1914 5
		if( !comb->tree )
		{
			rt_db_free_internal( &intern );
			return( curtree );
		}
d1916 1
a1916 1
		etree = build_etree( comb->tree );
d1918 7
a1924 2
		Eplot( etree, &vhead );
		rt_db_free_internal( &intern );
d1926 10
a1935 2
		/* Free etree */
		free_etree( etree );
d1937 2
a1938 2
		/* reset leaf_list */
		bu_ptbl_reset( &leaf_list );
d1940 2
a1941 2
		ret_tree = curtree;
	}
d1943 4
a1946 1
	drawH_part2( 0, &vhead, pathp, tsp, SOLID_NULL );
d1948 1
a1948 2
	if( bu_debug&BU_DEBUG_MEM_CHECK && bu_mem_barriercheck() )
		bu_log( "Error at end of E_region_end()\n" );
d1950 9
a1958 2
	return( ret_tree );
}
d1960 13
a1972 8
HIDDEN union tree *
E_solid_end( tsp, pathp, ep, id )
struct db_tree_state    *tsp;
struct db_full_path     *pathp;
struct bu_external      *ep;
int                     id;
{
	union tree *curtree;
d1974 3
a1976 5
	db_free_external( ep );
	BU_GETUNION( curtree, tree );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	return( curtree );
d1978 1
d2111 36
a2146 2
	(void)db_walk_tree( dbip, argc, (CONST char **)argv, 1, &E_initial_tree_state, 0,
		E_region_end, E_solid_end );
@


11.29
log
@*- some cleanup
@
text
@d1 1
a1 1
/*		This module implimenst the 'E' command
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.28 1998/12/17 04:19:11 mike Exp $ (BRL)";
d40 1
d46 1
a46 1
static struct application	ap;
d51 21
a71 1
static int			do_polysolids;
d108 3
d115 1
a115 1
	struct E_node
d123 1
a123 1
	struct E_leaf
d127 4
a130 5
		int the_edge;
		struct model *m;
		struct seg seghead;
		struct bu_ptbl edge_list;
		struct soltab *stp;
d143 1
d170 1
a170 2
			eptr->l.the_edge = 0;
			BU_LIST_INIT( &eptr->l.seghead.l );
d186 2
d200 1
d209 1
d220 2
d243 2
d261 1
d264 1
a264 1
struct seg *seg;
d272 2
a273 2
		if( BU_LIST_IS_EMPTY( &seg->l ) )
			bu_log( "%s - empty\n" );
d277 34
a310 1
			for( BU_LIST_FOR( ptr, seg, &seg->l ) )
d312 5
a316 1
				bu_log( "\t %g to %g\n", ptr->seg_in.hit_dist, ptr->seg_out.hit_dist );
d318 2
d321 2
d326 5
a330 2
HIDDEN struct seg *
eval_op( A, op, B )
d333 1
a333 1
int op;
d335 4
a338 3
	struct seg *sega, *segb;
	struct seg *ptr;
	struct seg *final=(struct seg *)NULL;
d340 2
a341 2
	/* handle special cases for "THE EDGE" */
	if( A && B && A->seg_stp && B->seg_stp )
d343 11
a353 3
		/* this wil only happen while plotting solid intersection lines */
		if( op != OP_INTERSECT )
			return( eval_op( A, OP_INTERSECT, B ) );
d357 15
d373 44
a416 1
		if( B && op == OP_SUBTRACT && B->seg_stp )
d418 11
a428 1
			return( eval_op( A, OP_INTERSECT, B ) );
d430 15
d446 3
a448 1
		if( A && op == OP_UNION && A->seg_stp )
d450 5
a454 1
			return( eval_op( A, OP_SUBTRACT, B ) );
d456 1
a456 2

		if( B && op == OP_UNION && B->seg_stp )
d458 5
a462 1
			return( eval_op( B, OP_SUBTRACT, A ) );
d464 1
d467 7
a473 1
	if(  (A && A->seg_stp) || (B && B->seg_stp) )
d475 3
a477 4
		if( A )
			A->seg_stp = (struct soltab *)0x1;
		if( B )
			B->seg_stp = (struct soltab *)0x1;
d480 23
a502 1
	if( op == OP_INTERSECT )
d504 5
a508 7
		if( !B )
			return( A );
		if( !A )
		{
			RT_FREE_SEG_LIST( B, ap.a_resource );
			return( B );
		}
d510 4
a513 2
		BU_GETSTRUCT( final, seg );
		BU_LIST_INIT( &final->l );
d515 3
a517 4
		if( A->seg_stp || B->seg_stp )
			final->seg_stp = (struct soltab *)0x1;
		else
			final->seg_stp = (struct soltab *)NULL;
d519 3
a521 3
		for( BU_LIST_FOR( sega, seg, &A->l ) )
		{
			for( BU_LIST_FOR( segb, seg, &B->l ) )
d523 1
a523 4
				if( segb->seg_out.hit_dist <= sega->seg_in.hit_dist )
					continue;
				if( segb->seg_in.hit_dist >= sega->seg_out.hit_dist )
					continue;
d525 3
a527 5
				RT_GET_SEG( ptr, ap.a_resource );
				if( sega->seg_in.hit_dist > segb->seg_in.hit_dist )
					ptr->seg_in.hit_dist = sega->seg_in.hit_dist;
				else
					ptr->seg_in.hit_dist = segb->seg_in.hit_dist;
d529 2
a530 4
				if( sega->seg_out.hit_dist < segb->seg_out.hit_dist )
					ptr->seg_out.hit_dist = sega->seg_out.hit_dist;
				else
					ptr->seg_out.hit_dist = segb->seg_out.hit_dist;
d532 23
a554 1
				BU_LIST_INSERT( &final->l, &ptr->l );
d556 8
a563 7
		}
		RT_FREE_SEG_LIST( A, ap.a_resource );
		RT_FREE_SEG_LIST( B, ap.a_resource );
		BU_LIST_INSERT_LIST( &A->l, &final->l );
		bu_free( (char *)final, "final" );
		return( A );
	}
a564 8
	if( op == OP_SUBTRACT )
	{
		if( !A )
		{
			RT_FREE_SEG_LIST( B, ap.a_resource );
			return( B );
		}
		if( !B )
d566 2
d569 5
a573 3
		for( BU_LIST_FOR( sega, seg, &A->l ) )
		{
			for( BU_LIST_FOR( segb, seg, &B->l ) )
d575 7
a581 4
				if( segb->seg_out.hit_dist <= sega->seg_in.hit_dist )
					continue;
				if( segb->seg_in.hit_dist >= sega->seg_out.hit_dist )
					continue;
d583 9
a591 2
				if( sega->seg_in.hit_dist >= segb->seg_in.hit_dist &&
				    sega->seg_out.hit_dist <= segb->seg_out.hit_dist )
d593 30
a622 1
					struct seg *tmp;
d624 45
a668 7
					/* remove entire segment */
					tmp = sega;
					sega = BU_LIST_PREV( seg, &sega->l );
					BU_LIST_DEQUEUE( &tmp->l );
					RT_FREE_SEG( tmp, ap.a_resource );
					continue;
				}
d670 1
a670 2
				if( segb->seg_in.hit_dist > sega->seg_in.hit_dist &&
				    segb->seg_out.hit_dist < sega->seg_out.hit_dist )
d672 12
a683 6
					/* splits segment into two */
					RT_GET_SEG( ptr, ap.a_resource );
					ptr->seg_in.hit_dist = sega->seg_in.hit_dist;
					ptr->seg_out.hit_dist = segb->seg_in.hit_dist;
					sega->seg_in.hit_dist = segb->seg_out.hit_dist;
					BU_LIST_INSERT( &sega->l, &ptr->l );
d687 12
a698 4
					if( segb->seg_in.hit_dist > sega->seg_in.hit_dist )
						sega->seg_out.hit_dist = segb->seg_in.hit_dist;
					if( segb->seg_out.hit_dist < sega->seg_out.hit_dist )
						sega->seg_in.hit_dist = segb->seg_out.hit_dist;
a700 4
		}
		RT_FREE_SEG_LIST( B, ap.a_resource );
		return( A );
	}
d702 36
a737 8
	if( op == OP_UNION )
	{
		if( !A && !B )
			return( (struct seg *)NULL );
		if( !A )
			return( B );
		if( !B )
			return( A );
d739 13
a751 3
		while( BU_LIST_WHILE( segb, seg, &B->l ) )
		{
			int found=0;
d753 10
a762 4
			for( BU_LIST_FOR( sega, seg, &A->l ) )
			{
				if( segb->seg_in.hit_dist > sega->seg_out.hit_dist )
					continue;
d764 16
a779 8
				found = 1;
				if( segb->seg_out.hit_dist <= sega->seg_out.hit_dist &&
				    segb->seg_in.hit_dist >= sega->seg_in.hit_dist )
				{
					/* nothing to do */
					BU_LIST_DEQUEUE( &segb->l );
					bu_free( (char *)segb, "segb" );
					break;
d781 10
d792 2
a793 1
				if( segb->seg_out.hit_dist < sega->seg_in.hit_dist )
d795 6
a800 4
					/* insert B segment before A segment */
					BU_LIST_DEQUEUE( &segb->l );
					BU_LIST_INSERT( &sega->l, &segb->l );
					break;
d803 3
a805 5
				/* segments overlap */
				if( segb->seg_in.hit_dist < sega->seg_in.hit_dist )
					sega->seg_in.hit_dist = segb->seg_in.hit_dist;
				if( segb->seg_out.hit_dist > sega->seg_out.hit_dist )
					sega->seg_out.hit_dist = segb->seg_out.hit_dist;
d807 8
a814 4
				BU_LIST_DEQUEUE( &segb->l );
				bu_free( (char *)segb, "segb" );
				break;
			}
d816 2
a817 8
			if( !found )
			{
				/* segment from B gets added to end of A */
				BU_LIST_DEQUEUE( &segb->l )
				BU_LIST_INSERT( &A->l, &segb->l );
			}
		}
		return( A );
d821 10
a830 1
	return( (struct seg *)NULL );   /* for the compilers */
d833 2
a834 1
HIDDEN struct seg *
d838 1
a838 1
	struct seg *A, *B;
d842 4
d849 9
a857 9
			if( eptr->l.the_edge )
			{
				eptr->l.seghead.seg_stp = (struct soltab *)0x1;
			}
			else
			{
				eptr->l.seghead.seg_stp = (struct soltab *)NULL;
			}
			return( &eptr->l.seghead );
d861 4
d871 1
a871 1
	return( (struct seg *)NULL );	/* for the compilers */
d874 4
d890 1
a890 1
	struct seg *final_segs;
a897 8
	bzero( &ap, sizeof( struct application ) );

	ap.a_resource = &rt_uniresource;
	rt_uniresource.re_magic = RESOURCE_MAGIC;
	ap.a_rt_i = rtip;

	if( BU_LIST_UNINITIALIZED( &rt_uniresource.re_nmgfree ) )
		BU_LIST_INIT( &rt_uniresource.re_nmgfree );
d927 1
a927 1
	rd.ap = &ap;
d932 3
a934 1
	/* shoot this ray at every leaf solid except the current one */
d942 1
a942 1
		if( BU_LIST_NON_EMPTY( &shoot->l.seghead.l ) )
d944 1
a944 1
			RT_FREE_SEG_LIST( &shoot->l.seghead, ap.a_resource );
d946 1
a946 1
		BU_LIST_INIT( &shoot->l.seghead.l );
d948 1
d953 1
d984 2
a985 2
			/* put entire edge in seg list */
			RT_GET_SEG( seg, ap.a_resource );
d989 2
a990 5
			BU_LIST_INSERT( &shoot->l.seghead.l, &seg->l );
			if( shoot_leaf == skip_leaf1 || shoot_leaf == skip_leaf2 )
				shoot->l.the_edge = 1;
			else
				shoot->l.the_edge = 0;
a993 2
		shoot->l.the_edge = 0;

d1001 1
a1001 4
		/* make sure this solid is identified as not "THE EDGE" */
		shoot->l.the_edge = 0;

		/* actually shoot the ray */
d1004 1
a1004 1
			if( rt_functab[shoot->l.stp->st_id].ft_shot( shoot->l.stp, &rp, &ap, rd.seghead ) )
a1007 1
				seg = BU_LIST_FIRST( seg, &rd.seghead->l );
d1009 16
a1024 2
				BU_LIST_INSERT_LIST( &shoot->l.seghead.l, &rd.seghead->l );
				shoot->l.seghead.seg_stp = shoot->l.stp;
d1032 5
d1039 4
d1048 1
a1048 1
		for( BU_LIST_FOR( seg, seg, &final_segs->l ) )
d1051 5
d1058 5
d1065 5
d1076 2
a1077 1
		RT_FREE_SEG_LIST( final_segs, ap.a_resource );
a1127 2
		leaf_ptr->l.the_edge = 1;

a1153 1

a1159 1

d1197 1
d1210 1
a1220 1
					NMG_GET_FU_PLANE( pl1, fu1 );
d1243 1
a1243 5

							if( dist < 0.0 || dist >= 1.0 )
								continue;

							if( NEAR_ZERO( old_dist - dist, mged_tol.dist ) )
a1245 1
							old_dist = dist;
d1247 7
d1256 1
a1256 1
								break;;
d1259 1
a1259 1
							break;;
d1278 1
a1278 4
							if( dist < 0.0 || dist >= 1.0 )
								continue;

							if( NEAR_ZERO( old_dist - dist, mged_tol.dist ) )
a1280 1
							old_dist = dist;
d1282 7
d1291 1
a1291 1
								break;;
d1294 1
a1294 1
							break;;
d1372 1
a1372 1
			if( BU_LIST_NON_EMPTY( &eptr->l.seghead.l ) )
d1374 1
a1374 1
				RT_FREE_SEG_LIST( &eptr->l.seghead, ap.a_resource );
d1605 9
d1626 1
@


11.28
log
@Regions now have an associated temperature
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.27 1998/11/06 22:32:42 bparker Exp $ (BRL)";
a1240 4

#ifdef DO_SINGLE_DISPLAY_LIST
	  createDList(&HeadSolid);
#endif
@


11.27
log
@*- use new structures
*- cleanup
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.26 1998/09/14 15:59:20 bparker Exp $ (BRL)";
d67 1
@


11.26
log
@*- fix typos
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.25 1998/06/24 17:55:18 bparker Exp $ (BRL)";
d1221 2
a1222 2
	  if(curr_dm_list->aim)
	    curr_cmd_list = curr_dm_list->aim;
d1227 1
a1227 1
	  if (mged_variables->autosize  && initial_blank_screen &&
d1229 1
a1229 1
	    struct view_list *vlp;
d1235 2
a1236 6
#ifdef DO_SCROLL_UPDATES
	    set_scroll();
#endif

	    for(BU_LIST_FOR(vlp, view_list, &headView.l))
	      vlp->vscale = Viewscale;
@


11.25
log
@*- mods to f_evedit() to optionally specify a color
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/proc_reg.c,v 11.24 1997/12/23 14:24:16 bparker Exp $ (BRL)";
d1253 1
a1253 1
	sprintf(perf_message, "E: %ld vectors in %ld sec\n", nvectors, etime - start_time );
@


11.24
log
@*** empty log message ***
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.23 1997/09/08 18:38:23 bparker Exp bparker $ (BRL)";
d43 2
a1101 1
	int start_argc=1;
d1103 1
d1123 45
a1167 4
	if( *argv[1] == '-' )
	{
		do_polysolids = 1;
		start_argc++;
d1169 2
d1174 1
a1174 1
	for( i=start_argc ; i<argc ; i++ )
d1207 1
a1207 1
	(void)db_walk_tree( dbip, argc-start_argc, (CONST char **)(argv+start_argc), 1, &E_initial_tree_state, 0,
@


11.23
log
@*- mged_variables is now a pointer
* new macro FOR_ALL_DISPLAYS
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.22 1997/09/03 14:19:39 bparker Exp bparker $ (BRL)";
d1189 4
@


11.22
log
@mods to implement new display lists
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.21 1997/08/20 19:23:33 jra Exp bparker $ (BRL)";
d1174 1
a1174 1
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
d1182 1
a1182 1
	  if (mged_variables.autosize  && initial_blank_screen &&
@


11.21
log
@Minor mods for IRIX 6.4.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.20 1997/04/24 18:03:58 bparker Exp jra $ (BRL)";
d1102 3
a1133 1
			no_memory = 0;
a1136 8
	if( dmp->dm_displaylist )
	{
		/* Force displaylist update before starting new drawing */
		update_views = 1;
		refresh();
	}


d1172 28
a1199 7
      /* If we went from blank screen to non-blank, resize */
      if (mged_variables.autosize  && initial_blank_screen &&
	  BU_LIST_NON_EMPTY(&HeadSolid.l)) {
	size_reset();
	new_mats();
	(void)mged_svbase();
      }
d1201 2
a1202 1
	color_soltab();
d1207 1
@


11.20
log
@modify calls to Tcl_Eval
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.19 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d453 3
d485 3
@


11.19
log
@mods so that commands check args internally
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.18 1997/03/18 19:51:52 bparker Exp bparker $ (BRL)";
d1098 6
a1103 1
	  Tcl_Eval(interp, "help E");
@


11.18
log
@*** empty log message ***
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.17 1997/03/12 19:28:18 jra Exp bparker $ (BRL)";
d1097 2
a1098 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1100 1
@


11.17
log
@Finished clearing up the last few bugs (I think).
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.16 1997/03/11 21:41:04 jra Exp $ (BRL)";
d44 1
a44 1
static time_t			stime, etime;
d1153 1
a1153 1
	(void)time( &stime );
d1175 1
a1175 1
	sprintf(perf_message, "E: %ld vectors in %ld sec\n", nvectors, etime - stime );
@


11.16
log
@Entirely re-wrote the 'E' command.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.19 1997/03/04 19:29:35 jra Exp $ (BRL)";
d160 8
a167 2
				Tcl_AppendResult(interp, "Cannot handle regions containing combinations yet\n",
					(char *)NULL );
d301 1
a301 1
			return( (struct seg *)NULL );
d304 8
a320 10
				if( !final )
				{
					BU_GETSTRUCT( final, seg );
					BU_LIST_INIT( &final->l );

					if( A->seg_stp || B->seg_stp )
						final->seg_stp = (struct soltab *)0x1;
					else
						final->seg_stp = (struct soltab *)NULL;
				}
d337 3
a339 1
		return( final );
d347 1
a347 1
			return( (struct seg *)NULL );
d554 6
d602 2
d626 1
a646 1

a671 1
	time_t start_edges, start_inters;
a695 2
	(void)time( &start_edges );

a741 2
	(void)time( &start_inters );

d785 1
d810 1
d827 4
a830 1
							if( dist < 0.0 || dist > 1.0 )
d833 1
d842 1
d859 1
a859 1
							if( dist < 0.0 || dist > 1.0 )
d862 4
a922 1
	(void)time( &start_edges );
a1159 3
	sprintf(perf_message, "E: %ld vectors in %ld sec\n", nvectors, etime - stime );
	Tcl_AppendResult(interp, perf_message, (char *)NULL);

d1174 3
@


11.15
log
@mods to use libbn and libbu
@
text
@d1 1
a1 4
/*
 *				P R O C _ R E G . C
 *
 * This module deals with building an edge description of a region.
d3 2
a4 10
 * Functions -
 *	f_evedit	Evaluated edit something (add to visible display)
 *	Edrawtree	Call drawHobj to draw a tree
 *	EdrawHobj	Call Edrawsolid for all solids in an object
 *	EdrawHsolid	Manage the drawing of a COMGEOM solid
 *	proc_region	processes each member (solid) of a region
 *
 * Authors -
 *	Keith Applin
 *	Gary Kuehl
d6 1
a6 2
 * Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
d8 1
a8 1
 *	Aberdeen Proving Ground, Maryland  21005
d11 1
a11 1
 *	This software is Copyright (C) 1985 by the United States Army.
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.14 1996/12/04 03:39:35 mike Exp bparker $ (BRL)";
d21 8
a28 1
#include <math.h>
d32 2
a33 2
#include "bn.h"
#include "db.h"
d35 1
a35 1
#include "externs.h"
d39 1
d41 8
a48 1
extern void color_soltab();
d50 4
a53 19
int		drawreg;	/* if > 0, process and draw regions */
int		regmemb;	/* # of members left to process in a region */
int		reg_pathpos;	/* pathpos of a processed region */
int		reg_error;	/* error encountered in region processing */
char		memb_oper;	/* operation for present member of processed region */

extern int	no_memory;	/* flag indicating memory for drawing is used up */
extern long	nvectors;	/* from dodraw.c */
extern struct bn_tol		mged_tol;		/* from ged.c */

void		Edrawtree();
void		EdrawHobj();
int		EdrawHsolid();

static void	center(), dwreg(), ellin(), move(), points(),
		regin(), solin(), solpl(), tgcin(), tplane(),
		vectors();
static int	arb(), cgarbs(), gap(), redoarb(), 
		region();
d55 27
a81 1
static union record input;		/* Holds an object file record */
a82 10
/* following variables are used in processing regions
 *  for producing edge representations
 */
#define NMEMB	250	/* max number of members in a region */
static int	nmemb = 0;		/* actual number of members */
static int	m_type[NMEMB];		/* member solid types */
static char	m_op[NMEMB];		/* member operations */
static fastf_t	m_param[NMEMB*24];	/* member parameters */
static int	memb_count = 0;		/* running count of members */
static int	param_count = 0; 	/* location in m_param[] array */
d84 1
a84 13
/*
 *			F _ E V E D I T
 *
 *  The "Big E" command.
 *  Evaluated Edit something (add to visible display)
 *  Usage: E object(s)
 */
int
f_evedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d86 1
a86 4
	register struct directory *dp;
	register int	i;
	time_t		stime, etime;	/* start & end times */
	static int	first_time = 1;
d88 7
a94 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d96 11
a106 2
	drawreg = 1;
	regmemb = -1;
d108 2
a109 6
	/* Innards from old eedit() */
	nvectors = 0;
	(void)time( &stime );
	for( i=1; i < argc; i++ )  {
		if( (dp = db_lookup( dbip,  argv[i], LOOKUP_NOISY )) == DIR_NULL )
			continue;
d111 5
a115 10
		if( dmp->dm_displaylist )  {
			/*
			 * Delete any portion of object
			 * remaining from previous draw.
			 */
			eraseobj( dp );
			dmaflag++;
			refresh();
			dmaflag++;
		}
d117 9
a125 12
		/*
		 * Draw this object as a ROOT object, level 0
		 * on the path, with no displacement, and
		 * unit scale.
		 */
		if( no_memory )  {
		  Tcl_AppendResult(interp, "No memory left so cannot draw ",
				   dp->d_namep, "\n", (char *)NULL);
		  drawreg = 0;
		  regmemb = -1;
		  continue;
		}
d127 1
a127 6
		Edrawtree( dp );
		regmemb = -1;
	}
	(void)time( &etime );
	if(first_time && BU_LIST_NON_EMPTY(&HeadSolid.l)){
		first_time = 0;
d129 2
a130 3
		size_reset();
		new_mats();
	}
d132 1
d134 31
a164 1
	  struct bu_vls tmp_vls;
d166 45
a210 5
	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "E: %ld vectors in %ld sec\n", nvectors, etime - stime );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
d212 1
a212 5
	color_soltab();
#if 0
	dmp->dm_colorchange(dmp);
#endif
	dmaflag = 1;
d214 5
a218 1
	return TCL_OK;
a220 15
struct directory	*cur_path[MAX_PATH];	/* Record of current path */

static struct mater_info mged_no_mater = {
	/* RT default is white.  This is red, to stay clear of illuminate mode */
	1.0, 0, 0,		/* */
	0,			/* override */
	DB_INH_LOWER,		/* color inherit */
	DB_INH_LOWER		/* mater inherit */
};

/*
 *			D R A W T R E E
 *
 *  This routine is the analog of rt_gettree().
 */
d222 2
a223 2
Edrawtree( dp )
struct directory	*dp;
d225 1
a225 2
	mat_t		root;
	struct mater_info	root_mater;
d227 15
a241 6
	root_mater = mged_no_mater;	/* struct copy */

	bn_mat_idn( root );
	/* Could apply root animations here ? */

	EdrawHobj( dp, ROOT, 0, root, 0, &root_mater );
d244 5
a248 15
/*
 *			D R A W H O B J
 *
 * This routine is used to get an object drawn.
 * The actual drawing of solids is performed by Edrawsolid(),
 * but all transformations down the path are done here.
 */
void
EdrawHobj( dp, flag, pathpos, old_xlate, regionid, materp )
register struct directory *dp;
int		flag;
int		pathpos;
matp_t		old_xlate;
int		regionid;
struct mater_info *materp;
d250 3
a252 5
	struct bu_external	ext;
	union record	*rp;
	auto mat_t	new_xlate;	/* Accumulated translation matrix */
	auto int	i;
	struct mater_info curmater;
d254 6
a259 13
	if( pathpos >= MAX_PATH )  {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "nesting exceeds %d levels\n", MAX_PATH );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);

	  for(i=0; i<MAX_PATH; i++)
	    Tcl_AppendResult(interp, "/", cur_path[i]->d_namep, (char *)NULL);

	  Tcl_AppendResult(interp, "\n", (char *)NULL);
	  return;			/* ERROR */
d261 2
d264 4
a267 5
	/*
	 * Load the record into local record buffer
	 */
	if( db_get_external( &ext, dp, dbip ) < 0 )
		return;
d269 4
a272 12
	rp = (union record *)ext.ext_buf;
	if( rp[0].u_id != ID_COMB )  {
		register struct solid *sp;

		if( rt_id_solid( &ext ) == ID_NULL )  {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "Edrawobj(%s):  defective database record, type='%c' (0%o) addr=x%x\n",
				dp->d_namep, rp[0].u_id, rp[0].u_id, dp->d_addr );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
d274 3
a276 1
		  goto out;		/* ERROR */
a277 12
		/*
		 * Enter new solid (or processed region) into displaylist.
		 */
		cur_path[pathpos] = dp;

		GET_SOLID(sp, &FreeSolid.l);
		if( sp == SOLID_NULL )
			return;		/* ERROR */
		if( EdrawHsolid( sp, flag, pathpos, old_xlate, &ext, regionid, materp ) != 1 ) {
			FREE_SOLID(sp, &FreeSolid.l);
		}
		goto out;
d280 6
a285 8
	/*
	 *  At this point, u_id == ID_COMB.
	 *  Process a Combination (directory) node
	 */
	if( dp->d_len <= 1 )  {
	  Tcl_AppendResult(interp, "Warning: combination with zero members \"",
			   dp->d_namep, "\".\n", (char *)NULL);
	  goto out;			/* non-fatal ERROR */
d288 41
a328 19
	/*
	 *  Handle inheritance of material property.
	 *  Color and the material property have separate
	 *  inheritance interlocks.
	 */
	curmater = *materp;	/* struct copy */
	if( rp[0].c.c_override == 1 )  {
		if( regionid != 0 )  {
		  Tcl_AppendResult(interp, "Edrawobj: ERROR: color override in combination within region ", dp->d_namep, "\n", (char *)NULL);
		} else {
			if( curmater.ma_cinherit == DB_INH_LOWER )  {
				curmater.ma_override = 1;
				curmater.ma_color[0] =
					((double)(rp[0].c.c_rgb[0]))*bn_inv255;
				curmater.ma_color[1] =
					((double)(rp[0].c.c_rgb[1]))*bn_inv255;
				curmater.ma_color[2] =
					((double)(rp[0].c.c_rgb[2]))*bn_inv255;
				curmater.ma_cinherit = rp[0].c.c_inherit;
d331 3
d335 50
a384 12
	if( rp[0].c.c_matname[0] != '\0' )  {
		if( regionid != 0 )  {
		  Tcl_AppendResult(interp, "Edrawobj: ERROR: material property spec in combination within region ", dp->d_namep, "\n", (char *)NULL);
		} else {
			if( curmater.ma_minherit == DB_INH_LOWER )  {
				struct bu_vls	str;
				bu_vls_init(&str);
				bu_vls_strncat( &str, rp[0].c.c_matname, sizeof(rp[0].c.c_matname) );
				bu_vls_strncpy( &str, rp[0].c.c_matparm, sizeof(rp[0].c.c_matparm) );
				curmater.ma_shader = bu_vls_strgrab( &str );
				/* bu_vls_free() done by bu_vls_strgrab() */
				curmater.ma_minherit = rp[0].c.c_inherit;
d387 2
d391 27
a417 53
	/* Handle combinations which are the top of a "region" */
	if( rp[0].c.c_flags == 'R' )  {
	  if( regionid != 0 ){
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "regionid %d overriden by %d\n",
			  regionid, rp[0].c.c_regionid );
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }

	  regionid = rp[0].c.c_regionid;
	}

	/*
	 *  This node is a combination (eg, a directory).
	 *  Process all the arcs (eg, directory members).
	 */
	if( drawreg && rp[0].c.c_flags == 'R' && dp->d_len > 1 ) {
	  if( regmemb >= 0  ) {
	    Tcl_AppendResult(interp, "ERROR: region (", dp->d_namep,
			     ") is member of region (", cur_path[reg_pathpos]->d_namep,
			     ")\n", (char *)NULL);
	    goto out;	/* ERROR */
	  }
	  /* Well, we are processing regions and this is a region */
	  /* if region has only 1 member, don't process as a region */
	  if( dp->d_len > 2) {
	    regmemb = dp->d_len-1;
	    reg_pathpos = pathpos;
	  }
	}

	/* Process all the member records */
	for( i=1; i < dp->d_len; i++ )  {
		register struct member	*mp;
		register struct directory *nextdp;
		static mat_t		xmat;	/* temporary fastf_t matrix */

		mp = &(rp[i].M);
		if( mp->m_id != ID_MEMB )  {
		  Tcl_AppendResult(interp, "EdrawHobj:  ", dp->d_namep,
				   " bad member rec\n", (char *)NULL);
		  goto out;			/* ERROR */
		}
		cur_path[pathpos] = dp;
		if( regmemb > 0  ) { 
			regmemb--;
			memb_oper = mp->m_relation;
		}
		if( (nextdp = db_lookup( dbip,  mp->m_instname, LOOKUP_NOISY )) == DIR_NULL )
			continue;
d419 7
a425 21
		/* s' = M3 . M2 . M1 . s
		 * Here, we start at M3 and descend the tree.
		 * convert matrix to fastf_t from disk format.
		 */
		rt_mat_dbmat( xmat, mp->m_mat );
		/* Check here for animation to apply */
		bn_mat_mul(new_xlate, old_xlate, xmat);

		/* Recursive call */
		EdrawHobj(
			nextdp,
			(mp->m_relation != SUBTRACT) ? ROOT : INNER,
			pathpos + 1,
			new_xlate,
			regionid,
			&curmater
		);
	}
out:
	db_free_external( &ext );
}
d427 5
a431 22
/*
 *			D R A W H S O L I D
 *
 * Returns -
 *	-1	on error
 *	 0	if NO OP
 *	 1	if solid was drawn
 */
int
EdrawHsolid( sp, flag, pathpos, xform, ep, regionid, materp )
register struct solid	*sp;
int			flag;
int			pathpos;
mat_t			xform;
struct bu_external	*ep;
int			regionid;
struct mater_info	*materp;
{
	register int i;
	int dashflag;		/* draw with dashed lines */
	struct bu_list	vhead;
	struct rt_tess_tol	ttol;
d433 3
a435 10
	BU_LIST_INIT( &vhead );
	if( regmemb >= 0 ) {
		/* processing a member of a processed region */
		/* regmemb  =>  number of members left */
		/* regmemb == 0  =>  last member */
		/* reg_error > 0  =>  error condition  no more processing */
		if(reg_error) { 
			if(regmemb == 0) {
				reg_error = 0;
				regmemb = -1;
a436 4
			return(-1);		/* ERROR */
		}
		if(memb_oper == UNION)
			flag = 999;
d438 6
a443 13
		/* The hard part */
		i = proc_region( (union record *)ep->ext_buf, xform, flag );

		if( i < 0 )  {
		  /* error somwhere */
		  Tcl_AppendResult(interp, "Error in converting solid ",
				   cur_path[reg_pathpos]->d_namep, " to ARBN\n", (char *)NULL);
		  reg_error = 1;
		  if(regmemb == 0) {
		    regmemb = -1;
		    reg_error = 0;
		  }
		  return(-1);		/* ERROR */
d445 3
a447 1
		reg_error = 0;		/* reset error flag */
d449 5
a453 24
		/* if more member solids to be processed, no drawing was done
		 */
		if( regmemb > 0 )
		  return(0);		/* NOP -- more to come */

		i = finish_region( &vhead );
		if( i < 0 )  {
		  Tcl_AppendResult(interp, "error in finish_region()\n", (char *)NULL);
		  return(-1);		/* ERROR */
		}
		dashflag = 0;
	}  else  {
		/* Doing a normal solid */
		struct rt_db_internal	intern;
		int id;

		dashflag = (flag != ROOT);

		id = rt_id_solid( ep );
		if( id <= 0 || id >= rt_nfunctab )  {
		  Tcl_AppendResult(interp, "EdrawHsolid(", cur_path[pathpos]->d_namep,
				   "):  unknown database object\n", (char *)NULL);
		  return(-1);			/* ERROR */
		}
d455 1
a455 8
	    	RT_INIT_DB_INTERNAL(&intern);
		if( rt_functab[id].ft_import( &intern, ep, xform ) < 0 )  {
		  Tcl_AppendResult(interp, cur_path[pathpos]->d_namep,
				   ":  solid import failure\n", (char *)NULL);
		  if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		  return(-1);			/* FAIL */
		}
		RT_CK_DB_INTERNAL( &intern );
d457 18
a474 12
		ttol.magic = RT_TESS_TOL_MAGIC;
		ttol.abs = mged_abs_tol;
		ttol.rel = mged_rel_tol;
		ttol.norm = mged_nrm_tol;

		if( rt_functab[id].ft_plot( &vhead,
					    &intern,
					    &ttol, &mged_tol ) < 0 )  {
		  Tcl_AppendResult(interp, cur_path[pathpos]->d_namep,
				   ": vector conversion failure\n", (char *)NULL);
		}
		rt_functab[id].ft_ifree( &intern );
d476 1
d478 40
a517 5
	/* Take note of the base color */
	if( materp )  {
		sp->s_basecolor[0] = materp->ma_color[0] * 255.;
		sp->s_basecolor[1] = materp->ma_color[1] * 255.;
		sp->s_basecolor[2] = materp->ma_color[2] * 255.;
d519 5
a523 45

	/*
	 * Compute the min, max, and center points.
	 */
	BU_LIST_APPEND_LIST( &(sp->s_vlist), &vhead );

	mged_bound_solid( sp );
	nvectors += sp->s_vlen;

	/*
	 * If this solid is not illuminated, fill in it's information.
	 * A solid might be illuminated yet vectorized again by redraw().
	 */
	if( sp != illump )  {
		sp->s_iflag = DOWN;
		sp->s_soldash = dashflag;

		if(regmemb == 0) {
			/* done processing a region */
			regmemb = -1;
			sp->s_last = reg_pathpos;
			sp->s_Eflag = 1;	/* This is processed region */
		}  else  {
			sp->s_Eflag = 0;	/* This is a solid */
			sp->s_last = pathpos;
		}
		/* Copy path information */
		for( i=0; i<=sp->s_last; i++ )
			sp->s_path[i] = cur_path[i];
	}
	sp->s_regionid = regionid;
	sp->s_addr = 0;
	sp->s_bytes = 0;

	/* Cvt to displaylist, determine displaylist memory requirement. */
	if( !no_memory && (sp->s_bytes = dmp->dm_cvtvecs( dmp, sp )) != 0 )  {
		/* Allocate displaylist storage for object */
		sp->s_addr = rt_memalloc( &(dmp->dm_map), sp->s_bytes );
		if( sp->s_addr == 0 )  {
		  no_memory = 1;
		  Tcl_AppendResult(interp, "Edraw: out of Displaylist\n", (char *)NULL);
		  sp->s_bytes = 0;	/* not drawn */
		} else {
			sp->s_bytes = dmp->dm_load(dmp, sp->s_addr, sp->s_bytes );
		}
d525 2
a526 8

	/* Solid is successfully drawn */
	if( sp != illump )  {
		/* Add to linked list of solid structs */
	  BU_LIST_APPEND(HeadSolid.l.back, &sp->l);
#if 0
	  dmp->dm_viewchange( dmp, DM_CHGV_ADD, sp );
#endif
d528 2
a529 5
	  /* replacing illuminated solid -- struct already linked in */
	  sp->s_iflag = UP;
#if 0
	  dmp->dm_viewchange( dmp, DM_CHGV_REPL, sp );
#endif
d532 13
a544 2
	return(1);		/* OK */
}
d546 1
a546 44
/*
 * This routine processes each member(solid) of a region.
 *
 * When the last member is processed, dwreg() is executed.
 *
 * Returns -
 *	-1	error
 *	 0	region drawn
 *	 1	more solids follow, please re-invoke w/next solid.
 */
proc_region( recordp, xform, flag )
register union record *recordp;
register mat_t xform;
int flag;
{
	register int i;
	register dbfloat_t *op;	/* Used for scanning vectors */
	static vect_t	work;		/* Vector addition work area */
	static int length, type;
	static int uvec[8], svec[11];
	static int cgtype;

	input = *recordp;		/* struct copy */

	type = recordp->s.s_type;
	cgtype = type;

	if(type == GENARB8) {
		/* check for arb8, arb7, arb6, arb5, arb4 */
		points();
		if( (i = cgarbs(uvec, svec)) == 0 ) {
			nmemb = param_count = memb_count = 0;
			return(-1);	/* ERROR */
		}
		if(redoarb(uvec, svec, i) == 0) {
			nmemb = param_count = memb_count = 0;
			return(-1);	/* ERROR */
		}
		vectors();
/* XXX */
		cgtype = input.s.s_cgtype;
	}
	if(cgtype == RPP || cgtype == BOX || cgtype == GENARB8)
		cgtype = ARB8;
d548 5
a552 7
	if(flag == ROOT)
		m_op[memb_count] = '+';
	else
	if(flag == 999)
		m_op[memb_count] = 'u';
	else
		m_op[memb_count] = '-';
d554 22
a575 28
	m_type[memb_count++] = cgtype;
	if(memb_count > NMEMB) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "proc_reg: region has more than %d members\n", NMEMB);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  nmemb = param_count = memb_count = 0;
	  return(-1);	/* ERROR */
	}

	switch( cgtype )  {

	case ARB8:
		length = 8;
arbcom:		/* common area for arbs */
		MAT4X3PNT( work, xform, &input.s.s_values[0] );
		VMOVE( &input.s.s_values[0], work );
		VMOVE(&m_param[param_count], &input.s.s_values[0]);
		param_count += 3;
		op = &input.s.s_values[1*3];
		for( i=1; i<length; i++ )  {
			MAT4X3VEC( work, xform, op );
			VADD2(op, input.s.s_values, work);
			VMOVE(&m_param[param_count], op);
			param_count += 3;
			op += 3;
a576 1
		break;
d578 13
a590 32
	case ARB7:
		length = 7;
		goto arbcom;

	case ARB6:
		VMOVE(&input.s.s_values[15], &input.s.s_values[18]);
		length = 6;
		goto arbcom;

	case ARB5:
		length = 5;
		goto arbcom;

	case ARB4:
		length = 4;
		VMOVE(&input.s.s_values[9], &input.s.s_values[12]);
		goto arbcom;

	case GENTGC:
		op = &recordp->s.s_values[0*3];
		MAT4X3PNT( work, xform, op );
		VMOVE( op, work );
		VMOVE(&m_param[param_count], op);
		param_count += 3;
		op += 3;

		for( i=1; i<6; i++ )  {
			MAT4X3VEC( work, xform, op );
			VMOVE( op, work );
			VMOVE(&m_param[param_count], op);
			param_count += 3;
			op += 3;
a591 1
		break;
d593 1
a593 16
	case GENELL:
		op = &recordp->s.s_values[0*3];
		MAT4X3PNT( work, xform, op );
		VMOVE( op, work );
		VMOVE(&m_param[param_count], op);
		param_count += 3;
		op += 3;

		for( i=1; i<4; i++ )  {
			MAT4X3VEC( work, xform, op );
			VMOVE( op, work );
			VMOVE(&m_param[param_count], op);
			param_count += 3;
			op += 3;
		}
		break;
d595 4
a598 11
	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "proc_reg:  Cannot draw solid type %d (%s)\n",
			  type, type == TOR ? "TOR":
			  type == ARS ? "ARS" : "UNKNOWN TYPE" );
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }
d600 1
a600 5
	  nmemb = param_count = memb_count = 0;
	  return(-1);	/* ERROR */
	}
	return(0);		/* OK */
}
d602 2
a603 14
int
finish_region(vhead)
struct bu_list	*vhead;
{
	/* last member solid has been seen, now draw the region */
	nmemb = memb_count;
	param_count = memb_count = 0;
	if(nmemb == 0) {
		nmemb = param_count = memb_count = 0;
		return(-1);	/* ERROR */
	}
	dwreg(vhead);
	return(0);		/* OK, region was drawn */
}
d605 6
a610 2
#define NO	0
#define YES	1
d612 3
a614 40
/* C G A R B S :   determines COMGEOM arb types from GED general arbs
 */
static int
cgarbs( uvec, svec )
register int *uvec;	/* array of unique points */
register int *svec;	/* array of like points */
{
	register int i,j;
	static int numuvec, unique, done;
	static int si;

	done = NO;		/* done checking for like vectors */

	svec[0] = svec[1] = 0;
	si = 2;

	for(i=0; i<7; i++) {
		unique = YES;
		if(done == NO)
			svec[si] = i;
		for(j=i+1; j<8; j++) {
			vect_t	diff;
			VSUB2( diff, &input.s.s_values[i*3], &input.s.s_values[j*3] );
			if( VNEAR_ZERO( diff, 0.0001 ) )  {
				/* Points are the same */
				if( done == NO )
					svec[++si] = j;
				unique = NO;
			}
		}
		if( unique == NO ) {  	/* point i not unique */
			if( si > 2 && si < 6 ) {
				svec[0] = si - 1;
				if(si == 5 && svec[5] >= 6)
					done = YES;
				si = 6;
			}
			if( si > 6 ) {
				svec[1] = si - 5;
				done = YES;
d618 5
a622 21
	if( si > 2 && si < 6 ) 
		svec[0] = si - 1;
	if( si > 6 )
		svec[1] = si - 5;
	for(i=1; i<=svec[1]; i++)
		svec[svec[0]+1+i] = svec[5+i];
	for(i=svec[0]+svec[1]+2; i<11; i++)
		svec[i] = -1;
	/* find the unique points */
	numuvec = 0;
	for(j=0; j<8; j++) {
		unique = YES;
		for(i=2; i<svec[0]+svec[1]+2; i++) {
			if( j == svec[i] ) {
				unique = NO;
				break;
			}
		}
		if( unique == YES )
			uvec[numuvec++] = j;
	}
d624 3
a626 2
	/* put comgeom solid typpe into s_cgtype */
	switch( numuvec ) {
d628 4
a631 3
	case 8:
		input.s.s_cgtype = ARB8;  /* ARB8 */
		break;
d633 8
a640 3
	case 6:
		input.s.s_cgtype = ARB7;	/* ARB7 */
		break;
d642 2
a643 6
	case 4:
		if(svec[0] == 2)
			input.s.s_cgtype = ARB6;	/* ARB6 */
		else
			input.s.s_cgtype = ARB5;	/* ARB5 */
		break;
d645 2
a646 14
	case 2:
		input.s.s_cgtype = ARB4;	/* ARB4 */
		break;

	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "solid: %s  bad number of unique vectors (%d)\n",
			  input.s.s_name, numuvec);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }
a647 3
	  return(0);
	}
	return( numuvec );
d650 4
a653 6
/*  R E D O A R B :   rearranges arbs to be GIFT compatible
 */
static int
redoarb( uvec, svec, numvec )
register int *uvec, *svec;
int numvec;
d655 8
a662 2
	register int i, j;
	static int prod;
d664 1
a664 1
	switch( input.s.s_cgtype ) {
d666 10
a675 54
	case ARB8:
		/* do nothing */
		break;

	case ARB7:
		/* arb7 vectors: 0 1 2 3 4 5 6 4 */
		switch( svec[2] ) {
			case 0:
				/* 0 = 1, 3, or 4 */
				if(svec[3] == 1)
					move(4,7,6,5,1,4,3,1);
				if(svec[3] == 3)
					move(4,5,6,7,0,1,2,0);
				if(svec[3] == 4)
					move(1,2,6,5,0,3,7,0);
				break;
			case 1:
				/* 1 = 2 or 5 */
				if(svec[3] == 2)
					move(0,4,7,3,1,5,6,1);
				if(svec[3] == 5)
					move(0,3,7,4,1,2,6,1);
				break;
			case 2:
				/* 2 = 3 or 6 */
				if(svec[3] == 3)
					move(6,5,4,7,2,1,0,2);
				if(svec[3] == 6)
					move(3,0,4,7,2,1,5,2);
				break;
			case 3:
				/* 3 = 7 */
				move(2,1,5,6,3,0,4,3);
				break;
			case 4:
				/* 4 = 5 */
				/* if 4 = 7  do nothing */
				if(svec[3] == 5)
					move(1,2,3,0,5,6,7,5);
				break;
			case 5:
				/* 5 = 6 */
				move(2,3,0,1,6,7,4,6);
				break;
			case 6:
				/* 6 = 7 */
				move(3,0,1,2,7,4,5,7);
				break;
			default:
			  Tcl_AppendResult(interp, "redoarb: ", input.s.s_name,
					   " - bad arb7\n", (char *)NULL);
			  return( 0 );
			}
			break;    	/* end of ARB7 case */
d677 5
a681 2
		case ARB6:
			/* arb6 vectors:  0 1 2 3 4 4 6 6 */
d683 1
a683 58
			prod = 1;
			for(i=0; i<numvec; i++)
				prod = prod * (uvec[i] + 1);
			switch( prod ) {
			case 24:
				/* 0123 unique */
				/* 4=7 and 5=6  OR  4=5 and 6=7 */
				if(svec[3] == 7)
					move(3,0,1,2,4,4,5,5);
				else
					move(0,1,2,3,4,4,6,6);
				break;
			case 1680:
				/* 4567 unique */
				/* 0=3 and 1=2  OR  0=1 and 2=3 */
				if(svec[3] == 3)
					move(7,4,5,6,0,0,1,1);
				else
					move(4,5,6,7,0,0,2,2);
				break;
			case 160:
				/* 0473 unique */
				/* 1=2 and 5=6  OR  1=5 and 2=6 */
				if(svec[3] == 2)
					move(0,3,7,4,1,1,5,5);
				else
					move(4,0,3,7,1,1,2,2);
				break;
			case 672:
				/* 3267 unique */
				/* 0=1 and 4=5  OR  0=4 and 1=5 */
				if(svec[3] == 1)
					move(3,2,6,7,0,0,4,4);
				else
					move(7,3,2,6,0,0,1,1);
				break;
			case 252:
				/* 1256 unique */
				/* 0=3 and 4=7  OR 0=4 and 3=7 */
				if(svec[3] == 3)
					move(1,2,6,5,0,0,4,4);
				else
					move(5,1,2,6,0,0,3,3);
				break;
			case 60:
				/* 0154 unique */
				/* 2=3 and 6=7  OR  2=6 and 3=7 */
				if(svec[3] == 3)
					move(0,1,5,4,2,2,6,6);
				else
					move(5,1,0,4,2,2,3,3);
				break;
			default:
			  Tcl_AppendResult(interp, "redoarb: ", input.s.s_name,
					   " - bad arb6\n", (char *)NULL);
			  return( 0 );
			}
			break; 		/* end of ARB6 case */
d685 1
a685 36
		case ARB5:
			/* arb5 vectors:  0 1 2 3 4 4 4 4 */
			prod = 1;
			for(i=2; i<6; i++)
				prod = prod * (svec[i] + 1);
			switch( prod ) {
			case 24:
				/* 0=1=2=3 */
				move(4,5,6,7,0,0,0,0);
				break;
			case 1680:
				/* 4=5=6=7 */
				/* do nothing */
				break;
			case 160:
				/* 0=3=4=7 */
				move(1,2,6,5,0,0,0,0);
				break;
			case 672:
				/* 2=3=7=6 */
				move(0,1,5,4,2,2,2,2);
				break;
			case 252:
				/* 1=2=5=6 */
				move(0,3,7,4,1,1,1,1);
				break;
			case 60:
				/* 0=1=5=4 */
				move(3,2,6,7,0,0,0,0);
				break;
			default:
			  Tcl_AppendResult(interp, "redoarb: ", input.s.s_name,
					   " - bad arb5\n", (char *)NULL);
			  return( 0 );
			}
			break;		/* end of ARB5 case */
d687 4
a690 7
		case ARB4:
			/* arb4 vectors:  0 1 2 0 4 4 4 4 */
			j = svec[6];
			if( svec[0] == 2 )
				j = svec[4];
			move(uvec[0],uvec[1],svec[2],uvec[0],j,j,j,j);
			break;
d692 1
a692 3
		default:
		  {
		    struct bu_vls tmp_vls;
d694 2
a695 6
		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "redoarb %s: unknown arb type (%d)\n",
				  input.s.s_name,input.s.s_cgtype);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }
d697 1
a697 2
		  return( 0 );
	}
d699 10
a708 2
	return( 1 );
}
d710 4
d715 2
a716 27
static void
move( p0, p1, p2, p3, p4, p5, p6, p7 )
int p0, p1, p2, p3, p4, p5, p6, p7;
{
	register int i, j;
	static int pts[8];
	static dbfloat_t copy[24];

	pts[0] = p0 * 3;
	pts[1] = p1 * 3;
	pts[2] = p2 * 3;
	pts[3] = p3 * 3;
	pts[4] = p4 * 3;
	pts[5] = p5 * 3;
	pts[6] = p6 * 3;
	pts[7] = p7 * 3;

	/* copy of the record */
	for(i=0; i<=21; i+=3) {
		VMOVE(&copy[i], &input.s.s_values[i]);
	}

	for(i=0; i<8; i++) {
		j = pts[i];
		VMOVE(&input.s.s_values[i*3], &copy[j]);
	}
}
d718 7
d726 1
a726 4
static void
vectors()
{
	register int i;
d728 1
a728 2
	for(i=3; i<=21; i+=3) {
		VSUB2(&input.s.s_values[i],&input.s.s_values[i],&input.s.s_values[0]);
a729 1
}
d731 1
d733 1
d735 3
a737 4
static void
points()
{
	register int i;
d739 3
a741 4
	for(i=3; i<=21; i+=3) {
		VADD2(&input.s.s_values[i],&input.s.s_values[i],&input.s.s_values[0]);
	}
}
d743 40
d784 2
a785 29


/*
 *      		D W R E G
 *
 *	Draws an "edge approximation" of a region
 *
 *	All solids are converted to planar approximations.
 *	Logical operations are then applied to the solids to
 *	produce the edge representation of the region.
 *
 * 	Gary Kuehl 	2Feb83
 *
 * 	Routines used by dwreg():
 *	  1. gap()   	puts gaps in the edges
 *	  2. region()	finds intersection of ray with a region
 *	  5. center()	finds center point of an arb
 *	  6. tplane()	tests if plane is inside enclosing rpp
 *	  7. arb()	finds intersection of ray with an arb
 *	  8. tgcin()	converts tgc to arbn
 *	  9. ellin()	converts ellg to arbn
 *	 10. regin()	process region to planes
 *	 11. solin()	finds enclosing rpp for solids
 *	 12. solpl()	process solids to arbn's
 *
 *		R E V I S I O N   H I S T O R Y
 *
 *	11/02/83  CMK	Modified to use g3.c module (device independence).
 */
d787 1
d789 3
a791 43
#define NPLANES	500
static fastf_t	peq[NPLANES*4];		/* plane equations for EACH region */
static fastf_t	solrpp[NMEMB*6];	/* enclosing RPPs for each member of the region */
static fastf_t	regi[NMEMB], rego[NMEMB];	/* distances along ray where ray enters and leaves the region */
static fastf_t	pcenter[3];		/* center (interior) point of a solid */
static fastf_t	reg_min[3], reg_max[3];		/* min,max's for the region */
static fastf_t	sol_min[3], sol_max[3];		/* min,max's for a solid */
static fastf_t	xb[3];			/* starting point of ray */
static fastf_t	wb[3];			/* direction cosines of ray */
static fastf_t	rin, rout;		/* location where ray enters and leaves a solid */
static fastf_t	ri, ro;			/* location where ray enters and leaves a region */
static fastf_t	tol;			/* tolerance */
static fastf_t	*sp, *savesp;		/* pointers to the solid parameter array m_param[] */
static int	mlc[NMEMB];		/* location of last plane for each member */
static int	la, lb, lc, id, jd, ngaps;
static fastf_t	pinf = 1000000.0;
static int	negpos;
static char	oper;

static void
dwreg(vhead)
struct bu_list	*vhead;
{
	register int i,j;
	static int k,l;
	static int n,m;
	static int itemp;
	static int lmemb, umemb;/* lower and upper limit of members of region
				 * from one OR to the next OR */

	/* calculate center and scale for COMPLETE REGION since may have ORs */
	lmemb = umemb = 0;
	savesp = &m_param[0];
	while( 1 ) {
		/* Perhaps this can be eliminated?  Side effects? */
		for(umemb = lmemb+1; (umemb < nmemb && m_op[umemb] != 'u'); umemb++)
			;
		lc = 0;
		regin(1, lmemb, umemb);
		lmemb = umemb;
		if(umemb >= nmemb)
			break;
	}
d793 2
a794 2
	lmemb = 0;
	savesp = &m_param[0];
d796 2
a797 35
orregion:	/* sent here if region has or's */
	for(umemb = lmemb+1; (umemb < nmemb && m_op[umemb] != 'u'); umemb++)
		;

	lc = 0;
	regin(0, lmemb, umemb);

	l=0;

	/* id loop processes all member to the next OR */
	for(id=lmemb; id<umemb; id++) {
		if(mlc[id] < l)
			goto skipid;

		/* plane i is associated with member id */
		for(i=l; (i<(lc-1) && i<=mlc[id]); i++){
			m = i + 1;
			itemp = id;
			if(i == mlc[id])
				itemp = id + 1;
			for(jd=itemp; jd<umemb; jd++) {

				negpos = 0;
				if( (m_op[id] == '-' && m_op[jd] != '-') ||
				    (m_op[id] != '-' && m_op[jd] == '-') )
					negpos = 1;

				/* plane j is associated with member jd */
				for(j=m; j<=mlc[jd]; j++){
					if(id!=jd && m_op[id]=='-' && m_op[jd]=='-') { 
						for(k=0; k<3; k++) {
							if(solrpp[6*id+k] > solrpp[6*jd+k+3] || 
							   solrpp[6*id+k+3] < solrpp[6*jd+k] )
								goto sksolid;
						}
d799 24
a822 10
						for(k=mlc[jd-1]+1; k<=mlc[jd]; k++) {
							if(fabs(peq[i*4+3] - peq[k*4+3]) < tol && 
							    VDOT(&peq[i*4], &peq[k*4]) > .9999) {
								for(k=l; k<=mlc[id]; k++) {
									if(fabs(peq[j*4+3] - peq[k*4+3]) < tol && 
									    VDOT(&peq[j*4], &peq[k*4]) > .9999)
										goto noskip;
								}
								goto sksolid;
							}
d824 26
a849 4
						for(k=l; k<= mlc[id]; k++) {
							if(fabs(peq[j*4+3] - peq[k*4+3]) < tol && 
							    VDOT(&peq[j*4], &peq[k*4]) > .9999)
								goto skplane;
d851 2
d854 8
a861 3
noskip:
					if( bn_isect_2planes( xb, wb,
					    &peq[i*4], &peq[j*4], reg_min, &mged_tol ) < 0 )
d863 15
d879 3
a881 2
					/* check if ray intersects region */
					if( (k=region(lmemb,umemb))<=0)
d884 4
a887 9
					/* ray intersects region */
					/* plot this ray  including gaps */
					for(n=0; n<k; n++){
						static vect_t	pi, po;

						VJOIN1( pi, xb, regi[n], wb );
						VJOIN1( po, xb, rego[n], wb );
						RT_ADD_VLIST( vhead, pi, RT_VLIST_LINE_MOVE );
						RT_ADD_VLIST( vhead, po, RT_VLIST_LINE_DRAW );
d889 10
a898 1
skplane:				 ;
a899 2
sksolid:
				m = mlc[jd] + 1;
a901 2
skipid:
		l=mlc[id]+1;
d903 1
d905 2
a907 6
	lmemb = umemb;
	if(umemb < nmemb)
		goto orregion;

	nmemb = 0;
	/* The finishing touches are done by EdrawHsolid() */
d910 3
a912 5

/* put gaps into region line */
static int
gap(si,so)
fastf_t si,so;
d914 1
a914 1
	register int igap,lgap,i;
d916 28
a943 10
	if(si<=ri+tol) goto front;
	if(so>=ro-tol) goto back;
	if(ngaps>0){
		for(igap=0;igap<ngaps;igap++) {
			/* locate position of gap along ray */
			if(si<=(regi[igap+1]+tol)) 
				goto insert;
		}
	}
	if((++ngaps)==25) return(-1);
d945 2
a946 63
	/* last gap along ray */
	rego[ngaps-1]=si;
	regi[ngaps]=so;
	return(1);

insert:		/* insert gap in ray between existing gaps */
	if(so < (rego[igap]-tol)) goto novlp;

	/* have overlapping gaps - sort out */
	V_MIN(rego[igap],si);
	if(regi[igap+1]>=so) return(1);
	regi[igap+1]=so;
	for(lgap=igap;(lgap<ngaps&&so<(rego[lgap]-tol));lgap++)
		;
	if(lgap==igap) return(1);
	if(so>regi[lgap+1]) {
		lgap++;
		igap++;
	}
	while(lgap<ngaps){
		rego[igap]=rego[lgap];
		regi[igap+1]=regi[lgap+1];
		lgap++;
		igap++;
	}
	ngaps=ngaps-lgap+igap;
	return(1);

novlp:		/* no overlapping gaps */
	if((++ngaps)>=25) return(-1);
	for(lgap=igap+1;lgap<ngaps;lgap++){
		rego[lgap]=rego[lgap-1];
		regi[lgap+1]=regi[lgap];
	}
	rego[igap]=si;
	regi[igap+1]=so;
	return(1);

front:		/* gap starts before beginning of ray */
	if((so+tol)>ro)
		return(0);
	V_MAX(ri,so);
	if(ngaps<1) return(1);
	for(igap=0; ((igap<ngaps) && ((ri+tol)>rego[igap])); igap++)
		;
	if(igap<1) return(1);
	V_MAX(ri, regi[igap]);
	lgap=ngaps;
	ngaps=0;
	if(igap>=lgap) return(1);
	for(i=igap;i<lgap;i++){
		rego[ngaps++]=rego[i];
		regi[ngaps]=regi[i+1];
	}
	return(1);

back:		/* gap ends after end of ray */
	V_MIN(ro,si);
	if(ngaps<1) return(1);
	for(igap=ngaps; (igap>0 && (ro<(regi[igap]+tol))); igap--)
		;
	if(igap < ngaps) {
		V_MIN(ro, rego[igap]);
a947 2
	ngaps=igap;
	return(1);
d950 24
d975 2
a976 39
/* computes intersection of ray with region 
 *   	returns ngaps+1	if intersection
 *	        0	if no intersection
 */
static int
region(lmemb,umemb)
{
	register int	i, kd;
	static vect_t	s1, s2;
	static fastf_t a1, a2;

	ngaps=0;
	ri = -1.0 * pinf;
	ro=pinf;

	/* does ray intersect region rpp */
	VSUB2( s1, reg_min, xb );
	VSUB2( s2, reg_max, xb );

	/* find start & end point of ray with enclosing rpp */
	for(i=0;i<3;i++){
		if(fabs(wb[i])>.001){
			a1=s1[i]/wb[i];
			a2=s2[i]/wb[i];
			if(wb[i] <= 0.){
				if(a1<tol) return(0);
				V_MAX(ri,a2);
				V_MIN(ro,a1);
			} else {
				if(a2<tol) return(0);
				V_MAX(ri,a1);
				V_MIN(ro,a2);
			}
			if((ri+tol)>=ro) return(0);
		} else {
			if(s1[i]>tol || s2[i]<(-1.0*tol)) 
				return(0);
		}
	}
d978 1
a978 5
	/* ray intersects region - find intersection with each member */
	la=0;
	for(kd=lmemb;kd<umemb;kd++){
		oper=m_op[kd];
		lb=mlc[kd];
d980 2
a981 3
		/* if la > lb then no planes to check for this member */
		if(la > lb)
			continue;
d983 6
a988 24
		if(kd==id || kd==jd) oper='+';
		if(oper!='-'){
			/* positive solid  recalculate end points of ray */
			if( arb() == 0 )
				return(0);
			if(ngaps==0){
				V_MAX(ri,rin);
				V_MIN(ro,rout);
			} else{
				if(gap(-pinf, rin) <= 0)
					return(0);
				if(gap(rout, pinf) <= 0)
					return(0);
			}
		}
		if(oper == '-') {
			/* negative solid  look for gaps in ray */
			if(arb() != 0) {
				if(gap(rin, rout) <= 0)
					return(0);
			}
		}
		if(ri+tol>=ro) return(0);
		la=lb+1;
d991 12
a1002 5
	/*end of region - set number of intersections*/
	regi[0]=ri;
	rego[ngaps]=ro;
	return(ngaps+1);
}
d1004 2
d1007 7
a1013 6
/* find center point */
static void
center()
{
	register fastf_t ppc;
	register int i,j,k;
d1015 4
a1018 6
	for(i=0;i<3;i++){
		k=i;
		ppc=0.0;
		for(j=0; j<m_type[id]; j++) {
			ppc += *(sp+k);
			k+=3;
d1020 5
a1024 3
		pcenter[i]=ppc/(fastf_t)m_type[id];
	}
}
d1026 2
d1029 2
a1030 12
/*
 *			T P L A N E
 *
 *  Register a plane which contains the 4 specified points,
 *  unless they are degenerate, or lie outside the region RPP.
 */
static void
tplane(p,q,r,s)
fastf_t *p, *q, *r, *s;
{
	register fastf_t *pp,*pf;
	register int i;
d1032 1
a1032 10
	/* If all 4 pts have coord outside region RPP,
	 * discard this plane, as the polygon is definitely outside */
	for(i=0;i<3;i++){
		FAST fastf_t t;
		t=reg_min[i]-tol;
		if(*(p+i)<t && *(q+i)<t && *(r+i)<t && *(s+i)<t)
			return;
		t=reg_max[i]+tol;
		if(*(p+i)>t && *(q+i)>t && *(r+i)>t  && *(s+i)>t)
			return;
d1035 1
a1035 10
	/* Do these three points form a valid plane? */
	/* WARNING!!  Fourth point is never even looked at!! */
	pp = &peq[lc*4];
	/* Dist tol here used to be 1e-6 */
	if( bn_mk_plane_3pts( pp, p, q, r, &mged_tol ) < 0 )  return;

	if((pp[3]-VDOT(pp,pcenter)) > 0.)  {
		VREVERSE( pp, pp );
		pp[3] = -pp[3];
	}
d1037 2
a1038 5
	/* See if this plane already exists */
	for(pf = &peq[0];pf<pp;pf+=4) {
		 if(VDOT(pp,pf)>0.9999 && fabs(*(pp+3)-*(pf+3))<tol) 
			return;
	}
d1040 1
a1040 12
	/* increment plane counter */
	if(lc >= NPLANES) {
	  struct bu_vls tmp_vls;
	  
	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "tplane: More than %d planes for a region - ABORTING\n",
			NPLANES);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  return;
	}
	lc++;		/* Save plane eqn */
d1043 6
a1048 3
/* finds intersection of ray with arbitrary convex polyhedron */
static int
arb()
d1050 1
a1050 1
	static fastf_t s,*pp,dxbdn,wbdn,te;
d1052 28
a1079 2
	rin = ri;
	rout = ro;
d1081 9
a1089 20
	te = tol;
	if(oper == '-' && negpos)
		te = -1.0 * tol;

	for(pp = &peq[la*4];pp <= &peq[lb*4];pp+=4){
		dxbdn = *(pp+3)-VDOT(xb,pp);
		wbdn=VDOT(wb,pp);
		if(fabs(wbdn)>.001){
			s=dxbdn/wbdn;
			if(wbdn > 0.0) {
				V_MAX(rin, s);
			}
			else {
				V_MIN(rout,s);
			}
		}
		else{
			if(dxbdn>te) return(0);
		}
		if((rin+tol)>=rout || rout<=tol) return(0);
a1090 4
	/* ray starts inside */
	V_MAX(rin,0);
	return(1);
}
d1092 1
d1094 6
a1099 32

/* convert tgc to an arbn */
static void
tgcin()
{
	static fastf_t vt[3], p[3], q[3], r[3], t[3];
	static fastf_t s,sa,c,ca,sd=.38268343,cd=.92387953;
	register int i,j,lk;

	lk = lc;

	for(i=0;i<3;i++){
		vt[i] = *(sp+i) + *(sp+i+3);
		pcenter[i]=( *(sp+i) + vt[i])*.5;
		p[i] = *(sp+i) + *(sp+i+6);
		t[i] = vt[i] + *(sp+i+12);
	}
	s=0.;
	c=1.;
	for(i=0;i<16;i++){
		sa=s*cd+c*sd;
		ca=c*cd-s*sd;
		for(j=0;j<3;j++){
			q[j] = *(sp+j) + ca * *(sp+j+6) + sa * *(sp+j+9);
			r[j]=vt[j]+ ca * *(sp+j+12) + sa* *(sp+j+15);
		}
		tplane( p, q, r, t );
		s=sa;
		c=ca;
		for(j=0; j<3; j++) {
			p[j] = q[j];
			t[j] = r[j];
a1101 1
	if(lc == lk)	return;
d1103 5
a1107 15
	/* top plane */
	for(i=0; i<3; i++) {
		p[i]=vt[i] + *(sp+i+12) + *(sp+i+15);
		q[i]=vt[i] + *(sp+i+15) - *(sp+i+12);
		r[i]=vt[i] - *(sp+i+12) - *(sp+i+15);
		t[i]=vt[i] + *(sp+i+12) - *(sp+i+15);
	}
	tplane( p, q, r, t );

	/* bottom plane */
	for(i=0;i<3;i++){
		p[i] = *(sp+i) + *(sp+i+6) + *(sp+i+9);
		q[i] = *(sp+i) + *(sp+i+9) - *(sp+i+6);
		r[i] = *(sp+i) - *(sp+i+6) - *(sp+i+9);
		t[i] = *(sp+i) + *(sp+i+6) - *(sp+i+9);
a1108 2
	tplane( p, q, r, t );
}
d1111 3
a1113 52
/* convert ellg to an arbn */
static void
ellin()
{
	static fastf_t p[3], q[3], r[3], t[3];
	static fastf_t s1,s2,sa,c1,c2,ca,sd=.5,cd=.8660254,sgn;
	static fastf_t se, ce;
	register int i,j,ih,ie;

	sgn = -1.;
	for(i=0;i<3;i++) pcenter[i] = *(sp+i);
	for(ih=0;ih<2;ih++){
		c2=1.;
		s2=0.;

		/* find first point */
		for(ie=0;ie<3;ie++){
			s1=0.;
			c1=1.;
			se=s2*cd+c2*sd;
			ce=c2*cd-s2*sd;
			for(i=0;i<3;i++) {
				p[i] = *(sp+i) + (c2 * (*(sp+i+3)))
				       + (sgn * s2 * (*(sp+i+9)));
				t[i] = *(sp+i) + (ce * (*(sp+i+3)))
				       + (sgn * se * (*(sp+i+9)));
			}
			for(i=0;i<12;i++){
				sa=s1*cd+c1*sd;
				ca=c1*cd-s1*sd;
				for(j=0;j<3;j++){
					q[j] = *(sp+j) + (ca * c2 * (*(sp+j+3))) 
						+ (sa * c2 * (*(sp+j+6))) 
						+ (s2 * sgn * (*(sp+j+9)));
					r[j] = *(sp+j) + (c1 * ce* (*(sp+j+3))) 
						+ (s1 * ce * (*(sp+j+6))) 
						+ (se * sgn * (*(sp+j+9)));
				}
				tplane( p, q, r, t );
				s1=sa;
				c1=ca;
				for(j=0; j<3; j++) {
					p[j] = q[j];
					t[j] = r[j];
				}
			}
			c2=ce;
			s2=se;
		}
		sgn = -sgn;
	}
}
d1115 4
d1120 1
a1120 6
/* process region into planes */
static void
regin(flag, lmemb, umemb)
int flag;	/* 1 if only calculating min,maxs   NO PLANE EQUATIONS */
{
	register int i,j;
d1122 6
a1127 13
	tol=reg_min[0]=reg_min[1]=reg_min[2] = -pinf;
	reg_max[0]=reg_max[1]=reg_max[2]=pinf;
	sp = savesp;

	/* find min max's */
	for(i=lmemb;i<umemb;i++){
		solin(i);
		if(m_op[i] != '-') {
			for(j=0;j<3;j++){
				V_MAX(reg_min[j],sol_min[j]);
				V_MIN(reg_max[j],sol_max[j]);
			}
		}
a1128 5
	for(i=0;i<3;i++){
		V_MAX(tol,fabs(reg_min[i]));
		V_MAX(tol,fabs(reg_max[i]));
	}
	tol=tol*0.00001;
d1130 2
a1131 5
	if(flag == 0 ) {
		/* find planes for each solid */
		sp = savesp;
		solpl(lmemb,umemb);
	}
d1133 2
a1134 3
	/* save the parameter pointer in case region has ORs */
	savesp = sp;
}
d1136 2
d1139 1
a1139 51
/* finds enclosing RPP for a solid using the solid's parameters */
static void
solin(num)
int num;
{
	static int amt[19]={0,0,0,12,15,18,21,24,0,0,0,0,0,0,0,0,0,18,12};
	register int *ity,i,j;
	static fastf_t a,b,c,d,v1,v2,vt,vb;

	ity = &m_type[num];
	if(*ity==20) *ity=8;
	if(*ity>19 || amt[*ity-1]==0){
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "solin: Type %d Solid not known\n",*ity);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  return;
	}
	sol_min[0]=sol_min[1]=sol_min[2]=pinf;
	sol_max[0]=sol_max[1]=sol_max[2] = -pinf;

	/* ARB4,5,6,7,8 */
	if(*ity<18){
		for(i=0;i<*ity;i++){
			for(j=0;j<3;j++){
				V_MIN(sol_min[j],*sp);
				V_MAX(sol_max[j],*sp);
				sp++;
			}
		}
	}

	/* TGC */
	if(*ity==18){
		for(i=0;i<3;i++,sp++){
			vt = *sp + *(sp+3);
			a = *(sp+6);
			b = *(sp+9);
			c = *(sp+12);
			d = *(sp+15);
			v1=sqrt(a*a+b*b);
			v2=sqrt(c*c+d*d);
			V_MIN(sol_min[i],*(sp)-v1);
			V_MIN(sol_min[i],vt-v2);
			V_MAX(sol_max[i],*(sp)+v1);
			V_MAX(sol_max[i],vt+v2);			
		}
		sp+=15;
	}
d1141 2
a1142 16
	if(*ity > 18) {
		/* ELLG */
		for(i=0;i<3;i++,sp++){
			vb = *sp - *(sp+3);
			vt = *sp + *(sp+3);
			a = *(sp+6);
			b = *(sp+9);
			v1=sqrt(a*a+b*b);
			v2=sqrt(c*c+d*d);
			V_MIN(sol_min[i],vb-v1);
			V_MIN(sol_min[i],vt-v2);
			V_MAX(sol_max[i],vb+v1);
			V_MAX(sol_max[i],vt+v2);
		}
		sp+=9;
	}
d1144 1
a1144 6
	/* save min,maxs for this solid */
	for(i=0; i<3; i++) {
		solrpp[num*6+i] = sol_min[i];
		solrpp[num*6+i+3] = sol_max[i];
	}
}
d1146 2
d1149 7
a1155 44
/* converts all solids to ARBNs */
/* Called only from regin() */
static void
solpl(lmemb,umemb)
{
	static fastf_t tt;
	static int ls, n4;
	static fastf_t *pp,*p1,*p2,*p3,*p4;
	register int i,j;
	static int nfc[5]={4,5,5,6,6};
	static int iv[5*24]={
		 0,1,2,0, 3,0,1,0, 3,1,2,1, 3,2,0,0, 0,0,0,0, 0,0,0,0,
		 0,1,2,3, 4,0,1,0, 4,1,2,1, 4,2,3,2, 4,3,0,0, 0,0,0,0,
		 0,1,2,3, 1,2,5,4, 0,4,5,3, 4,0,1,0, 5,2,3,2, 0,0,0,0,
		 0,1,2,3, 4,5,6,4, 0,3,4,0, 1,2,6,5, 0,1,5,4, 3,2,6,4,
		 0,1,2,3, 4,5,6,7, 0,4,7,3, 1,2,6,5, 0,1,5,4, 3,2,6,7};

	lc=0;
	tt=tol*10.;
	for(id=lmemb;id<umemb;id++){
		ls=lc;
		if(m_type[id]<18){

			/* ARB 4,5,6,7,8 */
			n4=m_type[id]-4;
			center();
			j=n4*24;
			for(i=0;i<nfc[n4];i++){
				p1=sp+iv[j++]*3;
				p2=sp+iv[j++]*3;
				p3=sp+iv[j++]*3;
				p4=sp+iv[j++]*3;
				tplane(p1,p2,p3,p4);
			}
			sp+=m_type[id]*3;
		}
		if(m_type[id]==18){
			tgcin();
			sp+=18;
		}
		if(m_type[id]==19){
			ellin();
			sp+=12;
		}
d1157 1
a1157 7
		if(m_op[id]=='-'){
			pp = &peq[4*ls]+3;
			while(ls++ < lc) {
				*pp-=tt;
				pp+=4;
			}
		}
d1159 1
a1159 2
		mlc[id]=lc-1;
	}
@


11.14
log
@Changed ma_matparm stuff to ma_shader
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.13 1996/10/22 21:10:18 bparker Exp mike $ (BRL)";
d37 1
d55 1
a55 1
extern struct rt_tol		mged_tol;		/* from ged.c */
d189 1
a189 1
	mat_idn( root );
d211 1
a211 1
	struct rt_external	ext;
d290 1
a290 1
					((double)(rp[0].c.c_rgb[0]))*rt_inv255;
d292 1
a292 1
					((double)(rp[0].c.c_rgb[1]))*rt_inv255;
d294 1
a294 1
					((double)(rp[0].c.c_rgb[2]))*rt_inv255;
d375 1
a375 1
		mat_mul(new_xlate, old_xlate, xmat);
d405 1
a405 1
struct rt_external	*ep;
d1216 1
a1216 1
					if( rt_isect_2planes( xb, wb,
d1472 1
a1472 1
	if( rt_mk_plane_3pts( pp, p, q, r, &mged_tol ) < 0 )  return;
@


11.13
log
@hacks to use latest libdm
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.12 1996/09/30 19:45:10 bparker Exp $ (BRL)";
d303 6
a308 2
				strncpy( curmater.ma_matname, rp[0].c.c_matname, sizeof(rp[0].c.c_matname) );
				strncpy( curmater.ma_matparm, rp[0].c.c_matparm, sizeof(rp[0].c.c_matparm) );
@


11.12
log
@call color_soltab from f_evedit
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.11 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d111 1
a111 1
		if( dmp->dmr_displaylist )  {
d156 3
a158 1
	dmp->dmr_colorchange(dmp);
d530 1
a530 1
	if( !no_memory && (sp->s_bytes = dmp->dmr_cvtvecs( dmp, sp )) != 0 )  {
d532 1
a532 1
		sp->s_addr = rt_memalloc( &(dmp->dmr_map), sp->s_bytes );
d538 1
a538 1
			sp->s_bytes = dmp->dmr_load(dmp, sp->s_addr, sp->s_bytes );
d546 3
a548 1
	  dmp->dmr_viewchange( dmp, DM_CHGV_ADD, sp );
d552 3
a554 1
	  dmp->dmr_viewchange( dmp, DM_CHGV_REPL, sp );
@


11.11
log
@now using more generalized solid macros
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.10 1996/09/23 18:17:21 bparker Exp bparker $ (BRL)";
d154 2
@


11.10
log
@use LIBDM permanently
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.9 1996/09/17 21:20:57 bparker Exp bparker $ (BRL)";
d41 1
a41 1
#include "./solid.h"
d139 1
a139 1
	if( first_time && HeadSolid.s_forw != &HeadSolid)  {
d253 1
a253 1
		GET_SOLID( sp );
d257 1
a257 1
			FREE_SOLID( sp );
d541 2
a542 2
		APPEND_SOLID( sp, HeadSolid.s_back );
		dmp->dmr_viewchange( dmp, DM_CHGV_ADD, sp );
d544 3
a546 3
		/* replacing illuminated solid -- struct already linked in */
		sp->s_iflag = UP;
		dmp->dmr_viewchange( dmp, DM_CHGV_REPL, sp );
@


11.9
log
@prepare to use libdm
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.8 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d42 1
a42 1
#include "./dm.h"
a43 1
#ifdef USE_LIBDM
a44 1
#endif
a153 1
#ifdef USE_LIBDM
a154 3
#else
	dmp->dmr_colorchange();
#endif
a525 1
#ifdef USE_LIBDM
a526 3
#else
	if( !no_memory && (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
#endif
a533 1
#ifdef USE_LIBDM
a534 3
#else
			sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes );
#endif
a541 1
#ifdef USE_LIBDM
a542 3
#else
		dmp->dmr_viewchange( DM_CHGV_ADD, sp );
#endif
a545 1
#ifdef USE_LIBDM
a546 3
#else
		dmp->dmr_viewchange( DM_CHGV_REPL, sp );
#endif
@


11.8
log
@rt_list ---> bu_list
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.7 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d44 4
d156 3
a158 1

d160 1
d532 3
d536 1
d544 3
d548 1
d556 3
d560 1
d564 3
d568 1
@


11.7
log
@now using libbu
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.6 1996/08/21 19:20:55 jra Exp bparker $ (BRL)";
d35 1
d401 1
a401 1
	struct rt_list	vhead;
d404 1
a404 1
	RT_LIST_INIT( &vhead );
d494 1
a494 1
	RT_LIST_APPEND_LIST( &(sp->s_vlist), &vhead );
d707 1
a707 1
struct rt_list	*vhead;
d1122 1
a1122 1
struct rt_list	*vhead;
@


11.6
log
@Increased limit for number of members in a big-E region to 250.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.5 1996/04/18 20:28:43 bparker Exp jra $ (BRL)";
d144 1
a144 1
	  struct rt_vls tmp_vls;
d146 4
a149 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "E: %ld vectors in %ld sec\n", nvectors, etime - stime );
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d211 1
a211 1
	  struct rt_vls tmp_vls;
d213 4
a216 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "nesting exceeds %d levels\n", MAX_PATH );
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d236 1
a236 1
		  struct rt_vls tmp_vls;
d238 2
a239 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "Edrawobj(%s):  defective database record, type='%c' (0%o) addr=x%x\n",
d241 2
a242 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d307 1
a307 1
	    struct rt_vls tmp_vls;
d309 2
a310 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "regionid %d overriden by %d\n",
d312 2
a313 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d605 1
a605 1
	  struct rt_vls tmp_vls;
d607 4
a610 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "proc_reg: region has more than %d members\n", NMEMB);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d688 1
a688 1
	    struct rt_vls tmp_vls;
d690 2
a691 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "proc_reg:  Cannot draw solid type %d (%s)\n",
d694 2
a695 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d811 1
a811 1
	    struct rt_vls tmp_vls;
d813 2
a814 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "solid: %s  bad number of unique vectors (%d)\n",
d816 2
a817 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d1001 1
a1001 1
		    struct rt_vls tmp_vls;
d1003 2
a1004 2
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "redoarb %s: unknown arb type (%d)\n",
d1006 2
a1007 2
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		    rt_vls_free(&tmp_vls);
d1472 1
a1472 1
	  struct rt_vls tmp_vls;
d1474 2
a1475 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "tplane: More than %d planes for a region - ABORTING\n",
d1477 2
a1478 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d1680 1
a1680 1
	  struct rt_vls tmp_vls;
d1682 4
a1685 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "solin: Type %d Solid not known\n",*ity);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
@


11.5
log
@convert commands to Tcl
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.4 1996/03/01 19:30:22 bparker Exp bparker $ (BRL)";
d68 1
a68 1
#define NMEMB	100	/* max number of members in a region */
@


11.4
log
@remove unused XMGED stuff
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.3 1995/02/18 03:09:05 mike Exp bparker $ (BRL)";
d84 3
a86 1
f_evedit( argc, argv )
d95 3
d125 5
a129 5
			rt_log("No memory left so cannot draw %s\n",
				dp->d_namep);
			drawreg = 0;
			regmemb = -1;
			continue;
d143 9
a151 1
	rt_log("E: %ld vectors in %ld sec\n", nvectors, etime - stime );
d155 1
a155 1
	return CMD_OK;
d211 12
a222 5
		rt_log("nesting exceeds %d levels\n", MAX_PATH );
		for(i=0; i<MAX_PATH; i++)
			rt_log("/%s", cur_path[i]->d_namep );
		rt_log("\n");
		return;			/* ERROR */
d236 9
a244 4
			rt_log("Edrawobj(%s):  defective database record, type='%c' (0%o) addr=x%x\n",
				dp->d_namep,
				rp[0].u_id, rp[0].u_id, dp->d_addr );
			goto out;		/* ERROR */
d265 3
a267 3
		rt_log("Warning: combination with zero members \"%s\".\n",
			dp->d_namep );
		goto out;			/* non-fatal ERROR */
d278 1
a278 2
			rt_log("Edrawobj: ERROR: color override in combination within region %s\n",
				dp->d_namep );
d294 1
a294 2
			rt_log("Edrawobj: ERROR: material property spec in combination within region %s\n",
				dp->d_namep );
d306 11
a316 4
		if( regionid != 0 )
			rt_log("regionid %d overriden by %d\n",
				regionid, rp[0].c.c_regionid );
		regionid = rp[0].c.c_regionid;
d324 12
a335 13
		if( regmemb >= 0  ) {
			rt_log(
			"ERROR: region (%s) is member of region (%s)\n",
				dp->d_namep,
				cur_path[reg_pathpos]->d_namep);
			goto out;	/* ERROR */
		}
		/* Well, we are processing regions and this is a region */
		/* if region has only 1 member, don't process as a region */
		if( dp->d_len > 2) {
			regmemb = dp->d_len-1;
			reg_pathpos = pathpos;
		}
d346 3
a348 3
			rt_log("EdrawHobj:  %s bad member rec\n",
				dp->d_namep);
			goto out;			/* ERROR */
d423 9
a431 9
			/* error somwhere */
			rt_log("Error in converting solid %s to ARBN\n",
					cur_path[reg_pathpos]->d_namep);
			reg_error = 1;
			if(regmemb == 0) {
				regmemb = -1;
				reg_error = 0;
			}
			return(-1);		/* ERROR */
d438 1
a438 1
			return(0);		/* NOP -- more to come */
d442 2
a443 2
			rt_log("error in finish_region()\n");
			return(-1);		/* ERROR */
d455 3
a457 3
			rt_log("EdrawHsolid(%s):  unknown database object\n",
				cur_path[pathpos]->d_namep);
			return(-1);			/* ERROR */
d462 4
a465 4
			rt_log("%s:  solid import failure\n",
				cur_path[pathpos]->d_namep);
		    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
			return(-1);			/* FAIL */
d475 4
a478 4
		    &intern,
		    &ttol, &mged_tol ) < 0 )  {
			rt_log("%s: vector conversion failure\n",
				cur_path[pathpos]->d_namep);
d528 3
a530 3
			no_memory = 1;
			rt_log("Edraw: out of Displaylist\n");
			sp->s_bytes = 0;	/* not drawn */
d605 8
a612 3
		rt_log("proc_reg: region has more than %d members\n", NMEMB);
		nmemb = param_count = memb_count = 0;
		return(-1);	/* ERROR */
d687 13
a699 5
		rt_log("proc_reg:  Cannot draw solid type %d (%s)\n",
			type, type == TOR ? "TOR":
			 type == ARS ? "ARS" : "UNKNOWN TYPE" );
		nmemb = param_count = memb_count = 0;
		return(-1);	/* ERROR */
d810 11
a820 3
		rt_log("solid: %s  bad number of unique vectors (%d)\n",
			input.s.s_name, numuvec);
		return(0);
d886 3
a888 3
				rt_log("redoarb: %s - bad arb7\n",
					input.s.s_name);
				return( 0 );
d948 3
a950 3
				rt_log("redoarb: %s: bad arb6\n",
					input.s.s_name);
				return( 0 );
d985 3
a987 3
				rt_log("redoarb: %s: bad arb5\n",
					input.s.s_name);
				return( 0 );
d1000 11
a1010 3
			rt_log("redoarb %s: unknown arb type (%d)\n",
				input.s.s_name,input.s.s_cgtype);
			return( 0 );
d1472 8
a1479 2
		rt_log("tplane: More than %d planes for a region - ABORTING\n", NPLANES);
		return;
d1680 7
a1686 2
		rt_log("solin: Type %d Solid not known\n",*ity);
		return;
@


11.3
log
@Eliminated local setting of "rt_tol" structures.
Everything now uses the global mged_tol.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 11.2 95/01/17 13:04:54 bparker Exp Locker: mike $ (BRL)";
a52 7
#ifdef XMGED
extern point_t orig_pos;
extern double tran_x;
extern double tran_y;
extern double tran_z;
#endif

a91 6
#ifdef XMGED
	vect_t view_pos;
        point_t new_pos;
        point_t old_pos;
        point_t diff;
#endif
a132 2
#ifdef XMGED
	  MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
a133 12
	  size_reset();
	  new_mats();

	  MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
	  VSUB2(diff, new_pos, old_pos);
	  VADD2(new_pos, orig_pos, diff);
	  VSET(view_pos, new_pos[X], new_pos[Y], new_pos[Z]);
	  MAT4X3PNT( new_pos, model2view, view_pos);
	  tran_x = new_pos[X];
	  tran_y = new_pos[Y];
	  tran_z = new_pos[Z];
#else
a135 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/proc_reg.c,v 11.2 95/01/17 11:44:16 bparker Exp $ (BRL)";
d51 1
a400 1
	struct rt_tol		toler;
a472 7
		/* XXX These need to be improved */
		toler.magic = RT_TOL_MAGIC;
		toler.dist = 0.005;
		toler.dist_sq = toler.dist * toler.dist;
		toler.perp = 1e-6;
		toler.para = 1 - toler.perp;

d475 1
a475 1
		    &ttol, &toler ) < 0 )  {
a1098 1
	struct rt_tol	toler;
a1099 7
	/* XXX These need to be improved */
	toler.magic = RT_TOL_MAGIC;
	toler.dist = 0.005;
	toler.dist_sq = toler.dist * toler.dist;
	toler.perp = 1e-6;
	toler.para = 1 - toler.perp;

d1172 1
a1172 1
					    &peq[i*4], &peq[j*4], reg_min, &toler ) < 0 )
a1409 1
	struct rt_tol	toler;
d1426 2
a1427 6
	toler.magic = RT_TOL_MAGIC;
	toler.dist = 1e-6;
	toler.dist_sq = toler.dist * toler.dist;
	toler.perp = 1e-6;
	toler.para = 1 - toler.perp;
	if( rt_mk_plane_3pts( pp, p, q, r, &toler ) < 0 )  return;
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 10.9 94/12/30 01:08:53 mike Exp $ (BRL)";
d52 7
d98 6
d145 15
d162 1
@


10.9
log
@DEC Alpha
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 10.8 94/12/27 16:58:43 mike Exp Locker: mike $ (BRL)";
@


10.8
log
@Fixed bug #247, added rt_ prefix to memalloc(), etc.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 10.7 94/12/16 20:33:38 gdurf Exp Locker: mike $ (BRL)";
d89 1
a89 1
	long		stime, etime;	/* start & end times */
@


10.7
log
@Converted putchar to rt_log
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 10.6 1994/12/16 19:37:11 gdurf Exp gdurf $ (BRL)";
d503 1
a503 1
		sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
@


10.6
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 10.5 1994/11/10 12:06:12 jra Exp gdurf $ (BRL)";
d199 1
a199 1
		(void)putchar('\n');
@


10.5
log
@Irix 6.0.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/proc_reg.c,v 10.4 1994/08/27 03:18:19 mike Exp jra $ (BRL)";
d119 1
a119 1
			(void)printf("No memory left so cannot draw %s\n",
d136 1
a136 1
	(void)printf("E: %ld vectors in %ld sec\n", nvectors, etime - stime );
d196 1
a196 1
		(void)printf("nesting exceeds %d levels\n", MAX_PATH );
d198 1
a198 1
			(void)printf("/%s", cur_path[i]->d_namep );
d214 1
a214 1
			(void)printf("Edrawobj(%s):  defective database record, type='%c' (0%o) addr=x%x\n",
d238 1
a238 1
		(void)printf("Warning: combination with zero members \"%s\".\n",
d282 1
a282 1
			(void)printf("regionid %d overriden by %d\n",
d293 1
a293 1
			(void)printf(
d315 1
a315 1
			fprintf(stderr,"EdrawHobj:  %s bad member rec\n",
d394 1
a394 1
			(void)printf("Error in converting solid %s to ARBN\n",
d412 1
a412 1
			(void)printf("error in finish_region()\n");
d425 1
a425 1
			printf("EdrawHsolid(%s):  unknown database object\n",
d454 1
a454 1
			printf("%s: vector conversion failure\n",
d506 1
a506 1
			(void)printf("Edraw: out of Displaylist\n");
d582 1
a582 1
		(void)printf("proc_reg: region has more than %d members\n", NMEMB);
d659 1
a659 1
		(void)printf("proc_reg:  Cannot draw solid type %d (%s)\n",
d774 1
a774 1
		(void)printf("solid: %s  bad number of unique vectors (%d)\n",
d842 1
a842 1
				(void)printf("redoarb: %s - bad arb7\n",
d904 1
a904 1
				(void)printf("redoarb: %s: bad arb6\n",
d941 1
a941 1
				(void)printf("redoarb: %s: bad arb5\n",
d956 1
a956 1
			(void)printf("redoarb %s: unknown arb type (%d)\n",
d1433 1
a1433 1
		(void)printf("tplane: More than %d planes for a region - ABORTING\n", NPLANES);
d1635 1
a1635 1
		(void)printf("solin: Type %d Solid not known\n",*ity);
@


10.4
log
@Eliminated MIN() and MAX() from ged.h, in favor of V_MIN() and V_MAX()
from vmath.h, because some systems use the symbols MIN and MAX in
system header files.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 10.3 94/08/09 18:18:00 gdurf Exp Locker: mike $ (BRL)";
a366 1
	register struct rt_vlist *vp;
a368 1
	int count;
@


10.3
log
@Added include of conf.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 10.2 1994/06/03 17:31:53 gdurf Exp gdurf $ (BRL)";
d1224 1
a1224 1
	MIN(rego[igap],si);
d1256 1
a1256 1
	MAX(ri,so);
d1261 1
a1261 1
	MAX(ri, regi[igap]);
d1272 1
a1272 1
	MIN(ro,si);
d1277 1
a1277 1
		MIN(ro, rego[igap]);
d1310 2
a1311 2
				MAX(ri,a2);
				MIN(ro,a1);
d1314 2
a1315 2
				MAX(ri,a1);
				MIN(ro,a2);
d1340 2
a1341 2
				MAX(ri,rin);
				MIN(ro,rout);
d1460 1
a1460 1
				MAX(rin, s);
d1463 1
a1463 1
				MIN(rout,s);
d1472 1
a1472 1
	MAX(rin,0);
d1603 2
a1604 2
				MAX(reg_min[j],sol_min[j]);
				MIN(reg_max[j],sol_max[j]);
d1609 2
a1610 2
		MAX(tol,fabs(reg_min[i]));
		MAX(tol,fabs(reg_max[i]));
d1647 2
a1648 2
				MIN(sol_min[j],*sp);
				MAX(sol_max[j],*sp);
d1664 4
a1667 4
			MIN(sol_min[i],*(sp)-v1);
			MIN(sol_min[i],vt-v2);
			MAX(sol_max[i],*(sp)+v1);
			MAX(sol_max[i],vt+v2);			
d1681 4
a1684 4
			MIN(sol_min[i],vb-v1);
			MIN(sol_min[i],vt-v2);
			MAX(sol_max[i],vb+v1);
			MAX(sol_max[i],vt+v2);
@


10.2
log
@Converted f_evedit to use new command return codes.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 10.1 1991/10/12 06:44:14 mike Rel4_0 gdurf $ (BRL)";
d29 2
@


10.1
log
@Release_4.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.13 91/08/29 23:02:29 mike Exp $ (BRL)";
d80 1
a80 1
void
d137 2
@


9.13
log
@Stardent lint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.12 91/05/18 03:30:48 mike Exp $ (BRL)";
@


9.12
log
@Converted to new tolerance interface
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.11 91/02/02 00:01:50 mike Exp $ (BRL)";
d252 6
a257 3
				curmater.ma_color[0] = (rp[0].c.c_rgb[0])*rt_inv255;
				curmater.ma_color[1] = (rp[0].c.c_rgb[1])*rt_inv255;
				curmater.ma_color[2] = (rp[0].c.c_rgb[2])*rt_inv255;
@


9.11
log
@Converted to new rt_vlist structure
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.10 91/01/26 03:23:08 mike Exp $ (BRL)";
d365 2
d434 12
d448 1
a448 1
		    mged_abs_tol, mged_rel_tol, mged_nrm_tol ) < 0 )  {
d1072 1
d1074 7
d1153 1
a1153 1
					    &peq[i*4], &peq[j*4], reg_min ) < 0 )
d1391 1
d1408 6
a1413 1
	if( rt_mk_plane_3pts( pp, p, q, r, 1.0e-6 ) < 0 )  return;
@


9.10
log
@Changed calling sequences for ft_plot, rt_id_solid, etc.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.9 91/01/12 08:25:40 mike Exp $ (BRL)";
d360 1
a360 1
	register struct vlist *vp;
d364 1
a364 2
	struct vlhead	vhead;
	vect_t		maxvalue, minvalue;
d366 1
a366 1
	vhead.vh_first = vhead.vh_last = VL_NULL;
d451 3
a453 8
	VSETALL( maxvalue, -INFINITY );
	VSETALL( minvalue,  INFINITY );
	sp->s_vlist = vhead.vh_first;
	sp->s_vlen = 0;
	for( vp = vhead.vh_first; vp != VL_NULL; vp = vp->vl_forw )  {
		VMINMAX( minvalue, maxvalue, vp->vl_pnt );
		sp->s_vlen++;
	}
a455 6
	VADD2SCALE( sp->s_center, minvalue, maxvalue, 0.5 );

	sp->s_size = maxvalue[X] - minvalue[X];
	MAX( sp->s_size, maxvalue[Y] - minvalue[Y] );
	MAX( sp->s_size, maxvalue[Z] - minvalue[Z] );

d651 1
a651 1
struct vlhead	*vhead;
d1050 1
a1050 1
struct vlhead	*vhead;
d1145 2
a1146 2
						ADD_VL( vhead, pi, 0 );
						ADD_VL( vhead, po, 1 );
@


9.9
log
@externs.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.8 90/12/07 01:09:01 mike Exp $ (BRL)";
d185 1
d202 1
a202 1
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
d205 1
d209 1
a209 1
		if( rt_id_solid( rp ) == ID_NULL )  {
d223 1
a223 1
		if( EdrawHsolid( sp, flag, pathpos, old_xlate, rp, regionid, materp ) != 1 ) {
d339 1
a339 1
	rt_free( (char *)rp, "EdrawHobj recs");
d351 8
a358 8
EdrawHsolid( sp, flag, pathpos, xform, recordp, regionid, materp )
register struct solid *sp;
int		flag;
int		pathpos;
matp_t		xform;
union record	*recordp;
int		regionid;
struct mater_info *materp;
d384 1
a384 1
		i = proc_region( recordp, xform, flag );
d412 1
d417 2
a418 2
		id = rt_id_solid( recordp );
		if( id < 0 || id >= rt_nfunctab )  {
d424 11
a434 2
		if( rt_functab[id].ft_plot( recordp, xform, &vhead,
		    cur_path[pathpos],
d439 1
@


9.8
log
@lint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.7 90/12/06 20:00:30 mike Exp $ (BRL)";
a39 3

extern int	atoi();
extern long	time();
@


9.7
log
@This version works too, and is back to using the
librt/plane.c routines.  The problem was actually in
librt/plane.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.6 90/12/06 19:51:01 mike Exp $ (BRL)";
d425 2
a426 1
		    cur_path[pathpos] ) < 0 )  {
@


9.6
log
@This version also works.
@
text
@a0 1
#define	OLD	1	/* db/demo.g region BRL and BRL.p exhibit bug in new */
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.5 90/12/06 19:43:47 mike Exp $ (BRL)";
a1130 25
#if OLD
					if(fabs(VDOT(&peq[i*4],&peq[j*4]))>=.9999)
						continue; /* planes parallel */

					/* planes not parallel */
					/* compute direction vector for ray */
					VCROSS(wb,&peq[i*4],&peq[j*4]);
					VUNITIZE( wb );

					k=0;
					if(fabs(wb[1]) > fabs(wb[0])) k=1;
					if(fabs(wb[2]) > fabs(wb[k])) k=2;
					if(wb[k] < 0.0)  {
						VREVERSE( wb, wb );
					}
					{
						plane_t	c1;

						VSETALL(c1, 0);
						c1[k] = 1;
						c1[3] = reg_min[k];
						if( rt_mkpoint_3planes( xb, c1, &peq[i*4], &peq[j*4] ) < 0 )
							continue;
					}
#else
a1133 2

#endif
@


9.5
log
@This version works as well as the Release 3.7 version did.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.4 90/12/06 19:21:04 mike Exp $ (BRL)";
d1153 2
a1154 1
						cpoint(xb,c1,&peq[i*4],&peq[j*4]);
a1746 29

/* XXX begin old versions */
#if OLD
/*
 *			C P O I N T
 *
 * computes point of intersection of three planes, answer in "point".
 */
cpoint(point,c1,c2,c3)
vect_t	point;
register fastf_t *c1, *c2, *c3;
{
	static vect_t	v1, v2, v3;
	register int i;
	static fastf_t d;

	VCROSS(v1,c2,c3);
	if((d=VDOT(c1,v1))==0)  {
		printf("cpoint failure\n");
		return;
	}
	d = 1.0 / d;
	VCROSS(v2,c1,c3);
	VCROSS(v3,c1,c2);
	for(i=0; i<3; i++)
		point[i]=d*(c1[3]*v1[i]-c2[3]*v2[i]+c3[3]*v3[i]);
}

#endif
@


9.4
log
@The big-E command has been moved entirely within this module.
There seems to be some tolerance issue with this version that
prevents it from working -- that is the topic of the next revision.
@
text
@d1 1
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/proc_reg.c,v 9.3 90/04/13 00:34:32 mike Exp $ (BRL)";
d1132 24
d1160 2
d1746 29
@


9.3
log
@Made some improvements to calling sequence for big-E.
proc_reg() is now proc_region(), with finish_region().
@
text
@d7 5
a11 1
 *	proc_reg	processes each member (solid) of a region
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 9.2 89/10/13 20:42:54 mike Locked $ (BRL)";
a34 1

d36 1
d38 1
d41 16
d77 433
d548 1
d1165 1
a1165 1
	/* The finishing touches are done by drawHsolid() */
d1386 1
a1386 1
	if( rt_mk_plane_3pts( pp, p, q, r ) < 0 )  return;
@


9.2
log
@Changed to use rt_mk_plane_3pts() and the rt routine to find the
intersection line of two planes.
Changed comparvec to use VNEAR_ZERO()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 9.1 89/05/19 06:03:39 mike Rel3_5 $ (BRL)";
d65 1
a65 1
proc_reg( recordp, xform, flag, more, vhead )
d68 1
a68 2
int flag, more;
struct vlhead	*vhead;
d192 2
d195 10
a204 10
	if(more == 0) {
		/* this was the last member solid - draw the region */
		nmemb = memb_count;
		param_count = memb_count = 0;
		if(nmemb == 0) {
			nmemb = param_count = memb_count = 0;
			return(-1);	/* ERROR */
		}
		dwreg(vhead);
		return(0);	/* OK, region was drawn */
d206 2
a207 1
	return(1);		/* MORE solids follow */
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 8.2 88/12/06 02:31:23 mike Exp $ (BRL)";
d36 1
a36 1
static void	center(), cpoint(), dwreg(), ellin(), move(), points(),
d39 1
a39 1
static int	arb(), cgarbs(), comparvec(), gap(), planeeq(), redoarb(), 
d232 4
a235 1
			if(comparvec(&input.s.s_values[i*3], &input.s.s_values[j*3]) == YES) {
a518 15

static int
comparvec( x, y )
register dbfloat_t *x,*y;
{
	register int i;

	for(i=0; i<3; i++) {
		if( fabs( *x++ - *y++ ) > 0.0001 )
			return(0);   /* different */
	}
	return(1);  /* same */
}


a557 1
 *	  4. cpoint()	finds point of intersection of three planes
a565 1
 *	 13. planeeq()	finds normalized plane from 3 points
a599 1
	static fastf_t c1[3*4]={1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.};
a626 2
	for(i=0; i<3; i++)
		c1[(i*4)+3]=reg_min[i];
d674 3
a676 2
					if(fabs(VDOT(&peq[i*4],&peq[j*4]))>=.9999)
						continue; /* planes parallel */
a677 15
					/* planes not parallel */
					/* compute direction vector for ray */
					VCROSS(wb,&peq[i*4],&peq[j*4]);
					VUNITIZE( wb );

					k=0;
					if(fabs(wb[1]) > fabs(wb[0])) k=1;
					if(fabs(wb[2]) > fabs(wb[k])) k=2;
					if(wb[k] < 0.0)  {
						VREVERSE( wb, wb );
					}

					/* starting point for this ray */
					cpoint(xb,&c1[k*4],&peq[i*4],&peq[j*4]);

a881 27
/*
 *			C P O I N T
 *
 * computes point of intersection of three planes, answer in "point".
 */
static void
cpoint(point,c1,c2,c3)
vect_t	point;
register fastf_t *c1, *c2, *c3;
{
	static vect_t	v1, v2, v3;
	register int i;
	static fastf_t d;

	VCROSS(v1,c2,c3);
	if((d=VDOT(c1,v1))==0)  {
		printf("cpoint failure\n");
		return;
	}
	d = 1.0 / d;
	VCROSS(v2,c1,c3);
	VCROSS(v3,c1,c2);
	for(i=0; i<3; i++)
		point[i]=d*(c1[3]*v1[i]-c2[3]*v2[i]+c3[3]*v3[i]);
}


d929 1
a929 1
	if(planeeq( pp, p,q,r)==0) return;
a947 24
}

/*
 *			P L A N E E Q
 *
 * computes normalized plane eq from three points.
 *  Returns 0 if plane is degenerate, 1 if plane is good.
 */
static int
planeeq(eqn,p1,p2,p3)
fastf_t *eqn;
fastf_t *p1, *p2, *p3;
{
	static fastf_t vecl;
	static vect_t	va, vb, vc;

	VSUB2( va, p2, p1 );
	VSUB2( vb, p3, p1 );
	VCROSS(vc,va,vb);
	vecl = MAGNITUDE( vc );
	if(vecl<.0001) return(0);
	VSCALE(eqn, vc, 1.0/vecl);
	eqn[3] = VDOT(eqn, p1);
	return(1);
@


8.2
log
@raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/proc_reg.c,v 1.2 88/10/23 13:56:49 mike Exp $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 7.3 88/02/25 06:09:10 mike Exp $ (BRL)";
d32 1
@


7.3
log
@Modified for new vector lists
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 7.2 87/11/05 05:06:39 mike Locked $ (BRL)";
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 7.1 87/11/03 00:01:42 mike Rel $ (BRL)";
d26 1
d31 1
d64 1
a64 1
proc_reg( recordp, xform, flag, more )
d68 1
d201 1
a201 1
		dwreg();
d606 2
a607 1
dwreg()
d719 2
a720 2
						DM_GOTO( pi, PEN_UP);
						DM_GOTO( po, PEN_DOWN);
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 6.1 87/07/11 08:04:59 mike Rel $ (BRL)";
d27 1
a27 1
#include "./machine.h"	/* special copy */
d48 1
a48 1
static float	m_param[NMEMB*24];	/* member parameters */
d68 1
a68 1
	register float *op;	/* Used for scanning vectors */
d489 1
a489 1
	static float copy[24];
d515 1
a515 1
register float *x,*y;
d584 12
a595 12
static float	peq[NPLANES*4];		/* plane equations for EACH region */
static float	solrpp[NMEMB*6];	/* enclosing RPPs for each member of the region */
static float	regi[NMEMB], rego[NMEMB];	/* distances along ray where ray enters and leaves the region */
static float	pcenter[3];		/* center (interior) point of a solid */
static float	reg_min[3], reg_max[3];		/* min,max's for the region */
static float	sol_min[3], sol_max[3];		/* min,max's for a solid */
static float	xb[3];			/* starting point of ray */
static float	wb[3];			/* direction cosines of ray */
static float	rin, rout;		/* location where ray enters and leaves a solid */
static float	ri, ro;			/* location where ray enters and leaves a region */
static float	tol;			/* tolerance */
static float	*sp, *savesp;		/* pointers to the solid parameter array m_param[] */
d598 1
a598 1
static float	pinf = 1000000.0;
d609 1
a609 1
	static float c1[3*4]={1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.};
d711 2
a712 1
						static float pi[3],po[3];
d741 1
a741 1
float si,so;
d833 2
a834 2
	static float s1[3],s2[3];
	static float a1, a2;
d915 2
a916 2
float *point;
register float *c1, *c2, *c3;
d918 1
a918 1
	static float v1[4], v2[4], v3[4];
d920 1
a920 1
	static float d;
d939 1
a939 1
	register float ppc;
d949 1
a949 1
		pcenter[i]=ppc/(float)m_type[id];
d962 1
a962 1
float *p, *q, *r, *s;
d964 1
a964 1
	register float *pp,*pf;
d970 1
a970 1
		FAST float t;
d1011 2
a1012 2
float *eqn;
float *p1, *p2, *p3;
d1014 2
a1015 2
	static float vecl;
	static float va[3],vb[3],vc[3];
d1031 1
a1031 1
	static float s,*pp,dxbdn,wbdn,te;
d1068 2
a1069 2
	static float vt[3], p[3], q[3], r[3], t[3];
	static float s,sa,c,ca,sd=.38268343,cd=.92387953;
d1123 3
a1125 3
	static float p[3], q[3], r[3], t[3];
	static float s1,s2,sa,c1,c2,ca,sd=.5,cd=.8660254,sgn;
	static float se, ce;
d1218 1
a1218 1
	static float a,b,c,d,v1,v2,vt,vb;
d1288 1
a1288 1
	static float tt;
d1290 1
a1290 1
	static float *pp,*p1,*p2,*p3,*p4;
@


6.1
log
@Release 2.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 5.1 87/06/24 22:21:54 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 4.2 87/02/13 00:12:51 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 4.1 86/12/29 03:22:43 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.5.1.1 86/08/14 22:45:03 mike Exp $ (BRL)";
@


2.13
log
@Changed #includes for CC -I../h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.4 85/08/07 05:19:36 mike Exp $ (BRL)";
d33 1
a33 1
static void	center(), cpoint(), dwreg(), ellin(), move(), neg(), points(),
a565 1
 *	  3. neg()	vector A = - vector B
d587 3
a589 3
static float	pc[3];			/* center (interior) point of a solid */
static float	rmn[3], rmx[3];		/* min,max's for the region */
static float	smn[3], smx[3];		/* min,max's for a solid */
a594 3
static int	lmemb, umemb;		/* lower and upper limit of members of a region
					 * from one OR to the next OR
					 */
d597 1
a597 1
static int	la, lb, lc, id, jd, nint, ngaps;
a608 2
	static float pi[3],po[3];
	static float lenwb;
d610 2
d621 1
a621 1
		regin(1);
a628 2
printf("nmemb=%d\n", nmemb);
printf("all m_op: '%s'\n", m_op);
a633 1
printf("doing range %d..%d\n", lmemb, umemb);
d635 1
a635 1
	regin(0);
d637 3
a640 5
	for(i=0; i<3; i++) c1[(i*4)+3]=rmn[i];
	l=0;
printf("mlc[] = ");
for(id=lmemb;id<umemb;id++) printf("%d ", mlc[id]);
printf("\n");
a642 1
printf("SOLID %d, mlc[] = %d, l=%d\n", id, mlc[id], l);
a651 1
printf("Starting solid %d/plane %d..%d\n", id, i, itemp);
a660 3
printf("%c %d/%d, %c %d/%d\n",
m_op[id], id, i,
m_op[jd], jd, j );
d686 2
a687 2
					if(fabs(VDOT(&peq[i*4],&peq[j*4]))<.9999){
						/* planes not parallel */
d689 4
a692 4
						/* compute vector for ray */
						VCROSS(wb,&peq[i*4],&peq[j*4]);
						lenwb = MAGNITUDE( wb );
						VSCALE(wb, wb, 1.0/lenwb);
d694 6
a699 8
						/* starting point for this ray */
						k=0;
						if(fabs(wb[1]) > fabs(wb[0])) k=1;
						if(fabs(wb[2]) > fabs(wb[k])) k=2;
						if(wb[k] < 0.0)
							neg( wb, wb, 3 );
printf("cpoint %g,%g,%g k=%d i=%d j=%d\n", xb[0], xb[1], xb[2], k, i, j);
						cpoint(&c1[k*4],&peq[i*4],&peq[j*4]);
d701 15
a715 13
						/* check if ray intersects region */
						if(region()>0){
							/* ray intersects region */
							/* plot this ray  including gaps */
							for(n=0; n<nint; n++){
								for(k=0; k<3; k++){
									 pi[k]=xb[k]+wb[k]*regi[n];
									 po[k]=xb[k]+wb[k]*rego[n];
								}
								DM_GOTO(&pi[0], PEN_UP);
								DM_GOTO(&po[0], PEN_DOWN);
							}
						}
d825 2
a826 2
 *   	returns 1  if intersection
 *	        0  if no intersection
a827 1

d829 1
a829 1
region()
a833 1
	static float dum1, dum2;
a834 1
	nint=0;
d840 2
a841 4
	for(i=0;i<3;i++){
		s1[i]=rmn[i]-xb[i];
		s2[i]=rmx[i]-xb[i];
	}
d852 1
a852 2
			}
			else {
d858 1
a858 2
		}
		else {
d872 1
a872 1
			goto nullsolid;
d882 2
a883 5
			}
			else{
				dum1 = -1.0 * pinf;
				dum2 = rin;
				if(gap(dum1, dum2) <= 0)
d885 1
a885 3
				dum1 = rout;
				dum2 = pinf;
				if(gap(dum1, dum2) <= 0)
d892 1
a892 3
				dum1 = rin;
				dum2 = rout;
				if(gap(dum1, dum2) <= 0)
a897 2
nullsolid:
		;
a900 1
	nint=ngaps+1;
d902 2
a903 2
	rego[nint-1]=ro;
	return(1);
d907 5
d913 2
a914 14
neg(a,b,n)
register float *a, *b;
int n;
{
	register int i;

	for(i=0; i<n; i++)
		*(b+i) = -1.0 * (*(a+i));
}


/* computes point of intersection of three planes */
static void
cpoint(c1,c2,c3)
d922 4
a925 1
	if((d=VDOT(c1,v1))==0) return;
d930 1
a930 1
		xb[i]=d*(*(c1+3)*v1[i]-(*(c2+3))*v2[i]+(*(c3+3))*v3[i]);
d948 1
a948 1
		pc[i]=ppc/(float)m_type[id];
d953 6
a958 1
/* test if plane inside enclosing rpp */
d961 1
a961 1
register float *p, *q, *r, *s;
d963 1
a963 2
	static float t;
	static float *pp,*pf;
d966 2
a967 1
	pp = &peq[lc*4];
d969 2
a970 1
		t=rmn[i]-tol;
d973 1
a973 1
		t=rmx[i]+tol;
d978 4
a981 2
	/* Does plane already exist? */
	if(planeeq(p,q,r)==0) return;
d983 6
a988 1
	if((*(pp+3)-VDOT(pp,pc)) > 0.) neg(pp,pp,4);
d995 1
a995 1
	if(++lc > NPLANES) {
a996 1
		lc--;
d999 1
d1002 24
d1075 1
a1075 1
		pc[i]=( *(sp+i) + vt[i])*.5;
d1128 1
a1128 1
	for(i=0;i<3;i++) pc[i] = *(sp+i);
d1174 1
a1174 1
regin(flag)
d1179 2
a1180 2
	tol=rmn[0]=rmn[1]=rmn[2] = -pinf;
	rmx[0]=rmx[1]=rmx[2]=pinf;
d1188 2
a1189 2
				MAX(rmn[j],smn[j]);
				MIN(rmx[j],smx[j]);
d1194 2
a1195 2
		MAX(tol,fabs(rmn[i]));
		MAX(tol,fabs(rmx[i]));
d1202 1
a1202 1
		solpl();
d1225 2
a1226 2
	smn[0]=smn[1]=smn[2]=pinf;
	smx[0]=smx[1]=smx[2] = -pinf;
d1232 2
a1233 2
				MIN(smn[j],*sp);
				MAX(smx[j],*sp);
d1249 4
a1252 4
			MIN(smn[i],*(sp)-v1);
			MIN(smn[i],vt-v2);
			MAX(smx[i],*(sp)+v1);
			MAX(smx[i],vt+v2);			
d1266 4
a1269 4
			MIN(smn[i],vb-v1);
			MIN(smn[i],vt-v2);
			MAX(smx[i],vb+v1);
			MAX(smx[i],vt+v2);
d1276 2
a1277 2
		solrpp[num*6+i] = smn[i];
		solrpp[num*6+i+3] = smx[i];
d1283 1
d1285 1
a1285 1
solpl()
a1337 61


/* computes normalized plane eq from three points */
static int
planeeq(p1,p2,p3)
float *p1, *p2, *p3;
{
	static float vecl;
	static float va[3],vb[3],vc[3];
	register int i;

	for(i=0;i<3;i++){
		va[i] = *(p2+i) - *(p1+i);
		vb[i] = *(p3+i) - *(p1+i);
	}
	VCROSS(vc,va,vb);
	vecl = MAGNITUDE( vc );
	if(vecl<.0001) return(0);
	VSCALE(&peq[lc*4], vc, 1.0/vecl);
	peq[(lc*4)+3] = VDOT(&peq[lc*4], p1);
	return(1);
}



/* TYPE_ARB()	returns specific ARB type of record rec.  The record rec
 *		is also rearranged to "standard" form.
 */
#ifdef never
type_arb( rec )
union record *rec;
{
	int i;
	static int uvec[8], svec[11];

	if( rec->s.s_type != GENARB8 )
		return( 0 );

	input = *rec;		/* copy */

	/* convert input record to points */
	points();

	if( (i = cgarbs(uvec, svec)) == 0 )
		return(0);

	if( redoarb(uvec, svec, i) == 0 )
		return( 0 );

	/* convert to vectors in the rec record */
	VMOVE(&rec->s.s_values[0], &input.s.s_values[0]);
	for(i=3; i<=21; i+=3) {
		VSUB2(&rec->s.s_values[i], &input.s.s_values[i], &input.s.s_values[0]);
	}

	return( input.s.s_cgtype );

}
#endif


@


2.12
log
@Additional cleanups and minor performance enhancements.
@
text
@a11 1
 *	Michael John Muuss
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.12 86/07/17 02:05:08 mike Exp $ (BRL)";
d26 1
a26 1
#include	<math.h>
d28 4
a31 4
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "dm.h"
d33 5
a37 2
HIDDEN void	cpoint(), dwreg(), ell_arbn(), tgc_arbn(), tplane();
HIDDEN int	arbn_shot(), cgarbs(), gap(), region();
d39 1
a51 20
static float	reg_min[3], reg_max[3];		/* min,max's for the region */
static float	pinf = 1000000.0;
static float	*sp;			/* pointers to the solid parameter array m_param[] */

#define NPLANES	500
static float	peq[NPLANES*4];		/* plane equations for EACH region */
static float	solrpp[NMEMB*6];	/* enclosing RPPs for each member of the region */
static float	regi[NMEMB], rego[NMEMB];	/* distances along ray where ray enters and leaves the region */
static float	pcenter[3];		/* center (interior) point of a solid */
static float	r_pt[3];			/* starting point of ray */
static float	r_dir[3];			/* direction cosines of ray */
static float	rin, rout;		/* location where ray enters and leaves a solid */
static float	ri, ro;			/* location where ray enters and leaves a region */
static float	tol;			/* tolerance */
static int	mlc[NMEMB];		/* location of last plane for each member */
static int	la, lb, lc, id, jd, ngaps;
static int	negpos;
static char	oper;


d53 1
a53 1
 *			P R O C _ R E G
a54 1
 * This routine processes each member(solid) of a region.
d71 1
a72 4
	static int j;
	static float	sol_min[3], sol_max[3];
	static float a,b,c,d,v1,v2,vt,vb;
	static union record input;	/* Holds an object file record */
d79 17
d104 2
a105 2
	m_type[memb_count] = cgtype;
	if(memb_count >= NMEMB) {
a109 6
	if( memb_count == 0 )  {
		/* First part of this region, initialize */
		reg_min[0]=reg_min[1]=reg_min[2] = -pinf;
		reg_max[0]=reg_max[1]=reg_max[2]=pinf;
		sp = &m_param[0];	/* XXX */
	}
a110 4
	/* Find enclosing RPP for the solid */
	sol_min[0]=sol_min[1]=sol_min[2]=pinf;
	sol_max[0]=sol_max[1]=sol_max[2] = -pinf;

d113 3
a115 1
	case GENARB8:
d121 1
a121 1
		for( i=1; i<8; i++ )  {
d123 2
a124 1
			VADD2(&m_param[param_count], input.s.s_values, work);
a127 7
		for(i=0;i<8;i++){
			for(j=0;j<3;j++){
				MIN(sol_min[j],*sp);
				MAX(sol_max[j],*sp);
				sp++;
			}
		}
d130 18
d151 2
a152 1
		VMOVE(&m_param[param_count], work);
d158 2
a159 1
			VMOVE(&m_param[param_count], work);
a162 14
		for(i=0;i<3;i++,sp++){
			vt = *sp + *(sp+3);
			a = *(sp+6);
			b = *(sp+9);
			c = *(sp+12);
			d = *(sp+15);
			v1=sqrt(a*a+b*b);
			v2=sqrt(c*c+d*d);
			MIN(sol_min[i],*(sp)-v1);
			MIN(sol_min[i],vt-v2);
			MAX(sol_max[i],*(sp)+v1);
			MAX(sol_max[i],vt+v2);			
		}
		sp+=15;
d175 2
a176 1
			VMOVE(&m_param[param_count], work);
a179 13
		for(i=0;i<3;i++,sp++){
			vb = *sp - *(sp+3);
			vt = *sp + *(sp+3);
			a = *(sp+6);
			b = *(sp+9);
			v1=sqrt(a*a+b*b);
			v2=sqrt(c*c+d*d);
			MIN(sol_min[i],vb-v1);
			MIN(sol_min[i],vt-v2);
			MAX(sol_max[i],vb+v1);
			MAX(sol_max[i],vt+v2);
		}
		sp+=9;
d190 10
a199 4
	/* save min,maxs for this solid */
	for(i=0; i<3; i++) {
		solrpp[memb_count*6+i] = sol_min[i];
		solrpp[memb_count*6+i+3] = sol_max[i];
d201 2
d204 29
a232 4
	if(m_op[memb_count] != '-') {
		for(i=0;i<3;i++){
			MAX(reg_min[i],sol_min[i]);
			MIN(reg_max[i],sol_max[i]);
d234 12
d247 21
a267 1
	memb_count++;
d269 2
a270 2
	if(more)
		return(1);		/* MORE solids follow */
d272 23
a294 6
	/* this was the last member solid - draw the region */
	nmemb = memb_count;
	param_count = memb_count = 0;
	if(nmemb == 0) {
		nmemb = param_count = memb_count = 0;
		return(-1);	/* ERROR */
d296 1
a296 2
	dwreg();
	return(0);	/* OK, region was drawn */
d299 9
d309 243
d566 1
d568 1
d570 11
a580 3
 *	  7. arbn_shot()	finds intersection of ray with an arb
 *	  8. tgc_arbn()	converts tgc to arbn
 *	  9. ell_arbn()	converts ellg to arbn
d582 25
a606 1
HIDDEN void
d613 3
a615 10
	static float c1[3*4]={
		1.,0.,0.,0.,
		0.,1.,0.,0.,
		0.,0.,1.,0.};
	static int lmemb, umemb;/* lower and upper limit of members of region
				 * from one OR to the next OR */
	static float *savesp;
	static float tt;
	static int ls;
	static float *pp;
d617 14
d633 2
d640 1
d642 1
a642 2
	tol = -pinf;
	sp = savesp;
a643 5
	for(i=0;i<3;i++){
		MAX(tol,fabs(reg_min[i]));
		MAX(tol,fabs(reg_max[i]));
	}
	tol=tol*0.00001;
d645 1
a645 56
	/* convert all solids to ARBNs */
	sp = savesp;
	lc=0;
	tt=tol*10.;
	for(id=lmemb;id<umemb;id++){
		ls=lc;
		switch( m_type[id] )  {
		case GENARB8:
			for(i=0;i<3;i++){
				register float ppc;
				register int k;
				k=i;
				ppc=0.0;
				for(j=0; j<8; j++) {
					ppc += *(sp+k);
					k+=3;
				}
				pcenter[i]=ppc/8.;
			}
#define P(x)	(sp+3*x)
			tplane( P(0),P(1),P(2),P(3) );
			tplane( P(4),P(5),P(6),P(7) );
			tplane( P(0),P(4),P(7),P(3) );
			tplane( P(1),P(2),P(6),P(5) );
			tplane( P(0),P(1),P(5),P(4) );
			tplane( P(3),P(2),P(6),P(7) );
#undef P
			sp += 8*3;
			break;
		case GENTGC:
			tgc_arbn();
			sp+=18;
			break;
		case GENELL:
			ell_arbn();
			sp+=12;
			break;
		}

		if(m_op[id]=='-'){
			pp = &peq[4*ls]+3;
			while(ls++ < lc) {
				*pp-=tt;
				pp+=4;
			}
		}

		mlc[id]=lc-1;
	}

	/* save the parameter pointer in case region has ORs */
	savesp = sp;

	/* Make 3 basic plane eqns of min bounds */
	for(i=0; i<3; i++)
		c1[(i*4)+3]=reg_min[i];
d647 4
a650 2

	/* process all members until the next OR */
d652 1
d662 1
d672 3
d700 2
a701 2
					if(fabs(VDOT(&peq[i*4],&peq[j*4]))>=.9999)
						continue; /* planes parallel */
d703 4
a706 5
					/* planes not parallel */
					/* compute direction vector for ray
					 * perpendicular to both plane normals */
					VCROSS(r_dir,&peq[i*4],&peq[j*4]);
					VUNITIZE( r_dir );
d708 8
a715 6
					k=0;
					if(fabs(r_dir[1]) > fabs(r_dir[0])) k=1;
					if(fabs(r_dir[2]) > fabs(r_dir[k])) k=2;
					if(r_dir[k] < 0.0)  {
						VREVERSE( r_dir, r_dir );
					}
d717 13
a729 18
					/* starting point for this ray:
					 * intersection of two planes (line),
					 * and closest min RPP bound plane.
					 */
					cpoint(r_pt,&c1[k*4],&peq[i*4],&peq[j*4]);

					/* check if ray intersects region */
					if( (k=region(lmemb,umemb))<=0)
						continue;

					/* ray intersects region */
					/* plot this ray  including gaps */
					for(n=0; n<k; n++){
						static float pi[3],po[3];
						VJOIN1( pi, r_pt, regi[n], r_dir );
						VJOIN1( po, r_pt, rego[n], r_dir );
						DM_GOTO( pi, PEN_UP);
						DM_GOTO( po, PEN_DOWN);
d747 1
d752 1
a752 1
HIDDEN int
d839 2
a840 2
 *   	returns ngaps+1	if intersection
 *	        0	if no intersection
d842 3
a844 2
HIDDEN int
region(lmemb,umemb)
d847 3
a849 2
	static double s1[3],s2[3];
	static double a1, a2;
d851 1
d857 4
a860 2
	VSUB2( s1, reg_min, r_pt );
	VSUB2( s2, reg_max, r_pt );
d864 4
a867 4
		if(fabs(r_dir[i])>.001){
			a1=s1[i]/r_dir[i];
			a2=s2[i]/r_dir[i];
			if(r_dir[i] <= 0.){
d871 2
a872 1
			} else {
d878 2
a879 1
		} else {
d885 1
a885 1
	/* ray intersects region - find intersection with each arbn solid */
d893 1
a893 1
			continue;
d898 1
a898 1
			if( arbn_shot() == 0 )
d903 5
a907 2
			} else{
				if(gap(-pinf, rin) <= 0)
d909 3
a911 1
				if(gap(rout, pinf) <= 0)
d917 4
a920 2
			if(arbn_shot() != 0) {
				if(gap(rin, rout) <= 0)
d926 2
d931 1
d933 2
a934 2
	rego[ngaps]=ro;
	return(ngaps+1);
d937 5
a941 8
/*
 *			A R B N _ S H O T
 *
 *  finds intersection of ray with an arbitrary convex polyhedron
 *  defined by enclosing half-spaces.
 */
HIDDEN int
arbn_shot()
d943 1
a943 3
	register float *pp;
	static float *pend;
	static double dxbdn,wbdn,te;
d945 3
a947 2
	rin = ri;
	rout = ro;
a948 3
	te = tol;
	if(oper == '-' && negpos)
		te = -tol;
d950 3
a952 30
	pend = &peq[lb*4];
	for(pp = &peq[la*4]; pp <= pend; pp+=4){
		dxbdn = pp[3]-VDOT(r_pt,pp);
		wbdn=VDOT(r_dir,pp);
		if( wbdn < -0.001 || wbdn > 0.001 )  {
			static double s;

			s=dxbdn/wbdn;
			if(wbdn > 0.0) {
				MAX(rin, s);
			} else {
				MIN(rout,s);
			}
		} else {
			if(dxbdn>te) return(0);
		}
		if((rin+tol)>=rout || rout<=tol) return(0);
	}
	MAX(rin,0);	/* ray may start inside */
	return(1);
}

/*
 *			C P O I N T
 *
 * computes point of intersection of three planes, answer in "point".
 */
HIDDEN void
cpoint(point,c1,c2,c3)
float *point;
d955 1
a955 1
	static double v1[4], v2[4], v3[4];
d957 1
a957 1
	static double d;
d960 1
a960 4
	if((d=VDOT(c1,v1))==0)  {
		printf("cpoint failure\n");
		return;
	}
d965 1
a965 1
		point[i]=d*(c1[3]*v1[i]-c2[3]*v2[i]+c3[3]*v3[i]);
d968 22
a989 8
static int arb_npts;
/*
 *			T P L A N E
 *
 *  Register a plane which contains the 4 specified points,
 *  unless they are degenerate, or lie outside the region RPP.
 */
HIDDEN void
d991 1
a991 1
float *p, *q, *r, *s;
d993 2
a994 1
	register float *pp,*pf;
d997 1
a997 2
	/* If all 4 pts have coord outside region RPP,
	 * discard this plane, as the polygon is definitely outside */
d999 1
a999 2
		FAST float t;
		t=reg_min[i]-tol;
d1002 1
a1002 1
		t=reg_max[i]+tol;
d1007 2
a1008 9
	/* Do these three points form a valid plane? */
	/* WARNING!!  Fourth point is never even looked at!! */
	pp = &peq[lc*4];
	arb_npts = 0;
	planept( pp, p );
	planept( pp, q );
	planept( pp, r );
	planept( pp, s );
	if( arb_npts < 3 )  return;	/* invalid as plane */
d1010 1
a1010 1
	/* See if this plane already exists in list */
d1017 1
a1017 1
	if(lc >= NPLANES) {
d1019 1
a1021 1
	lc++;		/* Save plane eqn */
d1024 3
a1026 3
#define NEAR_ZERO(val,epsilon)	( ((val) > -epsilon) && ((val) < epsilon) )
planept( eqn, point )
float *eqn, *point;
d1028 1
a1028 8
	register int i;
	static float arb_points[4*3];
	static float arb_Xbasis[3];
	static float P_A[3];
	static double f;
	static float work[3];
#define arb_A	arb_points		/* first saved point is A */
#define arb_N	eqn			/* first 3 # of plane eqn */
d1030 2
a1031 8
	/* Verify that this point is not the same as an earlier point */
	for( i=0; i < arb_npts; i++ )  {
		VSUB2( work, point, &arb_points[i*3] );
		if( MAGSQ( work ) < 0.005 )
			return(0);			/* BAD */
	}
	i = arb_npts++;		/* Current point number */
	VMOVE( &arb_points[i*3], point );
d1033 3
a1035 17
	/* The first 3 points are treated differently */
	switch( i )  {
	case 0:
		return(1);				/* OK */
	case 1:
		VSUB2( arb_Xbasis, point, arb_A );	/* B-A */
		return(1);				/* OK */
	case 2:
		VSUB2( P_A, point, arb_A );	/* C-A */
		/* Check for co-linear, ie, (B-A)x(C-A) == 0 */
		VCROSS( arb_N, arb_Xbasis, P_A );
		f = MAGNITUDE( arb_N );
		if( NEAR_ZERO(f,0.005) )  {
			arb_npts--;
			return(0);			/* BAD */
		}
		VUNITIZE( arb_N );
d1037 11
a1047 9
		/*
		 *  If C-A is clockwise from B-A, then the normal
		 *  points inwards, so we need to fix it here.
		 *  WARNING:  Here, INWARD normals is correct, for now.
		 */
		VSUB2( work, arb_A, pcenter );
		f = VDOT( work, arb_N );
		if( f > 0.0 )  {
			VREVERSE(arb_N, arb_N);	/* "fix" normal */
d1049 2
a1050 12
		eqn[3] = VDOT( arb_N, arb_A );
		return(1);				/* OK */
	default:
		/* Merely validate 4th and subsequent points */
		VSUB2( P_A, point, arb_A );
		VUNITIZE( P_A );		/* Checking direction only */
		f = VDOT( arb_N, P_A );
		if( ! NEAR_ZERO(f,0.005) )  {
			/* Non-planar face */
			printf("arb: face non-planar, dot=%f\n", f );
			arb_npts--;
			return(0);				/* BAD */
d1052 1
a1052 1
		return(1);			/* OK */
d1054 3
d1059 2
d1062 2
a1063 2
HIDDEN void
tgc_arbn()
d1073 1
a1073 1
		pcenter[i]=( *(sp+i) + vt[i])*.5;
d1117 2
a1118 2
HIDDEN void
ell_arbn()
d1126 1
a1126 1
	for(i=0;i<3;i++) pcenter[i] = *(sp+i);
d1168 228
@


2.11
log
@More improvements
@
text
@d12 1
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.10 86/07/16 23:23:04 mike Exp $ (BRL)";
d34 2
a35 3
static void	cpoint(), dwreg(), ellin(),
		solin(), solpl(), tgcin(), tplane();
static int	arbn_shot(), cgarbs(), gap(), region();
a36 1
static union record input;		/* Holds an object file record */
d58 2
a59 2
static float	xb[3];			/* starting point of ray */
static float	wb[3];			/* direction cosines of ray */
a88 1
	static int uvec[8], svec[11];
d93 1
a127 2
		length = 8;
		/* common area for arbs */
d133 1
a133 1
		for( i=1; i<length; i++ )  {
d135 1
a135 2
			VADD2(op, input.s.s_values, work);
			VMOVE(&m_param[param_count], op);
d151 1
a151 2
		VMOVE( op, work );
		VMOVE(&m_param[param_count], op);
d157 1
a157 2
			VMOVE( op, work );
			VMOVE(&m_param[param_count], op);
d187 1
a187 2
			VMOVE( op, work );
			VMOVE(&m_param[param_count], op);
d260 2
a261 4
 *	  8. tgcin()	converts tgc to arbn
 *	  9. ellin()	converts ellg to arbn
 *	 12. solpl()	process solids to arbn's
 *
d263 1
a263 1
static void
d277 3
d298 1
a298 1
	/* find planes for each solid */
d300 48
a347 1
	solpl(lmemb,umemb);
d356 1
a356 1
	/* id loop processes all member to the next OR */
d407 2
a408 2
					VCROSS(wb,&peq[i*4],&peq[j*4]);
					VUNITIZE( wb );
d411 4
a414 4
					if(fabs(wb[1]) > fabs(wb[0])) k=1;
					if(fabs(wb[2]) > fabs(wb[k])) k=2;
					if(wb[k] < 0.0)  {
						VREVERSE( wb, wb );
d421 1
a421 1
					cpoint(xb,&c1[k*4],&peq[i*4],&peq[j*4]);
d431 2
a432 2
						VJOIN1( pi, xb, regi[n], wb );
						VJOIN1( po, xb, rego[n], wb );
a451 1
	/* The finishing touches are done by drawHsolid() */
d456 1
a456 1
static int
d546 1
a546 1
static int
d550 2
a551 2
	static float s1[3],s2[3];
	static float a1, a2;
d558 2
a559 2
	VSUB2( s1, reg_min, xb );
	VSUB2( s2, reg_max, xb );
d563 4
a566 4
		if(fabs(wb[i])>.001){
			a1=s1[i]/wb[i];
			a2=s2[i]/wb[i];
			if(wb[i] <= 0.){
d630 1
a630 1
static int
d635 1
a635 1
	static float dxbdn,wbdn,te;
d646 2
a647 2
		dxbdn = pp[3]-VDOT(xb,pp);
		wbdn=VDOT(wb,pp);
d649 1
a649 1
			register float s;
d671 1
a671 1
static void
d676 1
a676 1
	static float v1[4], v2[4], v3[4];
d678 1
a678 1
	static float d;
d699 1
a699 1
static void
d810 2
a811 2
static void
tgcin()
d865 2
a866 2
static void
ellin()
a913 68
	}
}

/* converts all solids to ARBNs */
static void
solpl(lmemb,umemb)
{
	static float tt;
	static int ls;
	static float *pp,*p1,*p2,*p3,*p4;
	register int i,j;
	static int nfc[5]={4,5,5,6,6};
	static int iv[5*24]={
		 0,1,2,0, 3,0,1,0, 3,1,2,1, 3,2,0,0, 0,0,0,0, 0,0,0,0,
		 0,1,2,3, 4,0,1,0, 4,1,2,1, 4,2,3,2, 4,3,0,0, 0,0,0,0,
		 0,1,2,3, 1,2,5,4, 0,4,5,3, 4,0,1,0, 5,2,3,2, 0,0,0,0,
		 0,1,2,3, 4,5,6,4, 0,3,4,0, 1,2,6,5, 0,1,5,4, 3,2,6,4,
		 0,1,2,3, 4,5,6,7, 0,4,7,3, 1,2,6,5, 0,1,5,4, 3,2,6,7};

	lc=0;
	tt=tol*10.;
	for(id=lmemb;id<umemb;id++){
		ls=lc;
		switch( m_type[id] )  {
		case GENARB8:
			{
				register float ppc;
				register int i,j,k;

				for(i=0;i<3;i++){
					k=i;
					ppc=0.0;
					for(j=0; j<8; j++) {
						ppc += *(sp+k);
						k+=3;
					}
					pcenter[i]=ppc/8.;
				}
			}
			j=4*24;
			for(i=0;i<nfc[4];i++){
				p1=sp+iv[j++]*3;
				p2=sp+iv[j++]*3;
				p3=sp+iv[j++]*3;
				p4=sp+iv[j++]*3;
				tplane(p1,p2,p3,p4);
			}
			sp += 8*3;
			break;
		case GENTGC:
			tgcin();
			sp+=18;
			break;
		case GENELL:
			ellin();
			sp+=12;
			break;
		}

		if(m_op[id]=='-'){
			pp = &peq[4*ls]+3;
			while(ls++ < lc) {
				*pp-=tt;
				pp+=4;
			}
		}

		mlc[id]=lc-1;
@


2.10
log
@More refinement.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.9 86/07/16 22:43:04 mike Exp $ (BRL)";
a50 1
static float	sol_min[3], sol_max[3];		/* min,max's for a solid */
d54 16
d92 3
d122 4
d143 7
d167 14
d198 13
d221 6
a226 2
	/* Find min and max */
	solin(memb_count);
a268 1
 *	 11. solin()	finds enclosing rpp for solids
a270 3
 *		R E V I S I O N   H I S T O R Y
 *
 *	11/02/83  CMK	Modified to use g3.c module (device independence).
a271 16

#define NPLANES	500
static float	peq[NPLANES*4];		/* plane equations for EACH region */
static float	solrpp[NMEMB*6];	/* enclosing RPPs for each member of the region */
static float	regi[NMEMB], rego[NMEMB];	/* distances along ray where ray enters and leaves the region */
static float	pcenter[3];		/* center (interior) point of a solid */
static float	xb[3];			/* starting point of ray */
static float	wb[3];			/* direction cosines of ray */
static float	rin, rout;		/* location where ray enters and leaves a solid */
static float	ri, ro;			/* location where ray enters and leaves a region */
static float	tol;			/* tolerance */
static int	mlc[NMEMB];		/* location of last plane for each member */
static int	la, lb, lc, id, jd, ngaps;
static int	negpos;
static char	oper;

a875 67

/* finds enclosing RPP for a solid using the solid's parameters */
static void
solin(num)
int num;
{
	register int i,j;
	static float a,b,c,d,v1,v2,vt,vb;

	sol_min[0]=sol_min[1]=sol_min[2]=pinf;
	sol_max[0]=sol_max[1]=sol_max[2] = -pinf;

	switch( m_type[num] )  {
	case GENARB8:
		for(i=0;i<8;i++){
			for(j=0;j<3;j++){
				MIN(sol_min[j],*sp);
				MAX(sol_max[j],*sp);
				sp++;
			}
		}
		break;

	case GENTGC:
		for(i=0;i<3;i++,sp++){
			vt = *sp + *(sp+3);
			a = *(sp+6);
			b = *(sp+9);
			c = *(sp+12);
			d = *(sp+15);
			v1=sqrt(a*a+b*b);
			v2=sqrt(c*c+d*d);
			MIN(sol_min[i],*(sp)-v1);
			MIN(sol_min[i],vt-v2);
			MAX(sol_max[i],*(sp)+v1);
			MAX(sol_max[i],vt+v2);			
		}
		sp+=15;
		break;

	case GENELL:
		for(i=0;i<3;i++,sp++){
			vb = *sp - *(sp+3);
			vt = *sp + *(sp+3);
			a = *(sp+6);
			b = *(sp+9);
			v1=sqrt(a*a+b*b);
			v2=sqrt(c*c+d*d);
			MIN(sol_min[i],vb-v1);
			MIN(sol_min[i],vt-v2);
			MAX(sol_max[i],vb+v1);
			MAX(sol_max[i],vt+v2);
		}
		sp+=9;
		break;

	default:
		printf("solin:  unknown type\n");
	}

	/* save min,maxs for this solid */
	for(i=0; i<3; i++) {
		solrpp[num*6+i] = sol_min[i];
		solrpp[num*6+i+3] = sol_max[i];
	}
}

@


2.9
log
@More improvement.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.8 86/07/16 17:51:38 mike Exp $ (BRL)";
d33 1
a33 1
static void	center(), cpoint(), dwreg(), ellin(),
a204 1
 *	  5. center()	finds center point of an arb
a611 20

/* find center point */
static void
center()
{
	register float ppc;
	register int i,j,k;

	for(i=0;i<3;i++){
		k=i;
		ppc=0.0;
		for(j=0; j<m_type[id]; j++) {
			ppc += *(sp+k);
			k+=3;
		}
		pcenter[i]=ppc/(float)m_type[id];
	}
}


d842 1
a842 2
	static int amt[19]={0,0,0,12,15,18,21,24,0,0,0,0,0,0,0,0,0,18,12};
	register int *ity,i,j;
a844 6
	ity = &m_type[num];
	if(*ity==20) *ity=8;
	if(*ity>19 || amt[*ity-1]==0){
		(void)printf("solin: Type %d Solid not known\n",*ity);
		return;
	}
d848 3
a850 3
	/* ARB4,5,6,7,8 */
	if(*ity<18){
		for(i=0;i<*ity;i++){
d857 1
a857 1
	}
d859 1
a859 2
	/* TGC */
	if(*ity==18){
d874 1
a874 1
	}
d876 1
a876 2
	if(*ity > 18) {
		/* ELLG */
d890 4
d909 1
a909 1
	static int ls, n4;
d924 5
a928 1
		if(m_type[id]<18){
d930 12
a941 5
			/* ARB 4,5,6,7,8 */
			n4=m_type[id]-4;
			center();
			j=n4*24;
			for(i=0;i<nfc[n4];i++){
d948 3
a950 3
			sp+=m_type[id]*3;
		}
		if(m_type[id]==18){
d953 2
a954 2
		}
		if(m_type[id]==19){
d957 1
@


2.8
log
@relocated type_arb() function to arbs.c,
improvements in tplane() to directly handle GENARB8s.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.7 86/07/16 03:44:02 mike Exp $ (BRL)";
d50 5
d56 2
a58 1
 *
d91 2
a92 2
	m_type[memb_count++] = cgtype;
	if(memb_count > NMEMB) {
d97 6
d165 6
a170 7
	if(more == 0) {
		/* this was the last member solid - draw the region */
		nmemb = memb_count;
		param_count = memb_count = 0;
		if(nmemb == 0) {
			nmemb = param_count = memb_count = 0;
			return(-1);	/* ERROR */
a171 2
		dwreg();
		return(0);	/* OK, region was drawn */
d173 14
a186 1
	return(1);		/* MORE solids follow */
a222 2
static float	reg_min[3], reg_max[3];		/* min,max's for the region */
static float	sol_min[3], sol_max[3];		/* min,max's for a solid */
a227 1
static float	*sp;			/* pointers to the solid parameter array m_param[] */
a229 1
static float	pinf = 1000000.0;
d256 1
a256 2
	tol=reg_min[0]=reg_min[1]=reg_min[2] = -pinf;
	reg_max[0]=reg_max[1]=reg_max[2]=pinf;
a258 10
	/* find min max's */
	for(i=lmemb;i<umemb;i++){
		solin(i);
		if(m_op[i] != '-') {
			for(j=0;j<3;j++){
				MAX(reg_min[j],sol_min[j]);
				MIN(reg_max[j],sol_max[j]);
			}
		}
	}
@


2.7
log
@Efficiency improvements.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.6 86/07/16 03:33:05 mike Exp $ (BRL)";
d33 3
a35 5
static void	center(), cpoint(), dwreg(), ellin(), move(), points(),
		solin(), solpl(), tgcin(), tplane(),
		vectors();
static int	arbn_shot(), cgarbs(), comparvec(), gap(), planeeq(), redoarb(), 
		region();
a76 17
	if(type == GENARB8) {
		/* check for arb8, arb7, arb6, arb5, arb4 */
		points();
		if( (i = cgarbs(uvec, svec)) == 0 ) {
			nmemb = param_count = memb_count = 0;
			return(-1);	/* ERROR */
		}
		if(redoarb(uvec, svec, i) == 0) {
			nmemb = param_count = memb_count = 0;
			return(-1);	/* ERROR */
		}
		vectors();
		cgtype = input.s.s_cgtype;
	}
	if(cgtype == RPP || cgtype == BOX || cgtype == GENARB8)
		cgtype = ARB8;

d94 1
a94 1
	case ARB8:
d96 1
a96 1
arbcom:		/* common area for arbs */
a110 18
	case ARB7:
		length = 7;
		goto arbcom;

	case ARB6:
		VMOVE(&input.s.s_values[15], &input.s.s_values[18]);
		length = 6;
		goto arbcom;

	case ARB5:
		length = 5;
		goto arbcom;

	case ARB4:
		length = 4;
		VMOVE(&input.s.s_values[9], &input.s.s_values[12]);
		goto arbcom;

a166 2
#define NO	0
#define YES	1
a167 345
/* C G A R B S :   determines COMGEOM arb types from GED general arbs
 */
static int
cgarbs( uvec, svec )
register int *uvec;	/* array of unique points */
register int *svec;	/* array of like points */
{
	register int i,j;
	static int numuvec, unique, done;
	static int si;

	done = NO;		/* done checking for like vectors */

	svec[0] = svec[1] = 0;
	si = 2;

	for(i=0; i<7; i++) {
		unique = YES;
		if(done == NO)
			svec[si] = i;
		for(j=i+1; j<8; j++) {
			if(comparvec(&input.s.s_values[i*3], &input.s.s_values[j*3]) == YES) {
				if( done == NO )
					svec[++si] = j;
				unique = NO;
			}
		}
		if( unique == NO ) {  	/* point i not unique */
			if( si > 2 && si < 6 ) {
				svec[0] = si - 1;
				if(si == 5 && svec[5] >= 6)
					done = YES;
				si = 6;
			}
			if( si > 6 ) {
				svec[1] = si - 5;
				done = YES;
			}
		}
	}
	if( si > 2 && si < 6 ) 
		svec[0] = si - 1;
	if( si > 6 )
		svec[1] = si - 5;
	for(i=1; i<=svec[1]; i++)
		svec[svec[0]+1+i] = svec[5+i];
	for(i=svec[0]+svec[1]+2; i<11; i++)
		svec[i] = -1;
	/* find the unique points */
	numuvec = 0;
	for(j=0; j<8; j++) {
		unique = YES;
		for(i=2; i<svec[0]+svec[1]+2; i++) {
			if( j == svec[i] ) {
				unique = NO;
				break;
			}
		}
		if( unique == YES )
			uvec[numuvec++] = j;
	}

	/* put comgeom solid typpe into s_cgtype */
	switch( numuvec ) {

	case 8:
		input.s.s_cgtype = ARB8;  /* ARB8 */
		break;

	case 6:
		input.s.s_cgtype = ARB7;	/* ARB7 */
		break;

	case 4:
		if(svec[0] == 2)
			input.s.s_cgtype = ARB6;	/* ARB6 */
		else
			input.s.s_cgtype = ARB5;	/* ARB5 */
		break;

	case 2:
		input.s.s_cgtype = ARB4;	/* ARB4 */
		break;

	default:
		(void)printf("solid: %s  bad number of unique vectors (%d)\n",
			input.s.s_name, numuvec);
		return(0);
	}
	return( numuvec );
}

/*  R E D O A R B :   rearranges arbs to be GIFT compatible
 */
static int
redoarb( uvec, svec, numvec )
register int *uvec, *svec;
int numvec;
{
	register int i, j;
	static int prod;

	switch( input.s.s_cgtype ) {

	case ARB8:
		/* do nothing */
		break;

	case ARB7:
		/* arb7 vectors: 0 1 2 3 4 5 6 4 */
		switch( svec[2] ) {
			case 0:
				/* 0 = 1, 3, or 4 */
				if(svec[3] == 1)
					move(4,7,6,5,1,4,3,1);
				if(svec[3] == 3)
					move(4,5,6,7,0,1,2,0);
				if(svec[3] == 4)
					move(1,2,6,5,0,3,7,0);
				break;
			case 1:
				/* 1 = 2 or 5 */
				if(svec[3] == 2)
					move(0,4,7,3,1,5,6,1);
				if(svec[3] == 5)
					move(0,3,7,4,1,2,6,1);
				break;
			case 2:
				/* 2 = 3 or 6 */
				if(svec[3] == 3)
					move(6,5,4,7,2,1,0,2);
				if(svec[3] == 6)
					move(3,0,4,7,2,1,5,2);
				break;
			case 3:
				/* 3 = 7 */
				move(2,1,5,6,3,0,4,3);
				break;
			case 4:
				/* 4 = 5 */
				/* if 4 = 7  do nothing */
				if(svec[3] == 5)
					move(1,2,3,0,5,6,7,5);
				break;
			case 5:
				/* 5 = 6 */
				move(2,3,0,1,6,7,4,6);
				break;
			case 6:
				/* 6 = 7 */
				move(3,0,1,2,7,4,5,7);
				break;
			default:
				(void)printf("redoarb: %s - bad arb7\n",
					input.s.s_name);
				return( 0 );
			}
			break;    	/* end of ARB7 case */

		case ARB6:
			/* arb6 vectors:  0 1 2 3 4 4 6 6 */

			prod = 1;
			for(i=0; i<numvec; i++)
				prod = prod * (uvec[i] + 1);
			switch( prod ) {
			case 24:
				/* 0123 unique */
				/* 4=7 and 5=6  OR  4=5 and 6=7 */
				if(svec[3] == 7)
					move(3,0,1,2,4,4,5,5);
				else
					move(0,1,2,3,4,4,6,6);
				break;
			case 1680:
				/* 4567 unique */
				/* 0=3 and 1=2  OR  0=1 and 2=3 */
				if(svec[3] == 3)
					move(7,4,5,6,0,0,1,1);
				else
					move(4,5,6,7,0,0,2,2);
				break;
			case 160:
				/* 0473 unique */
				/* 1=2 and 5=6  OR  1=5 and 2=6 */
				if(svec[3] == 2)
					move(0,3,7,4,1,1,5,5);
				else
					move(4,0,3,7,1,1,2,2);
				break;
			case 672:
				/* 3267 unique */
				/* 0=1 and 4=5  OR  0=4 and 1=5 */
				if(svec[3] == 1)
					move(3,2,6,7,0,0,4,4);
				else
					move(7,3,2,6,0,0,1,1);
				break;
			case 252:
				/* 1256 unique */
				/* 0=3 and 4=7  OR 0=4 and 3=7 */
				if(svec[3] == 3)
					move(1,2,6,5,0,0,4,4);
				else
					move(5,1,2,6,0,0,3,3);
				break;
			case 60:
				/* 0154 unique */
				/* 2=3 and 6=7  OR  2=6 and 3=7 */
				if(svec[3] == 3)
					move(0,1,5,4,2,2,6,6);
				else
					move(5,1,0,4,2,2,3,3);
				break;
			default:
				(void)printf("redoarb: %s: bad arb6\n",
					input.s.s_name);
				return( 0 );
			}
			break; 		/* end of ARB6 case */

		case ARB5:
			/* arb5 vectors:  0 1 2 3 4 4 4 4 */
			prod = 1;
			for(i=2; i<6; i++)
				prod = prod * (svec[i] + 1);
			switch( prod ) {
			case 24:
				/* 0=1=2=3 */
				move(4,5,6,7,0,0,0,0);
				break;
			case 1680:
				/* 4=5=6=7 */
				/* do nothing */
				break;
			case 160:
				/* 0=3=4=7 */
				move(1,2,6,5,0,0,0,0);
				break;
			case 672:
				/* 2=3=7=6 */
				move(0,1,5,4,2,2,2,2);
				break;
			case 252:
				/* 1=2=5=6 */
				move(0,3,7,4,1,1,1,1);
				break;
			case 60:
				/* 0=1=5=4 */
				move(3,2,6,7,0,0,0,0);
				break;
			default:
				(void)printf("redoarb: %s: bad arb5\n",
					input.s.s_name);
				return( 0 );
			}
			break;		/* end of ARB5 case */

		case ARB4:
			/* arb4 vectors:  0 1 2 0 4 4 4 4 */
			j = svec[6];
			if( svec[0] == 2 )
				j = svec[4];
			move(uvec[0],uvec[1],svec[2],uvec[0],j,j,j,j);
			break;

		default:
			(void)printf("redoarb %s: unknown arb type (%d)\n",
				input.s.s_name,input.s.s_cgtype);
			return( 0 );
	}

	return( 1 );
}


static void
move( p0, p1, p2, p3, p4, p5, p6, p7 )
int p0, p1, p2, p3, p4, p5, p6, p7;
{
	register int i, j;
	static int pts[8];
	static float copy[24];

	pts[0] = p0 * 3;
	pts[1] = p1 * 3;
	pts[2] = p2 * 3;
	pts[3] = p3 * 3;
	pts[4] = p4 * 3;
	pts[5] = p5 * 3;
	pts[6] = p6 * 3;
	pts[7] = p7 * 3;

	/* copy of the record */
	for(i=0; i<=21; i+=3) {
		VMOVE(&copy[i], &input.s.s_values[i]);
	}

	for(i=0; i<8; i++) {
		j = pts[i];
		VMOVE(&input.s.s_values[i*3], &copy[j]);
	}
}



static int
comparvec( x, y )
register float *x,*y;
{
	register int i;

	for(i=0; i<3; i++) {
		if( fabs( *x++ - *y++ ) > 0.0001 )
			return(0);   /* different */
	}
	return(1);  /* same */
}


static void
vectors()
{
	register int i;

	for(i=3; i<=21; i+=3) {
		VSUB2(&input.s.s_values[i],&input.s.s_values[i],&input.s.s_values[0]);
	}
}



static void
points()
{
	register int i;

	for(i=3; i<=21; i+=3) {
		VADD2(&input.s.s_values[i],&input.s.s_values[i],&input.s.s_values[0]);
	}
}




a189 1
 *	 13. planeeq()	finds normalized plane from 3 points
a195 1

d626 1
d655 6
a660 1
	if(planeeq( pp, p,q,r)==0) return;
d662 1
a662 6
	if((pp[3]-VDOT(pp,pcenter)) > 0.)  {
		VREVERSE( pp, pp );
		pp[3] = -pp[3];
	}

	/* See if this plane already exists */
d676 3
a678 10
/*
 *			P L A N E E Q
 *
 * computes normalized plane eq from three points.
 *  Returns 0 if plane is degenerate, 1 if plane is good.
 */
static int
planeeq(eqn,p1,p2,p3)
float *eqn;
float *p1, *p2, *p3;
d680 8
a687 2
	static float vecl;
	static float va[3],vb[3],vc[3];
d689 52
a740 8
	VSUB2( va, p2, p1 );
	VSUB2( vb, p3, p1 );
	VCROSS(vc,va,vb);
	vecl = MAGNITUDE( vc );
	if(vecl<.0001) return(0);
	VSCALE(eqn, vc, 1.0/vecl);
	eqn[3] = VDOT(eqn, p1);
	return(1);
a976 35
}



/* TYPE_ARB()	returns specific ARB type of record rec.  The record rec
 *		is also rearranged to "standard" form.
 */
type_arb( rec )
union record *rec;
{
	int i;
	static int uvec[8], svec[11];

	if( rec->s.s_type != GENARB8 )
		return( 0 );

	input = *rec;		/* copy */

	/* convert input record to points */
	points();

	if( (i = cgarbs(uvec, svec)) == 0 )
		return(0);

	if( redoarb(uvec, svec, i) == 0 )
		return( 0 );

	/* convert to vectors in the rec record */
	VMOVE(&rec->s.s_values[0], &input.s.s_values[0]);
	for(i=3; i<=21; i+=3) {
		VSUB2(&rec->s.s_values[i], &input.s.s_values[i], &input.s.s_values[0]);
	}

	return( input.s.s_cgtype );

@


2.6
log
@More cleanups
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.5 86/07/16 01:01:33 mike Exp $ (BRL)";
d933 3
a935 1
	static float s,*pp,dxbdn,wbdn,te;
d942 1
a942 1
		te = -1.0 * tol;
d944 3
a946 2
	for(pp = &peq[la*4];pp <= &peq[lb*4];pp+=4){
		dxbdn = *(pp+3)-VDOT(xb,pp);
d948 3
a950 1
		if(fabs(wbdn)>.001){
d954 1
a954 2
			}
			else {
d957 1
a957 2
		}
		else{
d962 1
a962 2
	/* ray starts inside */
	MAX(rin,0);
@


2.5
log
@Minor cleanups
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.4 85/08/07 05:19:36 mike Exp $ (BRL)";
d34 1
a34 1
		regin(), solin(), solpl(), tgcin(), tplane(),
d36 1
a36 1
static int	arb(), cgarbs(), comparvec(), gap(), planeeq(), redoarb(), 
d569 1
a569 1
 *	  7. arb()	finds intersection of ray with an arb
a571 1
 *	 10. regin()	process region to planes
d594 1
a594 1
static float	*sp, *savesp;		/* pointers to the solid parameter array m_param[] */
d608 4
a611 1
	static float c1[3*4]={1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.};
d614 1
a615 14
	/* calculate center and scale for COMPLETE REGION since may have ORs */
	lmemb = umemb = 0;
	savesp = &m_param[0];
	while( 1 ) {
		/* Perhaps this can be eliminated?  Side effects? */
		for(umemb = lmemb+1; (umemb < nmemb && m_op[umemb] != 'u'); umemb++)
			;
		lc = 0;
		regin(1, lmemb, umemb);
		lmemb = umemb;
		if(umemb >= nmemb)
			break;
	}

d624 3
a626 1
	regin(0, lmemb, umemb);
d628 23
d704 2
a705 1
					/* compute direction vector for ray */
d716 4
a719 1
					/* starting point for this ray */
d882 1
a882 1
	/* ray intersects region - find intersection with each member */
d895 1
a895 1
			if( arb() == 0 )
d909 1
a909 1
			if(arb() != 0) {
d924 10
d935 29
a1082 37
/* finds intersection of ray with arbitrary convex polyhedron */
static int
arb()
{
	static float s,*pp,dxbdn,wbdn,te;

	rin = ri;
	rout = ro;

	te = tol;
	if(oper == '-' && negpos)
		te = -1.0 * tol;

	for(pp = &peq[la*4];pp <= &peq[lb*4];pp+=4){
		dxbdn = *(pp+3)-VDOT(xb,pp);
		wbdn=VDOT(wb,pp);
		if(fabs(wbdn)>.001){
			s=dxbdn/wbdn;
			if(wbdn > 0.0) {
				MAX(rin, s);
			}
			else {
				MIN(rout,s);
			}
		}
		else{
			if(dxbdn>te) return(0);
		}
		if((rin+tol)>=rout || rout<=tol) return(0);
	}
	/* ray starts inside */
	MAX(rin,0);
	return(1);
}



a1190 39

/* process region into planes */
static void
regin(flag, lmemb, umemb)
int flag;	/* 1 if only calculating min,maxs   NO PLANE EQUATIONS */
{
	register int i,j;

	tol=reg_min[0]=reg_min[1]=reg_min[2] = -pinf;
	reg_max[0]=reg_max[1]=reg_max[2]=pinf;
	sp = savesp;

	/* find min max's */
	for(i=lmemb;i<umemb;i++){
		solin(i);
		if(m_op[i] != '-') {
			for(j=0;j<3;j++){
				MAX(reg_min[j],sol_min[j]);
				MIN(reg_max[j],sol_max[j]);
			}
		}
	}
	for(i=0;i<3;i++){
		MAX(tol,fabs(reg_min[i]));
		MAX(tol,fabs(reg_max[i]));
	}
	tol=tol*0.00001;

	if(flag == 0 ) {
		/* find planes for each solid */
		sp = savesp;
		solpl(lmemb,umemb);
	}

	/* save the parameter pointer in case region has ORs */
	savesp = sp;
}


a1263 1
/* Called only from regin() */
@


2.5.1.1
log
@Unlike version 2.13, this one works, but compiles with CC -I../h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.5 86/07/16 01:01:33 mike Exp $ (BRL)";
d26 1
a26 1
#include <math.h>
d28 4
a31 4
#include "vmath.h"
#include "db.h"
#include "./ged.h"
#include "./dm.h"
d1337 35
@


2.4
log
@Changed to use common ../h/vmath.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.3 85/07/30 01:17:54 mike Exp $ (BRL)";
d33 1
a33 1
static void	center(), cpoint(), dwreg(), ellin(), move(), neg(), points(),
a565 1
 *	  3. neg()	vector A = - vector B
d587 3
a589 3
static float	pc[3];			/* center (interior) point of a solid */
static float	rmn[3], rmx[3];		/* min,max's for the region */
static float	smn[3], smx[3];		/* min,max's for a solid */
a594 3
static int	lmemb, umemb;		/* lower and upper limit of members of a region
					 * from one OR to the next OR
					 */
d597 1
a597 1
static int	la, lb, lc, id, jd, nint, ngaps;
a608 2
	static float pi[3],po[3];
	static float lenwb;
d610 2
d621 1
a621 1
		regin(1);
d635 1
a635 1
	regin(0);
d637 2
a638 2

	for(i=0; i<3; i++) c1[(i*4)+3]=rmn[i];
d686 2
a687 2
					if(fabs(VDOT(&peq[i*4],&peq[j*4]))<.9999){
						/* planes not parallel */
d689 4
a692 4
						/* compute vector for ray */
						VCROSS(wb,&peq[i*4],&peq[j*4]);
						lenwb = MAGNITUDE( wb );
						VSCALE(wb, wb, 1.0/lenwb);
d694 6
a699 7
						/* starting point for this ray */
						k=0;
						if(fabs(wb[1]) > fabs(wb[0])) k=1;
						if(fabs(wb[2]) > fabs(wb[k])) k=2;
						if(wb[k] < 0.0)
							neg( wb, wb, 3 );
						cpoint(&c1[k*4],&peq[i*4],&peq[j*4]);
d701 15
a715 13
						/* check if ray intersects region */
						if(region()>0){
							/* ray intersects region */
							/* plot this ray  including gaps */
							for(n=0; n<nint; n++){
								for(k=0; k<3; k++){
									 pi[k]=xb[k]+wb[k]*regi[n];
									 po[k]=xb[k]+wb[k]*rego[n];
								}
								DM_GOTO(&pi[0], PEN_UP);
								DM_GOTO(&po[0], PEN_DOWN);
							}
						}
d825 2
a826 2
 *   	returns 1  if intersection
 *	        0  if no intersection
a827 1

d829 1
a829 1
region()
a833 1
	static float dum1, dum2;
a834 1
	nint=0;
d840 2
a841 4
	for(i=0;i<3;i++){
		s1[i]=rmn[i]-xb[i];
		s2[i]=rmx[i]-xb[i];
	}
d852 1
a852 2
			}
			else {
d858 1
a858 2
		}
		else {
d872 1
a872 1
			goto nullsolid;
d882 2
a883 5
			}
			else{
				dum1 = -1.0 * pinf;
				dum2 = rin;
				if(gap(dum1, dum2) <= 0)
d885 1
a885 3
				dum1 = rout;
				dum2 = pinf;
				if(gap(dum1, dum2) <= 0)
d892 1
a892 3
				dum1 = rin;
				dum2 = rout;
				if(gap(dum1, dum2) <= 0)
a897 2
nullsolid:
		;
a900 1
	nint=ngaps+1;
d902 2
a903 2
	rego[nint-1]=ro;
	return(1);
d907 5
d913 2
a914 14
neg(a,b,n)
register float *a, *b;
int n;
{
	register int i;

	for(i=0; i<n; i++)
		*(b+i) = -1.0 * (*(a+i));
}


/* computes point of intersection of three planes */
static void
cpoint(c1,c2,c3)
d922 4
a925 1
	if((d=VDOT(c1,v1))==0) return;
d930 1
a930 1
		xb[i]=d*(*(c1+3)*v1[i]-(*(c2+3))*v2[i]+(*(c3+3))*v3[i]);
d948 1
a948 1
		pc[i]=ppc/(float)m_type[id];
d953 6
a958 1
/* test if plane inside enclosing rpp */
d961 1
a961 1
register float *p, *q, *r, *s;
d963 1
a963 2
	static float t;
	static float *pp,*pf;
d966 2
a967 1
	pp = &peq[lc*4];
d969 2
a970 1
		t=rmn[i]-tol;
d973 1
a973 1
		t=rmx[i]+tol;
d978 4
a981 2
	/* Does plane already exist? */
	if(planeeq(p,q,r)==0) return;
d983 6
a988 1
	if((*(pp+3)-VDOT(pp,pc)) > 0.) neg(pp,pp,4);
d995 1
a995 1
	if(++lc > NPLANES) {
a996 1
		lc--;
d999 1
d1002 24
d1075 1
a1075 1
		pc[i]=( *(sp+i) + vt[i])*.5;
d1128 1
a1128 1
	for(i=0;i<3;i++) pc[i] = *(sp+i);
d1174 1
a1174 1
regin(flag)
d1179 2
a1180 2
	tol=rmn[0]=rmn[1]=rmn[2] = -pinf;
	rmx[0]=rmx[1]=rmx[2]=pinf;
d1188 2
a1189 2
				MAX(rmn[j],smn[j]);
				MIN(rmx[j],smx[j]);
d1194 2
a1195 2
		MAX(tol,fabs(rmn[i]));
		MAX(tol,fabs(rmx[i]));
d1202 1
a1202 1
		solpl();
d1225 2
a1226 2
	smn[0]=smn[1]=smn[2]=pinf;
	smx[0]=smx[1]=smx[2] = -pinf;
d1232 2
a1233 2
				MIN(smn[j],*sp);
				MAX(smx[j],*sp);
d1249 4
a1252 4
			MIN(smn[i],*(sp)-v1);
			MIN(smn[i],vt-v2);
			MAX(smx[i],*(sp)+v1);
			MAX(smx[i],vt+v2);			
d1266 4
a1269 4
			MIN(smn[i],vb-v1);
			MIN(smn[i],vt-v2);
			MAX(smx[i],vb+v1);
			MAX(smx[i],vt+v2);
d1276 2
a1277 2
		solrpp[num*6+i] = smn[i];
		solrpp[num*6+i+3] = smx[i];
d1283 1
d1285 1
a1285 1
solpl()
a1339 8
/* computes normalized plane eq from three points */
static int
planeeq(p1,p2,p3)
float *p1, *p2, *p3;
{
	static float vecl;
	static float va[3],vb[3],vc[3];
	register int i;
a1340 14
	for(i=0;i<3;i++){
		va[i] = *(p2+i) - *(p1+i);
		vb[i] = *(p3+i) - *(p1+i);
	}
	VCROSS(vc,va,vb);
	vecl = MAGNITUDE( vc );
	if(vecl<.0001) return(0);
	VSCALE(&peq[lc*4], vc, 1.0/vecl);
	peq[(lc*4)+3] = VDOT(&peq[lc*4], p1);
	return(1);
}



a1372 2


@


2.3
log
@Change to support new ARB editing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.2 85/05/07 23:12:19 mike Exp $ (BRL)";
d27 2
a28 1
#include "ged_types.h"
a30 1
#include "../h/vmath.h"
@


2.2
log
@KAA fixes for ARB6, ARB7
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 2.1 85/03/11 23:56:48 mike Prod $ (BRL)";
d36 1
a36 1
static int	arb(), cgarbs(), comparvec(), gap(), planeeq(), redoarb(),
d81 4
a84 11
		if(input.s.s_cgtype >= 0) {
			points();
			if( (i = cgarbs(uvec, svec)) == 0 ) {
				nmemb = param_count = memb_count = 0;
				return(-1);	/* ERROR */
			}
			if(redoarb(uvec, svec, i) == 0) {
				nmemb = param_count = memb_count = 0;
				return(-1);	/* ERROR */
			}
			vectors();
d86 6
a91 1
		cgtype = input.s.s_cgtype * -1;
d273 1
a273 1
		input.s.s_cgtype = -8;  /* ARB8 */
d277 1
a277 1
		input.s.s_cgtype = -7;	/* ARB7 */
d282 1
a282 1
			input.s.s_cgtype = -6;	/* ARB6 */
d284 1
a284 1
			input.s.s_cgtype = -5;	/* ARB5 */
d288 1
a288 1
		input.s.s_cgtype = -4;	/* ARB4 */
d307 1
a307 1
	static int prod, cgtype;
d309 1
a309 1
	cgtype = input.s.s_cgtype * -1;
a310 2
	switch( cgtype ) {

d1346 37
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 1.5 85/01/16 01:58:29 mike Exp $ (BRL)";
d118 3
a120 3
		MAT4X3PNT( work, xform, recordp->s.s_values );
		VMOVE( recordp->s.s_values, work );
		VMOVE(&m_param[param_count], &(recordp->s.s_values[0]));
d122 1
a122 1
		op = &recordp->s.s_values[1*3];
d125 1
a125 1
			VADD2(op, recordp->s.s_values, work);
@


1.5
log
@pre-Keith version
@
text
@d7 1
d17 4
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: proc_reg.c,v 1.4 84/11/20 04:25:15 mike Exp $ (BRL)";
d28 1
a28 1
#include "db.h"
d30 1
a30 1
#include "vmath.h"
a32 2
extern int	printf();

d36 1
a36 1
static int	arb(), cgarbs(), compar(), gap(), plane(), redoarb(),
d230 1
a230 1
			if(compar(&input.s.s_values[i*3], &input.s.s_values[j*3]) == YES) {
d518 1
a518 1
compar( x, y )
d580 1
a580 1
 *	 13. plane()	finds normalized plane from 3 points
a618 2
	static unsigned	count;
	static unsigned	addr;
d1001 1
a1001 1
	if(plane(p,q,r)==0) return;
d1332 1
a1332 1
plane(p1,p2,p3)
@


1.4
log
@Vector lists saved, multiple display managers supported.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d23 1
a23 1
#include "3d.h"
@


1.3
log
@Better interface between drawHsolid and proc_reg
@
text
@d11 5
a15 3
 *
 *	Ballistic Research Laboratory
 *	U. S. Army
d17 3
d24 1
a24 2
#include "commo.h"
#include "ged2.h"
a617 1
	static float xmin,ymin,zmin,xmax,ymax,zmax;
a619 6
	xmin = ymin = zmin = 100000000.0;
	xmax = ymax = zmax = -100000000.0;

	/* set up for drawing with VECTOR ABSOLUTE Solid Lines */
	dmp->dmr_Spreamble( 1 );

d624 1
a628 6
		MIN(xmin, rmn[0]);
		MIN(ymin, rmn[1]);
		MIN(zmin, rmn[2]);
		MAX(xmax, rmx[0]);
		MAX(ymax, rmx[1]);
		MAX(zmax, rmx[2]);
a632 6
	dl_scale = xmax - xmin;
	MAX(dl_scale, ymax - ymin);
	MAX(dl_scale, zmax - zmin);
	dl_xcent = (xmax + xmin) / 2.0;
	dl_ycent = (ymax + ymin) / 2.0;
	dl_zcent = (zmax + zmin) / 2.0;
d718 2
a719 2
								dmp->dmr_goto(&pi[0], UP);
								dmp->dmr_goto(&po[0], DOWN);
d739 1
a739 26

	/* Finish off the display subroutine */
	dmp->dmr_Sepilogue();

	/* Build output record */
	commi.i_center[X] = dl_xcent;
	commi.i_center[Y] = dl_ycent;
	commi.i_center[Z] = dl_zcent;
	commi.i_center[H] = 1;
	commi.i_scale = dl_scale;

	/* Determine VG memory requirement */
	count = dmp->dmr_size();

	/* Allocate VG storage for object */
	addr = memalloc( count );

	commi.i_addr = addr;
	commi.i_type = MS_DREG;

	if( addr == 0 )  {
		(void)printf("dwreg: no more Displaylist memory\n");
		commi.i_size = 0;	/* FLAG:  error */
	} else {
		commi.i_size = dmp->dmr_load( addr, count );
	}
@


1.2
log
@Minor cleanups
@
text
@a0 1
/*	SCCSID	%W%	%E%	*/
d2 1
a2 1
 *				G 2 . C
a3 2
 *			G E D ,   P a r t   I I
 *
a13 9
 *
 *		R E V I S I O N   H I S T O R Y
 *
 *	06/01/83  MJM	Split ged2.c into g1.c and g2.c
 *
 *	09-Sep-83 DAG	Overhauled.
 *
 *	11/02/83  CMK	Modified to use g3.c module (device independence).
 *			Moved display processor FD to g3.c module
d27 1
a27 1
		regin(), ret_error(), solin(), solpl(), tgcin(), tplane(),
d50 4
d55 4
a58 6

void
proc_reg( dp, xform, flag )
struct directory *dp;
mat_t xform;
int flag;
d61 1
a61 1
	static float *op;	/* Used for scanning vectors */
d63 3
a65 4
	static vect_t	homog;		/* Vector/Homog.Vector conversion buffer */
	int length, type;
	int uvec[8], svec[11];
	int cgtype;
d67 1
a67 1
 	db_getrec( dp, &input, 0 );
d69 1
a69 3
#define	ip	(&input.s)

	type = ip->s_type;
d77 2
a78 2
				ret_error();
				return;
d81 2
a82 2
				ret_error();
				return;
d91 1
a91 1
	if(commo.o_flag == ROOT)
d94 1
a94 1
	if(commo.o_flag == 999)
d102 2
a103 2
		ret_error();
		return;
d111 3
a113 3
		MAT4X3PNT( work, commo.o_mat, ip->s_values );
		VMOVE( ip->s_values, work );
		VMOVE(&m_param[param_count], &(ip->s_values[0]));
d115 1
a115 1
		op = &ip->s_values[1*3];
d117 2
a118 2
			MAT4X3VEC( work, commo.o_mat, op );
			VADD2(op, ip->s_values, work);
d144 2
a145 2
		op = &ip->s_values[0*3];
		MAT4X3PNT( work, commo.o_mat, op );
d152 1
a152 1
			MAT4X3VEC( work, commo.o_mat, op );
d161 2
a162 2
		op = &ip->s_values[0*3];
		MAT4X3PNT( work, commo.o_mat, op );
d169 1
a169 1
			MAT4X3VEC( work, commo.o_mat, op );
d181 2
a182 2
		ret_error();
		return;
d185 1
a185 1
	if(commo.o_more == 0) {
d190 2
a191 2
			ret_error();
			return;
d194 1
a194 2
	} else {
		commi.i_type = MS_MORE;
d196 1
a198 12
/*
 *  called to return to ged1 if any errors were
 *  found while processing a region
 */
static void
ret_error()
{

	commi.i_type = MS_ERROR;
	nmemb = param_count = memb_count = 0;
}

d621 1
a621 1
	dl_preamble( 1 );
d732 2
a733 2
								dl_goto(&pi[0], UP);
								dl_goto(&po[0], DOWN);
d755 1
a755 1
	dl_epilogue();
d765 1
a765 1
	count = dl_size();
d777 1
a777 1
		commi.i_size = dl_load( addr, count );
@


1.1
log
@Initial revision
@
text
@d34 1
d49 1
a237 1
#define	sp	(&input.s)
d248 1
a248 1
			if(compar(&sp->s_values[i*3], &sp->s_values[j*3]) == YES) {
d633 1
a633 1
	static int n,m
@
