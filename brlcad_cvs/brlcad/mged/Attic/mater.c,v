head	11.41;
access;
symbols
	ansi-20040405-merged:11.36.2.2
	postmerge-20040405-ansi:11.39
	premerge-20040404-ansi:11.38
	postmerge-autoconf:11.38
	autoconf-freeze:11.36.10.3
	premerge-autoconf:11.38
	postmerge-20040315-windows:11.38
	premerge-20040315-windows:11.37
	windows-20040315-freeze:11.36.4.2
	autoconf-20031203:11.36
	autoconf-20031202:11.36
	autoconf-branch:11.36.0.10
	phong-branch:11.36.0.8
	photonmap-branch:11.36.0.6
	rel-6-1-DP:11.36
	windows-branch:11.36.0.4
	rel-6-0-2:11.34
	ansi-branch:11.36.0.2
	rel-6-0-1-branch:11.34.0.2
	hartley-6-0-post:11.35
	hartley-6-0-pre:11.34
	rel-6-0-1:11.34
	rel-6-0:11.34
	rel-5-4:11.25
	offsite-5-3-pre:11.27
	rel-5-3:11.25
	rel-5-2:11.25
	rel-5-1-branch:11.25.0.2
	rel-5-1:11.25
	rel-5-0:11.24
	rel-5-0-beta:11.23
	rel-4-5:11.18
	ctj-4-5-post:11.16
	ctj-4-5-pre:11.16
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:1.4;
locks; strict;
comment	@ * @;


11.41
date	2004.05.21.17.47.44;	author morrison;	state dead;
branches;
next	11.40;

11.40
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.39;

11.39
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2004.02.02.17.39.33;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2002.08.20.17.08.24;	author jra;	state Exp;
branches
	11.36.2.1
	11.36.4.1
	11.36.10.1;
next	11.35;

11.35
date	2002.08.15.20.55.35;	author hartley;	state Exp;
branches;
next	11.34;

11.34
date	2001.08.14.18.30.39;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	2001.05.04.14.20.46;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	2001.05.02.17.14.01;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	2001.04.03.19.01.59;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	2001.04.02.18.10.11;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2001.03.23.16.05.52;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	2000.10.24.19.05.07;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.08.19.03.10.47;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	99.12.28.19.43.11;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	99.09.01.18.55.11;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	99.05.10.22.00.44;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	98.10.21.17.04.24;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	98.06.24.18.34.46;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	98.06.24.17.22.14;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	98.05.26.14.25.06;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.11.03.15.24.31;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.05.02.15.07.25;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.05.02.14.56.20;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.10.04.15.03.37;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.30.19.47.18;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.09.23.18.24.56;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.09.17.21.20.57;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.03.01.19.30.49;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.51;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.15;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.27.17.22.34;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.12.16.19.36.56;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.11.01.17.47.14;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.08.09.15.22.55;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.06.01.15.16.38;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.04.01.04.43.56;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.48;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.01.12.08.25.58;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.08.00.31.21;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.23;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.06.20.40.09;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.03.06.17.35.40;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.18.01.55.54;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.28.27;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.00;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	87.11.14.04.45.34;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.23;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.01.17;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.31;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.21.21;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.08.06;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.22.12;	author mike;	state Rel1;
branches;
next	1.11;

1.11
date	86.11.14.04.59.39;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.11.14.04.33.42;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.11.14.03.50.58;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.11.10.20.33.05;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.12.06.50.03;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.02.17.17.06.12;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.09.14.05.36.58;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.08.07.05.19.15;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.06.03.16.49.23;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.03.15.05.06.11;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.03.14.05.03.48;	author mike;	state Exp;
branches;
next	;

11.36.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	11.36.2.2;

11.36.2.2
date	2004.03.17.21.22.00;	author morrison;	state Exp;
branches;
next	;

11.36.4.1
date	2002.09.26.23.04.11;	author morrison;	state Exp;
branches;
next	11.36.4.2;

11.36.4.2
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

11.36.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.36.10.2;

11.36.10.2
date	2004.03.15.14.07.38;	author erikg;	state Exp;
branches;
next	11.36.10.3;

11.36.10.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Module to map from ID codes to color values and database handles.
@


11.41
log
@moved to src/mged/
@
text
@/*
 *  			M A T E R . C
 *  
 *  Code to deal with establishing and maintaining the tables which
 *  map region ID codes into worthwhile material information
 *  (colors and outboard database "handles").
 *
 *  Functions -
 *	f_prcolor	Print color & material table
 *	f_color		Add a color & material table entry
 *	f_edcolor	Invoke text editor on color table
 *	color_soltab	Apply colors to the solid table
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/mater.c,v 11.40 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "mater.h"
#include "raytrace.h"
#include "./ged.h"
#include "externs.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

/*
 *  It is expected that entries on this mater list will be sorted
 *  in strictly ascending order, with no overlaps (ie, monotonicly
 * increasing).
 */
extern struct mater *rt_material_head;	/* now defined in librt/mater.c */
extern void rt_insert_color( struct mater *newp );

void color_soltab(void);
void color_putrec(register struct mater *mp), color_zaprec(register struct mater *mp);

static char	tmpfil[17];
#ifndef WIN32
static char	*tmpfil_init = "/tmp/GED.aXXXXXX";
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif

/*
 *  			F _ E D C O L O R
 *  
 *  Print color table in easy to scanf() format,
 *  invoke favorite text editor to allow user to
 *  fiddle, then reload incore structures from file,
 *  and update database.
 */
int
f_edcolor(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct mater *mp;
	register struct mater *zot;
	register FILE *fp;
	register int fd;
	char line[128];
	static char hdr[] = "LOW\tHIGH\tRed\tGreen\tBlue\n";
	int ret = TCL_OK;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 1 || 1 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help edcolor");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	strcpy(tmpfil, tmpfil_init);
#ifdef WIN32
	(void)mktemp(tmpfil);
	if ((fp = fopen(tmpfil, "w")) == NULL) {
		perror(tmpfil);
		return TCL_ERROR;;
	}
#else
	if ((fd = mkstemp(tmpfil)) < 0) {
		perror(tmpfil);
		return TCL_ERROR;
	}
	if ((fp = fdopen(fd, "w+")) == NULL) {
		close(fd);
		perror(tmpfil);
		return TCL_ERROR;;
	}
#endif

	(void)fprintf( fp, hdr );
	for( mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw )  {
		(void)fprintf( fp, "%d\t%d\t%3d\t%3d\t%3d",
			mp->mt_low, mp->mt_high,
			mp->mt_r, mp->mt_g, mp->mt_b );
		(void)fprintf( fp, "\n" );
	}
	(void)fclose(fp);

	if( !editit( tmpfil ) )  {
	  Tcl_AppendResult(interp, "Editor returned bad status.  Aborted\n", (char *)NULL);
	  return TCL_ERROR;
	}

	/* Read file and process it */
	if( (fp = fopen( tmpfil, "r")) == NULL )  {
	  perror( tmpfil );
	  return TCL_ERROR;
	}

	if (fgets(line, sizeof (line), fp) == NULL ||
	    line[0] != hdr[0]) {
		Tcl_AppendResult(interp, "Header line damaged, aborting\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (dbip->dbi_version < 5) {
		/* Zap all the current records, both in core and on disk */
		while (rt_material_head != MATER_NULL) {
			zot = rt_material_head;
			rt_material_head = rt_material_head->mt_forw;
			color_zaprec(zot);
			bu_free((genptr_t)zot, "mater rec");
		}

		while (fgets(line, sizeof (line), fp) != NULL) {
			int cnt;
			int low, hi, r, g, b;

			cnt = sscanf(line, "%d %d %d %d %d",
				     &low, &hi, &r, &g, &b);
			if (cnt != 5) {
				Tcl_AppendResult(interp, "Discarding ",
						 line, "\n", (char *)NULL);
				continue;
			}
			BU_GETSTRUCT(mp, mater);
			mp->mt_low = low;
			mp->mt_high = hi;
			mp->mt_r = r;
			mp->mt_g = g;
			mp->mt_b = b;
			mp->mt_daddr = MATER_NO_ADDR;
			rt_insert_color(mp);
			color_putrec(mp);
		}
	} else {
		struct bu_vls vls;

		/* free colors in rt_material_head */
		rt_color_free();

		bu_vls_init(&vls);

		while (fgets(line, sizeof (line), fp) != NULL) {
			int cnt;
			int low, hi, r, g, b;

			/* check to see if line is reasonable */
			cnt = sscanf(line, "%d %d %d %d %d",
				     &low, &hi, &r, &g, &b);
			if (cnt != 5) {
				Tcl_AppendResult(interp, "Discarding ",
						 line, "\n", (char *)NULL);
				continue;
			}
			bu_vls_printf(&vls, "{%d %d %d %d %d} ", low, hi, r, g, b);
		}

		db5_update_attribute("_GLOBAL", "regionid_colortable", bu_vls_addr(&vls), dbip);
		db5_import_color_table(bu_vls_addr(&vls));
		bu_vls_free(&vls);
	}

	(void)fclose(fp);
	(void)unlink(tmpfil);

	color_soltab();

	return ret;
}

/*
 *  			C O L O R _ P U T R E C
 *  
 *  Used to create a database record and get it written out to a granule.
 *  In some cases, storage will need to be allocated.
 */
void
color_putrec(register struct mater *mp)
{
	struct directory dir;
	union record rec;

	if(dbip == DBI_NULL)
	  return;

	if( dbip->dbi_read_only )
		return;
	rec.md.md_id = ID_MATERIAL;
	rec.md.md_low = mp->mt_low;
	rec.md.md_hi = mp->mt_high;
	rec.md.md_r = mp->mt_r;
	rec.md.md_g = mp->mt_g;
	rec.md.md_b = mp->mt_b;

	/* Fake up a directory entry for db_* routines */
	dir.d_namep = "color_putrec";
	dir.d_magic = RT_DIR_MAGIC;
	dir.d_flags = 0;
	if( mp->mt_daddr == MATER_NO_ADDR )  {
		/* Need to allocate new database space */
		if( db_alloc( dbip, &dir, 1 ) < 0 )  ALLOC_ERR_return;
		mp->mt_daddr = dir.d_addr;
	} else {
		dir.d_addr = mp->mt_daddr;
		dir.d_len = 1;
	}
	if( db_put( dbip, &dir, &rec, 0, 1 ) < 0 )  WRITE_ERR_return;
}

/*
 *  			C O L O R _ Z A P R E C
 *  
 *  Used to release database resources occupied by a material record.
 */
void
color_zaprec(register struct mater *mp)
{
	struct directory dir;

	if(dbip == DBI_NULL)
	  return;

	if( dbip->dbi_read_only || mp->mt_daddr == MATER_NO_ADDR )
		return;
	dir.d_magic = RT_DIR_MAGIC;
	dir.d_namep = "color_zaprec";
	dir.d_len = 1;
	dir.d_addr = mp->mt_daddr;
	dir.d_flags = 0;
	if( db_delete( dbip, &dir ) < 0 )  DELETE_ERR_return("color_zaprec");
	mp->mt_daddr = MATER_NO_ADDR;
}

/*
 *  			C O L O R _ S O L T A B
 *
 *  Pass through the solid table and set pointer to appropriate
 *  mater structure.
 */
void
color_soltab(void)
{
	register struct solid *sp;
	register struct mater *mp;

	FOR_ALL_SOLIDS( sp, &dgop->dgo_headSolid )  {
		sp->s_cflag = 0;

	        /* the user specified the color, so use it */
		if( sp->s_uflag ) {
			sp->s_color[0] = sp->s_basecolor[0];
			sp->s_color[1] = sp->s_basecolor[1];
			sp->s_color[2] = sp->s_basecolor[2];
			goto done;
		}

		for( mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw )  {
			if( sp->s_regionid <= mp->mt_high &&
			    sp->s_regionid >= mp->mt_low ) {
			    	sp->s_color[0] = mp->mt_r;
			    	sp->s_color[1] = mp->mt_g;
			    	sp->s_color[2] = mp->mt_b;
				goto done;
			}
		}

		/*
		 *  There is no region-id-based coloring entry in the
		 *  table, so use the combination-record ("mater"
		 *  command) based color if one was provided. Otherwise,
		 *  use the default wireframe color.
		 *  This is the "new way" of coloring things.
		 */

		/* use wireframe_default_color */
		if (sp->s_dflag)
		  sp->s_cflag = 1;
		/* Be conservative and copy color anyway, to avoid black */
		sp->s_color[0] = sp->s_basecolor[0];
		sp->s_color[1] = sp->s_basecolor[1];
		sp->s_color[2] = sp->s_basecolor[2];
done: ;
	}
	update_views = 1;		/* re-write control list with new colors */
}
@


11.40
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/mater.c,v 11.39 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.39
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d30 5
a34 1
#include "conf.h"
@


11.38
log
@merge of windows-6-0-branch into head
@
text
@d56 2
a57 2
void color_soltab();
void color_putrec(), color_zaprec();
d75 1
a75 5
f_edcolor(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d216 1
a216 2
color_putrec( mp )
register struct mater *mp;
d254 1
a254 2
color_zaprec( mp )
register struct mater *mp;
@


11.37
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.36 2002/08/20 17:08:24 jra Exp $ (BRL)";
d60 1
d62 3
d103 1
a103 1
#if 0
@


11.36
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.34 2001/08/14 18:30:39 bparker Exp $ (BRL)";
@


11.36.10.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.37 2004/02/02 17:39:33 morrison Exp $ (BRL)";
@


11.36.10.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.36.10.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.36.10.3
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a59 1
#ifndef WIN32
a60 3
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif
d99 1
a99 1
#ifdef WIN32
@


11.36.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.36 2002/08/20 17:08:24 jra Exp $ (BRL)";
a59 1
#ifndef WIN32
a60 3
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif
d99 1
a99 1
#ifdef WIN32
@


11.36.4.2
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/mater.c,v 11.36.4.1 2002/09/26 23:04:11 morrison Exp $ (BRL)";
@


11.36.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.36 2002/08/20 17:08:24 jra Exp $ (BRL)";
d56 2
a57 2
void color_soltab(void);
void color_putrec(register struct mater *mp), color_zaprec(register struct mater *mp);
d71 5
a75 1
f_edcolor(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d216 2
a217 1
color_putrec(register struct mater *mp)
d255 2
a256 1
color_zaprec(register struct mater *mp)
@


11.36.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a59 1
#ifndef WIN32
a60 3
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif
d95 1
a95 1
#ifdef WIN32
@


11.35
log
@Converted from K&R to ANSI C - RFH
@
text
@d56 2
a57 2
void color_soltab(void);
void color_putrec(register struct mater *mp), color_zaprec(register struct mater *mp);
d71 5
a75 1
f_edcolor(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d216 2
a217 1
color_putrec(register struct mater *mp)
d255 2
a256 1
color_zaprec(register struct mater *mp)
@


11.34
log
@*- mods to f_edcolor to get things working
   with db5 databases
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.33 2001/06/01 19:23:24 bparker Exp $ (BRL)";
d56 2
a57 2
void color_soltab();
void color_putrec(), color_zaprec();
d71 1
a71 5
f_edcolor(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d212 1
a212 2
color_putrec( mp )
register struct mater *mp;
d250 1
a250 2
color_zaprec( mp )
register struct mater *mp;
@


11.33
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.32 2001/05/04 14:20:46 bparker Exp $ (BRL)";
d83 1
d137 4
a140 4
	if( fgets(line, sizeof (line), fp) == NULL  ||
	    line[0] != hdr[0] )  {
	  Tcl_AppendResult(interp, "Header line damaged, aborting\n", (char *)NULL);
	  return TCL_ERROR;
d143 51
a193 18
	/* Zap all the current records, both in core and on disk */
	while( rt_material_head != MATER_NULL )  {
		zot = rt_material_head;
		rt_material_head = rt_material_head->mt_forw;
		color_zaprec( zot );
		bu_free( (genptr_t)zot, "mater rec" );
	}

	while( fgets(line, sizeof (line), fp) != NULL )  {
		int cnt;
		int low, hi, r, g, b;

		cnt = sscanf( line, "%d %d %d %d %d",
			&low, &hi, &r, &g, &b );
		if( cnt != 5 )  {
		  Tcl_AppendResult(interp, "Discarding ",
				   line, "\n", (char *)NULL);
			continue;
d195 4
a198 9
		BU_GETSTRUCT( mp, mater );
		mp->mt_low = low;
		mp->mt_high = hi;
		mp->mt_r = r;
		mp->mt_g = g;
		mp->mt_b = b;
		mp->mt_daddr = MATER_NO_ADDR;
		rt_insert_color( mp );
		color_putrec( mp );
d200 1
d206 1
a206 1
	return TCL_OK;
@


11.32
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.31 2001/05/02 17:14:01 bparker Exp $ (BRL)";
d256 1
a256 1
	FOR_ALL_SOLIDS( sp, &HeadSolid.l )  {
@


11.31
log
@*- modified commands to use new librt routines
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.30 2001/04/03 19:01:59 bparker Exp $ (BRL)";
a60 75

/*
 *  			F _ P R C O L O R
 */
int
f_prcolor(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	return wdb_prcolor_cmd(wdbp, interp, argc, argv);
}

/*
 *  			F _ C O L O R
 *  
 *  Add a color table entry.
 */
int
f_color(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	register struct mater *newp,*next_mater;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 7 || 7 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help color");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* Delete all color records from the database */
	newp = rt_material_head;
	while( newp != MATER_NULL )
	{
		next_mater = newp->mt_forw;
		color_zaprec( newp );
		newp = next_mater;
	}

	/* construct the new color record */
	BU_GETSTRUCT( newp, mater );
	newp->mt_low = atoi( argv[1] );
	newp->mt_high = atoi( argv[2] );
	newp->mt_r = atoi( argv[3] );
	newp->mt_g = atoi( argv[4] );
	newp->mt_b = atoi( argv[5] );
	newp->mt_daddr = MATER_NO_ADDR;		/* not in database yet */

	/* Insert new color record in the in-memory list */
	rt_insert_color( newp );

	/* Write new color records for all colors in the list */
	newp = rt_material_head;
	while( newp != MATER_NULL )
	{
		next_mater = newp->mt_forw;
		color_putrec( newp );
		newp = next_mater;
	}

	color_soltab();

	return TCL_OK;
}
@


11.30
log
@*- get rid of warnings
*- use mkstemp instead of mktemp
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.29 2001/04/02 18:10:11 jra Exp $ (BRL)";
d72 1
a72 1
	return invoke_db_wrapper(interp, argc, argv);
@


11.29
log
@Lint
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.28 2001/03/23 16:05:52 bparker Exp $ (BRL)";
a61 19
static void
pr_mater( mp )
register struct mater *mp;
{
  char buf[128];
  struct bu_vls vls;

  bu_vls_init(&vls);

  (void)sprintf(buf, "%5d..%d", mp->mt_low, mp->mt_high );
  vls_col_item(&vls, buf);
  (void)sprintf( buf, "%3d,%3d,%3d", mp->mt_r, mp->mt_g, mp->mt_b);
  vls_col_item(&vls, buf);
  vls_col_eol(&vls);

  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
}

d155 1
d173 1
d179 11
@


11.28
log
@*- convert prcolor to use LIBRT's
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/mater.c,v 11.27 2000/10/24 19:05:07 mike Exp $ (BRL)";
d33 5
@


11.27
log
@
Fixed compiler lint, function declarations.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.26 2000/08/19 03:10:47 mike Exp $ (BRL)";
d86 1
a86 21
  register struct mater *mp;

  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help prcolor");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if( rt_material_head == MATER_NULL )  {
    Tcl_AppendResult(interp, "none\n", (char *)NULL);
    return TCL_OK;
  }

  for( mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw )
    pr_mater( mp );

  return TCL_OK;
@


11.26
log
@
const RCSid
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.25 1999/12/28 19:43:11 bparker Exp $ (BRL)";
d49 1
d347 1
a347 1
color_soltab()
@


11.25
log
@*- mktemp requires six X's in the template; the template must also
   be declared as an array of char's
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.24 1999/09/01 18:55:11 bparker Exp $ (BRL)";
@


11.24
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.23 1999/05/10 22:00:44 mike Exp $ (BRL)";
d53 3
a184 1
	static char tempfile[] = "/tmp/MGED.aXXXXX";
d204 4
a207 3
	(void)mktemp(tempfile);
	if( (fp = fopen( tempfile, "w" )) == NULL )  {
		perror(tempfile);
d220 1
a220 1
	if( !editit( tempfile ) )  {
d226 2
a227 2
	if( (fp = fopen( tempfile, "r")) == NULL )  {
	  perror( tempfile );
d267 1
a267 1
	(void)unlink( tempfile );
@


11.23
log
@More conservative handling of color
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.22 1998/10/21 17:04:24 bparker Exp $ (BRL)";
d119 1
a119 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d189 1
a189 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

@


11.22
log
@*- use color scheme variables
*- use "struct solid"'s flags to help determine what color
	to draw in
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.21 1998/06/24 18:34:46 bparker Exp $ (BRL)";
d384 4
a387 6
		else {
		  /* Using a combination-record based color */
		  sp->s_color[0] = sp->s_basecolor[0];
		  sp->s_color[1] = sp->s_basecolor[1];
		  sp->s_color[2] = sp->s_basecolor[2];
		}
@


11.21
log
@*- added comments
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.20 1998/06/24 17:22:14 bparker Exp $ (BRL)";
d353 4
a356 2
		if( sp->s_useBaseColor ) {
		        /* the user specified the color, so use it */
d362 1
d372 1
d376 2
a377 1
		 *  command) based color instead.
d380 10
a389 3
		sp->s_color[0] = sp->s_basecolor[0];
		sp->s_color[1] = sp->s_basecolor[1];
		sp->s_color[2] = sp->s_basecolor[2];
@


11.20
log
@*- modified color_soltab() to handle the explicit color
	specification of a solid (i.e. e -C255/0/255 driver)
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mater.c,v 11.19 1998/05/26 14:25:06 bparker Exp $ (BRL)";
d354 1
@


11.19
log
@*- slight mod to color_soltab()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/mater.c,v 11.18 1997/11/03 15:24:31 bparker Exp $ (BRL)";
a42 1
extern void color_soltab();
d50 1
a344 1
 *  Called by the display manager anytime the color mappings change.
d352 7
a358 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
@


11.18
log
@some clean up
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.17 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d365 1
a365 1
		 *  table, so use the combination-record ("matter"
d374 1
a374 1
	dmaflag = 1;		/* re-write control list with new colors */
@


11.17
log
@mods to run without a database
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.16 1997/05/02 15:07:25 jra Exp bparker $ (BRL)";
a164 3
#if 0
	dmp->dm_colorchange(dmp);
#endif
a270 3
#if 0
	dmp->dm_colorchange(dmp);
#endif
@


11.16
log
@color_zaprec() needed to set d_flags in the directory structure it creates.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.15 1997/05/02 14:56:20 jra Exp $ (BRL)";
d119 3
d194 3
d294 3
d331 3
@


11.15
log
@f_color() needed to set d_flags in the directory entry it creates.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.14 1997/04/24 18:03:58 bparker Exp $ (BRL)";
d329 1
@


11.14
log
@modify calls to Tcl_Eval
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.13 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d300 1
@


11.13
log
@mods so that commands check args internally
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.12 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d85 6
a90 1
    Tcl_Eval(interp, "help prcolor");
d122 6
a127 1
	  Tcl_Eval(interp, "help color");
d194 6
a199 1
	  Tcl_Eval(interp, "help edcolor");
@


11.12
log
@Mods to support MGED's read-only mode.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.11 1996/10/22 21:10:18 bparker Exp jra $ (BRL)";
d84 2
a85 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d87 1
d116 2
a117 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d119 1
d183 2
a184 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d186 1
@


11.11
log
@hacks to use latest libdm
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.10 1996/10/04 15:03:37 bparker Exp $ (BRL)";
d112 2
d176 2
@


11.10
log
@-call vls_col_XXXX instead of col_XXXX
-cast bu_free's 1st argument to genptr_t
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.9 1996/09/30 19:47:18 bparker Exp bparker $ (BRL)";
d146 3
a148 1
	dmp->dmr_colorchange(dmp);
d243 3
a245 1
	dmp->dmr_colorchange(dmp);
@


11.9
log
@call color_soltab before call to dmr_colorchange
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.8 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d57 2
a58 1
	char buf[128];
d60 10
a69 5
	(void)sprintf( buf, "%5d..%d", mp->mt_low, mp->mt_high );
	col_item( buf );
	(void)sprintf( buf, "%3d,%3d,%3d", mp->mt_r, mp->mt_g, mp->mt_b);
	col_item( buf );
	col_eol();
d213 1
a213 1
		bu_free( (char *)zot, "mater rec" );
@


11.8
log
@now using more generalized solid macros
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.7 1996/09/23 18:24:56 bparker Exp bparker $ (BRL)";
d139 1
d233 2
@


11.7
log
@use LIBDM permanently
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.6 1996/09/17 21:20:57 bparker Exp bparker $ (BRL)";
d40 1
a40 1
#include "./solid.h"
d307 1
a307 1
	FOR_ALL_SOLIDS( sp )  {
@


11.6
log
@prepare to use libdm
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.5 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d41 1
a41 1
#include "./dm.h"
a42 1
#ifdef USE_LIBDM
a43 2
#endif

a138 1
#ifdef USE_LIBDM
a139 3
#else
	dmp->dmr_colorchange();
#endif
a231 1
#ifdef USE_LIBDM
a232 3
#else
	dmp->dmr_colorchange();
#endif
@


11.5
log
@now using libbu
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.4 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d43 4
d142 3
d146 1
d239 3
d243 1
@


11.4
log
@convert commands to Tcl
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.3 1996/03/01 19:30:49 bparker Exp bparker $ (BRL)";
d118 1
a118 1
	GETSTRUCT( newp, mater );
d205 1
a205 1
		rt_free( (char *)zot, "mater rec" );
d219 1
a219 1
		GETSTRUCT( mp, mater );
@


11.3
log
@remove unused XMGED stuff
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 11.2 1995/01/17 13:04:51 bparker Exp bparker $ (BRL)";
d69 3
a71 1
f_prcolor( argc, argv )
d75 9
a83 1
	register struct mater *mp;
d85 2
a86 6
	if( rt_material_head == MATER_NULL )  {
		rt_log("none\n");
		return CMD_OK;
	}
	for( mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw )
		pr_mater( mp );
d88 1
a88 1
	return CMD_OK;
d97 3
a99 1
f_color( argc, argv )
d105 3
d140 1
a140 1
	return CMD_OK;
d152 3
a154 1
f_edcolor( argc, argv )
d165 3
d171 1
a171 1
		return CMD_BAD;
d184 2
a185 2
		rt_log("Editor returned bad status.  Aborted\n");
		return CMD_BAD;
d190 2
a191 2
		perror( tempfile );
		return CMD_BAD;
d196 2
a197 2
		rt_log("Header line damaged, aborting\n");
		return CMD_BAD;
d215 2
a216 1
			rt_log("Discarding %s\n", line );
d233 1
a233 1
	return CMD_OK;
@


11.2
log
@merging xmged sources
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/mater.c,v 11.2 95/01/17 11:43:54 bparker Exp $ (BRL)";
d177 1
a177 3
#ifdef XMGED
	if( mged_fgets(line, sizeof (line), fp) == NULL  ||
#else
a178 1
#endif
a191 3
#ifdef XMGED
	while( mged_fgets(line, sizeof (line), fp) != NULL )  {
#else
a192 1
#endif
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 10.7 94/12/27 17:22:34 mike Exp $ (BRL)";
d177 3
d181 1
d195 3
d199 1
@


10.7
log
@Bug 247, changed MaterHead to rt_material_head.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 10.6 94/12/16 19:36:56 gdurf Exp Locker: mike $ (BRL)";
@


10.6
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 10.5 1994/11/01 17:47:14 jra Exp gdurf $ (BRL)";
d48 1
a48 1
extern struct mater *MaterHead;	/* now defined in librt/mater.c */
d75 1
a75 1
	if( MaterHead == MATER_NULL )  {
d79 1
a79 1
	for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )
d98 1
a98 1
	newp = MaterHead;
d119 1
a119 1
	newp = MaterHead;
d159 1
a159 1
	for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )  {
d184 3
a186 3
	while( MaterHead != MATER_NULL )  {
		zot = MaterHead;
		MaterHead = MaterHead->mt_forw;
d289 1
a289 1
		for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )  {
@


10.5
log
@modified f_color to zap old color records.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 10.4 94/08/09 15:22:55 gdurf Exp Locker: jra $ (BRL)";
d76 1
a76 1
		(void)printf("none\n");
d168 1
a168 1
		(void)printf("Editor returned bad status.  Aborted\n");
d179 1
a179 1
		(void)printf("Header line damaged, aborting\n");
d198 1
a198 1
			(void)printf("Discarding %s\n", line );
@


10.4
log
@Added include of conf.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 10.3 1994/06/01 15:16:38 gdurf Exp gdurf $ (BRL)";
d95 1
a95 1
	register struct mater *newp;
d97 10
d114 2
d117 10
a126 1
	color_putrec( newp );			/* write to database */
@


10.3
log
@Converted f_ functions to use new command return codes.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 10.2 1993/04/01 04:43:56 mike Exp gdurf $ (BRL)";
d29 2
@


10.2
log
@Added magic numbers
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 10.1 91/10/12 06:43:48 mike Rel4_0 Locker: mike $ (BRL)";
d66 1
a66 1
void
d75 1
a75 1
		return;
d79 2
d88 1
a88 1
void
d105 2
d117 1
a117 1
void
d132 1
a132 1
		return;
d146 1
a146 1
		return;
d152 1
a152 1
		return;
d157 1
a157 1
		return;
d191 2
@


10.1
log
@Release_4.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 9.3 91/01/12 08:25:58 mike Exp $ (BRL)";
d213 1
d238 1
@


9.3
log
@externs.h
changed to argc/argv
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 9.2 90/12/08 00:31:21 mike Exp $ (BRL)";
@


9.2
log
@Added error checking around calls to db_*() routines
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mater.c,v 9.1 89/05/19 06:03:23 mike Rel3_5 $ (BRL)";
a40 5
extern char	*mktemp();

extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */

d67 3
a69 1
f_prcolor()
d87 3
a89 1
f_color()
d94 5
a98 5
	newp->mt_low = atoi( cmd_args[1] );
	newp->mt_high = atoi( cmd_args[2] );
	newp->mt_r = atoi( cmd_args[3] );
	newp->mt_g = atoi( cmd_args[4] );
	newp->mt_b = atoi( cmd_args[5] );
d114 3
a116 1
f_edcolor()
@


9.1
log
@Release_3.5
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: mater.c,v 8.5 89/04/06 20:40:09 mike Exp $ (BRL)";
d214 1
a214 1
		db_alloc( dbip, &dir, 1 );
d220 1
a220 1
	db_put( dbip, &dir, &rec, 0, 1 );
d239 1
a239 1
	db_delete( dbip, &dir );
@


8.5
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: mater.c,v 8.4 89/03/06 17:35:40 mike Locked $ (BRL)";
@


8.4
log
@ansii
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: mater.c,v 8.3 89/01/18 01:55:54 mike Locked $ (BRL)";
d37 1
@


8.3
log
@Includes changes in how MGED colors the various solids.
Externally, the color selection now matches that used by RT.
Internally, this was accomplished by adding 3 more fields
to the solid table (s_basecolor[], s_color[], s_dmindex),
and eliminating the mt_dm_int value from the region-id-based
material table.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: mater.c,v 8.2 88/12/06 01:28:27 mike Locked $ (BRL)";
d159 1
a159 1
		rt_free( zot, "mater rec" );
@


8.2
log
@Converted to new db_*() routines.
Now use some routines from librt
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/mater.c,v 1.3 88/10/30 00:36:02 mike Exp $ (BRL)";
a63 2
	(void)sprintf( buf, "dm%d", mp->mt_dm_int );
	col_item( buf );
a241 7
static struct mater default_mater = {
	0, 32767,
	DM_RED,
	255, 0, 0,
	MATER_NO_ADDR, 0
};

d259 3
a261 1
				sp->s_materp = (char *)mp;
d265 9
a273 1
		sp->s_materp = (char *)&default_mater;
@


8.1
log
@Release_3.0
@
text
@a11 1
 *	color_addrec	Called by dir_build on startup
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: mater.c,v 7.3 87/11/14 04:45:34 mike Exp $ (BRL)";
d35 1
a36 1
#include "./objdir.h"
a43 1
extern int	read_only;	/* database is read-only */
d52 1
a52 1
void color_addrec(), color_putrec(), color_zaprec();
a85 113
 *  			I N S E R T _ C O L O R
 *
 *  While any additional database records are created and written here,
 *  it is the responsibility of the caller to color_putrec(newp) if needed.
 */
static void
insert_color( newp )
register struct mater *newp;
{
	register struct mater *mp;
	register struct mater *zot;

	if( MaterHead == MATER_NULL || newp->mt_high < MaterHead->mt_low )  {
		/* Insert at head of list */
		newp->mt_forw = MaterHead;
		MaterHead = newp;
		return;
	}
	if( newp->mt_low < MaterHead->mt_low )  {
		/* Insert at head of list, check for redefinition */
		newp->mt_forw = MaterHead;
		MaterHead = newp;
		goto check_overlap;
	}
	for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )  {
		if( mp->mt_low == newp->mt_low  &&
		    mp->mt_high <= newp->mt_high )  {
			(void)printf("dropping overwritten entry:\n");
			newp->mt_forw = mp->mt_forw;
			pr_mater( mp );
			color_zaprec( mp );
			*mp = *newp;		/* struct copy */
			free( newp );
			newp = mp;
			goto check_overlap;
		}
		if( mp->mt_low  < newp->mt_low  &&
		    mp->mt_high > newp->mt_high )  {
			/* New range entirely contained in old range; split */
			(void)printf("Splitting into 3 ranges\n");
			GETSTRUCT( zot, mater );
			*zot = *mp;		/* struct copy */
			zot->mt_daddr = MATER_NO_ADDR;
			/* zot->mt_high = mp->mt_high; */
			zot->mt_low = newp->mt_high+1;
			mp->mt_high = newp->mt_low-1;
			/* mp, newp, zot */
			/* zot->mt_forw = mp->mt_forw; */
			newp->mt_forw = zot;
			mp->mt_forw = newp;
			color_putrec( mp );
			color_putrec( zot );	/* newp put by caller */
			pr_mater( mp );
			pr_mater( newp );
			pr_mater( zot );
			return;
		}
		if( mp->mt_high > newp->mt_low )  {
			/* Overlap to the left: Shorten preceeding entry */
			(void)printf("Shortening lhs range, from:\n");
			pr_mater( mp );
			(void)printf("to:\n");
			mp->mt_high = newp->mt_low-1;
			color_putrec( mp );		/* it was changed */
			pr_mater( mp );
			/* Now append */
			newp->mt_forw = mp->mt_forw;
			mp->mt_forw = newp;
			goto check_overlap;
		}
		if( mp->mt_forw == MATER_NULL ||
		    newp->mt_low < mp->mt_forw->mt_low )  {
			/* Append */
			newp->mt_forw = mp->mt_forw;
			mp->mt_forw = newp;
			goto check_overlap;
		}
	}
	(void)printf("fell out of insert_color loop, append to end\n");
	/* Append at end */
	newp->mt_forw = MATER_NULL;
	mp->mt_forw = newp;
	f_prcolor();
	return;

	/* Check for overlap, ie, redefinition of following colors */
check_overlap:
	while( newp->mt_forw != MATER_NULL &&
	       newp->mt_high >= newp->mt_forw->mt_low )  {
		if( newp->mt_high >= newp->mt_forw->mt_high )  {
			/* Drop this mater struct */
			zot = newp->mt_forw;
			newp->mt_forw = zot->mt_forw;
			(void)printf("dropping overlaping entry:\n");
			pr_mater( zot );
			color_zaprec( zot );
			free( zot );
			continue;
		}
		if( newp->mt_high >= newp->mt_forw->mt_low )  {
			/* Shorten this mater struct, then done */
			(void)printf("Shortening rhs range, from:\n");
			pr_mater( newp->mt_forw );
			(void)printf("to:\n");
			newp->mt_forw->mt_low = newp->mt_high+1;
			color_putrec( newp->mt_forw );
			pr_mater( newp->mt_forw );
			continue;	/* more conservative than returning */
		}
	}
}

/*
d102 1
a102 1
	insert_color( newp );
d161 1
a161 1
		free( zot );
d181 1
a181 1
		insert_color( mp );
a189 22
 *  			C O L O R _ A D D R E C
 *  
 *  Called from dir_build() when initially scanning database.
 */
void
color_addrec( recp, addr )
union record *recp;
long addr;
{
	register struct mater *mp;

	GETSTRUCT( mp, mater );
	mp->mt_low = recp->md.md_low;
	mp->mt_high = recp->md.md_hi;
	mp->mt_r = recp->md.md_r;
	mp->mt_g = recp->md.md_g;
	mp->mt_b = recp->md.md_b;
	mp->mt_daddr = addr;
	insert_color( mp );
}

/*
d202 1
a202 1
	if( read_only )
d215 1
a215 1
		db_alloc( &dir, 1 );
d221 1
a221 1
	db_putrec( &dir, &rec, 0 );
d235 1
a235 1
	if( read_only || mp->mt_daddr == MATER_NO_ADDR )
d240 1
a240 1
	db_delete( &dir );
@


7.3
log
@Changed to use librt declaration of MaterHead
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 7.2 87/11/05 05:06:23 mike Locked $ (BRL)";
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 7.1 87/11/03 00:01:17 mike Rel $ (BRL)";
d52 1
a52 1
struct mater *MaterHead = MATER_NULL;
@


7.1
log
@Release 2.3
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 6.1 87/07/11 08:04:31 mike Rel $ (BRL)";
d32 1
a32 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 5.1 87/06/24 22:21:21 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 4.2 87/02/13 00:08:06 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 4.1 86/12/29 03:22:12 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.11 86/11/14 04:59:39 mike Exp $ (BRL)";
@


1.11
log
@Expunged mt_mater, as the converters won't handle them,
and many more mt_mater bugs remain.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.10 86/11/14 04:33:42 mike Locked $ (BRL)";
@


1.10
log
@Fixed sleepy typo, neatened printf formating.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.9 86/11/14 03:50:58 mike Locked $ (BRL)";
a65 4
	if( mp->mt_handle != NULL )
		col_item( mp->mt_handle );
	else
		col_item( "(none)" );
a215 1
	newp->mt_handle = strdup( cmd_args[6] );
d238 1
a238 2
	char hbuf[128];			/* handle buffer for sscanf */
	static char hdr[] = "LOW\tHIGH\tRed\tGreen\tBlue\tHandle\n";
a250 2
		if( mp->mt_handle != NULL )
			(void)fprintf( fp, "\t%s", mp->mt_handle );
d283 3
a285 3
		cnt = sscanf( line, "%d %d %d %d %d %s",
			&low, &hi, &r, &g, &b, hbuf );
		if( cnt != 5 && cnt != 6 )  {
a294 4
		if( cnt == 6 )
			mp->mt_handle = strdup( hbuf );
		else
			mp->mt_handle = (char *)NULL;
a384 1
	"{default mater}",
@


1.9
log
@Fixed dereferencing null mt_handle pointers.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.8 86/11/10 20:33:05 mike Locked $ (BRL)";
d64 1
a64 1
	(void)sprintf( buf, "%d,%d,%d", mp->mt_r, mp->mt_g, mp->mt_b);
d254 1
a254 1
		(void)fprintf( fp, "%d\t%d\t%d\t%d\t%d\t%s\n",
d258 1
a258 1
			(void)fprintf( fp, "%s", mp->mt_handle );
@


1.8
log
@More careful checking of mt_handle before printing it.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.7 86/08/12 06:50:03 mike Locked $ (BRL)";
d256 4
a259 2
			mp->mt_r, mp->mt_g, mp->mt_b,
			mp->mt_handle );
d288 1
d290 7
a297 2
		(void)sscanf( line, "%d %d %d %d %d %s",
			&low, &hi, &r, &g, &b, hbuf );
d303 4
a306 1
		mp->mt_handle = strdup( hbuf );
@


1.7
log
@Changed #includes for CC -I../h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.6 86/02/17 17:06:12 mike Exp $ (BRL)";
d66 4
a69 1
	col_item( mp->mt_handle );
@


1.6
log
@Removed mt_handle and mt_flags.  This is still an interim version.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.5 85/09/14 05:36:58 mike Exp $ (BRL)";
d33 7
a39 7
#include "../h/vmath.h"
#include "ged.h"
#include "../h/db.h"
#include "../h/mater.h"
#include "objdir.h"
#include "solid.h"
#include "dm.h"
@


1.5
log
@Lint-inspired cleanup.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.4 85/08/07 05:19:15 mike Exp $ (BRL)";
a319 1
	mp->mt_handle = strdup( recp->md.md_material );
a339 1
	rec.md.md_flags = 0;		/* not used yet */
a344 1
	strncpy(rec.md.md_material,mp->mt_handle,sizeof(rec.md.md_material));
@


1.4
log
@Changed to use common ../h/vmath.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.3 85/06/03 16:49:23 mike Exp $ (BRL)";
d235 1
a235 1
	static char tmpfile[] = "/tmp/MGED.aXXXXX";
d243 3
a245 3
	(void)mktemp(tmpfile);
	if( (fp = fopen( tmpfile, "w" )) == NULL )  {
		perror(tmpfile);
d258 1
a258 1
	if( !editit( tmpfile ) )  {
d264 2
a265 2
	if( (fp = fopen( tmpfile, "r")) == NULL )  {
		perror( tmpfile );
d298 1
a298 1
	(void)unlink( tmpfile );
@


1.3
log
@Fixes to allow compilation on System V on the IRIS.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.2 85/03/15 05:06:11 mike Exp $ (BRL)";
d32 2
a33 1
#include "ged_types.h"
a35 1
#include "../h/vmath.h"
@


1.2
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.1 85/03/14 05:03:48 mike Exp $ (BRL)";
d283 1
d286 6
a291 3
			&mp->mt_low, &mp->mt_high,
			&mp->mt_r, &mp->mt_g, &mp->mt_b,
			hbuf );
@


1.1
log
@Initial revision
@
text
@d13 1
d28 1
a28 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d38 2
d45 1
d52 1
a52 1
static struct mater *MaterHead = MATER_NULL;
d67 2
d221 1
d295 1
d334 2
d369 1
a369 1
	if( mp->mt_daddr == MATER_NO_ADDR )
d376 35
@
