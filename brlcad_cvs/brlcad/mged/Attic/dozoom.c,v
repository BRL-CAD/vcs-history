head	11.68;
access;
symbols
	ansi-20040405-merged:11.62.2.3
	postmerge-20040405-ansi:11.65
	premerge-20040404-ansi:11.64
	postmerge-autoconf:11.64
	autoconf-freeze:11.62.10.3
	premerge-autoconf:11.64
	postmerge-20040315-windows:11.64
	premerge-20040315-windows:11.63
	windows-20040315-freeze:11.62.4.2
	autoconf-20031203:11.62
	autoconf-20031202:11.62
	autoconf-branch:11.62.0.10
	phong-branch:11.62.0.8
	photonmap-branch:11.62.0.6
	rel-6-1-DP:11.62
	windows-branch:11.62.0.4
	rel-6-0-2:11.60
	ansi-branch:11.62.0.2
	rel-6-0-1-branch:11.60.0.2
	hartley-6-0-post:11.61
	hartley-6-0-pre:11.60
	rel-6-0-1:11.60
	rel-6-0:11.60
	rel-5-4:11.49.2.1
	offsite-5-3-pre:11.55
	rel-5-3:11.49.2.1
	rel-5-2:11.49
	rel-5-1-branch:11.49.0.2
	rel-5-1:11.49
	rel-5-0:11.46
	rel-5-0-beta:11.46
	rel-4-5:11.39
	ctj-4-5-post:11.30
	ctj-4-5-pre:11.30
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.2;
locks; strict;
comment	@ * @;


11.68
date	2004.05.21.17.47.41;	author morrison;	state dead;
branches;
next	11.67;

11.67
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.66;

11.66
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	11.65;

11.65
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.64;

11.64
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	11.63;

11.63
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.62;

11.62
date	2002.08.20.17.08.22;	author jra;	state Exp;
branches
	11.62.2.1
	11.62.4.1
	11.62.10.1;
next	11.61;

11.61
date	2002.08.15.20.55.33;	author hartley;	state Exp;
branches;
next	11.60;

11.60
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	2001.04.05.19.35.44;	author morrison;	state Exp;
branches;
next	11.57;

11.57
date	2001.03.31.01.57.22;	author morrison;	state Exp;
branches;
next	11.56;

11.56
date	2001.03.19.22.20.01;	author butler;	state Exp;
branches;
next	11.55;

11.55
date	2000.11.09.23.22.37;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	2000.10.24.19.47.15;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.09.07.02.43.21;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.08.19.03.10.44;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.08.17.18.11.59;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	2000.08.09.20.42.32;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	99.12.30.19.15.14;	author jra;	state Exp;
branches
	11.49.2.1;
next	11.48;

11.48
date	99.12.17.16.29.12;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	99.12.01.14.05.48;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	99.01.12.18.00.32;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	98.11.06.22.29.09;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	98.10.21.17.05.46;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	98.06.24.17.24.23;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	98.06.12.19.46.19;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	98.06.11.19.41.41;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	98.03.03.15.01.53;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	98.02.05.22.48.14;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	98.01.16.22.07.41;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	97.11.19.21.48.45;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	97.11.03.15.17.08;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	97.09.08.18.32.19;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	97.09.03.14.16.46;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	97.07.25.20.53.09;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	97.07.17.20.56.11;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	97.06.25.13.38.14;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	97.05.08.14.34.38;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	97.04.09.20.38.59;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	97.03.06.14.04.52;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	97.02.24.21.58.18;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	97.01.30.22.11.27;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	97.01.29.02.51.42;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	97.01.02.19.38.47;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.12.30.22.44.02;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.12.20.22.52.49;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.12.17.22.39.06;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.12.12.22.10.09;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.09.26.20.38.22;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.09.23.18.30.26;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.09.17.21.17.51;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.08.02.18.04.34;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.07.30.21.30.32;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.03.22.18.34.07;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.03.01.19.21.50;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.02.28.21.36.08;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	95.12.27.22.31.11;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.12.02.00.20.38;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	95.11.07.22.58.57;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.06.16.20.28.06;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.36;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.03;	author mike;	state Rel4_4;
branches;
next	10.15;

10.15
date	94.11.05.03.46.55;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.08.09.15.19.11;	author gdurf;	state Exp;
branches;
next	10.13;

10.13
date	94.03.02.20.42.21;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.07.27.21.46.27;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.07.02.17.51.20;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	92.11.23.20.55.39;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.09.03.19.18.57;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.08.25.03.36.30;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.08.24.19.51.26;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.08.21.22.46.16;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.08.21.22.35.57;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.08.19.15.49.33;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.04.18.02.46.11;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.04.18.01.46.42;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.39;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.02.59;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.06.20.39.53;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.18.30;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.43;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.09.17.02.35.12;	author reschly;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.05.38;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.00.33;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.03.46;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.20.23;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.07.24;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.21.22;	author mike;	state Rel1;
branches;
next	2.4;

2.4
date	86.08.12.06.49.20;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.14.05.36.12;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.08.07.05.18.40;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.55.48;	author mike;	state Prod;
branches;
next	1.5;

1.5
date	85.01.17.07.29.02;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.01.57.43;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.20.04.24.01;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.17.05.36.36;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.50.02;	author mike;	state Exp;
branches;
next	;

11.49.2.1
date	2000.11.09.22.54.49;	author bparker;	state Exp;
branches;
next	;

11.62.2.1
date	2002.09.19.18.02.01;	author morrison;	state Exp;
branches;
next	11.62.2.2;

11.62.2.2
date	2004.03.17.21.21.57;	author morrison;	state Exp;
branches;
next	11.62.2.3;

11.62.2.3
date	2004.04.02.16.10.33;	author morrison;	state Exp;
branches;
next	;

11.62.4.1
date	2002.09.26.23.04.10;	author morrison;	state Exp;
branches;
next	11.62.4.2;

11.62.4.2
date	2004.03.11.23.46.34;	author morrison;	state Exp;
branches;
next	;

11.62.10.1
date	2004.02.12.18.34.13;	author erikg;	state Exp;
branches;
next	11.62.10.2;

11.62.10.2
date	2004.03.15.14.07.36;	author erikg;	state Exp;
branches;
next	11.62.10.3;

11.62.10.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Build the control list to invoke the solids
@


11.68
log
@moved to src/mged/
@
text
@/*
 *			D O Z O O M . C
 *
 * Functions -
 *	dozoom		Compute new zoom/rotation perspectives
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/dozoom.c,v 11.67 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./sedit.h"
#include "./mged_dm.h"

mat_t	perspective_mat;
mat_t	incr_change;
mat_t	modelchanges;
mat_t	identity;

/* This is a holding place for the current display managers default wireframe color */
extern unsigned char geometry_default_color[];		/* defined in dodraw.c */

/* Screen coords of actual eye position.  Usually it is at (0,0,+1),
 * but in head-tracking and VR applications, it can move.
 */
#if 0
point_t	eye_pos_scr = { 0, 0, 1 };
#endif

struct solid	FreeSolid;	/* Head of freelist */
struct solid	HeadSolid;	/* Head of solid table */

/*
 *			P E R S P _ M A T
 *
 *  Compute a perspective matrix for a right-handed coordinate system.
 *  Reference: SGI Graphics Reference Appendix C
 *  (Note:  SGI is left-handed, but the fix is done in the Display Manger).
 */
static void
persp_mat(mat_t m, fastf_t fovy, fastf_t aspect, fastf_t near1, fastf_t far1, fastf_t backoff)
{
	mat_t	m2, tran;

	fovy *= 3.1415926535/180.0;

	MAT_IDN( m2 );
	m2[5] = cos(fovy/2.0) / sin(fovy/2.0);
	m2[0] = m2[5]/aspect;
	m2[10] = (far1+near1) / (far1-near1);
	m2[11] = 2*far1*near1 / (far1-near1);	/* This should be negative */

	m2[14] = -1;		/* XXX This should be positive */
	m2[15] = 0;

	/* Move eye to origin, then apply perspective */
	MAT_IDN( tran );
	tran[11] = -backoff;
	bn_mat_mul(m, m2, tran );
}

/*
 *
 *  Create a perspective matrix that transforms the +/1 viewing cube,
 *  with the acutal eye position (not at Z=+1) specified in viewing coords,
 *  into a related space where the eye has been sheared onto the Z axis
 *  and repositioned at Z=(0,0,1), with the same perspective field of view
 *  as before.
 *
 *  The Zbuffer clips off stuff with negative Z values.
 *
 *  pmat = persp * xlate * shear
 */
static void
mike_persp_mat(fastf_t *pmat, const fastf_t *eye)
{
	mat_t	shear;
	mat_t	persp;
	mat_t	xlate;
	mat_t	t1, t2;
	point_t	sheared_eye;
#if 0
	fastf_t	near1, far1;
	point_t	a,b;
#endif

	if( eye[Z] < SMALL )  {
		VPRINT("mike_persp_mat(): ERROR, z<0, eye", eye);
		return;
	}

	/* Shear "eye" to +Z axis */
	MAT_IDN(shear);
	shear[2] = -eye[X]/eye[Z];
	shear[6] = -eye[Y]/eye[Z];

	MAT4X3VEC( sheared_eye, shear, eye );
	if( !NEAR_ZERO(sheared_eye[X], .01) || !NEAR_ZERO(sheared_eye[Y], .01) )  {
		VPRINT("ERROR sheared_eye", sheared_eye);
		return;
	}
#if 0
VPRINT("sheared_eye", sheared_eye);
#endif

	/* Translate along +Z axis to put sheared_eye at (0,0,1). */
	MAT_IDN(xlate);
	/* XXX should I use MAT_DELTAS_VEC_NEG()?  X and Y should be 0 now */
	MAT_DELTAS( xlate, 0, 0, 1-sheared_eye[Z] );

	/* Build perspective matrix inline, substituting fov=2*atan(1,Z) */
	MAT_IDN( persp );
	/* From page 492 of Graphics Gems */
	persp[0] = sheared_eye[Z];	/* scaling: fov aspect term */
	persp[5] = sheared_eye[Z];	/* scaling: determines fov */

	/* From page 158 of Rogers Mathematical Elements */
	/* Z center of projection at Z=+1, r=-1/1 */
	persp[14] = -1;

	bn_mat_mul( t1, xlate, shear );
	bn_mat_mul( t2, persp, t1 );
#if 0
	/* t2 has perspective matrix, with Z ranging from -1 to +1.
	 * In order to control "near" and "far clipping planes,
	 * need to scale and translate in Z.
	 * For example, to get Z effective Z range of -1 to +11,
	 * divide Z by 12/2, then xlate by (6-1).
	 */
	t2[10] /= 6;		/* near+far/2 */
	MAT_DELTAS( xlate, 0, 0, -5 );
#else
	/* Now, move eye from Z=1 to Z=0, for clipping purposes */
	MAT_DELTAS( xlate, 0, 0, -1 );
#endif
	bn_mat_mul( pmat, xlate, t2 );
#if 0
bn_mat_print("pmat",pmat);

	/* Some quick checking */
	VSET( a, 0.0, 0.0, -1.0 );
	MAT4X3PNT( b, pmat, a );
	VPRINT("0,0,-1 ->", b);

	VSET( a, 1.0, 1.0, -1.0 );
	MAT4X3PNT( b, pmat, a );
	VPRINT("1,1,-1 ->", b);

	VSET( a, 0.0, 0.0, 0.0 );
	MAT4X3PNT( b, pmat, a );
	VPRINT("0,0,0 ->", b);

	VSET( a, 1.0, 1.0, 0.0 );
	MAT4X3PNT( b, pmat, a );
	VPRINT("1,1,0 ->", b);

	VSET( a, 1.0, 1.0, 1.0 );
	MAT4X3PNT( b, pmat, a );
	VPRINT("1,1,1 ->", b);

	VSET( a, 0.0, 0.0, 1.0 );
	MAT4X3PNT( b, pmat, a );
	VPRINT("0,0,1 ->", b);
#endif
}

/*
 *  Map "display plate coordinates" (which can just be the screen viewing cube), 
 *  into [-1,+1] coordinates, with perspective.
 *  Per "High Resolution Virtual Reality" by Michael Deering,
 *  Computer Graphics 26, 2, July 1992, pp 195-201.
 *
 *  L is lower left corner of screen, H is upper right corner.
 *  L[Z] is the front (near) clipping plane location.
 *  H[Z] is the back (far) clipping plane location.
 *
 *  This corresponds to the SGI "window()" routine, but taking into account
 *  skew due to the eyepoint being offset parallel to the image plane.
 *
 *  The gist of the algorithm is to translate the display plate to the
 *  view center, shear the eye point to (0,0,1), translate back,
 *  then apply an off-axis perspective projection.
 *
 *  Another (partial) reference is "A comparison of stereoscopic cursors
 *  for the interactive manipulation of B-splines" by Barham & McAllister,
 *  SPIE Vol 1457 Stereoscopic Display & Applications, 1991, pg 19.
 */
static void
deering_persp_mat(fastf_t *m, const fastf_t *l, const fastf_t *h, const fastf_t *eye)
             	  	/* lower left corner of screen */
             	  	/* upper right (high) corner of screen */
             	    	/* eye location.  Traditionally at (0,0,1) */
{
	vect_t	diff;	/* H - L */
	vect_t	sum;	/* H + L */

	VSUB2( diff, h, l );
	VADD2( sum, h, l );

	m[0] = 2 * eye[Z] / diff[X];
	m[1] = 0;
	m[2] = ( sum[X] - 2 * eye[X] ) / diff[X];
	m[3] = -eye[Z] * sum[X] / diff[X];

	m[4] = 0;
	m[5] = 2 * eye[Z] / diff[Y];
	m[6] = ( sum[Y] - 2 * eye[Y] ) / diff[Y];
	m[7] = -eye[Z] * sum[Y] / diff[Y];

	/* Multiplied by -1, to do right-handed Z coords */
	m[8] = 0;
	m[9] = 0;
	m[10] = -( sum[Z] - 2 * eye[Z] ) / diff[Z];
	m[11] = -(-eye[Z] + 2 * h[Z] * eye[Z]) / diff[Z];

	m[12] = 0;
	m[13] = 0;
	m[14] = -1;
	m[15] = eye[Z];

/* XXX May need to flip Z ? (lefthand to righthand?) */
}

static void
drawSolid(register struct solid *sp,
	  short r,
	  short g,
	  short b) {

  if(sp->s_cflag){
    if(!DM_SAME_COLOR(r,g,b,
		      (short)geometry_default_color[0],
		      (short)geometry_default_color[1],
		      (short)geometry_default_color[2])){
      DM_SET_FGCOLOR(dmp,
		     (short)geometry_default_color[0],
		     (short)geometry_default_color[1],
		     (short)geometry_default_color[2],
		     0,
		     sp->s_transparency);
      DM_COPY_COLOR(r,g,b,
		    (short)geometry_default_color[0],
		    (short)geometry_default_color[1],
		    (short)geometry_default_color[2]);
    }
  } else {
    if(!DM_SAME_COLOR(r,g,b,
		      (short)sp->s_color[0],
		      (short)sp->s_color[1],
		      (short)sp->s_color[2])){
      DM_SET_FGCOLOR(dmp,
		     (short)sp->s_color[0],
		     (short)sp->s_color[1],
		     (short)sp->s_color[2],
		     0,
		     sp->s_transparency);
      DM_COPY_COLOR(r,g,b,
		    (short)sp->s_color[0],
		    (short)sp->s_color[1],
		    (short)sp->s_color[2]);
    }
  }
		

#ifdef DO_DISPLAY_LISTS
  if (displaylist && mged_variables->mv_dlist) {
    DM_DRAWDLIST(dmp, sp->s_dlist);
    sp->s_flag = UP;
    ndrawn++;
  } else {
    if (DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
      sp->s_flag = UP;
      ndrawn++;
    }
  }
#else
  if (DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
    sp->s_flag = UP;
    ndrawn++;
  }
#endif
}

/*
 *			D O Z O O M
 *
 *	This routine reviews all of the solids in the solids table,
 * to see if they are visible within the current viewing
 * window.  If they are, the routine computes the scale and appropriate
 * screen position for the object.
 */
void
dozoom(int which_eye)
{
	register struct solid	*sp;
	FAST fastf_t		ratio;
	fastf_t			inv_viewsize;
	mat_t			new;
	matp_t			mat = new;
	int 			linestyle = -1;  /* not dashed */
	short 			r = -1;
	short 			g = -1;
	short 			b = -1;

	/*
	 * The vectorThreshold stuff in libdm may turn the
	 * Tcl-crank causing curr_dm_list to change.
	 */
	struct dm_list *save_dm_list = curr_dm_list;

	ndrawn = 0;
	inv_viewsize = view_state->vs_vop->vo_invSize;

	/*
	 * Draw all solids not involved in an edit.
	 */
	if( view_state->vs_vop->vo_perspective <= 0 && view_state->vs_vop->vo_eye_pos[Z] == 1.0 )  {
		mat = view_state->vs_vop->vo_model2view;
	} else {
		/*
		 *  There are two strategies that could be used:
		 *  1)  Assume a standard head location w.r.t. the
		 *  screen, and fix the perspective angle.
		 *  2)  Based upon the perspective angle, compute
		 *  where the head should be to achieve that field of view.
		 *  Try strategy #2 for now.
		 */
		fastf_t	to_eye_scr;	/* screen space dist to eye */
		fastf_t eye_delta_scr;	/* scr, 1/2 inter-occular dist */
		point_t	l, h, eye;

		/* Determine where eye should be */
		to_eye_scr = 1 / tan(view_state->vs_vop->vo_perspective * bn_degtorad * 0.5);

#define SCR_WIDTH_PHYS	330	/* Assume a 330 mm wide screen */

		eye_delta_scr = mged_variables->mv_eye_sep_dist * 0.5 / SCR_WIDTH_PHYS;

		VSET( l, -1.0, -1.0, -1.0 );
		VSET( h, 1.0, 1.0, 200.0 );
		if(which_eye) {
		  printf("d=%gscr, d=%gmm, delta=%gscr\n", to_eye_scr, to_eye_scr * SCR_WIDTH_PHYS, eye_delta_scr);
		  VPRINT("l", l);
		  VPRINT("h", h);
		}
		VSET( eye, 0.0, 0.0, to_eye_scr );
#if 0
		MAT_IDN(tmat);
		tmat[11] = -1.0;
		bn_mat_mul( tvmat, tmat, view_state->vs_model2view );
#endif
		switch(which_eye)  {
		  case 0:
		    /* Non-stereo case */
		    mat = view_state->vs_vop->vo_model2view;
		    /* XXX hack */
#define HACK 0
#if !HACK
		    if( 1 ) {
#else
		      if( mged_variables->mv_faceplate > 0 )  {
#endif
			if( view_state->vs_vop->vo_eye_pos[Z] == 1.0 )  {
				/* This way works, with reasonable Z-clipping */
				persp_mat( perspective_mat, view_state->vs_vop->vo_perspective,
					(fastf_t)1.0f, (fastf_t)0.01f, (fastf_t)1.0e10f, (fastf_t)1.0f );
			} else {
				/* This way does not have reasonable Z-clipping,
				 * but includes shear, for GDurf's testing.
				 */
			  deering_persp_mat( perspective_mat, l, h, view_state->vs_vop->vo_eye_pos );
			}
		      } else {
			/* New way, should handle all cases */
			mike_persp_mat( perspective_mat, view_state->vs_vop->vo_eye_pos );
		      }
#if HACK
		      bn_mat_print("perspective_mat", perspective_mat);
#endif
		      break;
		case 1:
			/* R */
			mat = view_state->vs_vop->vo_model2view;
			eye[X] = eye_delta_scr;
			deering_persp_mat( perspective_mat, l, h, eye );
			break;
		case 2:
			/* L */
			mat = view_state->vs_vop->vo_model2view;
			eye[X] = -eye_delta_scr;
			deering_persp_mat( perspective_mat, l, h, eye );
			break;
		    }
		    bn_mat_mul( new, perspective_mat, mat );
		    mat = new;
		}

		DM_LOADMATRIX( dmp, mat, which_eye );

		if (dmp->dm_transparency) {
		  /* First, draw opaque stuff */
		  FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		    sp->s_flag = DOWN;		/* Not drawn yet */

		    /* If part of object edit, will be drawn below */
		    if( sp->s_iflag == UP )
		      continue;

		    if (sp->s_transparency < 1.0)
		      continue;

		    /*
		     * The vectorThreshold stuff in libdm may turn the
		     * Tcl-crank causing curr_dm_list to change.
		     */
		    if (curr_dm_list != save_dm_list)
		      curr_dm_list = save_dm_list;

		    if (dmp->dm_boundFlag) {
		      ratio = sp->s_size * inv_viewsize;

		      /*
		       * Check for this object being bigger than 
		       * dmp->dm_bound * the window size, or smaller than a speck.
		       */
		      if (ratio < 0.001)
			continue;
		    }

		    if(linestyle != sp->s_soldash){
		      linestyle = sp->s_soldash;
		      DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
		    }

		    drawSolid(sp, r, g, b);
		  }

		  /* disable write to depth buffer */
		  DM_SET_DEPTH_MASK(dmp, 0);

		  /* Second, draw transparent stuff */
		  FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {

		    /* If part of object edit, will be drawn below */
		    if( sp->s_iflag == UP )
		      continue;

		    /* already drawn above */
		    if (sp->s_transparency == 1.0)
		      continue;

		    /*
		     * The vectorThreshold stuff in libdm may turn the
		     * Tcl-crank causing curr_dm_list to change.
		     */
		    if (curr_dm_list != save_dm_list)
		      curr_dm_list = save_dm_list;

		    if (dmp->dm_boundFlag) {
		      ratio = sp->s_size * inv_viewsize;

		      /*
		       * Check for this object being bigger than 
		       * dmp->dm_bound * the window size, or smaller than a speck.
		       */
		      if (ratio < 0.001)
			continue;
		    }

		    if(linestyle != sp->s_soldash){
		      linestyle = sp->s_soldash;
		      DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
		    }

		    drawSolid(sp, r, g, b);
		  }

		  /* re-enable write of depth buffer */
		  DM_SET_DEPTH_MASK(dmp, 1);
		} else {

		  FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		    sp->s_flag = DOWN;		/* Not drawn yet */
		    /* If part of object edit, will be drawn below */
		    if( sp->s_iflag == UP )
		      continue;

		    /*
		     * The vectorThreshold stuff in libdm may turn the
		     * Tcl-crank causing curr_dm_list to change.
		     */
		    if (curr_dm_list != save_dm_list)
		      curr_dm_list = save_dm_list;

		    if (dmp->dm_boundFlag) {
		      ratio = sp->s_size * inv_viewsize;

		      /*
		       * Check for this object being smaller than a speck.
		       */
		      if (ratio < 0.001)
			continue;
		    }

		    if(linestyle != sp->s_soldash){
		      linestyle = sp->s_soldash;
		      DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
		    }

		    drawSolid(sp, r, g, b);
		  }
		}

		/*
		 * The vectorThreshold stuff in libdm may turn the
		 * Tcl-crank causing curr_dm_list to change.
		 */
		if (curr_dm_list != save_dm_list)
		  curr_dm_list = save_dm_list;

		/* draw predictor vlist */
		if(mged_variables->mv_predictor){
		  DM_SET_FGCOLOR(dmp,
				 color_scheme->cs_predictor[0],
				 color_scheme->cs_predictor[1],
				 color_scheme->cs_predictor[2], 1, 1.0);
		  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&curr_dm_list->dml_p_vlist);
		}

		/*
		 *  Draw all solids involved in editing.
		 *  They may be getting transformed away from the other solids.
		 */
		if( state == ST_VIEW )
		  return;

		if( view_state->vs_vop->vo_perspective <= 0 )  {
		  mat = view_state->vs_model2objview;
		} else {
		  bn_mat_mul( new, perspective_mat, view_state->vs_model2objview );
		  mat = new;
		}
		DM_LOADMATRIX( dmp, mat, which_eye );
		inv_viewsize /= modelchanges[15];
		DM_SET_FGCOLOR(dmp,
			       color_scheme->cs_geo_hl[0],
			       color_scheme->cs_geo_hl[1],
			       color_scheme->cs_geo_hl[2], 1, 1.0);

		FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		  /* Ignore all objects not being edited */
		  if (sp->s_iflag != UP)
		    continue;

		  /*
		   * The vectorThreshold stuff in libdm may turn the
		   * Tcl-crank causing curr_dm_list to change.
		   */
		  if (curr_dm_list != save_dm_list)
		    curr_dm_list = save_dm_list;

		  if (dmp->dm_boundFlag) {
		    ratio = sp->s_size * inv_viewsize;
		    /*
		     * Check for this object being smaller than a speck.
		     */
		    if (ratio < 0.001)
		      continue;
		  }

		  if (linestyle != sp->s_soldash) {
		    linestyle = sp->s_soldash;
		    DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
		  }

#ifdef DO_DISPLAY_LISTS
		  if (displaylist && mged_variables->mv_dlist) {
		    DM_DRAWDLIST(dmp, sp->s_dlist);
		    sp->s_flag = UP;
		    ndrawn++;
		  } else {
		    /* draw in immediate mode */
		    if (DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
		      sp->s_flag = UP;
		      ndrawn++;
		    }
		  }
#else
		  if (DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
		    sp->s_flag = UP;
		    ndrawn++;
		  }
#endif
	}

	/*
	 * The vectorThreshold stuff in libdm may turn the
	 * Tcl-crank causing curr_dm_list to change.
	 */
	if (curr_dm_list != save_dm_list)
		curr_dm_list = save_dm_list;
}

#ifdef DO_DISPLAY_LISTS
/*
 * Create Display List
 */
void
createDList(struct solid *sp)
{
  DM_BEGINDLIST(dmp, sp->s_dlist);
  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist);
  DM_ENDDLIST(dmp);
}

/*
 * Create Display Lists
 */
void
createDLists(struct bu_list *hsp)
{
  register struct solid *sp;

  FOR_ALL_SOLIDS(sp, hsp){
    createDList(sp);
  }
}

/*
 * Create a display list for "sp" for every display manager
 * manager that:
 *		1 - supports display lists
 *		2 - is actively using display lists
 *		3 - has not already been created (i.e. sharing with a
 *			display manager that has already created the display list)
 */
void
createDListALL(struct solid *sp)
{
  struct dm_list *dlp;
  struct dm_list *save_dlp;

  save_dlp = curr_dm_list;

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
    dlp->dml_dlist_state->dl_flag = 1;

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l){
    if(dlp->dml_dmp->dm_displaylist &&
       dlp->dml_mged_variables->mv_dlist){
      if(dlp->dml_dlist_state->dl_flag){
	curr_dm_list = dlp;
	createDList(sp);
      }
    }

    dlp->dml_dirty = 1;
    dlp->dml_dlist_state->dl_flag = 0;
  }

  curr_dm_list = save_dlp;
}

/*
 * Call createDListALL for all solids. See createDListALL above
 * for a description.
 */
void
createDListsAll(struct bu_list *hsp)
{
  struct solid *sp;

  FOR_ALL_SOLIDS(sp, hsp){
    createDListALL(sp);
  }
}

/*
 * Free the range of display lists for all display managers
 * that support display lists and have them activated.
 */
void
freeDListsAll(unsigned int dlist, int range)
{
  struct dm_list *dlp;

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
    dlp->dml_dlist_state->dl_flag = 1;

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l){
    if(dlp->dml_dmp->dm_displaylist &&
       dlp->dml_mged_variables->mv_dlist){
      if(dlp->dml_dlist_state->dl_flag)
	DM_FREEDLISTS(dlp->dml_dmp, dlist, range);
    }

    dlp->dml_dirty = 1;
    dlp->dml_dlist_state->dl_flag = 0;
  }
}
#endif
@


11.67
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/dozoom.c,v 11.66 2004/05/10 15:25:28 morrison Exp $ (BRL)";
@


11.66
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.65 2004/04/05 09:09:11 morrison Exp $ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.65
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a212 1
     		  
d247 60
d364 5
a368 5
if(which_eye) {
printf("d=%gscr, d=%gmm, delta=%gscr\n", to_eye_scr, to_eye_scr * SCR_WIDTH_PHYS, eye_delta_scr);
VPRINT("l", l);
VPRINT("h", h);
}
d376 4
a379 4
		case 0:
			/* Non-stereo case */
			mat = view_state->vs_vop->vo_model2view;
/* XXX hack */
d382 1
a382 1
if( 1 ) {
d384 1
a384 1
if( mged_variables->mv_faceplate > 0 )  {
d394 1
a394 1
				deering_persp_mat( perspective_mat, l, h, view_state->vs_vop->vo_eye_pos );
d396 1
a396 1
} else {
d399 1
a399 1
}
d401 1
a401 1
bn_mat_print("perspective_mat", perspective_mat);
d403 1
a403 1
			break;
d416 3
a418 3
                }
		bn_mat_mul( new, perspective_mat, mat );
		mat = new;
d421 1
a421 1
	DM_LOADMATRIX( dmp, mat, which_eye );
d423 27
a449 4
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		sp->s_flag = DOWN;		/* Not drawn yet */
		/* If part of object edit, will be drawn below */
		if( sp->s_iflag == UP )
d451 1
d453 39
a491 6
		/*
		 * The vectorThreshold stuff in libdm may turn the
		 * Tcl-crank causing curr_dm_list to change.
		 */
		if (curr_dm_list != save_dm_list)
		  curr_dm_list = save_dm_list;
d493 4
a496 2
		if (dmp->dm_boundFlag) {
			ratio = sp->s_size * inv_viewsize;
d498 2
a499 12
			/*
			 * Check for this object being bigger than 
			 * dmp->dm_bound * the window size, or smaller than a speck.
			 */
			if (ratio >= dmp->dm_bound || ratio < 0.001)
				continue;
		}

		if(linestyle != sp->s_soldash){
			linestyle = sp->s_soldash;
			DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
		}
d501 2
a502 14
		if(sp->s_cflag){
			if(!DM_SAME_COLOR(r,g,b,
					  (short)geometry_default_color[0],
					  (short)geometry_default_color[1],
					  (short)geometry_default_color[2])){
				DM_SET_FGCOLOR(dmp,
					       (short)geometry_default_color[0],
					       (short)geometry_default_color[1],
					       (short)geometry_default_color[2], 0);
				DM_COPY_COLOR(r,g,b,
					      (short)geometry_default_color[0],
					      (short)geometry_default_color[1],
					      (short)geometry_default_color[2]);
			}
a503 14
			if(!DM_SAME_COLOR(r,g,b,
					  (short)sp->s_color[0],
					  (short)sp->s_color[1],
					  (short)sp->s_color[2])){
				DM_SET_FGCOLOR(dmp,
					       (short)sp->s_color[0],
					       (short)sp->s_color[1],
					       (short)sp->s_color[2], 0);
				DM_COPY_COLOR(r,g,b,
					      (short)sp->s_color[0],
					      (short)sp->s_color[1],
					      (short)sp->s_color[2]);
			}
		}
d505 22
a526 18
#ifdef DO_DISPLAY_LISTS
		if (displaylist && mged_variables->mv_dlist) {
			DM_DRAWDLIST(dmp, sp->s_dlist);
			sp->s_flag = UP;
			ndrawn++;
		} else {
			if (DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
				sp->s_flag = UP;
				ndrawn++;
			}
		}
#else
		if (DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
			sp->s_flag = UP;
			ndrawn++;
		}
#endif
	}
d528 4
a531 6
	/*
	 * The vectorThreshold stuff in libdm may turn the
	 * Tcl-crank causing curr_dm_list to change.
	 */
	if (curr_dm_list != save_dm_list)
		curr_dm_list = save_dm_list;
d533 3
a535 37
	/* draw predictor vlist */
	if(mged_variables->mv_predictor){
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_predictor[0],
			 color_scheme->cs_predictor[1],
			 color_scheme->cs_predictor[2], 1);
	  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&curr_dm_list->dml_p_vlist);
	}

	/*
	 *  Draw all solids involved in editing.
	 *  They may be getting transformed away from the other solids.
	 */
	if( state == ST_VIEW )
		return;

	if( view_state->vs_vop->vo_perspective <= 0 )  {
		mat = view_state->vs_model2objview;
	} else {
		bn_mat_mul( new, perspective_mat, view_state->vs_model2objview );
		mat = new;
	}
	DM_LOADMATRIX( dmp, mat, which_eye );
	inv_viewsize /= modelchanges[15];
	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_geo_hl[0],
		       color_scheme->cs_geo_hl[1],
		       color_scheme->cs_geo_hl[2], 1);

#if 1
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
#else
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
#endif
		/* Ignore all objects not being edited */
		if (sp->s_iflag != UP)
			continue;
d544 7
a550 8
		if (dmp->dm_boundFlag) {
			ratio = sp->s_size * inv_viewsize;
			/*
			 * Check for this object being bigger than 
			 * dmp->dm_bound * the window size, or smaller than a speck.
			 */
			if (ratio >= dmp->dm_bound || ratio < 0.001)
				continue;
d553 12
a564 3
		if (linestyle != sp->s_soldash) {
			linestyle = sp->s_soldash;
			DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
d566 32
d600 11
a610 11
		if (displaylist && mged_variables->mv_dlist) {
			DM_DRAWDLIST(dmp, sp->s_dlist);
			sp->s_flag = UP;
			ndrawn++;
		} else {
			/* draw in immediate mode */
			if (DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
				sp->s_flag = UP;
				ndrawn++;
			}
		}
d612 4
a615 4
		if (DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
			sp->s_flag = UP;
			ndrawn++;
		}
@


11.64
log
@merge of windows-6-0-branch into head
@
text
@a55 2
/* changed near - near1, far - far1*/

d64 1
a64 3
persp_mat( m, fovy, aspect, near1, far1, backoff )
mat_t	m;
fastf_t	fovy, aspect, near1, far1, backoff;
d82 1
a82 1
	bn_mat_mul( m, m2, tran );
d98 1
a98 3
mike_persp_mat( pmat, eye )
mat_t		pmat;
const point_t	eye;
d212 5
a216 5
deering_persp_mat( m, l, h, eye )
mat_t		m;
const point_t	l;	/* lower left corner of screen */
const point_t	h;	/* upper right (high) corner of screen */
const point_t	eye;	/* eye location.  Traditionally at (0,0,1) */
d257 1
a257 2
dozoom(which_eye)
int	which_eye;
d330 1
a330 1
					1.0, 0.01, 1.0e10, 1.0 );
@


11.63
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.62 2002/08/20 17:08:22 jra Exp $ (BRL)";
d56 2
d66 1
a66 1
persp_mat( m, fovy, aspect, near, far, backoff )
d68 1
a68 1
fastf_t	fovy, aspect, near, far, backoff;
d77 2
a78 2
	m2[10] = (far+near) / (far-near);
	m2[11] = 2*far*near / (far-near);	/* This should be negative */
d112 1
a112 1
	fastf_t	near, far;
@


11.62
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.60 2001/06/05 15:51:41 bparker Exp $ (BRL)";
@


11.62.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.63 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.62.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.62.10.1 2004/02/12 18:34:13 erikg Exp $ (BRL)";
@


11.62.10.3
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a55 2
/* changed near - near1, far - far1*/

d64 1
a64 1
persp_mat( m, fovy, aspect, near1, far1, backoff )
d66 1
a66 1
fastf_t	fovy, aspect, near1, far1, backoff;
d75 2
a76 2
	m2[10] = (far1+near1) / (far1-near1);
	m2[11] = 2*far1*near1 / (far1-near1);	/* This should be negative */
d110 1
a110 1
	fastf_t	near1, far1;
@


11.62.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.62 2002/08/20 17:08:22 jra Exp $ (BRL)";
a55 2
/* changed near - near1, far - far1*/

d64 1
a64 1
persp_mat( m, fovy, aspect, near1, far1, backoff )
d66 1
a66 1
fastf_t	fovy, aspect, near1, far1, backoff;
d75 2
a76 2
	m2[10] = (far1+near1) / (far1-near1);
	m2[11] = 2*far1*near1 / (far1-near1);	/* This should be negative */
d110 1
a110 1
	fastf_t	near1, far1;
@


11.62.4.2
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/dozoom.c,v 11.62.4.1 2002/09/26 23:04:10 morrison Exp $ (BRL)";
@


11.62.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.62 2002/08/20 17:08:22 jra Exp $ (BRL)";
d64 3
a66 1
persp_mat(fastf_t *m, fastf_t fovy, fastf_t aspect, fastf_t near, fastf_t far, fastf_t backoff)
d100 3
a102 1
mike_persp_mat(fastf_t *pmat, const fastf_t *eye)
d216 5
a220 5
deering_persp_mat(fastf_t *m, const fastf_t *l, const fastf_t *h, const fastf_t *eye)
     		  
             	  	/* lower left corner of screen */
             	  	/* upper right (high) corner of screen */
             	    	/* eye location.  Traditionally at (0,0,1) */
d261 2
a262 1
dozoom(int which_eye)
@


11.62.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a55 2
/* changed near - near1, far - far1*/

d64 1
a64 1
persp_mat(mat_t *m, fastf_t fovy, fastf_t aspect, fastf_t near, fastf_t far, fastf_t backoff)
d73 2
a74 2
	m2[10] = (far1+near1) / (far1-near1);
	m2[11] = 2*far1*near1 / (far1-near1);	/* This should be negative */
d106 1
a106 1
	fastf_t	near1, far1;
@


11.62.2.3
log
@conversion to ansi can make mistakes making things pointers that should not be pointers, fix persp_mat()
@
text
@d56 1
d66 1
a66 1
persp_mat(mat_t m, fastf_t fovy, fastf_t aspect, fastf_t near1, fastf_t far1, fastf_t backoff)
d84 1
a84 1
	bn_mat_mul(m, m2, tran );
d332 1
a332 1
					(fastf_t)1.0f, (fastf_t)0.01f, (fastf_t)1.0e10f, (fastf_t)1.0f );
@


11.61
log
@Converted from K&R to ANSI C - RFH
@
text
@d64 3
a66 1
persp_mat(fastf_t *m, fastf_t fovy, fastf_t aspect, fastf_t near, fastf_t far, fastf_t backoff)
d100 3
a102 1
mike_persp_mat(fastf_t *pmat, const fastf_t *eye)
d216 5
a220 5
deering_persp_mat(fastf_t *m, const fastf_t *l, const fastf_t *h, const fastf_t *eye)
     		  
             	  	/* lower left corner of screen */
             	  	/* upper right (high) corner of screen */
             	    	/* eye location.  Traditionally at (0,0,1) */
d261 2
a262 1
dozoom(int which_eye)
@


11.60
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.59 2001/06/01 19:23:24 bparker Exp $ (BRL)";
d64 1
a64 3
persp_mat( m, fovy, aspect, near, far, backoff )
mat_t	m;
fastf_t	fovy, aspect, near, far, backoff;
d98 1
a98 3
mike_persp_mat( pmat, eye )
mat_t		pmat;
const point_t	eye;
d212 5
a216 5
deering_persp_mat( m, l, h, eye )
mat_t		m;
const point_t	l;	/* lower left corner of screen */
const point_t	h;	/* upper right (high) corner of screen */
const point_t	eye;	/* eye location.  Traditionally at (0,0,1) */
d257 1
a257 2
dozoom(which_eye)
int	which_eye;
@


11.59
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.58 2001/04/05 19:35:44 morrison Exp $ (BRL)";
d49 1
d51 1
a280 1
#ifdef MGED_USE_VIEW_OBJ
a281 3
#else
	inv_viewsize = 1 / VIEWSIZE;
#endif
d286 1
a286 2
	if( mged_variables->mv_perspective <= 0 && eye_pos_scr[Z] == 1.0 )  {
#ifdef MGED_USE_VIEW_OBJ
a287 3
#else
		mat = view_state->vs_model2view;
#endif
d302 1
a302 1
		to_eye_scr = 1 / tan(mged_variables->mv_perspective * bn_degtorad * 0.5);
a323 1
#ifdef MGED_USE_VIEW_OBJ
a324 3
#else
			mat = view_state->vs_model2view;
#endif
d332 1
a332 1
			if( eye_pos_scr[Z] == 1.0 )  {
d334 1
a334 1
				persp_mat( perspective_mat, mged_variables->mv_perspective,
d340 1
a340 1
				deering_persp_mat( perspective_mat, l, h, eye_pos_scr );
d344 1
a344 1
			mike_persp_mat( perspective_mat, eye_pos_scr );
a351 1
#ifdef MGED_USE_VIEW_OBJ
a352 3
#else
			mat = view_state->vs_model2view;
#endif
a357 1
#ifdef MGED_USE_VIEW_OBJ
a358 3
#else
			mat = view_state->vs_model2view;
#endif
a368 1
#if 1
a369 3
#else
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
#endif
d470 1
a470 1
	if( mged_variables->mv_perspective <= 0 )  {
@


11.58
log
@updated SIGNED to signed
updated CONST to const
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.57 2001/03/31 01:57:22 morrison Exp $ (BRL)";
d279 3
d283 1
d289 3
d293 1
d330 3
d334 1
d362 3
d366 1
d372 3
d376 1
d387 3
d391 1
d505 3
d509 1
d580 1
a580 1
createDLists(struct solid *hsp)
d584 1
a584 1
  FOR_ALL_SOLIDS(sp, &hsp->l){
d629 1
a629 1
createDListsAll(struct solid *hsp)
d633 1
a633 1
  FOR_ALL_SOLIDS(sp, &hsp->l){
@


11.57
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.56 2001/03/19 22:20:01 butler Exp $ (BRL)";
d100 1
a100 1
CONST point_t	eye;
d216 3
a218 3
CONST point_t	l;	/* lower left corner of screen */
CONST point_t	h;	/* upper right (high) corner of screen */
CONST point_t	eye;	/* eye location.  Traditionally at (0,0,1) */
@


11.56
log
@patches to merge 5.3 into 6.0
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/dozoom.c,v 11.55 2000/11/09 23:22:37 bparker Exp $ (BRL)";
d70 1
a70 1
	bn_mat_idn( m2 );
d80 1
a80 1
	bn_mat_idn( tran );
d118 1
a118 1
	bn_mat_idn(shear);
d132 1
a132 1
	bn_mat_idn(xlate);
d137 1
a137 1
	bn_mat_idn( persp );
d315 1
a315 1
		bn_mat_idn(tmat);
@


11.55
log
@The vectorThreshold stuff in libdm may turn the
Tcl-crank causing curr_dm_list to change. Made
mods to dozoom to restore curr_dm_list.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.54 2000/10/24 19:47:15 mike Exp $ (BRL)";
a494 1

@


11.54
log
@
Possible uninit.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.53 2000/09/07 02:43:21 mike Exp $ (BRL)";
d272 6
d373 7
d445 7
d486 7
d528 7
@


11.53
log
@
More externs to ged.h to silence lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.52 2000/08/19 03:10:44 mike Exp $ (BRL)";
d266 1
a266 1
	matp_t			mat;
@


11.52
log
@
const RCSid
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.51 2000/08/17 18:11:59 bparker Exp $ (BRL)";
d508 1
a508 2
createDList(sp)
struct solid *sp;
d519 1
a519 2
createDLists(hsp)
struct solid *hsp;
d537 1
a537 2
createDListALL(sp)
struct solid *sp;
d568 1
a568 2
createDListsAll(hsp)
struct solid *hsp;
d582 1
a582 3
freeDListsAll(dlist, range)
unsigned int dlist;
int range;
@


11.51
log
@Move vector counting code to LIBDM
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.50 2000/08/09 20:42:32 bparker Exp $ (BRL)";
@


11.50
log
@When nvectors exceeds vectorThreshold
reset nvectors and handle Tcl events.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.49 1999/12/30 19:15:14 jra Exp $ (BRL)";
a41 1
int	vectorThreshold = 1000;
a270 1
	int 			nvectors = 0;
a429 7
		nvectors += ((struct bn_vlist *)&sp->s_vlist)->nused;
		if (nvectors >= vectorThreshold) {
			nvectors = 0;

			/* Handle events in the queue */
			while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
		}
a499 7
		nvectors += ((struct bn_vlist *)&sp->s_vlist)->nused;
		if (nvectors >= vectorThreshold) {
			nvectors = 0;

			/* Handle events in the queue */
			while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
		}
@


11.49
log
@Eliminated some unused variables
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.48 1999/12/17 16:29:12 bparker Exp $ (BRL)";
d42 1
d263 10
a272 9
	register struct solid *sp;
	FAST fastf_t ratio;
	fastf_t		inv_viewsize;
	mat_t		new;
	matp_t		mat;
	int linestyle = -1;  /* not dashed */
	short r = -1;
	short g = -1;
	short b = -1;
d364 50
a413 50
	  sp->s_flag = DOWN;		/* Not drawn yet */
	  /* If part of object edit, will be drawn below */
	  if( sp->s_iflag == UP )
	    continue;

	  if (dmp->dm_boundFlag) {
	    ratio = sp->s_size * inv_viewsize;

	    /*
	     * Check for this object being bigger than 
	     * dmp->dm_bound * the window size, or smaller than a speck.
	     */
	    if (ratio >= dmp->dm_bound || ratio < 0.001)
	      continue;
	  }

	  if(linestyle != sp->s_soldash){
	    linestyle = sp->s_soldash;
	    DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
	  }

	  if(sp->s_cflag){
	    if(!DM_SAME_COLOR(r,g,b,
			      (short)geometry_default_color[0],
			      (short)geometry_default_color[1],
			      (short)geometry_default_color[2])){
	      DM_SET_FGCOLOR(dmp,
			     (short)geometry_default_color[0],
			     (short)geometry_default_color[1],
			     (short)geometry_default_color[2], 0);
	      DM_COPY_COLOR(r,g,b,
			    (short)geometry_default_color[0],
			    (short)geometry_default_color[1],
			    (short)geometry_default_color[2]);
	    }
	  } else {
	    if(!DM_SAME_COLOR(r,g,b,
			      (short)sp->s_color[0],
			      (short)sp->s_color[1],
			      (short)sp->s_color[2])){
	      DM_SET_FGCOLOR(dmp,
			     (short)sp->s_color[0],
			     (short)sp->s_color[1],
			     (short)sp->s_color[2], 0);
	      DM_COPY_COLOR(r,g,b,
			    (short)sp->s_color[0],
			    (short)sp->s_color[1],
			    (short)sp->s_color[2]);
	    }
	  }
d416 10
a425 10
	  if(displaylist && mged_variables->mv_dlist){
	    DM_DRAWDLIST(dmp, sp->s_dlist);
	    sp->s_flag = UP;
	    ndrawn++;
	  }else{
	    if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK){
	      sp->s_flag = UP;
	      ndrawn++;
	    }
	  }
d427 4
a430 4
	  if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK) {
	    sp->s_flag = UP;
	    ndrawn++;
	  }
d432 7
d471 19
a489 19
	  /* Ignore all objects not being edited */
	  if( sp->s_iflag != UP )
	    continue;

	  if (dmp->dm_boundFlag) {
	    ratio = sp->s_size * inv_viewsize;

	    /*
	     * Check for this object being bigger than 
	     * dmp->dm_bound * the window size, or smaller than a speck.
	     */
	    if( ratio >= dmp->dm_bound || ratio < 0.001 )
	      continue;
	  }

	  if(linestyle != sp->s_soldash){
	    linestyle = sp->s_soldash;
	    DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
	  }
d492 11
a502 11
	  if(displaylist && mged_variables->mv_dlist){
	    DM_DRAWDLIST(dmp, sp->s_dlist);
	    sp->s_flag = UP;
	    ndrawn++;
	  }else{
	    /* draw in immediate mode */
	    if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK){
	      sp->s_flag = UP;
	      ndrawn++;
	    }
	  }
d504 4
a507 4
	  if( DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK){
	    sp->s_flag = UP;
	    ndrawn++;
	  }
d509 7
@


11.49.2.1
log
@Mods to dozoom to restore curr_dm_list when
libdm's vectorThreshold code changes it
(i.e. libdm turns the Tcl-crank if the number
of vectors drawn exceeds some threshold).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.49 1999/12/30 19:15:14 jra Exp $ (BRL)";
a271 6
	/*
	 * The vectorThreshold stuff in libdm may turn the
	 * Tcl-crank causing curr_dm_list to change.
	 */
	struct dm_list *save_dm_list = curr_dm_list;

a366 7
	  /*
	   * The vectorThreshold stuff in libdm may turn the
	   * Tcl-crank causing curr_dm_list to change.
	   */
	  if (curr_dm_list != save_dm_list)
		  curr_dm_list = save_dm_list;

a431 7
	/*
	 * The vectorThreshold stuff in libdm may turn the
	 * Tcl-crank causing curr_dm_list to change.
	 */
	if (curr_dm_list != save_dm_list)
		curr_dm_list = save_dm_list;

a465 7
	  /*
	   * The vectorThreshold stuff in libdm may turn the
	   * Tcl-crank causing curr_dm_list to change.
	   */
	  if (curr_dm_list != save_dm_list)
		  curr_dm_list = save_dm_list;

a500 7

	/*
	 * The vectorThreshold stuff in libdm may turn the
	 * Tcl-crank causing curr_dm_list to change.
	 */
	if (curr_dm_list != save_dm_list)
		curr_dm_list = save_dm_list;
@


11.48
log
@*- the signature to DM_DRAW_VLIST changed
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.47 1999/12/01 14:05:48 bparker Exp $ (BRL)";
a264 1
	mat_t		tmat, tvmat;
@


11.47
log
@*- have dozoom() look at dmp->dm_boundFlag and
   dmp->dm_bound to determine whether or not to draw vectors
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.46 1999/01/12 18:00:32 bparker Exp $ (BRL)";
d420 1
a420 1
	    if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->mv_perspective ) == TCL_OK){
d426 1
a426 1
	  if(DM_DRAW_VLIST( dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->mv_perspective ) == TCL_OK) {
d439 1
a439 1
	  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&curr_dm_list->dml_p_vlist, mged_variables->mv_perspective);
d490 1
a490 1
	    if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->mv_perspective) == TCL_OK){
d496 1
a496 1
	  if( DM_DRAW_VLIST( dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->mv_perspective ) == TCL_OK){
d513 1
a513 1
  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->mv_perspective);
@


11.46
log
@*- code to support sharing display lists
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.45 1998/11/06 22:29:09 bparker Exp $ (BRL)";
d254 1
a254 1
 * to see if they  visible within the current viewing
d368 2
a369 1
	  ratio = sp->s_size * inv_viewsize;
d371 7
a377 6
	  /*
	   * Check for this object being bigger than 
	   * dmp->dm_bound * the window size, or smaller than a speck.
	   */
	  if( ratio >= dmp->dm_bound || ratio < 0.001 )
	    continue;
d467 2
a468 1
	  ratio = sp->s_size * inv_viewsize;
d470 7
a476 6
	  /*
	   * Check for this object being bigger than 
	   * dmp->dm_bound * the window size, or smaller than a speck.
	   */
	  if( ratio >= dmp->dm_bound || ratio < 0.001 )
	    continue;
@


11.45
log
@*- use new data structures
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.44 1998/10/21 17:05:46 bparker Exp $ (BRL)";
a413 3
#ifdef DO_SINGLE_DISPLAY_LIST
	    /* don't draw anything here --- just update variables */
#else
a414 1
#endif
a430 7
#ifdef DO_SINGLE_DISPLAY_LIST
	if(displaylist && mged_variables->mv_dlist){
	  /* draw single display list containing all solids */
	  DM_DRAWDLIST(dmp, 1);
	}
#endif

a479 7
#ifdef DO_SINGLE_DISPLAY_LIST
	  /* draw in immediate mode */
	  if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->mv_perspective) == TCL_OK){
	    sp->s_flag = UP;
	    ndrawn++;
	  }
#else
a490 1
#endif
a500 1
#ifdef DO_SINGLE_DISPLAY_LIST
d505 13
a517 1
createDList(hsp)
d521 20
a540 4
  int linestyle = -1;  /* not dashed */
  short r = -1;
  short g = -1;
  short b = -1;
d542 1
a542 1
  DM_BEGINDLIST(dmp, 1);
d544 2
a545 5
  FOR_ALL_SOLIDS(sp, &hsp->l){
    if(linestyle != sp->s_soldash){
      linestyle = sp->s_soldash;
      DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, linestyle);
    }
d547 7
a553 12
    if(!DM_SAME_COLOR(r,g,b,
		      (short)sp->s_color[0],
		      (short)sp->s_color[1],
		      (short)sp->s_color[2])){
      DM_SET_FGCOLOR(dmp,
		       (short)sp->s_color[0],
		       (short)sp->s_color[1],
		       (short)sp->s_color[2], 0);
      DM_COPY_COLOR(r,g,b,
		    (short)sp->s_color[0],
		    (short)sp->s_color[1],
		    (short)sp->s_color[2]);
d556 2
a557 1
    DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->mv_perspective);
d560 1
a560 1
  DM_ENDDLIST(dmp);
d562 1
a562 1
#else
d564 2
a565 1
 * Create Display List
d568 2
a569 2
createDList(sp)
struct solid *sp;
d571 5
a575 3
  DM_BEGINDLIST(dmp, sp->s_dlist);
  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->mv_perspective);
  DM_ENDDLIST(dmp);
d579 2
a580 1
 * Create Display Lists
d583 3
a585 2
createDLists(hsp)
struct solid *hsp;
d587 11
a597 1
  register struct solid *sp;
d599 2
a600 2
  FOR_ALL_SOLIDS(sp, &hsp->l){
    createDList(sp);
a602 1
#endif
@


11.44
log
@*- use color scheme variables
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.43 1998/06/24 17:24:23 bparker Exp $ (BRL)";
d279 2
a280 2
	if( mged_variables->perspective <= 0 && eye_pos_scr[Z] == 1.0 )  {
		mat = model2view;
d295 1
a295 1
		to_eye_scr = 1 / tan(mged_variables->perspective * bn_degtorad * 0.5);
d299 1
a299 1
		eye_delta_scr = mged_variables->eye_sep_dist * 0.5 / SCR_WIDTH_PHYS;
d312 1
a312 1
		bn_mat_mul( tvmat, tmat, model2view );
d317 1
a317 1
			mat = model2view;
d323 1
a323 1
if( mged_variables->faceplate > 0 )  {
d327 1
a327 1
				persp_mat( perspective_mat, mged_variables->perspective,
d345 1
a345 1
			mat = model2view;
d351 1
a351 1
			mat = model2view;
d379 1
a379 1
	    DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, linestyle);
d413 1
a413 1
	  if(displaylist && mged_variables->dlist){
d422 1
a422 1
	    if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->perspective ) == TCL_OK){
d428 1
a428 1
	  if(DM_DRAW_VLIST( dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->perspective ) == TCL_OK) {
d436 1
a436 1
	if(displaylist && mged_variables->dlist){
d443 1
a443 1
	if(mged_variables->predictor){
d445 4
a448 4
			 color_scheme->predictor[0],
			 color_scheme->predictor[1],
			 color_scheme->predictor[2], 1);
	  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&curr_dm_list->p_vlist, mged_variables->perspective);
d458 2
a459 2
	if( mged_variables->perspective <= 0 )  {
		mat = model2objview;
d461 1
a461 1
		bn_mat_mul( new, perspective_mat, model2objview );
d467 3
a469 3
		       color_scheme->geo_hl[0],
		       color_scheme->geo_hl[1],
		       color_scheme->geo_hl[2], 1);
d487 1
a487 1
	    DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, linestyle);
d493 1
a493 1
	  if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->perspective) == TCL_OK){
d498 1
a498 1
	  if(displaylist && mged_variables->dlist){
d504 1
a504 1
	    if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->perspective) == TCL_OK){
d511 1
a511 1
	  if( DM_DRAW_VLIST( dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->perspective ) == TCL_OK){
d539 1
a539 1
      DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, linestyle);
d556 1
a556 1
    DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->perspective);
d570 1
a570 1
  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist, mged_variables->perspective);
@


11.43
log
@*- modified dozoom() to use wireframe_highlight_color[] when
	drawing highlighted solids
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dozoom.c,v 11.42 1998/06/12 19:46:19 bparker Exp $ (BRL)";
d43 2
a44 1
int wireframe_highlight_color[] = { 255, 255, 255 };
d364 1
a364 1
	  /* If part of object rotation, will be drawn below */
d382 20
a401 5
	  if(!DM_SAME_COLOR(r,g,b,
			    (short)sp->s_color[0],
			    (short)sp->s_color[1],
			    (short)sp->s_color[2])){
	    DM_SET_FGCOLOR(dmp,
d405 5
a409 4
	    DM_COPY_COLOR(r,g,b,
			  (short)sp->s_color[0],
			  (short)sp->s_color[1],
			  (short)sp->s_color[2]);
d411 1
d444 4
a447 1
	  DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d467 3
a469 4
		       wireframe_highlight_color[0],
		       wireframe_highlight_color[1],
		       wireframe_highlight_color[2],
		       1);
d472 1
a472 1
	  /* Ignore all objects not being rotated */
@


11.42
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/dozoom.c,v 11.41 1998/06/11 19:41:41 bparker Exp $ (BRL)";
d43 2
d445 5
a449 1
	DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
@


11.41
log
@*- using floating point literals to initialize floats
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/dozoom.c,v 11.40 1998/03/03 15:01:53 jra Exp $ (BRL)";
d383 1
a383 1
	    DM_SET_COLOR(dmp,
d424 1
a424 1
	  DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d443 1
a443 1
	DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d520 1
a520 1
      DM_SET_COLOR(dmp,
@


11.40
log
@Added perspective to calls tp DM_DRAW_VLIST.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.39 1998/02/05 22:48:14 bparker Exp jra $ (BRL)";
d163 1
a163 1
	VSET( a, 0, 0, -1 );
d167 1
a167 1
	VSET( a, 1, 1, -1 );
d171 1
a171 1
	VSET( a, 0, 0, 0 );
d175 1
a175 1
	VSET( a, 1, 1, 0 );
d179 1
a179 1
	VSET( a, 1, 1, 1 );
d183 1
a183 1
	VSET( a, 0, 0, 1 );
d298 2
a299 2
		VSET( l, -1, -1, -1 );
		VSET( h, 1, 1, 200.0 );
d305 1
a305 1
		VSET( eye, 0, 0, to_eye_scr );
d308 1
a308 1
		tmat[11] = -1;
@


11.39
log
@*- no longer calling draw_axes from dozoom()
*- rewrote draw_axes to draw directly to the screen (i.e. not using vlists now)
	and moved it to axes.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.38 1998/01/16 22:07:41 bparker Exp bparker $ (BRL)";
d402 1
a402 1
	    if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK){
d408 1
a408 1
	  if(DM_DRAW_VLIST( dmp, (struct rt_vlist *)&sp->s_vlist ) == TCL_OK) {
d425 1
a425 1
	  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&curr_dm_list->p_vlist);
d467 1
a467 1
	  if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK){
d478 1
a478 1
	    if(DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist) == TCL_OK){
d485 1
a485 1
	  if( DM_DRAW_VLIST( dmp, (struct rt_vlist *)&sp->s_vlist ) == TCL_OK){
d530 1
a530 1
    DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist);
d544 1
a544 1
  DM_DRAW_VLIST(dmp, (struct rt_vlist *)&sp->s_vlist);
@


11.38
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.37 1997/11/19 21:48:45 bparker Exp bparker $ (BRL)";
a37 8
#define M_AXES 0
#define V_AXES 1
#define E_AXES 2

extern point_t e_axes_pos;
extern point_t curr_e_axes_pos;
static void draw_axes();

a427 6
	if(mged_variables->m_axes)
	  draw_axes(M_AXES);  /* draw world view axis */

	if(mged_variables->v_axes)
	  draw_axes(V_AXES);  /* draw view axis */

a490 3

  if(mged_variables->e_axes)
    draw_axes(E_AXES); /* draw edit axis */
a562 223

/*
 * Draw view, edit or world axes.
 */
static void
draw_axes(axes)
int axes;
{
  short r, g, b;
  short index;
  struct rt_vlist h_vlist;
  struct rt_vlist vlist;
  int i, j;
  double ox, oy;
  point_t a1, a2;
  point_t m1, m2;
  point_t m3, m4;
  point_t r_m3, r_m4;
  point_t v1, v2;
  mat_t mr_mat;   /* model rotations */
  static char *labels[] = {"X", "Y", "Z"};

  BU_LIST_INIT(&h_vlist.l);
  BU_LIST_APPEND(&h_vlist.l, &vlist.l);

  bn_mat_idn(mr_mat);
  DM_LOADMATRIX(dmp, mr_mat, 0);

  if(axes_color_hook)
    (*axes_color_hook)(axes, &r, &g, &b, &index);
  else{/* use default color */
    switch(axes){
    case E_AXES:
      r = DM_WHITE_R;
      g = DM_WHITE_G;
      b = DM_WHITE_B;
      index = 1;
      break;
    case M_AXES:
      r = 150;
      g = 230;
      b = 150;
      index = 1;
      break;
    case V_AXES:
    default:
      r = 150;
      g = 150;
      b = 230;
      index = 1;
      break;
    }
  }

  if(axes == E_AXES)
    vlist.nused = 12;
  else
    vlist.nused = 6;

  /* set the vertex label color */
  DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);

  /* load vlist with axes */
  for(i = 0; i < 3; ++i){

    for(j = 0; j < 3; ++j){
      if(i == j){
	if(axes == V_AXES){
	  a1[j] = -0.125;
	  a2[j] = 0.125;
	}else{
	  a1[j] = -0.25;
	  a2[j] = 0.25;
	}
      }else{
	a1[j] = 0.0;
	a2[j] = 0.0;
      }
    }

    if(axes == M_AXES){ /* model axes */
      m1[X] = Viewscale*a1[X];
      m1[Y] = Viewscale*a1[Y];
      m1[Z] = Viewscale*a1[Z];
      m2[X] = Viewscale*a2[X];
      m2[Y] = Viewscale*a2[Y];
      m2[Z] = Viewscale*a2[Z];
    }else if(axes == V_AXES){  /* create view axes */
      /* build axes in view coodinates */

      /* apply rotations */
      MAT4X3PNT(v1, Viewrot, a1);
      MAT4X3PNT(v2, Viewrot, a2);

      /* possibly translate */
      switch(mged_variables->v_axes_pos){
      case 1:     /* lower left */
	ox = -0.8 / dmp->dm_aspect;
	oy = -0.8;
	break;
      case 2:     /* upper left */
	ox = -0.8 / dmp->dm_aspect;
	oy = 0.8;
	break;
      case 3:     /* upper right */
	ox = 0.8 / dmp->dm_aspect;
	oy = 0.8;
	break;
      case 4:     /* lower right */
	ox = 0.8 / dmp->dm_aspect;
	oy = -0.8;
	break;
      default:    /* center */
	ox = 0;
	oy = 0;
	break;
      }

      v1[X] += ox;
      v1[Y] += oy;
      v2[X] += ox;
      v2[Y] += oy;

      /* convert view to model coordinates */
      MAT4X3PNT(m1, view2model, v1);
      MAT4X3PNT(m2, view2model, v2);
    }else{  /* create edit axes */
      /* build edit axes in model coordinates */
      if(state == ST_S_EDIT){
	/* apply rotations */
	MAT4X3PNT(m1, acc_rot_sol, a1);
	MAT4X3PNT(m2, acc_rot_sol, a2);

	/* apply scale and translations */
	m1[X] = Viewscale*m1[X] + curr_e_axes_pos[X];
	m1[Y] = Viewscale*m1[Y] + curr_e_axes_pos[Y];
	m1[Z] = Viewscale*m1[Z] + curr_e_axes_pos[Z];
	m2[X] = Viewscale*m2[X] + curr_e_axes_pos[X];
	m2[Y] = Viewscale*m2[Y] + curr_e_axes_pos[Y];
	m2[Z] = Viewscale*m2[Z] + curr_e_axes_pos[Z];
	m3[X] = Viewscale*a1[X] + e_axes_pos[X];
	m3[Y] = Viewscale*a1[Y] + e_axes_pos[Y];
	m3[Z] = Viewscale*a1[Z] + e_axes_pos[Z];
	m4[X] = Viewscale*a2[X] + e_axes_pos[X];
	m4[Y] = Viewscale*a2[Y] + e_axes_pos[Y];
	m4[Z] = Viewscale*a2[Z] + e_axes_pos[Z];
      }else if(state == ST_O_EDIT){
	point_t delta1, delta2;
	point_t point1, point2;

	VSCALE(a1, a1, Viewscale);
	VSCALE(a2, a2, Viewscale);

	MAT4X3PNT(delta1, es_mat, es_keypoint);
	MAT4X3PNT(delta2, modelchanges, delta1);

	VADD2(m3, delta1, a1);
	VADD2(m4, delta1, a2);

	MAT4X3PNT(point1, acc_rot_sol, a1);
	MAT4X3PNT(point2, acc_rot_sol, a2);
	VADD2(m1, delta2, point1);
	VADD2(m2, delta2, point2);
      }else
	return;
    }

    /* load axes */
    if(axes == E_AXES){
      VMOVE(vlist.pt[i*4], m1);
      vlist.cmd[i*4] = RT_VLIST_LINE_MOVE;
      VMOVE(vlist.pt[i*4 + 1], m2);
      vlist.cmd[i*4 + 1] = RT_VLIST_LINE_DRAW;

      VMOVE(vlist.pt[i*4 + 2], m3);
      vlist.cmd[i*4 + 2] = RT_VLIST_LINE_MOVE;
      VMOVE(vlist.pt[i*4 + 3], m4);
      vlist.cmd[i*4 + 3] = RT_VLIST_LINE_DRAW;

      /* convert point m4 from model to view space */
      MAT4X3PNT(v2, model2view, m4);

#ifdef DM_X
      /* label axes */
      if(dmp->dm_type == DM_TYPE_X)
	DM_DRAW_STRING_2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
			     ((int)(2048.0 * v2[Y])) + 15, 1, 1);
      else
#endif
	DM_DRAW_STRING_2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
			     ((int)(2048.0 * v2[Y])) + 15, 1, 0);
    }else{
      VMOVE(vlist.pt[i*2], m1);
      vlist.cmd[i*2] = RT_VLIST_LINE_MOVE;
      VMOVE(vlist.pt[i*2 + 1], m2);
      vlist.cmd[i*2 + 1] = RT_VLIST_LINE_DRAW;
    }

    /* convert point m2 from model to view space */
    MAT4X3PNT(v2, model2view, m2);

#ifdef DM_X
    /* label axes */
    if(dmp->dm_type == DM_TYPE_X)
      DM_DRAW_STRING_2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
			   ((int)(2048.0 * v2[Y])) + 15, 1, 1);
    else
#endif
      DM_DRAW_STRING_2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
			   ((int)(2048.0 * v2[Y])) + 15, 1, 0);
  }

  DM_LOADMATRIX(dmp, model2view, 0);

  /* draw axes */
  DM_SET_COLOR(dmp, r, g, b, 1);
#if 1
  DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
#else
  DM_SET_LINE_ATTR(dmp, 1, 0);  /* linewidth - 1, not dashed */
#endif
  DM_DRAW_VLIST(dmp, &h_vlist);
}
@


11.37
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.36 1997/11/03 15:17:08 bparker Exp bparker $ (BRL)";
d360 1
a360 1
		}
d363 1
a363 1
	}
@


11.36
log
@use LIBDM macros
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.35 1997/09/08 18:32:19 bparker Exp bparker $ (BRL)";
a36 4

#ifdef DM_X
extern int X_drawString2D();
#endif
@


11.35
log
@*- mged_variables is now a pointer
*- add code to dozoom to draw the predictor vlist
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.34 1997/09/03 14:16:46 bparker Exp bparker $ (BRL)";
a49 5
#if 0
void createDList();
void createDLists();
#endif

d369 1
a369 1
	dmp->dm_newrot( dmp, mat, which_eye );
d388 1
a388 1
	    dmp->dm_setLineAttr(dmp, mged_variables->linewidth, linestyle);
d395 1
a395 1
	    dmp->dm_setColor(dmp,
d409 1
a409 1
	    DM_DRAWDLIST(dmp, sp->s_dlist + displaylist);
d420 1
a420 1
	  if(dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist ) == TCL_OK) {
d430 1
a430 1
	  DM_DRAWDLIST(dmp, displaylist + 1);
d436 2
a437 2
	  dmp->dm_setColor(dmp, DM_WHITE, 1);
	  dmp->dm_drawVList(dmp, (struct rt_vlist *)&curr_dm_list->p_vlist);
d459 1
a459 1
	dmp->dm_newrot( dmp, mat, which_eye );
d461 1
a461 1
	dmp->dm_setColor(dmp, DM_WHITE, 1);
d479 1
a479 1
	    dmp->dm_setLineAttr(dmp, mged_variables->linewidth, linestyle);
d491 1
a491 1
	    DM_DRAWDLIST(dmp, sp->s_dlist + displaylist);
d503 1
a503 1
	  if( dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist ) == TCL_OK){
d529 1
a529 1
  DM_BEGINDLIST(dmp, displaylist + 1);
d534 1
a534 1
      dmp->dm_setLineAttr(dmp, mged_variables->linewidth, linestyle);
d564 1
a564 1
  DM_BEGINDLIST(dmp, sp->s_dlist + displaylist);
d610 1
a610 1
  dmp->dm_newrot(dmp, mr_mat, 0);
d644 1
a644 1
  dmp->dm_setColor(dmp, DM_YELLOW, 1);
d768 2
a769 2
      if(dmp->dm_drawString2D == X_drawString2D)
	dmp->dm_drawString2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
d773 1
a773 1
	dmp->dm_drawString2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
d787 2
a788 2
    if(dmp->dm_drawString2D == X_drawString2D)
      dmp->dm_drawString2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
d792 1
a792 1
      dmp->dm_drawString2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
d796 1
a796 1
  dmp->dm_newrot(dmp, model2view, 0);
d799 1
a799 1
  dmp->dm_setColor(dmp, r, g, b, 1);
d801 1
a801 1
  dmp->dm_setLineAttr(dmp, mged_variables->linewidth, 0);
d803 1
a803 1
  dmp->dm_setLineAttr(dmp, 1, 0);  /* linewidth - 1, not dashed */
d805 1
a805 1
  dmp->dm_drawVList(dmp, &h_vlist);
@


11.34
log
@mods to implement new display lists
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.33 1997/07/25 20:53:09 bparker Exp bparker $ (BRL)";
d293 1
a293 1
	if( mged_variables.perspective <= 0 && eye_pos_scr[Z] == 1.0 )  {
d309 1
a309 1
		to_eye_scr = 1 / tan(mged_variables.perspective * bn_degtorad * 0.5);
d313 1
a313 1
		eye_delta_scr = mged_variables.eye_sep_dist * 0.5 / SCR_WIDTH_PHYS;
d337 1
a337 1
if( mged_variables.faceplate > 0 )  {
d341 1
a341 1
				persp_mat( perspective_mat, mged_variables.perspective,
d393 1
a393 1
	    dmp->dm_setLineAttr(dmp, mged_variables.linewidth, linestyle);
d410 1
a410 1
	  if(displaylist && mged_variables.dlist){
d433 1
a433 1
	if(displaylist && mged_variables.dlist){
d439 7
a445 1
	if(mged_variables.m_axes)
d448 1
a448 1
	if(mged_variables.v_axes)
d458 1
a458 1
	if( mged_variables.perspective <= 0 )  {
d484 1
a484 1
	    dmp->dm_setLineAttr(dmp, mged_variables.linewidth, linestyle);
d495 1
a495 1
	  if(displaylist){
d515 1
a515 1
  if(mged_variables.e_axes)
d539 1
a539 1
      dmp->dm_setLineAttr(dmp, mged_variables.linewidth, linestyle);
d559 1
a559 1
  DM_ENDDLIST(dmp, displaylist + 1);
d571 1
a571 1
  DM_ENDDLIST(dmp, sp->s_dlist + displaylist);
d684 22
a705 23
      if(mged_variables.v_axes > 2){
	switch(mged_variables.v_axes){
	case 3:     /* lower left */
	  ox = -0.8 / dmp->dm_aspect;
	  oy = -0.8;
	  break;
	case 4:     /* upper left */
	  ox = -0.8 / dmp->dm_aspect;
	  oy = 0.8;
	  break;
	case 5:     /* upper right */
	  ox = 0.8 / dmp->dm_aspect;
	  oy = 0.8;
	  break;
	case 6:     /* lower right */
	  ox = 0.8 / dmp->dm_aspect;
	  oy = -0.8;
	  break;
	default:    /* center */
	  ox = 0;
	  oy = 0;
	  break;
	}
d707 4
a710 5
	v1[X] += ox;
	v1[Y] += oy;
	v2[X] += ox;
	v2[Y] += oy;
      }
d806 1
a806 1
  dmp->dm_setLineAttr(dmp, mged_variables.linewidth, 0);
@


11.33
log
@mods to use user specified linewidth
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.32 1997/07/17 20:56:11 bparker Exp bparker $ (BRL)";
d50 5
d282 1
a282 1
	int linestyle = 0;  /* not dashed */
d375 1
a375 5
#if 1
	dmp->dm_setLineAttr(dmp, mged_variables.linewidth, linestyle);
#else
	dmp->dm_setLineAttr(dmp, 1, linestyle); /* linewidth - 0, not dashed */
#endif
a392 1
#if 1
a393 3
#else
	    dmp->dm_setLineAttr(dmp, 1, linestyle);
#endif
d409 17
a425 1
	  if(dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist, mat ) == TCL_OK) {
d429 7
d437 1
a477 1
#if 1
d479 9
d489 11
a499 1
	    dmp->dm_setLineAttr(dmp, 1, linestyle);
d501 2
a502 3
	  }

	  if( dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist, mat ) == TCL_OK){
d506 1
d513 71
d663 1
a663 1
    if(axes == M_AXES){ /* world axes */
d806 1
a806 1
  dmp->dm_drawVList(dmp, &h_vlist, model2view);
@


11.32
log
@mods to draw_axes() and dozoom()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.31 1997/06/25 13:38:14 bparker Exp bparker $ (BRL)";
d370 3
a372 1

d374 1
d392 3
d396 1
d457 3
d461 1
d691 3
d695 1
@


11.31
log
@change w_axes to m_axes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.30 1997/05/08 14:34:38 bparker Exp bparker $ (BRL)";
d371 1
a371 1
	dmp->dm_setLineAttr(dmp, 1, linestyle); /* linewidth - 1, not dashed */
d392 12
a403 27
	  if(sp==illump){
	    if(!DM_SAME_COLOR(r,g,b,DM_WHITE_R,DM_WHITE_G,DM_WHITE_B)){
	      dmp->dm_setColor(dmp, DM_WHITE, 1);
	      DM_COPY_COLOR(r,g,b,DM_WHITE_R,DM_WHITE_G,DM_WHITE_B);
	    }
	    if(dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist, mat ) == TCL_OK){
	      sp->s_flag = UP;
	      ndrawn++;
	    }
	  }else{
	    if(!DM_SAME_COLOR(r,g,b,
			      (short)sp->s_color[0],
			      (short)sp->s_color[1],
			      (short)sp->s_color[2])){
	      dmp->dm_setColor(dmp,
			       (short)sp->s_color[0],
			       (short)sp->s_color[1],
			       (short)sp->s_color[2], 0);
	      DM_COPY_COLOR(r,g,b,
			      (short)sp->s_color[0],
			      (short)sp->s_color[1],
			      (short)sp->s_color[2]);
	    }
	    if(dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist, mat ) == TCL_OK) {
	      sp->s_flag = UP;
	      ndrawn++;
	    }
d405 4
d411 2
a412 2
  if(mged_variables.m_axes)
    draw_axes(M_AXES);  /* draw world view axis */
d414 2
a415 2
  if(mged_variables.v_axes)
    draw_axes(V_AXES);  /* draw view axis */
d480 1
a480 1
  point_t   v1, v2;
d591 2
a592 3
      if(state == ST_S_EDIT || state == ST_O_EDIT){
	/* build edit axes in model coordinates */

d610 17
a626 8

	if(OEDIT_TRAN){
	  vect_t delta;

	  MAT_DELTAS_GET(delta, modelchanges);
	  VADD2(m1, delta, m1);
	  VADD2(m2, delta, m2);
	}
@


11.30
log
@DM_SET_COLOR changed to DM_COPY_COLOR
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.29 1997/04/09 20:38:59 bparker Exp bparker $ (BRL)";
d42 1
a42 1
#define W_AXES 0
d422 2
a423 2
  if(mged_variables.w_axes)
    draw_axes(W_AXES);  /* draw world view axis */
d511 1
a511 1
    case W_AXES:
d553 1
a553 1
    if(axes == W_AXES){ /* world axes */
@


11.29
log
@change pmat to perspective_mat; make perspective_mat global
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.28 1997/03/06 14:04:52 bparker Exp bparker $ (BRL)";
d318 1
a318 1

d322 1
a322 1

d395 1
a395 1
	      DM_SET_COLOR(r,g,b,DM_WHITE_R,DM_WHITE_G,DM_WHITE_B);
d410 1
a410 1
	      DM_SET_COLOR(r,g,b,
@


11.28
log
@mods to v_axes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.27 1997/02/24 21:58:18 bparker Exp bparker $ (BRL)";
d50 1
a273 1
	mat_t		pmat;
d336 1
a336 1
				persp_mat( pmat, mged_variables.perspective,
d342 1
a342 1
				deering_persp_mat( pmat, l, h, eye_pos_scr );
d346 1
a346 1
			mike_persp_mat( pmat, eye_pos_scr );
d349 1
a349 1
bn_mat_print("pmat", pmat);
d356 1
a356 1
			deering_persp_mat( pmat, l, h, eye );
d362 1
a362 1
			deering_persp_mat( pmat, l, h, eye );
d365 1
a365 1
		bn_mat_mul( new, pmat, mat );
d438 1
a438 1
		bn_mat_mul( new, pmat, model2objview );
@


11.27
log
@mods to draw_axes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.26 1997/01/30 22:11:27 bparker Exp bparker $ (BRL)";
d568 1
a568 1
      if(mged_variables.v_axes > 1){
d570 1
a570 1
	case 2:     /* lower left */
d574 1
a574 1
	case 3:     /* upper left */
d578 1
a578 1
	case 4:     /* upper right */
d582 1
a582 1
	case 5:     /* lower right */
@


11.26
log
@mods due to change in dm_drawString2D
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.25 1997/01/29 02:51:42 mike Exp bparker $ (BRL)";
d38 4
d571 1
a571 1
	  ox = -0.8;
d575 1
a575 1
	  ox = -0.425;
d579 1
a579 1
	  ox = 0.8;
d583 1
a583 1
	  ox = 0.8;
d649 1
d651 7
a657 2
      dmp->dm_drawString2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
			   ((int)(2048.0 * v2[Y])) + 15, 1, 0);
d668 1
d670 7
a676 2
    dmp->dm_drawString2D(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
		  ((int)(2048.0 * v2[Y])) + 15, 1, 0);
@


11.25
log
@No longer need db.,h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.24 1997/01/17 22:56:57 bparker Exp $ (BRL)";
d647 1
a647 1
			   ((int)(2048.0 * v2[Y])) + 15, 1);
d660 1
a660 1
		  ((int)(2048.0 * v2[Y])) + 15, 1);
@


11.24
log
@checkin for weekend
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.23 1997/01/02 19:38:47 bparker Exp bparker $ (BRL)";
a30 1
#include "db.h"
@


11.23
log
@mods to use libbn and libbu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.22 1996/12/30 22:44:02 bparker Exp bparker $ (BRL)";
a57 1
int		ndrawn;
@


11.22
log
@house cleaning
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.21 1996/12/20 22:52:49 bparker Exp bparker $ (BRL)";
d28 1
d30 1
d33 1
a34 1
#include "externs.h"
d76 1
a76 1
	mat_idn( m2 );
d86 1
a86 1
	mat_idn( tran );
d88 1
a88 1
	mat_mul( m, m2, tran );
d124 1
a124 1
	mat_idn(shear);
d138 1
a138 1
	mat_idn(xlate);
d143 1
a143 1
	mat_idn( persp );
d152 2
a153 2
	mat_mul( t1, xlate, shear );
	mat_mul( t2, persp, t1 );
d167 1
a167 1
	mat_mul( pmat, xlate, t2 );
d169 1
a169 1
mat_print("pmat",pmat);
d302 1
a302 1
		to_eye_scr = 1 / tan(mged_variables.perspective * rt_degtorad * 0.5);
d317 1
a317 1
		mat_idn(tmat);
d319 1
a319 1
		mat_mul( tvmat, tmat, model2view );
d347 1
a347 1
mat_print("pmat", pmat);
d363 1
a363 1
		mat_mul( new, pmat, mat );
d395 1
a395 1
	    if(dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist, mat )){
d413 1
a413 1
	    if(dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist, mat )) {
d436 1
a436 1
		mat_mul( new, pmat, model2objview );
d462 1
a462 1
	  if( dmp->dm_drawVList( dmp, (struct rt_vlist *)&sp->s_vlist, mat )){
d496 1
a496 1
  mat_idn(mr_mat);
@


11.21
log
@mods to draw_axes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.20 1996/12/17 22:39:06 bparker Exp bparker $ (BRL)";
d389 1
a389 5
#if 0
	    if(!DM_SAME_COLOR(r,g,b,DM_WHITE)){
#else
	      if(!DM_SAME_COLOR(r,g,b,DM_WHITE_R,DM_WHITE_G,DM_WHITE_B)){
#endif
a390 3
#if 0
	      DM_SET_COLOR(r,g,b,DM_WHITE);
#else
a391 1
#endif
d600 1
a600 1
#if 1
a617 31
#else
	{
	  mat_t es_rot_mat;   /* rotations in es_mat */
	  mat_t tmat2;        /* rotations in es_mat and acc_rot_sol */

	  mat_copy(es_rot_mat, es_mat);
	  MAT_DELTAS(es_rot_mat, 0.0, 0.0, 0.0);
	  MAT_SCALE(es_rot_mat, 1.0, 1.0, 1.0);
	  MAT_SCALE_ALL(es_rot_mat, 1.0);
	  mat_mul(tmat2, es_rot_mat, acc_rot_sol);

	  /* apply rotations */
	  MAT4X3PNT(r_m3, es_rot_mat, a1);
	  MAT4X3PNT(r_m4, es_rot_mat, a2);
	  MAT4X3PNT(m1, tmat2, a1);
	  MAT4X3PNT(m2, tmat2, a2);
	}

	m1[X] = Viewscale*m1[X] + curr_e_axes_pos[X];
	m1[Y] = Viewscale*m1[Y] + curr_e_axes_pos[Y];
	m1[Z] = Viewscale*m1[Z] + curr_e_axes_pos[Z];
	m2[X] = Viewscale*m2[X] + curr_e_axes_pos[X];
	m2[Y] = Viewscale*m2[Y] + curr_e_axes_pos[Y];
	m2[Z] = Viewscale*m2[Z] + curr_e_axes_pos[Z];
	m3[X] = Viewscale*r_m3[X] + e_axes_pos[X];
	m3[Y] = Viewscale*r_m3[Y] + e_axes_pos[Y];
	m3[Z] = Viewscale*r_m3[Z] + e_axes_pos[Z];
	m4[X] = Viewscale*r_m4[X] + e_axes_pos[X];
	m4[Y] = Viewscale*r_m4[Y] + e_axes_pos[Y];
	m4[Z] = Viewscale*r_m4[Z] + e_axes_pos[Z];
#endif
@


11.20
log
@mod's to axes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.19 1996/12/12 22:10:09 bparker Exp bparker $ (BRL)";
d42 1
a477 1
#define DO_NEW_E_AXES
a492 1
#ifdef DO_NEW_E_AXES
d494 1
a494 1
#endif
d608 4
d613 7
a619 1
#ifdef DO_NEW_E_AXES
a625 12
#endif
	/* apply rotations */
	MAT4X3PNT(m1, acc_rot_sol, a1);
	MAT4X3PNT(m2, acc_rot_sol, a2);
#ifndef DO_NEW_E_AXES
	/* apply scale and translations */
	m1[X] = Viewscale*m1[X] + e_axes_pos[X];
	m1[Y] = Viewscale*m1[Y] + e_axes_pos[Y];
	m1[Z] = Viewscale*m1[Z] + e_axes_pos[Z];
	m2[X] = Viewscale*m2[X] + e_axes_pos[X];
	m2[Y] = Viewscale*m2[Y] + e_axes_pos[Y];
	m2[Z] = Viewscale*m2[Z] + e_axes_pos[Z];
d627 38
a664 7
	m1[X] = Viewscale*m1[X] + es_keypoint[X];
	m1[Y] = Viewscale*m1[Y] + es_keypoint[Y];
	m1[Z] = Viewscale*m1[Z] + es_keypoint[Z];
	m2[X] = Viewscale*m2[X] + es_keypoint[X];
	m2[Y] = Viewscale*m2[Y] + es_keypoint[Y];
	m2[Z] = Viewscale*m2[Z] + es_keypoint[Z];
#endif
a669 1
#ifdef DO_NEW_E_AXES
d693 1
a693 6
#else
    VMOVE(vlist.pt[i*2], m1);
    vlist.cmd[i*2] = RT_VLIST_LINE_MOVE;
    VMOVE(vlist.pt[i*2 + 1], m2);
    vlist.cmd[i*2 + 1] = RT_VLIST_LINE_DRAW;
#endif
@


11.19
log
@start of cleanup
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.18 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d477 1
d493 3
d532 4
a535 1
  vlist.nused = 6;
d545 1
a545 2
#if 0
	if(axes == V_AXES && mged_variables.v_axes > 1){
a551 4
#else
	a1[j] = -0.125;
	a2[j] = 0.125;
#endif
d610 19
a628 11
	  /* apply rotations */
	  MAT4X3PNT(m1, acc_rot_sol, a1);
	  MAT4X3PNT(m2, acc_rot_sol, a2);
#if 1
	  /* apply scale and translations */
	  m1[X] = Viewscale*m1[X] + e_axes_pos[X];
	  m1[Y] = Viewscale*m1[Y] + e_axes_pos[Y];
	  m1[Z] = Viewscale*m1[Z] + e_axes_pos[Z];
	  m2[X] = Viewscale*m2[X] + e_axes_pos[X];
	  m2[Y] = Viewscale*m2[Y] + e_axes_pos[Y];
	  m2[Z] = Viewscale*m2[Z] + e_axes_pos[Z];
d630 6
a635 6
	  m1[X] = Viewscale*m1[X] + es_keypoint[X];
	  m1[Y] = Viewscale*m1[Y] + es_keypoint[Y];
	  m1[Z] = Viewscale*m1[Z] + es_keypoint[Z];
	  m2[X] = Viewscale*m2[X] + es_keypoint[X];
	  m2[Y] = Viewscale*m2[Y] + es_keypoint[Y];
	  m2[Z] = Viewscale*m2[Z] + es_keypoint[Z];
d642 25
d671 1
a671 1

@


11.18
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.17 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d538 1
d546 4
d575 1
a575 1
	  oy = -0.7;
d587 1
a587 1
	  oy = -0.7;
@


11.17
log
@hacks to use latest libdm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.16 1996/09/26 20:38:22 bparker Exp bparker $ (BRL)";
d507 3
a509 3
      r = 230;
      g = 50;
      b = 50;
@


11.16
log
@changed parameters to dmr_object
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.15 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d272 4
d364 1
a364 1
	dmp->dmr_newrot( dmp, mat, which_eye );
d366 1
d368 18
a385 4
		sp->s_flag = DOWN;		/* Not drawn yet */
		/* If part of object rotation, will be drawn below */
		if( sp->s_iflag == UP )
			continue;
d387 36
a422 18
		ratio = sp->s_size * inv_viewsize;

		/*
		 * Check for this object being bigger than 
		 * dmp->dmr_bound * the window size, or smaller than a speck.
		 */
		 if( ratio >= dmp->dmr_bound || ratio < 0.001 )
		 	continue;

 		if( dmp->dmr_object( dmp, (struct rt_vlist *)&sp->s_vlist,
				     mat, sp==illump, sp->s_soldash,
				     (short)sp->s_color[0],
				     (short)sp->s_color[1],
				     (short)sp->s_color[2],
				     sp->s_dmindex) )  {
			sp->s_flag = UP;
			ndrawn++;
		}
d444 1
a444 1
	dmp->dmr_newrot( dmp, mat, which_eye );
d446 1
d449 22
a470 22
		/* Ignore all objects not being rotated */
		if( sp->s_iflag != UP )
			continue;

		ratio = sp->s_size * inv_viewsize;

		/*
		 * Check for this object being bigger than 
		 * dmp->dmr_bound * the window size, or smaller than a speck.
		 */
		 if( ratio >= dmp->dmr_bound || ratio < 0.001 )
		 	continue;

		if( dmp->dmr_object( dmp, (struct rt_vlist *)&sp->s_vlist,
				     mat, 1, sp->s_soldash,
				     (short)sp->s_color[0],
				     (short)sp->s_color[1],
				     (short)sp->s_color[2],
				     sp->s_dmindex) )  {
			sp->s_flag = UP;
			ndrawn++;
		}
d500 1
a500 1
  dmp->dmr_newrot(dmp, mr_mat, 0);
d530 3
d636 2
a637 2
    dmp->dmr_puts(dmp, labels[i], ((int)(2048.0 * v2[X])) + 15,
		  ((int)(2048.0 * v2[Y])) + 15, 1, DM_YELLOW);
d640 1
a640 1
  dmp->dmr_newrot(dmp, model2view, 0);
d643 3
a645 1
  dmp->dmr_object( dmp, &h_vlist, model2view, 0, 0, r, g, b, index);
@


11.15
log
@now using more generalized solid macros
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.14 1996/09/23 18:30:26 bparker Exp bparker $ (BRL)";
d377 6
a382 1
 		if( dmp->dmr_object( dmp, sp, mat, ratio, sp==illump ) )  {
d424 6
a429 1
		if( dmp->dmr_object( dmp, sp, mat, ratio, 1 ) )  {
d446 3
a448 1
  struct solid sp;
d458 3
a463 5
  sp.s_vlist.forw = &sp.s_vlist;
  sp.s_vlist.back = &sp.s_vlist;
  BU_LIST_APPEND(&sp.s_vlist, (struct bu_list *)&vlist);
  sp.s_soldash = 0;

d465 1
a465 1
    (*axes_color_hook)(axes, sp.s_color);
d469 4
a472 3
      sp.s_color[0] = 230;
      sp.s_color[1] = 50;
      sp.s_color[2] = 50;
d475 4
a478 3
      sp.s_color[0] = 150;
      sp.s_color[1] = 230;
      sp.s_color[2] = 150;
d482 4
a485 3
      sp.s_color[0] = 150;
      sp.s_color[1] = 150;
      sp.s_color[2] = 230;
d602 1
a602 1
  dmp->dmr_object( dmp, &sp, model2view, (double)1.0, 0 );
@


11.14
log
@ use LIBDM permanently
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.13 1996/09/17 21:17:51 bparker Exp bparker $ (BRL)";
d33 1
a33 1
#include "./solid.h"
d53 1
a53 1
struct solid	*FreeSolid;	/* Head of freelist */
d362 1
a362 1
	FOR_ALL_SOLIDS( sp )  {
d405 1
a405 1
	FOR_ALL_SOLIDS( sp )  {
@


11.13
log
@prepare to use libdm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.12 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d35 1
a35 1
#include "./dm.h"
a359 1
#ifdef USE_LIBDM
a360 3
#else
	dmp->dmr_newrot( mat, which_eye );
#endif
a376 1
#ifdef USE_LIBDM
a377 3
#else
		if( dmp->dmr_object( sp, mat, ratio, sp==illump ) )  {
#endif
a401 1
#ifdef USE_LIBDM
a402 3
#else
	dmp->dmr_newrot( mat, which_eye );
#endif
a418 1
#ifdef USE_LIBDM
a419 3
#else
		if( dmp->dmr_object( sp, mat, ratio, 1 ) )  {
#endif
a446 1
#ifdef USE_LIBDM
a447 3
#else
  dmp->dmr_newrot(mr_mat, 0);
#endif
a581 1
#ifdef USE_LIBDM
a589 10
#else
    dmp->dmr_puts(labels[i], ((int)(2048.0 * v2[X])) + 15,
		  ((int)(2048.0 * v2[Y])) + 15, 1, DM_YELLOW);
  }

  dmp->dmr_newrot(model2view, 0);

  /* draw axes */
  dmp->dmr_object( &sp, model2view, (double)1.0, 0 );
#endif
@


11.12
log
@rt_list ---> bu_list
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.11 1996/08/02 18:04:34 bparker Exp bparker $ (BRL)";
d360 3
d364 1
d381 3
d385 1
d410 3
d414 1
d431 3
d435 1
d463 3
d467 1
d602 10
d620 1
@


11.11
log
@supply default colors in draw_axes()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.10 1996/07/30 21:30:32 bparker Exp bparker $ (BRL)";
d451 1
a451 1
  RT_LIST_APPEND(&sp.s_vlist, (struct rt_list *)&vlist);
@


11.10
log
@tweaked the view axes positions
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.9 1996/03/22 18:34:07 bparker Exp bparker $ (BRL)";
a438 1
  int color = 0;
d456 19
a474 2
  else{/* use highlight color */
    color = 1;
d589 1
a589 1
  dmp->dmr_object( &sp, model2view, (double)1.0, color );
@


11.9
log
@cleanup
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.8 1996/03/01 19:21:50 bparker Exp bparker $ (BRL)";
d37 3
a39 3
#define W_AXIS 0
#define V_AXIS 1
#define E_AXIS 2
d41 2
a42 2
extern point_t e_axis_pos;
static void draw_axis();
d383 2
a384 2
  if(mged_variables.w_axis)
    draw_axis(W_AXIS);  /* draw world view axis */
d386 2
a387 2
  if(mged_variables.v_axis)
    draw_axis(V_AXIS);  /* draw view axis */
d425 2
a426 2
  if(mged_variables.e_axis)
    draw_axis(E_AXIS); /* draw edit axis */
d430 1
a430 1
 * Draw view axis or edit axis.
d433 2
a434 2
draw_axis(axis)
int axis;
d455 2
a456 2
  if(axis_color_hook)
    (*axis_color_hook)(axis, sp.s_color);
d468 1
a468 1
	if(axis == V_AXIS && mged_variables.v_axis > 1){
d481 1
a481 1
    if(axis == W_AXIS){ /* world axis */
d488 2
a489 2
    }else if(axis == V_AXIS){  /* create view axis */
      /* build axis in view coodinates */
d496 2
a497 2
      if(mged_variables.v_axis > 1){
	switch(mged_variables.v_axis){
d500 1
a500 1
	  oy = -0.6;
d503 2
a504 2
	  ox = -0.8;
	  oy = 0.6;
d508 1
a508 1
	  oy = 0.6;
d512 1
a512 1
	  oy = -0.6;
d529 1
a529 1
    }else{  /* create edit axis */
d531 1
a531 1
	/* build edit axis in model coordinates */
d538 6
a543 6
	  m1[X] = Viewscale*m1[X] + e_axis_pos[X];
	  m1[Y] = Viewscale*m1[Y] + e_axis_pos[Y];
	  m1[Z] = Viewscale*m1[Z] + e_axis_pos[Z];
	  m2[X] = Viewscale*m2[X] + e_axis_pos[X];
	  m2[Y] = Viewscale*m2[Y] + e_axis_pos[Y];
	  m2[Z] = Viewscale*m2[Z] + e_axis_pos[Z];
d556 1
a556 1
    /* load axis */
d565 1
a565 1
    /* label axis */
d572 1
a572 1
  /* draw axis */
@


11.8
log
@remove unused XMGED stuff
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.7 1996/02/28 21:36:08 bparker Exp bparker $ (BRL)";
a43 7
#ifndef MULTI_ATTACH
/* Variables for dozoom() */
fastf_t	Viewscale;
mat_t	Viewrot, toViewcenter;
mat_t	model2view, view2model;
mat_t	model2objview, objview2model;
#endif
@


11.7
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.6 1995/12/27 22:31:11 bparker Exp bparker $ (BRL)";
a41 1
extern void (*axis_color_hook)();
a310 3
#ifdef XMGED
rt_log("d=%gscr, d=%gmm, delta=%gscr\n", to_eye_scr, to_eye_scr * SCR_WIDTH_PHYS, eye_delta_scr);
#else
a311 1
#endif
@


11.6
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.5 1995/12/02 00:20:38 bparker Exp bparker $ (BRL)";
d579 1
a579 1
		  ((int)(2048.0 * v2[Y])) + 15, 1, DM_YELLOW, -1);
@


11.5
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.4 1995/11/07 22:58:57 bparker Exp bparker $ (BRL)";
d45 1
d51 1
d371 1
@


11.4
log
@turned on axis
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.3 1995/06/16 20:28:06 mike Exp bparker $ (BRL)";
d546 1
a546 1
	  /* apply translations */
@


11.3
log
@Fixed bad code
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 11.2 1995/01/17 13:04:36 bparker Exp mike $ (BRL)";
a36 1
#ifdef XMGED
d42 1
a43 2
void (*axis_color_hook)();
#endif
a391 1
#ifdef XMGED
a396 1
#endif
a433 1
#ifdef XMGED
a435 1
#endif
a437 1
#ifdef XMGED
a583 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/dozoom.c,v 11.2 95/01/17 11:42:53 bparker Exp $ (BRL)";
d469 1
a469 1
  sp.s_soldash = NULL;
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.15 94/11/05 03:46:55 mike Exp $ (BRL)";
d37 10
d312 3
d316 1
d394 8
d437 5
d443 149
@


10.15
log
@Irix 6
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.14 94/08/09 15:19:11 gdurf Exp Locker: mike $ (BRL)";
@


10.14
log
@Added include of conf.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.13 1994/03/02 20:42:21 mike Exp gdurf $ (BRL)";
d108 1
d110 2
a111 1
point_t	a,b;
@


10.13
log
@More conservative setting of s_flag.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.12 93/07/27 21:46:27 mike Exp Locker: mike $ (BRL)";
d22 2
@


10.12
log
@This version is the same as before, but has new perspective matrix
code that is on the verge of being useful.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.11 93/07/02 17:51:20 mike Exp Locker: mike $ (BRL)";
d356 1
a361 1
		sp->s_flag = DOWN;		/* Not drawn yet */
a397 1
		sp->s_flag = DOWN;		/* Not drawn yet */
@


10.11
log
@Slightly better algorithm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.10 92/11/23 20:55:39 mike Exp Locker: mike $ (BRL)";
d73 1
a73 1
	m2[11] = 2*far*near / (far-near);
d75 1
a75 1
	m2[14] = -1;
d78 1
d85 105
d312 7
d329 7
@


10.10
log
@If the eye is at Z==+1 (it normally is), then use normal Z clipping.
If not, then this is probably VRMGR at work, select an alternate
perspecive routine
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.9 92/09/03 19:18:57 mike Exp Locker: mike $ (BRL)";
d95 8
d127 1
d130 2
a131 2
	m[10] = ( sum[Z] - 2 * eye[Z] ) / diff[Z];
	m[11] = -eye[Z] + 2 * h[Z] * eye[Z] / diff[Z];
d137 2
d167 1
a167 1
	if( mged_variables.perspective <= 0 )  {
d189 1
a189 1
		VSET( l, -1, -1, 0.01 );
@


10.9
log
@Added eye_pos_scr
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.8 92/08/25 03:36:30 mike Exp Locker: mike $ (BRL)";
d195 10
a204 10
#if 0
			/* This way works, with reasonable Z-clipping */
			persp_mat( pmat, mged_variables.perspective,
				1.0, 0.01, 1.0e10, 1.0 );
#else
			/* This way does not have reasonable Z-clipping,
			 * but includes shear, for GDurf's testing.
			 */
			deering_persp_mat( pmat, l, h, eye_pos_scr );
#endif
@


10.8
log
@The perspective matrix for stereo is not right.
It Z-clips at the screen origin.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.7 92/08/24 19:51:26 mike Exp Locker: mike $ (BRL)";
d44 4
a47 2
/* How should this be implemented????? */
point_t	recip_vanishing_point = { 0, 0, -1 };
d193 1
d195 2
d199 6
@


10.7
log
@Added new variable "eye_sep_dist" to support Stereo viewing.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.6 92/08/21 22:46:16 mike Exp Locker: mike $ (BRL)";
d82 47
a146 1
	fastf_t		eye_delta;
d157 32
d192 2
d197 3
a199 6
			/* XXX more logic needed */
			eye_delta = mged_variables.eye_sep_dist*0.5;
			mat_idn(tmat);
			MAT_DELTAS(tmat, eye_delta, 0, 0);	/* view delta */
			mat_mul(tvmat, tmat, model2view);
			mat = tvmat;
d203 3
a205 6
			mat_idn(tmat);
			/* XXX more logic needed */
			eye_delta = mged_variables.eye_sep_dist*0.5;
			MAT_DELTAS(tmat, -eye_delta, 0, 0);	/* view delta */
			mat_mul(tvmat, tmat, model2view);
			mat = tvmat;
a207 2
		persp_mat( pmat, mged_variables.perspective,
			1.0, 0.01, 1.0e10, 1.0 );
@


10.6
log
@Initial prototype support for stereo viewer
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.4 92/08/19 15:49:33 gdurf Exp Locker: mike $ (BRL)";
d100 1
d117 2
a118 1
#define EYE_DELTA	0.01	/* XXX hack hack hack */
d120 1
a120 1
			MAT_DELTAS(tmat, EYE_DELTA, 0, 0);	/* view delta */
d127 3
a129 1
			MAT_DELTAS(tmat, -EYE_DELTA, 0, 0);	/* view delta */
@


10.5
log
@Fixed perspective generation subroutine for right handed coords.
I got it wrong because the bloody SGI is left handed, and
I didn't correct properly.
@
text
@d90 2
a91 1
dozoom()
d97 1
d110 20
d132 1
a132 1
		mat_mul( new, pmat, model2view );
d135 1
a135 1
	dmp->dmr_newrot( mat );
d171 1
a171 1
	dmp->dmr_newrot( mat );
@


10.4
log
@added recip_vanishing_point
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.3 92/04/18 02:46:11 mike Exp Locker: gdurf $ (BRL)";
d54 1
a54 1
 *  Compute a perspective matrix.
d56 1
d70 2
a71 2
	m2[10] = -(far+near) / (far-near);	/* negate Z! */
	m2[11] = -2*far*near / (far-near);
@


10.3
log
@Support for perspective transformations now lies here,
in MGED, rather than in the display manager.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.2 92/04/18 01:46:42 mike Exp Locker: mike $ (BRL)";
d44 3
d71 1
@


10.2
log
@Modified make a dm_newrot() call twice, once before normal solids,
and a second time before edited solids.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dozoom.c,v 10.1 91/10/12 06:43:39 mike Rel4_0 Locker: mike $ (BRL)";
d49 28
d90 3
d100 10
a109 1
	dmp->dmr_newrot( model2view );
d125 1
a125 1
		if( dmp->dmr_object( sp, model2view, ratio, sp==illump ) )  {
d138 8
a145 1
	dmp->dmr_newrot( model2objview );
d152 1
a152 1
		ratio = (sp->s_size / modelchanges[15]) * inv_viewsize;
d162 1
a162 1
		if( dmp->dmr_object( sp, model2objview, ratio, 1 ) )  {
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 9.1 89/05/19 06:02:59 mike Rel3_5 $ (BRL)";
d61 1
d64 1
d67 1
a67 1
	 * Compute translation vector & scale factor for all solids
d69 1
d75 1
a75 1
		ratio = sp->s_size / VIEWSIZE;
d92 2
a93 2
	 * Compute translation vector & scale factor for solids involved in
	 * Object edits.
a97 1
	/* Output special Rotation matrix, when needed */
d105 1
a105 1
		ratio = (sp->s_size / modelchanges[15]) / VIEWSIZE;
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 8.3 89/04/06 20:39:53 mike Exp $ (BRL)";
@


8.3
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 8.2 88/12/06 01:18:30 mike Locked $ (BRL)";
@


8.2
log
@No more maxview
Included raytrace.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/dozoom.c,v 1.3 88/10/29 22:55:28 mike Exp $ (BRL)";
d30 1
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 7.3 88/09/17 02:35:12 reschly Exp $ (BRL)";
d28 1
a40 1
fastf_t	maxview = 0.5;
@


7.3
log
@added stdio include.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 7.2 87/11/05 05:05:38 reschly Locked $ (BRL)";
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 7.1 87/11/03 00:00:33 mike Rel $ (BRL)";
d23 1
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 6.1 87/07/11 08:03:46 mike Rel $ (BRL)";
d24 1
a24 1
#include "./machine.h"	/* special copy */
d33 1
a33 1
float	Viewscale;
d39 1
a39 1
float	maxview = 0.5;
d58 1
a58 1
	FAST float ratio;
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 5.1 87/06/24 22:20:23 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 4.2 87/02/13 00:07:24 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 4.1 86/12/29 03:21:22 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 2.4 86/08/12 06:49:20 mike Exp $ (BRL)";
@


2.4
log
@Changed #includes for CC -I../h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 2.3 85/09/14 05:36:12 mike Exp $ (BRL)";
@


2.3
log
@Lint-inspired cleanup.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 2.2 85/08/07 05:18:40 mike Exp $ (BRL)";
d23 1
d25 6
a30 7
#include "../h/vmath.h"
#include "ged.h"
#include "solid.h"
#include "../h/db.h"
#include "sedit.h"
#include <math.h>
#include "dm.h"
@


2.2
log
@Changed to use common ../h/vmath.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 2.1 85/03/11 23:55:48 mike Prod $ (BRL)";
d58 1
a58 1
	static float ratio;
d90 1
a90 1
	if( 0 )			/* later, check flag here */
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 1.5 85/01/17 07:29:02 mike Exp $ (BRL)";
d23 2
a24 1
#include "ged_types.h"
a30 1
#include "../h/vmath.h"
@


1.5
log
@
Latest stuff
@
text
@d7 4
a10 1
 * Source -
d14 4
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 1.4 85/01/16 01:57:43 mike Exp $ (BRL)";
d26 1
a26 1
#include "db.h"
d30 1
a30 1
#include "vmath.h"
@


1.4
log
@pre-Keith version
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: dozoom.c,v 1.3 84/11/20 04:24:01 mike Exp $ (BRL)";
d73 1
a73 1
		if( dmp->dmr_object( sp->s_center, model2view, ratio, sp->s_addr, sp==illump ) )  {
d104 1
a104 1
		if( dmp->dmr_object( sp->s_center, model2objview, ratio, sp->s_addr, 1 ) )  {
@


1.3
log
@Vector lists saved, multiple display managers supported.
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d19 1
a19 1
#include "3d.h"
@


1.2
log
@Now has no compile-time flags for display type,
instead using smarter display manager routines
@
text
@d6 5
d12 4
d68 1
a68 1
		 * dm_bound * the window size, or smaller than a speck.
d70 1
a70 1
		 if( ratio >= dm_bound || ratio < 0.001 )
d73 1
a73 1
		if( dm_object( sp->s_center, model2view, ratio, sp->s_addr, sp==illump ) )  {
d87 1
a87 1
	dm_newrot( model2objview );
d99 1
a99 1
		 * dm_bound * the window size, or smaller than a speck.
d101 1
a101 1
		 if( ratio >= dm_bound || ratio < 0.001 )
d104 1
a104 1
		if( dm_object( sp->s_center, model2objview, ratio, sp->s_addr, 1 ) )  {
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
 * to see if they are visible IN ENTIRETY within the current viewing
a36 2
 *
 * NOTE that titles, etc, are now done in dotitles().
a42 9
#ifdef MEGATEK
#define BOUND 15.9			/* Max magnification in Rot matrix */
	static mat_t mat_xform;		/* intermediate Megatek matrix */
	static mat_t mat_screen;	/* xform from prototype to screen */
	static mat_t mat_trnrot;	/* transposed Rot matrix */
#else	/* VG */
#define BOUND 0.95			/* Max magnification in Rot matrix */
#endif
	static vect_t pos_screen;	/* Pos, in (rotated) view space */
d59 1
a59 1
		 * BOUND * the window size, or smaller than a speck.
d61 1
a61 1
		 if( ratio >= BOUND || ratio < 0.001 )
d64 4
a67 70
#ifndef MEGATEK			/* VG */

		/* Compute view-space pos of solid's center */
		MAT4X3PNT( pos_screen, model2view, sp->s_center );

		/*
		 * If the view co-ordinates of the center point fall
		 * outside the viewing window, discard this solid.
		 */
		if( pos_screen[X] >= BOUND || pos_screen[X] <= -BOUND )
			 continue;
		if( pos_screen[Y] >= BOUND || pos_screen[Y] <= -BOUND )
			continue;
		if( pos_screen[Z] >= BOUND || pos_screen[Z] <= -BOUND )
			continue;

		/*
		 * Object will be displayed.
		 */
		sp->s_flag = UP;		/* obj is drawn */
		ndrawn++;
		dm_call( sp->s_addr, pos_screen, ratio, sp==illump );
#endif
#ifdef MEGATEK

		/*
		 * Object will be displayed.
		 *
		 * Compute transfomation from model to view co-ordinates,
		 * to correctly position prototype on the screen.
		 * Take into account prototypes actual size (-1..+1) by
		 * multiplying by ratio.
		 */
		/* Compute view-space pos of solid's center */
		MAT4X3PNT( pos_screen, model2view, sp->s_center );

		/* Save rotation portion of model2view, add xlate */
		mat_copy( mat_trnrot, model2view );
		mat_trnrot[15] = 1;
		mat_trnrot[MDX] = pos_screen[X];
		mat_trnrot[MDY] = pos_screen[Y];
		mat_trnrot[MDZ] = pos_screen[Z];

		/* Also include scaling, given prototype size -vs- view */
		mat_idn(mat_xform);
		mat_xform[0] = ratio;	/* * s_size / ( 2 * m2view[15] ) */
		mat_xform[5] = ratio;
		mat_xform[10] = ratio;

		/* Glue it together.  Important to scale BEFORE rot+xlate, so
		 * as not to damage the length of the (screen space) xlate */
		mat_mul( mat_screen, mat_trnrot, mat_xform );

		if(
			mat_screen[ 0] < -BOUND ||
			mat_screen[ 0] >  BOUND ||
			mat_screen[ 5] < -BOUND ||
			mat_screen[ 5] >  BOUND ||
		 	mat_screen[MDX] < -BOUND ||
			mat_screen[MDX] >  BOUND ||
			mat_screen[MDY] < -BOUND ||
			mat_screen[MDY] >  BOUND
		)  continue;

		sp->s_flag = UP;		/* obj is drawn */
		ndrawn++;
		dm_matcall( sp->s_addr, mat_screen,
			sp==illump ? DM_WHITE
				: ((ndrawn>>2)%13)+2 );
#endif
d74 2
a75 5
	if( 1 )  {
#ifndef MEGATEK
		/* Output special Rotation matrix */
		dm_newrot( model2objview );
#endif
d77 2
a78 4
		FOR_ALL_SOLIDS( sp )  {
			/* Ignore all objects not being rotated */
			if( sp->s_iflag != UP )
				continue;
d80 4
a83 2
			ratio = (sp->s_size / modelchanges[15]) / VIEWSIZE;
			sp->s_flag = DOWN;		/* Not drawn yet */
d85 2
a86 6
			/*
			 * Check for this object being bigger than 
			 * BOUND * the window size, or smaller than a speck.
			 */
			 if( ratio >= BOUND || ratio < 0.001 )
			 	continue;
d88 6
a93 3
#ifndef MEGATEK				/* VG */
			/* Compute view-space pos of solid's center */
			MAT4X3PNT( pos_screen, model2objview, sp->s_center );
d95 2
a96 15
			/*
			 * If the edit view co-ordinates of the center point
			 * fall outside the viewing window, discard the solid.
			 */
			if( pos_screen[X] >= BOUND || pos_screen[X] <= -BOUND)
				continue;
			if( pos_screen[Y] >= BOUND || pos_screen[Y] <= -BOUND)
				continue;
			if( pos_screen[Z] >= BOUND || pos_screen[Z] <= -BOUND)
				continue;

			/*
			 * Object will be displayed.
			 */
			sp->s_flag = UP;		/* obj is drawn */
a97 39
			dm_call( sp->s_addr, pos_screen, ratio, 0 );
#endif

#ifdef MEGATEK
			/* Compute view-space pos of solid's center */
			MAT4X3PNT( pos_screen, model2objview, sp->s_center );

			/* Save rot portion of model2objview, add xlate */
			mat_copy( mat_trnrot, model2objview );
			mat_trnrot[15] = 1;
			mat_trnrot[MDX] = pos_screen[X];
			mat_trnrot[MDY] = pos_screen[Y];
			mat_trnrot[MDZ] = pos_screen[Z];

			/* Also include scaling, given prototype size -vs- view */
			mat_idn(mat_xform);
			mat_xform[0] = ratio;	/* * s_size / ( 2 * m2view[15] ) */
			mat_xform[5] = ratio;
			mat_xform[10] = ratio;

			/* Glue it together.  Important to scale BEFORE rot+xlate, so
			 * as not to damage the length of the (screen space) xlate */
			mat_mul( mat_screen, mat_trnrot, mat_xform );

			if(
				mat_screen[ 0] < -BOUND ||
				mat_screen[ 0] >  BOUND ||
				mat_screen[ 5] < -BOUND ||
				mat_screen[ 5] >  BOUND ||
			 	mat_screen[MDX] < -BOUND ||
				mat_screen[MDX] >  BOUND ||
				mat_screen[MDY] < -BOUND ||
				mat_screen[MDY] >  BOUND
			)  continue;

			sp->s_flag = UP;		/* obj is drawn */
			ndrawn++;
			dm_matcall( sp->s_addr, mat_screen, DM_WHITE );
#endif
@
