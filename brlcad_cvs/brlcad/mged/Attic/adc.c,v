head	11.55;
access;
symbols
	ansi-20040405-merged:11.50.2.2
	postmerge-20040405-ansi:11.52
	premerge-20040404-ansi:11.51
	postmerge-autoconf:11.51
	autoconf-freeze:11.50.10.2
	premerge-autoconf:11.51
	postmerge-20040315-windows:11.51
	premerge-20040315-windows:11.51
	windows-20040315-freeze:11.50.4.1
	autoconf-20031203:11.50
	autoconf-20031202:11.50
	autoconf-branch:11.50.0.10
	phong-branch:11.50.0.8
	photonmap-branch:11.50.0.6
	rel-6-1-DP:11.50
	windows-branch:11.50.0.4
	rel-6-0-2:11.48
	ansi-branch:11.50.0.2
	rel-6-0-1-branch:11.48.0.2
	hartley-6-0-post:11.49
	hartley-6-0-pre:11.48
	rel-6-0-1:11.48
	rel-6-0:11.48
	rel-5-4:11.43
	offsite-5-3-pre:11.45
	rel-5-3:11.43
	rel-5-2:11.43
	rel-5-1-branch:11.43.0.2
	rel-5-1:11.43
	rel-5-0:11.42
	rel-5-0-beta:11.41
	rel-4-5:11.31
	ctj-4-5-post:11.23
	ctj-4-5-pre:11.23
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.2;
locks; strict;
comment	@ * @;


11.55
date	2004.05.21.17.47.34;	author morrison;	state dead;
branches;
next	11.54;

11.54
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.53;

11.53
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	11.52;

11.52
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.51;

11.51
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.50;

11.50
date	2002.08.20.17.08.20;	author jra;	state Exp;
branches
	11.50.2.1
	11.50.4.1
	11.50.10.1;
next	11.49;

11.49
date	2002.08.15.20.55.31;	author hartley;	state Exp;
branches;
next	11.48;

11.48
date	2001.06.05.15.51.40;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	2001.06.01.19.23.22;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	2001.04.02.19.08.56;	author jra;	state Exp;
branches;
next	11.45;

11.45
date	2000.09.07.02.23.41;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	2000.08.19.03.10.37;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	99.12.30.19.40.50;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	99.09.01.18.55.08;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	99.02.17.19.37.32;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	98.12.18.22.05.34;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	98.11.06.21.50.25;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	98.10.21.17.34.55;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	98.06.12.19.46.18;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	98.06.11.19.32.07;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	98.05.18.19.35.06;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	98.03.19.18.05.26;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	98.03.13.22.38.58;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	98.03.06.22.26.36;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	98.02.06.22.13.20;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	97.12.23.14.25.42;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	97.11.26.21.33.20;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	97.11.03.15.22.23;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	97.09.08.19.05.35;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	97.07.25.20.52.50;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	97.06.25.13.35.42;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	97.02.24.22.03.34;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	97.01.24.21.02.28;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.12.23.22.40.34;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.11.19.21.49.13;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.10.03.20.22.26;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.09.23.18.40.41;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.09.17.21.16.54;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.07.29.15.43.51;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.06.21.16.06.47;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.05.24.18.52.32;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.03.22.18.35.22;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.03.01.19.35.25;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.01.17.22.12.53;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.12.27.22.28.16;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.07.36;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.32;	author mike;	state Rel4_4;
branches;
next	10.9;

10.9
date	94.12.28.15.37.14;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.12.16.20.38.40;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.12.16.19.34.25;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.12.05.15.32.16;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.01.30.33;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.09.14.54.27;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.06.22.18.23.40;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.06.01.13.50.00;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.02;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.07.06.03.28.30;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.06.26.16.18.06;	author pjt;	state Exp;
branches;
next	9.4;

9.4
date	91.06.25.16.05.54;	author pjt;	state Exp;
branches;
next	9.3;

9.3
date	91.06.14.08.38.32;	author pjt;	state Exp;
branches;
next	9.2;

9.2
date	91.06.14.06.31.09;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.01.37;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.35.15;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.09.16.02.34.58;	author reschly;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.03.02;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.13;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.01.16;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.17.25;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.05.03;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.18.44;	author mike;	state Rel1;
branches;
next	2.4;

2.4
date	86.08.12.06.45.58;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.14.05.33.23;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.08.07.05.16.06;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.53.23;	author mike;	state Prod;
branches;
next	1.2;

1.2
date	84.11.20.04.21.41;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.47.19;	author mike;	state Exp;
branches;
next	;

11.50.2.1
date	2002.09.19.18.01.58;	author morrison;	state Exp;
branches;
next	11.50.2.2;

11.50.2.2
date	2004.03.17.21.21.54;	author morrison;	state Exp;
branches;
next	;

11.50.4.1
date	2004.03.11.23.46.32;	author morrison;	state Exp;
branches;
next	;

11.50.10.1
date	2004.02.12.18.34.12;	author erikg;	state Exp;
branches;
next	11.50.10.2;

11.50.10.2
date	2004.03.15.14.07.34;	author erikg;	state Exp;
branches;
next	;


desc
@Angle/Distance cursor
@


11.55
log
@moved to src/mged/
@
text
@/*
 *			A D C . C
 *
 * Functions -
 *	adcursor	implement the angle/distance cursor
 *	f_adc		control angle/distance cursor from keyboard
 *
 * Authors -
 *	Gary Steven Moss
 *	Paul J. Tanenbaum
 *	Robert G. Parker
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/adc.c,v 11.54 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"

#ifndef M_SQRT2
#define M_SQRT2		1.41421356237309504880
#endif

#ifndef M_SQRT2_DIV2
#define M_SQRT2_DIV2       0.70710678118654752440
#endif

static void adc_print_vars(void);

void
adc_set_dirty_flag(void)
{
  struct dm_list *dmlp;

  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
    if(dmlp->dml_adc_state == adc_state)
      dmlp->dml_dirty = 1;
}

void
adc_set_scroll(void)
{
  struct dm_list *dmlp;
  struct dm_list *save_dmlp;

  save_dmlp = curr_dm_list;

  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
    if(dmlp->dml_adc_state == adc_state){
      curr_dm_list = dmlp;
      set_scroll();
      dirty = 1;
    }

  curr_dm_list = save_dmlp;
}

static void
adc_model_To_adc_view(void)
{
  MAT4X3PNT(adc_state->adc_pos_view, view_state->vs_vop->vo_model2view, adc_state->adc_pos_model);
  adc_state->adc_dv_x = adc_state->adc_pos_view[X] * GED_MAX;
  adc_state->adc_dv_y = adc_state->adc_pos_view[Y] * GED_MAX;
}

static void
adc_grid_To_adc_view(void)
{
  point_t model_pt;
  point_t view_pt;

  VSETALL(model_pt, 0.0);
  MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, model_pt);
  VADD2(adc_state->adc_pos_view, view_pt, adc_state->adc_pos_grid);
  adc_state->adc_dv_x = adc_state->adc_pos_view[X] * GED_MAX;
  adc_state->adc_dv_y = adc_state->adc_pos_view[Y] * GED_MAX;
}

static void
adc_view_To_adc_grid(void)
{
  point_t model_pt;
  point_t view_pt;

  VSETALL(model_pt, 0.0);
  MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, model_pt);
  VSUB2(adc_state->adc_pos_grid, adc_state->adc_pos_view, view_pt);
}

static void
calc_adc_pos(void)
{
  if(adc_state->adc_anchor_pos == 1){
    adc_model_To_adc_view();
    adc_view_To_adc_grid();
  }else if(adc_state->adc_anchor_pos == 2){
    adc_grid_To_adc_view();
    MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_vop->vo_view2model, adc_state->adc_pos_view);
  }else{
    adc_view_To_adc_grid();
    MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_vop->vo_view2model, adc_state->adc_pos_view);
  }
}

static void
calc_adc_a1(void)
{
  if(adc_state->adc_anchor_a1){
    fastf_t dx, dy;
    point_t view_pt;

    MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, adc_state->adc_anchor_pt_a1);
    dx = view_pt[X] * GED_MAX - adc_state->adc_dv_x;
    dy = view_pt[Y] * GED_MAX - adc_state->adc_dv_y;

    if(dx != 0.0 || dy != 0.0){
      adc_state->adc_a1 = RAD2DEG*atan2(dy, dx);
      adc_state->adc_dv_a1 = (1.0 - (adc_state->adc_a1 / 45.0)) * GED_MAX;
    }
  }
}

static void
calc_adc_a2(void)
{
  if(adc_state->adc_anchor_a2){
    fastf_t dx, dy;
    point_t view_pt;

    MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, adc_state->adc_anchor_pt_a2);
    dx = view_pt[X] * GED_MAX - adc_state->adc_dv_x;
    dy = view_pt[Y] * GED_MAX - adc_state->adc_dv_y;

    if(dx != 0.0 || dy != 0.0){
      adc_state->adc_a2 = RAD2DEG*atan2(dy, dx);
      adc_state->adc_dv_a2 = (1.0 - (adc_state->adc_a2 / 45.0)) * GED_MAX;
    }
  }
}

static void
calc_adc_dst(void)
{
  if(adc_state->adc_anchor_dst){
    fastf_t dist;
    fastf_t dx, dy;
    point_t view_pt;

    MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, adc_state->adc_anchor_pt_dst);

    dx = view_pt[X] * GED_MAX - adc_state->adc_dv_x;
    dy = view_pt[Y] * GED_MAX - adc_state->adc_dv_y;
    dist = sqrt(dx * dx + dy * dy);
    adc_state->adc_dst = dist * INV_GED;
    adc_state->adc_dv_dist = (dist / M_SQRT2_DIV2) - GED_MAX;
  }else
    adc_state->adc_dst = (adc_state->adc_dv_dist * INV_GED + 1.0) * M_SQRT2_DIV2;
}

static void
draw_ticks(fastf_t angle)
{
  fastf_t c_tdist;
  fastf_t d1, d2;
  fastf_t t1, t2;
  fastf_t x1, Y1;       /* not "y1", due to conflict with math lib */
  fastf_t x2, y2;

  /*
   * Position tic marks from dial 9.
   */
  /* map -2048 - 2047 into 0 - 2048 * sqrt (2) */
  /* Tick distance */
  c_tdist = ((fastf_t)(adc_state->adc_dv_dist) + GED_MAX) * M_SQRT2_DIV2;

  d1 = c_tdist * cos (angle);
  d2 = c_tdist * sin (angle);
  t1 = 20.0 * sin (angle);
  t2 = 20.0 * cos (angle);

  /* Quadrant 1 */
  x1 = adc_state->adc_dv_x + d1 + t1;
  Y1 = adc_state->adc_dv_y + d2 - t2;
  x2 = adc_state->adc_dv_x + d1 -t1;
  y2 = adc_state->adc_dv_y + d2 + t2;
  if(clip(&x1, &Y1, &x2, &y2) == 0){
    DM_DRAW_LINE_2D(dmp, 
		    GED2PM1(x1), GED2PM1(Y1) * dmp->dm_aspect,
		    GED2PM1(x2), GED2PM1(y2) * dmp->dm_aspect);
  }

  /* Quadrant 2 */
  x1 = adc_state->adc_dv_x - d2 + t2;
  Y1 = adc_state->adc_dv_y + d1 + t1;
  x2 = adc_state->adc_dv_x - d2 - t2;
  y2 = adc_state->adc_dv_y + d1 - t1;
  if(clip (&x1, &Y1, &x2, &y2) == 0){
    DM_DRAW_LINE_2D(dmp,
		    GED2PM1(x1), GED2PM1(Y1) * dmp->dm_aspect,
		    GED2PM1(x2), GED2PM1(y2) * dmp->dm_aspect);
  }

  /* Quadrant 3 */
  x1 = adc_state->adc_dv_x - d1 - t1;
  Y1 = adc_state->adc_dv_y - d2 + t2;
  x2 = adc_state->adc_dv_x - d1 + t1;
  y2 = adc_state->adc_dv_y - d2 - t2;
  if(clip (&x1, &Y1, &x2, &y2) == 0){
    DM_DRAW_LINE_2D(dmp,
		    GED2PM1(x1), GED2PM1(Y1) * dmp->dm_aspect,
		    GED2PM1(x2), GED2PM1(y2) * dmp->dm_aspect);
  }

  /* Quadrant 4 */
  x1 = adc_state->adc_dv_x + d2 - t2;
  Y1 = adc_state->adc_dv_y - d1 - t1;
  x2 = adc_state->adc_dv_x + d2 + t2;
  y2 = adc_state->adc_dv_y - d1 + t1;
  if(clip (&x1, &Y1, &x2, &y2) == 0){
    DM_DRAW_LINE_2D(dmp,
		    GED2PM1(x1), GED2PM1(Y1) * dmp->dm_aspect,
		    GED2PM1(x2), GED2PM1(y2) * dmp->dm_aspect);
  }
}

/*
 *			A D C U R S O R
 *
 * Compute and display the angle/distance cursor.
 */
void
adcursor(void)
{
  fastf_t x1, Y1;	/* not "y1", due to conflict with math lib */
  fastf_t x2, y2;
  fastf_t x3, y3;
  fastf_t x4, y4;
  fastf_t d1, d2;
  fastf_t angle1, angle2;

  calc_adc_pos();
  calc_adc_a1();
  calc_adc_a2();
  calc_adc_dst();

  DM_SET_FGCOLOR(dmp,
		 color_scheme->cs_adc_line[0],
		 color_scheme->cs_adc_line[1],
		 color_scheme->cs_adc_line[2], 1, 1.0);
  DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 0);

  /* Horizontal */
  DM_DRAW_LINE_2D(dmp,
		  GED2PM1(GED_MIN), GED2PM1(adc_state->adc_dv_y) * dmp->dm_aspect,
		  GED2PM1(GED_MAX), GED2PM1(adc_state->adc_dv_y) * dmp->dm_aspect);

  /* Vertical */
  DM_DRAW_LINE_2D(dmp,
		  GED2PM1(adc_state->adc_dv_x), GED2PM1(GED_MAX),
		  GED2PM1(adc_state->adc_dv_x), GED2PM1(GED_MIN));

  angle1 = adc_state->adc_a1 * DEG2RAD;
  angle2 = adc_state->adc_a2 * DEG2RAD;

  /* sin for X and cos for Y to reverse sense of knob */
  d1 = cos (angle1) * 8000.0;
  d2 = sin (angle1) * 8000.0;
  x1 = adc_state->adc_dv_x + d1;
  Y1 = adc_state->adc_dv_y + d2;
  x2 = adc_state->adc_dv_x - d1;
  y2 = adc_state->adc_dv_y - d2;

  x3 = adc_state->adc_dv_x + d2;
  y3 = adc_state->adc_dv_y - d1;
  x4 = adc_state->adc_dv_x - d2;
  y4 = adc_state->adc_dv_y + d1;

  DM_DRAW_LINE_2D(dmp,
		  GED2PM1(x1), GED2PM1(Y1) * dmp->dm_aspect,
		  GED2PM1(x2), GED2PM1(y2) * dmp->dm_aspect);
  DM_DRAW_LINE_2D(dmp,
		  GED2PM1(x3), GED2PM1(y3) * dmp->dm_aspect,
		  GED2PM1(x4), GED2PM1(y4) * dmp->dm_aspect);

  d1 = cos(angle2) * 8000.0;
  d2 = sin(angle2) * 8000.0;
  x1 = adc_state->adc_dv_x + d1;
  Y1 = adc_state->adc_dv_y + d2;
  x2 = adc_state->adc_dv_x - d1;
  y2 = adc_state->adc_dv_y - d2;

  x3 = adc_state->adc_dv_x + d2;
  y3 = adc_state->adc_dv_y - d1;
  x4 = adc_state->adc_dv_x - d2;
  y4 = adc_state->adc_dv_y + d1;

  DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 1);
  DM_DRAW_LINE_2D(dmp,
		  GED2PM1(x1), GED2PM1(Y1) * dmp->dm_aspect,
		  GED2PM1(x2), GED2PM1(y2) * dmp->dm_aspect);
  DM_DRAW_LINE_2D(dmp,
		  GED2PM1(x3), GED2PM1(y3) * dmp->dm_aspect,
		  GED2PM1(x4), GED2PM1(y4) * dmp->dm_aspect);
  DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 0);

  DM_SET_FGCOLOR(dmp,
		 color_scheme->cs_adc_tick[0],
		 color_scheme->cs_adc_tick[1],
		 color_scheme->cs_adc_tick[2], 1, 1.0);
  draw_ticks(0.0);
  draw_ticks(angle1);
  draw_ticks(angle2);
}

static void
adc_reset(void)
{
  adc_state->adc_dv_x = adc_state->adc_dv_y = 0;
  adc_state->adc_dv_a1 = adc_state->adc_dv_a2 = 0;
  adc_state->adc_dv_dist = 0;

  VSETALL(adc_state->adc_pos_view, 0.0);
  MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_vop->vo_view2model, adc_state->adc_pos_view);
  adc_state->adc_dst = (adc_state->adc_dv_dist * INV_GED + 1.0) * M_SQRT2_DIV2;
  adc_state->adc_a1 = adc_state->adc_a2 = 45.0;
  adc_view_To_adc_grid();

  VSETALL(adc_state->adc_anchor_pt_a1, 0.0);
  VSETALL(adc_state->adc_anchor_pt_a2, 0.0);
  VSETALL(adc_state->adc_anchor_pt_dst, 0.0);

  adc_state->adc_anchor_pos = 0;
  adc_state->adc_anchor_a1 = 0;
  adc_state->adc_anchor_a2 = 0;
  adc_state->adc_anchor_dst = 0;
}

/*
 *			F _ A D C
 */

static char	adc_syntax[] = "\
 adc			toggle display of angle/distance cursor\n\
 adc vars		print a list of all variables (i.e. var = val)\n\
 adc draw [0|1]		set or get the draw parameter\n\
 adc a1 [#]		set or get angle1\n\
 adc a2 [#]		set or get angle2\n\
 adc dst [#]		set or get radius (distance) of tick\n\
 adc odst [#]		set or get radius (distance) of tick (+-2047)\n\
 adc hv [# #]		set or get position (grid coordinates)\n\
 adc xyz [# # #]	set or get position (model coordinates)\n\
 adc x [#]		set or get horizontal position (+-2047)\n\
 adc y [#]		set or get vertical position (+-2047)\n\
 adc dh #		add to horizontal position (grid coordinates)\n\
 adc dv #		add to vertical position (grid coordinates)\n\
 adc dx #		add to X position (model coordinates)\n\
 adc dy #		add to Y position (model coordinates)\n\
 adc dz #		add to Z position (model coordinates)\n\
 adc anchor_pos	[0|1]	anchor ADC to current position in model coordinates\n\
 adc anchor_a1	[0|1]	anchor angle1 to go through anchorpoint_a1\n\
 adc anchor_a2	[0|1]	anchor angle2 to go through anchorpoint_a2\n\
 adc anchor_dst	[0|1]	anchor tick distance to go through anchorpoint_dst\n\
 adc anchorpoint_a1 [# # #]	set or get anchor point for angle1\n\
 adc anchorpoint_a2 [# # #]	set or get anchor point for angle2\n\
 adc anchorpoint_dst [# # #]	set or get anchor point for tick distance\n\
 adc -i			any of the above appropriate commands will interpret parameters as increments\n\
 adc reset		reset angles, location, and tick distance\n\
 adc help		prints this help message\n\
";

int
f_adc (
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
  struct bu_vls vls;
  char *parameter;
  char **argp = argv;
  point_t user_pt;		/* Value(s) provided by user */
  point_t scaled_pos;
  int incr_flag;
  int i;

  CHECK_DBI_NULL;

  if(6 < argc){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help adc");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  if(argc == 1){
    if(adc_state->adc_draw)
      adc_state->adc_draw = 0;
    else
      adc_state->adc_draw = 1;

    if(adc_auto){
      adc_reset();
      adc_auto = 0;
    }

    adc_set_scroll();

    return TCL_OK;
  }

  if (strcmp(argv[1], "-i") == 0) {
	  if (argc < 4) {
		  bu_vls_init(&vls);
		  bu_vls_printf(&vls, "adc: -i option specified without an op-val pair");
		  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		  bu_vls_free(&vls);

		  return TCL_ERROR;
	  }

	  incr_flag = 1;
	  parameter = argv[2];
	  argc -= 3;
	  argp += 3;
  }else{
    incr_flag = 0;
    parameter = argv[1];
    argc -= 2;
    argp += 2;
  }

  for (i = 0; i < argc; ++i)
    user_pt[i] = atof(argp[i]);

  if(strcmp(parameter, "draw") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", adc_state->adc_draw);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      i = (int)user_pt[X];

      if(i)
	adc_state->adc_draw = 1;
      else
	adc_state->adc_draw = 0;

      adc_set_scroll();

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc draw' command accepts 0 or 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "a1") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.15e", adc_state->adc_a1);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      if(!adc_state->adc_anchor_a1){
	if(incr_flag)
	  adc_state->adc_a1 += user_pt[0];
	else
	  adc_state->adc_a1 = user_pt[0];

	adc_state->adc_dv_a1 = (1.0 - (adc_state->adc_a1 / 45.0)) * GED_MAX;
	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc a1' command accepts only 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "a2") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.15e", adc_state->adc_a2);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      if(!adc_state->adc_anchor_a2){
	if(incr_flag)
	  adc_state->adc_a2 += user_pt[0];
	else
	  adc_state->adc_a2 = user_pt[0];

	adc_state->adc_dv_a2 = (1.0 - (adc_state->adc_a2 / 45.0)) * GED_MAX;
	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc a2' command accepts 0 or 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "dst") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.15e", adc_state->adc_dst * view_state->vs_vop->vo_scale * base2local);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      if(!adc_state->adc_anchor_dst){
	if(incr_flag)
	  adc_state->adc_dst += user_pt[0] / (view_state->vs_vop->vo_scale * base2local);
	else
	  adc_state->adc_dst = user_pt[0] / (view_state->vs_vop->vo_scale * base2local);

	adc_state->adc_dv_dist = (adc_state->adc_dst / M_SQRT2_DIV2 - 1.0) * GED_MAX;

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc dst' command accepts 0 or 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "odst") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", adc_state->adc_dv_dist);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      if(!adc_state->adc_anchor_dst){
	if(incr_flag)
	  adc_state->adc_dv_dist += user_pt[0];
	else
	  adc_state->adc_dv_dist = user_pt[0];

	adc_state->adc_dst = (adc_state->adc_dv_dist * INV_GED + 1.0) * M_SQRT2_DIV2;
	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc odst' command accepts 0 or 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "dh") == 0){
    if(argc == 1){
      if(!adc_state->adc_anchor_pos){
	adc_state->adc_pos_grid[X] += user_pt[0] / (view_state->vs_vop->vo_scale * base2local);
	adc_grid_To_adc_view();
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_vop->vo_view2model, adc_state->adc_pos_view);

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc dh' command requires 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "dv") == 0){
    if(argc == 1){
      if(!adc_state->adc_anchor_pos){
	adc_state->adc_pos_grid[Y] += user_pt[0] / (view_state->vs_vop->vo_scale * base2local);
	adc_grid_To_adc_view();
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_vop->vo_view2model, adc_state->adc_pos_view);

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc dv' command requires 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "hv") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.15e %.15e",
		    adc_state->adc_pos_grid[X] * view_state->vs_vop->vo_scale * base2local,
		    adc_state->adc_pos_grid[Y] * view_state->vs_vop->vo_scale * base2local);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 2){
      if(!adc_state->adc_anchor_pos){
	if(incr_flag){
	  adc_state->adc_pos_grid[X] += user_pt[X] / (view_state->vs_vop->vo_scale * base2local);
	  adc_state->adc_pos_grid[Y] += user_pt[Y] / (view_state->vs_vop->vo_scale * base2local);
	}else{
	  adc_state->adc_pos_grid[X] = user_pt[X] / (view_state->vs_vop->vo_scale * base2local);
	  adc_state->adc_pos_grid[Y] = user_pt[Y] / (view_state->vs_vop->vo_scale * base2local);
	}

	adc_state->adc_pos_grid[Z] = 0.0;
	adc_grid_To_adc_view();
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_vop->vo_view2model, adc_state->adc_pos_model);

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc hv' command requires 0 or 2 arguments\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "dx") == 0){
    if(argc == 1){
      if(!adc_state->adc_anchor_pos){
	adc_state->adc_pos_model[X] += user_pt[0] * local2base;
	adc_model_To_adc_view();
	adc_view_To_adc_grid();

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc dx' command requires 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "dy") == 0){
    if(argc == 1){
      if(!adc_state->adc_anchor_pos){
	adc_state->adc_pos_model[Y] += user_pt[0] * local2base;
	adc_model_To_adc_view();
	adc_view_To_adc_grid();

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc dy' command requires 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "dz") == 0){
    if(argc == 1){
      if(!adc_state->adc_anchor_pos){
	adc_state->adc_pos_model[Z] += user_pt[0] * local2base;
	adc_model_To_adc_view();
	adc_view_To_adc_grid();

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc dz' command requires 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "xyz") == 0){
    if(argc == 0){
      VSCALE(scaled_pos, adc_state->adc_pos_model, base2local);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(scaled_pos));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 3) {
      VSCALE(user_pt, user_pt, local2base);

      if(incr_flag){
	VADD2(adc_state->adc_pos_model, adc_state->adc_pos_model, user_pt);
      }else{
	VMOVE(adc_state->adc_pos_model, user_pt);
      }

      adc_model_To_adc_view();
      adc_view_To_adc_grid();

      adc_set_dirty_flag();

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc xyz' command requires 0 or 3 arguments\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "x") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", adc_state->adc_dv_x);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1) {
      if(!adc_state->adc_anchor_pos){
	if(incr_flag){
	  adc_state->adc_dv_x += user_pt[0];
	}else{
	  adc_state->adc_dv_x = user_pt[0];
	}

	adc_state->adc_pos_view[X] = adc_state->adc_dv_x * INV_GED;
	adc_state->adc_pos_view[Y] = adc_state->adc_dv_y * INV_GED;
	adc_view_To_adc_grid();
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_vop->vo_view2model, adc_state->adc_pos_view);

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc x' command requires 0 or 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "y") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", adc_state->adc_dv_y);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1) {
      if(!adc_state->adc_anchor_pos){
	if(incr_flag){
	  adc_state->adc_dv_y += user_pt[0];
	}else{
	  adc_state->adc_dv_y = user_pt[0];
	}

	adc_state->adc_pos_view[X] = adc_state->adc_dv_x * INV_GED;
	adc_state->adc_pos_view[Y] = adc_state->adc_dv_y * INV_GED;
	adc_view_To_adc_grid();
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_vop->vo_view2model, adc_state->adc_pos_view);

	adc_set_dirty_flag();
      }

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc y' command requires 0 or 1 argument\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "anchor_pos") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", adc_state->adc_anchor_pos);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      i = (int)user_pt[X];

      if(i < 0 || 2 < i){
	Tcl_AppendResult(interp, "The 'adc anchor_pos parameter accepts values of 0, 1, or 2.",
			 (char *)NULL);
	return TCL_ERROR;
      }

      adc_state->adc_anchor_pos = i;

      calc_adc_pos();
      adc_set_dirty_flag();
      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc anchor_pos' command accepts 0 or 1 argument\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "anchor_a1") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", adc_state->adc_anchor_a1);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      i = (int)user_pt[X];

      if(i)
	adc_state->adc_anchor_a1 = 1;
      else
	adc_state->adc_anchor_a1 = 0;

      calc_adc_a1();
      adc_set_dirty_flag();
      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc anchor_a1' command accepts 0 or 1 argument\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "anchorpoint_a1") == 0){
    if(argc == 0){
      VSCALE(scaled_pos, adc_state->adc_anchor_pt_a1, base2local);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(scaled_pos));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 3){
      VSCALE(user_pt, user_pt, local2base);

      if(incr_flag){
	VADD2(adc_state->adc_anchor_pt_a1, adc_state->adc_anchor_pt_a1, user_pt);
      }else{
	VMOVE(adc_state->adc_anchor_pt_a1, user_pt);
      }

      calc_adc_a1();
      adc_set_dirty_flag();
      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc anchorpoint_a1' command accepts 0 or 3 arguments\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "anchor_a2") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", adc_state->adc_anchor_a2);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      i = (int)user_pt[X];

      if(i)
	adc_state->adc_anchor_a2 = 1;
      else
	adc_state->adc_anchor_a2 = 0;

      calc_adc_a2();
      adc_set_dirty_flag();
      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc anchor_a2' command accepts 0 or 1 argument\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "anchorpoint_a2") == 0){
    if(argc == 0){
      VSCALE(scaled_pos, adc_state->adc_anchor_pt_a2, base2local);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(scaled_pos));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 3){
      VSCALE(user_pt, user_pt, local2base);

      if(incr_flag){
	VADD2(adc_state->adc_anchor_pt_a2, adc_state->adc_anchor_pt_a2, user_pt);
      }else{
	VMOVE(adc_state->adc_anchor_pt_a2, user_pt);
      }

      calc_adc_a2();
      adc_set_dirty_flag();
      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc anchorpoint_a2' command accepts 0 or 3 arguments\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "anchor_dst") == 0){
    if(argc == 0){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", adc_state->adc_anchor_dst);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 1){
      i = (int)user_pt[X];

      if(i){
	adc_state->adc_anchor_dst = 1;
      }else
	adc_state->adc_anchor_dst = 0;

      calc_adc_dst();
      adc_set_dirty_flag();
      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc anchor_dst' command accepts 0 or 1 argument\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "anchorpoint_dst") == 0){
    if(argc == 0){
      VSCALE(scaled_pos, adc_state->adc_anchor_pt_dst, base2local);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(scaled_pos));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }else if(argc == 3){
      VSCALE(user_pt, user_pt, local2base);

      if(incr_flag){
	VADD2(adc_state->adc_anchor_pt_dst, adc_state->adc_anchor_pt_dst, user_pt);
      }else{
	VMOVE(adc_state->adc_anchor_pt_dst, user_pt);
      }

      calc_adc_dst();
      adc_set_dirty_flag();
      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc anchorpoint_dst' command accepts 0 or 3 arguments\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "reset") == 0){
    if (argc == 0) {
      adc_reset();

      adc_set_dirty_flag();
      return TCL_OK;
    }

    Tcl_AppendResult(interp, "The 'adc reset' command accepts no arguments\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(strcmp(parameter, "vars") == 0){
    adc_print_vars();
    return TCL_OK;
  }

  if(strcmp(parameter, "help") == 0){
    Tcl_AppendResult(interp, "Usage:\n", adc_syntax, (char *)NULL);
    return TCL_OK;
  }

  Tcl_AppendResult(interp, "ADC: unrecognized command: '",
		   argv[1], "'\nUsage:\n", adc_syntax, (char *)NULL);
  return TCL_ERROR;
}

static void
adc_print_vars(void)
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "draw = %d\n", adc_state->adc_draw);
  bu_vls_printf(&vls, "a1 = %.15e\n", adc_state->adc_a1);
  bu_vls_printf(&vls, "a2 = %.15e\n", adc_state->adc_a2);
  bu_vls_printf(&vls, "dst = %.15e\n", adc_state->adc_dst * view_state->vs_vop->vo_scale * base2local);
  bu_vls_printf(&vls, "odst = %d\n", adc_state->adc_dv_dist);
  bu_vls_printf(&vls, "hv = %.15e %.15e\n",
		adc_state->adc_pos_grid[X] * view_state->vs_vop->vo_scale * base2local,
		adc_state->adc_pos_grid[Y] * view_state->vs_vop->vo_scale * base2local);
  bu_vls_printf(&vls, "xyz = %.15e %.15e %.15e\n",
		adc_state->adc_pos_model[X] * base2local,
		adc_state->adc_pos_model[Y] * base2local,
		adc_state->adc_pos_model[Z] * base2local);
  bu_vls_printf(&vls, "x = %d\n", adc_state->adc_dv_x);
  bu_vls_printf(&vls, "y = %d\n", adc_state->adc_dv_y);
  bu_vls_printf(&vls, "anchor_pos = %d\n", adc_state->adc_anchor_pos);
  bu_vls_printf(&vls, "anchor_a1 = %d\n", adc_state->adc_anchor_a1);
  bu_vls_printf(&vls, "anchor_a2 = %d\n", adc_state->adc_anchor_a2);
  bu_vls_printf(&vls, "anchor_dst = %d\n", adc_state->adc_anchor_dst);
  bu_vls_printf(&vls, "anchorpoint_a1 = %.15e %.15e %.15e\n",
		adc_state->adc_anchor_pt_a1[X] * base2local,
		adc_state->adc_anchor_pt_a1[Y] * base2local,
		adc_state->adc_anchor_pt_a1[Z] * base2local);
  bu_vls_printf(&vls, "anchorpoint_a2 = %.15e %.15e %.15e\n",
		adc_state->adc_anchor_pt_a2[X] * base2local,
		adc_state->adc_anchor_pt_a2[Y] * base2local,
		adc_state->adc_anchor_pt_a2[Z] * base2local);
  bu_vls_printf(&vls, "anchorpoint_dst = %.15e %.15e %.15e\n",
		adc_state->adc_anchor_pt_dst[X] * base2local,
		adc_state->adc_anchor_pt_dst[Y] * base2local,
		adc_state->adc_anchor_pt_dst[Z] * base2local);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
}
@


11.54
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/adc.c,v 11.53 2004/05/10 15:25:28 morrison Exp $ (BRL)";
@


11.53
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.52 2004/04/05 09:09:11 morrison Exp $ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.52
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d274 1
a274 1
		 color_scheme->cs_adc_line[2], 1);
d334 1
a334 1
		 color_scheme->cs_adc_tick[2], 1);
@


11.51
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.50 2002/08/20 17:08:20 jra Exp $ (BRL)";
d53 1
a53 1
static void adc_print_vars();
d56 1
a56 1
adc_set_dirty_flag()
d66 1
a66 1
adc_set_scroll()
d84 1
a84 1
adc_model_To_adc_view()
d92 1
a92 1
adc_grid_To_adc_view()
d105 1
a105 1
adc_view_To_adc_grid()
d116 1
a116 1
calc_adc_pos()
d131 1
a131 1
calc_adc_a1()
d149 1
a149 1
calc_adc_a2()
d167 1
a167 1
calc_adc_dst()
d186 1
a186 2
draw_ticks(angle)
fastf_t angle;
d257 1
a257 1
adcursor()
d341 1
a341 1
adc_reset()
d1026 1
a1026 1
adc_print_vars()
@


11.50
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.48 2001/06/05 15:51:40 bparker Exp $ (BRL)";
@


11.50.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/adc.c,v 11.51 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.50.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.51 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.50.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.50.10.1 2004/02/12 18:34:12 erikg Exp $ (BRL)";
@


11.50.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.50 2002/08/20 17:08:20 jra Exp $ (BRL)";
d53 1
a53 1
static void adc_print_vars(void);
d56 1
a56 1
adc_set_dirty_flag(void)
d66 1
a66 1
adc_set_scroll(void)
d84 1
a84 1
adc_model_To_adc_view(void)
d92 1
a92 1
adc_grid_To_adc_view(void)
d105 1
a105 1
adc_view_To_adc_grid(void)
d116 1
a116 1
calc_adc_pos(void)
d131 1
a131 1
calc_adc_a1(void)
d149 1
a149 1
calc_adc_a2(void)
d167 1
a167 1
calc_adc_dst(void)
d186 2
a187 1
draw_ticks(fastf_t angle)
d258 1
a258 1
adcursor(void)
d342 1
a342 1
adc_reset(void)
d1027 1
a1027 1
adc_print_vars(void)
@


11.50.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.49
log
@Converted from K&R to ANSI C - RFH
@
text
@d53 1
a53 1
static void adc_print_vars(void);
d56 1
a56 1
adc_set_dirty_flag(void)
d66 1
a66 1
adc_set_scroll(void)
d84 1
a84 1
adc_model_To_adc_view(void)
d92 1
a92 1
adc_grid_To_adc_view(void)
d105 1
a105 1
adc_view_To_adc_grid(void)
d116 1
a116 1
calc_adc_pos(void)
d131 1
a131 1
calc_adc_a1(void)
d149 1
a149 1
calc_adc_a2(void)
d167 1
a167 1
calc_adc_dst(void)
d186 2
a187 1
draw_ticks(fastf_t angle)
d258 1
a258 1
adcursor(void)
d342 1
a342 1
adc_reset(void)
d1027 1
a1027 1
adc_print_vars(void)
@


11.48
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.47 2001/06/01 19:23:22 bparker Exp $ (BRL)";
d53 1
a53 1
static void adc_print_vars();
d56 1
a56 1
adc_set_dirty_flag()
d66 1
a66 1
adc_set_scroll()
d84 1
a84 1
adc_model_To_adc_view()
d92 1
a92 1
adc_grid_To_adc_view()
d105 1
a105 1
adc_view_To_adc_grid()
d116 1
a116 1
calc_adc_pos()
d131 1
a131 1
calc_adc_a1()
d149 1
a149 1
calc_adc_a2()
d167 1
a167 1
calc_adc_dst()
d186 1
a186 2
draw_ticks(angle)
fastf_t angle;
d257 1
a257 1
adcursor()
d341 1
a341 1
adc_reset()
d1026 1
a1026 1
adc_print_vars()
@


11.47
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.46 2001/04/02 19:08:56 jra Exp $ (BRL)";
a85 1
#ifdef MGED_USE_VIEW_OBJ
a86 3
#else
  MAT4X3PNT(adc_state->adc_pos_view, view_state->vs_model2view, adc_state->adc_pos_model);
#endif
a97 1
#ifdef MGED_USE_VIEW_OBJ
a98 3
#else
  MAT4X3PNT(view_pt, view_state->vs_model2view, model_pt);
#endif
a110 1
#ifdef MGED_USE_VIEW_OBJ
a111 3
#else
  MAT4X3PNT(view_pt, view_state->vs_model2view, model_pt);
#endif
a122 1
#ifdef MGED_USE_VIEW_OBJ
a127 7
#else
    MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_view2model, adc_state->adc_pos_view);
  }else{
    adc_view_To_adc_grid();
    MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_view2model, adc_state->adc_pos_view);
  }
#endif
a136 1
#ifdef MGED_USE_VIEW_OBJ
a137 3
#else
    MAT4X3PNT(view_pt, view_state->vs_model2view, adc_state->adc_anchor_pt_a1);
#endif
a154 1
#ifdef MGED_USE_VIEW_OBJ
a155 3
#else
    MAT4X3PNT(view_pt, view_state->vs_model2view, adc_state->adc_anchor_pt_a2);
#endif
a173 1
#ifdef MGED_USE_VIEW_OBJ
a174 3
#else
    MAT4X3PNT(view_pt, view_state->vs_model2view, adc_state->adc_anchor_pt_dst);
#endif
a348 1
#ifdef MGED_USE_VIEW_OBJ
a349 3
#else
  MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_view2model, adc_state->adc_pos_view);
#endif
a542 1
#ifdef MGED_USE_VIEW_OBJ
a543 3
#else
      bu_vls_printf(&vls, "%.15e", adc_state->adc_dst * view_state->vs_Viewscale * base2local);
#endif
a549 1
#ifdef MGED_USE_VIEW_OBJ
a553 6
#else
	if(incr_flag)
	  adc_state->adc_dst += user_pt[0] / (view_state->vs_Viewscale * base2local);
	else
	  adc_state->adc_dst = user_pt[0] / (view_state->vs_Viewscale * base2local);
#endif
a595 1
#ifdef MGED_USE_VIEW_OBJ
a598 5
#else
	adc_state->adc_pos_grid[X] += user_pt[0] / (view_state->vs_Viewscale * base2local);
	adc_grid_To_adc_view();
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_view2model, adc_state->adc_pos_view);
#endif
a612 1
#ifdef MGED_USE_VIEW_OBJ
a615 5
#else
	adc_state->adc_pos_grid[Y] += user_pt[0] / (view_state->vs_Viewscale * base2local);
	adc_grid_To_adc_view();
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_view2model, adc_state->adc_pos_view);
#endif
a629 1
#ifdef MGED_USE_VIEW_OBJ
a632 5
#else
      bu_vls_printf(&vls, "%.15e %.15e",
		    adc_state->adc_pos_grid[X] * view_state->vs_Viewscale * base2local,
		    adc_state->adc_pos_grid[Y] * view_state->vs_Viewscale * base2local);
#endif
a638 1
#ifdef MGED_USE_VIEW_OBJ
a649 13
#else
	if(incr_flag){
	  adc_state->adc_pos_grid[X] += user_pt[X] / (view_state->vs_Viewscale * base2local);
	  adc_state->adc_pos_grid[Y] += user_pt[Y] / (view_state->vs_Viewscale * base2local);
	}else{
	  adc_state->adc_pos_grid[X] = user_pt[X] / (view_state->vs_Viewscale * base2local);
	  adc_state->adc_pos_grid[Y] = user_pt[Y] / (view_state->vs_Viewscale * base2local);
	}

	adc_state->adc_pos_grid[Z] = 0.0;
	adc_grid_To_adc_view();
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_view2model, adc_state->adc_pos_model);
#endif
a761 1
#ifdef MGED_USE_VIEW_OBJ
a762 3
#else
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_view2model, adc_state->adc_pos_view);
#endif
a792 1
#ifdef MGED_USE_VIEW_OBJ
a793 3
#else
	MAT4X3PNT(adc_state->adc_pos_model, view_state->vs_view2model, adc_state->adc_pos_view);
#endif
a1034 1
#ifdef MGED_USE_VIEW_OBJ
a1039 7
#else
  bu_vls_printf(&vls, "dst = %.15e\n", adc_state->adc_dst * view_state->vs_Viewscale * base2local);
  bu_vls_printf(&vls, "odst = %d\n", adc_state->adc_dv_dist);
  bu_vls_printf(&vls, "hv = %.15e %.15e\n",
		adc_state->adc_pos_grid[X] * view_state->vs_Viewscale * base2local,
		adc_state->adc_pos_grid[Y] * view_state->vs_Viewscale * base2local);
#endif
@


11.46
log
@Lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.45 2000/09/07 02:23:41 mike Exp $ (BRL)";
d86 3
d90 1
d102 3
d106 1
d119 3
d123 1
d135 7
d147 1
d157 3
d161 1
d179 3
d183 1
d202 3
d206 1
d381 3
d385 1
d475 14
a488 5
  if(strcmp(argv[1], "-i") == 0){
    incr_flag = 1;
    parameter = argv[2];
    argc -= 3;
    argp += 3;
d579 3
d583 1
d590 6
d600 1
d643 5
d651 1
d666 5
d674 1
d689 5
d697 1
d704 13
d728 1
d841 3
d845 1
d876 3
d880 1
d1122 7
d1134 1
@


11.45
log
@
Added externs to ged.h to fix lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.44 2000/08/19 03:10:37 mike Exp $ (BRL)";
d30 7
@


11.44
log
@
const RCSid
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.43 1999/12/30 19:40:50 jra Exp $ (BRL)";
d391 5
a395 5
f_adc (clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.43
log
@Eliminated some unused variables
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.42 1999/09/01 18:55:08 bparker Exp $ (BRL)";
@


11.42
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.41 1999/02/17 19:37:32 bparker Exp $ (BRL)";
a99 1
  fastf_t f;
a126 1
    fastf_t angle;
a144 1
    fastf_t angle;
a257 1
  fastf_t t1, t2;
a258 1
  long idxy[2];
a399 2
  point_t view_pt;
  point_t model_pt;
a400 1
  point_t diff;
@


11.41
log
@*- mods to usage string
*- mods to adc_print_vars()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.40 1998/12/18 22:05:34 bparker Exp $ (BRL)";
d413 1
a413 2
  if(dbip == DBI_NULL)
    return TCL_OK;
@


11.40
log
@*- allow setting of xyz whether or not anchoring is enabled
*- more mods to draw adc in non-square windows
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.39 1998/11/06 21:50:25 bparker Exp $ (BRL)";
d369 1
a369 1
 adc draw [#]		set or get the draw parameter\n\
d383 4
a386 4
 adc anchor_pos		anchor ADC to current position in model coordinates\n\
 adc anchor_a1		anchor angle1 to go through anchorpoint_a1\n\
 adc anchor_a2		anchor angle2 to go through anchorpoint_a2\n\
 adc anchor_dst		anchor tick distance to go through anchorpoint_dst\n\
d1028 11
a1038 3
  bu_vls_printf(&vls, "dst = %.15e\n", adc_state->adc_dst);
  bu_vls_printf(&vls, "hv = %.15e %.15e\n", adc_state->adc_pos_grid[X], adc_state->adc_pos_grid[Y]);
  bu_vls_printf(&vls, "xyz = %.15e %.15e %.15e\n", V3ARGS(adc_state->adc_pos_model));
d1043 12
a1054 3
  bu_vls_printf(&vls, "anchorpoint_a1 = %.15e %.15e %.15e\n", V3ARGS(adc_state->adc_anchor_pt_a1));
  bu_vls_printf(&vls, "anchorpoint_a2 = %.15e %.15e %.15e\n", V3ARGS(adc_state->adc_anchor_pt_a2));
  bu_vls_printf(&vls, "anchorpoint_dst = %.15e %.15e %.15e\n", V3ARGS(adc_state->adc_anchor_pt_dst));
@


11.39
log
@*- use new structures
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.38 1998/10/21 17:34:55 bparker Exp $ (BRL)";
d275 2
d278 4
a281 2
		  GED2PM1(GED_MIN), GED2PM1(adc_state->adc_dv_y),
		  GED2PM1(GED_MAX), GED2PM1(adc_state->adc_dv_y)); /* Horizontal */
d284 1
a284 1
		  GED2PM1(adc_state->adc_dv_x), GED2PM1(GED_MIN));  /* Vertical */
d716 1
a716 2
      if(!adc_state->adc_anchor_pos){
	VSCALE(user_pt, user_pt, local2base);
d718 5
a722 5
	if(incr_flag){
	  VADD2(adc_state->adc_pos_model, adc_state->adc_pos_model, user_pt);
	}else{
	  VMOVE(adc_state->adc_pos_model, user_pt);
	}
d724 2
a725 2
	adc_model_To_adc_view();
	adc_view_To_adc_grid();
d727 1
a727 2
	adc_set_dirty_flag();
      }
@


11.38
log
@*- use color scheme variables
*- use macros in place of common literals
*- put back old options x, y
	-not for user consumption
*- add "odst" option to allow dv_distadc to be set directly
	-not for user consumption
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/adc.c,v 11.37 1998/06/12 19:46:18 bparker Exp $ (BRL)";
d48 28
d79 3
a81 3
  MAT4X3PNT(adc_pos_view, model2view, adc_pos_model);
  dv_xadc = adc_pos_view[X] * GED_MAX;
  dv_yadc = adc_pos_view[Y] * GED_MAX;
d91 4
a94 4
  MAT4X3PNT(view_pt, model2view, model_pt);
  VADD2(adc_pos_view, view_pt, adc_pos_grid);
  dv_xadc = adc_pos_view[X] * GED_MAX;
  dv_yadc = adc_pos_view[Y] * GED_MAX;
d105 2
a106 2
  MAT4X3PNT(view_pt, model2view, model_pt);
  VSUB2(adc_pos_grid, adc_pos_view, view_pt);
d112 1
a112 1
  if(adc_anchor_pos == 1){
d115 1
a115 1
  }else if(adc_anchor_pos == 2){
d117 1
a117 1
    MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
d120 1
a120 1
    MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
d127 1
a127 1
  if(adc_anchor_a1){
d132 3
a134 3
    MAT4X3PNT(view_pt, model2view, adc_anchor_pt_a1);
    dx = view_pt[X] * GED_MAX - dv_xadc;
    dy = view_pt[Y] * GED_MAX - dv_yadc;
d137 2
a138 2
      adc_a1 = RAD2DEG*atan2(dy, dx);
      dv_1adc = (1.0 - (adc_a1 / 45.0)) * GED_MAX;
d146 1
a146 1
  if(adc_anchor_a2){
d151 3
a153 3
    MAT4X3PNT(view_pt, model2view, adc_anchor_pt_a2);
    dx = view_pt[X] * GED_MAX - dv_xadc;
    dy = view_pt[Y] * GED_MAX - dv_yadc;
d156 2
a157 2
      adc_a2 = RAD2DEG*atan2(dy, dx);
      dv_2adc = (1.0 - (adc_a2 / 45.0)) * GED_MAX;
d165 1
a165 1
  if(adc_anchor_dst){
d170 1
a170 1
    MAT4X3PNT(view_pt, model2view, adc_anchor_pt_dst);
d172 2
a173 2
    dx = view_pt[X] * GED_MAX - dv_xadc;
    dy = view_pt[Y] * GED_MAX - dv_yadc;
d175 2
a176 2
    adc_dst = dist * INV_GED;
    dv_distadc = (dist / M_SQRT2_DIV2) - GED_MAX;
d178 1
a178 1
    adc_dst = (dv_distadc * INV_GED + 1.0) * M_SQRT2_DIV2;
d196 1
a196 1
  c_tdist = ((fastf_t)(dv_distadc) + GED_MAX) * M_SQRT2_DIV2;
d204 4
a207 4
  x1 = dv_xadc + d1 + t1;
  Y1 = dv_yadc + d2 - t2;
  x2 = dv_xadc + d1 -t1;
  y2 = dv_yadc + d2 + t2;
d215 4
a218 4
  x1 = dv_xadc - d2 + t2;
  Y1 = dv_yadc + d1 + t1;
  x2 = dv_xadc - d2 - t2;
  y2 = dv_yadc + d1 - t1;
d226 4
a229 4
  x1 = dv_xadc - d1 - t1;
  Y1 = dv_yadc - d2 + t2;
  x2 = dv_xadc - d1 + t1;
  y2 = dv_yadc - d2 - t2;
d237 4
a240 4
  x1 = dv_xadc + d2 - t2;
  Y1 = dv_yadc - d1 - t1;
  x2 = dv_xadc + d2 + t2;
  y2 = dv_yadc - d1 + t1;
d271 4
a274 4
		 color_scheme->adc_line[0],
		 color_scheme->adc_line[1],
		 color_scheme->adc_line[2], 1);
  DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
d276 2
a277 2
		  GED2PM1(GED_MIN), GED2PM1(dv_yadc),
		  GED2PM1(GED_MAX), GED2PM1(dv_yadc)); /* Horizontal */
d279 2
a280 2
		  GED2PM1(dv_xadc), GED2PM1(GED_MAX),
		  GED2PM1(dv_xadc), GED2PM1(GED_MIN));  /* Vertical */
d282 2
a283 2
  angle1 = adc_a1 * DEG2RAD;
  angle2 = adc_a2 * DEG2RAD;
d288 9
a296 9
  x1 = dv_xadc + d1;
  Y1 = dv_yadc + d2;
  x2 = dv_xadc - d1;
  y2 = dv_yadc - d2;

  x3 = dv_xadc + d2;
  y3 = dv_yadc - d1;
  x4 = dv_xadc - d2;
  y4 = dv_yadc + d1;
d307 9
a315 9
  x1 = dv_xadc + d1;
  Y1 = dv_yadc + d2;
  x2 = dv_xadc - d1;
  y2 = dv_yadc - d2;

  x3 = dv_xadc + d2;
  y3 = dv_yadc - d1;
  x4 = dv_xadc - d2;
  y4 = dv_yadc + d1;
d317 1
a317 1
  DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 1);
d324 1
a324 1
  DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
d327 3
a329 3
		 color_scheme->adc_tick[0],
		 color_scheme->adc_tick[1],
		 color_scheme->adc_tick[2], 1);
d338 8
a345 8
  dv_xadc = dv_yadc = 0;
  dv_1adc = dv_2adc = 0;
  dv_distadc = 0;

  VSETALL(adc_pos_view, 0.0);
  MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
  adc_dst = (dv_distadc * INV_GED + 1.0) * M_SQRT2_DIV2;
  adc_a1 = adc_a2 = 45.0;
d348 8
a355 8
  VSETALL(adc_anchor_pt_a1, 0.0);
  VSETALL(adc_anchor_pt_a2, 0.0);
  VSETALL(adc_anchor_pt_dst, 0.0);

  adc_anchor_pos = 0;
  adc_anchor_a1 = 0;
  adc_anchor_a2 = 0;
  adc_anchor_dst = 0;
d369 1
d372 2
d422 2
a423 2
    if(adc_draw)
      adc_draw = 0;
d425 1
a425 1
      adc_draw = 1;
d432 2
a433 1
    set_scroll();
d455 1
a455 1
      bu_vls_printf(&vls, "%d", adc_draw);
d464 1
a464 1
	adc_draw = 1;
d466 3
a468 1
	adc_draw = 0;
a469 1
      set_scroll();
d480 1
a480 1
      bu_vls_printf(&vls, "%.15e", adc_a1);
d486 1
a486 1
      if(!adc_anchor_a1){
d488 1
a488 1
	  adc_a1 += user_pt[0];
d490 1
a490 1
	  adc_a1 = user_pt[0];
d492 2
a493 2
	dv_1adc = (1.0 - (adc_a1 / 45.0)) * GED_MAX;
	dirty = 1;
d506 1
a506 1
      bu_vls_printf(&vls, "%.15e", adc_a2);
d512 1
a512 1
      if(!adc_anchor_a2){
d514 1
a514 1
	  adc_a2 += user_pt[0];
d516 1
a516 1
	  adc_a2 = user_pt[0];
d518 2
a519 2
	dv_2adc = (1.0 - (adc_a2 / 45.0)) * GED_MAX;
	dirty = 1;
d532 1
a532 1
      bu_vls_printf(&vls, "%.15e", adc_dst * Viewscale * base2local);
d538 1
a538 1
      if(!adc_anchor_dst){
d540 1
a540 1
	  adc_dst += user_pt[0] / (Viewscale * base2local);
d542 1
a542 1
	  adc_dst = user_pt[0] / (Viewscale * base2local);
d544 1
a544 1
	dv_distadc = (adc_dst / M_SQRT2_DIV2 - 1.0) * GED_MAX;
d546 1
a546 1
	dirty = 1;
d559 1
a559 1
      bu_vls_printf(&vls, "%d", dv_distadc);
d565 1
a565 1
      if(!adc_anchor_dst){
d567 1
a567 1
	  dv_distadc += user_pt[0];
d569 1
a569 1
	  dv_distadc = user_pt[0];
d571 2
a572 2
	adc_dst = (dv_distadc * INV_GED + 1.0) * M_SQRT2_DIV2;
	dirty = 1;
d584 2
a585 2
      if(!adc_anchor_pos){
	adc_pos_grid[X] += user_pt[0] / (Viewscale * base2local);
d587 1
a587 1
	MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
d589 1
a589 1
	dirty = 1;
d601 2
a602 2
      if(!adc_anchor_pos){
	adc_pos_grid[Y] += user_pt[0] / (Viewscale * base2local);
d604 1
a604 1
	MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
d606 1
a606 1
	dirty = 1;
d620 2
a621 2
		    adc_pos_grid[X] * Viewscale * base2local,
		    adc_pos_grid[Y] * Viewscale * base2local);
d627 1
a627 1
      if(!adc_anchor_pos){
d629 2
a630 2
	  adc_pos_grid[X] += user_pt[X] / (Viewscale * base2local);
	  adc_pos_grid[Y] += user_pt[Y] / (Viewscale * base2local);
d632 2
a633 2
	  adc_pos_grid[X] = user_pt[X] / (Viewscale * base2local);
	  adc_pos_grid[Y] = user_pt[Y] / (Viewscale * base2local);
d636 1
a636 1
	adc_pos_grid[Z] = 0.0;
d638 1
a638 1
	MAT4X3PNT(adc_pos_model, view2model, adc_pos_model);
d640 1
a640 1
	dirty = 1;
d652 2
a653 2
      if(!adc_anchor_pos){
	adc_pos_model[X] += user_pt[0] * local2base;
d657 1
a657 1
	dirty = 1;
d669 2
a670 2
      if(!adc_anchor_pos){
	adc_pos_model[Y] += user_pt[0] * local2base;
d674 1
a674 1
	dirty = 1;
d686 2
a687 2
      if(!adc_anchor_pos){
	adc_pos_model[Z] += user_pt[0] * local2base;
d691 1
a691 1
	dirty = 1;
d703 1
a703 1
      VSCALE(scaled_pos, adc_pos_model, base2local);
d712 1
a712 1
      if(!adc_anchor_pos){
d716 1
a716 1
	  VADD2(adc_pos_model, adc_pos_model, user_pt);
d718 1
a718 1
	  VMOVE(adc_pos_model, user_pt);
d724 1
a724 1
	dirty = 1;
d737 1
a737 1
      bu_vls_printf(&vls, "%d", dv_xadc);
d743 1
a743 1
      if(!adc_anchor_pos){
d745 1
a745 1
	  dv_xadc += user_pt[0];
d747 1
a747 1
	  dv_xadc = user_pt[0];
d750 2
a751 2
	adc_pos_view[X] = dv_xadc * INV_GED;
	adc_pos_view[Y] = dv_yadc * INV_GED;
d753 1
a753 1
	MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
d755 1
a755 1
	dirty = 1;
d768 1
a768 1
      bu_vls_printf(&vls, "%d", dv_yadc);
d774 1
a774 1
      if(!adc_anchor_pos){
d776 1
a776 1
	  dv_yadc += user_pt[0];
d778 1
a778 1
	  dv_yadc = user_pt[0];
d781 2
a782 2
	adc_pos_view[X] = dv_xadc * INV_GED;
	adc_pos_view[Y] = dv_yadc * INV_GED;
d784 1
a784 1
	MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
d786 1
a786 1
	dirty = 1;
d799 1
a799 1
      bu_vls_printf(&vls, "%d", adc_anchor_pos);
d813 1
a813 1
      adc_anchor_pos = i;
d816 1
a816 1
      dirty = 1;
d828 1
a828 1
      bu_vls_printf(&vls, "%d", adc_anchor_a1);
d837 1
a837 1
	adc_anchor_a1 = 1;
d839 1
a839 1
	adc_anchor_a1 = 0;
d842 1
a842 1
      dirty = 1;
d853 1
a853 1
      VSCALE(scaled_pos, adc_anchor_pt_a1, base2local);
d865 1
a865 1
	VADD2(adc_anchor_pt_a1, adc_anchor_pt_a1, user_pt);
d867 1
a867 1
	VMOVE(adc_anchor_pt_a1, user_pt);
d871 1
a871 1
      dirty = 1;
d883 1
a883 1
      bu_vls_printf(&vls, "%d", adc_anchor_a2);
d892 1
a892 1
	adc_anchor_a2 = 1;
d894 1
a894 1
	adc_anchor_a2 = 0;
d897 1
a897 1
      dirty = 1;
d908 1
a908 1
      VSCALE(scaled_pos, adc_anchor_pt_a2, base2local);
d920 1
a920 1
	VADD2(adc_anchor_pt_a2, adc_anchor_pt_a2, user_pt);
d922 1
a922 1
	VMOVE(adc_anchor_pt_a2, user_pt);
d926 1
a926 1
      dirty = 1;
d938 1
a938 1
      bu_vls_printf(&vls, "%d", adc_anchor_dst);
d947 1
a947 1
	adc_anchor_dst = 1;
d949 1
a949 1
	adc_anchor_dst = 0;
d952 1
a952 1
      dirty = 1;
d963 1
a963 1
      VSCALE(scaled_pos, adc_anchor_pt_dst, base2local);
d975 1
a975 1
	VADD2(adc_anchor_pt_dst, adc_anchor_pt_dst, user_pt);
d977 1
a977 1
	VMOVE(adc_anchor_pt_dst, user_pt);
d981 1
a981 1
      dirty = 1;
d994 1
a994 1
      dirty = 1;
d1023 13
a1035 13
  bu_vls_printf(&vls, "draw = %d\n", adc_draw);
  bu_vls_printf(&vls, "a1 = %.15e\n", adc_a1);
  bu_vls_printf(&vls, "a2 = %.15e\n", adc_a2);
  bu_vls_printf(&vls, "dst = %.15e\n", adc_dst);
  bu_vls_printf(&vls, "hv = %.15e %.15e\n", adc_pos_grid[X], adc_pos_grid[Y]);
  bu_vls_printf(&vls, "xyz = %.15e %.15e %.15e\n", V3ARGS(adc_pos_model));
  bu_vls_printf(&vls, "anchor_pos = %d\n", adc_anchor_pos);
  bu_vls_printf(&vls, "anchor_a1 = %d\n", adc_anchor_a1);
  bu_vls_printf(&vls, "anchor_a2 = %d\n", adc_anchor_a2);
  bu_vls_printf(&vls, "anchor_dst = %d\n", adc_anchor_dst);
  bu_vls_printf(&vls, "anchorpoint_a1 = %.15e %.15e %.15e\n", V3ARGS(adc_anchor_pt_a1));
  bu_vls_printf(&vls, "anchorpoint_a2 = %.15e %.15e %.15e\n", V3ARGS(adc_anchor_pt_a2));
  bu_vls_printf(&vls, "anchorpoint_dst = %.15e %.15e %.15e\n", V3ARGS(adc_anchor_pt_dst));
@


11.37
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/adc.c,v 11.36 1998/06/11 19:32:07 bparker Exp $ (BRL)";
d108 1
a108 1
    if(dx != 0.0 || dy != 0.0)
d110 2
d127 1
a127 1
    if(dx != 0.0 || dy != 0.0)
d129 2
d148 1
a148 1
    dv_distadc = (dist / M_SQRT2_DIV2) - 2047.0;
d168 1
a168 1
  c_tdist = ((fastf_t)(dv_distadc) + 2047.0) * M_SQRT2_DIV2;
d242 4
a245 1
  DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d298 4
d401 1
a401 1
    dirty = 1;
d436 1
a436 1
      dirty = 1;
d459 1
d485 1
d523 26
d698 62
@


11.36
log
@*- mods to adcursor()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/adc.c,v 11.35 1998/05/18 19:35:06 bparker Exp $ (BRL)";
d238 1
a238 1
  DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
@


11.35
log
@*- mods for pjt demo
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/adc.c,v 11.34 1998/03/19 18:05:26 bparker Exp $ (BRL)";
d108 1
a108 1
    if(dx != 0 || dy != 0)
d125 1
a125 1
    if(dx != 0 || dy != 0)
d144 1
a144 1
    dv_distadc = (dist / M_SQRT2_DIV2) - 2047;
a237 10
#if 0
  idxy[0] = dv_xadc;
  idxy[1] = dv_yadc;

  idxy[0] = (idxy[0] < GED_MIN ? GED_MIN : idxy[0]);
  idxy[0] = (idxy[0] > GED_MAX ? GED_MAX : idxy[0]);
  idxy[1] = (idxy[1] < GED_MIN ? GED_MIN : idxy[1]);
  idxy[1] = (idxy[1] > GED_MAX ? GED_MAX : idxy[1]);
#endif

d241 2
a242 2
		  GED2PM1(GED_MIN), GED2PM1(dv_yadc) * dmp->dm_aspect,
		  GED2PM1(GED_MAX), GED2PM1(dv_yadc) * dmp->dm_aspect); /* Horizontal */
d244 2
a245 2
		  GED2PM1(dv_xadc), GED2PM1(GED_MAX) * dmp->dm_aspect,
		  GED2PM1(dv_xadc), GED2PM1(GED_MIN) * dmp->dm_aspect);  /* Vertical */
a256 1
  (void)clip ( &x1, &Y1, &x2, &y2 );
a261 1
  (void)clip ( &x3, &y3, &x4, &y4 );
a275 1
  (void)clip(&x1, &Y1, &x2, &y2);
a280 1
  (void)clip(&x3, &y3, &x4, &y4);
@


11.34
log
@*- added adc_print_vars()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.33 1998/03/13 22:38:58 bparker Exp bparker $ (BRL)";
d178 2
a179 2
		    GED2PM1(x1), GED2PM1(Y1),
		    GED2PM1(x2), GED2PM1(y2));
d189 2
a190 2
		    GED2PM1(x1), GED2PM1(Y1),
		    GED2PM1(x2), GED2PM1(y2));
d200 2
a201 2
		    GED2PM1(x1), GED2PM1(Y1),
		    GED2PM1(x2), GED2PM1(y2));
d211 2
a212 2
		    GED2PM1(x1), GED2PM1(Y1),
		    GED2PM1(x2), GED2PM1(y2) );
d251 2
a252 2
		  GED2PM1(GED_MIN), GED2PM1(dv_yadc),
		  GED2PM1(GED_MAX), GED2PM1(dv_yadc)); /* Horizontal */
d254 2
a255 2
		  GED2PM1(dv_xadc), GED2PM1(GED_MAX),
		  GED2PM1(dv_xadc), GED2PM1(GED_MIN));  /* Vertical */
a274 2
  DM_DRAW_LINE_2D(dmp, GED2PM1(x1), GED2PM1(Y1),
		   GED2PM1(x2), GED2PM1(y2));
d276 5
a280 2
		  GED2PM1(x3), GED2PM1(y3),
		  GED2PM1(x4), GED2PM1(y4));
d298 2
a299 2
		  GED2PM1(x1), GED2PM1(Y1),
		  GED2PM1(x2), GED2PM1(y2));
d301 2
a302 2
		  GED2PM1(x3), GED2PM1(y3),
		  GED2PM1(x4), GED2PM1(y4));
@


11.33
log
@*- changed f_adc to not use mged_variables --- as before
*- now gets as well as sets adc parameters
*- added more parameters
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.32 1998/03/06 22:26:36 bparker Exp bparker $ (BRL)";
d46 3
a48 1
void
d56 1
a56 1
void
d69 1
a69 1
void
d82 68
a231 45
  fastf_t dx, dy;
  point_t model_pt;
  point_t view_pt;

  /*
   * Calculate a-d cursor displacement.
   */

  if(adc_anchor_pos == 1){
    adc_model_To_adc_view();
    adc_view_To_adc_grid();
  }else if(adc_anchor_pos == 2){
    adc_grid_To_adc_view();
    MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
  }else{
    adc_view_To_adc_grid();
    MAT4X3PNT(adc_pos_model, view2model, adc_pos_view);
  }

  if(adc_anchor_a1){
    fastf_t angle;

    MAT4X3PNT(view_pt, model2view, adc_anchor_pt_a1);
    dx = view_pt[X] * GED_MAX - dv_xadc;
    dy = view_pt[Y] * GED_MAX - dv_yadc;

    if(dx != 0 || dy != 0)
      adc_a1 = RAD2DEG*atan2(dy, dx);
  }

  if(adc_anchor_a2){
    fastf_t angle;

    MAT4X3PNT(view_pt, model2view, adc_anchor_pt_a2);
    dx = view_pt[X] * GED_MAX - dv_xadc;
    dy = view_pt[Y] * GED_MAX - dv_yadc;

    if(dx != 0 || dy != 0)
      adc_a2 = RAD2DEG*atan2(dy, dx);
  }

  if(adc_anchor_dst){
    fastf_t dist;

    MAT4X3PNT(view_pt, model2view, adc_anchor_pt_dst);
d233 4
a236 7
    dx = view_pt[X] * GED_MAX - dv_xadc;
    dy = view_pt[Y] * GED_MAX - dv_yadc;
    dist = sqrt(dx * dx + dy * dy);
    adc_dst = dist * INV_GED;
    dv_distadc = (dist / M_SQRT2_DIV2) - 2047;
  }else
    adc_dst = (dv_distadc * INV_GED + 1.0) * M_SQRT2_DIV2;
d338 1
d361 1
d694 1
d720 1
d749 1
d775 1
d804 1
d825 1
a825 1
      if(i)
d827 1
a827 1
      else
d830 1
d859 1
d869 1
a869 1
  if( strcmp(parameter, "reset") == 0)  {
d881 6
a886 1
  if( strcmp(parameter, "help") == 0)  {
d894 23
@


11.32
log
@*- rewrote f_adc
	- uses mged_variables
	- draws ticks on all lines
	- uses -i to mean treat parameters as incremental
	- use of anchors --- position, a1, a2, tick distance
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.31 1998/02/06 22:13:20 bparker Exp bparker $ (BRL)";
a37 4
extern void set_dirty_flag();		/* defined in set.c */
extern void set_adc_xyz();		/* defined in set.c */
extern void set_adc_xyz_grid();		/* defined in set.c */

d47 1
a47 13
adc_xyz_To_dv_xyadc()
{
  point_t model_pt;
  point_t view_pt;

  VSCALE(model_pt, mged_variables->adc_xyz, local2base);
  MAT4X3PNT(view_pt, model2view, model_pt);
  dv_xadc = view_pt[X] * GED_MAX;
  dv_yadc = view_pt[Y] * GED_MAX;
}

void
dv_xyadc_To_adc_xyz()
d49 3
a51 6
  point_t model_pt;
  point_t view_pt;

  VSET(view_pt, dv_xadc * INV_GED, dv_yadc * INV_GED, 0.0);
  MAT4X3PNT(model_pt, view2model, view_pt);
  VSCALE(mged_variables->adc_xyz, model_pt, base2local);
d55 1
a55 1
adc_xyz_grid_To_dv_xyadc()
a56 1
  fastf_t f;
d62 3
a64 6
  f = Viewscale * base2local;
  VSCALE(view_pt, view_pt, f);

  f = 2047.0 / (Viewscale * base2local);
  dv_xadc = (view_pt[X] + mged_variables->adc_xyz_grid[X]) * f;
  dv_yadc = (view_pt[Y] + mged_variables->adc_xyz_grid[Y]) * f;
d68 1
a68 1
dv_xyadc_To_adc_xyz_grid()
d76 1
a76 63
  VSCALE(view_pt, view_pt, GED_MAX);

  f = INV_GED * Viewscale * base2local;
  mged_variables->adc_xyz_grid[X] = (dv_xadc - view_pt[X]) * f;
  mged_variables->adc_xyz_grid[Y] = (dv_yadc - view_pt[Y]) * f;
}

void
adc_xyz_To_adc_xyz_grid()
{
  fastf_t f;
  point_t model_pt;
  point_t xyz_view_pt;		/* ADC's xyz in view space */
  point_t mo_view_pt;		/* model origin in view space */
  point_t diff;
  
  VSCALE(model_pt, mged_variables->adc_xyz, local2base);
  MAT4X3PNT(xyz_view_pt, model2view, model_pt);

  VSETALL(model_pt, 0.0);
  MAT4X3PNT(mo_view_pt, model2view, model_pt);

  VSUB2(diff, mo_view_pt, xyz_view_pt);
  f = Viewscale * base2local;
  mged_variables->adc_xyz_grid[X] = diff[X] * f;
  mged_variables->adc_xyz_grid[Y] = diff[Y] * f;
}

void
adc_xyz_grid_To_adc_xyz()
{
  fastf_t f;
  point_t model_pt;
  point_t xyz_view_pt;		/* ADC's xyz in view space */
  point_t mo_view_pt;		/* model origin in view space */
  point_t diff;

  VSETALL(model_pt, 0.0);
  MAT4X3PNT(mo_view_pt, model2view, model_pt);

  f = 1.0 / (Viewscale * base2local);
  diff[X] = mged_variables->adc_xyz_grid[X] * f;
  diff[Y] = mged_variables->adc_xyz_grid[Y] * f;
  diff[Z] = 0.0;

  VADD2(xyz_view_pt, mo_view_pt, diff);
  MAT4X3PNT(mged_variables->adc_xyz, view2model, xyz_view_pt);

  f = Viewscale * base2local;
  VSCALE(mged_variables->adc_xyz, mged_variables->adc_xyz, f);
}

void
adc_dst_To_dv_distadc()
{
  dv_distadc = (mged_variables->adc_dst /
		(Viewscale * base2local * M_SQRT2_DIV2) - 1.0) * GED_MAX;
}

void
dv_distadc_To_adc_dst()
{
  mged_variables->adc_dst = (dv_distadc * INV_GED + 1.0) * Viewscale * base2local * M_SQRT2_DIV2;
d170 9
a178 6
  if(mged_variables->adc_anchor_xyz == 1){
    adc_xyz_To_dv_xyadc();
    dv_xyadc_To_adc_xyz_grid();
  }else if(mged_variables->adc_anchor_xyz == 2){
    adc_xyz_grid_To_dv_xyadc();
    dv_xyadc_To_adc_xyz();
d180 2
a181 2
    
  if(mged_variables->adc_anchor_a1){
d184 1
a184 2
    VSCALE(model_pt, mged_variables->adc_anchor_pt_a1, local2base);
    MAT4X3PNT(view_pt, model2view, model_pt);
d189 1
a189 1
      mged_variables->adc_a1 = RAD2DEG*atan2(dy, dx);
d192 1
a192 1
  if(mged_variables->adc_anchor_a2){
d195 1
a195 2
    VSCALE(model_pt, mged_variables->adc_anchor_pt_a2, local2base);
    MAT4X3PNT(view_pt, model2view, model_pt);
d200 1
a200 1
      mged_variables->adc_a2 = RAD2DEG*atan2(dy, dx);
d203 1
a203 1
  if(mged_variables->adc_anchor_tick){
d206 1
a206 2
    VSCALE(model_pt, mged_variables->adc_anchor_pt_tick, local2base);
    MAT4X3PNT(view_pt, model2view, model_pt);
d211 1
a211 1
    mged_variables->adc_dst = dist * INV_GED * Viewscale * base2local;
d213 2
a214 1
  }
d235 2
a236 2
  angle1 = mged_variables->adc_a1 * DEG2RAD;
  angle2 = mged_variables->adc_a2 * DEG2RAD;
d294 14
a307 11
  dv_xyadc_To_adc_xyz();
  dv_xyadc_To_adc_xyz_grid();
  dv_distadc_To_adc_dst();
  mged_variables->adc_a1 = mged_variables->adc_a2 = 45.0;

  mged_variables->adc_anchor_xyz = 0;
  mged_variables->adc_anchor_a1 = 0;
  mged_variables->adc_anchor_a2 = 0;
  mged_variables->adc_anchor_tick = 0;

  set_dirty_flag();
d315 22
a336 8
 adc		toggle display of angle/distance cursor\n\
 adc a1 #	set angle1\n\
 adc a2 #	set angle2\n\
 adc dst #	set radius (distance) of tick\n\
 adc hv # #	reposition (view coordinates)\n\
 adc xyz # # #	reposition in front of a point (model coordinates)\n\
 adc reset	reset angles, location, and tick distance\n\
 adc help       prints this help message\n\
d345 1
d352 1
a359 2
    struct bu_vls vls;

d368 3
a370 3
  if (argc == 1){
    if (mged_variables->adcflag)
      mged_variables->adcflag = 0;
d372 1
a372 1
      mged_variables->adcflag = 1;
a374 2
      struct dm_list *dlp;

d376 1
a376 4

      FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
	if(dlp->_mged_variables == mged_variables)
	  dlp->_adc_auto = 0;
d379 1
d398 24
d423 9
a431 2
    if(argc == 1){
      if(!mged_variables->adc_anchor_a1){
d433 1
a433 1
	  mged_variables->adc_a1 += user_pt[0];
d435 1
a435 1
	  mged_variables->adc_a1 = user_pt[0];
d437 1
a437 1
	set_dirty_flag();
d448 9
a456 2
    if(argc == 1){
      if(!mged_variables->adc_anchor_a2){
d458 1
a458 1
	  mged_variables->adc_a2 += user_pt[0];
d460 1
a460 1
	  mged_variables->adc_a2 = user_pt[0];
d462 1
a462 1
	set_dirty_flag();
d468 1
a468 1
    Tcl_AppendResult(interp, "The 'adc a2' command accepts only 1 argument\n", (char *)NULL);
d473 9
a481 2
    if(argc == 1){
      if(!mged_variables->adc_anchor_tick){
d483 1
a483 1
	  mged_variables->adc_dst += user_pt[0];
d485 1
a485 1
	  mged_variables->adc_dst = user_pt[0];
d487 3
a489 2
	adc_dst_To_dv_distadc();
	set_dirty_flag();
d495 1
a495 1
    Tcl_AppendResult(interp, "The 'adc dst' command accepts only 1 argument\n", (char *)NULL);
d501 7
a507 1
      mged_variables->adc_xyz_grid[X] += user_pt[0];
d509 1
a509 1
      set_adc_xyz_grid();
d518 7
a524 1
      mged_variables->adc_xyz_grid[Y] += user_pt[0];
d526 1
a526 1
      set_adc_xyz_grid();
d534 11
a544 2
    if(argc == 2){
      if(!mged_variables->adc_anchor_xyz){
d546 2
a547 2
	  mged_variables->adc_xyz_grid[X] += user_pt[X];
	  mged_variables->adc_xyz_grid[Y] += user_pt[Y];
d549 2
a550 2
	  mged_variables->adc_xyz_grid[X] = user_pt[X];
	  mged_variables->adc_xyz_grid[Y] = user_pt[Y];
d553 5
a557 1
	set_adc_xyz_grid();
d563 1
a563 1
    Tcl_AppendResult(interp, "The 'adc hv' command requires 2 arguments\n", (char *)NULL);
d569 4
a572 2
      if(!mged_variables->adc_anchor_xyz){
	mged_variables->adc_xyz[X] += user_pt[0];
d574 1
a574 1
	set_adc_xyz();
d586 4
a589 2
      if(!mged_variables->adc_anchor_xyz){
	mged_variables->adc_xyz[Y] += user_pt[0];
d591 1
a591 1
	set_adc_xyz();
d603 4
a606 2
      if(!mged_variables->adc_anchor_xyz){
	mged_variables->adc_xyz[Z] += user_pt[0];
d608 1
a608 1
	set_adc_xyz();
d619 13
a631 2
    if(argc == 3) {
      if(!mged_variables->adc_anchor_xyz){
d633 1
a633 1
	  VADD2(mged_variables->adc_xyz, mged_variables->adc_xyz, user_pt);
d635 1
a635 1
	  VMOVE(mged_variables->adc_xyz, user_pt);
d638 4
a641 1
	set_adc_xyz();
d647 1
a647 1
    Tcl_AppendResult(interp, "The 'adc xyz' command requires 2 arguments\n", (char *)NULL);
d651 16
a666 3
  if(strcmp(parameter, "anchor") == 0){
    mged_variables->adc_anchor_xyz = 1;
    set_dirty_flag();
d668 1
a668 2
    return TCL_OK;
  }
d670 3
a672 3
  if(strcmp(parameter, "noanchor") == 0){
    mged_variables->adc_anchor_xyz = 0;
    set_dirty_flag();
d674 3
a676 1
    return TCL_OK;
d679 10
a688 3
  if(strcmp(parameter, "anchor_grid") == 0){
    mged_variables->adc_anchor_xyz = 2;
    set_dirty_flag();
d690 4
a693 2
    return TCL_OK;
  }
d695 3
a697 3
  if(strcmp(parameter, "noanchor_grid") == 0){
    mged_variables->adc_anchor_xyz = 0;
    set_dirty_flag();
d699 3
a701 1
    return TCL_OK;
d704 3
a706 3
  if(strcmp(parameter, "anchor_a1") == 0){
    mged_variables->adc_anchor_a1 = 1;
    set_dirty_flag();
d708 4
a711 2
    return TCL_OK;
  }
d713 3
a715 3
  if(strcmp(parameter, "noanchor_a1") == 0){
    mged_variables->adc_anchor_a1 = 0;
    set_dirty_flag();
d717 5
a721 2
    return TCL_OK;
  }
d723 3
a725 3
  if(strcmp(parameter, "anchorpoint_a1") == 0){
    VMOVE(mged_variables->adc_anchor_pt_a1, user_pt);
    set_dirty_flag();
d727 3
a729 1
    return TCL_OK;
d733 9
a741 2
    mged_variables->adc_anchor_a2 = 1;
    set_dirty_flag();
d743 4
a746 2
    return TCL_OK;
  }
d748 3
a750 3
  if(strcmp(parameter, "noanchor_a2") == 0){
    mged_variables->adc_anchor_a2 = 0;
    set_dirty_flag();
d752 3
a754 1
    return TCL_OK;
d758 2
a759 2
    VMOVE(mged_variables->adc_anchor_pt_a2, user_pt);
    set_dirty_flag();
d761 22
a782 1
    return TCL_OK;
d785 19
a803 3
  if(strcmp(parameter, "anchor_tick") == 0){
    mged_variables->adc_anchor_tick = 1;
    set_dirty_flag();
d805 3
a807 1
    return TCL_OK;
d810 8
a817 3
  if(strcmp(parameter, "noanchor_tick") == 0){
    mged_variables->adc_anchor_tick = 0;
    set_dirty_flag();
d819 9
a827 2
    return TCL_OK;
  }
d829 3
a831 3
  if(strcmp(parameter, "anchorpoint_tick") == 0){
    VMOVE(mged_variables->adc_anchor_pt_tick, user_pt);
    set_dirty_flag();
d833 3
a835 1
    return TCL_OK;
d842 1
@


11.31
log
@DM_DRAW_STRING_2D and DM_DRAW_STRING_2D now expect x,y values in the range +-1
@
text
@d11 1
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.30 1997/12/23 14:25:42 bparker Exp bparker $ (BRL)";
d38 3
a40 1
extern void set_scroll();   /* defined in set.c */
d50 181
d239 131
a369 97
	static double	pi = 3.14159265358979323264;
	static fastf_t	x1, Y1;	/* not "y1", due to conflict with math lib */
	static fastf_t	x2, y2;
	static fastf_t	x3, y3;
	static fastf_t	x4, y4;
	static fastf_t	d1, d2;
	static fastf_t	t1, t2;
	static long	idxy[2];

	/*
	 * Calculate a-d cursor displacement.
	 */
#define MINVAL	-2048
#define MAXVAL	 2047
	idxy[0] = dv_xadc;
	idxy[1] = dv_yadc;
	idxy[0] = (idxy[0] < MINVAL ? MINVAL : idxy[0]);
	idxy[0] = (idxy[0] > MAXVAL ? MAXVAL : idxy[0]);
	idxy[1] = (idxy[1] < MINVAL ? MINVAL : idxy[1]);
	idxy[1] = (idxy[1] > MAXVAL ? MAXVAL : idxy[1]);

	DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
#if 1
	DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
#else
	DM_SET_LINE_ATTR(dmp, 1, 0);    /* linewidth - 1, not dashed */
#endif
	DM_DRAW_LINE_2D( dmp,
			 GED2PM1(MINVAL), GED2PM1(idxy[1]),
			 GED2PM1(MAXVAL), GED2PM1(idxy[1]) ); /* Horizontal */
	DM_DRAW_LINE_2D( dmp,
			 GED2PM1(idxy[0]), GED2PM1(MAXVAL),
			 GED2PM1(idxy[0]), GED2PM1(MINVAL) );  /* Vertical */

	curs_x = (fastf_t) (idxy[0]);
	curs_y = (fastf_t) (idxy[1]);

	/*
	 * Calculate a-d cursor rotation.
	 */
	/* - to make rotation match knob direction */
	idxy[0] = -dv_1adc;	/* solid line */
	idxy[1] = -dv_2adc;	/* dashed line */
	angle1 = ((2047.0 + (fastf_t) (idxy[0])) * pi) / (4.0 * 2047.0);
	angle2 = ((2047.0 + (fastf_t) (idxy[1])) * pi) / (4.0 * 2047.0);

	/* sin for X and cos for Y to reverse sense of knob */
	d1 = cos (angle1) * 8000.0;
	d2 = sin (angle1) * 8000.0;
	x1 = curs_x + d1;
	Y1 = curs_y + d2;
	x2 = curs_x - d1;
	y2 = curs_y - d2;
	(void)clip ( &x1, &Y1, &x2, &y2 );

	x3 = curs_x + d2;
	y3 = curs_y - d1;
	x4 = curs_x - d2;
	y4 = curs_y + d1;
	(void)clip ( &x3, &y3, &x4, &y4 );

	DM_DRAW_LINE_2D( dmp, GED2PM1(x1), GED2PM1(Y1),
			 GED2PM1(x2), GED2PM1(y2) );
	DM_DRAW_LINE_2D( dmp,
			 GED2PM1(x3), GED2PM1(y3),
			 GED2PM1(x4), GED2PM1(y4) );

	d1 = cos (angle2) * 8000.0;
	d2 = sin (angle2) * 8000.0;
	x1 = curs_x + d1;
	Y1 = curs_y + d2;
	x2 = curs_x - d1;
	y2 = curs_y - d2;
	(void)clip ( &x1, &Y1, &x2, &y2 );

	x3 = curs_x + d2;
	y3 = curs_y - d1;
	x4 = curs_x - d2;
	y4 = curs_y + d1;
	(void)clip ( &x3, &y3, &x4, &y4 );

#if 1
	DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 1);
#else
	DM_SET_LINE_ATTR(dmp, 1, 1);  /* linewidth - 1, dashed */
#endif
	DM_DRAW_LINE_2D( dmp,
			 GED2PM1(x1), GED2PM1(Y1),
			 GED2PM1(x2), GED2PM1(y2) );
	DM_DRAW_LINE_2D( dmp,
			 GED2PM1(x3), GED2PM1(y3),
			 GED2PM1(x4), GED2PM1(y4) );
#if 1
	DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
#else
	DM_SET_LINE_ATTR(dmp, 1, 0);  /* linewidth - 1, not dashed */
#endif
d371 16
a386 33
	/*
	 * Position tic marks from dial 9.
	 */
	/* map -2048 - 2047 into 0 - 2048 * sqrt (2) */
	/* Tick distance */
	c_tdist = ((fastf_t)(dv_distadc) + 2047.0) * M_SQRT2_DIV2;

	d1 = c_tdist * cos (angle1);
	d2 = c_tdist * sin (angle1);
	t1 = 20.0 * sin (angle1);
	t2 = 20.0 * cos (angle1);

	/* Quadrant 1 */
	x1 = curs_x + d1 + t1;
	Y1 = curs_y + d2 - t2;
	x2 = curs_x + d1 -t1;
	y2 = curs_y + d2 + t2;
	if (clip ( &x1, &Y1, &x2, &y2 ) == 0) {
	  DM_DRAW_LINE_2D( dmp, 
			   GED2PM1(x1), GED2PM1(Y1),
			   GED2PM1(x2), GED2PM1(y2) );
	}

	/* Quadrant 2 */
	x1 = curs_x - d2 + t2;
	Y1 = curs_y + d1 + t1;
	x2 = curs_x - d2 - t2;
	y2 = curs_y + d1 - t1;
	if (clip (&x1, &Y1, &x2, &y2) == 0) {
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(x1), GED2PM1(Y1),
			   GED2PM1(x2), GED2PM1(y2) );
	}
d388 1
a388 21
	/* Quadrant 3 */
	x1 = curs_x - d1 - t1;
	Y1 = curs_y - d2 + t2;
	x2 = curs_x - d1 + t1;
	y2 = curs_y - d2 - t2;
	if (clip (&x1, &Y1, &x2, &y2) == 0) {
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(x1), GED2PM1(Y1),
			   GED2PM1(x2), GED2PM1(y2) );
	}

	/* Quadrant 4 */
	x1 = curs_x + d2 - t2;
	Y1 = curs_y - d1 - t1;
	x2 = curs_x + d2 + t2;
	y2 = curs_y - d1 + t1;
	if (clip (&x1, &Y1, &x2, &y2) == 0) {
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(x1), GED2PM1(Y1),
			   GED2PM1(x2), GED2PM1(y2) );
	}
a399 5
 adc dh #	reposition horizontally\n\
 adc dv #	reposition vertically\n\
 adc dx #	reposition in X direction\n\
 adc dy #	reposition in Y direction\n\
 adc dz #	reposition in Z direction\n\
d403 1
d412 329
a740 238
	char	*parameter;
	point_t	center_model;
	point_t	center_view;
	point_t	pt;		/* Value(s) provided by user */
	point_t	pt2, pt3;	/* Extra points as needed */
	fastf_t	view2dm = 2047.0 / Viewscale;
	int	i;
	int     iadc = 0;

	if(dbip == DBI_NULL)
	  return TCL_OK;

	if(argc < 1 || 5 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help adc");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);

	  return TCL_ERROR;
	}

	if(strstr(argv[0], "iadc"))
	   iadc = 1;

	if (argc == 1){
	  if (mged_variables->adcflag)
	    mged_variables->adcflag = 0;
	  else
	    mged_variables->adcflag = 1;

#ifdef DO_SCROLL_UPDATES
	  set_scroll();
#endif

	  dmaflag = 1;
	  return TCL_OK;
	}

	parameter = argv[1];
	argc -= 2;
	for (i = 0; i < argc; ++i)
		pt[i] = atof(argv[i + 2]);
	MAT_DELTAS_GET_NEG(center_model, toViewcenter);

	if( strcmp( parameter, "a1" ) == 0 )  {
	  if (argc == 1) {
	    if(iadc)
	      dv_1adc +=  pt[0] / 45.0 * 2047.0;
	    else
	      dv_1adc = (1.0 - pt[0] / 45.0) * 2047.0;

	    dmaflag = 1;
	    adc_a1_deg = pt[0];
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&ang1_vls));
#endif
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc a1' command accepts only 1 argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp( parameter, "a2" ) == 0 )  {
	  if (argc == 1) {
	    if(iadc)
	      dv_2adc +=  pt[0] / 45.0 * 2047.0;
	    else
	      dv_2adc = (1.0 - pt[0] / 45.0) * 2047.0;

	    dmaflag = 1;
	    adc_a2_deg = pt[0];
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&ang2_vls));
#endif

	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc a2' command accepts only 1 argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if(strcmp(parameter, "dst") == 0)  {
	  if (argc == 1) {
	    if(iadc)
	      dv_distadc += (pt[0] /
			  (Viewscale * base2local * M_SQRT2_DIV2) - 1.0) * 2047.0;
	    else
	      dv_distadc = (pt[0] /
			    (Viewscale * base2local * M_SQRT2_DIV2) - 1.0) * 2047.0;

	    dmaflag = 1;
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&distadc_vls));
#endif

	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc dst' command accepts only 1 argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp( parameter, "dh" ) == 0 )  {
	  if (argc == 1) {
	    dv_xadc += pt[0] * 2047.0 / (Viewscale * base2local);
	    dmaflag = 1;
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc dh' command accepts only 1 argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp( parameter, "dv" ) == 0 )  {
	  if (argc == 1) {
	    dv_yadc += pt[0] * 2047.0 / (Viewscale * base2local);
	    dmaflag = 1;
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc dv' command accepts only 1 argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp( parameter, "dx" ) == 0 )  {
	  if (argc == 1) {
	    VSET(pt2, pt[0]*local2base, 0.0, 0.0);
	    MAT4X3VEC(pt3, Viewrot, pt2);
	    dv_xadc += pt3[X] * view2dm;
	    dv_yadc += pt3[Y] * view2dm;
	    dmaflag = 1;
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc dx' command accepts only 1 argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp( parameter, "dy" ) == 0 )  {
	  if (argc == 1) {
	    VSET(pt2, 0.0, pt[0]*local2base, 0.0);
	    MAT4X3VEC(pt3, Viewrot, pt2);
	    dv_xadc += pt3[X] * view2dm;
	    dv_yadc += pt3[Y] * view2dm;
	    dmaflag = 1;
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc dy' command accepts only 1 argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp( parameter, "dz" ) == 0 )  {
	  if (argc == 1) {
	    VSET(pt2, 0.0, 0.0, pt[0]*local2base);
	    MAT4X3VEC(pt3, Viewrot, pt2);
	    dv_xadc += pt3[X] * view2dm;
	    dv_yadc += pt3[Y] * view2dm;
	    dmaflag = 1;
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc dz' command accepts only 1 argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp(parameter, "hv") == 0)  {
	  if (argc == 2) {
	    dv_xadc = pt[X] * 2047.0 / (Viewscale * base2local);
	    dv_yadc = pt[Y] * 2047.0 / (Viewscale * base2local);

	    dmaflag = 1;
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc hv' command requires 2 arguments\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp(parameter, "xyz") == 0)  {
	  if (argc == 3) {
	    VSCALE(pt, pt, local2base);
	    VSUB2(pt2, pt, center_model);
	    MAT4X3VEC(pt3, Viewrot, pt2);
	    dv_xadc = pt3[X] * view2dm;
	    dv_yadc = pt3[Y] * view2dm;
	    dmaflag = 1;
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc xyz' command requires 2 arguments\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp(parameter, "x") == 0 ) {
	  if( argc == 1 ) {
	    if(iadc)
	      dv_xadc += pt[0];
	    else
	      dv_xadc = pt[0];

	    dmaflag = 1;
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&xadc_vls));
#endif

	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc x' command requires one argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp(parameter, "y") == 0 ) {
	  if( argc == 1 ) {
	    if(iadc)
	      dv_yadc += pt[0];
	    else
	      dv_yadc = pt[0];

	    dmaflag = 1;
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&yadc_vls));
#endif
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc y' command requires one argument\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp(parameter, "reset") == 0)  {
	  if (argc == 0) {
	    dv_xadc = dv_yadc = 0;
	    dv_1adc = dv_2adc = 0;
	    dv_distadc = 0;
	    adc_a1_deg = adc_a2_deg = 45.0;
	    dmaflag = 1;
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&xadc_vls));
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&yadc_vls));
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&ang1_vls));
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&ang2_vls));
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&distadc_vls));
#endif
	    return TCL_OK;
	  }
	  Tcl_AppendResult(interp, "The 'adc reset' command accepts no arguments\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( strcmp(parameter, "help") == 0)  {
	  Tcl_AppendResult(interp, "Usage:\n", adc_syntax, (char *)NULL);
	  return TCL_OK;
	} else {
	  Tcl_AppendResult(interp, "ADC: unrecognized command: '",
			   argv[1], "'\nUsage:\n", adc_syntax, (char *)NULL);
	}
	return TCL_ERROR;
@


11.30
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.29 1997/11/26 21:33:20 bparker Exp bparker $ (BRL)";
d82 6
a87 2
	DM_DRAW_LINE_2D( dmp, MINVAL, idxy[1], MAXVAL, idxy[1] ); /* Horizontal */
	DM_DRAW_LINE_2D( dmp, idxy[0], MAXVAL, idxy[0], MINVAL );  /* Vertical */
d116 5
a120 2
	DM_DRAW_LINE_2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
	DM_DRAW_LINE_2D( dmp, (int)x3, (int)y3, (int)x4, (int)y4 );
d141 6
a146 2
	DM_DRAW_LINE_2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
	DM_DRAW_LINE_2D( dmp, (int)x3, (int)y3, (int)x4, (int)y4 );
d171 3
a173 1
	  DM_DRAW_LINE_2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
d182 3
a184 1
	  DM_DRAW_LINE_2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
d193 3
a195 1
	  DM_DRAW_LINE_2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
d204 3
a206 1
	  DM_DRAW_LINE_2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
@


11.29
log
@ifdef code that uses Tcl_UpdateLinkedVar
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.28 1997/11/03 15:22:23 bparker Exp bparker $ (BRL)";
d247 2
a248 1
	  
d250 2
@


11.28
log
@use LIBDM macros
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.27 1997/09/08 19:05:35 bparker Exp bparker $ (BRL)";
d268 1
d270 1
a270 1

d285 1
d287 1
d304 1
d306 1
d399 1
d401 1
d416 1
d418 1
d431 1
d437 1
@


11.27
log
@mged_variables is now a pointer
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.26 1997/07/25 20:52:50 bparker Exp bparker $ (BRL)";
d76 1
a76 1
	dmp->dm_setColor(dmp, DM_YELLOW, 1);
d78 1
a78 1
	dmp->dm_setLineAttr(dmp, mged_variables->linewidth, 0);
d80 1
a80 1
	dmp->dm_setLineAttr(dmp, 1, 0);    /* linewidth - 1, not dashed */
d82 2
a83 2
	dmp->dm_drawLine2D( dmp, MINVAL, idxy[1], MAXVAL, idxy[1] ); /* Horizontal */
	dmp->dm_drawLine2D( dmp, idxy[0], MAXVAL, idxy[0], MINVAL );  /* Vertical */
d112 2
a113 2
	dmp->dm_drawLine2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
	dmp->dm_drawLine2D( dmp, (int)x3, (int)y3, (int)x4, (int)y4 );
d130 1
a130 1
	dmp->dm_setLineAttr(dmp, mged_variables->linewidth, 1);
d132 1
a132 1
	dmp->dm_setLineAttr(dmp, 1, 1);  /* linewidth - 1, dashed */
d134 2
a135 2
	dmp->dm_drawLine2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
	dmp->dm_drawLine2D( dmp, (int)x3, (int)y3, (int)x4, (int)y4 );
d137 1
a137 1
	dmp->dm_setLineAttr(dmp, mged_variables->linewidth, 0);
d139 1
a139 1
	dmp->dm_setLineAttr(dmp, 1, 0);  /* linewidth - 1, not dashed */
d160 1
a160 1
	  dmp->dm_drawLine2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
d169 1
a169 1
	  dmp->dm_drawLine2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
d178 1
a178 1
	  dmp->dm_drawLine2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
d187 1
a187 1
	  dmp->dm_drawLine2D( dmp, (int)x1, (int)Y1, (int)x2, (int)y2 );
d242 2
a243 6
	if (argc == 1)
	{
	  if (mged_variables->adcflag)  {
#if 0
	    dmp->dm_light( dmp, LIGHT_OFF, BV_ADCURSOR );
#endif
d245 1
a245 4
	  } else {
#if 0
	    dmp->dm_light( dmp, LIGHT_ON, BV_ADCURSOR );
#endif
d247 1
a247 2
	  }

a257 3
#if 0
	MAT4X3VEC(center_view, Viewrot, center_model);
#endif
a363 6
#if 0
	    VSCALE(pt, pt, local2base);
	    VSUB2(pt3, pt, center_view);
	    dv_xadc = pt3[X] * view2dm;
	    dv_yadc = pt3[Y] * view2dm;
#else
d366 1
a366 1
#endif
@


11.26
log
@mods to use user specified linewidth
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.25 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d78 1
a78 1
	dmp->dm_setLineAttr(dmp, mged_variables.linewidth, 0);
d130 1
a130 1
	dmp->dm_setLineAttr(dmp, mged_variables.linewidth, 1);
d137 1
a137 1
	dmp->dm_setLineAttr(dmp, mged_variables.linewidth, 0);
d244 1
a244 1
	  if (mged_variables.adcflag)  {
d248 1
a248 1
	    mged_variables.adcflag = 0;
d253 1
a253 1
	    mged_variables.adcflag = 1;
@


11.25
log
@mods to run without a database
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.24 1997/06/25 13:35:42 bparker Exp bparker $ (BRL)";
d77 3
d81 1
d129 3
d133 1
d136 3
d140 1
d265 2
a266 2
	VSET(center_model,
	    -toViewcenter[MDX], -toViewcenter[MDY], -toViewcenter[MDZ]);
d268 1
d375 1
d380 4
@


11.24
log
@fix bug wrt the -i option as applied to a1 and a2
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.23 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d212 3
@


11.23
log
@modify calls to Tcl_Eval
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.22 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d257 1
a257 1
	      dv_1adc += (1.0 - pt[0] / 45.0) * 2047.0;
d273 1
a273 1
	      dv_2adc += (1.0 - pt[0] / 45.0) * 2047.0;
@


11.22
log
@mods so that commands check args internally
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.21 1997/02/24 22:03:34 bparker Exp bparker $ (BRL)";
d214 7
a220 1
	  Tcl_Eval(interp, "help adc");
@


11.21
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.20 1997/01/24 21:02:28 bparker Exp bparker $ (BRL)";
d213 2
a214 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d216 1
@


11.20
log
@mods to update sliders
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.19 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d234 1
@


11.19
log
@checkin for weekend
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.18 1996/12/23 22:40:34 bparker Exp bparker $ (BRL)";
d37 2
d233 1
a233 9
	  if(mged_variables.scroll_enabled){
	    /* 
	     * We need to send this through the interpreter in case
	     * the built-in "sliders" command has been redefined.
	     */
	    Tcl_Eval(interp, "sliders on");
	  }

	  dmaflag = 1;
d253 1
a253 1
	    adc_a1_deg = ((2047.0 + (fastf_t)-dv_1adc) * bn_pi) / (4.0 * 2047.0) * radtodeg;
d269 1
a269 1
	    adc_a2_deg = ((2047.0 + (fastf_t)-dv_2adc) * bn_pi) / (4.0 * 2047.0) * radtodeg;
d407 1
d409 5
@


11.18
log
@added (char *)NULL to end of Tcl_AppendResult call
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.17 1996/11/19 21:49:13 bparker Exp bparker $ (BRL)";
a231 8
#if 0
	    char *av[3];

	    av[0] = "sliders";
	    av[1] = "on";
	    av[2] = NULL;
	    (void)cmd_sliders(clientData, interp, 2, av);
#else
a236 1
#endif
d259 3
d275 3
d293 2
d387 2
d402 1
@


11.17
log
@send call to sliders through the Tcl interpreter
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.16 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d422 1
a422 1
			   argv[1], "'\nUsage:\n", adc_syntax);
@


11.16
log
@hacks to use latest libdm
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.15 1996/10/03 20:22:26 bparker Exp bparker $ (BRL)";
d232 1
d239 7
@


11.15
log
@get rid of extra cmdline() uses
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.14 1996/09/23 18:40:41 bparker Exp bparker $ (BRL)";
d74 4
a77 2
	dmp->dmr_2d_line( dmp, MINVAL, idxy[1], MAXVAL, idxy[1], 0 ); /* Horiz */
	dmp->dmr_2d_line( dmp, idxy[0], MAXVAL, idxy[0], MINVAL, 0);  /* Vert */
d106 2
a107 2
	dmp->dmr_2d_line( dmp, (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
	dmp->dmr_2d_line( dmp, (int)x3, (int)y3, (int)x4, (int)y4, 0 );
d123 4
a126 3
	/* Dashed lines */
	dmp->dmr_2d_line( dmp, (int)x1, (int)Y1, (int)x2, (int)y2, 1 );
	dmp->dmr_2d_line( dmp, (int)x3, (int)y3, (int)x4, (int)y4, 1 );
d146 1
a146 1
		dmp->dmr_2d_line( dmp, (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
d155 1
a155 1
		dmp->dmr_2d_line( dmp, (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
d164 1
a164 1
		dmp->dmr_2d_line( dmp, (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
d173 1
a173 1
		dmp->dmr_2d_line( dmp, (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
d220 3
a222 1
	    dmp->dmr_light( dmp, LIGHT_OFF, BV_ADCURSOR );
d225 3
a227 1
	    dmp->dmr_light( dmp, LIGHT_ON, BV_ADCURSOR );
@


11.14
log
@use LIBDM permanently
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.13 1996/09/17 21:16:54 bparker Exp bparker $ (BRL)";
d225 1
a225 1
	    struct bu_vls cmd;
d227 4
a230 4
	    bu_vls_init(&cmd);
	    bu_vls_strcpy(&cmd, "sliders on\n");
	    (void)cmdline(&cmd, False);
	    bu_vls_free(&cmd);
@


11.13
log
@prepare to use libdm
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.12 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d35 1
a35 1
#include "./dm.h"
a73 1
#ifdef USE_LIBDM
d76 1
a76 4
#else
	dmp->dmr_2d_line( MINVAL, idxy[1], MAXVAL, idxy[1], 0 ); /* Horiz */
	dmp->dmr_2d_line( idxy[0], MAXVAL, idxy[0], MINVAL, 0);  /* Vert */
#endif
a103 1
#ifdef USE_LIBDM
d106 1
a106 4
#else
	dmp->dmr_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
	dmp->dmr_2d_line( (int)x3, (int)y3, (int)x4, (int)y4, 0 );
#endif
a121 1
#ifdef USE_LIBDM
d124 1
a124 4
#else
	dmp->dmr_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 1 );
	dmp->dmr_2d_line( (int)x3, (int)y3, (int)x4, (int)y4, 1 );
#endif
a142 1
#ifdef USE_LIBDM
a143 3
#else
		dmp->dmr_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
#endif
a151 1
#ifdef USE_LIBDM
a152 3
#else
		dmp->dmr_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
#endif
a160 1
#ifdef USE_LIBDM
a161 3
#else
		dmp->dmr_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
#endif
a169 1
#ifdef USE_LIBDM
a170 3
#else
		dmp->dmr_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
#endif
a216 1
#ifdef USE_LIBDM
a217 3
#else
	    dmp->dmr_light( LIGHT_OFF, BV_ADCURSOR );
#endif
a219 1
#ifdef USE_LIBDM
a220 3
#else
	    dmp->dmr_light( LIGHT_ON, BV_ADCURSOR );
#endif
@


11.12
log
@rt_list ---> bu_list
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.11 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d74 4
d80 1
a80 1

d108 4
d114 1
a114 1

d130 4
d136 1
a136 1

d155 3
d159 1
d168 3
d172 1
d181 3
d185 1
d194 3
d198 1
d245 3
d249 1
d252 3
d256 1
@


11.11
log
@now using libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.10 1996/07/29 15:43:51 bparker Exp bparker $ (BRL)";
d31 1
@


11.10
log
@fixed tick distance bug in f_adc
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.9 1996/06/21 16:06:47 bparker Exp bparker $ (BRL)";
d224 1
a224 1
	    struct rt_vls cmd;
d226 2
a227 2
	    rt_vls_init(&cmd);
	    rt_vls_strcpy(&cmd, "sliders on\n");
d229 1
a229 1
	    rt_vls_free(&cmd);
@


11.9
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.8 1996/05/24 18:52:32 bparker Exp bparker $ (BRL)";
d40 4
d129 1
a129 1
	c_tdist = ((fastf_t)(dv_distadc) + 2047.0) * 0.5 * M_SQRT2;
d274 1
a274 1
			  (Viewscale * base2local * M_SQRT2) - 1.0) * 2047.0;
d277 1
a277 1
			    (Viewscale * base2local * M_SQRT2) - 1.0) * 2047.0;
@


11.8
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.7 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d211 1
a211 1
	  if (adcflag)  {
d213 1
a213 1
	    adcflag = 0;
d216 1
a216 1
	    adcflag = 1;
d219 9
a227 2
	  rt_vls_printf( &dm_values.dv_string, "set sliders(adc) %d; sliders %s\n",
			 adcflag, scroll_enabled ? "on" : "off");
@


11.7
log
@convert commands to Tcl
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.6 1996/03/22 18:35:22 bparker Exp bparker $ (BRL)";
d201 1
d206 3
d211 7
a217 7
		if (adcflag)  {
			dmp->dmr_light( LIGHT_OFF, BV_ADCURSOR );
			adcflag = 0;
		} else {
			dmp->dmr_light( LIGHT_ON, BV_ADCURSOR );
			adcflag = 1;
		}
d219 4
a222 2
		dmaflag = 1;
		return TCL_OK;
d235 5
a239 1
	    dv_1adc = (1.0 - pt[0] / 45.0) * 2047.0;
d248 5
a252 1
	    dv_2adc = (1.0 - pt[0] / 45.0) * 2047.0;
d261 2
a262 1
	    dv_distadc = (pt[0] /
d264 4
d355 5
a359 1
	    dv_xadc = pt[0];
d368 5
a372 1
	    dv_yadc = pt[0];
@


11.6
log
@cleanup
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.5 1996/03/01 19:35:25 bparker Exp bparker $ (BRL)";
d188 3
a190 1
f_adc (argc, argv)
d202 3
d216 1
a216 1
		return CMD_OK;
d228 7
a234 7
		if (argc == 1) {
			dv_1adc = (1.0 - pt[0] / 45.0) * 2047.0;
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc a1' command accepts only 1 argument\n");
		return CMD_BAD;
d237 7
a243 7
		if (argc == 1) {
			dv_2adc = (1.0 - pt[0] / 45.0) * 2047.0;
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc a2' command accepts only 1 argument\n");
		return CMD_BAD;
d246 8
a253 8
		if (argc == 1) {
			dv_distadc = (pt[0] /
			    (Viewscale * base2local * M_SQRT2) - 1.0) * 2047.0;
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc dst' command accepts only 1 argument\n");
		return CMD_BAD;
d256 7
a262 7
		if (argc == 1) {
			dv_xadc += pt[0] * 2047.0 / (Viewscale * base2local);
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc dh' command accepts only 1 argument\n");
		return CMD_BAD;
d265 7
a271 7
		if (argc == 1) {
			dv_yadc += pt[0] * 2047.0 / (Viewscale * base2local);
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc dv' command accepts only 1 argument\n");
		return CMD_BAD;
d274 10
a283 10
		if (argc == 1) {
			VSET(pt2, pt[0]*local2base, 0.0, 0.0);
			MAT4X3VEC(pt3, Viewrot, pt2);
			dv_xadc += pt3[X] * view2dm;
			dv_yadc += pt3[Y] * view2dm;
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc dx' command accepts only 1 argument\n");
		return CMD_BAD;
d286 10
a295 10
		if (argc == 1) {
			VSET(pt2, 0.0, pt[0]*local2base, 0.0);
			MAT4X3VEC(pt3, Viewrot, pt2);
			dv_xadc += pt3[X] * view2dm;
			dv_yadc += pt3[Y] * view2dm;
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc dy' command accepts only 1 argument\n");
		return CMD_BAD;
d298 10
a307 10
		if (argc == 1) {
			VSET(pt2, 0.0, 0.0, pt[0]*local2base);
			MAT4X3VEC(pt3, Viewrot, pt2);
			dv_xadc += pt3[X] * view2dm;
			dv_yadc += pt3[Y] * view2dm;
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc dz' command accepts only 1 argument\n");
		return CMD_BAD;
d310 10
a319 10
		if (argc == 2) {
			VSCALE(pt, pt, local2base);
			VSUB2(pt3, pt, center_view);
			dv_xadc = pt3[X] * view2dm;
			dv_yadc = pt3[Y] * view2dm;
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc hv' command requires 2 arguments\n");
		return CMD_BAD;
d322 11
a332 11
		if (argc == 3) {
			VSCALE(pt, pt, local2base);
			VSUB2(pt2, pt, center_model);
			MAT4X3VEC(pt3, Viewrot, pt2);
			dv_xadc = pt3[X] * view2dm;
			dv_yadc = pt3[Y] * view2dm;
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log("The 'adc xyz' command requires 2 arguments\n");
		return CMD_BAD;
d335 7
a341 7
		if( argc == 1 ) {
			dv_xadc = pt[0];
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log( "The 'adc x' command requires one argument\n" );
		return CMD_BAD;
d344 7
a350 7
		if( argc == 1 ) {
			dv_yadc = pt[0];
			dmaflag = 1;
			return CMD_OK;
		}
		rt_log( "The 'adc y' command requires one argument\n" );
		return CMD_BAD;
d353 9
a361 11
		if (argc == 0) {
			dv_xadc = dv_yadc = 0;
			dv_1adc = dv_2adc = 0;
			dv_distadc = 0;
			dmaflag = 1;

			return CMD_OK;
		}

		rt_log("The 'adc reset' command accepts no arguments\n");
		return CMD_BAD;
d364 2
a365 2
		rt_log("Usage:\n%s", adc_syntax);
		return CMD_OK;
d367 2
a368 2
		rt_log("ADC: unrecognized command: '%s'\n", argv[1]);
		rt_log("Usage:\n%s", adc_syntax);
d370 1
a370 1
	return CMD_BAD;
@


11.5
log
@remove unused XMGED stuff
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.4 1996/01/17 22:12:53 bparker Exp bparker $ (BRL)";
a37 18
#endif

/*
 * These variables are global for the benefit of
 * the display portion of dotitles.
 */
#ifndef MULTI_ATTACH
fastf_t	curs_x;		/* cursor X position */
fastf_t	curs_y;		/* cursor Y position */
fastf_t	c_tdist;		/* Cursor tick distance */
fastf_t	angle1;		/* Angle to solid wiper */
fastf_t	angle2;		/* Angle to dashed wiper */

static int	dv_xadc;		/* A/D cursor -2048 <= adc <= +2047 */
static int	dv_yadc;
static int	dv_1adc;		/* angle 1 for A/D cursor */
static int	dv_2adc;		/* angle 2 for A/D cursor */
static int	dv_distadc;		/* Tick distance */
@


11.4
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.3 1995/12/27 22:28:16 bparker Exp bparker $ (BRL)";
d227 1
a227 4
#ifdef XMGED
		 if(adc_hook)
                        (*adc_hook)(0);
#endif
d371 1
a371 4
#ifdef XMGED
			if(adc_hook)
			  (*adc_hook)(1);
#endif
@


11.3
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.2 1995/01/17 13:07:36 bparker Exp bparker $ (BRL)";
a49 4
#endif

#ifdef XMGED
extern void (*adc_hook)();
a50 6
int      dv_xadc;                /* A/D cursor -2048 <= adc <= +2047 */
int      dv_yadc;
int      dv_1adc;                /* angle 1 for A/D cursor */
int      dv_2adc;                /* angle 2 for A/D cursor */
int      dv_distadc;             /* Tick distance */
#else
@


11.2
log
@merging xmged sources
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 11.1 95/01/04 10:02:32 mike Rel4_4 $ (BRL)";
d44 1
d50 1
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.9 94/12/28 15:37:14 jra Exp $ (BRL)";
d50 9
d64 1
d235 4
d382 4
d388 1
@


10.9
log
@Removed last occurrences of dm_values by using local variables.
Added dmaflag = 1 to the "adc" commands.
Added "x" and "y" adc commands for use by f_knob().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.8 94/12/16 20:38:40 gdurf Exp Locker: jra $ (BRL)";
@


10.8
log
@Converted puts to rt_log
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.7 1994/12/16 19:34:25 gdurf Exp gdurf $ (BRL)";
d50 5
d78 2
a79 2
	idxy[0] = dm_values.dv_xadc;
	idxy[1] = dm_values.dv_yadc;
d95 2
a96 2
	idxy[0] = -dm_values.dv_1adc;	/* solid line */
	idxy[1] = -dm_values.dv_2adc;	/* dashed line */
d141 1
a141 1
	c_tdist = ((fastf_t)(dm_values.dv_distadc) + 2047.0) * 0.5 * M_SQRT2;
d239 2
a240 2
			dm_values.dv_1adc = (1.0 - pt[0] / 45.0) * 2047.0;
			dm_values.dv_flagadc = 1;
d248 2
a249 2
			dm_values.dv_2adc = (1.0 - pt[0] / 45.0) * 2047.0;
			dm_values.dv_flagadc = 1;
d257 1
a257 1
			dm_values.dv_distadc = (pt[0] /
d259 1
a259 1
			dm_values.dv_flagadc = 1;
d267 2
a268 2
			dm_values.dv_xadc += pt[0] * 2047.0 / (Viewscale * base2local);
			dm_values.dv_flagadc = 1;
d276 2
a277 2
			dm_values.dv_yadc += pt[0] * 2047.0 / (Viewscale * base2local);
			dm_values.dv_flagadc = 1;
d287 3
a289 3
			dm_values.dv_xadc += pt3[X] * view2dm;
			dm_values.dv_yadc += pt3[Y] * view2dm;
			dm_values.dv_flagadc = 1;
d299 3
a301 3
			dm_values.dv_xadc += pt3[X] * view2dm;
			dm_values.dv_yadc += pt3[Y] * view2dm;
			dm_values.dv_flagadc = 1;
d311 3
a313 3
			dm_values.dv_xadc += pt3[X] * view2dm;
			dm_values.dv_yadc += pt3[Y] * view2dm;
			dm_values.dv_flagadc = 1;
d323 3
a325 3
			dm_values.dv_xadc = pt3[X] * view2dm;
			dm_values.dv_yadc = pt3[Y] * view2dm;
			dm_values.dv_flagadc = 1;
d336 3
a338 3
			dm_values.dv_xadc = pt3[X] * view2dm;
			dm_values.dv_yadc = pt3[Y] * view2dm;
			dm_values.dv_flagadc = 1;
d344 18
d364 4
a367 4
			dm_values.dv_xadc = dm_values.dv_yadc = 0;
			dm_values.dv_1adc = dm_values.dv_2adc = 0;
			dm_values.dv_distadc = 0;
			dm_values.dv_flagadc = 1;
@


10.7
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.6 1994/12/05 15:32:16 mike Exp gdurf $ (BRL)";
d351 1
a351 2
		rt_log("Usage:\n");
		(void) fputs(adc_syntax, stdout);
d355 1
a355 2
		rt_log("Usage:\n");
		(void) fputs(adc_syntax, stdout);
@


10.6
log
@Fixed bug #222
Scaling for ADC 'ticks' was wrong.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.5 94/08/11 01:30:33 gdurf Exp Locker: mike $ (BRL)";
d238 1
a238 1
		(void)printf("The 'adc a1' command accepts only 1 argument\n");
d247 1
a247 1
		(void)printf("The 'adc a2' command accepts only 1 argument\n");
d257 1
a257 1
		(void)printf("The 'adc dst' command accepts only 1 argument\n");
d266 1
a266 1
		(void)printf("The 'adc dh' command accepts only 1 argument\n");
d275 1
a275 1
		(void)printf("The 'adc dv' command accepts only 1 argument\n");
d287 1
a287 1
		(void)printf("The 'adc dx' command accepts only 1 argument\n");
d299 1
a299 1
		(void)printf("The 'adc dy' command accepts only 1 argument\n");
d311 1
a311 1
		(void)printf("The 'adc dz' command accepts only 1 argument\n");
d323 1
a323 1
		(void)printf("The 'adc hv' command requires 2 arguments\n");
d336 1
a336 1
		(void)printf("The 'adc xyz' command requires 2 arguments\n");
d347 1
a347 1
		(void)printf("The 'adc reset' command accepts no arguments\n");
d351 1
a351 1
		(void) printf("Usage:\n");
d355 2
a356 2
		(void) printf("ADC: unrecognized command: '%s'\n", argv[1]);
		(void) printf("Usage:\n");
@


10.5
log
@Added include of externs.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.4 1994/08/09 14:54:27 gdurf Exp gdurf $ (BRL)";
d134 1
a134 1
	/* map -2048 - 2047 into 0 - 4096 * sqrt (2) */
d136 1
a136 1
	c_tdist = ((fastf_t)(dm_values.dv_distadc) + 2047.0) * M_SQRT2;
@


10.4
log
@#include "conf.h"
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.3 1994/06/22 18:23:40 gdurf Exp gdurf $ (BRL)";
d30 1
@


10.3
log
@Removed superfluous return statement
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.2 1994/06/01 13:50:00 gdurf Exp gdurf $ (BRL)";
d24 2
@


10.2
log
@Converted f_adc() to use new command return codes
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 10.1 1991/10/12 06:43:02 mike Rel4_0 gdurf $ (BRL)";
a354 1
		return CMD_BAD;
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 9.6 91/07/06 03:28:30 mike Exp $ (BRL)";
d195 2
a196 1
void f_adc (argc, argv)
d218 1
a218 1
		return;
d233 1
a233 1
			return;
d236 1
a236 1
		return;
d242 1
a242 1
			return;
d245 1
a245 1
		return;
d252 1
a252 1
			return;
d255 1
a255 1
		return;
d261 1
a261 1
			return;
d264 1
a264 1
		return;
d270 1
a270 1
			return;
d273 1
a273 1
		return;
d282 1
a282 1
			return;
d285 1
a285 1
		return;
d294 1
a294 1
			return;
d297 1
a297 1
		return;
d306 1
a306 1
			return;
d309 1
a309 1
		return;
d318 1
a318 1
			return;
d321 1
a321 1
		return;
d331 1
a331 1
			return;
d334 1
a334 1
		return;
d342 1
a342 1
			return;
d345 1
a345 1
		return;
d350 1
a350 1
		return;
d355 1
d357 1
a357 1
	return;
@


9.6
log
@Revised ADC command so that the bloody VAX compiler would
compile the code.  All the hairy IF blocks resulted in a
JBRNE instruction being generated with too large an offset
to fit into the offset field.
Ick.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 9.5 91/06/26 16:18:06 pjt Exp $ (BRL)";
@


9.5
log
@Corrected handling of local units on keyboard entry
in f_adc()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 9.4 91/06/25 16:05:54 pjt Exp $ (BRL)";
d201 1
d204 1
d223 1
a223 1
	    pt[i] = atof(argv[i + 2]);
d226 1
d230 8
a237 4
		    dm_values.dv_1adc = (1.0 - pt[0] / 45.0) * 2047.0;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp( parameter, "a2" ) == 0 )  {
d239 8
a246 4
		    dm_values.dv_2adc = (1.0 - pt[0] / 45.0) * 2047.0;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if(strcmp(parameter, "dst") == 0)  {
d248 9
a256 5
		    dm_values.dv_distadc = (pt[0] / (Viewscale * base2local * M_SQRT2) -1.0)
			* 2047.0;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp( parameter, "dh" ) == 0 )  {
d258 8
a265 4
		    dm_values.dv_xadc += pt[0] * 2047.0 / (Viewscale * base2local);
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp( parameter, "dv" ) == 0 )  {
d267 8
a274 4
		    dm_values.dv_yadc += pt[0] * 2047.0 / (Viewscale * base2local);
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp( parameter, "dx" ) == 0 )  {
d276 11
a286 8
		    VSET(pt2, pt[0], 0.0, 0.0);
		    VSCALE(pt2, pt2, local2base);
		    MAT4X3VEC(pt3, Viewrot, pt2);
		    dm_values.dv_xadc += pt3[X] * 2047.0 / Viewscale;
		    dm_values.dv_yadc += pt3[Y] * 2047.0 / Viewscale;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp( parameter, "dy" ) == 0 )  {
d288 11
a298 8
		    VSET(pt2, 0.0, pt[0], 0.0);
		    VSCALE(pt2, pt2, local2base);
		    MAT4X3VEC(pt3, Viewrot, pt2);
		    dm_values.dv_xadc += pt3[X] * 2047.0 / Viewscale;
		    dm_values.dv_yadc += pt3[Y] * 2047.0 / Viewscale;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp( parameter, "dz" ) == 0 )  {
d300 11
a310 8
		    VSET(pt2, 0.0, 0.0, pt[0]);
		    VSCALE(pt2, pt2, local2base);
		    MAT4X3VEC(pt3, Viewrot, pt2);
		    dm_values.dv_xadc += pt3[X] * 2047.0 / Viewscale;
		    dm_values.dv_yadc += pt3[Y] * 2047.0 / Viewscale;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp(parameter, "hv") == 0)  {
d312 11
a322 8
		    MAT4X3VEC(pt2, Viewrot, center_model);
		    VSCALE(pt, pt, local2base);
		    VSUB2(pt3, pt, pt2);
		    dm_values.dv_xadc = pt3[X] * 2047.0 / Viewscale;
		    dm_values.dv_yadc = pt3[Y] * 2047.0 / Viewscale;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp(parameter, "xyz") == 0)  {
d324 12
a335 8
		    VSCALE(pt, pt, local2base);
		    VSUB2(pt2, pt, center_model);
		    MAT4X3VEC(pt3, Viewrot, pt2);
		    dm_values.dv_xadc = pt3[X] * 2047.0 / Viewscale;
		    dm_values.dv_yadc = pt3[Y] * 2047.0 / Viewscale;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp(parameter, "reset") == 0)  {
d337 10
a346 6
		    dm_values.dv_xadc = dm_values.dv_yadc = 0;
		    dm_values.dv_1adc = dm_values.dv_2adc = 0;
		    dm_values.dv_distadc = 0;
		    dm_values.dv_flagadc = 1;
		    return;
	}} else if( strcmp(parameter, "help") == 0)  {
d350 4
a353 5
	} else  {
		(void) printf("ADC: unrecognized parameter: '%s'\n", argv[1]);
		(void) printf("valid parameters: %s\n",
			    "<a1|a2|dst|dh|dv|hv|dx|dy|dz|xyz|reset|help>\n");
		return;
d355 1
a355 5

	(void) printf("ADC: invalid syntax for parameter '%s'\n",
	    parameter);
	(void) printf("usage is:\n");
	(void) fputs(adc_syntax, stdout);
@


9.4
log
@Added/rearranged functionality of f_adc()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 9.3 91/06/14 08:38:32 pjt Exp $ (BRL)";
d254 1
d256 2
a257 2
		    dm_values.dv_xadc += pt3[X] * 2047.0 / (Viewscale * base2local);
		    dm_values.dv_yadc += pt3[Y] * 2047.0 / (Viewscale * base2local);
d263 1
d265 2
a266 2
		    dm_values.dv_xadc += pt3[X] * 2047.0 / (Viewscale * base2local);
		    dm_values.dv_yadc += pt3[Y] * 2047.0 / (Viewscale * base2local);
d272 1
d274 2
a275 2
		    dm_values.dv_xadc += pt3[X] * 2047.0 / (Viewscale * base2local);
		    dm_values.dv_yadc += pt3[Y] * 2047.0 / (Viewscale * base2local);
d281 1
d283 2
a284 2
		    dm_values.dv_xadc = pt3[X] * 2047.0 / (Viewscale * base2local);
		    dm_values.dv_yadc = pt3[Y] * 2047.0 / (Viewscale * base2local);
d289 1
d292 2
a293 2
		    dm_values.dv_xadc = pt3[X] * 2047.0 / (Viewscale * base2local);
		    dm_values.dv_yadc = pt3[Y] * 2047.0 / (Viewscale * base2local);
@


9.3
log
@Corrected the header comment block in f_adc()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/adc.c,v 9.2 91/06/14 06:31:09 mike Exp $ (BRL)";
a178 8
 *
 *	"adc"		toggles display of angle/distance cursor
 *	"adc a1 #"	sets angle1
 *	"adc a2 #"	sets angle2
 *	"adc x #"	sets horz. coord of angle/distance cursor location
 *	"adc y #"	sets vert. coord of angle/distance cursor location
 *	"adc dst #"	sets radius of angle/distance cursor tick
 *	"adc reset"	Resets angles, location, and tick distance
a179 7
#define ADCPARM_A1	1
#define ADCPARM_A2	2
#define ADCPARM_X	3
#define ADCPARM_Y	4
#define ADCPARM_DST	5
#define ADCPARM_RESET	6
#define ADCPARM_NONE	0
d181 14
d200 4
a203 2
	double	f;
	int	parm_code;
d217 1
d219 5
d225 77
a301 12
	if( strcmp( parameter, "x" ) == 0 )  {
		parm_code = ADCPARM_X;
	} else if( strcmp( parameter, "y" ) == 0 )  {
		parm_code = ADCPARM_Y;
	} else if( strcmp( parameter, "a1" ) == 0 )  {
		parm_code = ADCPARM_A1;
	} else if( strcmp( parameter, "a2" ) == 0 )  {
		parm_code = ADCPARM_A2;
	} else if( (strcmp(parameter, "dst") == 0))  {
		parm_code = ADCPARM_DST;
	} else if( (strcmp(parameter, "reset") == 0))  {
		parm_code = ADCPARM_RESET;
d304 2
a305 1
		(void) printf("valid parameters: <a1|a2|x|y|dst|reset>\n");
a307 20
	if (parm_code == ADCPARM_RESET)
	{
		if (argc != 2)
		{
			(void) printf("ADC: the parameter '%s' accepts no value\n",
			    parameter);
			return;
		}
	}
	else
	{
		if (argc == 2)
		{
			(void) printf("ADC: no value provided for parameter '%s'\n",
			    parameter);
			return;
		}
		else
			f = atof(argv[2]);
	}
d309 4
a312 33
	switch (parm_code)
	{
	case ADCPARM_X:
		dm_values.dv_xadc = f * 2047.0 / (Viewscale * base2local);
		dm_values.dv_flagadc = 1;
		return;
	case ADCPARM_Y:
		dm_values.dv_yadc = f * 2047.0 / (Viewscale * base2local);
		dm_values.dv_flagadc = 1;
		return;
	case ADCPARM_A1:
		dm_values.dv_1adc = (1.0 - f / 45.0) * 2047.0;
		dm_values.dv_flagadc = 1;
		return;
	case ADCPARM_A2:
		dm_values.dv_2adc = (1.0 - f / 45.0) * 2047.0;
		dm_values.dv_flagadc = 1;
		return;
	case ADCPARM_DST:
		dm_values.dv_distadc = (f / (Viewscale * base2local * M_SQRT2) -1.0)
		    * 2047.0;
		dm_values.dv_flagadc = 1;
		return;
	case ADCPARM_RESET:
		dm_values.dv_xadc = dm_values.dv_yadc = 0;
		dm_values.dv_1adc = dm_values.dv_2adc = 0;
		dm_values.dv_distadc = 0;
		dm_values.dv_flagadc = 1;
		return;
	default:
		(void) fprintf(stderr,
		    "f_adc(): parm_code=%d.  This shouldn't happen\n", parm_code);
	}
@


9.2
log
@Added ADC command from Paul Tanenbaum
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: adc.c,v 9.1 89/05/19 06:01:37 mike Rel3_5 $ (BRL)";
d182 1
a182 1
 *	"adc a2 #"	sets angle1
@


9.1
log
@Release_3.5
@
text
@d6 1
d10 1
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: adc.c,v 8.1 88/10/05 00:35:15 mike Rel3_0 $ (BRL)";
d29 1
d33 4
d47 1
d133 1
a133 1
	c_tdist = ((fastf_t)(dm_values.dv_distadc) + 2047.0) * 1.4142136;
d174 114
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 7.3 88/09/16 02:34:58 reschly Exp $ (BRL)";
@


7.3
log
@added stdio.h include.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 7.2 87/11/05 05:03:02 reschly Locked $ (BRL)";
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 7.1 87/11/02 23:58:13 mike Rel $ (BRL)";
d23 1
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 6.1 87/07/11 08:01:16 mike Rel $ (BRL)";
d24 1
a24 1
#include "./machine.h"	/* special copy */
d33 5
a37 5
float	curs_x;		/* cursor X position */
float	curs_y;		/* cursor Y position */
float	c_tdist;		/* Cursor tick distance */
float	angle1;		/* Angle to solid wiper */
float	angle2;		/* Angle to dashed wiper */
d48 6
a53 6
	static float	x1, Y1;	/* not "y1", due to conflict with math lib */
	static float	x2, y2;
	static float	x3, y3;
	static float	x4, y4;
	static float	d1, d2;
	static float	t1, t2;
d71 2
a72 2
	curs_x = (float) (idxy[0]);
	curs_y = (float) (idxy[1]);
d80 2
a81 2
	angle1 = ((2047.0 + (float) (idxy[0])) * pi) / (4.0 * 2047.0);
	angle2 = ((2047.0 + (float) (idxy[1])) * pi) / (4.0 * 2047.0);
d124 1
a124 1
	c_tdist = ((float)(dm_values.dv_distadc) + 2047.0) * 1.4142136;
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 5.1 87/06/24 22:17:25 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 4.2 87/02/13 00:05:03 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 4.1 86/12/29 03:18:44 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 2.4 86/08/12 06:45:58 mike Exp $ (BRL)";
@


2.4
log
@Changed #includes for CC -I../h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 2.3 85/09/14 05:33:23 mike Exp $ (BRL)";
@


2.3
log
@Lint-inspired cleanup.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 2.2 85/08/07 05:16:06 mike Exp $ (BRL)";
d25 3
a27 3
#include "../h/vmath.h"
#include "ged.h"
#include "dm.h"
@


2.2
log
@Changed to use common ../h/vmath.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: adc.c,v 2.1 85/03/11 23:53:23 mike Prod $ (BRL)";
d45 1
a45 1
adcursor( tick_dist )
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d24 2
a25 1
#include "ged_types.h"
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d10 8
a17 3
 *	Ballistic Research Laboratory
 *	U. S. Army
 *	December, 1981
d19 4
d44 1
a44 1
adcursor( pos_x, pos_y, rot1, rot2, tick_dist )
d60 2
a61 2
	idxy[0] = pos_x;
	idxy[1] = pos_y;
d76 3
a78 2
	idxy[0] = -rot1;	/* - to make rotation match knob direction */
	idxy[1] = -rot2;
d122 2
a123 1
	c_tdist = ((float)(tick_dist) + 2047.0) * 1.4142136;
@


1.1
log
@Initial revision
@
text
@a0 1
/*	SCCSID	%W%	%E%	*/
d2 1
a2 1
 *			G E D 1 2 . C
a12 13
 *
 *		R E V I S I O N   H I S T O R Y
 *
 *	12/01/81  Moss	Add the angle/distance cursor.
 *
 *	12/02/81  MJM	Modified to take parameters as arguments.
 *
 *	05/27/83  MJM	Adapted code to run on VAX;  numerous cleanups.
 *
 *	09-Sep-83 DAG	Overhauled.
 *
 *	11/02/83  MJM	Changed to use display manager, plus cleanups
 *			for adding Megatek support.
a13 1

d17 1
d21 1
a21 1
 * the display portion of dozoom.
d58 2
a59 2
	dm_2d_line( MINVAL, idxy[1], MAXVAL, idxy[1], 0 );	/* Horiz */
	dm_2d_line( idxy[0], MAXVAL, idxy[0], MINVAL, 0);	/* Vert */
d87 2
a88 2
	dm_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
	dm_2d_line( (int)x3, (int)y3, (int)x4, (int)y4, 0 );
d105 2
a106 2
	dm_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 1 );
	dm_2d_line( (int)x3, (int)y3, (int)x4, (int)y4, 1 );
d125 1
a125 1
		dm_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
d134 1
a134 1
		dm_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
d143 1
a143 1
		dm_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
d152 1
a152 1
		dm_2d_line( (int)x1, (int)Y1, (int)x2, (int)y2, 0 );
@
