head	11.289;
access;
symbols
	ansi-20040405-merged:11.280.2.2
	postmerge-20040405-ansi:11.286
	premerge-20040404-ansi:11.285
	postmerge-autoconf:11.285
	autoconf-freeze:11.283.4.3
	premerge-autoconf:11.285
	postmerge-20040315-windows:11.285
	premerge-20040315-windows:11.284
	windows-20040315-freeze:11.280.4.2
	autoconf-20031203:11.283
	autoconf-20031202:11.283
	autoconf-branch:11.283.0.4
	phong-branch:11.283.0.2
	photonmap-branch:11.282.0.2
	rel-6-1-DP:11.281
	windows-branch:11.280.0.4
	rel-6-0-2:11.274
	ansi-branch:11.280.0.2
	rel-6-0-1-branch:11.274.0.2
	hartley-6-0-post:11.278
	hartley-6-0-pre:11.277
	rel-6-0-1:11.274
	rel-6-0:11.273
	rel-5-4:11.222.2.7
	offsite-5-3-pre:11.241
	rel-5-3:11.222.2.7
	rel-5-2:11.222.2.1
	rel-5-1-branch:11.222.0.2
	rel-5-1:11.222
	rel-5-0:11.209
	rel-5-0-beta:11.209
	rel-4-5:11.189
	ctj-4-5-post:11.164
	ctj-4-5-pre:11.164
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.13;
locks; strict;
comment	@ * @;


11.289
date	2004.05.21.17.47.37;	author morrison;	state dead;
branches;
next	11.288;

11.288
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.287;

11.287
date	2004.05.05.14.20.29;	author morrison;	state Exp;
branches;
next	11.286;

11.286
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.285;

11.285
date	2004.03.16.21.15.10;	author morrison;	state Exp;
branches;
next	11.284;

11.284
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.283;

11.283
date	2003.09.05.14.39.53;	author jra;	state Exp;
branches
	11.283.4.1;
next	11.282;

11.282
date	2003.01.31.13.39.05;	author jra;	state Exp;
branches;
next	11.281;

11.281
date	2002.10.25.02.30.12;	author morrison;	state Exp;
branches;
next	11.280;

11.280
date	2002.08.28.16.51.51;	author morrison;	state Exp;
branches
	11.280.2.1
	11.280.4.1;
next	11.279;

11.279
date	2002.08.20.17.08.22;	author jra;	state Exp;
branches;
next	11.278;

11.278
date	2002.08.15.20.55.33;	author hartley;	state Exp;
branches;
next	11.277;

11.277
date	2002.08.14.17.25.57;	author jra;	state Exp;
branches;
next	11.276;

11.276
date	2002.08.12.18.25.38;	author morrison;	state Exp;
branches;
next	11.275;

11.275
date	2002.08.11.02.10.44;	author morrison;	state Exp;
branches;
next	11.274;

11.274
date	2002.06.19.20.14.32;	author butler;	state Exp;
branches;
next	11.273;

11.273
date	2002.02.26.20.31.22;	author jra;	state Exp;
branches;
next	11.272;

11.272
date	2002.02.22.16.09.44;	author jra;	state Exp;
branches;
next	11.271;

11.271
date	2002.02.17.03.08.49;	author jra;	state Exp;
branches;
next	11.270;

11.270
date	2002.02.05.03.14.19;	author jra;	state Exp;
branches;
next	11.269;

11.269
date	2002.01.22.19.01.50;	author jra;	state Exp;
branches;
next	11.268;

11.268
date	2001.12.13.19.37.28;	author jra;	state Exp;
branches;
next	11.267;

11.267
date	2001.11.15.22.07.48;	author bparker;	state Exp;
branches;
next	11.266;

11.266
date	2001.11.09.20.40.03;	author bparker;	state Exp;
branches;
next	11.265;

11.265
date	2001.10.17.07.40.04;	author morrison;	state Exp;
branches;
next	11.264;

11.264
date	2001.10.05.21.19.55;	author bparker;	state Exp;
branches;
next	11.263;

11.263
date	2001.10.04.16.01.33;	author bparker;	state Exp;
branches;
next	11.262;

11.262
date	2001.10.04.15.35.46;	author bparker;	state Exp;
branches;
next	11.261;

11.261
date	2001.09.19.22.20.35;	author bparker;	state Exp;
branches;
next	11.260;

11.260
date	2001.09.10.23.11.03;	author bparker;	state Exp;
branches;
next	11.259;

11.259
date	2001.09.10.22.39.33;	author bparker;	state Exp;
branches;
next	11.258;

11.258
date	2001.09.07.21.40.12;	author bparker;	state Exp;
branches;
next	11.257;

11.257
date	2001.09.06.18.41.55;	author bparker;	state Exp;
branches;
next	11.256;

11.256
date	2001.08.02.17.38.43;	author jra;	state Exp;
branches;
next	11.255;

11.255
date	2001.06.25.21.26.54;	author bparker;	state Exp;
branches;
next	11.254;

11.254
date	2001.06.18.19.22.56;	author bparker;	state Exp;
branches;
next	11.253;

11.253
date	2001.06.13.20.28.52;	author jra;	state Exp;
branches;
next	11.252;

11.252
date	2001.06.06.16.46.08;	author bparker;	state Exp;
branches;
next	11.251;

11.251
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	11.250;

11.250
date	2001.06.01.19.23.23;	author bparker;	state Exp;
branches;
next	11.249;

11.249
date	2001.05.04.14.43.27;	author bparker;	state Exp;
branches;
next	11.248;

11.248
date	2001.05.04.14.20.46;	author bparker;	state Exp;
branches;
next	11.247;

11.247
date	2001.05.03.17.01.47;	author bparker;	state Exp;
branches;
next	11.246;

11.246
date	2001.04.12.14.55.29;	author bparker;	state Exp;
branches;
next	11.245;

11.245
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	11.244;

11.244
date	2001.04.02.20.07.16;	author jra;	state Exp;
branches;
next	11.243;

11.243
date	2001.03.23.22.05.32;	author jra;	state Exp;
branches;
next	11.242;

11.242
date	2001.03.20.21.48.20;	author pjt;	state Exp;
branches;
next	11.241;

11.241
date	2001.02.21.18.31.27;	author bparker;	state Exp;
branches;
next	11.240;

11.240
date	2001.01.04.17.02.21;	author bparker;	state Exp;
branches;
next	11.239;

11.239
date	2001.01.03.21.30.00;	author bparker;	state Exp;
branches;
next	11.238;

11.238
date	2000.12.22.00.32.47;	author bparker;	state Exp;
branches;
next	11.237;

11.237
date	2000.12.15.21.29.20;	author bparker;	state Exp;
branches;
next	11.236;

11.236
date	2000.11.16.21.20.29;	author bparker;	state Exp;
branches;
next	11.235;

11.235
date	2000.10.24.19.05.05;	author mike;	state Exp;
branches;
next	11.234;

11.234
date	2000.10.24.14.46.22;	author mike;	state Exp;
branches;
next	11.233;

11.233
date	2000.09.08.14.39.54;	author bparker;	state Exp;
branches;
next	11.232;

11.232
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	11.231;

11.231
date	2000.09.07.02.43.20;	author mike;	state Exp;
branches;
next	11.230;

11.230
date	2000.08.20.01.14.29;	author jra;	state Exp;
branches;
next	11.229;

11.229
date	2000.08.19.03.10.12;	author mike;	state Exp;
branches;
next	11.228;

11.228
date	2000.08.17.18.11.59;	author bparker;	state Exp;
branches;
next	11.227;

11.227
date	2000.08.17.01.26.43;	author mike;	state Exp;
branches;
next	11.226;

11.226
date	2000.08.09.20.43.23;	author bparker;	state Exp;
branches;
next	11.225;

11.225
date	2000.07.05.22.23.45;	author mike;	state Exp;
branches;
next	11.224;

11.224
date	2000.07.05.20.50.50;	author mike;	state Exp;
branches;
next	11.223;

11.223
date	2000.06.30.20.10.22;	author pjt;	state Exp;
branches;
next	11.222;

11.222
date	2000.06.07.19.28.08;	author bparker;	state Exp;
branches
	11.222.2.1;
next	11.221;

11.221
date	2000.06.05.21.53.05;	author bparker;	state Exp;
branches;
next	11.220;

11.220
date	2000.06.02.20.21.11;	author bparker;	state Exp;
branches;
next	11.219;

11.219
date	2000.04.20.21.21.13;	author bparker;	state Exp;
branches;
next	11.218;

11.218
date	2000.04.12.22.42.40;	author bparker;	state Exp;
branches;
next	11.217;

11.217
date	99.12.30.19.22.37;	author jra;	state Exp;
branches;
next	11.216;

11.216
date	99.12.29.23.23.18;	author mike;	state Exp;
branches;
next	11.215;

11.215
date	99.12.21.13.54.13;	author jra;	state Exp;
branches;
next	11.214;

11.214
date	99.12.20.19.59.13;	author jra;	state Exp;
branches;
next	11.213;

11.213
date	99.10.27.17.38.52;	author bparker;	state Exp;
branches;
next	11.212;

11.212
date	99.10.26.18.54.58;	author bparker;	state Exp;
branches;
next	11.211;

11.211
date	99.10.26.17.33.43;	author bparker;	state Exp;
branches;
next	11.210;

11.210
date	99.10.22.21.39.35;	author bparker;	state Exp;
branches;
next	11.209;

11.209
date	99.05.03.16.47.34;	author bparker;	state Exp;
branches;
next	11.208;

11.208
date	99.03.11.18.27.29;	author bparker;	state Exp;
branches;
next	11.207;

11.207
date	99.02.02.18.14.46;	author bparker;	state Exp;
branches;
next	11.206;

11.206
date	99.01.27.20.33.54;	author bparker;	state Exp;
branches;
next	11.205;

11.205
date	99.01.26.19.02.18;	author bparker;	state Exp;
branches;
next	11.204;

11.204
date	99.01.25.18.17.20;	author bparker;	state Exp;
branches;
next	11.203;

11.203
date	99.01.21.18.28.04;	author bparker;	state Exp;
branches;
next	11.202;

11.202
date	99.01.19.22.21.46;	author bparker;	state Exp;
branches;
next	11.201;

11.201
date	99.01.12.18.20.02;	author bparker;	state Exp;
branches;
next	11.200;

11.200
date	98.12.28.21.54.17;	author mike;	state Exp;
branches;
next	11.199;

11.199
date	98.11.06.22.14.21;	author bparker;	state Exp;
branches;
next	11.198;

11.198
date	98.10.21.17.17.19;	author bparker;	state Exp;
branches;
next	11.197;

11.197
date	98.08.21.21.00.51;	author mike;	state Exp;
branches;
next	11.196;

11.196
date	98.08.13.11.53.52;	author bparker;	state Exp;
branches;
next	11.195;

11.195
date	98.06.24.17.52.32;	author bparker;	state Exp;
branches;
next	11.194;

11.194
date	98.06.08.20.51.07;	author bparker;	state Exp;
branches;
next	11.193;

11.193
date	98.05.18.19.35.08;	author bparker;	state Exp;
branches;
next	11.192;

11.192
date	98.04.10.18.21.12;	author bparker;	state Exp;
branches;
next	11.191;

11.191
date	98.03.19.17.58.02;	author bparker;	state Exp;
branches;
next	11.190;

11.190
date	98.02.20.23.21.44;	author bparker;	state Exp;
branches;
next	11.189;

11.189
date	98.02.06.22.06.13;	author bparker;	state Exp;
branches;
next	11.188;

11.188
date	98.01.28.16.14.34;	author bparker;	state Exp;
branches;
next	11.187;

11.187
date	98.01.16.22.05.58;	author bparker;	state Exp;
branches;
next	11.186;

11.186
date	97.12.23.14.13.52;	author bparker;	state Exp;
branches;
next	11.185;

11.185
date	97.12.08.21.17.08;	author pjt;	state Exp;
branches;
next	11.184;

11.184
date	97.12.08.20.37.37;	author bparker;	state Exp;
branches;
next	11.183;

11.183
date	97.10.24.13.41.36;	author jra;	state Exp;
branches;
next	11.182;

11.182
date	97.10.08.04.42.05;	author mike;	state Exp;
branches;
next	11.181;

11.181
date	97.10.08.04.38.18;	author mike;	state Exp;
branches;
next	11.180;

11.180
date	97.09.23.21.12.41;	author bparker;	state Exp;
branches;
next	11.179;

11.179
date	97.09.19.20.43.28;	author bparker;	state Exp;
branches;
next	11.178;

11.178
date	97.09.11.13.38.25;	author bparker;	state Exp;
branches;
next	11.177;

11.177
date	97.09.08.19.47.31;	author bparker;	state Exp;
branches;
next	11.176;

11.176
date	97.09.08.19.02.29;	author bparker;	state Exp;
branches;
next	11.175;

11.175
date	97.08.26.05.54.22;	author mike;	state Exp;
branches;
next	11.174;

11.174
date	97.08.15.19.21.42;	author jra;	state Exp;
branches;
next	11.173;

11.173
date	97.07.31.14.28.22;	author bparker;	state Exp;
branches;
next	11.172;

11.172
date	97.07.25.20.41.41;	author bparker;	state Exp;
branches;
next	11.171;

11.171
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.170;

11.170
date	97.06.25.02.03.15;	author mike;	state Exp;
branches;
next	11.169;

11.169
date	97.06.20.03.46.52;	author gdurf;	state Exp;
branches;
next	11.168;

11.168
date	97.06.19.20.53.40;	author bparker;	state Exp;
branches;
next	11.167;

11.167
date	97.06.19.17.01.51;	author bparker;	state Exp;
branches;
next	11.166;

11.166
date	97.06.13.23.19.51;	author mike;	state Exp;
branches;
next	11.165;

11.165
date	97.06.13.23.14.51;	author mike;	state Exp;
branches;
next	11.164;

11.164
date	97.05.28.22.34.49;	author mike;	state Exp;
branches;
next	11.163;

11.163
date	97.05.28.22.32.18;	author mike;	state Exp;
branches;
next	11.162;

11.162
date	97.05.21.12.53.12;	author bparker;	state Exp;
branches;
next	11.161;

11.161
date	97.05.09.21.03.10;	author bparker;	state Exp;
branches;
next	11.160;

11.160
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.159;

11.159
date	97.04.23.18.31.41;	author bparker;	state Exp;
branches;
next	11.158;

11.158
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.157;

11.157
date	97.04.14.12.27.11;	author bparker;	state Exp;
branches;
next	11.156;

11.156
date	97.04.04.20.07.18;	author bparker;	state Exp;
branches;
next	11.155;

11.155
date	97.03.28.21.39.08;	author jra;	state Exp;
branches;
next	11.154;

11.154
date	97.03.28.17.46.51;	author pjt;	state Exp;
branches;
next	11.153;

11.153
date	97.03.20.23.00.39;	author bparker;	state Exp;
branches;
next	11.152;

11.152
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.151;

11.151
date	97.03.11.21.41.43;	author jra;	state Exp;
branches;
next	11.150;

11.150
date	97.03.07.10.47.27;	author mike;	state Exp;
branches;
next	11.149;

11.149
date	97.03.05.04.05.29;	author mike;	state Exp;
branches;
next	11.148;

11.148
date	97.03.05.02.03.00;	author mike;	state Exp;
branches;
next	11.147;

11.147
date	97.02.28.21.34.51;	author bparker;	state Exp;
branches;
next	11.146;

11.146
date	97.02.25.14.45.36;	author jra;	state Exp;
branches;
next	11.145;

11.145
date	97.02.24.22.04.02;	author bparker;	state Exp;
branches;
next	11.144;

11.144
date	97.02.14.22.09.28;	author bparker;	state Exp;
branches;
next	11.143;

11.143
date	97.02.14.08.52.45;	author mike;	state Exp;
branches;
next	11.142;

11.142
date	97.02.14.08.36.29;	author mike;	state Exp;
branches;
next	11.141;

11.141
date	97.02.13.17.02.00;	author jra;	state Exp;
branches;
next	11.140;

11.140
date	97.02.13.15.45.31;	author pjt;	state Exp;
branches;
next	11.139;

11.139
date	97.02.12.21.17.52;	author pjt;	state Exp;
branches;
next	11.138;

11.138
date	97.02.04.22.12.15;	author bparker;	state Exp;
branches;
next	11.137;

11.137
date	97.02.01.03.14.36;	author mike;	state Exp;
branches;
next	11.136;

11.136
date	97.02.01.03.05.35;	author mike;	state Exp;
branches;
next	11.135;

11.135
date	97.01.31.05.50.49;	author mike;	state Exp;
branches;
next	11.134;

11.134
date	97.01.30.00.54.01;	author mike;	state Exp;
branches;
next	11.133;

11.133
date	97.01.29.16.39.46;	author jra;	state Exp;
branches;
next	11.132;

11.132
date	97.01.29.16.30.28;	author bparker;	state Exp;
branches;
next	11.131;

11.131
date	97.01.24.20.51.58;	author bparker;	state Exp;
branches;
next	11.130;

11.130
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.129;

11.129
date	97.01.10.21.56.48;	author bparker;	state Exp;
branches;
next	11.128;

11.128
date	97.01.09.01.44.19;	author mike;	state Exp;
branches;
next	11.127;

11.127
date	97.01.08.21.58.39;	author bparker;	state Exp;
branches;
next	11.126;

11.126
date	97.01.02.19.41.06;	author bparker;	state Exp;
branches;
next	11.125;

11.125
date	96.12.23.20.40.49;	author bparker;	state Exp;
branches;
next	11.124;

11.124
date	96.12.17.22.40.29;	author bparker;	state Exp;
branches;
next	11.123;

11.123
date	96.12.13.23.10.54;	author bparker;	state Exp;
branches;
next	11.122;

11.122
date	96.12.12.22.10.09;	author bparker;	state Exp;
branches;
next	11.121;

11.121
date	96.12.11.22.40.57;	author bparker;	state Exp;
branches;
next	11.120;

11.120
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.119;

11.119
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.118;

11.118
date	96.12.06.21.55.11;	author bparker;	state Exp;
branches;
next	11.117;

11.117
date	96.12.04.21.11.10;	author bparker;	state Exp;
branches;
next	11.116;

11.116
date	96.11.27.08.56.16;	author mike;	state Exp;
branches;
next	11.115;

11.115
date	96.11.27.08.50.01;	author mike;	state Exp;
branches;
next	11.114;

11.114
date	96.11.19.21.46.36;	author bparker;	state Exp;
branches;
next	11.113;

11.113
date	96.11.01.22.10.27;	author bparker;	state Exp;
branches;
next	11.112;

11.112
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.111;

11.111
date	96.10.18.13.55.07;	author bparker;	state Exp;
branches;
next	11.110;

11.110
date	96.10.10.20.12.53;	author jra;	state Exp;
branches;
next	11.109;

11.109
date	96.10.08.19.38.20;	author jra;	state Exp;
branches;
next	11.108;

11.108
date	96.10.03.20.44.41;	author bparker;	state Exp;
branches;
next	11.107;

11.107
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.106;

11.106
date	96.09.26.20.40.29;	author bparker;	state Exp;
branches;
next	11.105;

11.105
date	96.09.25.19.59.43;	author bparker;	state Exp;
branches;
next	11.104;

11.104
date	96.09.23.18.35.25;	author bparker;	state Exp;
branches;
next	11.103;

11.103
date	96.09.17.21.22.32;	author bparker;	state Exp;
branches;
next	11.102;

11.102
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.101;

11.101
date	96.09.03.13.07.52;	author jra;	state Exp;
branches;
next	11.100;

11.100
date	96.08.28.19.40.56;	author bparker;	state Exp;
branches;
next	11.99;

11.99
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.98;

11.98
date	96.08.27.04.10.42;	author mike;	state Exp;
branches;
next	11.97;

11.97
date	96.08.22.20.46.10;	author bparker;	state Exp;
branches;
next	11.96;

11.96
date	96.08.21.14.06.23;	author jra;	state Exp;
branches;
next	11.95;

11.95
date	96.08.20.20.38.32;	author jra;	state Exp;
branches;
next	11.94;

11.94
date	96.08.20.19.19.52;	author bparker;	state Exp;
branches;
next	11.93;

11.93
date	96.08.14.18.11.36;	author jra;	state Exp;
branches;
next	11.92;

11.92
date	96.08.02.18.02.24;	author bparker;	state Exp;
branches;
next	11.91;

11.91
date	96.07.31.00.17.24;	author cnuzman;	state Exp;
branches;
next	11.90;

11.90
date	96.07.30.21.28.59;	author bparker;	state Exp;
branches;
next	11.89;

11.89
date	96.07.25.17.56.14;	author bparker;	state Exp;
branches;
next	11.88;

11.88
date	96.07.19.20.48.37;	author bparker;	state Exp;
branches;
next	11.87;

11.87
date	96.07.15.20.31.51;	author bparker;	state Exp;
branches;
next	11.86;

11.86
date	96.07.10.20.25.02;	author bparker;	state Exp;
branches;
next	11.85;

11.85
date	96.06.28.22.46.18;	author cnuzman;	state Exp;
branches;
next	11.84;

11.84
date	96.06.21.16.01.21;	author bparker;	state Exp;
branches;
next	11.83;

11.83
date	96.06.19.16.26.08;	author cnuzman;	state Exp;
branches;
next	11.82;

11.82
date	96.06.18.17.33.51;	author cnuzman;	state Exp;
branches;
next	11.81;

11.81
date	96.06.14.19.59.00;	author bparker;	state Exp;
branches;
next	11.80;

11.80
date	96.06.11.16.57.53;	author bparker;	state Exp;
branches;
next	11.79;

11.79
date	96.06.03.12.46.48;	author jra;	state Exp;
branches;
next	11.78;

11.78
date	96.05.31.22.30.22;	author bparker;	state Exp;
branches;
next	11.77;

11.77
date	96.05.24.18.19.48;	author bparker;	state Exp;
branches;
next	11.76;

11.76
date	96.05.13.20.48.28;	author bparker;	state Exp;
branches;
next	11.75;

11.75
date	96.05.02.21.29.03;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	96.04.03.22.04.20;	author bparker;	state Exp;
branches;
next	11.71;

11.71
date	96.04.01.22.18.15;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	96.03.25.21.50.49;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	96.03.22.18.31.55;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	96.03.11.21.47.35;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	96.03.01.19.20.05;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	96.02.22.16.26.51;	author jra;	state Exp;
branches;
next	11.65;

11.65
date	96.02.22.15.38.55;	author bparker;	state Exp;
branches;
next	11.64;

11.64
date	96.02.16.16.52.53;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	96.02.16.16.43.30;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	96.02.09.22.15.12;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	96.02.01.18.32.09;	author pjt;	state Exp;
branches;
next	11.60;

11.60
date	96.02.01.17.19.30;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	96.01.17.22.13.56;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	95.12.07.16.33.15;	author jra;	state Exp;
branches;
next	11.56;

11.56
date	95.12.02.00.21.12;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	95.11.29.21.21.31;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	95.11.28.22.45.23;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	95.11.22.17.22.29;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	95.11.09.22.25.49;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	95.11.03.21.56.46;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	95.09.26.20.21.21;	author pjt;	state Exp;
branches;
next	11.49;

11.49
date	95.09.25.17.28.55;	author pjt;	state Exp;
branches;
next	11.48;

11.48
date	95.09.22.02.00.24;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	95.09.09.03.06.32;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	95.09.09.02.34.00;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	95.09.09.02.02.05;	author butler;	state Exp;
branches;
next	11.44;

11.44
date	95.08.30.19.10.34;	author cnuzman;	state Exp;
branches;
next	11.43;

11.43
date	95.08.29.21.23.26;	author cnuzman;	state Exp;
branches;
next	11.42;

11.42
date	95.08.28.16.31.04;	author cnuzman;	state Exp;
branches;
next	11.41;

11.41
date	95.08.25.23.31.15;	author cnuzman;	state Exp;
branches;
next	11.40;

11.40
date	95.08.25.20.25.05;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	95.08.25.20.17.08;	author cnuzman;	state Exp;
branches;
next	11.38;

11.38
date	95.08.24.23.12.42;	author cnuzman;	state Exp;
branches;
next	11.37;

11.37
date	95.08.24.06.29.29;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	95.08.09.15.08.33;	author gdurf;	state Exp;
branches;
next	11.35;

11.35
date	95.08.07.14.35.31;	author gdurf;	state Exp;
branches;
next	11.34;

11.34
date	95.08.03.21.44.32;	author gdurf;	state Exp;
branches;
next	11.33;

11.33
date	95.07.28.17.57.03;	author gdurf;	state Exp;
branches;
next	11.32;

11.32
date	95.07.28.07.37.05;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	95.07.27.21.48.02;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	95.07.27.21.14.22;	author gdurf;	state Exp;
branches;
next	11.29;

11.29
date	95.07.25.17.53.04;	author gdurf;	state Exp;
branches;
next	11.28;

11.28
date	95.07.19.16.02.02;	author pjt;	state Exp;
branches;
next	11.27;

11.27
date	95.07.18.22.52.58;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	95.07.07.20.18.30;	author pjt;	state Exp;
branches;
next	11.25;

11.25
date	95.07.07.17.13.13;	author gdurf;	state Exp;
branches;
next	11.24;

11.24
date	95.07.06.19.23.26;	author gdurf;	state Exp;
branches;
next	11.23;

11.23
date	95.07.06.14.14.45;	author gdurf;	state Exp;
branches;
next	11.22;

11.22
date	95.07.06.14.12.37;	author gdurf;	state Exp;
branches;
next	11.21;

11.21
date	95.07.06.13.56.33;	author gdurf;	state Exp;
branches;
next	11.20;

11.20
date	95.06.23.20.20.50;	author pjt;	state Exp;
branches;
next	11.19;

11.19
date	95.06.22.14.40.40;	author gdurf;	state Exp;
branches;
next	11.18;

11.18
date	95.05.30.18.50.22;	author gdurf;	state Exp;
branches;
next	11.17;

11.17
date	95.05.30.15.08.13;	author gdurf;	state Exp;
branches;
next	11.16;

11.16
date	95.03.31.20.45.49;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	95.03.10.23.40.23;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	95.03.10.20.54.16;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	95.03.10.20.47.03;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.03.10.19.18.14;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.03.09.20.56.34;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	95.02.13.15.45.48;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.01.25.15.24.19;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.01.25.14.07.35;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.01.19.16.21.01;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	95.01.19.12.06.20;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.01.18.08.29.34;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.01.17.16.27.54;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.01.17.16.20.07;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.10.17.12.44;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.46;	author mike;	state Rel4_4;
branches;
next	10.58;

10.58
date	95.01.03.14.32.48;	author gdurf;	state Exp;
branches;
next	10.57;

10.57
date	94.12.28.17.02.14;	author gdurf;	state Exp;
branches;
next	10.56;

10.56
date	94.12.28.14.44.14;	author gdurf;	state Exp;
branches;
next	10.55;

10.55
date	94.12.28.12.27.42;	author gdurf;	state Exp;
branches;
next	10.54;

10.54
date	94.12.28.12.24.46;	author gdurf;	state Exp;
branches;
next	10.53;

10.53
date	94.12.28.12.20.08;	author gdurf;	state Exp;
branches;
next	10.52;

10.52
date	94.12.28.11.02.45;	author gdurf;	state Exp;
branches;
next	10.51;

10.51
date	94.12.27.22.59.16;	author mike;	state Exp;
branches;
next	10.50;

10.50
date	94.12.27.22.58.34;	author gdurf;	state Exp;
branches;
next	10.49;

10.49
date	94.12.27.18.00.27;	author gdurf;	state Exp;
branches;
next	10.48;

10.48
date	94.12.23.23.48.04;	author gdurf;	state Exp;
branches;
next	10.47;

10.47
date	94.12.23.23.31.07;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	94.12.23.23.25.33;	author gdurf;	state Exp;
branches;
next	10.45;

10.45
date	94.12.16.19.35.47;	author gdurf;	state Exp;
branches;
next	10.44;

10.44
date	94.12.05.13.59.52;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	94.11.22.12.27.32;	author jra;	state Exp;
branches;
next	10.42;

10.42
date	94.11.15.15.31.12;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	94.11.14.17.18.06;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	94.11.07.16.04.16;	author jra;	state Exp;
branches;
next	10.39;

10.39
date	94.11.05.03.50.20;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	94.10.06.13.03.26;	author jra;	state Exp;
branches;
next	10.37;

10.37
date	94.09.28.15.45.22;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.09.24.02.32.54;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.08.27.03.22.55;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	94.08.19.16.12.46;	author pjt;	state Exp;
branches;
next	10.33;

10.33
date	94.08.19.10.14.25;	author pjt;	state Exp;
branches;
next	10.32;

10.32
date	94.08.17.16.16.27;	author pjt;	state Exp;
branches;
next	10.31;

10.31
date	94.08.09.18.03.41;	author gdurf;	state Exp;
branches;
next	10.30;

10.30
date	94.08.09.11.47.00;	author pjt;	state Exp;
branches;
next	10.29;

10.29
date	94.08.09.10.26.09;	author pjt;	state Exp;
branches;
next	10.28;

10.28
date	94.06.24.20.10.36;	author gdurf;	state Exp;
branches;
next	10.27;

10.27
date	94.06.13.19.09.05;	author gdurf;	state Exp;
branches;
next	10.26;

10.26
date	94.04.20.09.49.43;	author jra;	state Exp;
branches;
next	10.25;

10.25
date	94.04.05.17.11.44;	author cjohnson;	state Exp;
branches;
next	10.24;

10.24
date	94.03.24.16.25.36;	author cjohnson;	state Exp;
branches;
next	10.23;

10.23
date	94.03.22.19.38.16;	author cjohnson;	state Exp;
branches;
next	10.22;

10.22
date	94.03.17.00.42.38;	author cjohnson;	state Exp;
branches;
next	10.21;

10.21
date	94.03.08.21.30.43;	author pjt;	state Exp;
branches;
next	10.20;

10.20
date	94.01.06.12.26.28;	author pjt;	state Exp;
branches;
next	10.19;

10.19
date	94.01.05.13.14.05;	author pjt;	state Exp;
branches;
next	10.18;

10.18
date	93.11.18.02.33.07;	author butler;	state Exp;
branches;
next	10.17;

10.17
date	93.11.05.12.22.55;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.07.15.21.28.01;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.07.13.21.01.11;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.03.24.04.07.09;	author phil;	state Exp;
branches;
next	10.13;

10.13
date	92.11.23.20.53.40;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	92.09.03.19.37.02;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	92.08.05.17.14.12;	author gdurf;	state Exp;
branches;
next	10.10;

10.10
date	92.06.25.21.05.10;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	92.06.05.22.31.17;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.05.04.14.12.25;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.04.16.03.21.45;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.04.16.03.21.26;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.04.15.23.43.43;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.04.03.19.24.18;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.12.19.03.22.45;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.11.05.00.02.44;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.14;	author mike;	state Rel4_0;
branches;
next	9.29;

9.29
date	91.08.31.07.30.40;	author butler;	state Exp;
branches;
next	9.28;

9.28
date	91.08.25.04.57.53;	author butler;	state Exp;
branches;
next	9.27;

9.27
date	91.08.25.04.30.33;	author butler;	state Exp;
branches;
next	9.26;

9.26
date	91.07.09.01.57.10;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.07.01.01.44.04;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.07.01.01.35.18;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.06.30.21.14.24;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.06.25.16.08.04;	author pjt;	state Exp;
branches;
next	9.21;

9.21
date	91.06.14.06.03.28;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.02.06.23.57.56;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.01.12.08.05.28;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.01.05.03.34.28;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.12.07.06.16.14;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.12.07.04.14.32;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.12.05.06.17.45;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.10.10.19.10.22;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.05.22.16.03.25;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.05.09.20.00.23;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.05.04.08.28.25;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.05.04.03.47.58;	author butler;	state Exp;
branches;
next	9.9;

9.9
date	90.04.26.02.14.59;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.04.25.21.21.07;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.04.24.01.05.12;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.03.15.02.03.34;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.12.28.16.10.46;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.12.28.14.36.43;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.10.27.21.20.13;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.23.48;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.03;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.06.20.46.06;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.20.39.00;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.03.20.07.20;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.59.43;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.40;	author mike;	state Rel3_0;
branches;
next	7.11;

7.11
date	88.09.17.02.22.11;	author reschly;	state Exp;
branches;
next	7.10;

7.10
date	88.09.06.09.05.54;	author mike;	state Exp;
branches;
next	7.9;

7.9
date	88.08.24.07.41.33;	author reschly;	state Exp;
branches;
next	7.8;

7.8
date	88.08.12.07.48.51;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.08.11.05.22.07;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.05.15.23.04.51;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.02.27.01.07.13;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.02.25.00.23.50;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.01.13.16.37.26;	author stay;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.04.02;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.59;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.02.14;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.18.25;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.06.17.23.44.14;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.06.12.20.05.38;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.05.29.00.44.52;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.05.58;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.19.39;	author mike;	state Rel1;
branches;
next	2.24;

2.24
date	86.11.04.01.40.17;	author mike;	state Exp;
branches;
next	2.23;

2.23
date	86.09.09.23.57.15;	author mike;	state Exp;
branches;
next	2.22;

2.22
date	86.08.12.06.47.24;	author mike;	state Exp;
branches;
next	2.21;

2.21
date	86.06.12.00.11.25;	author mike;	state Exp;
branches;
next	2.20;

2.20
date	86.05.28.01.41.07;	author mike;	state Exp;
branches;
next	2.19;

2.19
date	86.04.09.01.09.35;	author mike;	state Exp;
branches;
next	2.18;

2.18
date	86.03.15.01.06.41;	author mike;	state Exp;
branches;
next	2.17;

2.17
date	86.03.10.21.38.09;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	86.02.17.17.05.21;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	85.09.27.19.18.01;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	85.09.12.00.26.25;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	85.08.29.14.55.21;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	85.08.26.17.09.44;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	85.08.07.05.17.13;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	85.07.30.01.16.35;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.06.19.03.02.20;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.06.06.22.33.05;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.05.08.00.37.55;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.05.02.20.16.43;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.03.29.00.13.46;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.03.28.20.51.05;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.15.05.03.20;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.14.05.04.35;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.54.19;	author mike;	state Prod;
branches;
next	1.14;

1.14
date	85.02.14.01.46.29;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	85.02.14.00.23.42;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	85.02.06.02.30.27;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	85.02.05.04.17.20;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	85.02.05.02.25.57;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.02.01.15.40.31;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.02.01.03.25.48;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.02.01.00.56.53;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.02.01.00.50.13;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.01.17.07.28.14;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.03.40.34;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.01.16.01.56.46;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.17.05.35.38;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.49.09;	author mike;	state Exp;
branches;
next	;

11.222.2.1
date	2000.08.18.13.52.13;	author jra;	state Exp;
branches;
next	11.222.2.2;

11.222.2.2
date	2000.11.15.21.31.20;	author bparker;	state Exp;
branches;
next	11.222.2.3;

11.222.2.3
date	2000.12.15.21.26.09;	author bparker;	state Exp;
branches;
next	11.222.2.4;

11.222.2.4
date	2000.12.21.23.37.19;	author bparker;	state Exp;
branches;
next	11.222.2.5;

11.222.2.5
date	2001.01.03.21.09.14;	author bparker;	state Exp;
branches;
next	11.222.2.6;

11.222.2.6
date	2001.01.04.17.00.28;	author bparker;	state Exp;
branches;
next	11.222.2.7;

11.222.2.7
date	2001.02.21.18.25.18;	author bparker;	state Exp;
branches;
next	;

11.280.2.1
date	2002.09.19.18.02.00;	author morrison;	state Exp;
branches;
next	11.280.2.2;

11.280.2.2
date	2004.03.17.21.21.56;	author morrison;	state Exp;
branches;
next	;

11.280.4.1
date	2002.09.26.23.04.09;	author morrison;	state Exp;
branches;
next	11.280.4.2;

11.280.4.2
date	2004.03.11.23.46.33;	author morrison;	state Exp;
branches;
next	11.280.4.3;

11.280.4.3
date	2004.03.17.04.15.11;	author morrison;	state Exp;
branches;
next	;

11.283.4.1
date	2004.02.12.18.34.13;	author erikg;	state Exp;
branches;
next	11.283.4.2;

11.283.4.2
date	2004.03.15.14.07.36;	author erikg;	state Exp;
branches;
next	11.283.4.3;

11.283.4.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Keyboard command processor
@


11.289
log
@moved to src/mged/
@
text
@/*
 *			C M D . C
 *
 * Functions -
 *	f_press		hook for displays with no buttons
 *	f_summary	do directory summary
 *	mged_cmd		Check arg counts, run a command
 *
 *  Authors -
 *	Michael John Muuss
 *	Charles M. Kennedy
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/cmd.c,v 11.288 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <signal.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#ifndef WIN32
#include <sys/time.h>
#endif
#include <time.h>

#ifdef DM_X
#  include "tk.h"
#else
#  include "tcl.h"
#endif

#include "tclInt.h"
#include "itcl.h"

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./ged.h"
#include "./cmd.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./sedit.h"

#include "./mgedtcl.h"

int bv_zoomin(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_zoomout(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_rate_toggle(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_top(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_bottom(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_right(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_left(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_front(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_rear(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_vrestore(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_vsave(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_adcursor(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_45_45(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_35_25(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_illuminate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_illuminate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_scale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_x(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_y(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_xy(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_rotate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_accept(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_reject(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_edit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_rotate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_trans(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_scale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_xscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_yscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_zscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

void mged_setup(void), cmd_setup(void), mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first);
void mged_print_result(int status);
void mged_global_variable_setup(Tcl_Interp *interp);
int f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv), f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv), f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
extern int f_hide(), f_unhide();


#ifndef HAVE_UNISTD_H
extern void sync();
#endif
extern void update_grids(fastf_t sf);			/* in grid.c */
extern void set_localunit_TclVar(void);		/* in chgmodel.c */
extern void init_qray(void);			/* in qray.c */
extern int gui_setup(char *dstr);				/* in attach.c */
extern int mged_default_dlist;			/* in attach.c */
extern int classic_mged;			/* in ged.c */
extern int bot_vertex_fuse(), bot_condense();
extern int cmd_smooth_bot();
struct cmd_list head_cmd_list;
struct cmd_list *curr_cmd_list;

extern void mged_view_obj_callback(genptr_t clientData, struct view_obj *vop);

extern int db_warn;	/* defined in ged.c */
extern int db_upgrade;	/* defined in ged.c */
extern int db_version;	/* defined in ged.c */

extern struct rt_tess_tol     mged_ttol; /* do_draw.c */
extern struct bn_tol	      mged_tol; /* ged.c */

int glob_compat_mode = 1;
int output_as_return = 1;

int mged_cmd(int argc, char **argv, struct funtab *in_functions);
struct bu_vls tcl_output_hook;

Tcl_Interp *interp = NULL;

#ifdef WIN32
void gettimeofday(struct timeval *tp, struct timezone *tzp);
#endif

#ifdef DM_X
Tk_Window tkwin;
#endif

struct cmdtab {
	char *ct_name;
	int (*ct_func)();
};

#if 1
int f_test_bomb_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
#endif

static struct cmdtab cmdtab[] = {
#if 1
	{"test_bomb_hook", f_test_bomb_hook},
#endif
	{"%", f_comm},
	{"35,25",	bv_35_25},
	{"3ptarb", f_3ptarb},
	{"45,45",	bv_45_45},
	{"accept",	be_accept},
	{"adc", f_adc},
	{"adjust",	cmd_adjust},
	{"ae", cmd_aetview},
	{"aip", f_aip},
	{"analyze", f_analyze},
	{"arb", f_arbdef},
	{"arced", f_arced},
	{"area", f_area},
	{"arot", cmd_arot},
#ifdef DM_X
	{"attach", f_attach},
#endif
	{"attr",	cmd_attr},
	{"autoview", cmd_autoview},
	{"B", cmd_blast},
	{"bev", f_bev},
#if 0
	{"import_body", cmd_import_body},
	{"export_body", cmd_export_body},
#endif
	{"dbbinary", f_binary},
	{"bot_face_fuse", f_bot_face_fuse},
	{"bot_face_sort", cmd_bot_face_sort},
	{"bot_condense", f_bot_condense},
	{"bot_decimate", cmd_bot_decimate},
	{"bot_smooth", cmd_smooth_bot },
	{"bot_vertex_fuse", f_bot_fuse},
	{"bottom",	bv_bottom},
	{"c", cmd_comb_std},
	{"cat", cmd_cat},
	{"center", cmd_center},
	{"closedb", f_closedb},
	{"cmd_win", cmd_cmd_win},
	{"color", cmd_color},
	{"comb", cmd_comb},
	{"comb_color", f_comb_color},
	{"copyeval", cmd_copyeval},
	{"copymat", f_copymat},
	{"cp", cmd_copy},
	{"cpi", f_copy_inv},
	{"d", cmd_erase},
	{"dall", cmd_erase_all},
	{"db_glob", cmd_mged_glob},
	{"dbconcat", cmd_concat},
	{"dbfind", cmd_find},
	{"dbversion", cmd_dbversion},
	{"dbip",	cmd_dbip},
	{"dump",	cmd_dump},
	{"debugbu", f_debugbu},
	{"debugdir", f_debugdir},
	{"debuglib", f_debuglib},
	{"debugmem", f_debugmem},
	{"debugnmg", f_debugnmg},
	{"decompose", f_decompose},
	{"delay", f_delay},
#ifdef DM_X
	{"dm", f_dm},
#endif
	{"draw", cmd_draw},
	{"dup", cmd_dup},
#ifdef DM_X
	{"E", cmd_E},
#endif
	{"e", cmd_draw},
	{"eac", f_eac},
	{"echo", cmd_echo},
	{"edcodes", f_edcodes},
	{"edcolor", f_edcolor},
	{"edcomb", f_edcomb},
	{"edgedir", f_edgedir},
	{"edmater", f_edmater},
	{"em", cmd_emuves},
	{"erase", cmd_erase},
	{"erase_all", cmd_erase_all},
#ifdef DM_X
	{"ev", cmd_ev},
#endif
	{"eqn", f_eqn},
	{"exit", f_quit},
	{"extrude", f_extrude},
	{"expand", cmd_expand},
	{"eye_pt", cmd_eye_pt},
	{"e_muves", f_e_muves},
	{"facedef", f_facedef},
	{"facetize", f_facetize},
	{"form",	cmd_form},
	{"fracture", f_fracture},
	{"front",	bv_front},
	{"g", cmd_group},
	{"get",		cmd_get},
	{"get_autoview", cmd_get_autoview},
	{"get_comb", cmd_get_comb},
	{"get_dbip", cmd_get_ptr},
	{"get_dm_list", f_get_dm_list},
	{"get_more_default", cmd_get_more_default},
	{"get_sed", f_get_sedit},
	{"get_sed_menus", f_get_sedit_menus},
	{"get_solid_keypoint", f_get_solid_keypoint},
	{"grid2model_lu", f_grid2model_lu},
	{"grid2view_lu", f_grid2view_lu},
#ifdef HIDELINE
	{"H", f_hideline},
#endif
	{"hide", cmd_hide },
	{"history", f_history},
	{"hist", cmd_hist},
	{"i", cmd_instance},
	{"idents", f_tables},
	{"ill", f_ill},
	{"in", f_in},
	{"inside", f_inside},
	{"item", f_itemair},
	{"joint", f_joint},
	{"journal", f_journal},
	{"keep", cmd_keep},
	{"keypoint", f_keypoint},
	{"kill", cmd_kill},
	{"killall", cmd_killall},
	{"killtree", cmd_killtree},
	{"knob", f_knob},
	{"l", cmd_list},
	{"lt", cmd_lt},
	{"l_muves", f_l_muves},
	{"labelvert", f_labelvert},
	{"left",		bv_left},
	{"lm", cmd_lm},
#ifdef DM_X
	{"loadtk", cmd_tk},
#endif
	{"loadview", f_loadview},
	{"lookat", cmd_lookat},
	{"ls", cmd_ls},
	{"M", f_mouse},
	{"make", f_make},
	{"make_bb", cmd_make_bb},
	{"make_name", cmd_make_name},
	{"match",	cmd_match},
	{"mater", f_mater},
	{"matpick", f_matpick},
	{"memprint", f_memprint},
	{"listeval", cmd_pathsum},
#ifdef DM_X
	{"mged_update", f_update},
	{"mged_wait", f_wait},
#endif
	{"mirface", f_mirface},
	{"mirror", f_mirror},
#ifdef DM_X
	{"mmenu_get", cmd_mmenu_get},
	{"mmenu_set", cmd_nop},
#endif
	{"model2grid_lu", f_model2grid_lu},
	{"model2view", f_model2view},
	{"model2view_lu", f_model2view_lu},
	{"mrot", cmd_mrot},
	{"mv", cmd_name},
	{"mvall", cmd_mvall},
	{"nirt", f_nirt},
	{"nmg_collapse", cmd_nmg_collapse},
	{"nmg_simplify", cmd_nmg_simplify},
	{"o_rotate",		be_o_rotate},
	{"o_scale",	be_o_scale},
	{"oed", cmd_oed},
	{"oed_apply", f_oedit_apply},
	{"oed_reset", f_oedit_reset},
#ifdef DM_X
	{"oill",		be_o_illuminate},
#endif
	{"opendb", f_opendb},
	{"orientation", cmd_orientation},
	{"orot", f_rot_obj},
	{"oscale", f_sc_obj},
	{"output_hook", cmd_output_hook},
	{"overlay", cmd_overlay},
	{"ox",		be_o_x},
	{"oxy",		be_o_xy},
	{"oxscale",	be_o_xscale},
	{"oy",		be_o_y},
	{"oyscale",	be_o_yscale},
	{"ozscale",	be_o_zscale},
	{"p", f_param},
	{"pathlist", cmd_pathlist},
	{"paths", cmd_pathsum},
	{"permute", f_permute},
	{"plot", f_plot},
	{"pl", f_pl},
	{"polybinout", f_polybinout},
#ifdef TCP_FILES
	{"pov", cmd_pov},
#endif
	{"prcolor", cmd_prcolor},
	{"prefix", f_prefix},
	{"press", f_press},
	{"preview", f_preview},
	{"ps", f_ps},
	{"push", cmd_push},
	{"put",		cmd_put},
	{"put_comb", cmd_put_comb},
	{"put_sed", f_put_sedit},
	{"putmat", f_putmat},
	{"q", f_quit},
	{"qray", f_qray},
	{"query_ray", f_nirt},
	{"quit", f_quit},
	{"qorot", f_qorot},
	{"qvrot", f_qvrot},
	{"r", cmd_region},
	{"rate",		bv_rate_toggle},
	{"rcodes", f_rcodes},
	{"read_muves", f_read_muves},
	{"rear",	bv_rear},
	{"red", f_red},
	{"redraw_vlist", cmd_redraw_vlist},
#ifdef DM_X
	{"refresh", f_refresh},
#endif
	{"regdebug", f_regdebug},
	{"regdef", f_regdef},
	{"regions", f_tables},
	{"reject",	be_reject},
	{"release", f_release},
	{"solid_report", cmd_solid_report},
	{"reset",	bv_reset},
	{"restore",	bv_vrestore},
	{"right",	bv_right},
	{"rfarb", f_rfarb},
	{"rm", cmd_remove},
	{"rmater", f_rmater},
	{"rmats", f_rmats},
	{"rot", cmd_rot},
	{"rotobj", f_rot_obj},
	{"rrt", f_rrt},
	{"rset", f_rset},
	{"rt", cmd_rt},
	{"rtabort", cmd_rtabort},
	{"rtcheck", cmd_rtcheck},
	{"rtedge", cmd_rt},
	{"rt_gettrees", cmd_rt_gettrees},
	{"save",		bv_vsave},
#if 0
	{"savedit", f_savedit},
#endif
	{"savekey", f_savekey},
	{"saveview", f_saveview},
	{"sca", cmd_sca},
	{"sed", f_sed},
	{"sedit",	be_s_edit},
	{"sed_apply", f_sedit_apply},
	{"sed_reset", f_sedit_reset},
	{"set_more_default", cmd_set_more_default},
	{"setview", cmd_setview},
	{"shader", f_shader},
	{"share", f_share},
	{"shaded_mode", cmd_shaded_mode},
	{"shells", cmd_shells},
	{"showmats", cmd_showmats},
	{"sill",		be_s_illuminate},
	{"size", cmd_size},
	{"solid_report", cmd_solid_report},
	{"solids", f_tables},
	{"solids_on_ray", cmd_solids_on_ray},
	{"srot",		be_s_rotate},
	{"sscale",	be_s_scale},
	{"status", f_status},
	{"stuff_str", cmd_stuff_str},
	{"summary", cmd_summary},
	{"sv", f_slewview},
	{"svb", f_svbase},
	{"sync", f_sync},
	{"sxy",		be_s_trans},
	{"t", cmd_ls},
	{"ted", f_tedit},
	{"tie", f_tie},
	{"title", cmd_title},
	{"tol", cmd_tol},
	{"top",		bv_top},
	{"tops", cmd_tops},
	{"tra", cmd_tra},
	{"track", f_amtrack},
	{"translate", f_tr_obj},
	{"tree", cmd_tree},
	{"t_muves", f_t_muves},
	{"unhide", cmd_unhide},
	{"units", cmd_units},
	{"vars", f_set},
	{"vdraw", cmd_vdraw},
	{"view", f_view},
	{"view_ring", f_view_ring},
#if 0
	{"viewget", cmd_viewget},
	{"viewset", cmd_viewset},
#endif
	{"viewsize", cmd_size},		/* alias "size" for saveview scripts */
	{"view2grid_lu", f_view2grid_lu},
	{"view2model", f_view2model},
	{"view2model_vec", f_view2model_vec},
	{"view2model_lu", f_view2model_lu},
	{"vnirt", f_vnirt},
	{"vquery_ray", f_vnirt},
#if 0
	{"vrmgr", f_vrmgr},
#endif
	{"vrot", cmd_vrot},
#if 0
	{"vrot_center", f_vrot_center},
#endif
	{"wcodes", f_wcodes},
	{"whatid", cmd_whatid},
	{"whichair", cmd_which},
	{"whichid", cmd_which},
	{"which_shader", f_which_shader},
	{"who", cmd_who},
	{"winset", f_winset},
	{"wmater", f_wmater},
	{"x", cmd_solid_report},
	{"xpush", cmd_xpush},
	{"Z", cmd_zap},
	{"zoom", cmd_zoom},
	{"zoomin",	bv_zoomin},
	{"zoomout",	bv_zoomout},
	{0, 0}
};


/*
 *                        O U T P U T _ C A T C H
 *
 * Gets the output from bu_log and appends it to clientdata vls.
 */

HIDDEN int
output_catch(genptr_t clientdata, genptr_t str)
{
	register struct bu_vls *vp = (struct bu_vls *)clientdata;
	register int len;

	BU_CK_VLS(vp);
	len = bu_vls_strlen(vp);
	bu_vls_strcat(vp, str);
	len = bu_vls_strlen(vp) - len;

	return len;
}

/*
 *                 S T A R T _ C A T C H I N G _ O U T P U T
 *
 * Sets up hooks to bu_log so that all output is caught in the given vls.
 *
 */

void
start_catching_output(struct bu_vls *vp)
{
	bu_log_add_hook(output_catch, (genptr_t)vp);
}

/*
 *                 S T O P _ C A T C H I N G _ O U T P U T
 *
 * Turns off the output catch hook.
 */

void
stop_catching_output(struct bu_vls *vp)
{
	bu_log_delete_hook(output_catch, (genptr_t)vp);
}

/*
 *                            G U I _ O U T P U T
 *
 * Used as a hook for bu_log output.  Sends output to the Tcl procedure whose
 * name is contained in the vls "tcl_output_hook".  Useful for user interface
 * building.
 */

int
gui_output(genptr_t clientData, genptr_t str)
{
	Tcl_DString tclcommand;
	Tcl_Obj *save_result;
	static int level = 0;

	if (level > 50) {
		bu_log_delete_hook(gui_output, clientData);
		/* Now safe to run bu_log? */
		bu_log("Ack! Something horrible just happened recursively.\n");
		return 0;
	}

	Tcl_DStringInit(&tclcommand);
	(void)Tcl_DStringAppendElement(&tclcommand, bu_vls_addr(&tcl_output_hook));
	(void)Tcl_DStringAppendElement(&tclcommand, str);

	save_result = Tcl_GetObjResult(interp);
	Tcl_IncrRefCount(save_result);
	++level;
	Tcl_Eval((Tcl_Interp *)clientData, Tcl_DStringValue(&tclcommand));
	--level;
	Tcl_SetObjResult(interp, save_result);
	Tcl_DecrRefCount(save_result);

	Tcl_DStringFree(&tclcommand);
	return strlen(str);
}

/*
 *                     C M D _ T K
 *
 *  Command for initializing the Tk window and defaults.
 *
 *  Usage:  loadtk [displayname[.screennum]]
 */
int
cmd_tk(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int status;

	if(argc < 1 || 2 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help loadtk");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(argc == 1)
		status = gui_setup((char *)NULL);
	else
		status = gui_setup(argv[1]);

	return status;
}

/*
 *   C M D _ O U T P U T _ H O O K
 *
 *   Hooks the output to the given output hook.
 *   Removes the existing output hook!
 */

int
cmd_output_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls infocommand;
	int status;

	if(argc < 1 || 2 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel output_hook");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_log_delete_hook(gui_output, (genptr_t)interp);/* Delete the existing hook */

	if (argc < 2)
		return TCL_OK;

	/* Make sure the command exists before putting in the hook! */
	/* Note - the parameters to proc could be wrong and/or the proc could still disappear later */
	bu_vls_init(&infocommand);
	bu_vls_strcat(&infocommand, "info commands ");
	bu_vls_strcat(&infocommand, argv[1]);
	status = Tcl_Eval(interp, bu_vls_addr(&infocommand));
	bu_vls_free(&infocommand);

	if (status != TCL_OK || interp->result[0] == '\0') {
		Tcl_AppendResult(interp, "command does not exist", (char *)NULL);
		return TCL_ERROR;
	}

	/* Also, don't allow silly infinite loops. */

	if (strcmp(argv[1], argv[0]) == 0) {
		Tcl_AppendResult(interp, "Don't be silly.", (char *)NULL);
		return TCL_ERROR;
	}

	/* Set up the hook! */

	bu_vls_strcpy(&tcl_output_hook, argv[1]);
	bu_log_add_hook(gui_output, (genptr_t)interp);
    
	Tcl_ResetResult(interp);
	return TCL_OK;
}


/*
 *			C M D _ N O P
 */
int
cmd_nop(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	return TCL_OK;
}


/*
 *			C M D _ G E T _ P T R
 *
 *  Returns an appropriately-formatted string that can later be reinterpreted
 *  (using atol() and a cast) as a a pointer.
 */

int
cmd_get_ptr(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	char buf[128];

	sprintf( buf, "%ld", (long)(*((void **)&dbip)) );
	Tcl_AppendResult( interp, buf, (char *)NULL );
	return TCL_OK;
}

/*
 *
 * Sets up the Tcl interpreter
 */ 
void
mged_setup(void)
{
	struct bu_vls str;
	char *filename;
	
	/* The following is for GUI output hooks: contains name of function to
	   run with output */
	bu_vls_init(&tcl_output_hook);

	/* Locate the BRL-CAD-specific Tcl scripts */
	filename = bu_brlcad_path( "" );
#ifdef WIN32
	{
	  /* XXX - nasty little hack to convert paths */
	  int i;
	  strcat(filename,"/");
	  for (i=0;i<strlen(filename);i++) {
	    if(filename[i]=='\\') 
	      filename[i]='/'; }
	}
#endif

	/* Create the interpreter */
	interp = Tcl_CreateInterp();

	/* This runs the init.tcl script */
	if( Tcl_Init(interp) == TCL_ERROR )
		bu_log("Tcl_Init error %s\n", interp->result);

	/* Initialize [incr Tcl] */
	if (Itcl_Init(interp) == TCL_ERROR)
	  bu_log("Itcl_Init error %s\n", interp->result);

	/* Import [incr Tcl] commands into the global namespace. */
	if (Tcl_Import(interp, Tcl_GetGlobalNamespace(interp),
		       "::itcl::*", /* allowOverwrite */ 1) != TCL_OK)
	  bu_log("Tcl_Import error %s\n", interp->result);

	/* Initialize libbu */
	Bu_Init(interp);

	/* Initialize libbn */
	Bn_Init(interp);

	/* Initialize librt (includes database, drawable geometry and view objects) */
	if (Rt_Init(interp) == TCL_ERROR) {
		bu_log("Rt_Init error %s\n", interp->result);
	}

	/* initialize MGED's drawable geometry object */
	dgop = dgo_open_cmd("mged", wdbp);

	view_state->vs_vop = vo_open_cmd("");
	view_state->vs_vop->vo_callback = mged_view_obj_callback;
	view_state->vs_vop->vo_clientData = view_state;
	view_state->vs_vop->vo_scale = 500;
	view_state->vs_vop->vo_size = 2.0 * view_state->vs_vop->vo_scale;
	view_state->vs_vop->vo_invSize = 1.0 / view_state->vs_vop->vo_size;
	MAT_DELTAS_GET_NEG(view_state->vs_orig_pos, view_state->vs_vop->vo_center);

	/* register commands */
	cmd_setup();

	history_setup();
	mged_global_variable_setup(interp);
#if !TRY_NEW_MGED_VARS
	mged_variable_setup(interp);
#endif

	bu_vls_init(&str);
	bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 %stclscripts/mged %stclscripts %stclscripts/lib %stclscripts/util %stclscripts/geometree]", filename, filename, filename, filename, filename);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));

	/* Tcl needs to write nulls onto subscripted variable names */
	bu_vls_trunc( &str, 0 );
	bu_vls_printf( &str, "%s(state)", MGED_DISPLAY_VAR );
	Tcl_SetVar(interp, bu_vls_addr(&str), state_str[state],
		   TCL_GLOBAL_ONLY);

	/* initialize "Query Ray" variables */
	init_qray();

	Tcl_ResetResult(interp);

	bu_vls_free(&str);
}

/* 			C M D _ S E T U P
 * Register all the MGED commands.
 */
void
cmd_setup(void)
{
	register struct cmdtab *ctp;
	struct bu_vls temp;

	bu_vls_init(&temp);
	for (ctp = cmdtab; ctp->ct_name != NULL; ctp++) {
#if 0
		bu_vls_strcpy(&temp, "info commands ");
		bu_vls_strcat(&temp, ctp->ct_name);
		if (Tcl_Eval(interp, bu_vls_addr(&temp)) != TCL_OK ||
		    interp->result[0] != '\0') {
			bu_log("WARNING:  '%s' name collision (%s)\n", ctp->ct_name,
			       interp->result);
		}
#endif
		bu_vls_strcpy(&temp, "_mged_");
		bu_vls_strcat(&temp, ctp->ct_name);
	
		(void)Tcl_CreateCommand(interp, ctp->ct_name, ctp->ct_func,
					(ClientData)ctp, (Tcl_CmdDeleteProc *)NULL);
		(void)Tcl_CreateCommand(interp, bu_vls_addr(&temp), ctp->ct_func,
					(ClientData)ctp, (Tcl_CmdDeleteProc *)NULL);
	}

	/* overrides/wraps the built-in tree command */
	{
		struct bu_vls	vls;
		char		*pathname;

		/* Locate the BRL-CAD-specific Tcl scripts */
		pathname = bu_brlcad_path("");

#ifdef WIN32
	{
		/* XXXXXXXXXXXXXXX UGLY XXXXXXXXXXXXXXXXXX*/
	int i;
	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
		if(pathname[i]=='\\') 
			pathname[i]='/'; }
	}
#endif

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "source %stclscripts/mged/tree.tcl", pathname);
		(void)Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
	}

	bu_vls_strcpy(&temp, "glob_compat_mode");
	Tcl_LinkVar(interp, bu_vls_addr(&temp), (char *)&glob_compat_mode,
		    TCL_LINK_BOOLEAN);
	bu_vls_strcpy(&temp, "output_as_return");
	Tcl_LinkVar(interp, bu_vls_addr(&temp), (char *)&output_as_return,
		    TCL_LINK_BOOLEAN);

	/* Provide Tcl interfaces to the fundamental BRL-CAD libraries */
	Bu_Init(interp);
	bn_tcl_setup( interp );
	Rt_Init(interp);

#ifdef DM_X
	tkwin = NULL;
#endif

	bu_vls_free(&temp);
}

int
cmd_cmd_win(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if(argc < 2){
		bu_vls_printf(&vls, "helpdevel cmd_win");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(strcmp(argv[1], "open") == 0){
		struct cmd_list *clp;
		int name_not_used = 1;

		if(argc != 3){
			bu_vls_printf(&vls, "helpdevel cmd_win");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* Search to see if there exists a command window with this name */
		for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
			if(!strcmp(argv[2], bu_vls_addr(&clp->cl_name))){
				name_not_used = 0;
				break;
			}

		if(name_not_used){
			clp = (struct cmd_list *)bu_malloc(sizeof(struct cmd_list), "cmd_list");
			bzero((void *)clp, sizeof(struct cmd_list));
			BU_LIST_APPEND(&head_cmd_list.l, &clp->l);
			clp->cl_cur_hist = head_cmd_list.cl_cur_hist;
			bu_vls_init(&clp->cl_more_default);
			bu_vls_init(&clp->cl_name);
			bu_vls_strcpy(&clp->cl_name, argv[2]);
		}

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(strcmp(argv[1], "close") == 0){
		struct cmd_list *clp;

		if(argc != 3){
			bu_vls_printf(&vls, "helpdevel cmd_win");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* First, search to see if there exists a command window with the name
		   in argv[2] */
		for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
			if(!strcmp(argv[2], bu_vls_addr(&clp->cl_name)))
				break;

		if(clp == &head_cmd_list){
			if(!strcmp(argv[2], "mged"))
				Tcl_AppendResult(interp, "cmd_close: not allowed to close \"mged\"",
								(char *)NULL);
			else
				Tcl_AppendResult(interp, "cmd_close: did not find \"", argv[2],
							"\"", (char *)NULL);
			return TCL_ERROR;
		}

		if(clp == curr_cmd_list)
			curr_cmd_list = &head_cmd_list;

		BU_LIST_DEQUEUE( &clp->l );
		if(clp->cl_tie != NULL)
			clp->cl_tie->dml_tie = CMD_LIST_NULL;
		bu_vls_free(&clp->cl_more_default);
		bu_vls_free(&clp->cl_name);
		bu_free((genptr_t)clp, "cmd_close: clp");

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(strcmp(argv[1], "get") == 0){
		if(argc != 2){
			bu_vls_printf(&vls, "helpdevel cmd_win");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_name));

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(strcmp(argv[1], "set") == 0){
		if(argc != 3){
			bu_vls_printf(&vls, "helpdevel cmd_win");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		for( BU_LIST_FOR(curr_cmd_list, cmd_list, &head_cmd_list.l) ){
			if(strcmp(bu_vls_addr(&curr_cmd_list->cl_name), argv[2]))
				continue;

			break;
		}

		if(curr_cmd_list->cl_tie)
			curr_dm_list = curr_cmd_list->cl_tie;

		bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	bu_vls_printf(&vls, "helpdevel cmd_win");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

#if 0
cmd_get(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
{
	struct dm_list *p;
	struct cmd_list *save_clp;
	struct bu_vls vls;
	int first = 1;

	if(argc != 1){
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel cmd_get");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	save_clp = curr_cmd_list;
	bu_vls_init(&vls);

	if(!curr_cmd_list->cl_tie){
		if(curr_dm_list->dml_tie){
			Tcl_AppendElement(interp, bu_vls_addr(&curr_dm_list->dml_tie->cl_name));
			curr_cmd_list = curr_dm_list->dml_tie;
			Tcl_AppendElement(interp, bu_vls_addr(&pathName));
		}else{
			Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_name));
			Tcl_AppendElement(interp, bu_vls_addr(&pathName));
			Tcl_AppendElement(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_OK;
		}
	}else{
		Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_name));
		Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_tie->dml_dmp->dm_pathName));
	}

	/* return all ids associated with the current command window */
	FOR_ALL_DISPLAYS(p, &head_dm_list.l){
		/* The display manager tied to the current command window shares
		   information with display manager p */
		if(curr_cmd_list->cl_tie->dml_view_state == p->dml_view_state)
			/* This display manager is tied to a command window */
			if(p->dml_tie)
				if(first){
					bu_vls_printf(&vls, "%S", &p->dml_tie->cl_name);
					first = 0;
				} else
					bu_vls_printf(&vls, " %S", &p->dml_tie->cl_name);
	}

	Tcl_AppendElement(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	curr_cmd_list = save_clp;
	return TCL_OK;
}
#endif

int
cmd_get_more_default(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	if(argc != 1){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel get_more_default");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	Tcl_AppendResult(interp, bu_vls_addr(&curr_cmd_list->cl_more_default), (char *)NULL);
	return TCL_OK;
}

int
cmd_set_more_default(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	if(argc != 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel set_more_default");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_strcpy(&curr_cmd_list->cl_more_default, argv[1]);
	return TCL_OK;
}


int
cmd_mged_glob(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls dest, src;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help db_glob");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&src);
	bu_vls_init(&dest);
	bu_vls_strcpy(&src, argv[1]);
	mged_compat(&dest, &src, 0);
	Tcl_AppendResult(interp, bu_vls_addr(&dest), (char *)NULL);
	bu_vls_free(&src);
	bu_vls_free(&dest);

	return TCL_OK;
}


/*
 * debackslash, backslash_specials, mged_compat: routines for original
 *   mged emulation mode
 */

void
debackslash(struct bu_vls *dest, struct bu_vls *src)
{
	char *ptr;

	ptr = bu_vls_addr(src);
	while( *ptr ) {
		if( *ptr == '\\' )
			++ptr;
		if( *ptr == '\0' )
			break;
		bu_vls_putc( dest, *ptr++ );
	}
}

void
backslash_specials(struct bu_vls *dest, struct bu_vls *src)
{
	int backslashed;
	char *ptr, buf[2];

	buf[1] = '\0';
	backslashed = 0;
	for( ptr = bu_vls_addr( src ); *ptr; ptr++ ) {
		if( *ptr == '[' && !backslashed )
			bu_vls_strcat( dest, "\\[" );
		else if( *ptr == ']' && !backslashed )
			bu_vls_strcat( dest, "\\]" );
		else if( backslashed ) {
			bu_vls_strcat( dest, "\\" );
			buf[0] = *ptr;
			bu_vls_strcat( dest, buf );
			backslashed = 0;
		} else if( *ptr == '\\' )
			backslashed = 1;
		else {
			buf[0] = *ptr;
			bu_vls_strcat( dest, buf );
		}
	}
}

/*                    M G E D _ C O M P A T
 *
 * This routine is called to perform wildcard expansion and character quoting
 * on the given vls (typically input from the keyboard.)
 */

void
mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first)
{
	char *start, *end;          /* Start and ends of words */
	int regexp;                 /* Set to TRUE when word is a regexp */
	int backslashed;
	int firstword;
	struct bu_vls word;         /* Current word being processed */
	struct bu_vls temp;

	if(dbip == DBI_NULL){
	  bu_vls_vlscat(dest, src);
	  return;
	}

	bu_vls_init( &word );
	bu_vls_init( &temp );
    
	start = end = bu_vls_addr( src );
	firstword = 1;
	while( *end != '\0' ) {            /* Run through entire string */

		/* First, pass along leading whitespace. */

		start = end;                   /* Begin where last word ended */
		while( *start != '\0' ) {
			if( *start == ' '  ||
			    *start == '\t' ||
			    *start == '\n' )
				bu_vls_putc( dest, *start++ );
			else
				break;
		}
		if( *start == '\0' )
			break;

		/* Next, advance "end" pointer to the end of the word, while adding
		   each character to the "word" vls.  Also make a note of any
		   unbackslashed wildcard characters. */

		end = start;
		bu_vls_trunc( &word, 0 );
		regexp = 0;
		backslashed = 0;
		while( *end != '\0' ) {
			if( *end == ' '  ||
			    *end == '\t' ||
			    *end == '\n' )
				break;
			if( (*end == '*' || *end == '?' || *end == '[') && !backslashed )
				regexp = 1;
			if( *end == '\\' && !backslashed )
				backslashed = 1;
			else
				backslashed = 0;
			bu_vls_putc( &word, *end++ );
		}

		if( firstword && !use_first )
			regexp = 0;

		/* Now, if the word was suspected of being a wildcard, try to match
		   it to the database. */

		if( regexp ) {
			bu_vls_trunc( &temp, 0 );
			if( db_regexp_match_all( &temp, dbip,
						 bu_vls_addr(&word) ) == 0 ) {
				debackslash( &temp, &word );
				backslash_specials( dest, &temp );
			} else
				bu_vls_vlscat( dest, &temp );
		} else {
			debackslash( dest, &word );
		}

		firstword = 0;
	}

	bu_vls_free( &temp );
	bu_vls_free( &word );
}
    
/*
 *			C M D L I N E
 *
 *  This routine is called to process a vls full of commands.
 *  Each command is newline terminated.
 *  The input string will not be altered in any way.
 *
 *  Returns -
 *	!0	when a prompt needs to be printed.
 *	 0	no prompt needed.
 */

int
cmdline( struct bu_vls *vp, int record )
{
	int	status;
	struct bu_vls globbed;
	struct bu_vls tmp_vls;
	struct bu_vls save_vp;
	struct timeval start, finish;
	size_t len;
	extern struct bu_vls mged_prompt;
	char *cp;

	BU_CK_VLS(vp);

	if (bu_vls_strlen(vp) <= 0)
		return CMD_OK;
		
	bu_vls_init(&globbed);
	bu_vls_init(&tmp_vls);
	bu_vls_init(&save_vp);
	bu_vls_vlscat(&save_vp, vp);

	/* MUST MAKE A BACKUP OF THE INPUT STRING AND USE THAT IN THE CALL TO
	   Tcl_Eval!!!
       
	   You never know who might change the string (append to it...)
	   (f_mouse is notorious for adding things to the input string)
	   If it were to change while it was still being evaluated, Horrible Things
	   could happen.
	*/

	if (glob_compat_mode)
		mged_compat(&globbed, vp, 0);
	else
		bu_vls_vlscat(&globbed, vp);

	gettimeofday(&start, (struct timezone *)NULL);
	status = Tcl_Eval(interp, bu_vls_addr(&globbed));
	gettimeofday(&finish, (struct timezone *)NULL);

	/* Contemplate the result reported by the Tcl interpreter. */

	switch (status) {
	case TCL_RETURN:
	case TCL_OK:
		if( setjmp( jmp_env ) == 0 ){
			len = strlen(interp->result);

			/* If the command had something to say, print it out. */	     
			if (len > 0){
				(void)signal( SIGINT, sig3);  /* allow interupts */

				bu_log("%s%s", interp->result,
				       interp->result[len-1] == '\n' ? "" : "\n");

				(void)signal( SIGINT, SIG_IGN );
			}


#ifdef DM_X
			/* A user typed this command so let everybody see, then record
			   it in the history. */
			if (record && tkwin != NULL) {
				bu_vls_printf(&tmp_vls, "distribute_text {} {%s} {%s}",
					      bu_vls_addr(&save_vp), interp->result);
				Tcl_Eval(interp, bu_vls_addr(&tmp_vls));
				Tcl_SetResult(interp, "", TCL_STATIC);
			}
#endif

			if(record)
				history_record(&save_vp, &start, &finish, CMD_OK);

		}else{
/* XXXXXX */
			bu_semaphore_release(BU_SEM_SYSCALL);
			bu_log("\n");
		}
      
		bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
		status = CMD_OK;
		goto end;

	case TCL_ERROR:
	default:

		/* First check to see if it's a secret message. */

		if ((cp = strstr(interp->result, MORE_ARGS_STR)) != NULL) {
			if(cp == interp->result){
				bu_vls_trunc(&mged_prompt, 0);
				bu_vls_printf(&mged_prompt, "\r%s",
					      interp->result+sizeof(MORE_ARGS_STR)-1);
			}else{
				len = cp - interp->result;
				bu_log("%*s%s", len, interp->result, interp->result[len-1] == '\n' ? "" : "\n");
				bu_vls_trunc(&mged_prompt, 0);
				bu_vls_printf(&mged_prompt, "\r%s",
					      interp->result+sizeof(MORE_ARGS_STR)-1+len);
			}

			status = CMD_MORE;
			goto end;
		}

		/* Otherwise, it's just a regular old error. */    

		len = strlen(interp->result);
		if (len > 0) bu_log("%s%s", interp->result,
				    interp->result[len-1] == '\n' ? "" : "\n");

		if (record)
			history_record(&save_vp, &start, &finish, CMD_BAD);

		bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
		status = CMD_BAD;

		/* Fall through to end */
	}

 end:
	bu_vls_free(&globbed);
	bu_vls_free(&tmp_vls);
	bu_vls_free(&save_vp);

	return status;
}


void
mged_print_result(int status)
{
	int len;
	extern void pr_prompt(void);

#if 0
	switch (status) {
	case TCL_OK:
		len = strlen(interp->result);

		/* If the command had something to say, print it out. */	     
		if (len > 0){
			bu_log("%s%s", interp->result,
			       interp->result[len-1] == '\n' ? "" : "\n");

			pr_prompt();
		}

		break;

	case TCL_ERROR:
	default:
		len = strlen(interp->result);
		if (len > 0){
			bu_log("%s%s", interp->result,
			       interp->result[len-1] == '\n' ? "" : "\n");

			pr_prompt();
		}

		break;
	}
#else
	len = strlen(interp->result);
	if (len > 0){
		bu_log("%s%s", interp->result,
		       interp->result[len-1] == '\n' ? "" : "\n");

		pr_prompt();
	}
#endif

	Tcl_ResetResult(interp);
}

/*
 *			M G E D _ C M D
 *
 *  Check a table for the command, check for the correct minimum and maximum
 *  number of arguments, and pass control to the proper function.  If the
 *  number of arguments is incorrect, print out a short help message.
 */

int
mged_cmd(
	int argc,
	char **argv,
	struct funtab in_functions[])
{
	register struct funtab *ftp;
	struct funtab *functions;

	if (argc == 0)
		return CMD_OK;	/* No command entered, that's fine */

	/* if no function table is provided, use the default mged function table */
	if( in_functions == (struct funtab *)NULL )
	{
		bu_log("mged_cmd: failed to supply function table!\n");
		return CMD_BAD;
	}
	else
		functions = in_functions;

	for (ftp = &functions[1]; ftp->ft_name; ftp++) {
		if (strcmp(ftp->ft_name, argv[0]) != 0)
			continue;
		/* We have a match */
		if ((ftp->ft_min <= argc) && (argc <= ftp->ft_max)) {
			/* Input has the right number of args.
			 * Call function listed in table, with
			 * main(argc, argv) style args
			 */

			switch (ftp->ft_func(argc, argv)) {
			case CMD_OK:
				return CMD_OK;
			case CMD_BAD:
				return CMD_BAD;
			case CMD_MORE:
				return CMD_MORE;
			default:
				Tcl_AppendResult(interp, "mged_cmd(): Invalid return from ",
						 ftp->ft_name, "\n", (char *)NULL);
				return CMD_BAD;
			}
		}

		Tcl_AppendResult(interp, "Usage: ", functions[0].ft_name, ftp->ft_name,
				 " ", ftp->ft_parms, "\n\t(", ftp->ft_comment,
				 ")\n", (char *)NULL);
		return CMD_BAD;
	}

	Tcl_AppendResult(interp, functions[0].ft_name, argv[0],
			 ": no such command, type '", functions[0].ft_name,
			 "?' for help\n", (char *)NULL);
	return CMD_BAD;
}

/* Let the user temporarily escape from the editor */
/* Format: %	*/

int
f_comm(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{

#ifndef WIN32

	register int pid, rpid;
	int retcode;

	if(argc != 1 || !classic_mged || curr_cmd_list != &head_cmd_list){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	(void)signal( SIGINT, SIG_IGN );
	if ( ( pid = fork()) == 0 )  {
		(void)signal( SIGINT, SIG_DFL );
		(void)execl("/bin/sh","-",(char *)NULL);
		perror("/bin/sh");
		mged_finish( 11 );
	}

	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;

	Tcl_AppendResult(interp, "!\n", (char *)NULL);
#endif

	return TCL_OK;
}

/* Quit and exit gracefully */
/* Format: q	*/

int
f_quit(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	if(argc < 1 || 1 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if( state != ST_VIEW )
		button( BE_REJECT );

	quit();			/* Exiting time */
	/* NOTREACHED */
	return TCL_OK;
}

/* wrapper for sync() */

int
f_sync(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{

	if(argc < 1 || 1 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help sync");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
// XXXXXXXXXXXXXXX FIX LATER XXXXXXXXXXXXXXXXXx
#ifndef WIN32
	sync();
#endif
    
	return TCL_OK;
}

/*
 *			H E L P C O M M
 *
 *  Common code for help commands
 */

static int
helpcomm(int argc, char **argv, struct funtab *functions)
{
	register struct funtab *ftp;
	register int	i, bad;

	bad = 0;
	
	/* Help command(s) */
	for( i=1; i<argc; i++ )  {
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			if( strcmp( ftp->ft_name, argv[i] ) != 0 )
				continue;

			Tcl_AppendResult(interp, "Usage: ", functions->ft_name, ftp->ft_name,
					 " ", ftp->ft_parms, "\n\t(", ftp->ft_comment, ")\n", (char *)NULL);
			break;
		}
		if( !ftp->ft_name ) {
			Tcl_AppendResult(interp, functions->ft_name, argv[i],
					 ": no such command, type '", functions->ft_name,
					 "?' for help\n", (char *)NULL);
			bad = 1;
		}
	}

	return bad ? TCL_ERROR : TCL_OK;
}

/*
 *			F _ H E L P
 *
 *  Print a help message, two lines for each command.
 *  Or, help with the indicated commands.
 */

int
f_help2(int argc, char **argv, struct funtab *functions)
{
	register struct funtab *ftp;

	if( argc <= 1 )  {
		Tcl_AppendResult(interp, "The following commands are available:\n", (char *)NULL);
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			Tcl_AppendResult(interp,  functions->ft_name, ftp->ft_name, " ",
					 ftp->ft_parms, "\n\t(", ftp->ft_comment, ")\n", (char *)NULL);
		}
		return TCL_OK;
	}
	return helpcomm( argc, argv, functions );
}

int
f_fhelp2(int argc, char **argv, struct funtab *functions)
{
	register struct funtab *ftp;
	struct bu_vls		str;

	if( argc <= 1 )  {
		bu_vls_init(&str);
		Tcl_AppendResult(interp, "The following ", functions->ft_name,
				 " commands are available:\n", (char *)NULL);
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			vls_col_item( &str, ftp->ft_name);
		}
		vls_col_eol( &str );
		Tcl_AppendResult(interp, bu_vls_addr( &str ), (char *)NULL);
		bu_vls_free(&str);
		return TCL_OK;
	}
	return helpcomm( argc, argv, functions );
}

int
cmd_summary(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_summary_cmd(wdbp, interp, argc, argv);
}

/*
 *                          C M D _ E C H O
 *
 * Concatenates its arguments and "bu_log"s the resulting string.
 */

int
cmd_echo(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;

	if(argc < 1){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help echo");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( i=1; i < argc; i++ )  {
		Tcl_AppendResult(interp, i==1 ? "" : " ", argv[i], (char *)NULL);
	}

	Tcl_AppendResult(interp, "\n", (char *)NULL);

	return TCL_OK;
}

#if 0
int
f_savedit(argc, argv)
	int	argc;
	char	*argv[];
{
	struct bu_vls str;
	char	line[35];
	int o_ipathpos;
	register struct solid *o_illump;

	o_illump = illump;
	bu_vls_init(&str);

	if(state == ST_S_EDIT){
		bu_vls_strcpy( &str, "press accept\npress sill\n" );
		cmdline(&str, 0);
		illump = o_illump;
		bu_vls_strcpy( &str, "M 1 0 0\n");
		cmdline(&str, 0);
		return CMD_OK;
	}else if(state == ST_O_EDIT){
		o_ipathpos = ipathpos;
		bu_vls_strcpy( &str, "press accept\npress oill\n" );
		cmdline(&str, 0);
		(void)chg_state( ST_O_PICK, ST_O_PATH, "savedit");
		illump = o_illump;
		ipathpos = o_ipathpos;
		bu_vls_strcpy( &str, "M 1 0 0\n");
		cmdline(&str, 0);
		return CMD_OK;
	}

	bu_log( "Savedit will only work in an edit state\n");
	bu_vls_free(&str);
	return CMD_BAD;
}
#endif

/*
 * SYNOPSIS
 *	tie [cw [dm]]
 *	tie -u cw
 *
 * DESCRIPTION
 *	This command ties/associates a command window (cw) to a display manager window (dm).
 *	When a command window is tied to a display manager window, all commands issued from
 *	this window will be directed at a particular display manager. Otherwise, the
 *	commands issued will be directed at the current display manager window.
 *
 * EXAMPLES
 *	tie		--->	returns a list of the command_window/display_manager associations
 *	tie cw1		--->	returns the display_manager, if it exists, associated with cw1
 *	tie cw1 dm1	--->	associated cw1 with dm1
 *	tie -u cw1	--->	removes the association, if it exists, cw1 has with a display manager
 */
int
f_tie(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int uflag = 0;		/* untie flag */
	struct cmd_list *clp;
	struct dm_list *dlp;
	struct bu_vls vls;

	bu_vls_init(&vls);

	if(argc < 1 || 3 < argc){
		bu_vls_printf(&vls, "helpdevel tie");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(argc == 1){
		for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) ){
			bu_vls_trunc(&vls, 0);
			if(clp->cl_tie){
				bu_vls_printf(&vls, "%S %S", &clp->cl_name,
						&clp->cl_tie->dml_dmp->dm_pathName);
				Tcl_AppendElement(interp, bu_vls_addr(&vls));
			}else{
				bu_vls_printf(&vls, "%S {}", &clp->cl_name);
				Tcl_AppendElement(interp, bu_vls_addr(&vls));
			}
		}

		bu_vls_trunc(&vls, 0);
		if(clp->cl_tie){
			bu_vls_printf(&vls, "%S %S", &clp->cl_name,
                                                &clp->cl_tie->dml_dmp->dm_pathName);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));
		}else{
			bu_vls_printf(&vls, "%S {}", &clp->cl_name);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));
		}

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(argv[1][0] == '-' && argv[1][1] == 'u'){
		uflag = 1;
		--argc;
		++argv;
	}

	if(argc < 2){
                bu_vls_printf(&vls, "help tie");
                Tcl_Eval(interp, bu_vls_addr(&vls));
                bu_vls_free(&vls);
                return TCL_ERROR;
	}

	for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
		if(!strcmp(bu_vls_addr(&clp->cl_name), argv[1]))
			break;

	if(clp == &head_cmd_list &&
	   (strcmp(bu_vls_addr(&head_cmd_list.cl_name), argv[1]))){
		Tcl_AppendResult(interp, "f_tie: unrecognized command_window - ", argv[1],
				 "\n", (char *)NULL);
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(uflag){
		if(clp->cl_tie)
			clp->cl_tie->dml_tie = (struct cmd_list *)NULL;

		clp->cl_tie = (struct dm_list *)NULL;

		bu_vls_free(&vls);
		return TCL_OK;
	}

	/* print out the display manager that we're tied to */
	if(argc == 2){
		if(clp->cl_tie)
			Tcl_AppendElement(interp, bu_vls_addr(&clp->cl_tie->dml_dmp->dm_pathName));
		else
			Tcl_AppendElement(interp, "");

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(*argv[2] != '.')
		bu_vls_printf(&vls, ".%s", argv[2]);
	else
		bu_vls_strcpy(&vls, argv[2]);

	FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
		if(!strcmp(bu_vls_addr(&vls), bu_vls_addr(&dlp->dml_dmp->dm_pathName)))
			break;

	if(dlp == &head_dm_list){
		Tcl_AppendResult(interp, "f_tie: unrecognized pathName - ",
				 bu_vls_addr(&vls), "\n", (char *)NULL);
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* already tied */
	if(clp->cl_tie)
		clp->cl_tie->dml_tie = (struct cmd_list *)NULL;

	clp->cl_tie = dlp;

	/* already tied */
	if(dlp->dml_tie)
		dlp->dml_tie->cl_tie = (struct dm_list *)NULL;

	dlp->dml_tie = clp;

	bu_vls_free(&vls);
	return TCL_OK;
}

int
f_ps(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int status;
	char *av[2];
	struct dm_list *dml;
	struct _view_state *vsp;

	if (argc < 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help ps");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dml = curr_dm_list;
	status = mged_attach(&which_dm[DM_PS_INDEX], argc, argv);
	if(status == TCL_ERROR)
		return TCL_ERROR;

	vsp = view_state;  /* save state info pointer */

	bu_free((genptr_t)menu_state,"f_ps: menu_state");
	menu_state = dml->dml_menu_state;

	scroll_top = dml->dml_scroll_top;
	scroll_active = dml->dml_scroll_active;
	scroll_y = dml->dml_scroll_y;
	bcopy((void *)dml->dml_scroll_array, (void *)scroll_array,
	      sizeof(struct scroll_item *) * 6);

	dirty = 1;
	refresh();

	view_state = vsp;  /* restore state info pointer */
	av[0] = "release";
	av[1] = NULL;
	status = f_release(clientData, interp, 1, av);
	curr_dm_list = dml;

	return status;
}

/*
 * Experimental - like f_plot except we attach to dm-plot, passing along
 *                any arguments.
 */
int
f_pl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int status;
	char *av[2];
	struct dm_list *dml;
	struct _view_state *vsp;

	if(argc < 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help pl");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dml = curr_dm_list;
	status = mged_attach(&which_dm[DM_PLOT_INDEX], argc, argv);
	if(status == TCL_ERROR)
		return TCL_ERROR;

	vsp = view_state;  /* save state info pointer */
	view_state = dml->dml_view_state;  /* use dml's state info */
	*mged_variables = *dml->dml_mged_variables; /* struct copy */

	bu_free((genptr_t)menu_state,"f_pl: menu_state");
	menu_state = dml->dml_menu_state;

	scroll_top = dml->dml_scroll_top;
	scroll_active = dml->dml_scroll_active;
	scroll_y = dml->dml_scroll_y;
	bcopy( (void *)dml->dml_scroll_array, (void *)scroll_array,
	       sizeof(struct scroll_item *) * 6);

	dirty = 1;
	refresh();

	view_state = vsp;  /* restore state info pointer */
	av[0] = "release";
	av[1] = NULL;
	status = f_release(clientData, interp, 1, av);
	curr_dm_list = dml;

	return status;
}

int
f_winset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct dm_list *p;

	if(argc < 1 || 2 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel winset");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* print pathname of drawing window with primary focus */
	if( argc == 1 ){
		Tcl_AppendResult(interp, bu_vls_addr(&pathName), (char *)NULL);
		return TCL_OK;
	}

	/* change primary focus to window argv[1] */
	FOR_ALL_DISPLAYS(p, &head_dm_list.l){
		if( !strcmp( argv[1], bu_vls_addr( &p->dml_dmp->dm_pathName ) ) ){
			curr_dm_list = p;

			if(curr_dm_list->dml_tie)
				curr_cmd_list = curr_dm_list->dml_tie;
			else
				curr_cmd_list = &head_cmd_list;

			return TCL_OK;
		}
	}

	Tcl_AppendResult(interp, "Unrecognized pathname - ", argv[1],
			 "\n", (char *)NULL);
	return TCL_ERROR;
}

void
mged_global_variable_setup(Tcl_Interp *interp)
{
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "mged_default(dlist)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&mged_default_dlist, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "mged_default(db_warn)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&db_warn, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "mged_default(db_upgrade)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&db_upgrade, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "mged_default(db_version)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&db_version, TCL_LINK_INT);

	bu_vls_strcpy(&vls, "edit_class");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&es_edclass, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "edit_solid_flag");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&es_edflag, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "edit_object_flag");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&edobj, TCL_LINK_INT);

	bu_vls_init(&edit_info_vls);
	bu_vls_strcpy(&edit_info_vls, "edit_info");
}

int
f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *old_dp, *new_dp;
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc != 3){
	  Tcl_AppendResult(interp, "Usage:\nbot_face_fuse new_bot_solid old_bot_solid\n", (char *)NULL );
	  return TCL_ERROR;
	}

	if( (old_dp = db_lookup( dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( intern.idb_type != ID_BOT )
	{
		Tcl_AppendResult(interp, argv[2], " is not a BOT solid!!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	(void) rt_bot_face_fuse( bot );

	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( new_dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

int
f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *old_dp, *new_dp;
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;
	int count1=0;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc != 3){
	  Tcl_AppendResult(interp, "Usage:\nbot_fuse new_bot_solid old_bot_solid\n", (char *)NULL );
	  return TCL_ERROR;
	}

	if( (old_dp = db_lookup( dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( intern.idb_type != ID_BOT )
	{
		Tcl_AppendResult(interp, argv[2], " is not a BOT solid!!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	count1 = rt_bot_vertex_fuse( bot );
	if( count1 )
		(void)rt_bot_condense( bot );

	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( new_dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

int
f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *old_dp, *new_dp;
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;
	int count2=0;
	char count_str[255];

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc != 3){
	  Tcl_AppendResult(interp, "Usage:\nbot_condense new_bot_solid old_bot_solid\n", (char *)NULL );
	  return TCL_ERROR;
	}

	if( (old_dp = db_lookup( dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( intern.idb_type != ID_BOT )
	{
		Tcl_AppendResult(interp, argv[2], " is not a BOT solid!!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	count2 = rt_bot_condense( bot );
	sprintf( count_str, "%d", count2 );
	Tcl_AppendResult(interp, count_str, " dead vertices eliminated\n", (char *)NULL );

	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( new_dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

#if 1
int
f_test_bomb_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	bu_bomb("\nTesting MGED's bomb hook!\n");

	/* This is never reached */
	return TCL_OK;
}
#endif

int
cmd_adjust(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_adjust_cmd(wdbp, interp, argc, argv);
}

int
cmd_attr(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_attr_cmd(wdbp, interp, argc, argv);
}

int
cmd_dbip(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_dbip_cmd(wdbp, interp, argc, argv);
}

int
cmd_dump(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_dump_cmd(wdbp, interp, argc, argv);
}

int
cmd_form(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_form_cmd(wdbp, interp, argc, argv);
}

int
cmd_get(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_get_cmd(wdbp, interp, argc, argv);
}

int
cmd_match(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_match_cmd(wdbp, interp, argc, argv);
}

int
cmd_put(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_put_cmd(wdbp, interp, argc, argv);
}

int
cmd_rt_gettrees(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_rt_gettrees_cmd(wdbp, interp, argc, argv);
}

int
cmd_dbversion(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_version_cmd(wdbp, interp, argc, argv);
}

/*
 *		    C M D _ C O M B _ S T D
 *
 *	Input a combination in standard set-theoetic notation
 *
 *	Syntax: c [-gr] comb_name [boolean_expr]
 */
int
cmd_comb_std(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	CHECK_DBI_NULL;

	return wdb_comb_std_cmd(wdbp, interp, argc, argv);
}

int
cmd_nmg_collapse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	char *av[3];

	CHECK_DBI_NULL;

	if (wdb_nmg_collapse_cmd(wdbp, interp, argc, argv) == TCL_ERROR)
		return TCL_ERROR;

	av[0] = "e";
	av[1] = argv[2];
	av[2] = NULL;

	return cmd_draw(clientData, interp, 2, av);
}

/*			F _ M A K E _ N A M E
 *
 * Generate an identifier that is guaranteed not to be the name
 * of any object currently in the database.
 *
 */
int
cmd_make_name(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_make_name_cmd(wdbp, interp, argc, argv);
}

int
cmd_shells(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_shells_cmd(wdbp, interp, argc, argv);
}

/*  	F _ P A T H S U M :   does the following
 *		1.  produces path for purposes of matching
 *      	2.  gives all paths matching the input path OR
 *		3.  gives a summary of all paths matching the input path
 *		    including the final parameters of the solids at the bottom
 *		    of the matching paths
 */
int
cmd_pathsum(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int	ret;

	CHECK_DBI_NULL;

	if (argc < 2) {
		/* get the path */
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "Enter the path: ", (char *)NULL);
		return TCL_ERROR;
	}

#if 0
	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;
#endif

	ret = wdb_pathsum_cmd(wdbp, interp, argc, argv);

#if 0
	(void)signal( SIGINT, SIG_IGN );
#endif
	return ret;
}

/*   	F _ C O P Y E V A L : copys an evaluated solid
 */

int
cmd_copyeval(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int ret;

	CHECK_DBI_NULL;

	if (argc < 3) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "Enter new_solid_name and full path to old_solid\n",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;

	ret = wdb_copyeval_cmd(wdbp, interp, argc, argv);

	(void)signal( SIGINT, SIG_IGN );
	return ret;
}


/*			F _ P U S H
 *
 * The push command is used to move matrices from combinations 
 * down to the solids. At some point, it is worth while thinking
 * about adding a limit to have the push go only N levels down.
 *
 * the -d flag turns on the treewalker debugging output.
 * the -P flag allows for multi-processor tree walking (not useful)
 * the -l flag is there to select levels even if it does not currently work.
 */
int
cmd_push(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_push_cmd(wdbp, interp, argc, argv);
}

int
cmd_hide(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_hide_cmd(wdbp, interp, argc, argv);
}

int
cmd_unhide(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_unhide_cmd(wdbp, interp, argc, argv);
}

int
cmd_xpush(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_xpush_cmd(wdbp, interp, argc, argv);
}

int
cmd_showmats(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_showmats_cmd(wdbp, interp, argc, argv);
}

int
cmd_nmg_simplify(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_nmg_simplify_cmd(wdbp, interp, argc, argv);
}

/*			F _ M A K E _ B B
 *
 *	Build an RPP bounding box for the list of objects and/or paths passed to this routine
 */

int
cmd_make_bb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_make_bb_cmd(wdbp, interp, argc, argv);
}

int
cmd_whatid(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_whatid_cmd(wdbp, interp, argc, argv);
}

/*
 *      C M D _ W H I C H
 *
 *	Finds all regions with given region ids or air codes.
 */
int
cmd_which(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int		ret;

	CHECK_DBI_NULL;

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;

	ret = wdb_which_cmd(wdbp, interp, argc, argv);

	(void)signal(SIGINT, SIG_IGN);
	return ret;
}

/*
 *  			C M D _ T O P S
 *  
 *  Find all top level objects.
 *  TODO:  Perhaps print all objects, sorted by use count, as an option?
 */
int
cmd_tops(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int		ret;

	CHECK_DBI_NULL;

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;

	ret = wdb_tops_cmd(wdbp, interp, argc, argv);

	(void)signal(SIGINT, SIG_IGN);
	return ret;
}

/*
 *			C M D _ T R E E
 *
 *	Print out a list of all members and submembers of an object.
 */
int
cmd_tree(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	int		ret;

	CHECK_DBI_NULL;

#if 0
	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
	else
		return TCL_OK;
#endif

	/*
	 * The tree command is wrapped by tclscripts/tree.tcl and calls this
	 * routine with the name _mged_tree. So, we put back the original name.
	 */ 
	argv[0] = "tree";
	ret = wdb_tree_cmd(wdbp, interp, argc, argv);

#if 0
	(void)signal(SIGINT, SIG_IGN);
#endif
	return ret;
}

/*	C M D _ M V A L L
 *
 *	rename all occurences of an object
 *	format:	mvall oldname newname
 *
 */
int
cmd_mvall(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_move_all_cmd(wdbp, interp, argc, argv);
}

/*
 *
 *			C M D _ D U P
 *
 *  Check for duplicate names in preparation for cat'ing of files
 *
 *  Usage:  dup file.g [prefix]
 *  becomes: db dup file.g [prefix]
 */
int
cmd_dup(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_dup_cmd(wdbp, interp, argc, argv);
}

/*
 *			C M D _ C O N C A T
 *
 *  Concatenate another GED file into the current file.
 *  Interrupts are not permitted during this function.
 *
 *  Usage:  dbconcat file.g [prefix]
 *  becomes: db concat file.g prefix
 *
 *  NOTE:  If a prefix is not given on the command line,
 *  then the users insist that they be prompted for the prefix,
 *  to prevent inadvertently sucking in a non-prefixed file.
 *  Slash ("/") specifies no prefix.
 */
int
cmd_concat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	/* get any prefix */
	if (argc < 2) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "concat: Enter database: ",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if (argc < 3) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "concat: Enter prefix string or / for no prefix: ",
				 (char *)NULL);
		return TCL_ERROR;
	}

	/* replace dbconcat with concat */
	argv[0] = "concat";

	return wdb_concat_cmd(wdbp, interp, argc, argv);
}

/* Rename an object */
/* Format: mv oldname newname	*/
int
cmd_name(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_move_cmd(wdbp, interp, argc, argv);
}

/* add solids to a region or create the region */
/* and then add solids */
/* Format: r regionname opr1 sol1 opr2 sol2 ... oprn soln */
int
cmd_region(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_region_cmd(wdbp, interp, argc, argv);
}

/* Delete members of a combination */
/* Format: rm comb memb1 memb2 .... membn	*/
int
cmd_remove(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_remove_cmd(wdbp, interp, argc, argv);
}

/*
 *			C M D _ U N I T S
 *
 * Change the local units of the description.
 * Base unit is fixed in mm, so this just changes the current local unit
 * that the user works in.
 */
int
cmd_units(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	register struct dm_list *dmlp;
	int		ret;
	fastf_t		sf;

	CHECK_DBI_NULL;

	sf = dbip->dbi_base2local;
	ret = wdb_units_cmd(wdbp, interp, argc, argv);

 	set_localunit_TclVar();
	sf = dbip->dbi_base2local / sf;
	update_grids(sf);
	update_views = 1;

	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
		dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
		dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
	}

	return ret;
}

/*
 *	Change the current title of the description
 */
int
cmd_title(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	int	ret;

	CHECK_DBI_NULL;

	ret = wdb_title_cmd(wdbp, interp, argc, argv);
	view_state->vs_flag = 1;

	return ret;
}

/*
 *  			C M D _ P R C O L O R
 */
int
cmd_prcolor(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	return wdb_prcolor_cmd(wdbp, interp, argc, argv);
}

/* List object information, briefly */
/* Format: cat object	*/
int
cmd_cat(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	int ret;

	CHECK_DBI_NULL;

#if 0
	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);	/* allow interupts */
	else
		return TCL_OK;
#endif

	ret = wdb_cat_cmd(wdbp, interp, argc, argv);

#if 0
	(void)signal(SIGINT, SIG_IGN);
#endif
	return ret;
}

/*
 *  			C M D _ C O L O R
 *  
 *  Add a color table entry.
 */
int
cmd_color(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	int ret;

	CHECK_DBI_NULL;

	ret = wdb_color_cmd(wdbp, interp, argc, argv);
	color_soltab();

	return ret;
}

/*
 *			C M D _ C O M B
 *
 *  Create or add to the end of a combination, with one or more solids,
 *  with explicitly specified operations.
 *
 *  Format: comb comb_name sol1 opr2 sol2 ... oprN solN
 */
int
cmd_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_comb_cmd(wdbp, interp, argc, argv);
}

/* Copy an object */
/* Format: cp oldname newname	*/
int
cmd_copy(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	int ret;
	char *av[3];

	CHECK_DBI_NULL;

	if ((ret = wdb_copy_cmd(wdbp, interp, argc, argv)) != TCL_OK)
		return ret;

	av[0] = "e";
	av[1] = argv[2]; /* depends on solid name being in argv[2] */
	av[2] = NULL;

	/* draw the new object */
	return cmd_draw(clientData, interp, 2, av);
}

/*
 *                C M D _ E X P A N D
 *
 * Performs wildcard expansion (matched to the database elements)
 * on its given arguments.  The result is returned in interp->result.
 */
int
cmd_expand(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    CHECK_DBI_NULL;

    return wdb_expand_cmd(wdbp, interp, argc, argv);
}

/*
 *			C M D _ L S
 *
 * This routine lists the names of all the objects accessible
 * in the object file.
 */
int
cmd_ls(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_ls_cmd(wdbp, interp, argc, argv);
}

/*
 *  			C M D _ F I N D
 *  
 *  Find all references to the named objects.
 */
int
cmd_find(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_find_cmd(wdbp, interp, argc, argv);
}

/* Grouping command */
/* Format: g groupname object1 object2 .... objectn	*/
int
cmd_group(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_group_cmd(wdbp, interp, argc, argv);
}

/* Create an instance of something */
/* Format: i object combname [op]	*/
int
cmd_instance(ClientData	clientData,
	     Tcl_Interp *interp,
	     int	argc,
	     char	**argv)
{
	CHECK_DBI_NULL;

	return wdb_instance_cmd(wdbp, interp, argc, argv);
}

int
cmd_keep(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_keep_cmd(wdbp, interp, argc, argv);
}

/*
 *			C M D _ L I S T
 *
 *  List object information, verbose, in GIFT-compatible format.
 *  Format: l object
 */
int
cmd_list(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	int recurse=0;

	CHECK_DBI_NULL;

	if (argc > 1 && argv[1][0] == '-' && argv[1][1] == 'r' && argv[1][2] == '\0')
		recurse = 1;

	/*
	 * Here we have no usable arguments,
	 * so we better be in an edit state.
	 */
	if ((argc == 1 || (argc == 2 && recurse)) && illump != SOLID_NULL) {
		struct bu_vls	vls;
		int		ret;
		int		ac;
		char		*av[4];

		bu_vls_init(&vls);

		if (state == ST_S_EDIT)
			db_path_to_vls( &vls, &illump->s_fullpath );
		else if (state == ST_O_EDIT) {
			register int	i;
			for( i=0; i < ipathpos; i++ ) {
				bu_vls_printf(&vls, "/%s",
					      DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep );
			}
		} else
			return TCL_ERROR;

		if (recurse) {
			av[0] = "l";
			av[1] = "-r";
			av[2] = bu_vls_addr(&vls);
			av[3] = (char *)NULL;
			ac = 3;
		} else {
			av[0] = "l";
			av[1] = bu_vls_addr(&vls);
			av[2] = (char *)NULL;
			ac = 2;
		}
		ret = wdb_list_cmd(wdbp, interp, ac, av);
		bu_vls_free(&vls);
		return ret;
	} else {
		return wdb_list_cmd(wdbp, interp, argc, argv);
	}
}

/*
 *			C M D _ L M
 *
 *	List regions based on values of their MUVES_Component attribute
 */
int
cmd_lm(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct bu_attribute_value_set avs;
	struct bu_vls vls;
	struct bu_ptbl *tbl;
	struct directory *dp;
	int i;
	int last_opt=0;
	int new_arg_count=1;
	int new_argc;
	int ret;
	char **new_argv;

	bu_vls_init( &vls );
	bu_vls_strcat( &vls, argv[0] );
	for( i=1 ; i<argc ; i++ ) {
		if( *argv[i] == '-' ) {
			bu_vls_putc( &vls, ' ' );
			bu_vls_strcat( &vls, argv[i] );
			last_opt = i;
			new_arg_count++;
		} else {
			break;
		}
	}

	bu_avs_init( &avs, argc - last_opt, "cmd_lm avs" );
	for( i=last_opt+1 ; i<argc ; i++ ) {
		bu_avs_add_nonunique( &avs, "MUVES_Component", argv[i] );
	}

	tbl = db_lookup_by_attr( dbip, DIR_REGION, &avs, 2 );
	if( !tbl ) {
		/* Error!!! */
		Tcl_AppendResult( interp, "Error: db_lookup_by_attr() failed!!\n", (char *)NULL );
		bu_vls_free( &vls );
		bu_avs_free( &avs );
		return TCL_ERROR;
	}

	if( BU_PTBL_LEN( tbl ) == 0 ) {
		/* no matches */
		bu_vls_free( &vls );
		bu_avs_free( &avs );
		bu_ptbl_free( tbl );
		bu_free( (char *)tbl, "cmd_lm ptbl" );
		return TCL_OK;
	}

	for( i=0 ; i<BU_PTBL_LEN( tbl ) ; i++ ) {
		dp = (struct directory *)BU_PTBL_GET( tbl, i );
		bu_vls_putc( &vls, ' ' );
		bu_vls_strcat( &vls, dp->d_namep );
		new_arg_count++;
	}

	bu_ptbl_free( tbl );
	bu_free( (char *)tbl, "cmd_lm ptbl" );

	/* create a new argc and argv to pass to the cmd_ls routine */
	new_argv = (char **)bu_calloc( new_arg_count + 1, sizeof( char *), "cmd_lm new_argv" );
	new_argc = bu_argv_from_string( new_argv, new_arg_count+1, bu_vls_addr( &vls ) );

	ret = cmd_ls( clientData, interp, new_argc, new_argv );

	bu_vls_free( &vls );
	bu_free( (char *)new_argv, "cmd_lm new_argv" );

	return( ret );
}


/*
 *			C M D _ L T
 *
 *  List object information in a tcl list. The
 *  tcl list is a list of {op obj} pairs.
 */
int
cmd_lt(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	return wdb_lt_cmd(wdbp, interp, argc, argv);
}

/*
 *			F _ T O L
 *
 *  "tol"	displays current settings
 *  "tol abs #"	sets absolute tolerance.  # > 0.0
 *  "tol rel #"	sets relative tolerance.  0.0 < # < 1.0
 *  "tol norm #" sets normal tolerance, in degrees.
 *  "tol dist #" sets calculational distance tolerance
 *  "tol perp #" sets calculational normal tolerance.
 */
int
cmd_tol(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	int ret;

	CHECK_DBI_NULL;

	ret = wdb_tol_cmd(wdbp, interp, argc, argv);

	/* hack to keep mged tolerance settings current */
	mged_ttol = wdbp->wdb_ttol;
	mged_tol = wdbp->wdb_tol;
	mged_abs_tol = mged_ttol.abs;
	mged_rel_tol = mged_ttol.rel;
	mged_nrm_tol = mged_ttol.norm;

	return( ret );
}

/* defined in chgview.c */
extern int edit_com(int argc, char **argv, int kind, int catch_sigint);

/* ZAP the display -- then edit anew */
/* Format: B object	*/
int
cmd_blast(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	char *av[2];

	av[0] = "Z";
	av[1] = (char *)0;

	if (cmd_zap(clientData, interp, 1, av) == TCL_ERROR)
		return TCL_ERROR;

	return edit_com(argc, argv, 1, 1);
}

/* Edit something (add to visible display) */
/* Format: e object	*/
int
cmd_draw(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	return edit_com(argc, argv, 1, 1);
}

extern int emuves_com( int argc, char **argv );	/* from chgview.c */

/* Add regions with attribute MUVES_Component haveing the specified values */
/* Format: em value [value value ...]	*/
int
cmd_emuves(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	return emuves_com(argc, argv);
}

/* Format: ev objects	*/
int
cmd_ev(ClientData	clientData,
       Tcl_Interp *interp,
       int	argc,
       char	**argv)
{
	return edit_com(argc, argv, 3, 1);
}

/*
 *			C M D _ V D R A W
 */
int
cmd_vdraw(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	CHECK_DBI_NULL;

	return dgo_vdraw_cmd(dgop, interp, argc, argv);
}

/*
 *			C M D _ E
 *
 *  The "Big E" command.
 *  Evaluated Edit something (add to visible display)
 *  Usage: E object(s)
 */
int
cmd_E(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char	**argv)
{
	int	initial_blank_screen;
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
	register struct cmd_list *save_cmd_list;
	int ret;

	CHECK_DBI_NULL;
	initial_blank_screen = BU_LIST_IS_EMPTY(&dgop->dgo_headSolid);

	if ((ret = dgo_E_cmd(dgop, interp, argc, argv)) != TCL_OK)
		return ret;

	update_views = 1;

	save_dmlp = curr_dm_list;
	save_cmd_list = curr_cmd_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
		curr_dm_list = dmlp;
		if (curr_dm_list->dml_tie)
			curr_cmd_list = curr_dm_list->dml_tie;
		else
			curr_cmd_list = &head_cmd_list;

		/* If we went from blank screen to non-blank, resize */
		if (mged_variables->mv_autosize  && initial_blank_screen &&
		    BU_LIST_NON_EMPTY(&dgop->dgo_headSolid)) {
			struct view_ring *vrp;

			size_reset();
			new_mats();
			(void)mged_svbase();

			for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
				vrp->vr_scale = view_state->vs_vop->vo_scale;
		}
	}

	curr_dm_list = save_dmlp;
	curr_cmd_list = save_cmd_list;

	return TCL_OK;
}

int
cmd_bot_face_sort( ClientData	clientData,
	Tcl_Interp	*interp,
	int     	argc,
	char    	**argv)
{
	CHECK_DBI_NULL;
	return wdb_bot_face_sort_cmd( wdbp, interp, argc, argv );
}

int
cmd_bot_decimate( ClientData	clientData,
	Tcl_Interp	*interp,
	int     	argc,
	char    	**argv)
{
	CHECK_DBI_NULL;
	return wdb_bot_decimate_cmd( wdbp, interp, argc, argv );
}

#ifdef WIN32
/* limited to seconds only */
void gettimeofday(struct timeval *tp, struct timezone *tzp)
{

	time_t ltime;

	time( &ltime );

	tp->tv_sec = ltime;
	tp->tv_usec = 0;

}
#endif


int
cmd_shaded_mode(ClientData	clientData,
		Tcl_Interp	*interp,
		int     	argc,
		char    	**argv)
{
	/* check to see if we have -a or -auto */
	if (argc == 3 && 
	    argv[1][0] == '-' &&
	    argv[1][1] == 'a') {
	  struct bu_vls vls;

	  /* set zbuffer, zclip and lighting for all */
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "mged_shaded_mode_helper %s", argv[2]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);

	  /* skip past -a */
	  --argc;
	  ++argv;
	}

	return dgo_shaded_mode_cmd(dgop, interp, argc, argv);
}
@


11.288
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/cmd.c,v 11.287 2004/05/05 14:20:29 morrison Exp $ (BRL)";
@


11.287
log
@make the USE_SURVICE_MODS not compile-time-optional.  so that means the #if sections go bye bye.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 5
a31 1
#include "conf.h"
@


11.286
log
@merge of ansi-6-0-branch into HEAD
@
text
@a414 1
#if USE_SURVICE_MODS
a415 1
#endif
a3304 1
#if USE_SURVICE_MODS
a3329 1
#endif
@


11.285
log
@merge of windows-6-0-branch into head
@
text
@d98 4
a101 4
void mged_setup(), cmd_setup(), mged_compat();
void mged_print_result();
void mged_global_variable_setup();
int f_bot_fuse(), f_bot_condense(), f_bot_face_fuse();
d108 4
a111 4
extern void update_grids();			/* in grid.c */
extern void set_localunit_TclVar();		/* in chgmodel.c */
extern void init_qray();			/* in qray.c */
extern int gui_setup();				/* in attach.c */
d119 1
a119 1
extern void mged_view_obj_callback();
d131 1
a131 1
int mged_cmd();
a493 1
#ifndef WIN32
d495 1
a495 6
output_catch(clientdata, str)
	genptr_t clientdata;
	genptr_t str;
#else
	HIDDEN int output_catch(genptr_t clientdata, genptr_t str)
#endif
d516 1
a516 2
start_catching_output(vp)
	struct bu_vls *vp;
d528 1
a528 2
stop_catching_output(vp)
	struct bu_vls *vp;
a540 1
#ifndef WIN32
d542 1
a542 7
gui_output(clientData, str)
	genptr_t clientData;
	genptr_t str;
#else
int
	gui_output(genptr_t clientData, genptr_t str)
#endif
d579 1
a579 5
cmd_tk(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d609 1
a609 5
cmd_output_hook(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;    
	int argc;
	char **argv;
d663 1
a663 5
cmd_nop(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d677 1
a677 5
cmd_get_ptr(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d691 1
a691 1
mged_setup()
d782 1
a782 1
cmd_setup()
d852 1
a852 5
cmd_cmd_win(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1044 1
a1044 5
cmd_get_more_default(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1061 1
a1061 5
cmd_set_more_default(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1079 1
a1079 5
cmd_mged_glob(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1111 1
a1111 2
debackslash( dest, src )
	struct bu_vls *dest, *src;
d1126 1
a1126 2
backslash_specials( dest, src )
	struct bu_vls *dest, *src;
d1159 1
a1159 3
mged_compat( dest, src, use_first )
	struct bu_vls *dest, *src;
	int use_first;
d1386 1
a1386 1
	extern void pr_prompt();
d1497 1
a1497 5
f_comm(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int	argc;
	char	**argv;
d1563 1
a1563 5
f_sync(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1590 1
a1590 4
helpcomm( argc, argv, functions)
	int	argc;
	char	**argv;
	struct funtab *functions;
d1626 1
a1626 4
f_help2(argc, argv, functions)
	int argc;
	char **argv;
	struct funtab *functions;
d1642 1
a1642 4
f_fhelp2( argc, argv, functions)
	int	argc;
	char	**argv;
	struct funtab *functions;
d1663 1
a1663 5
cmd_summary(clientData, interp, argc, argv )
	ClientData clientData;
	Tcl_Interp *interp;
	int	argc;
	char	**argv;
d1677 1
a1677 5
cmd_echo(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int	argc;
	char	*argv[];
d1757 1
a1757 5
f_tie(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char *argv[];
d1879 1
a1879 5
f_ps(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char *argv[];
d1929 1
a1929 5
f_pl(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char *argv[];
d1977 1
a1977 5
f_winset(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2017 1
a2017 2
mged_global_variable_setup(interp)
Tcl_Interp *interp;
d2043 1
a2043 5
f_bot_face_fuse( clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2092 1
a2092 5
f_bot_fuse(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2144 1
a2144 5
f_bot_condense(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2198 1
a2198 5
f_test_bomb_hook(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2336 1
a2336 5
cmd_nmg_collapse( clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2370 1
a2370 5
cmd_shells(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2385 1
a2385 5
cmd_pathsum(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2417 1
a2417 5
cmd_copyeval(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2453 1
a2453 5
cmd_push(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2461 1
a2461 5
cmd_hide(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2469 1
a2469 5
cmd_unhide(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2488 1
a2488 5
cmd_showmats(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2496 1
a2496 5
cmd_nmg_simplify(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
d2509 1
a2509 5
cmd_make_bb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2517 1
a2517 5
cmd_whatid(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2530 1
a2530 5
cmd_which(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d2554 1
a2554 5
cmd_tops(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2633 1
a2633 5
cmd_dup(clientData, interp, argc, argv )
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d2655 1
a2655 5
cmd_concat(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d2710 1
a2710 5
cmd_remove(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2840 1
a2840 5
cmd_comb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2878 1
a2878 5
cmd_expand( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d3146 1
a3146 1
extern int edit_com();
@


11.284
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.283 2003/09/05 14:39:53 jra Exp $ (BRL)";
d37 1
d39 1
d136 4
d349 1
d351 1
d494 1
d499 3
d549 1
d554 4
d726 1
a726 1

d733 10
d846 11
d1555 2
d1582 1
d1634 2
a1635 1

d1637 1
d3471 16
@


11.283
log
@Changed "smooth_bot" command to "bot_smooth"
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.282 2003/01/31 13:39:05 jra Exp $ (BRL)";
@


11.283.4.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.284 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.283.4.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.283.4.1 2004/02/12 18:34:13 erikg Exp $ (BRL)";
@


11.283.4.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a36 1
#ifndef WIN32
a37 1
#endif
a133 4
#ifdef WIN32
void gettimeofday(struct timeval *tp, struct timezone *tzp);
#endif

a342 1
#ifdef TCP_FILES
a343 1
#endif
a485 1
#ifndef WIN32
a489 3
#else
	HIDDEN int output_catch(genptr_t clientdata, genptr_t str)
#endif
a536 1
#ifndef WIN32
a540 4
#else
int
	gui_output(genptr_t clientData, genptr_t str)
#endif
d709 1
a709 1
	
a715 10
#ifdef WIN32
	{
	  /* XXX - nasty little hack to convert paths */
	  int i;
	  strcat(filename,"/");
	  for (i=0;i<strlen(filename);i++) {
	    if(filename[i]=='\\') 
	      filename[i]='/'; }
	}
#endif
a818 11
#ifdef WIN32
	{
		/* XXXXXXXXXXXXXXX UGLY XXXXXXXXXXXXXXXXXX*/
	int i;
	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
		if(pathname[i]=='\\') 
			pathname[i]='/'; }
	}
#endif

a1516 2
#ifndef WIN32

a1541 1
#endif
d1593 1
a1593 2
// XXXXXXXXXXXXXXX FIX LATER XXXXXXXXXXXXXXXXXx
#ifndef WIN32
a1594 1
#endif
a3427 16

#ifdef WIN32
/* limited to seconds only */
void gettimeofday(struct timeval *tp, struct timezone *tzp)
{

	time_t ltime;

	time( &ltime );

	tp->tv_sec = ltime;
	tp->tv_usec = 0;

}
#endif

@


11.282
log
@Added "smooth_bot" command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.281 2002/10/25 02:30:12 morrison Exp $ (BRL)";
a178 1
	{"bot_vertex_fuse", f_bot_fuse},
d181 2
a413 1
	{"smooth_bot", cmd_smooth_bot },
@


11.281
log
@Finally found what was wrong with geometree installation -- added %s to a printf without adding the param...heh
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.280 2002/08/28 16:51:51 morrison Exp $ (BRL)";
d113 1
d413 1
@


11.280
log
@moved item to be alphabetically consistent
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.279 2002/08/20 17:08:22 jra Exp $ (BRL)";
d763 1
a763 4
	bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 \
                             %stclscripts/mged %stclscripts \
                             %stclscripts/lib %stclscripts/util]",
		      filename, filename, filename, filename);
@


11.280.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.280 2002/08/28 16:51:51 morrison Exp $ (BRL)";
a36 1
#ifndef WIN32
a37 1
#endif
a132 4
#ifdef WIN32
void gettimeofday(struct timeval *tp, struct timezone *tzp);
#endif

a340 1
#ifdef TCP_FILES
a341 1
#endif
a483 1
#ifndef WIN32
a487 3
#else
	HIDDEN int output_catch(genptr_t clientdata, genptr_t str)
#endif
a534 1
#ifndef WIN32
a538 4
#else
int
	gui_output(genptr_t clientData, genptr_t str)
#endif
d707 1
a707 1
	
a713 10
#ifdef WIN32
	{
		/* XXXXXXXXXXXXXXX UGLY XXXXXXXXXXXXXXXXXX*/
	int i;
	strcat(filename,"/");
	for (i=0;i<strlen(filename);i++) {
		if(filename[i]=='\\') 
			filename[i]='/'; }
	}
#endif
a819 11
#ifdef WIN32
	{
		/* XXXXXXXXXXXXXXX UGLY XXXXXXXXXXXXXXXXXX*/
	int i;
	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
		if(pathname[i]=='\\') 
			pathname[i]='/'; }
	}
#endif

a1517 2
#ifndef WIN32

a1542 1
#endif
d1594 1
a1594 2
// XXXXXXXXXXXXXXX FIX LATER XXXXXXXXXXXXXXXXXx
#ifndef WIN32
a1595 1
#endif
a3428 16

#ifdef WIN32
/* limited to seconds only */
void gettimeofday(struct timeval *tp, struct timezone *tzp)
{

	time_t ltime;

	time( &ltime );

	tp->tv_sec = ltime;
	tp->tv_usec = 0;

}
#endif

@


11.280.4.2
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/cmd.c,v 11.280.4.1 2002/09/26 23:04:09 morrison Exp $ (BRL)";
a114 1
extern int cmd_smooth_bot();
d184 1
a186 2
	{"bot_smooth", cmd_smooth_bot },
	{"bot_vertex_fuse", f_bot_fuse},
d790 4
a793 1
	bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 %stclscripts/mged %stclscripts %stclscripts/lib %stclscripts/util %stclscripts/geometree]", filename, filename, filename, filename, filename);
@


11.280.4.3
log
@remerge head into branch just in case someone checks out this branch later
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d735 6
a740 6
	  /* XXX - nasty little hack to convert paths */
	  int i;
	  strcat(filename,"/");
	  for (i=0;i<strlen(filename);i++) {
	    if(filename[i]=='\\') 
	      filename[i]='/'; }
@


11.280.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.280 2002/08/28 16:51:51 morrison Exp $ (BRL)";
d96 4
a99 4
void mged_setup(void), cmd_setup(void), mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first);
void mged_print_result(int status);
void mged_global_variable_setup(Tcl_Interp *interp);
int f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv), f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv), f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d106 4
a109 4
extern void update_grids(fastf_t sf);			/* in grid.c */
extern void set_localunit_TclVar(void);		/* in chgmodel.c */
extern void init_qray(void);			/* in qray.c */
extern int gui_setup(char *dstr);				/* in attach.c */
d116 1
a116 1
extern void mged_view_obj_callback(genptr_t clientData, struct view_obj *vop);
d128 1
a128 1
int mged_cmd(int argc, char **argv, struct funtab *in_functions);
d485 3
a487 1
output_catch(genptr_t clientdata, genptr_t str)
d508 2
a509 1
start_catching_output(struct bu_vls *vp)
d521 2
a522 1
stop_catching_output(struct bu_vls *vp)
d536 3
a538 1
gui_output(genptr_t clientData, genptr_t str)
d575 5
a579 1
cmd_tk(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d609 5
a613 1
cmd_output_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d667 5
a671 1
cmd_nop(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d685 5
a689 1
cmd_get_ptr(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d703 1
a703 1
mged_setup(void)
d787 1
a787 1
cmd_setup(void)
d846 5
a850 1
cmd_cmd_win(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1042 5
a1046 1
cmd_get_more_default(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1063 5
a1067 1
cmd_set_more_default(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1085 5
a1089 1
cmd_mged_glob(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1121 2
a1122 1
debackslash(struct bu_vls *dest, struct bu_vls *src)
d1137 2
a1138 1
backslash_specials(struct bu_vls *dest, struct bu_vls *src)
d1171 3
a1173 1
mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first)
d1400 1
a1400 1
	extern void pr_prompt(void);
d1511 5
a1515 1
f_comm(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1578 5
a1582 1
f_sync(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1607 4
a1610 1
helpcomm(int argc, char **argv, struct funtab *functions)
d1646 4
a1649 1
f_help2(int argc, char **argv, struct funtab *functions)
d1665 4
a1668 1
f_fhelp2(int argc, char **argv, struct funtab *functions)
d1689 5
a1693 1
cmd_summary(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1707 5
a1711 1
cmd_echo(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1791 5
a1795 1
f_tie(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1917 5
a1921 1
f_ps(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1971 5
a1975 1
f_pl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2023 5
a2027 1
f_winset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2067 2
a2068 1
mged_global_variable_setup(Tcl_Interp *interp)
d2094 5
a2098 1
f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2147 5
a2151 1
f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2203 5
a2207 1
f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2261 5
a2265 1
f_test_bomb_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2403 5
a2407 1
cmd_nmg_collapse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2441 5
a2445 1
cmd_shells(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2460 5
a2464 1
cmd_pathsum(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2496 5
a2500 1
cmd_copyeval(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2536 5
a2540 1
cmd_push(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2548 5
a2552 1
cmd_hide(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2560 5
a2564 1
cmd_unhide(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2583 5
a2587 1
cmd_showmats(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2595 5
a2599 1
cmd_nmg_simplify(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2612 5
a2616 1
cmd_make_bb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2624 5
a2628 1
cmd_whatid(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2641 5
a2645 1
cmd_which(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2669 5
a2673 1
cmd_tops(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2752 5
a2756 1
cmd_dup(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2778 5
a2782 1
cmd_concat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2837 5
a2841 1
cmd_remove(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2971 5
a2975 1
cmd_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3013 5
a3017 1
cmd_expand(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3285 1
a3285 1
extern int edit_com(int argc, char **argv, int kind, int catch_sigint);
@


11.280.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a36 1
#ifndef WIN32
a37 1
#endif
a112 1
extern int cmd_smooth_bot();
a132 4
#ifdef WIN32
void gettimeofday(struct timeval *tp, struct timezone *tzp);
#endif

d178 1
a180 2
	{"bot_smooth", cmd_smooth_bot },
	{"bot_vertex_fuse", f_bot_fuse},
a340 1
#ifdef TCP_FILES
a341 1
#endif
d685 1
a685 1
	
a691 10
#ifdef WIN32
	{
	  /* XXX - nasty little hack to convert paths */
	  int i;
	  strcat(filename,"/");
	  for (i=0;i<strlen(filename);i++) {
	    if(filename[i]=='\\') 
	      filename[i]='/'; }
	}
#endif
d741 4
a744 1
	bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 %stclscripts/mged %stclscripts %stclscripts/lib %stclscripts/util %stclscripts/geometree]", filename, filename, filename, filename, filename);
a797 11
#ifdef WIN32
	{
		/* XXXXXXXXXXXXXXX UGLY XXXXXXXXXXXXXXXXXX*/
	int i;
	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
		if(pathname[i]=='\\') 
			pathname[i]='/'; }
	}
#endif

a1471 2
#ifndef WIN32

a1496 1
#endif
d1544 1
a1544 2
// XXXXXXXXXXXXXXX FIX LATER XXXXXXXXXXXXXXXXXx
#ifndef WIN32
a1545 1
#endif
a3256 16

#ifdef WIN32
/* limited to seconds only */
void gettimeofday(struct timeval *tp, struct timezone *tzp)
{

	time_t ltime;

	time( &ltime );

	tp->tv_sec = ltime;
	tp->tv_usec = 0;

}
#endif

@


11.279
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.277 2002/08/14 17:25:57 jra Exp $ (BRL)";
a278 1
	{"listeval", cmd_pathsum},
d294 1
@


11.278
log
@Converted from K&R to ANSI C - RFH
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.274 2002/06/19 20:14:32 butler Exp $ (BRL)";
d96 4
a99 4
void mged_setup(void), cmd_setup(void), mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first);
void mged_print_result(int status);
void mged_global_variable_setup(Tcl_Interp *interp);
int f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv), f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv), f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d106 4
a109 4
extern void update_grids(fastf_t sf);			/* in grid.c */
extern void set_localunit_TclVar(void);		/* in chgmodel.c */
extern void init_qray(void);			/* in qray.c */
extern int gui_setup(char *dstr);				/* in attach.c */
d116 1
a116 1
extern void mged_view_obj_callback(genptr_t clientData, struct view_obj *vop);
d122 3
d128 1
a128 1
int mged_cmd(int argc, char **argv, struct funtab *in_functions);
d185 1
d284 1
d485 3
a487 1
output_catch(genptr_t clientdata, genptr_t str)
d508 2
a509 1
start_catching_output(struct bu_vls *vp)
d521 2
a522 1
stop_catching_output(struct bu_vls *vp)
d536 3
a538 1
gui_output(genptr_t clientData, genptr_t str)
d575 5
a579 1
cmd_tk(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d609 5
a613 1
cmd_output_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d667 5
a671 1
cmd_nop(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d685 5
a689 1
cmd_get_ptr(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d703 1
a703 1
mged_setup(void)
d787 1
a787 1
cmd_setup(void)
d846 5
a850 1
cmd_cmd_win(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1042 5
a1046 1
cmd_get_more_default(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1063 5
a1067 1
cmd_set_more_default(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1085 5
a1089 1
cmd_mged_glob(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1121 2
a1122 1
debackslash(struct bu_vls *dest, struct bu_vls *src)
d1137 2
a1138 1
backslash_specials(struct bu_vls *dest, struct bu_vls *src)
d1171 3
a1173 1
mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first)
d1400 1
a1400 1
	extern void pr_prompt(void);
d1511 5
a1515 1
f_comm(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1578 5
a1582 1
f_sync(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1607 4
a1610 1
helpcomm(int argc, char **argv, struct funtab *functions)
d1646 4
a1649 1
f_help2(int argc, char **argv, struct funtab *functions)
d1665 4
a1668 1
f_fhelp2(int argc, char **argv, struct funtab *functions)
d1689 5
a1693 1
cmd_summary(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1707 5
a1711 1
cmd_echo(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1791 5
a1795 1
f_tie(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1917 5
a1921 1
f_ps(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1971 5
a1975 1
f_pl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2023 5
a2027 1
f_winset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2067 2
a2068 1
mged_global_variable_setup(Tcl_Interp *interp)
d2094 5
a2098 1
f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2147 5
a2151 1
f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2203 5
a2207 1
f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2261 5
a2265 1
f_test_bomb_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2403 5
a2407 1
cmd_nmg_collapse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2441 5
a2445 1
cmd_shells(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2460 5
a2464 1
cmd_pathsum(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2496 5
a2500 1
cmd_copyeval(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2536 5
a2540 1
cmd_push(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2548 5
a2552 1
cmd_hide(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2560 5
a2564 1
cmd_unhide(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2583 5
a2587 1
cmd_showmats(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2595 5
a2599 1
cmd_nmg_simplify(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2612 5
a2616 1
cmd_make_bb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2624 5
a2628 1
cmd_whatid(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2641 5
a2645 1
cmd_which(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2669 5
a2673 1
cmd_tops(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2752 5
a2756 1
cmd_dup(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2778 5
a2782 1
cmd_concat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2837 5
a2841 1
cmd_remove(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2971 5
a2975 1
cmd_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3013 5
a3017 1
cmd_expand(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3268 2
d3272 10
a3281 1
	return wdb_tol_cmd(wdbp, interp, argc, argv);
d3285 1
a3285 1
extern int edit_com(int argc, char **argv, int kind, int catch_sigint);
@


11.277
log
@"tol" command now updates mged_ttol, mged_tol, mged_abs_tol, mged_rel_tol, and mged_nrm_tol
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.276 2002/08/12 18:25:38 morrison Exp $ (BRL)";
d96 4
a99 4
void mged_setup(), cmd_setup(), mged_compat();
void mged_print_result();
void mged_global_variable_setup();
int f_bot_fuse(), f_bot_condense(), f_bot_face_fuse();
d106 4
a109 4
extern void update_grids();			/* in grid.c */
extern void set_localunit_TclVar();		/* in chgmodel.c */
extern void init_qray();			/* in qray.c */
extern int gui_setup();				/* in attach.c */
d116 1
a116 1
extern void mged_view_obj_callback();
a121 3
extern struct rt_tess_tol     mged_ttol; /* do_draw.c */
extern struct bn_tol	      mged_tol; /* ged.c */

d125 1
a125 1
int mged_cmd();
a181 1
	{"closedb", f_closedb},
a279 1
	{"loadview", f_loadview},
d480 1
a480 3
output_catch(clientdata, str)
	genptr_t clientdata;
	genptr_t str;
d501 1
a501 2
start_catching_output(vp)
	struct bu_vls *vp;
d513 1
a513 2
stop_catching_output(vp)
	struct bu_vls *vp;
d527 1
a527 3
gui_output(clientData, str)
	genptr_t clientData;
	genptr_t str;
d564 1
a564 5
cmd_tk(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d594 1
a594 5
cmd_output_hook(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;    
	int argc;
	char **argv;
d648 1
a648 5
cmd_nop(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d662 1
a662 5
cmd_get_ptr(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d676 1
a676 1
mged_setup()
d760 1
a760 1
cmd_setup()
d819 1
a819 5
cmd_cmd_win(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1011 1
a1011 5
cmd_get_more_default(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1028 1
a1028 5
cmd_set_more_default(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1046 1
a1046 5
cmd_mged_glob(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1078 1
a1078 2
debackslash( dest, src )
	struct bu_vls *dest, *src;
d1093 1
a1093 2
backslash_specials( dest, src )
	struct bu_vls *dest, *src;
d1126 1
a1126 3
mged_compat( dest, src, use_first )
	struct bu_vls *dest, *src;
	int use_first;
d1353 1
a1353 1
	extern void pr_prompt();
d1464 1
a1464 5
f_comm(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int	argc;
	char	**argv;
d1527 1
a1527 5
f_sync(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
d1552 1
a1552 4
helpcomm( argc, argv, functions)
	int	argc;
	char	**argv;
	struct funtab *functions;
d1588 1
a1588 4
f_help2(argc, argv, functions)
	int argc;
	char **argv;
	struct funtab *functions;
d1604 1
a1604 4
f_fhelp2( argc, argv, functions)
	int	argc;
	char	**argv;
	struct funtab *functions;
d1625 1
a1625 5
cmd_summary(clientData, interp, argc, argv )
	ClientData clientData;
	Tcl_Interp *interp;
	int	argc;
	char	**argv;
d1639 1
a1639 5
cmd_echo(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int	argc;
	char	*argv[];
d1719 1
a1719 5
f_tie(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char *argv[];
d1841 1
a1841 5
f_ps(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char *argv[];
d1891 1
a1891 5
f_pl(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char *argv[];
d1939 1
a1939 5
f_winset(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d1979 1
a1979 2
mged_global_variable_setup(interp)
Tcl_Interp *interp;
d2005 1
a2005 5
f_bot_face_fuse( clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2054 1
a2054 5
f_bot_fuse(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2106 1
a2106 5
f_bot_condense(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2160 1
a2160 5
f_test_bomb_hook(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
d2298 1
a2298 5
cmd_nmg_collapse( clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2332 1
a2332 5
cmd_shells(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2347 1
a2347 5
cmd_pathsum(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2379 1
a2379 5
cmd_copyeval(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2415 1
a2415 5
cmd_push(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2423 1
a2423 5
cmd_hide(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2431 1
a2431 5
cmd_unhide(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2450 1
a2450 5
cmd_showmats(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2458 1
a2458 5
cmd_nmg_simplify(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
d2471 1
a2471 5
cmd_make_bb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2479 1
a2479 5
cmd_whatid(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2492 1
a2492 5
cmd_which(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d2516 1
a2516 5
cmd_tops(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2595 1
a2595 5
cmd_dup(clientData, interp, argc, argv )
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d2617 1
a2617 5
cmd_concat(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
d2672 1
a2672 5
cmd_remove(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2802 1
a2802 5
cmd_comb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2840 1
a2840 5
cmd_expand( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
a3090 2
	int ret;

d3093 1
a3093 10
	ret = wdb_tol_cmd(wdbp, interp, argc, argv);

	/* hack to keep mged tolerance settings current */
	mged_ttol = wdbp->wdb_ttol;
	mged_tol = wdbp->wdb_tol;
	mged_abs_tol = mged_ttol.abs;
	mged_rel_tol = mged_ttol.rel;
	mged_nrm_tol = mged_ttol.norm;

	return( ret );
d3097 1
a3097 1
extern int edit_com();
@


11.276
log
@added closedb command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.275 2002/08/11 02:10:44 morrison Exp $ (BRL)";
d122 3
d3268 2
d3272 10
a3281 1
	return wdb_tol_cmd(wdbp, interp, argc, argv);
@


11.275
log
@Added loadview command.  loadview command is converse of the saveview command.  it reads raytrace script files, handles a proper subset of the possible commands (those related to the view only), and restores the stored view
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.274 2002/06/19 20:14:32 butler Exp $ (BRL)";
d182 1
@


11.274
log
@SURVICE mods
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.273 2002/02/26 20:31:22 jra Exp $ (BRL)";
d280 1
@


11.273
log
@Added "lm" command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.272 2002/02/22 16:09:44 jra Exp $ (BRL)";
d400 3
d3413 28
@


11.272
log
@Added "em" command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.271 2002/02/17 03:08:49 jra Exp $ (BRL)";
d276 1
d3147 81
@


11.271
log
@ifdef'd out import_body and export_body
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.270 2002/02/05 03:14:19 jra Exp $ (BRL)";
d221 1
d3214 13
@


11.270
log
@eliminated attr_rm command (now a subcommand of "attr")
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.269 2002/01/22 19:01:50 jra Exp $ (BRL)";
d168 1
d171 1
@


11.269
log
@Added bot_decimate command (and support) to MGED
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.268 2001/12/13 19:37:28 jra Exp $ (BRL)";
a164 1
	{"attr_rm",	cmd_attr_rm},
a2281 11
}

int
cmd_attr_rm(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_attr_rm_cmd(wdbp, interp, argc, argv);
@


11.268
log
@Added bot_face_sort command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.267 2001/11/15 22:07:48 bparker Exp $ (BRL)";
d176 1
d3311 1
d3313 10
@


11.267
log
@*- changed the binary command to dbbinary in order
   to uncover Tcl's binary command.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.266 2001/11/09 20:40:03 bparker Exp $ (BRL)";
d173 1
d3302 9
@


11.266
log
@*- added get_autoview command. This command returns
   the view center and size necessary to see all geometry.
   Currently, only mouse_shoot_ray uses this.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.265 2001/10/17 07:40:04 morrison Exp $ (BRL)";
d171 1
a171 1
	{"binary", f_binary},
@


11.265
log
@Mac OS X warning and error fixes for non-production build
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.264 2001/10/05 21:19:55 bparker Exp $ (BRL)";
d236 1
@


11.264
log
@*- changed mged_default(db_nowarn) to mged_default(db_warn)
*- added mged_default(db_upgrade)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.263 2001/10/04 16:01:33 bparker Exp $ (BRL)";
d41 1
a41 1
#include "tk.h"
d43 1
a43 1
#include "tcl.h"
@


11.263
log
@*- changed create_db4 to db_version
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.262 2001/10/04 15:35:46 bparker Exp $ (BRL)";
d118 2
a119 1
extern int db_nowarn;	/* defined in ged.c */
d2061 4
a2064 2
	bu_vls_strcpy(&vls, "mged_default(db_nowarn)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&db_nowarn, TCL_LINK_INT);
@


11.262
log
@*- create two mged_default variables linked to C variables
	db_nowarn: 0 - warn
		   1 - no warn, prompt to convert
		   2 - no warn, convert database
	create_db4: 0 - create db 5
		    1 - create db 4
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.261 2001/09/19 22:20:35 bparker Exp $ (BRL)";
d119 1
a119 1
extern int create_db4;	/* defined in ged.c */
d2062 2
a2063 2
	bu_vls_strcpy(&vls, "mged_default(create_db4)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&create_db4, TCL_LINK_INT);
@


11.261
log
@*- add CHECK_DBI_NULL to numerous routines
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.260 2001/09/10 23:11:03 bparker Exp $ (BRL)";
d118 3
d2060 5
@


11.260
log
@*- disable vrmgr command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.259 2001/09/10 22:39:33 bparker Exp $ (BRL)";
d2255 2
d2266 2
d2277 2
d2288 2
d2299 2
d2310 2
d2321 2
d2332 2
d2343 2
d2354 2
d2365 2
d2856 1
a2856 1
	set_localunit_TclVar();
d3230 2
@


11.259
log
@*- add dbversion command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.258 2001/09/07 21:40:12 bparker Exp $ (BRL)";
d435 1
d437 1
@


11.258
log
@*- fixed bug in f_ps
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.257 2001/09/06 18:41:55 bparker Exp $ (BRL)";
d188 1
d2335 9
@


11.257
log
@*- mods to cmd_mged_glob
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.256 2001/08/02 17:38:43 jra Exp $ (BRL)";
d1897 4
a1900 4
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char *argv[];
d1907 1
a1907 1
	if(argc < 2){
a1922 2
	view_state = dml->dml_view_state;  /* use dml's state info */
	*mged_variables = *dml->dml_mged_variables; /* struct copy */
@


11.256
log
@Added "binary" command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.255 2001/06/25 21:26:54 bparker Exp $ (BRL)";
d1072 1
a1072 1
	if(argc != 2){
d1085 1
a1085 1
	mged_compat(&dest, &src, 1);
@


11.255
log
@*- modified cmd_blast to call MGED's cmd_zap
   instead of LIBRT's dgo_zap_cmd
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.254 2001/06/18 19:22:56 bparker Exp $ (BRL)";
d102 1
d167 1
d578 1
a578 1
}    
@


11.254
log
@*- clean up
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.253 2001/06/13 20:28:52 jra Exp $ (BRL)";
d3155 4
d3160 2
a3161 1
	dgo_zap_cmd(dgop, interp);
@


11.253
log
@Added attr_rm command
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.252 2001/06/06 16:46:08 bparker Exp $ (BRL)";
a503 93
#if 0
/*
 *	T C L _ A P P I N I T
 *
 *	Called by the Tcl/Tk libraries for initialization.
 *	Unncessary in our case; cmd_setup does all the work.
 */


int
Tcl_AppInit(interp)
	Tcl_Interp *interp;		/* Interpreter for application. */
{
	return TCL_OK;
}

/*			C M D _ W R A P P E R
 *
 * Translates between MGED's "CMD_OK/BAD/MORE" result codes to ones that
 * Tcl can understand.
 */

int
cmd_wrapper(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
{
	int status;
	size_t len;
	struct bu_vls result;
	int catch_output;

	argv[0] = ((struct funtab *)clientData)->ft_name;

	/* We now leave the world of Tcl where everything prints its results
	   in the interp->result field.  Here, stuff gets printed with the
	   bu_log command; hence, we must catch such output and stuff it into
	   the result string.  Do this *only* if "output_as_return" global
	   variable is set.  Make a local copy of this variable in case it's
	   changed by our command. */

	catch_output = output_as_return;
    
	bu_vls_init(&result);

	if (catch_output)
		start_catching_output(&result);
	status = mged_cmd(argc, argv, funtab);
	if (catch_output)
		stop_catching_output(&result);

	/* Remove any trailing newlines. */

	if (catch_output) {
		len = bu_vls_strlen(&result);
		while (len > 0 && bu_vls_addr(&result)[len-1] == '\n')
			bu_vls_trunc(&result, --len);
	}
    
	switch (status) {
	case CMD_OK:
		if (catch_output)
			Tcl_SetResult(interp, bu_vls_addr(&result), TCL_VOLATILE);
		status = TCL_OK;
		break;
	case CMD_BAD:
		if (catch_output)
			Tcl_SetResult(interp, bu_vls_addr(&result), TCL_VOLATILE);
		status = TCL_ERROR;
		break;
	case CMD_MORE:
		Tcl_SetResult(interp, MORE_ARGS_STR, TCL_STATIC);
		if (catch_output) {
			Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
		}
		status = TCL_ERROR;
		break;
	default:
		Tcl_SetResult(interp, "error executing mged routine::", TCL_STATIC);
		if (catch_output) {
			Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
		}
		status = TCL_ERROR;
		break;
	}
    
	bu_vls_free(&result);
	return status;
}
#endif

d611 1
a611 1
    
@


11.252
log
@*- add wdb_lt_cmd (i.e. lt command which
   returns a tcl list of {op obj} pairs)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.251 2001/06/05 15:51:41 bparker Exp $ (BRL)";
d160 1
d2355 9
@


11.251
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.250 2001/06/01 19:23:23 bparker Exp $ (BRL)";
d258 1
d3189 15
@


11.250
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.249 2001/05/04 14:43:27 bparker Exp $ (BRL)";
a114 1
#ifdef MGED_USE_VIEW_OBJ
a115 1
#endif
d149 1
a149 1
	{"ae", f_aetview},
d171 1
a171 1
	{"center", f_center},
d321 1
a321 1
	{"pov", f_pov},
d388 1
a388 1
	{"size", f_size},
d423 1
a423 1
	{"viewsize", f_size},		/* alias "size" for saveview scripts */
a809 1
#if 1
a812 1
#ifdef MGED_USE_VIEW_OBJ
a819 2
#endif
#endif
a2908 1
#ifdef MGED_USE_VIEW_OBJ
a2912 1
#endif
d3151 1
a3151 2
	if ((argc == 1 || argc == 2 && recurse) && illump != SOLID_NULL) {
		register int	i;
d3162 1
a3162 1
			int i;
a3306 1
#ifdef MGED_USE_VIEW_OBJ
a3307 3
#else
			vrp->vr_scale = view_state->vs_Viewscale;
#endif
@


11.249
log
@*- fix minor stuff
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.248 2001/05/04 14:20:46 bparker Exp $ (BRL)";
d115 4
d157 1
a157 1
	{"arot", f_arot},
d162 2
a163 2
	{"autoview", f_autoview},
	{"B", f_blast},
d182 2
a183 2
	{"d", f_erase},
	{"dall", f_erase_all},
d199 1
a199 1
	{"draw", f_edit},
d202 1
a202 1
	{"E", f_evedit},
d204 1
a204 1
	{"e", f_edit},
d212 2
a213 2
	{"erase", f_erase},
	{"erase_all", f_erase_all},
d215 1
a215 1
	{"ev", f_ev},
d221 1
a221 1
	{"eye_pt", f_eye_pt},
d228 1
a228 1
	{"g", f_group},
d245 1
a245 1
	{"i", f_instance},
d253 1
a253 1
	{"keep", f_keep},
d255 3
a257 3
	{"kill", f_kill},
	{"killall", f_killall},
	{"killtree", f_killtree},
d267 1
a267 1
	{"lookat", f_lookat},
d290 1
a290 1
	{"mrot", f_mrot},
d305 1
a305 1
	{"orientation", f_orientation},
d309 1
a309 1
	{"overlay", f_overlay},
d355 1
d363 1
a363 1
	{"rot", f_rot},
d367 4
a370 3
	{"rt", f_rt},
	{"rt_abort", cmd_rt_abort},
	{"rtcheck", f_rtcheck},
d378 1
a378 1
	{"sca", f_sca},
d384 1
a384 1
	{"setview", f_setview},
d391 1
d407 1
a407 1
	{"tol", f_tol},
d410 1
a410 1
	{"tra", f_tra},
d421 1
d424 1
d433 1
a433 1
	{"vrot", f_vrot},
d445 1
a445 1
	{"x", f_debug},
d447 2
a448 2
	{"Z", f_zap},
	{"zoom", f_zoom},
d807 1
a807 1
	/* Initialize librt */
d812 15
d2460 1
a2460 1
	return f_edit(clientData, interp, 2, av);
d2476 1
d2517 1
d2522 1
d2526 1
d2528 1
a2544 1
	CHECK_READ_ONLY;
a2582 1
	CHECK_READ_ONLY;
a2594 1
	CHECK_READ_ONLY;
a2606 1
	CHECK_READ_ONLY;
a2658 1
	CHECK_READ_ONLY;
d2745 1
d2750 1
d2759 1
d2761 1
a2777 1
	CHECK_READ_ONLY;
d2901 1
d2915 7
d2968 1
d2973 1
d2977 1
d2979 1
d3045 1
a3045 1
	return f_edit(clientData, interp, 2, av);
d3097 231
@


11.248
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.247 2001/05/03 17:01:47 bparker Exp $ (BRL)";
d105 2
d1739 1
a1739 1
wdb_summary(clientData, interp, argc, argv )
d2319 1
a2319 1
static int
d2328 1
a2328 1
static int
d2337 1
a2337 1
static int
d2346 1
a2346 1
static int
d2355 1
a2355 1
static int
d2364 1
a2364 1
static int
d2373 1
a2373 1
static int
d2382 1
a2382 1
static int
d2391 1
a2391 1
static int
@


11.247
log
@*- add the following commands to MGED:
     adjust, attr, dbip, dump, form, get, match, put
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.246 2001/04/12 14:55:29 bparker Exp $ (BRL)";
d165 2
a166 2
	{"c", f_comb_std},
	{"cat", f_cat},
d169 2
a170 2
	{"color", f_color},
	{"comb", f_comb},
d172 1
a172 1
	{"copyeval", f_copyeval},
d174 1
a174 1
	{"cp", f_copy},
d179 2
a180 2
	{"dbconcat", f_concat},
	{"dbfind", f_find},
d194 1
a194 1
	{"dup", f_dup},
d236 1
a236 1
	{"hide", f_hide },
d257 1
a257 1
	{"listeval", f_pathsum},
d262 1
a262 1
	{"ls", dir_print},
d265 2
a266 2
	{"make_bb", f_make_bb},
	{"make_name", f_make_name},
d285 2
a286 2
	{"mv", f_name},
	{"mvall", f_mvall},
d288 2
a289 2
	{"nmg_collapse", f_edge_collapse},
	{"nmg_simplify", f_nmg_simplify},
d312 1
a312 1
	{"paths", f_pathsum},
d318 1
a318 1
	{"prcolor", f_prcolor},
d323 1
a323 1
	{"push", f_push},
d334 1
a334 1
	{"r", f_region},
d353 1
a353 1
	{"rm", f_rm},
d363 1
d379 2
a380 2
	{"shells", f_shells},
	{"showmats", f_showmats},
d389 1
a389 1
	{"summary", f_summary},
d394 1
a394 1
	{"t", dir_print},
d397 1
a397 1
	{"title", f_title},
d400 1
a400 1
	{"tops", f_tops},
d404 1
a404 1
	{"tree", f_tree},
d406 2
a407 2
	{"unhide", f_unhide},
	{"units", f_units},
d427 3
a429 3
	{"whatid", f_whatid},
	{"whichair", f_which},
	{"whichid", f_which},
d435 1
a435 1
	{"xpush", f_xpush},
d1737 1
a1737 1
f_summary(clientData, interp, argc, argv )
d1743 1
a1743 6
	register char *cp;
	int flags = 0;
	int bad;

	if(argc < 1 || 2 < argc){
		struct bu_vls vls;
d1745 1
a1745 32
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help summary");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bad = 0;
	if( argc <= 1 )  {
		dir_summary(0);
		return TCL_OK;
	}
	cp = argv[1];
	while( *cp )  switch( *cp++ )  {
	case 's':
		flags |= DIR_SOLID;
		break;
	case 'r':
		flags |= DIR_REGION;
		break;
	case 'g':
		flags |= DIR_COMB;
		break;
	default:
		Tcl_AppendResult(interp, "summary:  S R or G are only valid parmaters\n",
				 (char *)NULL);
		bad = 1;
		break;
	}

	dir_summary(flags);
	return bad ? TCL_ERROR : TCL_OK;
d2387 669
@


11.246
log
@*- call Bu_Init() instead of bu_tcl_setup()
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.245 2001/04/02 21:20:40 bparker Exp $ (BRL)";
d144 1
d155 1
d181 2
d219 1
d223 1
d267 1
d324 1
d2351 72
@


11.245
log
@*- remove Tk dependencies
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.244 2001/04/02 20:07:16 jra Exp $ (BRL)";
d873 1
a873 1
	bu_tcl_setup( interp );
@


11.244
log
@Added "hide" and "unhide" comands
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.243 2001/03/23 22:05:32 jra Exp $ (BRL)";
d40 3
d44 3
a46 1
#include "tk.h"
a47 1
/* #include "tclIntDecls.h" */
d120 2
d123 1
d151 1
d153 1
d186 1
d188 1
d191 1
d193 1
d204 1
d206 1
d252 1
d254 1
d264 1
d267 1
d270 1
d273 1
d288 1
d290 1
d333 1
d335 1
d877 1
d879 1
d1365 1
d1374 1
@


11.243
log
@Support for major and minor types in directory structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/cmd.c,v 11.242 2001/03/20 21:48:20 pjt Exp $ (BRL)";
d96 1
d215 1
d372 1
@


11.242
log
@renamed bodyread and bodywrite to import_body and export_body
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/cmd.c,v 11.241 2001/02/21 18:31:27 bparker Exp $ (BRL)";
d2170 1
a2170 1
	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
d2226 1
a2226 1
	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
d2283 1
a2283 1
	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
@


11.241
log
@*- mods to mged/cmd.c/gui_output() to save and restore the result string
   before and after, respectively, the call to Tcl_Eval()
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.240 2001/01/04 17:02:21 bparker Exp $ (BRL)";
d147 2
a148 2
	{"bodyread", cmd_bodyread},
	{"bodywrite", cmd_bodywrite},
@


11.240
log
@Changed autosize to autoview.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.239 2001/01/03 21:30:00 bparker Exp $ (BRL)";
d563 1
d577 2
d582 2
@


11.239
log
@New command (autosize) for setting the view size
and center such that all displayed solids are in view.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.238 2000/12/22 00:32:47 bparker Exp $ (BRL)";
d144 1
a144 1
	{"autosize", f_autosize},
@


11.238
log
@Mods for new command mged_wait.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.237 2000/12/15 21:29:20 bparker Exp $ (BRL)";
d144 1
@


11.237
log
@Change find to dbfind.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.236 2000/11/16 21:20:29 bparker Exp $ (BRL)";
d245 1
a2058 33
}

void
mged_update(non_blocking)
int non_blocking;
{
  if(non_blocking >= 0)
    event_check(non_blocking);
  refresh();
}

int
f_update(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int     argc;
	char    **argv;
{
	int non_blocking;

	if(argc != 2 || sscanf(argv[1], "%d", &non_blocking) != 1){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel mged_update");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	mged_update(non_blocking);

	return TCL_OK;
@


11.236
log
@Add rt_abort command that aborts all
rt processes forked by MGED.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.235 2000/10/24 19:05:05 mike Exp $ (BRL)";
d167 1
a197 1
	{"find", f_find},
@


11.235
log
@
Fixed compiler lint, function declarations.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.234 2000/10/24 14:46:22 mike Exp $ (BRL)";
d324 1
@


11.234
log
@
BoT routines have rt_bot prefix
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.233 2000/09/08 14:39:54 bparker Exp $ (BRL)";
d40 1
d42 2
d46 1
d49 2
a51 2
#include "rtgeom.h"
#include "externs.h"
@


11.233
log
@Add command to test mged_bomb_hook.
Call initialization routines for libbu, libbn and librt.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.232 2000/09/08 05:55:48 mike Exp $ (BRL)";
d1567 1
d2189 1
a2189 1
	(void) bot_face_fuse( bot );
d2243 1
a2243 1
	count1 = bot_vertex_fuse( bot );
d2245 1
a2245 1
		(void)bot_condense( bot );
d2300 1
a2300 1
	count2 = bot_condense( bot );
@


11.232
log
@
Tree routines now need resource structure.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.231 2000/09/07 02:43:20 mike Exp $ (BRL)";
d118 4
d123 3
d741 11
d2316 15
@


11.231
log
@
More externs to ged.h to silence lint
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.230 2000/08/20 01:14:29 jra Exp $ (BRL)";
d2155 1
a2155 1
	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity ) < 0 )
d2178 1
a2178 1
	if( rt_db_put_internal( new_dp, dbip, &intern ) < 0 )
d2180 1
a2180 1
		rt_db_free_internal( &intern );
d2209 1
a2209 1
	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity ) < 0 )
d2234 1
a2234 1
	if( rt_db_put_internal( new_dp, dbip, &intern ) < 0 )
d2236 1
a2236 1
		rt_db_free_internal( &intern );
d2266 1
a2266 1
	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity ) < 0 )
d2291 1
a2291 1
	if( rt_db_put_internal( new_dp, dbip, &intern ) < 0 )
d2293 1
a2293 1
		rt_db_free_internal( &intern );
@


11.230
log
@sync() is usually declared in unistd.h (added protection to avoid redeclaration)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.229 2000/08/19 03:10:12 mike Exp $ (BRL)";
d1247 1
a1247 3
cmdline(vp, record)
	struct bu_vls *vp;
	int record;
d1374 1
a1374 2
mged_print_result(status)
	int status;
d1428 4
a1431 4
mged_cmd(argc, argv, in_functions)
	int argc;
	char **argv;
	struct funtab in_functions[];
d1528 5
a1532 5
f_quit(clientData, interp, argc, argv )
	ClientData clientData;
	Tcl_Interp *interp;
	int	argc;
	char	**argv;
@


11.229
log
@
Reduced use of MAXARGS
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.228 2000/08/17 18:11:59 bparker Exp $ (BRL)";
d93 1
d95 1
@


11.228
log
@Move vector counting code to LIBDM
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.227 2000/08/17 01:26:43 mike Exp $ (BRL)";
d822 1
d1728 1
a1728 1
	if(argc < 1 || MAXARGS < argc){
d1941 1
a1941 1
	if(argc < 2 || MAXARGS < argc){
d1997 1
a1997 1
	if(argc < 2 || MAXARGS < argc){
@


11.227
log
@
Added "viewsize" as alias for "size", so that
anim scripts can (finally) be cut'n'pasted.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.226 2000/08/09 20:43:23 bparker Exp $ (BRL)";
a98 2
extern int vectorThreshold;

a810 3
	bu_vls_strcpy(&temp, "mged_default(vectorThreshold)");
	Tcl_LinkVar(interp, bu_vls_addr(&temp), (char *)&vectorThreshold,
		    TCL_LINK_INT);
@


11.226
log
@Link the "C" variable vectorThreshold to
mged_default(vectorThreshold).
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.225 2000/07/05 22:23:45 mike Exp $ (BRL)";
d363 1
@


11.225
log
@
extern for slicemode has been removed too
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.224 2000/07/05 20:50:50 mike Exp $ (BRL)";
d99 1
d812 3
@


11.224
log
@
Added direct access to all the commands formerly only seen on
the "press" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.223 2000/06/30 20:10:22 pjt Exp $ (BRL)";
a79 1
int bv_slicemode(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
@


11.223
log
@Added cmd_bodyread and cmd_bodywrite
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.222 2000/06/07 19:28:08 bparker Exp $ (BRL)";
d56 33
d119 80
a198 75
	"%", f_comm,
	"3ptarb", f_3ptarb,
	"adc", f_adc,
	"ae", f_aetview,
	"aip", f_aip,
	"analyze", f_analyze,
	"arb", f_arbdef,
	"arced", f_arced,
	"area", f_area,
	"arot", f_arot,
	"attach", f_attach,
	"B", f_blast,
	"bev", f_bev,
	"bodyread", cmd_bodyread,
	"bodywrite", cmd_bodywrite,
	"bot_face_fuse", f_bot_face_fuse,
	"bot_vertex_fuse", f_bot_fuse,
	"bot_condense", f_bot_condense,
	"c", f_comb_std,
	"cat", f_cat,
	"center", f_center,
	"cmd_win", cmd_cmd_win,
	"color", f_color,
	"comb", f_comb,
	"comb_color", f_comb_color,
	"copyeval", f_copyeval,
	"copymat", f_copymat,
	"cp", f_copy,
	"cpi", f_copy_inv,
	"d", f_erase,
	"dall", f_erase_all,
	"db_glob", cmd_mged_glob,
	"dbconcat", f_concat,
	"debugbu", f_debugbu,
	"debugdir", f_debugdir,
	"debuglib", f_debuglib,
	"debugmem", f_debugmem,
	"debugnmg", f_debugnmg,
	"decompose", f_decompose,
	"delay", f_delay,
	"dm", f_dm,
	"draw", f_edit,
	"dup", f_dup,
	"E", f_evedit,
	"e", f_edit,
	"eac", f_eac,
	"echo", cmd_echo,
	"edcodes", f_edcodes,
	"edcolor", f_edcolor,
	"edcomb", f_edcomb,
	"edgedir", f_edgedir,
	"edmater", f_edmater,
	"erase", f_erase,
	"erase_all", f_erase_all,
	"ev", f_ev,
	"eqn", f_eqn,
	"exit", f_quit,
	"extrude", f_extrude,
	"expand", cmd_expand,
	"eye_pt", f_eye_pt,
	"e_muves", f_e_muves,
	"facedef", f_facedef,
	"facetize", f_facetize,
	"find", f_find,
	"fracture", f_fracture,
	"g", f_group,
	"get_comb", cmd_get_comb,
	"get_dbip", cmd_get_ptr,
	"get_dm_list", f_get_dm_list,
	"get_more_default", cmd_get_more_default,
	"get_sed", f_get_sedit,
	"get_sed_menus", f_get_sedit_menus,
	"get_solid_keypoint", f_get_solid_keypoint,
	"grid2model_lu", f_grid2model_lu,
	"grid2view_lu", f_grid2view_lu,
d200 1
a200 1
	"H", f_hideline,
d202 113
a314 96
	"history", f_history,
	"hist", cmd_hist,
	"i", f_instance,
	"idents", f_tables,
	"ill", f_ill,
	"in", f_in,
	"inside", f_inside,
	"item", f_itemair,
	"joint", f_joint,
	"journal", f_journal,
	"keep", f_keep,
	"keypoint", f_keypoint,
	"kill", f_kill,
	"killall", f_killall,
	"killtree", f_killtree,
	"knob", f_knob,
	"l", cmd_list,
	"l_muves", f_l_muves,
	"labelvert", f_labelvert,
	"listeval", f_pathsum,
	"loadtk", cmd_tk,
	"lookat", f_lookat,
	"ls", dir_print,
	"M", f_mouse,
	"make", f_make,
	"make_bb", f_make_bb,
	"make_name", f_make_name,
	"mater", f_mater,
	"matpick", f_matpick,
	"memprint", f_memprint,
	"mged_update", f_update,
	"mirface", f_mirface,
	"mirror", f_mirror,
	"mmenu_get", cmd_mmenu_get,
	"mmenu_set", cmd_nop,
	"model2grid_lu", f_model2grid_lu,
	"model2view", f_model2view,
	"model2view_lu", f_model2view_lu,
	"mrot", f_mrot,
	"mv", f_name,
	"mvall", f_mvall,
	"nirt", f_nirt,
	"nmg_collapse", f_edge_collapse,
	"nmg_simplify", f_nmg_simplify,
	"oed", cmd_oed,
	"oed_apply", f_oedit_apply,
	"oed_reset", f_oedit_reset,
	"opendb", f_opendb,
	"orientation", f_orientation,
	"orot", f_rot_obj,
	"oscale", f_sc_obj,
	"output_hook", cmd_output_hook,
	"overlay", f_overlay,
	"p", f_param,
	"pathlist", cmd_pathlist,
	"paths", f_pathsum,
	"permute", f_permute,
	"plot", f_plot,
	"pl", f_pl,
	"polybinout", f_polybinout,
	"pov", f_pov,
	"prcolor", f_prcolor,
	"prefix", f_prefix,
	"press", f_press,
	"preview", f_preview,
	"ps", f_ps,
	"push", f_push,
	"put_comb", cmd_put_comb,
	"put_sed", f_put_sedit,
	"putmat", f_putmat,
	"q", f_quit,
	"qray", f_qray,
	"query_ray", f_nirt,
	"quit", f_quit,
	"qorot", f_qorot,
	"qvrot", f_qvrot,
	"r", f_region,
	"rcodes", f_rcodes,
	"read_muves", f_read_muves,
	"red", f_red,
	"redraw_vlist", cmd_redraw_vlist,
	"refresh", f_refresh,
	"regdebug", f_regdebug,
	"regdef", f_regdef,
	"regions", f_tables,
	"release", f_release,
	"rfarb", f_rfarb,
	"rm", f_rm,
	"rmater", f_rmater,
	"rmats", f_rmats,
	"rot", f_rot,
	"rotobj", f_rot_obj,
	"rrt", f_rrt,
	"rset", f_rset,
	"rt", f_rt,
	"rtcheck", f_rtcheck,
d316 1
a316 1
	"savedit", f_savedit,
d318 53
a370 47
	"savekey", f_savekey,
	"saveview", f_saveview,
	"sca", f_sca,
	"sed", f_sed,
	"sed_apply", f_sedit_apply,
	"sed_reset", f_sedit_reset,
	"set_more_default", cmd_set_more_default,
	"setview", f_setview,
	"shader", f_shader,
	"share", f_share,
	"shells", f_shells,
	"showmats", f_showmats,
	"size", f_size,
	"solids", f_tables,
	"solids_on_ray", cmd_solids_on_ray,
	"status", f_status,
	"stuff_str", cmd_stuff_str,
	"summary", f_summary,
	"sv", f_slewview,
	"svb", f_svbase,
	"sync", f_sync,
	"t", dir_print,
	"ted", f_tedit,
	"tie", f_tie,
	"title", f_title,
	"tol", f_tol,
	"tops", f_tops,
	"tra", f_tra,
	"track", f_amtrack,
	"translate", f_tr_obj,
	"tree", f_tree,
	"t_muves", f_t_muves,
	"units", f_units,
	"vars", f_set,
	"vdraw", cmd_vdraw,
	"view", f_view,
	"view_ring", f_view_ring,
	"viewget", cmd_viewget,
	"viewset", cmd_viewset,
	"view2grid_lu", f_view2grid_lu,
	"view2model", f_view2model,
	"view2model_vec", f_view2model_vec,
	"view2model_lu", f_view2model_lu,
	"vnirt", f_vnirt,
	"vquery_ray", f_vnirt,
	"vrmgr", f_vrmgr,
	"vrot", f_vrot,
d372 1
a372 1
	"vrot_center", f_vrot_center,
d374 15
a388 13
	"wcodes", f_wcodes,
	"whatid", f_whatid,
	"whichair", f_which,
	"whichid", f_which,
	"which_shader", f_which_shader,
	"who", cmd_who,
	"winset", f_winset,
	"wmater", f_wmater,
	"x", f_debug,
	"xpush", f_xpush,
	"Z", f_zap,
	"zoom", f_zoom,
	0, 0
a1662 26
}

/* Hook for displays with no buttons */
int
f_press(clientData, interp, argc, argv )
	ClientData clientData;
	Tcl_Interp *interp;
	int	argc;
	char	**argv;
{
	register int i;

	if(argc < 2 || MAXARGS < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help press");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( i = 1; i < argc; i++ )
		press( argv[i] );

	return TCL_OK;
@


11.222
log
@Source in tclscripts/mged/tree.tcl. This proc
wraps MGED's tree command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.221 2000/06/05 21:53:05 bparker Exp $ (BRL)";
d99 2
@


11.222.2.1
log
@protected declaration of sync() (normally declared in unistd.h)
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.222 2000/06/07 19:28:08 bparker Exp $ (BRL)";
a60 1
#if !defined( HAVE_UNISTD_H )
a61 1
#endif
@


11.222.2.2
log
@Add rt_abort command that will abort
any raytrace initiated from MGED.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.222.2.1 2000/08/18 13:52:13 jra Exp $ (BRL)";
a258 1
	"rt_abort", cmd_rt_abort,
@


11.222.2.3
log
@Change find to dbfind.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.222.2.2 2000/11/15 21:31:20 bparker Exp $ (BRL)";
a118 1
	"dbfind", f_find,
d149 1
@


11.222.2.4
log
@New command: mged_wait, like tkwait but refreshes
the geometry windows.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.222.2.3 2000/12/15 21:26:09 bparker Exp $ (BRL)";
a194 1
	"mged_wait", f_wait,
d1999 33
@


11.222.2.5
log
@New command (autosize) for setting the view size
and center such that all displayed solids are in view.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.222.2.4 2000/12/21 23:37:19 bparker Exp $ (BRL)";
a98 1
	"autosize", f_autosize,
@


11.222.2.6
log
@Change autosize to autoview.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.222.2.5 2001/01/03 21:09:14 bparker Exp $ (BRL)";
d99 1
a99 1
	"autoview", f_autoview,
@


11.222.2.7
log
@*- mods to gui_output to save and restore
   the result string before and after, respectively,
   the call to Tcl_Eval
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.222.2.6 2001/01/04 17:00:28 bparker Exp $ (BRL)";
a487 1
	Tcl_Obj *save_result;
a500 2
	save_result = Tcl_GetObjResult(interp);
	Tcl_IncrRefCount(save_result);
a503 2
	Tcl_SetObjResult(interp, save_result);
	Tcl_DecrRefCount(save_result);
@


11.221
log
@*- added new routines
*- a few routines changed names
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.220 2000/06/02 20:21:11 bparker Exp $ (BRL)";
d725 14
@


11.220
log
@New command(f_sedit_apply) to push solid edits
  to the database while remaining in solid edit state.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.219 2000/04/20 21:21:13 bparker Exp $ (BRL)";
a59 1
int get_solid_keypoint_tcl();
a63 1
extern int get_edit_solid_menus();		/* in edsol.c */
a91 1
	"apply_edit_solid", f_sedit_apply,
d151 1
a152 1
	"get_edit_solid", f_get_edit_solid,
d154 3
a156 1
	"get_solid_keypoint", get_solid_keypoint_tcl,
d207 2
d230 1
a230 1
	"put_edit_solid", f_put_edit_solid,
a247 2
	"reset_edit_matrix", f_reset_edit_matrix,
	"reset_edit_solid", f_reset_edit_solid,
d265 2
d630 1
a630 1
	sprintf( buf, "%ld", (long)(*((void **)clientData)) );
a725 5

	(void)Tcl_CreateCommand(interp, "get_dbip", cmd_get_ptr,
				(ClientData)&dbip, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "get_edit_solid_menus", get_edit_solid_menus,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
@


11.219
log
@*- call Rt_Init instead of rt_tcl_setup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.218 2000/04/12 22:42:40 bparker Exp $ (BRL)";
d94 1
@


11.218
log
@*- add to auto_path
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.217 1999/12/30 19:22:37 jra Exp $ (BRL)";
d740 1
a740 1
	rt_tcl_setup( interp );
@


11.217
log
@Eliminated some unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.216 1999/12/29 23:23:18 mike Exp $ (BRL)";
d677 3
a679 2
                             %stclscripts/mged %stclscripts]",
		      filename, filename);
@


11.216
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.215 1999/12/21 13:54:13 jra Exp $ (BRL)";
a641 1
	register int i, n;
a1483 1
	register int i;
a1760 1
	struct cmd_list *save_cclp;
a1884 1
	int i;
a1940 1
	int i;
@


11.215
log
@Eliminated unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.214 1999/12/20 19:59:13 jra Exp $ (BRL)";
d2127 1
a2127 1
	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID)) == DIR_NULL )
d2183 1
a2183 1
	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID)) == DIR_NULL )
d2240 1
a2240 1
	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID)) == DIR_NULL )
@


11.214
log
@Added commands bot_vertex_fuse, bot_face_fuse, and bot_condense
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.213 1999/10/27 17:38:52 bparker Exp $ (BRL)";
a2097 1
	int count1=0;
d2125 1
a2125 1
	count1 = bot_face_fuse( bot );
d2151 1
a2151 1
	int count1=0, count2=0;
d2181 1
a2181 1
		count2 = bot_condense( bot );
@


11.213
log
@*- cleanup
*- it's not necessary to place the iwidgets
   path in auto_path
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.212 1999/10/26 18:54:58 bparker Exp $ (BRL)";
d59 2
d68 1
d101 3
d156 1
d2086 167
@


11.212
log
@*- OOPS! removing the extra /
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.211 1999/10/26 17:33:43 bparker Exp $ (BRL)";
a650 1
#if 1
a654 4
#if 0
	Tcl_StaticPackage(interp, "Itcl", Itcl_Init, Itcl_SafeInit);
#endif

a655 1
	/* Then cause the autoloader to do the same. */
a659 4
	if (Tcl_Eval(interp, "auto_mkindex_parser::slavehook { _%@@namespace import -force ::itcl::* }") != TCL_OK)
	  bu_log("auto_mkindex_parser error %s\n", interp->result);
#endif

d671 2
a672 2
                             %stclscripts/mged %stclscripts %slib/iwidgets/scripts]",
		      filename, filename, filename);
@


11.211
log
@*- turn on Itcl
*- hack to find the iwidgets
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.210 1999/10/22 21:39:35 bparker Exp $ (BRL)";
d681 1
a681 1
                             %stclscripts/mged %stclscripts %s/lib/iwidgets/scripts]",
@


11.210
log
@*- add code to initialize [incr Tcl]; for now leave turned off
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.209 1999/05/03 16:47:34 bparker Exp $ (BRL)";
d642 1
a642 1
	filename = bu_brlcad_path( "tclscripts" );
d651 1
a651 1
#if 0
d680 3
a682 2
	bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 %s/mged %s]",
		      filename, filename);
@


11.209
log
@*- mods to support f_reset_edit_matrix
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.208 1999/03/11 18:27:29 bparker Exp $ (BRL)";
d367 1
a382 1
#if 0
d650 19
@


11.208
log
@*- mods to mged_update(), if non_blocking is negative don't
	call event_check()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.207 1999/02/02 18:14:46 bparker Exp $ (BRL)";
d239 1
@


11.207
log
@*- whichair and whichid now use f_which
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.206 1999/01/27 20:33:54 bparker Exp $ (BRL)";
d1977 2
a1978 1
  event_check(non_blocking);
@


11.206
log
@*- collapse cmd_hist_add, cmd_prev and cmd_next into cmd_hist
*- add non_blocking parameter to mged_update()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.205 1999/01/26 19:02:18 bparker Exp $ (BRL)";
d303 2
a304 2
	"whichair", f_which_air,
	"whichid", f_which_id,
@


11.205
log
@*- replace cmd_close, cmd_init, cmd_get and cmd_set
	with cmd_cmd_win
*- mods to f_tie to return values as a Tcl list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.204 1999/01/25 18:17:20 bparker Exp $ (BRL)";
d156 1
a156 3
	"hist_prev", cmd_prev,
	"hist_next", cmd_next,
	"hist_add", cmd_hist_add,
d1974 2
a1975 1
mged_update()
d1977 1
a1977 1
  event_check(0);  /* blocking */
d1988 3
a1990 1
	if(argc < 1 || 1 < argc){
d2000 1
a2000 1
	mged_update();
@


11.204
log
@*- mods to insure that calls to Tcl_LinkVar are made with
   the variable name in "writable" space
*- mods to f_comm to disallow escaping to a shell from
	a Tcl/Tk command window.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.203 1999/01/21 18:28:04 bparker Exp $ (BRL)";
d101 1
a101 4
	"cmd_close", cmd_close,
	"cmd_get", cmd_get,
	"cmd_init", cmd_init,
	"cmd_set", cmd_set,
d731 1
a731 4

/* initialize a new command window */
int
cmd_init(clientData, interp, argc, argv)
d737 1
a737 2
	struct cmd_list *clp;
	int name_not_used = 1;
d739 1
a739 2
	if(argc != 2){
		struct bu_vls vls;
d741 2
a742 2
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel cmd_init");
d748 56
a803 5
	/* Search to see if there exists a command window with this name */
	for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
		if(!strcmp(argv[1], bu_vls_addr(&clp->cl_name))){
			name_not_used = 0;
			break;
d806 2
a807 10
	if(name_not_used){
		clp = (struct cmd_list *)bu_malloc(sizeof(struct cmd_list), "cmd_list");
		bzero((void *)clp, sizeof(struct cmd_list));
		BU_LIST_APPEND(&head_cmd_list.l, &clp->l);
		clp->cl_cur_hist = head_cmd_list.cl_cur_hist;
		bu_vls_init(&clp->cl_more_default);
		bu_vls_init(&clp->cl_name);
		bu_vls_strcpy(&clp->cl_name, argv[1]);
	}else{
		clp->cl_cur_hist = head_cmd_list.cl_cur_hist;
d809 2
a810 1
		if(clp->cl_tie != NULL){
d812 6
a817 2
			clp->cl_tie = DM_LIST_NULL;
		}
d820 5
a824 2
	return TCL_OK;
}
d826 2
a827 9
/* close a command window */
int
cmd_close(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
{
	struct cmd_list *clp;
d829 1
a829 2
	if(argc != 2){
		struct bu_vls vls;
a830 3
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel cmd_close");
		Tcl_Eval(interp, bu_vls_addr(&vls));
d832 1
a832 1
		return TCL_ERROR;
d835 12
a846 4
	/* First, search to see if there exists a command window with the name
	   in argv[1] */
	for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
		if(!strcmp(argv[1], bu_vls_addr(&clp->cl_name)))
d848 1
d850 6
a855 6
	if(clp == &head_cmd_list){
		if(!strcmp(argv[1], "mged"))
			Tcl_AppendResult(interp, "cmd_close: not allowed to close \"mged\"", (char *)NULL);
		else
			Tcl_AppendResult(interp, "cmd_close: did not find \"", argv[1], "\"", (char *)NULL);
		return TCL_ERROR;
d858 3
a860 2
	if(clp == curr_cmd_list)
		curr_cmd_list = &head_cmd_list;
d862 1
a862 8
	BU_LIST_DEQUEUE( &clp->l );
	if(clp->cl_tie != NULL)
		clp->cl_tie->dml_tie = CMD_LIST_NULL;
	bu_vls_free(&clp->cl_more_default);
	bu_vls_free(&clp->cl_name);
	bu_free((genptr_t)clp, "cmd_close: clp");

	return TCL_OK;
d865 1
a865 2
/* returns a list of ids associated with the current command window */
int
d873 1
d875 1
d885 3
d889 1
a889 3
		Tcl_AppendElement(interp, bu_vls_addr(&pathName));
		Tcl_AppendElement(interp, bu_vls_addr(&pathName));
		if(curr_dm_list->dml_tie)
d891 3
a893 1
		else
d895 8
a902 2

		return TCL_OK;
a904 5
	Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_tie->dml_dmp->dm_pathName));
	Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_tie->dml_dmp->dm_pathName));
	Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_name));
	bu_vls_init(&vls);

d912 5
a916 1
				bu_vls_printf(&vls, "{%S} ", &p->dml_tie->cl_name);
d921 1
d924 1
a924 33


/* given an id sets the current command window */
int
cmd_set(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
{
	if(argc != 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel cmd_set");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( BU_LIST_FOR(curr_cmd_list, cmd_list, &head_cmd_list.l) ){
		if(strcmp(bu_vls_addr(&curr_cmd_list->cl_name), argv[1]))
			continue;

		break;
	}

	if(curr_cmd_list->cl_tie)
		curr_dm_list = curr_cmd_list->cl_tie;

	bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);
	return TCL_OK;
}
d1729 2
a1730 3
 *	this window will be directed at a particular display manager. If a command window
 *	is not tied to a display manager window, the commands issued will be directed at
 *	the current display manager window.
d1749 3
a1751 1
	struct bu_vls vls2;
a1753 3
		struct bu_vls vls;

		bu_vls_init(&vls);
d1761 11
a1771 8
		for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
			if(clp->cl_tie)
				Tcl_AppendResult(interp, bu_vls_addr(&clp->cl_name), " ---> ",
						 bu_vls_addr(&clp->cl_tie->dml_dmp->dm_pathName),
						 "\n", (char *)NULL);
			else
				Tcl_AppendResult(interp, bu_vls_addr(&clp->cl_name), " ---> ",
						 "\n", (char *)NULL);
d1773 9
a1781 7
		if(clp->cl_tie)
			Tcl_AppendResult(interp, bu_vls_addr(&clp->cl_name), " ---> ",
					 bu_vls_addr(&clp->cl_tie->dml_dmp->dm_pathName),
					 "\n", (char *)NULL);
		else
			Tcl_AppendResult(interp, bu_vls_addr(&clp->cl_name), " ---> ",
					 "\n", (char *)NULL);
d1783 1
a1793 3
		struct bu_vls vls;

                bu_vls_init(&vls);
d1808 1
d1818 1
d1825 1
a1825 3
			Tcl_AppendResult(interp, bu_vls_addr(&clp->cl_name), " ---> ",
					 bu_vls_addr(&clp->cl_tie->dml_dmp->dm_pathName),
					 "\n", (char *)NULL);
d1827 1
a1827 1
			Tcl_AppendResult(interp, bu_vls_addr(&clp->cl_name), " ---> ", "\n", (char *)NULL);
d1829 1
a1832 2
	bu_vls_init(&vls2);

d1834 1
a1834 1
		bu_vls_printf(&vls2, ".%s", argv[2]);
d1836 1
a1836 1
		bu_vls_strcpy(&vls2, argv[2]);
d1839 1
a1839 1
		if(!strcmp(bu_vls_addr(&vls2), bu_vls_addr(&dlp->dml_dmp->dm_pathName)))
d1844 2
a1845 2
				 bu_vls_addr(&vls2), "\n", (char *)NULL);
		bu_vls_free(&vls2);
a1848 2
	bu_vls_free(&vls2);

d1861 1
a1861 4
	Tcl_AppendResult(interp, bu_vls_addr(&clp->cl_name), " ---> ",
			 bu_vls_addr(&clp->cl_tie->dml_dmp->dm_pathName),
			 "\n", (char *)NULL);

@


11.203
log
@*- call helpdevel for help on developer commands
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.202 1999/01/19 22:21:46 bparker Exp $ (BRL)";
d65 1
a710 1
	bu_vls_free(&temp);
d717 2
a718 1
	Tcl_LinkVar(interp, "glob_compat_mode", (char *)&glob_compat_mode,
d720 2
a721 1
	Tcl_LinkVar(interp, "output_as_return", (char *)&output_as_return,
d730 2
d1394 1
a1394 1
	if(argc < 0 || MAXARGS < argc){
d1398 1
a1398 1
		bu_vls_printf(&vls, "help ?");
d2044 1
a2044 1
	Tcl_LinkVar(interp, "mged_default(dlist)", (char *)&mged_default_dlist, TCL_LINK_INT);
d2046 9
a2054 3
	Tcl_LinkVar(interp, "edit_class", (char *)&es_edclass, TCL_LINK_INT);
	Tcl_LinkVar(interp, "edit_solid_flag", (char *)&es_edflag, TCL_LINK_INT);
	Tcl_LinkVar(interp, "edit_object_flag", (char *)&edobj, TCL_LINK_INT);
@


11.202
log
@*- mods to cmdtab array
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.201 1999/01/12 18:20:02 bparker Exp $ (BRL)";
d553 1
a553 1
		bu_vls_printf(&vls, "help output_hook");
d743 6
a748 1
		Tcl_AppendResult(interp, "Usage: cmd_init name", (char *)NULL);
d790 6
a795 1
		Tcl_AppendResult(interp, "Usage: cmd_close id", (char *)NULL);
d837 8
d886 6
a891 1
		Tcl_AppendResult(interp, "Usage: cmd_set id", (char *)NULL);
d917 6
a922 1
		Tcl_AppendResult(interp, "Usage: get_more_default", (char *)NULL);
d938 6
a943 1
		Tcl_AppendResult(interp, "Usage: set_more_default more_default", (char *)NULL);
d962 6
a967 1
		Tcl_AppendResult(interp, "cmd_mged_glob: There must be only one argument.", (char *)NULL);
d1739 1
a1739 1
		bu_vls_printf(&vls, "help tie");
d1981 1
a1981 1
		bu_vls_printf(&vls, "help mged_update");
d2005 1
a2005 1
		bu_vls_printf(&vls, "help winset");
d2040 1
a2040 1
	Tcl_LinkVar(interp, "mged_default_dlist", (char *)&mged_default_dlist, TCL_LINK_INT);
@


11.201
log
@*- added variable mged_default_dlist
*- some cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.200 1998/12/28 21:54:17 mike Exp $ (BRL)";
a153 1
	"output_hook", cmd_output_hook,
a182 1
	"mrot", f_mrot,
d189 1
d197 1
d208 1
d211 1
a212 1
	"pathlist", cmd_pathlist,
d220 1
a221 1
	"press", f_press,
d224 1
a225 1
	"put_comb", cmd_put_comb,
a259 1
	"showmats", f_showmats,
d266 1
a287 1
	"mged_update", f_update,
d302 1
d304 1
@


11.200
log
@Modified routine names to start with bu_log where appropriate.
Changed bu_add_hook() to bu_log_add_hook().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.199 1998/11/06 22:14:21 bparker Exp $ (BRL)";
a55 12
#if 0
extern float default_wireframe_color[];
extern int wireframe_highlight_color[];

#define DEFAULT_WIREFRAME_COLOR 1
#define WIREFRAME_HIGHLIGHT_COLOR 2

char *handle_global_variable_read_traces();
char *handle_global_variable_write_traces();
char *handle_global_variable_unset_traces();
#endif

d64 1
d2000 1
a2000 159
  struct bu_vls vls;

  bu_vls_init(&vls);

  Tcl_LinkVar(interp, "edit_class", (char *)&es_edclass, TCL_LINK_INT);
  Tcl_LinkVar(interp, "edit_solid_flag", (char *)&es_edflag, TCL_LINK_INT);
  Tcl_LinkVar(interp, "edit_object_flag", (char *)&edobj, TCL_LINK_INT);

  bu_vls_init(&edit_info_vls);
  bu_vls_strcpy(&edit_info_vls, "edit_info");

#if 0
  /* Set up variable traces */
  bu_vls_strcpy(&vls, "default_wireframe_color");
  Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_READS|TCL_GLOBAL_ONLY,
	       handle_global_variable_read_traces, (ClientData)DEFAULT_WIREFRAME_COLOR);
  Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_WRITES|TCL_GLOBAL_ONLY,
	       handle_global_variable_write_traces, (ClientData)DEFAULT_WIREFRAME_COLOR);
  Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_UNSETS|TCL_GLOBAL_ONLY,
	       handle_global_variable_unset_traces, (ClientData)DEFAULT_WIREFRAME_COLOR);

  bu_vls_strcpy(&vls, "wireframe_highlight_color");
  Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_READS|TCL_GLOBAL_ONLY,
	       handle_global_variable_read_traces, (ClientData)WIREFRAME_HIGHLIGHT_COLOR);
  Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_WRITES|TCL_GLOBAL_ONLY,
	       handle_global_variable_write_traces, (ClientData)WIREFRAME_HIGHLIGHT_COLOR);
  Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_UNSETS|TCL_GLOBAL_ONLY,
	       handle_global_variable_unset_traces, (ClientData)WIREFRAME_HIGHLIGHT_COLOR);
#endif

  bu_vls_free(&vls);
}

#if 0
char *
handle_global_variable_read_traces(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;
char *name1, *name2;
int flags;
{
  int global_var = (int)clientData;
  struct bu_vls vls;

  bu_vls_init(&vls);

  switch (global_var) {
  case DEFAULT_WIREFRAME_COLOR:
    bu_vls_printf(&vls, "%d %d %d",
		  (int)(default_wireframe_color[0] * 255.0),
		  (int)(default_wireframe_color[1] * 255.0),
		  (int)(default_wireframe_color[2] * 255.0));
    break;
  case WIREFRAME_HIGHLIGHT_COLOR:
    bu_vls_printf(&vls, "%d %d %d",
		  wireframe_highlight_color[0],
		  wireframe_highlight_color[1],
		  wireframe_highlight_color[2]);
    break;
  }

  (void)Tcl_SetVar2(interp, name1, name2, bu_vls_addr(&vls),
		    (flags&TCL_GLOBAL_ONLY)|TCL_LEAVE_ERR_MSG);

  bu_vls_free(&vls);
  return (char *)0;
}

char *
handle_global_variable_write_traces(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;
char *name1, *name2;
int flags;
{
  int global_var = (int)clientData;
  char *val;

  val = Tcl_GetVar2(interp, name1, name2,
		   (flags&TCL_GLOBAL_ONLY)|TCL_LEAVE_ERR_MSG);

  switch (global_var) {
  case DEFAULT_WIREFRAME_COLOR:
    {
      int r, g, b;

      if(sscanf(val, "%d %d %d", &r, &g, &b) != 3){
	return (char *)0;
      }

      /* check range and clamp if necessary */
      if(r < 0)
	r = 0;
      else if(r > 255)
	r = 255;
      
      if(g < 0)
	g = 0;
      else if(g > 255)
	g = 255;
      
      if(b < 0)
	b = 0;
      else if(b > 255)
	b = 255;

      default_wireframe_color[0] = r / 255.0;
      default_wireframe_color[1] = g / 255.0;
      default_wireframe_color[2] = b / 255.0;
    }

    break;
  case WIREFRAME_HIGHLIGHT_COLOR:
    {
      int r, g, b;

      if(sscanf(val, "%d %d %d", &r, &g, &b) != 3){
	return (char *)0;
      }

      /* check range and clamp if necessary */
      if(r < 0)
	r = 0;
      else if(r > 255)
	r = 255;
      
      if(g < 0)
	g = 0;
      else if(g > 255)
	g = 255;
      
      if(b < 0)
	b = 0;
      else if(b > 255)
	b = 255;
      
      wireframe_highlight_color[0] = r;
      wireframe_highlight_color[1] = g;
      wireframe_highlight_color[2] = b;
    }

    if(state != ST_VIEW)
      update_views = 1;

    break;
  }

  return (char *)0;
}

char *
handle_global_variable_unset_traces(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;
char *name1, *name2;
int flags;
{
  int global_var = (int)clientData;
  struct bu_vls vls;
d2002 3
a2004 1
  bu_vls_init(&vls);
d2006 2
a2007 28
  switch (global_var) {
  case DEFAULT_WIREFRAME_COLOR:
    /* reset traces */
    bu_vls_strcpy(&vls, "default_wireframe_color");
    Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_READS|TCL_GLOBAL_ONLY,
		 handle_global_variable_read_traces, (ClientData)DEFAULT_WIREFRAME_COLOR);
    Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_WRITES|TCL_GLOBAL_ONLY,
		 handle_global_variable_write_traces, (ClientData)DEFAULT_WIREFRAME_COLOR);
    Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_UNSETS|TCL_GLOBAL_ONLY,
		 handle_global_variable_unset_traces, (ClientData)DEFAULT_WIREFRAME_COLOR);

    break;
  case WIREFRAME_HIGHLIGHT_COLOR:
    /* reset traces */
    bu_vls_strcpy(&vls, "wireframe_highlight_color");
    Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_READS|TCL_GLOBAL_ONLY,
		 handle_global_variable_read_traces, (ClientData)WIREFRAME_HIGHLIGHT_COLOR);
    Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_WRITES|TCL_GLOBAL_ONLY,
		 handle_global_variable_write_traces, (ClientData)WIREFRAME_HIGHLIGHT_COLOR);
    Tcl_TraceVar(interp, bu_vls_addr(&vls), TCL_TRACE_UNSETS|TCL_GLOBAL_ONLY,
		 handle_global_variable_unset_traces, (ClientData)WIREFRAME_HIGHLIGHT_COLOR);

    break;
  }

  bu_vls_free(&vls);

  return (char *)0;
a2008 1
#endif
@


11.199
log
@*- remove commands
	add_view, aim, cs_def, cs_set, delete_view,
	get_rect, get_view, goto_view, L, R, next_view,
	prev_view, rset, set_rect, share_menu, share_vars,
	share_view, sliders, toggle_view, unaim, unshare_menu,
	unshare_vars, unshare_view
*- add commands
	share, rset, tie, view_ring
*- use new structures
*- cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.198 1998/10/21 17:17:19 bparker Exp $ (BRL)";
d363 1
a363 1
	bu_add_hook(output_catch, (genptr_t)vp);
d376 1
a376 1
	bu_delete_hook(output_catch, (genptr_t)vp);
d489 1
a489 1
		bu_delete_hook(gui_output, clientData);
d568 1
a568 1
	bu_delete_hook(gui_output, (genptr_t)interp);/* Delete the existing hook */
d596 1
a596 1
	bu_add_hook(gui_output, (genptr_t)interp);
@


11.198
log
@*- add cs_set and cs_def to the list of commands
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.197 1998/08/21 21:00:51 mike Exp $ (BRL)";
a71 1
extern void set_scroll();			/* in set.c */
a88 72
/*
 *			C M D _ L E F T _ M O U S E
 *
 *  Default old-MGED binding for left mouse button.
 */
int
cmd_left_mouse(clientData, interp, argc, argv)
	ClientData	clientData;
	Tcl_Interp	*interp;
	int		argc;
	char		*argv[];
{
	if(argc < 4 || 4 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help L");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if( atoi(argv[1]) != 0 ){
		int status;
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "zoom 0.5\n");
		status = Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return status;
	}

	return TCL_OK;
}

/*
 *			C M D _ R I G H T _ M O U S E
 *
 *  Default old-MGED binding for right mouse button.
 */
int
cmd_right_mouse(clientData, interp, argc, argv)
	ClientData	clientData;
	Tcl_Interp	*interp;
	int		argc;
	char		*argv[];
{
	if(argc < 4 || 4 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help R");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if( atoi(argv[1]) != 0 ){
		int status;
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "zoom 2.0\n");
		status = Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return status;
	}

	return TCL_OK;
}

a97 1
	"add_view", f_add_view,
a98 1
	"aim", f_aim,
a121 2
	"cs_def", f_cs_def,
	"cs_set", f_cs_set,
a132 1
	"delete_view", f_delete_view,
a140 1
	"edmater", f_edmater,
d144 1
a162 3
	"get_rect", f_get_rect, 
	"get_view", f_get_view,
	"goto_view", f_goto_view,
a188 1
	"L", cmd_left_mouse,
a210 1
	"next_view", f_next_view,
a229 1
	"prev_view", f_prev_view,
a243 1
	"R", cmd_right_mouse,
d261 1
a271 1
	"set_rect", f_set_rect,
d274 2
a276 4
	"shader", f_shader,
	"share_menu", f_share_menu,
	"share_vars", f_share_vars,
	"share_view", f_share_view,
a277 1
	"sliders", cmd_sliders,
d288 1
a289 1
	"toggle_view", f_toggle_view,
a296 1
	"unaim", f_unaim,
a297 3
	"unshare_menu", f_unshare_menu,
	"unshare_vars", f_unshare_vars,
	"unshare_view", f_unshare_view,
d302 1
a308 1
	"viewsize", f_size,
a671 137
#if 0
	/*XXX
	 * The variables below are no longer necessary. They were
	 * once used by Tcl/Tk sliders.
	 */
	bu_vls_init(&edit_rate_model_tran_vls[X]);
	bu_vls_init(&edit_rate_model_tran_vls[Y]);
	bu_vls_init(&edit_rate_model_tran_vls[Z]);
	bu_vls_init(&edit_rate_view_tran_vls[X]);
	bu_vls_init(&edit_rate_view_tran_vls[Y]);
	bu_vls_init(&edit_rate_view_tran_vls[Z]);
	bu_vls_init(&edit_rate_model_rotate_vls[X]);
	bu_vls_init(&edit_rate_model_rotate_vls[Y]);
	bu_vls_init(&edit_rate_model_rotate_vls[Z]);
	bu_vls_init(&edit_rate_object_rotate_vls[X]);
	bu_vls_init(&edit_rate_object_rotate_vls[Y]);
	bu_vls_init(&edit_rate_object_rotate_vls[Z]);
	bu_vls_init(&edit_rate_view_rotate_vls[X]);
	bu_vls_init(&edit_rate_view_rotate_vls[Y]);
	bu_vls_init(&edit_rate_view_rotate_vls[Z]);
	bu_vls_init(&edit_rate_scale_vls);
	bu_vls_init(&edit_absolute_model_tran_vls[X]);
	bu_vls_init(&edit_absolute_model_tran_vls[Y]);
	bu_vls_init(&edit_absolute_model_tran_vls[Z]);
	bu_vls_init(&edit_absolute_view_tran_vls[X]);
	bu_vls_init(&edit_absolute_view_tran_vls[Y]);
	bu_vls_init(&edit_absolute_view_tran_vls[Z]);
	bu_vls_init(&edit_absolute_model_rotate_vls[X]);
	bu_vls_init(&edit_absolute_model_rotate_vls[Y]);
	bu_vls_init(&edit_absolute_model_rotate_vls[Z]);
	bu_vls_init(&edit_absolute_object_rotate_vls[X]);
	bu_vls_init(&edit_absolute_object_rotate_vls[Y]);
	bu_vls_init(&edit_absolute_object_rotate_vls[Z]);
	bu_vls_init(&edit_absolute_view_rotate_vls[X]);
	bu_vls_init(&edit_absolute_view_rotate_vls[Y]);
	bu_vls_init(&edit_absolute_view_rotate_vls[Z]);
	bu_vls_init(&edit_absolute_scale_vls);

	bu_vls_strcpy(&edit_rate_model_tran_vls[X], "edit_rate_model_tran(X)");
	bu_vls_strcpy(&edit_rate_model_tran_vls[Y], "edit_rate_model_tran(Y)");
	bu_vls_strcpy(&edit_rate_model_tran_vls[Z], "edit_rate_model_tran(Z)");
	bu_vls_strcpy(&edit_rate_view_tran_vls[X], "edit_rate_view_tran(X)");
	bu_vls_strcpy(&edit_rate_view_tran_vls[Y], "edit_rate_view_tran(Y)");
	bu_vls_strcpy(&edit_rate_view_tran_vls[Z], "edit_rate_view_tran(Z)");
	bu_vls_strcpy(&edit_rate_model_rotate_vls[X], "edit_rate_model_rotate(X)");
	bu_vls_strcpy(&edit_rate_model_rotate_vls[Y], "edit_rate_model_rotate(Y)");
	bu_vls_strcpy(&edit_rate_model_rotate_vls[Z], "edit_rate_model_rotate(Z)");
	bu_vls_strcpy(&edit_rate_object_rotate_vls[X], "edit_rate_object_rotate(X)");
	bu_vls_strcpy(&edit_rate_object_rotate_vls[Y], "edit_rate_object_rotate(Y)");
	bu_vls_strcpy(&edit_rate_object_rotate_vls[Z], "edit_rate_object_rotate(Z)");
	bu_vls_strcpy(&edit_rate_view_rotate_vls[X], "edit_rate_view_rotate(X)");
	bu_vls_strcpy(&edit_rate_view_rotate_vls[Y], "edit_rate_view_rotate(Y)");
	bu_vls_strcpy(&edit_rate_view_rotate_vls[Z], "edit_rate_view_rotate(Z)");
	bu_vls_strcpy(&edit_rate_scale_vls, "edit_rate_scale");
	bu_vls_strcpy(&edit_absolute_model_tran_vls[X], "edit_abs_model_tran(X)");
	bu_vls_strcpy(&edit_absolute_model_tran_vls[Y], "edit_abs_model_tran(Y)");
	bu_vls_strcpy(&edit_absolute_model_tran_vls[Z], "edit_abs_model_tran(Z)");
	bu_vls_strcpy(&edit_absolute_view_tran_vls[X], "edit_abs_view_tran(X)");
	bu_vls_strcpy(&edit_absolute_view_tran_vls[Y], "edit_abs_view_tran(Y)");
	bu_vls_strcpy(&edit_absolute_view_tran_vls[Z], "edit_abs_view_tran(Z)");
	bu_vls_strcpy(&edit_absolute_model_rotate_vls[X], "edit_abs_model_rotate(X)");
	bu_vls_strcpy(&edit_absolute_model_rotate_vls[Y], "edit_abs_model_rotate(Y)");
	bu_vls_strcpy(&edit_absolute_model_rotate_vls[Z], "edit_abs_model_rotate(Z)");
	bu_vls_strcpy(&edit_absolute_object_rotate_vls[X], "edit_abs_object_rotate(X)");
	bu_vls_strcpy(&edit_absolute_object_rotate_vls[Y], "edit_abs_object_rotate(Y)");
	bu_vls_strcpy(&edit_absolute_object_rotate_vls[Z], "edit_abs_object_rotate(Z)");
	bu_vls_strcpy(&edit_absolute_view_rotate_vls[X], "edit_abs_view_rotate(X)");
	bu_vls_strcpy(&edit_absolute_view_rotate_vls[Y], "edit_abs_view_rotate(Y)");
	bu_vls_strcpy(&edit_absolute_view_rotate_vls[Z], "edit_abs_view_rotate(Z)");
	bu_vls_strcpy(&edit_absolute_scale_vls, "edit_abs_scale");

	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[X]),
		    (char *)&edit_rate_model_tran[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[Y]),
		    (char *)&edit_rate_model_tran[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[Z]),
		    (char *)&edit_rate_model_tran[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[X]),
		    (char *)&edit_rate_view_tran[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[Y]),
		    (char *)&edit_rate_view_tran[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[Z]),
		    (char *)&edit_rate_view_tran[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[X]),
		    (char *)&edit_rate_model_rotate[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[Y]),
		    (char *)&edit_rate_model_rotate[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[Z]),
		    (char *)&edit_rate_model_rotate[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[X]),
		    (char *)&edit_rate_object_rotate[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[Y]),
		    (char *)&edit_rate_object_rotate[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[Z]),
		    (char *)&edit_rate_object_rotate[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[X]),
		    (char *)&edit_rate_view_rotate[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[Y]),
		    (char *)&edit_rate_view_rotate[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[Z]),
		    (char *)&edit_rate_view_rotate[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_scale_vls),
		    (char *)&edit_rate_scale, TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[X]),
		    (char *)&edit_absolute_model_tran[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[Y]),
		    (char *)&edit_absolute_model_tran[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[Z]),
		    (char *)&edit_absolute_model_tran[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[X]),
		    (char *)&edit_absolute_view_tran[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[Y]),
		    (char *)&edit_absolute_view_tran[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[Z]),
		    (char *)&edit_absolute_view_tran[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_model_rotate_vls[X]),
		    (char *)&edit_absolute_model_rotate[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_model_rotate_vls[Y]),
		    (char *)&edit_absolute_model_rotate[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_model_rotate_vls[Z]),
		    (char *)&edit_absolute_model_rotate[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_object_rotate_vls[X]),
		    (char *)&edit_absolute_object_rotate[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_object_rotate_vls[Y]),
		    (char *)&edit_absolute_object_rotate[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_object_rotate_vls[Z]),
		    (char *)&edit_absolute_object_rotate[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_view_rotate_vls[X]),
		    (char *)&edit_absolute_view_rotate[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_view_rotate_vls[Y]),
		    (char *)&edit_absolute_view_rotate[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_view_rotate_vls[Z]),
		    (char *)&edit_absolute_view_rotate[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_scale_vls),
		    (char *)&edit_absolute_scale, TCL_LINK_DOUBLE);
#endif

d758 1
a758 1
		if(!strcmp(argv[1], bu_vls_addr(&clp->name))){
d767 4
a770 4
		clp->cur_hist = head_cmd_list.cur_hist;
		bu_vls_init(&clp->more_default);
		bu_vls_init(&clp->name);
		bu_vls_strcpy(&clp->name, argv[1]);
d772 1
a772 1
		clp->cur_hist = head_cmd_list.cur_hist;
d774 3
a776 3
		if(clp->aim != NULL){
			clp->aim->aim = CMD_LIST_NULL;
			clp->aim = DM_LIST_NULL;
d801 1
a801 1
		if(!strcmp(argv[1], bu_vls_addr(&clp->name)))
d816 4
a819 4
	if(clp->aim != NULL)
		clp->aim->aim = CMD_LIST_NULL;
	bu_vls_free(&clp->more_default);
	bu_vls_free(&clp->name);
d836 2
a837 1
	if(!curr_cmd_list->aim){
d839 2
a840 3
		Tcl_AppendElement(interp, bu_vls_addr(curr_dm_list->s_info->opp));
		if(curr_dm_list->aim)
			Tcl_AppendElement(interp, bu_vls_addr(&curr_dm_list->aim->name));
d842 1
a842 1
			Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->name));
d847 3
a849 3
	Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->aim->_dmp->dm_pathName));
	Tcl_AppendElement(interp, bu_vls_addr(curr_cmd_list->aim->s_info->opp));
	Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->name));
d856 1
a856 1
		if(curr_cmd_list->aim->s_info == p->s_info)
d858 2
a859 2
			if(p->aim)
				bu_vls_printf(&vls, "{%S} ", &p->aim->name);
d882 1
a882 1
		if(strcmp(bu_vls_addr(&curr_cmd_list->name), argv[1]))
d888 2
a889 2
	if(curr_cmd_list->aim)
		curr_dm_list = curr_cmd_list->aim;
d891 1
a891 1
	bu_vls_trunc(&curr_cmd_list->more_default, 0);
a901 2
	struct cmd_list *p;

d907 1
a907 1
	Tcl_AppendResult(interp, bu_vls_addr(&curr_cmd_list->more_default), (char *)NULL);
a917 2
	struct cmd_list *p;

d923 1
a923 1
	bu_vls_strcpy(&curr_cmd_list->more_default, argv[1]);
d1675 18
d1694 1
a1694 1
f_aim(clientData, interp, argc, argv)
d1700 1
a1703 1
	struct dm_list *save_cdlp;
d1710 1
a1710 1
		bu_vls_printf(&vls, "help aim");
d1718 3
a1720 3
			if(clp->aim)
				Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
						 bu_vls_addr(&clp->aim->_dmp->dm_pathName),
d1723 1
a1723 1
				Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
d1726 3
a1728 3
		if(clp->aim)
			Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
					 bu_vls_addr(&clp->aim->_dmp->dm_pathName),
d1731 1
a1731 1
			Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
d1737 16
d1754 1
a1754 1
		if(!strcmp(bu_vls_addr(&clp->name), argv[1]))
d1758 2
a1759 2
	   (strcmp(bu_vls_addr(&head_cmd_list.name), argv[1]))){
		Tcl_AppendResult(interp, "f_aim: unrecognized command_window - ", argv[1],
d1764 10
a1773 1
	/* print out the display manager being aimed at */
d1775 3
a1777 3
		if(clp->aim)
			Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
					 bu_vls_addr(&clp->aim->_dmp->dm_pathName),
d1780 1
a1780 1
			Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ", "\n", (char *)NULL);
d1793 1
a1793 1
		if(!strcmp(bu_vls_addr(&vls2), bu_vls_addr(&dlp->_dmp->dm_pathName)))
d1797 1
a1797 1
		Tcl_AppendResult(interp, "f_aim: unrecognized pathName - ",
d1805 3
a1807 11
	/* already aiming */
	if(clp->aim)
		clp->aim->aim = (struct cmd_list *)NULL;

	clp->aim = dlp;

	/* already being aimed at */
	if(dlp->aim)
		dlp->aim->aim = (struct dm_list *)NULL;

	dlp->aim = clp;
d1809 1
a1809 4
	save_cdlp = curr_dm_list;
	save_cclp = curr_cmd_list;
	curr_dm_list = dlp;
	curr_cmd_list = clp;
d1811 3
a1813 3
#ifdef DO_SCROLL_UPDATES
	set_scroll();
#endif
d1815 1
a1815 2
	curr_dm_list = save_cdlp;
	curr_cmd_list = save_cclp;
d1817 2
a1818 2
	Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
			 bu_vls_addr(&clp->aim->_dmp->dm_pathName),
a1824 38
f_unaim(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char *argv[];
{
	struct cmd_list *clp;

	if(argc != 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help unaim");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
		if(!strcmp(bu_vls_addr(&clp->name), argv[1]))
			break;

	if(clp == &head_cmd_list &&
	   (strcmp(bu_vls_addr(&head_cmd_list.name), argv[1]))){
		Tcl_AppendResult(interp, "f_unaim: unrecognized command_window - ", argv[1],
				 "\n", (char *)NULL);
		return TCL_ERROR;
	}

	if(clp->aim)
		clp->aim->aim = (struct cmd_list *)NULL;

	clp->aim = (struct dm_list *)NULL;

	return TCL_OK;
}

int
d1835 1
a1835 1
	struct shared_info *sip;
d1852 11
a1862 18
	sip = curr_dm_list->s_info;  /* save state info pointer */
	curr_dm_list->s_info = dml->s_info;  /* use dml's state info */
	*mged_variables = *dml->_mged_variables; /* struct copy */
#if 1
	bu_free((genptr_t)curr_dm_list->menu_vars,"f_ps: menu_vars");
	curr_dm_list->menu_vars = dml->menu_vars;
#else
	bcopy((void *)dml->_menu_array, (void *)menu_array,
	      sizeof(struct menu_item *) * NMENU);
	menuflag = dml->_menuflag;
	menu_top = dml->_menu_top;
	cur_menu = dml->_cur_menu;
	cur_item = dml->_cur_menu_item;
#endif
	scroll_top = dml->_scroll_top;
	scroll_active = dml->_scroll_active;
	scroll_y = dml->_scroll_y;
	bcopy((void *)dml->_scroll_array, (void *)scroll_array,
d1868 1
a1868 1
	curr_dm_list->s_info = sip;  /* restore state info pointer */
d1892 1
a1892 1
	struct shared_info *sip;
d1909 11
a1919 18
	sip = curr_dm_list->s_info;  /* save state info pointer */
	curr_dm_list->s_info = dml->s_info;  /* use dml's state info */
	*mged_variables = *dml->_mged_variables; /* struct copy */
#if 1
	bu_free((genptr_t)curr_dm_list->menu_vars,"f_pl: menu_vars");
	curr_dm_list->menu_vars = dml->menu_vars;
#else
	bcopy((void *)dml->_menu_array, (void *)menu_array,
	      sizeof(struct menu_item *) * NMENU);
	menuflag = dml->_menuflag;
	menu_top = dml->_menu_top;
	cur_menu = dml->_cur_menu;
	cur_item = dml->_cur_menu_item;
#endif
	scroll_top = dml->_scroll_top;
	scroll_active = dml->_scroll_active;
	scroll_y = dml->_scroll_y;
	bcopy( (void *)dml->_scroll_array, (void *)scroll_array,
d1925 1
a1925 1
	curr_dm_list->s_info = sip;  /* restore state info pointer */
d1990 1
a1990 1
		if( !strcmp( argv[1], bu_vls_addr( &p->_dmp->dm_pathName ) ) ){
d1993 2
a1994 2
			if(curr_dm_list->aim)
				curr_cmd_list = curr_dm_list->aim;
@


11.197
log
@Don't use compile-time hack, use new LIBBU routine bu_brlcad_path()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.196 1998/08/13 11:53:52 bparker Exp $ (BRL)";
d56 1
d63 4
a70 3
char *handle_global_variable_read_traces();
char *handle_global_variable_write_traces();
char *handle_global_variable_unset_traces();
d197 2
d2276 1
d2293 1
d2298 1
d2456 1
@


11.196
log
@*- mods to mged_setup(), cmd_setup() and cmdtab[]
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.195 1998/06/24 17:52:32 bparker Exp $ (BRL)";
d741 3
a896 5
#ifdef BRLCAD_TCL_LIBRARY
	filename = BRLCAD_TCL_LIBRARY;
#else
	filename = "/usr/brlcad/tclscripts";
#endif
@


11.195
log
@*- add support for new tcl variables:
	default_wireframe_color, wireframe_highlight_color
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/cmd.c,v 11.194 1998/06/08 20:51:07 bparker Exp $ (BRL)";
a62 2
int get_more_default();
int set_more_default();
a69 1
extern int cmd_get_comb(), cmd_put_comb();	/* in red.c */
d72 1
d74 1
a74 1
extern void init_qray();			/* in qray.c */
d184 4
d197 1
a197 1
/*	"db", cmd_db, */
d233 1
d235 2
d282 2
d314 2
d334 1
d352 2
a353 1
	"set_rect", f_set_rect, 
d365 1
d396 1
a750 5
	(void)Tcl_CreateCommand(interp, "mmenu_set", cmd_nop, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "mmenu_get", cmd_mmenu_get,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

d897 1
a897 1
	filename = "/vld/bparker/cad_dev/tclscripts";
d905 2
a906 1
	bu_vls_strcpy( &str, "mged_display(state)" );
d948 3
a950 1
	(void)Tcl_CreateCommand(interp, "db_glob", cmd_mged_glob,
a951 23
	(void)Tcl_CreateCommand(interp, "cmd_init", cmd_init, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "cmd_close", cmd_close, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "cmd_set", cmd_set, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "cmd_get", cmd_get, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "get_more_default", get_more_default, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "set_more_default", set_more_default, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "stuff_str", cmd_stuff_str, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "get_dbip", cmd_get_ptr, (ClientData)&dbip, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "get_comb", cmd_get_comb,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "put_comb", cmd_put_comb,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	/* A synonym, to allow cut-n-paste of rt animation scripts into mged */
	(void)Tcl_CreateCommand(interp, "viewsize", f_view, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
d1123 1
a1123 1
get_more_default(clientData, interp, argc, argv)
d1141 1
a1141 1
set_more_default(clientData, interp, argc, argv)
@


11.194
log
@*- mods to mged_update()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/cmd.c,v 11.193 1998/05/18 19:35:08 bparker Exp $ (BRL)";
d56 7
d67 4
d744 1
d749 5
a753 5
	Tcl_LinkVar(interp, "edit_class", (char *)&es_edclass, TCL_LINK_INT);
	Tcl_LinkVar(interp, "edit_solid_flag", (char *)&es_edflag, TCL_LINK_INT);
	Tcl_LinkVar(interp, "edit_object_flag", (char *)&edobj, TCL_LINK_INT);

	bu_vls_init(&edit_info_vls);
a786 1
	bu_vls_strcpy(&edit_info_vls, "edit_info");
d884 1
d2269 193
@


11.193
log
@*- mods for pjt demo
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/cmd.c,v 11.192 1998/04/10 18:21:12 bparker Exp $ (BRL)";
d2189 1
a2189 5
  event_check(1);  /* non-blocking */

  if(sedraw > 0)
    sedit();

@


11.192
log
@*- map "size" command to f_size()
*- map "view" command to f_view()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.191 1998/03/19 17:58:02 bparker Exp bparker $ (BRL)";
d877 1
a877 1
	filename = "/usr/brlcad/tclscripts";
@


11.191
log
@*- add a few commands to cmdtab[]
*- move "Query Ray" stuff to qray.c and call init_qray()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.190 1998/02/20 23:21:44 bparker Exp bparker $ (BRL)";
d338 1
a338 1
	"size", f_view,
d366 1
@


11.190
log
@added mged_update()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.189 1998/02/06 22:06:13 bparker Exp bparker $ (BRL)";
d61 2
a62 2
extern int cmd_get_comb(), cmd_put_comb();  /* defined in red.c */
extern void set_scroll();  /* defined in set.c */
d64 2
a65 1
extern int gui_setup();
a78 28
/* query_ray stuff */
#define QUERY_RAY_BASENAME "query_ray"
#define QUERY_RAY_FMT "query_ray_fmt"

struct bu_vls query_ray_basename;

struct query_ray_fmt {
  struct bu_vls tclName;
  struct bu_vls fmt;
};
struct query_ray_fmt *query_ray_fmts;

struct query_ray_fmt_data {
  char type;
  char *fmt;
};

struct query_ray_fmt_data def_query_ray_fmt_data[] = {
  {'r', "\"Origin (x y z) = (%.2f %.2f %.2f)  (h v d) = (%.2f %.2f %.2f)\\nDirection (x y z) = (%.4f %.4f %.4f)  (az el) = (%.2f %.2f)\\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e"},
  {'h', "\"    Region Name               Entry (x y z)              LOS  Obliq_in\\n\""},
  {'p', "\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f\\n\" reg_name x_in y_in z_in los obliq_in"},
  {'f', "\"\""},
  {'m', "\"You missed the target\\n\""},
  {'o', "\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\\n\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"},
  {(char)NULL, (char *)NULL}
};
/* End query_ray format stuff */

d224 2
d266 1
d268 1
d298 1
d368 1
d370 2
a709 1
	struct query_ray_fmt_data *nfdp;
d888 2
a889 23
	/* initialize query_ray variables */
	bu_vls_init(&query_ray_basename);

	bu_vls_strcpy(&query_ray_basename, "query_ray_basename");
	Tcl_SetVar(interp, bu_vls_addr(&query_ray_basename), QUERY_RAY_BASENAME, TCL_GLOBAL_ONLY);

	/* query_ray format variables */
	n = 0;
	for(nfdp = def_query_ray_fmt_data; nfdp->fmt != (char *)NULL; ++nfdp)
	  ++n;

	query_ray_fmts = (struct query_ray_fmt *)bu_malloc(sizeof(struct query_ray_fmt) * n, "query_ray_fmts");
	for(i = 0; i < n; ++i){
	  bu_vls_init(&query_ray_fmts[i].tclName);
	  bu_vls_init(&query_ray_fmts[i].fmt);

	  bu_vls_printf(&query_ray_fmts[i].tclName, "%s(%c)",
			QUERY_RAY_FMT, def_query_ray_fmt_data[i].type);
	  bu_vls_strcpy(&query_ray_fmts[i].fmt, def_query_ray_fmt_data[i].fmt);

	  Tcl_SetVar(interp, bu_vls_addr(&query_ray_fmts[i].tclName),
		     bu_vls_addr(&query_ray_fmts[i].fmt), TCL_GLOBAL_ONLY);
	}
@


11.189
log
@*- replaced a few strictly Tcl variables with mged_variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.188 1998/01/28 16:14:34 bparker Exp bparker $ (BRL)";
d2226 11
d2254 1
a2254 6
	event_check(1);  /* non-blocking */

	if(sedraw > 0)
		sedit();

	refresh();
@


11.188
log
@*- added get_dm_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.187 1998/01/16 22:05:58 bparker Exp bparker $ (BRL)";
d78 3
a80 9
#ifdef DO_RUBBER_BAND
#define RUBBER_BAND_COLOR "255 255 255"
#define RUBBER_BAND_LINE_WIDTH "1"
#define RUBBER_BAND_LINE_STYLE "0"

struct bu_vls rubber_band_color;
struct bu_vls rubber_band_line_width;
struct bu_vls rubber_band_line_style;
#endif
d82 1
a82 11
/* nirt stuff */
#define NIRT_EVEN_COLOR "255 255 0"
#define NIRT_ODD_COLOR "0 255 255"
#define NIRT_VOID_COLOR "255 0 255"
#define NIRT_RAY_BASENAME "nirt_ray"
#define NIRT_FMT "nirt_fmt"

struct bu_vls nirt_even_color;
struct bu_vls nirt_odd_color;
struct bu_vls nirt_void_color;
struct bu_vls nirt_basename;
d84 1
a84 1
struct nirt_fmt {
d88 1
a88 1
struct nirt_fmt *nirt_fmts;
d90 1
a90 1
struct nirt_fmt_data {
d95 1
a95 1
struct nirt_fmt_data def_nirt_fmt_data[] = {
d104 1
a104 1
/* End nirt format stuff */
d321 1
d392 1
d729 1
a729 1
	struct nirt_fmt_data *nfdp;
d908 2
a909 15
#ifdef DO_RUBBER_BAND
	/* initialize rubber band variables */
	bu_vls_init(&rubber_band_color);
	bu_vls_init(&rubber_band_line_width);
	bu_vls_init(&rubber_band_line_style);

	bu_vls_strcpy(&rubber_band_color, "rubber_band_color");
	Tcl_SetVar(interp, bu_vls_addr(&rubber_band_color), RUBBER_BAND_COLOR, TCL_GLOBAL_ONLY);

	bu_vls_strcpy(&rubber_band_line_width, "rubber_band_line_width");
	Tcl_SetVar(interp, bu_vls_addr(&rubber_band_line_width), RUBBER_BAND_LINE_WIDTH, TCL_GLOBAL_ONLY);

	bu_vls_strcpy(&rubber_band_line_style, "rubber_band_line_style");
	Tcl_SetVar(interp, bu_vls_addr(&rubber_band_line_style), RUBBER_BAND_LINE_STYLE, TCL_GLOBAL_ONLY);
#endif
d911 2
a912 16
	/* initialize nirt variables */
	bu_vls_init(&nirt_even_color);
	bu_vls_init(&nirt_odd_color);
	bu_vls_init(&nirt_void_color);
	bu_vls_init(&nirt_basename);

	bu_vls_strcpy(&nirt_basename, "nirt_ray_basename");
	Tcl_SetVar(interp, bu_vls_addr(&nirt_basename), NIRT_RAY_BASENAME, TCL_GLOBAL_ONLY);

	/* nirt color variables */
	bu_vls_strcpy(&nirt_even_color, "nirt_ray_colors(even)");
	Tcl_SetVar(interp, bu_vls_addr(&nirt_even_color), NIRT_EVEN_COLOR, TCL_GLOBAL_ONLY);
	bu_vls_strcpy(&nirt_odd_color, "nirt_ray_colors(odd)");
	Tcl_SetVar(interp, bu_vls_addr(&nirt_odd_color), NIRT_ODD_COLOR, TCL_GLOBAL_ONLY);
	bu_vls_strcpy(&nirt_void_color, "nirt_ray_colors(void)");
	Tcl_SetVar(interp, bu_vls_addr(&nirt_void_color), NIRT_VOID_COLOR, TCL_GLOBAL_ONLY);
d914 1
a914 1
	/* nirt format variables */
d916 1
a916 1
	for(nfdp = def_nirt_fmt_data; nfdp->fmt != (char *)NULL; ++nfdp)
d919 1
a919 1
	nirt_fmts = (struct nirt_fmt *)bu_malloc(sizeof(struct nirt_fmt) * n, "nirt_fmts");
d921 2
a922 2
	  bu_vls_init(&nirt_fmts[i].tclName);
	  bu_vls_init(&nirt_fmts[i].fmt);
d924 3
a926 3
	  bu_vls_printf(&nirt_fmts[i].tclName, "%s(%c)",
			NIRT_FMT, def_nirt_fmt_data[i].type);
	  bu_vls_strcpy(&nirt_fmts[i].fmt, def_nirt_fmt_data[i].fmt);
d928 2
a929 2
	  Tcl_SetVar(interp, bu_vls_addr(&nirt_fmts[i].tclName),
		     bu_vls_addr(&nirt_fmts[i].fmt), TCL_GLOBAL_ONLY);
@


11.187
log
@*- new commands, get_rect() and set_rect()
*- more Tcl variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.186 1997/12/23 14:13:52 bparker Exp bparker $ (BRL)";
d263 1
@


11.186
log
@*- new command vnirt
*- add Tcl variables in support of nirt
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.185 1997/12/08 21:17:08 pjt Exp bparker $ (BRL)";
d57 1
d78 10
d263 1
d367 1
d921 16
d1019 2
d1220 18
d1425 1
d1438 2
d1482 1
a1482 1
					      bu_vls_addr(&globbed), interp->result);
d1488 1
a1488 1
				history_record(vp, &start, &finish, CMD_OK);
d1529 1
a1529 1
			history_record(vp, &start, &finish, CMD_BAD);
d1540 2
d2285 1
a2285 1
	if( sedraw > 0)
@


11.185
log
@Implemented the make_name command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.184 1997/12/08 20:37:37 bparker Exp pjt $ (BRL)";
d77 22
d100 11
d392 1
d729 2
d908 35
d2035 2
d2038 2
@


11.184
log
@remove references to scroll_edit
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.183 1997/10/24 13:41:36 jra Exp bparker $ (BRL)";
d255 1
@


11.183
log
@Added *_muves commands.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.182 1997/10/08 04:42:05 mike Exp jra $ (BRL)";
a2056 1
	scroll_edit = dml->_scroll_edit;
a2120 1
	scroll_edit = dml->_scroll_edit;
@


11.182
log
@Tcl needs to write nulls onto subscripted variable names
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.181 1997/10/08 04:38:18 mike Exp mike $ (BRL)";
d213 1
d244 1
d296 1
d346 1
@


11.181
log
@BParker mod to add "arot" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.180 1997/09/23 21:12:41 bparker Exp bparker $ (BRL)";
a688 1
	struct bu_vls str2;
d858 2
a859 4
	bu_vls_init(&str2);
	bu_vls_printf(&str2, "%s/mged", filename);
	bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 %s %s]",
		      bu_vls_addr(&str2), filename);
a860 2
	bu_vls_free(&str);
	bu_vls_free(&str2);
d862 3
a864 1
	Tcl_SetVar(interp, "mged_display(state)", state_str[state],
d868 2
@


11.180
log
@2 new commands: get_comb and put_comb
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.179 1997/09/19 20:43:28 bparker Exp bparker $ (BRL)";
d167 1
@


11.179
log
@mods to mged_compat()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.178 1997/09/11 13:38:25 bparker Exp bparker $ (BRL)";
d60 1
d917 4
@


11.178
log
@ mods to mged_setup(): initially set mged_display(state) variable
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.177 1997/09/08 19:47:31 bparker Exp bparker $ (BRL)";
d901 1
a901 1
	(void)Tcl_CreateCommand(interp, "mged_glob", cmd_mged_glob,
d1126 1
a1126 1
	mged_compat( &dest, &src );
d1191 1
a1191 1
mged_compat( dest, src )
d1193 1
d1250 1
a1250 1
		if( firstword )
d1318 1
a1318 1
		mged_compat(&globbed, vp);
@


11.177
log
@remove reference to f_fix
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.176 1997/09/08 19:02:29 bparker Exp bparker $ (BRL)";
d864 3
@


11.176
log
@*- new macro --> FOR_ALL_DISPLAYS
*- mged_variables is now a pointer
*- add f_share_vars, f_share_view, f_unshare_vars, and f_unshare_view to
	cmdtab[]
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.175 1997/08/26 05:54:22 mike Exp bparker $ (BRL)";
a213 1
	"fix", f_fix,
@


11.175
log
@Added call to bu_tcl_setup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.174 1997/08/15 19:21:42 jra Exp mike $ (BRL)";
d321 2
a333 1
	"tie", f_tie,
d344 3
a346 1
	"untie", f_untie,
d1046 1
a1046 1
	for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d1922 1
a1922 1
	for( BU_LIST_FOR(dlp, dm_list, &head_dm_list.l) )
d2030 1
a2030 1
	mged_variables = dml->_mged_variables; /* struct copy */
d2095 1
a2095 1
	mged_variables = dml->_mged_variables; /* struct copy */
d2179 1
a2179 1
	for( BU_LIST_FOR(p, dm_list, &head_dm_list.l ) ){
@


11.174
log
@Added nmg_collapse command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.173 1997/07/31 14:28:22 bparker Exp jra $ (BRL)";
d922 1
@


11.173
log
@added two more Tcl variables: edit_solid_flag and edit_object_flag
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.172 1997/07/25 20:41:41 bparker Exp bparker $ (BRL)";
d262 1
@


11.172
log
@add variables to keep track of different kinds
of editing
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.171 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d712 2
@


11.171
log
@mods to run without a database
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.170 1997/06/25 02:03:15 mike Exp bparker $ (BRL)";
d303 1
d313 1
d336 1
a337 1
	"tran", f_tran,
a700 5
#if 0
	/* Initialize the menu mechanism to be off, but ready. */
	mmenu_init();
	btn_head_menu(0,0,0);		/* unlabeled menu */
#else
a704 1
#endif
d714 15
a728 6
	bu_vls_init(&edit_rate_tran_vls[X]);
	bu_vls_init(&edit_rate_tran_vls[Y]);
	bu_vls_init(&edit_rate_tran_vls[Z]);
	bu_vls_init(&edit_rate_rotate_vls[X]);
	bu_vls_init(&edit_rate_rotate_vls[Y]);
	bu_vls_init(&edit_rate_rotate_vls[Z]);
d730 15
a744 6
	bu_vls_init(&edit_absolute_tran_vls[X]);
	bu_vls_init(&edit_absolute_tran_vls[Y]);
	bu_vls_init(&edit_absolute_tran_vls[Z]);
	bu_vls_init(&edit_absolute_rotate_vls[X]);
	bu_vls_init(&edit_absolute_rotate_vls[Y]);
	bu_vls_init(&edit_absolute_rotate_vls[Z]);
d748 15
a762 6
	bu_vls_strcpy(&edit_rate_tran_vls[X], "edit_rate_tran(X)");
	bu_vls_strcpy(&edit_rate_tran_vls[Y], "edit_rate_tran(Y)");
	bu_vls_strcpy(&edit_rate_tran_vls[Z], "edit_rate_tran(Z)");
	bu_vls_strcpy(&edit_rate_rotate_vls[X], "edit_rate_rotate(X)");
	bu_vls_strcpy(&edit_rate_rotate_vls[Y], "edit_rate_rotate(Y)");
	bu_vls_strcpy(&edit_rate_rotate_vls[Z], "edit_rate_rotate(Z)");
d764 15
a778 6
	bu_vls_strcpy(&edit_absolute_tran_vls[X], "edit_abs_tran(X)");
	bu_vls_strcpy(&edit_absolute_tran_vls[Y], "edit_abs_tran(Y)");
	bu_vls_strcpy(&edit_absolute_tran_vls[Z], "edit_abs_tran(Z)");
	bu_vls_strcpy(&edit_absolute_rotate_vls[X], "edit_abs_rotate(X)");
	bu_vls_strcpy(&edit_absolute_rotate_vls[Y], "edit_abs_rotate(Y)");
	bu_vls_strcpy(&edit_absolute_rotate_vls[Z], "edit_abs_rotate(Z)");
d781 30
a810 12
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_tran_vls[X]),
		    (char *)&edit_rate_tran[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_tran_vls[Y]),
		    (char *)&edit_rate_tran[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_tran_vls[Z]),
		    (char *)&edit_rate_tran[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_rotate_vls[X]),
		    (char *)&edit_rate_rotate[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Y]),
		    (char *)&edit_rate_rotate[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Z]),
		    (char *)&edit_rate_rotate[Z], TCL_LINK_DOUBLE);
d813 30
a842 12
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_tran_vls[X]),
		    (char *)&edit_absolute_tran[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Y]),
		    (char *)&edit_absolute_tran[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Z]),
		    (char *)&edit_absolute_tran[Z], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[X]),
		    (char *)&edit_absolute_rotate[X], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[Y]),
		    (char *)&edit_absolute_rotate[Y], TCL_LINK_DOUBLE);
	Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[Z]),
		    (char *)&edit_absolute_rotate[Z], TCL_LINK_DOUBLE);
a2188 2


@


11.170
log
@Added "redraw_vlist"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.169 1997/06/20 03:46:52 gdurf Exp mike $ (BRL)";
d1123 5
@


11.169
log
@Added get_dbip function and cleaned up dbip handling.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.168 1997/06/19 20:53:40 bparker Exp gdurf $ (BRL)";
d293 1
@


11.168
log
@mods to cmd_get
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.167 1997/06/19 17:01:51 bparker Exp bparker $ (BRL)";
d653 1
d655 20
d838 1
a851 9
	/* Call it dbip since it looks like a pointer to Tcl */
	Tcl_LinkVar( interp, "dbip", (char *)&dbih,
		     TCL_LINK_INT|TCL_LINK_READ_ONLY );

#if THIS_DOESNT_WORK_BECAUSE_THE_DATABASE_ISNT_OPEN_YET	
	/* XXX Change from .db to "db" & eliminate mged-specific "db" command*/
	if( Tcl_Eval(interp, "set wdbp [wdb_open .db disk $dbip]") != TCL_OK )
		bu_log( "%s", interp->result );
#endif
@


11.167
log
@gdurf mods
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.166 1997/06/13 23:19:51 mike Exp gdurf $ (BRL)";
d953 1
a979 2
	struct cmd_list *p;

d985 2
a986 2
	for( BU_LIST_FOR(p, cmd_list, &head_cmd_list.l) ){
		if(strcmp(bu_vls_addr(&p->name), argv[1]))
a988 1
		curr_cmd_list = p;
a990 3

	if(p == &head_cmd_list)
		curr_cmd_list = &head_cmd_list;
@


11.166
log
@Fixed "dbip" problem on IRIX64.  TCL_INT isn't wide enough to link
to (void*)
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.165 1997/06/13 23:14:51 mike Exp mike $ (BRL)";
d84 25
a108 25
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
  if(argc < 4 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help L");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if( atoi(argv[1]) != 0 ){
    int status;
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "zoom 0.5\n");
    status = Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return status;
  }
d110 1
a110 1
  return TCL_OK;
d120 25
a144 25
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		*argv[];
{
  if(argc < 4 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help R");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if( atoi(argv[1]) != 0 ){
    int status;
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "zoom 2.0\n");
    status = Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return status;
  }
d146 1
a146 1
  return TCL_OK;
d150 2
a151 2
  char *ct_name;
  int (*ct_func)();
d155 65
a219 65
"%", f_comm,
"3ptarb", f_3ptarb,
"adc", f_adc,
"add_view", f_add_view,
"ae", f_aetview,
"aim", f_aim,
"aip", f_aip,
"analyze", f_analyze,
"arb", f_arbdef,
"arced", f_arced,
"area", f_area,
"attach", f_attach,
"B", f_blast,
"bev", f_bev,
"c", f_comb_std,
"cat", f_cat,
"center", f_center,
"color", f_color,
"comb", f_comb,
"comb_color", f_comb_color,
"copyeval", f_copyeval,
"copymat", f_copymat,
"cp", f_copy,
"cpi", f_copy_inv,
"d", f_erase,
"dall", f_erase_all,
"db", cmd_db,
"dbconcat", f_concat,
"debugbu", f_debugbu,
"debugdir", f_debugdir,
"debuglib", f_debuglib,
"debugmem", f_debugmem,
"debugnmg", f_debugnmg,
"decompose", f_decompose,
"delay", f_delay,
"delete_view", f_delete_view,
"dm", f_dm,
"draw", f_edit,
"dup", f_dup,
"E", f_evedit,
"e", f_edit,
"eac", f_eac,
"echo", cmd_echo,
"edcodes", f_edcodes,
"edmater", f_edmater,
"edcolor", f_edcolor,
"edcomb", f_edcomb,
"edgedir", f_edgedir,
"erase", f_erase,
"erase_all", f_erase_all,
"ev", f_ev,
"eqn", f_eqn,
"exit", f_quit,
"extrude", f_extrude,
"expand", cmd_expand,
"eye_pt", f_eye_pt,
"facedef", f_facedef,
"facetize", f_facetize,
"find", f_find,
"fix", f_fix,
"fracture", f_fracture,
"g", f_group,
"get_view", f_get_view,
"goto_view", f_goto_view,
"output_hook", cmd_output_hook,
d221 1
a221 1
"H", f_hideline,
d223 83
a305 83
"history", f_history,
"hist_prev", cmd_prev,
"hist_next", cmd_next,
"hist_add", cmd_hist_add,
"i", f_instance,
"idents", f_tables,
"ill", f_ill,
"in", f_in,
"inside", f_inside,
"item", f_itemair,
"joint", f_joint,
"journal", f_journal,
"keep", f_keep,
"keypoint", f_keypoint,
"kill", f_kill,
"killall", f_killall,
"killtree", f_killtree,
"knob", f_knob,
"l", cmd_list,
"L", cmd_left_mouse,
"labelvert", f_labelvert,
"listeval", f_pathsum,
"loadtk", cmd_tk,
"lookat", f_lookat,
"ls", dir_print,
"M", f_mouse,
"mrot", f_mrot,
"make", f_make,
"make_bb", f_make_bb,
"mater", f_mater,
"matpick", f_matpick,
"memprint", f_memprint,
"mirface", f_mirface,
"mirror", f_mirror,
"model2view", f_model2view,
"mv", f_name,
"mvall", f_mvall,
"next_view", f_next_view,
"nirt", f_nirt,
"nmg_simplify", f_nmg_simplify,
"oed", cmd_oed,
"opendb", f_opendb,
"orientation", f_orientation,
"orot", f_rot_obj,
"oscale", f_sc_obj,
"overlay", f_overlay,
"p", f_param,
"paths", f_pathsum,
"pathlist", cmd_pathlist,
"permute", f_permute,
"plot", f_plot,
"pl", f_pl,
"polybinout", f_polybinout,
"pov", f_pov,
"prcolor", f_prcolor,
"prefix", f_prefix,
"prev_view", f_prev_view,
"preview", f_preview,
"press", f_press,
"ps", f_ps,
"push", f_push,
"putmat", f_putmat,
"q", f_quit,
"quit", f_quit,
"qorot", f_qorot,
"qvrot", f_qvrot,
"r", f_region,
"R", cmd_right_mouse,
"rcodes", f_rcodes,
"red", f_red,
"refresh", f_refresh,
"regdebug", f_regdebug,
"regdef", f_regdef,
"regions", f_tables,
"release", f_release,
"rfarb", f_rfarb,
"rm", f_rm,
"rmater", f_rmater,
"rmats", f_rmats,
"rotobj", f_rot_obj,
"rrt", f_rrt,
"rt", f_rt,
"rtcheck", f_rtcheck,
d307 1
a307 1
"savedit", f_savedit,
d309 53
a361 53
"savekey", f_savekey,
"saveview", f_saveview,
"showmats", f_showmats,
"sed", f_sed,
"setview", f_setview,
"shells", f_shells,
"shader", f_shader,
"share_menu", f_share_menu,
"size", f_view,
"sliders", cmd_sliders,
"solids", f_tables,
"solids_on_ray", cmd_solids_on_ray,
"status", f_status,
"summary", f_summary,
"sv", f_slewview,
"svb", f_svbase,
"sync", f_sync,
"t", dir_print,
"ted", f_tedit,
"tie", f_tie,
"title", f_title,
"toggle_view", f_toggle_view,
"tol", f_tol,
"tops", f_tops,
"track", f_amtrack,
"tran", f_tran,
"translate", f_tr_obj,
"tree", f_tree,
"unaim", f_unaim,
"units", f_units,
"untie", f_untie,
"mged_update", f_update,
"vars", f_set,
"vdraw", cmd_vdraw,
"viewget", cmd_viewget,
"viewset", cmd_viewset,
"view2model", f_view2model,
"vrmgr", f_vrmgr,
"vrot", f_vrot,
"vrot_center", f_vrot_center,
"wcodes", f_wcodes,
"whatid", f_whatid,
"whichair", f_which_air,
"whichid", f_which_id,
"which_shader", f_which_shader,
"who", cmd_who,
"winset", f_winset,
"wmater", f_wmater,
"x", f_debug,
"xpush", f_xpush,
"Z", f_zap,
"zoom", f_zoom,
0, 0
d373 2
a374 2
genptr_t clientdata;
genptr_t str;
d376 2
a377 2
    register struct bu_vls *vp = (struct bu_vls *)clientdata;
    register int len;
d379 4
a382 4
    BU_CK_VLS(vp);
    len = bu_vls_strlen(vp);
    bu_vls_strcat(vp, str);
    len = bu_vls_strlen(vp) - len;
d384 1
a384 1
    return len;
d396 1
a396 1
struct bu_vls *vp;
d398 1
a398 1
    bu_add_hook(output_catch, (genptr_t)vp);
d409 1
a409 1
struct bu_vls *vp;
d411 1
a411 1
    bu_delete_hook(output_catch, (genptr_t)vp);
d424 1
a424 1
Tcl_Interp *interp;		/* Interpreter for application. */
d426 1
a426 1
    return TCL_OK;
d438 18
a455 18
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    int status;
    size_t len;
    struct bu_vls result;
    int catch_output;

    argv[0] = ((struct funtab *)clientData)->ft_name;

    /* We now leave the world of Tcl where everything prints its results
       in the interp->result field.  Here, stuff gets printed with the
       bu_log command; hence, we must catch such output and stuff it into
       the result string.  Do this *only* if "output_as_return" global
       variable is set.  Make a local copy of this variable in case it's
       changed by our command. */
d457 1
a457 1
    catch_output = output_as_return;
d459 1
a459 1
    bu_vls_init(&result);
a460 16
    if (catch_output)
	start_catching_output(&result);
    status = mged_cmd(argc, argv, funtab);
    if (catch_output)
	stop_catching_output(&result);

    /* Remove any trailing newlines. */

    if (catch_output) {
	len = bu_vls_strlen(&result);
	while (len > 0 && bu_vls_addr(&result)[len-1] == '\n')
	    bu_vls_trunc(&result, --len);
    }
    
    switch (status) {
    case CMD_OK:
d462 2
a463 4
	    Tcl_SetResult(interp, bu_vls_addr(&result), TCL_VOLATILE);
	status = TCL_OK;
	break;
    case CMD_BAD:
d465 4
a468 5
	    Tcl_SetResult(interp, bu_vls_addr(&result), TCL_VOLATILE);
	status = TCL_ERROR;
	break;
    case CMD_MORE:
	Tcl_SetResult(interp, MORE_ARGS_STR, TCL_STATIC);
d470 3
a472 1
	    Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
d474 26
a499 6
	status = TCL_ERROR;
	break;
    default:
	Tcl_SetResult(interp, "error executing mged routine::", TCL_STATIC);
	if (catch_output) {
	    Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
a500 3
	status = TCL_ERROR;
	break;
    }
d502 2
a503 2
    bu_vls_free(&result);
    return status;
d517 2
a518 2
genptr_t clientData;
genptr_t str;
d520 9
a528 2
    Tcl_DString tclcommand;
    static int level = 0;
d530 7
a536 14
    if (level > 50) {
	bu_delete_hook(gui_output, clientData);
	/* Now safe to run bu_log? */
    	bu_log("Ack! Something horrible just happened recursively.\n");
	return 0;
    }

    Tcl_DStringInit(&tclcommand);
    (void)Tcl_DStringAppendElement(&tclcommand, bu_vls_addr(&tcl_output_hook));
    (void)Tcl_DStringAppendElement(&tclcommand, str);

    ++level;
    Tcl_Eval((Tcl_Interp *)clientData, Tcl_DStringValue(&tclcommand));
    --level;
d538 2
a539 2
    Tcl_DStringFree(&tclcommand);
    return strlen(str);
d551 16
a566 21
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  int status;

  if(argc < 1 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help loadtk");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(argc == 1)
    status = gui_setup((char *)NULL);
  else
    status = gui_setup(argv[1]);
d568 6
a573 1
  return status;
d585 17
a601 17
ClientData clientData;
Tcl_Interp *interp;    
int argc;
char **argv;
{
    struct bu_vls infocommand;
    int status;

    if(argc < 1 || 2 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help output_hook");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d603 1
a603 1
    bu_delete_hook(gui_output, (genptr_t)interp);/* Delete the existing hook */
d605 2
a606 2
    if (argc < 2)
	return TCL_OK;
d608 1
a608 1
    /* Make sure the command exists before putting in the hook! */
d610 10
a619 10
    bu_vls_init(&infocommand);
    bu_vls_strcat(&infocommand, "info commands ");
    bu_vls_strcat(&infocommand, argv[1]);
    status = Tcl_Eval(interp, bu_vls_addr(&infocommand));
    bu_vls_free(&infocommand);

    if (status != TCL_OK || interp->result[0] == '\0') {
      Tcl_AppendResult(interp, "command does not exist", (char *)NULL);
      return TCL_ERROR;
    }
d621 1
a621 1
    /* Also, don't allow silly infinite loops. */
d623 4
a626 4
    if (strcmp(argv[1], argv[0]) == 0) {
	Tcl_AppendResult(interp, "Don't be silly.", (char *)NULL);
	return TCL_ERROR;
    }
d628 1
a628 1
    /* Set up the hook! */
d630 2
a631 2
    bu_vls_strcpy(&tcl_output_hook, argv[1]);
    bu_add_hook(gui_output, (genptr_t)interp);
d633 2
a634 2
    Tcl_ResetResult(interp);
    return TCL_OK;
d643 4
a646 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d648 1
a648 1
    return TCL_OK;
d659 14
a672 14
  struct bu_vls str;
  struct bu_vls str2;
  char *filename;

  /* The following is for GUI output hooks: contains name of function to
     run with output */
  bu_vls_init(&tcl_output_hook);

  /* Create the interpreter */
  interp = Tcl_CreateInterp();

  /* This runs the init.tcl script */
  if( Tcl_Init(interp) == TCL_ERROR )
    bu_log("Tcl_Init error %s\n", interp->result);
d674 2
a675 2
  /* register commands */
  cmd_setup();
d678 3
a680 3
  /* Initialize the menu mechanism to be off, but ready. */
  mmenu_init();
  btn_head_menu(0,0,0);		/* unlabeled menu */
d682 4
a685 4
  (void)Tcl_CreateCommand(interp, "mmenu_set", cmd_nop, (ClientData)NULL,
			  (Tcl_CmdDeleteProc *)NULL);
  (void)Tcl_CreateCommand(interp, "mmenu_get", cmd_mmenu_get,
			  (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
d688 1
a688 1
  history_setup();
d690 1
a690 1
  mged_variable_setup(interp);
d693 1
a693 1
  Tcl_LinkVar(interp, "edit_class", (char *)&es_edclass, TCL_LINK_INT);
d695 60
a754 60
  bu_vls_init(&edit_info_vls);
  bu_vls_init(&edit_rate_tran_vls[X]);
  bu_vls_init(&edit_rate_tran_vls[Y]);
  bu_vls_init(&edit_rate_tran_vls[Z]);
  bu_vls_init(&edit_rate_rotate_vls[X]);
  bu_vls_init(&edit_rate_rotate_vls[Y]);
  bu_vls_init(&edit_rate_rotate_vls[Z]);
  bu_vls_init(&edit_rate_scale_vls);
  bu_vls_init(&edit_absolute_tran_vls[X]);
  bu_vls_init(&edit_absolute_tran_vls[Y]);
  bu_vls_init(&edit_absolute_tran_vls[Z]);
  bu_vls_init(&edit_absolute_rotate_vls[X]);
  bu_vls_init(&edit_absolute_rotate_vls[Y]);
  bu_vls_init(&edit_absolute_rotate_vls[Z]);
  bu_vls_init(&edit_absolute_scale_vls);

  bu_vls_strcpy(&edit_info_vls, "edit_info");
  bu_vls_strcpy(&edit_rate_tran_vls[X], "edit_rate_tran(X)");
  bu_vls_strcpy(&edit_rate_tran_vls[Y], "edit_rate_tran(Y)");
  bu_vls_strcpy(&edit_rate_tran_vls[Z], "edit_rate_tran(Z)");
  bu_vls_strcpy(&edit_rate_rotate_vls[X], "edit_rate_rotate(X)");
  bu_vls_strcpy(&edit_rate_rotate_vls[Y], "edit_rate_rotate(Y)");
  bu_vls_strcpy(&edit_rate_rotate_vls[Z], "edit_rate_rotate(Z)");
  bu_vls_strcpy(&edit_rate_scale_vls, "edit_rate_scale");
  bu_vls_strcpy(&edit_absolute_tran_vls[X], "edit_abs_tran(X)");
  bu_vls_strcpy(&edit_absolute_tran_vls[Y], "edit_abs_tran(Y)");
  bu_vls_strcpy(&edit_absolute_tran_vls[Z], "edit_abs_tran(Z)");
  bu_vls_strcpy(&edit_absolute_rotate_vls[X], "edit_abs_rotate(X)");
  bu_vls_strcpy(&edit_absolute_rotate_vls[Y], "edit_abs_rotate(Y)");
  bu_vls_strcpy(&edit_absolute_rotate_vls[Z], "edit_abs_rotate(Z)");
  bu_vls_strcpy(&edit_absolute_scale_vls, "edit_abs_scale");

  Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_tran_vls[X]),
	      (char *)&edit_rate_tran[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_tran_vls[Y]),
	      (char *)&edit_rate_tran[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_tran_vls[Z]),
	      (char *)&edit_rate_tran[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_rotate_vls[X]),
	      (char *)&edit_rate_rotate[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Y]),
	      (char *)&edit_rate_rotate[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Z]),
	      (char *)&edit_rate_rotate[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_rate_scale_vls),
	      (char *)&edit_rate_scale, TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_tran_vls[X]),
	      (char *)&edit_absolute_tran[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Y]),
	      (char *)&edit_absolute_tran[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Z]),
	      (char *)&edit_absolute_tran[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[X]),
	      (char *)&edit_absolute_rotate[X], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[Y]),
	      (char *)&edit_absolute_rotate[Y], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[Z]),
	      (char *)&edit_absolute_rotate[Z], TCL_LINK_DOUBLE);
  Tcl_LinkVar(interp, bu_vls_addr(&edit_absolute_scale_vls),
	      (char *)&edit_absolute_scale, TCL_LINK_DOUBLE);
d757 1
a757 1
  filename = BRLCAD_TCL_LIBRARY;
d759 1
a759 1
  filename = "/usr/brlcad/tclscripts";
d761 8
a768 8
  bu_vls_init(&str);
  bu_vls_init(&str2);
  bu_vls_printf(&str2, "%s/mged", filename);
  bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 %s %s]",
		bu_vls_addr(&str2), filename);
  (void)Tcl_Eval(interp, bu_vls_addr(&str));
  bu_vls_free(&str);
  bu_vls_free(&str2);
d770 1
a770 1
  Tcl_ResetResult(interp);
d779 2
a780 4
    register struct cmdtab *ctp;
    struct bu_vls temp;

    bu_vls_init(&temp);
d782 2
a783 1
    for (ctp = cmdtab; ctp->ct_name != NULL; ctp++) {
d785 15
a799 6
	bu_vls_strcpy(&temp, "info commands ");
	bu_vls_strcat(&temp, ctp->ct_name);
	if (Tcl_Eval(interp, bu_vls_addr(&temp)) != TCL_OK ||
	    interp->result[0] != '\0') {
	    bu_log("WARNING:  '%s' name collision (%s)\n", ctp->ct_name,
		   interp->result);
d801 37
a838 48
	bu_vls_strcpy(&temp, "_mged_");
	bu_vls_strcat(&temp, ctp->ct_name);
	
	(void)Tcl_CreateCommand(interp, ctp->ct_name, ctp->ct_func,
				(ClientData)ctp, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, bu_vls_addr(&temp), ctp->ct_func,
				(ClientData)ctp, (Tcl_CmdDeleteProc *)NULL);
    }

    (void)Tcl_CreateCommand(interp, "mged_glob", cmd_mged_glob, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);
    (void)Tcl_CreateCommand(interp, "cmd_init", cmd_init, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);
    (void)Tcl_CreateCommand(interp, "cmd_close", cmd_close, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);
    (void)Tcl_CreateCommand(interp, "cmd_set", cmd_set, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);
    (void)Tcl_CreateCommand(interp, "cmd_get", cmd_get, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);
    (void)Tcl_CreateCommand(interp, "get_more_default", get_more_default, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);
    (void)Tcl_CreateCommand(interp, "stuff_str", cmd_stuff_str, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);

    /* A synonym, to allow cut-n-paste of rt animation scripts into mged */
    (void)Tcl_CreateCommand(interp, "viewsize", f_view, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);

    Tcl_LinkVar(interp, "glob_compat_mode", (char *)&glob_compat_mode,
		TCL_LINK_BOOLEAN);
    Tcl_LinkVar(interp, "output_as_return", (char *)&output_as_return,
		TCL_LINK_BOOLEAN);

    /* Provide Tcl interfaces to the fundamental BRL-CAD libraries */
    bn_tcl_setup(interp);
    rt_tcl_setup(interp);

    /* Can't use Tcl_LinkVar, it doesn't have a (void*) or (long) type */
    {
    	char	str[64];
    	sprintf(str, "%ld", (long)dbip );
    	Tcl_SetVar(interp, "dbip", str, TCL_GLOBAL_ONLY);
    }

    /* XXX Change from .db to "db" & eliminate mged-specific "db" command */
    bu_vls_trunc(&temp, 0);
    bu_vls_printf(&temp, "set wdbp [wdb_open .db disk $dbip]");
    (void)Tcl_Eval(interp, bu_vls_addr(&temp)); 
d840 1
a840 2
    bu_vls_free(&temp);
    tkwin = NULL;
d847 19
a865 36
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct cmd_list *clp;
  int name_not_used = 1;

  if(argc != 2){
    Tcl_AppendResult(interp, "Usage: cmd_init name", (char *)NULL);
    return TCL_ERROR;
  }

  /* Search to see if there exists a command window with this name */
  for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
    if(!strcmp(argv[1], bu_vls_addr(&clp->name))){
      name_not_used = 0;
      break;
    }

  if(name_not_used){
    clp = (struct cmd_list *)bu_malloc(sizeof(struct cmd_list), "cmd_list");
    bzero((void *)clp, sizeof(struct cmd_list));
    BU_LIST_APPEND(&head_cmd_list.l, &clp->l);
    clp->cur_hist = head_cmd_list.cur_hist;
    bu_vls_init(&clp->more_default);
    bu_vls_init(&clp->name);
    bu_vls_strcpy(&clp->name, argv[1]);
  }else{
    clp->cur_hist = head_cmd_list.cur_hist;

    if(clp->aim != NULL){
      clp->aim->aim = CMD_LIST_NULL;
      clp->aim = DM_LIST_NULL;
    }
  }
d867 18
a884 1
  return TCL_OK;
d890 28
a917 35
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct cmd_list *clp;

  if(argc != 2){
    Tcl_AppendResult(interp, "Usage: cmd_close id", (char *)NULL);
    return TCL_ERROR;
  }

  /* First, search to see if there exists a command window with the name
          in argv[1] */
  for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
    if(!strcmp(argv[1], bu_vls_addr(&clp->name)))
      break;

  if(clp == &head_cmd_list){
    if(!strcmp(argv[1], "mged"))
      Tcl_AppendResult(interp, "cmd_close: not allowed to close \"mged\"", (char *)NULL);
    else
      Tcl_AppendResult(interp, "cmd_close: did not find \"", argv[1], "\"", (char *)NULL);
    return TCL_ERROR;
  }

  if(clp == curr_cmd_list)
    curr_cmd_list = &head_cmd_list;

  BU_LIST_DEQUEUE( &clp->l );
  if(clp->aim != NULL)
    clp->aim->aim = CMD_LIST_NULL;
  bu_vls_free(&clp->more_default);
  bu_vls_free(&clp->name);
  bu_free((genptr_t)clp, "cmd_close: clp");
d919 8
a926 1
  return TCL_OK;
d932 36
a967 36
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct dm_list *p;
  struct bu_vls vls;

  if(!curr_cmd_list->aim){
    Tcl_AppendElement(interp, bu_vls_addr(&pathName));
    Tcl_AppendElement(interp, bu_vls_addr(curr_dm_list->s_info->opp));
    if(curr_dm_list->aim)
      Tcl_AppendElement(interp, bu_vls_addr(&curr_dm_list->aim->name));
    else
    Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->name));

    return TCL_OK;
  }

  Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->aim->_dmp->dm_pathName));
  Tcl_AppendElement(interp, bu_vls_addr(curr_cmd_list->aim->s_info->opp));
  bu_vls_init(&vls);

  /* return all ids associated with the current command window */
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
    /* The display manager tied to the current command window shares
       information with display manager p */
    if(curr_cmd_list->aim->s_info == p->s_info)
      /* This display manager is tied to a command window */
      if(p->aim)
	bu_vls_printf(&vls, "{%S} ", &p->aim->name);
  }

  Tcl_AppendElement(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_OK;
d974 19
a992 19
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct cmd_list *p;

  if(argc != 2){
    Tcl_AppendResult(interp, "Usage: cmd_set id", (char *)NULL);
    return TCL_ERROR;
  }

  for( BU_LIST_FOR(p, cmd_list, &head_cmd_list.l) ){
    if(strcmp(bu_vls_addr(&p->name), argv[1]))
      continue;

    curr_cmd_list = p;
    break;
  }
d994 2
a995 2
  if(p == &head_cmd_list)
    curr_cmd_list = &head_cmd_list;
d997 2
a998 2
  if(curr_cmd_list->aim)
    curr_dm_list = curr_cmd_list->aim;
d1000 2
a1001 2
  bu_vls_trunc(&curr_cmd_list->more_default, 0);
  return TCL_OK;
d1006 11
a1016 11
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct cmd_list *p;

  if(argc != 1){
    Tcl_AppendResult(interp, "Usage: get_more_default", (char *)NULL);
    return TCL_ERROR;
  }
d1018 2
a1019 2
  Tcl_AppendResult(interp, bu_vls_addr(&curr_cmd_list->more_default), (char *)NULL);
  return TCL_OK;
d1025 11
a1035 19
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct bu_vls dest, src;

  if(argc != 2){
    Tcl_AppendResult(interp, "cmd_mged_glob: There must be only one argument.", (char *)NULL);
    return TCL_ERROR;
  }

  bu_vls_init(&src);
  bu_vls_init(&dest);
  bu_vls_strcpy(&src, argv[1]);
  mged_compat( &dest, &src );
  Tcl_AppendResult(interp, bu_vls_addr(&dest), (char *)NULL);
  bu_vls_free(&src);
  bu_vls_free(&dest);
d1037 9
a1045 1
  return TCL_OK;
d1056 1
a1056 1
struct bu_vls *dest, *src;
d1058 1
a1058 1
    char *ptr;
d1060 8
a1067 8
    ptr = bu_vls_addr(src);
    while( *ptr ) {
	if( *ptr == '\\' )
	    ++ptr;
	if( *ptr == '\0' )
	    break;
	bu_vls_putc( dest, *ptr++ );
    }
d1072 1
a1072 1
struct bu_vls *dest, *src;
d1074 2
a1075 2
    int backslashed;
    char *ptr, buf[2];
d1077 18
a1094 17
    buf[1] = '\0';
    backslashed = 0;
    for( ptr = bu_vls_addr( src ); *ptr; ptr++ ) {
	if( *ptr == '[' && !backslashed )
	    bu_vls_strcat( dest, "\\[" );
	else if( *ptr == ']' && !backslashed )
	    bu_vls_strcat( dest, "\\]" );
	else if( backslashed ) {
	    bu_vls_strcat( dest, "\\" );
	    buf[0] = *ptr;
	    bu_vls_strcat( dest, buf );
	    backslashed = 0;
	} else if( *ptr == '\\' )
	    backslashed = 1;
	else {
	    buf[0] = *ptr;
	    bu_vls_strcat( dest, buf );
a1095 1
    }
d1106 1
a1106 1
struct bu_vls *dest, *src;
d1108 6
a1113 6
    char *start, *end;          /* Start and ends of words */
    int regexp;                 /* Set to TRUE when word is a regexp */
    int backslashed;
    int firstword;
    struct bu_vls word;         /* Current word being processed */
    struct bu_vls temp;
d1115 2
a1116 2
    bu_vls_init( &word );
    bu_vls_init( &temp );
d1118 17
a1134 17
    start = end = bu_vls_addr( src );
    firstword = 1;
    while( *end != '\0' ) {            /* Run through entire string */

	/* First, pass along leading whitespace. */

	start = end;                   /* Begin where last word ended */
	while( *start != '\0' ) {
	    if( *start == ' '  ||
	        *start == '\t' ||
	        *start == '\n' )
		bu_vls_putc( dest, *start++ );
	    else
		break;
	}
	if( *start == '\0' )
	    break;
d1136 7
a1142 18
	/* Next, advance "end" pointer to the end of the word, while adding
	   each character to the "word" vls.  Also make a note of any
	   unbackslashed wildcard characters. */

	end = start;
	bu_vls_trunc( &word, 0 );
	regexp = 0;
	backslashed = 0;
	while( *end != '\0' ) {
	    if( *end == ' '  ||
	        *end == '\t' ||
		*end == '\n' )
		break;
	    if( (*end == '*' || *end == '?' || *end == '[') && !backslashed )
		regexp = 1;
	    if( *end == '\\' && !backslashed )
		backslashed = 1;
	    else
d1144 31
a1174 5
	    bu_vls_putc( &word, *end++ );
	}

	if( firstword )
	    regexp = 0;
d1176 1
a1176 12
	/* Now, if the word was suspected of being a wildcard, try to match
	   it to the database. */

	if( regexp ) {
	    bu_vls_trunc( &temp, 0 );
	    if( regexp_match_all(&temp, bu_vls_addr(&word)) == 0 ) {
		debackslash( &temp, &word );
		backslash_specials( dest, &temp );
	    } else
		bu_vls_vlscat( dest, &temp );
	} else {
	    debackslash( dest, &word );
d1179 2
a1180 5
	firstword = 0;
    }

    bu_vls_free( &temp );
    bu_vls_free( &word );
d1197 2
a1198 2
struct bu_vls *vp;
int record;
d1200 7
a1206 7
  int	status;
  struct bu_vls globbed;
  struct bu_vls tmp_vls;
  struct timeval start, finish;
  size_t len;
  extern struct bu_vls mged_prompt;
  char *cp;
d1208 1
a1208 1
  BU_CK_VLS(vp);
d1210 2
a1211 2
  if (bu_vls_strlen(vp) <= 0)
    return CMD_OK;
d1213 2
a1214 2
  bu_vls_init(&globbed);
  bu_vls_init(&tmp_vls);
d1216 2
a1217 2
  /* MUST MAKE A BACKUP OF THE INPUT STRING AND USE THAT IN THE CALL TO
     Tcl_Eval!!!
d1219 42
a1260 26
     You never know who might change the string (append to it...)
     (f_mouse is notorious for adding things to the input string)
     If it were to change while it was still being evaluated, Horrible Things
     could happen.
   */

  if (glob_compat_mode)
    mged_compat(&globbed, vp);
  else
    bu_vls_vlscat(&globbed, vp);

  gettimeofday(&start, (struct timezone *)NULL);
  status = Tcl_Eval(interp, bu_vls_addr(&globbed));
  gettimeofday(&finish, (struct timezone *)NULL);

  /* Contemplate the result reported by the Tcl interpreter. */

  switch (status) {
  case TCL_RETURN:
  case TCL_OK:
    if( setjmp( jmp_env ) == 0 ){
      len = strlen(interp->result);

      /* If the command had something to say, print it out. */	     
      if (len > 0){
	(void)signal( SIGINT, sig3);  /* allow interupts */
d1262 2
a1263 2
	bu_log("%s%s", interp->result,
	       interp->result[len-1] == '\n' ? "" : "\n");
d1265 37
a1301 2
	(void)signal( SIGINT, SIG_IGN );
      }
d1303 2
d1306 2
a1307 8
      /* A user typed this command so let everybody see, then record
	 it in the history. */
      if (record && tkwin != NULL) {
	bu_vls_printf(&tmp_vls, "distribute_text {} {%s} {%s}",
		      bu_vls_addr(&globbed), interp->result);
	Tcl_Eval(interp, bu_vls_addr(&tmp_vls));
	Tcl_SetResult(interp, "", TCL_STATIC);
      }
d1309 2
a1310 2
      if(record)
	history_record(vp, &start, &finish, CMD_OK);
d1312 4
a1315 51
    }else{
/* XXXXXX */
      bu_semaphore_release(BU_SEM_SYSCALL);
      bu_log("\n");
    }
      
    bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
    status = CMD_OK;
    goto end;

  case TCL_ERROR:
  default:

    /* First check to see if it's a secret message. */

    if ((cp = strstr(interp->result, MORE_ARGS_STR)) != NULL) {
      if(cp == interp->result){
	bu_vls_trunc(&mged_prompt, 0);
	bu_vls_printf(&mged_prompt, "\r%s",
		      interp->result+sizeof(MORE_ARGS_STR)-1);
      }else{
	len = cp - interp->result;
	bu_log("%*s%s", len, interp->result, interp->result[len-1] == '\n' ? "" : "\n");
	bu_vls_trunc(&mged_prompt, 0);
	bu_vls_printf(&mged_prompt, "\r%s",
		      interp->result+sizeof(MORE_ARGS_STR)-1+len);
      }

      status = CMD_MORE;
      goto end;
    }

    /* Otherwise, it's just a regular old error. */    

    len = strlen(interp->result);
    if (len > 0) bu_log("%s%s", interp->result,
			interp->result[len-1] == '\n' ? "" : "\n");

    if (record)
      history_record(vp, &start, &finish, CMD_BAD);

    bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
    status = CMD_BAD;

    /* Fall through to end */
  }

end:
  bu_vls_free(&globbed);
  bu_vls_free(&tmp_vls);
  return status;
d1321 1
a1321 1
int status;
d1323 2
a1324 2
  int len;
  extern void pr_prompt();
d1327 13
a1339 20
  switch (status) {
  case TCL_OK:
    len = strlen(interp->result);

    /* If the command had something to say, print it out. */	     
    if (len > 0){
      bu_log("%s%s", interp->result,
	     interp->result[len-1] == '\n' ? "" : "\n");

      pr_prompt();
    }

    break;

  case TCL_ERROR:
  default:
    len = strlen(interp->result);
    if (len > 0){
      bu_log("%s%s", interp->result,
	     interp->result[len-1] == '\n' ? "" : "\n");
d1341 6
a1346 2
      pr_prompt();
    }
d1348 5
a1352 2
    break;
  }
d1354 4
a1357 4
  len = strlen(interp->result);
  if (len > 0){
    bu_log("%s%s", interp->result,
	   interp->result[len-1] == '\n' ? "" : "\n");
d1359 2
a1360 2
    pr_prompt();
  }
d1363 1
a1363 1
  Tcl_ResetResult(interp);
d1376 18
a1393 28
int argc;
char **argv;
struct funtab in_functions[];
{
    register struct funtab *ftp;
    struct funtab *functions;

    if (argc == 0)
	return CMD_OK;	/* No command entered, that's fine */

    /* if no function table is provided, use the default mged function table */
    if( in_functions == (struct funtab *)NULL )
      {
	bu_log("mged_cmd: failed to supply function table!\n");
	return CMD_BAD;
      }
    else
	functions = in_functions;

    for (ftp = &functions[1]; ftp->ft_name; ftp++) {
	if (strcmp(ftp->ft_name, argv[0]) != 0)
	    continue;
	/* We have a match */
	if ((ftp->ft_min <= argc) && (argc <= ftp->ft_max)) {
	    /* Input has the right number of args.
	     * Call function listed in table, with
	     * main(argc, argv) style args
	     */
d1395 27
a1421 4
	    switch (ftp->ft_func(argc, argv)) {
	    case CMD_OK:
		return CMD_OK;
	    case CMD_BAD:
a1422 7
	    case CMD_MORE:
		return CMD_MORE;
	    default:
	      Tcl_AppendResult(interp, "mged_cmd(): Invalid return from ",
			       ftp->ft_name, "\n", (char *)NULL);
	      return CMD_BAD;
	    }
d1425 3
a1427 3
	Tcl_AppendResult(interp, "Usage: ", functions[0].ft_name, ftp->ft_name,
			 " ", ftp->ft_parms, "\n\t(", ftp->ft_comment,
			 ")\n", (char *)NULL);
a1428 6
    }

    Tcl_AppendResult(interp, functions[0].ft_name, argv[0],
		     ": no such command, type '", functions[0].ft_name,
		     "?' for help\n", (char *)NULL);
    return CMD_BAD;
d1436 4
a1439 4
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1446 1
a1446 1
	  struct bu_vls vls;
d1448 5
a1452 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help ?");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
d1476 14
a1489 14
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d1491 2
a1492 2
  if( state != ST_VIEW )
    button( BE_REJECT );
d1494 2
a1495 2
  quit();			/* Exiting time */
  /* NOTREACHED */
d1502 16
a1517 16
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    register int i;

    if(argc < 1 || 1 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help sync");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d1519 1
a1519 1
    sync();
d1521 1
a1521 1
    return TCL_OK;
d1532 3
a1534 3
int	argc;
char	**argv;
struct funtab *functions;
d1536 2
a1537 2
  register struct funtab *ftp;
  register int	i, bad;
d1539 1
a1539 1
  bad = 0;
d1541 5
a1545 17
  /* Help command(s) */
  for( i=1; i<argc; i++ )  {
    for( ftp = functions+1; ftp->ft_name; ftp++ )  {
      if( strcmp( ftp->ft_name, argv[i] ) != 0 )
	continue;

      Tcl_AppendResult(interp, "Usage: ", functions->ft_name, ftp->ft_name,
		       " ", ftp->ft_parms, "\n\t(", ftp->ft_comment, ")\n", (char *)NULL);
      break;
    }
    if( !ftp->ft_name ) {
      Tcl_AppendResult(interp, functions->ft_name, argv[i],
		       ": no such command, type '", functions->ft_name,
		       "?' for help\n", (char *)NULL);
      bad = 1;
    }
  }
d1547 13
a1559 1
  return bad ? TCL_ERROR : TCL_OK;
d1571 3
a1573 3
int argc;
char **argv;
struct funtab *functions;
d1578 6
a1583 6
	  Tcl_AppendResult(interp, "The following commands are available:\n", (char *)NULL);
	  for( ftp = functions+1; ftp->ft_name; ftp++ )  {
	    Tcl_AppendResult(interp,  functions->ft_name, ftp->ft_name, " ",
			     ftp->ft_parms, "\n\t(", ftp->ft_comment, ")\n", (char *)NULL);
	  }
	  return TCL_OK;
d1590 3
a1592 3
int	argc;
char	**argv;
struct funtab *functions;
d1598 10
a1607 10
	  bu_vls_init(&str);
	  Tcl_AppendResult(interp, "The following ", functions->ft_name,
			   " commands are available:\n", (char *)NULL);
	  for( ftp = functions+1; ftp->ft_name; ftp++ )  {
	    vls_col_item( &str, ftp->ft_name);
	  }
	  vls_col_eol( &str );
	  Tcl_AppendResult(interp, bu_vls_addr( &str ), (char *)NULL);
	  bu_vls_free(&str);
	  return TCL_OK;
d1615 16
a1630 16
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  register int i;

  if(argc < 2 || MAXARGS < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help press");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d1632 2
a1633 2
  for( i = 1; i < argc; i++ )
    press( argv[i] );
d1635 1
a1635 1
  return TCL_OK;
d1640 4
a1643 4
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1650 1
a1650 1
	  struct bu_vls vls;
d1652 5
a1656 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help summary");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
d1666 14
a1679 14
		case 's':
			flags |= DIR_SOLID;
			break;
		case 'r':
			flags |= DIR_REGION;
			break;
		case 'g':
			flags |= DIR_COMB;
			break;
		default:
		   Tcl_AppendResult(interp, "summary:  S R or G are only valid parmaters\n",
				    (char *)NULL);
		   bad = 1;
		   break;
d1694 20
a1713 20
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
{
    register int i;

    if(argc < 1 || MAXARGS < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help echo");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    for( i=1; i < argc; i++ )  {
      Tcl_AppendResult(interp, i==1 ? "" : " ", argv[i], (char *)NULL);
    }
d1715 1
a1715 1
    Tcl_AppendResult(interp, "\n", (char *)NULL);
d1717 1
a1717 1
    return TCL_OK;
d1723 2
a1724 2
int	argc;
char	*argv[];
d1726 30
a1755 30
  struct bu_vls str;
  char	line[35];
  int o_ipathpos;
  register struct solid *o_illump;

  o_illump = illump;
  bu_vls_init(&str);

  if(state == ST_S_EDIT){
    bu_vls_strcpy( &str, "press accept\npress sill\n" );
    cmdline(&str, 0);
    illump = o_illump;
    bu_vls_strcpy( &str, "M 1 0 0\n");
    cmdline(&str, 0);
    return CMD_OK;
  }else if(state == ST_O_EDIT){
    o_ipathpos = ipathpos;
    bu_vls_strcpy( &str, "press accept\npress oill\n" );
    cmdline(&str, 0);
    (void)chg_state( ST_O_PICK, ST_O_PATH, "savedit");
    illump = o_illump;
    ipathpos = o_ipathpos;
    bu_vls_strcpy( &str, "M 1 0 0\n");
    cmdline(&str, 0);
    return CMD_OK;
  }

  bu_log( "Savedit will only work in an edit state\n");
  bu_vls_free(&str);
  return CMD_BAD;
d1761 105
a1865 24
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
{
  struct cmd_list *clp;
  struct cmd_list *save_cclp;
  struct dm_list *dlp;
  struct dm_list *save_cdlp;
  struct bu_vls vls2;

  if(argc < 1 || 3 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help aim");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(argc == 1){
    for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
      if(clp->aim)
a1868 3
      else
	Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
			 "\n", (char *)NULL);
d1870 1
a1870 79
    if(clp->aim)
      Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
		       bu_vls_addr(&clp->aim->_dmp->dm_pathName),
		       "\n", (char *)NULL);
    else
      Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
		       "\n", (char *)NULL);

    return TCL_OK;
  }

  for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
    if(!strcmp(bu_vls_addr(&clp->name), argv[1]))
      break;

  if(clp == &head_cmd_list &&
     (strcmp(bu_vls_addr(&head_cmd_list.name), argv[1]))){
    Tcl_AppendResult(interp, "f_aim: unrecognized command_window - ", argv[1],
		     "\n", (char *)NULL);
    return TCL_ERROR;
  }

  /* print out the display manager being aimed at */
  if(argc == 2){
    if(clp->aim)
      Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
		       bu_vls_addr(&clp->aim->_dmp->dm_pathName),
		       "\n", (char *)NULL);
    else
      Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ", "\n", (char *)NULL);

    return TCL_OK;
  }

  bu_vls_init(&vls2);

  if(*argv[2] != '.')
    bu_vls_printf(&vls2, ".%s", argv[2]);
  else
    bu_vls_strcpy(&vls2, argv[2]);

  for( BU_LIST_FOR(dlp, dm_list, &head_dm_list.l) )
    if(!strcmp(bu_vls_addr(&vls2), bu_vls_addr(&dlp->_dmp->dm_pathName)))
      break;

  if(dlp == &head_dm_list){
    Tcl_AppendResult(interp, "f_aim: unrecognized pathName - ",
		     bu_vls_addr(&vls2), "\n", (char *)NULL);
    bu_vls_free(&vls2);
    return TCL_ERROR;
  }

  bu_vls_free(&vls2);

  /* already aiming */
  if(clp->aim)
    clp->aim->aim = (struct cmd_list *)NULL;

  clp->aim = dlp;

  /* already being aimed at */
  if(dlp->aim)
    dlp->aim->aim = (struct dm_list *)NULL;

  dlp->aim = clp;

  save_cdlp = curr_dm_list;
  save_cclp = curr_cmd_list;
  curr_dm_list = dlp;
  curr_cmd_list = clp;
  set_scroll();
  curr_dm_list = save_cdlp;
  curr_cmd_list = save_cclp;

  Tcl_AppendResult(interp, bu_vls_addr(&clp->name), " ---> ",
		   bu_vls_addr(&clp->aim->_dmp->dm_pathName),
		   "\n", (char *)NULL);

  return TCL_OK;
d1875 27
a1901 27
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
{
  struct cmd_list *clp;

  if(argc != 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help unaim");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
    if(!strcmp(bu_vls_addr(&clp->name), argv[1]))
      break;

  if(clp == &head_cmd_list &&
     (strcmp(bu_vls_addr(&head_cmd_list.name), argv[1]))){
    Tcl_AppendResult(interp, "f_unaim: unrecognized command_window - ", argv[1],
		     "\n", (char *)NULL);
    return TCL_ERROR;
  }
d1903 2
a1904 2
  if(clp->aim)
    clp->aim->aim = (struct cmd_list *)NULL;
d1906 1
a1906 1
  clp->aim = (struct dm_list *)NULL;
d1908 1
a1908 1
  return TCL_OK;
d1913 29
a1941 29
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
{
  int i;
  int status;
  char *av[2];
  struct dm_list *dml;
  struct shared_info *sip;

  if(argc < 2 || MAXARGS < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help ps");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  dml = curr_dm_list;
  status = mged_attach(&which_dm[DM_PS_INDEX], argc, argv);
  if(status == TCL_ERROR)
    return TCL_ERROR;

  sip = curr_dm_list->s_info;  /* save state info pointer */
  curr_dm_list->s_info = dml->s_info;  /* use dml's state info */
  mged_variables = dml->_mged_variables; /* struct copy */
d1943 2
a1944 2
  bu_free((genptr_t)curr_dm_list->menu_vars,"f_ps: menu_vars");
  curr_dm_list->menu_vars = dml->menu_vars;
d1946 6
a1951 6
  bcopy((void *)dml->_menu_array, (void *)menu_array,
	sizeof(struct menu_item *) * NMENU);
  menuflag = dml->_menuflag;
  menu_top = dml->_menu_top;
  cur_menu = dml->_cur_menu;
  cur_item = dml->_cur_menu_item;
d1953 15
a1967 15
  scroll_top = dml->_scroll_top;
  scroll_active = dml->_scroll_active;
  scroll_y = dml->_scroll_y;
  scroll_edit = dml->_scroll_edit;
  bcopy((void *)dml->_scroll_array, (void *)scroll_array,
	sizeof(struct scroll_item *) * 6);

  dirty = 1;
  refresh();

  curr_dm_list->s_info = sip;  /* restore state info pointer */
  av[0] = "release";
  av[1] = NULL;
  status = f_release(clientData, interp, 1, av);
  curr_dm_list = dml;
d1969 1
a1969 1
  return status;
d1978 29
a2006 29
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
{
  int i;
  int status;
  char *av[2];
  struct dm_list *dml;
  struct shared_info *sip;

  if(argc < 2 || MAXARGS < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help pl");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  dml = curr_dm_list;
  status = mged_attach(&which_dm[DM_PLOT_INDEX], argc, argv);
  if(status == TCL_ERROR)
    return TCL_ERROR;

  sip = curr_dm_list->s_info;  /* save state info pointer */
  curr_dm_list->s_info = dml->s_info;  /* use dml's state info */
  mged_variables = dml->_mged_variables; /* struct copy */
d2008 2
a2009 2
  bu_free((genptr_t)curr_dm_list->menu_vars,"f_pl: menu_vars");
  curr_dm_list->menu_vars = dml->menu_vars;
d2011 6
a2016 6
  bcopy((void *)dml->_menu_array, (void *)menu_array,
	sizeof(struct menu_item *) * NMENU);
  menuflag = dml->_menuflag;
  menu_top = dml->_menu_top;
  cur_menu = dml->_cur_menu;
  cur_item = dml->_cur_menu_item;
d2018 15
a2032 15
  scroll_top = dml->_scroll_top;
  scroll_active = dml->_scroll_active;
  scroll_y = dml->_scroll_y;
  scroll_edit = dml->_scroll_edit;
  bcopy( (void *)dml->_scroll_array, (void *)scroll_array,
	sizeof(struct scroll_item *) * 6);

  dirty = 1;
  refresh();

  curr_dm_list->s_info = sip;  /* restore state info pointer */
  av[0] = "release";
  av[1] = NULL;
  status = f_release(clientData, interp, 1, av);
  curr_dm_list = dml;
d2034 1
a2034 1
  return status;
d2039 14
a2052 7
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  if(argc < 1 || 1 < argc){
    struct bu_vls vls;
d2054 1
a2054 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help mged_update");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d2056 2
a2057 1
  event_check(1);  /* non-blocking */
d2059 1
a2059 2
  if( sedraw > 0)
    sedit();
d2061 1
a2061 3
  refresh();

  return TCL_OK;
d2066 40
a2105 40
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  register struct dm_list *p;

  if(argc < 1 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help winset");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* print pathname of drawing window with primary focus */
  if( argc == 1 ){
    Tcl_AppendResult(interp, bu_vls_addr(&pathName), (char *)NULL);
    return TCL_OK;
  }

  /* change primary focus to window argv[1] */
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l ) ){
    if( !strcmp( argv[1], bu_vls_addr( &p->_dmp->dm_pathName ) ) ){
      curr_dm_list = p;

      if(curr_dm_list->aim)
	curr_cmd_list = curr_dm_list->aim;
      else
	curr_cmd_list = &head_cmd_list;

      return TCL_OK;
    }
  }

  Tcl_AppendResult(interp, "Unrecognized pathname - ", argv[1],
		    "\n", (char *)NULL);
  return TCL_ERROR;
@


11.165
log
@BParker additions of new commands
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.164 1997/05/28 22:34:49 mike Exp bparker $ (BRL)";
d831 7
a837 1
    Tcl_LinkVar(interp, "dbip", (char *)&dbip, TCL_LINK_INT|TCL_LINK_READ_ONLY);
@


11.164
log
@Added synonym of "viewsize" for "size" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.163 1997/05/28 22:32:18 mike Exp mike $ (BRL)";
d158 1
d190 1
d217 2
a218 1
"getknob", cmd_getknob,
a244 1
"load_dv", f_load_dv,
d249 1
d260 1
d279 1
d316 1
d330 1
d1939 4
d1949 1
d2004 4
d2014 1
d2082 1
a2082 1
    Tcl_AppendResult(interp, bu_vls_addr(&pathName), "\n", (char *)NULL);
@


11.163
log
@BParker "unaim" addition
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.162 1997/05/21 12:53:12 bparker Exp bparker $ (BRL)";
d809 4
@


11.162
log
@mods to cmd_get
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.161 1997/05/09 21:03:10 bparker Exp bparker $ (BRL)";
d330 1
d1855 38
@


11.161
log
@*- no longer checking for MGED_TCL_LIBRARY
*- mods to handle mged's tcl scripts being in its own subdirectory
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.160 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d927 1
a927 1
    Tcl_AppendElement(interp, bu_vls_addr(&tkName));
d937 1
a937 1
  Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->aim->_dmp->dm_tkName));
@


11.160
log
@modify calls to Tcl_Eval
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.159 1997/04/23 18:31:41 bparker Exp bparker $ (BRL)";
d652 1
d748 2
a749 5
  filename = getenv("MGED_TCL_LIBRARY");

  if(filename == NULL)
#ifdef MGED_TCL_LIBRARY
    filename = MGED_TCL_LIBRARY;
d751 1
a751 1
    filename = "/usr/brlcad/tclscripts";
d754 4
a757 1
  bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 %s]", filename);
d760 2
@


11.159
log
@mods to f_ps() and f_pl
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.158 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d89 9
a97 1
	static char	cmd[] = "zoom 0.5\n";
d99 3
a101 4
	if(argc < 4 || 4 < argc){
	  Tcl_Eval(interp, "help L");
	  return TCL_ERROR;
	}
d103 6
a108 2
	if( atoi(argv[1]) != 0 )
	  return Tcl_Eval( interp, cmd );
d110 1
a110 1
	return TCL_OK;
d125 13
a137 1
	static char	cmd[] = "zoom 2\n";
d139 6
a144 4
	if(argc < 4 || 4 < argc){
	  Tcl_Eval(interp, "help R");
	  return TCL_ERROR;
	}
d146 1
a146 3
	if( atoi(argv[1]) != 0 )
		return Tcl_Eval( interp, cmd );
	return TCL_OK;
d551 6
a556 1
    Tcl_Eval(interp, "help loadtk");
d586 6
a591 1
      Tcl_Eval(interp, "help output_hook");
a594 7
    if (argc > 2) {
	Tcl_AppendResult(interp,
			 "too many args: should be \"output_hook [hookName]\"",
			 (char *)NULL);
	return TCL_ERROR;
    }

d818 3
a820 1
    (void)Tcl_Eval(interp, "set wdbp [wdb_open .db disk $dbip]" );
d1428 6
a1433 1
	  Tcl_Eval(interp, "help ?");
d1492 6
a1497 1
      Tcl_Eval(interp, "help sync");
d1605 6
a1610 1
    Tcl_Eval(interp, "help press");
d1632 6
a1637 1
	  Tcl_Eval(interp, "help summary");
d1684 6
a1689 1
      Tcl_Eval(interp, "help echo");
d1755 6
a1760 1
    Tcl_Eval(interp, "help aim");
d1869 6
a1874 1
    Tcl_Eval(interp, "help ps");
d1929 6
a1934 1
    Tcl_Eval(interp, "help pl");
d1979 6
a1984 1
    Tcl_Eval(interp, "help mged_update");
d2008 6
a2013 1
    Tcl_Eval(interp, "help winset");
@


11.158
log
@mods so that commands check args internally
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.157 1997/04/14 12:27:11 bparker Exp bparker $ (BRL)";
d747 1
a747 1
    for (ctp = cmdtab+1; ctp->ct_name != NULL; ctp++) {
d1806 1
a1806 1
  char **av;
d1816 2
a1817 12
  av = (char **)bu_malloc(sizeof(char *) * (argc + 2), "f_ps: av");

  /* Load the argument vector */
  av[0] = "attach";
  for(i = 1; i < argc + 1; ++i)
    av[i] = argv[i - 1];
  av[i] = "ps";
  av[++i] = NULL;

  status = f_attach(clientData, interp, i - 1, av);
  if(status == TCL_ERROR){
    bu_free((genptr_t)av, "f_ps: av");
a1818 1
  }
d1822 13
d1843 1
a1844 1
  bu_free((genptr_t)av, "f_ps: av");
d1861 1
a1861 1
  char **av;
d1871 2
a1872 12
  av = (char **)bu_malloc(sizeof(char *) * (argc + 2), "f_pl: av");

  /* Load the argument vector */
  av[0] = "attach";
  for(i = 1; i < argc + 1; ++i)
    av[i] = argv[i - 1];
  av[i] = "plot";
  av[++i] = NULL;

  status = f_attach(clientData, interp, i - 1, av);
  if(status == TCL_ERROR){
    bu_free((genptr_t)av, "f_pl: av");
a1873 1
  }
d1877 13
d1898 1
a1899 1
  bu_free((genptr_t)av, "f_pl: av");
@


11.157
log
@added a few commands: dall, draw, erase, erase_all
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.156 1997/04/04 20:07:18 bparker Exp bparker $ (BRL)";
a66 2
extern Tcl_CmdProc	cmd_fhelp;

d91 2
a92 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d94 1
d116 2
a117 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d119 1
d126 68
a193 139
static struct funtab funtab[] = {
"", "", "Primary command Table.",
        0, 0, 0, FALSE,
"?", "", "summary of available commands",
        cmd_fhelp,0,MAXARGS,TRUE,
"%", "", "escape to interactive shell",
	f_comm,1,1,TRUE,
"3ptarb", "", "makes arb given 3 pts, 2 coord of 4th pt, and thickness",
	f_3ptarb, 1, 27,TRUE,
"adc", "[<a1|a2|dst|dh|dv|hv|dx|dy|dz|xyz|reset|help> value(s)]",
	"control the angle/distance cursor",
        f_adc, 1, 5, TRUE,
"ae", "[-i] azim elev [twist]", "set view using azim, elev and twist angles",
	f_aetview, 3, 5, TRUE,
"aim", "[command_window [pathName of display window]]", "aims command_window at pathName",
        f_aim, 1, 3, TRUE,
"aip", "[fb]", "advance illumination pointer or path position forward or backward",
        f_aip, 1, 2, TRUE,
"analyze", "[arbname]", "analyze faces of ARB",
	f_analyze,1,MAXARGS,TRUE,
"apropos", "keyword", "finds commands whose descriptions contain the given keyword",
        cmd_apropos, 2, 2, TRUE,
"arb", "name rot fb", "make arb8, rotation + fallback",
	f_arbdef,4,4,TRUE,
"arced", "a/b ...anim_command...", "edit matrix or materials on combination's arc",
	f_arced, 3,MAXARGS,TRUE,
"area", "[endpoint_tolerance]", "calculate presented area of view",
	f_area, 1, 2, TRUE,
"attach", "[-d display_string] [-i init_script] [-n name]\n\t\t[-t is_toplevel]\
[-W width] [-N height]\n\t\t[-S square_size] dev_type", "attach to a display manager",
	f_attach,2,MAXARGS,TRUE,
"B", "<objects>", "clear screen, edit objects",
	f_blast,2,MAXARGS,TRUE,
"bev",	"[-t] [-P#] new_obj obj1 op obj2 op obj3 op ...", "Boolean evaluation of objects via NMG's",
	f_bev, 2, MAXARGS, TRUE,
#if 0
"button", "number", "simulates a button press, not intended for the user",
	f_button, 2, 2, FALSE,
#endif
"c", "[-gr] comb_name [boolean_expr]", "create or extend a combination using standard notation",
	f_comb_std,3,MAXARGS,TRUE,
"cat", "<objects>", "list attributes (brief)",
	f_cat,2,MAXARGS,TRUE,
"center", "x y z", "set view center",
	f_center, 4,4, TRUE,
"color", "low high r g b str", "make color entry",
	f_color, 7, 7, TRUE,
"comb", "comb_name <operation solid>", "create or extend combination w/booleans",
	f_comb,4,MAXARGS,TRUE,
"comb_color", "comb R G B", "assign a color to a combination (like 'mater')",
	f_comb_color, 5,5,TRUE,
"copyeval", "new_solid path_to_old_solid",
	"copy an 'evaluated' path solid",
	f_copyeval, 1, 27, TRUE,
"copymat", "a/b c/d", "copy matrix from one combination's arc to another's",
	f_copymat, 3,3,TRUE,
"cp", "from to", "copy [duplicate] object",
	f_copy,3,3, TRUE,
"cpi", "from to", "copy cylinder and position at end of original cylinder",
	f_copy_inv,3,3,TRUE,
"d", "<objects>", "remove objects from the screen",
	f_erase,2,MAXARGS,TRUE,
"dall", "<objects>", "remove all occurrences of object(s) from the screen",
	f_erase_all,2,MAXARGS,TRUE,
"db", "command", "database manipulation routines",
	cmd_db, 1, MAXARGS, TRUE,
"dbconcat", "file [prefix]", "concatenate 'file' onto end of present database.  Run 'dup file' first.",
	f_concat, 2, 3, TRUE,
"debugbu", "[hex_code]", "Show/set debugging bit vector for libbu",
	f_debugbu,1,2,TRUE,
"debugdir", "", "Print in-memory directory, for debugging",
	f_debugdir, 1, 1, TRUE,
"debuglib", "[hex_code]", "Show/set debugging bit vector for librt",
	f_debuglib,1,2,TRUE,
"debugmem", "", "Print librt memory use map",
	f_debugmem, 1, 1, TRUE,
"debugnmg", "[hex code]", "Show/set debugging bit vector for NMG",
	f_debugnmg,1,2,TRUE,
"decompose", "nmg_solid [prefix]", "decompose nmg_solid into maximally connected shells",
	f_decompose, 2, 3, TRUE,
"delay", "sec usec", "Delay for the specified amount of time",
	f_delay,3,3,TRUE,
"dm", "set var [val]", "Do display-manager specific command",
	f_dm, 2, MAXARGS, TRUE,
"draw", "<objects>", "draw objects",
	f_edit,2,MAXARGS,TRUE,
"dup", "file [prefix]", "check for dup names in 'file'",
	f_dup, 2, 3, TRUE,
"E", " [-s] <objects>", "evaluated edit of objects. Option 's' provides a slower, but better fidelity evaluation",
	f_evedit,2,MAXARGS,TRUE,
"e", "<objects>", "edit objects",
	f_edit,2,MAXARGS,TRUE,
"eac", "Air_code(s)", "display all regions with given air code",
	f_eac, 2, MAXARGS,TRUE,
"echo", "[text]", "echo arguments back",
	cmd_echo, 1, MAXARGS, TRUE,
"edcodes", "object(s)", "edit region ident codes",
	f_edcodes, 2, MAXARGS, TRUE,
"edmater", "comb(s)", "edit combination materials",
	f_edmater, 2, MAXARGS, TRUE,
"edcolor", "", "text edit color table",
	f_edcolor, 1, 1, TRUE,
"edcomb", "combname Regionflag regionid air los [GIFTmater]", "edit combination record info",
	f_edcomb,6,7,TRUE,
"edgedir", "[delta_x delta_y delta_z]|[rot fb]", "define direction of ARB edge being moved",
	f_edgedir, 3, 4, TRUE,
"erase", "<objects>", "remove objects from the screen",
	f_erase,2,MAXARGS,TRUE,
"erase_all", "<objects>", "remove all occurrences of object(s) from the screen",
	f_erase_all,2,MAXARGS,TRUE,
"ev",	"[-dnqstuvwT] [-P #] <objects>", "evaluate objects via NMG tessellation",
	f_ev, 2, MAXARGS, TRUE,
"eqn", "A B C", "planar equation coefficients",
	f_eqn, 4, 4, TRUE,
"exit", "", "exit",
	f_quit,1,1,TRUE,
"extrude", "#### distance", "extrude dist from face",
	f_extrude,3,3,TRUE,
"expand", "wildcard expression", "expands wildcard expression",
        cmd_expand, 1, MAXARGS, TRUE,
"eye_pt", "mx my mz", "set eye point to given model coordinates (in mm)",
	f_eye_pt, 4, 4, TRUE,
"facedef", "####", "define new face for an arb",
	f_facedef, 2, MAXARGS, TRUE,
"facetize", "[-tT] [-P#] new_obj old_obj(s)", "convert objects to faceted NMG objects at current tol",
	f_facetize, 3, MAXARGS, TRUE,
"find", "<objects>", "find all references to objects",
	f_find, 1, MAXARGS, TRUE,
"fix", "", "fix display after hardware error",
	f_fix,1,1,TRUE,
"fracture", "NMGsolid [prefix]", "fracture an NMG solid into many NMG solids, each containing one face\n",
	f_fracture, 2, 3, TRUE,
"g", "groupname <objects>", "group objects",
	f_group,3,MAXARGS,TRUE,
"getknob", "knobname", "Gets the current setting of the given knob",
        cmd_getknob, 2, 2, TRUE,
"output_hook", "output_hook_name",
       "All output is sent to the Tcl procedure \"output_hook_name\"",
	cmd_output_hook, 1, 2, TRUE,
d195 1
a195 170
"H", "plotfile [step_size %epsilon]", "produce hidden-line unix-plot",
	f_hideline,2,4,TRUE,
#endif
"help", "[commands]", "give usage message for given commands",
	f_help,0,MAXARGS,TRUE,
"history", "[-delays]", "list command history",
	f_history, 1, 4,TRUE,
"hist_prev", "", "Returns previous command in history",
        cmd_prev, 1, 1, TRUE,
"hist_next", "", "Returns next command in history",
        cmd_next, 1, 1, TRUE,
"hist_add", "[command]", "Adds command to the history (without executing it)",
        cmd_hist_add, 1, 2, TRUE,
"i", "obj combination [operation]", "add instance of obj to comb",
	f_instance,3,4,TRUE,
"idents", "file object(s)", "make ascii summary of region idents",
	f_tables, 3, MAXARGS, TRUE,
"ill", "name", "illuminate object",
	f_ill,2,2,TRUE,
"in", "[-f] [-s] parameters...", "keyboard entry of solids.  -f for no drawing, -s to enter solid edit",
	f_in, 1, MAXARGS, TRUE,
"inside", "", "finds inside solid per specified thicknesses",
	f_inside, 1, MAXARGS, TRUE,
"item", "region item [air [GIFTmater [los]]]", "set region ident codes",
	f_itemair,3,6,TRUE,
"joint", "command [options]", "articulation/animation commands",
	f_joint, 1, MAXARGS, TRUE,
"journal", "[-d] fileName", "record all commands and timings to journal",
	f_journal, 1, 3, TRUE,
"keep", "keep_file object(s)", "save named objects in specified file",
	f_keep, 3, MAXARGS, TRUE,
"keypoint", "[x y z | reset]", "set/see center of editing transformations",
	f_keypoint,1,4, TRUE,
"kill", "[-f] <objects>", "delete object[s] from file",
	f_kill,2,MAXARGS,TRUE,
"killall", "<objects>", "kill object[s] and all references",
	f_killall, 2, MAXARGS,TRUE,
"killtree", "<object>", "kill complete tree[s] - BE CAREFUL",
	f_killtree, 2, MAXARGS, TRUE,
"knob", "[-e -i -v] [id [val]]", "emulate knob twist",
	f_knob,1,MAXARGS, TRUE,
"l", "<objects>", "list attributes (verbose)",
	cmd_list,2,MAXARGS, TRUE,
"L",  "1|0 xpos ypos", "handle a left mouse event",
	cmd_left_mouse, 4,4, TRUE,
"labelvert", "object[s]", "label vertices of wireframes of objects",
	f_labelvert, 2, MAXARGS, TRUE,
"listeval", "", "lists 'evaluated' path solids",
	f_pathsum, 1, MAXARGS, TRUE,
"load_dv", "", "Initializes the view matrices",
        f_load_dv, 1, 1, TRUE,
"loadtk", "[DISPLAY]", "Initializes Tk window library",
        cmd_tk, 1, 2, TRUE,
"lookat", "x y z", "Adjust view to look at given coordinates",
	f_lookat, 4,4,TRUE,
"ls", "", "table of contents",
	dir_print,1,MAXARGS, TRUE,
"M", "1|0 xpos ypos", "handle a middle mouse event",
	f_mouse, 4,4, TRUE,
"make", "name <arb8|sph|ellg|tor|tgc|rpc|rhc|epa|ehy|eto|part|grip|half|nmg|pipe>", "create a primitive",
	f_make,3,3,TRUE,
"make_bb", "new_rpp_name obj1_or_path1 [list of objects or paths ...]", "make a bounding box solid enclosing specified objects/paths",
	f_make_bb, 3, MAXARGS, TRUE,
"mater", "comb [material]", "assign/delete material to combination",
	f_mater,2,8,TRUE,
"matpick", "# or a/b", "select arc which has matrix to be edited, in O_PATH state",
	f_matpick, 2,2,TRUE,
"memprint", "", "print memory maps",
	f_memprint, 1, 1,TRUE,
"mirface", "#### axis", "mirror an ARB face",
	f_mirface,3,3,TRUE,
"mirror", "old new axis", "mirror solid or combination around axis",
	f_mirror,4,4,TRUE,
"model2view", "mx my mz", "convert point in model coords (mm) to view coords",
	f_model2view, 4, 4, TRUE,
"mv", "old new", "rename object",
	f_name,3,3,TRUE,
"mvall", "oldname newname", "rename object everywhere",
	f_mvall, 3, 3,TRUE,
"nirt", "", "trace a single ray from current view",
	f_nirt,1,MAXARGS,TRUE,
"nmg_simplify", "[arb|tgc|ell|poly] new_solid nmg_solid", "simplify nmg_solid, if possible",
	f_nmg_simplify, 3,4,TRUE,
"oed", "path_lhs path_rhs", "Go from view to object_edit of path_lhs/path_rhs",
	cmd_oed, 3, 3, TRUE,
"opendb", "database.g", "Close current .g file, and open new .g file",
	f_opendb, 2, 3, TRUE,
"orientation", "x y z w", "Set view direction from quaternion",
	f_orientation, 5, 5,TRUE,
"orot", "[-i] xdeg ydeg zdeg", "rotate object being edited",
	f_rot_obj, 4, 5,TRUE,
"oscale", "factor", "scale object by factor",
	f_sc_obj,2,2,TRUE,
"overlay", "file.plot [name]", "Read UNIX-Plot as named overlay",
	f_overlay, 2, 3,TRUE,
"p", "dx [dy dz]", "set parameters",
	f_param,2,4,TRUE,
"paths", "pattern", "lists all paths matching input path",
	f_pathsum, 1, MAXARGS,TRUE,
"pathlist", "name(s)", "list all paths from name(s) to leaves",
	cmd_pathlist, 1, MAXARGS,TRUE,
"permute", "tuple", "permute vertices of an ARB",
	f_permute,2,2,TRUE,
"plot", "[-float] [-zclip] [-2d] [-grid] [out_file] [|filter]", "make UNIX-plot of view",
	f_plot, 2, MAXARGS,TRUE,
"pl", "[-float] [-zclip] [-2d] [-grid] [out_file] [|filter]", "Experimental - uses dm-plot:make UNIX-plot of view",
	f_pl, 2, MAXARGS,TRUE,
"polybinout", "file", "store vlist polygons into polygon file (experimental)",
	f_polybinout, 2, 2,TRUE,
"pov", "args", "experimental:  set point-of-view",
	f_pov, 3+4+1, MAXARGS,TRUE,
"prcolor", "", "print color&material table",
	f_prcolor, 1, 1,TRUE,
"prefix", "new_prefix object(s)", "prefix each occurrence of object name(s)",
	f_prefix, 3, MAXARGS,TRUE,
"preview", "[-v] [-d sec_delay] rt_script_file", "preview new style RT animation script",
	f_preview, 2, MAXARGS,TRUE,
"press", "button_label", "emulate button press",
	f_press,2,MAXARGS,TRUE,
"ps", "[-f font] [-t title] [-c creator] [-s size in inches] [-l linewidth] file", "creates a postscript file of the current view",
        f_ps, 2, MAXARGS,TRUE,
"push", "object[s]", "pushes object's path transformations to solids",
	f_push, 2, MAXARGS,TRUE,
"putmat", "a/b {I | m0 m1 ... m16}", "replace matrix on combination's arc",
	f_putmat, 3,MAXARGS,TRUE,
"q", "", "quit",
	f_quit,1,1,TRUE,
"quit", "", "quit",
	f_quit,1,1,TRUE,
"qorot", "x y z dx dy dz theta", "rotate object being edited about specified vector",
	f_qorot, 8, 8,TRUE,
"qvrot", "dx dy dz theta", "set view from direction vector and twist angle",
	f_qvrot, 5, 5,TRUE,
"r", "region <operation solid>", "create or extend a Region combination",
	f_region,4,MAXARGS,TRUE,
"R",  "1|0 xpos ypos", "handle a right mouse event",
	cmd_right_mouse, 4,4, TRUE,
"rcodes", "filename", "read region ident codes from filename",
        f_rcodes, 2, 2, TRUE,
"red", "object", "edit a group or region using a text editor",
	f_red, 2, 2,TRUE,
"refresh", "", "send new control list",
	f_refresh, 1,1,TRUE,
"regdebug", "", "toggle register print",
	f_regdebug, 1,2,TRUE,
"regdef", "item [air [los [GIFTmaterial]]]", "change next region default codes",
	f_regdef, 2, 5,TRUE,
"regions", "file object(s)", "make ascii summary of regions",
	f_tables, 3, MAXARGS,TRUE,
"release", "[name]", "release display processor",
	f_release,1,2,TRUE,
"rfarb", "", "makes arb given point, 2 coord of 3 pts, rot, fb, thickness",
	f_rfarb, 1, 27,TRUE,
"rm", "comb <members>", "remove members from comb",
	f_rm,3,MAXARGS,TRUE,
"rmater", "filename", "read combination materials from filename",
        f_rmater, 2, 2, TRUE,
"rmats", "file", "load view(s) from 'savekey' file",
	f_rmats,2,MAXARGS,TRUE,
"rotobj", "[-i] xdeg ydeg zdeg", "rotate object being edited",
	f_rot_obj, 4, 5,TRUE,
"rrt", "prog [options]", "invoke prog with view",
	f_rrt,2,MAXARGS,TRUE,
"rt", "[options]", "do raytrace of view",
	f_rt,1,MAXARGS,TRUE,
"rtcheck", "[options]", "check for overlaps in current view",
	f_rtcheck,1,MAXARGS,TRUE,
#if 0
"savedit", "", "save current edit and remain in edit state",
	f_savedit, 1, 1,FALSE,
d197 81
a277 16
"savekey", "file [time]", "save keyframe in file (experimental)",
	f_savekey,2,MAXARGS,TRUE,
"saveview", "file [args]", "save view in file for RT",
	f_saveview,2,MAXARGS,TRUE,
"showmats", "path", "show xform matrices along path",
	f_showmats,2,2,TRUE,
"sed", "<path>", "solid-edit named solid",
	f_sed,2,2,TRUE,
"setview", "x y z", "set the view given angles x, y, and z in degrees",
        f_setview,4,4,TRUE,
"shells", "nmg_model", "breaks model into seperate shells",
	f_shells, 2,2,TRUE,
"shader", "comb material [arg(s)]", "assign materials (like 'mater')",
	f_shader, 3,MAXARGS,TRUE,
"size", "size", "set view size",
	f_view, 2,2,TRUE,
d279 1
a279 2
"slider", "slider number, value", "adjust sliders using keyboard",
	f_slider, 3,3,FALSE,
d281 50
a330 95
#if 1
"sliders", "[{on|off}]", "turns the sliders on or off, or reads current state",
        cmd_sliders, 1, 2, TRUE,
#else
"sliders", "[{on|off}]", "turns the sliders on or off, or reads current state",
        cmd_sliders, 1, 2, TRUE,
#endif
"solids", "file object(s)", "make ascii summary of solid parameters",
	f_tables, 3, MAXARGS,TRUE,
"solids_on_ray", "h v", "List all displayed solids along a ray",
        cmd_solids_on_ray, 1, 3, TRUE,
"status", "", "get view status",
	f_status, 1,1,TRUE,
"summary", "[s r g]", "count/list solid/reg/groups",
	f_summary,1,2,TRUE,
"sv", "x y [z]", "Move view center to (x, y, z)",
	f_slewview, 3, 4,TRUE,
"svb", "", "set view reference base",
        f_svbase, 1, 1, TRUE,
"sync",	"",	"forces UNIX sync",
	f_sync, 1, 1,TRUE,
"t", "", "table of contents",
	dir_print,1,MAXARGS,TRUE,
#if 0
"tab", "object[s]", "tabulates objects as stored in database",
	f_tabobj, 2, MAXARGS,TRUE,
#endif
"ted", "", "text edit a solid's parameters",
	f_tedit,1,1,TRUE,
"tie", "pathName1 pathName2", "tie display manager pathName1 to display manager pathName2",
        f_tie, 3,3,TRUE,
"title", "string", "change the title",
	f_title,1,MAXARGS,TRUE,
"tol", "[abs #] [rel #] [norm #] [dist #] [perp #]", "show/set tessellation and calculation tolerances",
	f_tol, 1, 11,TRUE,
"tops", "", "find all top level objects",
	f_tops,1,1,TRUE,
"track", "<parameters>", "adds tracks to database",
	f_amtrack, 1, 27,TRUE,
"tran", "[-i] x y [z]", "absolute translate using view coordinates",
        f_tran, 3, 5,TRUE,
"translate", "x y z", "trans object to x,y, z",
	f_tr_obj,4,4,TRUE,
"tree",	"object(s)", "print out a tree of all members of an object",
	f_tree, 2, MAXARGS,TRUE,
"units", "[mm|cm|m|in|ft|...]", "change units",
	f_units,1,2,TRUE,
"untie", "pathName", "untie display manager pathName",
        f_untie, 2,2,TRUE,
"mged_update", "", "handle outstanding events and refresh",
        f_update, 1,1,TRUE,
"vars",	"[var=opt]", "assign/display mged variables",
	f_set,1,2,TRUE,
#if 1
"vdraw", "write|insert|delete|read|length|show [args]", "Expermental drawing (cnuzman)",
	cmd_vdraw, 2, 7, TRUE,
"viewget", "center|size|eye|ypr|quat", "Experimental - return high-precision view parameters.",
	cmd_viewget, 2, 2, TRUE,
"viewset","center|eye|size|ypr|quat|aet","Experimental - set several view parameters at once.",
	cmd_viewset, 3, MAXARGS, TRUE,
#endif
"view2model", "mx my mz", "convert point in view coords to model coords (mm)",
	f_view2model, 4, 4, TRUE,
"vrmgr", "host {master|slave|overview}", "link with Virtual Reality manager",
	f_vrmgr, 3, MAXARGS,TRUE,
"vrot", "xdeg ydeg zdeg", "rotate viewpoint",
	f_vrot,4,4,TRUE,
"vrot_center", "v|m x y z", "set center point of viewpoint rotation, in model or view coords",
	f_vrot_center, 5, 5,TRUE,
"wcodes", "filename object(s)", "write region ident codes to filename",
        f_wcodes, 3, MAXARGS, TRUE,
"whatid", "region_name", "display ident number for region",
	f_whatid, 2, MAXARGS,TRUE,
"whichair", "air_codes(s)", "lists all regions with given air code",
	f_which_air, 2, MAXARGS,TRUE,
"whichid", "ident(s)", "lists all regions with given ident code",
	f_which_id, 2, MAXARGS,TRUE,
"which_shader", "Shader(s)", "lists all combinations using the given shaders",
	f_which_shader, 2, MAXARGS,TRUE,
"who", "[r(eal)|p(hony)|b(oth)]", "list the top-level objects currently being displayed",
	cmd_who,1,2,TRUE,
"winset", "pathname", "sets the current display manager to pathname",
        f_winset, 1, 2, TRUE,
"wmater", "filename comb(s)", "write combination materials to filename",
        f_wmater, 3, MAXARGS, TRUE,
"x", "lvl", "print solid table & vector list",
	f_debug, 1,2,TRUE,
"xpush", "object", "Experimental Push Command",
	f_xpush, 2,2,TRUE,
"Z", "", "zap all objects off screen",
	f_zap,1,1,TRUE,
"zoom", "scale_factor", "zoom view in or out",
	f_zoom, 2,2,TRUE,
0, 0, 0,
	0, 0, 0, 0
d398 1
a398 1

d474 1
d527 2
a528 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d530 1
d557 2
a558 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d560 1
d742 1
a742 1
    register struct funtab *ftp;
d747 1
a747 1
    for (ftp = funtab+1; ftp->ft_name != NULL; ftp++) {
d750 1
a750 1
	bu_vls_strcat(&temp, ftp->ft_name);
d753 1
a753 1
	    bu_log("WARNING:  '%s' name collision (%s)\n", ftp->ft_name,
d758 1
a758 1
	bu_vls_strcat(&temp, ftp->ft_name);
d760 4
a763 15
	if (ftp->tcl_converted) {
	    (void)Tcl_CreateCommand(interp, ftp->ft_name, ftp->ft_func,
				   (ClientData)ftp, (Tcl_CmdDeleteProc *)NULL);
	    (void)Tcl_CreateCommand(interp, bu_vls_addr(&temp), ftp->ft_func,
				   (ClientData)ftp, (Tcl_CmdDeleteProc *)NULL);
	} else {
#if 0
	    (void)Tcl_CreateCommand(interp, ftp->ft_name, cmd_wrapper, 	    
			           (ClientData)ftp, (Tcl_CmdDeleteProc *)NULL);
	    (void)Tcl_CreateCommand(interp, bu_vls_addr(&temp), cmd_wrapper,
				   (ClientData)ftp, (Tcl_CmdDeleteProc *)NULL);
#else
	    bu_log("cmd_setup: %s needs to be Tcl converted\n", ftp->ft_name);
#endif
	}
a765 1
#if 1
a779 12
#endif

#if 0
    /* Link to some internal variables */
    Tcl_LinkVar(interp, "mged_center_x", (char *)&toViewcenter[MDX],
		TCL_LINK_DOUBLE);
    Tcl_LinkVar(interp, "mged_center_y", (char *)&toViewcenter[MDY],
		TCL_LINK_DOUBLE);
    Tcl_LinkVar(interp, "mged_center_z", (char *)&toViewcenter[MDZ],
		TCL_LINK_DOUBLE);

#endif
d786 7
a792 7
	/* Provide Tcl interfaces to the fundamental BRL-CAD libraries */
	bn_tcl_setup(interp);
	rt_tcl_setup(interp);

	Tcl_LinkVar(interp, "dbip", (char *)&dbip, TCL_LINK_INT|TCL_LINK_READ_ONLY);
	/* XXX Change from .db to "db" & eliminate mged-specific "db" command */
	(void)Tcl_Eval(interp, "set wdbp [wdb_open .db disk $dbip]" );
d1342 4
a1345 1
	functions = funtab;
a1384 83
int
mged_cmd_arg_check(argc, argv, in_functions)
int argc;
char **argv;
struct funtab in_functions[];
{
    register struct funtab *ftp;
    struct funtab *functions;
    char *cp;

    if(argc == 0)
      return 0; /* Good */

    /* if no function table is provided, use the default mged function table */
    if( in_functions == (struct funtab *)NULL )
	functions = funtab;
    else
    	functions = in_functions;

    if((cp = strstr(argv[0], "_mged_")) == argv[0])
      cp = cp + 6;
    else
      cp = argv[0];

    for (ftp = &functions[1]; ftp->ft_name; ftp++) {
	if (strcmp(ftp->ft_name, cp) != 0)
	    continue;

	/* We have a match */
	if ((ftp->ft_min <= argc) && (argc <= ftp->ft_max))
	  return 0;  /* Good */

	Tcl_AppendResult(interp, "Usage: ", functions[0].ft_name, ftp->ft_name,
			 " ", ftp->ft_parms, "\n\t(", ftp->ft_comment,
			 ")\n", (char *)NULL);

	return 1;    /* Bad */
    }

    return 0; /* Good */
}



/*
 *               C M D _ A P R O P O S
 *
 * Returns a list of commands whose descriptions contain the given keyword
 * contained in argv[1].  This version is case-sensitive.
 */

int
cmd_apropos(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    register struct funtab *ftp;
    char *keyword;

    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
      return TCL_ERROR;

    if( argc < 2 )  {
      Tcl_AppendResult(interp, "apropos: insufficient args", (char *)NULL);
      return TCL_ERROR;
    }

    keyword = argv[1];
    if (keyword == NULL)
	keyword = "";
    
    for (ftp = funtab+1; ftp->ft_name != NULL; ftp++)
	if (strstr(ftp->ft_name, keyword) != NULL ||
	    strstr(ftp->ft_parms, keyword) != NULL ||
	    strstr(ftp->ft_comment, keyword) != NULL)
	    Tcl_AppendElement(interp, ftp->ft_name);
	
    return TCL_OK;
}


d1399 2
a1400 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1402 1
a1414 3
#if 0
	(void)signal(SIGINT, cur_sigint);
#endif
d1430 7
a1436 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1438 1
d1458 2
a1459 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1461 1
a1511 21
int f_help2();

int
f_help(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
#if 0
	/* There needs to be a better way to trigger this */
	if( argc <= 1 )  {
		/* User typed just "help" */
		system("Mosaic http://ftp.arl.mil/ftp/brl-cad/html/mged &");
	}
#endif
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;

	return f_help2(argc, argv, &funtab[0]);
}
a1531 27
/*
 *			F _ F H E L P
 *
 *  Print a fast help message;  just tabulate the commands available.
 */
int
cmd_fhelp( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	register struct funtab *ftp;
	struct bu_vls		str;

	bu_vls_init(&str);
	for( ftp = &funtab[1]; ftp->ft_name; ftp++ )  {
		vls_col_item( &str, ftp->ft_name);
	}
	vls_col_eol( &str );

	Tcl_AppendResult(interp, bu_vls_addr( &str), (char *)NULL);

	bu_vls_free(&str);
	return TCL_OK;
}

d1566 2
a1567 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1569 1
d1588 2
a1589 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1591 1
d1635 2
a1636 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1638 1
d1701 4
a1704 2
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
        return TCL_ERROR;
d1810 2
a1811 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1813 1
d1863 2
a1864 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1866 1
d1906 2
a1907 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1909 1
d1930 2
a1931 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1933 1
@


11.156
log
@mods to attach's command table entry
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.155 1997/03/28 21:39:08 jra Exp bparker $ (BRL)";
d184 4
a187 2
"d", "<objects>", "delete list of objects",
	f_delobj,2,MAXARGS,TRUE,
d208 2
d230 4
@


11.155
log
@Added lookat command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.154 1997/03/28 17:46:51 pjt Exp jra $ (BRL)";
d152 2
a153 2
"attach", "[-d display_string] [-i init_script] [-n name] [-t is_toplevel]\n\
\t\t[-W width] [-N height] [-S square_size] dev_type", "attach to a display manager",
@


11.154
log
@Enhanced item command to support setting GIFTmater and los, too
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.153 1997/03/20 23:00:39 bparker Exp pjt $ (BRL)";
d309 2
@


11.153
log
@mod to attach command entry
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.152 1997/03/12 20:45:46 jra Exp bparker $ (BRL)";
d279 2
a280 2
"item", "region item [air]", "change item # or air code",
	f_itemair,3,4,TRUE,
d399 1
a399 1
"regdef", "item [air] [los] [GIFTmaterial]", "change next region default codes",
@


11.152
log
@removed dependencies on db.h.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.151 1997/03/11 21:41:43 jra Exp jra $ (BRL)";
d153 1
a153 1
\t\t[-W width] [-N height] [-S square_size] dev_type", "attach to a display processor of device type X, ogl, or glx",
@


11.151
log
@Changed 'E' command. Also include Parker's changes to 'journal'.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.150 1997/03/07 10:47:27 mike Exp bparker $ (BRL)";
a44 1
#include "db.h"
@


11.150
log
@Added Tcl hooks for new LIBWDB stuff
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.149 1997/03/05 04:05:29 mike Exp mike $ (BRL)";
d209 1
a209 1
"E", "<objects>", "evaluated edit of objects",
d284 2
a285 2
"journal", "fileName", "record all commands and timings to journal",
	f_journal, 1, 2, TRUE,
@


11.149
log
@Attach to LIBRT Tcl commands, too.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.148 1997/03/05 02:03:00 mike Exp mike $ (BRL)";
d1018 4
@


11.148
log
@Changed to bn_tcl_setup(), moved mged/math.c to libbn/bn-tcl.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.147 1997/02/28 21:34:51 bparker Exp mike $ (BRL)";
d1015 1
d1017 1
@


11.147
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.146 1997/02/25 14:45:36 jra Exp bparker $ (BRL)";
d1015 1
a1015 1
	math_setup();
@


11.146
log
@removed "tab" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.145 1997/02/24 22:04:02 bparker Exp jra $ (BRL)";
d865 1
d881 1
@


11.145
log
@mods to cmd_init
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.144 1997/02/14 22:09:28 bparker Exp bparker $ (BRL)";
d469 1
d472 1
@


11.144
log
@mods to cmd_close
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.143 1997/02/14 08:52:45 mike Exp bparker $ (BRL)";
d845 1
d849 6
d1029 2
a1030 2
  if(argc != 3){
    Tcl_AppendResult(interp, "Usage: cmd_init name id", (char *)NULL);
d1034 1
a1034 2
  /* First, search to see if there exists a command window with the name
     in argv[1] */
d1115 1
d1125 1
@


11.143
log
@Added 3 new commands.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.142 1997/02/14 08:36:29 mike Exp mike $ (BRL)";
d1066 1
a1066 1
    Tcl_AppendResult(interp, "Usage: cmd_init id", (char *)NULL);
d1077 4
a1080 1
    Tcl_AppendResult(interp, "cmd_init: did not find ", argv[1], (char *)NULL);
@


11.142
log
@BParker TRY_NEW_MGED_VARS stuff
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.141 1997/02/13 17:02:00 jra Exp bparker $ (BRL)";
d237 2
d328 2
d505 2
d523 1
a523 1
"who", "[r(eal)|p(hony)|b(oth)]", "list the displayed objects",
@


11.141
log
@"listeval" and "copyeval" now accept space delimited paths or '/' delimited paths.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.140 1997/02/13 15:45:31 pjt Exp jra $ (BRL)";
d844 1
d846 1
d1101 3
@


11.140
log
@Put copymat entry in proper position in array
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.139 1997/02/12 21:17:52 pjt Exp $ (BRL)";
d176 1
a176 1
"copyeval", "new_solid path_to_old_solid (separate path components with spaces, not /)",
@


11.139
log
@Added stub for copymat command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.138 1997/02/04 22:12:15 bparker Exp $ (BRL)";
d179 2
a375 2
"copymat", "a/b c/d", "copy matrix from one combination's arc to another's",
	f_copymat, 3,3,TRUE,
@


11.138
log
@turn global mged_rotate_view_around_eye into an mged variable
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.137 1997/02/01 03:14:36 mike Exp bparker $ (BRL)";
d374 2
@


11.137
log
@mged_rotate_view_around_eye is C & Tcl variable which controls
new feature.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.136 1997/02/01 03:05:35 mike Exp mike $ (BRL)";
a63 1
extern int mged_rotate_view_around_eye;	/* shared with chgview.c */
a844 2
  Tcl_LinkVar(interp, "mged_rotate_view_around_eye",
		(char *)&mged_rotate_view_around_eye, TCL_LINK_INT);
@


11.136
log
@BParker: -W and -N for attach
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.135 1997/01/31 05:50:49 mike Exp bparker $ (BRL)";
d64 1
d846 2
@


11.135
log
@Improved commenting.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.134 1997/01/30 00:54:01 mike Exp mike $ (BRL)";
d153 2
a154 1
"attach", "[-d display_string] [-i init_script] [-n name] dev_type", "attach to a display processor of device type X, ogl, or glx",
@


11.134
log
@Improved comment on mirror command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.133 1997/01/29 16:39:46 jra Exp mike $ (BRL)";
d405 1
a405 1
"rmats", "file", "load views from file (experimental)",
@


11.133
log
@Added which_shader command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.132 1997/01/29 16:30:28 bparker Exp jra $ (BRL)";
d321 1
a321 1
"mirror", "old new axis", "Arb mirror ??",
@


11.132
log
@mods to f_ps, f_plot due to changes in f_attach
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.131 1997/01/24 20:51:58 bparker Exp bparker $ (BRL)";
d512 2
@


11.131
log
@*- new command - cmd_close
*- mods to f_aim
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.130 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d153 2
a154 2
"attach", "device screen", "attach to a display processor on screen",
	f_attach,1,MAXARGS,TRUE,
d2005 1
d2054 7
d2062 1
a2062 1
    if(!strcmp(argv[2], bu_vls_addr(&dlp->_dmp->dm_pathName)))
d2066 3
a2068 2
    Tcl_AppendResult(interp, "f_aim: unrecognized pathName - ", argv[2],
		     "\n", (char *)NULL);
d2072 2
a2079 4
  save_cdlp = curr_dm_list;
  curr_dm_list = dlp;
  save_cclp = curr_cmd_list;

d2086 2
d2122 1
a2122 2
  av[1] = "ps";
  for(i = 2; i < argc + 1; ++i)
d2124 2
a2125 1
  av[i] = NULL;
d2173 1
a2173 2
  av[1] = "plot";
  for(i = 2; i < argc + 1; ++i)
d2175 2
a2176 1
  av[i] = NULL;
@


11.130
log
@checkin for weekend
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.129 1997/01/10 21:56:48 bparker Exp bparker $ (BRL)";
d61 1
a61 1

a63 6
extern int f_decompose();
extern int f_nmg_simplify();
extern int f_make_bb();
extern int f_whatid();
extern int f_which_air();
extern int f_eac();
a67 8
/* Carl Nuzman experimental */
#if 1
extern int cmd_vdraw();
extern int cmd_viewget();
extern int cmd_viewset();
extern int cmd_who();
#endif

d841 2
d963 2
a1013 1
#if 1
d1039 28
a1066 1
#else
d1068 2
a1069 7
  clp = (struct cmd_list *)bu_malloc(sizeof(struct cmd_list), "cmd_list");
  bzero((void *)clp, sizeof(struct cmd_list));
  BU_LIST_APPEND(&head_cmd_list.l, &clp->l);
  clp->cur_hist = head_cmd_list.cur_hist;
  bu_vls_init(&clp->more_default);
  bu_vls_init(&clp->name);
  bu_vls_strcpy(&clp->name, argv[1]);
d1071 6
a1076 1
#endif
a1080 1

a1089 1
#if 1
d1092 3
a1094 1
  bu_vls_init(&vls);
a1095 5
  if(!curr_cmd_list->aim){
    bu_vls_printf(&vls, "{%S} {%S}", curr_dm_list->s_info->opp,
		  &curr_cmd_list->name);
    Tcl_AppendElement(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
d1100 1
a1113 18
#else
  /* The current command window is not tied to a display manager so,
     simply return the id of the current command window */
  if(!curr_cmd_list->aim){
    Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->name));
    return TCL_OK;
  }

  /* return all ids associated with the current command window */
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
    /* The display manager tied to the current command window shares
       information with display manager p */
    if(curr_cmd_list->aim->s_info == p->s_info)
      /* This display manager is tied to a command window */
      if(p->aim)
	Tcl_AppendElement(interp, bu_vls_addr(&p->aim->name));
  }
#endif
a1385 1
      (void)signal( SIGINT, sig3);  /* allow interupts */
d1389 3
a1391 1
      if (len > 0)
d1395 4
a1407 2
      (void)signal( SIGINT, SIG_IGN );

d1411 3
a1413 1
    }else
d1415 1
d2001 4
a2004 2
  struct cmd_list *p_cmd;
  struct dm_list *p_dm;
d2010 4
a2013 4
    for( BU_LIST_FOR(p_cmd, cmd_list, &head_cmd_list.l) )
      if(p_cmd->aim)
	Tcl_AppendResult(interp, bu_vls_addr(&p_cmd->name), " ---> ",
			 bu_vls_addr(&p_cmd->aim->_dmp->dm_pathName),
d2016 1
a2016 1
	Tcl_AppendResult(interp, bu_vls_addr(&p_cmd->name), " ---> ",
d2019 3
a2021 3
    if(p_cmd->aim)
      Tcl_AppendResult(interp, bu_vls_addr(&p_cmd->name), " ---> ",
		       bu_vls_addr(&p_cmd->aim->_dmp->dm_pathName),
d2024 1
a2024 1
      Tcl_AppendResult(interp, bu_vls_addr(&p_cmd->name), " ---> ",
d2030 2
a2031 2
  for( BU_LIST_FOR(p_cmd, cmd_list, &head_cmd_list.l) )
    if(!strcmp(bu_vls_addr(&p_cmd->name), argv[1]))
d2034 1
a2034 1
  if(p_cmd == &head_cmd_list &&
d2043 3
a2045 3
    if(p_cmd->aim)
      Tcl_AppendResult(interp, bu_vls_addr(&p_cmd->name), " ---> ",
		       bu_vls_addr(&p_cmd->aim->_dmp->dm_pathName),
d2048 1
a2048 1
      Tcl_AppendResult(interp, bu_vls_addr(&p_cmd->name), " ---> ", "\n", (char *)NULL);
d2053 2
a2054 2
  for( BU_LIST_FOR(p_dm, dm_list, &head_dm_list.l) )
    if(!strcmp(argv[2], bu_vls_addr(&p_dm->_dmp->dm_pathName)))
d2057 1
a2057 9
#if 1
  if(p_dm == &head_dm_list){
    Tcl_AppendResult(interp, "f_aim: unrecognized pathName - ", argv[2],
		     "\n", (char *)NULL);
    return TCL_ERROR;
  }
#else
  if(p_dm == &head_dm_list &&
     strcmp(argv[2], bu_vls_addr(&head_dm_list._dmp->dm_pathName))){
a2059 1

a2061 1
#endif
d2064 2
a2065 2
  if(p_cmd->aim)
    p_cmd->aim->aim = (struct cmd_list *)NULL;
d2067 1
a2067 1
  p_cmd->aim = p_dm;
d2069 4
d2074 4
a2077 2
  if(p_dm->aim)
    p_dm->aim->aim = (struct dm_list *)NULL;
d2079 8
a2086 3
  p_dm->aim = p_cmd;
  Tcl_AppendResult(interp, bu_vls_addr(&p_cmd->name), " ---> ",
		   bu_vls_addr(&p_cmd->aim->_dmp->dm_pathName),
d2088 1
a2088 1
  
@


11.129
log
@*- moved view related commands to chgview.c
*- new command svb: set view base reference for absolute translate and scale
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.128 1997/01/09 01:44:19 mike Exp bparker $ (BRL)";
d453 4
d459 1
d855 59
d1075 24
d1100 3
d1119 1
a1119 1

d2055 7
d2069 1
@


11.128
log
@Changed to /usr/brlcad
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.127 1997/01/08 21:58:39 bparker Exp mike $ (BRL)";
d50 1
a56 4
int cmd_mged_glob();
int cmd_init();
int cmd_set();
int cmd_get();
a57 1
int f_tran();
a63 1
extern int cmd_stuff_str();
d465 2
a743 145
 *	G E T K N O B
 *
 *	Procedure called by the Tcl/Tk interface code to find the values
 *	of the knobs/sliders.
 */

int
cmd_getknob(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  int len;
  fastf_t f;
  char *cp;

  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  cp  = argv[1];
  len = strlen(cp);
  if(len == 1){
    switch(*cp){
    case 'x':
      if(EDIT_ROTATE && mged_variables.edit)
	f = edit_rate_rotate[X];
      else
	f = rate_rotate[X];
      break;
    case 'y':
      if(EDIT_ROTATE && mged_variables.edit)
	f = edit_rate_rotate[Y];
      else
	f = rate_rotate[Y];
      break;
    case 'z':
      if(EDIT_ROTATE && mged_variables.edit)
	f = edit_rate_rotate[Z];
      else
	f = rate_rotate[Z];
      break;
    case 'X':
      if(EDIT_TRAN && mged_variables.edit)
	f = edit_rate_tran[X];
      else
	f = rate_slew[X];
      break;
    case 'Y':
      if(EDIT_TRAN && mged_variables.edit)
	f = edit_rate_tran[Y];
      else
	f = rate_slew[Y];
      break;
    case 'Z':
      if(EDIT_TRAN && mged_variables.edit)
	f = edit_rate_tran[Z];
      else
	f = rate_slew[Z];
      break;
    case 'S':
      if(EDIT_SCALE && mged_variables.edit)
	f = edit_rate_scale;
      else
	f = rate_zoom;
      break;
    default:
      Tcl_AppendResult(interp, "getknob: bad value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else if(len == 2){
    if(*cp++ != 'a'){
      Tcl_AppendResult(interp, "getknob: bad value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    switch(*cp){
    case 'x':
      if(EDIT_ROTATE && mged_variables.edit)
	f = edit_absolute_rotate[X];
      else
	f = absolute_rotate[X];
      break;
    case 'y':
      if(EDIT_ROTATE && mged_variables.edit)
	f = edit_absolute_rotate[Y];
      else
	f = absolute_rotate[Y];
      break;
    case 'z':
      if(EDIT_ROTATE && mged_variables.edit)
	f = edit_absolute_rotate[Z];
      else
	f = absolute_rotate[Z];
      break;
    case 'X':
      if(EDIT_TRAN && mged_variables.edit)
	f = edit_absolute_tran[X];
      else
	f = absolute_slew[X];
      break;
    case 'Y':
      if(EDIT_TRAN && mged_variables.edit)
	f = edit_absolute_tran[Y];
      else
	f = absolute_slew[Y];
      break;
    case 'Z':
      if(EDIT_TRAN && mged_variables.edit)
	f = edit_absolute_tran[Z];
      else
	f = absolute_slew[Z];
      break;
    case 'S':
      if(EDIT_SCALE && mged_variables.edit)
	f = edit_absolute_scale;
      else
	f = absolute_zoom;
      break;
    default:
      Tcl_AppendResult(interp, "getknob: bad value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else{
    if(strcmp(argv[1], "xadc") == 0)
      f = dv_xadc;
    else if(strcmp(argv[1], "yadc") == 0)
      f = dv_yadc;
    else if(strcmp(argv[1], "ang1") == 0)
      f = dv_1adc;
    else if(strcmp(argv[1], "ang2") == 0)
      f = dv_2adc;
    else if(strcmp(argv[1], "distadc") == 0)
      f = dv_distadc;
    else{
      Tcl_AppendResult(interp, "getknob: bad value - ", argv[1], "\n", (char *)NULL);
       return TCL_ERROR;
    }
  }

  sprintf(interp->result, "%lf", f);
  return TCL_OK;
}

/*
d1298 1
a2088 160
f_setview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    *argv[];
{
  double x, y, z;

  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  if(sscanf(argv[1], "%lf", &x) < 1){
    Tcl_AppendResult(interp, "f_setview: bad x value - ",
		     argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &y) < 1){
    Tcl_AppendResult(interp, "f_setview: bad y value - ",
		     argv[2], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%lf", &z) < 1){
    Tcl_AppendResult(interp, "f_setview: bad z value - ",
		     argv[3], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  setview(x, y, z);

  return TCL_OK;
}


int
mged_tran(interp, tranvec)
Tcl_Interp *interp;
vect_t tranvec;
{
  vect_t old_pos;
  vect_t new_pos;
  vect_t diff;

  VMOVE(absolute_slew, tranvec);
  MAT4X3PNT( new_pos, view2model, absolute_slew );
  MAT_DELTAS_GET_NEG( old_pos, toViewcenter );
  VSUB2( diff, new_pos, old_pos );
  VADD2(new_pos, orig_pos, diff);
  MAT_DELTAS_VEC( toViewcenter, new_pos);
#if 0
  MAT_DELTAS_VEC( ModelDelta, new_pos);
#endif
  new_mats();

  return TCL_OK;
}


int
f_tran(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
{
  int incr = 0;
  int x, y, z;
  vect_t tranvec;

  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  /* Check for -i option */
  if(argv[1][0] == '-' && argv[1][1] == 'i'){
    incr = 1;  /* treat arguments as incremental values */
    ++argv;
    --argc;
  }

  if(sscanf(argv[1], "%d", &x) < 1){
    Tcl_AppendResult(interp, "f_slewview: bad x value - ",
		     argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%d", &y) < 1){
    Tcl_AppendResult(interp, "f_slewview: bad y value - ",
		     argv[2], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(argc == 4){
    if(sscanf(argv[3], "%d", &z) < 1){
      Tcl_AppendResult(interp, "f_slewview: bad z value - ",
		       argv[3], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else{
    if(incr)
      z = 0.0;
    else
      z = absolute_slew[Z];
  }

  if(incr){
    point_t tpoint;

    VSET(tpoint, x, y, z)
    VADD2(tranvec, absolute_slew, tpoint);
  }else{
    VSET(tranvec, x, y, z);
  }

  return mged_tran(interp, tranvec);
}


int
f_slewview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
{
  int x, y, z;
  vect_t slewvec;

  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  if(sscanf(argv[1], "%d", &x) < 1){
    Tcl_AppendResult(interp, "f_slewview: bad x value - ",
		     argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%d", &y) < 1){
    Tcl_AppendResult(interp, "f_slewview: bad y value - ",
		     argv[2], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(argc == 4){
    if(sscanf(argv[3], "%d", &z) < 1){
      Tcl_AppendResult(interp, "f_slewview: bad z value - ",
		       argv[3], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else
    z = 0;

  VSET(slewvec, x/2047.0, y/2047.0, z/2047.0);
  VSUB2(absolute_slew, absolute_slew, slewvec);
  slewview( slewvec );

  return TCL_OK;
}

int
d2144 2
@


11.127
log
@rewrote cmd_getknob
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.126 1997/01/02 19:41:06 bparker Exp bparker $ (BRL)";
d1004 1
a1004 1
    filename = "/m/cad/tclscripts";
@


11.126
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.125 1996/12/23 20:40:49 bparker Exp bparker $ (BRL)";
d158 1
a158 1
"aim", "[command_window [pathName]]", "aims command_window at pathName",
d760 6
a765 26
    register int i;
#if 1
    static struct {
	char *knobname;
	fastf_t variable;
    } knobs[] = {
	"ax", 0, 
	"ay", 0,
	"az", 0,
	"aX", 0,
	"aY", 0,
	"aZ", 0,
	"aS", 0,
	"x", 0,
	"y", 0,
	"z", 0,
	"X", 0,
	"Y", 0,
	"Z", 0,
	"S", 0,
	"xadc", 0,
	"yadc", 0,
	"ang1", 0,
	"ang2", 0,
	"distadc", 0,
    };
d767 53
a819 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
a820 24

    knobs[0].variable = absolute_rotate[X];
    knobs[1].variable = absolute_rotate[Y];
    knobs[2].variable = absolute_rotate[Z];
    knobs[3].variable = absolute_slew[X];
    knobs[4].variable = absolute_slew[Y];
    knobs[5].variable = absolute_slew[Z];
    knobs[6].variable = absolute_zoom;
    knobs[7].variable = rate_rotate[X];
    knobs[8].variable = rate_rotate[Y];
    knobs[9].variable = rate_rotate[Z];
    knobs[10].variable = rate_slew[X];
    knobs[11].variable = rate_slew[Y];
    knobs[12].variable = rate_slew[Z];
    knobs[13].variable = rate_zoom;
    knobs[14].variable = (fastf_t)dv_xadc;
    knobs[15].variable = (fastf_t)dv_yadc;
    knobs[16].variable = (fastf_t)dv_1adc;
    knobs[17].variable = (fastf_t)dv_2adc;
    knobs[18].variable = (fastf_t)dv_distadc;
	
    if( argc < 2 ) {
	Tcl_AppendResult(interp, "getknob: need a knob name", (char *)NULL);
	return TCL_ERROR;
d823 45
a867 32
    for (i = 0; i < 19; ++i)
      if (strcmp(knobs[i].knobname, argv[1]) == 0) {
	sprintf(interp->result, "%lf", knobs[i].variable);
	return TCL_OK;
      }
#else
    static struct {
	char *knobname;
	fastf_t *variable;
    } knobs[] = {
	"ax", (fastf_t *)NULL, 
	"ay", (fastf_t *)NULL,
	"az", (fastf_t *)NULL,
	"aX", (fastf_t *)NULL,
	"aY", (fastf_t *)NULL,
	"aZ", (fastf_t *)NULL,
	"aS", (fastf_t *)NULL,
	"x", (fastf_t *)NULL,
	"y", (fastf_t *)NULL,
	"z", (fastf_t *)NULL,
	"X", (fastf_t *)NULL,
	"Y", (fastf_t *)NULL,
	"Z", (fastf_t *)NULL,
	"S", (fastf_t *)NULL,
	"xadc", (fastf_t *)NULL,
	"yadc", (fastf_t *)NULL,
	"ang1", (fastf_t *)NULL,
	"ang2", (fastf_t *)NULL,
	"distadc", (fastf_t *)NULL,
    };

    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d869 15
a883 24

    knobs[0].variable = &absolute_rotate[X];
    knobs[1].variable = &absolute_rotate[Y];
    knobs[2].variable = &absolute_rotate[Z];
    knobs[3].variable = &absolute_slew[X];
    knobs[4].variable = &absolute_slew[Y];
    knobs[5].variable = &absolute_slew[Z];
    knobs[6].variable = &absolute_zoom;
    knobs[7].variable = &rate_rotate[X];
    knobs[8].variable = &rate_rotate[Y];
    knobs[9].variable = &rate_rotate[Z];
    knobs[10].variable = &rate_slew[X];
    knobs[11].variable = &rate_slew[Y];
    knobs[12].variable = &rate_slew[Z];
    knobs[13].variable = &rate_zoom;
    knobs[14].variable = (fastf_t *)&dv_xadc;
    knobs[15].variable = (fastf_t *)&dv_yadc;
    knobs[16].variable = (fastf_t *)&dv_1adc;
    knobs[17].variable = (fastf_t *)&dv_2adc;
    knobs[18].variable = (fastf_t *)&dv_distadc;
	
    if( argc < 2 ) {
	Tcl_AppendResult(interp, "getknob: need a knob name", (char *)NULL);
	return TCL_ERROR;
d885 1
d887 2
a888 8
    for (i = 0; i < 19; ++i)
      if (strcmp(knobs[i].knobname, argv[1]) == 0) {
	sprintf(interp->result, "%lf", *(knobs[i].variable));
	return TCL_OK;
      }
#endif    
    Tcl_AppendResult(interp, "getknob: invalid knob name", (char *)NULL);
    return TCL_ERROR;
@


11.125
log
@mods to mged_setup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.124 1996/12/17 22:40:29 bparker Exp bparker $ (BRL)";
a39 1
#include "tcl.h"
@


11.124
log
@mod's to f_tran
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.123 1996/12/13 23:10:54 bparker Exp bparker $ (BRL)";
d992 3
d996 4
a1000 8
#if 0
  filename = getenv("MGED_TCL_LIBRARY");
  bu_vls_printf(&str, "set auto_path \\[linsert $auto_path 0 %s\\];\
set junk \"\"", filename ? filename : MGED_TCL_LIBRARY);
  (void)cmdline(&str, False);
#else
  if((filename = getenv("MGED_TCL_LIBRARY")) == NULL)
    filename = MGED_TCL_LIBRARY;
a1002 1
#endif
a1004 1
#endif
@


11.123
log
@weekend checkin
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.122 1996/12/12 22:10:09 bparker Exp bparker $ (BRL)";
d2335 1
a2335 1
      z = absolute_slew[Z] * 2047.0;
d2341 1
a2341 1
    VSET(tpoint, x/2047.0, y/2047.0, z/2047.0);
d2344 1
a2344 1
    VSET(tranvec, x/2047.0, y/2047.0, z/2047.0);
@


11.122
log
@start of cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.121 1996/12/11 22:40:57 bparker Exp bparker $ (BRL)";
a61 1
int tran(), irot();
d66 2
a67 3
extern mat_t    ModelDelta;
extern void sedit_trans();
extern int mged_vrot();
a76 8
extern short earb4[5][18];
extern short earb5[9][18];
extern short earb6[10][18];
extern short earb7[12][18];
extern short earb8[12][18];
extern struct rt_db_internal es_int;
extern short int fixv; /* used in ECMD_ARB_ROTATE_FACE,f_eqn(): fixed vertex */

a78 2
point_t e_axes_pos;
void set_e_axes_pos();
a79 1

a89 3
extern void sync();
int	inpara;			/* parameter input from keyboard */

d2269 24
d2301 1
a2301 3
  point_t old_pos;
  point_t new_pos;
  point_t diff;
d2342 1
a2342 1
    VADD2(absolute_slew, absolute_slew, tpoint);
d2344 1
a2344 1
    VSET(absolute_slew, x/2047.0, y/2047.0, z/2047.0);
d2347 1
a2347 11
  MAT4X3PNT( new_pos, view2model, absolute_slew );
  MAT_DELTAS_GET_NEG( old_pos, toViewcenter );
  VSUB2( diff, new_pos, old_pos );
  VADD2(new_pos, orig_pos, diff);
  MAT_DELTAS_VEC( toViewcenter, new_pos);
#if 0
  MAT_DELTAS_VEC( ModelDelta, new_pos);
#endif
  new_mats();

  return TCL_OK;
a2391 125
void
set_e_axes_pos()
{
  int	i;

#if 0
  update_views = 1;

  if(EDIT_TRAN) {
    VMOVE(e_axes_pos, es_keypoint);
    MAT4X3PNT( absolute_slew, model2view, es_keypoint );
  }else{
    point_t new_pos;

    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);

    if(EDIT_ROTATE)
      VSETALL( absolute_rotate, 0.0 );
  }
#else
  update_views = 1;
  switch(es_int.idb_type){
  case	ID_ARB8:
  case	ID_ARBN:
    if(state == ST_O_EDIT)
      i = 0;
    else
      switch(es_edflag){
      case	STRANS:
	i = 0;
	break;
      case	EARB:
	switch(es_type){
	case	ARB5:
	  i = earb5[es_menu][0];
	  break;
	case	ARB6:
	  i = earb6[es_menu][0];
	  break;
	case	ARB7:
	  i = earb7[es_menu][0];
	  break;
	case	ARB8:
	  i = earb8[es_menu][0];
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case	PTARB:
	switch(es_type){
	case    ARB4:
	  i = es_menu;	/* index for point 1,2,3 or 4 */
	  break;
	case    ARB5:
	case	ARB7:
	  i = 4;	/* index for point 5 */
	  break;
	case    ARB6:
	  i = es_menu;	/* index for point 5 or 6 */
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case ECMD_ARB_MOVE_FACE:
	switch(es_type){
	case	ARB4:
	  i = arb_faces[0][es_menu * 4];
	  break;
	case	ARB5:
	  i = arb_faces[1][es_menu * 4];  		
	  break;
	case	ARB6:
	  i = arb_faces[2][es_menu * 4];  		
	  break;
	case	ARB7:
	  i = arb_faces[3][es_menu * 4];  		
	  break;
	case	ARB8:
	  i = arb_faces[4][es_menu * 4];  		
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case ECMD_ARB_ROTATE_FACE:
	i = fixv;
	break;
      default:
	i = 0;
	break;
      }

    VMOVE(e_axes_pos, ((struct rt_arb_internal *)es_int.idb_ptr)->pt[i]);
    break;
  case ID_TGC:
  case ID_REC:
    if(es_edflag == ECMD_TGC_MV_H ||
       es_edflag == ECMD_TGC_MV_HH){
      struct rt_tgc_internal  *tgc = (struct rt_tgc_internal *)es_int.idb_ptr;

      VADD2(e_axes_pos, tgc->h, tgc->v);
      break;
    }
  default:
    VMOVE(e_axes_pos, es_keypoint);
    break;
  }

  if(EDIT_ROTATE)
    VSETALL( edit_absolute_rotate, 0.0 )
  else if(EDIT_TRAN)
    VSETALL( edit_absolute_tran, 0.0 )
  else if(EDIT_SCALE)
    edit_absolute_scale = 0;

  mat_idn(acc_rot_sol);
#endif
}

a2447 77


int
tran(view_flag)
int view_flag;
{
  point_t old_pos;
  point_t new_pos;
  point_t diff;
  point_t model_pos;

  if(EDIT_TRAN && mged_variables.edit && !view_flag){
    VSCALE(diff, edit_absolute_tran, Viewscale);
    VADD2(model_pos, diff, e_axes_pos);
    MAT4X3PNT(new_pos, model2view, model_pos);

    if(state = ST_S_EDIT){
      sedit_trans(new_pos);
    }else
      objedit_mouse(new_pos);
  }else{/* slew the view */
    MAT4X3PNT( new_pos, view2model, absolute_slew )
    MAT_DELTAS_GET_NEG( old_pos, toViewcenter )
    VSUB2( diff, new_pos, old_pos )
    VADD2(new_pos, orig_pos, diff)
    MAT_DELTAS_VEC( toViewcenter, new_pos)
    new_mats();
  }

  return CMD_OK;
}

int
irot(x, y, z, iflag)
fastf_t x, y, z;
int iflag;
{
  point_t model_pos;
  point_t new_pos;
  int status;
  char *av[6];
  struct bu_vls xval, yval, zval;

  bu_vls_init(&xval);
  bu_vls_init(&yval);
  bu_vls_init(&zval);
  bu_vls_printf(&xval, "%f", x);
  bu_vls_printf(&yval, "%f", y);
  bu_vls_printf(&zval, "%f", z);
  av[1] = bu_vls_addr(&xval);
  av[2] = bu_vls_addr(&yval);
  av[3] = bu_vls_addr(&zval);
  av[4] = NULL;

  if(state == ST_S_EDIT){
    av[0] = "p";
    status = f_param((ClientData)NULL, interp, 4, av);
  }else if(state == ST_O_EDIT){
    av[0] = "orot";
    if(iflag){
      av[1] = "-i";
      av[2] = bu_vls_addr(&xval);
      av[3] = bu_vls_addr(&yval);
      av[4] = bu_vls_addr(&zval);
      av[5] = NULL;
      status = f_rot_obj((ClientData)NULL, interp, 5, av);
    }else
      status = f_rot_obj((ClientData)NULL, interp, 4, av);
  }

  bu_vls_free(&xval);
  bu_vls_free(&yval);
  bu_vls_free(&zval);

  return status;
}

@


11.121
log
@experimenting
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.120 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d327 1
a327 1
"knob", "[-i] [id [val]]", "emulate knob twist",
d2514 2
a2603 6

    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);

    if(tkwin != NULL)
      (void)Tcl_Eval(interp, "set_sliders");
d2617 2
d2620 10
a2629 5
  if(state == ST_VIEW || !EDIT_ROTATE || !mged_variables.edit){
    status = mged_vrot(x, y, z);
  }else{
    char *av[6];
    struct bu_vls xval, yval, zval;
d2631 14
a2644 30
    bu_vls_init(&xval);
    bu_vls_init(&yval);
    bu_vls_init(&zval);
    bu_vls_printf(&xval, "%f", x);
    bu_vls_printf(&yval, "%f", y);
    bu_vls_printf(&zval, "%f", z);
    av[1] = bu_vls_addr(&xval);
    av[2] = bu_vls_addr(&yval);
    av[3] = bu_vls_addr(&zval);
    av[4] = NULL;

    if(state == ST_S_EDIT){
      av[0] = "p";
      status = f_param((ClientData)NULL, interp, 4, av);
    }else if(state == ST_O_EDIT){
      av[0] = "orot";
      if(iflag){
	av[1] = "-i";
	av[2] = bu_vls_addr(&xval);
	av[3] = bu_vls_addr(&yval);
	av[4] = bu_vls_addr(&zval);
	av[5] = NULL;
	status = f_rot_obj((ClientData)NULL, interp, 5, av);
      }else
	status = f_rot_obj((ClientData)NULL, interp, 4, av);
    }

    bu_vls_free(&xval);
    bu_vls_free(&yval);
    bu_vls_free(&zval);
d2646 4
@


11.120
log
@experimentation
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.119 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d68 1
a68 1

d2513 1
a2513 9
#if 0
    MAT4X3PNT( edit_absolute_tran, model2view, e_axes_pos )
#else
  VSETALL( edit_absolute_tran, 0.0 )
#endif

#if 0
  {
    point_t new_pos;
d2515 1
a2515 4
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
  }
#endif
d2592 1
a2592 1
      sedit_mouse(new_pos);
a2600 3
#if 0
    MAT_DELTAS_VEC( ModelDelta, new_pos)
#endif
d2602 6
@


11.119
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.118 1996/12/06 21:55:11 bparker Exp bparker $ (BRL)";
d2510 11
a2520 3
  if(EDIT_TRAN) {
    MAT4X3PNT( edit_absolute_tran, model2view, e_axes_pos );
  }else{
a2524 3

    if(EDIT_ROTATE)
      VSETALL( edit_absolute_rotate, 0.0 );
d2527 1
d2589 2
a2590 2
tran(view_pos)
vect_t view_pos;
d2595 6
d2602 4
a2605 8
  if(SEDIT_TRAN){
    tran_set = 1;
    sedit_mouse(view_pos);
    tran_set = 0;
  }else if(OEDIT_TRAN){
    tran_set = 1;
    objedit_mouse(view_pos);
    tran_set = 0;
d2607 5
a2611 5
    MAT4X3PNT( new_pos, view2model, view_pos );
    MAT_DELTAS_GET_NEG( old_pos, toViewcenter );
    VSUB2( diff, new_pos, old_pos );
    VADD2(new_pos, orig_pos, diff);
    MAT_DELTAS_VEC( toViewcenter, new_pos);
d2613 1
a2613 1
    MAT_DELTAS_VEC( ModelDelta, new_pos);
d2630 1
a2630 1
  if(state == ST_VIEW || !EDIT_ROTATE){
@


11.118
log
@not done yet --- working on allowing full view manipulation while editing
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.117 1996/12/04 21:11:10 bparker Exp bparker $ (BRL)";
d64 1
a64 1
void set_tran(), mged_setup(), cmd_setup(), mged_compat();
d2511 1
a2511 1
    MAT4X3PNT( absolute_slew, model2view, e_axes_pos );
d2519 1
a2519 1
      VSETALL( absolute_rotate, 0.0 );
a2581 29
/*
 *                         S E T _ T R A N
 *
 * Calculate the values for absolute_slew.
 *
 *
 */
void
set_tran(x, y, z)
fastf_t x, y, z;
{
  point_t diff;
  point_t old_pos;
  point_t new_pos;
  point_t view_pos;

  diff[X] = x - e_axes_pos[X];
  diff[Y] = y - e_axes_pos[Y];
  diff[Z] = z - e_axes_pos[Z];
  
  /* If there is more than one active view, then absolute_slew
     needs to be initialized for each view. */
  MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
  VADD2(new_pos, old_pos, diff);
  MAT4X3PNT(view_pos, model2view, new_pos);
  VMOVE( absolute_slew, view_pos );
}


d2590 1
a2590 1
  if(state == ST_S_EDIT && !SEDIT_ROTATE && es_edflag > IDLE){
d2594 1
a2594 1
  }else if(state == ST_O_EDIT && !OEDIT_ROTATE && edobj){
@


11.117
log
@mods to irot
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.116 1996/11/27 08:56:16 mike Exp bparker $ (BRL)";
d63 1
d485 2
a486 2
"sv", "x y", "Move view center to (x, y)",
	f_slewview, 3, 3,TRUE,
d505 2
a506 4
#if 0
"tran", "x y z", "absolute translate using view coordinates",
        f_tran, 4, 4,TRUE,
#endif
d2283 72
d2362 2
a2363 2
  int x, y;
  vect_t tabvec;
a2364 1

d2380 12
a2391 4
  tabvec[X] =  x / 2047.0;
  tabvec[Y] =  y / 2047.0;
  tabvec[Z] = 0;
  slewview( tabvec );
d2633 1
d2635 1
@


11.116
log
@Added debugbu command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.115 1996/11/27 08:50:01 mike Exp mike $ (BRL)";
d68 1
a2569 2
  char *av[6];
  struct bu_vls xval, yval, zval;
a2570 12
  bu_vls_init(&xval);
  bu_vls_init(&yval);
  bu_vls_init(&zval);
  bu_vls_printf(&xval, "%f", x);
  bu_vls_printf(&yval, "%f", y);
  bu_vls_printf(&zval, "%f", z);
  av[1] = bu_vls_addr(&xval);
  av[2] = bu_vls_addr(&yval);
  av[3] = bu_vls_addr(&zval);
  av[4] = NULL;

  /* if in view state or not doing a solid rotate then allow the view to be rotated */
d2572 4
a2575 5
    if(EDIT_TRAN)
      MAT4X3PNT(model_pos, view2model, absolute_slew);

    av[0] = "vrot";
    status = f_vrot((ClientData)NULL, interp, 4, av);
d2577 30
a2606 20
    if(EDIT_TRAN){
      MAT4X3PNT(absolute_slew, model2view, model_pos);
    }else{
      VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
      MAT4X3PNT(absolute_slew, model2view, new_pos);
    }
  }else if(state == ST_S_EDIT){
    av[0] = "p";
    status = f_param((ClientData)NULL, interp, 4, av);
  }else if(state == ST_O_EDIT){
    av[0] = "orot";
    if(iflag){
      av[1] = "-i";
      av[2] = bu_vls_addr(&xval);
      av[3] = bu_vls_addr(&yval);
      av[4] = bu_vls_addr(&zval);
      av[5] = NULL;
      status = f_rot_obj((ClientData)NULL, interp, 5, av);
    }else
      status = f_rot_obj((ClientData)NULL, interp, 4, av);
d2609 1
a2609 8
  bu_vls_free(&xval);
  bu_vls_free(&yval);
  bu_vls_free(&zval);

  if(status == TCL_OK)
    return CMD_OK;

  return CMD_BAD;
@


11.115
log
@Bob Parker modifications
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.114 1996/11/19 21:46:36 bparker Exp bparker $ (BRL)";
d222 2
@


11.114
log
@add -i option to orot, rotobj and ae
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.113 1996/11/01 22:10:27 bparker Exp bparker $ (BRL)";
d1008 1
d1013 6
d1539 1
d1566 9
@


11.113
log
@- change iknob to knob -i
- add new commands:
		aet - set azimuth, elevation and twist
		mged_update - for handling outstanding events and to refresh.
			     For use in scripts to update the screen etc.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.112 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d171 2
a172 4
"ae", "azim elev", "set view using azim and elev angles",
	f_aeview, 3, 3, TRUE,
"aet", "[-i] azim elev twist", "set view using azim, elev and twist angles",
	f_aetview, 4, 5, TRUE,
d369 2
a370 2
"orot", "xdeg ydeg zdeg", "rotate object being edited",
	f_rot_obj, 4, 4,TRUE,
d439 2
a440 2
"rotobj", "xdeg ydeg zdeg", "rotate object being edited",
	f_rot_obj, 4, 4,TRUE,
d1006 1
a1006 1
#ifdef MGED_LIBRARY
d1010 1
a1010 1
set junk \"\"", filename ? filename : MGED_LIBRARY);
d2543 1
a2543 1
irot(x, y, z)
d2545 1
d2550 1
a2550 1
  char *av[5];
d2582 10
a2591 2
    av[0] = "rotobj";
    status = f_rot_obj((ClientData)NULL, interp, 4, av);
@


11.112
log
@hacks to use latest libdm
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.111 1996/10/18 13:55:07 bparker Exp $ (BRL)";
d171 1
a171 1
"ae", "azim elev", "set view using az and elev angles",
d173 2
a302 2
"iknob", "id [val]", "increment knob value",
       f_knob,2,3, TRUE,
a308 4
#if 0
"irot", "x y z", "incremental/relative rotate",
        f_irot, 4, 4, TRUE,
#endif
a310 4
#if 0
"itran", "x y z", "incremental/relative translate using normalized screen coordinates",
        f_tran, 4, 4,TRUE,
#endif
d325 2
a326 2
"knob", "id [val]", "emulate knob twist",
	f_knob,2,3, TRUE,
d515 2
d2426 20
@


11.111
log
@define a function "mged_print_result" to be used by code that
calls MGED commands directly.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.110 1996/10/10 20:12:53 jra Exp bparker $ (BRL)";
d2069 1
a2069 1
			 bu_vls_addr(&p_cmd->aim->_dmp->dmr_pathName),
d2077 1
a2077 1
		       bu_vls_addr(&p_cmd->aim->_dmp->dmr_pathName),
d2101 1
a2101 1
		       bu_vls_addr(&p_cmd->aim->_dmp->dmr_pathName),
d2110 1
a2110 1
    if(!strcmp(argv[2], bu_vls_addr(&p_dm->_dmp->dmr_pathName)))
d2114 1
a2114 1
     strcmp(argv[2], bu_vls_addr(&head_dm_list._dmp->dmr_pathName))){
d2133 1
a2133 1
		   bu_vls_addr(&p_cmd->aim->_dmp->dmr_pathName),
d2454 1
a2454 1
    if( !strcmp( argv[1], bu_vls_addr( &p->_dmp->dmr_pathName ) ) ){
@


11.110
log
@Added "decompose" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.109 1996/10/08 19:38:20 jra Exp jra $ (BRL)";
d64 1
d1530 38
@


11.109
log
@corrected spelling errors.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.108 1996/10/03 20:44:41 bparker Exp jra $ (BRL)";
d69 1
d229 2
@


11.108
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.107 1996/10/01 17:26:29 bparker Exp bparker $ (BRL)";
d207 1
a207 1
"copyeval", "new_solid path_to_old_solid (seperate path components with spaces, not /)",
d315 1
a315 1
"joint", "command [options]", "articualtion/animation commands",
@


11.107
log
@ignore SIGINT
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.106 1996/09/26 20:40:29 bparker Exp bparker $ (BRL)";
d1417 7
a1423 6
    int	status;
    struct bu_vls globbed;
    struct timeval start, finish;
    size_t len;
    extern struct bu_vls mged_prompt;
    char *cp;
d1425 1
a1425 1
    BU_CK_VLS(vp);
d1427 2
a1428 2
    if (bu_vls_strlen(vp) <= 0)
      return CMD_OK;
d1430 2
a1431 2
    bu_vls_init(&globbed);

d1433 2
a1434 2
    /* MUST MAKE A BACKUP OF THE INPUT STRING AND USE THAT IN THE CALL TO
       Tcl_Eval!!!
d1436 5
a1440 5
       You never know who might change the string (append to it...)
       (f_mouse is notorious for adding things to the input string)
       If it were to change while it was still being evaluated, Horrible Things
       could happen.
    */
d1442 4
a1445 5
    
    if (glob_compat_mode)
	mged_compat(&globbed, vp);
    else
	bu_vls_vlscat(&globbed, vp);
d1447 25
a1471 3
    gettimeofday(&start, (struct timezone *)NULL);
    status = Tcl_Eval(interp, bu_vls_addr(&globbed));
    gettimeofday(&finish, (struct timezone *)NULL);
d1473 1
a1473 1
    /* Contemplate the result reported by the Tcl interpreter. */
d1475 2
a1476 23
    switch (status) {
    case TCL_OK:
      if( setjmp( jmp_env ) == 0 ){
	(void)signal( SIGINT, sig3);  /* allow interupts */
	len = strlen(interp->result);

	/* If the command had something to say, print it out. */	     
	if (len > 0)
	  bu_log("%s%s", interp->result,
		 interp->result[len-1] == '\n' ? "" : "\n");

	/* A user typed this command so let everybody see, then record
	   it in the history. */
	if (record && tkwin != NULL) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "distribute_text {} {%s} {%s}",
			bu_vls_addr(&globbed), interp->result);
	  Tcl_Eval(interp, bu_vls_addr(&tmp_vls));
	  Tcl_SetResult(interp, "", TCL_STATIC);
	  bu_vls_free(&tmp_vls);
	}
d1478 2
a1479 3
	(void)signal( SIGINT, SIG_IGN );
      }else
	bu_log("\n");
d1481 21
d1503 3
a1505 2
      if(record)
	history_record(vp, &start, &finish, CMD_OK);
d1507 1
a1507 3
      bu_vls_free(&globbed);
      bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
      return CMD_OK;
d1509 3
a1511 2
    case TCL_ERROR:
    default:
d1513 2
a1514 1
    /* First check to see if it's a secret message from cmd_wrapper. */
d1516 2
a1517 12
	if ((cp = strstr(interp->result, MORE_ARGS_STR)) != NULL) {
	    if(cp == interp->result){
	      bu_vls_trunc(&mged_prompt, 0);
	      bu_vls_printf(&mged_prompt, "\r%s",
			    interp->result+sizeof(MORE_ARGS_STR)-1);
	    }else{
	      len = cp - interp->result;
	      bu_log("%*s%s", len, interp->result, interp->result[len-1] == '\n' ? "" : "\n");
	      bu_vls_trunc(&mged_prompt, 0);
	      bu_vls_printf(&mged_prompt, "\r%s",
			    interp->result+sizeof(MORE_ARGS_STR)-1+len);
	    }
d1519 2
a1520 3
	    bu_vls_free(&globbed);
	    return CMD_MORE;
	}
d1522 4
a1525 11
    /* Otherwise, it's just a regular old error. */    

	len = strlen(interp->result);
	if (len > 0) bu_log("%s%s", interp->result,
			    interp->result[len-1] == '\n' ? "" : "\n");

	if (record) history_record(vp, &start, &finish, CMD_BAD);
	bu_vls_free(&globbed);
	bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
	return CMD_BAD;
    }
d1854 1
a1854 2
	/* XXX should be bu_vls_strgrab() */
	Tcl_AppendResult(interp, bu_vls_strdup( &str), (char *)NULL);
@


11.106
log
@call gui_setup with display string
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.105 1996/09/25 19:59:43 bparker Exp bparker $ (BRL)";
d1476 2
@


11.105
log
@include mged_solid.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.104 1996/09/23 18:35:25 bparker Exp bparker $ (BRL)";
d63 1
a63 1
void set_tran(), gui_setup(), mged_setup(), cmd_setup(), mged_compat();
d67 1
d752 11
a762 2
  gui_setup();
  return TCL_OK;
a1019 32

void
gui_setup()
{
  char *filename;
  int status;

  /* initialize only once */
  if(tkwin != NULL)
    return;

  if((tkwin = Tk_CreateMainWindow(interp, (char *)NULL, "MGED", "MGED")) == NULL){
    bu_log("gui_setup: Failed to create main window.\n");
    return;
  }

  /* This runs the tk.tcl script */
  if (Tk_Init(interp) == TCL_ERROR)
    bu_log("Tk_Init error %s\n", interp->result);

  Tcl_Eval( interp, "wm withdraw .");

  /* Check to see if user specified MGED_GUIRC */
  if((filename = getenv("MGED_GUIRC")) == (char *)NULL )
    return;

  if(Tcl_EvalFile( interp, filename ) == TCL_ERROR)
    bu_log("gui_setup: %s\n", interp->result);

  return;
}

@


11.104
log
@use LIBDM permanently
added f_pl -- similar to plot except it calls on dm-plot
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.103 1996/09/17 21:22:32 bparker Exp bparker $ (BRL)";
d51 1
a51 1
#include "./solid.h"
d2288 13
a2300 2
  VMOVE(e_axes_pos, es_keypoint);
  MAT4X3PNT( absolute_slew, model2view, es_keypoint );
@


11.103
log
@prepare to use libdm
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.102 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d52 1
a52 1
#include "./dm.h"
d185 1
a185 1
	f_attach,1,3,TRUE,
d390 2
d404 2
a405 2
"ps", "file", "creates a postscript file of the current view",
        f_ps, 2, 3,TRUE,
d2121 1
d2123 1
a2123 1
  char *av[4];
d2131 1
d2133 1
d2136 7
a2142 4
  av[2] = argv[1];
  av[3] = NULL;
  status = f_attach(clientData, interp, 3, av);
  if(status == TCL_ERROR)
d2144 52
d2206 4
a2209 1
  return f_release(clientData, interp, 1, av);
@


11.102
log
@rt_list ---> bu_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.101 1996/09/03 13:07:52 jra Exp bparker $ (BRL)";
a106 1
int gui_not_initialized = 1;
a748 1
#if 1
d750 1
a750 32
#else
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
      return TCL_ERROR;

    /* XXX Screen name should be same as attachment, or should ask, or
       should be settable from "-display" option. */

    if (tkwin != NULL)  {
      Tcl_AppendResult(interp, "loadtk: already attached to display", (char *)NULL);
      return TCL_ERROR;
    }

    if( argc != 2 )  {
	tkwin = Tk_CreateMainWindow(interp, (char *)NULL, "MGED", "MGED");
    } else {
	tkwin = Tk_CreateMainWindow(interp, argv[1], "MGED", "MGED");
    }
    if (tkwin == NULL)
	return TCL_ERROR;

    if (tkwin != NULL) {
	Tk_GeometryRequest(tkwin, 100, 20);
	/* This runs the tk.tcl script */
	if (Tk_Init(interp) == TCL_ERROR)
	    return TCL_ERROR;
    }
    
    /* Handle any delayed events which result */
    while (Tk_DoOneEvent(TK_DONT_WAIT | TK_ALL_EVENTS))
	;
#endif
    return TCL_OK;
a1013 1
  static int gui_initialized = 0;
d1016 1
a1016 1
  if(gui_initialized)
a1027 1
  gui_initialized = 1;
d2042 1
a2042 1
			 bu_vls_addr(&p_cmd->aim->_pathName),
d2050 1
a2050 1
		       bu_vls_addr(&p_cmd->aim->_pathName),
d2074 1
a2074 1
		       bu_vls_addr(&p_cmd->aim->_pathName),
d2083 1
a2083 1
    if(!strcmp(argv[2], bu_vls_addr(&p_dm->_pathName)))
d2087 1
a2087 1
     strcmp(argv[2], bu_vls_addr(&head_dm_list._pathName))){
d2106 1
a2106 1
		   bu_vls_addr(&p_cmd->aim->_pathName),
d2120 3
a2122 2
  char *av_attach[4];
  char *av_release[2];
d2127 7
a2133 5
  av_attach[0] = "attach";
  av_attach[1] = "ps";
  av_attach[2] = argv[1];
  av_attach[3] = NULL;
  status = f_attach(clientData, interp, 3, av_attach);
d2137 3
d2143 4
a2146 3
  av_release[0] = "release";
  av_release[1] = NULL;
  return f_release(clientData, interp, 1, av_release);
d2355 1
a2355 1
    if( !strcmp( argv[1], bu_vls_addr( &p->_pathName ) ) ){
@


11.101
log
@removed redundant "eid" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.100 1996/08/28 19:40:56 bparker Exp jra $ (BRL)";
d44 1
a47 2
#include "bu.h"
#include "rtlist.h"
d1174 1
a1174 1
  for( RT_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
d1183 1
a1183 1
    RT_LIST_APPEND(&head_cmd_list.l, &clp->l);
d1201 1
a1201 1
  RT_LIST_APPEND(&head_cmd_list.l, &clp->l);
d1231 1
a1231 1
  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d1259 1
a1259 1
  for( RT_LIST_FOR(p, cmd_list, &head_cmd_list.l) ){
d2074 1
a2074 1
    for( RT_LIST_FOR(p_cmd, cmd_list, &head_cmd_list.l) )
d2094 1
a2094 1
  for( RT_LIST_FOR(p_cmd, cmd_list, &head_cmd_list.l) )
d2117 1
a2117 1
  for( RT_LIST_FOR(p_dm, dm_list, &head_dm_list.l) )
d2382 1
a2382 1
  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l ) ){
@


11.100
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.99 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
a72 1
extern int f_eid();
a252 2
"eid", "ident(s)", "display all regions with given ident code",
	f_eid, 2, MAXARGS,TRUE,
@


11.99
log
@now using libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.98 1996/08/27 04:10:42 mike Exp bparker $ (BRL)";
d2467 1
a2467 2
  vect_t view_pos;
  vect_t model_pos;
a2468 1
  point_t diff;
@


11.98
log
@bu.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.97 1996/08/22 20:46:10 bparker Exp mike $ (BRL)";
d567 1
a567 1
 * Gets the output from rt_log and appends it to clientdata vls.
d589 1
a589 1
 * Sets up hooks to rt_log so that all output is caught in the given vls.
d651 1
a651 1
       rt_log command; hence, we must catch such output and stuff it into
d708 1
a708 1
 * Used as a hook for rt_log output.  Sends output to the Tcl procedure whose
d723 2
a724 2
	/* Now safe to run rt_log? */
    	rt_log("Ack! Something horrible just happened recursively.\n");
d1023 1
a1023 1
    rt_log("Tcl_Init error %s\n", interp->result);
d1058 1
a1058 1
    rt_log("gui_setup: Failed to create main window.\n");
d1064 1
a1064 1
    rt_log("Tk_Init error %s\n", interp->result);
d1074 1
a1074 1
    rt_log("gui_setup: %s\n", interp->result);
d1097 1
a1097 1
	    rt_log("WARNING:  '%s' name collision (%s)\n", ftp->ft_name,
d1116 1
a1116 1
	    rt_log("cmd_setup: %s needs to be Tcl converted\n", ftp->ft_name);
d1483 1
a1483 1
    RT_VLS_CHECK(vp);
d1520 1
a1520 1
	  rt_log("%s%s", interp->result,
d1536 1
a1536 1
	rt_log("\n");
d1558 1
a1558 1
	      rt_log("%*s%s", len, interp->result, interp->result[len-1] == '\n' ? "" : "\n");
d1571 1
a1571 1
	if (len > 0) rt_log("%s%s", interp->result,
d2001 1
a2001 1
 * Concatenates its arguments and "rt_log"s the resulting string.
d2058 1
a2058 1
  rt_log( "Savedit will only work in an edit state\n");
@


11.97
log
@add commands to funtab: edmater, wmater, rmater
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.96 1996/08/21 14:06:23 jra Exp bparker $ (BRL)";
d47 1
a47 1
#include "rtstring.h"
d107 1
a107 1
struct rt_vls tcl_output_hook;
d573 1
a573 1
char *str;
d575 1
a575 1
    register struct rt_vls *vp = (struct rt_vls *)clientdata;
d578 4
a581 3
    len = rt_vls_strlen(vp);
    rt_vls_strcat(vp, str);
    len = rt_vls_strlen(vp) - len;
d595 1
a595 1
struct rt_vls *vp;
d597 1
a597 1
    rt_add_hook(output_catch, (genptr_t)vp);
d608 1
a608 1
struct rt_vls *vp;
d610 1
a610 1
    rt_delete_hook(output_catch, (genptr_t)vp);
d644 1
a644 1
    struct rt_vls result;
d658 1
a658 1
    rt_vls_init(&result);
d669 3
a671 3
	len = rt_vls_strlen(&result);
	while (len > 0 && rt_vls_addr(&result)[len-1] == '\n')
	    rt_vls_trunc(&result, --len);
d677 1
a677 1
	    Tcl_SetResult(interp, rt_vls_addr(&result), TCL_VOLATILE);
d682 1
a682 1
	    Tcl_SetResult(interp, rt_vls_addr(&result), TCL_VOLATILE);
d688 1
a688 1
	    Tcl_AppendResult(interp, rt_vls_addr(&result), (char *)NULL);
d695 1
a695 1
	    Tcl_AppendResult(interp, rt_vls_addr(&result), (char *)NULL);
d701 1
a701 1
    rt_vls_free(&result);
d716 1
a716 1
char *str;
d722 1
a722 1
	rt_delete_hook(gui_output, clientData);
d729 1
a729 1
    (void)Tcl_DStringAppendElement(&tclcommand, rt_vls_addr(&tcl_output_hook));
d942 1
a942 1
    struct rt_vls infocommand;
d955 1
a955 1
    rt_delete_hook(gui_output, (genptr_t)interp);/* Delete the existing hook */
d962 5
a966 5
    rt_vls_init(&infocommand);
    rt_vls_strcat(&infocommand, "info commands ");
    rt_vls_strcat(&infocommand, argv[1]);
    status = Tcl_Eval(interp, rt_vls_addr(&infocommand));
    rt_vls_free(&infocommand);
d982 2
a983 2
    rt_vls_strcpy(&tcl_output_hook, argv[1]);
    rt_add_hook(gui_output, (genptr_t)interp);
d1011 1
a1011 1
  struct rt_vls str;
d1016 1
a1016 1
  rt_vls_init(&tcl_output_hook);
d1036 1
a1036 1
  rt_vls_init(&str);
d1038 1
a1038 1
  rt_vls_printf(&str, "set auto_path \\[linsert $auto_path 0 %s\\];\
d1041 1
a1041 1
  rt_vls_free(&str);
d1087 1
a1087 1
    struct rt_vls temp;
d1089 1
a1089 1
    rt_vls_init(&temp);
d1093 3
a1095 3
	rt_vls_strcpy(&temp, "info commands ");
	rt_vls_strcat(&temp, ftp->ft_name);
	if (Tcl_Eval(interp, rt_vls_addr(&temp)) != TCL_OK ||
d1101 2
a1102 2
	rt_vls_strcpy(&temp, "_mged_");
	rt_vls_strcat(&temp, ftp->ft_name);
d1107 1
a1107 1
	    (void)Tcl_CreateCommand(interp, rt_vls_addr(&temp), ftp->ft_func,
d1113 1
a1113 1
	    (void)Tcl_CreateCommand(interp, rt_vls_addr(&temp), cmd_wrapper,
d1154 1
a1154 1
    rt_vls_free(&temp);
d1179 1
a1179 1
    if(!strcmp(argv[1], rt_vls_addr(&clp->name))){
d1185 1
a1185 1
    clp = (struct cmd_list *)rt_malloc(sizeof(struct cmd_list), "cmd_list");
d1189 3
a1191 3
    rt_vls_init(&clp->more_default);
    rt_vls_init(&clp->name);
    rt_vls_strcpy(&clp->name, argv[1]);
d1203 1
a1203 1
  clp = (struct cmd_list *)rt_malloc(sizeof(struct cmd_list), "cmd_list");
d1207 3
a1209 3
  rt_vls_init(&clp->more_default);
  rt_vls_init(&clp->name);
  rt_vls_strcpy(&clp->name, argv[1]);
d1230 1
a1230 1
    Tcl_AppendElement(interp, rt_vls_addr(&curr_cmd_list->name));
d1241 1
a1241 1
	Tcl_AppendElement(interp, rt_vls_addr(&p->aim->name));
d1264 1
a1264 1
    if(strcmp(rt_vls_addr(&p->name), argv[1]))
d1277 1
a1277 1
  rt_vls_trunc(&curr_cmd_list->more_default, 0);
d1295 1
a1295 1
  Tcl_AppendResult(interp, rt_vls_addr(&curr_cmd_list->more_default), (char *)NULL);
d1307 1
a1307 1
  struct rt_vls dest, src;
d1314 3
a1316 3
  rt_vls_init(&src);
  rt_vls_init(&dest);
  rt_vls_strcpy(&src, argv[1]);
d1318 3
a1320 3
  Tcl_AppendResult(interp, rt_vls_addr(&dest), (char *)NULL);
  rt_vls_free(&src);
  rt_vls_free(&dest);
d1333 1
a1333 1
struct rt_vls *dest, *src;
d1337 1
a1337 1
    ptr = rt_vls_addr(src);
d1343 1
a1343 1
	rt_vls_putc( dest, *ptr++ );
d1349 1
a1349 1
struct rt_vls *dest, *src;
d1356 1
a1356 1
    for( ptr = rt_vls_addr( src ); *ptr; ptr++ ) {
d1358 1
a1358 1
	    rt_vls_strcat( dest, "\\[" );
d1360 1
a1360 1
	    rt_vls_strcat( dest, "\\]" );
d1362 1
a1362 1
	    rt_vls_strcat( dest, "\\" );
d1364 1
a1364 1
	    rt_vls_strcat( dest, buf );
d1370 1
a1370 1
	    rt_vls_strcat( dest, buf );
d1383 1
a1383 1
struct rt_vls *dest, *src;
d1389 2
a1390 2
    struct rt_vls word;         /* Current word being processed */
    struct rt_vls temp;
d1392 2
a1393 2
    rt_vls_init( &word );
    rt_vls_init( &temp );
d1395 1
a1395 1
    start = end = rt_vls_addr( src );
d1406 1
a1406 1
		rt_vls_putc( dest, *start++ );
d1418 1
a1418 1
	rt_vls_trunc( &word, 0 );
d1432 1
a1432 1
	    rt_vls_putc( &word, *end++ );
d1442 2
a1443 2
	    rt_vls_trunc( &temp, 0 );
	    if( regexp_match_all(&temp, rt_vls_addr(&word)) == 0 ) {
d1447 1
a1447 1
		rt_vls_vlscat( dest, &temp );
d1455 2
a1456 2
    rt_vls_free( &temp );
    rt_vls_free( &word );
d1473 1
a1473 1
struct rt_vls *vp;
d1477 1
a1477 1
    struct rt_vls globbed;
d1480 1
a1480 1
    extern struct rt_vls mged_prompt;
d1485 1
a1485 1
    if (rt_vls_strlen(vp) <= 0)
d1488 1
a1488 1
    rt_vls_init(&globbed);
d1504 1
a1504 1
	rt_vls_vlscat(&globbed, vp);
d1507 1
a1507 1
    status = Tcl_Eval(interp, rt_vls_addr(&globbed));
d1526 1
a1526 1
	  struct rt_vls tmp_vls;
d1528 4
a1531 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "distribute_text {} {%s} {%s}",
			rt_vls_addr(&globbed), interp->result);
	  Tcl_Eval(interp, rt_vls_addr(&tmp_vls));
d1533 1
a1533 1
	  rt_vls_free(&tmp_vls);
d1542 2
a1543 2
      rt_vls_free(&globbed);
      rt_vls_strcpy(&mged_prompt, MGED_PROMPT);
d1553 2
a1554 2
	      rt_vls_trunc(&mged_prompt, 0);
	      rt_vls_printf(&mged_prompt, "\r%s",
d1559 2
a1560 2
	      rt_vls_trunc(&mged_prompt, 0);
	      rt_vls_printf(&mged_prompt, "\r%s",
d1564 1
a1564 1
	    rt_vls_free(&globbed);
d1575 2
a1576 2
	rt_vls_free(&globbed);
	rt_vls_strcpy(&mged_prompt, MGED_PROMPT);
d1899 1
a1899 1
	struct rt_vls		str;
d1901 1
a1901 1
	rt_vls_init(&str);
d1907 2
a1908 2
	/* XXX should be rt_vls_strgrab() */
	Tcl_AppendResult(interp, rt_vls_strdup( &str), (char *)NULL);
d1910 1
a1910 1
	rt_vls_free(&str);
d1921 1
a1921 1
	struct rt_vls		str;
d1924 1
a1924 1
	  rt_vls_init(&str);
d1931 2
a1932 2
	  Tcl_AppendResult(interp, rt_vls_addr( &str ), (char *)NULL);
	  rt_vls_free(&str);
d2031 1
a2031 1
  struct rt_vls str;
d2037 1
a2037 1
  rt_vls_init(&str);
d2040 1
a2040 1
    rt_vls_strcpy( &str, "press accept\npress sill\n" );
d2043 1
a2043 1
    rt_vls_strcpy( &str, "M 1 0 0\n");
d2048 1
a2048 1
    rt_vls_strcpy( &str, "press accept\npress oill\n" );
d2053 1
a2053 1
    rt_vls_strcpy( &str, "M 1 0 0\n");
d2059 1
a2059 1
  rt_vls_free(&str);
d2080 2
a2081 2
	Tcl_AppendResult(interp, rt_vls_addr(&p_cmd->name), " ---> ",
			 rt_vls_addr(&p_cmd->aim->_pathName),
d2084 1
a2084 1
	Tcl_AppendResult(interp, rt_vls_addr(&p_cmd->name), " ---> ",
d2088 2
a2089 2
      Tcl_AppendResult(interp, rt_vls_addr(&p_cmd->name), " ---> ",
		       rt_vls_addr(&p_cmd->aim->_pathName),
d2092 1
a2092 1
      Tcl_AppendResult(interp, rt_vls_addr(&p_cmd->name), " ---> ",
d2099 1
a2099 1
    if(!strcmp(rt_vls_addr(&p_cmd->name), argv[1]))
d2103 1
a2103 1
     (strcmp(rt_vls_addr(&head_cmd_list.name), argv[1]))){
d2112 2
a2113 2
      Tcl_AppendResult(interp, rt_vls_addr(&p_cmd->name), " ---> ",
		       rt_vls_addr(&p_cmd->aim->_pathName),
d2116 1
a2116 1
      Tcl_AppendResult(interp, rt_vls_addr(&p_cmd->name), " ---> ", "\n", (char *)NULL);
d2122 1
a2122 1
    if(!strcmp(argv[2], rt_vls_addr(&p_dm->_pathName)))
d2126 1
a2126 1
     strcmp(argv[2], rt_vls_addr(&head_dm_list._pathName))){
d2144 2
a2145 2
  Tcl_AppendResult(interp, rt_vls_addr(&p_cmd->name), " ---> ",
		   rt_vls_addr(&p_cmd->aim->_pathName),
d2381 1
a2381 1
    Tcl_AppendResult(interp, rt_vls_addr(&pathName), "\n", (char *)NULL);
d2387 1
a2387 1
    if( !strcmp( argv[1], rt_vls_addr( &p->_pathName ) ) ){
d2473 1
a2473 1
  struct rt_vls xval, yval, zval;
d2475 9
a2483 9
  rt_vls_init(&xval);
  rt_vls_init(&yval);
  rt_vls_init(&zval);
  rt_vls_printf(&xval, "%f", x);
  rt_vls_printf(&yval, "%f", y);
  rt_vls_printf(&zval, "%f", z);
  av[1] = rt_vls_addr(&xval);
  av[2] = rt_vls_addr(&yval);
  av[3] = rt_vls_addr(&zval);
d2508 3
a2510 3
  rt_vls_free(&xval);
  rt_vls_free(&yval);
  rt_vls_free(&zval);
@


11.96
log
@Minor mods for IRIX 6.2.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.95 1996/08/20 20:38:32 jra Exp jra $ (BRL)";
d240 2
d246 2
a253 2
"eac", "Air_code(s)", "display all regions with given air code",
	f_eac, 2, MAXARGS,TRUE,
d443 2
d549 2
d1528 1
a1528 1
	  rt_vls_printf(&tmp_vls, "distribute_text \{\} \{%s\} \{%s\}",
d1680 2
@


11.95
log
@Added "eac", "eid", and "whatid" commands.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.94 1996/08/20 19:19:52 bparker Exp jra $ (BRL)";
d64 1
a64 1
void set_tran(), gui_setup(), mged_setup(), cmd_setup();
d1374 1
a1374 1
int
@


11.94
log
@If MGED_TCL_LIBRARY is set, then use it.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.93 1996/08/14 18:11:36 jra Exp bparker $ (BRL)";
d71 1
d73 2
d250 4
d535 2
@


11.93
log
@Added whichair command (similar to whichid).
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.92 1996/08/02 18:02:24 bparker Exp jra $ (BRL)";
d286 1
a286 1
"hist_add", "", "Adds command to the history (without executing it)",
d996 1
d1021 1
d1023 1
a1023 1
set junk \"\"", MGED_LIBRARY);
@


11.92
log
@remove minus signs in f_slewview()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.91 1996/07/31 00:17:24 cnuzman Exp bparker $ (BRL)";
d71 1
d528 2
@


11.91
log
@added cmd_who
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.90 1996/07/30 21:28:59 bparker Exp cnuzman $ (BRL)";
a204 2
"dbconcat", "file [prefix]", "concatenate 'file' onto end of present database.  Run 'dup file' first.",
	f_concat, 2, 3, TRUE,
d216 2
d371 2
a452 2
"oscale", "factor", "scale object by factor",
	f_sc_obj,2,2,TRUE,
a456 2
"vars",	"[var=opt]", "assign/display mged variables",
	f_set,1,2,TRUE,
d477 1
a477 1
"sv", "x y", "Move view center to (x, y, 0)",
d509 2
d2219 2
a2220 2
  tabvec[X] =  -x / 2047.0;
  tabvec[Y] =  -y / 2047.0;
d2381 1
d2494 1
@


11.90
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.89 1996/07/25 17:56:14 bparker Exp bparker $ (BRL)";
d91 1
d529 2
@


11.89
log
@-declare f_load_dv in the function table
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.88 1996/07/19 20:48:37 bparker Exp bparker $ (BRL)";
d82 2
a83 2
point_t e_axis_pos;
void set_e_axis_pos();
d528 1
a528 1
"winset", "pathname", "sets the window focus to the Tcl/Tk window with pathname",
d2225 1
a2225 1
set_e_axis_pos()
d2231 1
a2231 1
  VMOVE(e_axis_pos, es_keypoint);
d2311 1
a2311 1
    VMOVE(e_axis_pos, ((struct rt_arb_internal *)es_int.idb_ptr)->pt[i]);
d2319 1
a2319 1
      VADD2(e_axis_pos, tgc->h, tgc->v);
d2323 1
a2323 1
    VMOVE(e_axis_pos, es_keypoint);
d2328 1
a2328 1
    MAT4X3PNT( absolute_slew, model2view, e_axis_pos );
d2394 3
a2396 3
  diff[X] = x - e_axis_pos[X];
  diff[Y] = y - e_axis_pos[Y];
  diff[Z] = z - e_axis_pos[Z];
@


11.88
log
@-changed vget to viewget for Carl
-modified for auto loading
-some cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.87 1996/07/15 20:31:51 bparker Exp bparker $ (BRL)";
d332 2
d1029 1
a1034 1
#if 1
a1035 3
#else
    exit(1);
#endif
d2366 2
@


11.87
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.86 1996/07/10 20:25:02 bparker Exp bparker $ (BRL)";
d89 1
a89 1
extern int cmd_vget();
d104 1
d511 2
a512 2
"vget", "center|size|eye|ypr|quat", "Experimental - return high-precision view parameters.",
	cmd_vget, 2, 2, TRUE,
d730 3
d762 1
a762 1

d987 2
d1010 8
a1017 1
  gui_setup();
a1022 3
  FILE    *fp;
  struct rt_vls str;
  char *path;
d1024 2
a1025 1
  int     found;
d1027 2
a1028 10
#define MGED_GUIRC "mged2.tcl"
#include "./mgedGui.h"
#include "./menuGui.h"
#include "./slidersGui.h"
#include "./editobjGui.h"
#include "./icreateGui.h"
#include "./solclickGui.h"
#include "./solcreateGui.h"
#include "./vmathUi.h"
#include "./htmlLibraryUi.h"
d1031 4
a1034 1
    rt_log("mged_setup: Failed to create main window.\n");
d1036 1
d1043 2
a1044 15
  /* Load default GUI */
  Tcl_Eval( interp, vmath_ui_str );
  Tcl_Eval( interp, vmath_ui_str2 );
  Tcl_Eval( interp, html_library_ui_str );
  Tcl_Eval( interp, mged_gui_str );
  Tcl_Eval( interp, mged_gui_str2 );
  Tcl_Eval( interp, menu_gui_str );
  Tcl_Eval( interp, sliders_gui_str );
  Tcl_Eval( interp, editobj_gui_str );
  Tcl_Eval( interp, icreate_gui_str );
  Tcl_Eval( interp, solclick_gui_str );
  Tcl_Eval( interp, solcreate_gui_str );

  found = 0;
  rt_vls_init( &str );
d1046 1
d1048 1
a1048 36
    /* Use default file name */
    filename = MGED_GUIRC;

  if((path = getenv("MGED_LIBRARY")) != (char *)NULL ){
    /* Use MGED_LIBRARY path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL ){
      found = 1;
      fclose( fp );
      (void)Tcl_EvalFile( interp, rt_vls_addr(&str) );
    }
  }

  if( (path = getenv("HOME")) != (char *)NULL )  {
    /* Use HOME path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL ){
      found = 1;
      fclose( fp );
      (void)Tcl_EvalFile( interp, rt_vls_addr(&str) );
    }
  }

  /* Check current directory */
  if( (fp = fopen( filename, "r" )) != NULL )  {
    rt_vls_strcpy( &str, filename );
    found = 1;
    fclose( fp );
    (void)Tcl_EvalFile( interp, rt_vls_addr(&str) );
  }
d1050 2
a1051 9
  /* Didn't find a startup file, so warn user */
  if(!found){
    rt_log("gui_setup: user interface startup file was not found.\n");
    rt_log("         - Using default interface.\n\n");
    rt_log("Note: there are three environment variables that can be set.\n");
    rt_log("\tMGED_GUIRC - user interface startup file.\n");
    rt_log("\tMGED_LIBRARY - search path for Tcl files.\n");
    rt_log("\tMGED_HTML_DIR - search path for html files.\n\n");
  }
a1052 1
  rt_vls_free(&str);
d1502 1
a1502 1
	if (record){
@


11.86
log
@house cleaning
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.85 1996/06/28 22:46:18 cnuzman Exp bparker $ (BRL)";
d1038 1
d1041 1
d2182 2
a2183 2
  char *av_attach[] = {"attach", "ps", NULL, NULL};
  char *av_release[] = {"release", NULL};
d2188 2
d2191 1
d2198 3
d2492 1
a2492 1
  char *av[] = {NULL, NULL, NULL, NULL, NULL};
d2504 1
a2507 2
    char vrot_str[] = "vrot";

d2511 1
a2511 1
    av[0] = vrot_str;
d2521 1
a2521 3
    char p_str[] = "p";

    av[0] = p_str;
d2524 1
a2524 3
    char rotobj_str[] = "rotobj";

    av[0] = rotobj_str;
@


11.85
log
@??
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.84 1996/06/21 16:01:21 bparker Exp bparker $ (BRL)";
d201 2
a358 2
"comb_color", "comb R G B", "assign a color to a combination (like 'mater')",
	f_comb_color, 5,5,TRUE,
a2047 40
f_button(argc, argv)
int	argc;
char	*argv[];
{
  int	save_journal;
  int result;

  if(button_hook){
    save_journal = journal;
    journal = 0;
    result = (*button_hook)(atoi(argv[1]));
    journal = save_journal;
    return result;
  }

  rt_log( "button: currently not available for this display manager\n");
  return CMD_BAD;
}

int
f_slider(argc, argv)
int	argc;
char	*argv[];
{
  int	save_journal;
  int result;

  if(slider_hook){
    save_journal = journal;
    journal = 0;
    result = (*slider_hook)(atoi(argv[1]), atoi(argv[2]));
    journal = save_journal;
    return result;
  }

  rt_log( "slider: currently not available for this display manager\n");
  return CMD_BAD;
}

int
a2082 28

int
f_openw(argc, argv)
int     argc;
char    *argv[];
{
  if(openw_hook){
  	if(argc == 1)
		return (*openw_hook)(NULL);
  	else
		return (*openw_hook)(argv[1]);
  }

  rt_log( "openw: currently not available\n");
  return CMD_BAD;
}

int
f_closew(argc, argv)
int     argc;
char    *argv[];
{
  if(closew_hook)
    return (*closew_hook)(argv[1]);

  rt_log( "closew: currently not available\n");
  return CMD_BAD;
}
a2275 3
#if 0
  VSETALL( absolute_slew, 0 );
#endif
d2368 1
a2368 1
  if(EDIT_TRAN){
d2371 7
a2377 1
    /*XXX Nothing yet */
a2465 1

d2480 1
a2481 1
  point_t old_pos;
d2501 3
a2503 1
    MAT_DELTAS_GET(old_pos, toViewcenter);
d2507 6
a2512 6
    MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
    VSUB2(diff, new_pos, orig_pos);
    VADD2(new_pos, old_pos, diff);
    VSET(view_pos, new_pos[X], new_pos[Y], new_pos[Z]);
    MAT4X3PNT( new_pos, model2view, view_pos);
    VMOVE( absolute_slew, new_pos );
@


11.84
log
@modified cmd_getknob(), cmd_init()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.83 1996/06/19 16:26:08 cnuzman Exp bparker $ (BRL)";
d2338 7
d2346 1
a2346 2
  update_views = 1;

d2438 7
d2519 5
a2523 9
  VMOVE( absolute_slew, view_pos );

  /* if doing an edit other than a rotate then do the regular thing */
  if((state == ST_S_EDIT || state == ST_O_EDIT) &&
     (!EDIT_ROTATE && es_edflag > IDLE)){
    int status;
    char *av[] = {"M", "1", NULL, NULL, NULL};
    char xval[32], yval[32];

d2525 1
a2525 5
    av[2] = xval;
    av[3] = yval;
    sprintf(xval, "%d", (int)(absolute_slew[X]*2048.0));
    sprintf(yval, "%d", (int)(absolute_slew[Y]*2048.0));
    status = f_mouse((ClientData)NULL, interp, 4, av);
d2527 1
a2527 6

    if(status == TCL_OK)
      return CMD_OK;
    else
      return CMD_BAD;
  }else{ /* otherwise, slew the view */
d2536 1
d2538 1
a2538 2
    return CMD_OK;
  }
d2551 1
a2551 1
  char xval[32], yval[32], zval[32];
d2553 9
a2561 6
  av[1] = xval;
  av[2] = yval;
  av[3] = zval;
  sprintf(xval, "%f", x);
  sprintf(yval, "%f", y);
  sprintf(zval, "%f", z);
d2588 4
@


11.83
log
@added viewset command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.82 1996/06/18 17:33:51 cnuzman Exp cnuzman $ (BRL)";
d777 28
d806 31
d895 1
a895 1
    
d1191 1
d1198 28
d1233 2
@


11.82
log
@replaced read_center,read_scale with more general "vget"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.81 1996/06/14 19:59:00 bparker Exp cnuzman $ (BRL)";
d90 1
d512 2
@


11.81
log
@house cleaning
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.80 1996/06/11 16:57:53 bparker Exp bparker $ (BRL)";
d89 1
a89 2
extern int cmd_read_center();
extern int cmd_read_scale();
d509 2
a510 4
"read_center", "", "Experimental - return coords of view center",
	cmd_read_center, 1, 1, TRUE,
"read_scale", "", "Experimental - return coords of view scale",
	cmd_read_scale, 1, 1, TRUE,
@


11.80
log
@load default GUI strings.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.79 1996/06/03 12:46:48 jra Exp bparker $ (BRL)";
a775 1
/*XXX I need to come back later and fix this */
d831 5
a835 9
#if 0
    for (i = 0; i < sizeof(knobs); i++)
#else
      for (i = 0; i < 19; ++i)
#endif
	if (strcmp(knobs[i].knobname, argv[1]) == 0) {
	    sprintf(interp->result, "%lf", *(knobs[i].variable));
	    return TCL_OK;
	}
d1145 1
a1145 7
#if 0
  sscanf(argv[2], "%x", &clp->id);
  clp->sp = (void *)Tk_Display(Tk_NameToWindow(interp, argv[3], tkwin));
#else
  rt_vls_init(&clp->path);
  rt_vls_strcpy(&clp->path, argv[2]);
#endif
@


11.79
log
@Modified make_bb command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.78 1996/05/31 22:30:22 bparker Exp jra $ (BRL)";
d963 9
a971 1
#include "./sliders.h"
d982 10
a991 2
  /* Load redefined knob command */
/*  Tcl_Eval( interp, knob_str ); */
d1036 6
a1041 5
    rt_log("gui_setup: user interface startup file was not found.\n\n");
    rt_log("Note: there are three environment variables that should be set.\n");
    rt_log("\tMGED_GUIRC is the name of the user interface startup file.\n");
    rt_log("\tMGED_LIBRARY is the path where the Tcl files live.\n");
    rt_log("\tMGED_HTML_DIR is the path where the html files live.\n\n");
d1138 2
a1139 2
  if(argc != 2){
    Tcl_AppendResult(interp, "Usage: cmd_init id", (char *)NULL);
a1145 1
  strcpy((char *)clp->name, argv[1]);
d1148 9
d1174 1
a1174 1
    Tcl_AppendElement(interp, curr_cmd_list->name);
d1185 1
a1185 1
	Tcl_AppendElement(interp, p->aim->name);
d1208 1
a1208 1
    if(strcmp((char *)p->name, argv[1]))
a1224 1

d1597 3
d2090 2
a2091 1
	Tcl_AppendResult(interp, p_cmd->name, " ---> ", rt_vls_addr(&p_cmd->aim->_pathName),
d2094 2
a2095 1
	Tcl_AppendResult(interp, p_cmd->name, " ---> ", "\n", (char *)NULL);
d2098 2
a2099 1
      Tcl_AppendResult(interp, p_cmd->name, " ---> ", rt_vls_addr(&p_cmd->aim->_pathName),
d2102 2
a2103 1
      Tcl_AppendResult(interp, p_cmd->name, " ---> ", "\n", (char *)NULL);
d2109 1
a2109 1
    if(!strcmp((char *)p_cmd->name, argv[1]))
d2113 1
a2113 1
     (strcmp(head_cmd_list.name, argv[1]))){
d2122 2
a2123 1
      Tcl_AppendResult(interp, p_cmd->name, " ---> ", rt_vls_addr(&p_cmd->aim->_pathName),
d2126 1
a2126 1
      Tcl_AppendResult(interp, p_cmd->name, " ---> ", "\n", (char *)NULL);
d2154 2
a2155 1
  Tcl_AppendResult(interp, p_cmd->name, " ---> ", rt_vls_addr(&p_cmd->aim->_pathName),
@


11.78
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.77 1996/05/24 18:19:48 bparker Exp bparker $ (BRL)";
d337 2
a338 2
"make_bb", "new_rpp_name obj1 [obj2 obj3 ...]", "make a bounding box solid enclosing specified objects",
	f_make_bb, 1, MAXARGS, TRUE,
d975 1
a975 1
  Tcl_Eval( interp, knob_str );
@


11.77
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.76 1996/05/13 20:48:28 bparker Exp bparker $ (BRL)";
a749 1

d949 1
d963 6
d970 7
d990 1
a990 1
    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL )
d992 3
d997 5
a1001 6
  if(!found){
    if( (path = getenv("HOME")) != (char *)NULL )  {
      /* Use HOME path */
      rt_vls_strcpy( &str, path );
      rt_vls_strcat( &str, "/" );
      rt_vls_strcat( &str, filename );
d1003 4
a1006 2
      if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
	found = 1;
d1010 6
a1015 6
  if( !found ) {
    /* Check current directory */
    if( (fp = fopen( filename, "r" )) != NULL )  {
      rt_vls_strcpy( &str, filename );
      found = 1;
    }
d1018 1
a1024 8
    return;
  }

  fclose( fp );

  if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
    rt_vls_free(&str);
    return;
a2225 3
#if 0
  rot_x = rot_y = rot_z = 0;
#endif
a2226 1

d2396 3
a2398 1
  if(state == ST_S_EDIT || state == ST_O_EDIT){
d2415 1
a2415 1
  }else{
d2438 1
a2438 1
  char *av[] = {"vrot", NULL, NULL, NULL, NULL};
a2440 2
  MAT_DELTAS_GET(old_pos, toViewcenter);

d2447 22
a2468 1
  status = f_vrot((ClientData)NULL, interp, 4, av);
d2470 3
a2472 6
  MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
  VSUB2(diff, new_pos, orig_pos);
  VADD2(new_pos, old_pos, diff);
  VSET(view_pos, new_pos[X], new_pos[Y], new_pos[Z]);
  MAT4X3PNT( new_pos, model2view, view_pos);
  VMOVE( absolute_slew, new_pos );
@


11.76
log
@modify f_irot to always call f_vrot
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.75 1996/05/02 21:29:03 bparker Exp bparker $ (BRL)";
d63 1
a63 1
int f_tran(), f_irot();
d295 1
d298 1
d301 1
d304 1
d495 1
d498 1
d797 6
a802 1
	"S", (fastf_t *)NULL
d822 5
d833 1
d835 3
d2203 2
a2204 2
  tabvec[X] =  x / 2047.0;
  tabvec[Y] =  y / 2047.0;
d2216 1
a2216 1
  tran_x = tran_y = tran_z = 0;
d2218 2
d2354 1
a2354 1
 * Calculate the values for tran_x, tran_y, and tran_z.
d2371 1
a2371 1
  /* If there is more than one active view, then tran_x/y/z
d2376 1
a2376 4

  tran_x = view_pos[X];
  tran_y = view_pos[Y];
  tran_z = view_pos[Z];
d2381 2
a2382 5
f_tran(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    *argv[];
a2383 4
  double x, y, z;
  int itran;
  char cmd[128];
  vect_t view_pos;
d2387 7
a2393 2
  struct rt_vls str;
  int status;
d2395 7
a2401 2
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;
d2403 4
a2406 10
  sscanf(argv[1], "%lf", &x);
  sscanf(argv[2], "%lf", &y);
  sscanf(argv[3], "%lf", &z);

  itran = !strcmp(argv[0], "itran");

  if(itran){
    tran_x += x;
    tran_y += y;
    tran_z += z;
d2408 3
a2410 4
    tran_x = x;
    tran_y = y;
    tran_z = z;
  }
a2411 8
  VSET( view_pos, tran_x, tran_y, tran_z );
  MAT4X3PNT( new_pos, view2model, view_pos );
  MAT_DELTAS_GET_NEG( old_pos, toViewcenter );
  VSUB2( diff, new_pos, old_pos );

  if(state == ST_S_EDIT || state == ST_O_EDIT)
    sprintf(cmd, "M %d %d %d\n", 1, (int)(tran_x*2048.0), (int)(tran_y*2048.0));
  else{
d2417 1
a2417 1
    return TCL_OK;
a2418 12

  tran_set = 1;
  rt_vls_init(&str);
  rt_vls_strcpy( &str, cmd );
  status = cmdline(&str, False);
  rt_vls_free(&str);
  tran_set = 0;

  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
d2422 2
a2423 5
f_irot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
a2424 3
  double x, y, z;
  char cmd[128];
  struct rt_vls str;
d2430 2
a2431 9

  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  rt_vls_init(&str);

  sscanf(argv[1], "%lf", &x);
  sscanf(argv[2], "%lf", &y);
  sscanf(argv[3], "%lf", &z);
d2435 7
a2441 9
#if 1
  sprintf(cmd, "vrot %f %f %f\n", x, y, z);
#else
  if(state == ST_VIEW)
    sprintf(cmd, "vrot %f %f %f\n", x, y, z);
  else{
    rot_x += x;
    rot_y += y;
    rot_z += z;
d2443 6
a2448 8
    if(state == ST_O_EDIT)
      sprintf(cmd, "rotobj %f %f %f\n", rot_x, rot_y, rot_z);
    else if(state == ST_S_EDIT)
      sprintf(cmd, "p %f %f %f\n", rot_x, rot_y, rot_z);
    else
      return TCL_OK;
  }
#endif
d2450 2
a2451 5
  rot_set = 1;
  rt_vls_strcpy( &str, cmd );
  status = cmdline(&str, False);
  rt_vls_free(&str);
  rot_set = 0;
d2453 1
a2453 15
  if(state == ST_VIEW){
    MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
    VSUB2(diff, new_pos, orig_pos);
    VADD2(new_pos, old_pos, diff);
    VSET(view_pos, new_pos[X], new_pos[Y], new_pos[Z]);
    MAT4X3PNT( new_pos, model2view, view_pos);
    tran_x = new_pos[X];
    tran_y = new_pos[Y];
    tran_z = new_pos[Z];
  }

  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
@


11.75
log
@Still Tcl'ing the code
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.74 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d2453 3
d2470 1
@


11.74
log
@still tcl-converting
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.73 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d61 1
d167 2
d405 2
d515 2
d984 1
a984 1
    rt_log("\tMGED_GUIRC is the name of the startup file.\n");
d1050 2
d1106 32
a1137 1
/* sets the current command window */
d1404 2
d1408 2
a1409 4
    /* If the command had something to say, print it out. */	     
	if (len > 0) {
	  struct rt_vls tmp_vls;

d1413 5
d1425 3
d1429 2
a1430 3
    /* Then record it in the history, if desired. */
	if (record)
	  history_record(vp, &start, &finish, CMD_OK);
d1432 3
a1434 3
	rt_vls_free(&globbed);
	rt_vls_strcpy(&mged_prompt, MGED_PROMPT);
	return CMD_OK;
d1638 2
d1641 1
d2018 81
d2316 4
d2464 2
@


11.73
log
@convert commands to Tcl
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.72 1996/04/03 22:04:20 bparker Exp bparker $ (BRL)";
d63 1
a63 1
void set_tran();
d67 1
d178 1
a178 1
"attach", "[device]", "attach to a display processor, or NU",
d384 2
a385 4
#if 0
"ps", "[f] file", "create postscript file of current view with or without the faceplate",
        f_ps, 2, 3,FALSE,
#endif
d494 2
d896 1
a896 1
/* 			C M D _ S E T U P
d898 1
a898 1
 * Sets up the Tcl interpreter and calls other setup functions.
d900 16
d917 9
d927 1
a927 2
cmd_setup(interactive)
int interactive;
d929 53
a981 2
    register struct funtab *ftp;
    struct rt_vls temp;
d983 1
a983 1
    rt_vls_init(&temp);
d985 4
a988 3
    /* The following is for GUI output hooks: contains name of function to
       run with output */
    rt_vls_init(&tcl_output_hook);
d990 3
a992 1
    /* Create the interpreter */
a993 1
    interp = Tcl_CreateInterp();
d995 8
a1002 4
#if 0
    Tcl_SetVar(interp, "tcl_interactive", interactive ? "1" : "0",
	       TCL_GLOBAL_ONLY);
#endif
d1004 1
a1004 3
    /* This runs the init.tcl script */
    if( Tcl_Init(interp) == TCL_ERROR )
	rt_log("Tcl_Init error %s\n", interp->result);
a1005 1
    /* Finally, add in all the MGED commands.  Warn if they conflict */
d1025 1
d1030 3
d1045 2
a1068 3

    history_setup();
    mged_variable_setup(interp);
d1335 2
a1336 1
    if (rt_vls_strlen(vp) <= 0) return 0;
d1367 5
d1373 7
a1379 2
	if (len > 0) rt_log("%s%s", interp->result,
			    interp->result[len-1] == '\n' ? "" : "\n");
d1382 2
a1383 2

	if (record) history_record(vp, &start, &finish, CMD_OK);
d1965 1
a1966 1
static
d1968 3
a1970 1
f_ps(argc, argv)
d1974 3
a1976 18
  struct dm *o_dmp;
  void (*o_dotitles_hook)();
  int o_faceplate;
  static int windowbounds[] = {
    2047, -2048, 2047, -2048, 2047, -2048
  };

  o_faceplate = mged_variables.faceplate;
  if(argc == 3){
    if(*argv[1] == 'f'){
      mged_variables.faceplate = 1;
      ++argv;
    }else{
      rt_log( "Usage: ps filename [f]\n");
      return CMD_BAD;
    }
  }else
    mged_variables.faceplate = 0;
d1978 2
a1979 4
  if( (ps_fp = fopen( argv[1], "w" )) == NULL )  {
	perror(argv[1]);
	return CMD_BAD;
  }
d1981 4
a1984 11
  o_dotitles_hook = dotitles_hook;
  dotitles_hook = NULL;
  o_dmp = dmp;
  dmp = &dm_PS;
  dmp->dmr_window(windowbounds);
#if 0
  if(dmp->dmr_open())
	goto clean_up;
#else

	setbuf( ps_fp, ps_ttybuf );
d1986 1
a1986 39
	mged_fputs( "%!PS-Adobe-1.0\n\
%begin(plot)\n\
%%DocumentFonts:  Courier\n", ps_fp );
	fprintf(ps_fp, "%%%%Title: %s\n", argv[1] );
	mged_fputs( "\
%%Creator: MGED dm-ps.c\n\
%%BoundingBox: 0 0 324 324	% 4.5in square, for TeX\n\
%%EndComments\n\
\n", ps_fp );

	mged_fputs( "\
4 setlinewidth\n\
\n\
% Sizes, made functions to avoid scaling if not needed\n\
/FntH /Courier findfont 80 scalefont def\n\
/DFntL { /FntL /Courier findfont 73.4 scalefont def } def\n\
/DFntM { /FntM /Courier findfont 50.2 scalefont def } def\n\
/DFntS { /FntS /Courier findfont 44 scalefont def } def\n\
\n\
% line styles\n\
/NV { [] 0 setdash } def	% normal vectors\n\
/DV { [8] 0 setdash } def	% dotted vectors\n\
/DDV { [8 8 32 8] 0 setdash } def	% dot-dash vectors\n\
/SDV { [32 8] 0 setdash } def	% short-dash vectors\n\
/LDV { [64 8] 0 setdash } def	% long-dash vectors\n\
\n\
/NEWPG {\n\
	.0791 .0791 scale	% 0-4096 to 324 units (4.5 inches)\n\
} def\n\
\n\
FntH  setfont\n\
NEWPG\n\
", ps_fp);

	in_middle = 0;
#endif

  color_soltab();
  dmaflag = 1;
d1988 1
a1988 6
  dmp->dmr_close();
clean_up:
  dmp = o_dmp;
  dotitles_hook = o_dotitles_hook;
  mged_variables.faceplate = o_faceplate;
  return CMD_OK;
a1989 1
#endif
@


11.72
log
@code to implement CMD_MORE with defaults while using the
Tcl/Tk command windows
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.71 1996/04/01 22:18:15 bparker Exp bparker $ (BRL)";
a57 2
#define MORE_ARGS_STR    "more arguments needed::"

d119 4
a122 4
	if( argc < 2 )  {
		Tcl_SetResult(interp, "insufficient args", TCL_STATIC);
		return TCL_ERROR;
	}
d124 2
a125 1
		return Tcl_Eval( interp, cmd );
d142 4
a145 4
	if( argc < 2 )  {
		Tcl_SetResult(interp, "insufficient args", TCL_STATIC);
		return TCL_ERROR;
	}
a150 11

struct funtab {
    char *ft_name;
    char *ft_parms;
    char *ft_comment;
    int (*ft_func)();
    int ft_min;
    int ft_max;
    int tcl_converted;
};

d157 1
a157 1
	f_comm,1,1,FALSE,
d159 1
a159 1
	f_3ptarb, 1, 27,FALSE,
d162 1
a162 1
        f_adc, 1, 5, FALSE,
d164 1
a164 1
	f_aeview, 3, 3, FALSE,
d166 1
a166 1
        f_aip, 1, 2, FALSE,
d168 1
a168 1
	f_analyze,1,MAXARGS,FALSE,
d172 1
a172 1
	f_arbdef,4,4,FALSE,
d174 1
a174 1
	f_arced, 3,MAXARGS,FALSE,
d176 1
a176 1
	f_area, 1, 2, FALSE,
d178 1
a178 1
	f_attach,1,3,FALSE,
d180 1
a180 1
	f_blast,2,MAXARGS,FALSE,
d182 1
a182 1
	f_bev, 2, MAXARGS, FALSE,
d188 1
a188 1
	f_comb_std,3,MAXARGS,FALSE,
d190 1
a190 1
	f_cat,2,MAXARGS,FALSE,
d192 1
a192 1
	f_center, 4,4, FALSE,
d194 1
a194 1
	f_color, 7, 7, FALSE,
d196 1
a196 1
	f_comb,4,MAXARGS,FALSE,
d198 1
a198 1
	f_concat, 2, 3, FALSE,
d201 1
a201 1
	f_copyeval, 1, 27, FALSE,
d203 1
a203 1
	f_copy,3,3, FALSE,
d205 1
a205 1
	f_copy_inv,3,3,FALSE,
d207 1
a207 1
	f_delobj,2,MAXARGS,FALSE,
d211 1
a211 1
	f_debugdir, 1, 1, FALSE,
d213 1
a213 1
	f_debuglib,1,2,FALSE,
d215 1
a215 1
	f_debugmem, 1, 1, FALSE,
d217 1
a217 1
	f_debugnmg,1,2,FALSE,
d219 1
a219 1
	f_delay,3,3,FALSE,
d221 1
a221 1
	f_dm, 2, MAXARGS, FALSE,
d223 1
a223 1
	f_dup, 2, 3, FALSE,
d225 1
a225 1
	f_evedit,2,MAXARGS,FALSE,
d227 1
a227 1
	f_edit,2,MAXARGS,FALSE,
d231 1
a231 1
	f_edcodes, 2, MAXARGS, FALSE,
d233 1
a233 1
	f_edcolor, 1, 1, FALSE,
d235 1
a235 1
	f_edcomb,6,7,FALSE,
d237 1
a237 1
	f_edgedir, 3, 4, FALSE,
d239 1
a239 1
	f_ev, 2, MAXARGS, FALSE,
d241 1
a241 1
	f_eqn, 4, 4, FALSE,
d243 1
a243 1
	f_quit,1,1,FALSE,
d245 1
a245 1
	f_extrude,3,3,FALSE,
d249 1
a249 1
	f_facedef, 2, MAXARGS, FALSE,
d251 1
a251 1
	f_facetize, 3, MAXARGS, FALSE,
d253 1
a253 1
	f_find, 1, MAXARGS, FALSE,
d255 1
a255 1
	f_fix,1,1,FALSE,
d257 1
a257 1
	f_fracture, 2, 3, FALSE,
d259 1
a259 1
	f_group,3,MAXARGS,FALSE,
d267 1
a267 1
	f_hideline,2,4,FALSE,
d270 1
a270 1
	f_help,0,MAXARGS,FALSE,
d272 1
a272 1
	f_history, 1, 4,FALSE,
d278 1
a278 1
        cmd_hist_add, 1, 1, TRUE,
d280 1
a280 1
	f_instance,3,4,FALSE,
d282 1
a282 1
	f_tables, 3, MAXARGS, FALSE,
d284 1
a284 1
       f_knob,2,3, FALSE,
d286 1
a286 1
	f_ill,2,2,FALSE,
d288 1
a288 1
	f_in, 1, MAXARGS, FALSE,
d290 1
a290 1
	f_inside, 1, MAXARGS, FALSE,
d292 1
a292 1
        f_irot, 4, 4, FALSE,
d294 1
a294 1
	f_itemair,3,4,FALSE,
d296 1
a296 1
        f_tran, 4, 4,FALSE,
d298 1
a298 1
	f_joint, 1, MAXARGS, FALSE,
d300 1
a300 1
	f_journal, 1, 2, FALSE,
d302 1
a302 1
	f_keep, 3, MAXARGS, FALSE,
d304 1
a304 1
	f_keypoint,1,4, FALSE,
d306 1
a306 1
	f_kill,2,MAXARGS,FALSE,
d308 1
a308 1
	f_killall, 2, MAXARGS,FALSE,
d310 1
a310 1
	f_killtree, 2, MAXARGS, FALSE,
d312 1
a312 1
	f_knob,2,3, FALSE,
d318 1
a318 1
	f_labelvert, 2, MAXARGS, FALSE,
d320 1
a320 1
	f_pathsum, 1, MAXARGS, FALSE,
d326 1
a326 1
	f_mouse, 4,4, FALSE,
d328 1
a328 1
	f_make,3,3,FALSE,
d330 1
a330 1
	f_make_bb, 1, MAXARGS, FALSE,
d332 1
a332 1
	f_mater,2,8,FALSE,
d334 1
a334 1
	f_matpick, 2,2,FALSE,
d336 1
a336 1
	f_memprint, 1, 1,FALSE,
d338 1
a338 1
	f_mirface,3,3,FALSE,
d340 1
a340 1
	f_mirror,4,4,FALSE,
d342 1
a342 1
	f_name,3,3,FALSE,
d344 1
a344 1
	f_mvall, 3, 3,FALSE,
d346 1
a346 1
	f_nirt,1,MAXARGS,FALSE,
d348 1
a348 1
	f_nmg_simplify, 3,4,FALSE,
d350 1
a350 1
	f_comb_color, 5,5,FALSE,
d354 1
a354 1
	f_opendb, 2, 2,FALSE,
d356 1
a356 1
	f_orientation, 5, 5,FALSE,
d358 1
a358 1
	f_rot_obj, 4, 4,FALSE,
d360 1
a360 1
	f_overlay, 2, 3,FALSE,
d362 1
a362 1
	f_param,2,4,FALSE,
d364 1
a364 1
	f_pathsum, 1, MAXARGS,FALSE,
d368 1
a368 1
	f_permute,2,2,FALSE,
d370 1
a370 1
	f_plot, 2, MAXARGS,FALSE,
d372 1
a372 1
	f_polybinout, 2, 2,FALSE,
d374 1
a374 1
	f_pov, 3+4+1, MAXARGS,FALSE,
d376 1
a376 1
	f_prcolor, 1, 1,FALSE,
d378 1
a378 1
	f_prefix, 3, MAXARGS,FALSE,
d380 1
a380 1
	f_preview, 2, MAXARGS,FALSE,
d382 1
a382 1
	f_press,2,MAXARGS,FALSE,
d388 1
a388 1
	f_push, 2, MAXARGS,FALSE,
d390 1
a390 1
	f_putmat, 3,MAXARGS,FALSE,
d392 1
a392 1
	f_quit,1,1,FALSE,
d394 1
a394 1
	f_quit,1,1,FALSE,
d396 1
a396 1
	f_qorot, 8, 8,FALSE,
d398 1
a398 1
	f_qvrot, 5, 5,FALSE,
d400 1
a400 1
	f_region,4,MAXARGS,FALSE,
d404 1
a404 1
	f_red, 2, 2,FALSE,
d406 1
a406 1
	f_refresh, 1,1,FALSE,
d408 1
a408 1
	f_regdebug, 1,2,FALSE,
d410 1
a410 1
	f_regdef, 2, 5,FALSE,
d412 1
a412 1
	f_tables, 3, MAXARGS,FALSE,
d414 1
a414 1
	f_release,1,2,FALSE,
d416 1
a416 1
	f_rfarb, 1, 27,FALSE,
d418 1
a418 1
	f_rm,3,MAXARGS,FALSE,
d420 1
a420 1
	f_rmats,2,MAXARGS,FALSE,
d422 1
a422 1
	f_rot_obj, 4, 4,FALSE,
d424 1
a424 1
	f_rrt,2,MAXARGS,FALSE,
d426 1
a426 1
	f_rt,1,MAXARGS,FALSE,
d428 1
a428 1
	f_rtcheck,1,MAXARGS,FALSE,
d434 1
a434 1
	f_savekey,2,MAXARGS,FALSE,
d436 1
a436 1
	f_saveview,2,MAXARGS,FALSE,
d438 1
a438 1
	f_showmats,2,2,FALSE,
d440 1
a440 1
	f_sc_obj,2,2,FALSE,
d442 1
a442 1
	f_sed,2,2,FALSE,
d444 1
a444 1
        f_setview,4,4,FALSE,
d446 1
a446 1
	f_set,1,2,FALSE,
d448 1
a448 1
	f_shells, 2,2,FALSE,
d450 1
a450 1
	f_shader, 3,MAXARGS,FALSE,
d452 1
a452 1
	f_view, 2,2,FALSE,
d460 1
a460 1
	f_tables, 3, MAXARGS,FALSE,
d464 1
a464 1
	f_status, 1,1,FALSE,
d466 1
a466 1
	f_summary,1,2,FALSE,
d468 1
a468 1
	f_slewview, 3, 3,FALSE,
d470 1
a470 1
	f_sync, 1, 1,FALSE,
d474 1
a474 1
	f_tabobj, 2, MAXARGS,FALSE,
d476 1
a476 1
	f_tedit,1,1,FALSE,
d478 1
a478 1
        f_tie, 3,3,FALSE,
d480 1
a480 1
	f_title,1,MAXARGS,FALSE,
d482 1
a482 1
	f_tol, 1, 11,FALSE,
d484 1
a484 1
	f_tops,1,1,FALSE,
d486 1
a486 1
	f_amtrack, 1, 27,FALSE,
d488 1
a488 1
        f_tran, 4, 4,FALSE,
d490 1
a490 1
	f_tr_obj,4,4,FALSE,
d492 1
a492 1
	f_tree, 2, MAXARGS,FALSE,
d494 1
a494 1
	f_units,1,2,FALSE,
d504 1
a504 1
	f_vrmgr, 3, MAXARGS,FALSE,
d506 1
a506 1
	f_vrot,4,4,FALSE,
d508 1
a508 1
	f_vrot_center, 5, 5,FALSE,
d510 1
a510 1
	f_which_id, 2, MAXARGS,FALSE,
d512 1
a512 1
        f_winset, 1, 2, FALSE,
d514 1
a514 1
	f_debug, 1,2,FALSE,
d516 1
a516 1
	f_xpush, 2,2,FALSE,
d518 1
a518 1
	f_zap,1,1,FALSE,
d520 1
a520 1
	f_zoom, 2,2,FALSE,
d715 3
d722 2
a723 2
	Tcl_SetResult(interp, "loadtk: already attached to display", TCL_STATIC);
	return TCL_ERROR;
d786 3
d805 1
a805 1
	Tcl_SetResult(interp, "getknob: need a knob name", TCL_STATIC);
d815 1
a815 1
    Tcl_SetResult(interp, "getknob: invalid knob name", TCL_STATIC);
d836 3
d840 3
a842 3
	Tcl_SetResult(interp,
		      "too many args: should be \"output_hook [hookName]\"",
		      TCL_STATIC);
d860 2
a861 2
	Tcl_SetResult(interp, "command does not exist", TCL_STATIC);
	return TCL_ERROR;
d867 1
a867 1
	Tcl_SetResult(interp, "Don't be silly.", TCL_STATIC);
d1001 1
a1001 1
    Tcl_SetResult(interp, "Usage: cmd_init id", TCL_STATIC);
d1026 1
a1026 1
    Tcl_SetResult(interp, "Usage: cmd_set id", TCL_STATIC);
d1059 1
a1059 1
    Tcl_SetResult(interp, "Usage: get_more_default", TCL_STATIC);
d1063 1
a1063 1
  Tcl_SetResult(interp, rt_vls_addr(&curr_cmd_list->more_default), TCL_VOLATILE);
d1078 1
a1078 1
    Tcl_SetResult(interp, "cmd_mged_glob: There must be only one argument.", TCL_STATIC);
d1086 1
a1086 1
  Tcl_SetResult(interp, rt_vls_addr(&dest), TCL_VOLATILE);
d1249 1
d1301 13
a1313 10
	if (strstr(interp->result, MORE_ARGS_STR) == interp->result) {
#if 0
	    rt_vls_strcpy(&mged_prompt,interp->result+sizeof(MORE_ARGS_STR)-1);
	    Tcl_SetResult(interp, rt_vls_addr(&mged_prompt), TCL_VOLATILE);
#else
	    rt_vls_trunc(&mged_prompt, 0);
	    rt_vls_printf(&mged_prompt, "\r%s",
			  interp->result+sizeof(MORE_ARGS_STR)-1);
	    Tcl_SetResult(interp, rt_vls_addr(&mged_prompt) + 1, TCL_VOLATILE);
#endif
d1375 3
a1377 3
		rt_log("mged_cmd(): Invalid return from %s\n",
		       ftp->ft_name);
		return CMD_BAD;
d1380 4
a1383 2
	rt_log("Usage: %s%s %s\n\t(%s)\n",functions[0].ft_name,
	       ftp->ft_name, ftp->ft_parms, ftp->ft_comment);
d1386 4
a1389 2
    rt_log("%s%s: no such command, type '%s?' for help\n",
	   functions[0].ft_name, argv[0], functions[0].ft_name);
d1393 37
d1431 1
d1449 7
a1455 4
	if( argc < 2 )  {
		Tcl_SetResult(interp, "apropos: insufficient args", TCL_STATIC);
		return TCL_ERROR;
	}
d1475 3
a1477 1
f_comm( argc, argv )
d1485 3
d1499 1
a1499 1
	rt_log("!\n");
d1501 1
a1501 1
	return CMD_OK;  /* ? */
d1508 3
a1510 1
f_quit( argc, argv )
d1514 8
a1521 4
	if( state != ST_VIEW )
		button( BE_REJECT );
	quit();			/* Exiting time */
	/* NOTREACHED */
d1527 3
a1529 1
f_sync(argc, argv)
d1533 4
a1537 1
    register int i;
d1540 1
a1540 1
    return CMD_OK;
d1555 2
a1556 2
	register struct funtab *ftp;
	register int	i, bad;
d1558 1
a1558 1
	bad = 0;
d1560 17
a1576 15
	/* Help command(s) */
	for( i=1; i<argc; i++ )  {
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			if( strcmp( ftp->ft_name, argv[i] ) != 0 )
				continue;
			rt_log("Usage: %s%s %s\n\t(%s)\n", functions->ft_name,
			    ftp->ft_name, ftp->ft_parms, ftp->ft_comment);
			break;
		}
		if( !ftp->ft_name ) {
			rt_log("%s%s: no such command, type '%s?' for help\n",
			    functions->ft_name, argv[i], functions->ft_name);
			bad = 1;
		}
	}
d1578 1
a1578 1
	return bad ? CMD_BAD : CMD_OK;
d1590 3
a1592 1
f_help( argc, argv )
d1603 3
d1618 6
a1623 6
		rt_log("The following commands are available:\n");
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			rt_log("%s%s %s\n\t(%s)\n", functions->ft_name,
			    ftp->ft_name, ftp->ft_parms, ftp->ft_comment);
		}
		return CMD_OK;
d1650 1
a1650 1
	Tcl_SetResult(interp, rt_vls_strdup( &str), TCL_DYNAMIC);
d1666 10
a1675 10
		rt_vls_init(&str);
		rt_log("The following %scommands are available:\n",
		    functions->ft_name);
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			vls_col_item( &str, ftp->ft_name);
		}
		vls_col_eol( &str );
		rt_log("%s", rt_vls_addr( &str ) );
		rt_vls_free(&str);
		return CMD_OK;
d1682 3
a1684 1
f_press( argc, argv )
d1688 4
a1691 1
	register int i;
d1693 2
a1694 2
	for( i = 1; i < argc; i++ )
		press( argv[i] );
d1696 1
a1696 1
	return CMD_OK;
d1700 3
a1702 1
f_summary( argc, argv )
d1710 3
d1716 1
a1716 1
		return CMD_OK;
d1730 4
a1733 3
			rt_log("summary:  S R or G are only valid parmaters\n");
			bad = 1;
			break;
d1735 1
d1737 1
a1737 1
	return bad ? CMD_BAD : CMD_OK;
d1755 3
d1759 1
a1759 1
	rt_log( i==1 ? "%s" : " %s", argv[i] );
a1760 1
    rt_log("\n");
d1762 2
d1965 3
a1967 1
f_setview(argc, argv)
d1973 3
d1977 3
a1979 2
    rt_log("f_setview: bad x value - %s\n", argv[1]);
    return CMD_BAD;
d1983 3
a1985 2
    rt_log("f_setview: bad y value - %s\n", argv[2]);
    return CMD_BAD;
d1989 3
a1991 2
    rt_log("f_setview: bad z value - %s\n", argv[3]);
    return CMD_BAD;
d1996 1
a1996 1
  return CMD_OK;
d2000 3
a2002 1
f_slewview(argc, argv)
d2010 3
d2014 3
a2016 2
    rt_log("f_slewview: bad x value - %s\n", argv[1]);
    return CMD_BAD;
d2020 3
a2022 2
    rt_log("f_slewview: bad y value - %s\n", argv[2]);
    return CMD_BAD;
d2030 1
a2030 1
  return CMD_OK;
d2137 3
a2139 1
f_winset( argc, argv )
d2145 3
d2150 2
a2151 2
    rt_log( "%s\n", rt_vls_addr(&pathName) );
    return CMD_OK;
d2158 1
a2158 1
      return CMD_OK;
d2162 3
a2164 2
  rt_log( "Unrecognized pathname - %s\n", argv[1] );
  return CMD_BAD;
d2200 3
a2202 1
f_tran(argc, argv)
d2214 4
a2218 2
  rt_vls_init(&str);
  
d2248 1
a2248 2
    rt_vls_free(&str);
    return CMD_OK;
d2252 1
d2254 1
a2254 1
  cmdline(&str, False);
d2258 4
a2261 1
  return CMD_OK;
d2265 3
a2267 1
f_irot(argc, argv)
d2278 4
d2306 1
a2306 1
  cmdline(&str, False);
d2321 4
a2324 1
  return CMD_OK;
@


11.71
log
@added code to help handle multiple command windows.
also added cmd_mged_glob
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.70 1996/03/25 21:50:49 bparker Exp bparker $ (BRL)";
a59 1
int cmd_sig2();
d63 1
a956 2
    (void)Tcl_CreateCommand(interp, "sigint", cmd_sig2, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);
d963 2
d993 1
d1013 1
a1013 1

d1018 1
d1047 1
d1053 1
a1053 1
cmd_sig2(clientData, interp, argc, argv)
d1059 9
a1067 1
  sig2();
@


11.70
log
@change parameters of attach and mater
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.69 1996/03/22 18:31:55 bparker Exp bparker $ (BRL)";
d60 4
d80 2
d956 11
d990 93
@


11.69
log
@cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.68 1996/03/11 21:47:35 bparker Exp bparker $ (BRL)";
d93 1
a93 1
int output_as_return = 0;
d184 1
a184 1
	f_attach,1,2,FALSE,
d338 1
a338 1
	f_mater,2,3,FALSE,
@


11.68
log
@added the tie command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.67 1996/03/01 19:20:05 bparker Exp bparker $ (BRL)";
a59 1
#ifdef VIRTUAL_TRACKBALL
a63 1
#endif
a296 1
#ifdef VIRTUAL_TRACKBALL
a298 1
#endif
a300 1
#ifdef VIRTUAL_TRACKBALL
a302 1
#endif
a482 1
#ifdef MULTI_ATTACH
a484 1
#endif
a492 1
#ifdef VIRTUAL_TRACKBALL
a494 1
#endif
a516 1
#ifdef MULTI_ATTACH
a518 1
#endif
a765 1
#ifdef MULTI_ATTACH
a816 37
#else
    register int i;

    static struct {
	char *knobname;
	double *variable;
    } knobs[] = {
	"ax", &absolute_rotate[X],
	"ay", &absolute_rotate[Y],
	"az", &absolute_rotate[Z],
	"aX", &absolute_slew[X],
	"aY", &absolute_slew[Y],
	"aZ", &absolute_slew[Z],
	"aS", &absolute_zoom,
	"x", &rate_rotate[X],
	"y", &rate_rotate[Y],
	"z", &rate_rotate[Z],
	"X", &rate_slew[X],
	"Y", &rate_slew[Y],
	"Z", &rate_slew[Z],
	"S", &rate_zoom
    };
	
    if( argc < 2 ) {
	Tcl_SetResult(interp, "getknob: need a knob name", TCL_STATIC);
	return TCL_ERROR;
    }

    for (i = 0; i < sizeof(knobs); i++)
	if (strcmp(knobs[i].knobname, argv[1]) == 0) {
	    sprintf(interp->result, "%lf", *(knobs[i].variable));
	    return TCL_OK;
	}
    
    Tcl_SetResult(interp, "getknob: invalid knob name", TCL_STATIC);
    return TCL_ERROR;
#endif
a1819 1
#ifdef MULTI_ATTACH
a1820 1
#endif
a1914 1
#ifdef MULTI_ATTACH
a1938 1
#endif
a1939 1
#ifdef VIRTUAL_TRACKBALL
a2082 1
#endif
@


11.67
log
@remove unused XMGED stuff
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.66 1996/02/22 16:26:51 jra Exp bparker $ (BRL)";
d425 2
a426 2
"release", "", "release current display processor [attach NU]",
	f_release,1,1,FALSE,
d489 4
d802 14
a815 14
    knobs[0].variable = &curr_dm_list->_absolute_rotate[X];
    knobs[1].variable = &curr_dm_list->_absolute_rotate[Y];
    knobs[2].variable = &curr_dm_list->_absolute_rotate[Z];
    knobs[3].variable = &curr_dm_list->_absolute_slew[X];
    knobs[4].variable = &curr_dm_list->_absolute_slew[Y];
    knobs[5].variable = &curr_dm_list->_absolute_slew[Z];
    knobs[6].variable = &curr_dm_list->_absolute_zoom;
    knobs[7].variable = &curr_dm_list->_rate_rotate[X];
    knobs[8].variable = &curr_dm_list->_rate_rotate[Y];
    knobs[9].variable = &curr_dm_list->_rate_rotate[Z];
    knobs[10].variable = &curr_dm_list->_rate_slew[X];
    knobs[11].variable = &curr_dm_list->_rate_slew[Y];
    knobs[12].variable = &curr_dm_list->_rate_slew[Z];
    knobs[13].variable = &curr_dm_list->_rate_zoom;
@


11.66
log
@Added make_bb command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.65 1996/02/22 15:38:55 bparker Exp jra $ (BRL)";
a59 48
#ifdef XMGED

#define DEFSHELL "/bin/sh"
#define TIME_STR_SIZE 32
#define NFUNC   ( (sizeof(funtab)) / (sizeof(struct funtab)) )

extern void (*dotitles_hook)();
extern FILE     *ps_fp;
extern struct dm dm_PS;
extern char     ps_ttybuf[];
extern int      in_middle;
extern FILE	*journal_file;
extern int	journal;	/* initialize to off */

typedef struct _cmd{
	struct _cmd	*prev;
	struct _cmd	*next;
	char	*cmd;
	char	time[TIME_STR_SIZE];
	int	num;
}Cmd, *CmdList;

typedef struct _alias{
	struct _alias	*left;
	struct _alias	*right;
	char	*name;	/* name of the alias */
	char	*def;	/* definition of the alias */
	int	marked;
}Alias, *AliasList;

CmdList	hhead=NULL, htail=NULL, hcurr=NULL;	/* for history list */
AliasList atop = NULL;
AliasList alias_free = NULL;

int 	savedit = 0;
int     mged_wait();
int chg_state();

int	f_history(), f_alias(), f_unalias();
int	f_journal(), f_button(), f_savedit(), f_slider();
int	f_slewview(), f_openw(), f_closew();
int	(*button_hook)(), (*slider_hook)();
int	(*openw_hook)(), (*closew_hook)();

int     f_perspective(), f_cue(), f_light(), f_zbuffer(), f_zclip();
int     f_ps();
#endif /* XMGED */

a60 2
int (*tran_hook)(), (*rot_hook)();
int (*set_tran_hook)();
a62 1
static void make_command();
a64 3

int rot_set = 0;
int tran_set = 0;
a66 3
extern int (*knob_hook)();
extern int (*cue_hook)(), (*zclip_hook)(), (*zbuffer_hook)();
extern int (*light_hook)(), (*perspective_hook)();
d191 1
a191 1
#ifdef XMGED
a200 4
#ifdef XMGED
"closew", "[host]", "close drawing window associated with host",
	f_closew, 1, 2, FALSE,
#endif
a366 4
#ifdef XMGED
"openw", "[host]", "open a drawing window on host",
	f_openw, 1, 2,FALSE,
#endif
d395 1
a395 1
#ifdef XMGED
d441 1
a441 1
#ifdef XMGED
d465 1
a465 1
#ifdef XMGED
a1369 3
#ifdef XMGED
	while ((rpid = mged_wait(&retcode, pid)) != pid && rpid != -1)
#else
a1370 1
#endif
d1607 1
a1607 1
#ifdef XMGED
a1862 17
#if 0
  /* If there is more than one active view, then tran_x/y/z
     needs to be initialized for each view. */
  if(set_tran_hook){
    point_t pos;

    VSETALL(pos, 0.0);
    (*set_tran_hook)(pos);
  }else{
    tran_x = tran_y = tran_z = 0;
  }

  if(rot_hook)
    (*rot_hook)();

  rot_x = rot_y = rot_z = 0;
#else
d1865 1
a1865 1
#endif
a1990 19
static void
make_command(line, diff)
char	*line;
point_t	diff;
{

  if(state == ST_O_EDIT)
    (void)sprintf(line, "translate %f %f %f\n",
		  (e_axis_pos[X] + diff[X]) * base2local,
		  (e_axis_pos[Y] + diff[Y]) * base2local,
		  (e_axis_pos[Z] + diff[Z]) * base2local);
  else
    (void)sprintf(line, "p %f %f %f\n",
		  (e_axis_pos[X] + diff[X]) * base2local,
		  (e_axis_pos[Y] + diff[Y]) * base2local,
		  (e_axis_pos[Z] + diff[Z]) * base2local);

}

a2059 1
#if 1
a2061 6
#else
  if(state == ST_O_EDIT)
    make_command(cmd, diff);
  else if(state == ST_S_EDIT)
    make_command(cmd, diff);
#endif
a2067 3
    if(tran_hook)
      (*tran_hook)();

a2077 5
  /* If there is more than one active view, then tran_x/y/z
     needs to be initialized for each view. */
  if(set_tran_hook)
    (*set_tran_hook)(diff);

a2129 3

    if(tran_hook)
      (*tran_hook)();
@


11.65
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.64 1996/02/16 16:52:53 jra Exp bparker $ (BRL)";
d125 1
d402 2
@


11.64
log
@Added "nmg_simplify" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.63 1996/02/16 16:43:30 bparker Exp jra $ (BRL)";
d2056 1
a2056 1
    rt_log( "%s\n", &pathName );
d2105 3
d2115 7
a2121 15
  if(set_tran_hook)
    (*set_tran_hook)(diff);
  else{
    point_t old_pos;
    point_t new_pos;
    point_t view_pos;

    MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
    VADD2(new_pos, old_pos, diff);
    MAT4X3PNT(view_pos, model2view, new_pos);

    tran_x = view_pos[X];
    tran_y = view_pos[Y];
    tran_z = view_pos[Z];
  }
d2157 5
d2164 1
a2164 1
    sprintf(cmd, "M %d %d %d\n", 1, (int)(tran_x*2048), (int)(tran_y*2048));
a2171 5
    VSET(view_pos, tran_x, tran_y, tran_z);
    MAT4X3PNT( new_pos, view2model, view_pos );
    MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
    VSUB2( diff, new_pos, old_pos );

@


11.63
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.62 1996/02/09 22:15:12 bparker Exp bparker $ (BRL)";
d124 1
d417 2
@


11.62
log
@adding virtual trackball stuff
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.61 1996/02/01 18:32:09 pjt Exp bparker $ (BRL)";
d1942 3
d2071 1
a2071 1
void
d2159 4
a2162 5
  VSET(view_pos, tran_x, tran_y, tran_z);
  MAT4X3PNT( new_pos, view2model, view_pos );
  MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
  VSUB2( diff, new_pos, old_pos );

d2167 1
d2169 5
a2218 4
  rot_x += x;
  rot_y += y;
  rot_z += z;

d2223 10
a2232 4
  else if(state == ST_O_EDIT)
    sprintf(cmd, "rotobj %f %f %f\n", rot_x, rot_y, rot_z);
  else if(state == ST_S_EDIT)
    sprintf(cmd, "p %f %f %f\n", rot_x, rot_y, rot_z);
@


11.61
log
@Implemented putmat command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.59 1996/01/17 22:13:56 bparker Exp bparker $ (BRL)";
a70 1
extern mat_t    ModelDelta;
a94 11
point_t	orig_pos;
int irot_set = 0;
double irot_x = 0;
double irot_y = 0;
double irot_z = 0;
int tran_set = 0;
double tran_x = 0;
double tran_y = 0;
double tran_z = 0;

void set_tran();
a97 1
static void    make_command();
a102 2
int (*tran_hook)(), (*rot_hook)();
int (*set_tran_hook)();
a104 1
int     f_tran(), f_irot();
d108 13
d358 1
a358 1
#ifdef XMGED
d364 1
a364 1
#ifdef XMGED
d556 1
a556 1
#ifdef XMGED
d1776 1
a1776 186
static void
make_command(line, diff)
char	*line;
point_t	diff;
{

  if(state == ST_O_EDIT)
    (void)sprintf(line, "translate %f %f %f\n",
		  (e_axis_pos[X] + diff[X]) * base2local,
		  (e_axis_pos[Y] + diff[Y]) * base2local,
		  (e_axis_pos[Z] + diff[Z]) * base2local);
  else
    (void)sprintf(line, "p %f %f %f\n",
		  (e_axis_pos[X] + diff[X]) * base2local,
		  (e_axis_pos[Y] + diff[Y]) * base2local,
		  (e_axis_pos[Z] + diff[Z]) * base2local);

}

/*
 *                         S E T _ T R A N
 *
 * Calculate the values for tran_x, tran_y, and tran_z.
 *
 *
 */
void
set_tran(x, y, z)
fastf_t x, y, z;
{
  point_t diff;

  diff[X] = x - e_axis_pos[X];
  diff[Y] = y - e_axis_pos[Y];
  diff[Z] = z - e_axis_pos[Z];
  
  /* If there is more than one active view, then tran_x/y/z
     needs to be initialized for each view. */
  if(set_tran_hook)
    (*set_tran_hook)(diff);
  else{
    point_t old_pos;
    point_t new_pos;
    point_t view_pos;

    MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
    VADD2(new_pos, old_pos, diff);
    MAT4X3PNT(view_pos, model2view, new_pos);

    tran_x = view_pos[X];
    tran_y = view_pos[Y];
    tran_z = view_pos[Z];
  }
}


int
f_tran(argc, argv)
int     argc;
char    *argv[];
{
  double x, y, z;
  int itran;
  char cmd[128];
  vect_t view_pos;
  point_t old_pos;
  point_t new_pos;
  point_t diff;
  struct rt_vls str;
  int save_journal = journal;

  rt_vls_init(&str);
  
  sscanf(argv[1], "%lf", &x);
  sscanf(argv[2], "%lf", &y);
  sscanf(argv[3], "%lf", &z);

  itran = !strcmp(argv[0], "itran");

  if(itran){
    tran_x += x;
    tran_y += y;
    tran_z += z;
  }else{
    tran_x = x;
    tran_y = y;
    tran_z = z;
  }

  VSET(view_pos, tran_x, tran_y, tran_z);
  MAT4X3PNT( new_pos, view2model, view_pos );
  MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
  VSUB2( diff, new_pos, old_pos );

  if(state == ST_O_EDIT)
    make_command(cmd, diff);
  else if(state == ST_S_EDIT)
    make_command(cmd, diff);
  else{
    VADD2(new_pos, orig_pos, diff);
    MAT_DELTAS_VEC( toViewcenter, new_pos);
    MAT_DELTAS_VEC( ModelDelta, new_pos);
    new_mats();

    if(tran_hook)
      (*tran_hook)();

    rt_vls_free(&str);
    save_journal = journal;
    return CMD_OK;
  }

  tran_set = 1;
  rt_vls_strcpy( &str, cmd );
  cmdline(&str, False);
  rt_vls_free(&str);
  tran_set = 0;
  save_journal = journal;

  /* If there is more than one active view, then tran_x/y/z
     needs to be initialized for each view. */
  if(set_tran_hook)
    (*set_tran_hook)(diff);

  return CMD_OK;
}

int
f_irot(argc, argv)
int argc;
char *argv[];
{
  int save_journal = journal;
  double x, y, z;
  char cmd[128];
  struct rt_vls str;
  vect_t view_pos;
  point_t new_pos;
  point_t old_pos;
  point_t diff;

  journal = 0;

  rt_vls_init(&str);

  sscanf(argv[1], "%lf", &x);
  sscanf(argv[2], "%lf", &y);
  sscanf(argv[3], "%lf", &z);

  irot_x += x;
  irot_y += y;
  irot_z += z;

  MAT_DELTAS_GET(old_pos, toViewcenter);

  if(state == ST_VIEW)
    sprintf(cmd, "vrot %f %f %f\n", x, y, z);
  else if(state == ST_O_EDIT)
    sprintf(cmd, "rotobj %f %f %f\n", irot_x, irot_y, irot_z);
  else if(state == ST_S_EDIT)
    sprintf(cmd, "p %f %f %f\n", irot_x, irot_y, irot_z);

  irot_set = 1;
  rt_vls_strcpy( &str, cmd );
  cmdline(&str, False);
  rt_vls_free(&str);
  irot_set = 0;

  if(state == ST_VIEW){
    MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
    VSUB2(diff, new_pos, orig_pos);
    VADD2(new_pos, old_pos, diff);
    VSET(view_pos, new_pos[X], new_pos[Y], new_pos[Z]);
    MAT4X3PNT( new_pos, model2view, view_pos);
    tran_x = new_pos[X];
    tran_y = new_pos[Y];
    tran_z = new_pos[Z];

    if(tran_hook)
      (*tran_hook)();
  }

  journal = save_journal;
  return CMD_OK;
}

d1941 1
a1941 1
  irot_x = irot_y = irot_z = 0;
d2064 181
@


11.60
log
@*** empty log message ***
@
text
@d463 2
@


11.59
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.58 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
d583 1
d586 1
d2226 1
d2251 1
@


11.58
log
@Just playing it safe
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.57 1995/12/07 16:33:15 jra Exp bparker $ (BRL)";
d2233 1
a2233 1
    rt_log( "%s", &pathName );
@


11.57
log
@Added showmats command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.56 1995/12/02 00:21:12 bparker Exp jra $ (BRL)";
a73 1
extern int update_views;
d123 1
d583 2
d832 53
d920 1
d2126 2
d2222 25
@


11.56
log
@add setview command. It might be useful. :-)
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.55 1995/11/29 21:21:31 mike Exp bparker $ (BRL)";
d509 2
@


11.55
log
@Improved usage message
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.53 1995/11/22 17:22:29 bparker Exp $ (BRL)";
d513 2
d1994 27
d2025 8
a2032 2
	int x, y;
	vect_t tabvec;
d2034 4
a2037 2
	sscanf(argv[1], "%d", &x);
	sscanf(argv[2], "%d", &y);
d2039 4
a2042 4
	tabvec[X] =  x / 2047.0;
	tabvec[Y] =  y / 2047.0;
	tabvec[Z] = 0;
	slewview( tabvec );
d2044 1
a2044 1
	return CMD_OK;
@


11.54
log
@Tk window titlebar should read "MGED", not "TkMGED".
@
text
@d308 1
a308 1
"ev",	"[-dnqsuvwT] [-P #] <objects>", "evaluate objects via NMG tessellation",
d320 1
a320 1
"facetize", "[-t] [-P#] new_obj old_obj(s)", "convert objects to faceted NMG objects at current tol",
@


11.53
log
@removed some stuff that I added that really belongs in
the display manager
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/mged/RCS/cmd.c,v 11.52 1995/11/09 22:25:49 bparker Exp bparker $ (BRL)";
d790 1
a790 1
	tkwin = Tk_CreateMainWindow(interp, (char *)NULL, "TkMGED", "tkMGED");
d792 1
a792 1
	tkwin = Tk_CreateMainWindow(interp, argv[1], "TkMGED", "tkMGED");
@


11.52
log
@removed unnecessary xmged stuff like journal,alias,history etc.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.51 1995/11/03 21:56:46 bparker Exp bparker $ (BRL)";
a1989 83

int
f_cue(argc, argv)
int     argc;
char    *argv[];
{
  if(cue_hook)
    return (*cue_hook)();


  rt_log( "cue: currently not available\n");
  return CMD_BAD;
}

int
f_zclip(argc, argv)
int     argc;
char    *argv[];
{
  if(zclip_hook)
    return (*zclip_hook)();

  rt_log( "zclip: currently not available\n");
  return CMD_BAD;
}

int
f_zbuffer(argc, argv)
int     argc;
char    *argv[];
{
  if(zbuffer_hook)
    return (*zbuffer_hook)();

  rt_log( "zbuffer: currently not available\n");
  return CMD_BAD;
}

int
f_light(argc, argv)
int     argc;
char    *argv[];
{
  if(light_hook)
    return (*light_hook)();

  rt_log( "light: currently not available\n");
  return CMD_BAD;
}

int
f_perspective(argc, argv)
int     argc;
char    *argv[];
{
  int i;
  static int perspective_angle = 0;
  static int perspective_mode = 0;
  static int perspective_table[] = { 30, 45, 60, 90 };

  if(argc == 2){
    perspective_mode = 1;
    sscanf(argv[1], "%d", &i);
    if(i < 0 || i > 3){
      if (--perspective_angle < 0) perspective_angle = 3;
    }else
      perspective_angle = i;

    rt_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[perspective_angle] );
  }else{
    perspective_mode = 1 - perspective_mode;
    rt_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_mode ? perspective_table[perspective_angle] : -1 );
  }

#if 0
  update_views = 1;
#endif
  return CMD_OK;
}
@


11.51
log
@minor fix to make command line editing work
while return value is CMD_MORE
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.50 1995/09/26 20:21:21 pjt Exp bparker $ (BRL)";
a71 5
extern short earb4[5][18];
extern short earb5[9][18];
extern short earb6[10][18];
extern short earb7[12][18];
extern short earb8[12][18];
a74 2
extern struct rt_db_internal es_int;
extern short int fixv;         /* used in ECMD_ARB_ROTATE_FACE,f_eqn(): fixed vertex */
a97 1
point_t e_axis_pos;
a106 1
void set_e_axis_pos();
a110 6
static void	addtohist();
static int	parse_history();
static void	print_alias(), load_alias_def();
static void	balance_alias_tree(), free_alias_node();
static AliasList	get_alias_node();
static int	extract_alias_def();
a116 3
int	(*knob_hook)();
int (*cue_hook)(), (*zclip_hook)(), (*zbuffer_hook)();
int (*light_hook)(), (*perspective_hook)();
a118 1
int (*bindkey_hook)();
d122 1
a122 2
int     f_aip(), f_ps();
int     f_bindkey();
d124 15
d153 1
a153 1
int output_as_return = 1;
d158 1
a158 1
Tcl_Interp *interp;
a230 1
#ifdef XMGED
a232 3
"alias", "[name definition]", "lists or creates an alias",
	f_alias, 1, MAXARGS, FALSE,
#endif
a249 2
"bindkey", "[key] [command]", "bind key to a command",
        f_bindkey, 1, MAXARGS, FALSE,
a273 4
#ifdef XMGED
"cue", "", "toggle cueing",
        f_cue, 1, 1, FALSE,
#endif
a340 4
#ifdef XMGED
"history", "[N]", "print out history of commands or last N commands",
	f_history,1, 2,FALSE,
#else
a348 1
#endif
a352 1
#ifdef XMGED
a354 1
#endif
a372 4
#ifdef XMGED
"journal", "[file]", "toggle journaling on or off",
	f_journal, 1, 2, FALSE,
#else
a374 1
#endif
a392 4
#ifdef XMGED
"light", "", "toggle lighting",
        f_light, 1, 1, FALSE,
#endif
a442 4
#ifdef XMGED
"perspective", "[n]", "toggle perspective",
        f_perspective, 1, 2,FALSE,
#endif
a534 1
#ifdef XMGED
a536 1
#endif
a560 4
#ifdef XMGED
"unalias","name/s", "deletes an alias or aliases",
	f_unalias, 2, MAXARGS,FALSE,
#endif
a584 6
#ifdef XMGED
"zbuffer", "", "toggle zbuffer",
        f_zbuffer, 1, 1,FALSE,
"zclip", "", "toggle zclipping",
        f_zclip, 1, 1,FALSE,
#endif
a639 173
#ifdef XMGED
int
f_journal(argc, argv)
int	argc;
char	*argv[];
{
	char	*path;

	journal = journal ? 0 : 1;

	if(journal){
		if(argc == 2)
			if( (journal_file = fopen(argv[1], "w")) != NULL )
				return CMD_OK;
			
		if( (path = getenv("MGED_JOURNAL")) != (char *)NULL )
			if( (journal_file = fopen(path, "w")) != NULL )
				return CMD_OK;

		if( (journal_file = fopen( "mged.journal", "w" )) != NULL )
			return CMD_OK;

		journal = 0;	/* could not open a file so turn off */
		rt_log( "Could not open a file for journalling.\n");

		return CMD_BAD;
	}

	fclose(journal_file);
	return CMD_OK;
}

int
f_history(argc, argv)
int	argc;
char	*argv[];
{
	register int	i;
	int	N = 0;
	CmdList	ptr;


	if(argc == 1){	/* print entire history list */
		ptr = hhead;
	}else{	/* argc == 2;  print last N commands */
		sscanf(argv[1], "%d", &N);
		ptr = htail->prev;
		for(i = 1; i < N && ptr != NULL; ++i, ptr = ptr->prev);

		if(ptr == NULL)
			ptr = hhead;
	}

	for(; ptr != htail; ptr = ptr->next)
		rt_log("%d\t%s\t%s\n", ptr->num, ptr->time,
				ptr->cmd);

	return CMD_OK;
}

/*   The node at the end of the list(pointed to by htail) always
   contains a null cmd string. And hhead points to the
   beginning(oldest) of the list. */
static void
addtohist(cmd)
char *cmd;
{
	static int count = 0;
	time_t	clock;

	if(hhead != htail){	/* more than one node */
		htail->prev->next = (CmdList)malloc(sizeof (Cmd));
		htail->prev->next->next = htail;
		htail->prev->next->prev = htail->prev;
		htail->prev = htail->prev->next;
		clock = time((time_t *) 0);
		strftime(htail->prev->time, TIME_STR_SIZE, "%I:%M%p", localtime(&clock));
		htail->prev->cmd =  malloc(strlen(cmd));   /* allocate space for cmd */
		(void)strncpy(htail->prev->cmd, cmd, strlen(cmd) - 1);
		htail->prev->cmd[strlen(cmd) - 1] = NULL;
		htail->prev->num = count;
		++count;
	}else if(!count){	/* no nodes */
		hhead = htail = hcurr = (CmdList)malloc(sizeof (Cmd));
		htail->prev = NULL;	/* initialize pointers */
		htail->next = NULL;
		clock = time((time_t *) 0);
		strftime(htail->time, TIME_STR_SIZE, "%I:%M%p", localtime(&clock));
		htail->cmd = malloc(1);	/* allocate space */
		htail->cmd[0] = NULL;	/* first node will have null command string */
		++count;
		addtohist(cmd);
	}else{		/* only one node */
		htail->prev = (CmdList)malloc(sizeof (Cmd));
		htail->prev->next = htail;
		htail->prev->prev = NULL;
		hhead = htail->prev;
		clock = time((time_t *) 0);
		strftime(hhead->time, TIME_STR_SIZE, "%I:%M%p", localtime(&clock));
		hhead->cmd =  malloc(strlen(cmd));   /* allocate space for cmd */
		(void)strncpy(hhead->cmd, cmd, strlen(cmd) - 1);
		hhead->cmd[strlen(cmd) - 1] = NULL;
		hhead->num = count;
		++count;
	}
}

static int
parse_history(cmd, str)
struct rt_vls	*cmd;
char	*str;
{
	register int	i;
	int	N;
	CmdList	ptr;

	if(*str == '@@'){	/* @@@@	last command */
		if(htail == NULL || htail->prev == NULL){
			rt_log( "No events in history list yet!\n");
			return(1);	/* no command in history list yet */
		}else{
			rt_vls_strcpy(cmd, htail->prev->cmd);
			rt_vls_strncat(cmd, "\n", 1);
			return(0);
		}
	}else if(*str >= '0' && *str <= '9'){	/* @@N	command N */
		sscanf(str, "%d", &N);
		for(i = 1, ptr = hhead; i < N && ptr != NULL; ++i, ptr = ptr->next);
	
		if(ptr != NULL){
			rt_vls_strcpy(cmd, ptr->cmd);
			rt_vls_strncat(cmd, "\n", 1);
			return(0);
		}else{
			rt_log("%d: Event not found\n", N);
			return(1);
		}
	}else if(*str == '-'){
		++str;
		if(*str >= '0' && *str <= '9'){
			sscanf(str, "%d", &N);
			for(i = 0, ptr = htail; i < N && ptr != NULL; ++i, ptr = ptr->prev);
			if(ptr != NULL){
	                        rt_vls_strcpy(cmd, ptr->cmd);
				rt_vls_strncat(cmd, "\n", 1);
	                        return(0);
			}else{
	                        rt_log("%s: Event not found\n", str);
	                        return(1);
			}
		}else{
			rt_log("%s: Event not found\n", str);
			return(1);
		}
	}else{	/* assuming a character string for now */
		for( ptr = htail; ptr != NULL; ptr = ptr->prev ){
			if( strncmp( str, ptr->cmd, strlen( str ) - 1 ) )
				continue;
			else	/* found a match */
				break;
		}
		if( ptr != NULL ){
                        rt_vls_strcpy( cmd, ptr->cmd );
			rt_vls_strncat( cmd, "\n", 1 );
                        return( 0 );
		}else{
                        rt_log("%s: Event not found\n", str );
                        return( 1 );
		}
	}
}
#endif

a1217 4
#ifdef XMGED
	addtohist(rt_vls_addr(vp));
	hcurr = htail;
#endif
a1247 4
#ifdef XMGED
	addtohist(rt_vls_addr(vp));
	hcurr = htail;
#endif
a1268 7
#ifdef XMGED
    AliasList	curr;
    struct rt_vls	cmd;
    int result;
    int	i, cmp;
    int 	save_journal;
#endif
a1272 27
#ifdef XMGED
    /* check for aliases first */
    for(curr = atop; curr != NULL;){
	if((cmp = strcmp(argv[0], curr->name)) == 0){
	    if(curr->marked)
      /* alias has same name as real command, so call real command */
		break;

      /* repackage alias commands with any arguments and call cmdline again */
	    save_journal = journal;
	    journal = 0;	/* temporarily shut off journalling */
	    rt_vls_init( &cmd );
	    curr->marked = 1;
	    if(!extract_alias_def(&cmd, curr, argc, argv))
		(void)cmdline(&cmd, False);
	    
	    rt_vls_free( &cmd );
	    curr->marked = 0;
	    journal = save_journal;	/* restore journal state */
	    return CMD_OK;
	}else if(cmp > 0)
	    curr = curr->right;
	else
	    curr = curr->left;
    }
#endif

a1287 2
#ifdef XMGED
	    result = ftp->ft_func(argc, argv);
a1288 9
/*  This needs to be done here in order to handle multiple commands within
    an alias.  */
	    if( sedraw > 0) {
		sedit();
		sedraw = 0;
		dmaflag = 1;
	    }
	    return result;
#else
a1300 1
#endif
a1585 88
#ifdef XMGED
/*
 *			S O U R C E _ F I L E
 *
 */
void
mged_source_file(fp, option)
register FILE	*fp;
char option;
{
	struct rt_vls	str, cmd;
	int		len;
	int             cflag = 0;
	int record;

	switch(option){
	case 'h':
	case 'H':
		rt_vls_init(&str);
		rt_vls_init(&cmd);

		while( (len = rt_vls_gets( &str, fp )) >= 0 )  {
		  if(str.vls_str[len - 1] == '\\'){ /* continuation */
			str.vls_str[len - 1] = ' ';
                        cflag = 1;
                  }

                  rt_vls_strcat(&cmd, str.vls_str);

                  if(!cflag){/* no continuation, so add to history list */
                    rt_vls_strcat( &str, "\n" );

                    if( cmd.vls_len > 0 ){
                       addtohist( rt_vls_addr(&cmd) );
                       rt_vls_trunc( &cmd, 0 );
		    }
		  }else
                    cflag = 0;

                  rt_vls_trunc( &str, 0 );
		}

		rt_vls_free(&str);
		rt_vls_free(&cmd);
		break;
	case 'e':
        case 'E':
        case 'b':
        case 'B':
		if(option == 'e' || option == 'E')
		  record = 0;
		else
		  record = 1;

		rt_vls_init(&str);
		rt_vls_init(&cmd);

		while( (len = rt_vls_gets( &str, fp )) >= 0 ){
		  if(str.vls_str[len - 1] == '\\'){ /* continuation */
			str.vls_str[len - 1] = ' ';
                        cflag = 1;
                  }

                  rt_vls_strcat(&cmd, str.vls_str);

                  if(!cflag){/* no continuation, so execute command */
                    rt_vls_strcat( &cmd, "\n" );

                    if( cmd.vls_len > 0 ){
                      cmdline( &cmd, record );
                      rt_vls_trunc( &cmd, 0 );
                    }
                  }else
		    cflag = 0;

                  rt_vls_trunc( &str, 0 );
		}

		rt_vls_free(&str);
		rt_vls_free(&cmd);
		break;
	default:
		rt_log( "Unknown option: %c\n", option);
		break;
	}
}
#endif

a1610 301
f_alias(argc, argv)
int	argc;
char	*argv[];
{
	int	i;
	int	namelen, deflen;
	int	cmp;
	AliasList curr, prev;

	if(argc == 1){
		print_alias(True, NULL, atop);
		return CMD_BAD;
	}

	if(argc == 2){
		print_alias(False, argv[1], atop);
		return CMD_BAD;
	}

	namelen = strlen(argv[1]) + 1;

	/* find length of alias definition */
	for(deflen = 0, i = 2; i < argc; ++i)
		deflen += strlen(argv[i]) + 1;

	if(atop != NULL){
		/* find a spot in the binary tree for the new node */
		for(curr = atop; curr != NULL;){
			if((cmp = strcmp(argv[1], curr->name)) == 0){
			/* redefine the alias */
				free((void *)curr->def);
				curr->def = (char *)malloc(deflen + 1);
				load_alias_def(curr->def, argc - 2, argv + 2);
				return CMD_OK;
			}else if(cmp > 0){
				prev = curr;
				curr = curr->right;
			}else{
				prev = curr;
				curr = curr->left;
			}
		}
		/* create the new node and initialize */
		if(cmp > 0){
			prev->right = get_alias_node();
			curr = prev->right;
		}else{
			prev->left = get_alias_node();
			curr = prev->left;
		}
	}else {	/* atop == NULL */
		atop = get_alias_node();
		curr = atop;
	}

	curr->name = (char *)malloc(namelen + 1);
	curr->def = (char *)malloc(deflen + 1);
	strcpy(curr->name, argv[1]);
	load_alias_def(curr->def, argc - 2, argv + 2);

	balance_alias_tree();

	return CMD_OK;
}

int
f_unalias(argc, argv)
int	argc;
char	*argv[];
{
	int	i;
	int	cmp, o_cmp;
	AliasList	prev, curr;
	AliasList	right;

	if(atop == NULL)
		return CMD_BAD;

	for(i = 1; i < argc; ++i){
		prev = curr = atop;
		while(curr != NULL){
			if((cmp = strcmp(argv[1], curr->name)) == 0){
				if(prev == curr){	/* tree top gets deleted */
					if(curr->left != NULL){
						atop = curr->left;
						right = curr->right;
						free_alias_node(curr);
						for(curr = atop; curr->right != NULL; curr = curr->right);
						curr->right = right;
					}else{
						atop = curr->right;
						free_alias_node(curr);
					}
				}else{
					if(curr->left != NULL){
						if(o_cmp > 0)
							prev->right = curr->left;
						else
							prev->left = curr->left;

						prev = curr->left;
						right = curr->right;
						free_alias_node(curr);
						for(; prev->right != NULL; prev = prev->right);
						prev->right = right;
					}else{
						if(o_cmp > 0)
							prev->right = curr->right;
						else
							prev->left = curr->right;

						free_alias_node(curr);
					}
				}
				break;
			}else if(cmp > 0){
				prev = curr;
				curr = curr->right;
			}else{
				prev = curr;
				curr = curr->left;
			}

			o_cmp = cmp;
		}/* while */
	}/* for */

	balance_alias_tree();
	return CMD_OK;
}


static void
print_alias(printall, alias, curr)
int	printall;
char	*alias;
AliasList	curr;
{
	int	cmp;

	if(curr == NULL)
		return;

	if(printall){
		print_alias(printall, alias, curr->left);
		rt_log( "%s\t%s\n", curr->name, curr->def);
		print_alias(printall, alias, curr->right);
	}else{	/* print only one */
		while(curr != NULL){
			if((cmp = strcmp(alias, curr->name)) == 0){
				rt_log( "%s\t%s\n", curr->name, curr->def);
				return;
			}else if(cmp > 0)
				curr = curr->right;
			else
				curr = curr->left;
		}
	}
}


static void
load_alias_def(def, num, params)
char	*def;
int	num;
char	*params[];
{
	int	i;

	strcpy(def, params[0]);

	for(i = 1; i < num; ++i){
		strcat(def, " ");
		strcat(def, params[i]);
	}
}


static AliasList
get_alias_node()
{
	AliasList	curr;

	if(alias_free == NULL)
		curr = (AliasList)malloc(sizeof(Alias));
	else{
		curr = alias_free;
		alias_free = alias_free->right;	/* using only right in this freelist */
	}

	curr->left = NULL;
	curr->right = NULL;
	curr->marked = 0;
	return(curr);
}


static void
free_alias_node(node)
AliasList	node;
{
	free((void *)node->name);
	free((void *)node->def);
	node->right = alias_free;
	alias_free = node;
}


static void
balance_alias_tree()
{
	int	i = 0;
}

/*
 *	Extract the alias definition and insert arguments that where called for.
 * If there are any left over arguments, tack them on the end.
 */
static int
extract_alias_def(cmd, curr, argc, argv)
struct rt_vls *cmd;
AliasList	curr;
int	argc;
char	*argv[];
{
	int	i = 0;
	int	j;
	int	start = 0;	/* used for range of arguments */
	int	end = 0;
	int	*arg_used;	/* used to keep track of which arguments have been used */
	char	*p;

p = curr->def;
arg_used = (int *)calloc(argc, sizeof(int));

while(p[i] != '\0'){
	/* copy a command name or other stuff embedded in the alias */
	for(j = i; p[j] != '$' && p[j] != ';'
		&& p[j] != '\0'; ++j);

	rt_vls_strncat( cmd, p + i, j - i);

	i = j;

	if(p[i] == '\0')
		break;
	else if(p[i] == ';'){
		rt_vls_strcat(cmd, "\n");
		++i;
	}else{		/* parse the variable argument string */
		++i;
		if(p[i] < '0' || p[i] > '9'){
			rt_log( "%s\n", curr->def);
			rt_log( "Range must be numeric.\n");
			return(1);	/* Bad */
		}

		sscanf(p + i, "%d", &start);
		if(start < 1 || start > argc){
			rt_log( "%s\n", curr->def);
			rt_log( "variable argument number is out of range.\n");
                        return(1);      /* Bad */
		}
		if(p[++i] == '-'){
			++i;
			if(p[i] < '0' || p[i] > '9')	/* put rest of args here */
				end = argc;
			else{
				sscanf(p + i, "%d", &end);
				++i;
			}

			if(end < start || end > argc){
				rt_log( "%s\n", curr->def);
				rt_log( "variable argument number is out of range.\n");
	                        return(1);      /* Bad */
			}
		}else
			end = start;

		for(; start <= end; ++start){
			arg_used[start] = 1;	/* mark used */
			rt_vls_strcat(cmd, argv[start]);
			rt_vls_strcat(cmd, " ");
		}
	}
}/* while */

/* tack unused arguments on the end */
for(j = 1; j < argc; ++j){
	if(!arg_used[j]){
		rt_vls_strcat(cmd, " ");
		rt_vls_strcat(cmd, argv[j]);
	}
}

rt_vls_strcat(cmd, "\n");
return(0);
}

int
a1687 19
f_slewview(argc, argv)
int	argc;
char	*argv[];
{
	int x, y;
	vect_t tabvec;

	sscanf(argv[1], "%d", &x);
	sscanf(argv[2], "%d", &y);

	tabvec[X] =  x / 2047.0;
	tabvec[Y] =  y / 2047.0;
	tabvec[Z] = 0;
	slewview( tabvec );

	return CMD_OK;
}

int
a1714 81
int
f_cue(argc, argv)
int     argc;
char    *argv[];
{
  if(cue_hook)
    return (*cue_hook)();


  rt_log( "cue: currently not available\n");
  return CMD_BAD;
}

int
f_zclip(argc, argv)
int     argc;
char    *argv[];
{
  if(zclip_hook)
    return (*zclip_hook)();

  rt_log( "zclip: currently not available\n");
  return CMD_BAD;
}

int
f_zbuffer(argc, argv)
int     argc;
char    *argv[];
{
  if(zbuffer_hook)
    return (*zbuffer_hook)();

  rt_log( "zbuffer: currently not available\n");
  return CMD_BAD;
}

int
f_light(argc, argv)
int     argc;
char    *argv[];
{
  if(light_hook)
    return (*light_hook)();

  rt_log( "light: currently not available\n");
  return CMD_BAD;
}

int
f_perspective(argc, argv)
int     argc;
char    *argv[];
{
  int i;
  static int perspective_angle = 0;
  static int perspective_mode = 0;
  static int perspective_table[] = { 30, 45, 60, 90 };

  if(argc == 2){
    perspective_mode = 1;
    sscanf(argv[1], "%d", &i);
    if(i < 0 || i > 3){
      if (--perspective_angle < 0) perspective_angle = 3;
    }else
      perspective_angle = i;

    rt_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[perspective_angle] );
  }else{
    perspective_mode = 1 - perspective_mode;
    rt_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_mode ? perspective_table[perspective_angle] : -1 );
  }

  update_views = 1;
  return CMD_OK;
}

a1769 114
void
set_e_axis_pos()
{
  int	i;

  /* If there is more than one active view, then tran_x/y/z
     needs to be initialized for each view. */
  if(set_tran_hook){
    point_t pos;

    VSETALL(pos, 0.0);
    (*set_tran_hook)(pos);
  }else{
    tran_x = tran_y = tran_z = 0;
  }

  if(rot_hook)
    (*rot_hook)();

  irot_x = irot_y = irot_z = 0;
  update_views = 1;

  switch(es_int.idb_type){
  case	ID_ARB8:
  case	ID_ARBN:
    if(state == ST_O_EDIT)
      i = 0;
    else
      switch(es_edflag){
      case	STRANS:
	i = 0;
	break;
      case	EARB:
	switch(es_type){
	case	ARB5:
	  i = earb5[es_menu][0];
	  break;
	case	ARB6:
	  i = earb6[es_menu][0];
	  break;
	case	ARB7:
	  i = earb7[es_menu][0];
	  break;
	case	ARB8:
	  i = earb8[es_menu][0];
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case	PTARB:
	switch(es_type){
	case    ARB4:
	  i = es_menu;	/* index for point 1,2,3 or 4 */
	  break;
	case    ARB5:
	case	ARB7:
	  i = 4;	/* index for point 5 */
	  break;
	case    ARB6:
	  i = es_menu;	/* index for point 5 or 6 */
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case ECMD_ARB_MOVE_FACE:
	switch(es_type){
	case	ARB4:
	  i = arb_faces[0][es_menu * 4];
	  break;
	case	ARB5:
	  i = arb_faces[1][es_menu * 4];  		
	  break;
	case	ARB6:
	  i = arb_faces[2][es_menu * 4];  		
	  break;
	case	ARB7:
	  i = arb_faces[3][es_menu * 4];  		
	  break;
	case	ARB8:
	  i = arb_faces[4][es_menu * 4];  		
	  break;
	default:
	  i = 0;
	  break;
	}
	break;
      case ECMD_ARB_ROTATE_FACE:
	i = fixv;
	break;
      default:
	i = 0;
	break;
      }

    VMOVE(e_axis_pos, ((struct rt_arb_internal *)es_int.idb_ptr)->pt[i]);
    break;
  case ID_TGC:
  case ID_REC:
    if(es_edflag == ECMD_TGC_MV_H ||
       es_edflag == ECMD_TGC_MV_HH){
      struct rt_tgc_internal  *tgc = (struct rt_tgc_internal *)es_int.idb_ptr;

      VADD2(e_axis_pos, tgc->h, tgc->v);
      break;
    }
  default:
    VMOVE(e_axis_pos, es_keypoint);
    break;
  }
}
d1989 38
d2029 3
a2031 3
f_bindkey(argc, argv)
int argc;
char *argv[];
d2033 2
a2034 2
  if(bindkey_hook)
    return (*bindkey_hook)(argc, argv);
d2036 1
a2036 1
  rt_log( "bindkey: currently not available\n");
d2039 76
d2117 92
@


11.50
log
@Implemented comb_color command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.48 1995/09/22 02:00:24 mike Exp jra $ (BRL)";
d158 1
a158 1
int output_as_return = 0;
d1451 1
d1454 6
@


11.49
log
@John's changes
@
text
@d450 2
@


11.48
log
@Lee changed dir_print() over to TCL semantidcs
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/cmd.c,v 11.47 1995/09/09 03:06:32 mike Exp mike $ (BRL)";
d1481 1
a1481 1
mged_cmd(argc, argv, functions)
d1484 1
a1484 1
struct funtab functions[];
d1487 1
d1525 6
@


11.47
log
@Added arg count checking.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.46 1995/09/09 02:34:00 mike Exp mike $ (BRL)";
d429 1
a429 1
	dir_print,1,MAXARGS, FALSE,
d575 1
a575 1
	dir_print,1,MAXARGS,FALSE,
@


11.46
log
@Converted "?" command to TCL.
Added DISPLAY argument to "loadtk" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.45 1995/09/09 02:02:05 butler Exp mike $ (BRL)";
d180 4
d202 4
d1586 5
@


11.45
log
@Changed f_list to cmd_list with TCL interface.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/cmd.c,v 11.44 1995/08/30 19:10:34 cnuzman Exp butler $ (BRL)";
d152 2
d218 1
a218 1
        f_fhelp,0,MAXARGS,FALSE,
d418 2
a419 2
"loadtk", "", "Initializes Tk",
        cmd_tk, 1, 1, TRUE,
d981 2
a983 1

d994 4
a997 2
    if (tkwin != NULL)
	return TCL_OK;
d999 5
a1003 1
    tkwin = Tk_CreateMainWindow(interp, (char *)NULL, "TkMGED", "tkMGED");
d1008 1
a1008 1
	Tk_GeometryRequest(tkwin, 200, 200);
a1734 1
 *  Or, help with the indicated commands.
a1735 2
int f_fhelp2();

d1737 3
a1739 1
f_fhelp( argc, argv )
d1743 14
a1756 1
	return f_fhelp2(argc, argv, &funtab[0]);
d1766 1
d1769 1
d1773 1
a1773 1
			col_item(ftp->ft_name);
d1775 3
a1777 1
		col_eol();
@


11.44
log
@added cmd_read_scale
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.43 1995/08/29 21:23:26 cnuzman Exp cnuzman $ (BRL)";
d405 1
a405 1
	f_list,2,MAXARGS, FALSE,
@


11.43
log
@added cmd_read_center
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.42 1995/08/28 16:31:04 cnuzman Exp cnuzman $ (BRL)";
d149 1
d597 2
@


11.42
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.41 1995/08/25 23:31:15 cnuzman Exp cnuzman $ (BRL)";
d148 1
d594 2
@


11.41
log
@began experimental vdraw
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.40 1995/08/25 20:25:05 mike Exp cnuzman $ (BRL)";
a146 2
extern int f_drawline();
#else
a294 7
#if 1
"drawline", "x y z (color) (kill)", "Experimental - draw a line (cnuzman)",
	f_drawline, 4, 6, FALSE,
#else
"vdraw", "write|insert|delete|read|length|show [args]", "Expermental drawing (cnuzman)",
	cmd_vdraw, 2, 7, TRUE,
#endif
d590 4
@


11.40
log
@Moved TCL access to LIBRT math functions into math.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.39 1995/08/25 20:17:08 cnuzman Exp mike $ (BRL)";
d145 2
d148 3
d297 1
d300 4
@


11.39
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.38 1995/08/24 23:12:42 cnuzman Exp cnuzman $ (BRL)";
d1112 2
a1113 82

/* Support routines for the math functions */

static int
decode_mat(m, str)
mat_t m;
char *str;
{
    return sscanf(str,
	     "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
		 &m[0], &m[1], &m[2], &m[3], &m[4], &m[5], &m[6], &m[7],
		 &m[8], &m[9], &m[10], &m[11], &m[12], &m[13], &m[14], &m[15]);
}

static int
decode_quat(q, str)
quat_t q;
char *str;
{
    return sscanf(str, "%lf %lf %lf %lf", &q[0], &q[1], &q[2], &q[3]);
}

static int
decode_vect(v, str)
vect_t v;
char *str;
{
    return sscanf(str, "%lf %lf %lf", &v[0], &v[1], &v[2]);
}

static void
encode_mat(vp, m)
struct rt_vls *vp;
mat_t m;
{
    rt_vls_printf(vp, "%g %g %g %g  %g %g %g %g  %g %g %g %g  %g %g %g %g",
		  m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
		  m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
}

static void
encode_quat(vp, q)
struct rt_vls *vp;
quat_t q;
{
    rt_vls_printf(vp, "%g %g %g %g", V4ARGS(q));
}

static void
encode_vect(vp, v)
struct rt_vls *vp;
vect_t v;
{
    rt_vls_printf(vp, "%g %g %g", V3ARGS(v));
}

static void
quat_distance_wrapper(dp, q1, q2)
double *dp;
quat_t q1, q2;
{
    *dp = quat_distance(q1, q2);
}

static void
mat_scale_about_pt_wrapper(statusp, mat, pt, scale)
int *statusp;
mat_t mat;
CONST point_t pt;
CONST double scale;
{
    *statusp = mat_scale_about_pt(mat, pt, scale);
}



/*                      C M D _ M A T H
 *
 * Tcl wrappers for the math functions.
 *
 * This is where you should put clauses, in the below "if" statement, to add
 * Tcl support for the librt math routines.
a1114 1

a1115 325
cmd_math(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    void (*math_func)();
    struct rt_vls result;

    math_func = (void (*)())clientData;
    rt_vls_init(&result);

    if (math_func == mat_mul) {
	mat_t o, a, b;
	if (argc < 3 || decode_mat(a, argv[1]) < 16 ||
	    decode_mat(b, argv[2]) < 16) {
	    rt_vls_printf(&result, "usage: %s matA matB", argv[0]);
	    goto error;
	}
	(*math_func)(o, a, b);
	encode_mat(&result, o);
    } else if (math_func == mat_inv || math_func == mat_trn) {
	mat_t o, a;

	if (argc < 2 || decode_mat(a, argv[1]) < 16) {
	    rt_vls_printf(&result, "usage: %s mat", argv[0]);
	    goto error;
	}
	(*math_func)(o, a);
	encode_mat(&result, o);
    } else if (math_func == mat_ae) {
	mat_t o;
	double az, el;

	if (argc < 3) {
	    rt_vls_printf(&result, "usage: %s azimuth elevation", argv[0]);
	    goto error;
	}
	if (Tcl_GetDouble(interp, argv[1], &az) != TCL_OK) goto error;
	if (Tcl_GetDouble(interp, argv[2], &el) != TCL_OK) goto error;

	(*math_func)(o, (fastf_t)az, (fastf_t)el);
	encode_mat(&result, o);
    } else if (math_func == mat_ae_vec) {
	fastf_t az, el;
	vect_t v;

	if (argc < 2 || decode_vect(v, argv[1]) < 3) {
	    rt_vls_printf(&result, "usage: %s vect", argv[0]);
	    goto error;
	}

	(*math_func)(&az, &el, v);
	rt_vls_printf(&result, "%g %g", az, el);
    } else if (math_func == mat_aet_vec) {
	fastf_t az, el, twist, accuracy;
	vect_t vec_ae, vec_twist;

	if (argc < 4 || decode_vect(vec_ae, argv[1]) < 3 ||
	    decode_vect(vec_twist, argv[2]) < 3) {
	    rt_vls_printf(&result, "usage: %s vec_ae vec_twist accuracy",
			  argv[0]);
	    goto error;
	}

	(*math_func)(&az, &el, &twist, vec_ae, vec_twist, accuracy);
	rt_vls_printf(&result, "%g %g %g", az, el, twist);
    } else if (math_func == mat_angles) {
	mat_t o;
	double alpha, beta, ggamma;

	if (argc < 4) {
	    rt_vls_printf(&result, "usage: %s alpha beta gamma", argv[0]);
	    goto error;
	}
	if (Tcl_GetDouble(interp, argv[1], &alpha) != TCL_OK)  goto error;
	if (Tcl_GetDouble(interp, argv[2], &beta) != TCL_OK)   goto error;
	if (Tcl_GetDouble(interp, argv[3], &ggamma) != TCL_OK) goto error;

	(*math_func)(o, alpha, beta, ggamma);
	encode_mat(&result, o);
    } else if (math_func == mat_eigen2x2) {
	fastf_t val1, val2;
	vect_t vec1, vec2;
	double a, b, c;

	if (argc < 4) {
	    rt_vls_printf(&result, "usage: %s a b c", argv[0]);
	    goto error;
	}
	if (Tcl_GetDouble(interp, argv[1], &a) != TCL_OK) goto error;
	if (Tcl_GetDouble(interp, argv[2], &c) != TCL_OK) goto error;
	if (Tcl_GetDouble(interp, argv[3], &b) != TCL_OK) goto error;

	(*math_func)(&val1, &val2, vec1, vec2, (fastf_t)a, (fastf_t)b,
		     (fastf_t)c);
	rt_vls_printf(&result, "%g %g {%g %g %g} {%g %g %g}", val1, val2,
		      V3ARGS(vec1), V3ARGS(vec2));
    } else if (math_func == mat_fromto) {
	mat_t o;
	vect_t from, to;

	if (argc < 3 || decode_vect(from, argv[1]) < 3 ||
	    decode_vect(to, argv[2]) < 3) {
	    rt_vls_printf(&result, "usage: %s vecFrom vecTo", argv[0]);
	    goto error;
	}
	(*math_func)(o, from, to);
	encode_mat(&result, o);
    } else if (math_func == mat_xrot || math_func == mat_yrot ||
	       math_func == mat_zrot) {
	mat_t o;
	double s, c;
	if (argc < 3) {
	    rt_vls_printf(&result, "usage: %s sinAngle cosAngle", argv[0]);
	    goto error;
	}
	if (Tcl_GetDouble(interp, argv[1], &s) != TCL_OK) goto error;
	if (Tcl_GetDouble(interp, argv[2], &c) != TCL_OK) goto error;

	(*math_func)(o, s, c);
	encode_mat(&result, o);
    } else if (math_func == mat_lookat) {
	mat_t o;
	vect_t dir;
	int yflip;
	if (argc < 3 || decode_vect(dir, argv[1]) < 3) {
	    rt_vls_printf(&result, "usage: %s dir yflip", argv[0]);
	    goto error;
	}
	if (Tcl_GetBoolean(interp, argv[2], &yflip) != TCL_OK) goto error;

	(*math_func)(o, dir, yflip);
	encode_mat(&result, o);
    } else if (math_func == mat_vec_ortho || math_func == mat_vec_perp) {
	vect_t ov, vec;

	if (argc < 2 || decode_vect(vec, argv[1]) < 3) {
	    rt_vls_printf(&result, "usage: %s vec", argv[0]);
	    goto error;
	}

	(*math_func)(ov, vec);
	encode_vect(&result, ov);
    } else if (math_func == mat_scale_about_pt_wrapper) {
	mat_t o;
	vect_t v;
	double scale;
	int status;

	if (argc < 3 || decode_vect(v, argv[1]) < 3) {
	    rt_vls_printf(&result, "usage: %s pt scale", argv[0]);
	    goto error;
	}
	if (Tcl_GetDouble(interp, argv[2], &scale) != TCL_OK) goto error;

	(*math_func)(&status, o, v, scale);
	if (status != 0) {
	    rt_vls_printf(&result, "error performing calculation");
	    goto error;
	}
	encode_mat(&result, o);
    } else if (math_func == mat_xform_about_pt) {
	mat_t o, xform;
	vect_t v;

	if (argc < 3 || decode_mat(xform, argv[1]) < 16 ||
	    decode_vect(v, argv[2]) < 3) {
	    rt_vls_printf(&result, "usage: %s xform pt", argv[0]);
	    goto error;
	}

	(*math_func)(o, xform, v);
	encode_mat(&result, o);
    } else if (math_func == mat_arb_rot) {
	mat_t o;
	point_t pt;
	vect_t dir;
	double angle;

	if (argc < 4 || decode_vect(pt, argv[1]) < 3 ||
	    decode_vect(dir, argv[2]) < 3) {
	    rt_vls_printf(&result, "usage: %s pt dir angle", argv[0]);
	    goto error;
	}
	if (Tcl_GetDouble(interp, argv[3], &angle) != TCL_OK)
	    return TCL_ERROR;

	(*math_func)(o, pt, dir, (fastf_t)angle);
	encode_mat(&result, o);
    } else if (math_func == quat_mat2quat) {
	mat_t mat;
	quat_t quat;

	if (argc < 2 || decode_mat(mat, argv[1]) < 16) {
	    rt_vls_printf(&result, "usage: %s mat", argv[0]);
	    goto error;
	}

	(*math_func)(quat, mat);
	encode_quat(&result, quat);
    } else if (math_func == quat_quat2mat) {
	mat_t mat;
	quat_t quat;

	if (argc < 2 || decode_quat(quat, argv[1]) < 4) {
	    rt_vls_printf(&result, "usage: %s quat", argv[0]);
	    goto error;
	}

	(*math_func)(mat, quat);
	encode_mat(&result, mat);
    } else if (math_func == quat_distance_wrapper) {
	quat_t q1, q2;
	double d;

	if (argc < 3 || decode_quat(q1, argv[1]) < 4 ||
	    decode_quat(q2, argv[2]) < 4) {
	    rt_vls_printf(&result, "usage: %s quatA quatB", argv[0]);
	    goto error;
	}

	(*math_func)(&d, q1, q2);
	rt_vls_printf(&result, "%g", d);
    } else if (math_func == quat_double || math_func == quat_bisect ||
	       math_func == quat_make_nearest) {
	quat_t oqot, q1, q2;

	if (argc < 3 || decode_quat(q1, argv[1]) < 4 ||
	    decode_quat(q2, argv[2]) < 4) {
	    rt_vls_printf(&result, "usage: %s quatA quatB", argv[0]);
	    goto error;
	}

	(*math_func)(oqot, q1, q2);
	encode_quat(&result, oqot);
    } else if (math_func == quat_slerp) {
	quat_t oq, q1, q2;
	double d;

	if (argc < 4 || decode_quat(q1, argv[1]) < 4 ||
	    decode_quat(q2, argv[2]) < 4) {
	    rt_vls_printf(&result, "usage: %s quat1 quat2 factor", argv[0]);
	    goto error;
	}
	if (Tcl_GetDouble(interp, argv[3], &d) != TCL_OK) goto error;

	(*math_func)(oq, q1, q2, d);
	encode_quat(&result, oq);
    } else if (math_func == quat_sberp) {
	quat_t oq, q1, qa, qb, q2;
	double d;

	if (argc < 6 || decode_quat(q1, argv[1]) < 4 ||
	    decode_quat(qa, argv[2]) < 4 || decode_quat(qb, argv[3]) < 4 ||
	    decode_quat(q2, argv[4]) < 4) {
	    rt_vls_printf(&result, "usage: %s quat1 quatA quatB quat2 factor",
			  argv[0]);
	    goto error;
	}
	if (Tcl_GetDouble(interp, argv[5], &d) != TCL_OK) goto error;

	(*math_func)(oq, q1, qa, qb, q2, d);
	encode_quat(&result, oq);
    } else if (math_func == quat_exp || math_func == quat_log) {
	quat_t qout, qin;

	if (argc < 2 || decode_quat(qin, argv[1]) < 4) {
	    rt_vls_printf(&result, "usage: %s quat", argv[0]);
	    goto error;
	}

	(*math_func)(qout, qin);
	encode_quat(&result, qout);
    } else {
	rt_vls_printf(&result, "math function %s not supported yet", argv[0]);
	goto error;
    }

    Tcl_SetResult(interp, rt_vls_addr(&result), TCL_VOLATILE);
    rt_vls_free(&result);
    return TCL_OK;

error:
    Tcl_AppendResult(interp, rt_vls_addr(&result), (char *)NULL);
    rt_vls_free(&result);
    return TCL_ERROR;
}

static struct math_func_link {
    char *name;
    void (*func)();
} math_funcs[] = {
    "mat_mul",            mat_mul,
    "mat_inv",            mat_inv,
    "mat_trn",            mat_trn,
    "mat_ae",             mat_ae,
    "mat_ae_vec",         mat_ae_vec,
    "mat_aet_vec",        mat_aet_vec,
    "mat_angles",         mat_angles,
    "mat_eigen2x2",       mat_eigen2x2,
    "mat_fromto",         mat_fromto,
    "mat_xrot",           mat_xrot,
    "mat_yrot",           mat_yrot,
    "mat_zrot",           mat_zrot,
    "mat_lookat",         mat_lookat,
    "mat_vec_ortho",      mat_vec_ortho,
    "mat_vec_perp",       mat_vec_perp,
    "mat_scale_about_pt", mat_scale_about_pt_wrapper,
    "mat_xform_about_pt", mat_xform_about_pt,
    "mat_arb_rot",        mat_arb_rot,
    "quat_mat2quat",      quat_mat2quat,
    "quat_quat2mat",      quat_quat2mat,
    "quat_distance",      quat_distance_wrapper,
    "quat_double",        quat_double,
    "quat_bisect",        quat_bisect,
    "quat_slerp",         quat_bisect,
    "quat_sberp",         quat_sberp,
    "quat_make_nearest",  quat_make_nearest,
    "quat_exp",           quat_exp,
    "quat_log",           quat_log,
    0, 0
};

int
a1136 1
    struct math_func_link *mp;
d1200 1
a1200 5
    for (mp = math_funcs; mp->name != NULL; mp++) {
	(void)Tcl_CreateCommand(interp, mp->name, cmd_math,
				(ClientData)mp->func,
				(Tcl_CmdDeleteProc *)NULL);
    }
@


11.38
log
@added experimental drawline command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.37 1995/08/24 06:29:29 mike Exp cnuzman $ (BRL)";
d292 2
a293 2
"drawline", "x y z color", "Experimental - draw a line (cnuzman)",
	f_drawline, 3, 4, FALSE,
@


11.37
log
@Added "L" and "R" commands for default mouse handling.
The advantage of doing things this way is that now users can
re-define the mice, for example:
proc L {up x y} {_mged_M $up $x $y}
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.36 1995/08/09 15:08:33 gdurf Exp mike $ (BRL)";
d145 2
d292 2
@


11.36
log
@Typo!
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.35 1995/08/07 14:35:31 gdurf Exp gdurf $ (BRL)";
d157 38
d399 2
d413 1
a413 1
"M", "1|0 xpos ypos", "handle a mouse event",
d489 2
@


11.35
log
@Removed old version of "source"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.34 1995/08/03 21:44:32 gdurf Exp gdurf $ (BRL)";
d1230 1
a1230 1
	(*math_func)(o, alpha, beta, gamma);
@


11.34
log
@Added apropos command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.33 1995/07/28 17:57:03 gdurf Exp gdurf $ (BRL)";
a504 4
#ifdef XMGED
"source", "[beh] filename", "reads in and records and/or executes a file of commands",
	f_source, 2, MAXARGS,FALSE,
#endif
@


11.33
log
@Added warning comment
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.32 1995/07/28 07:37:05 mike Exp gdurf $ (BRL)";
a39 1
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
d56 2
d151 1
a151 8
extern Tcl_CmdProc cmd_expand, cmd_db, cmd_prev, cmd_next, f_echo;
extern Tcl_CmdProc cmd_solids_on_ray;
extern Tcl_CmdProc cmd_pathlist;
extern Tcl_CmdProc cmd_oed;

int	mged_cmd();
int	cmd_gui(), cmd_tk(), cmd_getknob();

d189 2
d259 1
a259 1
	f_echo, 1, MAXARGS, TRUE,
a289 1
#ifndef XMGED
d292 3
a294 3
"gui", "output_hook", "Sends all output to the \"output_hook\" routine",
	cmd_gui, 1, 2, TRUE,
#endif
d307 1
a307 1
"prev", "", "Returns previous command",
d309 4
a368 1
#ifndef XMGED
a370 1
#endif
a486 1
#ifndef XMGED
a488 4
#else
"set",	"[var=opt]", "assign/display mged variables",
	f_set,1,2,FALSE,
#endif
d499 2
d900 1
a900 1
    struct rt_vls tclcommand;
a903 3
	/* Uh-oh... some bonehead probably typed "gui mged" and all output
	   is being redirected back into input... they deserve a core dump,
	   but we'll be slightly more polite... */
d905 1
a905 1
	/* Now safe to run rt_log */
a908 5
    rt_vls_init(&tclcommand);
    rt_vls_vlscat(&tclcommand, &tcl_output_hook);
    rt_vls_strcat(&tclcommand, " \"");
    rt_vls_strcat(&tclcommand, str);
    rt_vls_strcat(&tclcommand, "\"");
d910 4
d915 1
a915 1
    Tcl_Eval((Tcl_Interp *)clientData, rt_vls_addr(&tclcommand));
d918 1
a918 1
    rt_vls_free(&tclcommand);
d1012 1
a1012 1
 *   C M D _ G U I
d1014 2
a1015 3
 *   Hooks the output to the given output hook.  (Maybe it shouldn't be called
 *   "gui". Misleading name, although it is used to build up guis.)
 *   Deletes the existing GUI hook!
d1019 1
a1019 1
cmd_gui(clientData, interp, argc, argv)
d1029 2
a1030 1
	Tcl_SetResult(interp, "too many args: should be \"gui [hookName]\"",
d1748 1
a1748 1
       would happen.
d1825 1
a1825 1
struct funtab *functions;
d1866 1
a1866 1
    for (ftp = functions+1; ftp->ft_name; ftp++) {
d1901 1
a1901 1
	rt_log("Usage: %s%s %s\n\t(%s)\n",functions->ft_name,
d1906 1
a1906 1
	   functions->ft_name, argv[0], functions->ft_name);
d1910 32
d2253 3
a2255 2
 * F _ E C H O
 *      
d2259 1
a2259 1
f_echo(clientData, interp, argc, argv)
@


11.32
log
@Added "oed" command, to allow direct transition from View to ObjEdit.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.31 1995/07/27 21:48:02 mike Exp mike $ (BRL)";
d1751 11
@


11.31
log
@Added "pathlist" command to MGED.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.30 1995/07/27 21:14:22 gdurf Exp mike $ (BRL)";
d153 1
d396 2
@


11.30
log
@added nop
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.29 1995/07/25 17:53:04 gdurf Exp gdurf $ (BRL)";
d152 1
d411 2
@


11.29
log
@cmdline() no longer does CMD_MORE (handled in stdin_input() handler)
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.28 1995/07/19 16:02:02 pjt Exp gdurf $ (BRL)";
d1483 10
d1574 1
a1574 1
    
@


11.28
log
@Changed the help message for the sed command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.27 1995/07/18 22:52:58 jra Exp $ (BRL)";
d150 1
a150 1
extern Tcl_CmdProc cmd_expand, cmd_db, cmd_prev, cmd_next, f_echo, cmd_look;
a371 2
"look", "eyepoint vector", "Looks along the given ray and returns a list of hit solids",
        cmd_look, 3, 3, TRUE,
a587 2
    /* Temporarily shut off hooks in case the vls routines bomb! */

a1718 1
#ifdef XMGED
d1720 1
a1720 1
struct rt_vls	*vp;
a1721 4
#else
cmdline(vp)
struct rt_vls	*vp;
#endif
d1723 3
a1725 1
    int	done, status;
d1727 1
a1727 5
    struct rt_vls line, line_globbed, str;
    struct timeval start, finish;
    int	need_prompt = 0;
    char *argv[MAXARGS+2];
    register char *cp, *ep, *end;
d1731 1
a1731 2
    len = rt_vls_strlen(vp);
    if (len <= 0) return 0;
d1733 1
a1733 31
    cp = rt_vls_addr(vp);
    end = cp + len;

    rt_vls_init(&line);
    rt_vls_init(&line_globbed);
    rt_vls_init(&str);

    while (cp < end) {
	ep = strchr(cp, '\n');
	if (ep == NULL) break; /* Quit if there are no more complete commands*/
	/* Copy one cmd, including newline.  Null terminate */
	rt_vls_strncpy(&line, cp, ep-cp+1);

	/* If the command was not complete, pick up additional fragments
	   as required. */
	while (!Tcl_CommandComplete(rt_vls_addr(&line)) && ep+1 < end) {
	    cp = ep + 1;
	    ep = strchr(cp, '\n');
	    if (ep == NULL)
		break;
	    rt_vls_strncat(&line, cp, ep-cp+1);
	}

	while (1) {
	    done = 0;

	    rt_vls_trunc(&line_globbed, 0);
	    if (glob_compat_mode)
		mged_compat(&line_globbed, &line);
	    else
		rt_vls_vlscat(&line_globbed, &line);
d1735 8
a1742 3
	    gettimeofday(&start, (struct timezone *)NULL);
	    status = Tcl_Eval(interp, rt_vls_addr(&line_globbed));
	    gettimeofday(&finish, (struct timezone *)NULL);
d1746 3
a1748 3
	    switch (status) {
	    case TCL_OK:
		len = strlen(interp->result);
d1752 2
a1753 2
		if (len > 0) rt_log("%s%s", interp->result,
				    interp->result[len-1] == '\n' ? "" : "\n");
d1755 1
a1755 1
    /* Then record it for posterity, and notify that we're done. */
d1757 9
a1765 3
		history_record(&line, &start, &finish, CMD_OK);
		done = 1;
		break;
d1767 2
a1768 1
	    default:
d1772 6
a1777 11
		if (strstr(interp->result, MORE_ARGS_STR) == interp->result) {
		    struct rt_vls temp;

		    rt_vls_init(&temp);
		    rt_vls_strcat(&temp,
				  interp->result+sizeof(MORE_ARGS_STR)-1);
		    Tcl_SetResult(interp, rt_vls_addr(&temp), TCL_VOLATILE);
		    rt_vls_free(&temp);
		    done = 0;
		    break;
		}
d1781 3
a1783 8
		len = strlen(interp->result);
		if (len > 0) rt_log("%s%s", interp->result,
				    interp->result[len-1] == '\n' ? "" : "\n");

		history_record(&line, &start, &finish, CMD_BAD);
		done = 1;
		break;
	    }
d1785 2
d1788 2
a1789 5
	    if (done && record) {
		addtohist(rt_vls_addr(&hadd));
		/* reset hcurr to point to most recent command */
		hcurr = htail;
	    }
d1791 2
a1792 43
	    /* If we get here, it means the command failed due
	       to insufficient arguments.  In this case, grab some
	       more from stdin and call the command again. */

	    if (done)
		break;
	    
	    rt_vls_trunc(&str, 0);
	    rt_log("%s", interp->result);
	    rt_vls_gets(&str, stdin);  /* Feh. We should continue to respond
					  to events! */

	    /* Remove newline and append new string */
	    rt_vls_trunc(&line, rt_vls_strlen(&line)-1);
	    rt_vls_strcat(&line, " ");
	    rt_vls_vlscatzap(&line, &str);
	    rt_vls_strcat(&line, "\n");
	}

	need_prompt = 1;
	cp = ep+1;
    }

    rt_vls_free( &line );
    rt_vls_free( &line_globbed );
    rt_vls_free( &str );

    return need_prompt;
}

int
cmd_look(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    double viewX, viewY;

    if (argc < 3) {
	Tcl_AppendResult(interp, "wrong # args: should be ", argv[0],
			 " scrH scrV", (char *)NULL);
	return TCL_ERROR;
a1793 16

#if 0
    if (Tcl_GetDouble(interp, argv[1], &viewX) != TCL_OK) return TCL_ERROR;
    
    /* Do stuff. */

    Tcl_SetResult(interp, "foo", TCL_STATIC);

    Tcl_SetResult(interp, rt_vls_addr(&vls), TCL_VOLATILE);
    rt_vls_free(&vls);
    

    Tcl_AppendElement(interp, "This { is really \\ fu\"nk}y.");
#endif
    
    return TCL_OK;
a2199 23
}
#else
/*
 *			S O U R C E _ F I L E
 *
 */

void
mged_source_file(fp)
register FILE	*fp;
{
	struct rt_vls	str;
	int		len;

	rt_vls_init(&str);

	while( (len = rt_vls_gets( &str, fp )) >= 0 )  {
		rt_vls_strcat( &str, "\n" );
		if( len > 0 )  (void)cmdline( &str );
		rt_vls_trunc( &str, 0 );
	}

	rt_vls_free(&str);
@


11.27
log
@Added pipe to make command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.26 1995/07/07 20:18:30 pjt Exp jra $ (BRL)";
d484 1
a484 1
"sed", "solid", "solid-edit named solid",
@


11.26
log
@added solids_on_ray command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.25 1995/07/07 17:13:13 gdurf Exp pjt $ (BRL)";
d378 1
a378 1
"make", "name <arb8|sph|ellg|tor|tgc|rpc|rhc|epa|ehy|eto|part|grip|half|nmg>", "create a primitive",
@


11.25
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.24 1995/07/06 19:23:26 gdurf Exp gdurf $ (BRL)";
d151 1
d505 2
d1877 1
d1889 1
@


11.24
log
@Started cmd_look
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.23 1995/07/06 14:14:45 gdurf Exp gdurf $ (BRL)";
a1858 17
struct rt_vls look_result;

int
look_hit(ap, PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
    rt_vls_strcat(&look_result, "H");
}

int
look_miss(ap)
register struct application *ap;
{
    rt_vls_strcat(&look_result, "M");
}

d1866 1
a1866 5
    vect_t               temp;
    double               viewX, viewY;
    struct rt_i         *rtip;
    struct application   a;
    char                 title[2];
d1869 2
a1870 3
	Tcl_SetResult(interp, "wrong # args: should be \"look viewX viewY \
objList\"",
		      TCL_STATIC);
d1875 2
a1876 1
    if (Tcl_GetDouble(interp, argv[2], &viewY) != TCL_OK) return TCL_ERROR;
d1878 1
a1878 1
    bzero((void *)&a, sizeof(struct application));
d1880 2
a1881 11
    rtip = rt_dirbuild(dbip->dbi_filename, title, 0);
    while (argc > 4) {
	rt_gettree(rtip, argv[3]);
	--argc;
	++argv;
    }

    a.a_hit = look_hit;
    a.a_miss = look_miss;
    a.a_rt_i = rtip;
    a.a_level = 0;
a1882 5
    VSET(temp, viewX, viewY, 0);
    MAT4X3PNT(a.a_ray.r_pt, view2model, temp);
    VSET(temp, 0, 0, 1);
    MAT4X3PNT(a.a_ray.r_dir, view2model, temp);
    VUNITIZE(a.a_ray.r_dir);
d1884 1
a1884 3
    rt_vls_init(&look_result);
    
    rt_shootray_for_sols(&a);
a1885 2
    Tcl_SetResult(interp, rt_vls_addr(&look_result), TCL_VOLATILE);
    rt_vls_free(&look_result);
@


11.23
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.22 1995/07/06 14:12:37 gdurf Exp gdurf $ (BRL)";
d1859 10
d1870 7
d1883 17
a1899 3
    point_t pnt;
    vect_t v;
    struct rt_vls result;
d1901 5
a1905 4
    if (argc < 3 || decode_vect(pnt, argv[1]) < 3 ||
	decode_vect(v, argv[2]) < 3) {
	Tcl_SetResult(interp, "usage: look eyePoint vect", TCL_STATIC);
	return TCL_ERROR;
d1908 17
@


11.22
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.21 1995/07/06 13:56:33 gdurf Exp gdurf $ (BRL)";
d153 1
a153 1
int	cmd_gui(), cmd_tk(), cmd_getknob(), gui_cmdline();
a384 4
#ifndef XMGED
"mged", "cmd ?args...?", "Executes the given command and its arguments",
        gui_cmdline, 1, MAXARGS, TRUE,
#endif
@


11.21
log
@Changes too numerous to enumerate
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.20 1995/06/23 20:20:50 pjt Exp gdurf $ (BRL)";
d150 1
a150 1
extern Tcl_CmdProc cmd_expand, cmd_db, cmd_prev, cmd_next, f_echo;
@


11.20
log
@Added the 'c' command
@
text
@d22 1
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.18 1995/05/30 18:50:22 gdurf Exp gdurf $ (BRL)";
d40 4
d48 3
a54 2

#ifdef XMGED
a55 2
#include "rtgeom.h"
#endif
d57 1
a57 5
#ifndef XMGED
#  define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
#  include "tcl.h"
#  include "tk.h"
#endif
d59 1
a59 15
#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef False
#define False (0)
#endif

#ifndef True
#define True (1)
#endif
a60 1
#ifdef XMGED
d144 2
a145 1
extern void	sync();
d147 2
a148 1
int	inpara;			/* parameter input from keyboard */
d150 1
a150 2
extern int cmd_glob(), cmd_glob_args();
extern Tcl_CmdProc cmd_expand, cmd_db;
a151 1
int	f_matpick();
d153 1
a153 4
int	f_sync();
int	f_shells();
int	f_arced();
int	f_xpush();
d155 1
a155 6
#ifndef XMGED
int	f_gui();
int	f_tk();

int gui_mode = 0;
char text_widget_name[200];
a158 7
#endif

struct rt_vls history;
struct rt_vls replay_history;
struct timeval lastfinish;
FILE *journalfp;
int firstjournal;
d260 1
a260 1
	f_echo, 1, MAXARGS, FALSE,
d273 2
d292 4
a295 2
"gui",	"text_widget_name", "Bring up a Tcl/Tk Graphical User Interface",
	f_gui, 2, 2, FALSE,
d307 1
a307 1
"hist", "[-delays]", "describe command history",
d309 2
d369 1
a369 1
        f_tk, 1, 1, FALSE,
d371 2
d385 4
a576 1

d578 1
a578 1
 *	H I S T O R Y _ R E C O R D
d580 1
a580 2
 *	Stores the given command with start and finish times in the
 *	  history vls'es.
d583 13
a595 22
void
history_record( cmdp, start, finish )
struct rt_vls *cmdp;
struct timeval *start, *finish;
{
	static int done = 0;
	struct rt_vls timing;

	rt_vls_vlscat( &history, cmdp );

	rt_vls_init( &timing );
	if( done != 0 ) {
		if( lastfinish.tv_usec > start->tv_usec ) {
			rt_vls_printf( &timing, "delay %ld %08ld\n",
			    start->tv_sec - lastfinish.tv_sec - 1,
			    start->tv_usec - lastfinish.tv_usec + 1000000L );
		} else {
			rt_vls_printf( &timing, "delay %ld %08ld\n",
				start->tv_sec - lastfinish.tv_sec,
				start->tv_usec - lastfinish.tv_usec );
		}
	}		
d597 2
a598 3
	/* As long as this isn't our first command to record after setting
           up the journal (which would be "journal", which we don't want
	   recorded!)... */
d600 6
a605 4
	if( journalfp != NULL && !firstjournal ) {
		rt_vls_fwrite( journalfp, &timing );
		rt_vls_fwrite( journalfp, cmdp );
	}
d607 6
a612 2
	rt_vls_vlscat( &replay_history, &timing );
	rt_vls_vlscat( &replay_history, cmdp );
d614 5
a618 4
	lastfinish.tv_sec = finish->tv_sec;
	lastfinish.tv_usec = finish->tv_usec;
	done = 1;
	firstjournal = 0;
d620 6
a625 2
	rt_vls_free( &timing );
}		
a657 58
#else
/*
 *	F _ J O U R N A L
 *
 *	Opens the journal file, so each command and the time since the previous
 *	  one will be recorded.  Or, if called with no arguments, closes the
 *	  journal file.
 */

int
f_journal( argc, argv )
int argc;
char **argv;
{
	if( argc < 2 ) {
		if( journalfp != NULL )
			fclose( journalfp );
		journalfp = NULL;
		return CMD_OK;
	} else {
		if( journalfp != NULL ) {
			rt_log("First shut off journaling with \"journal\" (no args)\n");
			return CMD_BAD;
		} else {
			journalfp = fopen(argv[1], "a+");
			if( journalfp == NULL ) {
				rt_log( "Error opening %s for appending\n", argv[1] );
				return CMD_BAD;
			}
			firstjournal = 1;
		}
	}

	return CMD_OK;
}
#endif


/*
 *	F _ D E L A Y
 *
 * 	Uses select to delay for the specified amount of seconds and 
 *	  microseconds.
 */

int
f_delay( argc, argv )
int argc;
char **argv;
{
	struct timeval tv;

	tv.tv_sec = atoi( argv[1] );
	tv.tv_usec = atoi( argv[2] );
	select( 0, NULL, NULL, NULL, &tv );

	return CMD_OK;
}
a658 1
#ifdef XMGED
a797 57
#else
/*
 *	F _ H I S T O R Y
 *
 *	Prints out the command history, either to rt_log or to a file.
 */

int
f_history( argc, argv )
int argc;
char **argv;
{
	FILE *fp;
	struct rt_vls *which_history;

	fp = NULL;
	which_history = &history;

	while( argc >= 2 ) {
		if( strcmp(argv[1], "-delays") == 0 ) {
			if( which_history == &replay_history ) {
				rt_log( "history: -delays option given more than once\n" );
				return CMD_BAD;
			}
			which_history = &replay_history;
		} else if( strcmp(argv[1], "-outfile") == 0 ) {
			if( fp != NULL ) {
				rt_log( "history: -outfile option given more than once\n" );
				return CMD_BAD;
			} else if( argc < 3 || strcmp(argv[2], "-delays") == 0 ) {
				rt_log( "history: I need a file name\n" );
				return CMD_BAD;
			} else {
				fp = fopen( argv[2], "a+" );
				if( fp == NULL ) {
					rt_log( "history: error opening file" );
					return CMD_BAD;
				}
				--argc;
				++argv;
			}
		} else {
			rt_log( "Invalid option %s\n", argv[1] );
		}
		--argc;
		++argv;
	}

	if( fp == NULL ) {
		rt_log( "%s", rt_vls_addr(which_history) );
	} else {
		rt_vls_fwrite( fp, which_history );
		fclose( fp );
	}

	return CMD_OK;
}
a799 2
#ifndef XMGED

d810 1
a810 1
    Tcl_Interp *interp;		/* Interpreter for application. */
d812 1
a812 1
	return TCL_OK;
d818 2
d829 4
a832 3
    int new_argc;
    char **new_argv;
    int result;
d835 11
a845 2
#if 0
    cmd_glob_args(argc, argv, &new_argc, &new_argv);
d847 15
a861 4
    switch (mged_cmd(new_argc, new_argv, funtab)) {
#else
    switch (mged_cmd(argc, argv, funtab)) {
#endif
d863 3
a865 2
	interp->result = "MGED_Ok";
	result = TCL_OK;
d868 3
a870 2
	interp->result = "MGED_Error";
	result = TCL_ERROR;
d873 5
a877 2
	interp->result = "MGED_More";
	result = TCL_ERROR;
d880 5
a884 2
	interp->result = "MGED_Unknown";
	result = TCL_ERROR;
d887 3
a889 23
#if 0
    rt_free((char *)new_argv, "new_argv array for wildcard expansion");
#endif
    return result;
}

void
mged_tk_hook()
{
	while( Tk_DoOneEvent( TK_DONT_WAIT | TK_ALL_EVENTS ) )  /*NIL*/;
}

void
mged_tk_idle(non_blocking)
int	non_blocking;
{
	int	flags;

	flags = TK_DONT_WAIT | TK_ALL_EVENTS;

	while( Tk_DoOneEvent( flags ) )  {
		/* NIL */	;
	}
a891 2


d893 1
a893 1
 *	G U I _ O U T P U T
d895 3
a897 2
 *	Used as a hook for rt_log output.  Redirects output to the Tcl/Tk
 *		MGED Interaction window.
d901 2
a902 1
gui_output( str )
d905 17
a921 2
	char buf[10240];
	char *old;
d923 3
a925 6
	sprintf(buf, "%s insert insert \"%s\"", text_widget_name, str);
	Tcl_Eval(interp, buf);
	sprintf(buf, "%s yview -pickplace insert", text_widget_name);
	Tcl_Eval(interp, buf);
	sprintf(buf, "set printend [%s index insert]", text_widget_name);
	Tcl_Eval(interp, buf);
d927 2
a928 1
	return strlen(str);
a930 2


d932 1
a932 1
 *	G U I _ C M D L I N E
d934 1
a934 2
 *	Called from the Tcl/Tk section to process commands from
 *	the MGED Interaction window.
d938 1
a938 1
gui_cmdline( clientData, interp, argc, argv )
d944 1
a944 71
	static struct rt_vls argstr, hargstr;
	static int done = 0;
	struct timeval start, finish;
	int result;

	if( done == 0 ) {
		rt_vls_init( &argstr );
		rt_vls_init( &hargstr );
		done = 1;
		rt_vls_strcpy( &argstr, "" );
		rt_vls_strcpy( &hargstr, "" );
	}

	rt_vls_trunc( &hargstr, 0 );

	if( rt_vls_strlen(&argstr) > 0 ) {
		/* Remove newline */
		rt_vls_trunc( &argstr, rt_vls_strlen(&argstr)-1 );
		rt_vls_strcat( &argstr, " " );
	}

	rt_vls_strcat( &argstr, argv[1] );

	gettimeofday( &start, NULL );
	result = Tcl_Eval(interp, rt_vls_addr(&argstr));
	gettimeofday( &finish, NULL );
	
	switch( result ) {
	case TCL_OK:
		if( strcmp(interp->result, "MGED_Ok") != 0 )
			rt_log( interp->result );
			    /* If the command was more than just \n, record. */
		if( rt_vls_strlen(&argstr) > 1 )
			history_record( &argstr, &start, &finish );
		rt_vls_trunc( &argstr, 0 );
		pr_prompt();
		return TCL_OK;
	case TCL_ERROR:
		if( strcmp(interp->result, "MGED_Error") == 0 ) {
			rt_vls_printf(&hargstr, "# %s", rt_vls_addr(&argstr));
			history_record( &hargstr, &start, &finish );
			rt_vls_trunc( &argstr, 0 );
			pr_prompt();
			return TCL_OK;
		} else if( strcmp(interp->result, "MGED_More") == 0 ) {
			return TCL_OK;
		} else {
			char *tmp;
			tmp = (char *)malloc( strlen(interp->result)+1 );
			strcpy( tmp, interp->result );
			rt_log( "%s\n", tmp );
			rt_vls_printf(&hargstr, "# %s", rt_vls_addr(&argstr));
			history_record( &hargstr, &start, &finish );
			rt_vls_trunc( &argstr, 0 );
			pr_prompt();
			interp->result = tmp;
			interp->freeProc = (void (*)())free;
			return TCL_ERROR;
		}
	default:
		interp->result = "MGED: Unknown Error.";
		return TCL_ERROR;
	}
}

int
f_tk( argc, argv )
int argc;
char **argv;
{
    /* Screen name should be same as attachment, or should ask, or
d948 1
a948 1
	return CMD_OK;
d950 1
a950 1
    tkwin = Tk_CreateMainWindow(interp, NULL, "TkMGED", "tkMGED");
d952 1
a952 1
	rt_log("Error creating Tk window: %s\n", interp->result);
d955 1
a955 6
	/* XXX HACK! */
	extern void (*extrapoll_hook)();	/* ged.c */
	extern int  extrapoll_fd;		/* ged.c */

	extrapoll_hook = mged_tk_hook;
	extrapoll_fd = Tk_Display(tkwin)->fd;
a956 5
	Tk_GeometryRequest(tkwin, 200, 200);
#if 0
	Tk_MakeWindowExist(tkwin);
	Tk_MapWindow(tkwin);
#endif
d958 2
a959 2
	if( Tk_Init(interp) == TCL_ERROR )
	    rt_log("Tk_init error %s\n", interp->result);
d963 1
a963 1
    while( Tk_DoOneEvent( TK_DONT_WAIT | TK_ALL_EVENTS ) )  /*NIL*/
d966 1
a966 1
    return CMD_OK;
a969 29
 *	C M D _ P R E V
 */

int
cmd_prev( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	return TCL_OK;
}

/*
 *	C M D _ N E X T
 */

int
cmd_next( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	return TCL_OK;
}


/*
d977 1
a977 1
getknob( clientData, interp, argc, argv )
d1006 1
a1006 1
	interp->result = "getknob: need a knob name";
d1016 1
a1016 1
    interp->result = "getknob: invalid knob name";
d1021 1
a1021 1
 *	G U I _ K N O B
d1023 3
a1025 3
 *	Replaces the regular knob function.
 *	All this one does is call the regular one knob function, then update
 *	  the Tk sliders.
d1029 1
a1029 1
gui_knob( clientData, interp, argc, argv )
d1031 1
a1031 1
Tcl_Interp *interp;
d1035 91
a1125 1
	int result;
d1127 7
a1133 14
	/* First, call regular "knob" function and proceed if ok. */
	if((result=cmd_wrapper( clientData, interp, argc, argv )) == TCL_OK) { 
		struct rt_vls tclcmd;

		rt_vls_init( &tclcmd );
		if( strcmp(argv[1], "zero") == 0 ) {
			rt_vls_strcpy( &tclcmd, "sliders_zero" );
		} else if( strcmp(argv[1], "calibrate") == 0 ) {
			return result;
		} else {
			rt_vls_printf( &tclcmd, 
     "global sliders; if { $sliders(exist) } then { .sliders.f.k%s set %d }",
				argv[1], (int) (2048.0*atof(argv[2])) );
		}
d1135 7
a1141 3
		result = Tcl_Eval( interp, rt_vls_addr(&tclcmd) );
		rt_vls_free( &tclcmd );
	}
d1143 8
a1150 1
	return result;
d1154 4
a1157 2
/*
 *	F _ G U I
d1159 2
a1160 2
 *	Puts the necessary hooks in to interface with the MGED Interaction
 *		window.
d1164 3
a1166 1
f_gui( argc, argv ) 
d1170 5
a1174 4
	if( argc < 2 ) {
		rt_log("Error: need an interaction window name\n");
		return CMD_BAD;
	}
d1176 266
a1441 1
	strncpy(text_widget_name, argv[1], sizeof(text_widget_name));
d1443 8
a1450 10
	rt_log("Please direct your attention to the mged interaction window.\n");
	rt_add_hook( gui_output );
	Tcl_CreateCommand(interp, "cmdline", gui_cmdline, (ClientData)NULL,
			  (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "getknob", getknob, (ClientData)NULL,
			  (Tcl_CmdDeleteProc *)NULL);
	Tcl_CreateCommand(interp, "knob", gui_knob, (ClientData)NULL,
			  (Tcl_CmdDeleteProc *)NULL);
	gui_mode = 1;
	return CMD_OK;
d1453 34
a1486 1
#endif
d1491 1
a1491 1
 * Sets up the Tcl interpreter, if running in Tcl mode.
a1497 1
#ifndef XMGED
d1499 2
a1500 3
    char	buf[1024];
    extern int glob_compat_mode;
    struct rt_vls _mged_name;
d1502 1
a1502 1
    rt_vls_init( &_mged_name );
d1504 3
a1506 6
#endif
    rt_vls_init( &history );
    rt_vls_strcpy( &history, "" );
    
    rt_vls_init( &replay_history );
    rt_vls_strcpy( &replay_history, "" );
d1508 1
a1508 3
    journalfp = NULL;

#ifndef XMGED
d1512 4
a1515 5
    /* XXX This is done so the user doesn't run the Tcl version of exit
       (we want to run "quit" instead).  Needs to be improved */
    
    (void)Tcl_CreateCommand(interp, "exit", cmd_wrapper, (ClientData)NULL,
			    (Tcl_CmdDeleteProc *)NULL);
a1516 3
    Tcl_SetVar(interp, "tcl_interactive",
	       interactive ? "1" : "0", TCL_GLOBAL_ONLY);

a1520 2
    /* The Tk initialization stuff is run with the "loadtk" command */

d1522 6
a1527 4
    for (ftp = funtab+1; ftp->ft_name != NULL; ftp++)  {
	sprintf(buf, "info commands %s", ftp->ft_name);
	if( Tcl_Eval(interp, buf) != TCL_OK ||
	   interp->result[0] != '\0' )  {
d1531 3
a1533 3

	rt_vls_trunc( &_mged_name, 0 );
	rt_vls_printf( &_mged_name, "_mged_%s", ftp->ft_name );
d1536 4
a1539 4
	    Tcl_CreateCommand(interp, ftp->ft_name, ftp->ft_func,
			      (ClientData)ftp, (Tcl_CmdDeleteProc *)NULL);
	    Tcl_CreateCommand(interp, rt_vls_addr( &_mged_name ), ftp->ft_func,
			      (ClientData)ftp, (Tcl_CmdDeleteProc *)NULL);
d1541 4
a1544 4
	    Tcl_CreateCommand(interp, ftp->ft_name, cmd_wrapper, 	    
			      (ClientData)ftp, (Tcl_CmdDeleteProc *)NULL);
	    Tcl_CreateCommand(interp, rt_vls_addr( &_mged_name ), cmd_wrapper,
			      (ClientData)ftp, (Tcl_CmdDeleteProc *)NULL);
d1558 1
d1561 2
a1562 1
    mged_variable_setup(interp);
d1564 7
a1571 2
#endif
}
d1573 2
a1574 9
/* wrapper for sync() */

int
f_sync(argc, argv)
int argc;
char **argv;
{
    sync();
    return CMD_OK;
d1579 3
a1581 1
   */
a1626 2
int glob_compat_mode = 1;

d1733 4
a1736 1
    int	i;
d1738 2
a1739 12
    int	len;
    register char	*cp;
    char		*ep;
    char		*end;
    struct rt_vls	line;
    struct rt_vls       line_globbed;
    struct rt_vls	cmd_buf;
    struct rt_vls	str;
    int  	result;
    int	argc;
    char 	*argv[MAXARGS+2];
    struct timeval start, finish;
a1740 2
    struct rt_vls	hadd;

d1743 2
a1744 1
    if( (len = rt_vls_strlen( vp )) <= 0 )  return 0;
d1746 1
a1746 1
    cp = rt_vls_addr( vp );
d1749 20
a1768 17
    rt_vls_init( &line );
    rt_vls_init( &line_globbed );
    rt_vls_init( &cmd_buf );
    rt_vls_init( &str );
    rt_vls_init( &hadd );

    while( cp < end ) {
	ep = strchr( cp, '\n' );
	if( ep == NULL )  break;

	/* Copy one cmd, incl newline.  Null terminate */
	rt_vls_strncpy( &line, cp, ep-cp+1 );
	/* parse_line insists on it ending with newline&null */
#ifdef XMGED
	rt_vls_strcpy( &cmd_buf, rt_vls_addr(&line) );
	i = parse_line( record, &cmd_buf, &argc, argv );
#endif
a1769 1
	    int done;
d1771 4
a1774 5
#ifndef XMGED
	    gettimeofday( &start, NULL );
	    rt_vls_trunc( &line_globbed, 0 );
	    if( glob_compat_mode )
		mged_compat( &line_globbed, &line );
d1776 7
a1782 7
		rt_vls_vlscat( &line_globbed, &line );
#if 0
	    printf("BEFORE::%s", rt_vls_addr(&line));
	    printf("AFTER:::%s", rt_vls_addr(&line_globbed));
#endif
	    result = Tcl_Eval( interp, rt_vls_addr(&line_globbed) );
	    gettimeofday( &finish, NULL );
d1784 1
a1784 1
	    switch( result ) {
d1786 10
a1795 7
    /* If it's TCL's OK, then print out the associated return value. */
		if( strcmp(interp->result, "MGED_Ok") != 0
		   && strlen(interp->result) > 0 ) {
		    /* Some TCL value to display */
		    rt_log("%s\n", interp->result);
		}
		rt_vls_strcpy( &hadd, rt_vls_addr(&line) );
d1798 14
a1811 12
	    case TCL_ERROR:
    /* If it's an MGED error, don't print out an error message. */
		if( strcmp(interp->result, "MGED_Error") == 0 ) {
		    rt_vls_printf( &hadd, "# %s", rt_vls_addr(&line) );
		    done = 1;
		    break;
		} 
    /* If it's a TCL error, print out the associated error message. */
		if( strcmp(interp->result, "MGED_More") != 0 ){
		    rt_vls_printf( &hadd, "# %s", rt_vls_addr(&line) );
		    rt_log("%s\n", interp->result);
		    done = 1;
d1815 7
a1821 15
    /* Fall through to here iff it's MGED_More. */
		done = 0;
		break;
	    }
#else
	    gettimeofday( &start, NULL );
	    result = mged_cmd(argc, argv, funtab);
	    gettimeofday( &finish, NULL );
	    switch( result ) {
	    case CMD_OK:
		rt_vls_strcpy( &hadd, rt_vls_addr(&line) );
		done = 1;
		break;
	    case CMD_BAD:
		rt_vls_printf( &hadd, "# %s", rt_vls_addr(&line) );
a1823 3
	    case CMD_MORE:
		done = 0;
		break;
a1824 2
#endif
    /* Record into history and return if we're all done. */
a1825 1
	    if( done ) {
d1827 5
a1831 5
		if(record){
		    addtohist(rt_vls_addr(&hadd));
		       /* reset hcurr to point to most recent command */
		    hcurr = htail;
		}
a1832 6
		/* Record non-newline commands */
		if( rt_vls_strlen(&hadd) > 1 )
		    history_record( &hadd, &start, &finish );
		break;
	    }

d1836 3
d1840 11
a1850 1
	    rt_vls_gets( &str, stdin );
a1851 15
	    /* Remove newline */
	    rt_vls_trunc( &line, rt_vls_strlen(&line)-1 );

	    rt_vls_strcat( &line, " " );
	    rt_vls_vlscatzap( &line, &str );
	    rt_vls_strcat( &line, "\n" );
#ifdef XMGED
	    rt_vls_strcpy( &cmd_buf, rt_vls_addr(&line) );
	    i = parse_line( record, &cmd_buf, &argc, argv );
#endif
	    rt_vls_free( &str );
	}
#ifdef XMGED
	if( i < 0 )  continue;	/* some kind of error */
#endif
a1852 1

a1857 1
    rt_vls_free( &cmd_buf );
d1859 1
a1859 1
    rt_vls_free( &hadd );
a1862 8
/*
 *			P A R S E _ L I N E
 *
 * Parse commandline into argument vector
 * Returns nonzero value if input is to be ignored
 * Returns less than zero if there is no input to read.
 */

d1864 5
a1868 10
#ifdef XMGED
parse_line(record, cmd, argcp, argv)
int	record;		/* if true, add command to the history list */
struct rt_vls   *cmd;
#else
parse_line(line, argcp, argv)
char	*line;
#endif
int	*argcp;
char   **argv;
d1870 9
a1878 56
	register char *lp;
	register char *lp1;
#ifdef XMGED
	struct rt_vls   tmp_cmd;
        int     n;
#endif

	(*argcp) = 0;
#ifdef XMGED
	lp = rt_vls_addr(cmd);
#else
	lp = &line[0];
#endif

	/* Delete leading white space */
	while( (*lp == ' ') || (*lp == '\t'))
		lp++;

	argv[0] = lp;

	if( *lp == '\n' )
		return(1);		/* NOP */

	if( *lp == '#' )
		return 1;		/* NOP -- a comment line */

#ifdef XMGED
	/*
	 * Recall command from history list.
	 */
	if( *lp == '@@' ){
		rt_vls_init( &tmp_cmd );
		n = parse_history( &tmp_cmd, ++lp );
		if( n )
			return( n );	/* Don't process command line! */

		rt_vls_free( cmd );
		rt_vls_strcpy( cmd, rt_vls_addr( &tmp_cmd ) );
		rt_vls_free( &tmp_cmd );
		return parse_line(record, cmd, argcp, argv);
	}

	if(journal && strncmp("journal", rt_vls_addr(cmd), 7)){
		n = rt_vls_strlen(cmd);
		cmd->vls_str[n - 1] = NULL;
		fprintf(journal_file, "%s\n", rt_vls_addr(cmd));
		cmd->vls_str[n - 1] = '\n';
	}
#endif

	/* Handle "!" shell escape char so the shell can parse the line */
	if( *lp == '!' )  {
		(void)system( ++lp);
		rt_log("!\n");
		return(1);		/* Don't process command line! */
	}
d1880 1
a1880 28
	/*  Starting with the first non-whitespace, search ahead for the
	 *  first whitespace (or newline) at the end of each command
	 *  element and turn it into a null.  Then while there is more
	 *  turn it into nulls.  Once the next string is spotted (or
	 *  the of the command line) glob it if necessary and prepare
	 *  for the next command element.
	 */
	for( ; *lp != '\0'; lp++ )  {
		if((*lp == ' ') || (*lp == '\t') || (*lp == '\n'))  {
			*lp = '\0';
			lp1 = lp + 1;
			if((*lp1 == ' ') || (*lp1 == '\t') || (*lp1 == '\n'))
				continue;
			/* If not cmd [0], check for regular exp */
			if( *argcp > 0 )
				(void)cmd_glob(argcp, argv, MAXARGS);
			if( (*argcp)++ >= MAXARGS )  {
				rt_log("More than %d arguments, excess flushed\n", MAXARGS);
				argv[MAXARGS] = (char *)0;
				return(0);
			}
			argv[*argcp] = lp1;
		}
		/* Finally, a non-space char */
	}
	/* Null terminate pointer array */
	argv[*argcp] = (char *)0;
	return(0);
d1886 3
a1888 4
 *  Check a table for the command, check for the correct
 *  minimum and maximum number of arguments, and pass control
 *  to the proper function.  If the number of arguments is
 *  incorrect, print out a short help message.
d1890 1
d1892 3
a1894 3
mged_cmd( argc, argv, functions )
int	argc;
char	**argv;
d1897 1
a1897 1
	register struct funtab *ftp;
d1899 5
a1903 5
	AliasList	curr;
	struct rt_vls	cmd;
	int result;
	int	i, cmp;
	int 	save_journal;
d1906 3
a1908 4
	if( argc == 0 )  {
		/* No command entered, that's fine */
		return CMD_OK;
	}
d1910 6
a1915 6
/* check for aliases first */
	for(curr = atop; curr != NULL;){
		if((cmp = strcmp(argv[0], curr->name)) == 0){
			if(curr->marked)
		/* alias has same name as real command, so call real command */
				break;
d1917 17
a1933 17
	/* repackage alias commands with any arguments and call cmdline again */
			save_journal = journal;
			journal = 0;	/* temporarily shut off journalling */
			rt_vls_init( &cmd );
			curr->marked = 1;
			if(!extract_alias_def(&cmd, curr, argc, argv))
				(void)cmdline(&cmd, False);

			rt_vls_free( &cmd );
			curr->marked = 0;
			journal = save_journal;	/* restore journal state */
			return CMD_OK;
		}else if(cmp > 0)
			curr = curr->right;
		else
			curr = curr->left;
	}
d1935 10
a1944 10
	for( ftp = functions+1; ftp->ft_name ; ftp++ )  {
		if( strcmp( ftp->ft_name, argv[0] ) != 0 )
			continue;
		/* We have a match */
		if( (ftp->ft_min <= argc) &&
		    (argc <= ftp->ft_max) )  {
			/* Input has the right number of args.
		    	 * Call function listed in table, with
		    	 * main(argc, argv) style args
		    	 */
d1946 1
a1946 1
		  result = ftp->ft_func(argc, argv);
d1950 6
a1955 6
			if( sedraw > 0) {
				sedit();
				sedraw = 0;
				dmaflag = 1;
			}
			return result;
d1957 12
a1968 12
			switch (ftp->ft_func(argc, argv)) {
			case CMD_OK:
				return CMD_OK;
			case CMD_BAD:
				return CMD_BAD;
			case CMD_MORE:
				return CMD_MORE;
			default:
				rt_log("mged_cmd(): Invalid return from %s\n",
					ftp->ft_name);
				return CMD_BAD;
			}
a1969 4
		}
		rt_log("Usage: %s%s %s\n\t(%s)\n",functions->ft_name,
		    ftp->ft_name, ftp->ft_parms, ftp->ft_comment);
		return CMD_BAD;
d1971 2
a1972 2
	rt_log("%s%s: no such command, type '%s?' for help\n",
	    functions->ft_name, argv[0], functions->ft_name);
d1974 4
d2026 14
d2314 2
a2315 2
 *	F _ E C H O
 *
d2319 3
a2321 1
f_echo( argc, argv )
d2325 1
a2325 1
	register int i;
d2327 4
a2330 4
	for( i=1; i < argc; i++ )  {
		rt_log( i==1 ? "%s" : " %s", argv[i] );
	}
	rt_log("\n");
d2332 1
a2332 1
	return CMD_OK;
@


11.19
log
@Lots of Tcl-related changes
@
text
@d240 2
@


11.18
log
@Minor changes for TMGED
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.17 1995/05/30 15:08:13 gdurf Exp gdurf $ (BRL)";
d53 1
a53 1
#ifdef MGED_TCL
d59 8
a66 1
#ifdef XMGED
d75 1
d163 2
a164 1
extern int	cmd_glob();
d173 1
a173 1
#ifdef MGED_TCL
d175 1
d191 7
a197 6
	char *ft_name;
	char *ft_parms;
	char *ft_comment;
	int (*ft_func)();
	int ft_min;
	int ft_max;
d202 1
a202 1
	0, 0, 0,
d204 1
a204 1
	f_fhelp,0,MAXARGS,
d206 1
a206 1
	f_comm,1,1,
d208 1
a208 1
	f_3ptarb, 1, 27,
d211 1
a211 1
        f_adc, 1, 5,
d213 1
a213 1
	f_aeview, 3, 3,
d216 1
a216 1
        f_aip, 1, 2,
d218 1
a218 1
	f_alias, 1, MAXARGS,
d221 1
a221 1
	f_analyze,1,MAXARGS,
d223 1
a223 1
	f_arbdef,4,4,
d225 1
a225 1
	f_arced, 3,MAXARGS,
d227 1
a227 1
	f_area, 1, 2,
d229 1
a229 1
	f_attach,1,2,
d231 1
a231 1
	f_blast,2,MAXARGS,
d233 1
a233 1
	f_bev, 2, MAXARGS,
d236 1
a236 1
        f_bindkey, 1, MAXARGS,
d238 1
a238 1
	f_button, 2, 2,
d241 1
a241 1
	f_cat,2,MAXARGS,
d243 1
a243 1
	f_center, 4,4,
d246 1
a246 1
	f_closew, 1, 2,
d249 1
a249 1
	f_color, 7, 7,
d251 3
a253 8
	f_comb,4,MAXARGS,
#ifdef MGED_TCL
"mconcat", "file [prefix]", "concatenate 'file' onto end of present database.  Run 'dup file' first.",
	f_concat, 2, 3,
#else
"concat", "file [prefix]", "concatenate 'file' onto end of present database.  Run 'dup file' first.",
	f_concat, 2, 3,
#endif
d256 1
a256 1
	f_copyeval, 1, 27,
d258 1
a258 1
	f_copy,3,3,
d261 1
a261 1
        f_cue, 1, 1,
d264 1
a264 1
	f_copy_inv,3,3,
d266 3
a268 1
	f_delobj,2,MAXARGS,
d270 1
a270 1
	f_debugdir, 1, 1,
d272 1
a272 1
	f_debuglib,1,2,
d274 1
a274 1
	f_debugmem, 1, 1,
d276 1
a276 1
	f_debugnmg,1,2,
d278 3
a280 3
	f_delay,3,3,
"dm", "set var=val", "Do display-manager specific command",
	f_dm, 2, MAXARGS,
d282 1
a282 1
	f_dup, 2, 3,
d284 1
a284 1
	f_evedit,2,MAXARGS,
d286 1
a286 1
	f_edit,2,MAXARGS,
d288 1
a288 1
	f_echo, 1, MAXARGS,
d290 1
a290 1
	f_edcodes, 2, MAXARGS,
d292 1
a292 1
	f_edcolor, 1, 1,
d294 1
a294 1
	f_edcomb,6,7,
d296 1
a296 1
	f_edgedir, 3, 4,
d298 1
a298 1
	f_ev, 2, MAXARGS,
d300 1
a300 1
	f_eqn, 4, 4,
d302 3
a304 1
	f_extrude,3,3,
d306 1
a306 1
	f_facedef, 2, MAXARGS,
d308 1
a308 1
	f_facetize, 3, MAXARGS,
d310 1
a310 1
	f_find, 1, MAXARGS,
d312 1
a312 1
	f_fix,1,1,
d314 1
a314 1
	f_fracture, 2, 3,
d316 2
a317 2
	f_group,3,MAXARGS,
#ifdef MGED_TCL
d319 1
a319 1
	f_gui, 2, 2,
d323 1
a323 1
	f_hideline,2,4,
d326 1
a326 1
	f_help,0,MAXARGS,
d329 1
a329 1
	f_history,1, 2,
d331 2
a332 2
"history", "[-delays]", "describe command history",
	f_history, 1, 4,
d335 1
a335 1
	f_instance,3,4,
d337 1
a337 1
	f_tables, 3, MAXARGS,
d340 1
a340 1
       f_knob,2,3,
d343 1
a343 1
	f_ill,2,2,
d345 1
a345 1
	f_in, 1, MAXARGS,
d347 1
a347 1
	f_inside, 1, MAXARGS,
d350 1
a350 1
        f_irot, 4, 4,
d353 1
a353 1
	f_itemair,3,4,
d356 1
a356 1
        f_tran, 4, 4,
d359 1
a359 1
	f_joint, 1, MAXARGS,
d362 1
a362 1
	f_journal, 1, 2,
d365 1
a365 1
	f_journal, 1, 2,
d368 1
a368 1
	f_keep, 3, MAXARGS,
d370 1
a370 1
	f_keypoint,1,4,
d372 1
a372 1
	f_kill,2,MAXARGS,
d374 1
a374 1
	f_killall, 2, MAXARGS,
d376 1
a376 1
	f_killtree, 2, MAXARGS,
d378 1
a378 1
	f_knob,2,3,
d380 1
a380 1
	f_list,2,MAXARGS,
d382 1
a382 1
	f_labelvert, 2, MAXARGS,
d385 1
a385 1
        f_light, 1, 1,
d388 5
a392 1
	f_pathsum, 1, MAXARGS,
d394 1
a394 1
	dir_print,1,MAXARGS,
d396 1
a396 1
	f_mouse, 4,4,
d398 1
a398 1
	f_make,3,3,
d400 1
a400 1
	f_mater,2,3,
d402 1
a402 1
	f_matpick, 2,2,
d404 1
a404 1
	f_memprint, 1, 1,
d406 1
a406 1
	f_mirface,3,3,
d408 1
a408 1
	f_mirror,4,4,
d410 1
a410 1
	f_name,3,3,
d412 1
a412 1
	f_mvall, 3, 3,
d414 1
a414 1
	f_nirt,1,MAXARGS,
d416 1
a416 1
	f_opendb, 2, 2,
d419 1
a419 1
	f_openw, 1, 2,
d422 1
a422 1
	f_orientation, 5, 5,
d424 1
a424 1
	f_rot_obj, 4, 4,
d426 1
a426 1
	f_overlay, 2, 3,
d428 1
a428 1
	f_param,2,4,
d430 1
a430 1
	f_pathsum, 1, MAXARGS,
d432 1
a432 1
	f_permute,2,2,
d435 1
a435 1
        f_perspective, 1, 2,
d438 1
a438 1
	f_plot, 2, MAXARGS,
d440 1
a440 1
	f_polybinout, 2, 2,
d442 1
a442 1
	f_pov, 3+4+1, MAXARGS,
d444 1
a444 1
	f_prcolor, 1, 1,
d446 1
a446 1
	f_prefix, 3, MAXARGS,
d448 1
a448 1
	f_preview, 2, MAXARGS,
d450 1
a450 1
	f_press,2,MAXARGS,
d453 1
a453 1
        f_ps, 2, 3,
d456 1
a456 1
	f_push, 2, MAXARGS,
d458 1
a458 1
	f_quit,1,1,
d460 1
a460 1
	f_quit,1,1,
d462 1
a462 1
	f_qorot, 8, 8,
d464 1
a464 1
	f_qvrot, 5, 5,
d466 1
a466 1
	f_region,4,MAXARGS,
d468 1
a468 1
	f_red, 2, 2,
d470 1
a470 1
	f_refresh, 1,1,
d472 1
a472 1
	f_regdebug, 1,2,
d474 1
a474 1
	f_regdef, 2, 5,
d476 1
a476 1
	f_tables, 3, MAXARGS,
d478 1
a478 1
	f_release,1,1,
d480 1
a480 1
	f_rfarb, 1, 27,
d482 1
a482 1
	f_rm,3,MAXARGS,
d484 1
a484 1
	f_rmats,2,MAXARGS,
d486 1
a486 1
	f_rot_obj, 4, 4,
d488 1
a488 1
	f_rrt,2,MAXARGS,
d490 1
a490 1
	f_rt,1,MAXARGS,
d492 1
a492 1
	f_rtcheck,1,MAXARGS,
d495 1
a495 1
	f_savedit, 1, 1,
d498 1
a498 1
	f_savekey,2,MAXARGS,
d500 3
a502 8
	f_saveview,2,MAXARGS,
#ifdef MGED_TCL
"mscale", "factor", "scale object by factor",
	f_sc_obj,2,2,
#else
"scale", "factor", "scale object by factor",
	f_sc_obj,2,2,
#endif
d504 4
a507 4
	f_sed,2,2,
#ifdef MGED_TCL
"mset",	"[var=opt]", "assign/display mged variables",
	f_set,1,2,
d510 1
a510 1
	f_set,1,2,
d513 1
a513 1
	f_shells, 2,2,
d515 1
a515 1
	f_shader, 3,MAXARGS,
d517 1
a517 1
	f_view, 2,2,
d520 1
a520 1
	f_slider, 3,3,
d523 1
a523 2
	f_tables, 3, MAXARGS,
#ifndef MGED_TCL
d526 1
a526 5
	f_source, 2, MAXARGS,
#else
"source", "file/pipe", "read and process file/pipe of commands",
	f_source, 2,MAXARGS,
#endif
d529 1
a529 1
	f_status, 1,1,
d531 1
a531 1
	f_summary,1,2,
d534 1
a534 1
	f_slewview, 3, 3,
d537 1
a537 1
	f_sync, 1, 1,
d539 1
a539 1
	dir_print,1,MAXARGS,
d541 1
a541 1
	f_tabobj, 2, MAXARGS,
d543 1
a543 1
	f_tedit,1,1,
d545 1
a545 1
	f_title,1,MAXARGS,
d547 1
a547 1
	f_tol, 1, 11,
d549 1
a549 1
	f_tops,1,1,
d551 1
a551 1
	f_amtrack, 1, 27,
d554 1
a554 1
        f_tran, 4, 4,
d557 1
a557 1
	f_tr_obj,4,4,
d559 1
a559 1
	f_tree, 2, MAXARGS,
d562 1
a562 1
	f_unalias, 2, MAXARGS,
d565 1
a565 1
	f_units,1,2,
d567 1
a567 1
	f_vrmgr, 3, MAXARGS,
d569 1
a569 1
	f_vrot,4,4,
d571 1
a571 1
	f_vrot_center, 5, 5,
d573 1
a573 1
	f_which_id, 2, MAXARGS,
d575 1
a575 1
	f_debug, 1,2,
d577 1
a577 1
	f_xpush, 2,2,
d579 1
a579 1
	f_zap,1,1,
d582 1
a582 1
        f_zbuffer, 1, 1,
d584 1
a584 1
        f_zclip, 1, 1,
d587 1
a587 1
	f_zoom, 2,2,
d589 1
a589 1
	0, 0, 0,
d933 1
a933 1
#ifdef MGED_TCL
d962 33
a994 14
	switch (mged_cmd(argc, argv, funtab)) {
	case CMD_OK:
		interp->result = "MGED_Ok";
		return TCL_OK;
	case CMD_BAD:
		interp->result = "MGED_Error";
		return TCL_ERROR;
	case CMD_MORE:
		interp->result = "MGED_More";
		return TCL_ERROR;
	default:
		interp->result = "MGED_Unknown";
		return TCL_ERROR;
	}
d1123 40
d1206 1
a1206 1
	char *cmd;
d1208 33
a1240 59
	if( argc < 2 ) {
		interp->result = "getknob: need a knob name";
		return TCL_ERROR;
	}

	cmd = argv[1];
	switch( cmd[0] ) {
	case 'a':
		switch( cmd[1] ) {
		case 'x':
			sprintf( interp->result, "%lf", absolute_rotate[X] );
			return TCL_OK;
		case 'y':
			sprintf( interp->result, "%lf", absolute_rotate[Y] );
			return TCL_OK;
		case 'z':
			sprintf( interp->result, "%lf", absolute_rotate[Z] );
			return TCL_OK;
		case 'X':
			sprintf( interp->result, "%lf", absolute_slew[X] );
			return TCL_OK;
		case 'Y':
			sprintf( interp->result, "%lf", absolute_slew[Y] );
			return TCL_OK;
		case 'Z':
			sprintf( interp->result, "%lf", absolute_slew[Z] );
			return TCL_OK;
		case 'S':
			sprintf( interp->result, "%lf", absolute_zoom );
			return TCL_OK;
		default:
			interp->result = "getknob: invalid knob name";
			return TCL_ERROR;
		}
	case 'x':
		sprintf(interp->result, "%lf", rate_rotate[X]);
		return TCL_OK;
	case 'y':
		sprintf(interp->result, "%lf", rate_rotate[Y]);
		return TCL_OK;
	case 'z':
		sprintf(interp->result, "%lf", rate_rotate[Z]);
		return TCL_OK;
	case 'X':
		sprintf(interp->result, "%lf", rate_slew[X]);
		return TCL_OK;
	case 'Y':
		sprintf(interp->result, "%lf", rate_slew[Y]);
		return TCL_OK;
	case 'Z':
		sprintf(interp->result, "%lf", rate_slew[Z]);
		return TCL_OK;
	case 'S':
		sprintf(interp->result, "%lf", rate_zoom);
		return TCL_OK;
	default:
		interp->result = "getknob: invalid knob name";
		return TCL_ERROR;
	}
d1319 1
a1319 3
#ifdef MGED_TCL
 * Sets up the TCL interpreter.
#endif
d1324 1
a1324 1
int	interactive;
d1326 5
a1330 4
#ifdef MGED_TCL
        register struct funtab *ftp;
	char	buf[1024];
#endif
d1332 1
a1332 2
	rt_vls_init( &history );
	rt_vls_strcpy( &history, "" );
d1334 6
a1339 2
	rt_vls_init( &replay_history );
	rt_vls_strcpy( &replay_history, "" );
d1341 1
a1341 1
	journalfp = NULL;
d1343 1
a1343 1
#ifdef MGED_TCL
d1345 1
a1345 1
	interp = Tcl_CreateInterp();
d1347 5
a1351 2
	Tcl_CreateCommand(interp, "exit", cmd_wrapper, (ClientData)NULL,
			(Tcl_CmdDeleteProc *)NULL);
d1353 2
a1354 2
	Tcl_SetVar(interp, "tcl_interactive",
		interactive ? "1" : "0", TCL_GLOBAL_ONLY);
d1356 2
a1357 2
	/* This runs the init.tcl script */
	if( Tcl_Init(interp) == TCL_ERROR )
d1360 1
a1360 5
	/* Screen name should be same as attachment */
	/* This binds in Tk commands.  Do AFTER binding MGED commands */
	tkwin = Tk_CreateMainWindow(interp, NULL, "TkMGED", "tkMGED");
	if (tkwin == NULL)
	rt_log("Error creating Tk window: %s\n", interp->result);
d1362 8
a1369 4
	if (tkwin != NULL) {
		/* XXX HACK! */
		extern void (*extrapoll_hook)();	/* ged.c */
		extern int  extrapoll_fd;		/* ged.c */
d1371 15
a1385 2
		extrapoll_hook = mged_tk_hook;
		extrapoll_fd = Tk_Display(tkwin)->fd;
a1386 1
		Tk_GeometryRequest(tkwin, 200, 200);
d1388 8
a1395 2
		Tk_MakeWindowExist(tkwin);
		Tk_MapWindow(tkwin);
d1397 3
a1399 18
		/* This runs the tk.tcl script */
		if( Tk_Init(interp) == TCL_ERROR )
		rt_log("Tk_init error %s\n", interp->result);
	}

	/* Finally, add in all the MGED commands, if they don't conflict */
        for (ftp = funtab+1; ftp->ft_name != NULL; ftp++)  {
        	sprintf(buf, "info commands %s", ftp->ft_name);
        	if( Tcl_Eval(interp, buf) != TCL_OK ||
		    interp->result[0] != '\0' )  {
	        	rt_log("WARNING:  '%s' name collision (%s)\n", ftp->ft_name, interp->result);
        	}
		Tcl_CreateCommand(interp, ftp->ft_name, cmd_wrapper, 
			(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
        }

	/* Handle any delayed events which result */
	while( Tk_DoOneEvent( TK_DONT_WAIT | TK_ALL_EVENTS ) )  /*NIL*/;
d1401 1
a1401 4
	/* Link to some internal variables */
	Tcl_LinkVar(interp, "mged_center_x", (char *)&toViewcenter[MDX], TCL_LINK_DOUBLE );
	Tcl_LinkVar(interp, "mged_center_y", (char *)&toViewcenter[MDY], TCL_LINK_DOUBLE );
	Tcl_LinkVar(interp, "mged_center_z", (char *)&toViewcenter[MDZ], TCL_LINK_DOUBLE );
d1412 22
a1433 2
	sync();
	return CMD_OK;
d1436 114
d1572 14
a1585 13
	int	i;
	int	need_prompt = 0;
	int	len;
	register char	*cp;
	char		*ep;
	char		*end;
	struct rt_vls	cmd;
	struct rt_vls	cmd_buf;
	struct rt_vls	str;
	int  	result;
	int	argc;
	char 	*argv[MAXARGS+2];
	struct timeval start, finish;
d1587 1
a1587 1
	struct rt_vls	hadd;
d1589 1
a1589 1
	RT_VLS_CHECK(vp);
d1591 1
a1591 1
	if( (len = rt_vls_strlen( vp )) <= 0 )  return 0;
d1593 2
a1594 2
	cp = rt_vls_addr( vp );
	end = cp + len;
d1596 30
a1625 19
	rt_vls_init( &cmd );
	rt_vls_init( &cmd_buf );
	rt_vls_init( &str );
	rt_vls_init( &hadd );
	rt_vls_strcpy( &hadd, "" );

	while( cp < end )  {
		ep = strchr( cp, '\n' );
		if( ep == NULL )  break;

		/* Copy one cmd, incl newline.  Null terminate */
		rt_vls_strncpy( &cmd, cp, ep-cp+1 );
		/* parse_line insists on it ending with newline&null */
#ifndef MGED_TCL		
		rt_vls_strcpy( &cmd_buf, rt_vls_addr(&cmd) );
#ifdef XMGED
		i = parse_line( record, &cmd_buf, &argc, argv);
#else
		i = parse_line( rt_vls_addr(&cmd_buf), &argc, argv );
d1627 2
a1628 3
#endif
		while (1) {
			int done;
d1630 25
a1654 34
			done = 0;
#ifdef MGED_TCL
			gettimeofday( &start, NULL );
			result = Tcl_Eval(interp, rt_vls_addr(&cmd));
			gettimeofday( &finish, NULL );

			switch( result ) {
			case TCL_OK:
	/* If it's TCL's OK, then print out the associated return value. */
				if( strcmp(interp->result, "MGED_Ok") != 0
				    && strlen(interp->result) > 0 ) {
					/* Some TCL value to display */
					rt_log("%s\n", interp->result);
				}
				rt_vls_strcpy( &hadd, rt_vls_addr(&cmd) );
				done = 1;
				break;
			case TCL_ERROR:
	/* If it's an MGED error, don't print out an error message. */
				if(strcmp(interp->result, "MGED_Error") == 0){
					rt_vls_printf( &hadd, "# %s",
						rt_vls_addr(&cmd) );
					done = 1;
					break;
				} 

	/* If it's a TCL error, print out the associated error message. */
				if( strcmp(interp->result, "MGED_More") != 0 ){
					rt_vls_printf( &hadd, "# %s",
						rt_vls_addr(&cmd) );
					rt_log("%s\n", interp->result);
					done = 1;
					break;
				}
d1656 4
a1659 5
	/* Fall through to here iff it's MGED_More. */
				done = 0;
				break;

			}
d1661 16
a1676 17
			gettimeofday( &start, NULL );
			result = mged_cmd(argc, argv, funtab);
			gettimeofday( &finish, NULL );
			switch( result ) {
			case CMD_OK:
				rt_vls_strcpy( &hadd, rt_vls_addr(&cmd) );
				done = 1;
				break;
			case CMD_BAD:
				rt_vls_printf( &hadd, "# %s",
					rt_vls_addr(&cmd) );
				done = 1;
				break;
			case CMD_MORE:
				done = 0;
				break;
			}
d1678 1
a1678 2

	/* Record into history and return if we're all done. */
d1680 1
a1680 1
			if( done ) {
d1682 5
a1686 4
				if(record){
				  addtohist(rt_vls_addr(&hadd));
				  hcurr = htail;		/* reset hcurr to point to most recent command */
				}
d1688 14
a1701 5
					/* Record non-newline commands */
				if( rt_vls_strlen(&hadd) > 1 )
				    history_record( &hadd, &start, &finish );
				break;
			}
d1703 3
a1705 14
			/* If we get here, it means the command failed due
			   to insufficient arguments.  In this case, grab some
			   more from stdin and call the command again. */

			rt_vls_gets( &str, stdin );

			/* Remove newline */
			rt_vls_trunc( &cmd, rt_vls_strlen(&cmd)-1 );

			rt_vls_strcat( &cmd, " " );
			rt_vls_vlscatzap( &cmd, &str );
			rt_vls_strcat( &cmd, "\n" );
#ifndef MGED_TCL
			rt_vls_strcpy( &cmd_buf, rt_vls_addr(&cmd) );
d1707 2
a1708 3
			i = parse_line( record, &cmd_buf, &argc, argv );
#else
			i = parse_line( rt_vls_addr(&cmd_buf), &argc, argv );
d1710 4
a1713 5
#endif
			rt_vls_free( &str );
		}
#ifndef MGED_TCL
		if( i < 0 )  continue;	/* some kind of error */
d1715 1
a1715 1
		need_prompt = 1;
d1717 2
a1718 2
		cp = ep+1;
	}
d1720 6
a1725 5
	rt_vls_free( &cmd );
	rt_vls_free( &cmd_buf );
	rt_vls_free( &str );
	rt_vls_free( &hadd );
	return need_prompt;
d2766 1
a2766 1
		  "set perspective=%d\n",
d2771 1
a2771 1
		  "set perspective=%d\n",
@


11.17
log
@Bug fix for MGED_TCL
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.16 1995/03/31 20:45:49 jra Exp gdurf $ (BRL)";
d308 2
a309 2
"gui",	"", "Bring up a Tcl/Tk Graphical User Interface",
	f_gui, 1, 1,
d1263 1
a1263 1
	strncpy(text_widget_name, argv[1]);
@


11.16
log
@Temporary new command "xpush" for experimental new push command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.15 1995/03/10 23:40:23 mike Exp jra $ (BRL)";
d168 1
d1009 1
a1009 1
	sprintf(buf, ".i.f.text insert insert \"%s\"", str);
d1011 4
a1014 2
	Tcl_Eval(interp, ".i.f.text yview -pickplace insert");
	Tcl_Eval(interp, "set printend [.i.f.text index insert]");
d1258 7
@


11.15
log
@Added arced command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.14 95/03/10 20:54:16 mike Exp Locker: mike $ (BRL)";
d162 1
d571 2
@


11.14
log
@If no command is entered, don't say anything.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.13 95/03/10 20:47:03 mike Exp Locker: mike $ (BRL)";
d161 1
d211 2
@


11.13
log
@Moved MAXARGS to ged.h, standardized on it's use, increased to 9000.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.12 95/03/10 19:18:14 mike Exp Locker: mike $ (BRL)";
d1670 2
a1671 3
		rt_log("no command entered, type '%s?' for help\n",
		    functions->ft_name);
		return CMD_BAD;
@


11.12
log
@Can't do rt_log( rt_vls_addr( &str ) ), need to use "%s" format.
Otherwise, can over-run format string in printf.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.11 95/03/09 20:56:34 butler Exp Locker: mike $ (BRL)";
a152 1
#define	MAXARGS		2000	/* Maximum number of args per line */
@


11.11
log
@updated flags to "ev" command in usage message
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.10 1995/02/13 15:45:48 jra Exp butler $ (BRL)";
d913 1
a913 1
		rt_log( rt_vls_addr(which_history) );
@


11.10
log
@Added "shells" command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.9 95/01/25 15:24:19 jra Exp Locker: jra $ (BRL)";
d285 1
a285 1
"ev",	"[-w] [-n] [-P#] [-T] <objects>", "evaluate objects via NMG tessellation",
@


11.9
log
@Changed eval command to "bev".
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.8 95/01/25 14:07:35 jra Exp Locker: jra $ (BRL)";
d161 1
d499 2
@


11.8
log
@Added "eval" command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.7 95/01/19 16:21:01 bparker Exp Locker: jra $ (BRL)";
d216 2
a285 2
"eval",	"[-t] [-P#] new_obj obj1 op obj2 op obj3 op ...", "evaluate objects via NMG Booleans",
	f_eval, 2, MAXARGS,
@


11.7
log
@merging xmged sources
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.5 95/01/18 08:29:34 jra Exp $ (BRL)";
d284 2
@


11.6
log
@merging xmged sources
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/cmd.c,v 11.3 95/01/19 12:03:31 bparker Exp $ (BRL)";
d48 5
d1670 7
d1678 18
d1706 12
d1730 1
@


11.5
log
@Fixed bug in tol command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.4 95/01/17 16:27:54 jra Exp Locker: jra $ (BRL)";
d54 92
d195 6
d211 6
d221 4
d241 4
d305 4
d311 1
d316 4
d326 4
d332 4
d338 4
d344 1
d361 4
d391 4
d407 4
d425 4
d467 4
d495 4
d502 4
d509 1
d514 4
d534 4
d542 4
d560 6
d624 7
d632 24
d690 1
d714 9
d724 131
d911 1
a912 1

d1362 5
d1369 1
d1409 3
d1414 1
d1481 6
d1507 3
d1512 1
d1539 5
d1546 1
d1552 4
d1558 3
d1562 1
d1576 24
d1652 7
d1717 4
d1722 1
d1906 1
d1911 9
d1921 77
d2015 1
a2016 1

d2036 909
@


11.4
log
@Added calculational tolerances to the "tol" command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.3 95/01/17 16:20:07 jra Exp Locker: jra $ (BRL)";
d361 1
a361 1
"tol", "[abs #]|[rel #]", "show/set tessellation and calculation tolerances",
@


11.3
log
@Changes by gdurf.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.2 95/01/10 17:12:44 gdurf Exp Locker: gdurf $ (BRL)";
d361 2
a362 2
"tol", "[abs #]|[rel #]", "show/set absolute or relative tolerance for tessellation",
	f_tol, 1, 3,
@


11.2
log
@*** empty log message ***
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 11.1 95/01/04 10:02:46 mike Rel4_4 Locker: gdurf $ (BRL)";
d781 27
d809 1
a809 4
		if( mged_variables.rateknobs )
			sprintf(interp->result, "%lf", rate_rotate[X]);
		else
			sprintf(interp->result, "%lf", absolute_rotate[X]);
d812 1
a812 4
		if( mged_variables.rateknobs )
			sprintf(interp->result, "%lf", rate_rotate[Y]);
		else
			sprintf(interp->result, "%lf", absolute_rotate[Y]);
d815 1
a815 4
		if( mged_variables.rateknobs )
			sprintf(interp->result, "%lf", rate_rotate[Z]);
		else	
			sprintf(interp->result, "%lf", absolute_rotate[Z]);
d818 1
a818 4
		if( mged_variables.rateknobs )
			sprintf(interp->result, "%lf", rate_slew[X]);
		else
			sprintf(interp->result, "0");
d821 1
a821 4
		if( mged_variables.rateknobs )
			sprintf(interp->result, "%lf", rate_slew[Y]);
		else
			sprintf(interp->result, "0");
d824 1
a824 4
		if( mged_variables.rateknobs )
			sprintf(interp->result, "%lf", rate_slew[Z]);
		else
			sprintf(interp->result, "0");
d827 1
a827 4
		if( mged_variables.rateknobs )
			sprintf(interp->result, "%lf", rate_zoom);
		else
			sprintf(interp->result, "0");
d859 2
d863 1
a863 1
    "global sliders; if { $sliders(exist) } then { .sliders.f.k%s set %d }",
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.58 95/01/03 14:32:48 gdurf Exp $ (BRL)";
@


10.58
log
@Minor changes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/cmd.c,v 10.57 1994/12/28 17:02:14 gdurf Exp gdurf $ (BRL)";
@


10.57
log
@Moved tkEvent stuff away
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.56 94/12/28 14:44:14 gdurf Exp Locker: jra $ (BRL)";
d562 16
d961 1
a961 2
        	rt_log("WARNING:  '%s' name collision (%s)\n", ftp->ft_name, interp->result);
        		continue;
d1031 1
d1141 1
d1479 1
d1497 6
@


10.56
log
@Fixed offending includes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.55 94/12/28 12:27:42 gdurf Exp Locker: gdurf $ (BRL)";
a1494 1715
#ifdef MGED_TCL

/* TCL */
/* XXX Slightly hacked version */
/* 
 * tkEvent.c --
 *
 *	This file provides basic event-managing facilities,
 *	whereby procedure callbacks may be attached to
 *	certain events.
 *
 * Copyright (c) 1990-1993 The Regents of the University of California.
 * All rights reserved.
 *
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the
 * above copyright notice and the following two paragraphs appear in
 * all copies of this software.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */

#ifndef lint
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.55 94/12/28 12:27:42 gdurf Exp Locker: gdurf $ SPRITE (Berkeley)";
#endif

#include "../libtk/tkConfig.h"
#include "../libtk/tkInt.h"
#include <errno.h>
#include <signal.h>

/*
 * For each timer callback that's pending, there is one record
 * of the following type, chained together in a list sorted by
 * time (earliest event first).
 */

typedef struct TimerEvent {
    struct timeval time;	/* When timer is to fire. */
    void (*proc)  _ANSI_ARGS_((ClientData clientData));
				/* Procedure to call. */
    ClientData clientData;	/* Argument to pass to proc. */
    Tk_TimerToken token;	/* Identifies event so it can be
				 * deleted. */
    struct TimerEvent *nextPtr;	/* Next event in queue, or NULL for
				 * end of queue. */
} TimerEvent;

static TimerEvent *timerQueue;	/* First event in queue. */

/*
 * The information below is used to provide read, write, and
 * exception masks to select during calls to Tk_DoOneEvent.
 */

static int readCount;		/* Number of files for which we */
static int writeCount;		/* care about each event type. */
static int exceptCount;
static fd_mask masks[3*MASK_SIZE];
				/* Integer array containing official
				 * copies of the three sets of
				 * masks. */
static fd_mask ready[3*MASK_SIZE];
				/* Temporary copy of masks, passed
				 * to select and modified by kernel
				 * to indicate which files are
				 * actually ready. */
static fd_mask *readPtr;	/* Pointers to the portions of */
static fd_mask *writePtr;	/* *readyPtr for reading, writing, */
static fd_mask *exceptPtr;	/* and excepting.  Will be NULL if
				 * corresponding count (e.g. readCount
				 * is zero. */
static int numFds = 0;		/* Number of valid bits in mask
				 * arrays (this value is passed
				 * to select). */

/*
 * For each file registered in a call to Tk_CreateFileHandler,
 * and for each display that's currently active, there is one
 * record of the following type.  All of these records are
 * chained together into a single list.
 */

typedef struct FileEvent {
    int fd;			/* Descriptor number for this file. */
    int isDisplay;		/* Non-zero means that this file descriptor
				 * corresponds to a display and should be
				 * treated specially. */
    fd_mask *readPtr;		/* Pointer to word in ready array
				 * for this file's read mask bit. */
    fd_mask *writePtr;		/* Same for write mask bit. */
    fd_mask *exceptPtr;		/* Same for except mask bit. */
    fd_mask mask;		/* Value to AND with mask word to
				 * select just this file's bit. */
    void (*proc)  _ANSI_ARGS_((ClientData clientData, int mask));
				/* Procedure to call.  NULL means
				 * this is a display. */
    ClientData clientData;	/* Argument to pass to proc.  For
				 * displays, this is a (Display *). */
    struct FileEvent *nextPtr;	/* Next in list of all files we
				 * care about (NULL for end of
				 * list). */
} FileEvent;

static FileEvent *fileList;	/* List of all file events. */

/*
 * There is one of the following structures for each of the
 * handlers declared in a call to Tk_DoWhenIdle.  All of the
 * currently-active handlers are linked together into a list.
 */

typedef struct IdleHandler {
    void (*proc)  _ANSI_ARGS_((ClientData clientData));
				/* Procedure to call. */
    ClientData clientData;	/* Value to pass to proc. */
    int generation;		/* Used to distinguish older handlers from
				 * recently-created ones. */
    struct IdleHandler *nextPtr;/* Next in list of active handlers. */
} IdleHandler;

static IdleHandler *idleList = NULL;
				/* First in list of all idle handlers. */
static IdleHandler *lastIdlePtr = NULL;
				/* Last in list (or NULL for empty list). */
static int idleGeneration = 0;	/* Used to fill in the "generation" fields
				 * of IdleHandler structures.  Increments
				 * each time Tk_DoOneEvent starts calling
				 * idle handlers, so that all old handlers
				 * can be called without calling any of the
				 * new ones created by old ones. */

/*
 * There's a potential problem if a handler is deleted while it's
 * current (i.e. its procedure is executing), since Tk_HandleEvent
 * will need to read the handler's "nextPtr" field when the procedure
 * returns.  To handle this problem, structures of the type below
 * indicate the next handler to be processed for any (recursively
 * nested) dispatches in progress.  The nextHandler fields get
 * updated if the handlers pointed to are deleted.  Tk_HandleEvent
 * also needs to know if the entire window gets deleted;  the winPtr
 * field is set to zero if that particular window gets deleted.
 */

typedef struct InProgress {
    XEvent *eventPtr;		 /* Event currently being handled. */
    TkWindow *winPtr;		 /* Window for event.  Gets set to None if
				  * window is deleted while event is being
				  * handled. */
    TkEventHandler *nextHandler; /* Next handler in search. */
    struct InProgress *nextPtr;	 /* Next higher nested search. */
} InProgress;

static InProgress *pendingPtr = NULL;
				/* Topmost search in progress, or
				 * NULL if none. */

/*
 * For each call to Tk_CreateGenericHandler, an instance of the following
 * structure will be created.  All of the active handlers are linked into a
 * list.
 */

typedef struct GenericHandler {
    Tk_GenericProc *proc;	/* Procedure to dispatch on all X events. */
    ClientData clientData;	/* Client data to pass to procedure. */
    int deleteFlag;		/* Flag to set when this handler is deleted. */
    struct GenericHandler *nextPtr;
				/* Next handler in list of all generic
				 * handlers, or NULL for end of list. */
} GenericHandler;

static GenericHandler *genericList = NULL;
				/* First handler in the list, or NULL. */
static GenericHandler *lastGenericPtr = NULL;
				/* Last handler in list. */

/*
 * There's a potential problem if Tk_HandleEvent is entered recursively.
 * A handler cannot be deleted physically until we have returned from
 * calling it.  Otherwise, we're looking at unallocated memory in advancing to
 * its `next' entry.  We deal with the problem by using the `delete flag' and
 * deleting handlers only when it's known that there's no handler active.
 *
 * The following variable has a non-zero value when a handler is active.
 */

static int genericHandlersActive = 0;

/*
 * Array of event masks corresponding to each X event:
 */

static unsigned long eventMasks[] = {
    0,
    0,
    KeyPressMask,			/* KeyPress */
    KeyReleaseMask,			/* KeyRelease */
    ButtonPressMask,			/* ButtonPress */
    ButtonReleaseMask,			/* ButtonRelease */
    PointerMotionMask|PointerMotionHintMask|ButtonMotionMask
	    |Button1MotionMask|Button2MotionMask|Button3MotionMask
	    |Button4MotionMask|Button5MotionMask,
					/* MotionNotify */
    EnterWindowMask,			/* EnterNotify */
    LeaveWindowMask,			/* LeaveNotify */
    FocusChangeMask,			/* FocusIn */
    FocusChangeMask,			/* FocusOut */
    KeymapStateMask,			/* KeymapNotify */
    ExposureMask,			/* Expose */
    ExposureMask,			/* GraphicsExpose */
    ExposureMask,			/* NoExpose */
    VisibilityChangeMask,		/* VisibilityNotify */
    SubstructureNotifyMask,		/* CreateNotify */
    StructureNotifyMask,		/* DestroyNotify */
    StructureNotifyMask,		/* UnmapNotify */
    StructureNotifyMask,		/* MapNotify */
    SubstructureRedirectMask,		/* MapRequest */
    StructureNotifyMask,		/* ReparentNotify */
    StructureNotifyMask,		/* ConfigureNotify */
    SubstructureRedirectMask,		/* ConfigureRequest */
    StructureNotifyMask,		/* GravityNotify */
    ResizeRedirectMask,			/* ResizeRequest */
    StructureNotifyMask,		/* CirculateNotify */
    SubstructureRedirectMask,		/* CirculateRequest */
    PropertyChangeMask,			/* PropertyNotify */
    0,					/* SelectionClear */
    0,					/* SelectionRequest */
    0,					/* SelectionNotify */
    ColormapChangeMask,			/* ColormapNotify */
    0,					/* ClientMessage */
    0,					/* Mapping Notify */
};

/*
 * If someone has called Tk_RestrictEvents, the information below
 * keeps track of it.
 */

static Bool (*restrictProc)  _ANSI_ARGS_((Display *display, XEvent *eventPtr,
    char *arg));		/* Procedure to call.  NULL means no
				 * restrictProc is currently in effect. */
static char *restrictArg;	/* Argument to pass to restrictProc. */

/*
 * The following array keeps track of the last TK_NEVENTS X events, for
 * memory dump analysis.  The tracing is only done if tkEventDebug is set
 * to 1.
 */

#define TK_NEVENTS 32
static XEvent eventTrace[TK_NEVENTS];
static int traceIndex = 0;
int tkEventDebug = 0;

/*
 *--------------------------------------------------------------
 *
 * Tk_CreateEventHandler --
 *
 *	Arrange for a given procedure to be invoked whenever
 *	events from a given class occur in a given window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	From now on, whenever an event of the type given by
 *	mask occurs for token and is processed by Tk_HandleEvent,
 *	proc will be called.  See the manual entry for details
 *	of the calling sequence and return value for proc.
 *
 *--------------------------------------------------------------
 */

void
Tk_CreateEventHandler(token, mask, proc, clientData)
    Tk_Window token;		/* Token for window in which to
				 * create handler. */
    unsigned long mask;		/* Events for which proc should
				 * be called. */
    Tk_EventProc *proc;		/* Procedure to call for each
				 * selected event */
    ClientData clientData;	/* Arbitrary data to pass to proc. */
{
    register TkEventHandler *handlerPtr;
    register TkWindow *winPtr = (TkWindow *) token;
    int found;

    /*
     * Skim through the list of existing handlers to (a) compute the
     * overall event mask for the window (so we can pass this new
     * value to the X system) and (b) see if there's already a handler
     * declared with the same callback and clientData (if so, just
     * change the mask).  If no existing handler matches, then create
     * a new handler.
     */

    found = 0;
    if (winPtr->handlerList == NULL) {
	handlerPtr = (TkEventHandler *) ckalloc(
		(unsigned) sizeof(TkEventHandler));
	winPtr->handlerList = handlerPtr;
	goto initHandler;
    } else {
	for (handlerPtr = winPtr->handlerList; ;
		handlerPtr = handlerPtr->nextPtr) {
	    if ((handlerPtr->proc == proc)
		    && (handlerPtr->clientData == clientData)) {
		handlerPtr->mask = mask;
		found = 1;
	    }
	    if (handlerPtr->nextPtr == NULL) {
		break;
	    }
	}
    }

    /*
     * Create a new handler if no matching old handler was found.
     */

    if (!found) {
	handlerPtr->nextPtr = (TkEventHandler *)
		ckalloc(sizeof(TkEventHandler));
	handlerPtr = handlerPtr->nextPtr;
	initHandler:
	handlerPtr->mask = mask;
	handlerPtr->proc = proc;
	handlerPtr->clientData = clientData;
	handlerPtr->nextPtr = NULL;
    }

    /*
     * No need to call XSelectInput:  Tk always selects on all events
     * for all windows (needed to support bindings on classes and "all").
     */
}

/*
 *--------------------------------------------------------------
 *
 * Tk_DeleteEventHandler --
 *
 *	Delete a previously-created handler.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If there existed a handler as described by the
 *	parameters, the handler is deleted so that proc
 *	will not be invoked again.
 *
 *--------------------------------------------------------------
 */

void
Tk_DeleteEventHandler(token, mask, proc, clientData)
    Tk_Window token;		/* Same as corresponding arguments passed */
    unsigned long mask;		/* previously to Tk_CreateEventHandler. */
    Tk_EventProc *proc;
    ClientData clientData;
{
    register TkEventHandler *handlerPtr;
    register InProgress *ipPtr;
    TkEventHandler *prevPtr;
    register TkWindow *winPtr = (TkWindow *) token;

    /*
     * Find the event handler to be deleted, or return
     * immediately if it doesn't exist.
     */

    for (handlerPtr = winPtr->handlerList, prevPtr = NULL; ;
	    prevPtr = handlerPtr, handlerPtr = handlerPtr->nextPtr) {
	if (handlerPtr == NULL) {
	    return;
	}
	if ((handlerPtr->mask == mask) && (handlerPtr->proc == proc)
		&& (handlerPtr->clientData == clientData)) {
	    break;
	}
    }

    /*
     * If Tk_HandleEvent is about to process this handler, tell it to
     * process the next one instead.
     */

    for (ipPtr = pendingPtr; ipPtr != NULL; ipPtr = ipPtr->nextPtr) {
	if (ipPtr->nextHandler == handlerPtr) {
	    ipPtr->nextHandler = handlerPtr->nextPtr;
	}
    }

    /*
     * Free resources associated with the handler.
     */

    if (prevPtr == NULL) {
	winPtr->handlerList = handlerPtr->nextPtr;
    } else {
	prevPtr->nextPtr = handlerPtr->nextPtr;
    }
    ckfree((char *) handlerPtr);


    /*
     * No need to call XSelectInput:  Tk always selects on all events
     * for all windows (needed to support bindings on classes and "all").
     */
}

/*--------------------------------------------------------------
 *
 * Tk_CreateGenericHandler --
 *
 *	Register a procedure to be called on each X event, regardless
 *	of display or window.  Generic handlers are useful for capturing
 *	events that aren't associated with windows, or events for windows
 *	not managed by Tk.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	From now on, whenever an X event is given to Tk_HandleEvent,
 *	invoke proc, giving it clientData and the event as arguments.
 *
 *--------------------------------------------------------------
 */

void
Tk_CreateGenericHandler(proc, clientData)
     Tk_GenericProc *proc;	/* Procedure to call on every event. */
     ClientData clientData;	/* One-word value to pass to proc. */
{
    GenericHandler *handlerPtr;
    
    handlerPtr = (GenericHandler *) ckalloc (sizeof (GenericHandler));
    
    handlerPtr->proc = proc;
    handlerPtr->clientData = clientData;
    handlerPtr->deleteFlag = 0;
    handlerPtr->nextPtr = NULL;
    if (genericList == NULL) {
	genericList = handlerPtr;
    } else {
	lastGenericPtr->nextPtr = handlerPtr;
    }
    lastGenericPtr = handlerPtr;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_DeleteGenericHandler --
 *
 *	Delete a previously-created generic handler.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	If there existed a handler as described by the parameters,
 *	that handler is logically deleted so that proc will not be
 *	invoked again.  The physical deletion happens in the event
 *	loop in Tk_HandleEvent.
 *
 *--------------------------------------------------------------
 */

void
Tk_DeleteGenericHandler(proc, clientData)
     Tk_GenericProc *proc;
     ClientData clientData;
{
    GenericHandler * handler;
    
    for (handler = genericList; handler; handler = handler->nextPtr) {
	if ((handler->proc == proc) && (handler->clientData == clientData)) {
	    handler->deleteFlag = 1;
	}
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_HandleEvent --
 *
 *	Given an event, invoke all the handlers that have
 *	been registered for the event.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on the handlers.
 *
 *--------------------------------------------------------------
 */

void
Tk_HandleEvent(eventPtr)
    XEvent *eventPtr;		/* Event to dispatch. */
{
    register TkEventHandler *handlerPtr;
    register GenericHandler *genericPtr;
    register GenericHandler *genPrevPtr;
    TkWindow *winPtr;
    register unsigned long mask;
    InProgress ip;
    Window handlerWindow;

    /*
     * First off, look for a special trigger event left around by the
     * grab module.  If it's found, call the grab module and discard
     * the event.
     */

    if ((eventPtr->xany.type == -1) && (eventPtr->xany.window == None)) {
	TkGrabTriggerProc(eventPtr);
	return;
    }

    /* 
     * Next, invoke all the generic event handlers (those that are
     * invoked for all events).  If a generic event handler reports that
     * an event is fully processed, go no further.
     */

    for (genPrevPtr = NULL, genericPtr = genericList;  genericPtr != NULL; ) {
	if (genericPtr->deleteFlag) {
	    if (!genericHandlersActive) {
		GenericHandler *tmpPtr;

		/*
		 * This handler needs to be deleted and there are no
		 * calls pending through the handler, so now is a safe
		 * time to delete it.
		 */

		tmpPtr = genericPtr->nextPtr;
		if (genPrevPtr == NULL) {
		    genericList = tmpPtr;
		} else {
		    genPrevPtr->nextPtr = tmpPtr;
		}
		if (tmpPtr == NULL) {
		    lastGenericPtr = genPrevPtr;
		}
		(void) ckfree((char *) genericPtr);
		genericPtr = tmpPtr;
		continue;
	    }
	} else {
	    int done;

	    genericHandlersActive++;
	    done = (*genericPtr->proc)(genericPtr->clientData, eventPtr);
	    genericHandlersActive--;
	    if (done) {
		return;
	    }
	}
	genPrevPtr = genericPtr;
	genericPtr = genPrevPtr->nextPtr;
    }

    /*
     * If the event is a MappingNotify event, find its display and
     * refresh the keyboard mapping information for the display.
     * After that there's nothing else to do with the event, so just
     * quit.
     */

    if (eventPtr->type == MappingNotify) {
	TkDisplay *dispPtr;

	for (dispPtr = tkDisplayList; dispPtr != NULL;
		dispPtr = dispPtr->nextPtr) {
	    if (dispPtr->display != eventPtr->xmapping.display) {
		continue;
	    }
	    XRefreshKeyboardMapping(&eventPtr->xmapping);
	    dispPtr->bindInfoStale = 1;
	    break;
	}
	return;
    }

    /*
     * Events selected by StructureNotify look the same as those
     * selected by SubstructureNotify;  the only difference is
     * whether the "event" and "window" fields are the same.
     * Check it out and convert StructureNotify to
     * SubstructureNotify if necessary.
     */

    handlerWindow = eventPtr->xany.window;
    mask = eventMasks[eventPtr->xany.type];
    if (mask == StructureNotifyMask) {
	if (eventPtr->xmap.event != eventPtr->xmap.window) {
	    mask = SubstructureNotifyMask;
	    handlerWindow = eventPtr->xmap.event;
	}
    }
    if (XFindContext(eventPtr->xany.display, handlerWindow,
	    tkWindowContext, (caddr_t *) &winPtr) != 0) {

	/*
	 * There isn't a TkWindow structure for this window.
	 * However, if the event is a PropertyNotify event then call
	 * the selection manager (it deals beneath-the-table with
	 * certain properties).
	 */

	if (eventPtr->type == PropertyNotify) {
	    TkSelPropProc(eventPtr);
	}
	return;
    }

    /*
     * Call focus-related code to look at FocusIn, FocusOut, Enter,
     * and Leave events;  depending on its return value, ignore the
     * event.
     */

    if ((mask & (FocusChangeMask|EnterWindowMask|LeaveWindowMask))
	    && !TkFocusFilterEvent(winPtr, eventPtr)) {
	return;
    }

    /*
     * Redirect KeyPress and KeyRelease events to the focus window,
     * or ignore them entirely if there is no focus window.  Map the
     * x and y coordinates to make sense in the context of the focus
     * window, if possible (make both -1 if the map-from and map-to
     * windows don't share the same screen).
     */

    if (mask & (KeyPressMask|KeyReleaseMask)) {
	TkWindow *focusPtr;
	int winX, winY, focusX, focusY;

	winPtr->dispPtr->lastEventTime = eventPtr->xkey.time;
	if (winPtr->mainPtr->focusPtr == NULL) {
	    return;
	}
	focusPtr = winPtr->mainPtr->focusPtr;
	if ((focusPtr->display != winPtr->display)
		|| (focusPtr->screenNum != winPtr->screenNum)) {
	    eventPtr->xkey.x = -1;
	    eventPtr->xkey.y = -1;
	} else {
	    Tk_GetRootCoords((Tk_Window) winPtr, &winX, &winY);
	    Tk_GetRootCoords((Tk_Window) focusPtr, &focusX, &focusY);
	    eventPtr->xkey.x -= focusX - winX;
	    eventPtr->xkey.y -= focusY - winY;
	}
	eventPtr->xkey.window = focusPtr->window;
	winPtr = focusPtr;
    }

    /*
     * Call a grab-related procedure to do special processing on
     * pointer events.
     */

    if (mask & (ButtonPressMask|ButtonReleaseMask|PointerMotionMask
	    |EnterWindowMask|LeaveWindowMask)) {
	if (mask & (ButtonPressMask|ButtonReleaseMask)) {
	    winPtr->dispPtr->lastEventTime = eventPtr->xbutton.time;
	} else if (mask & PointerMotionMask) {
	    winPtr->dispPtr->lastEventTime = eventPtr->xmotion.time;
	} else {
	    winPtr->dispPtr->lastEventTime = eventPtr->xcrossing.time;
	}
	if (TkPointerEvent(eventPtr, winPtr) == 0) {
	    return;
	}
    }

    /*
     * For events where it hasn't already been done, update the current
     * time in the display.
     */

    if (eventPtr->type == PropertyNotify) {
	winPtr->dispPtr->lastEventTime = eventPtr->xproperty.time;
    }

    /*
     * There's a potential interaction here with Tk_DeleteEventHandler.
     * Read the documentation for pendingPtr.
     */

    ip.eventPtr = eventPtr;
    ip.winPtr = winPtr;
    ip.nextHandler = NULL;
    ip.nextPtr = pendingPtr;
    pendingPtr = &ip;
    if (mask == 0) {
	if ((eventPtr->type == SelectionClear)
		|| (eventPtr->type == SelectionRequest)
		|| (eventPtr->type == SelectionNotify)) {
	    TkSelEventProc((Tk_Window) winPtr, eventPtr);
	} else if ((eventPtr->type == ClientMessage)
		&& (eventPtr->xclient.message_type ==
		    Tk_InternAtom((Tk_Window) winPtr, "WM_PROTOCOLS"))) {
	    TkWmProtocolEventProc(winPtr, eventPtr);
	}
    } else {
	for (handlerPtr = winPtr->handlerList; handlerPtr != NULL; ) {
	    if ((handlerPtr->mask & mask) != 0) {
		ip.nextHandler = handlerPtr->nextPtr;
		(*(handlerPtr->proc))(handlerPtr->clientData, eventPtr);
		handlerPtr = ip.nextHandler;
	    } else {
		handlerPtr = handlerPtr->nextPtr;
	    }
	}

	/*
	 * Pass the event to the "bind" command mechanism.  But, don't
	 * do this for SubstructureNotify events.  The "bind" command
	 * doesn't support them anyway, and it's easier to filter out
	 * these events here than in the lower-level procedures.
	 */

	if ((ip.winPtr != None) && (mask != SubstructureNotifyMask)) {
	    TkBindEventProc(winPtr, eventPtr);
	}
    }
    pendingPtr = ip.nextPtr;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CreateFileHandler --
 *
 *	Arrange for a given procedure to be invoked whenever
 *	a given file becomes readable or writable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	From now on, whenever the I/O channel given by fd becomes
 *	ready in the way indicated by mask, proc will be invoked.
 *	See the manual entry for details on the calling sequence
 *	to proc.  If fd is already registered then the old mask
 *	and proc and clientData values will be replaced with
 *	new ones.
 *
 *--------------------------------------------------------------
 */

void
Tk_CreateFileHandler(fd, mask, proc, clientData)
    int fd;			/* Integer identifier for stream. */
    int mask;			/* OR'ed combination of TK_READABLE,
				 * TK_WRITABLE, and TK_EXCEPTION:
				 * indicates conditions under which
				 * proc should be called.  TK_IS_DISPLAY
				 * indicates that this is a display and that
				 * clientData is the (Display *) for it,
				 * and that events should be handled
				 * automatically.*/
    Tk_FileProc *proc;		/* Procedure to call for each
				 * selected event. */
    ClientData clientData;	/* Arbitrary data to pass to proc. */
{
    register FileEvent *filePtr;
    int index;

    if (fd >= OPEN_MAX) {
	panic("Tk_CreatefileHandler can't handle file id %d", fd);
    }

    /*
     * Make sure the file isn't already registered.  Create a
     * new record in the normal case where there's no existing
     * record.
     */

    for (filePtr = fileList; filePtr != NULL;
	    filePtr = filePtr->nextPtr) {
	if (filePtr->fd == fd) {
	    break;
	}
    }
    index = fd/(NBBY*sizeof(fd_mask));
    if (filePtr == NULL) {
	filePtr = (FileEvent *) ckalloc(sizeof(FileEvent));
	filePtr->fd = fd;
	filePtr->isDisplay = 0;
	filePtr->readPtr = &ready[index];
	filePtr->writePtr = &ready[index+MASK_SIZE];
	filePtr->exceptPtr = &ready[index+2*MASK_SIZE];
	filePtr->mask = 1 << (fd%(NBBY*sizeof(fd_mask)));
	filePtr->nextPtr = fileList;
	fileList = filePtr;
    } else {
	if (masks[index] & filePtr->mask) {
	    readCount--;
	    *filePtr->readPtr &= ~filePtr->mask;
	    masks[index] &= ~filePtr->mask;
	}
	if (masks[index+MASK_SIZE] & filePtr->mask) {
	    writeCount--;
	    *filePtr->writePtr &= ~filePtr->mask;
	    masks[index+MASK_SIZE] &= ~filePtr->mask;
	}
	if (masks[index+2*MASK_SIZE] & filePtr->mask) {
	    exceptCount--;
	    *filePtr->exceptPtr &= ~filePtr->mask;
	    masks[index+2*MASK_SIZE] &= ~filePtr->mask;
	}
    }

    /*
     * The remainder of the initialization below is done
     * regardless of whether or not this is a new record
     * or a modification of an old one.
     */

    if (mask & TK_READABLE) {
	masks[index] |= filePtr->mask;
	readCount++;
    }
    readPtr = (readCount == 0) ? (fd_mask *) NULL : &ready[0];

    if (mask & TK_WRITABLE) {
	masks[index+MASK_SIZE] |= filePtr->mask;
	writeCount++;
    }
    writePtr = (writeCount == 0) ? (fd_mask *) NULL : &ready[MASK_SIZE];

    if (mask & TK_EXCEPTION) {
	masks[index+2*MASK_SIZE] |= filePtr->mask;
	exceptCount++;
    }
    exceptPtr = (exceptCount == 0) ? (fd_mask *) NULL : &ready[2*MASK_SIZE];

    if (mask & TK_IS_DISPLAY) {
	filePtr->isDisplay = 1;
    } else {
	filePtr->isDisplay = 0;
    }

    filePtr->proc = proc;
    filePtr->clientData = clientData;

    if (numFds <= fd) {
	numFds = fd+1;
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_DeleteFileHandler --
 *
 *	Cancel a previously-arranged callback arrangement for
 *	a file.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If a callback was previously registered on fd, remove it.
 *
 *--------------------------------------------------------------
 */

void
Tk_DeleteFileHandler(fd)
    int fd;			/* Stream id for which to remove
				 * callback procedure. */
{
    register FileEvent *filePtr;
    FileEvent *prevPtr;
    int index;

    /*
     * Find the entry for the given file (and return if there
     * isn't one).
     */

    for (prevPtr = NULL, filePtr = fileList; ;
	    prevPtr = filePtr, filePtr = filePtr->nextPtr) {
	if (filePtr == NULL) {
	    return;
	}
	if (filePtr->fd == fd) {
	    break;
	}
    }

    /*
     * Clean up information in the callback record.
     */

    index = filePtr->fd/(NBBY*sizeof(fd_mask));
    if (masks[index] & filePtr->mask) {
	readCount--;
	*filePtr->readPtr &= ~filePtr->mask;
	masks[index] &= ~filePtr->mask;
    }
    if (masks[index+MASK_SIZE] & filePtr->mask) {
	writeCount--;
	*filePtr->writePtr &= ~filePtr->mask;
	masks[index+MASK_SIZE] &= ~filePtr->mask;
    }
    if (masks[index+2*MASK_SIZE] & filePtr->mask) {
	exceptCount--;
	*filePtr->exceptPtr &= ~filePtr->mask;
	masks[index+2*MASK_SIZE] &= ~filePtr->mask;
    }
    if (prevPtr == NULL) {
	fileList = filePtr->nextPtr;
    } else {
	prevPtr->nextPtr = filePtr->nextPtr;
    }
    ckfree((char *) filePtr);

    /*
     * Recompute numFds.
     */

    numFds = 0;
    for (filePtr = fileList; filePtr != NULL;
	    filePtr = filePtr->nextPtr) {
	if (numFds <= filePtr->fd) {
	    numFds = filePtr->fd+1;
	}
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CreateTimerHandler --
 *
 *	Arrange for a given procedure to be invoked at a particular
 *	time in the future.
 *
 * Results:
 *	The return value is a token for the timer event, which
 *	may be used to delete the event before it fires.
 *
 * Side effects:
 *	When milliseconds have elapsed, proc will be invoked
 *	exactly once.
 *
 *--------------------------------------------------------------
 */

Tk_TimerToken
Tk_CreateTimerHandler(milliseconds, proc, clientData)
    int milliseconds;		/* How many milliseconds to wait
				 * before invoking proc. */
    Tk_TimerProc *proc;		/* Procedure to invoke. */
    ClientData clientData;	/* Arbitrary data to pass to proc. */
{
    register TimerEvent *timerPtr, *tPtr2, *prevPtr;
    static int id = 0;

    timerPtr = (TimerEvent *) ckalloc(sizeof(TimerEvent));

    /*
     * Compute when the event should fire.
     */

    (void) gettimeofday(&timerPtr->time, (struct timezone *) NULL);
    timerPtr->time.tv_sec += milliseconds/1000;
    timerPtr->time.tv_usec += (milliseconds%1000)*1000;
    if (timerPtr->time.tv_usec > 1000000) {
	timerPtr->time.tv_usec -= 1000000;
	timerPtr->time.tv_sec += 1;
    }

    /*
     * Fill in other fields for the event.
     */

    timerPtr->proc = proc;
    timerPtr->clientData = clientData;
    id++;
    timerPtr->token = (Tk_TimerToken) id;

    /*
     * Add the event to the queue in the correct position
     * (ordered by event firing time).
     */

    for (tPtr2 = timerQueue, prevPtr = NULL; tPtr2 != NULL;
	    prevPtr = tPtr2, tPtr2 = tPtr2->nextPtr) {
	if ((tPtr2->time.tv_sec > timerPtr->time.tv_sec)
		|| ((tPtr2->time.tv_sec == timerPtr->time.tv_sec)
		&& (tPtr2->time.tv_usec > timerPtr->time.tv_usec))) {
	    break;
	}
    }
    if (prevPtr == NULL) {
	timerPtr->nextPtr = timerQueue;
	timerQueue = timerPtr;
    } else {
	timerPtr->nextPtr = prevPtr->nextPtr;
	prevPtr->nextPtr = timerPtr;
    }
    return timerPtr->token;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_DeleteTimerHandler --
 *
 *	Delete a previously-registered timer handler.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Destroy the timer callback identified by TimerToken,
 *	so that its associated procedure will not be called.
 *	If the callback has already fired, or if the given
 *	token doesn't exist, then nothing happens.
 *
 *--------------------------------------------------------------
 */

void
Tk_DeleteTimerHandler(token)
    Tk_TimerToken token;	/* Result previously returned by
				 * Tk_DeleteTimerHandler. */
{
    register TimerEvent *timerPtr, *prevPtr;

    for (timerPtr = timerQueue, prevPtr = NULL; timerPtr != NULL;
	    prevPtr = timerPtr, timerPtr = timerPtr->nextPtr) {
	if (timerPtr->token != token) {
	    continue;
	}
	if (prevPtr == NULL) {
	    timerQueue = timerPtr->nextPtr;
	} else {
	    prevPtr->nextPtr = timerPtr->nextPtr;
	}
	ckfree((char *) timerPtr);
	return;
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_DoWhenIdle --
 *
 *	Arrange for proc to be invoked the next time the
 *	system is idle (i.e., just before the next time
 *	that Tk_DoOneEvent would have to wait for something
 *	to happen).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Proc will eventually be called, with clientData
 *	as argument.  See the manual entry for details.
 *
 *--------------------------------------------------------------
 */

void
Tk_DoWhenIdle(proc, clientData)
    Tk_IdleProc *proc;		/* Procedure to invoke. */
    ClientData clientData;	/* Arbitrary value to pass to proc. */
{
    register IdleHandler *idlePtr;

    idlePtr = (IdleHandler *) ckalloc(sizeof(IdleHandler));
    idlePtr->proc = proc;
    idlePtr->clientData = clientData;
    idlePtr->generation = idleGeneration;
    idlePtr->nextPtr = NULL;
    if (lastIdlePtr == NULL) {
	idleList = idlePtr;
    } else {
	lastIdlePtr->nextPtr = idlePtr;
    }
    lastIdlePtr = idlePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_CancelIdleCall --
 *
 *	If there are any when-idle calls requested to a given procedure
 *	with given clientData, cancel all of them.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If the proc/clientData combination were on the when-idle list,
 *	they are removed so that they will never be called.
 *
 *----------------------------------------------------------------------
 */

void
Tk_CancelIdleCall(proc, clientData)
    Tk_IdleProc *proc;		/* Procedure that was previously registered. */
    ClientData clientData;	/* Arbitrary value to pass to proc. */
{
    register IdleHandler *idlePtr, *prevPtr;
    IdleHandler *nextPtr;

    for (prevPtr = NULL, idlePtr = idleList; idlePtr != NULL;
	    prevPtr = idlePtr, idlePtr = idlePtr->nextPtr) {
	while ((idlePtr->proc == proc)
		&& (idlePtr->clientData == clientData)) {
	    nextPtr = idlePtr->nextPtr;
	    ckfree((char *) idlePtr);
	    idlePtr = nextPtr;
	    if (prevPtr == NULL) {
		idleList = idlePtr;
	    } else {
		prevPtr->nextPtr = idlePtr;
	    }
	    if (idlePtr == NULL) {
		lastIdlePtr = prevPtr;
		return;
	    }
	}
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_DoOneEvent --
 *
 *	Process a single event of some sort.  If there's no
 *	work to do, wait for an event to occur, then process
 *	it.
 *
 * Results:
 *	The return value is 1 if the procedure actually found
 *	an event to process.  If no event was found then 0 is
 *	returned.
 *
 * Side effects:
 *	May delay execution of process while waiting for an
 *	X event, X error, file-ready event, or timer event.
 *	The handling of the event could cause additional
 *	side effects.  Collapses sequences of mouse-motion
 *	events for the same window into a single event by
 *	delaying motion event processing.
 *
 *--------------------------------------------------------------
 */
    static int eventDelayed = 0;	/* Non-zero means there is an event
					 * in delayedMotionEvent. */

int
Tk_DoOneEvent(flags)
    int flags;			/* Miscellaneous flag values:  may be any
				 * combination of TK_DONT_WAIT, TK_X_EVENTS,
				 * TK_FILE_EVENTS, TK_TIMER_EVENTS, and
				 * TK_IDLE_EVENTS. */
{
    register FileEvent *filePtr;
    struct timeval curTime, timeout, *timeoutPtr;
    int numFound;
    static XEvent delayedMotionEvent;	/* Used to hold motion events that
					 * are being saved until later. */

    if ((flags & TK_ALL_EVENTS) == 0) {
	flags |= TK_ALL_EVENTS;
    }

    /*
     * Phase One: see if there's already something ready
     * (either a file or a display) that was left over
     * from before (i.e don't do a select, just check the
     * bits from the last select).
     */

    checkFiles:
    if (tcl_AsyncReady) {
	(void) Tcl_AsyncInvoke((Tcl_Interp *) NULL, 0);
	return 1;
    }
    for (filePtr = fileList; filePtr != NULL;
	    filePtr = filePtr->nextPtr) {
	int mask;

	/*
	 * Displays:  flush output, check for queued events,
	 * and read events from the server if display is ready.
	 * If there are any events, process one and then
	 * return.
	 */

	if (filePtr->isDisplay) {
	    Display *display = (Display *) filePtr->clientData;
	    XEvent event;

	    if (!(flags & TK_X_EVENTS)) {
		continue;
	    }
	    XFlush(display);
	    if ((*filePtr->readPtr) & filePtr->mask) {
		*filePtr->readPtr &= ~filePtr->mask;
		if (XEventsQueued(display, QueuedAfterReading) == 0) {

		    /*
		     * Things are very tricky if there aren't any events
		     * readable at this point (after all, there was
		     * supposedly data available on the connection).
		     * A couple of things could have occurred:
		     * 
		     * One possibility is that there were only error events
		     * in the input from the server.  If this happens,
		     * we should return (we don't want to go to sleep
		     * in XNextEvent below, since this would block out
		     * other sources of input to the process).
		     *
		     * Another possibility is that our connection to the
		     * server has been closed.  This will not necessarily
		     * be detected in XEventsQueued (!!), so if we just
		     * return then there will be an infinite loop.  To
		     * detect such an error, generate a NoOp protocol
		     * request to exercise the connection to the server,
		     * then return.  However, must disable SIGPIPE while
		     * sending the event, or else the process will die
		     * from the signal and won't invoke the X error
		     * function to print a nice message.
		     */

		    void (*oldHandler)();

		    oldHandler = (void (*)()) signal(SIGPIPE, SIG_IGN);
		    XNoOp(display);
		    XFlush(display);
		    (void) signal(SIGPIPE, oldHandler);
		    return 1;
		}
		if (restrictProc != NULL) {
		    if (!XCheckIfEvent(display, &event, restrictProc,
			    restrictArg)) {
			return 1;
		    }
		} else {
		    XNextEvent(display, &event);
		}
	    } else {
		if (QLength(display) == 0) {
		    continue;
		}
		if (restrictProc != NULL) {
		    if (!XCheckIfEvent(display, &event, restrictProc,
			    restrictArg)) {
			continue;
		    }
		} else {
		    XNextEvent(display, &event);
		}
	    }

	    /*
	     * Got an event.  Deal with mouse-motion-collapsing and
	     * event-delaying here.  If there's already an event delayed,
	     * then process that event if it's incompatible with the new
	     * event (new event not mouse motion, or window changed, or
	     * state changed).  If the new event is mouse motion, then
	     * don't process it now;  delay it until later in the hopes
	     * that it can be merged with other mouse motion events
	     * immediately following.
	     */

	    if (tkEventDebug) {
		eventTrace[traceIndex] = event;
		traceIndex = (traceIndex+1) % TK_NEVENTS;
	    }

	    if (eventDelayed) {
		if (((event.type != MotionNotify)
			    && (event.type != GraphicsExpose)
			    && (event.type != NoExpose)
			    && (event.type != Expose))
			|| (event.xmotion.display
			    != delayedMotionEvent.xmotion.display)
			|| (event.xmotion.window
			    != delayedMotionEvent.xmotion.window)) {
		    XEvent copy;

		    /*
		     * Must copy the event out of delayedMotionEvent before
		     * processing it, in order to allow recursive calls to
		     * Tk_DoOneEvent as part of the handler.
		     */

		    copy = delayedMotionEvent;
		    eventDelayed = 0;
		    Tk_HandleEvent(&copy);
		}
	    }
	    if (event.type == MotionNotify) {
		delayedMotionEvent = event;
		eventDelayed = 1;
	    } else {
		Tk_HandleEvent(&event);
	    }
	    return 1;
	}

	/*
	 * Not a display:  if the file is ready, call the
	 * appropriate handler.
	 */

	if (((*filePtr->readPtr | *filePtr->writePtr
		| *filePtr->exceptPtr) & filePtr->mask) == 0) {
	    continue;
	}
	if (!(flags & TK_FILE_EVENTS)) {
	    continue;
	}
	mask = 0;
	if (*filePtr->readPtr & filePtr->mask) {
	    mask |= TK_READABLE;
	    *filePtr->readPtr &= ~filePtr->mask;
	}
	if (*filePtr->writePtr & filePtr->mask) {
	    mask |= TK_WRITABLE;
	    *filePtr->writePtr &= ~filePtr->mask;
	}
	if (*filePtr->exceptPtr & filePtr->mask) {
	    mask |= TK_EXCEPTION;
	    *filePtr->exceptPtr &= ~filePtr->mask;
	}
	(*filePtr->proc)(filePtr->clientData, mask);
	return 1;
    }

    /*
     * Phase Two: get the current time and see if any timer
     * events are ready to fire.  If so, fire one and return.
     */

    checkTime:
    if ((timerQueue != NULL) && (flags & TK_TIMER_EVENTS)) {
	register TimerEvent *timerPtr = timerQueue;

	(void) gettimeofday(&curTime, (struct timezone *) NULL);
	if ((timerPtr->time.tv_sec < curTime.tv_sec)
		|| ((timerPtr->time.tv_sec == curTime.tv_sec)
		&&  (timerPtr->time.tv_usec < curTime.tv_usec))) {
	    timerQueue = timerPtr->nextPtr;
	    (*timerPtr->proc)(timerPtr->clientData);
	    ckfree((char *) timerPtr);
	    return 1;
	}
    }


    /*
     * Phase Three: if there is a delayed motion event, process it
     * now, before any DoWhenIdle handlers.  Better to process before
     * idle handlers than after, because the goal of idle handlers is
     * to delay until after all pending events have been processed.
     * Must free up delayedMotionEvent *before* calling Tk_HandleEvent,
     * so that the event handler can call Tk_DoOneEvent recursively
     * without infinite looping.
     */

    if ((eventDelayed) && (flags & TK_X_EVENTS)) {
	XEvent copy;

	copy = delayedMotionEvent;
	eventDelayed = 0;
	Tk_HandleEvent(&copy);
	return 1;
    }

    /*
     * Phase Four: if there are DoWhenIdle requests pending (or
     * if we're not allowed to block), then do a select with an
     * instantaneous timeout.  If a ready file is found, then go
     * back to process it.
     */

    if (((idleList != NULL) && (flags & TK_IDLE_EVENTS))
	    || (flags & TK_DONT_WAIT)) {
	if (flags & (TK_X_EVENTS|TK_FILE_EVENTS)) {
	    memcpy((VOID *) ready, (VOID *) masks,
		    3*MASK_SIZE*sizeof(fd_mask));
	    timeout.tv_sec = timeout.tv_usec = 0;
	    numFound = select(numFds, (SELECT_MASK *) readPtr,
		    (SELECT_MASK *) writePtr, (SELECT_MASK *) exceptPtr,
		    &timeout);
	    if (numFound == -1) {
		/*
		 * Some systems don't clear the masks after an error, so
		 * we have to do it here.
		 */

		memset((VOID *) ready, 0, 3*MASK_SIZE*sizeof(fd_mask));
	    }
	    if ((numFound > 0) || ((numFound == -1) && (errno == EINTR))) {
		goto checkFiles;
	    }
	}
    }

    /*
     * Phase Five:  process all pending DoWhenIdle requests.
     */

    if ((idleList != NULL) && (flags & TK_IDLE_EVENTS)) {
	register IdleHandler *idlePtr;
	int oldGeneration;

	oldGeneration = idleList->generation;
	idleGeneration++;

	/*
	 * The code below is trickier than it may look, for the following
	 * reasons:
	 *
	 * 1. New handlers can get added to the list while the current
	 *    one is being processed.  If new ones get added, we don't
	 *    want to process them during this pass through the list (want
	 *    to check for other work to do first).  This is implemented
	 *    using the generation number in the handler:  new handlers
	 *    will have a different generation than any of the ones currently
	 *    on the list.
	 * 2. The handler can call Tk_DoOneEvent, so we have to remove
	 *    the hander from the list before calling it. Otherwise an
	 *    infinite loop could result.
	 * 3. Tk_CancelIdleCall can be called to remove an element from
	 *    the list while a handler is executing, so the list could
	 *    change structure during the call.
	 */

	for (idlePtr = idleList;
		((idlePtr != NULL) && (idlePtr->generation == oldGeneration));
		idlePtr = idleList) {
	    idleList = idlePtr->nextPtr;
	    if (idleList == NULL) {
		lastIdlePtr = NULL;
	    }
	    (*idlePtr->proc)(idlePtr->clientData);
	    ckfree((char *) idlePtr);
	}
	return 1;
    }

    /*
     * Phase Six: do a select to wait for either one of the
     * files to become ready or for the first timer event to
     * fire.  Then go back to process the event.
     */

    if ((flags & TK_DONT_WAIT)
	    || !(flags & (TK_TIMER_EVENTS|TK_FILE_EVENTS|TK_X_EVENTS))) {
	return 0;
    }
    if ((timerQueue == NULL) || !(flags & TK_TIMER_EVENTS)) {
	timeoutPtr = NULL;
    } else {
	timeoutPtr = &timeout;
	timeout.tv_sec = timerQueue->time.tv_sec - curTime.tv_sec;
	timeout.tv_usec = timerQueue->time.tv_usec - curTime.tv_usec;
	if (timeout.tv_usec < 0) {
	    timeout.tv_sec -= 1;
	    timeout.tv_usec += 1000000;
	}
    }
    memcpy((VOID *) ready, (VOID *) masks, 3*MASK_SIZE*sizeof(fd_mask));
    numFound = select(numFds, (SELECT_MASK *) readPtr,
	    (SELECT_MASK *) writePtr, (SELECT_MASK *) exceptPtr,
	    timeoutPtr);
    if (numFound == -1) {
	/*
	 * Some systems don't clear the masks after an error, so
	 * we have to do it here.
	 */

	memset((VOID *) ready, 0, 3*MASK_SIZE*sizeof(fd_mask));
    }
    if (numFound == 0) {
	goto checkTime;
    }
    goto checkFiles;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_MainLoop --
 *
 *	Call Tk_DoOneEvent over and over again in an infinite
 *	loop as long as there exist any main windows.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Arbitrary;  depends on handlers for events.
 *
 *--------------------------------------------------------------
 */

void
Tk_MainLoop()
{
    while (tk_NumMainWindows > 0) {
	Tk_DoOneEvent(0);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_Sleep --
 *
 *	Delay execution for the specified number of milliseconds.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Time passes.
 *
 *----------------------------------------------------------------------
 */

void
Tk_Sleep(ms)
    int ms;			/* Number of milliseconds to sleep. */
{
    static struct timeval delay;

    delay.tv_sec = ms/1000;
    delay.tv_usec = (ms%1000)*1000;
    (void) select(0, (SELECT_MASK *) 0, (SELECT_MASK *) 0,
	    (SELECT_MASK *) 0, &delay);
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_RestrictEvents --
 *
 *	This procedure is used to globally restrict the set of events
 *	that will be dispatched.  The restriction is done by filtering
 *	all incoming X events through a procedure that determines
 *	whether they are to be processed immediately or deferred.
 *
 * Results:
 *	The return value is the previous restriction procedure in effect,
 *	if there was one, or NULL if there wasn't.
 *
 * Side effects:
 *	From now on, proc will be called to determine whether to process
 *	or defer each incoming X event.
 *
 *----------------------------------------------------------------------
 */

Tk_RestrictProc *
Tk_RestrictEvents(proc, arg, prevArgPtr)
    Tk_RestrictProc *proc;	/* X "if" procedure to call for each
				 * incoming event.  See "XIfEvent" doc.
				 * for details. */
    char *arg;			/* Arbitrary argument to pass to proc. */
    char **prevArgPtr;		/* Place to store information about previous
				 * argument. */
{
    Bool (*prev)  _ANSI_ARGS_((Display *display, XEvent *eventPtr, char *arg));

    prev = restrictProc;
    *prevArgPtr = restrictArg;
    restrictProc = proc;
    restrictArg = arg;
    return prev;
}

/*
 *--------------------------------------------------------------
 *
 * TkEventDeadWindow --
 *
 *	This procedure is invoked when it is determined that
 *	a window is dead.  It cleans up event-related information
 *	about the window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Various things get cleaned up and recycled.
 *
 *--------------------------------------------------------------
 */

void
TkEventDeadWindow(winPtr)
    TkWindow *winPtr;		/* Information about the window
				 * that is being deleted. */
{
    register TkEventHandler *handlerPtr;
    register InProgress *ipPtr;

    /*
     * While deleting all the handlers, be careful to check for
     * Tk_HandleEvent being about to process one of the deleted
     * handlers.  If it is, tell it to quit (all of the handlers
     * are being deleted).
     */

    while (winPtr->handlerList != NULL) {
	handlerPtr = winPtr->handlerList;
	winPtr->handlerList = handlerPtr->nextPtr;
	for (ipPtr = pendingPtr; ipPtr != NULL; ipPtr = ipPtr->nextPtr) {
	    if (ipPtr->nextHandler == handlerPtr) {
		ipPtr->nextHandler = NULL;
	    }
	    if (ipPtr->winPtr == winPtr) {
		ipPtr->winPtr = None;
	    }
	}
	ckfree((char *) handlerPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkCurrentTime --
 *
 *	Try to deduce the current time.  "Current time" means the time
 *	of the event that led to the current code being executed, which
 *	means the time in the most recently-nested invocation of
 *	Tk_HandleEvent.
 *
 * Results:
 *	The return value is the time from the current event, or
 *	CurrentTime if there is no current event or if the current
 *	event contains no time.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Time
TkCurrentTime(dispPtr)
    TkDisplay *dispPtr;		/* Display for which the time is desired. */
{
    register XEvent *eventPtr;

    if (pendingPtr == NULL) {
	return dispPtr->lastEventTime;
    }
    eventPtr = pendingPtr->eventPtr;
    switch (eventPtr->type) {
	case ButtonPress:
	case ButtonRelease:
	    return eventPtr->xbutton.time;
	case KeyPress:
	case KeyRelease:
	    return eventPtr->xkey.time;
	case MotionNotify:
	    return eventPtr->xmotion.time;
	case EnterNotify:
	case LeaveNotify:
	    return eventPtr->xcrossing.time;
	case PropertyNotify:
	    return eventPtr->xproperty.time;
    }
    return dispPtr->lastEventTime;
}

/* TCL */
int
mged_tk_dontwait()
{
	if( eventDelayed || timerQueue || idleList )  return 1;
	return 0;
}

#endif
@


10.55
log
@Removed controversial prototype
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.54 94/12/28 12:24:46 gdurf Exp Locker: gdurf $ (BRL)";
d891 1
a891 1
	char	buf[512];
d942 1
a942 1
        	rt_log(buf, "info commands %s", ftp->ft_name);
d1118 1
d1120 1
d1528 1
a1528 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.54 94/12/28 12:24:46 gdurf Exp Locker: gdurf $ SPRITE (Berkeley)";
d1531 2
a1532 2
#include "/m/tcl/tk3.6/tkConfig.h"
#include "/m/tcl/tk3.6/tkInt.h"
@


10.54
log
@Removed controversial assignment
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.53 94/12/28 12:20:08 gdurf Exp Locker: gdurf $ (BRL)";
d704 1
a704 1
			interp->freeProc = (void (*)(char *))free;
d1526 1
a1526 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.53 94/12/28 12:20:08 gdurf Exp Locker: gdurf $ SPRITE (Berkeley)";
@


10.53
log
@Removed long filename for tcl,tk incldes
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.52 94/12/28 11:02:45 gdurf Exp Locker: gdurf $ (BRL)";
a621 1
	int ret;
d624 1
a624 1
	ret = sprintf(buf, ".i.f.text insert insert \"%s\"", str);
d629 1
a629 1
	return ret;
d1526 1
a1526 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.52 94/12/28 11:02:45 gdurf Exp Locker: gdurf $ SPRITE (Berkeley)";
@


10.52
log
@Added knob feedback
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.51 94/12/27 22:59:16 mike Exp Locker: gdurf $ (BRL)";
d50 2
a51 2
#  include "/usr/brl/include/tcl.h"
#  include "/usr/brl/include/tk.h"
d1527 1
a1527 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.51 94/12/27 22:59:16 mike Exp Locker: gdurf $ SPRITE (Berkeley)";
@


10.51
log
@Eliminated dead variables.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.50 94/12/27 22:58:34 gdurf Exp Locker: mike $ (BRL)";
d36 3
a61 1

d64 1
d88 1
d194 1
a194 1
	f_history, 1, 2,
d391 2
d396 2
d413 1
a413 1
			rt_vls_printf( &timing, "delay %ld %ld\n",
d417 1
a417 1
			rt_vls_printf( &timing, "delay %ld %ld\n",
d423 4
d443 1
d447 3
d479 1
d483 2
a484 1
 * 	Uses select to delay for the specified amount of time.
d501 1
d505 1
a505 1
 *	Prints out the command history. 
d513 31
a543 6
	if( argc == 2 )
		if( strcmp(argv[1], "-delays") == 0 )
			rt_log( rt_vls_addr(&replay_history) );
		else {
			rt_log( "history: invalid option %s\n", argv[1] );
			return CMD_BAD;
d545 3
a547 2
	else
		rt_log( rt_vls_addr(&history) );
d549 7
d559 1
d725 1
a725 1
	;
d728 3
d732 11
d744 1
a744 1
 *	S A V E _ H I S T O R Y
d746 2
a747 1
 *	Saves the history to the given filename.
d751 1
a751 1
save_history( clientData, interp, argc, argv )
d757 1
a757 1
	FILE *fp;
d759 2
a760 3
	if( argc < 3 ) {
		rt_log("save_history: Usage: %s history|replay_history fileName\n", argv[0]);
		interp->result = "save_history: Insufficient args";
d764 46
a809 4
	fp = fopen( argv[2], "a+" );
	if( fp == NULL ) {
		rt_log("save_history: Error opening file\n");
		interp->result = "save_history: Error opening file";
d812 1
d814 32
a845 4
	if( strcmp( argv[1], "history" )==0 ) {
		fprintf( fp, "%s", rt_vls_addr(&history) );
	} else if( strcmp( argv[1], "replay_history" )==0 ) {
		fprintf( fp, "%s", rt_vls_addr(&replay_history) );
d848 1
a848 2
	fclose( fp );
	return TCL_OK;
d868 4
a871 2
	Tcl_CreateCommand(interp, "save_history", save_history,
			  (ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
d985 1
d1527 1
a1527 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.50 94/12/27 22:58:34 gdurf Exp Locker: mike $ SPRITE (Berkeley)";
@


10.50
log
@More history support
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.49 94/12/27 18:00:27 gdurf Exp Locker: gdurf $ (BRL)";
a1074 1
	struct rt_vls str;
a1220 1
	register int	i;
d1387 1
a1387 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.49 94/12/27 18:00:27 gdurf Exp Locker: gdurf $ SPRITE (Berkeley)";
@


10.49
log
@Added some journaling features
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.48 94/12/23 23:48:04 gdurf Exp Locker: gdurf $ (BRL)";
d75 1
d141 2
d189 2
a389 2
 * 	Note that this function uses different times for the calculating 
 *	the time delta and the current time.
d405 1
a405 1
			rt_vls_printf( &timing, "delay %d %d\n",
d409 1
a409 1
			rt_vls_printf( &timing, "delay %d %d\n",
d415 1
a415 1
	if( journalfp != NULL ) {
d426 1
d456 1
d463 44
d751 1
d754 1
d936 3
a938 1
			if (result != CMD_MORE)
d940 7
a946 1
			else
d948 2
d955 3
a957 1
				history_record( &hadd, &start, &finish );
d1389 1
a1389 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.48 94/12/23 23:48:04 gdurf Exp Locker: gdurf $ SPRITE (Berkeley)";
@


10.48
log
@Converted strlen to rt_vls_strlen
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.47 94/12/23 23:31:07 mike Exp Locker: gdurf $ (BRL)";
d65 2
d72 3
d200 2
d382 76
a522 2
	old = interp->result; 

a527 2
	interp->result = old;

d532 1
d547 1
a547 1
	static struct rt_vls argstr;
d549 2
d554 1
d557 1
d560 2
d570 5
a574 1
	switch ( Tcl_Eval(interp, rt_vls_addr(&argstr)) ) {
d580 1
a580 1
			rt_vls_vlscat( &history, &argstr );
d586 2
a587 2
			rt_vls_strcat( &history, "# " );
			rt_vls_vlscat( &history, &argstr );
d598 2
a599 2
			rt_vls_strcat( &history, "# " );
			rt_vls_vlscat( &history, &argstr );
d612 3
d616 11
d642 3
a644 3
	if( argc < 2 ) {
		rt_log("save_history: Need a filename\n");
		interp->result = "save_history: Need a filename";
d648 1
a648 1
	fp = fopen( argv[1], "a+" );
d655 5
a659 1
	fprintf( fp, "%s", rt_vls_addr(&history) );	
a664 3
/*
 *	C M D _ P R E V
 */
a665 10
int
cmd_prev( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	;
}

d684 1
d690 1
d708 5
d811 1
d813 2
d825 1
d838 2
d841 1
a841 1
		while (1) {
d843 1
d845 7
a851 3
			if (result == TCL_OK) {
				if (strcmp(interp->result, "MGED_Ok") != 0
					&& interp->result[0] != '\0') {
d855 2
a856 6
				break;  /* XXX Record, later */
			}
			if (result == TCL_ERROR && 
			    strcmp(interp->result, "MGED_Error") != 0 &&
			    strcmp(interp->result, "MGED_More") != 0) {
				rt_log("%s\n", interp->result);
d858 20
a877 4
			}
			if (strcmp(interp->result, "MGED_Error") == 0)  {
				/* Silent error (we already printed out the
				   error message) */
d879 1
a880 5
			if (strcmp(interp->result, "MGED_More") != 0) {
				/* Some TCL error of some sort. */
			rt_log("%s\n", interp->result);
				break;
			}
d882 7
a888 2
			if (mged_cmd(argc, argv, funtab) != CMD_MORE)
				break;
d891 7
a919 2
		rt_vls_free( &cmd );
		rt_vls_free( &cmd_buf );
d922 3
d1326 1
a1326 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.47 94/12/23 23:31:07 mike Exp Locker: gdurf $ SPRITE (Berkeley)";
@


10.47
log
@Added a new one.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.46 94/12/23 23:25:33 gdurf Exp Locker: mike $ (BRL)";
d476 1
a476 1
	if( strlen(rt_vls_addr(&argstr)) > 0 ) {
d478 1
a478 1
		rt_vls_trunc( &argstr, strlen(rt_vls_addr(&argstr))-1 );
d489 1
a489 1
		if( strlen(rt_vls_addr(&argstr)) > 1 )
d772 1
a772 1
			rt_vls_trunc( &cmd, strlen(rt_vls_addr(&cmd))-1 );
d1192 1
a1192 1
static char rcsid[] = "$Header: /m/cad/mged/RCS/cmd.c,v 10.46 94/12/23 23:25:33 gdurf Exp Locker: mike $ SPRITE (Berkeley)";
@


10.46
log
@Merged Tcl code
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged-tcl/RCS/cmd.c,v 10.30 94/08/11 22:40:46 mike Exp Locker: mike $ (BRL)";
d58 2
d221 2
d1192 1
a1192 1
static char rcsid[] = "$Header: /m/cad/mged-tcl/RCS/cmd.c,v 10.30 94/08/11 22:40:46 mike Exp Locker: mike $ SPRITE (Berkeley)";
@


10.45
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@a4 2


d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.44 1994/12/05 13:59:52 mike Exp gdurf $ (BRL)";
d45 6
d60 2
d63 3
a65 2
/* XXX Move to ged.h */
MGED_EXTERN(int f_shader, (int argc, char **argv));
d67 2
d109 4
d115 1
d169 4
d301 4
d307 1
d310 4
d316 1
d323 1
d326 1
d371 1
d373 27
d401 1
a401 1
cmd_setup()
d403 1
a403 1
	return;
d406 261
d702 1
d724 1
a724 1
		
d727 1
d729 28
a756 1
		while (i == 0) {
d759 1
d773 1
d776 1
a776 1

d874 1
d1021 1
d1148 1
a1148 1
		rt_log( i==1 ? "%s" : " %s", argv[i]);
d1150 1
a1150 1
	rt_log( "\n");
d1154 1716
@


10.44
log
@Closed bug #212
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.43 94/11/22 12:27:32 jra Exp Locker: mike $ (BRL)";
d475 1
a475 1
		(void)printf("!\n");
d496 1
a496 1
				(void)printf("More than %d arguments, excess flushed\n", MAXARGS);
d526 1
a526 1
		(void)printf("no command entered, type '%s?' for help\n",
d549 1
a549 1
				printf("mged_cmd(): Invalid return from %s\n",
d585 1
a585 1
	(void)printf("!\n");
d672 1
a672 1
		(void)printf("The following commands are available:\n");
d707 1
a707 1
		(void)printf("The following %scommands are available:\n",
d758 1
a758 1
			(void)printf("summary:  S R or G are only valid parmaters\n");
d796 1
a796 1
		fprintf(stdout, i==1 ? "%s" : " %s", argv[i]);
d798 1
a798 1
	fprintf(stdout, "\n");
@


10.43
log
@Added NMG's to make command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.42 94/11/15 15:31:12 mike Exp Locker: jra $ (BRL)";
d653 2
d659 1
@


10.42
log
@Added args to IN command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.41 94/11/14 17:18:06 mike Exp Locker: mike $ (BRL)";
d197 1
a197 1
"make", "name <arb8|sph|ellg|tor|tgc|rpc|rhc|epa|ehy|eto|part|grip|half>", "create a primitive",
@


10.41
log
@Added f_shader
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.40 94/11/07 16:04:16 jra Exp Locker: mike $ (BRL)";
d167 1
a167 1
"in", "", "keyboard entry of solids",
@


10.40
log
@Added parameters to funtab entry for copyeval.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.39 94/11/05 03:50:20 mike Exp Locker: jra $ (BRL)";
d57 3
d289 2
@


10.39
log
@Irix 6
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.38 94/10/06 13:03:26 jra Exp Locker: mike $ (BRL)";
d99 2
a100 1
"copyeval", "", "copy an 'evaluated' path solid",
@


10.38
log
@Added ERIM solids, part, and half to make command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.37 94/09/28 15:45:22 mike Exp Locker: jra $ (BRL)";
a376 1
	int  	result;
a517 1
	struct rt_vls str;
a660 1
	register int	i;
@


10.37
log
@Expanded help message for CONCAT command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.36 94/09/24 02:32:54 mike Exp Locker: mike $ (BRL)";
d193 1
a193 1
"make", "name <arb8|sph|ellg|tor|tgc>", "create a primitive",
@


10.36
log
@Added Mosaic hack.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.35 94/08/27 03:22:55 mike Exp Locker: mike $ (BRL)";
d97 1
a97 1
"concat", "file [prefix]", "concatenate 'file' onto end of present database",
d99 1
a99 1
"copyeval", "", "copys an 'evaluated' path solid",
@


10.35
log
@Documented -f flag on KILL command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.34 94/08/19 16:12:46 pjt Exp Locker: mike $ (BRL)";
d649 4
@


10.34
log
@Implemented qorot command
and made orot a synonym for rotobj
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.33 94/08/19 10:14:25 pjt Exp Locker: pjt $ (BRL)";
d175 1
a175 1
"kill", "<objects>", "delete objects from file",
d177 1
a177 1
"killall", "object[s]", "kill object[s] and all references",
d179 1
a179 1
"killtree", "object[s]", "kill complete tree[s] - BE CAREFUL",
@


10.33
log
@Cleaned up qvrot command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.32 94/08/17 16:16:27 pjt Exp Locker: pjt $ (BRL)";
d213 2
d243 2
@


10.32
log
@Implemented qvrot command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.31 1994/08/09 18:03:41 gdurf Exp $ (BRL)";
d241 1
a241 1
"qvrot", "dx dy dz theta", "Set view direction from quaternion",
@


10.31
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.30 1994/08/09 11:47:00 pjt Exp gdurf $ (BRL)";
d241 2
@


10.30
log
@Enhanced 'source' command so it now reads
from a pipe, too.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.29 94/08/09 10:26:09 pjt Exp $ (BRL)";
d28 2
d33 3
a35 1
#ifdef BSD
a36 2
#else
#include <string.h>
a386 3
#ifdef BSD
		ep = index( cp, '\n' );
#else
a387 1
#endif
@


10.29
log
@Implemented the 'source' command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/cmd.c,v 10.28 1994/06/24 20:10:36 gdurf Exp gdurf $ (BRL)";
d281 2
a282 2
"source", "file", "read and process file of commands",
	f_source, 2,2,
@


10.28
log
@Added cmd_setup()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.27 1994/06/13 19:09:05 gdurf Exp gdurf $ (BRL)";
d281 2
@


10.27
log
@Modified to use new command return codes
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.26 1994/04/20 09:49:43 jra Exp gdurf $ (BRL)";
d325 6
@


10.26
log
@Added -t option to facetize command
@
text
@d5 2
a6 2
 *	cmdline		Process commands typed on the keyboard
 *	parse_line	Parse command line into argument vector
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.25 94/04/05 17:11:44 cjohnson Exp Locker: jra $ (BRL)";
a47 1
int	maxargs = MAXARGS;	/* For dir.c */
a48 2
int	numargs;		/* number of args */
char	*cmd_args[MAXARGS+2];	/* array of pointers to args */
d52 2
a53 49
static void	f_help(), f_fhelp(), f_comm();
void	f_labelvert();
void	f_red();
void	f_pov();
void	f_vrmgr();
void	f_echo();
void	f_param();
void	mged_cmd();
void	f_center(), f_press(), f_view(), f_blast();
void	f_edit(), f_evedit(), f_delobj(), f_hideline();
void	f_debug(), f_regdebug(), f_debuglib(), f_debugmem();
void	f_name(), f_copy(), f_instance();
void	f_copy_inv(), f_killall(), f_killtree();
void	f_region(), f_itemair(), f_mater(), f_kill(), f_list(), f_cat();
void	f_zap(), f_group(), f_mirror(), f_extrude();
void	f_rm(), f_arbdef(), f_quit();
void	f_edcomb(), f_status(), f_vrot();
void	f_refresh(), f_fix(), f_rt(), f_rrt(), f_nirt();
void	f_saveview(), f_savekey();
void	f_make(), f_attach(), f_release();
void	f_tedit(), f_memprint();
void	f_mirface(), f_units(), f_title();
void	f_permute();
void	f_keypoint();
void	f_rot_obj(), f_tr_obj(), f_sc_obj();
void	f_analyze(), f_sed();
void	f_ill(), f_knob(), f_tops(), f_summary();
void	f_prcolor(), f_color(), f_edcolor(), f_3ptarb(), f_rfarb(), f_which_id();
void	f_plot(), f_area(), f_find(), f_edgedir();
void	f_regdef(), f_aeview(), f_in(), f_tables(), f_edcodes(), f_dup(), f_concat();
void	f_rmats(),f_prefix(), f_keep(), f_tree(), f_inside(), f_mvall(), f_amtrack();
void	f_tabobj(), f_pathsum(), f_copyeval(), f_push(), f_facedef(), f_eqn();
void	f_overlay(), f_rtcheck(), f_comb();
void	f_preview();
void	f_ev(), f_debugnmg();
void	f_tol();
void	f_debugdir();
void	f_polybinout();
void	f_facetize();
void	f_adc();
void	f_set();
void	f_zoom();
void	f_mouse();
void	f_fracture();
void	f_orientation();
void	f_dm();
void	f_vrot_center();
void	f_opendb();
void	f_joint();
d59 1
a59 1
	void (*ft_func)();
d286 1
a286 1
	sync, 1, 1,
d326 11
d359 5
d373 2
d388 24
a411 1
		i = parse_line(rt_vls_addr(&cmd));
a412 3
		if( i == 0 ) {
			mged_cmd( numargs, cmd_args, funtab );
		}
d417 1
d430 1
d432 1
a432 1
parse_line(line)
d434 2
d440 1
a440 1
	numargs = 0;
d447 1
a447 1
	cmd_args[numargs] = lp;
d476 3
a478 3
			if( numargs > 0 )
				(void)cmd_glob();
			if( numargs++ >= MAXARGS )  {
d480 1
a480 1
				cmd_args[MAXARGS] = (char *)0;
d483 1
a483 1
			cmd_args[numargs] = lp1;
d488 1
a488 1
	cmd_args[numargs] = (char *)0;
d500 1
a500 1
void
d507 1
d512 1
a512 1
		return;
d525 12
a536 2
			ftp->ft_func(argc, argv);
			return;
d540 1
a540 1
		return;
d544 1
d549 2
a550 1
static void
d570 2
d576 2
a577 1
void
d593 2
a594 1
static void
d601 1
a601 1
	register int	i;
d603 2
d617 1
d620 2
d630 3
a632 2
void f_help2();
static void
d637 1
a637 1
	f_help2(argc, argv, &funtab[0]);
d640 2
a641 1
void f_help2(argc, argv, functions)
d655 1
a655 1
		return;
d657 1
a657 1
	helpcomm( argc, argv, functions );
d666 3
a668 2
void f_fhelp2();
static void
d673 1
a673 1
	f_fhelp2(argc, argv, &funtab[0]);
d675 2
a676 1
void
d691 1
a691 1
		return;
d693 1
a693 1
	helpcomm( argc, argv, functions );
d697 1
a697 1
void
d706 2
d710 1
a710 1
void
d717 1
d719 1
d722 1
a722 1
		return;
d737 1
d741 1
d759 1
a759 1
		if( len > 0 )  cmdline( &str );
d766 1
a766 1
void
d777 2
@


10.25
log
@Lint from 5.1.1.1
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.24 1994/03/24 16:25:36 cjohnson Exp $ (BRL)";
d189 1
a189 1
"facetize", "new_obj old_obj(s)", "convert objects to faceted NMG objects at current tol",
@


10.24
log
@Insert stub call to articulation/animation module.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.23 1994/03/22 19:38:16 cjohnson Exp cjohnson $ (BRL)";
d616 1
a621 1
	void f_help2();
d650 1
@


10.23
log
@Fix off by one error that was printing command table name.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.22 1994/03/17 00:42:38 cjohnson Exp cjohnson $ (BRL)";
d103 1
d217 2
@


10.22
log
@Change mged_cmd, f_help2, f_fhelp2 to take a function table as
a parameter.  This allows for secondary command tables.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.21 1994/03/08 21:30:43 pjt Exp cjohnson $ (BRL)";
d665 1
a665 1
		for( ftp = functions; ftp->ft_name; ftp++ )  {
@


10.21
log
@Added f_keypoint() linkage.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.20 94/01/06 12:26:28 pjt Exp $ (BRL)";
d104 1
a104 1
static struct funtab {
d111 4
a114 2
} funtab[] = {

d368 2
a370 1
#define NFUNC	( (sizeof(funtab)) / (sizeof(struct funtab)) )
d372 1
d420 1
a420 1
			mged_cmd( numargs, cmd_args );
d506 1
a506 1
mged_cmd( argc, argv )
d509 1
d514 2
a515 1
		(void)printf("no command entered, type ? for help\n");
d519 1
a519 1
	for( ftp = &funtab[0]; ftp < &funtab[NFUNC]; ftp++ )  {
d532 2
a533 2
		(void)printf("Usage: %s %s\n", ftp->ft_name, ftp->ft_parms);
		(void)printf("\t(%s)\n", ftp->ft_comment);
d536 2
a537 1
	(void)printf("%s: no such command, type ? for help\n", argv[0] );
d583 1
a583 1
helpcomm( argc, argv )
d586 1
d593 1
a593 1
		for( ftp = &funtab[0]; ftp < &funtab[NFUNC]; ftp++ )  {
d596 2
a597 2
			(void)printf("Usage: %s %s\n", ftp->ft_name, ftp->ft_parms);
			(void)printf("\t(%s)\n", ftp->ft_comment);
d600 4
a603 2
		if( ftp == &funtab[NFUNC] )
			(void)printf("%s: no such command, type ? for help\n", argv[i] );
d618 9
d632 3
a634 3
		for( ftp = &funtab[0]; ftp < &funtab[NFUNC]; ftp++ )  {
			(void)printf("%s %s\n", ftp->ft_name, ftp->ft_parms);
			(void)printf("\t(%s)\n", ftp->ft_comment);
d638 1
a638 1
	helpcomm( argc, argv );
d652 8
d663 3
a665 2
		(void)printf("The following commands are available:\n");
		for( ftp = &funtab[0]; ftp < &funtab[NFUNC]; ftp++ )  {
d671 1
a671 1
	helpcomm( argc, argv );
@


10.20
log
@Updated "permute" command help message for all ARBs, not just ARB8s
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.19 94/01/05 13:14:05 pjt Exp Locker: pjt $ (BRL)";
d78 1
d216 2
@


10.19
log
@Added the permute command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/cmd.c,v 10.18 93/11/18 02:33:07 butler Exp $ (BRL)";
d259 1
a259 1
"permute", "###", "permute vertices of an ARB8",
@


10.18
log
@added the "don't triangulate" option (-T) to ev command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.17 93/11/05 12:22:55 mike Exp Locker: butler $ (BRL)";
d77 1
d259 2
@


10.17
log
@Added f_opendb
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.16 93/07/15 21:28:01 mike Exp Locker: mike $ (BRL)";
d176 1
a176 1
"ev",	"[-w] [-n] [-P#] <objects>", "evaluate objects via NMG tessellation",
@


10.16
log
@Added f_vrot_center().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.15 93/07/13 21:01:11 mike Exp Locker: mike $ (BRL)";
d100 1
d248 2
@


10.15
log
@Added f_dm command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.14 93/03/24 04:07:09 phil Exp Locker: mike $ (BRL)";
d99 1
d347 2
@


10.14
log
@fixed typo in "preview" command help message.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.13 1992/11/23 20:53:40 mike Exp phil $ (BRL)";
d98 1
d156 2
@


10.13
log
@Described new options to preview command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.12 92/09/03 19:37:02 mike Exp Locker: mike $ (BRL)";
d261 1
a261 1
"preview", "preview [-v] [-d sec_delay] rt_script_file", "preview new style RT animation script",
@


10.12
log
@Added "orientation" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.11 92/08/05 17:14:12 gdurf Exp Locker: mike $ (BRL)";
d261 2
a262 2
"preview", "preview rt_script", "preview new style RT animation script",
	f_preview, 2, 2,
@


10.11
log
@fixed incorrect help string for "vrmgr" command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.10 92/06/25 21:05:10 butler Exp Locker: gdurf $ (BRL)";
d97 1
d243 2
@


10.10
log
@added entry for "fracture" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.9 92/06/05 22:31:17 mike Exp Locker: butler $ (BRL)";
d336 1
a336 1
"vrmgr", "host {master|slave|observer}", "link with Virtual Reality manager",
@


10.9
log
@Added f_labelvert() routine, to label vertices of the vlist of a solid(s).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.8 92/05/04 14:12:25 mike Exp Locker: mike $ (BRL)";
d96 1
d184 2
@


10.8
log
@Added red
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.7 92/04/16 03:21:45 mike Exp Locker: mike $ (BRL)";
d56 1
d215 2
@


10.7
log
@Added pov and vrmgr commands.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.7 92/04/16 01:31:11 mike Exp Locker: mike $ (BRL)";
d56 1
d264 2
@


10.6
log
@Changed cmdline() to process multiple commands at once.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.6 92/04/16 03:19:34 mike Exp $ (BRL)";
d56 2
d245 2
d327 2
d368 1
a368 1

@


10.5
log
@Added echo command, and "#" commenting (first non-white char).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.4 92/04/03 19:24:18 mike Exp Locker: mike $ (BRL)";
d28 1
d31 5
a35 1
#include <stdio.h>
d339 7
a345 6
 * This routine is called to process a user's command, as typed
 * on the standard input.  Once the
 * main loop of the editor is entered, this routine will be called
 * to process commands which have been typed in completely.
 * Return value non-zero means to print a prompt.  This is needed
 * when non-blocking I/O is used instead of select.
d352 6
d361 28
a388 4
	i = parse_line(rt_vls_addr(vp));
	if( i == 0 ) {
		mged_cmd( numargs, cmd_args );
		return 1;
d390 2
a391 4
	if( i < 0 )
		return 0;

	return 1;
@


10.4
log
@Changed cmdline() to take an rt_vls argument
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.3 91/12/19 03:22:45 mike Exp Locker: mike $ (BRL)";
d51 1
d150 2
d386 3
d641 13
@


10.3
log
@Moved f_param ("p") command from cmd.c to edsol.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.2 91/11/05 00:02:44 mike Exp Locker: mike $ (BRL)";
d339 2
a340 2
cmdline(line)
char	*line;
d344 3
a346 1
	i = parse_line(line);
d613 22
@


10.2
log
@Modified for beginnings of new display manager interface.
Added zoom and "M" (mouse) command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 10.1 91/10/12 06:43:14 mike Rel4_0 Locker: mike $ (BRL)";
a35 1
#include "./sedit.h"
d50 2
a51 1
static void	f_help(), f_fhelp(), f_param(), f_comm();
a455 52
}

/* Input parameter editing changes from keyboard */
/* Format: p dx [dy dz]		*/
static void
f_param( argc, argv )
int	argc;
char	**argv;
{
	register int i;

	if( es_edflag <= 0 )  {
		(void)printf("A solid editor option not selected\n");
		return;
	}
	if( es_edflag == PROT ) {
		(void)printf("\"p\" command not defined for this option\n");
		return;
	}

	inpara = 1;
	sedraw++;
	for( i = 1; i < argc; i++ )  {
		es_para[ i - 1 ] = atof( argv[i] );
		if( es_edflag == PSCALE ||
					es_edflag == SSCALE )  {
			if(es_para[0] <= 0.0) {
				(void)printf("ERROR: SCALE FACTOR <= 0\n");
				inpara = 0;
				sedraw = 0;
				return;
			}
		}
	}
	/* check if need to convert to the base unit */
	switch( es_edflag ) {

		case STRANS:
		case PSCALE:
		case EARB:
		case MVFACE:
		case MOVEH:
		case MOVEHH:
		case PTARB:
			/* must convert to base units */
			es_para[0] *= local2base;
			es_para[1] *= local2base;
			es_para[2] *= local2base;

		default:
			return;
	}
@


10.1
log
@Release_4.0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.29 91/08/31 07:30:40 butler Exp $ (BRL)";
d84 2
d207 2
d323 2
@


9.29
log
@implementation of the "set" command for altering "autosize" function.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.28 91/08/25 04:57:53 butler Exp $ (BRL)";
@


9.28
log
@re-word usage message for "autosize" command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/cmd.c,v 9.27 91/08/25 04:30:33 butler Exp $ (BRL)";
d83 1
a83 1
void	f_autosize();
a112 3
"autosize", "[0|1]",
	"toggle/set automatic sizing/centering of display for new geometry",
	f_autosize,1,2,
d279 2
@


9.27
log
@added "autosize" command to enable/disable automatic view centering/sizing
on initial display.
q
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/cmd.c,v 9.26 91/07/09 01:57:10 mike Exp $ (BRL)";
d114 1
a114 1
	"toggle/set automatic center/size of display for new geometry",
@


9.26
log
@Fixed arg counts to paths and listeval commands
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.25 91/07/01 01:44:04 mike Exp $ (BRL)";
d83 1
d113 3
@


9.25
log
@Added "quit" as alias for "q".
I've used FTP far too long.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.24 91/07/01 01:35:18 mike Exp $ (BRL)";
d201 1
a201 1
	f_pathsum, 1, 27,
d225 1
a225 1
	f_pathsum, 2, MAXARGS,
@


9.24
log
@Allowed title command to be invoked with no args
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.23 91/06/30 21:14:24 mike Exp $ (BRL)";
d241 2
@


9.23
log
@Allowed "units" command with no arg.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.22 91/06/25 16:08:04 pjt Exp $ (BRL)";
d293 1
a293 1
	f_title,2,MAXARGS,
@


9.22
log
@Modified entry in command table for f_adc
and added entry for f_nirt
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.21 91/06/14 06:03:28 mike Exp $ (BRL)";
d304 2
a305 2
"units", "<mm|cm|m|in|ft>", "change units",
	f_units,2,2,
@


9.21
log
@Added PJT's ADC command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.20 91/02/06 23:57:56 mike Exp $ (BRL)";
d62 1
a62 1
void	f_refresh(), f_fix(), f_rt(), f_rrt();
d99 3
a101 2
"adc", "[<reset|<a1|a2|x|y|dst> num>]", "control the angle/distance cursor",
        f_adc, 1, 3,
d218 2
@


9.20
log
@Added facetize command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.19 91/01/12 08:05:28 mike Exp $ (BRL)";
d82 1
d99 2
@


9.19
log
@externs.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.18 91/01/05 03:34:28 mike Exp $ (BRL)";
d81 1
d158 2
@


9.18
log
@Added experimental polybinout
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.17 90/12/07 06:16:14 mike Exp $ (BRL)";
d34 2
a36 1
#include "raytrace.h"
a37 1
#include "externs.h"
a40 3
extern void	perror();
extern int	atoi(), execl(), fork(), nice(), wait();
extern long	time();
@


9.17
log
@Changed minimum number of args for which_id
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.16 90/12/07 04:14:32 mike Exp $ (BRL)";
d83 1
d222 2
@


9.16
log
@Changed dup and concat to take 1 or 2 args only
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.16 90/12/07 03:33:46 mike Exp $ (BRL)";
d178 1
a178 1
	f_in, 1, 27,
d217 2
a218 2
"paths", "", "lists all paths matching input path",
	f_pathsum, 1, 27,
d300 1
a300 1
	f_which_id, 1, 27,
@


9.15
log
@Eliminated nmgtest
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.14 90/10/10 19:10:22 mike Exp $ (BRL)";
d120 1
a120 1
	f_concat, 1, 27,
d138 1
a138 1
	f_dup, 1, 27,
@


9.14
log
@Added "debugdir" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.13 90/05/22 16:03:25 mike Exp $ (BRL)";
d80 1
a80 1
void	f_ev(), f_nmgtest(), f_debugnmg();
a212 2
"nmgtest", "solid <op solid>", "test booleans on NMG (experimental)",
	f_nmgtest, 2, MAXARGS,
@


9.13
log
@Changed interface to cmdline() so that it could be used directly
by other modules.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/cmd.c,v 9.12 90/05/09 20:00:23 mike Exp $ (BRL)";
d82 1
d129 2
@


9.12
log
@Changed "enmg" to "ev", for "evaluate".
Move parallel processsing startup from hideline to ged.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.11 90/05/04 08:28:25 mike Locked $ (BRL)";
d318 2
a319 1
cmdline()
d323 1
a323 1
	i = parse_line();
d342 2
a343 1
parse_line()
a346 1
	static char line[MAXLINE];
a349 14
	*lp = '\0';

	/* Read input line */
	if( fgets( line, MAXLINE, stdin ) == NULL ) {
		if( !feof( stdin ) )
			return -1;	/* nothing to read */
	}

	/* Check for Control-D (EOF) */
	if( feof( stdin ) )  {
		/* Control-D typed, let's hit the road */
		f_quit();
		/* NOTREACHED */
	}
@


9.11
log
@Fixed minor NMG typo
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.10 90/05/04 03:47:58 mike Locked $ (BRL)";
d80 1
a80 1
void	f_enmg(), f_nmgtest(), f_debugnmg();
d148 2
a149 2
"enmg",	"<objects>", "edit objects with NMG conversion (experimental)",
	f_enmg, 2, MAXARGS,
@


9.10
log
@added "debugnmg" command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.9 90/04/26 02:14:59 butler Locked $ (BRL)";
d80 1
a80 1
void	f_enmg(), f_nmgtest(); f_debugnmg();
@


9.9
log
@Added f_tol command.
Added support for tolerance args to ft_plot() and ft_tess().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.8 90/04/25 21:21:07 mike Locked $ (BRL)";
d80 1
a80 1
void	f_enmg(), f_nmgtest();
d132 2
@


9.8
log
@Changed things to use argc, argv in many places
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.7 90/04/24 01:05:12 mike Locked $ (BRL)";
d81 1
d282 2
@


9.7
log
@Added f_debugmem command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.6 90/03/15 02:03:34 mike Locked $ (BRL)";
d319 1
a319 1
		mged_cmd();
d414 3
a416 1
mged_cmd()
a417 2
	extern char *cmd_args[];
	extern int numargs;
d420 1
a420 1
	if( numargs == 0 )  {
d426 1
a426 1
		if( strcmp( ftp->ft_name, cmd_args[0] ) != 0 )
d429 2
a430 2
		if( (ftp->ft_min <= numargs) &&
		    (numargs <= ftp->ft_max) )  {
d435 1
a435 1
			ftp->ft_func(numargs, cmd_args);
d442 1
a442 1
	(void)printf("%s: no such command, type ? for help\n", cmd_args[0] );
d448 3
a450 1
f_param()
d465 2
a466 2
	for( i = 1; i < numargs; i++ )  {
		es_para[ i - 1 ] = atof( cmd_args[i] );
d500 3
a502 1
f_comm()
d524 3
a526 1
f_quit()
d540 3
a542 1
helpcomm()
d548 1
a548 1
	for( i=1; i<numargs; i++ )  {
d550 1
a550 1
			if( strcmp( ftp->ft_name, cmd_args[i] ) != 0 )
d557 1
a557 1
			(void)printf("%s: no such command, type ? for help\n", cmd_args[i] );
d568 3
a570 1
f_help()
d575 1
a575 1
	if( numargs <= 1 )  {
d583 1
a583 1
	helpcomm();
d593 3
a595 1
f_fhelp()
d599 1
a599 1
	if( numargs <= 1 )  {
d607 1
a607 1
	helpcomm();
d612 3
a614 1
f_press()
d618 2
a619 2
	for( i = 1; i < numargs; i++ )
		press( cmd_args[i] );
d623 3
a625 1
f_summary()
d630 1
a630 1
	if( numargs <= 1 )  {
d634 1
a634 1
	cp = cmd_args[1];
@


9.6
log
@Added f_nmgtest.
Changed "x" (f_debug) to have a debugging level parameter
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.5 89/12/28 16:10:46 mike Locked $ (BRL)";
d58 1
a58 1
void	f_debug(), f_regdebug(), f_debuglib();
d129 2
@


9.5
log
@Made MAXARGS local to cmd.c, global 'maxargs' is used to learn of size.
Improved error checking in command globbing.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.4 89/12/28 14:36:43 mike Locked $ (BRL)";
d80 1
a80 1
void	f_enmg();
d205 2
d293 2
a294 2
"x", "", "list drawn objects",
	f_debug, 1,1,
@


9.4
log
@Changed f_cat to f_concat.
split f_list into f_list and f_cat.
Changed calling sequence of ft_func() to have (argc, argv)
arguments, to permit numargs and cmd_arg[] globals to be phased out.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.3 89/10/27 21:20:13 mike Locked $ (BRL)";
d46 1
d50 1
a50 1
char *cmd_args[MAXARGS + 1];	/* array of pointers to args */
@


9.3
log
@Ignore trailing whitespace (from Dan Dender)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.2 89/10/10 16:23:48 phil Locked $ (BRL)";
d60 1
a60 1
void	f_region(), f_itemair(), f_mater(), f_kill(), f_list();
d74 1
a74 1
void	f_regdef(), f_aeview(), f_in(), f_tables(), f_edcodes(), f_dup(), f_cat();
d108 2
a109 2
"cat", "<objects>", "list attributes",
	f_list,2,MAXARGS,
d117 1
a117 1
	f_cat, 1, 27,
d184 1
a184 1
"l", "<objects>", "list attributes",
d426 5
a430 2
			/* We have the right number of args */
			ftp->ft_func(numargs);	/* finally! */
@


9.2
log
@Added PRELIMINARY command "enmg".
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 9.1 89/05/19 06:02:03 mike Rel3_5 $ (BRL)";
d381 1
a381 1
			if((*lp1 == ' ') || (*lp1 == '\t'))
@


9.1
log
@Release_3.5
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 8.5 89/04/06 20:46:06 mike Exp $ (BRL)";
d79 1
d142 2
@


8.5
log
@MAXARGS and MAXLINE are found in ged.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 8.4 89/04/06 20:39:00 mike Locked $ (BRL)";
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 8.3 89/04/03 20:07:20 mike Locked $ (BRL)";
a45 1
#define MAXARGS		 200	/* Maximum number of args per line */
a329 1
#define MAXLINE		512		/* Maximum number of chars per line */
@


8.3
log
@Added hook for hideline function "H" but commented out for Rel3.1
since it doesn't work everywhere yet.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 8.2 88/12/06 00:59:43 phil Locked $ (BRL)";
d37 1
@


8.2
log
@Added debuglib and preview commands.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/cmd.c,v 1.3 88/10/30 02:36:39 mike Exp $ (BRL)";
d56 1
a56 1
void	f_edit(), f_evedit(), f_delobj();
d153 4
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
 *	do_cmd		Check arg counts, run a command
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.11 88/09/17 02:22:11 reschly Exp $ (BRL)";
d35 1
a36 1
#include "./objdir.h"
d54 1
a54 1
void	do_cmd();
d57 2
a58 1
void	f_debug(), f_regdebug(), f_name(), f_copy(), f_instance();
d78 1
d125 2
d209 2
d307 1
a307 1
		do_cmd();
d395 2
d403 1
a403 1
do_cmd()
@


7.11
log
@changed usage strings for attach and knob.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.10 88/09/06 09:05:54 reschly Locked $ (BRL)";
@


7.10
log
@Put back "make" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.9 88/08/24 07:41:33 reschly Exp $ (BRL)";
d101 2
a102 2
"attach", "<device>", "attach to a display processor, or NU",
	f_attach,2,2,
d171 2
a172 2
"knob", "id val", "emulate knob twist",
	f_knob,3,3,
@


7.9
log
@alphabatized the command list,  modified parse_line to fix regexp bugs.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.8 88/08/12 07:48:51 reschly Locked $ (BRL)";
d179 2
@


7.8
log
@Small change to invocation of "comb" command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.7 88/08/11 05:22:07 mike Locked $ (BRL)";
d89 14
a102 4
"help", "[commands]", "give usage message for given commands",
	f_help,0,MAXARGS,
"e", "<objects>", "edit objects",
	f_edit,2,MAXARGS,
d105 12
a116 10
"E", "<objects>", "evaluated edit of objects",
	f_evedit,2,MAXARGS,
"d", "<objects>", "delete list of objects",
	f_delobj,2,MAXARGS,
"t", "", "table of contents",
	dir_print,1,MAXARGS,
"ls", "", "table of contents",
	dir_print,1,MAXARGS,
"mv", "old new", "rename object",
	f_name,3,3,
d121 30
d153 8
a160 4
"r", "region <operation solid>", "create or extend a Region combination",
	f_region,4,MAXARGS,
"comb", "comb_name <operation solid>", "create or extend combination w/booleans",
	f_comb,4,MAXARGS,
d163 2
a164 2
"mater", "comb [material]", "assign/delete material to combination",
	f_mater,2,3,
d167 6
d175 18
a192 8
"cat", "<objects>", "list attributes",
	f_list,2,MAXARGS,
"find", "<objects>", "find all references to objects",
	f_find, 1, MAXARGS,
"Z", "", "zap all objects off screen",
	f_zap,1,1,
"g", "groupname <objects>", "group objects",
	f_group,3,MAXARGS,
d195 28
a222 6
"mirror", "old new axis", "Arb mirror ??",
	f_mirror,4,4,
"mirface", "#### axis", "mirror an ARB face",
	f_mirface,3,3,
"extrude", "#### distance", "extrude dist from face",
	f_extrude,3,3,
d225 2
a226 6
"arb", "name rot fb", "make arb8, rotation + fallback",
	f_arbdef,4,4,
"units", "<mm|cm|m|in|ft>", "change units",
	f_units,2,2,
"title", "string", "change the title",
	f_title,2,MAXARGS,
d229 10
a238 4
"vrot", "xdeg ydeg zdeg", "rotate viewpoint",
	f_vrot,4,4,
"translate", "x y z", "trans object to x,y, z",
	f_tr_obj,4,4,
a240 4
"analyze", "[arbname]", "analyze faces of ARB",
	f_analyze,1,MAXARGS,
"ill", "name", "illuminate object",
	f_ill,2,2,
a242 10
"%", "", "escape to interactive shell",
	f_comm,1,1,
"q", "", "quit",
	f_quit,1,1,
"center", "x y z", "set view center",
	f_center, 4,4,
"press", "button_label", "emulate button press",
	f_press,2,MAXARGS,
"knob", "id val", "emulate knob twist",
	f_knob,3,3,
d245 2
a246 6
"x", "", "list drawn objects",
	f_debug, 1,1,
"regdebug", "", "toggle register print",
	f_regdebug, 1,2,
"edcomb", "combname Regionflag regionid air los [GIFTmater]", "edit combination record info",
	f_edcomb,6,7,
d249 8
a256 18
"fix", "", "fix display after hardware error",
	f_fix,1,1,
"refresh", "", "send new control list",
	f_refresh, 1,1,
"rt", "[options]", "do raytrace of view",
	f_rt,1,MAXARGS,
"rrt", "prog [options]", "invoke prog with view",
	f_rrt,2,MAXARGS,
"saveview", "file [args]", "save view in file for RT",
	f_saveview,2,MAXARGS,
"rmats", "file", "load views from file (experimental)",
	f_rmats,2,MAXARGS,
"savekey", "file [time]", "save keyframe in file (experimental)",
	f_savekey,2,MAXARGS,
"attach", "<device>", "attach to a display processor, or NU",
	f_attach,2,2,
"release", "", "release current display processor [attach NU]",
	f_release,1,1,
d259 2
a260 2
"make", "name <arb8|sph|ellg|tor|tgc>", "create a primitive",
	f_make,3,3,
d263 4
a266 36
"summary", "[s r g]", "count/list solid/reg/groups",
	f_summary,1,2,
"prcolor", "", "print color&material table",
	f_prcolor, 1, 1,
"color", "low high r g b str", "make color entry",
	f_color, 7, 7,
"edcolor", "", "text edit color table",
	f_edcolor, 1, 1,
"plot", "[-float] [-zclip] [-2d] [-grid] [out_file] [|filter]", "make UNIX-plot of view",
	f_plot, 2, MAXARGS,
"area", "[endpoint_tolerance]", "calculate presented area of view",
	f_area, 1, 2,
"ae", "azim elev", "set view using az and elev angles",
	f_aeview, 3, 3,
"regdef", "item [air] [los] [GIFTmaterial]", "change next region default codes",
	f_regdef, 2, 5,
"edgedir", "[delta_x delta_y delta_z]|[rot fb]", "define direction of ARB edge being moved",
	f_edgedir, 3, 4,
"in", "", "keyboard entry of solids",
	f_in, 1, 27,
"solids", "file object(s)", "make ascii summary of solid parameters",
	f_tables, 3, MAXARGS,
"regions", "file object(s)", "make ascii summary of regions",
	f_tables, 3, MAXARGS,
"idents", "file object(s)", "make ascii summary of region idents",
	f_tables, 3, MAXARGS,
"edcodes", "object(s)", "edit region ident codes",
	f_edcodes, 2, MAXARGS,
"dup", "file [prefix]", "check for dup names in 'file'",
	f_dup, 1, 27,
"concat", "file [prefix]", "concatenate 'file' onto end of present database",
	f_cat, 1, 27,
"prefix", "new_prefix object(s)", "prefix each occurrence of object name(s)",
	f_prefix, 3, MAXARGS,
"keep", "keep_file object(s)", "save named objects in specified file",
	f_keep, 3, MAXARGS,
d269 4
a272 10
"inside", "", "finds inside solid per specified thicknesses",
	f_inside, 1, MAXARGS,
"mvall", "oldname newname", "rename object everywhere",
	f_mvall, 3, 3,
"track", "<parameters>", "adds tracks to database",
	f_amtrack, 1, 27,
"3ptarb", "", "makes arb given 3 pts, 2 coord of 4th pt, and thickness",
	f_3ptarb, 1, 27,
"rfarb", "", "makes arb given point, 2 coord of 3 pts, rot, fb, thickness",
	f_rfarb, 1, 27,
d275 4
a278 26
"paths", "", "lists all paths matching input path",
	f_pathsum, 1, 27,
"listeval", "", "lists 'evaluated' path solids",
	f_pathsum, 1, 27,
"copyeval", "", "copys an 'evaluated' path solid",
	f_copyeval, 1, 27,
"tab", "object[s]", "tabulates objects as stored in database",
	f_tabobj, 2, MAXARGS,
"push", "object[s]", "pushes object's path transformations to solids",
	f_push, 2, MAXARGS,
"killall", "object[s]", "kill object[s] and all references",
	f_killall, 2, MAXARGS,
"killtree", "object[s]", "kill complete tree[s] - BE CAREFUL",
	f_killtree, 2, MAXARGS,
"memprint", "", "print memory maps",
	f_memprint, 1, 1,
"facedef", "####", "define new face for an arb",
	f_facedef, 2, MAXARGS,
"sync",	"",	"forces UNIX sync",
	sync, 1, 1,
"eqn", "A B C", "planar equation coefficients",
	f_eqn, 4, 4,
"overlay", "file.plot [name]", "Read UNIX-Plot as named overlay",
	f_overlay, 2, 3,
"rtcheck", "[options]", "check for overlaps in current view",
	f_rtcheck,1,MAXARGS
d340 3
a342 1
	cmd_args[numargs] = &line[0];
d344 2
d351 1
a351 1
		(void)system( &line[1] );
d356 9
a364 6
	/* In case first character is not "white space" */
	if( (*lp != ' ') && (*lp != '\t') && (*lp != '\0') )
		numargs++;		/* holds # of args */

	for( lp = &line[0]; *lp != '\0'; lp++ )  {
		if( (*lp == ' ') || (*lp == '\t') || (*lp == '\n') )  {
d367 9
a375 11
			if( (*lp1 != ' ') && (*lp1 != '\t') &&
			    (*lp1 != '\n') && (*lp1 != '\0') )  {
				if( numargs >= MAXARGS )  {
					(void)printf("More than %d arguments, excess flushed\n", MAXARGS);
					cmd_args[MAXARGS] = (char *)0;
					return(0);
				}
				cmd_args[numargs] = lp1;
				/* If not cmd [0], check for regular exp */
				if( numargs++ > 0 )
					(void)cmd_glob();
d377 1
@


7.7
log
@Added f_fhelp, f_comb
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.6 88/05/15 23:04:51 mike Locked $ (BRL)";
d111 1
a111 1
"r", "region <operation solid>", "create region",
d113 2
a114 2
"comb", "comb solid <operation solid>", "create combination w/booleans",
	f_comb,3,MAXARGS,
d261 1
a261 1
"tab", "object[s]", "tabs objects as stored in database",
@


7.6
log
@lint fixes
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.5 88/02/27 01:07:13 mike Locked $ (BRL)";
d53 1
a53 1
static void	f_help(), f_param(), f_comm();
d76 1
a76 1
void	f_overlay(), f_rtcheck();
d88 1
a88 1
	f_help,0,MAXARGS,
d113 2
d500 5
a504 1
/* Print a help message */
d506 1
a506 1
f_help()
a510 8
	if( numargs <= 1 )  {
		(void)printf("The following commands are available:\n");
		for( ftp = &funtab[0]; ftp < &funtab[NFUNC]; ftp++ )  {
			col_item(ftp->ft_name);
		}
		col_eol();
		return;
	}
d523 45
@


7.5
log
@added overlay and rtcheck commands
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.4 88/02/25 00:23:50 mike Locked $ (BRL)";
d53 1
d55 1
a55 1
void	f_help(), f_center(), f_press(), f_view(), f_blast();
d60 2
a61 2
void	f_zap(), f_group(), f_param(), f_mirror(), f_extrude();
void	f_rm(), f_arbdef(), f_comm(), f_quit();
d299 1
a299 1
		(void)do_cmd();
@


7.4
log
@Reorganized HELP capability
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.3 88/01/13 16:37:26 mike Locked $ (BRL)";
d75 1
d273 5
a277 1
	f_eqn, 4, 4
@


7.3
log
@added a call to mged_finish
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.2 87/11/05 05:04:02 stay Locked $ (BRL)";
d85 1
a85 1
"?", "", "help message",
d87 2
d209 1
a209 1
"plot", "[-zclip] [-2d] [-grid] [out_file] [|filter]", "make UNIX-plot of view",
d497 7
a503 7
	
	(void)printf("?\n");
	(void)printf("The following commands are available:\n");
	for( ftp = &funtab[0]; ftp < &funtab[NFUNC]; ftp++ )  {
		col_item(ftp->ft_name);
		col_item(ftp->ft_parms);
		col_item(ftp->ft_comment);
d505 13
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 7.1 87/11/02 23:58:59 mike Rel $ (BRL)";
d471 1
a471 1
		finish( 11 );
@


7.1
log
@Release 2.3
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 6.1 87/07/11 08:02:14 mike Rel $ (BRL)";
d31 1
a31 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 5.1 87/06/24 22:18:25 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 4.5 87/06/17 23:44:14 phil Exp $ (BRL)";
@


4.5
log
@non-blocking I/O support
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 4.4 87/06/12 20:05:38 phil Locked $ (BRL)";
@


4.4
log
@old cat command changed to concat, so that new cat == l command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 4.3 87/05/29 00:44:52 mike Locked $ (BRL)";
d281 2
d284 1
a284 1
void
d287 6
a292 3
	if( parse_line() )  {
		/* don't process this command line */
		return;
d294 4
a297 1
	(void)do_cmd();
d305 1
d320 4
a323 1
	(void)fgets( line, MAXLINE, stdin );
@


4.3
log
@Added ls, cat, and sync commands.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 4.2 87/02/13 00:05:58 mike Exp $ (BRL)";
d227 1
a227 1
"dup", "file {prefix}", "check for dup names in 'file'",
d229 1
a229 1
"cat", "file {prefix}", "cat 'file' onto end of present data file",
d241 1
a241 1
"track", "<parameters>", "adds tracks to data file",
d255 1
a255 1
"tab", "object[s]", "tabs objects as stored in data file",
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 4.1 86/12/29 03:19:39 mike Rel1 $ (BRL)";
d43 1
d53 1
a53 1
static void	do_cmd();
d97 2
d117 2
d267 2
d366 1
a366 1
static void
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.24 86/11/04 01:40:17 mike Exp $ (BRL)";
@


2.24
log
@Added "rrt".
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.23 86/09/09 23:57:15 mike Locked $ (BRL)";
@


2.23
log
@Dender:  added facedef, eqn commands.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.22 86/08/12 06:47:24 mike Exp $ (BRL)";
d61 2
a62 1
void	f_refresh(), f_fix(), f_rt(), f_saveview(), f_savekey();
d176 2
@


2.22
log
@Changed #includes for CC -I../h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.21 86/06/12 00:11:25 mike Exp $ (BRL)";
d72 1
a72 1
void	f_tabobj(), f_pathsum(), f_copyeval(), f_push();
d256 5
a260 1
	f_memprint, 1, 1
d421 1
@


2.21
log
@Keith added "killtree" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.20 86/05/28 01:41:07 mike Exp $ (BRL)";
d32 7
a38 7
#include "../h/vmath.h"
#include "../h/db.h"
#include "sedit.h"
#include "ged.h"
#include "objdir.h"
#include "solid.h"
#include "dm.h"
@


2.20
log
@Added cpi and killall commands from Keith
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.19 86/04/09 01:09:35 mike Exp $ (BRL)";
d56 1
a56 1
void	f_copy_inv(), f_killall();
d253 2
@


2.19
log
@Improved usage message on bad command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.18 86/03/15 01:06:41 mike Exp $ (BRL)";
d56 1
d99 2
d251 2
@


2.18
log
@Spelling fix.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.17 86/03/10 21:38:09 mike Exp $ (BRL)";
d367 1
a367 2
		(void)printf("%s: error in number of args\n", ftp->ft_name);
		(void)printf("%s: %s\n", ftp->ft_name, ftp->ft_parms);
@


2.17
log
@Latest revisions from Keith, including lots of new commands
and one-axis scaling.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.16 86/02/17 17:05:21 mike Exp $ (BRL)";
d220 1
a220 1
"prefix", "new_prefix object(s)", "prefix each occurence of object name(s)",
@


2.16
log
@Changed f_modify to f_mater, changed parameters to edcomb and regdef.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.15 85/09/27 19:18:01 mike Exp $ (BRL)";
d67 1
a67 1
void	f_prcolor(), f_color(), f_edcolor();
d69 3
a71 2
void	f_regdef(), f_aeview(), f_in();
void	f_rmats(),f_prefix(), f_keep(), f_tree(), f_inside(), f_mvall();
d204 1
a204 1
"edgedir", "edgedir delta_x delta_y delta_z", "define direction of ARB edge being moved",
d208 12
d230 18
@


2.15
log
@Added Phil's savekey command.
KAA added mvall command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.14 85/09/12 00:26:25 mike Exp $ (BRL)";
d56 1
a56 1
void	f_region(), f_itemair(), f_modify(), f_kill(), f_list();
d103 2
a104 2
"mater", "region mat los", "modify material or los",
	f_modify,4,4,
d161 2
a162 2
"edcomb", "combname flag item air mat los", "edit combination record info",
	f_edcomb,7,7,
d201 1
a201 1
"regdef", "item [air] [material] [los]", "change next region default codes",
@


2.14
log
@Added inside command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.13 85/08/29 14:55:21 mike Exp $ (BRL)";
d60 1
a60 1
void	f_refresh(), f_fix(), f_rt(), f_saveview();
d70 1
a70 1
void	f_rmats(),f_prefix(), f_keep(), f_tree(), f_inside();
d175 2
d215 2
d369 1
@


2.13
log
@Added prefix, keep, and tree comands.
(From Romanelli).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.12 85/08/26 17:09:44 mike Exp $ (BRL)";
d70 1
a70 1
void	f_rmats(),f_prefix(), f_keep(), f_tree();
d173 2
a174 2
"rmats", "file", "load views from file",
	f_rmats,2,2,
d211 2
@


2.12
log
@Added rmats() command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.11 85/08/07 05:17:13 mike Exp $ (BRL)";
d70 1
a70 1
void	f_rmats();
d205 6
@


2.11
log
@Changed to use common ../h/vmath.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.10 85/07/30 01:16:35 mike Exp $ (BRL)";
d70 1
d173 2
@


2.10
log
@Change to support new ARB editing.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.9 85/06/19 03:02:20 mike Exp $ (BRL)";
d28 5
a32 4
#include	<math.h>
#include	<signal.h>
#include	<stdio.h>
#include "ged_types.h"
a38 1
#include "../h/vmath.h"
@


2.9
log
@Support for typein.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.8 85/06/06 22:33:05 mike Exp $ (BRL)";
d366 1
@


2.8
log
@KAA, added f_edgedir() support
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.7 85/05/08 00:37:55 mike Exp $ (BRL)";
d69 1
a69 1
void	f_regdef(), f_aeview();
d200 2
d203 1
a203 1
	f_memprint,1,1
d234 1
a234 1
#define MAXLINE		128		/* Maximum number of chars per line */
d400 1
a400 1
static void
@


2.7
log
@KAA added regdef and ae commands.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.7 85/05/08 00:25:25 mike Exp $ (BRL)";
d68 1
a68 1
void	f_plot(), f_area(), f_find();
d198 2
d338 5
d363 1
@


2.6
log
@Eliminated silly M_brname stuff.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.5 85/03/29 00:13:46 mike Exp $ (BRL)";
d69 1
d194 4
@


2.5
log
@Added f_find.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.4 85/03/28 20:51:05 mike Exp $ (BRL)";
d58 1
a58 1
void	f_delmem(), f_arbdef(), f_comm(), f_quit();
d95 2
a96 2
"i", "object comb inst [operation]", "create instance",
	f_instance,4,5,
d122 1
a122 1
	f_delmem,3,MAXARGS,
@


2.4
log
@Added plot and area commands
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.3 85/03/15 05:03:20 mike Exp $ (BRL)";
d68 1
a68 1
void	f_plot(), f_area();
d105 1
a105 1
"l", "object", "list object attributes",
d107 2
@


2.3
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.2 85/03/14 05:04:35 mike Exp $ (BRL)";
d68 1
d187 4
@


2.2
log
@Various support for mater.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 2.1 85/03/11 23:54:19 mike Prod $ (BRL)";
d44 2
a45 1
#define MAXARGS		 20	/* Maximum number of args per line */
d50 2
d89 1
a89 1
	dir_print,1,1,
d105 1
a105 1
	f_list,2,2,
d135 1
a135 1
	f_analyze,1,2,
d265 3
a267 1
				numargs++;
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.14 85/02/14 01:46:29 mike Exp $ (BRL)";
d64 1
d175 1
a175 1
"summary", "[s r g]", "count/list solid/reg/groups\n",
d177 6
@


1.14
log
@Added f_sed routine to permit keyboard user to go directly
to solid edit state on named solid.
@
text
@d7 2
d11 5
a15 1
 * Source -
d19 4
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.13 85/02/14 00:23:42 mike Exp $ (BRL)";
d32 1
a32 1
#include "db.h"
d35 1
a35 1
#include "dir.h"
d38 1
a38 1
#include "vmath.h"
d234 2
a235 2
		system( &line[1] );
		printf("!\n");
d243 1
a243 1
	for( lp = &line[0]; *lp != '\0'; *lp++ )  {
d250 1
a250 1
					printf("More than %d arguments, excess flushed\n", MAXARGS);
d279 1
a279 1
		printf("no command entered, type ? for help\n");
d423 1
a423 1
			printf("summary:  S R or G are only valid parmaters\n");
@


1.13
log
@Added f_saveview()
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.12 85/02/06 02:30:27 mike Exp $ (BRL)";
d52 1
a52 1
void	f_analyze();
d124 2
@


1.12
log
@Added optional parameter to regdebug command to
permit tickling display-manager specific debugging.
(In this case, the 3 view options on the Raster Tek).
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.11 85/02/05 04:17:20 mike Exp $ (BRL)";
d47 1
a47 1
void	f_refresh(), f_fix(), f_rt();
d150 2
@


1.11
log
@Table format change.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.10 85/02/05 02:25:57 mike Exp $ (BRL)";
d138 2
a139 2
"regdump", "", "toggle register print",
	f_regdebug, 1,1,
@


1.10
log
@Added summary and tops commands.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.9 85/02/01 15:40:31 mike Exp $ (BRL)";
d45 1
a45 1
void	f_delmem(), f_arbdef(), f_return(), f_comm(), f_quit();
d57 2
a61 1
	char *ft_messages;
d63 101
a163 51
	{"?",f_help,0,100,"? (help message)"},
	{"B",f_blast,2,20,"B <objects> (blast screen, edit objects)"},
	"e",f_edit,2,20,"e <objects> (edit named objects)",
	"E",f_evedit,2,20,"E <objects> (evaluated edit of objects)",
	"d",f_delobj,2,20,"d <objects> (delete list of objects)",
	"t",dir_print,1,1,"t (table of contents)",
	"mv",f_name,3,3,"mv oldname newname (rename object)",
	"cp",f_copy,3,3,"cp oldname newname (copy [duplicate] object)",
	"i",f_instance,4,5,"i object combname instname [operation] (create instance)",
	"r",f_region,4,20,"r regionname <operation solidname> (create region)",
	"item",f_itemair,3,4,"item region item [air] (change item # or air code)",
	"mater",f_modify,4,4,"mater region mat los (modify material or los)",
	"kill",f_kill,2,20,"kill <objects> (delete objects from file)",
	"l",f_list,2,2,"l object (list object attributes)",
	"Z",f_zap,1,1,"Z (zap all objects off screen)",
	"g",f_group,3,20,"g groupname <objects> (group objects)",
	"p",f_param,2,4,"p dx [dy dz] (set parameters)",
	"mirror",f_mirror,4,4,"mirror oldsolid newsolid axis",
	"mirface",f_mirface,3,3,"mirface #### axis (mirror an ARB face)",
	"extrude",f_extrude,3,3,"extrude #### distance (extrude dist from face)",
	"rm",f_delmem,3,20,"rm comb <members> (remove members from comb)",
	"arb",f_arbdef,4,4,"arb name rot fb (make arb8, rotation + fallback)",
	"units",f_units,2,2,"units <mm|cm|m|in|ft> (change units)",
	"title",f_title,2,20,"title newtitle (change the title)",
	"rotobj",f_rot_obj,4,4,"rotobj xang yang zang (rotate object about x, y, z)",
	"vrot",f_vrot,4,4,"vrot xdeg ydeg zdeg (rotate view)",
	"translate",f_tr_obj,4,4,"translate x y z (trans object to x,y,z)",
	"scale",f_sc_obj,2,2,"scale factor (scale object by factor)",
	"analyze",f_analyze,1,2,"analyze [arbname] (list much info about arb)",
	"ill",f_ill,2,2,"ill name (illuminate object)",
	"\n",f_return,1,1,"NOP",
	"%",f_comm,1,1,"% (escape to interactive shell)",
	"q",f_quit,1,1,"q (quit)",
	"center",f_center,4,4,"center x y z (debug, set view center)",
	"press",f_press,2,20,"press button (emulate button press)",
	"knob",f_knob,3,3,"knob id val (emulate knob twist)",
	"size",f_view,2,2,"size size (debug, set view size)",
	"x",f_debug,1,1,"x (debug, list drawn objects)",
	"regdump",f_regdebug,1,1,"regdump (debug, toggle register print)",
	"edcomb",f_edcomb,7,7,"edcomb combname flag item air mat los (edit combination record info)",
	"status",f_status,1,1,"status (debug, get view status)",
	"fix",f_fix,1,1,"fix (restart display processor after hardware error)",
	"refresh",f_refresh,1,1,"refresh (debug, send new control list)",
	"rt",f_rt,1,20,"rt [options] (do raytrace of view)",
	"attach",f_attach,2,2,"attach <mg|vg> (attach to display processor)",
	"release",f_release,1,1,"release (release current display processor)",
	"ted",f_tedit,1,1,"ted (text edit a solid's parameters)",
	"make",f_make,3,3,"make name <arb8|ellg|tor|tgc> (create a primitive)",
	"tops",f_tops,1,1,"tops (find all top level objects)",
	"summary",f_summary,1,2,"summary [s r g] (count/list solids/regions/groups)\n",
	"memprint",f_memprint,1,1,"memprint (print memory maps)"
d185 6
a190 2
/* Parse commandline into argument vector */
/* Returns nonzero value if shell command */
d209 1
a209 1
		quit();
d215 2
a216 6
	/* Handle single "newline" so that paged Table-of-Contents works */
	if( *lp == '\n' )  {
		numargs++;
		cmd_args[numargs] = (char *)0;
		return(0);
	}
d236 1
a236 1
					printf("too many arguments, excess flushed\n");
d262 1
a262 1
	register int i;
d269 8
a276 11
	for( i = 0; i < NFUNC ; i++ )  {
		if( strcmp( funtab[i].ft_name, cmd_args[0] ) == 0 )  {
			/* We have a match */
			if( (funtab[i].ft_min <= numargs) &&
			    (numargs <= funtab[i].ft_max) )  {
				/* We have the right number of args */
				funtab[i].ft_func(numargs);	/* finally! */
				return;
			}
			printf("error in number of args\n");
			printf("%s\n", funtab[i].ft_messages );
d279 4
d284 1
a284 1
	printf("%s: no such command, type ? for help\n", cmd_args[0] );
a337 1
	(void)signal( SIGQUIT, SIG_IGN );
a338 4
#ifdef	pdp11
		/* The PDP-11 VG device driver nices up the process. */
		(void)nice( 10 );
#endif
a339 1
		(void)signal( SIGQUIT, SIG_DFL );
d346 1
a346 3
	(void)signal(SIGINT, quit);
	(void)signal(SIGQUIT, sig3);

d365 1
a365 1
	int i;
d369 5
a373 2
	for( i = 0; i < NFUNC; i++ )  {
		(void)printf("%s\n", funtab[i].ft_messages );
a374 8
	(void)printf("\n");
}

/* Carriage return hook */
static void
f_return()
{
	/* presently unused */
@


1.9
log
@vrot and rotobj
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.8 85/02/01 03:25:48 mike Exp $ (BRL)";
d53 1
a53 1
void	f_ill(), f_knob();
d110 2
d346 28
@


1.8
log
@Added knob and ill commands.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.7 85/02/01 00:56:53 mike Exp $ (BRL)";
d86 2
a87 2
	"rotobj",f_rot_obj,4,4,"rotate xang yang zang (rotate object about x, y, z)",
	"vrot",f_vrot,4,4,"rot xdeg ydeg zdeg (rotate view)",
@


1.7
log
@Typo
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.6 85/02/01 00:50:13 mike Exp $ (BRL)";
d53 1
d91 1
d97 1
@


1.6
log
@Keith's global/local units additions
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.5 85/01/17 07:28:14 mike Exp $ (BRL)";
d46 1
a46 1
void	f_edcomb(), f_status(), f_rot();
@


1.5
log
@
Latest stuff
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: cmd.c,v 1.4 85/01/16 03:40:34 mike Exp $ (BRL)";
d50 3
a52 1
void	f_mirface();
d83 7
a95 1
	"rot",f_rot,4,4,"rot xdeg ydeg zdeg (rotate view)",
d237 1
a237 1
	if( es_edflag == 0 )  {
d253 15
@


1.4
log
@Keith's added mirface command
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d85 1
a85 1
	"press",f_press,2,2,"press button# (debug, emulate button press)",
d87 1
a87 1
	"rot",f_rot,3,3,"rot axis degrees (debug, rotate view)",
d308 10
@


1.3
log
@pre-Keith version
@
text
@d50 1
d77 1
@


1.2
log
@Minor cleanups
@
text
@d9 4
a12 1
 * The U. S. Army Ballistic Research Laboratory
d14 3
d22 1
a22 1
#include "3d.h"
d49 1
a49 1
void	f_tedit();
d93 3
d97 1
a97 3
	"attach",f_attach,2,2,"attach <mg|vg> (unimplemented)",
	"release",f_release,1,1,"release (unimplemented)",
	"ted",f_tedit,1,1,"ted (text edit a solid's parameters)"
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
void	f_zap(), f_group(), f_param(), f_mirror(), f_face();
d42 2
d70 1
a70 1
	"extrude",f_face,3,3,"extrude #### distance (extrude face)",
d86 5
a90 1
	"rt",f_rt,1,20,"rt [options] (TEST)"
a91 1

@
