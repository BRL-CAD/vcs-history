head	11.87;
access;
symbols
	ansi-20040405-merged:11.83.2.2
	postmerge-20040405-ansi:11.85
	premerge-20040404-ansi:11.84
	postmerge-autoconf:11.84
	autoconf-freeze:11.83.10.2
	premerge-autoconf:11.84
	postmerge-20040315-windows:11.84
	premerge-20040315-windows:11.84
	windows-20040315-freeze:11.83.4.1
	autoconf-20031203:11.83
	autoconf-20031202:11.83
	autoconf-branch:11.83.0.10
	phong-branch:11.83.0.8
	photonmap-branch:11.83.0.6
	rel-6-1-DP:11.83
	windows-branch:11.83.0.4
	rel-6-0-2:11.81
	ansi-branch:11.83.0.2
	rel-6-0-1-branch:11.81.0.2
	hartley-6-0-post:11.82
	hartley-6-0-pre:11.81
	rel-6-0-1:11.81
	rel-6-0:11.81
	rel-5-4:11.58
	offsite-5-3-pre:11.68
	rel-5-3:11.58
	rel-5-2:11.58
	rel-5-1-branch:11.58.0.2
	rel-5-1:11.58
	rel-5-0:11.50
	rel-5-0-beta:11.49
	rel-4-5:11.44
	ctj-4-5-post:11.41
	ctj-4-5-pre:11.41
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.8;
locks; strict;
comment	@ * @;


11.87
date	2004.05.21.17.47.37;	author morrison;	state dead;
branches;
next	11.86;

11.86
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.85;

11.85
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.84;

11.84
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.83;

11.83
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	11.83.2.1
	11.83.4.1
	11.83.10.1;
next	11.82;

11.82
date	2002.08.15.20.55.32;	author hartley;	state Exp;
branches;
next	11.81;

11.81
date	2002.01.09.19.17.38;	author jra;	state Exp;
branches;
next	11.80;

11.80
date	2002.01.08.21.57.21;	author jra;	state Exp;
branches;
next	11.79;

11.79
date	2001.10.17.07.40.04;	author morrison;	state Exp;
branches;
next	11.78;

11.78
date	2001.09.21.14.46.48;	author jra;	state Exp;
branches;
next	11.77;

11.77
date	2001.06.01.19.23.23;	author bparker;	state Exp;
branches;
next	11.76;

11.76
date	2001.05.04.14.20.45;	author bparker;	state Exp;
branches;
next	11.75;

11.75
date	2001.05.02.17.14.00;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	2001.04.05.19.35.43;	author morrison;	state Exp;
branches;
next	11.73;

11.73
date	2001.04.02.21.38.18;	author morrison;	state Exp;
branches;
next	11.72;

11.72
date	2001.03.31.01.57.20;	author morrison;	state Exp;
branches;
next	11.71;

11.71
date	2001.03.23.22.05.32;	author jra;	state Exp;
branches;
next	11.70;

11.70
date	2001.03.23.21.19.45;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	2001.03.23.16.07.37;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	2000.10.20.05.04.37;	author mike;	state Exp;
branches;
next	11.67;

11.67
date	2000.09.21.02.46.51;	author mike;	state Exp;
branches;
next	11.66;

11.66
date	2000.09.08.05.55.47;	author mike;	state Exp;
branches;
next	11.65;

11.65
date	2000.09.07.02.23.42;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	2000.08.24.02.54.14;	author mike;	state Exp;
branches;
next	11.63;

11.63
date	2000.08.19.03.10.11;	author mike;	state Exp;
branches;
next	11.62;

11.62
date	2000.08.09.20.51.37;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	2000.07.11.23.14.23;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	2000.07.10.22.59.54;	author mike;	state Exp;
branches;
next	11.59;

11.59
date	2000.06.28.16.11.06;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	2000.05.26.16.09.51;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	2000.05.26.14.00.42;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	2000.01.31.15.09.58;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	2000.01.08.03.19.48;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	2000.01.04.17.58.21;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	99.12.30.19.29.48;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	99.12.29.23.23.18;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	99.11.26.23.03.30;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	99.09.01.18.55.09;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	99.04.16.18.00.02;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	99.01.12.18.21.54;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	99.01.07.18.39.59;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	98.11.13.22.31.21;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	98.11.06.22.16.59;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	97.09.08.19.05.59;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	97.09.03.14.19.20;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	97.05.02.15.32.11;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	97.04.14.12.29.36;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	97.03.13.21.39.40;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	97.03.13.19.11.53;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	97.02.20.16.24.37;	author pjt;	state Exp;
branches;
next	11.33;

11.33
date	97.02.19.21.14.58;	author pjt;	state Exp;
branches;
next	11.32;

11.32
date	97.02.18.21.21.19;	author pjt;	state Exp;
branches;
next	11.31;

11.31
date	97.02.12.21.17.52;	author pjt;	state Exp;
branches;
next	11.30;

11.30
date	97.01.30.05.38.17;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	97.01.30.05.33.36;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	97.01.30.05.04.18;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	97.01.30.04.59.50;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	97.01.30.04.57.26;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	97.01.30.04.50.07;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	97.01.30.02.17.14;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	97.01.29.00.33.08;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	97.01.26.02.59.23;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	97.01.02.19.36.55;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.12.23.20.08.46;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	96.10.04.14.58.11;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.09.23.18.37.18;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.08.26.17.58.39;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.07.15.20.36.28;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.04.10.18.52.12;	author pjt;	state Exp;
branches;
next	11.9;

11.9
date	96.02.01.18.32.09;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	95.08.03.22.45.10;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.08.03.21.42.39;	author gdurf;	state Exp;
branches;
next	11.6;

11.6
date	95.08.02.21.29.26;	author gdurf;	state Exp;
branches;
next	11.5;

11.5
date	95.07.28.07.33.03;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.07.27.21.52.03;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.06.27.14.50.30;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.03.11.00.04.28;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.43;	author mike;	state Rel4_4;
branches;
next	10.10;

10.10
date	94.12.16.19.35.39;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.12.14.16.11.56;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.11.08.04.19.16;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.09.22.04.10.16;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.27.03.21.18;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.25.19.50.13;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.09.14.58.09;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.06.01.13.46.01;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.09.30.16.12.00;	author jra;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.11;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.01.12.08.25.45;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.00.31.10;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.07.03.17.02;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.21.06.05.19;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.01.56;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.05.11.21.42.02;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.20.38.55;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.16.22.51.41;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.56.27;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.33;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.08.12.07.49.10;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.08.11.05.22.17;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.03.47;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.46;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.02.01;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.18.08;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.05.45;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.19.24;	author mike;	state Rel1;
branches;
next	2.16;

2.16
date	86.09.10.02.43.36;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	86.09.09.21.56.37;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	86.08.12.06.47.04;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	86.06.12.00.08.36;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.05.28.01.24.50;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.03.14.20.41.35;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.02.17.17.01.14;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.09.14.05.34.20;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.08.07.05.16.59;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.07.30.01.18.38;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.05.08.00.53.44;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.05.08.00.31.13;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.02.20.15.37;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.15.06.17.10;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.04.06.40;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.54.02;	author mike;	state Prod;
branches;
next	1.5;

1.5
date	85.03.08.20.07.55;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.02.14.00.58.28;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.02.14.00.22.14;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.02.01.01.45.59;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.02.01.00.48.58;	author mike;	state Exp;
branches;
next	;

11.83.2.1
date	2002.09.19.18.02.00;	author morrison;	state Exp;
branches;
next	11.83.2.2;

11.83.2.2
date	2004.03.17.21.21.55;	author morrison;	state Exp;
branches;
next	;

11.83.4.1
date	2004.03.11.23.46.33;	author morrison;	state Exp;
branches;
next	;

11.83.10.1
date	2004.02.12.18.34.13;	author erikg;	state Exp;
branches;
next	11.83.10.2;

11.83.10.2
date	2004.03.15.14.07.35;	author erikg;	state Exp;
branches;
next	;


desc
@Module to handle changes to the database tree.
@


11.87
log
@moved to src/mged/
@
text
@/*
 *			C H G T R E E
 *
 * This module contains functions which change the tree structure
 * of the model, and delete solids or combinations or combination elements.
 *
 * Functions -
 *	f_name		rename an object
 *	f_copy		copy a solid
 *	f_instance	create an instance of something
 *	f_region	add solids to a region or create the region
 *	f_kill		remove an object or several from the description
 *	f_group		"grouping" command
 *	f_rm		delete members of a combination
 *	f_copy_inv	copy cyl and position at "end" of original cyl
 *
 *  Authors -
 *	Michael John Muuss
 *	Keith A Applin
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/chgtree.c,v 11.86 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <signal.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#ifdef DM_X
#  include "tk.h"
#else
#  include "tcl.h"
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "./sedit.h"
#include "raytrace.h"
#include "wdb.h"
#include "rtgeom.h"
#include "./ged.h"
#include "externs.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./mgedtcl.h"
#include "./cmd.h"

extern void solid_list_callback(void); /* chgview.c */
extern struct db_tree_state	mged_initial_tree_state;	/* dodraw.c */
extern struct bn_tol		mged_tol;	/* from ged.c */
extern struct rt_tess_tol	mged_ttol;	/* XXX needs to replace mged_abs_tol, et.al. from dodraw.c */
extern int			classic_mged;

#ifdef DM_X
extern Tk_Window	tkwin;
#else
int tkwin=0;
#endif

static char *really_delete="tk_messageBox -icon question -title {Are you sure?}\
 -type yesno -message {If you delete the \"_GLOBAL\" object you will be losing some important information\
 such as your preferred units and the title of the database. Do you really want to do this?}";

void	aexists(char *name);

/* Remove an object or several from the description */
/* Format: kill [-f] object1 object2 .... objectn	*/
int
cmd_kill(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
#if 0
	int ret;

	CHECK_DBI_NULL;

	ret = wdb_kill_cmd(wdbp, interp, argc, argv);
	solid_list_callback();

	return ret;
#else
	register int		i;
	struct directory	*dp;
	struct directory	*dpp[2] = {DIR_NULL, DIR_NULL};
	int			is_phony;
	int			verbose = LOOKUP_NOISY;
	int			force=0;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help kill");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( argc > 1 && strcmp( argv[1], "-f" ) == 0 )  {
		verbose = LOOKUP_QUIET;
		force = 1;
		argc--;
		argv++;
	}

	for( i = 1; i < argc; i++ )  {
		if( (dp = db_lookup( dbip,  argv[i], verbose )) != DIR_NULL )  {
			if( !force && dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY && dp->d_minor_type == 0 ) {
				/* kill the _GLOBAL object?? */
				if( classic_mged || tkwin == NULL ) {
					/* Tk is not available */
					bu_log( "You attempted to delete the _GLOBAL object.\n" );
					bu_log( "\tIf you delete the \"_GLOBAL\" object you will be losing some important information\n" );
					bu_log( "\tsuch as your preferred units and the title of the database.\n" );
					bu_log( "\tUse the \"-f\" option, if you really want to do this.\n" );
					continue;
				} else {
					/* Use tk_messageBox to question user */
					Tcl_ResetResult( interp );
					if( Tcl_Eval( interp, really_delete ) != TCL_OK ) {
						bu_bomb( "Tcl_Eval() failed!!!\n" );
					}
					if( strcmp( Tcl_GetStringResult( interp ), "yes" ) ) {
						Tcl_ResetResult( interp );
						continue;
					}
					Tcl_ResetResult( interp );
				}
			}
			is_phony = (dp->d_addr == RT_DIR_PHONY_ADDR);
			dpp[0] = dp;
			eraseobjall(dpp);
			/* eraseobjall() does db_dirdelete() on phony entries, don't re-do. */
			if( is_phony )  continue;

			if( db_delete( dbip, dp ) < 0 ||
			    db_dirdelete( dbip, dp ) < 0 )  {
			  /* Abort kill processing on first error */
			  TCL_DELETE_ERR_return(argv[i]);
			}
		}
	}

	solid_list_callback();
	return TCL_OK;
#endif
}

/* Copy a cylinder and position at end of original cylinder

 *	Used in making "wires"
 *
 * Format: cpi old new
 */
int
f_copy_inv(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *proto;
	register struct directory *dp;
	struct rt_db_internal internal;
	struct rt_tgc_internal *tgc_ip;
	int id;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 3 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help cpi");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (proto = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;

	if( db_lookup( dbip,  argv[2], LOOKUP_QUIET ) != DIR_NULL )  {
	  aexists( argv[2] );
	  return TCL_ERROR;
	}

	if( (id = rt_db_get_internal( &internal, proto, dbip, (fastf_t *)NULL, &rt_uniresource )) < 0 )  {
		TCL_READ_ERR_return;
	}
	/* make sure it is a TGC */
	if( id != ID_TGC )
	{
	  Tcl_AppendResult(interp, "f_copy_inv: ", argv[1],
			   " is not a cylinder\n", (char *)NULL);
		rt_db_free_internal( &internal, &rt_uniresource );
		return TCL_ERROR;
	}
	tgc_ip = (struct rt_tgc_internal *)internal.idb_ptr;

	/* translate to end of "original" cylinder */
	VADD2( tgc_ip->v , tgc_ip->v , tgc_ip->h );

	/* no interuprts */
	(void)signal( SIGINT, SIG_IGN );

	if( (dp = db_diradd( dbip, argv[2], -1L, 0, proto->d_flags, &proto->d_minor_type)) == DIR_NULL )  {
		TCL_ALLOC_ERR_return;
	}

	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}

	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = argv[2]; /* depends on solid name being in argv[2] */
	  av[2] = NULL;

	  /* draw the new solid */
	  (void)cmd_draw( clientData, interp, 2, av );
	}

	if(state == ST_VIEW) {
	  char *av[3];

	  av[0] = "sed";
	  av[1] = argv[2];  /* new name in argv[2] */
	  av[2] = NULL;

	  /* solid edit this new cylinder */
	  (void)f_sed( clientData, interp, 2, av );
	}

	return TCL_OK;
}

/*
 *			F _ A R C E D
 *
 *  Allow editing of the matrix, etc., along an arc in the database
 *  from the command line, when NOT in an edit state.
 *  Used mostly to facilitate shell script writing.
 *
 *  Syntax:  arced a/b ("anim" command)
 *	arced a/b matrix rmul translate dx dy dz
 *
 *  Extensions should be formulated along the lines of the "anim"
 *  commands from the script language.
 */
int
f_arced(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct animate		*anp;
	struct directory	*dp;
	mat_t			stack;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	union tree		*tp;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help arced");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_VIEW, "Arc edit" ) )  return TCL_ERROR;

	if( !strchr( argv[1], '/' ) )  {
	  Tcl_AppendResult(interp, "arced: bad path specification '", argv[1],
			   "'\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( !(anp = db_parse_1anim( dbip, argc, (const char **)argv ) ) )  {
	  Tcl_AppendResult(interp, "arced: unable to parse command\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( anp->an_path.fp_len < 2 )  {
		Tcl_AppendResult(interp, "arced: path spec has insufficient elements\n", (char *)NULL);
		return TCL_ERROR;
	}
#if 0
	if( anp->an_path.fp_len != 2 )  {
		char	*thepath = db_path_to_string( &(anp->an_path) );
		bu_log("arced: '%s' is not a 2-element path spec\n");
		bu_free( thepath, "path" );
		db_free_1anim( anp );
		return TCL_ERROR;
	}
#endif

#if 0
	db_write_anim(stdout, anp);	/* XXX temp */
#endif

	/* Only the matrix rarc, lmul, and rmul directives are useful here */
	MAT_IDN( stack );

	/* Load the combination into memory */
	dp = anp->an_path.fp_names[anp->an_path.fp_len-2];
	RT_CK_DIR(dp);
	if( (dp->d_flags & DIR_COMB) == 0 )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  return TCL_ERROR;
	}
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		db_free_1anim( anp );
		TCL_READ_ERR_return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);
	if( !comb->tree )  {
		Tcl_AppendResult(interp, dp->d_namep, ": empty combination\n", (char *)NULL);
		goto fail;
	}

	/* Search for first mention of arc */
	if( (tp = db_find_named_leaf( comb->tree, anp->an_path.fp_names[anp->an_path.fp_len-1]->d_namep )) == TREE_NULL )  {
		Tcl_AppendResult(interp, "Unable to find instance of '",
			anp->an_path.fp_names[anp->an_path.fp_len-1]->d_namep,
			"' in combination '",
			anp->an_path.fp_names[anp->an_path.fp_len-2]->d_namep,
			"', error\n", (char *)NULL);
		goto fail;
	}

	/* Found match.  Update tl_mat in place. */
	if( !tp->tr_l.tl_mat )
		tp->tr_l.tl_mat = bn_mat_dup( bn_mat_identity );

	if( db_do_anim( anp, stack, tp->tr_l.tl_mat, NULL ) < 0 )  {
		goto fail;
	}

	if( bn_mat_is_identity( tp->tr_l.tl_mat ) )  {
		bu_free( (genptr_t)tp->tr_l.tl_mat, "tl_mat" );
		tp->tr_l.tl_mat = (matp_t)NULL;
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR;
		goto fail;
	}
	db_free_1anim( anp );
	return TCL_OK;
		
fail:
	rt_db_free_internal( &intern, &rt_uniresource );
	db_free_1anim( anp );
	return TCL_ERROR;
}

/*
 *			C M D _ P A T H L I S T
 *
 *  Given the name(s) of a database node(s), return a TCL list of all
 *  paths from there to each leaf below it.
 *
 *  Similar to the "tree" command, only suitable for programs, not humans.
 */
int
cmd_pathlist(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
  CHECK_DBI_NULL;

  return wdb_pathlist_cmd(wdbp, interp, argc, argv);
}

/*
 *			F I N D _ S O L I D _ W I T H _ P A T H
 */
struct solid *
find_solid_with_path(register struct db_full_path *pathp)
{
	register struct solid	*sp;
	int			count = 0;
	struct solid		*ret = (struct solid *)NULL;

	RT_CK_FULL_PATH(pathp);

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		if( !db_identical_full_paths( pathp, &sp->s_fullpath ) )  continue;

		/* Paths are the same */
		ret = sp;
		count++;
	}
	if( count > 1 ){
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls,"find_solid_with_path() found %d matches\n", count);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	return ret;
}

/*
 *			C M D _ O E D
 *
 *  Transition from VIEW state to OBJECT EDIT state in a single command,
 *  rather than requiring "press oill", "ill leaf", "matpick a/b".
 *
 *  Takes two parameters which when combined represent the full path to
 *  the reference solid of the object to be edited.
 *  The conceptual slash between the two strings signifies which
 *  matrix is to be edited.
 */
int
cmd_oed(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct db_full_path	lhs;
	struct db_full_path	rhs;
	struct db_full_path	both;
	char			*new_argv[4];
	char			number[32];

	CHECK_DBI_NULL;

	if(argc < 3 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help oed");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_VIEW, "Object Illuminate" ) )  {
		Tcl_AppendResult(interp, "MGED state is not VIEW", (char *)NULL);
		return TCL_ERROR;
	}
	if(BU_LIST_IS_EMPTY(&dgop->dgo_headSolid)) {
		Tcl_AppendResult(interp, "no solids in view", (char *)NULL);
		return TCL_ERROR;
	}

	if( db_string_to_path( &lhs, dbip, argv[1] ) < 0 )  {
		Tcl_AppendResult(interp, "bad lhs path", (char *)NULL);
		return TCL_ERROR;
	}
	if( db_string_to_path( &rhs, dbip, argv[2] ) < 0 )  {
		db_free_full_path( &lhs );
		Tcl_AppendResult(interp, "bad rhs path", (char *)NULL);
		return TCL_ERROR;
	}
	if( rhs.fp_len <= 0 )  {
		db_free_full_path( &lhs );
		db_free_full_path( &rhs );
		Tcl_AppendResult(interp, "rhs must not be null", (char *)NULL);
		return TCL_ERROR;
	}

	db_full_path_init( &both );
	db_dup_full_path( &both, &lhs );
	db_append_full_path( &both, &rhs );
#if 0
	db_pr_full_path( "lhs ", &lhs );
	db_pr_full_path( "rhs ", &rhs );
	db_pr_full_path( "both", &both);
#endif

	/* Patterned after  ill_common() ... */
	illump = BU_LIST_NEXT(solid, &dgop->dgo_headSolid);/* any valid solid would do */
	edobj = 0;		/* sanity */
	movedir = 0;		/* No edit modes set */
	MAT_IDN( modelchanges );	/* No changes yet */
	(void)chg_state( ST_VIEW, ST_O_PICK, "internal change of state");
	/* reset accumulation local scale factors */
	acc_sc[0] = acc_sc[1] = acc_sc[2] = 1.0;
	new_mats();

	/* Find the one solid, set s_iflag UP, point illump at it */
	illump = find_solid_with_path( &both );
	if( !illump )  {
		db_free_full_path( &lhs );
		db_free_full_path( &rhs );
		db_free_full_path( &both );
		Tcl_AppendResult(interp, "Unable to find solid matching path", (char *)NULL);
		illump = 0;
		(void)chg_state( ST_O_PICK, ST_VIEW, "error recovery");
		return TCL_ERROR;
	}
	(void)chg_state( ST_O_PICK, ST_O_PATH, "internal change of state");

	/* Select the matrix */
#if 0
	bu_log("matpick %d\n", lhs.fp_len);
#endif
	sprintf( number, "%d", lhs.fp_len );
	new_argv[0] = "matpick";
	new_argv[1] = number;
	new_argv[2] = NULL;
	if( f_matpick( clientData, interp, 2, new_argv ) != TCL_OK )  {
		db_free_full_path( &lhs );
		db_free_full_path( &rhs );
		db_free_full_path( &both );
		Tcl_AppendResult(interp, "error detected inside f_matpick", (char *)NULL);
		return TCL_ERROR;
	}
	if( not_state( ST_O_EDIT, "Object EDIT" ) )  {
		db_free_full_path( &lhs );
		db_free_full_path( &rhs );
		db_free_full_path( &both );
		Tcl_AppendResult(interp, "MGED state did not advance to Object EDIT", (char *)NULL);
		return TCL_ERROR;
	}
	db_free_full_path( &lhs );
	db_free_full_path( &rhs );
	db_free_full_path( &both );
	return TCL_OK;
}

/*
 *			F _ P U T M A T
 *
 *	Replace the matrix on an arc in the database from the command line,
 *	when NOT in an edit state.  Used mostly to facilitate writing shell
 *	scripts.  There are two valid syntaxes, each of which is implemented
 *	as an appropriate call to f_arced.  Commands of the form
 *
 *		    putmat a/b m0 m1 ... m15
 *
 *	are converted to
 *
 *		arced a/b matrix rarc m0 m1 ... m15,
 *
 *	while commands of the form
 *
 *			    putmat a/b I
 *
 *	are converted to
 *
 *	    arced a/b matrix rarc 1 0 0 0   0 1 0 0   0 0 1 0   0 0 0 1.
 *
 */
int
f_putmat (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    int			result = TCL_OK;	/* Return code */
    char		*newargv[20+2];
    struct bu_vls	*avp;
    int			got;

    CHECK_DBI_NULL;
    CHECK_READ_ONLY;

    if(argc < 3 || 18 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help putmat");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    if (not_state( ST_VIEW, "Command-line matrix replace"))
      return TCL_ERROR;

    if (!strchr( argv[1], '/'))
    {
      Tcl_AppendResult(interp, "putmat: bad path specification '",
		       argv[1], "'\n", (char *)NULL);
      return TCL_ERROR;
    }
    switch (argc)
    {
	case 18:
	    avp = bu_vls_vlsinit();
	    bu_vls_from_argv(avp, 16, argv + 2);
	    break;
	case 3:
	    if ((argv[2][0] == 'I') && (argv[2][1] == '\0'))
	    {
		avp = bu_vls_vlsinit();
		bu_vls_printf(avp, "1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 ");
		break;
	    }
    	    /* Sometimes the matrix is sent through Tcl as one long string.
    	     * Copy it so we can crack it, below.
    	     */
	    avp = bu_vls_vlsinit();
    	    bu_vls_strcat(avp, argv[2]);
    	    break;
	default:
	  Tcl_AppendResult(interp, "putmat: error in matrix specification (wrong number of args)\n", (char *)NULL);
	  return TCL_ERROR;
    }
    newargv[0] = "arced";
    newargv[1] = argv[1];
    newargv[2] = "matrix";
    newargv[3] = "rarc";

    /* 16+1 allows space for final NULL entry in argv[] */
    got = bu_argv_from_string( &newargv[4], 16+1, bu_vls_addr(avp) );
    if( got != 16 )  {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "putmat: %s:%d: bad matrix, only got %d elements: %s\n",
			__FILE__, __LINE__, got, bu_vls_addr(&tmp_vls));
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    	  bu_vls_free(&tmp_vls);
	  result = TCL_ERROR;
    }

    if (result != TCL_ERROR)
	result = f_arced(clientData, interp, 20, newargv);

    bu_vls_vlsfree(avp);
    return result;
}

/*
 *			F _ C O P Y M A T
 *
 *	Copy the matrix on one arc in the database to another arc.
 *
 */
int
f_copymat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    char			*child;
    char			*parent;
    struct bu_vls		pvls;
    int				i;
    int				sep;
    int				status;
    struct db_tree_state	ts;
    struct directory		*dp;
    struct rt_comb_internal	*comb;
    struct rt_db_internal	intern;
    struct animate		*anp;
    union tree			*tp;

    CHECK_DBI_NULL;
    CHECK_READ_ONLY;

    if(argc < 3 || 3 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help copymat");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    if (not_state( ST_VIEW, "Command-line matrix copy"))
	return TCL_ERROR;

    /*
     *	Ensure that each argument contains exactly one slash
     */
    for (i = 1; i <= 2; ++i)
	if (((child = strchr(argv[i], '/')) == NULL)
	 || (strchr(++child, '/') != NULL))
	{
	    Tcl_AppendResult(interp,
		"copymat: bad arc: '", argv[i], "'\n", (char *) NULL);
	    return TCL_ERROR;
	}

    BU_GETSTRUCT(anp, animate);
    anp -> magic = ANIMATE_MAGIC;

    ts = mged_initial_tree_state;	/* struct copy */
    ts.ts_dbip = dbip;
    ts.ts_resp = &rt_uniresource;
    MAT_IDN(ts.ts_mat);
    db_full_path_init(&anp -> an_path);
    if (db_follow_path_for_state(&ts, &(anp -> an_path), argv[1], LOOKUP_NOISY)
	< 0 )
    {
	Tcl_AppendResult(interp,
	    "copymat: cannot follow path for arc: '", argv[1], "'\n",
	    (char *) NULL);
	return TCL_ERROR;
    }

    bu_vls_init(&pvls);
    bu_vls_strcat(&pvls, argv[2]);
    parent = bu_vls_addr(&pvls);
    sep = strchr(parent, '/') - parent;
    bu_vls_trunc(&pvls, sep);
    switch (rt_db_lookup_internal(dbip, parent, &dp, &intern, LOOKUP_NOISY, &rt_uniresource))
    {
	case ID_COMBINATION:
	    if (dp -> d_flags & DIR_COMB)
		break;
	    else
	    {
		struct bu_vls tmp_vls;

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "Non-combination directory <x%x> '%s' for combination rt_db_internal <x%x>\nThis should not happen\n",
		    dp, dp -> d_namep, intern);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *) NULL);
	    }
	    /* Fall through this case */
	default:
	    Tcl_AppendResult(interp,
		"copymat: Object '", parent, "' is not a combination\n",
		(char *) NULL);
	    /* Fall through this case */
	case ID_NULL:
	    bu_vls_free(&pvls);
	    return TCL_ERROR;
    }
    comb = (struct rt_comb_internal *) intern.idb_ptr;
    RT_CK_COMB(comb);

    if ((tp = db_find_named_leaf(comb -> tree, child)) == TREE_NULL)
    {
	Tcl_AppendResult(interp, "copymat: unable to find instance of '",
		child, "' in combination '", dp -> d_namep,
		"'\n", (char *)NULL);
	status = TCL_ERROR;
	goto wrapup;
    }

    /*
     *	Finally, copy the matrix
     */
    if (!bn_mat_is_identity(ts.ts_mat))
    {
	if (tp -> tr_l.tl_mat == NULL)
	    tp -> tr_l.tl_mat = bn_mat_dup(ts.ts_mat);
	else
	    MAT_COPY(tp -> tr_l.tl_mat, ts.ts_mat);
    }
    else if (tp -> tr_l.tl_mat != NULL)
    {
	bu_free((genptr_t) tp -> tr_l.tl_mat, "tl_mat");
	tp -> tr_l.tl_mat = (matp_t) 0;
    }

    if (rt_db_put_internal(dp, dbip, &intern, &rt_uniresource) < 0)
    {
	TCL_WRITE_ERR;
	status = TCL_ERROR;
	goto wrapup;
    }

    status = TCL_OK;

wrapup:

    bu_vls_free(&pvls);
    if (status == TCL_ERROR)
	rt_db_free_internal(&intern, &rt_uniresource);
    return status;
}
@


11.86
log
@change conf.h to a wrapped config.h
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/chgtree.c,v 11.85 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.85
log
@merge of ansi-6-0-branch into HEAD
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d34 5
a38 1
#include "conf.h"
@


11.84
log
@update copyright to include span through 2003
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.83 2002/08/20 17:08:21 jra Exp $ (BRL)";
d62 1
a62 1
extern void solid_list_callback(); /* chgview.c */
d78 1
a78 1
void	aexists();
d175 1
a175 5
f_copy_inv(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d270 1
a270 5
f_arced(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d401 1
a401 2
find_solid_with_path( pathp )
register struct db_full_path	*pathp;
d440 1
a440 5
cmd_oed(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char      	**argv;
d569 1
a569 6
f_putmat (clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;

d653 1
a653 5
f_copymat(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
@


11.83
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1985 by the United States Army.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.81 2002/01/09 19:17:38 jra Exp $ (BRL)";
@


11.83.4.1
log
@sync to HEAD...
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/chgtree.c,v 11.84 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.83.10.1
log
@merge from HEAD
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.84 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.83.10.2
log
@merge from head
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.83.10.1 2004/02/12 18:34:13 erikg Exp $ (BRL)";
@


11.83.2.1
log
@Initial ANSIfication
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.83 2002/08/20 17:08:21 jra Exp $ (BRL)";
d62 1
a62 1
extern void solid_list_callback(void); /* chgview.c */
d78 1
a78 1
void	aexists(char *name);
d175 5
a179 1
f_copy_inv(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d274 5
a278 1
f_arced(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d409 2
a410 1
find_solid_with_path(register struct db_full_path *pathp)
d449 5
a453 1
cmd_oed(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d582 6
a587 1
f_putmat (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d671 5
a675 1
f_copymat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.83.2.2
log
@sync branch with HEAD
@
text
@d27 1
a27 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.82
log
@Converted from K&R to ANSI C - RFH
@
text
@d62 1
a62 1
extern void solid_list_callback(void); /* chgview.c */
d78 1
a78 1
void	aexists(char *name);
d175 5
a179 1
f_copy_inv(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d274 5
a278 1
f_arced(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d409 2
a410 1
find_solid_with_path(register struct db_full_path *pathp)
d449 5
a453 1
cmd_oed(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d582 6
a587 1
f_putmat (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d671 5
a675 1
f_copymat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.81
log
@Undo previous mod for long names (was not needed)
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.80 2002/01/08 21:57:21 jra Exp $ (BRL)";
d62 1
a62 1
extern void solid_list_callback(); /* chgview.c */
d78 1
a78 1
void	aexists();
d175 1
a175 5
f_copy_inv(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d270 1
a270 5
f_arced(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d401 1
a401 2
find_solid_with_path( pathp )
register struct db_full_path	*pathp;
d440 1
a440 5
cmd_oed(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char      	**argv;
d569 1
a569 6
f_putmat (clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;

d653 1
a653 5
f_copymat(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
@


11.80
log
@Corrections to handle long names
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.79 2001/10/17 07:40:04 morrison Exp $ (BRL)";
d227 3
a229 6
	if( dbip->dbi_version < 5 ) {
		if( (dp = db_diradd( dbip, argv[2], -1L, 0, proto->d_flags, &proto->d_minor_type)) == DIR_NULL )  {
			TCL_ALLOC_ERR_return;
		}
	} else {
		struct bu_attribute_value_set avs;
a230 10
		bu_avs_init( &avs, 1, "avs" );
		if ((dp = db_diradd5(dbip, argv[2], -1L, proto->d_major_type, proto->d_minor_type,
				     (unsigned char)'\0', 0, &avs )) == DIR_NULL)  {
			bu_avs_free( &avs );
			Tcl_AppendResult(interp, "An error has occured while adding '",
					 argv[2], "' to the database.\n", (char *)NULL);
			TCL_ALLOC_ERR_return;
		}
		bu_avs_free( &avs );
	}
@


11.79
log
@Mac OS X warning and error fixes for non-production build
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.78 2001/09/21 14:46:48 jra Exp $ (BRL)";
d227 16
a242 2
	if( (dp = db_diradd( dbip, argv[2], -1L, 0, proto->d_flags, &proto->d_minor_type)) == DIR_NULL )  {
	    	TCL_ALLOC_ERR_return;
@


11.78
log
@The kill command now makes it a bit harder to delete _GLOBAL object
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.77 2001/06/01 19:23:23 bparker Exp $ (BRL)";
d41 5
a45 2
#include "tcl.h"
#include "tk.h"
d68 1
d70 3
@


11.77
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.76 2001/05/04 14:20:45 bparker Exp $ (BRL)";
d42 1
d63 7
d96 1
d113 1
d120 22
@


11.76
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.75 2001/05/02 17:14:00 bparker Exp $ (BRL)";
d56 1
d65 2
a66 2
/* Create an instance of something */
/* Format: i object combname [op]	*/
d68 4
a71 5
f_instance(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d73 2
a74 2
	char oper;
	struct bu_list	head;
a76 1
	CHECK_READ_ONLY;
d78 2
a79 1
	BU_LIST_INIT(&head);
d81 2
a82 50
	if(argc < 3 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help i");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip, argv[1], LOOKUP_NOISY ) == DIR_NULL )
	  return TCL_ERROR;

	oper = WMOP_UNION;
	if( argc == 4 )
		oper = argv[3][0];
	if(oper != WMOP_UNION && oper != WMOP_SUBTRACT &&	oper != WMOP_INTERSECT) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "bad operation: %c\n", oper );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  return TCL_ERROR;
	}
	mk_addmember( argv[2], &head, oper );

	if( mk_comb( wdbp, argv[1], &head,
	    0, NULL, NULL, NULL,
	    0, 0, 0, 0,
	    0, 1, 1 ) < 0 )
	{
		Tcl_AppendResult(interp,
			"An error has occured while adding '",
			argv[1], "' to the database.\n", (char *)NULL);
		TCL_ERROR_RECOVERY_SUGGESTION;
		return TCL_ERROR;
	}
	return TCL_OK;
}

/* Remove an object or several from the description */
/* Format: kill [-f] object1 object2 .... objectn	*/
int
f_kill(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
d126 1
a126 51
}

/* Grouping command */
/* Format: g groupname object1 object2 .... objectn	*/
int
f_group(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	register int i;
	struct bu_list	head;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	BU_LIST_INIT(&head);

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help g");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* get objects to add to group */
	for( i = 2; i < argc; i++ )  {
		if( db_lookup( dbip,  argv[i], LOOKUP_NOISY) != DIR_NULL )  {
			/* Add to list */
			(void)mk_addmember( argv[i], &head, WMOP_UNION );
		}  else
		  Tcl_AppendResult(interp, "skip member ", argv[i], "\n", (char *)NULL);
	}

	/* Do them all at once */
	if( mk_comb( wdbp, argv[1], &head,
	    0, NULL, NULL, NULL,
	    0, 0, 0, 0,
	    0, 1, 1 ) < 0 )
	{
		Tcl_AppendResult(interp,
			"An error has occured while adding '",
			argv[1], "' to the database.\n", (char *)NULL);
		TCL_ERROR_RECOVERY_SUGGESTION;
		return TCL_ERROR;
	}
	return TCL_OK;
d203 1
a203 1
	  (void)f_edit( clientData, interp, 2, av );
a346 23
 *			P A T H L I S T _ L E A F _ F U N C
 */
static union tree *
pathlist_leaf_func( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
{
	char	*str;

	RT_CK_FULL_PATH( pathp );
	RT_CK_DB_INTERNAL(ip);

	str = db_path_to_string( pathp );

	Tcl_AppendElement( interp, str );

	bu_free( (genptr_t)str, "path string" );
	return TREE_NULL;
}

/*
d355 4
a358 5
cmd_pathlist(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char	        **argv;
d362 1
a362 21
  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help pathlist");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  mged_initial_tree_state.ts_ttol = &mged_ttol;
  mged_initial_tree_state.ts_tol = &mged_tol;

  if( db_walk_tree( dbip, argc-1, (const char **)argv+1, 1,
		    &mged_initial_tree_state,
		    0, 0, pathlist_leaf_func, (genptr_t)NULL ) < 0 )  {
    Tcl_AppendResult(interp, "db_walk_tree() error", (char *)NULL);
    return TCL_ERROR;
  }

  return TCL_OK;
d378 1
a378 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
d437 1
a437 1
	if(BU_LIST_IS_EMPTY(&HeadSolid.l)) {
d468 1
a468 1
	illump = BU_LIST_NEXT(solid, &HeadSolid.l);/* any valid solid would do */
@


11.75
log
@*- modified commands to use new librt routines
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.74 2001/04/05 19:35:43 morrison Exp $ (BRL)";
a63 79
/* Rename an object */
/* Format: mv oldname newname	*/
int
f_name(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return wdb_move_cmd(wdbp, interp, argc, argv);
}

/* Copy an object */
/* Format: cp oldname newname	*/
int
f_copy(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	register struct directory *proto;
	register struct directory *dp;
	struct bu_external external;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 3 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help cp");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (proto = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;

	if( db_lookup( dbip,  argv[2], LOOKUP_QUIET ) != DIR_NULL )  {
	  aexists( argv[2] );
	  return TCL_ERROR;
	}

	if( db_get_external( &external , proto , dbip ) ) {
	  TCL_READ_ERR_return;
	}

	/* no interuprts */
	(void)signal( SIGINT, SIG_IGN );

	if( (dp=db_diradd( dbip, argv[2], -1L, 0, proto->d_flags, &proto->d_minor_type)) == DIR_NULL )  {
	  TCL_ALLOC_ERR_return;
	}

	if (db_put_external( &external, dp, dbip ) < 0 )
	{
	  db_free_external( &external );
	  TCL_WRITE_ERR_return;
	}
	db_free_external( &external );

	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = argv[2]; /* depends on solid name being in argv[2] */
	  av[2] = NULL;

	  /* draw the new object */
	  return f_edit( clientData, interp, 2, av );
	}
}

a121 111
/* add solids to a region or create the region */
/* and then add solids */
/* Format: r regionname opr1 sol1 opr2 sol2 ... oprn soln */
int
f_region(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return wdb_region_cmd(wdbp, interp, argc, argv);
}

/*
 *			F _ C O M B
 *
 *  Create or add to the end of a combination, with one or more solids,
 *  with explicitly specified operations.
 *
 *  Format: comb comb_name sol1 opr2 sol2 ... oprN solN
 */
int
f_comb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	register struct directory *dp;
	char	*comb_name;
	register int	i;
	char	oper;
	struct bu_list	head;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	BU_LIST_INIT( &head );

	if(argc < 4){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help comb");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* Check for odd number of arguments */
	if( argc & 01 )  {
	  Tcl_AppendResult(interp, "error in number of args!\n", (char *)NULL);
	  return TCL_ERROR;
	}

	/* Save combination name, for use inside loop */
	comb_name = argv[1];
	if( (dp=db_lookup( dbip, comb_name, LOOKUP_QUIET )) != DIR_NULL )
	{
		if( !(dp->d_flags & DIR_COMB))
		{
			Tcl_AppendResult(interp, "ERROR: ", comb_name, " is not a combination\n", (char *)0 );
			return TCL_ERROR;
		}
	}

	/* Get operation and solid name for each solid */
	for( i = 2; i < argc; i += 2 )  {
		if( argv[i][1] != '\0' )  {
		  Tcl_AppendResult(interp, "bad operation: ", argv[i],
				   " skip member: ", argv[i+1], "\n", (char *)NULL);
		  continue;
		}
		oper = argv[i][0];
		if( (dp = db_lookup( dbip,  argv[i+1], LOOKUP_NOISY )) == DIR_NULL )  {
		  Tcl_AppendResult(interp, "skipping ", argv[i+1], "\n", (char *)NULL);
		  continue;
		}

		if(oper != WMOP_UNION && oper != WMOP_SUBTRACT && oper != WMOP_INTERSECT) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "bad operation: %c skip member: %s\n",
				oper, dp->d_namep );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			continue;
		}

		/* Add to the list */
		(void)mk_addmember( argv[i+1], &head, oper );
	}

	/* Do them all at once */
	if( mk_comb( wdbp, comb_name, &head,
	    0, NULL, NULL, NULL,
	    0, 0, 0, 0,
	    0, 1, 1 ) < 0 )
	{
		Tcl_AppendResult(interp,
			"An error has occured while adding '",
			comb_name, "' to the database.\n", (char *)NULL);
		TCL_ERROR_RECOVERY_SUGGESTION;
		return TCL_ERROR;
	}
	return TCL_OK;
}

a224 15
}

/* Delete members of a combination */
/* Format: rm comb memb1 memb2 .... membn	*/
int
f_rm(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return wdb_remove_cmd(wdbp, interp, argc, argv);
@


11.74
log
@updated SIGNED to signed
updated CONST to const
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.73 2001/04/02 21:38:18 morrison Exp $ (BRL)";
a72 3
	register struct directory *dp;
	struct rt_db_internal	intern;

d76 1
a76 36
	if(argc < 3 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help mv");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;

	if( db_lookup( dbip,  argv[2], LOOKUP_QUIET ) != DIR_NULL )  {
	  aexists( argv[2] );
	  return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR_return;
	}

	/*  Change object name in the in-memory directory. */
	if( db_rename( dbip, dp, argv[2] ) < 0 )  {
		rt_db_free_internal( &intern, &rt_uniresource );
	  Tcl_AppendResult(interp, "error in db_rename to ", argv[2],
			   ", aborting\n", (char *)NULL);
	  TCL_ERROR_RECOVERY_SUGGESTION;
	  return TCL_ERROR;
	}

	/* Re-write to the database.  New name is applied on the way out. */
	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
a210 12
#if 0
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return invoke_db_wrapper(interp, argc, argv);
#else
	register struct directory *dp;
	int i;
	int ident, air;
	char oper;
	struct bu_list head;

d214 1
a214 84
	BU_LIST_INIT(&head);

	if(argc < 4){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help r");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

 	ident = item_default;
 	air = air_default;
 
	/* Check for even number of arguments */
	if( argc & 01 )  {
	  Tcl_AppendResult(interp, "error in number of args!\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip, argv[1], LOOKUP_QUIET) == DIR_NULL ) {
		/* will attempt to create the region */
		if(item_default) {
		  struct bu_vls tmp_vls;

		  item_default++;
		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "Defaulting item number to %d\n", item_default);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
	}

	/* Get operation and solid name for each solid */
	for( i = 2; i < argc; i += 2 )  {
		if( argv[i][1] != '\0' )  {
		  Tcl_AppendResult(interp, "bad operation: ", argv[i],
				   " skip member: ", argv[i+1], "\n", (char *)NULL);
		  continue;
		}
		oper = argv[i][0];
		if( (dp = db_lookup( dbip,  argv[i+1], LOOKUP_NOISY )) == DIR_NULL )  {
		  Tcl_AppendResult(interp, "skipping ", argv[i+1], "\n", (char *)NULL);
		  continue;
		}

		if(oper != WMOP_UNION && oper != WMOP_SUBTRACT &&	oper != WMOP_INTERSECT) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "bad operation: %c skip member: %s\n",
				oper, dp->d_namep );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  continue;
		}

		/* Adding region to region */
		if( dp->d_flags & DIR_REGION )  {
		    Tcl_AppendResult(interp, "Note: ", dp->d_namep,
				     " is a region\n", (char *)NULL);
		}

		mk_addmember( argv[i+1], &head, oper );
	}

	if( mk_comb( wdbp, argv[1], &head,
	    1, NULL, NULL, NULL,
	    ident, air, mat_default, los_default,
	    0, 1, 1 ) < 0 )
	{
		/* failed to create region */
		if(item_default > 1)
			item_default--;

		Tcl_AppendResult(interp,
			"An error has occured while adding '",
			argv[1], "' to the database.\n", (char *)NULL);
		TCL_ERROR_RECOVERY_SUGGESTION;
		return TCL_ERROR;
	}
	return TCL_OK;
#endif
d429 1
a429 1
	return invoke_db_wrapper(interp, argc, argv);
@


11.73
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.72 2001/03/31 01:57:20 morrison Exp $ (BRL)";
d703 1
a703 1
	if( !(anp = db_parse_1anim( dbip, argc, (CONST char **)argv ) ) )  {
d835 1
a835 1
  if( db_walk_tree( dbip, argc-1, (CONST char **)argv+1, 1,
@


11.72
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.71 2001/03/23 22:05:32 jra Exp $ (BRL)";
d1164 1
a1164 1
    mat_idn(ts.ts_mat);
@


11.71
log
@Support for major and minor types in directory structure
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgtree.c,v 11.70 2001/03/23 21:19:45 bparker Exp $ (BRL)";
d726 1
a726 1
	bn_mat_idn( stack );
d951 1
a951 1
	bn_mat_idn( modelchanges );	/* No changes yet */
@


11.70
log
@*- temporarily put back old f_region code
   until LIBRT's version gets fixed.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgtree.c,v 11.69 2001/03/23 16:07:37 bparker Exp $ (BRL)";
d158 1
a158 1
	if( (dp=db_diradd( dbip, argv[2], -1L, 0, proto->d_flags, NULL)) == DIR_NULL )  {
d624 1
a624 1
	if( (dp = db_diradd( dbip, argv[2], -1L, 0, proto->d_flags, NULL)) == DIR_NULL )  {
@


11.69
log
@*- convert rm and r to use LIBRT's routines
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgtree.c,v 11.68 2000/10/20 05:04:37 mike Exp $ (BRL)";
d249 1
d254 94
@


11.68
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.67 2000/09/21 02:46:51 mike Exp $ (BRL)";
a248 6
	register struct directory *dp;
	int i;
	int ident, air;
	char oper;
	struct bu_list head;

d252 1
a252 83
	BU_LIST_INIT(&head);

	if(argc < 4){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help r");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

 	ident = item_default;
 	air = air_default;
 
	/* Check for even number of arguments */
	if( argc & 01 )  {
	  Tcl_AppendResult(interp, "error in number of args!\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip, argv[1], LOOKUP_QUIET) == DIR_NULL ) {
		/* will attempt to create the region */
		if(item_default) {
		  struct bu_vls tmp_vls;

		  item_default++;
		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "Defaulting item number to %d\n", item_default);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
	}

	/* Get operation and solid name for each solid */
	for( i = 2; i < argc; i += 2 )  {
		if( argv[i][1] != '\0' )  {
		  Tcl_AppendResult(interp, "bad operation: ", argv[i],
				   " skip member: ", argv[i+1], "\n", (char *)NULL);
		  continue;
		}
		oper = argv[i][0];
		if( (dp = db_lookup( dbip,  argv[i+1], LOOKUP_NOISY )) == DIR_NULL )  {
		  Tcl_AppendResult(interp, "skipping ", argv[i+1], "\n", (char *)NULL);
		  continue;
		}

		if(oper != WMOP_UNION && oper != WMOP_SUBTRACT &&	oper != WMOP_INTERSECT) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "bad operation: %c skip member: %s\n",
				oper, dp->d_namep );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  continue;
		}

		/* Adding region to region */
		if( dp->d_flags & DIR_REGION )  {
		    Tcl_AppendResult(interp, "Note: ", dp->d_namep,
				     " is a region\n", (char *)NULL);
		}

		mk_addmember( argv[i+1], &head, oper );
	}

	if( mk_comb( wdbp, argv[1], &head,
	    1, NULL, NULL, NULL,
	    ident, air, mat_default, los_default,
	    0, 1, 1 ) < 0 )
	{
		/* failed to create region */
		if(item_default > 1)
			item_default--;

		Tcl_AppendResult(interp,
			"An error has occured while adding '",
			argv[1], "' to the database.\n", (char *)NULL);
		TCL_ERROR_RECOVERY_SUGGESTION;
		return TCL_ERROR;
	}
	return TCL_OK;
a463 7
	register struct directory *dp;
	register int	i;
	int		num_deleted;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int			ret;

d467 1
a467 46
	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help rm");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
	  return TCL_ERROR;

	if( (dp->d_flags & DIR_COMB) == 0 )  {
		Tcl_AppendResult(interp, "rm: ", dp->d_namep,
			" is not a combination\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
		TCL_READ_ERR_return;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	/* Process each argument */
	num_deleted = 0;
	ret = TCL_OK;
	for( i = 2; i < argc; i++ )  {
		if( db_tree_del_dbleaf( &(comb->tree), argv[i], &rt_uniresource ) < 0 )  {
			Tcl_AppendResult(interp, "  ERROR_deleting ",
				dp->d_namep, "/", argv[i],
				"\n", (char *)NULL);
			ret = TCL_ERROR;
		} else {
			Tcl_AppendResult(interp, "deleted ",
				dp->d_namep, "/", argv[i],
				"\n", (char *)NULL);
			num_deleted++;
		}
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
		TCL_WRITE_ERR_return;
	}
	return ret;
@


11.67
log
@
Need to initialize ts.ts_resp
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.66 2000/09/08 05:55:47 mike Exp $ (BRL)";
a898 1
	int			i;
d904 1
a904 16
		int not_this_solid=0;

		if( pathp->fp_len != sp->s_last+1 )
			continue;

		for( i=0 ; i<pathp->fp_len ; i++ )
		{
			if( pathp->fp_names[i] != sp->s_path[i] )
			{
				not_this_solid = 1;
				break;
			}
		}

		if( not_this_solid )
			continue;
@


11.66
log
@
Tree routines now need resource structure.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.65 2000/09/07 02:23:42 mike Exp $ (BRL)";
d1222 1
a1222 1
    bzero((char *) &ts, sizeof(ts));
d1224 1
@


11.65
log
@
Added externs to ged.h to fix lint
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.64 2000/08/24 02:54:14 mike Exp $ (BRL)";
d97 1
a97 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d103 1
a103 1
		rt_db_free_internal( &intern );
d111 1
a111 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d581 1
a581 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d591 1
a591 1
		if( db_tree_del_dbleaf( &(comb->tree), argv[i] ) < 0 )  {
d604 1
a604 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d650 1
a650 1
	if( (id = rt_db_get_internal( &internal, proto, dbip, (fastf_t *)NULL )) < 0 )  {
d658 1
a658 1
		rt_db_free_internal( &internal );
d672 1
a672 1
	if( rt_db_put_internal( dp, dbip, &internal ) < 0 )  {
d780 1
a780 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d814 1
a814 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
d822 1
a822 1
	rt_db_free_internal( &intern );
d1240 1
a1240 1
    switch (rt_db_lookup_internal(dbip, parent, &dp, &intern, LOOKUP_NOISY))
d1292 1
a1292 1
    if (rt_db_put_internal(dp, dbip, &intern) < 0)
d1305 1
a1305 1
	rt_db_free_internal(&intern);
@


11.64
log
@
Changed from combadd() to mk_comb().
Main benefit is not taking a trip to the database as we add each member
to the combination.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.63 2000/08/19 03:10:11 mike Exp $ (BRL)";
d67 5
a71 5
f_name(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d441 5
a445 5
f_kill(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.63
log
@
Reduced use of MAXARGS
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.62 2000/08/09 20:51:37 mike Exp $ (BRL)";
a189 1
	register struct directory *dp;
d191 1
d196 2
d208 1
a208 1
	if( (dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
d223 1
a223 2
	if( combadd( dp, argv[2], 0, oper, 0, 0 ) == DIR_NULL )
	  return TCL_ERROR;
d225 11
d253 1
d258 2
d322 1
a322 4
		if( combadd( dp, argv[1], 1, oper, ident, air ) == DIR_NULL )  {
		  Tcl_AppendResult(interp, "error in combadd\n", (char *)NULL);
		  return TCL_ERROR;
		}
d325 5
a329 1
	if( db_lookup( dbip, argv[1], LOOKUP_QUIET) == DIR_NULL ) {
d333 5
a339 1

d362 1
d367 2
d409 1
a409 1
		if(oper != WMOP_UNION && oper != WMOP_SUBTRACT &&	oper != WMOP_INTERSECT) {
d419 2
a420 4
		if( combadd( dp, comb_name, 0, oper, 0, 0 ) == DIR_NULL )  {
		  Tcl_AppendResult(interp, "error in combadd\n", (char *)NULL);
		  return TCL_ERROR;
		}
d423 11
a433 4
	if( db_lookup( dbip, comb_name, LOOKUP_QUIET) == DIR_NULL ) {
	  Tcl_AppendResult(interp, "Error:  ", comb_name,
			   " not created\n", (char *)NULL);
	  return TCL_ERROR;
a434 1

a500 1
	register struct directory *dp;
d502 1
d507 2
d521 3
a523 4
		if( (dp = db_lookup( dbip,  argv[i], LOOKUP_NOISY)) != DIR_NULL )  {
			if( combadd( dp, argv[1], 0,
				     WMOP_UNION, 0, 0) == DIR_NULL )
			  return TCL_ERROR;
d526 13
@


11.62
log
@
If storage hasn't been allocated, don't specify a size.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.61 2000/07/11 23:14:23 mike Exp $ (BRL)";
d245 1
a245 1
	if(argc < 4 || MAXARGS < argc){
d346 1
a346 1
	if(argc < 4 || MAXARGS < argc){
d429 1
a429 1
	if(argc < 2 || MAXARGS < argc){
d480 1
a480 1
	if(argc < 3 || MAXARGS < argc){
d521 1
a521 1
	if(argc < 3 || MAXARGS < argc){
d690 1
a690 1
	if(argc < 3 || MAXARGS < argc){
d826 1
a826 1
  if(argc < 2 || MAXARGS < argc){
d1057 1
a1057 1
    if(argc < 3 || MAXARGS < argc){
@


11.61
log
@
moved wdb.h include after raytrace.h
Moved externs into raytrace.h
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.60 2000/07/10 22:59:54 mike Exp $ (BRL)";
d158 1
a158 1
	if( (dp=db_diradd( dbip, argv[2], -1, proto->d_len, proto->d_flags, NULL)) == DIR_NULL )  {
@


11.60
log
@
No need to call db_alloc(), that's taken care of by db_put_external().
It will probably change size anyway after being renamed.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.59 2000/06/28 16:11:06 mike Exp $ (BRL)";
a46 1
#include "wdb.h"
d49 1
a55 7

/* XXX Move to raytrace.h */
BU_EXTERN(struct animate	*db_parse_1anim, (struct db_i *dbip,
				int argc, CONST char **argv));
BU_EXTERN(union tree		*db_find_named_leaf, (union tree *tp,
				CONST char *cp));

@


11.59
log
@
db_walk_tree() leaf method calling sequence changed.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.59 2000/06/28 16:11:06 mike Exp $ (BRL)";
d165 1
a165 2
	if( (dp=db_diradd( dbip, argv[2], -1, proto->d_len, proto->d_flags, NULL)) == DIR_NULL ||
	    db_alloc( dbip, dp, proto->d_len ) < 0 )  {
@


11.58
log
@*- forgot to do this last time
(i.e. the dpp argument to eraseobj and eraseobjall
needs to be a NULL terminated array)
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.57 2000/05/26 14:00:42 bparker Exp $ (BRL)";
d798 1
a798 1
pathlist_leaf_func( tsp, pathp, ext, id, client_data )
d801 1
a801 2
struct bu_external	*ext;
int			id;
d807 1
@


11.57
log
@*- mods that reflect parameter changes to
   eraseobj and eraseobjall
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.56 2000/01/31 15:09:58 jra Exp $ (BRL)";
d428 5
a432 4
	register int i;
	struct directory *dp;
	int	is_phony;
	int	verbose = LOOKUP_NOISY;
d456 2
a457 1
			eraseobjall(&dp);
@


11.56
log
@Eliminated some unused variables
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.55 2000/01/08 03:19:48 mike Exp $ (BRL)";
a427 1
	register struct directory *dp;
d429 1
d455 1
a455 1
			eraseobjall( dp );
@


11.55
log
@
Fixed putmat command to accept my matrix.
Now (finally) my Tcl script works, which says things like:
set mat "1 0 0 [expr stuff] ..... 0 1"
putmat $comb/proto $mat
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.54 2000/01/04 17:58:21 bparker Exp $ (BRL)";
a1054 1
    int			i;			/* Dummy loop index */
a1055 2
    char		*ep;			/* Matrix element */
    char		*eep;			/* End of element */
@


11.54
log
@*- add client_data to db_walk_tree
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.53 1999/12/30 19:29:48 jra Exp $ (BRL)";
d1059 1
a1059 1
    char		*newargv[20];
d1061 1
d1098 6
a1103 1
	    /* This case falls through intentionally */
d1105 1
a1105 1
	  Tcl_AppendResult(interp, "error in matrix specification\n", (char *)NULL);
d1113 3
a1115 5
    ep = bu_vls_addr(avp);
    for (i = 0; i < 16; ++i)
    {
	if ((eep = strchr(ep, ' ')) == NULL && i < 15)
	{
d1119 2
a1120 2
	  bu_vls_printf(&tmp_vls, "%s:%d: bad matrix.  This shouldn't happen\n",
			__FILE__, __LINE__);
d1122 1
a1123 8
	  break;
	}
	newargv[4 + i] = ep;
    	if( eep )
    	{
		*eep = '\0';
		ep = eep + 1;
    	}
@


11.53
log
@Eliminated some unused variables
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.52 1999/12/29 23:23:18 mike Exp $ (BRL)";
d796 1
a796 1
pathlist_leaf_func( tsp, pathp, ext, id )
d801 1
d847 1
a847 1
		    0, 0, pathlist_leaf_func ) < 0 )  {
@


11.52
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.51 1999/11/26 23:03:30 mike Exp $ (BRL)";
a429 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
a521 1
	union tree		*tp;
a688 2
	mat_t			arc;
	int			i;
@


11.51
log
@
Lint
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.50 1999/09/01 18:55:09 bparker Exp $ (BRL)";
d165 1
a165 1
	if( (dp=db_diradd( dbip, argv[2], -1, proto->d_len, proto->d_flags)) == DIR_NULL ||
d637 1
a637 1
	if( (dp = db_diradd( dbip, argv[2], -1L, 0, proto->d_flags)) == DIR_NULL )  {
@


11.50
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.49 1999/04/16 18:00:02 bparker Exp $ (BRL)";
d104 1
a104 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d549 1
a549 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d618 1
a618 1
	if( (id = rt_db_get_internal( &internal, proto, dbip, (mat_t *)NULL )) < 0 )  {
d750 1
a750 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
@


11.49
log
@*- call solid_list_callback whenever the solid
   list gets changed.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.48 1999/01/12 18:21:54 bparker Exp $ (BRL)";
d83 1
a83 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d137 1
a137 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d201 1
a201 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d250 1
a250 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d351 1
a351 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d435 1
a435 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d485 1
a485 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d527 1
a527 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d597 1
a597 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d698 1
a698 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d834 1
a834 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d931 1
a931 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1066 1
a1066 3
    if(dbip == DBI_NULL)
      return TCL_OK;

d1166 1
a1166 3
    if(dbip == DBI_NULL)
      return TCL_OK;

@


11.48
log
@*- some cleanup
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.47 1999/01/07 18:39:59 jra Exp $ (BRL)";
d64 1
d481 1
@


11.47
log
@pathlist command wasn't correctly checking its argc.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.46 1998/11/13 22:31:21 bparker Exp $ (BRL)";
a478 11

#ifdef DO_SINGLE_DISPLAY_LIST
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
	    save_dmlp = curr_dm_list;
	    curr_dm_list = dmlp;
	    createDList(&HeadSolid);
	    curr_dm_list = save_dmlp;
	  }
	}
#endif
@


11.46
log
@*- fixed typo
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.45 1998/11/06 22:16:59 bparker Exp $ (BRL)";
d866 1
a866 1
  if(argc < 1 || MAXARGS < argc){
@


11.45
log
@*- use new structure
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgtree.c,v 11.44 1997/09/08 19:05:59 bparker Exp $ (BRL)";
d482 1
a482 1
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables.mv_dlist){
@


11.44
log
@new macro ---> FOR_ALL_DISPLAYS
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.43 1997/09/03 14:19:20 bparker Exp bparker $ (BRL)";
d482 1
a482 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
@


11.43
log
@mods to implement new display lists
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.42 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d481 1
a481 1
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
@


11.42
log
@mods to run without a database
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.41 1997/05/02 15:32:11 jra Exp bparker $ (BRL)";
d439 2
d479 12
@


11.41
log
@f_comb() wasn't checking if existing combaination was actually a combination.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.40 1997/04/24 18:03:58 bparker Exp jra $ (BRL)";
d82 3
d138 3
d204 3
d255 3
d358 3
d442 3
d492 3
d536 3
d608 3
d711 3
d849 3
d947 3
d1083 3
d1184 3
@


11.40
log
@modify calls to Tcl_Eval
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.39 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d366 8
@


11.39
log
@mods so that commands check args internally
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.38 1997/04/14 12:29:36 bparker Exp bparker $ (BRL)";
d85 6
a90 1
	  Tcl_Eval(interp, "help mv");
d138 6
a143 1
	  Tcl_Eval(interp, "help cp");
d201 6
a206 1
	  Tcl_Eval(interp, "help i");
d249 6
a254 1
	  Tcl_Eval(interp, "help r");
d349 6
a354 1
	  Tcl_Eval(interp, "help comb");
d422 6
a427 1
	  Tcl_Eval(interp, "help kill");
d469 6
a474 1
	  Tcl_Eval(interp, "help g");
d510 7
a516 2
	      Tcl_Eval(interp, "help rm");
	          return TCL_ERROR;
d579 6
a584 1
	  Tcl_Eval(interp, "help cpi");
d679 6
a684 1
	  Tcl_Eval(interp, "help arced");
d812 6
a817 1
    Tcl_Eval(interp, "help pathlist");
d821 2
a822 2
	mged_initial_tree_state.ts_ttol = &mged_ttol;
	mged_initial_tree_state.ts_tol = &mged_tol;
d824 6
a829 6
	if( db_walk_tree( dbip, argc-1, (CONST char **)argv+1, 1,
			 &mged_initial_tree_state,
			 0, 0, pathlist_leaf_func ) < 0 )  {
	    	Tcl_AppendResult(interp, "db_walk_tree() error", (char *)NULL);
		return TCL_ERROR;
	}
d831 1
a831 1
	return TCL_OK;
d907 6
a912 1
	  Tcl_Eval(interp, "help oed");
d1042 6
a1047 1
      Tcl_Eval(interp, "help putmat");
d1141 6
a1146 1
      Tcl_Eval(interp, "help copymat");
@


11.38
log
@now calling eraseobjall()
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.37 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d84 2
a85 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d87 1
d132 2
a133 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d135 1
d190 2
a191 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d193 1
d233 2
a234 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d236 1
d328 2
a329 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d331 1
d396 2
a397 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d399 1
d438 2
a439 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d441 1
d474 4
a477 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d538 2
a539 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d541 1
d633 2
a634 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d636 1
d761 4
a764 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d851 2
a852 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d854 1
d979 1
a979 1
	CHECK_READ_ONLY;
d981 2
a982 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d984 1
d1073 1
a1073 1
	CHECK_READ_ONLY;
d1075 2
a1076 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1078 1
@


11.37
log
@Mods to support MGED's read-only mode.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.36 1997/03/13 21:39:40 bparker Exp jra $ (BRL)";
d398 2
a399 2
			eraseobj( dp );
			/* eraseobj() does db_dirdelete() on phony entries, don't re-do. */
@


11.36
log
@fixed typo
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.35 1997/03/13 19:11:53 jra Exp bparker $ (BRL)";
d82 2
d128 2
d184 2
d225 2
d318 2
d384 2
d424 2
d458 2
d519 2
a520 1
	int ngran;
d613 2
d955 2
d1046 2
@


11.35
log
@Fixed bug in f_putmat.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.34 1997/02/20 16:24:37 pjt Exp jra $ (BRL)";
d516 1
a516 1
	if( (id = rt_db_get_internal( &internal, dp, dbip, (mat_t *)NULL )) < 0 )  {
@


11.34
log
@Fixed f_copymat
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.33 1997/02/19 21:14:58 pjt Exp $ (BRL)";
d974 1
a974 1
	if ((eep = strchr(ep, ' ')) == NULL)
d986 5
a990 2
	*eep = '\0';
	ep = eep + 1;
@


11.33
log
@COB 19 Feb
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.32 1997/02/18 21:21:19 pjt Exp $ (BRL)";
a996 33
int
get_comb_internal (dbip, comb_name, dpp, ip, noisy)

struct db_i		*dbip;
char			*comb_name;
struct directory	**dpp;
struct rt_db_internal	*ip;
int			noisy;

{
    struct directory		*dp;
    struct rt_comb_internal	*comb;

    if (comb_name == (char *) 0)
    {
	if (noisy == LOOKUP_NOISY)
	    bu_log("No combination specified\n");
	return ID_NULL;
    }
    if ((dp = db_lookup(dbip, comb_name, noisy)) == DIR_NULL)
	return ID_NULL;
    if (rt_db_get_internal(ip, dp, dbip, (mat_t *) NULL ) < 0 )
    {
	if (noisy == LOOKUP_NOISY)
	    bu_log("Failed to get internal form of object '%s'\n",
		dp -> d_namep);
	return ID_NULL;
    }

    *dpp = dp;
    return (ip -> idb_type);
}

d1037 1
a1037 1
		"Bad arc: '", argv[i], "'\n", (char *) NULL);
d1052 2
a1053 1
	    "Cannot follow path for arc: '", argv[1], "'\n", (char *) NULL);
d1062 1
a1062 3
    if ((comb = get_comb_internal(dbip, parent, &dp, &intern, LOOKUP_NOISY))
	    == ID_NULL)
	    /* XXX check for ID_COMBINATION */
d1064 21
a1084 8
	bu_vls_free(&pvls);
	return TCL_ERROR;
    }
    if ((dp -> d_flags & DIR_COMB) == 0)
    {
	bu_log("Object '%s' not a combination\n", parent);
	status = TCL_ERROR;
	goto wrapup;
d1086 1
a1086 1
    comb = (struct rt_comb_internal *) intern.db_ptr;
d1091 1
a1091 1
	Tcl_AppendResult(interp, "Unable to find instance of '",
@


11.32
log
@Fleshed out f_copymat a bit more
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.31 1997/02/12 21:17:52 pjt Exp pjt $ (BRL)";
d997 33
d1044 2
d1047 2
a1048 1
    mat_t			matrix;
d1050 3
d1054 1
d1065 1
a1065 1
    for (i = 1; i < 2; ++i)
d1067 1
a1067 1
	 || (strchr(child + 1, '/') != NULL))
a1072 3
	else
	    Tcl_AppendResult(interp,
		"OK, we have '", argv[i], "'\n", (char *) NULL);
d1085 1
a1085 1
	    "Cannot follow path for arc: '", argv[i], "'\n", (char *) NULL);
d1089 20
a1108 3
    matrix_print(ts.ts_mat);
    /* MAT_COPY(to,from) */
    install_mat(matrix, argv[2]);
d1110 8
a1117 2
    return TCL_OK;
}
d1119 15
a1133 2
HIDDEN int
accumulate_mat (matrix, path)
d1135 6
a1140 2
mat_t	matrix;
char	*path;
d1142 1
a1142 5
{
    bu_log("Accumulating the matrices from '%s' into <%x>\n",
	path, matrix);
    return 1;
}
d1144 1
a1144 2
HIDDEN int
install_mat (matrix, path)
d1146 4
a1149 7
mat_t	matrix;
char	*path;

{
    bu_log("Installing the matrix <%x> into '%s'\n",
	matrix, path);
    return 1;
@


11.31
log
@Added stub for copymat command
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.30 1997/01/30 05:38:17 mike Exp $ (BRL)";
d1010 2
d1013 2
d1022 32
a1053 1
    accumulate_mat(&matrix, argv[1]);
@


11.30
log
@Eliminated dependence on db.h
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.29 1997/01/30 05:33:36 mike Exp $ (BRL)";
d995 51
@


11.29
log
@Converted arced to new import/export routines
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.28 1997/01/30 05:04:18 mike Exp mike $ (BRL)";
d47 1
a47 1
#include "db.h"
d186 1
a186 1
	oper = UNION;
d189 1
a189 1
	if(oper != UNION && oper != SUBTRACT &&	oper != INTERSECT) {
d257 1
a257 1
		if(oper != UNION && oper != SUBTRACT &&	oper != INTERSECT) {
d335 1
a335 1
		if(oper != UNION && oper != SUBTRACT &&	oper != INTERSECT) {
d419 1
a419 1
				     UNION, 0, 0) == DIR_NULL )
@


11.28
log
@Minor simplification
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.27 1997/01/30 04:59:50 mike Exp mike $ (BRL)";
d60 2
d63 1
a590 1
	union record		*rec;
d592 3
d610 4
d632 2
a633 1
	dp = anp->an_path.fp_names[0];
d638 3
a640 4
	if( (rec = db_getmrec( dbip, dp )) == (union record *)NULL )  {
	  TCL_READ_ERR;
	  db_free_1anim( anp );
	  return TCL_ERROR;
d642 6
d650 8
a657 3
	for( i=1; i < dp->d_len; i++ )  {
		if( rec[i].u_id != ID_MEMB )  {
		  struct bu_vls tmp_vls;
d659 3
a661 10
		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "%s: element %d not a member! Database corrupted.\n",
				dp->d_namep, i);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  goto fail;
		}
		if( strncmp( rec[i].M.m_instname,
		    anp->an_path.fp_names[1]->d_namep,
		    NAMESIZE ) != 0 )  continue;
d663 3
a665 3
		/* Found match */
		/* XXX For future, also import/export materials here */
		rt_mat_dbmat( arc, rec[i].M.m_mat );
d667 4
a670 4
		if( db_do_anim( anp, stack, arc, NULL ) < 0 )  {
			goto fail;
		}
		rt_dbmat_mat( rec[i].M.m_mat, arc );
d672 3
a674 9
		/* Write back */
		if( db_put( dbip, dp, rec, 0, dp->d_len ) < 0 )  {
		  Tcl_AppendResult(interp, "arced: write error, aborting\n", (char *)NULL);
		  TCL_ERROR_RECOVERY_SUGGESTION;
		  goto fail;
		}
		bu_free( (genptr_t)rec, "union record []");
		db_free_1anim( anp );
		return TCL_OK;
d676 2
a677 4

	Tcl_AppendResult(interp, "Unable to find instance of '",
			 anp->an_path.fp_names[1]->d_namep, "' in combination '",
			 anp->an_path.fp_names[0]->d_namep, "', error\n", (char *)NULL);
d680 1
a680 1
	bu_free( (genptr_t)rec, "union record []");
@


11.27
log
@Killed off one more union record.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.26 1997/01/30 04:57:26 mike Exp mike $ (BRL)";
d624 4
a631 4
	}
	if( rec[0].u_id != ID_COMB )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
	  goto fail;
@


11.26
log
@Converted copy_inv to new import/export interface
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.25 1997/01/30 04:50:07 mike Exp mike $ (BRL)";
a211 1
	union record record;
d265 2
a266 6
		if( db_get( dbip,  dp, &record, 0 , 1) < 0 ) {
		  TCL_READ_ERR_return;
		}
		
		if( record.u_id == ID_COMB ) {
		  if( record.c.c_flags == 'R' ) {
a268 1
		  }
@


11.25
log
@Converted 'mv' command to new import/export interface.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.24 1997/01/30 02:17:14 mike Exp mike $ (BRL)";
d57 4
a502 1
	struct bu_external external;
d519 2
a520 3
	/* get external representation of slid to be copied */
	if( db_get_external( &external, proto, dbip )) {
	  TCL_READ_ERR_return;
a521 1

a522 1
	id = rt_id_solid( &external );
d527 2
a528 2
	  db_free_external( &external );
	  return TCL_ERROR;
a529 10

	/* import the TGC */
	if( rt_functab[id].ft_import( &internal , &external , bn_mat_identity ) < 0 )
	{
	  Tcl_AppendResult(interp, "f_copy_inv: import failure for ",
			   argv[1], "\n", (char *)NULL);
	  return TCL_ERROR;
	}
	db_free_external( &external );

a534 13
	/* now export the new TGC */
	if( rt_functab[internal.idb_type].ft_export( &external, &internal, (double)1.0 ) < 0 )
	{
	  Tcl_AppendResult(interp, "f_copy_inv: export failure\n", (char *)NULL);
	  rt_functab[internal.idb_type].ft_ifree( &internal );
	  return TCL_ERROR;
	}
	rt_functab[internal.idb_type].ft_ifree( &internal );   /* free internal rep */

	/*
	 * Update the disk record
	 */

d538 1
a538 5
	ngran = (external.ext_nbytes+sizeof(union record)-1) / sizeof(union record);
	if( (dp = db_diradd( dbip, argv[2], -1L, ngran, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, 1 ) < 0 )
	    {
	    	db_free_external( &external );
d540 2
a541 5
	    }

	if (db_put_external( &external, dp, dbip ) < 0 )
	{
		db_free_external( &external );
a543 1
	db_free_external( &external );
a568 4

/* XXX Move to raytrace.h */
BU_EXTERN(struct animate	*db_parse_1anim, (struct db_i *dbip,
				int argc, CONST char **argv));
@


11.24
log
@Eliminated rt_get_comb.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.23 1997/01/29 00:33:08 mike Exp mike $ (BRL)";
d64 1
a64 1
/* Format: n oldname newname	*/
d73 1
a73 1
	union record record;
d86 8
a93 4
	/*  Change object name in the directory. */
	if( db_rename( dbip, dp, argv[2] ) < 0 ||
	    db_get( dbip,  dp, &record, 0 , 1) < 0 )  {
	  Tcl_AppendResult(interp, "error in rename to ", argv[2],
d99 3
a101 4
	/* Change name in the file */
	NAMEMOVE( argv[2], record.c.c_name );
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 ){
	  TCL_WRITE_ERR_return;
a102 1

@


11.23
log
@Changed calling sequence, improved log/error messages
of "rm" command to be useful to TCL scripts.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.22 1997/01/26 02:59:23 mike Exp mike $ (BRL)";
d453 2
a454 4
	if( rt_get_comb( &intern, dp, (mat_t *)NULL, dbip ) < 0 )  {
		Tcl_AppendResult(interp, "rt_get_comb(", dp->d_namep,
			") failure", (char *)NULL );
		return TCL_ERROR;
d477 1
a477 2
		Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
		return TCL_ERROR;
a478 1

@


11.22
log
@Changed from using db_delrec() to using db_tree_del_dbleaf().
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/mged/RCS/chgtree.c,v 11.21 1997/01/02 19:36:55 bparker Exp mike $ (BRL)";
d465 4
a468 5
		Tcl_AppendResult(interp, "deleting member ", argv[i],
				   "\n", (char *)NULL);
		if( db_tree_del_dbleaf( comb->tree, argv[i] ) < 0 )  {
			Tcl_AppendResult(interp, "  ERROR in deleting member ",
				argv[1], "\n", (char *)NULL);
d471 3
@


11.21
log
@mods to use libbn and libbu
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.20 1996/12/23 20:08:46 jra Exp bparker $ (BRL)";
d425 1
a425 1
/* Format: D comb memb1 memb2 .... membn	*/
d434 6
a439 2
	register int i, rec, num_deleted;
	union record record;
d447 15
a461 1
	/* Examine all the Member records, one at a time */
d463 10
a472 4
top:
	for( rec = 1; rec < dp->d_len; rec++ )  {
		if( db_get( dbip,  dp, &record, rec , 1) < 0 ) {
		  TCL_READ_ERR_return;
d474 1
a474 4
		/* Compare this member to each command arg */
		for( i = 2; i < argc; i++ )  {
		  if( strcmp( argv[i], record.M.m_instname ) != 0 )
		    continue;
d476 3
a478 10
		  Tcl_AppendResult(interp, "deleting member ", argv[i],
				   "\n", (char *)NULL);
		  if( db_delrec( dbip, dp, rec ) < 0 )  {
		    Tcl_AppendResult(interp, "Error in deleting member.\n", (char *)NULL);
		    TCL_ERROR_RECOVERY_SUGGESTION;
		    return TCL_ERROR;
		  }
		  num_deleted++;
		  goto top;
		}
d481 1
a481 1
	return TCL_OK;
@


11.20
log
@rewrote part of find_solid_with_path() to not use bcmp() (not portable).
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.19 1996/10/04 14:58:11 bparker Exp jra $ (BRL)";
a35 1
#include <math.h>
d38 1
d46 1
d58 1
a58 1
extern struct rt_tol		mged_tol;	/* from ged.c */
d115 1
a115 1
	struct rt_external external;
d485 1
a485 1
	struct rt_external external;
d518 1
a518 1
	if( rt_functab[id].ft_import( &internal , &external , rt_identity ) < 0 )
d647 1
a647 1
	mat_idn( stack );
d714 1
a714 1
struct rt_external	*ext;
d873 1
a873 1
	mat_idn( modelchanges );	/* No changes yet */
@


11.19
log
@cast bu_free's 1st argument to genptr_t
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.18 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d768 1
d774 2
d779 12
a790 4
		if( bcmp( (char *)&pathp->fp_names[0],
			  (char *)&sp->s_path[0],
			  pathp->fp_len * sizeof(struct directory *)
		        ) != 0 )  continue;
@


11.18
log
@now using more generalized solid macros
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.17 1996/09/23 18:37:18 bparker Exp bparker $ (BRL)";
d691 1
a691 1
		bu_free( (char *)rec, "union record []");
d701 1
a701 1
	bu_free( (char *)rec, "union record []");
d724 1
a724 1
	bu_free( str, "path string" );
@


11.17
log
@changed dm.h to mged_dm.h
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.16 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d52 1
a52 1
#include "./solid.h"
d772 1
a772 1
	FOR_ALL_SOLIDS(sp)  {
d827 1
a827 1
	if( HeadSolid.s_forw == &HeadSolid )  {
d858 1
a858 1
	illump = HeadSolid.s_forw;/* any valid solid would do */
@


11.16
log
@rt_list ---> bu_list
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.15 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d53 1
a53 1
#include "./dm.h"
@


11.15
log
@now using libbu
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.14 1996/08/26 17:58:39 bparker Exp bparker $ (BRL)";
d44 1
@


11.14
log
@replace old return values
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.13 1996/07/15 20:36:28 bparker Exp bparker $ (BRL)";
d179 1
a179 1
	  struct rt_vls tmp_vls;
d181 4
a184 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "bad operation: %c\n", oper );
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d224 1
a224 1
		  struct rt_vls tmp_vls;
d227 4
a230 4
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "Defaulting item number to %d\n", item_default);
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d248 1
a248 1
		  struct rt_vls tmp_vls;
d250 2
a251 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "bad operation: %c skip member: %s\n",
d253 2
a254 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d331 1
a331 1
		  struct rt_vls tmp_vls;
d333 2
a334 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "bad operation: %c skip member: %s\n",
d336 1
a336 1
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
d586 1
a586 1
RT_EXTERN(struct animate	*db_parse_1anim, (struct db_i *dbip,
d633 2
a634 2
		rt_log("arced: '%s' is not a 2-element path spec\n");
		rt_free( thepath, "path" );
d662 1
a662 1
		  struct rt_vls tmp_vls;
d664 2
a665 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "%s: element %d not a member! Database corrupted.\n",
d667 2
a668 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d690 1
a690 1
		rt_free( (char *)rec, "union record []");
d700 1
a700 1
	rt_free( (char *)rec, "union record []");
d723 1
a723 1
	rt_free( str, "path string" );
d784 1
a784 1
	  struct rt_vls tmp_vls;
d786 4
a789 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls,"find_solid_with_path() found %d matches\n", count);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d881 1
a881 1
	rt_log("matpick %d\n", lhs.fp_len);
d943 1
a943 1
    struct rt_vls	*avp;
d960 2
a961 2
	    avp = rt_vls_vlsinit();
	    rt_vls_from_argv(avp, 16, argv + 2);
d966 2
a967 2
		avp = rt_vls_vlsinit();
		rt_vls_printf(avp, "1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 ");
d980 1
a980 1
    ep = rt_vls_addr(avp);
d985 1
a985 1
	  struct rt_vls tmp_vls;
d987 2
a988 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "%s:%d: bad matrix.  This shouldn't happen\n",
d990 1
a990 1
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
d1002 1
a1002 1
    rt_vls_vlsfree(avp);
@


11.13
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.12 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d95 3
a97 1
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 ) { WRITE_ERR; return CMD_BAD; }
d619 1
a619 1
	if( not_state( ST_VIEW, "Arc edit" ) )  return CMD_BAD;
d636 1
a636 1
		return CMD_BAD;
d887 1
a887 1
	if( f_matpick( clientData, interp, 2, new_argv ) != CMD_OK )  {
d939 1
a939 1
    int			result = CMD_OK;	/* Return code */
@


11.12
log
@still tcl-converting
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.11 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d144 1
a144 1
	  char *av[] = {"e", NULL, NULL};
d146 1
d148 1
d559 1
a559 1
	  char *av[] = {"e", NULL, NULL};
d561 1
d563 1
d570 1
a570 1
	  char *av[] = {"sed", NULL, NULL};
d572 1
d574 1
@


11.11
log
@convert commands to Tcl
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.10 1996/04/10 18:52:12 pjt Exp bparker $ (BRL)";
d143 8
a150 2
	/* draw the new object */
	return f_edit( clientData, interp, 2, argv+1 );	/* depends on name being in argv[2] ! */
d556 8
a563 2
	/* draw the new solid */
	f_edit( clientData, interp, 2, argv+1 );	/* depends on name being in argv[2] ! */
d566 4
d571 1
a571 1
	  f_sed( clientData, interp, 2, argv+1 );	/* new name in argv[2] */
@


11.10
log
@Commented out check of an_path.fp_len in f_arced()
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.9 1996/02/01 18:32:09 pjt Exp $ (BRL)";
d64 3
a66 1
f_name( argc, argv )
d73 3
d77 1
a77 1
		return CMD_BAD;
d80 2
a81 2
		aexists( argv[2] );
		return CMD_BAD;
d87 4
a90 3
		rt_log("error in rename to %s, aborting\n", argv[2] );
	    	ERROR_RECOVERY_SUGGESTION;
	    	return CMD_BAD;
d97 1
a97 1
	return CMD_OK;
d103 3
a105 1
f_copy( argc, argv )
d113 3
d117 1
a117 1
		return CMD_BAD;
d120 2
a121 2
		aexists( argv[2] );
		return CMD_BAD;
d125 1
a125 2
		READ_ERR;
		return CMD_BAD;
d133 1
a133 2
	    	ALLOC_ERR;
		return CMD_BAD;
d138 2
a139 3
		db_free_external( &external );
		WRITE_ERR;
		return CMD_BAD;
d144 1
a144 1
	return f_edit( 2, argv+1 );	/* depends on name being in argv[2] ! */
d150 3
a152 1
f_instance( argc, argv )
d159 3
d163 1
a163 1
		return CMD_BAD;
d169 7
a175 2
		rt_log("bad operation: %c\n", oper );
		return CMD_BAD;
d178 1
a178 1
		return CMD_BAD;
d180 1
a180 1
	return CMD_OK;
d187 3
a189 1
f_region( argc, argv )
d199 3
d207 2
a208 2
		rt_log("error in number of args!\n");
		return CMD_BAD;
d214 7
a220 2
			item_default++;
			rt_log("Defaulting item number to %d\n", item_default);
d227 3
a229 3
			rt_log("bad operation: %s skip member: %s\n",
				argv[i], argv[i+1] );
			continue;
d233 2
a234 2
			rt_log("skipping %s\n", argv[i+1] );
			continue;
d238 4
a241 1
			rt_log("bad operation: %c skip member: %s\n",
d243 3
a245 1
			continue;
d249 1
a249 2
			READ_ERR;
			return CMD_BAD;
d253 4
a256 5
			if( record.c.c_flags == 'R' ) {
				rt_log(
				     "Note: %s is a region\n",
				     dp->d_namep );
			}
d260 2
a261 2
			rt_log("error in combadd\n");
			return CMD_BAD;
d269 1
a269 1
		return CMD_BAD;
d272 1
a272 1
	return CMD_OK;
d284 3
a286 1
f_comb( argc, argv )
d295 3
d300 2
a301 2
		rt_log("error in number of args!\n");
		return CMD_BAD;
d310 3
a312 3
			rt_log("bad operation: %s skip member: %s\n",
				argv[i], argv[i+1] );
			continue;
d316 2
a317 2
			rt_log("skipping %s\n", argv[i+1] );
			continue;
d321 4
a324 1
			rt_log("bad operation: %c skip member: %s\n",
d326 1
d331 2
a332 2
			rt_log("error in combadd\n");
			return CMD_BAD;
d337 3
a339 2
		rt_log("Error:  %s not created\n", comb_name );
		return CMD_BAD;
d342 1
a342 1
	return CMD_OK;
d348 3
a350 1
f_kill( argc, argv )
d359 3
d377 2
a378 3
			    	DELETE_ERR(argv[i]);
			    	/* Abort kill processing on first error */
				return CMD_BAD;
d382 1
a382 1
	return CMD_OK;
d388 3
a390 1
f_group( argc, argv )
d397 3
d404 2
a405 2
				UNION, 0, 0) == DIR_NULL )
				return CMD_BAD;
d407 1
a407 1
			rt_log("skip member %s\n", argv[i]);
d409 1
a409 1
	return CMD_OK;
d415 3
a417 1
f_rm( argc, argv )
d425 3
d429 1
a429 1
		return CMD_BAD;
d436 1
a436 2
			READ_ERR;
			return CMD_BAD;
d440 12
a451 10
			if( strcmp( argv[i], record.M.m_instname ) != 0 )
				continue;
			rt_log("deleting member %s\n", argv[i] );
			if( db_delrec( dbip, dp, rec ) < 0 )  {
				rt_log("Error in deleting member.\n");
				ERROR_RECOVERY_SUGGESTION;
				return CMD_BAD;
			}
			num_deleted++;
			goto top;
d455 1
a455 1
	return CMD_OK;
d465 3
a467 1
f_copy_inv( argc, argv )
d479 3
d483 1
a483 1
		return CMD_BAD;
d486 2
a487 2
		aexists( argv[2] );
		return CMD_BAD;
d492 1
a492 2
		READ_ERR;
		return CMD_BAD;
d499 4
a502 3
		rt_log( "f_copy_inv: %d is not a cylinder\n" , argv[1] );
		db_free_external( &external );
		return CMD_BAD;
d508 3
a510 2
		rt_log( "f_copy_inv: import failure for %s\n" , argv[1] );
		return CMD_BAD;
d522 3
a524 3
		rt_log( "f_copy_inv: export failure\n" );
		rt_functab[internal.idb_type].ft_ifree( &internal );
		return CMD_BAD;
d540 1
a540 2
	    	ALLOC_ERR;
		return CMD_BAD;
d546 1
a546 2
		WRITE_ERR;
		return CMD_BAD;
d551 1
a551 1
	f_edit( 2, argv+1 );	/* depends on name being in argv[2] ! */
d554 2
a555 2
		/* solid edit this new cylinder */
		f_sed( 2, argv+1 );	/* new name in argv[2] */
d558 1
a558 1
	return CMD_OK;
d579 3
a581 1
f_arced( argc, argv )
d592 3
d598 3
a600 2
		rt_log("arced: bad path specification '%s'\n", argv[1]);
		return CMD_BAD;
d603 2
a604 2
		rt_log("arced: unable to parse command\n");
		return CMD_BAD;
d626 3
a628 3
		READ_ERR;
		db_free_1anim( anp );
		return CMD_BAD;
d631 2
a632 2
		rt_log("%s: not a combination\n", dp->d_namep );
		goto fail;
d638 8
a645 2
			rt_log("%s: element %d not a member! Database corrupted.\n", dp->d_namep, i );
			goto fail;
d662 3
a664 3
			rt_log("arced: write error, aborting\n");
			ERROR_RECOVERY_SUGGESTION;
			goto fail;
d668 1
a668 1
		return CMD_OK;
d671 3
a673 3
	rt_log("Unable to find instance of '%s' in combination '%s', error\n",
		anp->an_path.fp_names[1]->d_namep,
		anp->an_path.fp_names[0]->d_namep );
d678 1
a678 1
	return CMD_BAD;
d718 3
d727 1
a727 1
	    	Tcl_SetResult(interp, "db_walk_tree() error", TCL_STATIC);
d759 9
a767 1
	if( count > 1 )  rt_log("find_solid_with_path() found %d matches\n", count);
d795 3
a797 4
	if( argc != 3 )  {
		Tcl_SetResult(interp, "Usage: oed path_lhs path_rhs", TCL_STATIC);
		return TCL_ERROR;
	}
d799 1
a799 1
		Tcl_SetResult(interp, "MGED state is not VIEW", TCL_STATIC);
d803 1
a803 1
		Tcl_SetResult(interp, "no solids in view", TCL_STATIC);
d808 1
a808 1
		Tcl_SetResult(interp, "bad lhs path", TCL_STATIC);
d813 1
a813 1
		Tcl_SetResult(interp, "bad rhs path", TCL_STATIC);
d819 1
a819 1
		Tcl_SetResult(interp, "rhs must not be null", TCL_STATIC);
d848 1
a848 1
		Tcl_SetResult(interp, "Unable to find solid matching path", TCL_STATIC);
d863 1
a863 1
	if( f_matpick( 2, new_argv ) != CMD_OK )  {
d867 1
a867 1
		Tcl_SetResult(interp, "error detected inside f_matpick", TCL_STATIC);
d874 1
a874 1
		Tcl_SetResult(interp, "MGED state did not advance to Object EDIT", TCL_STATIC);
d907 3
a909 2
f_putmat (argc, argv)

d921 3
d925 1
a925 1
	return CMD_BAD;
d929 3
a931 2
	rt_log("putmat: bad path specification '%s'\n", argv[1]);
	return CMD_BAD;
d948 2
a949 2
	    rt_log("error in matrix specification\n");
	    return CMD_BAD;
d961 8
a968 4
	    rt_log("%s:%d: bad matrix.  This shouldn't happen\n",
		__FILE__, __LINE__);
	    result = CMD_BAD;
	    break;
d974 4
a977 2
    if (result != CMD_BAD)
	result = f_arced(20, newargv);
d979 1
a979 1
    return (result);
@


11.9
log
@Implemented putmat command
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.8 1995/08/03 22:45:10 mike Exp pjt $ (BRL)";
d540 1
d548 1
@


11.8
log
@Prevent NaNs
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.6 1995/08/02 21:29:26 gdurf Exp gdurf $ (BRL)";
d39 1
d530 1
a530 1
	if( not_state( ST_VIEW, "Viewing state" ) )  return CMD_BAD;
d797 88
@


11.7
log
@Removed CONST (conflicted with Tcl_CmdProc definition)
@
text
@d753 3
@


11.6
log
@#include "./mgedtcl.h"
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.5 1995/07/28 07:33:03 mike Exp gdurf $ (BRL)";
d641 1
a641 1
CONST char	**argv;
d646 3
a648 2
	if( db_walk_tree( dbip, argc-1, argv+1, 1, &mged_initial_tree_state,
	    0, 0, pathlist_leaf_func ) < 0 )  {
d701 1
a701 1
CONST char	**argv;
@


11.5
log
@Added "oed" command, to allow direct transition from View to ObjEdit.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.4 1995/07/27 21:52:03 mike Exp mike $ (BRL)";
d39 3
a49 1
#include "tcl.h"
d52 1
a56 1
extern Tcl_Interp		*interp;	/* from cmd.c */
@


11.4
log
@Added cmd_pathlist
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.3 1995/06/27 14:50:30 gdurf Exp mike $ (BRL)";
d645 2
a646 1
	    0, 0, pathlist_leaf_func ) < 0 )
d648 1
d653 138
@


11.3
log
@Modified f_arced to fit prototype
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.2 1995/03/11 00:04:28 mike Exp gdurf $ (BRL)";
d47 1
d51 5
d603 48
@


11.2
log
@Added arced command.
Especially useful with scripts
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 11.1 95/01/04 10:02:43 mike Rel4_4 Locker: mike $ (BRL)";
d511 2
a512 2
int		argc;
CONST char	**argv;
d527 1
a527 1
	if( !(anp = db_parse_1anim( dbip, argc, argv ) ) )  {
@


11.1
log
@Release_4.4
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.10 94/12/16 19:35:39 gdurf Exp $ (BRL)";
d490 106
@


10.10
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.9 1994/12/14 16:11:56 jra Exp gdurf $ (BRL)";
@


10.9
log
@f_copy_inv was importing with rt_identity and exporting with local2mm, so
points were getting multiplied by an extra local2mm.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/chgtree.c,v 10.8 94/11/08 04:19:16 mike Exp Locker: jra $ (BRL)";
d73 1
a73 1
		printf("error in rename to %s, aborting\n", argv[2] );
d147 1
a147 1
		(void)printf("bad operation: %c\n", oper );
d175 1
a175 1
		(void)printf("error in number of args!\n");
d183 1
a183 1
			(void)printf("Defaulting item number to %d\n", item_default);
d190 1
a190 1
			(void)printf("bad operation: %s skip member: %s\n",
d196 1
a196 1
			(void)printf("skipping %s\n", argv[i+1] );
d201 1
a201 1
			(void)printf("bad operation: %c skip member: %s\n",
d213 1
a213 1
				(void)printf(
d220 1
a220 1
			(void)printf("error in combadd\n");
d255 1
a255 1
		(void)printf("error in number of args!\n");
d265 1
a265 1
			(void)printf("bad operation: %s skip member: %s\n",
d271 1
a271 1
			(void)printf("skipping %s\n", argv[i+1] );
d276 1
a276 1
			(void)printf("bad operation: %c skip member: %s\n",
d282 1
a282 1
			(void)printf("error in combadd\n");
d288 1
a288 1
		(void)printf("Error:  %s not created\n", comb_name );
d348 1
a348 1
			(void)printf("skip member %s\n", argv[i]);
d379 1
a379 1
			(void)printf("deleting member %s\n", argv[i] );
d381 1
a381 1
				(void)printf("Error in deleting member.\n");
@


10.8
log
@IRix 6
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.7 94/09/22 04:10:16 mike Exp Locker: mike $ (BRL)";
d449 1
a449 1
	if( rt_functab[internal.idb_type].ft_export( &external, &internal, local2base ) < 0 )
@


10.7
log
@Added proper cast, for Sun compiler.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.6 94/08/27 03:21:18 mike Exp Locker: mike $ (BRL)";
a405 1
	register int i;
@


10.6
log
@Added -f flag to KILL command.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.5 94/08/25 19:50:13 mike Exp Locker: mike $ (BRL)";
d444 1
a444 1
	tgc_ip = internal.idb_ptr;
@


10.5
log
@eraseobj() does db_dirdelete() on invented (phony) solids,
no need to do it again.  (Causes core dumps).
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.4 94/08/09 14:58:09 gdurf Exp Locker: mike $ (BRL)";
d296 1
a296 1
/* Format: k object1 object2 .... objectn	*/
d305 1
d307 6
d314 1
a314 1
		if( (dp = db_lookup( dbip,  argv[i], LOOKUP_NOISY )) != DIR_NULL )  {
@


10.4
log
@Added #include "conf.h"
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.3 1994/06/01 13:46:01 gdurf Exp gdurf $ (BRL)";
d304 1
d308 1
d310 3
d316 1
a320 1

@


10.3
log
@Converted f_ commands to use new return codes
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.2 1993/09/30 16:12:00 jra Exp gdurf $ (BRL)";
d33 2
@


10.2
log
@modified f_copy and f_copy_inv to use import/export routines
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 10.1 91/10/12 06:43:11 mike Rel4_0 Locker: jra $ (BRL)";
d52 1
a52 1
void
d61 1
a61 1
		return;
d65 1
a65 1
		return;
d73 1
a73 1
	    	return;
d78 3
a80 1
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
d85 1
a85 1
void
d95 1
a95 1
		return;
d99 1
a99 1
		return;
d102 4
a105 2
	if( db_get_external( &external , proto , dbip ) )
		READ_ERR_return;
d112 2
a113 1
	    	ALLOC_ERR_return;
d119 2
a120 1
		WRITE_ERR_return;
d125 1
a125 1
	f_edit( 2, argv+1 );	/* depends on name being in argv[2] ! */
d130 1
a130 1
void
d139 1
a139 1
		return;
d146 1
a146 1
		return;
d149 3
a151 1
		return;
d157 1
a157 1
void
d174 1
a174 1
		return;
d204 5
a208 1
		if( db_get( dbip,  dp, &record, 0 , 1) < 0 )  READ_ERR_return;
d219 1
a219 1
			return;
d227 1
d229 2
d241 1
a241 1
void
d254 1
a254 1
		return;
d281 1
a281 1
			return;
d285 1
a285 1
	if( db_lookup( dbip, comb_name, LOOKUP_QUIET) == DIR_NULL )
d287 4
d295 1
a295 1
void
d308 2
a309 1
			    	DELETE_ERR_return(argv[i]);
d313 2
d319 1
a319 1
void
d332 1
a332 1
				return;
d336 1
d341 1
a341 1
void
d351 1
a351 1
		return;
d357 4
a360 1
		if( db_get( dbip,  dp, &record, rec , 1) < 0 )  READ_ERR_return;
d369 1
a369 1
				return;
d375 2
d380 1
d385 1
a385 1
void
d400 1
a400 1
		return;
d404 1
a404 1
		return;
d408 4
a411 2
	if( db_get_external( &external, proto, dbip ))
		READ_ERR_return;
d419 1
a419 1
		return;
d426 1
a426 1
		return;
d440 1
a440 1
		return;
d456 2
a457 1
	    	ALLOC_ERR_return;
d463 2
a464 1
		WRITE_ERR_return;
d475 2
@


10.1
log
@Release_4.0
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 9.5 91/01/12 08:25:45 mike Exp $ (BRL)";
d35 1
d42 1
d90 1
a90 1
	union record		*rp;
d100 1
a100 1
	if( (rp = db_getmrec( dbip, proto )) == (union record *)0 )
d103 3
d111 6
a116 3
	/* All objects have name in the same place */
	NAMEMOVE( argv[2], rp->c.c_name );
	if( db_put( dbip, dp, rp, 0, proto->d_len ) < 0 )  WRITE_ERR_return;
a119 1
	rt_free( (char *)rp, "record" );
a362 1
	union record record;
d364 5
d373 2
a374 3
	NAMEMOVE( argv[2], record.s.s_name );
	if( db_lookup( dbip,  record.s.s_name, LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( record.s.s_name );
d378 3
a380 1
	if( db_get( dbip,  proto, &record, 0 , 1) < 0 )  READ_ERR_return;
d382 6
a387 2
	if(record.u_id != ID_SOLID || record.s.s_type != GENTGC )  {
		(void)printf("%s: Not a cylinder\n",record.s.s_name);
d391 5
a395 3
	if( (dp = db_diradd( dbip,  argv[2], -1, proto->d_len, DIR_SOLID )) == DIR_NULL ||
	    db_alloc( dbip, dp, proto->d_len ) < 0 )  {
	    	ALLOC_ERR_return;
d397 1
d399 2
d402 8
a409 2
	for(i=0; i<3; i++) {
		record.s.s_values[i] += record.s.s_values[i+3];
d411 1
d416 18
a433 2
	NAMEMOVE( argv[2], record.s.s_name );
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
@


9.5
log
@externs.h
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 9.4 90/12/08 00:31:10 mike Exp $ (BRL)";
@


9.4
log
@Added error checking around calls to db_*() routines
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 9.4 90/12/07 20:51:28 mike Exp $ (BRL)";
a45 1
extern int	atoi();
@


9.3
log
@Eliminated use of rec.c.c_length, using instead dp->d_len-1
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgtree.c,v 9.2 90/04/21 06:05:19 mike Exp $ (BRL)";
d68 6
a73 2
	if( db_rename( dbip, dp, argv[2] ) < 0 )
		printf("error in rename to %s\n", argv[2] );
a75 1
	(void)db_get( dbip,  dp, &record, 0 , 1);
d77 1
a77 1
	(void)db_put( dbip, dp, &record, 0, 1 );
d99 2
a100 1
	rp = db_getmrec( dbip, proto );
d102 4
a105 3
	if( (dp=db_diradd( dbip, argv[2], -1, proto->d_len, proto->d_flags)) == DIR_NULL )
		return;
	db_alloc( dbip, dp, proto->d_len );
d109 1
a109 5
	if( db_put( dbip, dp, rp, 0, proto->d_len ) < 0 )  {
		(void)printf("db_put() failed, skipping\n");
		rt_free( (char *)rp, "record" );
		return;
	}
d190 1
a190 1
		db_get( dbip,  dp, &record, 0 , 1);
d281 4
a284 2
			db_delete( dbip, dp );
			db_dirdelete( dbip, dp );
d328 1
a328 1
		db_get( dbip,  dp, &record, rec , 1);
d334 5
a339 1
			db_delrec( dbip, dp, rec );
d369 1
a369 1
	db_get( dbip,  proto, &record, 0 , 1);
d376 4
a379 3
	if( (dp = db_diradd( dbip,  argv[2], -1, proto->d_len, DIR_SOLID )) == DIR_NULL )
		return;
	db_alloc( dbip, dp, proto->d_len );
d390 1
a390 1
	db_put( dbip, dp, &record, 0, 1 );
@


9.2
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 9.1 89/05/19 06:01:56 mike Locked $ (BRL)";
a334 6
	}
	/* go back and update the header record */
	if( num_deleted ) {
		db_get( dbip, dp, &record, 0, 1 );
		record.c.c_length -= num_deleted;
		db_put( dbip, dp, &record, 0, 1 );
@


9.1
log
@Release_3.5
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 8.5 89/05/11 21:42:02 phil Exp $ (BRL)";
a48 3
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */

d52 3
a54 1
f_name()
d59 1
a59 1
	if( (dp = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d62 2
a63 2
	if( db_lookup( dbip,  cmd_args[2], LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( cmd_args[2] );
d68 2
a69 2
	if( db_rename( dbip, dp, cmd_args[2] ) < 0 )
		printf("error in rename to %s\n", cmd_args[2] );
d73 1
a73 1
	NAMEMOVE( cmd_args[2], record.c.c_name );
d80 3
a82 1
f_copy()
d86 1
a86 2
	union record record;
	register int i;
d88 1
a88 1
	if( (proto = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d91 2
a92 2
	if( db_lookup( dbip,  cmd_args[2], LOOKUP_QUIET ) != DIR_NULL )  {
		aexists( cmd_args[2] );
d96 1
a96 1
	db_get( dbip,  proto, &record, 0 , 1);
d98 3
a100 4
	if(record.u_id == ID_SOLID) {
		if( (dp = db_diradd( dbip,  cmd_args[2], -1, proto->d_len, DIR_SOLID )) == DIR_NULL )
			return;
		db_alloc( dbip, dp, proto->d_len );
d102 7
a108 5
		/*
		 * Update the disk record
		 */
		NAMEMOVE( cmd_args[2], record.s.s_name );
		db_put( dbip, dp, &record, 0, 1 );
d110 3
a112 47
		/* draw the new solid */
		drawtree( dp );
		dmaflag = 1;

		/* color the solid */
		dmp->dmr_colorchange();
	} else if(record.u_id == ID_ARS_A)  {
		if( (dp = db_diradd( dbip,  cmd_args[2], -1, proto->d_len, DIR_SOLID )) == DIR_NULL )
			return;
		db_alloc( dbip, dp, proto->d_len );
		NAMEMOVE( cmd_args[2], record.a.a_name );
		db_put( dbip, dp, &record, 0, 1 );

		/* Process the rest of the ARS (b records)  */
		for( i = 1; i < proto->d_len; i++ )  {
			db_get( dbip, proto, &record, i, 1);
			db_put( dbip, dp, &record, i, 1 );
		}
	} else if( record.u_id == ID_BSOLID ) {
		if( (dp = db_diradd( dbip,  cmd_args[2], -1, proto->d_len, DIR_SOLID )) == DIR_NULL )
			return;
		db_alloc( dbip, dp, proto->d_len );
		NAMEMOVE( cmd_args[2], record.B.B_name );
		db_put( dbip, dp, &record, 0, 1 );
		for( i = 1; i < proto->d_len; i++ ) {
			db_get( dbip, proto, &record, i, 1);
			db_put( dbip, dp, &record, i, 1 );
		}
	} else if(record.u_id == ID_COMB) {
		if( (dp = db_diradd( dbip, 
			cmd_args[2], -1, proto->d_len,
			record.c.c_flags == 'R' ?
			DIR_COMB|DIR_REGION : DIR_COMB)) == DIR_NULL )
			return;
		db_alloc( dbip, dp, proto->d_len );

		NAMEMOVE( cmd_args[2], record.c.c_name );
		db_put( dbip, dp, &record, 0, 1 );

		/* Process member records  */
		for( i = 1; i < proto->d_len; i++ )  {
			db_get( dbip, proto, &record, i, 1);
			db_put( dbip, dp, &record, i, 1 );
		}
	} else {
		(void)printf("%s: cannot copy\n",cmd_args[2]);
	}
d118 3
a120 1
f_instance()
d125 1
a125 1
	if( (dp = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d129 2
a130 2
	if( numargs == 4 )
		oper = cmd_args[3][0];
d135 1
a135 1
	if( combadd( dp, cmd_args[2], 0, oper, 0, 0 ) == DIR_NULL )
d143 3
a145 1
f_region()
d157 1
a157 1
	if( numargs & 01 )  {
d162 1
a162 1
	if( db_lookup( dbip, cmd_args[1], LOOKUP_QUIET) == DIR_NULL ) {
d171 2
a172 2
	for( i = 2; i < numargs; i += 2 )  {
		if( cmd_args[i][1] != '\0' )  {
d174 1
a174 1
				cmd_args[i], cmd_args[i+1] );
d177 3
a179 3
		oper = cmd_args[i][0];
		if( (dp = db_lookup( dbip,  cmd_args[i + 1], LOOKUP_NOISY )) == DIR_NULL )  {
			(void)printf("skipping %s\n", cmd_args[i + 1] );
d198 1
a198 1
		if( combadd( dp, cmd_args[1], 1, oper, ident, air ) == DIR_NULL )  {
d204 1
a204 1
	if( db_lookup( dbip, cmd_args[1], LOOKUP_QUIET) == DIR_NULL ) {
d220 3
a222 1
f_comb()
d230 1
a230 1
	if( numargs & 01 )  {
d236 1
a236 1
	comb_name = cmd_args[1];
d239 2
a240 2
	for( i = 2; i < numargs; i += 2 )  {
		if( cmd_args[i][1] != '\0' )  {
d242 1
a242 1
				cmd_args[i], cmd_args[i+1] );
d245 3
a247 3
		oper = cmd_args[i][0];
		if( (dp = db_lookup( dbip,  cmd_args[i + 1], LOOKUP_NOISY )) == DIR_NULL )  {
			(void)printf("skipping %s\n", cmd_args[i + 1] );
d270 3
a272 1
f_kill()
d277 2
a278 2
	for( i = 1; i < numargs; i++ )  {
		if( (dp = db_lookup( dbip,  cmd_args[i], LOOKUP_NOISY )) != DIR_NULL )  {
a283 1
	dmaflag = 1;
d289 3
a291 1
f_group()
d297 3
a299 3
	for( i = 2; i < numargs; i++ )  {
		if( (dp = db_lookup( dbip,  cmd_args[i], LOOKUP_NOISY)) != DIR_NULL )  {
			if( combadd( dp, cmd_args[1], 0,
d303 1
a303 1
			(void)printf("skip member %s\n", cmd_args[i]);
d310 3
a312 1
f_rm()
d318 1
a318 1
	if( (dp = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d327 2
a328 2
		for( i = 2; i < numargs; i++ )  {
			if( strcmp( cmd_args[i], record.M.m_instname ) != 0 )
d330 1
a330 1
			(void)printf("deleting member %s\n", cmd_args[i] );
d350 3
a352 1
f_copy_inv()
d359 1
a359 1
	if( (proto = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d362 1
a362 1
	NAMEMOVE( cmd_args[2], record.s.s_name );
d375 1
a375 1
	if( (dp = db_diradd( dbip,  cmd_args[2], -1, proto->d_len, DIR_SOLID )) == DIR_NULL )
d387 1
a387 1
	NAMEMOVE( cmd_args[2], record.s.s_name );
d391 1
a391 2
	drawtree( dp );
	dmaflag = 1;
a392 3
	/* color the solid */
	dmp->dmr_colorchange();

d395 1
a395 2
		strcpy(cmd_args[1], cmd_args[2]);
		f_sed();
@


8.5
log
@db_diradd had the length and flags parameters backward
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 8.4 89/04/06 20:38:55 phil Locked $ (BRL)";
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 8.3 89/01/16 22:51:41 mike Locked $ (BRL)";
d99 1
a99 1
		if( (dp = db_diradd( dbip,  cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d116 1
a116 1
		if( (dp = db_diradd( dbip,  cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d128 1
a128 1
		if( (dp = db_diradd( dbip,  cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d139 3
a141 4
			cmd_args[2],
			-1,
			record.c.c_flags == 'R' ? DIR_COMB|DIR_REGION : DIR_COMB,
			proto->d_len )) == DIR_NULL )
d405 1
a405 1
	if( (dp = db_diradd( dbip,  cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
@


8.3
log
@drawHobj() --> drawtree()
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 8.2 88/12/06 00:56:27 mike Locked $ (BRL)";
d42 1
@


8.2
log
@Converted to new db_*() routines.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/chgtree.c,v 1.2 88/10/23 13:55:40 mike Exp $ (BRL)";
d109 1
a109 1
		drawHobj(dp, ROOT, 0, identity);
d421 1
a421 1
	drawHobj(dp, ROOT, 0, identity);
@


8.1
log
@Release_3.0
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 7.4 88/08/12 07:49:10 mike Exp $ (BRL)";
d40 1
a41 1
#include "./objdir.h"
a57 2
	long laddr;
	int flags, len;
d59 1
a59 1
	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d62 1
a62 1
	if( lookup( cmd_args[2], LOOKUP_QUIET ) != DIR_NULL )  {
d67 3
a69 5
	/* Due to hashing, need to delete and add it back */
	laddr = dp->d_addr;
	flags = dp->d_flags;
	len = dp->d_len;
	dir_delete( dp );
d71 2
a72 3
	dp = dir_add( cmd_args[2], laddr, flags, len );
	db_getrec( dp, &record, 0 );

d74 1
a74 1
	db_putrec( dp, &record, 0 );
d87 1
a87 1
	if( (proto = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d90 1
a90 1
	if( lookup( cmd_args[2], LOOKUP_QUIET ) != DIR_NULL )  {
d95 1
a95 1
	db_getrec( proto, &record, 0 );
d98 1
a98 1
		if( (dp = dir_add( cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d100 1
a100 1
		db_alloc( dp, proto->d_len );
d106 1
a106 1
		db_putrec( dp, &record, 0 );
d115 1
a115 1
		if( (dp = dir_add( cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d117 1
a117 1
		db_alloc( dp, proto->d_len );
d119 1
a119 1
		db_putrec( dp, &record, 0 );
d123 2
a124 2
			db_getrec( proto, &record, i );
			db_putrec( dp, &record, i );
d127 1
a127 1
		if( (dp = dir_add( cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d129 1
a129 1
		db_alloc( dp, proto->d_len );
d131 1
a131 1
		db_putrec( dp, &record, 0 );
d133 2
a134 2
			db_getrec( proto, &record, i );
			db_putrec( dp, &record, i );
d137 1
a137 1
		if( (dp = dir_add(
d143 1
a143 1
		db_alloc( dp, proto->d_len );
d146 1
a146 1
		db_putrec( dp, &record, 0 );
d150 2
a151 2
			db_getrec( proto, &record, i );
			db_putrec( dp, &record, i );
d166 1
a166 1
	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d201 1
a201 1
	if( lookup(cmd_args[1], LOOKUP_QUIET) == DIR_NULL ) {
d217 1
a217 1
		if( (dp = lookup( cmd_args[i + 1], LOOKUP_NOISY )) == DIR_NULL )  {
d228 1
a228 1
		db_getrec( dp, &record, 0 );
d243 1
a243 1
	if( lookup(cmd_args[1], LOOKUP_QUIET) == DIR_NULL ) {
d283 1
a283 1
		if( (dp = lookup( cmd_args[i + 1], LOOKUP_NOISY )) == DIR_NULL )  {
d300 1
a300 1
	if( lookup(comb_name, LOOKUP_QUIET) == DIR_NULL )
d313 1
a313 1
		if( (dp = lookup( cmd_args[i], LOOKUP_NOISY )) != DIR_NULL )  {
d315 2
a316 2
			db_delete( dp );
			dir_delete( dp );
d332 1
a332 1
		if( (dp = lookup( cmd_args[i], LOOKUP_NOISY)) != DIR_NULL )  {
d350 1
a350 1
	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d357 1
a357 1
		db_getrec( dp, &record, rec );
d364 1
a364 1
			db_delrec( dp, rec );
d370 1
a370 1
		db_getrec(dp, &record, 0);
d372 1
a372 1
		db_putrec(dp, &record, 0);
d389 1
a389 1
	if( (proto = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d393 1
a393 1
	if( lookup( record.s.s_name, LOOKUP_QUIET ) != DIR_NULL )  {
d398 1
a398 1
	db_getrec( proto, &record, 0 );
d405 1
a405 1
	if( (dp = dir_add( cmd_args[2], -1, DIR_SOLID, proto->d_len )) == DIR_NULL )
d407 1
a407 1
	db_alloc( dp, proto->d_len );
d418 1
a418 1
	db_putrec( dp, &record, 0 );
@


7.4
log
@Small change to invocation of "comb" command
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 7.3 88/08/11 05:22:17 mike Locked $ (BRL)";
@


7.3
log
@Added f_fhelp, f_comb
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 7.2 87/11/05 05:03:47 mike Locked $ (BRL)";
d272 1
a272 1
	if( !(numargs & 01) )  {
a279 3
	/* Fake up first operation as a UNION, to be tidy */
	cmd_args[1] = "u";

d281 1
a281 1
	for( i = 1; i < numargs; i += 2 )  {
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 7.1 87/11/02 23:58:46 mike Rel $ (BRL)";
d253 57
@


7.1
log
@Release 2.3
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 6.1 87/07/11 08:02:01 mike Rel $ (BRL)";
d36 1
a36 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 5.1 87/06/24 22:18:08 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 4.2 87/02/13 00:05:45 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 4.1 86/12/29 03:19:24 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.16 86/09/10 02:43:36 mike Exp $ (BRL)";
@


2.16
log
@Changed f_rm() to use db_delrec().
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.15 86/09/09 21:56:37 mike Exp $ (BRL)";
@


2.15
log
@When using the "cp" command, follow by drawing the new object.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.14 86/08/12 06:47:04 mike Exp $ (BRL)";
d306 1
a308 1
top:
d315 1
a315 10

			/* If deleting last member, just truncate */
			if( rec == dp->d_len-1 ) {
				db_trunc(dp, 1);
				continue;
			}

			db_getrec( dp, &record, dp->d_len-1 );	/* last one */
			db_putrec( dp, &record, rec );		/* xch */
			db_trunc( dp, 1 );
d319 1
a319 1
	/* go back and undate the header record */
@


2.14
log
@Changed #includes for CC -I../h
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.13 86/06/12 00:08:36 mike Exp $ (BRL)";
d112 7
@


2.13
log
@Fixed typo
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.12 86/05/28 01:24:50 mike Exp $ (BRL)";
d37 7
a43 7
#include "../h/vmath.h"
#include "../h/db.h"
#include "sedit.h"
#include "ged.h"
#include "objdir.h"
#include "solid.h"
#include "dm.h"
@


2.12
log
@Added f_copy_inv from Keith
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.11 86/03/14 20:41:35 mike Exp $ (BRL)";
d353 1
a353 1
	if(record.u_id != ID_SOLID || recrod.s.s_type != GENTGC )  {
@


2.11
log
@Added support for the new spline format.
@
text
@d14 2
a15 1
 *	f_rm	delete members of a combination
d17 1
a17 1
 *  Author -
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.10 86/02/17 17:01:14 mike Exp $ (BRL)";
d82 2
a83 2
/* Copy a solid */
/* Format: c oldname newname	*/
d326 58
@


2.10
log
@Minor typo with instance command.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.9 85/09/14 05:34:20 mike Exp $ (BRL)";
d123 1
a123 1
	} else if( record.u_id == ID_B_SPL_HEAD ) {
d127 1
a127 1
		NAMEMOVE( cmd_args[2], record.d.d_name );
@


2.9
log
@Lint-inspired cleanup.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.8 85/08/07 05:16:59 mike Exp $ (BRL)";
d167 1
a167 1
	if( numargs == 5 )
@


2.8
log
@Changed to use common ../h/vmath.h
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.7 85/07/30 01:18:38 mike Exp $ (BRL)";
a56 1
	char *name;
@


2.7
log
@KAA change to item_default strategy.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.6 85/05/08 00:53:44 mike Exp $ (BRL)";
d33 4
a36 3
#include	<math.h>
#include	<stdio.h>
#include "ged_types.h"
a42 1
#include "../h/vmath.h"
@


2.6
log
@spelling error
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.5 85/05/08 00:31:13 mike Exp $ (BRL)";
d201 4
a204 2
		item_default++;
		(void)printf("Defaulting item number to %d\n", item_default);
d243 2
a244 1
		item_default--;
@


2.5
log
@KAA added region code defaulting
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.4 85/05/02 20:15:37 mike Exp $ (BRL)";
d202 1
a202 1
		(void)printf("Defaulting item number to %d\n", idem_default);
@


2.4
log
@Eliminated silly M_brname stuff.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.3 85/03/15 06:17:10 mike Exp $ (BRL)";
d190 3
a192 1
	ident = air = 0;
d198 7
d237 5
@


2.3
log
@Fixed bug in "mv" command induced by hashed directory.
@
text
@d14 1
a14 1
 *	f_delmem	delete members of a combination
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.2 85/03/12 04:06:40 mike Exp $ (BRL)";
d157 1
a157 1
/* Format: i object combname instname [op]	*/
d169 1
a169 1
		oper = cmd_args[4][0];
d174 1
a174 2
	if( combadd( dp, cmd_args[2], cmd_args[3], '\0', oper, 0, 0 ) ==
	    DIR_NULL )
d224 1
a224 2
		if( combadd( dp, cmd_args[1], (char *)NULL, 'r', oper, ident,
							air ) == DIR_NULL )  {
d260 1
a260 1
			if( combadd( dp, cmd_args[1], (char *)NULL, 'g',
d263 1
a263 2
		}
		else
d271 1
a271 1
f_delmem()
d287 1
a287 2
			if( strcmp( cmd_args[i], record.M.m_instname ) != 0 &&
			    strcmp( cmd_args[i], record.M.m_brname ) != 0 )
@


2.2
log
@Paul Stay's Spline code
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 2.1 85/03/11 23:54:02 mike Prod $ (BRL)";
d57 3
d69 7
a75 1
	dp->d_namep = strdup( cmd_args[2] );
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 1.5 85/03/08 20:07:55 mike Exp $ (BRL)";
d81 1
a81 1
	int i, ngran, nmemb;
a93 3
		/*
		 * Update the in-core directory
		 */
d103 1
a103 6
	}
	else
	if(record.u_id == ID_ARS_A)  {
		/*
		 * Update the in-core directory
		 */
a106 4

		/*
		 * Update the disk record
		 */
a107 1
		ngran = record.a.a_totlen;
d111 3
a113 3
		for( i = 0; i < ngran; i++ )  {
			db_getrec( proto, &record, i+1 );
			db_putrec( dp, &record, i+1 );
d115 11
a125 6
	}
	else
	if(record.u_id == ID_COMB) {
		/*
		 * Update the in-core directory
		 */
a133 3
		/*
		 * Update the disk record
		 */
a134 1
		nmemb = record.c.c_length;
d138 3
a140 3
		for( i = 0; i < nmemb; i++ )  {
			db_getrec( proto, &record, i+1 );
			db_putrec( dp, &record, i+1 );
d142 1
a142 2
	}
	else {
a143 2
		(void)putchar( 7 );
		return;
@


1.5
log
@KAA fix to correctly update combination length when deleting elements.
@
text
@d8 7
d16 5
a20 1
 * Source -
d24 4
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 1.4 85/02/14 00:58:28 mike Exp $ (BRL)";
d36 1
a36 1
#include "db.h"
d39 1
a39 1
#include "dir.h"
d42 1
a42 1
#include "vmath.h"
d200 1
a200 1
		printf("error in number of args!\n");
d299 1
a299 1
			printf("deleting member %s\n", cmd_args[i] );
@


1.4
log
@Removed the (now redundant) "done" messages.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 1.3 85/02/14 00:22:14 mike Exp $ (BRL)";
d268 1
a268 1
	register int i, rec;
d275 1
d285 1
d298 6
@


1.3
log
@Latest KAA version.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 1.2 85/02/01 01:45:59 mike Exp $ (BRL)";
a55 1
	(void)printf("done\n");
a144 1
	(void)printf("done\n");
a167 1
	(void)printf("done\n");
a221 1
	(void)printf("done\n");
a239 1
	(void)printf("done\n");
a259 1
	(void)printf("done\n");
a296 1
	(void)printf("done\n");
@


1.2
log
@Typos.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: chgtree.c,v 1.1 85/02/01 00:48:58 mike Exp $ (BRL)";
d67 1
a67 1
	int i, ngran;
d79 13
a91 3
	if( record.u_id != ID_SOLID && record.u_id != ID_ARS_A ) {
		(void)printf("%s: not a solid\n", proto->d_namep );
		return;
d93 8
d102 3
a104 11
	/*
	 * Update the in-core directory
	 */
	if( (dp = dir_add( cmd_args[2], -1, DIR_SOLID, 0 )) == DIR_NULL )
		return;
	db_alloc( dp, proto->d_len );

	/*
	 * Update the disk record
	 */
	if(record.u_id == ID_ARS_A)  {
a111 5
			if( i == 0 )  {
				record.b.b_values[0] = -toViewcenter[MDX];
				record.b.b_values[1] = -toViewcenter[MDY];
				record.b.b_values[2] = -toViewcenter[MDZ];
			}
d114 19
a132 5
	}  else  {
		NAMEMOVE( cmd_args[2], record.s.s_name );
		record.s.s_values[0] = -toViewcenter[MDX];
		record.s.s_values[1] = -toViewcenter[MDY];
		record.s.s_values[2] = -toViewcenter[MDZ];
d134 11
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d30 1
@
