head	11.193;
access;
symbols
	ansi-20040405-merged:11.188.2.2
	postmerge-20040405-ansi:11.191
	premerge-20040404-ansi:11.190
	postmerge-autoconf:11.190
	autoconf-freeze:11.188.10.3
	premerge-autoconf:11.190
	postmerge-20040315-windows:11.190
	premerge-20040315-windows:11.190
	windows-20040315-freeze:11.188.4.1
	autoconf-20031203:11.188.10.1
	autoconf-20031202:11.188
	autoconf-branch:11.188.0.10
	phong-branch:11.188.0.8
	photonmap-branch:11.188.0.6
	rel-6-1-DP:11.188
	windows-branch:11.188.0.4
	rel-6-0-2:11.185
	ansi-branch:11.188.0.2
	rel-6-0-1-branch:11.185.0.2
	hartley-6-0-post:11.187
	hartley-6-0-pre:11.186
	rel-6-0-1:11.185
	rel-6-0:11.185
	rel-5-4:11.144.2.10
	offsite-5-3-pre:11.160
	rel-5-3:11.144.2.8
	rel-5-2:11.144
	rel-5-1-branch:11.144.0.2
	rel-5-1:11.144
	rel-5-0:11.137
	rel-5-0-beta:11.132
	rel-4-5:11.111
	ctj-4-5-post:11.93
	ctj-4-5-pre:11.93
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.4
	rel-1-10:4.1
	rt-2:2.13;
locks; strict;
comment	@ * @;


11.193
date	2004.05.21.17.47.37;	author morrison;	state dead;
branches;
next	11.192;

11.192
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.191;

11.191
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.190;

11.190
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.189;

11.189
date	2003.12.01.16.18.52;	author morrison;	state Exp;
branches;
next	11.188;

11.188
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	11.188.2.1
	11.188.4.1
	11.188.10.1;
next	11.187;

11.187
date	2002.08.15.20.55.32;	author hartley;	state Exp;
branches;
next	11.186;

11.186
date	2002.08.11.02.06.02;	author morrison;	state Exp;
branches;
next	11.185;

11.185
date	2002.02.27.20.43.07;	author jra;	state Exp;
branches;
next	11.184;

11.184
date	2002.02.25.21.10.54;	author jra;	state Exp;
branches;
next	11.183;

11.183
date	2002.02.22.16.09.43;	author jra;	state Exp;
branches;
next	11.182;

11.182
date	2001.12.13.17.42.26;	author bparker;	state Exp;
branches;
next	11.181;

11.181
date	2001.12.12.18.51.16;	author bparker;	state Exp;
branches;
next	11.180;

11.180
date	2001.11.09.20.40.03;	author bparker;	state Exp;
branches;
next	11.179;

11.179
date	2001.11.01.22.01.23;	author bparker;	state Exp;
branches;
next	11.178;

11.178
date	2001.10.15.20.39.56;	author bparker;	state Exp;
branches;
next	11.177;

11.177
date	2001.09.19.22.21.43;	author bparker;	state Exp;
branches;
next	11.176;

11.176
date	2001.09.18.15.25.38;	author bparker;	state Exp;
branches;
next	11.175;

11.175
date	2001.09.07.18.53.25;	author bparker;	state Exp;
branches;
next	11.174;

11.174
date	2001.08.11.13.16.11;	author butler;	state Exp;
branches;
next	11.173;

11.173
date	2001.06.25.21.27.30;	author bparker;	state Exp;
branches;
next	11.172;

11.172
date	2001.06.18.19.24.23;	author bparker;	state Exp;
branches;
next	11.171;

11.171
date	2001.06.05.15.51.40;	author bparker;	state Exp;
branches;
next	11.170;

11.170
date	2001.06.01.19.23.23;	author bparker;	state Exp;
branches;
next	11.169;

11.169
date	2001.05.17.20.05.34;	author morrison;	state Exp;
branches;
next	11.168;

11.168
date	2001.05.04.14.20.45;	author bparker;	state Exp;
branches;
next	11.167;

11.167
date	2001.05.02.17.14.00;	author bparker;	state Exp;
branches;
next	11.166;

11.166
date	2001.04.17.14.09.30;	author bparker;	state Exp;
branches;
next	11.165;

11.165
date	2001.04.05.19.35.43;	author morrison;	state Exp;
branches;
next	11.164;

11.164
date	2001.04.02.21.38.18;	author morrison;	state Exp;
branches;
next	11.163;

11.163
date	2001.03.31.01.57.21;	author morrison;	state Exp;
branches;
next	11.162;

11.162
date	2001.03.26.19.15.55;	author bparker;	state Exp;
branches;
next	11.161;

11.161
date	2001.03.19.22.20.01;	author butler;	state Exp;
branches;
next	11.160;

11.160
date	2001.02.23.20.24.38;	author bparker;	state Exp;
branches;
next	11.159;

11.159
date	2001.02.16.22.43.44;	author bparker;	state Exp;
branches;
next	11.158;

11.158
date	2001.01.04.17.02.21;	author bparker;	state Exp;
branches;
next	11.157;

11.157
date	2001.01.03.21.30.00;	author bparker;	state Exp;
branches;
next	11.156;

11.156
date	2000.10.24.19.53.49;	author mike;	state Exp;
branches;
next	11.155;

11.155
date	2000.10.24.19.05.05;	author mike;	state Exp;
branches;
next	11.154;

11.154
date	2000.10.20.05.04.37;	author mike;	state Exp;
branches;
next	11.153;

11.153
date	2000.10.18.14.21.40;	author bparker;	state Exp;
branches;
next	11.152;

11.152
date	2000.10.12.16.10.21;	author bparker;	state Exp;
branches;
next	11.151;

11.151
date	2000.09.21.02.46.51;	author mike;	state Exp;
branches;
next	11.150;

11.150
date	2000.09.09.04.30.54;	author mike;	state Exp;
branches;
next	11.149;

11.149
date	2000.09.08.05.55.47;	author mike;	state Exp;
branches;
next	11.148;

11.148
date	2000.09.07.02.23.43;	author mike;	state Exp;
branches;
next	11.147;

11.147
date	2000.08.31.01.28.08;	author mike;	state Exp;
branches;
next	11.146;

11.146
date	2000.08.19.03.10.11;	author mike;	state Exp;
branches;
next	11.145;

11.145
date	2000.06.30.19.52.01;	author mike;	state Exp;
branches;
next	11.144;

11.144
date	2000.06.08.21.34.04;	author bparker;	state Exp;
branches
	11.144.2.1;
next	11.143;

11.143
date	2000.05.26.16.10.22;	author bparker;	state Exp;
branches;
next	11.142;

11.142
date	2000.05.26.14.24.35;	author bparker;	state Exp;
branches;
next	11.141;

11.141
date	2000.01.06.22.06.54;	author mike;	state Exp;
branches;
next	11.140;

11.140
date	99.12.30.19.26.41;	author jra;	state Exp;
branches;
next	11.139;

11.139
date	99.11.26.23.03.30;	author mike;	state Exp;
branches;
next	11.138;

11.138
date	99.10.29.14.58.20;	author bparker;	state Exp;
branches;
next	11.137;

11.137
date	99.09.09.19.37.04;	author bparker;	state Exp;
branches;
next	11.136;

11.136
date	99.09.01.18.55.09;	author bparker;	state Exp;
branches;
next	11.135;

11.135
date	99.07.08.17.44.03;	author bparker;	state Exp;
branches;
next	11.134;

11.134
date	99.07.07.17.25.31;	author bparker;	state Exp;
branches;
next	11.133;

11.133
date	99.07.02.22.18.38;	author mike;	state Exp;
branches;
next	11.132;

11.132
date	99.05.15.08.04.34;	author mike;	state Exp;
branches;
next	11.131;

11.131
date	99.05.11.17.00.31;	author bparker;	state Exp;
branches;
next	11.130;

11.130
date	99.05.10.20.17.43;	author mike;	state Exp;
branches;
next	11.129;

11.129
date	99.05.10.19.08.36;	author mike;	state Exp;
branches;
next	11.128;

11.128
date	99.04.16.18.00.02;	author bparker;	state Exp;
branches;
next	11.127;

11.127
date	99.02.08.21.52.52;	author bparker;	state Exp;
branches;
next	11.126;

11.126
date	99.01.28.21.39.08;	author jra;	state Exp;
branches;
next	11.125;

11.125
date	99.01.27.21.15.45;	author jra;	state Exp;
branches;
next	11.124;

11.124
date	99.01.21.18.26.37;	author bparker;	state Exp;
branches;
next	11.123;

11.123
date	99.01.12.18.20.57;	author bparker;	state Exp;
branches;
next	11.122;

11.122
date	98.12.29.20.42.08;	author bparker;	state Exp;
branches;
next	11.121;

11.121
date	98.11.06.22.09.33;	author bparker;	state Exp;
branches;
next	11.120;

11.120
date	98.10.22.18.49.35;	author bparker;	state Exp;
branches;
next	11.119;

11.119
date	98.10.21.17.26.28;	author bparker;	state Exp;
branches;
next	11.118;

11.118
date	98.06.11.19.41.40;	author bparker;	state Exp;
branches;
next	11.117;

11.117
date	98.05.26.14.27.08;	author bparker;	state Exp;
branches;
next	11.116;

11.116
date	98.04.23.12.52.04;	author bparker;	state Exp;
branches;
next	11.115;

11.115
date	98.04.10.18.11.45;	author bparker;	state Exp;
branches;
next	11.114;

11.114
date	98.04.07.14.57.45;	author bparker;	state Exp;
branches;
next	11.113;

11.113
date	98.03.19.06.57.06;	author mike;	state Exp;
branches;
next	11.112;

11.112
date	98.03.19.06.46.20;	author mike;	state Exp;
branches;
next	11.111;

11.111
date	98.01.28.15.33.23;	author bparker;	state Exp;
branches;
next	11.110;

11.110
date	98.01.16.21.51.38;	author bparker;	state Exp;
branches;
next	11.109;

11.109
date	97.12.23.14.22.49;	author bparker;	state Exp;
branches;
next	11.108;

11.108
date	97.11.26.21.31.39;	author bparker;	state Exp;
branches;
next	11.107;

11.107
date	97.11.06.20.03.43;	author bparker;	state Exp;
branches;
next	11.106;

11.106
date	97.11.03.15.14.28;	author bparker;	state Exp;
branches;
next	11.105;

11.105
date	97.10.27.19.14.53;	author bparker;	state Exp;
branches;
next	11.104;

11.104
date	97.10.08.12.42.29;	author bparker;	state Exp;
branches;
next	11.103;

11.103
date	97.09.11.13.29.18;	author bparker;	state Exp;
branches;
next	11.102;

11.102
date	97.09.08.19.46.57;	author bparker;	state Exp;
branches;
next	11.101;

11.101
date	97.09.08.18.27.58;	author bparker;	state Exp;
branches;
next	11.100;

11.100
date	97.09.03.14.14.09;	author bparker;	state Exp;
branches;
next	11.99;

11.99
date	97.08.22.22.30.17;	author mike;	state Exp;
branches;
next	11.98;

11.98
date	97.07.28.20.05.49;	author bparker;	state Exp;
branches;
next	11.97;

11.97
date	97.07.25.20.43.22;	author bparker;	state Exp;
branches;
next	11.96;

11.96
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.95;

11.95
date	97.06.25.13.03.19;	author bparker;	state Exp;
branches;
next	11.94;

11.94
date	97.06.12.14.13.07;	author bparker;	state Exp;
branches;
next	11.93;

11.93
date	97.05.29.14.05.15;	author bparker;	state Exp;
branches;
next	11.92;

11.92
date	97.05.20.14.34.37;	author jra;	state Exp;
branches;
next	11.91;

11.91
date	97.05.09.21.04.45;	author bparker;	state Exp;
branches;
next	11.90;

11.90
date	97.05.02.14.27.53;	author jra;	state Exp;
branches;
next	11.89;

11.89
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.88;

11.88
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.87;

11.87
date	97.04.14.12.20.10;	author bparker;	state Exp;
branches;
next	11.86;

11.86
date	97.03.29.04.28.17;	author jra;	state Exp;
branches;
next	11.85;

11.85
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.84;

11.84
date	97.02.28.21.32.37;	author bparker;	state Exp;
branches;
next	11.83;

11.83
date	97.02.14.08.52.34;	author mike;	state Exp;
branches;
next	11.82;

11.82
date	97.02.14.08.51.16;	author mike;	state Exp;
branches;
next	11.81;

11.81
date	97.02.06.21.59.02;	author bparker;	state Exp;
branches;
next	11.80;

11.80
date	97.02.04.21.57.21;	author bparker;	state Exp;
branches;
next	11.79;

11.79
date	97.02.03.21.46.42;	author bparker;	state Exp;
branches;
next	11.78;

11.78
date	97.02.01.03.14.36;	author mike;	state Exp;
branches;
next	11.77;

11.77
date	97.02.01.02.56.47;	author mike;	state Exp;
branches;
next	11.76;

11.76
date	97.01.30.01.47.50;	author mike;	state Exp;
branches;
next	11.75;

11.75
date	97.01.29.23.15.37;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	97.01.24.20.58.56;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	97.01.10.21.52.45;	author bparker;	state Exp;
branches;
next	11.71;

11.71
date	97.01.08.21.43.58;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	97.01.08.19.41.27;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	97.01.08.18.57.59;	author jra;	state Exp;
branches;
next	11.68;

11.68
date	97.01.02.19.36.55;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	96.12.23.22.41.28;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	96.12.17.22.45.21;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	96.12.17.21.48.53;	author bparker;	state Exp;
branches;
next	11.64;

11.64
date	96.12.13.23.10.54;	author bparker;	state Exp;
branches;
next	11.63;

11.63
date	96.12.12.22.10.09;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	96.12.06.21.55.11;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	96.12.04.21.10.11;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	96.12.04.03.39.35;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	96.12.04.03.38.12;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	96.11.28.08.36.59;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	96.11.28.08.17.35;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	96.11.28.06.03.02;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	96.11.27.08.56.16;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	96.11.19.21.45.22;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	96.11.01.22.14.17;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	96.10.18.14.01.52;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	96.10.15.17.50.16;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	96.10.09.16.58.39;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	96.10.04.14.58.44;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	96.10.03.20.46.00;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	96.09.30.19.48.28;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	96.09.23.18.36.49;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	96.09.17.21.20.57;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	96.07.30.21.28.38;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	96.07.29.15.56.00;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	96.07.25.18.55.20;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	96.07.15.20.37.44;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.06.28.20.53.50;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.06.25.20.58.00;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.06.21.15.54.36;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.05.31.22.31.20;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.05.24.18.33.29;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.05.16.20.59.26;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.05.13.20.47.40;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	96.03.22.18.35.38;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.03.08.18.30.24;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.03.01.19.17.44;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.02.12.00.30.28;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	96.02.09.22.13.58;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.01.17.22.12.26;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	95.12.27.22.29.02;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	95.11.07.22.57.50;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	95.09.22.02.50.46;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	95.09.09.02.02.05;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	95.07.19.16.01.10;	author pjt;	state Exp;
branches;
next	11.11;

11.11
date	95.07.19.15.24.18;	author pjt;	state Exp;
branches;
next	11.10;

11.10
date	95.07.18.20.14.02;	author pjt;	state Exp;
branches;
next	11.9;

11.9
date	95.07.13.20.32.14;	author pjt;	state Exp;
branches;
next	11.8;

11.8
date	95.07.13.20.26.14;	author pjt;	state Exp;
branches;
next	11.7;

11.7
date	95.03.10.19.18.22;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.01.18.13.23.17;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.01.18.08.52.48;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.01.18.08.29.53;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.01.17.16.27.28;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.16.02.11;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.44;	author mike;	state Rel4_4;
branches;
next	10.34;

10.34
date	94.12.29.16.33.33;	author jra;	state Exp;
branches;
next	10.33;

10.33
date	94.12.28.16.06.49;	author jra;	state Exp;
branches;
next	10.32;

10.32
date	94.12.28.09.47.55;	author gdurf;	state Exp;
branches;
next	10.31;

10.31
date	94.12.27.18.04.54;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	94.12.27.16.58.45;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	94.12.24.00.23.44;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.12.23.23.47.56;	author gdurf;	state Exp;
branches;
next	10.27;

10.27
date	94.12.23.21.58.40;	author gdurf;	state Exp;
branches;
next	10.26;

10.26
date	94.12.16.20.55.00;	author gdurf;	state Exp;
branches;
next	10.25;

10.25
date	94.12.16.20.29.05;	author gdurf;	state Exp;
branches;
next	10.24;

10.24
date	94.12.16.19.35.42;	author gdurf;	state Exp;
branches;
next	10.23;

10.23
date	94.12.08.23.16.59;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	94.11.16.16.59.48;	author jra;	state Exp;
branches;
next	10.21;

10.21
date	94.11.10.12.06.03;	author jra;	state Exp;
branches;
next	10.20;

10.20
date	94.08.27.03.16.42;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.08.19.10.14.17;	author pjt;	state Exp;
branches;
next	10.18;

10.18
date	94.08.17.16.16.12;	author pjt;	state Exp;
branches;
next	10.17;

10.17
date	94.08.09.14.58.45;	author gdurf;	state Exp;
branches;
next	10.16;

10.16
date	94.08.05.14.48.24;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.08.03.22.53.19;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.08.03.22.24.12;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.06.03.12.30.12;	author gdurf;	state Exp;
branches;
next	10.12;

10.12
date	94.06.01.14.32.31;	author gdurf;	state Exp;
branches;
next	10.11;

10.11
date	94.03.02.20.49.00;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.07.15.21.27.32;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	93.07.15.21.23.26;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.11.23.20.54.36;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.09.03.19.36.56;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.06.12.19.59.21;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.04.04.00.08.43;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.04.03.05.04.24;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.12.18.06.38.44;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.11.04.23.15.09;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.12;	author mike;	state Rel4_0;
branches;
next	9.37;

9.37
date	91.08.31.07.30.00;	author butler;	state Exp;
branches;
next	9.36;

9.36
date	91.08.25.04.56.05;	author butler;	state Exp;
branches;
next	9.35;

9.35
date	91.08.25.04.28.42;	author butler;	state Exp;
branches;
next	9.34;

9.34
date	91.06.30.21.16.43;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	91.06.25.16.07.24;	author pjt;	state Exp;
branches;
next	9.32;

9.32
date	91.02.02.00.00.41;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	91.01.26.03.22.50;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.01.23.22.38.48;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.01.15.23.47.23;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.01.14.22.53.57;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.01.14.20.26.06;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.01.12.08.25.46;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.01.11.07.09.20;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.01.11.04.02.06;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.01.09.02.18.48;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	90.12.07.00.58.43;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	90.12.06.23.55.02;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	90.12.05.06.17.38;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	90.06.04.23.23.03;	author butler;	state Exp;
branches;
next	9.18;

9.18
date	90.05.22.21.42.35;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.05.18.07.43.52;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.05.09.20.00.56;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.05.04.04.20.13;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.05.04.03.47.39;	author butler;	state Exp;
branches;
next	9.13;

9.13
date	90.05.01.02.59.08;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.04.26.02.15.27;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.04.24.01.59.00;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.04.24.01.05.23;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.04.21.06.05.22;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.04.13.03.55.47;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.03.16.03.46.36;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.03.15.02.04.37;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.03.14.21.22.02;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.12.28.14.38.07;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.10.13.20.40.07;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.31.42;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.01.59;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.06.20.38.57;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.01.18.01.55.56;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.16.22.51.43;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.59.00;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.35;	author mike;	state Rel3_0;
branches;
next	7.8;

7.8
date	88.09.16.03.48.28;	author reschly;	state Exp;
branches;
next	7.7;

7.7
date	88.02.27.01.06.38;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.02.25.06.04.45;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.01.26.06.07.02;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.01.13.16.36.34;	author stay;	state Exp;
branches;
next	7.3;

7.3
date	87.11.05.07.09.05;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.03.51;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.50;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.02.05;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.18.13;	author mike;	state Rel;
branches;
next	4.7;

4.7
date	87.06.13.07.16.16;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.06.13.06.11.09;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.05.31.04.25.22;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.02.13.00.05.49;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.11.05.38.09;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.03.00.36.12;	author mike;	state Rel1;
branches;
next	4.1;

4.1
date	86.12.29.03.19.28;	author mike;	state Rel1;
branches;
next	2.29;

2.29
date	86.11.15.08.48.10;	author mike;	state Exp;
branches;
next	2.28;

2.28
date	86.11.14.05.00.20;	author mike;	state Exp;
branches;
next	2.27;

2.27
date	86.11.14.03.51.16;	author mike;	state Exp;
branches;
next	2.26;

2.26
date	86.11.04.01.40.46;	author mike;	state Exp;
branches;
next	2.25;

2.25
date	86.10.11.01.05.14;	author mike;	state Exp;
branches;
next	2.24;

2.24
date	86.08.12.06.47.10;	author mike;	state Exp;
branches;
next	2.23;

2.23
date	86.07.18.22.58.49;	author mike;	state Exp;
branches;
next	2.22;

2.22
date	86.07.18.02.33.53;	author mike;	state Exp;
branches;
next	2.21;

2.21
date	86.07.17.17.53.28;	author mike;	state Exp;
branches;
next	2.20;

2.20
date	86.06.20.00.25.56;	author mike;	state Exp;
branches;
next	2.19;

2.19
date	86.06.11.23.30.05;	author mike;	state Exp;
branches;
next	2.18;

2.18
date	86.03.14.20.41.50;	author mike;	state Exp;
branches;
next	2.17;

2.17
date	86.02.17.17.04.15;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	85.09.27.19.22.31;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	85.09.14.05.34.28;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	85.09.12.00.15.13;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	85.08.26.17.09.28;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	85.08.07.05.17.03;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	85.07.30.01.17.26;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	85.05.10.01.03.56;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.05.10.00.51.47;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.05.07.23.22.14;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.05.02.20.16.00;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.03.29.00.13.12;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.03.22.10.51.27;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.03.15.05.03.08;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.14.15.55.33;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.04.06.46;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.54.07;	author mike;	state Prod;
branches;
next	1.17;

1.17
date	85.03.08.20.53.38;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	85.02.14.01.54.36;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	85.02.14.01.22.11;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	85.02.14.00.59.06;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	85.02.06.02.31.21;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	85.02.05.04.55.16;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	85.02.05.04.17.00;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	85.02.02.01.40.07;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.02.01.03.25.59;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.02.01.00.50.06;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.01.17.07.28.04;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.01.16.03.00.50;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.01.16.01.56.33;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.11.22.06.55.45;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.20.04.22.51;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.17.05.35.31;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.48.12;	author mike;	state Exp;
branches;
next	;

11.144.2.1
date	2000.10.11.16.19.47;	author bparker;	state Exp;
branches;
next	11.144.2.2;

11.144.2.2
date	2000.10.12.16.17.09;	author bparker;	state Exp;
branches;
next	11.144.2.3;

11.144.2.3
date	2000.10.18.14.01.32;	author bparker;	state Exp;
branches;
next	11.144.2.4;

11.144.2.4
date	2001.01.03.21.09.14;	author bparker;	state Exp;
branches;
next	11.144.2.5;

11.144.2.5
date	2001.01.04.17.00.28;	author bparker;	state Exp;
branches;
next	11.144.2.6;

11.144.2.6
date	2001.02.09.15.26.31;	author bparker;	state Exp;
branches;
next	11.144.2.7;

11.144.2.7
date	2001.02.23.20.23.09;	author bparker;	state Exp;
branches;
next	11.144.2.8;

11.144.2.8
date	2001.03.02.18.29.06;	author bparker;	state Exp;
branches;
next	11.144.2.9;

11.144.2.9
date	2001.04.17.18.55.04;	author bparker;	state Exp;
branches;
next	11.144.2.10;

11.144.2.10
date	2001.07.11.12.32.07;	author jra;	state Exp;
branches;
next	;

11.188.2.1
date	2002.09.19.18.02.00;	author morrison;	state Exp;
branches;
next	11.188.2.2;

11.188.2.2
date	2004.03.17.21.21.55;	author morrison;	state Exp;
branches;
next	;

11.188.4.1
date	2004.03.11.23.46.33;	author morrison;	state Exp;
branches;
next	;

11.188.10.1
date	2003.12.03.17.56.00;	author erikg;	state Exp;
branches;
next	11.188.10.2;

11.188.10.2
date	2004.02.12.18.34.13;	author erikg;	state Exp;
branches;
next	11.188.10.3;

11.188.10.3
date	2004.03.15.14.07.35;	author erikg;	state Exp;
branches;
next	;


desc
@Implement keyboard commands to change the view
@


11.193
log
@moved to src/mged/
@
text
@/*
 *			C H G V I E W . C
 *
 * Functions -
 *	f_center	(DEBUG) force view center
 *	f_vrot		(DEBUG) force view rotation
 *	f_view		(DEBUG) force view size
 *	f_blast		zap the display, then edit anew
 *	f_edit		edit something (add to visible display)
 *	f_evedit	Evaluated edit something (add to visible display)
 *	f_delobj	delete an object or several from the display
 *	f_debug		(DEBUG) print solid info?
 *	f_regdebug	toggle debugging state
 *	cmd_list	list object information
 *	f_zap		zap the display -- everything dropped
 *	f_status	print view info
 *	f_fix		fix display processor after hardware error
 *	eraseobj	Drop an object from the visible list
 *	pr_schain	Print info about visible list
 *	f_ill		illuminate the named object
 *	f_sed		simulate pressing "solid edit" then illuminate
 *	f_knob		simulate knob twist
 *	f_slewview	Slew the view
 *	slewview	guts for f_setview
 *	f_setview	Set the current view
 *	setview		guts for f_setview
 *	usejoy		Apply joystick to viewing perspective
 *      absview_v       Absolute view rotation about view center
 *      f_vrot_center   Set the center of rotation -- not ready yet
 *      cmd_getknob     returns knob/slider value
 *      f_svbase        Set view base references (i.e. i_Viewscale and orig_pos)
 *      mged_svbase     Guts for f_svbase
 *      mged_tran       Guts for f_tran
 *      f_qvrot         Set view from direction vector and twist angle
 *      f_orientation   Set current view direction from a quaternion
 *      f_zoom          zoom view
 *      mged_zoom       guts for f_zoom
 *      abs_zoom        absolute zoom
 *      f_tol           set or display tolerance
 *      knob_tran       handle translations for f_knob
 *      f_aetview       set view using azimuth, elevation and twist angles
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/chgview.c,v 11.192 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <signal.h>
#include <math.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "mater.h"
#include "raytrace.h"
#include "nmg.h"
#include "externs.h"
#include "./sedit.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./cmd.h"
#include "../librt/debug.h"	/* XXX */

extern struct db_tree_state	mged_initial_tree_state;	/* dodraw.c */

extern void color_soltab(void);
extern void set_absolute_tran(void); /* defined in set.c */
extern void set_absolute_view_tran(void); /* defined in set.c */
extern void set_absolute_model_tran(void); /* defined in set.c */

void solid_list_callback(void);
void knob_update_rate_vars(void);
int mged_svbase(void);
int mged_vrot(char origin, fastf_t *newrot);
int mged_zoom(double val);
void mged_center(fastf_t *center);
static void abs_zoom(void);
void usejoy(double xangle, double yangle, double zangle);

int knob_rot(vect_t rvec, char origin, int mf, int vf, int ef);
int knob_tran(fastf_t *tvec, int model_flag, int view_flag, int edit_flag);
int mged_etran(struct view_obj *vop, Tcl_Interp *interp, char coords, vect_t tvec);
int mged_mtran(const fastf_t *tvec);
int mged_otran(const fastf_t *tvec);
int mged_vtran(const fastf_t *tvec);
int mged_tran(fastf_t *tvec);

#ifndef M_SQRT2
#define M_SQRT2		1.41421356237309504880
#endif

#ifndef M_SQRT2_DIV2
#define M_SQRT2_DIV2       0.70710678118654752440
#endif

extern vect_t curr_e_axes_pos;  /* from edsol.c */
extern long	nvectors;	/* from dodraw.c */

extern struct bn_tol mged_tol;	/* from ged.c */
extern vect_t e_axes_pos;

fastf_t ar_scale_factor = GED_MAX / ABS_ROT_FACTOR;
fastf_t rr_scale_factor = GED_MAX / RATE_ROT_FACTOR;
fastf_t adc_angle_scale_factor = GED_MAX / ADC_ANGLE_FACTOR;

vect_t edit_absolute_model_rotate;
vect_t edit_absolute_object_rotate;
vect_t edit_absolute_view_rotate;
vect_t last_edit_absolute_model_rotate;
vect_t last_edit_absolute_object_rotate;
vect_t last_edit_absolute_view_rotate;
vect_t edit_rate_model_rotate;
vect_t edit_rate_object_rotate;
vect_t edit_rate_view_rotate;
int edit_rateflag_model_rotate;
int edit_rateflag_object_rotate;
int edit_rateflag_view_rotate;

vect_t edit_absolute_model_tran;
vect_t edit_absolute_view_tran;
vect_t last_edit_absolute_model_tran;
vect_t last_edit_absolute_view_tran;
vect_t edit_rate_model_tran;
vect_t edit_rate_view_tran;
int edit_rateflag_model_tran;
int edit_rateflag_view_tran;

fastf_t edit_absolute_scale;
fastf_t edit_rate_scale;
int edit_rateflag_scale;

char edit_rate_model_origin;
char edit_rate_object_origin;
char edit_rate_view_origin;
char edit_rate_coords;
struct dm_list *edit_rate_mr_dm_list;
struct dm_list *edit_rate_or_dm_list;
struct dm_list *edit_rate_vr_dm_list;
struct dm_list *edit_rate_mt_dm_list;
struct dm_list *edit_rate_vt_dm_list;

struct bu_vls edit_info_vls;
struct bu_vls edit_rate_model_tran_vls[3];
struct bu_vls edit_rate_view_tran_vls[3];
struct bu_vls edit_rate_model_rotate_vls[3];
struct bu_vls edit_rate_object_rotate_vls[3];
struct bu_vls edit_rate_view_rotate_vls[3];
struct bu_vls edit_rate_scale_vls;
struct bu_vls edit_absolute_model_tran_vls[3];
struct bu_vls edit_absolute_view_tran_vls[3];
struct bu_vls edit_absolute_model_rotate_vls[3];
struct bu_vls edit_absolute_object_rotate_vls[3];
struct bu_vls edit_absolute_view_rotate_vls[3];
struct bu_vls edit_absolute_scale_vls;

double		mged_abs_tol;
double		mged_rel_tol = 0.01;		/* 1%, by default */
double		mged_nrm_tol;			/* normal ang tol, radians */

/* Delete an object or several objects from the display */
/* Format: d object1 object2 .... objectn */
int
cmd_erase(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int     	argc,
	  char    	**argv)
{
#if 1
	int	ret;

	CHECK_DBI_NULL;

	ret = dgo_erase_cmd(dgop, interp, argc, argv);
	solid_list_callback();
	update_views = 1;

	return ret;
#else
	CHECK_DBI_NULL;

	if (argc < 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	eraseobjpath(interp, argc-1, argv+1, LOOKUP_NOISY, 0);
	solid_list_callback();

	return TCL_OK;
#endif
}

int
cmd_erase_all(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
#if 1
	int	ret;

	CHECK_DBI_NULL;

	ret = dgo_erase_all_cmd(dgop, interp, argc, argv);
	solid_list_callback();
	update_views = 1;

	return ret;
#else
  CHECK_DBI_NULL;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  eraseobjpath(interp, argc-1, argv+1, LOOKUP_NOISY, 1);
  solid_list_callback();

  return TCL_OK;
#endif
}

/* DEBUG -- force view center */
/* Format: C x y z	*/
int
cmd_center(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	int	ret;

	CHECK_DBI_NULL;

	if ((ret = vo_center_cmd(view_state->vs_vop, interp, argc, argv)) == TCL_OK && argc > 1)
		(void)mged_svbase();

	return ret;
}

void
mged_center(point_t center)
{
	vo_center(view_state->vs_vop, interp, center);
	(void)mged_svbase();
}

/* DEBUG -- force viewsize */
/* Format: view size	*/
int
cmd_size(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	int	ret;

	CHECK_DBI_NULL;

	if ((ret = vo_size_cmd(view_state->vs_vop, interp, argc, argv)) == TCL_OK && argc > 1) {
		view_state->vs_absolute_scale = 1.0 - view_state->vs_vop->vo_scale / view_state->vs_i_Viewscale;
		if (view_state->vs_absolute_scale < 0.0)
			view_state->vs_absolute_scale /= 9.0;

		if (view_state->vs_absolute_tran[X] != 0.0 ||
		    view_state->vs_absolute_tran[Y] != 0.0 ||
		    view_state->vs_absolute_tran[Z] != 0.0)
			set_absolute_tran();
	}

	return ret;
}

#if 0
/* XXX until NMG support is complete,
 * XXX the old Big-E command is retained in all its glory in
 * XXX the file proc_reg.c, including the command processing.
 */
/*
 *			F _ E V E D I T
 *
 *  The "Big E" command.
 *  Evaluated Edit something (add to visible display)
 *  Usage: E object(s)
 */
int
f_evedit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help E");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return edit_com( argc, argv, 2, 1 );
}
#endif

/*
 *			S I Z E _ R E S E T
 *
 *  Reset view size and view center so that all solids in the solid table
 *  are in view.
 *  Caller is responsible for calling new_mats().
 */
void
size_reset(void)
{
	dgo_autoview(dgop, view_state->vs_vop, interp);
	view_state->vs_i_Viewscale = view_state->vs_vop->vo_scale;
}

/*
 *			E D I T _ C O M
 *
 * B and e commands use this area as common
 */
int
edit_com(int	argc,
	 char	**argv,
	 int	kind,
	 int	catch_sigint)
{
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
	register struct cmd_list *save_cmd_list;
	int		ret;
	int		initial_blank_screen;
	int		attr_flag=0;
	int		oflag=1;
	int		i;
	int		last_opt=0;
	struct bu_vls	vls;

	CHECK_DBI_NULL;

	initial_blank_screen = BU_LIST_IS_EMPTY(&dgop->dgo_headSolid);

	/* check args for "-A" (attributes) and "-o" */
	bu_vls_init( &vls );
	bu_vls_strcpy( &vls, argv[0] );
	for( i=1 ; i<argc ; i++ ) {
		char *ptr_A=NULL;
		char *ptr_o=NULL;
		char *c;

		if( *argv[i] != '-' ) break;
		if( (ptr_A=strchr( argv[i], 'A' )) ) attr_flag = 1;
		if( (ptr_o=strchr( argv[i], 'o' )) ) oflag = 2;
		last_opt = i;

		if( !ptr_A && !ptr_o ) {
			bu_vls_putc( &vls, ' ' );
			bu_vls_strcat( &vls, argv[i] );
			continue;
		}

		if( strlen( argv[i] ) == (1 + (ptr_A != NULL) + (ptr_o != NULL))) {
			/* argv[i] is just a "-A" or "-o" */
			continue;
		}

		/* copy args other than "-A" or "-o" */
		bu_vls_putc( &vls, ' ' );
		c = argv[i];
		while( *c != '\0' ) {
			if( *c != 'A' && *c != 'o' ) {
				bu_vls_putc( &vls, *c );
			}
			c++;
		}
	}

	if( attr_flag ) {
		/* args are attribute name/value pairs */
		struct bu_attribute_value_set avs;
		int max_count=0;
		int remaining_args=0;
		int new_argc=0;
		char **new_argv=NULL;
		struct bu_ptbl *tbl;

		remaining_args = argc - last_opt - 1;;
		if( remaining_args < 2 || remaining_args%2 ) {
			bu_log( "Error: must have even number of arguments (name/value pairs)\n" );
			return TCL_ERROR;
		}

		bu_avs_init( &avs, (argc - last_opt)/2, "edit_com avs" );
		i = 1;
		while( i < argc ) {
			if( *argv[i] == '-' ) {
				i++;
				continue;
			}

			/* this is a name/value pair */
			if( oflag == 2 ) {
				bu_avs_add_nonunique( &avs, argv[i], argv[i+1] );
			} else {
				bu_avs_add( &avs, argv[i], argv[i+1] );
			}
			i += 2;
		}

		tbl = db_lookup_by_attr( dbip, DIR_REGION | DIR_SOLID | DIR_COMB, &avs, oflag );
		bu_avs_free( &avs );
		if( !tbl ) {
			bu_log( "Error: db_lookup_by_attr() failed!!\n" );
			bu_vls_free( &vls );
			return TCL_ERROR;
		}
		for( i=0 ; i<BU_PTBL_LEN( tbl ) ; i++ ) {
			struct directory *dp;

			dp = (struct directory *)BU_PTBL_GET( tbl, i );
			bu_vls_putc( &vls, ' ' );
			bu_vls_strcat( &vls, dp->d_namep );
		}

		max_count = BU_PTBL_LEN( tbl ) + last_opt + 2;
		bu_ptbl_free( tbl );
		bu_free( (char *)tbl, "edit_com ptbl" );
		new_argv = (char **)bu_calloc( max_count, sizeof( char *), "edit_com new_argv" );
		new_argc = bu_argv_from_string( new_argv, max_count, bu_vls_addr( &vls ) );
		
		if ((ret = dgo_draw_cmd(dgop, interp, new_argc, new_argv, kind)) != TCL_OK) {
			bu_vls_free( &vls );
			bu_free( (char *)new_argv, "edit_com new_argv" );
			return ret;
		}
		bu_vls_free( &vls );
		bu_free( (char *)new_argv, "edit_com new_argv" );
	} else {
		bu_vls_free( &vls );
		if ((ret = dgo_draw_cmd(dgop, interp, argc, argv, kind)) != TCL_OK)
			return ret;
	}
		
	update_views = 1;

	save_dmlp = curr_dm_list;
	save_cmd_list = curr_cmd_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
		curr_dm_list = dmlp;
		if (curr_dm_list->dml_tie)
			curr_cmd_list = curr_dm_list->dml_tie;
		else
			curr_cmd_list = &head_cmd_list;

		/* If we went from blank screen to non-blank, resize */
		if (mged_variables->mv_autosize && initial_blank_screen &&
		    BU_LIST_NON_EMPTY(&dgop->dgo_headSolid)) {
			struct view_ring *vrp;

			dgo_autoview(dgop, view_state->vs_vop, interp);
			(void)mged_svbase();

			for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
				vrp->vr_scale = view_state->vs_vop->vo_scale;
		}
	}

	curr_dm_list = save_dmlp;
	curr_cmd_list = save_cmd_list;

	return TCL_OK;
}

int
emuves_com( int argc, char **argv )
{
	int i;
	struct bu_ptbl *tbl;
	struct bu_attribute_value_set avs;
	char **objs;
	int ret;
	int num_opts=0;

	CHECK_DBI_NULL;

	if( argc < 2 ) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( i=1 ; i<argc ; i++ ) {
		if( *argv[i] == '-' ) {
			num_opts++;
		} else {
			break;
		}
	}

	bu_avs_init( &avs, argc/2, "muves_avs" );
	for( i=1 ; i<argc ; i++ ) {
		bu_avs_add_nonunique( &avs, "MUVES_Component", argv[i] );
	}

	tbl = db_lookup_by_attr( dbip, DIR_REGION, &avs, 2 );

	bu_avs_free( &avs );

	if( !tbl ) {
		return TCL_OK;
	}

	if( BU_PTBL_LEN( tbl ) < 1 ) {
		bu_free( (char *)tbl, "tbl returned by wdb_get_by_attr" );
		return TCL_OK;
	}

	objs = (char **)bu_calloc( (BU_PTBL_LEN( tbl ) + 1 + num_opts), sizeof( char *), "emuves_com objs" );
	for( i=0 ; i<=num_opts ; i++ ) {
		objs[i] = argv[i];
	}
	for( i=0 ; i<BU_PTBL_LEN( tbl ) ; i++ ) {
		struct directory *dp;

		dp = (struct directory *)BU_PTBL_GET( tbl, i );
		objs[i+num_opts+1] = dp->d_namep;
	}

	ret = edit_com( (BU_PTBL_LEN( tbl ) + 1), objs, 1, 1 );
	bu_ptbl_free( tbl );
	bu_free( (char *)tbl, "tbl returned by wdb_get_by_attr" );
	bu_free( (char *)objs, "emuves_com objs" );
	return( ret );
}

int
cmd_autoview(ClientData clientData,
	     Tcl_Interp *interp,
	     int	argc,
	     char	**argv)
{
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
	register struct cmd_list *save_cmd_list;

	if (argc != 1) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help autoview");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	save_dmlp = curr_dm_list;
	save_cmd_list = curr_cmd_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
		struct view_ring *vrp;

		curr_dm_list = dmlp;
		if (curr_dm_list->dml_tie)
			curr_cmd_list = curr_dm_list->dml_tie;
		else
			curr_cmd_list = &head_cmd_list;

		dgo_autoview(dgop, view_state->vs_vop, interp);
		(void)mged_svbase();

		for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
			vrp->vr_scale = view_state->vs_vop->vo_scale;
	}
	curr_dm_list = save_dmlp;
	curr_cmd_list = save_cmd_list;

	return TCL_OK;
}

int
cmd_get_autoview(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	return dgo_get_autoview_cmd(dgop, interp, argc, argv);
}

void
solid_list_callback(void)
{
  struct bu_vls vls;
  Tcl_Obj *save_obj;

  /* save result */
  save_obj = Tcl_GetObjResult(interp);
  Tcl_IncrRefCount(save_obj);

  bu_vls_init(&vls);
  bu_vls_strcpy(&vls, "solid_list_callback");
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  /* restore result */
  Tcl_SetObjResult(interp, save_obj);
  Tcl_DecrRefCount(save_obj);
}

/*
 *			F _ D E B U G
 *
 *  Print information about solid table, and per-solid VLS
 */
int
cmd_solid_report(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int		argc,
		 char		**argv)
{
	CHECK_DBI_NULL;

	return dgo_report_cmd(dgop, interp, argc, argv);
}

/*
 *			F _ R E G D E B U G
 *
 *  Display-manager specific "hardware register" debugging.
 */
int
f_regdebug(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	static int regdebug = 0;
	static char debug_str[10];

	if(argc < 1 || 2 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help regdebug");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( argc == 1 )
		regdebug = !regdebug;	/* toggle */
	else
		regdebug = atoi( argv[1] );

	sprintf( debug_str, "%d", regdebug );

	Tcl_AppendResult(interp, "regdebug=", debug_str, "\n", (char *)NULL);

	DM_DEBUG(dmp, regdebug);

	return TCL_OK;
}

/*
 *			F _ D E B U G B U
 *
 *  Provide user-level access to LIBBU debug bit vector.
 */
int
f_debugbu(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (argc < 1 || 2 < argc) {
		bu_vls_printf(&vls, "help debugbu");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}


	if( argc >= 2 )  {
		sscanf( argv[1], "%x", (unsigned int *)&bu_debug );
	} else {
		bu_vls_printb(&vls, "Possible flags", 0xffffffffL, BU_DEBUG_FORMAT );
		bu_vls_printf(&vls, "\n");
	}
	bu_vls_printb(&vls, "bu_debug", bu_debug, BU_DEBUG_FORMAT );
	bu_vls_printf(&vls, "\n");

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 *			F _ D E B U G L I B
 *
 *  Provide user-level access to LIBRT debug bit vector
 */
int
f_debuglib(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (argc < 1 || 2 < argc) {
		bu_vls_printf(&vls, "help debuglib");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc >= 2) {
		sscanf(argv[1], "%x", (unsigned int *)&rt_g.debug);
		if (RT_G_DEBUG) bu_debug |= BU_DEBUG_COREDUMP;
	} else {
		bu_vls_printb(&vls, "Possible flags", 0xffffffffL, DEBUG_FORMAT);
		bu_vls_printf(&vls, "\n");
	}
	bu_vls_printb(&vls, "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT);
	bu_vls_printf(&vls, "\n");

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 *			F _ D E B U G M E M
 *
 *  Provide user-level access to LIBBU bu_prmem() routine.
 *  Must be used in concert with BU_DEBUG_MEM_CHECK flag.
 */
int
f_debugmem(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	if (argc < 1 || 1 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help debugmem");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
		(void)signal( SIGINT, sig3 );	/* allow interupts */
	else
		return TCL_OK;

	bu_prmem("Invoked via MGED command");

	(void)signal(SIGINT, SIG_IGN);
	return TCL_OK;
}

/*
 *			F _ D E B U G N M G
 *
 *  Provide user-level access to LIBRT NMG_debug flags.
 */
int
f_debugnmg(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (argc < 1 || 2 < argc) {
		bu_vls_printf(&vls, "help debugnmg");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc >= 2) {
		sscanf(argv[1], "%x", (unsigned int *)&rt_g.NMG_debug);
	} else {
		bu_vls_printb(&vls, "possible flags", 0xffffffffL, NMG_DEBUG_FORMAT);
		bu_vls_printf(&vls, "\n");
	}
	bu_vls_printb(&vls, "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT);
	bu_vls_printf(&vls, "\n");

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 *			D O _ L I S T
 */
void
do_list(struct bu_vls *outstrp, register struct directory *dp, int verbose)
{
	int			id;
	struct rt_db_internal	intern;

	if(dbip == DBI_NULL)
	  return;

	if( (id = rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource )) < 0 )  {
		Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
			") failure\n", (char *)NULL );
		return;
	}

	bu_vls_printf( outstrp, "%s:  ", dp->d_namep );

	if( rt_functab[id].ft_describe( outstrp, &intern,
	    verbose, base2local, &rt_uniresource, dbip ) < 0 )
	  Tcl_AppendResult(interp, dp->d_namep, ": describe error\n", (char *)NULL);
	rt_db_free_internal( &intern, &rt_uniresource );
}

/*
 *  To return all the free "struct bn_vlist" and "struct solid" items
 *  lurking on their respective freelists, back to bu_malloc().
 *  Primarily as an aid to tracking memory leaks.
 *  WARNING:  This depends on knowledge of the macro GET_SOLID in mged/solid.h
 *  and RT_GET_VLIST in h/raytrace.h.
 */
void
mged_freemem(void)
{
  register struct solid		*sp;
  register struct bn_vlist	*vp;

  FOR_ALL_SOLIDS(sp,&FreeSolid.l){
    GET_SOLID(sp,&FreeSolid.l);
    bu_free((genptr_t)sp, "mged_freemem: struct solid");
  }

  while( BU_LIST_NON_EMPTY( &rt_g.rtg_vlfree ) )  {
    vp = BU_LIST_FIRST( bn_vlist, &rt_g.rtg_vlfree );
    BU_LIST_DEQUEUE( &(vp->l) );
    bu_free( (genptr_t)vp, "mged_freemem: struct bn_vlist" );
  }
}

/* ZAP the display -- everything dropped */
/* Format: Z	*/
int
cmd_zap(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	update_views = 1;

	/* FIRST, reject any editing in progress */
	if (state != ST_VIEW)
		button(BE_REJECT);

#ifdef DO_DISPLAY_LISTS
	freeDListsAll(BU_LIST_FIRST(solid, &dgop->dgo_headSolid)->s_dlist,
		      BU_LIST_LAST(solid, &dgop->dgo_headSolid)->s_dlist -
		      BU_LIST_FIRST(solid, &dgop->dgo_headSolid)->s_dlist + 1);
#endif

	dgo_zap_cmd(dgop, interp);

	/* Keeping freelists improves performance.  When debugging, give mem back */
	if (RT_G_DEBUG)
		mged_freemem();

	(void)chg_state(state, state, "zap");
	solid_list_callback();

	return TCL_OK;
}

int
f_status(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;

	CHECK_DBI_NULL;

	if (argc < 1 || 2 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help status");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc == 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "STATE=%s, ", state_str[state] );
		bu_vls_printf(&vls, "Viewscale=%f (%f mm)\n",
			      view_state->vs_vop->vo_scale*base2local, view_state->vs_vop->vo_scale);
		bu_vls_printf(&vls, "base2local=%f\n", base2local);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		bn_tcl_mat_print(interp, "toViewcenter", view_state->vs_vop->vo_center);
		bn_tcl_mat_print(interp, "Viewrot", view_state->vs_vop->vo_rotation);
		bn_tcl_mat_print(interp, "model2view", view_state->vs_vop->vo_model2view);
		bn_tcl_mat_print(interp, "view2model", view_state->vs_vop->vo_view2model);

		if (state != ST_VIEW) {
			bn_tcl_mat_print(interp, "model2objview", view_state->vs_model2objview);
			bn_tcl_mat_print(interp, "objview2model", view_state->vs_objview2model);
		}

		return TCL_OK;
	}

	if (!strcmp(argv[1], "state")) {
		Tcl_AppendResult(interp, state_str[state], (char *)NULL);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "Viewscale")) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%f", view_state->vs_vop->vo_scale*base2local);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "base2local")) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%f", base2local);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "local2base")) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%f", local2base);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "toViewcenter")) {
		bn_tcl_mat_print(interp, "toViewcenter", view_state->vs_vop->vo_center);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "Viewrot")) {
		bn_tcl_mat_print(interp, "Viewrot", view_state->vs_vop->vo_rotation);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "model2view")) {
		bn_tcl_mat_print(interp, "model2view", view_state->vs_vop->vo_model2view);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "view2model")) {
		bn_tcl_mat_print(interp, "view2model", view_state->vs_vop->vo_view2model);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "model2objview")) {
		bn_tcl_mat_print(interp, "model2objview", view_state->vs_model2objview);
		return TCL_OK;
	}

	if (!strcmp(argv[1], "objview2model")) {
		bn_tcl_mat_print(interp, "objview2model", view_state->vs_objview2model);
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help status");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	if (!strcmp(argv[1], "help"))
		return TCL_OK;

	return TCL_ERROR;
}

int
f_view(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int n;
	point_t pt;
	mat_t mat;
	struct bu_vls vls;

	CHECK_DBI_NULL;

	if (argc < 1 || 6 < argc) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help view");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	if (argc == 1) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help view");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_OK;
	}

	if (!strcmp(argv[1], "quat")) {
		quat_t quat;

		/* return Viewrot as a quaternion */
		if (argc == 2) {
			quat_mat2quat(quat, view_state->vs_vop->vo_rotation);

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "%.12g %.12g %.12g %.12g", V4ARGS(quat));
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_OK;
		}

		if (argc != 6) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view: quat requires four parameters");
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		/* attempt to set Viewrot given a quaternion */
		n = sscanf(argv[2], "%lf", quat);
		n += sscanf(argv[3], "%lf", quat+1);
		n += sscanf(argv[4], "%lf", quat+2);
		n += sscanf(argv[5], "%lf", quat+3);

		if (n < 4) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view quat: bad value detected - %s %s %s %s",
				      argv[2], argv[3], argv[4], argv[5]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		quat_quat2mat(view_state->vs_vop->vo_rotation, quat);
		new_mats();

		return TCL_OK;
	}

	if (!strcmp(argv[1], "ypr")) {
		vect_t ypr;

		/* return Viewrot as yaw, pitch and roll */
		if (argc == 2) {
			bn_mat_trn(mat, view_state->vs_vop->vo_rotation);
			anim_v_unpermute(mat);
			n = anim_mat2ypr(pt, mat);
			if (n == 2) {
				Tcl_AppendResult(interp, "mat2ypr - matrix is not a rotation matrix", (char *)NULL);
				return TCL_ERROR;
			}
			VSCALE(pt, pt, bn_radtodeg);

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "%.12g %.12g %.12g", V3ARGS(pt));
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_OK;
		}

		if (argc != 5) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view: ypr requires 3 parameters");
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		/* attempt to set Viewrot given yaw, pitch and roll */
		n = sscanf(argv[2], "%lf", ypr);
		n += sscanf(argv[3], "%lf", ypr+1);
		n += sscanf(argv[4], "%lf", ypr+2);

		if (n < 3) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view ypr: bad value detected - %s %s %s",
				      argv[2], argv[3], argv[4]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		anim_dy_p_r2mat(mat, V3ARGS(ypr));
		anim_v_permute(mat);
		bn_mat_trn(view_state->vs_vop->vo_rotation, mat);
		new_mats();

		return TCL_OK;
	}

	if (!strcmp(argv[1], "aet")) {
		vect_t aet;

		/* return Viewrot as azimuth, elevation and twist */
		if (argc == 2){
			bu_vls_init(&vls);
			bn_encode_vect(&vls, view_state->vs_vop->vo_aet);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_OK;
		}

		if(argc != 5){
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view: aet requires 3 parameters");
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		/* attempt to set Viewrot given azimuth, elevation and twist */
		n = sscanf(argv[2], "%lf", aet);
		n += sscanf(argv[3], "%lf", aet+1);
		n += sscanf(argv[4], "%lf", aet+2);

		if (n < 3) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view aet: bad value detected - %s %s %s",
				      argv[2], argv[3], argv[4]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		VMOVE(view_state->vs_vop->vo_aet, aet);
		vo_mat_aet(view_state->vs_vop);
		new_mats();

		return TCL_OK;
	}

	if (!strcmp(argv[1], "center")) {
		point_t center;

		/* return view center */
		if (argc == 2) {
			MAT_DELTAS_GET_NEG(center, view_state->vs_vop->vo_center);
			VSCALE(center, center, base2local);

			bu_vls_init(&vls);
			bn_encode_vect(&vls, center);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_OK;
		}

		if (argc != 5) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view: center requires 3 parameters");
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* attempt to set the view center */
		n = sscanf(argv[2], "%lf", center);
		n += sscanf(argv[3], "%lf", center+1);
		n += sscanf(argv[4], "%lf", center+2);

		if (n < 3) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view center: bad value detected - %s %s %s",
				      argv[2], argv[3], argv[4]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		vo_center(view_state->vs_vop, interp, center);

		return TCL_OK;
	}

	if (!strcmp(argv[1], "eye")) {
		point_t eye;
		vect_t dir;

		/* return the eye point */
		if (argc == 2) {
			VSET(pt, 0.0, 0.0, 1.0);
			MAT4X3PNT(eye, view_state->vs_vop->vo_view2model, pt);
			VSCALE(eye, eye, base2local);

			bu_vls_init(&vls);
			bn_encode_vect(&vls, eye);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_OK;
		}

		if (argc != 5) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view: eye requires 3 parameters");
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		/* attempt to set view center given the eye point */
		n = sscanf(argv[2], "%lf", eye);
		n += sscanf(argv[3], "%lf", eye+1);
		n += sscanf(argv[4], "%lf", eye+2);

		if (n < 3) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view eye: bad value detected - %s %s %s",
				      argv[2], argv[3], argv[4]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		VSCALE(eye, eye, local2base);
		VSET(pt, 0.0, 0.0, view_state->vs_vop->vo_scale);
		bn_mat_trn(mat, view_state->vs_vop->vo_rotation);
		MAT4X3PNT(dir, mat, pt);
		VSUB2(pt, dir, eye);
		MAT_DELTAS_VEC(view_state->vs_vop->vo_center, pt);
		new_mats();

		return TCL_OK;
	}

	if (!strcmp(argv[1], "size")) {
		fastf_t size;

		/* return the view size */
		if (argc == 2) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "%.12g", view_state->vs_vop->vo_size * base2local);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_OK;
		}

		if (argc != 3) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view: size requires 1 parameter");
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		if (sscanf(argv[2], "%lf", &size) != 1) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "view size: bad value detected - %s", argv[2]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		vo_size(view_state->vs_vop, interp, size);
		return TCL_OK;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help view");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

int
f_refresh(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help refresh");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  view_state->vs_flag = 1;		/* causes refresh() */
  return TCL_OK;
}

#if 0
int
mged_aetview(int	iflag,
	     fastf_t	azim,
	     fastf_t	elev,
	     fastf_t	twist)
{
  int status = TCL_OK;
  fastf_t o_twist;
  fastf_t o_arz;
  fastf_t o_larz;
  struct bu_vls vls;

  /* grab old twist angle before it's lost */
  o_twist = view_state->vs_vop->vo_aet[BN_TWIST];
  o_arz = view_state->vs_absolute_rotate[Z];
  o_larz = view_state->vs_last_absolute_rotate[Z];

  /* set view using azimuth and elevation angles */
  if(iflag)
    setview(270.0 + elev + view_state->vs_vop->vo_aet[BN_ELEVATION],
	    0.0,
	    270.0 - azim - view_state->vs_vop->vo_aet[BN_AZIMUTH]);
  else
    setview(270.0 + elev, 0.0, 270.0 - azim );

  bu_vls_init(&vls);

  if(iflag)
    bu_vls_printf(&vls, "knob -i -v az %f", -o_twist - twist);
  else
    bu_vls_printf(&vls, "knob -i -v az %f", -twist);

  status = Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  view_state->vs_absolute_rotate[Z] = o_arz;
  view_state->vs_last_absolute_rotate[Z] = o_larz;

  return status;
}
#endif

/* set view using azimuth, elevation and twist angles */
int
cmd_aetview(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
#if 1
	return vo_aet_cmd(view_state->vs_vop, interp, argc, argv);
#else
  int iflag = 0;
  fastf_t twist = 0.0;  /* assumed to be 0.0 ---- unless supplied by user */

  if(argc < 3 || 5 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help ae");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Check for -i option */
  if(argv[1][0] == '-' && argv[1][1] == 'i'){
    iflag = 1;  /* treat arguments as incremental values */
    ++argv;
    --argc;
  }

  if (argc < 3) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help ae");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(argc == 4) /* twist angle supplied */
    twist = atof(argv[3]);

  return mged_aetview(iflag, atof(argv[1]), atof(argv[2]), twist);
#endif
}


/*
 *			E R A S E O B J A L L
 *
 * This routine goes through the solid table and deletes all solids
 * from the solid list which contain the specified object anywhere in their 'path'
 */
void
eraseobjall(register struct directory **dpp)
                                     	/* this is a partial path spec. XXX should be db_full_path? */
{
	register struct directory **tmp_dpp;
	register struct solid *sp;
	register struct solid *nsp;
	struct db_full_path	subpath;

	if (dbip == DBI_NULL)
		return;

	update_views = 1;

	db_full_path_init(&subpath);
	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)  {
		RT_CK_DIR(*tmp_dpp);
		db_add_node_to_full_path(&subpath, *tmp_dpp);
	}

	sp = BU_LIST_NEXT(solid, &dgop->dgo_headSolid);
	while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid)) {
		nsp = BU_LIST_PNEXT(solid, sp);

		if( db_full_path_subset( &sp->s_fullpath, &subpath ) )  {
#ifdef DO_DISPLAY_LISTS
			freeDListsAll(sp->s_dlist, 1);
#endif

			if (state != ST_VIEW && illump == sp)
				button(BE_REJECT);

			BU_LIST_DEQUEUE(&sp->l);
			FREE_SOLID(sp, &FreeSolid.l);
		}
		sp = nsp;
	}

	if ((*dpp)->d_addr == RT_DIR_PHONY_ADDR) {
		if (db_dirdelete(dbip, *dpp) < 0) {
			Tcl_AppendResult(interp, "eraseobjall: db_dirdelete failed\n", (char *)NULL);
		}
	}

	db_free_full_path(&subpath);
}


/*
 *			E R A S E O B J
 *
 * This routine goes through the solid table and deletes all solids
 * from the solid list which contain the specified object at the
 * beginning of their 'path'
 */
void
eraseobj(register struct directory **dpp)
                                     	/* this is a partial path spec. XXX should be db_full_path? */
{
	register struct directory **tmp_dpp;
	register struct solid *sp;
	register struct solid *nsp;
	struct db_full_path	subpath;

	if (dbip == DBI_NULL)
		return;

	if (*dpp == DIR_NULL)
		return;

	update_views = 1;

	db_full_path_init(&subpath);
	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)  {
		RT_CK_DIR(*tmp_dpp);
		db_add_node_to_full_path(&subpath, *tmp_dpp);
	}

	sp = BU_LIST_FIRST(solid, &dgop->dgo_headSolid);
	while (BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid)) {
		nsp = BU_LIST_PNEXT(solid, sp);

		if( db_full_path_subset( &sp->s_fullpath, &subpath ) )  {

#ifdef DO_DISPLAY_LISTS
			freeDListsAll(sp->s_dlist, 1);
#endif

			if (state != ST_VIEW && illump == sp)
				button( BE_REJECT );

			BU_LIST_DEQUEUE(&sp->l);
			FREE_SOLID(sp, &FreeSolid.l);
		}
		sp = nsp;
	}

	if ((*dpp)->d_addr == RT_DIR_PHONY_ADDR ) {
		if (db_dirdelete(dbip, *dpp) < 0) {
			Tcl_AppendResult(interp, "eraseobj: db_dirdelete failed\n", (char *)NULL);
		}
	}

	db_free_full_path(&subpath);
}


/*
 *			P R _ S C H A I N
 *
 *  Given a pointer to a member of the circularly linked list of solids
 *  (typically the head), chase the list and print out the information
 *  about each solid structure.
 */
void
pr_schain(struct solid *startp, int lvl)
                     
   		    			/* debug level */
{
  register struct solid	*sp;
  register struct bn_vlist	*vp;
  int			nvlist;
  int			npts;
  struct bu_vls vls;

  if(dbip == DBI_NULL)
    return;

  bu_vls_init(&vls);

  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3);
  else{
    bu_vls_free(&vls);
    return;
  }

  FOR_ALL_SOLIDS(sp, &startp->l){
    if (lvl <= -2) {
      /* print only leaves */
      bu_vls_printf(&vls, "%s ", LAST_SOLID(sp)->d_namep );
      continue;
    }

    if( lvl != -1 )
	bu_vls_printf(&vls, "%s", sp->s_flag == UP ? "VIEW " : "-no- ");
    db_path_to_vls(&vls, &sp->s_fullpath);
    if(( lvl != -1 ) && ( sp->s_iflag == UP ))
      bu_vls_printf(&vls, " ILLUM");

    bu_vls_printf(&vls, "\n");

    if( lvl <= 0 )  continue;

    /* convert to the local unit for printing */
    bu_vls_printf(&vls, "  cent=(%.3f,%.3f,%.3f) sz=%g ",
		  sp->s_center[X]*base2local,
		  sp->s_center[Y]*base2local, 
		  sp->s_center[Z]*base2local,
		  sp->s_size*base2local );
    bu_vls_printf(&vls, "reg=%d\n",sp->s_regionid );
    bu_vls_printf(&vls, "  basecolor=(%d,%d,%d) color=(%d,%d,%d)%s%s%s\n",
		  sp->s_basecolor[0],
		  sp->s_basecolor[1],
		  sp->s_basecolor[2],
		  sp->s_color[0],
		  sp->s_color[1],
		  sp->s_color[2],
  		  sp->s_uflag?" U":"",
  		  sp->s_dflag?" D":"",
  		  sp->s_cflag?" C":"");

    if( lvl <= 1 )  continue;

    /* Print the actual vector list */
    nvlist = 0;
    npts = 0;
    for( BU_LIST_FOR( vp, bn_vlist, &(sp->s_vlist) ) )  {
      register int	i;
      register int	nused = vp->nused;
      register int	*cmd = vp->cmd;
      register point_t *pt = vp->pt;

      BN_CK_VLIST( vp );
      nvlist++;
      npts += nused;
      if( lvl <= 2 )  continue;

      for( i = 0; i < nused; i++,cmd++,pt++ )  {
	bu_vls_printf(&vls, "  %s (%g, %g, %g)\n",
		      rt_vlist_cmd_descriptions[*cmd],
		      V3ARGS( *pt ) );
      }
    }

    bu_vls_printf(&vls, "  %d vlist structures, %d pts\n", nvlist, npts );
    bu_vls_printf(&vls, "  %d pts (via rt_ck_vlist)\n", rt_ck_vlist( &(sp->s_vlist) ) );
  }

  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
  (void)signal( SIGINT, SIG_IGN );
}

static char ** path_parse (char *path);

/* Illuminate the named object */
int
f_ill(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *dp;
	register struct solid *sp;
	struct solid *lastfound = SOLID_NULL;
	register int i, j;
	int nmatch;
	int	c;
	int	ri = 0;
	int	nm_pieces;
	int	illum_only = 0;
	char	**path_piece = 0;
	char	*basename;
	char	*sname;

	CHECK_DBI_NULL;

	if (argc < 2 || 5 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help ill");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_optind = 1;
	while ((c = bu_getopt(argc, argv, "i:n")) != EOF) {
		switch (c) {
		case 'n':
			illum_only = 1;
			break;
		case 'i':
			sscanf(bu_optarg, "%d", &ri);
			if (ri <= 0) {
				Tcl_AppendResult(interp,
						 "the reference index must be greater than 0\n",
						 (char *)NULL);
				return TCL_ERROR;
			}

			break;
		default:
		case 'h':
			{
				struct bu_vls vls;

				bu_vls_init(&vls);
				bu_vls_printf(&vls, "help ill");
				Tcl_Eval(interp, bu_vls_addr(&vls));
				bu_vls_free(&vls);
				return TCL_ERROR;
			}
		}
	}

	argc -= (bu_optind - 1);
	argv += (bu_optind - 1);

	if(argc != 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help ill");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if(state != ST_S_PICK && state != ST_O_PICK){
	  state_err("keyboard illuminate pick");
	  goto bail_out;
	}

	path_piece = path_parse(argv[1]);
	for (nm_pieces = 0; path_piece[nm_pieces] != 0; ++nm_pieces)
	  ;

	if(nm_pieces == 0){
	  Tcl_AppendResult(interp, "Bad solid path: '", argv[1], "'\n", (char *)NULL);
	  goto bail_out;
	}

	basename = path_piece[nm_pieces - 1];

	if( (dp = db_lookup( dbip,  basename, LOOKUP_NOISY )) == DIR_NULL )
		goto bail_out;

	nmatch = 0;
	if(!(dp -> d_flags & DIR_SOLID)){
	  Tcl_AppendResult(interp, basename, " is not a solid\n", (char *)NULL);
	  goto bail_out;
	}

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid){
	  int	a_new_match;

/* XXX Could this make use of db_full_path_subset()? */
	  if (nmatch == 0 || nmatch != ri) {
		  i = sp -> s_fullpath.fp_len-1;
		  if (DB_FULL_PATH_GET(&sp->s_fullpath,i) == dp) {
			  a_new_match = 1;
			  j = nm_pieces - 1;
			  for (; a_new_match && (i >= 0) && (j >= 0); --i, --j) {
				  sname = DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_namep;
				  if ((*sname != *(path_piece[j]))
				      || strcmp(sname, path_piece[j]))
					  a_new_match = 0;
			  }

			  if (a_new_match && ((i >= 0) || (j < 0))) {
				  lastfound = sp;
				  ++nmatch;
			  }
		  }
	  }

	  sp->s_iflag = DOWN;
	}

	if (nmatch == 0) {
	  Tcl_AppendResult(interp, argv[1], " not being displayed\n", (char *)NULL);
	  goto bail_out;
	}

	/* preserve same old behavior */
	if (nmatch > 1 && ri == 0) {
		Tcl_AppendResult(interp, argv[1], " multiply referenced\n", (char *)NULL);
		goto bail_out;
	} else if (ri != 0 && ri != nmatch) {
		Tcl_AppendResult(interp,
				 "the reference index must be less than the number of references\n",
				 (char *)NULL);
		goto bail_out;
	}

	/* Make the specified solid the illuminated solid */
	illump = lastfound;
	illump->s_iflag = UP;

	if(!illum_only){
	  if( state == ST_O_PICK )  {
	    ipathpos = 0;
	    (void)chg_state( ST_O_PICK, ST_O_PATH, "Keyboard illuminate");
	  } else {
	    /* Check details, Init menu, set state=ST_S_EDIT */
	    init_sedit();
	  }
	}

	update_views = 1;
	if (path_piece)
	{
	    for (i = 0; path_piece[i] != 0; ++i)
		bu_free((genptr_t)path_piece[i], "f_ill: char *");
	    bu_free((genptr_t) path_piece, "f_ill: char **");
	}
	return TCL_OK;

bail_out:
    if(state != ST_VIEW){
      struct bu_vls vls;

      bu_vls_init(&vls);

      bu_vls_printf(&vls, "%s", interp->result);
      button(BE_REJECT);
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

      bu_vls_free(&vls);
    }

    if (path_piece)
    {
	for (i = 0; path_piece[i] != 0; ++i)
	    bu_free((genptr_t)path_piece[i], "f_ill: char *");
	bu_free((genptr_t) path_piece, "f_ill: char **");
    }
    return TCL_ERROR;
}

/* Simulate pressing "Solid Edit" and doing an ILLuminate command */
int
f_sed(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  if (argc < 2 || 5 < argc) {
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help sed");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
  }

  if( not_state( ST_VIEW, "keyboard solid edit start") )
    return TCL_ERROR;
  if(BU_LIST_IS_EMPTY(&dgop->dgo_headSolid)){
    Tcl_AppendResult(interp, "no solids being displayed\n",  (char *)NULL);
    return TCL_ERROR;
  }

  update_views = 1;

  button(BE_S_ILLUMINATE);	/* To ST_S_PICK */

  argv[0] = "ill";

  /* Illuminate named solid --> ST_S_EDIT */
  if (f_ill(clientData, interp, argc, argv) == TCL_ERROR) {
	  Tcl_Obj *save_result;

	  save_result = Tcl_GetObjResult(interp);
	  Tcl_IncrRefCount(save_result);
	  button(BE_REJECT);
	  Tcl_SetObjResult(interp, save_result);
	  Tcl_DecrRefCount(save_result);
	  return TCL_ERROR;
  }

  return TCL_OK;
}

void
check_nonzero_rates(void)
{
  if( view_state->vs_rate_model_rotate[X] != 0.0 ||
      view_state->vs_rate_model_rotate[Y] != 0.0 ||
      view_state->vs_rate_model_rotate[Z] != 0.0 )
    view_state->vs_rateflag_model_rotate = 1;
  else
    view_state->vs_rateflag_model_rotate = 0;

  if( view_state->vs_rate_model_tran[X] != 0.0 ||
      view_state->vs_rate_model_tran[Y] != 0.0 ||
      view_state->vs_rate_model_tran[Z] != 0.0 )
    view_state->vs_rateflag_model_tran = 1;
  else
    view_state->vs_rateflag_model_tran = 0;

  if( view_state->vs_rate_rotate[X] != 0.0 ||
      view_state->vs_rate_rotate[Y] != 0.0 ||
      view_state->vs_rate_rotate[Z] != 0.0 )
    view_state->vs_rateflag_rotate = 1;
  else
    view_state->vs_rateflag_rotate = 0;

  if( view_state->vs_rate_tran[X] != 0.0 ||
      view_state->vs_rate_tran[Y] != 0.0 ||
      view_state->vs_rate_tran[Z] != 0.0 )
    view_state->vs_rateflag_tran = 1;
  else
    view_state->vs_rateflag_tran = 0;

  if( view_state->vs_rate_scale != 0.0 )
    view_state->vs_rateflag_scale = 1;
  else
    view_state->vs_rateflag_scale = 0;

  if( edit_rate_model_tran[X] != 0.0 ||
      edit_rate_model_tran[Y] != 0.0 ||
      edit_rate_model_tran[Z] != 0.0 )
    edit_rateflag_model_tran = 1;
  else
    edit_rateflag_model_tran = 0;

  if( edit_rate_view_tran[X] != 0.0 ||
      edit_rate_view_tran[Y] != 0.0 ||
      edit_rate_view_tran[Z] != 0.0 )
    edit_rateflag_view_tran = 1;
  else
    edit_rateflag_view_tran = 0;

  if( edit_rate_model_rotate[X] != 0.0 ||
      edit_rate_model_rotate[Y] != 0.0 ||
      edit_rate_model_rotate[Z] != 0.0 )
    edit_rateflag_model_rotate = 1;
  else
    edit_rateflag_model_rotate = 0;

  if( edit_rate_object_rotate[X] != 0.0 ||
      edit_rate_object_rotate[Y] != 0.0 ||
      edit_rate_object_rotate[Z] != 0.0 )
    edit_rateflag_object_rotate = 1;
  else
    edit_rateflag_object_rotate = 0;

  if( edit_rate_view_rotate[X] != 0.0 ||
      edit_rate_view_rotate[Y] != 0.0 ||
      edit_rate_view_rotate[Z] != 0.0 )
    edit_rateflag_view_rotate = 1;
  else
    edit_rateflag_view_rotate = 0;

  if( edit_rate_scale )
    edit_rateflag_scale = 1;
  else
    edit_rateflag_scale = 0;

  view_state->vs_flag = 1;	/* values changed so update faceplate */
}

void
knob_update_rate_vars(void)
{
  if(!mged_variables->mv_rateknobs)
    return;
}

int
mged_print_knobvals(Tcl_Interp *interp)
{
  struct bu_vls vls;

  bu_vls_init(&vls);

  if(mged_variables->mv_rateknobs){
    if(es_edclass == EDIT_CLASS_ROTATE && mged_variables->mv_transform == 'e'){
      bu_vls_printf(&vls, "x = %f\n", edit_rate_model_rotate[X]);
      bu_vls_printf(&vls, "y = %f\n", edit_rate_model_rotate[Y]);
      bu_vls_printf(&vls, "z = %f\n", edit_rate_model_rotate[Z]);
    }else{
      bu_vls_printf(&vls, "x = %f\n", view_state->vs_rate_rotate[X]);
      bu_vls_printf(&vls, "y = %f\n", view_state->vs_rate_rotate[Y]);
      bu_vls_printf(&vls, "z = %f\n", view_state->vs_rate_rotate[Z]);
    }

    if(es_edclass == EDIT_CLASS_SCALE && mged_variables->mv_transform == 'e')
      bu_vls_printf(&vls, "S = %f\n", edit_rate_scale);
    else
      bu_vls_printf(&vls, "S = %f\n", view_state->vs_rate_scale);

    if(es_edclass == EDIT_CLASS_TRAN && mged_variables->mv_transform == 'e'){
      bu_vls_printf(&vls, "X = %f\n", edit_rate_model_tran[X]);
      bu_vls_printf(&vls, "Y = %f\n", edit_rate_model_tran[Y]);
      bu_vls_printf(&vls, "Z = %f\n", edit_rate_model_tran[Z]);
    }else{
      bu_vls_printf(&vls, "X = %f\n", view_state->vs_rate_tran[X]);
      bu_vls_printf(&vls, "Y = %f\n", view_state->vs_rate_tran[Y]);
      bu_vls_printf(&vls, "Z = %f\n", view_state->vs_rate_tran[Z]);
    }
  }else{
    if(es_edclass == EDIT_CLASS_ROTATE && mged_variables->mv_transform == 'e'){
      bu_vls_printf(&vls, "ax = %f\n", edit_absolute_model_rotate[X]);
      bu_vls_printf(&vls, "ay = %f\n", edit_absolute_model_rotate[Y]);
      bu_vls_printf(&vls, "az = %f\n", edit_absolute_model_rotate[Z]);
    }else{
      bu_vls_printf(&vls, "ax = %f\n", view_state->vs_absolute_rotate[X]);
      bu_vls_printf(&vls, "ay = %f\n", view_state->vs_absolute_rotate[Y]);
      bu_vls_printf(&vls, "az = %f\n", view_state->vs_absolute_rotate[Z]);
    }

    if(es_edclass == EDIT_CLASS_SCALE && mged_variables->mv_transform == 'e')
      bu_vls_printf(&vls, "aS = %f\n", edit_absolute_scale);
    else
      bu_vls_printf(&vls, "aS = %f\n", view_state->vs_absolute_scale);

    if(es_edclass == EDIT_CLASS_TRAN && mged_variables->mv_transform == 'e'){
      bu_vls_printf(&vls, "aX = %f\n", edit_absolute_model_tran[X]);
      bu_vls_printf(&vls, "aY = %f\n", edit_absolute_model_tran[Y]);
      bu_vls_printf(&vls, "aZ = %f\n", edit_absolute_model_tran[Z]);
    }else{
      bu_vls_printf(&vls, "aX = %f\n", view_state->vs_absolute_tran[X]);
      bu_vls_printf(&vls, "aY = %f\n", view_state->vs_absolute_tran[Y]);
      bu_vls_printf(&vls, "aZ = %f\n", view_state->vs_absolute_tran[Z]);
    }
  }

  if(adc_state->adc_draw){
    bu_vls_printf(&vls, "xadc = %d\n", adc_state->adc_dv_x);
    bu_vls_printf(&vls, "yadc = %d\n", adc_state->adc_dv_y);
    bu_vls_printf(&vls, "ang1 = %d\n", adc_state->adc_dv_a1);
    bu_vls_printf(&vls, "ang2 = %d\n", adc_state->adc_dv_a2);
    bu_vls_printf(&vls, "distadc = %d\n", adc_state->adc_dv_dist);
  }

  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

/* Main processing of knob twists.  "knob id val id val ..." */
int
f_knob(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int	i;
  fastf_t f;
  fastf_t sf;
  vect_t tvec;
  vect_t rvec;
  char	*cmd;
  char origin = '\0';
  int do_tran = 0;
  int do_rot = 0;
  int incr_flag = 0;  /* interpret values as increments */
  int view_flag = 0;  /* manipulate view using view coords */
  int model_flag = 0; /* manipulate view using model coords */
  int edit_flag = 0;  /* force edit interpretation */

  CHECK_DBI_NULL;

  if(argc < 1){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help knob");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Check for options */
  {
    int c;

    bu_optind = 1;
    while((c = bu_getopt(argc, argv, "eimo:v")) != EOF){
      switch(c){
      case 'e':
	edit_flag = 1;
	break;
      case 'i':
	incr_flag = 1;
	break;
      case 'm':
	model_flag = 1;
	break;
      case 'o':
	origin = *bu_optarg;
	break;
      case 'v':
	view_flag = 1;
	break;
      default:
	break;
      }
    }
   
    argv += bu_optind - 1;
    argc -= bu_optind - 1;
  }

  if(origin != 'v' && origin != 'm' && origin != 'e' && origin != 'k')
    origin = mged_variables->mv_rotate_about;

  /* print the current values */
  if(argc == 1)
    return mged_print_knobvals(interp);

  VSETALL(tvec, 0.0);
  VSETALL(rvec, 0.0);

  for(--argc, ++argv; argc; --argc, ++argv){
    cmd = *argv;
    
    if( strcmp( cmd, "zap" ) == 0 || strcmp( cmd, "zero" ) == 0 )  {
      char *av[3];

      VSETALL( view_state->vs_rate_model_rotate, 0.0 );
      VSETALL( view_state->vs_rate_model_tran, 0.0 );
      VSETALL( view_state->vs_rate_rotate, 0.0 );
      VSETALL( view_state->vs_rate_tran, 0.0 );
      view_state->vs_rate_scale = 0.0;
      VSETALL( edit_rate_model_rotate, 0.0 );
      VSETALL( edit_rate_object_rotate, 0.0 );
      VSETALL( edit_rate_view_rotate, 0.0 );
      VSETALL( edit_rate_model_tran, 0.0 );
      VSETALL( edit_rate_view_tran, 0.0 );
      edit_rate_scale = 0.0;
      knob_update_rate_vars();

      av[0] = "adc";
      av[1] = "reset";
      av[2] = (char *)NULL;

      (void)f_adc( clientData, interp, 2, av );

      (void)mged_svbase();
    } else if( strcmp( cmd, "calibrate" ) == 0 ) {
      VSETALL( view_state->vs_absolute_tran, 0.0 );
    }else{
      if(argc - 1){
	i = atoi(argv[1]);
	f = atof(argv[1]);
#if 0
	if( f < -1.0 )
	  f = -1.0;
	else if( f > 1.0 )
	  f = 1.0;
#endif
      }else
	goto usage;

      --argc;
      ++argv;

    if( cmd[1] == '\0' )  {
#if 0
      if( f < -1.0 )
	f = -1.0;
      else if( f > 1.0 )
	f = 1.0;
#endif

      switch( cmd[0] )  {
      case 'x':
	if(incr_flag){
	  if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			      !view_flag && !model_flag) || edit_flag)){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      edit_rate_model_rotate[X] += f;
	      edit_rate_model_origin = origin;
	      edit_rate_mr_dm_list = curr_dm_list;

	      break;
	    case 'o':
	      edit_rate_object_rotate[X] += f;
	      edit_rate_object_origin = origin;
	      edit_rate_or_dm_list = curr_dm_list;

	      break;
	    case 'v':
	    default:
	      edit_rate_view_rotate[X] += f;
	      edit_rate_view_origin = origin;
	      edit_rate_vr_dm_list = curr_dm_list;

	      break;
	    }
	  }else{
	    if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	      view_state->vs_rate_model_rotate[X] += f;
	      view_state->vs_rate_model_origin = origin;
	    }else{
	      view_state->vs_rate_rotate[X] += f;
	      view_state->vs_rate_origin = origin;
	    }

	  }
	}else{
	  if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			      !view_flag && !model_flag) || edit_flag)){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      edit_rate_model_rotate[X] = f;
	      edit_rate_model_origin = origin;
	      edit_rate_mr_dm_list = curr_dm_list;

	      break;
	    case 'o':
	      edit_rate_object_rotate[X] = f;
	      edit_rate_object_origin = origin;
	      edit_rate_or_dm_list = curr_dm_list;

	      break;
	    case 'v':
	    default:
	      edit_rate_view_rotate[X] = f;
	      edit_rate_view_origin = origin;
	      edit_rate_vr_dm_list = curr_dm_list;

	      break;
	    }
	  }else{
	    if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	      view_state->vs_rate_model_rotate[X] = f;
	      view_state->vs_rate_model_origin = origin;
	    }else{
	      view_state->vs_rate_rotate[X] = f;
	      view_state->vs_rate_origin = origin;
	    }

	  }
	}

	break;
      case 'y':
	if(incr_flag){
	  if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			      !view_flag && !model_flag) || edit_flag)){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      edit_rate_model_rotate[Y] += f;
	      edit_rate_model_origin = origin;
	      edit_rate_mr_dm_list = curr_dm_list;

	      break;
	    case 'o':
	      edit_rate_object_rotate[Y] += f;
	      edit_rate_object_origin = origin;
	      edit_rate_or_dm_list = curr_dm_list;

	      break;
	    case 'v':
	    default:
	      edit_rate_view_rotate[Y] += f;
	      edit_rate_view_origin = origin;
	      edit_rate_vr_dm_list = curr_dm_list;

	      break;
	    }
	  }else{
	    if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	      view_state->vs_rate_model_rotate[Y] += f;
	      view_state->vs_rate_model_origin = origin;
	    }else{
	      view_state->vs_rate_rotate[Y] += f;
	      view_state->vs_rate_origin = origin;
	    }
	  }
	}else{
	  if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			      !view_flag && !model_flag) || edit_flag)){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      edit_rate_model_rotate[Y] = f;
	      edit_rate_model_origin = origin;
	      edit_rate_mr_dm_list = curr_dm_list;

	      break;
	    case 'o':
	      edit_rate_object_rotate[Y] = f;
	      edit_rate_object_origin = origin;
	      edit_rate_or_dm_list = curr_dm_list;

	      break;
	    case 'v':
	    default:
	      edit_rate_view_rotate[Y] = f;
	      edit_rate_view_origin = origin;
	      edit_rate_vr_dm_list = curr_dm_list;

	      break;
	    }
	  }else{
	    if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	      view_state->vs_rate_model_rotate[Y] = f;
	      view_state->vs_rate_model_origin = origin;
	    }else{
	      view_state->vs_rate_rotate[Y] = f;
	      view_state->vs_rate_origin = origin;
	    }
	  }
	}

	break;
      case 'z':
	if(incr_flag){
	  if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			      !view_flag && !model_flag) || edit_flag)){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      edit_rate_model_rotate[Z] += f;
	      edit_rate_model_origin = origin;
	      edit_rate_mr_dm_list = curr_dm_list;

	      break;
	    case 'o':
	      edit_rate_object_rotate[Z] += f;
	      edit_rate_object_origin = origin;
	      edit_rate_or_dm_list = curr_dm_list;

	      break;
	    case 'v':
	    default:
	      edit_rate_view_rotate[Z] += f;
	      edit_rate_view_origin = origin;
	      edit_rate_vr_dm_list = curr_dm_list;

	      break;
	    }
	  }else{
	    if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	      view_state->vs_rate_model_rotate[Z] += f;
	      view_state->vs_rate_model_origin = origin;
	    }else{
	      view_state->vs_rate_rotate[Z] += f;
	      view_state->vs_rate_origin = origin;
	    }
	  }
	}else{
	  if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			      !view_flag && !model_flag) || edit_flag)){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      edit_rate_model_rotate[Z] = f;
	      edit_rate_model_origin = origin;
	      edit_rate_mr_dm_list = curr_dm_list;

	      break;
	    case 'o':
	      edit_rate_object_rotate[Z] = f;
	      edit_rate_object_origin = origin;
	      edit_rate_or_dm_list = curr_dm_list;

	      break;
	    case 'v':
	    default:
	      edit_rate_view_rotate[Z] = f;
	      edit_rate_view_origin = origin;
	      edit_rate_vr_dm_list = curr_dm_list;

	      break;
	    }
	  }else{
	    if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	      view_state->vs_rate_model_rotate[Z] = f;
	      view_state->vs_rate_model_origin = origin;
	    }else{
	      view_state->vs_rate_rotate[Z] = f;
	      view_state->vs_rate_origin = origin;
	    }
	  }
	}

      break;
    case 'X':
      if(incr_flag){
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_rate_model_tran[X] += f;
	    edit_rate_mt_dm_list = curr_dm_list;

	    break;
	  case 'v':
	  default:
	    edit_rate_view_tran[X] += f;
	    edit_rate_vt_dm_list = curr_dm_list;

	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
	    view_state->vs_rate_model_tran[X] += f;
	  else
	    view_state->vs_rate_tran[X] += f;
	}
      }else{
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_rate_model_tran[X] = f;
	    edit_rate_mt_dm_list = curr_dm_list;

	    break;
	  case 'v':
	  default:
	    edit_rate_view_tran[X] = f;
	    edit_rate_vt_dm_list = curr_dm_list;

	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
	    view_state->vs_rate_model_tran[X] = f;
	  else
	    view_state->vs_rate_tran[X] = f;
	}
      }

      break;
    case 'Y':
      if(incr_flag){
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_rate_model_tran[Y] += f;
	    edit_rate_mt_dm_list = curr_dm_list;

	    break;
	  case 'v':
	  default:
	    edit_rate_view_tran[Y] += f;
	    edit_rate_vt_dm_list = curr_dm_list;

	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
	    view_state->vs_rate_model_tran[Y] += f;
	  else
	    view_state->vs_rate_tran[Y] += f;
	}
      }else{
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){	
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_rate_model_tran[Y] = f;
	    edit_rate_mt_dm_list = curr_dm_list;

	    break;
	  case 'v':
	  default:
	    edit_rate_view_tran[Y] = f;
	    edit_rate_vt_dm_list = curr_dm_list;

	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
	    view_state->vs_rate_model_tran[Y] = f;
	  else
	    view_state->vs_rate_tran[Y] = f;
	}
      }

      break;
    case 'Z':
      if(incr_flag){
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_rate_model_tran[Z] += f;
	    edit_rate_mt_dm_list = curr_dm_list;

	    break;
	  case 'v':
	  default:
	    edit_rate_view_tran[Z] += f;
	    edit_rate_vt_dm_list = curr_dm_list;

	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
	    view_state->vs_rate_model_tran[Z] += f;
	  else
	    view_state->vs_rate_tran[Z] += f;
	}
      }else{
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_rate_model_tran[Z] = f;
	    edit_rate_mt_dm_list = curr_dm_list;

	    break;
	  case 'v':
	  default:
	    edit_rate_view_tran[Z] = f;
	    edit_rate_vt_dm_list = curr_dm_list;

	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
	    view_state->vs_rate_model_tran[Z] = f;
	  else
	    view_state->vs_rate_tran[Z] = f;
	}
      }

      break;
    case 'S':
      if(incr_flag){
	if(EDIT_SCALE && ((mged_variables->mv_transform == 'e' && !view_flag) || edit_flag)){
	  edit_rate_scale += f;
	}else{
	  view_state->vs_rate_scale += f;
	}
      }else{
	if(EDIT_SCALE && ((mged_variables->mv_transform == 'e' && !view_flag) || edit_flag)){
	  edit_rate_scale = f;
	}else{
	  view_state->vs_rate_scale = f;
	}
      }

      break;
    default:
      goto usage;
    }
  } else if( cmd[0] == 'a' && cmd[1] != '\0' && cmd[2] == '\0' ) {
    switch( cmd[1] ) {
    case 'x':
      if(incr_flag){
	if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			     !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    edit_absolute_model_rotate[X] += f;
	    break;
	  case 'o':
	    edit_absolute_object_rotate[X] += f;
	    break;
	  case 'v':
	    edit_absolute_view_rotate[X] += f;
	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	    view_state->vs_absolute_model_rotate[X] += f;
	  }else{
	    view_state->vs_absolute_rotate[X] += f;
	  }
	}

	rvec[X] = f;
      }else{
	if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			     !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    rvec[X] = f - last_edit_absolute_model_rotate[X];
	    edit_absolute_model_rotate[X] = f;
	    break;
	  case 'o':
	    rvec[X] = f - last_edit_absolute_object_rotate[X];
	    edit_absolute_object_rotate[X] = f;
	    break;
	  case 'v':
	    rvec[X] = f - last_edit_absolute_view_rotate[X];
	    edit_absolute_view_rotate[X] = f;
	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	    rvec[X] = f - view_state->vs_last_absolute_model_rotate[X];
	    view_state->vs_absolute_model_rotate[X] = f;
	  }else{
	    rvec[X] = f - view_state->vs_last_absolute_rotate[X];
	    view_state->vs_absolute_rotate[X] = f;
	  }
	}
      }

      /* wrap around */
      if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	fastf_t *arp;
	fastf_t *larp;

	switch(mged_variables->mv_coords){
	case 'm':
	  arp = edit_absolute_model_rotate;
	  larp = last_edit_absolute_model_rotate;
	  break;
	case 'o':
	  arp = edit_absolute_object_rotate;
	  larp = last_edit_absolute_object_rotate;
	  break;
	case 'v':
	  arp = edit_absolute_view_rotate;
	  larp = last_edit_absolute_view_rotate;
	  break;
	default:
		bu_log("unknown mv_coords\n");
		arp = larp = NULL;
	}

	if(arp[X] < -180.0)
	  arp[X] = arp[X] + 360.0;
	else if(arp[X] > 180.0)
	  arp[X] = arp[X] - 360.0;

	larp[X] = arp[X];
      }else{
	fastf_t *arp;
	fastf_t *larp;

	if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  arp = view_state->vs_absolute_model_rotate;
	  larp = view_state->vs_last_absolute_model_rotate;
	}else{
	  arp = view_state->vs_absolute_rotate;
	  larp = view_state->vs_last_absolute_rotate;
	}

	if(arp[X] < -180.0)
	  arp[X] = arp[X] + 360.0;
	else if(arp[X] > 180.0)
	  arp[X] = arp[X] - 360.0;

	larp[X] = arp[X];
      }

      do_rot = 1;
      break;
    case 'y':
      if(incr_flag){
	if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			     !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    edit_absolute_model_rotate[Y] += f;
	    break;
	  case 'o':
	    edit_absolute_object_rotate[Y] += f;
	    break;
	  case 'v':
	    edit_absolute_view_rotate[Y] += f;
	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	    view_state->vs_absolute_model_rotate[Y] += f;
	  }else{
	    view_state->vs_absolute_rotate[Y] += f;
	  }
	}

	rvec[Y] = f;
      }else{
	if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			     !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    rvec[Y] = f - last_edit_absolute_model_rotate[Y];
	    edit_absolute_model_rotate[Y] = f;
	    break;
	  case 'o':
	    rvec[Y] = f - last_edit_absolute_object_rotate[Y];
	    edit_absolute_object_rotate[Y] = f;
	    break;
	  case 'v':
	    rvec[Y] = f - last_edit_absolute_view_rotate[Y];
	    edit_absolute_view_rotate[Y] = f;
	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	    rvec[Y] = f - view_state->vs_last_absolute_model_rotate[Y];
	    view_state->vs_absolute_model_rotate[Y] = f;
	  }else{
	    rvec[Y] = f - view_state->vs_last_absolute_rotate[Y];
	    view_state->vs_absolute_rotate[Y] = f;
	  }
	}
      }

      /* wrap around */
      if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	fastf_t *arp;
	fastf_t *larp;

	switch(mged_variables->mv_coords){
	case 'm':
	  arp = edit_absolute_model_rotate;
	  larp = last_edit_absolute_model_rotate;
	  break;
	case 'o':
	  arp = edit_absolute_object_rotate;
	  larp = last_edit_absolute_object_rotate;
	  break;
	case 'v':
	  arp = edit_absolute_view_rotate;
	  larp = last_edit_absolute_view_rotate;
	  break;
	default:
		bu_log("unknown mv_transform\n");
		arp = larp = NULL;
	}

	if(arp[Y] < -180.0)
	  arp[Y] = arp[Y] + 360.0;
	else if(arp[X] > 180.0)
	  arp[Y] = arp[Y] - 360.0;

	larp[Y] = arp[Y];
      }else{
	fastf_t *arp;
	fastf_t *larp;

	if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  arp = view_state->vs_absolute_model_rotate;
	  larp = view_state->vs_last_absolute_model_rotate;
	}else{
	  arp = view_state->vs_absolute_rotate;
	  larp = view_state->vs_last_absolute_rotate;
	}

	if(arp[Y] < -180.0)
	  arp[Y] = arp[Y] + 360.0;
	else if(arp[Y] > 180.0)
	  arp[Y] = arp[Y] - 360.0;

	larp[Y] = arp[Y];
      }

      do_rot = 1;
      break;
    case 'z':
      if(incr_flag){
	if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			     !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    edit_absolute_model_rotate[Z] += f;
	    break;
	  case 'o':
	    edit_absolute_object_rotate[Z] += f;
	    break;
	  case 'v':
	    edit_absolute_view_rotate[Z] += f;
	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	    view_state->vs_absolute_model_rotate[Z] += f;
	  }else{
	    view_state->vs_absolute_rotate[Z] += f;
	  }
	}

	rvec[Z] = f;
      }else{
	if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			     !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	    rvec[Z] = f - last_edit_absolute_model_rotate[Z];
	    edit_absolute_model_rotate[Z] = f;
	    break;
	  case 'o':
	    rvec[Z] = f - last_edit_absolute_object_rotate[Z];
	    edit_absolute_object_rotate[Z] = f;
	    break;
	  case 'v':
	    rvec[Z] = f - last_edit_absolute_view_rotate[Z];
	    edit_absolute_view_rotate[Z] = f;
	    break;
	  }
	}else{
	  if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	    rvec[Z] = f - view_state->vs_last_absolute_model_rotate[Z];
	    view_state->vs_absolute_model_rotate[Z] = f;
	  }else{
	    rvec[Z] = f - view_state->vs_last_absolute_rotate[Z];
	    view_state->vs_absolute_rotate[Z] = f;
	  }
	}
      }

      /* wrap around */
      if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	fastf_t *arp;
	fastf_t *larp;

	switch(mged_variables->mv_coords){
	case 'm':
	  arp = edit_absolute_model_rotate;
	  larp = last_edit_absolute_model_rotate;
	  break;
	case 'o':
	  arp = edit_absolute_object_rotate;
	  larp = last_edit_absolute_object_rotate;
	  break;
	case 'v':
	  arp = edit_absolute_view_rotate;
	  larp = last_edit_absolute_view_rotate;
	  break;
	default:
		bu_log("unknown mv_coords\n");
		arp = larp = NULL;
	}

	if(arp[Z] < -180.0)
	  arp[Z] = arp[Z] + 360.0;
	else if(arp[Z] > 180.0)
	  arp[Z] = arp[Z] - 360.0;

	larp[Z] = arp[Z];
      }else{
	fastf_t *arp;
	fastf_t *larp;

	if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  arp = view_state->vs_absolute_model_rotate;
	  larp = view_state->vs_last_absolute_model_rotate;
	}else{
	  arp = view_state->vs_absolute_rotate;
	  larp = view_state->vs_last_absolute_rotate;
	}

	if(arp[Z] < -180.0)
	  arp[Z] = arp[Z] + 360.0;
	else if(arp[Z] > 180.0)
	  arp[Z] = arp[Z] - 360.0;

	larp[Z] = arp[Z];
      }

      do_rot = 1;
      break;
    case 'X':
      sf = f * local2base / view_state->vs_vop->vo_scale;
      if(incr_flag){
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_absolute_model_tran[X] += sf;
	    last_edit_absolute_model_tran[X] = edit_absolute_model_tran[X];

	    break;
	  case 'v':
	    edit_absolute_view_tran[X] += sf;
	    last_edit_absolute_view_tran[X] = edit_absolute_view_tran[X];

	    break;
	  }
	}else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  view_state->vs_absolute_model_tran[X] += sf;
	  view_state->vs_last_absolute_model_tran[X] = view_state->vs_absolute_model_tran[X];
	}else{
	  view_state->vs_absolute_tran[X] += sf;
	  view_state->vs_last_absolute_tran[X] = view_state->vs_absolute_tran[X];
	}

	tvec[X] = f;
      }else{
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    tvec[X] = f - last_edit_absolute_model_tran[X]*view_state->vs_vop->vo_scale*base2local;
	    edit_absolute_model_tran[X] = sf;
	    last_edit_absolute_model_tran[X] = edit_absolute_model_tran[X];

	    break;
	  case 'v':
	    tvec[X] = f - last_edit_absolute_view_tran[X]*view_state->vs_vop->vo_scale*base2local;
	    edit_absolute_view_tran[X] = sf;
	    last_edit_absolute_view_tran[X] = edit_absolute_view_tran[X];

	    break;
	  }
	}else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  tvec[X] = f - view_state->vs_last_absolute_model_tran[X]*view_state->vs_vop->vo_scale*base2local;
	  view_state->vs_absolute_model_tran[X] = sf;
	  view_state->vs_last_absolute_model_tran[X] = view_state->vs_absolute_model_tran[X];
	}else{
	  tvec[X] = f - view_state->vs_last_absolute_tran[X]*view_state->vs_vop->vo_scale*base2local;
	  view_state->vs_absolute_tran[X] = sf;
	  view_state->vs_last_absolute_tran[X] = view_state->vs_absolute_tran[X];
	}

      }

      do_tran = 1;
      break;
    case 'Y':
      sf = f * local2base / view_state->vs_vop->vo_scale;
      if(incr_flag){
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_absolute_model_tran[Y] += sf;
	    last_edit_absolute_model_tran[Y] = edit_absolute_model_tran[Y];

	    break;
	  case 'v':
	    edit_absolute_view_tran[Y] += sf;
	    last_edit_absolute_view_tran[Y] = edit_absolute_view_tran[Y];

	    break;
	  }
	}else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  view_state->vs_absolute_model_tran[Y] += sf;
	  view_state->vs_last_absolute_model_tran[Y] = view_state->vs_absolute_model_tran[Y];
	}else{
	  view_state->vs_absolute_tran[Y] += sf;
	  view_state->vs_last_absolute_tran[Y] = view_state->vs_absolute_tran[Y];
	}

	tvec[Y] = f;
      }else{
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    tvec[Y] = f - last_edit_absolute_model_tran[Y]*view_state->vs_vop->vo_scale*base2local;
	    edit_absolute_model_tran[Y] = sf;
	    last_edit_absolute_model_tran[Y] = edit_absolute_model_tran[Y];

	    break;
	  case 'v':
	    tvec[Y] = f - last_edit_absolute_view_tran[Y]*view_state->vs_vop->vo_scale*base2local;
	    edit_absolute_view_tran[Y] = sf;
	    last_edit_absolute_view_tran[Y] = edit_absolute_view_tran[Y];

	    break;
	  }
	}else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  tvec[Y] = f - view_state->vs_last_absolute_model_tran[Y]*view_state->vs_vop->vo_scale*base2local;
	  view_state->vs_absolute_model_tran[Y] = sf;
	  view_state->vs_last_absolute_model_tran[Y] = view_state->vs_absolute_model_tran[Y];
	}else{
	  tvec[Y] = f - view_state->vs_last_absolute_tran[Y]*view_state->vs_vop->vo_scale*base2local;
	  view_state->vs_absolute_tran[Y] = sf;
	  view_state->vs_last_absolute_tran[Y] = view_state->vs_absolute_tran[Y];
	}
      }
      
      do_tran = 1;
      break;
    case 'Z':
      sf = f * local2base / view_state->vs_vop->vo_scale;
      if(incr_flag){
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    edit_absolute_model_tran[Z] += sf;
	    last_edit_absolute_model_tran[Z] = edit_absolute_model_tran[Z];

	    break;
	  case 'v':
	    edit_absolute_view_tran[Z] += sf;
	    last_edit_absolute_view_tran[Z] = edit_absolute_view_tran[Z];

	    break;
	  }
	}else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  view_state->vs_absolute_model_tran[Z] += sf;
	  view_state->vs_last_absolute_model_tran[Z] = view_state->vs_absolute_model_tran[Z];
	}else{
	  view_state->vs_absolute_tran[Z] += sf;
	  view_state->vs_last_absolute_tran[Z] = view_state->vs_absolute_tran[Z];
	}

	tvec[Z] = f;
      }else{
	if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			  !view_flag && !model_flag) || edit_flag)){
	  switch(mged_variables->mv_coords){
	  case 'm':
	  case 'o':
	    tvec[Z] = f - last_edit_absolute_model_tran[Z]*view_state->vs_vop->vo_scale*base2local;
	    edit_absolute_model_tran[Z] = sf;
	    last_edit_absolute_model_tran[Z] = edit_absolute_model_tran[Z];

	    break;
	  case 'v':
	    tvec[Z] = f - last_edit_absolute_view_tran[Z]*view_state->vs_vop->vo_scale*base2local;
	    edit_absolute_view_tran[Z] = sf;
	    last_edit_absolute_view_tran[Z] = edit_absolute_view_tran[Z];

	    break;
	  }
	}else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag)){
	  tvec[Z] = f - view_state->vs_last_absolute_model_tran[Z]*view_state->vs_vop->vo_scale*base2local;
	  view_state->vs_absolute_model_tran[Z] = sf;
	  view_state->vs_last_absolute_model_tran[Z] = view_state->vs_absolute_model_tran[Z];
	}else{
	  tvec[Z] = f - view_state->vs_last_absolute_tran[Z]*view_state->vs_vop->vo_scale*base2local;
	  view_state->vs_absolute_tran[Z] = sf;
	  view_state->vs_last_absolute_tran[Z] = view_state->vs_absolute_tran[Z];
	}
      }

      do_tran = 1;
      break;
    case 'S':
      if(incr_flag){
	if(EDIT_SCALE && ((mged_variables->mv_transform == 'e' && !view_flag) || edit_flag)){
	  edit_absolute_scale += f;
	  if(state == ST_S_EDIT)
	    sedit_abs_scale();
	  else
	    oedit_abs_scale();
	}else{
	  view_state->vs_absolute_scale += f;
	  abs_zoom();
	}
      }else{
	if(EDIT_SCALE && ((mged_variables->mv_transform == 'e' && !view_flag) || edit_flag)){
	  edit_absolute_scale = f;
	  if(state == ST_S_EDIT)
	    sedit_abs_scale();
	  else
	    oedit_abs_scale();
	}else{
	  view_state->vs_absolute_scale = f;
	  abs_zoom();
	}
      }

      break;
    default:
      goto usage;
    }
  } else if( strcmp( cmd, "xadc" ) == 0 ) {
	  char *av[5];
	  char sval[32];
	  int nargs = 3;

	  av[0] = "adc";
	  if (incr_flag) {
	    ++nargs;
	    av[1] = "-i";
	    av[2] = "x";
	    av[3] = sval;
	    av[4] = NULL;
	  } else {
	    av[1] = "x";
	    av[2] = sval;
	    av[3] = NULL;
	  }

	  sprintf(sval, "%d", i);
	  (void)f_adc(clientData, interp, nargs, av);
	} else if( strcmp( cmd, "yadc" ) == 0 )  {
	  char *av[5];
	  char sval[32];
	  int nargs = 3;

	  av[0] = "adc";
	  if (incr_flag) {
	    ++nargs;
	    av[1] = "-i";
	    av[2] = "y";
	    av[3] = sval;
	    av[4] = NULL;
	  } else {
	    av[1] = "y";
	    av[2] = sval;
	    av[3] = NULL;
	  }

	  sprintf(sval, "%d", i);
	  (void)f_adc(clientData, interp, nargs, av);
	} else if( strcmp( cmd, "ang1" ) == 0 )  {
	  char *av[5];
	  char sval[32];
	  int nargs = 3;

	  av[0] = "adc";
	  if (incr_flag) {
	    ++nargs;
	    av[1] = "-i";
	    av[2] = "a1";
	    av[3] = sval;
	    av[4] = NULL;
	  } else {
	    av[1] = "a1";
	    av[2] = sval;
	    av[3] = NULL;
	  }

	  sprintf(sval, "%f", f);
	  (void)f_adc(clientData, interp, nargs, av);
	} else if( strcmp( cmd, "ang2" ) == 0 )  {
	  char *av[5];
	  char sval[32];
	  int nargs = 3;

	  av[0] = "adc";
	  if (incr_flag) {
	    ++nargs;
	    av[1] = "-i";
	    av[2] = "a2";
	    av[3] = sval;
	    av[4] = NULL;
	  } else {
	    av[1] = "a2";
	    av[2] = sval;
	    av[3] = NULL;
	  }

	  sprintf(sval, "%f", f);
	  (void)f_adc(clientData, interp, nargs, av);
	} else if (strcmp(cmd, "distadc") == 0) {
	  char *av[5];
	  char sval[32];
	  int nargs = 3;

	  av[0] = "adc";
	  if (incr_flag) {
	    ++nargs;
	    av[1] = "-i";
	    av[2] = "odst";
	    av[3] = sval;
	    av[4] = NULL;
	  } else {
	    av[1] = "odst";
	    av[2] = sval;
	    av[3] = NULL;
	  }

	  sprintf(sval, "%d", i);
	  (void)f_adc(clientData, interp, nargs, av);
	} else {
usage:
	  Tcl_AppendResult(interp,
		"knob: x,y,z for rotation in degrees\n",
		"knob: S for scale, X,Y,Z for slew (rates, range -1..+1)\n",
		"knob: ax,ay,az for absolute rotation in degrees, aS for absolute scale,\n",
		"knob: aX,aY,aZ for absolute slew.  calibrate to set current slew to 0\n",
		"knob: xadc, yadc, distadc (values, range -2048..+2047)\n",
		"knob: ang1, ang2 for adc angles in degrees\n",
		"knob: zero (cancel motion)\n", (char *)NULL);

	  return TCL_ERROR;
	}
      }
  }

  if(do_tran)
    (void)knob_tran(tvec, model_flag, view_flag, edit_flag);

  if(do_rot)
    (void)knob_rot(rvec, origin, model_flag, view_flag, edit_flag);
 
  check_nonzero_rates();
  return TCL_OK;
}

int
knob_tran(vect_t	tvec,
	  int		model_flag,
	  int		view_flag,
	  int		edit_flag)
{
	if (EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
			   !view_flag && !model_flag) || edit_flag))
		mged_etran(view_state->vs_vop, interp, mged_variables->mv_coords, tvec);
	else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
		mged_mtran(tvec);
	else if(mged_variables->mv_coords == 'o')
		mged_otran(tvec);
	else
		mged_vtran(tvec);

	return TCL_OK;
}

int
knob_rot(vect_t	rvec,
	 char	origin,
	 int	model_flag,
	 int	view_flag,
	 int	edit_flag)
{
	if (EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
			     !view_flag && !model_flag) || edit_flag))
		mged_erot_xyz(origin, rvec);
	else if (model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
		mged_vrot_xyz(origin, 'm', rvec);
	else if (mged_variables->mv_coords == 'o')
		mged_vrot_xyz(origin, 'o', rvec);
	else
		mged_vrot_xyz(origin, 'v', rvec);

	return TCL_OK;
}

/* absolute_scale's value range is [-1.0, 1.0] */
static void
abs_zoom(void)
{
  /* Use initial Viewscale */
  if(-SMALL_FASTF < view_state->vs_absolute_scale && view_state->vs_absolute_scale < SMALL_FASTF)
    view_state->vs_vop->vo_scale = view_state->vs_i_Viewscale;
  else{
    /* if positive */
    if(view_state->vs_absolute_scale > 0){
      /* scale i_Viewscale by values in [0.0, 1.0] range */
      view_state->vs_vop->vo_scale = view_state->vs_i_Viewscale * (1.0 - view_state->vs_absolute_scale);
    }else/* negative */
      /* scale i_Viewscale by values in [1.0, 10.0] range */
      view_state->vs_vop->vo_scale = view_state->vs_i_Viewscale * (1.0 + (view_state->vs_absolute_scale * -9.0));
  }

  if (view_state->vs_vop->vo_scale < MINVIEW)
	  view_state->vs_vop->vo_scale = MINVIEW;

  vo_zoom(view_state->vs_vop, interp, 1.0);

  if(view_state->vs_absolute_tran[X] != 0.0 ||
     view_state->vs_absolute_tran[Y] != 0.0 ||
     view_state->vs_absolute_tran[Z] != 0.0){
    set_absolute_tran();
  }
}

int
mged_zoom(double val)
{
	int	ret;

	if ((ret = vo_zoom(view_state->vs_vop, interp, val)) != TCL_OK)
		return ret;

	view_state->vs_absolute_scale = 1.0 - view_state->vs_vop->vo_scale / view_state->vs_i_Viewscale;

	if (view_state->vs_absolute_scale < 0.0)
		view_state->vs_absolute_scale /= 9.0;

	if (view_state->vs_absolute_tran[X] != 0.0 ||
	    view_state->vs_absolute_tran[Y] != 0.0 ||
	    view_state->vs_absolute_tran[Z] != 0.0) {
		set_absolute_tran();
	}

	return TCL_OK;
}


/*
 *			F _ Z O O M
 *
 *  A scale factor of 2 will increase the view size by a factor of 2,
 *  (i.e., a zoom out) which is accomplished by reducing Viewscale in half.
 */
int
cmd_zoom(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help zoom");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	return mged_zoom(atof(argv[1]));
}

/*
 *			C M D _ O R I E N T A T I O N
 *
 *  Set current view direction from a quaternion,
 *  such as might be found in a "saveview" script.
 */
int
cmd_orientation(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	return vo_orientation_cmd(view_state->vs_vop, interp, argc, argv);
}

/*
 *			F _ Q V R O T
 *
 *  Set view from direction vector and twist angle
 */
int
f_qvrot(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    double	dx, dy, dz;
    double	az;
    double	el;
    double	theta;

    if(argc < 5 || 5 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help qvrot");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    dx = atof(argv[1]);
    dy = atof(argv[2]);
    dz = atof(argv[3]);

    if (NEAR_ZERO(dy, 0.00001) && NEAR_ZERO(dx, 0.00001))
    {
	if (NEAR_ZERO(dz, 0.00001))
	{
	  Tcl_AppendResult(interp, "f_qvrot: (dx, dy, dz) may not be the zero vector\n", (char *)NULL);
	  return TCL_ERROR;
	}
	az = 0.0;
    }
    else
	az = atan2(dy, dx);
    
    el = atan2(dz, sqrt(dx * dx + dy * dy));

    setview(270.0 + el * radtodeg, 0.0, 270.0 - az * radtodeg);
    theta = atof(argv[4]) * degtorad;
    usejoy(0.0, 0.0, theta);

    return TCL_OK;
}

/*
 *			P A T H _ P A R S E
 *
 *	    Break up a path string into its constituents.
 *
 *	This function has one parameter:  a slash-separated path.
 *	path_parse() allocates storage for and copies each constituent
 *	of path.  It returns a null-terminated array of these copies.
 *
 *	It is the caller's responsibility to free the copies and the
 *	pointer to them.
 */
static char **
path_parse (char *path)
{
    int		nm_constituents;
    int		i;
    char	*pp;
    char	*start_addr;
    char	**result;

    nm_constituents = ((*path != '/') && (*path != '\0'));
    for (pp = path; *pp != '\0'; ++pp)
	if (*pp == '/')
	{
	    while (*++pp == '/')
		;
	    if (*pp != '\0')
		++nm_constituents;
	}
    
    result = (char **) bu_malloc((nm_constituents + 1) * sizeof(char *),
			"array of strings");
    
    for (i = 0, pp = path; i < nm_constituents; ++i)
    {
	while (*pp == '/')
	    ++pp;
	start_addr = pp;
	while ((*++pp != '/') && (*pp != '\0'))
	    ;
	result[i] = (char *) bu_malloc((pp - start_addr + 1) * sizeof(char),
			"string");
	strncpy(result[i], start_addr, (pp - start_addr));
	result[i][pp - start_addr] = '\0';
    }
    result[nm_constituents] = 0;

    return(result);
}


int
cmd_setview(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int     	argc,
	    char    	*argv[])
{
	int	ret;

	if ((ret = vo_setview_cmd(view_state->vs_vop, interp, argc, argv)) != TCL_OK)
		return ret;

	if (view_state->vs_absolute_tran[X] != 0.0 ||
	    view_state->vs_absolute_tran[Y] != 0.0 ||
	    view_state->vs_absolute_tran[Z] != 0.0) {
		set_absolute_tran();
	}

	return TCL_OK;
}

int
f_slewview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	point_t old_model_center;
	point_t new_model_center;
	vect_t diff;
	mat_t	delta;
	int	ret;

	/* this is for the ModelDelta calculation below */
	MAT_DELTAS_GET_NEG(old_model_center, view_state->vs_vop->vo_center);

	if ((ret = vo_slew_cmd(view_state->vs_vop, interp, argc, argv)) != TCL_OK)
		return ret;

	/* all this for ModelDelta */
	MAT_DELTAS_GET_NEG(new_model_center, view_state->vs_vop->vo_center);
	VSUB2(diff, new_model_center, old_model_center);
	MAT_IDN(delta);
	MAT_DELTAS_VEC(delta, diff);
	bn_mat_mul2(delta, view_state->vs_ModelDelta);	/* updates ModelDelta */

	set_absolute_tran();
	return TCL_OK;
}


/* set view reference base */
int
mged_svbase(void)
{ 
	MAT_DELTAS_GET_NEG(view_state->vs_orig_pos, view_state->vs_vop->vo_center);
	view_state->vs_i_Viewscale = view_state->vs_vop->vo_scale;

	/* reset absolute slider values */
	VSETALL(view_state->vs_absolute_rotate, 0.0);
	VSETALL(view_state->vs_last_absolute_rotate, 0.0);
	VSETALL(view_state->vs_absolute_model_rotate, 0.0);
	VSETALL(view_state->vs_last_absolute_model_rotate, 0.0);
	VSETALL(view_state->vs_absolute_tran, 0.0);
	VSETALL(view_state->vs_last_absolute_tran, 0.0);
	VSETALL(view_state->vs_absolute_model_tran, 0.0);
	VSETALL(view_state->vs_last_absolute_model_tran, 0.0);
	view_state->vs_absolute_scale = 0.0;

	if(mged_variables->mv_faceplate && mged_variables->mv_orig_gui)
		curr_dm_list->dml_dirty = 1;

	return TCL_OK;
}


int
f_svbase(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int status;
  struct dm_list *dmlp;

  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel svb");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  status = mged_svbase();

  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l)
    /* if sharing view while faceplate and original gui (i.e. button menu, sliders) are on */
    if(dmlp->dml_view_state == view_state &&
       dmlp->dml_mged_variables->mv_faceplate &&
       dmlp->dml_mged_variables->mv_orig_gui)
      dmlp->dml_dirty = 1;

  return status;
}

/*
 *			F _ V R O T _ C E N T E R
 *
 *  Set the center of rotation, either in model coordinates, or
 *  in view (+/-1) coordinates.
 *  The default is to rotate around the view center: v=(0,0,0).
 */
int
f_vrot_center(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if(argc < 5 || 5 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help vrot_center");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* XXXX Actually, this is now available in LIBRT's view_obj.c */
  Tcl_AppendResult(interp, "Not ready until tomorrow.\n", (char *)NULL);
  return TCL_OK;
}

/*
 *			U S E J O Y
 *
 *  Apply the "joystick" delta rotation to the viewing direction,
 *  where the delta is specified in terms of the *viewing* axes.
 *  Rotation is performed about the view center, for now.
 *  Angles are in radians.
 */
void
usejoy(double xangle, double yangle, double zangle)
{
	mat_t	newrot;		/* NEW rot matrix, from joystick */

	/* NORMAL CASE.
	 * Apply delta viewing rotation for non-edited parts.
	 * The view rotates around the VIEW CENTER.
	 */
	MAT_IDN( newrot );
	bn_mat_angles_rad( newrot, xangle, yangle, zangle );

	bn_mat_mul2(newrot, view_state->vs_vop->vo_rotation);
	{
		mat_t	newinv;
		bn_mat_inv( newinv, newrot );
		wrt_view( view_state->vs_ModelDelta, newinv, view_state->vs_ModelDelta );	/* Updates ModelDelta */
	}
	new_mats();
}

/*
 *			A B S V I E W _ V
 *
 *  The "angle" ranges from -1 to +1.
 *  Assume rotation around view center, for now.
 */
void
absview_v(const fastf_t *ang)
{
	point_t	rad;

	VSCALE( rad, ang, bn_pi );	/* range from -pi to +pi */
	bn_mat_angles_rad(view_state->vs_vop->vo_rotation, rad[X], rad[Y], rad[Z]);
	new_mats();
}

/*
 *			S E T V I E W
 *
 * Set the view.  Angles are DOUBLES, in degrees.
 *
 * Given that viewvec = scale . rotate . (xlate to view center) . modelvec,
 * we just replace the rotation matrix.
 * (This assumes rotation around the view center).
 */
void
setview(double	a1,
	double	a2,
	double	a3)		/* DOUBLE angles, in degrees */
{
	vect_t		rvec;

	VSET(rvec, a1, a2, a3);
	vo_setview(view_state->vs_vop, interp, rvec);

	if (view_state->vs_absolute_tran[X] != 0.0 ||
	    view_state->vs_absolute_tran[Y] != 0.0 ||
	    view_state->vs_absolute_tran[Z] != 0.0){
		set_absolute_tran();
	}
}

/*
 *			S L E W V I E W
 *
 *  Given a position in view space,
 *  make that point the new view center.
 */
void
slewview(vect_t view_pos)
{
	point_t old_model_center;
	point_t new_model_center;
	vect_t diff;
	mat_t	delta;

	/* this is for the ModelDelta calculation below */
	MAT_DELTAS_GET_NEG(old_model_center, view_state->vs_vop->vo_center);

	(void)vo_slew(view_state->vs_vop, interp, view_pos);

	/* all this for ModelDelta */
	MAT_DELTAS_GET_NEG(new_model_center, view_state->vs_vop->vo_center);
	VSUB2(diff, new_model_center, old_model_center);
	MAT_IDN(delta);
	MAT_DELTAS_VEC(delta, diff);
	bn_mat_mul2(delta, view_state->vs_ModelDelta);	/* updates ModelDelta */

	set_absolute_tran();
}

/*
 *			F _ E Y E _ P T
 *
 *  Perform same function as mged command that 'eye_pt' performs
 *  in rt animation script -- put eye at specified point.
 */
int
cmd_eye_pt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	return vo_eye_cmd(view_state->vs_vop, interp, argc, argv);
}

/*
 *			F _ M O D E L 2 V I E W
 *
 *  Given a point in model space coordinates (in mm)
 *  convert it to view (screen) coordinates.
 */
int
f_model2view(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
#if 0
	return vo_model2view_cmd(view_state->vs_vop, interp, argc, argv);
#else
	point_t	model;
	point_t	view;
	struct bu_vls	str;
	struct bu_vls vls;

	if (argc != 4)
		goto bad;

	if (sscanf(argv[1], "%lf", &model[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &model[Y]) != 1)
		goto bad;
	if (sscanf(argv[3], "%lf", &model[Z]) != 1)
		goto bad;

	MAT4X3PNT(view, view_state->vs_vop->vo_model2view, model);

	bu_vls_init(&str);
	bn_encode_vect(&str, view);
	Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	bu_vls_free(&str);

	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel model2view");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
#endif
}

/*
 *			F _ V I E W 2 M O D E L
 *
 *  Given a point in view (screen) space coordinates,
 *  convert it to model coordinates (in mm).
 */
int
f_view2model(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	point_t	model;
	point_t	view;
	struct bu_vls	str;
	struct bu_vls vls;

	if (argc != 4)
		goto bad;

	if (sscanf(argv[1], "%lf", &view[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &view[Y]) != 1)
		goto bad;
	if (sscanf(argv[3], "%lf", &view[Z]) != 1)
		goto bad;

	MAT4X3PNT(model, view_state->vs_vop->vo_view2model, view);

	bu_vls_init(&str);
	bn_encode_vect(&str, model);
	Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	bu_vls_free(&str);

	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel view2model");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 *			F _ M O D E L 2 V I E W _ L U
 *
 *  Given a point in model coordinates (local units),
 *  convert it to view coordinates (local units).
 */
int
f_model2view_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;
	fastf_t f;
	point_t view_pt;
	point_t model_pt;

	CHECK_DBI_NULL;

	if (argc != 4)
		goto bad;

	if (sscanf(argv[1], "%lf", &model_pt[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &model_pt[Y]) != 1)
		goto bad;
	if (sscanf(argv[3], "%lf", &model_pt[Z]) != 1)
		goto bad;

	VSCALE(model_pt, model_pt, local2base);
	MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, model_pt);
	f = view_state->vs_vop->vo_scale * base2local;
	VSCALE(view_pt, view_pt, f);

	bu_vls_init(&vls);
	bn_encode_vect(&vls, view_pt);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel model2view_lu");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 *			F _ V I E W 2 M O D E L _ L U 
 *
 *  Given a point in view coordinates (local units),
 *  convert it to model coordinates (local units).
 */
int
f_view2model_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;
	fastf_t sf;
	point_t view_pt;
	point_t model_pt;

	CHECK_DBI_NULL;

	if (argc != 4)
		goto bad;

	if (sscanf(argv[1], "%lf", &view_pt[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &view_pt[Y]) != 1)
		goto bad;
	if (sscanf(argv[3], "%lf", &view_pt[Z]) != 1)
		goto bad;

	sf = 1.0 / (view_state->vs_vop->vo_scale * base2local);
	VSCALE(view_pt, view_pt, sf);
	MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);

	bu_vls_init(&vls);
	bn_encode_vect(&vls, model_pt);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

	bu_vls_free(&vls);
	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel view2model_lu");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 *			F _ M O D E L 2 G R I D _ L U
 *
 *  Given a point in model coordinates (local units),
 *  convert it to grid coordinates (local units).
 */
int
f_model2grid_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;
	fastf_t f;
	point_t view_pt;
	point_t model_pt;
	point_t mo_view_pt;           /* model origin in view space */
	point_t diff;

	CHECK_DBI_NULL;


	if (argc != 4)
		goto bad;

	VSETALL(model_pt, 0.0);
	MAT4X3PNT(mo_view_pt, view_state->vs_vop->vo_model2view, model_pt);

	if (sscanf(argv[1], "%lf", &model_pt[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &model_pt[Y]) != 1)
		goto bad;
	if (sscanf(argv[3], "%lf", &model_pt[Z]) != 1)
		goto bad;

	VSCALE(model_pt, model_pt, local2base);
	MAT4X3PNT(view_pt, view_state->vs_vop->vo_model2view, model_pt);

	VSUB2(diff, view_pt, mo_view_pt);
	f = view_state->vs_vop->vo_scale * base2local;
	VSCALE(diff, diff, f);

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%.15e %.15e", diff[X], diff[Y]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

	bu_vls_free(&vls);
	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel model2grid_lu");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 *			F _ G R I D 2 M O D E L _ L U
 *
 *  Given a point in grid coordinates (local units),
 *  convert it to model coordinates (local units).
 */
int
f_grid2model_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;
	fastf_t f;
	point_t view_pt;
	point_t model_pt;
	point_t mo_view_pt;           /* model origin in view space */
	point_t diff;

	CHECK_DBI_NULL;


	if (argc != 3)
		goto bad;

	if (sscanf(argv[1], "%lf", &diff[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &diff[Y]) != 1)
		goto bad;
	diff[Z] = 0.0;

	f = 1.0 / (view_state->vs_vop->vo_scale * base2local);
	VSCALE(diff, diff, f);

	VSETALL(model_pt, 0.0);
	MAT4X3PNT(mo_view_pt, view_state->vs_vop->vo_model2view, model_pt);

	VADD2(view_pt, mo_view_pt, diff);
	MAT4X3PNT(model_pt, view_state->vs_vop->vo_view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);

	bu_vls_init(&vls);
	bn_encode_vect(&vls, model_pt);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

	bu_vls_free(&vls);
	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel grid2model_lu");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 *			F _ V I E W 2 G R I D _ L U 
 *
 *  Given a point in view coordinates (local units),
 *  convert it to grid coordinates (local units).
 */
int
f_view2grid_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;
	fastf_t f;
	point_t view_pt;
	point_t model_pt;
	point_t mo_view_pt;           /* model origin in view space */
	point_t diff;

	CHECK_DBI_NULL;


	if (argc != 4)
		goto bad;

	if (sscanf(argv[1], "%lf", &view_pt[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &view_pt[Y]) != 1)
		goto bad;
	if (sscanf(argv[3], "%lf", &view_pt[Z]) != 1)
		goto bad;

	VSETALL(model_pt, 0.0);
	MAT4X3PNT(mo_view_pt, view_state->vs_vop->vo_model2view, model_pt);
	f = view_state->vs_vop->vo_scale * base2local;
	VSCALE(mo_view_pt, mo_view_pt, f);
	VSUB2(diff, view_pt, mo_view_pt);

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%.15e %.15e", diff[X], diff[Y]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

	bu_vls_free(&vls);
	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel view2grid_lu");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 *			F _ G R I D 2 V I E W _ L U
 *
 *  Given a point in grid coordinates (local units),
 *  convert it to view coordinates (local units).
 */
int
f_grid2view_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;
	fastf_t f;
	point_t view_pt;
	point_t model_pt;
	point_t mo_view_pt;           /* model origin in view space */
	point_t diff;

	CHECK_DBI_NULL;

	if (argc != 3)
		goto bad;

	if (sscanf(argv[1], "%lf", &diff[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &diff[Y]) != 1)
		goto bad;
	diff[Z] = 0.0;

	VSETALL(model_pt, 0.0);
	MAT4X3PNT(mo_view_pt, view_state->vs_vop->vo_model2view, model_pt);
	f = view_state->vs_vop->vo_scale * base2local;
	VSCALE(mo_view_pt, mo_view_pt, f);
	VADD2(view_pt, mo_view_pt, diff);

	bu_vls_init(&vls);
	bn_encode_vect(&vls, view_pt);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

	bu_vls_free(&vls);
	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel grid2view_lu");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 *			F _ V I E W 2 M O D E L _ V E C
 *
 *  Given a vector in view coordinates,
 *  convert it to model coordinates.
 */
int
f_view2model_vec(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;
	point_t model_vec;
	point_t view_vec;
	mat_t inv_Viewrot;

	if (argc != 4)
		goto bad;

	if (sscanf(argv[1], "%lf", &view_vec[X]) != 1)
		goto bad;
	if (sscanf(argv[2], "%lf", &view_vec[Y]) != 1)
		goto bad;
	if (sscanf(argv[3], "%lf", &view_vec[Z]) != 1)
		goto bad;

	bn_mat_inv(inv_Viewrot, view_state->vs_vop->vo_rotation);
	MAT4X3PNT(model_vec, inv_Viewrot, view_vec);

	bu_vls_init(&vls);
	bn_encode_vect(&vls, model_vec);
#if 0
	bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(model_vec));
#endif
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

	bu_vls_free(&vls);
	return TCL_OK;

 bad:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel view2model_vec");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

int
cmd_lookat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return vo_lookat_cmd(view_state->vs_vop, interp, argc, argv);
}

/*
 * Initialize vsp1 using vsp2 if vsp2 is not null.
 */
void
view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2)
{
  struct view_ring *vrp1;
  struct view_ring *vrp2;

  BU_LIST_INIT(&vsp1->vs_headView.l);

  if(vsp2 != (struct _view_state *)NULL){
    struct view_ring *vrp1_current_view = NULL;
    struct view_ring *vrp1_last_view = NULL;

    for(BU_LIST_FOR(vrp2, view_ring, &vsp2->vs_headView.l)){
      BU_GETSTRUCT(vrp1, view_ring);
      /* append to last list element */
      BU_LIST_APPEND(vsp1->vs_headView.l.back, &vrp1->l);

      MAT_COPY(vrp1->vr_rot_mat, vrp2->vr_rot_mat);
      MAT_COPY(vrp1->vr_tvc_mat, vrp2->vr_tvc_mat);
      vrp1->vr_scale = vrp2->vr_scale;
      vrp1->vr_id = vrp2->vr_id;

      if(vsp2->vs_current_view == vrp2)
	vrp1_current_view = vrp1;

      if(vsp2->vs_last_view == vrp2)
	vrp1_last_view = vrp1;
    }

    vsp1->vs_current_view = vrp1_current_view;
    vsp1->vs_last_view = vrp1_last_view;
  } else {
    BU_GETSTRUCT(vrp1, view_ring);
    BU_LIST_APPEND(&vsp1->vs_headView.l, &vrp1->l);

    vrp1->vr_id = 1;
    vsp1->vs_current_view = vrp1;
    vsp1->vs_last_view = vrp1;
  }
}

void
view_ring_destroy(struct dm_list *dlp)
{
  struct view_ring *vrp;

  while(BU_LIST_NON_EMPTY(&dlp->dml_view_state->vs_headView.l)){
    vrp = BU_LIST_FIRST(view_ring,&dlp->dml_view_state->vs_headView.l);
    BU_LIST_DEQUEUE(&vrp->l);
    bu_free((genptr_t)vrp, "view_ring_destroy: vrp");
  }
}


/*
 * SYNOPSIS
 *	view_ring add|next|prev|toggle		
 *	view_ring delete #			delete view #
 *	view_ring goto #			goto view #
 *	view_ring get [-a]			get the current view
 *
 * DESCRIPTION
 *
 * EXAMPLES
 *
 */
int
f_view_ring(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	int n;
	struct view_ring *vrp;
	struct view_ring *lv;
	struct bu_vls vls;

	if (argc < 2 || 3 < argc) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel view_ring");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (!strcmp(argv[1],"add")) {
		if (argc != 2) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "help view_ring");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* save current Viewrot */
		MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);

		/* save current toViewcenter */
		MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);

		/* save current Viewscale */
		view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;

		/* allocate memory and append to list */
		BU_GETSTRUCT(vrp, view_ring);
		lv = BU_LIST_LAST(view_ring, &view_state->vs_headView.l);
		BU_LIST_APPEND(&lv->l, &vrp->l);

		/* assign a view number */
		vrp->vr_id = lv->vr_id + 1;

		view_state->vs_last_view = view_state->vs_current_view;
		view_state->vs_current_view = vrp;
		(void)mged_svbase();

		return TCL_OK;
	}

	if (!strcmp(argv[1],"next")) {
		if (argc != 2) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "help view_ring");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* check to see if this is the last view in the list */
		if (BU_LIST_IS_HEAD(view_state->vs_current_view->l.forw, &view_state->vs_headView.l) &&
		   BU_LIST_IS_HEAD(view_state->vs_current_view->l.back, &view_state->vs_headView.l))
			return TCL_OK;

		/* save current Viewrot */
		MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);

		/* save current toViewcenter */
		MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);

		/* save current Viewscale */
		view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;

		view_state->vs_last_view = view_state->vs_current_view;
		view_state->vs_current_view = BU_LIST_PNEXT(view_ring, view_state->vs_current_view);

		if (BU_LIST_IS_HEAD(view_state->vs_current_view, &view_state->vs_headView.l))
			view_state->vs_current_view = BU_LIST_FIRST(view_ring, &view_state->vs_headView.l);

		MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
		MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
		view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;

		new_mats();
		(void)mged_svbase();

		return TCL_OK;
	}

	if (!strcmp(argv[1],"prev")) {
		if (argc != 2) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "help view_ring");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* check to see if this is the last view in the list */
		if (BU_LIST_IS_HEAD(view_state->vs_current_view->l.forw, &view_state->vs_headView.l) &&
		    BU_LIST_IS_HEAD(view_state->vs_current_view->l.back, &view_state->vs_headView.l))
			return TCL_OK;

		/* save current Viewrot */
		MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);

		/* save current toViewcenter */
		MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);

		/* save current Viewscale */
		view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;

		view_state->vs_last_view = view_state->vs_current_view;
		view_state->vs_current_view = BU_LIST_PLAST(view_ring, view_state->vs_current_view);

		if (BU_LIST_IS_HEAD(view_state->vs_current_view, &view_state->vs_headView.l))
			view_state->vs_current_view = BU_LIST_LAST(view_ring, &view_state->vs_headView.l);

		MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
		MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
		view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;

		new_mats();
		(void)mged_svbase();

		return TCL_OK;
	}

	if (!strcmp(argv[1],"toggle")) {
		struct view_ring *save_last_view;

		if (argc != 2) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "help view_ring");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* save current Viewrot */
		MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);

		/* save current toViewcenter */
		MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);

		/* save current Viewscale */
		view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;

		save_last_view = view_state->vs_last_view;
		view_state->vs_last_view = view_state->vs_current_view;
		view_state->vs_current_view = save_last_view;
		MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
		MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
		view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;

		new_mats();
		(void)mged_svbase();

		return TCL_OK;
	}

	if (!strcmp(argv[1],"delete")) {
		if (argc != 3) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "help view_ring");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* search for view with id of n */
		n = atoi(argv[2]);
		for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)) {
			if(vrp->vr_id == n)
				break;
		}

		if (BU_LIST_IS_HEAD(vrp, &view_state->vs_headView.l)) {
			Tcl_AppendResult(interp, "view_ring delete: ", argv[2], " is not a valid view\n",
					 (char *)NULL);
			return TCL_ERROR;
		}

		/* check to see if this is the last view in the list */
		if (BU_LIST_IS_HEAD(vrp->l.forw, &view_state->vs_headView.l) &&
		    BU_LIST_IS_HEAD(vrp->l.back, &view_state->vs_headView.l)) {
			Tcl_AppendResult(interp, "view_ring delete: Cannot delete the only remaining view!\n", (char *)NULL);
			return TCL_ERROR;
		}

		if (vrp == view_state->vs_current_view) {
			if (view_state->vs_current_view == view_state->vs_last_view) {
				view_state->vs_current_view = BU_LIST_PNEXT(view_ring, view_state->vs_last_view);
				view_state->vs_last_view = view_state->vs_current_view;
			} else
				view_state->vs_current_view = view_state->vs_last_view;

			MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
			MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
			view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;
			new_mats();
			(void)mged_svbase();
		}else if (vrp == view_state->vs_last_view)
			view_state->vs_last_view = view_state->vs_current_view;

		BU_LIST_DEQUEUE(&vrp->l);
		bu_free((genptr_t)vrp, "view_ring delete");

		return TCL_OK;
	}

	if (!strcmp(argv[1],"goto")) {
		if (argc != 3) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "help view_ring");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* search for view with id of n */
		n = atoi(argv[2]);
		for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)) {
			if (vrp->vr_id == n)
				break;
		}

		if (BU_LIST_IS_HEAD(vrp, &view_state->vs_headView.l)) {
			Tcl_AppendResult(interp, "view_ring goto: ", argv[2], " is not a valid view\n",
					 (char *)NULL);
			return TCL_ERROR;
		}

		/* nothing to do */
		if (vrp == view_state->vs_current_view)
			return TCL_OK;

		/* save current Viewrot */
		MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);

		/* save current toViewcenter */
		MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);

		/* save current Viewscale */
		view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;

		view_state->vs_last_view = view_state->vs_current_view;
		view_state->vs_current_view = vrp;
		MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
		MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
		view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;

		new_mats();
		(void)mged_svbase();

		return TCL_OK;
	}

	if (!strcmp(argv[1],"get")) {
		/* return current view */
		if (argc == 2) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "%d", view_state->vs_current_view->vr_id);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_OK;
		}

		if (strcmp("-a", argv[2])) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "help view_ring");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		bu_vls_init(&vls);
		for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)) {
			bu_vls_printf(&vls, "%d", vrp->vr_id);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));
			bu_vls_trunc(&vls, 0);
		}

		bu_vls_free(&vls);
		return TCL_OK;
	}

	Tcl_AppendResult(interp, "view_ring: unrecognized command - ", argv[1], (char *)NULL);
	return TCL_ERROR;
}

int
mged_erot(struct view_obj	*vop,
	  Tcl_Interp		*interp,
	  char			coords,
	  char			rotate_about,
	  mat_t			newrot)
{
	int save_edflag;
	mat_t temp1, temp2;

	update_views = 1;

	switch(coords){
	case 'm':
		break;
	case 'o':
		bn_mat_inv(temp1, acc_rot_sol);

		/* transform into object rotations */
		bn_mat_mul(temp2, acc_rot_sol, newrot);
		bn_mat_mul(newrot, temp2, temp1);
		break;
	case 'v':
		bn_mat_inv(temp1, view_state->vs_vop->vo_rotation);

		/* transform into model rotations */
		bn_mat_mul(temp2, temp1, newrot);
		bn_mat_mul(newrot, temp2, view_state->vs_vop->vo_rotation);
		break;
	}

	if (state == ST_S_EDIT) {
		char save_rotate_about;

		save_rotate_about = mged_variables->mv_rotate_about;
		mged_variables->mv_rotate_about = rotate_about;

		save_edflag = es_edflag;
		if (!SEDIT_ROTATE)
			es_edflag = SROT;

		inpara = 0;
		MAT_COPY(incr_change, newrot);
		bn_mat_mul2(incr_change, acc_rot_sol);
		sedit();

		mged_variables->mv_rotate_about = save_rotate_about;
		es_edflag = save_edflag;
	} else {
		point_t point;
		vect_t work;

		bn_mat_mul2(newrot, acc_rot_sol);

		/* find point for rotation to take place wrt */
		switch (rotate_about) {
		case 'v':       /* View Center */
			VSET(work, 0.0, 0.0, 0.0);
			MAT4X3PNT(point, view_state->vs_vop->vo_view2model, work);
			break;
		case 'e':       /* Eye */
			VSET(work, 0.0, 0.0, 1.0);
			MAT4X3PNT(point, view_state->vs_vop->vo_view2model, work);
			break;
		case 'm':       /* Model Center */
			VSETALL(point, 0.0);
			break;
		case 'k':
		default:
			MAT4X3PNT(point, modelchanges, es_keypoint);
		}

		/* 
		 * Apply newrot to the modelchanges matrix wrt "point"
		 */
		wrt_point(modelchanges, newrot, modelchanges, point);

		new_edit_mats();
	}

	return TCL_OK;
}

int
mged_erot_xyz(char	rotate_about,
	      vect_t	rvec)
{
	mat_t newrot;

	MAT_IDN(newrot);
	bn_mat_angles(newrot, rvec[X], rvec[Y], rvec[Z]);

	return mged_erot(view_state->vs_vop, interp, mged_variables->mv_coords, rotate_about, newrot);
}

int
cmd_mrot(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int     	argc,
	 char    	**argv)
{
	if ((state == ST_S_EDIT || state == ST_O_EDIT) &&
	    mged_variables->mv_transform == 'e')
		return vo_mrot_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())mged_erot);
	else
		return vo_mrot_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())0);
}

/*
 *			M G E D _ V R O T
 */
int
mged_vrot(char origin, fastf_t *newrot)
{
	mat_t   newinv;

	bn_mat_inv(newinv, newrot);

	if(origin != 'v'){
		point_t		rot_pt;
		point_t		new_origin;
		mat_t		viewchg, viewchginv;
		point_t		new_cent_view;
		point_t		new_cent_model;

		if (origin == 'e') {
			/* "VR driver" method: rotate around "eye" point (0,0,1) viewspace */
			VSET( rot_pt, 0.0, 0.0, 1.0 );		/* point to rotate around */
		} else if (origin == 'k' && state == ST_S_EDIT) {
			/* rotate around keypoint */
			MAT4X3PNT(rot_pt, view_state->vs_vop->vo_model2view, curr_e_axes_pos);
		} else if (origin == 'k' && state == ST_O_EDIT) {
			point_t kpWmc;

			MAT4X3PNT(kpWmc, modelchanges, es_keypoint);
			MAT4X3PNT(rot_pt, view_state->vs_vop->vo_model2view, kpWmc);
		} else {
			/* rotate around model center (0,0,0) */
			VSET(new_origin, 0.0, 0.0, 0.0);
			MAT4X3PNT(rot_pt, view_state->vs_vop->vo_model2view, new_origin);  /* point to rotate around */
		}

		bn_mat_xform_about_pt(viewchg, newrot, rot_pt);
		bn_mat_inv(viewchginv, viewchg);

		/* Convert origin in new (viewchg) coords back to old view coords */
		VSET(new_origin, 0.0, 0.0, 0.0);
		MAT4X3PNT(new_cent_view, viewchginv, new_origin);
		MAT4X3PNT(new_cent_model, view_state->vs_vop->vo_view2model, new_cent_view);
		MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, new_cent_model);

		/* XXX This should probably capture the translation too */
		/* XXX I think the only consumer of ModelDelta is the predictor frame */
		wrt_view(view_state->vs_ModelDelta, newinv, view_state->vs_ModelDelta);		/* pure rotation */
	} else
		/* Traditional method:  rotate around view center (0,0,0) viewspace */
		wrt_view(view_state->vs_ModelDelta, newinv, view_state->vs_ModelDelta);

	/* Update the rotation component of the model2view matrix */
	bn_mat_mul2(newrot, view_state->vs_vop->vo_rotation); /* pure rotation */
	new_mats();

	set_absolute_tran();

	return TCL_OK;
}

int
mged_vrot_xyz(char	origin,
	      char	coords,
	      vect_t	rvec)
{
	mat_t newrot;
	mat_t temp1, temp2;

	MAT_IDN(newrot);
	bn_mat_angles(newrot, rvec[X], rvec[Y], rvec[Z]);

	if (coords == 'm') {
		/* transform model rotations into view rotations */
		bn_mat_inv(temp1, view_state->vs_vop->vo_rotation);
		bn_mat_mul(temp2, view_state->vs_vop->vo_rotation, newrot);
		bn_mat_mul(newrot, temp2, temp1);
	} else if ((state == ST_S_EDIT || state == ST_O_EDIT) && coords == 'o') {
		/* first, transform object rotations into model rotations */
		bn_mat_inv(temp1, acc_rot_sol);
		bn_mat_mul(temp2, acc_rot_sol, newrot);
		bn_mat_mul(newrot, temp2, temp1);

		/* now transform model rotations into view rotations */
		bn_mat_inv(temp1, view_state->vs_vop->vo_rotation);
		bn_mat_mul(temp2, view_state->vs_vop->vo_rotation, newrot);
		bn_mat_mul(newrot, temp2, temp1);
	} /* else assume already view rotations */

  return mged_vrot(origin, newrot);
}

int
cmd_vrot(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	int ret;

	if ((ret = vo_vrot_cmd(view_state->vs_vop, interp, argc, argv)) != TCL_OK)
		return ret;

	set_absolute_tran();
	return TCL_OK;
}

int
cmd_rot(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	if ((state == ST_S_EDIT || state == ST_O_EDIT) &&
	    mged_variables->mv_transform == 'e')
		return vo_rot_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())mged_erot);
	else
		return vo_rot_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())0);
}

int
cmd_arot(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	if ((state == ST_S_EDIT || state == ST_O_EDIT) &&
	    mged_variables->mv_transform == 'e')
		return vo_arot_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())mged_erot);
	else
		return vo_arot_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())0);
}

int
mged_etran(struct view_obj	*vop,
	   Tcl_Interp		*interp,
	   char			coords,
	   vect_t		tvec)
{
  point_t p2;
  int save_edflag;
  point_t delta;
  point_t vcenter;
  point_t work;
  mat_t xlatemat;

  /* compute delta */
  switch(coords){
  case 'm':
    VSCALE(delta, tvec, local2base);
    break;
  case 'o':
    VSCALE(p2, tvec, local2base);
    MAT4X3PNT(delta, acc_rot_sol, p2);
    break;
  case 'v':
  default:
    VSCALE(p2, tvec, local2base/view_state->vs_vop->vo_scale);
    MAT4X3PNT(work, view_state->vs_vop->vo_view2model, p2);
    MAT_DELTAS_GET_NEG(vcenter, view_state->vs_vop->vo_center);
    VSUB2(delta, work, vcenter);

    break;
  }

  if(state == ST_S_EDIT){
    save_edflag = es_edflag;
    if(!SEDIT_TRAN)
      es_edflag = STRANS;

    VADD2(es_para, delta, curr_e_axes_pos);
    inpara = 3;
    sedit();
    es_edflag = save_edflag;
  }else{
    MAT_IDN(xlatemat);
    MAT_DELTAS_VEC(xlatemat, delta);
    bn_mat_mul2(xlatemat, modelchanges);

    new_edit_mats();
    update_views = 1;
  }

  return TCL_OK;
}

int
mged_otran(const vect_t tvec)
{
  vect_t work;

  if(state == ST_S_EDIT || state == ST_O_EDIT){
    /* apply acc_rot_sol to tvec */
    MAT4X3PNT(work, acc_rot_sol, tvec);
  }

  return mged_mtran(work);
}

int
mged_mtran(const vect_t tvec)
{
	point_t delta;
	point_t vc, nvc;

	VSCALE(delta, tvec, local2base);
	MAT_DELTAS_GET_NEG(vc, view_state->vs_vop->vo_center);
	VSUB2(nvc, vc, delta);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, nvc);
	new_mats();

	/* calculate absolute_tran */
	set_absolute_view_tran();
  
	return TCL_OK;
}

int
mged_vtran(const vect_t tvec)
{
  vect_t  tt;
  point_t delta;
  point_t work;
  point_t vc, nvc;

  VSCALE(tt, tvec, local2base/view_state->vs_vop->vo_scale);
  MAT4X3PNT(work, view_state->vs_vop->vo_view2model, tt);
  MAT_DELTAS_GET_NEG(vc, view_state->vs_vop->vo_center);
  VSUB2(delta, work, vc);
  VSUB2(nvc, vc, delta);
  MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, nvc);

  new_mats();

  /* calculate absolute_model_tran */
  set_absolute_model_tran();
  
  return TCL_OK;
}

int
mged_tran(vect_t tvec)
{
  if((state == ST_S_EDIT || state == ST_O_EDIT) &&
      mged_variables->mv_transform == 'e')
    return mged_etran(view_state->vs_vop, interp, mged_variables->mv_coords, tvec);

  /* apply to View */
  if(mged_variables->mv_coords == 'm')
    return mged_mtran(tvec);

  if(mged_variables->mv_coords == 'o')
    return mged_otran(tvec);

  return mged_vtran(tvec);
}

int
cmd_tra(ClientData	clientData,
	Tcl_Interp	*interp,
	int     	argc,
	char    	**argv)
{
	if ((state == ST_S_EDIT || state == ST_O_EDIT) &&
	    mged_variables->mv_transform == 'e')
		return vo_tra_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())mged_etran);
	else
		return vo_tra_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())0);
}

int
mged_escale(struct view_obj	*vop,
	    Tcl_Interp		*interp,
	    fastf_t		sfactor)
{
  fastf_t old_scale;

  if(-SMALL_FASTF < sfactor && sfactor < SMALL_FASTF)
    return TCL_OK;

  if(state == ST_S_EDIT){
    int save_edflag;

    save_edflag = es_edflag;
    if(!SEDIT_SCALE)
      es_edflag = SSCALE;

    es_scale = sfactor;
    old_scale = acc_sc_sol;
    acc_sc_sol *= sfactor;

    if(acc_sc_sol < MGED_SMALL_SCALE){
      acc_sc_sol = old_scale;
      es_edflag = save_edflag;
      return TCL_OK;
    }

    if(acc_sc_sol >= 1.0)
      edit_absolute_scale = (acc_sc_sol - 1.0) / 3.0;
    else
      edit_absolute_scale = acc_sc_sol - 1.0;

    sedit();

    es_edflag = save_edflag;
  }else{
    point_t temp;
    point_t pos_model;
    mat_t smat;
    fastf_t inv_sfactor;

    inv_sfactor = 1.0 / sfactor;
    MAT_IDN(smat);

    switch(edobj){
    case BE_O_XSCALE:                            /* local scaling ... X-axis */
      smat[0] = sfactor;
      old_scale = acc_sc[X];
      acc_sc[X] *= sfactor;

      if(acc_sc[X] < MGED_SMALL_SCALE){
	acc_sc[X] = old_scale;
	return TCL_OK;
      }
      break;
    case BE_O_YSCALE:                            /* local scaling ... Y-axis */
      smat[5] = sfactor;
      old_scale = acc_sc[Y];
      acc_sc[Y] *= sfactor;

      if(acc_sc[Y] < MGED_SMALL_SCALE){
	acc_sc[Y] = old_scale;
	return TCL_OK;
      }
      break;
    case BE_O_ZSCALE:                            /* local scaling ... Z-axis */
      smat[10] = sfactor;
      old_scale = acc_sc[Z];
      acc_sc[Z] *= sfactor;

      if(acc_sc[Z] < MGED_SMALL_SCALE){
	acc_sc[Z] = old_scale;
	return TCL_OK;
      }
      break;
    case BE_O_SCALE:                             /* global scaling */
    default:
      smat[15] = inv_sfactor;
      old_scale = acc_sc_sol;
      acc_sc_sol *= inv_sfactor;

      if(acc_sc_sol < MGED_SMALL_SCALE){
	acc_sc_sol = old_scale;
	return TCL_OK;
      }
      break;
    }

    /* Have scaling take place with respect to keypoint,
     * NOT the view center.
     */
    VMOVE(temp, es_keypoint);
    MAT4X3PNT(pos_model, modelchanges, temp);
    wrt_point(modelchanges, smat, modelchanges, pos_model);

    new_edit_mats();
  }

  return TCL_OK;
}

int
mged_vscale(fastf_t sfactor)
{
	fastf_t f;

	if (-SMALL_FASTF < sfactor && sfactor < SMALL_FASTF)
		return TCL_OK;

	view_state->vs_vop->vo_scale *= sfactor;
	if (view_state->vs_vop->vo_scale < RT_MINVIEWSIZE)
		view_state->vs_vop->vo_scale = RT_MINVIEWSIZE;
	f = view_state->vs_vop->vo_scale / view_state->vs_i_Viewscale;

	if (f >= 1.0)
		view_state->vs_absolute_scale = (f - 1.0) / -9.0;
	else
		view_state->vs_absolute_scale = 1.0 - f;

	new_mats();
	return TCL_OK;
}

int
mged_scale(fastf_t sfactor)
{
	if ((state == ST_S_EDIT || state == ST_O_EDIT) &&
	    mged_variables->mv_transform == 'e')
		return mged_escale(view_state->vs_vop, interp, sfactor);

	return mged_vscale(sfactor);
}

int
cmd_sca(ClientData	clientData,
	Tcl_Interp	*interp,
	int     	argc,
	char    	**argv)
{
	if ((state == ST_S_EDIT || state == ST_O_EDIT) &&
	    mged_variables->mv_transform == 'e')
		return vo_sca_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())mged_escale);
	else {
		int	ret;
		fastf_t	f;

		if ((ret = vo_sca_cmd(view_state->vs_vop, interp, argc, argv, (int (*)())0)) != TCL_OK)
			return ret;

		f = view_state->vs_vop->vo_scale / view_state->vs_i_Viewscale;
		if (f >= 1.0)
			view_state->vs_absolute_scale = (f - 1.0) / -9.0;
		else
			view_state->vs_absolute_scale = 1.0 - f;

		return TCL_OK;
	}
}
@


11.192
log
@change conf.h to a wrapped config.h
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/chgview.c,v 11.191 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.191
log
@merge of ansi-6-0-branch into HEAD
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d58 5
a62 1
#include "conf.h"
@


11.190
log
@update copyright to include span through 2003
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.189 2003/12/01 16:18:52 morrison Exp $ (BRL)";
d86 13
a98 13
extern void color_soltab();
extern void set_absolute_tran(); /* defined in set.c */
extern void set_absolute_view_tran(); /* defined in set.c */
extern void set_absolute_model_tran(); /* defined in set.c */

void solid_list_callback();
void knob_update_rate_vars();
int mged_svbase();
int mged_vrot();
int mged_zoom();
void mged_center();
static void abs_zoom();
void usejoy();
d101 1
a101 1
int knob_tran();
d103 4
a106 4
int mged_mtran();
int mged_otran();
int mged_vtran();
int mged_tran();
d346 1
a346 1
size_reset()
d628 1
a628 1
solid_list_callback()
d669 1
a669 5
f_regdebug(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d848 1
a848 4
do_list( outstrp, dp, verbose )
struct bu_vls	*outstrp;
register struct directory *dp;
int	verbose;
d878 1
a878 1
mged_freemem()
d930 1
a930 5
f_status(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1039 1
a1039 5
f_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1351 1
a1351 5
f_refresh(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1465 2
a1466 2
eraseobjall(dpp)
     register struct directory **dpp;	/* this is a partial path spec. XXX should be db_full_path? */
d1520 2
a1521 2
eraseobj(dpp)
     register struct directory **dpp;	/* this is a partial path spec. XXX should be db_full_path? */
d1579 3
a1581 3
pr_schain( startp, lvl )
struct solid *startp;
int		lvl;			/* debug level */
d1668 1
a1668 1
static char ** path_parse ();
d1672 1
a1672 5
f_ill(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1905 1
a1905 1
check_nonzero_rates()
d1984 1
a1984 1
knob_update_rate_vars()
d1991 1
a1991 2
mged_print_knobvals(interp)
Tcl_Interp *interp;
d2065 1
a2065 5
f_knob(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3253 1
a3253 1
abs_zoom()
d3349 1
a3349 5
f_qvrot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3404 1
a3404 4
path_parse (path)

char	*path;

d3464 1
a3464 5
f_slewview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d3492 1
a3492 1
mged_svbase()
d3516 1
a3516 5
f_svbase(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d3551 1
a3551 5
f_vrot_center(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3577 1
a3577 2
usejoy( xangle, yangle, zangle )
double	xangle, yangle, zangle;
d3604 1
a3604 2
absview_v( ang )
const point_t	ang;
d3675 1
a3675 5
cmd_eye_pt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3687 1
a3687 5
f_model2view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3732 1
a3732 5
f_view2model(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3773 1
a3773 5
f_model2view_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3820 1
a3820 5
f_view2model_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3867 1
a3867 5
f_model2grid_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3922 1
a3922 5
f_grid2model_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d3976 1
a3976 5
f_view2grid_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d4027 1
a4027 5
f_grid2view_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d4076 1
a4076 5
f_view2model_vec(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d4116 1
a4116 5
cmd_lookat(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d4127 1
a4127 3
view_ring_init(vsp1, vsp2)
struct _view_state *vsp1;
struct _view_state *vsp2;
d4597 1
a4597 3
mged_vrot(origin, newrot)
char origin;
mat_t newrot;
@


11.189
log
@use RT_G_DEBUG define, not var
@
text
@d52 1
a52 1
 *	This software is Copyright (C) 1985 by the United States Army.
d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.188 2002/08/20 17:08:21 jra Exp $ (BRL)";
@


11.188
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.186 2002/08/11 02:06:02 morrison Exp $ (BRL)";
d927 1
a927 1
	if (rt_g.debug)
@


11.188.4.1
log
@sync to HEAD...
@
text
@d52 1
a52 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/chgview.c,v 11.190 2004/02/02 17:39:31 morrison Exp $ (BRL)";
d927 1
a927 1
	if (RT_G_DEBUG)
@


11.188.10.1
log
@updates from HEAD
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.189 2003/12/01 16:18:52 morrison Exp $ (BRL)";
d927 1
a927 1
	if (RT_G_DEBUG)
@


11.188.10.2
log
@merge from HEAD
@
text
@d52 1
a52 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.190 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.188.10.3
log
@merge from head
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.188.10.2 2004/02/12 18:34:13 erikg Exp $ (BRL)";
@


11.188.2.1
log
@Initial ANSIfication
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.188 2002/08/20 17:08:21 jra Exp $ (BRL)";
d86 13
a98 13
extern void color_soltab(void);
extern void set_absolute_tran(void); /* defined in set.c */
extern void set_absolute_view_tran(void); /* defined in set.c */
extern void set_absolute_model_tran(void); /* defined in set.c */

void solid_list_callback(void);
void knob_update_rate_vars(void);
int mged_svbase(void);
int mged_vrot(char origin, fastf_t *newrot);
int mged_zoom(double val);
void mged_center(fastf_t *center);
static void abs_zoom(void);
void usejoy(double xangle, double yangle, double zangle);
d101 1
a101 1
int knob_tran(fastf_t *tvec, int model_flag, int view_flag, int edit_flag);
d103 4
a106 4
int mged_mtran(const fastf_t *tvec);
int mged_otran(const fastf_t *tvec);
int mged_vtran(const fastf_t *tvec);
int mged_tran(fastf_t *tvec);
d346 1
a346 1
size_reset(void)
d628 1
a628 1
solid_list_callback(void)
d669 5
a673 1
f_regdebug(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d852 4
a855 1
do_list(struct bu_vls *outstrp, register struct directory *dp, int verbose)
d885 1
a885 1
mged_freemem(void)
d937 5
a941 1
f_status(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1050 5
a1054 1
f_view(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1366 5
a1370 1
f_refresh(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1484 2
a1485 2
eraseobjall(register struct directory **dpp)
                                     	/* this is a partial path spec. XXX should be db_full_path? */
d1539 2
a1540 2
eraseobj(register struct directory **dpp)
                                     	/* this is a partial path spec. XXX should be db_full_path? */
d1598 3
a1600 3
pr_schain(struct solid *startp, int lvl)
                     
   		    			/* debug level */
d1687 1
a1687 1
static char ** path_parse (char *path);
d1691 5
a1695 1
f_ill(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1928 1
a1928 1
check_nonzero_rates(void)
d2007 1
a2007 1
knob_update_rate_vars(void)
d2014 2
a2015 1
mged_print_knobvals(Tcl_Interp *interp)
d2089 5
a2093 1
f_knob(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3281 1
a3281 1
abs_zoom(void)
d3377 5
a3381 1
f_qvrot(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3436 4
a3439 1
path_parse (char *path)
d3499 5
a3503 1
f_slewview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3531 1
a3531 1
mged_svbase(void)
d3555 5
a3559 1
f_svbase(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3594 5
a3598 1
f_vrot_center(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3624 2
a3625 1
usejoy(double xangle, double yangle, double zangle)
d3652 2
a3653 1
absview_v(const fastf_t *ang)
d3724 5
a3728 1
cmd_eye_pt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3740 5
a3744 1
f_model2view(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3789 5
a3793 1
f_view2model(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3834 5
a3838 1
f_model2view_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3885 5
a3889 1
f_view2model_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3936 5
a3940 1
f_model2grid_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3995 5
a3999 1
f_grid2model_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4053 5
a4057 1
f_view2grid_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4108 5
a4112 1
f_grid2view_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4161 5
a4165 1
f_view2model_vec(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4205 5
a4209 1
cmd_lookat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4220 3
a4222 1
view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2)
d4692 3
a4694 1
mged_vrot(char origin, fastf_t *newrot)
@


11.188.2.2
log
@sync branch with HEAD
@
text
@d52 1
a52 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d56 1
a56 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d920 1
a920 1
	if (RT_G_DEBUG)
@


11.187
log
@Converted from K&R to ANSI C - RFH
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.185 2002/02/27 20:43:07 jra Exp $ (BRL)";
d86 13
a98 13
extern void color_soltab(void);
extern void set_absolute_tran(void); /* defined in set.c */
extern void set_absolute_view_tran(void); /* defined in set.c */
extern void set_absolute_model_tran(void); /* defined in set.c */

void solid_list_callback(void);
void knob_update_rate_vars(void);
int mged_svbase(void);
int mged_vrot(char origin, fastf_t *newrot);
int mged_zoom(double val);
void mged_center(fastf_t *center);
static void abs_zoom(void);
void usejoy(double xangle, double yangle, double zangle);
d101 1
a101 1
int knob_tran(fastf_t *tvec, int model_flag, int view_flag, int edit_flag);
d103 4
a106 4
int mged_mtran(const fastf_t *tvec);
int mged_otran(const fastf_t *tvec);
int mged_vtran(const fastf_t *tvec);
int mged_tran(fastf_t *tvec);
d346 1
a346 1
size_reset(void)
d628 1
a628 1
solid_list_callback(void)
d669 5
a673 1
f_regdebug(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d852 4
a855 1
do_list(struct bu_vls *outstrp, register struct directory *dp, int verbose)
d885 1
a885 1
mged_freemem(void)
d937 5
a941 1
f_status(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1050 5
a1054 1
f_view(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1366 5
a1370 1
f_refresh(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1484 2
a1485 2
eraseobjall(register struct directory **dpp)
                                     	/* this is a partial path spec. XXX should be db_full_path? */
d1539 2
a1540 2
eraseobj(register struct directory **dpp)
                                     	/* this is a partial path spec. XXX should be db_full_path? */
d1598 3
a1600 3
pr_schain(struct solid *startp, int lvl)
                     
   		    			/* debug level */
d1687 1
a1687 1
static char ** path_parse (char *path);
d1691 5
a1695 1
f_ill(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1928 1
a1928 1
check_nonzero_rates(void)
d2007 1
a2007 1
knob_update_rate_vars(void)
d2014 2
a2015 1
mged_print_knobvals(Tcl_Interp *interp)
d2089 5
a2093 1
f_knob(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3281 1
a3281 1
abs_zoom(void)
d3357 1
a3357 1
 *			F _ O R I E N T A T I O N
d3377 5
a3381 1
f_qvrot(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3436 4
a3439 1
path_parse (char *path)
d3499 5
a3503 1
f_slewview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3531 1
a3531 1
mged_svbase(void)
d3555 5
a3559 1
f_svbase(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3594 5
a3598 1
f_vrot_center(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3624 2
a3625 1
usejoy(double xangle, double yangle, double zangle)
d3652 2
a3653 1
absview_v(const fastf_t *ang)
d3724 5
a3728 1
cmd_eye_pt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3740 5
a3744 1
f_model2view(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3789 5
a3793 1
f_view2model(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3834 5
a3838 1
f_model2view_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3885 5
a3889 1
f_view2model_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3936 5
a3940 1
f_model2grid_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d3995 5
a3999 1
f_grid2model_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4053 5
a4057 1
f_view2grid_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4108 5
a4112 1
f_grid2view_lu(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4161 5
a4165 1
f_view2model_vec(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4205 5
a4209 1
cmd_lookat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d4220 3
a4222 1
view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2)
d4692 3
a4694 1
mged_vrot(char origin, fastf_t *newrot)
@


11.186
log
@updated comment header to reflect currect function name
@
text
@d86 13
a98 13
extern void color_soltab();
extern void set_absolute_tran(); /* defined in set.c */
extern void set_absolute_view_tran(); /* defined in set.c */
extern void set_absolute_model_tran(); /* defined in set.c */

void solid_list_callback();
void knob_update_rate_vars();
int mged_svbase();
int mged_vrot();
int mged_zoom();
void mged_center();
static void abs_zoom();
void usejoy();
d101 1
a101 1
int knob_tran();
d103 4
a106 4
int mged_mtran();
int mged_otran();
int mged_vtran();
int mged_tran();
d346 1
a346 1
size_reset()
d628 1
a628 1
solid_list_callback()
d669 1
a669 5
f_regdebug(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d848 1
a848 4
do_list( outstrp, dp, verbose )
struct bu_vls	*outstrp;
register struct directory *dp;
int	verbose;
d878 1
a878 1
mged_freemem()
d930 1
a930 5
f_status(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1039 1
a1039 5
f_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1351 1
a1351 5
f_refresh(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1465 2
a1466 2
eraseobjall(dpp)
     register struct directory **dpp;	/* this is a partial path spec. XXX should be db_full_path? */
d1520 2
a1521 2
eraseobj(dpp)
     register struct directory **dpp;	/* this is a partial path spec. XXX should be db_full_path? */
d1579 3
a1581 3
pr_schain( startp, lvl )
struct solid *startp;
int		lvl;			/* debug level */
d1668 1
a1668 1
static char ** path_parse ();
d1672 1
a1672 5
f_ill(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1905 1
a1905 1
check_nonzero_rates()
d1984 1
a1984 1
knob_update_rate_vars()
d1991 1
a1991 2
mged_print_knobvals(interp)
Tcl_Interp *interp;
d2065 1
a2065 5
f_knob(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3253 1
a3253 1
abs_zoom()
d3329 1
a3329 1
 *			C M D _ O R I E N T A T I O N
d3349 1
a3349 5
f_qvrot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3404 1
a3404 4
path_parse (path)

char	*path;

d3464 1
a3464 5
f_slewview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d3492 1
a3492 1
mged_svbase()
d3516 1
a3516 5
f_svbase(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d3551 1
a3551 5
f_vrot_center(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3577 1
a3577 2
usejoy( xangle, yangle, zangle )
double	xangle, yangle, zangle;
d3604 1
a3604 2
absview_v( ang )
const point_t	ang;
d3675 1
a3675 5
cmd_eye_pt(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3687 1
a3687 5
f_model2view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3732 1
a3732 5
f_view2model(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3773 1
a3773 5
f_model2view_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3820 1
a3820 5
f_view2model_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3867 1
a3867 5
f_model2grid_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3922 1
a3922 5
f_grid2model_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d3976 1
a3976 5
f_view2grid_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d4027 1
a4027 5
f_grid2view_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d4076 1
a4076 5
f_view2model_vec(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d4116 1
a4116 5
cmd_lookat(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d4127 1
a4127 3
view_ring_init(vsp1, vsp2)
struct _view_state *vsp1;
struct _view_state *vsp2;
d4597 1
a4597 3
mged_vrot(origin, newrot)
char origin;
mat_t newrot;
@


11.185
log
@"em" command now passes its options on to the "e" command
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.184 2002/02/25 21:10:54 jra Exp $ (BRL)";
d3357 1
a3357 1
 *			F _ O R I E N T A T I O N
@


11.184
log
@"e" and "B" commands now honor "-A" and "-o" options for attributes
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.183 2002/02/22 16:09:43 jra Exp $ (BRL)";
d517 1
d531 8
d557 4
a560 2
	objs = (char **)bu_calloc( (BU_PTBL_LEN( tbl ) + 1), sizeof( char *), "emuves_com objs" );
	objs[0] = "e";
d565 1
a565 1
		objs[i+1] = dp->d_namep;
@


11.183
log
@Added "em" command
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.182 2001/12/13 17:42:26 bparker Exp $ (BRL)";
d355 1
a355 1
 * B, e, and E commands use this area as common
d368 5
d378 100
a477 2
	if ((ret = dgo_draw_cmd(dgop, interp, argc, argv, kind)) != TCL_OK)
		return ret;
@


11.182
log
@*- formatted f_view_ring to be more readable
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.181 2001/12/12 18:51:16 bparker Exp $ (BRL)";
d404 55
@


11.181
log
@*- delete eraseobjpath
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.180 2001/11/09 20:40:03 bparker Exp $ (BRL)";
d4119 4
a4122 5
f_view_ring(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d4124 30
a4153 4
  int n;
  struct view_ring *vrp;
  struct view_ring *lv;
  struct bu_vls vls;
d4155 4
a4158 7
  if(argc < 2 || 3 < argc){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel view_ring");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d4160 2
a4161 8
  if(!strcmp(argv[1],"add")){
    if(argc != 2){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help view_ring");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d4163 3
a4165 2
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);
d4167 2
a4168 2
    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);
d4170 8
a4177 2
    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;
d4179 4
a4182 11
    /* allocate memory and append to list */
    BU_GETSTRUCT(vrp, view_ring);
    lv = BU_LIST_LAST(view_ring, &view_state->vs_headView.l);
    BU_LIST_APPEND(&lv->l, &vrp->l);

    /* assign a view number */
    vrp->vr_id = lv->vr_id + 1;

    view_state->vs_last_view = view_state->vs_current_view;
    view_state->vs_current_view = vrp;
    (void)mged_svbase();
d4184 2
a4185 2
    return TCL_OK;
  }
d4187 2
a4188 8
  if(!strcmp(argv[1],"next")){
    if(argc != 2){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help view_ring");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d4190 2
a4191 4
    /* check to see if this is the last view in the list */
    if(BU_LIST_IS_HEAD(view_state->vs_current_view->l.forw, &view_state->vs_headView.l) &&
       BU_LIST_IS_HEAD(view_state->vs_current_view->l.back, &view_state->vs_headView.l))
      return TCL_OK;
d4193 2
a4194 2
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);
d4196 2
a4197 2
    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);
d4199 3
a4201 2
    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;
d4203 2
a4204 2
    view_state->vs_last_view = view_state->vs_current_view;
    view_state->vs_current_view = BU_LIST_PNEXT(view_ring, view_state->vs_current_view);
d4206 2
a4207 2
    if(BU_LIST_IS_HEAD(view_state->vs_current_view, &view_state->vs_headView.l))
      view_state->vs_current_view = BU_LIST_FIRST(view_ring, &view_state->vs_headView.l);
d4209 8
a4216 3
    MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
    MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;
d4218 4
a4221 2
    new_mats();
    (void)mged_svbase();
d4223 2
a4224 2
    return TCL_OK;
  }
d4226 2
a4227 8
  if(!strcmp(argv[1],"prev")){
    if(argc != 2){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help view_ring");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d4229 2
a4230 4
    /* check to see if this is the last view in the list */
    if(BU_LIST_IS_HEAD(view_state->vs_current_view->l.forw, &view_state->vs_headView.l) &&
       BU_LIST_IS_HEAD(view_state->vs_current_view->l.back, &view_state->vs_headView.l))
      return TCL_OK;
d4232 2
a4233 2
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);
d4235 2
a4236 2
    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);
d4238 3
a4240 2
    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;
d4242 2
a4243 2
    view_state->vs_last_view = view_state->vs_current_view;
    view_state->vs_current_view = BU_LIST_PLAST(view_ring, view_state->vs_current_view);
d4245 2
a4246 2
    if(BU_LIST_IS_HEAD(view_state->vs_current_view, &view_state->vs_headView.l))
      view_state->vs_current_view = BU_LIST_LAST(view_ring, &view_state->vs_headView.l);
d4248 2
a4249 3
    MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
    MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;
d4251 7
a4257 2
    new_mats();
    (void)mged_svbase();
d4259 2
a4260 2
    return TCL_OK;
  }
d4262 2
a4263 2
  if(!strcmp(argv[1],"toggle")){
    struct view_ring *save_last_view;
d4265 2
a4266 7
    if(argc != 2){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help view_ring");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d4268 6
a4273 2
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);
d4275 2
a4276 2
    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);
d4278 2
a4279 2
    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;
d4281 8
a4288 6
    save_last_view = view_state->vs_last_view;
    view_state->vs_last_view = view_state->vs_current_view;
    view_state->vs_current_view = save_last_view;
    MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
    MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;
d4290 6
a4295 2
    new_mats();
    (void)mged_svbase();
d4297 5
a4301 2
    return TCL_OK;
  }
d4303 6
a4308 8
  if(!strcmp(argv[1],"delete")){
    if(argc != 3){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help view_ring");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d4310 14
a4323 6
    /* search for view with id of n */
    n = atoi(argv[2]);
    for(BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)){
      if(vrp->vr_id == n)
	break;
    }
d4325 2
a4326 5
    if(BU_LIST_IS_HEAD(vrp, &view_state->vs_headView.l)){
      Tcl_AppendResult(interp, "view_ring delete: ", argv[2], " is not a valid view\n",
		       (char *)NULL);
      return TCL_ERROR;
    }
d4328 2
a4329 6
    /* check to see if this is the last view in the list */
    if(BU_LIST_IS_HEAD(vrp->l.forw, &view_state->vs_headView.l) &&
       BU_LIST_IS_HEAD(vrp->l.back, &view_state->vs_headView.l)){
      Tcl_AppendResult(interp, "view_ring delete: Cannot delete the only remaining view!\n", (char *)NULL);
      return TCL_ERROR;
    }
d4331 8
a4338 6
    if(vrp == view_state->vs_current_view){
      if(view_state->vs_current_view == view_state->vs_last_view){
	view_state->vs_current_view = BU_LIST_PNEXT(view_ring, view_state->vs_last_view);
	view_state->vs_last_view = view_state->vs_current_view;
      }else
	view_state->vs_current_view = view_state->vs_last_view;
d4340 6
a4345 7
      MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
      MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
      view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;
      new_mats();
      (void)mged_svbase();
    }else if(vrp == view_state->vs_last_view)
      view_state->vs_last_view = view_state->vs_current_view;
d4347 5
a4351 2
    BU_LIST_DEQUEUE(&vrp->l);
    bu_free((genptr_t)vrp, "view_ring delete");
d4353 3
a4355 2
    return TCL_OK;
  }
d4357 2
a4358 8
  if(!strcmp(argv[1],"goto")){
    if(argc != 3){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help view_ring");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d4360 2
a4361 6
    /* search for view with id of n */
    n = atoi(argv[2]);
    for(BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)){
      if(vrp->vr_id == n)
	break;
    }
d4363 2
a4364 5
    if(BU_LIST_IS_HEAD(vrp, &view_state->vs_headView.l)){
      Tcl_AppendResult(interp, "view_ring goto: ", argv[2], " is not a valid view\n",
		       (char *)NULL);
      return TCL_ERROR;
    }
d4366 5
a4370 18
    /* nothing to do */
    if(vrp == view_state->vs_current_view)
      return TCL_OK;

    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_vop->vo_rotation);

    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_vop->vo_center);

    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_vop->vo_scale;

    view_state->vs_last_view = view_state->vs_current_view;
    view_state->vs_current_view = vrp;
    MAT_COPY(view_state->vs_vop->vo_rotation, view_state->vs_current_view->vr_rot_mat);
    MAT_COPY(view_state->vs_vop->vo_center, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_vop->vo_scale = view_state->vs_current_view->vr_scale;
d4372 2
a4373 2
    new_mats();
    (void)mged_svbase();
d4375 2
a4376 2
    return TCL_OK;
  }
d4378 9
a4386 9
  if(!strcmp(argv[1],"get")){
    /* return current view */
    if(argc == 2){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d", view_state->vs_current_view->vr_id);
      Tcl_AppendElement(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_OK;
    }
d4388 7
a4394 7
    if(strcmp("-a", argv[2])){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help view_ring");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d4396 6
a4401 6
    bu_vls_init(&vls);
    for(BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)){
      bu_vls_printf(&vls, "%d", vrp->vr_id);
      Tcl_AppendElement(interp, bu_vls_addr(&vls));
      bu_vls_trunc(&vls, 0);
    }
d4403 3
a4405 3
    bu_vls_free(&vls);
    return TCL_OK;
  }
d4407 2
a4408 2
  Tcl_AppendResult(interp, "view_ring: unrecognized command - ", argv[1], (char *)NULL);
  return TCL_ERROR;
@


11.180
log
@*- added get_autoview command. This command returns
   the view center and size necessary to see all geometry.
   Currently, only mouse_shoot_ray uses this.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.179 2001/11/01 22:01:23 bparker Exp $ (BRL)";
a178 86

void
eraseobjpath(
     Tcl_Interp	*interp,
     int	argc,
     char	**argv,
     int	noisy,
     int	all)
{
	register struct directory *dp;
	register int i;
	struct bu_vls vls;
	Tcl_Obj *save_result;

	save_result = Tcl_GetObjResult(interp);
	Tcl_IncrRefCount(save_result);

	bu_vls_init(&vls);
	for (i = 0; i < argc; i++) {
		int j;
		char *list;
		int ac;
		char **av, **av_orig;
		struct directory **dpp;

#if 0
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "split %s /", argv[i]);
		if (Tcl_Eval(interp, bu_vls_addr(&vls)) != TCL_OK) {
			continue;
		}
		list = Tcl_GetStringResult(interp);
#else
		{
			char *begin;
			char *end;
			char *newstr = strdup(argv[i]);

			begin = newstr;
			bu_vls_trunc(&vls, 0);

			while ((end = strchr(begin, '/')) != NULL) {
				*end = '\0';
				bu_vls_printf(&vls, "%s ", begin);
				begin = end + 1;
			}
			bu_vls_printf(&vls, "%s ", begin);
			free((void *)newstr);
		}
		list = bu_vls_addr(&vls);
#endif
		Tcl_SplitList(interp, list, &ac, &av_orig);

		/* skip first element if empty */
		av = av_orig;
		if (*av[0] == '\0') {
			--ac;
			++av;
		}

		/* ignore last element if empty */
		if (*av[ac-1] == '\0')
			--ac;

		dpp = bu_calloc(ac+1, sizeof(struct directory *), "eraseobjpath: directory pointers");
		for (j = 0; j < ac; ++j)
			if ((dp = db_lookup(dbip, av[j], noisy)) != DIR_NULL)
				dpp[j] = dp;
			else
				goto end;

		dpp[j] = DIR_NULL;

		if (all)
			eraseobjall(dpp);
		else
			eraseobj(dpp);

	end:
		bu_free((genptr_t)dpp, "eraseobjpath: directory pointers");
		Tcl_Free((char *)av_orig);
	}
	bu_vls_free(&vls);
	Tcl_SetObjResult(interp, save_result);
	Tcl_DecrRefCount(save_result);
}
@


11.179
log
@*- add "struct db_i *" parameter to ft_describe function calls
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.178 2001/10/15 20:39:56 bparker Exp $ (BRL)";
d533 9
@


11.178
log
@*- add vop parameter to mged_escale
*- add interp parameter to mged_escale, mged_etran and mged_erot
   (MGED doesn't use it, but other applications might)
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.177 2001/09/19 22:21:43 bparker Exp $ (BRL)";
d780 1
a780 1
	    verbose, base2local, &rt_uniresource ) < 0 )
@


11.177
log
@*- remove old code from cmd_solid_report
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.176 2001/09/18 15:25:38 bparker Exp $ (BRL)";
d102 1
a102 1
int mged_etran(struct view_obj *vop, char coords, vect_t tvec);
d3156 1
a3156 1
		mged_etran(view_state->vs_vop, mged_variables->mv_coords, tvec);
d4491 1
d4581 1
a4581 1
	return mged_erot(view_state->vs_vop, mged_variables->mv_coords, rotate_about, newrot);
d4732 1
d4842 1
a4842 1
    return mged_etran(view_state->vs_vop, mged_variables->mv_coords, tvec);
d4868 3
a4870 2
mged_escale(sfactor)
fastf_t sfactor;
d4991 1
a4991 2
mged_scale(sfactor)
fastf_t sfactor;
d4993 3
a4995 3
  if((state == ST_S_EDIT || state == ST_O_EDIT) &&
    mged_variables->mv_transform == 'e')
    return mged_escale(sfactor);
d4997 1
a4997 1
  return mged_vscale(sfactor);
@


11.176
log
@*- simplify expression
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.175 2001/09/07 18:53:25 bparker Exp $ (BRL)";
d566 2
a567 1
#if 1
a568 26
#else
  int	lvl = 0;
  struct bu_vls vls;

  if(argc < 1 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help x");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if( argc > 1 )  lvl = atoi(argv[1]);

  bu_vls_init(&vls);
  if( 0 <= lvl )
      bu_vls_printf(&vls, "ndrawn=%d\n", ndrawn);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  pr_schain( &HeadSolid, lvl );

  return TCL_OK;
#endif
d4095 1
d4097 1
@


11.175
log
@*- change mged_print_knobvals' return value to TCL_OK
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.174 2001/08/11 13:16:11 butler Exp $ (BRL)";
d1261 1
a1261 1
			bu_vls_printf(&vls, "%.12g", view_state->vs_vop->vo_scale * 2.0 * base2local);
@


11.174
log
@misc compiler warning changes
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.173 2001/06/25 21:27:30 bparker Exp $ (BRL)";
d2017 1
a2017 1
  return TCL_RETURN;
@


11.173
log
@*- removed old code from cmd_zap
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.172 2001/06/18 19:24:23 bparker Exp $ (BRL)";
a451 1
	double		elapsed_time;
a453 1
	struct bu_vls vls;
d659 1
a659 1
		sscanf( argv[1], "%x", &bu_debug );
d696 1
a696 1
		sscanf(argv[1], "%x", &rt_g.debug);
d767 1
a767 1
		sscanf(argv[1], "%x", &rt_g.NMG_debug);
@


11.172
log
@*- remove use of start/stop_catching_output().
   Use routines that write directly to a vls.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.171 2001/06/05 15:51:40 bparker Exp $ (BRL)";
d840 4
a843 5
cmd_zap(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
a844 1
#if 1
a859 49
	(void)chg_state(state, state, "zap");
	solid_list_callback();

	return TCL_OK;
#else
	register struct solid *sp;
	register struct solid *nsp;
	struct directory	*dp;

	CHECK_DBI_NULL;

	if(argc < 1 || 1 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help Z");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	update_views = 1;

	/* FIRST, reject any editing in progress */
	if( state != ST_VIEW )
		button( BE_REJECT );

#ifdef DO_DISPLAY_LISTS
	freeDListsAll(BU_LIST_FIRST(solid, &dgop->dgo_headSolid)->s_dlist,
		      BU_LIST_LAST(solid, &dgop->dgo_headSolid)->s_dlist -
		      BU_LIST_FIRST(solid, &dgop->dgo_headSolid)->s_dlist + 1);
#endif

	sp = BU_LIST_NEXT(solid, &dgop->dgo_headSolid);
	while(BU_LIST_NOT_HEAD(sp, &dgop->dgo_headSolid)){
		dp = FIRST_SOLID(sp);
		RT_CK_DIR(dp);
		if( dp->d_addr == RT_DIR_PHONY_ADDR )  {
			if( db_dirdelete( dbip, dp ) < 0 )  {
			  Tcl_AppendResult(interp, "f_zap: db_dirdelete failed\n", (char *)NULL);
			}
		}

		nsp = BU_LIST_PNEXT(solid, sp);
		BU_LIST_DEQUEUE(&sp->l);
		FREE_SOLID(sp,&FreeSolid.l);
		sp = nsp;
	}

d862 2
a863 1
	if( RT_G_DEBUG )  mged_freemem();
d865 2
a866 1
	(void)chg_state( state, state, "zap" );
a867 1
	solid_list_callback();
a868 1
#endif
@


11.171
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.170 2001/06/01 19:23:23 bparker Exp $ (BRL)";
d643 4
a646 5
f_debugbu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d648 1
a648 1
  struct bu_vls vls;
d650 1
a650 2
  if(argc < 1 || 2 < argc){
    struct bu_vls vls;
d652 6
a657 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help debugbu");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
a658 2
  bu_vls_init(&vls);
  start_catching_output(&vls);
d660 8
a667 8
  if( argc >= 2 )  {
    sscanf( argv[1], "%x", &bu_debug );
  } else {
    bu_printb( "Possible flags", 0xffffffffL, BU_DEBUG_FORMAT );
    bu_log("\n");
  }
  bu_printb( "bu_debug", bu_debug, BU_DEBUG_FORMAT );
  bu_log("\n");
d669 2
a670 3
  stop_catching_output(&vls);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
d672 1
a672 1
  return TCL_OK;
d681 4
a684 5
f_debuglib(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d686 1
a686 1
  struct bu_vls vls;
d688 1
a688 2
  if(argc < 1 || 2 < argc){
    struct bu_vls vls;
d690 6
a695 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help debuglib");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d697 9
a705 2
  bu_vls_init(&vls);
  start_catching_output(&vls);
d707 2
a708 9
  if( argc >= 2 )  {
    sscanf( argv[1], "%x", &rt_g.debug );
    if( RT_G_DEBUG )  bu_debug |= BU_DEBUG_COREDUMP;
  } else {
    bu_printb( "Possible flags", 0xffffffffL, DEBUG_FORMAT );
    bu_log("\n");
  }
  bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
  bu_log("\n");
d710 1
a710 5
  stop_catching_output(&vls);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
d720 4
a723 5
f_debugmem(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d725 2
a726 2
  if(argc < 1 || 1 < argc){
    struct bu_vls vls;
d728 6
a733 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help debugmem");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d735 4
a738 4
  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3 );	/* allow interupts */
  else
    return TCL_OK;
d740 1
a740 1
  bu_prmem("Invoked via MGED command");
d742 2
a743 2
  (void)signal(SIGINT, SIG_IGN);
  return TCL_OK;
d752 4
a755 5
f_debugnmg(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d757 1
a757 1
  struct bu_vls vls;
d759 1
a759 2
  if(argc < 1 || 2 < argc){
    struct bu_vls vls;
d761 6
a766 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help debugnmg");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d768 8
a775 2
  bu_vls_init(&vls);
  start_catching_output(&vls);
d777 2
a778 8
  if( argc >= 2 )  {
    sscanf( argv[1], "%x", &rt_g.NMG_debug );
  } else {
    bu_printb( "possible flags", 0xffffffffL, NMG_DEBUG_FORMAT );
    bu_log("\n");
  }
  bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
  bu_log("\n");
d780 1
a780 5
  stop_catching_output(&vls);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
@


11.170
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.169 2001/05/17 20:05:34 morrison Exp $ (BRL)";
d343 4
a346 5
f_center(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
a347 1
#ifdef MGED_USE_VIEW_OBJ
a355 36
#else
  struct bu_vls str;
  point_t center;

  CHECK_DBI_NULL;

  if(argc != 1 && argc != 4){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help center");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(argc == 4)  {
	/* Set center.  Value is in local units */
	VSET(center, atof(argv[1]), atof(argv[2]), atof(argv[3]));

	/* must convert to base units */
	VSCALE(center, center, local2base);
	mged_center(center);
  }

  /* Whether set or not, print current center in local units */
  MAT_DELTAS_GET_NEG(center, view_state->vs_toViewcenter);
  VSCALE(center, center, base2local);

  bu_vls_init(&str);
  bu_vls_printf(&str, "%f %f %f\n", V3ARGS(center));
  Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
  bu_vls_free(&str);

  return TCL_OK;
#endif
a360 1
#ifdef MGED_USE_VIEW_OBJ
a361 5
#else
	MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, center);
	new_mats();
#endif

d368 4
a371 5
f_size(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
a372 1
#ifdef MGED_USE_VIEW_OBJ
a388 31
#else
  fastf_t f;

  CHECK_DBI_NULL;

  if(argc < 2 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help size");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  f = atof( argv[1] );
  if( f < 0.0001 ) f = 0.0001;
  view_state->vs_Viewscale = f * 0.5 * local2base;
  new_mats();

  view_state->vs_absolute_scale = 1.0 - view_state->vs_Viewscale / view_state->vs_i_Viewscale;
  if(view_state->vs_absolute_scale < 0.0)
    view_state->vs_absolute_scale /= 9.0;

  if(view_state->vs_absolute_tran[X] != 0.0 ||
     view_state->vs_absolute_tran[Y] != 0.0 ||
     view_state->vs_absolute_tran[Z] != 0.0)
    set_absolute_tran();

  return TCL_OK;
#endif
a433 1
#if 1
a435 53
#else
	register struct solid	*sp;
	vect_t		min, max;
	vect_t		minus, plus;
	vect_t		center;
	vect_t		radial;

	VSETALL( min,  INFINITY );
	VSETALL( max, -INFINITY );

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		minus[X] = sp->s_center[X] - sp->s_size;
		minus[Y] = sp->s_center[Y] - sp->s_size;
		minus[Z] = sp->s_center[Z] - sp->s_size;
		VMIN( min, minus );
		plus[X] = sp->s_center[X] + sp->s_size;
		plus[Y] = sp->s_center[Y] + sp->s_size;
		plus[Z] = sp->s_center[Z] + sp->s_size;
		VMAX( max, plus );
	}

	if(BU_LIST_IS_EMPTY(&dgop->dgo_headSolid)) {
		/* Nothing is in view */
		VSETALL( center, 0.0 );
		VSETALL( radial, 1000.0 );	/* 1 meter */
	} else {
		VADD2SCALE( center, max, min, 0.5 );
		VSUB2( radial, max, center );
	}

	if( VNEAR_ZERO( radial , SQRT_SMALL_FASTF ) )
		VSETALL( radial , 1.0 );

#ifdef MGED_USE_VIEW_OBJ
	MAT_IDN(view_state->vs_vop->vo_center);
	MAT_DELTAS(view_state->vs_vop->vo_center, -center[X], -center[Y], -center[Z]);
	view_state->vs_vop->vo_scale = radial[X];
	V_MAX(view_state->vs_vop->vo_scale, radial[Y]);
	V_MAX(view_state->vs_vop->vo_scale, radial[Z]);

	view_state->vs_i_Viewscale = view_state->vs_vop->vo_scale;
	view_state->vs_vop->vo_size = 2.0 * view_state->vs_vop->vo_scale;
 	view_state->vs_vop->vo_invSize = 1.0 / view_state->vs_vop->vo_size;
#else
	MAT_IDN( view_state->vs_toViewcenter );
	MAT_DELTAS( view_state->vs_toViewcenter, -center[X], -center[Y], -center[Z] );
	view_state->vs_Viewscale = radial[X];
	V_MAX( view_state->vs_Viewscale, radial[Y] );
	V_MAX( view_state->vs_Viewscale, radial[Z] );

	view_state->vs_i_Viewscale = view_state->vs_Viewscale;
#endif
#endif
a458 1
#if 1
a479 1
#if 1
a480 58
#else
			size_reset();
			new_mats();
#endif
			(void)mged_svbase();

			for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
#ifdef MGED_USE_VIEW_OBJ
				vrp->vr_scale = view_state->vs_vop->vo_scale;
#else
				vrp->vr_scale = view_state->vs_Viewscale;
#endif
		}
	}

	curr_dm_list = save_dmlp;
	curr_cmd_list = save_cmd_list;

	return TCL_OK;
#else
	bu_vls_init(&vls);
	initial_blank_screen = BU_LIST_IS_EMPTY(&dgop->dgo_headSolid);

	/*  First, delete any mention of these objects.
	 *  Silently skip any leading options (which start with minus signs).
	 */
	eraseobjpath(interp, argc-1, argv+1, LOOKUP_QUIET, 0);

	update_views = 1;

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);	/* allow interupts */
	else {
		bu_vls_free(&vls);
		return TCL_OK;
	}

	nvectors = 0;
	rt_prep_timer();
	drawtrees(argc, argv, kind);
	(void)rt_get_timer((struct bu_vls *)0, &elapsed_time);

	save_dmlp = curr_dm_list;
	save_cmd_list = curr_cmd_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
		curr_dm_list = dmlp;
		if (curr_dm_list->dml_tie)
			curr_cmd_list = curr_dm_list->dml_tie;
		else
			curr_cmd_list = &head_cmd_list;

		/* If we went from blank screen to non-blank, resize */
		if (mged_variables->mv_autosize  && initial_blank_screen &&
		    BU_LIST_NON_EMPTY(&dgop->dgo_headSolid)) {
			struct view_ring *vrp;

			size_reset();
			new_mats();
a483 1
#ifdef MGED_USE_VIEW_OBJ
a484 3
#else
				vrp->vr_scale = view_state->vs_Viewscale;
#endif
a487 1
	color_soltab();
a490 6
	bu_vls_printf(&vls, "%ld vectors in %g sec\n", nvectors, elapsed_time);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

	bu_vls_free(&vls);
	(void)signal(SIGINT, SIG_IGN);
	solid_list_callback();
a491 1
#endif
d525 1
a525 6
#if 1
			dgo_autoview(dgop, view_state->vs_vop, interp);
#else
		size_reset();
		new_mats();
#endif
a528 1
#ifdef MGED_USE_VIEW_OBJ
a529 3
#else
			vrp->vr_scale = view_state->vs_Viewscale;
#endif
a946 1
#ifdef MGED_USE_VIEW_OBJ
a1050 137
#else
  struct bu_vls vls;

  CHECK_DBI_NULL;

  if(argc < 1 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help status");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(argc == 1) {
    bu_vls_init(&vls);
    start_catching_output(&vls);
		   
    bu_log("STATE=%s, ", state_str[state] );
    bu_log("Viewscale=%f (%f mm)\n", view_state->vs_Viewscale*base2local, view_state->vs_Viewscale);
    bu_log("base2local=%f\n", base2local);
    bn_mat_print("toViewcenter", view_state->vs_toViewcenter);
    bn_mat_print("Viewrot", view_state->vs_Viewrot);
    bn_mat_print("model2view", view_state->vs_model2view);
    bn_mat_print("view2model", view_state->vs_view2model);

    if( state != ST_VIEW )  {
      bn_mat_print("model2objview", view_state->vs_model2objview);
      bn_mat_print("objview2model", view_state->vs_objview2model);
    }

    stop_catching_output(&vls);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "state")){
    Tcl_AppendResult(interp, state_str[state], (char *)NULL);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "Viewscale")){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%f", view_state->vs_Viewscale*base2local);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "base2local")){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%f", base2local);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "local2base")){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%f", local2base);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "toViewcenter")){
    bu_vls_init(&vls);
    start_catching_output(&vls);
    bn_mat_print("toViewcenter", view_state->vs_toViewcenter);
    stop_catching_output(&vls);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "Viewrot")){
    bu_vls_init(&vls);
    start_catching_output(&vls);
    bn_mat_print("Viewrot", view_state->vs_Viewrot);
    stop_catching_output(&vls);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "model2view")){
    bu_vls_init(&vls);
    start_catching_output(&vls);
    bn_mat_print("model2view", view_state->vs_model2view);
    stop_catching_output(&vls);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "view2model")){
    bu_vls_init(&vls);
    start_catching_output(&vls);
    bn_mat_print("view2model", view_state->vs_view2model);
    stop_catching_output(&vls);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "model2objview")){
    bu_vls_init(&vls);
    start_catching_output(&vls);
    bn_mat_print("model2objview", view_state->vs_model2objview);
    stop_catching_output(&vls);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(!strcmp(argv[1], "objview2model")){
    bu_vls_init(&vls);
    start_catching_output(&vls);
    bn_mat_print("objview2model", view_state->vs_objview2model);
    stop_catching_output(&vls);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "help status");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  if(!strcmp(argv[1], "help"))
    return TCL_OK;

  return TCL_ERROR;
#endif
a1059 1
#ifdef MGED_USE_VIEW_OBJ
d1367 1
a1367 5
#else
  int n;
  point_t pt;
  mat_t mat;
  struct bu_vls vls;
d1369 9
a1377 1
  CHECK_DBI_NULL;
a1378 1
  if(argc < 1 || 6 < argc){
d1380 1
a1380 1
    bu_vls_printf(&vls, "help view");
a1382 1

d1386 16
a1401 5
  if(argc == 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
d1403 4
a1406 2
    return TCL_OK;
  }
d1408 7
a1414 2
  if(!strcmp(argv[1], "quat")){
    quat_t quat;
d1416 1
a1416 3
    /* return Viewrot as a quaternion */
    if(argc == 2){
      quat_mat2quat(quat, view_state->vs_Viewrot);
d1418 4
a1421 4
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.12g %.12g %.12g %.12g", V4ARGS(quat));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
d1423 2
a1424 2
      return TCL_OK;
    }
d1426 1
a1426 363
    if(argc != 6){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view: quat requires four parameters");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    /* attempt to set Viewrot given a quaternion */
    n = sscanf(argv[2], "%lf", quat);
    n += sscanf(argv[3], "%lf", quat+1);
    n += sscanf(argv[4], "%lf", quat+2);
    n += sscanf(argv[5], "%lf", quat+3);

    if(n < 4){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view quat: bad value detected - %s %s %s %s",
		    argv[2], argv[3], argv[4], argv[5]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    quat_quat2mat(view_state->vs_Viewrot, quat);
    new_mats();

    return TCL_OK;
  }

  if(!strcmp(argv[1], "ypr")){
    vect_t ypr;

    /* return Viewrot as yaw, pitch and roll */
    if(argc == 2){
      bn_mat_trn(mat, view_state->vs_Viewrot);
      anim_v_unpermute(mat);
      n = anim_mat2ypr(pt, mat);
      if(n == 2){
	Tcl_AppendResult(interp, "mat2ypr - matrix is not a rotation matrix", (char *)NULL);
	return TCL_ERROR;
      }
      VSCALE(pt, pt, bn_radtodeg);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.12g %.12g %.12g", V3ARGS(pt));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }

    if(argc != 5){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view: ypr requires 3 parameters");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    /* attempt to set Viewrot given yaw, pitch and roll */
    n = sscanf(argv[2], "%lf", ypr);
    n += sscanf(argv[3], "%lf", ypr+1);
    n += sscanf(argv[4], "%lf", ypr+2);

    if(n < 3){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view ypr: bad value detected - %s %s %s",
		    argv[2], argv[3], argv[4]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    anim_dy_p_r2mat(mat, V3ARGS(ypr));
    anim_v_permute(mat);
    bn_mat_trn(view_state->vs_Viewrot, mat);
    new_mats();

    return TCL_OK;
  }

  if(!strcmp(argv[1], "aet")){
    vect_t aet;

    /* return Viewrot as azimuth, elevation and twist */
    if(argc == 2){
      bn_mat_trn(mat, view_state->vs_Viewrot);
      anim_v_unpermute(mat);
      n = anim_mat2ypr(pt, mat);
      if(n == 2){
	Tcl_AppendResult(interp, "mat2ypr - matrix is not a rotation matrix", (char *)NULL);
	return TCL_ERROR;
      }
      VSCALE(pt, pt, bn_radtodeg);
      if(pt[0] >= 180.0 )
	pt[0] -= 180;
      if(pt[0] < 180.0 )
	pt[0] += 180;
      pt[1] = -pt[1];
      pt[2] = -pt[2];

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.12g %.12g %.12g", V3ARGS(pt));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }

    if(argc != 5){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view: aet requires 3 parameters");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    /* attempt to set Viewrot given azimuth, elevation and twist */
    n = sscanf(argv[2], "%lf", aet);
    n += sscanf(argv[3], "%lf", aet+1);
    n += sscanf(argv[4], "%lf", aet+2);

    if(n < 3){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view aet: bad value detected - %s %s %s",
		    argv[2], argv[3], argv[4]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    anim_dy_p_r2mat(mat, aet[0]+180.0, -aet[1], -aet[2]);
    anim_v_permute(mat);
    bn_mat_trn(view_state->vs_Viewrot, mat);
    new_mats();

    return TCL_OK;
  }

  if(!strcmp(argv[1], "center")){
    point_t center;

    /* return view center */
    if(argc == 2){
      MAT_DELTAS_GET_NEG(center, view_state->vs_toViewcenter);
      VSCALE(center, center, base2local);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.12g %.12g %.12g", V3ARGS(center));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
      return TCL_OK;
    }

    if(argc != 5){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view: center requires 3 parameters");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    /* attempt to set the view center */
    n = sscanf(argv[2], "%lf", center);
    n += sscanf(argv[3], "%lf", center+1);
    n += sscanf(argv[4], "%lf", center+2);

    if(n < 3){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view center: bad value detected - %s %s %s",
		    argv[2], argv[3], argv[4]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    VSCALE(center, center, local2base);
    MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, center);
    new_mats();

    return TCL_OK;
  }

  if(!strcmp(argv[1], "eye")){
    point_t eye;
    vect_t dir;

    /* return the eye point */
    if(argc == 2){
      VSET(pt, 0.0, 0.0, 1.0);
      MAT4X3PNT(eye, view_state->vs_view2model, pt);
      VSCALE(eye, eye, base2local);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.12g %.12g %.12g", V3ARGS(eye));
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }

    if(argc != 5){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view: eye requires 3 parameters");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    /* attempt to set view center given the eye point */
    n = sscanf(argv[2], "%lf", eye);
    n += sscanf(argv[3], "%lf", eye+1);
    n += sscanf(argv[4], "%lf", eye+2);

    if(n < 3){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view eye: bad value detected - %s %s %s",
		    argv[2], argv[3], argv[4]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    VSCALE(eye, eye, local2base);
    VSET(pt, 0.0, 0.0, view_state->vs_Viewscale);
    bn_mat_trn(mat, view_state->vs_Viewrot);
    MAT4X3PNT(dir, mat, pt);
    VSUB2(pt, dir, eye);
    MAT_DELTAS_VEC(view_state->vs_toViewcenter, pt);
    new_mats();

    return TCL_OK;
  }

  if(!strcmp(argv[1], "size")){
    fastf_t size;

    /* return the view size */
    if(argc == 2){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%.12g", view_state->vs_Viewscale * 2.0 * base2local);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }

    if(argc != 3){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view: size requires 1 parameter");
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    /* attempt to set view size */
    n = sscanf(argv[2], "%lf", &size);

    if(n < 1){
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "view size: bad value detected - %s", argv[2]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_ERROR;
    }

    size *= local2base;
    if(size < 0.0001)
      size = 0.0001;
    view_state->vs_Viewscale = size * 0.5;
    new_mats();

    return TCL_OK;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "help view");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
#endif
}

int
f_refresh(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help refresh");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  view_state->vs_flag = 1;		/* causes refresh() */
  return TCL_OK;
}

int
mged_aetview(iflag, azim, elev, twist)
int iflag;
fastf_t azim, elev, twist;
{
  int status = TCL_OK;
  fastf_t o_twist;
  fastf_t o_arz;
  fastf_t o_larz;
  struct bu_vls vls;

  /* grab old twist angle before it's lost */
#ifdef MGED_USE_VIEW_OBJ
  o_twist = view_state->vs_vop->vo_aet[BN_TWIST];
#else
  o_twist = view_state->vs_twist;
#endif
  o_arz = view_state->vs_absolute_rotate[Z];
  o_larz = view_state->vs_last_absolute_rotate[Z];

  /* set view using azimuth and elevation angles */
#ifdef MGED_USE_VIEW_OBJ
  if(iflag)
    setview(270.0 + elev + view_state->vs_vop->vo_aet[BN_ELEVATION],
	    0.0,
	    270.0 - azim - view_state->vs_vop->vo_aet[BN_AZIMUTH]);
  else
    setview(270.0 + elev, 0.0, 270.0 - azim );
#else
  if(iflag)
	  setview(270.0 + elev + view_state->vs_elevation,
		  0.0,
		  270.0 - azim - view_state->vs_azimuth);
  else
	  setview(270.0 + elev, 0.0, 270.0 - azim);
#endif

  bu_vls_init(&vls);

  if(iflag)
    bu_vls_printf(&vls, "knob -i -v az %f", -o_twist - twist);
  else
    bu_vls_printf(&vls, "knob -i -v az %f", -twist);

  status = Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  view_state->vs_absolute_rotate[Z] = o_arz;
d1431 1
d1435 4
a1438 5
f_aetview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1440 3
d1477 1
a1715 17
#if 0
	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help ill");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if(!strcmp("-n", argv[1])){
	  illum_only = 1;
	  --argc;
	  ++argv;
	}
#else
a1757 1
#endif
a1892 11
#if 0
  if(argc < 2 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help sed");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
#else
a1901 1
#endif
a2914 1
#ifdef MGED_USE_VIEW_OBJ
a2915 3
#else
      sf = f * local2base / view_state->vs_Viewscale;
#endif
a2946 1
#ifdef MGED_USE_VIEW_OBJ
a2947 3
#else
	    tvec[X] = f - last_edit_absolute_model_tran[X]*view_state->vs_Viewscale*base2local;
#endif
a2952 1
#ifdef MGED_USE_VIEW_OBJ
a2953 3
#else
	    tvec[X] = f - last_edit_absolute_view_tran[X]*view_state->vs_Viewscale*base2local;
#endif
a2959 1
#ifdef MGED_USE_VIEW_OBJ
a2960 3
#else
	  tvec[X] = f - view_state->vs_last_absolute_model_tran[X]*view_state->vs_Viewscale*base2local;
#endif
a2963 1
#ifdef MGED_USE_VIEW_OBJ
a2964 3
#else
	  tvec[X] = f - view_state->vs_last_absolute_tran[X]*view_state->vs_Viewscale*base2local;
#endif
a2973 1
#ifdef MGED_USE_VIEW_OBJ
a2974 3
#else
      sf = f * local2base / view_state->vs_Viewscale;
#endif
a3005 1
#ifdef MGED_USE_VIEW_OBJ
a3006 3
#else
	    tvec[Y] = f - last_edit_absolute_model_tran[Y]*view_state->vs_Viewscale*base2local;
#endif
a3011 1
#ifdef MGED_USE_VIEW_OBJ
a3012 3
#else
	    tvec[Y] = f - last_edit_absolute_view_tran[Y]*view_state->vs_Viewscale*base2local;
#endif
a3018 1
#ifdef MGED_USE_VIEW_OBJ
a3019 3
#else
	  tvec[Y] = f - view_state->vs_last_absolute_model_tran[Y]*view_state->vs_Viewscale*base2local;
#endif
a3022 1
#ifdef MGED_USE_VIEW_OBJ
a3023 3
#else
	  tvec[Y] = f - view_state->vs_last_absolute_tran[Y]*view_state->vs_Viewscale*base2local;
#endif
a3031 1
#ifdef MGED_USE_VIEW_OBJ
a3032 3
#else
      sf = f * local2base / view_state->vs_Viewscale;
#endif
a3063 1
#ifdef MGED_USE_VIEW_OBJ
a3064 3
#else
	    tvec[Z] = f - last_edit_absolute_model_tran[Z]*view_state->vs_Viewscale*base2local;
#endif
a3069 1
#ifdef MGED_USE_VIEW_OBJ
a3070 3
#else
	    tvec[Z] = f - last_edit_absolute_view_tran[Z]*view_state->vs_Viewscale*base2local;
#endif
a3076 1
#ifdef MGED_USE_VIEW_OBJ
a3077 3
#else
	  tvec[Z] = f - view_state->vs_last_absolute_model_tran[Z]*view_state->vs_Viewscale*base2local;
#endif
a3080 1
#ifdef MGED_USE_VIEW_OBJ
a3081 3
#else
	  tvec[Z] = f - view_state->vs_last_absolute_tran[Z]*view_state->vs_Viewscale*base2local;
#endif
a3288 1
#ifdef MGED_USE_VIEW_OBJ
a3289 3
#else
    view_state->vs_Viewscale = view_state->vs_i_Viewscale;
#endif
a3293 1
#ifdef MGED_USE_VIEW_OBJ
a3294 3
#else
      view_state->vs_Viewscale = view_state->vs_i_Viewscale * (1.0 - view_state->vs_absolute_scale);
#endif
a3296 1
#ifdef MGED_USE_VIEW_OBJ
a3297 3
#else
      view_state->vs_Viewscale = view_state->vs_i_Viewscale * (1.0 + (view_state->vs_absolute_scale * -9.0));
#endif
a3299 1
#ifdef MGED_USE_VIEW_OBJ
a3303 6
#else
  if( view_state->vs_Viewscale < MINVIEW )
    view_state->vs_Viewscale = MINVIEW;

  new_mats();
#endif
a3314 1
#ifdef MGED_USE_VIEW_OBJ
a3320 14
#else
	if( val < SMALL_FASTF || val > INFINITY )  {
		Tcl_AppendResult(interp, "zoom: scale factor out of range\n", (char *)NULL);
		return TCL_ERROR;
	}

	view_state->vs_Viewscale /= val;
	if( view_state->vs_Viewscale < MINVIEW )
		view_state->vs_Viewscale = MINVIEW;

	new_mats();

	view_state->vs_absolute_scale = 1.0 - view_state->vs_Viewscale / view_state->vs_i_Viewscale;
#endif
a3371 1
#ifdef MGED_USE_VIEW_OBJ
a3372 21
#else
	register int	i;
	quat_t		quat;

	if (argc != 5) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help orientation");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for (i=0; i<4; i++)
		quat[i] = atof( argv[i+1] );
	quat_quat2mat(view_state->vs_Viewrot, quat);
	new_mats();

	return TCL_OK;
#endif
a3487 1
#if 1
a3499 35
#else
  double x, y, z;

  if(argc < 4 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help setview");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &x) < 1){
    Tcl_AppendResult(interp, "f_setview: bad x value - ",
		     argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &y) < 1){
    Tcl_AppendResult(interp, "f_setview: bad y value - ",
		     argv[2], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%lf", &z) < 1){
    Tcl_AppendResult(interp, "f_setview: bad z value - ",
		     argv[3], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  setview(x, y, z);

  return TCL_OK;
#endif
a3508 1
#if 1
a3529 41
#else
  int x, y, z;
  vect_t slewvec;

  if(argc < 3 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help sv");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%d", &x) < 1){
    Tcl_AppendResult(interp, "f_slewview: bad x value - ",
		     argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%d", &y) < 1){
    Tcl_AppendResult(interp, "f_slewview: bad y value - ",
		     argv[2], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(argc == 4){
    if(sscanf(argv[3], "%d", &z) < 1){
      Tcl_AppendResult(interp, "f_slewview: bad z value - ",
		       argv[3], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else
    z = 0;

  VSET(slewvec, x * INV_GED, y * INV_GED, z * INV_GED);
  VSUB2(view_state->vs_absolute_tran, view_state->vs_absolute_tran, slewvec);
  slewview( slewvec );

  return TCL_OK;
#endif
a3536 1
#ifdef MGED_USE_VIEW_OBJ
a3538 4
#else
	MAT_DELTAS_GET_NEG(view_state->vs_orig_pos, view_state->vs_toViewcenter);
	view_state->vs_i_Viewscale = view_state->vs_Viewscale;
#endif
a3632 10
#if 0
	if( state == ST_S_EDIT )  {
		if( sedit_rotate( xangle, yangle, zangle ) > 0 )
			return;		/* solid edit claimed event */
	} else if( state == ST_O_EDIT )  {
		if( objedit_rotate( xangle, yangle, zangle ) > 0 )
			return;		/* object edit claimed event */
	}
#endif

a3639 1
#ifdef MGED_USE_VIEW_OBJ
a3640 3
#else
	bn_mat_mul2( newrot, view_state->vs_Viewrot );
#endif
a3661 1
#ifdef MGED_USE_VIEW_OBJ
a3662 3
#else
	bn_mat_angles_rad( view_state->vs_Viewrot, rad[X], rad[Y], rad[Z] );
#endif
d3680 4
a3683 6
#ifdef MGED_USE_VIEW_OBJ
	vo_setview(view_state->vs_vop, interp, a1, a2, a3);
#else
	bn_mat_angles(view_state->vs_Viewrot, a1 * degtorad, a2 * degtorad, a3 * degtorad);
	new_mats();
#endif
a3700 1
#ifdef MGED_USE_VIEW_OBJ
a3716 17
#else
	point_t old_model_center;
	point_t new_model_center;
	vect_t diff;
	mat_t	delta;

	MAT_DELTAS_GET_NEG(old_model_center, view_state->vs_toViewcenter);

	MAT4X3PNT(new_model_center, view_state->vs_view2model, view_pos);
	MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, new_model_center);

	VSUB2(diff, new_model_center, old_model_center);
	MAT_IDN(delta);
	MAT_DELTAS_VEC(delta, diff);
	bn_mat_mul2(delta, view_state->vs_ModelDelta);	/* updates ModelDelta */
	new_mats();
#endif
a3733 1
#ifdef MGED_USE_VIEW_OBJ
a3734 31
#else
	point_t	eye_model;
	vect_t	xlate;
	vect_t	new_cent;

	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help eye_pt");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	VSET(eye_model, atof(argv[1]), atof(argv[2]), atof(argv[3]) );

	/* First step:  put eye at view center (view 0,0,0) */
	MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, eye_model );
	new_mats();

	/*  Second step:  put eye at view 0,0,1.
	 *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
	 */
	VSET( xlate, 0.0, 0.0, -1.0 );	/* correction factor */
	MAT4X3PNT( new_cent, view_state->vs_view2model, xlate );
	MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, new_cent );
	new_mats();

	return TCL_OK;
#endif
d3750 3
a3752 1
#ifdef MGED_USE_VIEW_OBJ
a3782 27
#else
	point_t	model;
	point_t	view;
	struct bu_vls	str;

	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helpdevel model2view");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	VSET(model, atof(argv[1]),
		atof(argv[2]),
		atof(argv[3]) );

	MAT4X3PNT( view, view_state->vs_model2view, model );

	bu_vls_init(&str);
	bu_vls_printf(&str, "%.15e %.15e %.15e", V3ARGS(view) );
	Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	bu_vls_free(&str);

	return TCL_OK;
a3798 1
#ifdef MGED_USE_VIEW_OBJ
a3828 25
#else
	point_t	model;
	point_t	view;
	struct bu_vls	str;

	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helpdevel view2model");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	VSET(view, atof(argv[1]), atof(argv[2]), atof(argv[3]));
	MAT4X3PNT(model, view_state->vs_view2model, view);

	bu_vls_init(&str);
	bu_vls_printf(&str, "%.15e %.15e %.15e", V3ARGS(model) );
	Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	bu_vls_free(&str);

	return TCL_OK;
#endif
a3843 1
#ifdef MGED_USE_VIEW_OBJ
a3879 30
#else
  struct bu_vls vls;
  fastf_t f;
  point_t view_pt;
  point_t model_pt;

  CHECK_DBI_NULL;

  bu_vls_init(&vls);

  if(argc != 4){
    bu_vls_printf(&vls, "helpdevel model2view_lu");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  VSET(model_pt, atof(argv[1]), atof(argv[2]), atof(argv[3]));
  VSCALE(model_pt, model_pt, local2base);
  MAT4X3PNT(view_pt, view_state->vs_model2view, model_pt);
  f = view_state->vs_Viewscale * base2local;
  VSCALE(view_pt, view_pt, f);

  bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(view_pt));
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

  bu_vls_free(&vls);
  return TCL_OK;
#endif
a3894 1
#ifdef MGED_USE_VIEW_OBJ
a3930 30
#else
  struct bu_vls vls;
  fastf_t sf;
  point_t view_pt;
  point_t model_pt;

  CHECK_DBI_NULL;

  bu_vls_init(&vls);

  if(argc != 4){
    bu_vls_printf(&vls, "helpdevel view2model_lu");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  sf = 1.0 / (view_state->vs_Viewscale * base2local);
  VSET(view_pt, atof(argv[1]), atof(argv[2]), atof(argv[3]));
  VSCALE(view_pt, view_pt, sf);
  MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
  VSCALE(model_pt, model_pt, base2local);

  bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(model_pt));
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

  bu_vls_free(&vls);
  return TCL_OK;
#endif
a3945 1
#ifdef MGED_USE_VIEW_OBJ
a3989 37
#else
  struct bu_vls vls;
  fastf_t f;
  point_t view_pt;
  point_t model_pt;
  point_t mo_view_pt;           /* model origin in view space */
  point_t diff;

  CHECK_DBI_NULL;

  bu_vls_init(&vls);

  if(argc != 4){
    bu_vls_printf(&vls, "helpdevel model2grid_lu");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  VSETALL(model_pt, 0.0);
  MAT4X3PNT(mo_view_pt, view_state->vs_model2view, model_pt);

  VSET(model_pt, atof(argv[1]), atof(argv[2]), atof(argv[3]));
  VSCALE(model_pt, model_pt, local2base);
  MAT4X3PNT(view_pt, view_state->vs_model2view, model_pt);

  VSUB2(diff, view_pt, mo_view_pt);
  f = view_state->vs_Viewscale * base2local;
  VSCALE(diff, diff, f);

  bu_vls_printf(&vls, "%.15e %.15e", diff[X], diff[Y]);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

  bu_vls_free(&vls);
  return TCL_OK;
#endif
a4004 1
#ifdef MGED_USE_VIEW_OBJ
a4047 38
#else
  struct bu_vls vls;
  fastf_t f;
  point_t view_pt;
  point_t model_pt;
  point_t mo_view_pt;           /* model origin in view space */
  point_t diff;

  CHECK_DBI_NULL;

  bu_vls_init(&vls);

  if(argc != 3){
    bu_vls_printf(&vls, "helpdevel grid2model_lu");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  f = 1.0 / (view_state->vs_Viewscale * base2local);
  diff[X] = atof(argv[1]) * f;
  diff[Y] = atof(argv[2]) * f;
  diff[Z] = 0.0;

  VSETALL(model_pt, 0.0);
  MAT4X3PNT(mo_view_pt, view_state->vs_model2view, model_pt);

  VADD2(view_pt, mo_view_pt, diff);
  MAT4X3PNT(model_pt, view_state->vs_view2model, view_pt);
  VSCALE(model_pt, model_pt, base2local);

  bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(model_pt));
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

  bu_vls_free(&vls);
  return TCL_OK;
#endif
a4062 1
#ifdef MGED_USE_VIEW_OBJ
a4102 34
#else
  struct bu_vls vls;
  fastf_t f;
  point_t view_pt;
  point_t model_pt;
  point_t mo_view_pt;           /* model origin in view space */
  point_t diff;

  CHECK_DBI_NULL;

  bu_vls_init(&vls);

  if(argc != 4){
    bu_vls_printf(&vls, "helpdevel view2grid_lu");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  VSET(view_pt, atof(argv[1]), atof(argv[2]), atof(argv[3]));

  VSETALL(model_pt, 0.0);
  MAT4X3PNT(mo_view_pt, view_state->vs_model2view, model_pt);
  f = view_state->vs_Viewscale * base2local;
  VSCALE(mo_view_pt, mo_view_pt, f);
  VSUB2(diff, view_pt, mo_view_pt);

  bu_vls_printf(&vls, "%.15e %.15e", diff[X], diff[Y]);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

  bu_vls_free(&vls);
  return TCL_OK;
#endif
a4117 1
#ifdef MGED_USE_VIEW_OBJ
a4155 36
#else
  struct bu_vls vls;
  fastf_t f;
  point_t view_pt;
  point_t model_pt;
  point_t mo_view_pt;           /* model origin in view space */
  point_t diff;

  CHECK_DBI_NULL;

  bu_vls_init(&vls);

  if(argc != 3){
    bu_vls_printf(&vls, "helpdevel grid2view_lu");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  diff[X] = atof(argv[1]);
  diff[Y] = atof(argv[2]);
  diff[Z] = 0.0;

  VSETALL(model_pt, 0.0);
  MAT4X3PNT(mo_view_pt, view_state->vs_model2view, model_pt);
  f = view_state->vs_Viewscale * base2local;
  VSCALE(mo_view_pt, mo_view_pt, f);
  VADD2(view_pt, mo_view_pt, diff);

  bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(view_pt));
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

  bu_vls_free(&vls);
  return TCL_OK;
#endif
a4170 1
#ifdef MGED_USE_VIEW_OBJ
d4203 2
a4204 82
	return TCL_ERROR;
#else
  struct bu_vls vls;
  point_t model_vec;
  point_t view_vec;
  mat_t inv_Viewrot;

  bu_vls_init(&vls);

  if(argc != 4){
    bu_vls_printf(&vls, "helpdevel view2model_vec");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }

  VSET(view_vec, atof(argv[1]), atof(argv[2]), atof(argv[3]));
  bn_mat_inv(inv_Viewrot, view_state->vs_Viewrot);
  MAT4X3PNT(model_vec, inv_Viewrot, view_vec);

  bu_vls_printf(&vls, "%.15e %.15e %.15e", V3ARGS(model_vec));
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

  bu_vls_free(&vls);
  return TCL_OK;
#endif
}

int
cmd_lookat(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
#ifdef MGED_USE_VIEW_OBJ
	CHECK_DBI_NULL;

	return vo_lookat_cmd(view_state->vs_vop, interp, argc, argv);
#else
  point_t look;
  point_t eye;
  point_t tmp;
  point_t new_center;
  vect_t dir;
  fastf_t new_az, new_el;
  int status;
  struct bu_vls vls;

  CHECK_DBI_NULL;

  if(argc < 4 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help lookat");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  VSET( look, atof(argv[1]),
	atof(argv[2]),
	atof(argv[3]) );

  VSCALE( look, look, local2base );

  VSET( tmp, 0.0, 0.0, 1.0 );
  MAT4X3PNT(eye, view_state->vs_view2model, tmp);

  VSUB2( dir, eye, look );
  VUNITIZE( dir );
  bn_ae_vec( &new_az, &new_el, dir );

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "ae %-15.10f %-15.10f %-15.10f", new_az, new_el, view_state->vs_twist);
  status = Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  VJOIN1( new_center, eye, -view_state->vs_Viewscale, dir );
  MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, new_center );
d4206 8
a4213 1
  new_mats();
d4215 1
a4215 2
  return( status );
#endif
a4317 1
#ifdef MGED_USE_VIEW_OBJ
a4325 10
#else
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;
#endif
a4355 1
#ifdef MGED_USE_VIEW_OBJ
a4363 10
#else
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;
#endif
a4370 1
#ifdef MGED_USE_VIEW_OBJ
a4373 5
#else
    MAT_COPY(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    MAT_COPY(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;
#endif
a4394 1
#ifdef MGED_USE_VIEW_OBJ
a4402 10
#else
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;
#endif
a4409 1
#ifdef MGED_USE_VIEW_OBJ
a4412 5
#else
    MAT_COPY(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    MAT_COPY(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;
#endif
a4430 1
#ifdef MGED_USE_VIEW_OBJ
a4438 10
#else
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;
#endif
a4442 1
#ifdef MGED_USE_VIEW_OBJ
a4445 5
#else
    MAT_COPY(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    MAT_COPY(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;
#endif
a4488 1
#ifdef MGED_USE_VIEW_OBJ
a4491 5
#else
      MAT_COPY(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
      MAT_COPY(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
      view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;
#endif
a4528 1
#ifdef MGED_USE_VIEW_OBJ
a4536 10
#else
    /* save current Viewrot */
    MAT_COPY(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

    /* save current toViewcenter */
    MAT_COPY(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

    /* save current Viewscale */
    view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;
#endif
a4539 1
#ifdef MGED_USE_VIEW_OBJ
a4542 5
#else
    MAT_COPY(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    MAT_COPY(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;
#endif
a4604 1
#ifdef MGED_USE_VIEW_OBJ
a4605 3
#else
		bn_mat_inv(temp1, view_state->vs_Viewrot);
#endif
a4608 1
#ifdef MGED_USE_VIEW_OBJ
a4609 3
#else
		bn_mat_mul(newrot, temp2, view_state->vs_Viewrot);
#endif
a4639 1
#ifdef MGED_USE_VIEW_OBJ
a4640 3
#else
			MAT4X3PNT(point, view_state->vs_view2model, work);
#endif
a4643 1
#ifdef MGED_USE_VIEW_OBJ
a4644 3
#else
			MAT4X3PNT(point, view_state->vs_view2model, work);
#endif
a4682 1
#if 1
a4687 30
#else
  vect_t rvec;

  if(argc < 4 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help mrot");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &rvec[X]) < 1){
    Tcl_AppendResult(interp, "f_mrot: bad x value - %s\n", argv[1]);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &rvec[Y]) < 1){
    Tcl_AppendResult(interp, "f_mrot: bad y value - %s\n", argv[2]);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%lf", &rvec[Z]) < 1){
    Tcl_AppendResult(interp, "f_mrot: bad z value - %s\n", argv[3]);
    return TCL_ERROR;
  }

  return mged_vrot_xyz(mged_variables->mv_rotate_about, 'm', rvec);
#endif
a4697 1
#ifdef MGED_USE_VIEW_OBJ
a4748 53
#else
  mat_t   newinv;

  bn_mat_inv( newinv, newrot );

  if(origin != 'v'){
    point_t		rot_pt;
    point_t		new_origin;
    mat_t		viewchg, viewchginv;
    point_t		new_cent_view;
    point_t		new_cent_model;

    if(origin == 'e'){
      /* "VR driver" method: rotate around "eye" point (0,0,1) viewspace */
      VSET( rot_pt, 0.0, 0.0, 1.0 );		/* point to rotate around */
    }else if(origin == 'k' && state == ST_S_EDIT){
      /* rotate around keypoint */
      MAT4X3PNT(rot_pt, view_state->vs_model2view, curr_e_axes_pos);
    }else if(origin == 'k' && state == ST_O_EDIT){
      point_t kpWmc;

      MAT4X3PNT(kpWmc, modelchanges, es_keypoint);
      MAT4X3PNT(rot_pt, view_state->vs_model2view, kpWmc);
    }else{
      /* rotate around model center (0,0,0) */
      VSET( new_origin, 0.0, 0.0, 0.0 );
      MAT4X3PNT( rot_pt, view_state->vs_model2view, new_origin );  /* point to rotate around */
    }

    bn_mat_xform_about_pt( viewchg, newrot, rot_pt );
    bn_mat_inv( viewchginv, viewchg );

    /* Convert origin in new (viewchg) coords back to old view coords */
    VSET( new_origin, 0.0, 0.0, 0.0 );
    MAT4X3PNT( new_cent_view, viewchginv, new_origin );
    MAT4X3PNT( new_cent_model, view_state->vs_view2model, new_cent_view );
    MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, new_cent_model );

    /* XXX This should probably capture the translation too */
    /* XXX I think the only consumer of ModelDelta is the predictor frame */
    wrt_view( view_state->vs_ModelDelta, newinv, view_state->vs_ModelDelta );		/* pure rotation */
  } else
    /* Traditional method:  rotate around view center (0,0,0) viewspace */
    wrt_view( view_state->vs_ModelDelta, newinv, view_state->vs_ModelDelta );

  /* Update the rotation component of the model2view matrix */
  bn_mat_mul2( newrot, view_state->vs_Viewrot ); /* pure rotation */
  new_mats();

  set_absolute_tran();

  return TCL_OK;
#endif
a4761 1
#ifdef MGED_USE_VIEW_OBJ
a4777 20
#else
  if (coords == 'm') {
    /* transform model rotations into view rotations */
    bn_mat_inv(temp1, view_state->vs_Viewrot);
    bn_mat_mul(temp2, view_state->vs_Viewrot, newrot);
    bn_mat_mul(newrot, temp2, temp1);
  } else if ((state == ST_S_EDIT || state == ST_O_EDIT) &&
	     coords == 'o') {

    /* first, transform object rotations into model rotations */
    bn_mat_inv(temp1, acc_rot_sol);
    bn_mat_mul(temp2, acc_rot_sol, newrot);
    bn_mat_mul(newrot, temp2, temp1);

    /* now transform model rotations into view rotations */
    bn_mat_inv(temp1, view_state->vs_Viewrot);
    bn_mat_mul(temp2, view_state->vs_Viewrot, newrot);
    bn_mat_mul(newrot, temp2, temp1);
  } /* else assume already view rotations */
#endif
a4787 1
#if 1
a4794 32
#else
  vect_t rvec;

  if(argc < 4 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help vrot");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &rvec[X]) < 1){
    Tcl_AppendResult(interp, "f_vrot: bad x value - %s\n", argv[1]);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &rvec[Y]) < 1){
    Tcl_AppendResult(interp, "f_vrot: bad y value - %s\n", argv[2]);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%lf", &rvec[Z]) < 1){
    Tcl_AppendResult(interp, "f_vrot: bad z value - %s\n", argv[3]);
    return TCL_ERROR;
  }

  VSCALE(rvec, rvec, -1.0);

  return mged_vrot_xyz(mged_variables->mv_rotate_about, 'v', rvec);
#endif
a4796 40
#if 0
int
mged_rot(char	origin,
	 mat_t	newrot)
{
	if ((state == ST_S_EDIT || state == ST_O_EDIT) &&
	    mged_variables->mv_transform == 'e')
		return mged_erot(view_state->vs_vop, mged_variables->mv_coords, origin, newrot);

#ifdef MGED_USE_VIEW_OBJ
	return vo_rot(view_state->vs_vop, interp, mged_variables->mv_coords, origin, newrot, (int (*)())0);
#else
  /* apply to View */
  if(mged_variables->mv_coords == 'm'){
    mat_t temp1, temp2;

    /* transform model rotations into view rotations */
    bn_mat_inv(temp1, view_state->vs_Viewrot);
    bn_mat_mul(temp2, view_state->vs_Viewrot, newrot);
    bn_mat_mul(newrot, temp2, temp1);
  }

  return mged_vrot(origin, newrot);
#endif
}

int
mged_rot_xyz(origin, rvec)
char origin;
vect_t rvec;
{
  mat_t newrot;

  MAT_IDN(newrot);
  bn_mat_angles(newrot, rvec[X], rvec[Y], rvec[Z]);

  return mged_rot(origin, newrot);
}
#endif

a4802 1
#if 1
a4807 34
#else
  vect_t rvec;

  if(argc != 4){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help rot");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &rvec[X]) < 1){
    Tcl_AppendResult(interp, "f_rot: bad x value - %s\n", argv[1]);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &rvec[Y]) < 1){
    Tcl_AppendResult(interp, "f_rot: bad y value - %s\n", argv[2]);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%lf", &rvec[Z]) < 1){
    Tcl_AppendResult(interp, "f_rot: bad z value - %s\n", argv[3]);
    return TCL_ERROR;
  }

  if(state != ST_S_EDIT && state != ST_O_EDIT){
    VSCALE(rvec, rvec, -1.0);
  }

  return mged_rot_xyz(mged_variables->mv_rotate_about, rvec);
#endif
a4815 1
#if 1
a4820 43
#else
  mat_t newrot;
  point_t pt;
  vect_t axis;
  fastf_t angle;

  if(argc != 5){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help arot");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &axis[X]) < 1){
    Tcl_AppendResult(interp, "f_arot: bad x value - %s\n", argv[1]);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &axis[Y]) < 1){
    Tcl_AppendResult(interp, "f_arot: bad y value - %s\n", argv[2]);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%lf", &axis[Z]) < 1){
    Tcl_AppendResult(interp, "f_arot: bad z value - %s\n", argv[3]);
    return TCL_ERROR;
  }

  if(sscanf(argv[4], "%lf", &angle) < 1){
    Tcl_AppendResult(interp, "f_arot: bad angle - %s\n", argv[4]);
    return TCL_ERROR;
  }

  VSETALL(pt, 0.0);
  VUNITIZE(axis);

  bn_mat_arb_rot(newrot, pt, axis, angle*degtorad);

  return mged_rot(mged_variables->mv_rotate_about, newrot);
#endif
a4845 1
#ifdef MGED_USE_VIEW_OBJ
a4848 5
#else
    VSCALE(p2, tvec, local2base/view_state->vs_Viewscale);
    MAT4X3PNT(work, view_state->vs_view2model, p2);
    MAT_DELTAS_GET_NEG(vcenter, view_state->vs_toViewcenter);
#endif
a4894 1
#ifdef MGED_USE_VIEW_OBJ
a4897 5
#else
	MAT_DELTAS_GET_NEG(vc, view_state->vs_toViewcenter);
	VSUB2(nvc, vc, delta);
	MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, nvc);
#endif
a4913 1
#ifdef MGED_USE_VIEW_OBJ
a4919 8
#else
  VSCALE(tt, tvec, local2base/view_state->vs_Viewscale);
  MAT4X3PNT(work, view_state->vs_view2model, tt);
  MAT_DELTAS_GET_NEG(vc, view_state->vs_toViewcenter);
  VSUB2(delta, work, vc);
  VSUB2(nvc, vc, delta);
  MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, nvc);
#endif
a4951 1
#if 1
a4956 36
#else
  vect_t tvec;

  CHECK_DBI_NULL;

  if(argc != 4){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help tra");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &tvec[X]) < 1){
    Tcl_AppendResult(interp, "f_tra: bad x value - %s\n", argv[1]);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &tvec[Y]) < 1){
    Tcl_AppendResult(interp, "f_tra: bad y value - %s\n", argv[2]);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%lf", &tvec[Z]) < 1){
    Tcl_AppendResult(interp, "f_tra: bad z value - %s\n", argv[3]);
    return TCL_ERROR;
  }

  if(state != ST_S_EDIT && state != ST_O_EDIT){
    VSCALE(tvec, tvec, -1.0);
  }

  return mged_tran(tvec);
#endif
a5048 3
#if 0
    MAT4X3PNT(temp, es_mat, es_keypoint);
#else
a5049 1
#endif
a5066 1
#ifdef MGED_USE_VIEW_OBJ
a5070 6
#else
	view_state->vs_Viewscale *= sfactor;
	if( view_state->vs_Viewscale < MINVIEW )
		view_state->vs_Viewscale = MINVIEW;
	f = view_state->vs_Viewscale / view_state->vs_i_Viewscale;
#endif
a5097 1
#if 1
a5115 20
#else
  fastf_t sfactor;

  if(argc != 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help sca");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &sfactor) < 1){
    Tcl_AppendResult(interp, "f_sca: bad scale factor - %s\n", argv[1]);
    return TCL_ERROR;
  }

  return mged_scale(sfactor);
#endif
@


11.169
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.168 2001/05/04 14:20:45 bparker Exp $ (BRL)";
a93 2
int knob_tran();
int mged_tran();
d100 8
d269 4
a272 5
f_erase(
	ClientData clientData,
	Tcl_Interp *interp,
	int     argc,
	char    **argv)
d274 11
d301 1
d305 4
a308 5
f_erase_all(
	ClientData clientData,
	Tcl_Interp *interp,
	int     argc,
	char    **argv)
d310 11
d337 1
d349 10
d393 1
d397 1
a397 2
mged_center(center)
point_t center;
d399 6
a404 2
  MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, center);
  new_mats();
d406 1
a406 1
  (void)mged_svbase();
d418 18
d465 1
a465 73
}

/* ZAP the display -- then edit anew */
/* Format: B object	*/
int
f_blast(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  char *av[2];

  av[0] = "Z";
  av[1] = (char *)NULL;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help B");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (f_zap(clientData, interp, 1, av) == TCL_ERROR)
    return TCL_ERROR;

  return edit_com( argc, argv, 1, 1 );
}

/* Edit something (add to visible display) */
/* Format: e object	*/
int
f_edit(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return edit_com( argc, argv, 1, 1 );
}

/* Format: ev objects	*/
int
f_ev(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help ev");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return edit_com( argc, argv, 3, 1 );
d511 4
d524 1
a524 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
d535 1
a535 1
	if(BU_LIST_IS_EMPTY(&HeadSolid.l)) {
d547 11
d565 2
d575 4
a578 5
edit_com(
     int	argc,
     char	**argv,
     int	kind,
     int	catch_sigint)
d584 1
d590 44
d635 1
a635 1
	initial_blank_screen = BU_LIST_IS_EMPTY(&HeadSolid.l);
d667 1
a667 1
		    BU_LIST_NON_EMPTY(&HeadSolid.l)) {
d675 3
d679 1
d694 1
d698 4
a701 5
f_autoview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d728 3
d733 1
d737 3
d741 1
d775 4
a778 5
f_debug(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d780 3
d807 1
a1042 162
 *			C M D _ L I S T _ G U T S
 */
static void
cmd_list_guts(clientData, interp, argc, argv, recurse)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
int recurse;
{
  register struct directory *dp;
  register int arg;
  struct bu_vls str;
  char *listeval="listeval";
  struct rt_db_internal intern;

  bu_vls_init( &str );

  for (arg = 0; arg < argc; arg++) {
    if (recurse) {
      char *tmp_argv[2];

      tmp_argv[0] = listeval;
      tmp_argv[1] = argv[arg];

      cmd_pathsum(clientData, interp, 2, tmp_argv);
    } else if (strchr(argv[arg], '/')) {
      struct db_tree_state ts;
      struct db_full_path path;

      db_full_path_init( &path );
      ts = mged_initial_tree_state;	/* struct copy */
      ts.ts_dbip = dbip;
      ts.ts_resp = &rt_uniresource;
      MAT_IDN(ts.ts_mat);

      if (db_follow_path_for_state(&ts, &path, argv[arg], 1))
	continue;

      dp = DB_FULL_PATH_CUR_DIR( &path );

      if (rt_db_get_internal(&intern, dp, dbip, ts.ts_mat, &rt_uniresource) < 0) {
	Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
			 ") failure\n", (char *)NULL );
	continue;
      }

      db_free_full_path( &path );

      bu_vls_printf( &str, "%s:  ", argv[arg] );

      if (intern.idb_meth->ft_describe(&str, &intern, 99, base2local, &rt_uniresource) < 0)
	Tcl_AppendResult(interp, dp->d_namep, ": ft_describe error\n", (char *)NULL);
    	rt_db_free_internal( &intern, &rt_uniresource );
    } else {
      if ((dp = db_lookup(dbip, argv[arg], LOOKUP_NOISY)) == DIR_NULL)
	continue;

      do_list(&str, dp, 99);	/* very verbose */
    }
  }

  Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
  bu_vls_free( &str );
}

/*
 *			C M D _ L I S T
 *
 *  List object information, verbose, in GIFT-compatible format.
 *  Format: l object
 */
int
cmd_list(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  int start_arg=1;
  int recurse=0;

  CHECK_DBI_NULL;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help l");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (argc > 1 && strcmp(argv[1], "-r") == 0) {
    recurse = 1;
    start_arg = 2;
  }

#if 0
  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3 );	/* allow interupts */
  else{
    bu_vls_free( &str );
    return TCL_OK;
  }
#endif

  /* 
   * Here we have no usable arguments,
   * so we better be in an edit state.
   */
  if (argc == 1 ||
      (argc == 2 && recurse)) {
    int ac = 1;
    char *av[2];

    if (illump != SOLID_NULL) {
      struct bu_vls vls;

      bu_vls_init(&vls);

      if (state == ST_S_EDIT)
    	db_path_to_vls( &vls, &illump->s_fullpath );
      else if (state == ST_O_EDIT)  {
      	int i;
      	for( i=0; i < ipathpos; i++ )  {
      		bu_vls_printf(&vls, "/%s",
			DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep );
      	}
      } else
	return TCL_ERROR;

    	db_path_to_vls( &vls, &illump->s_fullpath );

      av[0] = bu_vls_addr(&vls);
      av[1] = (char *)NULL;
      cmd_list_guts(clientData, interp, ac, av, recurse);

      bu_vls_free(&vls);
    } else {  /* not in an edit state */
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help l");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
  } else { /* Here we have usable arguments. */
    argc -= start_arg;
    argv += start_arg;
    cmd_list_guts(clientData, interp, argc, argv, recurse);
  }

#if 0
  (void)signal(SIGINT, SIG_IGN);
#endif
  return TCL_OK;
}

/*
d1070 1
a1070 1
f_zap(
d1076 21
d1120 3
a1122 3
	freeDListsAll(BU_LIST_FIRST(solid, &HeadSolid.l)->s_dlist,
		      BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist -
		      BU_LIST_FIRST(solid, &HeadSolid.l)->s_dlist + 1);
d1125 2
a1126 2
	sp = BU_LIST_NEXT(solid, &HeadSolid.l);
	while(BU_LIST_NOT_HEAD(sp, &HeadSolid.l)){
d1149 1
d1159 2
a1160 1
  struct bu_vls vls;
d1162 1
a1162 1
  CHECK_DBI_NULL;
d1164 107
a1270 2
  if(argc < 1 || 2 < argc){
    struct bu_vls vls;
d1400 1
d1410 309
d2050 1
d2086 3
d2090 1
d2095 8
d2104 3
a2106 3
    setview( 270.0 + elev + view_state->vs_elevation,
	     0.0,
	     270.0 - azim - view_state->vs_azimuth);
d2108 2
a2109 1
    setview( 270.0 + elev, 0.0, 270.0 - azim );
d2155 10
d2198 2
a2199 2
	sp = BU_LIST_NEXT(solid, &HeadSolid.l);
	while (BU_LIST_NOT_HEAD(sp, &HeadSolid.l)) {
d2256 2
a2257 2
	sp = BU_LIST_FIRST(solid, &HeadSolid.l);
	while (BU_LIST_NOT_HEAD(sp, &HeadSolid.l)) {
d2503 1
a2503 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l){
d2626 1
a2626 1
  if(BU_LIST_IS_EMPTY(&HeadSolid.l)){
d3636 3
d3640 1
d3672 3
d3676 1
d3682 3
d3686 1
d3693 3
d3697 1
d3701 3
d3705 1
d3715 3
d3719 1
d3751 3
d3755 1
d3761 3
d3765 1
d3772 3
d3776 1
d3780 3
d3784 1
d3793 3
d3797 1
d3829 3
d3833 1
d3839 3
d3843 1
d3850 3
d3854 1
d3858 3
d3862 1
d4026 14
a4039 15
knob_tran(tvec, model_flag, view_flag, edit_flag)
vect_t tvec;
int model_flag;
int view_flag;
int edit_flag;
{
  if(EDIT_TRAN && ((mged_variables->mv_transform == 'e' &&
		    !view_flag && !model_flag) || edit_flag))
    mged_etran(tvec);
  else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
    mged_mtran(tvec);
  else if(mged_variables->mv_coords == 'o')
    mged_otran(tvec);
  else
    mged_vtran(tvec);
d4041 1
a4041 1
  return TCL_OK;
d4045 15
a4059 16
knob_rot(
	vect_t rvec,
	char origin,
	int model_flag,
	int view_flag,
	int edit_flag)
{
  if(EDIT_ROTATE && ((mged_variables->mv_transform == 'e' &&
		      !view_flag && !model_flag) || edit_flag))
    mged_erot_xyz(origin, rvec);
  else if(model_flag || (mged_variables->mv_coords == 'm' && !view_flag))
    mged_vrot_xyz(origin, 'm', rvec);
  else if(mged_variables->mv_coords == 'o')
    mged_vrot_xyz(origin, 'o', rvec);
  else
    mged_vrot_xyz(origin, 'v', rvec);
d4061 1
a4061 1
  return TCL_OK;
d4064 3
a4066 16
/*
 *			F _ T O L
 *
 *  "tol"	displays current settings
 *  "tol abs #"	sets absolute tolerance.  # > 0.0
 *  "tol rel #"	sets relative tolerance.  0.0 < # < 1.0
 *  "tol norm #" sets normal tolerance, in degrees.
 *  "tol dist #" sets calculational distance tolerance
 *  "tol perp #" sets calculational normal tolerance.
 */
int
f_tol(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d4068 4
a4071 4
#if 0
	CHECK_DBI_NULL;

	return wdb_tol_cmd(wdbp, interp, argc, argv);
d4073 10
a4082 130
	double	f;
	int argind=1;

	CHECK_DBI_NULL;

	if(argc < 1 || 11 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help tol");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( argc < 3 )  {
	  Tcl_AppendResult(interp, "Current tolerance settings are:\n", (char *)NULL);
	  Tcl_AppendResult(interp, "Tesselation tolerances:\n", (char *)NULL );
	  if( mged_abs_tol > 0.0 )  {
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "\tabs %g %s\n", mged_abs_tol * base2local,
			  bu_units_string(dbip->dbi_local2base) );
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);
	  } else {
	    Tcl_AppendResult(interp, "\tabs None\n", (char *)NULL);
	  }
	  if( mged_rel_tol > 0.0 )  {
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "\trel %g (%g%%)\n", mged_rel_tol, mged_rel_tol * 100.0 );
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);
	  } else {
	    Tcl_AppendResult(interp, "\trel None\n", (char *)NULL);
	  }
	  if( mged_nrm_tol > 0.0 )  {
	    int	deg, min;
	    double	sec;
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    sec = mged_nrm_tol * bn_radtodeg;
	    deg = (int)(sec);
	    sec = (sec - (double)deg) * 60;
	    min = (int)(sec);
	    sec = (sec - (double)min) * 60;

	    bu_vls_printf(&vls, "\tnorm %g degrees (%d deg %d min %g sec)\n",
			  mged_nrm_tol * bn_radtodeg, deg, min, sec );
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);
	  } else {
	    Tcl_AppendResult(interp, "\tnorm None\n", (char *)NULL);
	  }

	  {
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls,"Calculational tolerances:\n");
	    bu_vls_printf(&vls,
			  "\tdistance = %g %s\n\tperpendicularity = %g (cosine of %g degrees)\n",
			   mged_tol.dist*base2local, bu_units_string(local2base), mged_tol.perp,
			  acos(mged_tol.perp)*bn_radtodeg);
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);
	  }

	  return TCL_OK;
	}

	while( argind < argc )
	{

		f = atof(argv[argind+1]);
		if( argv[argind][0] == 'a' )  {
			/* Absolute tol */
			if( f <= 0.0 )
			        mged_abs_tol = 0.0;	/* None */
			else
			        mged_abs_tol = f * local2base;
			return TCL_OK;
		}
		else if( argv[argind][0] == 'r' )  {
			/* Relative */
			if( f < 0.0 || f >= 1.0 )  {
			   Tcl_AppendResult(interp, "relative tolerance must be between 0 and 1, not changed\n", (char *)NULL);
			   return TCL_ERROR;
			}
			/* Note that a value of 0.0 will disable relative tolerance */
			mged_rel_tol = f;
		}
		else if( argv[argind][0] == 'n' )  {
			/* Normal tolerance, in degrees */
			if( f < 0.0 || f > 90.0 )  {
			  Tcl_AppendResult(interp, "Normal tolerance must be in positive degrees, < 90.0\n", (char *)NULL);
			  return TCL_ERROR;
			}
			/* Note that a value of 0.0 or 360.0 will disable this tol */
			mged_nrm_tol = f * bn_degtorad;
		}
		else if( argv[argind][0] == 'd' ) {
			/* Calculational distance tolerance */
			if( f < 0.0 ) {
			  Tcl_AppendResult(interp, "Calculational distance tolerance must be positive\n", (char *)NULL);
			  return TCL_ERROR;
			}
			mged_tol.dist = f*local2base;
			mged_tol.dist_sq = mged_tol.dist * mged_tol.dist;
		}
		else if( argv[argind][0] == 'p' ) {
			/* Calculational perpendicularity tolerance */
			if( f < 0.0 || f > 1.0 ) {
			  Tcl_AppendResult(interp, "Calculational perpendicular tolerance must be from 0 to 1\n", (char *)NULL);
			  return TCL_ERROR;
			}
			mged_tol.perp = f;
			mged_tol.para = 1.0 - f;
		}
		else
		  Tcl_AppendResult(interp, "Error, tolerance '", argv[argind],
				   "' unknown\n", (char *)NULL);

		argind += 2;
	}
	return TCL_OK;
a4083 14
}

/* absolute_scale's value range is [-1.0, 1.0] */
static void
abs_zoom()
{
  /* Use initial Viewscale */
  if(-SMALL_FASTF < view_state->vs_absolute_scale && view_state->vs_absolute_scale < SMALL_FASTF)
    view_state->vs_Viewscale = view_state->vs_i_Viewscale;
  else{
    /* if positive */
    if(view_state->vs_absolute_scale > 0){
      /* scale i_Viewscale by values in [0.0, 1.0] range */
      view_state->vs_Viewscale = view_state->vs_i_Viewscale * (1.0 - view_state->vs_absolute_scale);
d4086 3
d4090 1
d4093 6
d4103 1
d4113 1
a4113 2
mged_zoom(val)
double val;
d4115 16
a4130 4
  if( val < SMALL_FASTF || val > INFINITY )  {
    Tcl_AppendResult(interp, "zoom: scale factor out of range\n", (char *)NULL);
    return TCL_ERROR;
  }
d4132 1
a4132 3
  view_state->vs_Viewscale /= val;
  if( view_state->vs_Viewscale < MINVIEW )
    view_state->vs_Viewscale = MINVIEW;
d4134 2
a4135 1
  new_mats();
d4137 2
a4138 3
  view_state->vs_absolute_scale = 1.0 - view_state->vs_Viewscale / view_state->vs_i_Viewscale;
  if(view_state->vs_absolute_scale < 0.0)
    view_state->vs_absolute_scale /= 9.0;
d4140 5
a4144 5
  if(view_state->vs_absolute_tran[X] != 0.0 ||
     view_state->vs_absolute_tran[Y] != 0.0 ||
     view_state->vs_absolute_tran[Z] != 0.0){
    set_absolute_tran();
  }
d4146 1
a4146 1
  return TCL_OK;
d4157 4
a4160 5
f_zoom(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d4162 2
a4163 2
  if(argc < 2 || 2 < argc){
    struct bu_vls vls;
d4165 6
a4170 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help zoom");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d4172 1
a4172 1
  return mged_zoom(atof(argv[1]));
d4182 4
a4185 5
f_orientation(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d4187 5
a4191 2
  register int	i;
  quat_t		quat;
d4193 2
a4194 2
  if(argc < 5 || 5 < argc){
    struct bu_vls vls;
d4196 6
a4201 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help orientation");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d4203 4
a4206 4
  for( i=0; i<4; i++ )
    quat[i] = atof( argv[i+1] );
  quat_quat2mat( view_state->vs_Viewrot, quat );
  new_mats();
d4208 2
a4209 1
  return TCL_OK;
d4257 1
a4257 1
    setview( 270.0 + el * radtodeg, 0.0, 270.0 - az * radtodeg );
d4320 19
a4338 6
f_setview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    *argv[];
{
d4372 1
d4382 23
d4444 1
d4452 7
a4458 2
  view_state->vs_i_Viewscale = view_state->vs_Viewscale;
  MAT_DELTAS_GET_NEG(view_state->vs_orig_pos, view_state->vs_toViewcenter);
d4460 10
a4469 10
  /* reset absolute slider values */
  VSETALL(view_state->vs_absolute_rotate, 0.0);
  VSETALL(view_state->vs_last_absolute_rotate, 0.0);
  VSETALL(view_state->vs_absolute_model_rotate, 0.0);
  VSETALL(view_state->vs_last_absolute_model_rotate, 0.0);
  VSETALL(view_state->vs_absolute_tran, 0.0);
  VSETALL(view_state->vs_last_absolute_tran, 0.0);
  VSETALL(view_state->vs_absolute_model_tran, 0.0);
  VSETALL(view_state->vs_last_absolute_model_tran, 0.0);
  view_state->vs_absolute_scale = 0.0;
d4471 2
a4472 2
  if(mged_variables->mv_faceplate && mged_variables->mv_orig_gui)
    curr_dm_list->dml_dirty = 1;
d4474 1
a4474 1
  return TCL_OK;
d4534 1
d4568 1
a4568 1
	buildHrot( newrot, xangle, yangle, zangle );
d4570 3
d4574 1
d4596 5
a4600 1
	buildHrot( view_state->vs_Viewrot, rad[X], rad[Y], rad[Z] );
d4614 3
a4616 2
setview( a1, a2, a3 )
double a1, a2, a3;		/* DOUBLE angles, in degrees */
d4618 6
a4623 2
  buildHrot( view_state->vs_Viewrot, a1 * degtorad, a2 * degtorad, a3 * degtorad );
  new_mats();
d4625 5
a4629 5
  if(view_state->vs_absolute_tran[X] != 0.0 ||
     view_state->vs_absolute_tran[Y] != 0.0 ||
     view_state->vs_absolute_tran[Z] != 0.0){
    set_absolute_tran();
  }
a4631 1

d4639 1
a4639 2
slewview( view_pos )
vect_t view_pos;
d4641 34
a4674 15
  point_t old_model_center;
  point_t new_model_center;
  vect_t diff;
  mat_t	delta;

  MAT_DELTAS_GET_NEG( old_model_center, view_state->vs_toViewcenter );

  MAT4X3PNT( new_model_center, view_state->vs_view2model, view_pos );
  MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, new_model_center );

  VSUB2( diff, new_model_center, old_model_center );
  MAT_IDN( delta );
  MAT_DELTAS_VEC( delta, diff );
  bn_mat_mul2( delta, view_state->vs_ModelDelta );	/* updates ModelDelta */
  new_mats();
d4676 1
a4676 1
  set_absolute_tran();
d4686 1
a4686 1
f_eye_pt(clientData, interp, argc, argv)
d4692 3
d4724 1
d4740 32
d4798 1
d4814 32
d4869 1
d4885 38
d4951 1
d4967 38
d5033 1
d5049 46
d5130 1
d5146 45
d5227 1
d5232 53
a5284 11
 *
 *  Given a point in view coordinates (local units),
 *  convert it to grid coordinates (local units).
 */
int
f_view2grid_lu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
d5317 1
d5333 40
d5407 1
d5423 35
d5482 1
d5486 1
a5486 1
f_lookat(clientData, interp, argc, argv)
d5492 5
d5542 1
d5645 10
d5663 1
d5694 10
d5712 1
d5720 5
d5728 1
d5750 10
d5768 1
d5776 5
d5784 1
d5803 10
d5821 1
d5826 5
d5834 1
d5878 5
d5886 1
d5924 10
d5942 1
d5946 5
d5954 1
d5996 4
a5999 2
mged_erot(origin, newrot)
mat_t newrot;
d6001 2
a6002 2
  int save_edflag;
  mat_t temp1, temp2;
d6004 1
a6004 1
  update_views = 1;
d6006 5
a6010 5
  switch(mged_variables->mv_coords){
  case 'm':
    break;
  case 'o':
    bn_mat_inv(temp1, acc_rot_sol);
d6012 10
a6021 6
    /* transform into object rotations */
    bn_mat_mul(temp2, acc_rot_sol, newrot);
    bn_mat_mul(newrot, temp2, temp1);
    break;
  case 'v':
    bn_mat_inv(temp1, view_state->vs_Viewrot);
d6023 9
a6031 5
    /* transform into model rotations */
    bn_mat_mul(temp2, temp1, newrot);
    bn_mat_mul(newrot, temp2, view_state->vs_Viewrot);
    break;
  }
d6033 2
a6034 2
  if(state == ST_S_EDIT){
    char save_origin;
d6036 2
a6037 2
    save_origin = mged_variables->mv_rotate_about;
    mged_variables->mv_rotate_about = origin;
d6039 3
a6041 3
    save_edflag = es_edflag;
    if(!SEDIT_ROTATE)
      es_edflag = SROT;
d6043 4
a6046 4
    inpara = 0;
    MAT_COPY(incr_change, newrot);
    bn_mat_mul2(incr_change, acc_rot_sol);
    sedit();
d6048 5
a6052 5
    mged_variables->mv_rotate_about = save_origin;
    es_edflag = save_edflag;
  }else{
    point_t point;
    vect_t work;
d6054 1
a6054 1
    bn_mat_mul2(newrot, acc_rot_sol);
d6056 25
a6080 17
    /* find point for rotation to take place wrt */
    switch(origin){
    case 'v':       /* View Center */
      VSET(work, 0.0, 0.0, 0.0);
      MAT4X3PNT(point, view_state->vs_view2model, work);
      break;
    case 'e':       /* Eye */
      VSET(work, 0.0, 0.0, 1.0);
      MAT4X3PNT(point, view_state->vs_view2model, work);
      break;
    case 'm':       /* Model Center */
      VSETALL(point, 0.0);
      break;
    case 'k':
    default:
      MAT4X3PNT(point, modelchanges, es_keypoint);
    }
d6082 4
a6085 4
    /* 
     * Apply newrot to the modelchanges matrix wrt "point"
     */
    wrt_point(modelchanges, newrot, modelchanges, point);
d6087 2
a6088 2
    new_edit_mats();
  }
d6090 1
a6090 1
  return TCL_OK;
d6094 2
a6095 3
mged_erot_xyz(
	char origin,
	vect_t rvec)
d6097 1
a6097 1
  mat_t newrot;
d6099 2
a6100 2
  MAT_IDN(newrot);
  buildHrot(newrot, rvec[X]*degtorad, rvec[Y]*degtorad, rvec[Z]*degtorad);
d6102 1
a6102 1
  return mged_erot(origin, newrot);
d6106 4
a6109 5
f_mrot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d6111 7
d6146 1
d6157 53
d6261 1
d6265 28
a6292 11
mged_vrot_xyz(
	char origin,
	char coords,
	vect_t rvec)
{
  mat_t newrot;
  mat_t temp1, temp2;

  MAT_IDN(newrot);
  buildHrot(newrot, rvec[X]*degtorad, rvec[Y]*degtorad, rvec[Z]*degtorad);

d6311 1
d6317 4
a6320 5
f_vrot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d6322 9
d6361 1
d6364 1
d6366 2
a6367 3
mged_rot(origin, newrot)
char origin;
mat_t newrot;
d6369 3
a6371 3
  if((state == ST_S_EDIT || state == ST_O_EDIT) &&
     mged_variables->mv_transform == 'e')
    return mged_erot(origin, newrot);
d6373 3
d6387 1
d6398 1
a6398 1
  buildHrot(newrot, rvec[X]*degtorad, rvec[Y]*degtorad, rvec[Z]*degtorad);
d6402 1
d6405 12
a6416 6
f_rot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
d6449 1
d6453 12
a6464 6
f_arot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
d6506 1
d6510 3
a6512 1
mged_etran(const point_t pt)
d6522 1
a6522 1
  switch(mged_variables->mv_coords){
d6524 1
a6524 1
    VSCALE(delta, pt, local2base);
d6527 1
a6527 1
    VSCALE(p2, pt, local2base);
d6532 6
a6537 1
    VSCALE(p2, pt, local2base/view_state->vs_Viewscale);
d6540 1
d6583 2
a6584 2
  point_t delta;
  point_t vc, nvc;
d6586 11
a6596 5
  VSCALE(delta, tvec, local2base);
  MAT_DELTAS_GET_NEG(vc, view_state->vs_toViewcenter);
  VSUB2(nvc, vc, delta);
  MAT_DELTAS_VEC_NEG(view_state->vs_toViewcenter, nvc);
  new_mats();
d6598 2
a6599 2
  /* calculate absolute_tran */
  set_absolute_view_tran();
d6601 1
a6601 1
  return TCL_OK;
d6612 8
d6626 1
d6637 1
a6637 1
mged_tran(const vect_t tvec)
d6641 1
a6641 1
    return mged_etran(tvec);
d6654 12
a6665 6
f_tra(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
d6700 1
d6808 1
a6808 2
mged_vscale(sfactor)
fastf_t sfactor;
d6810 1
a6810 1
  fastf_t f;
d6812 2
a6813 2
  if(-SMALL_FASTF < sfactor && sfactor < SMALL_FASTF)
    return TCL_OK;
d6815 11
a6825 4
  view_state->vs_Viewscale *= sfactor;
  if( view_state->vs_Viewscale < MINVIEW )
        view_state->vs_Viewscale = MINVIEW;
  f = view_state->vs_Viewscale / view_state->vs_i_Viewscale;
d6827 4
a6830 4
  if(f >= 1.0)
    view_state->vs_absolute_scale = (f - 1.0) / -9.0;
  else
    view_state->vs_absolute_scale = 1.0 - f;
d6832 2
a6833 2
  new_mats();
  return TCL_OK;
d6848 25
a6872 6
f_sca(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
d6891 1
@


11.168
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.167 2001/05/02 17:14:00 bparker Exp $ (BRL)";
d857 1
a857 1
    if( rt_g.debug )  bu_debug |= BU_DEBUG_COREDUMP;
d862 1
a862 1
  bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
d1220 1
a1220 1
	if( rt_g.debug )  mged_freemem();
@


11.167
log
@*- modified commands to use new librt routines
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.166 2001/04/17 14:09:30 bparker Exp $ (BRL)";
d1004 1
a1004 1
      f_pathsum(clientData, interp, 2, tmp_argv);
a1136 49
  return TCL_OK;
}

/* List object information, briefly */
/* Format: cat object	*/
int
f_cat(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  register struct directory *dp;
  register int arg;
  struct bu_vls str;

  CHECK_DBI_NULL;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help cat");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_vls_init( &str );

  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3 );	/* allow interupts */
  else{
    bu_vls_free( &str );
    return TCL_OK;
  }

  for( arg = 1; arg < argc; arg++ )  {
    if( (dp = db_lookup( dbip, argv[arg], LOOKUP_NOISY )) == DIR_NULL )
      continue;

    bu_vls_trunc( &str, 0 );
    do_list( &str, dp, 0 );	/* non-verbose */
    Tcl_AppendResult(interp, bu_vls_addr(&str), "\n", (char *)NULL);
  }

  bu_vls_free( &str );

  (void)signal(SIGINT, SIG_IGN);
@


11.166
log
@*- mods to mged_escale() to fix a bug that
   shows up when scaling X, Y or Z in matrix
   edit mode
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.165 2001/04/05 19:35:43 morrison Exp $ (BRL)";
d3711 1
a3711 1
	return invoke_db_wrapper(interp, argc, argv);
@


11.165
log
@updated SIGNED to signed
updated CONST to const
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.164 2001/04/02 21:38:18 morrison Exp $ (BRL)";
d5820 1
a5820 1
      smat[0] = inv_sfactor;
d5822 1
a5822 1
      acc_sc[X] *= inv_sfactor;
d5830 1
a5830 1
      smat[5] = inv_sfactor;
d5832 1
a5832 1
      acc_sc[Y] *= inv_sfactor;
d5840 1
a5840 1
      smat[10] = inv_sfactor;
d5842 1
a5842 1
      acc_sc[Z] *= inv_sfactor;
@


11.164
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.163 2001/03/31 01:57:21 morrison Exp $ (BRL)";
d4295 1
a4295 1
CONST point_t	ang;
@


11.163
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.162 2001/03/26 19:15:55 bparker Exp $ (BRL)";
d4878 2
a4879 2
      bn_mat_copy(vrp1->vr_rot_mat, vrp2->vr_rot_mat);
      bn_mat_copy(vrp1->vr_tvc_mat, vrp2->vr_tvc_mat);
d4957 1
a4957 1
    bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);
d4960 1
a4960 1
    bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);
d4995 1
a4995 1
    bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);
d4998 1
a4998 1
    bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);
d5009 2
a5010 2
    bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
d5034 1
a5034 1
    bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);
d5037 1
a5037 1
    bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);
d5048 2
a5049 2
    bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
d5070 1
a5070 1
    bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);
d5073 1
a5073 1
    bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);
d5081 2
a5082 2
    bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
d5127 2
a5128 2
      bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
      bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
d5168 1
a5168 1
    bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);
d5171 1
a5171 1
    bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);
d5178 2
a5179 2
    bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
d5260 1
a5260 1
    bn_mat_copy(incr_change, newrot);
@


11.162
log
@*- check-in #if'd out unfinished work from tgm/offsite
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgview.c,v 11.161 2001/03/19 22:20:01 butler Exp $ (BRL)";
d555 1
a555 1
	bn_mat_idn( view_state->vs_toViewcenter );
d1013 1
a1013 1
      bn_mat_idn(ts.ts_mat);
d4275 1
a4275 1
	bn_mat_idn( newrot );
d4349 1
a4349 1
  bn_mat_idn( delta );
d5308 1
a5308 1
  bn_mat_idn(newrot);
d5421 1
a5421 1
  bn_mat_idn(newrot);
d5514 1
a5514 1
  bn_mat_idn(newrot);
d5650 1
a5650 1
    bn_mat_idn(xlatemat);
d5816 1
a5816 1
    bn_mat_idn(smat);
@


11.161
log
@patches to merge 5.3 into 6.0
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/chgview.c,v 11.160 2001/02/23 20:24:38 bparker Exp $ (BRL)";
d3708 5
d3843 1
@


11.160
log
@*- mods that save the Tcl result string
   and restore it after a Tcl_Eval
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.159 2001/02/16 22:43:44 bparker Exp $ (BRL)";
d658 1
a658 1
		bu_vls_printf(&vls, "help autosize");
@


11.159
log
@*- check if (dbip == DBI_NULL) before doing anything
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.158 2001/01/04 17:02:21 bparker Exp $ (BRL)";
d198 1
d205 19
@


11.158
log
@Changed autosize to autoview.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.157 2001/01/03 21:30:00 bparker Exp $ (BRL)";
d1413 2
d4472 2
d4515 2
d4560 2
d4610 2
d4661 2
d4708 2
d5714 2
@


11.157
log
@New command (autosize) for setting the view size
and center such that all displayed solids are in view.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.156 2000/10/24 19:53:49 mike Exp $ (BRL)";
d624 1
a624 1
f_autosize(clientData, interp, argc, argv)
@


11.156
log
@
Possible uninit
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.155 2000/10/24 19:05:05 mike Exp $ (BRL)";
d620 45
@


11.155
log
@
Fixed compiler lint, function declarations.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.154 2000/10/20 05:04:37 mike Exp $ (BRL)";
d3012 3
d3116 3
d3220 3
d4785 2
a4786 2
    struct view_ring *vrp1_current_view;
    struct view_ring *vrp1_last_view;
@


11.154
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.153 2000/10/18 14:21:40 bparker Exp $ (BRL)";
d81 1
@


11.153
log
@Use button(BE_REJECT) instead of be_reject()
in f_sed().
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.152 2000/10/12 16:10:21 bparker Exp $ (BRL)";
a1030 1
      register int i, last;
d1036 8
a1043 4
	last = illump->s_last;
      else if (state == ST_O_EDIT)
	  last = ipathpos;
      else
d1046 1
a1046 2
      for (i = 0; i <= last; ++i)
	bu_vls_printf(&vls, "/%s", illump->s_path[i]->d_namep);
d1187 1
a1187 1
		dp = sp->s_path[0];
d1797 1
a1797 1
     register struct directory **dpp;
d1802 1
a1802 1
	register int i;
d1809 2
a1810 1
	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)
d1812 2
a1817 14
		for (i=0; i <= sp->s_last; i++) {
			/* look for first path element */
			if (sp->s_path[i] != *dpp)
				continue;

			/* look for rest of path */
			for (++i, tmp_dpp = dpp+1;
			     i <= sp->s_last && *tmp_dpp != DIR_NULL;
			     ++i, ++tmp_dpp)
				if (sp->s_path[i] != *tmp_dpp)
					goto end;

			if (*tmp_dpp != DIR_NULL)
				goto end;
d1819 1
a1828 2

			break;
a1829 1
	end:
d1838 2
d1852 1
a1852 1
     register struct directory **dpp;
d1857 1
a1857 1
	register int i;
d1867 2
a1868 1
	for (tmp_dpp = dpp; *tmp_dpp != DIR_NULL; ++tmp_dpp)
d1870 2
a1875 6
		for (i = 0, tmp_dpp = dpp;
		     i <= sp->s_last && *tmp_dpp != DIR_NULL;
		     ++i, ++tmp_dpp)
			if (sp->s_path[i] != *tmp_dpp)
				goto end;

d1877 1
a1877 2
		if (*tmp_dpp != DIR_NULL)
			goto end;
d1880 1
a1880 1
		freeDListsAll(sp->s_dlist, 1);
d1883 2
a1884 2
		if (state != ST_VIEW && illump == sp)
			button( BE_REJECT );
d1886 3
a1888 3
		BU_LIST_DEQUEUE(&sp->l);
		FREE_SOLID(sp, &FreeSolid.l);
	end:
d1897 2
a1914 1
  register int		i;
d1935 1
a1935 1
      bu_vls_printf(&vls, "%s ", sp->s_path[(int)(sp->s_last)]->d_namep);
d1941 1
a1941 2
    for( i=0; i <= sp->s_last; i++ )
      bu_vls_printf(&vls, "/%s", sp->s_path[i]->d_namep);
d2123 1
d2125 2
a2126 2
		  i = sp -> s_last;
		  if (sp -> s_path[i] == dp) {
d2130 1
a2130 1
				  sname = sp -> s_path[i] -> d_namep;
@


11.152
log
@Add -i option to f_ill().
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.151 2000/09/21 02:46:51 mike Exp $ (BRL)";
d2272 1
a2272 1
	  be_reject(clientData, interp, 0, argv);
@


11.151
log
@
Need to initialize ts.ts_resp
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.150 2000/09/09 04:30:54 mike Exp $ (BRL)";
d2027 2
d2037 1
d2053 44
d2136 17
a2152 15
	  i = sp -> s_last;
	  if(sp -> s_path[i] == dp){
	    a_new_match = 1;
	    j = nm_pieces - 1;
	    for(; a_new_match && (i >= 0) && (j >= 0); --i, --j){
	      sname = sp -> s_path[i] -> d_namep;
	      if ((*sname != *(path_piece[j]))
		  || strcmp(sname, path_piece[j]))
		a_new_match = 0;
	    }

	    if(a_new_match && ((i >= 0) || (j < 0))){
	      lastfound = sp;
	      ++nmatch;
	    }
d2158 1
a2158 1
	if( nmatch <= 0 )  {
d2163 9
a2171 3
	if( nmatch > 1 )  {
	  Tcl_AppendResult(interp, argv[1], " multiply referenced\n", (char *)NULL);
	  goto bail_out;
d2231 1
d2241 11
d2265 14
a2278 1
  return f_ill(clientData, interp, argc, argv);	/* Illuminate named solid --> ST_S_EDIT */
@


11.150
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.149 2000/09/08 05:55:47 mike Exp $ (BRL)";
d83 2
a942 1
      bzero( (char *)&ts, sizeof( ts ) );
d944 1
a944 1

d946 1
@


11.149
log
@
Tree routines now need resource structure.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.148 2000/09/07 02:23:43 mike Exp $ (BRL)";
d905 1
a905 1
	    verbose, base2local ) < 0 )
d962 1
a962 1
      if (intern.idb_meth->ft_describe(&str, &intern, 99, base2local) < 0)
@


11.148
log
@
Added externs to ged.h to fix lint
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.147 2000/08/31 01:28:08 mike Exp $ (BRL)";
d896 1
a896 1
	if( (id = rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL )) < 0 )  {
d907 1
a907 1
	rt_db_free_internal( &intern );
d952 1
a952 1
      if (rt_db_get_internal(&intern, dp, dbip, ts.ts_mat) < 0) {
d964 1
a964 1
    	rt_db_free_internal( &intern );
@


11.147
log
@
Fixed lint, added comments.
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.146 2000/08/19 03:10:11 mike Exp $ (BRL)";
a170 2
BU_EXTERN(int	edit_com, (int argc, char **argv, int kind, int catch_sigint));

d172 6
a177 6
eraseobjpath(interp, argc, argv, noisy, all)
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
     int	noisy;	
     int	all;
d240 5
a244 5
f_erase(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d265 5
a269 5
f_erase_all(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d417 5
a421 5
f_edit(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d547 5
a551 5
edit_com(argc, argv, kind, catch_sigint)
     int	argc;
     char	**argv;
     int	kind;
     int	catch_sigint;
d1147 5
a1151 5
f_zap(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d2165 5
a2169 5
f_sed(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d3524 6
a3529 6
knob_rot(rvec, origin, model_flag, view_flag, edit_flag)
vect_t rvec;
char origin;
int model_flag;
int view_flag;
int edit_flag;
d4738 1
a4738 2
view_ring_destroy(dlp)
struct dm_list *dlp;
d5137 3
a5139 3
mged_erot_xyz(origin, rvec)
char origin;
vect_t rvec;
d5248 4
a5251 4
mged_vrot_xyz(origin, coords, rvec)
char origin;
char coords;
vect_t rvec;
d5447 1
a5447 2
mged_etran(pt)
point_t pt;
d5449 1
d5456 1
d5462 2
a5463 2
    VSCALE(pt, pt, local2base);
    MAT4X3PNT(delta, acc_rot_sol, pt);
d5467 2
a5468 2
    VSCALE(pt, pt, local2base/view_state->vs_Viewscale);
    MAT4X3PNT(work, view_state->vs_view2model, pt);
d5497 1
a5497 2
mged_otran(tvec)
vect_t tvec;
d5510 1
a5510 2
mged_mtran(tvec)
vect_t tvec;
d5528 1
a5528 2
mged_vtran(tvec)
vect_t tvec;
d5530 1
d5535 2
a5536 2
  VSCALE(tvec, tvec, local2base/view_state->vs_Viewscale);
  MAT4X3PNT(work, view_state->vs_view2model, tvec);
d5551 1
a5551 2
mged_tran(tvec)
vect_t tvec;
@


11.146
log
@
Reduced use of MAXARGS
@
text
@d56 1
a56 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.145 2000/06/30 19:52:01 mike Exp $ (BRL)";
a247 2
	register int i;

d266 1
a272 3
  register struct directory *dp;
  register int i;

a554 2
	register struct directory *dp;
	register int	i;
d912 3
d965 1
a965 1
	Tcl_AppendResult(interp, dp->d_namep, ": describe error\n", (char *)NULL);
d982 1
a982 1
 *  List object information, verbose
d1023 1
a1023 1
   * so we better be in and edit state.
d1026 1
a1026 1
      argc == 2 && recurse) {
d1353 1
d1691 1
d1947 1
a1947 1
      bu_vls_printf(&vls, "%s ", sp->s_path[sp->s_last]->d_namep);
@


11.145
log
@
Tidybowl.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144 2000/06/08 21:34:04 bparker Exp $ (BRL)";
d60 6
a66 1
#include <stdio.h>
d252 1
a252 1
	if (argc < 2 || MAXARGS < argc) {
d279 1
a279 1
  if(argc < 2 || MAXARGS < argc){
d404 1
a404 1
  if(argc < 2 || MAXARGS < argc){
d429 1
a429 1
  if(argc < 2 || MAXARGS < argc){
d450 1
a450 1
  if(argc < 2 || MAXARGS < argc){
d482 1
a482 1
  if(argc < 2 || MAXARGS < argc){
d1000 1
a1000 1
  if(MAXARGS < argc){
d1090 1
a1090 1
  if(argc < 2 || MAXARGS < argc){
d2386 1
a2386 1
  if(argc < 1 || MAXARGS < argc){
d5324 1
@


11.144
log
@Mod to mged_escale() (i.e. es_mat no longer
being applied again to es_keypoint).

Mod to usejoy() - since usejoy is only being called
by f_qvrot to change view orientation, there is
no need to inquire about edit states.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.143 2000/05/26 16:10:22 bparker Exp $ (BRL)";
d910 1
a910 1
	rt_functab[id].ft_ifree( &intern );
a923 1
  int id;
d952 1
a952 1
      if ((id = rt_db_get_internal(&intern, dp, dbip, ts.ts_mat)) < 0) {
d962 1
a962 1
      if (rt_functab[id].ft_describe(&str, &intern, 99, base2local) < 0)
d964 1
a964 2

      rt_functab[id].ft_ifree( &intern );
@


11.144.2.1
log
@Add -i option to f_ill() for specifying which
member instance/reference if more than one exists.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144 2000/06/08 21:34:04 bparker Exp $ (BRL)";
a2024 2
	int	c;
	int	ri = 0;
a2032 1
#if 0
a2046 40
	} 
#else
	if (argc < 2 || 5 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help ill");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_optind = 1;
	while ((c = bu_getopt(argc, argv, "i:n")) != EOF) {
		switch (c) {
		case 'n':
			illum_only = 1;
			break;
		case 'i':
			sscanf(bu_optarg, "%d", &ri);
			if (ri <= 0) {
				Tcl_AppendResult(interp,
						 "the reference index must be greater than 0\n",
						 (char *)NULL);
				return TCL_ERROR;
			}

			break;
		default:
		case 'h':
			{
				struct bu_vls vls;

				bu_vls_init(&vls);
				bu_vls_printf(&vls, "help ill");
				Tcl_Eval(interp, bu_vls_addr(&vls));
				bu_vls_free(&vls);
				return TCL_ERROR;
			}
		}
a2048 5
	argc -= (bu_optind - 1);
	argv += (bu_optind - 1);
#endif


d2087 15
a2101 17
	  if (nmatch == 0 || nmatch != ri) {
		  i = sp -> s_last;
		  if (sp -> s_path[i] == dp) {
			  a_new_match = 1;
			  j = nm_pieces - 1;
			  for (; a_new_match && (i >= 0) && (j >= 0); --i, --j) {
				  sname = sp -> s_path[i] -> d_namep;
				  if ((*sname != *(path_piece[j]))
				      || strcmp(sname, path_piece[j]))
					  a_new_match = 0;
			  }

			  if (a_new_match && ((i >= 0) || (j < 0))) {
				  lastfound = sp;
				  ++nmatch;
			  }
		  }
d2107 1
a2107 1
	if (nmatch == 0) {
d2112 3
a2114 9
	/* preserve same old behavior */
	if (nmatch > 1 && ri == 0) {
		Tcl_AppendResult(interp, argv[1], " multiply referenced\n", (char *)NULL);
		goto bail_out;
	} else if (ri != 0 && ri != nmatch) {
		Tcl_AppendResult(interp,
				 "the reference index must be less than the number of references\n",
				 (char *)NULL);
		goto bail_out;
a2173 1
#if 0
a2182 11
#else
  if (argc < 2 || 5 < argc) {
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help sed");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
  }
#endif
@


11.144.2.2
log
@Mods to f_sed() to return result from f_ill().
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.1 2000/10/11 16:19:47 bparker Exp $ (BRL)";
d2264 1
a2264 14

  /* Illuminate named solid --> ST_S_EDIT */
  if (f_ill(clientData, interp, argc, argv) == TCL_ERROR) {
	  Tcl_Obj *save_result;

	  save_result = Tcl_GetObjResult(interp);
	  Tcl_IncrRefCount(save_result);
	  be_reject(clientData, interp, 0, argv);
	  Tcl_SetObjResult(interp, save_result);
	  Tcl_DecrRefCount(save_result);
	  return TCL_ERROR;
  }

  return TCL_OK;
@


11.144.2.3
log
@Use button(BE_REJECT) instead of be_reject()
in f_sed()
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.2 2000/10/12 16:17:09 bparker Exp $ (BRL)";
d2271 1
a2271 1
	  button(BE_REJECT);
@


11.144.2.4
log
@New command (autosize) for setting the view size
and center such that all displayed solids are in view.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.3 2000/10/18 14:01:32 bparker Exp $ (BRL)";
a619 45
	return TCL_OK;
}

int
f_autosize(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
	register struct cmd_list *save_cmd_list;

	if (argc != 1) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help autosize");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	save_dmlp = curr_dm_list;
	save_cmd_list = curr_cmd_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
		struct view_ring *vrp;

		curr_dm_list = dmlp;
		if (curr_dm_list->dml_tie)
			curr_cmd_list = curr_dm_list->dml_tie;
		else
			curr_cmd_list = &head_cmd_list;

		size_reset();
		new_mats();
		(void)mged_svbase();

		for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
			vrp->vr_scale = view_state->vs_Viewscale;
	}
	curr_dm_list = save_dmlp;
	curr_cmd_list = save_cmd_list;

@


11.144.2.5
log
@Change autosize to autoview.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.4 2001/01/03 21:09:14 bparker Exp $ (BRL)";
d624 1
a624 1
f_autoview(clientData, interp, argc, argv)
d638 1
a638 1
		bu_vls_printf(&vls, "help autoview");
@


11.144.2.6
log
@Mods that check if dbip==DBI_NULL
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.5 2001/01/04 17:00:28 bparker Exp $ (BRL)";
a1408 2
  CHECK_DBI_NULL;

a4470 2
  CHECK_DBI_NULL;

a4511 2
  CHECK_DBI_NULL;

a4554 2
  CHECK_DBI_NULL;

a4602 2
  CHECK_DBI_NULL;

a4651 2
  CHECK_DBI_NULL;

a4696 2
  CHECK_DBI_NULL;

a5702 2

  CHECK_DBI_NULL;
@


11.144.2.7
log
@*- mods that save the Tcl result string and
   restore it after a Tcl_Eval.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.6 2001/02/09 15:26:31 bparker Exp $ (BRL)";
a191 1
#if 0
a197 19
#else
		{
			char *begin;
			char *end;
			char *newstr = strdup(argv[i]);

			begin = newstr;
			bu_vls_trunc(&vls, 0);

			while ((end = strchr(begin, '/')) != NULL) {
				*end = '\0';
				bu_vls_printf(&vls, "%s ", begin);
				begin = end + 1;
			}
			bu_vls_printf(&vls, "%s ", begin);
			free((void *)newstr);
		}
		list = bu_vls_addr(&vls);
#endif
@


11.144.2.8
log
@*- add include for string(s).h
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.7 2001/02/23 20:23:09 bparker Exp $ (BRL)";
a58 5
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
@


11.144.2.9
log
@*- mods to mged/chgview.c/mged_escale() to fix
   bug that shows up while doing a matrix scale
   of X, Y or Z.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.8 2001/03/02 18:29:06 bparker Exp $ (BRL)";
d5822 1
a5822 1
      smat[0] = sfactor;
d5824 1
a5824 1
      acc_sc[X] *= sfactor;
d5832 1
a5832 1
      smat[5] = sfactor;
d5834 1
a5834 1
      acc_sc[Y] *= sfactor;
d5842 1
a5842 1
      smat[10] = sfactor;
d5844 1
a5844 1
      acc_sc[Z] *= sfactor;
@


11.144.2.10
log
@Backporting bug fixes for release 5.4
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.144.2.9 2001/04/17 18:55:04 bparker Exp $ (BRL)";
d5822 1
a5822 1
      smat[0] = inv_sfactor;
d5824 1
a5824 1
      acc_sc[X] *= inv_sfactor;
d5832 1
a5832 1
      smat[5] = inv_sfactor;
d5834 1
a5834 1
      acc_sc[Y] *= inv_sfactor;
d5842 1
a5842 1
      smat[10] = inv_sfactor;
d5844 1
a5844 1
      acc_sc[Z] *= inv_sfactor;
@


11.143
log
@*- use the DIR_NULL macro
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.142 2000/05/26 14:24:35 bparker Exp $ (BRL)";
d4108 1
d4116 1
d5700 1
d5702 3
@


11.142
log
@*- mods to eraseobj and eraseobjall to
   handle paths
*- new procedure, eraseobjpath, that
   builds up an array of directory pointers
   to pass to eraseobj or eraseobjall
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.141 2000/01/06 22:06:54 mike Exp $ (BRL)";
d1805 1
a1805 1
	for (tmp_dpp = dpp; *tmp_dpp != (struct directory *)NULL; ++tmp_dpp)
d1874 1
a1874 1
	for (tmp_dpp = dpp; *tmp_dpp != (struct directory *)NULL; ++tmp_dpp)
@


11.141
log
@
Changed uses of rt_units_* routines to bu_units_*
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.140 1999/12/30 19:26:41 jra Exp $ (BRL)";
d168 66
d243 1
a243 2
  register struct directory *dp;
  register int i;
d245 1
a245 1
  CHECK_DBI_NULL;
d247 2
a248 2
  if(argc < 2 || MAXARGS < argc){
    struct bu_vls vls;
d250 6
a255 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d257 2
a258 4
  for( i = 1; i < argc; i++ )  {
    if( (dp = db_lookup( dbip,  argv[i], LOOKUP_NOISY )) != DIR_NULL )
      eraseobj(dp);
  }
d260 1
a260 3
  solid_list_callback();

  return TCL_OK;
d284 1
a284 5
  for( i = 1; i < argc; i++ )  {
    if( (dp = db_lookup( dbip,  argv[i], LOOKUP_NOISY )) != DIR_NULL )
      eraseobjall(dp);
  }

d549 13
a561 13
int	argc;
char	**argv;
int	kind;
int	catch_sigint;
{
  register struct directory *dp;
  register int	i;
  register struct dm_list *dmlp;
  register struct dm_list *save_dmlp;
  register struct cmd_list *save_cmd_list;
  double		elapsed_time;
  int		initial_blank_screen;
  struct bu_vls vls;
d563 1
a563 1
  CHECK_DBI_NULL;
d565 2
a566 2
  bu_vls_init(&vls);
  initial_blank_screen = BU_LIST_IS_EMPTY(&HeadSolid.l);
d568 4
a571 8
  /*  First, delete any mention of these objects.
   *  Silently skip any leading options (which start with minus signs).
   */
  for( i = 1; i < argc; i++ )  {
    if( (dp = db_lookup( dbip,  argv[i], LOOKUP_QUIET )) != DIR_NULL )  {
      eraseobj( dp );
    }
  }
d573 1
a573 1
  update_views = 1;
d575 6
a580 6
  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3);	/* allow interupts */
  else {
    bu_vls_free(&vls);
    return TCL_OK;
  }
d582 22
a603 4
  nvectors = 0;
  rt_prep_timer();
  drawtrees( argc, argv, kind );
  (void)rt_get_timer( (struct bu_vls *)0, &elapsed_time );
d605 4
a608 8
  save_dmlp = curr_dm_list;
  save_cmd_list = curr_cmd_list;
  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
    curr_dm_list = dmlp;
    if(curr_dm_list->dml_tie)
      curr_cmd_list = curr_dm_list->dml_tie;
    else
      curr_cmd_list = &head_cmd_list;
d610 3
a612 4
    /* If we went from blank screen to non-blank, resize */
    if (mged_variables->mv_autosize  && initial_blank_screen &&
	BU_LIST_NON_EMPTY(&HeadSolid.l)) {
      struct view_ring *vrp;
d614 2
a615 3
      size_reset();
      new_mats();
      (void)mged_svbase();
d617 4
a620 16
      for(BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
	vrp->vr_scale = view_state->vs_Viewscale;
    }
  }

  color_soltab();
  curr_dm_list = save_dmlp;
  curr_cmd_list = save_cmd_list;

  bu_vls_printf(&vls, "%ld vectors in %g sec\n", nvectors, elapsed_time);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

  bu_vls_free(&vls);
  (void)signal( SIGINT, SIG_IGN );
  solid_list_callback();
  return TCL_OK;
d1788 2
a1789 2
 * This routine goes through the solid table and deletes all displays
 * which contain the specified object in their 'path'
d1792 2
a1793 2
eraseobjall( dp )
register struct directory *dp;
d1795 9
a1803 3
  register struct solid *sp;
  static struct solid *nsp;
  register int i;
d1805 2
a1806 2
  if(dbip == DBI_NULL)
    return;
d1808 14
a1821 1
  update_views = 1;
d1823 2
a1824 6
  RT_CK_DIR(dp);
  sp = BU_LIST_NEXT(solid, &HeadSolid.l);
  while(BU_LIST_NOT_HEAD(sp, &HeadSolid.l)){
    nsp = BU_LIST_PNEXT(solid, sp);
    for( i=0; i<=sp->s_last; i++ )  {
      if( sp->s_path[i] != dp )  continue;
d1827 1
a1827 1
      freeDListsAll(sp->s_dlist, 1);
d1830 2
a1831 4
      if( state != ST_VIEW && illump == sp )
	button( BE_REJECT );
      BU_LIST_DEQUEUE(&sp->l);
      FREE_SOLID(sp, &FreeSolid.l);
d1833 8
a1840 4
      break;
    }
    sp = nsp;
  }
d1842 5
a1846 5
  if( dp->d_addr == RT_DIR_PHONY_ADDR )  {
    if( db_dirdelete( dbip, dp ) < 0 )  {
      Tcl_AppendResult(interp, "eraseobjall: db_dirdelete failed\n", (char *)NULL);
    }
  }
d1853 3
a1855 1
 * This routine removes only the specified object from the solid list
d1858 2
a1859 2
eraseobj( dp )
register struct directory *dp;
d1861 4
a1864 2
  register struct solid *sp;
  register struct solid *nsp;
d1866 5
a1870 2
  if(dbip == DBI_NULL)
    return;
d1872 4
a1875 2
  update_views = 1;
  RT_CK_DIR(dp);
d1877 12
a1888 7
  sp = BU_LIST_FIRST(solid, &HeadSolid.l);
  while(BU_LIST_NOT_HEAD(sp, &HeadSolid.l)){
    nsp = BU_LIST_PNEXT(solid, sp);
    if(*sp->s_path != dp){
      sp = nsp;
      continue;
    }
d1891 1
a1891 1
    freeDListsAll(sp->s_dlist, 1);
d1894 2
a1895 2
    if(state != ST_VIEW && illump == sp)
      button( BE_REJECT );
d1897 5
a1901 4
    BU_LIST_DEQUEUE(&sp->l);
    FREE_SOLID(sp, &FreeSolid.l);
    sp = nsp;
  }
d1903 5
a1907 5
  if( dp->d_addr == RT_DIR_PHONY_ADDR ){
    if( db_dirdelete( dbip, dp ) < 0 ){
      Tcl_AppendResult(interp, "eraseobj: db_dirdelete failed\n", (char *)NULL);
    }
  }
@


11.140
log
@Eliminated some unused variables
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.139 1999/11/26 23:03:30 mike Exp $ (BRL)";
d3499 1
a3499 1
			  rt_units_string(dbip->dbi_local2base) );
d3542 1
a3542 1
			   mged_tol.dist*base2local, rt_units_string(local2base), mged_tol.perp,
@


11.139
log
@
Lint
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.138 1999/10/29 14:58:20 bparker Exp $ (BRL)";
a178 2
  register struct dm_list *dmlp;
  register struct dm_list *save_dmlp;
a209 2
  register struct dm_list *dmlp;
  register struct dm_list *save_dmlp;
a1103 1
	register struct dm_list *dmlp;
a1665 1
  char *av[5];
a1705 1
  struct bu_vls vls;
a1744 1
  register struct dm_list *dmlp;
a1790 1
  register struct dm_list *dmlp;
a2287 1
  char  knob_val_pair[128];
a2294 1
  struct bu_vls vls;
a3424 5
  point_t new_pos;
  point_t diff;
  point_t model_pos;
  point_t view_pos;

a3611 2
  vect_t new_pos;

a3640 2
  vect_t new_pos;

a3800 1
    char	*copy;
a4076 3
  point_t model_pos;
  point_t temp;

a4100 1
  vect_t temp;
a5015 1
    point_t model_pt;
a5016 2
    point_t s_point;
    mat_t temp;
a5107 1
  vect_t new_pos;
@


11.138
log
@*- fixed "MY" bug in cmd_list
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.137 1999/09/09 19:37:04 bparker Exp $ (BRL)";
d850 1
a850 1
	if( (id = rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL )) < 0 )  {
@


11.137
log
@*- mods to cmd_list() to spew out the listing of the
   object currently being edited if no object(s) is/are specified
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.136 1999/09/01 18:55:09 bparker Exp $ (BRL)";
d958 1
a958 1
  if (strcmp(argv[1], "-r") == 0) {
a960 11

    if (illump == SOLID_NULL &&
	argc <= start_arg) {
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help l");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
d972 4
d1002 1
a1002 1
    } else {
d1011 1
a1011 1
  } else {
@


11.136
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.135 1999/07/08 17:44:03 bparker Exp $ (BRL)";
d864 66
a942 3
  register struct directory *dp;
  register int arg;
  struct bu_vls str;
a944 3
  char *listeval="listeval";
  int id;
  struct rt_db_internal intern;
d948 1
a948 1
  if(argc < 2 || MAXARGS < argc){
d958 15
a972 1
  bu_vls_init( &str );
d974 1
d981 1
d983 39
a1021 55
  if( strcmp( argv[1], "-r" ) == 0 )
	{
		recurse = 1;
		start_arg = 2;
	}

  for( arg = start_arg; arg < argc; arg++ )  {
  	if( recurse )
  	{
  		char *tmp_argv[2];

  		tmp_argv[0] = listeval;
  		tmp_argv[1] = argv[arg];

  		f_pathsum( clientData, interp, 2, tmp_argv );
  	}
  	else if( strchr( argv[arg], '/' ) )
  	{
  		struct db_tree_state ts;
  		struct db_full_path path;

  		bzero( (char *)&ts, sizeof( ts ) );
  		db_full_path_init( &path );

  		ts.ts_dbip = dbip;
  		bn_mat_idn(ts.ts_mat);

  		if( db_follow_path_for_state( &ts, &path, argv[arg], 1 ) )
  			continue;

  		dp = DB_FULL_PATH_CUR_DIR( &path );

		if( (id = rt_db_get_internal( &intern, dp, dbip, ts.ts_mat)) < 0 )
		{
			Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
				") failure\n", (char *)NULL );
			continue;
		}

  		db_free_full_path( &path );

		bu_vls_printf( &str, "%s:  ", argv[arg] );

		if( rt_functab[id].ft_describe( &str, &intern, 99, base2local ) < 0 )
  			Tcl_AppendResult(interp, dp->d_namep, ": describe error\n", (char *)NULL);

  		rt_functab[id].ft_ifree( &intern );
  	}
  	else
  	{
	    if( (dp = db_lookup( dbip, argv[arg], LOOKUP_NOISY )) == DIR_NULL )
	      continue;

	    do_list( &str, dp, 99 );	/* very verbose */
 	 }
d1024 1
a1024 3
  Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
  bu_vls_free( &str );

d1026 1
@


11.135
log
@*- modified code so that the rotation and tranlation routines
   consider the constraint coordinate system as well as the
   point about which to rotate.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.134 1999/07/07 17:25:31 bparker Exp $ (BRL)";
d182 1
a182 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d215 1
a215 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d249 1
a249 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d303 1
a303 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d510 1
a510 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d886 1
a886 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d984 1
a984 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d1059 1
a1059 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1118 1
a1118 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d1903 1
a1903 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d2043 1
a2043 3
  if(dbip == DBI_NULL)
    return TCL_OK;

d2255 1
a2255 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d3443 1
a3443 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d4539 1
a4539 2
  if(dbip == DBI_NULL)
    return TCL_OK;
@


11.134
log
@*- mods to mged_etran to transform pt using
   acc_rot_sol when in object edit mode
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.133 1999/07/02 22:18:38 mike Exp $ (BRL)";
d3407 2
d3427 3
a3429 1
    mged_mrot_xyz(origin, rvec);
d3431 1
a3431 1
    mged_vrot_xyz(origin, rvec);
d5027 1
a5027 2
      MAT4X3PNT(model_pt, es_mat, es_keypoint);
      MAT4X3PNT(point, modelchanges, model_pt);
a5053 98
/*
 *                     M G E D _ M R O T
 */
mged_mrot(origin, newrot)
char origin;
mat_t newrot;
{
  static int recurse = 1;
  mat_t invtvc;
  mat_t viewchg, viewchginv;
  point_t new_model_center;
  point_t new_view_center;
  point_t new_origin;
  point_t vrot_pt;
  point_t old_pos, new_pos;
  point_t diff;
  vect_t view_direc, model_direc;

  bn_mat_idn( invtvc );

  if(origin == 'e' || origin == 'm'){
    /* find view direction vector */
    VSET( model_direc, 0.0, 0.0, 1.0 );
    MAT4X3VEC( view_direc, view_state->vs_model2view, model_direc );

    VSET( new_origin, 0.0, 0.0, 0.0 );    /* point in model space */

    /* find view rotation point */
    if(origin == 'e'){
      /*XXXXX rotating in model space about the view eye does not work, yet!!! */
      VSET( vrot_pt, 0.0, 0.0, 1.0 );          /* point to rotate around */
    }else{
      MAT4X3PNT( vrot_pt, view_state->vs_model2view, new_origin ); /* point in view space */
    }

    /* find view rotation matrix */
    wrt_point_direc( viewchg, newrot, bn_mat_identity, vrot_pt, view_direc );
    bn_mat_inv( viewchginv, viewchg );

    /* find new toViewcenter */
    MAT4X3PNT( new_view_center, viewchginv, new_origin );
    MAT4X3PNT( new_model_center, view_state->vs_view2model, new_view_center );
    MAT_DELTAS_VEC_NEG( view_state->vs_toViewcenter, new_model_center );

    /* find new view2model  ---  used to find new model2view */
    bn_mat_mul2( newrot, view_state->vs_view2model );

    /* find inverse of toViewcenter  ---  used to find new Viewrot */
    MAT_DELTAS_VEC( invtvc, new_model_center );

    /* find new model2view  --- used to find new Viewrot */
    bn_mat_inv( view_state->vs_model2view, view_state->vs_view2model );
    view_state->vs_model2view[15] = 1.0;

    /* find new Viewrot */
    bn_mat_mul( view_state->vs_Viewrot, view_state->vs_model2view, invtvc );

    view_state->vs_Viewrot[3] = 0.0;
    view_state->vs_Viewrot[7] = 0.0;
    view_state->vs_Viewrot[11] = 0.0;

    /* recalculate toViewcenter */
    bn_mat_inv( viewchginv, view_state->vs_Viewrot );
    bn_mat_mul( view_state->vs_toViewcenter, viewchginv, view_state->vs_model2view );
  }else{
    /* find new view2model  ---  used to find new model2view */
    wrt_view( view_state->vs_view2model, newrot, view_state->vs_view2model);

    /* find inverse of toViewcenter  ---  used to find new Viewrot */
    MAT_DELTAS( invtvc, -view_state->vs_toViewcenter[MDX], -view_state->vs_toViewcenter[MDY], -view_state->vs_toViewcenter[MDZ] );

    /* find new model2view  --- used to find new Viewrot */
    bn_mat_inv( view_state->vs_model2view, view_state->vs_view2model );
    view_state->vs_model2view[15] = 1.0;

    /* find new Viewrot */
    bn_mat_mul( view_state->vs_Viewrot, view_state->vs_model2view, invtvc );
  }

  new_mats();
  set_absolute_tran();

  return TCL_OK;
}

int
mged_mrot_xyz(origin, rvec)
char origin;
vect_t rvec;
{
  mat_t newrot;

  bn_mat_idn(newrot);
  buildHrot(newrot, -rvec[X]*degtorad, -rvec[Y]*degtorad, -rvec[Z]*degtorad);

  return mged_mrot(origin, newrot);
}

d5088 1
a5088 1
  return mged_mrot_xyz(mged_variables->mv_rotate_about, rvec);
d5104 1
a5104 1
  if(origin == 'e' || origin == 'm'){
d5114 8
d5125 1
a5125 1
      MAT4X3PNT( rot_pt, view_state->vs_model2view, new_origin);  /* point to rotate around */
d5140 1
a5140 7

    /* Update the rotation component of the model2view matrix */
    bn_mat_mul2( newrot, view_state->vs_Viewrot );			/* pure rotation */
    new_mats();

    set_absolute_tran();
  } else {
d5144 3
a5146 3
    /* Update the rotation component of the model2view matrix */
    bn_mat_mul2( newrot, view_state->vs_Viewrot );			/* pure rotation */
    new_mats();
d5148 1
a5148 6
    if(view_state->vs_absolute_tran[X] != 0.0 ||
       view_state->vs_absolute_tran[Y] != 0.0 ||
       view_state->vs_absolute_tran[Z] != 0.0){
      set_absolute_tran();
    }
  }
d5154 1
a5154 1
mged_vrot_xyz(origin, rvec)
d5156 1
d5160 1
d5165 19
d5223 1
a5223 1
  return mged_vrot_xyz(mged_variables->mv_rotate_about, rvec);
d5235 8
a5242 2
  if(mged_variables->mv_coords == 'm')
    return mged_mrot(origin, newrot);
d5401 14
d5429 1
a5429 1

d5467 3
@


11.133
log
@
Removed dependence on compat4.h
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.132 1999/05/15 08:04:34 mike Exp $ (BRL)";
d5434 2
d5437 2
a5438 1
    VSCALE(delta, pt, local2base);
@


11.132
log
@Allow change of units even if database is read-only.
Have "center" command echo back current setting, so it can be used
in Tcl scripts.  Have "center" command without args print current center
in current units, also for use in Tcl scripts.
Have "overlay" command echo back list of phantom-solids created,
for use in Tcl scripts.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.131 1999/05/11 17:00:31 bparker Exp $ (BRL)";
d938 1
a938 1
  		mat_idn(ts.ts_mat);
d1028 1
a1028 1
 *  To return all the free "struct rt_vlist" and "struct solid" items
d1038 1
a1038 1
  register struct rt_vlist	*vp;
d1046 1
a1046 1
    vp = BU_LIST_FIRST( rt_vlist, &rt_g.rtg_vlfree );
d1048 1
a1048 1
    bu_free( (genptr_t)vp, "mged_freemem: struct rt_vlist" );
d1806 1
a1806 1
  register struct rt_vlist	*vp;
d1864 1
a1864 1
    for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d1870 1
a1870 1
      RT_CK_VLIST( vp );
d4573 1
a4573 1
  mat_ae_vec( &new_az, &new_el, dir );
@


11.131
log
@*- modified solid_list_callback() to save the result object
   and restore it after the call to Tcl_Eval
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.130 1999/05/10 20:17:43 mike Exp $ (BRL)";
d248 1
d254 1
a254 1
  if(argc < 4 || 4 < argc){
d264 8
a271 2
  /* center assumed to be in local units */
  VSET(center, atof(argv[1]), atof(argv[2]), atof(argv[3]));
d273 8
a280 3
  /* must convert to base units */
  VSCALE(center, center, local2base);
  mged_center(center);
@


11.130
log
@Enhanced debugging output to show D, U, and C flags.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.129 1999/05/10 19:08:36 mike Exp $ (BRL)";
d571 1
d573 4
d581 4
@


11.129
log
@Improved readability of debug output.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.128 1999/04/16 18:00:02 bparker Exp $ (BRL)";
d1827 1
a1827 1
    bu_vls_printf(&vls, "  basecolor=(%d,%d,%d) color=(%d,%d,%d)\n",
d1833 4
a1836 1
		  sp->s_color[2]);
@


11.128
log
@*- call solid_list_callback whenever the solid
   list gets changed.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.127 1999/02/08 21:52:52 bparker Exp $ (BRL)";
d1827 1
a1827 1
    bu_vls_printf(&vls, "  color=(%d,%d,%d) %d,%d,%d\n",
@


11.127
log
@*- mods to f_knob() to repair wrong behavior during
   edit rotations
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.126 1999/01/28 21:39:08 jra Exp $ (BRL)";
d83 1
d200 2
d234 2
d563 1
d567 11
d1092 1
@


11.126
log
@Th 'l' command now has a "-r" option and accepts paths.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.125 1999/01/27 21:15:45 jra Exp $ (BRL)";
d2745 1
a2745 1
	    edit_absolute_model_rotate[X] += f;
d2749 1
a2749 1
	    edit_absolute_object_rotate[X] += f;
d2753 1
a2753 1
	    edit_absolute_view_rotate[X] += f;
d2766 1
a2766 1
	  
d2846 1
a2846 1
	    edit_absolute_model_rotate[Y] += f;
d2850 1
a2850 1
	    edit_absolute_object_rotate[Y] += f;
d2854 1
a2854 1
	    edit_absolute_view_rotate[Y] += f;
d2867 1
a2867 1
	  
d2947 1
a2947 1
	    edit_absolute_model_rotate[Z] += f;
d2951 1
a2951 1
	    edit_absolute_object_rotate[Z] += f;
d2955 1
a2955 1
	    edit_absolute_view_rotate[Z] += f;
d2968 1
a2968 1
	  
@


11.125
log
@"l" command now accepts paths
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.124 1999/01/21 18:26:37 bparker Exp $ (BRL)";
d847 2
d850 2
d875 8
a882 2
  for( arg = 1; arg < argc; arg++ )  {
  	if( strchr( argv[arg], '/' ) )
d891 32
d929 1
a929 1
  	}
@


11.124
log
@*- call helpdevel for help on developer commands
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.123 1999/01/12 18:20:57 bparker Exp $ (BRL)";
d847 1
d872 13
a884 2
    if( (dp = db_lookup( dbip, argv[arg], LOOKUP_NOISY )) == DIR_NULL )
      continue;
d886 2
a887 1
    do_list( &str, dp, 99 );	/* very verbose */
@


11.123
log
@*- code to support sharing display lists
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.122 1998/12/29 20:42:08 bparker Exp $ (BRL)";
d3845 1
a3845 1
    bu_vls_printf(&vls, "help svb");
d4068 1
a4068 1
	  bu_vls_printf(&vls, "help model2view");
d4109 1
a4109 1
	  bu_vls_printf(&vls, "help view2model");
d4147 1
a4147 1
    bu_vls_printf(&vls, "help model2view_lu");
d4188 1
a4188 1
    bu_vls_printf(&vls, "help view2model_lu");
d4231 1
a4231 1
    bu_vls_printf(&vls, "help model2grid_lu");
d4279 1
a4279 1
    bu_vls_printf(&vls, "help f_grid2model_lu");
d4328 1
a4328 1
    bu_vls_printf(&vls, "help f_view2grid_lu");
d4373 1
a4373 1
    bu_vls_printf(&vls, "help f_grid2view_lu");
d4418 1
a4418 1
    bu_vls_printf(&vls, "help f_view2model_vec");
d4577 1
a4577 1
    bu_vls_printf(&vls, "help view_ring");
@


11.122
log
@*- mods to view_ring_init
*- cleanup/remove old view_ring routines
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.121 1998/11/06 22:09:33 bparker Exp $ (BRL)";
a198 11
#ifdef DO_SINGLE_DISPLAY_LIST
  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
    if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
      save_dmlp = curr_dm_list;
      curr_dm_list = dmlp;
      createDList(&HeadSolid);
      curr_dm_list = save_dmlp;
    }
  }
#endif

a230 11
#ifdef DO_SINGLE_DISPLAY_LIST
  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
    if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
      save_dmlp = curr_dm_list;
      curr_dm_list = dmlp;
      createDList(&HeadSolid);
      curr_dm_list = save_dmlp;
    }
  }
#endif

a546 4

#ifdef DO_SINGLE_DISPLAY_LIST
    createDList(&HeadSolid);
#endif
d993 3
a995 13
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist &&
	     dmlp->dml_mged_variables->mv_dlist &&
	     BU_LIST_NON_EMPTY(&HeadSolid.l))
#ifdef DO_SINGLE_DISPLAY_LIST
	    DM_FREEDLISTS(dmlp->dml_dmp, 1, 1);
#else
	    DM_FREEDLISTS(dmlp->dml_dmp,
				      BU_LIST_FIRST(solid, &HeadSolid.l)->s_dlist,
				      BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist -
				      BU_LIST_FIRST(solid, &HeadSolid.l)->s_dlist + 1);
#endif
	}
d1630 1
a1630 8
#ifdef DO_SINGLE_DISPLAY_LIST
    /* do nothing here */
#else
      FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist)
	  DM_FREEDLISTS(dmlp->dml_dmp, sp->s_dlist, 1);
      }
#endif
d1679 1
a1679 8
#ifdef DO_SINGLE_DISPLAY_LIST
    /* do nothing here */
#else
    FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
      if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist)
	DM_FREEDLISTS(dmlp->dml_dmp, sp->s_dlist, 1);
    }
#endif
@


11.121
log
@*- use new structures
*- view_ring command
*- cleanup
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.120 1998/10/22 18:49:35 bparker Exp $ (BRL)";
d4541 3
d4545 3
a4547 2
view_ring_init(dlp)
struct dm_list *dlp;
d4549 31
a4579 1
  struct view_ring *vrp;
d4581 4
a4584 7
  BU_LIST_INIT(&dlp->dml_view_state->vs_headView.l);
  BU_GETSTRUCT(vrp, view_ring);
  BU_LIST_APPEND(&dlp->dml_view_state->vs_headView.l, &vrp->l);

  vrp->vr_id = 1;
  dlp->dml_view_state->vs_current_view = vrp;
  dlp->dml_view_state->vs_last_view = vrp;
a4904 344
}


int
f_add_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  struct view_ring *vrp;
  struct view_ring *lv;
  struct bu_vls vls;

  if(argc != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help add_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* save current Viewrot */
  bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

  /* save current toViewcenter */
  bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

  /* save current Viewscale */
  view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;

  /* allocate memory and append to list */
  BU_GETSTRUCT(vrp, view_ring);
  lv = BU_LIST_LAST(view_ring, &view_state->vs_headView.l);
  BU_LIST_APPEND(&lv->l, &vrp->l);

  /* assign a view number */
  vrp->vr_id = lv->vr_id + 1;

  view_state->vs_last_view = view_state->vs_current_view;
  view_state->vs_current_view = vrp;
  (void)mged_svbase();

  return TCL_OK;
}


int
f_delete_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  int n;
  struct view_ring *vrp;

  struct bu_vls vls;

  if(argc != 2){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help delete_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* search for view with id of n */
  n = atoi(argv[1]);
  for(BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)){
    if(vrp->vr_id == n)
      break;
  }

  if(BU_LIST_IS_HEAD(vrp, &view_state->vs_headView.l)){
    Tcl_AppendResult(interp, "delete_view: ", argv[1], " is not a valid view\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  /* check to see if this is the last view in the list */
  if(BU_LIST_IS_HEAD(vrp->l.forw, &view_state->vs_headView.l) &&
     BU_LIST_IS_HEAD(vrp->l.back, &view_state->vs_headView.l)){
    Tcl_AppendResult(interp, "delete_view: Cannot delete the only remaining view!\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(vrp == view_state->vs_current_view){
    if(view_state->vs_current_view == view_state->vs_last_view){
      view_state->vs_current_view = BU_LIST_PNEXT(view_ring, view_state->vs_last_view);
      view_state->vs_last_view = view_state->vs_current_view;
    }else
      view_state->vs_current_view = view_state->vs_last_view;

    bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
    bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
    view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;
    new_mats();
    (void)mged_svbase();
  }else if(vrp == view_state->vs_last_view)
    view_state->vs_last_view = view_state->vs_current_view;

  BU_LIST_DEQUEUE(&vrp->l);
  bu_free((genptr_t)vrp, "f_delete_view");

  return TCL_OK;
}


int
f_get_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  struct bu_vls vls;
  struct view_ring *vrp;

  if(argc < 1 || 2 < argc){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help get_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* return current view */
  if(argc == 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%d", view_state->vs_current_view->vr_id);
    Tcl_AppendElement(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(strcmp("-a", argv[1])){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help get_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_vls_init(&vls);
  for(BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)){
    bu_vls_printf(&vls, "%d", vrp->vr_id);
    Tcl_AppendElement(interp, bu_vls_addr(&vls));
    bu_vls_trunc(&vls, 0);
  }

  bu_vls_free(&vls);
  return TCL_OK;
}


int
f_goto_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  int n;
  struct view_ring *vrp;
  struct bu_vls vls;

  if(argc != 2){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help goto_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* search for view with id of n */
  n = atoi(argv[1]);
  for(BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l)){
    if(vrp->vr_id == n)
      break;
  }

  if(BU_LIST_IS_HEAD(vrp, &view_state->vs_headView.l)){
    Tcl_AppendResult(interp, "goto_view: ", argv[1], " is not a valid view\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  /* nothing to do */
  if(vrp == view_state->vs_current_view)
    return TCL_OK;

  /* save current Viewrot */
  bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

  /* save current toViewcenter */
  bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

  /* save current Viewscale */
  view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;

  view_state->vs_last_view = view_state->vs_current_view;
  view_state->vs_current_view = vrp;
  bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
  bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
  view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;

  new_mats();
  (void)mged_svbase();

  return TCL_OK;
}


int
f_next_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  struct bu_vls vls;

  if(argc != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help next_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* check to see if this is the last view in the list */
  if(BU_LIST_IS_HEAD(view_state->vs_current_view->l.forw, &view_state->vs_headView.l) &&
     BU_LIST_IS_HEAD(view_state->vs_current_view->l.back, &view_state->vs_headView.l))
    return TCL_OK;

  /* save current Viewrot */
  bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

  /* save current toViewcenter */
  bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

  /* save current Viewscale */
  view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;

  view_state->vs_last_view = view_state->vs_current_view;
  view_state->vs_current_view = BU_LIST_PNEXT(view_ring, view_state->vs_current_view);
  if(BU_LIST_IS_HEAD(view_state->vs_current_view, &view_state->vs_headView.l))
    view_state->vs_current_view = BU_LIST_FIRST(view_ring, &view_state->vs_headView.l);
  bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
  bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
  view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;

  new_mats();
  (void)mged_svbase();

  return TCL_OK;
}


int
f_prev_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  struct bu_vls vls;

  if(argc != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help prev_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* check to see if this is the last view in the list */
  if(BU_LIST_IS_HEAD(view_state->vs_current_view->l.forw, &view_state->vs_headView.l) &&
     BU_LIST_IS_HEAD(view_state->vs_current_view->l.back, &view_state->vs_headView.l))
    return TCL_OK;

  /* save current Viewrot */
  bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

  /* save current toViewcenter */
  bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

  /* save current Viewscale */
  view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;

  view_state->vs_last_view = view_state->vs_current_view;
  view_state->vs_current_view = BU_LIST_PLAST(view_ring, view_state->vs_current_view);
  if(BU_LIST_IS_HEAD(view_state->vs_current_view, &view_state->vs_headView.l))
    view_state->vs_current_view = BU_LIST_LAST(view_ring, &view_state->vs_headView.l);
  bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
  bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
  view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;

  new_mats();
  (void)mged_svbase();

  return TCL_OK;
}


int
f_toggle_view(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  struct view_ring *save_last_view;
  struct bu_vls vls;

  if(argc != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help toggle_view");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* save current Viewrot */
  bn_mat_copy(view_state->vs_current_view->vr_rot_mat, view_state->vs_Viewrot);

  /* save current toViewcenter */
  bn_mat_copy(view_state->vs_current_view->vr_tvc_mat, view_state->vs_toViewcenter);

  /* save current Viewscale */
  view_state->vs_current_view->vr_scale = view_state->vs_Viewscale;

  save_last_view = view_state->vs_last_view;
  view_state->vs_last_view = view_state->vs_current_view;
  view_state->vs_current_view = save_last_view;
  bn_mat_copy(view_state->vs_Viewrot, view_state->vs_current_view->vr_rot_mat);
  bn_mat_copy(view_state->vs_toViewcenter, view_state->vs_current_view->vr_tvc_mat);
  view_state->vs_Viewscale = view_state->vs_current_view->vr_scale;

  new_mats();
  (void)mged_svbase();

  return TCL_OK;
@


11.120
log
@*- add support for level -2 in the "x" command
	This level prints only the leaves.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.119 1998/10/21 17:26:28 bparker Exp $ (BRL)";
a77 1
extern int mged_param();
a78 1
extern void set_scroll();   /* defined in set.c */
d201 1
a201 1
    if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
d244 1
a244 1
    if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
a289 3
/*
 * Center assumed to be in local units.
 */
d294 1
a294 1
  MAT_DELTAS_VEC_NEG(toViewcenter, center);
a297 4

#ifdef DO_SCROLL_UPDATES
  set_scroll();
#endif
d326 1
a326 1
  Viewscale = f * 0.5 * local2base;
d329 7
a335 7
  absolute_scale = 1.0 - Viewscale / i_Viewscale;
  if(absolute_scale < 0.0)
    absolute_scale /= 9.0;

  if(absolute_tran[X] != 0.0 ||
     absolute_tran[Y] != 0.0 ||
     absolute_tran[Z] != 0.0)
d489 5
a493 5
	bn_mat_idn( toViewcenter );
	MAT_DELTAS( toViewcenter, -center[X], -center[Y], -center[Z] );
	Viewscale = radial[X];
	V_MAX( Viewscale, radial[Y] );
	V_MAX( Viewscale, radial[Z] );
d495 1
a495 1
	i_Viewscale = Viewscale;
d552 2
a553 2
    if(curr_dm_list->aim)
      curr_cmd_list = curr_dm_list->aim;
d558 1
a558 1
    if (mged_variables->autosize  && initial_blank_screen &&
d560 1
a560 1
      struct view_list *vlp;
d566 2
a567 6
#ifdef DO_SCROLL_UPDATES
      set_scroll();
#endif

      for(BU_LIST_FOR(vlp, view_list, &headView.l))
	vlp->vscale = Viewscale;
d1020 2
a1021 2
	  if(dmlp->_dmp->dm_displaylist &&
	     dmlp->_mged_variables->dlist &&
d1024 1
a1024 1
	    DM_FREEDLISTS(dmlp->_dmp, 1, 1);
d1026 1
a1026 1
	    DM_FREEDLISTS(dmlp->_dmp,
d1086 1
a1086 1
    bu_log("Viewscale=%f (%f mm)\n", Viewscale*base2local, Viewscale);
d1088 4
a1091 4
    bn_mat_print("toViewcenter", toViewcenter);
    bn_mat_print("Viewrot", Viewrot);
    bn_mat_print("model2view", model2view);
    bn_mat_print("view2model", view2model);
d1094 2
a1095 2
      bn_mat_print("model2objview", model2objview);
      bn_mat_print("objview2model", objview2model);
d1111 1
a1111 1
    bu_vls_printf(&vls, "%f", Viewscale*base2local);
d1136 1
a1136 1
    bn_mat_print("toViewcenter", toViewcenter);
d1146 1
a1146 1
    bn_mat_print("Viewrot", Viewrot);
d1156 1
a1156 1
    bn_mat_print("model2view", model2view);
d1166 1
a1166 1
    bn_mat_print("view2model", view2model);
d1176 1
a1176 1
    bn_mat_print("model2objview", model2objview);
d1186 1
a1186 1
    bn_mat_print("objview2model", objview2model);
d1238 1
a1238 1
      quat_mat2quat(quat, Viewrot);
d1273 1
a1273 1
    quat_quat2mat(Viewrot, quat);
d1284 1
a1284 1
      bn_mat_trn(mat, Viewrot);
d1327 1
a1327 1
    bn_mat_trn(Viewrot, mat);
d1338 1
a1338 1
      bn_mat_trn(mat, Viewrot);
d1387 1
a1387 1
    bn_mat_trn(Viewrot, mat);
d1398 1
a1398 1
      MAT_DELTAS_GET_NEG(center, toViewcenter);
d1432 1
a1432 1
    MAT_DELTAS_VEC_NEG(toViewcenter, center);
d1445 1
a1445 1
      MAT4X3PNT(eye, view2model, pt);
d1481 2
a1482 2
    VSET(pt, 0.0, 0.0, Viewscale);
    bn_mat_trn(mat, Viewrot);
d1485 1
a1485 1
    MAT_DELTAS_VEC(toViewcenter, pt);
d1497 1
a1497 1
      bu_vls_printf(&vls, "%.12g", Viewscale * 2.0 * base2local);
d1528 1
a1528 1
    Viewscale = size * 0.5;
d1557 1
a1557 1
  dmaflag = 1;		/* causes refresh() */
d1574 3
a1576 3
  o_twist = curr_dm_list->s_info->twist;
  o_arz = absolute_rotate[Z];
  o_larz = last_absolute_rotate[Z];
d1580 1
a1580 1
    setview( 270.0 + elev + curr_dm_list->s_info->elevation,
d1582 1
a1582 1
	     270.0 - azim - curr_dm_list->s_info->azimuth);
d1596 2
a1597 2
  absolute_rotate[Z] = o_arz;
  last_absolute_rotate[Z] = o_larz;
a1598 4
#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_rotate_vls[Z]));
#endif

d1670 2
a1671 2
	if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist)
	  DM_FREEDLISTS(dmlp->_dmp, sp->s_dlist, 1);
d1726 2
a1727 2
      if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist)
	DM_FREEDLISTS(dmlp->_dmp, sp->s_dlist, 1);
d2039 4
a2042 4
  if( rate_model_rotate[X] != 0.0 ||
      rate_model_rotate[Y] != 0.0 ||
      rate_model_rotate[Z] != 0.0 )
    rateflag_model_rotate = 1;
d2044 1
a2044 1
    rateflag_model_rotate = 0;
d2046 4
a2049 4
  if( rate_model_tran[X] != 0.0 ||
      rate_model_tran[Y] != 0.0 ||
      rate_model_tran[Z] != 0.0 )
    rateflag_model_tran = 1;
d2051 1
a2051 1
    rateflag_model_tran = 0;
d2053 4
a2056 4
  if( rate_rotate[X] != 0.0 ||
      rate_rotate[Y] != 0.0 ||
      rate_rotate[Z] != 0.0 )
    rateflag_rotate = 1;
d2058 1
a2058 1
    rateflag_rotate = 0;
d2060 4
a2063 4
  if( rate_tran[X] != 0.0 ||
      rate_tran[Y] != 0.0 ||
      rate_tran[Z] != 0.0 )
    rateflag_tran = 1;
d2065 1
a2065 1
    rateflag_tran = 0;
d2067 2
a2068 2
  if( rate_scale != 0.0 )
    rateflag_scale = 1;
d2070 1
a2070 1
    rateflag_scale = 0;
d2112 1
a2112 1
  dmaflag = 1;	/* values changed so update faceplate */
d2118 1
a2118 1
  if(!mged_variables->rateknobs)
a2119 27

#ifdef UPDATE_TCL_SLIDERS
  if(es_edclass == EDIT_CLASS_ROTATE && mged_variables->transform == 'e'){
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[Z]));
  }else{
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[Z]));
  }

  if(es_edclass == EDIT_CLASS_SCALE && mged_variables->transform == 'e')
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_scale_vls));
  else
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_scale_vls));

  if(es_edclass == EDIT_CLASS_TRAN && mged_variables->transform == 'e'){
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[Z]));
  }else{
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[Z]));
  }
#endif
d2130 2
a2131 2
  if(mged_variables->rateknobs){
    if(es_edclass == EDIT_CLASS_ROTATE && mged_variables->transform == 'e'){
d2136 3
a2138 3
      bu_vls_printf(&vls, "x = %f\n", rate_rotate[X]);
      bu_vls_printf(&vls, "y = %f\n", rate_rotate[Y]);
      bu_vls_printf(&vls, "z = %f\n", rate_rotate[Z]);
d2141 1
a2141 1
    if(es_edclass == EDIT_CLASS_SCALE && mged_variables->transform == 'e')
d2144 1
a2144 1
      bu_vls_printf(&vls, "S = %f\n", rate_scale);
d2146 1
a2146 1
    if(es_edclass == EDIT_CLASS_TRAN && mged_variables->transform == 'e'){
d2151 3
a2153 3
      bu_vls_printf(&vls, "X = %f\n", rate_tran[X]);
      bu_vls_printf(&vls, "Y = %f\n", rate_tran[Y]);
      bu_vls_printf(&vls, "Z = %f\n", rate_tran[Z]);
d2156 1
a2156 1
    if(es_edclass == EDIT_CLASS_ROTATE && mged_variables->transform == 'e'){
d2161 3
a2163 3
      bu_vls_printf(&vls, "ax = %f\n", absolute_rotate[X]);
      bu_vls_printf(&vls, "ay = %f\n", absolute_rotate[Y]);
      bu_vls_printf(&vls, "az = %f\n", absolute_rotate[Z]);
d2166 1
a2166 1
    if(es_edclass == EDIT_CLASS_SCALE && mged_variables->transform == 'e')
d2169 1
a2169 1
      bu_vls_printf(&vls, "aS = %f\n", absolute_scale);
d2171 1
a2171 1
    if(es_edclass == EDIT_CLASS_TRAN && mged_variables->transform == 'e'){
d2176 3
a2178 3
      bu_vls_printf(&vls, "aX = %f\n", absolute_tran[X]);
      bu_vls_printf(&vls, "aY = %f\n", absolute_tran[Y]);
      bu_vls_printf(&vls, "aZ = %f\n", absolute_tran[Z]);
d2182 6
a2187 6
  if(adc_draw){
    bu_vls_printf(&vls, "xadc = %d\n", dv_xadc);
    bu_vls_printf(&vls, "yadc = %d\n", dv_yadc);
    bu_vls_printf(&vls, "ang1 = %d\n", dv_1adc);
    bu_vls_printf(&vls, "ang2 = %d\n", dv_2adc);
    bu_vls_printf(&vls, "distadc = %d\n", dv_distadc);
d2265 1
a2265 1
    origin = mged_variables->rotate_about;
d2280 5
a2284 5
      VSETALL( rate_model_rotate, 0.0 );
      VSETALL( rate_model_tran, 0.0 );
      VSETALL( rate_rotate, 0.0 );
      VSETALL( rate_tran, 0.0 );
      rate_scale = 0.0;
a2298 3
      if(knob_hook)
	knob_hook();

a2299 4

#ifdef DO_SCROLL_UPDATES
      set_scroll();
#endif
d2301 1
a2301 1
      VSETALL( absolute_tran, 0.0 );
d2329 1
a2329 1
	  if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2331 1
a2331 1
	    switch(mged_variables->coords){
d2336 1
a2336 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[X]));
#endif
d2342 1
a2342 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[X]));
#endif
d2349 1
a2349 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[X]));
#endif
d2353 3
a2355 3
	    if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	      rate_model_rotate[X] += f;
	      rate_model_origin = origin;
d2357 2
a2358 2
	      rate_rotate[X] += f;
	      rate_origin = origin;
d2360 1
a2360 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[X]));
#endif
d2363 1
a2363 1
	  if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2365 1
a2365 1
	    switch(mged_variables->coords){
d2370 1
a2370 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[X]));
#endif
d2376 1
a2376 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[X]));
#endif
d2383 1
a2383 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[X]));
#endif
d2387 3
a2389 3
	    if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	      rate_model_rotate[X] = f;
	      rate_model_origin = origin;
d2391 2
a2392 2
	      rate_rotate[X] = f;
	      rate_origin = origin;
d2394 1
a2394 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[X]));
#endif
d2401 1
a2401 1
	  if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2403 1
a2403 1
	    switch(mged_variables->coords){
d2408 1
a2408 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[Y]));
#endif
d2414 1
a2414 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[Y]));
#endif
d2421 1
a2421 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[Y]));
#endif
d2425 3
a2427 3
	    if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	      rate_model_rotate[Y] += f;
	      rate_model_origin = origin;
d2429 2
a2430 2
	      rate_rotate[Y] += f;
	      rate_origin = origin;
a2431 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[Y]));
#endif
d2434 1
a2434 1
	  if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2436 1
a2436 1
	    switch(mged_variables->coords){
d2441 1
a2441 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[Y]));
#endif
d2447 1
a2447 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[Y]));
#endif
d2454 1
a2454 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[Y]));
#endif
d2458 3
a2460 3
	    if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	      rate_model_rotate[Y] = f;
	      rate_model_origin = origin;
d2462 2
a2463 2
	      rate_rotate[Y] = f;
	      rate_origin = origin;
a2464 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[Y]));
#endif
d2471 1
a2471 1
	  if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2473 1
a2473 1
	    switch(mged_variables->coords){
d2478 1
a2478 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[Z]));
#endif
d2484 1
a2484 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[Z]));
#endif
d2491 1
a2491 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[Z]));
#endif
d2495 3
a2497 3
	    if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	      rate_model_rotate[Z] += f;
	      rate_model_origin = origin;
d2499 2
a2500 2
	      rate_rotate[Z] += f;
	      rate_origin = origin;
a2501 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[Z]));
#endif
d2504 1
a2504 1
	  if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2506 1
a2506 1
	    switch(mged_variables->coords){
d2511 1
a2511 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_rotate_vls[Z]));
#endif
d2517 1
a2517 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_object_rotate_vls[Z]));
#endif
d2524 1
a2524 3
#ifdef UPDATE_TCL_SLIDERS
	      Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_rotate_vls[Z]));
#endif
d2528 3
a2530 3
	    if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	      rate_model_rotate[Z] = f;
	      rate_model_origin = origin;
d2532 2
a2533 2
	      rate_rotate[Z] = f;
	      rate_origin = origin;
a2534 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_rotate_vls[Z]));
#endif
d2541 1
a2541 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d2543 1
a2543 1
	  switch(mged_variables->coords){
d2548 1
a2548 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[X]));
#endif
d2554 1
a2554 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[X]));
#endif
d2558 2
a2559 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag))
	    rate_model_tran[X] += f;
d2561 1
a2561 4
	    rate_tran[X] += f;
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[X]));
#endif
d2564 1
a2564 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d2566 1
a2566 1
	  switch(mged_variables->coords){
d2571 1
a2571 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[X]));
#endif
d2577 1
a2577 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[X]));
#endif
d2581 2
a2582 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag))
	    rate_model_tran[X] = f;
d2584 1
a2584 4
	    rate_tran[X] = f;
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[X]));
#endif
d2591 1
a2591 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d2593 1
a2593 1
	  switch(mged_variables->coords){
d2598 1
a2598 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[Y]));
#endif
d2604 1
a2604 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[Y]));
#endif
d2608 2
a2609 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag))
	    rate_model_tran[Y] += f;
d2611 1
a2611 4
	    rate_tran[Y] += f;
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[Y]));
#endif
d2614 1
a2614 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d2616 1
a2616 1
	  switch(mged_variables->coords){
d2621 1
a2621 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[Y]));
#endif
d2627 1
a2627 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[Y]));
#endif
d2631 2
a2632 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag))
	    rate_model_tran[Y] = f;
d2634 1
a2634 4
	    rate_tran[Y] = f;
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[Y]));
#endif
d2641 1
a2641 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d2643 1
a2643 1
	  switch(mged_variables->coords){
d2648 1
a2648 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[Z]));
#endif
d2654 1
a2654 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[Z]));
#endif
d2658 2
a2659 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag))
	    rate_model_tran[Z] += f;
d2661 1
a2661 4
	    rate_tran[Z] += f;
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[Z]));
#endif
d2664 1
a2664 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d2666 1
a2666 1
	  switch(mged_variables->coords){
d2671 1
a2671 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_model_tran_vls[Z]));
#endif
d2677 1
a2677 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_view_tran_vls[Z]));
#endif
d2681 2
a2682 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag))
	    rate_model_tran[Z] = f;
d2684 1
a2684 4
	    rate_tran[Z] = f;
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_tran_vls[Z]));
#endif
d2691 1
a2691 1
	if(EDIT_SCALE && ((mged_variables->transform == 'e' && !view_flag) || edit_flag)){
a2692 3
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_scale_vls));
#endif
d2694 1
a2694 4
	  rate_scale += f;
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_scale_vls));
#endif
d2697 1
a2697 1
	if(EDIT_SCALE && ((mged_variables->transform == 'e' && !view_flag) || edit_flag)){
a2698 3
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_scale_vls));
#endif
d2700 1
a2700 4
	  rate_scale = f;
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_scale_vls));
#endif
d2712 1
a2712 1
	if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2714 1
a2714 1
	  switch(mged_variables->coords){
d2726 2
a2727 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	    absolute_model_rotate[X] += f;
d2729 1
a2729 1
	    absolute_rotate[X] += f;
d2735 1
a2735 1
	if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2737 1
a2737 1
	  switch(mged_variables->coords){
d2752 3
a2754 3
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	    rvec[X] = f - last_absolute_model_rotate[X];
	    absolute_model_rotate[X] = f;
d2756 2
a2757 2
	    rvec[X] = f - last_absolute_rotate[X];
	    absolute_rotate[X] = f;
d2763 1
a2763 1
      if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2768 1
a2768 1
	switch(mged_variables->coords){
d2793 3
a2795 3
	if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  arp = absolute_model_rotate;
	  larp = last_absolute_model_rotate;
d2797 2
a2798 2
	  arp = absolute_rotate;
	  larp = last_absolute_rotate;
a2806 3
#ifdef UPDATE_TCL_SLIDERS
	Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_rotate_vls[X]));
#endif
d2813 1
a2813 1
	if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2815 1
a2815 1
	  switch(mged_variables->coords){
d2827 2
a2828 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	    absolute_model_rotate[Y] += f;
d2830 1
a2830 1
	    absolute_rotate[Y] += f;
d2836 1
a2836 1
	if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2838 1
a2838 1
	  switch(mged_variables->coords){
d2853 3
a2855 3
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	    rvec[Y] = f - last_absolute_model_rotate[Y];
	    absolute_model_rotate[Y] = f;
d2857 2
a2858 2
	    rvec[Y] = f - last_absolute_rotate[Y];
	    absolute_rotate[Y] = f;
d2864 1
a2864 1
      if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2869 1
a2869 1
	switch(mged_variables->coords){
d2894 3
a2896 3
	if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  arp = absolute_model_rotate;
	  larp = last_absolute_model_rotate;
d2898 2
a2899 2
	  arp = absolute_rotate;
	  larp = last_absolute_rotate;
a2907 3
#ifdef UPDATE_TCL_SLIDERS
	Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_rotate_vls[Y]));
#endif
d2914 1
a2914 1
	if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2916 1
a2916 1
	  switch(mged_variables->coords){
d2928 2
a2929 2
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	    absolute_model_rotate[Z] += f;
d2931 1
a2931 1
	    absolute_rotate[Z] += f;
d2937 1
a2937 1
	if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2939 1
a2939 1
	  switch(mged_variables->coords){
d2954 3
a2956 3
	  if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	    rvec[Z] = f - last_absolute_model_rotate[Z];
	    absolute_model_rotate[Z] = f;
d2958 2
a2959 2
	    rvec[Z] = f - last_absolute_rotate[Z];
	    absolute_rotate[Z] = f;
d2965 1
a2965 1
      if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d2970 1
a2970 1
	switch(mged_variables->coords){
d2995 3
a2997 3
	if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  arp = absolute_model_rotate;
	  larp = last_absolute_model_rotate;
d2999 2
a3000 2
	  arp = absolute_rotate;
	  larp = last_absolute_rotate;
a3008 3
#ifdef UPDATE_TCL_SLIDERS
	Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_rotate_vls[Z]));
#endif
d3014 1
a3014 1
      sf = f * local2base / Viewscale;
d3016 1
a3016 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d3018 1
a3018 1
	  switch(mged_variables->coords){
d3023 1
a3023 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[X]));
#endif
d3028 1
a3028 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[X]));
#endif
d3031 3
a3033 3
	}else if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  absolute_model_tran[X] += sf;
	  last_absolute_model_tran[X] = absolute_model_tran[X];
d3035 2
a3036 2
	  absolute_tran[X] += sf;
	  last_absolute_tran[X] = absolute_tran[X];
d3041 1
a3041 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d3043 1
a3043 1
	  switch(mged_variables->coords){
d3046 1
a3046 1
	    tvec[X] = f - last_edit_absolute_model_tran[X]*Viewscale*base2local;
d3049 1
a3049 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[X]));
#endif
d3052 1
a3052 1
	    tvec[X] = f - last_edit_absolute_view_tran[X]*Viewscale*base2local;
d3055 1
a3055 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[X]));
#endif
d3058 4
a3061 4
	}else if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  tvec[X] = f - last_absolute_model_tran[X]*Viewscale*base2local;
	  absolute_model_tran[X] = sf;
	  last_absolute_model_tran[X] = absolute_model_tran[X];
d3063 3
a3065 3
	  tvec[X] = f - last_absolute_tran[X]*Viewscale*base2local;
	  absolute_tran[X] = sf;
	  last_absolute_tran[X] = absolute_tran[X];
d3073 1
a3073 1
      sf = f * local2base / Viewscale;
d3075 1
a3075 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d3077 1
a3077 1
	  switch(mged_variables->coords){
d3082 1
a3082 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[Y]));
#endif
d3087 1
a3087 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[Y]));
#endif
d3090 3
a3092 3
	}else if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  absolute_model_tran[Y] += sf;
	  last_absolute_model_tran[Y] = absolute_model_tran[Y];
d3094 2
a3095 2
	  absolute_tran[Y] += sf;
	  last_absolute_tran[Y] = absolute_tran[Y];
d3100 1
a3100 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d3102 1
a3102 1
	  switch(mged_variables->coords){
d3105 1
a3105 1
	    tvec[Y] = f - last_edit_absolute_model_tran[Y]*Viewscale*base2local;
d3108 1
a3108 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[Y]));
#endif
d3111 1
a3111 1
	    tvec[Y] = f - last_edit_absolute_view_tran[Y]*Viewscale*base2local;
d3114 1
a3114 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[Y]));
#endif
d3117 4
a3120 4
	}else if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  tvec[Y] = f - last_absolute_model_tran[Y]*Viewscale*base2local;
	  absolute_model_tran[Y] = sf;
	  last_absolute_model_tran[Y] = absolute_model_tran[Y];
d3122 3
a3124 3
	  tvec[Y] = f - last_absolute_tran[Y]*Viewscale*base2local;
	  absolute_tran[Y] = sf;
	  last_absolute_tran[Y] = absolute_tran[Y];
d3131 1
a3131 1
      sf = f * local2base / Viewscale;
d3133 1
a3133 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d3135 1
a3135 1
	  switch(mged_variables->coords){
d3140 1
a3140 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[Z]));
#endif
d3145 1
a3145 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[Z]));
#endif
d3148 3
a3150 3
	}else if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  absolute_model_tran[Z] += sf;
	  last_absolute_model_tran[Z] = absolute_model_tran[Z];
d3152 2
a3153 2
	  absolute_tran[Z] += sf;
	  last_absolute_tran[Z] = absolute_tran[Z];
d3158 1
a3158 1
	if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d3160 1
a3160 1
	  switch(mged_variables->coords){
d3163 1
a3163 1
	    tvec[Z] = f - last_edit_absolute_model_tran[Z]*Viewscale*base2local;
d3166 1
a3166 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_model_tran_vls[Z]));
#endif
d3169 1
a3169 1
	    tvec[Z] = f - last_edit_absolute_view_tran[Z]*Viewscale*base2local;
d3172 1
a3172 3
#ifdef UPDATE_TCL_SLIDERS
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_view_tran_vls[Z]));
#endif
d3175 4
a3178 4
	}else if(model_flag || (mged_variables->coords == 'm' && !view_flag)){
	  tvec[Z] = f - last_absolute_model_tran[Z]*Viewscale*base2local;
	  absolute_model_tran[Z] = sf;
	  last_absolute_model_tran[Z] = absolute_model_tran[Z];
d3180 3
a3182 3
	  tvec[Z] = f - last_absolute_tran[Z]*Viewscale*base2local;
	  absolute_tran[Z] = sf;
	  last_absolute_tran[Z] = absolute_tran[Z];
d3190 1
a3190 1
	if(EDIT_SCALE && ((mged_variables->transform == 'e' && !view_flag) || edit_flag)){
a3195 3
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_scale_vls));
#endif
d3197 1
a3197 1
	  absolute_scale += f;
a3198 3
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_scale_vls));
#endif
d3201 1
a3201 1
	if(EDIT_SCALE && ((mged_variables->transform == 'e' && !view_flag) || edit_flag)){
a3206 3
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_scale_vls));
#endif
d3208 1
a3208 1
	  absolute_scale = f;
a3209 3
#ifdef UPDATE_TCL_SLIDERS
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_scale_vls));
#endif
d3355 1
a3355 1
  if(EDIT_TRAN && ((mged_variables->transform == 'e' &&
d3358 1
a3358 1
  else if(model_flag || (mged_variables->coords == 'm' && !view_flag))
d3374 1
a3374 1
  if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
d3377 1
a3377 1
  else if(model_flag || (mged_variables->coords == 'm' && !view_flag))
d3542 2
a3543 2
  if(-SMALL_FASTF < absolute_scale && absolute_scale < SMALL_FASTF)
    Viewscale = i_Viewscale;
d3546 1
a3546 1
    if(absolute_scale > 0){
d3548 1
a3548 1
      Viewscale = i_Viewscale * (1.0 - absolute_scale);
d3551 1
a3551 1
      Viewscale = i_Viewscale * (1.0 + (absolute_scale * -9.0));
d3554 2
a3555 2
  if( Viewscale < MINVIEW )
    Viewscale = MINVIEW;
d3559 3
a3561 3
  if(absolute_tran[X] != 0.0 ||
     absolute_tran[Y] != 0.0 ||
     absolute_tran[Z] != 0.0){
a3562 6

#ifdef UPDATE_TCL_SLIDERS
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
a3563 4

#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_scale_vls));
#endif
d3577 3
a3579 3
  Viewscale /= val;
  if( Viewscale < MINVIEW )
    Viewscale = MINVIEW;
d3583 7
a3589 7
  absolute_scale = 1.0 - Viewscale / i_Viewscale;
  if(absolute_scale < 0.0)
    absolute_scale /= 9.0;

  if(absolute_tran[X] != 0.0 ||
     absolute_tran[Y] != 0.0 ||
     absolute_tran[Z] != 0.0){
d3591 1
a3592 9
#ifdef UPDATE_TCL_SLIDERS
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
  }
#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_scale_vls));
#endif
d3651 1
a3651 1
  quat_quat2mat( Viewrot, quat );
d3849 1
a3849 1
  VSUB2(absolute_tran, absolute_tran, slewvec);
d3860 2
a3861 2
  i_Viewscale = Viewscale;
  MAT_DELTAS_GET_NEG(orig_pos, toViewcenter);
d3864 9
a3872 9
  VSETALL(absolute_rotate, 0.0);
  VSETALL(last_absolute_rotate, 0.0);
  VSETALL(absolute_model_rotate, 0.0);
  VSETALL(last_absolute_model_rotate, 0.0);
  VSETALL(absolute_tran, 0.0);
  VSETALL(last_absolute_tran, 0.0);
  VSETALL(absolute_model_tran, 0.0);
  VSETALL(last_absolute_model_tran, 0.0);
  absolute_scale = 0.0;
d3874 2
a3875 2
  if(mged_variables->faceplate && mged_variables->orig_gui)
    curr_dm_list->_dirty = 1;
d3905 4
a3908 4
    if(dmlp->s_info == curr_dm_list->s_info &&
       dmlp->_mged_variables->faceplate &&
       dmlp->_mged_variables->orig_gui)
      dmlp->_dirty = 1;
d3970 1
a3970 1
	bn_mat_mul2( newrot, Viewrot );
d3974 1
a3974 1
		wrt_view( ModelDelta, newinv, ModelDelta );	/* Updates ModelDelta */
d3992 1
a3992 1
	buildHrot( Viewrot, rad[X], rad[Y], rad[Z] );
d4012 1
a4012 1
  buildHrot( Viewrot, a1 * degtorad, a2 * degtorad, a3 * degtorad );
d4015 3
a4017 3
  if(absolute_tran[X] != 0.0 ||
     absolute_tran[Y] != 0.0 ||
     absolute_tran[Z] != 0.0){
a4018 6

#ifdef UPDATE_TCL_SLIDERS
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
d4039 1
a4039 1
  MAT_DELTAS_GET_NEG( old_model_center, toViewcenter );
d4041 2
a4042 2
  MAT4X3PNT( new_model_center, view2model, view_pos );
  MAT_DELTAS_VEC_NEG( toViewcenter, new_model_center );
d4047 1
a4047 1
  bn_mat_mul2( delta, ModelDelta );	/* updates ModelDelta */
a4050 6

#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
d4083 1
a4083 1
	MAT_DELTAS_VEC_NEG( toViewcenter, eye_model );
d4090 2
a4091 2
	MAT4X3PNT( new_cent, view2model, xlate );
	MAT_DELTAS_VEC_NEG( toViewcenter, new_cent );
d4128 1
a4128 1
	MAT4X3PNT( view, model2view, model );
d4166 1
a4166 1
	MAT4X3PNT(model, view2model, view);
d4206 2
a4207 2
  MAT4X3PNT(view_pt, model2view, model_pt);
  f = Viewscale * base2local;
d4245 1
a4245 1
  sf = 1.0 / (Viewscale * base2local);
d4248 1
a4248 1
  MAT4X3PNT(model_pt, view2model, view_pt);
d4289 1
a4289 1
  MAT4X3PNT(mo_view_pt, model2view, model_pt);
d4293 1
a4293 1
  MAT4X3PNT(view_pt, model2view, model_pt);
d4296 1
a4296 1
  f = Viewscale * base2local;
d4336 1
a4336 1
  f = 1.0 / (Viewscale * base2local);
d4342 1
a4342 1
  MAT4X3PNT(mo_view_pt, model2view, model_pt);
d4345 1
a4345 1
  MAT4X3PNT(model_pt, view2model, view_pt);
d4388 2
a4389 2
  MAT4X3PNT(mo_view_pt, model2view, model_pt);
  f = Viewscale * base2local;
d4435 2
a4436 2
  MAT4X3PNT(mo_view_pt, model2view, model_pt);
  f = Viewscale * base2local;
d4476 1
a4476 1
  bn_mat_inv(inv_Viewrot, Viewrot);
d4522 1
a4522 1
  MAT4X3PNT(eye, view2model, tmp);
d4529 1
a4529 1
  bu_vls_printf(&vls, "ae %-15.10f %-15.10f %-15.10f", new_az, new_el, curr_dm_list->s_info->twist);
d4533 2
a4534 2
  VJOIN1( new_center, eye, -Viewscale, dir );
  MAT_DELTAS_VEC_NEG( toViewcenter, new_center );
d4541 41
d4583 5
a4587 2
mged_view_init(dlp)
struct dm_list *dlp;
d4589 241
a4829 1
  struct view_list *vlp;
d4831 5
a4835 7
  BU_LIST_INIT(&dlp->s_info->_headView.l);
  BU_GETSTRUCT(vlp, view_list);
  BU_LIST_APPEND(&dlp->s_info->_headView.l, &vlp->l);

  vlp->vid = 1;
  dlp->s_info->_current_view = vlp;
  dlp->s_info->_last_view = vlp;
d4837 37
a4873 1
  return TCL_OK;
d4884 2
a4885 2
  struct view_list *vlp;
  struct view_list *lv;
d4897 1
a4897 1
  bn_mat_copy(current_view->vrot_mat, Viewrot);
d4900 1
a4900 1
  bn_mat_copy(current_view->tvc_mat, toViewcenter);
d4903 1
a4903 1
  current_view->vscale = Viewscale;
d4906 3
a4908 3
  BU_GETSTRUCT(vlp, view_list);
  lv = BU_LIST_LAST(view_list, &headView.l);
  BU_LIST_APPEND(&lv->l, &vlp->l);
d4911 1
a4911 1
  vlp->vid = lv->vid + 1;
d4913 2
a4914 2
  last_view = current_view;
  current_view = vlp;
a4916 4
#ifdef DO_SCROLL_UPDATES
  set_scroll();
#endif

d4929 1
a4929 1
  struct view_list *vlp;
d4943 2
a4944 2
  for(BU_LIST_FOR(vlp, view_list, &headView.l)){
    if(vlp->vid == n)
d4948 1
a4948 1
  if(BU_LIST_IS_HEAD(vlp, &headView.l)){
d4955 2
a4956 2
  if(BU_LIST_IS_HEAD(vlp->l.forw, &headView.l) &&
     BU_LIST_IS_HEAD(vlp->l.back, &headView.l)){
d4961 4
a4964 4
  if(vlp == current_view){
    if(current_view == last_view){
      current_view = BU_LIST_PNEXT(view_list, last_view);
      last_view = current_view;
d4966 1
a4966 1
      current_view = last_view;
d4968 3
a4970 3
    bn_mat_copy(Viewrot, current_view->vrot_mat);
    bn_mat_copy(toViewcenter, current_view->tvc_mat);
    Viewscale = current_view->vscale;
d4973 2
a4974 6

#ifdef DO_SCROLL_UPDATES
    set_scroll();
#endif
  }else if(vlp == last_view)
    last_view = current_view;
d4976 2
a4977 2
  BU_LIST_DEQUEUE(&vlp->l);
  bu_free((genptr_t)vlp, "f_delete_view");
d4991 1
a4991 1
  struct view_list *vlp;
d5004 1
a5004 1
    bu_vls_printf(&vls, "%d", current_view->vid);
d5019 2
a5020 2
  for(BU_LIST_FOR(vlp, view_list, &headView.l)){
    bu_vls_printf(&vls, "%d", vlp->vid);
d5038 1
a5038 1
  struct view_list *vlp;
d5051 2
a5052 2
  for(BU_LIST_FOR(vlp, view_list, &headView.l)){
    if(vlp->vid == n)
d5056 1
a5056 1
  if(BU_LIST_IS_HEAD(vlp, &headView.l)){
d5063 1
a5063 1
  if(vlp == current_view)
d5067 1
a5067 1
  bn_mat_copy(current_view->vrot_mat, Viewrot);
d5070 1
a5070 1
  bn_mat_copy(current_view->tvc_mat, toViewcenter);
d5073 1
a5073 1
  current_view->vscale = Viewscale;
d5075 5
a5079 5
  last_view = current_view;
  current_view = vlp;
  bn_mat_copy(Viewrot, current_view->vrot_mat);
  bn_mat_copy(toViewcenter, current_view->tvc_mat);
  Viewscale = current_view->vscale;
a5083 4
#ifdef DO_SCROLL_UPDATES
  set_scroll();
#endif

d5106 2
a5107 2
  if(BU_LIST_IS_HEAD(current_view->l.forw, &headView.l) &&
     BU_LIST_IS_HEAD(current_view->l.back, &headView.l))
d5111 1
a5111 1
  bn_mat_copy(current_view->vrot_mat, Viewrot);
d5114 1
a5114 1
  bn_mat_copy(current_view->tvc_mat, toViewcenter);
d5117 1
a5117 1
  current_view->vscale = Viewscale;
d5119 7
a5125 7
  last_view = current_view;
  current_view = BU_LIST_PNEXT(view_list, current_view);
  if(BU_LIST_IS_HEAD(current_view, &headView.l))
    current_view = BU_LIST_FIRST(view_list, &headView.l);
  bn_mat_copy(Viewrot, current_view->vrot_mat);
  bn_mat_copy(toViewcenter, current_view->tvc_mat);
  Viewscale = current_view->vscale;
a5129 4
#ifdef DO_SCROLL_UPDATES
  set_scroll();
#endif

d5152 2
a5153 2
  if(BU_LIST_IS_HEAD(current_view->l.forw, &headView.l) &&
     BU_LIST_IS_HEAD(current_view->l.back, &headView.l))
d5157 1
a5157 1
  bn_mat_copy(current_view->vrot_mat, Viewrot);
d5160 1
a5160 1
  bn_mat_copy(current_view->tvc_mat, toViewcenter);
d5163 1
a5163 1
  current_view->vscale = Viewscale;
d5165 7
a5171 7
  last_view = current_view;
  current_view = BU_LIST_PLAST(view_list, current_view);
  if(BU_LIST_IS_HEAD(current_view, &headView.l))
    current_view = BU_LIST_LAST(view_list, &headView.l);
  bn_mat_copy(Viewrot, current_view->vrot_mat);
  bn_mat_copy(toViewcenter, current_view->tvc_mat);
  Viewscale = current_view->vscale;
a5175 4
#ifdef DO_SCROLL_UPDATES
  set_scroll();
#endif

d5187 1
a5187 1
  struct view_list *save_last_view;
d5199 1
a5199 1
  bn_mat_copy(current_view->vrot_mat, Viewrot);
d5202 1
a5202 1
  bn_mat_copy(current_view->tvc_mat, toViewcenter);
d5205 1
a5205 1
  current_view->vscale = Viewscale;
d5207 6
a5212 6
  save_last_view = last_view;
  last_view = current_view;
  current_view = save_last_view;
  bn_mat_copy(Viewrot, current_view->vrot_mat);
  bn_mat_copy(toViewcenter, current_view->tvc_mat);
  Viewscale = current_view->vscale;
a5216 4
#ifdef DO_SCROLL_UPDATES
  set_scroll();
#endif

d5229 1
a5229 1
  switch(mged_variables->coords){
d5240 1
a5240 1
    bn_mat_inv(temp1, Viewrot);
d5244 1
a5244 1
    bn_mat_mul(newrot, temp2, Viewrot);
d5251 2
a5252 2
    save_origin = mged_variables->rotate_about;
    mged_variables->rotate_about = origin;
d5263 1
a5263 1
    mged_variables->rotate_about = save_origin;
d5278 1
a5278 1
      MAT4X3PNT(point, view2model, work);
d5282 1
a5282 1
      MAT4X3PNT(point, view2model, work);
d5340 1
a5340 1
    MAT4X3VEC( view_direc, model2view, model_direc );
d5349 1
a5349 1
      MAT4X3PNT( vrot_pt, model2view, new_origin ); /* point in view space */
d5358 2
a5359 2
    MAT4X3PNT( new_model_center, view2model, new_view_center );
    MAT_DELTAS_VEC_NEG( toViewcenter, new_model_center );
d5362 1
a5362 1
    bn_mat_mul2( newrot, view2model );
d5368 2
a5369 2
    bn_mat_inv( model2view, view2model );
    model2view[15] = 1.0;
d5372 1
a5372 1
    bn_mat_mul( Viewrot, model2view, invtvc );
d5374 3
a5376 3
    Viewrot[3] = 0.0;
    Viewrot[7] = 0.0;
    Viewrot[11] = 0.0;
d5379 2
a5380 2
    bn_mat_inv( viewchginv, Viewrot );
    bn_mat_mul( toViewcenter, viewchginv, model2view );
d5383 1
a5383 1
    wrt_view( view2model, newrot, view2model);
d5386 1
a5386 1
    MAT_DELTAS( invtvc, -toViewcenter[MDX], -toViewcenter[MDY], -toViewcenter[MDZ] );
d5389 2
a5390 2
    bn_mat_inv( model2view, view2model );
    model2view[15] = 1.0;
d5393 1
a5393 1
    bn_mat_mul( Viewrot, model2view, invtvc );
d5449 1
a5449 1
  return mged_mrot_xyz(mged_variables->rotate_about, rvec);
d5478 1
a5478 1
      MAT4X3PNT( rot_pt, model2view, new_origin);  /* point to rotate around */
d5487 2
a5488 2
    MAT4X3PNT( new_cent_model, view2model, new_cent_view );
    MAT_DELTAS_VEC_NEG( toViewcenter, new_cent_model );
d5492 1
a5492 1
    wrt_view( ModelDelta, newinv, ModelDelta );		/* pure rotation */
d5495 1
a5495 1
    bn_mat_mul2( newrot, Viewrot );			/* pure rotation */
d5501 1
a5501 1
    wrt_view( ModelDelta, newinv, ModelDelta );
d5504 1
a5504 1
    bn_mat_mul2( newrot, Viewrot );			/* pure rotation */
d5507 3
a5509 3
    if(absolute_tran[X] != 0.0 ||
       absolute_tran[Y] != 0.0 ||
       absolute_tran[Z] != 0.0){
a5513 5
#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
d5566 1
a5566 1
  return mged_vrot_xyz(mged_variables->rotate_about, rvec);
d5574 1
a5574 1
     mged_variables->transform == 'e')
d5578 1
a5578 1
  if(mged_variables->coords == 'm')
d5635 1
a5635 1
  return mged_rot_xyz(mged_variables->rotate_about, rvec);
d5685 1
a5685 1
  return mged_rot(mged_variables->rotate_about, newrot);
d5698 1
a5698 1
  switch(mged_variables->coords){
d5705 3
a5707 3
    VSCALE(pt, pt, local2base/Viewscale);
    MAT4X3PNT(work, view2model, pt);
    MAT_DELTAS_GET_NEG(vcenter, toViewcenter);
d5742 1
a5742 1
  MAT_DELTAS_GET_NEG(vc, toViewcenter);
d5744 1
a5744 1
  MAT_DELTAS_VEC_NEG(toViewcenter, nvc);
d5761 3
a5763 3
  VSCALE(tvec, tvec, local2base/Viewscale);
  MAT4X3PNT(work, view2model, tvec);
  MAT_DELTAS_GET_NEG(vc, toViewcenter);
d5766 1
a5766 1
  MAT_DELTAS_VEC_NEG(toViewcenter, nvc);
a5767 5
#ifdef UPDATE_TCL_SLIDERS
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
d5781 1
a5781 1
      mged_variables->transform == 'e')
d5785 1
a5785 1
  if(mged_variables->coords == 'm')
d5941 4
a5944 4
  Viewscale *= sfactor;
  if( Viewscale < MINVIEW )
        Viewscale = MINVIEW;
  f = Viewscale / i_Viewscale;
d5947 1
a5947 1
    absolute_scale = (f - 1.0) / -9.0;
d5949 1
a5949 1
    absolute_scale = 1.0 - f;
d5960 1
a5960 1
    mged_variables->transform == 'e')
@


11.119
log
@*- mods to reflect an earlier change of f_adc()
*- replace use of common literals with macros
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/chgview.c,v 11.118 1998/06/11 19:41:40 bparker Exp $ (BRL)";
d628 1
a628 1
  if( lvl != -1 )
d1797 6
@


11.118
log
@*- using floating point literals to initialize floats
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/chgview.c,v 11.117 1998/05/26 14:27:08 bparker Exp $ (BRL)";
d109 3
a111 3
fastf_t ar_scale_factor = 2047.0 / ABS_ROT_FACTOR;
fastf_t rr_scale_factor = 2047.0 / RATE_ROT_FACTOR;
fastf_t adc_angle_scale_factor = 2047.0 / ADC_ANGLE_FACTOR;
d3414 16
a3429 10
	  char *av[4];
	  char    sval[32];

	  av[1] = "x";
	  av[3] = NULL;

	  if(incr_flag)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";
a3430 1
	  av[2] = sval;
d3432 1
a3432 1
	  (void)f_adc(clientData, interp, 3, av);
d3434 16
a3449 5
	  char *av[4];
	  char    sval[32];

	  av[1] = "y";
	  av[3] = NULL;
a3450 6
	  if(incr_flag)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";

	  av[2] = sval;
d3452 1
a3452 1
	  (void)f_adc(clientData, interp, 3, av);
d3454 16
a3469 10
	  char *av[4];
	  char    sval[32];

	  av[1] = "a1";
	  av[3] = NULL;

	  if(incr_flag)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";
a3470 2
	  av[2] = sval;
#if 1
d3472 1
a3472 4
#else
	  sprintf(sval, "%f", 45.0*(1.0-(double)i/2047.0));
#endif
	  (void)f_adc(clientData, interp, 3, av);
d3474 16
a3489 2
	  char *av[4];
	  char    sval[32];
a3490 10
	  av[1] = "a2";
	  av[3] = NULL;

	  if(incr_flag)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";

	  av[2] = sval;
#if 1
d3492 18
a3509 7
#else
	  sprintf(sval, "%f", 45.0*(1.0-(double)i/2047.0));
#endif
	  (void)f_adc(clientData, interp, 3, av);
	} else if( strcmp( cmd, "distadc" ) == 0 )  {
	  char *av[4];
	  char    sval[32];
d3511 2
a3512 11
	  av[1] = "dst";
	  av[3] = NULL;

	  if(incr_flag)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";

	  av[2] = sval;
	  sprintf(sval, "%f", ((double)i/2047.0 + 1.0)*Viewscale * base2local * M_SQRT2_DIV2);
	  (void)f_adc(clientData, interp, 3, av);
d4062 1
a4062 1
  VSET(slewvec, x/2047.0, y/2047.0, z/2047.0);
@


11.117
log
@*- slight mod to edit_com
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/chgview.c,v 11.116 1998/04/23 12:52:04 bparker Exp $ (BRL)";
d488 2
a489 2
		VSETALL( center, 0 );
		VSETALL( radial, 1000 );	/* 1 meter */
d2318 10
a2327 10
      VSETALL( rate_model_rotate, 0 );
      VSETALL( rate_model_tran, 0 );
      VSETALL( rate_rotate, 0 );
      VSETALL( rate_tran, 0 );
      rate_scale = 0;
      VSETALL( edit_rate_model_rotate, 0 );
      VSETALL( edit_rate_object_rotate, 0 );
      VSETALL( edit_rate_view_rotate, 0 );
      VSETALL( edit_rate_model_tran, 0 );
      VSETALL( edit_rate_view_tran, 0 );
d4298 1
a4298 1
	VSET( xlate, 0, 0, -1 );	/* correction factor */
d4730 1
a4730 1
  VSET( tmp, 0, 0, 1 );
d5254 1
a5254 1
    VSET( model_direc, 0, 0, 1 );
d5257 1
a5257 1
    VSET( new_origin, 0, 0, 0 );    /* point in model space */
d5262 1
a5262 1
      VSET( vrot_pt, 0, 0, 1 );          /* point to rotate around */
d5389 1
a5389 1
      VSET( rot_pt, 0, 0, 1 );		/* point to rotate around */
d5392 1
a5392 1
      VSET( new_origin, 0, 0, 0 );
d5400 1
a5400 1
    VSET( new_origin, 0, 0, 0 );
@


11.116
log
@mods to f_delete_view()
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.115 1998/04/10 18:11:45 bparker Exp bparker $ (BRL)";
a582 2
    color_soltab();

d588 1
@


11.115
log
@*- modified the status command to accept parameters
*- added the view command to get/set view parameters
	using local units ----- essentially the same as
	viewget and viewset with a different interface
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.114 1998/04/07 14:57:45 bparker Exp bparker $ (BRL)";
d4853 1
a4853 1
    Tcl_AppendResult(interp, "delete_view: cannot delete last view\n", (char *)NULL);
@


11.114
log
@*- mods to f_ill()
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.113 1998/03/19 06:57:06 mike Exp bparker $ (BRL)";
d312 1
a312 1
f_view(clientData, interp, argc, argv)
d1085 1
a1085 1
  if(argc < 1 || 1 < argc){
d1095 3
a1097 2
  bu_vls_init(&vls);
  start_catching_output(&vls);
d1099 91
a1189 8
  bu_log("STATE=%s, ", state_str[state] );
  bu_log("Viewscale=%f (%f mm)\n", Viewscale*base2local, Viewscale);
  bu_log("base2local=%f\n", base2local);
  bn_mat_print("toViewcenter", toViewcenter);
  bn_mat_print("Viewrot", Viewrot);
  bn_mat_print("model2view", model2view);
  bn_mat_print("view2model", view2model);
  if( state != ST_VIEW )  {
d1191 9
d1201 44
d1247 304
a1550 2
  stop_catching_output(&vls);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d1552 1
a1552 1
  return TCL_OK;
@


11.113
log
@Clarified error handling for 'cat' command and other do_list() users.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.112 1998/03/19 06:46:20 mike Exp mike $ (BRL)";
d1433 1
d1441 1
a1441 1
	if(argc < 2 || 2 < argc){
d1451 28
a1478 12
	if (state == ST_S_PICK)
	{
	    path_piece = path_parse(argv[1]);
	    for (nm_pieces = 0; path_piece[nm_pieces] != 0; ++nm_pieces)
		;

	    if (nm_pieces == 0)
	    {
	      Tcl_AppendResult(interp, "Bad solid path: '", argv[1], "'\n", (char *)NULL);
	      goto bail_out;
	    }
	    basename = path_piece[nm_pieces - 1];
d1480 2
a1481 2
	else
	    basename = argv[1];
d1487 26
a1512 48
	switch (state)
	{
	    case ST_S_PICK:
		if (!(dp -> d_flags & DIR_SOLID))
		{
		  Tcl_AppendResult(interp, basename, " is not a solid\n", (char *)NULL);
		  goto bail_out;
		}
		FOR_ALL_SOLIDS(sp, &HeadSolid.l)
		{
		    int	a_new_match;

		    i = sp -> s_last;
		    if (sp -> s_path[i] == dp)
		    {
			a_new_match = 1;
			j = nm_pieces - 1;
			for ( ; a_new_match && (i >= 0) && (j >= 0); --i, --j)
			{
			    sname = sp -> s_path[i] -> d_namep;
			    if ((*sname != *(path_piece[j]))
			     || strcmp(sname, path_piece[j]))
			        a_new_match = 0;
			}
			if (a_new_match && ((i >= 0) || (j < 0)))
			{
			    lastfound = sp;
			    ++nmatch;
			}
		    }
		    sp->s_iflag = DOWN;
		}
		break;
	    case ST_O_PICK:
		FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
			for( i=0; i<=sp->s_last; i++ )  {
				if( sp->s_path[i] == dp )  {
					lastfound = sp;
					nmatch++;
					break;
				}
			}
			sp->s_iflag = DOWN;
		}
		break;
	    default:
		state_err("keyboard illuminate pick");
		goto bail_out;
d1514 1
d1519 1
d1524 1
d1528 9
a1536 6
	if( state == ST_O_PICK )  {
		ipathpos = 0;
		(void)chg_state( ST_O_PICK, ST_O_PATH, "Keyboard illuminate");
	} else {
		/* Check details, Init menu, set state=ST_S_EDIT */
		init_sedit();
d1538 1
@


11.112
log
@BParker changes involving rvec/tvec.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.111 1998/01/28 15:33:23 bparker Exp bparker $ (BRL)";
a856 2
	bu_vls_printf( outstrp, "%s:  ", dp->d_namep );

d859 1
a859 1
			") failure", (char *)NULL );
d862 2
@


11.111
log
@*- using coords instead of ecoords
*- mods to mged_etran()
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.110 1998/01/16 21:51:38 bparker Exp bparker $ (BRL)";
d1547 13
a1559 2
    if (state != ST_VIEW)
	button(BE_REJECT);
d1780 1
a1780 1
  if(mged_variables->adcflag){
d3900 1
a3900 1
	bu_vls_printf(&str, "%.15e %.15e %.15e\n", V3ARGS(view) );
d3934 2
a3935 5
	VSET(view, atof(argv[1]),
		atof(argv[2]),
		atof(argv[3]) );

	MAT4X3PNT( model, view2model, view );
d3938 1
a3938 1
	bu_vls_printf(&str, "%.15e %.15e %.15e\n", V3ARGS(model) );
d3945 185
d4131 1
a4131 1
f_lookat(clientData, interp, argc, argv)
d4137 8
a4144 8
	point_t look;
	point_t eye;
	point_t tmp;
	point_t new_center;
	vect_t dir;
	fastf_t new_az, new_el;
	int status;
	struct bu_vls vls;
d4146 108
a4253 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d4255 15
a4269 2
	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;
d4271 2
a4272 6
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help lookat");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}
d4274 2
a4275 3
	VSET( look, atof(argv[1]),
		atof(argv[2]),
		atof(argv[3]) );
d4277 6
a4282 1
	VSCALE( look, look, local2base );
d4284 12
a4295 2
	VSET( tmp, 0, 0, 1 );
	MAT4X3PNT(eye, view2model, tmp);
d4297 4
a4300 8
	VSUB2( dir, eye, look );
	VUNITIZE( dir );
	mat_ae_vec( &new_az, &new_el, dir );

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "ae %-15.10f %-15.10f %-15.10f", new_az, new_el, curr_dm_list->s_info->twist);
	status = Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d4302 2
a4303 2
	VJOIN1( new_center, eye, -Viewscale, dir );
	MAT_DELTAS_VEC_NEG( toViewcenter, new_center );
d4305 1
a4305 1
	new_mats();
d4307 1
a4307 1
	return( status );
d5044 2
d5111 4
d5308 4
@


11.110
log
@*- mods to the _view() routines
*- new routine, mged_center(), contains partial guts from f_center
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.109 1997/12/23 14:22:49 bparker Exp bparker $ (BRL)";
d103 1
d1851 2
a1852 7
  if(origin != 'v' && origin != 'm' && origin != 'e' && origin != 'k'){
    if(EDIT_ROTATE && ((mged_variables->transform == 'e' &&
			!view_flag && !model_flag) || edit_flag))
      origin = mged_variables->erotate_about;
    else
      origin = mged_variables->rotate_about;
  }
d1925 1
a1925 1
	    switch(mged_variables->ecoords){
d1967 1
a1967 1
	    switch(mged_variables->ecoords){
d2013 1
a2013 1
	    switch(mged_variables->ecoords){
d2055 1
a2055 1
	    switch(mged_variables->ecoords){
d2101 1
a2101 1
	    switch(mged_variables->ecoords){
d2143 1
a2143 1
	    switch(mged_variables->ecoords){
d2189 1
a2189 1
	  switch(mged_variables->ecoords){
d2219 1
a2219 1
	  switch(mged_variables->ecoords){
d2253 1
a2253 1
	  switch(mged_variables->ecoords){
d2283 1
a2283 1
	  switch(mged_variables->ecoords){
d2317 1
a2317 1
	  switch(mged_variables->ecoords){
d2347 1
a2347 1
	  switch(mged_variables->ecoords){
d2414 1
a2414 1
	  switch(mged_variables->ecoords){
d2437 1
a2437 1
	  switch(mged_variables->ecoords){
d2468 1
a2468 1
	switch(mged_variables->ecoords){
d2518 1
a2518 1
	  switch(mged_variables->ecoords){
d2541 1
a2541 1
	  switch(mged_variables->ecoords){
d2572 1
a2572 1
	switch(mged_variables->ecoords){
d2622 1
a2622 1
	  switch(mged_variables->ecoords){
d2645 1
a2645 1
	  switch(mged_variables->ecoords){
d2676 1
a2676 1
	switch(mged_variables->ecoords){
d2727 1
a2727 1
	  switch(mged_variables->ecoords){
d2756 1
a2756 1
	  switch(mged_variables->ecoords){
d2794 1
a2794 1
	  switch(mged_variables->ecoords){
d2823 1
a2823 1
	  switch(mged_variables->ecoords){
d2860 1
a2860 1
	  switch(mged_variables->ecoords){
d2889 1
a2889 1
	  switch(mged_variables->ecoords){
d4386 1
a4386 1
  switch(mged_variables->ecoords){
d4408 2
a4409 2
    save_origin = mged_variables->erotate_about;
    mged_variables->erotate_about = origin;
d4420 1
a4420 1
    mged_variables->erotate_about = save_origin;
d4791 1
a4791 4
  if(EDIT_ROTATE && mged_variables->transform == 'e')
    return mged_rot_xyz(mged_variables->erotate_about, rvec);
  else
    return mged_rot_xyz(mged_variables->rotate_about, rvec);
d4841 1
a4841 4
  if(EDIT_ROTATE && mged_variables->transform == 'e')
    return mged_rot(mged_variables->erotate_about, newrot);
  else
    return mged_rot(mged_variables->rotate_about, newrot);
d4854 1
a4854 1
  switch(mged_variables->ecoords){
d4865 1
d4874 1
a4874 1
    VADD2(es_para, delta, es_keypoint);
@


11.109
log
@*** empty log message ***
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.108 1997/11/26 21:31:39 bparker Exp bparker $ (BRL)";
d91 1
d266 2
d281 18
a298 4
  /* must convert from the local unit to the base unit */
  toViewcenter[MDX] = -atof( argv[1] ) * local2base;
  toViewcenter[MDY] = -atof( argv[2] ) * local2base;
  toViewcenter[MDZ] = -atof( argv[3] ) * local2base;
a305 2

  return TCL_OK;
d1190 1
a1190 1
  fastf_t twist = 0.0;
d1207 1
a1207 2
  }else
    twist = curr_dm_list->s_info->twist;
d4036 3
d4110 1
d4214 3
d4223 1
d4262 3
d4273 1
d4312 3
d4323 1
d4358 3
d4368 1
@


11.108
log
@ifdef code that uses Tcl_UpdateLinkedVar
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.107 1997/11/06 20:03:43 bparker Exp bparker $ (BRL)";
d286 4
d322 9
d559 4
d1667 1
a1667 1
  if(scroll_edit == EDIT_CLASS_ROTATE){
d1677 1
a1677 1
  if(scroll_edit == EDIT_CLASS_SCALE)
d1682 1
a1682 1
  if(es_edclass == EDIT_CLASS_TRAN){
d1703 1
a1703 1
    if(scroll_edit == EDIT_CLASS_ROTATE){
d1713 1
a1713 1
    if(scroll_edit == EDIT_CLASS_SCALE)
d1718 1
a1718 1
    if(es_edclass == EDIT_CLASS_TRAN){
d1728 1
a1728 1
    if(scroll_edit == EDIT_CLASS_ROTATE){
d1738 1
a1738 1
    if(scroll_edit == EDIT_CLASS_SCALE)
d1743 1
a1743 1
    if(es_edclass == EDIT_CLASS_TRAN){
d1880 4
d3605 1
d3607 1
d3610 2
a3611 1
  set_scroll();
d3624 3
d3637 10
a3646 1
  return mged_svbase();
d4037 4
d4096 4
d4207 4
d4253 4
d4299 4
d4339 4
@


11.107
log
@*- use new mged variables: ecoords and erotate_about
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.106 1997/11/03 15:14:28 bparker Exp bparker $ (BRL)";
d82 2
d1141 1
d1143 1
d1649 1
d1674 1
d1899 1
d1901 1
d1907 1
d1909 1
d1916 1
d1918 1
d1929 1
a1929 1

d1931 1
d1941 1
d1943 1
d1949 1
d1951 1
d1958 1
d1960 1
d1971 1
a1971 1

d1973 1
d1987 1
d1989 1
d1995 1
d1997 1
d2004 1
d2006 1
d2017 1
a2017 1

d2019 1
d2029 1
d2031 1
d2037 1
d2039 1
d2046 1
d2048 1
d2059 1
a2059 1

d2061 1
d2075 1
d2077 1
d2083 1
d2085 1
d2092 1
d2094 1
d2105 1
a2105 1

d2107 1
d2117 1
d2119 1
d2125 1
d2127 1
d2134 1
d2136 1
d2147 1
a2147 1

d2149 1
d2163 1
d2165 1
d2171 1
d2173 1
d2181 1
a2181 1

d2183 1
d2193 1
d2195 1
d2201 1
d2203 1
d2211 1
a2211 1

d2213 1
d2227 1
d2229 1
d2235 1
d2237 1
d2245 1
a2245 1

d2247 1
d2257 1
d2259 1
d2265 1
d2267 1
d2275 1
a2275 1

d2277 1
d2291 1
d2293 1
d2299 1
d2301 1
d2309 1
a2309 1

d2311 1
d2321 1
d2323 1
d2329 1
d2331 1
d2339 1
a2339 1

d2341 1
d2350 1
d2352 1
d2355 1
d2357 1
d2362 1
d2364 1
d2367 1
d2369 1
d2476 3
d2580 1
d2582 1
d2684 1
d2686 1
d2701 1
d2703 1
d2708 1
d2710 1
d2731 1
d2733 1
d2739 1
d2741 1
d2768 1
d2770 1
d2775 1
d2777 1
d2798 1
d2800 1
d2806 1
d2808 1
d2834 1
d2836 1
d2841 1
d2843 1
d2864 1
d2866 1
d2872 1
d2874 1
d2898 1
d2900 1
d2904 1
d2906 1
d2915 1
d2917 1
d2921 1
d2923 1
d3299 1
d3303 1
d3305 1
a3305 1

d3307 1
d3719 2
a3720 1
#if 1
d3758 1
a3758 1
#if 1
d4581 1
d4585 1
a4585 1

a4808 1
#if 1
d4816 1
a4816 3
#else
  point_t diff;
  point_t new_pos;
d4818 2
a4819 6
  VMOVE(absolute_model_tran, tvec);
  VSCALE(diff, absolute_model_tran, Viewscale);
  VSUB2(new_pos, orig_pos, diff);
  MAT_DELTAS_VEC_NEG(toViewcenter, new_pos);
#endif
  new_mats();
a4827 1
#if 1
a4837 4
#else
  point_t old_pos;
  point_t new_pos;
  point_t diff;
d4839 1
a4839 8
  VMOVE(absolute_tran, tvec);
  MAT4X3PNT(new_pos, view2model, absolute_tran);
  MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
  VSUB2(diff, new_pos, old_pos);
  VSUB2(new_pos, orig_pos, diff);
  MAT_DELTAS_VEC_NEG(toViewcenter, new_pos);

#if 1
a4843 1
#endif
d4846 3
@


11.106
log
@use LIBDM macros
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.105 1997/10/27 19:14:53 bparker Exp bparker $ (BRL)";
d1813 7
a1819 2
  if(origin != 'v' && origin != 'm' && origin != 'e' && origin != 'k')
    origin = mged_variables->rotate_about;
d1888 1
a1888 1
	    switch(mged_variables->coords){
d1923 1
a1923 1
	    switch(mged_variables->coords){
d1962 1
a1962 1
	    switch(mged_variables->coords){
d1997 1
a1997 1
	    switch(mged_variables->coords){
d2036 1
a2036 1
	    switch(mged_variables->coords){
d2071 1
a2071 1
	    switch(mged_variables->coords){
d2110 1
a2110 1
	  switch(mged_variables->coords){
d2135 1
a2135 1
	  switch(mged_variables->coords){
d2164 1
a2164 1
	  switch(mged_variables->coords){
d2189 1
a2189 1
	  switch(mged_variables->coords){
d2218 1
a2218 1
	  switch(mged_variables->coords){
d2243 1
a2243 1
	  switch(mged_variables->coords){
d2297 1
a2297 1
	  switch(mged_variables->coords){
d2320 1
a2320 1
	  switch(mged_variables->coords){
d2351 1
a2351 1
	switch(mged_variables->coords){
d2398 1
a2398 1
	  switch(mged_variables->coords){
d2421 1
a2421 1
	  switch(mged_variables->coords){
d2452 1
a2452 1
	switch(mged_variables->coords){
d2500 1
a2500 1
	  switch(mged_variables->coords){
d2523 1
a2523 1
	  switch(mged_variables->coords){
d2554 1
a2554 1
	switch(mged_variables->coords){
d2603 1
a2603 1
	  switch(mged_variables->coords){
d2628 1
a2628 1
	  switch(mged_variables->coords){
d2662 1
a2662 1
	  switch(mged_variables->coords){
d2687 1
a2687 1
	  switch(mged_variables->coords){
d2720 1
a2720 1
	  switch(mged_variables->coords){
d2745 1
a2745 1
	  switch(mged_variables->coords){
d4167 1
a4167 1
  switch(mged_variables->coords){
d4189 2
a4190 2
    save_origin = mged_variables->rotate_about;
    mged_variables->rotate_about = origin;
d4201 1
a4201 1
    mged_variables->rotate_about = save_origin;
d4571 4
a4574 1
  return mged_rot_xyz(mged_variables->rotate_about, rvec);
d4621 1
d4624 4
a4627 1
  return mged_rot(mged_variables->rotate_about, newrot);
d4640 1
a4640 1
  switch(mged_variables->coords){
@


11.105
log
@*** empty log message ***
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.104 1997/10/08 12:42:29 bparker Exp bparker $ (BRL)";
d638 1
a638 1
	dmp->dm_debug(dmp, regdebug);
d1003 1
a1003 1
	    dmlp->_dmp->dm_freeDLists(dmlp->_dmp, dmlp->_dmp->dm_displaylist + 1, 1);
d1005 2
a1006 3
	    dmlp->_dmp->dm_freeDLists(dmlp->_dmp,
				      BU_LIST_FIRST(solid, &HeadSolid.l)->s_dlist +
				      dmlp->_dmp->dm_displaylist,
d1214 1
a1214 2
	  dmlp->_dmp->dm_freeDLists(dmlp->_dmp,
				    sp->s_dlist + dmlp->_dmp->dm_displaylist, 1);
d1270 1
a1270 2
	dmlp->_dmp->dm_freeDLists(dmlp->_dmp,
			    sp->s_dlist + dmlp->_dmp->dm_displaylist, 1);
@


11.104
log
@add calls to help to display usage message
@
text
@a32 1
 *      f_tran          Translate view center
d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.103 1997/09/11 13:29:18 bparker Exp bparker $ (BRL)";
@


11.103
log
@mods to f_zap() to properly free "new" display lists
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.102 1997/09/08 19:46:57 bparker Exp bparker $ (BRL)";
d3843 9
d3885 10
d3947 4
d3964 4
d3992 9
d4044 10
d4086 10
d4129 9
@


11.102
log
@remove f_fix()
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.101 1997/09/08 18:27:58 bparker Exp bparker $ (BRL)";
d1000 3
a1002 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist)
d1004 1
a1004 3
	    dmlp->_dmp->dm_freeDLists(dmlp->_dmp,
				      HeadSolid.s_dlist + dmlp->_dmp->dm_displaylist,
				      1);
d1007 2
a1008 1
				      HeadSolid.s_dlist + dmlp->_dmp->dm_displaylist,
d1010 1
a1010 1
				      HeadSolid.s_dlist + 1);
@


11.101
log
@*- new macro FOR_ALL_DISPLAYS
*- mged_variables is now a pointer
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.100 1997/09/03 14:14:09 bparker Exp bparker $ (BRL)";
a1081 22
/* Fix the display processor after a hardware error by re-attaching */
int
f_fix(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help fix");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return reattach();
}

int
@


11.100
log
@mods to implement new display lists
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.99 1997/08/22 22:30:17 mike Exp bparker $ (BRL)";
a100 1
extern mat_t    ModelDelta;     /* from ged.c */
d199 2
a200 2
  for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
    if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
d242 2
a243 2
  for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
    if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
d529 1
a529 1
  for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
d537 1
a537 1
    if (mged_variables.autosize  && initial_blank_screen &&
a558 1
  bu_vls_printf(&vls, "%d total solid(s)\n", BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist);
d999 2
a1000 2
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist)
d1235 2
a1236 2
      for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist)
d1292 2
a1293 2
    for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
      if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist)
d1667 1
a1667 1
  if(!mged_variables.rateknobs)
d1704 1
a1704 1
  if(mged_variables.rateknobs){
d1756 1
a1756 1
  if(mged_variables.adcflag){
d1839 1
a1839 1
    origin = mged_variables.rotate_about;
d1906 1
a1906 1
	  if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d1908 1
a1908 1
	    switch(mged_variables.coords){
d1930 1
a1930 1
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d1941 1
a1941 1
	  if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d1943 1
a1943 1
	    switch(mged_variables.coords){
d1965 1
a1965 1
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d1980 1
a1980 1
	  if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d1982 1
a1982 1
	    switch(mged_variables.coords){
d2004 1
a2004 1
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2015 1
a2015 1
	  if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2017 1
a2017 1
	    switch(mged_variables.coords){
d2039 1
a2039 1
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2054 1
a2054 1
	  if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2056 1
a2056 1
	    switch(mged_variables.coords){
d2078 1
a2078 1
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2089 1
a2089 1
	  if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2091 1
a2091 1
	    switch(mged_variables.coords){
d2113 1
a2113 1
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2128 1
a2128 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2130 1
a2130 1
	  switch(mged_variables.coords){
d2145 1
a2145 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag))
d2153 1
a2153 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2155 1
a2155 1
	  switch(mged_variables.coords){
d2170 1
a2170 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag))
d2182 1
a2182 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2184 1
a2184 1
	  switch(mged_variables.coords){
d2199 1
a2199 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag))
d2207 1
a2207 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2209 1
a2209 1
	  switch(mged_variables.coords){
d2224 1
a2224 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag))
d2236 1
a2236 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2238 1
a2238 1
	  switch(mged_variables.coords){
d2253 1
a2253 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag))
d2261 1
a2261 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2263 1
a2263 1
	  switch(mged_variables.coords){
d2278 1
a2278 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag))
d2290 1
a2290 1
	if(EDIT_SCALE && ((mged_variables.transform == 'e' && !view_flag) || edit_flag)){
d2298 1
a2298 1
	if(EDIT_SCALE && ((mged_variables.transform == 'e' && !view_flag) || edit_flag)){
d2315 1
a2315 1
	if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2317 1
a2317 1
	  switch(mged_variables.coords){
d2329 1
a2329 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2338 1
a2338 1
	if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2340 1
a2340 1
	  switch(mged_variables.coords){
d2355 1
a2355 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2366 1
a2366 1
      if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2371 1
a2371 1
	switch(mged_variables.coords){
d2396 1
a2396 1
	if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2416 1
a2416 1
	if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2418 1
a2418 1
	  switch(mged_variables.coords){
d2430 1
a2430 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2439 1
a2439 1
	if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2441 1
a2441 1
	  switch(mged_variables.coords){
d2456 1
a2456 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2467 1
a2467 1
      if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2472 1
a2472 1
	switch(mged_variables.coords){
d2497 1
a2497 1
	if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2518 1
a2518 1
	if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2520 1
a2520 1
	  switch(mged_variables.coords){
d2532 1
a2532 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2541 1
a2541 1
	if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2543 1
a2543 1
	  switch(mged_variables.coords){
d2558 1
a2558 1
	  if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2569 1
a2569 1
      if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2574 1
a2574 1
	switch(mged_variables.coords){
d2599 1
a2599 1
	if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2621 1
a2621 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2623 1
a2623 1
	  switch(mged_variables.coords){
d2636 1
a2636 1
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2646 1
a2646 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2648 1
a2648 1
	  switch(mged_variables.coords){
d2663 1
a2663 1
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2680 1
a2680 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2682 1
a2682 1
	  switch(mged_variables.coords){
d2695 1
a2695 1
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2705 1
a2705 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2707 1
a2707 1
	  switch(mged_variables.coords){
d2722 1
a2722 1
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2738 1
a2738 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2740 1
a2740 1
	  switch(mged_variables.coords){
d2753 1
a2753 1
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2763 1
a2763 1
	if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2765 1
a2765 1
	  switch(mged_variables.coords){
d2780 1
a2780 1
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
d2795 1
a2795 1
	if(EDIT_SCALE && ((mged_variables.transform == 'e' && !view_flag) || edit_flag)){
d2808 1
a2808 1
	if(EDIT_SCALE && ((mged_variables.transform == 'e' && !view_flag) || edit_flag)){
d2947 1
a2947 1
  if(EDIT_TRAN && ((mged_variables.transform == 'e' &&
d2950 1
a2950 1
  else if(model_flag || (mged_variables.coords == 'm' && !view_flag))
d2966 1
a2966 1
  if(EDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2969 1
a2969 1
  else if(model_flag || (mged_variables.coords == 'm' && !view_flag))
d4122 1
a4122 1
  switch(mged_variables.coords){
d4144 2
a4145 2
    save_origin = mged_variables.rotate_about;
    mged_variables.rotate_about = origin;
d4156 1
a4156 1
    mged_variables.rotate_about = save_origin;
d4342 1
a4342 1
  return mged_mrot_xyz(mged_variables.rotate_about, rvec);
d4461 1
a4461 1
  return mged_vrot_xyz(mged_variables.rotate_about, rvec);
d4469 1
a4469 1
     mged_variables.transform == 'e')
d4473 1
a4473 1
  if(mged_variables.coords == 'm')
d4526 1
a4526 1
  return mged_rot_xyz(mged_variables.rotate_about, rvec);
d4575 1
a4575 1
  return mged_rot(mged_variables.rotate_about, newrot);
d4588 1
a4588 1
  switch(mged_variables.coords){
d4692 1
a4692 1
      mged_variables.transform == 'e')
d4696 1
a4696 1
  if(mged_variables.coords == 'm')
d4867 1
a4867 1
    mged_variables.transform == 'e')
@


11.99
log
@BParker mods to eliminate old MGED displaylist mode.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.98 1997/07/28 20:05:49 bparker Exp bparker $ (BRL)";
d178 2
d199 10
a208 1
  /* XXX do dm_freeDList() for each solid deleted */
d221 2
d242 11
a347 10
  if( dmp->dm_displaylist )  {
    /*
     * Force out the control list with NO solids being drawn,
     * then the display processor will not mind when we start
     * writing new subroutines out there...
     */
    update_views = 1;
    refresh();
  }

a369 2
  update_views = 1;

a390 2
  update_views = 1;

a422 2
  update_views = 1;

d492 3
d514 1
a514 5
  if( dmp->dm_displaylist )  {
    /* Force displaylist update before starting new drawing */
    update_views = 1;
    refresh();
  }
d528 21
a548 2
  bu_vls_printf(&vls, "%ld vectors in %g sec\n", nvectors, elapsed_time);
  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d550 1
a550 22
  {
    register struct dm_list *p;
    struct dm_list *save_dm_list;
    struct cmd_list *save_cmd_list;

    save_dm_list = curr_dm_list;
    save_cmd_list = curr_cmd_list;
    for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
      curr_dm_list = p;
      if(curr_dm_list->aim)
	curr_cmd_list = curr_dm_list->aim;
      else
	curr_cmd_list = &head_cmd_list;

      /* If we went from blank screen to non-blank, resize */
      if (mged_variables.autosize  && initial_blank_screen &&
	  BU_LIST_NON_EMPTY(&HeadSolid.l)) {
	struct view_list *vlp;

	size_reset();
	new_mats();
	(void)mged_svbase();
d552 4
a555 3
	for(BU_LIST_FOR(vlp, view_list, &headView.l))
	  vlp->vscale = Viewscale;
      }
d557 2
a558 2
      color_soltab();
    }
d560 3
a562 3
    curr_dm_list = save_dm_list;
    curr_cmd_list = save_cmd_list;
  }
d978 1
d1000 16
d1025 1
a1031 1
	/*XXX dm_freeDList() */
d1219 1
a1225 2
  /* XXX do dm_freeDList() for each solid deleted */

d1233 12
d1274 1
a1281 2
  /* XXX do dm_freeDList() for each solid deleted */

d1289 12
@


11.98
log
@*- mods to f_knob
*- new routines ----> mged_scale(), mged_vacale(), mged_escale()
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.97 1997/07/25 20:43:22 bparker Exp bparker $ (BRL)";
d197 2
a198 1
  no_memory = 0;
a228 1
  no_memory = 0;
a499 1
      no_memory = 0;
a551 3
#if 0
      dmp->dm_colorchange(dmp);
#endif
a987 1
	no_memory = 0;
a994 1
		rt_memfree( &(dmp->dm_map), sp->s_bytes, (unsigned long)sp->s_addr );
a1001 1
		sp->s_addr = sp->s_bytes = 0;
d1008 2
d1202 2
a1212 1
      rt_memfree( &(dmp->dm_map), sp->s_bytes, (unsigned long)sp->s_addr );
d1247 2
a1259 1
    rt_memfree(&(dmp->dm_map), sp->s_bytes, (unsigned long)sp->s_addr);
@


11.97
log
@some new commands and mods to f_knob()
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.96 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d141 5
a145 1
struct dm_list *edit_dm_list;
d1872 1
a1872 1
	      edit_dm_list = curr_dm_list;
d1878 1
a1878 1
	      edit_dm_list = curr_dm_list;
d1885 1
a1885 1
	      edit_dm_list = curr_dm_list;
d1907 1
a1907 1
	      edit_dm_list = curr_dm_list;
d1913 1
a1913 1
	      edit_dm_list = curr_dm_list;
d1920 1
a1920 1
	      edit_dm_list = curr_dm_list;
d1946 1
a1946 1
	      edit_dm_list = curr_dm_list;
d1952 1
a1952 1
	      edit_dm_list = curr_dm_list;
d1959 1
a1959 1
	      edit_dm_list = curr_dm_list;
d1981 1
a1981 1
	      edit_dm_list = curr_dm_list;
d1987 1
a1987 1
	      edit_dm_list = curr_dm_list;
d1994 1
a1994 1
	      edit_dm_list = curr_dm_list;
d2020 1
a2020 1
	      edit_dm_list = curr_dm_list;
d2026 1
a2026 1
	      edit_dm_list = curr_dm_list;
d2033 1
a2033 1
	      edit_dm_list = curr_dm_list;
d2055 1
a2055 1
	      edit_dm_list = curr_dm_list;
d2061 1
a2061 1
	      edit_dm_list = curr_dm_list;
d2068 1
a2068 1
	      edit_dm_list = curr_dm_list;
d2094 1
a2094 1
	    edit_dm_list = curr_dm_list;
d2100 1
a2100 1
	    edit_dm_list = curr_dm_list;
d2119 1
a2119 1
	    edit_dm_list = curr_dm_list;
d2125 1
a2125 1
	    edit_dm_list = curr_dm_list;
d2148 1
a2148 1
	    edit_dm_list = curr_dm_list;
d2154 1
a2154 1
	    edit_dm_list = curr_dm_list;
d2173 1
a2173 1
	    edit_dm_list = curr_dm_list;
d2179 1
a2179 1
	    edit_dm_list = curr_dm_list;
d2202 1
a2202 1
	    edit_dm_list = curr_dm_list;
d2208 1
a2208 1
	    edit_dm_list = curr_dm_list;
d2227 1
a2227 1
	    edit_dm_list = curr_dm_list;
d2233 1
a2233 1
	    edit_dm_list = curr_dm_list;
d3116 1
d3120 1
d3123 1
d3125 1
d4700 134
d4840 2
d4852 6
a4857 1
  return TCL_OK;
@


11.96
log
@mods to run without a database
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.95 1997/06/25 13:03:19 bparker Exp bparker $ (BRL)";
d111 21
a131 4
#if 1
int edit_abs_tran[3];
int abs_tran[3];
#endif
a132 9
vect_t edit_absolute_rotate;
vect_t last_edit_absolute_rotate;
vect_t edit_rate_rotate;
int edit_rateflag_rotate;

vect_t edit_absolute_tran;
vect_t edit_rate_tran;
int edit_rateflag_tran;

d137 6
d144 5
a148 2
struct bu_vls edit_rate_tran_vls[3];
struct bu_vls edit_rate_rotate_vls[3];
d150 5
a154 2
struct bu_vls edit_absolute_tran_vls[3];
struct bu_vls edit_absolute_rotate_vls[3];
a260 202
/*
 *                     M G E D _ M R O T
 */
mged_mrot(origin, x, y, z)
char origin;
double x, y, z;
{
  static int recurse = 1;
  mat_t newrot;
  mat_t invtvc;
  mat_t viewchg, viewchginv;
  point_t new_model_center;
  point_t new_view_center;
  point_t new_origin;
  point_t vrot_pt;
  point_t old_pos, new_pos;
  point_t diff;
  vect_t view_direc, model_direc;

  bn_mat_idn( invtvc );
  bn_mat_idn( newrot );
  buildHrot( newrot, -x * degtorad, -y * degtorad, -z * degtorad);

  if(origin == 'e' || origin == 'm'){
    /* find view direction vector */
    VSET( model_direc, 0, 0, 1 );
    MAT4X3VEC( view_direc, model2view, model_direc );

    VSET( new_origin, 0, 0, 0 );    /* point in model space */

    /* find view rotation point */
    if(origin == 'e'){
      /*XXXXX rotating in model space about the view eye does not work, yet!!! */
      VSET( vrot_pt, 0, 0, 1 );          /* point to rotate around */
    }else{
      MAT4X3PNT( vrot_pt, model2view, new_origin ); /* point in view space */
    }

    /* find view rotation matrix */
    wrt_point_direc( viewchg, newrot, bn_mat_identity, vrot_pt, view_direc );
    bn_mat_inv( viewchginv, viewchg );

    /* find new toViewcenter */
    MAT4X3PNT( new_view_center, viewchginv, new_origin );
    MAT4X3PNT( new_model_center, view2model, new_view_center );
    MAT_DELTAS_VEC_NEG( toViewcenter, new_model_center );

    /* find new view2model  ---  used to find new model2view */
    bn_mat_mul2( newrot, view2model );

    /* find inverse of toViewcenter  ---  used to find new Viewrot */
    MAT_DELTAS_VEC( invtvc, new_model_center );

    /* find new model2view  --- used to find new Viewrot */
    bn_mat_inv( model2view, view2model );
    model2view[15] = 1.0;

    /* find new Viewrot */
    bn_mat_mul( Viewrot, model2view, invtvc );

    Viewrot[3] = 0.0;
    Viewrot[7] = 0.0;
    Viewrot[11] = 0.0;

    /* recalculate toViewcenter */
    bn_mat_inv( viewchginv, Viewrot );
    bn_mat_mul( toViewcenter, viewchginv, model2view );
  }else{
    /* find new view2model  ---  used to find new model2view */
    wrt_view( view2model, newrot, view2model);

    /* find inverse of toViewcenter  ---  used to find new Viewrot */
    MAT_DELTAS( invtvc, -toViewcenter[MDX], -toViewcenter[MDY], -toViewcenter[MDZ] );

    /* find new model2view  --- used to find new Viewrot */
    bn_mat_inv( model2view, view2model );
    model2view[15] = 1.0;

    /* find new Viewrot */
    bn_mat_mul( Viewrot, model2view, invtvc );
  }

  new_mats();
  set_absolute_tran();

  return TCL_OK;
}

int
f_mrot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
{
  if(argc < 4 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help mrot");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return mged_mrot(mged_variables.rotate_about, atof(argv[1]),
		   atof(argv[2]), atof(argv[3]));
}

/*
 *			M G E D _ V R O T
 */
int
mged_vrot(origin, x, y, z)
char origin;
double x, y, z;
{
  mat_t newrot;
  vect_t new_pos;
  mat_t   newinv;

  bn_mat_idn( newrot );
  buildHrot( newrot, x * degtorad, y * degtorad, z * degtorad);
  bn_mat_inv( newinv, newrot );

  if(origin == 'e' || origin == 'm'){
    point_t		rot_pt;
    point_t		new_origin;
    mat_t		viewchg, viewchginv;
    point_t		new_cent_view;
    point_t		new_cent_model;

    if(origin == 'e'){
      /* "VR driver" method: rotate around "eye" point (0,0,1) viewspace */
      VSET( rot_pt, 0, 0, 1 );		/* point to rotate around */
    }else{
      /* rotate around model center (0,0,0) */
      VSET( new_origin, 0, 0, 0 );
      MAT4X3PNT( rot_pt, model2view, new_origin);  /* point to rotate around */
    }

    bn_mat_xform_about_pt( viewchg, newrot, rot_pt );
    bn_mat_inv( viewchginv, viewchg );

    /* Convert origin in new (viewchg) coords back to old view coords */
    VSET( new_origin, 0, 0, 0 );
    MAT4X3PNT( new_cent_view, viewchginv, new_origin );
    MAT4X3PNT( new_cent_model, view2model, new_cent_view );
    MAT_DELTAS_VEC_NEG( toViewcenter, new_cent_model );

    /* XXX This should probably capture the translation too */
    /* XXX I think the only consumer of ModelDelta is the predictor frame */
    wrt_view( ModelDelta, newinv, ModelDelta );		/* pure rotation */

    /* Update the rotation component of the model2view matrix */
    bn_mat_mul2( newrot, Viewrot );			/* pure rotation */
    new_mats();

    set_absolute_tran();
  } else {
    /* Traditional method:  rotate around view center (0,0,0) viewspace */
    wrt_view( ModelDelta, newinv, ModelDelta );

    /* Update the rotation component of the model2view matrix */
    bn_mat_mul2( newrot, Viewrot );			/* pure rotation */
    new_mats();

    if(absolute_tran[X] != 0.0 ||
       absolute_tran[Y] != 0.0 ||
       absolute_tran[Z] != 0.0){
      set_absolute_tran();
    }
  }

  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));

  return TCL_OK;
}

int
f_vrot(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(argc < 4 || 4 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help vrot");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return mged_vrot(mged_variables.rotate_about, atof(argv[1]),
		   atof(argv[2]), atof(argv[3]));
}

d1572 30
a1601 2
  if( rate_zoom != 0.0 )
    rateflag_zoom = 1;
d1603 1
a1603 1
    rateflag_zoom = 0;
d1605 6
a1610 19
  if(EDIT_TRAN){
    if( edit_rate_tran[X] != 0.0 ||
	edit_rate_tran[Y] != 0.0 ||
	edit_rate_tran[Z] != 0.0 )
      edit_rateflag_tran = 1;
    else
      edit_rateflag_tran = 0;
  }else 
    edit_rateflag_tran = 0;

  if(EDIT_ROTATE){
    if( edit_rate_rotate[X] != 0.0 ||
	edit_rate_rotate[Y] != 0.0 ||
	edit_rate_rotate[Z] != 0.0 )
      edit_rateflag_rotate = 1;
    else
      edit_rateflag_rotate = 0;
  }else
    edit_rateflag_rotate = 0;
d1612 3
a1614 6
  if(EDIT_SCALE){
    if( edit_rate_scale )
      edit_rateflag_scale = 1;
    else
      edit_rateflag_scale = 0;
  }else
a1616 5
  if( rate_azimuth )
    rateflag_azimuth = 1;
  else
    rateflag_azimuth = 0;
    
d1627 3
a1629 3
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Z]));
d1642 3
a1644 3
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[Z]));
d1662 3
a1664 3
      bu_vls_printf(&vls, "x = %f\n", edit_rate_rotate[X]);
      bu_vls_printf(&vls, "y = %f\n", edit_rate_rotate[Y]);
      bu_vls_printf(&vls, "z = %f\n", edit_rate_rotate[Z]);
d1674 1
a1674 1
      bu_vls_printf(&vls, "S = %f\n", rate_zoom);
d1677 3
a1679 3
      bu_vls_printf(&vls, "X = %f\n", edit_rate_tran[X]);
      bu_vls_printf(&vls, "Y = %f\n", edit_rate_tran[Y]);
      bu_vls_printf(&vls, "Z = %f\n", edit_rate_tran[Z]);
d1687 3
a1689 3
      bu_vls_printf(&vls, "ax = %f\n", edit_absolute_rotate[X]);
      bu_vls_printf(&vls, "ay = %f\n", edit_absolute_rotate[Y]);
      bu_vls_printf(&vls, "az = %f\n", edit_absolute_rotate[Z]);
d1699 1
a1699 1
      bu_vls_printf(&vls, "aS = %f\n", absolute_zoom);
d1702 3
a1704 3
      bu_vls_printf(&vls, "aX = %f\n", edit_absolute_tran[X]);
      bu_vls_printf(&vls, "aY = %f\n", edit_absolute_tran[Y]);
      bu_vls_printf(&vls, "aZ = %f\n", edit_absolute_tran[Z]);
d1736 1
d1738 1
d1743 1
d1794 1
a1794 1
  if(origin != 'v' && origin != 'm' && origin != 'e')
d1801 3
d1814 6
a1819 3
      rate_zoom = 0;
      VSETALL( edit_rate_rotate, 0 );
      VSETALL( edit_rate_tran, 0 );
a1820 1
      rate_azimuth = 0.0;
d1864 21
a1884 2
	    edit_rate_rotate[X] += f;
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[X]));
d1899 21
a1919 2
	    edit_rate_rotate[X] = f;
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[X]));
d1938 21
a1958 2
	    edit_rate_rotate[Y] += f;
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Y]));
d1973 21
a1993 2
	    edit_rate_rotate[Y] = f;
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Y]));
d2012 21
a2032 2
	    edit_rate_rotate[Z] += f;
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Z]));
d2047 21
a2067 2
	    edit_rate_rotate[Z] = f;
	    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_rotate_vls[Z]));
d2086 14
a2099 2
	  edit_rate_tran[X] += f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[X]));
d2111 14
a2124 2
	  edit_rate_tran[X] = f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[X]));
d2140 14
a2153 2
	  edit_rate_tran[Y] += f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[Y]));
d2164 15
a2178 3
			  !view_flag && !model_flag) || edit_flag)){
	  edit_rate_tran[Y] = f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[Y]));
d2194 14
a2207 2
	  edit_rate_tran[Z] += f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[Z]));
d2219 14
a2232 2
	  edit_rate_tran[Z] = f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_rate_tran_vls[Z]));
d2250 1
a2250 1
	  rate_zoom += f;
d2258 1
a2258 1
	  rate_zoom = f;
d2271 1
a2271 1
	if(SEDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2273 14
a2286 10
	  edit_absolute_rotate[X] += f;
	  (void)mged_param(interp, 3, edit_absolute_rotate);
	}else {
	  if(OEDIT_ROTATE && ((mged_variables.transform == 'e' &&
			       !view_flag && !model_flag) || edit_flag)){
	    tvec[X] = f;
	    tvec[Y] = 0.0;
	    tvec[Z] = 0.0;
	    mged_rot_obj(interp, 1, tvec);
	    edit_absolute_rotate[X] += f;
a2287 5
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	      (void)mged_mrot(origin, f, 0.0, 0.0);
	    else
	      (void)mged_vrot(origin, f, 0.0, 0.0);

d2291 2
d2294 1
a2294 1
	if(SEDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2296 18
a2313 10
	  edit_absolute_rotate[X] = f;
	  (void)mged_param(interp, 3, edit_absolute_rotate);
	}else {
	  if(OEDIT_ROTATE && ((mged_variables.transform == 'e' &&
			       !view_flag && !model_flag) || edit_flag)){
	    tvec[X] = f - last_edit_absolute_rotate[X];
	    tvec[Y] = 0.0;
	    tvec[Z] = 0.0;
	    mged_rot_obj(interp, 1, tvec);
	    edit_absolute_rotate[X] = f;
d2315 1
a2315 5
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	      (void)mged_mrot(origin, f - last_absolute_rotate[X], 0.0, 0.0);
	    else
	      mged_vrot(origin, f - last_absolute_rotate[X], 0.0, 0.0);

d2324 2
a2325 4
	if(edit_absolute_rotate[X] < -180.0)
	  edit_absolute_rotate[X] = edit_absolute_rotate[X] + 360.0;
	else if(edit_absolute_rotate[X] > 180.0)
	  edit_absolute_rotate[X] = edit_absolute_rotate[X] - 360.0;
d2327 21
a2347 2
	last_edit_absolute_rotate[X] = edit_absolute_rotate[X];
	Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[X]));
d2349 10
a2358 4
	if(absolute_rotate[X] < -180.0)
	  absolute_rotate[X] = absolute_rotate[X] + 360.0;
	else if(absolute_rotate[X] > 180.0)
	  absolute_rotate[X] = absolute_rotate[X] - 360.0;
d2360 6
a2365 2
	last_absolute_rotate[X] = absolute_rotate[X];
	Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_rotate_vls[X]));
d2368 1
d2372 1
a2372 1
	if(SEDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2374 14
a2387 10
	  edit_absolute_rotate[Y] += f;
	  (void)mged_param(interp, 3, edit_absolute_rotate);
	}else {
	  if(OEDIT_ROTATE && ((mged_variables.transform == 'e' &&
			       !view_flag && !model_flag) || edit_flag)){
	    tvec[X] = 0.0;
	    tvec[Y] = f;
	    tvec[Z] = 0.0;
	    mged_rot_obj(interp, 1, tvec);
	    edit_absolute_rotate[Y] += f;
a2388 5
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	      (void)mged_mrot(origin, 0.0, f, 0.0);
	    else
	      (void)mged_vrot(origin, 0.0, f, 0.0);

d2392 2
d2395 1
a2395 1
	if(SEDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2397 18
a2414 10
	  edit_absolute_rotate[Y] = f;
	  (void)mged_param(interp, 3, edit_absolute_rotate);
	}else {
	  if(OEDIT_ROTATE && ((mged_variables.transform == 'e' &&
			       !view_flag && !model_flag) || edit_flag)){
	    tvec[X] = 0.0;
	    tvec[Y] = f - last_edit_absolute_rotate[Y];
	    tvec[Z] = 0.0;
	    mged_rot_obj(interp, 1, tvec);
	    edit_absolute_rotate[Y] = f;
d2416 1
a2416 5
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	      (void)mged_mrot(origin, 0.0, f - last_absolute_rotate[Y], 0.0);
	    else
	      mged_vrot(origin, 0.0, f - last_absolute_rotate[Y], 0.0);

d2425 22
a2446 4
	if(edit_absolute_rotate[Y] < -180.0)
	  edit_absolute_rotate[Y] = edit_absolute_rotate[Y] + 360.0;
	else if(edit_absolute_rotate[Y] > 180.0)
	  edit_absolute_rotate[Y] = edit_absolute_rotate[Y] - 360.0;
d2448 1
a2448 2
	last_edit_absolute_rotate[Y] = edit_absolute_rotate[Y];
	Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[Y]));
d2450 15
a2464 4
	if(absolute_rotate[Y] < -180.0)
	  absolute_rotate[Y] = absolute_rotate[Y] + 360.0;
	else if(absolute_rotate[Y] > 180.0)
	  absolute_rotate[Y] = absolute_rotate[Y] - 360.0;
d2466 1
a2466 1
	last_absolute_rotate[Y] = absolute_rotate[Y];
d2470 1
d2474 1
a2474 1
	if(SEDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2476 14
a2489 10
	  edit_absolute_rotate[Z] += f;
	  (void)mged_param(interp, 3, edit_absolute_rotate);
	}else {
	  if(OEDIT_ROTATE && ((mged_variables.transform == 'e' &&
			       !view_flag && !model_flag) || edit_flag)){
	    tvec[X] = 0.0;
	    tvec[Y] = 0.0;
	    tvec[Z] = f;
	    mged_rot_obj(interp, 1, tvec);
	    edit_absolute_rotate[Z] += f;
a2490 5
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	      (void)mged_mrot(origin, 0.0, 0.0, f);
	    else
	      (void)mged_vrot(origin, 0.0, 0.0, f);

d2494 2
d2497 1
a2497 1
	if(SEDIT_ROTATE && ((mged_variables.transform == 'e' &&
d2499 18
a2516 10
	  edit_absolute_rotate[Z] = f;
	  (void)mged_param(interp, 3, edit_absolute_rotate);
	}else {
	  if(OEDIT_ROTATE && ((mged_variables.transform == 'e' &&
			       !view_flag && !model_flag) || edit_flag)){
	    tvec[X] = 0.0;
	    tvec[Y] = 0.0;
	    tvec[Z] = f - last_edit_absolute_rotate[Z];
	    mged_rot_obj(interp, 1, tvec);
	    edit_absolute_rotate[Z] = f;
d2518 1
a2518 5
	    if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	      (void)mged_mrot(origin, 0.0, 0.0, f - last_absolute_rotate[Z]);
	    else
	      mged_vrot(origin, 0.0, 0.0, f - last_absolute_rotate[Z]);

d2527 22
a2548 4
	if(edit_absolute_rotate[Z] < -180.0)
	  edit_absolute_rotate[Z] = edit_absolute_rotate[Z] + 360.0;
	else if(edit_absolute_rotate[Z] > 180.0)
	  edit_absolute_rotate[Z] = edit_absolute_rotate[Z] - 360.0;
d2550 1
a2550 2
	last_edit_absolute_rotate[Z] = edit_absolute_rotate[Z];
	Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_rotate_vls[Z]));
d2552 2
a2553 4
	if(absolute_rotate[Z] < -180.0)
	  absolute_rotate[Z] = absolute_rotate[Z] + 360.0;
	else if(absolute_rotate[Z] > 180.0)
	  absolute_rotate[Z] = absolute_rotate[Z] - 360.0;
d2555 14
a2568 1
	last_absolute_rotate[Z] = absolute_rotate[Z];
d2572 1
d2575 1
d2579 22
a2600 6
	  edit_absolute_tran[X] += f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[X]));
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	  absolute_model_tran[X] += f;
	else
	  absolute_tran[X] += f;
d2604 24
a2627 6
	  edit_absolute_tran[X] = f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[X]));
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	  absolute_model_tran[X] = f;
	else
	  absolute_tran[X] = f;
d2634 1
d2638 22
a2659 6
	  edit_absolute_tran[Y] += f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Y]));
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	  absolute_model_tran[Y] += f;
	else
	  absolute_tran[Y] += f;
d2663 24
a2686 6
	  edit_absolute_tran[Y] = f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Y]));
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	  absolute_model_tran[Y] = f;
	else
	  absolute_tran[Y] = f;
d2692 1
d2696 20
a2715 6
	  edit_absolute_tran[Z] += f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Z]));
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	  absolute_model_tran[Z] += f;
	else
	  absolute_tran[Z] += f;
d2717 1
d2721 24
a2744 6
	  edit_absolute_tran[Z] = f;
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&edit_absolute_tran_vls[Z]));
	}else if(model_flag || (mged_variables.coords == 'm' && !view_flag))
	  absolute_model_tran[Z] = f;
	else
	  absolute_tran[Z] = f;
d2759 1
a2759 1
	  absolute_zoom += f;
d2772 1
a2772 1
	  absolute_zoom = f;
a2781 14
  } else if( strcmp( cmd, "azim" ) == 0 ) {
    if(incr_flag)
      rate_azimuth += f;
    else
      rate_azimuth = f;

    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&rate_azimuth_vls));
  } else if( strcmp( cmd, "aazim" ) == 0 ) {
    if(incr_flag)
      (void)mged_aetview(1, f, 0.0, 0.0);
    else
      (void)mged_aetview(0, f, curr_dm_list->s_info->elevation, curr_dm_list->s_info->twist);

    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_azimuth_vls));
d2882 4
a2885 1
    (void)knob_tran(interp, model_flag, view_flag, edit_flag);
d2892 2
a2893 2
knob_tran(interp, model_flag, view_flag, edit_flag)
Tcl_Interp *interp;
d2901 1
d2904 6
a2909 38
		    !view_flag && !model_flag) || edit_flag)){
    VSCALE(diff, edit_absolute_tran, Viewscale);
    VADD2(model_pos, diff, e_axes_pos);
    MAT4X3PNT(new_pos, model2view, model_pos);

    if(state == ST_S_EDIT)
      sedit_trans(new_pos);
    else
      oedit_trans(new_pos);

    return TCL_OK;
  }

  if(model_flag || (mged_variables.coords == 'm' && !view_flag)){
    mged_mtran(interp, absolute_model_tran);

    if(absolute_tran[X] != 0.0 ||
       absolute_tran[Y] != 0.0 ||
       absolute_tran[Z] != 0.0){
      /* calculate absolute_tran */
      MAT4X3PNT(absolute_tran, model2view, orig_pos);
    }else{
      VMOVE(absolute_tran, absolute_model_tran);
    }
  }else{
    mged_tran(interp, absolute_tran);

    if(absolute_tran[X] != 0.0 ||
       absolute_tran[Y] != 0.0 ||
       absolute_tran[Z] != 0.0){
      /* calculate absolute_model_tran */
      MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
      VSUB2(diff, orig_pos, new_pos);
      VSCALE(absolute_model_tran, diff, 1/Viewscale);
    }else{
      VMOVE(absolute_model_tran, absolute_tran);
    }
  }
d2914 7
a2920 2
void
mged_do_rate_rotate()
d2922 7
a2928 25
  (void)mged_vrot(mged_variables.rotate_about, rate_rotate[X], rate_rotate[Y], rate_rotate[Z]);
  absolute_rotate[X] += rate_rotate[X];
  absolute_rotate[Y] += rate_rotate[Y];
  absolute_rotate[Z] += rate_rotate[Z];

  if(absolute_rotate[X] < -180.0)
    absolute_rotate[X] = absolute_rotate[X] + 360.0;
  else if(absolute_rotate[X] > 180.0)
    absolute_rotate[X] = absolute_rotate[X] - 360.0;

  last_absolute_rotate[X] = absolute_rotate[X];
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_rotate_vls[X]));

  if(absolute_rotate[Y] < -180.0)
    absolute_rotate[Y] = absolute_rotate[Y] + 360.0;
  else if(absolute_rotate[Y] > 180.0)
    absolute_rotate[Y] = absolute_rotate[Y] - 360.0;

  last_absolute_rotate[Y] = absolute_rotate[Y];
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_rotate_vls[Y]));

  if(absolute_rotate[Z] < -180.0)
    absolute_rotate[Z] = absolute_rotate[Z] + 360.0;
  else if(absolute_rotate[Z] > 180.0)
    absolute_rotate[Z] = absolute_rotate[Z] - 360.0;
d2930 1
a2930 11
  last_absolute_rotate[Z] = absolute_rotate[Z];
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_rotate_vls[Z]));
}

void
mged_do_rate_tran()
{
  absolute_tran[X] += rate_tran[X] * 0.1;
  absolute_tran[Y] += rate_tran[Y] * 0.1;
  absolute_tran[Z] += rate_tran[Z] * 0.1;
  mged_tran(interp, absolute_tran);
a2932 2


d3083 1
a3083 1
/* absolute_zoom's value range is [-1.0, 1.0] */
d3090 1
a3090 1
  if(-SMALL_FASTF < absolute_zoom && absolute_zoom < SMALL_FASTF)
d3094 1
a3094 1
    if(absolute_zoom > 0){
d3096 1
a3096 1
      Viewscale = i_Viewscale * (1.0 - absolute_zoom);
d3099 1
a3099 1
      Viewscale = i_Viewscale * (1.0 + (absolute_zoom * -9.0));
d3137 3
a3139 3
  absolute_zoom = 1.0 - Viewscale / i_Viewscale;
  if(absolute_zoom < 0.0)
    absolute_zoom /= 9.0;
a3366 191
mged_mtran(interp, pt)
Tcl_Interp *interp;
point_t pt;
{
  point_t diff;
  point_t new_pos;

  VMOVE(absolute_model_tran, pt);
  VSCALE(diff, absolute_model_tran, Viewscale);
  VSUB2(new_pos, orig_pos, diff);
  MAT_DELTAS_VEC_NEG(toViewcenter, new_pos);
#if 0
  MAT_DELTAS_VEC(ModelDelta, new_pos);		/* #if 0 */
#endif
  new_mats();

#if 0
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
  return TCL_OK;
}

int
f_mtran(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
{
  int incr = 0;
  point_t pt;
  point_t t_pt;

  if(argc < 4 || 5 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help mtran");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Check for -i option */
  if(argv[1][0] == '-' && argv[1][1] == 'i'){
    incr = 1;  /* treat arguments as incremental values */
    ++argv;
    --argc;
  }

  if(argc < 4){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help mtran");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &pt[X]) < 1){
    Tcl_AppendResult(interp, "f_mtran: bad x value - ",
		     argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &pt[Y]) < 1){
    Tcl_AppendResult(interp, "f_mtran: bad y value - ",
		     argv[2], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[3], "%lf", &pt[Z]) < 1){
    Tcl_AppendResult(interp, "f_mtran: bad z value - ",
		     argv[3], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(incr){
    VADD2(t_pt, absolute_model_tran, pt);
    return mged_tran(interp, t_pt);
  }

  return mged_tran(interp, pt);
}

int
mged_tran(interp, pt)
Tcl_Interp *interp;
point_t pt;
{
  point_t old_pos;
  point_t new_pos;
  point_t diff;

  VMOVE(absolute_tran, pt);
  MAT4X3PNT(new_pos, view2model, absolute_tran);
  MAT_DELTAS_GET_NEG(old_pos, toViewcenter);
  VSUB2(diff, new_pos, old_pos);
  VSUB2(new_pos, orig_pos, diff);
  MAT_DELTAS_VEC_NEG(toViewcenter, new_pos);

#if 0
  MAT_DELTAS_VEC(ModelDelta, new_pos);		/* #if 0 */
#endif
  new_mats();

#if 1
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
  return TCL_OK;
}


int
f_tran(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
{
  int incr = 0;
  point_t pt;
  point_t t_pt;

  if(argc < 3 || 5 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help tran");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Check for -i option */
  if(argv[1][0] == '-' && argv[1][1] == 'i'){
    incr = 1;  /* treat arguments as incremental values */
    ++argv;
    --argc;
  }

  if(argc < 3){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help tran");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(sscanf(argv[1], "%lf", &pt[X]) < 1){
    Tcl_AppendResult(interp, "f_tran: bad x value - ",
		     argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(sscanf(argv[2], "%lf", &pt[Y]) < 1){
    Tcl_AppendResult(interp, "f_tran: bad y value - ",
		     argv[2], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(argc == 4){
    if(sscanf(argv[3], "%lf", &pt[Z]) < 1){
      Tcl_AppendResult(interp, "f_tran: bad z value - ",
		       argv[3], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else{
    if(incr)
      pt[Z] = 0.0;
    else
      pt[Z] = absolute_tran[Z];
  }

  if(incr){
    VADD2(t_pt, absolute_tran, pt);
    return mged_tran(interp, t_pt);
  }

  return mged_tran(interp, pt);
}


int
d3425 2
d3429 1
a3429 1
  absolute_zoom = 0.0;
a3456 153

/*
 *	G E T K N O B
 *
 *	Procedure called by the Tcl/Tk interface code to find the values
 *	of the knobs/sliders.
 */

int
cmd_getknob(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  int len;
  fastf_t f;
  char *cp;

  if(argc < 2 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help getknob");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  cp  = argv[1];
  len = strlen(cp);
  if(len == 1){
    switch(*cp){
    case 'x':
      if(EDIT_ROTATE && mged_variables.transform == 'e')
	f = edit_rate_rotate[X];
      else
	f = rate_rotate[X];
      break;
    case 'y':
      if(EDIT_ROTATE && mged_variables.transform == 'e')
	f = edit_rate_rotate[Y];
      else
	f = rate_rotate[Y];
      break;
    case 'z':
      if(EDIT_ROTATE && mged_variables.transform == 'e')
	f = edit_rate_rotate[Z];
      else
	f = rate_rotate[Z];
      break;
    case 'X':
      if(EDIT_TRAN && mged_variables.transform == 'e')
	f = edit_rate_tran[X];
      else
	f = rate_tran[X];
      break;
    case 'Y':
      if(EDIT_TRAN && mged_variables.transform == 'e')
	f = edit_rate_tran[Y];
      else
	f = rate_tran[Y];
      break;
    case 'Z':
      if(EDIT_TRAN && mged_variables.transform == 'e')
	f = edit_rate_tran[Z];
      else
	f = rate_tran[Z];
      break;
    case 'S':
      if(EDIT_SCALE && mged_variables.transform == 'e')
	f = edit_rate_scale;
      else
	f = rate_zoom;
      break;
    default:
      Tcl_AppendResult(interp, "getknob: bad value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else if(len == 2){
    if(*cp++ != 'a'){
      Tcl_AppendResult(interp, "getknob: bad value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    switch(*cp){
    case 'x':
      if(EDIT_ROTATE && mged_variables.transform == 'e')
	f = edit_absolute_rotate[X];
      else
	f = absolute_rotate[X];
      break;
    case 'y':
      if(EDIT_ROTATE && mged_variables.transform == 'e')
	f = edit_absolute_rotate[Y];
      else
	f = absolute_rotate[Y];
      break;
    case 'z':
      if(EDIT_ROTATE && mged_variables.transform == 'e')
	f = edit_absolute_rotate[Z];
      else
	f = absolute_rotate[Z];
      break;
    case 'X':
      if(EDIT_TRAN && mged_variables.transform == 'e')
	f = edit_absolute_tran[X];
      else
	f = absolute_tran[X];
      break;
    case 'Y':
      if(EDIT_TRAN && mged_variables.transform == 'e')
	f = edit_absolute_tran[Y];
      else
	f = absolute_tran[Y];
      break;
    case 'Z':
      if(EDIT_TRAN && mged_variables.transform == 'e')
	f = edit_absolute_tran[Z];
      else
	f = absolute_tran[Z];
      break;
    case 'S':
      if(EDIT_SCALE && mged_variables.transform == 'e')
	f = edit_absolute_scale;
      else
	f = absolute_zoom;
      break;
    default:
      Tcl_AppendResult(interp, "getknob: bad value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else{
    if(strcmp(argv[1], "xadc") == 0)
      f = dv_xadc;
    else if(strcmp(argv[1], "yadc") == 0)
      f = dv_yadc;
    else if(strcmp(argv[1], "ang1") == 0)
      f = dv_1adc;
    else if(strcmp(argv[1], "ang2") == 0)
      f = dv_2adc;
    else if(strcmp(argv[1], "distadc") == 0)
      f = dv_distadc;
    else{
      Tcl_AppendResult(interp, "getknob: bad value - ", argv[1], "\n", (char *)NULL);
       return TCL_ERROR;
    }
  }

  sprintf(interp->result, "%lf", f);
  return TCL_OK;
}

d4061 646
@


11.95
log
@*- mods to support model rotations and translations
*- support or rotating view about origin other than view center
.,
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.94 1997/06/12 14:13:07 bparker Exp bparker $ (BRL)";
d155 3
d186 3
d217 3
d454 3
d666 3
d998 3
d1032 3
d1081 3
d1156 3
d1210 3
d1380 3
d1423 3
d1473 3
d1564 3
d1693 3
d1922 3
d2735 1
a2735 1
  (void)mged_vrot(rate_rotate[X], rate_rotate[Y], rate_rotate[Z]);
d2796 3
d3934 3
@


11.94
log
@added a few commands
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.93 1997/05/29 14:05:15 bparker Exp bparker $ (BRL)";
d82 1
d235 2
a236 1
mged_mrot(x, y, z)
d239 1
d242 7
a248 4
  mat_t mat, invmat;
  mat_t mat2, mat3;
  vect_t new_pos;
  vect_t old_model_center, new_model_center;
a249 4
  point_t origin;
  point_t vrot_pt;
  point_t new_cent_view, new_cent_model;
  point_t vpt1, vpt2;
d251 1
d253 1
a253 1
  buildHrot( newrot, x * degtorad, y * degtorad, z * degtorad);
d255 2
a256 4
  if(mged_variables.origin == 'm'){
/*XXX This doesn't quite work */
    bn_mat_idn( mat );
    bn_mat_idn( mat2 );
d258 3
a260 1
    MAT4X3PNT( view_direc, model2view, model_direc );
d262 11
a272 8
    VSET( origin, 0, 0, 0 );
    MAT4X3PNT( vrot_pt, model2view, origin );  /* point to rotate around */
    wrt_point_direc( mat, newrot, mat2, vrot_pt, view_direc );
    bn_mat_inv( invmat, mat );
#if 0
    MAT4X3PNT( new_cent_view, invmat, origin );
    MAT4X3PNT( new_cent_model, view2model, new_cent_view );
    MAT_DELTAS_VEC_NEG( toViewcenter, new_cent_model );
d274 4
a277 9
    wrt_point_direc( mat, newrot, mat2, origin, view_direc );
    bn_mat_mul2( mat, Viewrot );
#else
    MAT_DELTAS_GET_NEG( old_model_center, toViewcenter );
    MAT4X3PNT( vpt1, model2view, old_model_center );
    MAT4X3PNT( vpt2, invmat, vpt1 );
    MAT4X3PNT( new_model_center, view2model, vpt2 );
    MAT_DELTAS( toViewcenter, -new_model_center[X], -new_model_center[Y],
		-new_model_center[Z] );
d279 1
d281 5
d288 11
a298 4
    MAT_DELTAS( mat2, new_model_center[X], new_model_center[Y],
		new_model_center[Z] );
    bn_mat_mul( Viewrot, model2view, mat2 );
#endif
d300 1
d302 5
d308 1
d310 2
a311 5
    mat_idn( mat );
    MAT_DELTAS( mat, -toViewcenter[MDX], -toViewcenter[MDY], -toViewcenter[MDZ] );
    bn_mat_mul( Viewrot, model2view, mat );

    bn_mat_inv( invtvc, toViewcenter );
d315 1
a315 3

  VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, new_pos);
d337 2
a338 1
  return mged_mrot(atof(argv[1]), atof(argv[2]), atof(argv[3]));
d345 2
a346 1
mged_vrot(x, y, z)
d357 2
a358 3
  if(mged_variables.origin == 'e'){
    /* "VR driver" method: rotate around "eye" point (0,0,1) viewspace */
    point_t		eye_view;
d363 11
a373 3
    
    VSET( eye_view, 0, 0, 1 );		/* point to rotate around */
    bn_mat_xform_about_pt( viewchg, newrot, eye_view );
d390 1
a390 28
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
  }else if(mged_variables.origin == 'm'){
    point_t origin;
    point_t vrot_pt;
    mat_t viewchg, viewchginv;
    point_t new_cent_view, new_cent_model;

    VSET( origin, 0, 0, 0 );
    MAT4X3PNT( vrot_pt, model2view, origin);  /* point to rotate around */
    bn_mat_xform_about_pt(viewchg, newrot, vrot_pt);
    bn_mat_inv( viewchginv, viewchg );

    /* Convert origin in new (viewchg) coords back to old view coords */
    MAT4X3PNT( new_cent_view, viewchginv, origin );
    MAT4X3PNT( new_cent_model, view2model, new_cent_view );
    MAT_DELTAS_VEC_NEG( toViewcenter, new_cent_model );

    /* XXX This should probably capture the translation too */
    /* XXX I think the only consumer of ModelDelta is the predictor frame */
    wrt_view( ModelDelta, newinv, ModelDelta );		/* pure rotation */

    /* Update the rotation component of the model2view matrix */
    bn_mat_mul2(newrot, Viewrot);
    new_mats();

    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
d399 4
a402 5
    if(absolute_slew[X] != 0.0 ||
       absolute_slew[Y] != 0.0 ||
       absolute_slew[Z] != 0.0){
      VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
      MAT4X3PNT(absolute_slew, model2view, new_pos);
d430 2
a431 1
  return mged_vrot(atof(argv[1]), atof(argv[2]), atof(argv[3]));
d1681 14
d1702 4
a1705 4
  if( rate_slew[X] != 0.0 ||
      rate_slew[Y] != 0.0 ||
      rate_slew[Z] != 0.0 )
    rateflag_slew = 1;
d1707 1
a1707 1
    rateflag_slew = 0;
d1811 3
a1813 3
      bu_vls_printf(&vls, "X = %f\n", rate_slew[X]);
      bu_vls_printf(&vls, "Y = %f\n", rate_slew[Y]);
      bu_vls_printf(&vls, "Z = %f\n", rate_slew[Z]);
d1836 3
a1838 3
      bu_vls_printf(&vls, "aX = %f\n", absolute_slew[X]);
      bu_vls_printf(&vls, "aY = %f\n", absolute_slew[Y]);
      bu_vls_printf(&vls, "aZ = %f\n", absolute_slew[Z]);
d1869 1
d1872 2
a1873 1
  int view_flag = 0;  /* force view interpretation */
d1892 1
a1892 1
    while((c = bu_getopt(argc, argv, "eiv")) != EOF){
d1900 6
d1918 3
d1931 2
d1934 1
a1934 1
      VSETALL( rate_slew, 0 );
d1953 1
a1953 1
      VSETALL( absolute_slew, 0.0 );
d1981 2
a1982 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d1986 8
a1993 1
	    rate_rotate[X] += f;
d1997 2
a1998 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2002 8
a2009 1
	    rate_rotate[X] = f;
d2017 2
a2018 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2022 8
a2029 1
	    rate_rotate[Y] += f;
d2033 2
a2034 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2038 8
a2045 1
	    rate_rotate[Y] = f;
d2053 2
a2054 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2058 8
a2065 1
	    rate_rotate[Z] += f;
d2069 2
a2070 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2074 8
a2081 1
	    rate_rotate[Z] = f;
d2089 2
a2090 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2094 5
a2098 1
	  rate_slew[X] += f;
d2102 2
a2103 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2107 5
a2111 1
	  rate_slew[X] = f;
d2119 2
a2120 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2124 5
a2128 1
	  rate_slew[Y] += f;
d2132 2
a2133 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2137 5
a2141 1
	  rate_slew[Y] = f;
d2149 2
a2150 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2154 5
a2158 1
	  rate_slew[Z] += f;
d2162 2
a2163 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2167 5
a2171 1
	  rate_slew[Z] = f;
d2179 1
a2179 1
	if(EDIT_SCALE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2187 1
a2187 1
	if(EDIT_SCALE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2204 2
a2205 1
	if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2209 2
a2210 1
	  if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2217 2
a2218 2
	    if(mged_variables.model)
	      (void)mged_mrot(f, 0.0, 0.0);
d2220 1
a2220 1
	      (void)mged_vrot(f, 0.0, 0.0);
d2226 2
a2227 1
	if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2231 2
a2232 1
	  if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2239 2
a2240 2
	    if(mged_variables.model)
	      (void)mged_mrot(f - last_absolute_rotate[X], 0.0, 0.0);
d2242 1
a2242 1
	      mged_vrot(f - last_absolute_rotate[X], 0.0, 0.0);
d2250 2
a2251 1
      if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2272 2
a2273 1
	if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2277 2
a2278 1
	  if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2285 2
a2286 2
	    if(mged_variables.model)
	      (void)mged_mrot(0.0, f, 0.0);
d2288 1
a2288 1
	      (void)mged_vrot(0.0, f, 0.0);
d2294 2
a2295 1
	if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2299 2
a2300 1
	  if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2307 2
a2308 2
	    if(mged_variables.model)
	      (void)mged_mrot(0.0, f - last_absolute_rotate[Y], 0.0);
d2310 1
a2310 1
	      mged_vrot(0.0, f - last_absolute_rotate[Y], 0.0);
d2318 2
a2319 1
      if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2340 2
a2341 1
	if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2345 2
a2346 1
	  if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2353 2
a2354 2
	    if(mged_variables.model)
	      (void)mged_mrot(0.0, 0.0, f);
d2356 1
a2356 1
	      (void)mged_vrot(0.0, 0.0, f);
d2362 2
a2363 1
	if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2367 2
a2368 1
	  if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2375 2
a2376 2
	    if(mged_variables.model)
	      (void)mged_mrot(0.0, 0.0, f - last_absolute_rotate[Z]);
d2378 1
a2378 1
	      mged_vrot(0.0, 0.0, f - last_absolute_rotate[Z]);
d2386 2
a2387 1
      if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2408 2
a2409 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2412 4
a2415 6
	}else{
	  absolute_slew[X] += f;
#if 0
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
#endif
	}
d2417 2
a2418 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2421 5
a2425 6
	}else{
	  absolute_slew[X] = f;
#if 0
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
#endif
	}
d2432 2
a2433 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2436 4
a2439 6
	}else{
	  absolute_slew[Y] += f;
#if 0
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
#endif
	}
d2441 2
a2442 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2445 4
a2448 6
	}else{
	  absolute_slew[Y] = f;
#if 0
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
#endif
	}
d2455 2
a2456 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2459 5
a2463 6
	}else{
	  absolute_slew[Z] += f;
#if 0
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
	}
d2465 2
a2466 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2469 4
a2472 6
	}else{
	  absolute_slew[Z] = f;
#if 0
	  Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
	}
d2479 1
a2479 1
	if(EDIT_SCALE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2492 1
a2492 1
	if(EDIT_SCALE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2624 1
a2624 1
    (void)knob_tran(interp, view_flag, edit_flag);
d2631 1
a2631 1
knob_tran(interp, view_flag, edit_flag)
d2633 1
d2641 2
a2642 1
  if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag)){
d2652 28
a2679 2
  }else /* slew the view */
    mged_tran(interp, absolute_slew);
d2718 1
a2718 1
mged_do_rate_slew()
d2720 4
a2723 4
  absolute_slew[X] += rate_slew[X] * 0.1;
  absolute_slew[Y] += rate_slew[Y] * 0.1;
  absolute_slew[Z] += rate_slew[Z] * 0.1;
  mged_tran(interp, absolute_slew);
d2899 4
a2902 5
  if(absolute_slew[X] != 0.0 ||
     absolute_slew[Y] != 0.0 ||
     absolute_slew[Z] != 0.0){
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
d2933 4
a2936 5
  if(absolute_slew[X] != 0.0 ||
     absolute_slew[Y] != 0.0 ||
     absolute_slew[Z] != 0.0){
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
d3158 88
d3248 1
a3248 1
mged_tran(interp, tranvec)
d3250 1
a3250 1
vect_t tranvec;
d3252 10
a3261 3
  vect_t old_pos;
  vect_t new_pos;
  vect_t diff;
a3262 6
  VMOVE(absolute_slew, tranvec);
  MAT4X3PNT( new_pos, view2model, absolute_slew );
  MAT_DELTAS_GET_NEG( old_pos, toViewcenter );
  VSUB2( diff, new_pos, old_pos );
  VADD2(new_pos, orig_pos, diff);
  MAT_DELTAS_VEC( toViewcenter, new_pos);
d3264 1
a3264 1
  MAT_DELTAS_VEC( ModelDelta, new_pos);		/* #if 0 */
d3285 2
a3286 2
  int x, y, z;
  vect_t tranvec;
d3305 11
a3315 1
  if(sscanf(argv[1], "%d", &x) < 1){
d3321 1
a3321 1
  if(sscanf(argv[2], "%d", &y) < 1){
d3328 1
a3328 1
    if(sscanf(argv[3], "%d", &z) < 1){
d3335 1
a3335 1
      z = 0.0;
d3337 1
a3337 1
      z = absolute_slew[Z];
d3341 2
a3342 6
    point_t tpoint;

    VSET(tpoint, x, y, z)
    VADD2(tranvec, absolute_slew, tpoint);
  }else{
    VSET(tranvec, x, y, z);
d3345 1
a3345 1
  return mged_tran(interp, tranvec);
d3391 1
a3391 1
  VSUB2(absolute_slew, absolute_slew, slewvec);
d3403 1
a3403 1
  MAT_DELTAS_GET(orig_pos, toViewcenter);
d3406 4
a3409 3
  VSETALL( absolute_rotate, 0.0);
  VSETALL( last_absolute_rotate, 0.0);
  VSETALL( absolute_slew, 0.0);
d3472 1
a3472 1
      if(EDIT_ROTATE && mged_variables.edit)
d3478 1
a3478 1
      if(EDIT_ROTATE && mged_variables.edit)
d3484 1
a3484 1
      if(EDIT_ROTATE && mged_variables.edit)
d3490 1
a3490 1
      if(EDIT_TRAN && mged_variables.edit)
d3493 1
a3493 1
	f = rate_slew[X];
d3496 1
a3496 1
      if(EDIT_TRAN && mged_variables.edit)
d3499 1
a3499 1
	f = rate_slew[Y];
d3502 1
a3502 1
      if(EDIT_TRAN && mged_variables.edit)
d3505 1
a3505 1
	f = rate_slew[Z];
d3508 1
a3508 1
      if(EDIT_SCALE && mged_variables.edit)
d3525 1
a3525 1
      if(EDIT_ROTATE && mged_variables.edit)
d3531 1
a3531 1
      if(EDIT_ROTATE && mged_variables.edit)
d3537 1
a3537 1
      if(EDIT_ROTATE && mged_variables.edit)
d3543 1
a3543 1
      if(EDIT_TRAN && mged_variables.edit)
d3546 1
a3546 1
	f = absolute_slew[X];
d3549 1
a3549 1
      if(EDIT_TRAN && mged_variables.edit)
d3552 1
a3552 1
	f = absolute_slew[Y];
d3555 1
a3555 1
      if(EDIT_TRAN && mged_variables.edit)
d3558 1
a3558 1
	f = absolute_slew[Z];
d3561 1
a3561 1
      if(EDIT_SCALE && mged_variables.edit)
d3693 4
a3696 5
  if(absolute_slew[X] != 0.0 ||
     absolute_slew[Y] != 0.0 ||
     absolute_slew[Z] != 0.0){
    VSET(temp, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, temp);
d3733 1
a3733 2
  VSET(temp, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, temp);
d4001 6
a4006 1
    current_view = last_view;
a4008 1

d4100 2
@


11.93
log
@*- mods for adding azimuth knob/slider
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.92 1997/05/20 14:34:37 jra Exp bparker $ (BRL)";
d232 93
d339 55
a393 1
  if( mged_variables.eyerot == 0 )  {
a406 28
  } else {
  	/* "VR driver" method: rotate around "eye" point (0,0,1) viewspace */
  	point_t		eye_view;
  	point_t		new_origin;
  	mat_t		viewchg, viewchginv;
  	point_t		new_cent_view;
  	point_t		new_cent_model;

  	VSET( eye_view, 0, 0, 1 );		/* point to rotate around */
  	bn_mat_xform_about_pt( viewchg, newrot, eye_view );
  	bn_mat_inv( viewchginv, viewchg );

  	/* Convert origin in new (viewchg) coords back to old view coords */
  	VSET( new_origin, 0, 0, 0 );
  	MAT4X3PNT( new_cent_view, viewchginv, new_origin );
  	MAT4X3PNT( new_cent_model, view2model, new_cent_view );
  	MAT_DELTAS_VEC_NEG( toViewcenter, new_cent_model );

  	/* XXX This should probably capture the translation too */
  	/* XXX I think the only consumer of ModelDelta is the predictor frame */
	wrt_view( ModelDelta, newinv, ModelDelta );		/* pure rotation */

	/* Update the rotation component of the model2view matrix */
	bn_mat_mul2( newrot, Viewrot );			/* pure rotation */
	new_mats();

	VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
	MAT4X3PNT(absolute_slew, model2view, new_pos);
a422 3
  int status;
  struct bu_vls vls;

d433 1
a433 3
  status = mged_vrot(atof(argv[1]), atof(argv[2]), atof(argv[3]));

  return status;
d707 2
d713 2
a714 2
	for(i = 0; i < VIEW_TABLE_SIZE; ++i)
	  viewscale_table[i] = Viewscale;
d2112 5
a2116 1
	    (void)mged_vrot(f, 0.0, 0.0);
d2132 5
a2136 1
	    mged_vrot(f - last_absolute_rotate[X], 0.0, 0.0);
d2175 5
a2179 1
	    (void)mged_vrot(0.0, f, 0.0);
d2195 5
a2199 1
	    mged_vrot(0.0, f - last_absolute_rotate[Y], 0.0);
d2238 5
a2242 1
	    (void)mged_vrot(0.0, 0.0, f);
d2258 5
a2262 1
	    mged_vrot(0.0, 0.0, f - last_absolute_rotate[Z]);
d3684 270
@


11.92
log
@Fixed bug in "regdebug" command.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.91 1997/05/09 21:04:45 bparker Exp jra $ (BRL)";
d596 3
d1142 43
a1193 4
  int status = TCL_OK;
  fastf_t o_twist;
  fastf_t twist;
  char *av[5];
d1195 1
d1212 2
a1213 1
  }
d1215 1
a1215 12
  /* grab old twist angle before it's lost */
  o_twist = curr_dm_list->s_info->twist;

  /* set view using azimuth and elevation angles */
  if(iflag)
    setview( 270.0 + atof(argv[2]) + curr_dm_list->s_info->elevation,
	     0.0,
	     270.0 - atof(argv[1]) - curr_dm_list->s_info->azimuth);
  else
    setview( 270.0 + atof(argv[2]), 0.0, 270.0 - atof(argv[1]) );

  if(argc == 4){ /* twist angle supplied */
a1216 16
#if 0
    if(iflag)
      status = mged_vrot(0.0, 0.0, -o_twist - twist);
    else
      status = mged_vrot(0.0, 0.0, -twist);
#else
    bu_vls_init(&vls);
    if(iflag)
      bu_vls_printf(&vls, "knob -i az %f", -o_twist - twist);
    else
      bu_vls_printf(&vls, "knob -i az %f", -twist);

    status = Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
#endif
  }
d1218 1
a1218 1
  return status;
d1351 1
a1351 1
    bu_vls_printf(&vls, "  color=(%d,%d,%d) %d,%d,%d i=%d\n",
d1357 1
a1357 2
		  sp->s_color[2],
		  sp->s_dmindex );
d1613 6
a1618 1
 
a1791 4
      av[0] = "adc";
      av[1] = "reset";
      av[2] = (char *)NULL;

d1798 1
d1801 4
d2256 15
a2270 1
  } else if( strcmp( cmd, "xadc" ) == 0 )  {
@


11.91
log
@mods to f_center()
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.90 1997/05/02 14:27:53 jra Exp bparker $ (BRL)";
d664 1
d681 3
a683 1
	Tcl_AppendResult(interp, "regdebug=", argv[1], "\n", (char *)NULL);
@


11.90
log
@mod to f_cat() to handle multiple arguments correctly.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.89 1997/04/24 18:03:58 bparker Exp $ (BRL)";
d225 2
@


11.89
log
@modify calls to Tcl_Eval
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.88 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d963 1
a965 1
  Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
@


11.88
log
@mods so that commands check args internally
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.87 1997/04/14 12:20:10 bparker Exp bparker $ (BRL)";
d211 6
a216 1
    Tcl_Eval(interp, "help center");
d306 6
a311 1
    Tcl_Eval(interp, "help vrot");
d329 4
a332 1
	fastf_t f;
d334 6
a339 4
	if(argc < 2 || 2 < argc){
	  Tcl_Eval(interp, "help size");
	  return TCL_ERROR;
	}
d341 4
a344 4
	f = atof( argv[1] );
	if( f < 0.0001 ) f = 0.0001;
	Viewscale = f * 0.5 * local2base;
	new_mats();
d346 1
a346 1
	return TCL_OK;
d364 6
a369 1
    Tcl_Eval(interp, "help B");
d422 6
a427 1
    Tcl_Eval(interp, "help ev");
d456 6
a461 1
    Tcl_Eval(interp, "help E");
d627 6
a632 1
    Tcl_Eval(interp, "help x");
d664 6
a669 1
	  Tcl_Eval(interp, "help regdebug");
d700 6
a705 1
    Tcl_Eval(interp, "help debugbu");
d743 6
a748 1
    Tcl_Eval(interp, "help debuglib");
d786 6
a791 1
    Tcl_Eval(interp, "help debugmem");
d821 6
a826 1
    Tcl_Eval(interp, "help debugnmg");
d893 6
a898 1
    Tcl_Eval(interp, "help l");
d939 6
a944 1
    Tcl_Eval(interp, "help cat");
d1011 6
a1016 1
	  Tcl_Eval(interp, "help Z");
d1062 6
a1067 1
    Tcl_Eval(interp, "help status");
d1101 6
a1106 1
    Tcl_Eval(interp, "help fix");
d1121 6
a1126 1
    Tcl_Eval(interp, "help refresh");
d1150 6
a1155 1
    Tcl_Eval(interp, "help ae");
d1391 6
a1396 1
	  Tcl_Eval(interp, "help ill");
d1519 6
a1524 1
    Tcl_Eval(interp, "help sed");
d1722 6
a1727 1
    Tcl_Eval(interp, "help knob");
d2426 6
a2431 1
	  Tcl_Eval(interp, "help tol");
d2641 6
a2646 1
    Tcl_Eval(interp, "help zoom");
d2670 6
a2675 1
    Tcl_Eval(interp, "help orientation");
d2705 6
a2710 1
      Tcl_Eval(interp, "help qvrot");
d2805 6
a2810 1
    Tcl_Eval(interp, "help setview");
d2879 6
a2884 1
    Tcl_Eval(interp, "help tran");
d2944 6
a2949 1
    Tcl_Eval(interp, "help sv");
d3009 6
a3014 1
    Tcl_Eval(interp, "help svb");
d3041 6
a3046 1
    Tcl_Eval(interp, "help getknob");
d3189 6
a3194 1
    Tcl_Eval(interp, "help vrot_center");
d3345 6
a3350 1
	  Tcl_Eval(interp, "help eye_pt");
d3389 6
a3394 1
	  Tcl_Eval(interp, "help model2view");
d3430 6
a3435 1
	  Tcl_Eval(interp, "help view2model");
d3470 6
a3475 1
	  Tcl_Eval(interp, "help lookat");
@


11.87
log
@*- eraseobj() has become eraseobjall()
*- the new eraseobj() only erases objects that were explicitly e'd up
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.86 1997/03/29 04:28:17 jra Exp bparker $ (BRL)";
d154 7
a160 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d162 1
d182 7
a188 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d190 1
d210 2
a211 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d213 1
d300 2
a301 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d303 1
d321 2
a322 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d324 1
d348 2
a349 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d351 1
d378 7
a384 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d386 1
d401 2
a402 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d404 1
d430 2
a431 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d433 1
d596 2
a597 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d599 1
d628 2
a629 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d631 1
d659 2
a660 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d662 1
d697 2
a698 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d700 1
d735 2
a736 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d738 1
d765 5
d832 2
a833 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d835 1
d873 2
a874 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d876 1
d940 2
a941 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d943 1
d986 2
a987 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d989 1
d1020 2
a1021 6
#if 0
  attach( dmp->dm_name );	/* reattach */
  dmaflag = 1;		/* causes refresh() */
  return CMD_OK;
#else
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1023 1
a1025 1
#endif
d1035 4
a1038 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d1040 2
a1041 2
	dmaflag = 1;		/* causes refresh() */
	return TCL_OK;
d1059 2
a1060 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1062 1
d1295 2
a1296 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1298 1
d1416 1
a1416 1
	CHECK_READ_ONLY;
d1418 2
a1419 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1421 1
d1616 2
a1617 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1619 1
d2315 2
a2316 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2318 1
d2525 2
a2526 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2528 1
d2549 2
a2550 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2552 1
d2579 2
a2580 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2582 1
d2674 2
a2675 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2677 1
d2743 2
a2744 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2746 1
d2803 2
a2804 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2806 1
d2863 2
a2864 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2866 1
d2890 2
a2891 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d2893 1
d3033 2
a3034 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d3036 1
d3184 4
a3187 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
d3223 4
a3226 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
d3259 4
a3262 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
d3294 4
a3297 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
@


11.86
log
@Added lookat command.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.85 1997/03/25 14:43:44 jra Exp jra $ (BRL)";
d145 1
a145 1
f_delobj(clientData, interp, argc, argv)
d148 2
a149 2
int	argc;
char	**argv;
d151 10
a160 2
	register struct directory *dp;
	register int i;
d162 12
a173 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d175 2
a176 5
	for( i = 1; i < argc; i++ )  {
		if( (dp = db_lookup( dbip,  argv[i], LOOKUP_NOISY )) != DIR_NULL )
			eraseobj( dp );
	}
	no_memory = 0;
d178 4
a181 1
	update_views = 1;
d183 2
a184 1
	return TCL_OK;
d1050 1
a1050 1
 *			E R A S E O B J
d1056 41
d1100 5
a1104 3
	register struct solid *sp;
	static struct solid *nsp;
	register int i;
d1106 7
a1112 1
	update_views = 1;
d1114 2
a1115 6
	RT_CK_DIR(dp);
	sp = BU_LIST_NEXT(solid, &HeadSolid.l);
	while(BU_LIST_NOT_HEAD(sp, &HeadSolid.l)){
		nsp = BU_LIST_PNEXT(solid, sp);
		for( i=0; i<=sp->s_last; i++ )  {
			if( sp->s_path[i] != dp )  continue;
d1117 5
a1121 8
			if( state != ST_VIEW && illump == sp )
				button( BE_REJECT );
#if 0
			dmp->dm_viewchange( dmp, DM_CHGV_DEL, sp );
#endif
			rt_memfree( &(dmp->dm_map), sp->s_bytes, (unsigned long)sp->s_addr );
			BU_LIST_DEQUEUE(&sp->l);
			FREE_SOLID(sp, &FreeSolid.l);
d1123 5
a1127 9
			break;
		}
		sp = nsp;
	}
	if( dp->d_addr == RT_DIR_PHONY_ADDR )  {
		if( db_dirdelete( dbip, dp ) < 0 )  {
		  Tcl_AppendResult(interp, "eraseobj: db_dirdelete failed\n", (char *)NULL);
		}
	}
d1129 1
@


11.85
log
@Mods to support MGED's read-only mode.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.84 1997/02/28 21:32:37 bparker Exp jra $ (BRL)";
d3130 45
@


11.84
log
@declare edit_info_vls
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.83 1997/02/14 08:52:34 mike Exp bparker $ (BRL)";
d1300 2
@


11.83
log
@Added 3 new commands.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.82 1997/02/14 08:51:16 mike Exp mike $ (BRL)";
d128 1
@


11.82
log
@BParker curr_cmd_list changes.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.81 1997/02/06 21:59:02 bparker Exp bparker $ (BRL)";
d3024 104
@


11.81
log
@mods to f_knob() and mged_svbase()
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.80 1997/02/04 21:57:21 bparker Exp bparker $ (BRL)";
d442 1
a442 1
 * B, e, and E commands uses this area as common
d494 1
d497 1
d500 4
d520 1
@


11.80
log
@*- mods to fix translate to nowhere problem
*- change mged_rotate_view_around_eye to mged_variables.eyerot
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.79 1997/02/03 21:46:42 bparker Exp bparker $ (BRL)";
d1537 1
a1537 1
		
d1542 2
d2706 1
a2706 1
  dmaflag = 1;
@


11.79
log
@*** empty log message ***
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.78 1997/02/01 03:14:36 mike Exp bparker $ (BRL)";
a134 2
int		mged_rotate_view_around_eye = 0; /* shared with cmd.c */

d203 14
a216 3
  if( mged_rotate_view_around_eye == 0 )  {
	/* Traditional method:  rotate around view center (0,0,0) viewspace */
	wrt_view( ModelDelta, newinv, ModelDelta );
a237 1
  }
d239 3
a241 3
  /* Update the rotation component of the model2view matrix */
  bn_mat_mul2( newrot, Viewrot );			/* pure rotation */
  new_mats();
d243 2
a244 10
  if(absolute_slew[X] != 0.0 ||
     absolute_slew[Y] != 0.0 ||
     absolute_slew[Z] != 0.0){
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
#if 1
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[X]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Y]));
    Tcl_UpdateLinkedVar(interp, bu_vls_addr(&absolute_tran_vls[Z]));
#endif
d246 4
@


11.78
log
@mged_rotate_view_around_eye is C & Tcl variable which controls
new feature.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.77 1997/02/01 02:56:47 mike Exp mike $ (BRL)";
d1882 1
d1884 1
d1892 1
d1894 1
d1907 1
d1909 1
d1917 1
d1919 1
d1932 1
d1934 1
d1942 1
d1944 1
d2114 43
@


11.77
log
@Added support for mged_rotate_view_around_eye
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.76 1997/01/30 01:47:50 mike Exp mike $ (BRL)";
d135 2
a199 1
  char	*var;
d205 1
a205 3
  if( (var = Tcl_GetVar(interp, "mged_rotate_view_around_eye", TCL_GLOBAL_ONLY)) == NULL ||
	atoi(var) == 0 )
  {
@


11.76
log
@combinations are now full members of the function table.
To describe them, just use the ft_describe interface.
Supporting routines have all moved into librt/db_comb.c
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.75 1997/01/29 23:15:37 bparker Exp mike $ (BRL)";
d188 3
a190 1

d197 2
d202 1
a202 1
  bn_mat_mul2( newrot, Viewrot );
d204 2
d207 9
a215 1
    mat_t   newinv;
d217 13
a229 2
    bn_mat_inv( newinv, newrot );
    wrt_view( ModelDelta, newinv, ModelDelta );
d232 2
d2519 1
a2519 1
  MAT_DELTAS_VEC( ModelDelta, new_pos);
d2865 1
a2865 1
		wrt_view( ModelDelta, newinv, ModelDelta );
d2944 1
a2944 1
  bn_mat_mul2( delta, ModelDelta );
@


11.75
log
@,
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.74 1997/01/24 20:58:56 bparker Exp bparker $ (BRL)";
a684 184
 *			M G E D _ C O M B _ D E S C R I B E
 *
 *  Describe the non-tree portion of a combination node.
 */
void
mged_comb_describe( vls, comb )
struct bu_vls			*vls;
CONST struct rt_comb_internal	*comb;
{
	RT_CK_COMB(comb);

	if( comb->region_flag ) {
		bu_vls_printf( vls,
		       "REGION id=%d  (air=%d, los=%d, GIFTmater=%d) ",
			comb->region_id,
			comb->aircode,
			comb->los,
			comb->GIFTmater );
	}

	bu_vls_strcat( vls, "--\n" );
	if( bu_vls_strlen(&comb->shader) > 0 ) {
		bu_vls_printf( vls,
			"Shader '%s'\n",
			bu_vls_addr(&comb->shader) );
	}

	if( comb->rgb_valid ) {
		bu_vls_printf( vls,
			"Color %d %d %d\n",
			comb->rgb[0],
			comb->rgb[1],
			comb->rgb[2]);
	}

	if( bu_vls_strlen(&comb->shader) > 0 || comb->rgb_valid )  {
		if( comb->inherit ) {
			bu_vls_strcat( vls, 
	"(These material properties override all lower ones in the tree)\n");
		}
	}
}

#define STAT_ROT	1
#define STAT_XLATE	2
#define STAT_PERSP	4
#define STAT_SCALE	8
/*
 *			M A T _ C A T E G O R I Z E
 *
 *  Describe with a bit vector the effects this matrix will have.
 */
int
mat_categorize( matp )
CONST mat_t	matp;
{
	int	status = 0;

	if( !matp )  return 0;

	if( matp[0] != 1.0 || matp[5] != 1.0 || matp[10] != 1.0 )
		status |= STAT_ROT;

	if( matp[MDX] != 0.0 ||
	    matp[MDY] != 0.0 ||
	    matp[MDZ] != 0.0 )
		status |= STAT_XLATE;

	if( matp[12] != 0.0 ||
	    matp[13] != 0.0 ||
	    matp[14] != 0.0 )
		status |= STAT_PERSP;

	if( matp[15] != 1.0 )  status |= STAT_SCALE;

	return status;
}

/*
 *			M G E D _ T R E E _ D E S C R I B E
 */
void
mged_tree_describe( vls, tp, indented, lvl )
struct bu_vls		*vls;
CONST union tree	*tp;
int			indented;
int			lvl;
{
	int	status;

	BU_CK_VLS(vls);

	if( !tp )
	{
		/* no tree, probably an empty combination */
		bu_vls_strcat( vls, "-empty-\n" );
		return;
	}
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		status = mat_categorize( tp->tr_l.tl_mat );

		/* One per line, out onto the vls */
		if( !indented )  bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, tp->tr_l.tl_name );
		if( status & STAT_ROT ) {
			fastf_t	az, el;
			bn_ae_vec( &az, &el, tp->tr_l.tl_mat ?
				tp->tr_l.tl_mat : bn_mat_identity );
			bu_vls_printf( vls, 
				" az=%g, el=%g, ",
				az, el );
		}
		if( status & STAT_XLATE ) {
			bu_vls_printf( vls, " [%g,%g,%g]",
				tp->tr_l.tl_mat[MDX]*base2local,
				tp->tr_l.tl_mat[MDY]*base2local,
				tp->tr_l.tl_mat[MDZ]*base2local);
		}
		if( status & STAT_SCALE ) {
			bu_vls_printf( vls, " scale %g",
				1.0/tp->tr_l.tl_mat[15] );
		}
		if( status & STAT_PERSP ) {
			bu_vls_printf( vls, 
				" Perspective=[%g,%g,%g]??",
				tp->tr_l.tl_mat[12],
				tp->tr_l.tl_mat[13],
				tp->tr_l.tl_mat[14] );
		}
		bu_vls_printf( vls, "\n" );
		return;

		/* This node is known to be a binary op */
	case OP_UNION:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "u " );
		goto bin;
	case OP_INTERSECT:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "+ " );
		goto bin;
	case OP_SUBTRACT:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "- " );
		goto bin;
	case OP_XOR:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "^ " );
bin:
		mged_tree_describe( vls, tp->tr_b.tb_left, 1, lvl+1 );
		mged_tree_describe( vls, tp->tr_b.tb_right, 0, lvl+1 );
		return;

		/* This node is known to be a unary op */
	case OP_NOT:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "! " );
		goto unary;
	case OP_GUARD:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "G " );
		goto unary;
	case OP_XNOP:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "X " );
unary:
		mged_tree_describe( vls, tp->tr_b.tb_left, 1, lvl+1 );
		return;

	case OP_NOP:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "NOP\n" );
		return;

	default:
		bu_log("mged_tree_describe: bad op %d\n", tp->tr_op);
		bu_bomb("mged_tree_describe\n");
	}
}

/*
a692 1
	register int	i;
a693 1
	struct bu_external	ext;
a694 2
	mat_t			ident;
	struct bu_vls		str;
a695 1
	bu_vls_init( &str );
a696 6
	BU_INIT_EXTERNAL(&ext);
	if( db_get_external( &ext, dp, dbip ) < 0 )  {
	  Tcl_AppendResult(interp, "db_get_external(", dp->d_namep,
			   ") failure\n", (char *)NULL);
	  return;
	}
d698 4
a701 23
	if( dp->d_flags & DIR_COMB )  {
		struct rt_comb_internal	*comb;

		/* Combination */
		bu_vls_printf( outstrp, "%s (len %d) ", dp->d_namep, 
			       dp->d_len-1 );

		if( rt_comb_v4_import( &intern, &ext, NULL ) < 0 ||
		    intern.idb_type != ID_COMBINATION )  {
			Tcl_AppendResult(interp, "rt_comb_v4_import(",
				dp->d_namep, ") failure\n", (char *)NULL);
			goto out;
		}
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB(comb);
		mged_comb_describe( outstrp, comb );
		if( verbose )  {
			mged_tree_describe( outstrp, comb->tree, 0, 1 );
		} else {
			rt_pr_tree_vls( outstrp, comb->tree );
		}
		rt_comb_ifree( &intern );
		goto out;
d704 1
a704 8
	id = rt_id_solid( &ext );
	bn_mat_idn( ident );
	if( rt_functab[id].ft_import( &intern, &ext, ident ) < 0 )  {
	  Tcl_AppendResult(interp, dp->d_namep, ": database import error\n", (char *)NULL);
	  goto out;
	}

	if( rt_functab[id].ft_describe( &str, &intern,
a707 6
	bu_vls_vlscat( outstrp, &str );

out:
	db_free_external( &ext );

	bu_vls_free( &str );
@


11.74
log
@mods to update sliders
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.73 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d290 1
@


11.73
log
@checkin for weekend
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.72 1997/01/10 21:52:45 bparker Exp bparker $ (BRL)";
a64 5
#if 0
#include "tcl.h"
#include "tk.h"
#endif

d81 1
d83 1
d116 1
d214 5
d473 1
a473 5

	MAT_DELTAS_GET(orig_pos, toViewcenter);
	absolute_zoom = 0.0;
	VSETALL( absolute_rotate, 0.0 );
	VSETALL( absolute_slew, 0.0 );
d1559 31
d1600 1
a1600 1
    if(EDIT_ROTATE && mged_variables.edit){
d1610 1
a1610 1
    if(EDIT_SCALE && mged_variables.edit)
d1615 1
a1615 1
    if(EDIT_TRAN && mged_variables.edit){
d1625 1
a1625 1
    if(EDIT_ROTATE && mged_variables.edit){
d1635 1
a1635 1
    if(EDIT_SCALE && mged_variables.edit)
d1640 1
a1640 1
    if(EDIT_TRAN && mged_variables.edit){
d1732 1
d1933 1
a1933 1
	    tvec[X] = f - edit_absolute_rotate[X];
d1939 1
a1939 1
	    mged_vrot(f - absolute_rotate[X], 0.0, 0.0);
d1952 1
d1960 1
d1989 1
a1989 1
	    tvec[Y] = f - edit_absolute_rotate[Y];
d1994 1
a1994 1
	    mged_vrot(0.0, f - absolute_rotate[Y], 0.0);
d2007 1
d2015 1
d2045 1
a2045 1
	    tvec[Z] = f - edit_absolute_rotate[Z];
d2049 1
a2049 1
	    mged_vrot(0.0, 0.0, f - absolute_rotate[Z]);
d2062 1
d2070 1
d2473 4
d2479 1
a2479 2
  if(BU_LIST_NON_EMPTY(&head_cmd_list.l))
    (void)Tcl_Eval(interp, "set_sliders");
d2508 4
d2514 1
a2514 3
  if(BU_LIST_NON_EMPTY(&head_cmd_list.l))
        (void)Tcl_Eval(interp, "set_sliders");

d2722 5
d2841 1
d3110 5
a3115 3

  if(BU_LIST_NON_EMPTY(&head_cmd_list.l))
    Tcl_Eval(interp, "set_sliders");
d3149 5
a3153 2
  if(BU_LIST_NON_EMPTY(&head_cmd_list.l))
    (void)Tcl_Eval(interp, "set_sliders");
@


11.72
log
@*- mods to f_knob to return a list of id,val pairs
*- move view related commands here from ged.c and cmd.c
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.71 1997/01/08 21:43:58 bparker Exp bparker $ (BRL)";
a83 2
#define DO_KNOB_EXPERIMENT 1

d113 5
d130 7
d1652 1
d1736 1
a1736 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
d1738 2
a1739 1
	  else
d1741 2
d1744 1
a1744 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
d1746 2
a1747 1
	  else
d1749 2
a1752 8
#if DO_KNOB_EXPERIMENT
	if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
	  (void)sprintf(knob_val_pair, "{x} {%d}",
			dm_unlimit( (int)(edit_rate_rotate[X] * rr_scale_factor) ));
	else
	  (void)sprintf(knob_val_pair, "{x} {%d}",
			dm_unlimit( (int)(rate_rotate[X] * rr_scale_factor) ));
#endif
d1756 1
a1756 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
d1758 2
a1759 1
	  else
d1761 2
d1764 1
a1764 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
d1766 2
a1767 1
	  else
d1769 2
a1772 8
#if DO_KNOB_EXPERIMENT
	if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
	  (void)sprintf(knob_val_pair, "{y} {%d}",
			dm_unlimit( (int)(edit_rate_rotate[Y] * rr_scale_factor) ));
	else
	  (void)sprintf(knob_val_pair, "{y} {%d}",
			dm_unlimit( (int)(rate_rotate[Y] * rr_scale_factor) ));
#endif
d1776 1
a1776 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
d1778 2
a1779 1
	  else
d1781 2
d1784 1
a1784 1
	  if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
d1786 2
a1787 1
	  else
d1789 2
a1792 8
#if DO_KNOB_EXPERIMENT
	if(EDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag))
	  (void)sprintf(knob_val_pair, "{z} {%d}",
			dm_unlimit( (int)(edit_rate_rotate[Z] * rr_scale_factor) ));
	else
	  (void)sprintf(knob_val_pair, "{z} {%d}",
			dm_unlimit( (int)(rate_rotate[Z] * rr_scale_factor) ));
#endif
d1796 1
a1796 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d1798 2
a1799 1
	else
d1801 2
d1804 1
a1804 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d1806 2
a1807 1
	else
d1809 2
a1812 8
#if DO_KNOB_EXPERIMENT
      if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
	(void)sprintf(knob_val_pair, "{X} {%d}",
		      dm_unlimit( (int)(edit_rate_tran[X] * 2047.0) ));
      else
	(void)sprintf(knob_val_pair, "{X} {%d}",
		      dm_unlimit( (int)(rate_slew[X] * 2047.0) ));
#endif
d1816 1
a1816 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d1818 2
a1819 1
	else
d1821 2
d1824 1
a1824 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d1826 2
a1827 1
	else
d1829 2
a1832 8
#if DO_KNOB_EXPERIMENT
      if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
	(void)sprintf(knob_val_pair, "{Y} {%d}",
		      dm_unlimit( (int)(edit_rate_tran[Y] * 2047.0) ));
      else
	(void)sprintf(knob_val_pair, "{Y} {%d}",
		      dm_unlimit( (int)(rate_slew[Y] * 2047.0) ));
#endif
d1836 1
a1836 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d1838 2
a1839 1
	else
d1841 2
d1844 1
a1844 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d1846 2
a1847 1
	else
d1849 2
a1852 8
#if DO_KNOB_EXPERIMENT
      if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
	(void)sprintf(knob_val_pair, "{Z} {%d}",
		      dm_unlimit( (int)(edit_rate_tran[Z] * 2047.0) ));
      else
	(void)sprintf(knob_val_pair, "{Z} {%d}",
		      dm_unlimit( (int)(rate_slew[Z] * 2047.0) ));
#endif
d1856 1
a1856 1
	if(EDIT_SCALE && ((mged_variables.edit && !view_flag) || edit_flag))
d1858 2
a1859 1
	else
d1861 2
d1864 1
a1864 1
	if(EDIT_SCALE && ((mged_variables.edit && !view_flag) || edit_flag))
d1866 2
a1867 1
	else
d1869 2
a1872 8
#if DO_KNOB_EXPERIMENT
      if(EDIT_SCALE && ((mged_variables.edit && !view_flag) || edit_flag))
	(void)sprintf(knob_val_pair, "{S} {%d}",
		      dm_unlimit( (int)(edit_rate_scale * 2047.0) ));
      else
	(void)sprintf(knob_val_pair, "{S} {%d}",
		      dm_unlimit( (int)(rate_zoom * 2047.0) ));
#endif
d1914 1
a1914 1
	  /* wrap around */
d1921 1
a1921 5
#if DO_KNOB_EXPERIMENT
	(void)sprintf(knob_val_pair, "{ax} {%d}",
		      dm_unlimit( (int)(edit_absolute_rotate[X] * ar_scale_factor) ));
	Tcl_AppendElement(interp, knob_val_pair);
#endif
d1928 1
a1928 5
#if DO_KNOB_EXPERIMENT
	(void)sprintf(knob_val_pair, "{ax} {%d}",
		      dm_unlimit( (int)(absolute_rotate[X] * ar_scale_factor) ));
	Tcl_AppendElement(interp, knob_val_pair);
#endif
d1967 1
a1967 1
	  /* wrap around */
d1974 1
a1974 5
#if DO_KNOB_EXPERIMENT
	(void)sprintf(knob_val_pair, "{ay} {%d}",
		      dm_unlimit( (int)(edit_absolute_rotate[Y] * ar_scale_factor) ));
	Tcl_AppendElement(interp, knob_val_pair);
#endif
d1981 1
a1981 5
#if DO_KNOB_EXPERIMENT
	(void)sprintf(knob_val_pair, "{ay} {%d}",
		      dm_unlimit( (int)(absolute_rotate[Y] * ar_scale_factor) ));
	Tcl_AppendElement(interp, knob_val_pair);
#endif
d2027 1
a2027 5
#if DO_KNOB_EXPERIMENT
	(void)sprintf(knob_val_pair, "{az} {%d}",
		      dm_unlimit( (int)(edit_absolute_rotate[Z] * ar_scale_factor) ));
	Tcl_AppendElement(interp, knob_val_pair);
#endif
d2034 1
a2034 5
#if DO_KNOB_EXPERIMENT
	(void)sprintf(knob_val_pair, "{az} {%d}",
		      dm_unlimit( (int)(absolute_rotate[Z] * ar_scale_factor) ));
	Tcl_AppendElement(interp, knob_val_pair);
#endif
d2040 1
a2040 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d2042 2
a2043 1
	else
d2045 2
d2048 1
a2048 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d2050 2
a2051 1
	else
d2053 2
a2056 11
#if DO_KNOB_EXPERIMENT
      if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
	(void)sprintf(knob_val_pair, "{aX} {%d}",
		      dm_unlimit( (int)(edit_absolute_tran[X] * 2047.0)));
      else
	(void)sprintf(knob_val_pair, "{aX} {%d}",
		      dm_unlimit( (int)(absolute_slew[X] * 2047.0)));

      Tcl_AppendElement(interp, knob_val_pair);
#endif
      
d2061 1
a2061 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d2063 2
a2064 1
	else
d2066 2
d2069 1
a2069 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d2071 2
a2072 1
	else
d2074 2
a2077 10
#if DO_KNOB_EXPERIMENT
      if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
	(void)sprintf(knob_val_pair, "{aY} {%d}",
		      dm_unlimit( (int)(edit_absolute_tran[Y] * 2047.0)));
      else
	(void)sprintf(knob_val_pair, "{aY} {%d}",
		      dm_unlimit( (int)(absolute_slew[Y] * 2047.0)));

      Tcl_AppendElement(interp, knob_val_pair);
#endif
d2082 1
a2082 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d2084 2
a2085 1
	else
d2087 2
d2090 1
a2090 1
	if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
d2092 2
a2093 1
	else
d2095 2
a2097 8
      
#if DO_KNOB_EXPERIMENT
      if(EDIT_TRAN && ((mged_variables.edit && !view_flag) || edit_flag))
	(void)sprintf(knob_val_pair, "{aZ} {%d}",
		      dm_unlimit( (int)(edit_absolute_tran[Z] * 2047.0)));
      else
	(void)sprintf(knob_val_pair, "{aZ} {%d}",
		      dm_unlimit( (int)(absolute_slew[Z] * 2047.0)));
a2098 2
      Tcl_AppendElement(interp, knob_val_pair);
#endif
d2109 1
d2113 1
d2122 1
d2126 1
a2129 8
#if DO_KNOB_EXPERIMENT
      if(EDIT_SCALE && ((mged_variables.edit && !view_flag) || edit_flag))
	(void)sprintf(knob_val_pair, "{S} {%d}",
		      dm_unlimit( (int)(edit_absolute_scale * 2047.0) ));
      else
	(void)sprintf(knob_val_pair, "{S} {%d}",
		      dm_unlimit( (int)(absolute_zoom * 2047.0) ));
#endif
d2706 1
a2706 1
    Tcl_AppendResult(interp, "f_slewview: bad x value - ",
d2712 1
a2712 1
    Tcl_AppendResult(interp, "f_slewview: bad y value - ",
d2719 1
a2719 1
      Tcl_AppendResult(interp, "f_slewview: bad z value - ",
@


11.71
log
@changed f_knob's usage string
@
text
@a17 3
 *	f_refresh	request display refresh
 *	f_attach	attach display device
 *	f_release	release display device
d23 20
d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.70 1997/01/08 19:41:27 bparker Exp bparker $ (BRL)";
d84 2
d89 1
a89 1
int mged_zoom();
d91 1
d93 1
d95 1
d111 4
a1207 15
int
f_release(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  if(argc == 2)
    return release(argv[1], 1);

  return release(NULL, 1);
}
d1550 1
a1550 1
/* Main processing of knob twists.  "knob id val id val ..." */
d1552 1
a1552 2
f_knob(clientData, interp, argc, argv)
ClientData clientData;
a1553 2
int	argc;
char	**argv;
d1555 1
a1555 8
  int	i;
  fastf_t f;
  vect_t tvec;
  char	*cmd;
  int do_tran = 0;
  int incr_flag = 0;  /* interpret values as increments */
  int view_flag = 0;  /* force view interpretation */
  int edit_flag = 0;  /* force edit interpretation */
d1557 1
a1557 2
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;
d1559 6
a1564 7
  /* print the current values */
  if(argc == 1){
    struct bu_vls vls;

    bu_vls_init(&vls);

    if(mged_variables.rateknobs){
d1568 5
d1574 6
d1583 6
d1593 5
d1599 6
d1609 12
d1622 2
a1623 7
    if(mged_variables.adcflag){
      bu_vls_printf(&vls, "xadc = %d\n", dv_xadc);
      bu_vls_printf(&vls, "yadc = %d\n", dv_yadc);
      bu_vls_printf(&vls, "ang1 = %d\n", dv_1adc);
      bu_vls_printf(&vls, "ang2 = %d\n", dv_2adc);
      bu_vls_printf(&vls, "distadc = %d\n", dv_distadc);
    }
d1625 17
a1641 2
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
d1643 1
a1643 1
/*XXX Should be returning TCL_OK */
a1644 1
  }
d1670 4
a1673 1
  
a1686 5
      if(state != ST_VIEW){
	VSETALL( edit_rate_rotate, 0 );
	VSETALL( edit_rate_tran, 0 );
	edit_rate_scale = 0.0;
      }
d1688 3
d1735 9
d1757 9
d1779 9
d1801 9
d1823 9
d1845 9
d1867 9
d1900 9
a1908 1
	  if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d1910 3
a1912 12
	    (void)mged_param(interp, 3, edit_absolute_rotate);
	  }else {
	    if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
	      tvec[X] = f - edit_absolute_rotate[X];
	      tvec[Y] = 0.0;
	      tvec[Z] = 0.0;
	      mged_rot_obj(interp, 1, tvec);
	      edit_absolute_rotate[X] = f;
	    }else{
	      mged_vrot(f - absolute_rotate[X], 0.0, 0.0);
	      absolute_rotate[X] = f;
	    }
d1914 1
d1923 6
d1934 6
d1961 9
a1969 1
	  if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d1971 3
a1973 12
	    (void)mged_param(interp, 3, edit_absolute_rotate);
	  }else {
	    if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
	      tvec[X] = 0.0;
	      tvec[Y] = f - edit_absolute_rotate[Y];
	      tvec[Z] = 0.0;
	      mged_rot_obj(interp, 1, tvec);
	      edit_absolute_rotate[Y] = f;
	    }else{
	      mged_vrot(0.0, f - absolute_rotate[Y], 0.0);
	      absolute_rotate[Y] = f;
	    }
d1975 1
d1984 6
d1995 6
d2022 9
a2030 1
	  if(SEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
d2032 3
a2034 13
	    (void)mged_param(interp, 3, edit_absolute_rotate);
	  }else {
	    if(OEDIT_ROTATE && ((mged_variables.edit && !view_flag) || edit_flag)){
	      tvec[X] = 0.0;
	      tvec[Y] = 0.0;
	      tvec[Z] = f - edit_absolute_rotate[Z];
	      mged_rot_obj(interp, 1, tvec);
	      edit_absolute_rotate[Z] = f;
	    }else{
	      mged_vrot(0.0, 0.0, f - absolute_rotate[Z]);
	      absolute_rotate[Z] = f;
	    }
	    
d2036 1
d2039 1
a2039 1
	  /* wrap around */
d2045 6
d2056 6
d2077 11
d2104 10
d2129 10
d2166 8
d2666 481
@


11.70
log
@*- added fast path to f_zoom()  --->  mged_zoom()
*- test if ( Viewscale <  MINVIEW )
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.69 1997/01/08 18:57:59 jra Exp bparker $ (BRL)";
d2078 3
a2080 2
		"knob: x,y,z for rotation, S for scale, X,Y,Z for slew (rates, range -1..+1)\n",
		"knob: ax,ay,az for absolute rotation, aS for absolute scale,\n",
d2082 2
a2083 1
		"knob: xadc, yadc, ang1, ang2, distadc (values, range -2048..+2047)\n",
@


11.69
log
@Modified mged_tree_describe() to handle NULL trees.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.68 1997/01/02 19:36:55 bparker Exp jra $ (BRL)";
d70 1
d2282 3
a2297 7

/*
 *			F _ Z O O M
 *
 *  A scale factor of 2 will increase the view size by a factor of 2,
 *  (i.e., a zoom out) which is accomplished by reducing Viewscale in half.
 */
d2299 2
a2300 5
f_zoom(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
a2301 1
  double val;
a2303 4
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  val = atof(argv[1]);
d2309 3
a2311 2
  if( Viewscale < SMALL_FASTF || Viewscale > INFINITY )
    return TCL_ERROR;
a2312 1
  Viewscale /= val;
d2330 20
@


11.68
log
@mods to use libbn and libbu
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.67 1996/12/23 22:41:28 bparker Exp bparker $ (BRL)";
d739 7
@


11.67
log
@mods to f_knob
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.66 1996/12/17 22:45:21 bparker Exp bparker $ (BRL)";
a43 1
#include <math.h>
d46 1
d48 1
d51 1
d56 1
d85 1
a85 1
extern struct rt_tol mged_tol;	/* from ged.c */
d161 1
a161 1
  mat_idn( newrot );
d163 1
a163 1
  mat_mul2( newrot, Viewrot );
d168 1
a168 1
    mat_inv( newinv, newrot );
d359 1
a359 1
	mat_idn( toViewcenter );
d750 2
a751 2
			ae_vec( &az, &el, tp->tr_l.tl_mat ?
				tp->tr_l.tl_mat : rt_identity );
d842 1
a842 1
	RT_INIT_EXTERNAL(&ext);
d875 1
a875 1
	mat_idn( ident );
d1067 4
a1070 4
  mat_print("toViewcenter", toViewcenter);
  mat_print("Viewrot", Viewrot);
  mat_print("model2view", model2view);
  mat_print("view2model", view2model);
d1072 2
a1073 2
    mat_print("model2objview", model2objview);
    mat_print("objview2model", objview2model);
d2168 1
a2168 1
	    sec = mged_nrm_tol * rt_radtodeg;
d2175 1
a2175 1
			  mged_nrm_tol * rt_radtodeg, deg, min, sec );
d2190 1
a2190 1
			  acos(mged_tol.perp)*rt_radtodeg);
d2226 1
a2226 1
			mged_nrm_tol = f * rt_degtorad;
@


11.66
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.65 1996/12/17 21:48:53 bparker Exp bparker $ (BRL)";
d2024 3
d2028 1
d2043 3
d2047 1
@


11.65
log
@*- added code to eliminate jumpy sliders
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.64 1996/12/13 23:10:54 bparker Exp bparker $ (BRL)";
a2082 1
  point_t old_pos;
@


11.64
log
@weekend checkin
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.63 1996/12/12 22:10:09 bparker Exp bparker $ (BRL)";
d156 1
a156 2
  point_t model_pos;
  point_t new_pos;
a157 4
#if 0
  if(EDIT_TRAN)
    MAT4X3PNT(model_pos, view2model, edit_absolute_tran);
#endif
d168 1
d170 7
a176 6
#if 0
  if(EDIT_TRAN)
    MAT4X3PNT(edit_absolute_tran, model2view, model_pos);
#endif
  VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, new_pos);
d2266 6
a2271 2
  VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, new_pos);
d2313 6
a2318 2
  VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, new_pos);
@


11.63
log
@start of cleanup
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.62 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d64 1
d66 2
d83 1
d1541 2
a1542 1
  char	*cmd;/* = argv[1];*/
d1658 1
d1663 1
d1766 1
a1766 3
	  (void)irot(edit_absolute_rotate[X],
		     edit_absolute_rotate[Y],
		     edit_absolute_rotate[Z], 0);
d1769 4
a1772 1
	    (void)irot(f, 0.0, 0.0, 1);
d1782 1
a1782 3
	    (void)irot(edit_absolute_rotate[X],
		       edit_absolute_rotate[Y],
		       edit_absolute_rotate[Z], 0);
d1785 4
a1788 1
	      (void)irot(f - edit_absolute_rotate[X], 0.0, 0.0, 1);
d1815 1
a1815 3
	  (void)irot(edit_absolute_rotate[X],
		     edit_absolute_rotate[Y],
		     edit_absolute_rotate[Z], 0);
d1818 4
a1821 1
	    (void)irot(0.0, f, 0.0, 1);
d1831 1
a1831 3
	    (void)irot(edit_absolute_rotate[X],
		       edit_absolute_rotate[Y],
		       edit_absolute_rotate[Z], 0);
d1834 4
a1837 1
	      (void)irot(0.0, f - edit_absolute_rotate[Y], 0.0, 1);
a1842 1
	    
d1864 1
a1864 3
	  (void)irot(edit_absolute_rotate[X],
		     edit_absolute_rotate[Y],
		     edit_absolute_rotate[Z], 0);
d1867 4
a1870 1
	    (void)irot(0.0, 0.0, f, 1);
d1880 1
a1880 3
	    (void)irot(edit_absolute_rotate[X],
		       edit_absolute_rotate[Y],
		       edit_absolute_rotate[Z], 0);
d1883 4
a1886 1
	      (void)irot(0.0, 0.0, f - edit_absolute_rotate[Z], 1);
d1959 4
a1962 2
	  if(state = ST_S_EDIT)
	    sedit_scale();
d1970 4
a1973 2
	  if(state = ST_S_EDIT)
	    sedit_scale();
d2074 1
a2074 1
    (void)tran(view_flag);
d2079 28
@


11.62
log
@experimentation
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.61 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d1538 2
a1539 1
  static int aslewflag = 0;
d1541 1
a1541 3
  vect_t	aslew;
  int iknob = 0;
  int do_tran = 0;
d1590 1
a1590 1
    while((c = bu_getopt(argc, argv, "iv")) != EOF){
d1592 3
d1596 1
a1596 1
	iknob = 1;
d1660 2
a1661 2
	if(iknob){
	  if(EDIT_ROTATE && mged_variables.edit && !view_flag)
d1666 1
a1666 1
	  if(EDIT_ROTATE && mged_variables.edit && !view_flag)
d1673 2
a1674 2
	if(iknob){
	  if(EDIT_ROTATE && mged_variables.edit && !view_flag)
d1679 1
a1679 1
	  if(EDIT_ROTATE && mged_variables.edit && !view_flag)
d1686 2
a1687 2
	if(iknob){
	  if(EDIT_ROTATE && mged_variables.edit && !view_flag)
d1692 1
a1692 1
	  if(EDIT_ROTATE && mged_variables.edit && !view_flag)
d1699 2
a1700 2
      if(iknob){
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1705 1
a1705 1
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1712 2
a1713 2
      if(iknob){
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1718 1
a1718 1
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1725 2
a1726 2
      if(iknob){
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1731 1
a1731 1
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1738 11
a1748 4
      if(iknob)
	rate_zoom += f;
      else
	rate_zoom = f;
d1756 2
a1757 2
      if(iknob){
	if(SEDIT_ROTATE && mged_variables.edit && !view_flag){
d1763 1
a1763 1
	  if(OEDIT_ROTATE && mged_variables.edit && !view_flag){
d1772 1
a1772 1
	  if(SEDIT_ROTATE && mged_variables.edit && !view_flag){
d1778 1
a1778 1
	    if(OEDIT_ROTATE && mged_variables.edit && !view_flag){
a1784 1
	    
d1789 1
a1789 1
      if(EDIT_ROTATE && mged_variables.edit && !view_flag){
d1803 2
a1804 2
      if(iknob){
	if(SEDIT_ROTATE && mged_variables.edit && !view_flag){
d1810 1
a1810 1
	  if(OEDIT_ROTATE && mged_variables.edit && !view_flag){
d1819 1
a1819 1
	  if(SEDIT_ROTATE && mged_variables.edit && !view_flag){
d1825 1
a1825 1
	    if(OEDIT_ROTATE && mged_variables.edit && !view_flag){
d1837 1
a1837 1
      if(EDIT_ROTATE && mged_variables.edit && !view_flag){
d1851 2
a1852 2
      if(iknob){
	if(SEDIT_ROTATE && mged_variables.edit && !view_flag){
d1858 1
a1858 1
	  if(OEDIT_ROTATE && mged_variables.edit && !view_flag){
d1867 1
a1867 1
	  if(SEDIT_ROTATE && mged_variables.edit && !view_flag){
d1873 1
a1873 1
	    if(OEDIT_ROTATE && mged_variables.edit && !view_flag){
d1885 1
a1885 1
      if(EDIT_ROTATE && mged_variables.edit && !view_flag){
d1899 2
a1900 2
      if(iknob){
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1905 1
a1905 1
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1914 2
a1915 2
      if(iknob){
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1920 1
a1920 1
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1929 2
a1930 2
      if(iknob){
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1935 1
a1935 1
	if(EDIT_TRAN && mged_variables.edit && !view_flag)
d1944 2
a1945 2
      if(iknob){
	if(EDIT_SCALE)
d1947 3
a1949 1
	else
d1951 2
d1954 1
a1954 1
	if(EDIT_SCALE)
d1956 3
a1958 1
	else
d1960 2
a1963 1
      abs_zoom();
d1975 1
a1975 1
	  if(iknob)
d1990 1
a1990 1
	  if(iknob)
d2005 1
a2005 1
	  if(iknob)
d2020 1
a2020 1
	  if(iknob)
d2035 1
a2035 1
	  if(iknob)
d2208 1
a2208 1
  char *av[3];
a2209 4
  av[0] = "zoom";
  av[1] = "1";
  av[2] = NULL;

d2223 7
a2229 1
  (void)f_zoom((ClientData)NULL, interp, 2, av);
d2246 2
a2247 5
  double	val;
  point_t new_pos;
  point_t old_pos;
  point_t diff;
  point_t model_pos;
d2251 1
a2251 4
#if 0
  if(EDIT_TRAN)
    MAT4X3PNT(model_pos, view2model, absolute_slew);
#endif
d2267 1
a2267 4
#if 0
  if(EDIT_TRAN)
    MAT4X3PNT(absolute_slew, model2view, model_pos);
#endif
d2270 3
@


11.61
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.60 1996/12/06 21:55:11 bparker Exp bparker $ (BRL)";
d155 1
d158 1
a158 1

d170 1
a170 1

d173 1
a173 1

d1539 1
a1539 1
  int view_flag = 0;  /* force view */
d1659 1
a1659 1
	  if(EDIT_ROTATE && !view_flag)
d1664 1
a1664 1
	  if(EDIT_ROTATE && !view_flag)
d1672 1
a1672 1
	  if(EDIT_ROTATE && !view_flag)
d1677 1
a1677 1
	  if(EDIT_ROTATE && !view_flag)
d1685 1
a1685 1
	  if(EDIT_ROTATE && !view_flag)
d1690 1
a1690 1
	  if(EDIT_ROTATE && !view_flag)
d1698 1
a1698 1
	if(EDIT_TRAN && !view_flag)
d1703 1
a1703 1
	if(EDIT_TRAN && !view_flag)
d1711 1
a1711 1
	if(EDIT_TRAN && !view_flag)
d1716 1
a1716 1
	if(EDIT_TRAN && !view_flag)
d1724 1
a1724 1
	if(EDIT_TRAN && !view_flag)
d1729 1
a1729 1
	if(EDIT_TRAN && !view_flag)
d1748 1
a1748 1
	if(SEDIT_ROTATE && !view_flag){
d1754 1
a1754 1
	  if(OEDIT_ROTATE && !view_flag){
d1763 1
a1763 1
	  if(SEDIT_ROTATE && !view_flag){
d1769 1
a1769 1
	    if(OEDIT_ROTATE && !view_flag){
d1781 1
a1781 1
      if(EDIT_ROTATE && !view_flag){
d1796 1
a1796 1
	if(SEDIT_ROTATE && !view_flag){
d1802 1
a1802 1
	  if(OEDIT_ROTATE && !view_flag){
d1811 1
a1811 1
	  if(SEDIT_ROTATE && !view_flag){
d1817 1
a1817 1
	    if(OEDIT_ROTATE && !view_flag){
d1829 1
a1829 1
      if(EDIT_ROTATE && !view_flag){
d1844 1
a1844 1
	if(SEDIT_ROTATE && !view_flag){
d1850 1
a1850 1
	  if(OEDIT_ROTATE && !view_flag){
d1859 1
a1859 1
	  if(SEDIT_ROTATE && !view_flag){
d1865 1
a1865 1
	    if(OEDIT_ROTATE && !view_flag){
d1877 1
a1877 1
      if(EDIT_ROTATE && !view_flag){
d1892 1
a1892 1
	if(EDIT_TRAN && !view_flag)
d1897 1
a1897 1
	if(EDIT_TRAN && !view_flag)
d1907 1
a1907 1
	if(EDIT_TRAN && !view_flag)
d1912 1
a1912 1
	if(EDIT_TRAN && !view_flag)
d1922 1
a1922 1
	if(EDIT_TRAN && !view_flag)
d1927 1
a1927 1
	if(EDIT_TRAN && !view_flag)
d2042 2
a2043 6
  if(do_tran){
    if(EDIT_TRAN && !view_flag)
      (void)tran( edit_absolute_tran );
    else
      (void)tran( absolute_slew );
  }
d2237 1
a2237 1

d2240 1
a2240 1

d2256 2
a2257 2

  if(EDIT_TRAN){
d2259 3
a2261 4
  }else{
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
  }
@


11.60
log
@not done yet --- working on allowing full view manipulation while editing
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.59 1996/12/04 21:10:11 bparker Exp bparker $ (BRL)";
a81 1
vect_t edit_absolute_slew;
d83 10
a92 1
vect_t edit_rate_slew;
d156 1
a156 1
    MAT4X3PNT(model_pos, view2model, absolute_slew);
d170 5
a174 6
  if(EDIT_TRAN){
    MAT4X3PNT(absolute_slew, model2view, model_pos);
  }else{
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
  }
d1495 28
d1538 1
d1585 20
a1604 5
  /* Check for -i option */
  if(argv[1][0] == '-' && argv[1][1] == 'i'){
    iknob = 1;  /* treat arguments as incremental values */
    ++argv;
    --argc;
d1606 1
d1622 2
a1623 1
	VSETALL( edit_rate_slew, 0 );
d1657 11
a1667 4
	if(iknob)
	  rate_rotate[X] += f;
	else
	  rate_rotate[X] = f;
d1670 11
a1680 4
	if(iknob)
	  rate_rotate[Y] += f;
	else
	  rate_rotate[Y] = f;
d1683 11
a1693 4
	if(iknob)
	rate_rotate[Z] += f;
      else
	rate_rotate[Z] = f;
d1696 11
a1706 4
      if(iknob)
	rate_slew[X] += f;
      else
	rate_slew[X] = f;
d1709 11
a1719 4
      if(iknob)
	rate_slew[Y] += f;
      else
	rate_slew[Y] = f;
d1722 11
a1732 4
      if(iknob)
	rate_slew[Z] += f;
      else
	rate_slew[Z] = f;
d1747 7
a1753 10
#if 1
	if(state == ST_S_EDIT && EDIT_ROTATE){
#else
	  if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
#endif
	    absolute_rotate[X] += f;
	    (void)irot(absolute_rotate[X],
		       absolute_rotate[Y],
		       absolute_rotate[Z], 0);
	  }else {
d1755 3
d1760 13
a1772 6
	}else{
#if 1
	  if(state == ST_S_EDIT && EDIT_ROTATE){
#else
	    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
#endif
d1774 96
a1869 6
	      (void)irot(absolute_rotate[X],
			 absolute_rotate[Y],
			 absolute_rotate[Z], 0);
	    }else {
	      (void)irot(f - absolute_rotate[X], 0.0, 0.0, 1);
	      absolute_rotate[X] = f;
d1871 1
d1873 1
d1876 11
a1886 36
	  if(absolute_rotate[X] < -180.0)
	    absolute_rotate[X] = absolute_rotate[X] + 360.0;
	  else if(absolute_rotate[X] > 180.0)
	    absolute_rotate[X] = absolute_rotate[X] - 360.0;

	  break;
	case 'y':
		  if(iknob){
#if 1
		    if(state == ST_S_EDIT && EDIT_ROTATE){
#else
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
#endif
		      absolute_rotate[Y] += f;
		      (void)irot(absolute_rotate[X],
				 absolute_rotate[Y],
				 absolute_rotate[Z], 0);
		    }else {
		      (void)irot(0.0, f, 0.0, 1);
		      absolute_rotate[Y] += f;
		    }
		  }else{
#if 1
		    if(state == ST_S_EDIT && EDIT_ROTATE){
#else
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
#endif
		      absolute_rotate[Y] = f;
		      (void)irot(absolute_rotate[X],
				 absolute_rotate[Y],
				 absolute_rotate[Z], 0);
		    }else {
		      (void)irot(0.0, f - absolute_rotate[Y], 0.0, 1);
		      absolute_rotate[Y] = f;
		    }
		  }
d1888 58
a1945 37
		  /* wrap around */
		  if(absolute_rotate[Y] < -180.0)
		    absolute_rotate[Y] = absolute_rotate[Y] + 360.0;
		  else if(absolute_rotate[Y] > 180.0)
		    absolute_rotate[Y] = absolute_rotate[Y] - 360.0;

		  break;
		case 'z':
		  if(iknob){
#if 1
		    if(state == ST_S_EDIT && EDIT_ROTATE){
#else
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
#endif
		      absolute_rotate[Z] += f;
		      (void)irot(absolute_rotate[X],
				 absolute_rotate[Y],
				 absolute_rotate[Z], 0);
		    }else {
		      (void)irot(0.0, 0.0, f, 1);
		      absolute_rotate[Z] += f;
		    }
		  }else{
#if 1
		    if(state == ST_S_EDIT && EDIT_ROTATE){
#else
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
#endif
		      absolute_rotate[Z] = f;
		      (void)irot(absolute_rotate[X],
				 absolute_rotate[Y],
				 absolute_rotate[Z], 0);
		    }else {
		      (void)irot(0.0, 0.0, f - absolute_rotate[Z], 1);
		      absolute_rotate[Z] = f;
		    }
		  }
d1947 6
a1952 43
		  /* wrap around */
		  if(absolute_rotate[Z] < -180.0)
		    absolute_rotate[Z] = absolute_rotate[Z] + 360.0;
		  else if(absolute_rotate[Z] > 180.0)
		    absolute_rotate[Z] = absolute_rotate[Z] - 360.0;

		  break;
		case 'X':
		  if(iknob)
		    absolute_slew[X] += f;
		  else
		    absolute_slew[X] = f;

		  do_tran = 1;
		  break;
		case 'Y':
		  if(iknob)
		    absolute_slew[Y] += f;
		  else
		    absolute_slew[Y] = f;

		  do_tran = 1;
		  break;
		case 'Z':
		  if(iknob)
		    absolute_slew[Z] += f;
		  else
		    absolute_slew[Z] = f;

		  do_tran = 1;
		  break;
		case 'S':
		  if(iknob)
		    absolute_zoom += f;
		  else
		    absolute_zoom = f;

		  abs_zoom();
		  break;
		default:
			goto usage;
		}
	} else if( strcmp( cmd, "xadc" ) == 0 )  {
d2041 7
a2047 3
  if(do_tran)
    (void)tran( absolute_slew );

@


11.59
log
@mods to mged_vrot
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.58 1996/12/04 03:39:35 mike Exp bparker $ (BRL)";
d81 4
d1568 4
d2075 8
a2082 5
	double	val;
	vect_t view_pos;
	point_t new_pos;
	point_t old_pos;
	point_t diff;
d2084 2
a2085 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d2087 5
a2091 1
	MAT_DELTAS_GET(old_pos, toViewcenter);
d2093 2
a2094 5
	val = atof(argv[1]);
	if( val < SMALL_FASTF || val > INFINITY )  {
	  Tcl_AppendResult(interp, "zoom: scale factor out of range\n", (char *)NULL);
	  return TCL_ERROR;
	}
d2096 2
a2097 2
	if( Viewscale < SMALL_FASTF || Viewscale > INFINITY )
	  return TCL_ERROR;
d2099 3
a2101 2
	Viewscale /= val;
	new_mats();
d2103 6
a2108 16
	absolute_zoom = 1.0 - Viewscale / i_Viewscale;
	if(absolute_zoom < 0.0)
	  absolute_zoom /= 9.0;

	if(state == ST_S_EDIT || state == ST_O_EDIT){
	  absolute_slew[X] *= val;
	  absolute_slew[Y] *= val;
	  absolute_slew[Z] *= val;
	}else{
	  MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
	  VSUB2(diff, new_pos, orig_pos);
	  VADD2(new_pos, old_pos, diff);
	  VSET(view_pos, new_pos[X], new_pos[Y], new_pos[Z]);
	  MAT4X3PNT( new_pos, model2view, view_pos);
	  VMOVE( absolute_slew, new_pos );
	}
d2110 1
a2110 1
	return TCL_OK;
@


11.58
log
@Changed ma_matparm stuff to ma_shader
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.57 1996/12/04 03:38:12 mike Exp mike $ (BRL)";
d140 2
d143 3
d158 7
a180 1
#if 1
a181 8
#else
  /* run through knob to possibly update GUI sliders */
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob -i ax %s ay %s az %s\n",
		argv[1], argv[2], argv[3]);
  status = Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
#endif
d1138 1
a1138 1
#if 1
@


11.57
log
@BParker mods to irot()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.56 1996/11/28 08:36:59 mike Exp bparker $ (BRL)";
d650 1
a650 1
	if( bu_vls_strlen(&comb->shader_name) > 0 ) {
d652 2
a653 3
			"Shader '%s' '%s'\n",
		bu_vls_addr(&comb->shader_name),
			bu_vls_addr(&comb->shader_param) );
d664 1
a664 1
	if( bu_vls_strlen(&comb->shader_name) > 0 || comb->rgb_valid )  {
@


11.56
log
@Changed non-verbose form to using compact LIBRT parenthesized version
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.55 1996/11/28 08:17:35 mike Exp mike $ (BRL)";
d65 2
a80 1
static void abs_zoom();
d134 1
d136 21
d163 2
a164 1
  mat_t newrot;
d166 2
a167 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
a168 7
#if 0
	/* Actually, it would be nice if this worked all the time */
	/* usejoy isn't quite the right thing */
	if( not_state( ST_VIEW, "View Rotate") )
	  return TCL_ERROR;
#endif

d170 1
a170 11
	mat_idn( newrot );
	buildHrot( newrot, atof(argv[1]) * degtorad,
		   atof(argv[2]) * degtorad, atof(argv[3]) * degtorad );
	mat_mul2( newrot, Viewrot );

	{
	  mat_t   newinv;
	  mat_inv( newinv, newrot );
	  wrt_view( ModelDelta, newinv, ModelDelta );
	}
	new_mats();
d172 6
a177 3
	usejoy(	atof(argv[1]) * degtorad,
		atof(argv[2]) * degtorad,
		atof(argv[3]) * degtorad );
d180 1
a180 1
	return TCL_OK;
d1107 1
a1134 1
    bu_vls_init(&vls);
d1136 1
a1136 4
    av[0] = "vrot";
    av[1] = "0.0";
    av[2] = "0.0";

d1138 1
a1138 1
      bu_vls_printf(&vls, "%f", -o_twist - twist);
d1140 7
a1146 1
      bu_vls_printf(&vls, "%f", -twist);
d1148 1
a1148 2
    av[3] = bu_vls_addr(&vls);
    (void)f_vrot(clientData, interp, 4, av);
d1150 1
d1153 1
a1153 1
  return TCL_OK;
d1574 1
d1579 1
d1587 5
d1639 3
a1641 5
    struct bu_vls cmd_vls;

		switch( cmd[1] ) {
		case 'x':
		  if(iknob){
d1643 1
a1643 1
		    if(state == ST_S_EDIT && EDIT_ROTATE){
d1645 1
a1645 1
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
d1647 9
a1655 9
		      absolute_rotate[X] += f;
		      (void)irot(absolute_rotate[X]*180.0,
				 absolute_rotate[Y]*180.0,
				 absolute_rotate[Z]*180.0, 0);
		    }else {
		      (void)irot(f*180.0, 0.0, 0.0, 1);
		      absolute_rotate[X] += f;
		    }
		  }else{
d1657 1
a1657 1
		    if(state == ST_S_EDIT && EDIT_ROTATE){
d1659 1
a1659 1
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
d1661 15
a1675 9
		      absolute_rotate[X] = f;
		      (void)irot((absolute_rotate[X])*180.0,
				 absolute_rotate[Y]*180.0,
				 absolute_rotate[Z]*180.0, 0);
		    }else {
		      (void)irot((f - absolute_rotate[X])*180.0, 0.0, 0.0, 1);
		      absolute_rotate[X] = f;
		    }
		  }
d1677 2
a1678 8
		  /* wrap around */
		  if(absolute_rotate[X] < -1.0)
		    absolute_rotate[X] = absolute_rotate[X] + 2.0;
		  else if(absolute_rotate[X] > 1.0)
		    absolute_rotate[X] = absolute_rotate[X] - 2.0;

		  break;
		case 'y':
d1686 3
a1688 3
		      (void)irot(absolute_rotate[X]*180.0,
				 absolute_rotate[Y]*180.0,
				 absolute_rotate[Z]*180.0, 0);
d1690 1
a1690 1
		      (void)irot(0.0, f*180.0, 0.0, 1);
d1700 3
a1702 3
		      (void)irot(absolute_rotate[X]*180.0,
				 (absolute_rotate[Y])*180.0,
				 absolute_rotate[Z]*180.0, 0);
d1704 1
a1704 1
		      (void)irot(0.0, (f - absolute_rotate[Y])*180.0, 0.0, 1);
d1710 4
a1713 4
		  if(absolute_rotate[Y] < -1.0)
		    absolute_rotate[Y] = absolute_rotate[Y] + 2.0;
		  else if(absolute_rotate[Y] > 1.0)
		    absolute_rotate[Y] = absolute_rotate[Y] - 2.0;
d1724 3
a1726 3
		      (void)irot(absolute_rotate[X]*180.0,
				 absolute_rotate[Y]*180.0,
				 absolute_rotate[Z]*180.0, 0);
d1728 1
a1728 1
		      (void)irot(0.0, 0.0, f*180.0, 1);
d1738 3
a1740 3
		      (void)irot(absolute_rotate[X]*180.0,
				 absolute_rotate[Y]*180.0,
				 (absolute_rotate[Z])*180.0, 0);
d1742 1
a1742 1
		      (void)irot(0.0, 0.0, (f - absolute_rotate[Z])*180.0, 1);
d1748 4
a1751 4
		  if(absolute_rotate[Z] < -1.0)
		    absolute_rotate[Z] = absolute_rotate[Z] + 2.0;
		  else if(absolute_rotate[Z] > 1.0)
		    absolute_rotate[Z] = absolute_rotate[Z] - 2.0;
@


11.55
log
@Changed over to combination import/export routines
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.54 1996/11/28 06:03:02 mike Exp mike $ (BRL)";
d702 1
a702 1
mged_tree_describe( vls, tp, indented, lvl, verbose )
a706 1
int			verbose;
d717 10
a726 52
		if( verbose )  {
			/* One per line, out onto the vls */
			if( !indented )  bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, tp->tr_l.tl_name );
			if( status & STAT_ROT ) {
				fastf_t	az, el;
				ae_vec( &az, &el, tp->tr_l.tl_mat ?
					tp->tr_l.tl_mat : rt_identity );
				bu_vls_printf( vls, 
					" az=%g, el=%g, ",
					az, el );
			}
			if( status & STAT_XLATE ) {
				bu_vls_printf( vls, " [%g,%g,%g]",
					tp->tr_l.tl_mat[MDX]*base2local,
					tp->tr_l.tl_mat[MDY]*base2local,
					tp->tr_l.tl_mat[MDZ]*base2local);
			}
			if( status & STAT_SCALE ) {
				bu_vls_printf( vls, " scale %g",
					1.0/tp->tr_l.tl_mat[15] );
			}
			if( status & STAT_PERSP ) {
				bu_vls_printf( vls, 
					" Perspective=[%g,%g,%g]??",
					tp->tr_l.tl_mat[12],
					tp->tr_l.tl_mat[13],
					tp->tr_l.tl_mat[14] );
			}
			bu_vls_printf( vls, "\n" );
		} else {
			/* Many per line, using columnation */
			if( status )  {
				register char	*cp;
				struct bu_vls	str;
				char	buf[8];

				bu_vls_init( &str );
				bu_vls_strcpy( &str, tp->tr_l.tl_name );
				cp = buf;
				*cp++ = '/';
				if( status & STAT_ROT )  *cp++ = 'R';
				if( status & STAT_XLATE) *cp++ = 'T';
				if( status & STAT_SCALE) *cp++ = 'S';
				if( status & STAT_PERSP) *cp++ = 'P';
				*cp = '\0';
				bu_vls_strcat( vls, buf );
				vls_col_item( vls, bu_vls_addr(&str) );
				bu_vls_trunc( &str, 0 );
			} else {
				vls_col_item( vls, tp->tr_l.tl_name );
			}
d728 18
d750 2
a751 4
		if( verbose )  {
			if(!indented) bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, "u " );
		}
d754 2
a755 4
		if( verbose )  {
			if(!indented) bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, "+ " );
		}
d758 2
a759 4
		if( verbose )  {
			if(!indented) bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, "- " );
		}
d762 2
a763 4
		if( verbose )  {
			if(!indented) bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, "^ " );
		}
d765 2
a766 2
		mged_tree_describe( vls, tp->tr_b.tb_left, 1, lvl+1, verbose );
		mged_tree_describe( vls, tp->tr_b.tb_right, 0, lvl+1, verbose );
d771 2
a772 4
		if( verbose )  {
			if(!indented) bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, "! " );
		}
d775 2
a776 4
		if( verbose )  {
			if(!indented) bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, "G " );
		}
d779 2
a780 4
		if( verbose )  {
			if(!indented) bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, "X " );
		}
d786 2
a787 4
		if( verbose )  {
			if(!indented) bu_vls_spaces( vls, 2*lvl );
			bu_vls_strcat( vls, "NOP\n" );
		}
d837 5
a841 2
		mged_tree_describe( outstrp, comb->tree, 0, 1, verbose );
		if( !verbose )  vls_col_eol( outstrp );
@


11.54
log
@Added function headers
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.53 1996/11/27 08:56:16 mike Exp mike $ (BRL)";
a53 1
#include "db.h"
d619 219
a846 1
	register union record	*rp;
d848 1
a848 1
	struct rt_external	ext;
d852 1
a853 1

a860 1
	rp = (union record *)ext.ext_buf;
d862 3
a864 2
	/* XXX This should be converted to _import and _describe routines! */
	if( rp[0].u_id == ID_COMB )  {
a867 28
		if( rp[0].c.c_flags == 'R' ) {
			bu_vls_printf( outstrp,
			       "REGION id=%d  (air=%d, los=%d, GIFTmater=%d) ",
				rp[0].c.c_regionid,
				rp[0].c.c_aircode,
				rp[0].c.c_los,
				rp[0].c.c_material );
		}
		bu_vls_strcat( outstrp, "--\n" );
		if( rp[0].c.c_matname[0] ) {
			bu_vls_printf( outstrp,
				"Material '%s' '%s'\n",
				rp[0].c.c_matname,
				rp[0].c.c_matparm);
		}
		if( rp[0].c.c_override == 1 ) {
			bu_vls_printf( outstrp,
				"Color %d %d %d\n",
				rp[0].c.c_rgb[0],
				rp[0].c.c_rgb[1],
				rp[0].c.c_rgb[2]);
		}
		if( rp[0].c.c_matname[0] || rp[0].c.c_override )  {
			if( rp[0].c.c_inherit == DB_INH_HIGHER ) {
				bu_vls_strcat( outstrp, 
	"(These material properties override all lower ones in the tree)\n");
			}
		}
d869 5
a873 77
		for( i=1; i < dp->d_len; i++ )  {
			mat_t	xmat;
			int	status;

			status = 0;
#define STAT_ROT	1
#define STAT_XLATE	2
#define STAT_PERSP	4
#define STAT_SCALE	8

			/* See if this matrix does anything */
			rt_mat_dbmat( xmat, rp[i].M.m_mat );

			if( xmat[0] != 1.0 || xmat[5] != 1.0 
						|| xmat[10] != 1.0 )
				status |= STAT_ROT;

			if( xmat[MDX] != 0.0 ||
			    xmat[MDY] != 0.0 ||
			    xmat[MDZ] != 0.0 )
				status |= STAT_XLATE;

			if( xmat[12] != 0.0 ||
			    xmat[13] != 0.0 ||
			    xmat[14] != 0.0 )
				status |= STAT_PERSP;

			if( xmat[15] != 1.0 )  status |= STAT_SCALE;

			if( verbose )  {
				bu_vls_printf( outstrp, "  %c %s",
					rp[i].M.m_relation, 
					rp[i].M.m_instname );
				if( status & STAT_ROT ) {
					fastf_t	az, el;
					ae_vec( &az, &el, xmat );
					bu_vls_printf( outstrp, 
						" az=%g, el=%g, ",
						az, el );
				}
				if( status & STAT_XLATE ) {
					bu_vls_printf( outstrp, " [%g,%g,%g]",
						xmat[MDX]*base2local,
						xmat[MDY]*base2local,
						xmat[MDZ]*base2local);
				}
				if( status & STAT_SCALE ) {
					bu_vls_printf( outstrp, " scale %g",
						1.0/xmat[15] );
				}
				if( status & STAT_PERSP ) {
					bu_vls_printf( outstrp, 
						" ??Perspective=[%g,%g,%g]??",
						xmat[12], xmat[13], xmat[14] );
				}
				bu_vls_printf( outstrp, "\n" );
			} else {
				register char	*cp;

				bu_vls_trunc( &str, 0 );
				bu_vls_printf( &str, "%c %s",
					rp[i].M.m_relation, 
					rp[i].M.m_instname );

				cp = bu_vls_addr( &str );
				if( status )  {
					cp += strlen(cp);
					*cp++ = '/';
					if( status & STAT_ROT )  *cp++ = 'R';
					if( status & STAT_XLATE) *cp++ = 'T';
					if( status & STAT_SCALE) *cp++ = 'S';
					if( status & STAT_PERSP) *cp++ = 'P';
					*cp = '\0';
				}
				vls_col_item( outstrp, bu_vls_addr(&str) );
				bu_vls_trunc( &str, 0 );
			}
d875 4
d880 1
@


11.53
log
@Added debugbu command
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.52 1996/11/19 21:45:22 bparker Exp mike $ (BRL)";
d426 5
d457 5
d486 5
d522 5
d559 6
d586 5
d781 6
a786 2
/* List object information, verbose */
/* Format: l object	*/
@


11.52
log
@add parameter to irot()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.51 1996/11/01 22:14:17 bparker Exp bparker $ (BRL)";
d477 31
d524 1
@


11.51
log
@-add new function f_aetview()
-add -i option to f_knob
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.50 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
a936 16
/* set view using azimuth and elevation angles */
int
f_aeview(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  setview( 270.0 + atof(argv[2]), 0.0, 270.0 - atof(argv[1]) );

  return TCL_OK;
}

d958 1
d961 1
a961 1
  bu_vls_init(&vls);
a962 4
  twist = atof(argv[3]);
  av[0] = "vrot";
  av[1] = "0.0";
  av[2] = "0.0";
d964 2
a965 1
  if(iflag){
d969 1
a969 2
    bu_vls_printf(&vls, "%f", -o_twist - twist);
  }else{
d971 16
a986 1
    bu_vls_printf(&vls, "%f", -twist);
a988 3
  av[3] = bu_vls_addr(&vls);
  (void)f_vrot(clientData, interp, 4, av);
  bu_vls_free(&vls);
d1473 3
d1477 1
d1481 1
a1481 1
				 absolute_rotate[Z]*180.0);
d1483 1
a1483 1
		      (void)irot(f*180.0, 0.0, 0.0);
d1487 3
d1491 1
d1495 1
a1495 1
				 absolute_rotate[Z]*180.0);
d1497 1
a1497 1
		      (void)irot((f - absolute_rotate[X])*180.0, 0.0, 0.0);
d1511 3
d1515 1
d1519 1
a1519 1
				 absolute_rotate[Z]*180.0);
d1521 1
a1521 1
		      (void)irot(0.0, f*180.0, 0.0);
d1525 3
d1529 1
d1533 1
a1533 1
				 absolute_rotate[Z]*180.0);
d1535 1
a1535 1
		      (void)irot(0.0, (f - absolute_rotate[Y])*180.0, 0.0);
d1549 3
d1553 1
d1557 1
a1557 1
				 absolute_rotate[Z]*180.0);
d1559 1
a1559 1
		      (void)irot(0.0, 0.0, f*180.0);
d1563 3
d1567 1
d1571 1
a1571 1
				 (absolute_rotate[Z])*180.0);
d1573 1
a1573 1
		      (void)irot(0.0, 0.0, (f - absolute_rotate[Z])*180.0);
@


11.50
log
@hacks to use latest libdm
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.49 1996/10/18 14:01:52 bparker Exp $ (BRL)";
d949 47
d1344 2
a1345 2
  if(strstr(argv[0], "iknob"))
    iknob = 1;
d1386 8
a1393 1
  for(argc -= 1, ++argv; argc; --argc, ++argv){
d1491 1
d1496 2
a1497 1
		    (void)irot((f - absolute_rotate[X])*180.0, 0.0, 0.0);
a1498 1
		    absolute_rotate[X] = f;
d1521 1
d1527 1
a1528 1
		    absolute_rotate[Y] = f;
d1551 1
d1557 1
a1558 1
		    absolute_rotate[Z] = f;
@


11.49
log
@remove call to f_load_dv
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.48 1996/10/15 17:50:16 bparker Exp bparker $ (BRL)";
d216 1
a216 1
  if( dmp->dmr_displaylist )  {
d371 1
a371 1
  if( dmp->dmr_displaylist )  {
d413 3
a415 1
      dmp->dmr_colorchange(dmp);
d471 1
a471 1
	dmp->dmr_debug(dmp, regdebug);
d847 1
a847 1
		rt_memfree( &(dmp->dmr_map), sp->s_bytes, (unsigned long)sp->s_addr );
d912 1
a912 1
  attach( dmp->dmr_name );	/* reattach */
d993 4
a996 2
			dmp->dmr_viewchange( dmp, DM_CHGV_DEL, sp );
			rt_memfree( &(dmp->dmr_map), sp->s_bytes, (unsigned long)sp->s_addr );
@


11.48
log
@checkin pjt's mods.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.47 1996/10/09 16:58:39 bparker Exp pjt $ (BRL)";
a405 1
	(void)f_load_dv((ClientData)NULL, interp, 0, NULL);
@


11.47
log
@added parameter to release() call
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.46 1996/10/04 14:58:44 bparker Exp bparker $ (BRL)";
d441 2
a442 1
  bu_vls_printf(&vls, "ndrawn=%d\n", ndrawn);
d1037 2
a1038 1
    bu_vls_printf(&vls, "%s", sp->s_flag == UP ? "VIEW " : "-no- ");
d1041 1
a1041 1
    if( sp->s_iflag == UP )
@


11.46
log
@cast bu_free's 1st argument to genptr_t
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.45 1996/10/03 20:46:00 bparker Exp bparker $ (BRL)";
d961 1
a961 1
    return release(argv[1]);
d963 1
a963 1
  return release(NULL);
@


11.45
log
@free allocated memory after interrupt
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.44 1996/10/01 17:26:29 bparker Exp bparker $ (BRL)";
d816 1
a816 1
    bu_free( (char *)vp, "mged_freemem: struct rt_vlist" );
d1208 2
a1209 2
		bu_free(path_piece[i], "f_ill: char *");
	    bu_free((char *) path_piece, "f_ill: char **");
d1219 2
a1220 2
	    bu_free(path_piece[i], "f_ill: char *");
	bu_free((char *) path_piece, "f_ill: char **");
@


11.44
log
@ignore SIGINT
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.43 1996/09/30 19:48:28 bparker Exp bparker $ (BRL)";
d352 18
a369 4
	register struct directory *dp;
	register int	i;
	double		elapsed_time;
	int		initial_blank_screen;
d371 5
a375 1
	initial_blank_screen = BU_LIST_IS_EMPTY(&HeadSolid.l);
d377 6
a382 9
	/*  First, delete any mention of these objects.
	 *  Silently skip any leading options (which start with minus signs).
	 */
	for( i = 1; i < argc; i++ )  {
		if( (dp = db_lookup( dbip,  argv[i], LOOKUP_QUIET )) != DIR_NULL )  {
			eraseobj( dp );
			no_memory = 0;
		}
	}
d384 21
a404 5
	if( dmp->dmr_displaylist )  {
		/* Force displaylist update before starting new drawing */
	  update_views = 1;
	  refresh();
	}
d406 6
a411 5
	
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);	/* allow interupts */
	else
	  return TCL_OK;
d413 3
a415 4
	nvectors = 0;
	rt_prep_timer();
	drawtrees( argc, argv, kind );
	(void)rt_get_timer( (struct bu_vls *)0, &elapsed_time );
d417 2
a418 2
	{
	  struct bu_vls tmp_vls;
d420 3
a422 36
	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "%ld vectors in %g sec\n", nvectors, elapsed_time);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	{
	  register struct dm_list *p;
	  struct dm_list *save_dm_list;

	  save_dm_list = curr_dm_list;
	  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
	    curr_dm_list = p;

	    /* If we went from blank screen to non-blank, resize */
	    if (mged_variables.autosize  && initial_blank_screen &&
		BU_LIST_NON_EMPTY(&HeadSolid.l)) {
	      size_reset();
	      new_mats();

	      (void)f_load_dv((ClientData)NULL, interp, 0, NULL);
	      MAT_DELTAS_GET(orig_pos, toViewcenter);
	      absolute_zoom = 0.0;
	      VSETALL( absolute_rotate, 0.0 );
	      VSETALL( absolute_slew, 0.0 );
	    }

	    color_soltab();
	    dmp->dmr_colorchange(dmp);
	  }

	  curr_dm_list = save_dm_list;
	}

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
d432 2
a433 1
	int	lvl = 0;
d435 2
a436 7
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;

	if( argc > 1 )  lvl = atoi(argv[1]);

	{
	  struct bu_vls tmp_vls;
d438 1
a438 5
	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "ndrawn=%d\n", ndrawn);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
d440 4
a443 1
	(void)signal( SIGINT, sig2 );	/* allow interupts */
d445 1
a445 1
	pr_schain( &HeadSolid, lvl );
d447 1
a447 1
	return TCL_OK;
d481 1
a481 1
  struct bu_vls tmp_vls;
d486 2
a487 2
  bu_vls_init(&tmp_vls);
  start_catching_output(&tmp_vls);
d498 3
a500 3
  stop_catching_output(&tmp_vls);
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
d515 4
a518 1
  (void)signal( SIGINT, sig2 );	/* allow interupts */
d521 2
d533 1
a533 1
  struct bu_vls tmp_vls;
d535 2
a536 2
  bu_vls_init(&tmp_vls);
  start_catching_output(&tmp_vls);
d547 3
a549 3
  stop_catching_output(&tmp_vls);
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
d725 6
a730 3
	register struct directory *dp;
	register int arg;
	struct bu_vls str;
d732 1
a732 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d734 6
a739 1
	bu_vls_init( &str );
d741 3
a743 4
	(void)signal( SIGINT, sig2 );	/* allow interupts */
	for( arg = 1; arg < argc; arg++ )  {
		if( (dp = db_lookup( dbip, argv[arg], LOOKUP_NOISY )) == DIR_NULL )
			continue;
d745 2
a746 2
		do_list( &str, dp, 99 );	/* very verbose */
	}
d748 2
a749 1
	Tcl_AppendResult(interp, bu_vls_strdup( &str), (char *)NULL);
d751 2
a752 2
	bu_vls_free( &str );
	return TCL_OK;
d764 15
a778 3
	register struct directory *dp;
	register int arg;
	struct bu_vls str;
d780 3
a782 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d784 3
a786 11
	bu_vls_init( &str );
	
	(void)signal( SIGINT, sig2 );	/* allow interupts */
	for( arg = 1; arg < argc; arg++ )  {
		if( (dp = db_lookup( dbip, argv[arg], LOOKUP_NOISY )) == DIR_NULL )
			continue;

		bu_vls_trunc( &str, 0 );
		do_list( &str, dp, 0 );	/* non-verbose */
		Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	}
d788 2
a789 1
	bu_vls_free( &str );
d791 2
a792 1
	return TCL_OK;
d875 1
a875 1
  struct bu_vls tmp_vls;
d880 2
a881 2
  bu_vls_init(&tmp_vls);
  start_catching_output(&tmp_vls);
d895 3
a897 3
  stop_catching_output(&tmp_vls);
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
d1019 15
a1033 12
	register struct solid	*sp;
	register int		i;
	register struct rt_vlist	*vp;
	int			nvlist;
	int			npts;

	FOR_ALL_SOLIDS(sp, &startp->l){
	  Tcl_AppendResult(interp, sp->s_flag == UP ? "VIEW ":"-no- ", (char *)NULL);
	  for( i=0; i <= sp->s_last; i++ )
	    Tcl_AppendResult(interp, "/", sp->s_path[i]->d_namep, (char *)NULL);
	  if( sp->s_iflag == UP )
	    Tcl_AppendResult(interp, " ILLUM", (char *)NULL);
d1035 49
a1083 1
	  Tcl_AppendResult(interp, "\n", (char *)NULL);
d1085 3
a1087 55
	  if( lvl <= 0 )  continue;

	  /* convert to the local unit for printing */
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "  cent=(%.3f,%.3f,%.3f) sz=%g ",
			  sp->s_center[X]*base2local,
			  sp->s_center[Y]*base2local, 
			  sp->s_center[Z]*base2local,
			  sp->s_size*base2local );
	    bu_vls_printf(&tmp_vls, "reg=%d\n",sp->s_regionid );
	    bu_vls_printf(&tmp_vls, "  color=(%d,%d,%d) %d,%d,%d i=%d\n",
			  sp->s_basecolor[0],
			  sp->s_basecolor[1],
			  sp->s_basecolor[2],
			  sp->s_color[0],
			  sp->s_color[1],
			  sp->s_color[2],
			  sp->s_dmindex );
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }

		if( lvl <= 1 )  continue;

		/* Print the actual vector list */
		nvlist = 0;
		npts = 0;
		for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
			register int	i;
			register int	nused = vp->nused;
			register int	*cmd = vp->cmd;
			register point_t *pt = vp->pt;

			RT_CK_VLIST( vp );
			nvlist++;
			npts += nused;
			if( lvl <= 2 )  continue;

			for( i = 0; i < nused; i++,cmd++,pt++ )  {
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, "  %s (%g, %g, %g)\n",
					rt_vlist_cmd_descriptions[*cmd],
					V3ARGS( *pt ) );
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			}
		}

		{
		  struct bu_vls tmp_vls;
d1089 3
a1091 7
		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "  %d vlist structures, %d pts\n", nvlist, npts );
		  bu_vls_printf(&tmp_vls, "  %d pts (via rt_ck_vlist)\n", rt_ck_vlist( &(sp->s_vlist) ) );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
	}
d1664 1
a1664 1
	    struct bu_vls tmp_vls;
d1666 2
a1667 2
	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "\tabs %g %s\n", mged_abs_tol * base2local,
d1669 2
a1670 2
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
d1675 1
a1675 1
	    struct bu_vls tmp_vls;
d1677 4
a1680 4
	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "\trel %g (%g%%)\n", mged_rel_tol, mged_rel_tol * 100.0 );
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
d1687 1
a1687 1
	    struct bu_vls tmp_vls;
d1689 1
a1689 1
	    bu_vls_init(&tmp_vls);
d1696 1
a1696 1
	    bu_vls_printf(&tmp_vls, "\tnorm %g degrees (%d deg %d min %g sec)\n",
d1698 2
a1699 2
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
d1705 1
a1705 1
	    struct bu_vls tmp_vls;
d1707 3
a1709 3
	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls,"Calculational tolerances:\n");
	    bu_vls_printf(&tmp_vls,
d1713 2
a1714 2
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
@


11.43
log
@call color_soltab before call to dmr_colorchange
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.42 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d423 1
@


11.42
log
@now using more generalized solid macros
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.41 1996/09/23 18:36:49 bparker Exp bparker $ (BRL)";
d416 1
@


11.41
log
@use LIBDM permanently
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.40 1996/09/17 21:20:57 bparker Exp bparker $ (BRL)";
d61 1
a61 1
#include "./solid.h"
d308 1
a308 1
	FOR_ALL_SOLIDS( sp )  {
d319 1
a319 1
	if( HeadSolid.s_forw == &HeadSolid )  {
d357 1
a357 1
	initial_blank_screen = (HeadSolid.s_forw == &HeadSolid);
d405 1
a405 1
		HeadSolid.s_forw != &HeadSolid)  {
d791 7
a797 2
	register struct solid		*sp;
	register struct rt_vlist	*vp;
d799 5
a803 9
	while( (sp = FreeSolid) != SOLID_NULL )  {
		FreeSolid = sp->s_forw;
		bu_free( (char *)sp, "mged_freemem: struct solid" );
	}
	while( BU_LIST_NON_EMPTY( &rt_g.rtg_vlfree ) )  {
		vp = BU_LIST_FIRST( rt_vlist, &rt_g.rtg_vlfree );
		BU_LIST_DEQUEUE( &(vp->l) );
		bu_free( (char *)vp, "mged_freemem: struct rt_vlist" );
	}
d829 2
a830 2
	sp=HeadSolid.s_forw;
	while( sp != &HeadSolid )  {
d840 3
a842 3
		nsp = sp->s_forw;
		DEQUEUE_SOLID( sp );
		FREE_SOLID( sp );
d969 3
a971 3
	sp=HeadSolid.s_forw;
	while( sp != &HeadSolid )  {
		nsp = sp->s_forw;
d979 2
a980 2
			DEQUEUE_SOLID( sp );
			FREE_SOLID( sp );
d1011 1
a1011 1
	for( sp = startp->s_forw; sp != startp; sp = sp->s_forw )  {
d1136 1
a1136 1
		FOR_ALL_SOLIDS(sp)
d1162 1
a1162 1
		FOR_ALL_SOLIDS( sp )  {
d1229 1
a1229 1
  if( HeadSolid.s_forw == &HeadSolid )  {
@


11.40
log
@prepare to use libdm
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.39 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d62 2
a63 1
#include "./dm.h"
a64 1
#ifdef USE_LIBDM
a65 3
#endif

#include "../librt/debug.h"	/* XXX */
a415 1
#ifdef USE_LIBDM
a416 3
#else
	    dmp->dmr_colorchange();
#endif
a473 1
#ifdef USE_LIBDM
a474 3
#else
	dmp->dmr_debug(regdebug);
#endif
a975 1
#ifdef USE_LIBDM
a976 3
#else
			dmp->dmr_viewchange( DM_CHGV_DEL, sp );
#endif
@


11.39
log
@rt_list ---> bu_list
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.38 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d64 4
d419 3
d423 1
d481 3
d485 1
d987 3
d991 1
@


11.38
log
@now using libbu
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.37 1996/07/30 21:28:38 bparker Exp bparker $ (BRL)";
d52 1
a55 1
#include "rtstring.h"
d399 1
a399 1
	  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d797 3
a799 3
	while( RT_LIST_NON_EMPTY( &rt_g.rtg_vlfree ) )  {
		vp = RT_LIST_FIRST( rt_vlist, &rt_g.rtg_vlfree );
		RT_LIST_DEQUEUE( &(vp->l) );
d1048 1
a1048 1
		for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
@


11.37
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.36 1996/07/29 15:56:00 bparker Exp bparker $ (BRL)";
d84 1
a84 1
RT_EXTERN(int	edit_com, (int argc, char **argv, int kind, int catch_sigint));
d383 1
a383 1
	(void)rt_get_timer( (struct rt_vls *)0, &elapsed_time );
d386 1
a386 1
	  struct rt_vls tmp_vls;
d388 4
a391 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "%ld vectors in %g sec\n", nvectors, elapsed_time);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d439 1
a439 1
	  struct rt_vls tmp_vls;
d441 4
a444 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "ndrawn=%d\n", ndrawn);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d485 1
a485 1
  struct rt_vls tmp_vls;
d490 1
a490 1
  rt_vls_init(&tmp_vls);
d496 2
a497 2
    rt_printb( "Possible flags", 0xffffffffL, DEBUG_FORMAT );
    rt_log("\n");
d499 2
a500 2
  rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
  rt_log("\n");
d503 2
a504 2
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
d521 1
a521 1
  rt_prmem("Invoked via MGED command");
d532 1
a532 1
  struct rt_vls tmp_vls;
d534 1
a534 1
  rt_vls_init(&tmp_vls);
d540 2
a541 2
    rt_printb( "possible flags", 0xffffffffL, NMG_DEBUG_FORMAT );
    rt_log("\n");
d543 2
a544 2
  rt_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
  rt_log("\n");
d547 2
a548 2
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
d558 1
a558 1
struct rt_vls	*outstrp;
d568 2
a569 2
	struct rt_vls		str;
	rt_vls_init( &str );
d571 1
a571 1
	rt_vls_printf( outstrp, "%s:  ", dp->d_namep );
d583 1
a583 1
		rt_vls_printf( outstrp, "%s (len %d) ", dp->d_namep, 
d586 1
a586 1
			rt_vls_printf( outstrp,
d593 1
a593 1
		rt_vls_strcat( outstrp, "--\n" );
d595 1
a595 1
			rt_vls_printf( outstrp,
d601 1
a601 1
			rt_vls_printf( outstrp,
d609 1
a609 1
				rt_vls_strcat( outstrp, 
d644 1
a644 1
				rt_vls_printf( outstrp, "  %c %s",
d650 1
a650 1
					rt_vls_printf( outstrp, 
d655 1
a655 1
					rt_vls_printf( outstrp, " [%g,%g,%g]",
d661 1
a661 1
					rt_vls_printf( outstrp, " scale %g",
d665 1
a665 1
					rt_vls_printf( outstrp, 
d669 1
a669 1
				rt_vls_printf( outstrp, "\n" );
d673 2
a674 2
				rt_vls_trunc( &str, 0 );
				rt_vls_printf( &str, "%c %s",
d678 1
a678 1
				cp = rt_vls_addr( &str );
d688 2
a689 2
				vls_col_item( outstrp, rt_vls_addr(&str) );
				rt_vls_trunc( &str, 0 );
d707 1
a707 1
	rt_vls_vlscat( outstrp, &str );
d712 1
a712 1
	rt_vls_free( &str );
d726 1
a726 1
	struct rt_vls str;
d731 1
a731 1
	rt_vls_init( &str );
d741 1
a741 1
	Tcl_AppendResult(interp, rt_vls_strdup( &str), (char *)NULL);
d743 1
a743 1
	rt_vls_free( &str );
d758 1
a758 1
	struct rt_vls str;
d763 1
a763 1
	rt_vls_init( &str );
d770 1
a770 1
		rt_vls_trunc( &str, 0 );
d772 1
a772 1
		Tcl_AppendResult(interp, rt_vls_addr(&str), (char *)NULL);
d775 1
a775 1
	rt_vls_free( &str );
d782 1
a782 1
 *  lurking on their respective freelists, back to rt_malloc().
d795 1
a795 1
		rt_free( (char *)sp, "mged_freemem: struct solid" );
d800 1
a800 1
		rt_free( (char *)vp, "mged_freemem: struct rt_vlist" );
d859 1
a859 1
  struct rt_vls tmp_vls;
d864 1
a864 1
  rt_vls_init(&tmp_vls);
d867 3
a869 3
  rt_log("STATE=%s, ", state_str[state] );
  rt_log("Viewscale=%f (%f mm)\n", Viewscale*base2local, Viewscale);
  rt_log("base2local=%f\n", base2local);
d880 2
a881 2
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
d1022 1
a1022 1
	    struct rt_vls tmp_vls;
d1024 2
a1025 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "  cent=(%.3f,%.3f,%.3f) sz=%g ",
d1030 2
a1031 2
	    rt_vls_printf(&tmp_vls, "reg=%d\n",sp->s_regionid );
	    rt_vls_printf(&tmp_vls, "  color=(%d,%d,%d) %d,%d,%d i=%d\n",
d1039 2
a1040 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d1060 1
a1060 1
			  struct rt_vls tmp_vls;
d1062 2
a1063 2
			  rt_vls_init(&tmp_vls);
			  rt_vls_printf(&tmp_vls, "  %s (%g, %g, %g)\n",
d1066 2
a1067 2
			  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			  rt_vls_free(&tmp_vls);
d1072 1
a1072 1
		  struct rt_vls tmp_vls;
d1074 5
a1078 5
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "  %d vlist structures, %d pts\n", nvlist, npts );
		  rt_vls_printf(&tmp_vls, "  %d pts (via rt_ck_vlist)\n", rt_ck_vlist( &(sp->s_vlist) ) );
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d1197 2
a1198 2
		rt_free(path_piece[i], "f_ill: char *");
	    rt_free((char *) path_piece, "f_ill: char **");
d1208 2
a1209 2
	    rt_free(path_piece[i], "f_ill: char *");
	rt_free((char *) path_piece, "f_ill: char **");
d1286 1
a1286 1
    struct rt_vls vls;
d1288 1
a1288 1
    rt_vls_init(&vls);
d1291 7
a1297 7
      rt_vls_printf(&vls, "x = %f\n", rate_rotate[X]);
      rt_vls_printf(&vls, "y = %f\n", rate_rotate[Y]);
      rt_vls_printf(&vls, "z = %f\n", rate_rotate[Z]);
      rt_vls_printf(&vls, "S = %f\n", rate_zoom);
      rt_vls_printf(&vls, "X = %f\n", rate_slew[X]);
      rt_vls_printf(&vls, "Y = %f\n", rate_slew[Y]);
      rt_vls_printf(&vls, "Z = %f\n", rate_slew[Z]);
d1299 7
a1305 7
      rt_vls_printf(&vls, "ax = %f\n", absolute_rotate[X]);
      rt_vls_printf(&vls, "ay = %f\n", absolute_rotate[Y]);
      rt_vls_printf(&vls, "az = %f\n", absolute_rotate[Z]);
      rt_vls_printf(&vls, "aS = %f\n", absolute_zoom);
      rt_vls_printf(&vls, "aX = %f\n", absolute_slew[X]);
      rt_vls_printf(&vls, "aY = %f\n", absolute_slew[Y]);
      rt_vls_printf(&vls, "aZ = %f\n", absolute_slew[Z]);
d1309 5
a1313 5
      rt_vls_printf(&vls, "xadc = %d\n", dv_xadc);
      rt_vls_printf(&vls, "yadc = %d\n", dv_yadc);
      rt_vls_printf(&vls, "ang1 = %d\n", dv_1adc);
      rt_vls_printf(&vls, "ang2 = %d\n", dv_2adc);
      rt_vls_printf(&vls, "distadc = %d\n", dv_distadc);
d1316 2
a1317 2
    Tcl_AppendResult(interp, rt_vls_addr(&vls), (char *)NULL);
    rt_vls_free(&vls);
d1405 1
a1405 1
    struct rt_vls cmd_vls;
d1653 1
a1653 1
	    struct rt_vls tmp_vls;
d1655 2
a1656 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "\tabs %g %s\n", mged_abs_tol * base2local,
d1658 2
a1659 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d1664 1
a1664 1
	    struct rt_vls tmp_vls;
d1666 4
a1669 4
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "\trel %g (%g%%)\n", mged_rel_tol, mged_rel_tol * 100.0 );
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d1676 1
a1676 1
	    struct rt_vls tmp_vls;
d1678 1
a1678 1
	    rt_vls_init(&tmp_vls);
d1685 1
a1685 1
	    rt_vls_printf(&tmp_vls, "\tnorm %g degrees (%d deg %d min %g sec)\n",
d1687 2
a1688 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d1694 1
a1694 1
	    struct rt_vls tmp_vls;
d1696 3
a1698 3
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls,"Calculational tolerances:\n");
	    rt_vls_printf(&tmp_vls,
d1702 2
a1703 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d1956 1
a1956 1
    result = (char **) rt_malloc((nm_constituents + 1) * sizeof(char *),
d1966 1
a1966 1
	result[i] = (char *) rt_malloc((pp - start_addr + 1) * sizeof(char),
@


11.36
log
@made this change in response to the bug fix in f_adc
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.35 1996/07/25 18:55:20 bparker Exp bparker $ (BRL)";
d1781 1
a1781 1
    if(absolute_zoom > 0)
d1784 1
a1784 1
    else/* negative */
a1822 13
#if 1
	if( Viewscale < SMALL_FASTF ){
	  if(val > 1.0)
	    Viewscale = SMALL_FASTF * val;
	  else
	    Viewscale = SMALL_FASTF;
	}else if( Viewscale > INFINITY ){
	  if(val < 1.0)
	    Viewscale = val * INFINITY;
	  else
	    Viewscale = INFINITY;
	}
#else
a1824 1
#endif
@


11.35
log
@reload default views when going from blank
screen to non-blank
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.34 1996/07/15 20:37:44 bparker Exp bparker $ (BRL)";
d70 4
d1603 1
a1603 1
	  sprintf(sval, "%f", ((double)i/2047.0 + 1.0)*Viewscale * base2local * M_SQRT2);
@


11.34
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.33 1996/06/28 20:53:50 bparker Exp bparker $ (BRL)";
d404 1
d406 2
@


11.33
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.32 1996/06/25 20:58:00 bparker Exp bparker $ (BRL)";
d200 1
a200 1
  char *av[] = {"Z", (char *)NULL};
d202 3
d1320 5
a1324 1
      char	*av[] = {"adc", "reset", (char *)NULL};
d1524 1
a1524 1
	  char    *av[] = {NULL, "x", NULL, NULL};
d1527 3
d1539 1
a1539 1
	  char    *av[] = {NULL, "y", NULL, NULL};
d1542 3
d1554 1
a1554 1
	  char    *av[] = {NULL, "a1", NULL, NULL};
d1557 3
d1569 1
a1569 1
	  char    *av[] = {NULL, "a2", NULL, NULL};
d1572 3
d1584 1
a1584 1
	  char    *av[] = {NULL, "dst", NULL, NULL};
d1587 3
d1763 5
a1767 1
  char *av[] = {"zoom", "1", NULL};
@


11.32
log
@modified f_zoom to update absolute_zoom
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.31 1996/06/21 15:54:36 bparker Exp bparker $ (BRL)";
a1254 1
#if 1
a1595 298
#else
/* Main processing of a knob twist.  "knob id val" */
int
f_knob(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  int	i;
  fastf_t f;
  char	*cmd = argv[1];
  static int aslewflag = 0;
  vect_t	aslew;
  int iknob = 0;

  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  if(strstr(argv[0], "iknob"))
    iknob = 1;

  if(argc == 2)  {
    i = 0;
    f = 0;
  } else {
    i = atoi(argv[2]);
    f = atof(argv[2]);
    if( f < -1.0 )
      f = -1.0;
    else if( f > 1.0 )
      f = 1.0;
  }
  if( cmd[1] == '\0' )  {
    switch( cmd[0] )  {
    case 'x':
      if(iknob)
	rate_rotate[X] += f;
      else
	rate_rotate[X] = f;
      break;
    case 'y':
      if(iknob)
	rate_rotate[Y] += f;
      else
	rate_rotate[Y] = f;
      break;
    case 'z':
      if(iknob)
	rate_rotate[Z] += f;
      else
	rate_rotate[Z] = f;
      break;
    case 'X':
      if(iknob)
	rate_slew[X] += f;
      else
	rate_slew[X] = f;
      break;
    case 'Y':
      if(iknob)
	rate_slew[Y] += f;
      else
	rate_slew[Y] = f;
      break;
    case 'Z':
      if(iknob)
	rate_slew[Z] += f;
      else
	rate_slew[Z] = f;
      break;
    case 'S':
      if(iknob)
	rate_zoom += f;
      else
	rate_zoom = f;
      break;
    default:
      goto usage;
    }
  } else if( cmd[0] == 'a' && cmd[1] != '\0' && cmd[2] == '\0' ) {
    struct rt_vls cmd_vls;

		switch( cmd[1] ) {
		case 'x':
		  if(iknob){
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
		      absolute_rotate[X] += f;
		      (void)irot(absolute_rotate[X]*180.0,
				 absolute_rotate[Y]*180.0,
				 absolute_rotate[Z]*180.0);
		    }else {
		      (void)irot(f*180.0, 0.0, 0.0);
		      absolute_rotate[X] += f;
		    }
		  }else{
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
		      (void)irot((absolute_rotate[X])*180.0,
				 absolute_rotate[Y]*180.0,
				 absolute_rotate[Z]*180.0);
		    }else {
		    (void)irot((f - absolute_rotate[X])*180.0, 0.0, 0.0);
		    }
		    absolute_rotate[X] = f;
		  }

		  /* wrap around */
		  if(absolute_rotate[X] < -1.0)
		    absolute_rotate[X] = absolute_rotate[X] + 2.0;
		  else if(absolute_rotate[X] > 1.0)
		    absolute_rotate[X] = absolute_rotate[X] - 2.0;

		  break;
		case 'y':
		  if(iknob){
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
		      absolute_rotate[Y] += f;
		      (void)irot(absolute_rotate[X]*180.0,
				 absolute_rotate[Y]*180.0,
				 absolute_rotate[Z]*180.0);
		    }else {
		      (void)irot(0.0, f*180.0, 0.0);
		      absolute_rotate[Y] += f;
		    }
		  }else{
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
		      (void)irot(absolute_rotate[X]*180.0,
				 (absolute_rotate[Y])*180.0,
				 absolute_rotate[Z]*180.0);
		    }else {
		      (void)irot(0.0, (f - absolute_rotate[Y])*180.0, 0.0);
		    }
		    absolute_rotate[Y] = f;
		  }

		  /* wrap around */
		  if(absolute_rotate[Y] < -1.0)
		    absolute_rotate[Y] = absolute_rotate[Y] + 2.0;
		  else if(absolute_rotate[Y] > 1.0)
		    absolute_rotate[Y] = absolute_rotate[Y] - 2.0;

		  break;
		case 'z':
		  if(iknob){
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
		      absolute_rotate[Z] += f;
		      (void)irot(absolute_rotate[X]*180.0,
				 absolute_rotate[Y]*180.0,
				 absolute_rotate[Z]*180.0);
		    }else {
		      (void)irot(0.0, 0.0, f*180.0);
		      absolute_rotate[Z] += f;
		    }
		  }else{
		    if((state == ST_S_EDIT || state == ST_O_EDIT) && EDIT_ROTATE){
		      (void)irot(absolute_rotate[X]*180.0,
				 absolute_rotate[Y]*180.0,
				 (absolute_rotate[Z])*180.0);
		    }else {
		      (void)irot(0.0, 0.0, (f - absolute_rotate[Z])*180.0);
		    }
		    absolute_rotate[Z] = f;
		  }

		  /* wrap around */
		  if(absolute_rotate[Z] < -1.0)
		    absolute_rotate[Z] = absolute_rotate[Z] + 2.0;
		  else if(absolute_rotate[Z] > 1.0)
		    absolute_rotate[Z] = absolute_rotate[Z] - 2.0;

		  break;
		case 'X':
		  if(iknob)
		    absolute_slew[X] += f;
		  else
		    absolute_slew[X] = f;

		  (void)tran( absolute_slew );
		  break;
		case 'Y':
		  if(iknob)
		    absolute_slew[Y] += f;
		  else
		    absolute_slew[Y] = f;

		  (void)tran( absolute_slew );
		  break;
		case 'Z':
		  if(iknob)
		    absolute_slew[Z] += f;
		  else
		    absolute_slew[Z] = f;

		  (void)tran( absolute_slew );
		  break;
		case 'S':
		  if(iknob)
		    absolute_zoom += f;
		  else
		    absolute_zoom = f;

		  abs_zoom();
		  break;
		default:
			goto usage;
		}
	} else if( strcmp( cmd, "calibrate" ) == 0 ) {
		VSETALL( absolute_slew, 0.0 );
		return TCL_OK;
	} else if( strcmp( cmd, "xadc" ) == 0 )  {
	  char    *av[] = {NULL, "x", NULL, NULL};
	  char    sval[32];

	  if(iknob)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";

	  av[2] = sval;
	  sprintf(sval, "%d", i);
	  (void)f_adc(clientData, interp, 3, av);
	} else if( strcmp( cmd, "yadc" ) == 0 )  {
	  char    *av[] = {NULL, "y", NULL, NULL};
	  char    sval[32];

	  if(iknob)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";

	  av[2] = sval;
	  sprintf(sval, "%d", i);
	  (void)f_adc(clientData, interp, 3, av);
	} else if( strcmp( cmd, "ang1" ) == 0 )  {
	  char    *av[] = {NULL, "a1", NULL, NULL};
	  char    sval[32];

	  if(iknob)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";

	  av[2] = sval;
	  sprintf(sval, "%f", 45.0*(1.0-(double)i/2047.0));
	  (void)f_adc(clientData, interp, 3, av);
	} else if( strcmp( cmd, "ang2" ) == 0 )  {
	  char    *av[] = {NULL, "a2", NULL, NULL};
	  char    sval[32];

	  if(iknob)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";

	  av[2] = sval;
	  sprintf(sval, "%f", 45.0*(1.0-(double)i/2047.0));
	  (void)f_adc(clientData, interp, 3, av);
	} else if( strcmp( cmd, "distadc" ) == 0 )  {
	  char    *av[] = {NULL, "dst", NULL, NULL};
	  char    sval[32];

	  if(iknob)
	    av[0] = "iadc";
	  else
	    av[0] = "adc";

	  av[2] = sval;
	  sprintf(sval, "%f", ((double)i/2047.0 + 1.0)*Viewscale * base2local * M_SQRT2);
	  (void)f_adc(clientData, interp, 3, av);
	} else if( strcmp( cmd, "zap" ) == 0 || strcmp( cmd, "zero" ) == 0 )  {
		char	*av[] = {"adc", "reset", (char *)NULL};

		VSETALL( rate_rotate, 0 );
		VSETALL( rate_slew, 0 );
#if 0
		VSETALL( absolute_rotate, 0 );
		VSETALL( absolute_slew, 0 );
#endif
		rate_zoom = 0;
		
		(void)f_adc( clientData, interp, 2, av );

		if(knob_offset_hook)
		  knob_offset_hook();
	} else {
usage:
	  Tcl_AppendResult(interp,
		"knob: x,y,z for rotation, S for scale, X,Y,Z for slew (rates, range -1..+1)\n",
		"knob: ax,ay,az for absolute rotation, aS for absolute scale,\n",
		"knob: aX,aY,aZ for absolute skew.  calibrate to set current slew to 0\n",
		"knob: xadc, yadc, zadc, ang1, ang2, distadc (values, range -2048..+2047)\n",
		"knob: zero (cancel motion)\n", (char *)NULL);
	}

	check_nonzero_rates();
	return TCL_OK;
}
#endif
@


11.31
log
@added abs_zoom and modified f_knob to handled multiple commands
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.30 1996/05/31 22:31:20 bparker Exp bparker $ (BRL)";
d1326 2
a1327 2
      if(knob_offset_hook)
	knob_offset_hook();
d2088 14
d2104 1
d2108 4
@


11.30
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.29 1996/05/24 18:33:29 bparker Exp bparker $ (BRL)";
d75 1
d328 2
d1255 343
a1774 1

a1782 1

a1790 1

d1793 6
d1871 1
d1874 1
d1894 1
d2035 23
@


11.29
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.28 1996/05/16 20:59:26 bparker Exp bparker $ (BRL)";
d1337 9
a1345 2
		    (void)irot(f*180.0, 0.0, 0.0);
		    absolute_rotate[X] += f;
d1347 5
d1353 1
d1366 9
a1374 2
		    (void)irot(0.0, f*180.0, 0.0);
		    absolute_rotate[Y] += f;
d1376 7
a1382 1
		    (void)irot(0.0, (f - absolute_rotate[Y])*180.0, 0.0);
d1395 9
a1403 2
		    (void)irot(0.0, 0.0, f*180.0);
		    absolute_rotate[Z] += f;
d1405 7
a1411 1
		    (void)irot(0.0, 0.0, (f - absolute_rotate[Z])*180.0);
@


11.28
log
@modifying sliders
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.27 1996/05/13 20:47:40 bparker Exp bparker $ (BRL)";
a79 1
int		f_zap();
a146 6
	if(!rot_set){
          rot_x += atof(argv[1]);
          rot_y += atof(argv[2]);
          rot_z += atof(argv[3]);
        }

d399 1
a399 3
	      tran_x = 0.0;
	      tran_y = 0.0;
	      tran_z = 0.0;
d1260 6
a1265 7
	int	i;
	fastf_t	f;
	char	*cmd = argv[1];
	static int aslewflag = 0;
	vect_t	aslew;

  int iknob;
a1271 2
  else
    iknob = 0;
d1332 2
d1336 13
a1348 1
			VSETALL(rate_rotate, 0);
d1350 1
a1350 7
			if(iknob)
			  absolute_rotate[X] += f;
			else
			  absolute_rotate[X] = f;

			absview_v( absolute_rotate );
			break;
d1352 13
a1364 6
			VSETALL(rate_rotate, 0);

			if(iknob)
			  absolute_rotate[Y] += f;
			else
			  absolute_rotate[Y] = f;
d1366 1
a1366 2
			absview_v( absolute_rotate );
			break;
d1368 13
a1380 6
			VSETALL(rate_rotate, 0);

			if(iknob)
			  absolute_rotate[Z] += f;
			else
			  absolute_rotate[Z] = f;
d1382 1
a1382 2
			absview_v( absolute_rotate );
			break;
d1384 4
a1387 4
			aslew[X] = f - absolute_slew[X];
			aslew[Y] = absolute_slew[Y];
			aslew[Z] = absolute_slew[Z];
			slewview( aslew );
d1389 1
a1389 4
			if(iknob)
			  absolute_slew[X] += f;
			else
			  absolute_slew[X] = f;
d1391 1
a1391 1
			break;
d1393 4
a1396 4
			aslew[X] = absolute_slew[X];
			aslew[Y] = f - absolute_slew[Y];
			aslew[Z] = absolute_slew[Z];
			slewview( aslew );
d1398 1
a1398 4
			if(iknob)
			  absolute_slew[Y] += f;
			else
			  absolute_slew[Y] = f;
d1400 1
a1400 1
			break;
d1402 6
a1407 4
			aslew[X] = absolute_slew[X];
			aslew[Y] = absolute_slew[Y];
			aslew[Z] = f - absolute_slew[Z];
			slewview( aslew );
d1409 1
a1409 5
			if(iknob)
			  absolute_slew[Z] += f;
			else
			  absolute_slew[Z] = f;
			break;
d1411 1
a1411 1
			break;
d1419 11
a1429 2
		rt_vls_printf( &dm_values.dv_string, "adc x %d\n" , i );
		return TCL_OK;
d1431 11
a1441 2
		rt_vls_printf( &dm_values.dv_string, "adc y %d\n" , i );
		return TCL_OK;
d1443 11
a1453 2
		rt_vls_printf( &dm_values.dv_string, "adc a1 %f\n", 45.0*(1.0-(double)i/2047.0) );
		return TCL_OK;
d1455 11
a1465 2
		rt_vls_printf( &dm_values.dv_string, "adc a2 %f\n", 45.0*(1.0-(double)i/2047.0) );
		return TCL_OK;
d1467 11
a1477 3
		rt_vls_printf( &dm_values.dv_string, "adc dst %f\n",
			((double)i/2047.0 + 1.0)*Viewscale * base2local * M_SQRT2 );
		return TCL_OK;
d1483 2
d1681 3
a1683 3
	  tran_x *= val;
	  tran_y *= val;
	  tran_z *= val;
d1690 1
a1690 3
	  tran_x = new_pos[X];
	  tran_y = new_pos[Y];
	  tran_z = new_pos[Z];
@


11.27
log
@modify f_vrot to always allow vrot
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.26 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d1239 6
a1244 1
#define RATE_TOL 0.0001
d1246 4
a1249 4
  if(-RATE_TOL < rate_rotate[X] && rate_rotate[X] < RATE_TOL &&
     -RATE_TOL < rate_rotate[Y] && rate_rotate[Y] < RATE_TOL &&
     -RATE_TOL < rate_rotate[Z] && rate_rotate[Z] < RATE_TOL)
    rateflag_rotate = 0;
d1251 1
a1251 1
    rateflag_rotate = 1;
d1253 2
a1254 4
  if(-RATE_TOL < rate_slew[X] && rate_slew[X] < RATE_TOL &&
     -RATE_TOL < rate_slew[Y] && rate_slew[Y] < RATE_TOL &&
     -RATE_TOL < rate_slew[Z] && rate_slew[Z] < RATE_TOL)
    rateflag_slew = 0;
a1255 3
    rateflag_slew = 1;

  if(-RATE_TOL < rate_zoom && rate_zoom < RATE_TOL)
a1256 2
  else
    rateflag_zoom = 1;
@


11.26
log
@Still Tcl'ing the code
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.25 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d70 1
a70 2
#if 0
#endif
d136 2
d141 1
d146 1
d154 13
d170 1
@


11.25
log
@still tcl-converting
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.24 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d354 5
a358 2
	if( catch_sigint )
		(void)signal( SIGINT, sig2 );	/* allow interupts after here */
d1222 20
a1241 16
	if( rate_rotate[X] != 0.0 ||
	    rate_rotate[Y] != 0.0 ||
	    rate_rotate[Z] != 0.0 )  {
	    	rateflag_rotate = 1;
	} else {
		rateflag_rotate = 0;
	}
	if( rate_slew[X] != 0.0 ||
	    rate_slew[Y] != 0.0 ||
	    rate_slew[Z] != 0.0 )  {
	    	rateflag_slew = 1;
	} else {
		rateflag_slew = 0;
	}
	if( rate_zoom != 0.0 )  {
		rateflag_zoom = 1;
d1243 1
a1243 4
	} else {
		rateflag_zoom = 0;
	}
	dmaflag = 1;	/* values changed so update faceplate */
d1259 1
a1259 1
#if 1
d1265 1
a1265 1
  if(!strcmp(argv[0], "iknob"))
a1393 81
#else
	if( !aslewflag ) {
		VSETALL( absolute_slew, 0.0 );
		aslewflag = 1;
	}

	if(argc == 2)  {
		i = 0;
		f = 0;
	} else {
		i = atoi(argv[2]);
		f = atof(argv[2]);
		if( f < -1.0 )
			f = -1.0;
		else if( f > 1.0 )
			f = 1.0;
	}
	if( cmd[1] == '\0' )  {
		switch( cmd[0] )  {
		case 'x':
			rate_rotate[X] = f;
			break;
		case 'y':
			rate_rotate[Y] = f;
			break;
		case 'z':
			rate_rotate[Z] = f;
			break;
		case 'X':
			rate_slew[X] = f;
			break;
		case 'Y':
			rate_slew[Y] = f;
			break;
		case 'Z':
			rate_slew[Z] = f;
			break;
		case 'S':
			rate_zoom = f;
			break;
		default:
			goto usage;
		}
	} else if( cmd[0] == 'a' && cmd[1] != '\0' && cmd[2] == '\0' ) {
		switch( cmd[1] ) {
		case 'x':
			VSETALL(rate_rotate, 0);
			absolute_rotate[X] = f;
			absview_v( absolute_rotate );
			break;
		case 'y':
			VSETALL(rate_rotate, 0);
			absolute_rotate[Y] = f;
			absview_v( absolute_rotate );
			break;
		case 'z':
			VSETALL(rate_rotate, 0);
			absolute_rotate[Z] = f;
			absview_v( absolute_rotate );
			break;
		case 'X':
			aslew[X] = f - absolute_slew[X];
			aslew[Y] = absolute_slew[Y];
			aslew[Z] = absolute_slew[Z];
			slewview( aslew );
			absolute_slew[X] = f;
			break;
		case 'Y':
			aslew[X] = absolute_slew[X];
			aslew[Y] = f - absolute_slew[Y];
			aslew[Z] = absolute_slew[Z];
			slewview( aslew );
			absolute_slew[Y] = f;
			break;
		case 'Z':
			aslew[X] = absolute_slew[X];
			aslew[Y] = absolute_slew[Y];
			aslew[Z] = f - absolute_slew[Z];
			slewview( aslew );
			absolute_slew[Z] = f;
#endif
@


11.24
log
@convert commands to Tcl
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.23 1996/03/22 18:35:38 bparker Exp bparker $ (BRL)";
d189 1
d194 1
a194 1
  if (f_zap(clientData, interp, argc, argv) == TCL_ERROR)
a909 14
#if 0
int
f_attach(argc, argv)
int	argc;
char	**argv;
{
  if (argc == 1)
    get_attached();
  else
    attach( argv[1] );
  return CMD_OK;
}
#endif

d921 1
a921 3
    release(argv[1]);
  else
    release(NULL);
d923 1
a923 1
  return TCL_OK;
d1211 2
d1497 1
a1497 1
		char	*av[3];
a1502 3
		av[0] = "adc";
		av[1] = "reset";
		av[2] = (char *)NULL;
@


11.23
log
@cleanup
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.22 1996/03/08 18:30:24 bparker Exp bparker $ (BRL)";
a82 2


d86 3
a88 1
f_delobj(argc, argv)
d95 3
d106 1
a106 1
	return CMD_OK;
d112 3
a114 1
f_center(argc, argv)
d118 8
a125 5
	/* must convert from the local unit to the base unit */
	toViewcenter[MDX] = -atof( argv[1] ) * local2base;
	toViewcenter[MDY] = -atof( argv[2] ) * local2base;
	toViewcenter[MDZ] = -atof( argv[3] ) * local2base;
	new_mats();
d127 1
a127 1
	return CMD_OK;
d131 3
a133 1
f_vrot(argc, argv)
d137 3
d143 1
a143 1
		return CMD_BAD;
d155 1
a155 1
	return CMD_OK;
d161 3
a163 1
f_view(argc, argv)
d168 4
d177 1
a177 1
	return CMD_OK;
d183 3
a185 1
f_blast(argc, argv)
d190 2
a191 1
	if (f_zap(argc, argv) == CMD_BAD) return CMD_BAD;
d193 11
a203 8
	if( dmp->dmr_displaylist )  {
		/*
		 * Force out the control list with NO solids being drawn,
		 * then the display processor will not mind when we start
		 * writing new subroutines out there...
		 */
		refresh();
	}
d205 1
a205 1
	return edit_com( argc, argv, 1, 1 );
d211 3
a213 1
f_edit(argc, argv)
d217 4
a220 1
        update_views = 1;
d222 1
a222 1
	return edit_com( argc, argv, 1, 1 );
d227 3
a229 1
f_ev(argc, argv)
d233 4
a236 1
        update_views = 1;
d238 1
a238 1
	return edit_com( argc, argv, 3, 1 );
d254 3
a256 1
f_evedit(argc, argv)
d260 4
a263 1
        update_views = 1
d265 1
a265 1
	return edit_com( argc, argv, 2, 1 );
d360 3
a362 1
	rt_log("%ld vectors in %g sec\n", nvectors, elapsed_time );
d364 6
d396 1
a396 1
	return CMD_OK;
d400 3
a402 1
f_debug( argc, argv )
d408 3
d413 9
a421 1
	rt_log("ndrawn=%d\n", ndrawn);
d426 1
a426 1
	return CMD_OK;
d430 3
a432 1
f_regdebug(argc, argv)
d438 4
a441 1
	if( argc <= 1 )
d445 3
a447 1
	rt_log("regdebug=%d\n", regdebug);
d450 1
a450 1
	return CMD_OK;
d454 3
a456 1
f_debuglib(argc, argv)
d460 20
a479 8
	if( argc >= 2 )  {
		sscanf( argv[1], "%x", &rt_g.debug );
	} else {
		rt_printb( "Possible flags", 0xffffffffL, DEBUG_FORMAT );
		rt_log("\n");
	}
	rt_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
	rt_log("\n");
d481 1
a481 1
	return CMD_OK;
d485 3
a487 1
f_debugmem( argc, argv )
d491 4
a494 1
	(void)signal( SIGINT, sig2 );	/* allow interupts */
d496 2
a497 2
	rt_prmem("Invoked via MGED command");
	return CMD_OK;
d501 3
a503 1
f_debugnmg(argc, argv)
d507 17
a523 8
	if( argc >= 2 )  {
		sscanf( argv[1], "%x", &rt_g.NMG_debug );
	} else {
		rt_printb( "possible flags", 0xffffffffL, NMG_DEBUG_FORMAT );
		rt_log("\n");
	}
	rt_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
	rt_log("\n");
d525 1
a525 1
	return CMD_OK;
d549 3
a551 2
		rt_log("db_get_external(%s) failure\n", dp->d_namep);
		return;
d674 2
a675 2
		rt_log("%s: database import error\n", dp->d_namep);
		goto out;
d680 1
a680 1
		rt_log("%s: describe error\n", dp->d_namep);
d703 2
d716 1
a716 1
	Tcl_SetResult(interp, rt_vls_strdup( &str), TCL_DYNAMIC);
d725 3
a727 1
f_cat( argc, argv )
d735 3
d747 1
a747 1
		rt_log( "%s", rt_vls_addr(&str) );
d752 1
a752 1
	return CMD_OK;
d782 3
a784 1
f_zap(argc, argv)
d792 3
d809 1
a809 1
				rt_log("f_zap: db_dirdelete failed\n");
d824 1
a824 1
	return CMD_OK;
d828 3
a830 1
f_status(argc, argv)
d834 19
a852 11
	rt_log("STATE=%s, ", state_str[state] );
	rt_log("Viewscale=%f (%f mm)\n", Viewscale*base2local, Viewscale);
	rt_log("base2local=%f\n", base2local);
	mat_print("toViewcenter", toViewcenter);
	mat_print("Viewrot", Viewrot);
	mat_print("model2view", model2view);
	mat_print("view2model", view2model);
	if( state != ST_VIEW )  {
		mat_print("model2objview", model2objview);
		mat_print("objview2model", objview2model);
	}
d854 4
a857 1
	return CMD_OK;
d862 3
a864 1
f_fix(argc, argv)
d868 10
a877 3
	attach( dmp->dmr_name );	/* reattach */
	dmaflag = 1;		/* causes refresh() */
	return CMD_OK;
d881 3
a883 1
f_refresh(argc, argv)
d887 3
d891 1
a891 1
	return CMD_OK;
d896 3
a898 1
f_aeview(argc, argv)
d902 5
a906 2
	setview( 270.0 + atof(argv[2]), 0.0, 270.0 - atof(argv[1]) );
	return CMD_OK;
d909 1
d915 5
a919 5
	if (argc == 1)
		get_attached();
	else
		attach( argv[1] );
	return CMD_OK;
d921 1
d924 3
a926 1
f_release(argc, argv)
d930 3
d938 1
a938 1
  return CMD_OK;
d977 1
a977 1
			rt_log("eraseobj: db_dirdelete failed\n");
d1001 32
a1032 24
		rt_log( sp->s_flag == UP ? "VIEW ":"-no- " );
		for( i=0; i <= sp->s_last; i++ )
			rt_log("/%s", sp->s_path[i]->d_namep);
		if( sp->s_iflag == UP )
			rt_log(" ILLUM");
		rt_log("\n");

		if( lvl <= 0 )  continue;

		/* convert to the local unit for printing */
		rt_log("  cent=(%.3f,%.3f,%.3f) sz=%g ",
			sp->s_center[X]*base2local,
			sp->s_center[Y]*base2local, 
			sp->s_center[Z]*base2local,
			sp->s_size*base2local );
		rt_log("reg=%d\n",sp->s_regionid );
		rt_log("  color=(%d,%d,%d) %d,%d,%d i=%d\n",
			sp->s_basecolor[0],
			sp->s_basecolor[1],
			sp->s_basecolor[2],
			sp->s_color[0],
			sp->s_color[1],
			sp->s_color[2],
			sp->s_dmindex );
d1051 4
a1054 1
				rt_log("  %s (%g, %g, %g)\n",
d1057 2
d1061 3
a1063 1
		rt_log("  %d vlist structures, %d pts\n", nvlist, npts );
d1065 6
a1070 1
		rt_log("  %d pts (via rt_ck_vlist)\n", rt_ck_vlist( &(sp->s_vlist) ) );
d1078 3
a1080 1
f_ill(argc, argv)
d1094 3
d1105 2
a1106 2
		(void) rt_log("Bad solid path: '%s'\n", argv[1]);
		goto bail_out;
d1122 2
a1123 2
		    (void) rt_log("%s is not a solid\n", basename);
		    goto bail_out;
d1167 2
a1168 2
		(void) rt_log("%s not being displayed\n", argv[1]);
		goto bail_out;
d1171 2
a1172 2
		(void) rt_log("%s multiply referenced\n", argv[1]);
		goto bail_out;
d1191 1
a1191 1
	return CMD_OK;
d1202 1
a1202 1
    return CMD_BAD;
d1207 3
a1209 1
f_sed(argc, argv)
d1213 9
a1221 6
	if( not_state( ST_VIEW, "keyboard solid edit start") )
		return CMD_BAD;
	if( HeadSolid.s_forw == &HeadSolid )  {
		(void)rt_log("no solids being displayed\n");
		return CMD_BAD;
	}
d1223 1
a1223 1
	update_views = 1;
d1225 2
a1226 2
	button(BE_S_ILLUMINATE);	/* To ST_S_PICK */
	return f_ill(argc, argv);	/* Illuminate named solid --> ST_S_EDIT */
d1257 3
a1259 1
f_knob(argc, argv)
d1271 3
d1492 1
a1492 1
		return CMD_OK;
d1495 1
a1495 1
		return CMD_OK;
d1498 1
a1498 1
		return CMD_OK;
d1501 1
a1501 1
		return CMD_OK;
d1504 1
a1504 1
		return CMD_OK;
d1508 1
a1508 1
		return CMD_OK;
d1519 1
a1519 1
		(void)f_adc( 2, av );
d1525 6
a1530 5
		rt_log("knob: x,y,z for rotation, S for scale, X,Y,Z for slew (rates, range -1..+1)\n");
		rt_log("knob: ax,ay,az for absolute rotation, aS for absolute scale,\n");
		rt_log("knob: aX,aY,aZ for absolute skew.  calibrate to set current slew to 0\n");
		rt_log("knob: xadc, yadc, zadc, ang1, ang2, distadc (values, range -2048..+2047)\n");
		rt_log("knob: zero (cancel motion)\n");
d1534 1
a1534 1
	return CMD_OK;
d1548 3
a1550 1
f_tol( argc, argv )
d1557 3
d1561 57
a1617 36
		rt_log("Current tolerance settings are:\n");
		rt_log( "Tesselation tolerances:\n" );
		if( mged_abs_tol > 0.0 )  {
			rt_log("\tabs %g %s\n",
				mged_abs_tol * base2local,
				rt_units_string(dbip->dbi_local2base) );
		} else {
			rt_log("\tabs None\n");
		}
		if( mged_rel_tol > 0.0 )  {
			rt_log("\trel %g (%g%%)\n",
				mged_rel_tol, mged_rel_tol * 100.0 );
		} else {
			rt_log("\trel None\n");
		}
		if( mged_nrm_tol > 0.0 )  {
			int	deg, min;
			double	sec;

			sec = mged_nrm_tol * rt_radtodeg;
			deg = (int)(sec);
			sec = (sec - (double)deg) * 60;
			min = (int)(sec);
			sec = (sec - (double)min) * 60;

			rt_log("\tnorm %g degrees (%d deg %d min %g sec)\n",
				mged_nrm_tol * rt_radtodeg,
				deg, min, sec );
		} else {
			rt_log("\tnorm None\n");
		}

		rt_log( "Calculational tolerances:\n" );
		rt_log( "\tdistance = %g %s\n\tperpendicularity = %g (cosine of %g degrees)\n",
			mged_tol.dist*base2local, rt_units_string(local2base), mged_tol.perp, acos( mged_tol.perp)*rt_radtodeg );
		return CMD_OK;
d1630 1
a1630 1
			return CMD_OK;
d1635 2
a1636 2
				rt_log("relative tolerance must be between 0 and 1, not changed\n");
				return CMD_BAD;
d1644 2
a1645 2
				rt_log("Normal tolerance must be in positive degrees, < 90.0\n");
				return CMD_BAD;
d1653 2
a1654 2
				rt_log("Calculational distance tolerance must be positive\n");
				return CMD_BAD;
d1662 2
a1663 2
				rt_log("Calculational perpendicular tolerance must be fromn 0 to 1\n");
				return CMD_BAD;
d1669 2
a1670 1
			rt_log("Error, tolerance '%s' unknown\n", argv[argind] );
d1674 1
a1674 1
	return CMD_OK;
d1684 3
a1686 1
f_zoom( argc, argv )
d1696 3
d1703 2
a1704 2
		rt_log("zoom: scale factor out of range\n");
		return CMD_BAD;
d1707 1
a1707 1
		return CMD_BAD;
d1727 1
a1727 1
	return CMD_OK;
d1737 3
a1739 1
f_orientation( argc, argv )
d1743 10
a1752 2
	register int	i;
	quat_t		quat;
d1754 1
a1754 5
	for( i=0; i<4; i++ )
		quat[i] = atof( argv[i+1] );
	quat_quat2mat( Viewrot, quat );
	new_mats();
	return CMD_OK;
d1763 3
a1765 1
f_qvrot( argc, argv )
d1774 3
d1785 2
a1786 2
	    rt_log("f_qvrot: (dx, dy, dz) may not be the zero vector\n");
	    return CMD_BAD;
d1799 1
a1799 1
    return CMD_OK;
@


11.22
log
@added an optional parameter to the release command
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.21 1996/03/01 19:17:44 bparker Exp bparker $ (BRL)";
a79 14
#ifndef MULTI_ATTACH
int		rateflag_slew;
vect_t		rate_slew;
vect_t		absolute_slew;

int		rateflag_rotate;
vect_t		rate_rotate;
vect_t		absolute_rotate;	/* selected by mged_variables.rateknobs */

int		rateflag_zoom;
fastf_t		rate_zoom;
fastf_t		absolute_zoom;
#endif

a94 4
#ifdef MULTI_ATTACH
	update_views = 1;
#endif

d100 2
a101 1
	dmaflag = 1;
a117 1
	dmaflag++;
a131 1
#ifdef VIRTUAL_TRACKBALL 
a136 1
#endif
a156 1
	dmaflag++;
a189 1
#ifdef MULTI_ATTACH
a190 1
#endif
a200 1
#ifdef MULTI_ATTACH
a201 1
#endif
a222 1
#ifdef MULTI_ATTACH
a223 1
#endif
a306 1
	dmaflag = 1;
d309 2
a310 2
		dmaflag = 1;
		refresh();
a321 1
#ifdef MULTI_ATTACH
a335 1
#ifdef VIRTUAL_TRACKBALL
a339 1
#endif
a342 1
	    dmaflag = 1;
a346 14
#else	
	/* If we went from blank screen to non-blank, resize */
	if (mged_variables.autosize  && initial_blank_screen &&
	    HeadSolid.s_forw != &HeadSolid)  {
		size_reset();
		new_mats();

#ifdef VIRTUAL_TRACKBALL
		MAT_DELTAS_GET(orig_pos, toViewcenter);
		tran_x = 0.0;
		tran_y = 0.0;
		tran_z = 0.0;
#endif
	}
a347 3
	dmp->dmr_colorchange();
	dmaflag = 1;
#endif
a683 1
#ifdef MULTI_ATTACH
a684 1
#endif
a711 1
	dmaflag = 1;
a782 1
#ifdef MULTI_ATTACH
d787 2
a788 4
#else
	release();
#endif
	return CMD_OK;
a804 1
#ifdef MULTI_ATTACH
d806 1
a806 1
#endif
d820 1
a820 1
			dmaflag = 1;
d1009 1
a1009 1
	dmaflag = 1;
a1042 1
#ifdef MULTI_ATTACH
a1043 1
#endif
a1093 7
#ifndef MULTI_ATTACH
  if( !aslewflag ) {
    VSETALL( absolute_slew, 0.0 );
    aslewflag = 1;
  }
#endif

a1475 1
#ifdef VIRTUAL_TRACKBALL
a1481 1
#endif
a1493 1
#ifdef VIRTUAL_TRACKBALL
a1507 1
#endif
@


11.21
log
@remove unused XMGED stuff
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.20 1996/02/12 00:30:28 jra Exp bparker $ (BRL)";
d835 6
d842 1
@


11.20
log
@cmd_list was using rt_vls_vlsfree() on a local vls. Changed to use rt_vls_free().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.19 1996/02/09 22:13:58 bparker Exp jra $ (BRL)";
d70 1
a70 11
#ifdef XMGED
int local_rt_arb_describe();
void check_nonzero_rates();
#endif

#ifdef VIRTUAL_TRACKBALL
extern int (*rot_hook)();
extern int (*set_tran_hook)();
extern int (*tran_hook)();

extern int rot_set;
a71 3

extern void (*knob_offset_hook)();
extern int (*knob_hook)();
a161 5
#ifdef VIRTUAL_TRACKBALL
	if(rot_hook)
          (*rot_hook)();
#endif

a341 3
#ifdef XMGED
		(void)signal( SIGINT, cur_sigint );	/* allow interupts after here */
#else
a342 1
#endif
d349 31
a379 1
	
d396 1
a396 1

a409 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );	/* allow interupts */
#else
d411 1
a411 1
#endif
a455 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );	/* allow interupts */
#else
d457 1
a457 1
#endif
a655 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );	/* allow interupts */
#else	
a656 1
#endif
a1139 3
  if(knob_hook != NULL)
    return (*knob_hook)(argc, argv);

a1568 3

	if(tran_hook)
	  (*tran_hook)();
@


11.19
log
@adding virtual trackball stuff
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.18 1996/01/17 22:12:26 bparker Exp bparker $ (BRL)";
d668 1
a668 1
	rt_vls_vlsfree( &str );
@


11.18
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.17 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
a41 1

d71 5
a78 2
int local_rt_arb_describe();
void check_nonzero_rates();
d80 1
a80 8
extern int irot_set;
extern double irot_x;
extern double irot_y;
extern double irot_z;
extern double tran_x;
extern double tran_y;
extern double tran_z;
extern point_t orig_pos;
d163 5
a167 5
#ifdef XMGED
	if(!irot_set){
          irot_x += atof(argv[1]);
          irot_y += atof(argv[2]);
          irot_z += atof(argv[3]);
d175 1
a175 1
#ifdef XMGED
d378 1
a378 1
#ifdef XMGED
d1539 1
a1539 1
#ifdef XMGED
d1559 1
a1559 1
#ifdef XMGED
@


11.17
log
@Just playing it safe
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.16 1995/12/27 22:29:02 bparker Exp bparker $ (BRL)";
d1155 1
d1160 1
@


11.16
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.15 1995/11/07 22:57:50 bparker Exp bparker $ (BRL)";
a77 1
extern int update_views;   /* from dm-X.h */
d88 1
d127 1
a127 1
#ifdef XMGED
d234 1
a234 1
#ifdef XMGED
d247 1
a247 1
#ifdef XMGED
d271 1
a271 1
#ifdef XMGED
d740 1
a740 1
#ifdef XMGED
d860 1
a860 1
#ifdef XMGED
d1099 1
a1099 1
#ifdef XMGED
d1401 3
@


11.15
log
@unleashed iknob
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.14 1995/09/22 02:50:46 mike Exp bparker $ (BRL)";
d98 1
d110 1
@


11.14
log
@Fixed to use vls_col_item()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/chgview.c,v 11.13 1995/09/09 02:02:05 butler Exp mike $ (BRL)";
a74 1
extern int (*knob_hook)();
d89 1
d1142 1
a1142 1
#ifdef XMGED
@


11.13
log
@Changed f_list to cmd_list with TCL interface.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/chgview.c,v 11.12 1995/07/19 16:01:10 pjt Exp butler $ (BRL)";
d614 1
a614 1
				col_item( rt_vls_addr(&str) );
d618 1
a618 1
		if( !verbose )  col_eol();
@


11.12
log
@Fixed a bug in f_ill's freeing of path_piece
and removed some diagnostic prints
@
text
@d14 1
a14 1
 *	f_list		list object information
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.11 1995/07/19 15:24:18 pjt Exp pjt $ (BRL)";
d48 4
d644 3
a646 1
f_list(argc, argv)
a665 1
		rt_vls_trunc( &str, 0 );
a666 1
		rt_log( "%s", rt_vls_addr(&str) );
d669 1
a669 1
	rt_vls_free( &str );
d671 2
a672 1
	return CMD_OK;
@


11.11
log
@f_sed now supports a path as an arg
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.10 1995/07/18 20:14:02 pjt Exp pjt $ (BRL)";
d975 1
a975 1
		rt_log("OK, next piece is '%s'\n", path_piece[nm_pieces]);
d979 1
a979 1
		rt_log("Bad solid path: '%s'\n", argv[1]);
a982 1
	    rt_log("OK, now, basename is '%s'\n", basename);
d984 2
d996 1
a996 1
		    rt_log("%s is not a solid\n", basename);
a1012 1
			    {
a1013 6
				rt_log("strcmp(%s, %s) != 0\n",
				    sname, path_piece[j]);
			    }
			    else
				rt_log("strcmp(%s, %s) == 0\n",
				    sname, path_piece[j]);
a1019 2
			rt_log("a_new_match=%d, j=%d, i=%d\n",
			    a_new_match, j, i);
d1041 1
a1041 1
		rt_log("%s not being displayed\n", argv[1]);
d1045 1
a1045 1
		rt_log("%s multiply referenced\n", argv[1]);
d1061 2
a1062 2
	    while (*path_piece != 0)
		rt_free(*path_piece++, "f_ill: char *");
d1072 2
a1073 2
	while (*path_piece != 0)
	    rt_free(*path_piece++, "f_ill: char *");
@


11.10
log
@COB 18 Jul
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.9 1995/07/13 20:32:14 pjt Exp pjt $ (BRL)";
a955 1
/* TODO:  allow path specification on cmd line */
d964 1
a964 1
	register int i;
d966 2
a967 1
	char	**path_piece;
d969 1
a969 10

	/*
	 *	XXX
	 *
	 *	Have to reject before returning??
	 */

	path_piece = path_parse(argv[1]);
	for (i = 0; path_piece[i] != 0; ++i)
	    rt_log("OK, next piece is '%s'\n", path_piece[i]);
d971 1
a971 1
	if (i == 0)
d973 11
a983 2
	    rt_log("Bad solid path: '%s'\n", argv[1]);
	    return CMD_BAD;
a984 2
	basename = path_piece[i - 1];
	rt_log("OK, now, basename is '%s'\n", basename);
d987 2
a988 5
		return CMD_BAD;
	if( state != ST_O_PICK && state != ST_S_PICK )  {
		state_err("keyboard illuminate pick");
		return CMD_BAD;
	}
d990 1
a990 1
	FOR_ALL_SOLIDS (sp)
d992 7
a998 2
	    for (i = 0; i <= sp -> s_last; i++)
		if (sp -> s_path[i] == dp)
d1000 42
a1041 3
		    lastfound = sp;
		    nmatch++;
		    break;
d1043 4
a1046 1
	    sp -> s_iflag = DOWN;
d1050 1
a1050 1
		return CMD_BAD;
d1054 1
a1054 1
		return CMD_BAD;
d1067 6
d1074 11
d1095 4
@


11.9
log
@Really COB 13 July
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.8 1995/07/13 20:26:14 pjt Exp $ (BRL)";
d968 1
d970 6
d977 10
a986 2
	while (*path_piece != 0)
	    rt_log("OK, next piece is '%s'\n", *path_piece++);
d988 1
a988 1
	if( (dp = db_lookup( dbip,  argv[1], LOOKUP_NOISY )) == DIR_NULL )
d995 8
a1002 7
	FOR_ALL_SOLIDS( sp )  {
		for( i=0; i<=sp->s_last; i++ )  {
			if( sp->s_path[i] == dp )  {
				lastfound = sp;
				nmatch++;
				break;
			}
d1004 1
a1004 1
		sp->s_iflag = DOWN;
d1606 1
a1606 4
    while (*path == '/')
	++path;

    nm_constituents = 1;
d1609 6
a1614 1
	    ++nm_constituents;
d1621 2
d1624 1
a1624 1
	while (*++pp != '/')
d1626 1
a1626 1
	result[i] = (char *) rt_malloc((pp - start_addr) * sizeof(char),
d1629 1
@


11.8
log
@COB 13 July
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.7 95/03/10 19:18:22 mike Exp $ (BRL)";
d953 2
d967 1
a967 1
	char	**path_pieces;
d969 2
a970 2
	path_pieces = path_parse(argv[1]);
	while (*path_pieces != 0)
d1584 1
d1586 1
d1595 1
a1595 1
	if (pp == '/')
@


11.7
log
@Can't do rt_log( rt_vls_addr( &str ) ), need to use "%s" format.
Otherwise, can over-run format string in printf.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.6 95/01/18 13:23:17 bparker Exp Locker: mike $ (BRL)";
d965 1
d967 4
d1561 48
@


11.6
log
@merging xmged sources
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.3 95/01/17 16:27:28 jra Exp $ (BRL)";
d662 1
a662 1
		rt_log( rt_vls_addr(&str) );
d690 1
a690 1
		rt_log( rt_vls_addr(&str) );
@


11.5
log
@"tol dist #" now uses local units.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.4 95/01/18 08:29:53 jra Exp Locker: jra $ (BRL)";
d67 19
d121 4
d162 8
d174 5
d228 4
d241 4
d265 4
d359 3
d363 1
d376 7
d401 3
d405 1
d450 3
d454 1
d650 4
a653 1
	
d655 1
d733 3
d853 3
d1014 4
d1059 2
d1062 138
d1279 1
d1393 1
a1393 1
				mged_abs_tol = 0.0;	/* None */
d1395 1
a1395 1
				mged_abs_tol = f * local2base;
d1454 5
d1460 3
d1473 21
@


11.4
log
@Fixed bug in tol command.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.3 95/01/17 16:27:28 jra Exp $ (BRL)";
d1159 2
a1160 2
		rt_log( "\tdistance = %g\n\tperpendicularity = %g (cosine of %g degrees)\n",
			mged_tol.dist, mged_tol.perp, acos( mged_tol.perp)*rt_radtodeg );
d1200 2
a1201 2
			mged_tol.dist = f;
			mged_tol.dist_sq = f*f;
@


11.3
log
@Added calculational tolerances to the "tol" command.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.2 95/01/17 16:02:11 jra Exp Locker: jra $ (BRL)";
d1159 2
a1160 1
		rt_log( "\tdistance = %g\n\tperpendicularity = %g\n", mged_tol.dist, mged_tol.perp );
d1170 1
a1170 1
			if( f <= 0.0 )  {
d1172 2
a1173 3
				return CMD_OK;
			}
			mged_abs_tol = f * local2base;
a1183 1
			return CMD_OK;
a1192 1
			return CMD_OK;
a1201 1
			return CMD_OK;
a1210 1
			return CMD_OK;
@


11.2
log
@Changed by gdurf.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 11.1 95/01/04 10:02:44 mike Rel4_4 Locker: gdurf $ (BRL)";
d69 2
d1114 2
d1123 1
d1127 1
d1157 3
d1163 11
a1173 5
	f = atof(argv[2]);
	if( argv[1][0] == 'a' )  {
		/* Absolute tol */
		if( f <= 0.0 )  {
			mged_abs_tol = 0.0;	/* None */
d1176 9
a1184 8
		mged_abs_tol = f * local2base;
		return CMD_OK;
	}
	if( argv[1][0] == 'r' )  {
		/* Relative */
		if( f < 0.0 || f >= 1.0 )  {
			rt_log("relative tolerance must be between 0 and 1, not changed\n");
			return CMD_BAD;
d1186 9
a1194 9
		/* Note that a value of 0.0 will disable relative tolerance */
		mged_rel_tol = f;
		return CMD_OK;
	}
	if( argv[1][0] == 'n' )  {
		/* Normal tolerance, in degrees */
		if( f < 0.0 || f > 90.0 )  {
			rt_log("Normal tolerance must be in positive degrees, < 90.0\n");
			return CMD_BAD;
d1196 24
a1219 3
		/* Note that a value of 0.0 or 360.0 will disable this tol */
		mged_nrm_tol = f * rt_degtorad;
		return CMD_OK;
d1221 1
a1221 2
	rt_log("Error, tolerance '%s' unknown\n", argv[1] );
	return CMD_BAD;
@


11.1
log
@Release_4.4
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.34 94/12/29 16:33:33 jra Exp $ (BRL)";
d75 2
d80 1
d83 1
d974 2
d977 5
d996 1
a996 7
			if( mged_variables.rateknobs )  {
				rate_rotate[X] = f;
			} else {
				VSETALL(rate_rotate, 0);
				absolute_rotate[X] = f;
				absview_v( absolute_rotate );
			}
d999 1
a999 7
			if( mged_variables.rateknobs )  {
				rate_rotate[Y] = f;
			} else {
				VSETALL(rate_rotate, 0);
				absolute_rotate[Y] = f;
				absview_v( absolute_rotate );
			}
d1002 23
a1024 7
			if( mged_variables.rateknobs )  {
				rate_rotate[Z] = f;
			} else {
				VSETALL(rate_rotate, 0);
				absolute_rotate[Z] = f;
				absview_v( absolute_rotate );
			}
d1026 10
d1037 5
a1041 2
			if( mged_variables.rateknobs )
				rate_slew[X] = f;
d1044 5
a1048 2
			if( mged_variables.rateknobs )
				rate_slew[Y] = f;
d1051 5
a1055 2
			if( mged_variables.rateknobs )
				rate_slew[Z] = f;
a1057 2
			if( mged_variables.rateknobs )
				rate_zoom = f;
d1062 3
d1095 2
@


10.34
log
@moved vlist commands to vlist.c
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.33 94/12/28 16:06:49 jra Exp Locker: jra $ (BRL)";
@


10.33
log
@replaced code setting dm_values items with rt_vls_printf( &dm_values.dv_string...) calls.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.32 94/12/28 09:47:55 gdurf Exp Locker: jra $ (BRL)";
a797 10
static char *mged_vl_draw_message[] = {
	"line move ",
	"line draw ",
	"poly start",
	"poly move ",
	"poly draw ",
	"poly end  ",
	"**unknown*"
};

d853 1
d860 1
a860 1
					mged_vl_draw_message[*cmd],
d865 2
@


10.32
log
@Fixed do_list bug
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.31 94/12/27 18:04:54 mike Exp Locker: gdurf $ (BRL)";
d63 4
d1038 2
a1039 2
		dm_values.dv_xadc = i;
		dm_values.dv_flagadc = 1;
d1041 2
a1042 2
		dm_values.dv_yadc = i;
		dm_values.dv_flagadc = 1;
d1044 2
a1045 2
		dm_values.dv_1adc = i;
		dm_values.dv_flagadc = 1;
d1047 2
a1048 2
		dm_values.dv_2adc = i;
		dm_values.dv_flagadc = 1;
d1050 3
a1052 2
		dm_values.dv_distadc = i;
		dm_values.dv_flagadc = 1;
d1059 1
a1059 1

@


10.31
log
@Partially eliminated dv_ stuff
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.30 94/12/27 16:58:45 mike Exp Locker: mike $ (BRL)";
d514 1
a514 1
				rt_log("\n");
@


10.30
log
@Fixed bug #247, added rt_ prefix to memalloc(), etc.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.29 94/12/24 00:23:44 mike Exp Locker: mike $ (BRL)";
a987 1
			dm_values.dv_xjoy = f;
a996 1
			dm_values.dv_yjoy = f;
a1005 1
			dm_values.dv_zjoy = f;
a1014 1
			dm_values.dv_xslew = f;
d1019 2
a1020 2
			dm_values.dv_yslew = f;
			rate_slew[Y] = f;
d1023 2
a1024 2
			dm_values.dv_zslew = f;
			rate_slew[Z] = f;
d1027 2
a1028 2
			dm_values.dv_zoom = f;
			rate_zoom = f;
d1049 2
a1051 4
		dm_values.dv_xjoy = 0;
		dm_values.dv_yjoy = 0;
		dm_values.dv_zjoy = 0;

d1053 1
a1053 3
		dm_values.dv_xslew = 0;
		dm_values.dv_yslew = 0;
		dm_values.dv_zslew = 0;
d1055 4
a1058 2
		rate_zoom = 0;
		dm_values.dv_zoom = 0;
@


10.29
log
@When zapping knobs, don't zap absolute rotation
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.28 94/12/23 23:47:56 gdurf Exp Locker: mike $ (BRL)";
d660 1
a660 1
		memfree( &(dmp->dmr_map), sp->s_bytes, (unsigned long)sp->s_addr );
d779 1
a779 1
			memfree( &(dmp->dmr_map), sp->s_bytes, (unsigned long)sp->s_addr );
@


10.28
log
@Converted to new do_list
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.27 94/12/23 21:58:40 gdurf Exp Locker: gdurf $ (BRL)";
a1052 1
		VSETALL( absolute_rotate, 0 );
@


10.27
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.26 94/12/16 20:55:00 gdurf Exp Locker: gdurf $ (BRL)";
d403 2
a404 2
do_list( outfp, dp, verbose )
FILE	*outfp;
d415 1
d417 1
a417 1
	fprintf( outfp, "%s:  ", dp->d_namep);
d428 5
a432 3
		(void)fprintf( outfp, "%s (len %d) ", dp->d_namep, dp->d_len-1 );
		if( rp[0].c.c_flags == 'R' )
			rt_log("REGION id=%d  (air=%d, los=%d, GIFTmater=%d) ",
d437 5
a441 3
		(void)fprintf(outfp,"--\n");
		if( rp[0].c.c_matname[0] )
			(void)fprintf(outfp,"Material '%s' '%s'\n",
d444 4
a447 2
		if( rp[0].c.c_override == 1 )
			(void)fprintf(outfp,"Color %d %d %d\n",
d451 1
d453 4
a456 2
			if( rp[0].c.c_inherit == DB_INH_HIGHER )
				(void)fprintf(outfp,"(These material properties override all lower ones in the tree)\n");
d472 2
a473 1
			if( xmat[0] != 1.0 || xmat[5] != 1.0 || xmat[10] != 1.0 )
d489 4
a492 3
				(void)fprintf(outfp,"  %c %s",
					rp[i].M.m_relation, rp[i].M.m_instname );
				if( status & STAT_ROT )  {
d495 3
a497 1
					(void)fprintf(outfp," az=%g, el=%g, ", az, el );
d499 2
a500 2
				if( status & STAT_XLATE )
					(void)fprintf(outfp," [%g,%g,%g]",
d504 8
a511 4
				if( status & STAT_SCALE )
					(void)fprintf(outfp," scale %g", 1.0/xmat[15] );
				if( status & STAT_PERSP )
					(void)fprintf(outfp," ??Perspective=[%g,%g,%g]??",
d513 1
d516 1
a516 2
				char	buf[132];
				register char	*cp = buf;
d518 4
a521 2
				(void)sprintf(buf, "%c %s",
					rp[i].M.m_relation, rp[i].M.m_instname );
d523 1
d533 2
a534 1
				col_item( buf );
d547 1
a547 1
	rt_vls_init( &str );
d552 1
a552 2
	fputs( rt_vls_addr( &str ), outfp );
	rt_vls_free( &str );
d556 2
d569 4
d579 3
a581 1
		do_list( stderr, dp, 99 );	/* very verbose */
d584 2
d598 3
d607 3
a609 1
		do_list( stderr, dp, 0 );	/* non-verbose */
d611 2
@


10.26
log
@Changed stdout to stderr for compatibility with rt_log.
Temporary hack!
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.25 1994/12/16 20:29:05 gdurf Exp gdurf $ (BRL)";
@


10.25
log
@Changed putchar to rt_log (yuk)
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.24 1994/12/16 19:35:42 gdurf Exp gdurf $ (BRL)";
d552 1
a552 1
		do_list( stdout, dp, 99 );	/* very verbose */
d573 1
a573 1
		do_list( stdout, dp, 0 );	/* non-verbose */
@


10.24
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.23 1994/12/08 23:16:59 mike Exp gdurf $ (BRL)";
d495 1
a495 1
				(void)putchar('\n');
@


10.23
log
@Scale factor was wrong.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.22 94/11/16 16:59:48 jra Exp Locker: mike $ (BRL)";
d307 1
a307 1
	(void)printf("%ld vectors in %g sec\n", nvectors, elapsed_time );
d331 1
a331 1
	printf("ndrawn=%d\n", ndrawn);
d349 1
a349 1
	(void)printf("regdebug=%d\n", regdebug);
d419 1
a419 1
		printf("db_get_external(%s) failure\n", dp->d_namep);
d429 1
a429 1
			(void)printf("REGION id=%d  (air=%d, los=%d, GIFTmater=%d) ",
d522 1
a522 1
		printf("%s: database import error\n", dp->d_namep);
d528 1
a528 1
		printf("%s: describe error\n", dp->d_namep);
d627 1
a627 1
				printf("f_zap: db_dirdelete failed\n");
d651 3
a653 3
	(void)printf("STATE=%s, ", state_str[state] );
	(void)printf("Viewscale=%f (%f mm)\n", Viewscale*base2local, Viewscale);
	(void)printf("base2local=%f\n", base2local);
d751 1
a751 1
			printf("eraseobj: db_dirdelete failed\n");
d785 1
a785 1
		(void)printf( sp->s_flag == UP ? "VIEW ":"-no- " );
d787 1
a787 1
			(void)printf("/%s", sp->s_path[i]->d_namep);
d789 2
a790 2
			(void)printf(" ILLUM");
		(void)printf("\n");
d795 1
a795 1
		(void)printf("  cent=(%.3f,%.3f,%.3f) sz=%g ",
d800 2
a801 2
		(void)printf("reg=%d\n",sp->s_regionid );
		(void)printf("  color=(%d,%d,%d) %d,%d,%d i=%d\n",
d826 1
a826 1
				printf("  %s (%g, %g, %g)\n",
d831 1
a831 1
		printf("  %d vlist structures, %d pts\n", nvlist, npts );
d866 1
a866 1
		(void)printf("%s not being displayed\n", argv[1]);
d870 1
a870 1
		(void)printf("%s multiply referenced\n", argv[1]);
d1030 3
a1032 3
		(void)printf("knob: x,y,z for rotation, S for scale, X,Y,Z for slew (rates, range -1..+1)\n");
		(void)printf("knob: xadc, yadc, zadc, ang1, ang2, distadc (values, range -2048..+2047)\n");
		(void)printf("knob: zero (cancel motion)\n");
d1055 1
a1055 1
		(void)printf("Current tolerance settings are:\n");
d1057 1
a1057 1
			(void)printf("\tabs %g %s\n",
d1061 1
a1061 1
			(void)printf("\tabs None\n");
d1064 1
a1064 1
			(void)printf("\trel %g (%g%%)\n",
d1067 1
a1067 1
			(void)printf("\trel None\n");
d1079 1
a1079 1
			(void)printf("\tnorm %g degrees (%d deg %d min %g sec)\n",
d1083 1
a1083 1
			(void)printf("\tnorm None\n");
d1101 1
a1101 1
			(void)printf("relative tolerance must be between 0 and 1, not changed\n");
d1111 1
a1111 1
			(void)printf("Normal tolerance must be in positive degrees, < 90.0\n");
d1118 1
a1118 1
	(void)printf("Error, tolerance '%s' unknown\n", argv[1] );
d1137 1
a1137 1
		(void)printf("zoom: scale factor out of range\n");
d1192 1
a1192 1
	    printf("f_qvrot: (dx, dy, dz) may not be the zero vector\n");
@


10.22
log
@Modified size_reset to set size of 2.0 if size of all objects is less than SQRT_SMALL_FASTF.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.21 94/11/10 12:06:03 jra Exp Locker: jra $ (BRL)";
d491 1
a491 1
					(void)fprintf(outfp," scale %g", xmat[15] );
@


10.21
log
@Irix 6.0.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/chgview.c,v 10.20 1994/08/27 03:16:42 mike Exp jra $ (BRL)";
d253 4
@


10.20
log
@Eliminated MIN() and MAX() from ged.h, in favor of V_MIN() and V_MAX()
from vmath.h, because some systems use the symbols MIN and MAX in
system header files.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.19 94/08/19 10:14:17 pjt Exp Locker: mike $ (BRL)";
d359 1
a359 1
		rt_printb( "Possible flags", -1, DEBUG_FORMAT );
d386 1
a386 1
		rt_printb( "possible flags", -1, NMG_DEBUG_FORMAT );
a1177 1
    double	three_halves_pi = 270.0 * radtodeg;
a1178 2
    int		i, j;
    mat_t	mat1, mat2, mat3;
@


10.19
log
@Cleaned up qvrot command
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.18 94/08/17 16:16:12 pjt Exp Locker: pjt $ (BRL)";
d256 2
a257 2
	MAX( Viewscale, radial[Y] );
	MAX( Viewscale, radial[Z] );
@


10.18
log
@Implemented qvrot command
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.17 94/08/09 14:58:45 gdurf Exp Locker: pjt $ (BRL)";
d1168 1
a1168 1
 *  Set current view direction from a quaternion.
d1197 1
a1197 1
	az = atan2(-dy, -dx);
d1199 1
a1199 1
    el = atan2(-dz, sqrt(dx * dx + dy * dy));
a1205 22






    buildHrot(mat1, three_halves_pi + el, 0.0, three_halves_pi - az);

    theta = atof(argv[4]) * degtorad;
    buildHrot(mat2, 0.0, theta, 0.0);
    mat_mul(mat3, mat2, mat1);
    for (i = 0; i < 3; ++i)
	for (j = 0; j < 3; ++j)
	    Viewrot[4 * i + j] = mat3[4 * i + j];
    new_mats();
    return CMD_OK;

    /*
     * setview( 270.0 + atof(argv[2]), 0.0, 270.0 - atof(argv[1]) );
     *    buildHrot( Viewrot, a1 * degtorad, a2 * degtorad, a3 * degtorad );
     *    new_mats();
     */
@


10.17
log
@Added include
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.16 1994/08/05 14:48:24 mike Exp gdurf $ (BRL)";
d1163 65
@


10.16
log
@Only give back the freelists when debugging.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.15 94/08/03 22:53:19 mike Exp Locker: mike $ (BRL)";
d42 2
@


10.15
log
@For invented solids, clean up their directory entries when they
drop from view.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.14 94/08/03 22:24:12 mike Exp Locker: mike $ (BRL)";
d630 4
a633 1
	mged_freemem();
@


10.14
log
@Added mged_freemem()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.13 94/06/03 12:30:12 gdurf Exp Locker: mike $ (BRL)";
d606 1
d617 7
d722 1
d739 5
@


10.13
log
@a few bug fixes
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.12 1994/06/01 14:32:31 gdurf Exp gdurf $ (BRL)";
d573 24
d622 1
@


10.12
log
@Converted f_ commands to use new command return codes
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.11 1994/03/02 20:49:00 mike Exp gdurf $ (BRL)";
d117 1
a117 1
void
d988 1
d999 1
a999 1
void
d1045 1
a1045 1
			return;
@


10.11
log
@Added print of ndrawn on x command.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.10 93/07/15 21:27:32 mike Exp Locker: mike $ (BRL)";
d75 2
a76 2
RT_EXTERN(void	edit_com, (int argc, char **argv, int kind, int catch_sigint));
void		f_zap();
d82 1
a82 1
void
d96 2
d102 1
a102 1
void
d113 2
d125 1
a125 1
		return;
d130 2
d136 1
a136 1
void
d147 2
d153 1
a153 1
void
d159 1
a159 1
	f_zap(argc, argv);
d170 1
a170 1
	edit_com( argc, argv, 1, 1 );
d175 1
a175 1
void
d180 1
a180 1
	edit_com( argc, argv, 1, 1 );
d184 1
a184 1
void
d189 1
a189 1
	edit_com( argc, argv, 3, 1 );
d194 1
a194 1
 * XXX the old Big-E command is retained in all it's glory in
d204 1
a204 1
void
d209 1
a209 1
	edit_com( argc, argv, 2, 1 );
d263 1
a263 1
void
d312 2
d316 1
a316 1
void
d328 2
d332 1
a332 1
void
d345 2
d349 1
a349 1
void
d362 2
d366 1
a366 1
void
d373 1
d376 1
a376 1
void
d389 2
d533 1
a533 1
void
d548 2
d554 1
a554 1
void
d569 2
d575 1
a575 1
void
d600 2
d604 1
a604 1
void
d620 2
d625 1
a625 1
void
d632 1
d635 1
a635 1
void
d641 1
d645 1
a645 1
void
d651 1
d654 1
a654 1
void
d663 1
d666 1
a666 1
void
d672 1
d789 1
a789 1
void
d801 1
a801 1
		return;
d804 1
a804 1
		return;
d819 1
a819 1
		return;
d823 1
a823 1
		return;
d836 1
d840 1
a840 1
void
d846 1
a846 1
		return;
d849 1
a849 1
	f_ill(argc, argv);		/* Illuminate named solid --> ST_S_EDIT */
d879 1
a879 1
void
d1036 1
a1036 1
		return;
d1047 1
a1047 1
		return;
d1053 1
a1053 1
			return;
d1057 1
a1057 1
		return;
d1063 1
a1063 1
			return;
d1067 1
a1067 1
		return;
d1070 1
d1079 1
a1079 1
void
d1089 1
a1089 1
		return;
d1092 1
a1092 1
		return;
d1096 1
d1105 1
a1105 1
void
d1117 1
@


10.10
log
@Added zap of absolute_rotate[]
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.9 93/07/15 21:23:26 mike Exp Locker: mike $ (BRL)";
d315 1
@


10.9
log
@Added support for "rateknobs".
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.8 92/11/23 20:54:36 mike Exp Locker: mike $ (BRL)";
d933 1
@


10.8
log
@Changed eedit to edit_com(), made global so it can be used
in rtif.c, and added extra arg indicating if new SIGINT handler
should be installed, or if existing one should be used.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.7 92/09/03 19:36:56 mike Exp Locker: mike $ (BRL)";
d71 1
d869 7
a875 1
			rate_rotate[X] = f;
d879 7
a885 1
			rate_rotate[Y] = f;
d889 7
a895 1
			rate_rotate[Z] = f;
d899 2
a900 1
			rate_slew[X] = f;
@


10.7
log
@Added "orientation" command.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.6 92/06/12 19:59:21 mike Exp Locker: mike $ (BRL)";
d74 1
a74 1
static void	eedit();
d161 1
a161 1
	eedit( argc, argv, 1 );
d171 1
a171 1
	eedit( argc, argv, 1 );
d180 1
a180 1
	eedit( argc, argv, 3 );
d200 1
a200 1
	eedit( argc, argv, 2 );
d250 1
a250 1
 *			E E D I T
d254 2
a255 2
static void
eedit(argc, argv, kind)
d259 1
d285 2
a286 1
	(void)signal( SIGINT, sig2 );	/* allow interupts after here */
@


10.6
log
@Made f_list use very verbose flag.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.5 92/04/04 00:08:43 mike Exp Locker: mike $ (BRL)";
d1040 19
@


10.5
log
@Changed to use better timer, when it's available.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.4 92/04/03 05:04:24 mike Exp Locker: mike $ (BRL)";
d523 1
a523 1
		do_list( stdout, dp, 1 );	/* verbose */
@


10.4
log
@Added "knobs zap" "knobs zero" command.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.3 91/12/18 06:38:44 mike Exp Locker: mike $ (BRL)";
d262 1
a262 1
	long		stime, etime;	/* start & end times */
d287 1
a287 1
	(void)time( &stime );
d289 2
a290 2
	(void)time( &etime );
	(void)printf("%ld vectors in %ld sec\n", nvectors, etime - stime );
@


10.3
log
@Added output file descriptor to do_list().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.2 91/11/04 23:15:09 mike Exp Locker: mike $ (BRL)";
d910 13
d927 1
@


10.2
log
@Modified for beginnings of new display manager interface.
Added zoom and "M" (mouse) command.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 10.1 91/10/12 06:43:12 mike Rel4_0 Locker: mike $ (BRL)";
d374 2
a375 1
do_list( dp, verbose )
d387 1
a387 1
	printf("%s:  ", dp->d_namep);
d390 1
a390 1
		printf("db_get_external failure\n");
d398 1
a398 1
		(void)printf("%s (len %d) ", dp->d_namep, dp->d_len-1 );
d405 1
a405 1
		(void)printf("--\n");
d407 1
a407 1
			(void)printf("Material '%s' '%s'\n",
d411 1
a411 1
			(void)printf("Color %d %d %d\n",
d417 1
a417 1
				(void)printf("(These material properties override all lower ones in the tree)\n");
d449 1
a449 1
				(void)printf("  %c %s",
d454 1
a454 1
					(void)printf(" az=%g, el=%g, ", az, el );
d457 1
a457 1
					(void)printf(" [%g,%g,%g]",
d462 1
a462 1
					(void)printf(" scale %g", xmat[15] );
d464 1
a464 1
					(void)printf(" ??Perspective=[%g,%g,%g]??",
d493 1
a493 1
		printf("database import error\n");
d499 1
a499 1
		printf("describe error\n");
d501 1
a501 1
	fputs( rt_vls_addr( &str ), stdout );
d523 1
a523 1
		do_list( dp, 1 );	/* verbose */
d542 1
a542 1
		do_list( dp, 0 );	/* non-verbose */
@


10.1
log
@Release_4.0
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.37 91/08/31 07:30:00 butler Exp $ (BRL)";
d67 7
a813 1
/* Simulate a knob twist.  "knob id val" */
d815 27
d846 3
a848 1
	fastf_t f;
d850 2
a851 1
	if(argc == 2)
d853 2
a854 1
	else {
d861 52
a912 25
	switch( argv[1][0] )  {
	case 'x':
		dm_values.dv_xjoy = f;
		break;
	case 'y':
		dm_values.dv_yjoy = f;
		break;
	case 'z':
		dm_values.dv_zjoy = f;
		break;
	case 'X':
		dm_values.dv_xslew = f;
		break;
	case 'Y':
		dm_values.dv_yslew = f;
		break;
	case 'Z':
		dm_values.dv_zslew = f;
		break;
	case 'S':
		dm_values.dv_zoom = f;
		break;
	default:
		(void)printf("x,y,z for rotation, S for scale, X,Y,Z for slew\n");
		return;
d914 2
d999 26
@


9.37
log
@implementation of the "set" command for altering "autosize" function.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.36 91/08/25 04:56:05 butler Exp $ (BRL)";
@


9.36
log
@re-word status message for "autosize" command
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/chgview.c,v 9.35 91/08/25 04:28:42 butler Exp $ (BRL)";
a69 4
/* autosize: boolean - do auto-size & auto-center when bringing up geometry
 * on a blank display.
 */
static int	autosize = 1;
a70 9
/* Turn On/Off automatic re-center/re-size of display when
 * bringing up geometry on a blank display
 */
void
f_autosize(argc, argv)
int	argc;
char	**argv;
{
	register char *p;
a71 22
	if (argc <= 1) {
		/* toggle */
		autosize = !autosize;
	} else {
		p = argv[1];
		if (*p == '0') autosize = 0;
		else if (*p == '1') autosize = 1;
		else {
		    (void)printf(
			"autosize: No parameter toggles autosize,\n");
		    (void)printf(
			"valid parameters: '0' = disable, '1' = enable\n");
		}
	}
	if (autosize) {
		(void)fputs("Auto-size/center On\n", stdout );
	} else {
		(void)fputs("Auto-size/center Off\n", stdout );
	}
}


d286 1
a286 1
	if (autosize && initial_blank_screen &&
@


9.35
log
@added "autosize" command to enable/disable automatic view centering/sizing
on initial display.
q
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/chgview.c,v 9.34 91/06/30 21:16:43 mike Exp $ (BRL)";
d100 1
a100 1
		(void)fputs("Auto-center/size On\n", stdout );
d102 1
a102 1
		(void)fputs("Auto-center/size Off\n", stdout );
@


9.34
log
@Replaced local_unit[] with call to rt_units_string()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.33 91/06/25 16:07:24 pjt Exp $ (BRL)";
d70 37
d321 2
a322 1
	if( initial_blank_screen && HeadSolid.s_forw != &HeadSolid)  {
@


9.33
log
@Changed args in call to setview()
from ints to doubles
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.32 91/02/02 00:00:41 mike Exp $ (BRL)";
d869 1
a869 1
				local_unit[localunit] );
@


9.32
log
@Modified for new rt_vlist structures
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.31 91/01/26 03:22:50 mike Exp $ (BRL)";
d606 1
a606 1
	setview( 270 + atoi(argv[2]), 0, 270 - atoi(argv[1]) );
@


9.31
log
@Changed calling sequences for ft_plot, rt_id_solid, etc.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.30 91/01/23 22:38:48 mike Exp $ (BRL)";
d685 3
a687 1
	register struct vlist	*vp;
d718 17
a734 6
		for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
			printf("  %s (%g, %g, %g)\n",
				mged_vl_draw_message[vp->vl_draw],
				vp->vl_pnt[X],
				vp->vl_pnt[Y],
				vp->vl_pnt[Z] );
d736 1
@


9.30
log
@Converted do_list() entirely to new ft_describe() interface.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.29 91/01/15 23:47:23 mike Exp $ (BRL)";
d479 1
a479 1
	id = rt_id_solid( rp );
@


9.29
log
@Changed ell, tor, and poly solids to new import/export/describe interface
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.28 91/01/14 22:53:57 mike Exp $ (BRL)";
d360 3
a362 2


d370 5
a374 1
	int		id;
d376 4
a379 1
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
d381 2
d384 1
a478 2
	/* XXX This should run through the ft_switch[] table!! */
	/* XXX The result should be a variable length string */
d480 3
a482 14
	switch( id )  {
	case ID_ARB8:
		dbpr_arb( &rp[0].s, dp );
sol_com:
		/* This stuff ought to get pushed into the dbpr_xx code */
		pr_solid( &rp[0].s );

		for( i=0; i < es_nlines; i++ )
			(void)printf("%s\n",&es_display[ES_LINELEN*i]);

		/* If in solid edit, re-compute solid params */
		if(state == ST_S_EDIT)
			pr_solid(&es_rec.s);

a483 52
	default:
		printf("Unknown solid type, id=%d\n", id);
		break;

	case ID_BSPLINE:
		dbpr_spline( dp );
		break;

	case ID_EBM:
	case ID_VOL:
		(void)printf("%s: %s\n", dp->d_namep, rp->ss.ss_str );
		break;

	case ID_POLY:
	case ID_ELL:
	case ID_SPH:		/* shouldn't occur, special case of ID_ELL */
	case ID_TOR:
	case ID_ARS:
	case ID_HALF:
	case ID_PARTICLE:
	case ID_PIPE:
	case ID_ARBN:
	case ID_TGC:
	case ID_REC:		/* shouldn't occur, special case of ID_TGC */
		{
			struct rt_external	ext;
			struct rt_db_internal	intern;
			mat_t			ident;
			struct rt_vls		str;

			printf("%s:  ", dp->d_namep);
			RT_INIT_EXTERNAL(&ext);
			if( db_get_external( &ext, dp, dbip ) < 0 )  {
				printf("db_get_external failure\n");
				break;
			}
			mat_idn( ident );
			if( rt_functab[id].ft_import( &intern, &ext, ident ) < 0 )  {
				printf("database import error\n");
				db_free_external( &ext );
				break;
			}
			db_free_external( &ext );
			rt_vls_init( &str );
			if( rt_functab[id].ft_describe( &str, &intern,
			    verbose, base2local ) < 0 )
				printf("describe error\n");
			rt_functab[id].ft_ifree( &intern );
			fputs( rt_vls_addr( &str ), stdout );
			rt_vls_free( &str );
		}
		break;
d485 7
d494 1
a494 1
	if(rp) rt_free( (char *)rp, "do_list records");
@


9.28
log
@Removed erroneous ID_STRINGSOL
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.27 91/01/14 20:26:06 mike Exp $ (BRL)";
a485 6
	case ID_ELL:
		dbpr_ell( &rp[0].s, dp );
		goto sol_com;
	case ID_TOR:
		dbpr_torus( &rp[0].s, dp );
		goto sol_com;
a493 5
	case ID_POLY:
		(void)printf("%s:  %d granules of polygon data\n",
			dp->d_namep, dp->d_len-1 );
		break;

d498 5
d509 1
@


9.27
log
@Added ARS.
Passed "verbose" flag and base2local conversion through.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.26 91/01/12 08:25:46 mike Exp $ (BRL)";
a504 1
	case ID_STRINGSOL:
@


9.26
log
@externs.h
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.25 91/01/11 07:09:20 mike Exp $ (BRL)";
a495 11
	case ID_ARS:
		(void)printf("%s:  ARS\n", dp->d_namep );
		(void)printf(" num curves  %d\n", rp[0].a.a_m );
		(void)printf(" pts/curve   %d\n", rp[0].a.a_n );
		/* convert vertex from base unit to the local unit */
		(void)printf(" vertex      %.4f %.4f %.4f\n",
			rp[1].b.b_values[0]*base2local,
			rp[1].b.b_values[1]*base2local,
			rp[1].b.b_values[2]*base2local );
		break;

d510 1
d524 4
a527 2
			ext.ext_buf = (genptr_t)rp;
			ext.ext_nbytes = dp->d_len*sizeof(union record);
d529 5
a533 2
			if( rt_functab[id].ft_import( &intern, &ext, ident ) < 0 )
				printf("import error\n");
a534 1
			rp = (union record *)0;
d536 2
a537 1
			if( rt_functab[id].ft_describe( &str, &intern, 1 ) < 0 )
@


9.25
log
@Modified to begin using new import/export routines,
and ft_describe().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.24 91/01/11 04:02:06 mike Exp $ (BRL)";
a488 3
	case ID_HALF:
		dbpr_half( &rp[0].s, dp );
		goto sol_com;
d521 1
@


9.24
log
@Added description support for pipes as well.
Just a testing hack.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.23 91/01/09 02:18:48 mike Exp $ (BRL)";
a485 3
	case ID_TGC:
		dbpr_tgc( &rp[0].s, dp );
		goto sol_com;
a524 23
		{
			struct rt_external	ext;
			struct rt_db_internal	intern;
			mat_t			ident;
			struct rt_vls		str;

			printf("%s:  ", dp->d_namep);
			RT_INIT_EXTERNAL(&ext);
			ext.ext_buf = (genptr_t)rp;
			ext.ext_nbytes = dp->d_len*sizeof(union record);
			mat_idn( ident );
			if( rt_part_import( &intern, &ext, ident ) < 0 )
				printf("import error\n");
			db_free_external( &ext );
			rp = (union record *)0;
			rt_vls_init( &str );
			if( rt_part_describe( &str, &intern, 1 ) < 0 )
				printf("describe error\n");
			rt_part_ifree( &intern );
			fputs( rt_vls_addr( &str ), stdout );
			rt_vls_free( &str );
		}
		break;
d526 2
d539 1
a539 1
			if( rt_pipe_import( &intern, &ext, ident ) < 0 )
d544 1
a544 1
			if( rt_pipe_describe( &str, &intern, 1 ) < 0 )
d546 1
a546 1
			rt_pipe_ifree( &intern );
@


9.23
log
@Added beginnings of new interface to "solid description" subroutine
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.22 90/12/07 00:58:43 mike Exp $ (BRL)";
d547 25
a571 1
			printf("%s", rt_vls_addr( &str ) );
@


9.22
log
@lint
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.21 90/12/06 23:55:02 mike Exp $ (BRL)";
d50 4
a54 1
#include "raytrace.h"
a55 1
#include "externs.h"
a57 1
#include "nmg.h"
a60 3
extern int	atoi();
extern long	time();

a66 3
extern CONST double rt_degtorad;	/* XXX move to raytrace.h */
extern CONST double rt_radtodeg;	/* XXX move to raytrace.h */

d68 1
a68 1
void	f_zap();
d527 24
d554 1
a554 1
	rt_free( (char *)rp, "do_list records");
@


9.21
log
@Eliminated old big-E global variables.
For now, big-E command interface here is #ifdef'ed out.
Look in proc_reg.c
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.20 90/12/05 06:17:38 mike Exp $ (BRL)";
d776 1
a776 1
	struct solid *lastfound;
@


9.20
log
@Eliminated nmgtest
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.19 90/06/04 23:23:03 butler Exp $ (BRL)";
a64 2
int		drawreg;	/* if > 0, process and draw regions */

a156 2
	drawreg = 0;
	regmemb = -1;
a166 2
	drawreg = 0;
	regmemb = -1;
a175 2
	drawreg = 0;
	regmemb = -1;
d179 5
a195 2
	drawreg = 1;
	regmemb = -1;
d198 1
@


9.19
log
@added extra rt_printb to debugnmg & debuglib to print possible
bit flags when no arguments are given
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.18 90/05/22 21:42:35 mike Exp $ (BRL)";
a877 156
}


f_nmgtest( argc, argv )
int	argc;
char	**argv;
{
	register struct solid	*sp;
	struct model		*m;
	struct nmgregion	*r1;
	struct nmgregion	*r2;
	struct vlhead		vhead;
	struct directory	*dp;
	mat_t		mat;
	union record	*recp;
	int		i;
	point_t		minvalue, maxvalue;
	struct vlist	*vp;

	vhead.vh_first = vhead.vh_last = VL_NULL;

	mat_idn( mat );

	m = nmg_mm();		/* Make "model" */

	if( (dp = db_lookup( dbip, argv[1], LOOKUP_NOISY )) == DIR_NULL )
		goto out;
	recp = db_getmrec( dbip, dp );
	GET_SOLID( sp );

	/* Tessellate Solid to NMG */
	printf(" tess %s\n", dp->d_namep );
	if( rt_functab[rt_id_solid(recp)].ft_tessellate(
	    &r1, m, recp, mat, dp,
	    mged_abs_tol, mged_rel_tol, mged_nrm_tol ) < 0 )  {
		rt_log("%s tessellation failure\n", dp->d_namep);
	    	return;
	}
	nmg_ck_closed_region( r1 );	/* debug */
	NMG_CK_REGION( r1 );
	rt_free( (char *)recp, "record");

	for( i = 2; i+1 < argc; i += 2 )  {
		int	op;

		if( (dp = db_lookup( dbip, argv[i+1], LOOKUP_NOISY )) == DIR_NULL )
			continue;
		recp = db_getmrec( dbip, dp );

		/* Tessellate Solid to NMG */
		printf("  %s %s\n", argv[i], dp->d_namep );
		if( rt_functab[rt_id_solid(recp)].ft_tessellate(
		    &r2, m, recp, mat, dp,
		    mged_abs_tol, mged_rel_tol, mged_nrm_tol ) < 0 )  {
			rt_log("%s tessellation failure\n", dp->d_namep);
			rt_free( (char *)recp, "record");
			continue;
		}
		NMG_CK_REGION( r2 );
		nmg_ck_closed_region( r2 );	/* debug */
		rt_free( (char *)recp, "record");

		/* Bool */
		switch( argv[i][0] )  {
		case UNION:
			op = NMG_BOOL_ADD;
			break;
		case SUBTRACT:
			op = NMG_BOOL_SUB;
			break;
		case INTERSECT:
			op = NMG_BOOL_ISECT;
			break;
		default:
			printf("Operation '%c' unknown, using subtraction\n",
				argv[i][0] );
			op = NMG_BOOL_SUB;
		}
		/* input r1 and r2 are destroyed, output is new r1 */
		r1 = nmg_do_bool( r1, r2, op, 0.1 );
		NMG_CK_REGION( r1 );
		nmg_ck_closed_region( r1 );	/* debug */
	}

out:
	/* Convert NMG to vlist */
	/* 0 = vectors, 1 = w/polygon markers, 2 = polys with normals */
	nmg_r_to_vlist( &vhead, r1, 2 );

	/* Destroy NMG */
	nmg_km( m );

	VSET( sp->s_basecolor, 200, 200, 200 );	/* white, not red */

	/*
	 * Compute the min, max, and center points.
	 */
	VSETALL( maxvalue, -INFINITY );
	VSETALL( minvalue,  INFINITY );
	sp->s_vlist = vhead.vh_first;
	sp->s_vlen = 0;
	for( vp = vhead.vh_first; vp != VL_NULL; vp = vp->vl_forw )  {
		switch( vp->vl_draw )  {
		case VL_CMD_POLY_START:
			/* Has normal vector, not location */
			break;
		case VL_CMD_LINE_MOVE:
		case VL_CMD_LINE_DRAW:
		case VL_CMD_POLY_MOVE:
		case VL_CMD_POLY_DRAW:
		case VL_CMD_POLY_END:
			VMINMAX( minvalue, maxvalue, vp->vl_pnt );
			break;
		default:
			(void)printf("unknown vlist op %d\n", vp->vl_draw);
		}
		sp->s_vlen++;
	}
	nvectors += sp->s_vlen;

	VADD2SCALE( sp->s_center, minvalue, maxvalue, 0.5 );

	sp->s_size = maxvalue[X] - minvalue[X];
	MAX( sp->s_size, maxvalue[Y] - minvalue[Y] );
	MAX( sp->s_size, maxvalue[Z] - minvalue[Z] );

	sp->s_iflag = DOWN;
	sp->s_soldash = 0;

	sp->s_last = 0;
	sp->s_Eflag = 1;	/* This is processed region */

	/* Copy path information */
	sp->s_path[0] = dp;
	sp->s_regionid = -42;
	sp->s_addr = 0;
	sp->s_bytes = 0;

	/* Cvt to displaylist, determine displaylist memory requirement. */
	if( !no_memory && (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
		/* Allocate displaylist storage for object */
		sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
		if( sp->s_addr == 0 )  {
			no_memory = 1;
			(void)printf("draw: out of Displaylist\n");
			sp->s_bytes = 0;	/* not drawn */
		} else {
			sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes );
		}
	}

	/* Add to linked list of solid structs */
	APPEND_SOLID( sp, HeadSolid.s_back );
	dmp->dmr_viewchange( DM_CHGV_ADD, sp );

	dmaflag = 1;
@


9.18
log
@Changed to use VL_CMD_* definitions.  Added description of VL_CMD_*
stuff to "x" command.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.17 90/05/18 07:43:52 mike Exp $ (BRL)";
d337 3
d361 3
@


9.17
log
@Changed from processing shells to processing regions.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/chgview.c,v 9.16 90/05/09 20:00:56 mike Exp $ (BRL)";
d700 10
d737 1
a737 1
		(void)printf("  (%.3f,%.3f,%.3f) sz=%g ",
d742 2
a743 2
		(void)printf("reg=%d",sp->s_regionid );
		(void)printf(" (%d,%d,%d) %d,%d,%d i=%d\n",
d756 2
a757 1
			printf("%d (%g, %g, %g)\n", vp->vl_draw,
d974 14
a987 1
		VMINMAX( minvalue, maxvalue, vp->vl_pnt );
@


9.16
log
@Changed "enmg" to "ev", for "evaluate".
Move parallel processsing startup from hideline to ged.c
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.15 90/05/04 04:20:13 mike Locked $ (BRL)";
d899 1
a899 1
	nmg_ck_closed_surf( r1->s_p );	/* debug */
d920 1
a920 1
		nmg_ck_closed_surf( r2->s_p );	/* debug */
d942 1
a942 1
		nmg_ck_closed_surf( r1->s_p );	/* debug */
d948 1
a948 1
	nmg_s_to_vlist( &vhead, r1->s_p, 2 );
@


9.15
log
@Changed drawtrees to process options, using getopt().
Changed calling sequence to include argv[0].
Changed eedit() handling of deletions.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.14 90/05/04 03:47:39 mike Locked $ (BRL)";
d176 1
a176 1
/* Format: enmg objects	*/
d178 1
a178 1
f_enmg(argc, argv)
d283 2
@


9.14
log
@added "debugnmg" command
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.13 90/05/01 02:59:08 butler Locked $ (BRL)";
d267 11
a277 2
	/* First, delete any mention of these objects */
	f_delobj( argc, argv );
a283 7
	if( no_memory )  {
		(void)printf("No memory left\n");
		drawreg = 0;
		regmemb = -1;
		return;
	}

d286 1
a286 1
	drawtrees( argc-1, &argv[1], kind );
@


9.13
log
@Added normal tolerance support.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.12 90/04/26 02:15:27 mike Locked $ (BRL)";
d346 14
@


9.12
log
@Added f_tol command.
Added support for tolerance args to ft_plot() and ft_tess().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.11 90/04/24 01:59:00 mike Locked $ (BRL)";
d69 1
d71 3
d877 1
a877 1
	    mged_abs_tol, mged_rel_tol ) < 0 )  {
d895 2
a896 1
		    &r2, m, recp, mat, dp ) < 0 )  {
d922 1
a922 1
		r1 = nmg_do_bool( r1, r2, op );
d994 1
d1003 1
a1003 1
	if( argc != 3 )  {
d1018 16
d1038 2
a1039 1
	if( strcmp( argv[1], "abs" ) == 0 )  {
d1047 2
a1048 1
	if( strcmp( argv[1], "rel" ) == 0 )  {
d1055 10
@


9.11
log
@Allowed f_debugmem to be interrupted
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.10 90/04/24 01:05:23 mike Exp $ (BRL)";
d67 3
d144 1
a144 1
	f_zap();
d872 2
a873 1
	    &r1, m, recp, mat, dp ) < 0 )  {
d981 53
@


9.10
log
@Added f_debugmem command
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.9 90/04/21 06:05:22 mike Locked $ (BRL)";
d336 1
@


9.9
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.8 90/04/13 03:55:47 mike Locked $ (BRL)";
d329 8
@


9.8
log
@Changed to use new tree walker.
Big-E and solid edits are temporarily broken.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.7 90/03/16 03:46:36 mike Locked $ (BRL)";
d230 1
a230 1
		VSETALL( radial, 1 );
a276 1
	/* XXX For big-E, regmemb must be set to -1 after each object */
d651 10
a660 9
			if( sp->s_path[i] == dp )  {
				if( state != ST_VIEW && illump == sp )
					button( BE_REJECT );
				dmp->dmr_viewchange( DM_CHGV_DEL, sp );
				memfree( &(dmp->dmr_map), sp->s_bytes, (unsigned long)sp->s_addr );
				DEQUEUE_SOLID( sp );
				FREE_SOLID( sp );
				break;
			}
d781 1
a781 1
	f_ill();		/* Illuminate named solid --> ST_S_EDIT */
@


9.7
log
@More checking.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.6 90/03/15 02:04:37 mike Locked $ (BRL)";
a65 2
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */
d70 18
d91 3
a93 1
f_center()
d96 3
a98 3
	toViewcenter[MDX] = -atof( cmd_args[1] ) * local2base;
	toViewcenter[MDY] = -atof( cmd_args[2] ) * local2base;
	toViewcenter[MDZ] = -atof( cmd_args[3] ) * local2base;
d104 3
a106 1
f_vrot()
d113 3
a115 3
	usejoy(	atof(cmd_args[1]) * degtorad,
		atof(cmd_args[2]) * degtorad,
		atof(cmd_args[3]) * degtorad );
d121 3
a123 1
f_view()
d126 1
a126 1
	f = atof( cmd_args[1] );
d136 3
a138 1
f_blast()
d154 1
a154 1
	eedit();
a156 1
int	use_nmg_flag = 0;	/* XXX temporary.  Used by dodraw.c */
d160 3
a162 1
f_edit()
a163 1
	use_nmg_flag = 0;	/* XXX */
d166 1
a166 1
	eedit();
d171 3
a173 1
f_enmg()
a174 1
	use_nmg_flag = 1;
d177 1
a177 2
	eedit();
	use_nmg_flag = 0;
d188 3
a190 1
f_evedit()
a191 1
	use_nmg_flag = 0;
d194 1
a194 1
	eedit();
d248 4
a251 1
eedit()
d256 1
a256 1
	static int	first_time = 1;
d258 1
a258 5
	nvectors = 0;
	(void)time( &stime );
	for( i=1; i < numargs; i++ )  {
		if( (dp = db_lookup( dbip,  cmd_args[i], LOOKUP_NOISY )) == DIR_NULL )
			continue;
d260 7
a266 10
		if( dmp->dmr_displaylist )  {
			/*
			 * Delete any portion of object
			 * remaining from previous draw.
			 */
			eraseobj( dp );
			dmaflag++;
			refresh();
			dmaflag++;
		}
d268 3
a270 14
		/*
		 * Draw this object as a ROOT object, level 0
		 * on the path, with no displacement, and
		 * unit scale.
		 */
		if( no_memory )  {
			(void)printf("No memory left so cannot draw %s\n",
				dp->d_namep);
			drawreg = 0;
			regmemb = -1;
			continue;
		}

		drawtree( dp );
d272 1
d274 5
d280 4
a283 2
	if( first_time && HeadSolid.s_forw != &HeadSolid)  {
		first_time = 0;
a287 1
	(void)printf("%ld vectors in %ld sec\n", nvectors, etime - stime );
a291 2
/* Delete an object or several objects from the display */
/* Format: d object1 object2 .... objectn */
a292 14
f_delobj()
{
	register struct directory *dp;
	register int i;

	for( i = 1; i < numargs; i++ )  {
		if( (dp = db_lookup( dbip,  cmd_args[i], LOOKUP_NOISY )) != DIR_NULL )
			eraseobj( dp );
	}
	no_memory = 0;
	dmaflag = 1;
}

void
d306 3
a308 1
f_regdebug()
d312 1
a312 1
	if( numargs <= 1 )
d315 1
a315 1
		regdebug = atoi( cmd_args[1] );
d321 3
a323 1
f_debuglib()
d325 2
a326 2
	if( numargs >= 2 )  {
		sscanf( cmd_args[1], "%x", &rt_g.debug );
d544 3
a546 1
f_zap()
d571 3
a573 1
f_status()
d590 3
a592 1
f_fix()
d599 3
a601 1
f_refresh()
d608 3
a610 1
f_aeview()
d612 1
a612 1
	setview( 270 + atoi(cmd_args[2]), 0, 270 - atoi(cmd_args[1]) );
d616 3
a618 1
f_attach()
d620 1
a620 1
	if (numargs == 1)
d623 1
a623 1
		attach( cmd_args[1] );
d627 3
a629 1
f_release()
d723 3
a725 1
f_ill()
d733 1
a733 1
	if( (dp = db_lookup( dbip,  cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
d751 1
a751 1
		(void)printf("%s not being displayed\n", cmd_args[1]);
d755 1
a755 1
		(void)printf("%s multiply referenced\n", cmd_args[1]);
d773 3
a775 1
f_sed()
d786 3
a788 1
f_knob()
d792 1
a792 1
	if(numargs == 2)
d795 1
a795 1
		f = atof(cmd_args[2]);
d801 1
a801 1
	switch( cmd_args[1][0] )  {
@


9.6
log
@Minor changes for nmg debugging.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.5 90/03/14 21:22:02 mike Locked $ (BRL)";
d839 1
d843 1
a843 1
	for( i = 2; i < argc; i += 2 )  {
d859 1
@


9.5
log
@Added debugging levels to f_debug().
Added temporary routine f_nmgtest() for testing NMG booleans.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.4 89/12/28 14:38:07 mike Locked $ (BRL)";
d879 1
d884 2
a885 2
	/* 0 = vectors, 1 = w/polygon markers */
	nmg_s_to_vlist( &vhead, m->r_p->s_p, 1 );
d890 1
a890 1
	VSET( sp->s_basecolor, 255, 0, 0 );
d903 1
@


9.4
log
@f_list ('l' command) gives "verbose" listing, same as before.
f_cat ('cat' command) gives "brief" listing, in columns.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.3 89/10/13 20:40:07 mike Locked $ (BRL)";
d56 1
d292 3
a294 1
f_debug()
d296 4
d301 1
a301 1
	pr_schain( &HeadSolid );
d655 1
a655 1
pr_schain( startp )
d657 1
d659 3
a661 2
	register struct solid *sp;
	register int i;
d663 1
a663 2
	sp = startp->s_forw;
	while( sp != startp )  {
d670 3
d688 10
a697 1
		sp = sp->s_forw;
d802 137
@


9.3
log
@Added support for listing ID_EBM, ID_VOL solids.
Began reorganization to move this stuff into
"describe your solid" functions in the geometry routines.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.2 89/10/10 16:31:42 mike Exp $ (BRL)";
d321 1
a321 1
do_list( dp )
d323 1
d358 1
d360 7
d369 2
a370 2
			(void)printf("  %c %s",
				rp[i].M.m_relation, rp[i].M.m_instname );
a371 5
			if( xmat[0] != 1.0 || xmat[5] != 1.0 || xmat[10] != 1.0 )  {
				fastf_t	az, el;
				ae_vec( &az, &el, xmat );
				(void)printf(" az=%g, el=%g, ", az, el );
			}
d375 2
a376 4
				(void)printf(" [%f,%f,%f]",
					xmat[MDX]*base2local,
					xmat[MDY]*base2local,
					xmat[MDZ]*base2local);
d380 41
a420 3
				(void)printf(" ??Perspective=[%f,%f,%f]??",
					xmat[12], xmat[13], xmat[14] );
			(void)putchar('\n');
d422 1
d491 1
a491 1
/* List object information */
d494 3
a496 1
f_list()
d502 2
a503 2
	for( arg = 1; arg < numargs; arg++ )  {
		if( (dp = db_lookup( dbip,  cmd_args[arg], LOOKUP_NOISY )) == DIR_NULL )
d506 20
a525 1
		do_list( dp );
@


9.2
log
@Added f_enmg(), a preliminary routine
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 9.1 89/05/19 06:01:59 mike Rel3_5 $ (BRL)";
d326 1
d331 22
a352 20
	if( rp[0].u_id == ID_SOLID )  {
		switch( rp[0].s.s_type )  {
		case GENARB8:
			dbpr_arb( &rp[0].s, dp );
			break;
		case GENTGC:
			dbpr_tgc( &rp[0].s, dp );
			break;
		case GENELL:
			dbpr_ell( &rp[0].s, dp );
			break;
		case HALFSPACE:
			dbpr_half( &rp[0].s, dp );
			break;
		case TOR:
			dbpr_torus( &rp[0].s, dp );
			break;
		default:
			printf("bad solid type %d\n", rp[0].s.s_type );
			break;
d355 37
d403 15
a417 1
	}
d419 1
a419 1
	if( rp[0].u_id == ID_ARS_A )  {
d428 3
a430 3
		goto out;
	}
	if( rp[0].u_id == ID_BSOLID ) {
d432 3
a434 3
		goto out;
	}
	if( rp[0].u_id == ID_P_HEAD )  {
d437 1
a437 7
		goto out;
	}
	if( rp[0].u_id != ID_COMB )  {
		(void)printf("%s: unknown record type!\n",
			dp->d_namep );
		goto out;
	}
d439 5
a443 21
	/* Combination */
	(void)printf("%s (len %d) ", dp->d_namep, dp->d_len-1 );
	if( rp[0].c.c_flags == 'R' )
		(void)printf("REGION id=%d  (air=%d, los=%d, GIFTmater=%d) ",
			rp[0].c.c_regionid,
			rp[0].c.c_aircode,
			rp[0].c.c_los,
			rp[0].c.c_material );
	(void)printf("--\n");
	if( rp[0].c.c_matname[0] )
		(void)printf("Material '%s' '%s'\n",
			rp[0].c.c_matname,
			rp[0].c.c_matparm);
	if( rp[0].c.c_override == 1 )
		(void)printf("Color %d %d %d\n",
			rp[0].c.c_rgb[0],
			rp[0].c.c_rgb[1],
			rp[0].c.c_rgb[2]);
	if( rp[0].c.c_matname[0] || rp[0].c.c_override )  {
		if( rp[0].c.c_inherit == DB_INH_HIGHER )
			(void)printf("(These material properties override all lower ones in the tree)\n");
a445 24
	for( i=1; i < dp->d_len; i++ )  {
		mat_t	xmat;

		rt_mat_dbmat( xmat, rp[i].M.m_mat );

		(void)printf("  %c %s",
			rp[i].M.m_relation, rp[i].M.m_instname );

		if( xmat[0] != 1.0 || xmat[5] != 1.0 || xmat[10] != 1.0 )
			(void)printf(" (Rotated)");
		if( xmat[MDX] != 0.0 ||
		    xmat[MDY] != 0.0 ||
		    xmat[MDZ] != 0.0 )
			(void)printf(" [%f,%f,%f]",
				xmat[MDX]*base2local,
				xmat[MDY]*base2local,
				xmat[MDZ]*base2local);
		if( xmat[12] != 0.0 ||
		    xmat[13] != 0.0 ||
		    xmat[14] != 0.0 )
			(void)printf(" ??Perspective=[%f,%f,%f]??",
				xmat[12], xmat[13], xmat[14] );
		(void)putchar('\n');
	}
@


9.1
log
@Release_3.5
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 8.5 89/04/06 20:38:57 mike Exp $ (BRL)";
d132 1
d138 1
d144 11
d165 1
@


8.5
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 8.4 89/01/18 01:55:56 mike Locked $ (BRL)";
@


8.4
log
@Includes changes in how MGED colors the various solids.
Externally, the color selection now matches that used by RT.
Internally, this was accomplished by adding 3 more fields
to the solid table (s_basecolor[], s_color[], s_dmindex),
and eliminating the mt_dm_int value from the region-id-based
material table.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 8.3 89/01/16 22:51:43 mike Locked $ (BRL)";
d53 1
@


8.3
log
@drawHobj() --> drawtree()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 8.2 88/12/06 00:59:00 mike Locked $ (BRL)";
d389 1
a389 1
	if( rp[0].c.c_override == 1)
d578 1
a578 1
		(void)printf("    (%.3f, %.3f, %.3f) sz=%.4f ",
d584 8
a591 7
		if( sp->s_materp )  {
			register struct mater *mp;
			if( (mp = (struct mater *)sp->s_materp) != MATER_NULL)
				(void)printf(" dm%d",
					mp->mt_dm_int );
		}
		(void)printf("\n");
@


8.2
log
@Converted to new db_*() routines.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/chgview.c,v 1.3 88/10/29 22:53:35 mike Exp $ (BRL)";
d244 1
a244 1
		drawHobj( dp, ROOT, 0, identity, 0 );
@


8.1
log
@Release_3.0
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.8 88/09/16 03:48:28 reschly Exp $ (BRL)";
d51 1
a52 1
#include "./objdir.h"
d56 2
d61 2
d141 7
a147 2
/* Evaluated Edit something (add to visible display) */
/* E object */
d157 45
d210 3
a212 2
	register int i;
	static long stime, etime;	/* start & end times */
d214 1
d217 1
a217 1
		if( (dp = lookup( cmd_args[i], LOOKUP_NOISY )) == DIR_NULL )
d248 3
a250 2
	if( Viewscale == .125 )  {	/* also in ged.c */
		Viewscale = maxview;
d254 1
a254 1
	(void)printf("vectorized in %ld sec\n", etime - stime );
d268 1
a268 1
		if( (dp = lookup( cmd_args[i], LOOKUP_NOISY )) != DIR_NULL )
d296 10
d309 2
a310 2
	register int i;
	union record record;
d312 2
a313 1
	db_getrec( dp, &record, 0 );
d315 2
a316 2
	if( record.u_id == ID_SOLID )  {
		switch( record.s.s_type )  {
d318 1
a318 1
			dbpr_arb( &record.s, dp );
d321 1
a321 1
			dbpr_tgc( &record.s, dp );
d324 1
a324 1
			dbpr_ell( &record.s, dp );
d327 1
a327 1
			dbpr_half( &record.s, dp );
d330 1
a330 1
			dbpr_torus( &record.s, dp );
d333 1
a333 1
			printf("bad solid type %d\n", record.s.s_type );
d338 1
a338 1
		pr_solid( &record.s );
d347 1
a347 1
		return;
d350 1
a350 1
	if( record.u_id == ID_ARS_A )  {
d352 2
a353 4
		db_getrec( dp, &record, 0 );
		(void)printf(" num curves  %d\n", record.a.a_m );
		(void)printf(" pts/curve   %d\n", record.a.a_n );
		db_getrec( dp, &record, 1 );
d356 4
a359 4
			record.b.b_values[0]*base2local,
			record.b.b_values[1]*base2local,
			record.b.b_values[2]*base2local );
		return;
d361 1
a361 1
	if( record.u_id == ID_BSOLID ) {
d363 1
a363 1
		return;
d365 1
a365 1
	if( record.u_id == ID_P_HEAD )  {
d368 1
a368 1
		return;
d370 1
a370 1
	if( record.u_id != ID_COMB )  {
d373 1
a373 1
		return;
d378 1
a378 1
	if( record.c.c_flags == 'R' )
d380 4
a383 4
			record.c.c_regionid,
			record.c.c_aircode,
			record.c.c_los,
			record.c.c_material );
d385 1
a385 1
	if( record.c.c_matname[0] )
d387 3
a389 3
			record.c.c_matname,
			record.c.c_matparm);
	if( record.c.c_override == 1)
d391 5
a395 5
			record.c.c_rgb[0],
			record.c.c_rgb[1],
			record.c.c_rgb[2]);
	if( record.c.c_matname[0] || record.c.c_override )  {
		if( record.c.c_inherit == DB_INH_HIGHER )
d402 1
a402 2
		db_getrec( dp, &record, i );
		rt_mat_dbmat( xmat, record.M.m_mat );
d405 1
a405 1
			record.M.m_relation, record.M.m_instname );
d423 2
d437 1
a437 1
		if( (dp = lookup( cmd_args[arg], LOOKUP_NOISY )) == DIR_NULL )
a474 1
	(void)printf("maxview=%f, ", maxview*base2local);
d606 1
a606 1
	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
@


7.8
log
@attach now does a get_attached if no device is spec'd.  knob now zeros the
respective knob if the value is missing.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.7 88/02/27 01:06:38 reschly Locked $ (BRL)";
@


7.7
log
@Split RT-interfaces into new module, rtif.c
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.6 88/02/25 06:04:45 mike Locked $ (BRL)";
d445 4
a448 1
	attach( cmd_args[1] );
d595 9
a603 5
	f = atof(cmd_args[2]);
	if( f < -1.0 )
		f = -1.0;
	else if( f > 1.0 )
		f = 1.0;
d627 1
a627 1
		(void)printf("x,y,z for joystick, Z for zoom, X,Y for slew\n");
@


7.6
log
@Modified for new vector lists
@
text
@a18 3
 *	f_rt		ray-trace
 *	f_rrt		ray-trace using any program
 *	f_saveview	save the current view parameters
a25 2
 *	f_rmats		load views from a file
 *	f_savekey	save keyframe in file
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.5 88/01/26 06:07:02 mike Locked $ (BRL)";
d56 1
a56 2
extern void	perror();
extern int	atoi(), execl(), fork(), nice(), wait();
a58 1
extern char	*filename;	/* Name of database file */
a434 378
/*
 *  			R T _ O L D W R I T E
 *  
 *  Write out the information that RT's -M option needs to show current view.
 *  Note that the model-space location of the eye is a parameter,
 *  as it can be computed in different ways.
 *  The is the OLD format, needed only when sending to RT on a pipe,
 *  due to some oddball hackery in RT to determine old -vs- new format.
 */
HIDDEN void
rt_oldwrite(fp, eye_model)
FILE *fp;
vect_t eye_model;
{
	register int i;

	(void)fprintf(fp, "%.9e\n", VIEWSIZE );
	(void)fprintf(fp, "%.9e %.9e %.9e\n",
		eye_model[X], eye_model[Y], eye_model[Z] );
	for( i=0; i < 16; i++ )  {
		(void)fprintf( fp, "%.9e ", Viewrot[i] );
		if( (i%4) == 3 )
			(void)fprintf(fp, "\n");
	}
	(void)fprintf(fp, "\n");
}

/*
 *  			R T _ W R I T E
 *  
 *  Write out the information that RT's -M option needs to show current view.
 *  Note that the model-space location of the eye is a parameter,
 *  as it can be computed in different ways.
 */
HIDDEN void
rt_write(fp, eye_model)
FILE *fp;
vect_t eye_model;
{
	register int i;

	(void)fprintf(fp, "viewsize %.9e;\n", VIEWSIZE );
	(void)fprintf(fp, "eye_pt %.9e %.9e %.9e;\n",
		eye_model[X], eye_model[Y], eye_model[Z] );
	(void)fprintf(fp, "viewrot ");
	for( i=0; i < 16; i++ )  {
		(void)fprintf( fp, "%.9e ", Viewrot[i] );
		if( (i%4) == 3 )
			(void)fprintf(fp, "\n");
	}
	(void)fprintf(fp, ";\n");
	(void)fprintf(fp, "start 0;\nend;\n");
}

/*
 *  			R T _ R E A D
 *  
 *  Read in one view in RT format.
 */
HIDDEN int
rt_read(fp, scale, eye, mat)
FILE	*fp;
fastf_t	*scale;
vect_t	eye;
mat_t	mat;
{
	register int i;
	double d;

	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	*scale = d*0.5;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[X] = d;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[Y] = d;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[Z] = d;
	for( i=0; i < 16; i++ )  {
		if( fscanf( fp, "%lf", &d ) != 1 )
			return(-1);
		mat[i] = d;
	}
	return(0);
}

#define LEN 32
void
f_rt()
{
	register char **vp;
	register struct solid *sp;
	register int i;
	int pid, rpid;
	int retcode;
	int o_pipe[2];
	char *vec[LEN];
	char *dm;
	FILE *fp;

	if( not_state( ST_VIEW, "Ray-trace of current view" ) )
		return;

	/*
	 * This may be a workstation where RT and MGED have to share the
	 * display, so let display go.  We will try to reattach at the end.
	 */
	dm = dmp->dmr_name;
	release();

	vp = &vec[0];
	*vp++ = "rt";
	*vp++ = "-s50";
	*vp++ = "-M";
	for( i=1; i < numargs; i++ )
		*vp++ = cmd_args[i];
	*vp++ = filename;

	/* Find all unique top-level entrys.
	 *  Mark ones already done with s_iflag == UP
	 */
	FOR_ALL_SOLIDS( sp )
		sp->s_iflag = DOWN;
	FOR_ALL_SOLIDS( sp )  {
		register struct solid *forw;	/* XXX */

		if( sp->s_iflag == UP )
			continue;
		if( vp < &vec[LEN] )
			*vp++ = sp->s_path[0]->d_namep;
		else
			(void)printf("ran out of vec for %s\n",
				sp->s_path[0]->d_namep );
		sp->s_iflag = UP;
		for( forw=sp->s_forw; forw != &HeadSolid; forw=forw->s_forw) {
			if( forw->s_path[0] == sp->s_path[0] )
				forw->s_iflag = UP;
		}
	}
	*vp = (char *)0;

	vp = &vec[0];
	while( *vp )
		(void)printf("%s ", *vp++ );
	(void)printf("\n");

	(void)pipe( o_pipe );
	(void)signal( SIGINT, SIG_IGN );
	if ( ( pid = fork()) == 0 )  {
		(void)close(0);
		(void)dup( o_pipe[0] );
		for( i=3; i < 20; i++ )
			(void)close(i);

		(void)signal( SIGINT, SIG_DFL );
		(void)execvp( "rt", vec );
		perror( "rt" );
		exit(42);
	}
	/* Connect up to pipe */
	(void)close( o_pipe[0] );
	fp = fdopen( o_pipe[1], "w" );
	{
		vect_t temp;
		vect_t eye_model;

		VSET( temp, 0, 0, 1 );
		MAT4X3PNT( eye_model, view2model, temp );
		rt_oldwrite(fp, eye_model );
	}
	(void)fclose( fp );
	
	/* Wait for rt to finish */
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;	/* NULL */
	if( retcode != 0 )
		(void)printf("Abnormal exit status x%x\n", retcode);
	(void)signal(SIGINT, cur_sigint);

	FOR_ALL_SOLIDS( sp )
		sp->s_iflag = DOWN;

	if( retcode == 0 )  {
		/* Wait for a return, then reattach display */
		printf("Press RETURN to reattach\007\n");
		while( getchar() != '\n' )
			/* NIL */  ;
	}
	attach( dm );
}

/*
 *			F _ R R T
 *
 *  Invoke any program with the current view & stuff, just like
 *  an "rt" command (above).
 *  Typically used to invoke a remote RT (hence the name).
 */
void
f_rrt()
{
	register char **vp;
	register struct solid *sp;
	register int i;
	int pid, rpid;
	int retcode;
	int o_pipe[2];
	char *vec[LEN];
	char *dm;
	FILE *fp;

	if( not_state( ST_VIEW, "Ray-trace of current view" ) )
		return;

	/*
	 * This may be a workstation where RT and MGED have to share the
	 * display, so let display go.  We will try to reattach at the end.
	 */
	dm = dmp->dmr_name;
	release();

	vp = &vec[0];
	for( i=1; i < numargs; i++ )
		*vp++ = cmd_args[i];
	*vp++ = filename;

	/* Find all unique top-level entrys.
	 *  Mark ones already done with s_iflag == UP
	 */
	FOR_ALL_SOLIDS( sp )
		sp->s_iflag = DOWN;
	FOR_ALL_SOLIDS( sp )  {
		register struct solid *forw;	/* XXX */

		if( sp->s_iflag == UP )
			continue;
		if( vp < &vec[LEN] )
			*vp++ = sp->s_path[0]->d_namep;
		else
			(void)printf("ran out of vec for %s\n",
				sp->s_path[0]->d_namep );
		sp->s_iflag = UP;
		for( forw=sp->s_forw; forw != &HeadSolid; forw=forw->s_forw) {
			if( forw->s_path[0] == sp->s_path[0] )
				forw->s_iflag = UP;
		}
	}
	*vp = (char *)0;

	vp = &vec[0];
	while( *vp )
		(void)printf("%s ", *vp++ );
	(void)printf("\n");

	(void)pipe( o_pipe );
	(void)signal( SIGINT, SIG_IGN );
	if ( ( pid = fork()) == 0 )  {
		(void)close(0);
		(void)dup( o_pipe[0] );
		for( i=3; i < 20; i++ )
			(void)close(i);

		(void)signal( SIGINT, SIG_DFL );
		(void)execvp( cmd_args[1], vec );
		perror( cmd_args[1] );
		exit(42);
	}
	/* Connect up to pipe */
	(void)close( o_pipe[0] );
	fp = fdopen( o_pipe[1], "w" );
	{
		vect_t temp;
		vect_t eye_model;

		VSET( temp, 0, 0, 1 );
		MAT4X3PNT( eye_model, view2model, temp );
		rt_oldwrite(fp, eye_model );
	}
	(void)fclose( fp );
	
	/* Wait for rt to finish */
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;	/* NULL */
	if( retcode != 0 )
		(void)printf("Abnormal exit status x%x\n", retcode);
	(void)signal(SIGINT, cur_sigint);

	FOR_ALL_SOLIDS( sp )
		sp->s_iflag = DOWN;

	if( retcode == 0 )  {
		/* Wait for a return, then reattach display */
		printf("Press RETURN to reattach\007\n");
		while( getchar() != '\n' )
			/* NIL */  ;
	}
	attach( dm );
}

/*
 *  				B A S E N A M E
 *  
 *  Return basename of path, removing leading slashes and trailing suffix.
 */
static char *
basename( p1, suff )
register char *p1, *suff;
{
	register char *p2, *p3;
	static char buf[128];

	p2 = p1;
	while (*p1) {
		if (*p1++ == '/')
			p2 = p1;
	}
	for(p3=suff; *p3; p3++) 
		;
	while(p1>p2 && p3>suff)
		if(*--p3 != *--p1)
			return(p2);
	strncpy( buf, p2, p1-p2 );
	return(buf);
}

void
f_saveview()
{
	register struct solid *sp;
	register int i;
	register FILE *fp;
	char *base;

	if( (fp = fopen( cmd_args[1], "a")) == NULL )  {
		perror(cmd_args[1]);
		return;
	}
	base = basename( cmd_args[1], ".sh" );
	(void)chmod( cmd_args[1], 0755 );	/* executable */
	(void)fprintf(fp, "#!/bin/sh\nrt -M ");
	for( i=2; i < numargs; i++ )
		(void)fprintf(fp,"%s ", cmd_args[i]);
	(void)fprintf(fp,"$*\\\n -o %s.pix\\\n", base);
	(void)fprintf(fp," %s\\\n ", filename);

	/* Find all unique top-level entrys.
	 *  Mark ones already done with s_iflag == UP
	 */
	FOR_ALL_SOLIDS( sp )
		sp->s_iflag = DOWN;
	FOR_ALL_SOLIDS( sp )  {
		register struct solid *forw;	/* XXX */

		if( sp->s_iflag == UP )
			continue;
		(void)fprintf(fp, "'%s' ", sp->s_path[0]->d_namep);
		sp->s_iflag = UP;
		for( forw=sp->s_forw; forw != &HeadSolid; forw=forw->s_forw) {
			if( forw->s_path[0] == sp->s_path[0] )
				forw->s_iflag = UP;
		}
	}
	(void)fprintf(fp,"\\\n 2> %s.log\\\n", base);
	(void)fprintf(fp," <<EOF\n");
	{
		vect_t temp;
		vect_t eye_model;

		VSET( temp, 0, 0, 1 );
		MAT4X3PNT( eye_model, view2model, temp );
		rt_write(fp, eye_model);
	}
	(void)fprintf(fp,"\nEOF\n");
	(void)fclose( fp );
	
	FOR_ALL_SOLIDS( sp )
		sp->s_iflag = DOWN;
}

a622 149
}

/*
 *			F _ R M A T S
 *
 * Load view matrixes from a file.  rmats filename [mode]
 *
 * Modes:
 *	-1	put eye in viewcenter (default)
 *	0	put eye in viewcenter, don't rotate.
 *	1	leave view alone, animate solid named "EYE"
 */
void
f_rmats()
{
	register FILE *fp;
	register struct directory *dp;
	register struct solid *sp;
	union record	rec;
	vect_t	eye_model;
	vect_t	xlate;
	vect_t	sav_center;
	vect_t	sav_start;
	int	mode;
	fastf_t	scale;
	mat_t	rot;
	register struct vlist *vp;

	if( not_state( ST_VIEW, "animate from matrix file") )
		return;

	if( (fp = fopen(cmd_args[1], "r")) == NULL )  {
		perror(cmd_args[1]);
		return;
	}
	mode = -1;
	if( numargs > 2 )
		mode = atoi(cmd_args[2]);
	switch(mode)  {
	case 1:
		if( (dp=lookup("EYE",LOOKUP_NOISY)) == DIR_NULL )  {
			mode = -1;
			break;
		}
		db_getrec( dp, &rec, 0 );
		FOR_ALL_SOLIDS(sp)  {
			if( sp->s_path[sp->s_last] != dp )  continue;
			if( sp->s_vlist == VL_NULL )  continue;
			VMOVE( sav_start, sp->s_vlist->vl_pnt );
			VMOVE( sav_center, sp->s_center );
			printf("animating EYE solid\n");
			goto work;
		}
		/* Fall through */
	default:
	case -1:
		mode = -1;
		printf("default mode:  eyepoint at (0,0,1) viewspace\n");
		break;
	case 0:
		printf("rotation supressed, center is eyepoint\n");
		break;
	}
work:
	/* If user hits ^C, this will stop, but will leave hanging filedes */
	(void)signal(SIGINT, cur_sigint);
	while( !feof( fp ) &&
	    rt_read( fp, &scale, eye_model, rot ) >= 0 )  {
	    	switch(mode)  {
	    	case -1:
	    		/* First step:  put eye in center */
		       	Viewscale = scale;
		       	mat_copy( Viewrot, rot );
			MAT_DELTAS( toViewcenter,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
	    		new_mats();
	    		/* Second step:  put eye in front */
	    		VSET( xlate, 0, 0, -1 );	/* correction factor */
	    		MAT4X3PNT( eye_model, view2model, xlate );
			MAT_DELTAS( toViewcenter,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
	    		new_mats();
	    		break;
	    	case 0:
		       	Viewscale = scale;
			mat_idn(Viewrot);	/* top view */
			MAT_DELTAS( toViewcenter,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
			new_mats();
	    		break;
	    	case 1:
	    		/* Adjust center for displaylist devices */
	    		VMOVE( sp->s_center, eye_model );

	    		/* Adjust vector list for non-dl devices */
	    		if( sp->s_vlist == VL_NULL )  break;
	    		VSUB2( xlate, eye_model, sp->s_vlist->vl_pnt );
			for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
				VADD2( vp->vl_pnt, vp->vl_pnt, xlate );
			}
	    		break;
	    	}
		dmaflag = 1;
		refresh();	/* Draw new display */
	}
	if( mode == 1 )  {
    		VMOVE( sp->s_center, sav_center );
		if( sp->s_vlist != VL_NULL )  {
	    		VSUB2( xlate, sav_start, sp->s_vlist->vl_pnt );
			for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
				VADD2( vp->vl_pnt, vp->vl_pnt, xlate );
			}
		}
	}
	dmaflag = 1;
	fclose(fp);
}

/* Save a keyframe to a file */
void
f_savekey()
{
	register int i;
	register FILE *fp;
	fastf_t	time;
	vect_t	eye_model;
	vect_t temp;

	if( (fp = fopen( cmd_args[1], "a")) == NULL )  {
		perror(cmd_args[1]);
		return;
	}
	if( numargs > 2 ) {
		time = atof( cmd_args[2] );
		(void)fprintf(fp,"%f\n", time);
	}
	/*
	 *  Eye is in conventional place.
	 */
	VSET( temp, 0, 0, 1 );
	MAT4X3PNT( eye_model, view2model, temp );
	rt_oldwrite(fp, eye_model);
	(void)fclose( fp );
@


7.5
log
@Added more detailed printing of material properties,
added a message when inherit is set to DB_INH_HIGHER
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.4 88/01/13 16:36:34 mike Locked $ (BRL)";
d1034 1
a1034 2
	register struct veclist *vp;
	register int nvec;
d1054 6
a1059 6
			if( sp->s_path[sp->s_last] == dp )  {
				VMOVE( sav_start, sp->s_vlist->vl_pnt );
				VMOVE( sav_center, sp->s_center );
				printf("animating EYE solid\n");
				goto work;
			}
d1109 1
d1111 1
a1111 2
			nvec = sp->s_vlen;
			for( vp = sp->s_vlist; nvec-- > 0; vp++ )  {
d1121 5
a1125 4
    		VSUB2( xlate, sav_start, sp->s_vlist->vl_pnt );
		nvec = sp->s_vlen;
		for( vp = sp->s_vlist; nvec-- > 0; vp++ )  {
			VADD2( vp->vl_pnt, vp->vl_pnt, xlate );
@


7.4
log
@Fprintf needed a lf to get the double read correctly
on the 4d's
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.3 87/11/05 07:09:05 mike Exp $ (BRL)";
d326 12
a337 10
	if( record.c.c_override == 1 || record.c.c_matname[0] != '\0' )  {
		if( record.c.c_matname[0] )
			(void)printf("Material '%s' '%s'\n",
				record.c.c_matname,
				record.c.c_matparm);
		if( record.c.c_override == 1)
			(void)printf("Color %d %d %d\n",
				record.c.c_rgb[0],
				record.c.c_rgb[1],
				record.c.c_rgb[2]);
@


7.3
log
@Changed to use rt_mat_dbmat and rt_dbmat_mat
to convert between database and internal formats.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.2 87/11/05 05:03:51 mike Locked $ (BRL)";
d509 1
a509 1
	if( fscanf( fp, "%f", &d ) != 1 )  return(-1);
d511 1
a511 1
	if( fscanf( fp, "%f", &d ) != 1 )  return(-1);
d513 1
a513 1
	if( fscanf( fp, "%f", &d ) != 1 )  return(-1);
d515 1
a515 1
	if( fscanf( fp, "%f", &d ) != 1 )  return(-1);
d518 1
a518 1
		if( fscanf( fp, "%f", &d ) != 1 )
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 7.1 87/11/02 23:58:50 mike Rel $ (BRL)";
d339 2
d342 2
d347 1
a347 2
#define Mat record.M.m_mat
		if( Mat[0] != 1.0 || Mat[5] != 1.0 || Mat[10] != 1.0 )
d349 3
a351 3
		if( Mat[MDX] != 0.0 ||
		    Mat[MDY] != 0.0 ||
		    Mat[MDZ] != 0.0 )
d353 6
a358 6
				Mat[MDX]*base2local,
				Mat[MDY]*base2local,
				Mat[MDZ]*base2local);
		if( Mat[12] != 0.0 ||
		    Mat[13] != 0.0 ||
		    Mat[14] != 0.0 )
d360 1
a360 1
				Mat[12], Mat[13], Mat[14] );
a362 1
#undef Mat
@


7.1
log
@Release 2.3
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 6.1 87/07/11 08:02:05 mike Rel $ (BRL)";
d51 1
a51 1
#include "./machine.h"	/* special copy */
d104 1
a104 1
	float f;
d499 4
a502 4
FILE *fp;
float *scale;
vect_t eye;
mat_t mat;
d971 1
a971 1
	float f;
d1134 1
a1134 1
	float	time;
@


6.1
log
@Release 2.0
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 5.1 87/06/24 22:18:13 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 4.7 87/06/13 07:16:16 mike Exp $ (BRL)";
@


4.7
log
@Temporarily changed "savekey" command to use old format again.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 4.6 87/06/13 06:11:09 mike Locked $ (BRL)";
@


4.6
log
@added zslew, changed zoom knob to 'S'
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 4.5 87/05/31 04:25:22 phil Locked $ (BRL)";
d1151 1
a1151 1
	rt_write(fp, eye_model);
@


4.5
log
@Modified so that saveview and savekey use new RT command format,
while rt and rrt commands continue to use the old format.
Also changed savekey to use same eye point as rt command.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 4.4 87/02/13 00:05:49 mike Locked $ (BRL)";
a987 3
	case 'Z':
		dm_values.dv_zoom = f;
		break;
d993 6
@


4.4
log
@Release 1.20 -- First Formal Release
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 4.3 87/02/11 05:38:09 mike Exp $ (BRL)";
d439 1
a439 1
 *  			R T _ W R I T E
d444 2
d448 1
a448 1
rt_write(fp, eye_model)
d466 27
d549 1
a549 1
	*vp++ = "-f50";
d605 1
a605 1
		rt_write(fp, eye_model );
d713 1
a713 1
		rt_write(fp, eye_model );
d1133 1
d1143 2
a1144 4
	/* Important difference:  The eye is located
	 *  where the alignment dot in the center of
	 *  the screen is, NOT at the front of the viewing cube.
	 *  At least for now.
d1146 2
a1147 3
	VSET( eye_model, -toViewcenter[MDX],
		 -toViewcenter[MDY],
		 -toViewcenter[MDZ] );
@


4.3
log
@Minor cleanups inspired by the Cray
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 4.2 87/01/03 00:36:12 mike Locked $ (BRL)";
@


4.2
log
@Improved rmats command
@
text
@d25 1
a25 1
 *	pr_solids	Print info about visible list
d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 4.1 86/12/29 03:19:28 mike Rel1 $ (BRL)";
d229 1
a229 1
	pr_solids( &HeadSolid );
d839 1
a839 1
 *			P R _ S O L I D S
d846 1
a846 1
pr_solids( startp )
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.29 86/11/15 08:48:10 mike Exp $ (BRL)";
d974 10
a983 1
/* Load view matrixes from a file.  rmats filename */
d988 12
a999 1
	vect_t eye_model;
d1001 3
d1008 29
d1040 22
a1061 2
	       rt_read( fp, &Viewscale, eye_model, Viewrot ) >= 0 )  {
		if( numargs > 2 )
d1063 18
a1080 5
		MAT_DELTAS( toViewcenter,
			-eye_model[X],
			-eye_model[Y],
			-eye_model[Z] );
		new_mats();
d1084 9
@


2.29
log
@Changed -f flag to be -f50 when starting RT.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.28 86/11/14 05:00:20 mike Locked $ (BRL)";
@


2.28
log
@Expunged mt_mater, as the converters won't handle them,
and many more mt_mater bugs remain.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.27 86/11/14 03:51:16 mike Locked $ (BRL)";
d520 1
a520 1
	*vp++ = "-f";
@


2.27
log
@Fixed dereferencing null mt_handle pointers.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.26 86/11/04 01:40:46 mike Locked $ (BRL)";
d870 1
a870 2
				(void)printf(" matrl=%s (dm%d)",
					mp->mt_handle,
@


2.26
log
@Added "rrt", added auto-detach for all displays, also added
auto re-attach afterwards.
@
text
@d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.25 86/10/11 01:05:14 mike Locked $ (BRL)";
d867 7
a873 4
		if( sp->s_materp )
			(void)printf(" matrl=%s (dm%d)",
			    ((struct mater *)sp->s_materp)->mt_handle,
			    ((struct mater *)sp->s_materp)->mt_dm_int );
@


2.25
log
@Fixed parameter problem with dbpr_*().
@
text
@d20 1
d45 1
a45 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.24 86/08/12 06:47:10 mike Locked $ (BRL)";
d505 1
d512 2
a513 2
	 * If this is a workstation where RT and MGED have to share the
	 * display, let it go.  User must reattach.
d515 1
a515 1
#ifdef DM_IR
a516 1
#endif
d589 8
d598 109
@


2.24
log
@Changed #includes for CC -I../h
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.23 86/07/18 22:58:49 mike Exp $ (BRL)";
d256 1
a256 1
			dbpr_arb( record.s.s_type, dp );
d259 1
a259 1
			dbpr_tgc( record.s.s_type, dp );
d262 1
a262 1
			dbpr_ell( record.s.s_type, dp );
d265 1
a265 1
			dbpr_half( record.s.s_type, dp );
d268 1
a268 1
			dbpr_torus( record.s.s_type, dp );
@


2.23
log
@Added warning if RT exits with abnormal status
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.22 86/07/18 02:33:53 mike Exp $ (BRL)";
d51 8
a58 8
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/mater.h"
#include "sedit.h"
#include "ged.h"
#include "objdir.h"
#include "solid.h"
#include "dm.h"
d441 2
d445 1
a445 1
rt_write(fp)
d447 1
a449 2
	vect_t temp;
	vect_t eye_model;
a450 3
	VSET( temp, 0, 0, 1 );
	MAT4X3PNT( eye_model, view2model, temp );

d455 1
a457 1
		(void)fprintf( fp, "%.9e ", Viewrot[i] );
d569 8
a576 1
	rt_write(fp);
d632 2
a633 2
	(void)fprintf(fp,"\\\n -o %s.pix ", base);
	(void)fprintf(fp,"%s \\\n", filename);
d652 1
a652 1
	(void)fprintf(fp,"\\\n 2> %s.log", base);
d654 8
a661 1
	rt_write(fp);
d889 1
d899 9
a907 1
	rt_write(fp);
@


2.22
log
@Modified to include halfspace.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.21 86/07/17 17:53:28 mike Exp $ (BRL)";
d577 2
@


2.21
log
@KAA bug fix for multiple args to "E" command.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.20 86/06/20 00:25:56 mike Exp $ (BRL)";
d254 19
a272 11
		(void)printf("%s:  %s",
			dp->d_namep,record.s.s_type==GENARB8 ? "GENARB8" :
			record.s.s_type==GENTGC ? "GENTGC" :
			record.s.s_type==GENELL ? "GENELL": "TOR" );

		if(record.s.s_type == GENARB8) {
			if( (i=record.s.s_cgtype) < 0 )
				i *= -1;
			(void)printf(" (%s)",i==ARB4 ? "ARB4" :
				i==ARB5 ? "ARB5" : i==ARB6 ? "ARB6" :
				i==ARB7 ? "ARB7" : i==RAW ? "ARB6" : "ARB8");
a273 1
		(void)printf("\n");
d275 1
@


2.20
log
@Removed extra check in "ill" command to facilitate using
with Null DM.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.19 86/06/11 23:30:05 mike Exp $ (BRL)";
a194 2

		drawreg = 0;
@


2.19
log
@Better support for SGI Iris
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.18 86/03/14 20:41:50 mike Exp $ (BRL)";
a771 4
		return;
	}
	if( lastfound->s_flag != UP )  {
		(void)printf("%s not visible\n", cmd_args[1]);
@


2.18
log
@Added support for the new spline format.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.17 86/02/17 17:04:15 mike Exp $ (BRL)";
d319 7
a325 6
	if( record.c.c_matname[0] )  {
		(void)printf("MATERIAL: %s", record.c.c_matname);
		if( record.c.c_matparm[0] )
			(void)printf(" %s", record.c.c_matparm);
		if( record.c.c_override )
			(void)printf(" color=%d %d %d",
a328 1
		(void)printf("\n");
d504 8
@


2.17
log
@Added handling for c_matname
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.16 85/09/27 19:22:31 mike Exp $ (BRL)";
d295 2
a296 9
	if( record.u_id == ID_B_SPL_HEAD ) {
		(void)printf("%s:  SPLINE\n", dp->d_namep );
		db_getrec( dp, &record, 0 );
		(void)printf(" order %d %d\n",
			record.d.d_order[0],
			record.d.d_order[1]);
		(void)printf(" num Control points %d %d\n",
			record.d.d_ctl_size[0],
			record.d.d_ctl_size[1]);
@


2.16
log
@Added Phil's savekey function, fixed bug in rmats.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.15 85/09/14 05:34:28 mike Exp $ (BRL)";
d320 1
a320 1
		(void)printf("REGION id=%d (air=%d, mat=%d, los=%d) ",
d323 2
a324 2
			record.c.c_material,
			record.c.c_los );
d326 11
@


2.15
log
@Lint-inspired cleanup.
@
text
@d29 1
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.14 85/09/12 00:15:13 mike Exp $ (BRL)";
d470 1
a470 1
	*scale = d;
d852 20
@


2.14
log
@Changed to produce new RT matrix file format.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.13 85/08/26 17:09:28 mike Exp $ (BRL)";
d247 1
a248 1
	register struct directory *dp;
d440 1
a440 1
	MAT4X3VEC( eye_model, view2model, temp );
a829 1
	register int i;
@


2.13
log
@Added rmats() command.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.12 85/08/07 05:17:03 mike Exp $ (BRL)";
d426 58
d552 1
a552 4

	/* Send out model2view matrix */
	for( i=0; i < 16; i++ )
		(void)fprintf( fp, "%.9e ", model2view[i] );
d563 11
d575 14
d595 1
d601 2
d606 2
a607 2
	(void)fprintf(fp,"-o %s.pix ", filename);
	(void)fprintf(fp,"%s ", filename);
d626 3
a628 8
	(void)fprintf(fp," 2> %s.log", filename);
	(void)fprintf(fp," <<EOF");

	/* Send out model2view matrix */
	for( i=0; i < 16; i++ ) {
		if( (i%4) == 0 )  (void)fprintf(fp, "\n");
		(void)fprintf( fp, "%.9e ", model2view[i] );
	}
d831 1
a831 1
	double ovscale;		/* old Viewscale */
a836 1
	ovscale = Viewscale;
d839 9
a847 9
	while( !feof( fp ) )  {
		for( i=0; i < 16; i++ )
			fscanf(fp, "%f", &model2view[i] );
		Viewscale = model2view[15];
		mat_inv( view2model, model2view );
		if( state != ST_VIEW )  {
			mat_mul( model2objview, model2view, modelchanges );
			mat_inv( objview2model, model2objview );
		}
a851 1
	Viewscale = ovscale;
@


2.12
log
@Changed to use common ../h/vmath.h
@
text
@d28 1
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.11 85/07/30 01:17:26 mike Exp $ (BRL)";
d745 31
@


2.11
log
@Change to support new ARB editing.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.10 85/05/10 01:03:56 mike Exp $ (BRL)";
d45 5
a49 3
#include	<math.h>
#include	<signal.h>
#include	<stdio.h>
a50 1
#include "../h/vmath.h"
a51 1
#include "ged_types.h"
@


2.10
log
@Updated f_fix to not use dmr_restart, which no longer exists.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.9 85/05/10 00:51:47 mike Exp $ (BRL)";
d254 1
a254 1
		(void)printf("%s:  %s\n",
d258 9
@


2.9
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.8 85/05/07 23:22:14 mike Exp $ (BRL)";
d402 1
a402 1
/* Fix the display processor after a hardware error, as best we can */
d406 1
a406 1
	dmp->dmr_restart();
@


2.8
log
@KAA f_aeview() added.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.7 85/05/02 20:16:00 mike Exp $ (BRL)";
d234 2
d241 1
@


2.7
log
@Eliminated silly M_brname stuff.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.6 85/03/29 00:13:12 mike Exp $ (BRL)";
d543 7
@


2.6
log
@Made f_list interuptable.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.5 85/03/22 10:51:27 mike Exp $ (BRL)";
a317 2
		if( record.M.m_brname[0] != '\0' )
			(void)printf(" br name=%s", record.M.m_brname );
@


2.5
log
@Symbolic viewchange
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.4 85/03/15 05:03:08 mike Exp $ (BRL)";
d348 1
@


2.4
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.3 85/03/14 15:55:33 mike Exp $ (BRL)";
d579 1
a579 1
				dmp->dmr_viewchange( 2, sp );	/* DEL sol */
d618 6
a623 4
		(void)printf("reg=%d matrl=%s (dm%d)\n",
			sp->s_regionid,
			((struct mater *)sp->s_materp)->mt_handle,
			((struct mater *)sp->s_materp)->mt_dm_int );
@


2.3
log
@Fixed to reset no_memory flag when memory is made.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.2 85/03/12 04:06:46 mike Exp $ (BRL)";
d48 3
a51 1
#include "../h/db.h"
a56 1
#include "../h/vmath.h"
d192 1
a192 1
		drawHobj( dp, ROOT, 0, identity );
d204 1
d227 1
a240 2
/* List object information */
/* Format: l object	*/
d242 1
a242 1
f_list()
a246 3
	
	if( (dp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
		return;
d274 1
a274 1
		/* convert vertex from the base unit to the local unit */
d284 2
a285 1
		(void)printf(" order %d %d\n", record.d.d_order[0],
d288 2
a289 1
			record.d.d_ctl_size[0], record.d.d_ctl_size[1]);
d298 2
a299 1
		(void)printf("%s: unknown record type!\n", dp->d_namep );
d306 6
a311 4
		(void)printf("REGION item=%d, air=%d, mat=%d, los=%d ",
			record.c.c_regionid, record.c.c_aircode,
			record.c.c_material, record.c.c_los );
	(void)printf("--\n", dp->d_len-1 );
d321 1
a321 1
		if( Mat[0] != 1.0  || Mat[5] != 1.0 || Mat[10] != 1.0 )
d323 3
a325 1
		if( Mat[MDX] != 0.0 || Mat[MDY] != 0.0 || Mat[MDZ] != 0.0 )
d330 3
a332 1
		if( Mat[12] != 0.0 || Mat[13] != 0.0 || Mat[14] != 0.0 )
d340 16
d524 1
a524 1
		(void)fprintf(fp, "%s ", sp->s_path[0]->d_namep);
d577 2
d606 1
a608 1
		(void)printf("  %s", sp->s_flag == UP ? "VIEW":"-NO-" );
d610 2
a611 1
			(void)printf(" ILL");
d613 9
a621 4
		(void)printf(" [%f,%f,%f] size %f",
			sp->s_center[X]*base2local, sp->s_center[Y]*base2local, 
			sp->s_center[Z]*base2local,sp->s_size*base2local);
		(void)putchar('\n');
@


2.2
log
@Paul Stay's Spline code
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 2.1 85/03/11 23:54:07 mike Prod $ (BRL)";
d218 1
d340 2
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.17 85/03/08 20:53:38 mike Exp $ (BRL)";
d282 9
d297 1
a297 1
		(void)printf("%s: garbage!\n", dp->d_namep );
@


1.17
log
@USNA changes which formalize state changes.
@
text
@d5 18
d25 3
d29 4
a32 1
 * Source -
d36 4
d42 1
a42 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.16 85/02/14 01:54:36 mike Exp $ (BRL)";
d49 1
a49 1
#include "db.h"
d52 1
a52 1
#include "dir.h"
d55 1
a55 1
#include "vmath.h"
d67 1
a68 1

d71 1
d82 1
d97 1
d110 1
d132 1
d142 1
a203 1
	dmp->dmr_viewchange();		/* alert DM */
d208 1
a218 1
	dmp->dmr_viewchange();		/* alert DM */
d221 1
d227 1
d239 1
d277 2
a278 1
			record.b.b_values[0]*base2local, record.b.b_values[1]*base2local,
d312 3
a314 1
				Mat[MDX]*base2local, Mat[MDY]*base2local, Mat[MDZ]*base2local);
d316 1
a316 1
			printf(" ??Perspective=[%f,%f,%f]??",
d325 1
d337 1
a337 1
		memfree( &(dmp->dmr_map), sp->s_bytes, sp->s_addr );
d348 1
d351 4
a354 4
	printf("STATE=%s, ", state_str[state] );
	printf("maxview=%f, ", maxview*base2local);
	printf("Viewscale=%f (%f mm)\n", Viewscale*base2local, Viewscale);
	printf("base2local=%f\n", base2local);
d366 1
d373 1
a375 1

d380 1
d416 1
a416 1
			printf("ran out of vec for %s\n",
d428 2
a429 2
		printf("%s ", *vp++ );
	printf("\n");
d434 2
a435 2
		close(0);
		dup( o_pipe[0] );
d445 1
a445 1
	close( o_pipe[0] );
d450 2
a451 2
		fprintf( fp, "%.9e ", model2view[i] );
	fclose( fp );
d473 1
a473 1
	fprintf(fp, "#!/bin/sh\nrt -M ");
d475 3
a477 3
		fprintf(fp,"%s ", cmd_args[i]);
	fprintf(fp,"-o %s.pix ", filename);
	fprintf(fp,"%s ", filename);
d489 1
a489 1
		fprintf(fp, "%s ", sp->s_path[0]->d_namep);
d496 2
a497 2
	fprintf(fp," 2>&1 > %s.log", filename);
	fprintf(fp," <<EOF");
d501 2
a502 2
		if( (i%4) == 0 )  fprintf(fp, "\n");
		fprintf( fp, "%.9e ", model2view[i] );
d504 2
a505 2
	fprintf(fp,"\nEOF\n");
	fclose( fp );
d542 2
a543 1
				memfree( &(dmp->dmr_map), sp->s_bytes, sp->s_addr );
d620 1
a620 1
		printf("%s not visible\n", cmd_args[1]);
d678 1
a678 1
		printf("x,y,z for joystick, Z for zoom, X,Y for slew\n");
@


1.16
log
@Added f_sed to allow transition from ST_VIEW to ST_S_EDIT
with a single keyboard command.
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.16 85/02/14 01:46:57 mike Exp $ (BRL)";
d57 1
a57 2
	if( state != ST_VIEW )  {
		state_err("View Rotate");
d59 1
a59 1
	}
d84 8
a91 6
	/*
	 * Force out the control list with NO solids being drawn,
	 * then the display processor will not mind when we start
	 * writing new subroutines out there...
	 */
	refresh();
a92 1
	/* fall through */
a94 1

a103 1

d133 10
a142 7
		/*
		 * Delete any portion of object remaining from previous draw
		 */
		eraseobj( dp );
		dmaflag++;
		refresh();
		dmaflag++;
d163 1
a163 1
	if( Viewscale == 1.0 )  {
d168 1
a168 1
	(void)printf("view (%ld sec)\n", etime - stime );
d170 1
d185 1
d304 1
d349 1
a349 2
	if( state != ST_VIEW )  {
		state_err( "Ray-trace of current view" );
d351 1
a351 1
	}
a425 4
	if( state != ST_VIEW )  {
		state_err( "Ray-trace of current view" );
		return;
	}
d584 1
a584 1
		state = ST_O_PATH;
d596 1
a596 2
	if( state != ST_VIEW )  {
		state_err("keyboard solid edit start");
d598 1
a598 1
	}
@


1.15
log
@Changed interface to RT to use %.9e formats.
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.14 85/02/14 00:59:06 mike Exp $ (BRL)";
d591 12
@


1.14
log
@Removed the (now redundant) "done" messages.
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.13 85/02/06 02:31:21 mike Exp $ (BRL)";
d309 1
d404 1
a404 1
		fprintf( fp, "%f ", model2view[i] );
d434 1
a434 1
	fprintf(fp," -o %s.pix", filename);
d455 1
a455 1
	fprintf(fp," <<EOF\n");
d458 4
a461 2
	for( i=0; i < 16; i++ )
		fprintf( fp, "%f ", model2view[i] );
@


1.13
log
@Added optional parameter to regdebug command to
permit tickling display-manager specific debugging.
(In this case, the 3 view options on the Raster Tek).
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.12 85/02/05 04:55:16 mike Exp $ (BRL)";
a412 1
	(void)printf("done\n");
d414 51
a464 1
#undef LEN
@


1.12
log
@f_list improved to mention presence of perspective information in
transformation matrix.  (Probably leftover from old database format).
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.11 85/02/05 04:17:00 mike Exp $ (BRL)";
d192 5
a196 1
		regdebug ^= 1;	/* toggle */
@


1.11
log
@Signal adjustments, local view size fix.
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.10 85/02/02 01:40:07 mike Exp $ (BRL)";
a265 1
		/* must convert translations to the local unit before printing */
d269 3
@


1.10
log
@Fiddled with units command, have status also printed in base units.
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.9 85/02/01 03:25:59 mike Exp $ (BRL)";
d72 2
a73 2
	if( f < 0.01 ) f = 0.01;
	Viewscale = f / 2.0;
a379 1
	(void)signal( SIGQUIT, SIG_IGN );
a386 1
		(void)signal( SIGQUIT, SIG_DFL );
d403 1
a403 2
	(void)signal(SIGINT, quit);
	(void)signal(SIGQUIT, sig3);
@


1.9
log
@Added knob and ill commands.
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header: chgview.c,v 1.8 85/02/01 00:50:06 mike Exp $ (BRL)";
d302 1
a302 1
	printf("Viewscale=%f\n", Viewscale*base2local);
@


1.8
log
@Keith's global/local units additions
@
text
@d14 1
a14 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d482 89
@


1.7
log
@
Latest stuff
@
text
@d8 4
a11 1
 * The U. S. Army Ballistic Research Laboratory
d13 3
d45 4
a48 3
	toViewcenter[MDX] = -atof( cmd_args[1] );
	toViewcenter[MDY] = -atof( cmd_args[2] );
	toViewcenter[MDZ] = -atof( cmd_args[3] );
d53 1
a53 1
f_rot()
d55 6
d232 1
d234 2
a235 2
			record.b.b_values[0], record.b.b_values[1],
			record.b.b_values[2] );
d266 1
d269 1
a269 1
				Mat[MDX], Mat[MDY], Mat[MDZ]);
d301 2
a302 2
	printf("maxview=%f, ", maxview);
	printf("Viewscale=%f\n", Viewscale);
d476 1
d478 2
a479 2
			sp->s_center[X], sp->s_center[Y], sp->s_center[Z],
			sp->s_size);
@


1.6
log
@If in solid edit mode, restore solid params after "l" command.
@
text
@d48 3
a50 31
	register char c = cmd_args[1][0];
	static float f;

	f = atof(cmd_args[2]) * degtorad;

	switch( c )  {
	case 'x':
	case 'X':
		usejoy( f, 0.0, 0.0 );
		break;
	case 'y':
	case 'Y':
		usejoy( 0.0, f, 0.0 );
		break;
	case 'z':
	case 'Z':
		usejoy( 0.0, 0.0, f );
		break;
	default:
		printf("Unknown axis '%s'\n", cmd_args[1]);
		break;
	}
}

/* DEBUG -- simulate button press */
/* Format: press button#	*/
f_press()
{
	int i;
	i = atoi( cmd_args[1] );
	button( i );
@


1.5
log
@pre-Keith version
@
text
@d233 5
@


1.4
log
@Multiple simultaneous display manager support
@
text
@d5 2
d15 1
a15 1
#include "3d.h"
d296 2
a297 1
		memfree( &(dmp->dmr_map), sp->s_addr, sp->s_bytes );
d432 58
@


1.3
log
@Vector lists saved, multiple display managers supported.
@
text
@d294 1
a294 1
		freevgcore( sp->s_addr, sp->s_bytes );
@


1.2
log
@Minor cleanups
@
text
@d145 1
a145 1
		if( (dp = lookup( cmd_args[i], NOISY )) == DIR_NULL )
d192 1
a192 1
		if( (dp = lookup( cmd_args[i], NOISY )) != DIR_NULL )
d216 1
a216 1
	if( (dp = lookup( cmd_args[1], NOISY )) == DIR_NULL )
d321 1
a321 1
	dm_restart();
d422 1
d428 1
@


1.1
log
@Initial revision
@
text
@d418 10
@
