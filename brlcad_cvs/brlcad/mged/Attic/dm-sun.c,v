head	11.4;
access;
symbols
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.4
date	98.10.23.15.12.07;	author bparker;	state dead;
branches;
next	11.3;

11.3
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.57;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.24.01.05.21;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.12.23.22.59.38;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.12.16.19.36.13;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.09.07.13.17.51;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.21.42.53;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.15.15.02;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.32;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.02.02.00.14.03;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.45;	author mike;	state Rel3_5;
branches;
next	8.9;

8.9
date	89.05.17.03.30.58;	author phil;	state Exp;
branches;
next	8.8;

8.8
date	89.04.06.20.39.41;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.03.20.56.30;	author phil;	state Exp;
branches;
next	8.6;

8.6
date	89.01.25.04.47.47;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.01.24.23.10.49;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	88.12.06.01.07.03;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.11.30.05.02.19;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	88.11.27.19.55.33;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.33;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.09.15.21.43.49;	author phil;	state Exp;
branches;
next	7.6;

7.6
date	88.08.24.06.00.56;	author phil;	state Exp;
branches;
next	7.5;

7.5
date	88.08.12.23.21.46;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.02.25.06.23.30;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.25.06.06.45;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.05.13;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.00.07;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.03.18;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.19.50;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.06.16.05.30.34;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.05.06.02.52.22;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.06.59;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.20.51;	author mike;	state Rel1;
branches;
next	1.2;

1.2
date	86.11.14.03.54.31;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.11.13.13.56.32;	author mike;	state Exp;
branches;
next	;


desc
@Display Manager for SUN, using PixWin interface.
@


11.4
log
@*- moved old display managers to dm_old
@
text
@/*
 *			D M - S U N . C
 *
 *  Driver for SUN using SunView pixwins library.
 *
 *  Prerequisites -
 *	SUN 3.2.  Will not compile on 3.0 and below.
 *
 *  Author -
 *	Bill Lindemann, SUN - original pixwin/pixrect version.
 *	Phillip Dykstra, BRL - SunView version.
 *
 *  Source -
 *	SUN Microsystems Inc.
 *	2550 Garcia Ave
 *	Mountain View, Ca 94043
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-sun.c,v 11.3 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "./ged.h"
#include "./dm.h"
#include "externs.h"
#include "./solid.h"

#include <fcntl.h>
#include <signal.h>
#include <sunwindow/cms.h>
#include <sunwindow/cms_rgb.h>
#include <suntool/sunview.h>
#include <suntool/canvas.h>
#include <suntool/gfxsw.h>

extern void     perror();

/*
 * Max number of color map slots to use (don't consume all 256)
 */
#define	CMS_MGED	"mged"
#define	CMS_MGEDSIZE	128

/* Display Manager package interface */

#define SUNPWBOUND	1000.0	/* Max magnification in Rot matrix */
int             SunPw_open();
void            SunPw_close();
MGED_EXTERN(void	SunPw_input, (fd_set *input, int noblock) );
void            SunPw_prolog(), SunPw_epilog();
void            SunPw_normal(), SunPw_newrot();
void            SunPw_update();
void            SunPw_puts(), SunPw_2d_line(), SunPw_light();
int             SunPw_object();
unsigned        SunPw_cvtvecs(), SunPw_load();
void            SunPw_statechange(), SunPw_viewchange(), SunPw_colorchange();
void            SunPw_window(), SunPw_debug();

struct dm dm_SunPw = {
	SunPw_open, SunPw_close,
	SunPw_input,
	SunPw_prolog, SunPw_epilog,
	SunPw_normal, SunPw_newrot,
	SunPw_update,
	SunPw_puts, SunPw_2d_line,
	SunPw_light,
	SunPw_object,
	SunPw_cvtvecs, SunPw_load,
	SunPw_statechange,
	SunPw_viewchange,
	SunPw_colorchange,
	SunPw_window, SunPw_debug,
	0,			/* no displaylist */
	0,			/* Multiwindow */
	SUNPWBOUND,
	"sun", "SunView Release 3.x pixwin library"
};

void		input_eater();
extern struct device_values dm_values;	/* values read from devices */
static int	peripheral_input;	/* !0 => unprocessed input */
static int	mouse_motion;		/* !0 => MGED pen tracking mode */

static vect_t   clipmin, clipmax;	/* for vector clipping */
static int	height, width;

Window          frame;
Canvas		canvas;
Pixwin		*sun_pw;		/* sub-area of screen being used */
int		sun_depth;
int             sun_cmap_color = DM_WHITE+1;	/* for default colormap */
struct pixfont *sun_font_ptr;
Pr_texture     *sun_get_texP();
Rect            sun_win_rect;
int             sun_win_fd;
int             sun_debug = 0;

static short icon_image[] = {
#include "./sunicon.h"
};
DEFINE_ICON_FROM_IMAGE(icon, icon_image);

/*
 * Display coordinate conversion:
 *  GED is using -2048..+2048,
 *  We use 0..width, height..0.
 */
#define	GED_TO_SUNPWx(x) ((int)(((x)/4096.0+0.5)*width))
#define	GED_TO_SUNPWy(x) ((int)((0.5-(x)/4096.0)*height))
#define	SUNPWx_TO_GED(x) (((x)/(double)width-0.5)*4095)
#define	SUNPWy_TO_GED(x) (((x)/(double)height-0.5)*4095)

#define LABELING_FONT   "/usr/lib/fonts/fixedwidthfonts/sail.r.6"

static int doing_close;

static Notify_value
my_real_destroy(frame, status)
Frame	frame;
Destroy_status	status;
{
	if( status != DESTROY_CHECKING && !doing_close ) {
		doing_close++;
		quit();		/* Exit MGED */
	}
	/* Let frame get destroy event */
	return( notify_next_destroy_func(frame, status) );
}

/*
 *			S U N P W _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
SunPw_open()
{
	char unsigned   red[256], grn[256], blu[256];
	struct pr_subregion bound;
	char	gfxwinname[128];

	width = height = 512;
	doing_close = 0;

	/*
	 * Make sure we are running under suntools.
	 * Gets the name of our parent.
	 */
	if( we_getgfxwindow(gfxwinname) ) {
		bu_log( "dm-sun: Must be running suntools\n" );
		return(-1);
	}

	/* Make a frame and a canvas to go in it */
	frame = window_create(NULL, FRAME,
			      FRAME_ICON, &icon,
			      FRAME_LABEL, "MGED Display", 0);
	/* XXX - "command line" args? pg.51 */
	canvas = window_create(frame, CANVAS,
			      WIN_WIDTH, width,
			      WIN_HEIGHT, height, 0);
	/* Fit window to canvas (width+10, height+20) */
	window_fit(frame);

	/* get the canvas pixwin to draw in */
	sun_pw = canvas_pixwin(canvas);
	sun_win_rect = *((Rect *)window_get(canvas, WIN_RECT));
	sun_depth = sun_pw->pw_pixrect->pr_depth;
	sun_win_fd = sun_pw->pw_clipdata->pwcd_windowfd;

	/*printf("left,top,width,height=(%d %d %d %d)\n",
	sun_win_rect.r_left, sun_win_rect.r_top,
	sun_win_rect.r_width, sun_win_rect.r_height );*/

	/* Set up Canvas input */
	window_set( canvas,
		WIN_CONSUME_PICK_EVENT, WIN_MOUSE_BUTTONS,
		WIN_CONSUME_KBD_EVENT, WIN_TOP_KEYS,
		WIN_CONSUME_KBD_EVENT, WIN_UP_EVENTS,
		WIN_EVENT_PROC, input_eater, 0 );

	/* Set up our Colormap */
	if( sun_depth >= 8 )  {
		/* set a colormap segment; initialize it */
		SunPw_colorchange();
	} else {
		pw_blackonwhite( sun_pw, 0, 1 );
	}

	sun_clear_win();
	sun_font_ptr = pf_open(LABELING_FONT);
	if (sun_font_ptr == (struct pixfont *) 0) {
		perror(LABELING_FONT);
		return(-1);
	}
	pf_textbound(&bound, 1, sun_font_ptr, "X");

	notify_interpose_destroy_func(frame,my_real_destroy);

	window_set(frame, WIN_SHOW, TRUE, 0);	/* display it! */

	return (0);			/* OK */
}

/*
 *  			S U N P W _ C L O S E
 *  
 *  Gracefully release the display.
 *  Called on either a quit or release.
 */
void
SunPw_close()
{
	/*
	 * The window_destroy() call posts a destroy event, the same
	 * as if the user selected quit from the title bar.  We can
	 * interpose a destroy function to do an MGED release() or
	 * quit() in response to a title bar Quit, but both will
	 * result in calling this function, which will cause another
	 * destroy event, etc.!  There doesn't appear to be any way
	 * to REMOVE an interposed function.  So, we make this function
	 * do nothing if we have already been here or in destroy.
	 */
	if( !doing_close ) {
		doing_close++;
		window_set(frame, FRAME_NO_CONFIRM, TRUE, 0);
		window_destroy(frame);
	}
}

/*
 *			S U N _ C O L O R
 *
 *  Sets the global "sun_cmap_color" to the index of the requested color.
 */
sun_color(color)
int	color;
{
	/* Note that DM_BLACK is only used for clearing to background */
	if( sun_depth < 8 )  {
		/*
		 * Sun Monochrome:  Following normal Sun usage,
		 * "black" means "background" which is the lowest entry
		 * in your colormap segment.
		 * "white" means "foreground" which is the hightest entry.
		 * Which one is actually black or white depends on whether
		 * you are in "inverse video" or not.
		 *
		 * Note: foreground would have been index CMS_MGEDSIZE-2,
		 *  but this is the monochrome case so that does't work.
		 */
		if( color == DM_BLACK )
			sun_cmap_color = 0;	/* background */
		else
			sun_cmap_color = 1;	/* foreground */
		return;
	}
	switch (color) {
	case DM_BLACK:
		sun_cmap_color = 1;
		break;
	case DM_RED:
		sun_cmap_color = 2;
		break;
	case DM_BLUE:
		sun_cmap_color = 3;
		break;
	case DM_YELLOW:
		sun_cmap_color = 4;
		break;
	case DM_WHITE:
		sun_cmap_color = 5;
		break;
	default:
		bu_log("sun_color:  mged color %d not known\n", color);
		break;
	}
}

/*
 *			S U N P W _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
void
SunPw_prolog()
{
	if(!dmaflag)
		return;

	/* draw in the memory pixrect, not the window */
	pw_batch_on(sun_pw);

	/* clear the screen for a redraw */
	sun_clear_win();

	/* Put the center point up, in foreground */
	sun_color(DM_WHITE);
	pw_put(sun_pw, GED_TO_SUNPWx(0), GED_TO_SUNPWy(0),
		sun_cmap_color);
}

/*
 *			S U N P W _ E P I L O G
 */
void
SunPw_epilog()
{
	/* flush everything to the window */
	pw_batch_off(sun_pw);
	return;
}

/*
 *  			S U N P W _ N E W R O T
 *  Stub.
 */
/* ARGSUSED */
void
SunPw_newrot(mat)
mat_t	mat;
{
	return;
}

static Pr_brush sun_whitebrush = { 4 };

/*
 *  			S U N P W _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */
#define	MAXVEC	2048
/* ARGSUSED */
int
SunPw_object(sp, mat, ratio, white)
struct solid	*sp;
mat_t	mat;
double	ratio;
{
	register struct rt_vlist *vp;
	register struct pr_pos	*ptP;		/* Sun point list */
	register u_char		*mvP;		/* Sun move/draw list */
	struct pr_pos   ptlist[MAXVEC];		/* Sun point buffer */
	u_char          mvlist[MAXVEC];		/* Sun move/draw buffer */
	int             numvec;			/* number of points */
	static vect_t   pnt;			/* working point */
	Pr_texture	*texP;			/* line style/color */
	Pr_brush	*brush;
	int		color;

	ptP = ptlist;
	mvP = mvlist;
	numvec = 0;
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;

		/* Viewing region is from -1.0 to +1.0 */
		/* 2^31 ~= 2e9 -- dynamic range of a long int */
		/* 2^(31-11) = 2^20 ~= 1e6 */
		/* Integerize and let Sun do the clipping */
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			static vect_t	start, fin;
			switch( *cmd )  {
			case RT_VLIST_POLY_START:
			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				MAT4X3PNT( pnt, mat, *pt );
				if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
				    pnt[1] < -1e6 || pnt[1] > 1e6 )
					continue; /* omit this point (ugh) */
				/* Integerize and let the Sun library do the clipping */
				ptP->x = GED_TO_SUNPWx(2048*pnt[0]);
				ptP->y = GED_TO_SUNPWy(2048*pnt[1]);
				ptP++;
				*mvP++ = 1;
				break;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				/* draw */
				MAT4X3PNT( pnt, mat, *pt );
				if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
				    pnt[1] < -1e6 || pnt[1] > 1e6 )
					continue; /* omit this point (ugh) */
				/* Integerize and let the Sun library do the clipping */
				ptP->x = GED_TO_SUNPWx(2048*pnt[0]);
				ptP->y = GED_TO_SUNPWy(2048*pnt[1]);
				ptP++;
				*mvP++ = 0;
				break;
			}
			if( ++numvec >= MAXVEC ) {
				(void)bu_log(
					"SunPw_object: nvec %d clipped to %d\n",
					sp->s_vlen, numvec );
				break;
			}
		}
	}

	/* get line style/color etc */
	if( white )
		brush = &sun_whitebrush;
	else
		brush = (Pr_brush *)0;
	texP = sun_get_texP(sp->s_soldash);
	if( sun_depth < 8 ) {
		sun_color( DM_WHITE );
		color = PIX_COLOR(sun_cmap_color);
	} else {
		color = PIX_COLOR(sp->s_dmindex);
	}

	pw_polyline( sun_pw, 0, 0, numvec, ptlist, mvlist,
		brush, texP, PIX_SRC|color );

	return(numvec);		/* non-zero means it did something */
}

/*
 *			S U N P W _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
SunPw_normal()
{
	return;
}

/*
 *			S U N P W _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
void
SunPw_update()
{
	return;
}

/*
 *			S U N P W _ P U T S
 *
 *  Output a string into the displaylist.
 *  The starting position of the beam is as specified.
 *
 *  MGED starts edit messages with a TAB.  We get back at it
 *  here.  It's yucky, but better than printing a blotch.
 */
/* ARGSUSED */
void
SunPw_puts(str, x, y, size, color)
register u_char *str;
{
	if( str[0] == 9 ) {
		str[0] = ' ';
		x += 10;
	}

	sun_color(color);
	if( sun_depth == 1 ) {
		pw_text(sun_pw, GED_TO_SUNPWx(x), GED_TO_SUNPWy(y),
			PIX_SRC,
			sun_font_ptr, str);
	} else {
		pw_ttext(sun_pw, GED_TO_SUNPWx(x), GED_TO_SUNPWy(y),
			PIX_SRC | PIX_COLOR(sun_cmap_color),
			sun_font_ptr, str);
	}
}

/*
 *			S U N P W _ 2 D _ L I N E
 *
 */
void
SunPw_2d_line(x1, y1, x2, y2, dashed)
int	x1, y1;
int	x2, y2;
int	dashed;
{
	Pr_texture     *texP;

	sun_color(DM_YELLOW);
	texP = sun_get_texP(dashed);
	pw_line(sun_pw, GED_TO_SUNPWx(x1), GED_TO_SUNPWy(y1),
	    GED_TO_SUNPWx(x2), GED_TO_SUNPWy(y2), (Pr_brush *) 0, texP,
	    PIX_SRC | PIX_COLOR(sun_cmap_color));
}

/*
 *			S U N P W _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream, or a device event has
 * occured, unless "noblock" is set.
 *
 * We need to call notify_dispatch() regularly so that window events
 * such as say title-bar actions can be processed.  Button and mouse
 * events actually get sent to input_eater() via the notifier.  We
 * use a flag peripheral_input, for input_eater() to tell this module
 * when there had been window input to return.
 *
 * I used to use a long select timeout (60 sec) after a notify_do_dispatch()
 * call (to dispatch events inside of the select) and counted on a
 * notify_stop() in the input_eater() routine to wake the select up.
 * [This is the way we *should* do it, right? (See pg 266)]
 * It appears though that some input events get lost this way.  Perhaps
 * notify_stop() may be intended more as an abort and thus isn't careful.
 * The final straw was SIGINT on command input was causing window fd
 * input that notify_dispatch was never dispatching!  So, I finally
 * went back to a short timeout select loop and avoided the do_dispatch
 * and stop business.  It works better this way.
 *
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
SunPw_input( input, noblock)
fd_set		*input;
int		noblock;	/* !0 => poll */
{
	struct timeval  tv;
	fd_set		files;
	int		width;
	int		cnt;
	int		i;

	if( (width = getdtablesize()) <= 0 )
		width = 32;
	files = *input;		/* save, for restore on each loop */

	FD_SET( sun_win_fd, &files );

	/*
	 * Check for input on the keyboard or on the polled registers. 
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)	A change in peripheral status occurs
	 *  3)  The timelimit on SELECT has expired 
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which the peripherals (rate setting) may not have changed,
	 * but we still have to update the display,
	 * do not suspend execution.
	 */
	if (noblock) {
		tv.tv_sec = 0;
		tv.tv_usec = 0;
	} else {
		tv.tv_sec = 0;
		tv.tv_usec = 200000;
	}
	for( ;; ) {
		*input = files;
		cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
		if( cnt < 0 )  {
			perror("dm-sun.c/select");
			break;
		}

		(void) notify_dispatch();
		if( peripheral_input ) {
			/*printf("Returning peripherals\n");*/
			peripheral_input = 0;
			return;		/* just peripheral stuff */
		}
		if( FD_SET(sun_win_fd, input) ) {
			/* check for more input events before redisplay */
			/*printf("Loop d'loop\n");*/
			continue;
		}
		if( noblock ) {
			/*printf("Returning noblock\n");*/
			return;
		}
		for( i=0; i<width; i++ )  {
			if( FD_ISSET(i, input) )  return;
		}
	}
}

#define	NBUTTONS	10
#define	ZOOM_BUTTON	1	/* F1 */
#define	Z_SLEW_BUTTON	2
#define	X_SLEW_BUTTON	3
#define	Y_SLEW_BUTTON	4
#define	X_ROT_BUTTON	5
#define	Y_ROT_BUTTON	6
#define	Z_ROT_BUTTON	7
int	sun_buttons[NBUTTONS];

/*
 *  This gets called by the notifier whenever device input that
 *  we asked for comes in (and some that we didn't ask for).
 */
void
input_eater( win, event, arg )
Window	win;
Event	*event;
caddr_t	*arg;
{
	int             id;
	int             button;
	float           xval;
	float           yval;
	int		xpen, ypen;

	id = event_id(event);
	xpen = SUNPWx_TO_GED(event_x(event));
	ypen = -SUNPWy_TO_GED(event_y(event));
	if( sun_debug )
		bu_log("Event %d at (%d %d)\n",id,event_x(event),event_y(event));
	switch(id) {
	case MS_LEFT:
		if (event_is_down(event)) {
			bu_vls_strcat( &dm_values.dv_string , "zoom 2\n" );
			peripheral_input++;
		}
		break;
	case MS_MIDDLE:
		if (event_is_down(event)) {
			bu_vls_printf( &dm_values.dv_string , "M 1 %d %d\n" , xpen, ypen );
			peripheral_input++;
		}
		break;
	case MS_RIGHT:
		if (event_is_down(event)) {
			bu_vls_strcat( &dm_values.dv_string , "zoom 0.5\n" );
			peripheral_input++;
		}
		break;
	case LOC_DRAG:
		break;
	case LOC_MOVE:
		xval = (float) xpen / 2048.;
		if (xval < -1.0)
			xval = -1.0;
		if (xval > 1.0)
			xval = 1.0;
		yval = (float) ypen / 2048.;
		if (yval < -1.0)
			yval = -1.0;
	    	if (yval > 1.0)
			yval = 1.0;
		for( button = 0; button < NBUTTONS; button++ ) {
			char str_buf[128];

			if( sun_buttons[button] ) {
				peripheral_input++;
				switch(button) {
				case ZOOM_BUTTON:
					{
						float zoom;

						zoom = (yval*yval) / 2;
						if (yval < 0)
						    zoom = -zoom;
						sprintf( str_buf , &dm_values.dv_string, "zoom %f\n", zoom );
						bu_vls_strcat( &dm_values.dv_string, str_buf );
					}
					break;
				case X_SLEW_BUTTON:
					sprintf( str_buf, "knob X %f\n", xval );
					bu_vls_strcat( &dm_values.dv_string, str_buf );
					break;
				case Y_SLEW_BUTTON:
					sprintf( str_buf, "knob Y %f\n", yval );
					bu_vls_strcat( &dm_values.dv_string, str_buf );
					break;
				case Z_SLEW_BUTTON:
					sprintf( str_buf, "knob Z %f\n", yval );
					bu_vls_strcat( &dm_values.dv_string, str_buf );
					break;
				case X_ROT_BUTTON:
					sprintf( str_buf, "knob x %f\n", xval );
					bu_vls_strcat( &dm_values.dv_string, str_buf );
					break;
				case Y_ROT_BUTTON:
					sprintf( str_buf, "knob y %f\n", yval );
					bu_vls_strcat( &dm_values.dv_string, str_buf );
					break;
				case Z_ROT_BUTTON:
					sprintf( str_buf, "knob z %f\n", yval );
					bu_vls_strcat( &dm_values.dv_string, str_buf );
					break;
				}
			}
		}
		if( mouse_motion )
			peripheral_input++;	/* MGED wants to know */
		break;
	case KEY_TOP(ZOOM_BUTTON):
		sun_key(event, ZOOM_BUTTON);
		break;
	case KEY_TOP(X_SLEW_BUTTON):
		sun_key(event, X_SLEW_BUTTON);
		break;
	case KEY_TOP(Y_SLEW_BUTTON):
		sun_key(event, Y_SLEW_BUTTON);
		break;
	case KEY_TOP(Z_SLEW_BUTTON):
		sun_key(event, Z_SLEW_BUTTON);
		break;
	case KEY_TOP(X_ROT_BUTTON):
		sun_key(event, X_ROT_BUTTON);
		break;
	case KEY_TOP(Y_ROT_BUTTON):
		sun_key(event, Y_ROT_BUTTON);
		break;
	case KEY_TOP(Z_ROT_BUTTON):
		sun_key(event, Z_ROT_BUTTON);
		break;
	/*
	 * Gratuitous Input Events - supposed to be good for you
	 */
	case WIN_REPAINT:
		/* The canvas does the repaint for us */
		window_default_event_proc( win, event, arg );
		break;
	case WIN_RESIZE:
		dmaflag = 1;	/* causes refresh */
		height = (int)window_get(canvas,CANVAS_HEIGHT);
		width = (int)window_get(canvas,CANVAS_WIDTH);
		sun_pw = canvas_pixwin(canvas);
		sun_win_rect = *((Rect *)window_get(canvas, WIN_RECT));
		window_default_event_proc( win, event, arg );
		peripheral_input++;
		break;
	case LOC_WINENTER:
	case LOC_WINEXIT:
	case LOC_RGNENTER:
	case LOC_RGNEXIT:
	case KBD_USE:
	case KBD_DONE:
		/* pass them on */
		/*printf("*** Gratuity ***\n");*/
		window_default_event_proc( win, event, arg );
		break;
	default:
		/*printf("*** Default event ***\n");*/
		window_default_event_proc( win, event, arg );
		break;
	}

	/*
	 * Used to do a notify_stop() here to wake up the
	 * bsdselect() if blocked, but this seems to be unsafe
	 * (some input events were lost).  So, we just use a
	 * short select timeout now and wait for it.
	 */
}

sun_key(eventP, button)
Event	*eventP;
int	button;
{
	if (event_is_down(eventP)) {
		sun_buttons[button] = 1;
		/*window_set(canvas,WIN_CONSUME_PICK_EVENT,LOC_MOVE,0);*/
	} else {
		sun_buttons[button] = 0;
		/*window_set(canvas,WIN_IGNORE_PICK_EVENT,LOC_MOVE,0);*/
	}
}

/* 
 *			S U N P W _ L I G H T
 */
/* ARGSUSED */
void
SunPw_light(cmd, func)
int	cmd;
int	func;		/* BE_ or BV_ function */
{
	return;
}

/* ARGSUSED */
unsigned
SunPw_cvtvecs(sp)
struct solid   *sp;
{
	return (0);
}

/*
 * Loads displaylist
 */
unsigned
SunPw_load(addr, count)
unsigned	addr, count;
{
	bu_log("SunPw_load(x%x, %d.)\n", addr, count);
	return (0);
}

void
SunPw_statechange( a, b )
int	a, b;
{
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( b )  {
	case ST_VIEW:
		/* constant tracking OFF */
		mouse_motion = 0;
		break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
		/* constant tracking ON */
		mouse_motion = 1;
		break;
	case ST_O_EDIT:
	case ST_S_EDIT:
		/* constant tracking OFF */
		mouse_motion = 0;
		break;
	default:
		bu_log("SunPw_statechange: unknown state %s\n", state_str[b]);
		break;
	}
	/*SunPw_viewchange( DM_CHGV_REDO, SOLID_NULL );*/
}

void
SunPw_viewchange()
{
}

/*
 * Color Map table
 */
static int sun_nslots = CMS_MGEDSIZE-2;	/* how many we have (static) */
static int slotsused = 0;		/* how many actually used */
static struct cmap {
	unsigned char   r;
	unsigned char   g;
	unsigned char   b;
} sun_cmap[CMS_MGEDSIZE];

/*
 *  			S U N P W _ C O L O R C H A N G E
 *  
 *  Go through the mater table, and allocate color map slots.
 */
void
SunPw_colorchange()
{
	register struct mater *mp;
	register int    i;
	char unsigned   red[256], grn[256], blu[256];

	if( slotsused == 0 ) {
		/* create a colormap segment */
		pw_setcmsname(sun_pw, CMS_MGED);
	}

	sun_cmap[0].r = 0;
	sun_cmap[0].g = 0;
	sun_cmap[0].b = 0;	/* Suntools Background */

	sun_cmap[1].r = 0;
	sun_cmap[1].g = 0;
	sun_cmap[1].b = 0;	/* DM_BLACK */
	sun_cmap[2].r = 255;
	sun_cmap[2].g = 0;
	sun_cmap[2].b = 0;	/* DM_RED */
	sun_cmap[3].r = 0;
	sun_cmap[3].g = 0;
	sun_cmap[3].b = 255;	/* DM_BLUE */
	sun_cmap[4].r = 255;
	sun_cmap[4].g = 255;
	sun_cmap[4].b = 0;	/* DM_YELLOW */
	sun_cmap[5].r = 255;
	sun_cmap[5].g = 255;
	sun_cmap[5].b = 255;	/* DM_WHITE */
	sun_cmap[6].r = 0;
	sun_cmap[6].g = 255;
	sun_cmap[6].b = 0;	/* Green */

	slotsused = 7;

	/* apply region-id based colors to the solid table */
	color_soltab();

	/* Map the colors in the solid table to colormap indices */
	sun_colorit();

	for( i = 0; i < slotsused; i++ ) {
		red[i] = sun_cmap[i].r;
		grn[i] = sun_cmap[i].g;
		blu[i] = sun_cmap[i].b;
	}
	/* fill in remainder with a "distinctive" color */
	while( i < CMS_MGEDSIZE ) {
		red[i] = 200;
		grn[i] = 200;
		blu[i] = 200;
		i++;
	}
	/*
	 * Set bottom (background) and top (foreground) equal so
	 * that suntools will fill in the "correct" values for us.
	 */
	red[CMS_MGEDSIZE-1] = red[0];
	grn[CMS_MGEDSIZE-1] = grn[0];
	blu[CMS_MGEDSIZE-1] = blu[0];
	pw_putcolormap(sun_pw, 0, CMS_MGEDSIZE, red, grn, blu);
	/* read back the corrected colors */
	pw_getcolormap(sun_pw, 0, CMS_MGEDSIZE, red, grn, blu);
	/* save returned foreground color at size-2 */
	red[CMS_MGEDSIZE-2] = red[CMS_MGEDSIZE-1];
	grn[CMS_MGEDSIZE-2] = grn[CMS_MGEDSIZE-1];
	blu[CMS_MGEDSIZE-2] = blu[CMS_MGEDSIZE-1];
	/* Set cursor (forground!) color */
	red[CMS_MGEDSIZE-1] = 255;
	grn[CMS_MGEDSIZE-1] =  80;
	blu[CMS_MGEDSIZE-1] =   0;
	pw_putcolormap(sun_pw, 0, CMS_MGEDSIZE, red, grn, blu);
}

int
sun_colorit()
{
	register struct solid	*sp;
	register struct cmap *rgb;
	register int    i;
	register int    r, g, b;

	FOR_ALL_SOLIDS( sp )  {
		r = sp->s_color[0];
		g = sp->s_color[1];
		b = sp->s_color[2];
		if( (r == 255 && g == 255 && b == 255) ||
		    (r == 0 && g == 0 && b == 0) )  {
		    	sp->s_dmindex = DM_WHITE;
			continue;
		}

		/* First, see if this matches an existing color map entry */
		rgb = sun_cmap;
		for( i = 0; i < slotsused; i++, rgb++ )  {
			if( rgb->r == r && rgb->g == g && rgb->b == b )  {
				sp->s_dmindex = i;
				goto next;
			}
		}

		/* If slots left, create a new color map entry, first-come basis */
		if( slotsused < sun_nslots )  {
			rgb = &sun_cmap[i=(slotsused++)];
			rgb->r = r;
			rgb->g = g;
			rgb->b = b;
			sp->s_dmindex = i;
			continue;
		}
		sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		;
	}
}

/* ARGSUSED */
void
SunPw_debug(lvl)
{
	sun_debug = lvl;
	return;
}

void
SunPw_window(w)
register int    w[];
{
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
}

sun_clear_win()
{
	sun_color(DM_BLACK);
	/* Clear entire window, regardless of how much is being used */
	pw_writebackground(sun_pw, 0, 0,
		sun_win_rect.r_width, sun_win_rect.r_height,
		PIX_SRC | PIX_COLOR(sun_cmap_color) );
}

Pr_texture
*sun_get_texP(dashed)
int	dashed;
{
	static Pr_texture dotdashed = {
		pr_tex_dashdot, 0, { 1, 1, 0, 0, } };

	if (dashed)
		return (&dotdashed);
	else
		return ((Pr_texture *) 0);
}
@


11.3
log
@rt_list ---> bu_list
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 11.2 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
@


11.2
log
@now using libbu
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 11.1 1995/01/04 10:02:57 mike Rel4_4 bparker $ (BRL)";
d30 1
d370 1
a370 1
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 10.7 94/12/24 01:05:21 mike Exp $ (BRL)";
d160 1
a160 1
		rt_log( "dm-sun: Must be running suntools\n" );
d285 1
a285 1
		rt_log("sun_color:  mged color %d not known\n", color);
d414 1
a414 1
				(void)rt_log(
d640 1
a640 1
		rt_log("Event %d at (%d %d)\n",id,event_x(event),event_y(event));
d644 1
a644 1
			rt_vls_strcat( &dm_values.dv_string , "zoom 2\n" );
d650 1
a650 1
			rt_vls_printf( &dm_values.dv_string , "M 1 %d %d\n" , xpen, ypen );
d656 1
a656 1
			rt_vls_strcat( &dm_values.dv_string , "zoom 0.5\n" );
d687 1
a687 1
						rt_vls_strcat( &dm_values.dv_string, str_buf );
d692 1
a692 1
					rt_vls_strcat( &dm_values.dv_string, str_buf );
d696 1
a696 1
					rt_vls_strcat( &dm_values.dv_string, str_buf );
d700 1
a700 1
					rt_vls_strcat( &dm_values.dv_string, str_buf );
d704 1
a704 1
					rt_vls_strcat( &dm_values.dv_string, str_buf );
d708 1
a708 1
					rt_vls_strcat( &dm_values.dv_string, str_buf );
d712 1
a712 1
					rt_vls_strcat( &dm_values.dv_string, str_buf );
d821 1
a821 1
	rt_log("SunPw_load(x%x, %d.)\n", addr, count);
d851 1
a851 1
		rt_log("SunPw_statechange: unknown state %s\n", state_str[b]);
@


10.7
log
@Eliminated old dm_values.dv_* style "polled" device interface.
Everything is done by string commands now.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 10.6 94/12/23 22:59:38 mike Exp Locker: mike $ (BRL)";
@


10.6
log
@Added code to skip per-vertex normals.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 10.5 94/12/16 19:36:13 gdurf Exp Locker: mike $ (BRL)";
a559 7

	/*
	 * Set device interface structure for GED to "rest" state.
	 */
	dm_values.dv_buttonpress = 0;
	dm_values.dv_flagadc = 0;
	dm_values.dv_penpress = 0;
@


10.5
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 10.4 1994/09/07 13:17:51 jra Exp gdurf $ (BRL)";
d383 1
@


10.4
log
@Converted to use dm_values.dv_string instead of changing values directly.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 10.3 94/08/10 21:42:53 mike Exp Locker: jra $ (BRL)";
d160 1
a160 1
		fprintf( stderr, "dm-sun: Must be running suntools\n" );
d285 1
a285 1
		printf("sun_color:  mged color %d not known\n", color);
d413 1
a413 1
				(void)fprintf( stderr,
d646 1
a646 1
		printf("Event %d at (%d %d)\n",id,event_x(event),event_y(event));
d827 1
a827 1
	(void) printf("SunPw_load(x%x, %d.)\n", addr, count);
d857 1
a857 1
		(void)printf("SunPw_statechange: unknown state %s\n", state_str[b]);
@


10.3
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 10.2 94/08/09 15:15:02 gdurf Exp Locker: mike $ (BRL)";
d640 1
d643 2
a644 3
	dm_values.dv_penpress = 0;
	dm_values.dv_xpen = SUNPWx_TO_GED(event_x(event));
	dm_values.dv_ypen = -SUNPWy_TO_GED(event_y(event));
d650 1
a650 1
			dm_values.dv_penpress = DV_OUTZOOM;
d656 1
a656 1
			dm_values.dv_penpress = DV_PICK;
d662 1
a662 1
			dm_values.dv_penpress = DV_INZOOM;
d669 1
a669 1
		xval = (float) dm_values.dv_xpen / 2048.;
d674 1
a674 1
		yval = (float) dm_values.dv_ypen / 2048.;
d680 2
d686 9
a694 3
					dm_values.dv_zoom = (yval*yval) / 2;
					if (yval < 0)
					    dm_values.dv_zoom = -dm_values.dv_zoom;
d697 2
a698 1
					dm_values.dv_xslew = xval;
d701 2
a702 1
					dm_values.dv_yslew = yval;
d705 2
a706 1
					dm_values.dv_yslew = yval;
d709 2
a710 1
					dm_values.dv_xjoy = xval;
d713 2
a714 1
					dm_values.dv_yjoy = yval;
d717 2
a718 1
					dm_values.dv_zjoy = yval;
a727 1
		dm_values.dv_zoom = 0.0;
a730 1
		dm_values.dv_xslew = 0.0;
a733 1
		dm_values.dv_yslew = 0.0;
a736 1
		dm_values.dv_yslew = 0.0;
a739 3
		dm_values.dv_xjoy = 0.0;
		dm_values.dv_yjoy = 0.0;
		dm_values.dv_zjoy = 0.0;
a742 3
		dm_values.dv_xjoy = 0.0;
		dm_values.dv_yjoy = 0.0;
		dm_values.dv_zjoy = 0.0;
a745 3
		dm_values.dv_xjoy = 0.0;
		dm_values.dv_yjoy = 0.0;
		dm_values.dv_zjoy = 0.0;
@


10.2
log
@Added include of conf.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 10.1 1991/10/12 06:43:32 mike Rel4_0 gdurf $ (BRL)";
d59 1
a59 1
int             SunPw_input();
d538 4
a541 3
 * Returns:
 *	0 if no command waiting to be read,
 *	1 if command is waiting to be read.
d543 4
a546 3
SunPw_input(cmd_fd, noblock)
int	cmd_fd;
int	noblock;	/* !0 => poll */
d548 5
a552 2
	long            readfds;
	struct timeval  timeout;
d554 6
d581 2
a582 2
		timeout.tv_sec = 0;
		timeout.tv_usec = 0;
d584 2
a585 2
		timeout.tv_sec = 0;
		timeout.tv_usec = 200000;
d588 7
a594 5
		readfds = (1 << cmd_fd) | (1 << sun_win_fd);
		/*notify_do_dispatch(); Unsafe!*/
		readfds = bsdselect(readfds, timeout.tv_sec, timeout.tv_usec);
		/*printf("readfds = %d (cmd %d, win %d)\n",
			readfds, 1<<cmd_fd, 1<<sun_win_fd );*/
a595 4
		if( readfds & (1 << cmd_fd) ) {
			/*printf("Returning command\n");*/
			return (1);		/* command awaits */
		}
d599 1
a599 1
			return (0);		/* just peripheral stuff */
d601 1
a601 1
		if( readfds & (1 << sun_win_fd) ) {
d608 4
a611 1
			return (0);
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 9.2 91/02/02 00:14:03 mike Exp $ (BRL)";
d25 2
@


9.2
log
@Converted to new rt_vlist structures
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-sun.c,v 9.1 89/05/19 06:02:45 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.9 89/05/17 03:30:58 phil Exp $ (BRL)";
d353 1
a353 1
	register struct vlist	*vp;
d359 1
a359 1
	static vect_t   pt;			/* working point */
d367 7
a373 3
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		MAT4X3PNT(pt, mat, vp->vl_pnt);
		/* Visible range is +/- 1.0 */
d376 40
a415 18
		if( pt[0] < -1e6 || pt[0] > 1e6 ||
		    pt[1] < -1e6 || pt[1] > 1e6 )
			continue;		/* omit this point (ugh) */

		/* Integerize and let the Sun library do the clipping */
		ptP->x = GED_TO_SUNPWx(2048*pt[0]);
		ptP->y = GED_TO_SUNPWy(2048*pt[1]);
		ptP++;
		if( vp->vl_draw )
			*mvP++ = 0;
		else
			*mvP++ = 1;

		if( ++numvec >= MAXVEC ) {
			(void)fprintf( stderr,
				"SunPw_object: nvec %d clipped to %d\n",
				sp->s_vlen, numvec );
			break;
@


8.9
log
@Made it more selective about which events it gives back to MGED so
things like mouse motions can often be rolled together.  The problem
is that MGED does a screen update for every single event that we
return.  This can make input fall way behind if drawing is slow.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.8 89/04/06 20:39:41 phil Locked $ (BRL)";
@


8.8
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.7 89/04/03 20:56:30 mike Locked $ (BRL)";
d90 1
d558 3
a560 1
		} else if( peripheral_input ) {
a561 1
			/*printf("Returning peripherals\n");*/
d564 5
d605 2
a606 1
	/*printf("Event %d at (%d %d)\n",id,event_x(event),event_y(event));*/
d609 1
a609 1
		if (event_is_down(event))
d611 2
d615 1
a615 1
		if (event_is_down(event))
d617 2
d621 1
a621 1
		if (event_is_down(event))
d623 2
d641 1
d669 2
d720 1
a737 1
	peripheral_input++;
d791 2
a792 1
SunPw_statechange()
d794 26
@


8.7
log
@Bit the bullet and moved the icon out into an include file
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.6 89/01/25 04:47:47 phil Locked $ (BRL)";
d33 1
@


8.6
log
@added an icon, fixed problem with center dot, switched to bsdselect()
went back to short select timeout loop (more reliable)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.5 89/01/24 23:10:49 phil Locked $ (BRL)";
d104 3
a106 1
extern short icon_image[];		/* it's really static, but... */
a956 37

static short icon_image[] = {
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
 */
	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8002,0x0000,0x0000,0x0001,
	0x8002,0x0000,0x0000,0x0001,0x8002,0x0000,0x0000,0x0001,
	0x8002,0x000C,0x0000,0x0001,0xFFFE,0x0032,0x0000,0x0001,
	0x8000,0x006E,0x0000,0x0001,0x8000,0x00BF,0x0000,0x0001,
	0x8000,0x01E5,0x0000,0x0001,0x8000,0x03C5,0x0000,0x0001,
	0x8000,0x03C5,0x8000,0x0001,0x8000,0x02C7,0x8000,0x0001,
	0x8000,0x0385,0x0000,0x0001,0x8000,0x0385,0x0000,0x0001,
	0x8000,0x078F,0x8000,0x0001,0x8000,0x078E,0xE000,0x0001,
	0x8000,0x078A,0xC000,0x0001,0x8000,0x039D,0xA0C0,0x0001,
	0x8000,0x02BE,0x23B8,0x0001,0x8000,0x03FF,0x2C86,0x0001,
	0x8000,0x02FF,0xEB8E,0x0001,0x8000,0x03E1,0xFCF2,0x0001,
	0x8000,0x0F8C,0x1FA2,0x0001,0x8000,0x17CC,0x0BFA,0x0001,
	0x8000,0x7B4C,0x08FF,0x0001,0x8000,0xA520,0x093F,0xE001,
	0x8003,0x4520,0x0E26,0xFC01,0x8005,0x8520,0x0F2C,0x1F81,
	0x801A,0x07E0,0x00F0,0x03E1,0x806C,0x08B0,0x0000,0x00E1,
	0x8090,0x0890,0x0000,0x01C1,0x8360,0x0FE0,0x0000,0x0701,
	0x8680,0x0000,0x0000,0x1E01,0x87C0,0x0000,0x0000,0x2801,
	0x8638,0x0000,0x0000,0xF001,0x81C7,0x0000,0x0001,0x4001,
	0x8038,0xE000,0x0006,0x8001,0x8007,0x1E00,0x000B,0x0001,
	0x8000,0xE1C0,0x0034,0x0001,0x8000,0x1E38,0x00D8,0x0001,
	0x8000,0x01C7,0x0120,0x0001,0x8000,0x0038,0xE6C0,0x0001,
	0x8000,0x0007,0x1900,0x0001,0x8000,0x0000,0xEE00,0x0001,
	0x8000,0x0000,0x1800,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0xFFFF,0xFFFF,0xFFFF,0xFFFF
};
@


8.5
log
@Updated for new way of doing colors
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.4 88/12/06 01:07:03 mike Locked $ (BRL)";
d104 3
d160 1
d252 3
d257 1
a257 1
			sun_cmap_color = 0;		 /* background */
d259 1
a259 1
			sun_cmap_color = CMS_MGEDSIZE-2; /* foreground */
d304 1
a304 1
		PIX_COLOR(sun_cmap_color));
d495 10
a504 3
 * I have the feeling that very short select timeouts for notify_dispatch()
 * polling is more reliable than the notify_do_dispatch()/stop_notify() pair.
 * But this is the way we *should* do it, right? (See pg 266)
a515 1
	int             numfds;
d541 2
a542 2
		timeout.tv_sec = 60;
		timeout.tv_usec = 0;
d546 4
a549 4
		notify_do_dispatch();
		numfds = select(32, &readfds, (long *)0, (long *)0, &timeout);
		/*printf("num = %d, val = %d (cmd %d, win %d)\n",
			numfds, readfds, 1<<cmd_fd, 1<<sun_win_fd );*/
d718 6
a723 1
	notify_stop();		/* wake our select up */
d955 37
@


8.4
log
@Added #include <raytrace.h> for vector list stuff
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.3 88/11/30 05:02:19 mike Locked $ (BRL)";
a348 1
	struct mater	*mp;
a387 1
	mp = (struct mater *) sp->s_materp;
d392 1
a392 1
		color = PIX_COLOR(mp->mt_dm_int);
a813 2
	for (mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw)
		sun_colorit(mp);
d815 2
a816 1
	color_soltab();		/* apply colors to the solid table */
d818 3
d855 1
a855 2
sun_colorit(mp)
struct mater   *mp;
d857 4
a860 3
    register struct cmap *rgb;
    register int    i;
    register int    r, g, b;
d862 9
a870 9
    r = mp->mt_r;
    g = mp->mt_g;
    b = mp->mt_b;
    if ((r == 255 && g == 255 && b == 255) ||
	(r == 0 && g == 0 && b == 0))
    {
	mp->mt_dm_int = DM_WHITE;
	return;
    }
d872 20
a891 8
    /* First, see if this matches an existing color map entry */
    rgb = sun_cmap;
    for (i = 0; i < slotsused; i++, rgb++)
    {
	if (rgb->r == r && rgb->g == g && rgb->b == b)
	{
	    mp->mt_dm_int = i;
	    return;
a892 13
    }

    /* If slots left, create a new color map entry, first-come basis */
    if (slotsused < sun_nslots)
    {
	rgb = &sun_cmap[i = (slotsused++)];
	rgb->r = r;
	rgb->g = g;
	rgb->b = b;
	mp->mt_dm_int = i;
	return;
    }
    mp->mt_dm_int = DM_YELLOW;	/* Default color */
@


8.3
log
@fixed color and colormap usage, and text display, for color suns
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.2 88/11/27 19:55:33 phil Locked $ (BRL)";
d30 1
@


8.2
log
@fixed bug in vector list truncation
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 8.1 88/10/05 00:36:33 phil Locked $ (BRL)";
d44 6
d96 1
a96 1
int             sun_cmap_color = 7;	/* for default colormap */
d183 2
a184 12
		/* set a new cms name; initialize it */
		pw_setcmsname(sun_pw, "mged");
		/* default colormap, real one is set by SunPw_colorchange */
		red[0] =   0; grn[0] =   0; blu[0] =   0;	/* Black */
		red[1] = 255; grn[1] =   0; blu[1] =   0;	/* Red */
		red[2] =   0; grn[2] = 255; blu[2] =   0;	/* Green */
		red[3] = 255; grn[3] = 255; blu[3] =   0;	/* Yellow */
		red[4] =   0; grn[4] =   0; blu[4] = 255;	/* Blue */
		red[5] = 255; grn[5] =   0; blu[5] = 255;	/* Magenta */
		red[6] =   0; grn[6] = 255; blu[6] = 255;	/* Cyan */
		red[7] = 255; grn[7] = 255; blu[7] = 255;	/* White */
		pw_putcolormap(sun_pw, 0, 8, red, grn, blu);
d242 5
a246 3
		 * background (DM_BLACK) is white, from Sun color value 0,
		 * foreground (DM_WHITE) is black, from Sun color value 1.
		 * HOWEVER, in a graphics window, somehow this seems reversed.
d249 1
a249 1
			sun_cmap_color = 1;
d251 1
a251 3
			sun_cmap_color = 0;
		/* Note that color value of 0 becomes -1 (foreground) (=1),
		 * according to pg 14 of Pixrect Ref Man (V.A or 17-Feb-86) */
d256 1
a256 1
		sun_cmap_color = 0;
d259 1
a259 1
		sun_cmap_color = 1;
d262 1
a262 1
		sun_cmap_color = 4;
d265 1
a265 1
		sun_cmap_color = 3;
d268 1
a268 1
		sun_cmap_color = 7;
d446 9
a454 3
	pw_text(sun_pw, GED_TO_SUNPWx(x), GED_TO_SUNPWy(y),
		(PIX_NOT(PIX_SRC)) | PIX_COLOR(sun_cmap_color),
		sun_font_ptr, str);
d490 1
a490 1
 * polling is more reliable than the notify_do_display()/stop_notify() pair.
d766 3
a768 4
#define NSLOTS	256
static int      sun_nslots = 0;	/* how many we have, <= NSLOTS */
static int      slotsused;	/* how many actually used */
static struct rgbtab {
d772 1
a772 1
} sun_rgbtab[NSLOTS];
a777 2
 *	8 bit system gives 4 or 8,
 *	24 bit system gives 12 or 24.
d782 3
a784 3
    register struct mater *mp;
    register int    i;
    char unsigned   red[256], grn[256], blu[256];
d786 4
a789 22
    if (!sun_nslots)
    {
	sun_nslots = 256;	/* ## hardwire cg2, for now */
	if (sun_nslots > NSLOTS)
	    sun_nslots = NSLOTS;
    }
    sun_rgbtab[0].r = 0;
    sun_rgbtab[0].g = 0;
    sun_rgbtab[0].b = 0;	/* Black */
    sun_rgbtab[1].r = 255;
    sun_rgbtab[1].g = 0;
    sun_rgbtab[1].b = 0;	/* Red */
    sun_rgbtab[2].r = 0;
    sun_rgbtab[2].g = 0;
    sun_rgbtab[2].b = 255;	/* Blue */
    sun_rgbtab[3].r = 255;
    sun_rgbtab[3].g = 255;
    sun_rgbtab[3].b = 0;	/* Yellow */
    sun_rgbtab[4].r = sun_rgbtab[4].g = sun_rgbtab[4].b = 255;	/* White */
    sun_rgbtab[5].g = 255;	/* Green */
    sun_rgbtab[6].r = sun_rgbtab[6].g = sun_rgbtab[6].b = 128;	/* Grey */
    sun_rgbtab[7].r = sun_rgbtab[7].g = sun_rgbtab[7].b = 255;	/* White TEXT */
d791 3
a793 5
    slotsused = 8;
    for (mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw)
	sun_colorit(mp);
    if (sun_debug)
	printf("colorchange, %d slots used\n", slotsused);
d795 18
a812 1
    color_soltab();		/* apply colors to the solid table */
d814 37
a850 7
    for (i = 0; i < slotsused; i++)
    {
	red[i] = sun_rgbtab[i].r;
	grn[i] = sun_rgbtab[i].g;
	blu[i] = sun_rgbtab[i].b;
    }
    pw_putcolormap(sun_pw, 0, slotsused, red, grn, blu);
d857 1
a857 1
    register struct rgbtab *rgb;
d872 1
a872 1
    rgb = sun_rgbtab;
d885 1
a885 1
	rgb = &sun_rgbtab[i = (slotsused++)];
@


8.1
log
@Release_3.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 7.7 88/09/15 21:43:49 phil Exp $ (BRL)";
d337 1
d348 2
a349 2
	struct pr_pos   ptlist[1024+1];		/* Sun point buffer */
	u_char          mvlist[1024+1];		/* Sun move/draw buffer */
d378 1
a378 1
		if( numvec++ > 1024 ) {
d380 2
a381 2
				"SunPw_object: nvec %d clipped to 1024\n",
				sp->s_vlen );
@


7.7
log
@added releasedisplay flag, fixed up F1-F9 key functions
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 7.7 88/09/15 21:00:00 phil Exp $ (BRL)";
@


7.6
log
@screen update batching
several other things have been fixed/added - new input structure,
the F keys, auto repaint, the center point, a drawing bug, etc.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 7.5 88/08/12 23:21:46 phil Locked $ (BRL)";
d74 1
d76 1
a76 1
	"sun", "SunView 1.0/Sun release 3.x pixwin library"
d552 7
a558 8
#define	ZOOM_BUTTON	1
#define	SLEW_BUTTON	2
#define	X_ROT_BUTTON	3
#define	Y_ROT_BUTTON	4
#define	Z_ROT_BUTTON	5
#define	XY_ROT_BUTTON	6
#define	YZ_ROT_BUTTON	7
#define	XZ_ROT_BUTTON	8
d611 2
a612 2
					dm_values.dv_zoom = ((xval*xval) + (yval*yval)) / 2;
					if (xval < 0)
d615 1
a615 1
				case SLEW_BUTTON:
d617 2
d621 3
d625 1
a625 1
					dm_values.dv_xjoy = yval;
a632 12
				case XY_ROT_BUTTON:
					dm_values.dv_xjoy = xval;
					dm_values.dv_yjoy = yval;
					break;
				case YZ_ROT_BUTTON:
					dm_values.dv_yjoy = yval;
					dm_values.dv_zjoy = xval;
					break;
				case XZ_ROT_BUTTON:
					dm_values.dv_xjoy = xval;
					dm_values.dv_zjoy = yval;
					break;
d641 2
a642 2
	case KEY_TOP(SLEW_BUTTON):
		sun_key(event, SLEW_BUTTON);
d644 3
d649 4
a669 20
		break;
	case KEY_TOP(XY_ROT_BUTTON):
		sun_key(event, XY_ROT_BUTTON);
		dm_values.dv_xjoy = 0.0;
		dm_values.dv_yjoy = 0.0;
		dm_values.dv_zjoy = 0.0;
		break;
	case KEY_TOP(YZ_ROT_BUTTON):
		sun_key(event, YZ_ROT_BUTTON);
		dm_values.dv_xjoy = 0.0;
		dm_values.dv_yjoy = 0.0;
		dm_values.dv_zjoy = 0.0;
		break;
	case KEY_TOP(XZ_ROT_BUTTON):
		sun_key(event, XZ_ROT_BUTTON);
		dm_values.dv_xjoy = 0.0;
		dm_values.dv_yjoy = 0.0;
		dm_values.dv_zjoy = 0.0;
		break;
	case KEY_TOP(9):
@


7.5
log
@checkpoint - a mostly functional SunView version
@
text
@d10 3
a12 2
 *	Bill Lindemann
 *  
d19 2
a20 1
 *	You're welcome to it.
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 7.4 88/02/25 06:23:30 phil Locked $ (BRL)";
d59 17
a75 17
struct dm       dm_SunPw = {
			    SunPw_open, SunPw_close,
			    SunPw_input,
			    SunPw_prolog, SunPw_epilog,
			    SunPw_normal, SunPw_newrot,
			    SunPw_update,
			    SunPw_puts, SunPw_2d_line,
			    SunPw_light,
			    SunPw_object,
			    SunPw_cvtvecs, SunPw_load,
			    SunPw_statechange,
			    SunPw_viewchange,
			    SunPw_colorchange,
			    SunPw_window, SunPw_debug,
			    0,	/* no displaylist */
			    SUNPWBOUND,
			 "sun", "SunView 1.0/Sun release 3.x pixwin library"
a140 2
	 * We could then open it, size it, create a subwindow within it,
	 * etc. but who cares.  We will make our own window.
d154 1
a154 1
	/* Fit window to canvas (width+20, height+20) */
a161 3
/*printf("left,top,width,height=(%d %d %d %d)\n",
sun_win_rect.r_left, sun_win_rect.r_top,
sun_win_rect.r_width, sun_win_rect.r_height );*/
d163 4
d168 5
a172 5
	window_set( canvas, WIN_CONSUME_KBD_EVENT,
		WIN_TOP_KEYS, 0 );
	window_set( canvas, WIN_CONSUME_PICK_EVENT,
		WIN_MOUSE_BUTTONS, 0 );
	window_set( canvas, WIN_EVENT_PROC, input_eater, 0 );
a173 2
	/*fcntl(sun_win_fd, F_SETFL, FNDELAY);*/

d235 2
d290 3
d298 2
a299 1
	pw_put(sun_pw, GED_TO_SUNPWx(0), GED_TO_SUNPWy(0), 1);
d308 2
d339 1
a339 1
register struct solid *sp;
d343 9
a351 9
	register struct pr_pos *ptP;
	u_char         *mvP;
	static vect_t   pt;
	register struct vlist *vp;
	struct mater   *mp;
	int             nvec, totalvec;
	struct pr_pos   polylist[1024+1];
	u_char          mvlist[1024+1];
	Pr_texture     *texP;
d355 1
a355 8
	if( white )  brush = &sun_whitebrush;
	else brush = (Pr_brush *)0;

	texP = sun_get_texP(sp->s_soldash);
	mp = (struct mater *) sp->s_materp;

	nvec = sp->s_vlen;
	ptP = polylist;
d357 1
a357 5
	if (nvec > 1024)  {
		(void) fprintf(stderr, "SunPw_object: nvec %d clipped to 1024\n", nvec);
		nvec = 1024;
	}
	totalvec = 0;
d366 1
d371 3
a373 1
		if (vp->vl_draw == 0)
d375 7
a381 3
		else
			*mvP++ = 0;
		totalvec++;
d383 9
a391 2
	mvlist[0] = 0;
	if( sun_depth < 8 )  {
d394 1
a394 1
	} else
d396 6
a401 3
	pw_polyline(sun_pw, 0, 0, totalvec, polylist, mvlist, brush,
	    texP, PIX_SRC | color );
	return(totalvec);	/* non-zero means it did something */
d431 5
a435 2
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
d442 5
a475 19
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 * Returns:
 *	0 if no command waiting to be read,
 *	1 if command is waiting to be read.
 */
#define	NBUTTONS	10
#define	ZOOM_BUTTON	1
#define	SLEW_BUTTON	2
#define	XY_ROT_BUTTON	3
#define	YZ_ROT_BUTTON	4
#define	XZ_ROT_BUTTON	5
int	sun_buttons[NBUTTONS];

/*
 *			S U N P W _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
d485 3
a487 3
 * We might be able to replace the short select timeout polling by
 * notify_do_dispatch() coupled with notify_stop() in input_eater().
 * XXX Try this. See pg 266.
d502 7
d525 2
a526 2
		timeout.tv_sec = 0;
		timeout.tv_usec = 250000;	/* 1/4 second */
d530 1
d532 2
a533 2
/*printf("num = %d, val = %d (cmd %d, win %d)\n",
	numfds, readfds, 1<<cmd_fd, 1<<sun_win_fd );*/
d536 1
a536 1
/*printf("Returning command\n");*/
d540 1
a540 1
/*printf("Returning peripherals\n");*/
d543 2
a544 1
		if( noblock )
d546 1
d550 11
d576 1
a577 1
	id = event_id(event);
d580 1
a580 1
/*printf( "Event %d at (%d %d)\n", id, event_x(event), event_y(event));*/
d607 2
a608 2
		for (button = 0; button < NBUTTONS; button++) {
			if (sun_buttons[button]) {
d619 9
d653 18
a688 6
	case KEY_TOP(6):
		break;
	case KEY_TOP(7):
		break;
	case KEY_TOP(8):
		break;
d695 2
a696 1
		dmaflag = 1;	/* causes refresh */
d699 1
d717 1
a717 1
		printf("*** Default event ***\n");
d723 1
d732 1
a732 1
		window_set(frame,WIN_CONSUME_PICK_EVENT,LOC_MOVE,0);
d735 1
a735 1
		/*window_set(frame,WIN_IGNORE_PICK_EVENT,LOC_MOVE,0);*/
d846 2
a847 1
int             sun_colorit(mp)
@


7.4
log
@Fix from Elizabeth Swisher of MITRE Corp. for
sunpw_close() routine
@
text
@d4 1
a4 2
 * Driver for SUN using SunView pixwins library.
 * This will use a GP if present, but will not do shaded stuff.
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 7.3 88/02/25 06:06:45 mike Locked $ (BRL)";
a33 1
#include <sunwindow/window_hs.h>
d37 1
a41 2
/* typedef unsigned char u_char; */

d76 1
d78 1
d81 1
a81 1
/* static char     ttybuf[BUFSIZ]; */
d83 2
a84 1
Pixwin         *sun_master_pw;		/* area of screen available */
a89 1
Rect            sun_master_rect;
a91 1
int             sun_damaged;
a92 1
Inputmask       sun_input_mask;
d97 1
a97 4
 *  and we define (for the moment) window coordinates to be 0...512
 *
 *  NOTE that the Sun is 4th quadrant, so the user of these macros
 *  has to flip his Y values.
d99 5
a103 2
#define	GED_TO_SUNPW(x)	((((int)(x))+2048)>>3)
#define SUNPW_TO_GED(x)	((((int)(x))<<3)-2048)
d106 6
a111 1
Notify_value    sun_sigwinch()
d113 6
a118 3
                    pw_damaged(sun_pw);
    pw_donedamaged(sun_pw);
    sun_damaged = 1;
a128 1
	Rect            rect;
d131 1
d133 2
a134 2
#ifdef	DISABLED
	struct gfxsubwindow *mine;
d137 4
a140 2
	 * Get graphics subwindow, get its size, and trap alarm clock and interrupt
	 * signals. 
d142 4
a145 7
	mine = gfxsw_init(0, 0);
	sun_pw = mine->gfx_pixwin;
	win_getsize(sun_pw->pw_clipdata->pwcd_windowfd, &rect);
	sun_win_rect = rect;
#endif	DISABLED
#ifdef	DISABLED
	Window          frame;
d147 1
d149 7
a155 5
	    WIN_WIDTH, 600,
	    WIN_HEIGHT, 600,
	    0);
	sun_pw = window_get(frame, WIN_PIXWIN);
#endif	DISABLED
d157 8
a164 5
	{
		int             gfxfd;
		char            gfxwinname[128];
		int		width, height;
		int		size;
d166 6
a171 4
		sun_win_fd = win_getnewwindow();
		we_getgfxwindow(gfxwinname);
		gfxfd = open(gfxwinname, 2);
		win_insertblanket(sun_win_fd, gfxfd);
d173 1
a173 9
		if( (sun_master_pw = pw_open(sun_win_fd)) == (Pixwin *)0 )  {
			fprintf(stderr,"sun: pw_open failed\n");
			return(-1);
		}
		win_getsize(sun_win_fd, &sun_master_rect);
		width = sun_master_rect.r_width;
		height = sun_master_rect.r_height;
		if( width > height )  size = height;
		else  size = width;
d175 1
a175 25
		if( size < 512 ) printf("screen is not 512x512 pixels!\n");
		/* XXX should be size, not 512 */
		sun_pw = pw_region(sun_master_pw, 0, 0, 512, 512);
		win_getsize(sun_win_fd, &rect);
		sun_win_rect = rect;
		sun_depth = sun_pw->pw_pixrect->pr_depth;

		input_imnull(&sun_input_mask);
		sun_input_mask.im_flags |= IM_NEGEVENT;
		win_setinputcodebit(&sun_input_mask, MS_LEFT);
		win_setinputcodebit(&sun_input_mask, MS_MIDDLE);
		win_setinputcodebit(&sun_input_mask, MS_RIGHT);
		win_setinputcodebit(&sun_input_mask, KEY_TOP(1));
		win_setinputcodebit(&sun_input_mask, KEY_TOP(2));
		win_setinputcodebit(&sun_input_mask, KEY_TOP(3));
		win_setinputcodebit(&sun_input_mask, KEY_TOP(4));
		win_setinputcodebit(&sun_input_mask, KEY_TOP(5));
		win_setinputcodebit(&sun_input_mask, KEY_TOP(6));
		win_setinputcodebit(&sun_input_mask, KEY_TOP(7));
		win_setinputcodebit(&sun_input_mask, KEY_TOP(8));
		win_setinputcodebit(&sun_input_mask, KEY_TOP(9));
		win_set_pick_mask(sun_win_fd, &sun_input_mask);
		fcntl(sun_win_fd, F_SETFL, FNDELAY);
	}

d180 8
a187 24
		red[0] = 0;
		grn[0] = 0;
		blu[0] = 0;
		red[1] = 255;
		grn[1] = 0;
		blu[1] = 0;
		red[2] = 0;
		grn[2] = 255;
		blu[2] = 0;
		red[3] = 255;
		grn[3] = 255;
		blu[3] = 0;
		red[4] = 0;
		grn[4] = 0;
		blu[4] = 255;
		red[5] = 255;
		grn[5] = 0;
		blu[5] = 255;
		red[6] = 0;
		grn[6] = 255;
		blu[6] = 255;
		red[7] = 255;
		grn[7] = 255;
		blu[7] = 255;
d190 1
a190 1
		pr_blackonwhite( sun_pw->pw_pixrect, 0, 1 );
d195 1
a195 2
	if (sun_font_ptr == (struct pixfont *) 0)
	{
d200 5
a204 1
	notify_set_signal_func(SunPw_open, sun_sigwinch, SIGWINCH, NOTIFY_ASYNC);
d212 1
d214 2
a215 1
void	SunPw_close()
d217 15
a231 8
	/* Disable the asynchronous notifications before closing FDs */
	notify_set_signal_func(SunPw_open,
		NOTIFY_FUNC_NULL, SIGWINCH, NOTIFY_ASYNC);

	pw_close(sun_pw);
	pw_close(sun_master_pw);
	(void)close(sun_win_fd);
	sun_win_fd = -1;
d238 1
a238 1
int             color;
d256 1
a256 2
	switch (color)
	{
d283 2
a284 1
void            SunPw_prolog()
d294 1
a294 1
	pw_put(sun_pw, GED_TO_SUNPW(0), GED_TO_SUNPW(0), 1);
d300 2
a301 1
void            SunPw_epilog()
d303 1
a303 1
                    return;
d311 3
a313 2
void            SunPw_newrot(mat)
mat_t           mat;
d315 1
a315 1
    return;
d330 2
a331 1
int             SunPw_object(sp, mat, ratio, white)
d333 2
a334 2
mat_t           mat;
double          ratio;
a341 1
	int             useful = 0;
d361 1
a361 1
	totalvec = nvec;
d371 2
a372 2
		ptP->x = GED_TO_SUNPW( 2048*pt[0]);
		ptP->y = GED_TO_SUNPW(-2048*pt[1]);
d378 1
a378 1
		useful++;
d388 1
a388 1
	return(useful);
d398 2
a399 1
void            SunPw_normal()
d401 1
a401 1
                    return;
d409 2
a410 1
void            SunPw_update()
d412 1
a412 1
                    return;
d422 2
a423 1
void            SunPw_puts(str, x, y, size, color)
d427 1
a427 1
	pw_text(sun_pw, GED_TO_SUNPW(x), GED_TO_SUNPW(-y),
d436 5
a440 4
void            SunPw_2d_line(x1, y1, x2, y2, dashed)
int             x1, y1;
int             x2, y2;
int             dashed;
d442 1
a442 1
    Pr_texture     *texP;
d444 4
a447 4
    sun_color(DM_YELLOW);
    texP = sun_get_texP(dashed);
    pw_line(sun_pw, GED_TO_SUNPW(x1), GED_TO_SUNPW(-y1),
	    GED_TO_SUNPW(x2), GED_TO_SUNPW(-y2), (Pr_brush *) 0, texP,
d470 21
d492 2
d495 3
a497 9
    long            readfds;
    struct timeval  timeout;
    int             numfds;
    int             ret;
    int             id;
    int             button;
    float           xval;
    float           yval;
    Event           event;
d499 38
a536 22
    /*
     * Check for input on the keyboard or on the polled registers. 
     *
     * Suspend execution until either 1)  User types a full line 2)  The timelimit
     * on SELECT has expired 
     *
     * If a RATE operation is in progress (zoom, rotate, slew) in which we still
     * have to update the display, do not suspend execution. 
     */
    readfds = (1 << cmd_fd) | (1 << sun_win_fd);
    if (noblock)
    {
	timeout.tv_sec = 0;
	timeout.tv_usec = 0;
	numfds = select(32, &readfds, (long *) 0, (long *) 0, &timeout);
    }
    else
    {
	timeout.tv_sec = 30 * 60;	/* 30 mins */
	timeout.tv_usec = 0;
	numfds = select(32, &readfds, (long *) 0, (long *) 0, &timeout);
    }
d538 21
a558 8
    dm_values.dv_penpress = 0;
    if ((ret = input_readevent(sun_win_fd, &event)) != -1)
    {
	id = event_id(&event);
	dm_values.dv_xpen = SUNPW_TO_GED(event_x(&event));
	dm_values.dv_ypen = -SUNPW_TO_GED(event_y(&event));
	switch(id)
	{
d560 3
a562 3
	    if (event_is_down(&event))
		dm_values.dv_penpress = DV_OUTZOOM;
	    break;
d564 3
a566 3
	    if (event_is_down(&event))
		dm_values.dv_penpress = DV_PICK;
	    break;
d568 3
a570 3
	    if (event_is_down(&event))
		dm_values.dv_penpress = DV_INZOOM;
	    break;
d572 1
a572 1
	    break;
d574 36
a609 38
	    xval = (float) dm_values.dv_xpen / 2048.;
	    if (xval < -1.0)
		xval = -1.0;
	    if (xval > 1.0)
		xval = 1.0;
	    yval = (float) dm_values.dv_ypen / 2048.;
	    if (yval < -1.0)
		yval = -1.0;
	    if (yval > 1.0)
		yval = 1.0;
	    for (button = 0; button < NBUTTONS; button++)
	    {
		if (sun_buttons[button])
		{
		    switch(button)
		    {
		    case ZOOM_BUTTON:
			dm_values.dv_zoom = ((xval*xval) + (yval*yval)) / 2;
			if (xval < 0)
			    dm_values.dv_zoom = -dm_values.dv_zoom;
			break;
		    case SLEW_BUTTON:
			dm_values.dv_xslew = xval;
			dm_values.dv_yslew = yval;
			break;
		    case XY_ROT_BUTTON:
			dm_values.dv_xjoy = xval;
			dm_values.dv_yjoy = yval;
		    	break;
		    case YZ_ROT_BUTTON:
			dm_values.dv_yjoy = yval;
			dm_values.dv_zjoy = xval;
		    	break;
		    case XZ_ROT_BUTTON:
			dm_values.dv_xjoy = xval;
			dm_values.dv_zjoy = yval;
			break;
		    }
d611 1
a611 2
	    }
	    break;
d613 3
a615 3
	    sun_key(&event, ZOOM_BUTTON);
	    dm_values.dv_zoom = 0.0;
	    break;
d617 4
a620 4
	    sun_key(&event, SLEW_BUTTON);
	    dm_values.dv_xslew = 0.0;
	    dm_values.dv_yslew = 0.0;
	    break;
d622 5
a626 5
	    sun_key(&event, XY_ROT_BUTTON);
	    dm_values.dv_xjoy = 0.0;
	    dm_values.dv_yjoy = 0.0;
	    dm_values.dv_zjoy = 0.0;
	    break;
d628 5
a632 5
	    sun_key(&event, YZ_ROT_BUTTON);
	    dm_values.dv_xjoy = 0.0;
	    dm_values.dv_yjoy = 0.0;
	    dm_values.dv_zjoy = 0.0;
	    break;
d634 5
a638 5
	    sun_key(&event, XZ_ROT_BUTTON);
	    dm_values.dv_xjoy = 0.0;
	    dm_values.dv_yjoy = 0.0;
	    dm_values.dv_zjoy = 0.0;
	    break;
d640 1
a640 1
	    break;
d642 1
a642 1
	    break;
d644 1
a644 1
	    break;
d646 5
a650 5
	    break;
	}
    }

	if( sun_damaged )  {
d652 22
a673 1
		sun_damaged = 0;
d676 1
a676 4
    if (readfds & (1 << cmd_fd))
	return (1);		/* command awaits */
    else
	return (0);		/* just peripheral stuff */
d683 7
a689 12
    if (event_is_down(eventP))
    {
	sun_buttons[button] = 1;
	win_setinputcodebit(&sun_input_mask, LOC_MOVE);
	win_set_pick_mask(sun_win_fd, &sun_input_mask);
    }
    else
    {
	sun_buttons[button] = 0;
	win_unsetinputcodebit(&sun_input_mask, LOC_MOVE);
	win_set_pick_mask(sun_win_fd, &sun_input_mask);
    }
d696 4
a699 3
void            SunPw_light(cmd, func)
int             cmd;
int             func;		/* BE_ or BV_ function */
d701 1
a701 1
    return;
d705 2
a706 1
unsigned        SunPw_cvtvecs(sp)
d709 1
a709 1
    return (0);
d715 3
a717 2
unsigned        SunPw_load(addr, count)
unsigned        addr, count;
d719 2
a720 2
    (void) printf("SunPw_load(x%x, %d.)\n", addr, count);
    return (0);
d723 2
a724 1
void            SunPw_statechange()
d728 2
a729 1
void            SunPw_viewchange()
a732 1

d736 1
a736 1
#define NSLOTS		256
d739 5
a743 6
static struct rgbtab
{
    unsigned char   r;
    unsigned char   g;
    unsigned char   b;
}               sun_rgbtab[NSLOTS];
d752 2
a753 1
void            SunPw_colorchange()
d841 2
a842 1
void            SunPw_debug(lvl)
d848 2
a849 1
void            SunPw_window(w)
d852 7
a858 7
    /* Compute the clipping bounds */
    clipmin[0] = w[1] / 2048.;
    clipmin[1] = w[3] / 2048.;
    clipmin[2] = w[5] / 2048.;
    clipmax[0] = w[0] / 2047.;
    clipmax[1] = w[2] / 2047.;
    clipmax[2] = w[4] / 2047.;
d865 3
a867 4
	/* XXX oddly, using sun_master_pw here does not work! */
	pw_rop(sun_pw, 0, 0,
		sun_master_rect.r_width, sun_master_rect.r_height,
		PIX_SRC | PIX_COLOR(sun_cmap_color), (Pixrect *) 0, 0, 0);
d870 3
a872 2
Pr_texture     *sun_get_texP(dashed)
int             dashed;
d874 2
a875 10
    static Pr_texture dotdashed = {
				   pr_tex_dashdot,
				   0,
				   {
				    1,
				    1,
				    0,
				    0,
				    }
    };
d877 4
a880 4
    if (dashed)
	return (&dotdashed);
    else
	return ((Pr_texture *) 0);
@


7.3
log
@Modified for new vector lists
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 7.2 87/11/05 05:05:13 mike Locked $ (BRL)";
d248 4
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 7.1 87/11/03 00:00:07 mike Rel $ (BRL)";
d356 1
a356 1
	register struct veclist *vp;
d380 1
a380 1
	for (vp = sp->s_vlist; nvec-- > 0; vp++)  {
d392 1
a392 1
		if (vp->vl_pen == PEN_UP)
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 6.1 87/07/11 08:03:18 mike Rel $ (BRL)";
d26 1
a26 1
#include "./machine.h"		/* special copy */
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 5.1 87/06/24 22:19:50 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 4.4 87/06/16 05:30:34 mike Exp $ (BRL)";
@


4.4
log
@Improved version.  Still having trouble writing the centering dot.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sun.c,v 4.3 87/05/06 02:52:22 mike Exp $ (BRL)";
@


4.3
log
@This version seems to have correct basic functionality.

More work is needed.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sunpw.c,v 4.2 87/02/13 00:06:59 mike Exp $ (BRL)";
d161 4
a164 1
		sun_master_pw = pw_open(sun_win_fd);
d225 2
d234 1
a234 1
		exit(1);
d255 45
d312 1
a312 1
	/* Put the center point up */
d314 1
a314 1
	sun_point(0, 0);
a316 6
sun_point(x, y)
int             x, y;
{
	pw_put(sun_pw, GED_TO_SUNPW(x), GED_TO_SUNPW(-y), sun_cmap_color);
}

d336 2
d360 2
a361 2
	struct pr_pos   polylist[1024];
	u_char          mvlist[1024];
d363 1
d366 3
d383 6
d396 1
d404 1
a404 1
	pw_polyline(sun_pw, 0, 0, totalvec, polylist, mvlist, (Pr_brush *) 0,
d406 1
a406 1
	return (1);			/* ## is more clipping information useful ? */
d442 3
a444 9
	if( sun_depth < 8 )  {
		/* Color, write transparant text */
		pw_ttext(sun_pw, GED_TO_SUNPW(x), GED_TO_SUNPW(-y),
		    PIX_SRC | PIX_COLOR(sun_cmap_color), sun_font_ptr, str);
	} else {
		/* Monochrome */
		pw_text(sun_pw, GED_TO_SUNPW(x), GED_TO_SUNPW(-y),
		    PIX_SRC | PIX_COLOR(sun_cmap_color), sun_font_ptr, str);
	}
d570 1
d574 1
a812 34
sun_color(color)
int             color;
{
	if( sun_depth < 8 )  {
		/* Sun Monochrome:  0 gives white (bg), 1 gives black (fg) */
		if( color == DM_BLACK )
			sun_cmap_color = 1;
		else
			sun_cmap_color = 0;
		return;
	}
	switch (color)
	{
	case DM_BLACK:
		sun_cmap_color = 0;
		break;
	case DM_RED:
		sun_cmap_color = 1;
		break;
	case DM_BLUE:
		sun_cmap_color = 4;
		break;
	case DM_YELLOW:
		sun_cmap_color = 3;
		break;
	case DM_WHITE:
		sun_cmap_color = 7;
		break;
	default:
		printf("sun_color:  mged color %d not known\n", color);
		break;
	}
}

d817 1
a817 1
	/* XXX oddlyl using sun_master_pw here does not work! */
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d2 1
a2 1
 *			D M - S U N P W . C
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sunpw.c,v 4.1 86/12/29 03:20:51 mike Rel1 $ (BRL)";
d76 1
a76 1
			 "sunpw", "SunView 1.0/Sun release 3.x pixwin library"
d84 3
a86 1
Pixwin         *sun_master_pw, *sun_pw;
d90 1
a91 1
int             sun_y_text_offset;
d101 3
d124 3
a126 3
    Rect            rect;
    char unsigned   red[256], grn[256], blu[256];
    struct pr_subregion bound;
d129 1
a129 1
    struct gfxsubwindow *mine;
d131 8
a138 8
    /*
     * Get graphics subwindow, get its size, and trap alarm clock and interrupt
     * signals. 
     */
    mine = gfxsw_init(0, 0);
    sun_pw = mine->gfx_pixwin;
    win_getsize(sun_pw->pw_clipdata->pwcd_windowfd, &rect);
    sun_win_rect = rect;
d141 1
a141 1
    Window          frame;
d143 5
a147 5
    frame = window_create(NULL, FRAME,
			  WIN_WIDTH, 600,
			  WIN_HEIGHT, 600,
			  0);
    sun_pw = window_get(frame, WIN_PIXWIN);
d150 5
a154 4
    {
	int             gfxfd;
	char            gfxwinname[128];
	Rect            master_rect;
d156 4
a159 13
	sun_win_fd = win_getnewwindow();
	we_getgfxwindow(gfxwinname);
	gfxfd = open(gfxwinname);
	win_insertblanket(sun_win_fd, gfxfd);
	sun_master_pw = pw_open(sun_win_fd);
	win_getsize(sun_win_fd, &master_rect);
	sun_pw = pw_region(sun_master_pw, 0, 0, 512, 512);
	/* sun_pw = pw_region(sun_master_pw,
			(master_rect.r_width - 512) / 2,
			(master_rect.r_height - 512) / 2,
			512, 512); */
	win_getsize(sun_win_fd, &rect);
	sun_win_rect = rect;
d161 6
a166 17
	input_imnull(&sun_input_mask);
	sun_input_mask.im_flags |= IM_NEGEVENT;
	win_setinputcodebit(&sun_input_mask, MS_LEFT);
	win_setinputcodebit(&sun_input_mask, MS_MIDDLE);
	win_setinputcodebit(&sun_input_mask, MS_RIGHT);
	win_setinputcodebit(&sun_input_mask, KEY_TOP(1));
	win_setinputcodebit(&sun_input_mask, KEY_TOP(2));
	win_setinputcodebit(&sun_input_mask, KEY_TOP(3));
	win_setinputcodebit(&sun_input_mask, KEY_TOP(4));
	win_setinputcodebit(&sun_input_mask, KEY_TOP(5));
	win_setinputcodebit(&sun_input_mask, KEY_TOP(6));
	win_setinputcodebit(&sun_input_mask, KEY_TOP(7));
	win_setinputcodebit(&sun_input_mask, KEY_TOP(8));
	win_setinputcodebit(&sun_input_mask, KEY_TOP(9));
	win_set_pick_mask(sun_win_fd, &sun_input_mask);
	fcntl(sun_win_fd, F_SETFL, FNDELAY);
    }
d168 6
a173 28
    /* set a new cms name; initialize it */
    pw_setcmsname(sun_pw, "mged");
    /* default colormap, real one is set by SunPw_colorchange */
    red[0] = 0;
    grn[0] = 0;
    blu[0] = 0;
    red[1] = 255;
    grn[1] = 0;
    blu[1] = 0;
    red[2] = 0;
    grn[2] = 255;
    blu[2] = 0;
    red[3] = 255;
    grn[3] = 255;
    blu[3] = 0;
    red[4] = 0;
    grn[4] = 0;
    blu[4] = 255;
    red[5] = 255;
    grn[5] = 0;
    blu[5] = 255;
    red[6] = 0;
    grn[6] = 255;
    blu[6] = 255;
    red[7] = 255;
    grn[7] = 255;
    blu[7] = 255;
    pw_putcolormap(sun_pw, 0, 8, red, grn, blu);
d175 59
a233 12
    pw_rop(sun_pw, 0, 0, rect.r_width, rect.r_height,
	   PIX_SRC | PIX_COLOR(0), (struct pixrect *) 0, 0, 0);
    sun_font_ptr = pf_open(LABELING_FONT);
    if (sun_font_ptr == (struct pixfont *) 0)
    {
	perror(LABELING_FONT);
	exit(1);
    }
    pf_textbound(&bound, 1, sun_font_ptr, "X");
    sun_y_text_offset = -(bound.pos.y / 3);
    notify_set_signal_func(SunPw_open, sun_sigwinch, SIGWINCH, NOTIFY_ASYNC);
    return (0);			/* OK */
d241 1
a241 1
void            SunPw_close()
d243 4
a246 1
                    pw_close(sun_pw);
d256 2
a257 2
    if              (!dmaflag)
	                return;
d259 2
a260 2
    /* clear the screen for a redraw */
    sun_clear_win();
d262 3
a264 2
    /* Put the center point up */
    sun_point(0, 0);
d270 1
a270 1
    pw_put(sun_pw, GED_TO_SUNPW(x), GED_TO_SUNPW(y), sun_cmap_color);
d307 11
a317 10
    register struct pr_pos *ptP;
    u_char         *mvP;
    static vect_t   pt;
    register struct veclist *vp;
    struct mater   *mp;
    int             nvec, totalvec;
    int             useful = 0;
    struct pr_pos   polylist[1024];
    u_char          mvlist[1024];
    Pr_texture     *texP;
d319 2
a320 2
    texP = sun_get_texP(sp->s_soldash);
    mp = (struct mater *) sp->s_materp;
d322 28
a349 24
    nvec = sp->s_vlen;
    ptP = polylist;
    mvP = mvlist;
    if (nvec > 1024)
    {
	(void) fprintf(stderr, "nvec %d clipped to 1024\n", nvec);
	nvec = 1024;
    }
    totalvec = nvec;
    for (vp = sp->s_vlist; nvec-- > 0; vp++)
    {
	MAT4X3PNT(pt, mat, vp->vl_pnt);
	ptP->x = GED_TO_SUNPW(pt[0]);
	ptP->y = GED_TO_SUNPW(pt[1]);
	ptP++;
	if (vp->vl_pen == PEN_UP)
	    *mvP++ = 1;
	else
	    *mvP++ = 0;
    }
    mvlist[0] = 0;
    pw_polyline(sun_pw, 0, 0, totalvec, polylist, mvlist, (Pr_brush *) 0,
		texP, PIX_SRC | PIX_COLOR(mp->mt_dm_int));
    return (1);			/* ## is more clipping information useful ? */
d384 10
a393 2
    pw_ttext(sun_pw, GED_TO_SUNPW(x), GED_TO_SUNPW(y) + sun_y_text_offset,
	     PIX_SRC | PIX_COLOR(color), sun_font_ptr, str);
d409 2
a410 2
    pw_line(sun_pw, GED_TO_SUNPW(x1), GED_TO_SUNPW(y1),
	    GED_TO_SUNPW(x2), GED_TO_SUNPW(y2), (Pr_brush *) 0, texP,
d473 1
a473 1
	dm_values.dv_ypen = SUNPW_TO_GED(event_y(&event));
d478 1
a478 1
		dm_values.dv_penpress = DV_INZOOM;
d486 1
a486 1
		dm_values.dv_penpress = DV_OUTZOOM;
d568 5
d744 2
a745 2
                    sun_debug = lvl;
    return;
d763 29
a791 18
    switch (color)
    {
    case DM_BLACK:
	sun_cmap_color = 0;
	break;
    case DM_RED:
	sun_cmap_color = 1;
	break;
    case DM_BLUE:
	sun_cmap_color = 4;
	break;
    case DM_YELLOW:
	sun_cmap_color = 3;
	break;
    case DM_WHITE:
	sun_cmap_color = 7;
	break;
    }
a793 5
sun_rgb_color(r, g, b)
int             r, g, b;
{
}

d796 6
a801 2
    pw_rop(sun_pw, 0, 0, sun_win_rect.r_width, sun_win_rect.r_height,
	   PIX_CLR, (Pixrect *) 0, 0, 0);
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sunpw.c,v 1.2 86/11/14 03:54:31 mike Exp $ (BRL)";
@


1.2
log
@Added warning message about needing SUN 3.2
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: dm-sunpw.c,v 1.1 86/11/13 13:56:32 mike Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d7 3
d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@
