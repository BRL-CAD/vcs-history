head	11.65;
access;
symbols
	ansi-20040405-merged:11.61.2.2
	postmerge-20040405-ansi:11.63
	premerge-20040404-ansi:11.62
	postmerge-autoconf:11.62
	autoconf-freeze:11.61.10.2
	premerge-autoconf:11.62
	postmerge-20040315-windows:11.62
	premerge-20040315-windows:11.62
	windows-20040315-freeze:11.61.4.1
	autoconf-20031203:11.61
	autoconf-20031202:11.61
	autoconf-branch:11.61.0.10
	phong-branch:11.61.0.8
	photonmap-branch:11.61.0.6
	rel-6-1-DP:11.61
	windows-branch:11.61.0.4
	rel-6-0-2:11.59
	ansi-branch:11.61.0.2
	rel-6-0-1-branch:11.59.0.2
	hartley-6-0-post:11.60
	hartley-6-0-pre:11.59
	rel-6-0-1:11.59
	rel-6-0:11.59
	rel-5-4:11.50.2.2
	offsite-5-3-pre:11.55
	rel-5-3:11.50.2.2
	rel-5-2:11.50
	rel-5-1-branch:11.50.0.2
	rel-5-1:11.50
	rel-5-0:11.48
	rel-5-0-beta:11.47
	rel-4-5:11.41
	ctj-4-5-post:11.35
	ctj-4-5-pre:11.35
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.9;
locks; strict;
comment	@ * @;


11.65
date	2004.05.21.17.47.51;	author morrison;	state dead;
branches;
next	11.64;

11.64
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.63;

11.63
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.62;

11.62
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.61;

11.61
date	2002.08.20.17.08.26;	author jra;	state Exp;
branches
	11.61.2.1
	11.61.4.1
	11.61.10.1;
next	11.60;

11.60
date	2002.08.15.20.55.39;	author hartley;	state Exp;
branches;
next	11.59;

11.59
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	2001.03.31.01.57.24;	author morrison;	state Exp;
branches;
next	11.56;

11.56
date	2001.03.19.22.20.02;	author butler;	state Exp;
branches;
next	11.55;

11.55
date	2001.02.16.16.29.03;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	2000.10.24.14.54.10;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.10.20.05.04.40;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.09.07.02.58.53;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.08.19.03.10.50;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	2000.06.05.21.53.05;	author bparker;	state Exp;
branches
	11.50.2.1;
next	11.49;

11.49
date	99.12.30.19.17.45;	author jra;	state Exp;
branches;
next	11.48;

11.48
date	99.09.01.18.55.11;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	99.01.21.18.31.19;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	98.11.06.22.32.44;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	98.10.21.16.28.21;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	98.06.11.19.41.48;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	98.05.01.21.14.28;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	98.04.07.15.00.14;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	97.12.17.18.04.53;	author pjt;	state Exp;
branches;
next	11.40;

11.40
date	97.10.27.19.29.07;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	97.09.08.18.48.55;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	97.07.25.20.57.26;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	97.06.25.13.44.44;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	97.04.23.18.30.43;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	97.03.20.14.48.29;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	97.02.10.19.37.07;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	97.02.01.02.22.50;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	97.02.01.02.12.38;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	97.01.29.03.35.50;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	97.01.02.19.40.36;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.12.17.22.36.57;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.12.11.22.40.57;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.12.06.21.55.11;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.11.19.21.21.40;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.09.23.18.19.22;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.09.17.21.18.46;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.08.21.13.54.11;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.08.14.20.24.51;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.07.15.20.39.48;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.05.24.19.10.02;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.05.16.20.59.26;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.03.22.18.30.48;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.03.01.19.15.15;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.01.17.22.06.52;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	95.12.04.22.06.13;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.11.07.22.59.49;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	95.11.07.14.39.36;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.08.10.21.11.50;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.17;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.45;	author mike;	state Rel4_4;
branches;
next	10.13;

10.13
date	95.01.03.14.32.14;	author gdurf;	state Exp;
branches;
next	10.12;

10.12
date	94.12.24.01.07.01;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.12.16.19.37.33;	author gdurf;	state Exp;
branches;
next	10.10;

10.10
date	94.08.19.16.14.06;	author pjt;	state Exp;
branches;
next	10.9;

10.9
date	94.08.09.18.53.05;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.06.17.00.26.51;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.06.01.16.58.56;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.03.09.00.17.59;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.06.12.23.53.18;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	91.12.19.03.07.38;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.12.19.02.34.31;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.11.05.00.03.03;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.25;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	89.10.10.16.28.16;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.11;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.21.04.57.00;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.06.20.40.24;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.02.35.23;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.35;	author mike;	state Rel3_0;
branches;
next	7.6;

7.6
date	88.09.06.16.49.03;	author reschly;	state Exp;
branches;
next	7.5;

7.5
date	88.07.22.01.59.48;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.05.15.23.05.27;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.04.28.17.32.14;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.07.22;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.02.18;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.05.50;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.22.42;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.13.27;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.23.31;	author mike;	state Rel1;
branches;
next	2.13;

2.13
date	86.09.09.23.48.51;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.08.12.06.51.21;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.06.19.23.49.23;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.03.10.21.38.30;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.08.07.05.20.10;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.07.30.01.18.19;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.06.06.22.33.29;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.05.29.23.17.40;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.05.10.00.56.07;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.03.02.01.19;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.05.02.23.27.07;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.22.10.55.23;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.59.44;	author mike;	state Prod;
branches;
next	1.6;

1.6
date	85.03.08.20.54.09;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.02.01.00.51.27;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.02.55.39;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.01.16.01.58.56;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.04.25.51;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.53.32;	author mike;	state Exp;
branches;
next	;

11.50.2.1
date	2000.11.09.21.22.47;	author bparker;	state Exp;
branches;
next	11.50.2.2;

11.50.2.2
date	2001.02.16.16.27.49;	author bparker;	state Exp;
branches;
next	;

11.61.2.1
date	2002.09.19.18.02.06;	author morrison;	state Exp;
branches;
next	11.61.2.2;

11.61.2.2
date	2004.03.17.21.22.05;	author morrison;	state Exp;
branches;
next	;

11.61.4.1
date	2004.03.11.23.46.37;	author morrison;	state Exp;
branches;
next	;

11.61.10.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	11.61.10.2;

11.61.10.2
date	2004.03.15.14.07.42;	author erikg;	state Exp;
branches;
next	;


desc
@Process data tablet commands
@


11.65
log
@moved to src/mged/
@
text
@/*
 *			U S E P E N . C
 *
 * Functions -
 *	usepen		Use x,y data from data tablet
 *	buildHrot	Generate rotation matrix
 *	wrt_view	Modify xform matrix with respect to current view
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/usepen.c,v 11.64 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./titles.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

#include "./sedit.h"

/*	Degree <-> Radian conversion factors	*/
double	degtorad =  0.01745329251994329573;
double	radtodeg = 57.29577951308232098299;

struct solid	*illump = SOLID_NULL;	/* == 0 if none, else points to ill. solid */
int		ipathpos = 0;	/* path index of illuminated element */
				/* set by e9.c, cleared here */
void		wrt_view(fastf_t *out, const fastf_t *change, const fastf_t *in), wrt_point(fastf_t *out, const fastf_t *change, const fastf_t *in, const fastf_t *point);
static void	illuminate(int y);

/*
 *			F _ M O U S E
 *
 * X and Y are expected to be in -2048 <= x,y <= +2047 range.
 * The "up" flag is 1 on the not-pressed to pressed transition,
 * and 0 on the pressed to not-pressed transition.
 *
 * Note -
 *  The mouse is the focus of much of the editing activity in GED.
 *  The editor operates in one of seven basic editing states, recorded
 *  in the variable called "state".  When no editing is taking place,
 *  the editor is in state ST_VIEW.  There are two paths out of ST_VIEW:
 *  
 *  BE_S_ILLUMINATE, when pressed, takes the editor into ST_S_PICK,
 *  where the mouse is used to pick a solid to edit, using our
 *  unusual "illuminate" technique.  Moving the mouse varies the solid
 *  being illuminated.  When the mouse is pressed, the editor moves into
 *  state ST_S_EDIT, and solid editing may begin.  Solid editing is
 *  terminated via BE_ACCEPT and BE_REJECT.
 *  
 *  BE_O_ILLUMINATE, when pressed, takes the editor into ST_O_PICK,
 *  again performing the illuminate procedure.  When the mouse is pressed,
 *  the editor moves into state ST_O_PATH.  Now, moving the mouse allows
 *  the user to choose the portion of the path relation to be edited.
 *  When the mouse is pressed, the editor moves into state ST_O_EDIT,
 *  and object editing may begin.  Object editing is terminated via
 *  BE_ACCEPT and BE_REJECT.
 *  
 *  The only way to exit the intermediate states (non-VIEW, non-EDIT)
 *  is by completing the sequence, or pressing BE_REJECT.
 */
int
f_mouse(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	vect_t	mousevec;		/* float pt -1..+1 mouse pos vect */
	int	isave;
	int	up;
	int	xpos;
	int	ypos;

	if(argc < 4 || 4 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help M");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	up = atoi(argv[1]);
	xpos = atoi(argv[2]);
	ypos = atoi(argv[3]);

	/* Build floating point mouse vector, -1 to +1 */
	mousevec[X] =  xpos * INV_GED;
	mousevec[Y] =  ypos * INV_GED;
	mousevec[Z] = 0;

	if (mged_variables->mv_faceplate && mged_variables->mv_orig_gui && up) {
	  /*
	   * If mouse press is in scroll area, see if scrolling, and if so,
	   * divert this mouse press.
	   */
	  if( (xpos >= MENUXLIM) || scroll_active )  {
	    register int i;

	    if(scroll_active)
	      ypos = scroll_y;

	    if( (i = scroll_select( xpos, ypos, 1 )) < 0 )  {
	      Tcl_AppendResult(interp,
			       "mouse press outside valid scroll area\n",
			       (char *)NULL);
	      return TCL_ERROR;
	    } 

	    if( i > 0 )  {
	      scroll_active = 1;
	      scroll_y = ypos;

	      /* Scroller bars claimed button press */
	      return TCL_OK;
	    }
	    /* Otherwise, fall through */
	  }

	  /*
	   * If menu is active, and mouse press is in menu area,
	   * divert this mouse press for menu purposes.
	   */
	  if( xpos < MENUXLIM )  {
	    register int i;

	    if( (i = mmenu_select( ypos, 1 )) < 0 )  {
	      Tcl_AppendResult(interp,
			       "mouse press outside valid menu\n",
			       (char *)NULL);
	      return TCL_ERROR;
	    }

	    if( i > 0 )  {
	      /* Menu claimed button press */
	      return TCL_OK;
	    }
	    /* Otherwise, fall through */
	  }
	}

	/*
	 *  In the best of all possible worlds, nothing should happen
	 *  when the mouse is not pressed;  this would relax the requirement
	 *  for the host being informed when the mouse changes position.
	 *  However, for now, illuminate mode makes this impossible.
	 */
	if( up == 0 )  switch( state )  {

	case ST_VIEW:
	case ST_S_EDIT:
	case ST_O_EDIT:
	default:
	  return TCL_OK;		/* Take no action in these states */

	case ST_O_PICK:
	case ST_S_PICK:
	  /*
	   * Use the mouse for illuminating a solid
	   */
	  illuminate( ypos );
	  return TCL_OK;

	case ST_O_PATH:
	  /*
	   * Convert DT position to path element select
	   */
	  isave = ipathpos;
	  ipathpos = illump->s_fullpath.fp_len-1 - (
	       (ypos+(int)GED_MAX) * (illump->s_fullpath.fp_len) / (int)GED_RANGE);
	  if( ipathpos != isave )
	    view_state->vs_flag = 1;
	  return TCL_OK;

	} else switch( state )  {

	case ST_VIEW:
	  /*
	   * Use the DT for moving view center.
	   * Make indicated point be new view center (NEW).
	   */
	  slewview( mousevec );
	  return TCL_OK;

	case ST_O_PICK:
	  ipathpos = 0;
	  (void)chg_state( ST_O_PICK, ST_O_PATH, "mouse press");
	  view_state->vs_flag = 1;
	  return TCL_OK;

	case ST_S_PICK:
	  /* Check details, Init menu, set state */
	  init_sedit();		/* does chg_state */
	  view_state->vs_flag = 1;
	  return TCL_OK;

	case ST_S_EDIT:
	  if((SEDIT_TRAN || SEDIT_SCALE || SEDIT_PICK) && mged_variables->mv_transform == 'e')
	    sedit_mouse( mousevec );
	  else
	    slewview( mousevec );
	  return TCL_OK;

	case ST_O_PATH:
		/*
		 * Set combination "illuminate" mode.  This code
		 * assumes that the user has already illuminated
		 * a single solid, and wishes to move a collection of
		 * objects of which the illuminated solid is a part.
		 * The whole combination will not illuminate (to save
		 * vector drawing time), but all the objects should
		 * move/scale in unison.
		 */
		{
			char	*av[3];
			char	num[8];
			(void)sprintf(num, "%d", ipathpos);
			av[0] = "matpick";
			av[1] = num;
			av[2] = (char *)NULL;
			(void)f_matpick( clientData, interp, 2, av );
			/* How to record this in the journal file? */
			return TCL_OK;
		}

	case ST_S_VPICK:
		sedit_vpick( mousevec );
		return TCL_OK;

	case ST_O_EDIT:
	  if((OEDIT_TRAN || OEDIT_SCALE) && mged_variables->mv_transform == 'e')
	    objedit_mouse( mousevec );
	  else
	    slewview( mousevec );

	  return TCL_OK;

	default:
		state_err( "mouse press" );
		return TCL_ERROR;
	}
	/* NOTREACHED */
}

/*
 *			I L L U M I N A T E
 *
 *  All solids except for the illuminated one have s_iflag set to DOWN.
 *  The illuminated one has s_iflag set to UP, and also has the global
 *  variable "illump" pointing at it.
 */
static void
illuminate(int y) {
	register int count;
	register struct solid *sp;

	/*
	 * Divide the mouse into 'ndrawn' VERTICAL zones, and use the
	 * zone number as a sequential position among solids
	 * which are drawn.
	 */
	count = ((fastf_t)y + GED_MAX) * ndrawn / GED_RANGE;

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		/* Only consider solids which are presently in view */
		if( sp->s_flag == UP )  {
		        if( count-- == 0 ) {
				sp->s_iflag = UP;
				illump = sp;
			}  else  {
				/* All other solids have s_iflag set DOWN */
				sp->s_iflag = DOWN;
			}
		}
	}

	update_views = 1;
}

/*
 *                        A I L L
 *
 *   advance illump or ipathpos
 */
int
f_aip(
	ClientData clientData,
	Tcl_Interp *interp,
	int argc,
	char **argv)
{
  register struct solid *sp;

  if(argc < 1 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel aip");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (!ndrawn){
	  return TCL_OK;
  } else if (state != ST_S_PICK && state != ST_O_PICK  && state != ST_O_PATH) {
	  return TCL_OK;
  }

  if(state == ST_O_PATH){
    if(argc == 1 || *argv[1] == 'f'){
      ++ipathpos;
      if(ipathpos >= illump->s_fullpath.fp_len)
	ipathpos = 0;
    }else if(*argv[1] == 'b'){
      --ipathpos;
      if(ipathpos < 0)
	ipathpos = illump->s_fullpath.fp_len-1;
    }else{
      Tcl_AppendResult(interp, "aip: bad parameter - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else{
    sp = illump;
    sp->s_iflag = DOWN;
    if(argc == 1 || *argv[1] == 'f'){
      if(BU_LIST_NEXT_IS_HEAD(sp, &dgop->dgo_headSolid))
	sp = BU_LIST_NEXT(solid, &dgop->dgo_headSolid);
      else
	sp = BU_LIST_PNEXT(solid, sp);
    }else if(*argv[1] == 'b'){
      if(BU_LIST_PREV_IS_HEAD(sp, &dgop->dgo_headSolid))
	sp = BU_LIST_PREV(solid, &dgop->dgo_headSolid);
      else
	sp = BU_LIST_PLAST(solid, sp);
    }else{
      Tcl_AppendResult(interp, "aip: bad parameter - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    sp->s_iflag = UP;
    illump = sp;
  }

  update_views = 1;
  return TCL_OK;
}

/*
 *  			W R T _ V I E W
 *  
 *  Given a model-space transformation matrix "change",
 *  return a matrix which applies the change with-respect-to
 *  the view center.
 */
void
wrt_view( mat_t out, const mat_t change, const mat_t in )
{
	static mat_t t1, t2;

	bn_mat_mul(t1, view_state->vs_vop->vo_center, in);
	bn_mat_mul(t2, change, t1);

	/* Build "fromViewcenter" matrix */
	MAT_IDN(t1);
	MAT_DELTAS(t1, -view_state->vs_vop->vo_center[MDX], -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);
	bn_mat_mul(out, t1, t2);
}

/*
 *  			W R T _ P O I N T
 *  
 *  Given a model-space transformation matrix "change",
 *  return a matrix which applies the change with-respect-to
 *  "point".
 */
void
wrt_point( mat_t out, const mat_t change, const mat_t in, const point_t point )
{
	mat_t	t;

	bn_mat_xform_about_pt( t, change, point );

	if(out == in)
	  bn_mat_mul2( t, out );
	else
	  bn_mat_mul( out, t, in );
}

/*
 *  			W R T _ P O I N T _ D I R E C
 *  
 *  Given a model-space transformation matrix "change",
 *  return a matrix which applies the change with-respect-to
 *  given "point" and "direc".
 */
void
wrt_point_direc( mat_t out, const mat_t change, const mat_t in, const point_t point, const vect_t direc )
{
	static mat_t	t1;
	static mat_t	pt_to_origin, origin_to_pt;
	static mat_t	d_to_zaxis, zaxis_to_d;
	static vect_t	zaxis;

	/* build "point to origin" matrix */
	MAT_IDN( pt_to_origin );
	MAT_DELTAS(pt_to_origin, -point[X], -point[Y], -point[Z]);

	/* build "origin to point" matrix */
	MAT_IDN( origin_to_pt );
	MAT_DELTAS(origin_to_pt, point[X], point[Y], point[Z]);

	/* build "direc to zaxis" matrix */
	VSET(zaxis, 0.0, 0.0, 1.0);
	bn_mat_fromto(d_to_zaxis, direc, zaxis);

	/* build "zaxis to direc" matrix */
	bn_mat_inv(zaxis_to_d, d_to_zaxis);

	/* apply change matrix...
	 *	t1 = change * d_to_zaxis * pt_to_origin * in
	 */
	bn_mat_mul4( t1, change, d_to_zaxis, pt_to_origin, in );

	/* apply origin_to_pt matrix:
	 *	out = origin_to_pt * zaxis_to_d *
	 *		change * d_to_zaxis * pt_to_origin * in
	 */
	bn_mat_mul3( out, origin_to_pt, zaxis_to_d, t1 );
}

/*
 *			F _ M A T P I C K
 *
 *  When in O_PATH state, select the arc which contains the matrix
 *  which is going to be "object edited".
 *  The choice is recorded in variable "ipathpos".
 *
 *  There are two syntaxes:
 *	matpick a/b	Pick arc between a and b.
 *	matpick #	Similar to internal interface.
 *			0 = top level object is a solid.
 *			n = edit arc from path [n-1] to [n]
 */
int
f_matpick(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	register struct solid	*sp;
	char			*cp;
	register int		j;
	int			illum_only = 0;

	CHECK_DBI_NULL;

	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help matpick");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if(!strcmp("-n", argv[1])){
	  illum_only = 1;
	  --argc;
	  ++argv;
	}

	if(argc != 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help matpick");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_O_PATH, "Object Edit matrix pick" ) )
	  return TCL_ERROR;

	if( (cp = strchr( argv[1], '/' )) != NULL )  {
		struct directory	*d0, *d1;
		if( (d1 = db_lookup( dbip, cp+1, LOOKUP_NOISY )) == DIR_NULL )
		  return TCL_ERROR;
		*cp = '\0';		/* modifies argv[1] */
		if( (d0 = db_lookup( dbip, argv[1], LOOKUP_NOISY )) == DIR_NULL )
		  return TCL_ERROR;
		/* Find arc on illump path which runs from d0 to d1 */
		for( j=1; j < illump->s_fullpath.fp_len; j++ )  {
			if( DB_FULL_PATH_GET(&illump->s_fullpath,j-1) != d0 )  continue;
			if( DB_FULL_PATH_GET(&illump->s_fullpath,j-0) != d1 )  continue;
			ipathpos = j;
			goto got;
		}
		Tcl_AppendResult(interp, "matpick: unable to find arc ", d0->d_namep,
				 "/", d1->d_namep, " in current selection.  Re-specify.\n",
				 (char *)NULL);
		return TCL_ERROR;
	} else {
		ipathpos = atoi(argv[1]);
		if( ipathpos < 0 )  ipathpos = 0;
		else if( ipathpos >= illump->s_fullpath.fp_len )
			ipathpos = illump->s_fullpath.fp_len-1;
	}
got:
	/* Include all solids with same tree top */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		for( j = 0; j <= ipathpos; j++ )  {
			if( DB_FULL_PATH_GET(&sp->s_fullpath,j) !=
			    DB_FULL_PATH_GET(&illump->s_fullpath,j) )
				break;
		}
		/* Only accept if top of tree is identical */
		if( j == ipathpos+1 )
		  sp->s_iflag = UP;
		else
		  sp->s_iflag = DOWN;
	}

	if(!illum_only){
	  (void)chg_state( ST_O_PATH, ST_O_EDIT, "mouse press" );
	  chg_l2menu(ST_O_EDIT);

	  /* begin object editing - initialize */
	  init_oedit();
	}

	update_views = 1;
	return TCL_OK;
}
@


11.64
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/usepen.c,v 11.63 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.63
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.62
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.61 2002/08/20 17:08:26 jra Exp $ (BRL)";
d54 2
a55 2
void		wrt_view(), wrt_point();
static void	illuminate();
d281 1
a281 1
illuminate( y )  {
@


11.61
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.59 2001/06/05 15:51:42 bparker Exp $ (BRL)";
@


11.61.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/usepen.c,v 11.62 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.61.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.62 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.61.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.61.10.1 2004/02/12 18:34:16 erikg Exp $ (BRL)";
@


11.61.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.61 2002/08/20 17:08:26 jra Exp $ (BRL)";
d54 2
a55 2
void		wrt_view(fastf_t *out, const fastf_t *change, const fastf_t *in), wrt_point(fastf_t *out, const fastf_t *change, const fastf_t *in, const fastf_t *point);
static void	illuminate(int y);
d281 1
a281 1
illuminate(int y) {
@


11.61.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.60
log
@Converted from K&R to ANSI C - RFH
@
text
@d54 2
a55 2
void		wrt_view(fastf_t *out, const fastf_t *change, const fastf_t *in), wrt_point(fastf_t *out, const fastf_t *change, const fastf_t *in, const fastf_t *point);
static void	illuminate(int y);
d281 1
a281 1
illuminate(int y) {
@


11.59
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.58 2001/06/01 19:23:25 bparker Exp $ (BRL)";
d54 2
a55 2
void		wrt_view(), wrt_point();
static void	illuminate();
d281 1
a281 1
illuminate( y )  {
@


11.58
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.57 2001/03/31 01:57:24 morrison Exp $ (BRL)";
a388 1
#ifdef MGED_USE_VIEW_OBJ
a394 8
#else
	bn_mat_mul(t1, view_state->vs_toViewcenter, in);
	bn_mat_mul(t2, change, t1);

	/* Build "fromViewcenter" matrix */
	MAT_IDN(t1);
	MAT_DELTAS(t1, -view_state->vs_toViewcenter[MDX], -view_state->vs_toViewcenter[MDY], -view_state->vs_toViewcenter[MDZ]);
#endif
@


11.57
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.56 2001/03/19 22:20:02 butler Exp $ (BRL)";
d292 1
a292 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
d355 2
a356 2
      if(BU_LIST_NEXT_IS_HEAD(sp, &HeadSolid.l))
	sp = BU_LIST_NEXT(solid, &HeadSolid.l);
d360 2
a361 2
      if(BU_LIST_PREV_IS_HEAD(sp, &HeadSolid.l))
	sp = BU_LIST_PREV(solid, &HeadSolid.l);
a377 61
 *			B U I L D H R O T
 *
 * This routine builds a Homogeneous rotation matrix, given
 * alpha, beta, and gamma as angles of rotation.
 *
 * NOTE:  Only initialize the rotation 3x3 parts of the 4x4
 * There is important information in dx,dy,dz,s .
 */
void
buildHrot( matp_t mat, double alpha, double beta, double ggamma )
{
	static fastf_t calpha, cbeta, cgamma;
	static fastf_t salpha, sbeta, sgamma;

	calpha = cos( alpha );
	cbeta = cos( beta );
	cgamma = cos( ggamma );

	salpha = sin( alpha );
	sbeta = sin( beta );
	sgamma = sin( ggamma );

	/*
	 * compute the new rotation to apply to the previous
	 * viewing rotation.
	 * Alpha is angle of rotation about the X axis, and is done third.
	 * Beta is angle of rotation about the Y axis, and is done second.
	 * Gamma is angle of rotation about Z axis, and is done first.
	 */
#ifdef m_RZ_RY_RX
	/* view = model * RZ * RY * RX (Neuman+Sproul, premultiply) */
	mat[0] = cbeta * cgamma;
	mat[1] = -cbeta * sgamma;
	mat[2] = -sbeta;

	mat[4] = -salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = salpha * sbeta * sgamma + calpha * cgamma;
	mat[6] = -salpha * cbeta;

	mat[8] = calpha * sbeta * cgamma + salpha * sgamma;
	mat[9] = -calpha * sbeta * sgamma + salpha * cgamma;
	mat[10] = calpha * cbeta;
#endif
	/* This is the correct form for this version of GED */
	/* view = RX * RY * RZ * model (Rodgers, postmultiply) */
	/* Point thumb along axis of rotation.  +Angle as hand closes */
	mat[0] = cbeta * cgamma;
	mat[1] = -cbeta * sgamma;
	mat[2] = sbeta;

	mat[4] = salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = -salpha * sbeta * sgamma + calpha * cgamma;
	mat[6] = -salpha * cbeta;

	mat[8] = -calpha * sbeta * cgamma + salpha * sgamma;
	mat[9] = calpha * sbeta * sgamma + salpha * cgamma;
	mat[10] = calpha * cbeta;
}


/*
d389 3
a391 2
	bn_mat_mul( t1, view_state->vs_toViewcenter, in );
	bn_mat_mul( t2, change, t1 );
d394 11
a404 3
	MAT_IDN( t1 );
	MAT_DELTAS( t1, -view_state->vs_toViewcenter[MDX], -view_state->vs_toViewcenter[MDY], -view_state->vs_toViewcenter[MDZ] );
	bn_mat_mul( out, t1, t2 );
d551 1
a551 1
	FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
@


11.56
log
@patches to merge 5.3 into 6.0
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/usepen.c,v 11.55 2001/02/16 16:29:03 bparker Exp $ (BRL)";
d454 1
a454 1
	bn_mat_idn( t1 );
d495 1
a495 1
	bn_mat_idn( pt_to_origin );
d499 1
a499 1
	bn_mat_idn( origin_to_pt );
@


11.55
log
@*- return TCL_OK if no solids are drawn
   or not in an illumination state
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.54 2000/10/24 14:54:10 mike Exp $ (BRL)";
d200 1
a200 1
	    view_state->vs_flag++;
@


11.54
log
@
lint
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.53 2000/10/20 05:04:40 mike Exp $ (BRL)";
d333 3
a335 7
      Tcl_AppendResult(interp, "aip: no solids displayed\n", (char *)NULL);
      return TCL_ERROR;
    }
    else if (state != ST_S_PICK && state != ST_O_PICK  && state != ST_O_PATH)
    {
      state_err("advance the illumination pointer");
      return TCL_ERROR;
@


11.53
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.52 2000/09/07 02:58:53 mike Exp $ (BRL)";
d581 1
a581 1
	if( cp = strchr( argv[1], '/' ) )  {
@


11.52
log
@
Added externs to ged.h to quiet down lint
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.51 2000/08/19 03:10:50 mike Exp $ (BRL)";
d97 3
a99 3
	int	up = atoi(argv[1]);
	int	xpos = atoi(argv[2]);
	int	ypos = atoi(argv[3]);
d111 4
d197 2
a198 2
	  ipathpos = illump->s_last - (
				       (ypos+(int)GED_MAX) * (illump->s_last+1) / (int)GED_RANGE);
d345 1
a345 1
      if(ipathpos > illump->s_last)
d350 1
a350 1
	ipathpos = illump->s_last;
d536 1
a536 1
 *			n = edit arc from s_path[n-1] to [n]
d589 3
a591 3
		for( j=1; j <= illump->s_last; j++ )  {
			if( illump->s_path[j-1] != d0 )  continue;
			if( illump->s_path[j-0] != d1 )  continue;
d602 2
a603 1
		else if( ipathpos > illump->s_last )  ipathpos = illump->s_last;
d609 2
a610 1
			if( sp->s_path[j] != illump->s_path[j] )
@


11.51
log
@
const RCSid
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.50 2000/06/05 21:53:05 bparker Exp $ (BRL)";
d89 5
a93 5
f_mouse(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d310 5
a314 5
f_aip(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char *argv[];
d387 1
a387 3
buildHrot( mat, alpha, beta, ggamma )
register matp_t mat;
double alpha, beta, ggamma;
d446 1
a446 2
wrt_view( out, change, in )
register matp_t out, change, in;
d467 1
a467 4
wrt_point( out, change, in, point )
register matp_t out;
register CONST matp_t change, in;
register CONST vect_t point;
d487 1
a487 3
wrt_point_direc( out, change, in, point, direc )
register matp_t out, change, in;
register vect_t point, direc;
d535 5
a539 5
f_matpick(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.50
log
@*- added new routines
*- a few routines changed names
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.49 1999/12/30 19:17:45 jra Exp $ (BRL)";
@


11.50.2.1
log
@A little house cleaning.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.50 2000/06/05 21:53:05 bparker Exp $ (BRL)";
d196 1
a196 1
	    view_state->vs_flag = 1;
@


11.50.2.2
log
@*- return TCL_OK if no solids are drawn
   or not in an illumination state
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.50.2.1 2000/11/09 21:22:47 bparker Exp $ (BRL)";
d329 7
a335 3
	  return TCL_OK;
  } else if (state != ST_S_PICK && state != ST_O_PICK  && state != ST_O_PATH) {
	  return TCL_OK;
@


11.49
log
@Eliminated some unused variables
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.48 1999/09/01 18:55:11 bparker Exp $ (BRL)";
d627 1
a627 1
	  init_objedit();
@


11.48
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.47 1999/01/21 18:31:19 bparker Exp $ (BRL)";
a316 2
  static int count = -1;
  int i;
@


11.47
log
@*- use helpdevel for help on developer commands
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.46 1998/11/06 22:32:44 bparker Exp $ (BRL)";
d556 1
a556 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.46
log
@*- use new structures
*- cleanup
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.45 1998/10/21 16:28:21 bparker Exp $ (BRL)";
d324 1
a324 1
    bu_vls_printf(&vls, "help aip");
@


11.45
log
@*- use macro instead of literal
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/usepen.c,v 11.44 1998/06/11 19:41:48 bparker Exp $ (BRL)";
d116 1
a116 1
	if (mged_variables->faceplate && mged_variables->orig_gui && up) {
d194 1
a194 1
				       (ypos+2048L) * (illump->s_last+1) / 4096);
d196 1
a196 1
	    dmaflag++;
d212 1
a212 1
	  dmaflag = 1;
d218 1
a218 1
	  dmaflag = 1;
d222 1
a222 1
	  if((SEDIT_TRAN || SEDIT_SCALE || SEDIT_PICK) && mged_variables->transform == 'e')
d255 1
a255 1
	  if((OEDIT_TRAN || OEDIT_SCALE) && mged_variables->transform == 'e')
d286 1
a286 1
	count = ( (fastf_t) y + 2048.0 ) * ndrawn / 4096.0;
d455 1
a455 1
	bn_mat_mul( t1, toViewcenter, in );
d460 1
a460 1
	MAT_DELTAS( t1, -toViewcenter[MDX], -toViewcenter[MDY], -toViewcenter[MDZ] );
@


11.44
log
@*- using floating point literals to initialize floats
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/usepen.c,v 11.43 1998/05/01 21:14:28 bparker Exp $ (BRL)";
d112 2
a113 2
	mousevec[X] =  xpos / 2047.0;
	mousevec[Y] =  ypos / 2047.0;
@


11.43
log
@*- mods to f_matpick()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/usepen.c,v 11.42 1998/04/07 15:00:14 bparker Exp $ (BRL)";
d513 1
a513 1
	VSET(zaxis, 0, 0, 1);
@


11.42
log
@*- mods to f_matpick()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.41 1997/12/17 18:04:53 pjt Exp bparker $ (BRL)";
d633 1
a633 1
	dmaflag++;
@


11.41
log
@Fixed some diagnostics
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.40 1997/10/27 19:29:07 bparker Exp $ (BRL)";
d554 1
d559 1
a559 1
	if(argc < 2 || 2 < argc){
d569 16
d620 3
a622 1
			sp->s_iflag = UP;
d624 4
a627 2
	(void)chg_state( ST_O_PATH, ST_O_EDIT, "mouse press" );
	chg_l2menu(ST_O_EDIT);
d629 3
a631 2
	/* begin object editing - initialize */
	init_objedit();
@


11.40
log
@some cleanup
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.39 1997/09/08 18:48:55 bparker Exp bparker $ (BRL)";
d330 9
a338 2
  if(!ndrawn || (state != ST_S_PICK && state != ST_O_PICK  && state != ST_O_PATH))
    return TCL_ERROR;
d350 1
a350 1
      Tcl_AppendResult(interp, "aill: bad parameter - ", argv[1], "\n", (char *)NULL);
d367 1
a367 1
      Tcl_AppendResult(interp, "aill: bad parameter - ", argv[1], "\n", (char *)NULL);
@


11.39
log
@mged_variables is now a pointer
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.38 1997/07/25 20:57:26 bparker Exp bparker $ (BRL)";
a364 3
#if 0
    dmp->dm_viewchange( dmp, DM_CHGV_ILLUM, sp );
#endif
a587 6
#if 0
	dmp->dm_light( dmp, LIGHT_ON, BE_ACCEPT );
	dmp->dm_light( dmp, LIGHT_ON, BE_REJECT );
	dmp->dm_light( dmp, LIGHT_OFF, BE_O_ILLUMINATE );
#endif

@


11.38
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.37 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d116 1
a116 1
	if (mged_variables.faceplate && mged_variables.orig_gui && up) {
d222 1
a222 1
	  if((SEDIT_TRAN || SEDIT_SCALE || SEDIT_PICK) && mged_variables.transform == 'e')
d255 1
a255 1
	  if((OEDIT_TRAN || OEDIT_SCALE) && mged_variables.transform == 'e')
@


11.37
log
@mods to run without a database
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.36 1997/06/25 13:44:44 bparker Exp bparker $ (BRL)";
a279 1
	register struct solid *saveillump;
a280 2
	saveillump = illump;

d291 1
a291 1
			if( count-- == 0 && illump != sp )  {
a292 3
#if 0
				dmp->dm_viewchange( dmp, DM_CHGV_ILLUM, sp );
#endif
d301 1
a301 2
	if( saveillump != illump )
	  update_views = 1;
@


11.36
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.35 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d557 3
@


11.35
log
@modify calls to Tcl_Eval
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.34 1997/04/23 18:30:43 bparker Exp bparker $ (BRL)";
d116 1
a116 1
	if (mged_variables.faceplate && mged_variables.show_menu && up) {
d222 1
a222 1
	  if((SEDIT_TRAN || SEDIT_SCALE || SEDIT_PICK) && mged_variables.edit)
d255 1
a255 1
	  if((OEDIT_TRAN || OEDIT_SCALE) && mged_variables.edit)
@


11.34
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.33 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d102 6
a107 1
	  Tcl_Eval(interp, "help M");
d328 6
a333 1
    Tcl_Eval(interp, "help aip");
d559 6
a564 1
	  Tcl_Eval(interp, "help matpick");
@


11.33
log
@mods so that commands check args internally
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.32 1997/03/20 14:48:29 bparker Exp bparker $ (BRL)";
a42 1
#include "./menu.h"
@


11.32
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.31 1997/02/10 19:37:07 bparker Exp bparker $ (BRL)";
d102 2
a103 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d105 1
d323 2
a324 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d326 1
d549 2
a550 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d552 1
@


11.31
log
@mods to wrt_point to handle the case where
"out" and "in" are the same matrix
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.30 1997/02/01 02:22:50 mike Exp bparker $ (BRL)";
d464 2
a465 2
CONST register matp_t change, in;
CONST register vect_t point;
@


11.30
log
@Updated to use new libbn routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.29 1997/02/01 02:12:38 mike Exp mike $ (BRL)";
d463 3
a465 2
register matp_t out, change, in;
register vect_t point;
d470 5
a474 1
	bn_mat_mul( out, t, in );
@


11.29
log
@BParker 'up' mods.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.28 1997/01/29 03:35:50 mike Exp bparker $ (BRL)";
d466 1
a466 1
	static mat_t t1, t2, pt_to_origin, origin_to_pt;
d468 2
a469 18
	/* build "point to origin" matrix */
	bn_mat_idn( pt_to_origin );
	MAT_DELTAS(pt_to_origin, -point[X], -point[Y], -point[Z]);

	/* build "origin to point" matrix */
	bn_mat_idn( origin_to_pt );
	MAT_DELTAS(origin_to_pt, point[X], point[Y], point[Z]);

	/* t1 = pt_to_origin * in */
	bn_mat_mul( t1, pt_to_origin, in );

	/* apply change matrix: t2 = change * pt_to_origin * in */
	bn_mat_mul( t2, change, t1 );

	/* apply origin_to_pt matrix:
	 *	out = origin_to_pt * change * pt_to_origin * in
	 */
	bn_mat_mul( out, origin_to_pt, t2 );
d484 1
a484 1
	static mat_t	t1, t2;
a503 6
	/* t1 = pt_to_origin * in */
	bn_mat_mul( t1, pt_to_origin, in );

	/* t2 = d_to_zaxis * pt_to_origin * in */
	bn_mat_mul( t2, d_to_zaxis, t1 );

d507 1
a507 6
	bn_mat_mul( t1, change, t2 );

	/* apply zaxis_to_d matrix:
	 *	t2 = zaxis_to_d * change * d_to_zaxis * pt_to_origin * in
	 */
	bn_mat_mul( t2, zaxis_to_d, t1 );
d510 2
a511 2
	 *	out = origin_to_pt * zaxis_to_d * change *
	 *		d_to_zaxis * pt_to_origin * in
d513 1
a513 1
	bn_mat_mul( out, origin_to_pt, t2 );
@


11.28
log
@Don't need db.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.27 1997/01/02 19:40:36 bparker Exp $ (BRL)";
d110 1
a110 1
	if (mged_variables.faceplate && mged_variables.show_menu) {
d115 1
a115 1
	  if( (xpos >= MENUXLIM) && up || scroll_active && up)  {
d121 1
a121 1
	    if( (i = scroll_select(xpos, ypos )) < 0 )  {
d142 1
a142 1
	  if( xpos < MENUXLIM && up )  {
d145 1
a145 1
	    if( (i = mmenu_select( ypos )) < 0 )  {
@


11.27
log
@mods to use libbn and libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.26 1996/12/17 22:36:57 bparker Exp bparker $ (BRL)";
a37 1
#include "db.h"
@


11.26
log
@use SEDIT_PICK to help redirect mouse events
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.25 1996/12/11 22:40:57 bparker Exp bparker $ (BRL)";
d35 1
d37 1
d446 2
a447 2
	mat_mul( t1, toViewcenter, in );
	mat_mul( t2, change, t1 );
d450 1
a450 1
	mat_idn( t1 );
d452 1
a452 1
	mat_mul( out, t1, t2 );
d470 1
a470 1
	mat_idn( pt_to_origin );
d474 1
a474 1
	mat_idn( origin_to_pt );
d478 1
a478 1
	mat_mul( t1, pt_to_origin, in );
d481 1
a481 1
	mat_mul( t2, change, t1 );
d486 1
a486 1
	mat_mul( out, origin_to_pt, t2 );
d507 1
a507 1
	mat_idn( pt_to_origin );
d511 1
a511 1
	mat_idn( origin_to_pt );
d516 1
a516 1
	mat_fromto(d_to_zaxis, direc, zaxis);
d519 1
a519 1
	mat_inv(zaxis_to_d, d_to_zaxis);
d522 1
a522 1
	mat_mul( t1, pt_to_origin, in );
d525 1
a525 1
	mat_mul( t2, d_to_zaxis, t1 );
d530 1
a530 1
	mat_mul( t1, change, t2 );
d535 1
a535 1
	mat_mul( t2, zaxis_to_d, t1 );
d541 1
a541 1
	mat_mul( out, origin_to_pt, t2 );
@


11.25
log
@experimenting
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.24 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d215 1
a215 1
	  if((SEDIT_TRAN || SEDIT_SCALE) && mged_variables.edit)
@


11.24
log
@experimentation
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.23 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
a198 13
#if 1
	  {
	    struct bu_vls vls;
	    int status;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "sv %d %d", xpos, ypos);
	    status = Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);

	    return status;
	  }
#else
a199 1
#endif
d215 3
a217 19
	  if((SEDIT_TRAN || SEDIT_SCALE) && mged_variables.edit){
#if 0
	    mousevec[Z] = edit_absolute_tran[Z];
#endif
	    aslewview( mousevec );
	  }else
#if 1
	  {
	    struct bu_vls vls;
	    int status;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "sv %d %d", xpos, ypos);
	    status = Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);

	    return status;
	  }
#else
a218 1
#endif
d249 1
a249 1
	    aslewview( mousevec );
d251 1
a251 9
#if 1
	  {
	    struct bu_vls vls;
	    int status;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "sv %d %d", xpos, ypos);
	    status = Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
a252 5
	    return status;
	  }
#else
	    slewview( mousevec );
#endif
@


11.23
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.22 1996/12/06 21:55:11 bparker Exp bparker $ (BRL)";
d229 2
a230 1
	  if(SEDIT_TRAN || SEDIT_SCALE){
d232 1
d279 1
a279 1
	  if(OEDIT_TRAN || OEDIT_SCALE)
@


11.22
log
@not done yet --- working on allowing full view manipulation while editing
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.21 1996/11/19 21:21:40 bparker Exp bparker $ (BRL)";
d229 2
a230 2
	  if(!SEDIT_ROTATE && es_edflag > IDLE){
	    mousevec[Z] = absolute_slew[Z];
d277 1
a277 1
	  if(!OEDIT_ROTATE && edobj)
@


11.21
log
@initialize illump and ipathpos
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.20 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d199 13
d213 1
d233 13
d247 1
d280 13
d294 1
@


11.20
log
@hacks to use latest libdm
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.19 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d51 2
a52 2
struct solid	*illump;	/* == 0 if none, else points to ill. solid */
int		ipathpos;	/* path index of illuminated element */
d110 47
a156 22
        /*
	 * If mouse press is in scroll area, see if scrolling, and if so,
	 * divert this mouse press.
	 */
	if( (xpos >= MENUXLIM) && up || scroll_active && up)  {
		register int i;

		if(scroll_active)
		  ypos = scroll_y;

		if( (i = scroll_select(xpos, ypos )) < 0 )  {
		   Tcl_AppendResult(interp, "mouse press outside valid scroll area\n", (char *)NULL);
		   return TCL_ERROR;
		} 
		if( i > 0 )  {
		  scroll_active = 1;
		  scroll_y = ypos;

		  /* Scroller bars claimed button press */
		  return TCL_OK;
		}
		/* Otherwise, fall through */
a157 18

	/*
	 * If menu is active, and mouse press is in menu area,
	 * divert this mouse press for menu purposes.
	 */
	if( xpos < MENUXLIM && up )  {
		register int i;
		if( (i = mmenu_select( ypos )) < 0 )  {
		  Tcl_AppendResult(interp, "mouse press outside valid menu\n", (char *)NULL);
		  return TCL_ERROR;
		}
		if( i > 0 )  {
		  /* Menu claimed button press */
		  return TCL_OK;
		}
		/* Otherwise, fall through */
	}
      }
@


11.19
log
@now using more generalized solid macros
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.18 1996/09/23 18:19:22 bparker Exp bparker $ (BRL)";
d282 3
a284 1
				dmp->dmr_viewchange( dmp, DM_CHGV_ILLUM, sp );
d351 3
a353 1
    dmp->dmr_viewchange( dmp, DM_CHGV_ILLUM, sp );
d589 5
a593 3
	dmp->dmr_light( dmp, LIGHT_ON, BE_ACCEPT );
	dmp->dmr_light( dmp, LIGHT_ON, BE_REJECT );
	dmp->dmr_light( dmp, LIGHT_OFF, BE_O_ILLUMINATE );
@


11.18
log
@use LIBDM permanently
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.17 1996/09/17 21:18:46 bparker Exp bparker $ (BRL)";
d41 1
a41 1
#include "./solid.h"
d277 1
a277 1
	FOR_ALL_SOLIDS( sp )  {
d334 2
a335 2
      if(sp->s_forw == &HeadSolid)
	sp = HeadSolid.s_forw;
d337 1
a337 1
	sp = sp->s_forw;
d339 2
a340 2
      if(sp->s_back == &HeadSolid)
	sp = HeadSolid.s_back;
d342 1
a342 1
	sp = sp->s_back;
d590 1
a590 1
	FOR_ALL_SOLIDS( sp )  {
@


11.17
log
@prepare to use libdm
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.16 1996/08/21 13:54:11 jra Exp bparker $ (BRL)";
d43 1
a43 1
#include "./dm.h"
a281 1
#ifdef USE_LIBDM
a282 3
#else
				dmp->dmr_viewchange( DM_CHGV_ILLUM, sp );
#endif
a348 1
#ifdef USE_LIBDM
a349 3
#else
    dmp->dmr_viewchange( DM_CHGV_ILLUM, sp );
#endif
a584 1
#ifdef USE_LIBDM
d588 1
a588 5
#else
	dmp->dmr_light( LIGHT_ON, BE_ACCEPT );
	dmp->dmr_light( LIGHT_ON, BE_REJECT );
	dmp->dmr_light( LIGHT_OFF, BE_O_ILLUMINATE );
#endif
@


11.16
log
@Minor mods for IRIX 6.2.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.15 1996/08/14 20:24:51 bparker Exp jra $ (BRL)";
d282 3
d286 1
d353 3
d357 1
d593 5
d601 1
a601 1

@


11.15
log
@initialize mousevec[Z] before calling aslewview
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.14 1996/07/15 20:39:48 bparker Exp bparker $ (BRL)";
d308 1
a308 1
  static count = -1;
@


11.14
log
@thread mouse interaction through knob command where
the sliders get updated
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.13 1996/05/24 19:10:02 bparker Exp bparker $ (BRL)";
d208 2
a209 1
	  if(!SEDIT_ROTATE && es_edflag > IDLE)
d211 1
a211 1
	  else
@


11.13
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.12 1996/05/16 20:59:26 bparker Exp bparker $ (BRL)";
d109 1
a109 1
	if (mged_variables.faceplate && mged_variables.show_menu && !tran_set) {
d208 4
a211 1
	  sedit_mouse( mousevec );
d241 5
a245 2
		objedit_mouse( mousevec );
		return TCL_OK;
@


11.12
log
@modifying sliders
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.11 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d109 1
a109 1
	if (mged_variables.faceplate && mged_variables.show_menu) {
@


11.11
log
@convert commands to Tcl
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.10 1996/03/22 18:30:48 bparker Exp bparker $ (BRL)";
d114 1
a114 1
	if( (xpos >= MENUXLIM) && up )  {
d117 3
d125 5
a129 2
			/* Scroller bars claimed button press */
			return TCL_OK;
@


11.10
log
@cleanup
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.9 1996/03/01 19:15:15 bparker Exp bparker $ (BRL)";
d89 3
a91 1
f_mouse( argc, argv )
d101 3
d118 2
a119 2
			rt_log("mouse press outside valid scroll area\n");
			return CMD_BAD;
d123 1
a123 1
			return CMD_OK;
d135 2
a136 2
			rt_log("mouse press outside valid menu\n");
			return CMD_BAD;
d139 2
a140 2
			/* Menu claimed button press */
			return CMD_OK;
d158 1
a158 1
		return CMD_OK;		/* Take no action in these states */
d162 5
a166 5
		/*
		 * Use the mouse for illuminating a solid
		 */
		illuminate( ypos );
		return CMD_OK;
d169 9
a177 9
		/*
		 * Convert DT position to path element select
		 */
		isave = ipathpos;
		ipathpos = illump->s_last - (
			(ypos+2048L) * (illump->s_last+1) / 4096);
		if( ipathpos != isave )
			dmaflag++;
		return CMD_OK;
d182 6
a187 6
		/*
		 * Use the DT for moving view center.
		 * Make indicated point be new view center (NEW).
		 */
		slewview( mousevec );
		return CMD_OK;
d190 4
a193 4
		ipathpos = 0;
		(void)chg_state( ST_O_PICK, ST_O_PATH, "mouse press");
		dmaflag = 1;
		return CMD_OK;
d196 4
a199 4
		/* Check details, Init menu, set state */
		init_sedit();		/* does chg_state */
		dmaflag = 1;
		return CMD_OK;
d203 1
a203 1
	  return CMD_OK;
d222 1
a222 1
			(void)f_matpick( 2, av );
d224 1
a224 1
			return CMD_OK;
d229 1
a229 1
		return CMD_OK;
d233 1
a233 1
		return CMD_OK;
d237 1
a237 1
		return CMD_BAD;
d288 3
a290 1
f_aip(argc, argv)
d298 3
d302 1
a302 1
    return CMD_BAD;
d314 2
a315 2
      rt_log("aill: bad parameter - %s\n", argv[1]);
      return CMD_BAD;
d331 2
a332 2
      rt_log("aill: bad parameter - %s\n", argv[1]);
      return CMD_BAD;
d341 1
a341 1
  return CMD_OK;
d532 3
a534 1
f_matpick( argc, argv )
d542 5
a546 1
	if( not_state( ST_O_PATH, "Object Edit matrix pick" ) )  return CMD_BAD;
d551 1
a551 1
			return CMD_BAD;
d554 1
a554 1
			return CMD_BAD;
d562 4
a565 3
		rt_log("matpick: unable to find arc %s/%s in current selection.  Re-specify.\n",
			d0->d_namep, d1->d_namep );
		return CMD_BAD;
d593 1
a593 1
	return CMD_OK;
@


11.9
log
@remove unused XMGED stuff
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.8 1996/01/17 22:06:52 bparker Exp bparker $ (BRL)";
a44 1
#ifdef VIRTUAL_TRACKBALL
a45 1
#endif
d273 1
a273 2
#ifdef MULTI_ATTACH
	if( saveillump != illump ){
a274 6
	  dmaflag++;
	}
#else
	if( saveillump != illump )
		dmaflag++;
#endif
a329 1
#ifdef MULTI_ATTACH
a330 2
#endif
  dmaflag = 1;
@


11.8
log
@now using mged_variable.show_menu instead of
ignore_scroll_and_menu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.7 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
d45 1
a45 2
#ifdef XMGED
#include <errno.h>
a46 7

extern int using_dmX;
extern void (*tran_hook)();
extern void (*set_tran_hook)();
extern double tran_x;
extern double tran_y;
extern double tran_z;
d106 1
a106 3
	if (mged_variables.faceplate) {

	if(mged_variables.show_menu){
a141 1
      }
a173 4
#ifdef XMGED
		else
		  dmaflag = 0;
#endif
d199 2
a200 13
		sedit_mouse( mousevec );
#ifdef XMGED
		if(es_edflag >= STRANS && es_edflag <= PTARB && tran_hook){
		  point_t new_pos;
		  point_t old_pos;
		  point_t diff;

		  MAT4X3PNT( new_pos, view2model, mousevec);
		  set_tran(new_pos[X], new_pos[Y], new_pos[Z]);
/*		  (*tran_hook)();*/
		}
#endif
		return CMD_OK;
a229 9
#ifdef XMGED
		if(edobj == BE_O_X || edobj == BE_O_Y || edobj == BE_O_XY){
		  point_t new_pos;

		  MAT4X3PNT( new_pos, view2model, mousevec);
		  set_tran(new_pos[X], new_pos[Y], new_pos[Z]);
/*		  (*tran_hook)();*/
		}
#endif
d274 1
a274 7
#ifdef Xmged
	if( saveillump != illump ){
	  update_views = 1;
	  dmaflag++;
	}else
		--dmaflag;	/* illiminates unnecessary redrawing */
#else
a282 1
#endif
@


11.7
log
@Just playing it safe
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.6 1995/12/04 22:06:13 bparker Exp bparker $ (BRL)";
d116 1
a116 1
	if(!ignore_scroll_and_menu){
@


11.6
log
@using ignore_scroll_and_menu to shut off old menus and scrollbars
if requested by the display manager
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.5 1995/11/07 22:59:49 bparker Exp bparker $ (BRL)";
a48 1
extern int update_views;
a54 1

d316 6
d325 1
d381 1
a381 1
#if 0
@


11.5
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.4 1995/11/07 14:39:36 bparker Exp bparker $ (BRL)";
a56 2
int ignore_scroll_and_menu = 0;

a117 1
#ifdef XMGED
d119 1
a119 2
#endif
	/*
d153 1
a153 2

#ifdef XMGED
a154 2
#endif

a155 1
    }
@


11.4
log
@modified and unleashed f_aip
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.3 1995/08/10 21:11:50 gdurf Exp bparker $ (BRL)";
a59 1
int f_aip();
@


11.3
log
@Fixed menus-work-even-when-faceplate-removed bug
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 11.2 1995/01/17 13:05:17 bparker Exp gdurf $ (BRL)";
a58 1
void f_aip();
d60 1
a331 1
#ifdef XMGED
d337 1
a337 1
void
d347 1
a347 1
    return;
d360 1
a360 1
      return;
d363 12
a374 7

    if(argc == 1 || *argv[1] == 'f')
      ++count;
    else if(*argv[1] == 'b'){
      --count;
      if(count < 0)
	count = ndrawn - 1;
d377 1
a377 17
      return;
    }

    for(i = 0, sp = HeadSolid.s_forw; i < count; ++i){
      sp->s_iflag = DOWN;
      sp = sp->s_forw;
      if(sp == &HeadSolid){
	count = 0;
	sp = HeadSolid.s_forw;
      }
    }

    if(argc == 2 && *argv[1] == 'b'){
      if(sp->s_forw == &HeadSolid)
	HeadSolid.s_forw->s_iflag = DOWN;
      else
	sp->s_forw->s_iflag = DOWN;
d385 1
d387 1
d389 1
a390 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/usepen.c,v 11.2 95/01/17 11:44:42 bparker Exp $ (BRL)";
d119 2
d162 3
a164 1
	
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.13 95/01/03 14:32:14 gdurf Exp $ (BRL)";
d45 17
d119 3
d156 4
d192 4
d222 11
d263 9
d316 7
d325 1
d327 70
@


10.13
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.12 94/12/24 01:07:01 mike Exp Locker: gdurf $ (BRL)";
@


10.12
log
@Added "matpick" command.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.11 94/12/16 19:37:33 gdurf Exp Locker: mike $ (BRL)";
@


10.11
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.10 1994/08/19 16:14:06 pjt Exp gdurf $ (BRL)";
d29 5
a90 1
	register struct solid	*sp;
d206 10
a215 15
		dmp->dmr_light( LIGHT_ON, BE_ACCEPT );
		dmp->dmr_light( LIGHT_ON, BE_REJECT );
		dmp->dmr_light( LIGHT_OFF, BE_O_ILLUMINATE );

		/* Include all solids with same tree top */
		FOR_ALL_SOLIDS( sp )  {
			register int j;

			for( j = 0; j <= ipathpos; j++ )  {
				if( sp->s_path[j] != illump->s_path[j] )
					break;
			}
			/* Only accept if top of tree is identical */
			if( j == ipathpos+1 )
				sp->s_iflag = UP;
a216 2
		(void)chg_state( ST_O_PATH, ST_O_EDIT, "mouse press" );
		chg_l2menu(ST_O_EDIT);
a217 6
		/* begin object editing - initialize */
		init_objedit();

		dmaflag++;
		return CMD_OK;

d444 71
@


10.10
log
@Implemented wrt_point_direc
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.9 94/08/09 18:53:05 gdurf Exp Locker: pjt $ (BRL)";
d106 1
a106 1
			(void)printf("mouse press outside valid scroll area\n");
d123 1
a123 1
			(void)printf("mouse press outside valid menu\n");
@


10.9
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.8 1994/06/17 00:26:51 gdurf Exp gdurf $ (BRL)";
d396 55
@


10.8
log
@Corrected f_mouse return code
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.7 1994/06/01 16:58:56 gdurf Exp gdurf $ (BRL)";
d24 2
@


10.7
log
@Converted f_mouse to use new command return codes.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.6 1994/03/09 00:17:59 mike Exp gdurf $ (BRL)";
d151 1
a151 1
		return;
@


10.6
log
@Added comments and curlies.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.5 92/06/12 23:53:18 mike Exp Locker: mike $ (BRL)";
d79 1
a79 1
void
d105 1
a105 1
			return;
d109 1
a109 1
			return;
d122 1
a122 1
			return;
d126 1
a126 1
			return;
d143 1
a143 1
		return;		/* Take no action in these states */
d162 1
a162 1
		return;
d172 1
a172 1
		return;
d178 1
a178 1
		return;
d184 1
a184 1
		return;
d188 1
a188 1
		return;
d223 1
a223 1
		return;
d227 1
a227 1
		return;
d231 1
a231 1
		return;
d235 1
a235 1
		return;
@


10.5
log
@Added support for VPICK state
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.4 91/12/19 03:07:38 mike Exp Locker: mike $ (BRL)";
d242 4
d263 2
a264 1
		if( sp->s_flag == UP )
d269 2
a270 1
			}  else
d272 2
@


10.4
log
@Moved mouse event handling for solid edit and object edit states
into edsol.c, for consolidation with other editing routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.3 91/12/19 02:34:31 mike Exp Locker: mike $ (BRL)";
d223 4
@


10.3
log
@If a menu item needs sedraw=1 set, then it should do it itself.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.2 91/11/05 00:03:03 mike Exp Locker: mike $ (BRL)";
a36 1
#include "./sedit.h"
a41 1
int	sedraw;			/* apply solid editing changes */
a83 1
	fastf_t			scale;
a84 3
	vect_t	pos_view;	 	/* Unrotated view space pos */
	vect_t	pos_model;	/* Rotated screen space pos */
	vect_t	tr_temp;		/* temp translation vector */
a85 1
	vect_t	temp;
d187 1
a187 94
		/*
		 *  Solid Edit
		 */
		if( es_edflag <= 0 )  return;
		switch( es_edflag )  {

		case SSCALE:
		case PSCALE:
			/* use mouse to get a scale factor */
			es_scale = 1.0 + 0.25 * ((fastf_t)
				(ypos > 0 ?
					ypos :
					-ypos) / 2047);
			if ( ypos <= 0 )
				es_scale = 1.0 / es_scale;

			/* accumulate scale factor */
			acc_sc_sol *= es_scale;

			sedraw = 1;
			return;
		case STRANS:
			/* 
			 * Use mouse to change solid's location.
			 * Project solid's V point into view space,
			 * replace X,Y (but NOT Z) components, and
			 * project result back to model space.
			 */
			/* XXX this makes bad assumptions about format of es_rec !! */
			MAT4X3PNT( temp, es_mat, es_rec.s.s_values );
			MAT4X3PNT( pos_view, model2view, temp );
			pos_view[X] = xpos / 2047.0;
			pos_view[Y] = ypos / 2047.0;
			MAT4X3PNT( temp, view2model, pos_view );
			MAT4X3PNT( es_rec.s.s_values, es_invmat, temp );
			sedraw = 1;
			return;
		case MOVEH:
		case MOVEHH:
			/* Use mouse to change location of point V+H */
			VADD2( temp, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
			MAT4X3PNT(pos_model, es_mat, temp);
			MAT4X3PNT( pos_view, model2view, pos_model );
			pos_view[X] = xpos / 2047.0;
			pos_view[Y] = ypos / 2047.0;
			/* Do NOT change pos_view[Z] ! */
			MAT4X3PNT( temp, view2model, pos_view );
			MAT4X3PNT( tr_temp, es_invmat, temp );
			VSUB2( &es_rec.s.s_tgc_H, tr_temp, &es_rec.s.s_tgc_V );
			sedraw = 1;
			return;
		case PTARB:
			/* move an arb point to indicated point */
			/* point is located at es_values[es_menu*3] */
			VADD2(temp, es_rec.s.s_values, &es_rec.s.s_values[es_menu*3]);
			MAT4X3PNT(pos_model, es_mat, temp);
			MAT4X3PNT(pos_view, model2view, pos_model);
			pos_view[X] = xpos / 2047.0;
			pos_view[Y] = ypos / 2047.0;
			MAT4X3PNT(temp, view2model, pos_view);
			MAT4X3PNT(pos_model, es_invmat, temp);
			editarb( pos_model );
			sedraw = 1;
			return;
		case EARB:
			/* move arb edge, through indicated point */
			mousevec[X] = xpos / 2047.0;
			mousevec[Y] = ypos / 2047.0;
			mousevec[Z] = 0;
			MAT4X3PNT( temp, view2model, mousevec );
			/* apply inverse of es_mat */
			MAT4X3PNT( pos_model, es_invmat, temp );
			editarb( pos_model );
			sedraw = 1;
			return;
		case MVFACE:
			/* move arb face, through  indicated  point */
			mousevec[X] = xpos / 2047.0;
			mousevec[Y] = ypos / 2047.0;
			mousevec[Z] = 0;
			MAT4X3PNT( temp, view2model, mousevec );
			/* apply inverse of es_mat */
			MAT4X3PNT( pos_model, es_invmat, temp );
			/* change D of planar equation */
			es_peqn[es_menu][3]=VDOT(&es_peqn[es_menu][0], pos_model);
			/* calculate new vertices, put in record as vectors */
			calc_pnts( &es_rec.s, es_rec.s.s_cgtype );
			sedraw = 1;
			return;
			
		default:
			(void)printf("mouse press undefined in this solid edit mode\n");
			break;
		}
d226 1
a226 74
		/*
		 *  Object Edit
		 */
		mat_idn( incr_change );
		scale = 1;
		if( movedir & SARROW )  {
			/* scaling option is in effect */
			scale = 1.0 + (fastf_t)(ypos > 0 ?
				ypos : -ypos) / (2047);
			if ( ypos <= 0 )
				scale = 1.0 / scale;

			/* switch depending on scaling option selected */
			switch( edobj ) {

				case BE_O_SCALE:
					/* global scaling */
					incr_change[15] = 1.0 / scale;
				break;

				case BE_O_XSCALE:
					/* local scaling ... X-axis */
					incr_change[0] = scale;
					/* accumulate the scale factor */
					acc_sc[0] *= scale;
				break;

				case BE_O_YSCALE:
					/* local scaling ... Y-axis */
					incr_change[5] = scale;
					/* accumulate the scale factor */
					acc_sc[1] *= scale;
				break;

				case BE_O_ZSCALE:
					/* local scaling ... Z-axis */
					incr_change[10] = scale;
					/* accumulate the scale factor */
					acc_sc[2] *= scale;
				break;
			}

			/* Have scaling take place with respect to a point,
			 * NOT the view center.
			 */
			/* XXX should have an es_keypoint for this */
			MAT4X3PNT(temp, es_mat, es_rec.s.s_values);
			MAT4X3PNT(pos_model, modelchanges, temp);
			wrt_point(modelchanges, incr_change, modelchanges, pos_model);
		}  else if( movedir & (RARROW|UARROW) )  {
			mat_t oldchanges;	/* temporary matrix */

			/* Vector from object center to cursor */
			/* XXX should have an es_keypoint for this */
			MAT4X3PNT( temp, es_mat, es_rec.s.s_values );
			MAT4X3PNT( pos_view, model2objview, temp );
			if( movedir & RARROW )
				pos_view[X] = xpos / 2047.0;
			if( movedir & UARROW )
				pos_view[Y] = ypos / 2047.0;

			MAT4X3PNT( pos_model, view2model, pos_view );/* NOT objview */
			MAT4X3PNT( tr_temp, modelchanges, temp );
			VSUB2( tr_temp, pos_model, tr_temp );
			MAT_DELTAS(incr_change,
				tr_temp[X], tr_temp[Y], tr_temp[Z]);
			mat_copy( oldchanges, modelchanges );
			mat_mul( modelchanges, incr_change, oldchanges );
		}  else  {
			(void)printf("No object edit mode selected;  mouse press ignored\n");
			return;
		}
		mat_idn( incr_change );
		new_mats();
@


10.2
log
@Modified for beginnings of new display manager interface.
Added zoom and "M" (mouse) command.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/usepen.c,v 10.1 91/10/12 06:44:25 mike Rel4_0 Locker: mike $ (BRL)";
a132 3
			/* change solid edit menu if necessary */
			if( es_edflag == CONTROL || es_edflag == CHGMENU || es_edflag == SETUP_ROTFACE ) 
				sedraw = 1;
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 9.2 89/10/10 16:28:16 mike Exp $ (BRL)";
d51 1
a51 1
 *			U S E P E N
d54 2
a55 1
 * Pressval is !0 when pen is pressed, DV_{PICK,INZOOM,OUTZOOM,SLEW}.
d58 1
a58 1
 *  The data tablet is the focus of much of the editing activity in GED.
d64 3
a66 3
 *  where the tablet is used to pick a solid to edit, using our
 *  unusual "illuminate" technique.  Moving the pen varies the solid
 *  being illuminated.  When the pen is pressed, the editor moves into
d71 2
a72 2
 *  again performing the illuminate procedure.  When the pen is pressed,
 *  the editor moves into state ST_O_PATH.  Now, moving the pen allows
d74 1
a74 1
 *  When the pen is pressed, the editor moves into state ST_O_EDIT,
d82 3
a84 1
usepen()
d86 11
a96 8
	static fastf_t scale;
	register struct solid *sp;
	static vect_t pos_view;	 	/* Unrotated view space pos */
	static vect_t pos_model;	/* Rotated screen space pos */
	static vect_t tr_temp;		/* temp translation vector */
	static vect_t tabvec;		/* tablet vector */
	static vect_t temp;
	int isave;
d98 5
d104 2
a105 2
	 * If pen press is in scroll area, see if scrolling, and if so,
	 * divert this pen press.
d107 1
a107 2
	if( (dm_values.dv_xpen >= MENUXLIM) &&
	    dm_values.dv_penpress)  {
d110 2
a111 2
		if( (i = scroll_select(dm_values.dv_xpen, dm_values.dv_ypen )) < 0 )  {
			(void)printf("pen press outside valid scroll area\n");
d122 2
a123 2
	 * If menu is active, and pen press is in menu area,
	 * divert this pen press for menu purposes.
d125 1
a125 3
	if( dm_values.dv_xpen < MENUXLIM &&
		dm_values.dv_penpress
	)  {
d127 2
a128 2
		if( (i = mmenu_select( dm_values.dv_ypen )) < 0 )  {
			(void)printf("pen press outside valid menu\n");
d143 2
a144 2
	 *  when the pen is not pressed;  this would relax the requirement
	 *  for the host being informed when the pen changes position.
d147 1
a147 1
	if( dm_values.dv_penpress == 0 )  switch( state )  {
d158 1
a158 1
		 * Use the tablet for illuminating a solid
d160 1
a160 1
		illuminate( dm_values.dv_ypen );
d169 1
a169 1
			(dm_values.dv_ypen+2048L) * (illump->s_last+1) / 4096);
d181 1
a181 5
		tabvec[X] =  dm_values.dv_xpen / 2047.0;
		tabvec[Y] =  dm_values.dv_ypen / 2047.0;
		tabvec[Z] = 0;

		slewview( tabvec );
d186 1
a186 1
		(void)chg_state( ST_O_PICK, ST_O_PATH, "Pen press");
d205 1
a205 1
			/* use pen to get a scale factor */
d207 4
a210 4
				(dm_values.dv_ypen > 0 ?
					dm_values.dv_ypen :
					-dm_values.dv_ypen) / 2047);
			if ( dm_values.dv_ypen <= 0 )
d220 1
a220 1
			 * Use pen to change solid's location.
d228 2
a229 2
			pos_view[X] = dm_values.dv_xpen / 2047.0;
			pos_view[Y] = dm_values.dv_ypen / 2047.0;
d236 1
a236 1
			/* Use pen to change location of point V+H */
d240 2
a241 2
			pos_view[X] = dm_values.dv_xpen / 2047.0;
			pos_view[Y] = dm_values.dv_ypen / 2047.0;
d254 2
a255 2
			pos_view[X] = dm_values.dv_xpen / 2047.0;
			pos_view[Y] = dm_values.dv_ypen / 2047.0;
d263 4
a266 4
			tabvec[X] = dm_values.dv_xpen / 2047.0;
			tabvec[Y] = dm_values.dv_ypen / 2047.0;
			tabvec[Z] = 0;
			MAT4X3PNT( temp, view2model, tabvec );
d274 4
a277 4
			tabvec[X] = dm_values.dv_xpen / 2047.0;
			tabvec[Y] = dm_values.dv_ypen / 2047.0;
			tabvec[Z] = 0;
			MAT4X3PNT( temp, view2model, tabvec );
d288 1
a288 1
			(void)printf("Pen press undefined in this solid edit mode\n");
d319 1
a319 1
		(void)chg_state( ST_O_PATH, ST_O_EDIT, "Pen press" );
d336 3
a338 4
			scale = 1.0 + (fastf_t)(dm_values.dv_ypen > 0 ?
				dm_values.dv_ypen :
				-dm_values.dv_ypen) / (2047);
			if ( dm_values.dv_ypen <= 0 )
d379 1
a379 1
			static mat_t oldchanges;	/* temporary matrix */
d386 1
a386 1
				pos_view[X] = dm_values.dv_xpen / 2047.0;
d388 1
a388 1
				pos_view[Y] = dm_values.dv_ypen / 2047.0;
d398 1
a398 1
			(void)printf("No object edit mode selected;  pen press ignored\n");
d406 1
a406 1
		state_err( "Pen press" );
d424 1
a424 1
	 * Divide the tablet into 'ndrawn' VERTICAL zones, and use the
@


9.2
log
@Added notes about where es_keypoint is needed
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 9.1 89/05/19 06:04:11 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 8.4 89/04/21 04:57:00 mike Exp $ (BRL)";
d221 1
d371 1
d379 1
@


8.4
log
@Interface hooks for supporting scroll bars (aka sliders).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 8.3 89/04/06 20:40:24 mike Locked $ (BRL)";
@


8.3
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 8.2 88/12/06 02:35:23 mike Locked $ (BRL)";
d31 1
d33 1
a33 1
#include "externs.h"
d93 19
d132 1
a132 1

@


8.2
log
@raytrace.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/usepen.c,v 1.2 88/10/23 13:57:03 mike Exp $ (BRL)";
d32 1
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 7.6 88/09/06 16:49:03 reschly Exp $ (BRL)";
d30 1
@


7.6
log
@added stdio include
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 7.5 88/07/22 01:59:48 reschly Locked $ (BRL)";
@


7.5
log
@menu -> mmenu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 7.4 88/05/15 23:05:27 phil Locked $ (BRL)";
d25 1
@


7.4
log
@lint fixes
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 7.3 88/04/28 17:32:14 mike Locked $ (BRL)";
d96 1
a96 1
		if( (i = menu_select( dm_values.dv_ypen )) < 0 )  {
@


7.3
log
@only redisplay when illuminated object changes
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 7.2 87/11/05 05:07:22 phil Locked $ (BRL)";
d43 1
d484 1
d498 1
d506 1
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 7.1 87/11/03 00:02:18 mike Rel $ (BRL)";
d85 1
d135 1
d138 2
a139 1
		dmaflag++;
d389 1
d391 2
d409 2
a410 1
	dmaflag++;
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 6.1 87/07/11 08:05:50 mike Rel $ (BRL)";
d26 1
a26 1
#include "./machine.h"	/* special copy */
d78 1
a78 1
	static float scale;
d175 1
a175 1
			es_scale = 1.0 + 0.25 * ((float)
d304 1
a304 1
			scale = 1.0 + (float)(dm_values.dv_ypen > 0 ?
d392 1
a392 1
	count = ( (float) y + 2048.0 ) * ndrawn / 4096.0;
d420 2
a421 2
	static float calpha, cbeta, cgamma;
	static float salpha, sbeta, sgamma;
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 5.1 87/06/24 22:22:42 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 4.2 87/02/13 00:13:27 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 4.1 86/12/29 03:23:31 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.13 86/09/09 23:48:51 mike Exp $ (BRL)";
@


2.13
log
@Dender:  MVFACE code.
Also, fixed for pen presses below menu area.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.12 86/08/12 06:51:21 mike Exp $ (BRL)";
@


2.12
log
@Changed #includes for CC -I../h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.11 86/06/19 23:49:23 mike Exp $ (BRL)";
d93 2
a94 1
		if( menu_select( dm_values.dv_ypen ) < 0 )
d96 10
a105 1
		return;
d240 15
@


2.11
log
@Changed MAX_PATH to 16
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.10 86/03/10 21:38:30 mike Exp $ (BRL)";
d27 7
a33 7
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "solid.h"
#include "menu.h"
#include "dm.h"
#include "sedit.h"
@


2.10
log
@Latest revisions from Keith, including lots of new commands
and one-axis scaling.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.9 85/08/07 05:20:10 mike Exp $ (BRL)";
a122 3
		 *
		 * The following formula depends heavily on
		 * the fact that s_count will never exceed 7.
d124 2
a125 2
		ipathpos = (dm_values.dv_ypen + 2048) * (illump->s_last+1) / 4096;
		ipathpos = illump->s_last - ipathpos;
@


2.9
log
@Changed to use common ../h/vmath.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.8 85/07/30 01:18:19 mike Exp $ (BRL)";
d281 1
d288 29
a316 7
			/*  To take effect relative to the view center,
			 *	p' = ( (p - center) * scale ) + center
			 */
			incr_change[15] = 1.0 / scale;
/*
			wrt_view( modelchanges, incr_change, modelchanges );
*/
@


2.8
log
@Change to support new ARB editing.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.7 85/06/06 22:33:29 mike Exp $ (BRL)";
d25 4
a28 2
#include	<math.h>
#include "ged_types.h"
a32 2
#include "../h/vmath.h"
#include "../h/db.h"
@


2.7
log
@KAA, added f_edgedir() support
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.6 85/05/29 23:17:40 mike Exp $ (BRL)";
d207 13
@


2.6
log
@Added MENU_L2 menu for solid/object edit buttons,
moved menus to left side of screen.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.5 85/05/10 00:56:07 mike Exp $ (BRL)";
d196 1
@


2.5
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.4 85/05/03 02:01:19 mike Exp $ (BRL)";
d90 1
a90 1
	if( dm_values.dv_xpen > XLIM &&
d252 1
@


2.4
log
@Increased coordination with menu routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.3 85/05/02 23:27:07 mike Exp $ (BRL)";
d90 2
a91 4
	if(  menu_on == TRUE  &&
		dm_values.dv_xpen > XLIM &&
		dm_values.dv_penpress &&
		menu_list != (struct menu_item *) NULL
d93 1
a93 1
		if( menu_select( dm_values.dv_ypen ) == 0 )
@


2.3
log
@Reorganized code, moved some logic to ged.c,
no change in function (yet).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.2 85/03/22 10:55:23 mike Exp $ (BRL)";
d87 2
a88 5
	 * Keep the pen input from doing other things to
	 * ged when the MENU_ON is active.  This test may want
	 * to include some other stuff for illumination, which
	 * might still be done in a vertical direction, with
	 * the menu active under the illumination info. Bob S
d91 8
a98 3
		menu_list != (struct menu_item *) NULL  &&
		menu_select( dm_values.dv_xpen, dm_values.dv_ypen, dm_values.dv_penpress )
	) return;
@


2.2
log
@symbolid changeview param.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: usepen.c,v 2.1 85/03/11 23:59:44 mike Prod $ (BRL)";
a79 1
	static int j;
a85 32
	/* TODO:  switch(dm_values.dv_penpress) { switch(state) {stuff} } */
	switch( dm_values.dv_penpress )  {
	case DV_INZOOM:
		Viewscale *= 0.5;
		new_mats();
		return;

	case DV_OUTZOOM:
		Viewscale *= 2.0;
		new_mats();
		return;

	case DV_SLEW:
		/* Move view center to here */
		tabvec[X] =  dm_values.dv_xpen / 2047.0;
		tabvec[Y] =  dm_values.dv_ypen / 2047.0;
		tabvec[Z] = 0;

		slewview( tabvec );
		return;

	case DV_PICK:
	case 0:
		break;
	default:
		(void)printf("usepen(%d,%d,x%x) -- bad dm press code\n",
			dm_values.dv_xpen,
			dm_values.dv_ypen,
			dm_values.dv_penpress);
		return;
	}

a96 3
	if( state == ST_VIEW )  {
		if( dm_values.dv_penpress == 0 )
			return;
d98 7
a104 7
		/*
		 * Use the DT for moving view center.
		 * Make indicated point be new view center (NEW).
		 */
		tabvec[X] =  dm_values.dv_xpen / 2047.0;
		tabvec[Y] =  dm_values.dv_ypen / 2047.0;
		tabvec[Z] = 0;
d106 5
a110 3
		slewview( tabvec );
		return;
	}
d112 2
a113 1
	if( state == ST_O_PICK || state == ST_S_PICK )  {
a114 16
		 * We are in "illuminate" mode, with no object selected.
		 */
		if( dm_values.dv_penpress )  {
			/* Currently illuminated object is selected */
			if( state == ST_O_PICK )  {
				ipathpos = 0;
				(void)chg_state( ST_O_PICK, ST_O_PATH, "Pen press");
			} else {
				/* Check details, Init menu, set state */
				init_sedit();
			}
			dmaflag = 1;
			return;
		}

		/*
a117 6

		/*
		 * People seem to find the cross-hair distracting in
		 * illuminate mode, so force it to the center.
		 */
		xcross = ycross = 0;
a118 1
	}
d120 1
a120 37
	if( state == ST_O_PATH )  {
		/* Select path element for Object Edit */
		/* If pressed, use selected path element */
		if( dm_values.dv_penpress )  {
			/*
			 * Set combination "illuminate" mode.  This code
			 * assumes that the user has already illuminated
			 * a single solid, and wishes to move a collection of
			 * objects of which the illuminated solid is a part.
			 * The whole combination will not illuminate (to save
			 * vector drawing time), but all the objects should
			 * move/scale in unison.
			 */
			dmp->dmr_light( LIGHT_ON, BE_ACCEPT );
			dmp->dmr_light( LIGHT_ON, BE_REJECT );
			dmp->dmr_light( LIGHT_OFF, BE_O_ILLUMINATE );

			/* Include all solids with same tree top */
			FOR_ALL_SOLIDS( sp )  {
				for( j = 0; j <= ipathpos; j++ )  {
					if( sp->s_path[j] !=
							illump->s_path[j] )
						break;
				}
				/* Only accept if top of tree is identical */
				if( j == ipathpos+1 )
					sp->s_iflag = UP;
			}
			(void)chg_state( ST_O_PATH, ST_O_EDIT, "Pen press" );

			/* begin object editing - initialize */
			init_objedit();

			dmaflag++;
			return;
		}

a130 1
	}
d132 12
a143 1
	if( !dm_values.dv_penpress )
d145 14
a158 4
	/*
	 * When pressed, use the DT for object transformations
	 */
	if( state == ST_S_EDIT && es_edflag > 0 )  switch( es_edflag )  {
d162 2
a163 7
	case SSCALE:
	case PSCALE:
		/* use pen to get a scale factor */
		es_scale = 1.0 + 0.25 *
				((float)(dm_values.dv_ypen > 0 ? dm_values.dv_ypen : -dm_values.dv_ypen) / 2047);
		if ( dm_values.dv_ypen <= 0 )
			es_scale = 1.0 / es_scale;
d165 9
a173 2
		/* accumulate scale factor */
		acc_sc_sol *= es_scale;
d175 48
a222 1
		sedraw = 1;
d224 10
a233 6
	case STRANS:
		/* 
		 * Use pen to change solid's location.
		 * Project solid's V point into view space,
		 * replace X,Y (but NOT Z) components, and
		 * project result back to model space.
d235 3
a237 36
		MAT4X3PNT( temp, es_mat, es_rec.s.s_values );
		MAT4X3PNT( pos_view, model2view, temp );
		pos_view[X] = dm_values.dv_xpen / 2047.0;
		pos_view[Y] = dm_values.dv_ypen / 2047.0;
		MAT4X3PNT( temp, view2model, pos_view );
		MAT4X3PNT( es_rec.s.s_values, es_invmat, temp );
		sedraw = 1;
		return;
	case MOVEH:
		/* Use pen to change location of point V+H */
		VADD2( temp, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
		MAT4X3PNT(pos_model, es_mat, temp);
		MAT4X3PNT( pos_view, model2view, pos_model );
		pos_view[X] = dm_values.dv_xpen / 2047.0;
		pos_view[Y] = dm_values.dv_ypen / 2047.0;
		/* Do NOT change pos_view[Z] ! */
		MAT4X3PNT( temp, view2model, pos_view );
		MAT4X3PNT( tr_temp, es_invmat, temp );
		VSUB2( &es_rec.s.s_tgc_H, tr_temp, &es_rec.s.s_tgc_V );
		sedraw = 1;
		return;
	case EARB:
		/* move arb edge, through indicated point */
		tabvec[X] = dm_values.dv_xpen / 2047.0;
		tabvec[Y] = dm_values.dv_ypen / 2047.0;
		tabvec[Z] = 0;
		MAT4X3PNT( temp, view2model, tabvec );
		/* apply inverse of es_mat */
		MAT4X3PNT( pos_model, es_invmat, temp );
		editarb( pos_model );
		sedraw = 1;
		return;
	default:
		(void)printf("Pen press undefined in this solid edit mode\n");
		return;
	}
d239 18
a256 1
	if( not_state( ST_O_EDIT, "Pen Press" ) )
d259 12
a270 9
	/*
	 *  Object Edit
	 */
	mat_idn( incr_change );
	scale = 1;
	if( movedir & SARROW )  {
		scale = 1.0 + (float)(dm_values.dv_ypen > 0 ? dm_values.dv_ypen : -dm_values.dv_ypen) / (2047);
		if ( dm_values.dv_ypen <= 0 )
			scale = 1.0 / scale;
d272 4
a275 4
		/*  For this to take effect relative to the view center,
		 *	p' = ( (p - center) * scale ) + center
		 */
		incr_change[15] = 1.0 / scale;
d277 1
a277 1
		wrt_view( modelchanges, incr_change, modelchanges );
d280 8
a287 8
		/* Have scaling take place with respect to a point, NOT
		 *	the view center
		 */
		MAT4X3PNT(temp, es_mat, es_rec.s.s_values);
		MAT4X3PNT(pos_model, modelchanges, temp);
		wrt_point(modelchanges, incr_change, modelchanges, pos_model);
	}  else if( movedir & (RARROW|UARROW) )  {
		static mat_t oldchanges;	/* temporary matrix */
d289 7
a295 7
		/* Vector from object center to cursor */
		MAT4X3PNT( temp, es_mat, es_rec.s.s_values );
		MAT4X3PNT( pos_view, model2objview, temp );
		if( movedir & RARROW )
			pos_view[X] = dm_values.dv_xpen / 2047.0;
		if( movedir & UARROW )
			pos_view[Y] = dm_values.dv_ypen / 2047.0;
d297 13
a309 9
		MAT4X3PNT( pos_model, view2model, pos_view );/* NOT objview */
		MAT4X3PNT( tr_temp, modelchanges, temp );
		VSUB2( tr_temp, pos_model, tr_temp );
		MAT_DELTAS(incr_change,
			tr_temp[X], tr_temp[Y], tr_temp[Z]);
		mat_copy( oldchanges, modelchanges );
		mat_mul( modelchanges, incr_change, oldchanges );
	}  else  {
		(void)printf("No object edit mode selected;  pen press ignored\n");
d311 4
d316 1
a316 2
	mat_idn( incr_change );
	new_mats();
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d362 2
a364 4
				illump->s_iflag = UP;
				dmaflag++;
				/* Inform display manager */
				dmp->dmr_viewchange();
d368 1
@


1.6
log
@USNA changes which formalize state changes.
@
text
@d8 12
d21 3
d31 2
a32 2
#include "vmath.h"
#include "db.h"
d49 1
a49 1
 * Press is !0 when pen is pressed.
d76 1
a76 2
usepen( x, y, press )
register int x, y;
d87 2
a88 2
	/* TODO:  switch(press) { switch(state) {stuff} } */
	switch( press )  {
d101 2
a102 2
		tabvec[X] =  x / 2047.0;
		tabvec[Y] =  y / 2047.0;
d112 4
a115 1
		printf("usepen(%d,%d,x%x) -- bad dm press code\n", x,y,press);
d128 1
a128 1
		menu_select( x, y, press )
d131 1
a131 1
		if( press == 0 )
d138 2
a139 2
		tabvec[X] =  x / 2047.0;
		tabvec[Y] =  y / 2047.0;
d150 1
a150 1
		if( press )  {
d166 1
a166 1
		illuminate( y );
d179 1
a179 1
		if( press )  {
d219 1
a219 1
		ipathpos = (y + 2048) * (illump->s_last+1) / 4096;
d225 1
a225 1
	if( !press )
d238 2
a239 2
				((float)(y > 0 ? y : -y) / 2047);
		if ( y <= 0 )
d256 2
a257 2
		pos_view[X] = x / 2047.0;
		pos_view[Y] = y / 2047.0;
d267 2
a268 2
		pos_view[X] = x / 2047.0;
		pos_view[Y] = y / 2047.0;
d277 2
a278 2
		tabvec[X] = x / 2047.0;
		tabvec[Y] = y / 2047.0;
d300 2
a301 2
		scale = 1.0 + (float)(y > 0 ? y : -y) / (2047);
		if ( y <= 0 )
d325 1
a325 1
			pos_view[X] = x / 2047.0;
d327 1
a327 1
			pos_view[Y] = y / 2047.0;
d337 1
a337 1
		printf("No object edit mode selected;  pen press ignored\n");
@


1.5
log
@Keith's global/local units additions
@
text
@d137 1
a137 1
				state = ST_O_PATH;
d187 1
a187 1
			state = ST_O_EDIT;
d274 1
a274 2
	if( state != ST_O_EDIT )  {
		state_err( "Pen Press" );
a275 1
	}
d344 1
a344 1
			if( count-- == 0 )  {
d348 2
@


1.4
log
@Processed dv_penpress with symbolic values;  all assignment
of function to buttons now done here.
@
text
@d188 4
d293 1
d295 8
d307 2
a308 1
		MAT4X3PNT( pos_view, model2objview, illump->s_center );
d315 1
a315 1
		MAT4X3PNT( tr_temp, modelchanges, illump->s_center );
d437 32
@


1.3
log
@pre-Keith version
@
text
@d71 1
d73 29
a112 1

d220 4
d233 2
a234 1
		MAT4X3PNT( pos_view, model2view, es_rec.s.s_values );
d237 2
a238 1
		MAT4X3PNT( es_rec.s.s_values, view2model, pos_view );
d243 2
a244 1
		VADD2( pos_model, &es_rec.s.s_tgc_V, &es_rec.s.s_tgc_H );
d249 2
a250 1
		MAT4X3PNT( tr_temp, view2model, pos_view );
d259 3
a261 1
		MAT4X3PNT( pos_model, view2model, tabvec );
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d17 1
a17 1
#include "3d.h"
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *			G E D 4 . C
d143 3
a145 3
			dm_light( LIGHT_ON, BE_ACCEPT );
			dm_light( LIGHT_ON, BE_REJECT );
			dm_light( LIGHT_OFF, BE_O_ILLUMINATE );
@
