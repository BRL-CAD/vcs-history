head	1.11;
access;
symbols
	rel-4-5:1.10
	ctj-4-5-post:1.10
	ctj-4-5-pre:1.10;
locks; strict;
comment	@ * @;


1.11
date	98.07.16.14.29.24;	author bparker;	state dead;
branches;
next	1.10;

1.10
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	96.03.22.22.58.24;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	96.03.22.18.39.19;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.03.20.22.15.31;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.03.08.18.33.24;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.03.05.22.00.51;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.03.01.21.34.11;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	96.02.26.21.59.19;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	96.02.23.20.25.05;	author bparker;	state Exp;
branches;
next	;


desc
@dm-ogl with multi-attach and virtual
trackball. The user related events will
also be handled via the Tcl/Tk bind command.
@


1.11
log
@cleaning house
@
text
@ /*
 *			D M - O G L . C
 *
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
 */

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include <termio.h>
#undef VMIN		/* is used in vmath.h, too */
#include <ctype.h>

#include <sys/types.h>
#include <sys/time.h>

#include <X11/X.h>
#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif
#if defined(linux)
#	undef   X_NOT_STDC_ENV
#	undef   X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>

#include "tcl.h"
#include "tk.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XInput.h>
#include "./oglinit.h"

#include <GL/glx.h>
#include <GL/gl.h>
/*XXXX*/
#if 1
#include <gl/device.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "./ged.h"
#include "./dm.h"
#include "./solid.h"

/* these are from /usr/include/gl.h could be device dependent */
#define XMAXSCREEN	1279
#define YMAXSCREEN	1023
#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

extern int dm_pipe[];

extern Tcl_Interp *interp;
extern Tk_Window tkwin;

extern void sl_toggle_scroll();		/* from scroll.c */

static void     establish_perspective();
static void     set_perspective();
static void	establish_lighting();
static void	establish_zbuffer();
static int	Ogl2_setup();
static void     set_knob_offset();
static void	Ogl2_configure_window_shape();
static int	Ogl2_doevent();
static void	Ogl2_gen_color();
static void     Ogl2_colorit();
static int      Ogl2_load_startup();
static void     ogl_var_init();
static XVisualInfo *Ogl2_set_visual();
static void     print_cmap();
static struct dm_list *get_dm_list();
static int irisX2ged();
static int irisY2ged();

/* Display Manager package interface */

#define IRBOUND	4095.9	/* Max magnification in Rot matrix */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
int	Ogl2_open();
int	Ogl2_dm();
void	Ogl2_close();
MGED_EXTERN(void	Ogl2_input, (fd_set *input, int noblock) );
void	Ogl2_prolog(), Ogl2_epilog();
void	Ogl2_normal(), Ogl2_newrot();
void	Ogl2_update();
void	Ogl2_puts(), Ogl2_2d_line(), Ogl2_light();
int	Ogl2_object();
unsigned Ogl2_cvtvecs(), Ogl2_load();
void	Ogl2_statechange(), Ogl2_viewchange(), Ogl2_colorchange();
void	Ogl2_window(), Ogl2_debug(), Ogl2_selectargs();

struct dm dm_ogl2 = {
	Ogl2_open, Ogl2_close,
	Ogl2_input,
	Ogl2_prolog, Ogl2_epilog,
	Ogl2_normal, Ogl2_newrot,
	Ogl2_update,
	Ogl2_puts, Ogl2_2d_line,
	Ogl2_light,
	Ogl2_object,	Ogl2_cvtvecs, Ogl2_load,
	Ogl2_statechange,
	Ogl2_viewchange,
	Ogl2_colorchange,
	Ogl2_window, Ogl2_debug,
	0,				/* no displaylist */
	0,				/* multi-window */
	IRBOUND,
	"ogl", "X Windows with OpenGL graphics",
	0,				/* mem map */
	Ogl2_dm
};


/* ogl stuff */
#define NSLOTS		4080	/* The mostest possible - may be fewer */
#define dpy (((struct ogl_vars *)dm_vars)->_dpy)
#define win (((struct ogl_vars *)dm_vars)->_win)
#define xtkwin (((struct ogl_vars *)dm_vars)->_xtkwin)
#define omx (((struct ogl_vars *)dm_vars)->_omx)
#define omy (((struct ogl_vars *)dm_vars)->_omy)
#define perspective_angle (((struct ogl_vars *)dm_vars)->_perspective_angle)
#define devmotionnotify (((struct ogl_vars *)dm_vars)->_devmotionnotify)
#define devbuttonpress (((struct ogl_vars *)dm_vars)->_devbuttonpress)
#define devbuttonrelease (((struct ogl_vars *)dm_vars)->_devbuttonrelease)
#define knobs (((struct ogl_vars *)dm_vars)->_knobs)
#define stereo_is_on (((struct ogl_vars *)dm_vars)->_stereo_is_on)
#define aspect (((struct ogl_vars *)dm_vars)->_aspect)
#define glxc (((struct ogl_vars *)dm_vars)->_glxc)
#define fontstruct (((struct ogl_vars *)dm_vars)->_fontstruct)
#define fontOffset (((struct ogl_vars *)dm_vars)->_fontOffset)
#define ovec (((struct ogl_vars *)dm_vars)->_ovec)
#define ogl_is_direct (((struct ogl_vars *)dm_vars)->_ogl_is_direct)
#define ogl_index_size (((struct ogl_vars *)dm_vars)->_ogl_index_size)
#define ogl_nslots (((struct ogl_vars *)dm_vars)->_ogl_nslots)
#define slotsused (((struct ogl_vars *)dm_vars)->_slotsused)
#define ogl_rgbtab (((struct ogl_vars *)dm_vars)->_ogl_rgbtab)

struct modifiable_ogl_vars {
  int cueing_on;
  int zclipping_on;
  int zbuffer_on;
  int lighting_on;
  int perspective_mode;
  int dummy_perspective;
  int zbuf;
  int rgb;
  int doublebuffer;
  int depth;
  int debug;
  int linewidth;
  int fastfog;
  double fogdensity;
  int virtual_trackball;
};

struct ogl_vars {
  struct rt_list l;
  struct dm_list *dm_list;
  Display *_dpy;
  Window _win;
  Tk_Window _xtkwin;
  Colormap cmap;
  GLdouble faceplate_mat[16];
  int face_flag;
  int width;
  int height;
  int _omx, _omy;
  int _perspective_angle;
  int _devmotionnotify;
  int _devbuttonpress;
  int _devbuttonrelease;
  int _knobs[8];
  int _stereo_is_on;
  fastf_t _aspect;
  GLXContext _glxc;
  XFontStruct *_fontstruct;
  int _fontOffset;
  int _ovec;		/* Old color map entry number */
  char    _ogl_is_direct;
  int _ogl_index_size;
/*
 * SGI Color Map table
 */
  int _ogl_nslots;		/* how many we have, <= NSLOTS */
  int _slotsused;		/* how many actually used */
  struct rgbtab {
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
  }_ogl_rgbtab[NSLOTS];
  struct modifiable_ogl_vars mvars;
};

#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
#endif

#ifdef IR_KNOBS
static int irlimit();			/* provides knob dead spot */
#define NOISE 32		/* Size of dead spot on knob */
/*
 *  Labels for knobs in help mode.
 */
static char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
static char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

static struct ogl_vars head_ogl_vars;
static int perspective_table[] = {
	30, 45, 60, 90 };
static double	xlim_view = 1.0;	/* args for glOrtho*/
static double	ylim_view = 1.0;

extern struct device_values dm_values;	/* values read from devices */

/* lighting parameters */
static float amb_three[] = {0.3, 0.3, 0.3, 1.0};

static float light0_position[] = {100.0, 200.0, 100.0, 0.0};
static float light1_position[] = {100.0, 30.0, 100.0, 0.0};
static float light2_position[] = {-100.0, 20.0, 20.0, 0.0};
static float light3_position[] = {0.0, -100.0, -100.0, 0.0};

static float light0_diffuse[] = {0.70, 0.70, 0.70, 1.0}; /* white */
static float light1_diffuse[] = {0.60, 0.10, 0.10, 1.0}; /* red */
static float light2_diffuse[] = {0.10, 0.30, 0.10, 1.0}; /* green */
static float light3_diffuse[] = {0.10, 0.10, 0.30, 1.0}; /* blue */

/* functions */
static void
refresh_hook()
{
	dmaflag = 1;
}

static void
do_linewidth()
{
	glLineWidth((GLfloat) ((struct ogl_vars *)dm_vars)->mvars.linewidth);
	dmaflag = 1;
}


static void
do_fog()
{
	glHint(GL_FOG_HINT, ((struct ogl_vars *)dm_vars)->mvars.fastfog ? GL_FASTEST : GL_NICEST);
	dmaflag = 1;
}

#define OGL2_MV_O(_m) offsetof(struct modifiable_ogl_vars, _m)
struct structparse Ogl2_vparse[] = {
	{"%d",	1, "depthcue",		OGL2_MV_O(cueing_on),	Ogl2_colorchange },
	{"%d",  1, "zclip",		OGL2_MV_O(zclipping_on),	refresh_hook },
	{"%d",  1, "zbuffer",		OGL2_MV_O(zbuffer_on),	establish_zbuffer },
	{"%d",  1, "lighting",		OGL2_MV_O(lighting_on),	establish_lighting },
	{"%d",  1, "perspective",       OGL2_MV_O(perspective_mode), establish_perspective },
	{"%d",  1, "set_perspective",   OGL2_MV_O(dummy_perspective),  set_perspective },
	{"%d",  1, "has_zbuf",		OGL2_MV_O(zbuf),	refresh_hook },
	{"%d",  1, "has_rgb",		OGL2_MV_O(rgb),	Ogl2_colorchange },
	{"%d",  1, "has_doublebuffer",	OGL2_MV_O(doublebuffer), refresh_hook },
	{"%d",  1, "depth",		OGL2_MV_O(depth),	FUNC_NULL },
	{"%d",  1, "debug",		OGL2_MV_O(debug),	FUNC_NULL },
	{"%d",  1, "linewidth",		OGL2_MV_O(linewidth),	do_linewidth },
	{"%d",  1, "fastfog",		OGL2_MV_O(fastfog),	do_fog },
	{"%f",  1, "density",		OGL2_MV_O(fogdensity),	refresh_hook },
	{"%d",  1, "virtual_trackball",	OGL2_MV_O(virtual_trackball),FUNC_NULL },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
};

/* Map +/-2048 GED space into -1.0..+1.0 :: x/2048*/
#define GED2IRIS(x)	(((float)(x))*0.00048828125)

static int OgldoMotion = 0;

/*
 * Display coordinate conversion:
 *  GED is using -2048..+2048,
 *  X is 0..width,0..height
 */
#define	GED_TO_Xx(x)	(((x)/4096.0+0.5)*((struct ogl_vars *)dm_vars)->width)
#define	GED_TO_Xy(x)	((0.5-(x)/4096.0)*((struct ogl_vars *)dm_vars)->height)

/* get rid of when no longer needed */
#define USE_RAMP	(((struct ogl_vars *)dm_vars)->mvars.cueing_on || ((struct ogl_vars *)dm_vars)->mvars.lighting_on)
#define CMAP_BASE	32
#define CMAP_RAMP_WIDTH	16
#define MAP_ENTRY(x)	( USE_RAMP ? \
			((x) * CMAP_RAMP_WIDTH + CMAP_BASE) : \
			((x) + CMAP_BASE) )

/********************************************************************/

/*
 *  Mouse coordinates are in absolute screen space, not relative to
 *  the window they came from.  Convert to window-relative,
 *  then to MGED-style +/-2048 range.
 */
static int
irisX2ged(x)
register int x;
{
  return ((x/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 4095);
}

static int
irisY2ged(y)
register int y;
{
  return ((0.5 - y/(double)((struct ogl_vars *)dm_vars)->height) * 4095);
}


/*
 *			O G L _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
Ogl2_open()
{
  ogl_var_init();

  return Ogl2_setup(dname);
}

/*XXX Just experimenting */
int
Ogl2_load_startup()
{
  FILE    *fp;
  struct rt_vls str;
  char *path;
  char *filename;
  int     found;

/*XXX*/
#define DM_OGL_RCFILE "oglinit.tk"

#if 1
  bzero((void *)&head_ogl_vars, sizeof(struct ogl_vars));
  RT_LIST_INIT( &head_ogl_vars.l );
#endif

  found = 0;
  rt_vls_init( &str );

  if((filename = getenv("DM_OGL_RCFILE")) == (char *)NULL )
    /* Use default file name */
    filename = DM_OGL_RCFILE;

  if((path = getenv("MGED_LIBRARY")) != (char *)NULL ){
    /* Use MGED_LIBRARY path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
  }

  if(!found){
    if( (path = getenv("HOME")) != (char *)NULL )  {
      /* Use HOME path */
      rt_vls_strcpy( &str, path );
      rt_vls_strcat( &str, "/" );
      rt_vls_strcat( &str, filename );

      if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
	found = 1;
    }
  }

  if( !found ) {
    /* Check current directory */
    if( (fp = fopen( filename, "r" )) != NULL )  {
      rt_vls_strcpy( &str, filename );
      found = 1;
    }
  }

  if(!found){
    rt_vls_free(&str);

    /* Using default */
    if(Tcl_Eval( interp, ogl_init_str ) == TCL_ERROR)
      return -1;

    return 0;
  }

  fclose( fp );

  if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
    rt_vls_free(&str);
    return -1;
  }

  rt_vls_free(&str);
  return 0;
}

/*
 *  			O G L _ C L O S E
 *  
 *  Gracefully release the display.
 */
void
Ogl2_close()
{

  if(glxc != NULL){
    glDrawBuffer(GL_FRONT);
    glClearColor(0.0, 0.0, 0.0, 0.0);
    /*	glClearDepth(0.0);*/
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glXDestroyContext(dpy, glxc);
  }

  if(xtkwin != NULL)
    Tk_DestroyWindow(xtkwin);

  if(((struct ogl_vars *)dm_vars)->l.forw != RT_LIST_NULL)
    RT_LIST_DEQUEUE(&((struct ogl_vars *)dm_vars)->l);

  rt_free(dm_vars, "Ogl2_close: dm_vars");

#if 0
	Tk_DeleteGenericHandler(Ogl2_doevent, (ClientData)curr_dm_list);
#else
	if(RT_LIST_IS_EMPTY(&head_ogl_vars.l))
	  Tk_DeleteGenericHandler(Ogl2_doevent, (ClientData)NULL);
#endif
}

/*
 *			O G L _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
void
Ogl2_prolog()
{
  GLint mm; 
  char i;
  char *str = "a";
  GLfloat fogdepth;

  if (((struct ogl_vars *)dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl2_prolog\n", (char *)NULL);

  if (!glXMakeCurrent(dpy, win, glxc)){
    Tcl_AppendResult(interp, "Ogl2_prolog: Couldn't make context current\n", (char *)NULL);
    return;
  }

#if 0
  Ogl2_configure_window_shape();
#endif

  if (!((struct ogl_vars *)dm_vars)->mvars.doublebuffer){
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /*			return;*/
  }

  if (((struct ogl_vars *)dm_vars)->face_flag){
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
    ((struct ogl_vars *)dm_vars)->face_flag = 0;
    if (((struct ogl_vars *)dm_vars)->mvars.cueing_on){
      glEnable(GL_FOG);
      fogdepth = 2.2 * Viewscale; /* 2.2 is heuristic */
      glFogf(GL_FOG_END, fogdepth);
      fogdepth = (GLfloat) (0.5*((struct ogl_vars *)dm_vars)->mvars.fogdensity/Viewscale);
      glFogf(GL_FOG_DENSITY, fogdepth);
      glFogi(GL_FOG_MODE, ((struct ogl_vars *)dm_vars)->mvars.perspective_mode ? GL_EXP : GL_LINEAR);
    }
    if (((struct ogl_vars *)dm_vars)->mvars.lighting_on){
      glEnable(GL_LIGHTING);
    }
  }
	
  glLineWidth((GLfloat) ((struct ogl_vars *)dm_vars)->mvars.linewidth);
}

/*
 *			O G L _ E P I L O G
 */
void
Ogl2_epilog()
{
  if (((struct ogl_vars *)dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl2_epilog\n", (char *)NULL);

  /*
   * A Point, in the Center of the Screen.
   * This is drawn last, to always come out on top.
   */

  glColor3ub( (short)ogl_rgbtab[4].r, (short)ogl_rgbtab[4].g, (short)ogl_rgbtab[4].b );
  glBegin(GL_POINTS);
  glVertex2i(0,0);
  glEnd();
  /* end of faceplate */

  if(((struct ogl_vars *)dm_vars)->mvars.doublebuffer ){
    glXSwapBuffers(dpy, win);
    /* give Graphics pipe time to work */
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  }

  /* Prevent lag between events and updates */
  XSync(dpy, 0);

  if(((struct ogl_vars *)dm_vars)->mvars.debug){
    int error;
    struct rt_vls tmp_vls;

    rt_vls_init(&tmp_vls);
    rt_vls_printf(&tmp_vls, "ANY ERRORS?\n");

    while((error = glGetError())!=0){
      rt_vls_printf(&tmp_vls, "Error: %x\n", error);
    }

    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
  }

  return;
}

/*
 *  			O G L _ N E W R O T
 *  load new rotation matrix onto top of stack
 */
void
Ogl2_newrot(mat, which_eye)
mat_t mat;
int which_eye;
{
	register fastf_t *mptr;
	GLfloat gtmat[16], view[16];
	GLfloat *gtmatp;
	mat_t	newm;
	int	i;

	
	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl2_newrot()\n", (char *)NULL);

	if(((struct ogl_vars *)dm_vars)->mvars.debug){
	  struct rt_vls tmp_vls;

	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "which eye = %d\t", which_eye);
	  rt_vls_printf(&tmp_vls, "newrot matrix = \n");
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);

	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
	}

	switch(which_eye)  {
	case 0:
		/* Non-stereo */
		break;
	case 1:
		/* R eye */
		glViewport(0,  0, (XMAXSCREEN)+1, ( YSTEREO)+1); 
		glScissor(0,  0, (XMAXSCREEN)+1, (YSTEREO)+1);
		Ogl2_puts( "R", 2020, 0, 0, DM_RED );
		break;
	case 2:
		/* L eye */
		glViewport(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1, ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1); 
		glScissor(0,  0+YOFFSET_LEFT, ( XMAXSCREEN)+1, ( YSTEREO+YOFFSET_LEFT)-( YOFFSET_LEFT)+1);
		break;
	}

	mptr = mat;

	gtmat[0] = *(mptr++) * aspect;
	gtmat[4] = *(mptr++) * aspect;
	gtmat[8] = *(mptr++) * aspect;
	gtmat[12] = *(mptr++) * aspect;

	gtmat[1] = *(mptr++) * aspect;
	gtmat[5] = *(mptr++) * aspect;
	gtmat[9] = *(mptr++) * aspect;
	gtmat[13] = *(mptr++) * aspect;

	gtmat[2] = *(mptr++);
	gtmat[6] = *(mptr++);
	gtmat[10] = *(mptr++);
	gtmat[14] = *(mptr++);

	gtmat[3] = *(mptr++);
	gtmat[7] = *(mptr++);
	gtmat[11] = *(mptr++);
	gtmat[15] = *(mptr++);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -1.0 );
	glMultMatrixf( gtmat );

	/* Make sure that new matrix is applied to the lights */
	if (((struct ogl_vars *)dm_vars)->mvars.lighting_on ){
		glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
		glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
		glLightfv(GL_LIGHT2, GL_POSITION, light2_position);
		glLightfv(GL_LIGHT3, GL_POSITION, light3_position);

	}
}



/*
 *  			O G L _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */

/* ARGSUSED */
int
Ogl2_object( sp, mat, ratio, white_flag )
register struct solid *sp;
mat_t mat;
double ratio;
int white_flag;
{
	register struct rt_vlist	*vp;
	register int nvec;
	register float	*gtvec;
	register float material[4];
	char	gtbuf[16+3*sizeof(double)];
	int first;
	int i,j;

	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "ogl2_Object()\n", (char *)NULL);

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

	if (sp->s_soldash)
		glEnable(GL_LINE_STIPPLE);		/* set dot-dash */

	if (white_flag && ((struct ogl_vars *)dm_vars)->mvars.cueing_on)
		glDisable(GL_FOG);	

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		register short	r, g, b;
		if( white_flag )  {
			r = g = b = 230;
		} else {
			r = (short)sp->s_color[0];
			g = (short)sp->s_color[1];
			b = (short)sp->s_color[2];
		}

		if(((struct ogl_vars *)dm_vars)->mvars.lighting_on)
		{

			/* Ambient = .2, Diffuse = .6, Specular = .2 */

			material[0] = 	.2 * ( r / 255.0);
			material[1] = 	.2 * ( g / 255.0);
			material[2] = 	.2 * ( b / 255.0);
			material[3] = 1.0;
			glMaterialfv(GL_FRONT, GL_AMBIENT, material);
			glMaterialfv(GL_FRONT, GL_SPECULAR, material);

			material[0] *= 3.0;
			material[1] *= 3.0;
			material[2] *= 3.0;
			glMaterialfv(GL_FRONT, GL_DIFFUSE, material);

		} else {
			glColor3ub( r,  g,  b );
		}
	} else {
		if (white_flag){
			ovec = MAP_ENTRY(DM_WHITE);
			glIndexi(ovec);
		} else if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
			glIndexi(nvec);
			ovec = nvec;
		}

		if (((struct ogl_vars *)dm_vars)->mvars.lighting_on){
			material[0] = ovec - CMAP_RAMP_WIDTH + 2;
			material[1] = ovec - CMAP_RAMP_WIDTH/2;
			material[2] = ovec - 1;
			glMaterialfv(GL_FRONT, GL_COLOR_INDEXES, material);
		}
	}


	/* Viewing region is from -1.0 to +1.0 */
	first = 1;
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					glEnd();
				first = 0;
				glBegin(GL_LINE_STRIP);
				glVertex3dv( *pt );
				break;
			case RT_VLIST_LINE_DRAW:
				/* Draw line */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					glEnd();
				glBegin(GL_POLYGON);
				/* Set surface normal (vl_pnt points outward) */
				VMOVE( gtvec, *pt );
				glNormal3fv(gtvec);
				break;
			case RT_VLIST_POLY_MOVE:
				/* Polygon Move */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_DRAW:
				/* Polygon Draw */
				glVertex3dv( *pt );
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				glVertex3dv( *pt );
				glEnd();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				VMOVE( gtvec, *pt );
				glNormal3fv(gtvec);
				break;
			}
		}
	}
	if( first == 0 ) glEnd();

	if (sp->s_soldash)
		glDisable(GL_LINE_STIPPLE);	/* restore solid lines */

	if (white_flag && ((struct ogl_vars *)dm_vars)->mvars.cueing_on){
		glEnable(GL_FOG);
	}

	return(1);	/* OK */

}

/*
 *			O G L _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
Ogl2_normal()
{
	GLint mm; 

	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl2_normal\n", (char *)NULL);

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		glColor3ub( 0,  0,  0 );
	} else {
		ovec = MAP_ENTRY(DM_BLACK);
		glIndexi( ovec );
	}

	if (!((struct ogl_vars *)dm_vars)->face_flag){
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
		glLoadMatrixd( ((struct ogl_vars *)dm_vars)->faceplate_mat );
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glLoadIdentity();
		((struct ogl_vars *)dm_vars)->face_flag = 1;
		if(((struct ogl_vars *)dm_vars)->mvars.cueing_on)
			glDisable(GL_FOG);
		if (((struct ogl_vars *)dm_vars)->mvars.lighting_on)
			glDisable(GL_LIGHTING);

	}

	return;
}

/*
 *			O G L _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
void
Ogl2_update()
{
  if (((struct ogl_vars *)dm_vars)->mvars.debug)
    Tcl_AppendResult(interp, "Ogl2_update()\n", (char *)NULL);

    XFlush(dpy);
}


/*
 *			XOGL _ P U T S
 *
 * Output a string.
 * The starting position of the beam is as specified.
 */
void
Ogl2_puts( str, x, y, size, colour )
register char *str;
int x,y,size, colour;
{
	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl2_puts()\n", (char *)NULL);

	
/*	glRasterPos2f( GED2IRIS(x),  GED2IRIS(y));*/
	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		glColor3ub( (short)ogl_rgbtab[colour].r,  (short)ogl_rgbtab[colour].g,  (short)ogl_rgbtab[colour].b );
	} else {
		ovec = MAP_ENTRY(colour);
		glIndexi( ovec );
	}


/*	glRasterPos2i( x,  y);*/
	glRasterPos2f( GED2IRIS(x),  GED2IRIS(y));
	glListBase(fontOffset);
	glCallLists(strlen( str ), GL_UNSIGNED_BYTE,  str );
}


/*
 *			O G L _ 2 D _ L I N E
 *
 */
void
Ogl2_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	register int nvec;

	if (((struct ogl_vars *)dm_vars)->mvars.debug)
	  Tcl_AppendResult(interp, "Ogl2_2d_line()\n", (char *)NULL);

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		/* Yellow */

		glColor3ub( (short)255,  (short)255,  (short) 0 );
	} else {
		if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
			glIndexi(nvec);
			ovec = nvec;
		}
	}
	
/*	glColor3ub( (short)255,  (short)255,  (short) 0 );*/

	if(((struct ogl_vars *)dm_vars)->mvars.debug){
	  GLfloat pmat[16];
	  struct rt_vls tmp_vls;

	  rt_vls_init(&tmp_vls);
	  glGetFloatv(GL_PROJECTION_MATRIX, pmat);
	  rt_vls_printf(&tmp_vls, "projection matrix:\n");
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
	  glGetFloatv(GL_MODELVIEW_MATRIX, pmat);
	  rt_vls_printf(&tmp_vls, "modelview matrix:\n");
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
	  rt_vls_printf(&tmp_vls, "%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);

	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
	}

	if( dashed )
		glEnable(GL_LINE_STIPPLE);
		
	glBegin(GL_LINES); 
	 glVertex2f( GED2IRIS(x1),  GED2IRIS(y1));
	 glVertex2f( GED2IRIS(x2),  GED2IRIS(y2));
	glEnd();

	if( dashed )		/* restore solid */
		glDisable(GL_LINE_STIPPLE); 


}

#define Ogl2_NUM_SLID	7
#define Ogl2_XSLEW	0
#define Ogl2_YSLEW	1
#define Ogl2_ZSLEW	2
#define Ogl2_ZOOM	3
#define Ogl2_XROT	4
#define Ogl2_YROT	5
#define Ogl2_ZROT	6

static int
Ogl2_doevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  static int button0  = 0;   /*  State of button 0 */
  static int knobs_during_help[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  static int knob_values[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  register struct dm_list *save_dm_list;
  register struct dm_list *p;
  struct rt_vls cmd;
  int status = CMD_OK;

  rt_vls_init(&cmd);
  save_dm_list = curr_dm_list;

  curr_dm_list = get_dm_list(eventPtr->xany.window);

  if(curr_dm_list == DM_LIST_NULL)
    goto end;

  if(mged_variables.send_key && eventPtr->type == KeyPress){
    char buffer[1];
    KeySym keysym;

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  &keysym, (XComposeStatus *)NULL);

    if(keysym == mged_variables.hot_key)
      goto end;

    write(dm_pipe[1], buffer, 1);
    rt_vls_free(&cmd);
    curr_dm_list = save_dm_list;

    /* Use this so that these events won't propagate */
    return TCL_RETURN;
  }

  if ( eventPtr->type == Expose && eventPtr->xexpose.count == 0 ) {
#if 0
    Ogl2_configure_window_shape();
#else
    glClearColor(0.0, 0.0, 0.0, 0.0);
    if (((struct ogl_vars *)dm_vars)->mvars.zbuf)
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    else
       glClear(GL_COLOR_BUFFER_BIT);
#endif

    dirty = 1;
    refresh();
    goto end;
  } else if( eventPtr->type == ConfigureNotify ) {
    Ogl2_configure_window_shape();

    dirty = 1;
    refresh();
    goto end;
  } else if( eventPtr->type == MotionNotify ) {
    int mx, my;

    if( !OgldoMotion &&
	(VIRTUAL_TRACKBALL_NOT_ACTIVE(struct ogl_vars *, mvars.virtual_trackball)) )
      goto end;

    mx = eventPtr->xmotion.x;
    my = eventPtr->xmotion.y;

    switch(((struct ogl_vars *)dm_vars)->mvars.virtual_trackball){
    case VIRTUAL_TRACKBALL_OFF:
    case VIRTUAL_TRACKBALL_ON:
      /* do the regular thing */
      /* Constant tracking (e.g. illuminate mode) bound to M mouse */
      rt_vls_printf( &cmd, "M 0 %d %d\n",
		     (mx/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 4095,
		     (0.5 - my/(double)((struct ogl_vars *)dm_vars)->height) * 4095);
      break;
    case VIRTUAL_TRACKBALL_ROTATE:
      rt_vls_printf( &cmd, "irot %f %f 0\n", (my - omy)/2.0,
		     (mx - omx)/2.0);
      break;
    case VIRTUAL_TRACKBALL_TRANSLATE:
      rt_vls_printf( &cmd, "tran %f %f %f\n",
		     (mx/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 2,
		     (0.5 - my/(double)((struct ogl_vars *)dm_vars)->height) * 2, tran_z);
      break;
    case VIRTUAL_TRACKBALL_ZOOM:
      rt_vls_printf( &cmd, "zoom %lf\n",
		     (omy - my)/(double)((struct ogl_vars *)dm_vars)->height + 1.0);
      break;
    }

    omx = mx;
    omy = my;
  }else if( eventPtr->type == devmotionnotify ){
    XDeviceMotionEvent *M;
    int setting;

    M = (XDeviceMotionEvent * ) eventPtr;

    if(button0){
      ogl_dbtext(
		(adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
      goto end;
    }

    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
    setting = irlimit(knobs[M->first_axis]);
    knob_values[M->first_axis] = M->axis_data[0];

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(adcflag) {
	rt_vls_printf( &cmd, "knob ang1 %d\n",
		      setting );
      }
      break;
    case DIAL1:
      rt_vls_printf( &cmd , "knob S %f\n",
		    setting / 2048.0 );
      break;
    case DIAL2:
      if(adcflag)
	rt_vls_printf( &cmd , "knob ang2 %d\n",
		      setting );
      else
	rt_vls_printf( &cmd , "knob z %f\n",
		      setting / 2048.0 );
      break;
    case DIAL3:
      if(adcflag)
	rt_vls_printf( &cmd , "knob distadc %d\n",
		      setting );
      else
	rt_vls_printf( &cmd , "knob Z %f\n",
		      setting / 2048.0 );
      break;
    case DIAL4:
      if(adcflag)
	rt_vls_printf( &cmd , "knob yadc %d\n",
		      setting );
      else
	rt_vls_printf( &cmd , "knob y %f\n",
		      setting / 2048.0 );
      break;
    case DIAL5:
      rt_vls_printf( &cmd , "knob Y %f\n",
		    setting / 2048.0 );
      break;
    case DIAL6:
      if(adcflag)
	rt_vls_printf( &cmd , "knob xadc %d\n",
		      setting );
      else
	rt_vls_printf( &cmd , "knob x %f\n",
		      setting / 2048.0 );
      break;
    case DIAL7:
      rt_vls_printf( &cmd , "knob X %f\n",
		    setting / 2048.0 );
      break;
    default:
      break;
    }

  }else if( eventPtr->type == devbuttonpress ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      button0 = 1;
      goto end;
    }

    if(button0){
      ogl_dbtext(label_button(bmap[B->button - 1]));
    }else if(B->button == 4){
      rt_vls_strcat(&cmd, "knob zero\n");
      set_knob_offset();
    }else
      rt_vls_printf(&cmd, "press %s\n",
		    label_button(bmap[B->button - 1]));
  }else if( eventPtr->type == devbuttonrelease ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1)
      button0 = 0;

    goto end;
  }else
    goto end;

  status = cmdline(&cmd, FALSE);
end:
  rt_vls_free(&cmd);
  curr_dm_list = save_dm_list;

  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
}
	    
/*
 *			O G L _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 *
 * DEPRECATED 
 *
 */
/* ARGSUSED */
void
Ogl2_input( input, noblock )
fd_set		*input;
int		noblock;
{
    return;
}

/* 
 *			O G L _ L I G H T
 */
/* ARGSUSED */
void
Ogl2_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	return;
}

/* ARGSUSED */
unsigned
Ogl2_cvtvecs( sp )
struct solid *sp;
{
	return( 0 );
}

/*
 * Loads displaylist
 */
unsigned
Ogl2_load( addr, count )
unsigned addr, count;
{
  rt_log("Ogl2_load(x%x, %d.)\n", addr, count );
  return( 0 );
}

void
Ogl2_statechange( a, b )
int	a, b;
{
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( b )  {
	case ST_VIEW:
	    /* constant tracking OFF */
	    OgldoMotion = 0;
	    break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	case ST_S_VPICK:
	    /* constant tracking ON */
	    OgldoMotion = 1;
	    break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	    /* constant tracking OFF */
	    OgldoMotion = 0;
	    break;
	default:
	  Tcl_AppendResult(interp, "Ogl2_statechange: unknown state ",
			   state_str[b], "\n", (char *)NULL);
	  break;
	}

	/*Ogl2_viewchange( DM_CHGV_REDO, SOLID_NULL );*/
}

void
Ogl2_viewchange()
{
}

void
Ogl2_colorchange()
{
	register int i;
	register int nramp;
	XColor celltest;
	int count = 0;
	Colormap a_cmap;

	if( ((struct ogl_vars *)dm_vars)->mvars.debug )
	  Tcl_AppendResult(interp, "colorchange\n", (char *)NULL);

	/* Program the builtin colors */
	ogl_rgbtab[0].r=0; 
	ogl_rgbtab[0].g=0; 
	ogl_rgbtab[0].b=0;/* Black */
	ogl_rgbtab[1].r=255; 
	ogl_rgbtab[1].g=0; 
	ogl_rgbtab[1].b=0;/* Red */
	ogl_rgbtab[2].r=0; 
	ogl_rgbtab[2].g=0; 
	ogl_rgbtab[2].b=255;/* Blue */
	ogl_rgbtab[3].r=255; 
	ogl_rgbtab[3].g=255;
	ogl_rgbtab[3].b=0;/*Yellow */
	ogl_rgbtab[4].r = ogl_rgbtab[4].g = ogl_rgbtab[4].b = 255; /* White */
	slotsused = 5;

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  {
		if(((struct ogl_vars *)dm_vars)->mvars.cueing_on) {
			glEnable(GL_FOG);
		} else {
			glDisable(GL_FOG);
		}

		glColor3ub( (short)255,  (short)255,  (short)255 );

		/* apply region-id based colors to the solid table */
		color_soltab();

		return;
	}

	if(USE_RAMP && (ogl_index_size < 7)) {
	  Tcl_AppendResult(interp, "Too few bitplanes: depthcueing and lighting disabled\n",
			   (char *)NULL);
	  ((struct ogl_vars *)dm_vars)->mvars.cueing_on = 0;
	  ((struct ogl_vars *)dm_vars)->mvars.lighting_on = 0;
	}
	/* number of slots is 2^indexsize */
	ogl_nslots = 1<<ogl_index_size;
	if( ogl_nslots > NSLOTS )  ogl_nslots = NSLOTS;
	if(USE_RAMP) {
		/* peel off reserved ones */
		ogl_nslots = (ogl_nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
	} else {
		ogl_nslots -= CMAP_BASE;	/* peel off the reserved entries */
	}

	ovec = -1;	/* Invalidate the old colormap entry */

	/* apply region-id based colors to the solid table */
	color_soltab();

	/* best to do this before the colorit */
	if (((struct ogl_vars *)dm_vars)->mvars.cueing_on && ((struct ogl_vars *)dm_vars)->mvars.lighting_on){
		((struct ogl_vars *)dm_vars)->mvars.lighting_on = 0;
		glDisable(GL_LIGHTING);
	}

	/* Map the colors in the solid table to colormap indices */
	Ogl2_colorit();

	for( i=0; i < slotsused; i++ )  {
		Ogl2_gen_color( i, ogl_rgbtab[i].r, ogl_rgbtab[i].g, ogl_rgbtab[i].b);
	}

	/* best to do this after the colorit */
	if (((struct ogl_vars *)dm_vars)->mvars.cueing_on){
		glEnable(GL_FOG);
	} else {
		glDisable(GL_FOG);
	}

	ovec = MAP_ENTRY(DM_WHITE);
	glIndexi( ovec );

}

/* ARGSUSED */
void
Ogl2_debug(lvl)
{
  ((struct ogl_vars *)dm_vars)->mvars.debug = lvl;
  XFlush(dpy);
  Tcl_AppendResult(interp, "flushed\n", (char *)NULL);
}

void
Ogl2_window(w)
register int w[];
{
}

/* the font used depends on the size of the window opened */
#define FONTBACK	"-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1"
#define FONT5	"5x7"
#define FONT6	"6x10"
#define FONT7	"7x13"
#define FONT8	"8x13"
#define FONT9	"9x15"

static int
Ogl2_setup( name )
char	*name;
{
  static count = 0;
  char *cp, symbol;
  XGCValues gcv;
  XColor a_color;
  Visual *a_visual;
  int a_screen, num, i, success;
  int major, minor;
  Colormap  a_cmap;
  XVisualInfo *vip;
  int dsize, use, dbfr, rgba, red, blue, green, alpha, index;
  GLfloat backgnd[4];
  long supplied;
  int j, k;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  struct rt_vls str;
  Display *tmp_dpy;

  rt_vls_init(&str);

  /* Only need to do this once */
  if(tkwin == NULL){
    rt_vls_printf(&str, "loadtk %s\n", name);

    if(cmdline(&str, FALSE) == CMD_BAD){
      rt_vls_free(&str);
      return -1;
    }
  }

  /* Only need to do this once for this display manager */
  if(!count){
    if( Ogl2_load_startup() ){
      rt_vls_free(&str);
      return -1;
    }
  }

  if(RT_LIST_IS_EMPTY(&head_ogl_vars.l))
    Tk_CreateGenericHandler(Ogl2_doevent, (ClientData)NULL);

  RT_LIST_APPEND(&head_ogl_vars.l, &((struct ogl_vars *)curr_dm_list->_dm_vars)->l);

  rt_vls_printf(&pathName, ".dm_ogl%d", count++);

  /* this is important so that Ogl2_configure_notify knows to set
   * the font */
  fontstruct = NULL;

  if((tmp_dpy = XOpenDisplay(name)) == NULL){
    rt_vls_free(&str);
    return -1;
  }

  ((struct ogl_vars *)dm_vars)->width = DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  ((struct ogl_vars *)dm_vars)->height = DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;

  /* Make window square */
  if(((struct ogl_vars *)dm_vars)->height < ((struct ogl_vars *)dm_vars)->width)
    ((struct ogl_vars *)dm_vars)->width = ((struct ogl_vars *)dm_vars)->height;
  else
    ((struct ogl_vars *)dm_vars)->height = ((struct ogl_vars *)dm_vars)->width;

  XCloseDisplay(tmp_dpy);

  /* Make xtkwin a toplevel window */
  xtkwin = Tk_CreateWindowFromPath(interp, tkwin, rt_vls_addr(&pathName), name);

  /* Open the display - XXX see what NULL does now */
  if( xtkwin == NULL ) {
    Tcl_AppendResult(interp, "dm-ogl2: Failed to open ", rt_vls_addr(&pathName),
		     "\n", (char *)NULL);
    return -1;
  }

  rt_vls_strcpy(&str, "init_ogl ");
  rt_vls_printf(&str, "%s\n", rt_vls_addr(&pathName));

  if(cmdline(&str, FALSE) == CMD_BAD){
    rt_vls_free(&str);
    return -1;
  }

  dpy = Tk_Display(xtkwin);

  /* must do this before MakeExist */
  if ((vip=Ogl2_set_visual(xtkwin))==NULL){
    Tcl_AppendResult(interp, "Ogl2_open: Can't get an appropriate visual.\n", (char *)NULL);
    return -1;
  }

  Tk_GeometryRequest(xtkwin, ((struct ogl_vars *)dm_vars)->width, ((struct ogl_vars *)dm_vars)->height);
  Tk_MoveToplevelWindow(xtkwin, 1276 - 976, 0);
  Tk_MakeWindowExist(xtkwin);

  win = Tk_WindowId(xtkwin);

  a_screen = Tk_ScreenNumber(xtkwin);

  /* open GLX context */
  /* If the sgi display manager has been used, then we must use
   * an indirect context. Otherwise use direct, since it is usually
   * faster.
   */
  if ((glxc = glXCreateContext(dpy, vip, 0, ogl_sgi_used ? GL_FALSE : GL_TRUE))==NULL) {
    Tcl_AppendResult(interp, "Ogl2_open: couldn't create glXContext.\n", (char *)NULL);
    return -1;
  }
  /* If we used an indirect context, then as far as sgi is concerned,
   * gl hasn't been used.
   */
  ogl_is_direct = (char) glXIsDirect(dpy, glxc);
  Tcl_AppendResult(interp, "Using ", ogl_is_direct ? "a direct" : "an indirect",
		   " OpenGL rendering context.\n", (char *)NULL);
  /* set ogl_ogl_used if the context was ever direct */
  ogl_ogl_used = (ogl_is_direct || ogl_ogl_used);

  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  olist = list = (XDeviceInfoPtr) XListInputDevices (dpy, &ndevices);

  /* IRIX 4.0.5 bug workaround */
  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(dpy, list->id)) == (XDevice *)NULL){
	  Tcl_AppendResult(interp, "Glx_open: Couldn't open the dials+buttons\n", (char *)NULL);
	  goto Done;
	}

	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
	  case ButtonClass:
	    DeviceButtonPress(dev, devbuttonpress, e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, devbuttonrelease, e_class[nclass]);
	    ++nclass;
	    break;
	  case ValuatorClass:
	    DeviceMotionNotify(dev, devmotionnotify, e_class[nclass]);
	    ++nclass;
	    break;
	  default:
	    break;
	  }
	}

	XSelectExtensionEvent(dpy, win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);

#if 0
  /* Register the file descriptor with the Tk event handler */
  Tk_CreateGenericHandler(Ogl2_doevent, (ClientData)curr_dm_list);
#endif

#if 0
  Tk_SetWindowBackground(xtkwin, bg);
#endif

  if (!glXMakeCurrent(dpy, win, glxc)){
    Tcl_AppendResult(interp, "Ogl2_open: Couldn't make context current\n", (char *)NULL);
    return -1;
  }

  /* display list (fontOffset + char) will displays a given ASCII char */
  if ((fontOffset = glGenLists(128))==0){
    Tcl_AppendResult(interp, "dm-ogl: Can't make display lists for font.\n", (char *)NULL);
    return -1;
  }

  Tk_MapWindow(xtkwin);

  /* do viewport, ortho commands and initialize font*/
  Ogl2_configure_window_shape();

  /* Lines will be solid when stippling disabled, dashed when enabled*/
  glLineStipple( 1, 0xCF33);
  glDisable(GL_LINE_STIPPLE);

  backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
  glFogi(GL_FOG_MODE, GL_LINEAR);
  glFogf(GL_FOG_START, 0.0);
  glFogf(GL_FOG_END, 2.0);
  if (((struct ogl_vars *)dm_vars)->mvars.rgb)
    glFogfv(GL_FOG_COLOR, backgnd);
  else
    glFogi(GL_FOG_INDEX, CMAP_RAMP_WIDTH - 1);
  glFogf(GL_FOG_DENSITY, VIEWFACTOR);
	

  /* Initialize matrices */
  /* Leave it in model_view mode normally */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 2.0);
  glGetDoublev(GL_PROJECTION_MATRIX, ((struct ogl_vars *)dm_vars)->faceplate_mat);
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity(); 
  glTranslatef( 0.0, 0.0, -1.0); 
  glPushMatrix();
  glLoadIdentity();
  ((struct ogl_vars *)dm_vars)->face_flag = 1;	/* faceplate matrix is on top of stack */
		
  return 0;
}

/* currently, get a double buffered rgba visual that works with Tk and
 * OpenGL
 */
XVisualInfo *
Ogl2_set_visual(tkwin)
Tk_Window tkwin;
{
	XVisualInfo *vip, vitemp, *vibase, *maxvip;
	int good[40];
	int num, i, j;
	int use, rgba, dbfr, stereo;
	int m_stereo, m_double, m_rgba;
	int tries, baddepth;

	/* m_stereo - try to get stereo 
	 * m_double - try to get double buffered
	 * m_rgba  - try to get rgb
	 */

	if( mged_variables.eye_sep_dist )  {
		m_stereo = 1;
	} else {
		m_stereo = 0;
	}

	m_double = 1;
	m_rgba = 1;
	
	/* Try to satisfy the above desires with a color visual of the
	 * greatest depth */

	vibase = XGetVisualInfo(dpy, 0,	&vitemp, &num);

	while (1) {
		for (i=0, j=0, vip=vibase; i<num; i++, vip++){
			/* requirements */
			glXGetConfig(dpy,vip, GLX_USE_GL, &use);
			if (!use)
				continue;
			/* desires */
			if (m_rgba){
				glXGetConfig(dpy, vip, GLX_RGBA, &rgba);
				if (!rgba)
					continue;
			} else if (vip->class != PseudoColor) {
				/* if index mode, accept only read/write*/
				continue;
			}
			if ( m_stereo ) {
				glXGetConfig(dpy, vip, GLX_STEREO, &stereo);
				if (!stereo)
					continue;
			}
			if (m_double ) {
				glXGetConfig(dpy, vip, GLX_DOUBLEBUFFER,&dbfr);
				if (!dbfr)
					continue;
			}
			
			/* this visual meets criteria */
			good[j++] = i;
		}

		/* j = number of acceptable visuals under consideration */
		if (j >= 1){
			baddepth = 1000;
			tries = 0;
			while (tries < j) {
				maxvip = vibase + good[0];
				for (i=1; i<j; i++) {
					vip = vibase + good[i];
					if ((vip->depth > maxvip->depth)&&(vip->depth < baddepth)){
						maxvip = vip;
					}
				}

				/* make sure Tk handles it */
				if (maxvip->class == PseudoColor)
					((struct ogl_vars *)dm_vars)->cmap = XCreateColormap(dpy,
						RootWindow(dpy, maxvip->screen),
						maxvip->visual, AllocAll);
				else
					((struct ogl_vars *)dm_vars)->cmap = XCreateColormap(dpy,
						RootWindow(dpy, maxvip->screen),
						maxvip->visual, AllocNone);

				if (Tk_SetWindowVisual(tkwin, maxvip->visual, maxvip->depth, ((struct ogl_vars *)dm_vars)->cmap)){
					((struct ogl_vars *)dm_vars)->mvars.doublebuffer = m_double;
					glXGetConfig(dpy, maxvip, GLX_DEPTH_SIZE, &((struct ogl_vars *)dm_vars)->mvars.depth);
					if (((struct ogl_vars *)dm_vars)->mvars.depth > 0)
						((struct ogl_vars *)dm_vars)->mvars.zbuf = 1;
					((struct ogl_vars *)dm_vars)->mvars.rgb = m_rgba;
					if (!m_rgba){
						glXGetConfig(dpy, maxvip, GLX_BUFFER_SIZE, &ogl_index_size);
					}
					stereo_is_on = m_stereo;
					return (maxvip); /* sucess */
				} else { 
					/* retry with lesser depth */
					baddepth = maxvip->depth;
					tries ++;
					XFreeColormap(dpy,((struct ogl_vars *)dm_vars)->cmap);
				}
			}
					
		}
				

		/* if no success at this point, relax a desire and try again */
		if ( m_stereo ){
		  m_stereo = 0;
		  Tcl_AppendResult(interp, "Stereo not available.\n", (char *)NULL);
		} else if (m_rgba) {
		  m_rgba = 0;
		  Tcl_AppendResult(interp, "RGBA not available.\n", (char *)NULL);
		} else if (m_double) {
		  m_double = 0;
		  Tcl_AppendResult(interp, "Doublebuffering not available. \n", (char *)NULL);
		} else {
			return(NULL); /* failure */
		}
	}
}

/* 
 *			O G L _ C O N F I G U R E _ W I N D O W _ S H A P E
 *
 *  Either initially, or on resize/reshape of the window,
 *  sense the actual size of the window, and perform any
 *  other initializations of the window configuration.
 *
 * also change font size if necessary
 */
void
Ogl2_configure_window_shape()
{
	int		npix;
	GLint mm; 
	XWindowAttributes xwa;
	XFontStruct	*newfontstruct;

	XGetWindowAttributes( dpy, win, &xwa );
	((struct ogl_vars *)dm_vars)->height = xwa.height;
	((struct ogl_vars *)dm_vars)->width = xwa.width;
	
	glViewport(0,  0, (((struct ogl_vars *)dm_vars)->width), (((struct ogl_vars *)dm_vars)->height));
	glScissor(0,  0, (((struct ogl_vars *)dm_vars)->width)+1, (((struct ogl_vars *)dm_vars)->height)+1);

	if( ((struct ogl_vars *)dm_vars)->mvars.zbuffer_on )
	  establish_zbuffer();

	establish_lighting();

#if 0
	glDrawBuffer(GL_FRONT_AND_BACK);

	glClearColor(0.0, 0.0, 0.0, 0.0);
	if (((struct ogl_vars *)dm_vars)->mvars.zbuffer_on)
		glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	else
		glClear( GL_COLOR_BUFFER_BIT);

	if (((struct ogl_vars *)dm_vars)->mvars.doublebuffer)
		glDrawBuffer(GL_BACK);
	else
		glDrawBuffer(GL_FRONT);

	/*CJXX*/
	glFlush();
#endif
	/*CJXX this might cause problems in perspective mode? */
	glGetIntegerv(GL_MATRIX_MODE, &mm);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho( -xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0 );
	glMatrixMode(mm);
	aspect = (fastf_t)((struct ogl_vars *)dm_vars)->height/
	  (fastf_t)((struct ogl_vars *)dm_vars)->width;


	/* First time through, load a font or quit */
	if (fontstruct == NULL) {
	  if ((fontstruct = XLoadQueryFont(dpy, FONT9)) == NULL ) {
	    /* Try hardcoded backup font */
	    if ((fontstruct = XLoadQueryFont(dpy, FONTBACK)) == NULL) {
	      Tcl_AppendResult(interp, "dm-ogl2: Can't open font '", FONT9,
			       "' or '", FONTBACK, "'\n", (char *)NULL);
	      return;
	    }
	  }
	  glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
	}
		

	/* Always try to choose a the font that best fits the window size.
	 */

	if (((struct ogl_vars *)dm_vars)->width < 582) {
		if (fontstruct->per_char->width != 5) {
			if ((newfontstruct = XLoadQueryFont(dpy, FONT5)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	} else if (((struct ogl_vars *)dm_vars)->width < 679) {
		if (fontstruct->per_char->width != 6){
			if ((newfontstruct = XLoadQueryFont(dpy, FONT6)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	} else if (((struct ogl_vars *)dm_vars)->width < 776) {
		if (fontstruct->per_char->width != 7){
			if ((newfontstruct = XLoadQueryFont(dpy, FONT7)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	} else if (((struct ogl_vars *)dm_vars)->width < 873) {
		if (fontstruct->per_char->width != 8){
			if ((newfontstruct = XLoadQueryFont(dpy, FONT8)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	} else {
		if (fontstruct->per_char->width != 9){
			if ((newfontstruct = XLoadQueryFont(dpy, FONT9)) != NULL ) {
				XFreeFont(dpy,fontstruct);
				fontstruct = newfontstruct;
				glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
			}
		}
	}

	
}

/*
 *			O G L _ D M
 * 
 *  Implement display-manager specific commands, from MGED "dm" command.
 */
int
Ogl2_dm(argc, argv)
int	argc;
char	**argv;
{
  struct rt_vls	vls;
  int status;
  char *av[4];
  char xstr[32];
  char ystr[32];
  char zstr[32];

  if( !strcmp( argv[0], "set" ) )  {
    struct rt_vls tmp_vls;

    rt_vls_init(&vls);
    rt_vls_init(&tmp_vls);
    start_catching_output(&tmp_vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      rt_structprint("dm_ogl internal variables", Ogl2_vparse, (CONST char *)&((struct ogl_vars *)dm_vars)->mvars );
      rt_log("%s", rt_vls_addr(&vls) );
    } else if( argc == 2 ) {
      rt_vls_name_print( &vls, Ogl2_vparse, argv[1], (CONST char *)&((struct ogl_vars *)dm_vars)->mvars );
      rt_log( "%s\n", rt_vls_addr(&vls) );
    } else {
      rt_vls_printf( &vls, "%s=\"", argv[1] );
      rt_vls_from_argv( &vls, argc-2, argv+2 );
      rt_vls_putc( &vls, '\"' );
      rt_structparse( &vls, Ogl2_vparse, (char *)&((struct ogl_vars *)dm_vars)->mvars );
    }

    rt_vls_free(&vls);

    stop_catching_output(&tmp_vls);
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
    return TCL_OK;
  }

  if( !strcmp( argv[0], "mouse" )){
    if( argc < 4){
      Tcl_AppendResult(interp, "dm: need more parameters\n",
		       "mouse 1|0 xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

#if 0
    sprintf(xstr, "%d", irisX2ged(atoi(argv[2])));
    sprintf(ystr, "%d", irisY2ged(atoi(argv[3])));

    av[0] = "M";
    av[1] = argv[1];
    av[2] = xstr;
    av[3] = ystr;
    return f_mouse((ClientData)NULL, interp, 4, av);
#else
    rt_vls_init(&vls);
    rt_vls_printf(&vls, "M %s %d %d\n", argv[1],
		  irisX2ged(atoi(argv[2])), irisY2ged(atoi(argv[3])));
    status = cmdline(&vls, FALSE);
    rt_vls_free(&vls);

    if(status == CMD_OK)
      return TCL_OK;

    return TCL_ERROR;
#endif
  }

  status = TCL_OK;
  if(((struct ogl_vars *)dm_vars)->mvars.virtual_trackball){
    if( !strcmp( argv[0], "vtb" )){
      int buttonpress;

      if( argc < 5){
	Tcl_AppendResult(interp, "dm: need more parameters\n",
			 "vtb <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }

      buttonpress = atoi(argv[2]);
      omx = atoi(argv[3]);
      omy = atoi(argv[4]);

      if(buttonpress){
	switch(*argv[1]){
	case 'r':
	  ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ROTATE;
	  break;
	case 't':
	  ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_TRANSLATE;

	  sprintf(xstr, "%f", (omx/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - omy/(double)((struct ogl_vars *)dm_vars)->height) * 2);
	  sprintf(zstr, "%f", tran_z);
	  av[0] = "tran";
	  av[1] = xstr;
	  av[2] = ystr;
	  av[3] = zstr;
	  status = f_tran((ClientData)NULL, interp, 4, av);
	  
	  break;
	case 'z':
	  ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ZOOM;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm: need more parameters\n",
			   "vtb <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
	}
      }else{
	((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ON;
    }

    return status;
    }
  }else{
    return status;
  }

  Tcl_AppendResult(interp, "dm: bad command - ", argv[0], "\n", (char *)NULL);
  return TCL_ERROR;
}

void	
establish_lighting()
{


	if (!((struct ogl_vars *)dm_vars)->mvars.lighting_on) {
		/* Turn it off */
		glDisable(GL_LIGHTING);
		if (!((struct ogl_vars *)dm_vars)->mvars.rgb)
			Ogl2_colorchange();
	} else {
		/* Turn it on */

		if (!((struct ogl_vars *)dm_vars)->mvars.rgb){
			if (((struct ogl_vars *)dm_vars)->mvars.cueing_on){
				((struct ogl_vars *)dm_vars)->mvars.cueing_on = 0;
				glDisable(GL_FOG);
			} 
			Ogl2_colorchange();
		}

		glLightModelfv(GL_LIGHT_MODEL_AMBIENT, amb_three);
		glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);

		/* light positions specified in Ogl2_newrot */

		glLightfv(GL_LIGHT0, GL_SPECULAR, light0_diffuse);
		glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
		glLightfv(GL_LIGHT1, GL_SPECULAR, light1_diffuse);
		glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
		glLightfv(GL_LIGHT2, GL_SPECULAR, light2_diffuse);
		glLightfv(GL_LIGHT2, GL_DIFFUSE, light2_diffuse);
		glLightfv(GL_LIGHT3, GL_SPECULAR, light3_diffuse);
		glLightfv(GL_LIGHT3, GL_DIFFUSE, light3_diffuse);

		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
		glEnable(GL_LIGHT1);
		glEnable(GL_LIGHT3);
		glEnable(GL_LIGHT2);
	}
	dmaflag = 1;
}	


static void	
establish_zbuffer()
{
	if( ((struct ogl_vars *)dm_vars)->mvars.zbuf == 0 ) {
	  Tcl_AppendResult(interp, "dm-ogl2: This machine has no Zbuffer to enable\n",
			   (char *)NULL);
	  ((struct ogl_vars *)dm_vars)->mvars.zbuffer_on = 0;
	}

	if (((struct ogl_vars *)dm_vars)->mvars.zbuffer_on)  {
		glEnable(GL_DEPTH_TEST);
	} else {
		glDisable(GL_DEPTH_TEST);
	}
	dmaflag = 1;
	
	return;
}

static void
establish_perspective()
{
  rt_vls_printf( &dm_values.dv_string,
		 "set perspective %d\n",
		 ((struct ogl_vars *)dm_vars)->mvars.perspective_mode ?
		 perspective_table[perspective_angle] :
		 -1 );
  dmaflag = 1;
}

/*
  This routine will toggle the perspective_angle if the
  dummy_perspective value is 0 or less. Otherwise, the
  perspective_angle is set to the value of (dummy_perspective - 1).
*/
static void
set_perspective()
{
  /* set perspective matrix */
  if(((struct ogl_vars *)dm_vars)->mvars.dummy_perspective > 0)
    perspective_angle = ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective <= 4 ? ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective - 1: 3;
  else if (--perspective_angle < 0) /* toggle perspective matrix */
    perspective_angle = 3;

  if(((struct ogl_vars *)dm_vars)->mvars.perspective_mode)
    rt_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[perspective_angle] );

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective = 1;

  dmaflag = 1;
}


static void
establish_vtb()
{
  return;
}

static void
Ogl2_colorit()
{
	register struct solid	*sp;
	register struct rgbtab *rgb;
	register int i;
	register int r,g,b;

	if( ((struct ogl_vars *)dm_vars)->mvars.rgb )  return;

	FOR_ALL_SOLIDS( sp )  {
		r = sp->s_color[0];
		g = sp->s_color[1];
		b = sp->s_color[2];
		if( (r == 255 && g == 255 && b == 255) ||
		    (r == 0 && g == 0 && b == 0) )  {
			sp->s_dmindex = DM_WHITE;
			continue;
		}

		/* First, see if this matches an existing color map entry */
		rgb = ogl_rgbtab;
		for( i = 0; i < slotsused; i++, rgb++ )  {
			if( rgb->r == r && rgb->g == g && rgb->b == b )  {
				sp->s_dmindex = i;
				goto next;
			}
		}

		/* If slots left, create a new color map entry, first-come basis */
		if( slotsused < ogl_nslots )  {
			rgb = &ogl_rgbtab[i=(slotsused++)];
			rgb->r = r;
			rgb->g = g;
			rgb->b = b;
			sp->s_dmindex = i;
			continue;
		}
		sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		
		;
	}
}


#if IR_KNOBS
ogl_dbtext(str)
{
  Tcl_AppendResult(interp, "dm-ogl: You pressed Help key and '",
		   str, "'\n", (char *)NULL);
}
/*
 *			I R L I M I T
 *
 * Because the dials are so sensitive, setting them exactly to
 * zero is very difficult.  This function can be used to extend the
 * location of "zero" into "the dead zone".
 */
static 
int irlimit(i)
int i;
{
	if( i > NOISE )
		return( i-NOISE );
	if( i < -NOISE )
		return( i+NOISE );
	return(0);
}
#endif

/*			G E N _ C O L O R
 *
 *	maps a given color into the appropriate colormap entry
 *	for both depthcued and non-depthcued mode.  In depthcued mode,
 *	Ogl2_gen_color also generates the colormap ramps.  Note that in depthcued
 *	mode, DM_BLACK uses map entry 0, and does not generate a ramp for it.
 *	Non depthcued mode skips the first CMAP_BASE colormap entries.
 *
 *	This routine is not called at all if ((struct ogl_vars *)dm_vars)->mvars.rgb is set.
 */
void
Ogl2_gen_color(c)
int c;
{
	if(USE_RAMP) {

		/*  Not much sense in making a ramp for DM_BLACK.  Besides
		 *  which, doing so, would overwrite the bottom color
		 *  map entries, which is a no-no.
		 */
		if( c != DM_BLACK) {
			register int i, j;
			fastf_t r_inc, g_inc, b_inc;
			fastf_t red, green, blue;
			XColor cells[CMAP_RAMP_WIDTH];

			red = r_inc = ogl_rgbtab[c].r * (256/CMAP_RAMP_WIDTH);
			green = g_inc = ogl_rgbtab[c].g * (256/CMAP_RAMP_WIDTH);
			blue = b_inc = ogl_rgbtab[c].b * (256/CMAP_RAMP_WIDTH);

#if 0
			red = ogl_rgbtab[c].r * 256;
			green = ogl_rgbtab[c].g * 256;
			blue = ogl_rgbtab[c].b * 256;
#endif
			

			if (((struct ogl_vars *)dm_vars)->mvars.cueing_on){
				for(i = 0, j = MAP_ENTRY(c) + CMAP_RAMP_WIDTH - 1; 
					i < CMAP_RAMP_WIDTH;
				    i++, j--, red += r_inc, green += g_inc, blue += b_inc){
				    	cells[i].pixel = j;
				    	cells[i].red = (short)red;
				    	cells[i].green = (short)green;
				    	cells[i].blue = (short)blue;
				    	cells[i].flags = DoRed|DoGreen|DoBlue;
				}
			} else { /* ((struct ogl_vars *)dm_vars)->mvars.lighting_on */ 
				for(i = 0, j = MAP_ENTRY(c) - CMAP_RAMP_WIDTH + 1; 
					i < CMAP_RAMP_WIDTH;
				    i++, j++, red += r_inc, green += g_inc, blue += b_inc){
				    	cells[i].pixel = j;
				    	cells[i].red = (short)red;
				    	cells[i].green = (short)green;
				    	cells[i].blue = (short)blue;
				    	cells[i].flags = DoRed|DoGreen|DoBlue;
				    }
			}
			XStoreColors(dpy, ((struct ogl_vars *)dm_vars)->cmap, cells, CMAP_RAMP_WIDTH);
		}
	} else {
		XColor cell, celltest;

		cell.pixel = c + CMAP_BASE;
		cell.red = ogl_rgbtab[c].r * 256;
		cell.green = ogl_rgbtab[c].g * 256;
		cell.blue = ogl_rgbtab[c].b * 256;
		cell.flags = DoRed|DoGreen|DoBlue;
		XStoreColor(dpy, ((struct ogl_vars *)dm_vars)->cmap, &cell);

	}
}

static void
print_cmap()
{
	int i;
	XColor cell;

	for (i=0; i<112; i++){
		cell.pixel = i;
		XQueryColor(dpy, ((struct ogl_vars *)dm_vars)->cmap, &cell);
		printf("%d  = %d %d %d\n",i,cell.red,cell.green,cell.blue);
	}
}

static void
set_knob_offset()
{
  int i;

  for(i = 0; i < 8; ++i){
#if 0
    knobs_offset[i] = knobs[i];
#else
    knobs[i] = 0;
#endif
  }
}

static void
ogl_var_init()
{
  dm_vars = (char *)rt_malloc(sizeof(struct ogl_vars),
					    "ogl_var_init: glx_vars");
  bzero((void *)dm_vars, sizeof(struct ogl_vars));
  devmotionnotify = LASTEvent;
  devbuttonpress = LASTEvent;
  devbuttonrelease = LASTEvent;
  ((struct ogl_vars *)dm_vars)->dm_list = curr_dm_list;
  perspective_angle = 3;
  aspect = 1.0;
  ovec = -1;

  /* initialize the modifiable variables */
  ((struct ogl_vars *)dm_vars)->mvars.cueing_on = 1;          /* Depth cueing flag - for colormap work */
  ((struct ogl_vars *)dm_vars)->mvars.zclipping_on = 1;       /* Z Clipping flag */
  ((struct ogl_vars *)dm_vars)->mvars.zbuffer_on = 1;         /* Hardware Z buffer is on */
  ((struct ogl_vars *)dm_vars)->mvars.linewidth = 1;      /* Line drawing width */
  ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective = 1;
  ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = 1;
  ((struct ogl_vars *)dm_vars)->mvars.fastfog = 1;
  ((struct ogl_vars *)dm_vars)->mvars.fogdensity = 1.0;
}

static struct dm_list *
get_dm_list(window)
Window window;
{
  register struct ogl_vars *p;

  for( RT_LIST_FOR(p, ogl_vars, &head_ogl_vars.l) ){
    if(window == p->_win){
      if (!glXMakeCurrent(p->_dpy, p->_win, p->_glxc)){
	return DM_LIST_NULL;
      }

      return p->dm_list;
    }
  }

  return DM_LIST_NULL;
}
@


1.10
log
@still tcl-converting
@
text
@@


1.9
log
@convert commands to Tcl
@
text
@d1036 1
a1036 3
#if 0
    dmaflag = 1;
#else
a1037 1
#endif
d1042 1
a1042 3
#if 0
    dmaflag = 1;
#else
a1043 1
#endif
a1059 3
      mx = (mx/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 4095;
      my = (0.5 - my/(double)((struct ogl_vars *)dm_vars)->height) * 4095;

d1061 3
a1063 1
      rt_vls_printf( &cmd, "M 0 %d %d\n", mx, my );
d1178 4
a1181 1
  }
d1266 1
@


1.8
log
@modified the open routine to accommodate new attach command
@
text
@a363 13
#if 1
Ogl2_open(name)
char *name;
{
  ogl_var_init();
  rt_vls_init(&pathName);

  if( Ogl2_setup(name) )
    return(1);		/* BAD */

  return(0);			/* OK */
}
#else
a365 5
  char	line[82];
  char	hostname[80];
  char	display[82];
  char	*envp;

a366 1
  rt_vls_init(&pathName);
d368 1
a368 24
  /* get or create the default display */
  if( (envp = getenv("DISPLAY")) == NULL ) {
    /* Env not set, use local host */
    gethostname( hostname, 80 );
    hostname[79] = '\0';
    (void)sprintf( display, "%s:0", hostname );
    envp = display;
  }

  rt_log("X Display [%s]? ", envp );
  (void)fgets( line, sizeof(line), stdin );
  line[strlen(line)-1] = '\0';		/* remove newline */
  if( feof(stdin) )  quit();
  if( line[0] != '\0' ) {
    if( Ogl2_setup(line) ) {
      return(1);		/* BAD */
    }
  } else {
    if( Ogl2_setup(envp) ) {
      return(1);	/* BAD */
    }
  }

  return(0);			/* OK */
a369 1
#endif
d430 1
a430 3
    if(Tcl_Eval( interp, ogl_init_str ) == TCL_ERROR){
      rt_log("ogl2_load_startup: Error interpreting ogl_init_str.\n");
      rt_log("%s\n", interp->result);
a431 1
    }
a438 1
    rt_log("Error reading %s: %s\n", filename, interp->result);
d455 14
a468 4
	glDrawBuffer(GL_FRONT);
	glClearColor(0.0, 0.0, 0.0, 0.0);
/*	glClearDepth(0.0);*/
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
d470 1
a470 1
	glXDestroyContext(dpy, glxc);
a471 4
	Tk_DestroyWindow(xtkwin);
	RT_LIST_DEQUEUE(&((struct ogl_vars *)dm_vars)->l);
	rt_free(dm_vars, "Ogl2_close: dm_vars");
	rt_vls_free(&pathName);
d494 1
a494 1
    rt_log( "Ogl2_prolog\n");
d497 1
a497 1
    rt_log("Ogl2_prolog: Couldn't make context current\n");
d540 2
a541 1
    rt_log( "Ogl2_epilog\n");
a559 1

d565 4
d570 2
a571 3
    rt_log("ANY ERRORS?\n");
    while(	(error = glGetError())!=0){
      rt_log("Error: %x\n", error);
d573 3
d598 1
a598 1
		rt_log( "Ogl2_newrot()\n");
d601 12
a612 6
		printf("which eye = %d\t", which_eye);
		printf("newrot matrix = \n");
		printf("%g %g %g %g\n", mat[0], mat[4], mat[8],mat[12]);
		printf("%g %g %g %g\n", mat[1], mat[5], mat[9],mat[13]);
		printf("%g %g %g %g\n", mat[2], mat[6], mat[10],mat[14]);
		printf("%g %g %g %g\n", mat[3], mat[7], mat[11],mat[15]);
d698 1
a698 2
		rt_log( "ogl2_Object()\n");

d841 1
a841 1
		rt_log( "Ogl2_normal\n");
d876 2
a877 2
	if (((struct ogl_vars *)dm_vars)->mvars.debug)
		rt_log( "Ogl2_update()\n");
d895 1
a895 1
		rt_log( "Ogl2_puts()\n");
d927 1
a927 1
		rt_log( "Ogl2_2d_line()\n");
d943 2
a944 13
		GLfloat pmat[16];
		glGetFloatv(GL_PROJECTION_MATRIX, pmat);
		printf("projection matrix:\n");
		printf("%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
		printf("%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
		printf("%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
		printf("%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
		glGetFloatv(GL_MODELVIEW_MATRIX, pmat);
		printf("modelview matrix:\n");
		printf("%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
		printf("%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
		printf("%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
		printf("%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
d946 16
d963 1
d998 1
d1096 1
a1096 1
      glx_dbtext(
d1171 1
a1171 1
      glx_dbtext(label_button(bmap[B->button - 1]));
d1187 1
a1187 1
  (void)cmdline(&cmd, FALSE);
d1192 4
a1195 1
  return TCL_OK;
d1249 2
a1250 2
	rt_log("Ogl2_load(x%x, %d.)\n", addr, count );
	return( 0 );
d1279 3
a1281 2
	    rt_log("Ogl2_statechange: unknown state %s\n", state_str[b]);
	    break;
d1301 2
a1302 1
	if( ((struct ogl_vars *)dm_vars)->mvars.debug )  rt_log("colorchange\n");
d1336 4
a1339 3
		rt_log("Too few bitplanes: depthcueing and lighting disabled\n");
		((struct ogl_vars *)dm_vars)->mvars.cueing_on = 0;
		((struct ogl_vars *)dm_vars)->mvars.lighting_on = 0;
d1385 3
a1387 3
	((struct ogl_vars *)dm_vars)->mvars.debug = lvl;
	XFlush(dpy);
	rt_log("flushed\n");
d1482 2
a1483 1
    rt_log( "dm-X: Can't open X display\n" );
a1488 1
  rt_log("pathname = %s\n", rt_vls_addr(&pathName));
d1499 1
a1499 1
    rt_log("Ogl2_open: Can't get an appropriate visual.\n");
d1517 2
a1518 2
    rt_log("Ogl2_open: couldn't create glXContext.\n");
		return -1;
d1524 2
a1525 1
  rt_log("Using %s OpenGL rendering context.\n", ogl_is_direct ? "a direct" : "an indirect");
d1543 1
a1543 1
	  rt_log("Glx_open: Couldn't open the dials+buttons\n");
d1583 1
a1583 1
    rt_log("Ogl2_open: Couldn't make context current\n");
d1589 1
a1589 1
    rt_log("dm-ogl: Can't make display lists for font.\n");
d1740 2
a1741 2
			m_stereo = 0;
			rt_log("Stereo not available.\n");
d1743 2
a1744 2
			m_rgba = 0;
			rt_log("RGBA not available.\n");
d1746 2
a1747 2
			m_double = 0;
			rt_log("Doublebuffering not available. \n");
d1812 9
a1820 8
		if ((fontstruct = XLoadQueryFont(dpy, FONT9)) == NULL ) {
			/* Try hardcoded backup font */
			if ((fontstruct = XLoadQueryFont(dpy, FONTBACK)) == NULL) {
				rt_log( "dm-ogl: Can't open font '%s' or '%s'\n", FONT9, FONTBACK );
				return;
			}
		}
		glXUseXFont( fontstruct->fid, 0, 127, fontOffset);
d1883 5
d1890 2
d1893 3
d1909 1
d1911 5
a1915 1
    return CMD_OK;
d1919 9
a1927 4
    {
      int buttonpress;
      int xpos;
      int ypos;
d1929 11
a1939 5
      if( argc < 4){
	rt_log("dm: need more parameters\n");
	rt_log("mouse 1|0 xpos ypos\n");
	return CMD_BAD;
      }
d1941 2
a1942 10
      buttonpress = atoi(argv[1]);
      xpos = atoi(argv[2]);
      ypos = atoi(argv[3]);

      rt_vls_init(&vls);
      rt_vls_printf(&vls, "M %d %d %d\n",
		    buttonpress, irisX2ged(xpos), irisY2ged(ypos));
      (void)cmdline(&vls, FALSE);
      rt_vls_free(&vls);
    }
d1944 2
a1945 1
    return CMD_OK;
d1948 1
d1950 2
a1951 2
  if( !strcmp( argv[0], "vtb" )){
    int buttonpress;
d1953 5
a1957 5
    if( argc < 5){
      rt_log("dm: need more parameters\n");
      rt_log("vtb <r|t|z> 1|0 xpos ypos\n");
      return CMD_BAD;
    }
d1959 10
a1968 11
    buttonpress = atoi(argv[2]);
    omx = atoi(argv[3]);
    omy = atoi(argv[4]);

    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ROTATE;
	break;
      case 't':
	{
a1969 18
	  rt_vls_init(&vls);
	  rt_vls_printf( &vls, "tran %f %f %f\n",
			 (omx/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 2,
			 (0.5 - omy/(double)((struct ogl_vars *)dm_vars)->height) * 2,
			 tran_z);

	  (void)cmdline(&vls, FALSE);
	  rt_vls_free(&vls);
	}
	break;
      case 'z':
	((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ZOOM;
	break;
      default:
	rt_log("dm: need more parameters\n");
	rt_log("vtb <r|t|z> 1|0 xpos ypos\n");
	return CMD_BAD;
      }
d1971 20
a1990 2
    }else{
      ((struct ogl_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ON;
d1993 2
a1994 2
    return CMD_OK;
  }
d1996 1
a1996 1
    return CMD_OK;
d1999 2
a2000 2
  rt_log("dm: bad command - %s\n", argv[0]);
  return CMD_BAD;
d2052 3
a2054 2
		rt_log("dm-ogl: This machine has no Zbuffer to enable\n");
		((struct ogl_vars *)dm_vars)->mvars.zbuffer_on = 0;
d2159 5
@


1.7
log
@cleanup
@
text
@d364 13
d412 1
@


1.6
log
@*** empty log message ***
@
text
@a0 1
#ifdef MULTI_ATTACH
a67 1
#ifdef SEND_KEY_DOWN_PIPE
a68 1
#endif
a137 1
#ifdef VIRTUAL_TRACKBALL
a139 1
#endif
a171 1
#ifdef VIRTUAL_TRACKBALL
a172 1
#endif
a185 1
#ifdef VIRTUAL_TRACKBALL
a186 1
#endif
a310 1
#ifdef VIRTUAL_TRACKBALL
a311 1
#endif
a1016 1
#ifdef SEND_KEY_DOWN_PIPE
a1033 1
#endif
a1061 1
#ifdef VIRTUAL_TRACKBALL
a1097 8
#else
	int	x, y;
	if ( !OgldoMotion )
	    return 1;
	x = (eventPtr->xmotion.x/(double)((struct ogl_vars *)dm_vars)->width - 0.5) * 4095;
	y = (0.5 - eventPtr->xmotion.y/(double)((struct ogl_vars *)dm_vars)->height) * 4095;
	rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y );
#endif
a1929 1
#ifdef VIRTUAL_TRACKBALL  
a1979 1
#endif
a2087 1
#ifdef VIRTUAL_TRACKBALL
a2092 1
#endif
a2093 1

a2287 17
#if 0
  register struct dm_list *p;

  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
    if(window == ((struct ogl_vars *)p->_dm_vars)->_win)
      if (!glXMakeCurrent(((struct ogl_vars *)p->_dm_vars)->_dpy,
			  ((struct ogl_vars *)p->_dm_vars)->_win,
			  ((struct ogl_vars *)p->_dm_vars)->_glxc)){
#if 0
	rt_log("get_dm_list: Couldn't make context current\n");
#endif
	return DM_LIST_NULL;
      }

      return p;
  }
#else
a2292 3
#if 0
	rt_log("get_dm_list: Couldn't make context current\n");
#endif
a2298 1
#endif
a2301 1
#endif
@


1.5
log
@*** empty log message ***
@
text
@d1058 1
d1060 3
d1067 1
d1069 3
@


1.4
log
@initialize a few variables
modify ogl2_newrot -- fixes axes labels
@
text
@d383 1
a503 3
#if 0
	glXMakeCurrent(dpy, None, NULL);
#endif
a1447 1
  rt_vls_init(&pathName);
d2315 1
d2317 1
d2329 1
d2331 1
@


1.3
log
@not done, just playing it safe
@
text
@a15 2
#define CJDEBUG 0

d50 1
a50 1
#if 0
a95 2
static char    ogl_is_direct = 0;

d137 1
a137 2
static int ogl2_index_size;

d155 6
d206 13
a263 1
static int ovec = -1;		/* Old color map entry number */
a266 12
/*
 * SGI Color Map table
 */
#define NSLOTS		4080	/* The mostest possible - may be fewer */
static int ogl2_nslots=0;		/* how many we have, <= NSLOTS */
static int slotsused;		/* how many actually used */
static struct rgbtab {
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
} ogl2_rgbtab[NSLOTS];

d586 1
a586 1
  glColor3ub( (short)ogl2_rgbtab[4].r, (short)ogl2_rgbtab[4].g, (short)ogl2_rgbtab[4].b );
d603 1
a603 1
  if(CJDEBUG){
d630 3
d634 1
a634 1
	if(CJDEBUG){
a642 3

	if (((struct ogl_vars *)dm_vars)->mvars.debug)
		rt_log( "Ogl2_newrot()\n");
a681 80

	/* If all the display managers end up doing this maybe it's 
	 * dozoom that has a bug */
	gtmat[2]  = -gtmat[2];
	gtmat[6]  = -gtmat[6];
	gtmat[10]  = -gtmat[10];
	gtmat[14]  = -gtmat[14];

	/* we know that mat = P*T*M
	 *	where 	P = the perspective matrix based on the
	 *			eye at the origin
	 *		T = a translation of one in the -Z direction
	 *		M = model2view matrix
	 *
	 * Therefore P = mat*M'*T'
	 * 
	 * In order for depthcueing and lighting to work correctly, 
	 * P must be stored in the GL_PROJECTION matrix and T*M must
	 * be stored the the GL_MODELVIEW matrix.
	 */
	if ( ((struct ogl_vars *)dm_vars)->mvars.perspective_mode){
		float inv_view[16];

		/* disassemble supplied matrix */

		/* convert from row-major to column-major and from double
		 * to float
		 */
		inv_view[0] = view2model[0];
		inv_view[1] = view2model[4];
		inv_view[2] = view2model[8];
		inv_view[3] = view2model[12];
		inv_view[4] = view2model[1];
		inv_view[5] = view2model[5];
		inv_view[6] = view2model[9];
		inv_view[7] = view2model[13];
		inv_view[8] = view2model[2];
		inv_view[9] = view2model[6];
		inv_view[10] = view2model[10];
		inv_view[11] = view2model[14];
		inv_view[12] = view2model[3];
		inv_view[13] = view2model[7];
		inv_view[14] = view2model[11];
		inv_view[15] = view2model[15];

		/* do P = P*T*M*M'*T' = mat*M'*T' (see explanation above) */
		glMatrixMode(GL_PROJECTION);
		glLoadMatrixf( gtmat );
		glMultMatrixf( inv_view );
		glTranslatef( 0.0, 0.0, 1.0);

	} else {
		/* Orthographic projection */
		glMatrixMode(	GL_PROJECTION);
		glLoadMatrixd( ((struct ogl_vars *)dm_vars)->faceplate_mat);

	}


	/* convert from row-major to column-major and from double
	 * to float
	 */
	view[0] = model2view[0];
	view[1] = model2view[4];
	view[2] = model2view[8];
	view[3] = model2view[12];
	view[4] = model2view[1];
	view[5] = model2view[5];
	view[6] = model2view[9];
	view[7] = model2view[13];
	view[8] = model2view[2];
	view[9] = model2view[6];
	view[10] = model2view[10];
	view[11] = model2view[14];
	view[12] = model2view[3];
	view[13] = model2view[7];
	view[14] = model2view[11];
	view[15] = model2view[15];

	/* do T*M (see above explanation) */
d685 1
a685 1
	glMultMatrixf( view );
a686 1

a694 15


	if(CJDEBUG){
		GLfloat pmat[16];
		int mode;

		glGetIntegerv(GL_MATRIX_MODE, &mode);
		printf("matrix mode %s\n", (mode==GL_MODELVIEW) ? "modelview" : "projection");
		glGetFloatv(GL_MODELVIEW_MATRIX, pmat);
		printf("%g %g %g %g\n", pmat[0], pmat[4], pmat[8],pmat[12]);
		printf("%g %g %g %g\n", pmat[1], pmat[5], pmat[9],pmat[13]);
		printf("%g %g %g %g\n", pmat[2], pmat[6], pmat[10],pmat[14]);
		printf("%g %g %g %g\n", pmat[3], pmat[7], pmat[11],pmat[15]);
	}

d929 1
a929 1
		glColor3ub( (short)ogl2_rgbtab[colour].r,  (short)ogl2_rgbtab[colour].g,  (short)ogl2_rgbtab[colour].b );
d971 1
a971 1
	if(CJDEBUG){
d974 1
a974 1
		printf("projection matrix:");
d980 1
a980 1
		printf("modelview matrix:");
d1051 1
d1053 7
a1113 3
#if 1
  }
#else
a1210 1
#endif
d1325 13
a1337 13
	ogl2_rgbtab[0].r=0; 
	ogl2_rgbtab[0].g=0; 
	ogl2_rgbtab[0].b=0;/* Black */
	ogl2_rgbtab[1].r=255; 
	ogl2_rgbtab[1].g=0; 
	ogl2_rgbtab[1].b=0;/* Red */
	ogl2_rgbtab[2].r=0; 
	ogl2_rgbtab[2].g=0; 
	ogl2_rgbtab[2].b=255;/* Blue */
	ogl2_rgbtab[3].r=255; 
	ogl2_rgbtab[3].g=255;
	ogl2_rgbtab[3].b=0;/*Yellow */
	ogl2_rgbtab[4].r = ogl2_rgbtab[4].g = ogl2_rgbtab[4].b = 255; /* White */
d1355 1
a1355 1
	if(USE_RAMP && (ogl2_index_size < 7)) {
d1361 2
a1362 2
	ogl2_nslots = 1<<ogl2_index_size;
	if( ogl2_nslots > NSLOTS )  ogl2_nslots = NSLOTS;
d1365 1
a1365 1
		ogl2_nslots = (ogl2_nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
d1367 1
a1367 1
		ogl2_nslots -= CMAP_BASE;	/* peel off the reserved entries */
d1385 1
a1385 1
		Ogl2_gen_color( i, ogl2_rgbtab[i].r, ogl2_rgbtab[i].g, ogl2_rgbtab[i].b);
d1742 1
a1742 1
						glXGetConfig(dpy, maxvip, GLX_BUFFER_SIZE, &ogl2_index_size);
d1825 2
d2137 1
a2137 1
		rgb = ogl2_rgbtab;
d2146 2
a2147 2
		if( slotsused < ogl2_nslots )  {
			rgb = &ogl2_rgbtab[i=(slotsused++)];
d2207 3
a2209 3
			red = r_inc = ogl2_rgbtab[c].r * (256/CMAP_RAMP_WIDTH);
			green = g_inc = ogl2_rgbtab[c].g * (256/CMAP_RAMP_WIDTH);
			blue = b_inc = ogl2_rgbtab[c].b * (256/CMAP_RAMP_WIDTH);
d2212 3
a2214 3
			red = ogl2_rgbtab[c].r * 256;
			green = ogl2_rgbtab[c].g * 256;
			blue = ogl2_rgbtab[c].b * 256;
d2245 3
a2247 3
		cell.red = ogl2_rgbtab[c].r * 256;
		cell.green = ogl2_rgbtab[c].g * 256;
		cell.blue = ogl2_rgbtab[c].b * 256;
d2292 2
d2302 2
@


1.2
log
@*** empty log message ***
@
text
@d52 1
d54 1
d91 1
a91 1
static void     Ogl_var_init();
d98 1
a98 8
/* Flags indicating whether the gl and sgi display managers have been
 * attached. 
 * These are necessary to decide whether or not to use direct rendering
 * with gl.
 */
char	ogl2_ogl_used = 0;
char	ogl2_sgi_used = 0;
char	ogl2_is_direct = 0;
a141 1
static Colormap cmap;
a142 3
static GLdouble faceplate_mat[16];
static int ogl2_face_flag;		/* 1: faceplate matrix on stack */

d182 2
d187 3
d247 1
d381 1
a381 1
  Ogl_var_init();
d422 5
d469 1
a469 1
      rt_log("Glx_load_startup: Error interpreting glx_init_str.\n");
d502 1
d504 1
a504 1

a506 1
	Tk_DeleteGenericHandler(Ogl2_doevent, (ClientData)NULL);
d508 1
d511 6
d536 1
a536 1
    rt_log("Ogl2_open: Couldn't make context current\n");
d540 4
d550 1
a550 1
  if (ogl2_face_flag){
d555 1
a555 1
    ogl2_face_flag = 0;
d735 1
a735 1
		glLoadMatrixd( faceplate_mat);
d974 1
a974 1
	if (!ogl2_face_flag){
d977 1
a977 1
		glLoadMatrixd( faceplate_mat );
d981 1
a981 1
		ogl2_face_flag = 1;
d1030 1
d1128 1
d1131 4
a1134 1
		  (KeySym *)NULL, (XComposeStatus *)NULL);
d1145 1
a1145 10
  if (eventPtr->type == Expose && eventPtr->xexpose.count == 0) {
#if 0
    glClearColor(0.0, 0.0, 0.0, 0.0);
    if (((struct ogl_vars *)dm_vars)->mvars.zbuffer_on)
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    else
      glClear(GL_COLOR_BUFFER_BIT);
    rt_vls_printf( &dm_values.dv_string, "refresh\n" );
    dmaflag = 1;
#else
d1150 1
a1150 2
#endif
  } else if( eventPtr->type == ConfigureNotify) {
d1201 3
d1301 1
d1561 5
d1627 1
a1627 1
  if ((glxc = glXCreateContext(dpy, vip, 0, ogl2_sgi_used ? GL_FALSE : GL_TRUE))==NULL) {
d1634 4
a1637 4
  ogl2_is_direct = (char) glXIsDirect(dpy, glxc);
  rt_log("Using %s OpenGL rendering context.\n", ogl2_is_direct ? "a direct" : "an indirect");
  /* set ogl2_ogl_used if the context was ever direct */
  ogl2_ogl_used = (ogl2_is_direct || ogl2_ogl_used);
d1683 1
d1685 2
a1686 1
  Tk_CreateGenericHandler(Ogl2_doevent, (ClientData)NULL);
d1728 1
a1728 1
  glGetDoublev(GL_PROJECTION_MATRIX, faceplate_mat);
d1735 1
a1735 1
  ogl2_face_flag = 1;	/* faceplate matrix is on top of stack */
d1818 1
a1818 1
					cmap = XCreateColormap(dpy,
d1822 1
a1822 1
					cmap = XCreateColormap(dpy,
d1826 1
a1826 1
				if (Tk_SetWindowVisual(tkwin, maxvip->visual, maxvip->depth, cmap)){
d1841 1
a1841 1
					XFreeColormap(dpy,cmap);
d2328 1
a2328 1
			XStoreColors(dpy, cmap, cells, CMAP_RAMP_WIDTH);
d2338 1
a2338 1
		XStoreColor(dpy, cmap, &cell);
d2351 1
a2351 1
		XQueryColor(dpy, cmap, &cell);
a2370 17
Ogl_var_init()
{
  dm_vars = (char *)rt_malloc(sizeof(struct ogl_vars), "Ogl_var_init: ogl_vars");
  bzero((void *)dm_vars, sizeof(struct ogl_vars));
  devmotionnotify = LASTEvent;
  devbuttonpress = LASTEvent;
  devbuttonrelease = LASTEvent;

  /* initialize the modifiable variables */
  ((struct ogl_vars *)dm_vars)->mvars.cueing_on = 1;          /* Depth cueing flag - for colormap work */
  ((struct ogl_vars *)dm_vars)->mvars.zclipping_on = 1;       /* Z Clipping flag */
  ((struct ogl_vars *)dm_vars)->mvars.zbuffer_on = 1;         /* Hardware Z buffer is on */
  ((struct ogl_vars *)dm_vars)->mvars.linewidth = 1;      /* Line drawing width */
  ((struct ogl_vars *)dm_vars)->mvars.dummy_perspective = 1;
}

static void
d2379 2
d2388 1
d2395 1
a2396 1
  struct rt_vls str;
d2403 1
a2403 1
	rt_log("Ogl2_open: Couldn't make context current\n");
d2409 14
@


1.1
log
@Initial revision
@
text
@d45 2
d51 2
d76 6
d83 1
d87 1
d89 6
a94 1
static struct dm_list *get_dm_list()
d123 1
a123 1
struct dm dm_ogl = {
d139 1
a139 1
	"gl", "X Windows with OpenGL graphics",
a148 2
static XVisualInfo *Ogl2_set_visual();

a154 2
#define width (((struct ogl_vars *)dm_vars)->_width)
#define height (((struct ogl_vars *)dm_vars)->_height)
a165 1
#define _fontstruct (((struct ogl_vars *)dm_vars)->_fontstruct)
d167 1
a168 1
#define mvars (((struct ogl_vars *)dm_vars)->_mvars)
d180 1
d206 1
a207 1
  GLXContext _glxc;
d209 41
a249 2
  struct modifiable_ogl_vars _mvars;
}
a250 2
static int	ogl2_fd;			/* GL file descriptor to select() on */
static CONST char ogl2_title[] = "BRL MGED";
a253 1
static int kblights();
a256 2
void		ogl2_colorit();

a270 5
extern void sl_toggle_scroll();		/* from scroll.c */

static void	establish_lighting();
static void	establish_zbuffer();

a284 3
void print_cmap();


d294 1
a294 1
	glLineWidth((GLfloat) ogl2_linewidth);
d302 1
a302 1
	glHint(GL_FOG_HINT, mvars.fastfog ? GL_FASTEST : GL_NICEST);
d307 1
a307 1
structparse ogl2_vparse[] = {
d313 2
a314 2
	{"%d",  1, "set_perspective",OGL2_MV_O(dummy_perspective),  set_perspective },
	{"%d",  1, "has_zbuf",		OGL2_MV_O(zbuf),	establish_zbuffer },
d317 1
d321 1
a321 1
	{"%d",  1, "density",		OGL2_MV_O(fogdensity),	refresh_hook },
d338 2
a339 2
#define	GED_TO_Xx(x)	(((x)/4096.0+0.5)*width)
#define	GED_TO_Xy(x)	((0.5-(x)/4096.0)*height)
d342 1
a342 1
#define USE_RAMP	(mvars.cueing_on || mvars.lighting_on)
d351 18
d384 1
a384 1
  Ogl2_var_init();
d504 1
a504 1
	Tk_DeleteGenericHandler(Ogldoevent, (ClientData)NULL);
d506 2
d518 7
a524 35
	GLint mm; 
	char i;
	char *str = "a";
	GLfloat fogdepth;

	if (mvars.debug)
		rt_log( "Ogl2_prolog\n");

	if (dmaflag) {
		if (!mvars.doublebuffer){
			glClearColor(0.0, 0.0, 0.0, 0.0);
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
/*			return;*/
		}

		if (ogl2_face_flag){
			glMatrixMode(GL_PROJECTION);
			glPopMatrix();
			glMatrixMode(GL_MODELVIEW);
			glPopMatrix();
			ogl2_face_flag = 0;
			if (mvars.cueing_on){
				glEnable(GL_FOG);
				fogdepth = 2.2 * Viewscale; /* 2.2 is heuristic */
				glFogf(GL_FOG_END, fogdepth);
				fogdepth = (GLfloat) (0.5*mvars.fogdensity/Viewscale);
				glFogf(GL_FOG_DENSITY, fogdepth);
				glFogi(GL_FOG_MODE, mvars.perspective_mode ? GL_EXP : GL_LINEAR);
			}
			if (mvars.lighting_on){
				glEnable(GL_LIGHTING);
			}
		}
	
		glLineWidth((GLfloat) ogl2_linewidth);
d526 4
a529 1
	}
d531 5
d537 20
d565 6
a570 6
	if (mvars.debug)
		rt_log( "Ogl2_epilog\n");
	/*
	 * A Point, in the Center of the Screen.
	 * This is drawn last, to always come out on top.
	 */
d572 12
a583 12
	glColor3ub( (short)ogl2_rgbtab[4].r, (short)ogl2_rgbtab[4].g, (short)ogl2_rgbtab[4].b );
	glBegin(GL_POINTS);
	 glVertex2i(0,0);
	glEnd();
	/* end of faceplate */

	if(mvars.doublebuffer )
	{
		glXSwapBuffers(dpy, win);
		/* give Graphics pipe time to work */
		glClearColor(0.0, 0.0, 0.0, 0.0);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
a584 1
	}
d586 2
d589 2
a590 2
	/* Prevent lag between events and updates */
	XSync(dpy, 0);
d592 5
a596 9
	if(CJDEBUG){
		int error;

		rt_log("ANY ERRORS?\n");
		while(	(error = glGetError())!=0){
			rt_log("Error: %x\n", error);
		}
	}

d598 1
a598 1
	return;
d627 1
a627 1
	if (mvars.debug)
d688 1
a688 1
	if ( mvars.perspective_mode){
d755 1
a755 1
	if (mvars.lighting_on ){
d807 1
a807 1
	if (mvars.debug)
d823 1
a823 1
	if (white_flag && mvars.cueing_on)
d826 1
a826 1
	if( mvars.rgb )  {
d836 1
a836 1
		if(mvars.lighting_on)
d865 1
a865 1
		if (mvars.lighting_on){
d931 1
a931 1
	if (white_flag && mvars.cueing_on){
d951 1
a951 1
	if (mvars.debug)
d954 1
a954 1
	if( mvars.rgb )  {
d969 1
a969 1
		if(mvars.cueing_on)
d971 1
a971 1
		if (mvars.lighting_on)
d987 1
a987 1
	if (mvars.debug)
d1005 1
a1005 1
	if (mvars.debug)
d1010 1
a1010 1
	if( mvars.rgb )  {
d1036 1
a1036 1
	if (mvars.debug)
d1039 1
a1039 1
	if( mvars.rgb )  {
d1091 2
a1092 2
int
Ogldoevent(clientData, eventPtr)
d1096 90
a1185 23
    KeySym key;
    char keybuf[4];
    int cnt;
	float inc;
    XComposeStatus compose_stat;
	static int ogl2_which_slid = Ogl2_XSLEW;

    if (eventPtr->xany.window != win)
	return 0;

    if (eventPtr->type == Expose ) {
	if (eventPtr->xexpose.count == 0) {
		glClearColor(0.0, 0.0, 0.0, 0.0);
		if (mvars.zbuffer_on)
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		else
			glClear(GL_COLOR_BUFFER_BIT);
	    rt_vls_printf( &dm_values.dv_string, "refresh\n" );
		dmaflag = 1;
	}
    } else if( eventPtr->type == ConfigureNotify) {
    	Ogl2_configure_window_shape();
    } else if( eventPtr->type == MotionNotify ) {
d1189 2
a1190 2
	x = (eventPtr->xmotion.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xmotion.y/(double)height) * 4095;
d1192 71
a1262 42
    } else if( eventPtr->type == ButtonPress ) {
	/* There may also be ButtonRelease events */
	int	x, y;
	/* In MGED this is a "penpress" */
	x = (eventPtr->xbutton.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xbutton.y/(double)height) * 4095;
	switch( eventPtr->xbutton.button ) {
	case Button1:
	    /* Left mouse: Zoom out */
	    rt_vls_printf( &dm_values.dv_string, "L 1 %d %d\n", x, y);
	    break;
	case Button2:
	    /* Middle mouse, up to down transition */
	    rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n", x, y);
	    break;
	case Button3:
	    /* Right mouse: Zoom in */
	    rt_vls_printf( &dm_values.dv_string, "R 1 %d %d\n", x, y);
	    break;
	}
    } else if( eventPtr->type == ButtonRelease ) {
	int	x, y;
	x = (eventPtr->xbutton.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xbutton.y/(double)height) * 4095;
	switch( eventPtr->xbutton.button ) {
	case Button1:
	    rt_vls_printf( &dm_values.dv_string, "L 0 %d %d\n", x, y);
	    break;
	case Button2:
	    /* Middle mouse, down to up transition */
	    rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y);
	    break;
	case Button3:
	    rt_vls_printf( &dm_values.dv_string, "R 0 %d %d\n", x, y);
	    break;
	}
    } else if( eventPtr->type == KeyPress ) {
	register int i;
	/* Turn these into MGED "buttonpress" or knob functions */
	
	cnt = XLookupString(&eventPtr->xkey, keybuf, sizeof(keybuf),
			    &key, &compose_stat);
d1264 2
a1265 2
    	/* CJXX I think the following line is bad in X.c*/
/*	for(i=0 ; i < cnt ; i++){*/
d1267 1
a1267 200
	inc = 0.1;		
	switch( key ) {
	case '?':
		rt_log( "\n\t\tKey Help Menu:\n\
\n\tView Control Functions\n\
0, <F12>	Zero sliders (knobs)\n\
s		Toggle sliders\n\
x		Enable xrot slider\n\
y		Enable yrot slider\n\
z		Enable zrot slider\n\
X		Enable Xslew slider\n\
Y		Enable Yslew slider\n\
Z		Enable Zslew slider\n\
S		Enable Zoom (Scale) slider\n\
<Up Arrow>	Enable slider above the current slider\n\
<Down Arrow>	Enable slider below the current slider\n\
<Left Arrow>	Move enabled slider to the left (decrement)\n\
<Right Arrow>	Move enabled slider to the right (increment)\n\
f		Front view\n\
t		Top view\n\
b		Bottom view\n\
l		Left view\n\
r		Right view\n\
R		Rear view\n\
3		35,25 view\n\
4		45,45 view\n\
\n\tToggle Functions\n\
<F1>		Toggle depthcueing\n\
<F2>		Toggle zclipping\n\
<F3>		Toggle perspective\n\
<F4>		Toggle zbuffer status\n\
<F5>		Toggle smooth-shading\n\
<F6>		Change perspective angle\n\
<F7>,F		Toggle faceplate\n\
" );
		break;
	case 'w':
		print_cmap();
		break;
	case '0':
		rt_vls_printf( &dm_values.dv_string, "knob zero\n" );
		break;
	case 's':
		sl_toggle_scroll(); /* calls rt_vls_printf() */
		break;
	case 'S':
		ogl2_which_slid = Ogl2_ZOOM;
		break;
	case 'x':
		/* 6 degrees per unit */
		ogl2_which_slid = Ogl2_XROT;
		break;
	case 'y':
		ogl2_which_slid = Ogl2_YROT;
		break;
	case 'z':
		ogl2_which_slid = Ogl2_ZROT;
		break;
	case 'X':
		ogl2_which_slid = Ogl2_XSLEW;
		break;
	case 'Y':
		ogl2_which_slid = Ogl2_YSLEW;
		break;
	case 'Z':
		ogl2_which_slid = Ogl2_ZSLEW;
		break;
	case 'f':
		rt_vls_strcat( &dm_values.dv_string, "press front\n");
		break;
	case 't':
		rt_vls_strcat( &dm_values.dv_string, "press top\n");
		break;
	case 'b':
		rt_vls_strcat( &dm_values.dv_string, "press bottom\n");
		break;
	case 'l':
		rt_vls_strcat( &dm_values.dv_string, "press left\n");
		break;
	case 'r':
		rt_vls_strcat( &dm_values.dv_string, "press right\n");
		break;
	case 'R':
		rt_vls_strcat( &dm_values.dv_string, "press rear\n");
		break;
	case '3':
		rt_vls_strcat( &dm_values.dv_string, "press 35,25\n");
		break;
	case '4':
		rt_vls_strcat( &dm_values.dv_string, "press 45,45\n");
		break;
	case 'F':
		no_faceplate = !no_faceplate;
		rt_vls_strcat( &dm_values.dv_string,
			      no_faceplate ?
			      "set faceplate 0\n" :
			      "set faceplate 1\n" );
		break;
	case XK_F1:			/* F1 key */
	    	rt_log("F1 botton!\n");
		rt_vls_printf( &dm_values.dv_string,
				"dm set depthcue !\n");
		break;
	case XK_F2:			/* F2 key */
		rt_vls_printf(&dm_values.dv_string,
				"dm set zclip !\n");
		break;
	case XK_F3:			/* F3 key */
		mvars.perspective_mode = 1-mvars.perspective_mode;
		rt_vls_printf( &dm_values.dv_string,
			    "set perspective %d\n",
			    mvars.perspective_mode ?
			    perspective_table[perspective_angle] :
			    -1 );
		dmaflag = 1;
		break;
	case XK_F4:			/* F4 key */
		/* toggle zbuffer status */
		rt_vls_printf(&dm_values.dv_string,
				"dm set zbuffer !\n");
		break;
	case XK_F5:			/* F5 key */
		/* toggle status */
		rt_vls_printf(&dm_values.dv_string,
		    "dm set lighting !\n");
	    	break;
	case XK_F6:			/* F6 key */
		/* toggle perspective matrix */
		if (--perspective_angle < 0) perspective_angle = 3;
		if(mvars.perspective_mode) rt_vls_printf( &dm_values.dv_string,
			    "set perspective %d\n",
			    perspective_table[perspective_angle] );
		dmaflag = 1;
		break;
	case XK_F7:			/* F7 key */
		/* Toggle faceplate on/off */
		no_faceplate = !no_faceplate;
		rt_vls_strcat( &dm_values.dv_string,
				    no_faceplate ?
				    "set faceplate 0\n" :
				    "set faceplate 1\n" );
		Ogl2_configure_window_shape();
		dmaflag = 1;
		break;
	case XK_F12:			/* F12 key */
		rt_vls_printf( &dm_values.dv_string, "knob zero\n" );
		break;
	case XK_Up:
	    	if (ogl2_which_slid-- == 0)
	    		ogl2_which_slid = ogl2_NUM_SLID - 1;
		break;
	case XK_Down:
	    	if (ogl2_which_slid++ == ogl2_NUM_SLID - 1)
	    		ogl2_which_slid = 0;
		break;
	case XK_Left:
	    	/* set inc and fall through */
	    	inc = -0.1;
	case XK_Right:
	    	/* keep value of inc set at top of switch */
	    	switch(ogl2_which_slid){
	    	case Ogl2_XSLEW:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob X %f\n", rate_slew[X] + inc);
	    		break;
	    	case Ogl2_YSLEW:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob Y %f\n", rate_slew[Y] + inc);
	    		break;
	    	case Ogl2_ZSLEW:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob Z %f\n", rate_slew[Z] + inc);
	    		break;
	    	case Ogl2_ZOOM:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob S %f\n", rate_zoom + inc);
	    		break;
	    	case Ogl2_XROT:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob x %f\n", rate_rotate[X] + inc);
	    		break;
	    	case Ogl2_YROT:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob y %f\n", rate_rotate[Y] + inc);
	    		break;
	    	case Ogl2_ZROT:
	    		rt_vls_printf( &dm_values.dv_string, 
				"knob z %f\n", rate_rotate[Z] + inc);
	    		break;
	    	default:
	    		break;
	    	}
		break;
	case XK_Shift_L:
	case XK_Shift_R:
		break;
	default:
		rt_log("dm-ogl: The key '%c' is not defined. Press '?' for help.\n", key);
		break;
	    }
d1269 3
a1271 3
/*	}  for loop */
    } else {
	return 1;
d1274 23
a1296 1
    return 1;
d1401 1
a1401 1
	if( mvars.debug )  rt_log("colorchange\n");
d1419 2
a1420 2
	if( mvars.rgb )  {
		if(mvars.cueing_on) {
d1436 2
a1437 2
		mvars.cueing_on = 0;
		mvars.lighting_on = 0;
d1455 2
a1456 2
	if (mvars.cueing_on && mvars.lighting_on){
		mvars.lighting_on = 0;
d1468 1
a1468 1
	if (mvars.cueing_on){
d1483 1
a1483 1
	mvars.debug = lvl;
d1518 1
d1560 2
a1561 4
  ((struct ogl_vars *)dm_vars)->width =
      DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  ((struct ogl_vars *)dm_vars)->height =
      DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
d1597 1
a1597 1
  Tk_GeometryRequest(xtkwin, width, height);
d1619 2
a1620 2
  /* set ogl2_Ogl2_used if the context was ever direct */
  ogl2_Ogl2_used = (ogl2_is_direct || ogl2_Ogl2_used);
d1663 1
d1667 1
a1667 1
  Tk_CreateGenericHandler(Ogldoevent, (ClientData)NULL);
d1697 1
a1697 1
  if (mvars.rgb)
d1808 5
a1812 5
					mvars.doublebuffer = m_double;
					glXGetConfig(dpy, maxvip, GLX_DEPTH_SIZE, &ogl2_depth_size);
					if (ogl2_depth_size > 0)
						ogl2_has_zbuf = 1;
					mvars.rgb = m_rgba;
d1863 2
a1864 2
	height = xwa.height;
	width = xwa.width;
d1866 2
a1867 2
	glViewport(0,  0, (width), (height));
	glScissor(0,  0, (width)+1, (height)+1);
d1869 1
a1869 1
	if( mvars.zbuffer_on )
d1878 1
a1878 1
	if (mvars.zbuffer_on)
d1883 1
a1883 1
	if (mvars.doublebuffer)
d1915 1
a1915 1
	if (width < 582) {
d1923 1
a1923 1
	} else if (width < 679) {
d1931 1
a1931 1
	} else if (width < 776) {
d1939 1
a1939 1
	} else if (width < 873) {
d1970 92
a2061 1
	struct rt_vls	vls;
d2063 6
a2068 1
	if( argc < 1 )  return -1;
d2070 2
a2071 22
	/* For now, only "set" command is implemented */
	if( strcmp( argv[0], "set" ) != 0 )  {
		rt_log("dm: command is not 'set'\n");
		return CMD_BAD;
	}

	rt_vls_init(&vls);
	if( argc < 2 )  {
		/* Bare set command, print out current settings */
		rt_structprint("dm_ogl internal variables", ogl2_vparse, (char *)0 );
		rt_log("%s", rt_vls_addr(&vls) );
	} else if( argc == 2 ) {
	        rt_vls_name_print( &vls, ogl2_vparse, argv[1], (char *)0 );
		rt_log( "%s\n", rt_vls_addr(&vls) );
  	} else {
	        rt_vls_printf( &vls, "%s=\"", argv[1] );
	        rt_vls_from_argv( &vls, argc-2, argv+2 );
		rt_vls_putc( &vls, '\"' );
		rt_structparse( &vls, ogl2_vparse, (char *)0 );
	}
	rt_vls_free(&vls);
	return CMD_OK;
d2079 1
a2079 1
	if (!mvars.lighting_on) {
d2082 1
a2082 1
		if (!mvars.rgb)
d2087 3
a2089 3
		if (!mvars.rgb){
			if (mvars.cueing_on){
				mvars.cueing_on = 0;
d2119 1
a2119 1
void	
d2122 1
a2122 1
	if( ogl2_has_zbuf == 0 ) {
d2124 1
a2124 1
		mvars.zbuffer_on = 0;
d2127 1
a2127 1
	if (mvars.zbuffer_on)  {
d2137 48
d2186 1
a2186 1
void
d2194 1
a2194 1
	if( mvars.rgb )  return;
d2231 20
d2259 1
a2259 1
 *	This routine is not called at all if mvars.rgb is set.
d2288 1
a2288 1
			if (mvars.cueing_on){
d2298 1
a2298 1
			} else { /* mvars.lighting_on */ 
d2324 1
a2324 1
void
d2338 14
d2354 1
a2354 1
  dm_vars = (char *)rt_malloc(sizeof(struct ogl_vars), Ogl_var_init: "ogl_vars");
d2361 5
a2365 5
  mvars.cueing_on = 1;          /* Depth cueing flag - for colormap work */
  mvars.zclipping_on = 1;       /* Z Clipping flag */
  mvars.zbuffer_on = 1;         /* Hardware Z buffer is on */
  mvars.linewidth = 1;      /* Line drawing width */
  mvars.dummy_perspective = 1;
d2368 17
d2395 7
@
