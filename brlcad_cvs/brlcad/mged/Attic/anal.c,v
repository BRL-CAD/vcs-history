head	11.26;
access;
symbols
	ansi-20040405-merged:11.22.2.3
	postmerge-20040405-ansi:11.24
	premerge-20040404-ansi:11.23
	postmerge-autoconf:11.23
	autoconf-freeze:11.22.10.2
	premerge-autoconf:11.23
	postmerge-20040315-windows:11.23
	premerge-20040315-windows:11.23
	windows-20040315-freeze:11.22.4.1
	autoconf-20031203:11.22
	autoconf-20031202:11.22
	autoconf-branch:11.22.0.10
	phong-branch:11.22.0.8
	photonmap-branch:11.22.0.6
	rel-6-1-DP:11.22
	windows-branch:11.22.0.4
	rel-6-0-2:11.20
	ansi-branch:11.22.0.2
	rel-6-0-1-branch:11.20.0.2
	hartley-6-0-post:11.21
	hartley-6-0-pre:11.20
	rel-6-0-1:11.20
	rel-6-0:11.20
	rel-5-4:11.16
	offsite-5-3-pre:11.19
	rel-5-3:11.16
	rel-5-2:11.16
	rel-5-1-branch:11.16.0.2
	rel-5-1:11.16
	rel-5-0:11.14
	rel-5-0-beta:11.13
	rel-4-5:11.12
	ctj-4-5-post:11.11
	ctj-4-5-pre:11.11
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.6;
locks; strict;
comment	@ * @;


11.26
date	2004.05.21.17.47.34;	author morrison;	state dead;
branches;
next	11.25;

11.25
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.24;

11.24
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2002.08.20.17.08.20;	author jra;	state Exp;
branches
	11.22.2.1
	11.22.4.1
	11.22.10.1;
next	11.21;

11.21
date	2002.08.15.20.55.31;	author hartley;	state Exp;
branches;
next	11.20;

11.20
date	2001.04.05.19.35.42;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2000.10.20.05.04.37;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.09.08.05.55.47;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.08.19.03.10.09;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.03.30.20.47.11;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	99.12.30.19.35.29;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	99.09.01.18.55.08;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	99.02.08.16.32.57;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.09.23.18.40.01;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.03.10.19.17.46;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.18.03.08.23;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.33;	author mike;	state Rel4_4;
branches;
next	10.22;

10.22
date	94.12.23.23.47.48;	author gdurf;	state Exp;
branches;
next	10.21;

10.21
date	94.12.16.20.58.45;	author gdurf;	state Exp;
branches;
next	10.20;

10.20
date	94.12.16.19.35.14;	author gdurf;	state Exp;
branches;
next	10.19;

10.19
date	94.11.10.12.05.48;	author jra;	state Exp;
branches;
next	10.18;

10.18
date	94.08.25.00.05.09;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.08.23.18.26.28;	author gdurf;	state Exp;
branches;
next	10.16;

10.16
date	94.08.09.14.33.47;	author gdurf;	state Exp;
branches;
next	10.15;

10.15
date	94.06.01.15.00.49;	author gdurf;	state Exp;
branches;
next	10.14;

10.14
date	94.01.26.12.03.51;	author pjt;	state Exp;
branches;
next	10.13;

10.13
date	92.05.22.17.32.22;	author butler;	state Exp;
branches;
next	10.12;

10.12
date	92.03.24.14.23.09;	author mmark;	state Exp;
branches;
next	10.11;

10.11
date	92.03.18.00.35.23;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	92.03.18.00.33.07;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.03.18.00.27.33;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.03.18.00.24.04;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.03.17.20.53.44;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.02.22.03.35.42;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.02.22.02.04.18;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.02.22.01.20.57;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.02.21.23.52.17;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.12.18.06.38.33;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.03;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.01.12.08.25.42;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.08.00.30.50;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.07.01.04.52;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.07.01.03.28;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.27.22.50.09;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.01.39;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.06.20.38.19;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.03.06.17.45.34;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.03.06.17.25.43;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.00.48.29;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.17;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	87.11.05.05.03.06;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.58.15;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.01.19;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.17.28;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.05.06;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.18.47;	author mike;	state Rel1;
branches;
next	2.9;

2.9
date	86.09.09.21.40.31;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.08.12.06.46.16;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.09.14.05.33.31;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.08.26.17.15.56;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.08.07.05.16.28;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.07.30.01.17.00;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.15.05.02.35;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.05.23.18;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.53.28;	author mike;	state Prod;
branches;
next	1.6;

1.6
date	85.02.14.01.38.38;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.02.14.00.18.54;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.02.01.17.36.24;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.02.01.15.40.13;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.02.01.01.57.09;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.02.01.00.07.22;	author mike;	state Exp;
branches;
next	;

11.22.2.1
date	2002.09.19.18.01.58;	author morrison;	state Exp;
branches;
next	11.22.2.2;

11.22.2.2
date	2003.01.31.00.11.54;	author morrison;	state Exp;
branches;
next	11.22.2.3;

11.22.2.3
date	2004.03.17.21.21.54;	author morrison;	state Exp;
branches;
next	;

11.22.4.1
date	2004.03.11.23.46.32;	author morrison;	state Exp;
branches;
next	;

11.22.10.1
date	2004.02.12.18.34.12;	author erikg;	state Exp;
branches;
next	11.22.10.2;

11.22.10.2
date	2004.03.15.14.07.34;	author erikg;	state Exp;
branches;
next	;


desc
@GED solid analysis code
@


11.26
log
@moved to src/mged/
@
text
@/*
 *			A N A L
 *
 * Functions -
 *	f_analyze	"analyze" command
 *	findang		Given a normal vector, find rotation & fallback angles
 *
 *  Author -
 *	Keith A Applin
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/anal.c,v 11.25 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "./sedit.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./ged.h"
#include "externs.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

/* Conversion factor for Gallons to cubic millimeters */
#define GALLONS_TO_MM3 3785411.784

extern struct rt_db_internal	es_int;	/* from edsol.c */
extern struct bn_tol		mged_tol;		/* from ged.c */

static void	do_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	arb_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static double	anal_face(struct bu_vls *vp, int face, fastf_t *center_pt, const struct rt_arb_internal *arb, int type, const struct bn_tol *tol);
static void	anal_edge(struct bu_vls *vp, int edge, const struct rt_arb_internal *arb, int type);
static double	find_vol(int loc, struct rt_arb_internal *arb, struct bn_tol *tol);
static void	tgc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	ell_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	tor_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	ars_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	rpc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	rhc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	part_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	superell_anal(struct bu_vls *vp, const struct rt_db_internal *ip);

/*
 *			F _ A N A L Y Z E
 *
 *	Analyze command - prints loads of info about a solid
 *	Format:	analyze [name]
 *		if 'name' is missing use solid being edited
 */

int
f_analyze(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct directory *ndp;
	mat_t new_mat;
	register int i;
	struct bu_vls		v;
	struct rt_db_internal	intern;

	CHECK_DBI_NULL;

	if(argc < 1){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help analyze");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init(&v);

	if( argc == 1 ) {
		/* use the solid being edited */
		if (illump == SOLID_NULL) {
		  state_err( "Default SOLID Analyze" );
		  return TCL_ERROR;
		}
		ndp = LAST_SOLID(illump);
		if(illump->s_Eflag) {
		  Tcl_AppendResult(interp, "analyze: cannot analyze evaluated region containing ",
				   ndp->d_namep, "\n", (char *)NULL);
		  return TCL_ERROR;
		}
		switch( state ) {
		case ST_S_EDIT:
		  /* Use already modified version. "new way" */
		  do_anal(&v, &es_int);
		  Tcl_AppendResult(interp, bu_vls_addr(&v), (char *)NULL);
		  bu_vls_free(&v);
		  return TCL_OK;

		case ST_O_EDIT:
			/* use solid at bottom of path */
			break;

		default:
		  state_err( "Default SOLID Analyze" );
		  return TCL_ERROR;
		}
		bn_mat_mul(new_mat, modelchanges, es_mat);

		if( rt_db_get_internal( &intern, ndp, dbip, new_mat, &rt_uniresource ) < 0 )  {
		  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
		  return TCL_ERROR;
		}

		do_anal(&v, &intern);
		Tcl_AppendResult(interp, bu_vls_addr(&v), (char *)NULL);
		bu_vls_free(&v);
		rt_db_free_internal( &intern, &rt_uniresource );
		return TCL_OK;
	}

	/* use the names that were input */
	for( i = 1; i < argc; i++ )  {
		if( (ndp = db_lookup( dbip,  argv[i], LOOKUP_NOISY )) == DIR_NULL )
			continue;

		if( rt_db_get_internal( &intern, ndp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )  {
		  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
		  return TCL_ERROR;
		}

		bu_vls_trunc( &v, 0 );		
		do_list( &v, ndp, 1 );
		Tcl_AppendResult(interp, bu_vls_addr(&v), (char *)NULL);
		bu_vls_trunc( &v, 0 );

		do_anal(&v, &intern);
		Tcl_AppendResult(interp, bu_vls_addr(&v), (char *)NULL);
		bu_vls_free(&v);
		rt_db_free_internal( &intern, &rt_uniresource );
	}

	return TCL_OK;
}


/* Analyze solid in internal form */
static void
do_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	/* XXX Could give solid name, and current units, here */

	switch( ip->idb_type ) {

	case ID_ARS:
		ars_anal(vp, ip);
		break;

	case ID_ARB8:
		arb_anal(vp, ip);
		break;

	case ID_TGC:
		tgc_anal(vp, ip);
		break;

	case ID_ELL:
		ell_anal(vp, ip);
		break;

	case ID_TOR:
		tor_anal(vp, ip);
		break;

	case ID_RPC:
		rpc_anal(vp, ip);
		break;

	case ID_RHC:
		rhc_anal(vp, ip);
		break;

	case ID_PARTICLE:
		part_anal(vp, ip);
		break;

	case ID_SUPERELL:
		superell_anal(vp, ip);
		break;

	default:
		bu_vls_printf(vp,"analyze: unable to process %s solid\n",
			rt_functab[ip->idb_type].ft_name );
		break;
	}
}



/* edge definition array */
static const int nedge[5][24] = {
	{0,1, 1,2, 2,0, 0,3, 3,2, 1,3, -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},	/* ARB4 */
	{0,1, 1,2, 2,3, 0,3, 0,4, 1,4, 2,4, 3,4, -1,-1,-1,-1,-1,-1,-1,-1},	/* ARB5 */
	{0,1, 1,2, 2,3, 0,3, 0,4, 1,4, 2,5, 3,5, 4,5, -1,-1,-1,-1,-1,-1},	/* ARB6 */
	{0,1, 1,2, 2,3, 0,3, 0,4, 3,4, 1,5, 2,6, 4,5, 5,6, 4,6, -1,-1},		/* ARB7 */
	{0,1, 1,2, 2,3, 0,3, 0,4, 4,5, 1,5, 5,6, 6,7, 4,7, 3,7, 2,6},
};

/*
 *			A R B _ A N A L
 */
static void
arb_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	struct rt_arb_internal	*arb = (struct rt_arb_internal *)ip->idb_ptr;
	register int	i;
	point_t		center_pt;
	double		tot_vol;
	double		tot_area;
	int		cgtype;		/* COMGEOM arb type: # of vertices */
	int		type;

	if(dbip == DBI_NULL)
	  return;

	/* find the specific arb type, in GIFT order. */
	if( (cgtype = rt_arb_std_type( ip, &mged_tol )) == 0 ) {
		bu_vls_printf(vp,"arb_anal: bad ARB\n");
		return;
	}

	tot_area = tot_vol = 0.0;

	type = cgtype - 4;

	/* analyze each face, use center point of arb for reference */
	bu_vls_printf(vp,"\n------------------------------------------------------------------------------\n");
	bu_vls_printf(vp,"| FACE |   ROT     FB  |        PLANE EQUATION            |   SURFACE AREA   |\n");
	bu_vls_printf(vp,"|------|---------------|----------------------------------|------------------|\n");
	rt_arb_centroid( center_pt, arb, cgtype );

	for(i=0; i<6; i++) 
		tot_area += anal_face( vp, i, center_pt, arb, type, &mged_tol );

	bu_vls_printf(vp,"------------------------------------------------------------------------------\n");

	/* analyze each edge */
	bu_vls_printf(vp,"    | EDGE     LEN   | EDGE     LEN   | EDGE     LEN   | EDGE     LEN   |\n");
	bu_vls_printf(vp,"    |----------------|----------------|----------------|----------------|\n  ");

	/* set up the records for arb4's and arb6's */
	{
		struct rt_arb_internal	earb;

		earb = *arb;		/* struct copy */
		if( cgtype == 4 ) {
			VMOVE(earb.pt[3], earb.pt[4]);
		} else if( cgtype == 6 ) {
			VMOVE(earb.pt[5], earb.pt[6]);
		}
		for(i=0; i<12; i++) {
			anal_edge( vp, i, &earb, type );
			if( nedge[type][i*2] == -1 )
				break;
		}
	}
	bu_vls_printf(vp,"  ---------------------------------------------------------------------\n");

	/* find the volume - break arb8 into 6 arb4s */
	for(i=0; i<6; i++)
		tot_vol += find_vol( i, arb, &mged_tol );

	bu_vls_printf(vp,"      | Volume = %18.3f    Surface Area = %15.3f |\n",
			tot_vol*base2local*base2local*base2local,
			tot_area*base2local*base2local);
	bu_vls_printf(vp,"      |          %18.3f gal                               |\n",
		tot_vol/GALLONS_TO_MM3);
	bu_vls_printf(vp,"      -----------------------------------------------------------------\n");
}

/* ARB face printout array */
static const int prface[5][6] = {
	{123, 124, 234, 134, -111, -111},	/* ARB4 */
	{1234, 125, 235, 345, 145, -111},	/* ARB5 */
	{1234, 2365, 1564, 512, 634, -111},	/* ARB6 */
	{1234, 567, 145, 2376, 1265, 4375},	/* ARB7 */
	{1234, 5678, 1584, 2376, 1265, 4378},	/* ARB8 */
};
/* division of an arb8 into 6 arb4s */
static const int farb4[6][4] = {
	{0, 1, 2, 4},
	{4, 5, 6, 1},
	{1, 2, 6, 4},
	{0, 2, 3, 4},
	{4, 6, 7, 2},
	{2, 3, 7, 4},
};


/*
 *			F I N D A N G
 *
 * finds direction cosines and rotation, fallback angles of a unit vector
 * angles = pointer to 5 fastf_t's to store angles
 * unitv = pointer to the unit vector (previously computed)
 */
void
findang(register fastf_t *angles, register fastf_t *unitv)
{
	FAST fastf_t f;

	/* convert direction cosines into axis angles */
	if( unitv[X] <= -1.0 )  angles[X] = -90.0;
	else if( unitv[X] >= 1.0 )  angles[X] = 90.0;
	else angles[X] = acos( unitv[X] ) * radtodeg;

	if( unitv[Y] <= -1.0 )  angles[Y] = -90.0;
	else if( unitv[Y] >= 1.0 )  angles[Y] = 90.0;
	else angles[Y] = acos( unitv[Y] ) * radtodeg;

	if( unitv[Z] <= -1.0 )  angles[Z] = -90.0;
	else if( unitv[Z] >= 1.0 )  angles[Z] = 90.0;
	else angles[Z] = acos( unitv[Z] ) * radtodeg;

	/* fallback angle */
	if( unitv[Z] <= -1.0 )  unitv[Z] = -1.0;
	else if( unitv[Z] >= 1.0 )  unitv[Z] = 1.0;
	angles[4] = asin(unitv[Z]);

	/* rotation angle */
	/* For the tolerance below, on an SGI 4D/70, cos(asin(1.0)) != 0.0
	 * with an epsilon of +/- 1.0e-17, so the tolerance below was
	 * substituted for the original +/- 1.0e-20.
	 */
	if((f = cos(angles[4])) > 1.0e-16 || f < -1.0e-16 )  {
		f = unitv[X]/f;
		if( f <= -1.0 )
			angles[3] = 180;
		else if( f >= 1.0 )
			angles[3] = 0;
		else
			angles[3] = radtodeg * acos( f );
	}  else
		angles[3] = 0.0;
	if( unitv[Y] < 0 )
		angles[3] = 360.0 - angles[3];

	angles[4] *= radtodeg;
}

/* 	Analyzes an arb face
 */
static double
anal_face(struct bu_vls *vp, int face, fastf_t *center_pt, const struct rt_arb_internal *arb, int type, const struct bn_tol *tol)
             	    
   		     
       		          		/* reference center point */
                            	     
   		     
                   	     
{
	register int i, j, k;
	int a, b, c, d;		/* 4 points of face to look at */
	fastf_t	angles[5];	/* direction cosines, rot, fb */
	fastf_t	temp;
	fastf_t	area[2], len[6];
	vect_t	v_temp;
	plane_t	plane;
	double	face_area = 0;

	if(dbip == DBI_NULL)
	  return 0;

	a = arb_faces[type][face*4+0];
	b = arb_faces[type][face*4+1];
	c = arb_faces[type][face*4+2];
	d = arb_faces[type][face*4+3];

	if(a == -1)
		return 0;

	/* find plane eqn for this face */
	if( bn_mk_plane_3pts( plane, arb->pt[a], arb->pt[b],
	    arb->pt[c], tol ) < 0 )  {
		bu_vls_printf(vp,"| %d%d%d%d |         ***NOT A PLANE***                                          |\n",
				a+1,b+1,c+1,d+1);
		return 0;
	}

	/* the plane equations returned by planeqn above do not
	 * necessarily point outward. Use the reference center
	 * point for the arb and reverse direction for
	 * any errant planes. This corrects the output rotation,
	 * fallback angles so that they always give the outward
	 * pointing normal vector.
	 */
	if( (plane[3] - VDOT(center_pt, &plane[0])) < 0.0 ){
		for( i=0; i<4 ; i++ )
			plane[i] *= -1.0;
	}

	/* plane[] contains normalized eqn of plane of this face
	 * find the dir cos, rot, fb angles
	 */
	findang( angles, &plane[0] );

	/* find the surface area of this face */
	for(i=0; i<3; i++) {
		j = arb_faces[type][face*4+i];
		k = arb_faces[type][face*4+i+1];
		VSUB2(v_temp, arb->pt[k], arb->pt[j]);
		len[i] = MAGNITUDE( v_temp );
	}
	len[4] = len[2];
	j = arb_faces[type][face*4+0];
	for(i=2; i<4; i++) {
		k = arb_faces[type][face*4+i];
		VSUB2(v_temp, arb->pt[k], arb->pt[j]);
		len[((i*2)-1)] = MAGNITUDE( v_temp );
	}
	len[2] = len[3];

	for(i=0; i<2; i++) {
		j = i*3;
		temp = .5 * (len[j] + len[j+1] + len[j+2]);
		area[i] = sqrt(temp * (temp - len[j]) * (temp - len[j+1]) * (temp - len[j+2]));
		face_area += area[i];
	}

	bu_vls_printf(vp,"| %4d |",prface[type][face]);
	bu_vls_printf(vp," %6.2f %6.2f | %6.3f %6.3f %6.3f %11.3f |",
		angles[3], angles[4],
		plane[0],plane[1],plane[2],
		plane[3]*base2local);
	bu_vls_printf(vp,"   %13.3f  |\n",
		(area[0]+area[1])*base2local*base2local);
	return face_area;
}

/*	Analyzes arb edges - finds lengths */
static void
anal_edge(struct bu_vls *vp, int edge, const struct rt_arb_internal *arb, int type)
{
	register int a, b;
	static vect_t v_temp;

	if(dbip == DBI_NULL)
	  return;

	a = nedge[type][edge*2];
	b = nedge[type][edge*2+1];

	if( b == -1 ) {
		/* fill out the line */
		if( (a = edge%4) == 0 ) 
			return;
		if( a == 1 ) {
			bu_vls_printf(vp,"  |                |                |                |\n  ");
			return;
		}
		if( a == 2 ) {
			bu_vls_printf(vp,"  |                |                |\n  ");
			return;
		}
		bu_vls_printf(vp,"  |                |\n  ");
		return;
	}

	VSUB2(v_temp, arb->pt[b], arb->pt[a]);
	bu_vls_printf(vp, "  |  %d%d %9.3f",
		a+1, b+1, MAGNITUDE(v_temp)*base2local);

	if( ++edge%4 == 0 )
		bu_vls_printf(vp,"  |\n  ");
}


/*	Finds volume of an arb4 defined by farb4[loc][] 	*/
static double
find_vol(int loc, struct rt_arb_internal *arb, struct bn_tol *tol)
{
	int a, b, c, d;
	fastf_t vol, height, len[3], temp, areabase;
	vect_t	v_temp;
	plane_t	plane;

	/* a,b,c = base of the arb4 */
	a = farb4[loc][0];
	b = farb4[loc][1];
	c = farb4[loc][2];

	/* d = "top" point of arb4 */
	d = farb4[loc][3];

	if( bn_mk_plane_3pts( plane, arb->pt[a], arb->pt[b],
	    arb->pt[c], tol ) < 0 )
		return 0.0;

	/* have a good arb4 - find its volume */
	height = fabs(plane[3] - VDOT(&plane[0], arb->pt[d]));
	VSUB2(v_temp, arb->pt[b], arb->pt[a]);
	len[0] = MAGNITUDE(v_temp);
	VSUB2(v_temp, arb->pt[c], arb->pt[a]);
	len[1] = MAGNITUDE(v_temp);
	VSUB2(v_temp, arb->pt[c], arb->pt[b]);
	len[2] = MAGNITUDE(v_temp);
	temp = 0.5 * (len[0] + len[1] + len[2]);
	areabase = sqrt(temp * (temp-len[0]) * (temp-len[1]) * (temp-len[2]));
	vol = areabase * height / 3.0;
	return vol;
}

static double pi = 3.1415926535898;


/*	analyze a torus	*/
static void
tor_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	struct rt_tor_internal	*tor = (struct rt_tor_internal *)ip->idb_ptr;
	fastf_t r1, r2, vol, sur_area;

	if(dbip == DBI_NULL)
	  return;

	RT_TOR_CK_MAGIC( tor );

	r1 = tor->r_a;
	r2 = tor->r_h;

	vol = 2.0 * pi * pi * r1 * r2 * r2;
	sur_area = 4.0 * pi * pi * r1 * r2;

	bu_vls_printf(vp,"TOR Vol = %.4f (%.4f gal)   Surface Area = %.4f\n",
		vol*base2local*base2local*base2local,
		vol/GALLONS_TO_MM3,
		sur_area*base2local*base2local);

	return;
}

#define PROLATE 	1
#define OBLATE		2

/*	analyze an ell	*/
static void
ell_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	struct rt_ell_internal	*ell = (struct rt_ell_internal *)ip->idb_ptr;
	fastf_t ma, mb, mc;
#ifdef major		/* Some systems have these defined as macros!!! */
#undef major
#endif
#ifdef minor
#undef minor
#endif
	fastf_t ecc, major, minor;
	fastf_t vol, sur_area;
	int	type;

	if(dbip == DBI_NULL)
	  return;

	RT_ELL_CK_MAGIC( ell );

	ma = MAGNITUDE( ell->a );
	mb = MAGNITUDE( ell->b );
	mc = MAGNITUDE( ell->c );

	type = 0;

	vol = 4.0 * pi * ma * mb * mc / 3.0;
	bu_vls_printf(vp,"ELL Volume = %.4f (%.4f gal)",
		vol*base2local*base2local*base2local,
		vol/GALLONS_TO_MM3);

	if( fabs(ma-mb) < .00001 && fabs(mb-mc) < .00001 ) {
		/* have a sphere */
		sur_area = 4.0 * pi * ma * ma;
		bu_vls_printf(vp,"   Surface Area = %.4f\n",
				sur_area*base2local*base2local);
		return;
	}
	if( fabs(ma-mb) < .00001 ) {
		/* A == B */
		if( mc > ma ) {
			/* oblate spheroid */
			type = OBLATE;
			major = mc;
			minor = ma;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = ma;
			minor = mc;
		}
	}
	else
	if( fabs(ma-mc) < .00001 ) {
		/* A == C */
		if( mb > ma ) {
			/* oblate spheroid */
			type = OBLATE;
			major = mb;
			minor = ma;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = ma;
			minor = mb;
		}
	}
	else
	if( fabs(mb-mc) < .00001 ) {
		/* B == C */
		if( ma > mb ) {
			/* oblate spheroid */
			type = OBLATE;
			major = ma;
			minor = mb;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = mb;
			minor = ma;
		}
	}
	else {
		bu_vls_printf(vp,"   Cannot find surface area\n");
		return;
	}
	ecc = sqrt(major*major - minor*minor) / major;
	if( type == PROLATE ) {
		sur_area = 2.0 * pi * minor * minor +
			(2.0 * pi * (major*minor/ecc) * asin(ecc));
	} else if( type == OBLATE ) {
		sur_area = 2.0 * pi * major * major +
			(pi * (minor*minor/ecc) * log( (1.0+ecc)/(1.0-ecc) ));
	} else {
		sur_area = 0.0;
	}

	bu_vls_printf(vp,"   Surface Area = %.4f\n",
			sur_area*base2local*base2local);
}


/*	analyze an superell	*/
static void
superell_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	struct rt_superell_internal	*superell = (struct rt_superell_internal *)ip->idb_ptr;
	fastf_t ma, mb, mc;
#ifdef major		/* Some systems have these defined as macros!!! */
#undef major
#endif
#ifdef minor
#undef minor
#endif
	fastf_t ecc, major, minor;
	fastf_t vol, sur_area;
	int	type;

	if(dbip == DBI_NULL)
	  return;

	RT_SUPERELL_CK_MAGIC( superell );

	ma = MAGNITUDE( superell->a );
	mb = MAGNITUDE( superell->b );
	mc = MAGNITUDE( superell->c );

	type = 0;

	vol = 4.0 * pi * ma * mb * mc / 3.0;
	bu_vls_printf(vp,"SUPERELL Volume = %.4f (%.4f gal)",
		vol*base2local*base2local*base2local,
		vol/GALLONS_TO_MM3);

	if( fabs(ma-mb) < .00001 && fabs(mb-mc) < .00001 ) {
		/* have a sphere */
		sur_area = 4.0 * pi * ma * ma;
		bu_vls_printf(vp,"   Surface Area = %.4f\n",
				sur_area*base2local*base2local);
		return;
	}
	if( fabs(ma-mb) < .00001 ) {
		/* A == B */
		if( mc > ma ) {
			/* oblate spheroid */
			type = OBLATE;
			major = mc;
			minor = ma;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = ma;
			minor = mc;
		}
	}
	else
	if( fabs(ma-mc) < .00001 ) {
		/* A == C */
		if( mb > ma ) {
			/* oblate spheroid */
			type = OBLATE;
			major = mb;
			minor = ma;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = ma;
			minor = mb;
		}
	}
	else
	if( fabs(mb-mc) < .00001 ) {
		/* B == C */
		if( ma > mb ) {
			/* oblate spheroid */
			type = OBLATE;
			major = ma;
			minor = mb;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = mb;
			minor = ma;
		}
	}
	else {
		bu_vls_printf(vp,"   Cannot find surface area\n");
		return;
	}
	ecc = sqrt(major*major - minor*minor) / major;
	if( type == PROLATE ) {
		sur_area = 2.0 * pi * minor * minor +
			(2.0 * pi * (major*minor/ecc) * asin(ecc));
	} else if( type == OBLATE ) {
		sur_area = 2.0 * pi * major * major +
			(pi * (minor*minor/ecc) * log( (1.0+ecc)/(1.0-ecc) ));
	} else {
		sur_area = 0.0;
	}

	bu_vls_printf(vp,"   Surface Area = %.4f\n",
			sur_area*base2local*base2local);
}

#define MGED_ANAL_RCC	1
#define MGED_ANAL_TRC	2
#define MGED_ANAL_REC	3

/*	analyze tgc */
static void
tgc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	struct rt_tgc_internal	*tgc = (struct rt_tgc_internal *)ip->idb_ptr;
	fastf_t maxb, ma, mb, mc, md, mh;
	fastf_t area_base, area_top, area_side, vol;
	vect_t axb;
	int cgtype = 0;

	if(dbip == DBI_NULL)
	  return;

	RT_TGC_CK_MAGIC( tgc );

	VCROSS(axb, tgc->a, tgc->b);
	maxb = MAGNITUDE(axb);
	ma = MAGNITUDE( tgc->a );
	mb = MAGNITUDE( tgc->b );
	mc = MAGNITUDE( tgc->c );
	md = MAGNITUDE( tgc->d );
	mh = MAGNITUDE( tgc->h );

	/* check for right cylinder */
	if( fabs(fabs(VDOT(tgc->h,axb)) - (mh*maxb)) < .00001 ) {
		/* have a right cylinder */
		if(fabs(ma-mb) < .00001) {
			/* have a circular base */
			if(fabs(mc-md) < .00001) {
				/* have a circular top */
				if(fabs(ma-mc) < .00001)
					cgtype = MGED_ANAL_RCC;
				else
					cgtype = MGED_ANAL_TRC;
			}
		}
		else {
			/* have an elliptical base */
			if(fabs(ma-mc) < .00001 && fabs(mb-md) < .00001)
				cgtype = MGED_ANAL_REC;
		}
	}

	switch( cgtype ) {

		case MGED_ANAL_RCC:
			area_base = pi * ma * ma;
			area_top = area_base;
			area_side = 2.0 * pi * ma * mh;
			vol = pi * ma * ma * mh;
			bu_vls_printf(vp, "RCC ");
			break;

		case MGED_ANAL_TRC:
			area_base = pi * ma * ma;
			area_top = pi * mc * mc;
			area_side = pi * (ma+mc) * sqrt((ma-mc)*(ma-mc)+(mh*mh));
			vol = pi * mh * (ma*ma + mc*mc + ma*mc) / 3.0;
			bu_vls_printf(vp, "TRC ");
			break;

		case MGED_ANAL_REC:
			area_base = pi * ma * mb;
			area_top = pi * mc * md;
			/* approximate */
			area_side = 2.0 * pi * mh * sqrt(0.5 * (ma*ma + mb*mb));
			vol = pi * ma * mb * mh;
			bu_vls_printf(vp, "REC ");
			break;

		default:
			bu_vls_printf(vp,"TGC Cannot find areas and volume\n");
			return;
	}

	/* print the results */
	bu_vls_printf(vp,"Surface Areas:  base(AxB)=%.4f  top(CxD)=%.4f  side=%.4f\n",
			area_base*base2local*base2local,
			area_top*base2local*base2local,
			area_side*base2local*base2local);
	bu_vls_printf(vp,"Total Surface Area=%.4f    Volume=%.4f (%.4f gal)\n",
			(area_base+area_top+area_side)*base2local*base2local,
			vol*base2local*base2local*base2local,vol/GALLONS_TO_MM3);
	/* Print units? */
	return;

}



/*	analyze ars */
static void
ars_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	bu_vls_printf(vp,"ARS analyze not implemented\n");
}

/*	XXX	analyze spline needed
 * static void
 * spline_anal(vp, ip)
 * struct bu_vls	*vp;
 * const struct rt_db_internal	*ip;
 * {
 * 	bu_vls_printf(vp,"SPLINE analyze not implemented\n");
 * }
 */

/*	analyze particle	*/
static void
part_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	bu_vls_printf(vp,"PARTICLE analyze not implemented\n");
}

#define arcsinh(x) (log((x) + sqrt((x)*(x) + 1.)))

/*	analyze rpc */
static void
rpc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	fastf_t	area_parab, area_body, b, h, r, vol_parab;
	struct rt_rpc_internal	*rpc = (struct rt_rpc_internal *)ip->idb_ptr;

	if(dbip == DBI_NULL)
	  return;

	RT_RPC_CK_MAGIC( rpc );

	b = MAGNITUDE( rpc->rpc_B );
	h = MAGNITUDE( rpc->rpc_H );
	r = rpc->rpc_r;
	
	/* area of one parabolic side */
	area_parab = 4./3 * b*r;
	
	/* volume of rpc */
	vol_parab = area_parab*h;
	
	/* surface area of parabolic body */
	area_body = .5*sqrt(r*r + 4.*b*b) + .25*r*r/b*arcsinh(2.*b/r);
	area_body *= 2.;

	bu_vls_printf(vp,"Surface Areas:  front(BxR)=%.4f  top(RxH)=%.4f  body=%.4f\n",
			area_parab*base2local*base2local,
			2*r*h*base2local*base2local,
			area_body*base2local*base2local);
	bu_vls_printf(vp,"Total Surface Area=%.4f    Volume=%.4f (%.4f gal)\n",
			(2*area_parab+2*r*h+area_body)*base2local*base2local,
			vol_parab*base2local*base2local*base2local,
			vol_parab/GALLONS_TO_MM3);
}

/*	analyze rhc */
static void
rhc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	fastf_t	area_hyperb, area_body, b, c, h, r, vol_hyperb,	work1;
	struct rt_rhc_internal	*rhc = (struct rt_rhc_internal *)ip->idb_ptr;

	if(dbip == DBI_NULL)
	  return;

	RT_RHC_CK_MAGIC( rhc );

	b = MAGNITUDE( rhc->rhc_B );
	h = MAGNITUDE( rhc->rhc_H );
	r = rhc->rhc_r;
	c = rhc->rhc_c;
	
	/* area of one hyperbolic side (from macsyma) WRONG!!!! */
	work1 = sqrt(b*(b + 2.*c));
	area_hyperb = -2.*r*work1*(.5*(b+c) + c*c*log(c/(work1 + b + c)));

	/* volume of rhc */
	vol_hyperb = area_hyperb*h;
	
	/* surface area of hyperbolic body */
	area_body=0.;
#if 0
	k = (b+c)*(b+c) - c*c;
#define X_eval(y) sqrt( 1. + (4.*k)/(r*r*k*k*(y)*(y) + r*r*c*c) )
#define L_eval(y) .5*k*(y)*X_eval(y) \
		  + r*k*(r*r*c*c + 4.*k - r*r*c*c/k)*arcsinh((y)*sqrt(k)/c)
	area_body = 2.*(L_eval(r) - L_eval(0.));
#endif

	bu_vls_printf(vp,"Surface Areas:  front(BxR)=%.4f  top(RxH)=%.4f  body=%.4f\n",
			area_hyperb*base2local*base2local,
			2*r*h*base2local*base2local,
			area_body*base2local*base2local);
	bu_vls_printf(vp,"Total Surface Area=%.4f    Volume=%.4f (%.4f gal)\n",
			(2*area_hyperb+2*r*h+2*area_body)*base2local*base2local,
			vol_hyperb*base2local*base2local*base2local,
			vol_hyperb/GALLONS_TO_MM3);
}


/*
 *  		M A T H E R R
 *  
 *  Sys-V math-library error catcher.
 *  Some callers of acos trip over DOMAIN errors all the time, so...
 */
#ifdef HAVE_MATHERR
int
matherr(x)
struct exception *x;
{
	return(1);	/* be quiet */
}
#endif
@


11.25
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/anal.c,v 11.24 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.24
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.23
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.22 2002/08/20 17:08:20 jra Exp $ (BRL)";
d46 13
a58 12
static void	do_anal();
static void	arb_anal();
static double	anal_face();
static void	anal_edge();
static double	find_vol();
static void	tgc_anal();
static void	ell_anal();
static void	tor_anal();
static void	ars_anal();
static void	rpc_anal();
static void	rhc_anal();
static void	part_anal();
d69 1
a69 5
f_analyze(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d160 1
a160 3
do_anal(vp, ip)
struct bu_vls		*vp;
const struct rt_db_internal	*ip;
d198 4
d224 1
a224 3
arb_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d319 1
a319 3
findang( angles, unitv )
register fastf_t	*angles;
register vect_t		unitv;
d365 7
a371 7
anal_face( vp, face, center_pt, arb, type, tol )
struct bu_vls	*vp;
int		face;
point_t		center_pt;		/* reference center point */
const struct rt_arb_internal	*arb;
int		type;
const struct bn_tol	*tol;
d453 1
a453 5
anal_edge( vp, edge, arb, type )
struct bu_vls		*vp;
int			edge;
const struct rt_arb_internal	*arb;
int			type;
d491 1
a491 4
find_vol( loc, arb, tol )
int	loc;
struct rt_arb_internal	*arb;
struct bn_tol		*tol;
d529 1
a529 3
tor_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d558 1
a558 3
ell_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d661 106
d773 1
a773 3
tgc_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d863 1
a863 3
ars_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d880 1
a880 3
part_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d889 1
a889 3
rpc_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d925 1
a925 3
rhc_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
@


11.22
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.20 2001/04/05 19:35:42 morrison Exp $ (BRL)";
@


11.22.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/anal.c,v 11.23 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.22.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.23 2004/02/02 17:39:31 morrison Exp $ (BRL)";
@


11.22.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.22.10.1 2004/02/12 18:34:12 erikg Exp $ (BRL)";
@


11.22.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.22 2002/08/20 17:08:20 jra Exp $ (BRL)";
d46 12
a57 12
static void	do_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	arb_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static double	anal_face(struct bu_vls *vp, int face, fastf_t *center_pt, const struct rt_arb_internal *arb, int type, const struct bn_tol *tol);
static void	anal_edge(struct bu_vls *vp, int edge, const struct rt_arb_internal *arb, int type);
static double	find_vol(int loc, struct rt_arb_internal *arb, struct bn_tol *tol);
static void	tgc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	ell_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	tor_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	ars_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	rpc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	rhc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	part_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
d68 5
a72 1
f_analyze(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d163 3
a165 1
do_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d225 3
a227 1
arb_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d322 3
a324 1
findang(register fastf_t *angles, register fastf_t *unitv)
d370 7
a376 7
anal_face(struct bu_vls *vp, int face, fastf_t *center_pt, const struct rt_arb_internal *arb, int type, const struct bn_tol *tol)
             	    
   		     
       		          		/* reference center point */
                            	     
   		     
                   	     
d458 5
a462 1
anal_edge(struct bu_vls *vp, int edge, const struct rt_arb_internal *arb, int type)
d500 4
a503 1
find_vol(int loc, struct rt_arb_internal *arb, struct bn_tol *tol)
d541 3
a543 1
tor_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d572 3
a574 1
ell_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d683 3
a685 1
tgc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d775 3
a777 1
ars_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d794 3
a796 1
part_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d805 3
a807 1
rpc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d843 3
a845 1
rhc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
@


11.22.2.2
log
@Added initial stubbed support for a new primitive -- a superquadric ellipsoid.  The primitive may be created in mged, but it has the same guts as the ellipsoid
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.22.2.1 2002/09/19 18:01:58 morrison Exp $ (BRL)";
a57 1
static void	superell_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
a196 4
	case ID_SUPERELL:
		superell_anal(vp, ip);
		break;

a579 106
		vol*base2local*base2local*base2local,
		vol/GALLONS_TO_MM3);

	if( fabs(ma-mb) < .00001 && fabs(mb-mc) < .00001 ) {
		/* have a sphere */
		sur_area = 4.0 * pi * ma * ma;
		bu_vls_printf(vp,"   Surface Area = %.4f\n",
				sur_area*base2local*base2local);
		return;
	}
	if( fabs(ma-mb) < .00001 ) {
		/* A == B */
		if( mc > ma ) {
			/* oblate spheroid */
			type = OBLATE;
			major = mc;
			minor = ma;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = ma;
			minor = mc;
		}
	}
	else
	if( fabs(ma-mc) < .00001 ) {
		/* A == C */
		if( mb > ma ) {
			/* oblate spheroid */
			type = OBLATE;
			major = mb;
			minor = ma;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = ma;
			minor = mb;
		}
	}
	else
	if( fabs(mb-mc) < .00001 ) {
		/* B == C */
		if( ma > mb ) {
			/* oblate spheroid */
			type = OBLATE;
			major = ma;
			minor = mb;
		}
		else {
			/* prolate spheroid */
			type = PROLATE;
			major = mb;
			minor = ma;
		}
	}
	else {
		bu_vls_printf(vp,"   Cannot find surface area\n");
		return;
	}
	ecc = sqrt(major*major - minor*minor) / major;
	if( type == PROLATE ) {
		sur_area = 2.0 * pi * minor * minor +
			(2.0 * pi * (major*minor/ecc) * asin(ecc));
	} else if( type == OBLATE ) {
		sur_area = 2.0 * pi * major * major +
			(pi * (minor*minor/ecc) * log( (1.0+ecc)/(1.0-ecc) ));
	} else {
		sur_area = 0.0;
	}

	bu_vls_printf(vp,"   Surface Area = %.4f\n",
			sur_area*base2local*base2local);
}


/*	analyze an superell	*/
static void
superell_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
{
	struct rt_superell_internal	*superell = (struct rt_superell_internal *)ip->idb_ptr;
	fastf_t ma, mb, mc;
#ifdef major		/* Some systems have these defined as macros!!! */
#undef major
#endif
#ifdef minor
#undef minor
#endif
	fastf_t ecc, major, minor;
	fastf_t vol, sur_area;
	int	type;

	if(dbip == DBI_NULL)
	  return;

	RT_SUPERELL_CK_MAGIC( superell );

	ma = MAGNITUDE( superell->a );
	mb = MAGNITUDE( superell->b );
	mc = MAGNITUDE( superell->c );

	type = 0;

	vol = 4.0 * pi * ma * mb * mc / 3.0;
	bu_vls_printf(vp,"SUPERELL Volume = %.4f (%.4f gal)",
@


11.22.2.3
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.21
log
@Converted from K&R to ANSI C - RFH
@
text
@d46 12
a57 12
static void	do_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	arb_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static double	anal_face(struct bu_vls *vp, int face, fastf_t *center_pt, const struct rt_arb_internal *arb, int type, const struct bn_tol *tol);
static void	anal_edge(struct bu_vls *vp, int edge, const struct rt_arb_internal *arb, int type);
static double	find_vol(int loc, struct rt_arb_internal *arb, struct bn_tol *tol);
static void	tgc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	ell_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	tor_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	ars_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	rpc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	rhc_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
static void	part_anal(struct bu_vls *vp, const struct rt_db_internal *ip);
d68 5
a72 1
f_analyze(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d163 3
a165 1
do_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d225 3
a227 1
arb_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d322 3
a324 1
findang(register fastf_t *angles, register fastf_t *unitv)
d370 7
a376 7
anal_face(struct bu_vls *vp, int face, fastf_t *center_pt, const struct rt_arb_internal *arb, int type, const struct bn_tol *tol)
             	    
   		     
       		          		/* reference center point */
                            	     
   		     
                   	     
d458 5
a462 1
anal_edge(struct bu_vls *vp, int edge, const struct rt_arb_internal *arb, int type)
d500 4
a503 1
find_vol(int loc, struct rt_arb_internal *arb, struct bn_tol *tol)
d541 3
a543 1
tor_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d572 3
a574 1
ell_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d683 3
a685 1
tgc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d775 3
a777 1
ars_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d794 3
a796 1
part_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d805 3
a807 1
rpc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
d843 3
a845 1
rhc_anal(struct bu_vls *vp, const struct rt_db_internal *ip)
@


11.20
log
@updated SIGNED to signed
updated CONST to const
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.19 2000/10/20 05:04:37 mike Exp $ (BRL)";
d46 12
a57 12
static void	do_anal();
static void	arb_anal();
static double	anal_face();
static void	anal_edge();
static double	find_vol();
static void	tgc_anal();
static void	ell_anal();
static void	tor_anal();
static void	ars_anal();
static void	rpc_anal();
static void	rhc_anal();
static void	part_anal();
d68 1
a68 5
f_analyze(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d159 1
a159 3
do_anal(vp, ip)
struct bu_vls		*vp;
const struct rt_db_internal	*ip;
d219 1
a219 3
arb_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d314 1
a314 3
findang( angles, unitv )
register fastf_t	*angles;
register vect_t		unitv;
d360 7
a366 7
anal_face( vp, face, center_pt, arb, type, tol )
struct bu_vls	*vp;
int		face;
point_t		center_pt;		/* reference center point */
const struct rt_arb_internal	*arb;
int		type;
const struct bn_tol	*tol;
d448 1
a448 5
anal_edge( vp, edge, arb, type )
struct bu_vls		*vp;
int			edge;
const struct rt_arb_internal	*arb;
int			type;
d486 1
a486 4
find_vol( loc, arb, tol )
int	loc;
struct rt_arb_internal	*arb;
struct bn_tol		*tol;
d524 1
a524 3
tor_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d553 1
a553 3
ell_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d662 1
a662 3
tgc_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d752 1
a752 3
ars_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d769 1
a769 3
part_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d778 1
a778 3
rpc_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
d814 1
a814 3
rhc_anal(vp, ip)
struct bu_vls	*vp;
const struct rt_db_internal	*ip;
@


11.19
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.18 2000/09/08 05:55:47 mike Exp $ (BRL)";
d165 1
a165 1
CONST struct rt_db_internal	*ip;
d213 1
a213 1
static CONST int nedge[5][24] = {
d227 1
a227 1
CONST struct rt_db_internal	*ip;
d296 1
a296 1
static CONST int prface[5][6] = {
d304 1
a304 1
static CONST int farb4[6][4] = {
d374 1
a374 1
CONST struct rt_arb_internal	*arb;
d376 1
a376 1
CONST struct bn_tol	*tol;
d461 1
a461 1
CONST struct rt_arb_internal	*arb;
d543 1
a543 1
CONST struct rt_db_internal	*ip;
d574 1
a574 1
CONST struct rt_db_internal	*ip;
d685 1
a685 1
CONST struct rt_db_internal	*ip;
d777 1
a777 1
CONST struct rt_db_internal	*ip;
d786 1
a786 1
 * CONST struct rt_db_internal	*ip;
d796 1
a796 1
CONST struct rt_db_internal	*ip;
d807 1
a807 1
CONST struct rt_db_internal	*ip;
d845 1
a845 1
CONST struct rt_db_internal	*ip;
@


11.18
log
@
Tree routines now need resource structure.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.17 2000/08/19 03:10:09 mike Exp $ (BRL)";
d100 1
a100 1
		ndp = illump->s_path[illump->s_last];
@


11.17
log
@
Reduced use of MAXARGS
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.16 2000/03/30 20:47:11 bparker Exp $ (BRL)";
d124 1
a124 1
		if( rt_db_get_internal( &intern, ndp, dbip, new_mat ) < 0 )  {
d132 1
a132 1
		rt_db_free_internal( &intern );
d141 1
a141 1
		if( rt_db_get_internal( &intern, ndp, dbip, bn_mat_identity ) < 0 )  {
d154 1
a154 1
		rt_db_free_internal( &intern );
@


11.16
log
@Changed conversion factor (i.e. gallons to mm^3)
  from 3787878.79 to 3785411.784
The new factor was obtained from
  http://libweb.wes.army.mil/usace/weight.htm
Thanks to Bob Strausser.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.15 1999/12/30 19:35:29 jra Exp $ (BRL)";
d82 1
a82 1
	if(argc < 1 || MAXARGS < argc){
@


11.15
log
@Eliminated some unused variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.14 1999/09/01 18:55:08 bparker Exp $ (BRL)";
d40 3
d291 1
a291 1
		tot_vol/3787878.79);
d561 1
a561 1
		vol/3787878.79,
d602 1
a602 1
		vol/3787878.79);
d765 1
a765 1
			vol*base2local*base2local*base2local,vol/3787878.79);
d838 1
a838 1
			vol_parab/3787878.79);
d884 1
a884 1
			vol_hyperb/3787878.79);
@


11.14
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.13 1999/02/08 16:32:57 bparker Exp $ (BRL)";
a794 2
	struct rt_part_internal	*part = (struct rt_part_internal *)ip->idb_ptr;

@


11.13
log
@*- add stub for part_anal()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/anal.c,v 11.12 1997/07/01 22:09:08 bparker Exp $ (BRL)";
d77 1
a77 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.12
log
@mods to run without a database
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.11 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d54 1
d197 4
d789 11
@


11.11
log
@modify calls to Tcl_Eval
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.10 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d76 3
d230 3
d380 3
d460 3
d541 3
d581 3
d686 3
d796 3
d833 3
@


11.10
log
@mods so that commands check args internally
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.9 1997/01/02 19:35:05 bparker Exp bparker $ (BRL)";
d77 6
a82 1
	  Tcl_Eval(interp, "help analyze");
@


11.9
log
@mods to use libbn and libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.8 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d76 2
a77 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d79 1
@


11.8
log
@include mged_solid.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.7 1996/09/23 18:40:01 bparker Exp bparker $ (BRL)";
a27 1

d31 1
d41 1
a41 1
extern struct rt_tol		mged_tol;		/* from ged.c */
d109 1
a109 1
		mat_mul(new_mat, modelchanges, es_mat);
d128 1
a128 1
		if( rt_db_get_internal( &intern, ndp, dbip, rt_identity ) < 0 )  {
d356 1
a356 1
CONST struct rt_tol	*tol;
d376 1
a376 1
	if( rt_mk_plane_3pts( plane, arb->pt[a], arb->pt[b],
d477 1
a477 1
struct rt_tol		*tol;
d492 1
a492 1
	if( rt_mk_plane_3pts( plane, arb->pt[a], arb->pt[b],
@


11.7
log
@changed dm.h to mged_dm.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.6 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d37 1
a37 1
#include "./solid.h"
@


11.6
log
@rt_list ---> bu_list
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.5 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d38 1
a38 1
#include "./dm.h"
@


11.5
log
@now using libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.4 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d30 1
@


11.4
log
@convert commands to Tcl
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.3 1995/03/10 19:17:46 mike Exp bparker $ (BRL)";
d72 1
a72 1
	struct rt_vls		v;
d78 1
a78 1
	RT_VLS_INIT(&v);
d96 2
a97 2
		  Tcl_AppendResult(interp, rt_vls_addr(&v), (char *)NULL);
		  rt_vls_free(&v);
d116 2
a117 2
		Tcl_AppendResult(interp, rt_vls_addr(&v), (char *)NULL);
		rt_vls_free(&v);
d132 1
a132 1
		rt_vls_trunc( &v, 0 );		
d134 2
a135 2
		Tcl_AppendResult(interp, rt_vls_addr(&v), (char *)NULL);
		rt_vls_trunc( &v, 0 );
d138 2
a139 2
		Tcl_AppendResult(interp, rt_vls_addr(&v), (char *)NULL);
		rt_vls_free(&v);
d150 1
a150 1
struct rt_vls		*vp;
d186 1
a186 1
		rt_vls_printf(vp,"analyze: unable to process %s solid\n",
d208 1
a208 1
struct rt_vls	*vp;
d221 1
a221 1
		rt_vls_printf(vp,"arb_anal: bad ARB\n");
d230 3
a232 3
	rt_vls_printf(vp,"\n------------------------------------------------------------------------------\n");
	rt_vls_printf(vp,"| FACE |   ROT     FB  |        PLANE EQUATION            |   SURFACE AREA   |\n");
	rt_vls_printf(vp,"|------|---------------|----------------------------------|------------------|\n");
d238 1
a238 1
	rt_vls_printf(vp,"------------------------------------------------------------------------------\n");
d241 2
a242 2
	rt_vls_printf(vp,"    | EDGE     LEN   | EDGE     LEN   | EDGE     LEN   | EDGE     LEN   |\n");
	rt_vls_printf(vp,"    |----------------|----------------|----------------|----------------|\n  ");
d260 1
a260 1
	rt_vls_printf(vp,"  ---------------------------------------------------------------------\n");
d266 1
a266 1
	rt_vls_printf(vp,"      | Volume = %18.3f    Surface Area = %15.3f |\n",
d269 1
a269 1
	rt_vls_printf(vp,"      |          %18.3f gal                               |\n",
d271 1
a271 1
	rt_vls_printf(vp,"      -----------------------------------------------------------------\n");
d350 1
a350 1
struct rt_vls	*vp;
d377 1
a377 1
		rt_vls_printf(vp,"| %d%d%d%d |         ***NOT A PLANE***                                          |\n",
d422 2
a423 2
	rt_vls_printf(vp,"| %4d |",prface[type][face]);
	rt_vls_printf(vp," %6.2f %6.2f | %6.3f %6.3f %6.3f %11.3f |",
d427 1
a427 1
	rt_vls_printf(vp,"   %13.3f  |\n",
d435 1
a435 1
struct rt_vls		*vp;
d451 1
a451 1
			rt_vls_printf(vp,"  |                |                |                |\n  ");
d455 1
a455 1
			rt_vls_printf(vp,"  |                |                |\n  ");
d458 1
a458 1
		rt_vls_printf(vp,"  |                |\n  ");
d463 1
a463 1
	rt_vls_printf(vp, "  |  %d%d %9.3f",
d467 1
a467 1
		rt_vls_printf(vp,"  |\n  ");
d515 1
a515 1
struct rt_vls	*vp;
d529 1
a529 1
	rt_vls_printf(vp,"TOR Vol = %.4f (%.4f gal)   Surface Area = %.4f\n",
d543 1
a543 1
struct rt_vls	*vp;
d567 1
a567 1
	rt_vls_printf(vp,"ELL Volume = %.4f (%.4f gal)",
d574 1
a574 1
		rt_vls_printf(vp,"   Surface Area = %.4f\n",
d626 1
a626 1
		rt_vls_printf(vp,"   Cannot find surface area\n");
d640 1
a640 1
	rt_vls_printf(vp,"   Surface Area = %.4f\n",
d651 1
a651 1
struct rt_vls	*vp;
d697 1
a697 1
			rt_vls_printf(vp, "RCC ");
d705 1
a705 1
			rt_vls_printf(vp, "TRC ");
d714 1
a714 1
			rt_vls_printf(vp, "REC ");
d718 1
a718 1
			rt_vls_printf(vp,"TGC Cannot find areas and volume\n");
d723 1
a723 1
	rt_vls_printf(vp,"Surface Areas:  base(AxB)=%.4f  top(CxD)=%.4f  side=%.4f\n",
d727 1
a727 1
	rt_vls_printf(vp,"Total Surface Area=%.4f    Volume=%.4f (%.4f gal)\n",
d740 1
a740 1
struct rt_vls	*vp;
d743 1
a743 1
	rt_vls_printf(vp,"ARS analyze not implemented\n");
d749 1
a749 1
 * struct rt_vls	*vp;
d752 1
a752 1
 * 	rt_vls_printf(vp,"SPLINE analyze not implemented\n");
d761 1
a761 1
struct rt_vls	*vp;
d783 1
a783 1
	rt_vls_printf(vp,"Surface Areas:  front(BxR)=%.4f  top(RxH)=%.4f  body=%.4f\n",
d787 1
a787 1
	rt_vls_printf(vp,"Total Surface Area=%.4f    Volume=%.4f (%.4f gal)\n",
d796 1
a796 1
struct rt_vls	*vp;
d826 1
a826 1
	rt_vls_printf(vp,"Surface Areas:  front(BxR)=%.4f  top(RxH)=%.4f  body=%.4f\n",
d830 1
a830 1
	rt_vls_printf(vp,"Total Surface Area=%.4f    Volume=%.4f (%.4f gal)\n",
@


11.3
log
@Can't do rt_log( rt_vls_addr( &str ) ), need to use "%s" format.
Otherwise, can over-run format string in printf.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.2 95/02/18 03:08:23 mike Exp Locker: mike $ (BRL)";
d63 3
a65 1
f_analyze(argc, argv)
d75 3
d83 2
a84 2
			state_err( "Default SOLID Analyze" );
			return CMD_BAD;
d88 3
a90 3
			rt_log("analyze: cannot analyze evaluated region containing %s\n",
				ndp->d_namep);
			return CMD_BAD;
d94 5
a98 4
			/* Use already modified version. "new way" */
			do_anal(&v, &es_int);
			fputs( rt_vls_addr(&v), stderr );
			return CMD_OK;
d105 2
a106 2
			state_err( "Default SOLID Analyze" );
			return CMD_BAD;
d111 2
a112 2
			rt_log("rt_db_get_internal() error\n");
			return CMD_BAD;
d116 2
a117 1
		fputs( rt_vls_addr(&v), stderr );
d119 1
a119 1
		return CMD_OK;
d128 2
a129 2
			rt_log("rt_db_get_internal() error\n");
			return CMD_BAD;
d134 1
a134 1
		rt_log( "%s", rt_vls_addr(&v) );
d138 1
a138 1
		rt_log( "%s", rt_vls_addr(&v) );
d143 1
a143 1
	return CMD_OK;
@


11.2
log
@Eliminated local setting of "rt_tol" structures.
Everything now uses the global mged_tol.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 11.1 95/01/04 10:02:33 mike Rel4_4 Locker: mike $ (BRL)";
d127 1
a127 1
		rt_log( rt_vls_addr(&v) );
d131 1
a131 1
		rt_log( rt_vls_addr(&v) );
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.22 94/12/23 23:47:48 gdurf Exp $ (BRL)";
d40 1
a208 1
	struct rt_tol	tol;
a211 7
	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;	/* 0.005 matches planeqn() val, 0.0001 matches dist checking */
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d213 1
a213 1
	if( (cgtype = rt_arb_std_type( ip, &tol )) == 0 ) {
d229 1
a229 1
		tot_area += anal_face( vp, i, center_pt, arb, type, &tol );
d257 1
a257 1
		tot_vol += find_vol( i, arb, &tol );
@


10.22
log
@Converted to new do_list
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.21 94/12/16 20:58:45 gdurf Exp Locker: gdurf $ (BRL)";
@


10.21
log
@Temporary hack, replacing stdout with stderr, for compatibility with rt_log
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.20 1994/12/16 19:35:14 gdurf Exp gdurf $ (BRL)";
d124 5
a128 1
		do_list( stderr, ndp, 1 );
d130 1
a130 1
		fputs( rt_vls_addr(&v), stderr );
@


10.20
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.19 1994/11/10 12:05:48 jra Exp gdurf $ (BRL)";
d90 1
a90 1
			fputs( rt_vls_addr(&v), stdout );
d109 1
a109 1
		fputs( rt_vls_addr(&v), stdout );
d124 1
a124 1
		do_list( stdout, ndp, 1 );
d126 1
a126 1
		fputs( rt_vls_addr(&v), stdout );
@


10.19
log
@Irix 6.0.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/anal.c,v 10.18 1994/08/25 00:05:09 mike Exp jra $ (BRL)";
d82 1
a82 1
			(void)printf("analyze: cannot analyze evaluated region containing %s\n",
d104 1
a104 1
			(void)printf("rt_db_get_internal() error\n");
d120 1
a120 1
			(void)printf("rt_db_get_internal() error\n");
@


10.18
log
@When run without args, in solid edit mode, now usees es_int, rather than
re-reading from the disk.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.17 94/08/23 18:26:28 gdurf Exp Locker: mike $ (BRL)";
d742 9
a750 8
/*	analyze spline */
static void
spline_anal(vp, ip)
struct rt_vls	*vp;
CONST struct rt_db_internal	*ip;
{
	rt_vls_printf(vp,"SPLINE analyze not implemented\n");
}
d760 1
a760 1
	fastf_t	area_parab, area_body, area_rect, b, h, r, vol_parab;
d795 1
a795 2
	fastf_t	area_hyperb, area_body, area_rect, b, c, h, k, r, vol_hyperb,
		work1, work2, work3, work4;
@


10.17
log
@Added workaround to sun3 nasty
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.16 1994/08/09 14:33:47 gdurf Exp gdurf $ (BRL)";
d39 2
d88 4
a91 2
			mat_idn( modelchanges ); /* just to make sure */
			break;
d111 1
a111 1
		return CMD_BAD;
d139 1
a139 1
struct rt_db_internal	*ip;
d197 1
a197 1
struct rt_db_internal	*ip;
d349 1
a349 1
struct rt_arb_internal	*arb;
d351 1
a351 1
struct rt_tol	*tol;
d433 1
a433 1
struct rt_arb_internal	*arb;
d512 1
a512 1
struct rt_db_internal	*ip;
d540 1
a540 1
struct rt_db_internal	*ip;
d648 1
a648 1
struct rt_db_internal	*ip;
d737 1
a737 1
struct rt_db_internal	*ip;
d746 1
a746 1
struct rt_db_internal	*ip;
d757 1
a757 1
struct rt_db_internal	*ip;
d792 1
a792 1
struct rt_db_internal	*ip;
@


10.16
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.15 1994/06/01 15:00:49 gdurf Exp gdurf $ (BRL)";
d540 6
@


10.15
log
@Converted f_analyze to use new command return codes.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.14 1994/01/26 12:03:51 pjt Exp gdurf $ (BRL)";
d24 3
d28 1
a28 1
#include <stdio.h>
d829 1
a829 1
#if !__STDC__ && ( defined(SYSV) || BSD >= 43 )
@


10.14
log
@when called w/ no argument, f_analyze() now ensures
that there's an illuminated solid.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.13 92/05/22 17:32:22 butler Exp $ (BRL)";
d56 1
a56 1
void
d73 1
a73 1
			return;
d79 1
a79 1
			return;
d92 1
a92 1
			return;
d98 1
a98 1
			return;
d104 1
a104 1
		return;
d114 1
a114 1
			return;
d123 2
@


10.13
log
@Re-ordered occurrence of subroutines so that functions are defined before
being used the first time.  Removes compiler warnings.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.12 92/03/24 14:23:09 mmark Exp Locker: butler $ (BRL)";
d71 4
@


10.12
log
@editing support for erim primitives
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.11 92/03/18 00:35:23 mike Exp Locker: mmark $ (BRL)";
d276 53
a812 52
/*
 *			F I N D A N G
 *
 * finds direction cosines and rotation, fallback angles of a unit vector
 * angles = pointer to 5 fastf_t's to store angles
 * unitv = pointer to the unit vector (previously computed)
 */
void
findang( angles, unitv )
register fastf_t	*angles;
register vect_t		unitv;
{
	FAST fastf_t f;

	/* convert direction cosines into axis angles */
	if( unitv[X] <= -1.0 )  angles[X] = -90.0;
	else if( unitv[X] >= 1.0 )  angles[X] = 90.0;
	else angles[X] = acos( unitv[X] ) * radtodeg;

	if( unitv[Y] <= -1.0 )  angles[Y] = -90.0;
	else if( unitv[Y] >= 1.0 )  angles[Y] = 90.0;
	else angles[Y] = acos( unitv[Y] ) * radtodeg;

	if( unitv[Z] <= -1.0 )  angles[Z] = -90.0;
	else if( unitv[Z] >= 1.0 )  angles[Z] = 90.0;
	else angles[Z] = acos( unitv[Z] ) * radtodeg;

	/* fallback angle */
	if( unitv[Z] <= -1.0 )  unitv[Z] = -1.0;
	else if( unitv[Z] >= 1.0 )  unitv[Z] = 1.0;
	angles[4] = asin(unitv[Z]);

	/* rotation angle */
	/* For the tolerance below, on an SGI 4D/70, cos(asin(1.0)) != 0.0
	 * with an epsilon of +/- 1.0e-17, so the tolerance below was
	 * substituted for the original +/- 1.0e-20.
	 */
	if((f = cos(angles[4])) > 1.0e-16 || f < -1.0e-16 )  {
		f = unitv[X]/f;
		if( f <= -1.0 )
			angles[3] = 180;
		else if( f >= 1.0 )
			angles[3] = 0;
		else
			angles[3] = radtodeg * acos( f );
	}  else
		angles[3] = 0.0;
	if( unitv[Y] < 0 )
		angles[3] = 360.0 - angles[3];

	angles[4] *= radtodeg;
}
@


10.11
log
@Ooops, left in a debug print.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.10 92/03/18 00:33:07 mike Exp Locker: mike $ (BRL)";
d45 2
d152 8
d661 1
a661 1
/*	anaylze ars */
d667 1
a667 1
	rt_vls_printf(vp,"ARS analyze not implimented\n");
d670 1
a670 1
/*	anaylze spline */
d676 82
a757 1
	rt_vls_printf(vp,"SPLINE analyze not implimented\n");
@


10.10
log
@Moved geometry import/export routines to LIBRT, where they belong.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.9 92/03/18 00:27:33 mike Exp Locker: mike $ (BRL)";
a206 1
VPRINT("center_pt", center_pt);
@


10.9
log
@Now entirely free of db.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.8 92/03/18 00:24:04 mike Exp Locker: mike $ (BRL)";
a44 89

/****************************************************************/
/********************************* XXX move to librt ************/
/*
 *			R T _ D B _ G E T _ I N T E R N A L
 *
 *  Get an object from the database, and convert it into it's internal
 *  representation.
 */
int
rt_db_get_internal( ip, dp, dbip, mat )
struct rt_db_internal	*ip;
struct directory	*dp;
struct db_i		*dbip;
CONST mat_t		mat;
{
	struct rt_external	ext;
	register int		id;

	RT_INIT_EXTERNAL(&ext);
	RT_INIT_DB_INTERNAL(ip);
	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -2;		/* FAIL */

	id = rt_id_solid( &ext );
	if( rt_functab[id].ft_import( ip, &ext, mat ) < 0 )  {
		rt_log("rt_db_get_internal(%s):  solid import failure\n",
			dp->d_namep );
	    	if( ip->idb_ptr )  rt_functab[id].ft_ifree( ip );
		db_free_external( &ext );
		return -1;		/* FAIL */
	}
	db_free_external( &ext );
	RT_CK_DB_INTERNAL( ip );
	return 0;			/* OK */
}

/*
 *			R T _ D B _ P U T _ I N T E R N A L
 *
 *  Convert the internal representation of a solid to the external one,
 *  and write it into the database.
 *  On success only, the internal representation is freed.
 *
 *  Returns -
 *	<0	error
 *	 0	success
 */
int
rt_db_put_internal( dp, dbip, ip )
struct rt_db_internal	*ip;
struct directory	*dp;
struct db_i		*dbip;
{
	struct rt_external	ext;
	register int		id;

	RT_INIT_EXTERNAL(&ext);
	RT_CK_DB_INTERNAL( ip );

	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[ip->idb_type].ft_export( &ext, ip, 1.0 ) < 0 )  {
		rt_log("rt_db_put_internal(%s):  solid export failure\n",
			dp->d_namep);
		db_free_external( &ext );
		return -2;		/* FAIL */
	}

	if( db_put_external( &ext, dp, dbip ) < 0 )  {
		db_free_external( &ext );
		return -1;		/* FAIL */
	}

    	if( ip->idb_ptr )  rt_functab[ip->idb_type].ft_ifree( ip );
	RT_INIT_DB_INTERNAL(ip);
	db_free_external( &ext );
	return 0;			/* OK */
}

void
rt_db_free_internal( ip )
struct rt_db_internal	*ip;
{
	RT_CK_DB_INTERNAL( ip );
    	if( ip->idb_ptr )  rt_functab[ip->idb_type].ft_ifree( ip );
	RT_INIT_DB_INTERNAL(ip);
}

/****************************************************************/
@


10.8
log
@Modified to deal with ARBs in the "new way".
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.7 92/03/17 20:53:44 mike Exp Locker: mike $ (BRL)";
a27 1
#include "db.h"
a35 2
extern void	arb_center();

d648 3
d682 1
a682 1
					cgtype = RCC;
d684 1
a684 1
					cgtype = TRC;
d690 1
a690 1
				cgtype = REC;
d696 1
a696 1
		case RCC:
d704 1
a704 1
		case TRC:
d712 1
a712 1
		case REC:
a720 4
		case TEC:
			rt_vls_printf(vp,"TEC Cannot find areas and volume\n");
			return;
		case TGC:
@


10.7
log
@Moved findang() from edsol.c to anal.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.6 92/02/22 03:35:42 mike Exp Locker: mike $ (BRL)";
d138 4
a141 1
/*	Analyze command - prints loads of info about a solid
a145 2
static union record temp_rec;		/* local copy of es_rec */

a181 9
		/* XXX start old:  ARB only */
		temp_rec = es_rec;		/* struct copy */
		MAT4X3PNT(temp_rec.s.s_values, new_mat, es_rec.s.s_values);
		for(i=1; i<8; i++) {
			MAT4X3VEC( &temp_rec.s.s_values[i*3], new_mat,
					&es_rec.s.s_values[i*3] );
		}
		/* XXX end old way */

a197 3
		/* XXX old way */
		if( db_get( dbip, ndp, &temp_rec, 0, 1) < 0 )  READ_ERR_return;

d252 1
a252 1
static int nedge[5][24] = {
d260 3
a262 2
static int	type;	/* comgeom type, for ARB subs */

d264 1
a264 1
arb_anal(vp)
d266 1
d268 3
a270 2
	register int i;
	point_t		cpt;
d273 3
d277 7
d285 1
a285 1
	if( (type = type_arb( &temp_rec )) == 0 ) {
a289 5
	/* got the arb - convert to point notation */
	for(i=3; i<24; i+=3) {
		VADD2( &temp_rec.s.s_values[i], &temp_rec.s.s_values[i], temp_rec.s.s_values );
	}

d292 1
a292 7
	if( type < 0 )
		type *= -1;
	if(type == RPP || type == BOX)
		type = ARB8;
	if(type == RAW)
		type = ARB6;
	type -= 4;
d298 3
a300 1
	arb_center( cpt, temp_rec.s.s_values, type+4 );
d302 1
a302 1
		tot_area += anal_face( vp, i, cpt  );
d311 14
a324 2
	if( (type+4) == ARB4 ) {
		VMOVE(&temp_rec.s.s_values[9], &temp_rec.s.s_values[12]);
a325 9
	if( (type+4) == ARB6 ) {
		VMOVE(&temp_rec.s.s_values[15], &temp_rec.s.s_values[18]);
	}
	for(i=0; i<12; i++) {
		anal_edge( vp, i );
		if( nedge[type][i*2] == -1 )
			break;
	}

a327 7
	/* put records back */
	if( (type+4) == ARB4 ) {
		VMOVE(&temp_rec.s.s_values[9], &temp_rec.s.s_values[0]);
	}
	if( (type+4) == ARB6 ) {
		VMOVE(&temp_rec.s.s_values[15], &temp_rec.s.s_values[12]);
	}
d330 1
a330 1
		tot_vol += find_vol( i );
a337 2

	return;
d341 1
a341 1
static int prface[5][6] = {
d349 1
a349 1
static int farb4[6][4] = {
d362 1
a362 1
anal_face( vp, face, cpt )
d364 5
a368 2
int face;
vect_t cpt;				/* reference center point */
d371 6
a376 4
	static int a, b, c, d;		/* 4 points of face to look at */
	static fastf_t angles[5];	/* direction cosines, rot, fb */
	static fastf_t temp, area[2], len[6];
	static vect_t v_temp;
d388 3
a390 2
	if( planeqn(6, a, b, c, &temp_rec.s) ) {
		rt_vls_printf(vp,"| %d%d%d%d    ***NOT A PLANE***                                          |\n",
d402 1
a402 1
	if( (es_peqn[6][3] - VDOT(cpt, &es_peqn[6][0])) < 0.0 ){
d404 1
a404 1
			es_peqn[6][i] *= -1.0;
d407 1
a407 1
	/* es_peqn[6][] contains normalized eqn of plane of this face
d410 1
a410 1
	findang( angles, &es_peqn[6][0] );
d416 1
a416 1
		VSUB2(v_temp, &temp_rec.s.s_values[k*3], &temp_rec.s.s_values[j*3]);
d423 1
a423 1
		VSUB2(v_temp, &temp_rec.s.s_values[k*3], &temp_rec.s.s_values[j*3]);
d438 2
a439 2
		es_peqn[6][0],es_peqn[6][1],es_peqn[6][2],
		es_peqn[6][3]*base2local);
d447 5
a451 3
anal_edge( vp, edge )
struct rt_vls	*vp;
int edge;
d475 3
a477 2
	VSUB2(v_temp, &temp_rec.s.s_values[b*3], &temp_rec.s.s_values[a*3]);
	rt_vls_printf(vp,"  |  %d%d %9.3f",a+1,b+1,MAGNITUDE(v_temp)*base2local);
a480 1

d486 4
a489 2
find_vol( loc )
int loc;
d493 2
a494 1
	vect_t v_temp;
d504 2
a505 1
	if( planeqn(6, a, b, c, &temp_rec.s) != 0 )
d509 2
a510 2
	height = fabs(es_peqn[6][3] - VDOT(&es_peqn[6][0], &temp_rec.s.s_values[d*3]));
	VSUB2(v_temp, &temp_rec.s.s_values[b*3], &temp_rec.s.s_values[a*3]);
d512 1
a512 1
	VSUB2(v_temp, &temp_rec.s.s_values[c*3], &temp_rec.s.s_values[a*3]);
d514 1
a514 1
	VSUB2(v_temp, &temp_rec.s.s_values[c*3], &temp_rec.s.s_values[b*3]);
@


10.6
log
@Cleaned up arb stuff just a bit to eliminate some global vars.
@
text
@d6 1
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.5 92/02/22 02:04:18 mike Exp Locker: mike $ (BRL)";
d762 53
@


10.5
log
@Converted everything except ARB handling to new import/export interface.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.4 92/02/22 01:20:57 mike Exp Locker: mike $ (BRL)";
d40 1
a40 1
static void	anal_face();
d42 1
a42 1
static void	find_vol();
a142 2
fastf_t	tot_vol, tot_area;
int type;	/* comgeom type */
d270 2
d277 3
a279 1
	static vect_t cpt;
d308 1
a308 1
		anal_face( vp, i, cpt  );
d340 1
a340 1
		find_vol( i );
d345 2
a346 1
	rt_vls_printf(vp,"      |          %18.3f gal                               |\n",tot_vol/3787878.79);
d373 1
a373 1
static void
d384 1
d392 1
a392 1
		return;
d398 1
a398 1
		return;
d438 1
a438 1
		tot_area += area[i];
d448 1
d489 1
a489 1
static void
d505 2
a506 1
	vol = 0.0;	/* volume of this arb */
d508 12
a519 14
	if( planeqn(6, a, b, c, &temp_rec.s) == 0 ) {
		/* have a good arb4 - find its volume */
		height = fabs(es_peqn[6][3] - VDOT(&es_peqn[6][0], &temp_rec.s.s_values[d*3]));
		VSUB2(v_temp, &temp_rec.s.s_values[b*3], &temp_rec.s.s_values[a*3]);
		len[0] = MAGNITUDE(v_temp);
		VSUB2(v_temp, &temp_rec.s.s_values[c*3], &temp_rec.s.s_values[a*3]);
		len[1] = MAGNITUDE(v_temp);
		VSUB2(v_temp, &temp_rec.s.s_values[c*3], &temp_rec.s.s_values[b*3]);
		len[2] = MAGNITUDE(v_temp);
		temp = 0.5 * (len[0] + len[1] + len[2]);
		areabase = sqrt(temp * (temp-len[0]) * (temp-len[1]) * (temp-len[2]));
		vol = areabase * height / 3.0;
	}
	tot_vol += vol;
d563 1
@


10.4
log
@Temp. added new rt_db_get_internal() and put routines here.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.3 92/02/21 23:52:17 mike Exp Locker: mike $ (BRL)";
d30 1
a35 2
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */
d61 1
a61 1
mat_t			mat;
d125 10
d147 3
a149 1
f_analyze()
d154 2
a155 1
	struct rt_vls	v;
d159 1
a159 1
	if( numargs == 1 ) {
d161 1
d163 2
a164 1
			(void)printf("Analyze: cannot analyze evaluated region\n");
a179 1
		temp_rec = es_rec;	/* XXX old:  ARB only */
d181 3
d189 8
a196 1
		do_anal(&v);
d198 1
d203 2
a204 2
	for( i = 1; i < numargs; i++ )  {
		if( (ndp = db_lookup( dbip,  cmd_args[i], LOOKUP_NOISY )) == DIR_NULL )
d207 1
d210 2
a211 2
		if(temp_rec.u_id == ID_P_HEAD) {
			(void)printf("Analyze cannot handle polygons\n");
a213 7
		if(temp_rec.u_id != ID_SOLID && 
		   temp_rec.u_id != ID_ARS_A) {
			(void)printf("%s: not a solid \n",cmd_args[i]);
			return;
		}
		if(temp_rec.s.s_cgtype < 0)
			temp_rec.s.s_cgtype *= -1;
a214 9
		if( temp_rec.s.s_type == GENARB8 ) {
			/* find the specific arb type */
			if( (type = type_arb( &temp_rec )) == 0 ) {
				(void)printf("%s: BAD ARB\n",temp_rec.s.s_name);
				return;
			}
			temp_rec.s.s_cgtype = type;
		}

d216 1
a216 1
		do_anal(&v);
d218 2
d224 1
a224 1
/* Analyze solid in temp_rec */
d226 3
a228 2
do_anal(vp)
struct rt_vls	*vp;
d230 1
a230 1
	switch( temp_rec.s.s_type ) {
d232 4
a235 2
	case ARS:
		ars_anal(vp);
d238 2
a239 2
	case GENARB8:
		arb_anal(vp);
d242 2
a243 2
	case GENTGC:
		tgc_anal(vp);
d246 2
a247 2
	case GENELL:
		ell_anal(vp);
d250 2
a251 2
	case TOR:
		tor_anal(vp);
d255 2
a256 1
		rt_vls_printf(vp,"Analyze: unknown solid type\n");
d279 6
a291 2
	/* XXX compute cgtype of ARB */
	type = temp_rec.s.s_cgtype;
d523 1
a523 1
tor_anal(vp)
d525 1
d527 1
d530 1
a530 2
	r1 = MAGNITUDE( &temp_rec.s.s_values[6] );
	r2 = MAGNITUDE( &temp_rec.s.s_values[3] );
d532 3
d538 4
a541 3
	rt_vls_printf(vp,"Vol = %.4f (%.4f gal)   Surface Area = %.4f\n",
			vol*base2local*base2local*base2local,vol/3787878.79,
			sur_area*base2local*base2local);
d551 1
a551 1
ell_anal(vp)
d553 1
d555 1
d560 1
a560 3
	ma = MAGNITUDE( &temp_rec.s.s_values[3] );
	mb = MAGNITUDE( &temp_rec.s.s_values[6] );
	mc = MAGNITUDE( &temp_rec.s.s_values[9] );
d562 4
d569 3
a571 1
	rt_vls_printf(vp,"Volume = %.4f (%.4f gal)",vol*base2local*base2local*base2local,vol/3787878.79);
d649 1
a649 1
tgc_anal(vp)
d651 1
d653 1
d659 3
a661 1
	VCROSS(axb, &temp_rec.s.s_values[6], &temp_rec.s.s_values[9]);
d663 5
a667 5
	ma = MAGNITUDE( &temp_rec.s.s_values[6] );
	mb = MAGNITUDE( &temp_rec.s.s_values[9] );
	mc = MAGNITUDE( &temp_rec.s.s_values[12] );
	md = MAGNITUDE( &temp_rec.s.s_values[15] );
	mh = MAGNITUDE( &temp_rec.s.s_values[3] );
d670 1
a670 1
	if( fabs(fabs(VDOT(&temp_rec.s.s_values[3],axb)) - (mh*maxb)) < .00001 ) {
d742 1
a742 1
ars_anal(vp)
d744 1
d751 1
a751 1
spline_anal(vp)
d753 1
@


10.3
log
@Modified to use VLS package.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.2 91/12/18 06:38:33 mike Exp Locker: mike $ (BRL)";
d49 17
d67 61
d149 4
a153 1

d155 1
a155 3
			temp_rec = es_rec;
			/* just to make sure */
			mat_idn( modelchanges );
a158 4
			if(illump->s_Eflag) {
				(void)printf("Analyze: cannot analyze evaluated region\n");
				return;
			}
a159 1
			temp_rec = es_rec;
d166 1
d271 1
@


10.2
log
@Added output file descriptor to do_list().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 10.1 91/10/12 06:43:03 mike Rel4_0 Locker: mike $ (BRL)";
d65 1
d67 2
d98 2
a99 1
		do_anal();
d132 2
a133 1
		do_anal();
d140 2
a141 1
do_anal()
d146 1
a146 1
		ars_anal();
d150 1
a150 1
		arb_anal();
d154 1
a154 1
		tgc_anal();
d158 1
a158 1
		ell_anal();
d162 1
a162 1
		tor_anal();
d166 1
a166 1
		(void)printf("Analyze: unknown solid type\n");
d183 2
a184 1
arb_anal()
d206 3
a208 3
	(void)printf("\n------------------------------------------------------------------------------\n");
	(void)printf("| FACE |   ROT     FB  |        PLANE EQUATION            |   SURFACE AREA   |\n");
	(void)printf("|------|---------------|----------------------------------|------------------|\n");
d211 1
a211 1
		anal_face( i, cpt  );
d213 1
a213 1
	(void)printf("------------------------------------------------------------------------------\n");
d216 2
a217 2
	(void)printf("    | EDGE     LEN   | EDGE     LEN   | EDGE     LEN   | EDGE     LEN   |\n");
	(void)printf("    |----------------|----------------|----------------|----------------|\n  ");
d227 1
a227 1
		anal_edge( i );
d232 1
a232 1
	(void)printf("  ---------------------------------------------------------------------\n");
d245 1
a245 1
	(void)printf("      | Volume = %18.3f    Surface Area = %15.3f |\n",
d248 2
a249 2
	(void)printf("      |          %18.3f gal                               |\n",tot_vol/3787878.79);
	(void)printf("      -----------------------------------------------------------------\n");
d276 2
a277 1
anal_face( face, cpt )
d297 1
a297 1
		(void)printf("| %d%d%d%d    ***NOT A PLANE***                                          |\n",
d342 2
a343 2
	(void)printf("| %4d |",prface[type][face]);
	(void)printf(" %6.2f %6.2f | %6.3f %6.3f %6.3f %11.3f |",
d347 1
a347 1
	(void)printf("   %13.3f  |\n",
d353 2
a354 1
anal_edge( edge )
d368 1
a368 1
			(void)printf("  |                |                |                |\n  ");
d372 1
a372 1
			(void)printf("  |                |                |\n  ");
d375 1
a375 1
		(void)printf("  |                |\n  ");
d380 1
a380 1
	(void)printf("  |  %d%d %9.3f",a+1,b+1,MAGNITUDE(v_temp)*base2local);
d383 1
a383 1
		(void)printf("  |\n  ");
d428 2
a429 1
tor_anal()
d439 1
a439 1
	(void)printf("Vol = %.4f (%.4f gal)   Surface Area = %.4f\n",
d451 2
a452 1
ell_anal()
d465 1
a465 1
	(void)printf("Volume = %.4f (%.4f gal)",vol*base2local*base2local*base2local,vol/3787878.79);
d470 1
a470 1
		(void)printf("   Surface Area = %.4f\n",
d522 1
a522 1
		(void)printf("   Cannot find surface area\n");
d536 1
a536 1
	(void)printf("   Surface Area = %.4f\n",
d543 2
a544 1
tgc_anal()
d586 2
a587 1
		break;
d594 2
a595 1
		break;
d603 2
a604 1
		break;
d607 2
d611 2
a612 2
			(void)printf("Cannot find areas and volume\n");
		return;
d616 1
a616 1
	(void)printf("Surface Areas:  base(AxB)=%.4f  top(CxD)=%.4f  side=%.4f\n",
d620 1
a620 1
	(void)printf("Total Surface Area=%.4f    Volume=%.4f (%.4f gal)\n",
d623 1
a623 1

d632 2
a633 1
ars_anal()
d635 1
a635 1
(void)printf("ARS analyze not implimented\n");
d640 2
a641 1
spline_anal()
d643 1
a643 1
(void)printf("SPLINE analyze not implimented\n");
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 9.6 91/01/12 08:25:42 mike Exp $ (BRL)";
d127 1
a127 1
		do_list(ndp);
@


9.6
log
@externs.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 9.5 90/12/08 00:30:50 mike Exp $ (BRL)";
@


9.5
log
@Added error checking around calls to db_*() routines
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 9.4 90/12/07 01:04:52 mike Exp $ (BRL)";
a33 2

extern int	atoi();
@


9.4
log
@lint
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 9.3 90/12/07 01:03:28 mike Exp $ (BRL)";
d106 1
a106 1
		db_get( dbip, ndp, &temp_rec, 0, 1);
@


9.3
log
@STDC fix
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/anal.c,v 9.2 89/10/27 22:50:09 phil Exp $ (BRL)";
d520 1
a520 2
	}
	if( type == OBLATE ) {
d523 2
a528 2

	return;
@


9.2
log
@Always analyze according to outward normal (from Dan Dender)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 9.1 89/05/19 06:01:39 phil Locked $ (BRL)";
d636 1
a636 1
#if defined(SYSV) || BSD >= 43
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 8.5 89/04/06 20:38:19 mike Exp $ (BRL)";
d39 1
d51 1
d182 1
d200 1
a200 1
	/* analyze each face */
d204 1
d206 1
a206 1
		anal_face( i );
d271 1
a271 1
anal_face( face )
d273 1
d294 12
@


8.5
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 8.4 89/03/06 17:45:34 mike Locked $ (BRL)";
@


8.4
log
@BSD43 needs acos() protection by matherr() as well.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 8.3 89/03/06 17:25:43 mike Locked $ (BRL)";
d31 1
@


8.3
log
@ansii
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 8.2 88/12/06 00:48:29 mike Locked $ (BRL)";
d618 1
a618 1
#ifdef SYSV
@


8.2
log
@Converted to new db_*() routines.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/anal.c,v 1.2 88/10/23 13:55:27 mike Exp $ (BRL)";
d618 4
a621 1
matherr()
d625 1
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 7.2 87/11/05 05:03:06 mike Exp $ (BRL)";
d29 1
a30 1
#include "./objdir.h"
d100 1
a100 1
		if( (ndp = lookup( cmd_args[i], LOOKUP_NOISY )) == DIR_NULL )
d103 1
a103 1
		db_getrec(ndp, &temp_rec, 0);
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 7.1 87/11/02 23:58:15 mike Rel $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 6.1 87/07/11 08:01:19 mike Rel $ (BRL)";
d25 1
a25 1
#include "./machine.h"	/* special copy */
d55 1
a55 1
float	tot_vol, tot_area;
d271 2
a272 2
	static float angles[5];	/* direction cosines, rot, fb */
	static float temp, area[2], len[6];
d319 6
a324 3
	(void)printf(" %6.2f %6.2f | %6.3f %6.3f %6.3f %11.3f |",angles[3],angles[4],
			es_peqn[6][0],es_peqn[6][1],es_peqn[6][2],es_peqn[6][3]*base2local);
	(void)printf("   %13.3f  |\n",(area[0]+area[1])*base2local*base2local);
d369 1
a369 1
	float vol, height, len[3], temp, areabase;
d405 1
a405 1
	float r1, r2, vol, sur_area;
d427 3
a429 3
	float ma, mb, mc;
	float ecc, major, minor;
	float vol, sur_area;
d519 2
a520 2
	float maxb, ma, mb, mc, md, mh;
	float area_base, area_top, area_side, vol;
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 5.1 87/06/24 22:17:28 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 4.2 87/02/13 00:05:06 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 4.1 86/12/29 03:18:47 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 2.9 86/09/09 21:40:31 mike Exp $ (BRL)";
@


2.9
log
@Dender:  added one extra decimal place to analyze output
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 2.8 86/08/12 06:46:16 mike Exp $ (BRL)";
@


2.8
log
@Changed #includes for CC -I../h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 2.7 85/09/14 05:33:31 mike Exp $ (BRL)";
d197 3
a199 3
	(void)printf("\n--------------------------------------------------------------------------\n");
	(void)printf("| FACE |   ROT     FB  |        PLANE EQUATION        |   SURFACE AREA   |\n");
	(void)printf("|------|---------------|------------------------------|------------------|\n");
d203 1
a203 1
	(void)printf("--------------------------------------------------------------------------\n");
d206 2
a207 2
	(void)printf("    | EDGE     LEN  | EDGE     LEN  | EDGE     LEN  | EDGE     LEN  |\n");
	(void)printf("    |---------------|---------------|---------------|---------------|\n  ");
d222 1
a222 1
	(void)printf("  -----------------------------------------------------------------\n");
d235 1
a235 1
	(void)printf("    | Volume = %18.3f    Surface Area = %15.3f |\n",
d238 2
a239 2
	(void)printf("    |          %18.3f gal                               |\n",tot_vol/3787878.79);
	(void)printf("    -----------------------------------------------------------------\n");
d319 1
a319 1
	(void)printf(" %6.2f %6.2f | %5.2f %5.2f %5.2f %10.2f |",angles[3],angles[4],
d340 1
a340 1
			(void)printf("  |               |               |               |\n  ");
d344 1
a344 1
			(void)printf("  |               |               |\n  ");
d347 1
a347 1
		(void)printf("  |               |\n  ");
d352 1
a352 1
	(void)printf("  |  %d%d %8.2f",a+1,b+1,MAGNITUDE(v_temp)*base2local);
@


2.7
log
@Lint-inspired cleanup.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 2.6 85/08/26 17:15:56 mike Exp $ (BRL)";
d26 7
a32 7
#include "../h/vmath.h"
#include "../h/db.h"
#include "sedit.h"
#include "ged.h"
#include "objdir.h"
#include "solid.h"
#include "dm.h"
@


2.6
log
@Latest solid editing improvements from KAA.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 2.4 85/07/30 01:17:00 mike Exp $ (BRL)";
d275 4
a278 4
	a = faces[type][face*4+0];
	b = faces[type][face*4+1];
	c = faces[type][face*4+2];
	d = faces[type][face*4+3];
d297 2
a298 2
		j = faces[type][face*4+i];
		k = faces[type][face*4+i+1];
d303 1
a303 1
	j = faces[type][face*4+0];
d305 1
a305 1
		k = faces[type][face*4+i];
d519 1
a519 1
	int type = 0;
d537 1
a537 1
					type = RCC;
d539 1
a539 1
					type = TRC;
d545 1
a545 1
				type = REC;
d549 1
a549 1
	switch( type ) {
@


2.5
log
@Changed to use common ../h/vmath.h
@
text
@d116 10
@


2.4
log
@Change to support new ARB editing.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 2.3 85/03/15 05:02:35 mike Exp $ (BRL)";
d23 4
a26 3
#include	<math.h>
#include	<stdio.h>
#include "ged_types.h"
a32 1
#include "../h/vmath.h"
@


2.3
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 2.2 85/03/12 05:23:18 mike Exp $ (BRL)";
d56 1
d114 2
d155 10
d177 9
d198 9
a206 1
	for(i=0; i<12; i++)
d208 3
d214 7
d225 4
a228 3
	(void)printf("    | Surface Area = %15.3f    Volume = %18.3f |\n",
			tot_area*base2local*base2local,
			tot_vol*base2local*base2local*base2local);
d234 7
a240 8
/* face definition array */
static int nface[6][4] = {
	{0, 1, 2, 3},
	{4, 5, 6, 7},
	{0, 4, 7, 3},
	{1, 2, 6, 5},
	{3, 2, 6, 7},
	{0, 1, 5, 4},
a241 17

/* edge definition array */
static int nedge[12][2] = {
	{0, 1},
	{1, 2},
	{2, 3},
	{3, 0},
	{0, 4},
	{4, 5},
	{5, 1},
	{5, 6},
	{6, 7},
	{7, 4},
	{7, 3},
	{2, 6},
};

d265 4
a268 4
	a = nface[face][0];
	b = nface[face][1];
	c = nface[face][2];
	d = nface[face][3];
d270 3
d274 1
a274 1
	if( plane(a, b, c, d, &temp_rec.s) >= 0 ) {
d280 1
a280 1
	/* es_plant[] contains normalized eqn of plane of this face
d283 1
a283 1
	findang( angles, es_plant );
d287 2
a288 2
		j = nface[face][i];
		k = nface[face][i+1];
d293 1
a293 1
	j = nface[face][0];
d295 1
a295 1
		k = nface[face][i];
d308 1
a308 1
	(void)printf("| %d%d%d%d |",a+1,b+1,c+1,d+1);
d310 1
a310 1
			es_plant[0],es_plant[1],es_plant[2],es_plant[3]*base2local);
d322 2
a323 2
	a = nedge[edge][0];
	b = nedge[edge][1];
d325 16
d369 1
a369 1
	if( planeqn(a, b, c, &temp_rec.s) ) {
d371 1
a371 1
		height = fabs(es_plant[3] - VDOT(es_plant, &temp_rec.s.s_values[d*3]));
d400 2
a401 2
	(void)printf("Vol = %.4f   Surface Area = %.4f\n",
			vol*base2local*base2local*base2local,
a415 1
	int type = 0;
d422 2
d425 1
a425 1
	(void)printf("Volume = %.4f",vol*base2local*base2local*base2local);
d575 1
a575 1
	(void)printf("Total Surface Area=%.4f    Volume=%.4f\n",
d577 1
a577 1
			vol*base2local*base2local*base2local);
@


2.2
log
@Paul Stay's Spline code.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 2.1 85/03/11 23:53:28 mike Prod $ (BRL)";
d39 1
d60 1
a60 1
	struct directory *ndp;
d62 1
a62 1
	int i;
d72 1
a72 1
		break;
d81 1
a81 1
		break;
d85 1
a85 1
		return;
d93 3
a95 4
	} else {
		/* use the name that was input */
		if( (ndp = lookup( cmd_args[1], LOOKUP_NOISY )) == DIR_NULL )
			return;
d97 5
d110 1
a110 1
			(void)printf("%s: not a solid \n",cmd_args[1]);
d113 2
a114 1
		f_list();
d116 1
d118 5
a122 1
	/* Now have a solid in temp_rec */
d125 2
a126 2
		case ARS:
			ars_anal();
d129 2
a130 2
		case GENARB8:
			arb_anal();
d133 2
a134 2
		case GENTGC:
			tgc_anal();
d137 2
a138 2
		case GENELL:
			ell_anal();
d141 2
a142 2
		case TOR:
			tor_anal();
d145 3
a147 3
		default:
			(void)printf("Analyze: unknown solid type\n");
		return;
a148 1

d155 1
a155 1
	int i;
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 1.6 85/02/14 01:38:38 mike Exp $ (BRL)";
d539 6
@


1.6
log
@Added matherr() handler for silence.
@
text
@d5 1
d7 4
a10 2
 *
 * Source -
d14 4
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: anal.c,v 1.5 85/02/14 00:18:54 mike Exp $ (BRL)";
d26 1
a26 1
#include "db.h"
d29 1
a29 1
#include "dir.h"
d32 1
a32 1
#include "vmath.h"
@


1.5
log
@Latest KAA version.
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: anal.c,v 1.4 85/02/01 17:36:24 mike Exp $ (BRL)";
d533 10
@


1.4
log
@minor format changes.
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: anal.c,v 1.3 85/02/01 15:40:13 mike Exp $ (BRL)";
d32 1
d35 5
d41 1
a41 1
/*	Analyze command - prints loads of info about an arb
d43 1
a43 1
 *		if 'name' is missing using arb being edited
d47 1
a60 4
			if(es_gentype != GENARB8) {
				(void)printf("Analyze: solid must be an arb\n");
				return;
			}
d64 1
a64 1
			break;
d71 1
d73 1
a73 1
			break;
d76 2
a77 2
			state_err( "Default ARB Analyze" );
			return;
d92 2
a93 3
		if(temp_rec.u_id != ID_SOLID || 
		   temp_rec.s.s_type != GENARB8) {
			(void)printf("%s: not a solid or not an arb\n",cmd_args[1]);
d96 6
d104 36
d145 2
d148 3
a150 3
	(void)printf("\n----------------------------------------------------------------------\n");
	(void)printf("| FACE |   ROT     FB  |        PLANE EQUATION        | SURFACE AREA |\n");
	(void)printf("|------|---------------|------------------------------|--------------|\n");
d154 1
a154 1
	(void)printf("----------------------------------------------------------------------\n");
d157 2
a158 2
	(void)printf("  | EDGE     LEN  | EDGE     LEN  | EDGE     LEN  | EDGE     LEN  |\n");
	(void)printf("  |---------------|---------------|---------------|---------------|\n");
d163 11
d202 11
d247 1
a247 1
		len[i] = MAGNITUDE( v_temp ) * base2local;
d254 1
a254 1
		len[((i*2)-1)] = MAGNITUDE( v_temp ) * base2local;
d262 1
d268 1
a268 1
	(void)printf("   %9.3f  |\n",(area[0]+area[1])*base2local);
d283 1
a283 1
	(void)printf("  |  %d%d   %6.2f",a+1,b+1,MAGNITUDE(v_temp)*base2local);
d286 1
a286 1
		(void)printf("  |\n");
d288 242
@


1.3
log
@Improved output formatting by KAA
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d213 1
a213 1
	(void)printf("  |  %d%d   %7.2f ",a+1,b+1,MAGNITUDE(v_temp)*base2local);
d216 1
a216 1
		(void)printf("|\n");
@


1.2
log
@Put titles back.
@
text
@d6 5
a10 1
 * The U. S. Army Ballistic Research Laboratory
d12 3
d101 3
a103 1
	(void)printf("FACE     DIR COSINES   ROT   FB      EQN COEFs       SURFACE AREA\n");
d107 2
d110 2
a111 1
	(void)printf("EDGE   LENGTH\n");
d114 2
d153 1
a153 1
	static float temp, area[2], len[5];
d163 1
a163 1
		(void)printf("Analyze: face %d%d%d%d not a plane\n",
d195 4
a198 6
	(void)printf("%d%d%d%d  ",a+1,b+1,c+1,d+1);
	(void)printf("%5.2f %5.2f %5.2f  %5.2f %5.2f    ",angles[0],angles[1],
			angles[2],angles[3],angles[4],angles[5]);
	(void)printf("%.4f %.4f %.4f %.4f   ",es_plant[0],es_plant[1],
			es_plant[2],es_plant[3]);
	(void)printf("%.3f\n",area[0]+area[1]);
d213 1
d215 3
a217 3
	(void)printf(" %d%d    %10.2f\n",
		a+1, b+1,
		MAGNITUDE(v_temp)*base2local );
d219 2
@


1.1
log
@Initial revision
@
text
@d65 1
a65 1
			state_err( "ARB Analyze" );
a93 1
/*
a94 1
*/
a98 1
/*
a99 1
*/
@
