head	11.124;
access;
symbols
	ansi-20040405-merged:11.119.2.2
	postmerge-20040405-ansi:11.122
	premerge-20040404-ansi:11.121
	postmerge-autoconf:11.121
	autoconf-freeze:11.119.10.3
	premerge-autoconf:11.121
	postmerge-20040315-windows:11.121
	premerge-20040315-windows:11.120
	windows-20040315-freeze:11.119.4.2
	autoconf-20031203:11.119
	autoconf-20031202:11.119
	autoconf-branch:11.119.0.10
	phong-branch:11.119.0.8
	photonmap-branch:11.119.0.6
	rel-6-1-DP:11.119
	windows-branch:11.119.0.4
	rel-6-0-2:11.116
	ansi-branch:11.119.0.2
	rel-6-0-1-branch:11.116.0.2
	hartley-6-0-post:11.118
	hartley-6-0-pre:11.117
	rel-6-0-1:11.116
	rel-6-0:11.116
	rel-5-4:11.92.2.1
	offsite-5-3-pre:11.105
	rel-5-3:11.92.2.1
	rel-5-2:11.92
	rel-5-1-branch:11.92.0.2
	rel-5-1:11.92
	rel-5-0:11.81
	rel-5-0-beta:11.78
	rel-4-5:11.62
	ctj-4-5-post:11.50
	ctj-4-5-pre:11.50
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.6;
locks; strict;
comment	@ * @;


11.124
date	2004.05.21.17.47.40;	author morrison;	state dead;
branches;
next	11.123;

11.123
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.122;

11.122
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.121;

11.121
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	11.120;

11.120
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.119;

11.119
date	2002.08.20.17.08.22;	author jra;	state Exp;
branches
	11.119.2.1
	11.119.4.1
	11.119.10.1;
next	11.118;

11.118
date	2002.08.15.20.55.33;	author hartley;	state Exp;
branches;
next	11.117;

11.117
date	2002.08.14.17.24.39;	author jra;	state Exp;
branches;
next	11.116;

11.116
date	2002.01.09.19.56.06;	author jra;	state Exp;
branches;
next	11.115;

11.115
date	2002.01.08.20.58.44;	author jra;	state Exp;
branches;
next	11.114;

11.114
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	11.113;

11.113
date	2001.08.27.19.00.50;	author jra;	state Exp;
branches;
next	11.112;

11.112
date	2001.06.01.19.23.23;	author bparker;	state Exp;
branches;
next	11.111;

11.111
date	2001.05.17.20.05.34;	author morrison;	state Exp;
branches;
next	11.110;

11.110
date	2001.05.08.20.20.58;	author jra;	state Exp;
branches;
next	11.109;

11.109
date	2001.04.05.19.35.44;	author morrison;	state Exp;
branches;
next	11.108;

11.108
date	2001.04.02.21.38.19;	author morrison;	state Exp;
branches;
next	11.107;

11.107
date	2001.03.31.01.57.21;	author morrison;	state Exp;
branches;
next	11.106;

11.106
date	2001.03.23.22.05.34;	author jra;	state Exp;
branches;
next	11.105;

11.105
date	2000.11.17.06.02.01;	author mike;	state Exp;
branches;
next	11.104;

11.104
date	2000.11.14.18.09.46;	author jra;	state Exp;
branches;
next	11.103;

11.103
date	2000.10.24.19.05.05;	author mike;	state Exp;
branches;
next	11.102;

11.102
date	2000.10.20.05.04.38;	author mike;	state Exp;
branches;
next	11.101;

11.101
date	2000.09.21.02.46.51;	author mike;	state Exp;
branches;
next	11.100;

11.100
date	2000.09.09.04.30.55;	author mike;	state Exp;
branches;
next	11.99;

11.99
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	11.98;

11.98
date	2000.09.07.02.43.21;	author mike;	state Exp;
branches;
next	11.97;

11.97
date	2000.08.19.03.10.14;	author mike;	state Exp;
branches;
next	11.96;

11.96
date	2000.06.30.19.58.09;	author mike;	state Exp;
branches;
next	11.95;

11.95
date	2000.06.28.17.39.41;	author mike;	state Exp;
branches;
next	11.94;

11.94
date	2000.06.28.16.36.42;	author mike;	state Exp;
branches;
next	11.93;

11.93
date	2000.06.27.17.36.09;	author mike;	state Exp;
branches;
next	11.92;

11.92
date	2000.06.02.00.42.55;	author mike;	state Exp;
branches
	11.92.2.1;
next	11.91;

11.91
date	2000.05.26.16.09.51;	author bparker;	state Exp;
branches;
next	11.90;

11.90
date	2000.05.26.14.00.42;	author bparker;	state Exp;
branches;
next	11.89;

11.89
date	2000.01.14.22.59.22;	author bparker;	state Exp;
branches;
next	11.88;

11.88
date	2000.01.04.17.58.21;	author bparker;	state Exp;
branches;
next	11.87;

11.87
date	99.12.30.19.14.13;	author jra;	state Exp;
branches;
next	11.86;

11.86
date	99.12.29.23.23.22;	author mike;	state Exp;
branches;
next	11.85;

11.85
date	99.11.26.23.03.32;	author mike;	state Exp;
branches;
next	11.84;

11.84
date	99.11.24.14.26.41;	author jra;	state Exp;
branches;
next	11.83;

11.83
date	99.11.08.16.48.40;	author bparker;	state Exp;
branches;
next	11.82;

11.82
date	99.11.08.15.20.19;	author jra;	state Exp;
branches;
next	11.81;

11.81
date	99.09.01.18.55.09;	author bparker;	state Exp;
branches;
next	11.80;

11.80
date	99.07.07.15.37.39;	author bparker;	state Exp;
branches;
next	11.79;

11.79
date	99.07.02.22.18.38;	author mike;	state Exp;
branches;
next	11.78;

11.78
date	99.06.01.15.21.17;	author jra;	state Exp;
branches;
next	11.77;

11.77
date	99.05.15.08.04.26;	author mike;	state Exp;
branches;
next	11.76;

11.76
date	99.05.11.15.07.30;	author mike;	state Exp;
branches;
next	11.75;

11.75
date	99.05.10.22.01.38;	author mike;	state Exp;
branches;
next	11.74;

11.74
date	99.01.21.18.31.21;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	99.01.12.18.17.05;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	98.12.17.04.19.11;	author mike;	state Exp;
branches;
next	11.71;

11.71
date	98.11.06.22.32.39;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	98.10.21.16.49.31;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	98.09.14.15.59.19;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	98.06.25.13.31.55;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	98.06.24.18.34.45;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	98.06.24.17.57.25;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	98.05.15.14.47.25;	author bparker;	state Exp;
branches;
next	11.64;

11.64
date	98.05.13.13.08.34;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	98.03.19.17.50.03;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	97.12.23.10.05.52;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	97.12.23.09.21.20;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	97.12.18.06.29.14;	author mike;	state Exp;
branches;
next	11.59;

11.59
date	97.12.16.14.34.41;	author pjt;	state Exp;
branches;
next	11.58;

11.58
date	97.11.19.21.48.18;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	97.09.08.18.21.17;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	97.09.03.14.19.02;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	97.08.22.22.38.22;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	97.08.22.22.31.08;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	97.07.22.13.44.05;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	97.06.25.02.33.20;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	97.04.14.12.28.27;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.45;

11.45
date	97.02.25.14.42.00;	author jra;	state Exp;
branches;
next	11.44;

11.44
date	97.02.14.13.38.08;	author jra;	state Exp;
branches;
next	11.43;

11.43
date	97.01.29.05.23.53;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	97.01.08.17.03.48;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	97.01.02.22.12.41;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	97.01.02.19.32.57;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	96.12.30.20.16.47;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	96.12.04.03.27.56;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	96.10.18.13.53.51;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	96.10.04.15.02.32;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.10.03.20.23.10;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.09.23.18.31.03;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.09.17.21.20.57;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.08.21.13.52.38;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	96.07.15.20.38.02;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.07.03.13.37.05;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	96.06.03.12.48.06;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	95.11.29.23.54.12;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	95.11.29.21.21.31;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	95.11.29.02.16.04;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	95.08.29.14.50.55;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	95.07.27.21.26.20;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	95.07.25.17.48.19;	author gdurf;	state Exp;
branches;
next	11.15;

11.15
date	95.03.09.21.32.28;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	95.03.09.20.56.34;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	95.03.03.17.51.12;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.03.03.17.35.45;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.02.25.03.36.50;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	95.02.22.05.36.43;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.02.17.03.58.16;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.02.17.03.29.12;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.02.17.02.46.24;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.02.15.09.36.43;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.02.13.12.56.37;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.01.25.15.24.35;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.01.25.14.07.47;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.34;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.02;	author mike;	state Rel4_4;
branches;
next	10.33;

10.33
date	94.12.27.16.58.41;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.12.23.19.34.27;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	94.12.16.19.36.28;	author gdurf;	state Exp;
branches;
next	10.30;

10.30
date	94.12.08.23.36.21;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	94.11.30.17.37.01;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.11.05.03.45.03;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	94.10.19.23.57.31;	author cjohnson;	state Exp;
branches;
next	10.26;

10.26
date	94.08.27.03.18.18;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.08.27.03.12.01;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	94.08.25.17.52.51;	author gdurf;	state Exp;
branches;
next	10.23;

10.23
date	94.08.09.15.18.34;	author gdurf;	state Exp;
branches;
next	10.22;

10.22
date	94.08.05.14.45.22;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	94.08.03.22.40.45;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	94.06.01.16.35.18;	author gdurf;	state Exp;
branches;
next	10.19;

10.19
date	94.05.11.15.24.23;	author jra;	state Exp;
branches;
next	10.18;

10.18
date	94.04.20.09.49.21;	author jra;	state Exp;
branches;
next	10.17;

10.17
date	94.04.05.17.15.44;	author cjohnson;	state Exp;
branches;
next	10.16;

10.16
date	94.01.12.02.45.35;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.11.18.02.34.08;	author butler;	state Exp;
branches;
next	10.14;

10.14
date	93.07.13.21.03.47;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	92.10.13.16.15.14;	author mm;	state Exp;
branches;
next	10.12;

10.12
date	92.10.13.15.59.58;	author mm;	state Exp;
branches;
next	10.11;

10.11
date	92.07.23.05.25.15;	author butler;	state Exp;
branches;
next	10.10;

10.10
date	92.07.23.05.02.07;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	92.07.22.20.59.31;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.07.22.20.51.13;	author butler;	state Exp;
branches;
next	10.7;

10.7
date	92.06.25.21.04.27;	author butler;	state Exp;
branches;
next	10.6;

10.6
date	92.06.05.15.25.08;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.04.03.19.24.19;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.02.05.15.34.30;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.02.05.13.09.14;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.12.20.01.09.18;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.38;	author mike;	state Rel4_0;
branches;
next	9.37;

9.37
date	91.10.11.11.32.47;	author butler;	state Exp;
branches;
next	9.36;

9.36
date	91.08.29.22.44.52;	author mike;	state Exp;
branches;
next	9.35;

9.35
date	91.07.08.15.24.26;	author butler;	state Exp;
branches;
next	9.34;

9.34
date	91.07.06.02.18.20;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	91.07.06.00.08.23;	author mike;	state Exp;
branches;
next	9.32;

9.32
date	91.07.01.01.51.09;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	91.06.30.21.14.03;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.06.11.00.39.15;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.05.24.19.28.05;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.05.23.00.19.31;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.05.18.03.31.06;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.03.01.22.31.08;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.02.27.20.08.38;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.02.27.04.16.20;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.02.27.04.14.17;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.02.06.23.58.01;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.02.02.00.01.12;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.01.26.03.23.07;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.01.12.08.00.37;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	90.12.06.23.56.00;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.05.24.04.05.31;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.05.24.03.06.44;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.05.23.12.16.33;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.05.22.21.43.08;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.05.21.12.40.20;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.05.18.07.43.34;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.05.04.04.19.23;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.05.01.02.59.41;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.04.28.03.45.01;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.04.26.02.15.38;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.04.21.06.05.54;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.04.13.03.56.09;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.04.13.00.33.46;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.03.14.21.21.33;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.02.28.01.55.48;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.22.51;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.57;	author mike;	state Rel3_5;
branches;
next	8.7;

8.7
date	89.04.17.17.06.43;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.04.06.20.39.51;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.19.22.40.09;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.01.18.01.55.59;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.16.22.56.58;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.11.45;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.42;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.17.02.35.00;	author reschly;	state Exp;
branches;
next	7.3;

7.3
date	88.02.25.06.07.12;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.05.35;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.00.30;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.03.42;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.20.20;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.07.21;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.21.18;	author mike;	state Rel1;
branches;
next	2.13;

2.13
date	86.08.13.00.07.40;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.08.12.06.49.16;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.07.18.02.37.08;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.03.14.20.41.59;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.09.27.22.14.52;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.09.25.14.27.18;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.09.14.05.36.07;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.08.07.05.18.36;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.03.22.10.53.30;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.03.15.05.05.01;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.13.06.08.42;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.04.06.18;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.55.44;	author mike;	state Prod;
branches;
next	1.10;

1.10
date	85.02.01.03.23.42;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.01.19.04.06.40;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.01.17.07.28.57;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.01.16.03.03.38;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.01.16.01.57.30;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.11.22.06.56.32;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.11.20.04.23.54;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.19.02.59.31;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.17.05.36.25;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.50.18;	author mike;	state Exp;
branches;
next	;

11.92.2.1
date	2000.11.09.14.39.38;	author jra;	state Exp;
branches;
next	;

11.119.2.1
date	2002.09.19.18.02.01;	author morrison;	state Exp;
branches;
next	11.119.2.2;

11.119.2.2
date	2004.03.17.21.21.57;	author morrison;	state Exp;
branches;
next	;

11.119.4.1
date	2002.09.26.23.04.10;	author morrison;	state Exp;
branches;
next	11.119.4.2;

11.119.4.2
date	2004.03.11.23.46.34;	author morrison;	state Exp;
branches;
next	;

11.119.10.1
date	2004.02.12.18.34.13;	author erikg;	state Exp;
branches;
next	11.119.10.2;

11.119.10.2
date	2004.03.15.14.07.36;	author erikg;	state Exp;
branches;
next	11.119.10.3;

11.119.10.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Manage the drawing of a solid
@


11.124
log
@moved to src/mged/
@
text
@/*
 *			D O D R A W . C
 *
 * Functions -
 *	drawtrees	Add a set of tree hierarchies to the active set
 *	drawHsolid	Manage the drawing of a COMGEOM solid
 *	pathHmat	Find matrix across a given path
 *	replot_original_solid	Replot vector list for a solid
 *	replot_modified_solid	Replot solid, given matrix and db record.
 *	invent_solid		Turn list of vectors into phony solid
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/dodraw.c,v 11.123 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"		/* for ID_POLY special support */
#include "./ged.h"
#include "externs.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./cmd.h"

#include "../librt/debug.h"	/* XXX */

void		cvt_vlblock_to_solids(struct bn_vlblock *vbp, const char *name, int copy);
void		drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp);
extern void	(*nmg_plot_anim_upcall)();
extern void	(*nmg_vlblock_anim_upcall)();
extern void	(*nmg_mged_debug_display_hack)();
long	nvectors;	/* number of vectors drawn so far */

unsigned char geometry_default_color[] = { 255, 0, 0 };

/*
 *  This is just like the rt_initial_tree_state in librt/tree.c,
 *  except that the default color is red instead of white.
 *  This avoids confusion with illuminate mode.
 *  Red is a one-gun color, avoiding convergence problems too.
 */
struct db_tree_state	mged_initial_tree_state = {
	RT_DBTS_MAGIC,		/* magic */
	0,			/* ts_dbip */
	0,			/* ts_sofar */
	0, 0, 0,		/* region, air, gmater */
	100,			/* GIFT los */
#if __STDC__
	{
#endif
		/* struct mater_info ts_mater */
		{1.0, 0.0, 0.0},		/* color, RGB */
		-1.0,			/* Temperature */
		0,			/* ma_color_valid=0 --> use default */
		0,			/* color inherit */
		0,			/* mater inherit */
		(char *)NULL		/* shader */
#if __STDC__
	}
#endif
	,
	{1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0},
	REGION_NON_FASTGEN,		/* ts_is_fastgen */
#if __STDC__
	{
#endif
		/* attribute value set */
		BU_AVS_MAGIC,
		0,
		0,
		NULL,
		NULL,
		NULL
#if __STDC__
	}
#endif
	,
	0,				/* ts_stop_at_regions */
	NULL,				/* ts_region_start_func */
	NULL,				/* ts_region_end_func */
	NULL,				/* ts_leaf_func */
	NULL,				/* ts_ttol */
	NULL,				/* ts_tol */
	NULL,				/* ts_m */
	NULL,				/* ts_rtip */
	NULL				/* ts_resp */
};

static int		mged_draw_nmg_only;
static int		mged_nmg_triangulate;
static int		mged_draw_wireframes;
static int		mged_draw_normals;
static int		mged_draw_solid_lines_only=0;
static int		mged_draw_no_surfaces = 0;
static int		mged_shade_per_vertex_normals=0;
int			mged_wireframe_color_override;
int			mged_wireframe_color[3];
static struct model	*mged_nmg_model;
struct rt_tess_tol	mged_ttol;	/* XXX needs to replace mged_abs_tol, et.al. */

extern struct bn_tol		mged_tol;	/* from ged.c */

/*
 *		M G E D _ P L O T _ A N I M _ U P C A L L _ H A N D L E R
 *
 *  Used via upcall by routines deep inside LIBRT, to have a UNIX-plot
 *  file dyanmicly overlaid on the screen.
 *  This can be used to provide a very easy to program diagnostic
 *  animation capability.
 *  Alas, no wextern keyword to make this a little less indirect.
 */
void
mged_plot_anim_upcall_handler(char *file, long int us)
    	      
    	   		/* microseconds of extra delay */
{
	char *av[3];

	/* Overlay plot file */
	av[0] = "overlay";
	av[1] = file;
	av[2] = NULL;
	(void)cmd_overlay((ClientData)NULL, interp, 2, av);

	do {
		event_check( 1 );	/* Take any device events */
		refresh();		/* Force screen update */
		us -= frametime * 1000000;
	} while (us > 0);

#if 0
	/* Extra delay between screen updates, for more viewing time */
	/* Use /dev/tty to select on, because stdin may be a file */
	if(us)  {
		int	fd;

		if( (fd = open("/dev/tty", 2)) < 0 )  {
			perror("/dev/tty");
		} else {
			struct timeval tv;
			fd_set readfds;

			FD_ZERO(&readfds);
			FD_SET(fd, &readfds);
			tv.tv_sec = 0L;
			tv.tv_usec = us;

			select( fd+1, &readfds, (fd_set *)0, (fd_set *)0, &tv );
			close(fd);
		}
	}
#endif
}

/*
 *		M G E D _ V L B L O C K _ A N I M _ U P C A L L _ H A N D L E R
 *
 *  Used via upcall by routines deep inside LIBRT, to have a UNIX-plot
 *  file dyanmicly overlaid on the screen.
 *  This can be used to provide a very easy to program diagnostic
 *  animation capability.
 *  Alas, no wextern keyword to make this a little less indirect.
 */
void
mged_vlblock_anim_upcall_handler(struct bn_vlblock *vbp, long int us, int copy)
                 	     
    		   		/* microseconds of extra delay */
   		     
{

	cvt_vlblock_to_solids( vbp, "_PLOT_OVERLAY_", copy );


	do  {
		event_check( 1 );	/* Take any device events */
		refresh();		/* Force screen update */
		us -= frametime * 1000000;
	} while (us > 0);
#if 0
	/* Extra delay between screen updates, for more viewing time */
	/* Use /dev/tty to select on, because stdin may be a file */
	if(us)  {
		int	fd;
		if( (fd = open("/dev/tty", 2)) < 0 )  {
			perror("/dev/tty");
		} else {
			struct timeval tv;
			fd_set readfds;

			FD_ZERO(&readfds);
			FD_SET(fd, &readfds);
			tv.tv_sec = 0L;
			tv.tv_usec = us;

			select( fd+1, &readfds, (fd_set *)0, (fd_set *)0, &tv );
			close(fd);
		}
	}
#endif
}
static void
hack_for_lee(void)
{
	event_check( 1 );	/* Take any device events */

	refresh();		/* Force screen update */
}

/*
 *			M G E D _ W I R E F R A M E _ R E G I O N _ E N D
 *
 *  This routine must be prepared to run in parallel.
 */
HIDDEN union tree *
mged_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	return( curtree );
}

/*
 *			M G E D _ W I R E F R A M E _ L E A F
 *
 *  This routine must be prepared to run in parallel.
 */
HIDDEN union tree *
mged_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	union tree	*curtree;
	int		dashflag;		/* draw with dashed lines */
	struct bu_list	vhead;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	RT_CK_DB_INTERNAL(ip);

	BU_LIST_INIT( &vhead );

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
	  char	*sofar = db_path_to_string(pathp);

	  Tcl_AppendResult(interp, "mged_wireframe_leaf(",
			   ip->idb_meth->ft_name,
			   ") path='", sofar, "'\n", (char *)NULL);
	  bu_free((genptr_t)sofar, "path string");
	}

	if( mged_draw_solid_lines_only )
		dashflag = 0;
	else
		dashflag = (tsp->ts_sofar & (TS_SOFAR_MINUS|TS_SOFAR_INTER) );

	if( ip->idb_meth->ft_plot(
	    &vhead, ip,
	    tsp->ts_ttol, tsp->ts_tol ) < 0 )  {
	  Tcl_AppendResult(interp, DB_FULL_PATH_CUR_DIR(pathp)->d_namep,
			   ": plot failure\n", (char *)NULL);
	  return(TREE_NULL);		/* ERROR */
	}

	/*
	 * XXX HACK CTJ - drawH_part2 sets the default color of a
	 * solid by looking in tps->ts_mater.ma_color, for pseudo
	 * solids, this needs to be something different and drawH
	 * has no idea or need to know what type of solid this is.
	 */
	if (ip->idb_type == ID_GRIP) {
		int r,g,b;
		r= tsp->ts_mater.ma_color[0];
		g= tsp->ts_mater.ma_color[1];
		b= tsp->ts_mater.ma_color[2];
		tsp->ts_mater.ma_color[0] = 0;
		tsp->ts_mater.ma_color[1] = 128;
		tsp->ts_mater.ma_color[2] = 128;
		drawH_part2( dashflag, &vhead, pathp, tsp, SOLID_NULL );
		tsp->ts_mater.ma_color[0] = r;
		tsp->ts_mater.ma_color[1] = g;
		tsp->ts_mater.ma_color[2] = b;
	} else {
		drawH_part2( dashflag, &vhead, pathp, tsp, SOLID_NULL );
	}

	/* Indicate success by returning something other than TREE_NULL */
	BU_GETUNION( curtree, tree );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;

	return( curtree );
}
/* XXX Grotesque, shameless hack */
static int mged_do_not_draw_nmg_solids_during_debugging = 0;
static int mged_draw_edge_uses=0;
static int mged_enable_fastpath = 0;
static int mged_fastpath_count=0;	/* statistics */
static struct bn_vlblock	*mged_draw_edge_uses_vbp;

/*
 *			M G E D _ N M G _ R E G I O N _ S T A R T
 *
 *  When performing "ev" on a region, consider whether to process
 *  the whole subtree recursively.
 *  Normally, say "yes" to all regions by returning 0.
 *
 *  Check for special case:  a region of one solid, which can be
 *  directly drawn as polygons without going through NMGs.
 *  If we draw it here, then return -1 to signal caller to ignore
 *  further processing of this region.
 *  A hack to view polygonal models (converted from FASTGEN) more rapidly.
 */
int
mged_nmg_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
{
	union tree		*tp;
	struct directory	*dp;
	struct rt_db_internal	intern;
	mat_t			xform;
	matp_t			matp;
	struct bu_list		vhead;

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(pathp);
		bu_log("mged_nmg_region_start(%s)\n", sofar);
		bu_free((genptr_t)sofar, "path string");
		rt_pr_tree( combp->tree, 1 );
		db_pr_tree_state(tsp);
	}

	BU_LIST_INIT( &vhead );

	RT_CK_COMB(combp);
	tp = combp->tree;
	if( !tp )
		return( -1 );
	RT_CK_TREE(tp);
	if( tp->tr_l.tl_op != OP_DB_LEAF )
		return 0;	/* proceed as usual */

	/* The subtree is a single node.  It may be a combination, though */

	/* Fetch by name, check to see if it's an easy type */
	dp = db_lookup( tsp->ts_dbip, tp->tr_l.tl_name, LOOKUP_NOISY );
	if( !dp )
		return 0;	/* proceed as usual */
	if( tsp->ts_mat )  {
		if( tp->tr_l.tl_mat )  {
			matp = xform;
			bn_mat_mul( xform, tsp->ts_mat, tp->tr_l.tl_mat );
		} else {
			matp = tsp->ts_mat;
		}
	} else {
		if( tp->tr_l.tl_mat )  {
			matp = tp->tr_l.tl_mat;
		} else {
			matp = (matp_t)NULL;
		}
	}
	if( rt_db_get_internal(&intern, dp, tsp->ts_dbip, matp, &rt_uniresource ) < 0 )
		return 0;	/* proceed as usual */

	switch( intern.idb_type )  {
	case ID_POLY:
		{
			if(RT_G_DEBUG&DEBUG_TREEWALK)  {
				bu_log("fastpath draw ID_POLY %s\n", dp->d_namep);
			}
			if( mged_draw_wireframes )  {
				(void)rt_pg_plot( &vhead, &intern, tsp->ts_ttol, tsp->ts_tol );
			} else {
				(void)rt_pg_plot_poly( &vhead, &intern, tsp->ts_ttol, tsp->ts_tol );
			}
		}
		goto out;
	case ID_BOT:
		{
			if (RT_G_DEBUG&DEBUG_TREEWALK) {
				bu_log("fastpath draw ID_BOT %s\n", dp->d_namep);
			}
			if( mged_draw_wireframes )  {
				(void)rt_bot_plot( &vhead, &intern, tsp->ts_ttol, tsp->ts_tol );
			} else {
				(void)rt_bot_plot_poly( &vhead, &intern, tsp->ts_ttol, tsp->ts_tol );
			}
		}
		goto out;
	case ID_COMBINATION:
	default:
		break;
	}
	rt_db_free_internal(&intern, &rt_uniresource);
	return 0;

out:
	/* Successful fastpath drawing of this solid */
	db_add_node_to_full_path( pathp, dp );
	drawH_part2( 0, &vhead, pathp, tsp, SOLID_NULL );
	DB_FULL_PATH_POP(pathp);
	rt_db_free_internal(&intern, &rt_uniresource);
	mged_fastpath_count++;
	return -1;	/* SKIP THIS REGION */
}

/*
 *			M G E D _ N M G _ R E G I O N _ E N D
 *
 *  This routine must be prepared to run in parallel.
 */
HIDDEN union tree *
mged_nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct nmgregion	*r;
	struct bu_list		vhead;
	int			failed;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	NMG_CK_MODEL(*tsp->ts_m);

	BU_LIST_INIT( &vhead );

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
	  char	*sofar = db_path_to_string(pathp);

	  Tcl_AppendResult(interp, "mged_nmg_region_end() path='", sofar,
			   "'\n", (char *)NULL);
	  bu_free((genptr_t)sofar, "path string");
	}

	if( curtree->tr_op == OP_NOP )  return  curtree;

	if ( !mged_draw_nmg_only ) {
		if( BU_SETJUMP )
		{
			char  *sofar = db_path_to_string(pathp);

			BU_UNSETJUMP;

			Tcl_AppendResult(interp, "WARNING: Boolean evaluation of ", sofar,
				" failed!!!\n", (char *)NULL );
			bu_free((genptr_t)sofar, "path string");
			if( curtree )
				db_free_tree( curtree, &rt_uniresource );
			return (union tree *)NULL;
		}
		failed = nmg_boolean( curtree, *tsp->ts_m, tsp->ts_tol, &rt_uniresource );
		BU_UNSETJUMP;
		if( failed )  {
			db_free_tree( curtree, &rt_uniresource );
			return (union tree *)NULL;
		}
	}
	else if( curtree->tr_op != OP_NMG_TESS )
	{
	  Tcl_AppendResult(interp, "Cannot use '-d' option when Boolean evaluation is required\n", (char *)NULL);
	  db_free_tree( curtree, &rt_uniresource );
	  return (union tree *)NULL;
	}
	r = curtree->tr_d.td_r;
	NMG_CK_REGION(r);

	if( mged_do_not_draw_nmg_solids_during_debugging && r )  {
		db_free_tree( curtree, &rt_uniresource );
		return (union tree *)NULL;
	}

	if (mged_nmg_triangulate) {
		if( BU_SETJUMP )
		{
			char  *sofar = db_path_to_string(pathp);

			BU_UNSETJUMP;

			Tcl_AppendResult(interp, "WARNING: Triangulation of ", sofar,
				" failed!!!\n", (char *)NULL );
			bu_free((genptr_t)sofar, "path string");
			if( curtree )
				db_free_tree( curtree, &rt_uniresource );
			return (union tree *)NULL;
		}
		nmg_triangulate_model(*tsp->ts_m, tsp->ts_tol);
		BU_UNSETJUMP;
	}

	if( r != 0 )  {
		int	style;
		/* Convert NMG to vlist */
		NMG_CK_REGION(r);

		if( mged_draw_wireframes )  {
			/* Draw in vector form */
			style = NMG_VLIST_STYLE_VECTOR;
		} else {
			/* Default -- draw polygons */
			style = NMG_VLIST_STYLE_POLYGON;
		}
		if( mged_draw_normals )  {
			style |= NMG_VLIST_STYLE_VISUALIZE_NORMALS;
		}
		if( mged_shade_per_vertex_normals )  {
			style |= NMG_VLIST_STYLE_USE_VU_NORMALS;
		}
		if( mged_draw_no_surfaces )  {
			style |= NMG_VLIST_STYLE_NO_SURFACES;
		}
		nmg_r_to_vlist( &vhead, r, style );

		drawH_part2( 0, &vhead, pathp, tsp, SOLID_NULL );

		if( mged_draw_edge_uses )  {
			nmg_vlblock_r(mged_draw_edge_uses_vbp, r, 1);
		}
		/* NMG region is no longer necessary, only vlist remains */
		db_free_tree( curtree, &rt_uniresource );
		return (union tree *)NULL;
	}

	/* Return tree -- it needs to be freed (by caller) */
	return curtree;
}

/*
 *			D R A W T R E E S
 *
 *  This routine is MGED's analog of rt_gettrees().
 *  Add a set of tree hierarchies to the active set.
 *  Note that argv[0] should be ignored, it has the command name in it.
 *
 *  Kind =
 *	1	regular wireframes
 *	2	big-E
 *	3	NMG polygons
 *  
 *  Returns -
 *  	0	Ordinarily
 *	-1	On major error
 */
int
drawtrees(
	int	argc,
	char	**argv,
	int	kind)
{
	int		ret = 0;
	register int	c;
	int		ncpu;
	int		mged_nmg_use_tnurbs = 0;

	if(dbip == DBI_NULL)
	  return 0;

	RT_CHECK_DBI(dbip);

	if( argc <= 0 )  return(-1);	/* FAIL */

	/* Initial values for options, must be reset each time */
	ncpu = 1;
	mged_draw_nmg_only = 0;	/* no booleans */
	mged_nmg_triangulate = 1;
	mged_draw_wireframes = 0;
	mged_draw_normals = 0;
	mged_draw_edge_uses = 0;
	mged_draw_solid_lines_only = 0;
	mged_shade_per_vertex_normals = 0;
	mged_draw_no_surfaces = 0;
	mged_wireframe_color_override = 0;
	mged_fastpath_count = 0;
	mged_enable_fastpath = 0;

	/* Parse options. */
	bu_optind = 1;		/* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"dfnqrstuvwSTP:C:")) != EOF )  {
		switch(c)  {
		case 'u':
			mged_draw_edge_uses = 1;
			break;
		case 's':
			mged_draw_solid_lines_only = 1;
			break;
		case 't':
			mged_nmg_use_tnurbs = 1;
			break;
		case 'v':
			mged_shade_per_vertex_normals = 1;
			break;
		case 'w':
			mged_draw_wireframes = 1;
			break;
		case 'S':
			mged_draw_no_surfaces = 1;
			break;
		case 'T':
			mged_nmg_triangulate = 0;
			break;
		case 'n':
			mged_draw_normals = 1;
			break;
		case 'P':
			ncpu = atoi(bu_optarg);
			break;
		case 'q':
			mged_do_not_draw_nmg_solids_during_debugging = 1;
			break;
		case 'd':
			mged_draw_nmg_only = 1;
			break;
		case 'f':
			mged_enable_fastpath = 1;
			break;
		case 'C':
			{
				int		r,g,b;
				register char	*cp = bu_optarg;

				r = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				g = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				b = atoi(cp);

				if( r < 0 || r > 255 )  r = 255;
				if( g < 0 || g > 255 )  g = 255;
				if( b < 0 || b > 255 )  b = 255;

				mged_wireframe_color_override = 1;
				mged_wireframe_color[0] = r;
				mged_wireframe_color[1] = g;
				mged_wireframe_color[2] = b;
			}
			break;
		case 'r':
			/* Draw in all-red, as in Release 3 and earlier */
			/* Useful for spotting regions colored black */
			mged_wireframe_color_override = 1;
			mged_wireframe_color[0] = 255;
			mged_wireframe_color[1] = 0;
			mged_wireframe_color[2] = 0;
			break;
		default:
			{
				struct bu_vls vls;

				bu_vls_init(&vls);
				bu_vls_printf(&vls, "help %s", argv[0]);
				Tcl_Eval(interp, bu_vls_addr(&vls));
				bu_vls_free(&vls);

				return TCL_ERROR;
			}
#if 0
		  Tcl_AppendResult(interp, "Usage: ev [-dfnqstuvwST] [-P ncpu] object(s)\n\
	-d draw nmg without performing boolean operations\n\
	-f enable polysolid fastpath\n\
	-w draw wireframes (rather than polygons)\n\
	-n draw surface normals as little 'hairs'\n\
	-s draw solid lines only (no dot-dash for subtract and intersect)\n\
	-t Perform CSG-to-tNURBS conversion\n\
	-v shade using per-vertex normals, when present.\n\
	-u debug: draw edgeuses\n\
	-S draw tNURBs with trimming curves only, no surfaces.\n\
	-T debug: disable triangulator\n", (char *)NULL);
			break;
#endif
		}
	}
	argc -= bu_optind;
	argv += bu_optind;

	/* Establish upcall interfaces for use by bottom of NMG library */
	nmg_plot_anim_upcall = mged_plot_anim_upcall_handler;
	nmg_vlblock_anim_upcall = mged_vlblock_anim_upcall_handler;
	nmg_mged_debug_display_hack = hack_for_lee;

	/* Establish tolerances */
	mged_initial_tree_state.ts_ttol = &mged_ttol;
	mged_initial_tree_state.ts_tol = &mged_tol;

#if 0
	/* set default wireframe color */
	VMOVE(mged_initial_tree_state.ts_mater.ma_color, default_wireframe_color);
#endif

	mged_ttol.magic = RT_TESS_TOL_MAGIC;
	mged_ttol.abs = mged_abs_tol;
	mged_ttol.rel = mged_rel_tol;
	mged_ttol.norm = mged_nrm_tol;

	switch( kind )  {
	default:
	  Tcl_AppendResult(interp, "ERROR, bad kind\n", (char *)NULL);
	  return(-1);
	case 1:		/* Wireframes */
		ret = db_walk_tree( dbip, argc, (const char **)argv,
			ncpu,
			&mged_initial_tree_state,
			0,			/* take all regions */
			mged_wireframe_region_end,
			mged_wireframe_leaf, (genptr_t)NULL );
		break;
	case 2:		/* Big-E */
#	    if 0
		ret = db_walk_tree( dbip, argc, argv,
			ncpu,
			&mged_initial_tree_state,
			0,			/* take all regions */
			mged_bigE_region_end,
			mged_bigE_leaf, (genptr_t)NULL );
		break;
#	    else
		Tcl_AppendResult(interp, "drawtrees:  can't do big-E here\n", (char *)NULL);
		return(-1);
#	    endif
	case 3:
	  {
		/* NMG */
#if 0
	    Tcl_AppendResult(interp, "\
Please note that the NMG library used by this command is experimental.\n\
A production implementation will exist in the maintenance release.\n", (char *)NULL);
#endif
	  	mged_nmg_model = nmg_mm();
		mged_initial_tree_state.ts_m = &mged_nmg_model;
	  	if (mged_draw_edge_uses) {
		  Tcl_AppendResult(interp, "Doing the edgeuse thang (-u)\n", (char *)NULL);
		  mged_draw_edge_uses_vbp = rt_vlblock_init();
	  	}

		ret = db_walk_tree( dbip, argc, (const char **)argv,
			ncpu,
			&mged_initial_tree_state,
			mged_enable_fastpath ? mged_nmg_region_start : 0,
			mged_nmg_region_end,
	  		mged_nmg_use_tnurbs ?
	  			nmg_booltree_leaf_tnurb :
				nmg_booltree_leaf_tess,
			(genptr_t)NULL
			);

	  	if (mged_draw_edge_uses) {
	  		cvt_vlblock_to_solids(mged_draw_edge_uses_vbp, "_EDGEUSES_", 0);
	  		rt_vlblock_free(mged_draw_edge_uses_vbp);
			mged_draw_edge_uses_vbp = (struct bn_vlblock *)NULL;
 	  	}

		/* Destroy NMG */
		nmg_km( mged_nmg_model );
	  	break;
	  }
	}
	if(mged_fastpath_count)  {
		bu_log("%d region%s rendered through polygon fastpath\n",
			mged_fastpath_count, mged_fastpath_count==1?"":"s");
	}
	if( ret < 0 )  return(-1);
	return(0);	/* OK */
}

/*
 *  Compute the min, max, and center points of the solid.
 *  Also finds s_vlen;
 * XXX Should split out a separate bn_vlist_rpp() routine, for librt/vlist.c
 */
void
mged_bound_solid(register struct solid *sp)
{
	register struct bn_vlist	*vp;
	register double			xmax, ymax, zmax;
	register double			xmin, ymin, zmin;

	xmax = ymax = zmax = -INFINITY;
	xmin = ymin = zmin =  INFINITY;
	sp->s_vlen = 0;
	for( BU_LIST_FOR( vp, bn_vlist, &(sp->s_vlist) ) )  {
		register int	j;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( j = 0; j < nused; j++,cmd++,pt++ )  {
			switch( *cmd )  {
			case BN_VLIST_POLY_START:
			case BN_VLIST_POLY_VERTNORM:
				/* Has normal vector, not location */
				break;
			case BN_VLIST_LINE_MOVE:
			case BN_VLIST_LINE_DRAW:
			case BN_VLIST_POLY_MOVE:
			case BN_VLIST_POLY_DRAW:
			case BN_VLIST_POLY_END:
				V_MIN( xmin, (*pt)[X] );
				V_MAX( xmax, (*pt)[X] );
				V_MIN( ymin, (*pt)[Y] );
				V_MAX( ymax, (*pt)[Y] );
				V_MIN( zmin, (*pt)[Z] );
				V_MAX( zmax, (*pt)[Z] );
				break;
			default:
			  {
			    struct bu_vls tmp_vls;

			    bu_vls_init(&tmp_vls);
			    bu_vls_printf(&tmp_vls, "unknown vlist op %d\n", *cmd);
			    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			    bu_vls_free(&tmp_vls);
			  }
			}
		}
		sp->s_vlen += nused;
	}

	sp->s_center[X] = (xmin + xmax) * 0.5;
	sp->s_center[Y] = (ymin + ymax) * 0.5;
	sp->s_center[Z] = (zmin + zmax) * 0.5;

	sp->s_size = xmax - xmin;
	V_MAX( sp->s_size, ymax - ymin );
	V_MAX( sp->s_size, zmax - zmin );
}

/*
 *			D R A W h _ P A R T 2
 *
 *  Once the vlist has been created, perform the common tasks
 *  in handling the drawn solid.
 *
 *  This routine must be prepared to run in parallel.
 */
void
drawH_part2(
	int			dashflag,
	struct bu_list		*vhead,
	struct db_full_path	*pathp,
	struct db_tree_state	*tsp,
	struct solid		*existing_sp)
{
	register struct solid *sp;

	if( !existing_sp )  {
		/* Handling a new solid */
		GET_SOLID(sp, &FreeSolid.l);
		/* NOTICE:  The structure is dirty & not initialized for you! */

		sp->s_dlist = BU_LIST_LAST(solid, &dgop->dgo_headSolid)->s_dlist + 1;
	} else {
		/* Just updating an existing solid.
		 *  'tsp' and 'pathpos' will not be used
		 */
		sp = existing_sp;
	}


	/*
	 * Compute the min, max, and center points.
	 */
	BU_LIST_APPEND_LIST( &(sp->s_vlist), vhead );
	mged_bound_solid( sp );
	nvectors += sp->s_vlen;

	/*
	 *  If this solid is new, fill in it's information.
	 *  Otherwise, don't touch what is already there.
	 */
	if( !existing_sp )  {
		/* Take note of the base color */
		if( mged_wireframe_color_override ) {
		        /* a user specified the color, so arrange to use it */
			sp->s_uflag = 1;
			sp->s_dflag = 0;
			sp->s_basecolor[0] = mged_wireframe_color[0];
			sp->s_basecolor[1] = mged_wireframe_color[1];
			sp->s_basecolor[2] = mged_wireframe_color[2];
		} else {
			sp->s_uflag = 0;
			if (tsp) {
			  if (tsp->ts_mater.ma_color_valid) {
			    sp->s_dflag = 0;	/* color specified in db */
			  } else {
			    sp->s_dflag = 1;	/* default color */
			  }
			  /* Copy into basecolor anyway, to prevent black */
			  sp->s_basecolor[0] = tsp->ts_mater.ma_color[0] * 255.;
			  sp->s_basecolor[1] = tsp->ts_mater.ma_color[1] * 255.;
			  sp->s_basecolor[2] = tsp->ts_mater.ma_color[2] * 255.;
			}
		}
		sp->s_cflag = 0;
		sp->s_iflag = DOWN;
		sp->s_soldash = dashflag;
		sp->s_Eflag = 0;	/* This is a solid */
		db_dup_full_path( &sp->s_fullpath, pathp );
		sp->s_regionid = tsp->ts_regionid;
	}

#ifdef DO_DISPLAY_LISTS
	createDListALL(sp);
#endif

	/* Solid is successfully drawn */
	if( !existing_sp )  {
		/* Add to linked list of solid structs */
		bu_semaphore_acquire( RT_SEM_MODEL );
		BU_LIST_APPEND(dgop->dgo_headSolid.back, &sp->l);
		bu_semaphore_release( RT_SEM_MODEL );
	} else {
		/* replacing existing solid -- struct already linked in */
		sp->s_iflag = UP;
	}
}

HIDDEN void
Do_getmat(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3)
{
	matp_t	xmat;
	char	*kid_name;
	int	*found;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	kid_name = (char *)user_ptr2;

	if( strncmp( comb_leaf->tr_l.tl_name, kid_name, NAMESIZE ) )
		return;

	xmat = (matp_t)user_ptr1;
	found = (int *)user_ptr3;

	(*found) = 1;
	if( comb_leaf->tr_l.tl_mat ) {
		MAT_COPY( xmat, comb_leaf->tr_l.tl_mat );
	}
	else {
		MAT_IDN( xmat );
	}
}

/*
 *  			P A T H h M A T
 *  
 *  Find the transformation matrix obtained when traversing
 *  the arc indicated in sp->s_path[] to the indicated depth.
 *
 *  Returns -
 *	matp is filled with values (never read first).
 *	sp may have fields updated.
 */
void
pathHmat(
	register struct solid *sp,
	matp_t matp,
	int depth)
{
	struct db_tree_state	ts;
	struct db_full_path	null_path;

	RT_CHECK_DBI(dbip);

	db_full_path_init( &null_path );
	ts = mged_initial_tree_state;		/* struct copy */
	ts.ts_dbip = dbip;
	ts.ts_resp = &rt_uniresource;

	(void)db_follow_path( &ts, &null_path, &sp->s_fullpath, LOOKUP_NOISY, depth+1 );
	db_free_full_path( &null_path );

#if 0
	/*
	 *  Copy color out to solid structure, in case it changed.
	 *  This is an odd place to do this, but...
	 */
#if 0
	sp->s_color[0] = sp->s_basecolor[0] = ts.ts_mater.ma_color[0] * 255.;
	sp->s_color[1] = sp->s_basecolor[1] = ts.ts_mater.ma_color[1] * 255.;
	sp->s_color[2] = sp->s_basecolor[2] = ts.ts_mater.ma_color[2] * 255.;
#else
	if(!sp->s_uflag){
	  /* the user did not specify a color */
	  sp->s_basecolor[0] = ts.ts_mater.ma_color[0] * 255.;
	  sp->s_basecolor[1] = ts.ts_mater.ma_color[1] * 255.;
	  sp->s_basecolor[2] = ts.ts_mater.ma_color[2] * 255.;
	}
#endif
#endif

	MAT_COPY( matp, ts.ts_mat );	/* implicit return */

	db_free_db_tree_state( &ts );
}

/*
 *			R E P L O T _ O R I G I N A L _ S O L I D
 *
 *  Given an existing solid structure that may have been subjected to
 *  solid editing, recompute the vector list, etc, to make the solid
 *  the same as it originally was.
 *
 *  Returns -
 *	-1	error
 *	 0	OK
 */
int
replot_original_solid( struct solid *sp )
{
	struct rt_db_internal	intern;
	struct directory	*dp;
	mat_t			mat;

	if(dbip == DBI_NULL)
	  return 0;

	dp = LAST_SOLID(sp);
	if( sp->s_Eflag )  {
	  Tcl_AppendResult(interp, "replot_original_solid(", dp->d_namep,
			   "): Unable to plot evaluated regions, skipping\n", (char *)NULL);
	  return(-1);
	}
	pathHmat( sp, mat, sp->s_fullpath.fp_len-2 );

	if( rt_db_get_internal( &intern, dp, dbip, mat, &rt_uniresource ) < 0 )  {
	  Tcl_AppendResult(interp, dp->d_namep, ":  solid import failure\n", (char *)NULL);
	  return(-1);		/* ERROR */
	}
	RT_CK_DB_INTERNAL( &intern );

	if( replot_modified_solid( sp, &intern, bn_mat_identity ) < 0 )  {
		rt_db_free_internal( &intern, &rt_uniresource );
		return(-1);
	}
	rt_db_free_internal( &intern, &rt_uniresource );
	return(0);
}

/*
 *  			R E P L O T _ M O D I F I E D _ S O L I D
 *
 *  Given the solid structure of a solid that has already been drawn,
 *  and a new database record and transform matrix,
 *  create a new vector list for that solid, and substitute.
 *  Used for solid editing mode.
 *
 *  Returns -
 *	-1	error
 *	 0	OK
 */
int
replot_modified_solid(
	struct solid			*sp,
	struct rt_db_internal		*ip,
	const mat_t			mat)
{
	struct rt_db_internal	intern;
	struct bu_list		vhead;

	BU_LIST_INIT( &vhead );

	if( sp == SOLID_NULL )  {
	  Tcl_AppendResult(interp, "replot_modified_solid() sp==NULL?\n", (char *)NULL);
	  return(-1);
	}

	/* Release existing vlist of this solid */
	RT_FREE_VLIST( &(sp->s_vlist) );

	/* Draw (plot) a normal solid */
	RT_CK_DB_INTERNAL( ip );

	mged_ttol.magic = RT_TESS_TOL_MAGIC;
	mged_ttol.abs = mged_abs_tol;
	mged_ttol.rel = mged_rel_tol;
	mged_ttol.norm = mged_nrm_tol;

	transform_editing_solid( &intern, mat, ip, 0 );

	if( rt_functab[ip->idb_type].ft_plot( &vhead, &intern, &mged_ttol, &mged_tol ) < 0 )  {
	  Tcl_AppendResult(interp, LAST_SOLID(sp)->d_namep,
			   ": re-plot failure\n", (char *)NULL);
	  return(-1);
	}
	rt_db_free_internal( &intern, &rt_uniresource );

	/* Write new displaylist */
	drawH_part2( sp->s_soldash, &vhead,
		(struct db_full_path *)0,
		(struct db_tree_state *)0, sp );

#if 0
	/* Release previous chunk of displaylist. */
	if( bytes > 0 )
		rt_memfree( &(dmp->dm_map), bytes, (unsigned long)addr );
#endif

	view_state->vs_flag = 1;
	return(0);
}

/*
 *			C V T _ V L B L O C K _ T O _ S O L I D S
 */
void
cvt_vlblock_to_solids(
	struct bn_vlblock	*vbp,
	const char		*name,
	int			copy)
{
	int		i;
	char		shortname[32];
	char		namebuf[64];
	char		*av[4];

	strncpy( shortname, name, 16-6 );
	shortname[16-6] = '\0';
	/* Remove any residue colors from a previous overlay w/same name */
	if( dbip->dbi_read_only )  {
		av[0] = "d";
		av[1] = shortname;
		av[2] = NULL;
		(void)cmd_erase((ClientData)NULL, interp, 2, av);
	} else {
		av[0] = "kill";
		av[1] = "-f";
		av[2] = shortname;
		av[3] = NULL;
		(void)cmd_kill((ClientData)NULL, interp, 3, av);
	}

	for( i=0; i < vbp->nused; i++ )  {
#if 0
		if( vbp->rgb[i] == 0 )  continue;
#endif
		if( BU_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;

		sprintf( namebuf, "%s%lx",
			shortname, vbp->rgb[i] );
		invent_solid( namebuf, &vbp->head[i], vbp->rgb[i], copy );
	}
}

/*
 *			I N V E N T _ S O L I D
 *
 *  Invent a solid by adding a fake entry in the database table,
 *  adding an entry to the solid table, and populating it with
 *  the given vector list.
 *
 *  This parallels much of the code in dodraw.c
 */
int
invent_solid(
	const char	*name,
	struct bu_list	*vhead,
	long		rgb,
	int		copy)
{
	struct directory	*dp;
	struct directory	*dpp[2] = {DIR_NULL, DIR_NULL};
	register struct solid	*sp;
	int type = 0;

	if(dbip == DBI_NULL)
	  return 0;

	if( (dp = db_lookup( dbip,  name, LOOKUP_QUIET )) != DIR_NULL )  {
	  if( dp->d_addr != RT_DIR_PHONY_ADDR )  {
	    Tcl_AppendResult(interp, "invent_solid(", name,
			     ") would clobber existing database entry, ignored\n", (char *)NULL);
	    return(-1);
	  }
	  /* Name exists from some other overlay,
	   * zap any associated solids
	   */
	  dpp[0] = dp;
	  eraseobjall(dpp);
	}
	/* Need to enter phony name in directory structure */
	dp = db_diradd( dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID, &type );

#if 0
	/* XXX need to get this going. */
	path.fp_names[0] = dp;
	state.ts_mater.ma_color[0] = ((rgb>>16) & 0xFF) / 255.0
	state.ts_mater.ma_color[1] = ((rgb>> 8) & 0xFF) / 255.0
	state.ts_mater.ma_color[2] = ((rgb    ) & 0xFF) / 255.0
	drawH_part2( 0, vhead, path, &state, SOLID_NULL );
#else

	/* Obtain a fresh solid structure, and fill it in */
	GET_SOLID(sp,&FreeSolid.l);

	if( copy )  {
		BU_LIST_INIT( &(sp->s_vlist) );
		rt_vlist_copy( &(sp->s_vlist), vhead );
	} else {
		BU_LIST_INIT(&(sp->s_vlist));
		BU_LIST_APPEND_LIST(&(sp->s_vlist), vhead);
	}
	mged_bound_solid( sp );
	nvectors += sp->s_vlen;

	/* set path information -- this is a top level node */
	db_add_node_to_full_path( &sp->s_fullpath, dp );

	sp->s_iflag = DOWN;
	sp->s_soldash = 0;
	sp->s_Eflag = 1;		/* Can't be solid edited! */
	sp->s_color[0] = sp->s_basecolor[0] = (rgb>>16) & 0xFF;
	sp->s_color[1] = sp->s_basecolor[1] = (rgb>> 8) & 0xFF;
	sp->s_color[2] = sp->s_basecolor[2] = (rgb    ) & 0xFF;
	sp->s_regionid = 0;
	sp->s_dlist = BU_LIST_LAST(solid, &dgop->dgo_headSolid)->s_dlist + 1;

	/* Solid successfully drawn, add to linked list of solid structs */
	BU_LIST_APPEND(dgop->dgo_headSolid.back, &sp->l);

#ifdef DO_DISPLAY_LISTS
	createDListALL(sp);
#endif
#endif
	return(0);		/* OK */
}

static union tree	*mged_facetize_tree;

/*
 *			M G E D _ F A C E T I Z E _ R E G I O N _ E N D
 *
 *  This routine must be prepared to run in parallel.
 */
HIDDEN union tree *
mged_facetize_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	struct bu_list		vhead;

	BU_LIST_INIT( &vhead );

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
	  char	*sofar = db_path_to_string(pathp);

	  Tcl_AppendResult(interp, "mged_facetize_region_end() path='", sofar,
			   "'\n", (char *)NULL);
	  bu_free((genptr_t)sofar, "path string");
	}

	if( curtree->tr_op == OP_NOP )  return  curtree;

	bu_semaphore_acquire( RT_SEM_MODEL );
	if( mged_facetize_tree )  {
		union tree	*tr;
		tr = (union tree *)bu_calloc(1, sizeof(union tree), "union tree");
		tr->magic = RT_TREE_MAGIC;
		tr->tr_op = OP_UNION;
		tr->tr_b.tb_regionp = REGION_NULL;
		tr->tr_b.tb_left = mged_facetize_tree;
		tr->tr_b.tb_right = curtree;
		mged_facetize_tree = tr;
	} else {
		mged_facetize_tree = curtree;
	}
	bu_semaphore_release( RT_SEM_MODEL );

	/* Tree has been saved, and will be freed later */
	return( TREE_NULL );
}

/* facetize [opts] new_obj old_obj(s) */
int
f_facetize(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int			i;
	register int		c;
	int			ncpu;
	int			triangulate;
	char			*newname;
	struct rt_db_internal	intern;
	struct directory	*dp;
	int			failed;
	int			mged_nmg_use_tnurbs = 0;
	int			make_bot;

	CHECK_DBI_NULL;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help facetize");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	RT_CHECK_DBI(dbip);

	/* Establish tolerances */
	mged_initial_tree_state.ts_ttol = &wdbp->wdb_ttol;
	mged_initial_tree_state.ts_tol = &wdbp->wdb_tol;

	/* Initial vaues for options, must be reset each time */
	ncpu = 1;
	triangulate = 0;

	/* Parse options. */
	make_bot = 1;
	bu_optind = 1;		/* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"ntTP:")) != EOF )  {
		switch(c)  {
		case 'n':
			make_bot = 0;
			break;
		case 'P':
			ncpu = atoi(bu_optarg);
			break;
		case 'T':
			triangulate = 1;
			break;
		case 't':
			mged_nmg_use_tnurbs = 1;
			break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls),
				     "Usage: facetize [-tT] [-P ncpu] object(s)\n",
				     "\t-t Perform CSG-to-tNURBS conversion\n",
				     "\t-T enable triangulator\n", (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }
		  break;
		}
	}
	argc -= bu_optind;
	argv += bu_optind;
	if( argc < 0 ){
	  Tcl_AppendResult(interp, "facetize: missing argument\n", (char *)NULL);
	  return TCL_ERROR;
	}

	newname = argv[0];
	argv++;
	argc--;
	if( argc < 0 ){
	  Tcl_AppendResult(interp, "facetize: missing argument\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( db_lookup( dbip, newname, LOOKUP_QUIET ) != DIR_NULL )  {
	  Tcl_AppendResult(interp, "error: solid '", newname,
			   "' already exists, aborting\n", (char *)NULL);
	  return TCL_ERROR;
	}

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls,
			"facetize:  tessellating primitives with tolerances a=%g, r=%g, n=%g\n",
			mged_abs_tol, mged_rel_tol, mged_nrm_tol );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	mged_facetize_tree = (union tree *)0;
  	mged_nmg_model = nmg_mm();
	mged_initial_tree_state.ts_m = &mged_nmg_model;

	i = db_walk_tree( dbip, argc, (const char **)argv,
		ncpu,
		&mged_initial_tree_state,
		0,			/* take all regions */
		mged_facetize_region_end,
  		mged_nmg_use_tnurbs ?
  			nmg_booltree_leaf_tnurb :
			nmg_booltree_leaf_tess,
		(genptr_t)NULL
		);


	if( i < 0 )  {
	  Tcl_AppendResult(interp, "facetize: error in db_walk_tree()\n", (char *)NULL);
	  /* Destroy NMG */
	  nmg_km( mged_nmg_model );
	  return TCL_ERROR;
	}

	if( mged_facetize_tree )
	{
		/* Now, evaluate the boolean tree into ONE region */
		Tcl_AppendResult(interp, "facetize:  evaluating boolean expressions\n", (char *)NULL);

		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: facetization failed!!!\n", (char *)NULL );
			if( mged_facetize_tree )
				db_free_tree( mged_facetize_tree, &rt_uniresource );
			mged_facetize_tree = (union tree *)NULL;
			nmg_km( mged_nmg_model );
			mged_nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}

		failed = nmg_boolean( mged_facetize_tree, mged_nmg_model, &mged_tol, &rt_uniresource );
		BU_UNSETJUMP;
	}
	else
		failed = 1;

	if( failed )  {
	  Tcl_AppendResult(interp, "facetize:  no resulting region, aborting\n", (char *)NULL);
	  if( mged_facetize_tree )
		db_free_tree( mged_facetize_tree, &rt_uniresource );
	  mged_facetize_tree = (union tree *)NULL;
	  nmg_km( mged_nmg_model );
	  mged_nmg_model = (struct model *)NULL;
	  return TCL_ERROR;
	}
	/* New region remains part of this nmg "model" */
	NMG_CK_REGION( mged_facetize_tree->tr_d.td_r );
	Tcl_AppendResult(interp, "facetize:  ", mged_facetize_tree->tr_d.td_name,
			 "\n", (char *)NULL);

	/* Triangulate model, if requested */
	if( triangulate && !make_bot )
	{
		Tcl_AppendResult(interp, "facetize:  triangulating resulting object\n", (char *)NULL);
		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: triangulation failed!!!\n", (char *)NULL );
			if( mged_facetize_tree )
				db_free_tree( mged_facetize_tree, &rt_uniresource );
			mged_facetize_tree = (union tree *)NULL;
			nmg_km( mged_nmg_model );
			mged_nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}
		nmg_triangulate_model( mged_nmg_model , &mged_tol );
		BU_UNSETJUMP;
	}

	if( make_bot )
	{
		struct rt_bot_internal *bot;
		struct nmgregion *r;
		struct shell *s;

		Tcl_AppendResult(interp, "facetize:  converting to BOT format\n", (char *)NULL);

		r = BU_LIST_FIRST( nmgregion, &mged_nmg_model->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );
		bot = (struct rt_bot_internal *)nmg_bot( s, &mged_tol );
		nmg_km( mged_nmg_model );
		mged_nmg_model = (struct model *)NULL;

		/* Export BOT as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_BOT;
		intern.idb_meth = &rt_functab[ID_BOT];
		intern.idb_ptr = (genptr_t) bot;
	}
	else
	{

		Tcl_AppendResult(interp, "facetize:  converting NMG to database format\n", (char *)NULL);

		/* Export NMG as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_NMG;
		intern.idb_meth = &rt_functab[ID_NMG];
		intern.idb_ptr = (genptr_t)mged_nmg_model;
		mged_nmg_model = (struct model *)NULL;
	}

	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", newname, " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}
	
	mged_facetize_tree->tr_d.td_r = (struct nmgregion *)NULL;

	/* Free boolean tree, and the regions in it */
	db_free_tree( mged_facetize_tree, &rt_uniresource );
    	mged_facetize_tree = (union tree *)NULL;

	return TCL_OK;					/* OK */
}

/* bev [opts] new_obj obj1 op obj2 op obj3 ...
 *
 *	tesselates each operand object, then performs
 *	the Boolean evaluation, storing result in
 *	new_obj
 */
int
f_bev(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int			i;
	register int		c;
	int			ncpu;
	int			triangulate;
	char			*newname;
	struct rt_db_internal	intern;
	struct directory	*dp;
	union tree		*tmp_tree;
	char			op;
	int			failed;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help bev");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	RT_CHECK_DBI( dbip );

	/* Establish tolerances */
	mged_initial_tree_state.ts_ttol = &mged_ttol;
	mged_initial_tree_state.ts_tol = &mged_tol;

	mged_ttol.magic = RT_TESS_TOL_MAGIC;
	mged_ttol.abs = mged_abs_tol;
	mged_ttol.rel = mged_rel_tol;
	mged_ttol.norm = mged_nrm_tol;

	/* Initial vaues for options, must be reset each time */
	ncpu = 1;
	triangulate = 0;

	/* Parse options. */
	bu_optind = 1;		/* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"tP:")) != EOF )  {
		switch(c)  {
		case 'P':
#if 0
			/* not yet supported */
			ncpu = atoi(bu_optarg);
#endif
			break;
		case 't':
			triangulate = 1;
			break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }

		  break;
		}
	}
	argc -= bu_optind;
	argv += bu_optind;

	newname = argv[0];
	argv++;
	argc--;

	if( db_lookup( dbip, newname, LOOKUP_QUIET ) != DIR_NULL )  {
	  Tcl_AppendResult(interp, "error: solid '", newname,
			   "' already exists, aborting\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( argc < 1 )
	{
	  Tcl_AppendResult(interp, "Nothing to evaluate!!!\n", (char *)NULL);
	  return TCL_ERROR;
	}

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls,
			"bev:  tessellating primitives with tolerances a=%g, r=%g, n=%g\n",
			mged_abs_tol, mged_rel_tol, mged_nrm_tol);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	mged_facetize_tree = (union tree *)0;
  	mged_nmg_model = nmg_mm();
	mged_initial_tree_state.ts_m = &mged_nmg_model;

	op = ' ';
	tmp_tree = (union tree *)NULL;

	while( argc )
	{
		i = db_walk_tree( dbip, 1, (const char **)argv,
			ncpu,
			&mged_initial_tree_state,
			0,			/* take all regions */
			mged_facetize_region_end,
			nmg_booltree_leaf_tess,
			(genptr_t)NULL );

		if( i < 0 )  {
		  Tcl_AppendResult(interp, "bev: error in db_walk_tree()\n", (char *)NULL);
		  /* Destroy NMG */
		  nmg_km( mged_nmg_model );
		  return TCL_ERROR;
		}
		argc--;
		argv++;

		if( tmp_tree && op != ' ' )
		{
			union tree *new_tree;

			BU_GETUNION( new_tree, tree );

			new_tree->magic = RT_TREE_MAGIC;
			new_tree->tr_b.tb_regionp = REGION_NULL;
			new_tree->tr_b.tb_left = tmp_tree;
			new_tree->tr_b.tb_right = mged_facetize_tree;

			switch( op )
			{
				case 'u':
				case 'U':
					new_tree->tr_op = OP_UNION;
					break;
				case '-':
					new_tree->tr_op = OP_SUBTRACT;
					break;
				case '+':
					new_tree->tr_op = OP_INTERSECT;
					break;
				default:
				  {
				    struct bu_vls tmp_vls;

				    bu_vls_init(&tmp_vls);
				    bu_vls_printf(&tmp_vls, "Unrecognized operator: (%c)\n" , op );
				    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls),
						     "Aborting\n", (char *)NULL);
				    bu_vls_free(&tmp_vls);
				    db_free_tree( mged_facetize_tree, &rt_uniresource );
				    nmg_km( mged_nmg_model );
				    return TCL_ERROR;
				  }
			}

			tmp_tree = new_tree;
			mged_facetize_tree = (union tree *)NULL;
		}
		else if( !tmp_tree && op == ' ' )
		{
			/* just starting out */
			tmp_tree = mged_facetize_tree;
			mged_facetize_tree = (union tree *)NULL;
		}

		if( argc )
		{
			op = *argv[0];
			argc--;
			argv++;
		}
		else
			op = ' ';

	}

	if( tmp_tree )
	{
		/* Now, evaluate the boolean tree into ONE region */
		Tcl_AppendResult(interp, "bev:  evaluating boolean expressions\n", (char *)NULL);

		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;

			Tcl_AppendResult(interp, "WARNING: Boolean evaluation failed!!!\n", (char *)NULL );
			if( tmp_tree )
				db_free_tree( tmp_tree, &rt_uniresource );
			tmp_tree = (union tree *)NULL;
			nmg_km( mged_nmg_model );
			mged_nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}

		failed = nmg_boolean( tmp_tree, mged_nmg_model, &mged_tol, &rt_uniresource );
		BU_UNSETJUMP;
	}
	else
		failed = 1;

	if( failed )  {
	  Tcl_AppendResult(interp, "bev:  no resulting region, aborting\n", (char *)NULL);
	  if( tmp_tree )
		db_free_tree( tmp_tree, &rt_uniresource );
	  tmp_tree = (union tree *)NULL;
	  nmg_km( mged_nmg_model );
	  mged_nmg_model = (struct model *)NULL;
	  return TCL_ERROR;
	}
	/* New region remains part of this nmg "model" */
	NMG_CK_REGION( tmp_tree->tr_d.td_r );
	Tcl_AppendResult(interp, "facetize:  ", tmp_tree->tr_d.td_name, "\n", (char *)NULL);

	nmg_vmodel( mged_nmg_model );

	/* Triangulate model, if requested */
	if( triangulate )
	{
		Tcl_AppendResult(interp, "bev:  triangulating resulting object\n", (char *)NULL);
		if( BU_SETJUMP )
		{
			BU_UNSETJUMP;
			Tcl_AppendResult(interp, "WARNING: Triangulation failed!!!\n", (char *)NULL );
			if( tmp_tree )
				db_free_tree( tmp_tree, &rt_uniresource );
			tmp_tree = (union tree *)NULL;
			nmg_km( mged_nmg_model );
			mged_nmg_model = (struct model *)NULL;
			return TCL_ERROR;
		}
		nmg_triangulate_model( mged_nmg_model , &mged_tol );
		BU_UNSETJUMP;
	}

	Tcl_AppendResult(interp, "bev:  converting NMG to database format\n", (char *)NULL);

	/* Export NMG as a new solid */
	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern.idb_type = ID_NMG;
	intern.idb_meth = &rt_functab[ID_NMG];
	intern.idb_ptr = (genptr_t)mged_nmg_model;
	mged_nmg_model = (struct model *)NULL;

	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL ) {
		Tcl_AppendResult(interp, "Cannot add ", newname, " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}

	tmp_tree->tr_d.td_r = (struct nmgregion *)NULL;

	/* Free boolean tree, and the regions in it. */
	db_free_tree( tmp_tree, &rt_uniresource );


	{
	  char *av[3];

	  av[0] = "e";
	  av[1] = newname;
	  av[2] = NULL;

	  /* draw the new solid */
	  return cmd_draw( clientData, interp, 2, av );
	}
}

/*
 *			A D D _ S O L I D _ P A T H _ T O _ R E S U L T
 */
void
add_solid_path_to_result(
	Tcl_Interp *interp,
	struct solid *sp)
{
	struct bu_vls str;

	bu_vls_init(&str);
	db_path_to_vls(&str, &sp->s_fullpath );
	Tcl_AppendResult( interp, bu_vls_addr(&str), " ", NULL );
	bu_vls_free(&str);
}

/*
 *			R E D R A W _ V L I S T
 *
 *  Given the name(s) of database objects, re-generate the vlist
 *  associated with every solid in view which references the
 *  named object(s), either solids or regions.
 *  Particularly useful with outboard .inmem database modifications.
 */
int
cmd_redraw_vlist(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory	*dp;
	int		i;

	CHECK_DBI_NULL;

	if( argc < 2 )  {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help redraw_vlist");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( i = 1; i < argc; i++ )  {
		register struct solid	*sp;

		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY )) == NULL )
			continue;

		FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
			if( db_full_path_search( &sp->s_fullpath, dp ) )  {
#if 0
				add_solid_path_to_result(interp, sp);
#endif
				(void)replot_original_solid( sp );
				sp->s_iflag = DOWN;	/* It won't be drawn otherwise */
			}
		}
	}


	update_views = 1;
	return TCL_OK;
}
@


11.123
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/dodraw.c,v 11.122 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.122
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.121
log
@merge of windows-6-0-branch into head
@
text
@d51 2
a52 2
void		cvt_vlblock_to_solids();
void		drawH_part2();
d140 3
a142 3
mged_plot_anim_upcall_handler( file, us )
char	*file;
long	us;		/* microseconds of extra delay */
d192 4
a195 4
mged_vlblock_anim_upcall_handler( vbp, us, copy )
struct bn_vlblock	*vbp;
long		us;		/* microseconds of extra delay */
int		copy;
d229 1
a229 1
hack_for_lee()
d241 2
a242 13
#ifndef WIN32
HIDDEN union tree *mged_wireframe_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
#else
HIDDEN union tree *mged_wireframe_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t		client_data)
#endif
d252 2
a253 10
#ifndef WIN32
HIDDEN union tree *mged_wireframe_leaf( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
#else
HIDDEN union tree *mged_wireframe_leaf(struct db_tree_state *tsp,struct db_full_path *pathp,
struct rt_db_internal *ip,genptr_t client_data)
#endif
a335 8
#ifndef WIN32
int
mged_nmg_region_start( tsp, pathp, combp, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t client_data;
#else
d337 1
a337 6
mged_nmg_region_start(
struct db_tree_state	*tsp,
struct db_full_path	*pathp,
const struct rt_comb_internal *combp,
genptr_t client_data)
#endif
d434 2
a435 13
#ifndef WIN32
HIDDEN union tree *mged_nmg_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t client_data;
#else
HIDDEN union tree *mged_nmg_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t client_data)
#endif
d791 1
a791 2
mged_bound_solid( sp )
register struct solid *sp;
d937 1
a937 5
Do_getmat( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i             *dbip;
struct rt_comb_internal *comb;
union tree              *comb_leaf;
genptr_t                user_ptr1, user_ptr2, user_ptr3;
d1254 2
a1255 13
#ifndef WIN32
HIDDEN union tree *mged_facetize_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
#else
HIDDEN union tree *mged_facetize_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t		client_data)
#endif
d1292 1
a1292 5
f_facetize(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1532 1
a1532 5
f_bev(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1836 1
a1836 5
cmd_redraw_vlist( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.120
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.119 2002/08/20 17:08:22 jra Exp $ (BRL)";
d241 1
d247 7
d263 1
d269 4
d355 1
d362 8
d466 1
d472 7
d1302 1
d1308 7
@


11.119
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.117 2002/08/14 17:24:39 jra Exp $ (BRL)";
@


11.119.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.120 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.119.10.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.119.10.1 2004/02/12 18:34:13 erikg Exp $ (BRL)";
@


11.119.10.3
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a240 1
#ifndef WIN32
a245 7
#else
HIDDEN union tree *mged_wireframe_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t		client_data)
#endif
a254 1
#ifndef WIN32
a259 4
#else
HIDDEN union tree *mged_wireframe_leaf(struct db_tree_state *tsp,struct db_full_path *pathp,
struct rt_db_internal *ip,genptr_t client_data)
#endif
a341 1
#ifndef WIN32
a347 8
#else
int
mged_nmg_region_start(
struct db_tree_state	*tsp,
struct db_full_path	*pathp,
const struct rt_comb_internal *combp,
genptr_t client_data)
#endif
a443 1
#ifndef WIN32
a448 7
#else
HIDDEN union tree *mged_nmg_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t client_data)
#endif
a1271 1
#ifndef WIN32
a1276 7
#else
HIDDEN union tree *mged_facetize_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t		client_data)
#endif
@


11.119.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.119 2002/08/20 17:08:22 jra Exp $ (BRL)";
a240 1
#ifndef WIN32
a245 7
#else
HIDDEN union tree *mged_wireframe_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t		client_data)
#endif
a254 1
#ifndef WIN32
a259 4
#else
HIDDEN union tree *mged_wireframe_leaf(struct db_tree_state *tsp,struct db_full_path *pathp,
struct rt_db_internal *ip,genptr_t client_data)
#endif
a341 1
#ifndef WIN32
a347 8
#else
int
mged_nmg_region_start(
struct db_tree_state	*tsp,
struct db_full_path	*pathp,
const struct rt_comb_internal *combp,
genptr_t client_data)
#endif
a443 1
#ifndef WIN32
a448 7
#else
HIDDEN union tree *mged_nmg_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t client_data)
#endif
a1271 1
#ifndef WIN32
a1276 7
#else
HIDDEN union tree *mged_facetize_region_end(
register struct db_tree_state	*tsp,
struct db_full_path	*pathp,
union tree		*curtree,
genptr_t		client_data)
#endif
@


11.119.4.2
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/dodraw.c,v 11.119.4.1 2002/09/26 23:04:10 morrison Exp $ (BRL)";
@


11.119.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.119 2002/08/20 17:08:22 jra Exp $ (BRL)";
d51 2
a52 2
void		cvt_vlblock_to_solids(struct bn_vlblock *vbp, const char *name, int copy);
void		drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp);
d140 3
a142 3
mged_plot_anim_upcall_handler(char *file, long int us)
    	      
    	   		/* microseconds of extra delay */
d192 4
a195 4
mged_vlblock_anim_upcall_handler(struct bn_vlblock *vbp, long int us, int copy)
                 	     
    		   		/* microseconds of extra delay */
   		     
d229 1
a229 1
hack_for_lee(void)
d241 5
a245 1
HIDDEN union tree *mged_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d255 5
a259 1
HIDDEN union tree *mged_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d343 5
a347 1
mged_nmg_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d444 5
a448 1
HIDDEN union tree *mged_nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d804 2
a805 1
mged_bound_solid(register struct solid *sp)
d951 5
a955 1
Do_getmat(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3)
d1272 5
a1276 1
HIDDEN union tree *mged_facetize_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d1313 5
a1317 1
f_facetize(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1557 5
a1561 1
f_bev(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1865 5
a1869 1
cmd_redraw_vlist(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.119.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.118
log
@Converted from K&R to ANSI C - RFH
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.116 2002/01/09 19:56:06 jra Exp $ (BRL)";
d51 2
a52 2
void		cvt_vlblock_to_solids(struct bn_vlblock *vbp, const char *name, int copy);
void		drawH_part2(int dashflag, struct bu_list *vhead, struct db_full_path *pathp, struct db_tree_state *tsp, struct solid *existing_sp);
d140 3
a142 3
mged_plot_anim_upcall_handler(char *file, long int us)
    	      
    	   		/* microseconds of extra delay */
d192 4
a195 4
mged_vlblock_anim_upcall_handler(struct bn_vlblock *vbp, long int us, int copy)
                 	     
    		   		/* microseconds of extra delay */
   		     
d229 1
a229 1
hack_for_lee(void)
d241 5
a245 1
HIDDEN union tree *mged_wireframe_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d255 5
a259 1
HIDDEN union tree *mged_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d343 5
a347 1
mged_nmg_region_start(struct db_tree_state *tsp, struct db_full_path *pathp, const struct rt_comb_internal *combp, genptr_t client_data)
d444 5
a448 1
HIDDEN union tree *mged_nmg_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d804 2
a805 1
mged_bound_solid(register struct solid *sp)
d951 5
a955 1
Do_getmat(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3)
d1272 5
a1276 1
HIDDEN union tree *mged_facetize_region_end(register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d1313 5
a1317 1
f_facetize(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1345 2
a1346 7
	mged_initial_tree_state.ts_ttol = &mged_ttol;
	mged_initial_tree_state.ts_tol = &mged_tol;

	mged_ttol.magic = RT_TESS_TOL_MAGIC;
	mged_ttol.abs = mged_abs_tol;
	mged_ttol.rel = mged_rel_tol;
	mged_ttol.norm = mged_nrm_tol;
d1557 5
a1561 1
f_bev(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1865 5
a1869 1
cmd_redraw_vlist(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.117
log
@f_facetize() now uses the tolerances from wdbp
@
text
@d51 2
a52 2
void		cvt_vlblock_to_solids();
void		drawH_part2();
d140 3
a142 3
mged_plot_anim_upcall_handler( file, us )
char	*file;
long	us;		/* microseconds of extra delay */
d192 4
a195 4
mged_vlblock_anim_upcall_handler( vbp, us, copy )
struct bn_vlblock	*vbp;
long		us;		/* microseconds of extra delay */
int		copy;
d229 1
a229 1
hack_for_lee()
d241 1
a241 5
HIDDEN union tree *mged_wireframe_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d251 1
a251 5
HIDDEN union tree *mged_wireframe_leaf( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d335 1
a335 5
mged_nmg_region_start( tsp, pathp, combp, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
const struct rt_comb_internal *combp;
genptr_t client_data;
d432 1
a432 5
HIDDEN union tree *mged_nmg_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t client_data;
d788 1
a788 2
mged_bound_solid( sp )
register struct solid *sp;
d934 1
a934 5
Do_getmat( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i             *dbip;
struct rt_comb_internal *comb;
union tree              *comb_leaf;
genptr_t                user_ptr1, user_ptr2, user_ptr3;
d1251 1
a1251 5
HIDDEN union tree *mged_facetize_region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d1288 1
a1288 5
f_facetize(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1316 7
a1322 2
	mged_initial_tree_state.ts_ttol = &wdbp->wdb_ttol;
	mged_initial_tree_state.ts_tol = &wdbp->wdb_tol;
d1533 1
a1533 5
f_bev(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1837 1
a1837 5
cmd_redraw_vlist( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.116
log
@Eliminated previous mod (not needed)
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.115 2002/01/08 20:58:44 jra Exp $ (BRL)";
d1345 2
a1346 7
	mged_initial_tree_state.ts_ttol = &mged_ttol;
	mged_initial_tree_state.ts_tol = &mged_tol;

	mged_ttol.magic = RT_TESS_TOL_MAGIC;
	mged_ttol.abs = mged_abs_tol;
	mged_ttol.rel = mged_rel_tol;
	mged_ttol.norm = mged_nrm_tol;
@


11.115
log
@bev command now handles long names
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.114 2001/10/02 19:24:32 jra Exp $ (BRL)";
d1816 3
a1818 18
	if( dbip->dbi_version < 5 ) {
		if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL ) {
			Tcl_AppendResult(interp, "Cannot add ", newname, " to directory\n", (char *)NULL );
			return TCL_ERROR;
		}
	} else {
		struct bu_attribute_value_set avs;

		bu_avs_init( &avs, 1, "avs" );
		if ((dp = db_diradd5(dbip, newname, -1L,
				     intern.idb_major_type, intern.idb_type,
				     (unsigned char)'\0', 0, &avs )) == DIR_NULL)  {
			bu_avs_free( &avs );
			Tcl_AppendResult(interp, "An error has occured while adding '",
					 newname, "' to the database.\n", (char *)NULL);
			return TCL_ERROR;
		}
		bu_avs_free( &avs );
@


11.114
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.113 2001/08/27 19:00:50 jra Exp $ (BRL)";
d1816 18
a1833 4
	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", newname, " to directory\n", (char *)NULL );
		return TCL_ERROR;
@


11.113
log
@f_bev() modified to ignore the -P option (it doesn't work)
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.112 2001/06/01 19:23:23 bparker Exp $ (BRL)";
d1515 1
d1527 1
d1810 1
@


11.112
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.111 2001/05/17 20:05:34 morrison Exp $ (BRL)";
d1610 2
d1613 1
@


11.111
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.110 2001/05/08 20:20:58 jra Exp $ (BRL)";
d47 1
d150 1
a150 1
	(void)f_overlay((ClientData)NULL, interp, 2, av);
d883 1
a883 1
		sp->s_dlist = BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist + 1;
d942 1
a942 1
		BU_LIST_APPEND(HeadSolid.l.back, &sp->l);
d1161 1
a1161 1
		(void)f_erase((ClientData)NULL, interp, 2, av);
d1167 1
a1167 1
		(void)f_kill((ClientData)NULL, interp, 3, av);
d1253 1
a1253 1
	sp->s_dlist = BU_LIST_LAST(solid, &HeadSolid.l)->s_dlist + 1;
d1256 1
a1256 1
	BU_LIST_APPEND(HeadSolid.l.back, &sp->l);
d1836 1
a1836 1
	  return f_edit( clientData, interp, 2, av );
d1892 1
a1892 1
		FOR_ALL_SOLIDS(sp, &HeadSolid.l)  {
@


11.110
log
@Added initialization for the AVS structure in db_tree_state
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.109 2001/04/05 19:35:44 morrison Exp $ (BRL)";
d270 1
a270 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d355 1
a355 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d399 1
a399 1
			if(rt_g.debug&DEBUG_TREEWALK)  {
d411 1
a411 1
			if (rt_g.debug&DEBUG_TREEWALK) {
d459 1
a459 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
d1281 1
a1281 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
@


11.109
log
@updated SIGNED to signed
updated CONST to const
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.108 2001/04/02 21:38:19 morrison Exp $ (BRL)";
d90 14
@


11.108
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.107 2001/03/31 01:57:21 morrison Exp $ (BRL)";
d331 1
a331 1
CONST struct rt_comb_internal *combp;
d718 1
a718 1
		ret = db_walk_tree( dbip, argc, (CONST char **)argv,
d753 1
a753 1
		ret = db_walk_tree( dbip, argc, (CONST char **)argv,
d1409 1
a1409 1
	i = db_walk_tree( dbip, argc, (CONST char **)argv,
d1652 1
a1652 1
		i = db_walk_tree( dbip, 1, (CONST char **)argv,
@


11.107
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.106 2001/03/23 22:05:34 jra Exp $ (BRL)";
d958 4
a961 3
	if( comb_leaf->tr_l.tl_mat )
		bn_mat_copy( xmat, comb_leaf->tr_l.tl_mat );
	else
d963 1
d1014 1
a1014 1
	bn_mat_copy( matp, ts.ts_mat );	/* implicit return */
@


11.106
log
@Support for major and minor types in directory structure
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/dodraw.c,v 11.105 2000/11/17 06:02:01 mike Exp $ (BRL)";
d961 1
a961 1
		bn_mat_idn( xmat );
@


11.105
log
@
Modified MGED's "fast path" through the "ev" command for drawing polygonal
objects to (a) use the g_xxx.c plot routine rather than duplicating the
code, and (b) added methods for drawing the polygonal version.
Extended fast path to work for Bots.
Also included fixes in new DGO stuff.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.104 2000/11/14 18:09:46 jra Exp $ (BRL)";
d1184 1
d1202 1
a1202 1
	dp = db_diradd( dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID, NULL );
d1515 1
a1515 1
	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
d1793 1
a1793 1
	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID, NULL)) == DIR_NULL )
@


11.104
log
@facetize command now makes BOT's by default (added "-n" option for NMG's)
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.103 2000/10/24 19:05:05 mike Exp $ (BRL)";
a384 4
			struct rt_pg_internal	*pgp;
			register int	i;
			int		p;

d386 13
a398 1
				bu_log("fastpath draw ID_POLY\n", dp->d_namep);
a399 3
			pgp = (struct rt_pg_internal *)intern.idb_ptr;
			RT_PG_CK_MAGIC(pgp);

d401 1
a401 11
				for( p = 0; p < pgp->npoly; p++ )  {
					register struct rt_pg_face_internal	*pp;

					pp = &pgp->poly[p];
					RT_ADD_VLIST( &vhead, &pp->verts[3*(pp->npts-1)],
						BN_VLIST_LINE_MOVE );
					for( i=0; i < pp->npts; i++ )  {
						RT_ADD_VLIST( &vhead, &pp->verts[3*i],
							BN_VLIST_LINE_DRAW );
					}
				}
d403 1
a403 22
				for( p = 0; p < pgp->npoly; p++ )  {
					register struct rt_pg_face_internal	*pp;
					vect_t aa, bb, norm;

					pp = &pgp->poly[p];
					if( pp->npts < 3 )  continue;
					VSUB2( aa, &pp->verts[3*(0)], &pp->verts[3*(1)] );
					VSUB2( bb, &pp->verts[3*(0)], &pp->verts[3*(2)] );
					VCROSS( norm, aa, bb );
					VUNITIZE(norm);
					RT_ADD_VLIST( &vhead, norm,
						BN_VLIST_POLY_START );

					RT_ADD_VLIST( &vhead, &pp->verts[3*(pp->npts-1)],
						BN_VLIST_POLY_MOVE );
					for( i=0; i < pp->npts-1; i++ )  {
						RT_ADD_VLIST( &vhead, &pp->verts[3*i],
							BN_VLIST_POLY_DRAW );
					}
					RT_ADD_VLIST( &vhead, &pp->verts[3*(pp->npts-1)],
						BN_VLIST_POLY_END );
				}
@


11.103
log
@
Fixed compiler lint, function declarations.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.102 2000/10/20 05:04:38 mike Exp $ (BRL)";
d1336 1
d1366 1
d1368 1
a1368 1
	while( (c=bu_getopt(argc,argv,"tTP:")) != EOF )  {
d1370 3
d1489 1
a1489 1
	if( triangulate )
d1507 24
a1530 1
	Tcl_AppendResult(interp, "facetize:  converting NMG to database format\n", (char *)NULL);
d1532 7
a1538 6
	/* Export NMG as a new solid */
	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_type = ID_NMG;
	intern.idb_meth = &rt_functab[ID_NMG];
	intern.idb_ptr = (genptr_t)mged_nmg_model;
	mged_nmg_model = (struct model *)NULL;
@


11.102
log
@
s_path array has been replaced by a s_fullpath "struct db_full_path".
This has eliminated the MAX_PATH restriction in MGED.
member s_last is gone too.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.101 2000/09/21 02:46:51 mike Exp $ (BRL)";
d1823 3
a1825 3
add_solid_path_to_result( interp, sp )
Tcl_Interp *interp;
register struct solid	*sp;
@


11.101
log
@
Need to initialize ts.ts_resp
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.100 2000/09/09 04:30:55 mike Exp $ (BRL)";
a887 1
	register int	i;
a889 8
		if (pathp->fp_len > MAX_PATH) {
		  char *cp = db_path_to_string(pathp);

		  Tcl_AppendResult(interp, "drawH_part2: path too long, solid ignored.\n\t",
				   cp, "\n", (char *)NULL);
		  bu_free((genptr_t)cp, "Path string");
		  return;
		}
d941 1
a941 6
		sp->s_last = pathp->fp_len-1;

		/* Copy path information */
		for( i=0; i<=sp->s_last; i++ ) {
			sp->s_path[i] = pathp->fp_names[i];
		}
a990 20
 *			F U L L _ P A T H _ F R O M _ S O L I D
 *
 *  Initializes a 'db_full_path' to correspond to sp->s_path.
 */
void
full_path_from_solid( pathp, sp )
struct db_full_path	*pathp;
register struct solid	*sp;
{
	pathp->fp_len = pathp->fp_maxlen = sp->s_last+1;
	pathp->fp_names = (struct directory **)bu_malloc(
		pathp->fp_maxlen * sizeof(struct directory *),
		"db_full_path array");
	pathp->magic = DB_FULL_PATH_MAGIC;

	bcopy( (char *)sp->s_path, (char *)pathp->fp_names,
		pathp->fp_len * sizeof(struct directory *) );
}

/*
a1007 1
	struct db_full_path	path;
a1010 2
	full_path_from_solid( &path, sp );

d1016 1
a1016 1
	(void)db_follow_path( &ts, &null_path, &path, LOOKUP_NOISY, depth+1 );
a1017 1
	db_free_full_path( &path );
a1040 49

#if 0
	register struct directory *parentp;
	register struct directory *kidp;
	register int		j;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	auto mat_t		tmat;
	register int		i;

	if(dbip == DBI_NULL)
	  return;

	bn_mat_idn( matp );
	for( i=0; i <= depth; i++ )  {
		parentp = sp->s_path[i];
		kidp = sp->s_path[i+1];
		if( !(parentp->d_flags & DIR_COMB) )  {
		  Tcl_AppendResult(interp, "pathHmat:  ", parentp->d_namep,
				   " is not a combination\n", (char *)NULL);
		  return;		/* ERROR */
		}

		if( rt_db_get_internal( &intern, parentp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
			READ_ERR_return;
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		if( comb->tree )
		{
			static mat_t xmat;	/* temporary fastf_t matrix */
			int found=0;

			db_tree_funcleaf( dbip, comb, comb->tree, Do_getmat,
				(genptr_t)xmat, (genptr_t)kidp->d_namep, (genptr_t)&found );
			rt_db_free_internal( &intern, &rt_uniresource );

			if( found )
			{
				bn_mat_mul( tmat, matp, xmat );
				bn_mat_copy( matp, tmat );
			}
			else
			{
				Tcl_AppendResult(interp, "pathHmat: unable to follow ", parentp->d_namep,
						 "/", kidp->d_namep, "\n", (char *)NULL);
				return;			/* ERROR */
			}
		}
	}
#endif
d1064 1
a1064 1
	dp = sp->s_path[sp->s_last];
d1070 1
a1070 1
	pathHmat( sp, mat, sp->s_last-1 );
d1128 1
a1128 1
	  Tcl_AppendResult(interp, sp->s_path[sp->s_last]->d_namep,
d1252 1
a1252 2
	sp->s_last = 0;
	sp->s_path[0] = dp;
d1827 1
a1827 1
	register int	i;
d1829 4
a1832 5
	for( i = 0; i <= sp->s_last; i++ )  {
		Tcl_AppendResult( interp, sp->s_path[i]->d_namep,
			i == sp->s_last ? NULL : "/", NULL );
	}
	Tcl_AppendResult( interp, " ", NULL );
d1872 1
a1872 4
			register int j;
			for( j = sp->s_last; j >= 0; j-- )  {
				if( sp->s_path[j] != dp )
					continue;
a1877 1
				break;
@


11.100
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.99 2000/09/08 05:55:48 mike Exp $ (BRL)";
d1051 1
@


11.99
log
@
Tree routines now need resource structure.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.98 2000/09/07 02:43:21 mike Exp $ (BRL)";
d66 1
d89 10
@


11.98
log
@
More externs to ged.h to silence lint
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.97 2000/08/19 03:10:14 mike Exp $ (BRL)";
d368 1
a368 1
	if( rt_db_get_internal(&intern, dp, tsp->ts_dbip, matp) < 0 )
d426 1
a426 1
	rt_db_free_internal(&intern);
d434 1
a434 1
	rt_db_free_internal(&intern);
d481 1
a481 1
				db_free_tree( curtree );
d484 1
a484 1
		failed = nmg_boolean( curtree, *tsp->ts_m, tsp->ts_tol );
d487 1
a487 1
			db_free_tree( curtree );
d494 1
a494 1
	  db_free_tree( curtree );
d501 1
a501 1
		db_free_tree( curtree );
d516 1
a516 1
				db_free_tree( curtree );
d552 1
a552 1
		db_free_tree( curtree );
d1090 1
a1090 1
		if( rt_db_get_internal( &intern, parentp, dbip, (fastf_t *)NULL ) < 0 )
d1100 1
a1100 1
			rt_db_free_internal( &intern );
d1147 1
a1147 1
	if( rt_db_get_internal( &intern, dp, dbip, mat ) < 0 )  {
d1154 1
a1154 1
		rt_db_free_internal( &intern );
d1157 1
a1157 1
	rt_db_free_internal( &intern );
d1207 1
a1207 1
	rt_db_free_internal( &intern );
d1532 1
a1532 1
				db_free_tree( mged_facetize_tree );
d1539 1
a1539 1
		failed = nmg_boolean( mged_facetize_tree, mged_nmg_model, &mged_tol );
d1548 1
a1548 1
		db_free_tree( mged_facetize_tree );
d1568 1
a1568 1
				db_free_tree( mged_facetize_tree );
d1593 1
a1593 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
d1595 1
a1595 1
		rt_db_free_internal( &intern );
d1602 1
a1602 1
	db_free_tree( mged_facetize_tree );
d1771 1
a1771 1
				    db_free_tree( mged_facetize_tree );
d1809 1
a1809 1
				db_free_tree( tmp_tree );
d1816 1
a1816 1
		failed = nmg_boolean( tmp_tree, mged_nmg_model, &mged_tol );
d1825 1
a1825 1
		db_free_tree( tmp_tree );
d1846 1
a1846 1
				db_free_tree( tmp_tree );
d1871 1
a1871 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
d1873 1
a1873 1
		rt_db_free_internal( &intern );
d1880 1
a1880 1
	db_free_tree( tmp_tree );
@


11.97
log
@
Reduced use of MAXARGS
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.96 2000/06/30 19:58:09 mike Exp $ (BRL)";
d577 4
a580 4
drawtrees( argc, argv, kind )
int	argc;
char	**argv;
int	kind;
d869 6
a874 6
drawH_part2( dashflag, vhead, pathp, tsp, existing_sp )
int			dashflag;
struct bu_list		*vhead;
struct db_full_path	*pathp;
struct db_tree_state	*tsp;
struct solid		*existing_sp;
d1024 4
a1027 3
pathHmat( sp, matp, depth )
register struct solid *sp;
matp_t matp;
d1130 1
a1130 2
replot_original_solid( sp )
struct solid	*sp;
d1174 4
a1177 4
replot_modified_solid( sp, ip, mat )
struct solid			*sp;
struct rt_db_internal		*ip;
CONST mat_t			mat;
d1228 4
a1231 4
cvt_vlblock_to_solids( vbp, name, copy )
struct bn_vlblock	*vbp;
char			*name;
int			copy;
d1276 5
a1280 5
invent_solid( name, vhead, rgb, copy )
char		*name;
struct bu_list	*vhead;
long		rgb;
int		copy;
@


11.96
log
@
ft_ifree calls replaced properly
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.95 2000/06/28 17:39:41 mike Exp $ (BRL)";
d31 5
d74 1
a74 1
		1.0, 0.0, 0.0,		/* color, RGB */
d84 1
a84 1
	1.0, 0.0, 0.0, 0.0,
d87 1
a87 1
	0.0, 0.0, 0.0, 1.0,
d316 1
a1134 1
	int			id;
d1415 1
a1415 1
	if(argc < 3 || MAXARGS < argc){
d1635 1
a1635 1
	if(argc < 2 || MAXARGS < argc){
@


11.95
log
@
Changed to use rt_db_get_internal().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.94 2000/06/28 16:36:42 mike Exp $ (BRL)";
d1093 1
a1093 1
			rt_comb_ifree( &intern );
d1202 1
a1202 1
    	if( intern.idb_ptr )  rt_functab[ip->idb_type].ft_ifree( &intern );
@


11.94
log
@
Added additional magic number checks.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.93 2000/06/27 17:36:09 mike Exp $ (BRL)";
a1125 1
	struct bu_external	ext;
d1142 1
a1142 12
	BU_INIT_EXTERNAL( &ext );
	if( db_get_external( &ext, dp, dbip ) < 0 )  return(-1);

	if( (id = rt_id_solid( &ext )) == ID_NULL )  {
	  Tcl_AppendResult(interp, "replot_original_solid() unable to identify type of solid ",
			   dp->d_namep, "\n", (char *)NULL);
	  db_free_external( &ext );
	  return(-1);
	}

    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, &ext, mat, dbip ) < 0 )  {
a1143 2
	  if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
	  db_free_external( &ext );
d1149 1
a1149 2
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		db_free_external( &ext );
d1152 1
a1152 3
	if( intern.idb_type > ID_NULL && intern.idb_ptr )
		rt_functab[id].ft_ifree( &intern );
	db_free_external( &ext );
@


11.93
log
@
Modified calling sequence to leaf node callback for db_recurse()
and db_walk_tree().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.92 2000/06/02 00:42:55 mike Exp $ (BRL)";
d236 1
@


11.92
log
@
Added -r flag to e / draw command.
Draws all objects in red.
Useful for examining objects colored red.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.91 2000/05/26 16:09:51 bparker Exp $ (BRL)";
d224 1
a224 1
HIDDEN union tree *mged_wireframe_leaf( tsp, pathp, ep, id, client_data )
d227 1
a227 2
struct bu_external	*ep;
int			id;
a229 1
	struct rt_db_internal	intern;
d242 2
a243 1
	  Tcl_AppendResult(interp, "mged_wireframe_leaf(", rt_functab[id].ft_name,
d253 2
a254 13
    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, ep, tsp->ts_mat, dbip ) < 0 )  {
	  Tcl_AppendResult(interp, DB_FULL_PATH_CUR_DIR(pathp)->d_namep,
			   ":  solid import failure\n", (char *)NULL);

	  if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
	  return(TREE_NULL);		/* ERROR */
	}
	RT_CK_DB_INTERNAL( &intern );

	if( rt_functab[id].ft_plot(
	    &vhead,
	    &intern,
a257 1
	  rt_functab[id].ft_ifree( &intern );
d267 1
a267 1
	if (intern.idb_type == ID_GRIP) {
a281 1
	rt_functab[id].ft_ifree( &intern );
@


11.92.2.1
log
@facetize command now makes BOT's by default (added "-n" option for NMG's)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.92 2000/06/02 00:42:55 mike Exp $ (BRL)";
a1436 1
	int			make_bot = 0;
a1465 1
	make_bot = 1;
d1467 1
a1467 1
	while( (c=bu_getopt(argc,argv,"ntTP:")) != EOF )  {
a1477 3
		case 'n':
			make_bot = 0;
			break;
d1585 1
a1585 1
	if( triangulate && !make_bot )
d1603 1
a1603 10
	if( make_bot ) {
		struct rt_bot_internal *bot;
		struct nmgregion *r;
		struct shell *s;

		r = BU_LIST_FIRST( nmgregion, &mged_nmg_model->r_hd );
		s = BU_LIST_FIRST( shell, &r->s_hd );
		bot = (struct rt_bot_internal *)nmg_bot( s, &mged_tol );
		nmg_km( mged_nmg_model );
		mged_nmg_model = (struct model *)NULL;
d1605 6
a1610 17
		/* Export BOT as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_type = ID_BOT;
		intern.idb_meth = &rt_functab[ID_BOT];
		intern.idb_ptr = (genptr_t) bot;
	}
	else {

		Tcl_AppendResult(interp, "facetize:  converting NMG to database format\n", (char *)NULL);

		/* Export NMG as a new solid */
		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_type = ID_NMG;
		intern.idb_meth = &rt_functab[ID_NMG];
		intern.idb_ptr = (genptr_t)mged_nmg_model;
		mged_nmg_model = (struct model *)NULL;
	}
@


11.91
log
@*- forgot to do this last time
(i.e. the dpp argument to eraseobj and eraseobjall
needs to be a NULL terminated array)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.90 2000/05/26 14:00:42 bparker Exp $ (BRL)";
d617 1
a617 1
	while( (c=bu_getopt(argc,argv,"dfnqstuvwSTP:C:")) != EOF )  {
d677 8
@


11.90
log
@*- mods that reflect parameter changes to
   eraseobj and eraseobjall
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.89 2000/01/14 22:59:22 bparker Exp $ (BRL)";
d1299 3
a1301 2
	struct directory		*dp;
	register struct solid		*sp;
d1315 2
a1316 1
	  eraseobjall(&dp);
@


11.89
log
@*- initialize sp->s_vlist before appending list
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.88 2000/01/04 17:58:21 bparker Exp $ (BRL)";
d1299 1
a1299 1
	register struct directory	*dp;
d1314 1
a1314 1
	  eraseobjall(dp);
@


11.88
log
@*- add client_data to db_walk_tree
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.87 1999/12/30 19:14:13 jra Exp $ (BRL)";
d1335 2
a1336 3
		/* For efficiency, just swipe the vlist */
		BU_LIST_APPEND_LIST( &(sp->s_vlist), vhead );
		BU_LIST_INIT(vhead);
@


11.87
log
@Eliminated some unused variables
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.86 1999/12/29 23:23:22 mike Exp $ (BRL)";
d210 1
a210 1
HIDDEN union tree *mged_wireframe_region_end( tsp, pathp, curtree )
d214 1
d224 1
a224 1
HIDDEN union tree *mged_wireframe_leaf( tsp, pathp, ep, id )
d229 1
d324 1
a324 1
mged_nmg_region_start( tsp, pathp, combp )
d328 1
d451 1
a451 1
HIDDEN union tree *mged_nmg_region_end( tsp, pathp, curtree )
d455 1
d737 1
a737 1
			mged_wireframe_leaf );
d746 1
a746 1
			mged_bigE_leaf );
d774 2
a775 1
				nmg_booltree_leaf_tess
d1372 1
a1372 1
HIDDEN union tree *mged_facetize_region_end( tsp, pathp, curtree )
d1376 1
d1526 2
a1527 1
			nmg_booltree_leaf_tess
d1743 2
a1744 1
			nmg_booltree_leaf_tess );
@


11.86
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.85 1999/11/26 23:03:32 mike Exp $ (BRL)";
a652 1
				char		buf[128];
a871 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
a996 2
	register int	j;

a1024 1
	int			ret;
d1034 1
a1034 1
	ret = db_follow_path( &ts, &null_path, &path, LOOKUP_NOISY, depth+1 );
a1248 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
a1295 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
a1936 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
@


11.85
log
@
Lint
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.84 1999/11/24 14:26:41 jra Exp $ (BRL)";
d1322 1
a1322 1
	dp = db_diradd( dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID );
d1606 1
a1606 1
	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID)) == DIR_NULL )
d1883 1
a1883 1
	if( (dp=db_diradd( dbip, newname, -1L, 0, DIR_SOLID)) == DIR_NULL )
@


11.84
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.83 1999/11/08 16:48:40 bparker Exp $ (BRL)";
d1089 1
a1089 1
		if( rt_db_get_internal( &intern, parentp, dbip, (mat_t *)NULL ) < 0 )
@


11.83
log
@*- modified cvt_vlblock_to_solids to not skip black
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.82 1999/11/08 15:20:19 jra Exp $ (BRL)";
d1602 1
d1879 1
@


11.82
log
@
Removed superflous Tcl_AppendResult from cvt_vlblock_to_solids().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.81 1999/09/01 18:55:09 bparker Exp $ (BRL)";
d1275 1
d1277 1
@


11.81
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.80 1999/07/07 15:37:39 bparker Exp $ (BRL)";
a1280 1
		Tcl_AppendResult( interp, namebuf, " ", (char *)NULL);
@


11.80
log
@*- at the moment bn_vlblock_free and bn_vlist_copy don't
   exist; resort to using old names
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.79 1999/07/02 22:18:38 mike Exp $ (BRL)";
d1432 1
a1432 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d1649 1
a1649 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1947 1
a1947 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.79
log
@
Removed dependence on compat4.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.78 1999/06/01 15:21:17 jra Exp $ (BRL)";
d776 1
a776 1
	  		bn_vlblock_free(mged_draw_edge_uses_vbp);
d1337 1
a1337 1
		bn_vlist_copy( &(sp->s_vlist), vhead );
@


11.78
log
@mged_nmg_region_start() now ignores NULL trees
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.77 1999/05/15 08:04:26 mike Exp $ (BRL)";
d162 1
a162 1
struct rt_vlblock	*vbp;
d307 1
a307 1
static struct rt_vlblock	*mged_draw_edge_uses_vbp;
d394 1
a394 1
						RT_VLIST_LINE_MOVE );
d397 1
a397 1
							RT_VLIST_LINE_DRAW );
d412 1
a412 1
						RT_VLIST_POLY_START );
d415 1
a415 1
						RT_VLIST_POLY_MOVE );
d418 1
a418 1
							RT_VLIST_POLY_DRAW );
d421 1
a421 1
						RT_VLIST_POLY_END );
d776 2
a777 2
	  		rt_vlblock_free(mged_draw_edge_uses_vbp);
			mged_draw_edge_uses_vbp = (struct rt_vlblock *)NULL;
d796 1
a796 1
 * XXX Should split out a separate rt_vlist_rpp() routine, for librt/vlist.c
d802 1
a802 1
	register struct rt_vlist	*vp;
d809 1
a809 1
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d816 2
a817 2
			case RT_VLIST_POLY_START:
			case RT_VLIST_POLY_VERTNORM:
d820 5
a824 5
			case RT_VLIST_LINE_MOVE:
			case RT_VLIST_LINE_DRAW:
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
d1063 1
a1063 1
	mat_copy( matp, ts.ts_mat );	/* implicit return */
d1247 1
a1247 1
struct rt_vlblock	*vbp;
d1337 1
a1337 1
		rt_vlist_copy( &(sp->s_vlist), vhead );
@


11.77
log
@Allow change of units even if database is read-only.
Have "center" command echo back current setting, so it can be used
in Tcl scripts.  Have "center" command without args print current center
in current units, also for use in Tcl scripts.
Have "overlay" command echo back list of phantom-solids created,
for use in Tcl scripts.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.76 1999/05/11 15:07:30 mike Exp $ (BRL)";
d346 2
@


11.76
log
@Placed polygon fastpath code on -f flag to ev command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.75 1999/05/10 22:01:38 mike Exp $ (BRL)";
d1259 12
a1270 5
	av[0] = "kill";
	av[1] = "-f";
	av[2] = shortname;
	av[3] = NULL;
	(void)f_kill((ClientData)NULL, interp, 3, av);
d1279 1
@


11.75
log
@Added mged_nmg_region_start().
A hack to view polygonal models (converted from FASTGEN) more rapidly.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.74 1999/01/21 18:31:21 bparker Exp $ (BRL)";
d305 2
d381 1
a381 1
				bu_log("fast-path draw ID_POLY\n", dp->d_namep);
d432 1
a432 1
	/* Successful fast-path drawing of this solid */
d437 1
d583 1
a583 1
	int		i;
d606 2
d611 1
a611 1
	while( (c=bu_getopt(argc,argv,"dnqstuvwSTP:C:")) != EOF )  {
d646 3
d685 1
a685 1
		  Tcl_AppendResult(interp, "Usage: ev [-dnqstuvwST] [-P ncpu] object(s)\n\
d687 1
d727 1
a727 1
		i = db_walk_tree( dbip, argc, (CONST char **)argv,
a732 1
		if( i < 0 )  return(-1);
d736 1
a736 1
		i = db_walk_tree( dbip, argc, argv,
a741 1
		if( i < 0 )  return(-1);
d762 1
a762 1
		i = db_walk_tree( dbip, argc, (CONST char **)argv,
d765 1
a765 1
			mged_nmg_region_start,
a779 2

		if( i < 0 )  return(-1);
d783 5
@


11.74
log
@*- use helpdevel for help on developer commands
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.73 1999/01/12 18:17:05 bparker Exp $ (BRL)";
d37 1
d71 1
a71 1
		0,			/* override */
d308 131
d758 1
a758 1
			0,			/* take all regions */
d868 1
a868 1
		  Tcl_AppendResult(interp, "dodraw: path too long, solid ignored.\n\t",
d875 1
d902 1
d909 4
a912 6
			  if (!tsp->ts_mater.ma_override)
			    sp->s_dflag = 1;
			  else {
			    sp->s_basecolor[0] = tsp->ts_mater.ma_color[0] * 255.;
			    sp->s_basecolor[1] = tsp->ts_mater.ma_color[1] * 255.;
			    sp->s_basecolor[2] = tsp->ts_mater.ma_color[2] * 255.;
d914 4
d920 1
@


11.73
log
@*- some cleanup
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.72 1998/12/17 04:19:11 mike Exp $ (BRL)";
d1797 6
a1802 1
		Tcl_AppendResult(interp, "Usage: rtdraw_vlist object(s)\n", NULL);
@


11.72
log
@Regions now have an associated temperature
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.71 1998/11/06 22:32:39 bparker Exp $ (BRL)";
d797 1
a797 12
#ifdef DO_SINGLE_DISPLAY_LIST
	/* do nothing here */
#else
	save_dmlp = curr_dm_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
	    curr_dm_list = dmlp;
	    createDList(sp);
	  }
	}
	curr_dm_list = save_dmlp;
#endif
a1125 11

#ifdef DO_SINGLE_DISPLAY_LIST
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
	    save_dmlp = curr_dm_list;
	    curr_dm_list = dmlp;
	    createDList(&HeadSolid);
	    curr_dm_list = save_dmlp;
	  }
	}
#endif
d1206 1
a1206 12
#ifdef DO_SINGLE_DISPLAY_LIST
	/* do nothing here */
#else
	save_dmlp = curr_dm_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
	    curr_dm_list = dmlp;
	    createDList(sp);
	  }
	}
	curr_dm_list = save_dmlp;
#endif
a1821 10
#ifdef DO_SINGLE_DISPLAY_LIST
	save_dmlp = curr_dm_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
	  if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
	    curr_dm_list = dmlp;
	    createDList(&HeadSolid);
	  }
	}
	curr_dm_list = save_dmlp;
#endif
@


11.71
log
@*- use new structures
*- cleanup
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.70 1998/10/21 16:49:31 bparker Exp $ (BRL)";
d69 1
@


11.70
log
@*- set a few flags that help to determine what
	color the object is finally drawn in.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.69 1998/09/14 15:59:19 bparker Exp $ (BRL)";
d801 1
a801 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
d1099 1
a1099 1
	dmaflag = 1;
d1139 1
a1139 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
d1232 1
a1232 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
d1857 1
a1857 1
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
@


11.69
log
@*- fix typos
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.68 1998/06/25 13:31:55 bparker Exp $ (BRL)";
a49 1
float default_wireframe_color[] = { 1.0, 0.0, 0.0 };  /* start with red */
d51 2
d570 1
d573 1
d767 1
a767 1
			sp->s_useBaseColor = 1;
d772 9
a780 5
			sp->s_useBaseColor = 0;
			if( tsp )  {
				sp->s_basecolor[0] = tsp->ts_mater.ma_color[0] * 255.;
				sp->s_basecolor[1] = tsp->ts_mater.ma_color[1] * 255.;
				sp->s_basecolor[2] = tsp->ts_mater.ma_color[2] * 255.;
d905 1
d915 1
a915 1
	if(!sp->s_useBaseColor){
d922 2
@


11.68
log
@*- modified pathHmat()'s reassignment of color
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.67 1998/06/24 18:34:45 bparker Exp $ (BRL)";
d1122 1
a1122 1
		sprintf( namebuf, "%s%x",
@


11.67
log
@*- added comments
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.66 1998/06/24 17:57:25 bparker Exp $ (BRL)";
d902 1
d906 8
@


11.66
log
@*- mods to allow user to specify a color when e'ing something
*- support user specified default wireframe color
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dodraw.c,v 11.65 1998/05/15 14:47:25 bparker Exp $ (BRL)";
d763 1
@


11.65
log
@checkin for pjt/jra demo
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/dodraw.c,v 11.64 1998/05/13 13:08:34 jra Exp $ (BRL)";
d50 1
d89 2
d458 1
a458 1
	/* Initial vaues for options, must be reset each time */
d468 1
d472 1
a472 1
	while( (c=bu_getopt(argc,argv,"dnqstuvwSTP:")) != EOF )  {
d507 24
d532 2
a533 2
		  {
		    struct bu_vls tmp_vls;
d535 4
a538 5
		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }
d540 3
d553 2
a554 1
		break;
d569 3
d762 12
a773 4
		if( tsp )  {
			sp->s_basecolor[0] = tsp->ts_mater.ma_color[0] * 255.;
			sp->s_basecolor[1] = tsp->ts_mater.ma_color[1] * 255.;
			sp->s_basecolor[2] = tsp->ts_mater.ma_color[2] * 255.;
@


11.64
log
@ifdef'd out add_solid_path_to_result() in cmd_redraw_vlist(). It was producing enormous
result strings.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.63 1998/03/19 17:50:03 bparker Exp jra $ (BRL)";
d1803 1
@


11.63
log
@*- add dbip parameter to ft_import()
*- mods to cvt_vlblock_to_solids() to always append color to fake solid name
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.62 1997/12/23 10:05:52 mike Exp bparker $ (BRL)";
d1782 1
d1784 1
@


11.62
log
@Allow redraw_vlist to change the color of the object on the screen.
Need to set both sets of color info.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.61 1997/12/23 09:21:20 mike Exp mike $ (BRL)";
d247 1
a247 1
	if( rt_functab[id].ft_import( &intern, ep, tsp->ts_mat ) < 0 )  {
d959 1
a959 1
	if( rt_functab[id].ft_import( &intern, &ext, mat ) < 0 )  {
d1069 1
a1069 4
		if( i== 0 )  {
			invent_solid( name, &vbp->head[0], vbp->rgb[0], copy );
			continue;
		}
@


11.61
log
@Upgraded pathHmat() to be also update color, using the "standard" treewalker.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.60 1997/12/18 06:29:14 mike Exp mike $ (BRL)";
d859 3
a861 3
	sp->s_basecolor[0] = ts.ts_mater.ma_color[0] * 255.;
	sp->s_basecolor[1] = ts.ts_mater.ma_color[1] * 255.;
	sp->s_basecolor[2] = ts.ts_mater.ma_color[2] * 255.;
@


11.60
log
@tl_mat being null signifies an identity matrix.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.59 1997/12/16 14:34:41 pjt Exp mike $ (BRL)";
d763 1
a763 1
		bu_semaphore_acquire( (unsigned int)(RT_SEM_MODEL - BU_SEM_SYSCALL) );
d765 1
a765 1
		bu_semaphore_release( (unsigned int)(RT_SEM_MODEL - BU_SEM_SYSCALL) );
d802 22
a827 1
 *  Be sure to omit s_path[sp->s_last] -- it's a solid.
d829 3
a831 1
 *  XXX Change to using db_path_to_mat().
d838 29
d913 1
a945 1
	/* XXX This should really be db_follow_path_for_state() */
d1211 1
a1211 1
	bu_semaphore_acquire( (unsigned int)(RT_SEM_MODEL - BU_SEM_SYSCALL) );
d1224 1
a1224 1
	bu_semaphore_release( (unsigned int)(RT_SEM_MODEL - BU_SEM_SYSCALL) );
@


11.59
log
@Reran ed script ../h/sed4 to adjust for Mike's changes
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.58 1997/11/19 21:48:18 bparker Exp pjt $ (BRL)";
d795 4
a798 1
	bn_mat_copy( xmat, comb_leaf->tr_l.tl_mat );
@


11.58
log
@mods to invent_solid()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.57 1997/09/08 18:21:17 bparker Exp bparker $ (BRL)";
d332 1
a332 1
		if( RT_SETJUMP )
d336 1
a336 1
			RT_UNSETJUMP;
d346 1
a346 1
		RT_UNSETJUMP;
d367 1
a367 1
		if( RT_SETJUMP )
d371 1
a371 1
			RT_UNSETJUMP;
d381 1
a381 1
		RT_UNSETJUMP;
d763 1
a763 1
		bu_semaphore_acquire( (unsigned int)(&rt_g.res_model - &rt_g.res_syscall) );
d765 1
a765 1
		bu_semaphore_release( (unsigned int)(&rt_g.res_model - &rt_g.res_syscall) );
d1156 1
a1156 1
	bu_semaphore_acquire( (unsigned int)(&rt_g.res_model - &rt_g.res_syscall) );
d1169 1
a1169 1
	bu_semaphore_release( (unsigned int)(&rt_g.res_model - &rt_g.res_syscall) );
d1307 1
a1307 1
		if( RT_SETJUMP )
d1309 1
a1309 1
			RT_UNSETJUMP;
d1320 1
a1320 1
		RT_UNSETJUMP;
d1343 1
a1343 1
		if( RT_SETJUMP )
d1345 1
a1345 1
			RT_UNSETJUMP;
d1355 1
a1355 1
		RT_UNSETJUMP;
d1583 1
a1583 1
		if( RT_SETJUMP )
d1585 1
a1585 1
			RT_UNSETJUMP;
d1597 1
a1597 1
		RT_UNSETJUMP;
d1621 1
a1621 1
		if( RT_SETJUMP )
d1623 1
a1623 1
			RT_UNSETJUMP;
d1633 1
a1633 1
		RT_UNSETJUMP;
@


11.57
log
@use new macro FOR_ALL_DISPLAYS
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.56 1997/09/03 14:19:02 bparker Exp bparker $ (BRL)";
d1107 1
@


11.56
log
@mods to implement new display lists
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.55 1997/08/22 22:38:22 mike Exp bparker $ (BRL)";
d750 2
a751 2
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
d1024 2
a1025 2
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
a1072 1

d1116 2
a1117 2
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
d1739 2
a1740 2
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
@


11.55
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.54 1997/08/22 22:31:08 mike Exp mike $ (BRL)";
d691 2
d705 2
d745 15
d999 2
d1022 11
d1053 2
d1111 15
d1708 2
d1737 12
@


11.54
log
@BParker mods to eliminate MGED displaylist support
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.53 1997/07/22 13:44:05 jra Exp bparker $ (BRL)";
d467 2
a468 2
	optind = 1;		/* re-init getopt() */
	while( (c=getopt(argc,argv,"dnqstuvwSTP:")) != EOF )  {
d495 1
a495 1
			ncpu = atoi(optarg);
d526 2
a527 2
	argc -= optind;
	argv += optind;
d1173 2
a1174 2
	optind = 1;		/* re-init getopt() */
	while( (c=getopt(argc,argv,"tTP:")) != EOF )  {
d1177 1
a1177 1
			ncpu = atoi(optarg);
d1200 2
a1201 2
	argc -= optind;
	argv += optind;
d1393 2
a1394 2
	optind = 1;		/* re-init getopt() */
	while( (c=getopt(argc,argv,"tP:")) != EOF )  {
d1397 1
a1397 1
			ncpu = atoi(optarg);
d1415 2
a1416 2
	argc -= optind;
	argv += optind;
@


11.53
log
@Surrounded NMG Boolean evaluation with RT_SETJUMP protection.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.52 1997/07/01 22:09:08 bparker Exp jra $ (BRL)";
a43 2
extern void color_soltab();

a48 1
int	no_memory;	/* flag indicating memory for drawing is used up */
a739 2
	sp->s_addr = 0;
	sp->s_bytes = 0;
a740 13
	/* Cvt to displaylist, determine displaylist memory requirement. */
	if( !no_memory && (sp->s_bytes = dmp->dm_cvtvecs( dmp, sp )) != 0 )  {
		/* Allocate displaylist storage for object */
		sp->s_addr = rt_memalloc( &(dmp->dm_map), sp->s_bytes );
		if( sp->s_addr == 0 )  {
		  no_memory = 1;
		  Tcl_AppendResult(interp, "draw: out of Displaylist\n" ,(char *)NULL);
		  sp->s_bytes = 0;	/* not drawn */
		} else {
		  sp->s_bytes = dmp->dm_load(dmp, sp->s_addr, sp->s_bytes );
		}
	}

a746 3
#if 0
		dmp->dm_viewchange( dmp, DM_CHGV_ADD, sp );
#endif
a749 3
#if 0
		dmp->dm_viewchange( dmp, DM_CHGV_REPL, sp );
#endif
a922 1
	unsigned		addr, bytes;
a934 4
	/* Remember displaylist location of previous solid */
	addr = sp->s_addr;
	bytes = sp->s_bytes;

d957 1
d961 2
a1073 2
	sp->s_addr = 0;
	sp->s_bytes = 0;
a1074 13
	/* Cvt to displaylist, determine displaylist memory requirement. */
	if( !no_memory && (sp->s_bytes = dmp->dm_cvtvecs( dmp, sp )) != 0 )  {
		/* Allocate displaylist storage for object */
		sp->s_addr = rt_memalloc( &(dmp->dm_map), sp->s_bytes );
		if( sp->s_addr == 0 )  {
		  no_memory = 1;
		  Tcl_AppendResult(interp, "invent_solid: out of Displaylist\n", (char *)NULL);
		  sp->s_bytes = 0;	/* not drawn */
		} else {
		  sp->s_bytes = dmp->dm_load(dmp, sp->s_addr, sp->s_bytes );
		}
	}

a1076 7
#if 0
	dmp->dm_viewchange( dmp, DM_CHGV_ADD, sp );
#endif
	color_soltab();
#if 0
	dmp->dm_colorchange(dmp);
#endif
@


11.52
log
@mods to run without a database
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.51 1997/06/25 02:33:20 mike Exp bparker $ (BRL)";
d334 14
a347 1
	if ( ! mged_draw_nmg_only ) {
d349 1
d370 13
d384 1
d576 1
d580 1
a1206 4
	Tcl_AppendResult(interp, "Please note that the NMG library used by ",
			 "this command is experimental.\n", "A production implementation ",
			 "will exist in the maintenance release.\n", (char *)NULL);

d1306 12
d1319 1
d1341 14
a1354 2
	  Tcl_AppendResult(interp, "facetize:  triangulating resulting object\n", (char *)NULL);
	  nmg_triangulate_model( mged_nmg_model , &mged_tol );
a1426 4
	Tcl_AppendResult(interp, "Please note that the NMG library used by this command",
			 "is experimental.\n A production implementation will exist",
			 "in the maintenance release.\n", (char *)NULL);

d1582 13
d1596 1
d1619 14
a1632 2
	  Tcl_AppendResult(interp, "bev:  triangulating resulting object\n", (char *)NULL);
	  nmg_triangulate_model( mged_nmg_model , &mged_tol );
@


11.51
log
@cmd_redraw_vlist
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.50 1997/04/24 18:03:58 bparker Exp mike $ (BRL)";
d423 3
d795 3
d856 3
d1018 3
d1162 3
d1359 3
d1634 3
@


11.50
log
@modify calls to Tcl_Eval
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.49 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d856 1
d1580 61
@


11.49
log
@mods so that commands check args internally
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.48 1997/04/14 12:28:27 bparker Exp bparker $ (BRL)";
d1150 6
a1155 1
	  Tcl_Eval(interp, "help facetize");
d1346 6
a1351 1
	  Tcl_Eval(interp, "help bev");
@


11.48
log
@now calling eraseobjall()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.47 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d1149 2
a1150 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1152 1
d1340 2
a1341 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1343 1
@


11.47
log
@Mods to support MGED's read-only mode.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.46 1997/03/12 20:45:46 jra Exp jra $ (BRL)";
d1017 1
a1017 1
	  eraseobj(dp);
@


11.46
log
@removed dependencies on db.h.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.45 1997/02/25 14:42:00 jra Exp jra $ (BRL)";
d1335 2
@


11.45
log
@Completed conversion to combination import/export.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.44 1997/02/14 13:38:08 jra Exp jra $ (BRL)";
a34 1
#include "db.h"
d71 2
a72 2
		DB_INH_LOWER,		/* color inherit */
		DB_INH_LOWER,		/* mater inherit */
@


11.44
log
@converted pathHmat() to use combination import/export.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.43 1997/01/29 05:23:53 mike Exp jra $ (BRL)";
a784 1
	register union record	*rp;
a1144 1
	struct bu_external	ext;
a1146 1
	int			ngran;
d1292 4
a1295 17
	BU_INIT_EXTERNAL( &ext );

	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[ID_NMG].ft_export( &ext, &intern, 1.0 ) < 0 )  {
	  Tcl_AppendResult(interp, "facetize(", newname, "):  solid export failure\n",
			   (char *)NULL);
	  if( intern.idb_ptr )  rt_functab[ID_NMG].ft_ifree( &intern );
	  db_free_external( &ext );
	  return TCL_ERROR;				/* FAIL */
	}
	rt_functab[ID_NMG].ft_ifree( &intern );
	mged_facetize_tree->tr_d.td_r = (struct nmgregion *)NULL;

	ngran = (ext.ext_nbytes + sizeof(union record)-1)/sizeof(union record);
	if( (dp=db_diradd( dbip, newname, -1, ngran, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, ngran ) < 0 )  {
	    	TCL_ALLOC_ERR_return;
d1298 3
a1300 2
	if( db_put_external( &ext, dp, dbip ) < 0 )  {
		db_free_external( &ext );
d1303 2
a1304 12

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "facetize:  wrote %.2f Kbytes to database\n",
			ext.ext_nbytes / 1024.0 );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	db_free_external( &ext );
a1330 1
	struct bu_external	ext;
a1334 1
	int			ngran;
d1536 4
a1539 8
	BU_INIT_EXTERNAL( &ext );

	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[ID_NMG].ft_export( &ext, &intern, 1.0 ) < 0 )  {
	  Tcl_AppendResult(interp, "bev(", newname, "):  solid export failure\n", (char *)NULL);
	  if( intern.idb_ptr )  rt_functab[ID_NMG].ft_ifree( &intern );
	  db_free_external( &ext );
	  return TCL_ERROR;
a1540 2
	rt_functab[ID_NMG].ft_ifree( &intern );
	tmp_tree->tr_d.td_r = (struct nmgregion *)NULL;
d1542 3
a1544 8
	ngran = (ext.ext_nbytes + sizeof(union record)-1)/sizeof(union record);
	if( (dp=db_diradd( dbip, newname, -1, ngran, DIR_SOLID)) == DIR_NULL ||
	    db_alloc( dbip, dp, ngran ) < 0 )  {
	  TCL_ALLOC_ERR_return;
	}

	if( db_put_external( &ext, dp, dbip ) < 0 )  {
		db_free_external( &ext );
d1548 1
a1548 11
	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "bev:  wrote %.2f Kbytes to database\n",
			ext.ext_nbytes / 1024.0 );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	db_free_external( &ext );
@


11.43
log
@Added comment.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.42 1997/01/17 22:56:57 bparker Exp mike $ (BRL)";
d745 26
d789 2
d803 6
a808 3
		if( (rp = db_getmrec( dbip, parentp )) == (union record *)0 )
			return;		/* ERROR */
		for( j=1; j < parentp->d_len; j++ )  {
d810 1
d812 16
a827 15
			/* Examine Member records */
			if( strcmp( kidp->d_namep, rp[j].M.m_instname ) != 0 )
				continue;

			/* convert matrix to fastf_t from disk format */
			rt_mat_dbmat( xmat, rp[j].M.m_mat );
			bn_mat_mul( tmat, matp, xmat );
			bn_mat_copy( matp, tmat );
			goto next_level;
		}
		Tcl_AppendResult(interp, "pathHmat: unable to follow ", parentp->d_namep,
				 "/", kidp->d_namep, "\n", (char *)NULL);
		return;			/* ERROR */
next_level:
		bu_free( (genptr_t)rp, "pathHmat recs");
@


11.42
log
@checkin for weekend
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.41 1997/01/08 17:03:48 jra Exp bparker $ (BRL)";
d751 2
@


11.41
log
@Fixed initialization of mged_initial_tree_state.ts_mater.ma_shader was "" needed to be (char *)NULL.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.40 1997/01/02 22:12:41 bparker Exp jra $ (BRL)";
a51 1
extern double       frametime;
@


11.40
log
@.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.39 1997/01/02 19:32:57 bparker Exp bparker $ (BRL)";
d75 1
a75 1
		""			/* shader */
@


11.39
log
@mods to use libbn and libbu
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.38 1996/12/30 20:16:47 jra Exp bparker $ (BRL)";
d731 1
a731 1
		bu_semaphore_acquire( &rt_g.res_model );
d733 1
a733 1
		bu_semaphore_release( &rt_g.res_model );
d1080 1
a1080 1
	bu_semaphore_acquire( &rt_g.res_model );
d1093 1
a1093 1
	bu_semaphore_release( &rt_g.res_model );
@


11.38
log
@invent_solid() was deleting existing "phony" directory entries, then not creating a new one.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.37 1996/12/04 03:27:56 mike Exp jra $ (BRL)";
d34 1
d96 1
a96 1
extern struct rt_tol		mged_tol;	/* from ged.c */
d225 1
a225 1
struct rt_external	*ep;
d234 1
a234 1
	RT_CK_TOL(tsp->ts_tol);
d321 1
a321 1
	RT_CK_TOL(tsp->ts_tol);
d731 1
a731 1
		RES_ACQUIRE( &rt_g.res_model );
d733 1
a733 1
		RES_RELEASE( &rt_g.res_model );
d765 1
a765 1
	mat_idn( matp );
d785 2
a786 2
			mat_mul( tmat, matp, xmat );
			mat_copy( matp, tmat );
d812 1
a812 1
	struct rt_external	ext;
d826 1
a826 1
	RT_INIT_EXTERNAL( &ext );
d845 1
a845 1
	if( replot_modified_solid( sp, &intern, rt_identity ) < 0 )  {
d1080 1
a1080 1
	RES_ACQUIRE( &rt_g.res_model );
d1093 1
a1093 1
	RES_RELEASE( &rt_g.res_model );
d1112 1
a1112 1
	struct rt_external	ext;
d1261 1
a1261 1
	RT_INIT_EXTERNAL( &ext );
d1322 1
a1322 1
	struct rt_external	ext;
d1529 1
a1529 1
	RT_INIT_EXTERNAL( &ext );
@


11.37
log
@Changed to ma_shader
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.36 1996/10/22 21:10:18 bparker Exp mike $ (BRL)";
a984 3
	} else {
	  /* Need to enter phony name in directory structure */
	  dp = db_diradd( dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID );
d986 3
@


11.36
log
@hacks to use latest libdm
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.35 1996/10/18 13:53:51 bparker Exp $ (BRL)";
d74 1
a74 2
		"",			/* material name */
		""			/* material params */
@


11.35
log
@call color_soltab before calling dmr_colorchange
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.34 1996/10/04 15:02:32 bparker Exp bparker $ (BRL)";
d716 1
a716 1
	if( !no_memory && (sp->s_bytes = dmp->dmr_cvtvecs( dmp, sp )) != 0 )  {
d718 1
a718 1
		sp->s_addr = rt_memalloc( &(dmp->dmr_map), sp->s_bytes );
d724 1
a724 1
		  sp->s_bytes = dmp->dmr_load(dmp, sp->s_addr, sp->s_bytes );
d734 3
a736 1
		dmp->dmr_viewchange( dmp, DM_CHGV_ADD, sp );
d740 3
a742 1
		dmp->dmr_viewchange( dmp, DM_CHGV_REPL, sp );
d916 1
a916 1
		rt_memfree( &(dmp->dmr_map), bytes, (unsigned long)addr );
d1029 1
a1029 1
	if( !no_memory && (sp->s_bytes = dmp->dmr_cvtvecs( dmp, sp )) != 0 )  {
d1031 1
a1031 1
		sp->s_addr = rt_memalloc( &(dmp->dmr_map), sp->s_bytes );
d1037 1
a1037 1
		  sp->s_bytes = dmp->dmr_load(dmp, sp->s_addr, sp->s_bytes );
d1043 3
a1045 1
	dmp->dmr_viewchange( dmp, DM_CHGV_ADD, sp );
d1047 3
a1049 1
	dmp->dmr_colorchange(dmp);
@


11.34
log
@cast bu_free's 1st argument to genptr_t
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.33 1996/10/03 20:23:10 bparker Exp bparker $ (BRL)";
d1040 1
@


11.33
log
@get rid of extra cmdline() uses
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.32 1996/09/25 20:16:42 bparker Exp bparker $ (BRL)";
d243 1
a243 1
	  bu_free(sofar, "path string");
d331 1
a331 1
	  bu_free(sofar, "path string");
d789 1
a789 1
		bu_free( (char *)rp, "pathHmat recs");
d1066 1
a1066 1
	  bu_free(sofar, "path string");
@


11.32
log
@now using more generalized solid macros
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.31 1996/09/23 18:31:03 bparker Exp bparker $ (BRL)";
d112 1
a112 1
	struct bu_vls	str;
d115 4
a118 2
	bu_vls_init( &str );
	bu_vls_printf( &str, "overlay %s\n", file );
a119 4
	(void)cmdline( &str, FALSE );

	bu_vls_free( &str );

d929 1
a929 1
	struct bu_vls	str;
d934 5
a938 6
	bu_vls_init(&str);
	bu_vls_printf( &str, "kill -f %s*\n", shortname );

	(void)cmdline( &str, FALSE );

	bu_vls_free(&str);
@


11.31
log
@ use LIBDM permanently
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.30 1996/09/17 21:20:57 bparker Exp bparker $ (BRL)";
d39 1
a39 1
#include "./solid.h"
d672 1
a672 1
		  bu_free(cp, "Path string");
d676 1
a676 1
		GET_SOLID( sp );
d734 1
a734 1
		APPEND_SOLID( sp, HeadSolid.s_back );
d1000 1
a1000 1
	GET_SOLID(sp);
d1041 1
a1041 1
	APPEND_SOLID( sp, HeadSolid.s_back );
@


11.30
log
@prepare to use libdm
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.29 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d40 1
a40 1
#include "./dm.h"
a43 1
#ifdef USE_LIBDM
a44 1
#endif
a717 1
#ifdef USE_LIBDM
a718 3
#else
	if( !no_memory && (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
#endif
a725 1
#ifdef USE_LIBDM
a726 3
#else
		  sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes );
#endif
a735 1
#ifdef USE_LIBDM
a736 3
#else
		dmp->dmr_viewchange( DM_CHGV_ADD, sp );
#endif
a739 1
#ifdef USE_LIBDM
a740 3
#else
		dmp->dmr_viewchange( DM_CHGV_REPL, sp );
#endif
a1027 1
#ifdef USE_LIBDM
a1028 3
#else
	if( !no_memory && (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {
#endif
a1035 1
#ifdef USE_LIBDM
a1036 3
#else
		  sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes );
#endif
a1041 1
#ifdef USE_LIBDM
a1043 4
#else
	dmp->dmr_viewchange( DM_CHGV_ADD, sp );
	dmp->dmr_colorchange();
#endif
@


11.29
log
@rt_list ---> bu_list
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.28 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d44 4
d720 3
d724 1
d732 3
d736 1
d746 3
d750 1
d754 3
d758 1
d1046 3
d1050 1
d1058 3
d1062 1
d1068 4
d1074 1
@


11.28
log
@now using libbu
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.27 1996/08/21 13:52:38 jra Exp bparker $ (BRL)";
d32 1
d231 1
a231 1
	struct rt_list	vhead;
d236 1
a236 1
	RT_LIST_INIT( &vhead );
d317 1
a317 1
	struct rt_list		vhead;
d324 1
a324 1
	RT_LIST_INIT( &vhead );
d599 1
a599 1
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d656 1
a656 1
struct rt_list		*vhead;
d686 1
a686 1
	RT_LIST_APPEND_LIST( &(sp->s_vlist), vhead );
d872 1
a872 1
	struct rt_list		vhead;
d874 1
a874 1
	RT_LIST_INIT( &vhead );
d943 1
a943 1
		if( RT_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;
d966 1
a966 1
struct rt_list	*vhead;
d1001 1
a1001 1
		RT_LIST_INIT( &(sp->s_vlist) );
d1005 2
a1006 2
		RT_LIST_APPEND_LIST( &(sp->s_vlist), vhead );
		RT_LIST_INIT(vhead);
d1058 1
a1058 1
	struct rt_list		vhead;
d1060 1
a1060 1
	RT_LIST_INIT( &vhead );
@


11.27
log
@Minor mods for IRIX 6.2.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.26 1996/07/15 20:38:02 bparker Exp jra $ (BRL)";
d109 1
a109 1
	struct rt_vls	str;
d112 2
a113 2
	rt_vls_init( &str );
	rt_vls_printf( &str, "overlay %s\n", file );
d117 1
a117 1
	rt_vls_free( &str );
d242 1
a242 1
	  rt_free(sofar, "path string");
d294 1
a294 1
	GETUNION( curtree, tree );
d330 1
a330 1
	  rt_free(sofar, "path string");
d478 1
a478 1
		    struct rt_vls tmp_vls;
d480 4
a483 4
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		    rt_vls_free(&tmp_vls);
d623 1
a623 1
			    struct rt_vls tmp_vls;
d625 4
a628 4
			    rt_vls_init(&tmp_vls);
			    rt_vls_printf(&tmp_vls, "unknown vlist op %d\n", *cmd);
			    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			    rt_vls_free(&tmp_vls);
d669 1
a669 1
		  rt_free(cp, "Path string");
d788 1
a788 1
		rt_free( (char *)rp, "pathHmat recs");
d928 1
a928 1
	struct rt_vls	str;
d933 2
a934 2
	rt_vls_init(&str);
	rt_vls_printf( &str, "kill -f %s*\n", shortname );
d938 1
a938 1
	rt_vls_free(&str);
d1066 1
a1066 1
	  rt_free(sofar, "path string");
d1074 1
a1074 1
		tr = (union tree *)rt_calloc(1, sizeof(union tree), "union tree");
d1147 1
a1147 1
		    struct rt_vls tmp_vls;
d1149 3
a1151 3
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls),
d1155 1
a1155 1
		    rt_vls_free(&tmp_vls);
d1182 1
a1182 1
	  struct rt_vls tmp_vls;
d1184 2
a1185 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls,
d1188 2
a1189 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d1277 1
a1277 1
	  struct rt_vls tmp_vls;
d1279 2
a1280 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "facetize:  wrote %.2f Kbytes to database\n",
d1282 2
a1283 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d1355 1
a1355 1
		    struct rt_vls tmp_vls;
d1357 4
a1360 4
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		    rt_vls_free(&tmp_vls);
d1386 1
a1386 1
	  struct rt_vls tmp_vls;
d1388 2
a1389 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls,
d1392 2
a1393 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d1425 1
a1425 1
			GETUNION( new_tree, tree );
d1446 1
a1446 1
				    struct rt_vls tmp_vls;
d1448 3
a1450 3
				    rt_vls_init(&tmp_vls);
				    rt_vls_printf(&tmp_vls, "Unrecognized operator: (%c)\n" , op );
				    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls),
d1452 1
a1452 1
				    rt_vls_free(&tmp_vls);
d1544 1
a1544 1
	  struct rt_vls tmp_vls;
d1546 2
a1547 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "bev:  wrote %.2f Kbytes to database\n",
d1549 2
a1550 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
@


11.26
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.25 1996/07/03 13:37:05 jra Exp bparker $ (BRL)";
d43 1
d587 1
d919 1
@


11.25
log
@Mods to f_facetize() and f_bev() to gracefully fail when tessellator fails.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.24 1996/06/03 12:48:06 jra Exp jra $ (BRL)";
d1150 1
a1150 1
				     "\t-t Perform CSG-to-tNURBS conversion\n"
d1557 1
a1557 1
	  char *av[] = {"e", NULL, NULL};
d1559 1
d1561 1
@


11.24
log
@Fixed error in a call to Tcl_AppendResult().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.23 1996/04/24 16:20:56 bparker Exp jra $ (BRL)";
d1210 9
a1218 2
	/* Now, evaluate the boolean tree into ONE region */
	Tcl_AppendResult(interp, "facetize:  evaluating boolean expressions\n", (char *)NULL);
a1219 1
	failed = nmg_boolean( mged_facetize_tree, mged_nmg_model, &mged_tol );
d1222 2
a1223 1
	  db_free_tree( mged_facetize_tree );
d1476 10
a1485 2
	/* Now, evaluate the boolean tree into ONE region */
	Tcl_AppendResult(interp, "bev:  evaluating boolean expressions\n", (char *)NULL);
a1486 1
	failed = nmg_boolean( tmp_tree, mged_nmg_model, &mged_tol );
d1489 2
a1490 1
	  db_free_tree( tmp_tree );
@


11.23
log
@still tcl-converting
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.22 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d1234 1
a1234 1
	Tcl_AppendResult(interp, "facetize:  converting NMG to database format\n");
@


11.22
log
@convert commands to Tcl
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.21 1995/11/29 23:54:12 mike Exp bparker $ (BRL)";
a1307 1
	char			*edit_args[2];
d1540 9
a1548 4
	/* draw the new solid */
	edit_args[0] = (char *)NULL;
	edit_args[1] = newname;
	return( f_edit( clientData, interp, 2, edit_args ) );
@


11.21
log
@Added -S flag to "ev", to draw trimming curves only, not the surface.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.19 1995/11/29 02:16:04 mike Exp $ (BRL)";
d237 5
a241 4
		char	*sofar = db_path_to_string(pathp);
		rt_log("mged_wireframe_leaf(%s) path='%s'\n",
			rt_functab[id].ft_name, sofar );
		rt_free(sofar, "path string");
d251 5
a255 4
		rt_log("%s:  solid import failure\n",
			DB_FULL_PATH_CUR_DIR(pathp)->d_namep );
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
	    	return(TREE_NULL);		/* ERROR */
d263 4
a266 4
		rt_log("%s: plot failure\n",
			DB_FULL_PATH_CUR_DIR(pathp)->d_namep );
		rt_functab[id].ft_ifree( &intern );
	    	return(TREE_NULL);		/* ERROR */
d325 5
a329 4
		char	*sofar = db_path_to_string(pathp);
		rt_log("mged_nmg_region_end() path='%s'\n",
			sofar);
		rt_free(sofar, "path string");
d343 3
a345 3
		rt_log( "Cannot use '-d' option when Boolean evaluation is required\n" );
		db_free_tree( curtree );
		return (union tree *)NULL;
d476 10
a485 2
			rt_log("option '%c' unknown\n", c);
			rt_log("Usage: ev [-dnqstuvwST] [-P ncpu] object(s)\n\
d494 2
a495 2
	-T debug: disable triangulator\n");
			break;
d517 2
a518 2
		rt_log("ERROR, bad kind\n");
		return(-1);
d539 1
a539 1
		rt_log("drawtrees:  can't do big-E here\n");
d545 1
a545 1
	  	rt_log("\
d547 1
a547 1
A production implementation will exist in the maintenance release.\n");
d551 2
a552 2
	  		rt_log( "Doing the edgeuse thang (-u)\n");
	  		mged_draw_edge_uses_vbp = rt_vlblock_init();
d620 8
a627 1
				rt_log("unknown vlist op %d\n", *cmd);
d663 6
a668 5
			char *cp = db_path_to_string(pathp);
			rt_log("dodraw: path too long, solid ignored.\n\t%s\n",
			    cp);
			rt_free(cp, "Path string");
			return;
d717 3
a719 3
			no_memory = 1;
			rt_log("draw: out of Displaylist\n");
			sp->s_bytes = 0;	/* not drawn */
d721 1
a721 1
			sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes );
d763 3
a765 3
			rt_log("pathHmat:  %s is not a combination\n",
				parentp->d_namep);
			return;		/* ERROR */
d782 2
a783 2
		rt_log("pathHmat: unable to follow %s/%s path\n",
			parentp->d_namep, kidp->d_namep );
d813 3
a815 3
		rt_log("replot_original_solid(%s): Unable to plot evaluated regions, skipping\n",
			dp->d_namep );
		return(-1);
d823 4
a826 4
		rt_log("replot_original_solid() unable to identify type of solid %s\n",
			dp->d_namep );
		db_free_external( &ext );
		return(-1);
d831 4
a834 4
		rt_log("%s:  solid import failure\n", dp->d_namep );
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		db_free_external( &ext );
	    	return(-1);		/* ERROR */
d874 2
a875 2
		rt_log("replot_modified_solid() sp==NULL?\n");
		return(-1);
d896 3
a898 3
		rt_log("%s: re-plot failure\n",
			sp->s_path[sp->s_last]->d_namep );
	    	return(-1);
d970 9
a978 8
		if( dp->d_addr != RT_DIR_PHONY_ADDR )  {
			rt_log("invent_solid(%s) would clobber existing database entry, ignored\n");
			return(-1);
		}
		/* Name exists from some other overlay,
		 * zap any associated solids
		 */
		eraseobj(dp);
d980 2
a981 2
		/* Need to enter phony name in directory structure */
		dp = db_diradd( dbip,  name, RT_DIR_PHONY_ADDR, 0, DIR_SOLID );
d1026 3
a1028 3
			no_memory = 1;
			rt_log("invent_solid: out of Displaylist\n");
			sp->s_bytes = 0;	/* not drawn */
d1030 1
a1030 1
			sp->s_bytes = dmp->dmr_load(sp->s_addr, sp->s_bytes );
d1059 5
a1063 4
		char	*sofar = db_path_to_string(pathp);
		rt_log("mged_facetize_region_end() path='%s'\n",
			sofar);
		rt_free(sofar, "path string");
d1089 3
a1091 1
f_facetize( argc, argv )
d1107 3
d1112 3
a1114 2
	rt_log("Please note that the NMG library used by this command is experimental.\n");
	rt_log("A production implementation will exist in the maintenance release.\n");
d1143 12
a1154 5
			rt_log("option '%c' unknown\n", c);
			rt_log("Usage: facetize [-tT] [-P ncpu] object(s)\n\
	-t Perform CSG-to-tNURBS conversion\n\
	-T enable triangulator\n");
			break;
d1159 4
a1162 1
	if( argc < 0 )  {rt_log("facetize: missing argument\n"); return CMD_BAD;}
d1167 4
a1170 1
	if( argc < 0 )  {rt_log("facetize: missing argument\n"); return CMD_BAD;}
d1173 3
a1175 2
		rt_log("error: solid '%s' already exists, aborting\n", newname);
		return CMD_BAD;
d1178 10
a1187 2
	rt_log("facetize:  tessellating primitives with tolerances a=%g, r=%g, n=%g\n",
		mged_abs_tol, mged_rel_tol, mged_nrm_tol );
d1204 4
a1207 4
		rt_log("facetize: error in db_walk_tree()\n");
		/* Destroy NMG */
		nmg_km( mged_nmg_model );
		return CMD_BAD;
d1211 1
a1211 1
	rt_log("facetize:  evaluating boolean expressions\n");
d1215 6
a1220 6
		rt_log("facetize:  no resulting region, aborting\n");
		db_free_tree( mged_facetize_tree );
	    	mged_facetize_tree = (union tree *)NULL;
		nmg_km( mged_nmg_model );
		mged_nmg_model = (struct model *)NULL;
		return CMD_BAD;
d1224 2
a1225 1
	rt_log("facetize:  %s\n", mged_facetize_tree->tr_d.td_name );
d1230 2
a1231 2
		rt_log("facetize:  triangulating resulting object\n" );
		nmg_triangulate_model( mged_nmg_model , &mged_tol );
d1234 1
a1234 1
	rt_log("facetize:  converting NMG to database format\n");
d1246 5
a1250 5
		rt_log("facetize(%s):  solid export failure\n",
			newname );
		if( intern.idb_ptr )  rt_functab[ID_NMG].ft_ifree( &intern );
		db_free_external( &ext );
		return CMD_BAD;				/* FAIL */
d1258 1
a1258 2
	    	ALLOC_ERR;
		return CMD_BAD;
d1263 1
a1263 3
		ERROR_RECOVERY_SUGGESTION;
		WRITE_ERR;
		return CMD_BAD;
d1265 11
a1275 2
	rt_log("facetize:  wrote %.2f Kbytes to database\n",
		ext.ext_nbytes / 1024.0 );
d1282 1
a1282 1
	return CMD_OK;					/* OK */
d1292 3
a1294 1
f_bev( argc, argv )
d1312 3
d1317 3
a1319 2
	rt_log("Please note that the NMG library used by this command is experimental.\n");
	rt_log("A production implementation will exist in the maintenance release.\n");
d1345 10
a1354 2
			rt_log("option '%c' unknown\n", c);
			break;
d1365 3
a1367 2
		rt_log("error: solid '%s' already exists, aborting\n", newname);
		return CMD_BAD;
d1372 13
a1384 2
		rt_log( "Nothing to evaluate!!!\n" );
		return CMD_BAD;
a1386 2
	rt_log("bev:  tessellating primitives with tolerances a=%g, r=%g, n=%g\n",
		mged_abs_tol, mged_rel_tol, mged_nrm_tol );
d1404 4
a1407 4
			rt_log("bev: error in db_walk_tree()\n");
			/* Destroy NMG */
			nmg_km( mged_nmg_model );
			return CMD_BAD;
d1436 12
a1447 6
					rt_log( "Unrecognized operator: (%c)\n" , op );
					rt_log( "Aborting\n" );
					db_free_tree( mged_facetize_tree );
					nmg_km( mged_nmg_model );
					return CMD_BAD;
					break;
d1471 1
a1471 1
	rt_log("bev:  evaluating boolean expressions\n");
d1475 6
a1480 6
		rt_log("bev:  no resulting region, aborting\n");
		db_free_tree( tmp_tree );
	    	tmp_tree = (union tree *)NULL;
		nmg_km( mged_nmg_model );
		mged_nmg_model = (struct model *)NULL;
		return CMD_BAD;
d1484 1
a1484 1
	rt_log("facetize:  %s\n", tmp_tree->tr_d.td_name );
d1491 2
a1492 2
		rt_log("bev:  triangulating resulting object\n" );
		nmg_triangulate_model( mged_nmg_model , &mged_tol );
d1495 1
a1495 1
	rt_log("bev:  converting NMG to database format\n");
d1507 4
a1510 5
		rt_log("bev(%s):  solid export failure\n",
			newname );
		if( intern.idb_ptr )  rt_functab[ID_NMG].ft_ifree( &intern );
		db_free_external( &ext );
		return CMD_BAD;				/* FAIL */
d1518 1
a1518 2
	    	ALLOC_ERR;
		return CMD_BAD;
d1523 11
a1533 3
		ERROR_RECOVERY_SUGGESTION;
		WRITE_ERR;
		return CMD_BAD;
d1535 1
a1535 2
	rt_log("bev:  wrote %.2f Kbytes to database\n",
		ext.ext_nbytes / 1024.0 );
d1544 1
a1544 1
	return( f_edit( 2, edit_args ) );
@


11.20
log
@Upgraded "facetize" command to convert to trimmed nurbs
@
text
@d87 1
d374 3
d433 1
d437 1
a437 1
	while( (c=getopt(argc,argv,"dnqstuvwTP:")) != EOF )  {
d454 3
d474 1
a474 1
			rt_log("Usage: ev [-dnqstuvwT] [-P ncpu] object(s)\n\
d482 1
@


11.19
log
@Added initial support for nmg_booltree_leaf_tess() calling.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.18 1995/08/29 14:50:55 jra Exp $ (BRL)";
d1073 1
d1095 1
a1095 1
	while( (c=getopt(argc,argv,"tP:")) != EOF )  {
d1100 3
d1104 1
a1104 1
			triangulate = 1;
d1108 3
d1116 1
d1121 1
d1139 5
a1143 1
		nmg_booltree_leaf_tess );
@


11.18
log
@Added check to mged_nmg_region_end() to avoid bombing user tries "ev -d" on a region.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.17 1995/07/27 21:26:20 mike Exp jra $ (BRL)";
d414 1
d432 1
a432 1
	while( (c=getopt(argc,argv,"dnqsuvwTP:")) != EOF )  {
d440 3
d466 1
a466 1
			rt_log("Usage: ev [-dnqsuvwT] [-P ncpu] object(s)\n\
d471 1
d540 4
a543 1
			nmg_booltree_leaf_tess );
@


11.17
log
@Made mged_initial_tree_state global.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dodraw.c,v 11.16 1995/07/25 17:48:19 gdurf Exp mike $ (BRL)";
d336 6
@


11.16
log
@2-arg cmdline()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.15 1995/03/09 21:32:28 butler Exp gdurf $ (BRL)";
d57 1
a57 1
static struct db_tree_state	mged_initial_tree_state = {
@


11.15
log
@forgot to initialize mged_draw_nmg_only to 0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.14 1995/03/09 20:56:34 butler Exp butler $ (BRL)";
d113 1
a113 5
#ifdef XMGED
	(void)cmdline( &str, False );
#else
	(void)cmdline( &str );
#endif
d891 1
a891 5
#ifdef XMGED
	(void)cmdline( &str, False );
#else
	(void)cmdline(&str);
#endif
@


11.14
log
@updated help message for "ev" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.13 1995/03/03 17:51:12 mike Exp butler $ (BRL)";
d419 1
@


11.13
log
@Improved layering, so that nmgregions are converted to vlblocks
for the "edgeuse thang", as Lee calls it, down in the region handler.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.12 95/03/03 17:35:45 mike Exp Locker: mike $ (BRL)";
d82 1
d334 6
a339 4
	failed = nmg_boolean( curtree, *tsp->ts_m, tsp->ts_tol );
	if( failed )  {
		db_free_tree( curtree );
		return (union tree *)NULL;
d428 1
a428 1
	while( (c=getopt(argc,argv,"nqsuvwTP:")) != EOF )  {
d454 3
d459 2
a460 1
			rt_log("Usage: ev [-uwTnq] object(s)\n\
@


11.12
log
@ev -u didn't work any more -- to aggressive about releasing nmgregion.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.11 95/02/25 03:36:50 mike Exp Locker: mike $ (BRL)";
d302 1
a371 1
		/* NMG region is no longer necessary, only vlist remains */
d373 1
a373 4
			/* Leave nmgregion intact for caller to use
			 * via mged_nmg_model, kill off tree.
			 */
			curtree->tr_d.td_r = (struct nmgregion *)NULL;
d375 1
d515 4
d528 3
a530 7
	  		struct rt_vlblock *vbp;

	  		rt_log( "Doing the edgeuse thang\n");
	  		vbp = rt_vlblock_init();
			nmg_vlblock_m(vbp, mged_nmg_model, 1);
	  		cvt_vlblock_to_solids(vbp, "_EDGEUSES_", 0);
	  		rt_vlblock_free(vbp);
@


11.11
log
@Converted to nmg_boolean().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dodraw.c,v 11.10 1995/02/22 05:36:43 mike Exp mike $ (BRL)";
d372 5
a376 3
		if( !mged_draw_edge_uses )  {
			db_free_tree( curtree );
			return (union tree *)NULL;
d378 2
@


11.10
log
@nmg_model_fuse() is still accounting for 25% of the runtime.  In order
to correct this, it is necessary for me to make calling nmg_model_fuse()
a pre-condition of calling nmg_booltree_evaluate().  That way it's done
exactly once per region.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.9 1995/02/17 03:58:16 mike Exp mike $ (BRL)";
d315 1
d332 5
a336 4
	(void)nmg_model_fuse( *tsp->ts_m, tsp->ts_tol );
	curtree = nmg_booltree_evaluate( curtree, tsp->ts_tol );
	if( !curtree )  return (union tree *)NULL;
	if( curtree->tr_op != OP_NMG_TESS )  rt_bomb("mged_nmg_region_end() bad tr_op\n");
d338 1
d1056 1
d1126 2
a1127 4
	(void)nmg_model_fuse( mged_nmg_model, &mged_tol );
	mged_facetize_tree = nmg_booltree_evaluate( mged_facetize_tree, &mged_tol );
	if( mged_facetize_tree == 0 || mged_facetize_tree->tr_op != OP_NMG_TESS ||
	    mged_facetize_tree->tr_d.td_r == 0 )  {
d1129 1
a1129 1
		if( mged_facetize_tree ) db_free_tree( mged_facetize_tree );
d1132 1
d1214 1
d1349 2
a1350 4
	(void)nmg_model_fuse( mged_nmg_model, &mged_tol );
	tmp_tree = nmg_booltree_evaluate( tmp_tree, &mged_tol );
	if( tmp_tree == 0 || tmp_tree->tr_op != OP_NMG_TESS ||
	    tmp_tree->tr_d.td_r == 0 )  {
d1352 1
a1352 1
		if( tmp_tree ) db_free_tree( tmp_tree );
d1355 1
@


11.9
log
@Don't free the regions before exporting them to the disk!
(bev, facetize)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.8 95/02/17 03:29:12 mike Exp Locker: mike $ (BRL)";
d331 1
d1122 1
d1345 1
@


11.8
log
@Wrong variable.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.7 95/02/17 02:46:24 mike Exp Locker: mike $ (BRL)";
a1133 4
	/* Free boolean tree */
	db_free_tree( mged_facetize_tree );
    	mged_facetize_tree = (union tree *)NULL;

d1160 1
d1178 5
d1314 1
a1315 1
					db_free_tree( mged_facetize_tree );
a1357 3
	/* Free boolean tree */
	db_free_tree( tmp_tree );

d1384 1
d1403 2
@


11.7
log
@Changed return code of nmg_booltree_evaluate() to facilitate printing
the heritage of the boolean operations.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.6 95/02/15 09:36:43 jra Exp Locker: mike $ (BRL)";
d1352 1
a1352 1
	rt_log("facetize:  %s\n", mged_facetize_tree->tr_d.td_name );
@


11.6
log
@Added a call to nmg_vmodel in f_bev.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.5 95/02/13 12:56:37 jra Exp Locker: jra $ (BRL)";
d331 4
a334 1
	r = nmg_booltree_evaluate( curtree, tsp->ts_tol );
d337 2
a338 2
		nmg_kr(r);
		return curtree;
d368 4
a371 2
		if( !mged_draw_edge_uses )
			nmg_kr( r );
d374 2
a375 2
	/* Return original tree -- it needs to be freed (by caller) */
	return( curtree );
a1050 1
	struct nmgregion	*r;
d1121 3
a1123 2
	r = nmg_booltree_evaluate( mged_facetize_tree, &mged_tol );
	if( r == 0 )  {
d1125 2
d1131 2
a1132 1
	NMG_CK_REGION( r );
d1136 1
a1202 1
	struct nmgregion	*r;
d1341 3
a1343 2
	r = nmg_booltree_evaluate( tmp_tree, &mged_tol );
	if( r == 0 )  {
d1345 2
d1351 2
a1352 1
	NMG_CK_REGION( r );
@


11.5
log
@Modified f_bev to allow a single object with no boolean operations.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.4 95/01/25 15:24:35 jra Exp Locker: jra $ (BRL)";
d1341 2
@


11.4
log
@Changed eval command to "bev".
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.3 95/01/25 14:07:47 jra Exp Locker: jra $ (BRL)";
d1245 1
a1245 1
	if( argc < 2 )
@


11.3
log
@Added "eval" command.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 11.2 95/01/17 13:04:34 bparker Exp Locker: jra $ (BRL)";
d1175 1
a1175 1
/* eval [opts] new_obj obj1 op obj2 op obj3 ...
d1182 1
a1182 1
f_eval( argc, argv )
d1251 1
a1251 1
	rt_log("eval:  tessellating primitives with tolerances a=%g, r=%g, n=%g\n",
d1270 1
a1270 1
			rt_log("eval: error in db_walk_tree()\n");
d1331 1
a1331 1
	rt_log("eval:  evaluating boolean expressions\n");
d1335 1
a1335 1
		rt_log("eval:  no resulting region, aborting\n");
d1348 1
a1348 1
		rt_log("eval:  triangulating resulting object\n" );
d1352 1
a1352 1
	rt_log("eval:  converting NMG to database format\n");
d1364 1
a1364 1
		rt_log("eval(%s):  solid export failure\n",
d1385 1
a1385 1
	rt_log("eval:  wrote %.2f Kbytes to database\n",
@


11.2
log
@merging xmged sources
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/dodraw.c,v 11.2 95/01/17 11:42:51 bparker Exp $ (BRL)";
d1173 221
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.33 94/12/27 16:58:41 mike Exp $ (BRL)";
d111 4
d116 2
d875 4
d880 2
@


10.33
log
@Fixed bug #247, added rt_ prefix to memalloc(), etc.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.32 94/12/23 19:34:27 mike Exp Locker: mike $ (BRL)";
@


10.32
log
@Added -s and -v flag to "e" and "ev" commands.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.31 94/12/16 19:36:28 gdurf Exp Locker: mike $ (BRL)";
d652 1
a652 1
		sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
d846 1
a846 1
		memfree( &(dmp->dmr_map), bytes, (unsigned long)addr );
d958 1
a958 1
		sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
@


10.31
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.30 1994/12/08 23:36:21 mike Exp gdurf $ (BRL)";
d85 2
d239 4
a242 1
	dashflag = (tsp->ts_sofar & (TS_SOFAR_MINUS|TS_SOFAR_INTER) );
d341 1
a341 4
		if( mged_draw_normals )  {
			style = 2;
			/* 0 = vectors, 1 = w/polygon markers, 2 = polys with normals */
		} else if( mged_draw_wireframes )  {
d343 1
a343 1
			style = 0;
d346 1
a346 1
			style = 1;
d348 6
d403 2
d408 1
a408 1
	while( (c=getopt(argc,argv,"quwnTP:")) != EOF )  {
d413 6
d439 2
d549 1
@


10.30
log
@Extra checking.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.29 94/11/30 17:37:01 mike Exp Locker: mike $ (BRL)";
d252 1
a252 1
		printf("%s: plot failure\n",
d419 2
a420 2
			printf("option '%c' unknown\n", c);
			printf("Usage: ev [-uwTnq] object(s)\n\
d475 1
a475 1
	  	(void)printf("\
d491 1
a491 1
	  		fprintf(stderr, "Doing the edgeuse thang\n");
d546 1
a546 1
				(void)printf("unknown vlist op %d\n", *cmd);
d636 1
a636 1
			(void)printf("draw: out of Displaylist\n");
d681 1
a681 1
			printf("pathHmat:  %s is not a combination\n",
d700 1
a700 1
		(void)printf("pathHmat: unable to follow %s/%s path\n",
d731 1
a731 1
		(void)printf("replot_original_solid(%s): Unable to plot evaluated regions, skipping\n",
d741 1
a741 1
		(void)printf("replot_original_solid() unable to identify type of solid %s\n",
d792 1
a792 1
		(void)printf("replot_modified_solid() sp==NULL?\n");
d814 1
a814 1
		(void)printf("%s: re-plot failure\n",
d887 1
a887 1
			printf("invent_solid(%s) would clobber existing database entry, ignored\n");
d942 1
a942 1
			(void)printf("invent_solid: out of Displaylist\n");
d1047 1
a1047 1
			printf("option '%c' unknown\n", c);
d1059 1
a1059 1
		printf("error: solid '%s' already exists, aborting\n", newname);
@


10.29
log
@Improved usage message
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.28 94/11/05 03:45:03 mike Exp Locker: mike $ (BRL)";
d761 2
a762 1
    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
@


10.28
log
@Irix 6
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.27 94/10/19 23:57:31 cjohnson Exp Locker: mike $ (BRL)";
d420 5
@


10.27
log
@Change drawH_part2() to return void.
ADd check to make sure the db_full_path is not larger than the s_path[
array.  If it is, then the solid is not drwan.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.26 1994/08/27 03:18:18 mike Exp cjohnson $ (BRL)";
a50 8
static struct mater_info mged_no_mater = {
	/* RT default is white.  This is red, to stay clear of illuminate mode */
	1.0, 0, 0,		/* */
	0,			/* override */
	DB_INH_LOWER,		/* color inherit */
	DB_INH_LOWER		/* mater inherit */
};

a572 1
	register struct vlist *vp;
a962 1
	struct nmgregion	*r;
@


10.26
log
@Eliminated MIN() and MAX() from ged.h, in favor of V_MIN() and V_MAX()
from vmath.h, because some systems use the symbols MIN and MAX in
system header files.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.25 94/08/27 03:12:01 mike Exp Locker: mike $ (BRL)";
d43 1
d572 1
d585 7
d626 1
a626 1
		for( i=0; i<=sp->s_last; i++ )
d628 1
@


10.25
log
@Moved rt_vlist_copy() to librt/vlist.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.24 94/08/25 17:52:51 gdurf Exp Locker: mike $ (BRL)";
d559 2
a560 2
	MAX( sp->s_size, ymax - ymin );
	MAX( sp->s_size, zmax - zmin );
@


10.24
log
@Removed bsdselect
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.23 1994/08/09 15:18:34 gdurf Exp gdurf $ (BRL)";
a97 26
 *		R T _ C O P Y _ V L I S T
 *
 *  Duplicate the contents of a vlist.  Note that the copy may be more
 *  densely packed than the source.
 *
 *  XXX Move this support routine to librt.
 */
void
rt_copy_vlist( dest, src )
struct rt_list	*dest;
CONST struct rt_list	*src;
{
	struct rt_vlist	*vp;

	for( RT_LIST_FOR( vp, rt_vlist, src ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			RT_ADD_VLIST( dest, *pt, *cmd );
		}
	}
}

/*
d513 1
d842 1
a842 1
	rt_vls_printf( &str, "kill %s*\n", shortname );
d906 1
a906 1
		rt_copy_vlist( &(sp->s_vlist), vhead );
@


10.23
log
@Added include of conf.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.22 1994/08/05 14:45:22 mike Exp gdurf $ (BRL)";
d156 1
d160 9
a168 1
			(void)bsdselect( 1<<fd, 0, us );
d207 9
a215 1
			(void)bsdselect( 1<<fd, 0, us );
@


10.22
log
@Reworked mged_bound_solid() to run faster.
It's presently accounting for 9.6% of all MGED runtime.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.21 94/08/03 22:40:45 mike Exp Locker: mike $ (BRL)";
d27 2
@


10.21
log
@Changed to using raytrace.h definition
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.20 94/06/01 16:35:18 gdurf Exp Locker: mike $ (BRL)";
d525 2
a526 2
	vect_t				maxvalue;
	vect_t				minvalue;
d528 2
a529 2
	VSETALL( maxvalue, -INFINITY );
	VSETALL( minvalue,  INFINITY );
d546 6
a551 1
				VMINMAX( minvalue, maxvalue, *pt );
d560 3
a562 1
	VADD2SCALE( sp->s_center, minvalue, maxvalue, 0.5 );
d564 3
a566 3
	sp->s_size = maxvalue[X] - minvalue[X];
	MAX( sp->s_size, maxvalue[Y] - minvalue[Y] );
	MAX( sp->s_size, maxvalue[Z] - minvalue[Z] );
@


10.20
log
@Converted f_facetize to use new command return codes.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.19 1994/05/11 15:24:23 jra Exp gdurf $ (BRL)";
a876 1
#define PHONY_ADDR	(-1L)
d878 1
a878 1
		if( dp->d_addr != PHONY_ADDR )  {
d888 1
a888 1
		dp = db_diradd( dbip,  name, PHONY_ADDR, 0, DIR_SOLID );
@


10.19
log
@Union tree magic numbers
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.18 94/04/20 09:49:21 jra Exp Locker: jra $ (BRL)";
d996 1
a996 1
void
d1054 1
a1054 1
		return;
d1074 1
a1074 1
		return;
d1084 1
a1084 1
		return;
d1115 1
a1115 1
		return;				/* FAIL */
d1122 2
a1123 1
	    	ALLOC_ERR_return;
d1129 2
a1130 1
		WRITE_ERR_return;
d1135 1
a1135 1
	return;					/* OK */
@


10.18
log
@Added -t option to facetize command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.17 94/04/05 17:15:44 cjohnson Exp Locker: jra $ (BRL)";
d297 1
d980 1
@


10.17
log
@Add Hack to turn GRIPS cyan.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.16 1994/01/12 02:45:35 mike Exp $ (BRL)";
d1002 1
d1026 1
d1030 1
a1030 1
	while( (c=getopt(argc,argv,"P:")) != EOF )  {
d1035 3
a1086 2
	rt_log("facetize:  converting NMG to database format\n");

d1089 9
@


10.16
log
@Moved creation of global "mged_tol" variable from dodraw.c to ged.c
Now, the question is, what is a better way to select these values?
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dodraw.c,v 10.15 93/11/18 02:34:08 butler Exp $ (BRL)";
d271 22
a293 2

	drawH_part2( dashflag, &vhead, pathp, tsp, SOLID_NULL );
@


10.15
log
@added the "don't triangulate" option (-T) to ev command
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.14 93/07/13 21:03:47 mike Exp Locker: butler $ (BRL)";
a91 1
struct rt_tol		mged_tol;
d93 2
a432 7
	/* XXX These need to be improved */
	mged_tol.magic = RT_TOL_MAGIC;
	mged_tol.dist = 0.005;
	mged_tol.dist_sq = mged_tol.dist * mged_tol.dist;
	mged_tol.perp = 1e-6;
	mged_tol.para = 1 - mged_tol.perp;

a781 7
	/* XXX These need to be improved */
	mged_tol.magic = RT_TOL_MAGIC;
	mged_tol.dist = 0.005;
	mged_tol.dist_sq = mged_tol.dist * mged_tol.dist;
	mged_tol.perp = 1e-6;
	mged_tol.para = 1 - mged_tol.perp;

a1001 7

	/* XXX These need to be improved */
	mged_tol.magic = RT_TOL_MAGIC;
	mged_tol.dist = 0.005;
	mged_tol.dist_sq = mged_tol.dist * mged_tol.dist;
	mged_tol.perp = 1e-6;
	mged_tol.para = 1 - mged_tol.perp;
@


10.14
log
@Moved mged_nmg_doit() into LIBRT as nmg_booltree_evaluate().
Made tolerance handling consistent.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.13 92/10/13 16:15:14 mm Exp Locker: mike $ (BRL)";
d87 1
d319 4
d383 1
d390 1
a390 1
	while( (c=getopt(argc,argv,"quwnP:")) != EOF )  {
d397 3
@


10.13
log
@Added missing args.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.12 92/10/13 15:59:58 mm Exp Locker: mm $ (BRL)";
d90 2
a235 2
	struct rt_tess_tol	ttol;
	struct rt_tol		tol;
d237 3
a259 12
	ttol.magic = RT_TESS_TOL_MAGIC;
	ttol.abs = mged_abs_tol;
	ttol.rel = mged_rel_tol;
	ttol.norm = mged_nrm_tol;

	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d263 1
a263 1
	    &ttol, &tol ) < 0 )  {
a283 171
 *			M G E D _ N M G _ L E A F
 *
 *  Tessellate Solid into NMG
 *
 *  This routine must be prepared to run in parallel.
 */
HIDDEN union tree *mged_nmg_leaf( tsp, pathp, ep, id )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_external	*ep;
int			id;
{
	struct rt_db_internal	intern;
	struct nmgregion	*r1;
	union tree		*curtree;
	struct directory	*dp;
	struct rt_tess_tol	ttol;
	struct rt_tol		tol;

	dp = DB_FULL_PATH_CUR_DIR(pathp);

    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, ep, tsp->ts_mat ) < 0 )  {
		rt_log("%s:  solid import failure\n",
			DB_FULL_PATH_CUR_DIR(pathp)->d_namep );
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
	    	return(TREE_NULL);		/* ERROR */
	}
	RT_CK_DB_INTERNAL( &intern );

	ttol.magic = RT_TESS_TOL_MAGIC;
	ttol.abs = mged_abs_tol;
	ttol.rel = mged_rel_tol;
	ttol.norm = mged_nrm_tol;

	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	if( rt_functab[id].ft_tessellate(
	    &r1, mged_nmg_model, &intern,
	    &ttol, &tol ) < 0 )  {
		rt_log("%s: tessellation failure\n",
			dp->d_namep);
		rt_functab[id].ft_ifree( &intern );
	    	return(TREE_NULL);
	}
	rt_functab[id].ft_ifree( &intern );

	/* debug */
	NMG_CK_REGION( r1 );
	if( nmg_ck_closed_region( r1 ) != 0 )  {
#if 0
		nmg_kr( r1 );
		return(TREE_NULL);
#endif
	}

	GETUNION( curtree, tree );
	curtree->tr_op = OP_NMG_TESS;
	curtree->tr_d.td_r = r1;

	if(rt_g.debug&DEBUG_TREEWALK)
		rt_log("mged_nmg_leaf()\n");

	return(curtree);
}

/*
 *			M G E D _ N M G _ D O I T
 */
HIDDEN struct nmgregion *
mged_nmg_doit( tp, ttol )
register union tree	*tp;
struct rt_tess_tol	*ttol;
{
	register struct nmgregion	*l;
	register struct nmgregion	*r;
	vect_t			diag;
	fastf_t			rel;
	int			op;
	struct rt_tol		tol;

	RT_CK_TESS_TOL(ttol);

	switch( tp->tr_op )  {
	case OP_NOP:
		return( 0 );

	case OP_NMG_TESS:
		r = tp->tr_d.td_r;
		tp->tr_d.td_r = (struct nmgregion *)NULL;	/* Disconnect */
		tp->tr_op = OP_NOP;	/* Keep quiet */
		return( r );

	case OP_UNION:
		op = NMG_BOOL_ADD;
		goto com;
	case OP_INTERSECT:
		op = NMG_BOOL_ISECT;
		goto com;
	case OP_SUBTRACT:
		op = NMG_BOOL_SUB;
		goto com;

	default:
		rt_log("mged_nmg_doit: bad op %d\n", tp->tr_op);
		return(0);
	}
com:
	l = mged_nmg_doit( tp->tr_b.tb_left, ttol );
	r = mged_nmg_doit( tp->tr_b.tb_right, ttol );
	if( l == 0 )  {
		if( r == 0 )
			return( 0 );
		return( r );
	}
	if( r == 0 )  {
		if( l == 0 )
			return(0);
		return( l );
	}
	/* debug */
	NMG_CK_REGION( r );
	NMG_CK_REGION( l );
	if( nmg_ck_closed_region( r ) != 0 )
	    	rt_log("mged_nmg_doit:  WARNING, non-closed shell (r), barging ahead\n");
	if( nmg_ck_closed_region( l ) != 0 )
	    	rt_log("mged_nmg_doit:  WARNING, non-closed shell (l), barging ahead\n");

	/*
	 *  Compute appropriate tolerance for the boolean routine.
	 *  This tolerance is an absolute distance metric.
	 *  The geometry is guaranteed to contain no errors larger than
	 *  this tolerance value.
	 */
	tol.dist = ttol->abs;
	if( ttol->rel > 0.0 )  {
		if( l->ra_p )  {
			VSUB2( diag, l->ra_p->max_pt, l->ra_p->min_pt );
			rel = MAGNITUDE(diag) * ttol->rel;
			if( tol.dist <= 0.0 || rel < tol.dist )  tol.dist = rel;
		}
		if( r->ra_p )  {
			VSUB2( diag, r->ra_p->max_pt, r->ra_p->min_pt );
			rel = MAGNITUDE(diag) * ttol->rel;
			if( tol.dist <= 0.0 || rel < tol.dist )  tol.dist = rel;
		}
	}
	if( tol.dist <= 0.0 )  tol.dist = 0.1;		/* mm */

	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist /= 128;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	/* input r1 and r2 are destroyed, output is new r1 */
	r = nmg_do_bool( l, r, op, &tol );

	/* debug */
	NMG_CK_REGION( r );
	(void)nmg_ck_closed_region( r );
	return( r );
}

/*
a294 1
	struct rt_tess_tol	ttol;
d296 4
d311 1
a311 4
	ttol.magic = RT_TESS_TOL_MAGIC;
	ttol.abs = mged_abs_tol;
	ttol.rel = mged_rel_tol;
	ttol.norm = mged_nrm_tol;
a312 2
	r = mged_nmg_doit( curtree, &ttol );

d414 16
d464 1
a465 1

d471 1
a471 1
			mged_nmg_leaf );
a755 2
	struct rt_tess_tol	ttol;
	struct rt_tol		tol;
d774 4
a777 4
	ttol.magic = RT_TESS_TOL_MAGIC;
	ttol.abs = mged_abs_tol;
	ttol.rel = mged_rel_tol;
	ttol.norm = mged_nrm_tol;
d780 5
a784 5
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;
d788 1
a788 1
	if( rt_functab[ip->idb_type].ft_plot( &vhead, &intern, &ttol, &tol ) < 0 )  {
a991 1
	struct rt_tess_tol	ttol;
d998 16
d1045 2
d1052 1
a1052 1
		mged_nmg_leaf );
d1064 1
a1064 6
	ttol.magic = RT_TESS_TOL_MAGIC;
	ttol.abs = mged_abs_tol;
	ttol.rel = mged_rel_tol;
	ttol.norm = mged_nrm_tol;

	r = mged_nmg_doit( mged_facetize_tree, &ttol );
@


10.12
log
@Changed to OP_NMG_TESS.
Added ttol arg to mged_nmg_doit().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.12 92/10/13 15:57:50 mm Exp $ (BRL)";
d406 2
a407 2
	l = mged_nmg_doit( tp->tr_b.tb_left );
	r = mged_nmg_doit( tp->tr_b.tb_right );
@


10.11
log
@added extern for "frametime"
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.10 92/07/23 05:02:07 butler Exp Locker: butler $ (BRL)";
d355 2
a356 2
	curtree->tr_op = OP_REGION;	/* tag for nmg */
	curtree->tr_c.tc_ctsp = (struct combined_tree_state *)r1;
d368 1
a368 1
mged_nmg_doit( tp )
d370 1
d379 2
d385 4
a388 4
	case OP_REGION:
		r = (struct nmgregion *)tp->tr_c.tc_ctsp;
		tp->tr_c.tc_ctsp = (struct combined_tree_state *)0;/* Disconnect */
		tp->tr_op = OP_NOP;	/* Keep our use of OP_REGION quiet */
d432 2
a433 2
	tol.dist = mged_abs_tol;
	if( mged_rel_tol > 0.0 )  {
d436 1
a436 1
			rel = MAGNITUDE(diag) * mged_rel_tol;
d441 1
a441 1
			rel = MAGNITUDE(diag) * mged_rel_tol;
d475 1
d488 4
a491 1
	r = mged_nmg_doit( curtree );
d493 2
d1160 1
d1214 7
a1220 1
	r = mged_nmg_doit( mged_facetize_tree );
@


10.10
log
@changed upcall animation handlers to allow multiple frames to be drawn
per call.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.9 92/07/22 20:59:31 mike Exp Locker: butler $ (BRL)";
d44 1
a44 1

@


10.9
log
@Made mged_nmg_doit() tolerant of non-3-manifold intermediate results.
It warns, however.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.8 92/07/22 20:51:13 butler Exp Locker: mike $ (BRL)";
d139 5
a143 1
	event_check( 1 );	/* Take any device events */
d145 1
a145 2
	refresh();		/* Force screen update */

d157 1
a177 1
	event_check( 1 );	/* Take any device events */
d179 6
a184 2
	refresh();		/* Force screen update */

d196 1
@


10.8
log
@Support for Butler display feature
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.7 92/06/25 21:04:27 butler Exp Locker: butler $ (BRL)";
d410 4
a413 7
	if( nmg_ck_closed_region( r ) != 0 ||
	    nmg_ck_closed_region( l ) != 0 )  {
	    	rt_log("mged_nmg_doit:  non-closed shell, skipped\n");
	    	nmg_kr( r );
	    	nmg_kr( l );
		return(0);
	}
@


10.7
log
@added code to "ev" to allow plotting of edgeuses on finished result
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dodraw.c,v 10.5 92/04/03 19:24:19 mike Exp Locker: butler $ (BRL)";
d43 1
d190 4
d195 3
d580 1
@


10.6
log
@Added parameter to nmg_vlblock_anim_upcall
(mged_vlblock_anim_upcall_handler) and invent_solid() to indicate don't
copy vlist, steal them, which matches current usage.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.5 92/04/03 19:24:19 mike Exp Locker: mike $ (BRL)";
d272 3
a275 1

d472 6
d498 2
a499 1
		nmg_kr( r );
d540 1
d544 1
a544 1
	while( (c=getopt(argc,argv,"wnP:")) != EOF )  {
d546 3
d558 3
d607 2
d615 10
@


10.5
log
@Changed cmdline() to take an rt_vls argument
@
text
@d10 1
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.4 92/02/05 15:34:30 mike Exp Locker: mike $ (BRL)";
d91 26
d165 1
a165 1
mged_vlblock_anim_upcall_handler( vbp, us )
d168 1
d171 1
a171 1
	cvt_vlblock_to_solids( vbp, "_PLOT_OVERLAY_" );
d273 1
d927 1
a927 1
cvt_vlblock_to_solids( vbp, name )
d930 1
d949 1
a949 1
			invent_solid( name, &vbp->head[0], vbp->rgb[0] );
d954 1
a954 1
		invent_solid( namebuf, &vbp->head[i], vbp->rgb[i] );
d968 1
a968 1
invent_solid( name, vhead, rgb )
d972 1
d1004 8
a1011 1
	RT_LIST_APPEND_LIST( &(sp->s_vlist), vhead );
@


10.4
log
@db_put_external() now adds the name.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.3 92/02/05 13:09:14 mike Exp Locker: mike $ (BRL)";
d103 1
a103 1
	char	buf[128];
d106 4
a109 2
	sprintf( buf, "overlay %s\n", file );
	cmdline( buf );
d905 1
a905 1
	char		cmd_buf[64];
d910 4
a913 2
	sprintf( cmd_buf, "kill %s*\n", shortname );
	cmdline(cmd_buf);
@


10.3
log
@Fixed bug with replot_modified_solid() not using "mat" arg.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.2 91/12/20 01:09:18 mike Exp Locker: mike $ (BRL)";
a1063 1
	union record		*rec;
a1150 4

	/* Depends on solid names always being in the same place */
	rec = (union record *)ext.ext_buf;
	NAMEMOVE( newname, rec->s.s_name );
@


10.2
log
@Changed calling sequence to replot_modified_solid() to use
an rt_db_internal structure, rather than a pointer to union record.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 10.1 91/10/12 06:43:38 mike Rel4_0 Locker: mike $ (BRL)";
d809 1
a809 1
	if( replot_modified_solid( sp, &intern, mat ) < 0 )  {
d837 1
d872 3
a874 1
	if( rt_functab[ip->idb_type].ft_plot( &vhead, ip, &ttol, &tol ) < 0 )  {
d879 1
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.37 91/10/11 11:32:47 butler Exp $ (BRL)";
d776 5
a780 2
	union record	*rp;
	mat_t		mat;
d782 1
d785 1
a785 1
			sp->s_path[sp->s_last]->d_namep );
d789 8
a796 3
	rp = db_getmrec( dbip, sp->s_path[sp->s_last]);
	if( replot_modified_solid( sp, rp, mat ) < 0 )  {
		rt_free( (char *)rp, "original solid rec" );
d799 17
a815 1
	rt_free( (char *)rp, "original solid rec" );
d832 4
a835 4
replot_modified_solid( sp, recp, mat )
struct solid	*sp;
union record	*recp;
mat_t		mat;
a838 3
	int			id;
	struct rt_external	ext;
	struct rt_db_internal	intern;
a851 10
	RT_INIT_EXTERNAL( &ext );
	ext.ext_buf = (genptr_t)recp;
	ext.ext_nbytes = sizeof(union record);

	if( (id = rt_id_solid( &ext )) == ID_NULL )  {
		(void)printf("replot_modified_solid() unable to identify type of solid %s\n",
			sp->s_path[sp->s_last]->d_namep );
		return(-1);
	}

d857 1
a858 9
    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, &ext, mat ) < 0 )  {
		rt_log("%s:  solid import failure\n",
			sp->s_path[sp->s_last]->d_namep );
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
	    	return(-1);		/* ERROR */
	}
	RT_CK_DB_INTERNAL( &intern );

d871 1
a871 2
	if( rt_functab[id].ft_plot( &vhead, &intern,
	    &ttol, &tol ) < 0 )  {
a873 1
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
a875 1
	rt_functab[id].ft_ifree( &intern );
@


9.37
log
@mods to make SGI 3030 happy
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.36 91/08/29 22:44:52 mike Exp Locker: butler $ (BRL)";
@


9.36
log
@Stardent lint
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.35 91/07/08 15:24:26 butler Exp $ (BRL)";
d310 1
a310 1
		rt_log("mged_nmg_leaf() %s\n", curtree->tr_a.tu_name );
@


9.35
log
@added caveat emptor to "facetize" command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.34 91/07/06 02:18:20 mike Exp $ (BRL)";
d531 1
a531 1
		i = db_walk_tree( dbip, argc, argv,
d560 1
a560 1
		i = db_walk_tree( dbip, argc, argv,
d1100 1
a1100 1
	i = db_walk_tree( dbip, argc, argv,
@


9.34
log
@ANSI screwiness isn't compatible with K&R
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.33 91/07/06 00:08:23 mike Exp $ (BRL)";
d1065 3
@


9.33
log
@ANSI structure initialization
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.32 91/07/01 01:51:09 mike Exp $ (BRL)";
d65 1
d67 1
d74 5
a78 2
		"",			/* material params */
	},
@


9.32
log
@Made OP_REGION hack more tidy.
It was setting off bugchecks in db_tree.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.31 91/06/30 21:14:03 mike Exp $ (BRL)";
d65 9
a73 6
	1.0, 0.0, 0.0,		/* color, RGB */
	0,			/* override */
	DB_INH_LOWER,		/* color inherit */
	DB_INH_LOWER,		/* mater inherit */
	"",			/* material name */
	"",			/* material params */
@


9.31
log
@Added warning about NMGs being experimental
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.30 91/06/11 00:39:15 mike Exp $ (BRL)";
d299 1
a299 3
	curtree->tr_a.tu_stp = (struct soltab *)r1;
	curtree->tr_a.tu_name = (char *)0;
	curtree->tr_a.tu_regionp = (struct region *)0;
d326 3
a328 2
		r = (struct nmgregion *)tp->tr_a.tu_stp;
		tp->tr_a.tu_stp = SOLTAB_NULL;	/* Disconnect */
@


9.30
log
@Ignore empty regions
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.29 91/05/24 19:28:05 mike Exp $ (BRL)";
d549 3
@


9.29
log
@Modified to track JEHunt's inclusion of LOS
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.28 91/05/23 00:19:31 mike Exp $ (BRL)";
d429 2
d1016 2
@


9.28
log
@Better tolerance hack.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.27 91/05/18 03:31:06 mike Exp $ (BRL)";
d64 1
@


9.27
log
@Converted to new tolerance interface
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.26 91/03/01 22:31:08 mike Exp $ (BRL)";
d389 7
@


9.26
log
@This still does not seem to give the desired delay between frames.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.25 91/02/27 20:08:38 mike Exp $ (BRL)";
d179 2
d202 12
d217 1
a217 1
	    mged_abs_tol, mged_rel_tol, mged_nrm_tol ) < 0 )  {
d251 2
d265 12
d279 1
a279 1
	    mged_abs_tol, mged_rel_tol, mged_nrm_tol ) < 0 )  {
a317 1
	fastf_t			tol;
d320 1
d375 1
a375 1
	tol = mged_abs_tol;
d380 1
a380 1
			if( tol <= 0.0 || rel < tol )  tol = rel;
d385 1
a385 1
			if( tol <= 0.0 || rel < tol )  tol = rel;
d388 1
a388 1
	if( tol <= 0.0 )  tol = 0.1;		/* mm */
d391 1
a391 1
	r = nmg_do_bool( l, r, op, tol );
d797 2
d835 12
d848 1
a848 1
	    mged_abs_tol, mged_rel_tol, mged_nrm_tol ) < 0 )  {
@


9.25
log
@Made facetize command a bit more chatty, for now.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.24 91/02/27 04:16:20 mike Exp $ (BRL)";
d105 10
a114 2
	if(us)
		(void)bsdselect( 0, 0, us );
d139 10
a148 2
	if(us)
		(void)bsdselect( 0, 0, us );
d1067 2
@


9.24
log
@Made FACETIZE a bit more chatty, for reassurance.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.23 91/02/27 04:14:17 mike Exp $ (BRL)";
d1013 2
a1014 1
	rt_log("facetize:  tessellating primitives\n");
d1042 1
a1042 1
	rt_log("facetize:  exporting NMG to database\n");
d1078 2
@


9.23
log
@Changed so that FACETIZE command produces a single region as it's
output.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.22 91/02/06 23:58:01 mike Exp $ (BRL)";
d1013 1
d1031 1
d1040 2
@


9.22
log
@Added facetize command
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.21 91/02/02 00:01:12 mike Exp $ (BRL)";
d563 2
d635 1
d637 1
d925 2
d949 13
a961 2
	(void)mged_nmg_doit( curtree );
	/* New region remains part of this nmg "model" */
d963 2
a964 2
	/* Return original tree -- it needs to be freed (by caller) */
	return( curtree );
d981 1
d1013 1
d1028 14
d1058 1
@


9.21
log
@Modified for new rt_vlist structures
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.20 91/01/26 03:23:07 mike Exp $ (BRL)";
a42 2
struct vlist	*rtg_vlFree;	/* should be rt_g.rtg_vlFree !! XXX dm.h */

d919 122
@


9.20
log
@Changed calling sequences for ft_plot, rt_id_solid, etc.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.19 91/01/12 08:00:37 mike Exp $ (BRL)";
d122 1
a122 1
struct vlblock	*vbp;
d164 1
a164 1
	struct vlhead	vhead;
d166 1
a166 1
	vhead.vh_first = vhead.vh_last = VL_NULL;
d197 1
a197 1
	drawH_part2( dashflag, vhead.vh_first, pathp, tsp, SOLID_NULL );
d368 1
a368 1
	struct vlhead	vhead;
d370 1
a370 1
	vhead.vh_first = vhead.vh_last = VL_NULL;
d397 1
a397 1
		drawH_part2( 0, vhead.vh_first, pathp, tsp, SOLID_NULL );
d516 45
d566 3
a568 3
drawH_part2( dashflag, vfirst, pathp, tsp, existing_sp )
int		dashflag;
struct vlist	*vfirst;
a575 1
	vect_t		maxvalue, minvalue;
d591 2
a592 21
	VSETALL( maxvalue, -INFINITY );
	VSETALL( minvalue,  INFINITY );
	sp->s_vlist = vfirst;
	sp->s_vlen = 0;
	for( vp = vfirst; vp != VL_NULL; vp = vp->vl_forw )  {
		switch( vp->vl_draw )  {
		case VL_CMD_POLY_START:
			/* Has normal vector, not location */
			break;
		case VL_CMD_LINE_MOVE:
		case VL_CMD_LINE_DRAW:
		case VL_CMD_POLY_MOVE:
		case VL_CMD_POLY_DRAW:
		case VL_CMD_POLY_END:
			VMINMAX( minvalue, maxvalue, vp->vl_pnt );
			break;
		default:
			(void)printf("unknown vlist op %d\n", vp->vl_draw);
		}
		sp->s_vlen++;
	}
a594 6
	VADD2SCALE( sp->s_center, minvalue, maxvalue, 0.5 );

	sp->s_size = maxvalue[X] - minvalue[X];
	MAX( sp->s_size, maxvalue[Y] - minvalue[Y] );
	MAX( sp->s_size, maxvalue[Z] - minvalue[Z] );

d746 3
a748 3
	unsigned	addr, bytes;
	struct vlhead	vhead;
	int		id;
d752 1
a752 1
	vhead.vh_first = vhead.vh_last = VL_NULL;
d759 3
d797 1
a797 1
	drawH_part2( sp->s_soldash, vhead.vh_first,
d812 2
a813 2
struct vlblock	*vbp;
char		*name;
d826 3
a828 3
	for( i=0; i < vbp->count; i++ )  {
		if( vbp->cvp[i].rgb == 0 )  continue;
		if( vbp->cvp[i].head.vh_first == VL_NULL )  continue;
d830 1
a830 1
			invent_solid( name, &vbp->cvp[0] );
d834 2
a835 2
			shortname, vbp->cvp[i].rgb );
		invent_solid( namebuf, &vbp->cvp[i] );
d849 4
a852 3
invent_solid( name, cvl )
char	*name;
struct color_vlhead	*cvl;
d854 2
a855 5
	register struct directory *dp;
	register struct solid *sp;
	register struct vlist *vp;
	struct vlhead	*vhead;
	vect_t		max, min;
a856 2
	vhead = &cvl->head;

d875 4
a878 5
	state.ts_mater.ma_color[0] = ((cvl->rgb>>16) & 0xFF) / 255.0
	state.ts_mater.ma_color[1] = ((cvl->rgb>> 8) & 0xFF) / 255.0
	state.ts_mater.ma_color[2] = ((cvl->rgb    ) & 0xFF) / 255.0
	drawH_part2( 0, vhead->vh_first, path, &state, SOLID_NULL );
	vhead->vh_first = vhead->vh_last = VL_NULL;
d884 3
a886 14
	VSETALL( max, -INFINITY );
	VSETALL( min,  INFINITY );
	sp->s_vlist = vhead->vh_first;
	vhead->vh_first = vhead->vh_last = VL_NULL;
	sp->s_vlen = 0;
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		/* XXX need to look at types here */
		VMINMAX( min, max, vp->vl_pnt );
		sp->s_vlen++;
	}
	VSET( sp->s_center,
		(max[X] + min[X])*0.5,
		(max[Y] + min[Y])*0.5,
		(max[Z] + min[Z])*0.5 );
a887 4
	sp->s_size = max[X] - min[X];
	MAX( sp->s_size, max[Y] - min[Y] );
	MAX( sp->s_size, max[Z] - min[Z] );

d895 3
a897 3
	sp->s_color[0] = sp->s_basecolor[0] = (cvl->rgb>>16) & 0xFF;
	sp->s_color[1] = sp->s_basecolor[1] = (cvl->rgb>> 8) & 0xFF;
	sp->s_color[2] = sp->s_basecolor[2] = (cvl->rgb    ) & 0xFF;
@


9.19
log
@lint
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.18 90/12/06 23:56:00 mike Exp $ (BRL)";
d155 1
a155 1
HIDDEN union tree *mged_wireframe_leaf( tsp, pathp, rp, id )
d158 1
a158 1
union record		*rp;
d161 1
d177 12
a188 2
	if( rt_functab[id].ft_plot( rp, tsp->ts_mat, &vhead,
	    DB_FULL_PATH_CUR_DIR(pathp),
d192 1
d195 2
d209 2
d213 1
a213 1
HIDDEN union tree *mged_nmg_leaf( tsp, pathp, rp, id )
d216 1
a216 1
union record		*rp;
d219 1
d221 1
a221 1
	union tree	*curtree;
d226 9
a234 1
	/* Tessellate Solid to NMG */
d236 1
a236 1
	    &r1, mged_nmg_model, rp, tsp->ts_mat, dp,
d238 3
a240 1
		rt_log("%s tessellation failure\n", dp->d_namep);
d243 2
d730 2
d740 5
a744 1
	if( (id = rt_id_solid( recp )) == ID_NULL )  {
d755 11
a765 1
	if( rt_functab[id].ft_plot( recp, mat, &vhead, sp->s_path[sp->s_last],
d767 1
a767 1
		(void)printf("%s: plot failure\n",
d769 1
d772 1
@


9.18
log
@Removed stray big-E support.
Look in proc_reg.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.17 90/05/24 04:05:31 mike Exp $ (BRL)";
d31 1
a32 1
#include "nmg.h"
a38 4

extern int	getopt();
extern char	*optarg;
extern int	optind;
@


9.17
log
@Minor fixes.
Hints of better things to come.
@
text
@a1 2
 * XXXXX Big-E is badly broken right now
 *
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.16 90/05/24 03:06:44 mike Exp $ (BRL)";
a51 4
int	regmemb;	/* # of members left to process in a region */
char	memb_oper;	/* operation for present member of processed region */
int	reg_pathpos;	/* pathpos of a processed region */

a196 78
 *			M G E D _ B I G e _ L E A F
 *
 *  This routine must be prepared to run in parallel.
 */
HIDDEN union tree *mged_bigE_leaf( tsp, pathp, rp, id )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union record		*rp;
int			id;
{
	union tree	*curtree;
	int		dashflag;		/* draw with dashed lines */
	struct vlhead	vhead;
	int		flag = '-';
	int		i;

	vhead.vh_first = vhead.vh_last = VL_NULL;

	if(rt_g.debug&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(pathp);
		rt_log("mged_bigE_leaf(%s) path='%s'\n",
			rt_functab[id].ft_name, sofar );
		rt_free(sofar, "path string");
	}

	/* processing a member of a processed region */
	/* regmemb  =>  number of members left */
	/* regmemb == 0  =>  last member */
	if(memb_oper == UNION)
		flag = 999;

	/* The hard part */
	/* XXX flag is the boolean operation */
	i = proc_region( rp, tsp->ts_mat, flag );
	if( i < 0 )  {
		/* error somwhere */
		(void)printf("Error in converting solid %s to ARBN\n",
			DB_FULL_PATH_CUR_DIR(pathp)->d_namep );
		if(regmemb == 0) {
			regmemb = -1;
		}
	    	return(TREE_NULL);		/* ERROR */
	}

	/* if more member solids to be processed, no drawing was done
	 */
	if( regmemb > 0 )  {
		/* NOP -- more to come */
	    	return(TREE_NULL);
	}

	i = finish_region( &vhead );
	if( i < 0 )  {
		(void)printf("error in finish_region()\n");
	    	return(TREE_NULL);		/* ERROR */
	}
	drawH_part2( 0, vhead.vh_first, pathp, tsp, SOLID_NULL );

	/* Indicate success by returning something other than TREE_NULL */
	GETUNION( curtree, tree );
	curtree->tr_op = OP_NOP;
	return( curtree );
}

/*
 *			M G E D _ B I G e _ R E G I O N _ E N D
 *
 *  This routine must be prepared to run in parallel.
 */
HIDDEN union tree *mged_bigE_region_end( tsp, pathp, curtree )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
{
	return( curtree );
}

/*
d456 1
d465 4
d564 2
a566 9
		if(regmemb == 0) {
			/* done processing a region */
			regmemb = -1;
			sp->s_last = reg_pathpos;
			sp->s_Eflag = 1;	/* This is processed region */
		}  else  {
			sp->s_Eflag = 0;	/* This is a solid */
			sp->s_last = pathp->fp_len-1;
		}
@


9.16
log
@Moved cvt_vlblock_to_solids and invent_solid here.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.15 90/05/23 12:16:33 mike Exp $ (BRL)";
d848 2
a853 1
		if( vbp->cvp[i].rgb == 0 )  continue;
d897 10
d960 1
@


9.15
log
@Modified to provide plot overlay upcall facility for LIBRT internals.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.14 90/05/22 21:43:08 mike Exp $ (BRL)";
d47 1
d122 26
d524 1
d827 123
@


9.14
log
@Changed to use VL_CMD_* definitions.  Added description of VL_CMD_*
stuff to "x" command.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.13 90/05/21 12:40:20 mike Exp $ (BRL)";
d46 2
d92 29
d494 3
@


9.13
log
@Released NMG region when done with it.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.12 90/05/18 07:43:34 mike Exp $ (BRL)";
d544 14
a557 2
		/* XXX need to skip normal vectors, markers */
		VMINMAX( minvalue, maxvalue, vp->vl_pnt );
@


9.12
log
@Changed from processing shells to processing regions.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dodraw.c,v 9.11 90/05/04 04:19:23 mike Exp $ (BRL)";
d399 3
@


9.11
log
@Changed drawtrees to process options, using getopt().
Changed calling sequence to include argv[0].
Changed eedit() handling of deletions.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.10 90/05/01 02:59:41 mike Locked $ (BRL)";
d248 1
a248 1
	if( nmg_ck_closed_surf( r1->s_p ) != 0 )  {
d320 2
a321 2
	if( nmg_ck_closed_surf( r->s_p ) != 0 ||
	    nmg_ck_closed_surf( l->s_p ) != 0 )  {
d354 1
a354 1
	(void)nmg_ck_closed_surf( r->s_p );
d382 1
d387 1
a388 1
			nmg_s_to_vlist( &vhead, r->s_p, 2 );
d391 1
a391 1
			nmg_s_to_vlist( &vhead, r->s_p, 0 );
d394 1
a394 1
			nmg_s_to_vlist( &vhead, r->s_p, 1 );
d396 1
@


9.10
log
@Added normal tolerance support.
Added tolerance parameter to nmg_do_bool().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.9 90/04/28 03:45:01 mike Locked $ (BRL)";
d42 4
d85 2
d385 10
a394 2
		/* 0 = vectors, 1 = w/polygon markers */
		nmg_s_to_vlist( &vhead, r->s_p, 1 );
d408 1
d425 3
a427 1
	int			i;
d433 4
a436 1
	/* XXX could parse options here.  eg, -P ncpu, etc */
d438 21
d465 1
a465 1
			1,	/* # cpus */
d474 1
a474 1
			1,	/* # cpus */
d486 1
a486 1
			1,	/* # cpus */
a498 1

@


9.9
log
@nmg_ck_closed_surf() now returns a status code, rather than dumping core.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.8 90/04/26 02:15:38 mike Locked $ (BRL)";
d123 2
a124 1
	    DB_FULL_PATH_CUR_DIR(pathp), mged_abs_tol, mged_rel_tol ) < 0 )  {
d236 1
a236 1
	    mged_abs_tol, mged_rel_tol ) < 0 )  {
d266 1
a266 1
union tree	*tp;
d268 6
a273 2
	struct nmgregion	*l, *r;
	int	op;
d322 21
d344 2
a345 1
	r = nmg_do_bool( l, r, op );
d691 2
a692 2
	if( rt_functab[id].ft_plot( recp, mat, &vhead,
	    sp->s_path[sp->s_last], mged_abs_tol, mged_rel_tol ) < 0 )  {
@


9.8
log
@Added f_tol command.
Added support for tolerance args to ft_plot() and ft_tess().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.7 90/04/21 06:05:54 mike Locked $ (BRL)";
d239 1
a239 1
	nmg_ck_closed_surf( r1->s_p );	/* debug */
d241 6
d306 1
d309 7
a315 2
	nmg_ck_closed_surf( r->s_p );	/* debug */
	nmg_ck_closed_surf( l->s_p );	/* debug */
d319 1
d321 1
a321 1
	nmg_ck_closed_surf( r->s_p );	/* debug */
@


9.7
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.6 90/04/13 03:56:09 mike Locked $ (BRL)";
d123 1
a123 1
	    DB_FULL_PATH_CUR_DIR(pathp) ) < 0 )  {
d234 2
a235 1
	    &r1, mged_nmg_model, rp, tsp->ts_mat, dp ) < 0 )  {
d376 2
a382 1
	case 2:		/* Big-E */
d391 9
d652 1
a652 1
	    sp->s_path[sp->s_last] ) < 0 )  {
@


9.6
log
@Changed to use new tree walker.
Big-E and solid edits are temporarily broken.
@
text
@a2 1
 * XXXXX redraw() is broken too -- breaks solid edits.
d7 1
a7 1
 *	drawtree	Draw a tree
d10 2
a11 1
 *	redraw		redraw a single solid, given matrix and record.
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.5 90/04/13 00:33:46 mike Locked $ (BRL)";
d108 2
d111 2
d120 6
a125 4
	/*
	 * Enter new solid (or processed region) into displaylist.
	 */
	if( drawHsolid( rp, pathp, id, tsp ) < 0 ) {
d128 1
d148 52
d212 1
d253 4
a256 1
struct nmgregion *
d341 1
a341 1
		drawH_part2( 0, vhead.vh_first, pathp, tsp );
d412 1
a412 1
 *			D R A W T R E E
d414 2
a415 1
 *  This routine is the analog of rt_gettree().
d417 1
a417 75
void
drawtree( dp )
struct directory	*dp;
{
	(void)drawtrees( 1, &(dp->d_namep) );
}

/*
 *			D R A W H S O L I D
 *
 * Returns -
 *	-1	on error
 *	 0	if OK
 */
int
drawHsolid( recordp, pathp, id, tsp )
union record	*recordp;
struct db_full_path	*pathp;
int		id;
struct db_tree_state	*tsp;
{
	register int	i;
	int		dashflag;		/* draw with dashed lines */
	struct vlhead	vhead;

	vhead.vh_first = vhead.vh_last = VL_NULL;
	if( regmemb >= 0 ) {
		int	flag = '-';
		/* processing a member of a processed region */
		/* regmemb  =>  number of members left */
		/* regmemb == 0  =>  last member */
		if(memb_oper == UNION)
			flag = 999;

		/* The hard part */
		/* XXX flag is the boolean operation */
		i = proc_region( recordp, tsp->ts_mat, flag );

		if( i < 0 )  {
			/* error somwhere */
			(void)printf("Error in converting solid %s to ARBN\n",
				DB_FULL_PATH_CUR_DIR(pathp)->d_namep );
			if(regmemb == 0) {
				regmemb = -1;
			}
			return(-1);		/* ERROR */
		}

		/* if more member solids to be processed, no drawing was done
		 */
		if( regmemb > 0 )
			return(0);		/* NOP -- more to come */

		i = finish_region( &vhead );
		if( i < 0 )  {
			(void)printf("error in finish_region()\n");
			return(-1);		/* ERROR */
		}
		drawH_part2( 0, vhead.vh_first, pathp, tsp );
	}  else  {
		/* Doing a normal solid */

		dashflag = (tsp->ts_sofar & (TS_SOFAR_MINUS|TS_SOFAR_INTER) );

		if( rt_functab[id].ft_plot( recordp, tsp->ts_mat, &vhead,
		    DB_FULL_PATH_CUR_DIR(pathp) ) < 0 )  {
			printf("%s: vector conversion failure\n",
				DB_FULL_PATH_CUR_DIR(pathp)->d_namep );
		}
		drawH_part2( dashflag, vhead.vh_first, pathp, tsp );
	}
	return(1);		/* OK */
}

drawH_part2( dashflag, vfirst, pathp, tsp )
d422 1
d429 8
a436 7
	GET_SOLID( sp );

	/* Take note of the base color */
	if( tsp )  {
		sp->s_basecolor[0] = tsp->ts_mater.ma_color[0] * 255.;
		sp->s_basecolor[1] = tsp->ts_mater.ma_color[1] * 255.;
		sp->s_basecolor[2] = tsp->ts_mater.ma_color[2] * 255.;
d439 1
d448 1
d461 2
a462 2
	 * If this solid is not illuminated, fill in it's information.
	 * A solid might be illuminated yet vectorized again by redraw().
d464 7
a470 1
	if( sp != illump )  {
d486 1
a487 1
	sp->s_regionid = tsp->ts_regionid;
d505 1
a505 1
	if( sp != illump )  {
d510 1
a510 1
		/* replacing illuminated solid -- struct already linked in */
d568 9
a576 3
 *  			R E D R A W
 *  
 *  Probably misnamed.
d578 3
a580 5
struct solid *
redraw( sp, recp, mat )
struct solid *sp;
union record *recp;
mat_t	mat;
d582 2
a583 1
	int addr, bytes;
d585 14
a598 2
	if( sp == SOLID_NULL )
		return( sp );
d600 21
a620 1
/* XXX This is really broken!! */
d622 13
d639 6
a644 11
	if( drawHsolid(
		sp,
		sp->s_soldash,
		sp->s_last,
		mat,
		recp,
		sp->s_regionid,
		(struct mater_info *)0
	) != 1 )  {
		(void)printf("redraw():  error in drawHsolid()\n");
		return(sp);
d647 8
a654 2
	/* Release previous chunk of displaylist, and rewrite control list */
	memfree( &(dmp->dmr_map), (unsigned)bytes, (unsigned long)addr );
d656 1
a656 1
	return( sp );
@


9.5
log
@Made some improvements to calling sequence for big-E.
proc_reg() is now proc_region(), with finish_region().
@
text
@d2 3
d8 1
a8 2
 *	drawtree	Call drawHobj to draw a tree
 *	drawHobj	Call drawsolid for all solids in an object
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.4 90/03/14 21:21:33 mike Locked $ (BRL)";
d40 2
a43 1
int	reg_error;	/* error encountered in region processing */
a50 2
struct directory	*cur_path[MAX_PATH];	/* Record of current path */

d60 25
a84 1
 *			D R A W T R E E
d86 1
a86 1
 *  This routine is the analog of rt_gettree().
d88 4
a91 3
void
drawtree( dp )
struct directory	*dp;
d93 1
a93 9
	mat_t		root;
	struct mater_info	root_mater;

	root_mater = mged_no_mater;	/* struct copy */

	mat_idn( root );
	/* Could apply root animations here ? */

	drawHobj( dp, ROOT, 0, root, 0, &root_mater );
d97 1
a97 1
 *			D R A W H O B J
d99 1
a99 3
 * This routine is used to get an object drawn.
 * The actual drawing of solids is performed by drawsolid(),
 * but all transformations down the path are done here.
d101 5
a105 8
void
drawHobj( dp, flag, pathpos, old_xlate, regionid, materp )
register struct directory *dp;
int		flag;
int		pathpos;
matp_t		old_xlate;
int		regionid;
struct mater_info *materp;
d107 1
a107 4
	union record	*rp;
	auto mat_t	new_xlate;	/* Accumulated translation matrix */
	auto int	i;
	struct mater_info curmater;
d109 5
a113 6
	if( pathpos >= MAX_PATH )  {
		(void)printf("nesting exceeds %d levels\n", MAX_PATH );
		for(i=0; i<MAX_PATH; i++)
			(void)printf("/%s", cur_path[i]->d_namep );
		(void)putchar('\n');
		return;			/* ERROR */
d117 1
a117 1
	 * Load the record into local record buffer
d119 3
a121 2
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
		return;
d123 3
a125 2
	if( rp[0].u_id != ID_COMB )  {
		register struct solid *sp;
d127 2
a128 10
		if( rt_id_solid( rp ) == ID_NULL )  {
			(void)printf("drawobj(%s):  defective database record, type='%c' (0%o) addr=x%x\n",
				dp->d_namep,
				rp[0].u_id, rp[0].u_id, dp->d_addr );
			goto out;		/* ERROR */
		}
		/*
		 * Enter new solid (or processed region) into displaylist.
		 */
		cur_path[pathpos] = dp;
d130 12
a141 8
		GET_SOLID( sp );
		if( sp == SOLID_NULL )
			return;		/* ERROR */
		if( drawHsolid( sp, flag, pathpos, old_xlate, rp, regionid, materp ) != 1 ) {
			FREE_SOLID( sp );
		}
		goto out;
	}
d143 34
a176 8
	/*
	 *  At this point, u_id == ID_COMB.
	 *  Process a Combination (directory) node
	 */
	if( dp->d_len <= 1 )  {
		(void)printf("Warning: combination with zero members \"%s\".\n",
			dp->d_namep );
		goto out;			/* non-fatal ERROR */
d178 2
d181 41
a221 19
	/*
	 *  Handle inheritance of material property.
	 *  Color and the material property have separate
	 *  inheritance interlocks.
	 */
	curmater = *materp;	/* struct copy */
	if( rp[0].c.c_override == 1 )  {
		if( regionid != 0 )  {
			rt_log("rt_drawobj: ERROR: color override in combination within region %s\n",
				dp->d_namep );
		} else {
			if( curmater.ma_cinherit == DB_INH_LOWER )  {
				curmater.ma_override = 1;
				curmater.ma_color[0] = (rp[0].c.c_rgb[0])*rt_inv255;
				curmater.ma_color[1] = (rp[0].c.c_rgb[1])*rt_inv255;
				curmater.ma_color[2] = (rp[0].c.c_rgb[2])*rt_inv255;
				curmater.ma_cinherit = rp[0].c.c_inherit;
			}
		}
d223 7
a229 11
	if( rp[0].c.c_matname[0] != '\0' )  {
		if( regionid != 0 )  {
			rt_log("rt_drawobj: ERROR: material property spec in combination within region %s\n",
				dp->d_namep );
		} else {
			if( curmater.ma_minherit == DB_INH_LOWER )  {
				strncpy( curmater.ma_matname, rp[0].c.c_matname, sizeof(rp[0].c.c_matname) );
				strncpy( curmater.ma_matparm, rp[0].c.c_matparm, sizeof(rp[0].c.c_matparm) );
				curmater.ma_minherit = rp[0].c.c_inherit;
			}
		}
d231 9
d241 27
a267 6
	/* Handle combinations which are the top of a "region" */
	if( rp[0].c.c_flags == 'R' )  {
		if( regionid != 0 )
			(void)printf("regionid %d overriden by %d\n",
				regionid, rp[0].c.c_regionid );
		regionid = rp[0].c.c_regionid;
d270 9
a278 18
	/*
	 *  This node is a combination (eg, a directory).
	 *  Process all the arcs (eg, directory members).
	 */
	if( drawreg && rp[0].c.c_flags == 'R' && dp->d_len > 1 ) {
		if( regmemb >= 0  ) {
			(void)printf(
			"ERROR: region (%s) is member of region (%s)\n",
				dp->d_namep,
				cur_path[reg_pathpos]->d_namep);
			goto out;	/* ERROR */
		}
		/* Well, we are processing regions and this is a region */
		/* if region has only 1 member, don't process as a region */
		if( dp->d_len > 2) {
			regmemb = dp->d_len-1;
			reg_pathpos = pathpos;
		}
d281 3
a283 5
	/* Process all the member records */
	for( i=1; i < dp->d_len; i++ )  {
		register struct member	*mp;
		register struct directory *nextdp;
		static mat_t		xmat;	/* temporary fastf_t matrix */
d285 22
a306 13
		mp = &(rp[i].M);
		if( mp->m_id != ID_MEMB )  {
			fprintf(stderr,"drawHobj:  %s bad member rec\n",
				dp->d_namep);
			goto out;			/* ERROR */
		}
		cur_path[pathpos] = dp;
		if( regmemb > 0  ) { 
			regmemb--;
			memb_oper = mp->m_relation;
		}
		if( (nextdp = db_lookup( dbip,  mp->m_instname, LOOKUP_NOISY )) == DIR_NULL )
			continue;
d308 1
a308 7
		/* s' = M3 . M2 . M1 . s
		 * Here, we start at M3 and descend the tree.
		 * convert matrix to fastf_t from disk format.
		 */
		rt_mat_dbmat( xmat, mp->m_mat );
		/* Check here for animation to apply */
		mat_mul(new_xlate, old_xlate, xmat);
d310 33
a342 9
		/* Recursive call */
		drawHobj(
			nextdp,
			(mp->m_relation != SUBTRACT) ? ROOT : INNER,
			pathpos + 1,
			new_xlate,
			regionid,
			&curmater
		);
d344 2
a345 2
out:
	rt_free( (char *)rp, "drawHobj recs");
d349 12
d365 1
a365 2
 *	 0	if NO OP
 *	 1	if solid was drawn
d368 1
a368 5
drawHsolid( sp, flag, pathpos, xform, recordp, regionid, materp )
register struct solid *sp;
int		flag;
int		pathpos;
matp_t		xform;
d370 3
a372 2
int		regionid;
struct mater_info *materp;
d374 2
a375 4
	register struct vlist *vp;
	register int i;
	int dashflag;		/* draw with dashed lines */
	int count;
a376 1
	vect_t		maxvalue, minvalue;
d380 1
a383 8
		/* reg_error > 0  =>  error condition  no more processing */
		if(reg_error) { 
			if(regmemb == 0) {
				reg_error = 0;
				regmemb = -1;
			}
			return(-1);		/* ERROR */
		}
d388 2
a389 1
		i = proc_region( recordp, xform, flag );
d393 2
a394 3
			(void)printf("will skip region: %s\n",
					cur_path[reg_pathpos]->d_namep);
			reg_error = 1;
a396 1
				reg_error = 0;
a399 1
		reg_error = 0;		/* reset error flag */
d411 1
a411 1
		dashflag = 0;
a413 2
		int id;
		extern int use_nmg_flag;	/* XXX from chgview.c */
d415 1
a415 1
		dashflag = (flag != ROOT);
d417 4
a420 5
		id = rt_id_solid( recordp );
		if( id < 0 || id >= rt_nfunctab )  {
			printf("drawHsolid(%s):  unknown database object\n",
				cur_path[pathpos]->d_namep);
			return(-1);			/* ERROR */
d422 4
d427 10
a436 3
		if( use_nmg_flag )  {
			struct model		*m;
			struct nmgregion	*r;
d438 1
a438 11
			/* Tessellate Solid to NMG region */
			m = nmg_mm();		/* Make model */
			if( rt_functab[id].ft_tessellate( &r, m,
			    recordp, xform, cur_path[pathpos] ) < 0 )  {
				printf("%s: tessellate failure\n", cur_path[pathpos]->d_namep );
			} else {
				/* Convert NMG to vlist */
				NMG_CK_REGION(r);
				/* 0 = vectors, 1 = w/polygon markers */
				nmg_s_to_vlist( &vhead, r->s_p, 1 );
			}
a439 11
			/* Destroy NMG */
			nmg_km( m );
		} else {
			if( rt_functab[id].ft_plot( recordp, xform, &vhead,
			    cur_path[pathpos] ) < 0 )  {
				printf("%s: vector conversion failure\n",
					cur_path[pathpos]->d_namep);
			}
		}
	}

d441 4
a444 4
	if( materp )  {
		sp->s_basecolor[0] = materp->ma_color[0] * 255.;
		sp->s_basecolor[1] = materp->ma_color[1] * 255.;
		sp->s_basecolor[2] = materp->ma_color[2] * 255.;
d452 1
a452 1
	sp->s_vlist = vhead.vh_first;
d454 1
a454 1
	for( vp = vhead.vh_first; vp != VL_NULL; vp = vp->vl_forw )  {
d481 1
a481 1
			sp->s_last = pathpos;
d485 1
a485 1
			sp->s_path[i] = cur_path[i];
d487 1
a487 1
	sp->s_regionid = regionid;
a513 2

	return(1);		/* OK */
d582 2
@


9.4
log
@Changed calling sequence to tessellation routines
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.3 90/02/28 01:55:48 mike Locked $ (BRL)";
d291 1
a291 1
		i = proc_reg( recordp, xform, flag, regmemb, &vhead );
d308 8
a315 2
		if( i > 0 )
			return(0);		/* NOP */
@


9.3
log
@Upgraded NMG stuff for new library.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/mged/RCS/dodraw.c,v 9.2 89/10/10 16:22:51 mike Exp $ (BRL)";
d326 2
a327 1
			struct model	*m;
d329 11
a339 2
			m = nmg_mmr();		/* Make model & region */
			nmg_msv( m->r_p );	/* Make empty shell (& vertex) */
a340 10
			/* Tessellate Solid to NMG */
			rt_functab[id].ft_tessellate(
				m->r_p->s_p,
				recordp, xform,
				cur_path[pathpos] );

			/* Convert NMG to vlist */
			/* 0 = vectors, 1 = w/polygon markers */
			nmg_s_to_vlist( &vhead, m->r_p->s_p, 1 );

d344 5
a348 2
			rt_functab[id].ft_plot( recordp, xform, &vhead,
				cur_path[pathpos] );
@


9.2
log
@Added support for string solid.
Added preliminary support for using NMG & ft_tessellate() to
draw shaded polygons.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 9.1 89/05/19 06:02:57 mike Rel3_5 $ (BRL)";
d272 1
a272 1
	vect_t		max, min;
d328 2
a329 5
			if( (m = nmg_mkmodel()) == (struct model *)0 ||
			    nmg_mkshell( m->r_p ) )  {
			    	printf("nmg_mkmodel or nmg_mkshell failure\n");
			    	return(-1);
			}
d342 1
a342 1
			nmg_kmodel( m );
d359 2
a360 2
	VSETALL( max, -INFINITY );
	VSETALL( min,  INFINITY );
d364 1
a364 1
		VMINMAX( min, max, vp->vl_pnt );
d369 1
a369 1
	VADD2SCALE( sp->s_center, min, max, 0.5 );
d371 3
a373 3
	sp->s_size = max[X] - min[X];
	MAX( sp->s_size, max[Y] - min[Y] );
	MAX( sp->s_size, max[Z] - min[Z] );
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 8.7 89/04/17 17:06:43 mike Exp $ (BRL)";
d32 1
d113 1
a113 4
	if( rp[0].u_id == ID_SOLID ||
	    rp[0].u_id == ID_ARS_A ||
	    rp[0].u_id == ID_BSOLID ||
	    rp[0].u_id == ID_P_HEAD )  {
d115 7
d137 2
a138 1
	 * Process a Combination (directory) node
a139 4
	if( rp[0].u_id != ID_COMB )  {
		(void)printf("drawobj:  defective input '%c'\n", rp[0].u_id );
		goto out;		/* ERROR */
	}
d314 1
d325 25
a349 2
		rt_functab[id].ft_plot( recordp, xform, &vhead,
			cur_path[pathpos] );
@


8.7
log
@RT default is white, MGED default is red.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 8.6 89/04/06 20:39:51 mike Locked $ (BRL)";
@


8.6
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 8.5 89/01/19 22:40:09 mike Locked $ (BRL)";
d50 2
a51 2
	/* RT default is white.  This is grey, to stay clear of illuminate mode */
	0.78, 0.78, 0.78,	/* white/grey, "200". */
@


8.5
log
@While RT default color is white, for MGED it is 200/200/200
to allow full-up white to be used for illuminate mode.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 8.4 89/01/18 01:55:59 mike Locked $ (BRL)";
d33 1
@


8.4
log
@Includes changes in how MGED colors the various solids.
Externally, the color selection now matches that used by RT.
Internally, this was accomplished by adding 3 more fields
to the solid table (s_basecolor[], s_color[], s_dmindex),
and eliminating the mt_dm_int value from the region-id-based
material table.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 8.3 89/01/16 22:56:58 mike Locked $ (BRL)";
d49 2
a50 1
	1.0, 1.0, 1.0,		/* color, RGB */
@


8.3
log
@Absorbed path.c module,
accepted redraw() from edsol.c,
began conversion to using colors in the solid table.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 8.2 88/12/06 01:11:45 mike Locked $ (BRL)";
d49 1
a49 1
	1.0, 0.0, 0.0,		/* color, RGB */
d123 1
a123 1
		if( drawHsolid( sp, flag, pathpos, old_xlate, rp, regionid, &curmater ) != 1 ) {
d148 1
a148 1
	if( rp->c.c_override == 1 )  {
d155 4
a158 4
				curmater.ma_color[0] = (rp->c.c_rgb[0])*rt_inv255;
				curmater.ma_color[1] = (rp->c.c_rgb[1])*rt_inv255;
				curmater.ma_color[2] = (rp->c.c_rgb[2])*rt_inv255;
				curmater.ma_cinherit = rp->c.c_inherit;
d162 1
a162 1
	if( rp->c.c_matname[0] != '\0' )  {
d168 3
a170 3
				strncpy( curmater.ma_matname, rp->c.c_matname, sizeof(rp->c.c_matname) );
				strncpy( curmater.ma_matparm, rp->c.c_matparm, sizeof(rp->c.c_matparm) );
				curmater.ma_minherit = rp->c.c_inherit;
a370 1
	sp->s_materp = (char *)0;
@


8.2
log
@All vector drawing routines moved to librt.
Model is now bounded by an RPP
@
text
@d5 2
d8 2
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/dodraw.c,v 1.3 88/10/29 22:51:07 mike Exp $ (BRL)";
d42 3
a44 1
extern struct directory	*cur_path[MAX_PATH];	/* from path.c */
d46 9
d56 190
d254 8
a261 7
drawHsolid( sp, flag, pathpos, xform, recordp, regionid )
register struct solid *sp;		/* solid structure */
int flag;
int pathpos;
matp_t xform;
union record *recordp;
int regionid;
d324 7
d401 90
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 7.4 88/09/17 02:35:00 reschly Exp $ (BRL)";
d27 1
a29 1
#include "./objdir.h"
d36 1
d103 2
a105 2
	
		switch( recordp->u_id )  {
d107 4
a110 45
		case ID_SOLID:
			switch( recordp->s.s_type )  {

			case GENARB8:
				draw_arb8( &recordp->s, xform, &vhead );
				break;

			case GENTGC:
				draw_tgc( &recordp->s, xform, &vhead );
				break;

			case GENELL:
				draw_ell( &recordp->s, xform, &vhead );
				break;

			case TOR:
				draw_torus( &recordp->s, xform, &vhead );
				break;

			case HALFSPACE:
				draw_half( &recordp->s, xform, &vhead );
				break;

			default:
				(void)printf("draw:  bad SOLID type %d.\n",
					recordp->s.s_type );
				return(-1);		/* ERROR */
			}
			break;

		case ID_ARS_A:
			draw_ars( &recordp->a, cur_path[pathpos], xform, &vhead );
			break;

		case ID_BSOLID:
			draw_spline( &recordp->B, cur_path[pathpos], xform, &vhead );
			break;

		case ID_P_HEAD:
			draw_poly( cur_path[pathpos], xform, &vhead );
			break;

		default:
			(void)printf("draw:  bad database OBJECT type %d\n",
				recordp->u_id );
d113 3
a120 1
#define INFINITY	1.0e20
d129 1
d131 1
a131 4
	VSET( sp->s_center,
		(max[X] + min[X])*0.5,
		(max[Y] + min[Y])*0.5,
		(max[Z] + min[Z])*0.5 );
d176 1
a176 6
	/* Solid is successfully drawn.  Compute maximum. */
	/* This should be done with an RPP instead! XXX */
	MAX( maxview, sp->s_center[X] + sp->s_size );
	MAX( maxview, sp->s_center[Y] + sp->s_size );
	MAX( maxview, sp->s_center[Z] + sp->s_size );

@


7.4
log
@added stdio include.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 7.3 88/02/25 06:07:12 reschly Locked $ (BRL)";
@


7.3
log
@Modified for new vector lists
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 7.2 87/11/05 05:05:35 mike Locked $ (BRL)";
d23 1
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 7.1 87/11/03 00:00:30 mike Rel $ (BRL)";
d31 1
a31 4
extern char	*memcpy();
extern void	perror();
extern char	*malloc();
extern int	printf(), write();
a32 6
#define NVL	5000
static struct veclist veclist[NVL];

struct veclist *vlp;		/* pointer to first free veclist element */
struct veclist *vlend = &veclist[NVL]; /* pntr to 1st inval veclist element */

d55 1
a55 1
	register struct veclist *vp;
d59 2
a60 1
	vect_t	max, min;
d62 1
a62 1
	vlp = &veclist[0];
d79 1
a79 1
		i = proc_reg( recordp, xform, flag, regmemb );
d109 1
a109 1
				draw_arb8( &recordp->s, xform );
d113 1
a113 1
				draw_tgc( &recordp->s, xform );
d117 1
a117 1
				draw_ell( &recordp->s, xform );
d121 1
a121 1
				draw_torus( &recordp->s, xform );
d125 1
a125 1
				draw_half( &recordp->s, xform );
d136 1
a136 1
			draw_ars( &recordp->a, cur_path[pathpos], xform );
d140 1
a140 1
			draw_spline( &recordp->B, cur_path[pathpos], xform );
d144 1
a144 1
			draw_poly( cur_path[pathpos], xform );
a154 1
	 * The vector list is now safely stored in veclist[].
d157 1
a157 1
#define INFINITY	100000000.0
d160 3
a162 1
	for( vp = &veclist[0]; vp < vlp; vp++ )  {
d164 1
d166 1
a175 10
	/* Make a private copy of the vector list */
	sp->s_vlen = vlp - &veclist[0];		/* # of structs */
	count = sp->s_vlen * sizeof(struct veclist);
	if( (sp->s_vlist = (struct veclist *)malloc((unsigned)count)) == VLIST_NULL )  {
		no_memory = 1;
		(void)printf("draw: malloc error\n");
		return(-1);		/* ERROR */
	}
	(void)memcpy( (char *)sp->s_vlist, (char *)veclist, count );

d216 1
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 6.1 87/07/11 08:03:42 mike Rel $ (BRL)";
d23 1
a23 1
#include "./machine.h"	/* special copy */
d68 1
a68 2
	static float xmax, ymax, zmax;
	static float xmin, ymin, zmin;
d167 2
a168 2
	xmax = ymax = zmax = -INFINITY;
	xmin = ymin = zmin =  INFINITY;
d170 1
a170 6
		MIN( xmin, vp->vl_pnt[X] );
		MAX( xmax, vp->vl_pnt[X] );
		MIN( ymin, vp->vl_pnt[Y] );
		MAX( ymax, vp->vl_pnt[Y] );
		MIN( zmin, vp->vl_pnt[Z] );
		MAX( zmax, vp->vl_pnt[Z] );
d173 3
a175 1
		(xmax + xmin)/2, (ymax + ymin)/2, (zmax + zmin)/2 );
d177 3
a179 3
	sp->s_size = xmax - xmin;
	MAX( sp->s_size, ymax - ymin );
	MAX( sp->s_size, zmax - zmin );
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 5.1 87/06/24 22:20:20 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 4.2 87/02/13 00:07:21 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 4.1 86/12/29 03:21:18 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.13 86/08/13 00:07:40 mike Exp $ (BRL)";
@


2.13
log
@Converted from BSD42 to BSD and SYSV defines to select UNIX type.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.12 86/08/12 06:49:16 mike Exp $ (BRL)";
@


2.12
log
@Changed #includes for CC -I../h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.11 86/07/18 02:37:08 mike Exp $ (BRL)";
d31 1
a31 7
#ifdef BSD42
extern void bcopy();
#define	memcpy(to,from,cnt)	bcopy(from,to,cnt)
#else
extern char *memcpy();
#endif

@


2.11
log
@Modified to include halfspace.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.10 86/03/14 20:41:59 mike Exp $ (BRL)";
d24 6
a29 6
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "solid.h"
#include "objdir.h"
#include "dm.h"
@


2.10
log
@Added support for the new spline format.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.9 85/09/27 22:14:52 mike Exp $ (BRL)";
d136 5
a140 1
				draw_tor( &recordp->s, xform );
@


2.9
log
@Fixed bug where solid being drawn when displaylist runs out
was not entered into solid table.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.8 85/09/25 14:27:18 mike Exp $ (BRL)";
d150 2
a151 2
		case ID_B_SPL_HEAD:
			draw_spline( &recordp->a, cur_path[pathpos], xform );
@


2.8
log
@Increased max vector list size, to accomodate polygon objects.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.7 85/09/14 05:36:07 mike Exp $ (BRL)";
d230 3
a232 1
			return(-1);		/* ERROR */
a233 1
		sp->s_bytes = dmp->dmr_load( sp->s_addr, sp->s_bytes );
@


2.7
log
@Lint-inspired cleanup.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.6 85/08/07 05:18:36 mike Exp $ (BRL)";
d42 1
a42 1
#define NVL	2000
@


2.6
log
@Changed to use common ../h/vmath.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.5 85/03/22 10:53:30 mike Exp $ (BRL)";
d51 2
d99 1
a99 1
					path[reg_pathpos]->d_namep);
d147 1
a147 1
			draw_ars( &recordp->a, path[pathpos], xform );
d151 1
a151 1
			draw_spline( &recordp->a, path[pathpos], xform );
d155 1
a155 1
			draw_poly( path[pathpos], xform );
d216 1
a216 1
			sp->s_path[i] = path[i];
@


2.5
log
@symbolic viewchange params
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.4 85/03/15 05:05:01 mike Exp $ (BRL)";
d23 2
a24 1
#include "ged_types.h"
a28 1
#include "../h/vmath.h"
@


2.4
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.3 85/03/13 06:08:42 mike Exp $ (BRL)";
d216 1
d241 1
a241 1
		dmp->dmr_viewchange( 1, sp );		/* ADD solid */
d245 1
a245 1
		dmp->dmr_viewchange( 3, sp );		/* REPLACE solid */
@


2.3
log
@Fixed code ordering to not enroll solid structure on queue
until after all checking is complete.  (Ryan bug).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.2 85/03/12 04:06:18 mike Exp $ (BRL)";
d60 1
a60 1
drawHsolid( sp, flag, pathpos, xform, recordp )
d66 1
d216 3
d221 1
a221 3
	sp->s_addr = 0;
	if( (sp->s_bytes = dmp->dmr_cvtvecs( sp )) != 0 )  {

@


2.2
log
@Paul Stay's Spline code
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 2.1 85/03/11 23:55:44 mike Prod $ (BRL)";
d194 4
a197 1
	/* set solid/dashed line flag */
a213 8

		/* Add to linked list of solid structs */
		APPEND_SOLID( sp, HeadSolid.s_back );
		dmp->dmr_viewchange( 1, sp );		/* ADD solid */
	} else {
		/* replacing illuminated solid -- struct already linked in */
		sp->s_iflag = UP;
		dmp->dmr_viewchange( 3, sp );		/* REPLACE solid */
d217 1
a227 3
	} else {
		sp->s_addr = 0;
		sp->s_bytes = 0;
d230 1
a230 1
	/* Compute maximum */
d234 10
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 1.10 85/02/01 03:23:42 mike Exp $ (BRL)";
d145 4
@


1.10
log
@Reordered code to set dashed flag before generating displaylist (!).
@
text
@d7 4
a10 1
 * Source -
d14 4
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 1.9 85/01/19 04:06:40 mike Exp $ (BRL)";
d24 1
a24 1
#include "db.h"
d27 2
a28 2
#include "dir.h"
#include "vmath.h"
d30 1
d39 1
d42 1
a42 1
#define NVL	1000
d183 1
a183 1
	if( (sp->s_vlist = (struct veclist *)malloc(count)) == VLIST_NULL )  {
d185 1
a185 1
		printf("draw: malloc error\n");
d210 1
d214 1
d218 1
a218 1
	if( (sp->s_bytes = dmp->dmr_cvtvecs( sp )) > 0 )  {
a239 32

#ifdef never
/*
 *			M R E A D
 *
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This KLUDGE is necessary because pipes
 * may not return any more than 512 characters on a single read.
 */
static int
mread(fd, bufp, n)
int fd;
register char	*bufp;
unsigned	n;
{
	register unsigned	count = 0;
	register int		nread;

	do {
		nread = read(fd, bufp, n-count);
		if(nread == -1)
			return(nread);
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}
#endif
@


1.9
log
@Fixed problem with dmr_cvtvecs() returning 0,
for devices without displaylist.
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 1.8 85/01/17 07:28:57 mike Exp $ (BRL)";
a180 16
	/* Cvt to displaylist, determine displaylist memory requirement. */
	if( (sp->s_bytes = dmp->dmr_cvtvecs( sp )) > 0 )  {

		/* Allocate displaylist storage for object */
		sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
		if( sp->s_addr == 0 )  {
			no_memory = 1;
			(void)printf("draw: out of Displaylist\n");
			return(-1);		/* ERROR */
		}
		sp->s_bytes = dmp->dmr_load( sp->s_addr, sp->s_bytes );
	} else {
		sp->s_addr = 0;
		sp->s_bytes = 0;
	}

d204 16
@


1.8
log
@
Latest stuff
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 1.7 85/01/16 03:03:38 mike Exp $ (BRL)";
d182 1
a182 1
	sp->s_bytes = dmp->dmr_cvtvecs( sp );
d184 11
a194 6
	/* Allocate displaylist storage for object */
	sp->s_addr = memalloc( &(dmp->dmr_map), sp->s_bytes );
	if( sp->s_addr == 0 )  {
		no_memory = 1;
		(void)printf("draw: out of Displaylist\n");
		return(-1);		/* ERROR */
a195 1
	sp->s_bytes = dmp->dmr_load( sp->s_addr, sp->s_bytes );
@


1.7
log
@Fixes from Keith to have draw_*() make local copy of solid struct.
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 1.5 84/11/22 06:56:32 mike Exp $ (BRL)";
d182 1
a182 2
	sp->s_bytes = dmp->dmr_cvtvecs( sp->s_vlist,
		sp->s_center, sp->s_size, dashflag, sp->s_vlen );
@


1.6
log
@pre-Keith version
@
text
@d116 1
a116 1
				draw_tgc( recordp->s.s_values, xform );
d120 1
a120 1
				draw_ell( recordp->s.s_values, xform );
d124 1
a124 1
				draw_tor( recordp->s.s_values, xform );
@


1.5
log
@Multiple simultaneous display manager support
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: dodraw.c,v 1.4 84/11/20 04:23:54 mike Exp $ (BRL)";
d17 1
a17 1
#include "3d.h"
a64 4
	if( recordp->u_id != ID_SOLID )  {
		printf("dodraw: non-solid, id=%c\n", recordp->u_id );
		return(-1);	/* ERROR */
	}
@


1.4
log
@Vector lists saved, multiple display managers supported.
@
text
@a5 1
 *	freevgcore	De-allocate display processor memory
d13 1
a13 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d186 2
a187 2
	sp->s_bytes = dmp->dmr_cvtvecs( &veclist[0],
		sp->s_center, sp->s_size, dashflag );
d190 1
a190 1
	sp->s_addr = memalloc( sp->s_bytes );
a229 19

/*
 *			F R E E V G C O R E
 *
 * This routine is used to recycle displaylist memory.
 */
void
freevgcore( addr, bytes )
unsigned	addr;
unsigned	bytes;
{
	memfree( bytes, addr );

	/* reset memory used up flag */
	no_memory = 0;
	return;		/* OK */
}


@


1.3
log
@Better interface between drawHsolid and proc_reg
@
text
@d7 5
a11 3
 *
 *	Ballistic Research Laboratory
 *	U. S. Army
d13 3
a22 1
#include "commo.h"
d24 6
d34 2
a35 1
#define MAX(a,b)	if( (b) > (a) )  a = b
d37 2
a38 1
struct commi	commi;		/* Structure to be rcvd from GED2 */
d59 1
d61 4
d70 1
a97 1
			commi.i_type = MS_DRAW;
d106 1
a106 10

		/* See if write to display memory succeeded */
		if( commi.i_size == 0 )  {
			no_memory = 1;
			return(-1);		/* ERROR */
		}
		sp->s_addr = commi.i_addr;
		sp->s_bytes = commi.i_size;
		VMOVE( sp->s_center, commi.i_center );
		sp->s_size = commi.i_scale;
d109 1
a109 1
		dmp->dmr_Spreamble( flag == ROOT );
d152 1
d154 17
a170 2
		/* Finish off the display subroutine */
		dmp->dmr_Sepilogue();
d172 3
a174 5
		sp->s_center[X] = dl_xcent;
		sp->s_center[Y] = dl_ycent;
		sp->s_center[Z] = dl_zcent;
		sp->s_center[H] = 1;
		sp->s_size = dl_scale;
d176 9
a184 2
		/* Determine displaylist memory requirement */
		sp->s_bytes = dmp->dmr_size();
d186 10
a195 8
		/* Allocate displaylist storage for object */
		sp->s_addr = memalloc( sp->s_bytes );
		if( sp->s_addr == 0 )  {
			no_memory = 1;
			(void)printf("draw: out of Displaylist\n");
			return(-1);		/* ERROR */
		}
		sp->s_bytes = dmp->dmr_load( sp->s_addr, sp->s_bytes );
d197 1
d202 1
a202 1
		sp->s_soldash = flag;
@


1.2
log
@Minor cleanups
@
text
@d2 1
a2 1
 *			D R A W S O L . C
d5 2
a6 2
 *	drawHsolid	Draw a COMGEOM solid for the VG
 *	freevgcore	De-allocate VG core
a25 2
struct commo	commo;		/* Structure to be sent to GED2 */

d49 4
a64 3
		commo.o_flag = flag;
		commo.o_more = regmemb;		/* members left to process */
		commo.o_pos = memb_loc;		/* disk loc. of this member */
d66 1
a66 1
			commo.o_flag = 999;
a67 2
		mat_copy( commo.o_mat, xform );

d69 1
a69 1
		proc_reg( path[reg_pathpos], xform, flag );
d71 1
a71 1
		if(commi.i_type == MS_ERROR) {
d85 1
a85 2
		/* if type == MS_MORE  then more member solids to be processed
		 *    so no drawing was done
d87 1
a87 1
		if(commi.i_type == MS_MORE)
d101 1
a101 1
		dl_preamble( flag == ROOT );
d146 1
a146 1
		dl_epilogue();
d155 1
a155 1
		sp->s_bytes = dl_size();
d164 1
a164 1
		sp->s_bytes = dl_load( sp->s_addr, sp->s_bytes );
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
#include "ged2.h"
@
