head	11.226;
access;
symbols
	ansi-20040405-merged:11.215.2.3
	postmerge-20040405-ansi:11.222
	premerge-20040404-ansi:11.221
	postmerge-autoconf:11.221
	autoconf-freeze:11.218.6.3
	premerge-autoconf:11.221
	postmerge-20040315-windows:11.221
	premerge-20040315-windows:11.219
	windows-20040315-freeze:11.215.4.4
	autoconf-20031203:11.218
	autoconf-20031202:11.218
	autoconf-branch:11.218.0.6
	phong-branch:11.218.0.4
	photonmap-branch:11.218.0.2
	rel-6-1-DP:11.215
	windows-branch:11.215.0.4
	rel-6-0-2:11.212
	ansi-branch:11.215.0.2
	rel-6-0-1-branch:11.212.0.2
	hartley-6-0-post:11.214
	hartley-6-0-pre:11.213
	rel-6-0-1:11.212
	rel-6-0:11.212
	rel-5-4:11.181.2.8
	offsite-5-3-pre:11.199
	rel-5-3:11.181.2.8
	rel-5-2:11.181.2.1
	rel-5-1-branch:11.181.0.2
	rel-5-1:11.181
	rel-5-0:11.169
	rel-5-0-beta:11.162
	rel-4-5:11.130
	ctj-4-5-post:11.99
	ctj-4-5-pre:11.99
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1
	rt-2:2.9;
locks; strict;
comment	@ * @;


11.226
date	2004.05.21.17.47.43;	author morrison;	state dead;
branches;
next	11.225;

11.225
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.224;

11.224
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	11.223;

11.223
date	2004.04.22.12.11.36;	author jra;	state Exp;
branches;
next	11.222;

11.222
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.221;

11.221
date	2004.03.17.02.14.06;	author morrison;	state Exp;
branches;
next	11.220;

11.220
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	11.219;

11.219
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.218;

11.218
date	2003.04.01.13.56.13;	author jra;	state Exp;
branches
	11.218.6.1;
next	11.217;

11.217
date	2003.03.26.03.45.46;	author jra;	state Exp;
branches;
next	11.216;

11.216
date	2003.03.13.19.46.50;	author jra;	state Exp;
branches;
next	11.215;

11.215
date	2002.08.20.17.08.23;	author jra;	state Exp;
branches
	11.215.2.1
	11.215.4.1;
next	11.214;

11.214
date	2002.08.15.20.55.35;	author hartley;	state Exp;
branches;
next	11.213;

11.213
date	2002.08.12.18.25.38;	author morrison;	state Exp;
branches;
next	11.212;

11.212
date	2001.12.12.18.45.32;	author bparker;	state Exp;
branches;
next	11.211;

11.211
date	2001.10.17.07.40.05;	author morrison;	state Exp;
branches;
next	11.210;

11.210
date	2001.10.05.21.22.02;	author bparker;	state Exp;
branches;
next	11.209;

11.209
date	2001.10.04.16.01.32;	author bparker;	state Exp;
branches;
next	11.208;

11.208
date	2001.10.04.15.40.55;	author bparker;	state Exp;
branches;
next	11.207;

11.207
date	2001.08.11.13.16.11;	author butler;	state Exp;
branches;
next	11.206;

11.206
date	2001.06.05.15.51.41;	author bparker;	state Exp;
branches;
next	11.205;

11.205
date	2001.06.01.19.23.24;	author bparker;	state Exp;
branches;
next	11.204;

11.204
date	2001.04.20.20.08.58;	author bparker;	state Exp;
branches;
next	11.203;

11.203
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	11.202;

11.202
date	2001.03.31.01.57.23;	author morrison;	state Exp;
branches;
next	11.201;

11.201
date	2001.03.22.14.32.58;	author bparker;	state Exp;
branches;
next	11.200;

11.200
date	2001.03.21.20.14.14;	author bparker;	state Exp;
branches;
next	11.199;

11.199
date	2001.02.23.20.24.38;	author bparker;	state Exp;
branches;
next	11.198;

11.198
date	2001.02.16.22.43.43;	author bparker;	state Exp;
branches;
next	11.197;

11.197
date	2000.11.16.21.20.29;	author bparker;	state Exp;
branches;
next	11.196;

11.196
date	2000.11.09.23.27.56;	author bparker;	state Exp;
branches;
next	11.195;

11.195
date	2000.11.03.19.25.21;	author bparker;	state Exp;
branches;
next	11.194;

11.194
date	2000.11.03.18.08.46;	author bparker;	state Exp;
branches;
next	11.193;

11.193
date	2000.11.01.20.37.47;	author mike;	state Exp;
branches;
next	11.192;

11.192
date	2000.10.24.19.46.02;	author mike;	state Exp;
branches;
next	11.191;

11.191
date	2000.09.14.20.05.58;	author bparker;	state Exp;
branches;
next	11.190;

11.190
date	2000.09.08.14.34.10;	author bparker;	state Exp;
branches;
next	11.189;

11.189
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	11.188;

11.188
date	2000.09.07.02.58.52;	author mike;	state Exp;
branches;
next	11.187;

11.187
date	2000.09.06.20.54.16;	author mike;	state Exp;
branches;
next	11.186;

11.186
date	2000.08.19.03.10.46;	author mike;	state Exp;
branches;
next	11.185;

11.185
date	2000.08.09.20.40.41;	author bparker;	state Exp;
branches;
next	11.184;

11.184
date	2000.07.24.22.22.12;	author mike;	state Exp;
branches;
next	11.183;

11.183
date	2000.07.24.19.27.31;	author mike;	state Exp;
branches;
next	11.182;

11.182
date	2000.07.20.23.25.56;	author mike;	state Exp;
branches;
next	11.181;

11.181
date	2000.06.23.06.46.23;	author mike;	state Exp;
branches
	11.181.2.1;
next	11.180;

11.180
date	2000.02.22.21.21.07;	author bparker;	state Exp;
branches;
next	11.179;

11.179
date	2000.02.01.20.17.56;	author mike;	state Exp;
branches;
next	11.178;

11.178
date	2000.01.20.18.51.47;	author bparker;	state Exp;
branches;
next	11.177;

11.177
date	2000.01.07.04.21.20;	author mike;	state Exp;
branches;
next	11.176;

11.176
date	2000.01.04.15.32.41;	author bparker;	state Exp;
branches;
next	11.175;

11.175
date	99.12.30.19.11.38;	author jra;	state Exp;
branches;
next	11.174;

11.174
date	99.12.29.23.23.23;	author mike;	state Exp;
branches;
next	11.173;

11.173
date	99.10.26.21.33.04;	author bparker;	state Exp;
branches;
next	11.172;

11.172
date	99.10.22.21.37.09;	author bparker;	state Exp;
branches;
next	11.171;

11.171
date	99.10.12.19.41.51;	author bparker;	state Exp;
branches;
next	11.170;

11.170
date	99.10.08.21.42.30;	author bparker;	state Exp;
branches;
next	11.169;

11.169
date	99.09.09.19.35.24;	author bparker;	state Exp;
branches;
next	11.168;

11.168
date	99.09.08.14.31.29;	author bparker;	state Exp;
branches;
next	11.167;

11.167
date	99.09.01.18.55.10;	author bparker;	state Exp;
branches;
next	11.166;

11.166
date	99.08.16.14.44.14;	author bparker;	state Exp;
branches;
next	11.165;

11.165
date	99.07.26.15.28.03;	author bparker;	state Exp;
branches;
next	11.164;

11.164
date	99.07.08.19.01.24;	author bparker;	state Exp;
branches;
next	11.163;

11.163
date	99.06.11.17.52.59;	author bparker;	state Exp;
branches;
next	11.162;

11.162
date	99.04.16.17.58.01;	author bparker;	state Exp;
branches;
next	11.161;

11.161
date	99.04.13.19.36.40;	author bparker;	state Exp;
branches;
next	11.160;

11.160
date	99.04.12.21.40.39;	author bparker;	state Exp;
branches;
next	11.159;

11.159
date	99.04.07.16.44.01;	author bparker;	state Exp;
branches;
next	11.158;

11.158
date	99.03.30.19.58.58;	author bparker;	state Exp;
branches;
next	11.157;

11.157
date	99.03.30.19.46.50;	author bparker;	state Exp;
branches;
next	11.156;

11.156
date	99.03.29.19.50.01;	author bparker;	state Exp;
branches;
next	11.155;

11.155
date	99.03.18.18.03.18;	author bparker;	state Exp;
branches;
next	11.154;

11.154
date	99.03.11.18.26.01;	author bparker;	state Exp;
branches;
next	11.153;

11.153
date	99.01.27.14.37.48;	author bparker;	state Exp;
branches;
next	11.152;

11.152
date	99.01.25.18.14.35;	author bparker;	state Exp;
branches;
next	11.151;

11.151
date	99.01.21.18.31.21;	author bparker;	state Exp;
branches;
next	11.150;

11.150
date	99.01.12.18.15.57;	author bparker;	state Exp;
branches;
next	11.149;

11.149
date	98.12.29.20.37.19;	author bparker;	state Exp;
branches;
next	11.148;

11.148
date	98.12.15.15.55.32;	author bparker;	state Exp;
branches;
next	11.147;

11.147
date	98.11.06.21.48.21;	author bparker;	state Exp;
branches;
next	11.146;

11.146
date	98.10.22.18.47.03;	author bparker;	state Exp;
branches;
next	11.145;

11.145
date	98.10.21.19.07.54;	author bparker;	state Exp;
branches;
next	11.144;

11.144
date	98.10.21.17.24.06;	author bparker;	state Exp;
branches;
next	11.143;

11.143
date	98.08.13.11.56.29;	author bparker;	state Exp;
branches;
next	11.142;

11.142
date	98.06.24.17.17.40;	author bparker;	state Exp;
branches;
next	11.141;

11.141
date	98.06.16.18.13.26;	author bparker;	state Exp;
branches;
next	11.140;

11.140
date	98.06.12.19.46.20;	author bparker;	state Exp;
branches;
next	11.139;

11.139
date	98.06.11.19.41.45;	author bparker;	state Exp;
branches;
next	11.138;

11.138
date	98.06.11.14.28.12;	author bparker;	state Exp;
branches;
next	11.137;

11.137
date	98.05.18.19.35.10;	author bparker;	state Exp;
branches;
next	11.136;

11.136
date	98.05.07.15.38.56;	author bparker;	state Exp;
branches;
next	11.135;

11.135
date	98.03.19.18.06.29;	author bparker;	state Exp;
branches;
next	11.134;

11.134
date	98.03.06.22.40.17;	author bparker;	state Exp;
branches;
next	11.133;

11.133
date	98.03.03.15.49.03;	author pjt;	state Exp;
branches;
next	11.132;

11.132
date	98.02.26.16.06.46;	author bparker;	state Exp;
branches;
next	11.131;

11.131
date	98.02.20.23.13.24;	author bparker;	state Exp;
branches;
next	11.130;

11.130
date	98.02.05.22.55.31;	author bparker;	state Exp;
branches;
next	11.129;

11.129
date	98.01.28.16.04.30;	author bparker;	state Exp;
branches;
next	11.128;

11.128
date	98.01.16.22.02.38;	author bparker;	state Exp;
branches;
next	11.127;

11.127
date	97.12.23.14.01.51;	author bparker;	state Exp;
branches;
next	11.126;

11.126
date	97.12.16.00.52.21;	author mike;	state Exp;
branches;
next	11.125;

11.125
date	97.12.16.00.51.26;	author mike;	state Exp;
branches;
next	11.124;

11.124
date	97.12.09.13.46.10;	author bparker;	state Exp;
branches;
next	11.123;

11.123
date	97.11.12.22.01.11;	author bparker;	state Exp;
branches;
next	11.122;

11.122
date	97.11.06.20.00.55;	author bparker;	state Exp;
branches;
next	11.121;

11.121
date	97.11.06.13.17.59;	author jra;	state Exp;
branches;
next	11.120;

11.120
date	97.11.03.15.13.22;	author bparker;	state Exp;
branches;
next	11.119;

11.119
date	97.10.10.21.05.54;	author bparker;	state Exp;
branches;
next	11.118;

11.118
date	97.10.01.20.34.40;	author bparker;	state Exp;
branches;
next	11.117;

11.117
date	97.10.01.19.17.09;	author jra;	state Exp;
branches;
next	11.116;

11.116
date	97.10.01.19.10.01;	author bparker;	state Exp;
branches;
next	11.115;

11.115
date	97.09.08.18.08.44;	author bparker;	state Exp;
branches;
next	11.114;

11.114
date	97.08.22.22.38.22;	author mike;	state Exp;
branches;
next	11.113;

11.113
date	97.08.22.22.32.14;	author mike;	state Exp;
branches;
next	11.112;

11.112
date	97.08.20.19.23.33;	author jra;	state Exp;
branches;
next	11.111;

11.111
date	97.07.28.19.58.21;	author bparker;	state Exp;
branches;
next	11.110;

11.110
date	97.07.25.20.46.18;	author bparker;	state Exp;
branches;
next	11.109;

11.109
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.108;

11.108
date	97.06.25.02.58.35;	author mike;	state Exp;
branches;
next	11.107;

11.107
date	97.06.25.00.47.01;	author mike;	state Exp;
branches;
next	11.106;

11.106
date	97.06.25.00.16.37;	author mike;	state Exp;
branches;
next	11.105;

11.105
date	97.06.20.02.43.27;	author gdurf;	state Exp;
branches;
next	11.104;

11.104
date	97.06.20.02.01.40;	author gdurf;	state Exp;
branches;
next	11.103;

11.103
date	97.06.14.03.34.15;	author gdurf;	state Exp;
branches;
next	11.102;

11.102
date	97.06.14.02.40.21;	author gdurf;	state Exp;
branches;
next	11.101;

11.101
date	97.06.14.02.30.10;	author gdurf;	state Exp;
branches;
next	11.100;

11.100
date	97.06.14.02.24.25;	author gdurf;	state Exp;
branches;
next	11.99;

11.99
date	97.06.03.16.03.59;	author pjt;	state Exp;
branches;
next	11.98;

11.98
date	97.05.29.14.14.00;	author bparker;	state Exp;
branches;
next	11.97;

11.97
date	97.05.22.03.55.16;	author mike;	state Exp;
branches;
next	11.96;

11.96
date	97.05.22.03.46.16;	author mike;	state Exp;
branches;
next	11.95;

11.95
date	97.05.21.12.56.00;	author bparker;	state Exp;
branches;
next	11.94;

11.94
date	97.05.09.21.00.10;	author bparker;	state Exp;
branches;
next	11.93;

11.93
date	97.05.08.14.28.38;	author bparker;	state Exp;
branches;
next	11.92;

11.92
date	97.04.29.12.43.40;	author bparker;	state Exp;
branches;
next	11.91;

11.91
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.90;

11.90
date	97.04.18.12.30.01;	author bparker;	state Exp;
branches;
next	11.89;

11.89
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.88;

11.88
date	97.04.09.20.35.52;	author bparker;	state Exp;
branches;
next	11.87;

11.87
date	97.04.07.19.40.02;	author bparker;	state Exp;
branches;
next	11.86;

11.86
date	97.04.04.19.53.18;	author bparker;	state Exp;
branches;
next	11.85;

11.85
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.84;

11.84
date	97.03.20.14.48.43;	author bparker;	state Exp;
branches;
next	11.83;

11.83
date	97.03.07.02.51.55;	author mike;	state Exp;
branches;
next	11.82;

11.82
date	97.03.06.21.35.13;	author bparker;	state Exp;
branches;
next	11.81;

11.81
date	97.02.28.21.30.50;	author bparker;	state Exp;
branches;
next	11.80;

11.80
date	97.02.24.22.06.20;	author bparker;	state Exp;
branches;
next	11.79;

11.79
date	97.02.14.22.09.57;	author bparker;	state Exp;
branches;
next	11.78;

11.78
date	97.02.03.21.46.57;	author bparker;	state Exp;
branches;
next	11.77;

11.77
date	97.01.29.23.13.54;	author bparker;	state Exp;
branches;
next	11.76;

11.76
date	97.01.29.02.26.10;	author mike;	state Exp;
branches;
next	11.75;

11.75
date	97.01.24.20.51.13;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	97.01.10.21.55.09;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	97.01.09.21.46.02;	author mike;	state Exp;
branches;
next	11.71;

11.71
date	97.01.09.20.52.25;	author jra;	state Exp;
branches;
next	11.70;

11.70
date	97.01.09.17.12.01;	author jra;	state Exp;
branches;
next	11.69;

11.69
date	97.01.08.19.43.44;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	97.01.07.22.06.13;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	97.01.07.04.48.24;	author mike;	state Exp;
branches;
next	11.66;

11.66
date	97.01.02.22.12.41;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.64;

11.64
date	96.12.30.22.29.53;	author bparker;	state Exp;
branches;
next	11.63;

11.63
date	96.12.17.22.43.48;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	96.12.13.23.10.54;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	96.12.12.22.10.09;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	96.12.11.22.40.57;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	96.12.04.21.14.43;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	96.11.19.21.18.25;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	96.11.01.22.08.03;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	96.10.03.20.25.01;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	96.10.01.17.23.59;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	96.09.25.20.12.07;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	96.09.23.18.28.16;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	96.09.17.21.18.20;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	96.08.22.20.59.31;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	96.07.25.19.07.26;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	96.07.22.15.53.17;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	96.07.19.21.08.34;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	96.07.15.20.37.18;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	96.07.10.20.19.38;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	96.06.25.20.56.33;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	96.06.21.15.56.06;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	96.06.14.20.11.20;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	96.06.04.20.48.20;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	96.05.24.19.07.22;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.04.03.22.08.55;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.04.01.22.13.12;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.03.25.21.54.50;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.03.22.18.27.28;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.03.11.21.45.12;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.03.01.19.22.13;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.02.12.21.49.08;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.01.17.22.11.57;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	95.12.01.23.06.10;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	95.11.30.22.50.28;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	95.11.28.21.27.59;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	95.11.07.22.56.02;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	95.11.07.14.46.18;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	95.11.03.21.59.22;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	95.10.19.15.01.34;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	95.08.25.20.48.33;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	95.08.25.20.14.08;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	95.08.24.06.19.42;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	95.08.10.21.09.59;	author gdurf;	state Exp;
branches;
next	11.12;

11.12
date	95.08.07.14.35.47;	author gdurf;	state Exp;
branches;
next	11.11;

11.11
date	95.08.03.21.43.38;	author gdurf;	state Exp;
branches;
next	11.10;

11.10
date	95.07.27.17.42.21;	author gdurf;	state Exp;
branches;
next	11.9;

11.9
date	95.07.20.17.00.04;	author gdurf;	state Exp;
branches;
next	11.8;

11.8
date	95.07.06.13.57.10;	author gdurf;	state Exp;
branches;
next	11.7;

11.7
date	95.06.16.21.32.31;	author gdurf;	state Exp;
branches;
next	11.6;

11.6
date	95.06.15.20.22.35;	author gdurf;	state Exp;
branches;
next	11.5;

11.5
date	95.02.18.03.08.59;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.01.17.13.04.47;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.01.10.17.12.22;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.09.18.26.23;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.09;	author mike;	state Rel4_4;
branches;
next	10.39;

10.39
date	95.01.04.09.06.48;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	94.12.27.22.58.12;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	94.12.27.16.47.40;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.12.24.01.04.29;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.12.23.23.26.30;	author gdurf;	state Exp;
branches;
next	10.34;

10.34
date	94.12.23.19.36.11;	author gdurf;	state Exp;
branches;
next	10.33;

10.33
date	94.12.16.20.57.03;	author gdurf;	state Exp;
branches;
next	10.32;

10.32
date	94.12.16.17.52.56;	author gdurf;	state Exp;
branches;
next	10.31;

10.31
date	94.12.05.14.54.50;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	94.11.19.01.46.18;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	94.11.05.03.42.20;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.08.24.19.08.43;	author gdurf;	state Exp;
branches;
next	10.27;

10.27
date	94.08.10.23.05.27;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	94.08.10.21.43.04;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.08.09.18.12.44;	author gdurf;	state Exp;
branches;
next	10.24;

10.24
date	94.08.09.11.47.42;	author pjt;	state Exp;
branches;
next	10.23;

10.23
date	94.08.09.10.26.24;	author pjt;	state Exp;
branches;
next	10.22;

10.22
date	94.06.24.20.10.02;	author gdurf;	state Exp;
branches;
next	10.21;

10.21
date	94.06.03.17.28.22;	author gdurf;	state Exp;
branches;
next	10.20;

10.20
date	94.06.01.16.11.20;	author gdurf;	state Exp;
branches;
next	10.19;

10.19
date	94.01.12.02.45.10;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	93.11.05.12.34.34;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	93.11.04.15.16.54;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.07.15.21.26.30;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	92.08.24.19.51.25;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	92.08.21.22.45.57;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	92.04.16.04.07.54;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	92.04.16.01.30.57;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	92.04.16.00.23.03;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	92.04.04.01.10.55;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	92.04.04.00.12.59;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	92.04.03.19.44.38;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.04.03.19.24.08;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.04.03.05.04.56;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.04.03.02.28.33;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.02.05.13.32.01;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	91.12.20.02.21.51;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.11.05.00.02.55;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.43;	author mike;	state Rel4_0;
branches;
next	9.25;

9.25
date	91.10.11.11.32.59;	author butler;	state Exp;
branches;
next	9.24;

9.24
date	91.09.25.08.11.32;	author butler;	state Exp;
branches;
next	9.23;

9.23
date	91.09.05.20.25.04;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.08.28.04.18.06;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.07.26.20.27.48;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.07.23.02.30.48;	author butler;	state Exp;
branches;
next	9.19;

9.19
date	91.07.23.02.26.00;	author butler;	state Exp;
branches;
next	9.18;

9.18
date	91.06.25.16.19.41;	author phil;	state Exp;
branches;
next	9.17;

9.17
date	91.06.25.16.09.11;	author pjt;	state Exp;
branches;
next	9.16;

9.16
date	91.06.23.02.51.11;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.03.02.02.00.29;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.02.28.01.20.33;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.02.27.04.13.47;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.01.29.00.28.14;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.01.26.04.52.59;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.07.05.40.53;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.12.06.15.49.19;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.05.23.00.14.15;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.05.22.16.03.08;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.05.13.12.07.09;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.05.09.20.00.54;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.04.21.06.06.07;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.10.10.16.25.18;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.08.10.21.13.21;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.11;	author mike;	state Rel3_5;
branches;
next	8.11;

8.11
date	89.05.11.21.11.14;	author phil;	state Exp;
branches;
next	8.10;

8.10
date	89.05.08.21.46.15;	author phil;	state Exp;
branches;
next	8.9;

8.9
date	89.04.21.04.52.03;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.04.06.20.18.14;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.03.07.00.02.49;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.03.06.17.40.22;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.16.22.55.32;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.01.09.05.08.58;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.06.01.24.23;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.04.58.45;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.36.52;	author mike;	state Rel3_0;
branches;
next	7.9;

7.9
date	88.09.17.04.52.03;	author mike;	state Exp;
branches;
next	7.8;

7.8
date	88.09.17.03.49.55;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.09.17.03.44.41;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.09.17.02.32.14;	author reschly;	state Exp;
branches;
next	7.5;

7.5
date	88.07.22.01.57.38;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.01.13.16.38.18;	author stay;	state Exp;
branches;
next	7.3;

7.3
date	87.11.05.07.04.49;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.09;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.00.56;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.08;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.20.54;	author mike;	state Rel;
branches;
next	4.7;

4.7
date	87.06.17.23.48.45;	author phil;	state Exp;
branches;
next	4.6;

4.6
date	87.06.16.05.17.10;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.06.13.06.14.24;	author phil;	state Exp;
branches;
next	4.4;

4.4
date	87.05.29.00.44.23;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.13.00.07.46;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.02.13.37.35;	author mike;	state Rel1;
branches;
next	4.1;

4.1
date	86.12.29.03.21.48;	author mike;	state Rel1;
branches;
next	2.17;

2.17
date	86.10.26.14.09.06;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	86.09.23.01.48.16;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	86.09.10.01.35.11;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	86.08.14.22.22.28;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	86.08.13.07.33.08;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.08.13.00.07.59;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	86.08.12.06.49.44;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.06.20.01.31.02;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.08.07.05.19.05;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.06.03.16.49.14;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.05.29.23.17.23;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.05.10.00.54.31;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.05.03.01.39.53;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.02.23.27.30;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.28.22.25.10;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.05.26.00;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.56.15;	author mike;	state Prod;
branches;
next	1.13;

1.13
date	85.03.08.20.53.56;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	85.02.14.00.42.50;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	85.02.14.00.29.06;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	85.02.05.21.58.01;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.02.05.04.18.04;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.02.01.00.50.47;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.01.17.07.29.19;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.01.16.19.12.37;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.01.16.03.26.11;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.01.58.05;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.20.04.24.38;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.17.05.37.37;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.51.25;	author mike;	state Exp;
branches;
next	;

11.181.2.1
date	2000.08.30.17.22.13;	author bparker;	state Exp;
branches;
next	11.181.2.2;

11.181.2.2
date	2000.09.14.20.05.12;	author bparker;	state Exp;
branches;
next	11.181.2.3;

11.181.2.3
date	2000.11.03.17.58.48;	author bparker;	state Exp;
branches;
next	11.181.2.4;

11.181.2.4
date	2000.11.03.19.24.00;	author bparker;	state Exp;
branches;
next	11.181.2.5;

11.181.2.5
date	2000.11.09.21.24.26;	author bparker;	state Exp;
branches;
next	11.181.2.6;

11.181.2.6
date	2000.11.15.21.31.19;	author bparker;	state Exp;
branches;
next	11.181.2.7;

11.181.2.7
date	2001.02.09.15.26.31;	author bparker;	state Exp;
branches;
next	11.181.2.8;

11.181.2.8
date	2001.02.23.20.23.09;	author bparker;	state Exp;
branches;
next	;

11.215.2.1
date	2002.09.19.18.02.02;	author morrison;	state Exp;
branches;
next	11.215.2.2;

11.215.2.2
date	2004.03.17.21.21.59;	author morrison;	state Exp;
branches;
next	11.215.2.3;

11.215.2.3
date	2004.04.02.16.11.14;	author morrison;	state Exp;
branches;
next	;

11.215.4.1
date	2002.09.26.23.04.11;	author morrison;	state Exp;
branches;
next	11.215.4.2;

11.215.4.2
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	11.215.4.3;

11.215.4.3
date	2004.03.12.17.38.48;	author morrison;	state Exp;
branches;
next	11.215.4.4;

11.215.4.4
date	2004.03.15.17.49.02;	author morrison;	state Exp;
branches;
next	11.215.4.5;

11.215.4.5
date	2004.03.17.04.15.12;	author morrison;	state Exp;
branches;
next	;

11.218.6.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	11.218.6.2;

11.218.6.2
date	2004.03.15.14.07.38;	author erikg;	state Exp;
branches;
next	11.218.6.3;

11.218.6.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@GED mainline
@


11.226
log
@moved to src/mged/
@
text
@/*
 *			G E D . C
 *
 * Mainline portion of the graphics editor
 *
 *  Functions -
 *	pr_prompt	print prompt
 *	main		Mainline portion of the graphics editor
 *	refresh		Internal routine to perform displaylist output writing
 *	log_event	Log an event in the log file
 *	mged_finish	Terminate with logging.  To be used instead of exit().
 *	quit		General Exit routine
 *	sig2		user interrupt catcher
 *	new_mats	derive inverse and editing matrices, as required
 *
 *  Authors -
 *	Michael John Muuss
 *	Charles M Kennedy
 *	Douglas A Gwyn
 *	Bob Suckling
 *	Gary Steven Moss
 *	Earl P Weaver
 *	Phil Dykstra
 *	Bob Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/ged.c,v 11.225 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

char MGEDCopyRight_Notice[] = "@@(#) \
Re-distribution of this software is restricted, as described in \
your 'Statement of Terms and Conditions for the Release of \
The BRL-CAD Pacakge' agreement. \
This software is Copyright (C) 1985,1987,1990,1993 by the United States Army \
in all countries except the USA.  All rights reserved.";

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <fcntl.h>
#include <ctype.h>
#include <signal.h>
#include <time.h>
#ifndef WIN32
#include <sys/errno.h>
#endif

#ifdef DM_X
#  include "tk.h"
#else
#  include "tcl.h"
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "mater.h"
#include "libtermio.h"
#include "./ged.h"
#include "./titles.h"
#include "./mged_solid.h"
#include "./sedit.h"
#include "./mged_dm.h"
#include "./cmd.h"

#ifdef WIN32
#include <fcntl.h>
#include <errno.h>
#define R_OK 2
#define W_OK 4
#endif

#ifndef WIN32
#ifndef	LOGFILE
#define LOGFILE	"/vld/lib/gedlog"	/* usage log */
#endif
#else
#ifndef	LOGFILE
#define LOGFILE	"C:\\gedlog"	/* usage log */
#endif
#endif


extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */

extern void draw_e_axes(void);
extern void draw_m_axes(void);
extern void draw_v_axes(void);

extern void fb_tclInit();  /* from in libfb/tcl.c */
extern int fb_refresh();

extern void draw_grid(void);		/* grid.c */

extern void draw_rect(void);		/* rect.c */
extern void paint_rect_area(void);

/* defined in predictor.c */
extern void predictor_init(void);

/* defined in cmd.c */
extern Tcl_Interp *interp;

#ifdef DM_X
extern Tk_Window tkwin;
#endif

/* defined in attach.c */
extern int mged_link_vars(struct dm_list *p);

/* defined in chgmodel.c */
extern void set_localunit_TclVar(void);

/* defined in dodraw.c */
extern unsigned char geometry_default_color[];

/* defined in libdm/dm-Null.c */
extern struct dm dm_Null;

/* defined in set.c */
extern struct _mged_variables default_mged_variables;

/* defined in color_scheme.c */
extern struct _color_scheme default_color_scheme;

/* defined in grid.c */
extern struct _grid_state default_grid_state;

/* defined in axes.c */
extern struct _axes_state default_axes_state;

/* defined in rect.c */
extern struct _rubber_band default_rubber_band;

int pipe_out[2];
int pipe_err[2];
struct db_i *dbip = DBI_NULL;	/* database instance pointer */
struct rt_wdb *wdbp = RT_WDB_NULL;
struct dg_obj *dgop = RT_DGO_NULL;
int update_views = 0;
int (*cmdline_hook)() = NULL;
jmp_buf	jmp_env;		/* For non-local gotos */
double frametime;		/* time needed to draw last frame */

int             cmd_stuff_str(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
void		(*cur_sigint)();	/* Current SIGINT status */
void		sig2(int), sig3(int);
void		reset_input_strings(void);
void		new_mats(void);
void		usejoy(double xangle, double yangle, double zangle);
void            slewview(fastf_t *view_pos);
int		interactive = 0;	/* >0 means interactive */
int             cbreak_mode = 0;        /* >0 means in cbreak_mode */
#ifdef DM_X
int		classic_mged=0;
#else
int		classic_mged=1;
#endif
char		*dpy_string = (char *)NULL;
static int	mged_init_flag = 1;	/* >0 means in initialization stage */

struct bu_vls input_str, scratchline, input_str_prefix;
int input_str_index = 0;

/*
 * 0 - no warn
 * 1 - warn
 */
int db_warn = 0;

/*
 * 0 - no upgrade
 * 1 - upgrade
 */
int db_upgrade = 0;

/* force creation of specific database versions */
int db_version = 5;

static void     mged_insert_char(char ch);
static void	mged_process_char(char ch);
static int	do_rc(void);
static void	log_event(char *event, char *arg);
extern char	version[];		/* from vers.c */

struct bn_tol	mged_tol;		/* calculation tolerance */

struct bu_vls mged_prompt;
void pr_prompt(void), pr_beep(void);
int mged_bomb_hook(genptr_t clientData, genptr_t str);

void mged_view_obj_callback(genptr_t clientData, struct view_obj *vop);

#ifdef USE_PROTOTYPES
#ifndef WIN32
Tcl_FileProc stdin_input;
Tcl_FileProc std_out_or_err;
#else
void stdin_input(ClientData clientData,int mask);
void std_out_or_err(ClientData clientData,int mask);
#endif
#else
void stdin_input();
void std_out_or_err();
#endif

/* 
 *			M A I N
 */

int
main(int argc, char **argv)
{
	int	rateflag = 0;
	int	c;
	int	read_only_flag=0;

#ifdef WIN32
	Tcl_Channel chan;
#endif


#ifdef WIN32
	_fmode = _O_BINARY;
#endif

	while ((c = bu_getopt(argc, argv, "d:hicnrx:X:")) != EOF)
	{
		switch( c )
		{
			case 'd':
				dpy_string = bu_optarg;
				break;
			case 'r':
				read_only_flag = 1;
				break;
			case 'n':		/* "not new" == "classic" */
			case 'c':
#ifndef WIN32
				classic_mged = 1;
#else
				MessageBox(NULL,"-c OPTION NOT AVAILABLE","NOT SUPPORTED",MB_OK);
#endif
				break;
			case 'x':
				sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
				break;
			case 'X':
	                        sscanf( bu_optarg, "%x", (unsigned int *)&bu_debug );
				break;
			default:
				fprintf( stdout, "Unrecognized option (%c)\n", c );
				/* Fall through to help */
			case 'h':
				fprintf(stdout, "Usage:  %s [-c] [-d display] [-h] [-r] [-x#] [-X#] [database [command]]\n", argv[0]);
				fflush(stdout);
				return(1);
		}
	}

	argc -= (bu_optind - 1);
	argv += (bu_optind - 1);

	/* Identify ourselves if interactive */
	if( argc <= 2 )  {
	  if( isatty(fileno(stdin)) && isatty(fileno(stdout)) )
	    interactive = 1;

	  if(interactive && classic_mged){
	    fprintf(stdout, "%s\n", version+5);	/* skip @@(#) */
	    fflush(stdout);
		
	    if (isatty(fileno(stdin)) && isatty(fileno(stdout))) {
#ifndef COMMAND_LINE_EDITING
#define COMMAND_LINE_EDITING 1
#endif
	      /* Set up for character-at-a-time terminal IO. */
	      cbreak_mode = COMMAND_LINE_EDITING;
	      save_Tty(fileno(stdin));
	    }
	  }
	}

#ifndef WIN32
	(void)signal( SIGPIPE, SIG_IGN );
#endif

	/*
	 *  Sample and hold current SIGINT setting, so any commands that
	 *  might be run (e.g., by .mgedrc) which establish cur_sigint
	 *  as their signal handler get the initial behavior.
	 *  This will change after setjmp() is called, below.
	 */
	cur_sigint = signal( SIGINT, SIG_IGN );		/* sample */
	(void)signal( SIGINT, cur_sigint );		/* restore */

	if( !classic_mged ) {
		pid_t pid;

		pid = fork();
		if( pid > 0 ) {
			fprintf( stdout, "Backgrounding, please wait...\n" );
			sleep( 3 );	/* just so it does not appear that MGED has died */
			exit( 0 );
		}
	}

#if 1
	/* If multiple processors might be used, initialize for it.
	 * Do not run any commands before here.
	 * Do not use bu_log() or bu_malloc() before here.
	 */
	if( bu_avail_cpus() > 1 )  {
	  rt_g.rtg_parallel = 1;
	  bu_semaphore_init( RT_SEM_LAST );
	}
#endif

	/* Set up linked lists */
	BU_LIST_INIT(&HeadSolid.l);
	BU_LIST_INIT(&FreeSolid.l);
	BU_LIST_INIT(&rt_g.rtg_vlfree);
	BU_LIST_INIT(&rt_g.rtg_headwdb.l);
	BU_LIST_INIT(&head_run_rt.l);

	bzero((void *)&head_cmd_list, sizeof(struct cmd_list));
	BU_LIST_INIT(&head_cmd_list.l);
	bu_vls_init(&head_cmd_list.cl_name);
	bu_vls_init(&head_cmd_list.cl_more_default);
	bu_vls_strcpy(&head_cmd_list.cl_name, "mged");
	curr_cmd_list = &head_cmd_list;

	bzero((void *)&head_dm_list, sizeof(struct dm_list));
	BU_LIST_INIT( &head_dm_list.l );

	BU_GETSTRUCT(curr_dm_list, dm_list);
	BU_LIST_APPEND(&head_dm_list.l, &curr_dm_list->l);
	netfd = -1;

	/* initialize predictor stuff */
	BU_LIST_INIT(&curr_dm_list->dml_p_vlist);
	predictor_init();

	BU_GETSTRUCT(dmp, dm);
	*dmp = dm_Null;
	bu_vls_init(&pathName);
	bu_vls_init(&tkName);
	bu_vls_init(&dName);
	bu_vls_strcpy(&pathName, "nu");
	bu_vls_strcpy(&tkName, "nu");

	BU_GETSTRUCT(rubber_band, _rubber_band);
	*rubber_band = default_rubber_band;		/* struct copy */

	BU_GETSTRUCT(mged_variables, _mged_variables);
	*mged_variables = default_mged_variables;	/* struct copy */

	BU_GETSTRUCT(color_scheme, _color_scheme);
	*color_scheme = default_color_scheme;		/* struct copy */

	BU_GETSTRUCT(grid_state, _grid_state);
	*grid_state = default_grid_state;		/* struct copy */

	BU_GETSTRUCT(axes_state, _axes_state);
	*axes_state = default_axes_state;		/* struct copy */

	BU_GETSTRUCT(adc_state, _adc_state);
	adc_state->adc_rc = 1;
	adc_state->adc_a1 = adc_state->adc_a2 = 45.0;

	BU_GETSTRUCT(menu_state, _menu_state);
	menu_state->ms_rc = 1;

	BU_GETSTRUCT(dlist_state, _dlist_state);
	dlist_state->dl_rc = 1;

	BU_GETSTRUCT(view_state, _view_state);
	view_state->vs_rc = 1;
	view_ring_init(curr_dm_list->dml_view_state, (struct _view_state *)NULL);
	MAT_IDN( view_state->vs_ModelDelta );

	am_mode = AMM_IDLE;
	owner = 1;
	frametime = 1;

	MAT_IDN( identity );		/* Handy to have around */
	MAT_IDN( modelchanges );
	MAT_IDN( acc_rot_sol );

	state = ST_VIEW;
	es_edflag = -1;
	es_edclass = EDIT_CLASS_NULL;
	inpara = newedge = 0;

	/* These values match old GED.  Use 'tol' command to change them. */
	mged_tol.magic = BN_TOL_MAGIC;
	mged_tol.dist = 0.005;
	mged_tol.dist_sq = mged_tol.dist * mged_tol.dist;
	mged_tol.perp = 1e-6;
	mged_tol.para = 1 - mged_tol.perp;

	rt_init_resource( &rt_uniresource, 0, NULL );

	rt_prep_timer();		/* Initialize timer */

	es_edflag = -1;		/* no solid editing just now */

	bu_vls_init(&input_str);
	bu_vls_init(&input_str_prefix);
	bu_vls_init(&scratchline);
	bu_vls_init(&mged_prompt);
	input_str_index = 0;

	/* Get set up to use Tcl */
	mged_setup();
	new_mats();

	mmenu_init();
	btn_head_menu(0,0,0);
	mged_link_vars(curr_dm_list);


	{
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "set version \"%s\"", version+5);
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	}

	setview(0.0, 0.0, 0.0);

	if(dpy_string == (char *)NULL)
	  dpy_string = getenv("DISPLAY");

	if(interactive && !classic_mged){
	  int status;
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  if(dpy_string != (char *)NULL)
	    bu_vls_printf(&vls, "loadtk %s", dpy_string);
	  else
	    bu_vls_strcpy(&vls, "loadtk");

	  status = Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);

	  if (status != TCL_OK) {
	    bu_log("%s", interp->result);
	    exit(1);
	  }
	}

	if(argc >= 2){
	  /* Open the database, attach a display manager */
	  /* Command line may have more than 2 args, opendb only wants 2 */
	  if(f_opendb( (ClientData)NULL, interp, 2, argv ) == TCL_ERROR)
	    mged_finish(1);
	}

	if( dbip != DBI_NULL && (read_only_flag || dbip->dbi_read_only) )
	{
		dbip->dbi_read_only = 1;
		bu_log( "Opened in READ ONLY mode\n" );
	}

	/* --- Now safe to process commands. --- */
	if(interactive){
	  /* This is an interactive mged, process .mgedrc */
	  do_rc();

	  /*
	   * Initialze variables here in case the user specified changes
	   * to the defaults in their .mgedrc file.
	   */

	  if (classic_mged) {
#ifdef DM_X
	    get_attached();
#endif
	  } else {
	    struct bu_vls vls;
	    int status;
	    
	    /* make this a process group leader */
	    setpgid(0, 0);
	    
	    bu_vls_init(&vls);
	    bu_vls_strcpy(&vls, "gui");
	    status = Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    
	    if (status != TCL_OK) {
	      bu_log("%s", interp->result);
	      exit(1);
	    }

#ifndef WIN32
	    (void)pipe(pipe_out);
	    (void)pipe(pipe_err);
	    
	    /* Redirect stdout */
	    (void)close(1);
	    (void)dup(pipe_out[1]);
	    (void)close(pipe_out[1]);
	    
	    /* Redirect stderr */
	    (void)close(2);
	    (void)dup(pipe_err[1]);
	    (void)close(pipe_err[1]);

#  if 0
	    /* close stdin */
	    (void)close(0);
#  endif
#endif  /* WIN32 */

	    bu_add_hook(&bu_bomb_hook_list, mged_bomb_hook, GENPTR_NULL);
	  }
	}

	/* --- Now safe to process geometry. --- */

	/* If this is an argv[] invocation, do it now */
	if( argc > 2 )  {
	  char *av[2];

	  av[0] = "q";
	  av[1] = NULL;

	  /*
	    Call cmdline instead of calling mged_cmd directly
	    so that access to Tcl/Tk is possible.
	    */
	  for(argc -= 2, argv += 2; argc; --argc, ++argv)
	    bu_vls_printf(&input_str, "%s ", *argv);

	  cmdline(&input_str, TRUE);
	  bu_vls_free(&input_str);

	  f_quit((ClientData)NULL, interp, 1, av);
	  /* NOTREACHED */
	}

	if(classic_mged || !interactive){
#ifndef WIN32
	  Tcl_CreateFileHandler(STDIN_FILENO, TCL_READABLE,
				stdin_input, (ClientData)STDIN_FILENO);
#else
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_INPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      stdin_input, (ClientData)GetStdHandle(STD_INPUT_HANDLE));
#endif
	  (void)signal( SIGINT, SIG_IGN );

	  bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
	  pr_prompt();

	  if (cbreak_mode) {
	    set_Cbreak(fileno(stdin));
	    clr_Echo(fileno(stdin));
	  }
	}else{
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "output_hook output_callback");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);

#ifndef WIN32
	  /* to catch output from routines that do not use bu_log */
	  Tcl_CreateFileHandler(pipe_out[0], TCL_READABLE,
				std_out_or_err, (ClientData)pipe_out[0]);
	  Tcl_CreateFileHandler(pipe_err[0], TCL_READABLE,
				std_out_or_err, (ClientData)pipe_err[0]);
#else
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_OUTPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_OUTPUT_HANDLE));
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_ERROR_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_ERROR_HANDLE));
#endif
	}

	mged_init_flag = 0;	/* all done with initialization */

	/****************  M A I N   L O O P   *********************/
	while(1) {
		/* This test stops optimizers from complaining about an infinite loop */
		if( (rateflag = event_check( rateflag )) < 0 )  break;

		/*
		 * Cause the control portion of the displaylist to be
		 * updated to reflect the changes made above.
		 */
		refresh();
	}
	return(0);
}

void
pr_prompt(void)
{
	if( interactive )
		bu_log("%S", &mged_prompt);
}

void
pr_beep(void)
{
    bu_log("%c", 7);
}

/*
 * standard input handling
 *
 * When the Tk event handler sees input on standard input, it calls the
 * routine "stdin_input" (registered with the Tcl_CreateFileHandler call).
 * This routine simply appends the new input to a growing string until the
 * command is complete (it is assumed that the routine gets a fill line.)
 *
 * If the command is incomplete, then allow the user to hit ^C to start over,
 * by setting up the multi_line_sig routine as the SIGINT handler.
 */

extern struct bu_vls *history_prev(void), *history_cur(void), *history_next(void);

/*
 * stdin_input
 *
 * Called when a single character is ready for reading on standard input
 * (or an entire line if the terminal is not in cbreak mode.)
 */

void
stdin_input(ClientData clientData, int mask)
{
    int count;
    char ch;
    struct bu_vls temp;
#ifndef WIN32
    long fd;
#else
	HANDLE fd;
#endif

#ifndef WIN32
    fd = (long)clientData;
#else	
    fd = (HANDLE)clientData;      
#endif

    /* When not in cbreak mode, just process an entire line of input, and
       don't do any command-line manipulation. */

    if (!cbreak_mode) {
	bu_vls_init(&temp);

	/* Get line from stdin */
	if( bu_vls_gets(&temp, stdin) < 0 )
    		quit();				/* does not return */
	bu_vls_vlscat(&input_str, &temp);

	/* If there are any characters already in the command string (left
	   over from a CMD_MORE), then prepend them to the new input. */

	/* If no input and a default is supplied then use it */
	if(!bu_vls_strlen(&input_str) && bu_vls_strlen(&curr_cmd_list->cl_more_default))
	  bu_vls_printf(&input_str_prefix, "%s%S\n",
			bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			&curr_cmd_list->cl_more_default);
	else
	  bu_vls_printf(&input_str_prefix, "%s%S\n",
			bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			&input_str);

	bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);

	/* If a complete line was entered, attempt to execute command. */
	
	if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
	    curr_cmd_list = &head_cmd_list;
	    if(curr_cmd_list->cl_tie)
	      curr_dm_list = curr_cmd_list->cl_tie;
	    if (cmdline_hook != NULL) {
		if ((*cmdline_hook)(&input_str))
		    pr_prompt();
		bu_vls_trunc(&input_str, 0);
		bu_vls_trunc(&input_str_prefix, 0);
		(void)signal( SIGINT, SIG_IGN );
	    } else {
		if (cmdline(&input_str_prefix, TRUE) == CMD_MORE) {
		    /* Remove newline */
		    bu_vls_trunc(&input_str_prefix,
				 bu_vls_strlen(&input_str_prefix)-1);
		    bu_vls_trunc(&input_str, 0);

		    (void)signal( SIGINT, sig2 );
		} else {
		    bu_vls_trunc(&input_str_prefix, 0);
		    bu_vls_trunc(&input_str, 0);
		    (void)signal( SIGINT, SIG_IGN );
		}
		pr_prompt();
	    }
	    input_str_index = 0;
	} else {
	    bu_vls_trunc(&input_str, 0);
	    /* Allow the user to hit ^C. */
	    (void)signal( SIGINT, sig2 );
	}
	bu_vls_free(&temp);
	return;
    }

/*XXXXX*/
#define TRY_STDIN_INPUT_HACK
#ifdef TRY_STDIN_INPUT_HACK
    /* Grab everything --- assuming everything is <= 4096 */
    {
      char buf[4096];
      int index;
#  ifdef WIN32
      ReadFile(fd,buf,4096,&count,NULL);
#  else
      count = read((int)fd, (void *)buf, 4096);
#  endif

#else
    /* Grab single character from stdin */
    count = read((int)fd, (void *)&ch, 1);
#endif

    if (count <= 0 && feof(stdin)) {
      char *av[2];

      av[0] = "q";
      av[1] = NULL;

      f_quit((ClientData)NULL, interp, 1, av);
    }

#ifdef TRY_STDIN_INPUT_HACK
    /* Process everything in buf */
    for(index = 0, ch = buf[index]; index < count; ch = buf[++index]){
#endif
      mged_process_char(ch);
#ifdef TRY_STDIN_INPUT_HACK
    }
    }
#endif	
}

/* Process character */
static void
mged_process_char(char ch)
{
  struct bu_vls *vp;
  struct bu_vls temp;
  static int escaped = 0;
  static int bracketed = 0;
  static int freshline = 1;

#define CTRL_A      1
#define CTRL_B      2
#define CTRL_D      4
#define CTRL_E      5
#define CTRL_F      6
#define CTRL_K      11
#define CTRL_L      12
#define CTRL_N      14
#define CTRL_P      16
#define CTRL_T      20
#define CTRL_U      21
#define CTRL_W      '\027'
#define ESC         27
#define BACKSPACE   '\b'
#define DELETE      127

#define SPACES "                                                                                                                                                                                                                                                                                                           "
  /* ANSI arrow keys */
    
  if (escaped && bracketed) {
    if (ch == 'A') ch = CTRL_P;
    if (ch == 'B') ch = CTRL_N;
    if (ch == 'C') ch = CTRL_F;
    if (ch == 'D') ch = CTRL_B;
    escaped = bracketed = 0;
  }

  switch (ch) {
  case ESC:           /* Used for building up ANSI arrow keys */
    escaped = 1;
    break;
  case '\n':          /* Carriage return or line feed */
  case '\r':
    bu_log("\n");   /* Display newline */

    /* If there are any characters already in the command string (left
       over from a CMD_MORE), then prepend them to the new input. */

    /* If no input and a default is supplied then use it */
    if(!bu_vls_strlen(&input_str) && bu_vls_strlen(&curr_cmd_list->cl_more_default))
      bu_vls_printf(&input_str_prefix, "%s%S\n",
		    bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		    &curr_cmd_list->cl_more_default);
    else {
      if (curr_cmd_list->cl_quote_string)
	bu_vls_printf(&input_str_prefix, "%s\"%S\"\n",
		      bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		      &input_str);
      else
	bu_vls_printf(&input_str_prefix, "%s%S\n",
		      bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		      &input_str);
    }

    curr_cmd_list->cl_quote_string = 0;
    bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);

    /* If this forms a complete command (as far as the Tcl parser is
       concerned) then execute it. */
	
    if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
      curr_cmd_list = &head_cmd_list;
      if(curr_cmd_list->cl_tie)
	curr_dm_list = curr_cmd_list->cl_tie;
      if (cmdline_hook) {  /* Command-line hooks don't do CMD_MORE */
	reset_Tty(fileno(stdin));

	if ((*cmdline_hook)(&input_str_prefix))
	  pr_prompt();

	set_Cbreak(fileno(stdin));
	clr_Echo(fileno(stdin));

	bu_vls_trunc(&input_str, 0);
	bu_vls_trunc(&input_str_prefix, 0);
	(void)signal( SIGINT, SIG_IGN );
      } else {
	reset_Tty(fileno(stdin)); /* Backwards compatibility */
	(void)signal( SIGINT, SIG_IGN );
	if (cmdline(&input_str_prefix, TRUE) == CMD_MORE) {
	  /* Remove newline */
	  bu_vls_trunc(&input_str_prefix,
		       bu_vls_strlen(&input_str_prefix)-1);
	  bu_vls_trunc(&input_str, 0);
	  (void)signal( SIGINT, sig2 );
	  /* *** The mged_prompt vls now contains prompt for more input. *** */
	} else {
	  /* All done; clear all strings. */
	  bu_vls_trunc(&input_str_prefix, 0);
	  bu_vls_trunc(&input_str, 0);
	  (void)signal( SIGINT, SIG_IGN );
	}
	set_Cbreak(fileno(stdin)); /* Back to single-character mode */
	clr_Echo(fileno(stdin));
      }
    } else {
      bu_vls_trunc(&input_str, 0);
      bu_vls_strcpy(&mged_prompt, "\r? ");

      /* Allow the user to hit ^C */
      (void)signal( SIGINT, sig2 );
    }
    pr_prompt(); /* Print prompt for more input */
    input_str_index = 0;
    freshline = 1;
    escaped = bracketed = 0;
    break;
  case BACKSPACE:
  case DELETE:
    if (input_str_index <= 0) {
      pr_beep();
      break;
    }

    if (input_str_index == bu_vls_strlen(&input_str)) {
      bu_log("\b \b");
      bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1);
    } else {
      bu_vls_init(&temp);
      bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
      bu_vls_trunc(&input_str, input_str_index-1);
      bu_log("\b%S ", &temp);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }
    --input_str_index;
    escaped = bracketed = 0;
    break;
  case CTRL_A:                    /* Go to beginning of line */
    pr_prompt();
    input_str_index = 0;
    escaped = bracketed = 0;
    break;
  case CTRL_E:                    /* Go to end of line */
    if (input_str_index < bu_vls_strlen(&input_str)) {
      bu_log("%s", bu_vls_addr(&input_str)+input_str_index);
      input_str_index = bu_vls_strlen(&input_str);
    }
    escaped = bracketed = 0;
    break;
  case CTRL_D:                    /* Delete character at cursor */
    if (input_str_index == bu_vls_strlen(&input_str)) {
      pr_beep(); /* Beep if at end of input string */
      break;
    }
    bu_vls_init(&temp);
    bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index+1);
    bu_vls_trunc(&input_str, input_str_index);
    bu_log("%S ", &temp);
    pr_prompt();
    bu_log("%S", &input_str);
    bu_vls_vlscat(&input_str, &temp);
    bu_vls_free(&temp);
    escaped = bracketed = 0;
    break;
  case CTRL_U:                   /* Delete whole line */
    pr_prompt();
    bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
    pr_prompt();
    bu_vls_trunc(&input_str, 0);
    input_str_index = 0;
    escaped = bracketed = 0;
    break;
  case CTRL_K:                    /* Delete to end of line */
    bu_log("%*s", bu_vls_strlen(&input_str)-input_str_index, SPACES);
    bu_vls_trunc(&input_str, input_str_index);
    pr_prompt();
    bu_log("%S", &input_str);
    escaped = bracketed = 0;
    break;
  case CTRL_L:                   /* Redraw line */
    bu_log("\n");
    pr_prompt();
    bu_log("%S", &input_str);
    if (input_str_index == bu_vls_strlen(&input_str))
      break;
    pr_prompt();
    bu_log("%*S", input_str_index, &input_str);
    escaped = bracketed = 0;
    break;
  case CTRL_B:                   /* Back one character */
    if (input_str_index == 0) {
      pr_beep();
      break;
    }
    --input_str_index;
    bu_log("\b"); /* hopefully non-destructive! */
    escaped = bracketed = 0;
    break;
  case CTRL_F:                   /* Forward one character */
    if (input_str_index == bu_vls_strlen(&input_str)) {
      pr_beep();
      break;
    }
    
    bu_log("%c", bu_vls_addr(&input_str)[input_str_index]);
    ++input_str_index;
    escaped = bracketed = 0;
    break;
  case CTRL_T:                  /* Transpose characters */
    if (input_str_index == 0) {
      pr_beep();
      break;
    }
    if (input_str_index == bu_vls_strlen(&input_str)) {
      bu_log("\b");
      --input_str_index;
    }
    ch = bu_vls_addr(&input_str)[input_str_index];
    bu_vls_addr(&input_str)[input_str_index] =
      bu_vls_addr(&input_str)[input_str_index - 1];
    bu_vls_addr(&input_str)[input_str_index - 1] = ch;
    bu_log("\b%*s", 2, bu_vls_addr(&input_str)+input_str_index-1);
    ++input_str_index;
    escaped = bracketed = 0;
    break;
  case CTRL_N:                  /* Next history command */
  case CTRL_P:                  /* Last history command */
    /* Work the history routines to get the right string */
    curr_cmd_list = &head_cmd_list;
    if (freshline) {
      if (ch == CTRL_P) {
	vp = history_prev();
	if (vp == NULL) {
	  pr_beep();
	  break;
	}
	bu_vls_trunc(&scratchline, 0);
	bu_vls_vlscat(&scratchline, &input_str);
	freshline = 0;
      } else {
	pr_beep();
	break;
      }
    } else {
      if (ch == CTRL_P) {
	vp = history_prev();
	if (vp == NULL) {
	  pr_beep();
	  break;
	}
      } else {
	vp = history_next();
	if (vp == NULL) {
	  vp = &scratchline;
	  freshline = 1;
	}
      }
    }
    pr_prompt();
    bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
    pr_prompt();
    bu_vls_trunc(&input_str, 0);
    bu_vls_vlscat(&input_str, vp);
    if (bu_vls_addr(&input_str)[bu_vls_strlen(&input_str)-1] == '\n')
      bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1); /* del \n */
    bu_log("%S", &input_str);
    input_str_index = bu_vls_strlen(&input_str);
    escaped = bracketed = 0;
    break;
  case CTRL_W:                   /* backward-delete-word */
    {
      char *start;
      char *curr;
      int len;
      
      start = bu_vls_addr(&input_str);
      curr = start + input_str_index - 1;
      
      /* skip spaces */
      while(curr > start && *curr == ' ')
	--curr;
      
      /* find next space */
      while(curr > start && *curr != ' ')
	--curr;
      
      bu_vls_init(&temp);
      bu_vls_strcat(&temp, start+input_str_index);
      
      if(curr == start)
	input_str_index = 0;
      else
	input_str_index = curr - start + 1;
      
      len = bu_vls_strlen(&input_str);
      bu_vls_trunc(&input_str, input_str_index);
      pr_prompt();
      bu_log("%S%S%*s", &input_str, &temp, len - input_str_index, SPACES);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }
  
  escaped = bracketed = 0;
  break;
  case 'd':
    if (escaped) {                /* delete-word */
      char *start;
      char *curr;
      int i;

      start = bu_vls_addr(&input_str);
      curr = start + input_str_index;

      /* skip spaces */
      while(*curr != '\0' && *curr == ' ')
	++curr;

      /* find next space */
      while(*curr != '\0' && *curr != ' ')
	++curr;

      i = curr - start;
      bu_vls_init(&temp);
      bu_vls_strcat(&temp, curr);
      bu_vls_trunc(&input_str, input_str_index);
      pr_prompt();
      bu_log("%S%S%*s", &input_str, &temp, i - input_str_index, SPACES);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }else
      mged_insert_char(ch);

    escaped = bracketed = 0;
    break;
  case 'f':
    if (escaped) {                /* forward-word */
      char *start;
      char *curr;

      start = bu_vls_addr(&input_str);
      curr = start + input_str_index;

      /* skip spaces */
      while(*curr != '\0' && *curr == ' ')
	++curr;

      /* find next space */
      while(*curr != '\0' && *curr != ' ')
	++curr;

      input_str_index = curr - start;
      bu_vls_init(&temp);
      bu_vls_strcat(&temp, start+input_str_index);
      bu_vls_trunc(&input_str, input_str_index);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }else
      mged_insert_char(ch);

    escaped = bracketed = 0;
    break;
  case 'b':
    if (escaped) {                /* backward-word */
      char *start;
      char *curr;

      start = bu_vls_addr(&input_str);
      curr = start + input_str_index - 1;

      /* skip spaces */
      while(curr > start && *curr == ' ')
	--curr;

      /* find next space */
      while(curr > start && *curr != ' ')
	--curr;

      if(curr == start)
	input_str_index = 0;
      else
	input_str_index = curr - start + 1;

      bu_vls_init(&temp);
      bu_vls_strcat(&temp, start+input_str_index);
      bu_vls_trunc(&input_str, input_str_index);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }else
      mged_insert_char(ch);

    escaped = bracketed = 0;
    break;
  case '[':
    if (escaped) {
      bracketed = 1;
      break;
    }
    /* Fall through if not escaped! */
  default:
    if (!isprint(ch))
      break;

    mged_insert_char(ch);
    escaped = bracketed = 0;
    break;
  }
}

static void
mged_insert_char(char ch)
{
  if (input_str_index == bu_vls_strlen(&input_str)) {
    bu_log("%c", (int)ch);
    bu_vls_putc(&input_str, (int)ch);
    ++input_str_index;
  } else {
    struct bu_vls temp;

    bu_vls_init(&temp);
    bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
    bu_vls_trunc(&input_str, input_str_index);
    bu_log("%c%S", (int)ch, &temp);
    pr_prompt();
    bu_vls_putc(&input_str, (int)ch);
    bu_log("%S", &input_str);
    bu_vls_vlscat(&input_str, &temp);
    ++input_str_index;
    bu_vls_free(&temp);
  }
}


/* Stuff a string to stdout while leaving the current command-line alone */
int
cmd_stuff_str(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int i;

  if(argc != 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel stuff_str");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(classic_mged){
    bu_log("\r%s\n", argv[1]);
    pr_prompt();
    bu_log("%s", bu_vls_addr(&input_str));
    pr_prompt();
    for(i = 0; i < input_str_index; ++i)
      bu_log("%c", bu_vls_addr(&input_str)[i]);
  }

  return TCL_OK;
}

void
std_out_or_err(ClientData clientData, int mask)
{
#ifndef WIN32
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
#else
  HANDLE fd = clientData;
#endif  
  int count;
  struct bu_vls vls;
  char line[MAXLINE];
  Tcl_Obj *save_result;

  /* Get data from stdout or stderr */

#ifndef WIN32
  if((count = read((int)fd, line, MAXLINE)) == 0)
#else
  if((!ReadFile(fd, line, MAXLINE,&count,0)))
#endif
    return;

  line[count] = '\0';

  save_result = Tcl_GetObjResult(interp);
  Tcl_IncrRefCount(save_result);

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "output_callback {%s}", line);
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  Tcl_SetObjResult(interp, save_result);
  Tcl_DecrRefCount(save_result);
}

/*
 *			E V E N T _ C H E C K
 *
 *  Check for events, and dispatch them.
 *  Eventually, this will be done entirely by generating commands
 *
 *  Returns - recommended new value for non_blocking
 */

int
event_check( int non_blocking )
{
    register struct dm_list *p;
    struct dm_list *save_dm_list;
    int save_edflag;

    /* Let cool Tk event handler do most of the work */

    if (non_blocking) {

	/* When in non_blocking-mode, we want to deal with as many events
	   as possible before the next redraw (multiple keypresses, redraw
	   events, etc... */
	
	while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
    } else {
      /* Wait for an event, then handle it */
      Tcl_DoOneEvent(TCL_ALL_EVENTS);

      /* Handle any other events in the queue */
      while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
    }
    
    non_blocking = 0;

    if (dbip == DBI_NULL)
	    return non_blocking;

    /*********************************
     *  Handle rate-based processing *
     *********************************/
    save_dm_list = curr_dm_list;
    if( edit_rateflag_model_rotate ) {
      struct bu_vls vls;
      char save_coords;

      curr_dm_list = edit_rate_mr_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'm';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		    edit_rate_model_origin,
		    edit_rate_model_rotate[X],
		    edit_rate_model_rotate[Y],
		    edit_rate_model_rotate[Z]);
	
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_object_rotate ) {
      struct bu_vls vls;
      char save_coords;

      curr_dm_list = edit_rate_or_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'o';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		    edit_rate_object_origin,
		    edit_rate_object_rotate[X],
		    edit_rate_object_rotate[Y],
		    edit_rate_object_rotate[Z]);
	
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_view_rotate ) {
      struct bu_vls vls;
      char save_coords;

      curr_dm_list = edit_rate_vr_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'v';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		    edit_rate_view_origin,
		    edit_rate_view_rotate[X],
		    edit_rate_view_rotate[Y],
		    edit_rate_view_rotate[Z]);
	
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_model_tran ) {
      char save_coords;
      struct bu_vls vls;

      curr_dm_list = edit_rate_mt_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'm';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_TRAN)
	  es_edflag = STRANS;
      }else{
	save_edflag = edobj;
	edobj = BE_O_XY;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -i -e aX %f aY %f aZ %f\n",
		    edit_rate_model_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		    edit_rate_model_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		    edit_rate_model_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);
	
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_view_tran ) {
      char save_coords;
      struct bu_vls vls;

      curr_dm_list = edit_rate_vt_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'v';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_TRAN)
	  es_edflag = STRANS;
      }else{
	save_edflag = edobj;
	edobj = BE_O_XY;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -i -e aX %f aY %f aZ %f\n",
		    edit_rate_view_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		    edit_rate_view_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		    edit_rate_view_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);
	
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_scale ) {
      struct bu_vls vls;

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_SCALE)
	  es_edflag = SSCALE;
      }else{
	save_edflag = edobj;
	if(!OEDIT_SCALE)
	  edobj = BE_O_SCALE;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -i -e aS %f\n", edit_rate_scale * 0.01);
	
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }

    FOR_ALL_DISPLAYS(p, &head_dm_list.l){
      if(!p->dml_owner)
	continue;

      curr_dm_list = p;

      if( view_state->vs_rateflag_model_rotate ) {
	struct bu_vls vls;

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -o %c -i -m ax %f ay %f az %f\n",
		      view_state->vs_rate_model_origin,
		      view_state->vs_rate_model_rotate[X],
		      view_state->vs_rate_model_rotate[Y],
		      view_state->vs_rate_model_rotate[Z]);
	
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
      }
      if( view_state->vs_rateflag_model_tran ) {
	struct bu_vls vls;

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -m aX %f aY %f aZ %f\n",
		      view_state->vs_rate_model_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      view_state->vs_rate_model_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      view_state->vs_rate_model_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
      }
      if( view_state->vs_rateflag_rotate )  {
	struct bu_vls vls;

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -o %c -i -v ax %f ay %f az %f\n",
		      view_state->vs_rate_origin,
		      view_state->vs_rate_rotate[X],
		      view_state->vs_rate_rotate[Y],
		      view_state->vs_rate_rotate[Z]);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
      }
      if( view_state->vs_rateflag_tran )  {
	struct bu_vls vls;

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -v aX %f aY %f aZ %f",
		      view_state->vs_rate_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      view_state->vs_rate_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      view_state->vs_rate_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
      }
      if( view_state->vs_rateflag_scale )  {
	struct bu_vls vls;

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "zoom %f",
		      1.0 / (1.0 - (view_state->vs_rate_scale / 10.0)));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
      }
      
      curr_dm_list = save_dm_list;
    }

    return( non_blocking );
}

/*			R E F R E S H
 *
 * NOTE that this routine is not to be casually used to
 * refresh the screen.  The normal procedure for screen
 * refresh is to manipulate the necessary global variables,
 * and wait for refresh to be called at the bottom of the while loop
 * in main().  However, when it is absolutely necessary to
 * flush a change in the solids table out to the display in
 * the middle of a routine somewhere (such as the "B" command
 * processor), then this routine may be called.
 *
 * If you don't understand the ramifications of using this routine,
 * then you don't want to call it.
 */
void
refresh(void)
{
  struct dm_list *p;
  struct dm_list *save_dm_list;
  struct bu_vls overlay_vls;
  struct bu_vls tmp_vls;
  register int do_overlay = 1;
  double elapsed_time;
  int do_time = 0;

  rt_prep_timer();

  FOR_ALL_DISPLAYS(p, &head_dm_list.l)
	  if (update_views || p->dml_view_state->vs_flag)
		  p->dml_dirty = 1;

  /*
   * This needs to be done separately
   * because dml_view_state may be shared.
   */
  FOR_ALL_DISPLAYS(p, &head_dm_list.l)
	  p->dml_view_state->vs_flag = 0;

  update_views = 0;

  save_dm_list = curr_dm_list;
  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
    /*
     * if something has changed, then go update the display.
     * Otherwise, we are happy with the view we have
     */
    curr_dm_list = p;
    if (mapped && dirty) {
      dirty = 0;
      do_time = 1;
      VMOVE(geometry_default_color,color_scheme->cs_geo_def);

      if(dbip != DBI_NULL){
	if(do_overlay){
	  bu_vls_init(&overlay_vls);
	  bu_vls_init(&tmp_vls);
	  create_text_overlay(&overlay_vls);
	  do_overlay = 0;
	}

	/* XXX VR hack */
	if( viewpoint_hook )  (*viewpoint_hook)();
      }

      if( mged_variables->mv_predictor )
	predictor_frame();

      DM_DRAW_BEGIN(dmp);	/* update displaylist prolog */

      if (dbip != DBI_NULL) {
	      /* do framebuffer underlay */
	      if (mged_variables->mv_fb && !mged_variables->mv_fb_overlay) {
		      if (mged_variables->mv_fb_all)
			      fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
		      else if (mged_variables->mv_mouse_behavior != 'z')
			      paint_rect_area();
	      }

	      /* do framebuffer overlay for entire window */
	      if (mged_variables->mv_fb &&
		  mged_variables->mv_fb_overlay &&
		  mged_variables->mv_fb_all) {
		      fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
	      } else {
		      /*  Draw each solid in it's proper place on the screen
		       *  by applying zoom, rotation, & translation.
		       *  Calls DM_LOADMATRIX() and DM_DRAW_VLIST().
		       */

		      if (dmp->dm_stereo == 0 ||
			  mged_variables->mv_eye_sep_dist <= 0) {
			      /* Normal viewing */
			      dozoom(0);
		      } else {
			      /* Stereo viewing */
			      dozoom(1);
			      dozoom(2);
		      }

		      /* do framebuffer overlay in rectangular area */
		      if (mged_variables->mv_fb &&
			  mged_variables->mv_fb_overlay &&
			  mged_variables->mv_mouse_behavior != 'z')
			      paint_rect_area();
	      }


	      /* Restore to non-rotated, full brightness */
	      DM_NORMAL(dmp);

	      /* only if not doing overlay */
	      if (!mged_variables->mv_fb ||
		  mged_variables->mv_fb_overlay != 2) {
		      if (rubber_band->rb_active || rubber_band->rb_draw)
			      draw_rect();

		      if (grid_state->gr_draw)
			      draw_grid();

		      /* Compute and display angle/distance cursor */
		      if (adc_state->adc_draw)
			      adcursor();

		      if (axes_state->ax_view_draw)
			      draw_v_axes();

		      if (axes_state->ax_model_draw)
			      draw_m_axes();

		      if (axes_state->ax_edit_draw &&
			  (state == ST_S_EDIT || state == ST_O_EDIT))
			      draw_e_axes();

		      /* Display titles, etc., if desired */
		      bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
		      dotitles(&tmp_vls);
		      bu_vls_trunc(&tmp_vls, 0);
	      }
      }

      /* only if not doing overlay */
      if (!mged_variables->mv_fb ||
	  mged_variables->mv_fb_overlay != 2) {
	      /* Draw center dot */
	      DM_SET_FGCOLOR(dmp,
			     color_scheme->cs_center_dot[0],
			     color_scheme->cs_center_dot[1],
			     color_scheme->cs_center_dot[2], 1, 1.0);
	      DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
      }

      DM_DRAW_END(dmp);
    }
  }

  /* a frame was drawn */
  if(do_time){
    (void)rt_get_timer( (struct bu_vls *)0, &elapsed_time );
    /* Only use reasonable measurements */
    if( elapsed_time > 1.0e-5 && elapsed_time < 30 )  {
      /* Smoothly transition to new speed */
      frametime = 0.9 * frametime + 0.1 * elapsed_time;
    }
  }

  curr_dm_list = save_dm_list;

  if(!do_overlay){
    bu_vls_free(&overlay_vls);
    bu_vls_free(&tmp_vls);
  }
}

/*
 *			L O G _ E V E N T
 *
 * Logging routine
 */
static void
log_event(char *event, char *arg)
{
	struct bu_vls line;
	time_t now;
	char *timep;
	int logfd;

	(void)time( &now );
	timep = ctime( &now );	/* returns 26 char string */
	timep[24] = '\0';	/* Chop off \n */

	bu_vls_init(&line);
#ifndef WIN32
	bu_vls_printf(&line, "%s [%s] time=%ld uid=%d (%s) %s\n",
		      event,
		      dmp->dm_name,
		      (long)now,
		      getuid(),
		      timep,
		      arg
	);
#else
	{
		char uname[256]; 
		DWORD dwNumBytes = 256; 
		GetUserName(uname, &dwNumBytes);
		bu_vls_printf(&line, "%s [%s] time=%ld uid=%d (%s) %s\n",
		      event,
		      dmp->dm_name,
		      (long)now,
		      uname,
		      timep,
		      arg);
	}
#endif

#ifndef WIN32
	if( (logfd = open( LOGFILE, O_WRONLY|O_APPEND )) >= 0 )  {
		(void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
		(void)close( logfd );
	}
#else
	if( (logfd = open( LOGFILE, _O_WRONLY|_O_APPEND )) >= 0 )  {
		(void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
		(void)close( logfd );
	}
#endif


	bu_vls_free(&line);
}

/*
 *			F I N I S H
 *
 * This routine should be called in place of exit() everywhere
 * in GED, to permit an accurate finish time to be recorded in
 * the (ugh) logfile, also to remove the device access lock.
 */
void
mged_finish(int exitcode)
{
	char place[64];
	register struct dm_list *p;

	(void)sprintf(place, "exit_status=%d", exitcode );
	log_event( "CEASE", place );

	/* Release all displays */
	FOR_ALL_DISPLAYS(p, &head_dm_list.l){
	  curr_dm_list = p;

	  DM_CLOSE(dmp);
	}

	/* Be certain to close the database cleanly before exiting */
#if 0
	Tcl_Eval(interp, "db close; .inmem close");
#else
	Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
#endif

#if 0
	if (wdbp)
		wdb_close(wdbp);

	if (dbip)
		db_close(dbip);
#endif

	if (cbreak_mode > 0)
	    reset_Tty(fileno(stdin)); 
	    
	exit( exitcode );
}

/*
 *			Q U I T
 *
 * Handles finishing up.  Also called upon EOF on STDIN.
 */
void
quit(void)
{
	mged_finish(0);
	/* NOTREACHED */
}

/*
 *  			S I G 2
 */
#ifndef WIN32
void
sig2(int sig)
{
  reset_input_strings();

  (void)signal( SIGINT, SIG_IGN );
}

/*
 *  			S I G 3
 */
void
sig3(int sig)
{
  (void)signal( SIGINT, SIG_IGN );
  longjmp( jmp_env, 1 );
}
#else
void
sig2(int sig)
{
  reset_input_strings();

  (void)signal( SIGINT, SIG_IGN );
}

void
sig3(int sig)
{
  (void)signal( SIGINT, SIG_IGN );
  longjmp( jmp_env, 1 );
}
#endif


void
reset_input_strings()
{
  if(BU_LIST_IS_HEAD(curr_cmd_list, &head_cmd_list.l)){
    /* Truncate input string */
    bu_vls_trunc(&input_str, 0);
    bu_vls_trunc(&input_str_prefix, 0);
    bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);
    input_str_index = 0;

    curr_cmd_list->cl_quote_string = 0;
    bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
    bu_log("\n");
    pr_prompt();
  }else{
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_strcpy(&vls, "reset_input_strings");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
  }
}


/*
 *  			N E W _ M A T S
 *  
 *  Derive the inverse and editing matrices, as required.
 *  Centralized here to simplify things.
 */
void
new_mats(void)
{
	vo_update(view_state->vs_vop, interp, 0);
}

#ifdef DO_NEW_EDIT_MATS
void
new_edit_mats(void)
{
  register struct dm_list *p;
  struct dm_list *save_dm_list;

  save_dm_list = curr_dm_list;
  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
    if(!p->dml_owner)
      continue;

    curr_dm_list = p;
    bn_mat_mul( view_state->vs_model2objview, view_state->vs_vop->vo_model2view, modelchanges );
    bn_mat_inv( view_state->vs_objview2model, view_state->vs_model2objview );
    view_state->vs_flag = 1;
  }

  curr_dm_list = save_dm_list;
}
#endif

void
mged_view_obj_callback(genptr_t		clientData,
		       struct view_obj	*vop)
{
	struct _view_state *vsp = (struct _view_state *)clientData;

	if (state != ST_VIEW) {
		bn_mat_mul(vsp->vs_model2objview, vop->vo_model2view, modelchanges);
		bn_mat_inv(vsp->vs_objview2model, vsp->vs_model2objview);
	}
	vsp->vs_flag = 1;
}

/*
 *			D O _ R C
 *
 *  If an mgedrc file exists, open it and process the commands within.
 *  Look first for a Shell environment variable, then for a file in
 *  the user's home directory, and finally in the current directory.
 *
 *  Returns -
 *	-1	FAIL
 *	 0	OK
 */
static int
do_rc(void)
{
	FILE	*fp = NULL;
	char	*path;
	struct	bu_vls str;
	int bogus;

	bu_vls_init( &str );

#define ENVRC	"MGED_RCFILE"
#define RCFILE	".mgedrc"

	if( (path = getenv(ENVRC)) != (char *)NULL ) {
		if ((fp = fopen(path, "r")) != NULL ) {
			bu_vls_strcpy( &str, path );
		}
	}

	if( !fp ) {
		if( (path = getenv("HOME")) != (char *)NULL )  {
			bu_vls_strcpy( &str, path );
			bu_vls_strcat( &str, "/" );
			bu_vls_strcat( &str, RCFILE );

			fp = fopen(bu_vls_addr(&str), "r");
		}
	}

	if( !fp ) {
		if( (fp = fopen( RCFILE, "r" )) != NULL )  {
			bu_vls_strcpy( &str, RCFILE );
		}
	}

    /* At this point, if none of the above attempts panned out, give up. */

	if( !fp ){
	  bu_vls_free(&str);
	  return -1;
	}

	bogus = 0;
	while( !feof(fp) ) {
	    char buf[80];

	    /* Get beginning of line */
	    fgets( buf, 80, fp );
    /* If the user has a set command with an equal sign, remember to warn */
	    if( strstr(buf, "set") != NULL )
	      if( strchr(buf, '=') != NULL ){
		    bogus = 1;
		    break;
	      }
	}
	
	fclose( fp );
	if( bogus ) {
	    bu_log("\nWARNING: The new format of the \"set\" command is:\n");
	    bu_log("    set varname value\n");
	    bu_log("If you are setting variables in your %s, you will ", RCFILE);
	    bu_log("need to change those\ncommands.\n\n");
	}
	if (Tcl_EvalFile( interp, bu_vls_addr(&str) ) != TCL_OK) {
	    bu_log("Error reading %s:\n%s\n", RCFILE,
		Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
	}

	bu_vls_free(&str);
	return 0;
}

/*
 *			F _ O P E N D B
 *
 *  Close the current database, if open, and then open a new database.
 *  May also open a display manager, if interactive and none selected yet.
 *
 *  argv[1] is the filename.
 *
 *  There are two invocations:
 *	main()
 *	cmdline()		Only one arg is permitted.
 */
int
f_opendb(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	struct db_i		*save_dbip;
	struct mater		*save_materp;
	struct bu_vls		vls;
	struct bu_vls		msg;	/* use this to hold returned message */
	int			create_new_db = 0;

	if( argc <= 1 )  {

		/* Invoked without args, return name of current database */
		if( dbip != DBI_NULL )  {
			Tcl_AppendResult(interp, dbip->dbi_filename, (char *)NULL);
			return TCL_OK;
		}

		Tcl_AppendResult(interp, "", (char *)NULL);
		return TCL_OK;
	}

	if(3 < argc || (strlen(argv[1]) == 0)){
		bu_vls_printf(&vls, "help opendb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_init(&msg);

	if(argc == 3 &&
	    strcmp("y", argv[2]) && strcmp("Y", argv[2]) &&
	    strcmp("n", argv[2]) && strcmp("N", argv[2])){
		bu_vls_printf(&vls, "help opendb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}

	save_dbip = dbip;
	dbip = DBI_NULL;
	save_materp = rt_material_head;
	rt_material_head = MATER_NULL;

	/* Get input file */
	if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
	    ((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
		char line[128];

		/*
	         * Check to see if we can access the database
	         */
#ifndef WIN32
		if (access(argv[1], R_OK|W_OK) != 0 && errno != ENOENT) {
			perror(argv[1]);
			return TCL_ERROR;
		}
#else
		if ((access(argv[1], R_OK) != 0 || access(argv[1], W_OK) != 0)  && errno != ENOENT) {
			perror(argv[1]);
			return TCL_ERROR;
		}
#endif

	    	/* File does not exist */
		if (interactive) {
			if(mged_init_flag){
				if(classic_mged){
					bu_log("Create new database (y|n)[n]? ");
					(void)fgets(line, sizeof(line), stdin);
					if( line[0] != 'y' && line[0] != 'Y' ) {
						bu_log("Warning: no database is currently opened!\n");
						bu_vls_free(&vls);
						bu_vls_free(&msg);
						return TCL_OK;
					}
				} else{
					int status;

					if(dpy_string != (char *)NULL)
						bu_vls_printf(&vls, "cad_dialog .createdb %s \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
						    dpy_string, argv[1]);
					else
						bu_vls_printf(&vls, "cad_dialog .createdb :0 \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
						    argv[1]);

					status = Tcl_Eval(interp, bu_vls_addr(&vls));

					if(status != TCL_OK || interp->result[0] == '2') {
						mged_finish(0);
					}

					if(interp->result[0] == '1') {
						bu_log("opendb: no database is currently opened!\n");
						bu_vls_free(&vls);
						bu_vls_free(&msg);
						return TCL_OK;
					}
				}
			} else { /* not initializing mged */
				if(argc == 2){
					/* need to reset this before returning */
					dbip = save_dbip;
					rt_material_head = save_materp;
					Tcl_AppendResult(interp, MORE_ARGS_STR, "Create new database (y|n)[n]? ",
					    (char *)NULL);
					bu_vls_printf(&curr_cmd_list->cl_more_default, "n");
					bu_vls_free(&vls);
					bu_vls_free(&msg);
					return TCL_ERROR;
				}

				if( *argv[2] != 'y' && *argv[2] != 'Y' ){
					dbip = save_dbip; /* restore previous database */
					rt_material_head = save_materp;
					bu_vls_free(&vls);
					bu_vls_free(&msg);
					return TCL_OK;
				}
			}
		}

	    	/* File does not exist, and should be created */
		if ((dbip = db_create(argv[1], db_version)) == DBI_NULL) {
			dbip = save_dbip; /* restore previous database */
			rt_material_head = save_materp;
			bu_vls_free(&vls);
			bu_vls_free(&msg);

			if (mged_init_flag) {
				/* we need to use bu_log here */
				bu_log("opendb: failed to create %s\n", argv[1]);
				bu_log("opendb: no database is currently opened!\n");
				return TCL_OK;
			}

			Tcl_AppendResult(interp, "opendb: failed to create ", argv[1], "\n",\
		       (char *)NULL);
			if (dbip == DBI_NULL)
				Tcl_AppendResult(interp, "opendb: no database is currently opened!", \
			 (char *)NULL);

			return TCL_ERROR;
		}
	    	/* New database has already had db_dirbuild() by here */

		create_new_db = 1;
		bu_vls_printf(&msg, "The new database %s was successfully created.\n", argv[1]);
	} else {
		/* Opened existing database file */

		/* Scan geometry database and build in-memory directory */
		(void)db_dirbuild( dbip );
	}

	if( save_dbip )  {
		char *av[2];
		struct db_i *new_dbip;
		struct mater *new_materp;

		av[0] = "zap";
		av[1] = NULL;

		new_dbip = dbip;
		dbip = save_dbip;
		new_materp = rt_material_head;
		rt_material_head = save_materp;

		/* Clear out anything in the display */
		cmd_zap(clientData, interp, 1, av);

		/* Close the Tcl database objects */
#if 0
		Tcl_Eval(interp, "db close; .inmem close");
#else
		Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
#endif

		dbip = new_dbip;
		rt_material_head = new_materp;

		log_event( "CEASE", "(close)" );
	}

	{
		register struct dm_list *dmlp;

		/* update local2base and base2local variables for all view objects */
		FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
			dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
			dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
		}
	}

	if( dbip->dbi_read_only )
		bu_vls_printf(&msg, "%s: READ ONLY\n", dbip->dbi_filename);

	/* Quick -- before he gets away -- write a logfile entry! */
	log_event( "START", argv[1] );

	/* Provide LIBWDB C access to the on-disk database */
	if( (wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL )  {
		Tcl_AppendResult(interp, "wdb_dbopen() failed?\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* increment use count for this db instance */
	dbip->dbi_uses++;

	/* Establish LIBWDB TCL access to both disk and in-memory databases */
	/* This creates "db" and ".inmem" Tcl objects */
	if (wdb_init_obj(interp, wdbp, MGED_DB_NAME) != TCL_OK) {
		bu_vls_printf(&msg, "%s\n%s\n",
			      interp->result,
			      Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "wdb_open %s inmem [get_dbip]", MGED_INMEM_NAME);
	if (Tcl_Eval( interp, bu_vls_addr(&vls) ) != TCL_OK) {
		bu_vls_printf(&msg, "%s\n%s\n",
			      interp->result,
			      Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}

	/* link the drawable geometry object to the database object */
	dgop->dgo_wdbp = wdbp;

	/* Perhaps do something special with the GUI */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "opendb_callback %s", dbip->dbi_filename);
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));

	bu_vls_strcpy(&vls, "local2base");
	Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&local2base,
	    TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);

	bu_vls_strcpy(&vls, "base2local");
	Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&base2local,
	    TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);

	set_localunit_TclVar();

	/* Print title/units information */
	if (interactive)
		bu_vls_printf(&msg, "%s (units=%s)\n", dbip->dbi_title,
			      bu_units_string(dbip->dbi_local2base));

	/*
	 * We have an old database version AND
	 * we're not in the process of
	 * creating a new database.
	 */
	if (wdbp->dbip->dbi_version != 5 && !create_new_db) {
		if (db_upgrade) {
			if (db_warn)
				bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tConverting to the new format.\n");

			bu_vls_strcpy(&vls, "after idle dbupgrade -f y");
			(void)Tcl_Eval(interp, bu_vls_addr(&vls));
		} else {
			if (db_warn) {
				if (classic_mged)
					bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tSee the dbupgrade command.");
				else
					bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tSelect Tools-->Upgrade Database for info.");
			}
		}
	}

	Tcl_ResetResult( interp );
	Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);

	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_OK;
}


/*
 *			F _ C L O S E D B
 *
 *  Close the current database, if open.
 *
 */
int
f_closedb(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	char *av[2];

	if( argc != 1 )  {
		Tcl_Eval(interp, "help closedb");
		return TCL_ERROR;
	}

	if (dbip == DBI_NULL) {
		Tcl_AppendResult(interp, "No database is open\n", (char *)NULL);
		return TCL_OK;
	}

	/* Clear out anything in the display */
	av[0] = "zap";
	av[1] = NULL;
	cmd_zap(clientData, interp, 1, av);

	/* Close the Tcl database objects */
#if 0
	Tcl_Eval(interp, "db close; .inmem close");
#else
	Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
#endif
	
	log_event( "CEASE", "(close)" );

	/* update any and all other displays */
	{
		register struct dm_list *dmlp;
		
		/* update local2base and base2local variables for all view objects */
		FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
			dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
			dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
		}
	}
	
	/* wipe out the global pointers */
	dbip = DBI_NULL;
	rt_material_head = MATER_NULL;

	return TCL_OK;
}


int
mged_bomb_hook(genptr_t clientData, genptr_t str)
{
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "set mbh_dialog [Dialog .#auto -modality application];");
	bu_vls_printf(&vls, "$mbh_dialog hide 1; $mbh_dialog hide 2; $mbh_dialog hide 3;");
	bu_vls_printf(&vls, "label [$mbh_dialog childsite].l -text {%s};", str);
	bu_vls_printf(&vls, "pack [$mbh_dialog childsite].l;");
	bu_vls_printf(&vls, "update; $mbh_dialog activate");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	
	return TCL_OK;
}
@


11.225
log
@change conf.h to a wrapped config.h
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/ged.c,v 11.224 2004/05/10 15:25:28 morrison Exp $ (BRL)";
@


11.224
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.223 2004/04/22 12:11:36 jra Exp $ (BRL)";
d50 5
a54 1
#include "conf.h"
@


11.223
log
@Added a "dbip->dbi_uses++;" line in f_opendb (as suggested by Bob Parker)
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/ged.c,v 11.222 2004/04/05 09:09:11 morrison Exp $ (BRL)";
d1751 1
a1751 1
			     color_scheme->cs_center_dot[2], 1);
@


11.222
log
@merge of ansi-6-0-branch into HEAD
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d2307 3
@


11.221
log
@odd how that built successfully on the branch..
@
text
@d105 1
a105 1
extern void view_ring_init(); /* defined in chgview.c */
d107 3
a109 3
extern void draw_e_axes();
extern void draw_m_axes();
extern void draw_v_axes();
d114 1
a114 1
extern void draw_grid();		/* grid.c */
d116 2
a117 2
extern void draw_rect();		/* rect.c */
extern void paint_rect_area();
d120 1
a120 1
extern void predictor_init();
d130 1
a130 1
extern int mged_link_vars();
d133 1
a133 1
extern void set_localunit_TclVar();
d166 1
a166 1
int             cmd_stuff_str();
d168 5
a172 9
#ifndef WIN32
void		sig2(), sig3();
#else
void		sig2(int sig), sig3(int sig);
#endif
void		reset_input_strings();
void		new_mats();
void		usejoy();
void            slewview();
d201 4
a204 4
static void     mged_insert_char();
static void	mged_process_char();
static int	do_rc();
static void	log_event();
d210 2
a211 2
void pr_prompt(), pr_beep();
int mged_bomb_hook();
d213 1
a213 1
void mged_view_obj_callback();
d233 1
a233 3
main(argc,argv)
int argc;
char **argv;
d627 1
a627 1
pr_prompt()
d634 1
a634 1
pr_beep()
d651 1
a651 1
extern struct bu_vls *history_prev(), *history_cur(), *history_next();
d661 1
a661 3
stdin_input(clientData, mask)
ClientData clientData;
int mask;
d781 1
a781 2
mged_process_char(ch)
char ch;
d1199 1
a1199 2
mged_insert_char(ch)
char ch;
d1224 1
a1224 5
cmd_stuff_str(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1251 1
a1251 3
std_out_or_err(clientData, mask)
ClientData clientData;
int mask;
d1619 1
a1619 1
refresh()
d1783 1
a1783 3
log_event( event, arg )
char *event;
char *arg;
d1843 1
a1843 2
mged_finish( exitcode )
int	exitcode;
d1885 1
a1885 1
quit()
d1896 1
a1896 1
sig2()
d1903 3
d1907 1
a1907 1
sig3()
d1929 1
d1962 1
a1962 1
new_mats()
d1969 1
a1969 1
new_edit_mats()
d2014 1
a2014 1
do_rc()
d2446 1
a2446 3
mged_bomb_hook(clientData, str)
     genptr_t clientData;
     genptr_t str;
@


11.220
log
@merge of windows-6-0-branch into head
@
text
@d511 15
a525 15
	      struct bu_vls vls;
	      int status;

	      /* make this a process group leader */
	      setpgid(0, 0);

	      bu_vls_init(&vls);
	      bu_vls_strcpy(&vls, "gui");
	      status = Tcl_Eval(interp, bu_vls_addr(&vls));
	      bu_vls_free(&vls);

	      if (status != TCL_OK) {
		bu_log("%s", interp->result);
		exit(1);
	      }
d528 12
a539 12
	      (void)pipe(pipe_out);
	      (void)pipe(pipe_err);

	      /* Redirect stdout */
	      (void)close(1);
	      (void)dup(pipe_out[1]);
	      (void)close(pipe_out[1]);

	      /* Redirect stderr */
	      (void)close(2);
	      (void)dup(pipe_err[1]);
	      (void)close(pipe_err[1]);
d542 2
a543 2
	      /* close stdin */
	      (void)close(0);
a544 1
	    }
a545 3
	    else{
	      exit(0);
	    }
@


11.219
log
@update copyright to include span through 2003
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.218 2003/04/01 13:56:13 jra Exp $ (BRL)";
d62 1
d64 1
d87 8
d98 6
d168 1
d170 3
d220 1
d224 4
d245 9
d266 1
d268 3
d311 1
d313 1
d500 1
a500 1
#if 1
a504 1
#endif
d527 1
d541 1
a541 1
#if 0
d544 7
a550 1
#endif
d579 1
d582 5
d604 1
d610 8
d678 1
d680 3
d684 1
d686 3
d760 5
a765 1
      count = read((int)fd, (void *)buf, 4096);
d771 1
a771 1
    if (count <= 0 && feof(stdin)){
d1273 1
d1275 3
d1284 2
a1285 1
#if 1
d1288 1
a1288 1
  if((count = read((int)fd, line, 5120)) == 0)
d1817 1
d1826 14
d1841 1
d1846 7
d1917 1
d1932 16
d2173 1
d2178 6
@


11.218
log
@Added output message about backgrounding, to keep users aware
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1993 by the United States Army
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.217 2003/03/26 03:45:46 jra Exp $ (BRL)";
@


11.218.6.1
log
@merge from HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.219 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.218.6.2
log
@merge from head
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.218.6.1 2004/02/12 18:34:14 erikg Exp $ (BRL)";
@


11.218.6.3
log
@merge from head
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a61 1
#ifndef WIN32
a62 1
#endif
a84 8
#ifdef WIN32
#include <fcntl.h>
#include <errno.h>
#define R_OK 2
#define W_OK 4
#endif

#ifndef WIN32
a87 6
#else
#ifndef	LOGFILE
#define LOGFILE	"C:\\gedlog"	/* usage log */
#endif
#endif

a151 1
#ifndef WIN32
a152 3
#else
void		sig2(int sig), sig3(int sig);
#endif
a199 1
#ifndef WIN32
a202 4
void stdin_input(ClientData clientData,int mask);
void std_out_or_err(ClientData clientData,int mask);
#endif
#else
a219 9
#ifdef WIN32
	Tcl_Channel chan;
#endif


#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a231 1
#ifndef WIN32
a232 3
#else
				MessageBox(NULL,"-c OPTION NOT AVAILABLE","NOT SUPPORTED",MB_OK);
#endif
a272 1
#ifndef WIN32
a273 1
#endif
d460 1
a460 1

d465 1
d472 18
a489 15
	    struct bu_vls vls;
	    int status;
	    
	    /* make this a process group leader */
	    setpgid(0, 0);
	    
	    bu_vls_init(&vls);
	    bu_vls_strcpy(&vls, "gui");
	    status = Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    
	    if (status != TCL_OK) {
	      bu_log("%s", interp->result);
	      exit(1);
	    }
d491 9
a499 19
#ifndef WIN32
	    (void)pipe(pipe_out);
	    (void)pipe(pipe_err);
	    
	    /* Redirect stdout */
	    (void)close(1);
	    (void)dup(pipe_out[1]);
	    (void)close(pipe_out[1]);
	    
	    /* Redirect stderr */
	    (void)close(2);
	    (void)dup(pipe_err[1]);
	    (void)close(pipe_err[1]);

#  if 0
	    /* close stdin */
	    (void)close(0);
#  endif
#endif  /* WIN32 */
d501 4
a532 1
#ifndef WIN32
a534 5
#else
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_INPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      stdin_input, (ClientData)GetStdHandle(STD_INPUT_HANDLE));
#endif
a551 1
#ifndef WIN32
a556 8
#else
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_OUTPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_OUTPUT_HANDLE));
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_ERROR_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_ERROR_HANDLE));
#endif
a616 1
#ifndef WIN32
a617 3
#else
	HANDLE fd;
#endif
a618 1
#ifndef WIN32
a619 3
#else	
    fd = (HANDLE)clientData;      
#endif
d691 1
a691 3
#  ifdef WIN32
      ReadFile(fd,buf,4096,&count,NULL);
#  else
a692 2
#  endif

d698 1
a698 1
    if (count <= 0 && feof(stdin)) {
a1199 1
#ifndef WIN32
a1200 3
#else
  HANDLE fd = clientData;
#endif  
d1207 1
a1207 2

#ifndef WIN32
d1210 1
a1210 1
  if((!ReadFile(fd, line, MAXLINE,&count,0)))
a1738 1
#ifndef WIN32
a1746 14
#else
	{
		char uname[256]; 
		DWORD dwNumBytes = 256; 
		GetUserName(uname, &dwNumBytes);
		bu_vls_printf(&line, "%s [%s] time=%ld uid=%d (%s) %s\n",
		      event,
		      dmp->dm_name,
		      (long)now,
		      uname,
		      timep,
		      arg);
	}
#endif
a1747 1
#ifndef WIN32
a1751 7
#else
	if( (logfd = open( LOGFILE, _O_WRONLY|_O_APPEND )) >= 0 )  {
		(void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
		(void)close( logfd );
	}
#endif

a1815 1
#ifndef WIN32
a1829 16
#else
void
sig2(int sig)
{
  reset_input_strings();

  (void)signal( SIGINT, SIG_IGN );
}

void
sig3(int sig)
{
  (void)signal( SIGINT, SIG_IGN );
  longjmp( jmp_env, 1 );
}
#endif
a2054 1
#ifndef WIN32
a2058 6
#else
		if ((access(argv[1], R_OK) != 0 || access(argv[1], W_OK) != 0)  && errno != ENOENT) {
			perror(argv[1]);
			return TCL_ERROR;
		}
#endif
@


11.217
log
@Added a three second sleep after fork and before parent exits.
Less likely to appear that MGED died.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.216 2003/03/13 19:46:50 jra Exp $ (BRL)";
d289 1
@


11.216
log
@Moved fork earlier so that all tcl/tk stuff comes after the fork
This is a fall-out of updating to tcl/tk 8.4
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.215 2002/08/20 17:08:23 jra Exp $ (BRL)";
d289 1
@


11.215
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.213 2002/08/12 18:25:38 morrison Exp $ (BRL)";
d284 9
a469 2

	    if ((fork()) == 0){
a502 4
	    }else{
	      exit(0);
	    }

@


11.215.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.215 2002/08/20 17:08:23 jra Exp $ (BRL)";
a61 1
#ifndef WIN32
a62 1
#endif
a84 8
#ifdef WIN32
#include <fcntl.h>
#include <errno.h>
#define R_OK 2
#define W_OK 4
#endif

#ifndef WIN32
a87 6
#else
#ifndef	LOGFILE
#define LOGFILE	"C:\\gedlog"	/* usage log */
#endif
#endif

a151 1
#ifndef WIN32
a152 3
#else
void		sig2(int sig), sig3(int sig);
#endif
a199 1
#ifndef WIN32
a202 4
void stdin_input(ClientData clientData,int mask);
void std_out_or_err(ClientData clientData,int mask);
#endif
#else
a219 9
#ifdef WIN32
	Tcl_Channel chan;
#endif


#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a231 1
#ifndef WIN32
a232 3
#else
				MessageBox(NULL,"-c OPTION NOT AVAILABLE","NOT SUPPORTED",MB_OK);
#endif
a272 1
#ifndef WIN32
a273 1
#endif
a460 16
#ifdef WIN32
		  if(1) {
	      struct bu_vls vls;
	      int status;

	      bu_vls_init(&vls);
	      bu_vls_strcpy(&vls, "gui");
	      status = Tcl_Eval(interp, bu_vls_addr(&vls));
	      bu_vls_free(&vls);

	      if (status != TCL_OK) {
		bu_log("%s", interp->result);
		exit(1);
	      }
	    }
#else
d496 1
a496 3
	    }
#endif
		else{
a527 1
#ifndef WIN32
a529 5
#else
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_INPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      stdin_input, (ClientData)GetStdHandle(STD_INPUT_HANDLE));
#endif
a546 1
#ifndef WIN32
a551 8
#else
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_OUTPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_OUTPUT_HANDLE));
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_ERROR_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_ERROR_HANDLE));
#endif
a611 1
#ifndef WIN32
a612 3
#else
	HANDLE fd;
#endif
a613 1
#ifndef WIN32
a614 3
#else	
	fd = (HANDLE)clientData;      
#endif
a685 5
#ifdef WIN32
	ReadFile(fd,buf,4096,&count,NULL);
#else
      count = read((int)fd, (void *)buf, 4096)
#endif
d687 1
a1194 1
#ifndef WIN32
a1195 3
#else
  HANDLE fd = clientData;
#endif  
a1201 2

#ifndef WIN32
a1206 7
#else
#if 1
  if((!ReadFile(fd, line, MAXLINE,&count,0)))
#else
  if((!ReadFile(fd, line, 5120,&count,0)))
#endif
#endif
a1733 1
#ifndef WIN32
a1741 14
#else
	{
		char uname[256]; 
		DWORD dwNumBytes = 256; 
		GetUserName(uname, &dwNumBytes);
		bu_vls_printf(&line, "%s [%s] time=%ld uid=%d (%s) %s\n",
		      event,
		      dmp->dm_name,
		      (long)now,
		      uname,
		      timep,
		      arg);
	}
#endif
a1742 1
#ifndef WIN32
a1746 7
#else
	if( (logfd = open( LOGFILE, _O_WRONLY|_O_APPEND )) >= 0 )  {
		(void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
		(void)close( logfd );
	}
#endif

a1810 1
#ifndef WIN32
a1824 16
#else
void
sig2(int sig)
{
  reset_input_strings();

  (void)signal( SIGINT, SIG_IGN );
}

void
sig3(int sig)
{
  (void)signal( SIGINT, SIG_IGN );
  longjmp( jmp_env, 1 );
}
#endif
a2049 1
#ifndef WIN32
a2053 6
#else
		if ((access(argv[1], R_OK) != 0 || access(argv[1], W_OK) != 0)  && errno != ENOENT) {
			perror(argv[1]);
			return TCL_ERROR;
		}
#endif
@


11.215.4.2
log
@sync to HEAD...
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/ged.c,v 11.215.4.1 2002/09/26 23:04:11 morrison Exp $ (BRL)";
a323 11
	if( !classic_mged ) {
		pid_t pid;

		pid = fork();
		if( pid > 0 ) {
			fprintf( stdout, "Backgrounding, please wait...\n" );
			sleep( 3 );	/* just so it does not appear that MGED has died */
			exit( 0 );
		}
	}

d502 1
a502 1
	    if(1) {
d553 2
a554 2
#endif  /* windows */
	    else{
@


11.215.4.3
log
@use the define instead of the hard-coded constant
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d705 1
a705 1
    fd = (HANDLE)clientData;      
d778 5
a782 5
#  ifdef WIN32
      ReadFile(fd,buf,4096,&count,NULL);
#  else
      count = read((int)fd, (void *)buf, 4096);
#  endif
d789 1
a789 1
    if (count <= 0 && feof(stdin)) {
d1304 1
d1307 4
d1312 3
@


11.215.4.4
log
@simplify defines for windows
@
text
@d500 1
a500 1

d505 1
d512 16
a545 1
#ifndef WIN32
d559 1
a559 1
#  if 0
d562 1
a562 1
#  endif
d564 1
a564 1
#endif  /* WIN32 */
@


11.215.4.5
log
@remerge head into branch just in case someone checks out this branch later
@
text
@d511 17
a527 15
	    struct bu_vls vls;
	    int status;
	    
	    /* make this a process group leader */
	    setpgid(0, 0);
	    
	    bu_vls_init(&vls);
	    bu_vls_strcpy(&vls, "gui");
	    status = Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    
	    if (status != TCL_OK) {
	      bu_log("%s", interp->result);
	      exit(1);
	    }
d530 12
a541 12
	    (void)pipe(pipe_out);
	    (void)pipe(pipe_err);
	    
	    /* Redirect stdout */
	    (void)close(1);
	    (void)dup(pipe_out[1]);
	    (void)close(pipe_out[1]);
	    
	    /* Redirect stderr */
	    (void)close(2);
	    (void)dup(pipe_err[1]);
	    (void)close(pipe_err[1]);
d544 2
a545 2
	    /* close stdin */
	    (void)close(0);
d547 1
d549 3
@


11.215.2.1
log
@Initial ANSIfication
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.215 2002/08/20 17:08:23 jra Exp $ (BRL)";
d89 1
a89 1
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */
d91 3
a93 3
extern void draw_e_axes(void);
extern void draw_m_axes(void);
extern void draw_v_axes(void);
d98 1
a98 1
extern void draw_grid(void);		/* grid.c */
d100 2
a101 2
extern void draw_rect(void);		/* rect.c */
extern void paint_rect_area(void);
d104 1
a104 1
extern void predictor_init(void);
d114 1
a114 1
extern int mged_link_vars(struct dm_list *p);
d117 1
a117 1
extern void set_localunit_TclVar(void);
d150 1
a150 1
int             cmd_stuff_str(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d152 5
a156 5
void		sig2(void), sig3(void);
void		reset_input_strings(void);
void		new_mats(void);
void		usejoy(double xangle, double yangle, double zangle);
void            slewview(fastf_t *view_pos);
d185 4
a188 4
static void     mged_insert_char(char ch);
static void	mged_process_char(char ch);
static int	do_rc(void);
static void	log_event(char *event, char *arg);
d194 2
a195 2
void pr_prompt(void), pr_beep(void);
int mged_bomb_hook(genptr_t clientData, genptr_t str);
d197 1
a197 1
void mged_view_obj_callback(genptr_t clientData, struct view_obj *vop);
d212 3
a214 1
main(int argc, char **argv)
d571 1
a571 1
pr_prompt(void)
d578 1
a578 1
pr_beep(void)
d595 1
a595 1
extern struct bu_vls *history_prev(void), *history_cur(void), *history_next(void);
d605 3
a607 1
stdin_input(ClientData clientData, int mask)
d715 2
a716 1
mged_process_char(char ch)
d1134 2
a1135 1
mged_insert_char(char ch)
d1160 5
a1164 1
cmd_stuff_str(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1191 3
a1193 1
std_out_or_err(ClientData clientData, int mask)
d1556 1
a1556 1
refresh(void)
d1720 3
a1722 1
log_event(char *event, char *arg)
d1759 2
a1760 1
mged_finish(int exitcode)
d1802 1
a1802 1
quit(void)
d1812 1
a1812 1
sig2(void)
d1820 1
a1820 1
sig3(void)
d1827 1
a1827 1
reset_input_strings(void)
d1858 1
a1858 1
new_mats(void)
d1865 1
a1865 1
new_edit_mats(void)
d1910 1
a1910 1
do_rc(void)
d2335 3
a2337 1
mged_bomb_hook(genptr_t clientData, genptr_t str)
@


11.215.2.2
log
@sync branch with HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a61 1
#ifndef WIN32
a62 1
#endif
a84 8
#ifdef WIN32
#include <fcntl.h>
#include <errno.h>
#define R_OK 2
#define W_OK 4
#endif

#ifndef WIN32
a87 6
#else
#ifndef	LOGFILE
#define LOGFILE	"C:\\gedlog"	/* usage log */
#endif
#endif

a199 1
#ifndef WIN32
a202 4
void stdin_input(ClientData clientData,int mask);
void std_out_or_err(ClientData clientData,int mask);
#endif
#else
a217 9
#ifdef WIN32
	Tcl_Channel chan;
#endif


#ifdef WIN32
	_fmode = _O_BINARY;
#endif

a229 1
#ifndef WIN32
a230 3
#else
				MessageBox(NULL,"-c OPTION NOT AVAILABLE","NOT SUPPORTED",MB_OK);
#endif
a270 1
#ifndef WIN32
a271 1
#endif
a281 11
	if( !classic_mged ) {
		pid_t pid;

		pid = fork();
		if( pid > 0 ) {
			fprintf( stdout, "Backgrounding, please wait...\n" );
			sleep( 3 );	/* just so it does not appear that MGED has died */
			exit( 0 );
		}
	}

d447 1
a447 1

d452 1
d459 37
a495 14
	    struct bu_vls vls;
	    int status;
	    
	    /* make this a process group leader */
	    setpgid(0, 0);
	    
	    bu_vls_init(&vls);
	    bu_vls_strcpy(&vls, "gui");
	    status = Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    
	    if (status != TCL_OK) {
	      bu_log("%s", interp->result);
	      exit(1);
a497 20
#ifndef WIN32
	    (void)pipe(pipe_out);
	    (void)pipe(pipe_err);
	    
	    /* Redirect stdout */
	    (void)close(1);
	    (void)dup(pipe_out[1]);
	    (void)close(pipe_out[1]);
	    
	    /* Redirect stderr */
	    (void)close(2);
	    (void)dup(pipe_err[1]);
	    (void)close(pipe_err[1]);

#  if 0
	    /* close stdin */
	    (void)close(0);
#  endif
#endif  /* WIN32 */

a525 1
#ifndef WIN32
a527 5
#else
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_INPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      stdin_input, (ClientData)GetStdHandle(STD_INPUT_HANDLE));
#endif
a544 1
#ifndef WIN32
a549 8
#else
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_OUTPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_OUTPUT_HANDLE));
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_ERROR_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_ERROR_HANDLE));
#endif
a607 1
#ifndef WIN32
a608 3
#else
	HANDLE fd;
#endif
a609 1
#ifndef WIN32
a610 3
#else	
    fd = (HANDLE)clientData;      
#endif
d682 1
a682 3
#  ifdef WIN32
      ReadFile(fd,buf,4096,&count,NULL);
#  else
a683 2
#  endif

d689 1
a689 1
    if (count <= 0 && feof(stdin)) {
a1182 1
#ifndef WIN32
a1183 3
#else
  HANDLE fd = clientData;
#endif  
d1190 1
a1190 2

#ifndef WIN32
d1193 1
a1193 1
  if((!ReadFile(fd, line, MAXLINE,&count,0)))
a1719 1
#ifndef WIN32
a1727 14
#else
	{
		char uname[256]; 
		DWORD dwNumBytes = 256; 
		GetUserName(uname, &dwNumBytes);
		bu_vls_printf(&line, "%s [%s] time=%ld uid=%d (%s) %s\n",
		      event,
		      dmp->dm_name,
		      (long)now,
		      uname,
		      timep,
		      arg);
	}
#endif
a1728 1
#ifndef WIN32
a1732 7
#else
	if( (logfd = open( LOGFILE, _O_WRONLY|_O_APPEND )) >= 0 )  {
		(void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
		(void)close( logfd );
	}
#endif

a1795 1
#ifndef WIN32
a1809 8
#else
void
sig2(int sig)
{
  reset_input_strings();

  (void)signal( SIGINT, SIG_IGN );
}
d1812 1
a1812 9
sig3(int sig)
{
  (void)signal( SIGINT, SIG_IGN );
  longjmp( jmp_env, 1 );
}
#endif

void
reset_input_strings()
a2034 1
#ifndef WIN32
a2038 6
#else
		if ((access(argv[1], R_OK) != 0 || access(argv[1], W_OK) != 0)  && errno != ENOENT) {
			perror(argv[1]);
			return TCL_ERROR;
		}
#endif
@


11.215.2.3
log
@no need for win32 section, since we all can use the same thing for the sginal() hook function
@
text
@d168 1
a168 1
void		sig2(int), sig3(int);
d1894 16
a1917 3
/*
 *  			S I G 3
 */
d1924 1
a1924 1

@


11.214
log
@Converted from K&R to ANSI C - RFH
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.212 2001/12/12 18:45:32 bparker Exp $ (BRL)";
d89 1
a89 1
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */
d91 3
a93 3
extern void draw_e_axes(void);
extern void draw_m_axes(void);
extern void draw_v_axes(void);
d98 1
a98 1
extern void draw_grid(void);		/* grid.c */
d100 2
a101 2
extern void draw_rect(void);		/* rect.c */
extern void paint_rect_area(void);
d104 1
a104 1
extern void predictor_init(void);
d114 1
a114 1
extern int mged_link_vars(struct dm_list *p);
d117 1
a117 1
extern void set_localunit_TclVar(void);
d150 1
a150 1
int             cmd_stuff_str(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d152 5
a156 5
void		sig2(void), sig3(void);
void		reset_input_strings(void);
void		new_mats(void);
void		usejoy(double xangle, double yangle, double zangle);
void            slewview(fastf_t *view_pos);
d185 4
a188 4
static void     mged_insert_char(char ch);
static void	mged_process_char(char ch);
static int	do_rc(void);
static void	log_event(char *event, char *arg);
d194 2
a195 2
void pr_prompt(void), pr_beep(void);
int mged_bomb_hook(genptr_t clientData, genptr_t str);
d197 1
a197 1
void mged_view_obj_callback(genptr_t clientData, struct view_obj *vop);
d212 3
a214 1
main(int argc, char **argv)
d571 1
a571 1
pr_prompt(void)
d578 1
a578 1
pr_beep(void)
d595 1
a595 1
extern struct bu_vls *history_prev(void), *history_cur(void), *history_next(void);
d605 3
a607 1
stdin_input(ClientData clientData, int mask)
d715 2
a716 1
mged_process_char(char ch)
d1134 2
a1135 1
mged_insert_char(char ch)
d1160 5
a1164 1
cmd_stuff_str(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1191 3
a1193 1
std_out_or_err(ClientData clientData, int mask)
d1556 1
a1556 1
refresh(void)
d1720 3
a1722 1
log_event(char *event, char *arg)
d1759 2
a1760 1
mged_finish(int exitcode)
d1802 1
a1802 1
quit(void)
d1812 1
a1812 1
sig2(void)
d1820 1
a1820 1
sig3(void)
d1827 1
a1827 1
reset_input_strings(void)
d1858 1
a1858 1
new_mats(void)
d1865 1
a1865 1
new_edit_mats(void)
d1910 1
a1910 1
do_rc(void)
a2005 3
	bu_vls_init(&vls);
	bu_vls_init(&msg);

a2006 2
		bu_vls_free(&vls);
		bu_vls_free(&msg);
a2020 2
		bu_vls_free(&vls);
		bu_vls_free(&msg);
d2024 3
d2275 59
d2335 3
a2337 1
mged_bomb_hook(genptr_t clientData, genptr_t str)
@


11.213
log
@added closedb command
@
text
@d89 1
a89 1
extern void view_ring_init(); /* defined in chgview.c */
d91 3
a93 3
extern void draw_e_axes();
extern void draw_m_axes();
extern void draw_v_axes();
d98 1
a98 1
extern void draw_grid();		/* grid.c */
d100 2
a101 2
extern void draw_rect();		/* rect.c */
extern void paint_rect_area();
d104 1
a104 1
extern void predictor_init();
d114 1
a114 1
extern int mged_link_vars();
d117 1
a117 1
extern void set_localunit_TclVar();
d150 1
a150 1
int             cmd_stuff_str();
d152 5
a156 5
void		sig2(), sig3();
void		reset_input_strings();
void		new_mats();
void		usejoy();
void            slewview();
d185 4
a188 4
static void     mged_insert_char();
static void	mged_process_char();
static int	do_rc();
static void	log_event();
d194 2
a195 2
void pr_prompt(), pr_beep();
int mged_bomb_hook();
d197 1
a197 1
void mged_view_obj_callback();
d212 1
a212 3
main(argc,argv)
int argc;
char **argv;
d569 1
a569 1
pr_prompt()
d576 1
a576 1
pr_beep()
d593 1
a593 1
extern struct bu_vls *history_prev(), *history_cur(), *history_next();
d603 1
a603 3
stdin_input(clientData, mask)
ClientData clientData;
int mask;
d711 1
a711 2
mged_process_char(ch)
char ch;
d1129 1
a1129 2
mged_insert_char(ch)
char ch;
d1154 1
a1154 5
cmd_stuff_str(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d1181 1
a1181 3
std_out_or_err(clientData, mask)
ClientData clientData;
int mask;
d1544 1
a1544 1
refresh()
d1708 1
a1708 3
log_event( event, arg )
char *event;
char *arg;
d1745 1
a1745 2
mged_finish( exitcode )
int	exitcode;
d1787 1
a1787 1
quit()
d1797 1
a1797 1
sig2()
d1805 1
a1805 1
sig3()
d1812 1
a1812 1
reset_input_strings()
d1843 1
a1843 1
new_mats()
d1850 1
a1850 1
new_edit_mats()
d1895 1
a1895 1
do_rc()
d1991 3
d1995 2
d2011 2
a2015 3
	bu_vls_init(&vls);
	bu_vls_init(&msg);

a2263 59

/*
 *			F _ C L O S E D B
 *
 *  Close the current database, if open.
 *
 */
int
f_closedb(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	char *av[2];

	if( argc != 1 )  {
		Tcl_Eval(interp, "help closedb");
		return TCL_ERROR;
	}

	if (dbip == DBI_NULL) {
		Tcl_AppendResult(interp, "No database is open\n", (char *)NULL);
		return TCL_OK;
	}

	/* Clear out anything in the display */
	av[0] = "zap";
	av[1] = NULL;
	cmd_zap(clientData, interp, 1, av);

	/* Close the Tcl database objects */
#if 0
	Tcl_Eval(interp, "db close; .inmem close");
#else
	Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
#endif
	
	log_event( "CEASE", "(close)" );

	/* update any and all other displays */
	{
		register struct dm_list *dmlp;
		
		/* update local2base and base2local variables for all view objects */
		FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
			dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
			dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
		}
	}
	
	/* wipe out the global pointers */
	dbip = DBI_NULL;
	rt_material_head = MATER_NULL;

	return TCL_OK;
}


d2265 1
a2265 3
mged_bomb_hook(clientData, str)
     genptr_t clientData;
     genptr_t str;
@


11.212
log
@*- now using rename to destroy the database object instance
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.211 2001/10/17 07:40:05 morrison Exp $ (BRL)";
a2005 3
	bu_vls_init(&vls);
	bu_vls_init(&msg);

a2006 2
		bu_vls_free(&vls);
		bu_vls_free(&msg);
a2020 2
		bu_vls_free(&vls);
		bu_vls_free(&msg);
d2024 3
d2274 59
@


11.211
log
@Mac OS X warning and error fixes for non-production build
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.210 2001/10/05 21:22:02 bparker Exp $ (BRL)";
d1776 1
d1778 3
d2167 1
d2169 3
@


11.210
log
@*- mods to f_opendb to honor db_warn and db_upgrade
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.209 2001/10/04 16:01:32 bparker Exp $ (BRL)";
d65 1
a65 1
#include "tk.h"
d67 1
a67 1
#include "tcl.h"
@


11.209
log
@*- changed create_db4 to db_version
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.208 2001/10/04 15:40:55 bparker Exp $ (BRL)";
d171 2
a172 3
 * 0 - warn
 * 1 - no warn, prompt to convert database
 * 2 - no warn, convert database
d174 7
a180 1
int db_nowarn = 0;
d1996 5
a2000 4
	struct db_i *save_dbip;
	struct mater *save_materp;
	struct bu_vls vls;
	struct bu_vls msg;	/* use this to hold returned message */
d2137 1
d2237 1
a2237 1
	if( interactive )
d2239 23
a2261 1
		    bu_units_string(dbip->dbi_local2base) );
@


11.208
log
@*- define the following variables which are
   linked to Tcl variables: db_nowarn, create_db4
*- mods to f_opendb to look at the create_db4
   variable to determine what version of the database
   to create
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.207 2001/08/11 13:16:11 butler Exp $ (BRL)";
d177 2
a178 2
/* force creation of db4 databases */
int create_db4 = 0;
d2108 1
a2108 1
		if ((dbip = db_create(argv[1], create_db4 ? 4 : 5)) == DBI_NULL) {
@


11.207
log
@misc compiler warning changes
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.206 2001/06/05 15:51:41 bparker Exp $ (BRL)";
d170 10
d2108 1
a2108 1
		if( (dbip = db_create( argv[1], 5 )) == DBI_NULL )  {
@


11.206
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.205 2001/06/01 19:23:24 bparker Exp $ (BRL)";
d220 1
a220 1
				sscanf( bu_optarg, "%x", &rt_g.debug );
d223 1
a223 1
	                        sscanf( bu_optarg, "%x", &bu_debug );
@


11.205
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.204 2001/04/20 20:08:58 bparker Exp $ (BRL)";
a181 1
#ifdef MGED_USE_VIEW_OBJ
a182 1
#endif
a340 8
#ifndef MGED_USE_VIEW_OBJ
	/* init rotation matrix */
	view_state->vs_Viewscale = 500;		/* => viewsize of 1000mm (1m) */
	MAT_IDN( view_state->vs_Viewrot );
	MAT_IDN( view_state->vs_toViewcenter );
	MAT_DELTAS_GET_NEG(view_state->vs_orig_pos, view_state->vs_toViewcenter);
	view_state->vs_i_Viewscale = view_state->vs_Viewscale;
#endif
a1374 1
#ifdef MGED_USE_VIEW_OBJ
a1377 5
#else
		    edit_rate_model_tran[X] * 0.05 * view_state->vs_Viewscale * base2local,
		    edit_rate_model_tran[Y] * 0.05 * view_state->vs_Viewscale * base2local,
		    edit_rate_model_tran[Z] * 0.05 * view_state->vs_Viewscale * base2local);
#endif
a1408 1
#ifdef MGED_USE_VIEW_OBJ
a1411 5
#else
		    edit_rate_view_tran[X] * 0.05 * view_state->vs_Viewscale * base2local,
		    edit_rate_view_tran[Y] * 0.05 * view_state->vs_Viewscale * base2local,
		    edit_rate_view_tran[Z] * 0.05 * view_state->vs_Viewscale * base2local);
#endif
a1474 1
#ifdef MGED_USE_VIEW_OBJ
a1477 5
#else
		      view_state->vs_rate_model_tran[X] * 0.05 * view_state->vs_Viewscale * base2local,
		      view_state->vs_rate_model_tran[Y] * 0.05 * view_state->vs_Viewscale * base2local,
		      view_state->vs_rate_model_tran[Z] * 0.05 * view_state->vs_Viewscale * base2local);
#endif
a1501 1
#ifdef MGED_USE_VIEW_OBJ
a1504 5
#else
		      view_state->vs_rate_tran[X] * 0.05 * view_state->vs_Viewscale * base2local,
		      view_state->vs_rate_tran[Y] * 0.05 * view_state->vs_Viewscale * base2local,
		      view_state->vs_rate_tran[Z] * 0.05 * view_state->vs_Viewscale * base2local);
#endif
a1840 1
#ifdef MGED_USE_VIEW_OBJ
a1841 46
#else
	bn_mat_mul( view_state->vs_model2view, view_state->vs_Viewrot, view_state->vs_toViewcenter );
	view_state->vs_model2view[15] = view_state->vs_Viewscale;
	bn_mat_inv( view_state->vs_view2model, view_state->vs_model2view );

#if 1
	{
	  vect_t work, work1;
	  vect_t temp, temp1;

	  /* Find current azimuth, elevation, and twist angles */
	  VSET( work , 0.0, 0.0, 1.0 );       /* view z-direction */
	  MAT4X3VEC( temp , view_state->vs_view2model , work );
	  VSET( work1 , 1.0, 0.0, 0.0 );      /* view x-direction */
	  MAT4X3VEC( temp1 , view_state->vs_view2model , work1 );

	  /* calculate angles using accuracy of 0.005, since display
	   * shows 2 digits right of decimal point */
	  bn_aet_vec( &view_state->vs_azimuth,
		       &view_state->vs_elevation,
		       &view_state->vs_twist,
		       temp , temp1 , (fastf_t)0.005 );
#if 1
	  /* Force azimuth range to be [0,360] */
	  if((NEAR_ZERO(view_state->vs_elevation - 90.0,(fastf_t)0.005) ||
	     NEAR_ZERO(view_state->vs_elevation + 90.0,(fastf_t)0.005)) &&
	     view_state->vs_azimuth < 0 &&
	     !NEAR_ZERO(view_state->vs_azimuth,(fastf_t)0.005))
	    view_state->vs_azimuth += 360.0;
	  else if(NEAR_ZERO(view_state->vs_azimuth,(fastf_t)0.005))
	    view_state->vs_azimuth = 0.0;
#else
	  /* Force azimuth range to be [-180,180] */
	  if(!NEAR_ZERO(view_state->vs_elevation - 90.0,(fastf_t)0.005) &&
	      !NEAR_ZERO(view_state->vs_elevation + 90.0,(fastf_t)0.005))
	    view_state->vs_azimuth -= 180;
#endif
	}
#endif

	if( state != ST_VIEW ) {
	  bn_mat_mul( view_state->vs_model2objview, view_state->vs_model2view, modelchanges );
	  bn_mat_inv( view_state->vs_objview2model, view_state->vs_model2objview );
	}
	view_state->vs_flag = 1;
#endif
a1856 1
#ifdef MGED_USE_VIEW_OBJ
a1857 3
#else
    bn_mat_mul( view_state->vs_model2objview, view_state->vs_model2view, modelchanges );
#endif
a1865 1
#ifdef MGED_USE_VIEW_OBJ
a1877 1
#endif
a2147 6
#if 0
		wdb_close(wdbp);

		/* Close current database.  Releases MaterHead, etc. too. */
		db_close(dbip);
#endif
a2153 1
#ifdef MGED_USE_VIEW_OBJ
a2162 1
#endif
d2175 1
a2175 17
#if 0
	/* Establish LIBWDB TCL access to both disk and in-memory databases */
	/* This creates "db" and ".inmem" Tcl objects */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls,
		      "set wdbp [wdb_open %s disk [get_dbip]]; wdb_open %s inmem [get_dbip]",
		      MGED_DB_NAME, MGED_INMEM_NAME);
	if( Tcl_Eval( interp, bu_vls_addr(&vls) ) != TCL_OK )  {
		bu_vls_printf(&msg, "%s\n%s\n",
		    interp->result,
		    Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}
#else
d2199 1
a2200 1
#endif
@


11.204
log
@*- we had essentially three wdb_objs (mged's built-in one,
   db and .inmem). We're now down to two: db and .inmem.
   MGED's built-in one shares with db's. This is part of MGED's
   transition toward using LIBRT's wdb_obj routines.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.203 2001/04/02 21:20:40 bparker Exp $ (BRL)";
d83 1
d144 1
d182 4
d343 1
a347 1
	MAT_IDN( view_state->vs_ModelDelta );
d350 2
a376 2
	new_mats();

d387 2
d393 1
d403 1
a403 1
	setview( 0.0, 0.0, 0.0 );
d1385 5
d1393 1
d1425 5
d1433 1
d1497 5
d1505 1
d1530 5
d1538 1
d1875 3
d1922 1
d1938 3
d1942 1
d1951 15
d2230 1
a2230 1
		f_zap(clientData, interp, 1, av);
d2247 12
d2309 2
@


11.203
log
@*- remove Tk dependencies
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.202 2001/03/31 01:57:23 morrison Exp $ (BRL)";
d1763 8
a1770 2
	if( wdbp )  wdb_close(wdbp);
	if( dbip )  db_close(dbip);
d2178 2
d2184 1
d2202 1
d2218 24
a2290 1
	     
@


11.202
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.201 2001/03/22 14:32:58 bparker Exp $ (BRL)";
d64 1
d66 3
d107 2
d110 1
d157 1
d159 3
d442 2
a443 1
	  if(classic_mged)
d445 2
a446 1
	  else{
@


11.201
log
@*- call bu_vls_trunc before building command to create
   the db and .inmem objects
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/ged.c,v 11.200 2001/03/21 20:14:14 bparker Exp $ (BRL)";
d328 3
a330 3
	bn_mat_idn( view_state->vs_Viewrot );
	bn_mat_idn( view_state->vs_toViewcenter );
	bn_mat_idn( view_state->vs_ModelDelta );
d338 3
a340 3
	bn_mat_idn( identity );		/* Handy to have around */
	bn_mat_idn( modelchanges );
	bn_mat_idn( acc_rot_sol );
@


11.200
log
@*- make use of MGED_DB_NAME and MGED_INMEM_NAME
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/ged.c,v 11.199 2001/02/23 20:24:38 bparker Exp $ (BRL)";
d2182 1
@


11.199
log
@*- mods that save the Tcl result string
   and restore it after a Tcl_Eval
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.198 2001/02/16 22:43:43 bparker Exp $ (BRL)";
d2182 3
a2184 1
	bu_vls_strcpy(&vls, "set wdbp [wdb_open db disk [get_dbip]]; wdb_open .inmem inmem [get_dbip]");
@


11.198
log
@*- check if (dbip == DBI_NULL) before doing anything
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.197 2000/11/16 21:20:29 bparker Exp $ (BRL)";
d1172 1
d1184 3
d1191 3
@


11.197
log
@Add rt_abort command that aborts all
rt processes forked by MGED.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.196 2000/11/09 23:27:56 bparker Exp $ (BRL)";
d1223 3
@


11.196
log
@Mods to refresh() to once again
accomodate view sharing.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.195 2000/11/03 19:25:21 bparker Exp $ (BRL)";
a267 1
#if 1
d270 1
a270 1
#endif
@


11.195
log
@Remove unnecessary call to perror().
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.194 2000/11/03 18:08:46 bparker Exp $ (BRL)";
d1532 13
d1552 1
a1552 1
    if(mapped && (update_views || view_state->vs_flag || dirty)) {
a1553 1
      view_state->vs_flag = 0;
a1670 1
  update_views = 0;
@


11.194
log
@Fix for when opendb blows away the rt_material_head.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.193 2000/11/01 20:37:47 mike Exp $ (BRL)";
a2034 1
					perror( argv[1] );
@


11.193
log
@
db_create got version argument
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.192 2000/10/24 19:46:02 mike Exp $ (BRL)";
d72 1
d1729 1
d1974 1
d2015 2
d2071 1
d2082 1
d2093 1
d2124 2
d2130 5
d2140 1
d2143 3
a2145 1
		db_close(save_dbip);
a2155 4
	/* Close previous databases, if any.  Ignore errors. */
	bu_vls_strcpy(&vls, "db close; .inmem close");
	(void)Tcl_Eval( interp, bu_vls_addr(&vls) );

a2156 1
	if( wdbp )  wdb_close(wdbp);
a2160 1

@


11.192
log
@
lint
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.191 2000/09/14 20:05:58 bparker Exp $ (BRL)";
d2084 1
a2084 1
		if( (dbip = db_create( argv[1] )) == DBI_NULL )  {
@


11.191
log
@Mod that fixes a bug related to the
number of vectors being drawn being
greater than the value of vectorThreshold
(i.e. flags get set when the Tcl-crank is
turned and then clobbered when the drawing
is complete).
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.190 2000/09/08 14:34:10 bparker Exp $ (BRL)";
d1883 1
a1883 1
	FILE	*fp;
a1884 1
	int 	found;
a1887 1
	found = 0;
a1895 1
			found = 1;
d1899 1
a1899 1
	if( !found ) {
d1905 1
a1905 2
			if( (fp = fopen(bu_vls_addr(&str), "r")) != NULL )
			  found = 1;
d1909 1
a1909 1
	if( !found ) {
a1911 1
			found = 1;
d1917 1
a1917 1
	if( !found ){
@


11.190
log
@Add mged_bomb_hook() and register with bu_add_hook
if interactive and non-classic. This is so that
Chris (or anyone else) gets a dialog window if
bu_bomb is called.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.189 2000/09/08 05:55:48 mike Exp $ (BRL)";
d1539 2
a1643 2

      dirty = 0;
a1654 3

    FOR_ALL_DISPLAYS(p, &head_dm_list.l)
      p->dml_view_state->vs_flag = 0;
@


11.189
log
@
Tree routines now need resource structure.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.188 2000/09/07 02:58:52 mike Exp $ (BRL)";
d166 1
d253 1
d262 1
d267 1
d270 1
d472 2
d2199 20
@


11.188
log
@
Added externs to ged.h to quiet down lint
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.187 2000/09/06 20:54:16 mike Exp $ (BRL)";
d348 2
@


11.187
log
@
libtermio.h lint
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.186 2000/08/19 03:10:46 mike Exp $ (BRL)";
d1190 1
a1190 2
event_check( non_blocking )
int	non_blocking;
d1964 5
a1968 5
f_opendb(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.186
log
@
const RCSid
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.185 2000/08/09 20:40:41 bparker Exp $ (BRL)";
d72 1
@


11.185
log
@Don't draw wireframe if framebuffer is active
and in overlay mode for entire window.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.184 2000/07/24 22:22:12 mike Exp $ (BRL)";
@


11.184
log
@
More new-libwdb-related cleanups
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.183 2000/07/24 19:27:31 mike Exp $ (BRL)";
d1550 8
a1557 8
      if(dbip != DBI_NULL){
	/* do framebuffer underlay */
	if(mged_variables->mv_fb && !mged_variables->mv_fb_overlay){
	  if(mged_variables->mv_fb_all)
	    fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
	  else if(mged_variables->mv_mouse_behavior != 'z')
	    paint_rect_area();
	}
d1559 27
a1585 12
	/*  Draw each solid in it's proper place on the screen
	 *  by applying zoom, rotation, & translation.
	 *  Calls DM_LOADMATRIX() and DM_DRAW_VLIST().
	 */
	if( dmp->dm_stereo == 0 || mged_variables->mv_eye_sep_dist <= 0 )  {
	  /* Normal viewing */
	  dozoom(0);
	} else {
	  /* Stereo viewing */
	  dozoom(1);
	  dozoom(2);
	}
a1586 7
	/* do framebuffer overlay */
	if(mged_variables->mv_fb && mged_variables->mv_fb_overlay){
	  if(mged_variables->mv_fb_all)
	    fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
	  else if(mged_variables->mv_mouse_behavior != 'z')
	    paint_rect_area();
	}
d1588 2
a1589 2
	/* Restore to non-rotated, full brightness */
	DM_NORMAL(dmp);
d1591 28
a1618 27
	/* only if not doing overlay */
	if(!mged_variables->mv_fb || mged_variables->mv_fb_overlay != 2){
	  if(rubber_band->rb_active || rubber_band->rb_draw)
	    draw_rect();

	  if(grid_state->gr_draw)
	    draw_grid();

	  /* Compute and display angle/distance cursor */
	  if (adc_state->adc_draw)
	    adcursor();

	  if(axes_state->ax_view_draw)
	    draw_v_axes();

	  if(axes_state->ax_model_draw)
	    draw_m_axes();

	  if(axes_state->ax_edit_draw &&
	     (state == ST_S_EDIT || state == ST_O_EDIT))
	    draw_e_axes();

	  /* Display titles, etc., if desired */
	  bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
	  dotitles(&tmp_vls);
	  bu_vls_trunc(&tmp_vls, 0);
	}
d1622 8
a1629 7
      if(!mged_variables->mv_fb || mged_variables->mv_fb_overlay != 2){
	/* Draw center dot */
	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_center_dot[0],
		       color_scheme->cs_center_dot[1],
		       color_scheme->cs_center_dot[2], 1);
	DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
@


11.183
log
@
Changed mged/typin.c to start using libwdb interfaces.
Which means mged/ged.c now also opens a libwdb interface.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.182 2000/07/20 23:25:56 mike Exp $ (BRL)";
d1704 1
d1711 4
d2132 1
@


11.182
log
@
db_create() calls db_dirbuild(), so we shouldn't.
Also reformatted the subroutine with CB, so that logic structure
could be determined.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181 2000/06/23 06:46:23 mike Exp $ (BRL)";
d133 1
d2126 8
a2133 1
	/* Establish TCL access to both disk and in-memory databases */
@


11.181
log
@
Changed to using version-generic db_dirbuild() routine.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.180 2000/02/22 21:21:07 bparker Exp $ (BRL)";
d1954 3
a1956 3
  struct db_i *save_dbip;
  struct bu_vls vls;
  struct bu_vls msg;	/* use this to hold returned message */
d1958 2
a1959 2
  bu_vls_init(&vls);
  bu_vls_init(&msg);
d1961 9
a1969 3
  if( argc <= 1 )  {
    bu_vls_free(&vls);
    bu_vls_free(&msg);
d1971 3
a1973 5
    /* Invoked without args, return name of current database */
    if( dbip != DBI_NULL )  {
      Tcl_AppendResult(interp, dbip->dbi_filename, (char *)NULL);
      return TCL_OK;
    }
d1975 25
a1999 3
    Tcl_AppendResult(interp, "", (char *)NULL);
    return TCL_OK;
  }
d2001 7
a2007 7
  if(3 < argc || (strlen(argv[1]) == 0)){
    bu_vls_printf(&vls, "help opendb");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    bu_vls_free(&msg);
    return TCL_ERROR;
  }
d2009 56
a2064 9
  if(argc == 3 &&
     strcmp("y", argv[2]) && strcmp("Y", argv[2]) &&
     strcmp("n", argv[2]) && strcmp("N", argv[2])){
    bu_vls_printf(&vls, "help opendb");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    bu_vls_free(&msg);
    return TCL_ERROR;
  }
d2066 12
a2077 2
  save_dbip = dbip;
  dbip = DBI_NULL;
d2079 5
a2083 4
  /* Get input file */
  if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
      ((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
    char line[128];
d2085 3
a2087 22
    /*
     * Check to see if we can access the database
     */
    if (access(argv[1], R_OK|W_OK) != 0 && errno != ENOENT) {
      perror(argv[1]);
      return TCL_ERROR;
    }

    if (interactive) {
      if(mged_init_flag){
	if(classic_mged){
	  perror( argv[1] );
	  bu_log("Create new database (y|n)[n]? ");
	  (void)fgets(line, sizeof(line), stdin);
	  if( line[0] != 'y' && line[0] != 'Y' ) {
	    bu_log("Warning: no database is currently opened!\n");
	    bu_vls_free(&vls);
	    bu_vls_free(&msg);
	    return TCL_OK;
	  }
	}else{
	  int status;
d2089 3
a2091 6
	  if(dpy_string != (char *)NULL)
	    bu_vls_printf(&vls, "cad_dialog .createdb %s \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
			  dpy_string, argv[1]);
	  else
	    bu_vls_printf(&vls, "cad_dialog .createdb :0 \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
			  argv[1]);
d2093 2
a2094 23
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));

	  if(status != TCL_OK || interp->result[0] == '2') {
	    mged_finish(0);
	  }

	  if(interp->result[0] == '1') {
	    bu_log("opendb: no database is currently opened!\n");
	    bu_vls_free(&vls);
	    bu_vls_free(&msg);
	    return TCL_OK;
	  }
	}
      } else { /* not initializing mged */
	if(argc == 2){
	  /* need to reset this before returning */
	  dbip = save_dbip;
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Create new database (y|n)[n]? ",
			   (char *)NULL);
	  bu_vls_printf(&curr_cmd_list->cl_more_default, "n");
	  bu_vls_free(&vls);
	  bu_vls_free(&msg);
	  return TCL_ERROR;
d2097 2
a2098 8
	if( *argv[2] != 'y' && *argv[2] != 'Y' ){
	  dbip = save_dbip; /* restore previous database */
	  bu_vls_free(&vls);
	  bu_vls_free(&msg);
	  return TCL_OK;
	}
      }
    }
d2100 2
a2101 4
    if( (dbip = db_create( argv[1] )) == DBI_NULL )  {
      dbip = save_dbip; /* restore previous database */
      bu_vls_free(&vls);
      bu_vls_free(&msg);
d2103 2
a2104 12
      if (mged_init_flag) {
	/* we need to use bu_log here */
	bu_log("opendb: failed to create %s\n", argv[1]);
	bu_log("opendb: no database is currently opened!\n");
	return TCL_OK;
      }
      
      Tcl_AppendResult(interp, "opendb: failed to create ", argv[1], "\n",\
		       (char *)NULL);
      if (dbip == DBI_NULL)
	Tcl_AppendResult(interp, "opendb: no database is currently opened!", \
			 (char *)NULL);
d2106 2
a2107 2
      return TCL_ERROR;
    }
d2109 2
a2110 2
    bu_vls_printf(&msg, "The new database %s was successfully created.\n", argv[1]);
  }/* if( ((dbip = db_open( argv[1] ..... */
d2112 2
a2113 2
  if( save_dbip )  {
    char *av[2];
d2115 2
a2116 2
    av[0] = "zap";
    av[1] = NULL;
d2118 2
a2119 2
    /* Clear out anything in the display */
    f_zap(clientData, interp, 1, av);
d2121 3
a2123 2
    /* Close the Tcl database objects */
    Tcl_Eval(interp, "db close; .inmem close");
d2125 11
a2135 2
    /* Close current database.  Releases MaterHead, etc. too. */
    db_close(save_dbip);
d2137 4
a2140 2
    log_event( "CEASE", "(close)" );
  }
d2142 4
a2145 2
  if( dbip->dbi_read_only )
    bu_vls_printf(&msg, "%s: READ ONLY\n", dbip->dbi_filename);
d2147 4
a2150 2
  /* Quick -- before he gets away -- write a logfile entry! */
  log_event( "START", argv[1] );
d2152 1
a2152 2
  /* --- Scan geometry database and build in-memory directory --- */
  (void)db_dirbuild( dbip );
d2154 4
a2157 15
  /* Close previous databases, if any.  Ignore errors. */
  bu_vls_strcpy(&vls, "db close; .inmem close");
  (void)Tcl_Eval( interp, bu_vls_addr(&vls) );

  /* Establish TCL access to both disk and in-memory databases */
  bu_vls_strcpy(&vls, "set wdbp [wdb_open db disk [get_dbip]]; wdb_open .inmem inmem [get_dbip]");
  if( Tcl_Eval( interp, bu_vls_addr(&vls) ) != TCL_OK )  {
    bu_vls_printf(&msg, "%s\n%s\n",
		  interp->result,
		  Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
    Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
    bu_vls_free(&vls);
    bu_vls_free(&msg);
    return TCL_ERROR;
  }
d2159 2
a2160 4
  /* Perhaps do something special with the GUI */
  bu_vls_trunc(&vls, 0);
  bu_vls_printf(&vls, "opendb_callback %s", dbip->dbi_filename);
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
d2162 3
a2164 23
  bu_vls_strcpy(&vls, "local2base");
  Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
  Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&local2base,
	      TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);

  bu_vls_strcpy(&vls, "base2local");
  Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
  Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&base2local,
	      TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);

  set_localunit_TclVar();

  /* Print title/units information */
  if( interactive )
    bu_vls_printf(&msg, "%s (units=%s)\n", dbip->dbi_title,
		  bu_units_string(dbip->dbi_local2base) );

  Tcl_ResetResult( interp );
  Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);

  bu_vls_free(&vls);
  bu_vls_free(&msg);
  return TCL_OK;
@


11.181.2.1
log
@Don't draw wireframe if overlaying entire window
with framebuffer pixels.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181 2000/06/23 06:46:23 mike Exp $ (BRL)";
a132 1
struct rt_wdb *wdbp = RT_WDB_NULL;
d1549 44
a1592 8
      if (dbip != DBI_NULL) {
	      /* do framebuffer underlay */
	      if (mged_variables->mv_fb && !mged_variables->mv_fb_overlay) {
		      if (mged_variables->mv_fb_all)
			      fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
		      else if (mged_variables->mv_mouse_behavior != 'z')
			      paint_rect_area();
	      }
d1594 2
a1595 27
	      /* do framebuffer overlay for entire window */
	      if (mged_variables->mv_fb &&
		  mged_variables->mv_fb_overlay &&
		  mged_variables->mv_fb_all) {
		      fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
	      } else {
		      /*  Draw each solid in it's proper place on the screen
		       *  by applying zoom, rotation, & translation.
		       *  Calls DM_LOADMATRIX() and DM_DRAW_VLIST().
		       */

		      if (dmp->dm_stereo == 0 ||
			  mged_variables->mv_eye_sep_dist <= 0) {
			      /* Normal viewing */
			      dozoom(0);
		      } else {
			      /* Stereo viewing */
			      dozoom(1);
			      dozoom(2);
		      }

		      /* do framebuffer overlay in rectangular area */
		      if (mged_variables->mv_fb &&
			  mged_variables->mv_fb_overlay &&
			  mged_variables->mv_mouse_behavior != 'z')
			      paint_rect_area();
	      }
d1597 2
d1600 3
a1602 2
	      /* Restore to non-rotated, full brightness */
	      DM_NORMAL(dmp);
d1604 5
a1608 28
	      /* only if not doing overlay */
	      if (!mged_variables->mv_fb ||
		  mged_variables->mv_fb_overlay != 2) {
		      if (rubber_band->rb_active || rubber_band->rb_draw)
			      draw_rect();

		      if (grid_state->gr_draw)
			      draw_grid();

		      /* Compute and display angle/distance cursor */
		      if (adc_state->adc_draw)
			      adcursor();

		      if (axes_state->ax_view_draw)
			      draw_v_axes();

		      if (axes_state->ax_model_draw)
			      draw_m_axes();

		      if (axes_state->ax_edit_draw &&
			  (state == ST_S_EDIT || state == ST_O_EDIT))
			      draw_e_axes();

		      /* Display titles, etc., if desired */
		      bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
		      dotitles(&tmp_vls);
		      bu_vls_trunc(&tmp_vls, 0);
	      }
d1612 7
a1618 8
      if (!mged_variables->mv_fb ||
	  mged_variables->mv_fb_overlay != 2) {
	      /* Draw center dot */
	      DM_SET_FGCOLOR(dmp,
			     color_scheme->cs_center_dot[0],
			     color_scheme->cs_center_dot[1],
			     color_scheme->cs_center_dot[2], 1);
	      DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
a1702 1
	/* Release all displays */
a1708 4
	/* Be certain to close the database cleanly before exiting */
	if( wdbp )  wdb_close(wdbp);
	if( dbip )  db_close(dbip);

d1954 16
a1969 3
	struct db_i *save_dbip;
	struct bu_vls vls;
	struct bu_vls msg;	/* use this to hold returned message */
d1971 3
a1973 2
	bu_vls_init(&vls);
	bu_vls_init(&msg);
d1975 7
a1981 9
	if( argc <= 1 )  {
		bu_vls_free(&vls);
		bu_vls_free(&msg);

		/* Invoked without args, return name of current database */
		if( dbip != DBI_NULL )  {
			Tcl_AppendResult(interp, dbip->dbi_filename, (char *)NULL);
			return TCL_OK;
		}
d1983 9
a1991 3
		Tcl_AppendResult(interp, "", (char *)NULL);
		return TCL_OK;
	}
d1993 2
a1994 25
	if(3 < argc || (strlen(argv[1]) == 0)){
		bu_vls_printf(&vls, "help opendb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}

	if(argc == 3 &&
	    strcmp("y", argv[2]) && strcmp("Y", argv[2]) &&
	    strcmp("n", argv[2]) && strcmp("N", argv[2])){
		bu_vls_printf(&vls, "help opendb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}

	save_dbip = dbip;
	dbip = DBI_NULL;

	/* Get input file */
	if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
	    ((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
		char line[128];
d1996 4
a1999 7
		/*
	         * Check to see if we can access the database
	         */
		if (access(argv[1], R_OK|W_OK) != 0 && errno != ENOENT) {
			perror(argv[1]);
			return TCL_ERROR;
		}
d2001 22
a2022 56
	    	/* File does not exist */
		if (interactive) {
			if(mged_init_flag){
				if(classic_mged){
					perror( argv[1] );
					bu_log("Create new database (y|n)[n]? ");
					(void)fgets(line, sizeof(line), stdin);
					if( line[0] != 'y' && line[0] != 'Y' ) {
						bu_log("Warning: no database is currently opened!\n");
						bu_vls_free(&vls);
						bu_vls_free(&msg);
						return TCL_OK;
					}
				} else{
					int status;

					if(dpy_string != (char *)NULL)
						bu_vls_printf(&vls, "cad_dialog .createdb %s \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
						    dpy_string, argv[1]);
					else
						bu_vls_printf(&vls, "cad_dialog .createdb :0 \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
						    argv[1]);

					status = Tcl_Eval(interp, bu_vls_addr(&vls));

					if(status != TCL_OK || interp->result[0] == '2') {
						mged_finish(0);
					}

					if(interp->result[0] == '1') {
						bu_log("opendb: no database is currently opened!\n");
						bu_vls_free(&vls);
						bu_vls_free(&msg);
						return TCL_OK;
					}
				}
			} else { /* not initializing mged */
				if(argc == 2){
					/* need to reset this before returning */
					dbip = save_dbip;
					Tcl_AppendResult(interp, MORE_ARGS_STR, "Create new database (y|n)[n]? ",
					    (char *)NULL);
					bu_vls_printf(&curr_cmd_list->cl_more_default, "n");
					bu_vls_free(&vls);
					bu_vls_free(&msg);
					return TCL_ERROR;
				}

				if( *argv[2] != 'y' && *argv[2] != 'Y' ){
					dbip = save_dbip; /* restore previous database */
					bu_vls_free(&vls);
					bu_vls_free(&msg);
					return TCL_OK;
				}
			}
		}
d2024 6
a2029 12
	    	/* File does not exist, and should be created */
		if( (dbip = db_create( argv[1] )) == DBI_NULL )  {
			dbip = save_dbip; /* restore previous database */
			bu_vls_free(&vls);
			bu_vls_free(&msg);

			if (mged_init_flag) {
				/* we need to use bu_log here */
				bu_log("opendb: failed to create %s\n", argv[1]);
				bu_log("opendb: no database is currently opened!\n");
				return TCL_OK;
			}
d2031 1
a2031 5
			Tcl_AppendResult(interp, "opendb: failed to create ", argv[1], "\n",\
		       (char *)NULL);
			if (dbip == DBI_NULL)
				Tcl_AppendResult(interp, "opendb: no database is currently opened!", \
			 (char *)NULL);
d2033 3
a2035 3
			return TCL_ERROR;
		}
	    	/* New database has already had db_dirbuild() by here */
d2037 18
a2054 3
		bu_vls_printf(&msg, "The new database %s was successfully created.\n", argv[1]);
	} else {
		/* Opened existing database file */
d2056 5
a2060 2
		/* Scan geometry database and build in-memory directory */
		(void)db_dirbuild( dbip );
d2062 2
d2065 4
a2068 2
	if( save_dbip )  {
		char *av[2];
d2070 12
a2081 2
		av[0] = "zap";
		av[1] = NULL;
d2083 2
a2084 2
		/* Clear out anything in the display */
		f_zap(clientData, interp, 1, av);
d2086 2
a2087 2
		/* Close the Tcl database objects */
		Tcl_Eval(interp, "db close; .inmem close");
d2089 2
a2090 2
		/* Close current database.  Releases MaterHead, etc. too. */
		db_close(save_dbip);
d2092 2
a2093 2
		log_event( "CEASE", "(close)" );
	}
d2095 2
a2096 2
	if( dbip->dbi_read_only )
		bu_vls_printf(&msg, "%s: READ ONLY\n", dbip->dbi_filename);
d2098 2
a2099 2
	/* Quick -- before he gets away -- write a logfile entry! */
	log_event( "START", argv[1] );
d2101 2
a2102 3
	/* Close previous databases, if any.  Ignore errors. */
	bu_vls_strcpy(&vls, "db close; .inmem close");
	(void)Tcl_Eval( interp, bu_vls_addr(&vls) );
d2104 2
a2105 6
	/* Provide LIBWDB C access to the on-disk database */
	if( wdbp )  wdb_close(wdbp);
	if( (wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL )  {
		Tcl_AppendResult(interp, "wdb_dbopen() failed?\n", (char *)NULL);
		return TCL_ERROR;
	}
d2107 2
a2108 12
	/* Establish LIBWDB TCL access to both disk and in-memory databases */
	/* This creates "db" and ".inmem" Tcl objects */
	bu_vls_strcpy(&vls, "set wdbp [wdb_open db disk [get_dbip]]; wdb_open .inmem inmem [get_dbip]");
	if( Tcl_Eval( interp, bu_vls_addr(&vls) ) != TCL_OK )  {
		bu_vls_printf(&msg, "%s\n%s\n",
		    interp->result,
		    Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}
d2110 2
a2111 4
	/* Perhaps do something special with the GUI */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "opendb_callback %s", dbip->dbi_filename);
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
d2113 2
a2114 4
	bu_vls_strcpy(&vls, "local2base");
	Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&local2base,
	    TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);
d2116 15
a2130 4
	bu_vls_strcpy(&vls, "base2local");
	Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&base2local,
	    TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);
d2132 4
a2135 1
	set_localunit_TclVar();
d2137 16
a2152 4
	/* Print title/units information */
	if( interactive )
		bu_vls_printf(&msg, "%s (units=%s)\n", dbip->dbi_title,
		    bu_units_string(dbip->dbi_local2base) );
d2154 2
a2155 2
	Tcl_ResetResult( interp );
	Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
d2157 3
a2159 3
	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_OK;
@


11.181.2.2
log
@Mod that fixes a bug related to the
number of vectors being drawn being
greater than the value of vectorThreshold
(i.e. flags get set when the Tcl-crank is
turned and then clobbered when the drawing
is complete).
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181.2.1 2000/08/30 17:22:13 bparker Exp $ (BRL)";
a1529 2
      dirty = 0;
      view_state->vs_flag = 0;
d1633 2
d1646 3
@


11.181.2.3
log
@Fix for rt_material_head getting blown away
when doing an opendb.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181.2.2 2000/09/14 20:05:12 bparker Exp $ (BRL)";
a71 1
#include "mater.h"
d133 1
d1719 1
a1719 3
	/* Close the Tcl database objects */
	Tcl_Eval(interp, "db close; .inmem close");

a1967 1
	struct mater *save_materp;
a2007 2
	save_materp = rt_material_head;
	rt_material_head = MATER_NULL;
a2061 1
					rt_material_head = save_materp;
a2071 1
					rt_material_head = save_materp;
a2081 1
			rt_material_head = save_materp;
a2111 2
		struct db_i *new_dbip;
		struct mater *new_materp;
a2115 5
		new_dbip = dbip;
		dbip = save_dbip;
		new_materp = rt_material_head;
		rt_material_head = save_materp;

d2123 1
a2123 3
		db_close(dbip);
		dbip = new_dbip;
		rt_material_head = new_materp;
d2133 11
@


11.181.2.4
log
@Remove unnecessary perror().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181.2.3 2000/11/03 17:58:48 bparker Exp $ (BRL)";
d2031 1
@


11.181.2.5
log
@Rework things in refresh so that the
view sharing stuff once again works.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181.2.4 2000/11/03 19:24:00 bparker Exp $ (BRL)";
a1521 13
  FOR_ALL_DISPLAYS(p, &head_dm_list.l)
	  if (update_views || p->dml_view_state->vs_flag)
		  p->dml_dirty = 1;

  /*
   * This needs to be done separately
   * because dml_view_state may be shared.
   */
  FOR_ALL_DISPLAYS(p, &head_dm_list.l)
	  p->dml_view_state->vs_flag = 0;

  update_views = 0;

d1529 1
a1529 1
    if (mapped && dirty) {
d1531 1
d1649 2
a1650 1
  
@


11.181.2.6
log
@Add rt_abort command that will abort
any raytrace initiated from MGED.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181.2.5 2000/11/09 21:24:26 bparker Exp $ (BRL)";
a264 1
	BU_LIST_INIT(&head_run_rt.l);
@


11.181.2.7
log
@Mods that check if dbip==DBI_NULL
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181.2.6 2000/11/15 21:31:19 bparker Exp $ (BRL)";
a1214 3

    if (dbip == DBI_NULL)
	    return non_blocking;
@


11.181.2.8
log
@*- mods that save the Tcl result string and
   restore it after a Tcl_Eval.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.181.2.7 2001/02/09 15:26:31 bparker Exp $ (BRL)";
a1162 1
  Tcl_Obj *save_result;
a1173 3
  save_result = Tcl_GetObjResult(interp);
  Tcl_IncrRefCount(save_result);

a1177 3

  Tcl_SetObjResult(interp, save_result);
  Tcl_DecrRefCount(save_result);
@


11.180
log
@Close the Tcl database objects. This fixes the
problem of not freeing rt_material_head.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.179 2000/02/01 20:17:56 mike Exp $ (BRL)";
d2114 1
a2114 1
  db_scan( dbip, (int (*)())db_diradd, 1, NULL );
@


11.179
log
@
Supressed warning message.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.178 2000/01/20 18:51:47 bparker Exp $ (BRL)";
d2097 3
@


11.178
log
@*- mods to f_opendb to better handle non_interactive mode
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.177 2000/01/07 04:21:20 mike Exp $ (BRL)";
d1157 1
a1157 1
  int fd = (int)clientData;
@


11.177
log
@
Eliminated dbi_localunit.  This is a v4 database anachronism.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.176 2000/01/04 15:32:41 bparker Exp $ (BRL)";
d2009 21
a2029 13
    if(mged_init_flag){
      if(classic_mged){
	perror( argv[1] );
	bu_log("Create new database (y|n)[n]? ");
	(void)fgets(line, sizeof(line), stdin);
	if( line[0] != 'y' && line[0] != 'Y' ) {
	  bu_log("Warning: no database is currently opened!\n");
	  bu_vls_free(&vls);
	  bu_vls_free(&msg);
	  return TCL_OK;
	}
      }else{
	int status;
d2031 1
a2031 6
	if(dpy_string != (char *)NULL)
	  bu_vls_printf(&vls, "cad_dialog .createdb %s \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
			dpy_string, argv[1]);
	else
	  bu_vls_printf(&vls, "cad_dialog .createdb :0 \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
			argv[1]);
d2033 3
a2035 1
	status = Tcl_Eval(interp, bu_vls_addr(&vls));
d2037 17
a2053 2
	if(status != TCL_OK || interp->result[0] == '2') {
	  mged_finish(0);
d2056 2
a2057 2
	if(interp->result[0] == '1') {
	  bu_log("opendb: no database is currently opened!\n");
a2062 18
    } else { /* not initializing mged */
      if(argc == 2){
	/* need to reset this before returning */
	dbip = save_dbip;
	Tcl_AppendResult(interp, MORE_ARGS_STR, "Create new database (y|n)[n]? ",
			 (char *)NULL);
	bu_vls_printf(&curr_cmd_list->cl_more_default, "n");
	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_ERROR;
      }

      if( *argv[2] != 'y' && *argv[2] != 'Y' ){
	dbip = save_dbip; /* restore previous database */
	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_OK;
      }
d2120 7
a2126 7
        bu_vls_printf(&msg, "%s\n%s\n",
    		interp->result,
		Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
	Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_ERROR;
d2149 1
a2149 1
		bu_units_string(dbip->dbi_local2base) );
@


11.176
log
@*- initialize rt_g's rtg_headwdb
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.175 1999/12/30 19:11:38 jra Exp $ (BRL)";
a161 14
static char *units_str[] = {
	"none",
	"mm",
	"um",
	"cm",
	"meters",
	"km",
	"inches",
	"feet",
	"yards",
	"miles",
	"extra"
};

d2147 1
a2147 1
		  units_str[dbip->dbi_localunit]);
@


11.175
log
@Eliminated some unused variables
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.174 1999/12/29 23:23:23 mike Exp $ (BRL)";
d276 2
a277 1
	BU_LIST_INIT( &rt_g.rtg_vlfree );
@


11.174
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.173 1999/10/26 21:33:04 bparker Exp $ (BRL)";
a437 1
	    int pid;
d439 1
a439 1
	    if ((pid = fork()) == 0){
a586 1
    static int freshline = 1;
a644 1
	    freshline = 1;
a1203 1
    vect_t		knobvec;	/* knob slew */
@


11.173
log
@*- check the reason we can't access a database and
   return if the reason is anything other than the
   file doesn't exist (i.e. ENOENT).
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.172 1999/10/22 21:37:09 bparker Exp $ (BRL)";
d2126 1
a2126 1
  db_scan( dbip, (int (*)())db_diradd, 1);
@


11.172
log
@*- move libdm and libfb initialization to attach.c/gui_setup()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.171 1999/10/12 19:41:51 bparker Exp $ (BRL)";
d62 1
d2018 5
a2022 3
    /* check to see if we can access the database */
    if (access(argv[1], R_OK|W_OK) != 0) {
      perror("opendb");
@


11.171
log
@*- fixed bug in f_opendb that causes files that are
   inaccessible to be mishandled
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.170 1999/10/08 21:42:30 bparker Exp $ (BRL)";
a384 6

	/* Initialize libdm */
	(void)dm_tclInit(interp);

	/* Initialize libfb */
	(void)fb_tclInit(interp);
@


11.170
log
@*- mods to log_event() to use a bu_vls instead
   of a fixed character array.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.169 1999/09/09 19:35:24 bparker Exp $ (BRL)";
d2022 6
@


11.169
log
@*- make MGED a process group leader
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.168 1999/09/08 14:31:29 bparker Exp $ (BRL)";
d1681 1
a1681 1
	char line[128];
d1690 2
a1691 1
	(void)sprintf(line, "%s [%s] time=%ld uid=%d (%s) %s\n",
d1701 1
a1701 1
		(void)write( logfd, line, (unsigned)strlen(line) );
d1704 2
@


11.168
log
@*- remove redundant declarations
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.167 1999/09/01 18:55:10 bparker Exp $ (BRL)";
d448 3
@


11.167
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.166 1999/08/16 14:44:14 bparker Exp $ (BRL)";
a194 2
	extern char *bu_optarg;
	extern int bu_optind, bu_opterr, bu_optopt;
@


11.166
log
@*-
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.165 1999/07/26 15:28:03 bparker Exp $ (BRL)";
d1183 1
a1183 1
#if 0
@


11.165
log
@*- add support for interlay
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.164 1999/07/08 19:01:24 bparker Exp $ (BRL)";
d1183 1
d1185 3
@


11.164
log
@*- modified f_opendb's dialog script
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.163 1999/06/11 17:52:59 bparker Exp $ (BRL)";
d1599 28
a1626 2
	if(rubber_band->rb_active || rubber_band->rb_draw)
	  draw_rect();
d1628 8
a1635 21
	if(grid_state->gr_draw)
	  draw_grid();

	/* Compute and display angle/distance cursor */
	if (adc_state->adc_draw)
	  adcursor();

	if(axes_state->ax_view_draw)
	  draw_v_axes();

	if(axes_state->ax_model_draw)
	  draw_m_axes();

	if(axes_state->ax_edit_draw &&
	   (state == ST_S_EDIT || state == ST_O_EDIT))
	  draw_e_axes();

	/* Display titles, etc., if desired */
	bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
	dotitles(&tmp_vls);
	bu_vls_trunc(&tmp_vls, 0);
a1636 7

      /* Draw center dot */
      DM_SET_FGCOLOR(dmp,
		     color_scheme->cs_center_dot[0],
		     color_scheme->cs_center_dot[1],
		     color_scheme->cs_center_dot[2], 1);
      DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
@


11.163
log
@*- mods to f_opendb
	- do not exit if db_create fails, reset dbip and continue
	- use bu_log only if initializing mged
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.162 1999/04/16 17:58:01 bparker Exp $ (BRL)";
d2024 1
a2024 1
	  bu_vls_printf(&vls, "cad_dialog .createdb %s \"Create New Database?\" \"Create new database named %s?\" \"\" 0 OK Cancel",
d2027 1
a2027 1
	  bu_vls_printf(&vls, "cad_dialog .createdb :0 \"Create New Database?\" \"Create new database named %s?\" \"\" 0 OK Cancel",
d2032 5
a2036 1
	if(status != TCL_OK || interp->result[0] != '0') {
@


11.162
log
@*- change new_db_callback to opendb_callback
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.161 1999/04/13 19:36:40 bparker Exp $ (BRL)";
d1964 1
d1967 1
d1970 3
d1987 1
d1997 1
d2016 2
a2030 1
	bu_vls_free(&vls);
d2033 3
a2035 1
	  bu_log("Warning: no database is currently opened!\n");
d2046 2
d2053 2
d2059 17
a2075 2
    Tcl_AppendResult(interp, "Creating new database \"", argv[1],
		     "\"\n", (char *)NULL);
d2077 1
a2077 3
    if( (dbip = db_create( argv[1] )) == DBI_NULL )  {
      perror( argv[1] );
      exit(2);		/* NOT finish() */
d2079 2
d2099 1
a2099 1
    Tcl_AppendResult(interp, dbip->dbi_filename, ":  READ ONLY\n", (char *)NULL);
d2114 1
a2114 1
	bu_log("%s\n%s\n",
d2117 3
a2121 1
  Tcl_ResetResult( interp );
a2137 2
  bu_vls_free(&vls);

d2142 2
a2143 2
    Tcl_AppendResult(interp, dbip->dbi_title, " (units=",
		     units_str[dbip->dbi_localunit], ")\n", (char *)NULL);
d2145 5
@


11.161
log
@*- more error checking
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.160 1999/04/12 21:40:39 bparker Exp $ (BRL)";
d2094 1
a2094 1
  bu_vls_printf(&vls, "new_db_callback %s", dbip->dbi_filename);
@


11.160
log
@*- set up to call output_callback
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.159 1999/04/07 16:44:01 bparker Exp $ (BRL)";
d412 2
a413 1
	  if(status != TCL_OK)
d415 1
d449 6
d456 5
a477 5

	      bu_vls_init(&vls);
	      bu_vls_strcpy(&vls, "gui");
	      (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	      bu_vls_free(&vls);
@


11.159
log
@*-
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.158 1999/03/30 19:58:58 bparker Exp $ (BRL)";
d512 8
d1181 1
a1181 1
  bu_vls_printf(&vls, "distribute_text {} {} {%s}", line);
@


11.158
log
@*- truncate string before use
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.157 1999/03/30 19:46:50 bparker Exp $ (BRL)";
d1574 2
a1575 1
	  if(mged_variables->mv_fb_all)	    fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
@


11.157
log
@*- removed line that made a bad assumption
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.156 1999/03/29 19:50:01 bparker Exp $ (BRL)";
d2076 1
@


11.156
log
@*- XXX for the moment leave stdin open
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.155 1999/03/18 18:03:18 bparker Exp $ (BRL)";
a252 3

	if(!interactive)
	  classic_mged = 0;
@


11.155
log
@*- initialize netfd to -1
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.154 1999/03/11 18:26:01 bparker Exp $ (BRL)";
d464 1
d467 1
@


11.154
log
@*- removed the -i option to MGED (after discussing with jra)
*- mods to control when MGED is interactive
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.153 1999/01/27 14:37:48 bparker Exp $ (BRL)";
d294 1
@


11.153
log
@*- changed mged_slider_link_vars to mged_link_vars
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.152 1999/01/25 18:14:35 bparker Exp $ (BRL)";
a196 1
	int	force_interactive = 0;
a207 3
			case 'i':
				force_interactive = 1;
				break;
d225 1
a225 1
				fprintf(stdout, "Usage:  %s [-c] [-h] [-i] [-r] [-x#] -X#] [database [command]]\n", argv[0]);
a233 10
#if 0
	/* Check again for proper invocation */
	if( argc < 2 )  {
	  argv -= (bu_optind - 1);
	  fprintf(stdout, "Usage:  %s [-n] [-r] [database [command]]\n", argv[0]);
	  fflush(stdout);
	  return(1);		/* NOT finish() */
	}
#endif

d236 1
a236 1
	  if( isatty(fileno(stdin)) )
d239 1
a239 1
	  if(classic_mged){
d254 2
a255 2
	if( force_interactive )
		interactive = 1;
a392 1
#if 1
a394 1
#endif
d463 3
d499 1
a499 3
	refresh();			/* Put up faceplate */

	if(classic_mged){
a501 1

@


11.152
log
@*- mods to insure that calls to Tcl_Eval are made
   with commands that are in "writable" space
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.151 1999/01/21 18:31:21 bparker Exp $ (BRL)";
d103 1
a103 1
extern int mged_slider_link_vars();
d393 1
a393 1
	mged_slider_link_vars(curr_dm_list);
@


11.151
log
@*- use helpdevel for help on developer commands
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.150 1999/01/12 18:15:57 bparker Exp $ (BRL)";
d299 1
a382 1
	bu_vls_init( &curr_cmd_list->cl_more_default );
d1964 2
a1977 3
    struct bu_vls vls;

    bu_vls_init(&vls);
a1986 3
    struct bu_vls vls;

    bu_vls_init(&vls);
a2011 1
	struct bu_vls vls;
a2012 1
	bu_vls_init(&vls);
d2078 2
a2079 1
  (void)Tcl_Eval( interp, "db close; .inmem close" );
d2082 2
a2083 1
  if( Tcl_Eval( interp, "set wdbp [wdb_open db disk [get_dbip]]; wdb_open .inmem inmem [get_dbip]" ) != TCL_OK )  {
a2089 2

  bu_vls_init(&vls);
@


11.150
log
@*- code to support sharing display lists
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.149 1998/12/29 20:37:19 bparker Exp $ (BRL)";
d1150 7
a1156 1
  if(argc != 2)
d1158 1
@


11.149
log
@*- call view_ring_init with two paramters, both of which
	are (struct _view_state *).
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.148 1998/12/15 15:55:32 bparker Exp $ (BRL)";
a303 2
	{
	  struct dm_list *dlp;
d305 2
a306 4
	  BU_GETSTRUCT(dlp, dm_list);
	  BU_LIST_APPEND(&head_dm_list.l, &dlp->l);
	  curr_dm_list = dlp;
	}
d341 3
@


11.148
log
@*- using global frametime instead of display manager
	owned frametime.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.147 1998/11/06 21:48:21 bparker Exp $ (BRL)";
d81 2
d348 1
a348 1
	view_ring_init(curr_dm_list);
a359 4

	bu_vls_init(&fps_name);
	bu_vls_printf(&fps_name, "%s(%S,fps)", MGED_DISPLAY_VAR,
		      &curr_dm_list->dml_dmp->dm_pathName);
@


11.147
log
@*- use new structures
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.146 1998/10/22 18:47:03 bparker Exp $ (BRL)";
d130 2
a131 2
int    update_views = 0;
int		(*cmdline_hook)() = NULL;
d133 1
d1529 2
a1530 1
  double elapsed_time = -1;
d1542 1
a1559 5
#if 0
      rt_prep_timer();
      elapsed_time = -1;		/* timer running */
#endif

d1586 1
a1586 2
	  if(mged_variables->mv_fb_all)
	    fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
a1629 11

#if 0
      if (elapsed_time < 0)  {
	(void)rt_get_timer( (struct bu_vls *)0, &elapsed_time );
	/* Only use reasonable measurements */
	if( elapsed_time > 1.0e-5 && elapsed_time < 30 )  {
	  /* Smoothly transition to new speed */
	  frametime = 0.9 * frametime + 0.1 * elapsed_time;
	}
      }
#endif
d1633 2
a1634 2
#if 1
  if (elapsed_time < 0)  {
d1641 3
a1644 4
#endif

  FOR_ALL_DISPLAYS(p, &head_dm_list.l)
    p->dml_view_state->vs_flag = 0;
@


11.146
log
@*- unlink base2local and local2base before (re)linking
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.145 1998/10/21 19:07:54 bparker Exp $ (BRL)";
d118 9
d295 2
a296 2
	bu_vls_init(&head_cmd_list.name);
	bu_vls_strcpy(&head_cmd_list.name, "mged");
d310 1
a310 1
	BU_LIST_INIT(&curr_dm_list->p_vlist);
d320 4
a323 1
	BU_GETSTRUCT(curr_dm_list->s_info, shared_info);
d326 1
d329 25
a354 1
	rc = 1;
a356 3
	curr_dm_list->s_info->opp = &pathName;
	mged_view_init(curr_dm_list);
	BU_GETSTRUCT(curr_dm_list->menu_vars, menu_vars);
d360 1
a360 1
		      &curr_dm_list->_dmp->dm_pathName);
a362 4
	/* init rotation matrix */
	Viewscale = 500;		/* => viewsize of 1000mm (1m) */
	bn_mat_idn( Viewrot );
	bn_mat_idn( toViewcenter );
a363 1
	bn_mat_idn( ModelDelta );
a365 3
	MAT_DELTAS_GET_NEG(orig_pos, toViewcenter);
	i_Viewscale = Viewscale;

d384 1
a384 1
	bu_vls_init( &curr_cmd_list->more_default );
a457 2
	  *mged_variables = default_mged_variables;	/* struct copy */
	  *color_scheme = default_color_scheme;		/* struct copy */
d614 1
a614 1
	if(!bu_vls_strlen(&input_str) && bu_vls_strlen(&curr_cmd_list->more_default))
d617 1
a617 1
			&curr_cmd_list->more_default);
d623 1
a623 1
	bu_vls_trunc(&curr_cmd_list->more_default, 0);
d629 2
a630 2
	    if(curr_cmd_list->aim)
	      curr_dm_list = curr_cmd_list->aim;
d747 1
a747 1
    if(!bu_vls_strlen(&input_str) && bu_vls_strlen(&curr_cmd_list->more_default))
d750 1
a750 1
		    &curr_cmd_list->more_default);
d752 1
a752 1
      if (curr_cmd_list->quote_string)
d762 2
a763 2
    curr_cmd_list->quote_string = 0;
    bu_vls_trunc(&curr_cmd_list->more_default, 0);
d770 2
a771 2
      if(curr_cmd_list->aim)
	curr_dm_list = curr_cmd_list->aim;
d1235 2
a1236 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'm';
d1258 1
a1258 1
      mged_variables->coords = save_coords;
d1270 2
a1271 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'o';
d1293 1
a1293 1
      mged_variables->coords = save_coords;
d1305 2
a1306 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'v';
d1328 1
a1328 1
      mged_variables->coords = save_coords;
d1340 2
a1341 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'm';
d1355 3
a1357 3
		    edit_rate_model_tran[X] * 0.05 * Viewscale * base2local,
		    edit_rate_model_tran[Y] * 0.05 * Viewscale * base2local,
		    edit_rate_model_tran[Z] * 0.05 * Viewscale * base2local);
d1362 1
a1362 1
      mged_variables->coords = save_coords;
d1374 2
a1375 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'v';
d1389 3
a1391 3
		    edit_rate_view_tran[X] * 0.05 * Viewscale * base2local,
		    edit_rate_view_tran[Y] * 0.05 * Viewscale * base2local,
		    edit_rate_view_tran[Z] * 0.05 * Viewscale * base2local);
d1396 1
a1396 1
      mged_variables->coords = save_coords;
d1430 1
a1430 1
      if(!p->_owner)
d1435 1
a1435 1
      if( rateflag_model_rotate ) {
d1441 4
a1444 4
		      rate_model_origin,
		      rate_model_rotate[X],
		      rate_model_rotate[Y],
		      rate_model_rotate[Z]);
d1449 1
a1449 1
      if( rateflag_model_tran ) {
d1455 3
a1457 3
		      rate_model_tran[X] * 0.05 * Viewscale * base2local,
		      rate_model_tran[Y] * 0.05 * Viewscale * base2local,
		      rate_model_tran[Z] * 0.05 * Viewscale * base2local);
d1462 1
a1462 1
      if( rateflag_rotate )  {
d1468 4
a1471 4
		      rate_origin,
		      rate_rotate[X],
		      rate_rotate[Y],
		      rate_rotate[Z]);
d1476 1
a1476 1
      if( rateflag_tran )  {
d1482 3
a1484 3
		      rate_tran[X] * 0.05 * Viewscale * base2local,
		      rate_tran[Y] * 0.05 * Viewscale * base2local,
		      rate_tran[Z] * 0.05 * Viewscale * base2local);
d1489 1
a1489 1
      if( rateflag_scale )  {
d1495 1
a1495 1
		      1.0 / (1.0 - (rate_scale / 10.0)));
d1539 2
a1540 2
    if(mapped && (update_views || dmaflag || dirty)) {
      VMOVE(geometry_default_color,color_scheme->geo_def);
d1554 1
a1554 1
      if( mged_variables->predictor )
d1557 1
a1557 1
#if 1
d1566 2
a1567 2
	if(mged_variables->fb && !mged_variables->fb_overlay){
	  if(mged_variables->fb_all)
d1569 1
a1569 1
	  else if(mged_variables->mouse_behavior != 'z')
d1577 1
a1577 1
	if( dmp->dm_stereo == 0 || mged_variables->eye_sep_dist <= 0 )  {
d1587 2
a1588 2
	if(mged_variables->fb && mged_variables->fb_overlay){
	  if(mged_variables->fb_all)
d1590 1
a1590 1
	  else if(mged_variables->mouse_behavior != 'z')
d1597 1
a1597 1
	if(rubber_band_active || mged_variables->rubber_band)
d1600 1
a1600 1
	if(mged_variables->grid_draw)
d1604 1
a1604 1
	if (adc_draw)
d1607 1
a1607 1
	if(mged_variables->v_axes)
d1610 1
a1610 1
	if(mged_variables->m_axes)
d1613 1
a1613 1
	if(mged_variables->e_axes &&
d1625 3
a1627 3
		     color_scheme->fp_center_dot[0],
		     color_scheme->fp_center_dot[1],
		     color_scheme->fp_center_dot[2], 1);
d1659 1
a1659 1
    p->s_info->_dmaflag = 0;
d1770 1
a1770 1
    bu_vls_trunc(&curr_cmd_list->more_default, 0);
d1773 1
a1773 1
    curr_cmd_list->quote_string = 0;
d1797 3
a1799 3
	bn_mat_mul( model2view, Viewrot, toViewcenter );
	model2view[15] = Viewscale;
	bn_mat_inv( view2model, model2view );
d1808 1
a1808 1
	  MAT4X3VEC( temp , view2model , work );
d1810 1
a1810 1
	  MAT4X3VEC( temp1 , view2model , work1 );
d1814 3
a1816 3
	  bn_aet_vec( &curr_dm_list->s_info->azimuth,
		       &curr_dm_list->s_info->elevation,
		       &curr_dm_list->s_info->twist,
d1820 7
a1826 7
	  if((NEAR_ZERO(curr_dm_list->s_info->elevation - 90.0,(fastf_t)0.005) ||
	     NEAR_ZERO(curr_dm_list->s_info->elevation + 90.0,(fastf_t)0.005)) &&
	     curr_dm_list->s_info->azimuth < 0 &&
	     !NEAR_ZERO(curr_dm_list->s_info->azimuth,(fastf_t)0.005))
	    curr_dm_list->s_info->azimuth += 360.0;
	  else if(NEAR_ZERO(curr_dm_list->s_info->azimuth,(fastf_t)0.005))
	    curr_dm_list->s_info->azimuth = 0.0;
d1829 3
a1831 3
	  if(!NEAR_ZERO(curr_dm_list->s_info->elevation - 90.0,(fastf_t)0.005) &&
	      !NEAR_ZERO(curr_dm_list->s_info->elevation + 90.0,(fastf_t)0.005))
	    curr_dm_list->s_info->azimuth -= 180;
d1837 2
a1838 2
	  bn_mat_mul( model2objview, model2view, modelchanges );
	  bn_mat_inv( objview2model, model2objview );
d1840 1
a1840 1
	dmaflag = 1;
d1852 1
a1852 1
    if(!p->_owner)
d1856 3
a1858 3
    bn_mat_mul( model2objview, model2view, modelchanges );
    bn_mat_inv( objview2model, model2objview );
    dmaflag = 1;
d2051 1
a2051 1
	bu_vls_printf(&curr_cmd_list->more_default, "n");
@


11.145
log
@*- oops! Better allocate some memory for color_scheme.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.144 1998/10/21 17:24:06 bparker Exp $ (BRL)";
d2089 1
d2094 1
@


11.144
log
@*- use color scheme variables
*- get fps across all display managers
*- issue warning about no database being opened
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.143 1998/08/13 11:56:29 bparker Exp $ (BRL)";
d314 1
@


11.143
log
@*- now using MGED_DISPLAY_VAR
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.142 1998/06/24 17:17:40 bparker Exp $ (BRL)";
d106 4
d111 2
d115 3
d313 2
a314 1
        *mged_variables = default_mged_variables;
a413 2
	  else
	    bu_log("%s", interp->result);
d426 8
d1503 3
a1508 2
    double	elapsed_time;

d1515 2
d1532 1
d1535 1
d1582 10
a1597 10
      if(mged_variables->v_axes)
	draw_v_axes();

      if(mged_variables->m_axes)
	draw_m_axes();

      if(mged_variables->e_axes &&
	 (state == ST_S_EDIT || state == ST_O_EDIT))
	draw_e_axes();

d1599 4
a1602 1
      DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d1609 1
d1618 11
d1631 1
d1996 4
a1999 2
	if( line[0] != 'y' && line[0] != 'Y' )
	    return TCL_OK;
d2015 2
a2016 1
	if(status != TCL_OK)
d2018 1
a2018 3

	if(interp->result[0] != '0')
	  return TCL_OK;
@


11.142
log
@*- fixed typo in units_str
*- mods to f_opendb()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/ged.c,v 11.141 1998/06/16 18:13:26 bparker Exp $ (BRL)";
d314 1
a314 1
	bu_vls_printf(&fps_name, "mged_display(%S,fps)",
@


11.141
log
@*- set tcl variable "version" to the version string
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/ged.c,v 11.140 1998/06/12 19:46:20 bparker Exp $ (BRL)";
d127 1
d145 1
a146 1
	"meters",
d495 2
a1909 2
  static int first = 1;
  int force_new = 0;
d1954 10
a1963 11
    if( isatty(0) ) {
      if(first){
	if(classic_mged){
	  perror( argv[1] );
	  bu_log("Create new database (y|n)[n]? ");
	  (void)fgets(line, sizeof(line), stdin);
	  if( line[0] != 'y' && line[0] != 'Y' )
	    exit(0);                /* NOT finish() */
	}else{
	  int status;
	  struct bu_vls vls;
d1965 7
a1971 10
	  bu_vls_init(&vls);
	  if(dpy_string != (char *)NULL)
	    bu_vls_printf(&vls, "mged_dialog .createdb %s \"Create New Database?\" \"Create new database named %s?\" \"\" 0 OK Cancel",
			  dpy_string, argv[1]);
	  else
	    bu_vls_printf(&vls, "mged_dialog .createdb :0 \"Create New Database?\" \"Create new database named %s?\" \"\" 0 OK Cancel",
			  argv[1]);
	    
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
d1973 2
a1974 2
	  if(status != TCL_OK)
	    exit(0);
d1976 2
a1977 12
	  if(interp->result[0] != '0')
	    exit(0);
	}
      } else {
	if(argc == 2){
	  /* need to reset this before returning */
	  dbip = save_dbip;
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Create new database (y|n)[n]? ",
			   (char *)NULL);
	  bu_vls_printf(&curr_cmd_list->more_default, "n");
	  return TCL_ERROR;
	}
d1979 1
a1979 2
	if( *argv[2] != 'y' && *argv[2] != 'Y' ){
	  dbip = save_dbip;
d1981 14
a1994 1
	}
d2005 1
a2005 1
  }
a2026 3

  if(first)
    first = 0;
@


11.140
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/ged.c,v 11.139 1998/06/11 19:41:45 bparker Exp $ (BRL)";
d358 9
@


11.139
log
@*- using floating point literals to initialize floats
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/ged.c,v 11.138 1998/06/11 14:28:12 bparker Exp $ (BRL)";
d1566 1
a1566 1
      DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
@


11.138
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/ged.c,v 11.137 1998/05/18 19:35:10 bparker Exp $ (BRL)";
d1567 1
a1567 1
      DM_DRAW_POINT_2D(dmp, 0, 0);
d1733 1
a1733 1
	  VSET( work , 0 , 0 , 1 );       /* view z-direction */
d1735 1
a1735 1
	  VSET( work1 , 1 , 0 , 0 );      /* view x-direction */
@


11.137
log
@*- mods for pjt demo
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/ged.c,v 11.136 1998/05/07 15:38:56 bparker Exp $ (BRL)";
a84 1
#ifdef USE_FRAMEBUFFER
a86 1
#endif
a87 1
#ifdef DO_SNAP_TO_GRID
a88 1
#endif
a89 1
#ifdef DO_RUBBER_BAND
a91 1
#endif
a1506 1
#ifdef USE_FRAMEBUFFER
a1513 1
#endif
a1527 1
#ifdef USE_FRAMEBUFFER
a1534 1
#endif
a1538 1
#ifdef DO_RUBBER_BAND
a1540 1
#endif
a1541 1
#ifdef DO_SNAP_TO_GRID
a1543 1
#endif
@


11.136
log
@*- mods to f_opendb
*- eliminate any code related to dm_pipe (now doing things elsewhere)
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/ged.c,v 11.135 1998/03/19 18:06:29 bparker Exp $ (BRL)";
d1518 1
a1518 1
	  else
d1541 1
a1541 1
	  else
d1632 1
a1632 1
		      now,
d1923 2
a1924 1
    Tcl_AppendResult(interp, "opendb: No database presently open\n", (char *)NULL);
@


11.135
log
@ADC variables are no longer mged_variables
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.134 1998/03/06 22:40:17 bparker Exp bparker $ (BRL)";
a114 1
int dm_pipe[2];
a164 1
Tcl_FileProc dm_pipe_input;
a167 1
void dm_pipe_input();
a169 2
struct dm_char_queue head_dm_char_queue;

a185 9
#if 0
	/* Check for proper invocation */
	if( argc < 1 )  {
		fprintf(stdout, "Usage:  %s [-n] [-r] [database [command]]\n", argv[0]);
		fflush(stdout);
		return(1);		/* NOT finish() */
	}
#endif

a279 3
	bzero((void *)&head_dm_char_queue, sizeof(struct dm_char_queue));
	BU_LIST_INIT(&head_dm_char_queue.l);

a470 4
	(void)pipe(dm_pipe);
	Tcl_CreateFileHandler(dm_pipe[0], TCL_READABLE,
			      dm_pipe_input, (ClientData)dm_pipe[0]);

a1141 54
void
dm_pipe_input(clientData, mask)
ClientData clientData;
int mask;
{
  int fd = (int)clientData;
  int count;
  struct bu_vls vls;
  char line[2];
  struct dm_char_queue *dcqp;
  struct dm_list *dlp;
  struct dm_list *save_curr_dlp;

  /* Get data from dm_pipe */
  if((count = read((int)fd, line, 1)) == 0)
     return;

  line[count] = '\0';

  BU_LIST_POP(dm_char_queue, &head_dm_char_queue.l, dcqp);
  if(dcqp == (struct dm_char_queue *)0)
    return;

  /* search for dcqp->dlp in list of valid displays */
  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
    if(dlp == dcqp->dlp)
      break;

  /* dcqp->dlp is no longer valid */
  if(BU_LIST_IS_HEAD(dlp, &head_dm_list.l)){
    bu_free((genptr_t)dcqp, "dm_pipe_input: dcqp");
    return;
  }

  /* save curr_dm_list */
  save_curr_dlp = curr_dm_list;
  curr_dm_list = dlp;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "insert_char {%s}", line);
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  bu_free((genptr_t)dcqp, "dm_pipe_input: dcqp");

  /* restore */
  curr_dm_list = save_curr_dlp;

  if(classic_mged){
    /* not claimed by insert_char */
    if(!strcmp(interp->result, "mged"))
	mged_process_char(line[0]);
  }
}

d2052 4
@


11.134
log
@*- clean up some old ADC related code
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.133 1998/03/03 15:49:03 pjt Exp bparker $ (BRL)";
d200 1
a200 1
	while ((c = bu_getopt(argc, argv, "d:hicrx:X:")) != EOF)
d213 1
d223 3
d227 1
a227 1
				fprintf(stdout, "Usage:  %s [-h] [-i] [-n] [-r] [database [command]]\n", argv[0]);
a229 4
			default:
				fprintf( stdout, "Unrecognized option (%c)\n", c );
				fflush(stdout);
				return( 1 );
d1635 1
a1635 1
	if (mged_variables->adcflag)
@


11.133
log
@It's not an error to run "opendb" w/ no args, even if there's no
currently open database.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.132 1998/02/26 16:06:46 bparker Exp $ (BRL)";
a330 1
	adc_a1_deg = adc_a2_deg = 45.0;
@


11.132
log
@*- mods necessary for the move to Tcl 8.0
*- mods to dm_pipe_input()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.131 1998/02/20 23:13:24 bparker Exp bparker $ (BRL)";
d2000 1
a2000 1
    return TCL_ERROR;
@


11.131
log
@call set_localunit_TclVar() from f_opendb()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.130 1998/02/05 22:55:31 bparker Exp bparker $ (BRL)";
d490 2
a491 2
	Tcl_CreateFileHandler(Tcl_GetFile((ClientData)dm_pipe[0], TCL_UNIX_FD),
			      TCL_READABLE, dm_pipe_input, (ClientData)dm_pipe[0]);
d494 2
a495 2
	  Tcl_CreateFileHandler(Tcl_GetFile((ClientData)STDIN_FILENO, TCL_UNIX_FD),
				TCL_READABLE, stdin_input, (ClientData)STDIN_FILENO);
d507 4
a510 4
	  Tcl_CreateFileHandler(Tcl_GetFile((ClientData)pipe_out[0], TCL_UNIX_FD),
				TCL_READABLE, std_out_or_err, (ClientData)pipe_out[0]);
	  Tcl_CreateFileHandler(Tcl_GetFile((ClientData)pipe_err[0], TCL_UNIX_FD),
				TCL_READABLE, std_out_or_err, (ClientData)pipe_err[0]);
d1175 1
d1184 1
a1184 2
  if(dcqp == (struct dm_char_queue *)0){
    bu_free((genptr_t)dcqp, "dm_pipe_input: dcqp");
a1185 1
  }
d1198 2
d1207 3
@


11.130
log
@*- now drawing the various axes in refresh()
*- now drawing the grid in refresh()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.129 1998/01/28 16:04:30 bparker Exp bparker $ (BRL)";
d109 3
d495 1
a495 2
				TCL_READABLE, stdin_input,
				(ClientData)STDIN_FILENO);
d2134 2
@


11.129
log
@*- using coords instead of ecoords
*- mods to f_opendb(), pop up a dialog box to ascertain whether or not to create a new database
*- initialize Tk immediately if not classic_mged
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.128 1998/01/16 22:02:38 bparker Exp bparker $ (BRL)";
d81 4
d90 4
d1616 3
d1624 4
a1627 2
	/* Restore to non-rotated, full brightness */
	DM_NORMAL(dmp);
d1638 10
@


11.128
log
@*- mods to use MGED's framebuffer capability
*- mods to use MGED's rubber band rectangle capability
*- reset_input_strings() used to reset input strings from alternate event loop
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.127 1997/12/23 14:01:51 bparker Exp bparker $ (BRL)";
a111 1
int bit_bucket();
d122 1
d189 1
a189 1
	while ((c = bu_getopt(argc, argv, "hinrx:X:")) != EOF)
d193 3
d202 1
a202 1
			case 'n':
d382 20
d444 1
a444 1
	      bu_vls_strcpy(&vls, "openw");
a446 3
#if 0
	      bu_add_hook(bit_bucket, (genptr_t)NULL);
#endif
d1247 1
a1247 1
      char save_ecoords;
d1250 2
a1251 2
      save_ecoords = mged_variables->ecoords;
      mged_variables->ecoords = 'm';
d1273 1
a1273 1
      mged_variables->ecoords = save_ecoords;
d1282 1
a1282 1
      char save_ecoords;
d1285 2
a1286 2
      save_ecoords = mged_variables->ecoords;
      mged_variables->ecoords = 'o';
d1308 1
a1308 1
      mged_variables->ecoords = save_ecoords;
d1317 1
a1317 1
      char save_ecoords;
d1320 2
a1321 2
      save_ecoords = mged_variables->ecoords;
      mged_variables->ecoords = 'v';
d1343 1
a1343 1
      mged_variables->ecoords = save_ecoords;
d1351 1
a1351 1
      char save_ecoords;
d1355 2
a1356 2
      save_ecoords = mged_variables->ecoords;
      mged_variables->ecoords = 'm';
d1377 1
a1377 1
      mged_variables->ecoords = save_ecoords;
d1385 1
a1385 1
      char save_ecoords;
d1389 2
a1390 2
      save_ecoords = mged_variables->ecoords;
      mged_variables->ecoords = 'v';
d1411 1
a1411 1
      mged_variables->ecoords = save_ecoords;
d2005 28
a2032 6
      if(first && classic_mged){
	perror( argv[1] );
	bu_log("Create new database (y|n)[n]? ");
	(void)fgets(line, sizeof(line), stdin);
	if( line[0] != 'y' && line[0] != 'Y' )
	  exit(0);                /* NOT finish() */
a2115 9
}

int
bit_bucket(clientdata, str)
genptr_t clientdata;
genptr_t str;
{
  /* do nothing */
  return( 0 );
@


11.127
log
@*- routine, dm_pipe_input(), to handle all redirected KeyPress events from display managers
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.126 1997/12/16 00:52:21 mike Exp bparker $ (BRL)";
d81 8
a88 3
#if 1
/* defined in libfb/tcl.c */
extern void fb_tclInit();
d116 1
d124 2
a125 2
static struct bu_vls input_str, scratchline, input_str_prefix;
static int input_str_index = 0;
d1555 10
d1578 15
d1718 1
a1718 11
  /* Truncate input string */
  bu_vls_trunc(&input_str, 0);
  bu_vls_trunc(&input_str_prefix, 0);
  bu_vls_trunc(&curr_cmd_list->more_default, 0);
  input_str_index = 0;

  curr_cmd_list->quote_string = 0;

  bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
  bu_log("\n");
  pr_prompt();
d1728 24
@


11.126
log
@Changed to use new symbol RT_SEM_LAST
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.125 1997/12/16 00:51:26 mike Exp mike $ (BRL)";
d122 1
d149 1
d153 1
d156 2
d274 3
d452 4
a456 1
	  (void)pipe(dm_pipe);
a459 3
	  Tcl_CreateFileHandler(Tcl_GetFile((ClientData)dm_pipe[0], TCL_UNIX_FD),
				TCL_READABLE, stdin_input,
				(ClientData)dm_pipe[0]);
d481 1
a481 10
#if 0
		/* apply solid editing changes if necessary */
		if( sedraw > 0) {
			sedit();
#if 1
			sedraw = 0;
			dmaflag = 1;
#endif
		}
#endif
a531 1
    struct bu_vls *vp;
a532 2
    static int escaped = 0;
    static int bracketed = 0;
d625 22
a646 1
    /* Process character */
d664 1
a664 5
#ifdef TRY_STDIN_INPUT_HACK
    /* Process everything in buf */
    for(index = 0, ch = buf[index]; index < count; ch = buf[++index]){
#endif
    /* ANSI arrow keys */
d666 33
a698 6
    if (escaped && bracketed) {
	if (ch == 'A') ch = CTRL_P;
	if (ch == 'B') ch = CTRL_N;
	if (ch == 'C') ch = CTRL_F;
	if (ch == 'D') ch = CTRL_B;
	escaped = bracketed = 0;
d701 2
a702 29
    switch (ch) {
    case ESC:           /* Used for building up ANSI arrow keys */
	escaped = 1;
	break;
    case '\n':          /* Carriage return or line feed */
    case '\r':
	bu_log("\n");   /* Display newline */

	/* If there are any characters already in the command string (left
	   over from a CMD_MORE), then prepend them to the new input. */

	/* If no input and a default is supplied then use it */
	if(!bu_vls_strlen(&input_str) && bu_vls_strlen(&curr_cmd_list->more_default))
	  bu_vls_printf(&input_str_prefix, "%s%S\n",
			bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			&curr_cmd_list->more_default);
	else {
	  if (curr_cmd_list->quote_string)
	    bu_vls_printf(&input_str_prefix, "%s\"%S\"\n",
			  bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			  &input_str);
	  else
	    bu_vls_printf(&input_str_prefix, "%s%S\n",
			  bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			  &input_str);
	}

	curr_cmd_list->quote_string = 0;
	bu_vls_trunc(&curr_cmd_list->more_default, 0);
d704 2
a705 2
	/* If this forms a complete command (as far as the Tcl parser is
	   concerned) then execute it. */
d707 6
a712 6
	if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
	    curr_cmd_list = &head_cmd_list;
	    if(curr_cmd_list->aim)
	      curr_dm_list = curr_cmd_list->aim;
	    if (cmdline_hook) {  /* Command-line hooks don't do CMD_MORE */
		reset_Tty(fileno(stdin));
d714 2
a715 31
		if ((*cmdline_hook)(&input_str_prefix))
		    pr_prompt();

		set_Cbreak(fileno(stdin));
		clr_Echo(fileno(stdin));

		bu_vls_trunc(&input_str, 0);
		bu_vls_trunc(&input_str_prefix, 0);
		(void)signal( SIGINT, SIG_IGN );
	    } else {
		reset_Tty(fileno(stdin)); /* Backwards compatibility */
		(void)signal( SIGINT, SIG_IGN );
		if (cmdline(&input_str_prefix, TRUE) == CMD_MORE) {
		    /* Remove newline */
		    bu_vls_trunc(&input_str_prefix,
				 bu_vls_strlen(&input_str_prefix)-1);
		    bu_vls_trunc(&input_str, 0);
		    (void)signal( SIGINT, sig2 );
       /* *** The mged_prompt vls now contains prompt for more input. *** */
		} else {
		    /* All done; clear all strings. */
		    bu_vls_trunc(&input_str_prefix, 0);
		    bu_vls_trunc(&input_str, 0);
		    (void)signal( SIGINT, SIG_IGN );
		}
		set_Cbreak(fileno(stdin)); /* Back to single-character mode */
		clr_Echo(fileno(stdin));
	    }
	} else {
	    bu_vls_trunc(&input_str, 0);
	    bu_vls_strcpy(&mged_prompt, "\r? ");
d717 2
a718 14
	    /* Allow the user to hit ^C */
	    (void)signal( SIGINT, sig2 );
	}
	pr_prompt(); /* Print prompt for more input */
	input_str_index = 0;
	freshline = 1;
	escaped = bracketed = 0;
	break;
    case BACKSPACE:
    case DELETE:
	if (input_str_index <= 0) {
	    pr_beep();
	    break;
	}
a719 47
	if (input_str_index == bu_vls_strlen(&input_str)) {
	    bu_log("\b \b");
	    bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1);
	} else {
	    bu_vls_init(&temp);
	    bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
	    bu_vls_trunc(&input_str, input_str_index-1);
	    bu_log("\b%S ", &temp);
	    pr_prompt();
	    bu_log("%S", &input_str);
	    bu_vls_vlscat(&input_str, &temp);
	    bu_vls_free(&temp);
	}
	--input_str_index;
	escaped = bracketed = 0;
	break;
    case CTRL_A:                    /* Go to beginning of line */
	pr_prompt();
	input_str_index = 0;
	escaped = bracketed = 0;
	break;
    case CTRL_E:                    /* Go to end of line */
	if (input_str_index < bu_vls_strlen(&input_str)) {
	    bu_log("%s", bu_vls_addr(&input_str)+input_str_index);
	    input_str_index = bu_vls_strlen(&input_str);
	}
	escaped = bracketed = 0;
	break;
    case CTRL_D:                    /* Delete character at cursor */
	if (input_str_index == bu_vls_strlen(&input_str)) {
	    pr_beep(); /* Beep if at end of input string */
	    break;
	}
	bu_vls_init(&temp);
	bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index+1);
	bu_vls_trunc(&input_str, input_str_index);
	bu_log("%S ", &temp);
	pr_prompt();
	bu_log("%S", &input_str);
	bu_vls_vlscat(&input_str, &temp);
	bu_vls_free(&temp);
	escaped = bracketed = 0;
	break;
    case CTRL_U:                   /* Delete whole line */
	pr_prompt();
	bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
	pr_prompt();
d721 12
a732 74
	input_str_index = 0;
	escaped = bracketed = 0;
	break;
    case CTRL_K:                    /* Delete to end of line */
	bu_log("%*s", bu_vls_strlen(&input_str)-input_str_index, SPACES);
	bu_vls_trunc(&input_str, input_str_index);
	pr_prompt();
	bu_log("%S", &input_str);
	escaped = bracketed = 0;
	break;
    case CTRL_L:                   /* Redraw line */
	bu_log("\n");
	pr_prompt();
	bu_log("%S", &input_str);
	if (input_str_index == bu_vls_strlen(&input_str))
	    break;
	pr_prompt();
	bu_log("%*S", input_str_index, &input_str);
	escaped = bracketed = 0;
	break;
    case CTRL_B:                   /* Back one character */
	if (input_str_index == 0) {
	    pr_beep();
	    break;
	}
	--input_str_index;
	bu_log("\b"); /* hopefully non-destructive! */
	escaped = bracketed = 0;
	break;
    case CTRL_F:                   /* Forward one character */
	if (input_str_index == bu_vls_strlen(&input_str)) {
	    pr_beep();
	    break;
	}

	bu_log("%c", bu_vls_addr(&input_str)[input_str_index]);
	++input_str_index;
	escaped = bracketed = 0;
	break;
    case CTRL_T:                  /* Transpose characters */
	if (input_str_index == 0) {
	    pr_beep();
	    break;
	}
	if (input_str_index == bu_vls_strlen(&input_str)) {
	    bu_log("\b");
	    --input_str_index;
	}
	ch = bu_vls_addr(&input_str)[input_str_index];
	bu_vls_addr(&input_str)[input_str_index] =
	    bu_vls_addr(&input_str)[input_str_index - 1];
	bu_vls_addr(&input_str)[input_str_index - 1] = ch;
	bu_log("\b%*s", 2, bu_vls_addr(&input_str)+input_str_index-1);
	++input_str_index;
	escaped = bracketed = 0;
	break;
    case CTRL_N:                  /* Next history command */
    case CTRL_P:                  /* Last history command */
	/* Work the history routines to get the right string */
        curr_cmd_list = &head_cmd_list;
	if (freshline) {
	    if (ch == CTRL_P) {
		vp = history_prev();
		if (vp == NULL) {
		    pr_beep();
		    break;
		}
		bu_vls_trunc(&scratchline, 0);
		bu_vls_vlscat(&scratchline, &input_str);
		freshline = 0;
	    } else {
		pr_beep();
		break;
	    }
d734 4
a737 13
	    if (ch == CTRL_P) {
		vp = history_prev();
		if (vp == NULL) {
		    pr_beep();
		    break;
		}
	    } else {
		vp = history_next();
		if (vp == NULL) {
		    vp = &scratchline;
		    freshline = 1;
		}
	    }
d739 6
a744 16
	pr_prompt();
	bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
	pr_prompt();
	bu_vls_trunc(&input_str, 0);
	bu_vls_vlscat(&input_str, vp);
	if (bu_vls_addr(&input_str)[bu_vls_strlen(&input_str)-1] == '\n')
	    bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1); /* del \n */
	bu_log("%S", &input_str);
	input_str_index = bu_vls_strlen(&input_str);
	escaped = bracketed = 0;
	break;
    case CTRL_W:                   /* backward-delete-word */
	{
	  char *start;
	  char *curr;
	  int len;
d746 14
a759 2
	  start = bu_vls_addr(&input_str);
	  curr = start + input_str_index - 1;
d761 71
a831 59
	  /* skip spaces */
	  while(curr > start && *curr == ' ')
	    --curr;

	  /* find next space */
	  while(curr > start && *curr != ' ')
	    --curr;

	  bu_vls_init(&temp);
	  bu_vls_strcat(&temp, start+input_str_index);

	  if(curr == start)
	    input_str_index = 0;
	  else
	    input_str_index = curr - start + 1;

	  len = bu_vls_strlen(&input_str);
	  bu_vls_trunc(&input_str, input_str_index);
	  pr_prompt();
	  bu_log("%S%S%*s", &input_str, &temp, len - input_str_index, SPACES);
	  pr_prompt();
	  bu_log("%S", &input_str);
	  bu_vls_vlscat(&input_str, &temp);
	  bu_vls_free(&temp);
	}

        escaped = bracketed = 0;
        break;
    case 'd':
      if (escaped) {                /* delete-word */
	char *start;
	char *curr;
	int i;

	start = bu_vls_addr(&input_str);
	curr = start + input_str_index;

	/* skip spaces */
	while(*curr != '\0' && *curr == ' ')
	  ++curr;

	/* find next space */
	while(*curr != '\0' && *curr != ' ')
	  ++curr;

	i = curr - start;
	bu_vls_init(&temp);
	bu_vls_strcat(&temp, curr);
	bu_vls_trunc(&input_str, input_str_index);
	pr_prompt();
	bu_log("%S%S%*s", &input_str, &temp, i - input_str_index, SPACES);
	pr_prompt();
	bu_log("%S", &input_str);
	bu_vls_vlscat(&input_str, &temp);
	bu_vls_free(&temp);
      }else
	mged_insert_char(ch);

      escaped = bracketed = 0;
d833 8
a840 28
    case 'f':
      if (escaped) {                /* forward-word */
	char *start;
	char *curr;

	start = bu_vls_addr(&input_str);
	curr = start + input_str_index;

	/* skip spaces */
	while(*curr != '\0' && *curr == ' ')
	  ++curr;

	/* find next space */
	while(*curr != '\0' && *curr != ' ')
	  ++curr;

	input_str_index = curr - start;
	bu_vls_init(&temp);
	bu_vls_strcat(&temp, start+input_str_index);
	bu_vls_trunc(&input_str, input_str_index);
	pr_prompt();
	bu_log("%S", &input_str);
	bu_vls_vlscat(&input_str, &temp);
	bu_vls_free(&temp);
      }else
	mged_insert_char(ch);

      escaped = bracketed = 0;
d842 9
a850 32
    case 'b':
      if (escaped) {                /* backward-word */
	char *start;
	char *curr;

	start = bu_vls_addr(&input_str);
	curr = start + input_str_index - 1;

	/* skip spaces */
	while(curr > start && *curr == ' ')
	  --curr;

	/* find next space */
	while(curr > start && *curr != ' ')
	  --curr;

	if(curr == start)
	  input_str_index = 0;
	else
	  input_str_index = curr - start + 1;

	bu_vls_init(&temp);
	bu_vls_strcat(&temp, start+input_str_index);
	bu_vls_trunc(&input_str, input_str_index);
	pr_prompt();
	bu_log("%S", &input_str);
	bu_vls_vlscat(&input_str, &temp);
	bu_vls_free(&temp);
      }else
	mged_insert_char(ch);

      escaped = bracketed = 0;
d852 43
a894 4
    case '[':
	if (escaped) {
	    bracketed = 1;
	    break;
d896 1
a896 8
	/* Fall through if not escaped! */
    default:
	if (!isprint(ch))
	    break;

	mged_insert_char(ch);
	escaped = bracketed = 0;
	break;
d898 44
a941 1
#ifdef TRY_STDIN_INPUT_HACK
d943 101
d1045 9
a1053 1
#endif	
d1120 45
d1166 1
a1166 1
  bu_vls_printf(&vls, "distribute_text {} {} %*s", count, line);
d1169 1
d1171 5
a1175 1
  return;
@


11.125
log
@BParker mods
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.124 1997/12/09 13:46:10 bparker Exp bparker $ (BRL)";
d261 1
a261 6

	  bu_semaphore_init( 5 );
	  bu_semaphore_init( 5 );
	  bu_semaphore_init( 5 );
	  bu_semaphore_init( 5 );
	  bu_semaphore_init( 5 );
@


11.124
log
@redirect stdout and stderr if not classic mged
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.123 1997/11/12 22:01:11 bparker Exp bparker $ (BRL)";
d81 1
a81 1
#if 0
d363 1
a363 1
#if 0
@


11.123
log
@name change: dm_Tcl_Init ----> dm_tclInit
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.122 1997/11/06 20:00:55 bparker Exp bparker $ (BRL)";
d81 5
d100 2
d147 1
d150 1
d331 1
a331 1
	es_edclass = scroll_edit = EDIT_CLASS_NULL;
d360 1
a360 1
	/* This initializes libdm */
d363 5
d398 13
d415 1
a415 1

d417 1
d467 5
d1090 8
a1097 6
  bu_log("\r%s\n", argv[1]);
  pr_prompt();
  bu_log("%s", bu_vls_addr(&input_str));
  pr_prompt();
  for(i = 0; i < input_str_index; ++i)
    bu_log("%c", bu_vls_addr(&input_str)[i]);
d1102 21
@


11.122
log
@use new mged variable: ecoords
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.121 1997/11/06 13:17:59 jra Exp bparker $ (BRL)";
d352 1
a352 1
	(void)dm_Tcl_Init(interp);
@


11.121
log
@Added -x and -X command line options
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.120 1997/11/03 15:13:22 bparker Exp jra $ (BRL)";
d1111 1
a1111 1
      char save_coords;
d1114 2
a1115 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'm';
d1137 1
a1137 1
      mged_variables->coords = save_coords;
d1146 1
a1146 1
      char save_coords;
d1149 2
a1150 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'o';
d1172 1
a1172 1
      mged_variables->coords = save_coords;
d1181 1
a1181 1
      char save_coords;
d1184 2
a1185 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'v';
d1207 1
a1207 1
      mged_variables->coords = save_coords;
d1215 1
a1215 1
      char save_coords;
d1219 2
a1220 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'm';
d1241 1
a1241 1
      mged_variables->coords = save_coords;
d1249 1
a1249 1
      char save_coords;
d1253 2
a1254 2
      save_coords = mged_variables->coords;
      mged_variables->coords = 'v';
d1275 1
a1275 1
      mged_variables->coords = save_coords;
@


11.120
log
@use LIBDM macros
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.119 1997/10/10 21:05:54 bparker Exp bparker $ (BRL)";
d169 1
a169 1
	while ((c = bu_getopt(argc, argv, "hinr")) != EOF)
d181 6
@


11.119
log
@remove code that sets the window bounds  ---> now doing it once at
display manager creation time
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.118 1997/10/01 20:34:40 bparker Exp bparker $ (BRL)";
a414 5
#if 0
	/* Reset the lights */
	dmp->dm_light( dmp, LIGHT_RESET, 0 );
#endif

d1430 1
a1430 1
      dmp->dm_drawBegin(dmp);	/* update displaylist prolog */
d1435 1
a1435 1
	 *  Calls dmp->dm_newrot() and dmp->dm_drawVList().
d1447 1
a1447 1
	dmp->dm_normal(dmp);
d1460 2
a1461 2
      dmp->dm_setColor(dmp, DM_YELLOW, 1);
      dmp->dm_drawVertex2D(dmp, 0, 0);
d1463 1
a1463 1
      dmp->dm_drawEnd(dmp);
d1544 1
a1544 4
	  dmp->dm_close(dmp);
#if 0
	  dmp->dm_light( dmp, LIGHT_RESET, 0 );	/* turn off the lights */
#endif
@


11.118
log
@mods to event_check()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.117 1997/10/01 19:17:09 jra Exp bparker $ (BRL)";
a97 1
static int	windowbounds[6];	/* X hi,lo;  Y hi,lo;  Z hi,lo */
a349 7
	windowbounds[0] = XMAX;		/* XHR */
	windowbounds[1] = XMIN;		/* XLR */
	windowbounds[2] = YMAX;		/* YHR */
	windowbounds[3] = YMIN;		/* YLR */
	windowbounds[4] = 2047;		/* ZHR */
	windowbounds[5] = -2048;	/* ZLR */

a364 4
#if 0
	dmp->dm_setWinBounds(windowbounds);
#endif

a1103 14
    /*
     * Set up window so that drawing does not run over into the
     * status line area, and menu area (if present).
     */

    windowbounds[1] = XMIN;		/* XLR */
    if( illump != SOLID_NULL )
	windowbounds[1] = MENUXLIM;
    windowbounds[3] = TITLE_YBASE-TEXT1_DY;	/* YLR */

#if 0
    dmp->dm_setWinBounds(windowbounds);	/* hack */
#endif

a1435 1
      dmp->dm_setWinBounds(dmp, windowbounds);
@


11.117
log
@add -i option
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.116 1997/10/01 19:10:01 bparker Exp jra $ (BRL)";
d1359 3
a1361 3
		      rate_model_tran[X] * 0.1,
		      rate_model_tran[Y] * 0.1,
		      rate_model_tran[Z] * 0.1);
d1386 3
a1388 3
		      rate_tran[X] * 0.1,
		      rate_tran[Y] * 0.1,
		      rate_tran[Z] * 0.1);
@


11.116
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.115 1997/09/08 18:08:44 bparker Exp bparker $ (BRL)";
d156 1
d170 1
a170 1
	while ((c = bu_getopt(argc, argv, "hnr")) != EOF)
d174 3
d184 1
a184 1
				fprintf(stdout, "Usage:  %s [-h] [-n] [-r] [database [command]]\n", argv[0]);
d226 3
@


11.115
log
@*- new macro FOR_ALL_DISPLAYS
*- mged_variables is now a pointer
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.114 1997/08/22 22:38:22 mike Exp bparker $ (BRL)";
d216 1
d218 1
a222 4
	/* Set up for character-at-a-time terminal IO. */
	if(classic_mged && cbreak_mode)
	    save_Tty(fileno(stdin));
	
@


11.114
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.113 1997/08/22 22:32:14 mike Exp mike $ (BRL)";
d81 3
a96 1
mat_t		ModelDelta;		/* Changes to Viewrot this frame */
d270 5
d283 2
a284 1
	mged_variables = default_mged_variables;
a289 1
	last_v_axes = 2; /* center location */
d1134 2
a1135 2
      save_coords = mged_variables.coords;
      mged_variables.coords = 'm';
d1157 1
a1157 1
      mged_variables.coords = save_coords;
d1169 2
a1170 2
      save_coords = mged_variables.coords;
      mged_variables.coords = 'o';
d1192 1
a1192 1
      mged_variables.coords = save_coords;
d1204 2
a1205 2
      save_coords = mged_variables.coords;
      mged_variables.coords = 'v';
d1227 1
a1227 1
      mged_variables.coords = save_coords;
d1239 2
a1240 2
      save_coords = mged_variables.coords;
      mged_variables.coords = 'm';
d1261 1
a1261 1
      mged_variables.coords = save_coords;
d1273 2
a1274 2
      save_coords = mged_variables.coords;
      mged_variables.coords = 'v';
d1295 1
a1295 1
      mged_variables.coords = save_coords;
d1328 1
a1328 1
    for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d1429 1
a1429 1
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d1448 1
a1448 3

	rt_prep_timer();
	elapsed_time = -1;		/* timer running */
d1450 2
a1451 1
	dmp->dm_setWinBounds(dmp, windowbounds);
d1453 2
a1454 3
	if( mged_variables.predictor )
	  predictor_frame();
      }
d1457 1
d1464 1
a1464 1
	if( mged_variables.eye_sep_dist <= 0 )  {
d1477 1
a1477 1
	if (mged_variables.adcflag)
d1505 1
a1505 1
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) )
d1568 1
a1568 1
	for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d1687 1
a1687 1
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
@


11.113
log
@Fallout from BParker mods to eliminate MGED displaylist mode.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.112 1997/08/20 19:23:33 jra Exp bparker $ (BRL)";
d152 2
a153 2
	extern char *optarg;
	extern int optind, opterr, optopt;
d167 1
a167 1
	while ((c = getopt(argc, argv, "hnr")) != EOF)
d188 2
a189 2
	argc -= (optind - 1);
	argv += (optind - 1);
d194 1
a194 1
	  argv -= (optind - 1);
@


11.112
log
@Minor mods for IRIX 6.4.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.111 1997/07/28 19:58:21 bparker Exp jra $ (BRL)";
a318 1
	no_memory = 0;		/* memory left */
@


11.111
log
@mods to event_check()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.110 1997/07/25 20:46:18 bparker Exp bparker $ (BRL)";
d1946 1
@


11.110
log
@mods to event_check()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.109 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d1084 1
a1124 1
      int save_edflag;
d1127 1
a1127 1
      curr_dm_list = edit_dm_list;
a1159 1
      int save_edflag;
d1162 1
a1162 1
      curr_dm_list = edit_dm_list;
a1194 1
      int save_edflag;
d1197 1
a1197 1
      curr_dm_list = edit_dm_list;
a1228 1
      int save_edflag;
d1232 1
a1232 1
      curr_dm_list = edit_dm_list;
a1262 1
      int save_edflag;
d1266 1
a1266 1
      curr_dm_list = edit_dm_list;
d1299 10
d1315 5
@


11.109
log
@mods to run without a database
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.108 1997/06/25 02:58:35 mike Exp bparker $ (BRL)";
d282 1
d1118 3
d1122 28
a1149 3
    for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
      if(!p->_owner)
	continue;
d1151 1
a1151 1
      curr_dm_list = p;
d1153 22
a1174 5
      /*********************************
       *  Handle rate-based processing *
       *********************************/
      if( edit_rateflag_rotate ) {
	struct bu_vls vls;
d1176 7
a1182 6
	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -e ax %f ay %f az %f\n",
		      edit_rate_rotate[X],
		      edit_rate_rotate[Y],
		      edit_rate_rotate[Z]);
d1184 26
a1209 2
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
a1210 2
      if( edit_rateflag_tran ) {
	struct bu_vls vls;
d1212 7
a1218 6
	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -e aX %f aY %f aZ %f\n",
		      -edit_rate_tran[X] * 0.1,
		      -edit_rate_tran[Y] * 0.1,
		      -edit_rate_tran[Z] * 0.1);
d1220 26
a1245 2
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
a1246 2
      if( edit_rateflag_scale ) {
	struct bu_vls vls;
d1248 6
a1253 3
	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -e aS %f\n", edit_rate_scale * 0.01);
d1255 26
a1280 2
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1282 35
a1358 1
#if 1
a1369 4
#else
	non_blocking++;
	mged_do_rate_slew();
#endif
d1371 1
a1371 1
      if( rateflag_zoom )  {
d1374 1
d1377 1
a1377 1
		      1.0 / (1.0 - (rate_zoom / 10.0)));
a1380 9
      if ( rateflag_azimuth ) {
	struct bu_vls vls;

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -v aazim %f", rate_azimuth);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
      }
a1410 3
  if(dbip == DBI_NULL)
    return;

d1421 7
a1427 6
      if(do_overlay){
	bu_vls_init(&overlay_vls);
	bu_vls_init(&tmp_vls);
	create_text_overlay(&overlay_vls);
	do_overlay = 0;
      }
d1429 2
a1430 2
      /* XXX VR hack */
      if( viewpoint_hook )  (*viewpoint_hook)();
d1432 2
a1433 2
      rt_prep_timer();
      elapsed_time = -1;		/* timer running */
d1435 1
a1435 1
      dmp->dm_setWinBounds(dmp, windowbounds);
d1437 3
a1439 2
      if( mged_variables.predictor )
	predictor_frame();
d1443 25
a1467 11
      /*  Draw each solid in it's proper place on the screen
       *  by applying zoom, rotation, & translation.
       *  Calls dmp->dm_newrot() and dmp->dm_drawVList().
       */
      if( mged_variables.eye_sep_dist <= 0 )  {
	/* Normal viewing */
	dozoom(0);
      } else {
	/* Stereo viewing */
	dozoom(1);
	dozoom(2);
a1469 12
      /* Restore to non-rotated, full brightness */
      dmp->dm_normal(dmp);

      /* Compute and display angle/distance cursor */
      if (mged_variables.adcflag)
	adcursor();

      /* Display titles, etc., if desired */
      bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
      dotitles(&tmp_vls);
      bu_vls_trunc(&tmp_vls, 0);

d1795 1
a1896 5
  /* Print title/units information */
  if( interactive )
    Tcl_AppendResult(interp, dbip->dbi_title, " (units=",
		     units_str[dbip->dbi_localunit], ")\n", (char *)NULL);

d1908 17
@


11.108
log
@Give read-only warning all the time.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.107 1997/06/25 00:47:01 mike Exp mike $ (BRL)";
a64 7
/* defined in cmd.c */
extern Tcl_Interp *interp;
extern Tk_Window tkwin;

/* defined in attach.c */
extern int mged_slider_link_vars();

d81 6
a86 2
int dm_pipe[2];
struct db_i *dbip = DBI_NULL;	/* database instance pointer */
a87 1
int    update_views = 0;
d91 3
a94 1

a95 1

d97 1
d99 1
a99 1
jmp_buf	jmp_env;		/* For non-local gotos */
d108 1
d158 1
d160 2
a161 2
	if( argc < 2 )  {
		fprintf(stdout, "Usage:  %s [-r] database [command]\n", argv[0]);
d165 1
d167 1
a167 1
	while ((c = getopt(argc, argv, "r")) != EOF)
d174 7
d191 1
d195 1
a195 1
	  fprintf(stdout, "Usage:  %s [-r] database [command]\n", argv[0]);
d199 1
d202 7
a208 6
	if( argc == 2 )  {
		if( isatty(fileno(stdin)) )
			interactive = 1;

		fprintf(stdout, "%s\n", version+5);	/* skip @@(#) */
		fflush(stdout);
d210 1
a210 1
		if (isatty(fileno(stdin)) && isatty(fileno(stdout))) {
d214 3
a216 2
 		    cbreak_mode = COMMAND_LINE_EDITING;
		}
d220 1
a220 1
	if (cbreak_mode) 
d277 1
a277 1
	am_mode = ALT_IDLE;
d334 3
d346 8
a353 6
	/* Open the database, attach a display manager */
	/* Command line may have more than 2 args, opendb only wants 2 */
	if(f_opendb( (ClientData)NULL, interp, 2, argv ) == TCL_ERROR)
	  mged_finish(1);
	else
	  bu_log("%s", interp->result);
d355 1
a355 1
	if( read_only_flag || dbip->dbi_read_only )
d366 22
a387 4
	if( interactive )  {
		/* This is an interactive mged, process .mgedrc */
		do_rc();
		get_attached();
d420 8
a427 7
	(void)pipe(dm_pipe);
	Tcl_CreateFileHandler(Tcl_GetFile((ClientData)STDIN_FILENO, TCL_UNIX_FD),
			      TCL_READABLE, stdin_input,
			     (ClientData)STDIN_FILENO);
	Tcl_CreateFileHandler(Tcl_GetFile((ClientData)dm_pipe[0], TCL_UNIX_FD),
			      TCL_READABLE, stdin_input,
			     (ClientData)dm_pipe[0]);
d429 1
a429 1
	(void)signal( SIGINT, SIG_IGN );
d431 2
a432 4
	bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
	pr_prompt();

	/****************  M A I N   L O O P   *********************/
d434 1
a434 1
	if (cbreak_mode) {
d437 1
d440 1
d1656 1
a1656 1
    if( dbip )  {
d1695 1
a1695 1
      if(first){
d1772 8
@


11.107
log
@Improved database open and close processing
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.106 1997/06/25 00:16:37 mike Exp mike $ (BRL)";
d338 1
a338 1
	if( read_only_flag && !dbip->dbi_read_only )
@


11.106
log
@Additional support for RTSYNC/RTNODE realtime-ray-tracer.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.105 1997/06/20 02:43:27 gdurf Exp mike $ (BRL)";
d1723 4
a1726 4
#if NOT_READY_YET
  if( Tcl_Eval( interp, "wdb_close $wdbp" ) != TCL_OK )
	  return TCL_ERROR;
#endif
@


11.105
log
@New system for setting up dbip
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.104 1997/06/20 02:01:40 gdurf Exp gdurf $ (BRL)";
d1727 6
a1732 2
  if( Tcl_Eval( interp, "set wdbp [wdb_open db disk [get_dbip]]" ) != TCL_OK )
	  return TCL_ERROR;
@


11.104
log
@changes by bparker
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.103 1997/06/14 03:34:15 gdurf Exp bparker $ (BRL)";
a89 1
int dbih = 0;			/* Tcl DB handle to the database instance */
d1723 7
a1729 8
  /* 0 is not a valid database handle. */
  if( !dbih )
	  dbih = db_tcl_register( dbip );
  else {
/*	  db_tcl_change_registered( dbih, dbip ); */
	  db_tcl_unregister( dbih );
	  dbih = db_tcl_register( dbip );
  }
@


11.103
log
@New db handles are genereated when the db is replaced.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.102 1997/06/14 02:40:21 gdurf Exp gdurf $ (BRL)";
a1104 1

a1117 1

d1128 23
d1152 3
d1160 2
a1161 1
	bu_vls_printf(&vls, "knob -i -v ax %f ay %f az %f\n",
d1169 1
a1169 1
      if( rateflag_slew )  {
d1176 4
a1179 3
		      rate_slew[X] * 0.1,
		      rate_slew[Y] * 0.1,
		      rate_slew[Z] * 0.1);
@


11.102
log
@minor name change
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.101 1997/06/14 02:30:10 gdurf Exp gdurf $ (BRL)";
d1701 5
a1705 2
  else
	  db_tcl_change_registered( dbih, dbip );
@


11.101
log
@Added support for "dbih" variable, which is a Tcl handle to the database
instance.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.100 1997/06/14 02:24:25 gdurf Exp gdurf $ (BRL)";
d1700 1
a1700 1
	  dbih = dbi_tcl_register( dbip );
d1702 1
a1702 1
	  dbi_tcl_change_registered( dbih, dbip );
@


11.100
log
@Changes by bparker
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.99 1997/06/03 16:03:59 pjt Exp bparker $ (BRL)";
d90 1
d1697 6
@


11.99
log
@Added units um, km, yd, mi, and other minor improvements
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.98 1997/05/29 14:14:00 bparker Exp bparker $ (BRL)";
d265 1
a265 1
	am_mode = ALT_MOUSE_MODE_IDLE;
d271 2
a272 1
	mged_view_init();
d287 1
a287 1
	MAT_DELTAS_GET(orig_pos, toViewcenter);
a319 3
#if TRY_NEW_MGED_VARS
	mged_variable_setup(curr_dm_list);
#endif
d1589 2
d1592 9
a1600 9
	if( argc <= 1 )  {
		/* Invoked without args, return name of current database */
		if( dbip )  {
			Tcl_AppendResult(interp, dbip->dbi_filename, (char *)NULL);
			return TCL_OK;
		}
		Tcl_AppendResult(interp, "opendb: No database presently open\n", (char *)NULL);
		return TCL_ERROR;
	}
d1602 1
a1602 1
  if( 3 < argc || (strlen(argv[1]) == 0)){
d1612 4
a1615 2
  if( dbip )  {
    char *av[2];
d1617 6
a1622 9
    av[0] = "zap";
    av[1] = NULL;

    /* Clear out anything in the display */
    f_zap(clientData, interp, 1, av);

    /* Close current database.  Releases MaterHead, etc. too. */
    db_close(dbip);
    dbip = DBI_NULL;
d1624 2
a1625 2
    log_event( "CEASE", "(close)" );
  }
d1641 2
a1642 2
	  perror( argv[1] );

a1645 3

	  dmaflag = 0;
	  update_views = 0;
d1649 4
a1652 2
	if( *argv[2] != 'y' && *argv[2] != 'Y' )
	  exit(0);		/* NOT finish() */
d1663 15
@


11.98
log
@mods to handle azimuth rate stuff
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.97 1997/05/22 03:55:16 mike Exp bparker $ (BRL)";
d124 1
d126 1
d130 2
d271 1
@


11.97
log
@Changed "opendb" command to be good TCL citizen, returning
name of current database when invoked with no args.
Particularly useful with "send" command in multi-program tools.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.96 1997/05/22 03:46:16 mike Exp mike $ (BRL)";
a1127 2
#if 1
#if 1
a1138 12
#else
	non_blocking++;
	mged_do_rate_rotate();
#endif
#else
	non_blocking++;

	/* Compute delta x,y,z parameters */
	usejoy( rate_rotate[X] * 6 * degtorad,
	        rate_rotate[Y] * 6 * degtorad,
	        rate_rotate[Z] * 6 * degtorad );
#endif
a1141 1
#if 0
a1155 9
#else
	non_blocking++;

	/* slew 1/10th of the view per update */
	knobvec[X] = -rate_slew[X] / 10;
	knobvec[Y] = -rate_slew[Y] / 10;
	knobvec[Z] = -rate_slew[Z] / 10;
	slewview( knobvec );
#endif
a1157 2
#if 1
#if 1
d1165 2
a1166 2
#else
	int status;
a1167 1
	char *av[3];
d1169 1
a1169 3
	av[0] = "zoom";
	av[2] = NULL;

d1171 2
a1172 3
	bu_vls_printf(&vls, "%f", 1.0 / (1.0 - (rate_zoom / 10.0)));
	av[1] = bu_vls_addr(&vls);
	status = f_zoom((ClientData)NULL, interp, 2, av);
a1173 23

	if( status == TCL_OK )
	  non_blocking++;
#endif
#else
	fastf_t	factor;
	mat_t scale_mat;

	factor = 1.0 - (rate_zoom / 10);
	Viewscale *= factor;
	if( Viewscale < MINVIEW )
	    Viewscale = MINVIEW;
	else  {
	    non_blocking++;
	}

	/* Scaling (zooming) takes place around view center */
	bn_mat_idn( scale_mat );
	scale_mat[15] = 1/factor;

	wrt_view( ModelDelta, scale_mat, ModelDelta );
	new_mats();
#endif
d1431 15
d1448 1
a1448 1
#ifdef DO_NEW_EDIT_MATS
a1453 21
#else
	if( state != ST_VIEW ) {
	    register struct dm_list *p;
	    struct dm_list *save_dm_list;

	    save_dm_list = curr_dm_list;
	    for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
	      if(!p->_owner)
		continue;

	      curr_dm_list = p;

	      bn_mat_mul( model2objview, model2view, modelchanges );
	      bn_mat_inv( objview2model, model2objview );
	    }

	    curr_dm_list = save_dm_list;
	    update_views = 1;
	}else
	  dmaflag = 1;
#endif
@


11.96
log
@BParker mod to add "mapped" flag check.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.95 1997/05/21 12:56:00 bparker Exp bparker $ (BRL)";
d329 2
a330 1
	if(f_opendb( (ClientData)NULL, interp, argc, argv ) == TCL_ERROR)
d1646 11
a1656 1
  if(argc < 2 || 3 < argc || (strlen(argv[1]) == 0)){
@


11.95
log
@move get_attached out of f_opendb
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.94 1997/05/09 21:00:10 bparker Exp bparker $ (BRL)";
d1269 1
a1269 1
    if(update_views || dmaflag || dirty) {
@


11.94
log
@added code to slurp up all waiting events
whether or not non_blocking is true
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.93 1997/05/08 14:28:38 bparker Exp bparker $ (BRL)";
d266 1
a266 1
	curr_dm_list->s_info->opp = &tkName;
d270 1
a270 1
		      &curr_dm_list->_dmp->dm_tkName);
d348 1
d1716 1
a1716 1
  if(first){
a1717 4

    if( interactive )
      get_attached();
  }
@


11.93
log
@mods to do_rc()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.92 1997/04/29 12:43:40 bparker Exp bparker $ (BRL)";
d1053 1
d1055 3
@


11.92
log
@mods to f_opendb()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.91 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d1555 1
a1555 1
#define RCFILE	".gedrc"
d1569 3
a1572 2
		if( (fp = fopen(bu_vls_addr(&str), "r")) != NULL )
			found = 1;
d1584 4
a1587 2
	if( !found )
		return -1;
d1597 1
a1597 1
		if( strchr(buf, '=') != NULL )
d1599 2
d1615 1
a1616 1

@


11.91
log
@modify calls to Tcl_Eval
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.90 1997/04/18 12:30:01 bparker Exp bparker $ (BRL)";
d179 8
d201 1
a201 2

	    }
d223 7
a229 14
		rt_g.rtg_parallel = 1;
#if 0
		RES_INIT( &rt_g.res_syscall );
		RES_INIT( &rt_g.res_worker );
		RES_INIT( &rt_g.res_stats );
		RES_INIT( &rt_g.res_results );
		RES_INIT( &rt_g.res_model );
#else
		bu_semaphore_init( 5 );
		bu_semaphore_init( 5 );
		bu_semaphore_init( 5 );
		bu_semaphore_init( 5 );
		bu_semaphore_init( 5 );
#endif
d1635 12
a1646 2
	if( dbip )  {
	  char *av[2];
d1648 2
a1649 2
	  av[0] = "zap";
	  av[1] = NULL;
d1651 2
a1652 2
	  if(argc < 2 || 3 < argc){
	    struct bu_vls vls;
d1654 3
a1656 32
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "help opendb");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    return TCL_ERROR;
	  }

	  /* Clear out anything in the display */
	  f_zap(clientData, interp, 1, av);

	  /* Close current database.  Releases MaterHead, etc. too. */
	  db_close(dbip);
	  dbip = DBI_NULL;

	  log_event( "CEASE", "(close)" );
	}

	/* Get input file */
	if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
	    ((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
	  char line[128];

	  if( isatty(0) ) {
	    if(first){
	      perror( argv[1] );
	      bu_log("Create new database (y|n)[n]? ");
	      (void)fgets(line, sizeof(line), stdin);
	      if( line[0] != 'y' && line[0] != 'Y' )
		exit(0);                /* NOT finish() */
	    } else {
	      if(argc == 2){
		perror( argv[1] );
d1658 2
a1659 8
		Tcl_AppendResult(interp, MORE_ARGS_STR, "Create new database (y|n)[n]? ",
				 (char *)NULL);
		bu_vls_printf(&curr_cmd_list->more_default, "n");

		dmaflag = 0;
		update_views = 0;
		return TCL_ERROR;
	      }
d1661 15
a1675 4
	      if( *argv[2] != 'y' && *argv[2] != 'Y' )
		exit(0);		/* NOT finish() */
	    }
	  }
d1677 3
a1679 2
	  Tcl_AppendResult(interp, "Creating new database \"", argv[1],
			   "\"\n", (char *)NULL);
d1681 3
a1683 4
	  if( (dbip = db_create( argv[1] )) == DBI_NULL )  {
	    perror( argv[1] );
	    exit(2);		/* NOT finish() */
	  }
d1685 20
a1704 2
	if( dbip->dbi_read_only )
	  Tcl_AppendResult(interp, dbip->dbi_filename, ":  READ ONLY\n", (char *)NULL);
d1706 2
a1707 2
 	/* Quick -- before he gets away -- write a logfile entry! */
	log_event( "START", argv[1] );
d1709 3
a1711 2
	if(first){
	  first = 0;
d1713 2
a1714 7
	  if( interactive )
	    get_attached();
#if 0
	  Tcl_AppendResult(interp, "Note: the attach command can be used\n",
			   "      to open a display window.\n\n", (char *)NULL);
#endif
	}
d1716 4
a1719 13
	/* --- Scan geometry database and build in-memory directory --- */
	db_scan( dbip, (int (*)())db_diradd, 1);
	/* XXX - save local units */
#if 0
	localunit = dbip->dbi_localunit;
	local2base = dbip->dbi_local2base;
	base2local = dbip->dbi_base2local;
#endif
	/* Print title/units information */
	if( interactive )
	  Tcl_AppendResult(interp, dbip->dbi_title, " (units=",
			   units_str[dbip->dbi_localunit], ")\n", (char *)NULL);
	
d1721 1
a1721 1
	return TCL_OK;
@


11.90
log
@reset quote_string when receive interrupt
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.89 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d1642 6
a1647 1
	    Tcl_Eval(interp, "help opendb");
@


11.89
log
@mods so that commands check args internally
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.88 1997/04/09 20:35:52 bparker Exp bparker $ (BRL)";
d1430 2
@


11.88
log
@mods to allow pasting more than one line into mged
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.87 1997/04/07 19:40:02 bparker Exp bparker $ (BRL)";
d1639 2
a1640 1
	  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1642 1
@


11.87
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.86 1997/04/04 19:53:18 bparker Exp bparker $ (BRL)";
d536 10
d547 2
a549 1
    count = read((int)fd, (void *)&ch, 1);
d577 4
a580 1

d971 4
a974 1
	
@


11.86
log
@add prompt for display manager
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.85 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d1681 3
a1683 1
	  get_attached();
@


11.85
log
@Mods to support MGED's read-only mode.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.84 1997/03/20 14:48:43 bparker Exp jra $ (BRL)";
d1681 1
@


11.84
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.83 1997/03/07 02:51:55 mike Exp bparker $ (BRL)";
d149 2
d152 2
d157 1
a157 1
		fprintf(stdout, "Usage:  %s database [command]\n", argv[0]);
d162 17
d333 6
@


11.83
log
@If there is an error in a Tcl .mgedrc file, provide full error trace.
Debugging is hard enough even with the trace.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.82 1997/03/06 21:35:13 bparker Exp mike $ (BRL)";
d91 1
a91 5
int    update_views;
#if 0
extern void mged_do_rate_rotate();
extern void mged_do_rate_slew();
#endif
@


11.82
log
@added new_edit_mats()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.81 1997/02/28 21:30:50 bparker Exp bparker $ (BRL)";
d1563 3
a1565 2
	if (Tcl_EvalFile( interp, bu_vls_addr(&str) ) == TCL_ERROR) {
	    bu_log("Error reading %s: %s\n", RCFILE, interp->result);
@


11.81
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.80 1997/02/24 22:06:20 bparker Exp bparker $ (BRL)";
d251 4
d1438 7
a1444 1

d1464 22
d1487 1
@


11.80
log
@*- mods to initialize for independent button menu
*= mod to refresh()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.79 1997/02/14 22:09:57 bparker Exp bparker $ (BRL)";
a345 1
#if 1
a346 4
#else
	/* Force mged_display variables to be initialized */
	dotitles(1);
#endif
d1204 3
d1221 6
d1262 3
a1264 5
#if 0
      dotitles(mged_variables.faceplate);
#else
      dotitles();
#endif
d1290 5
@


11.79
log
@mods to a few variables
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.78 1997/02/03 21:46:57 bparker Exp bparker $ (BRL)";
d249 1
a249 1
	curr_dm_list->s_info->opp = &pathName;
d291 2
d1209 3
@


11.78
log
@*** empty log message ***
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.77 1997/01/29 23:13:54 bparker Exp bparker $ (BRL)";
d238 2
a239 1
	bu_vls_init(&dname);
d241 1
d291 3
@


11.77
log
@call dotitles without parameter --- like before
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.76 1997/01/29 02:26:10 mike Exp bparker $ (BRL)";
d92 4
d1077 1
d1091 4
d1104 1
d1115 4
@


11.76
log
@BParker init of dname;
Removed include of db.h
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.75 1997/01/24 20:51:13 bparker Exp bparker $ (BRL)";
d335 1
a335 1
#if 0
d1234 1
d1236 3
@


11.75
log
@mods to stdin_input
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.74 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
a76 1
#include "db.h"
d234 1
@


11.74
log
@checkin for weekend
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.73 1997/01/10 21:55:09 bparker Exp bparker $ (BRL)";
d259 1
a272 2
	setview( 0.0, 0.0, 0.0 );

d287 2
d560 10
a569 4
	else
	  bu_vls_printf(&input_str_prefix, "%s%S\n",
			bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			&input_str);
d571 1
@


11.73
log
@move view related commands to chgview.c
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.72 1997/01/09 21:46:02 mike Exp bparker $ (BRL)";
d69 3
a95 1
double		frametime = 1.0;	/* time needed to draw last frame */
a98 1
void		(*viewpoint_hook)() = NULL;
d225 9
a233 11
	head_dm_list._dmp = &dm_Null;
	curr_dm_list = &head_dm_list;
	curr_dm_list->s_info = (struct shared_info *)bu_malloc(sizeof(struct shared_info),
							       "shared_info");
	bzero((void *)curr_dm_list->s_info, sizeof(struct shared_info));
#if 1
	bcopy((void *)&default_mged_variables, (void *)&mged_variables,
	      sizeof(struct _mged_variables));
#else
	mged_variables = default_mged_variables;
#endif
d236 3
d241 3
a244 4
	state = ST_VIEW;
	es_edflag = -1;
	inpara = newedge = 0;

d254 7
d286 1
a1179 1
  double	elapsed_time = 0;
a1180 8
  if(update_views || dmaflag || dirty) {
    /* XXX VR hack */
    if( viewpoint_hook )  (*viewpoint_hook)();

    rt_prep_timer();
    elapsed_time = -1;		/* timer running */
  }

d1183 2
d1189 5
d1195 2
a1196 2
    curr_dm_list = p;
    dmp->dm_setWinBounds(dmp, windowbounds);
d1198 1
a1198 1
    if(update_views || dmaflag || dirty) {
d1235 9
a1243 8
    }
  }
  if (elapsed_time < 0)  {
    (void)rt_get_timer( (struct bu_vls *)0, &elapsed_time );
    /* Only use reasonable measurements */
    if( elapsed_time > 1.0e-5 && elapsed_time < 30 )  {
      /* Smoothly transition to new speed */
      frametime = 0.9 * frametime + 0.1 * elapsed_time;
d1247 2
a1248 3
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
    curr_dm_list = p;
  }
a1251 1
  dmaflag = 0;
@


11.72
log
@Always clear dmaflag.
@
text
@a9 3
 *	usejoy		Apply joystick to viewing perspective
 *	setview		Set the current view
 *	slewview	Slew the view
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.71 1997/01/09 20:52:25 jra Exp mike $ (BRL)";
a1245 140
}

/*
 *			F _ V R O T _ C E N T E R
 *
 *  Set the center of rotation, either in model coordinates, or
 *  in view (+/-1) coordinates.
 *  The default is to rotate around the view center: v=(0,0,0).
 */
int
f_vrot_center(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;

  Tcl_AppendResult(interp, "Not ready until tomorrow.\n", (char *)NULL);
  return TCL_OK;
}

/*
 *			U S E J O Y
 *
 *  Apply the "joystick" delta rotation to the viewing direction,
 *  where the delta is specified in terms of the *viewing* axes.
 *  Rotation is performed about the view center, for now.
 *  Angles are in radians.
 */
void
usejoy( xangle, yangle, zangle )
double	xangle, yangle, zangle;
{
	mat_t	newrot;		/* NEW rot matrix, from joystick */

	if( state == ST_S_EDIT )  {
		if( sedit_rotate( xangle, yangle, zangle ) > 0 )
			return;		/* solid edit claimed event */
	} else if( state == ST_O_EDIT )  {
		if( objedit_rotate( xangle, yangle, zangle ) > 0 )
			return;		/* object edit claimed event */
	}

	/* NORMAL CASE.
	 * Apply delta viewing rotation for non-edited parts.
	 * The view rotates around the VIEW CENTER.
	 */
	bn_mat_idn( newrot );
	buildHrot( newrot, xangle, yangle, zangle );

	bn_mat_mul2( newrot, Viewrot );
	{
		mat_t	newinv;
		bn_mat_inv( newinv, newrot );
		wrt_view( ModelDelta, newinv, ModelDelta );
	}
	new_mats();
}

/*
 *			A B S V I E W _ V
 *
 *  The "angle" ranges from -1 to +1.
 *  Assume rotation around view center, for now.
 */
void
absview_v( ang )
CONST point_t	ang;
{
	point_t	rad;

	VSCALE( rad, ang, bn_pi );	/* range from -pi to +pi */
	buildHrot( Viewrot, rad[X], rad[Y], rad[Z] );
	new_mats();
}

/*
 *			S E T V I E W
 *
 * Set the view.  Angles are DOUBLES, in degrees.
 *
 * Given that viewvec = scale . rotate . (xlate to view center) . modelvec,
 * we just replace the rotation matrix.
 * (This assumes rotation around the view center).
 */
void
setview( a1, a2, a3 )
double a1, a2, a3;		/* DOUBLE angles, in degrees */
{
  point_t model_pos;
  point_t temp;

  buildHrot( Viewrot, a1 * degtorad, a2 * degtorad, a3 * degtorad );
  new_mats();

  if(absolute_slew[X] != 0.0 ||
     absolute_slew[Y] != 0.0 ||
     absolute_slew[Z] != 0.0){
    VSET(temp, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, temp);
  }

  if(BU_LIST_NON_EMPTY(&head_cmd_list.l))
    Tcl_Eval(interp, "set_sliders");
}

/*
 *			S L E W V I E W
 *
 *  Given a position in view space,
 *  make that point the new view center.
 */
void
slewview( view_pos )
vect_t view_pos;
{
  point_t old_model_center;
  point_t new_model_center;
  vect_t diff;
  vect_t temp;
  mat_t	delta;

  MAT_DELTAS_GET_NEG( old_model_center, toViewcenter );

  MAT4X3PNT( new_model_center, view2model, view_pos );
  MAT_DELTAS_VEC_NEG( toViewcenter, new_model_center );

  VSUB2( diff, new_model_center, old_model_center );
  bn_mat_idn( delta );
  MAT_DELTAS_VEC( delta, diff );
  bn_mat_mul2( delta, ModelDelta );
  new_mats();

  VSET(temp, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, temp);

  if(BU_LIST_NON_EMPTY(&head_cmd_list.l))
    (void)Tcl_Eval(interp, "set_sliders");
@


11.71
log
@removed erroneous initialization.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.70 1997/01/09 17:12:01 jra Exp jra $ (BRL)";
a1243 1
    dmaflag = 0;
d1248 1
@


11.70
log
@Added initialization of nmg hitmiss freelist.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.69 1997/01/08 19:43:44 bparker Exp jra $ (BRL)";
a217 1
	BU_LIST_INIT( &rt_g.rtg_nmgfree );
@


11.69
log
@move definition for  MINVIEW to mged_dm.h
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.68 1997/01/07 22:06:13 bparker Exp bparker $ (BRL)";
d218 1
@


11.68
log
@added more command line editing to stdin_input()
	*- delete-word
	*- backward-delete-word
	*- forward-word
	*- backward-word
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.67 1997/01/07 04:48:24 mike Exp bparker $ (BRL)";
a1130 2

#define MINVIEW		0.001	/* smallest view.  Prevents runaway zoom */
@


11.67
log
@Fixed viewpoint_hook, per-frame timing.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.66 1997/01/02 22:12:41 bparker Exp mike $ (BRL)";
d117 1
d520 1
d765 131
d905 2
a906 17
	if (input_str_index == bu_vls_strlen(&input_str)) {
	    bu_log("%c", (int)ch);
	    bu_vls_putc(&input_str, (int)ch);
	    ++input_str_index;
	} else {
	    bu_vls_init(&temp);
	    bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
	    bu_vls_trunc(&input_str, input_str_index);
	    bu_log("%c%S", (int)ch, &temp);
	    pr_prompt();
	    bu_vls_putc(&input_str, (int)ch);
	    bu_log("%S", &input_str);
	    bu_vls_vlscat(&input_str, &temp);
	    ++input_str_index;
	    bu_vls_free(&temp);
	}
	
d911 24
@


11.66
log
@.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.65 1997/01/02 19:35:05 bparker Exp bparker $ (BRL)";
d1032 1
a1032 1
  register struct dm_list *p;
d1034 1
d1036 8
a1054 1
      double	elapsed_time;
a1055 5
      /* XXX VR hack */
      if( viewpoint_hook )  (*viewpoint_hook)();

      rt_prep_timer();

a1089 7
      (void)rt_get_timer( (struct bu_vls *)0, &elapsed_time );
      /* Only use reasonable measurements */
      if( elapsed_time > 1.0e-5 && elapsed_time < 30 )  {
	/* Smoothly transition to new speed */
	frametime = 0.9 * frametime + 0.1 * elapsed_time;
      }

d1091 8
@


11.65
log
@mods to use libbn and libbu
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.64 1996/12/30 22:29:53 bparker Exp bparker $ (BRL)";
d198 13
a210 5
		bu_semaphore_init( &rt_g.res_syscall );
		bu_semaphore_init( &rt_g.res_worker );
		bu_semaphore_init( &rt_g.res_stats );
		bu_semaphore_init( &rt_g.res_results );
		bu_semaphore_init( &rt_g.res_model );
@


11.64
log
@remove sedit call from main loop
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.63 1996/12/17 22:43:48 bparker Exp bparker $ (BRL)";
a65 1
#include "tcl.h"
d76 1
d121 1
a121 1
struct rt_tol	mged_tol;		/* calculation tolerance */
d198 5
a202 5
		RES_INIT( &rt_g.res_syscall );
		RES_INIT( &rt_g.res_worker );
		RES_INIT( &rt_g.res_stats );
		RES_INIT( &rt_g.res_results );
		RES_INIT( &rt_g.res_model );
d238 1
a238 1
	mat_idn( identity );		/* Handy to have around */
d241 5
a245 5
	mat_idn( Viewrot );
	mat_idn( toViewcenter );
	mat_idn( modelchanges );
	mat_idn( ModelDelta );
	mat_idn( acc_rot_sol );
d248 1
a248 1
	mged_tol.magic = RT_TOL_MAGIC;
d993 1
a993 1
	mat_idn( scale_mat );
d1146 1
a1146 1
	mat_idn( newrot );
d1149 1
a1149 1
	mat_mul2( newrot, Viewrot );
d1152 1
a1152 1
		mat_inv( newinv, newrot );
d1170 1
a1170 1
	VSCALE( rad, ang, rt_pi );	/* range from -pi to +pi */
d1227 1
a1227 1
  mat_idn( delta );
d1229 1
a1229 1
  mat_mul2( delta, ModelDelta );
d1353 1
a1353 1
	mat_mul( model2view, Viewrot, toViewcenter );
d1355 1
a1355 1
	mat_inv( view2model, model2view );
d1370 1
a1370 1
	  mat_aet_vec( &curr_dm_list->s_info->azimuth,
d1388 2
a1389 2
	      mat_mul( model2objview, model2view, modelchanges );
	      mat_inv( objview2model, model2objview );
@


11.63
log
@mod's to eliminate jumpy sliders
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.62 1996/12/13 23:10:54 bparker Exp bparker $ (BRL)";
d354 1
a354 1

d363 1
a363 1

@


11.62
log
@weekend checkin
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.61 1996/12/12 22:10:09 bparker Exp bparker $ (BRL)";
d1194 6
a1199 2
  VSET(temp, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, temp);
@


11.61
log
@start of cleanup
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.60 1996/12/11 22:40:57 bparker Exp bparker $ (BRL)";
d874 3
a876 3
		      edit_rate_rotate[X] * 6,
		      edit_rate_rotate[Y] * 6,
		      edit_rate_rotate[Z] * 6);
d888 3
a890 3
		      -edit_rate_tran[X] / 10,
		      -edit_rate_tran[Y] / 10,
		      -edit_rate_tran[Z] / 10);
d901 1
a901 1
	bu_vls_printf(&vls, "knob -i -e aS %f\n", edit_rate_scale);
d914 3
a916 3
		      rate_rotate[X] * 6,
		      rate_rotate[Y] * 6,
		      rate_rotate[Z] * 6);
d936 3
a938 3
		      rate_slew[X] / 10.0,
		      rate_slew[Y] / 10.0,
		      rate_slew[Z] / 10.0);
@


11.60
log
@experimenting
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.59 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d873 1
a873 1
	bu_vls_printf(&vls, "knob -i ax %f ay %f az %f\n",
d887 1
a887 1
	bu_vls_printf(&vls, "knob -i aX %f aY %f aZ %f\n",
d901 1
a901 1
	bu_vls_printf(&vls, "knob -i aS %f\n", edit_rate_scale);
@


11.59
log
@experimentation
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.58 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d1189 1
a1189 1
  point_t new_pos;
a1190 4
#if 0
  if(EDIT_TRAN)
    MAT4X3PNT(model_pos, view2model, edit_absolute_tran);
#endif
d1193 3
a1195 6
#if 0
  if(EDIT_TRAN)
    MAT4X3PNT(edit_absolute_tran, model2view, model_pos);
#endif
  VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
  MAT4X3PNT(absolute_slew, model2view, new_pos);
d1197 1
a1197 1
  if(tkwin != NULL)
a1200 20
void
aslewview( view_pos )
vect_t view_pos;
{
  struct bu_vls vls;
  vect_t model_pos;
  vect_t diff;
  extern point_t e_axes_pos;

  MAT4X3PNT(model_pos, view2model, view_pos);
  VSUB2(diff, model_pos, e_axes_pos);
  VSCALE(diff, diff, 1/Viewscale);

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob aX %f aY %f aZ %f",
		diff[X], diff[Y], diff[Z]);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}

d1211 4
a1214 3
  point_t	old_model_center;
  point_t	new_model_center;
  vect_t	diff;
d1227 6
@


11.58
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.57 1996/12/04 21:14:43 bparker Exp bparker $ (BRL)";
d930 12
d949 1
d953 9
d977 1
d1191 1
d1194 1
a1194 1

d1197 1
a1197 1

d1200 1
a1200 1

a1211 1
#if 1
d1213 7
d1223 1
a1223 1
		view_pos[X], view_pos[Y], view_pos[Z]);
a1225 26
#else
  char *av[8];
  struct bu_vls x_vls, y_vls, z_vls;

  bu_vls_init(&x_vls);
  bu_vls_init(&y_vls);
  bu_vls_init(&z_vls);
  bu_vls_printf(&x_vls, "%f", view_pos[X]);
  bu_vls_printf(&y_vls, "%f", view_pos[Y]);
  bu_vls_printf(&z_vls, "%f", view_pos[Z]);

  av[0] = "knob";
  av[1] = "aX";
  av[2] = bu_vls_addr(&x_vls);
  av[3] = "aY";
  av[4] = bu_vls_addr(&y_vls);;
  av[5] = "aZ";
  av[6] = bu_vls_addr(&z_vls);;
  av[7] = NULL;

  (void)f_knob((ClientData)NULL, interp, 7, av);

  bu_vls_free(&x_vls);
  bu_vls_free(&y_vls);
  bu_vls_free(&z_vls);
#endif
@


11.57
log
@*** empty log message ***
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.56 1996/11/19 21:18:25 bparker Exp bparker $ (BRL)";
d868 39
d913 1
a913 1
	bu_vls_printf(&vls, "knob -i ax %f ay %f az %f\n",
d1169 1
a1169 1
    MAT4X3PNT(model_pos, view2model, absolute_slew);
d1174 5
a1178 6
  if(EDIT_TRAN){
    MAT4X3PNT(absolute_slew, model2view, model_pos);
  }else{
    VSET(new_pos, -orig_pos[X], -orig_pos[Y], -orig_pos[Z]);
    MAT4X3PNT(absolute_slew, model2view, new_pos);
  }
d1234 15
a1248 53
#if 1
#if 1
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob -i aX %f aY %f aZ %f",
		-view_pos[X], -view_pos[Y], -view_pos[Z]);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
#else
  char *av[9];
  struct bu_vls x_vls, y_vls, z_vls;

  bu_vls_init(&x_vls);
  bu_vls_init(&y_vls);
  bu_vls_init(&z_vls);
  bu_vls_printf(&x_vls, "%f", -view_pos[X]);
  bu_vls_printf(&y_vls, "%f", -view_pos[Y]);
  bu_vls_printf(&z_vls, "%f", -view_pos[Z]);

  av[0] = "knob";
  av[1] = "-i";
  av[2] = "aX";
  av[3] = bu_vls_addr(&x_vls);
  av[4] = "aY";
  av[5] = bu_vls_addr(&y_vls);;
  av[6] = "aZ";
  av[7] = bu_vls_addr(&z_vls);;
  av[8] = NULL;

  (void)f_knob((ClientData)NULL, interp, 8, av);

  bu_vls_free(&x_vls);
  bu_vls_free(&y_vls);
  bu_vls_free(&z_vls);
#endif
#else
	point_t	old_model_center;
	point_t	new_model_center;
	vect_t	diff;
	mat_t	delta;

	MAT_DELTAS_GET_NEG( old_model_center, toViewcenter );

	MAT4X3PNT( new_model_center, view2model, view_pos );
	MAT_DELTAS_VEC_NEG( toViewcenter, new_model_center );

	VSUB2( diff, new_model_center, old_model_center );
	mat_idn( delta );
	MAT_DELTAS_VEC( delta, diff );
	mat_mul2( delta, ModelDelta );
	new_mats();
#endif
@


11.56
log
@modified to work with Tcl 7.6 and Tk 4.2
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.55 1996/11/01 22:08:03 bparker Exp bparker $ (BRL)";
d869 13
d888 1
d1012 2
a1013 1
      dmp->dm_drawVertex2D(dmp, 0, 0, DM_YELLOW);
d1150 9
d1183 1
d1197 9
d1231 1
d1587 1
d1591 1
a1591 1

@


11.55
log
@update new s_info members
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.54 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d90 1
a91 2
struct db_i	*dbip;			/* database instance pointer */

d137 1
a137 1
Tk_FileProc stdin_input;
d332 2
a333 1
	Tk_CreateFileHandler(STDIN_FILENO, TK_READABLE, stdin_input,
d335 2
a336 1
	Tk_CreateFileHandler(dm_pipe[0], TK_READABLE, stdin_input,
d390 1
a390 1
 * routine "stdin_input" (registered with the Tk_CreateFileHandler call).
d837 1
a837 1
	while (Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT));
d839 1
a839 1
      Tk_DoOneEvent(TK_ALL_EVENTS);
@


11.54
log
@hacks to use latest libdm
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.53 1996/10/03 20:25:01 bparker Exp bparker $ (BRL)";
d357 1
d360 1
d1171 1
a1171 1
  char *av[8];
d1181 9
a1189 8
  av[0] = "iknob";
  av[1] = "aX";
  av[2] = bu_vls_addr(&x_vls);
  av[3] = "aY";
  av[4] = bu_vls_addr(&y_vls);;
  av[5] = "aZ";
  av[6] = bu_vls_addr(&z_vls);;
  av[7] = NULL;
d1191 1
a1191 1
  (void)f_knob((ClientData)NULL, interp, 7, av);
d1332 20
@


11.53
log
@get rid of extra cmdline() uses
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.52 1996/10/01 17:23:59 bparker Exp bparker $ (BRL)";
d288 1
a288 1
	dmp->dmr_window(windowbounds);
d327 1
d329 2
a330 1
	dmp->dmr_light( dmp, LIGHT_RESET, 0 );
d852 1
a852 1
    dmp->dmr_window(windowbounds);	/* hack */
d956 1
a956 1
    dmp->dmr_window(dmp, windowbounds);
d969 1
a969 1
      dmp->dmr_prolog(dmp);	/* update displaylist prolog */
d973 1
a973 1
       *  Calls dmp->dmr_newrot() and dmp->dmr_object().
d985 1
a985 1
      dmp->dmr_normal(dmp);
d994 4
a997 1
      dmp->dmr_epilog(dmp);
d1232 6
a1237 6
			event,
			dmp->dmr_name,
			now,
			getuid(),
			timep,
			arg
d1266 4
a1269 2
	  dmp->dmr_light( dmp, LIGHT_RESET, 0 );	/* turn off the lights */
	  dmp->dmr_close(dmp);
d1493 2
@


11.52
log
@no longer using dm_values
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.51 1996/09/25 20:12:07 bparker Exp bparker $ (BRL)";
d566 1
d1127 2
a1128 1
  struct bu_vls cmd;
d1130 21
a1150 5
  bu_vls_init(&cmd);
  bu_vls_printf(&cmd, "knob aX %f aY %f aZ %f\n",
		view_pos[X], view_pos[Y], view_pos[Z]);
  (void)cmdline(&cmd, FALSE);
  bu_vls_free(&cmd);
d1164 2
a1165 1
  struct bu_vls cmd;
d1167 21
a1187 5
  bu_vls_init(&cmd);
  bu_vls_printf(&cmd, "iknob aX %f aY %f aZ %f\n",
		-view_pos[X], -view_pos[Y], -view_pos[Z]);
  (void)cmdline(&cmd, FALSE);
  bu_vls_free(&cmd);
@


11.51
log
@include mged_solid.h and use BU_LIST_INIT on
HeadSolid and FreeSolid
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.50 1996/09/23 18:28:16 bparker Exp bparker $ (BRL)";
a92 2
struct device_values dm_values;		/* Dev Values, filled by dm-XX.c */

a264 1
	bu_vls_init( &dm_values.dv_string );
d831 1
a831 17
	while (Tk_DoOneEvent(TK_ALL_EVENTS|TK_DONT_WAIT)) {
	    if( cmdline_hook )  
		(*cmdline_hook)( &dm_values.dv_string ); 
	    else {
		/* Some commands (e.g. mouse events) queue further events. */
		int oldlen;
loopagain:
		oldlen = bu_vls_strlen( &dm_values.dv_string );
		(void)cmdline( &dm_values.dv_string, FALSE );
		if( bu_vls_strlen( &dm_values.dv_string ) > oldlen ) {
		    /* Remove cmds already done, and go again */
		    bu_vls_nibble( &dm_values.dv_string, oldlen );
		    goto loopagain;
		}
	    }
	    bu_vls_trunc( &dm_values.dv_string, 0 );
	}
a838 23
     *  Process any "string commands" sent to us by the display manager.
     *  (Or "invented" here, for compatability with old dm's).
     *  Each one is expected to be newline terminated.
     */

    if( cmdline_hook )  
	(*cmdline_hook)(&dm_values.dv_string); 
    else {
	/* Some commands (e.g. mouse events) queue further events. */
	int oldlen;
again:
	oldlen = bu_vls_strlen( &dm_values.dv_string );
	(void)cmdline( &dm_values.dv_string, FALSE );
	if( bu_vls_strlen( &dm_values.dv_string ) > oldlen ) {
	    /* Remove cmds already done, and go again */
	    bu_vls_nibble( &dm_values.dv_string, oldlen );
	    goto again;
	}
    }

    bu_vls_trunc( &dm_values.dv_string, 0 );
    
    /*
d1270 1
a1271 1
  (void)signal( SIGINT, SIG_IGN );
@


11.50
log
@ use LIBDM permanently
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.49 1996/09/17 21:18:20 bparker Exp bparker $ (BRL)";
d81 1
a81 1
#include "./solid.h"
d209 2
a210 3
	HeadSolid.s_forw = &HeadSolid;
	HeadSolid.s_back = &HeadSolid;
	FreeSolid = SOLID_NULL;
@


11.49
log
@prepare to use libdm
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.48 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d83 1
a83 1
#include "./dm.h"
a331 1
#ifdef USE_LIBDM
a332 3
#else
	dmp->dmr_light( LIGHT_RESET, 0 );
#endif
a995 1
#ifdef USE_LIBDM
a996 3
#else
    dmp->dmr_window(windowbounds);
#endif
a1008 1
#ifdef USE_LIBDM
a1009 3
#else
      dmp->dmr_prolog();	/* update displaylist prolog */
#endif
a1024 1
#ifdef USE_LIBDM
a1025 3
#else
      dmp->dmr_normal();
#endif
a1033 1
#ifdef USE_LIBDM
a1034 3
#else
      dmp->dmr_epilog();
#endif
a1268 1
#ifdef USE_LIBDM
a1270 4
#else
	  dmp->dmr_light( LIGHT_RESET, 0 );	/* turn off the lights */
	  dmp->dmr_close();
#endif
@


11.48
log
@rt_list ---> bu_list
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.47 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d332 3
d336 1
d1000 3
d1004 1
d1017 3
d1021 1
d1037 3
d1041 1
d1049 4
a1052 1
		
d1054 1
d1289 4
d1295 1
@


11.47
log
@now using libbu
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.46 1996/08/22 20:59:31 bparker Exp bparker $ (BRL)";
d75 1
a77 2
#include "rtlist.h"
#include "rtstring.h"
d212 1
a212 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );
d215 1
a215 1
	RT_LIST_INIT(&head_cmd_list.l);
d221 1
a221 1
	RT_LIST_INIT( &head_dm_list.l );
d896 1
a896 1
    for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d989 1
a989 1
  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d1047 1
a1047 1
  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d1266 1
a1266 1
	for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d1336 1
a1336 1
	    for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
@


11.46
log
@changed fd from int to long.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.45 1996/07/25 19:07:26 bparker Exp bparker $ (BRL)";
d118 1
a118 1
static struct rt_vls input_str, scratchline, input_str_prefix;
d137 1
a137 1
struct rt_vls mged_prompt;
d198 1
a198 1
	 * Do not use rt_log() or rt_malloc() before here.
d200 1
a200 1
	if( rt_avail_cpus() > 1 )  {
d217 2
a218 2
	rt_vls_init(&head_cmd_list.name);
	rt_vls_strcpy(&head_cmd_list.name, "mged");
d225 1
a225 1
	curr_dm_list->s_info = (struct shared_info *)rt_malloc(sizeof(struct shared_info),
d234 2
a235 2
	rt_vls_init(&pathName);
	rt_vls_strcpy(&pathName, "nu");
d268 6
a273 6
	rt_vls_init( &curr_cmd_list->more_default );
	rt_vls_init( &dm_values.dv_string );
	rt_vls_init(&input_str);
	rt_vls_init(&input_str_prefix);
	rt_vls_init(&scratchline);
	rt_vls_init(&mged_prompt);
d290 1
a290 1
	  rt_log("%s", interp->result);
d316 1
a316 1
	    rt_vls_printf(&input_str, "%s ", *argv);
d319 1
a319 1
	  rt_vls_free(&input_str);
d343 1
a343 1
	rt_vls_strcpy(&mged_prompt, MGED_PROMPT);
d377 1
a377 1
		rt_log("%S", &mged_prompt);
d383 1
a383 1
    rt_log("%c", 7);
d398 1
a398 1
extern struct rt_vls *history_prev(), *history_cur(), *history_next();
d414 2
a415 2
    struct rt_vls *vp;
    struct rt_vls temp;
d427 1
a427 1
	rt_vls_init(&temp);
d430 1
a430 1
	if( rt_vls_gets(&temp, stdin) < 0 )
d432 1
a432 1
	rt_vls_vlscat(&input_str, &temp);
d438 3
a440 3
	if(!rt_vls_strlen(&input_str) && rt_vls_strlen(&curr_cmd_list->more_default))
	  rt_vls_printf(&input_str_prefix, "%s%S\n",
			rt_vls_strlen(&input_str_prefix) > 0 ? " " : "",
d443 2
a444 2
	  rt_vls_printf(&input_str_prefix, "%s%S\n",
			rt_vls_strlen(&input_str_prefix) > 0 ? " " : "",
d447 1
a447 1
	rt_vls_trunc(&curr_cmd_list->more_default, 0);
d451 1
a451 1
	if (Tcl_CommandComplete(rt_vls_addr(&input_str_prefix))) {
d458 2
a459 2
		rt_vls_trunc(&input_str, 0);
		rt_vls_trunc(&input_str_prefix, 0);
d464 3
a466 3
		    rt_vls_trunc(&input_str_prefix,
				 rt_vls_strlen(&input_str_prefix)-1);
		    rt_vls_trunc(&input_str, 0);
d470 2
a471 2
		    rt_vls_trunc(&input_str_prefix, 0);
		    rt_vls_trunc(&input_str, 0);
d479 1
a479 1
	    rt_vls_trunc(&input_str, 0);
d483 1
a483 1
	rt_vls_free(&temp);
d533 1
a533 1
	rt_log("\n");   /* Display newline */
d539 3
a541 3
	if(!rt_vls_strlen(&input_str) && rt_vls_strlen(&curr_cmd_list->more_default))
	  rt_vls_printf(&input_str_prefix, "%s%S\n",
			rt_vls_strlen(&input_str_prefix) > 0 ? " " : "",
d544 2
a545 2
	  rt_vls_printf(&input_str_prefix, "%s%S\n",
			rt_vls_strlen(&input_str_prefix) > 0 ? " " : "",
d548 1
a548 1
	rt_vls_trunc(&curr_cmd_list->more_default, 0);
d553 1
a553 1
	if (Tcl_CommandComplete(rt_vls_addr(&input_str_prefix))) {
d566 2
a567 2
		rt_vls_trunc(&input_str, 0);
		rt_vls_trunc(&input_str_prefix, 0);
d573 3
a575 3
		    rt_vls_trunc(&input_str_prefix,
				 rt_vls_strlen(&input_str_prefix)-1);
		    rt_vls_trunc(&input_str, 0);
d580 2
a581 2
		    rt_vls_trunc(&input_str_prefix, 0);
		    rt_vls_trunc(&input_str, 0);
d588 2
a589 2
	    rt_vls_trunc(&input_str, 0);
	    rt_vls_strcpy(&mged_prompt, "\r? ");
d606 3
a608 3
	if (input_str_index == rt_vls_strlen(&input_str)) {
	    rt_log("\b \b");
	    rt_vls_trunc(&input_str, rt_vls_strlen(&input_str)-1);
d610 4
a613 4
	    rt_vls_init(&temp);
	    rt_vls_strcat(&temp, rt_vls_addr(&input_str)+input_str_index);
	    rt_vls_trunc(&input_str, input_str_index-1);
	    rt_log("\b%S ", &temp);
d615 3
a617 3
	    rt_log("%S", &input_str);
	    rt_vls_vlscat(&input_str, &temp);
	    rt_vls_free(&temp);
d628 3
a630 3
	if (input_str_index < rt_vls_strlen(&input_str)) {
	    rt_log("%s", rt_vls_addr(&input_str)+input_str_index);
	    input_str_index = rt_vls_strlen(&input_str);
d635 1
a635 1
	if (input_str_index == rt_vls_strlen(&input_str)) {
d639 4
a642 4
	rt_vls_init(&temp);
	rt_vls_strcat(&temp, rt_vls_addr(&input_str)+input_str_index+1);
	rt_vls_trunc(&input_str, input_str_index);
	rt_log("%S ", &temp);
d644 3
a646 3
	rt_log("%S", &input_str);
	rt_vls_vlscat(&input_str, &temp);
	rt_vls_free(&temp);
d651 1
a651 1
	rt_log("%*s", rt_vls_strlen(&input_str), SPACES);
d653 1
a653 1
	rt_vls_trunc(&input_str, 0);
d658 2
a659 2
	rt_log("%*s", rt_vls_strlen(&input_str)-input_str_index, SPACES);
	rt_vls_trunc(&input_str, input_str_index);
d661 1
a661 1
	rt_log("%S", &input_str);
d665 1
a665 1
	rt_log("\n");
d667 2
a668 2
	rt_log("%S", &input_str);
	if (input_str_index == rt_vls_strlen(&input_str))
d671 1
a671 1
	rt_log("%*S", input_str_index, &input_str);
d680 1
a680 1
	rt_log("\b"); /* hopefully non-destructive! */
d684 1
a684 1
	if (input_str_index == rt_vls_strlen(&input_str)) {
d689 1
a689 1
	rt_log("%c", rt_vls_addr(&input_str)[input_str_index]);
d698 2
a699 2
	if (input_str_index == rt_vls_strlen(&input_str)) {
	    rt_log("\b");
d702 5
a706 5
	ch = rt_vls_addr(&input_str)[input_str_index];
	rt_vls_addr(&input_str)[input_str_index] =
	    rt_vls_addr(&input_str)[input_str_index - 1];
	rt_vls_addr(&input_str)[input_str_index - 1] = ch;
	rt_log("\b%*s", 2, rt_vls_addr(&input_str)+input_str_index-1);
d721 2
a722 2
		rt_vls_trunc(&scratchline, 0);
		rt_vls_vlscat(&scratchline, &input_str);
d744 1
a744 1
	rt_log("%*s", rt_vls_strlen(&input_str), SPACES);
d746 6
a751 6
	rt_vls_trunc(&input_str, 0);
	rt_vls_vlscat(&input_str, vp);
	if (rt_vls_addr(&input_str)[rt_vls_strlen(&input_str)-1] == '\n')
	    rt_vls_trunc(&input_str, rt_vls_strlen(&input_str)-1); /* del \n */
	rt_log("%S", &input_str);
	input_str_index = rt_vls_strlen(&input_str);
d763 3
a765 3
	if (input_str_index == rt_vls_strlen(&input_str)) {
	    rt_log("%c", (int)ch);
	    rt_vls_putc(&input_str, (int)ch);
d768 4
a771 4
	    rt_vls_init(&temp);
	    rt_vls_strcat(&temp, rt_vls_addr(&input_str)+input_str_index);
	    rt_vls_trunc(&input_str, input_str_index);
	    rt_log("%c%S", (int)ch, &temp);
d773 3
a775 3
	    rt_vls_putc(&input_str, (int)ch);
	    rt_log("%S", &input_str);
	    rt_vls_vlscat(&input_str, &temp);
d777 1
a777 1
	    rt_vls_free(&temp);
d800 1
a800 1
  rt_log("\r%s\n", argv[1]);
d802 1
a802 1
  rt_log("%s", rt_vls_addr(&input_str));
d805 1
a805 1
    rt_log("%c", rt_vls_addr(&input_str)[i]);
d843 1
a843 1
		oldlen = rt_vls_strlen( &dm_values.dv_string );
d845 1
a845 1
		if( rt_vls_strlen( &dm_values.dv_string ) > oldlen ) {
d847 1
a847 1
		    rt_vls_nibble( &dm_values.dv_string, oldlen );
d851 1
a851 1
	    rt_vls_trunc( &dm_values.dv_string, 0 );
d871 1
a871 1
	oldlen = rt_vls_strlen( &dm_values.dv_string );
d873 1
a873 1
	if( rt_vls_strlen( &dm_values.dv_string ) > oldlen ) {
d875 1
a875 1
	    rt_vls_nibble( &dm_values.dv_string, oldlen );
d880 1
a880 1
    rt_vls_trunc( &dm_values.dv_string, 0 );
d926 1
a926 1
	struct rt_vls vls;
d932 3
a934 3
	rt_vls_init(&vls);
	rt_vls_printf(&vls, "%f", 1.0 / (1.0 - (rate_zoom / 10.0)));
	av[1] = rt_vls_addr(&vls);
d936 1
a936 1
	rt_vls_free(&vls);
d1037 1
a1037 1
      (void)rt_get_timer( (struct rt_vls *)0, &elapsed_time );
d1170 1
a1170 1
  struct rt_vls cmd;
d1172 2
a1173 2
  rt_vls_init(&cmd);
  rt_vls_printf(&cmd, "knob aX %f aY %f aZ %f\n",
d1176 1
a1176 1
  rt_vls_free(&cmd);
d1190 1
a1190 1
  struct rt_vls cmd;
d1192 2
a1193 2
  rt_vls_init(&cmd);
  rt_vls_printf(&cmd, "iknob aX %f aY %f aZ %f\n",
d1196 1
a1196 1
  rt_vls_free(&cmd);
d1299 3
a1301 3
  rt_vls_trunc(&input_str, 0);
  rt_vls_trunc(&input_str_prefix, 0);
  rt_vls_trunc(&curr_cmd_list->more_default, 0);
d1304 2
a1305 2
  rt_vls_strcpy(&mged_prompt, MGED_PROMPT);
  rt_log("\n");
d1370 1
a1370 1
	struct	rt_vls str;
d1374 1
a1374 1
	rt_vls_init( &str );
d1381 1
a1381 1
			rt_vls_strcpy( &str, path );
d1388 3
a1390 3
			rt_vls_strcpy( &str, path );
			rt_vls_strcat( &str, "/" );
			rt_vls_strcat( &str, RCFILE );
d1392 1
a1392 1
		if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
d1398 1
a1398 1
			rt_vls_strcpy( &str, RCFILE );
d1422 4
a1425 4
	    rt_log("\nWARNING: The new format of the \"set\" command is:\n");
	    rt_log("    set varname value\n");
	    rt_log("If you are setting variables in your %s, you will ", RCFILE);
	    rt_log("need to change those\ncommands.\n\n");
d1427 2
a1428 2
	if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
	    rt_log("Error reading %s: %s\n", RCFILE, interp->result);
d1483 1
a1483 1
	      rt_log("Create new database (y|n)[n]? ");
d1493 1
a1493 1
		rt_vls_printf(&curr_cmd_list->more_default, "n");
@


11.45
log
@*** empty log message ***
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.44 1996/07/22 15:53:17 bparker Exp bparker $ (BRL)";
d419 1
a419 1
    int fd;
d421 1
a421 1
    fd = (int)clientData;
d489 1
a489 1
    count = read(fd, (void *)&ch, 1);
@


11.44
log
@modified setview
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.43 1996/07/19 21:08:34 bparker Exp bparker $ (BRL)";
d276 1
a276 1
	/* Get set up to use Tcl/Tk */
@


11.43
log
@if'd out note about attach command
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.42 1996/07/15 20:37:18 bparker Exp bparker $ (BRL)";
d1146 1
a1146 3
#define TRY_NEW_STUFF 1
#if TRY_NEW_STUFF
  vect_t view_pos;
a1147 3
  point_t old_pos;
  point_t diff;
  mat_t newrot;
d1149 2
a1150 2
  MAT_DELTAS_GET(old_pos, toViewcenter);
#endif
d1153 1
d1155 5
a1159 7
#if TRY_NEW_STUFF
  mat_idn( newrot );
  mat_mul2( newrot, Viewrot );
  {
    mat_t   newinv;
    mat_inv( newinv, newrot );
    wrt_view( ModelDelta, newinv, ModelDelta );
a1160 1
#endif
d1162 2
a1163 10
  new_mats();

#if TRY_NEW_STUFF
  MAT_DELTAS_GET_NEG(new_pos, toViewcenter);
  VSUB2(diff, new_pos, orig_pos);
  VADD2(new_pos, old_pos, diff);
  VSET(view_pos, new_pos[X], new_pos[Y], new_pos[Z]);
  MAT4X3PNT( new_pos, model2view, view_pos);
  VMOVE( absolute_slew, new_pos );
#endif
@


11.42
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.41 1996/07/10 20:19:38 bparker Exp bparker $ (BRL)";
d1534 1
d1537 1
@


11.41
log
@added aslewview which is being called from f_mouse()
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.40 1996/06/25 20:56:33 bparker Exp bparker $ (BRL)";
d306 5
a310 1
	  char *av[] = {"q", NULL};
d491 4
a494 1
      char *av[] = {"q", NULL};
a925 1
	char *av[] = {"zoom", NULL, NULL};
d927 1
d929 3
d1472 4
a1475 1
	  char *av[] = { "zap", NULL };
@


11.40
log
@handling rate_zoom by calling f_zoom
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.39 1996/06/21 15:56:06 bparker Exp bparker $ (BRL)";
d1169 13
@


11.39
log
@using multiple command capability of knob
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.38 1996/06/14 20:11:20 bparker Exp bparker $ (BRL)";
d917 14
d950 1
@


11.38
log
@using vls for name
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.37 1996/06/04 20:48:20 bparker Exp bparker $ (BRL)";
d1004 1
a1004 1
      if (adcflag)
d1170 1
a1170 5
#if 1
  rt_vls_printf(&cmd, "iknob aX %f; iknob aY %f\n",
		-view_pos[X], -view_pos[Y]);
#else
  rt_vls_printf(&cmd, "iknob aX %f; iknob aY %f; iknob aZ %f\n",
a1171 1
#endif
@


11.37
log
@modified setview to update absolute_slew
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.36 1996/05/24 19:07:22 bparker Exp bparker $ (BRL)";
d217 2
a218 1
	strcpy((char *)head_cmd_list.name, "mged");
d1170 4
d1176 1
@


11.36
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.35 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d1120 33
a1152 2
	buildHrot( Viewrot, a1 * degtorad, a2 * degtorad, a3 * degtorad );
	new_mats();
@


11.35
log
@Still Tcl'ing the code
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.34 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d1134 9
d1158 1
@


11.34
log
@still tcl-converting
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.33 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d108 1
a108 1
static jmp_buf	jmp_env;		/* For non-local gotos */
d111 1
a111 2
void            (*cmdline_sig)();
void		sig2();
d336 1
a336 20
	/* Caught interrupts take us back here, via longjmp() */
	if( setjmp( jmp_env ) == 0 )  {
		/* First pass, determine SIGINT handler for interruptable cmds */
		if( cur_sigint == (void (*)())SIG_IGN )
			cur_sigint = (void (*)())SIG_IGN; /* detached? */
		else
			cur_sigint = sig2;	/* back to here w/!0 return */
	} else {
		rt_log("\nAborted.\n");
		/* If parallel routine was interrupted, need to reset */
		RES_RELEASE( &rt_g.res_syscall );
		RES_RELEASE( &rt_g.res_worker );
		RES_RELEASE( &rt_g.res_stats );
		RES_RELEASE( &rt_g.res_results );
		/* Truncate input string */
		rt_vls_trunc(&input_str, 0);
		rt_vls_trunc(&input_str_prefix, 0);
		rt_vls_trunc(&curr_cmd_list->more_default, 0);
		input_str_index = 0;
	}
a347 2
	cmdline_sig = SIG_IGN;

a348 2
		(void)signal( SIGINT, cmdline_sig );

d432 11
a442 5
	rt_vls_trunc(&temp, 0);
	rt_vls_vlscat(&temp, &input_str_prefix);  /* Make a backup copy */
	rt_vls_printf(&input_str_prefix, "%s%S\n",
		      rt_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		      &input_str);
d447 3
a449 1
	    cmdline_sig = SIG_IGN; /* Ignore interrupts when command finishes*/
d455 1
a455 1
		input_str_index = 0;
d462 2
a463 1
		    cmdline_sig = sig2;  /* Still in CMD_MORE; allow ^C. */
d467 1
d476 1
a476 1
	    cmdline_sig = sig2;
a529 5
	rt_vls_init(&temp);
	
	rt_vls_trunc(&temp, 0);
	rt_vls_vlscat(&temp, &input_str_prefix);  /* Make a backup copy */

a545 1
	    cmdline_sig = SIG_IGN;
d547 2
d551 1
d554 1
d557 1
d560 1
d568 1
a568 1
		    cmdline_sig = sig2; /* Allow ^C */
d571 1
d574 1
a574 1
		    /* All done; clear all strings. */
a580 3
#if 0
	    rt_vls_strcpy(&mged_prompt, "? ");
#else
d582 1
a582 1
#endif
d584 1
a584 1
	    cmdline_sig = sig2;
a589 1
	rt_vls_free(&temp);
d1233 18
a1250 3
    rt_vls_strcpy(&mged_prompt, MGED_PROMPT);
    longjmp( jmp_env, 1 );
	/* NOTREACHED */
a1262 10
#if 0
	mat_mul( model2view, Viewrot, toViewcenter );
	model2view[15] = Viewscale;
	mat_inv( view2model, model2view );
	if( state != ST_VIEW )  {
		mat_mul( model2objview, model2view, modelchanges );
		mat_inv( objview2model, model2objview );
	}
	dmaflag = 1;
#else
a1285 1
#endif
@


11.33
log
@convert commands to Tcl
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.32 1996/04/03 22:08:55 bparker Exp bparker $ (BRL)";
d109 1
d276 2
a277 2
	/* Perform any necessary initializations for the command parser */
	cmd_setup(interactive);
a278 4
	/* Initialize the menu mechanism to be off, but ready. */
	mmenu_init();
	btn_head_menu(0,0,0);		/* unlabeled menu */

d292 1
d294 1
d306 10
a315 9
#if 0
		mged_cmd( argc-2, argv+2, (struct funtab *)NULL );
#else
		/*
		   Call cmdline instead of calling mged_cmd directly
		   so that access to Tcl/Tk is possible.
	        */
		for(argc -= 2, argv += 2; argc; --argc, ++argv)
		  rt_vls_printf(&input_str, "%s ", *argv);
d317 2
a318 5
		cmdline(&input_str, TRUE);
		rt_vls_free(&input_str);
#endif
		f_quit((ClientData)NULL, interp, 0, NULL);
		/* NOTREACHED */
d499 5
a503 2
    if (count <= 0 && feof(stdin))
	f_quit((ClientData)NULL, interp, 0, NULL);
d795 25
d900 2
d903 1
d988 1
a1404 1
	  int ac = 1;
d1411 1
a1411 1
	  f_zap(clientData, interp, ac, av);
a1461 12
#if 0
	if( interactive && is_dm_null() )  {
		/*
		 * This is an interactive mged, with no display yet.
		 * Ask which DM, and fire up the display manager.
		 * Ask this question BEFORE the db_scan, because
		 * that can take a long time for large models.
		 */

		get_attached();
	}
#else
a1466 2
	  
#endif
@


11.32
log
@fixed typo in stdin_input
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.31 1996/04/01 22:13:12 bparker Exp bparker $ (BRL)";
d227 4
d232 1
d290 4
a293 1
	f_opendb( argc, argv );
d320 1
a320 1
		f_quit(0, NULL);
d503 1
a503 1
	f_quit(0, NULL);
d1027 3
a1029 1
f_vrot_center( argc, argv )
d1033 5
a1037 2
	rt_log("Not ready until tomorrow.\n");
	return CMD_OK;
d1367 3
a1369 1
f_opendb( argc, argv )
d1373 2
d1376 2
a1377 2
		/* Clear out anything in the display */
		f_zap( 0, (char **)NULL );
d1379 2
a1380 3
		/* Close current database.  Releases MaterHead, etc. too. */
		db_close(dbip);
		dbip = DBI_NULL;
d1382 8
a1389 1
		log_event( "CEASE", "(close)" );
d1395 19
a1413 1
		char line[128];
d1415 12
a1426 14
		if( isatty(0) ) {
		    perror( argv[1] );
		    rt_log("Create new database (y|n)[n]? ");
		    (void)fgets(line, sizeof(line), stdin);
		    if( line[0] != 'y' && line[0] != 'Y' )
			exit(0);		/* NOT finish() */
		} else
		    rt_log("Creating new database \"%s\"\n", argv[1]);
			

		if( (dbip = db_create( argv[1] )) == DBI_NULL )  {
			perror( argv[1] );
			exit(2);		/* NOT finish() */
		}
d1429 1
a1429 1
		rt_log("%s:  READ ONLY\n", dbip->dbi_filename );
d1434 1
d1442 1
a1442 1
#if 0
d1444 8
a1452 1
	}
d1463 2
a1464 2
		rt_log("%s (units=%s)\n", dbip->dbi_title,
			units_str[dbip->dbi_localunit] );
d1466 2
a1467 1
	return CMD_OK;
@


11.31
log
@added code to help handle multiple command windows
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.30 1996/03/25 21:54:50 bparker Exp bparker $ (BRL)";
d262 1
d307 1
a307 1
		  rt_vls_strcat(&input_str, *argv);
d349 1
d468 1
a468 1
		if (cmdline(&input_str, TRUE) == CMD_MORE) {
d540 12
a551 3
	rt_vls_printf(&input_str_prefix, "%s%S\n",
		      rt_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		      &input_str);
@


11.30
log
@call dotitles to force the mged_display variables to be initialized
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.29 1996/03/22 18:27:28 bparker Exp bparker $ (BRL)";
d215 5
d547 1
d703 1
a703 1

d819 1
a819 1
	Tk_DoOneEvent(TK_ALL_EVENTS);
@


11.29
log
@-modify new_mats to update matrices for all display
managers while state != ST_VIEW.
-clean up
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.28 1996/03/11 21:45:12 bparker Exp bparker $ (BRL)";
d215 1
d225 2
a270 2
	dmaflag = 1;

d310 1
d312 4
d1385 1
d1387 1
@


11.28
log
@a few changes in support of the "tie" command
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.27 1996/03/01 19:22:13 bparker Exp bparker $ (BRL)";
a89 1
#ifdef SEND_KEY_DOWN_PIPE
a90 1
#endif
a95 1
#ifdef MULTI_ATTACH
a98 3
#else
int		dmaflag;		/* Set to 1 to force new screen DMA */
#endif
a214 1
#ifdef MULTI_ATTACH
a223 1
#endif
a313 1
#ifdef SEND_KEY_DOWN_PIPE 
a318 4
#else
	Tk_CreateFileHandler(fileno(stdin), TK_READABLE, stdin_input,
			     (ClientData)NULL);
#endif
a419 1
#ifdef SEND_KEY_DOWN_PIPE
a422 1
#endif
a479 1
#ifdef SEND_KEY_DOWN_PIPE
a480 3
#else
    count = read(fileno(stdin), (void *)&ch, 1);
#endif
a777 1
#ifdef MULTI_ATTACH
a779 1
#endif
a845 1
#ifdef MULTI_ATTACH
d848 2
a851 1
#endif
d853 4
a856 4
    /*********************************
     *  Handle rate-based processing *
     *********************************/
    if( rateflag_rotate )  {
d863 2
a864 2
    }
    if( rateflag_slew )  {
d872 2
a873 2
    }
    if( rateflag_zoom )  {
a891 1
	dmaflag = 1;
d893 3
a896 4
#ifdef MULTI_ATTACH
        curr_dm_list = save_dm_list;
    }
#endif
a917 1
#ifdef MULTI_ATTACH
d933 2
a934 8
#else
	/*
	 * if something has changed, then go update the display.
	 * Otherwise, we are happy with the view we have
	 */
	if( dmaflag )  {
		double	elapsed_time;
#endif
d936 1
a936 2
		/* XXX VR hack */
		if( viewpoint_hook )  (*viewpoint_hook)();
d938 2
a939 1
		rt_prep_timer();
d941 21
a961 2
		if( mged_variables.predictor )
			predictor_frame();
d963 4
a966 21
		dmp->dmr_prolog();	/* update displaylist prolog */

		/*  Draw each solid in it's proper place on the screen
		 *  by applying zoom, rotation, & translation.
		 *  Calls dmp->dmr_newrot() and dmp->dmr_object().
		 */
		if( mged_variables.eye_sep_dist <= 0 )  {
			/* Normal viewing */
			dozoom(0);
		} else {
			/* Stereo viewing */
			dozoom(1);
			dozoom(2);
		}

		/* Restore to non-rotated, full brightness */
		dmp->dmr_normal();

		/* Compute and display angle/distance cursor */
		if (adcflag)
			adcursor();
d968 6
a973 4
		/* Display titles, etc., if desired */
		dotitles(mged_variables.faceplate);
		
		dmp->dmr_epilog();
a974 7
		(void)rt_get_timer( (struct rt_vls *)0, &elapsed_time );
		/* Only use reasonable measurements */
		if( elapsed_time > 1.0e-5 && elapsed_time < 30 )  {
			/* Smoothly transition to new speed */
			frametime = 0.9 * frametime + 0.1 * elapsed_time;
		}
#ifdef MULTI_ATTACH
d979 5
a985 10
  dmaflag = 0;
#else
  } else {
		/* For displaylist machines??? */
		dmp->dmr_prolog();	/* update displaylist prolog */
		dmp->dmr_update();
	}

	dmaflag = 0;
#endif
a1017 2
	dmaflag = 1;

d1149 1
d1153 3
a1155 2
	dmp->dmr_light( LIGHT_RESET, 0 );	/* turn off the lights */
	dmp->dmr_close();
d1157 4
d1200 1
d1209 25
@


11.27
log
@remove unused XMGED stuff
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.26 1996/02/12 21:49:08 bparker Exp bparker $ (BRL)";
d101 1
d225 4
d954 1
a954 1
    if(update_views || dmaflag) {
d1008 1
a1008 1
      dmaflag = 0;
d1014 1
@


11.26
log
@*** empty log message ***
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.25 1996/01/17 22:11:57 bparker Exp bparker $ (BRL)";
a85 27
#ifdef XMGED

extern int      (*editline_hook)();
extern int	(*fgetc_hook)();
extern int	(*fputc_hook)();
extern int	(*fputs_hook)();
extern char	*(*fgets_hook)();
extern char	*(*gets_hook)();
extern void	(*fprintf_hook)();
extern int	(*button_hook)();
extern int	(*slider_hook)();
extern int	(*openw_hook)();
extern int	(*closew_hook)();
extern int	(*adc_hook)();
extern void	(*wait_hook)();
extern void	(*dotitles_hook)();
extern int     (*tran_hook)();
extern int     (*rot_hook)(), (*set_tran_hook)();
extern void set_tran();
extern point_t orig_pos;
extern int tran_set;
extern double tran_x;
extern double tran_y;
extern double tran_z;
extern int journal;
#endif

a107 6
int             (*knob_hook)() = NULL;
int             (*cue_hook)() = NULL;
int             (*zclip_hook)() = NULL;
int             (*zbuffer_hook)() = NULL;
int             (*light_hook)() = NULL;
int             (*perspective_hook)() = NULL;
a109 2
void            (*axis_color_hook)() = NULL;
void            (*knob_offset_hook)() = NULL;
a131 4
#ifdef XMGED
extern int      already_scandb;
#endif

a161 20
#ifdef XMGED
	editline_hook = NULL;
	fputc_hook = NULL;
	fputs_hook = NULL;
	fprintf_hook = NULL;
	fgets_hook = NULL;
	gets_hook = NULL;
	fgetc_hook = NULL;
	button_hook = NULL;
	slider_hook = NULL;
	openw_hook = NULL;
	closew_hook = NULL;
	adc_hook = NULL;
	dotitles_hook = NULL;
	wait_hook = NULL;
	tran_hook = NULL;
	rot_hook = NULL;
	set_tran_hook = NULL;
#endif

d224 2
a365 3
#ifdef XMGED
		/* now being done in cmd.c/mged_cmd() */
#else
a371 1
#endif
d428 1
a428 1
#if TRY_PIPES
d490 1
a490 1
#if TRY_PIPES
a1105 15
#ifdef XMGED
  point_t old_pos;
  point_t new_pos;
  point_t new_pos2;
  point_t diff;
  vect_t view_pos;
  
  MAT_DELTAS_GET(old_pos, toViewcenter);

  if(state == ST_S_EDIT || state == ST_O_EDIT){
    VSET(view_pos, tran_x, tran_y, tran_z);
    MAT4X3PNT( new_pos2, view2model, view_pos );
  }
#endif

a1107 22

#ifdef XMGED
  MAT_DELTAS_GET_NEG(new_pos, toViewcenter);

  if(state == ST_S_EDIT || state == ST_O_EDIT){
    MAT4X3PNT(view_pos, model2view, new_pos2);
    tran_x = view_pos[X];
    tran_y = view_pos[Y];
    tran_z = view_pos[Z];
  }else{
    VSUB2(diff, new_pos, orig_pos);
    VADD2(new_pos, old_pos, diff);
    VSET(view_pos, new_pos[X], new_pos[Y], new_pos[Z]);
    MAT4X3PNT( new_pos, model2view, view_pos);
    tran_x = new_pos[X];
    tran_y = new_pos[Y];
    tran_z = new_pos[Z];
  }

  if(tran_hook)
          (*tran_hook)();
#endif
a1134 11

#ifdef XMGED
	if(!tran_set){
	  tran_x -= view_pos[X];
	  tran_y -= view_pos[Y];
	  tran_z -= view_pos[Z];
	}

	if(tran_hook)
	  (*tran_hook)();
#endif
a1292 1
#ifndef XMGED
d1315 1
a1315 4
#else
	mged_source_file( fp );
	fclose( fp );
#endif
@


11.25
log
@playing it safe
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.24 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
d117 2
a118 4
#define TRY_PIPES 1

#if TRY_PIPES
int ged_pipe[2];
d374 2
a375 2
#if TRY_PIPES
	(void)pipe(ged_pipe);
d378 2
a379 2
	Tk_CreateFileHandler(ged_pipe[0], TK_READABLE, stdin_input,
			     (ClientData)ged_pipe[0]);
@


11.24
log
@Just playing it safe
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.23 1995/12/01 23:06:10 bparker Exp bparker $ (BRL)";
d855 4
d925 7
d974 4
@


11.23
log
@initialized acc_rot_sol. It was breaking the e_axis.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.22 1995/11/30 22:50:28 bparker Exp bparker $ (BRL)";
d127 4
d132 2
d146 1
a169 1
extern int    update_views;
d281 6
d291 1
a292 1
	mat_idn( identity );		/* Handy to have around */
d330 2
a338 2
	dmaflag = 1;

d359 1
a359 1
		   so that access to tcl is possible.
d984 17
d1007 1
d1050 9
a1058 1
	} else {
d1065 1
a1436 80
#ifdef XMGED
        struct db_i *o_dbip;

	o_dbip = dbip;  /* save pointer to old database */

	/* Get input file */
	if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
	    ((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
		char line[128];

		dbip = o_dbip; /* reinitialize in case of control-C */

		if( isatty(0) ) {
		    perror( argv[1] );
		    rt_log("Create new database (y|n)[n]? ");
		    (void)mged_fgets(line, sizeof(line), stdin);
		    if( line[0] != 'y' && line[0] != 'Y' ){
		      if(dbip != DBI_NULL){
			rt_log( "Still using %s\n", dbip->dbi_title);
			return(CMD_OK);
		      }

		      exit(0);		/* NOT finish() */
		    }
		} else
		  rt_log("Creating new database \"%s\"\n", argv[1]);

		if( (dbip = db_create( argv[1] )) == DBI_NULL )  {
			perror( argv[1] );
			exit(2);		/* NOT finish() */
		}
	}

	already_scandb = 0;
	if( o_dbip )  {
		/* Clear out anything in the display */
		f_zap( 0, (char **)NULL );

		/* Close current database.  Releases rt_material_head, etc. too. */
		db_close(o_dbip);

		log_event( "CEASE", "(close)" );
	}

	if( dbip->dbi_read_only )
		(void)rt_log( "%s:  READ ONLY\n", dbip->dbi_filename );

	/* Quick -- before he gets away -- write a logfile entry! */
	log_event( "START", argv[1] );

	if( interactive && is_dm_null() )  {
		/*
		 * This is an interactive mged, with no display yet.
		 * Ask which DM, and fire up the display manager.
		 * Ask this question BEFORE the db_scan, because
		 * that can take a long time for large models.
		 */
		get_attached();
	}

	/* --- Scan geometry database and build in-memory directory --- */
	if(!already_scandb){	/* need this because the X display manager may
					scan the database */
		db_scan( dbip, (int (*)())db_diradd, 1);
		already_scandb = 1;
	}

	/* XXX - save local units */
	localunit = dbip->dbi_localunit;
	local2base = dbip->dbi_local2base;
	base2local = dbip->dbi_base2local;

	/* Print title/units information */
	if( interactive )
		(void)rt_log( "%s (units=%s)\n", dbip->dbi_title,
			units_str[dbip->dbi_localunit] );

	update_views = 1;
	return(CMD_OK);
#else
d1471 1
a1471 1
	/* Quick -- before he gets away -- write a logfile entry! */
a1496 1
#endif
@


11.22
log
@*** empty log message ***
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.21 1995/11/28 21:27:59 bparker Exp bparker $ (BRL)";
d286 1
@


11.21
log
@added ged_pipe
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.20 1995/11/07 22:56:02 bparker Exp bparker $ (BRL)";
d365 1
a365 1
	Tk_CreateFileHandler(fileno(stdin), TK_READABLE, stdin_input,
@


11.20
log
@unleashed a few xmged commands
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.19 1995/11/07 14:46:18 bparker Exp bparker $ (BRL)";
d117 6
d363 7
d372 1
d478 5
d540 3
d544 1
@


11.19
log
@call cmdline instead of mged_cmd to allow access to tcl
in batch mode.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.18 1995/11/03 21:59:22 bparker Exp bparker $ (BRL)";
a87 1
extern void     (*axis_color_hook)();
a98 1
extern int	(*knob_hook)();
d102 1
a102 2
extern int     (*cue_hook)(), (*zclip_hook)(), (*zbuffer_hook)();
extern int     (*light_hook)(), (*perspective_hook)(), (*tran_hook)();
d125 6
a130 1
int             (*bindkey_hook)() = NULL;
d133 1
a191 1
	axis_color_hook = NULL;
a202 1
	knob_hook = NULL;
a205 5
	cue_hook = NULL;
	zclip_hook = NULL;
	zbuffer_hook = NULL;
	light_hook = NULL;
	perspective_hook = NULL;
@


11.18
log
@minor fix to make command line editing work
while return value is CMD_MORE
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.17 1995/10/19 15:01:34 jra Exp bparker $ (BRL)";
a86 1
void	slewview();
a88 1
extern int     (*bindkey_hook)();
d128 1
d140 1
a189 1
	bindkey_hook = NULL;
d339 1
d341 11
@


11.17
log
@Fixed bug to allow execution of command line command.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.16 1995/08/25 20:48:33 mike Exp jra $ (BRL)";
d597 1
d599 3
@


11.16
log
@The \r has been moved from the pr_prompt() routine into MGED_PROMTP
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.15 1995/08/25 20:14:08 mike Exp mike $ (BRL)";
d340 1
a340 1
		mged_cmd( argc-2, argv+2 );
@


11.15
log
@Fixed handling of EOF on stdin.
Fixed so it only prompts in interactive mode.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.14 1995/08/24 06:19:42 mike Exp mike $ (BRL)";
d415 1
a415 1
		rt_log("\r%S", &mged_prompt);
@


11.14
log
@Tcl MGED needs to read a different file -- .gedrc
@
text
@d7 1
a7 1
 *	prprompt	print prompt
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.13 1995/08/10 21:09:59 gdurf Exp mike $ (BRL)";
d225 3
a227 1
		interactive = 1;
d414 2
a415 1
    rt_log("\r%S", &mged_prompt);
d463 4
a466 1
	rt_vls_gets(&temp, stdin);  /* Get line from stdin */
@


11.13
log
@\a => \07
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.12 1995/08/07 14:35:47 gdurf Exp gdurf $ (BRL)";
d1278 1
a1278 1
#define RCFILE	".mgedrc"
d1326 1
a1326 1
	    rt_log("If you are setting variables in your .mgedrc, you will ");
d1330 1
a1330 1
	    rt_log("Error reading .mgedrc: %s\n", interp->result);
@


11.12
log
@Removed old version of source
Improved event handling
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.11 1995/08/03 21:43:38 gdurf Exp gdurf $ (BRL)";
d170 2
d173 3
d418 1
a418 1
    rt_log("\a");
@


11.11
log
@Added ^T
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.10 1995/07/27 17:42:21 gdurf Exp gdurf $ (BRL)";
d800 27
a826 1
    Tk_DoOneEvent(TK_ALL_EVENTS | (non_blocking ? TK_DONT_WAIT : 0));
a1493 59

#ifdef XMGED
int
f_source(argc, argv)
int	argc;
char	*argv[];
{
	FILE	*fp;
	char	*path;
	struct rt_vls	str;
	char option = 'e';	/* default is to execute only */
	int save_journal;

	save_journal = journal;
	journal = 0;	/* temporarily shut off journalling */

	if(argc > 2){
	  sscanf(argv[1], "%c", &option);
	  ++argv;
	}

	if( (path = getenv("MGED_SRC_DIR")) != (char *)NULL )  {
		rt_vls_init(&str);
		rt_vls_strcpy( &str, path );
		rt_vls_strcat( &str, "/" );
		rt_vls_strcat( &str, argv[1] );
		if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )  {
			mged_source_file( fp, option );
			fclose(fp);
			rt_vls_free(&str);
			journal = save_journal;
			return CMD_OK;
		}
		rt_vls_free(&str);
	}
	if( (fp = fopen( argv[1], "r" )) != NULL )  {
		mged_source_file( fp, option );
		fclose(fp);
		journal = save_journal;
		return CMD_OK;
	}
	if( (path = getenv("HOME")) != (char *)NULL )  {
		rt_vls_init(&str);
		rt_vls_strcpy( &str, path );
		rt_vls_strcat( &str, "/" );
		rt_vls_strcat( &str, argv[1] );
		if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )  {
			mged_source_file( fp, option );
			fclose(fp);
			rt_vls_free(&str);
			journal = save_journal;
			return CMD_OK;
		}
		rt_vls_free(&str);
	}
	journal = save_journal;
	return CMD_BAD;
}
#endif
@


11.10
log
@More command-line editing support
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.9 1995/07/20 17:00:04 gdurf Exp gdurf $ (BRL)";
d296 8
a317 3
	/* Perform any necessary initializations for the command parser */
	cmd_setup(interactive);

a342 6
	rt_vls_init(&input_str);
	rt_vls_init(&input_str_prefix);
	rt_vls_init(&scratchline);
	rt_vls_init(&mged_prompt);
	input_str_index = 0;
	
d493 1
a493 3
	    rt_vls_trunc(&input_str_prefix, 0);
	    rt_vls_vlscat(&input_str_prefix, &temp); /* Restore initial
							command */
d517 1
a580 1
		pr_prompt(); /* Print prompt for more input */
a583 2
	    input_str_index = 0;
	    freshline = 1;
d585 2
a586 3
	    rt_vls_trunc(&input_str_prefix, 0);
	    rt_vls_vlscat(&input_str_prefix, &temp); /* Restore initial
							command */
d590 3
d646 1
a646 1
    case CTRL_U:
d690 17
d938 2
a939 3
		if( mged_variables.faceplate > 0 )
			dotitles();

@


11.9
log
@Converted standard input reading to cbreak mode
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.8 1995/07/06 13:57:10 gdurf Exp gdurf $ (BRL)";
a64 4
#ifdef NONBLOCK
#	include <termio.h>
#	undef VMIN	/* also used in vmath.h */
#endif
d66 2
a67 4
#ifndef XMGED
#  define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
#  include "tcl.h"
#  include "tk.h"
a71 1
#endif
d144 3
d168 2
a169 2

void pr_prompt();
d225 4
a228 1
 		    cbreak_mode = 1;
d338 6
d361 4
d366 2
d408 7
a414 1
    rt_log("\rmged> ");
d429 1
a429 19
static struct rt_vls input_str;
static int input_str_init = 0;
static int input_str_index = 0;

/* multi_line_sig
 * Called when the user hits ^C while typing multiple lines of input
 * (using a backslash at the end of the line, or nested within braces.)
 * Acts like the usual break, except it also truncates the input string.
 */

void
multi_line_sig()
{
    if (input_str_init)
	rt_vls_trunc(&input_str, 0);

    longjmp( jmp_env, 1 );
    /* NOTREACHED */
}
d445 22
d468 34
a501 4
    if (!input_str_init) {
	rt_vls_init(&input_str);
	input_str_init = 1;
	input_str_index = 0;
d516 2
d520 2
d524 4
d529 8
d538 4
a541 1
    case '\n':
d543 17
a559 3
	if (cbreak_mode) rt_log("\n");
	rt_vls_putc(&input_str, '\n');
	if (Tcl_CommandComplete(rt_vls_addr(&input_str))) {
d561 3
a563 2
	    if (cmdline_hook) {
		if ((*cmdline_hook)(&input_str))
d565 4
d570 12
a581 8
		if (cbreak_mode) {
		    reset_Tty(fileno(stdin));
		}
		if (cmdline(&input_str))
		    pr_prompt();
		if (cbreak_mode) {
		    set_Cbreak(fileno(stdin));
		    clr_Echo(fileno(stdin));
d583 3
d587 2
a588 1
	    rt_vls_trunc(&input_str, 0);
d590 3
d594 1
a594 1
	    cmdline_sig = multi_line_sig;
d596 2
a597 1
	input_str_index = 0;
d602 1
a602 1
	    rt_log("\a");
d606 73
a678 2
	if (cbreak_mode) rt_log("\b \b");
	rt_vls_trunc(&input_str, rt_vls_strlen(&input_str)-1);
d680 12
d693 43
a735 7
    case CTRL_A:
    case CTRL_B:
    case CTRL_D:
    case CTRL_E:
    case CTRL_F:
    case CTRL_N:
    case CTRL_P:
d737 6
d746 18
a763 3
	if (cbreak_mode) rt_log("%c", (int)ch);
	rt_vls_putc(&input_str, (int)ch);
	++input_str_index;
d784 2
d802 1
a802 1
	(void)cmdline( &dm_values.dv_string );
a1174 4
#ifdef NONBLOCK
	int off = 0;
	(void)ioctl( 0, FIONBIO, &off );
#endif
d1185 2
a1186 1
	longjmp( jmp_env, 1 );
a1511 53
}
#else
/*
 *			F _ S O U R C E
 *
 *  Open a file/pipe and process the commands within.
 *
 *  argv[1] is the filename.
 *
 */
int
f_source (argc, argv)
int	argc;
char	**argv;
{
    char		*path;
    int			pipe = 0;	/* Read from pipe (vs. file)? */
    int			status;
    FILE		*fp;
    struct rt_vls	str;

    if (*(path = *++argv) == '|')
    {
	pipe = 1;
	rt_vls_init(&str);
	while (isspace(*++path))
	    ;
	rt_vls_strcpy(&str, path);
	while (--argc > 1)
	{
	    rt_vls_strcat(&str, " ");
	    rt_vls_strcat(&str, *++argv);
	}
	path = rt_vls_addr(&str);
    }

    if ((pipe && ((fp = popen(path, "r")) == NULL))
     || (!pipe && ((fp = fopen(path, "r")) == NULL)))
    {
	rt_log( "f_source: Cannot open %s '%s'\n", 
		pipe ? "pipe" : "command file", path );
	return( CMD_BAD );
    }
    mged_source_file(fp);
    if (pipe)
    {
	rt_vls_free(&str);
	if (status = pclose(fp))
	    rt_log("f_source: Exit status of pipe: %d\n", status);
    }
    else
	(void) fclose(fp);
    return(CMD_OK);
@


11.8
log
@Event handling changes
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.7 1995/06/16 21:32:31 gdurf Exp gdurf $ (BRL)";
d62 1
d229 1
a229 5
#if 0
		    cbreak_mode = 1;
#else
		    ;
#endif
d397 1
a397 1
    rt_log("mged> ");
d414 7
d432 7
d445 1
d450 1
d453 1
a453 3
    /* Get additional input and append a newline */
    count = rt_vls_gets(&input_str, stdin);
    rt_vls_strcat(&input_str, "\n");
d455 1
d459 33
a491 5
    if (Tcl_CommandComplete(rt_vls_addr(&input_str))) {
	cmdline_sig = SIG_IGN;
	if (cmdline_hook) {
	    if ((*cmdline_hook)(&input_str))
		pr_prompt();
d493 2
a494 2
	    if (cmdline(&input_str))
		pr_prompt();
d496 28
a523 4
	rt_vls_trunc(&input_str, 0);
    } else {
	/* Allow the user to hit ^C */
	cmdline_sig = multi_line_sig;
d525 1
d1045 3
a1047 1
	Tcl_EvalFile( interp, rt_vls_addr(&str) );
@


11.7
log
@Warning for use of old "set" command
@
text
@a17 1
 *	f_source	Open a file and process the commands within
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.6 1995/06/15 20:22:35 gdurf Exp gdurf $ (BRL)";
d69 10
d83 1
a91 10
#ifndef XMGED
#  define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
#  include "tcl.h"
#  include "tk.h"

/* defined in cmd.c */
extern Tcl_Interp *interp;
extern Tk_Window tkwin;
#endif

a137 2
void		(*extrapoll_hook)() = NULL;
int		extrapoll_fd;		/* XXX Ultra hack XXX */
d143 1
d147 3
a149 1
int		interactive = 0;	/* !0 means interactive */
d171 3
a173 4
void
pr_prompt()  {
	rt_log("mged> ");
}
d226 10
a235 1
	}
d237 4
d342 3
d363 8
d372 1
a372 1
		(void)signal( SIGINT, SIG_IGN );
d397 66
d469 1
a469 3
 *  Returns -
 *	 0	no events detected
 *	>0	number of events detected
d471 1
d476 1
a476 27
	fd_set		input;
	vect_t		knobvec;	/* knob slew */

	/*
	 * dmr_input() will suspend until some change has occured,
	 * either on the device peripherals, or a command has been
	 * entered on the keyboard, unless the non-blocking flag is set.
	 */
	FD_ZERO( &input );
	if( extrapoll_fd )  FD_SET( extrapoll_fd, &input );
	FD_SET( fileno(stdin), &input );

#ifndef XMGED
	if( mged_tk_dontwait() )  non_blocking = 1;
#endif

	/* await an input event. Bits will be set in 'input' as appropriate */
	dmp->dmr_input( &input, non_blocking );

	if(extrapoll_fd && FD_ISSET(extrapoll_fd,&input) && extrapoll_hook)  {
		(*extrapoll_hook)();
	}
#ifndef XMGED
	else {
		mged_tk_idle(non_blocking);
	}
#endif
d478 2
a479 25
	/* Acquire anything present on stdin */
	if( FD_ISSET( fileno(stdin), &input ) )  {
		struct rt_vls	str;
		rt_vls_init(&str);

		/* Read input line */
		if( rt_vls_gets( &str, stdin ) >= 0 )  {
			rt_vls_strcat( &str, "\n" );
		if( cmdline_hook ) {
			if( (*cmdline_hook)(&str)) 
				pr_prompt();
		} else
			if( cmdline( &str ) )
				pr_prompt();
		} else {
			/* Check for Control-D (EOF) */
			if( feof( stdin ) )  {
				/* EOF, let's hit the road */
				f_quit(0, NULL);
				/* NOTREACHED */
			}
		}
		rt_vls_free(&str);
	}
	non_blocking = 0;
d481 11
a491 10
	/*
	 *  Process any "string commands" sent to us by the display manager.
	 *  (Or "invented" here, for compatability with old dm's).
	 *  Each one is expected to be newline terminated.
	 */
	if( cmdline_hook )  
		(*cmdline_hook)(&dm_values.dv_string); 
	else {
		/* Some commands (e.g. mouse events) queue further events. */
		int oldlen;
d493 45
a537 8
		oldlen = rt_vls_strlen( &dm_values.dv_string );
		(void)cmdline( &dm_values.dv_string );
		if( rt_vls_strlen( &dm_values.dv_string ) > oldlen ) {
			/* Remove cmds already done, and go again */
			rt_vls_nibble( &dm_values.dv_string, oldlen );
			goto again;
		}
	}
d539 1
a539 1
	rt_vls_trunc( &dm_values.dv_string, 0 );
d541 6
a546 29
	/*
	 * Set up window so that drawing does not run over into the
	 * status line area, and menu area (if present).
	 */
	windowbounds[1] = XMIN;		/* XLR */
	if( illump != SOLID_NULL )
		windowbounds[1] = MENUXLIM;
	windowbounds[3] = TITLE_YBASE-TEXT1_DY;	/* YLR */
	dmp->dmr_window(windowbounds);	/* hack */

	/*********************************
	 *  Handle rate-based processing *
	 *********************************/
	if( rateflag_rotate )  {
		non_blocking++;

		/* Compute delta x,y,z parameters */
		usejoy( rate_rotate[X] * 6 * degtorad,
			rate_rotate[Y] * 6 * degtorad,
			rate_rotate[Z] * 6 * degtorad );
	}
	if( rateflag_slew )  {
		non_blocking++;

		/* slew 1/10th of the view per update */
		knobvec[X] = -rate_slew[X] / 10;
		knobvec[Y] = -rate_slew[Y] / 10;
		knobvec[Z] = -rate_slew[Z] / 10;
		slewview( knobvec );
a547 3
	if( rateflag_zoom )  {
		fastf_t	factor;
#define MINVIEW		0.001	/* smallest view.  Prevents runaway zoom */
d549 3
a551 10
		factor = 1.0 - (rate_zoom / 10);
		Viewscale *= factor;
		if( Viewscale < MINVIEW )
			Viewscale = MINVIEW;
		else  {
			non_blocking++;
		}
		{
			/* Scaling (zooming) takes place around view center */
			mat_t	scale_mat;
d553 4
a556 8
			mat_idn( scale_mat );
			scale_mat[15] = 1/factor;

			wrt_view( ModelDelta, scale_mat, ModelDelta );
		}
		dmaflag = 1;
		new_mats();
	}
d558 1
a558 1
	return( non_blocking );
d852 4
a966 5
	    /* Discard rest of line */
	    while( !feof(fp) && fgetc(fp)!='\n' )
		;
	    while( !feof(fp) && fgetc(fp)!='\n' )
		;
@


11.6
log
@Converted to Tcl version
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.5 1995/02/18 03:08:59 mike Exp gdurf $ (BRL)";
d878 1
d916 17
d934 6
@


11.5
log
@Eliminated local setting of "rt_tol" structures.
Everything now uses the global mged_tol.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.4 95/01/17 13:04:47 bparker Exp Locker: mike $ (BRL)";
d82 1
a82 1
#ifdef MGED_TCL
d399 1
a399 1
#ifdef MGED_TCL
d409 1
a409 1
#ifdef MGED_TCL
d882 2
a883 7
#ifdef MGED_TCL
# define ENVRC	"TMGED_RCFILE"
# define RCFILE	".tmgedrc"
#else
# define ENVRC	"MGED_RCFILE"
# define RCFILE	".mgedrc"
#endif
d914 1
a914 1
#ifdef MGED_TCL
@


11.4
log
@merging xmged sources
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/ged.c,v 11.2 95/01/17 11:43:08 bparker Exp $ (BRL)";
d270 1
a270 1
	/* XXX Some better method is needed for setting this */
@


11.3
log
@RC file loading changes
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.2 95/01/09 18:26:23 gdurf Exp Locker: gdurf $ (BRL)";
d92 32
d155 5
d186 28
d353 3
d362 1
d681 15
d698 22
d747 11
d947 80
d1087 1
d1090 58
d1200 1
@


11.2
log
@TMGED default rc file is now .tmgedrc
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 11.1 95/01/04 10:03:09 mike Rel4_4 Locker: gdurf $ (BRL)";
d82 10
d239 6
a244 1
	/* --- Now safe to process commands.  BUT, no geometry yet. --- */
a249 5
	/* Open the database, attach a display manager */
	f_opendb( argc, argv );

	dmp->dmr_window(windowbounds);

d759 2
d762 3
a764 11
	if( (path = getenv("MGED_RCFILE")) != (char *)NULL )  {
		if( (fp = fopen(path, "r")) != NULL )  {
			mged_source_file( fp );
			fclose(fp);
			return(0);
		}
	}
	if( (path = getenv("HOME")) != (char *)NULL )  {
		struct rt_vls	str;
		rt_vls_init(&str);
		rt_vls_strcpy( &str, path );
d766 2
a767 1
		rt_vls_strcat( &str, "/.tmgedrc" );
d769 2
a770 1
		rt_vls_strcat( &str, "/.mgedrc" );
d772 5
a776 5
		if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )  {
			mged_source_file( fp );
			fclose(fp);
			rt_vls_free(&str);
			return(0);
a777 1
		rt_vls_free(&str);
d779 9
a787 4
	if( (fp = fopen( ".mgedrc", "r" )) != NULL )  {
		mged_source_file( fp );
		fclose(fp);
		return(0);
d789 22
a810 1
	return(-1);
@


11.1
log
@Release_4.4
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.39 95/01/04 09:06:48 mike Exp $ (BRL)";
d761 3
d765 1
@


10.39
log
@setjmp.h now included by raytrace.h.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.38 94/12/27 22:58:12 mike Exp Locker: mike $ (BRL)";
@


10.38
log
@Removed dead variables
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.37 94/12/27 16:47:40 mike Exp Locker: mike $ (BRL)";
a63 1
#include <setjmp.h>
@


10.37
log
@No longer need variable "old_values".
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.36 94/12/24 01:04:29 mike Exp Locker: mike $ (BRL)";
a310 4
	int		i;
	int		len;
	int		formerly_non_blocking = non_blocking;
	static int	need_penup = 0;
@


10.36
log
@Eliminated old dm_values.dv_* style "polled" device interface.
Everything is done by string commands now.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.35 94/12/23 23:26:30 gdurf Exp Locker: mike $ (BRL)";
a314 1
	static struct device_values	old_values;
a441 3

	/* Keep a copy of knob values, for later comparison */
	old_values = dm_values;	/* struct copy */
@


10.35
log
@Merged Tcl
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged-tcl/RCS/ged.c,v 10.23 94/08/11 22:40:56 mike Exp Locker: mike $ (BRL)";
a366 107

	/********************************
	 *  Begin compatability code	*
	 ********************************/

	/* Process any function button presses */
	if( dm_values.dv_buttonpress )  {
		rt_vls_printf( &dm_values.dv_string, "press %s\n",
			label_button(dm_values.dv_buttonpress) );
		dm_values.dv_buttonpress = 0;
	}

	/* Detect any joystick activity */
	if( dm_values.dv_xjoy != old_values.dv_xjoy )  {
		rt_vls_printf( &dm_values.dv_string, "knob x %f\n",
			dm_values.dv_xjoy );
	}
	if( dm_values.dv_yjoy != old_values.dv_yjoy )  {
		rt_vls_printf( &dm_values.dv_string, "knob y %f\n",
			dm_values.dv_yjoy );
	}
	if( dm_values.dv_zjoy != old_values.dv_zjoy )  {
		rt_vls_printf( &dm_values.dv_string, "knob z %f\n",
			dm_values.dv_zjoy );
	}

	/*
	 * Use pen input.
	 */		 
	switch( dm_values.dv_penpress )  {
	case DV_INZOOM:
		rt_vls_strcat( &dm_values.dv_string, "zoom 2\n" );
		break;

	case DV_OUTZOOM:
		rt_vls_strcat( &dm_values.dv_string, "zoom 0.5\n" );
		break;

	case DV_SLEW:		/* Move view center to here */
		{
			vect_t tabvec;
			tabvec[X] =  dm_values.dv_xpen / 2047.0;
			tabvec[Y] =  dm_values.dv_ypen / 2047.0;
			tabvec[Z] = 0;
			slewview( tabvec );
			/* XXX still needs conversion to a command */
		}
		break;

	case DV_PICK:		/* transition 0 --> 1 */
		rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n",
			dm_values.dv_xpen, dm_values.dv_ypen);
		non_blocking++;	/* to catch transition back to 0 */
		need_penup = 1;
		break;
	case 0:			/* transition 1 --> 0 */
		if( need_penup && formerly_non_blocking )  {
			need_penup = 0;
			rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
				dm_values.dv_xpen, dm_values.dv_ypen);
		} else if( (state == ST_S_PICK || state == ST_O_PICK ||
		    state == ST_O_PATH) && (
		    (dm_values.dv_xpen != old_values.dv_xpen) ||
		    (dm_values.dv_ypen != old_values.dv_ypen) )
		    )  {
			rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
				dm_values.dv_xpen, dm_values.dv_ypen);
		}
		break;
	default:
		rt_log("pen(%d,%d,x%x) -- bad dm press code\n",
			dm_values.dv_xpen,
			dm_values.dv_ypen,
			dm_values.dv_penpress);
		break;
	}

	/*
	 * Apply the knob slew factor to the view center
	 */
	if( dm_values.dv_xslew != old_values.dv_xslew )  {
		rt_vls_printf( &dm_values.dv_string, "knob X %f\n",
			dm_values.dv_xslew );
	}
	if( dm_values.dv_yslew != old_values.dv_yslew )  {
		rt_vls_printf( &dm_values.dv_string, "knob Y %f\n",
			dm_values.dv_yslew );
	}
	if( dm_values.dv_zslew != old_values.dv_zslew )  {
		rt_vls_printf( &dm_values.dv_string, "knob Z %f\n",
			dm_values.dv_zslew );
	}

	/* Apply zoom rate input to current view window size */
	if( dm_values.dv_zoom != old_values.dv_zoom )  {
		rt_vls_printf( &dm_values.dv_string, "knob S %f\n",
			dm_values.dv_zoom );
	}

	/* See if the angle/distance cursor is doing anything */
	/* XXX still needs conversion to a command */
	if(  adcflag && dm_values.dv_flagadc )
		dmaflag = 1;	/* Make refresh call dozoom */

	/********************************
	 *  End compatability code	*
	 ********************************/
@


10.34
log
@Changed output to use rt_log
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.33 94/12/16 20:57:03 gdurf Exp Locker: gdurf $ (BRL)";
d132 1
d142 2
a143 1
		rt_log("Usage:  %s database [command]\n", argv[0]);
d150 2
a151 1
		rt_log("%s\n", version+5);	/* skip @@(#) */
d228 1
a228 1
	cmd_setup();
d311 2
d326 4
d336 5
d350 4
a353 1
if( cmdline_hook )  {if( (*cmdline_hook)(&str)) pr_prompt();} else
d480 3
a482 3
	if( cmdline_hook )  {
		(*cmdline_hook)(&dm_values.dv_string);
	} else {
d484 1
a484 1
		int	oldlen;
d488 1
a488 1
		if( rt_vls_strlen( &dm_values.dv_string ) > oldlen )  {
d494 1
a927 1

d1010 3
a1012 4
	(void) rt_log(
	    "f_source: Cannot open %s '%s'\n",
	    pipe ? "pipe" : "command file", path);
	return(CMD_BAD);
d1019 1
a1019 2
	    (void) rt_log(
		"f_source: Exit status of pipe: %d\n", status);
@


10.33
log
@Temporary hack, replaced stdout with stderr for compatibility with
rt_log
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.32 1994/12/16 17:52:56 gdurf Exp gdurf $ (BRL)";
a123 3
FILE *infile;
FILE *outfile;

d126 1
a126 2
	(void)fprintf(outfile, "mged> ");
	(void)fflush(outfile);
a138 5
	/* In some ANSI implementations, symbol "stdin" is a variable. */
	infile = stdin;
/*	outfile = stdout; */
	outfile = stderr;

d141 1
a141 2
		(void)fprintf(outfile, "Usage:  %s database [command]\n",
		  argv[0]);
d148 1
a148 1
		(void)fprintf(outfile, "%s\n", version+5);	/* skip @@(#) */
d260 1
a260 1
		(void)fprintf(outfile, "\nAborted.\n");
d420 4
a423 4
		(void)fprintf(outfile, "pen(%d,%d,x%x) -- bad dm press code\n",
		dm_values.dv_xpen,
		dm_values.dv_ypen,
		dm_values.dv_penpress);
d912 2
a913 3
		    (void)fprintf(outfile, "Create new database (y|n)[n]? ");
		    fflush(outfile);
		    (void)fgets(line, sizeof(line), infile);
d917 1
a917 2
		    (void)fprintf(outfile,
		    	"Creating new database \"%s\"\n", argv[1]);
@


10.32
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.31 1994/12/05 14:54:50 mike Exp gdurf $ (BRL)";
d145 2
a146 1
	outfile = stdout;
@


10.31
log
@Fixed bug #51.  "Zero Sliders" menu item inoperative
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.30 94/11/19 01:46:18 mike Exp Locker: mike $ (BRL)";
d635 1
a635 1
	printf("Not ready until tomorrow.\n");
d937 1
a937 1
		(void)printf("%s:  READ ONLY\n", dbip->dbi_filename );
d961 1
a961 1
		(void)printf("%s (units=%s)\n", dbip->dbi_title,
d1004 1
a1004 1
	(void) fprintf(stderr,
d1014 1
a1014 1
	    (void) fprintf(stderr,
@


10.30
log
@Zoom slider was having no effect.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.29 94/11/05 03:42:20 mike Exp Locker: mike $ (BRL)";
d472 14
a485 2
if( cmdline_hook )  (*cmdline_hook)(&dm_values.dv_string); else
	(void)cmdline( &dm_values.dv_string );
@


10.29
log
@Irix 6
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.28 94/08/24 19:08:43 gdurf Exp Locker: mike $ (BRL)";
d510 1
a510 1
		factor = 1.0 - (dm_values.dv_zoom / 10);
@


10.28
log
@Added include of conf.h
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.27 1994/08/10 23:05:27 mike Exp gdurf $ (BRL)";
a316 2
	int		i;
	int		len;
a714 1
	mat_t	temp;
d739 1
a739 1
	long now;
@


10.27
log
@Have to initialize cmd_setup() earlier.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.26 94/08/10 21:43:04 mike Exp Locker: mike $ (BRL)";
d53 2
@


10.26
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.25 94/08/09 18:12:44 gdurf Exp Locker: mike $ (BRL)";
d231 3
a274 3

	/* Perform any necessary initializations for the command parser */
	cmd_setup();
@


10.25
log
@Factored ifdefs
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.24 1994/08/09 11:47:42 pjt Exp gdurf $ (BRL)";
d313 1
d326 9
a334 7
#if 0
/* XXX Need to send extra FD down, instead */
/* XXX Compensated for by hack in dm-4d.c for now */
	/* XXX ultra hack */
	if(extrapoll_fd)  {
		i = dmp->dmr_input( extrapoll_fd, 1 );	/* don't block */
		if( i && extrapoll_hook )  (*extrapoll_hook)();
d336 3
a338 3
#endif
	i = dmp->dmr_input( 0, non_blocking );	/* fd 0 for cmds */
	if( i )  {
@


10.24
log
@Enhanced 'source' command so it now reads
from a pipe, too.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.23 94/08/09 10:26:24 pjt Exp Locker: pjt $ (BRL)";
d55 3
a57 1
#ifdef BSD
a58 2
#else
#include <string.h>
a100 4
#if defined(sgi) && !defined(mips)
int		(*cur_sigint)();	/* Current SIGINT status */
int		sig2();
#else
a102 1
#endif
a258 6
#if defined(sgi) && !defined(mips)
		if( cur_sigint == (int (*)())SIG_IGN )
			cur_sigint = (int (*)())SIG_IGN; /* detached? */
		else
			cur_sigint = sig2;	/* back to here w/!0 return */
#else
a262 1
#endif
a798 8
#if defined(sgi) && !defined(mips)
int
sig2()
{
	longjmp( jmp_env, 1 );
	/* NOTREACHED */
}
#else
a804 1
#endif
a869 8

#if defined(BSD) && !defined(__convexc__)
extern void bcopy();
void memcpy(to,from,cnt)
{
	bcopy(from,to,cnt);
}
#endif
@


10.23
log
@Implemented the 'source' command
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.22 94/06/24 20:10:02 gdurf Exp Locker: pjt $ (BRL)";
d985 1
a985 1
 *  Open a file and process the commands within.
d995 5
a999 2
    FILE	*fp;
    char	*path;
d1001 1
a1001 1
    if((fp = fopen(argv[1], "r")) == NULL)
d1003 16
d1020 2
a1021 1
	    "f_source: Cannot open command file %s\n", argv[1]);
d1025 9
a1033 1
    fclose(fp);
@


10.22
log
@Added call to cmd_setup(), for a future hook to a Tcl interpreter.
@
text
@d18 1
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.21 1994/06/03 17:28:22 gdurf Exp gdurf $ (BRL)";
d980 27
@


10.21
log
@Completed support for new command return codes.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.20 1994/06/01 16:11:20 gdurf Exp gdurf $ (BRL)";
d283 3
@


10.20
log
@Converted f_ functions to use new command return codes.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.19 94/01/12 02:45:10 mike Exp Locker: mike $ (BRL)";
a108 1
void		f_opendb();
a113 3
extern int	numargs;	/* number of args */
extern char	*cmd_args[];	/* array of pointers to args */

d251 1
a251 1
		f_quit();
d357 1
a357 1
				f_quit();
@


10.19
log
@Moved creation of global "mged_tol" variable from dodraw.c to ged.c
Now, the question is, what is a better way to select these values?
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.18 93/11/05 12:34:34 mike Exp Locker: mike $ (BRL)";
d428 5
a432 2
		} else if( state == ST_S_PICK || state == ST_O_PICK ||
		    state == ST_O_PATH )  {
d627 1
a627 1
void
d633 1
d912 1
a912 1
void
d978 2
@


10.18
log
@Added f_opendb(), inspired by code from Bob Parker.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.17 93/11/04 15:16:54 mike Exp Locker: mike $ (BRL)";
d118 2
d207 7
@


10.17
log
@Hack to fix bug in simulation of old->new event handler
regarding illuminate mode.
@
text
@d26 2
d30 2
a31 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d33 5
d39 2
a40 2
 *	This software is Copyright (C) 1985,1987 by the United States Army.
 *	All rights reserved.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.16 93/07/15 21:26:30 mike Exp Locker: mike $ (BRL)";
d46 6
a51 1
char MGEDCopyRight_Notice[] = "@@(#) Copyright (C) 1985,1987,1990 by the United States Army";
d109 2
d159 2
a160 1
	if( argc == 2 )
d162 1
a174 29
	/* Get input file */
	if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
	    ((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
		char line[128];

		if( isatty(0) ) {

		    perror( argv[1] );
		    (void)fprintf(outfile, "Create new database (y|n)[n]? ");
		    fflush(outfile);
		    (void)fgets(line, sizeof(line), infile);
		    if( line[0] != 'y' && line[0] != 'Y' )
			exit(0);		/* NOT finish() */
		} else
		    (void)fprintf(outfile,
		    	"Creating new database \"%s\"\n", argv[1]);
			

		if( (dbip = db_create( argv[1] )) == DBI_NULL )  {
			perror( argv[1] );
			exit(2);		/* NOT finish() */
		}
	}
	if( dbip->dbi_read_only )
		(void)printf("%s:  READ ONLY\n", dbip->dbi_filename );

	/* Quick -- before he gets away -- write a logfile entry! */
	log_event( "START", argv[1] );

d177 1
d221 7
d231 2
a232 5

	if( argc == 2 )  {
		/* This is an interactive mged */

		/* Process any .mgedrc file, before attaching */
a233 3

		/* Ask which one, and fire up the display manager */
		get_attached();
d236 3
a238 6
	windowbounds[0] = XMAX;		/* XHR */
	windowbounds[1] = XMIN;		/* XLR */
	windowbounds[2] = YMAX;		/* YHR */
	windowbounds[3] = YMIN;		/* YLR */
	windowbounds[4] = 2047;		/* ZHR */
	windowbounds[5] = -2048;	/* ZLR */
d241 1
a241 6
	/* --- Scan geometry database and build in-memory directory --- */
	db_scan( dbip, (int (*)())db_diradd, 1);
	/* XXX - save local units */
	localunit = dbip->dbi_localunit;
	local2base = dbip->dbi_local2base;
	base2local = dbip->dbi_base2local;
a242 5
	/* Print title/units information */
	if( argc == 2 )
		(void)printf("%s (units=%s)\n", dbip->dbi_title,
			units_str[dbip->dbi_localunit] );

d886 80
@


10.16
log
@Added absview_v(), to support f_knobs().
Added f_vrot_center(), for future expansion.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.15 92/08/24 19:51:25 mike Exp Locker: mike $ (BRL)";
d442 4
@


10.15
log
@Added new variable "eye_sep_dist" to support Stereo viewing.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.14 92/08/21 22:45:57 mike Exp Locker: mike $ (BRL)";
d630 15
d647 4
a650 2
 * Apply the "joystick" delta rotation to the viewing direction.
 *  Rotation is performed about the view center.
d685 17
d708 1
@


10.14
log
@Initial prototype support for stereo viewer
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.13 92/04/16 04:07:54 mike Exp Locker: mike $ (BRL)";
d592 8
a599 6
#if 1
		dozoom(0);
#else
		dozoom(1);
		dozoom(2);
#endif
@


10.13
log
@Contains ultra-hacks for VR testing.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.12 92/04/16 01:30:57 mike Exp Locker: mike $ (BRL)";
d588 10
a597 2
		/* Apply zoom & rotate translation vectors */
		dozoom();
@


10.12
log
@Modified cmdline() to be able to process multiple commands at once.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.11 92/04/16 00:23:03 mike Exp Locker: mike $ (BRL)";
d81 1
d83 2
d353 9
d370 1
d490 1
@


10.11
log
@Added cmdline and viewpoint hooks, for VR experiment
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.10 92/04/04 01:10:55 mike Exp Locker: mike $ (BRL)";
d477 2
a478 25
	if( (len = rt_vls_strlen( &dm_values.dv_string )) > 0 )  {
		register char	*cp = rt_vls_addr( &dm_values.dv_string );
		char		*ep;
		char		*end = cp + len;
		struct rt_vls	cmd;

		rt_vls_init( &cmd );

		while( cp < end )  {
#ifdef BSD
			ep = index( cp, '\n' );
#else
			ep = strchr( cp, '\n' );
#endif
			if( ep == NULL )  break;

			/* Copy one cmd, incl newline.  Null terminate */
			rt_vls_strncpy( &cmd, cp, ep-cp+1 );
			/* cmdline insists on ending with newline&null */
			(void)cmdline( &cmd );
			cp = ep+1;
		}
		rt_vls_trunc( &dm_values.dv_string, 0 );
		rt_vls_free( &cmd );
	}
@


10.10
log
@Moved predictor code to predictor.c
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.9 92/04/04 00:12:59 mike Exp Locker: mike $ (BRL)";
d81 2
d586 3
@


10.9
log
@Checkpoint of work on predictor frame.
Not working yet.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.8 92/04/03 19:44:38 mike Exp Locker: mike $ (BRL)";
a544 2
			mat_t	from_Viewcenter;
			mat_t	temp;
d549 1
a549 7
			mat_idn( from_Viewcenter );
			from_Viewcenter[MDX] = -toViewcenter[MDX];
			from_Viewcenter[MDY] = -toViewcenter[MDY];
			from_Viewcenter[MDZ] = -toViewcenter[MDZ];
			mat_mul( temp, scale_mat, toViewcenter );
			mat_mul2( from_Viewcenter, temp );
			mat_mul2( temp, ModelDelta );
d627 1
d656 1
a656 1
		mat_mul2( newinv, ModelDelta );
a865 202

#define MAX_TRAIL	32
struct trail {
	int	cur_index;	/* index of first free entry */
	int	nused;		/* max index in use */
	point_t	pt[MAX_TRAIL];
}

init_trail(tp)
struct trail	*tp;
{
	tp->cur_index = 0;
	tp->nused = 0;
}

/*
 *  Add a new point to the end of the trail.
 */
push_trail(tp, pt)
struct trail	*tp;
point_t		pt;
{
	VMOVE( tp->pt[tp->cur_index], pt );
	if( tp->cur_index >= tp->nused )  tp->nused++;
	tp->cur_index++;
	if( tp->cur_index >= MAX_TRAIL )  tp->cur_index = 0;
}

/*
 *  Draw from the most recently added point, backwards.
 */
draw_trail(vhead, tp)
struct rt_list	*vhead;
struct trail	*tp;
{
	int	i;
	int	todo = tp->nused;

	RT_LIST_INIT( vhead );
	if( tp->nused <= 0 )  return;
	if( (i = tp->cur_index-1) < 0 )  i = tp->nused-1;
	for( ; todo > 0; todo-- )  {
		if( todo == tp->nused )  {
			RT_ADD_VLIST( vhead, tp->pt[i], RT_VLIST_LINE_MOVE );
		}  else  {
			RT_ADD_VLIST( vhead, tp->pt[i], RT_VLIST_LINE_DRAW );
		}
		if( (--i) < 0 )  i = tp->nused-1;
	}
}

static struct trail	ll;
static struct trail	ul;
static struct trail	lr;
static struct trail	ur;

#define PREDICTOR_NAME	"_PREDIC_FRAME_"

predictor_kill()
{
	struct rt_vls	str;

	rt_vls_init( &str );
	rt_vls_printf( &str, "kill %s\n", PREDICTOR_NAME );
	(void)cmdline( &str );
	rt_vls_trunc( &str, 0 );

	rt_vls_strcat( &str, "kill _PREDIC_TRAIL_*\n" );
	(void)cmdline( &str );
	rt_vls_free( &str );

	init_trail( &ll );
	init_trail( &ul );
	init_trail( &lr );
	init_trail( &ur );
}

#define TF_X	0.14
#define TF_Y	0.07
#define TF_Z	(1.0-0.15)	/* To prevent Z clipping of TF_X */

#define TF_VL( _m, _v, _op ) \
	{ vect_t edgevect_m; \
	MAT4X3VEC( edgevect_m, predictorXv2m, _v ); \
	VADD2( _m, framecenter_m, edgevect_m ); \
	RT_ADD_VLIST( &vhead, _m, _op ); }

/*
 *			P R E D I C T O R _ F R A M E
 * 
 *  Note that the first time through, PREDICTOR_NAME won't be found yet,
 *  so the frame will be drawn.  As soon as motion starts & stops, it
 *  will vanish.  Consider this a user feedback cue, acknowledging
 *  the "set predictor=1" command.
 */
predictor_frame()
{
	int	i;
	int	nframes;
	mat_t	predictor;
	mat_t	predictorXv2m;
	point_t	v;		/* view coords */
	point_t	m;		/* model coords */
	struct rt_list	vhead;
	struct rt_list	trail;
	point_t	framecenter_m;
	point_t	framecenter_v;
	point_t	center_m;
	vect_t	delta_v;

	if( rateflag_rotate == 0 && rateflag_slew == 0 && rateflag_zoom == 0 )  {
		if( db_lookup( dbip, PREDICTOR_NAME, LOOKUP_QUIET ) != DIR_NULL )  {
			predictor_kill();
			dmaflag = 1;
		}
		return;
	}

	/* Advance into the future */
	nframes = (int)(mged_variables.predictor_advance / frametime);
	if( nframes < 1 )  nframes = 1;

	/* Build view2model matrix for the future time */
	mat_idn( predictor );
	for( i=0; i < nframes; i++ )  {
		mat_mul2( ModelDelta, predictor );
	}
	mat_mul( predictorXv2m, predictor, view2model );

	MAT_DELTAS_GET_NEG( center_m, toViewcenter );
	MAT4X3PNT( framecenter_m, predictor, center_m );
	MAT4X3PNT( framecenter_v, model2view, framecenter_m );
#if 0
VPRINT("\ncenter_m", center_m);
mat_print("ModelDelta", ModelDelta);
VPRINT("framecenter_m", framecenter_m);
VPRINT("framecenter_v", framecenter_v);
	framecenter_v[Z] = TF_Z;
VPRINT("framecenter_v", framecenter_v);
	MAT4X3PNT( framecenter_m, view2model, framecenter_v );
VPRINT("framecenter_m", framecenter_m);
#endif

	/* Draw frame around point framecenter_v. */
	RT_LIST_INIT( &vhead );

	VSETALL( delta_v, 0 );		/* Centering dot */
	TF_VL( m, delta_v, RT_VLIST_LINE_MOVE );
	TF_VL( m, delta_v, RT_VLIST_LINE_DRAW );

	VSET( delta_v, -TF_X, -TF_Y, 0 );
	TF_VL( m, delta_v, RT_VLIST_LINE_MOVE );
#if 0
VPRINT("delta_v", delta_v );
VPRINT("ll_m", m );
#endif
	push_trail( &ll, m );

	VSET( delta_v,  TF_X, -TF_Y, 0 );
	TF_VL( m, delta_v, RT_VLIST_LINE_DRAW );
	push_trail( &lr, m );

	VSET( delta_v,  TF_X,  TF_Y, 0 );
	TF_VL( m, delta_v, RT_VLIST_LINE_DRAW );
	push_trail( &ur, m );

	VSET( delta_v, -TF_X,  TF_Y, 0 );
	TF_VL( m, delta_v, RT_VLIST_LINE_DRAW );
	push_trail( &ul, m );

	VSET( delta_v, -TF_X, -TF_Y, 0 );
	TF_VL( m, delta_v, RT_VLIST_LINE_DRAW );

	invent_solid( PREDICTOR_NAME, &vhead, 0x00FFFFFFL );

	draw_trail( &trail, &ll );
	invent_solid( "_PREDIC_TRAIL_LL_", &trail, 0x00FF00FFL );

	draw_trail( &trail, &lr );
	invent_solid( "_PREDIC_TRAIL_LR_", &trail, 0x0000FFFFL );

	draw_trail( &trail, &ur );
	invent_solid( "_PREDIC_TRAIL_UR_", &trail, 0x00FF00FFL );

	draw_trail( &trail, &ul );
	invent_solid( "_PREDIC_TRAIL_UL_", &trail, 0x0000FFFFL );

	/* Done */
	mat_idn( ModelDelta );
}

void
predictor_hook()
{
	if( mged_variables.predictor > 0 )  {
		/* Allocate storage? */
	} else {
		/* Release storage? */
		predictor_kill();
	}
	dmaflag = 1;
}
@


10.8
log
@Fixed prompting bug.
Implemented set faceplate=0 support, per idea from Lee.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.7 92/04/03 19:24:08 mike Exp Locker: mike $ (BRL)";
d214 2
d542 17
a558 1
		ModelDelta[15] /= factor;
d591 1
a591 1
		double	this_time;
d595 2
a596 4
#if 0
		/* XXX should check a "set" variable */
		target_frame();
#endif
d616 1
a616 1
		this_time = rt_read_timer( (char *)0, 0 );
d618 1
a618 1
		if( this_time > 1.0e-5 )  {
d620 1
a620 1
			frametime = 0.9 * frametime + 0.1 * this_time;
a640 1
	mat_t	temp;
d659 1
a659 2
	mat_mul( temp, newrot, Viewrot );
	mat_copy( Viewrot, temp );
d663 1
a663 2
		mat_mul( temp, newinv, ModelDelta );
		mat_copy( ModelDelta, temp );
d708 1
a708 2
	mat_mul( temp, delta, ModelDelta );
	mat_copy( ModelDelta, temp );
d929 3
a931 1
target_frame()
d933 37
a970 1
	int	fps;
d972 2
a973 2
	mat_t	dest;
	mat_t	temp;
d978 4
d983 7
a989 2
	fps = (int)(1.0 / frametime);
	if( fps < 1 )  fps = 1;
d991 3
a993 2
	/* Advance one second into the future */
	nframes = fps * 1;
d996 1
a996 2
/*mat_print("ModelDelta", ModelDelta);*/
	mat_copy( dest, view2model );
d998 1
a998 2
		mat_mul( temp, ModelDelta, dest );
		mat_copy( dest, temp );
d1000 1
d1002 13
a1014 5
	/* Draw frame. */
#define TF_VL( x, y, z, op ) \
	VSET( v, x, y, z ); \
	MAT4X3PNT( m, dest, v ); \
	RT_ADD_VLIST( &vhead, m, op );
d1016 1
d1018 11
a1028 1
	TF_VL( -0.1, -0.1, 0.9, RT_VLIST_LINE_MOVE );
d1030 3
a1032 1
	TF_VL(  0.1, -0.1, 0.9, RT_VLIST_LINE_DRAW );
d1034 3
a1036 1
	TF_VL(  0.1,  0.1, 0.9, RT_VLIST_LINE_DRAW );
d1038 3
a1040 1
	TF_VL( -0.1,  0.1, 0.9, RT_VLIST_LINE_DRAW );
a1041 1
	TF_VL( -0.1, -0.1, 0.9, RT_VLIST_LINE_DRAW );
d1043 2
a1044 1
	invent_solid( "_TARGET_FRAME_", &vhead, 0x00FFFFFFL );
d1046 2
d1049 1
a1049 1
	invent_solid( "_TARGET_TRAIL_LL_", &trail, 0x00FF00FFL );
d1052 1
a1052 1
	invent_solid( "_TARGET_TRAIL_LR_", &trail, 0x0000FFFFL );
d1055 1
a1055 1
	invent_solid( "_TARGET_TRAIL_UR_", &trail, 0x00FF00FFL );
d1058 1
a1058 1
	invent_solid( "_TARGET_TRAIL_UL_", &trail, 0x0000FFFFL );
d1062 12
@


10.7
log
@Changed cmdline() to take an rt_vls argument
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.6 92/04/03 05:04:56 mike Exp Locker: mike $ (BRL)";
d352 1
a352 1
		if( (len = rt_vls_gets( &str, stdin )) >= 0 )  {
d354 2
a355 4
			if( len > 0 )  {
				if( cmdline( &str ) )
					pr_prompt();
			}
d594 3
a596 2
		/* Display titles, etc */
		dotitles();
@


10.6
log
@Added preliminary tracking frame stuff
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.5 92/04/03 02:28:33 mike Exp Locker: mike $ (BRL)";
a333 1
	char		input_line[MAXLINE];
d348 2
a350 2
		input_line[0] = '\0';

d352 6
a357 3
		if( fgets( input_line, MAXLINE, stdin ) != NULL ) {
			if( cmdline( input_line ) )
				pr_prompt();
d366 1
d376 1
a376 2
		rt_vls_strcat( &dm_values.dv_string, "press " );
		rt_vls_strcat( &dm_values.dv_string,
a377 1
		rt_vls_strcat( &dm_values.dv_string, "\n" );
d383 2
a384 2
		sprintf(input_line, "knob x %f\n", dm_values.dv_xjoy );
		rt_vls_strcat( &dm_values.dv_string, input_line);
d387 2
a388 2
		sprintf(input_line, "knob y %f\n", dm_values.dv_yjoy );
		rt_vls_strcat( &dm_values.dv_string, input_line);
d391 2
a392 2
		sprintf(input_line, "knob z %f\n", dm_values.dv_zjoy );
		rt_vls_strcat( &dm_values.dv_string, input_line);
d419 1
a419 1
		sprintf(input_line, "M 1 %d %d\n",
a420 1
		rt_vls_strcat( &dm_values.dv_string, input_line);
d427 1
a427 1
			sprintf(input_line, "M 0 %d %d\n",
a428 1
			rt_vls_strcat( &dm_values.dv_string, input_line);
d443 2
a444 2
		sprintf(input_line, "knob X %f\n", dm_values.dv_xslew );
		rt_vls_strcat( &dm_values.dv_string, input_line);
d447 2
a448 2
		sprintf(input_line, "knob Y %f\n", dm_values.dv_yslew );
		rt_vls_strcat( &dm_values.dv_string, input_line);
d451 2
a452 2
		sprintf(input_line, "knob Z %f\n", dm_values.dv_zslew );
		rt_vls_strcat( &dm_values.dv_string, input_line);
d457 2
a458 2
		sprintf(input_line, "knob S %f\n", dm_values.dv_zoom );
		rt_vls_strcat( &dm_values.dv_string, input_line);
d494 1
a494 4
#if 0
printf("cmd: %s", rt_vls_addr(&cmd) );
#endif
			(void)cmdline( rt_vls_addr(&cmd) );
a810 24
 *			S O U R C E _ F I L E
 *
 *  XXX This should probably move to mged/cmd.c
 */
static void
source_file(fp)
register FILE	*fp;
{
	struct rt_vls	str;
	int		len;

	rt_vls_init(&str);

	while( (len = rt_vls_gets( &str, fp )) >= 0 )  {
		rt_vls_strcat( &str, "\n" );
		if( len > 0 )  cmdline( rt_vls_addr( &str ) );
		rt_vls_trunc( &str, 0 );
	}

	rt_vls_free(&str);
}


/*
d829 1
a829 1
			source_file( fp );
d840 1
a840 1
			source_file( fp );
d848 1
a848 1
		source_file( fp );
@


10.5
log
@Added measurement of frame drawing time.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.4 92/02/05 13:32:01 mike Exp Locker: mike $ (BRL)";
d79 1
d212 1
d536 1
d539 2
a540 1
		Viewscale *= 1.0 - (dm_values.dv_zoom / 10);
d546 2
a548 1
		dmaflag = 1;
d579 2
d583 5
d605 6
a610 2
		frametime = rt_read_timer( (char *)0, 0 );
		if( frametime <= 1.0e-5 )  frametime = 0.01;	/* 100 fps */
d651 6
d686 5
a690 1
	static vect_t model_pos;
d692 10
a701 4
	MAT4X3PNT( model_pos, view2model, view_pos );
	toViewcenter[MDX] = -model_pos[X];
	toViewcenter[MDY] = -model_pos[Y];
	toViewcenter[MDZ] = -model_pos[Z];
d891 115
@


10.4
log
@ANSI nit
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.3 91/12/20 02:21:51 mike Exp Locker: mike $ (BRL)";
d78 1
a568 1
	dmp->dmr_prolog();	/* update displaylist prolog */
d574 4
d592 7
a599 1
	dmp->dmr_update();
@


10.3
log
@Moved sedit_rotate() and objedit_rotate() off to edsol.c
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.2 91/11/05 00:02:55 mike Exp Locker: mike $ (BRL)";
d108 2
a109 2
FILE *infile = stdin;
FILE *outfile = stdout;
d126 4
@


10.2
log
@Modified for beginnings of new display manager interface.
Added zoom and "M" (mouse) command.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 10.1 91/10/12 06:43:43 mike Rel4_0 Locker: mike $ (BRL)";
d593 1
a593 5
 * Apply the "joystick" rotation to the viewing perspective.
 *
 * Xangle = angle of rotation about the X axis, and is done 3rd.
 * Yangle = angle of rotation about the Y axis, and is done 2nd.
 * Zangle = angle of rotation about the Z axis, and is done 1st.
d597 1
a597 1
fastf_t xangle, yangle, zangle;
d599 2
a600 1
	static mat_t	newrot;		/* NEW rot matrix, from joystick */
d604 6
a609 12
	/* Joystick is used for parameter or solid rotation (ST_S_EDIT) */
	if(es_edflag == PROT || es_edflag == SROT || es_edflag == ROTFACE)  {
		static mat_t tempp;

		mat_idn( incr_change );
		buildHrot( incr_change, xangle, yangle, zangle );

		/* accumulate the translations */
		mat_mul(tempp, incr_change, acc_rot_sol);
		mat_copy(acc_rot_sol, tempp);
		sedit();	/* change es_rec only, NOW */
		return;
a610 4
	/* Joystick is used for object rotation (ST_O_EDIT) */
	if( movedir == ROTARROW )  {
		static mat_t tempp;
		static vect_t point;
a611 13
		mat_idn( incr_change );
		buildHrot( incr_change, xangle, yangle, zangle );

		/* accumulate change matrix - do it wrt a point NOT view center */
		mat_mul(tempp, modelchanges, es_mat);
		/* XXX should have an es_keypoint for this */
		MAT4X3PNT(point, tempp, es_rec.s.s_values);
		wrt_point(modelchanges, incr_change, modelchanges, point);

		new_mats();
		return;
	}

a614 1
	 * ***** THIS IS BROKEN!! ****** (rotation is around origin, humbug)
d618 4
a621 6
	{
		static mat_t temp;
		mat_mul( temp, newrot, Viewrot );
		mat_copy( Viewrot, temp );
		new_mats();
	}
@


10.1
log
@Release_4.0
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.25 91/10/11 11:32:59 butler Exp $ (BRL)";
d331 3
a357 1

d360 3
a362 9
	/*
	 *  Process any "string commands" sent to us by the display manager.
	 *  Each one is expected to be newline terminated.
	 */
	if( (len = rt_vls_strlen( &dm_values.dv_string )) > 0 )  {
		register char	*cp = rt_vls_addr( &dm_values.dv_string );
		char		*ep;
		char		*end = cp + len;
		struct rt_vls	cmd;
d364 7
a370 18
		rt_vls_init( &cmd );

		while( cp < end )  {
#ifdef BSD
			ep = index( cp, '\n' );
#else
			ep = strchr( cp, '\n' );
#endif
			if( ep == NULL )  break;

			/* Copy one cmd, incl newline.  Null terminate */
			rt_vls_strncpy( &cmd, cp, ep-cp+1 );
			/* cmdline insists on ending with newline&null */
			(void)cmdline( rt_vls_addr(&cmd) );
			cp = ep+1;
		}
		rt_vls_trunc( &dm_values.dv_string, 0 );
		rt_vls_free( &cmd );
d373 4
a376 16
	/* Process any function button presses */
	if( dm_values.dv_buttonpress )
		button( dm_values.dv_buttonpress );

	/* Process any joystick activity */
	if(	dmaflag
	   ||	dm_values.dv_xjoy != 0.0
	   ||	dm_values.dv_yjoy != 0.0
	   ||	dm_values.dv_zjoy != 0.0
	)  {
		non_blocking++;

		/* Compute delta x,y,z parameters */
		usejoy( dm_values.dv_xjoy * 6 * degtorad,
			dm_values.dv_yjoy * 6 * degtorad,
			dm_values.dv_zjoy * 6 * degtorad );
d378 8
d388 1
a388 1
	 * Use data tablet inputs.
a389 3
	if( dm_values.dv_penpress )
		non_blocking++;	/* to catch transition back to 0 */

d392 1
a392 3
		if( Viewscale > SMALL_FASTF )
			Viewscale *= 0.5;
		new_mats();
d396 1
a396 3
		if( Viewscale < INFINITY )
			Viewscale *= 2.0;
		new_mats();
d406 1
d411 6
d418 6
a423 1
		usepen();
d434 65
d508 14
a521 3
	/* Apply the knob slew factor to the view center */
	if( dm_values.dv_xslew != 0.0 || dm_values.dv_yslew != 0.0
	  || dm_values.dv_zslew != 0.0 )  {
d523 3
a525 3
		knobvec[X] = -dm_values.dv_xslew / 10;
		knobvec[Y] = -dm_values.dv_yslew / 10;
		knobvec[Z] = -dm_values.dv_zslew / 10;
a526 1
		non_blocking++;
d528 1
a528 3

	/* Apply zoom rate input to current view window size */
	if( dm_values.dv_zoom != 0 )  {
d541 2
a542 3
	/* See if the angle/distance cursor is doing anything */
	if(  adcflag && dm_values.dv_flagadc )
		dmaflag = 1;	/* Make refresh call dozoom */
@


9.25
log
@mods to make SGI 3030 happy
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.24 91/09/25 08:11:32 butler Exp Locker: butler $ (BRL)";
@


9.24
log
@patches for the !@@#$%@@$%^ convex
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.23 91/09/05 20:25:04 mike Exp Locker: butler $ (BRL)";
d82 4
d88 1
d269 6
d279 1
d307 1
a307 1
		 */	 
d703 8
d717 1
d719 1
d815 1
@


9.23
log
@Improved signal handling so that commands being run from the
.mgedrc won't scrogg the SIGINT handler.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.22 91/08/28 04:18:06 mike Exp $ (BRL)";
d786 1
a786 1
#ifdef BSD
@


9.22
log
@Added processing for .mgedrc file.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.22 91/08/27 00:51:42 mike Exp $ (BRL)";
d135 9
d264 1
a264 1
		if( signal( SIGINT, SIG_IGN ) == SIG_IGN )
@


9.21
log
@Prevent zoom in/out buttons from going out of control.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.20 91/07/23 02:30:48 butler Exp $ (BRL)";
d86 1
d133 2
d164 3
a166 1
	/* If multiple processors might be used, initialize for it */
d200 20
d228 1
a228 11
	rt_vls_init( &dm_values.dv_string );

	dmaflag = 1;

	/* Fire up the display manager, and the display processor */
	if( argc == 2 )
		get_attached();		/* interactive */

	/* Here we should print out a "message of the day" file */

	/*	 Scan input file and build the directory	 */
a239 6
	/* Initialize the menu mechanism to be off, but ready. */
	mmenu_init();
	btn_head_menu(0,0,0);		/* unlabeled menu */

	refresh();			/* Put up faceplate */

d247 2
d252 1
a252 1
	/* Caught interrupts take us here */
d254 1
a254 1
		/* First pass through */
a266 1
	(void)signal( SIGPIPE, SIG_IGN );
d706 69
@


9.20
log
@cleaned up some minor nits that lint was complaining about.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.19 91/07/23 02:26:00 butler Exp $ (BRL)";
d383 2
a384 1
		Viewscale *= 0.5;
d389 2
a390 1
		Viewscale *= 2.0;
@


9.19
log
@changed main() to attempt to create new database if database doesn't exist
and there is not tty on stdin.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.18 91/06/25 16:19:41 phil Exp $ (BRL)";
a118 1
	register int i;
d279 1
a518 1
		static vect_t point;
@


9.18
log
@Rolled 9.16 change back into 9.17.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.17 91/06/25 16:09:11 pjt Exp $ (BRL)";
d138 7
a144 7
	    	perror( argv[1] );
		if( !isatty(0) )
			exit(2);		/* NOT finish() */
		(void)fprintf(outfile, "Create new database (y|n)[n]? ");
		fflush(outfile);
		(void)fgets(line, sizeof(line), infile);
		if( line[0] != 'y' && line[0] != 'Y' )
d146 5
@


9.17
log
@Changed args in a call to setview()
and the formal parameters in its definition
from ints to doubles
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.15 91/03/02 02:00:29 mike Exp $ (BRL)";
d259 2
a260 1
		rateflag = event_check( rateflag );
a274 1
	/* NOTREACHED */
d282 4
@


9.16
log
@Modified to stop the SGI optimizer from complaining about an infinite loop
@
text
@d186 1
a186 1
	setview( 0, 0, 0 );
d259 1
a259 2
		/* This test stops optimizers from complaining about an infinite loop */
		if( (rateflag = event_check( rateflag )) < 0 )  break;
d274 1
a281 4
 *
 *  Returns -
 *	 0	no events detected
 *	>0	number of events detected
d557 1
a557 1
 * Set the view.  Angles are integers, in degrees.
d564 1
a564 1
int a1, a2, a3;		/* integer angles, in degrees */
@


9.15
log
@Fixed one-shot command on command line feature.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.14 91/02/28 01:20:33 mike Exp $ (BRL)";
d259 2
a260 1
		rateflag = event_check( rateflag );
a274 1
	/* NOTREACHED */
d282 4
@


9.14
log
@lint
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.14 91/02/28 01:14:17 mike Exp $ (BRL)";
d229 1
a229 9
		argc -= 2;
		argv += 2;
		numargs = 0;
		while( argc > 0 )  {
			cmd_args[numargs++] = argv[0];
			argc--; argv++;
		}
		cmd_args[numargs] = (char *)0;
		mged_cmd();
@


9.13
log
@Forgot one parallel initialization, which, of course, I just
started using for the FACETIZE command.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.12 91/01/29 00:28:14 mike Exp $ (BRL)";
d43 5
d57 1
a58 1
#include "machine.h"
@


9.12
log
@Modified for new rt_vlist structure
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.11 91/01/26 04:52:59 mike Exp $ (BRL)";
d159 1
@


9.11
log
@Added ability for display managers to send command strings up.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.10 90/12/07 05:40:53 mike Exp $ (BRL)";
d165 2
a166 1
	
@


9.10
log
@Tell db_scan to process old region-ID based material property stuff.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.9 90/12/06 15:49:19 mike Exp $ (BRL)";
d56 1
d192 2
a289 1
	char		cmd[128];
d291 1
d318 30
@


9.9
log
@Eliminated two flag variables for Big-E command.
They live strictly in proc_reg.c now
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.8 90/05/23 00:14:15 mike Exp $ (BRL)";
d200 1
a200 1
	db_scan( dbip, (int (*)())db_diradd);
@


9.8
log
@Separated out event checking from the main loop, so that
it can be accessed from within animation previews.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.7 90/05/22 16:03:08 mike Exp $ (BRL)";
a179 2
	drawreg = 0;		/* no region processing */
	regmemb = -1;		/* no members to process */
@


9.7
log
@Changed interface to cmdline() so that it could be used directly
by other modules.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.6 90/05/13 12:07:09 mike Exp $ (BRL)";
d114 1
a256 3
		static vect_t knobvec;	/* knob slew */
		static int rateflag;	/* != 0 means change RATE */

d259 9
d269 7
a275 7
		 * dmr_input() will suspend until some change has occured,
		 * either on the device peripherals, or a command on the
		 * keyboard.
		 */
		i = dmp->dmr_input( 0, rateflag );	/* fd 0 for cmds */
		if( i )  {
			static char line[MAXLINE];
d277 14
a290 1
			line[0] = '\0';
d292 20
a311 11
			/* Read input line */
			if( fgets( line, MAXLINE, stdin ) != NULL ) {
				if( cmdline( line ) )
					pr_prompt();
			} else {
				/* Check for Control-D (EOF) */
				if( feof( stdin ) )  {
					/* EOF, let's hit the road */
					f_quit();
					/* NOTREACHED */
				}
d314 1
d316 1
a316 1
		rateflag = 0;
d318 3
a320 3
		/* Process any function button presses */
		if( dm_values.dv_buttonpress )
			button( dm_values.dv_buttonpress );
d322 7
a328 7
		/* Process any joystick activity */
		if(	dmaflag
		   ||	dm_values.dv_xjoy != 0.0
		   ||	dm_values.dv_yjoy != 0.0
		   ||	dm_values.dv_zjoy != 0.0
		)  {
			rateflag++;
d330 5
a334 5
			/* Compute delta x,y,z parameters */
			usejoy( dm_values.dv_xjoy * 6 * degtorad,
				dm_values.dv_yjoy * 6 * degtorad,
				dm_values.dv_zjoy * 6 * degtorad );
		}
d336 5
a340 5
		/*
		 * Use data tablet inputs.
		 */		 
		if( dm_values.dv_penpress )
			rateflag++;	/* to catch transition back to 0 */
d342 5
a346 5
		switch( dm_values.dv_penpress )  {
		case DV_INZOOM:
			Viewscale *= 0.5;
			new_mats();
			break;
d348 4
a351 4
		case DV_OUTZOOM:
			Viewscale *= 2.0;
			new_mats();
			break;
d353 7
a359 20
		case DV_SLEW:		/* Move view center to here */
			{
				vect_t tabvec;
				tabvec[X] =  dm_values.dv_xpen / 2047.0;
				tabvec[Y] =  dm_values.dv_ypen / 2047.0;
				tabvec[Z] = 0;
				slewview( tabvec );
			}
			break;

		case DV_PICK:		/* transition 0 --> 1 */
		case 0:			/* transition 1 --> 0 */
			usepen();
			break;
		default:
			(void)fprintf(outfile, "pen(%d,%d,x%x) -- bad dm press code\n",
			dm_values.dv_xpen,
			dm_values.dv_ypen,
			dm_values.dv_penpress);
			break;
d361 1
d363 11
a373 9
		/*
		 * Set up window so that drawing does not run over into the
		 * status line area, and menu area (if present).
		 */
		windowbounds[1] = XMIN;		/* XLR */
		if( illump != SOLID_NULL )
			windowbounds[1] = MENUXLIM;
		windowbounds[3] = TITLE_YBASE-TEXT1_DY;	/* YLR */
		dmp->dmr_window(windowbounds);	/* hack */
d375 9
a383 10
		/* Apply the knob slew factor to the view center */
		if( dm_values.dv_xslew != 0.0 || dm_values.dv_yslew != 0.0
		  || dm_values.dv_zslew != 0.0 )  {
			/* slew 1/10th of the view per update */
			knobvec[X] = -dm_values.dv_xslew / 10;
			knobvec[Y] = -dm_values.dv_yslew / 10;
			knobvec[Z] = -dm_values.dv_zslew / 10;
			slewview( knobvec );
			rateflag++;
		}
d385 13
a397 2
		/* Apply zoom rate input to current view window size */
		if( dm_values.dv_zoom != 0 )  {
d400 5
a404 8
			Viewscale *= 1.0 - (dm_values.dv_zoom / 10);
			if( Viewscale < MINVIEW )
				Viewscale = MINVIEW;
			else  {
				rateflag++;
			}
			new_mats();
			dmaflag = 1;
d406 3
d410 3
a412 6
		/* apply solid editing changes if necessary */
		if( sedraw > 0) {
			sedit();			/* e13.c */
			sedraw = 0;
			dmaflag = 1;
		}
d414 1
a414 11
		/* See if the angle/distance cursor is doing anything */
		if(  adcflag && dm_values.dv_flagadc )
			dmaflag = 1;	/* Make refresh call dozoom */

		/*
		 * Cause the control portion of the displaylist to be
		 * updated to reflect the changes made above.
		 */	 
		refresh();
	}
	/* NOTREACHED */
@


9.6
log
@If parallel routine was interrupted, need to RES_RELEASE semaphores.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/ged.c,v 9.5 90/05/09 20:00:54 mike Exp $ (BRL)";
d268 16
a283 2
			if( cmdline() )
				pr_prompt();
@


9.5
log
@Changed "enmg" to "ev", for "evaluate".
Move parallel processsing startup from hideline to ged.c
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 9.4 90/04/21 06:06:07 mike Locked $ (BRL)";
d245 5
@


9.4
log
@redraw() and drawtree() replaced.
More emphasis on argv/argc use in command functions.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 9.3 89/10/10 16:25:18 mike Locked $ (BRL)";
d40 1
a40 1
char MGEDCopyRight_Notice[] = "@@(#) Copyright (C) 1985,1987 by the United States Army";
d149 9
@


9.3
log
@Noted where an es_keypoint should be used, instead.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 9.2 89/08/10 21:13:21 mike Exp $ (BRL)";
a171 1
	reg_error = 0;		/* no errors yet */
@


9.2
log
@Changed default view size to 1000mm -- should help keep people from
creating models with parts smaller than 1mm.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 9.1 89/05/19 06:03:11 mike Locked $ (BRL)";
d457 1
@


9.1
log
@Release_3.5
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.11 89/05/11 21:11:14 phil Exp $ (BRL)";
d161 1
a161 1
	Viewscale = 0.5;		/* => viewsize of 1 */
@


8.11
log
@save dbi_ units into local variables until we clean these up
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.10 89/05/08 21:46:15 phil Locked $ (BRL)";
@


8.10
log
@added printing of database title and units
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.9 89/04/21 04:52:03 phil Locked $ (BRL)";
d194 4
@


8.9
log
@Faceplate locations moved into titles.h
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.8 89/04/06 20:18:14 mike Locked $ (BRL)";
d86 10
d194 5
@


8.8
log
@Converted to externs.h
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.7 89/03/07 00:02:49 mike Locked $ (BRL)";
d58 1
@


8.7
log
@ansii
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.6 89/03/06 17:40:22 mike Locked $ (BRL)";
d52 1
a64 6

extern void	exit(), perror(), sync();
extern char	*malloc(), *tempnam();
extern int	close(), dup(), execl(), fork(), getuid(), open(), pipe(),
		unlink(), write();
extern long	time();
@


8.6
log
@ansii
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.5 89/01/16 22:55:32 mike Locked $ (BRL)";
a69 6

#ifdef BSD
extern char	*sprintf();
#else
extern int	sprintf();
#endif
@


8.5
log
@Moved bsdselect() function into libsysv
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.4 89/01/09 05:08:58 phil Locked $ (BRL)";
d68 1
a68 1
		fprintf(), unlink(), write();
@


8.4
log
@Added message to warn of database in read-only mode
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.3 88/12/06 01:24:23 mike Locked $ (BRL)";
d46 1
a46 5
#if defined(BSD) || defined(CRAY)
#	include <sys/time.h>	/* for struct timeval.  Includes <time.h> */
#else
#	include <time.h>
#endif
a50 14
#if defined(sgi)
#	if !defined(mips) || defined(SGI4D_Rel2)
		/* 3D systems, and Rel2 4D systems. */
#		include <bsd/sys/types.h>
#		include <bsd/sys/time.h>
#	else
		/* Rel3 4D systems got it right */
#		include <sys/types.h>
#		include <sys/time.h>
#	endif
#endif
#ifdef stellar
#	include <sys/timeval.h>
#endif
a601 26
}

/*
 *			B S D S E L E C T
 *
 *  Ordinarily, a stub for select() could have been implemented here,
 *  but the IRIS defines a graphics library routine select().
 *  On non-BSD systems, select() is name likely to have been reused,
 *  so this special interface has been created.  This has the slight
 *  advantage of centralizing the struct timeval stuff.
 */

bsdselect( readfds, sec, us )
long readfds;
{
#if defined(BSD) || defined(sgi) || defined(stellar) || defined(CRAY)
	struct timeval tv;

	tv.tv_sec = sec;
	tv.tv_usec = us;
	if( select( 32, &readfds, 0L, 0L, &tv ) <= 0 )
		return(0);
	return( readfds );
#else
	return(32-1);	/* SYSV always has lots of input */
#endif
@


8.3
log
@Converted to new db_*() routines.
Eliminated maxview.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/ged.c,v 1.5 88/10/30 02:37:07 mike Exp $ (BRL)";
d162 2
@


8.2
log
@SGI #include fix.
really Release 3.0
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 8.1 88/10/05 00:36:52 mike Locked $ (BRL)";
d73 1
d95 2
d99 1
a99 1
int	dmaflag;			/* Set to 1 to force new screen DMA */
d145 2
a146 1
	if( db_open( argv[1] ) < 0 )  {
d148 2
d151 1
a151 1
			exit(2);		/* NOT finish */
d156 5
a160 3
			exit(0);		/* NOT finish */
		if( db_create( argv[1] ) < 0 )
			exit(2);		/* NOT finish */
d177 1
a177 1
	Viewscale = .125;		/* also in chgview.c */
d209 1
a209 1
	dir_build();
d227 1
a227 1
		do_cmd();
d354 1
a354 4
				if( Viewscale > maxview * 15.0 )
					Viewscale = maxview * 15.0;
				else
					rateflag++;
@


8.1
log
@Release_3.0
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.9 88/09/17 04:52:03 mike Exp $ (BRL)";
d55 10
a64 3
#ifdef sgi
#	include <bsd/sys/types.h>
#	include <bsd/sys/time.h>
@


7.9
log
@bsdselect() also on the Cray.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.8 88/09/17 03:49:55 mike Locked $ (BRL)";
@


7.8
log
@Added CRAY, improved sgi timeval stuf
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.7 88/09/17 03:44:41 mike Locked $ (BRL)";
d621 1
a621 1
#if defined(BSD) || defined(sgi) || defined(stellar)
@


7.7
log
@Added support for stellar
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.7 88/09/17 03:42:46 mike Exp $ (BRL)";
d46 1
a46 1
#ifdef BSD
d56 2
a57 4
	struct timeval {
		long	tv_sec;		/* seconds */
		long 	tv_usec;	/* and microseconds */
	};
@


7.6
log
@changed i/o to stream versions in preparation for pipes and redirects.
/
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.5 88/07/22 01:57:38 reschly Locked $ (BRL)";
d47 1
a47 1
#include <sys/time.h>	/* for struct timeval.  Includes <time.h> */
d49 1
a49 1
#include <time.h>
d52 2
a53 2
#include <termio.h>
#undef VMIN	/* also used in vmath.h */
d56 4
a59 4
struct timeval {
	long	tv_sec;		/* seconds */
	long 	tv_usec;	/* and microseconds */
};
d61 3
d623 1
a623 1
#if defined(BSD) || defined(sgi)
@


7.5
log
@menu -> mmenu
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.4 88/01/13 16:38:18 phil Locked $ (BRL)";
d77 1
a77 1
		printf(), unlink(), write();
d103 3
d108 2
a109 2
	(void)printf("mged> ");
	(void)fflush(stdout);
d124 2
a125 1
		(void)printf("Usage:  %s database [command]\n", argv[0]);
d131 1
a131 1
		(void)printf("%s\n", version+5);	/* skip @@(#) */
d138 3
a140 3
		(void)printf("Create new database (y|n)[n]? ");
		fflush(stdout);
		(void)gets( line );
d227 1
a227 1
		(void)printf("\nAborted.\n");
d302 1
a302 1
			(void)printf("pen(%d,%d,x%x) -- bad dm press code\n",
d527 1
a527 1
	(void)sprintf( line, "%s [%s] time=%ld uid=%d (%s) %s\n",
d555 1
a555 1
	(void)sprintf( place, "exit_status=%d", exitcode );
@


7.4
log
@added a call to mged_finish
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.3 87/11/05 07:04:49 stay Locked $ (BRL)";
d192 1
a192 1
	menu_init();
@


7.3
log
@Changed external name of copyright notice to not conflict with librt's.
@
text
@d14 1
a14 1
 *	finish		Terminate with logging.  To be used instead of exit().
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.2 87/11/05 05:06:09 mike Locked $ (BRL)";
d546 1
a546 1
finish( exitcode )
d570 1
a570 1
	finish(0);
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 7.1 87/11/03 00:00:56 mike Rel $ (BRL)";
d40 1
a40 1
char CopyRight_Notice[] = "@@(#) Copyright (C) 1985,1987 by the United States Army";
@


7.1
log
@Release 2.3
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 6.1 87/07/11 08:04:08 mike Rel $ (BRL)";
d62 1
a62 1
#include "./machine.h"	/* special copy */
d417 1
a417 1
float xangle, yangle, zangle;
@


6.1
log
@Release 2.0
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 5.1 87/06/24 22:20:54 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 4.7 87/06/17 23:48:45 phil Exp $ (BRL)";
@


4.7
log
@non-blocking I/O support on ifdef NONBLOCK
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 4.6 87/06/16 05:17:10 phil Locked $ (BRL)";
@


4.6
log
@reset lights on start and exit
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 4.5 87/06/13 06:14:24 phil Exp $ (BRL)";
d51 4
d242 2
a243 2
			cmdline();
			pr_prompt();
d566 4
@


4.5
log
@added zslew
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 4.4 87/05/29 00:44:23 mike Exp $ (BRL)";
d208 3
d549 1
@


4.4
log
@Added command line command processing as an option.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 4.3 87/02/13 00:07:46 mike Locked $ (BRL)";
d309 2
a310 1
		if( dm_values.dv_xslew != 0.0 || dm_values.dv_yslew != 0.0 )  {
d314 1
a314 1
			knobvec[Z] = 0;
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d33 1
a33 1
 *	This software is Copyright (C) 1985 by the United States Army.
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 4.2 87/01/02 13:37:35 mike Rel1 $ (BRL)";
d40 1
a40 1
char CopyRight_Notice[] = "@@(#) Copyright (C) 1985 by the United States Army";
d96 3
d116 2
a117 2
	if( argc != 2 )  {
		(void)printf("Usage:  %s database\n", argv[0]);
d121 3
a123 2
	/* Identify ourselves */
	(void)printf("%s\n", version+5);	/* skip @@(#) */
d179 2
a180 1
	get_attached();
d193 15
d352 1
@


4.2
log
@Release 1.12
Enhancements to allow SGI to use select(), since
under 3.5, FIONREAD is broken.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 4.1 86/12/29 03:21:48 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.17 86/10/26 14:09:06 mike Exp $ (BRL)";
d51 6
d573 1
a573 1
 *  but the IRIS uses the library routine select() for something else.
d582 1
a582 4
#ifdef SYSV
	return(32-1);	/* Always has lots of input */
#endif
#ifdef BSD
d590 2
@


2.17
log
@Removed @@(#) from version print.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.16 86/09/23 01:48:16 mike Locked $ (BRL)";
@


2.16
log
@Fixed small error in BSD include file locations.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.15 86/09/10 01:35:11 mike Locked $ (BRL)";
d113 1
a113 1
	(void)printf("%s\n", version);
@


2.15
log
@Revised for new buttons.c interface on init.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.14 86/08/14 22:22:28 mike Exp $ (BRL)";
d46 3
d50 1
@


2.14
log
@Changed attach() to bsdattach() to provide better insulation.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.13 86/08/13 07:33:08 mike Exp $ (BRL)";
d174 1
a174 1
	button_menu(0);			/* unlabeled menu */
d384 2
a385 5
	/*
	 * Joystick is used for parameter or solid rotation (ST_S_EDIT),
	 * or for object rotation (ST_O_EDIT).
	 */
	if( es_edflag == PROT || es_edflag == SROT || movedir == ROTARROW ) {
d392 14
a405 7
		if( es_edflag == SROT || es_edflag == PROT )  {
			/* accumulate the translations */
			mat_mul(tempp, incr_change, acc_rot_sol);
			mat_copy(acc_rot_sol, tempp);
			sedit();	/* change es_rec only, NOW */
			return;
		}
@


2.13
log
@One more #define glitch
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.12 86/08/13 00:07:59 mike Exp $ (BRL)";
d45 1
a46 1
#include <setjmp.h>
d555 13
d569 11
a579 4
/* System V lacks this */
select( n, iv, ov, ev, timeout )
{
	return(n);
a580 1
#endif
@


2.12
log
@Converted from BSD42 to BSD and SYSV defines to select UNIX type.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.11 86/08/12 06:49:44 mike Exp $ (BRL)";
d65 2
a66 1
#ifdef BSD42
@


2.11
log
@Changed #includes for CC -I../h
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.10 86/06/20 01:31:02 mike Exp $ (BRL)";
d554 2
a555 2
#ifndef BSD42
/* Scum-bag System V */
d559 8
@


2.10
log
@Added ability to create a new database if given name
does not exist.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.9 85/08/07 05:19:05 mike Exp $ (BRL)";
d49 6
a54 6
#include "../h/vmath.h"
#include "ged.h"
#include "solid.h"
#include "../h/db.h"
#include "sedit.h"
#include "dm.h"
@


2.9
log
@Changed to use common ../h/vmath.h
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.8 85/06/03 16:49:14 mike Exp $ (BRL)";
d111 12
a122 1
	db_open( argv[1] );
@


2.8
log
@Fixes to allow compilation on System V on the IRIS.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.7 85/05/29 23:17:23 mike Exp $ (BRL)";
d48 2
a49 1
#include "ged_types.h"
a54 1
#include "../h/vmath.h"
@


2.7
log
@Added MENU_L2 menu for solid/object edit buttons,
moved menus to left side of screen.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.6 85/05/10 00:54:31 mike Exp $ (BRL)";
d542 8
@


2.6
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.5 85/05/03 01:39:53 mike Exp $ (BRL)";
d142 4
a145 4
	windowbounds[0] = 2047;		/* XHR */
	windowbounds[1] = -2048;	/* XLR */
	windowbounds[2] = 2047;		/* YHR */
	windowbounds[3] = -2048;	/* YLR */
d260 1
a260 1
		windowbounds[0] = 2047;		/* XHR */
d262 1
a262 1
			windowbounds[0] = XLIM;
@


2.5
log
@Removed xcross and inten_* stuff.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.4 85/05/02 23:27:30 mike Exp $ (BRL)";
a70 1
extern struct dm dm_Mg;
d75 1
a75 3
/**** Begin global display information, used by dm.c *******/
int		windowbounds[6];	/* X hi,lo;  Y hi,lo;  Z hi,lo */
/**** End global display information ******/
d148 1
d162 1
a175 1
	(void)signal( SIGINT, SIG_IGN );
d184 2
d201 1
a201 1
			button( (long)dm_values.dv_buttonpress );
a262 1

d264 1
@


2.4
log
@Absorbed some logic from usepen().
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.3 85/03/28 22:25:10 mike Exp $ (BRL)";
a76 4
int		xcross = 0;
int		ycross = 0;		/* tracking cross position */
int		inten_offset;		/* intensity offset (IOR) */
int		inten_scale;		/* intensity scale (ISR) */
a143 2

	inten_scale = 0x7FF0;	/* full positive, to start with */
@


2.3
log
@set SIGPIPE to SIG_IGN, to prevent problems from having
helper processes die unexpectedly.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.2 85/03/12 05:26:00 mike Exp $ (BRL)";
d227 1
a227 1
			rateflag++;
d229 5
a233 2
		xcross = dm_values.dv_xpen;
		ycross = dm_values.dv_ypen;
d235 26
a260 1
		usepen();
@


2.2
log
@Improved type cast for signal.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 2.1 85/03/11 23:56:15 mike Prod $ (BRL)";
d184 1
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.13 85/03/08 20:53:56 mike Exp $ (BRL)";
d177 1
a177 1
			cur_sigint = SIG_IGN;	/* detached? */
@


1.13
log
@USNA changes which formalize state changes.
@
text
@d6 2
a7 1
 * Functions -
d16 2
d19 1
a19 2
 *
 * Authors -
d27 1
a27 1
 * Source -
d31 4
d37 1
a37 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.12 85/02/14 00:42:50 mike Exp $ (BRL)";
d40 2
d51 1
a51 1
#include "db.h"
d54 1
a54 1
#include "vmath.h"
d63 1
a63 1
		printf(),  unlink(), write();
d65 5
d87 2
d95 1
a95 1
	fflush(stdout);
d101 1
d111 1
a111 1
		exit(1);		/* NOT finish() */
d115 1
a115 1
	printf("%s\n", version);
d181 1
a181 1
		printf("\nAborted.\n");
d206 1
a206 1
			button( dm_values.dv_buttonpress );
a213 1

d231 1
a231 4
		/* inputs:  -2048 <= x,y <= +2047 */
		usepen( dm_values.dv_xpen,
			dm_values.dv_ypen,
			dm_values.dv_penpress );
a240 1

d255 1
a255 1
#define MINVIEW		0.01	/* smallest view.  Prevents runaway zoom */
d320 1
a320 7
			adcursor(
				dm_values.dv_xadc,
				dm_values.dv_yadc,
				dm_values.dv_1adc,	/* Solid line angle */
				dm_values.dv_2adc,	/* Dashed line angle */
				dm_values.dv_distadc	/* Tick distance */
			);
d341 1
a359 1

d497 1
a497 1
	longjmp( jmp_env );
d504 1
a504 1
 *  Derrive the inverse and editing matrices, as required.
d507 1
@


1.12
log
@Added missing #include.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.11 85/02/14 00:29:06 mike Exp $ (BRL)";
d55 1
a55 1
		printf(), sprintf(), unlink(), write();
d111 4
a115 3
	/* Fire up the display manager, and the display processor */
	get_attached();

d118 1
a118 1
	Viewscale = 1.0;
d144 3
a153 4
	
	state = ST_VIEW;
	es_edflag = -1;
	inpara = newedge = 0;
@


1.11
log
@Command prompting.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.10 85/02/05 21:58:01 mike Exp $ (BRL)";
d34 6
a39 4
#include	<fcntl.h>
#include	<signal.h>
#include	<time.h>
#include	<setjmp.h>
@


1.10
log
@Minor change to refresh() to clear dmaflag only at the end.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.9 85/02/05 04:18:04 mike Exp $ (BRL)";
d75 6
d161 1
a161 1
			cur_sigint = quit;
d163 1
a163 1
		printf("MGED\n");
d166 1
d179 1
a179 1
		if( i )
d181 2
@


1.9
log
@signal handling improved.
@
text
@d31 1
a31 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.8 85/02/01 00:50:47 mike Exp $ (BRL)";
a309 2

		dmaflag = 0;
d312 2
@


1.8
log
@Keith's global/local units additions
@
text
@d14 1
a14 2
 *	quit		Signal catcher & general Exit routine
 *	sig3		Signal catcher, to restart display when hung
d31 1
a31 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.7 85/01/17 07:29:19 mike Exp $ (BRL)";
d37 1
d69 3
a71 1
void		quit(), sig3();
a139 3
	(void)signal(SIGINT, quit);
	(void)signal(SIGQUIT, sig3);

d149 12
d173 1
a173 1
			cmdline();			/* e8.c */
d179 1
a179 1
			button( dm_values.dv_buttonpress );	/* e9.c */
d205 1
a205 1
		/* usepen (e4.c) wants inputs:  -2048 <= x,y <= +2047 */
d208 1
a208 1
			dm_values.dv_penpress );	/* e4.c */
a277 4
 * When an initialization routine wants to send out a skeleton displaylist,
 * this routine should be called with a non-zero argument;  normal calls
 * should be with a zero argument.
 *
d279 2
a280 1
 * then you don't want to call it. */
d466 1
a466 2
 * catch SIGINT, and process exiting.
 * Also called upon EOF on STDIN.
d471 2
a472 2
	(void)signal(SIGINT, SIG_IGN);
	finish(0);		/* log termination and exit */
d475 2
a476 3
/*			S I G 3
 *
 * This routine is used to get things going again.
d479 4
a482 3
sig3()  {
	(void)signal(SIGQUIT, sig3);
	printf("Please use keyboard command 'fix' to restart display\n");
@


1.7
log
@
Latest stuff
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.6 85/01/16 19:12:37 mike Exp $ (BRL)";
d111 1
d330 1
d335 1
d337 1
a337 1
			/* accumulate the rotations */
d343 4
a346 3
		/* accumulate change matrices */
		mat_mul( tempp, incr_change, modelchanges );
		mat_copy( modelchanges, tempp);
@


1.6
log
@Added version string
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.5 85/01/16 03:26:11 mike Exp $ (BRL)";
d88 3
a93 3
	/* Identify ourselves */
	printf("%s", version);

d113 1
a113 1
	setview( 270, 0, 0 );
d122 1
d124 5
a128 1
	windowbounds[3] = -925;		/* YLR */
@


1.5
log
@Accumulate the rotations
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.3 84/11/20 04:24:38 mike Exp $ (BRL)";
d71 1
d90 3
@


1.4
log
@pre-Keith version
@
text
@d324 4
a327 1
		if( es_edflag == SROT )  {
@


1.3
log
@Vector lists saved, multiple display managers supported.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.2 84/11/17 05:37:37 mike Exp $ (BRL)";
d41 1
a41 1
#include "3d.h"
a57 1
struct dm *dmp = &dm_Mg;		/* Ptr to Display Manager package */
d99 1
a99 2
	(void)printf("attach %s (%s)\n", dmp->dmr_name, dmp->dmr_lname);
	dmp->dmr_open();
@


1.2
log
@Minor cleanups
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: ged.c,v 1.1 84/11/16 19:51:25 mike Exp $ (BRL)";
d56 3
a58 1
extern struct device_values dm_values;	/* Values from devs, from dm-XX.c */
a59 2
int	objfd;				/* ged database file descriptor */
char	*filename;			/* Name of database file */
a61 2
extern char	part2_base[];	/* from dm-??.c, name of GED2 binary */

d89 1
a89 8
	filename = argv[1];
	if( (objfd = open( filename, O_RDWR )) < 0 )  {
		if( (objfd = open( filename, O_RDONLY )) < 0 )  {
			perror( argv[1] );
			exit(2);		/* NOT finish */
		}
		(void)printf("%s: READ ONLY\n", filename);
	}
d99 3
a101 2
	/* Have the display manager attach to the display processor */
	dm_open();
a122 2
	/* Fire up the display manager, and the display processor */
	dm_init();
d148 1
a148 1
		 * dm_input() will suspend until some change has occured,
d152 1
a152 1
		i = dm_input( 0, rateflag );		/* fd 0 for commands */
d268 1
a268 1
	dm_prolog();		/* update displaylist prolog */
d278 1
a278 1
		dm_normal();
d293 1
a293 1
		dm_epilog();
d297 1
a297 1
	dm_update();
d409 1
a409 1
			part2_base,
d437 1
a437 1

d451 1
a451 2
	dm_finish();	/* halt the display processor */
	finish(0);	/* log termination and exit */
@


1.1
log
@Initial revision
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d336 4
a344 2
		if( state == ST_S_EDIT )
			sedraw = 1;
d349 3
a351 2
	 * Change viewing rotation for non-edited parts.
	 * The view rotates around the view center.
a376 1
	dmaflag = 1;
a395 1
	dmaflag = 1;
@
