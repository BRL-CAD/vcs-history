head	11.30;
access;
symbols
	ansi-20040405-merged:11.26.2.2
	postmerge-20040405-ansi:11.28
	premerge-20040404-ansi:11.27
	postmerge-autoconf:11.27
	autoconf-freeze:11.26.10.2
	premerge-autoconf:11.27
	postmerge-20040315-windows:11.27
	premerge-20040315-windows:11.27
	windows-20040315-freeze:11.26.4.1
	autoconf-20031203:11.26
	autoconf-20031202:11.26
	autoconf-branch:11.26.0.10
	phong-branch:11.26.0.8
	photonmap-branch:11.26.0.6
	rel-6-1-DP:11.26
	windows-branch:11.26.0.4
	rel-6-0-2:11.24
	ansi-branch:11.26.0.2
	rel-6-0-1-branch:11.24.0.2
	hartley-6-0-post:11.25
	hartley-6-0-pre:11.24
	rel-6-0-1:11.24
	rel-6-0:11.24
	rel-5-4:11.20
	offsite-5-3-pre:11.21
	rel-5-3:11.20
	rel-5-2:11.20
	rel-5-1-branch:11.20.0.2
	rel-5-1:11.20
	rel-5-0:11.20
	rel-5-0-beta:11.20
	rel-4-5:11.18
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.14
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.30
date	2004.05.21.17.47.48;	author morrison;	state dead;
branches;
next	11.29;

11.29
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.28;

11.28
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2004.02.02.17.39.34;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2002.08.20.17.08.24;	author jra;	state Exp;
branches
	11.26.2.1
	11.26.4.1
	11.26.10.1;
next	11.25;

11.25
date	2002.08.15.20.55.36;	author hartley;	state Exp;
branches;
next	11.24;

11.24
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	2001.03.31.01.57.23;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2000.08.19.03.10.48;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	98.11.06.22.32.42;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	98.06.11.19.41.47;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.09.08.18.11.11;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.09.03.14.18.33;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.07.25.20.59.09;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.05.27.12.04.42;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.04.14.12.30.35;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	97.01.02.19.40.36;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.10.03.20.51.39;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.23.18.23.21;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.03.22.18.33.18;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.12.27.22.34.52;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	95.07.25.17.49.01;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	95.06.20.13.14.29;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.53;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.27;	author mike;	state Rel4_4;
branches;
next	1.7;

1.7
date	94.11.08.04.18.24;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.08.09.18.15.55;	author gdurf;	state Exp;
branches;
next	1.5;

1.5
date	92.11.11.00.26.18;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	92.06.05.15.19.35;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	92.04.04.01.37.52;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	92.04.04.01.18.00;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	92.04.04.01.11.07;	author mike;	state Exp;
branches;
next	;

11.26.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	11.26.2.2;

11.26.2.2
date	2004.03.17.21.22.01;	author morrison;	state Exp;
branches;
next	;

11.26.4.1
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

11.26.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.26.10.2;

11.26.10.2
date	2004.03.15.14.07.39;	author erikg;	state Exp;
branches;
next	;


desc
@Predictor display for velocity-based navigation
@


11.30
log
@moved to src/mged/
@
text
@/*
 *			P R E D I C T O R . C
 *
 *  Put a predictor frame into view, as an aid to velocity-based
 *  navigation through an MGED model.
 *
 *  Inspired by the paper "Manipulating the Future:  Predictor Based
 *  Feedback for Velocity Control in Virtual Environment Navigation"
 *  by Dale Chapman and Colin Ware, <cware@@unb.ca>, in
 *  ACM SIGGRAPH Computer Graphics Special Issue on 1992 Symposium
 *  on Interactive 3D Graphics.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1992-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/predictor.c,v 11.29 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <math.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./cmd.h"
#include "./mged_dm.h"

/*
 *			I N I T _ T R A I L
 */
static void
init_trail(struct trail *tp)
{
	tp->t_cur_index = 0;
	tp->t_nused = 0;
}

/*
 *			P U S H _ T R A I L
 *
 *  Add a new point to the end of the trail.
 */
static void
push_trail(struct trail *tp, fastf_t *pt)
{
	VMOVE( tp->t_pt[tp->t_cur_index], pt );
	if( tp->t_cur_index >= tp->t_nused )  tp->t_nused++;
	tp->t_cur_index++;
	if( tp->t_cur_index >= MAX_TRAIL )  tp->t_cur_index = 0;
}

#if 0
/*
 *			D R A W _ T R A I L
 *
 *  Draw from the most recently added point, backwards, as vectors.
 */
static void
draw_trail(vhead, tp)
struct bu_list	*vhead;
struct trail	*tp;
{
	int	i;
	int	todo = tp->t_nused;

	BU_LIST_INIT( vhead );
	if( tp->t_nused <= 0 )  return;
	if( (i = tp->t_cur_index-1) < 0 )  i = tp->t_nused-1;
	for( ; todo > 0; todo-- )  {
		if( todo == tp->t_nused )  {
			RT_ADD_VLIST( vhead, tp->t_pt[i], RT_VLIST_LINE_MOVE );
		}  else  {
			RT_ADD_VLIST( vhead, tp->t_pt[i], RT_VLIST_LINE_DRAW );
		}
		if( (--i) < 0 )  i = tp->t_nused-1;
	}
}
#endif

/*
 *			P O L Y _ T R A I L
 *
 *  Draw from the most recently added points in two trails, as polygons.
 *  Proceeds backwards.
 *  t1 should be below (lower screen Y) t2.
 */
static void
poly_trail(struct bu_list *vhead, struct trail *t1, struct trail *t2)
{
	int	i1, i2;
	int	todo = t1->t_nused;
	fastf_t	*s1, *s2;
	vect_t	right, up;
	vect_t	norm;

	if( t2->t_nused < todo )  todo = t2->t_nused;

	BU_LIST_INIT( vhead );
	if( t1->t_nused <= 0 || t1->t_nused <= 0 )  return;

	if( (i1 = t1->t_cur_index-1) < 0 )  i1 = t1->t_nused-1;
	if( (i2 = t2->t_cur_index-1) < 0 )  i2 = t2->t_nused-1;

	/* Get starting points, next to frame. */
	s1 = t1->t_pt[i1];
	s2 = t2->t_pt[i2];
	if( (--i1) < 0 )  i1 = t1->t_nused-1;
	if( (--i2) < 0 )  i2 = t2->t_nused-1;
	todo--;

	for( ; todo > 0; todo-- )  {
		/* Go from s1 to s2 to t2->t_pt[i2] to t1->t_pt[i1] */
		VSUB2( up, s1, s2 );
		VSUB2( right, t1->t_pt[i1], s1 );
		VCROSS( norm, right, up );

		RT_ADD_VLIST( vhead, norm, RT_VLIST_POLY_START );
		RT_ADD_VLIST( vhead, s1, RT_VLIST_POLY_MOVE );
		RT_ADD_VLIST( vhead, s2, RT_VLIST_POLY_DRAW );
		RT_ADD_VLIST( vhead, t2->t_pt[i2], RT_VLIST_POLY_DRAW );
		RT_ADD_VLIST( vhead, t1->t_pt[i1], RT_VLIST_POLY_DRAW );
		RT_ADD_VLIST( vhead, s1, RT_VLIST_POLY_END );

		s1 = t1->t_pt[i1];
		s2 = t2->t_pt[i2];

		if( (--i1) < 0 )  i1 = t1->t_nused-1;
		if( (--i2) < 0 )  i2 = t2->t_nused-1;
	}
}

void
predictor_init(void)
{
  register int i;

  for(i = 0; i < NUM_TRAILS; ++i)
    init_trail(&curr_dm_list->dml_trails[i]);
}

/*
 *			P R E D I C T O R _ K I L L
 */
void
predictor_kill(void)
{
  RT_FREE_VLIST(&curr_dm_list->dml_p_vlist);
  predictor_init();
}

#define TF_BORD	0.01
#define TF_X	0.14
#define TF_Y	0.07
#define TF_Z	(1.0-0.15)	/* To prevent Z clipping of TF_X */

#define TF_VL( _m, _v ) \
	{ vect_t edgevect_m; \
	MAT4X3VEC( edgevect_m, predictorXv2m, _v ); \
	VADD2( _m, framecenter_m, edgevect_m ); }

/*
 *			P R E D I C T O R _ F R A M E
 *
 *  Draw the frame itself as four polygons:
 *	ABFE, HGCD, EILH, and JFGK.
 *  The streamers will attach at edges AE, BF, GC, and HD.
 *	
 *		D --------------- C
 *		|                 |
 *		H -L-----------K- G
 *		|  |           |  |
 *		|  |           |  |
 *		|  |           |  |
 *		E -I-----------J- F
 *		|                 |
 *		A --------------- B
 */
void
predictor_frame(void)
{
	int	i;
	int	nframes;
	mat_t	predictor;
	mat_t	predictorXv2m;
	point_t	m;		/* model coords */
	point_t	mA,mB,mC,mD,mE,mF,mG,mH,mI,mJ,mK,mL;
	struct bu_list	trail;
	point_t	framecenter_m;
#if 0
	point_t	framecenter_v;
#endif
	point_t	center_m;
	vect_t	delta_v;
	vect_t	right, up;
	vect_t	norm;

	if( view_state->vs_rateflag_rotate == 0 &&
	    view_state->vs_rateflag_tran == 0 &&
	    view_state->vs_rateflag_scale == 0 ){
	  predictor_kill();
	  return;
	}

	RT_FREE_VLIST(&curr_dm_list->dml_p_vlist);

	/* Advance into the future */
	nframes = (int)(mged_variables->mv_predictor_advance / frametime);
	if( nframes < 1 )  nframes = 1;

	/* Build view2model matrix for the future time */
	MAT_IDN( predictor );
	for( i=0; i < nframes; i++ )  {
		bn_mat_mul2( view_state->vs_ModelDelta, predictor );
	}
	bn_mat_mul(predictorXv2m, predictor, view_state->vs_vop->vo_view2model);
	MAT_DELTAS_GET_NEG(center_m, view_state->vs_vop->vo_center);

	MAT4X3PNT( framecenter_m, predictor, center_m );
#if 0
	MAT4X3PNT( framecenter_v, view_state->vs_model2view, framecenter_m );
#endif

	/*
	 * Draw the frame around the point framecenter_v.
	 */

	/* Centering dot */
	VSETALL( delta_v, 0.0 );
	TF_VL( m, delta_v );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, m, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, m, RT_VLIST_LINE_DRAW );

	/* The exterior rectangle */
	VSET( delta_v, -TF_X, -TF_Y, 0.0 );
	TF_VL( mA, delta_v );

	VSET( delta_v,  TF_X, -TF_Y, 0.0 );
	TF_VL( mB, delta_v );

	VSET( delta_v,  TF_X,  TF_Y, 0.0 );
	TF_VL( mC, delta_v );

	VSET( delta_v, -TF_X,  TF_Y, 0.0 );
	TF_VL( mD, delta_v );

	/* The EFGH rectangle */
	VSET( delta_v, -TF_X, -TF_Y+TF_BORD, 0.0 );
	TF_VL( mE, delta_v );

	VSET( delta_v,  TF_X, -TF_Y+TF_BORD, 0.0 );
	TF_VL( mF, delta_v );

	VSET( delta_v,  TF_X,  TF_Y-TF_BORD, 0.0 );
	TF_VL( mG, delta_v );

	VSET( delta_v, -TF_X,  TF_Y-TF_BORD, 0.0 );
	TF_VL( mH, delta_v );

	/* The IJKL rectangle */
	VSET( delta_v, -TF_X+TF_BORD, -TF_Y+TF_BORD, 0.0 );
	TF_VL( mI, delta_v );

	VSET( delta_v,  TF_X-TF_BORD, -TF_Y+TF_BORD, 0.0 );
	TF_VL( mJ, delta_v );

	VSET( delta_v,  TF_X-TF_BORD,  TF_Y-TF_BORD, 0.0 );
	TF_VL( mK, delta_v );

	VSET( delta_v, -TF_X+TF_BORD,  TF_Y-TF_BORD, 0.0 );
	TF_VL( mL, delta_v );

	VSUB2( right, mB, mA );
	VSUB2( up, mD, mA );
	VCROSS( norm, right, up );
	VUNITIZE(norm);

	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mA, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mB, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mF, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mE, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mA, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mE, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mI, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mL, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mH, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mE, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mH, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mG, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mC, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mD, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mH, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mJ, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mF, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mG, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mK, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->dml_p_vlist, mJ, RT_VLIST_POLY_END );

	push_trail( &curr_dm_list->dml_trails[0], mA );
	push_trail( &curr_dm_list->dml_trails[1], mB );
	push_trail( &curr_dm_list->dml_trails[2], mC );
	push_trail( &curr_dm_list->dml_trails[3], mD );

	push_trail( &curr_dm_list->dml_trails[4], mE );
	push_trail( &curr_dm_list->dml_trails[5], mF );
	push_trail( &curr_dm_list->dml_trails[6], mG );
	push_trail( &curr_dm_list->dml_trails[7], mH );

	/* Draw the trails */
	poly_trail( &trail, &curr_dm_list->dml_trails[0], &curr_dm_list->dml_trails[4] );
	BU_LIST_APPEND_LIST(&curr_dm_list->dml_p_vlist, &trail);
	poly_trail( &trail, &curr_dm_list->dml_trails[1], &curr_dm_list->dml_trails[5] );
	BU_LIST_APPEND_LIST(&curr_dm_list->dml_p_vlist, &trail);
	poly_trail( &trail, &curr_dm_list->dml_trails[6], &curr_dm_list->dml_trails[2] );
	BU_LIST_APPEND_LIST(&curr_dm_list->dml_p_vlist, &trail);
	poly_trail( &trail, &curr_dm_list->dml_trails[7], &curr_dm_list->dml_trails[3] );
	BU_LIST_APPEND_LIST(&curr_dm_list->dml_p_vlist, &trail);

	/* Done */
	MAT_IDN( view_state->vs_ModelDelta );
}

/*
 *			P R E D I C T O R _ H O O K
 *
 *  Called from set.c when the predictor variables are modified.
 */
void
predictor_hook(void)
{
  if(mged_variables->mv_predictor > 0)
    predictor_init();
  else
    predictor_kill();

  dirty = 1;
}
@


11.29
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/predictor.c,v 11.28 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.28
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d29 5
a33 1
#include "conf.h"
@


11.27
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.26 2002/08/20 17:08:24 jra Exp $ (BRL)";
d54 1
a54 2
init_trail(tp)
struct trail	*tp;
d66 1
a66 3
push_trail(tp, pt)
struct trail	*tp;
point_t		pt;
d110 1
a110 4
poly_trail(vhead, t1, t2)
struct bu_list	*vhead;
struct trail	*t1;
struct trail	*t2;
d155 1
a155 1
predictor_init()
d167 1
a167 1
predictor_kill()
d201 1
a201 1
predictor_frame()
d357 1
a357 1
predictor_hook()
@


11.26
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1992 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.24 2001/06/05 15:51:42 bparker Exp $ (BRL)";
@


11.26.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/predictor.c,v 11.27 2004/02/02 17:39:34 morrison Exp $ (BRL)";
@


11.26.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.27 2004/02/02 17:39:34 morrison Exp $ (BRL)";
@


11.26.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.26.10.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.26.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.26 2002/08/20 17:08:24 jra Exp $ (BRL)";
d54 2
a55 1
init_trail(struct trail *tp)
d67 3
a69 1
push_trail(struct trail *tp, fastf_t *pt)
d113 4
a116 1
poly_trail(struct bu_list *vhead, struct trail *t1, struct trail *t2)
d161 1
a161 1
predictor_init(void)
d173 1
a173 1
predictor_kill(void)
d207 1
a207 1
predictor_frame(void)
d363 1
a363 1
predictor_hook(void)
@


11.26.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.25
log
@Converted from K&R to ANSI C - RFH
@
text
@d54 2
a55 1
init_trail(struct trail *tp)
d67 3
a69 1
push_trail(struct trail *tp, fastf_t *pt)
d113 4
a116 1
poly_trail(struct bu_list *vhead, struct trail *t1, struct trail *t2)
d161 1
a161 1
predictor_init(void)
d173 1
a173 1
predictor_kill(void)
d207 1
a207 1
predictor_frame(void)
d363 1
a363 1
predictor_hook(void)
@


11.24
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.23 2001/06/01 19:23:25 bparker Exp $ (BRL)";
d54 1
a54 2
init_trail(tp)
struct trail	*tp;
d66 1
a66 3
push_trail(tp, pt)
struct trail	*tp;
point_t		pt;
d110 1
a110 4
poly_trail(vhead, t1, t2)
struct bu_list	*vhead;
struct trail	*t1;
struct trail	*t2;
d155 1
a155 1
predictor_init()
d167 1
a167 1
predictor_kill()
d201 1
a201 1
predictor_frame()
d357 1
a357 1
predictor_hook()
@


11.23
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.22 2001/03/31 01:57:23 morrison Exp $ (BRL)";
a242 1
#ifdef MGED_USE_VIEW_OBJ
a244 4
#else
	bn_mat_mul( predictorXv2m, predictor, view_state->vs_view2model );
	MAT_DELTAS_GET_NEG( center_m, view_state->vs_toViewcenter );
#endif
@


11.22
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.21 2000/08/19 03:10:48 mike Exp $ (BRL)";
d243 4
d248 2
a250 1
	MAT_DELTAS_GET_NEG( center_m, view_state->vs_toViewcenter );
@


11.21
log
@
const RCSid
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.20 1998/11/06 22:32:42 bparker Exp $ (BRL)";
d239 1
a239 1
	bn_mat_idn( predictor );
d354 1
a354 1
	bn_mat_idn( view_state->vs_ModelDelta );
@


11.20
log
@*- use new structures
*- cleanup
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/predictor.c,v 11.19 1998/06/11 19:41:47 bparker Exp $ (BRL)";
@


11.19
log
@*- using floating point literals to initialize floats
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/predictor.c,v 11.18 1997/09/08 18:11:11 bparker Exp $ (BRL)";
d57 2
a58 2
	tp->cur_index = 0;
	tp->nused = 0;
d71 4
a74 4
	VMOVE( tp->pt[tp->cur_index], pt );
	if( tp->cur_index >= tp->nused )  tp->nused++;
	tp->cur_index++;
	if( tp->cur_index >= MAX_TRAIL )  tp->cur_index = 0;
d89 1
a89 1
	int	todo = tp->nused;
d92 2
a93 2
	if( tp->nused <= 0 )  return;
	if( (i = tp->cur_index-1) < 0 )  i = tp->nused-1;
d95 2
a96 2
		if( todo == tp->nused )  {
			RT_ADD_VLIST( vhead, tp->pt[i], RT_VLIST_LINE_MOVE );
d98 1
a98 1
			RT_ADD_VLIST( vhead, tp->pt[i], RT_VLIST_LINE_DRAW );
d100 1
a100 1
		if( (--i) < 0 )  i = tp->nused-1;
d119 1
a119 1
	int	todo = t1->nused;
d124 1
a124 1
	if( t2->nused < todo )  todo = t2->nused;
d127 1
a127 1
	if( t1->nused <= 0 || t1->nused <= 0 )  return;
d129 2
a130 2
	if( (i1 = t1->cur_index-1) < 0 )  i1 = t1->nused-1;
	if( (i2 = t2->cur_index-1) < 0 )  i2 = t2->nused-1;
d133 4
a136 4
	s1 = t1->pt[i1];
	s2 = t2->pt[i2];
	if( (--i1) < 0 )  i1 = t1->nused-1;
	if( (--i2) < 0 )  i2 = t2->nused-1;
d140 1
a140 1
		/* Go from s1 to s2 to t2->pt[i2] to t1->pt[i1] */
d142 1
a142 1
		VSUB2( right, t1->pt[i1], s1 );
d148 2
a149 2
		RT_ADD_VLIST( vhead, t2->pt[i2], RT_VLIST_POLY_DRAW );
		RT_ADD_VLIST( vhead, t1->pt[i1], RT_VLIST_POLY_DRAW );
d152 2
a153 2
		s1 = t1->pt[i1];
		s2 = t2->pt[i2];
d155 2
a156 2
		if( (--i1) < 0 )  i1 = t1->nused-1;
		if( (--i2) < 0 )  i2 = t2->nused-1;
d166 1
a166 1
    init_trail(&curr_dm_list->trails[i]);
d175 1
a175 1
  RT_FREE_VLIST(&curr_dm_list->p_vlist);
d225 3
a227 1
	if( rateflag_rotate == 0 && rateflag_tran == 0 && rateflag_scale == 0 ){
d232 1
a232 1
	RT_FREE_VLIST(&curr_dm_list->p_vlist);
d235 1
a235 1
	nframes = (int)(mged_variables->predictor_advance / frametime);
d241 1
a241 1
		bn_mat_mul2( ModelDelta, predictor );
d243 1
a243 1
	bn_mat_mul( predictorXv2m, predictor, view2model );
d245 1
a245 1
	MAT_DELTAS_GET_NEG( center_m, toViewcenter );
d248 1
a248 1
	MAT4X3PNT( framecenter_v, model2view, framecenter_m );
d258 2
a259 2
	RT_ADD_VLIST( &curr_dm_list->p_vlist, m, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, m, RT_VLIST_LINE_DRAW );
d305 37
a341 37
	RT_ADD_VLIST( &curr_dm_list->p_vlist, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mA, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mB, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mF, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mE, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mA, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &curr_dm_list->p_vlist, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mE, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mI, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mL, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mH, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mE, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &curr_dm_list->p_vlist, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mH, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mG, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mC, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mD, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mH, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &curr_dm_list->p_vlist, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mJ, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mF, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mG, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mK, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &curr_dm_list->p_vlist, mJ, RT_VLIST_POLY_END );

	push_trail( &curr_dm_list->trails[0], mA );
	push_trail( &curr_dm_list->trails[1], mB );
	push_trail( &curr_dm_list->trails[2], mC );
	push_trail( &curr_dm_list->trails[3], mD );

	push_trail( &curr_dm_list->trails[4], mE );
	push_trail( &curr_dm_list->trails[5], mF );
	push_trail( &curr_dm_list->trails[6], mG );
	push_trail( &curr_dm_list->trails[7], mH );
d344 8
a351 8
	poly_trail( &trail, &curr_dm_list->trails[0], &curr_dm_list->trails[4] );
	BU_LIST_APPEND_LIST(&curr_dm_list->p_vlist, &trail);
	poly_trail( &trail, &curr_dm_list->trails[1], &curr_dm_list->trails[5] );
	BU_LIST_APPEND_LIST(&curr_dm_list->p_vlist, &trail);
	poly_trail( &trail, &curr_dm_list->trails[6], &curr_dm_list->trails[2] );
	BU_LIST_APPEND_LIST(&curr_dm_list->p_vlist, &trail);
	poly_trail( &trail, &curr_dm_list->trails[7], &curr_dm_list->trails[3] );
	BU_LIST_APPEND_LIST(&curr_dm_list->p_vlist, &trail);
d354 1
a354 1
	bn_mat_idn( ModelDelta );
d365 1
a365 1
  if(mged_variables->predictor > 0)
@


11.18
log
@*- predictor variables are now members of "struct dm_list"
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.17 1997/09/03 14:18:33 bparker Exp bparker $ (BRL)";
d254 1
a254 1
	VSETALL( delta_v, 0 );
d260 1
a260 1
	VSET( delta_v, -TF_X, -TF_Y, 0 );
d263 1
a263 1
	VSET( delta_v,  TF_X, -TF_Y, 0 );
d266 1
a266 1
	VSET( delta_v,  TF_X,  TF_Y, 0 );
d269 1
a269 1
	VSET( delta_v, -TF_X,  TF_Y, 0 );
d273 1
a273 1
	VSET( delta_v, -TF_X, -TF_Y+TF_BORD, 0 );
d276 1
a276 1
	VSET( delta_v,  TF_X, -TF_Y+TF_BORD, 0 );
d279 1
a279 1
	VSET( delta_v,  TF_X,  TF_Y-TF_BORD, 0 );
d282 1
a282 1
	VSET( delta_v, -TF_X,  TF_Y-TF_BORD, 0 );
d286 1
a286 1
	VSET( delta_v, -TF_X+TF_BORD, -TF_Y+TF_BORD, 0 );
d289 1
a289 1
	VSET( delta_v,  TF_X-TF_BORD, -TF_Y+TF_BORD, 0 );
d292 1
a292 1
	VSET( delta_v,  TF_X-TF_BORD,  TF_Y-TF_BORD, 0 );
d295 1
a295 1
	VSET( delta_v, -TF_X+TF_BORD,  TF_Y-TF_BORD, 0 );
@


11.17
log
@mods to implement new display lists
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.16 1997/07/25 20:59:09 bparker Exp bparker $ (BRL)";
a49 9
extern mat_t	ModelDelta;		/* Changed to Viewrot this frame */

#define MAX_TRAIL	32
struct trail {
	int	cur_index;	/* index of first free entry */
	int	nused;		/* max index in use */
	point_t	pt[MAX_TRAIL];
};

d160 4
a163 2
static struct trail	tA, tB, tC, tD;
static struct trail	tE, tF, tG, tH;
d165 3
a167 1
#define PREDICTOR_NAME	"_PREDIC_FRAME_"
a170 2
 *
 *  Don't use mged "kill" command, just use "d".
d175 2
a176 29
  char *av[3];

  av[0] = "d";
  av[2] = NULL;

  av[1] = PREDICTOR_NAME;
  (void)f_erase_all((ClientData)NULL, interp, 2, av);

  av[1] = "_PREDIC_TRAIL_LL_";
  (void)f_erase_all((ClientData)NULL, interp, 2, av);

  av[1] = "_PREDIC_TRAIL_LR_";
  (void)f_erase_all((ClientData)NULL, interp, 2, av);

  av[1] = "_PREDIC_TRAIL_UR_";
  (void)f_erase_all((ClientData)NULL, interp, 2, av);

  av[1] = "_PREDIC_TRAIL_UL_";
  (void)f_erase_all((ClientData)NULL, interp, 2, av);

  init_trail( &tA );
  init_trail( &tB );
  init_trail( &tC );
  init_trail( &tD );

  init_trail( &tE );
  init_trail( &tF );
  init_trail( &tG );
  init_trail( &tH );
a214 1
	struct bu_list	vhead;
a223 2
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
d225 2
a226 1
	if(dbip == DBI_NULL)
d228 1
d230 1
a230 8
	if( rateflag_rotate == 0 && rateflag_tran == 0 && rateflag_scale == 0 )  {
		/* If no motion, and predictor is drawn, get rid of it */
		if( db_lookup( dbip, PREDICTOR_NAME, LOOKUP_QUIET ) != DIR_NULL )  {
			predictor_kill();
			dmaflag = 1;
		}
		return;
	}
d233 1
a233 1
	nframes = (int)(mged_variables.predictor_advance / frametime);
a251 1
	BU_LIST_INIT( &vhead );
d256 2
a257 2
	RT_ADD_VLIST( &vhead, m, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( &vhead, m, RT_VLIST_LINE_DRAW );
d303 37
a339 65
#if 0
	RT_ADD_VLIST( &vhead, mA, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( &vhead, mB, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mF, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mE, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mA, RT_VLIST_LINE_DRAW );

	RT_ADD_VLIST( &vhead, mE, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( &vhead, mI, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mL, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mH, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mE, RT_VLIST_LINE_DRAW );

	RT_ADD_VLIST( &vhead, mH, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( &vhead, mG, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mC, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mD, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mH, RT_VLIST_LINE_DRAW );

	RT_ADD_VLIST( &vhead, mJ, RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( &vhead, mF, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mG, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mK, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( &vhead, mJ, RT_VLIST_LINE_DRAW );
#else
	RT_ADD_VLIST( &vhead, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &vhead, mA, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &vhead, mB, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mF, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mE, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mA, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &vhead, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &vhead, mE, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &vhead, mI, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mL, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mH, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mE, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &vhead, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &vhead, mH, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &vhead, mG, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mC, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mD, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mH, RT_VLIST_POLY_END );

	RT_ADD_VLIST( &vhead, norm, RT_VLIST_POLY_START );
	RT_ADD_VLIST( &vhead, mJ, RT_VLIST_POLY_MOVE );
	RT_ADD_VLIST( &vhead, mF, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mG, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mK, RT_VLIST_POLY_DRAW );
	RT_ADD_VLIST( &vhead, mJ, RT_VLIST_POLY_END );
#endif

	invent_solid( PREDICTOR_NAME, &vhead, 0x00FFFFFFL, 0 );

	push_trail( &tA, mA );
	push_trail( &tB, mB );
	push_trail( &tC, mC );
	push_trail( &tD, mD );

	push_trail( &tE, mE );
	push_trail( &tF, mF );
	push_trail( &tG, mG );
	push_trail( &tH, mH );
d342 8
a349 16

#if 0
	draw_trail( &trail, &tA );
	invent_solid( "_PREDIC_TRAIL_LL_", &trail, 0x00FF00FFL, 0 );

	draw_trail( &trail, &tB );
	invent_solid( "_PREDIC_TRAIL_LR_", &trail, 0x0000FFFFL, 0 );

	draw_trail( &trail, &tC );
	invent_solid( "_PREDIC_TRAIL_UR_", &trail, 0x00FF00FFL, 0 );

	draw_trail( &trail, &tD );
	invent_solid( "_PREDIC_TRAIL_UL_", &trail, 0x0000FFFFL, 0 );
#else
	poly_trail( &trail, &tA, &tE );
	invent_solid( "_PREDIC_TRAIL_LL_", &trail, 0x00FF00FFL, 0 );
a350 21
	poly_trail( &trail, &tB, &tF );
	invent_solid( "_PREDIC_TRAIL_LR_", &trail, 0x0000FFFFL, 0 );

	poly_trail( &trail, &tG, &tC );
	invent_solid( "_PREDIC_TRAIL_UR_", &trail, 0x00FF00FFL, 0 );

	poly_trail( &trail, &tH, &tD );
	invent_solid( "_PREDIC_TRAIL_UL_", &trail, 0x0000FFFFL, 0 );
#endif

#ifdef DO_SINGLE_DISPLAY_LIST
	save_dmlp = curr_dm_list;
	for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
	  if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
	    curr_dm_list = dmlp;
	    createDList(&HeadSolid);
	  }
	}
	curr_dm_list = save_dmlp;
#endif

d363 6
a368 7
	if( mged_variables.predictor > 0 )  {
		/* Allocate storage? */
	} else {
		/* Release storage? */
		predictor_kill();
	}
	dmaflag = 1;
@


11.16
log
@*** empty log message ***
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.15 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d46 1
d259 2
d438 11
@


11.15
log
@mods to run without a database
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.14 1997/05/27 12:04:42 jra Exp bparker $ (BRL)";
d262 1
a262 1
	if( rateflag_rotate == 0 && rateflag_slew == 0 && rateflag_zoom == 0 )  {
@


11.14
log
@fixed names used in predictor_kill().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.13 1997/04/14 12:30:35 bparker Exp jra $ (BRL)";
d258 3
@


11.13
log
@now calling f_erase_all()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.12 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d189 1
a189 1
  av[1] = "d _PREDIC_TRAIL_LL_";
d192 1
a192 1
  av[1] = "d _PREDIC_TRAIL_LR_";
d195 1
a195 1
  av[1] = "d _PREDIC_TRAIL_UR_";
d198 1
a198 1
  av[1] = "d _PREDIC_TRAIL_UL_";
@


11.12
log
@checkin for weekend
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.11 1997/01/02 19:40:36 bparker Exp bparker $ (BRL)";
d46 1
d187 1
a187 1
  (void)f_delobj((ClientData)NULL, interp, 2, av);
d190 1
a190 1
  (void)f_delobj((ClientData)NULL, interp, 2, av);
d193 1
a193 1
  (void)f_delobj((ClientData)NULL, interp, 2, av);
d196 1
a196 1
  (void)f_delobj((ClientData)NULL, interp, 2, av);
d199 1
a199 1
  (void)f_delobj((ClientData)NULL, interp, 2, av);
@


11.11
log
@mods to use libbn and libbu
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.10 1996/10/03 20:51:39 bparker Exp bparker $ (BRL)";
a47 1
extern double	frametime;		/* time needed to draw last frame */
@


11.10
log
@get rid of extra cmdline() uses
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.9 1996/09/23 18:23:21 bparker Exp bparker $ (BRL)";
d38 1
d41 1
d43 1
a43 1
#include "bu.h"
d273 1
a273 1
	mat_idn( predictor );
d275 1
a275 1
		mat_mul2( ModelDelta, predictor );
d277 1
a277 1
	mat_mul( predictorXv2m, predictor, view2model );
d435 1
a435 1
	mat_idn( ModelDelta );
@


11.9
log
@changed dm.h to mged_dm.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.8 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d179 1
a179 1
	struct bu_vls	str;
d181 2
a182 2
	bu_vls_init( &str );
	bu_vls_printf( &str, "d %s\n", PREDICTOR_NAME );
d184 2
a185 1
	(void)cmdline( &str, FALSE );
d187 2
a188 1
	bu_vls_trunc( &str, 0 );
d190 2
a191 4
	bu_vls_strcat( &str, "d _PREDIC_TRAIL_LL_\n" );
	bu_vls_strcat( &str, "d _PREDIC_TRAIL_LR_\n" );
	bu_vls_strcat( &str, "d _PREDIC_TRAIL_UR_\n" );
	bu_vls_strcat( &str, "d _PREDIC_TRAIL_UL_\n" );
d193 2
a194 1
        (void)cmdline( &str, FALSE );
d196 2
a197 1
	bu_vls_free( &str );
d199 4
a202 4
	init_trail( &tA );
	init_trail( &tB );
	init_trail( &tC );
	init_trail( &tD );
d204 4
a207 4
	init_trail( &tE );
	init_trail( &tF );
	init_trail( &tG );
	init_trail( &tH );
@


11.8
log
@rt_list ---> bu_list
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.7 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d44 1
a44 1
#include "./dm.h"
@


11.7
log
@now using libbu
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.6 1996/03/22 18:33:18 bparker Exp bparker $ (BRL)";
d41 1
a41 1
#include "rtstring.h"
d91 1
a91 1
struct rt_list	*vhead;
d97 1
a97 1
	RT_LIST_INIT( vhead );
d120 1
a120 1
struct rt_list	*vhead;
d132 1
a132 1
	RT_LIST_INIT( vhead );
d244 2
a245 2
	struct rt_list	vhead;
	struct rt_list	trail;
d284 1
a284 1
	RT_LIST_INIT( &vhead );
@


11.6
log
@cleanup
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.5 1995/12/27 22:34:52 bparker Exp bparker $ (BRL)";
d179 1
a179 1
	struct rt_vls	str;
d181 2
a182 2
	rt_vls_init( &str );
	rt_vls_printf( &str, "d %s\n", PREDICTOR_NAME );
d186 1
a186 1
	rt_vls_trunc( &str, 0 );
d188 4
a191 4
	rt_vls_strcat( &str, "d _PREDIC_TRAIL_LL_\n" );
	rt_vls_strcat( &str, "d _PREDIC_TRAIL_LR_\n" );
	rt_vls_strcat( &str, "d _PREDIC_TRAIL_UR_\n" );
	rt_vls_strcat( &str, "d _PREDIC_TRAIL_UL_\n" );
d195 1
a195 1
	rt_vls_free( &str );
@


11.5
log
@*** empty log message ***
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.4 1995/07/25 17:49:01 gdurf Exp bparker $ (BRL)";
a43 1
#ifdef MULTI_ATTACH
a44 1
#endif
@


11.4
log
@2-arg cmdline()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.3 1995/06/20 13:14:29 gdurf Exp gdurf $ (BRL)";
d44 3
@


11.3
log
@Changed unexpandable wildcard
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 11.2 1995/01/17 13:04:53 bparker Exp gdurf $ (BRL)";
d183 1
a183 5
#ifdef XMGED
	(void)cmdline( &str, False );
#else
	(void)cmdline( &str );
#endif
d192 1
a192 5
#ifdef XMGED
        (void)cmdline( &str, False );
#else
	(void)cmdline( &str );
#endif
@


11.2
log
@merging xmged sources
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/predictor.c,v 11.2 95/01/17 11:44:15 bparker Exp $ (BRL)";
d191 4
a194 1
	rt_vls_strcat( &str, "d _PREDIC_TRAIL_*\n" );
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 1.7 94/11/08 04:18:24 mike Exp $ (BRL)";
d182 4
d187 2
d192 4
d197 2
@


1.7
log
@Irix 6
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 1.6 94/08/09 18:15:55 gdurf Exp Locker: mike $ (BRL)";
@


1.6
log
@Factored ifdefs
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 1.5 1992/11/11 00:26:18 mike Exp gdurf $ (BRL)";
d82 1
d108 1
a233 1
	point_t	v;		/* view coords */
d239 1
d241 1
d269 1
d271 1
@


1.5
log
@Don't use mged "kill" command, use "d" to drop from view.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 1.4 92/06/05 15:19:35 mike Exp Locker: mike $ (BRL)";
d29 2
d32 3
a34 1
#ifdef BSD
a35 2
#else
#include <string.h>
@


1.4
log
@Added parameter to nmg_vlblock_anim_upcall
(mged_vlblock_anim_upcall_handler) and invent_solid() to indicate don't
copy vlist, steal them, which matches current usage.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 1.3 92/04/04 01:37:52 mike Exp Locker: mike $ (BRL)";
d168 2
d177 1
a177 1
	rt_vls_printf( &str, "kill %s\n", PREDICTOR_NAME );
d181 1
a181 1
	rt_vls_strcat( &str, "kill _PREDIC_TRAIL_*\n" );
@


1.3
log
@Tails drawn as polygons too.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 1.2 92/04/04 01:18:00 mike Exp Locker: mike $ (BRL)";
d373 1
a373 1
	invent_solid( PREDICTOR_NAME, &vhead, 0x00FFFFFFL );
d389 1
a389 1
	invent_solid( "_PREDIC_TRAIL_LL_", &trail, 0x00FF00FFL );
d392 1
a392 1
	invent_solid( "_PREDIC_TRAIL_LR_", &trail, 0x0000FFFFL );
d395 1
a395 1
	invent_solid( "_PREDIC_TRAIL_UR_", &trail, 0x00FF00FFL );
d398 1
a398 1
	invent_solid( "_PREDIC_TRAIL_UL_", &trail, 0x0000FFFFL );
d401 1
a401 1
	invent_solid( "_PREDIC_TRAIL_LL_", &trail, 0x00FF00FFL );
d404 1
a404 1
	invent_solid( "_PREDIC_TRAIL_LR_", &trail, 0x0000FFFFL );
d407 1
a407 1
	invent_solid( "_PREDIC_TRAIL_UR_", &trail, 0x00FF00FFL );
d410 1
a410 1
	invent_solid( "_PREDIC_TRAIL_UL_", &trail, 0x0000FFFFL );
@


1.2
log
@Predictor now drawn with polygons
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/predictor.c,v 1.1 92/04/04 01:11:07 mike Exp Locker: mike $ (BRL)";
d83 1
a83 1
 *  Draw from the most recently added point, backwards.
d106 55
d387 1
d399 13
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d182 2
d259 6
d288 29
@
