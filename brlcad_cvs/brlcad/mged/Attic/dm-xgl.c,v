head	11.6;
access;
symbols
	rel-4-5:11.5
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.6
date	98.10.23.15.12.08;	author bparker;	state dead;
branches;
next	11.5;

11.5
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.06.16.19.54.58;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.06.15.20.36.39;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.00;	author mike;	state Rel4_4;
branches;
next	10.19;

10.19
date	95.01.03.21.20.48;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	94.12.30.04.06.23;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.12.29.16.17.22;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.12.24.01.05.26;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.12.23.18.09.29;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.12.23.16.58.34;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.12.23.16.56.27;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.12.20.22.02.38;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.12.16.19.36.23;	author gdurf;	state Exp;
branches;
next	10.10;

10.10
date	94.12.01.23.06.57;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.11.30.15.45.42;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.10.14.17.07.07;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.10.14.16.06.34;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.09.07.13.17.54;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.08.10.21.43.00;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.09.15.17.44;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.06.01.12.04.21;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	91.10.29.17.38.24;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.36;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.10.10.02.45.37;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.10.10.00.48.28;	author mike;	state Exp;
branches;
next	;


desc
@ An XGL interface for MGED on the Sun, with OpenWindows 2.0
@


11.6
log
@*- moved old display managers to dm_old
@
text
@/*
 *			D M - X G L . C
 *
 *  An XGL 3.X interface for MGED for Sun Solaris 2.X systems.
 *
 *  Authors -
 *	Original XGL 2.0/OpenWindows 2.0:
 *		Saul Wold
 *		John Cummings  
 *	XGL 3.X/OpenWindows 3.X support and significant other enhancements:
 *		James D. Fiori
 *
 *  Source -
 *	Sun Microsystems, Inc.  
 *	Southern Area Special Projects Group
 *	6716 Alexander Bell Drive, Suite 200
 *	Columbia, MD 21046
 *  
 *  Copyright Notice -
 *	Copyright (c) 1994 Sun Microsystems, Inc. - All Rights Reserved.
 *
 *	Permission is hereby granted, without written agreement and without
 *	license or royalty fees, to use, copy, modify, and distribute this
 *	software and its documentation for any purpose, provided that the
 *	above copyright notice and the following two paragraphs appear in
 *	all copies of this software.
 *
 *	IN NO EVENT SHALL SUN MICROSYSTEMS INC. BE LIABLE TO ANY PARTY FOR
 *	DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
 *	OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF SUN
 *	MICROSYSTEMS INC. HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	SUN MICROSYSTEMS INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 *	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 *	AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER
 *	IS ON AN "AS IS" BASIS, AND SUN MICROSYSTEMS INC. HAS NO OBLIGATION TO
 *	PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *  
 * History -
 *	Modified 12/94 to support XGL 3.X by Sun Microsystems Computer Company
 *		XView code stripped out for the following reasons:
 *			XView is a 'dead' product
 *			Provide similar interface to X and SGI versions of mged
 *		Uses dm-X event processing code. Knob keys (x,y,z,X,Y,Z) were 
 *		 	fixed to perform "knob key .1"). Also, using the
 *			Control key with the knob keys performs "knob key -.1".
 *		Polygon surface color-fill support
 *		SunDials support
 *			The dials can be re-set (ie. "knob zero") by pressing 
 *			the '0' key.
 *		Z-Buffering (done in h/w for SX, ZX, s/w for others)
 *		24-bit color (for SX, ZX, S24)
 *		Lighting, Depth Cueing (for SX, ZX, S24)
 *		Anti-alias support for vectors (done in h/w for SX, ZX, s/w 
 *						for others)
 *		Double-Buffering Support:
 *			Performed in Hardware on TGX, SX, ZX
 *			Performed in Software: when using PEX
 *			Performed via colormap double-buffering on GX
 *			No double buffering on S24 (unless PEX is being used as
 *				is the case when running remotely)
 *		Function Key Support:
 *			F1 - Depth Cue Toggle
 *			F2 - Z-clip Toggle
 *			F3 - Perspective Toggle (currently not functional)
 *			F4 - Z-Buffer Toggle
 *			F5 - Lighting Toggle
 *			F6 - Perspective Angle Change (30, 45, 60, 90) 
 *						(currently not functional)
 *			F7 - Faceplate Toggle
 *			F8 - Line Anti-alias Toggle
 *
 * 	Known Problems:
 *		monochrome is not supported
 *		The GX amd TGX frame buffers are currently not being used in 
 *		DGA (Direct Graphics Access) mode. PEX is used instead.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-xgl.c,v 11.5 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
#endif

/*
 *	Header files
 */
#include "conf.h"

#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <sys/types.h>
#include <string.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"

#include "./ged.h"
#include "./dm.h"
#include "./solid.h"

#include <xgl/xgl.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/keysym.h>
#include <X11/Sunkeysym.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XInput.h>

/*
 *	Degug macro
 */
				/* currently, only two debug "levels"	*/
				/* are recognized, ON and OFF;  may be	*/
				/* toggled by mged "redebug" command.	*/
static int		XGL_debug_level = 0;
#define	DPRINTF(S)	if(XGL_debug_level) bu_log(S)

/*
 *	NON-dm functions
 */
						/* Initialization	*/
static void		init_globals();			/* init globals */
static int		init_check_buffering();		/* parent setup */
static void		XGL_object_init();	
static void		init_sundials(), reset_sundials();
static void		handle_sundials_event(), reposition_light();
static void		setcolortables();		/* init colortables */

/*
 *	dm (display manager) package interface
 */
extern struct device_values	dm_values;	/* values read from devices */

extern void color_soltab();

#define PLOTBOUND       4000.0  /* Max magnification in Rot matrix */

int		XGL_open();
void		XGL_close();
MGED_EXTERN(void	XGL_input, (fd_set *input, int noblock) );
void		XGL_prolog(), XGL_epilog();
void		XGL_normal(), XGL_newrot();
void		XGL_update();
void		XGL_puts(), XGL_2d_line(), XGL_light();
int		XGL_object(), XGL_dm();
unsigned	XGL_cvtvecs(), XGL_load();
void		XGL_statechange(), XGL_viewchange(), XGL_colorchange();
void		XGL_window(), XGL_debug();

struct dm dm_XGL = {
	XGL_open,
	XGL_close,
	XGL_input,
	XGL_prolog, XGL_epilog,
	XGL_normal, XGL_newrot,
	XGL_update,
	XGL_puts, XGL_2d_line,
	XGL_light,
	XGL_object,
	XGL_cvtvecs, XGL_load,
	XGL_statechange,
	XGL_viewchange,
	XGL_colorchange,
	XGL_window, XGL_debug,
	0,				/* no displaylist */
	0,				/* multi-window */
	PLOTBOUND,
	"xgl", "XGL (X11)",
	0,
	XGL_dm,
};


/* X11 variables */
static Display  *display;               /* X display pointer */
static Window   xwin;                   /* X window we draw in */
static int	screen_num;		/* screen number */
static Atom	wm_protocols_atom;
static Atom	wm_delete_win_atom;
static unsigned char sundials_ev_type;


/*
 *	Global variables
 */
					/* miscellaneous */
static int      	height, width;		/* Maintain window dimensions 
						 * here */
static int		no_2d_flag;		/* ON - no display of 2d ctx */

					/* XGL		*/
static Xgl_sys_state	sys_state;		/* system state */
static Xgl_X_window	xgl_x_win;		/* x window */
static Xgl_obj_desc	win_desc;
static Xgl_win_ras	ras;			/* window raster */
static Xgl_3d_ctx	ctx_3d;			/* 3d context (for objects) */
static Xgl_2d_ctx	ctx_2d;			/* 2d context (text & lines) */
static Xgl_trans	trans;			/* transformation */

static Xgl_trans        itrans;

/*
 * Macro for flushing 3D polylines and polygons.
 */
#define Flush3D 	XGL_object_flush 

/*
 * Color Map info
 */
					/* XGL - color management */
static Xgl_cmap		cmap_A, cmap_B;		/* colormaps */
static Xgl_color_list	cmap_info_A, cmap_info_B; /* color lists */
static Xgl_color	color_table_A[256];	/* color tables */
static Xgl_color	color_table_B[256];
static Xgl_color_type	color_type;		/* INDEX or RGB */
static Xgl_color_index	last_color_index = 0xffffffff;

static int		dbuffering;		/* double buffering? */
static int		maxcolors;		/* max number of colors */
static int		slotsused;		/* used cmap index slots */
static int		colortablesize;		/* size of cmap index */
static int		current_buffer_is_A;	/* flag for cmap dbuffering */

static int      	no_faceplate = 0;

#define cmap		cmap_A			/* for clarity */
#define cmap_info	cmap_info_A
#define color_table	color_table_A

#define XGL_BUF_A	0	/* Used for double buffering */
#define XGL_BUF_B	1

#define	NO_DBUFF	0x0			/* OR'ed for value found */
#define	CMAP8_DBUFF	0x1				/* in dbuffering */
#define CMAP16_DBUFF	0x2
#define	AB_DBUFF	0x4

#define OPTION_ZERO	'0'			/* monochrome option */
#define OPTION_ONE	'1'			/* no dbuffering option */
#define OPTION_TWO	'2'			/* 8 color dbuffering */
#define OPTION_THREE	'3'			/* 16 color dbuffering */

#define DEFAULT_DB	OPTION_TWO		/* default type of dbuffering */
#define MONOCHROME	(colortablesize == 2)	/* monochrome frame buffer */

#define COLORSHIFT	(dbuffering + 2)	/* shift by COLORSHIFT */
#define CMAPDBUFFERING	(dbuffering & 0x3)	/* colormap dbuffering? */
#define COLORINDEX(ci)	(CMAPDBUFFERING ? (ci | ci << COLORSHIFT) : ci)
#define CMAP_MASK_A	(~(-1 << COLORSHIFT))	/* A BUFFER mask */
#define CMAP_MASK_B	(CMAP_MASK_A << COLORSHIFT) /* B BUFFER mask */

static Xgl_color_rgb BLACK	= {0.0, 0.0, 0.0 }; /* the 5 DM_ colors */
static Xgl_color_rgb RED	= {1.0, 0.0, 0.0 };
static Xgl_color_rgb BLUE	= {0.0, 0.0, 1.0 };
static Xgl_color_rgb YELLOW	= {1.0, 1.0, 0.0 };
static Xgl_color_rgb WHITE	= {1.0, 1.0, 1.0 };

#define MINSLOTS	5			/* number of DM_ colors */
#define	DEFAULT_COLOR	DM_YELLOW		/* default color */
#define SetColor(c, i) if (color_type == XGL_COLOR_INDEX) \
                                c.index = COLORINDEX(i); \
                       else \
                                c.rgb = color_table[i].rgb;

/* Light Info */
#define NUM_LIGHTS 2
static Xgl_light        lights[NUM_LIGHTS];
static Xgl_boolean      light_switches[NUM_LIGHTS];
static int		lighting_on = 0;	/* 1 = lighting is on */
static int		dcue_on = 0;		/* 1 = depth-cueing is on */
static int		zbuff_on = 0;		/* 1 = Z-buffer is on */
static int		zclip_on = 0;		/* 1 = Z is clipped */
static int		anti_alias_on = 0;	/* 1 = line A-A is on */
static void		init_lights();

/*
 * Flag that indicates what type of frame buffer we are running.
 */

typedef enum {
	FB_GX,
	FB_TGX,
	FB_SX,
	FB_ZX,
	FB_OTHER
} fb_type;

static fb_type frame_buffer_type = FB_OTHER;

static int X_setup( Display **, int *, Window *, int *, int *);
static int XGL_setup();
static void XGL_object_flush();
static void process_func_key(KeySym);
static void toggle_faceplate();
static void checkevents();
static void display_buff ();

#if 0	/* debug only */
static void start_ts();
static int stop_ts();
static int getms(struct timeval , struct timeval );
#endif

/*
 * Function Key Function Structures
 */
/* 'Borrowed' from dm-4d.c */
static int perspective_mode = 0;        /* Perspective flag */
static int perspective_table[] = {
        30, 45, 60, 90 };
#define NUM_PERSPECTIVE_ANGLES (sizeof (perspective_table)/sizeof(int))
static int perspective_angle = NUM_PERSPECTIVE_ANGLES - 1;
		        /* Angle of perspective */
	


/************************************************************************
 *									*
 * 	DM PACKAGE INTERFACE FUNCTIONS					*
 *									*
 ************************************************************************/

/*
 *	XGL_open
 */
XGL_open()
{

	DPRINTF("XGL_open\n");
	/*
	 * First thing we have to do is create an X11 window to pass to XGL
	 */
	init_globals();			/* initialize global variables */

	/* Init the X11 environment */
	if (X_setup(&display, &screen_num, &xwin, &width, &height))
		return (1);		/* Error */

	/* Init the XGL environment */
	if (XGL_setup())
		return (1);		/* Error */

	/* Init some data that XGL_object() needs */
	XGL_object_init();

	/* Set up for SunDials using the X Input Extensions */
	init_sundials();

	return (0);
}

/*
 * 	XGL_close
 */
void
XGL_close()
{
	DPRINTF("XGL_close\n");

	xgl_object_destroy (ctx_2d);
	xgl_object_destroy (ctx_3d);
	xgl_close(sys_state);
        XCloseDisplay( display );
	return;
}

/*
 *	XGL_prolog
 */
void
XGL_prolog()
{
	DPRINTF("XGL_prolog\n");

	if(!dmaflag || dbuffering)
		return;

    /* If we are NOT doing any double buffering, erase the window	*/
    /* BEFORE we begin to do any drawing.				*/
	xgl_context_new_frame(ctx_3d);
	xgl_context_new_frame(ctx_2d);

	return;
}

/*
 *	XGL_epilog
 */
void
XGL_epilog()
{

	DPRINTF("XGL_epilog\n");

	Flush3D();
	/*
	 * Place a "centering dot" in the center of the screen 
	 */
	XGL_2d_line( 0, 0, 0, 0, 0 );

	display_buff();	/* Display the screen and clear the hidden buffer */
	return;
}


static void
apply_matrix(mat_t mat)
{
	int i;
        Xgl_pt               	pt;
        Xgl_pt_d3d           	pt_d3d;
	double			w;
	static Xgl_matrix_d3d	xgl_mat;

	for (i = 0; i < 16; i++)
		xgl_mat[i/4][i%4] = (fabs(mat[i]) < 1.0e-15) ? 0.0 : mat[i];

	/*
	 * Write the matrix into the transform, then transpose it 
	 */
	xgl_transform_write_specific (trans, xgl_mat, NULL);
        xgl_transform_transpose(trans, trans);

	reposition_light(); /* reposition light source */
}

/*
 *	XGL_newrot
 */
void
XGL_newrot(mat)
mat_t mat;
{
	DPRINTF("XGL_newrot\n");

	apply_matrix(mat);
	return;
}

/*
 * 	XGL_object
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  If sp is null, it is being called from within this .c file
 *  for purposes of flushing ONLY!
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 *
 *  We use four Xgl_pt_list structures, one for solid polylines, one
 *  for dashed polylines, one for polygons without vertex normals, and one
 *  for polygons with vertex normals. The reason for much of this
 *  complexity is we buffer up polylines to enhance performance. We could have
 *  just drawn i polyline/solid, but with some Sun frame buffers, that's much
 *  slower than buffering up many.
 */
/*  First, define the array of point structures for regular lines, dashed lines,
 *  and polygons. Note that we use the 'flag' point type for polylines, since
 *  we need that to indicate whether or not to draw the line. The flag is only
 *  set for LINE_EDGE commands.
 */
#define MAX_PL_PTS	100000
static Xgl_pt_flag_f3d 	pl_solid_pts[MAX_PL_PTS];
static Xgl_pt_flag_f3d 	pl_dash_pts[MAX_PL_PTS];

#define MAX_PG_PTS	12
static Xgl_pt_f3d      	pg_pts[MAX_PG_PTS];		/* no vertext normals */
static Xgl_pt_normal_f3d pg_vnorm_pts[MAX_PG_PTS];	/* w/ vertext normals */

/* Next define the point list structures, one for each type. */
static Xgl_pt_list pl_solid_list = 	{XGL_PT_FLAG_F3D, 0, 0, 0, 0};
static Xgl_pt_list pl_dash_list = 	{XGL_PT_FLAG_F3D, 0, 0, 0, 0};
static Xgl_pt_list pg_list = 	  	{XGL_PT_F3D, 0, 0, 0, 0};
static Xgl_pt_list pg_vnorm_list = 	{XGL_PT_NORMAL_F3D, 0, 0, 0, 0};

/* Polygon data */


static Xgl_pt_f3d      	 *pg_ptr = pg_pts;	/* ptr into polygon point arr*/
static Xgl_pt_normal_f3d *pg_vnorm_ptr = pg_vnorm_pts;	/* ptr into polygon 
						           point arr w/ vertex
							   normals */
Xgl_facet_list		facet_list;		/* facet (contains color and
						   normal) */
Xgl_color_normal_facet	cn_facet;


/*
 * Macros for flushing the polyline and polygon lists
 */
 
#define FlushPlList() \
	if (pl_solid_list.num_pts) {\
		xgl_object_set(ctx_3d,XGL_CTX_LINE_STYLE,XGL_LINE_SOLID,0);\
		xgl_multipolyline(ctx_3d, NULL, 1, &pl_solid_list);\
		pl_solid_list.num_pts = 0;\
	}\
	if (pl_dash_list.num_pts) {\
		xgl_object_set(ctx_3d,XGL_CTX_LINE_STYLE,XGL_LINE_PATTERNED,0);\
		xgl_multipolyline(ctx_3d, NULL, 1, &pl_dash_list);\
		pl_dash_list.num_pts = 0; \
	}

#define FlushPgList() \
	if (pg_list.num_pts) {\
		xgl_multi_simple_polygon(ctx_3d,\
                        XGL_FACET_FLAG_SIDES_UNSPECIFIED |\
                        XGL_FACET_FLAG_SHAPE_NONCONVEX | \
			XGL_FACET_FLAG_FN_CONSISTENT, &facet_list,\
                        NULL, 1, &pg_list);\
		pg_list.num_pts = 0; pg_ptr = pg_pts;\
	}\
	if (pg_vnorm_list.num_pts) {\
		xgl_multi_simple_polygon(ctx_3d,\
                        XGL_FACET_FLAG_SIDES_UNSPECIFIED |\
                        XGL_FACET_FLAG_SHAPE_NONCONVEX | \
			XGL_FACET_FLAG_FN_CONSISTENT, &facet_list,\
                        NULL, 1, &pg_vnorm_list);\
		pg_vnorm_list.num_pts = 0; pg_vnorm_ptr = pg_vnorm_pts;\
	}

/* Macro for pulling out double points and shoving into local array for XGL */
#define GrabPts(xgl_ptr, pt) 	xgl_ptr->x = pt[0][0]; \
                                xgl_ptr->y = pt[0][1]; \
                                xgl_ptr->z = pt[0][2]; \
				xgl_ptr++;
	
/* Macro for bumping the number of polyline points, based on a dashed line */
#define BumpNumPts() \
		if (sp->s_soldash)\
			pl_dash_list.num_pts++;\
		else\
			pl_solid_list.num_pts++;

int
XGL_object(sp, mat, ratio, white)
struct solid *sp;
mat_t mat;
double ratio;
{
	static Xgl_color		solid_color;
	Xgl_color_index			color_index;
	struct rt_vlist         	*vp;
	Xgl_pt_flag_f3d			*flag_f3d_ptr;
	int				num_pts;
	int				vnorm_flag;

/*	DPRINTF("XGL_object\n");*/

	/* Set the line color (s_dmindex was set in XGL_colorchange) */
	if(MONOCHROME) 
		color_index = 1;
	else if(white) 
		color_index = DM_WHITE;
	else 
		color_index = sp->s_dmindex;

	if (color_index != last_color_index) {
		/* Changing colors, need to flush polylines and polygons */
		FlushPlList();
		FlushPgList();
		SetColor(solid_color, color_index);
		xgl_object_set(ctx_3d,
               		XGL_CTX_LINE_COLOR,    &solid_color,
               	 	0);
		last_color_index = color_index;
	}
	/* 
	 * Next, check to see if we filled up the polyline arrays. If so,
	 * flush. 
	 */
	if (sp->s_soldash) {
		num_pts = pl_dash_list.num_pts;
		if (num_pts + sp->s_vlen > MAX_PL_PTS)  {
			FlushPlList();
		}
		flag_f3d_ptr = &(pl_dash_list.pts.flag_f3d[num_pts]);
	} else {
		num_pts = pl_solid_list.num_pts;
		if (num_pts + sp->s_vlen > MAX_PL_PTS)  {
			FlushPlList();
		}
		flag_f3d_ptr = &(pl_solid_list.pts.flag_f3d[num_pts]);
	}
		
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		int    i;
		int    nused = vp->nused;
                int    *cmd = vp->cmd;
                point_t *pt = vp->pt;

                for( i = 0; i < nused; i++,cmd++,pt++ )  {
                        switch( *cmd )  {
                        case RT_VLIST_POLY_START:
				FlushPgList();
				/* Grab normal vector */
				cn_facet.normal.x = pt[0][0];
				cn_facet.normal.y = pt[0][1];
				cn_facet.normal.z = pt[0][2];
				cn_facet.color = solid_color;
				/* Assume no vertex normals coming */
				vnorm_flag = 0;
                                continue;
                        case RT_VLIST_POLY_MOVE:
                        case RT_VLIST_POLY_DRAW:
				if (vnorm_flag) {
					GrabPts(pg_vnorm_ptr, pt);
					pg_vnorm_list.num_pts++;
				} else {
					GrabPts(pg_ptr, pt);
					pg_list.num_pts++;
				}
				continue;
                        case RT_VLIST_POLY_END:
				FlushPgList();
				continue;
			case RT_VLIST_POLY_VERTNORM:
				/* Set flag indicating we have vert. normals */
				vnorm_flag = 1;
				pg_vnorm_ptr->normal.x = pt[0][0];
				pg_vnorm_ptr->normal.y = pt[0][1];
				pg_vnorm_ptr->normal.z = pt[0][2];
				/* The vertex comes next (POLY_MOVE/DRAW) */
				continue;
                        case RT_VLIST_LINE_MOVE:
					/* Don't draw edge */
				flag_f3d_ptr->flag = 0x00;
				GrabPts(flag_f3d_ptr, pt);
				BumpNumPts();
				continue;
                        case RT_VLIST_LINE_DRAW:
					/* Draw Edge */
                               	flag_f3d_ptr->flag = 0x01;
				GrabPts(flag_f3d_ptr, pt);
				BumpNumPts();
                                continue;
                        }
                }
	}
	return (1);
}
static void
XGL_object_flush()
{
	/* Flush any outstanding polylines or polygons */
	FlushPlList();
	FlushPgList();
	return;
}


/*
 * Init the 'pts' element of the 3 point lists
 */
static void 
XGL_object_init() {
	pl_solid_list.pts.flag_f3d = pl_solid_pts;
	pl_dash_list.pts.flag_f3d = pl_dash_pts;
	pg_list.pts.f3d = pg_pts;
	pg_vnorm_list.pts.normal_f3d = pg_vnorm_pts;

	facet_list.facet_type = XGL_FACET_COLOR_NORMAL;
	facet_list.num_facets = 1;
	facet_list.facets.color_normal_facets = &cn_facet;
}
	
/*
 *	XGL_normal
 *
 */
void
XGL_normal()
{
	DPRINTF("XGL_normal\n");

	return;
}

/*
 *	XGL_update
 */
void
XGL_update()
{
	DPRINTF("XGL_update\n");

	xgl_context_post(ctx_3d, FALSE);
	xgl_context_post(ctx_2d, FALSE);

	return;
}

/*
 *	XGL_puts
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
void
XGL_puts( str, x, y, size, color )
char 	*str;
int	x, y, size, color;
{
	Xgl_color	ln_color;
	Xgl_pt_f2d	pos;

	DPRINTF("XGL_puts\n");

	if(no_2d_flag) return;
	Flush3D();

	pos.x = x;
	pos.y = y;

	if (MONOCHROME)
		ln_color.index = 1;
	else
		SetColor(ln_color, color);

	xgl_object_set(ctx_2d,
		XGL_CTX_STEXT_COLOR,	&ln_color,
		XGL_CTX_STEXT_CHAR_HEIGHT,	45.,
		0);

	xgl_stroke_text_2d(ctx_2d, str, &pos);

	return;
}


/*
 *	XGL_2d_line
 */
void
XGL_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	Xgl_pt_list	pl;
	Xgl_pt_f2d	pts[2];

	DPRINTF("XGL_2d_line\n");

	if(no_2d_flag) return;
	Flush3D();

	if(dashed) {
		xgl_object_set(ctx_2d,
			XGL_CTX_LINE_STYLE,	XGL_LINE_PATTERNED,
			XGL_CTX_LINE_PATTERN, 	xgl_lpat_dashed,
			0);
	} else {
		xgl_object_set(ctx_2d,
			XGL_CTX_LINE_STYLE,	XGL_LINE_SOLID,
			0);
	}
	pl.pt_type = XGL_PT_F2D;
	pl.bbox    = NULL;
	pl.num_pts = 2;
	pl.pts.f2d = pts;

	pts[0].x = x1;
	pts[0].y = y1;
	pts[1].x = x2;
	pts[1].y = y2;

	xgl_multipolyline(ctx_2d, NULL, 1, &pl);
	return;
}

/*
 *	XGL_input
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
XGL_input( input, noblock )
fd_set		*input;
int		noblock;
{

	struct timeval	tv;
	fd_set		files;
	int		width;
	int		cnt;
	register int	i;

#if defined(_SC_OPEN_MAX)
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
#endif
		width = 32;

	files = *input;		/* save, for restore on each loop */
	FD_SET( display->fd, &files );	/* check X fd too */

	/*
	 * Check for input on the keyboard, mouse, or window system.
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  Mouse or Window input arrives
	 *  3)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which we still have to update the display,
	 * do not suspend execution.
	 */
	do {
		*input = files;
		i = XPending( display );
		if( i > 0 ) {
			/* Don't select if we have some input! */
			FD_ZERO( input );
			FD_SET( display->fd, input );
			break;
			/* Any other input will be found on next call */
		}

		tv.tv_sec = 0;
		if( noblock )  {
			tv.tv_usec = 0;
		}  else  {
			/* 1/20th second */
			tv.tv_usec = 50000;
		}
		cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
		if( cnt < 0 )  {
			perror("dm-xgl.c/select");
			break;
		}
		if( noblock )  break;
		for( i=0; i<width; i++ )  {
			if( FD_ISSET(i, input) ) {
				noblock = 1;
				break;
			}
		}
	} while( noblock == 0 );

	if( FD_ISSET( display->fd, input ) )
		checkevents();

	return;
}

/* 
 *	XGL_light
 */
void
XGL_light( cmd, func )
int cmd;
int func;
{
	DPRINTF("XGL_light\n");

	return;
}

/*
 *	XGL_cvtvecs
 */
unsigned
XGL_cvtvecs(sp)
struct solid *sp;
{
	DPRINTF("XGL_ctvecs\n");

	return(0);
}


/*
 *	XGL_load
 */
unsigned
XGL_load( addr, count )
unsigned addr, count;
{
	DPRINTF("XGL_load\n");

	return 0;
}

/*
 *	XGL_statechange
 */
void
XGL_statechange(oldstate, newstate)
int	oldstate, newstate;
{
	DPRINTF("XGL_statechange\n");  /* .... found below	*/
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( newstate )  {
	case ST_VIEW:
		/* constant tracking OFF */
		XSelectInput( display, xwin, 
			ExposureMask|ButtonPressMask|
			KeyPressMask|StructureNotifyMask);
		break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
		/* constant tracking ON */
		XSelectInput( display, xwin, 
		  	PointerMotionMask|ExposureMask|ButtonPressMask|
			KeyPressMask|StructureNotifyMask );
		break;
	case ST_O_EDIT:
	case ST_S_EDIT:
		/* constant tracking OFF */
		XSelectInput( display, xwin, 
			ExposureMask|ButtonPressMask|
			KeyPressMask|StructureNotifyMask );
		break;
	default:
		bu_log("X_statechange: unknown state %s\n", 
			state_str[newstate]);
		break;
	}

	return;
}


/*
 *	XGL_viewchange
 */
void
XGL_viewchange(cmd, sp)
register int cmd;
register struct solid *sp;
{

	return;
}

/*
 *	XGL_colorchange
 */
void
XGL_colorchange()
{
	register struct solid	*sp;
	register int		i;
	register float		r, g, b;
	Xgl_color		bg_color;

	DPRINTF("XGL_colorchange\n");

	if(MONOCHROME)
		return;

	color_soltab();		/* apply colors to the solid table */

	slotsused = MINSLOTS;

	FOR_ALL_SOLIDS(sp) {
		r = (float)sp->s_color[0] / 255.0;
		g = (float)sp->s_color[1] / 255.0;
		b = (float)sp->s_color[2] / 255.0;

		if((r == 1.0 && g == 1.0 && b == 1.0) ||
		   (r == 0.0 && g == 0.0 && b == 0.0)) {
			sp->s_dmindex = DM_WHITE;
			continue;
		}

		for(i = 0; i < slotsused; i++) {
			if(color_table[i].rgb.r == r &&
			   color_table[i].rgb.g == g &&
			   color_table[i].rgb.b == b) {
				sp->s_dmindex = (short)i;
				break;
			}
		}
		if(i < slotsused)
			continue;

		if(slotsused < maxcolors) {
			color_table[slotsused].rgb.r = r;
			color_table[slotsused].rgb.g = g;
			color_table[slotsused].rgb.b = b;
			sp->s_dmindex = slotsused++;
			continue;
		}

		sp->s_dmindex = DEFAULT_COLOR;
	}

	for(i = slotsused; i < maxcolors; i++)
		color_table[i].rgb = RED;

	/* Invalidate the last color since the table may have changed */
	last_color_index = 0xffffffff;
		
	if (color_type == XGL_COLOR_RGB) 
		return;

	if(CMAPDBUFFERING) 
		setcolortables(color_table_A, color_table_B);
	xgl_object_set(cmap,
		XGL_CMAP_COLOR_TABLE,		&cmap_info,
		0);

	if(CMAPDBUFFERING) {
		xgl_object_set(cmap_B,
			XGL_CMAP_COLOR_TABLE,		&cmap_info_B,
			0);
	}

	SetColor(bg_color, DM_BLACK);
	xgl_object_set (ctx_3d, XGL_CTX_BACKGROUND_COLOR, &bg_color, NULL);
	xgl_object_set (ctx_2d, XGL_CTX_BACKGROUND_COLOR, &bg_color, NULL);
	return;
}

/*
 *	XGL_debug
 */
void
XGL_debug(level)
int	level;
{
	DPRINTF("XGL_debug\n");

	XGL_debug_level = level;
	return;
}

/*
 *	XGL_window
 */
void
XGL_window(windowbounds)
register int windowbounds[];
{
	Xgl_bounds_d3d	bounds_d3d;
	static int	lastwindowbounds[6];

	DPRINTF("XGL_window\n");

	if(memcmp((char *)windowbounds, (char *)lastwindowbounds,
	    (6 * sizeof(int)))) {
		bcopy((char *)windowbounds, (char *)lastwindowbounds,
		    (6 * sizeof(int)));

		bounds_d3d.xmax = windowbounds[0] / 2047.0;
		bounds_d3d.xmin = windowbounds[1] / 2048.0;

		bounds_d3d.ymax = windowbounds[2] / 2047.0;
		bounds_d3d.ymin = windowbounds[3] / 2048.0;

		bounds_d3d.zmax = windowbounds[4] / 2047.0;
		bounds_d3d.zmin = windowbounds[5] / 2048.0;	

		xgl_object_set(ctx_3d,
			XGL_CTX_VIEW_CLIP_BOUNDS, &bounds_d3d,
			0);

	}

	return;
}

int
XGL_dm( int argc, char ** argv)
{

	bu_log(stderr, "No commands implemented\n");
	return 0;
}



/************************************************************************
 *									*
 * 	INITIALIZATION							*
 *									*
 ************************************************************************/

static void
init_globals()
{
	width		= 512;
	height		= 512;
	no_2d_flag	= 0;
	dbuffering	= 0;
}

/********************************************************************/

static int
X_setup( Display **dpy, int *screen, Window *win, int *w, int *h)
{
	XVisualInfo	visual_info;
	Visual		*visual;
        XSizeHints 	xsh;
	int		depth;
	int		x, y;
	XEvent  	event;
	Colormap        xcmap;
        static XSetWindowAttributes xswa;
	static XWMHints xwmh = {
       	 	(InputHint|StateHint),          /* flags */
       	 	False,                          /* input */
       	 	NormalState,                    /* initial_state */
       	 	0,                              /* icon pixmap */
       	 	0,                              /* icon window */
       	 	0, 0,                           /* icon location */
       	 	0,                              /* icon mask */
       	 	0                               /* Window group */
	};


	/* Use the DISPLAY environment variable. If not set, it's an error */
	if ((*dpy = XOpenDisplay (NULL)) == NULL) {
		bu_log("Could not open X display %s\n", XDisplayName(NULL));
		return (-1);
	}

	*screen = DefaultScreen (*dpy);
	visual =  DefaultVisual (*dpy, *screen);
        depth = DefaultDepth (*dpy, *screen);
        xcmap = CopyFromParent;

	/* Make the window full screen */
	*w = DisplayWidth(*dpy, *screen);
	*h = DisplayHeight(*dpy, *screen);
	/*
	 * Since there is no ICCCM protocol for determining the size of the
	 * window decoration, let's assume we're using olwm.
	 */
#define WM_BORDER_HEIGHT 30
#define WM_BORDER_WIDTH  10
	*h -= WM_BORDER_HEIGHT;
	*w -= WM_BORDER_WIDTH;
	if (*w < *h)
		*h = *w;
	if (*h < *w)
		*w = *h;

	/* Position window at lower-right side of screen */
	x = DisplayWidth(*dpy, *screen) - *w - WM_BORDER_WIDTH;
	y = DisplayHeight(*dpy, *screen) - *h - WM_BORDER_HEIGHT;
	/* 
	 * If we have a 24-bit display, let's use that visual. Otherwise use
	 * the default visual
	 */
	if (depth != 24) {
		/* 
		 * If we find 1 24-bit visual, must create a colormap for
		 * that visual, or CreateWindow will fail
		 */
		if (XMatchVisualInfo(*dpy, *screen, 24, TrueColor, 
				&visual_info)) {
			xcmap = XCreateColormap(*dpy, RootWindow(*dpy,*screen),
				visual_info.visual, AllocNone);
			depth = 24;
			visual = visual_info.visual;
		}
		else if (XMatchVisualInfo(*dpy, *screen, 24, DirectColor, 
                                &visual_info)) {
			xcmap = XCreateColormap(*dpy, RootWindow(*dpy,*screen),
				visual_info.visual, AllocAll);
			depth = 24;
			visual = visual_info.visual;
		}

	}

	xswa.colormap = xcmap;
	xswa.border_pixel = BlackPixel(*dpy, *screen);
	xswa.background_pixel = BlackPixel(*dpy, *screen);

	*win = XCreateWindow (*dpy, DefaultRootWindow(*dpy),  x, y, *w, *h,
		1, depth, InputOutput, visual,
		CWBorderPixel |CWColormap | CWBackPixel, &xswa);

	if (xwin == NULL) {
		bu_log("Could not create X window\n");
		return (-1);
	}
	xsh.flags = (PSize | PPosition);
	xsh.height = *h;
	xsh.width =  *w;
	xsh.x = x;
	xsh.y = y;
	XSetStandardProperties(*dpy, *win, "MGED", "MGED", 
			None, NULL, 0, &xsh );
	XSetWMHints(*dpy, *win, &xwmh );
        XSelectInput(*dpy, *win, 
		ExposureMask|ButtonPressMask|
		KeyPressMask |StructureNotifyMask);

	/* Set up the DELETE_WINDOW handshaking */
	wm_protocols_atom = XInternAtom(*dpy, "WM_PROTOCOLS", False);
	wm_delete_win_atom = XInternAtom(*dpy, "WM_DELETE_WINDOW", True);
	if (wm_delete_win_atom == None || wm_protocols_atom == None) 
	    bu_log("Couldn't get WM_PROTOCOLS or WM_DELETE_WINDOW atom\n");
	else 
		XSetWMProtocols (*dpy, *win, &wm_delete_win_atom, 1);

        XMapWindow(*dpy, *win );
 
        while( 1 ) {
                XNextEvent(*dpy, &event );
                if( event.type == Expose && event.xexpose.count == 0 ) {
                        XWindowAttributes xwa;
 
                        /* remove other exposure events */
                        while( XCheckTypedEvent(*dpy, Expose, &event) ) ;
 
                        if( XGetWindowAttributes( *dpy, *win, &xwa ) == 0 )
                                break;
 
                        *w= xwa.width;
                        *h= xwa.height;
                        break;
                }
        }
        return  0;
}

static int 
XGL_setup()
{
	
	Xgl_bounds_d2d	bounds_d2d;
	Xgl_bounds_d3d	bounds_d3d;
	int		bufs;
       	Xgl_inquire     *inq_info;
	Xgl_color	ln_color, bg_color;
	
	xgl_x_win.X_display = display;
	xgl_x_win.X_window = xwin;
	xgl_x_win.X_screen = screen_num;

	win_desc.win_ras.type = XGL_WIN_X;
	win_desc.win_ras.desc = &xgl_x_win;

	sys_state = xgl_open(0);

       if (!(inq_info = xgl_inquire(sys_state, &win_desc))) {
          	bu_log("error in getting inquiry\n");
          	exit(1);
        }
	bufs = inq_info->maximum_buffer;	/* if double buffering, its 2 */

	if (strcmp(inq_info->name, "Sun:GX") == 0) {
		if (bufs > 1)
			/* 2 buffers,  We must have a TGX+ */
			frame_buffer_type = FB_TGX;
		else
			frame_buffer_type = FB_GX;
	} else if (strcmp(inq_info->name, "Sun:LEO") == 0)
		frame_buffer_type = FB_ZX;
	else if (strcmp(inq_info->name, "Sun:SX") == 0)
		frame_buffer_type = FB_SX;

	/*
	 * HACK City!!! 12-23-94
	 * 	The GX and TGX frame buffers have performance problems
	 * 	and clipping problems when using DGA that have not yet been 
	 *	resolved. Until they are, we use PEX or Xlib.
	 */
	if (frame_buffer_type == FB_GX || frame_buffer_type == FB_TGX) {
		free(inq_info);
		xgl_close(sys_state);
		win_desc.win_ras.type = XGL_WIN_X | XGL_WIN_X_PROTO_PEX |
			XGL_WIN_X_PROTO_XLIB ;
		sys_state = xgl_open(0);
		if (!(inq_info = xgl_inquire(sys_state, &win_desc))) {
			bu_log("error in getting inquiry\n");
			exit(1);
		}
	}

	bufs = inq_info->maximum_buffer;	/* if double buffering, its 2 */
	/*
	 * Check whether the frame buffer supports Z-buffering. If so, turn
	 * on Z-buffering by default.
	 */
	if (inq_info->hlhsr_mode == XGL_HLHSR_Z_BUFFER &&
	    inq_info->hlhsr == XGL_INQ_HARDWARE)
		zbuff_on = 1;

	free(inq_info);
	
    	/* ras MUST be created before init_check_buffering() is called */
    	ras = xgl_object_create(sys_state, XGL_WIN_RAS, &win_desc,
		NULL);

	if((dbuffering = init_check_buffering(bufs)) < 0)
		return(-1);

	if(MONOCHROME) {
		ln_color.index = 1;
	} else {
		cmap_info.start_index	= 0;
		cmap_info.length	= colortablesize;
		cmap_info.colors	= color_table;

		if(CMAPDBUFFERING) {
			cmap_info_B.start_index	= 0;
			cmap_info_B.length	= colortablesize;
			cmap_info_B.colors	= color_table_B;
		}

		color_table[DM_BLACK ].rgb = BLACK;
		color_table[DM_RED   ].rgb = RED;
		color_table[DM_BLUE  ].rgb = BLUE;
		color_table[DM_YELLOW].rgb = YELLOW;
		color_table[DM_WHITE ].rgb = WHITE;
		for(slotsused=MINSLOTS; slotsused < maxcolors; ++slotsused)
			color_table[slotsused].rgb = RED;
		slotsused = MINSLOTS;
		if(CMAPDBUFFERING)
			setcolortables(color_table_A, color_table_B);

		SetColor(ln_color, DM_YELLOW);
		SetColor(bg_color, DM_BLACK);
		if (color_type == XGL_COLOR_INDEX) {
		    cmap = xgl_object_create(sys_state, XGL_CMAP, NULL,
			XGL_CMAP_COLOR_TABLE_SIZE,	colortablesize,
			XGL_CMAP_COLOR_TABLE,		&cmap_info,
			0);

		    if(CMAPDBUFFERING) {
			cmap_B = xgl_object_create(sys_state, XGL_CMAP, NULL,
				XGL_CMAP_COLOR_TABLE_SIZE,	colortablesize,
				XGL_CMAP_COLOR_TABLE,		&cmap_info_B,
				0);
		    }
		    xgl_object_set(ras,
			XGL_DEV_COLOR_MAP,	cmap,
			0);
		}
	}

	bounds_d2d.xmin = -2048.0;
	bounds_d2d.xmax = 2050.0;	/* I'm not sure why this has to be */
	bounds_d2d.ymin = -2052.0;	/* hacked with 2050 and 2052;  but, */
	bounds_d2d.ymax = 2048.0;	/* that's what works */

	bounds_d3d.xmax = 1.;
	bounds_d3d.xmin = -1.;
	bounds_d3d.ymax = 1.;
	bounds_d3d.ymin = -1.;
	bounds_d3d.zmax = PLOTBOUND;
	bounds_d3d.zmin = -PLOTBOUND;	

	ctx_3d = xgl_object_create (sys_state, XGL_3D_CTX, NULL,
		XGL_CTX_DEVICE,		ras,
		XGL_CTX_LINE_COLOR,	&ln_color,
		XGL_CTX_VDC_MAP,	XGL_VDC_MAP_ASPECT,
		XGL_CTX_VDC_ORIENTATION, XGL_Y_UP_Z_TOWARD,
		XGL_CTX_VDC_WINDOW,	&bounds_d3d,
		XGL_CTX_CLIP_PLANES,	XGL_CLIP_XMIN | XGL_CLIP_YMIN |
					XGL_CLIP_XMAX | XGL_CLIP_YMAX,
		XGL_CTX_RENDERING_ORDER, XGL_RENDERING_ORDER_HLHSR,
		XGL_3D_CTX_HLHSR_MODE, XGL_HLHSR_Z_BUFFER,
                XGL_CTX_LINE_PATTERN,   xgl_lpat_dashed,
		XGL_CTX_LINE_STYLE,	XGL_LINE_SOLID,
		XGL_CTX_DEFERRAL_MODE, XGL_DEFER_ASTI,
		XGL_CTX_BACKGROUND_COLOR, &bg_color,
		XGL_CTX_SURF_FRONT_COLOR_SELECTOR, XGL_SURF_COLOR_FACET,
		0);

	init_lights();	/* Create and init the lights */

	ctx_2d = xgl_object_create(sys_state, XGL_2D_CTX, NULL,
			XGL_CTX_DEVICE,		ras,
			XGL_CTX_LINE_COLOR,	&ln_color,
			XGL_CTX_VDC_MAP,	XGL_VDC_MAP_ASPECT,
			XGL_CTX_VDC_ORIENTATION, XGL_Y_UP_Z_TOWARD,
			XGL_CTX_VDC_WINDOW,	&bounds_d2d,
			XGL_CTX_BACKGROUND_COLOR, &bg_color,
			0);
	if(CMAPDBUFFERING) {
		xgl_context_new_frame(ctx_3d);
		xgl_context_new_frame(ctx_2d);
		current_buffer_is_A = 0;
		xgl_object_set(ctx_3d, XGL_CTX_PLANE_MASK, CMAP_MASK_B, 0);
		xgl_object_set(ctx_2d, XGL_CTX_PLANE_MASK, CMAP_MASK_B, 0);
		xgl_object_set(ctx_3d,
                    XGL_CTX_NEW_FRAME_ACTION,
                        (XGL_CTX_NEW_FRAME_CLEAR | XGL_CTX_NEW_FRAME_VRETRACE |
			 XGL_CTX_NEW_FRAME_HLHSR_ACTION),
			NULL);
		xgl_context_new_frame(ctx_3d);
		xgl_context_new_frame(ctx_2d);
	} else if (dbuffering == AB_DBUFF) {
		xgl_context_new_frame(ctx_3d);
		xgl_context_new_frame(ctx_2d);
		xgl_object_set(ras,
		    XGL_WIN_RAS_BUF_DISPLAY,		XGL_BUF_A,
		    XGL_WIN_RAS_BUF_DRAW,		XGL_BUF_B,
		    0);
		xgl_context_new_frame(ctx_3d);
		xgl_context_new_frame(ctx_2d);
		xgl_object_set(ctx_3d,
		    XGL_CTX_NEW_FRAME_ACTION,
			(XGL_CTX_NEW_FRAME_CLEAR
			    | XGL_CTX_NEW_FRAME_SWITCH_BUFFER 
			    | XGL_CTX_NEW_FRAME_HLHSR_ACTION),
		    0);

	} else {
		/* No double buffering */
		xgl_object_set(ctx_3d,
                    XGL_CTX_NEW_FRAME_ACTION,
                        (XGL_CTX_NEW_FRAME_CLEAR | XGL_CTX_NEW_FRAME_VRETRACE |
			 XGL_CTX_NEW_FRAME_HLHSR_ACTION),
		    0);
	}

	/*
	 * Initialize the z-buffer by clearing the frame 
	 * (XGL_CTX_NEW_FRAME_HLHSR_ACTION is already turned on). Then
	 * turn z-buffering back off if we don't have HLHSR in hardware.
	 */
	xgl_context_new_frame(ctx_3d);
	xgl_context_new_frame(ctx_2d);
	if (!zbuff_on)
		xgl_object_set(ctx_3d, XGL_3D_CTX_HLHSR_MODE,XGL_HLHSR_NONE,0);

	/* Get the View transformation */

	xgl_object_get (ctx_3d, XGL_CTX_VIEW_TRANS, &trans);
	xgl_object_set (trans, XGL_TRANS_DATA_TYPE, XGL_DATA_DBL, NULL); 

	/* Create a transform that we'll use for the inverse of the VIEW */
	itrans = xgl_object_create(sys_state, XGL_TRANS, NULL,
		XGL_TRANS_DATA_TYPE, XGL_DATA_DBL,
		XGL_TRANS_DIMENSION, XGL_TRANS_3D,
		NULL);

	/*
	 * Set Backing store if we're not h/w double-bufferred (XGL won't
	 * support both double-buffer AND backing store
	 */
        if (dbuffering != AB_DBUFF) {
		static XSetWindowAttributes xswa;

                xswa.backing_store = Always;
                XChangeWindowAttributes (display, xwin,
                       	CWBackingStore , &xswa);
                xgl_object_set (ras, XGL_WIN_RAS_BACKING_STORE, TRUE,0);
        }
	return(0);
}

static int
init_check_buffering( int bufs)
{
	Xgl_cmap	cmap;
	Xgl_usgn32	maxsize;
	Xgl_usgn32	nbufs;
	int		type;

	type = NO_DBUFF;
	maxcolors = 128;
	colortablesize = 128;

	xgl_object_get(ras, XGL_RAS_COLOR_TYPE, &color_type);
	if (bufs > 1) {
		/* Let's try double buffering because the H/W says it exists */
		xgl_object_set(ras, XGL_WIN_RAS_BUFFERS_REQUESTED, bufs, 0);
	}
	xgl_object_get(ras, XGL_WIN_RAS_BUFFERS_ALLOCATED, &nbufs);
	xgl_object_get(ras, XGL_DEV_COLOR_MAP, &cmap);
	xgl_object_get(cmap, XGL_CMAP_MAX_COLOR_TABLE_SIZE, &maxsize);

	if(nbufs > 1) {
		bu_log("\nA total of %d buffers are supported by this\n", 
				nbufs);
		bu_log("hardware. Hardware double buffering will be used.\n");

		return(AB_DBUFF);
	} else if(maxsize == 2) {

		bu_log("\nThis is a MONOCHROME frame buffer. No double \n");
		bu_log("buffering of any type can be used.\n\n");

		maxcolors = 2;
		colortablesize = 2;
		return(NO_DBUFF);

	} else if(maxsize != 256) {
		bu_log("\nUnknown frame buffer type ... aborting.\n\n");
		return(-1);

	} else {
		if (color_type == XGL_COLOR_INDEX) {
			bu_log(
			   "\nUsing colormap double buffering, 8 bit color.\n");
			switch(DEFAULT_DB) {
			case OPTION_ZERO:
				type = NO_DBUFF;
				maxcolors = 2;
				colortablesize = 2;
				break;
		 	case OPTION_ONE:
				type = NO_DBUFF;
				maxcolors = 128;
				colortablesize = 128;
				break;
		  	case OPTION_TWO:
				type = CMAP8_DBUFF;
				maxcolors = 8;
				colortablesize = 64;
				break;
		  	case OPTION_THREE:
				type = CMAP16_DBUFF;
				maxcolors = 16;
				colortablesize = 256;
				break;
		  	default:
			       bu_log("Undefined DEFAULT_DB option,exiting\n");
			       exit(1);
			}
		} else {
			/* 
			 * We don't have HW double buffering AND we're a
			 * 24-bit frame buffer (XGL_COLOR_RGB). So let's
			 * not do double-buffering at all so we can do 24-bit
			 * colors for lighting, etc.
			 *
			 * type is already set to NO_DBUFF
			 */
		}
	}
	return(type);
}
/*
 *  Only called when we *know* there is at least one event to process.
 *  (otherwise we would block in XNextEvent)
 *
 *	NOTE: This code was 'lifted' right from the dm-X module!
 */
static void
checkevents()
{
	XEvent	event;
	KeySym	key;
	char keybuf[4];
	char cmd_buf[32];
	int cnt;
	XComposeStatus compose_stat;
	static int prev_width = -1, prev_height = -1;

	while( XPending( display ) > 0 ) {
		XNextEvent( display, &event );
		if (event.type == sundials_ev_type) {
			/* Somebody turned a dial! */
			handle_sundials_event(&event);
			continue;
		}
		switch(event.type) {
		case Expose:
			if( event.xexpose.count == 0 ) {
				/*
				 * If we're colormap double-buffering, we 
				 * need to work around a bug where the 
				 * window manager paints the background with
				 * BlackPixel, which corresponds to XGL red.
				 */
				if(CMAPDBUFFERING) {
					if (current_buffer_is_A) 
						display_buff();
				}
				if (frame_buffer_type == FB_TGX || 
				    CMAPDBUFFERING) {
					/* Clear the screen before refresh */
					display_buff();
				}
				dmaflag = 1;
			}
			break;
		case DestroyNotify:
			XGL_close();
			break;
		case ConfigureNotify:
			if (prev_width != event.xconfigure.width ||
			    prev_height != event.xconfigure.height ) {
				width = prev_width = event.xconfigure.width;
				height = prev_height = event.xconfigure.height;
				if(width < height) height = width;
				if(height < width) width  = height;

				xgl_window_raster_resize(ras);
			}
			if (frame_buffer_type == FB_TGX) {
				/* First, clear the screen. This is necessary
				 * because any area that was obscured will
				 * not refresh properly after a window move 
				 * on the TGX
				 */
				display_buff();
				dmaflag = 1;
			}
			break;
		case ClientMessage:
			if (event.xclient.message_type == wm_protocols_atom &&
			    event.xclient.data.l[0] == wm_delete_win_atom) {
					/* Must have quit from menu */
			    		bu_vls_printf( 
						&dm_values.dv_string, 
						"q\n");
			}
			break;

		case MotionNotify:
			{
			    int	x, y;
			    x = (event.xmotion.x/(double)width - 0.5) * 4095;
			    y = (0.5 - event.xmotion.y/(double)height) * 4095;
			    bu_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
			    	x, y );
			}
			break;
		case ButtonPress:
			/* There may also be ButtonRelease events */
		    {
			int	x, y;
			/* In MGED this is a "penpress" */
			x = (event.xbutton.x/(double)width - 0.5) * 4095;
			y = (0.5 - event.xbutton.y/(double)height) * 4095;
			switch( event.xbutton.button ) {
			case Button1:
			    /* Left mouse: Zoom out */
			    bu_vls_strcat( &dm_values.dv_string, "zoom 0.5\n");
			    break;
			case Button2:
			    /* Middle mouse, up to down transition */
			    bu_vls_printf( &dm_values.dv_string, "M 1 %d %d\n",
			    	x, y);
			    break;
			case Button3:
			    /* Right mouse: Zoom in */
			    bu_vls_strcat( &dm_values.dv_string, "zoom 2\n");
			    break;
			}
		    }
		    break;
		case ButtonRelease:
		    {
			int	x, y;
			x = (event.xbutton.x/(double)width - 0.5) * 4095;
			y = (0.5 - event.xbutton.y/(double)height) * 4095;
			switch( event.xbutton.button ) {
			case Button1:
			    /* Left mouse: Zoom out.  Do nothing more */
			    break;
			case Button2:
			    /* Middle mouse, down to up transition */
			    bu_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
			    	x, y);
			    break;
			case Button3:
			    /* Right mouse: Zoom in.  Do nothing more. */
			    break;
			}
		    }
		    break;
		case KeyPress:
		    {
			/*Turn these into MGED "buttonpress" or knob functions*/

		    	cnt = XLookupString(&event.xkey, keybuf, sizeof(keybuf),
						&key, &compose_stat);

			if (key >= XK_F1 && key <= XK_F12 || 
			    key == SunXK_F36 || key == SunXK_F37) 
				/* F36 and F37 are really F11 and F12! */
				process_func_key(key);
			else {
				switch( key ) {
				case '?':
					bu_log( "\nKey Help Menu:\n\
0	Zero 'knobs'\n\
x	Increase xrot\n\
y	Increase yrot\n\
z	Increase zrot\n\
X	Increase Xslew\n\
Y	Increase Yslew\n\
Z	Increase Zslew\n\
f	Front view\n\
t	Top view\n\
b	Bottom view\n\
l	Left view\n\
r	Right view\n\
R	Rear view\n\
3	35,25 view\n\
4	45,45 view\n\
F	Toggle faceplate\n\
" );
					break;
				case 'F':
					/* Toggle faceplate on/off */
					toggle_faceplate();
					break;
				case '0':
					reset_sundials();
					bu_vls_printf( &dm_values.dv_string,
						"knob zero\n" );
					break;
				case 'x':
				case 'y':
				case 'z':
				case 'X':
				case 'Y':
				case 'Z':
					/* 6 degrees per unit */
					/* 
					 * Knob keys:
					 *
					 * If CTRL key is pressed, move negative.
					 * Else move positive
					 */

					if (event.xkey.state & ControlMask)
						sprintf(cmd_buf, "knob %c -0.1\n",
							key);
					else
						sprintf(cmd_buf, "knob %c 0.1\n",
							key);
					bu_vls_printf( &dm_values.dv_string,
						cmd_buf);
					break;
				case 'f':
					bu_vls_strcat( &dm_values.dv_string,
						"press front\n");
					break;
				case 't':
					bu_vls_strcat( &dm_values.dv_string,
						"press top\n");
					break;
				case 'b':
					bu_vls_strcat( &dm_values.dv_string,
						"press bottom\n");
					break;
				case 'l':
					bu_vls_strcat( &dm_values.dv_string,
						"press left\n");
					break;
				case 'r':
					bu_vls_strcat( &dm_values.dv_string,
						"press right\n");
					break;
				case 'R':
					bu_vls_strcat( &dm_values.dv_string,
						"press rear\n");
					break;
				case '3':
					bu_vls_strcat( &dm_values.dv_string,
						"press 35,25\n");
					break;
				case '4':
					bu_vls_strcat( &dm_values.dv_string,
						"press 45,45\n");
					break;
				case XK_Shift_L:
				case XK_Shift_R:
				case XK_Control_L:
				case XK_Control_R:
				case XK_Caps_Lock:
				case XK_Shift_Lock:
					break;	/* ignore */
				default:
					bu_log(
					  "dm-X:The key '%c' is not defined\n",
						key);
					break;
				}
		    	}
		    }
		    break;
		
		case UnmapNotify:
		case MapNotify:
		    /* No need for action here - we'll get the Expose */
		    break;
		default:
			bu_log( "Unknown event type\n" );
		}
	}
}

/* 
 * Process the SunDials event
 *
 *	SunDials:
 *
 *	    BUTTON 0 (X rot/ADC X)		BUTTON 4 (X slew)
 *	    BUTTON 1 (Y rot/ADC Y)		BUTTON 5 (Y slew)
 *	    BUTTON 2 (Z rot/ang2)		BUTTON 6 (Z slew)
 *	    BUTTON 3 (unused/ang1)		BUTTON 7 (Scale)
 *
 *	From the XDeviceMotionEvent event:
 *		first_axis:	the dial number (0-7)
 *		axis_data[0]:	tick value
 *
 *	The SunDials device reports values in units of 1/64th of a degree.
 *	All values are deltas - there is no concept of absolute positions.
 *	Clockwise turns are reported as positive values, counter-clockwise
 *	as negative. The smallest value returned is 90 units, or a little 
 *	less than 1.5 degrees.
 *
 *	The mged 'knob' command for rotate and slew wants a floating point
 *	value from -1.0 to 1.0. The greater the absolute value of this number
 *	the larger the delta for the operation. So, what we do with the
 *	SunDials device, assuming we start at 0 (neutral) is treat a 
 *	counter-clockwise 360-degree turn as going from 0.0 to -1.0. Any
 *	further turn will be pegged at -1.0. Likewise a clockwise full turn
 *	is treated as going from 0.0 to 1.0.
 *
 *	Finally, we don't want to process each event because the granularity
 *	is too fine for a user to be able to bring the dial back to 0. So, we
 *	divide up the 0.0 to 1.0 values into an increment (eg. .04).
 *
 */

#define SUNDIALS_UNITS_PER_DEGREE 	64	/* 64 units per degree */
#define SUNDIALS_UNITS_PER_REVOLUTION 	(360*SUNDIALS_UNITS_PER_DEGREE)
#define SUNDIALS_NUM_DIALS		8
#define	SUNDIALS_INCR			.04

/* Maintain current unit count and value (-1.- to 1.0) for each dial */
static int current_units[8] = {0,0,0,0,0,0,0,0};
static float current_val[8] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
				/* negative to left, positive to the right */

static void
reset_sundials() 
{
	int	i;
	for (i = 0; i < SUNDIALS_NUM_DIALS; i++) {
		current_units[i] = 0;
		current_val[i] = 0.0;
	}
}

static void
handle_sundials_event(XDeviceMotionEvent *ev)
{

	float val;	/* -1.0 to 1.0 */
	int   setting;	/* -2048 to 2048 - needed by ADC commands */
	int	dial_num;

	dial_num = ev->first_axis;

	current_units[dial_num] += ev->axis_data[0];
	if (current_units[dial_num] > SUNDIALS_UNITS_PER_REVOLUTION) 
		current_units[dial_num] = SUNDIALS_UNITS_PER_REVOLUTION;
	if (current_units[dial_num] < -SUNDIALS_UNITS_PER_REVOLUTION) 
		current_units[dial_num] = -SUNDIALS_UNITS_PER_REVOLUTION;

	val = (float)current_units[dial_num] / 
			(float)SUNDIALS_UNITS_PER_REVOLUTION;

	/* if we're between -INCR and +INCR, just call it zero */
	if (val >= -SUNDIALS_INCR && val <= SUNDIALS_INCR)
		/* Close enough to 0 */
		val = 0.0;

	/* 
	 * Now, if the change in value is less than INCR, let's not send a
	 * command, UNLESS we've got a 0.0 and the previous value as not 0.0.
	 * This is so we can turn off (reset) the operation.
	 */
	if ((fabs (val - current_val[dial_num]) < SUNDIALS_INCR) &&
	   (!(val == 0.0 && current_val[dial_num] != 0.0)))
		/* delta too small to worry about */
		return;

	current_val[dial_num] = val;
	setting = val*2048;
	
	if (XGL_debug_level)
		bu_log( "val = %f, setting = %d\n",val, setting);

	switch (dial_num) {	/* first_axis is button number */
	case 0:
		if(adcflag)
		    bu_vls_printf( &dm_values.dv_string , "knob xadc %d\n",
					setting);
		else
		    bu_vls_printf( &dm_values.dv_string , "knob x %f\n", val);
		break;
	case 1:
		if(adcflag)
		    bu_vls_printf( &dm_values.dv_string , "knob yadc %d\n",
					setting);
		else
		    bu_vls_printf( &dm_values.dv_string , "knob y %f\n", val);
		break;
	case 2:
		if(adcflag)
		    bu_vls_printf( &dm_values.dv_string , "knob ang2 %d\n",
					setting);
		else
		    bu_vls_printf( &dm_values.dv_string , "knob z %f\n", val);
		break;
	case 3:
		if(adcflag)
		    bu_vls_printf( &dm_values.dv_string, "knob ang1 %d\n",
					setting);
		break;
	case 4:
		bu_vls_printf( &dm_values.dv_string , "knob X %f\n", val);
		break;
	case 5:
		bu_vls_printf( &dm_values.dv_string , "knob Y %f\n", val);
		break;
	case 6:
		if(adcflag)
		    bu_vls_printf( &dm_values.dv_string , "knob distadc %d\n",
					setting );
		else
		    bu_vls_printf( &dm_values.dv_string , "knob Z %f\n", val);
		break;
	case 7:
		bu_vls_printf( &dm_values.dv_string , "knob S %f\n", val);
		break;
	}
}

static void fk_depth_cue(), fk_zclip(), fk_perspective(), 
	   fk_zbuffering(), fk_lighting(), fk_p_angle(), fk_faceplate(),
	   fk_anti_alias(), fk_zero_knobs(), fk_nop();
static void 
process_func_key(KeySym key) 
{

	switch (key) {
	case XK_F1:
		fk_depth_cue();
		break;
	case XK_F2:
		fk_zclip();
		break;
	case XK_F3:
		fk_perspective();
		break;
	case XK_F4:
		fk_zbuffering();
		break;
	case XK_F5:
		fk_lighting();
		break;
	case XK_F6:
		fk_p_angle();
		break;
	case XK_F7:
		fk_faceplate();
		break;
	case XK_F8:
		fk_anti_alias();
		break;
	case XK_F9:
	case XK_F10:
	case XK_F11:
	case SunXK_F36:
		fk_nop();
		break;
	case XK_F12:
	case SunXK_F37:
		fk_zero_knobs();
		break;
	}
}
static void
fk_depth_cue()
{
	Xgl_color	dc_color;
	double zvals[2] = {1.0, -1.0};	/* Z-planes between which to scale
					 *  depth-cue */
	/*
	 * Use two scale factors, one for perspective amd one for non-
	 * perspective. We do this so the screen is not so dark with the
	 * perspective set
	 */
	float scale_factors_non_persp[2] = {1.0, 0.2}; 
	float scale_factors_persp[2]     = {1.0, 0.5};
	
	if (color_type == XGL_COLOR_INDEX) {
		bu_log(
		    "Depth-cue support not available for this frame buffer\n");
		return;
	}
	SetColor(dc_color, DM_BLACK);
	if (dcue_on == 0) {
		xgl_object_set(ctx_3d, 
			XGL_3D_CTX_DEPTH_CUE_MODE, XGL_DEPTH_CUE_SCALED,
			XGL_3D_CTX_DEPTH_CUE_REF_PLANES, zvals,
			XGL_3D_CTX_DEPTH_CUE_SCALE_FACTORS, 
			    perspective_mode ? scale_factors_persp :
					       scale_factors_non_persp,
			XGL_3D_CTX_DEPTH_CUE_INTERP, TRUE,
			XGL_3D_CTX_DEPTH_CUE_COLOR, &dc_color,
			NULL);
	} else {
		xgl_object_set(ctx_3d, 
			XGL_3D_CTX_DEPTH_CUE_MODE, XGL_DEPTH_CUE_OFF,
			NULL);

	}
	dcue_on = !dcue_on;
	dmaflag = 1;
}
static void
fk_zclip()
{
	Xgl_bounds_d3d	bounds_d3d ;

	bounds_d3d.xmax = 1.;
	bounds_d3d.xmin = -1.;
	bounds_d3d.ymax = 1.;
	bounds_d3d.ymin = -1.;
	if (zclip_on) {
		bounds_d3d.zmax = PLOTBOUND;
		bounds_d3d.zmin = -PLOTBOUND;	
	} else {
		bounds_d3d.zmax = 1.;
		bounds_d3d.zmin = -1.;	
	}
	xgl_object_set (ctx_3d, XGL_CTX_VDC_WINDOW, &bounds_d3d, NULL);
	zclip_on = !zclip_on;
	dmaflag = 1;
}
static void
fk_perspective()
{
	/* 'Borrowed' from dm-4d.c */
	perspective_mode = 1 - perspective_mode;
        bu_vls_printf( &dm_values.dv_string, "set perspective %d\n",
        	perspective_mode ? perspective_table[perspective_angle] : -1 );
	/*
	 * If depth-cueing is on, re-set the depth-cue scale factors to allow
	 * for more light so the screen is not too dark.
	 */
	if (dcue_on) {
		dcue_on = 0; /* fk_depth_cue() will turn the flag back on */
		fk_depth_cue();
	}
	dmaflag = 1;
}
static void
fk_zbuffering()
{

	if (zbuff_on == 0) {
		xgl_object_set (ctx_3d, 
			XGL_3D_CTX_HLHSR_MODE, XGL_HLHSR_Z_BUFFER,
			NULL);
	} else {
		xgl_object_set (ctx_3d, 
			XGL_3D_CTX_HLHSR_MODE, XGL_HLHSR_NONE,
			NULL);
	}
	zbuff_on = !zbuff_on;
	dmaflag = 1;
}
static void
fk_lighting()
{
	if (color_type == XGL_COLOR_INDEX) {
		bu_log(
		    "Lighting support not available for this frame buffer\n");
		return;
	}
	if (lighting_on == 0) {
		/*
		 * We specify illumination of per-vertex (gouraud shading) 
		 * since we now receive vertex normals.
		 */
		light_switches[0] = light_switches[1] = TRUE;
		xgl_object_set(ctx_3d,
			XGL_3D_CTX_LIGHT_SWITCHES, light_switches,
			XGL_3D_CTX_SURF_FRONT_ILLUMINATION, 
				XGL_ILLUM_PER_VERTEX,	/* gouraud shading */
			NULL);
	} else {
		light_switches[0] = light_switches[1] = FALSE;
		xgl_object_set(ctx_3d,
			XGL_3D_CTX_LIGHT_SWITCHES, light_switches,
			XGL_3D_CTX_SURF_FRONT_ILLUMINATION, XGL_ILLUM_NONE,
			NULL);
	}
	lighting_on = !lighting_on;
	dmaflag = 1;

}
static void
reposition_light()
{
	Xgl_pt_d3d      pos;
	Xgl_pt		pt;

	/*
	 * Position the light in the lower,left-hand corner. Since the position
	 * gets the VIEW transform applied to it, we must take it through the
	 * inverse of the current transform.
	 */
	
	pos.x = -PLOTBOUND;
	pos.y = -PLOTBOUND;
	pos.z = PLOTBOUND;
	pt.pt_type = XGL_PT_D3D;
	pt.pt.d3d = &pos;

	xgl_transform_invert (itrans, trans);
	xgl_transform_point(itrans, &pt);

	xgl_object_set (lights[1],
		XGL_LIGHT_POSITION, &pos,
		NULL);
}

static void
fk_p_angle()
{
	/* 'Borrowed' from dm-4d.c */
	/* toggle perspective matrix */
       	if (--perspective_angle < 0) 
		perspective_angle = NUM_PERSPECTIVE_ANGLES-1;
       	if(perspective_mode) 
		bu_vls_printf( &dm_values.dv_string,
       		"set perspective %d\n", perspective_table[perspective_angle] );
	dmaflag = 1;

}
static void
fk_faceplate()
{
	toggle_faceplate();
}

static void
fk_anti_alias()
{

	if (anti_alias_on == 0) {
		xgl_object_set(ctx_3d, 
			XGL_CTX_LINE_AA_BLEND_EQ, XGL_BLEND_ARBITRARY_BG,
			XGL_CTX_LINE_AA_FILTER_WIDTH,3, 
			XGL_CTX_LINE_AA_FILTER_SHAPE, XGL_FILTER_GAUSSIAN,
			NULL);
	} else {
		xgl_object_set(ctx_3d, 
			XGL_CTX_LINE_AA_BLEND_EQ, XGL_BLEND_NONE,
			XGL_CTX_LINE_AA_FILTER_WIDTH, 1,
			XGL_CTX_LINE_AA_FILTER_SHAPE, XGL_FILTER_GAUSSIAN,
			NULL);
	}
	anti_alias_on = !anti_alias_on;
	dmaflag = 1;
}

static void
fk_zero_knobs()
{
	reset_sundials();
	bu_vls_printf( &dm_values.dv_string,
		"knob zero\n" );
}

static void
fk_nop()
{
	bu_log("Function Key Undefined\n");
}

static void
toggle_faceplate()
{
	no_faceplate = !no_faceplate;
	bu_vls_strcat( &dm_values.dv_string,
		no_faceplate ?
		"set faceplate 0\n" :
		"set faceplate 1\n" );
}

/*************************************************************************
 *
 *	Lighting Code
 */

static void
init_lights()
{
	Xgl_color	lt_color;

	SetColor (lt_color, DM_WHITE);
	xgl_object_set (ctx_3d,
		XGL_3D_CTX_LIGHT_NUM, NUM_LIGHTS,
		XGL_3D_CTX_SURF_FACE_DISTINGUISH, FALSE,
		XGL_3D_CTX_SURF_FRONT_AMBIENT, 0.1,
		XGL_3D_CTX_SURF_FRONT_DIFFUSE, 0.6,
		XGL_3D_CTX_SURF_FRONT_SPECULAR, 0.5,
		XGL_3D_CTX_SURF_FRONT_LIGHT_COMPONENT,
			XGL_LIGHT_ENABLE_COMP_AMBIENT |
			XGL_LIGHT_ENABLE_COMP_DIFFUSE |
			XGL_LIGHT_ENABLE_COMP_SPECULAR,
		XGL_3D_CTX_SURF_FACE_CULL, XGL_CULL_BACK,
		0);

	xgl_object_get(ctx_3d, XGL_3D_CTX_LIGHTS, lights);
	xgl_object_get(ctx_3d, XGL_3D_CTX_LIGHT_SWITCHES, light_switches);
	xgl_object_set (lights[0],
		XGL_LIGHT_TYPE, XGL_LIGHT_AMBIENT,
		XGL_LIGHT_COLOR, &lt_color,
		NULL);
	xgl_object_set (lights[1],
		XGL_LIGHT_TYPE, XGL_LIGHT_POSITIONAL,
		XGL_LIGHT_ATTENUATION_1, 1.0,
		XGL_LIGHT_ATTENUATION_2, 0.0,
		XGL_LIGHT_COLOR, &lt_color,
		NULL);
	light_switches[0] = FALSE;
	light_switches[1] = FALSE;
	xgl_object_set(ctx_3d, XGL_3D_CTX_LIGHT_SWITCHES, light_switches, NULL);
}

/***********************************************************************
 *
 * SunDials Processing Code.
 *
 *	This code uses the X Input Extensions to receive X11 events from
 *	a SunDails dial box.
 */
static void
init_sundials()
{
	
	int          	major_code, minor_code, firsterr, num_dev;
	int		i,j;
	XDeviceInfo	*xdevlist;
   	XAnyClassPtr 	classInfo;
	XEventClass	ev_class;
	XID 		sundials_id;
	XDevice 	*sundials_device;

	/* First, be sure we have the X extension */
	if (!XQueryExtension(display, "XInputDeviceEvents",
			&major_code, &minor_code,
			&firsterr)) {
		return;	/* Nope. No need to report an error, we just won't get
			   events */
	}

	/* Next get the list of input devices supported */
	xdevlist = XListInputDevices(display, &num_dev);

	/* Look for "sundials" */
	if (num_dev > 0) {
		for (i = 0; i < num_dev; i++)
			if (strcmp(xdevlist[i].name,"sundials") == 0)
				break;
	}
	if (num_dev <= 0 || i == num_dev) {
		/* No sundials found - just quietly return */
		return;
	}

	/* Find the Valuator device (sundials) */
	classInfo = xdevlist[i].inputclassinfo;
        for (j = 0; j < xdevlist[i].num_classes; j++) {
            switch(classInfo->class) {
                case ValuatorClass:
                    if ( ((XValuatorInfo *)(classInfo))->num_axes == 8) {
			sundials_id = xdevlist[i].id;
			sundials_device = XOpenDevice(display, sundials_id);
			if (sundials_device == 0) 
				return;	/* Device must not be present */

			/* 
			 * Finally, get the event type to look for in the
			 * X event processing loop and register interest
			 * in these events.
			 */
			DeviceMotionNotify(sundials_device, 
				sundials_ev_type, ev_class);
			XSelectExtensionEvent(display, xwin, &ev_class, 1);
		    }
                break;
                case ButtonClass:
                    if ( ((XButtonInfo *)(classInfo))->num_buttons ==32)
                        ; /* This would be a SunButtons device */
                break;
            }
	    classInfo = (XAnyClassPtr)(((char *)classInfo) + classInfo->length);
        }
	XFreeDeviceList(xdevlist);
	reset_sundials();
}



/************************************************************************
 *									*
 * 	MISCELLANEOUS							*
 *									*
 ************************************************************************/


static void
setcolortables(color_table_A, color_table_B)
Xgl_color	*color_table_A, *color_table_B;
{
	register unsigned int	i;

	for(i = maxcolors; i < colortablesize; i++) {
		color_table_A[i].rgb.r = color_table_A[i & CMAP_MASK_A].rgb.r;
		color_table_A[i].rgb.g = color_table_A[i & CMAP_MASK_A].rgb.g;
		color_table_A[i].rgb.b = color_table_A[i & CMAP_MASK_A].rgb.b;
	}

	for(i = 0; i < colortablesize; i++) {
		color_table_B[i].rgb.r = color_table_A[i >> COLORSHIFT].rgb.r;
		color_table_B[i].rgb.g = color_table_A[i >> COLORSHIFT].rgb.g;
		color_table_B[i].rgb.b = color_table_A[i >> COLORSHIFT].rgb.b;
	}

	return;
}



static void
display_buff() {
    /* If we ARE doing double buffering, it's time to switch		*/
    /* to the buffer we just finished drawing into;   else, don't	*/
    /* do anything.							*/

	switch(dbuffering) {
	  case NO_DBUFF:
	  default:
		if (color_type == XGL_COLOR_INDEX)
			xgl_object_set(ras, XGL_DEV_COLOR_MAP, cmap, 0);
		return;

	  case CMAP8_DBUFF:
	  case CMAP16_DBUFF:
		if(current_buffer_is_A) {
		    xgl_object_set(ras, XGL_DEV_COLOR_MAP, cmap_A, 0);
		    xgl_object_set(ctx_2d, XGL_CTX_PLANE_MASK, CMAP_MASK_B, 0);
		    xgl_object_set(ctx_3d, XGL_CTX_PLANE_MASK, CMAP_MASK_B, 0);
		} else {
		    xgl_object_set(ras, XGL_DEV_COLOR_MAP, cmap_B, 0);
		    xgl_object_set(ctx_2d, XGL_CTX_PLANE_MASK, CMAP_MASK_A, 0);
		    xgl_object_set(ctx_3d, XGL_CTX_PLANE_MASK, CMAP_MASK_A, 0);
		}
		current_buffer_is_A ^= 1;
		xgl_context_new_frame(ctx_3d);
		xgl_context_new_frame(ctx_2d);
		break;
	  case AB_DBUFF:
		xgl_context_new_frame(ctx_3d);
		xgl_context_new_frame(ctx_2d);
		break;
	}
}

#if 0
/******************************************************************
 *
 *	Miscellaneous Debug Code
 */

static struct timeval tp1, tp2;
static void
start_ts() {
	gettimeofday(&tp1);
}
static int
stop_ts() {
	gettimeofday(&tp2);
	return (((tp2.tv_sec*1000000 + tp2.tv_usec) -
                 (tp1.tv_sec*1000000 + tp1.tv_usec))/1000 );
}
static int
getms(struct timeval tp1, struct timeval tp2)
{
	return (((tp2.tv_sec*1000000 + tp2.tv_usec) - 
		 (tp1.tv_sec*1000000 + tp1.tv_usec))/1000 );
}
dump_pl(Xgl_pt_list *pl, int n)
{
 
        int i, j;
 
        for (i = 0; i < n; i++) {
                bu_log("PL[%d]: (%d pts)\n",i, pl[i].num_pts);
                for (j = 0; j < pl[i].num_pts; j++) {
                        bu_log( "       pt[%d]: %e,%e,%e, %d\n",j,
                                pl[i].pts.flag_f3d[j].x,
                                pl[i].pts.flag_f3d[j].y,
                                pl[i].pts.flag_f3d[j].z,
                                pl[i].pts.flag_f3d[j].flag);
                }
        }
}
#endif
@


11.5
log
@rt_list ---> bu_list
@
text
@d79 1
a79 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 11.4 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
@


11.4
log
@now using libbu
@
text
@d79 1
a79 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 11.3 1995/06/16 19:54:58 gdurf Exp bparker $ (BRL)";
d96 1
d593 1
a593 1
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
@


11.3
log
@Converted to rt_log
@
text
@d79 1
a79 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 11.2 1995/06/15 20:36:39 gdurf Exp gdurf $ (BRL)";
d120 1
a120 1
#define	DPRINTF(S)	if(XGL_debug_level) rt_log(S)
d933 1
a933 1
		rt_log("X_statechange: unknown state %s\n", 
d1086 1
a1086 1
	rt_log(stderr, "No commands implemented\n");
d1134 1
a1134 1
		rt_log("Could not open X display %s\n", XDisplayName(NULL));
d1197 1
a1197 1
		rt_log("Could not create X window\n");
d1216 1
a1216 1
	    rt_log("Couldn't get WM_PROTOCOLS or WM_DELETE_WINDOW atom\n");
d1261 1
a1261 1
          	rt_log("error in getting inquiry\n");
d1290 1
a1290 1
			rt_log("error in getting inquiry\n");
d1492 1
a1492 1
		rt_log("\nA total of %d buffers are supported by this\n", 
d1494 1
a1494 1
		rt_log("hardware. Hardware double buffering will be used.\n");
d1499 2
a1500 2
		rt_log("\nThis is a MONOCHROME frame buffer. No double \n");
		rt_log("buffering of any type can be used.\n\n");
d1507 1
a1507 1
		rt_log("\nUnknown frame buffer type ... aborting.\n\n");
d1512 1
a1512 1
			rt_log(
d1536 1
a1536 1
			       rt_log("Undefined DEFAULT_DB option,exiting\n");
d1624 1
a1624 1
			    		rt_vls_printf( 
d1635 1
a1635 1
			    rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
d1649 1
a1649 1
			    rt_vls_strcat( &dm_values.dv_string, "zoom 0.5\n");
d1653 1
a1653 1
			    rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n",
d1658 1
a1658 1
			    rt_vls_strcat( &dm_values.dv_string, "zoom 2\n");
d1674 1
a1674 1
			    rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
d1697 1
a1697 1
					rt_log( "\nKey Help Menu:\n\
d1722 1
a1722 1
					rt_vls_printf( &dm_values.dv_string,
d1745 1
a1745 1
					rt_vls_printf( &dm_values.dv_string,
d1749 1
a1749 1
					rt_vls_strcat( &dm_values.dv_string,
d1753 1
a1753 1
					rt_vls_strcat( &dm_values.dv_string,
d1757 1
a1757 1
					rt_vls_strcat( &dm_values.dv_string,
d1761 1
a1761 1
					rt_vls_strcat( &dm_values.dv_string,
d1765 1
a1765 1
					rt_vls_strcat( &dm_values.dv_string,
d1769 1
a1769 1
					rt_vls_strcat( &dm_values.dv_string,
d1773 1
a1773 1
					rt_vls_strcat( &dm_values.dv_string,
d1777 1
a1777 1
					rt_vls_strcat( &dm_values.dv_string,
d1788 1
a1788 1
					rt_log(
d1802 1
a1802 1
			rt_log( "Unknown event type\n" );
d1899 1
a1899 1
		rt_log( "val = %f, setting = %d\n",val, setting);
d1904 1
a1904 1
		    rt_vls_printf( &dm_values.dv_string , "knob xadc %d\n",
d1907 1
a1907 1
		    rt_vls_printf( &dm_values.dv_string , "knob x %f\n", val);
d1911 1
a1911 1
		    rt_vls_printf( &dm_values.dv_string , "knob yadc %d\n",
d1914 1
a1914 1
		    rt_vls_printf( &dm_values.dv_string , "knob y %f\n", val);
d1918 1
a1918 1
		    rt_vls_printf( &dm_values.dv_string , "knob ang2 %d\n",
d1921 1
a1921 1
		    rt_vls_printf( &dm_values.dv_string , "knob z %f\n", val);
d1925 1
a1925 1
		    rt_vls_printf( &dm_values.dv_string, "knob ang1 %d\n",
d1929 1
a1929 1
		rt_vls_printf( &dm_values.dv_string , "knob X %f\n", val);
d1932 1
a1932 1
		rt_vls_printf( &dm_values.dv_string , "knob Y %f\n", val);
d1936 1
a1936 1
		    rt_vls_printf( &dm_values.dv_string , "knob distadc %d\n",
d1939 1
a1939 1
		    rt_vls_printf( &dm_values.dv_string , "knob Z %f\n", val);
d1942 1
a1942 1
		rt_vls_printf( &dm_values.dv_string , "knob S %f\n", val);
d2006 1
a2006 1
		rt_log(
d2055 1
a2055 1
        rt_vls_printf( &dm_values.dv_string, "set perspective %d\n",
d2087 1
a2087 1
		rt_log(
d2147 1
a2147 1
		rt_vls_printf( &dm_values.dv_string,
d2183 1
a2183 1
	rt_vls_printf( &dm_values.dv_string,
d2190 1
a2190 1
	rt_log("Function Key Undefined\n");
d2197 1
a2197 1
	rt_vls_strcat( &dm_values.dv_string,
d2413 1
a2413 1
                rt_log("PL[%d]: (%d pts)\n",i, pl[i].num_pts);
d2415 1
a2415 1
                        rt_log( "       pt[%d]: %e,%e,%e, %d\n",j,
@


11.2
log
@Changed set call
@
text
@d79 1
a79 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 11.1 1995/01/04 10:03:00 mike Rel4_4 gdurf $ (BRL)";
d120 1
a120 1
#define	DPRINTF(S)	if(XGL_debug_level) (void)fprintf(stderr, S)
d933 1
a933 1
		(void)printf("X_statechange: unknown state %s\n", 
d1086 1
a1086 1
	fprintf(stderr, "No commands implemented\n");
d1134 1
a1134 2
		fprintf (stderr, "Could not open X display %s\n", 
			XDisplayName(NULL));
d1197 1
a1197 1
		fprintf (stderr, "Could not create X window\n");
d1216 1
a1216 2
		fprintf(stderr, 
			"Couldn't get WM_PROTOCOLS or WM_DELETE_WINDOW atom\n");
d1261 1
a1261 1
          	printf("error in getting inquiry\n");
d1290 1
a1290 1
			printf("error in getting inquiry\n");
d1492 1
a1492 1
		printf("\nA total of %d buffers are supported by this\n", 
d1494 1
a1494 1
		printf("hardware. Hardware double buffering will be used.\n");
d1499 2
a1500 2
		printf("\nThis is a MONOCHROME frame buffer. No double \n");
		printf("buffering of any type can be used.\n\n");
d1507 1
a1507 1
		printf("\nUnknown frame buffer type ... aborting.\n\n");
d1512 1
a1512 1
			printf(
d1536 2
a1537 2
				printf("Undefined DEFAULT_DB option,exiting\n");
				exit(1);
d1697 1
a1697 1
					fprintf( stderr, "\nKey Help Menu:\n\
d1788 2
a1789 2
					printf(
					  "dm-X:The key '%c' is not defined\n", 
d1802 1
a1802 1
			fprintf( stderr, "Unknown event type\n" );
d1899 1
a1899 1
		fprintf(stderr, "val = %f, setting = %d\n",val, setting);
d2006 1
a2006 1
		fprintf(stderr, 
d2087 1
a2087 1
		fprintf(stderr, 
d2190 1
a2190 1
	fprintf(stderr, "Function Key Undefined\n");
d2199 2
a2200 2
		"set faceplate=0\n" :
		"set faceplate=1\n" );
d2413 1
a2413 1
                fprintf(stderr, "PL[%d]: (%d pts)\n",i, pl[i].num_pts);
d2415 1
a2415 1
                        fprintf(stderr, "       pt[%d]: %e,%e,%e, %d\n",j,
@


11.1
log
@Release_4.4
@
text
@d79 1
a79 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.19 95/01/03 21:20:48 mike Exp $ (BRL)";
d2057 1
a2057 1
        rt_vls_printf( &dm_values.dv_string, "set perspective=%d\n",
d2150 1
a2150 1
       		"set perspective=%d\n", perspective_table[perspective_angle] );
@


10.19
log
@Latest version from Jim.
@
text
@d79 1
a79 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.18 94/12/30 04:06:23 mike Exp $ (BRL)";
@


10.18
log
@Latest version from Jim.
@
text
@a46 3
 *			Function keys are not currently activated, so that
 *			those can be used in the future for lighting, etc 
 *			similar to the SGI display module.
d79 1
a79 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.8 94/10/14 17:07:07 mike Exp $ (BRL)";
d130 1
a130 1
static void		handle_sundials_event();
d204 2
d220 1
a409 1
static Xgl_matrix_d3d	xgl_mat;
d417 1
d427 2
a428 3
	xgl_object_set(ctx_3d,
		XGL_CTX_LOCAL_MODEL_TRANS, trans,
		0);
d547 1
a547 1
	Xgl_color			solid_color;
a548 1
	static Xgl_color_index		last_color_index = DM_YELLOW;
d1009 3
d1298 8
d1439 1
a1439 1
	 * Turn z-buffering back off (off is the default).
d1443 2
a1444 1
	xgl_object_set (ctx_3d, XGL_3D_CTX_HLHSR_MODE, XGL_HLHSR_NONE, 0);
d1446 1
a1446 4
	trans = xgl_object_create(sys_state, XGL_TRANS, NULL,
			XGL_TRANS_DATA_TYPE, XGL_DATA_DBL,
			XGL_TRANS_DIMENSION, XGL_TRANS_3D,
			NULL);
d1448 9
a2093 13
		Xgl_pt_d3d	pos;
		double		w;

		/* 
		 * First, set the light position to the lower-right hand
		 * position, using the last 'w' value 
		 */
		w = xgl_mat[3][3];
		pos.x = pos.y = -w;
		pos.z = w;
		xgl_object_set (lights[1],
			XGL_LIGHT_POSITION, &pos,
			NULL);
d2116 26
d2219 1
a2219 1
		XGL_3D_CTX_SURF_FRONT_AMBIENT, 0.8,
d2237 2
@


10.17
log
@Latest version from Jim Fiori.
@
text
@d457 3
a459 2
 *  We use three Xgl_pt_list structures, one for solid polylines, one
 *  for dashed polylines, and one for polygons. The reason for much of this
d461 1
a461 1
 *  just drawn i polyline/solid, but one some Sun frame buffers, that's much
d466 1
a466 1
 *  we need that to indicate wheter or not to draw the line. The flag is only
d470 1
a470 1
static Xgl_pt_flag_f3d 	pl_norm_pts[MAX_PL_PTS];
d474 2
a475 1
static Xgl_pt_f3d      	pg_pts[MAX_PG_PTS];
d478 4
a481 3
static Xgl_pt_list pl_norm_list = {XGL_PT_FLAG_F3D, 0, 0, 0, 0};
static Xgl_pt_list pl_dash_list = {XGL_PT_FLAG_F3D, 0, 0, 0, 0};
static Xgl_pt_list pg_list = 	  {XGL_PT_F3D, 0, 0, 0, 0};
d486 4
a489 1
static Xgl_pt_f3d      	*pg_ptr = pg_pts;	/* ptr into polygon point arr*/
d491 1
a491 1
						   normal */
d500 1
a500 1
	if (pl_norm_list.num_pts) {\
d502 2
a503 2
		xgl_multipolyline(ctx_3d, NULL, 1, &pl_norm_list);\
		pl_norm_list.num_pts = 0;\
d515 2
a516 1
                        XGL_FACET_FLAG_SHAPE_UNKNOWN, &facet_list,\
d519 8
d540 1
a540 1
			pl_norm_list.num_pts++;
d554 1
d587 1
a587 1
		num_pts = pl_norm_list.num_pts;
d591 1
a591 1
		flag_f3d_ptr = &(pl_norm_list.pts.flag_f3d[num_pts]);
d609 2
d614 7
a620 2
				GrabPts(pg_ptr, pt);
				pg_list.num_pts++;
d626 6
d665 1
a665 1
	pl_norm_list.pts.flag_f3d = pl_norm_pts;
d668 1
d2087 1
a2087 1
		pos.z = -w;
d2092 2
a2093 3
		 * We specify illumination of per-facet (flat shading) since
		 * we don't have per-vertex normals we would need to do
		 * color (gouraud) shading
d2099 1
a2099 1
				XGL_ILLUM_PER_FACET,	/* flat shading */
@


10.16
log
@Eliminated old dm_values.dv_* style "polled" device interface.
Everything is done by string commands now.
@
text
@d82 1
a82 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.15 94/12/23 18:09:29 mike Exp Locker: mike $ (BRL)";
d112 1
d396 1
d400 4
d602 2
a620 1

a999 3

		/*xgl_context_new_frame(ctx_3d);*/
		/*xgl_context_new_frame(ctx_2d);*/
d1085 1
d1107 1
d1113 19
d1162 1
a1162 1
	*win = XCreateWindow (*dpy, DefaultRootWindow(*dpy),  0, 0, *w, *h,
d1170 1
a1170 1
	xsh.flags = (PSize);
d1173 2
d1341 1
d1387 1
d1397 9
d1646 3
a1648 1
			if (key >= XK_F1 && key <= XK_F10) 
d1905 1
a1905 1
	   fk_anti_alias(), fk_nop();
d1937 2
d1941 4
d2017 4
a2020 3
	dcue_on = 0; /* fk_depth_cue() will turn the flag back on */
	fk_depth_cue();
	
d2026 1
d2057 1
a2057 1
		pos.z = w;
d2121 8
@


10.15
log
@Made attach name lower case.
@
text
@d82 1
a82 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.14 94/12/23 16:58:34 mike Exp Locker: mike $ (BRL)";
a816 5

	/* "rest" state */
	dm_values.dv_buttonpress = 0;
	dm_values.dv_flagadc = 0;
	dm_values.dv_penpress = 0;
@


10.14
log
@This version should do perspective.
@
text
@d82 1
a82 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.8 94/10/14 17:07:07 mike Exp $ (BRL)";
d174 1
a174 1
	"XGL", "XGL (X11)",
@


10.13
log
@Latest (Thursday) version from Jim.
@
text
@d11 1
a11 1
 *		James Fiori
d59 6
a64 3
 *		Hardware double-buffering for TGX, SX, ZX
 *		Colormap double-buffering for GX frame buffers
 *		No double-buffering for S24
d75 5
d404 1
a408 1
	static Xgl_matrix_d3d	xgl_mat;
a414 11
	/*
	 * The following matrix is passed in:
	 *	1.0	0.0	0.0	Tx
	 *	0.0	1.0	0.0	Ty
	 *	0.0	0.0	1.0	Tz
	 *	0.0	0.0	0.0	W
	 *
	 * This (for some as yet unknown reason) produces very slow DGA results.
	 * So, we perform the rotation, translation, and scaling in 3 separate 
	 * calls. We use the W value for the scale factor.
	*/
d417 1
a417 1
	 * First, rotate it
d419 2
a420 28
	xgl_transform_identity(trans);

	xgl_transform_write_specific (trans, xgl_mat, 
                   		 XGL_TRANS_MEMBER_ROTATION);
	xgl_transform_transpose(trans, trans);

	/*
	 * Next, translate it
	 */
	pt.pt_type = XGL_PT_D3D;
	pt.pt.d3d = &pt_d3d;
	pt_d3d.x = xgl_mat[0][3];
	pt_d3d.y = xgl_mat[1][3];
	pt_d3d.z = xgl_mat[2][3];
	xgl_transform_translate (trans, &pt, XGL_TRANS_POSTCONCAT);

	/*
	 * Finally, scale it
	 */
	w = xgl_mat[3][3];
        pt.pt_type = XGL_PT_D3D;
        pt.pt.d3d = &pt_d3d;
        pt_d3d.x = 1.0/w;
        pt_d3d.y = 1.0/w;
        pt_d3d.z = 1.0/w;
 
        xgl_transform_scale (trans, &pt, XGL_TRANS_POSTCONCAT);

d1204 1
a1204 1
	win_desc.win_ras.type = XGL_WIN_X ;
d1226 18
a1381 1

d1912 7
a1918 1
	float scale_factors[2] = {1.0, 0.2}; /* Depth-cue scale factors */
d1930 3
a1932 1
			XGL_3D_CTX_DEPTH_CUE_SCALE_FACTORS, scale_factors,
d1972 7
d2005 2
d2008 10
a2017 1
		light_switches[0] = light_switches[1] = TRUE;
d2023 1
a2104 1
	Xgl_pt_d3d	pos;
a2125 3
	/* Put light at lower-left hand corner, out from screen */
	pos.x = pos.y = -1.0;
	pos.z = 1.0;
a2128 1
		XGL_LIGHT_POSITION, &pos,
@


10.12
log
@New version from Tim Smith et.al. at Sun.
@
text
@d40 1
a40 1
 *	Modified 11/94 to support XGL 3.X by Sun Microsystems Computer Company
d55 2
a56 2
 *		24-bit color (for SX, ZX)
 *		Lighting, Depth Cueing (for SX, ZX)
d59 3
d1375 7
d1446 37
a1482 28
		printf("\nUsing colormap double buffering, 8 bit color.\n");
		switch(DEFAULT_DB) {
		case OPTION_ZERO:
			type = NO_DBUFF;
			maxcolors = 2;
			colortablesize = 2;
			break;

		 case OPTION_ONE:
			type = NO_DBUFF;
			maxcolors = 128;
			colortablesize = 128;
			break;

		  case OPTION_TWO:
			type = CMAP8_DBUFF;
			maxcolors = 8;
			colortablesize = 64;
			break;

		  case OPTION_THREE:
			type = CMAP16_DBUFF;
			maxcolors = 16;
			colortablesize = 256;
			break;
		  default:
			printf("Undefined DEFAULT_DB option, exiting\n");
			exit(1);
@


10.11
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d4 1
a4 2
 *  An XGL interface for MGED on the Sun
 *  OpenWindows 2.0.
d7 6
a12 3
 *	Saul Wold
 *	John Cummings  
 *  
d14 4
a17 3
 *	SUN Microsystems, Inc.  
 *  	2550 Garcia Ave.
 *  	Mountain View, CA 94043
d19 50
a68 3
 *  Copyright Notices -
 *	This software is Copyright (C) 1990 by the United States Army.
 *	All rights reserved.
d71 1
a71 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.10 1994/12/01 23:06:57 mike Exp gdurf $ (BRL)";
d84 2
d100 3
a102 12
#define __EXTENSIONS__
#undef CONST	/* xview/xv_c_types.h re-defines this symbol */
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/termsw.h>
#include <xview/canvas.h>
#include <xview/textsw.h>
#include <xview/tty.h>
#include <xview/cms.h>
#include <xview/attr.h>
#include <xview/cursor.h>
#undef __EXTENSIONS__
a103 15
static unsigned short icon_bits[] = {
#include "./sunicon.h"
};

			/* struct button - describes one of our panel	*/
			/* 	buttons in convenient terms;  an array	*/
			/*	of these is used to describe all of 	*/
			/* 	our buttons.				*/
struct button {
	char		*label;			/* Panel_item label	*/
	char		*cmd;			/* associated mged cmd	*/
	int		(*button_proc)();	/* button procedure	*/
};


d111 1
a111 1
#define	DPRINTF(S)	if(XGL_debug_level) (void)rt_log( S)
a112 3



a113 34
 *	Command definitions for textsw child process
 */
#define	SET_POSITION	'\001'	/* re-position termsw - followed by 2 ints */
#define	SET_WIDTH	'\002'	/* set termsw width   - followed by 1 int  */
#define	SET_DISPLAY	'\003'	/* set termsw WIN_SHOW to true		   */

#define XGL_BUF_A	0	/* Used for double buffering */
#define XGL_BUF_B	1


/*
 *	Definitions for use with the F2-F8 function key buttons
 */
#define	ZOOM_BUTTON	2	/* F2 */
#define	X_SLEW_BUTTON	3	/* F3 */
#define	Y_SLEW_BUTTON	4	/* F4 */
#define	Z_SLEW_BUTTON	5	/* F5 */
#define	X_ROT_BUTTON	6	/* F6 */
#define	Y_ROT_BUTTON	7	/* F7 */
#define	Z_ROT_BUTTON	8	/* F8 */

#define	ZOOM_FLAG	0x01	/* These flags may be OR'ed in "sun_buttons" */
#define	X_SLEW_FLAG	0x02
#define	Y_SLEW_FLAG	0x04
#define	Z_SLEW_FLAG	0x08
#define	X_ROT_FLAG	0x10
#define	Y_ROT_FLAG	0x20
#define	Z_ROT_FLAG	0x40

int	sun_buttons = 0;	/* Which buttons are being held down?	    */



/*
a117 4
static void		init_create_icons();		/* create icons */
static void		init_termsw_child();		/* child setup */
static void		init_graphics_parent_xview();	/* parent setup */
static int		init_graphics_parent_xgl();	/* parent setup */
d119 3
a121 4
static int		init_editor();			/* set EDITOR */

						/* Miscellaneous	*/
static int		ok();				/* yes or no? */
a122 4
static int		input_poll();			/* polling select */
static void		set_termsw_width();		/* set termsw width */
static void		set_termsw_position();		/* set termsw x y */
static void		set_termsw_display();		/* WIN_SHOW TRUE */
a123 19
						/* Parent Xview functions */
static Notify_value	stop_func();			/* notify_stop() */
static Notify_value	destroy_func();			/* done */

static int		standard_button_proc();		/* cmd buttons */
static int		menu_button_proc();		/* menu button */
static int		detach_button_proc();		/* detach button */

static void		repaint_proc();			/* canvas repaint */
static void		resize_proc();			/* canvas resize */
static void		frame_event_proc();		/* frame event */
static void		pw_event_proc();		/* canvas event */
static void		set_sun_buttons();		/* canvas event */
static void		set_dm_values();		/* canvas event */

						/* Child Xview functions */
static Notify_value	copy_func();			/* I/O */
static Notify_value	signal_func();			/* pass signal */

d129 1
d131 2
d140 1
a140 1
int		XGL_object();
d162 4
a165 2
	1000.0,
	"XGL", "XGL (X11)"
d169 7
d177 1
d182 2
a183 3
static int		cmd_fd;			/* cmd file descriptor */
static int		pty_fd;			/* pty file descriptor */
static int		height, width;		/* canvas width & height */
a184 5
static int		detached_flag;		/* ON - termsw is detached */
static int		mouse_tracking;		/* ON - we are tracing mouse */
static int		busy;			/* ON - busy cursor showing */
static int		xpen;			/* mouse/pen location (x) */
static int		ypen;			/* mouse/pen location (y) */
a185 11
					/* Xview	*/
static Display		*display;		/* Display */
static Icon		icon;			/* Icon */
static Frame		frame;			/* Frame */
static Panel		panel;			/* Panel */
static Canvas		canvas;			/* Canvas */
static Xv_Window	pw;			/* Paint Window */
static Xv_Cursor	cursor_red;		/* Normal cursor */
static Xv_Cursor	cursor_busyred;		/* Busy cursor */
static Termsw		termsw;			/* Termsw (command window) */

d196 1
a196 6
 * Point List Arrays
 *
 *	We use on array for solid lines and 1 for dash lines. This allows
 *	us to batch the polylines into just a few calls to xgl_multipolyline.
 *	If we reach MAX_PT_LISTS point lists, we simply flush what we have and
 *	start another batch.
d198 1
a198 10
#define MAX_PT_LISTS	2000
static Xgl_usgn32	num_pt_lists = 0;	/* current number in pl[] */
static Xgl_usgn32	num_pt_dash_lists = 0;	/* current number in pl_dash[]*/
#define PolyLinesOutstanding (num_pt_lists || num_pt_dash_lists)
static Xgl_pt_list	pl[MAX_PT_LISTS];    	
				/* for xgl_multipolyline (solid) */
static Xgl_pt_list	pl_dash[MAX_PT_LISTS];    
				/* for xgl_multipolyline (dash) */
#define FlushPolyLines() if(PolyLinesOutstanding) \
		XGL_object ((struct solid *)0, (float *)0, 0.0, 0)
d200 3
d208 2
a214 3
static int		win_visual_class;	/* TrueColor, etc */
static int		win_depth;		/* 8, 24, etc */
static Xgl_color_type	color_type;		/* INDEX or RGB */
d216 2
d222 3
a234 15
/*
 * Flags that control the color type, double buffering, etc.
 *
 * DO_DOUBLE_BUFF:	If non-0, do hardware double buffering. 
 *
 * DO_DASH_LINES:	if non-0, we process dashed lines. This is only turned
 *			off for determining how much of a performance hit
 *			dashed lines cause (considerable on DGA!).
 *
 * DO_24_BIT:		if non-o, we use 24-bit color if available. 
 */
#define DO_DOUBLE_BUFF	1			/* flag to do h/w double buff.*/
#define DO_DASH_LINES	1			/* flag to do dash lines */							/* Dash lines slow things down*/
#define DO_24_BIT	1			/* 24-bit color  */

d257 10
a266 6
static int get_1_pt_list(struct solid *, Xgl_pt_list *);
static void free_pts(Xgl_pt_list *, int);
static void switch_bg_color();
static void start_ts();
static int stop_ts();
static int getms(struct timeval , struct timeval );
a267 1

d269 1
a269 1
 *	Miscellaneous defines
a270 3
					/* Yes and No */
#define NO	0
#define YES	1
d272 7
a278 5
					/* Display coordinate conversion: */
 					/*	GED is using -2048..+2048, */
 					/*	xview is 0..width, 0..height */
#define	SUNPWx_TO_GED(x) (((x)/(double)width-0.5)*4095)
#define	SUNPWy_TO_GED(x) (-((x)/(double)height-0.5)*4095)
d280 1
d282 14
d297 1
a297 1
 *	Buttons
d299 8
a306 6
		/* The "standard cmds" buttons should be tailered to	*/
		/* best meet the needs of the installation.  Unused buttons */
		/* should have 1 space as a label and a single newline as */
		/* the command.						*/
		/*							*/
struct button	button_list[] = {
a307 22
	{"STANDARD CMDS",	NULL,		NULL},

	{"E all",		"E all\n",	standard_button_proc},
	{"refresh",		"refresh\n",	standard_button_proc},
	{"debug",		"regdebug\n",	standard_button_proc},
	{"quit",		"q\n",		standard_button_proc},
	{"clear",		"Z\n",	        standard_button_proc},
	{" ",			"\n",		standard_button_proc},
	{" ",			"\n",		standard_button_proc},
	{" ",			"\n",		standard_button_proc},
	{" ",			"\n",		standard_button_proc},
	{" ",			"\n",		standard_button_proc},
	{" ",			"\n",		standard_button_proc},

	{"SPECIAL CMDS",	NULL,		NULL},

	{"menu toggle",		NULL,		menu_button_proc},
	{"detach",		NULL,		detach_button_proc},

	{NULL,			NULL,		NULL},
};

a319 4
	int		p0[2], p1[2], p3[2];
	int		pid;
	register int	fds;
	static int	once = 0;
d322 3
a324 6

	if(once++) {
		rt_log( "Cannot re-attach to XGL\n");
		return(-1);
	}

d327 3
a329 7
	pipe(p0);			/* set up 3 pipes for stdin, */
	pipe(p1);			/* stdout, and */
	pipe(p3);			/* a special "command" pipe */
	if((pid = fork()) < 0) {	/* FORK */
		perror("mged XGL_open");
		return(-1);
	}
d331 3
a333 11
	if(!pid) {		/* CHILD - the command terminal subwindow */
		cmd_fd = 3;
		dup2(p0[1], 1);		/* stdout to parent */
		dup2(p1[0], 0);		/* stdin from parent */
		dup2(p3[0], cmd_fd);	/* special "command" from parent */
#if defined(_SC_OPEN_MAX)
		fds = sysconf(_SC_OPEN_MAX);
#else
		fds = 32;
#endif
		for(; fds > 4; close(--fds));
d335 2
a336 5
		xv_init(0);		/* init xview */
		init_create_icons();	/* create icon */
		init_termsw_child(p0, p1, p3);	/* setup the term subwindow */
		notify_start(/*frame*/);	/* and, go */
		exit(0);		/* but, never return */
d338 2
a339 14
	} else {		/* PARENT - the canvas and panel */
		dup2(p0[0], 0);		/* stdin from child */
		dup2(p1[1], 1);		/* stdout to child */
		cmd_fd = p3[1];		/* special "command" to child */
		if(p0[0] != 0) close(p0[0]);
		if(p1[1] != 1) close(p1[1]);
		close(p0[1]);
		close(p1[0]);
		close(p3[0]);
		/*
		 * We must fork BEFORE the call to xgl_open()! Otherwise
		 * XGL gets very confused (as documented)
		 */
		if(fork()) exit(0);	/* "background" us */
d341 1
a341 22
		xv_init(0);		/* init xview */
		init_create_icons();	/* create icon */
		init_graphics_parent_xview(); /* setup xview stuff */
					      /* and, xgl stuff */
		if(init_graphics_parent_xgl(frame) < 0)
			goto bad_exit;
		xv_set(canvas,
			CANVAS_REPAINT_PROC,	repaint_proc,
			CANVAS_RESIZE_PROC,	resize_proc,
			0);

		if(init_editor() < 0)	/* set the EDITOR variable */
			goto bad_exit;

		return(0);		/* go back to GED */
	}

bad_exit:
	xv_destroy_safe(frame);
	xgl_close(sys_state);
	return(-1);
	
a349 2
	static int	once = 0;

d352 2
a353 5
	if(once++) return;

	dup2(2, 1);
	dup2(2, 0);
	xv_destroy_safe(frame);
d355 1
a365 1
start_ts();
d370 1
a370 1
    /* If we are NOT doing any double buffering, erase the canvas	*/
d386 1
a386 1
	FlushPolyLines();
d388 1
a388 33
    /* If we ARE doing double buffering, it's time to switch		*/
    /* to the buffer we just finished drawing into;   else, don't	*/
    /* do anything.							*/

	switch(dbuffering) {
	  case NO_DBUFF:
	  default:
		if (color_type == XGL_COLOR_INDEX)
			xgl_object_set(ras, XGL_DEV_COLOR_MAP, cmap, 0);
		return;

	  case CMAP8_DBUFF:
	  case CMAP16_DBUFF:
		if(current_buffer_is_A) {
		    xgl_object_set(ras, XGL_DEV_COLOR_MAP, cmap_A, 0);
		    xgl_object_set(ctx_2d, XGL_CTX_PLANE_MASK, CMAP_MASK_B, 0);
		    xgl_object_set(ctx_3d, XGL_CTX_PLANE_MASK, CMAP_MASK_B, 0);
		} else {
		    xgl_object_set(ras, XGL_DEV_COLOR_MAP, cmap_B, 0);
		    xgl_object_set(ctx_2d, XGL_CTX_PLANE_MASK, CMAP_MASK_A, 0);
		    xgl_object_set(ctx_3d, XGL_CTX_PLANE_MASK, CMAP_MASK_A, 0);
		}
		current_buffer_is_A ^= 1;
		xgl_context_new_frame(ctx_3d);
		xgl_context_new_frame(ctx_2d);
		break;
	  case AB_DBUFF:
		xgl_context_new_frame(ctx_3d);
		xgl_context_new_frame(ctx_2d);
		break;
	}
/*rt_log("XGL_epilog: %d ms from prolog\n", stop_ts());*/

a391 4
static void
switch_bg_color()
{
	Xgl_color	bg;
a392 5
	bg.index = COLORINDEX(DM_BLACK);
	xgl_object_set (ctx_2d, XGL_CTX_BACKGROUND_COLOR, &bg, 0);
	xgl_object_set (ctx_3d, XGL_CTX_BACKGROUND_COLOR, &bg, 0);
}

d397 1
a397 1
	static Xgl_matrix_f3d	xgl_mat;
d399 2
a400 2
        Xgl_pt_f3d           	pt_f3d;
	float			w;
d420 1
d428 5
a432 5
	pt.pt_type = XGL_PT_F3D;
	pt.pt.f3d = &pt_f3d;
	pt_f3d.x = xgl_mat[0][3];
	pt_f3d.y = xgl_mat[1][3];
	pt_f3d.z = xgl_mat[2][3];
d439 5
a443 5
        pt.pt_type = XGL_PT_F3D;
        pt.pt.f3d = &pt_f3d;
        pt_f3d.x = 1.0/w;
        pt_f3d.y = 1.0/w;
        pt_f3d.z = 1.0/w;
d476 6
d483 64
d553 1
a553 2
	Xgl_color			ln_color;

a554 1
	float				width_factor;
d556 3
a558 3
	static float			last_width_factor = 0.0;
	int				diff = 0;
static struct timeval tp1, tp2;
d562 7
a568 9
	if (sp) {
		/* Set the line color (s_dmindex was set in XGL_colorchange) */
		if(MONOCHROME) {
			color_index = 1;
		} else if(white) {
			color_index = DM_WHITE;
		} else {
			color_index = sp->s_dmindex;
		}
d570 9
a578 14
		SetColor(ln_color, color_index);

		/* And, the width. */
		if(white) {
			width_factor = 2.0;
		} else {
			width_factor = 1.0;
		}

		if (color_index  != last_color_index ||
	    	    width_factor != last_width_factor) {

			diff = 1;
		}
d580 8
a587 13

	if (sp == NULL || 
	    diff || 
	    num_pt_lists == MAX_PT_LISTS ||
	    num_pt_dash_lists == MAX_PT_LISTS) {
		if (num_pt_lists) {
			xgl_object_set(ctx_3d,
				XGL_CTX_LINE_STYLE,     XGL_LINE_SOLID,
				0);
			xgl_multipolyline(ctx_3d, NULL, 
					num_pt_lists, pl);
			free_pts (pl, num_pt_lists);
			num_pt_lists = 0;
d589 5
a593 8
		if (num_pt_dash_lists) {
			xgl_object_set(ctx_3d,
				XGL_CTX_LINE_STYLE,     XGL_LINE_PATTERNED,
				0);
			xgl_multipolyline(ctx_3d, NULL, 
					num_pt_dash_lists, pl_dash);
			free_pts (pl_dash, num_pt_dash_lists);
			num_pt_dash_lists = 0;
d595 1
a595 10
		if (diff) {
			xgl_object_set(ctx_3d,
               			XGL_CTX_LINE_COLOR,    &ln_color,
/* Don't use Line Width. It's not defined for 3D 
               	 		XGL_CTX_LINE_WIDTH_SCALE_FACTOR, width_factor,
*/
               	 		0);
			last_color_index = color_index;
			last_width_factor = width_factor;
		}
d597 1
a597 40

	if (sp) {
#if DO_DASH_LINES
		if (sp->s_soldash) {
			if (get_1_pt_list (sp, 
			    		&pl_dash[num_pt_dash_lists]) == 0) {
				rt_log( "mged XGL_object: no memory\n");
                		return 0;
        		}
			num_pt_dash_lists++;
		} else {
#endif
			if (get_1_pt_list (sp, &pl[num_pt_lists]) == 0) {
				rt_log( "mged XGL_object: no memory\n");
                		return 0;
        		}
			num_pt_lists++;
		}
#if DO_DASH_LINES
	}
#endif

	return(1);
}

static  int
get_1_pt_list(struct solid *sp, Xgl_pt_list *pt_list)
{

	struct rt_vlist         *vp;
	Xgl_pt_flag_f3d		*ptr;
	
	pt_list->pt_type = XGL_PT_FLAG_F3D;
	pt_list->num_pts = sp->s_vlen;
	if((pt_list->pts.flag_f3d = (Xgl_pt_flag_f3d *)calloc(
			sp->s_vlen, sizeof(Xgl_pt_flag_f3d)))
            		== (Xgl_pt_flag_f3d *)0)
                	return(0);
	ptr = pt_list->pts.flag_f3d;

d603 2
a604 1
                for( i = 0; i < nused; i++,cmd++,pt++,ptr++ )  {
d607 6
a614 7
                        case RT_VLIST_LINE_MOVE:
                                /* Move, not draw */
                                ptr->x = pt[0][0];
                                ptr->y = pt[0][1];
                                ptr->z = pt[0][2];
                                ptr->flag = 0x00;
                                continue;
d616 3
d620 8
d629 4
a632 5
                                /* draw */
                                ptr->x = pt[0][0];
                                ptr->y = pt[0][1];
                                ptr->z = pt[0][2];
                                ptr->flag = 0x01;
d639 1
d641 1
a641 1
free_pts(Xgl_pt_list pt_list[], int num)
d643 5
a647 1
	int	i;
d649 13
a661 2
	for (i = 0; i < num; i++) 
		free (pt_list[i].pts.flag_f3d);
a663 1

d707 1
a707 1
	FlushPolyLines();
d713 1
a713 1
		ln_color.index;
d743 1
a743 1
	FlushPolyLines();
a784 3
	static int		once = 0;
	struct itimerval	timeout;
	fd_set          files;
d786 5
a790 1
	DPRINTF("XGL_input\n");
d792 4
a795 2
	files = *input;         /* save, for restore on each loop */
        FD_SET( display->fd, &files );      /* check X fd too */
d797 2
a798 6
	if(!once++) {
						/* first time through */
		xv_set(frame, WIN_SHOW,	TRUE, 0); /* display the canvas */
		XFlush(display);
		set_termsw_display();		/* and, the command window */
	}
d800 22
a821 5
	if(busy) {				/* if busy cursor is up, */
		busy = 0;			/* change to normal cursor */
		xv_set(pw,    WIN_CURSOR, cursor_red,  0);
		XFlush(display);
	}
d823 22
d846 2
a847 2
	dm_values.dv_flagadc     = 0;
	dm_values.dv_penpress    = 0;
d849 2
a850 3
    /* If there is a command waiting  to be read, have the notifier call */
    /* stop_func() which will call notify_stop(), so we can get back to ged */
    /*									*/
a851 33
	notify_set_input_func(frame, stop_func, fileno(stdin) /* input_fd */);
	notify_set_input_func(frame, stop_func, display->fd /* input_fd */);

	if(noblock) {

    /* If we are not using any type of double buffering, slow it down */
    /* a bit so the user isn't too confused by the constant jerkiness */
    /*									*/
		if(!dbuffering)
			sleep(1);

    /* It would be nice to be able to use notify_dispatch() here.	*/
    /* But, we seem to drop a lot of events if that happens.   In fact,	*/
    /* using notify_dispatch() here can cause openwin to completely	*/
    /* lock up.								*/
    /*									*/
    /* Using notify_start() and nofify_stop() seems to work best.	*/
    /*									*/
		bzero((char *)&timeout, sizeof(timeout));
		timeout.it_value.tv_usec = 1L;
		notify_set_itimer_func(pw, stop_func, ITIMER_VIRTUAL,
			&timeout, NULL);
		notify_start();
	} else {
		notify_start();
		xv_set(pw,    WIN_CURSOR, cursor_busyred,   0);
		++busy;
	}
	XFlush(display);

	/* XXX This won't work well, do select() here! */
	if (!input_poll(fileno(stdin)))
		FD_CLR(fileno(stdin), input);
d901 6
a906 2

	switch(newstate) {
d908 4
a911 1
		mouse_tracking = 0;
d913 1
a913 1

d916 4
a919 2
	case ST_S_PICK:
		mouse_tracking = 1;
a920 1

d923 4
a926 1
		mouse_tracking = 0;
a927 1

d929 3
a931 2
		DPRINTF("XGL_statechange:  UNKNOWN STATE\n");
		return;
a932 2
	if(XGL_debug_level) rt_log( "XGL_statechange from %s to %s\n",
		state_str[oldstate], state_str[newstate]);
d959 1
d985 1
a985 1
				sp->s_dmindex = i;
d1020 7
a1026 1
 
a1050 1
	Xgl_bounds_d2d	bounds_d2d;
d1078 3
d1082 5
a1099 2
	detached_flag	= 0;
	mouse_tracking	= 0;
a1100 1
	busy		= 1;
d1103 1
a1103 4
static void
init_create_icons()
{
	Server_image	icon_image;
d1105 2
a1106 14
	icon_image = (Server_image)xv_create(XV_NULL, SERVER_IMAGE,
		XV_WIDTH,		64,
		XV_HEIGHT,		64,
		SERVER_IMAGE_BITS,	icon_bits,
		0);
	icon  = (Icon)xv_create(XV_NULL, ICON,
		ICON_IMAGE,		icon_image,
		0);

	return;
}

static void
init_termsw_child()
d1108 17
a1124 4
	frame = (Frame)xv_create(XV_NULL, FRAME,
		FRAME_ICON,		icon,
		FRAME_LABEL,		"MGED Display",
		0);
a1125 1
        display = (Display *)xv_get(frame, XV_DISPLAY);
d1127 10
a1136 7
	termsw = (Termsw)xv_create(frame, TERMSW,
		TTY_ARGV,		TTY_ARGV_DO_NOT_FORK,
		WIN_ROWS,		10,
		0);
	pty_fd = (int)xv_get(termsw, TTY_TTY_FD);
	setsid();
	tcsetpgrp(pty_fd, getpgrp(0));
d1138 3
a1140 37
	window_fit(frame);

	notify_set_input_func(frame, copy_func, 0);
	notify_set_input_func(frame, copy_func, pty_fd);
	notify_set_input_func(frame, copy_func, cmd_fd);

	notify_set_signal_func(frame, signal_func, SIGINT, NOTIFY_SYNC);

	return;
}

static void
init_graphics_parent_xview()
{
	register struct button	*butts;
	Panel_item		last_button;
	int			y;
	Xv_singlecolor		redish;
	XVisualInfo		visual_info;

	frame = (Frame)xv_create(XV_NULL, FRAME,
		WIN_DYNAMIC_VISUAL,	TRUE,
		OPENWIN_AUTO_CLEAR,	FALSE,
		FRAME_ICON,		icon,
		FRAME_LABEL,		"MGED Display",
		WIN_EVENT_PROC,		frame_event_proc,
		WIN_CONSUME_EVENTS,	WIN_NO_EVENTS,
					WIN_RESIZE,
					WIN_REPAINT,
					0,
		0);
	notify_interpose_destroy_func(frame, destroy_func);

        display = (Display *)xv_get(frame, XV_DISPLAY);
#if DO_24_BIT
	/*
	 * Get the visual information
d1142 11
a1152 34
	if (XMatchVisualInfo (display, DefaultScreen(display),
		24, TrueColor, &visual_info) ||
	    XMatchVisualInfo (display, DefaultScreen(display),
		24, DirectColor, &visual_info)) {

		win_visual_class = visual_info.class;
		win_depth = 24;

	} else {
		win_visual_class = DefaultVisual(display, 
				DefaultScreen(display))->class;
		win_depth = DisplayPlanes (display, DefaultScreen(display));
	}
/*rt_log( "Visual Class is %d, depth = %d\n",win_visual_class,win_depth);*/
#endif
	panel = (Panel)xv_create(frame, PANEL,
		PANEL_LAYOUT,		PANEL_VERTICAL,
		0);

	last_button = (Panel_item)0;
	for(butts = button_list; butts->label != NULL; ++butts) {
		if(butts->button_proc == NULL) {
			if(last_button == (Panel_item)0) {
				y = 15;
			} else {
				y = (int)xv_get(last_button, PANEL_ITEM_Y) +
				    (int)xv_get(last_button, XV_HEIGHT)    +
				    30;
			}
			xv_create(panel, PANEL_MESSAGE,
				PANEL_LABEL_STRING,	butts->label,
				XV_Y,			y,
				0);
			continue;
d1154 7
a1161 7
		last_button = (Panel_item)xv_create(panel, PANEL_BUTTON,
			PANEL_LABEL_STRING,		butts->label,
			PANEL_LABEL_WIDTH,		100,
			PANEL_CLIENT_DATA,		butts->cmd,
			PANEL_NOTIFY_PROC,		butts->button_proc,
			XV_X,				30,
			0);
a1162 1
	window_fit_width(panel);
d1164 3
d1168 3
a1170 14
	canvas = (Canvas)xv_create(frame, CANVAS,
		WIN_RIGHT_OF,		panel,
		XV_HEIGHT,		height,
		XV_WIDTH,		width,
		XV_HELP_DATA,		"dm-XGL:canvas",
#if DO_24_BIT
		XV_DEPTH,		win_depth,
		XV_VISUAL_CLASS,	win_visual_class,
#endif
		CANVAS_AUTO_CLEAR, FALSE,
		CANVAS_FIXED_IMAGE, FALSE,
		CANVAS_RETAINED,	FALSE,
		0);
	pw = (Xv_Window)canvas_paint_window(canvas);
d1172 13
a1184 3
	redish.red   = 255;
	redish.green =  80;
	redish.blue  =   0;
d1186 8
a1193 4
	cursor_red     = (Cursor)xv_create(XV_NULL, CURSOR,
		CURSOR_SRC_CHAR,		OLC_BASIC_PTR,
		CURSOR_FOREGROUND_COLOR,	&redish,
		0);
d1195 20
a1214 22
	cursor_busyred = (Cursor)xv_create(XV_NULL, CURSOR,
		CURSOR_SRC_CHAR,		OLC_BUSY_PTR,
		CURSOR_FOREGROUND_COLOR,	&redish,
		0);

	xv_set(pw,
		WIN_EVENT_PROC,		pw_event_proc,
		WIN_CONSUME_EVENTS,	WIN_NO_EVENTS,
					WIN_TOP_KEYS,
					WIN_UP_EVENTS,
					WIN_MOUSE_BUTTONS,
					LOC_WINENTER,
					LOC_MOVE,
					WIN_RESIZE, WIN_REPAINT,
					0,
		WIN_CURSOR,		cursor_busyred,
		0);

	window_fit(frame);

	return;
}
d1216 2
a1217 3
static int
init_graphics_parent_xgl(frame)
Frame	frame;
d1219 1
a1219 4
        Atom		catom;
	Window		frame_window;
	Window		canvas_window;
	Xgl_color	ln_color;
d1223 2
d1226 3
a1228 2
	canvas_window = (Window)xv_get(pw, XV_XID);
	frame_window = (Window)xv_get(frame, XV_XID);
a1229 13
#if 0
	/* Set the window background */
	XSetWindowBackground(display, 
		canvas_window, BlackPixel(display,DefaultScreen(display))); 
#endif
	catom = XInternAtom(display, "WM_COLORMAP_WINDOWS", False);
	XChangeProperty(display, frame_window, catom, XA_WINDOW, 32,
		PropModeAppend, (unsigned char *)&canvas_window, 1);

	xgl_x_win.X_display = (void *)XV_DISPLAY_FROM_WINDOW(pw);
	xgl_x_win.X_window = (Xgl_usgn32)canvas_window;
	xgl_x_win.X_screen = (int)DefaultScreen(display);

d1234 1
a1234 2
{
       Xgl_inquire          *inq_info;
d1236 2
a1237 2
          rt_log("error in getting inquiry\n");
          exit(1);
a1239 5
}
    if (win_depth == 24)
	color_type = XGL_COLOR_RGB;
    else
	color_type = XGL_COLOR_INDEX;
d1241 15
a1255 1
    /* ras MUST be created before init_check_buffering() is called */
a1256 1
		XGL_RAS_COLOR_TYPE, color_type,
d1287 1
d1315 2
a1316 2
	bounds_d3d.zmax = 1.;
	bounds_d3d.zmin = -1.;	
d1319 17
a1335 10
			XGL_CTX_DEVICE,		ras,
			XGL_CTX_LINE_COLOR,	&ln_color,
			XGL_CTX_VDC_MAP,	XGL_VDC_MAP_ASPECT,
			XGL_CTX_VDC_ORIENTATION, XGL_Y_UP_Z_TOWARD,
			XGL_CTX_VDC_WINDOW,	&bounds_d3d,
			XGL_CTX_CLIP_PLANES,	XGL_CLIP_XMIN | XGL_CLIP_YMIN,
                        XGL_CTX_LINE_PATTERN,   xgl_lpat_dashed,
			XGL_CTX_LINE_STYLE,	XGL_LINE_SOLID,
			XGL_CTX_DEFERRAL_MODE, XGL_DEFER_ASTI,
			0);
d1342 1
a1343 1
	/*switch_bg_color();*/
d1350 5
d1369 2
a1370 1
			    | XGL_CTX_NEW_FRAME_SWITCH_BUFFER),
d1374 4
a1377 1
	trans = xgl_object_create(sys_state, XGL_TRANS, NULL, NULL);
d1379 13
a1394 1

a1407 1
#if DO_DOUBLE_BUFF
a1411 1
#endif
d1417 3
a1420 3
	rt_log("\nA total of %d buffers are supported by this\n", nbufs);
	rt_log("hardware.  Hardware double buffering will be turned on.\n");

a1421 1

d1424 2
a1425 2
	rt_log("\nThis is a MONOCHROME frame buffer.  No double buffering\n");
	rt_log("of any type can be used.\n\n");
d1432 1
a1432 3

	rt_log("\nUnknown frame buffer type ... aborting.\n\n");

d1436 1
a1436 3

		rt_log("\nUsing colormap double buffering, 8 bit color.\n");

d1462 1
a1462 1
			rt_log("Undefined DEFAULT_DB option, exiting\n");
d1468 8
a1475 3

static int
init_editor()
d1477 7
a1483 3
	char		*openwinhome, *editor;
	static char	buff[80];
	FILE		*file;
d1485 6
a1490 5
	if((editor = getenv("EDITOR")) != NULL) {
		if((openwinhome = getenv("OPENWINHOME")) == NULL) {
			rt_log(
			    "mged XGL_open:  $OPENWINHOME not set\n");
			return(-1);
d1492 31
a1522 12
		if((file = fopen("/tmp/MGED.editor", "w+")) == NULL) {
			perror("mged XGL_open");
			return(-1);
		}
		fchmod(fileno(file), 0755);
		fprintf(file, "#!/bin/sh\n");
		fprintf(file, "%s/bin/xview/shelltool %s $1\n", openwinhome, editor);
		fclose(file);
		strcpy(buff, "EDITOR=/tmp/MGED.editor");
	} else {
		strcpy(buff, "EDITOR=/bin/ed");
	}
d1524 21
a1544 6
	if(putenv(buff)) {
		perror("mged XGL_open");
		return(-1);
	}
	return(0);
}
d1546 8
a1553 29

/************************************************************************
 *									*
 * 	MISCELLANEOUS							*
 *									*
 ************************************************************************/

static int
ok(defalt)
int	defalt;
{
	char	line[80];

	for(;;) {
		rt_log("Is it OK to proceed [%s]? ",
			(defalt == YES) ? "yes" : "no");
		(void)fgets( line, sizeof(line), stdin ); /* \n, null terminated */
		line[strlen(line)-1] = '\0';		/* remove newline */
		if(feof(stdin)) continue;
		switch(*line) {
		  case '\0':
			return(defalt);
		  case 'y':
		  case 'Y':
			return(YES);
		  case 'n':
		  case 'N':
			return(NO);
		  default:
d1555 47
a1601 3
		}
	}
}
d1603 2
a1604 5
static void
setcolortables(color_table_A, color_table_B)
Xgl_color	*color_table_A, *color_table_B;
{
	register int	i;
d1606 46
a1651 5
	for(i = maxcolors; i < colortablesize; i++) {
		color_table_A[i].rgb.r = color_table_A[i & CMAP_MASK_A].rgb.r;
		color_table_A[i].rgb.g = color_table_A[i & CMAP_MASK_A].rgb.g;
		color_table_A[i].rgb.b = color_table_A[i & CMAP_MASK_A].rgb.b;
	}
d1653 65
a1717 4
	for(i = 0; i < colortablesize; i++) {
		color_table_B[i].rgb.r = color_table_A[i >> COLORSHIFT].rgb.r;
		color_table_B[i].rgb.g = color_table_A[i >> COLORSHIFT].rgb.g;
		color_table_B[i].rgb.b = color_table_A[i >> COLORSHIFT].rgb.b;
a1718 2

	return;
d1721 33
a1753 7
static int
input_poll(fd)
int	fd;
{
	fd_set		readfds;
	struct timeval	timeout;
	int		width;
d1755 4
a1758 3
	bzero((char *)&timeout, sizeof(timeout));
	FD_ZERO(&readfds);
	FD_SET(fd, &readfds);
d1760 4
a1763 5
#if defined(_SC_OPEN_MAX)
	width = sysconf(_SC_OPEN_MAX);
#else
	width = 32;
#endif
a1764 7
	if(select(width, &readfds, NULL, NULL, &timeout) > 0) {
		return(1);
	} else {
		return(0);
	}
}

d1766 1
a1766 2
set_termsw_width(w)
int	w;
d1768 5
a1772 7
	char	c;

	c = SET_WIDTH;
	write(cmd_fd, &c, 1);
	write(cmd_fd, &w, sizeof(w));

	return;
d1776 1
a1776 2
set_termsw_position(x, y)
int	x, y;
a1777 1
	char	c;
d1779 3
a1781 4
	c = SET_POSITION;
	write(cmd_fd, &c, 1);
	write(cmd_fd, &x, sizeof(x));
	write(cmd_fd, &y, sizeof(y));
d1783 1
a1783 2
	return;
}
d1785 5
a1789 4
static void
set_termsw_display()
{
	char	c;
d1791 2
a1792 3
	c = SET_DISPLAY;
	write(cmd_fd, &c, 1);
}
d1794 4
d1799 9
a1807 6

/************************************************************************
 *									*
 * 	XVIEW ROUTINES FOR THE PARENT PROCESS				*
 *									*
 ************************************************************************/
d1809 5
a1813 3
/*
 *	Notifier funcs
 */
d1815 45
d1861 5
a1865 4
static Notify_value
stop_func(client, fd)
Notify_client	client;
int		fd;
a1866 3
/*rt_log("stop_func:calling notify_stop()\n");*/
	notify_stop();
/*rt_log("stop_func:back from notify_stop()\n");*/
d1868 30
a1897 1
	return(NOTIFY_DONE);
d1899 2
a1900 5

static Notify_value
destroy_func(client, status)
Notify_client client;
Destroy_status status;
d1902 23
a1924 1
	static int	once = 0;
d1926 3
a1928 5
	if(once++) return(NOTIFY_DONE);

	quit();	

	return(NOTIFY_DONE);
d1930 2
a1931 10


/*
 *	Button procs
 */

static int
standard_button_proc(item, event)
Panel_item	item;
Event		*event;
d1933 1
a1933 1
	char	*buff;
d1935 14
a1948 4
	buff = (char *)xv_get(item, PANEL_CLIENT_DATA);
	write(cmd_fd, buff, strlen(buff));
	
	return(0);
d1950 2
a1951 5

static int
menu_button_proc(item, event)
Panel_item	item;
Event		*event;
d1953 4
a1956 2
	no_2d_flag ^= 0x01;

a1957 3
	stop_func((Notify_client)0, 0);

	return(0);
d1959 2
a1960 5

static int
detach_button_proc(item, event)
Panel_item	item;
Event		*event;
d1962 21
a1982 2
	int	h, x, y;
	Rect	r;
d1984 11
a1994 8
	detached_flag ^= 0x01;

	frame_get_rect (frame, &r);
	h = r.r_height;
	x = r.r_left;
	y = r.r_top + h;
	if(detached_flag) {
		xv_set(item, PANEL_LABEL_STRING, "attach", 0);
d1996 5
a2000 2
		xv_set(item, PANEL_LABEL_STRING, "detach", 0);
		set_termsw_width((int)xv_get(frame, XV_WIDTH));
d2002 2
a2003 1
	set_termsw_position(x, y);
a2004 1
	return(0);
a2005 6


/*
 *	Resize and Repaint
 */

d2007 1
a2007 4
repaint_proc(canvas, paint_window, repaint_area)
Canvas		canvas;
Xv_Window	paint_window;
Rectlist	*repaint_area;
d2009 7
a2015 2
	DPRINTF("repaint_proc\n");

a2016 1
	stop_func((Notify_client)0, 0);
a2017 1
	return;
d2019 5
d2026 1
a2026 3
resize_proc(canvas, w, h)
Canvas		canvas;
int		w, h;
a2027 1
	DPRINTF("resize_proc\n");
d2029 14
a2042 9
	width  = w;
	height = h;

	if(width < height) height = width;
	if(height < width) width  = height;

	XSync (display, 0);
	xgl_window_raster_resize(ras);

d2044 1
a2044 1
	stop_func((Notify_client)0, 0);
d2046 4
a2049 1
	return;
d2052 13
a2064 2
/*
 *	Event handlers
d2068 1
a2068 4
frame_event_proc(win, event, arg)
Window	win;
Event	*event;
caddr_t	*arg;
d2070 2
a2071 2
	int		h, x, y;
	Rect	r;
d2073 13
a2085 3
	switch(event_id(event)) {
	case WIN_RESIZE:
		if(detached_flag) break;
d2087 17
a2103 10
		frame_get_rect (frame, &r);
		h = r.r_height;
		x = r.r_left;
		y = r.r_top + h;
		set_termsw_position(x, y);
		set_termsw_width((int)xv_get(frame, XV_WIDTH));
		break;
	default:
		break;
	}
d2106 7
d2114 1
a2114 4
pw_event_proc(win, event, arg)
Window	win;
Event	*event;
caddr_t	*arg;
a2115 9
	struct itimerval	timeout;
	int			x, y;


	x = event_x(event);
	y = event_y(event);

	if(x >= width)  x = width  - 1;
	if(y >= height) y = height - 1;
d2117 7
a2123 2
	xpen = SUNPWx_TO_GED(x);
	ypen = SUNPWy_TO_GED(y);
d2125 7
a2131 27
	switch(event_id(event)) {
	case WIN_RESIZE:
		break;
	case WIN_REPAINT:
		break;
	case ACTION_SELECT:
	case MS_LEFT:
		if (event_is_down(event)) {
			rt_vls_strcat( &dm_values.dv_string , "zoom .5\n" );
			stop_func((Notify_client)0, 0);
		}
		break;
	case ACTION_ADJUST:
	case MS_MIDDLE:
		if (!no_2d_flag && event_is_down(event)) {
			rt_vls_printf(  &dm_values.dv_string , "M 1 %d %d\n", 
				xpen, ypen );
			stop_func((Notify_client)0, 0);
		}
	 	break;
	case ACTION_MENU:
	case MS_RIGHT:
		if (event_is_down(event)) {
			rt_vls_strcat( &dm_values.dv_string , "zoom 2\n" );
			stop_func((Notify_client)0, 0);
		}
		break;
d2133 2
a2134 5
	case LOC_WINENTER:
		break;
	case LOC_MOVE:
		if(sun_buttons)
			set_dm_values();
d2136 10
a2145 11
	/*********************************************************************/
	/* Delay the effect of mouse tracking to make things smoother.	     */
	/*********************************************************************/
		if(mouse_tracking || sun_buttons) {
			rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
                                xpen, ypen );
			bzero((char *)&timeout, sizeof(timeout));
			timeout.it_value.tv_usec = 500000L;
			notify_set_itimer_func(pw, stop_func, ITIMER_REAL,
		    		&timeout, NULL);
		}
d2147 10
a2156 1
		break;
d2158 20
a2177 3
	case KEY_TOP(ZOOM_BUTTON):
		set_sun_buttons(event, ZOOM_FLAG);
		break;
a2178 3
	case KEY_TOP(X_SLEW_BUTTON):
		set_sun_buttons(event, X_SLEW_FLAG);
		break;
d2180 6
a2185 3
	case KEY_TOP(Y_SLEW_BUTTON):
		set_sun_buttons(event, Y_SLEW_FLAG);
		break;
a2186 3
	case KEY_TOP(Z_SLEW_BUTTON):
		set_sun_buttons(event, Z_SLEW_FLAG);
		break;
a2187 19
	case KEY_TOP(X_ROT_BUTTON):
		set_sun_buttons(event, X_ROT_FLAG);
		break;

	case KEY_TOP(Y_ROT_BUTTON):
		set_sun_buttons(event, Y_ROT_FLAG);
		break;

	case KEY_TOP(Z_ROT_BUTTON):
		set_sun_buttons(event, Z_ROT_FLAG);
		break;

	default:
		break;

	}
	return;
}

d2189 2
a2190 3
set_sun_buttons(event, button_flag)
Event	*event;
int	button_flag;
d2192 1
a2192 9
	if(event_is_up(event)) {
		sun_buttons &= ~button_flag;
	} else if(event_is_down(event)) {
		sun_buttons |= button_flag;
	}
	set_dm_values();
	stop_func((Notify_client)0, 0);
	return;
}
d2194 4
a2197 17
static void
set_dm_values()
{
	float		xval, yval, zoomval;
	char		str_buf[128];

	if(sun_buttons) {
		xval = (float) xpen / 2048.;
		if (xval < -1.0) xval = -1.0;
		if (xval > 1.0)  xval = 1.0;

		yval = (float) ypen / 2048.;
		if (yval < -1.0) yval = -1.0;
		if (yval > 1.0)  yval = 1.0;

		zoomval = (yval * yval) / 2;
		if(yval < 0) zoomval = -zoomval;
d2200 4
a2203 4
	if(sun_buttons & ZOOM_FLAG)
	{
		(void)sprintf( str_buf , "zoom %f\n", zoomval );
		rt_vls_strcat( &dm_values.dv_string , str_buf );
a2204 30
	if(sun_buttons & X_SLEW_FLAG)
	{
		(void)sprintf( str_buf , "knob X %f\n", xval );
		rt_vls_strcat( &dm_values.dv_string , str_buf );
	}
	if(sun_buttons & Y_SLEW_FLAG)
	{
		(void)sprintf( str_buf , "knob Y %f\n", yval );
		rt_vls_strcat( &dm_values.dv_string , str_buf );
	}
	if(sun_buttons & Z_SLEW_FLAG)
	{
		(void)sprintf( str_buf , "knob Z %f\n", yval );
		rt_vls_strcat( &dm_values.dv_string , str_buf );
	}
	if(sun_buttons & X_ROT_FLAG)
	{
		(void)sprintf( str_buf , "knob x %f\n", xval );
		rt_vls_strcat( &dm_values.dv_string , str_buf );
	}
	if(sun_buttons & Y_ROT_FLAG)
	{
		(void)sprintf( str_buf , "knob Y %f\n", yval );
		rt_vls_strcat( &dm_values.dv_string , str_buf );
	}
	if(sun_buttons & Z_ROT_FLAG)
	{
		(void)sprintf( str_buf , "knob Z %f\n", yval );
		rt_vls_strcat( &dm_values.dv_string , str_buf );
	}
a2208 1

a2209 5
/************************************************************************
 *									*
 * 	XVIEW ROUTINES FOR THE CHILD PROCESS				*
 *									*
 ************************************************************************/
d2211 5
a2215 12
/*
 *	Notifier funcs
 */
#define IGNORED_MSG	"The \'%\' command is ignored in this environment...\n"
static Notify_value
copy_func(client, ifd)
Notify_client	client;
int		ifd;
{
	int		ofd, i, x, y, w;
	char		c;
	static char	b = '\n';
d2217 6
a2222 6
	if(ifd == 0)
		ofd = pty_fd;
	else if(ifd == pty_fd)
		ofd = 1;
	else if(ifd == cmd_fd)
		ofd = -1;
d2224 6
a2229 37
	while(input_poll(ifd)) {
		if((i = read(ifd, &c, 1)) < 0) {
			perror("mged XGL termsw read");
			sleep(5);
			exit(1);
		}
		if(!i) {
			xv_destroy_safe(frame);
			return(NOTIFY_DONE);
		}
		if(ifd == cmd_fd) {
			if(isprint(c) || isspace(c)) {
				ttysw_input(termsw, &c, 1);
			} else {
				switch(c) {
				   case SET_POSITION:
					read(ifd, (char *)&x, sizeof(x));
					read(ifd, (char *)&y, sizeof(y));
					xv_set(frame,
						XV_X,		x,
						XV_Y,		y,
						0);
					break;
	
				   case SET_WIDTH:
					read(ifd, (char *)&w, sizeof(w));
					xv_set(frame, XV_WIDTH, w, 0);
					break;
	
				   case SET_DISPLAY:
					xv_set(frame, WIN_SHOW, TRUE, 0);
					break;
	
				   default:
					break;
				}
			}
d2231 3
a2233 17
			if(ofd == 1) {
    /*									*/
    /* Ignore the "Escape to shell command";   it only causes problems,	*/
    /* and there is really no need for it in an Openwindows environment	*/
    /*									*/
				if(isspace(b) && (c == '%')) {
				    write(pty_fd, IGNORED_MSG,
					sizeof(IGNORED_MSG));
			    	    continue;
				}
				b = c;
			}
			if(write(ofd, &c, 1) < 0) {
				perror("mged XGL termsw write");
				sleep(5);
				exit(1);
			}
d2235 8
a2242 3

    /* get back to the notifier, in case we have a lot of stuff to read */
	if(c == '\n') break;
a2243 2
		
	return(NOTIFY_DONE);
d2246 5
a2250 7
static Notify_value
signal_func(client, sig, when)
Notify_client		client;
int			sig;
Notify_signal_mode	when;
{
	kill(getppid(), sig);
a2251 4
	return(NOTIFY_DONE);
}


a2268 1

d2271 15
a2285 16

	int i, j;

	for (i = 0; i < n; i++) {
		rt_log( "PL[%d]: (%d pts)\n",i, pl[i].num_pts);
		for (j = 0; j < pl[i].num_pts; j++) {
			rt_log( "	pt[%j]: %f,%f,%f, %d\n",
				pl[i].pts.flag_f3d[j].x,
				pl[i].pts.flag_f3d[j].y,
				pl[i].pts.flag_f3d[j].z,
				pl[i].pts.flag_f3d[j].flag);
		}
	}
}

	
@


10.10
log
@xview/xv_c_types.h re-defines CONST
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.9 94/11/30 15:45:42 mike Exp Locker: mike $ (BRL)";
d83 1
a83 1
#define	DPRINTF(S)	if(XGL_debug_level) (void)fprintf(stderr, S)
d394 1
a394 1
		fprintf(stderr, "Cannot re-attach to XGL\n");
d545 1
a545 1
/*fprintf(stderr,"XGL_epilog: %d ms from prolog\n", stop_ts());*/
d725 1
a725 1
				fprintf(stderr, "mged XGL_object: no memory\n");
d732 1
a732 1
				fprintf(stderr, "mged XGL_object: no memory\n");
d1054 1
a1054 1
	if(XGL_debug_level) fprintf(stderr, "XGL_statechange from %s to %s\n",
d1301 1
a1301 1
/*fprintf(stderr, "Visual Class is %d, depth = %d\n",win_visual_class,win_depth);*/
d1417 1
a1417 1
          printf("error in getting inquiry\n");
d1564 2
a1565 2
	printf("\nA total of %d buffers are supported by this\n", nbufs);
	printf("hardware.  Hardware double buffering will be turned on.\n");
d1571 2
a1572 2
	printf("\nThis is a MONOCHROME frame buffer.  No double buffering\n");
	printf("of any type can be used.\n\n");
d1580 1
a1580 1
	printf("\nUnknown frame buffer type ... aborting.\n\n");
d1586 1
a1586 1
		printf("\nUsing colormap double buffering, 8 bit color.\n");
d1613 1
a1613 1
			printf("Undefined DEFAULT_DB option, exiting\n");
d1629 1
a1629 1
			fprintf(stderr,
d1667 1
a1667 1
		printf("Is it OK to proceed [%s]? ",
d1787 1
a1787 1
/*fprintf (stderr,"stop_func:calling notify_stop()\n");*/
d1789 1
a1789 1
/*fprintf (stderr,"stop_func:back from notify_stop()\n");*/
d2237 1
a2237 1
		fprintf(stderr, "PL[%d]: (%d pts)\n",i, pl[i].num_pts);
d2239 1
a2239 1
			fprintf(stderr, "	pt[%j]: %f,%f,%f, %d\n",
@


10.9
log
@New version from Sun.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.8 94/10/14 17:07:07 mike Exp $ (BRL)";
d49 1
@


10.8
log
@#if defined(_SC_OPEN_MAX)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.7 94/10/14 16:06:34 mike Exp Locker: mike $ (BRL)";
d48 1
d58 1
d60 1
a60 1
static short icon_bits[] = {
a63 17



/*
 *	Structure declarations
 */

			/* struct obj - describes a ged graphics object	*/
			/* 	in convenient terms;   used in a doubly	*/
			/*	linked list of all objects which we 	*/
			/* 	know about.				*/
struct obj {
	struct solid	*sp;			/* ptr to ged solid	*/
	Xgl_pt_list	pt_list;		/* XGL point list	*/
	struct obj	*forptr, *backptr;	/* linked list ptrs	*/
};

a74 3



d94 2
a96 4
/*
 *	Gross hack to get true height of frame
 */
#define SLACK_HACK	31	/* XV_HEIGHT on frame is busted; add this in */
a97 2


a120 2


a136 3
static struct obj	*alloc_obj();			/* alloc obj struct */
static void		free_obj();			/* free obj struct */
static struct obj	*find_obj();			/* find obj */ 
a141 1
static Notify_value	setfocus_timer_func();		/* delayed set focus */
d152 1
a152 1
static void		win_event_proc();		/* canvas event */
a159 3



a204 3
static struct obj	*obj = (struct obj *)0;	/* begin obj linked list */
static struct obj	*end_obj = (struct obj *)0; /* end of linked list */
static struct obj	*lastf_obj = (struct obj *)0; /* last found in list */
d227 1
a227 2
#define MAX_PT_LISTS	500
static Xgl_sys_st	sys_state;		/* system state */
d229 1
d234 10
d245 8
a252 1
static Xgl_pt_list	pl[MAX_PT_LISTS];	/* for xgl_multipolyline */
d264 3
d282 15
d314 4
d319 6
a340 2


d422 1
a422 1
		notify_start(frame);	/* and, go */
d426 14
a450 11
		dup2(p0[0], 0);		/* stdin from child */
		dup2(p1[1], 1);		/* stdout to child */
		cmd_fd = p3[1];		/* special "command" to child */
		if(p0[0] != 0) close(p0[0]);
		if(p1[1] != 1) close(p1[1]);
		close(p0[1]);
		close(p1[0]);
		close(p3[0]);

		if(fork()) exit(0);	/* "background" us */

d490 1
a496 1

d511 1
a511 1
	if(num_pt_lists) XGL_object(0, 0, 0, 0);
d520 2
a521 1
		xgl_object_set(ras, XGL_RAS_COLOR_MAP, cmap, 0);
d527 1
a527 1
		    xgl_object_set(ras, XGL_RAS_COLOR_MAP, cmap_A, 0);
d531 1
a531 1
		    xgl_object_set(ras, XGL_RAS_COLOR_MAP, cmap_B, 0);
d536 3
a538 1

d544 1
d549 4
d554 63
d626 1
d644 1
a644 1
register struct solid *sp;
a647 3
	register int			i;	
	register struct obj		*objptr;
	Xgl_matrix_f3d			xgl_mat;
d649 1
d652 2
a653 3
	static mat_t			last_mat;
	static Xgl_color_index		last_color_index;
	static float			last_width_factor;
d655 1
d657 1
a657 1
	DPRINTF("XGL_object\n");
d659 2
a660 23
	if(sp != NULL) {
		if((objptr = find_obj(sp)) == (struct obj *)0) {
			DPRINTF("mged XGL_object: unknown solid\n");
			return(0);
		}

		if(bcmp((char *)mat, (char *)last_mat, sizeof(last_mat))) {
			++diff;
			bcopy((char *)mat, (char *)last_mat, sizeof(last_mat));

			for (i = 0; i < 16; i++)
			xgl_mat[i/4][i%4] =
			    (fabs(mat[i]) < 1.0e-15) ? 0.0 : mat[i];
		
			xgl_transform_write(trans, xgl_mat);
			xgl_transform_transpose(trans, trans);
		
			xgl_object_set(ctx_3d,
			    XGL_CTX_LOCAL_MODEL_TRANS, trans,
			    0);
		}

	    /* Set the line color (s_dmindex was set in XGL_colorchange) */
d664 1
a664 1
			color_index = COLORINDEX(DM_WHITE);
d666 1
a666 1
			color_index = COLORINDEX(objptr->sp->s_dmindex);
d669 3
a671 1
	    /* And, the width. */
d678 5
a682 3
		if((color_index != last_color_index) ||
		    (width_factor != last_width_factor))
			++diff;
d685 5
a689 3
	if(diff || (sp == NULL) || (num_pt_lists == MAX_PT_LISTS)) {
		if(num_pt_lists) {
			ln_color.index = last_color_index;
d691 6
a696 4
			    XGL_CTX_LINE_COLOR,		     &ln_color,
			    XGL_CTX_LINE_WIDTH_SCALE_FACTOR, last_width_factor,
			    0);
			xgl_multipolyline(ctx_3d, NULL, num_pt_lists, pl);
d698 16
a713 2
		num_pt_lists = 0;
		if(sp != NULL) {
d719 20
a738 1
	if(sp != NULL) pl[num_pt_lists++] = objptr->pt_list;
a739 1
    /* Return 1 to say we drew it. */
d743 56
d842 1
a842 1
	if(num_pt_lists) XGL_object(0, 0, 0, 0);
a845 1
	ln_color.index = MONOCHROME ? 1 : COLORINDEX(color);
d847 5
d853 2
a854 2
		XGL_CTX_SFONT_TEXT_COLOR,	&ln_color,
		XGL_CTX_SFONT_CHAR_HEIGHT,	45.,
d878 1
a878 1
	if(num_pt_lists) XGL_object(0, 0, 0, 0);
d922 1
d926 3
a948 1
	notify_set_input_func(frame, stop_func, input_fd);
d950 3
d981 2
a982 1
	(void)input_poll(fileno(stdin));
d1031 1
a1031 1
/*	DPRINTF("XGL_statechange\n");  /* .... found below	*/
a1067 4
	register struct rt_vlist	*vp;
	register Xgl_pt_flag_f3d	*ptr;
	register int			i;
	struct obj			*objptr;
a1068 83
	DPRINTF("XGL_viewchange ");

	switch(cmd)  {
	case DM_CHGV_ADD:

    /* Add an object to our list */

		DPRINTF("DM_CHGV_ADD\n");

		objptr = alloc_obj(sp->s_vlen);
		if(objptr == (struct obj *)0) {
			fprintf(stderr, "mged XGL_viewchange:  no memory\n");
			break;
		}

		objptr->sp           = sp;
		objptr->pt_list.bbox = NULL;

		ptr = objptr->pt_list.pts.flag_f3d;
		for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
			register int	nused = vp->nused;
			register int	*cmd = vp->cmd;
			register point_t *pt = vp->pt;
			for( i = 0; i < nused; i++,cmd++,pt++,ptr++ )  {
				switch( *cmd )  {
				case RT_VLIST_POLY_START:
					continue;
				case RT_VLIST_POLY_MOVE:
				case RT_VLIST_LINE_MOVE:
					/* Move, not draw */
					ptr->x = pt[0][0];
					ptr->y = pt[0][1];
					ptr->z = pt[0][2];
					ptr->flag = 0x00;
					continue;
				case RT_VLIST_POLY_DRAW:
				case RT_VLIST_POLY_END:
				case RT_VLIST_LINE_DRAW:
					/* draw */
					ptr->x = pt[0][0];
					ptr->y = pt[0][1];
					ptr->z = pt[0][2];
					ptr->flag = 0x01;
					continue;
				}
			}
		}
		break;

	case DM_CHGV_REDO:
		DPRINTF("DM_CHGV_REDO\n");

    /* not sure what we're supposed to do here */

		break;

	case DM_CHGV_DEL:
		DPRINTF("DM_CHGV_DEL\n");

		if((objptr = find_obj(sp)) == (struct obj *)0)
			fprintf(stderr,"mged XGL_viewchange: unknown solid\n");

		free_obj(objptr);
		break;

	case DM_CHGV_REPL:
		DPRINTF("DM_CHGV_REPL\n");

    /* not sure what we're supposed to do here */

		break;

	case DM_CHGV_ILLUM:
		DPRINTF("DM_CHGV_ILLUM\n");

    /* not sure what we're supposed to do here */

		break;

	default:
		DPRINTF("UNKNOWN COMMAND\n");
		break;
	}
d1127 5
a1131 1
	if(CMAPDBUFFERING) setcolortables(color_table_A, color_table_B);
d1165 2
a1166 1
	Xgl_bounds_f3d	bounds_f3d;
d1171 1
a1171 1
	if(bcmp((char *)windowbounds, (char *)lastwindowbounds,
d1176 2
a1177 2
		bounds_f3d.xmax = windowbounds[0] / 2047.0;
		bounds_f3d.xmin = windowbounds[1] / 2048.0;
d1179 2
a1180 2
		bounds_f3d.ymax = windowbounds[2] / 2047.0;
		bounds_f3d.ymin = windowbounds[3] / 2048.0;
d1182 2
a1183 2
		bounds_f3d.zmax = windowbounds[4] / 2047.0;
		bounds_f3d.zmin = windowbounds[5] / 2048.0;	
d1186 1
a1186 1
			XGL_CTX_VIEW_CLIP_BOUNDS, &bounds_f3d,
d1188 1
d1255 1
a1255 1
	notify_set_signal_func(frame, signal_func, SIGINT, NOTIFY_SAFE);
d1267 1
d1277 1
d1282 20
a1332 1
        display = (Display *)xv_get(frame, XV_DISPLAY);
a1335 1
		WIN_DYNAMIC_VISUAL,	TRUE,
a1337 1
		CANVAS_RETAINED,	TRUE,
d1339 7
d1364 1
a1364 1
		WIN_EVENT_PROC,		win_event_proc,
d1371 1
a1384 1
	void		win_event_proc();
d1389 3
a1391 2
	Xgl_bounds_f2d	bounds_f2d;
	Xgl_bounds_f3d	bounds_f3d;
d1396 5
d1403 1
a1403 1
		PropModeAppend, &canvas_window, 1);
d1409 2
a1410 1
	sleep(2);
d1413 12
d1427 3
a1429 3
    	ras = xgl_window_raster_device_create(
		XGL_WIN_X,		&xgl_x_win,
		0);
d1431 1
a1431 1
	if((dbuffering = init_check_buffering()) < 0)
d1452 1
a1452 1
		for(slotsused = MINSLOTS; slotsused < maxcolors; ++slotsused)
d1458 3
a1460 3
		ln_color.index = COLORINDEX(DM_YELLOW);

		cmap = xgl_color_map_create(
d1465 2
a1466 2
		if(CMAPDBUFFERING) {
			cmap_B = xgl_color_map_create(
d1470 3
a1472 3

		xgl_object_set(ras,
			XGL_RAS_COLOR_MAP,	cmap,
d1477 4
a1480 4
	bounds_f2d.xmin = -2048.0;
	bounds_f2d.xmax = 2050.0;	/* I'm not sure why this has to be */
	bounds_f2d.ymin = -2052.0;	/* hacked with 2050 and 2052;  but, */
	bounds_f2d.ymax = 2048.0;	/* that's what works */
d1482 6
a1487 6
	bounds_f3d.xmax = 1.;
	bounds_f3d.xmin = -1.;
	bounds_f3d.ymax = 1.;
	bounds_f3d.ymin = -1.;
	bounds_f3d.zmax = 1.;
	bounds_f3d.zmin = -1.;	
d1489 1
a1489 1
	ctx_3d = xgl_3d_context_create(
d1494 1
a1494 1
			XGL_CTX_VDC_WINDOW,	&bounds_f3d,
d1496 3
d1500 1
a1500 2

	ctx_2d = xgl_2d_context_create(
d1505 1
a1505 1
			XGL_CTX_VDC_WINDOW,	&bounds_f2d,
d1507 1
a1507 1

d1509 2
d1514 2
d1517 2
a1519 1
		    XGL_WIN_RAS_BUF_ENABLE,		(XGL_BUF_A | XGL_BUF_B),
d1521 1
a1521 2
		    XGL_WIN_RAS_BUF_WRITE_ENABLE,	XGL_BUF_B,
		    XGL_WIN_RAS_BUF_READ_ENABLE,	XGL_BUF_B,
d1523 2
a1529 5
		xgl_object_set(ctx_2d,
		    XGL_CTX_NEW_FRAME_ACTION,
			(XGL_CTX_NEW_FRAME_CLEAR
			    | XGL_CTX_NEW_FRAME_SWITCH_BUFFER),
		    0);
d1532 1
a1532 1
	trans = xgl_transform_create(0);
d1539 1
a1539 1
init_check_buffering()
a1541 1
	Xgl_color_type	color_type;
a1543 1
	char		line[80];
d1551 8
a1558 2
	xgl_object_get(ras, XGL_WIN_RAS_BUFFERS_SUPPORTED, &nbufs);
	xgl_object_get(ras, XGL_RAS_COLOR_MAP, &cmap);
d1561 1
a1561 1
	if(color_type != XGL_COLOR_INDEX) {
a1562 18
	printf("\nThis hardware does not use an indexed color map.\n");
	printf("And, this software has not been optimized or tested for\n");
	printf("this type of frame buffer.    Unpredictable results may\n");
	printf("occur.\n\n");

		if(ok(NO) == YES) {
			xgl_object_destroy(ras);
    			ras = xgl_window_raster_device_create(
				XGL_WIN_X,		&xgl_x_win,
				XGL_RAS_COLOR_TYPE,	XGL_COLOR_INDEX,
				0);
			return(init_check_buffering());
		} else {
			return(-1);
		}

	} else if(nbufs > 1) {

d1575 1
a1575 1
		return((ok(YES) == YES) ? NO_DBUFF : -1);
d1585 1
a1585 2
	printf("\nThis is a color frame buffer with a single hardware\n");
	printf("display buffer.  ");
d1587 6
a1592 1
#if   (DEFAULT_DB == OPTION_ZERO)
d1594 5
a1598 5
	printf(                 "By default, no double buffering will be\n");
	printf("used.   And, the display will be treated as a monochrome\n");
	printf("display.   This option (option \'0\') is more for testing\n");
	printf("purposes than anything else.   And, as such, option \'0\'\n");
	printf("is never listed on the menu.\n");
d1600 5
a1604 1
#elif (DEFAULT_DB == OPTION_ONE)
d1606 8
a1613 62
	printf(                 "By default, no double buffering will be\n");
	printf("used.   As such, 128 colors will be available, and\n");
	printf("\"colormap flash\" is unlikely.   However, certain\n");
	printf("operations will appear to be extremely \"jerky\".\n");

#elif (DEFAULT_DB == OPTION_TWO)

	printf(                 "By default, colormap double buffering\n");
	printf("in 8 colors will be used.   As such, \"colormap flash\"\n");
	printf("is unlikely, but objects may not be displayed in their\n");
	printf("correct colors.\n\n");

#elif (DEFAULT_DB == OPTION_THREE)

	printf(                 "By default, colormap double buffering\n");
	printf("in 16 colors will be used.   As such, \"colormap flash\"\n");
	printf("may be expected to occur.\n\n");

#endif

		for(*line = DEFAULT_DB;;) {
			switch(*line) {
			  case OPTION_ZERO:
				type = NO_DBUFF;
				maxcolors = 2;
				colortablesize = 2;
				break;

			  case OPTION_ONE:
				type = NO_DBUFF;
				maxcolors = 128;
				colortablesize = 128;
				break;

			  case OPTION_TWO:
				type = CMAP8_DBUFF;
				maxcolors = 8;
				colortablesize = 64;
				break;

			  case OPTION_THREE:
				type = CMAP16_DBUFF;
				maxcolors = 16;
				colortablesize = 256;
				break;
			  default:
				goto skip_ok;
			}
			if(ok(YES) == YES) break;
skip_ok:
		printf("Please choose from the following:\n\n");

		printf("\t1 -\tNo double buffering;  but, with 128 colors\n");
		printf("\t2 -\tColormap double buffering in 8 colors\n");
		printf("\t3 -\tColormap double buffering in 16 colors\n\n");

		printf("Option [%c]: ", DEFAULT_DB);

			(void)fgets( line, sizeof(line), stdin ); /* \n, null terminated */
			line[strlen(line)-1] = '\0';		/* remove newline */
			if(feof(stdin)) goto skip_ok;
			if(*line == '\0') *line = DEFAULT_DB;
a1614 1
		return(type);
d1616 1
a1731 28
static struct obj *
alloc_obj(num_pts)
int		num_pts;
{
	struct obj	*objptr;

	if((objptr = (struct obj *)calloc(1, sizeof(struct obj)))
	    == (struct obj *)0)
		return((struct obj *)0);

	if(obj == (struct obj *)0) {
		obj = objptr;
	} else {
		end_obj->forptr = objptr;
		objptr->backptr = end_obj;
	}
	end_obj = objptr;

	objptr->pt_list.pt_type = XGL_PT_FLAG_F3D;
	objptr->pt_list.num_pts = num_pts;
	if((objptr->pt_list.pts.flag_f3d =
	  (Xgl_pt_flag_f3d *)calloc(num_pts, sizeof(Xgl_pt_flag_f3d)))
	    == (Xgl_pt_flag_f3d *)0)
		return((struct obj *)0);

	return(objptr);
}

a1732 37
free_obj(objptr)
struct obj	*objptr;
{
	if(objptr->backptr == (struct obj *)0)
		obj = objptr->forptr;
	else
		objptr->backptr->forptr = objptr->forptr;

	if(objptr->forptr == (struct obj *)0)
		end_obj = objptr->backptr;
	else
		objptr->forptr->backptr = objptr->backptr;

	if(lastf_obj == objptr) lastf_obj = (struct obj *)0;
	free(objptr->pt_list.pts.flag_f3d);
	free(objptr);

	return;
}

static struct obj *
find_obj(sp)
struct solid	*sp;
{
	register struct obj	*objptr;

	objptr = (lastf_obj == (struct obj *)0) ? obj : lastf_obj;
	for(; objptr != (struct obj *)0; objptr = objptr->forptr)
		if(objptr->sp == sp) return(lastf_obj = objptr);
	if(lastf_obj == (struct obj *)0) return((struct obj *)0);
	for(objptr = obj; objptr != lastf_obj; objptr = objptr->forptr)
		if(objptr->sp == sp) return(lastf_obj = objptr);

	return(lastf_obj = (struct obj *)0);
}

static void
a1779 7
static Notify_value
setfocus_timer_func(client, which)
Notify_client	client;
int		which;
{
	XSetInputFocus(display, (Window)xv_get(pw, XV_XID),
		RevertToNone, CurrentTime);
a1780 3
	return(NOTIFY_DONE);
}

d1786 1
d1788 1
d1833 1
a1833 1
	stop_func(0, 0);
d1844 1
d1848 4
a1851 4
	h = (int)xv_get(frame, XV_HEIGHT);
	x = (int)xv_get(frame, XV_X);
	y = (int)xv_get(frame, XV_Y) + h + SLACK_HACK;

a1853 1
		y += 20;
d1877 1
a1877 1
	stop_func(0, 0);
d1895 2
a1896 1
	xgl_window_raster_resize(ras, w, h);
d1899 1
a1899 1
	stop_func(0, 0);
d1915 1
a1915 1
	static int	hack = 0;
a1918 7
	    /*								*/
	    /* due to an openwin 2.0 xview bug, this application has	*/
	    /* to ignore the 6th resize event on startup, or the termsw	*/
	    /* will start off in the wrong place.  This is a very ugly	*/
	    /* way to work around this bug;   but, I tried everything,	*/
	    /* and this is all I could come up with.			*/
	    /*								*/
a1919 1
		if(++hack == 6) break;
d1921 4
a1924 3
		h = (int)xv_get(frame, XV_HEIGHT);
		y = (int)xv_get(frame, XV_Y) + h + SLACK_HACK;
		x = (int)xv_get(frame, XV_X);
a1927 1

d1934 1
a1934 1
win_event_proc(win, event, arg)
d1942 1
d1953 4
d1960 2
a1961 2
			rt_vls_strcat( &dm_values.dv_string , "zoom 2\n" );
			stop_func(0, 0);
d1967 3
a1969 2
			rt_vls_printf(  &dm_values.dv_string , "M 1 %d %d\n", xpen, ypen );
			stop_func(0, 0);
d1975 2
a1976 2
			rt_vls_strcat( &dm_values.dv_string , "zoom 0.5\n" );
			stop_func(0, 0);
a1979 12
	/*********************************************************************/
	/* Catching LOC_WINENTER seems to be necessary here, for some reason,*/
	/* in order to force keyboard input focus into my canvas.	     */
	/* And, XSetInputFocus() seems to be about the only thing that gets  */
	/* it right.   win_set_kbd_focus() doesn't work completely; and,     */
	/* setting WIN_KBD_FOCUS is hopless.   Even XSetInputFocus doesn't   */
	/* work all the time;   I think I sometimes get into a race condition*/
	/* of some sort with the window manager, but it works most of the    */
	/* time.  Nonetheless, I added a 1/2 second delay with		     */
	/* notify_set_itimer_func() to force it into working ALL the time.   */
	/*   ...sigh							     */
	/*********************************************************************/
a1980 4
		bzero((char *)&timeout, sizeof(timeout));
		timeout.it_value.tv_usec = 500000L;
		notify_set_itimer_func(pw, setfocus_timer_func, ITIMER_REAL,
		    &timeout, NULL);
d1990 2
d2046 1
a2046 1
	stop_func();
d2210 38
@


10.7
log
@Changed from getdtablesize() to sysconf(_SC_OPEN_MAX)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.6 94/09/07 13:17:54 jra Exp Locker: mike $ (BRL)";
d403 6
a408 1
		for(fds = sysconf(_SC_OPEN_MAX); fds > 4; close(--fds));
d1638 1
d1644 7
a1650 1
	if(select(sysconf(_SC_OPEN_MAX), &readfds, NULL, NULL, &timeout) > 0) {
@


10.6
log
@Converted to use dm_values.dv_string instead of changing values directly.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.5 94/08/10 21:43:00 mike Exp Locker: jra $ (BRL)";
d403 1
a403 1
		for(fds = getdtablesize(); fds > 4; close(--fds));
d1638 1
a1638 1
	if(select(getdtablesize(), &readfds, NULL, NULL, &timeout) > 0) {
@


10.5
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.4 94/08/09 15:17:44 gdurf Exp Locker: mike $ (BRL)";
d246 2
d1941 2
a1942 2
	dm_values.dv_xpen = SUNPWx_TO_GED(x);
	dm_values.dv_ypen = SUNPWy_TO_GED(y);
d1948 1
a1948 1
			dm_values.dv_penpress = DV_OUTZOOM;
d1955 1
a1955 1
			dm_values.dv_penpress = DV_PICK;
d1962 1
a1962 1
			dm_values.dv_penpress = DV_INZOOM;
d2055 1
d2058 1
a2058 1
		xval = (float) dm_values.dv_xpen / 2048.;
d2062 1
a2062 1
		yval = (float) dm_values.dv_ypen / 2048.;
d2070 35
a2104 9
	dm_values.dv_zoom  = (sun_buttons & ZOOM_FLAG)   ? zoomval : 0.0;

	dm_values.dv_xslew = (sun_buttons & X_SLEW_FLAG) ? xval : 0.0;
	dm_values.dv_yslew = (sun_buttons & Y_SLEW_FLAG) ? yval : 0.0;
	dm_values.dv_zslew = (sun_buttons & Z_SLEW_FLAG) ? yval : 0.0;

	dm_values.dv_xjoy  = (sun_buttons & X_ROT_FLAG)  ? xval : 0.0;
	dm_values.dv_yjoy  = (sun_buttons & Y_ROT_FLAG)  ? yval : 0.0;
	dm_values.dv_zjoy  = (sun_buttons & Z_ROT_FLAG)  ? yval : 0.0;
@


10.4
log
@Added include of conf.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.3 1994/06/01 12:04:21 gdurf Exp gdurf $ (BRL)";
d199 1
a199 1
int		XGL_input();
d743 3
a745 3
 * Returns:
 *	0 if no command waiting to be read,
 *	1 if command is waiting to be read.
d747 4
a750 3
int
XGL_input(input_fd, noblock)
int	input_fd, noblock;
d805 4
a808 1
	return(input_poll(input_fd));
@


10.3
log
@Replaced gets() with fgets()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.2 1991/10/29 17:38:24 mike Exp gdurf $ (BRL)";
a23 1

d27 2
@


10.2
log
@Fix to make it compile.  Thanks to David Turner at Sandia.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 10.1 91/10/12 06:43:36 mike Rel4_0 Locker: mike $ (BRL)";
d1523 2
a1524 1
			(void)gets(line);
d1581 2
a1582 1
		(void)gets(line);
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 1.2 91/10/10 02:45:37 mike Exp $ (BRL)";
d923 3
a925 3
					ptr->x = pt[0];
					ptr->y = pt[1];
					ptr->z = pt[2];
d932 3
a934 3
					ptr->x = pt[0];
					ptr->y = pt[1];
					ptr->z = pt[2];
@


1.2
log
@Modified to use new vlist
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-xgl.c,v 1.1 91/10/10 00:48:28 mike Exp Locker: mike $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 9.1 89/05/19 06:02:13 mike Rel3_5 $ (BRL)";
d888 2
a889 2
	register struct vlist		*vp;
	register Xgl_pt_flag_f3d	*pt;
d911 28
a938 9
		for(vp = sp->s_vlist, pt = objptr->pt_list.pts.flag_f3d, i = 1;
		    vp != VL_NULL;
		    vp = vp->vl_forw, ++pt, ++i) {

			if(i > sp->s_vlen) break;
			pt->x = vp->vl_pnt[0];
			pt->y = vp->vl_pnt[1];
			pt->z = vp->vl_pnt[2];
			pt->flag = vp->vl_draw ? 0x01 : 0x00;
a939 2
		if(i != sp->s_vlen + 1)
			fprintf(stderr,"mged XGL_viewchange: corrupt solid\n");
@
