head	11.5;
access;
symbols
	ansi-20040405-merged:11.3.4.1
	postmerge-20040405-ansi:11.4
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.3.12.2
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.3.6.1
	autoconf-20031203:11.3
	autoconf-20031202:11.3
	autoconf-branch:11.3.0.12
	phong-branch:11.3.0.10
	photonmap-branch:11.3.0.8
	rel-6-1-DP:11.3
	windows-branch:11.3.0.6
	rel-6-0-2:11.3
	ansi-branch:11.3.0.4
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:8.1
	rel-3-5:8.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.17.47.44;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2004.02.02.17.39.33;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.19.03.10.47;	author mike;	state Exp;
branches
	11.3.4.1
	11.3.6.1
	11.3.12.1;
next	11.2;

11.2
date	96.09.23.18.23.58;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.16;	author mike;	state Rel4_4;
branches;
next	8.1;

8.1
date	88.10.05.00.37.03;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.09.17.06.03.59;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.25.06.07.27;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.01.20;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.35;	author mike;	state Rel;
branches;
next	5.2;

5.2
date	87.07.09.03.43.13;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.21.26;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.08.10;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.22.18;	author mike;	state Rel1;
branches;
next	2.2;

2.2
date	86.08.12.06.50.08;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.56.28;	author mike;	state Prod;
branches;
next	1.5;

1.5
date	85.02.01.03.23.25;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.19.03.57.17;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.12.17.17.01.34;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.22.06.57.01;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.51.39;	author mike;	state Exp;
branches;
next	;

11.3.4.1
date	2004.03.17.21.22.00;	author morrison;	state Exp;
branches;
next	;

11.3.6.1
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

11.3.12.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.3.12.2;

11.3.12.2
date	2004.03.15.14.07.38;	author erikg;	state Exp;
branches;
next	;


desc
@Dynamic memory allocator for non-host memory
@


11.5
log
@moved to src/mged/
@
text
@/*
 *			M E M A L L O C . C
 *
 * Functions -
 *	memalloc	allocate 'size' of memory from a given map
 *	memget		allocate 'size' of memory from map at 'place'
 *	memfree		return 'size' of memory to map at 'place'
 *	mempurge	free everything on current memory chain
 *	memprint	print a map
 *
 * The structure of the displaylist memory map chains
 * consists of non-zero count and base address of that many contiguous units.
 * The addresses are increasing and the list is terminated with the
 * first zero link.
 *
 * memalloc() and memfree() use these tables to allocate displaylist memory.
 *
 *	For each Memory Map there exists a queue (coremap).
 *	There also exists a queue of free buffers which are enqueued
 *	on to either of the previous queues.  Initially all of the buffers
 *	are placed on the `freemap' queue.  Whenever a buffer is freed
 *	because of coallescing ends in memfree() or zero size in memalloc()
 *	the mapping buffer is taken off from the respective queue and
 *	returned to the `freemap' queue.
 *
 *  Authors -
 *	George E. Toth
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/memalloc.c,v 11.4 2004/02/02 17:39:33 morrison Exp $ (BRL)";
#endif

#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "./mged_dm.h"		/* for struct mem_map */

extern char	*malloc();

/* Allocation/Free spaces */
static struct mem_map *freemap = MAP_NULL;	/* Freelist of buffers */

/* Flags used by `type' in memfree() */
#define	M_TMTCH	00001	/* Top match */
#define	M_BMTCH	00002	/* Bottom match */
#define	M_TOVFL	00004	/* Top overflow */
#define	M_BOVFL	00010	/* Bottom overflow */

/*
 *			M E M A L L O C
 *
 *	Takes:		& pointer of map,
 *			size.
 *
 *	Returns:	NULL	Error
 *			<addr>	Othewise
 *
 *	Comments:
 *	Algorithm is first fit.
 */
unsigned long
memalloc( pp, size )
struct mem_map **pp;
register unsigned size;
{
	register struct mem_map *prevp = MAP_NULL;
	register struct mem_map *curp;
	unsigned long	addr;

	if( size == 0 )
		return( 0L );	/* fail */

	for( curp = *pp; curp; curp = (prevp=curp)->m_nxtp )  {
		if( curp->m_size >= size )
			break;
	}

	if( curp == MAP_NULL )  {
		return(0L);		/* No more space */
	}

	addr = curp->m_addr;
	curp->m_addr += size;

	/* If the element size goes to zero, put it on the freelist */

	if( (curp->m_size -= size) == 0 )  {
		if( prevp )
			prevp->m_nxtp = curp->m_nxtp;
		else
			*pp = curp->m_nxtp;	/* Click list down at start */
		curp->m_nxtp = freemap;		/* Link it in */
		freemap = curp;			/* Make it the start */
	}

	return( addr );
}

/*
 *			M E M G E T
 *
 *	Returns:	NULL	Error
 *			-1	Zero Request
 *			<addr>	Othewise
 *
 *	Comments:
 *	Algorithm is first fit.
 */
unsigned long
memget( pp, size, place )
struct mem_map **pp;
register unsigned int size;
unsigned int place;
{
	register struct mem_map *prevp, *curp;
	unsigned int addr;

	prevp = MAP_NULL;		/* special for first pass through */
	if( size == 0 )
		return( -1 );	/* Anything non-zero */

	curp = *pp;
	while( curp )  {
		/*
		 * Assumption:  We will always be APPENDING to an existing
		 * memory allocation, so we search for a free piece of memory
		 * which begins at 'place', without worrying about ones which
		 * could begin earlier but be long enough to satisfy this
		 * request.
		 */
		if( curp->m_addr == place && curp->m_size >= size )
			break;
		curp = (prevp=curp)->m_nxtp;
	}

	if( curp == MAP_NULL )
		return(0L);		/* No space here */

	addr = curp->m_addr;
	curp->m_addr += size;

	/* If the element size goes to zero, put it on the freelist */
	if( (curp->m_size -= size) == 0 )  {
		if( prevp )
			prevp->m_nxtp = curp->m_nxtp;
		else
			*pp = curp->m_nxtp;	/* Click list down at start */
		curp->m_nxtp = freemap;		/* Link it in */
		freemap = curp;			/* Make it the start */
	}
	return( addr );
}

/*
 *			M E M F R E E
 *
 *	Takes:
 *			size,
 *			address.
 *
 *	Comments:
 *	The routine does not check for wrap around when increasing sizes
 *	or changing addresses.  Other wrap-around conditions are flagged.
 */
void
memfree( pp, size, addr )
struct mem_map **pp;
unsigned size;
unsigned long addr;
{
	register int type = 0;
	register struct mem_map *prevp = MAP_NULL;
	register struct mem_map *curp;
	long il;
	struct mem_map *tmap;

	if( size == 0 )
		return;		/* Nothing to free */

	/* Find the position in the list such that (prevp)<(addr)<(curp) */
	for( curp = *pp; curp; curp = (prevp=curp)->m_nxtp )
		if( addr < curp->m_addr )
			break;

	/* Make up the `type' variable */

	if( prevp )  {
		if( (il=prevp->m_addr+prevp->m_size) > addr )
			type |= M_BOVFL;
		if( il == addr )
			type |= M_BMTCH;
	}
	if( curp )  {
		if( (il=addr+size) > curp->m_addr )
			type |= M_TOVFL;
		if( il == curp->m_addr )
			type |= M_TMTCH;
	}

	if( type & (M_TOVFL|M_BOVFL) )  {
		(void)printf("mfree(addr=%d,size=%d)  error type=0%o\n",
			addr, size, type );
		if( prevp )
			(void)printf("prevp: m_addr=%d, m_size=%d\n",
				prevp->m_addr, prevp->m_size );
		if( curp )
			(void)printf("curp: m_addr=%d, m_size=%d\n",
				curp->m_addr, curp->m_size );
		(void)printf("display memory dropped, continuing\n");
		return;
	}

	/*
 	 * Now we do the surgery:
	 * If there are no matches on boundaries we allocate a buffer
	 * If there is one match we expand the appropriate buffer
	 * If there are two matches we will have a free buffer returned.
	 */

	switch( type & (M_BMTCH|M_TMTCH) )  {
	case M_TMTCH|M_BMTCH:	/* Deallocate top element and expand bottom */
		prevp->m_size += size + curp->m_size;
		prevp->m_nxtp = curp->m_nxtp;
		curp->m_nxtp = freemap;		/* Link into freemap */
		freemap = curp;
		break;

	case M_BMTCH:		/* Expand bottom element */
		prevp->m_size += size;
		break;

	case M_TMTCH:		/* Expand top element downward */
		curp->m_size += size;
		curp->m_addr -= size;
		break;

	default:		/* No matches; allocate and insert */
		if( (tmap=freemap) == MAP_NULL )
			tmap = (struct mem_map *)malloc(sizeof(struct mem_map));
		else
			freemap = freemap->m_nxtp;	/* Click one off */

		if( prevp )
			prevp->m_nxtp = tmap;
		else
			*pp = tmap;

		tmap->m_size = size;
		tmap->m_addr = addr;
		tmap->m_nxtp = curp;
	}
}

/*
 *			M E M P U R G E
 *
 *  Take everything on the current memory chain, and place it on
 *  the freelist.
 */
void
mempurge( pp )
struct mem_map **pp;
{
	register struct mem_map *prevp = MAP_NULL;
	register struct mem_map *curp;

	if( *pp == MAP_NULL )
		return;

	/* Find the end of the (busy) list */
	for( curp = *pp; curp; curp = (prevp=curp)->m_nxtp )
		;

	/* Put the whole busy list onto the free list */
	prevp->m_nxtp = freemap;
	freemap = *pp;

	*pp = MAP_NULL;
}

/*
 *			M E M P R I N T
 *
 *  Print a memory chain.
 */
void
memprint( pp )
struct mem_map **pp;
{
	register struct mem_map *curp;

	curp = *pp;
	for( curp = *pp; curp; curp = curp->m_nxtp )
		(void)printf(" %ld, len=%d\n", curp->m_addr, curp->m_size );
}
@


11.4
log
@update copyright to include span through 2003
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/memalloc.c,v 11.3 2000/08/19 03:10:47 mike Exp $ (BRL)";
@


11.3
log
@
const RCSid
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1985 by the United States Army.
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/memalloc.c,v 11.2 1996/09/23 18:23:58 bparker Exp $ (BRL)";
@


11.3.4.1
log
@sync branch with HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.3.6.1
log
@sync to HEAD...
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/memalloc.c,v 11.4 2004/02/02 17:39:33 morrison Exp $ (BRL)";
@


11.3.12.1
log
@merge from HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/memalloc.c,v 11.4 2004/02/02 17:39:33 morrison Exp $ (BRL)";
@


11.3.12.2
log
@merge from head
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/memalloc.c,v 11.3.12.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.2
log
@changed dm.h to mged_dm.h
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/memalloc.c,v 11.1 1995/01/04 10:03:16 mike Rel4_4 bparker $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/memalloc.c,v 8.1 88/10/05 00:37:03 mike Rel3_0 Locker: mike $ (BRL)";
d46 1
a46 1
#include "./dm.h"		/* for struct mem_map */
@


8.1
log
@Release_3.0
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 7.3 88/09/17 06:03:59 mike Exp $ (BRL)";
@


7.3
log
@removed {} from register initialization.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 7.2 88/02/25 06:07:27 mike Locked $ (BRL)";
@


7.2
log
@Modified for new vector lists
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 7.1 87/11/03 00:01:20 mike Locked $ (BRL)";
d181 1
a181 1
	register int type = {0};
@


7.1
log
@Release 2.3
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 6.1 87/07/11 08:04:35 mike Rel $ (BRL)";
d44 2
@


6.1
log
@Release 2.0
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 5.2 87/07/09 03:43:13 mike Exp $ (BRL)";
@


5.2
log
@Removed MAXINT code, which assumed sizeof(int) < sizeof(long)
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 5.1 87/06/24 22:21:26 mike Locked $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 4.2 87/02/13 00:08:10 mike Exp $ (BRL)";
a55 2
#define M_TWRAR	00020	/* Top wrap-around */
#define	M_BWRAR	00040	/* Bottom wrap-around */
a56 2
#define	MAXINT	((unsigned long)((int)(-1)))	/* Maximum integer */

a199 2
		if( il > MAXINT )
			type |= M_BWRAR;
a205 2
		if( il > MAXINT )
			type |= M_TWRAR;
d208 1
a208 1
	if( type & (M_TOVFL|M_BOVFL|M_TWRAR|M_BWRAR) )  {
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 4.1 86/12/29 03:22:18 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 2.2 86/08/12 06:50:08 mike Exp $ (BRL)";
@


2.2
log
@Changed #includes for CC -I../h
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 2.1 85/03/11 23:56:28 mike Prod $ (BRL)";
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 1.5 85/02/01 03:23:25 mike Exp $ (BRL)";
d44 1
a44 1
#include "dm.h"		/* for struct mem_map */
@


1.5
log
@Removed debugging printf.
@
text
@d8 1
d11 2
a12 2
 * Structure of the displaylist memory map chains.
 * Consists of non-zero count and base address of that many contiguous units.
a16 13
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: memalloc.c,v 1.4 85/01/19 03:57:17 mike Exp $ (BRL)";
#endif

#include <stdio.h>
#include "dm.h"		/* for struct mem_map */

/* Allocation/Free spaces */
static struct mem_map *freemap = MAP_NULL;	/* Freelist of buffers */

/*
 *	A little better memory allocator		=GET=
a17 2
 *	July 4, 1980
 *
d26 12
d39 3
d43 2
d46 1
a46 1
	/* Flags used by `type' in memfree() */
d48 4
d217 1
a217 1
		printf("mfree(addr=%d,size=%d)  error type=0%o\n",
d220 1
a220 1
			printf("prevp: m_addr=%d, m_size=%d\n",
d223 1
a223 1
			printf("curp: m_addr=%d, m_size=%d\n",
d225 1
a225 1
		printf("display memory dropped, continuing\n");
d310 1
a310 1
		printf(" %ld, len=%d\n", curp->m_addr, curp->m_size );
@


1.4
log
@memalloc size 0 now returns FAIL (ie, 0).
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 1.3 84/12/17 17:01:34 mike Exp $ (BRL)";
a83 1
		printf("memalloc(%d):  no more space\n", size );
@


1.3
log
@Fixed bug with memget() on null map.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: memalloc.c,v 1.2 84/11/22 06:57:01 mike Exp $ (BRL)";
d76 1
a76 1
		return( 1L );	/* Anything non-zero */
@


1.2
log
@Multiple simultaneous display manager support
@
text
@d4 6
d18 1
a18 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d66 1
a66 1
unsigned
d73 1
a73 1
	unsigned	addr;
d76 1
a76 1
		return( 1 );	/* Anything non-zero */
d85 1
a85 1
		return(0);		/* No more space */
d106 55
d175 1
a175 1
unsigned addr;
d289 16
@


1.1
log
@Initial revision
@
text
@a0 1
/*	SCCSID	%W%	%E%	*/
d2 3
a4 5
 *	memalloc.c -- displaylist memory allocation routines
 */

/*
 * Structure of the coremap array.
d9 1
a9 1
 * memalloc() and memfree() use these tables to allocate memory
d11 3
a13 6
struct map {
	struct map	*m_nxtp;	/* Linking pointer to next element */
	unsigned	 m_size;	/* Size of this free element */
	unsigned	 m_addr;	/* Address of start of this element */
};
#define MAP_NULL	((struct map *) 0)
d15 3
d19 1
a19 2
static struct map *coremap = MAP_NULL;	/* Working map queues -- freespace */
static struct map *freemap = MAP_NULL;	/* Freelist of buffers */
a33 9
 *
 *		R E V I S I O N   H I S T O R Y
 *
 *	07/04/80  GET	Original version  (JHU 6.79)
 *
 *	07/15/80  MJM	Modified to have unique names, since calling
 *			sequences are not unique  (BRL 6.85)
 *
 *	09-Sep-83 DAG	Overhauled.
d61 2
a62 1
memalloc( size )
d65 2
a66 2
	register struct map *prevp = MAP_NULL;
	register struct map *curp;
d72 1
a72 1
	for( curp = coremap; curp; curp = (prevp=curp)->m_nxtp )  {
d91 1
a91 1
			coremap = curp->m_nxtp;	/* Click list down at start */
d111 2
a112 1
memfree( size, addr )
d117 2
a118 2
	register struct map *prevp = MAP_NULL;
	register struct map *curp;
d120 1
a120 1
	struct map *tmap;
d126 1
a126 1
	for( curp = coremap; curp; curp = (prevp=curp)->m_nxtp )
d188 1
a188 1
			tmap = (struct map *)malloc(sizeof(struct map));
d195 1
a195 1
			coremap = tmap;
d201 27
@
