head	11.25;
access;
symbols
	ansi-20040405-merged:11.21.2.2
	postmerge-20040405-ansi:11.23
	premerge-20040404-ansi:11.22
	postmerge-autoconf:11.22
	autoconf-freeze:11.21.10.2
	premerge-autoconf:11.22
	postmerge-20040315-windows:11.22
	premerge-20040315-windows:11.22
	windows-20040315-freeze:11.21.4.1
	autoconf-20031203:11.21
	autoconf-20031202:11.21
	autoconf-branch:11.21.0.10
	phong-branch:11.21.0.8
	photonmap-branch:11.21.0.6
	rel-6-1-DP:11.21
	windows-branch:11.21.0.4
	rel-6-0-2:11.19
	ansi-branch:11.21.0.2
	rel-6-0-1-branch:11.19.0.2
	hartley-6-0-post:11.20
	hartley-6-0-pre:11.19
	rel-6-0-1:11.19
	rel-6-0:11.19
	rel-5-4:11.12
	offsite-5-3-pre:11.15
	rel-5-3:11.12
	rel-5-2:11.12
	rel-5-1-branch:11.12.0.2
	rel-5-1:11.12
	rel-5-0:11.12
	rel-5-0-beta:11.11
	rel-4-5:11.11
	ctj-4-5-post:11.11
	ctj-4-5-pre:11.11
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.25
date	2004.05.21.17.47.38;	author morrison;	state dead;
branches;
next	11.24;

11.24
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.23;

11.23
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2002.08.20.17.08.22;	author jra;	state Exp;
branches
	11.21.2.1
	11.21.4.1
	11.21.10.1;
next	11.20;

11.20
date	2002.08.15.20.55.33;	author hartley;	state Exp;
branches;
next	11.19;

11.19
date	2001.04.05.19.35.43;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2001.04.02.18.10.10;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	2001.03.23.22.05.34;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2001.03.23.21.27.01;	author tranese;	state Exp;
branches;
next	11.15;

11.15
date	2000.09.07.02.43.20;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.19.03.10.42;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.07.24.22.22.11;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.09.08.14.33.26;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	97.02.28.21.24.25;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.10.04.14.53.15;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.10.04.14.49.56;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.03.01.19.33.51;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.09.22.02.17.40;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.09.09.02.35.32;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.01.19.12.20.00;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.27;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.48;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.23.21.57.03;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.12.16.20.44.05;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.12.16.20.29.16;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.12.16.20.24.37;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.12.16.19.35.49;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.15.01.23;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.15;	author mike;	state Rel4_0;
branches;
next	9.7;

9.7
date	91.09.26.22.42.51;	author butler;	state Exp;
branches;
next	9.6;

9.6
date	90.12.13.16.31.14;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.07.00.57.19;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.06.07.01.07.04;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.29.14.48.44;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.28.14.35.25;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.06;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.06.20.18.05;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.00.12;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.43;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.17.02.23.04;	author reschly;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.59.03;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.02.19;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.18.31;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.06.03;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.19.44;	author mike;	state Rel1;
branches;
next	2.4;

2.4
date	86.11.15.10.26.26;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	86.08.12.06.47.31;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	86.05.27.23.48.15;	author reschly;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.54.25;	author mike;	state Prod;
branches;
next	1.2;

1.2
date	85.02.05.04.17.28;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.02.05.01.39.47;	author mike;	state Exp;
branches;
next	;

11.21.2.1
date	2002.09.19.18.02.00;	author morrison;	state Exp;
branches;
next	11.21.2.2;

11.21.2.2
date	2004.03.17.21.21.56;	author morrison;	state Exp;
branches;
next	;

11.21.4.1
date	2004.03.11.23.46.33;	author morrison;	state Exp;
branches;
next	;

11.21.10.1
date	2004.02.12.18.34.13;	author erikg;	state Exp;
branches;
next	11.21.10.2;

11.21.10.2
date	2004.03.15.14.07.36;	author erikg;	state Exp;
branches;
next	;


desc
@Routines for printing columnar data.
@


11.25
log
@moved to src/mged/
@
text
@/*
 *  			C O L U M N S
 *  
 *  A set of routines for printing columns of data.
 *
 * Functions -
 *	col_item	Called to print an item
 *	col_putchar	Called to annotate an item
 *	col_eol		Called to end a line
 *	cmpdirname	Comparison function for col_pr4v
 *	col_pr4v	Called to sort and print directory entry names
 *			  vertically in four columns (ala "ls -C")
 *
 *  Authors -
 *	Michael John Muuss
 *	Robert Jon Reschly Jr.
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/columns.c,v 11.24 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"

static int	col_count;		/* names listed on current line */
static int	col_len;		/* length of previous name */
#define TERMINAL_WIDTH	80		/* XXX */
#define	COLUMNS	((TERMINAL_WIDTH + NAMESIZE - 1) / NAMESIZE)

/*
 *			V L S _ C O L _ I T E M
 */
void
vls_col_item(
	struct bu_vls		*str,
	register const char	*cp)
{
	/* Output newline if last column printed. */
	if( col_count >= COLUMNS || (col_len+NAMESIZE-1) >= TERMINAL_WIDTH )  {
		/* line now full */
		bu_vls_putc( str, '\n' );
		col_count = 0;
	} else if ( col_count != 0 ) {
		/* Space over before starting new column */
		do {
			bu_vls_putc( str, ' ' );
			col_len++;
		}  while ( (col_len % NAMESIZE) != 0 );
	}
	/* Output string and save length for next tab. */
	col_len = 0;
	while ( *cp != '\0' )  {
		bu_vls_putc( str, *cp );
		++cp;
		++col_len;
	}
	col_count++;
}

/*
 */
void
vls_col_eol( struct bu_vls *str )
{
	if ( col_count != 0 )		/* partial line */
		bu_vls_putc( str, '\n' );
	col_count = 0;
	col_len = 0;
}


/*
 *			C M P D I R N A M E
 *
 * Given two pointers to pointers to directory entries, do a string compare
 * on the respective names and return that value.
 */
int
cmpdirname(const genptr_t a, const genptr_t b)
{
	register struct directory **dp1, **dp2;

	dp1 = (struct directory **)a;
	dp2 = (struct directory **)b;
	return( strcmp( (*dp1)->d_namep, (*dp2)->d_namep));
}

/*
 *				C O L _ P R 4 V
 *
 *  Given a pointer to a list of pointers to names and the number of names
 *  in that list, sort and print that list in column order over four columns.
 */
void
vls_col_pr4v(struct bu_vls *vls, struct directory **list_of_names, int num_in_list)
{
  int lines, i, j, namelen, this_one;
  int k,
      maxnamelen,      /* longest name in list */
      cwidth,          /* column width */
      numcol;         /* number of columns */

  qsort( (genptr_t)list_of_names,
	 (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	 (int (*)())cmpdirname);

  /* 
   * Traverse the list of names, find the longest name and set the
   * the column width and number of columns accordingly.
   * If the longest name is greater than 80 characters, the number of columns
   * will be one.
   */
  maxnamelen = 0;
  for( k=0; k < num_in_list; k++) {
    namelen = strlen(list_of_names[k]->d_namep);
    if(namelen > maxnamelen)
      maxnamelen = namelen;
  }
  if(maxnamelen <= 16) 
    maxnamelen = 16;
  cwidth = maxnamelen + 4;
  if(cwidth > 80)
    cwidth = 80;
  numcol = TERMINAL_WIDTH / cwidth;
     
  /*
   * For the number of (full and partial) lines that will be needed,
   * print in vertical format.
   */
  lines = (num_in_list + (numcol - 1)) / numcol;
  for( i=0; i < lines; i++) {
    for(j=0; j < numcol; j++) {
      this_one = j * lines + i;
      bu_vls_printf(vls, "%s", list_of_names[this_one]->d_namep);
      namelen = strlen( list_of_names[this_one]->d_namep);
      /*
       * Region and ident checks here....  Since the code
       * has been modified to push and sort on pointers,
       * the printing of the region and ident flags must
       * be delayed until now.  There is no way to make the
       * decision on where to place them before now.
       */
      if(list_of_names[this_one]->d_flags & DIR_COMB) {
	bu_vls_putc(vls, '/');
	namelen++;
      }
      if(list_of_names[this_one]->d_flags & DIR_REGION) {
	bu_vls_putc(vls, 'R');
	namelen++;
      }
      /*
       * Size check (partial lines), and line termination.
       * Note that this will catch the end of the lines
       * that are full too.
       */
      if( this_one + lines >= num_in_list) {
	bu_vls_putc(vls, '\n');
	break;
      } else {
	/*
	 * Pad to next boundary as there will be
	 * another entry to the right of this one. 
	 */
        while( namelen++ < cwidth)
	  bu_vls_putc(vls, ' ');
      }
    }
  }
}

void
vls_long_dpp( 
	struct bu_vls *vls,
	struct directory **list_of_names,
	int num_in_list,
	int aflag,	/* print all objects */
	int cflag,	/* print combinations */
	int rflag,	/* print regions */
	int sflag)	/* print solids */
{
  int i;
  int isComb, isRegion;
  int isSolid;
  const char *type;
  int max_nam_len = 0;
  int max_type_len = 0;
  struct directory *dp;

  qsort( (genptr_t)list_of_names,
	 (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	 (int (*)())cmpdirname);

  for( i=0 ; i<num_in_list ; i++ ) {
	  int len;

	  dp = list_of_names[i];
	  len = strlen( dp->d_namep );
	  if( len > max_nam_len )
		  max_nam_len = len;

	  if( dp->d_flags & DIR_REGION )
		  len = 6;
	  else if( dp->d_flags & DIR_COMB )
		  len = 4;
	  else if( dp->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
		  len = 6;
	  else
		  len = strlen( rt_functab[dp->d_minor_type].ft_label );

	  if( len > max_type_len )
		  max_type_len = len;
  }
  /*
   * i - tracks the list item
   */
  for (i=0; i < num_in_list; ++i) {
    if (list_of_names[i]->d_flags & DIR_COMB) {
      isComb = 1;
      isSolid = 0;
      type = "comb";

      if (list_of_names[i]->d_flags & DIR_REGION) {
	isRegion = 1;
        type = "region";
      }
      else
	isRegion = 0;
    } else {
      isComb = isRegion = 0;
      isSolid = 1;
      type = rt_functab[list_of_names[i]->d_minor_type].ft_label;
    }

    if( list_of_names[i]->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY ) {
	    isSolid = 0;
	    type = "global";
    }

    /* print list item i */
    dp = list_of_names[i];
    if (aflag ||
	(!cflag && !rflag && !sflag) ||
	(cflag && isComb) ||
	(rflag && isRegion) ||
	(sflag && isSolid)) {
	    bu_vls_printf(vls, "%s", dp->d_namep );
	    bu_vls_spaces(vls, max_nam_len - strlen( dp->d_namep ) );
	    bu_vls_printf(vls, " %s", type );
	    bu_vls_spaces(vls, max_type_len - strlen( type ) );
	    bu_vls_printf(vls,  " %2d %2d %d\n",
		    dp->d_major_type, dp->d_minor_type, dp->d_len);
    }
  }
}
/*
 *				V L S _ L I N E _ D P P
 *
 *  Given a pointer to a list of pointers to names and the number of names
 *  in that list, sort and print that list on the same line.
 */
void
vls_line_dpp(
	struct bu_vls *vls,
	struct directory **list_of_names,
	int num_in_list,
	int aflag,	/* print all objects */
	int cflag,	/* print combinations */
	int rflag,	/* print regions */
	int sflag)	/* print solids */
{
  int i;
  int isComb, isRegion;
  int isSolid;

  qsort( (genptr_t)list_of_names,
	 (unsigned)num_in_list, (unsigned)sizeof(struct directory *),
	 (int (*)())cmpdirname);

  /*
   * i - tracks the list item
   */
  for (i=0; i < num_in_list; ++i) {
    if (list_of_names[i]->d_flags & DIR_COMB) {
      isComb = 1;
      isSolid = 0;

      if (list_of_names[i]->d_flags & DIR_REGION)
	isRegion = 1;
      else
	isRegion = 0;
    } else {
      isComb = isRegion = 0;
      isSolid = 1;
    }

    /* print list item i */
    if (aflag ||
	(!cflag && !rflag && !sflag) ||
	(cflag && isComb) ||
	(rflag && isRegion) ||
	(sflag && isSolid)) {
      bu_vls_printf(vls,  "%s ", list_of_names[i]->d_namep);
    }
  }
}
@


11.24
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/columns.c,v 11.23 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.23
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d31 5
a35 1
#include "conf.h"
@


11.22
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.21 2002/08/20 17:08:22 jra Exp $ (BRL)";
d102 1
a102 3
cmpdirname(a, b)
const genptr_t a;
const genptr_t b;
@


11.21
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1985 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.19 2001/04/05 19:35:43 morrison Exp $ (BRL)";
@


11.21.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/columns.c,v 11.22 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.21.10.1
log
@merge from HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.22 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.21.10.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.21.10.1 2004/02/12 18:34:13 erikg Exp $ (BRL)";
@


11.21.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.21 2002/08/20 17:08:22 jra Exp $ (BRL)";
d102 3
a104 1
cmpdirname(const genptr_t a, const genptr_t b)
@


11.21.2.2
log
@sync branch with HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.20
log
@Converted from K&R to ANSI C - RFH
@
text
@d102 3
a104 1
cmpdirname(const genptr_t a, const genptr_t b)
@


11.19
log
@updated SIGNED to signed
updated CONST to const
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.18 2001/04/02 18:10:10 jra Exp $ (BRL)";
d102 1
a102 3
cmpdirname(a, b)
const genptr_t a;
const genptr_t b;
@


11.18
log
@Lint
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.17 2001/03/23 22:05:34 jra Exp $ (BRL)";
d103 2
a104 2
CONST genptr_t a;
CONST genptr_t b;
d209 1
a209 1
  CONST char *type;
@


11.17
log
@Support for major and minor types in directory structure
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/columns.c,v 11.16 2001/03/23 21:27:01 tranese Exp $ (BRL)";
d34 7
@


11.16
log
@*** empty log message ***
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/columns.c,v 11.15 2000/09/07 02:43:20 mike Exp $ (BRL)";
d189 84
@


11.15
log
@
More externs to ged.h to silence lint
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.14 2000/08/19 03:10:42 mike Exp $ (BRL)";
d116 4
d125 19
d148 1
a148 1
  lines = (num_in_list + 3) / 4;
d150 1
a150 1
    for( j=0; j < 4; j++) {
d152 1
a152 2
      /* Restrict the print to 16 chars per spec. */
      bu_vls_printf(vls,  "%.16s", list_of_names[this_one]->d_namep);
a153 2
      if( namelen > 16)
	namelen = 16;
d182 1
a182 1
	while( namelen++ < 20)
@


11.14
log
@
const RCSid
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.13 2000/07/24 22:22:11 mike Exp $ (BRL)";
d50 3
a52 3
vls_col_item( str, cp )
struct bu_vls	*str;
register char	*cp;
d79 1
a79 2
vls_col_eol( str )
struct bu_vls	*str;
d113 1
a113 4
vls_col_pr4v(vls, list_of_names, num_in_list)
struct bu_vls *vls;
struct directory **list_of_names;
int num_in_list;
d176 8
a183 8
vls_line_dpp(vls, list_of_names, num_in_list, aflag, cflag, rflag, sflag)
struct bu_vls *vls;
struct directory **list_of_names;
int num_in_list;
int aflag;	/* print all objects */
int cflag;	/* print combinations */
int rflag;	/* print regions */
int sflag;	/* print solids */
@


11.13
log
@
More new-libwdb-related cleanups
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.12 1999/09/08 14:33:26 bparker Exp $ (BRL)";
@


11.12
log
@*- new routine - vls_line_dpp
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/columns.c,v 11.11 1997/02/28 21:24:25 jra Exp $ (BRL)";
d216 4
a219 4
	!cflag && !rflag && !sflag ||
	cflag && isComb ||
	rflag && isRegion ||
	sflag && isSolid) {
@


11.11
log
@removed include of db.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 11.10 1996/10/04 14:53:15 bparker Exp jra $ (BRL)";
d169 52
@


11.10
log
@remove col_item
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 11.9 1996/10/04 14:49:56 bparker Exp bparker $ (BRL)";
a36 1
#include "db.h"			/* for NAMESIZE */
@


11.9
log
@get rid of code that used non-vls output routines
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 11.8 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
a88 30

/*
 *			C O L _ I T E M
 */
void
col_item(cp)
register char *cp;
{
	/* Output newline if last column printed. */
	if( col_count >= COLUMNS || (col_len+NAMESIZE-1) >= TERMINAL_WIDTH )  {
		/* line now full */
		bu_putchar( '\n' );
		col_count = 0;
	} else if ( col_count != 0 ) {
		/* Space over before starting new column */
		do {
			bu_putchar( ' ' );
			col_len++;
		}  while ( (col_len % NAMESIZE) != 0 );
	}
	/* Output string and save length for next tab. */
	col_len = 0;
	while ( *cp != '\0' )  {
		bu_putchar( *cp );
		++cp;
		++col_len;
	}
	col_count++;
#undef	COLUMNS
}
@


11.8
log
@rt_list ---> bu_list
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 11.7 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
a119 17
void
col_putchar(c)
char c;
{
	bu_putchar(c);
	col_len++;
}

void
col_eol()
{
	if ( col_count != 0 )		/* partial line */
		bu_putchar( '\n' );
	col_count = 0;
	col_len = 0;
}

d145 2
a146 66
col_pr4v( list_of_names, num_in_list)
struct directory **list_of_names;
int num_in_list;
{
	int lines, i, j, namelen, this_one;

	qsort( (genptr_t)list_of_names,
		(unsigned)num_in_list, (unsigned)sizeof(struct directory *),
		(int (*)())cmpdirname);
	/*
	 * For the number of (full and partial) lines that will be needed,
	 * print in vertical format.
	 */
	lines = (num_in_list + 3) / 4;
	for( i=0; i < lines; i++) {
		for( j=0; j < 4; j++) {
			this_one = j * lines + i;
			/* Restrict the print to 16 chars per spec. */
			bu_log( "%.16s", list_of_names[this_one]->d_namep); 
			namelen = strlen( list_of_names[this_one]->d_namep);
			if( namelen > 16)
				namelen = 16;
			/*
			 * Region and ident checks here....  Since the code
			 * has been modified to push and sort on pointers,
			 * the printing of the region and ident flags must
			 * be delayed until now.  There is no way to make the
			 * decision on where to place them before now.
			 */
			if(list_of_names[this_one]->d_flags & DIR_COMB) {
				bu_putchar('/');
				namelen++;
			}
			if(list_of_names[this_one]->d_flags & DIR_REGION) {
				bu_putchar('R');
				namelen++;
			}
			/*
			 * Size check (partial lines), and line termination.
			 * Note that this will catch the end of the lines
			 * that are full too.
			 */
			if( this_one + lines >= num_in_list) {
				bu_log("\n");
				break;
			} else {
				/*
				 * Pad to next boundary as there will be
				 * another entry to the right of this one. 
				 */
				while( namelen++ < 20)
					bu_putchar(' ');
			}
		}
	}
}

/*
 *				V L S _ C O L _ P R 4 V
 *
 *  Given a pointer to a list of pointers to names and the number of names
 *  in that list, sort and print that list in column order over four columns.
 */
void
vls_col_pr4v( str, list_of_names, num_in_list)
struct bu_vls	*str;
d150 1
a150 3
	int lines, i, j, namelen, this_one;

	BU_CK_VLS( str );
d152 41
a192 3
	qsort( (genptr_t)list_of_names,
		(unsigned)num_in_list, (unsigned)sizeof(struct directory *),
		(int (*)())cmpdirname);
d194 2
a195 2
	 * For the number of (full and partial) lines that will be needed,
	 * print in vertical format.
d197 5
a201 42
	lines = (num_in_list + 3) / 4;
	for( i=0; i < lines; i++) {
		for( j=0; j < 4; j++) {
			this_one = j * lines + i;
			/* Restrict the print to 16 chars per spec. */
			bu_vls_printf( str, "%.16s", list_of_names[this_one]->d_namep);
			namelen = strlen( list_of_names[this_one]->d_namep);
			if( namelen > 16)
				namelen = 16;
			/*
			 * Region and ident checks here....  Since the code
			 * has been modified to push and sort on pointers,
			 * the printing of the region and ident flags must
			 * be delayed until now.  There is no way to make the
			 * decision on where to place them before now.
			 */
			if(list_of_names[this_one]->d_flags & DIR_COMB) {
				bu_vls_putc(str, '/');
				namelen++;
			}
			if(list_of_names[this_one]->d_flags & DIR_REGION) {
				bu_vls_putc(str, 'R');
				namelen++;
			}
			/*
			 * Size check (partial lines), and line termination.
			 * Note that this will catch the end of the lines
			 * that are full too.
			 */
			if( this_one + lines >= num_in_list) {
				bu_vls_putc(str, '\n');
				break;
			} else {
				/*
				 * Pad to next boundary as there will be
				 * another entry to the right of this one. 
				 */
				while( namelen++ < 20)
					bu_vls_putc(str, ' ');
			}
		}
	}
@


11.7
log
@now using libbu
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 11.6 1996/03/01 19:33:51 bparker Exp bparker $ (BRL)";
d35 1
a37 1
#include "rtstring.h"
@


11.6
log
@remove unused XMGED stuff
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 11.5 1995/09/22 02:17:40 mike Exp bparker $ (BRL)";
d52 1
a52 1
struct rt_vls	*str;
d58 1
a58 1
		rt_vls_putc( str, '\n' );
d63 1
a63 1
			rt_vls_putc( str, ' ' );
d70 1
a70 1
		rt_vls_putc( str, *cp );
d81 1
a81 1
struct rt_vls	*str;
d84 1
a84 1
		rt_vls_putc( str, '\n' );
d100 1
a100 1
		rt_putchar( '\n' );
d105 1
a105 1
			rt_putchar( ' ' );
d112 1
a112 1
		rt_putchar( *cp );
d124 1
a124 1
	rt_putchar(c);
d132 1
a132 1
		rt_putchar( '\n' );
d180 1
a180 2
			rt_log( "%.16s", list_of_names[this_one]->d_namep); 
/*			printf( "%.16s", list_of_names[this_one]->d_namep);  */
d192 1
a192 1
				rt_putchar('/');
d196 1
a196 1
				rt_putchar('R');
d205 1
a205 1
				rt_log("\n");
d213 1
a213 1
					rt_putchar(' ');
d227 1
a227 1
struct rt_vls	*str;
d233 1
a233 1
	RT_VLS_CHECK( str );
d247 1
a247 1
			rt_vls_printf( str, "%.16s", list_of_names[this_one]->d_namep);
d259 1
a259 1
				rt_vls_putc(str, '/');
d263 1
a263 1
				rt_vls_putc(str, 'R');
d272 1
a272 1
				rt_vls_putc(str, '\n');
d280 1
a280 1
					rt_vls_putc(str, ' ');
@


11.5
log
@Finished converting dir_print() over to TCL.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/columns.c,v 11.4 1995/09/09 02:35:32 mike Exp mike $ (BRL)";
a96 26
#ifdef XMGED
	char 	line[133], *lineptr;

	lineptr = line;

	/* Output newline if last column printed. */
	if( col_count >= COLUMNS || (col_len+NAMESIZE-1) >= TERMINAL_WIDTH )  {
		/* line now full */
		sprintf(lineptr, "\n");
		++lineptr;
		col_count = 0;
	} else if ( col_count != 0 ) {
		/* Space over before starting new column */
		do {
			sprintf(lineptr, " ");
			lineptr++;
			col_len++;
		}  while ( (col_len % NAMESIZE) != 0 );
	}
	/* Output string and save length for next tab. */
	sprintf(lineptr, "%s", cp);
	rt_log( "%s", line);
	col_len = strlen(cp);
	
	col_count++;
#else
a116 1
#endif
a154 75
#ifdef XMGED
/*
 *				C O L _ P R 4 V
 *
 *  Given a pointer to a list of pointers to names and the number of names
 *  in that list, sort and print that list in column order over four columns.
 */
void
col_pr4v( list_of_names, num_in_list)
struct directory **list_of_names;
int num_in_list;
{
	int lines, i, j, namelen, this_one;
	char line[133], *lineptr;

	lineptr = line;

	qsort( (genptr_t)list_of_names,
		(unsigned)num_in_list, (unsigned)sizeof(struct directory *),
		(int (*)())cmpdirname);
	/*
	 * For the number of (full and partial) lines that will be needed,
	 * print in vertical format.
	 */
	lines = (num_in_list + 3) / 4;
	for( i=0; i < lines; i++) {
		for( j=0; j < 4; j++) {
			this_one = j * lines + i;
			/* Restrict the print to 16 chars per spec. */
			sprintf(lineptr,  "%.16s", list_of_names[this_one]->d_namep);
			namelen = strlen( list_of_names[this_one]->d_namep);
			if( namelen > 16)
				namelen = 16;
			lineptr += namelen;
			/*
			 * Region and ident checks here....  Since the code
			 * has been modified to push and sort on pointers,
			 * the printing of the region and ident flags must
			 * be delayed until now.  There is no way to make the
			 * decision on where to place them before now.
			 */
			if(list_of_names[this_one]->d_flags & DIR_COMB) {
				sprintf(lineptr,  "/");
				namelen++;
				++lineptr;
			}
			if(list_of_names[this_one]->d_flags & DIR_REGION) {
				sprintf(lineptr,  "R");
				namelen++;
				++lineptr;
			}
			/*
			 * Size check (partial lines), and line termination.
			 * Note that this will catch the end of the lines
			 * that are full too.
			 */
			if( this_one + lines >= num_in_list) {
				sprintf(lineptr,  "\n");
				rt_log("%s", line);
				lineptr = line;
				break;
			} else {
				/*
				 * Pad to next boundary as there will be
				 * another entry to the right of this one. 
				 */
				while( namelen++ < 20){
					sprintf(lineptr,  " ");
					++lineptr;
				}
			}
		}
	}
}
#else
a218 1
#endif
d221 1
a221 1
 *				C O L _ P R 4 V
@


11.4
log
@Added vls_col_item(), vls_col_eol.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 11.3 1995/01/19 12:20:00 bparker Exp mike $ (BRL)";
d322 67
@


11.3
log
@modified col_pr4v for XMGED
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 11.2 95/01/17 13:04:27 bparker Exp $ (BRL)";
d37 1
d47 46
@


11.2
log
@merging xmged sources
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/columns.c,v 11.2 95/01/17 11:42:08 bparker Exp $ (BRL)";
d135 1
d148 1
d150 2
d164 71
d274 1
@


11.1
log
@Release_4.4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 10.7 94/12/23 21:57:03 gdurf Exp $ (BRL)";
d50 5
d58 21
d96 1
@


10.7
log
@Added support for rt_putchar
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 10.6 1994/12/16 20:44:05 gdurf Exp gdurf $ (BRL)";
@


10.6
log
@Fixed typo
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 10.5 1994/12/16 20:29:16 gdurf Exp gdurf $ (BRL)";
d53 1
a53 1
		rt_log( "\n" );
d58 1
a58 1
			rt_log( " " );
d65 1
a65 1
		rt_log( "%c", *cp );	/* dreadful performance */
d77 1
a77 1
	rt_log("%c", c);	/* dreadful performance */
d85 1
a85 1
		rt_log( "\n" );
d146 1
a146 1
				rt_log("/");
d150 1
a150 1
				rt_log("R");
d167 1
a167 1
					rt_log(" ");
@


10.5
log
@Changed putchar to rt_log (yuk)
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 10.4 1994/12/16 20:24:37 gdurf Exp gdurf $ (BRL)";
d58 1
a58 1
			rt_log( ' ' );
@


10.4
log
@Turned putchars into rt_logs
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 10.3 1994/12/16 19:35:49 gdurf Exp $ (BRL)";
d53 1
a53 1
		(void)putchar( '\n' );
d58 1
a58 1
			(void)putchar( ' ' );
d65 1
a65 1
		(void)putchar( *cp );	/* is a macro */
d77 1
a77 1
	(void)putchar(c);
d85 1
a85 1
		(void)putchar( '\n' );
@


10.3
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 10.2 1994/08/09 15:01:23 gdurf Exp gdurf $ (BRL)";
d133 2
a134 1
			rt_log( "%.16s", list_of_names[this_one]->d_namep);
d146 1
a146 1
				putchar('/');
d150 1
a150 1
				putchar('R');
d159 1
a159 1
				putchar('\n');
d167 1
a167 1
					putchar(' ');
@


10.2
log
@Added include
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 10.1 1991/10/12 06:43:15 mike Rel4_0 gdurf $ (BRL)";
d133 1
a133 1
			printf( "%.16s", list_of_names[this_one]->d_namep);
@


10.1
log
@Release_4.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 9.7 91/09/26 22:42:51 butler Exp $ (BRL)";
d31 2
d43 1
a43 1
#define TERMINAL_WIDTH	80
@


9.7
log
@cast the last argument to qsort so that the !@@$# ansi compiler shuts up.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 9.6 90/12/13 16:31:14 mike Exp Locker: butler $ (BRL)";
@


9.6
log
@A further attempt at a satisfactory qsort() STDC on xmp.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 9.5 90/12/07 00:57:19 mike Exp $ (BRL)";
d121 1
a121 1
		cmpdirname);
@


9.5
log
@lint
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 9.4 90/06/07 01:07:04 mike Exp $ (BRL)";
d96 2
a97 1
CONST genptr_t a, b;
@


9.4
log
@A not entirely successful attempt to accomodate the ANSI C
definition of qsort().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/columns.c,v 9.3 89/12/29 14:48:44 mike Exp $ (BRL)";
d119 1
a119 1
		num_in_list, sizeof(struct directory *),
@


9.3
log
@Fixed confusion between col_count and col_len
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 9.2 89/12/28 14:35:25 mike Locked $ (BRL)";
d95 2
a96 2
cmpdirname(dp1, dp2)
struct directory **dp1, **dp2;
d98 4
d118 3
a120 2
	qsort(list_of_names, num_in_list, sizeof(struct directory *),
	  cmpdirname);
@


9.2
log
@Changed from using tab characters to using spaces.
Fixed bug with a column of NAMESIZE characters throwing
everything following off by 8 characters (tab width).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 9.1 89/05/19 06:02:06 mike Locked $ (BRL)";
d41 2
a42 1
#define	COLUMNS	((80 + NAMESIZE - 1) / NAMESIZE)
d49 1
a49 1
	if ( (col_count+NAMESIZE-1) >= COLUMNS )  {
@


9.1
log
@Release_3.5
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 8.3 89/04/06 20:18:05 mike Exp $ (BRL)";
d48 2
a49 1
	if ( col_count >= COLUMNS )  {	/* line now full */
d53 5
a57 4
		/* Tab to start column. */
		do
			(void)putchar( '\t' );
		while ( (col_len += 8) < NAMESIZE );
@


8.3
log
@Converted to externs.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 8.2 88/12/06 01:00:12 mike Locked $ (BRL)";
@


8.2
log
@Switched to raytrace.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/columns.c,v 1.2 88/10/23 13:55:46 mike Exp $ (BRL)";
d36 1
a41 2

extern int qsort(), strcmp();
@


8.1
log
@Release_3.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 7.2 88/09/17 02:23:04 reschly Exp $ (BRL)";
d35 1
a36 1
#include "./objdir.h"		/* for directory structure */
@


7.2
log
@added machine vmath and ged includes.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 7.1 87/11/02 23:59:03 reschly Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 6.1 87/07/11 08:02:19 mike Rel $ (BRL)";
d32 2
d35 1
@


6.1
log
@Release 2.0
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 5.1 87/06/24 22:18:31 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 4.2 87/02/13 00:06:03 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 4.1 86/12/29 03:19:44 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 2.4 86/11/15 10:26:26 mike Exp $ (BRL)";
@


2.4
log
@Accomodated macro nature of putchar().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 2.3 86/08/12 06:47:31 mike Locked $ (BRL)";
@


2.3
log
@Changed #includes for CC -I../h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 2.2 86/05/27 23:48:15 reschly Exp $ (BRL)";
d58 2
a59 1
		(void)putchar( *cp++ );
@


2.2
log
@Added col_pr4v() to print 4-columns vertically
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 2.1 85/03/11 23:54:25 mike Prod $ (BRL)";
d32 2
a33 2
#include "../h/db.h"		/* for NAMESIZE */
#include "objdir.h"		/* for directory structure */
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d10 3
d14 1
a14 1
 *  Author -
d16 1
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: columns.c,v 1.2 85/02/05 04:17:28 mike Exp $ (BRL)";
d33 1
d39 2
d80 76
@


1.2
log
@improved.
@
text
@d11 4
a14 1
 * Source -
d18 4
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: columns.c,v 1.1 85/02/05 01:39:47 mike Exp $ (BRL)";
d28 1
a28 1
#include "db.h"		/* for NAMESIZE */
d34 1
d58 1
d66 1
@


1.1
log
@Initial revision
@
text
@a6 1
 *	col_init	Called to initialize a new table
d9 1
a9 1
 *	col_end		Called to finish printing the table
d17 1
a17 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d20 1
a26 5
col_init() {
	col_count = 0;
	col_len = 0;
}

d40 1
a40 1
	/* Output name and save length for next tab. */
d42 1
a42 1
	do {
d45 2
a46 1
	}  while ( *cp != '\0' );
d57 1
a57 1
col_end()
d61 2
@
