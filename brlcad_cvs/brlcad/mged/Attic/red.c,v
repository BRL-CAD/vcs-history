head	11.72;
access;
symbols
	ansi-20040405-merged:11.67.2.2
	postmerge-20040405-ansi:11.70
	premerge-20040404-ansi:11.69
	postmerge-autoconf:11.69
	autoconf-freeze:11.67.10.3
	premerge-autoconf:11.69
	postmerge-20040315-windows:11.69
	premerge-20040315-windows:11.68
	windows-20040315-freeze:11.67.4.2
	autoconf-20031203:11.67
	autoconf-20031202:11.67
	autoconf-branch:11.67.0.10
	phong-branch:11.67.0.8
	photonmap-branch:11.67.0.6
	rel-6-1-DP:11.67
	windows-branch:11.67.0.4
	rel-6-0-2:11.65
	ansi-branch:11.67.0.2
	rel-6-0-1-branch:11.65.0.2
	hartley-6-0-post:11.66
	hartley-6-0-pre:11.65
	rel-6-0-1:11.65
	rel-6-0:11.65
	rel-5-4:11.47.2.1
	offsite-5-3-pre:11.57
	rel-5-3:11.47.2.1
	rel-5-2:11.47
	rel-5-1-branch:11.47.0.2
	rel-5-1:11.47
	rel-5-0:11.36
	rel-5-0-beta:11.32
	rel-4-5:11.27
	ctj-4-5-post:11.23
	ctj-4-5-pre:11.23
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.72
date	2004.05.21.17.47.49;	author morrison;	state dead;
branches;
next	11.71;

11.71
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.70;

11.70
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.69;

11.69
date	2004.03.16.21.15.12;	author morrison;	state Exp;
branches;
next	11.68;

11.68
date	2004.02.02.17.39.34;	author morrison;	state Exp;
branches;
next	11.67;

11.67
date	2002.08.20.17.08.25;	author jra;	state Exp;
branches
	11.67.2.1
	11.67.4.1
	11.67.10.1;
next	11.66;

11.66
date	2002.08.15.20.55.37;	author hartley;	state Exp;
branches;
next	11.65;

11.65
date	2001.10.15.21.44.08;	author bparker;	state Exp;
branches;
next	11.64;

11.64
date	2001.10.02.19.24.32;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	2001.08.22.17.26.46;	author jra;	state Exp;
branches;
next	11.62;

11.62
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	2001.05.04.14.43.27;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	2001.05.04.14.20.46;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	2001.04.03.19.01.59;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	2001.03.23.22.05.35;	author jra;	state Exp;
branches;
next	11.57;

11.57
date	2001.01.19.16.11.51;	author jra;	state Exp;
branches;
next	11.56;

11.56
date	2001.01.11.14.38.51;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	2001.01.08.17.11.09;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	2000.10.24.19.05.08;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.09.08.05.55.49;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.08.25.01.35.19;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.08.25.01.33.19;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	2000.08.22.06.49.08;	author mike;	state Exp;
branches;
next	11.49;

11.49
date	2000.08.19.03.10.48;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	2000.07.23.23.42.21;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.06.01.21.35.36;	author bparker;	state Exp;
branches
	11.47.2.1;
next	11.46;

11.46
date	2000.06.01.14.54.54;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	2000.05.31.20.50.53;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	2000.03.02.19.01.36;	author jra;	state Exp;
branches;
next	11.43;

11.43
date	2000.01.03.13.49.42;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	99.12.29.23.23.24;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	99.11.26.23.03.33;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	99.11.24.14.26.42;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	99.11.18.22.38.01;	author cjohnson;	state Exp;
branches;
next	11.38;

11.38
date	99.10.15.18.30.23;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	99.10.14.13.57.02;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	99.09.01.18.55.11;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	99.07.16.20.15.55;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	99.07.16.18.03.20;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	99.07.07.15.41.04;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	99.04.23.17.51.17;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	99.01.21.18.31.20;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	99.01.04.22.51.42;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	98.06.11.20.48.11;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	98.04.07.14.53.58;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	97.11.05.19.25.13;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	97.09.26.21.25.01;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	97.09.23.21.11.59;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	97.03.20.14.47.18;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	97.03.04.19.29.35;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	97.02.28.21.40.49;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	97.02.27.15.46.03;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	97.02.20.21.45.31;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	97.02.20.19.38.28;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.01.30.02.19.40;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.01.29.01.56.52;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.01.29.01.50.24;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.10.04.15.06.14;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.10.03.20.51.25;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.25.12.37.19;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.07.15.20.35.25;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.03.01.19.29.08;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.07.25.17.49.38;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.58;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.30;	author mike;	state Rel4_4;
branches;
next	1.10;

1.10
date	94.12.16.19.37.14;	author gdurf;	state Exp;
branches;
next	1.9;

1.9
date	94.11.10.12.06.14;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.10.18.00.22.32;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.08.25.13.01.28;	author gdurf;	state Exp;
branches;
next	1.6;

1.6
date	94.08.09.18.27.54;	author gdurf;	state Exp;
branches;
next	1.5;

1.5
date	94.07.11.20.48.09;	author gdurf;	state Exp;
branches;
next	1.4;

1.4
date	94.06.13.19.01.23;	author gdurf;	state Exp;
branches;
next	1.3;

1.3
date	94.06.01.17.16.28;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	93.04.30.18.54.51;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	92.05.04.14.12.20;	author mike;	state Exp;
branches;
next	;

11.47.2.1
date	2001.01.08.17.22.08;	author bparker;	state Exp;
branches;
next	;

11.67.2.1
date	2002.09.19.18.02.04;	author morrison;	state Exp;
branches;
next	11.67.2.2;

11.67.2.2
date	2004.03.17.21.22.03;	author morrison;	state Exp;
branches;
next	;

11.67.4.1
date	2002.09.26.23.04.13;	author morrison;	state Exp;
branches;
next	11.67.4.2;

11.67.4.2
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

11.67.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.67.10.2;

11.67.10.2
date	2004.03.15.14.07.39;	author erikg;	state Exp;
branches;
next	11.67.10.3;

11.67.10.3
date	2004.03.18.18.10.31;	author erikg;	state Exp;
branches;
next	;


desc
@Region Editor
@


11.72
log
@moved to src/mged/
@
text
@/*
 *			R E D . C
 *
 *	These routines allow editing of a combination using the text editor
 *	of the users choice.
 *
 *  Author -
 *	John Anderson
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1992-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/red.c,v 11.71 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <signal.h>
#ifdef USE_STRING_H
#	include <string.h>
#else
#	include <strings.h>
#endif
#include <errno.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "externs.h"
#include "raytrace.h"
#include "./ged.h"
#include "./sedit.h"
#include <ctype.h>

extern int cmd_name(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static char	red_tmpfil[17];
#ifndef WIN32
static char	*red_tmpfil_init = "/tmp/GED.aXXXXXX";
#else
static char	*red_tmpfil_init = "C:\\GED.aXXXXXX";
#endif
static char	red_tmpcomb[16];
static char	*red_tmpcomb_init = "red_tmp.aXXXXXX";
static char	delims[] = " \t/";	/* allowable delimiters */

void put_rgb_into_comb(struct rt_comb_internal *comb, char *str);
void restore_comb(struct directory *dp);
int editit(const char *file);
static int make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index);
int clear_comb(),build_comb(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name),save_comb(struct directory *dpold);

int
f_red(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int node_count;
	int fd;

	CHECK_DBI_NULL;
#if 0
	CHECK_READ_ONLY;
#endif

	if(argc != 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help red");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	strcpy(red_tmpfil, red_tmpfil_init);
	strcpy(red_tmpcomb, red_tmpcomb_init);

	dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );

	if( dp != DIR_NULL )
	{
		if( !(dp->d_flags & DIR_COMB ) )
		{
		  Tcl_AppendResult(interp, argv[1],
				   " is not a combination, so cannot be edited this way\n", (char *)NULL);
		  return TCL_ERROR;
		}

		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
			TCL_READ_ERR_return;

		comb = (struct rt_comb_internal *)intern.idb_ptr;

		/* Make a file for the text editor */
#ifdef WIN32
		(void)mktemp( red_tmpfil );
#else
		if ((fd = mkstemp(red_tmpfil)) < 0) {
			perror(red_tmpfil);
			return TCL_ERROR;;
		}
		(void)close(fd);
#endif

		/* Write the combination components to the file */
		if( writecomb( comb, dp->d_namep ) )
		{
		  Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
		  unlink( red_tmpfil );
		  return TCL_ERROR;
		}
	}
	else
	{
		comb = (struct rt_comb_internal *)NULL;
		/* Make a file for the text editor */
#ifdef WIN32
		(void)mktemp( red_tmpfil );
#else
		if ((fd = mkstemp(red_tmpfil)) < 0) {
			perror(red_tmpfil);
			return TCL_ERROR;;
		}
		(void)close(fd);
#endif

		/* Write the combination components to the file */
		if( writecomb( comb, argv[1] ) )
		{
		  Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
		  unlink( red_tmpfil );
		  return TCL_ERROR;
		}
	}

	/* Edit the file */
	if( editit( red_tmpfil ) ){
		if (!dbip->dbi_read_only) {
			if( (node_count = checkcomb()) < 0 ){ /* Do some quick checking on the edited file */
				Tcl_AppendResult(interp, "Error in edited region, no changes made\n", (char *)NULL);
				if( comb )
					rt_comb_ifree( &intern, &rt_uniresource );
				(void)unlink( red_tmpfil );
				return TCL_ERROR;
			}

			if( comb ){
				if( save_comb( dp ) ){ /* Save combination to a temp name */
					Tcl_AppendResult(interp, "No changes made\n", (char *)NULL);
					rt_comb_ifree( &intern, &rt_uniresource );
					(void)unlink( red_tmpfil );
					return TCL_OK;
				}
			}

			if( build_comb( comb, dp, node_count, argv[1] ) ){
				Tcl_AppendResult(interp, "Unable to construct new ", dp->d_namep,
						 (char *)NULL);
				if( comb ){
					restore_comb( dp );
					Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL );
					rt_comb_ifree( &intern, &rt_uniresource );
				}

				(void)unlink( red_tmpfil );
				return TCL_ERROR;
			}else if( comb ){
				/* eliminate the temporary combination */
				char *av[3];

				av[0] = "kill";
				av[1] = red_tmpcomb;
				av[2] = NULL;
				(void)cmd_kill(clientData, interp, 2, av);
			}
		} else {
			Tcl_AppendResult(interp, "Because the database is READ-ONLY no changes were made.\n", (char *)NULL);
		}
	}

	(void)unlink( red_tmpfil );
	return TCL_OK;
}

HIDDEN char *
find_keyword(int i, char *line, char *word)
{
	char *ptr1;
	char *ptr2;
	int j;

	/* find the keyword */
	ptr1 = strstr( &line[i], word );
	if( !ptr1 )
		return( (char *)NULL );

	/* find the '=' */
	ptr2 = strchr( ptr1, '=' );
	if( !ptr2 )
		return( (char *)NULL );

	/* skip any white space before the value */
	while( isspace( *(++ptr2) ) );

	/* eliminate trailing white space */
	j = strlen( line );
	while( isspace( line[--j] ) );
	line[j+1] = '\0';

	/* return pointer to the value */
	return( ptr2 );
}

HIDDEN void
print_matrix(FILE *fp, matp_t matrix)
{
	int k;
	char buf[64];
	fastf_t tmp;

	if( !matrix )
		return;

	if( bn_mat_is_identity( matrix ) )
		return;

	for( k=0 ; k<16 ; k++ )
	{
		sprintf( buf, "%g", matrix[k] );
		tmp = atof( buf );
		if( tmp == matrix[k] )
			fprintf( fp, " %g", matrix[k] );
		else
			fprintf( fp, " %.12e", matrix[k] );
	}
}

HIDDEN void
vls_print_matrix(struct bu_vls *vls, matp_t matrix)
{
  int k;
  char buf[64];
  fastf_t tmp;

  if(!matrix)
    return;

  if(bn_mat_is_identity(matrix))
    return;

  for(k=0; k<16; k++){
    sprintf(buf, "%g", matrix[k]);
    tmp = atof(buf);
    if(tmp == matrix[k])
      bu_vls_printf(vls, " %g", matrix[k]);
    else
      bu_vls_printf(vls, " %.12e", matrix[k]);
  }
}

void
put_rgb_into_comb(struct rt_comb_internal *comb, char *str)
{
  int r, g, b;

  if(sscanf(str, "%d%d%d", &r, &g, &b) != 3){
    comb->rgb_valid = 0;
    return;
  }

  /* clamp the RGB values to [0,255] */
  if(r < 0)
    r = 0;
  else if(r > 255)
    r = 255;

  if(g < 0)
    g = 0;
  else if(g > 255)
    g = 255;

  if(b < 0)
    b = 0;
  else if(b > 255)
    b = 255;

  comb->rgb[0] = (unsigned char)r;
  comb->rgb[1] = (unsigned char)g;
  comb->rgb[2] = (unsigned char)b;
  comb->rgb_valid = 1;
}

struct line_list{
  struct bu_list l;
  char *line;
};

struct line_list HeadLines;

HIDDEN int
count_nodes(char *line)
{
  char *ptr;
  char *name;
  char relation;
  int node_count=0;

  /* sanity */
  if (line == NULL)
    return 0;

  ptr = strtok(line , delims);

  while (ptr) {
    /* First non-white is the relation operator */
    relation = (*ptr);

    if (relation != '+' && relation != 'u' && relation != '-') {
      struct bu_vls tmp_vls;

      bu_vls_init(&tmp_vls);
      bu_vls_printf(&tmp_vls, " %c is not a legal operator\n" , relation );
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);
      return( -1 );
    }

    /* Next must be the member name */
    name = strtok((char *)NULL, delims);

    if (name == NULL) {
      Tcl_AppendResult(interp, " operand name missing\n", (char *)NULL);
      return( -1 );
    }

    ptr = strtok( (char *)NULL, delims );
    /*
     * If this token is not a boolean operator, then it must be the start
     * of a matrix which we will skip.
     */
    if (ptr && !((*ptr == 'u' || *ptr == '-' || *ptr=='+') &&
		 *(ptr+1) == '\0')) {
      int k;

      /* skip past matrix, k=1 because we already have the first value */
      for (k=1 ; k<16 ; k++) {
	ptr = strtok( (char *)NULL, delims );
	if (!ptr) {
	  Tcl_AppendResult(interp, "expecting a matrix\n", (char *)NULL);
	  return( -1 );
	}
      }

      /* get the next relational operator on the current line */
      ptr = strtok( (char *)NULL, delims );
    }

    node_count++;
  }

  return node_count;
}

HIDDEN int
put_tree_into_comb(struct rt_comb_internal *comb, struct directory *dp, char *old_name, char *new_name, char *str)
{
	int			i;
	int			done;
	char			*line;
	char			*ptr;
	char			relation;
	char			*name;
	struct rt_tree_array	*rt_tree_array;
	struct line_list	*llp;
	int			node_count = 0;
	int			tree_index = 0;
	union tree		*tp;
	matp_t			matrix;
	struct bu_vls		vls;
	int			result;

	if (str == (char *)NULL)
		return TCL_ERROR;

	BU_LIST_INIT(&HeadLines.l);

	/* break str into lines */
	line = str;
	ptr = strchr(str, '\n');
	if (ptr != NULL)
		*ptr = '\0';
	bu_vls_init(&vls);
	while (line != (char *)NULL) {
		int n;

		bu_vls_strcpy(&vls, line);

		if ((n = count_nodes(bu_vls_addr(&vls))) < 0) {
			bu_vls_free(&vls);
			bu_list_free(&HeadLines.l);
			return TCL_ERROR;
		} else if (n > 0) {
			BU_GETSTRUCT(llp, line_list);
			BU_LIST_INSERT(&HeadLines.l, &llp->l);
			llp->line = line;

			node_count += n;
		} /* else blank line */

		if (ptr != NULL && *(ptr+1) != '\0') {
			/* leap frog past EOS */
			line = ptr + 1;

			ptr = strchr(line, '\n');
			if (ptr != NULL)
				*ptr = '\0';
		} else {
			line = NULL;
		}
	}
	bu_vls_free(&vls);

	/* build tree list */
	if (node_count)
		rt_tree_array = (struct rt_tree_array *)bu_calloc(node_count, sizeof(struct rt_tree_array), "tree list" );
	else
		rt_tree_array = (struct rt_tree_array *)NULL;

	for (BU_LIST_FOR(llp, line_list, &HeadLines.l)) {
		done = 0;
		ptr = strtok(llp->line, delims);
		while (!done) {
			if (!ptr)
				break;

			/* First non-white is the relation operator */
			relation = (*ptr);
			if (relation == '\0')
				break;

			/* Next must be the member name */
			ptr = strtok((char *)NULL, delims);
			if (ptr == (char *)NULL) {
				bu_list_free(&HeadLines.l);
				if (rt_tree_array)
					bu_free((char *)rt_tree_array, "red: tree list");
				bu_log("no name specified\n");
				return TCL_ERROR;
			}
			name = ptr;

			/* Eliminate trailing white space from name */
			i = strlen( ptr );
			while(isspace(name[--i]))
				name[i] = '\0';

			/* Check for existence of member */
			if ((db_lookup(dbip , name , LOOKUP_QUIET)) == DIR_NULL)
				bu_log("\tWARNING: ' %s ' does not exist\n", name);

			/* get matrix */
			ptr = strtok((char *)NULL, delims);
			if (ptr == (char *)NULL) {
				matrix = (matp_t)NULL;
				done = 1;
			} else if (*ptr == 'u' ||
				   (*ptr == '-' && *(ptr+1) == '\0') ||
				   (*ptr == '+' && *(ptr+1) == '\0')) {
				/* assume another relational operator */
				matrix = (matp_t)NULL;
			} else {
				int k;

				matrix = (matp_t)bu_calloc(16, sizeof(fastf_t), "red: matrix");
				matrix[0] = atof(ptr);
				for (k=1 ; k<16 ; k++) {
					ptr = strtok((char *)NULL, delims);
					if (!ptr) {
						bu_log("incomplete matrix for member %s - No changes made\n", name);
						bu_free( (char *)matrix, "red: matrix" );
						if(rt_tree_array)
							bu_free((char *)rt_tree_array, "red: tree list");
						bu_list_free(&HeadLines.l);
						return TCL_ERROR;
					}
					matrix[k] = atof( ptr );
				}
				if (bn_mat_is_identity( matrix )) {
					bu_free((char *)matrix, "red: matrix");
					matrix = (matp_t)NULL;
				}

				ptr = strtok((char *)NULL, delims);
				if (ptr == (char *)NULL)
					done = 1;
			}

			/* Add it to the combination */
			switch (relation) {
			case '+':
				rt_tree_array[tree_index].tl_op = OP_INTERSECT;
				break;
			case '-':
				rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
				break;
			default:
				bu_log("unrecognized relation (assume UNION)\n");
			case 'u':
				rt_tree_array[tree_index].tl_op = OP_UNION;
				break;
			}

			BU_GETUNION(tp, tree);
			rt_tree_array[tree_index].tl_tree = tp;
			tp->tr_l.magic = RT_TREE_MAGIC;
			tp->tr_l.tl_op = OP_DB_LEAF;
			tp->tr_l.tl_name = bu_strdup( name );
			tp->tr_l.tl_mat = matrix;
			tree_index++;
		}
	}

	bu_list_free(&HeadLines.l);
	result = make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index);
	if (result == 0)
		return TCL_OK;
	else
		return TCL_ERROR;
}

int
cmd_get_comb(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal *comb;
	struct rt_tree_array	*rt_tree_array;
	int i;
	int node_count;
	int actual_count;
	struct bu_vls vls;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	bu_vls_init(&vls);

	if (argc != 2) {
		bu_vls_printf(&vls, "helpdevel get_comb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dp = db_lookup(dbip , argv[1] , LOOKUP_QUIET);

	if (dp != DIR_NULL) {
		if (!(dp->d_flags & DIR_COMB)) {
			Tcl_AppendResult(interp, argv[1],
					 " is not a combination, so cannot be edited this way\n", (char *)NULL);
			return TCL_ERROR;
		}

		if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
			TCL_READ_ERR_return;

		comb = (struct rt_comb_internal *)intern.idb_ptr;

		if (comb->tree && db_ck_v4gift_tree(comb->tree) < 0) {
			db_non_union_push(comb->tree, &rt_uniresource);
			if (db_ck_v4gift_tree(comb->tree) < 0) {
				Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL);
				return TCL_ERROR;
			}
		}

		node_count = db_tree_nleaves(comb->tree);
		if (node_count > 0) {
			rt_tree_array = (struct rt_tree_array *)bu_calloc(node_count,
									  sizeof(struct rt_tree_array),
									  "tree list");
			actual_count = (struct rt_tree_array *)db_flatten_tree(rt_tree_array,
									       comb->tree,
									       OP_UNION,
									       1,
									       &rt_uniresource) - rt_tree_array;
			BU_ASSERT_LONG(actual_count, ==, node_count);
			comb->tree = TREE_NULL;
		} else {
			rt_tree_array = (struct rt_tree_array *)NULL;
			actual_count = 0;
		}

		Tcl_AppendElement(interp, dp->d_namep);                 /* NAME=name */
		if (comb->region_flag) {
			Tcl_AppendElement(interp, "Yes");              /* REGION=Yes */
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d", comb->region_id );
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* REGION_ID=comb->region_id */
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d", comb->aircode);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* AIRCODE=comb->aircode */
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d", comb->GIFTmater);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* GIFT_MATERIAL=comb->GIFTmater */
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d", comb->los );
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* LOS=comb->los */
		} else {
			Tcl_AppendElement(interp, "No");   /* REGION=No */
		}

		if (comb->rgb_valid) {
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d %d %d", V3ARGS(comb->rgb));
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* COLOR=comb->rgb */
		} else
			Tcl_AppendElement(interp, "");                 /* COLOR="" */

		Tcl_AppendElement(interp, bu_vls_addr(&comb->shader)); /* SHADER=comb->shader */

		if (comb->inherit)
			Tcl_AppendElement(interp, "Yes");  /* INHERIT=Yes */
		else
			Tcl_AppendElement(interp, "No");   /* INHERIT=No  */


		bu_vls_trunc(&vls, 0);
		for (i = 0 ; i < actual_count ; i++) {
			char op;

			switch (rt_tree_array[i].tl_op) {
			case OP_UNION:
				op = 'u';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			default:
				Tcl_AppendResult(interp, "Illegal op code in tree\n",
						 (char *)NULL);
				bu_vls_free(&vls);

				return TCL_ERROR;
			}

			bu_vls_printf(&vls, " %c %s\t" , op , rt_tree_array[i].tl_tree->tr_l.tl_name);
			vls_print_matrix(&vls, rt_tree_array[i].tl_tree->tr_l.tl_mat);
			bu_vls_printf(&vls, "\n");
			db_free_tree(rt_tree_array[i].tl_tree, &rt_uniresource);
		}

		Tcl_AppendElement(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_OK;
	} else {
		Tcl_AppendElement(interp, argv[1]); /* NAME=argv[1] */
		Tcl_AppendElement(interp, "Yes");    /* REGION=Yes */
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "%d", item_default);
		Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* REGION_ID=item_default */
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "%d", air_default);
		Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* AIRCODE=air_default */
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "%d", mat_default);
		Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* GIFT_MATERIAL=mat_default */
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "%d", los_default);
		Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* LOS=los_default */
		Tcl_AppendElement(interp, "");      /* COLOR=""         */
		Tcl_AppendElement(interp, "");      /* SHADER=""        */
		Tcl_AppendElement(interp, "No");    /* INHERIT=No       */
		Tcl_AppendElement(interp, "");      /* COMBINATION:""   */
		bu_vls_free(&vls);

		return TCL_RETURN;
	}
}

/*
 *  Usage:  put_comb comb_name is_Region id air material los color
 *			shader inherit boolean_expr
 */
int
cmd_put_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct directory *dp;
  struct rt_db_internal	intern;
  struct rt_comb_internal *comb;
  char new_name_v4[NAMESIZE+1];
  char *new_name;
  int offset;
  int save_comb_flag = 0;

  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  if(argc < 7 || 11 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel put_comb");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  strcpy(red_tmpfil, red_tmpfil_init);
  strcpy(red_tmpcomb, red_tmpcomb_init);
  dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );
  if(dp != DIR_NULL){
    if( !(dp->d_flags & DIR_COMB) ){
      Tcl_AppendResult(interp, argv[1],
		       " is not a combination, so cannot be edited this way\n", (char *)NULL);
      return TCL_ERROR;
    }
    
    if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
      TCL_READ_ERR_return;

    comb = (struct rt_comb_internal *)intern.idb_ptr;
    save_comb(dp); /* Save combination to a temp name */
    save_comb_flag = 1;
  }else{
    comb = (struct rt_comb_internal *)NULL;
  }

  /* empty the existing combination */
  if( comb && comb->tree ){
    db_free_tree( comb->tree, &rt_uniresource );
    comb->tree = NULL;
  }else{
    /* make an empty combination structure */
    BU_GETSTRUCT( comb, rt_comb_internal );
    comb->magic = RT_COMB_MAGIC;
    comb->tree = TREE_NULL;
    bu_vls_init( &comb->shader );
    bu_vls_init( &comb->material );
  }

  if( dbip->dbi_version < 5 )
  {
	  new_name = new_name_v4;
	  if(dp == DIR_NULL)
		  NAMEMOVE(argv[1], new_name_v4);
	  else
		  NAMEMOVE(dp->d_namep, new_name_v4);
  } else {
	  if( dp == DIR_NULL )
		  new_name = argv[1];
	  else
		  new_name = dp->d_namep;
  }

  if(*argv[2] == 'y' || *argv[2] == 'Y')
    comb->region_flag = 1;
  else
    comb->region_flag = 0;

  if(comb->region_flag){
    if(argc != 11){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help put_comb");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    comb->region_id = atoi(argv[3]);
    comb->aircode = atoi(argv[4]);
    comb->GIFTmater = atoi(argv[5]);
    comb->los = atoi(argv[6]);

    /* use the new values for defaults */
    item_default = comb->region_id + 1;
    air_default = comb->aircode;
    mat_default = comb->GIFTmater;
    los_default = comb->los;
    offset = 6;
  }else{
    if(argc != 7){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help put_comb");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
    offset = 2;
  }

  put_rgb_into_comb(comb, argv[offset + 1]);
  bu_vls_strcpy(&comb->shader, argv[offset +2]);

  if(*argv[offset + 3] == 'y' || *argv[offset + 3] == 'Y')
    comb->inherit = 1;
  else
    comb->inherit = 0;

  if(put_tree_into_comb(comb, dp, argv[1], new_name, argv[offset + 4]) == TCL_ERROR){
    if(comb){
      restore_comb(dp);
      Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL);
    }
    (void)unlink(red_tmpfil);
    return TCL_ERROR;
  }else if(save_comb_flag){
    /* eliminate the temporary combination */
    char *av[3];

    av[0] = "kill";
    av[1] = red_tmpcomb;
    av[2] = NULL;
    (void)cmd_kill(clientData, interp, 2, av);
  }

  (void)unlink(red_tmpfil);
  return TCL_OK;
}

int
writecomb( const struct rt_comb_internal *comb, const char *name )
{
/*	Writes the file for later editing */
	struct rt_tree_array	*rt_tree_array;
	FILE			*fp;
	int			i;
	int			node_count;
	int			actual_count;

	if( comb )
		RT_CK_COMB( comb );

	/* open the file */
	if( (fp=fopen( red_tmpfil , "w" )) == NULL )
	{
	  Tcl_AppendResult(interp, "Cannot open create file for editing\n", (char *)NULL);
	  perror( "MGED" );
	  return(1);
	}

	if( !comb )
	{
		fprintf( fp, "NAME=%s\n", name );
		fprintf( fp, "REGION=No\n" );
		fprintf( fp, "REGION_ID=\n" );
		fprintf( fp, "AIRCODE=\n" );
		fprintf( fp, "GIFT_MATERIAL=\n" );
		fprintf( fp, "LOS=\n" );
		fprintf( fp, "COLOR=\n" );
		fprintf( fp, "SHADER=\n" );
		fprintf( fp, "INHERIT=No\n" );
		fprintf( fp, "COMBINATION:\n" );
		fclose( fp );
		return( 0 );
	}

	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
	{
		db_non_union_push( comb->tree, &rt_uniresource );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL );
			return( 1 );
		}
	}
	node_count = db_tree_nleaves( comb->tree );
	if( node_count > 0 )
	{
		rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count,
			sizeof( struct rt_tree_array ), "tree list" );
		actual_count = (struct rt_tree_array *)db_flatten_tree(
			rt_tree_array, comb->tree, OP_UNION,
			0, &rt_uniresource ) - rt_tree_array;
		BU_ASSERT_LONG( actual_count, ==, node_count );
	}
	else
	{
		rt_tree_array = (struct rt_tree_array *)NULL;
		actual_count = 0;
	}

	fprintf( fp, "NAME=%s\n", name );
	if( comb->region_flag )
	{
		fprintf( fp, "REGION=Yes\n" );
		fprintf( fp, "REGION_ID=%d\n", comb->region_id );
		fprintf( fp, "AIRCODE=%d\n", comb->aircode );
		fprintf( fp, "GIFT_MATERIAL=%d\n", comb->GIFTmater );
		fprintf( fp, "LOS=%d\n", comb->los );
	}
	else
	{
		fprintf( fp, "REGION=No\n" );
		fprintf( fp, "REGION_ID=\n" );
		fprintf( fp, "AIRCODE=\n" );
		fprintf( fp, "GIFT_MATERIAL=\n" );
		fprintf( fp, "LOS=\n" );
	}

	if( comb->rgb_valid )
		fprintf( fp, "COLOR= %d %d %d\n", V3ARGS( comb->rgb ) );
	else
		fprintf( fp, "COLOR=\n" );

	fprintf( fp, "SHADER=%s\n", bu_vls_addr( &comb->shader ) );
#if 0
	fprintf( fp, "MATERIAL=%s\n", bu_vls_addr( &comb->material ) );
#endif
	if( comb->inherit )
		fprintf( fp, "INHERIT=Yes\n" );
	else
		fprintf( fp, "INHERIT=No\n" );

	fprintf( fp, "COMBINATION:\n" );

	for( i=0 ; i<actual_count ; i++ )
	{
		char op;

		switch( rt_tree_array[i].tl_op )
		{
			case OP_UNION:
				op = 'u';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			default:
				Tcl_AppendResult(interp, "Illegal op code in tree\n",
					(char *)NULL );
				fclose( fp );
				return( 1 );
		}
		if( fprintf( fp , " %c %s" , op , rt_tree_array[i].tl_tree->tr_l.tl_name ) <= 0 )
		{
			Tcl_AppendResult(interp, "Cannot write to temp file (", red_tmpfil,
				"). Aborting edit\n", (char *)NULL );
			fclose( fp );
			return( 1 );
		}
		print_matrix( fp, rt_tree_array[i].tl_tree->tr_l.tl_mat );
		fprintf( fp, "\n" );
	}
	fclose( fp );
	return( 0 );
}

int
checkcomb(void)
{
/*	Do some minor checking of the edited file */

	FILE *fp;
	int node_count=0;
	int nonsubs=0;
	int i,j,done,ch;
	int done2,first;
	char relation;
	char name_v4[NAMESIZE+1];
	char *name_v5=NULL;
	char *name=NULL;
	char line[MAXLINE];
	char *ptr;
	int region=(-1);
	int id=0,air=0;
	int rgb_valid;

	if( (fp=fopen( red_tmpfil , "r" )) == NULL )
	{
	  Tcl_AppendResult(interp, "Cannot open create file for editing\n", (char *)NULL);
	  perror( "MGED" );
	  return(-1);
	}

	/* Read a line at a time */
	done = 0;
	while( !done )
	{
		/* Read a line */
		i = (-1);

		while( (ch=getc( fp )) != EOF && ch != '\n' && i<MAXLINE )
			line[++i] = ch;

		if( ch == EOF )	/* We must be done */
		{
			done = 1;
			if( i < 0 )
				break;
		}
		if( i == MAXLINE )
		{
		  Tcl_AppendResult(interp, "Line too long in edited file\n", (char *)NULL);
		  return( 1 );
		}

		line[++i] = '\0';

		/* skip leading white space */
		i = (-1);
		while( isspace( line[++i] ));

		if( line[i] == '\0' )
			continue;	/* blank line */

		if( (ptr=find_keyword(i, line, "NAME" ) ) )
		{
			if( dbip->dbi_version < 5 ) {
				int len;

				len = strlen( ptr );
				if( len >= NAMESIZE ) {
					while( len > 1 && isspace( ptr[len-1] ) )
						len--;
				}
				if( len >= NAMESIZE ) {
					Tcl_AppendResult(interp, "Name too long for v4 database: ", ptr, "\n", (char *)NULL );
				}
			}
			continue;
		}
		else if( (ptr=find_keyword( i, line, "REGION" ) ) )
		{
			if( *ptr == 'y' || *ptr == 'Y' )
				region = 1;
			else
				region = 0;
			continue;
		}
		else if( (ptr=find_keyword( i, line, "REGION_ID" ) ) )
		{
			id = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "AIRCODE" ) ) )
		{
			air = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "GIFT_MATERIAL" ) ) )
		{
			continue;
		}
		else if( (ptr=find_keyword( i, line, "LOS" ) ) )
		{
			continue;
		}
		else if( (ptr=find_keyword( i, line, "COLOR" ) ) )
		{
			char *ptr2;

			rgb_valid = 1;
			ptr2 = strtok( ptr, delims );
			if( !ptr2 )
			{
				rgb_valid = 0;
				continue;
			}
			ptr2 = strtok( (char *)NULL, delims );
			if( !ptr2 )
			{
				rgb_valid = 0;
				continue;
			}
			ptr2 = strtok( (char *)NULL, delims );
			if( !ptr2 )
			{
				rgb_valid = 0;
				continue;
			}
			if( !rgb_valid )
				Tcl_AppendResult(interp, "Invalid color specification!!! Must be three integers, each 0-255\n", (char *)NULL );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "SHADER" ) ) )
			continue;
#if 0
		else if( (ptr=find_keyword( i, line, "MATERIAL" ) ) )
			continue;
#endif
		else if( (ptr=find_keyword( i, line, "INHERIT" ) ) )
			continue;
		else if( !strncmp( &line[i], "COMBINATION:", 12 ) )
		{
			if( region < 0 )
			{
				Tcl_AppendResult(interp, "Region flag not correctly set\n",
					"\tMust be 'Yes' or 'No'\n", "\tNo Changes made\n",
					(char *)NULL );
				fclose( fp );
				return( 1 );
			}
			else if( region )
			{
				if( id < 0 )
				{
					Tcl_AppendResult(interp, "invalid region ID\n",
						"\tNo Changes made\n",
						(char *)NULL );
					fclose( fp );
					return( 1 );
				}
				if( air < 0 )
				{
					Tcl_AppendResult(interp, "invalid Air code\n",
						"\tNo Changes made\n",
						(char *)NULL );
					fclose( fp );
					return( 1 );
				}
				if( air == 0 && id == 0 )
					Tcl_AppendResult(interp, "Warning: both ID and Air codes are 0!!!\n", (char *)NULL );
				if( air && id )
					Tcl_AppendResult(interp, "Warning: both ID and Air codes are non-zero!!!\n", (char *)NULL );
			}
			continue;
		}

		done2=0;
		first=1;
		ptr = strtok( line , delims );

		while (!done2) {
			if( name_v5 ) {
				bu_free( name_v5, "name_v5" );
				name_v5 = NULL;
			}
			/* First non-white is the relation operator */
			if( !ptr )
			{
				done2 = 1;
				break;
			}
			
			relation = (*ptr);
			if( relation == '\0' )
			{
				if (first)
					done = 1;

				done2 = 1;
				break;
			}
			first = 0;

			/* Next must be the member name */
			ptr = strtok( (char *)NULL, delims );
			name = NULL;
			if( dbip->dbi_version < 5 ) {
				strncpy( name_v4 , ptr , NAMESIZE );
				name_v4[NAMESIZE] = '\0';

				/* Eliminate trailing white space from name */
				j = NAMESIZE;
				while( isspace( name_v4[--j] ) )
					name_v4[j] = '\0';
				name = name_v4;
			} else {
				int len;

				len = strlen( ptr );
				name_v5 = (char *)bu_malloc( len + 1, "name_v5" );
				strcpy( name_v5, ptr );
				while( isspace( name_v5[len-1] ) ) {
					len--;
					name_v5[len] = '\0';
				}
				name = name_v5;
			}

			if( relation != '+' && relation != 'u' && relation != '-' )
			{
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, " %c is not a legal operator\n" , relation );
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			  fclose( fp );
			  if( dbip->dbi_version >= 5 )
				  bu_free( name_v5, "name_v5" );
			  return( -1 );
			}
			if( relation != '-' )
				nonsubs++;

			if( name == NULL || name[0] == '\0' )
			{
				Tcl_AppendResult(interp, " operand name missing\n", (char *)NULL);
				fclose( fp );
				if( dbip->dbi_version >= 5 )
					bu_free( name_v5, "name_v5" );
				return( -1 );
			}

			ptr = strtok( (char *)NULL, delims );
			if( !ptr )
				done2 = 1;
			else if(*ptr != 'u' &&
				(*ptr != '-' || *(ptr+1) != '\0') &&
				(*ptr != '+' || *(ptr+1) != '\0')) {
				int k;

				/* skip past matrix */
				for( k=1 ; k<16 ; k++ )
				{
					ptr = strtok( (char *)NULL, delims );
					if( !ptr)
					{
						Tcl_AppendResult(interp, "expecting a matrix\n", (char *)NULL);
						fclose( fp );
						if( dbip->dbi_version >= 5 )
							bu_free( name_v5, "name_v5" );
						return( -1 );
					}
				}

				/* get the next relational operator on the current line */
				ptr = strtok( (char *)NULL, delims );
			}

			node_count++;
		}
	}

	if( dbip->dbi_version >= 5 && name_v5 )
		bu_free( name_v5, "name_v5" );

	fclose( fp );

	if( nonsubs == 0 && node_count )
	{
	  Tcl_AppendResult(interp, "Cannot create a combination with all subtraction operators\n",
			   (char *)NULL);
	  return( -1 );
	}
	return( node_count );
}

static int
make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index)
{
	struct rt_db_internal	intern;
	union tree		*final_tree;

	if (tree_index)
		final_tree = (union tree *)db_mkgift_tree( rt_tree_array, node_count, &rt_uniresource );
	else
		final_tree = (union tree *)NULL;

	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern.idb_type = ID_COMBINATION;
	intern.idb_meth = &rt_functab[ID_COMBINATION];
	intern.idb_ptr = (genptr_t)comb;
	comb->tree = final_tree;

	if (strcmp(new_name, old_name)) {
		int flags;

		if (comb->region_flag)
			flags = DIR_COMB | DIR_REGION;
		else
			flags = DIR_COMB;

		if (dp != DIR_NULL) {
			if (db_delete(dbip, dp) || db_dirdelete(dbip, dp)) {
				Tcl_AppendResult(interp, "ERROR: Unable to delete directory entry for ",
						 old_name, "\n", (char *)NULL);
				rt_comb_ifree(&intern, &rt_uniresource);
				return(1);
			}
		}

		if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
			Tcl_AppendResult(interp, "Cannot add ", new_name,
					 " to directory, no changes made\n", (char *)NULL);
			rt_comb_ifree(&intern, &rt_uniresource);
			return(1);
		}
	} else if( dp == DIR_NULL ) {
		int flags;

		if (comb->region_flag)
			flags = DIR_COMB | DIR_REGION;
		else
			flags = DIR_COMB;

		if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
			Tcl_AppendResult(interp, "Cannot add ", new_name,
					 " to directory, no changes made\n", (char *)NULL);
			rt_comb_ifree( &intern, &rt_uniresource );
			return(1);
		}
	} else {
		if (comb->region_flag)
			dp->d_flags |= DIR_REGION;
		else
			dp->d_flags &= ~DIR_REGION;
	}

	if (rt_db_put_internal(dp, dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
		return 1;
	}

	return(0);
}


int build_comb(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name)
{
/*	Build the new combination by adding to the recently emptied combination
	This keeps combo info associated with this combo intact */

	FILE *fp;
	char relation;
	char *name=NULL, *new_name;
	char name_v4[NAMESIZE+1];
	char new_name_v4[NAMESIZE+1];
	char line[MAXLINE];
	char *ptr;
	int ch;
	int i;
	int done=0;
	int done2;
	struct rt_tree_array *rt_tree_array;
	int tree_index=0;
	union tree *tp;
	matp_t matrix;
	int ret=0;

	if(dbip == DBI_NULL)
	  return 0;

	if( comb )
	{
		RT_CK_COMB( comb );
		RT_CK_DIR( dp );
	}

	if( (fp=fopen( red_tmpfil , "r" )) == NULL )
	{
	  Tcl_AppendResult(interp, " Cannot open edited file: ",
			   red_tmpfil, "\n", (char *)NULL);
	  return( 1 );
	}

	/* empty the existing combination */
	if( comb && comb->tree )
	{
		db_free_tree( comb->tree, &rt_uniresource );
		comb->tree = NULL;
	}
	else
	{
		/* make an empty combination structure */
		BU_GETSTRUCT( comb, rt_comb_internal );
		comb->magic = RT_COMB_MAGIC;
		comb->tree = TREE_NULL;
		bu_vls_init( &comb->shader );
		bu_vls_init( &comb->material );
	}

	/* build tree list */
	if( node_count )
		rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count , sizeof( struct rt_tree_array ) , "tree list" );
	else
		rt_tree_array = (struct rt_tree_array *)NULL;

	if( dbip->dbi_version < 5 ) {
		if( dp == DIR_NULL )
			NAMEMOVE( old_name, new_name_v4 );
		else
			NAMEMOVE( dp->d_namep, new_name_v4 );
		new_name = new_name_v4;
	} else {
		if( dp == DIR_NULL )
			new_name = bu_strdup( old_name );
		else
			new_name = bu_strdup( dp->d_namep );
	}

	/* Read edited file */
	while( !done )
	{
		/* Read a line */
		i = (-1);

		while( (ch=getc( fp )) != EOF && ch != '\n' && i<MAXLINE )
			line[++i] = ch;

		if( ch == EOF )	/* We must be done */
		{
			done = 1;
			if( i < 0 )
				break;
		}

		line[++i] = '\0';

		/* skip leading white space */
		i = (-1);
		while( isspace( line[++i] ));

		if( line[i] == '\0' )
			continue;	/* blank line */

		if( (ptr=find_keyword(i, line, "NAME" ) ) )
		{
			if( dbip->dbi_version < 5 )
				NAMEMOVE( ptr, new_name_v4 );
			else {
				bu_free( new_name, "new_name" );
				new_name = bu_strdup( ptr );
			}
			continue;
		}
		else if( (ptr=find_keyword( i, line, "REGION_ID" ) ) )
		{
			comb->region_id = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "REGION" ) ) )
		{
			if( *ptr == 'y' || *ptr == 'Y' )
				comb->region_flag = 1;
			else
				comb->region_flag = 0;
			continue;
		}
		else if( (ptr=find_keyword( i, line, "AIRCODE" ) ) )
		{
			comb->aircode = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "GIFT_MATERIAL" ) ) )
		{
			comb->GIFTmater = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "LOS" ) ) )
		{
			comb->los = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "COLOR" ) ) )
		{
			char *ptr2;
			int value;

			ptr2 = strtok( ptr, delims );
			if( !ptr2 )
			{
				comb->rgb_valid = 0;
				continue;
			}
			value = atoi( ptr2 );
			if( value < 0 )
			{
				Tcl_AppendResult(interp, "Red value less than 0, assuming 0\n", (char *)NULL );
				value = 0;
			}
			if( value > 255 )
			{
				Tcl_AppendResult(interp, "Red value greater than 255, assuming 255\n", (char *)NULL );
				value = 255;
			}
			comb->rgb[0] = value;
			ptr2 = strtok( (char *)NULL, delims );
			if( !ptr2 )
			{
				Tcl_AppendResult(interp, "Invalid RGB value\n", (char *)NULL );
				comb->rgb_valid = 0;
				continue;
			}
			value = atoi( ptr2 );
			if( value < 0 )
			{
				Tcl_AppendResult(interp, "Green value less than 0, assuming 0\n", (char *)NULL );
				value = 0;
			}
			if( value > 255 )
			{
				Tcl_AppendResult(interp, "Green value greater than 255, assuming 255\n", (char *)NULL );
				value = 255;
			}
			comb->rgb[1] = value;
			ptr2 = strtok( (char *)NULL, delims );
			if( !ptr2 )
			{
				Tcl_AppendResult(interp, "Invalid RGB value\n", (char *)NULL );
				comb->rgb_valid = 0;
				continue;
			}
			value = atoi( ptr2 );
			if( value < 0 )
			{
				Tcl_AppendResult(interp, "Blue value less than 0, assuming 0\n", (char *)NULL );
				value = 0;
			}
			if( value > 255 )
			{
				Tcl_AppendResult(interp, "Blue value greater than 255, assuming 255\n", (char *)NULL );
				value = 255;
			}
			comb->rgb[2] = value;
			comb->rgb_valid = 1;
			continue;
		}
		else if( (ptr=find_keyword( i, line, "SHADER" ) ) )
		{
			bu_vls_strcpy( &comb->shader,  ptr );
			continue;
		}
#if 0
		else if( (ptr=find_keyword( i, line, "MATERIAL" ) ) )
		{
			bu_vls_strcpy( &comb->material,  ptr );
			continue;
		}
#endif
		else if( (ptr=find_keyword( i, line, "INHERIT" ) ) )
		{
			if( *ptr == 'y' || *ptr == 'Y' )
				comb->inherit = 1;
			else
				comb->inherit = 0;
			continue;
		}
		else if( !strncmp( &line[i], "COMBINATION:", 12 ) )
			continue;

		done2=0;
		ptr = strtok( line, delims );
		while (!done2) {
			if ( !ptr )
			  break;

			/* First non-white is the relation operator */
			relation = (*ptr);
			if( relation == '\0' )
				break;

			/* Next must be the member name */
			ptr = strtok( (char *)NULL, delims );
			if( dbip->dbi_version < 5 ) {
				strncpy( name_v4 , ptr, NAMESIZE );
				name_v4[NAMESIZE] = '\0';
				name = name_v4;
			} else {
				if( name )
					bu_free( name, "name" );
				name = bu_strdup( ptr );
			}
	
			/* Eliminate trailing white space from name */
			if( dbip->dbi_version < 5 )
				i = NAMESIZE;
			else
				i = strlen( name );
			while( isspace( name[--i] ) )
				name[i] = '\0';

			/* Check for existence of member */
			if( (db_lookup( dbip , name , LOOKUP_QUIET )) == DIR_NULL )
			  Tcl_AppendResult(interp, "\tWARNING: '", name, "' does not exist\n", (char *)NULL);
			/* get matrix */
			ptr = strtok( (char *)NULL, delims );
			if( !ptr ){
				matrix = (matp_t)NULL;
				done2 = 1;
			}else if(*ptr == 'u' ||
				(*ptr == '-' && *(ptr+1) == '\0') ||
				(*ptr == '+' && *(ptr+1) == '\0')) {
				/* assume another relational operator */
				matrix = (matp_t)NULL;
			}else
			{
				int k;

				matrix = (matp_t)bu_calloc( 16, sizeof( fastf_t ), "red: matrix" );
				matrix[0] = atof( ptr );
				for( k=1 ; k<16 ; k++ )
				{
					ptr = strtok( (char *)NULL, delims );
					if( !ptr )
					{
						Tcl_AppendResult(interp, "incomplete matrix for member ",
							name, " No changes made\n", (char *)NULL );
						bu_free( (char *)matrix, "red: matrix" );
						if( rt_tree_array )
							bu_free( (char *)rt_tree_array, "red: tree list" );
						fclose( fp );
						return( 1 );
					}
					matrix[k] = atof( ptr );
				}
				if( bn_mat_is_identity( matrix ) )
				{
					bu_free( (char *)matrix, "red: matrix" );
					matrix = (matp_t)NULL;
				}

				ptr = strtok( (char *)NULL, delims );
				if (ptr == (char *)NULL)
					done2 = 1;
			}

			/* Add it to the combination */
			switch( relation )
			{
				case '+':
					rt_tree_array[tree_index].tl_op = OP_INTERSECT;
					break;
				case '-':
					rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
					break;
				default:
					Tcl_AppendResult(interp, "unrecognized relation (assume UNION)\n",
						(char *)NULL );
				case 'u':
					rt_tree_array[tree_index].tl_op = OP_UNION;
					break;
			}
			BU_GETUNION( tp, tree );
			rt_tree_array[tree_index].tl_tree = tp;
			tp->tr_l.magic = RT_TREE_MAGIC;
			tp->tr_l.tl_op = OP_DB_LEAF;
			tp->tr_l.tl_name = bu_strdup( name );
			tp->tr_l.tl_mat = matrix;
			tree_index++;
		}
	}

	fclose( fp );

	ret = make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index);

	if( dbip->dbi_version >= 5 ) {
		if( name )
			bu_free( name, "name " );
		bu_free( new_name, "new_name" );
	}

	return( ret );
}

void
mktemp_comb(char *str)
{
/* Make a temporary name for a combination
	a template name is expected as in "mk_temp()" with 
	5 trailing X's */

	int counter,done;
	char *ptr;


	if(dbip == DBI_NULL)
	  return;

	/* Set "ptr" to start of X's */

	ptr = str;
	while( *ptr != '\0' )
		ptr++;

	while( *(--ptr) == 'X' );
	ptr++;


	counter = 1;
	done = 0;
	while( !done && counter < 99999 )
	{
		sprintf( ptr , "%d" , counter );
		if( db_lookup( dbip , str , LOOKUP_QUIET ) == DIR_NULL )
			done = 1;
		else
			counter++;
	}
}

int save_comb(struct directory *dpold)
{
/* Save a combination under a temporory name */

	register struct directory	*dp;
	struct rt_db_internal		intern;

	if(dbip == DBI_NULL)
	  return 0;

	/* Make a new name */
	mktemp_comb( red_tmpcomb );

	if( rt_db_get_internal( &intern, dpold, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		TCL_READ_ERR_return;

	if( (dp=db_diradd( dbip, red_tmpcomb, -1L, 0, dpold->d_flags, (genptr_t)&intern.idb_type)) == DIR_NULL )  {
	  Tcl_AppendResult(interp, "Cannot save copy of ", dpold->d_namep,
			   ", no changes made\n", (char *)NULL);
	  return( 1 );
	}

	if( rt_db_put_internal(	dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "Cannot save copy of ", dpold->d_namep,
			", no changes made\n", (char *)NULL);
		return( 1 );
	}
	
	return( 0 );
}

/* restore a combination that was saved in "red_tmpcomb" */
void
restore_comb(struct directory *dp)
{
  char *av[4];
  char *name;

  /* Save name of original combo */
  name = bu_strdup( dp->d_namep );

  av[0] = "kill";
  av[1] = name;
  av[2] = NULL;
  av[3] = NULL;
  (void)cmd_kill((ClientData)NULL, interp, 2, av);

  av[0] = "mv";
  av[1] = red_tmpcomb;
  av[2] = name;

  (void)cmd_name((ClientData)NULL, interp, 3, av);

  bu_free( name, "bu_strdup'd name" );
}
@


11.71
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/red.c,v 11.70 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.70
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.69
log
@merge of windows-6-0-branch into head
@
text
@d43 1
a43 1
extern int cmd_name();
d55 5
a59 5
void put_rgb_into_comb();
void restore_comb();
int editit();
static int make_tree();
int clear_comb(),build_comb(),save_comb();
d62 1
a62 5
f_red(clientData, interp, argc , argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d196 1
a196 4
find_keyword( i, line, word )
int i;
char *line;
char *word;
d225 1
a225 3
print_matrix( fp, matrix )
FILE *fp;
matp_t matrix;
d249 1
a249 3
vls_print_matrix(vls, matrix)
struct bu_vls *vls;
matp_t matrix;
d272 1
a272 3
put_rgb_into_comb(comb, str)
struct rt_comb_internal *comb;
char *str;
d311 1
a311 2
count_nodes(line)
char *line;
d375 1
a375 6
put_tree_into_comb(comb, dp, old_name, new_name, str)
     struct rt_comb_internal	*comb;
     struct directory		*dp;
     char			*old_name;
     char			*new_name;
     char			*str;
d703 1
a703 5
cmd_put_comb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1266 1
a1266 8
make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index)
     struct rt_comb_internal	*comb;
     struct directory		*dp;
     int			node_count;
     char			*old_name;
     char			*new_name;
     struct rt_tree_array	*rt_tree_array;
     int			tree_index;
d1336 1
a1336 5
int build_comb( comb, dp, node_count, old_name )
struct rt_comb_internal *comb;
struct directory *dp;
int node_count;
char *old_name;
d1675 1
a1675 2
mktemp_comb( str )
char *str;
d1710 1
a1710 2
int save_comb( dpold )
struct directory *dpold;
d1744 1
a1744 2
restore_comb( dp )
struct directory *dp;
@


11.68
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.67 2002/08/20 17:08:25 jra Exp $ (BRL)";
d46 1
d48 3
d109 1
a109 1
#if 0
d131 1
a131 1
#if 0
@


11.67
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1992 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.65 2001/10/15 21:44:08 bparker Exp $ (BRL)";
@


11.67.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.68 2004/02/02 17:39:34 morrison Exp $ (BRL)";
@


11.67.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.67.10.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.67.10.3
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a45 1
#ifndef WIN32
a46 3
#else
static char	*red_tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d105 1
a105 1
#ifdef WIN32
d127 1
a127 1
#ifdef WIN32
@


11.67.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.67 2002/08/20 17:08:25 jra Exp $ (BRL)";
a45 1
#ifndef WIN32
a46 3
#else
static char	*red_tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d105 1
a105 1
#ifdef WIN32
d127 1
a127 1
#ifdef WIN32
@


11.67.4.2
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/red.c,v 11.67.4.1 2002/09/26 23:04:13 morrison Exp $ (BRL)";
@


11.67.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.67 2002/08/20 17:08:25 jra Exp $ (BRL)";
d43 1
a43 1
extern int cmd_name(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d51 5
a55 5
void put_rgb_into_comb(struct rt_comb_internal *comb, char *str);
void restore_comb(struct directory *dp);
int editit(const char *file);
static int make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index);
int clear_comb(),build_comb(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name),save_comb(struct directory *dpold);
d58 5
a62 1
f_red(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d196 4
a199 1
find_keyword(int i, char *line, char *word)
d228 3
a230 1
print_matrix(FILE *fp, matp_t matrix)
d254 3
a256 1
vls_print_matrix(struct bu_vls *vls, matp_t matrix)
d279 3
a281 1
put_rgb_into_comb(struct rt_comb_internal *comb, char *str)
d320 2
a321 1
count_nodes(char *line)
d385 6
a390 1
put_tree_into_comb(struct rt_comb_internal *comb, struct directory *dp, char *old_name, char *new_name, char *str)
d718 5
a722 1
cmd_put_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1285 8
a1292 1
make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index)
d1362 5
a1366 1
int build_comb(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name)
d1705 2
a1706 1
mktemp_comb(char *str)
d1741 2
a1742 1
int save_comb(struct directory *dpold)
d1776 2
a1777 1
restore_comb(struct directory *dp)
@


11.67.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a45 1
#ifndef WIN32
a46 3
#else
static char	*red_tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d101 1
a101 1
#ifdef WIN32
d123 1
a123 1
#ifdef WIN32
@


11.66
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 1
a43 1
extern int cmd_name(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d51 5
a55 5
void put_rgb_into_comb(struct rt_comb_internal *comb, char *str);
void restore_comb(struct directory *dp);
int editit(const char *file);
static int make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index);
int clear_comb(),build_comb(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name),save_comb(struct directory *dpold);
d58 5
a62 1
f_red(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d196 4
a199 1
find_keyword(int i, char *line, char *word)
d228 3
a230 1
print_matrix(FILE *fp, matp_t matrix)
d254 3
a256 1
vls_print_matrix(struct bu_vls *vls, matp_t matrix)
d279 3
a281 1
put_rgb_into_comb(struct rt_comb_internal *comb, char *str)
d320 2
a321 1
count_nodes(char *line)
d385 6
a390 1
put_tree_into_comb(struct rt_comb_internal *comb, struct directory *dp, char *old_name, char *new_name, char *str)
d718 5
a722 1
cmd_put_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d1285 8
a1292 1
make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index)
d1362 5
a1366 1
int build_comb(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name)
d1705 2
a1706 1
mktemp_comb(char *str)
d1741 2
a1742 1
int save_comb(struct directory *dpold)
d1776 2
a1777 1
restore_comb(struct directory *dp)
@


11.65
log
@*- mods to cmd_get_comb:
	formatting and added tab between object and matrix
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.64 2001/10/02 19:24:32 jra Exp $ (BRL)";
d43 1
a43 1
extern int cmd_name();
d51 5
a55 5
void put_rgb_into_comb();
void restore_comb();
int editit();
static int make_tree();
int clear_comb(),build_comb(),save_comb();
d58 1
a58 5
f_red(clientData, interp, argc , argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d192 1
a192 4
find_keyword( i, line, word )
int i;
char *line;
char *word;
d221 1
a221 3
print_matrix( fp, matrix )
FILE *fp;
matp_t matrix;
d245 1
a245 3
vls_print_matrix(vls, matrix)
struct bu_vls *vls;
matp_t matrix;
d268 1
a268 3
put_rgb_into_comb(comb, str)
struct rt_comb_internal *comb;
char *str;
d307 1
a307 2
count_nodes(line)
char *line;
d371 1
a371 6
put_tree_into_comb(comb, dp, old_name, new_name, str)
     struct rt_comb_internal	*comb;
     struct directory		*dp;
     char			*old_name;
     char			*new_name;
     char			*str;
d699 1
a699 5
cmd_put_comb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1262 1
a1262 8
make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index)
     struct rt_comb_internal	*comb;
     struct directory		*dp;
     int			node_count;
     char			*old_name;
     char			*new_name;
     struct rt_tree_array	*rt_tree_array;
     int			tree_index;
d1332 1
a1332 5
int build_comb( comb, dp, node_count, old_name )
struct rt_comb_internal *comb;
struct directory *dp;
int node_count;
char *old_name;
d1671 1
a1671 2
mktemp_comb( str )
char *str;
d1706 1
a1706 2
int save_comb( dpold )
struct directory *dpold;
d1740 1
a1740 2
restore_comb( dp )
struct directory *dp;
@


11.64
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.63 2001/08/22 17:26:46 jra Exp $ (BRL)";
d557 4
a560 5
cmd_get_comb(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d562 22
a583 20
  struct directory *dp;
  struct rt_db_internal	intern;
  struct rt_comb_internal *comb;
  struct rt_tree_array	*rt_tree_array;
  int i;
  int node_count;
  int actual_count;
  struct bu_vls vls;

  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  bu_vls_init(&vls);

  if(argc != 2){
    bu_vls_printf(&vls, "helpdevel get_comb");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d585 6
a590 1
  dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );
d592 2
a593 6
  if(dp != DIR_NULL){
    if( !(dp->d_flags & DIR_COMB) ){
      Tcl_AppendResult(interp, argv[1],
		       " is not a combination, so cannot be edited this way\n", (char *)NULL);
      return TCL_ERROR;
    }
d595 1
a595 2
    if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
      TCL_READ_ERR_return;
d597 7
a603 1
    comb = (struct rt_comb_internal *)intern.idb_ptr;
d605 16
a620 7
    if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 ){
      db_non_union_push( comb->tree, &rt_uniresource );
      if( db_ck_v4gift_tree( comb->tree ) < 0 ){
	Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL );
	return TCL_ERROR;
      }
    }
d622 18
a639 11
    node_count = db_tree_nleaves( comb->tree );
    if( node_count > 0 ){
      rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count, sizeof( struct rt_tree_array ), "tree list" );
      actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array,
		comb->tree, OP_UNION, 1, &rt_uniresource ) - rt_tree_array;
      BU_ASSERT_LONG( actual_count, ==, node_count );
      comb->tree = TREE_NULL;
    } else {
      rt_tree_array = (struct rt_tree_array *)NULL;
      actual_count = 0;
    }
d641 6
a646 18
    Tcl_AppendElement(interp, dp->d_namep);                 /* NAME=name */
    if( comb->region_flag ){
      Tcl_AppendElement(interp, "Yes");              /* REGION=Yes */
      bu_vls_trunc(&vls, 0);
      bu_vls_printf(&vls, "%d", comb->region_id );
      Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* REGION_ID=comb->region_id */
      bu_vls_trunc(&vls, 0);
      bu_vls_printf(&vls, "%d", comb->aircode);
      Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* AIRCODE=comb->aircode */
      bu_vls_trunc(&vls, 0);
      bu_vls_printf(&vls, "%d", comb->GIFTmater);
      Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* GIFT_MATERIAL=comb->GIFTmater */
      bu_vls_trunc(&vls, 0);
      bu_vls_printf(&vls, "%d", comb->los );
      Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* LOS=comb->los */
    }else{
      Tcl_AppendElement(interp, "No");   /* REGION=No */
    }
d648 1
a648 6
    if(comb->rgb_valid){
      bu_vls_trunc(&vls, 0);
      bu_vls_printf(&vls, "%d %d %d", V3ARGS(comb->rgb));
      Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* COLOR=comb->rgb */
    }else
      Tcl_AppendElement(interp, "");                 /* COLOR="" */
d650 4
a653 1
    Tcl_AppendElement(interp, bu_vls_addr(&comb->shader)); /* SHADER=comb->shader */
a654 4
    if( comb->inherit )
      Tcl_AppendElement(interp, "Yes");  /* INHERIT=Yes */
    else
      Tcl_AppendElement(interp, "No");   /* INHERIT=No  */
d656 3
d660 14
a673 18
    bu_vls_trunc(&vls, 0);
    for( i=0 ; i<actual_count ; i++ ){
      char op;

      switch( rt_tree_array[i].tl_op ){
      case OP_UNION:
	op = 'u';
	break;
      case OP_INTERSECT:
	op = '+';
	break;
      case OP_SUBTRACT:
	op = '-';
	break;
      default:
	Tcl_AppendResult(interp, "Illegal op code in tree\n",
			 (char *)NULL );
	bu_vls_free(&vls);
d675 2
a676 2
	return TCL_ERROR;
      }
d678 5
a682 5
      bu_vls_printf(&vls, " %c %s" , op , rt_tree_array[i].tl_tree->tr_l.tl_name);
      vls_print_matrix(&vls, rt_tree_array[i].tl_tree->tr_l.tl_mat);
      bu_vls_printf(&vls, "\n");
      db_free_tree( rt_tree_array[i].tl_tree, &rt_uniresource );
    }
d684 2
a685 2
    Tcl_AppendElement(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
d687 21
a707 21
    return TCL_OK;
  }else {
    Tcl_AppendElement(interp, argv[1]); /* NAME=argv[1] */
    Tcl_AppendElement(interp, "Yes");    /* REGION=Yes */
    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "%d", item_default);
    Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* REGION_ID=item_default */
    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "%d", air_default);
    Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* AIRCODE=air_default */
    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "%d", mat_default);
    Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* GIFT_MATERIAL=mat_default */
    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "%d", los_default);
    Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* LOS=los_default */
    Tcl_AppendElement(interp, "");      /* COLOR=""         */
    Tcl_AppendElement(interp, "");      /* SHADER=""        */
    Tcl_AppendElement(interp, "No");    /* INHERIT=No       */
    Tcl_AppendElement(interp, "");      /* COMBINATION:""   */
    bu_vls_free(&vls);
d709 2
a710 2
    return TCL_RETURN;
  }
@


11.63
log
@build_comb() was returning too early
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.62 2001/06/01 19:23:25 bparker Exp $ (BRL)";
d1299 1
@


11.62
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.61 2001/05/04 14:43:27 bparker Exp $ (BRL)";
d1381 1
d1688 1
a1688 1
	return make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index);
d1695 2
@


11.61
log
@*- fix minor stuff
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.60 2001/05/04 14:20:46 bparker Exp $ (BRL)";
d184 1
a184 1
				(void)f_kill(clientData, interp, 2, av);
d850 1
a850 1
    (void)f_kill(clientData, interp, 2, av);
d1781 1
a1781 1
  (void)f_kill((ClientData)NULL, interp, 2, av);
@


11.60
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.59 2001/04/03 19:01:59 bparker Exp $ (BRL)";
d42 2
@


11.59
log
@*- get rid of warnings
*- use mkstemp instead of mktemp
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.58 2001/03/23 22:05:35 jra Exp $ (BRL)";
d1785 1
a1785 1
  (void)f_name((ClientData)NULL, interp, 3, av);
@


11.58
log
@Support for major and minor types in directory structure
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/red.c,v 11.57 2001/01/19 16:11:51 jra Exp $ (BRL)";
d66 1
d103 1
d105 7
d125 1
d127 7
@


11.57
log
@Mods for long names
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.56 2001/01/11 14:38:51 jra Exp $ (BRL)";
d1302 1
a1302 1
		if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, NULL)) == DIR_NULL) {
d1316 1
a1316 1
		if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, NULL)) == DIR_NULL) {
d1731 1
a1731 1
	if( (dp=db_diradd( dbip, red_tmpcomb, -1L, 0, dpold->d_flags, NULL)) == DIR_NULL )  {
@


11.56
log
@Mods for unlimited name length
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.55 2001/01/08 17:11:09 bparker Exp $ (BRL)";
d305 1
a305 1
  char name[NAMESIZE+1];
a307 1
  int j;
a317 12
    if (relation == '\0')
      break;

    /* Next must be the member name */
    ptr = strtok((char *)NULL, delims);
    strncpy(name, ptr, NAMESIZE);
    name[NAMESIZE] = '\0';

    /* Eliminate trailing white space from name */
    j = NAMESIZE;
    while (isspace(name[--j]))
      name[j] = '\0';
d329 4
a332 1
    if (name[0] == '\0') {
a723 1
  bu_log( "comb name is %s\n", argv[1] );
d980 3
a982 1
	char name[NAMESIZE+1];
d1029 12
a1040 1
			strncpy( name, ptr, NAMESIZE );
d1145 4
d1169 12
a1180 2
			strncpy( name , ptr , NAMESIZE );
			name[NAMESIZE] = '\0';
d1182 9
a1190 4
			/* Eliminate trailing white space from name */
			j = NAMESIZE;
			while( isspace( name[--j] ) )
				name[j] = '\0';
d1201 2
d1208 1
a1208 1
			if( name[0] == '\0' )
d1212 2
d1233 2
d1247 3
d1349 3
a1351 2
	char name[NAMESIZE+1];
	char new_name[NAMESIZE+1];
d1401 12
a1412 4
	if( dp == DIR_NULL )
		NAMEMOVE( old_name, new_name );
	else
		NAMEMOVE( dp->d_namep, new_name );
d1441 6
a1446 1
			NAMEMOVE( ptr, new_name );
d1577 9
a1585 2
			strncpy( name , ptr, NAMESIZE );
			name[NAMESIZE] = '\0';
d1588 4
a1591 1
			i = NAMESIZE;
d1669 6
d1753 1
a1753 1
  char name[NAMESIZE];
d1756 1
a1756 1
  strcpy( name , dp->d_namep );
d1769 2
@


11.55
log
@*- Mods to edcodes and red to allow the user to view the info
   even if the database is READ_ONLY.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.54 2000/10/24 19:05:08 mike Exp $ (BRL)";
d388 1
a388 1
	char			name[NAMESIZE+1];
d466 1
a466 2
			strncpy(name , ptr, NAMESIZE);
			name[NAMESIZE] = '\0';
d469 1
a469 1
			i = NAMESIZE;
d714 2
a715 1
  char new_name[NAMESIZE+1];
d734 1
a734 1

d766 13
a778 4
  if(dp == DIR_NULL)
    NAMEMOVE(argv[1], new_name);
  else
    NAMEMOVE(dp->d_namep, new_name);
d1255 1
a1255 1
	if (strncmp(new_name, old_name, NAMESIZE)) {
@


11.54
log
@
Fixed compiler lint, function declarations.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.53 2000/09/08 05:55:49 mike Exp $ (BRL)";
d68 1
d70 1
d129 41
a169 37
	  if( (node_count = checkcomb()) < 0 ){ /* Do some quick checking on the edited file */
	    Tcl_AppendResult(interp, "Error in edited region, no changes made\n", (char *)NULL);
	    if( comb )
		    rt_comb_ifree( &intern, &rt_uniresource );
	    (void)unlink( red_tmpfil );
	    return TCL_ERROR;
	  }

	  if( comb ){
	    if( save_comb( dp ) ){ /* Save combination to a temp name */
	      Tcl_AppendResult(interp, "No changes made\n", (char *)NULL);
	      rt_comb_ifree( &intern, &rt_uniresource );
	      (void)unlink( red_tmpfil );
	      return TCL_OK;
	    }
	  }

	  if( build_comb( comb, dp, node_count, argv[1] ) ){
	    Tcl_AppendResult(interp, "Unable to construct new ", dp->d_namep,
			     (char *)NULL);
	    if( comb ){
	      restore_comb( dp );
	      Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL );
	      rt_comb_ifree( &intern, &rt_uniresource );
	    }

	    (void)unlink( red_tmpfil );
	    return TCL_ERROR;
	  }else if( comb ){
	    /* eliminate the temporary combination */
	    char *av[3];

	    av[0] = "kill";
	    av[1] = red_tmpcomb;
	    av[2] = NULL;
	    (void)f_kill(clientData, interp, 2, av);
	  }
@


11.53
log
@
Tree routines now need resource structure.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.52 2000/08/25 01:35:19 mike Exp $ (BRL)";
d835 1
a835 3
writecomb( comb, name )
struct rt_comb_internal	*comb;
char *name;
d966 1
a966 1
checkcomb()
@


11.52
log
@
lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.51 2000/08/25 01:33:19 mike Exp $ (BRL)";
d94 1
a94 1
		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d130 1
a130 1
		    rt_comb_ifree( &intern );
d138 1
a138 1
	      rt_comb_ifree( &intern );
d150 1
a150 1
	      rt_comb_ifree( &intern );
d579 1
a579 1
    if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d585 1
a585 1
      db_non_union_push( comb->tree );
d595 2
a596 1
      actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION, 1 ) - rt_tree_array;
d663 1
a663 1
      db_free_tree( rt_tree_array[i].tl_tree );
d737 1
a737 1
    if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d749 1
a749 1
    db_free_tree( comb->tree );
d875 1
a875 1
		db_non_union_push( comb->tree );
d887 3
a889 1
		actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION, 0 ) - rt_tree_array;
d1232 1
a1232 1
		final_tree = (union tree *)db_mkgift_tree( rt_tree_array, node_count, (struct db_tree_state *)NULL );
d1254 1
a1254 1
				rt_comb_ifree(&intern);
d1262 1
a1262 1
			rt_comb_ifree(&intern);
d1276 1
a1276 1
			rt_comb_ifree( &intern );
d1286 1
a1286 1
	if (rt_db_put_internal(dp, dbip, &intern) < 0) {
d1338 1
a1338 1
		db_free_tree( comb->tree );
d1655 1
a1655 1
	if( rt_db_get_internal( &intern, dpold, dbip, (fastf_t *)NULL ) < 0 )
d1664 1
a1664 1
	if( rt_db_put_internal(	dp, dbip, &intern ) < 0 )
@


11.51
log
@
lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.50 2000/08/22 06:49:08 mike Exp $ (BRL)";
d326 1
a326 1
    if (relation != '+' && relation != 'u' & relation != '-') {
d979 1
a979 1
	int id,air;
d1155 1
a1155 1
			if( relation != '+' && relation != 'u' & relation != '-' )
@


11.50
log
@
db_flatten_tree() got an additional argument, to prevent memory leaks.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.49 2000/08/19 03:10:48 mike Exp $ (BRL)";
a387 2
	union tree		*final_tree;
	struct rt_db_internal	intern;
@


11.49
log
@
const RCSid
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.48 2000/07/23 23:42:21 mike Exp $ (BRL)";
d597 3
a599 10
      actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION ) - rt_tree_array;
      if( actual_count > node_count )
	bu_bomb("write_comb() array overflow!");
      if( actual_count < node_count ){
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "WARNING write_comb() array underflow! %d < %d",
		      actual_count, node_count);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
      }
d664 1
d888 2
a889 3
		actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION ) - rt_tree_array;
		if( actual_count > node_count )  bu_bomb("write_comb() array overflow!");
		if( actual_count < node_count )  bu_log("WARNING write_comb() array underflow! %d < %d", actual_count, node_count);
@


11.48
log
@
Removed calls to db_alloc(), which are no longer necessary
with either v4 or v5 database interfaces
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.47 2000/06/01 21:35:36 bparker Exp $ (BRL)";
@


11.47
log
@*- make_tree routine to be called by
   build_comb and put_tree_into_comb.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.46 2000/06/01 14:54:54 bparker Exp $ (BRL)";
d1265 1
a1265 1
		if ((dp=db_diradd(dbip, new_name, -1, node_count+1, flags, NULL)) == DIR_NULL) {
a1270 7

		if (db_alloc(dbip, dp, node_count+1)) {
			Tcl_AppendResult(interp, "Cannot allocate file space for ", new_name,
				"\n", (char *)NULL);
			rt_comb_ifree(&intern);
			return(1);
		}
d1279 1
a1279 1
		if ((dp=db_diradd(dbip, new_name, -1, node_count+1, flags, NULL)) == DIR_NULL) {
a1284 7

		if (db_alloc( dbip, dp, node_count+1)) {
			Tcl_AppendResult(interp, "Cannot allocate file space for ", new_name,
				"\n", (char *)NULL);
			rt_comb_ifree(&intern);
			return(1);
		}
d1664 1
a1664 3
	if( (dp=db_diradd( dbip, red_tmpcomb, -1, dpold->d_len, dpold->d_flags, NULL)) == DIR_NULL ||
	    db_alloc( dbip, dp, dpold->d_len ) < 0 )
	{
@


11.47.2.1
log
@*- mods to edcodes and red to allow the user to view the info
   even if the database is READ_ONLY
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.47 2000/06/01 21:35:36 bparker Exp $ (BRL)";
a67 1
#if 0
a68 1
#endif
d127 37
a163 41
		if (!dbip->dbi_read_only) {
			if( (node_count = checkcomb()) < 0 ){ /* Do some quick checking on the edited file */
				Tcl_AppendResult(interp, "Error in edited region, no changes made\n", (char *)NULL);
				if( comb )
					rt_comb_ifree( &intern );
				(void)unlink( red_tmpfil );
				return TCL_ERROR;
			}

			if( comb ){
				if( save_comb( dp ) ){ /* Save combination to a temp name */
					Tcl_AppendResult(interp, "No changes made\n", (char *)NULL);
					rt_comb_ifree( &intern );
					(void)unlink( red_tmpfil );
					return TCL_OK;
				}
			}

			if( build_comb( comb, dp, node_count, argv[1] ) ){
				Tcl_AppendResult(interp, "Unable to construct new ", dp->d_namep,
						 (char *)NULL);
				if( comb ){
					restore_comb( dp );
					Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL );
					rt_comb_ifree( &intern );
				}

				(void)unlink( red_tmpfil );
				return TCL_ERROR;
			}else if( comb ){
				/* eliminate the temporary combination */
				char *av[3];

				av[0] = "kill";
				av[1] = red_tmpcomb;
				av[2] = NULL;
				(void)f_kill(clientData, interp, 2, av);
			}
		} else {
			Tcl_AppendResult(interp, "Because the database is READ-ONLY no changes were made.\n", (char *)NULL);
		}
@


11.46
log
@Track changes to region flag in build_comb
(same fix that mike applied to put_comb).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.45 2000/05/31 20:50:53 mike Exp $ (BRL)";
d52 1
d371 5
a375 5
struct rt_comb_internal *comb;
struct directory *dp;
char *old_name;
char *new_name;
char *str;
d377 57
a433 15
  int i;
  int done;
  char *line;
  char *ptr;
  char relation;
  char name[NAMESIZE+1];
  struct rt_tree_array *rt_tree_array;
  struct line_list *llp;
  int node_count = 0;
  int tree_index = 0;
  union tree *tp;
  union tree *final_tree;
  struct rt_db_internal intern;
  matp_t matrix;
  struct bu_vls vls;
d435 5
a439 2
  if(str == (char *)NULL)
    return TCL_ERROR;
d441 6
a446 1
  BU_LIST_INIT(&HeadLines.l);
d448 4
a451 8
  /* break str into lines */
  line = str;
  ptr = strchr(str, '\n');
  if (ptr != NULL)
    *ptr = '\0';
  bu_vls_init(&vls);
  while (line != (char *)NULL) {
    int n;
d453 11
a463 1
    bu_vls_strcpy(&vls, line);
d465 4
a468 24
    if ((n = count_nodes(bu_vls_addr(&vls))) < 0) {
      bu_vls_free(&vls);
      bu_list_free(&HeadLines.l);
      return TCL_ERROR;
    } else if (n > 0) {
      BU_GETSTRUCT(llp, line_list);
      BU_LIST_INSERT(&HeadLines.l, &llp->l);
      llp->line = line;

      node_count += n;
    } /* else blank line */

    if (ptr != NULL && *(ptr+1) != '\0') {
      /* leap frog past EOS */
      line = ptr + 1;

      ptr = strchr(line, '\n');
      if (ptr != NULL)
	*ptr = '\0';
    } else {
      line = NULL;
    }
  }
  bu_vls_free(&vls);
d470 3
a472 5
  /* build tree list */
  if (node_count)
    rt_tree_array = (struct rt_tree_array *)bu_calloc(node_count, sizeof(struct rt_tree_array), "tree list" );
  else
    rt_tree_array = (struct rt_tree_array *)NULL;
d474 12
a485 6
  for(BU_LIST_FOR(llp, line_list, &HeadLines.l)){
    done = 0;
    ptr = strtok(llp->line, delims);
    while (!done) {
      if ( !ptr )
	break;
d487 18
a504 4
      /* First non-white is the relation operator */
      relation = (*ptr);
      if (relation == '\0')
	break;
d506 4
a509 11
      /* Next must be the member name */
      ptr = strtok((char *)NULL, delims);
      if (ptr == (char *)NULL) {
	bu_list_free(&HeadLines.l);
	if(rt_tree_array)
	  bu_free( (char *)rt_tree_array, "red: tree list" );
	bu_log("no name specified\n");
	return TCL_ERROR;
      }
      strncpy(name , ptr, NAMESIZE);
      name[NAMESIZE] = '\0';
d511 14
a524 21
      /* Eliminate trailing white space from name */
      i = NAMESIZE;
      while(isspace(name[--i]))
      name[i] = '\0';

      /* Check for existence of member */
      if ((db_lookup(dbip , name , LOOKUP_QUIET)) == DIR_NULL)
      bu_log("\tWARNING: ' %s ' does not exist\n", name);

      /* get matrix */
      ptr = strtok((char *)NULL, delims);
      if (ptr == (char *)NULL) {
	matrix = (matp_t)NULL;
	done = 1;
      }else if(*ptr == 'u' ||
	       (*ptr == '-' && *(ptr+1) == '\0') ||
	       (*ptr == '+' && *(ptr+1) == '\0')) {
	/* assume another relational operator */
	matrix = (matp_t)NULL;
      } else {
	int k;
d526 8
a533 17
	matrix = (matp_t)bu_calloc(16, sizeof(fastf_t), "red: matrix");
	matrix[0] = atof(ptr);
	for (k=1 ; k<16 ; k++) {
	  ptr = strtok((char *)NULL, delims);
	  if (!ptr) {
	    bu_log("incomplete matrix for member %s - No changes made\n", name);
	    bu_free( (char *)matrix, "red: matrix" );
	    if(rt_tree_array)
	      bu_free((char *)rt_tree_array, "red: tree list");
	    bu_list_free(&HeadLines.l);
	    return TCL_ERROR;
	  }
	  matrix[k] = atof( ptr );
	}
	if (bn_mat_is_identity( matrix )) {
	  bu_free((char *)matrix, "red: matrix");
	  matrix = (matp_t)NULL;
d536 6
a541 102
	ptr = strtok((char *)NULL, delims);
	if (ptr == (char *)NULL)
	  done = 1;
      }

      /* Add it to the combination */
      switch (relation) {
      case '+':
	rt_tree_array[tree_index].tl_op = OP_INTERSECT;
	break;
      case '-':
	rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
	break;
      default:
	bu_log("unrecognized relation (assume UNION)\n");
      case 'u':
	rt_tree_array[tree_index].tl_op = OP_UNION;
	break;
      }

      BU_GETUNION(tp, tree);
      rt_tree_array[tree_index].tl_tree = tp;
      tp->tr_l.magic = RT_TREE_MAGIC;
      tp->tr_l.tl_op = OP_DB_LEAF;
      tp->tr_l.tl_name = bu_strdup( name );
      tp->tr_l.tl_mat = matrix;
      tree_index++;
    }
  }

  bu_list_free(&HeadLines.l);

  if( tree_index )
    final_tree = (union tree *)db_mkgift_tree( rt_tree_array, node_count, (struct db_tree_state *)NULL );
  else
    final_tree = (union tree *)NULL;

  RT_INIT_DB_INTERNAL( &intern );
  intern.idb_type = ID_COMBINATION;
  intern.idb_meth = &rt_functab[ID_COMBINATION];
  intern.idb_ptr = (genptr_t)comb;
  comb->tree = final_tree;

  if( strncmp( new_name, old_name, NAMESIZE ) ){
    int flags;

    if( comb->region_flag )
      flags = DIR_COMB | DIR_REGION;
    else
      flags = DIR_COMB;

    if( dp != DIR_NULL ){
      if(  db_delete( dbip, dp ) || db_dirdelete( dbip, dp ) ){
	bu_log("ERROR: Unable to delete directory entry for %s\n", old_name);
	rt_comb_ifree( &intern );
	return( 1 );
      }
    }

    if( (dp=db_diradd( dbip, new_name, -1, node_count+1, flags, NULL)) == DIR_NULL ){
      bu_log("Cannot add %s to directory, no changes made\n", new_name);
      rt_comb_ifree( &intern );
      return( 1 );
    }

    if( db_alloc( dbip, dp, node_count+1) ){
      bu_log("Cannot allocate file space for %s\n", new_name);
      rt_comb_ifree( &intern );
      return( 1 );
    }
  }else if( dp == DIR_NULL ){
    int flags;

    if( comb->region_flag )
      flags = DIR_COMB | DIR_REGION;
    else
      flags = DIR_COMB;

    if( (dp=db_diradd( dbip, new_name, -1, node_count+1, flags, NULL)) == DIR_NULL ){
      bu_log("Cannot add %s to directory, no changes made\n", new_name);
      rt_comb_ifree( &intern );
      return TCL_ERROR;
    }

    if( db_alloc( dbip, dp, node_count+1) ){
      bu_log("Cannot allocate file space for %s\n", new_name);
      rt_comb_ifree( &intern );
      return TCL_ERROR;
    }
  }else {
  	if( comb->region_flag )
  		dp->d_flags |= DIR_REGION;
  	else
  		dp->d_flags &= ~DIR_REGION;
  }

  if( rt_db_put_internal( dp, dbip, &intern ) < 0 ){
    bu_log("ERROR: Unable to write new combination into database.\n");
    return TCL_ERROR;
  }

  return TCL_OK;
d1224 91
a1336 2
	union tree *final_tree;
	struct rt_db_internal intern;
d1621 1
a1621 84

	if( tree_index )
		final_tree = (union tree *)db_mkgift_tree( rt_tree_array, node_count, (struct db_tree_state *)NULL );
	else
		final_tree = (union tree *)NULL;

	RT_INIT_DB_INTERNAL( &intern );
	intern.idb_type = ID_COMBINATION;
	intern.idb_meth = &rt_functab[ID_COMBINATION];
	intern.idb_ptr = (genptr_t)comb;
	comb->tree = final_tree;

	if( strncmp( new_name, old_name, NAMESIZE ) )
	{
		int flags;

		if( comb->region_flag )
			flags = DIR_COMB | DIR_REGION;
		else
			flags = DIR_COMB;

		if( dp != DIR_NULL )
		{
			if(  db_delete( dbip, dp ) || db_dirdelete( dbip, dp ) )
			{
				Tcl_AppendResult(interp, "ERROR: Unable to delete directory entry for ",
					old_name, "\n", (char *)NULL );
				rt_comb_ifree( &intern );
				return( 1 );
			}
		}

		if( (dp=db_diradd( dbip, new_name, -1, node_count+1, flags, NULL)) == DIR_NULL )
		{
		  Tcl_AppendResult(interp, "Cannot add ", new_name,
				   " to directory, no changes made\n", (char *)NULL);
		  rt_comb_ifree( &intern );
		  return( 1 );
		}

		if( db_alloc( dbip, dp, node_count+1) )
		{
			Tcl_AppendResult(interp, "Cannot allocate file space for ", new_name,
				"\n", (char *)NULL );
			rt_comb_ifree( &intern );
			return( 1 );
		}
	}
	else if( dp == DIR_NULL )
	{
		int flags;

		if( comb->region_flag )
			flags = DIR_COMB | DIR_REGION;
		else
			flags = DIR_COMB;

		if( (dp=db_diradd( dbip, new_name, -1, node_count+1, flags, NULL)) == DIR_NULL )
		{
		  Tcl_AppendResult(interp, "Cannot add ", new_name,
				   " to directory, no changes made\n", (char *)NULL);
		  rt_comb_ifree( &intern );
		  return( 1 );
		}

		if( db_alloc( dbip, dp, node_count+1) )
		{
			Tcl_AppendResult(interp, "Cannot allocate file space for ", new_name,
				"\n", (char *)NULL );
			rt_comb_ifree( &intern );
			return( 1 );
		}
	}else {
		if( comb->region_flag )
			dp->d_flags |= DIR_REGION;
		else
			dp->d_flags &= ~DIR_REGION;
	}

	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
		Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
		return 1;
	}
	return( 0 );
@


11.45
log
@
Track changes to region flag in put_comb.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.44 2000/03/02 19:01:36 jra Exp $ (BRL)";
d1668 5
@


11.44
log
@Now uses the comb->region_flag as 1 or 0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.43 2000/01/03 13:49:42 jra Exp $ (BRL)";
d593 5
d766 4
@


11.43
log
@Eliminated some unused variables
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.42 1999/12/29 23:23:24 mike Exp $ (BRL)";
d828 1
a828 1
    comb->region_flag = 'Y';
d830 1
a830 1
    comb->region_flag = '\0';
d1386 1
a1386 1
				comb->region_flag = 'Y';
d1388 1
a1388 1
				comb->region_flag = '\0';
@


11.42
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.41 1999/11/26 23:03:33 mike Exp $ (BRL)";
a53 3
static int ident;
static int air;

a381 1
  struct directory *dp1;
d469 1
a469 1
      if ((dp1=db_lookup(dbip , name , LOOKUP_QUIET)) == DIR_NULL)
d614 1
a614 1
  int offset,i;
d904 1
a904 1
	int			offset,i;
d1043 1
a1043 2
	int id,air,gift,los;
	unsigned char rgb[3];
a1108 1
			gift = atoi( ptr );
a1112 1
			los = atoi( ptr );
d1119 1
a1125 1
			rgb[0] = atoi( ptr2 ) & 0377;
a1131 1
			rgb[1] = atoi( ptr2 ) & 0377;
d1138 2
a1139 1
			rgb[2] = atoi( ptr2 ) & 0377;
d1297 1
a1297 3
	int region;
	int done2, first;
	struct directory *dp1;
a1493 1
		first=1;
a1502 1
			first = 0;
d1515 1
a1515 1
			if( (dp1=db_lookup( dbip , name , LOOKUP_QUIET )) == DIR_NULL )
@


11.41
log
@
Lint
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.40 1999/11/24 14:26:42 jra Exp $ (BRL)";
d567 1
a567 1
    if( (dp=db_diradd( dbip, new_name, -1, node_count+1, flags)) == DIR_NULL ){
d586 1
a586 1
    if( (dp=db_diradd( dbip, new_name, -1, node_count+1, flags)) == DIR_NULL ){
d1630 1
a1630 1
		if( (dp=db_diradd( dbip, new_name, -1, node_count+1, flags)) == DIR_NULL )
d1655 1
a1655 1
		if( (dp=db_diradd( dbip, new_name, -1, node_count+1, flags)) == DIR_NULL )
d1733 1
a1733 1
	if( (dp=db_diradd( dbip, red_tmpcomb, -1, dpold->d_len, dpold->d_flags)) == DIR_NULL ||
@


11.40
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.39 1999/11/18 22:38:01 cjohnson Exp $ (BRL)";
d96 1
a96 1
		if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d644 1
a644 1
    if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d803 1
a803 1
    if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d1730 1
a1730 1
	if( rt_db_get_internal( &intern, dpold, dbip, (mat_t *)NULL ) < 0 )
@


11.39
log
@count_nodes would core dump because the last strtok always returns NULL
which is then dereferenced at the start of the loop.  Remove done flag
and use the result of 'ptr' directly.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.38 1999/10/15 18:30:23 bparker Exp $ (BRL)";
d547 1
d1606 1
@


11.38
log
@*- check return value from strtok before
   trying to use
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.37 1999/10/14 13:57:02 jra Exp $ (BRL)";
a302 1
  int done=0;
d312 1
a312 5
  /* more sanity */
  if (ptr == NULL)
    return 0;

  while (!done) {
d344 6
a349 5
    if (!ptr)
      done = 1;
    else if (*ptr != 'u' &&
	     (*ptr != '-' || *(ptr+1) != '\0') &&
	     (*ptr != '+' || *(ptr+1) != '\0')) {
d352 1
a352 1
      /* skip past matrix */
@


11.37
log
@Fixed temp file template (now 6 X's are required) and fixed a minor bug in finding the end of an input line.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.36 1999/09/01 18:55:11 bparker Exp $ (BRL)";
d451 3
d1509 3
@


11.36
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.35 1999/07/16 20:15:55 bparker Exp $ (BRL)";
d43 4
a46 4
static char	red_tmpfil[16];
static char	*red_tmpfil_init = "/tmp/GED.aXXXXX";
static char	red_tmpcomb[15];
static char	*red_tmpcomb_init = "red_tmp.aXXXXX";
d1199 6
@


11.35
log
@*- added error checking to put_tree_into_comb
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.34 1999/07/16 18:03:20 bparker Exp $ (BRL)";
d69 1
a69 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d623 1
a623 3
  if(dbip == DBI_NULL)
    return TCL_OK;

d779 1
a779 3
  if(dbip == DBI_NULL)
    return TCL_OK;

@


11.34
log
@*- added some error checking to count_nodes()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.33 1999/07/07 15:41:04 bparker Exp $ (BRL)";
d315 4
d415 1
a416 3
    BU_GETSTRUCT(llp, line_list);
    BU_LIST_INSERT(&HeadLines.l, &llp->l);
    llp->line = line;
d422 5
a426 1
    } else
d428 1
d431 1
d433 1
@


11.33
log
@*- mods to allow multiple objects on the same line
   while editing a combination
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.32 1999/04/23 17:51:17 bparker Exp $ (BRL)";
d308 4
@


11.32
log
@*- mods to cmd_put_comb
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.31 1999/01/21 18:31:20 bparker Exp $ (BRL)";
d297 71
a367 1
static char newline[] = "\n";
d378 1
d392 1
d400 8
a407 2
  line = strtok(str, newline);
  while(line != (char *)NULL){
d411 16
a426 2
    line = strtok((char *)NULL, newline);
    ++node_count;
d428 1
d431 1
a431 1
  if( node_count )
d437 1
d439 5
d445 11
a455 9
    /* First non-white is the relation operator */
    relation = (*ptr);
    if( relation == '\0' ){
      bu_list_free(&HeadLines.l);
      if( rt_tree_array )
	bu_free( (char *)rt_tree_array, "red: tree list" );
      bu_log("no relational operator\n");
      return TCL_ERROR;
    }
d457 3
a459 15
    /* Next must be the member name */
    ptr = strtok( (char *)NULL, delims );
    if(ptr == (char *)NULL){
      bu_list_free(&HeadLines.l);
      if( rt_tree_array )
	bu_free( (char *)rt_tree_array, "red: tree list" );
      bu_log("no name specified\n");
      return TCL_ERROR;
    }
    strncpy( name , ptr, NAMESIZE );
    name[NAMESIZE] = '\0';

    /* Eliminate trailing white space from name */
    i = NAMESIZE;
    while( isspace( name[--i] ) )
d462 2
a463 2
    /* Check for existence of member */
    if( (dp1=db_lookup( dbip , name , LOOKUP_QUIET )) == DIR_NULL )
d466 12
a477 6
    /* get matrix */
    ptr = strtok( (char *)NULL, delims );
    if(ptr == (char *)NULL)
      matrix = (matp_t)NULL;
    else{
      int k;
d479 17
a495 11
      matrix = (matp_t)bu_calloc( 16, sizeof( fastf_t ), "red: matrix" );
      matrix[0] = atof( ptr );
      for( k=1 ; k<16 ; k++ ){
	ptr = strtok( (char *)NULL, delims );
	if( !ptr ){
	  bu_log("incomplete matrix for member %s - No changes made\n", name);
	  bu_free( (char *)matrix, "red: matrix" );
	  if( rt_tree_array )
	    bu_free( (char *)rt_tree_array, "red: tree list" );
	  bu_list_free(&HeadLines.l);
	  return TCL_ERROR;
d497 4
a500 1
	matrix[k] = atof( ptr );
d502 14
a515 3
      if( bn_mat_is_identity( matrix ) ){
	bu_free( (char *)matrix, "red: matrix" );
	matrix = (matp_t)NULL;
a516 1
    }
d518 7
a524 13
    /* Add it to the combination */
    switch( relation ){
    case '+':
      rt_tree_array[tree_index].tl_op = OP_INTERSECT;
      break;
    case '-':
      rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
      break;
    default:
      bu_log("unrecognized relation (assume UNION)\n");
    case 'u':
      rt_tree_array[tree_index].tl_op = OP_UNION;
      break;
a525 8

    BU_GETUNION( tp, tree );
    rt_tree_array[tree_index].tl_tree = tp;
    tp->tr_l.magic = RT_TREE_MAGIC;
    tp->tr_l.tl_op = OP_DB_LEAF;
    tp->tr_l.tl_name = bu_strdup( name );
    tp->tr_l.tl_mat = matrix;
    tree_index++;
d1034 1
d1186 2
a1188 7
		/* First non-white is the relation operator */
		relation = (*ptr);
		if( relation == '\0' )
		{
			done = 1;
			break;
		}
d1190 22
a1211 4
		/* Next must be the member name */
		ptr = strtok( (char *)NULL, delims );
		strncpy( name , ptr , NAMESIZE );
		name[NAMESIZE] = '\0';
d1213 3
a1215 4
		/* Eliminate trailing white space from name */
		j = NAMESIZE;
		while( isspace( name[--j] ) )
			name[j] = '\0';
d1217 36
a1252 3
		if( relation != '+' && relation != 'u' & relation != '-' )
		{
		  struct bu_vls tmp_vls;
d1254 3
a1256 9
		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, " %c is not a legal operator\n" , relation );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  fclose( fp );
		  return( -1 );
		}
		if( relation != '-' )
			nonsubs++;
d1258 1
a1258 5
		if( name[0] == '\0' )
		{
		  Tcl_AppendResult(interp, " operand name missing\n", (char *)NULL);
		  fclose( fp );
		  return( -1 );
a1259 2

		node_count++;
d1292 1
d1489 2
d1492 6
d1499 26
a1524 7
		/* First non-white is the relation operator */
		relation = (*ptr);
		if( relation == '\0' )
		{
			done = 1;
			break;
		}
d1526 18
a1543 28
		/* Next must be the member name */
		ptr = strtok( (char *)NULL, delims );
		strncpy( name , ptr, NAMESIZE );
		name[NAMESIZE] = '\0';

		/* Eliminate trailing white space from name */
		i = NAMESIZE;
		while( isspace( name[--i] ) )
			name[i] = '\0';

		/* Check for existence of member */
		if( (dp1=db_lookup( dbip , name , LOOKUP_QUIET )) == DIR_NULL )
		  Tcl_AppendResult(interp, "\tWARNING: '", name, "' does not exist\n", (char *)NULL);

		/* get matrix */
		ptr = strtok( (char *)NULL, delims );
		if( !ptr )
			matrix = (matp_t)NULL;
		else
		{
			int k;

			matrix = (matp_t)bu_calloc( 16, sizeof( fastf_t ), "red: matrix" );
			matrix[0] = atof( ptr );
			for( k=1 ; k<16 ; k++ )
			{
				ptr = strtok( (char *)NULL, delims );
				if( !ptr )
a1544 2
					Tcl_AppendResult(interp, "incomplete matrix for member ",
						name, " No changes made\n", (char *)NULL );
d1546 1
a1546 4
					if( rt_tree_array )
						bu_free( (char *)rt_tree_array, "red: tree list" );
					fclose( fp );
					return( 1 );
d1548 4
a1551 1
				matrix[k] = atof( ptr );
d1553 3
a1555 1
			if( bn_mat_is_identity( matrix ) )
d1557 12
a1568 2
				bu_free( (char *)matrix, "red: matrix" );
				matrix = (matp_t)NULL;
d1570 7
a1577 24

		/* Add it to the combination */
		switch( relation )
		{
			case '+':
				rt_tree_array[tree_index].tl_op = OP_INTERSECT;
				break;
			case '-':
				rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
				break;
			default:
				Tcl_AppendResult(interp, "unrecognized relation (assume UNION)\n",
					(char *)NULL );
			case 'u':
				rt_tree_array[tree_index].tl_op = OP_UNION;
				break;
		}
		BU_GETUNION( tp, tree );
		rt_tree_array[tree_index].tl_tree = tp;
		tp->tr_l.magic = RT_TREE_MAGIC;
		tp->tr_l.tl_op = OP_DB_LEAF;
		tp->tr_l.tl_name = bu_strdup( name );
		tp->tr_l.tl_mat = matrix;
		tree_index++;
d1581 1
@


11.31
log
@*- use helpdevel for help on developer commands
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.30 1999/01/04 22:51:42 bparker Exp $ (BRL)";
d744 6
@


11.30
log
@*- mods to put_rgb_into_comb
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/red.c,v 11.29 1998/06/11 20:48:11 bparker Exp $ (BRL)";
d520 1
a520 1
    bu_vls_printf(&vls, "help get_comb");
d679 1
a679 1
    bu_vls_printf(&vls, "help put_comb");
@


11.29
log
@*- mods to checkcomb() and build_comb()
	- if encountered EOF and characters read,
		mark as done, but continue to process input string
*- modified checkcomb() to skip blank lines as does build_comb()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/red.c,v 11.28 1998/04/07 14:53:58 bparker Exp $ (BRL)";
d49 1
d257 1
a257 1
HIDDEN int
d264 4
a267 2
  if(sscanf(str, "%d%d%d", &r, &g, &b) != 3)
    return TCL_ERROR;
a288 2

  return TCL_OK;
@


11.28
log
@*- mods to put_tree_into_comb() to go back to using bu_log
*- mods to cmd_get_comb() and cmd_put_comb()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.27 1997/11/05 19:25:13 jra Exp bparker $ (BRL)";
d956 2
a957 1
			break;
d971 3
d1214 2
a1215 1
			break;
@


11.27
log
@Changes to get it to compile on a SUN4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.26 1997/09/26 21:25:01 bparker Exp jra $ (BRL)";
d351 1
a351 1
      Tcl_AppendResult(interp, "no relational operator\n", (char *)NULL);
d361 1
a361 1
      Tcl_AppendResult(interp, "no name specified\n", (char *)NULL);
d374 1
a374 2
      Tcl_AppendResult(interp, "\tWARNING: '", name,
		       "' does not exist\n", (char *)NULL);
d388 1
a388 2
	  Tcl_AppendResult(interp, "incomplete matrix for member ",
			   name, " No changes made\n", (char *)NULL );
d412 1
a412 2
      Tcl_AppendResult(interp, "unrecognized relation (assume UNION)\n",
		       (char *)NULL );
d449 1
a449 2
	Tcl_AppendResult(interp, "ERROR: Unable to delete directory entry for ",
			 old_name, "\n", (char *)NULL );
d456 1
a456 2
      Tcl_AppendResult(interp, "Cannot add ", new_name,
		       " to directory, no changes made\n", (char *)NULL);
d462 1
a462 2
      Tcl_AppendResult(interp, "Cannot allocate file space for ", new_name,
		       "\n", (char *)NULL );
d475 1
a475 2
      Tcl_AppendResult(interp, "Cannot add ", new_name,
		       " to directory, no changes made\n", (char *)NULL);
d481 1
a481 2
      Tcl_AppendResult(interp, "Cannot allocate file space for ", new_name,
		       "\n", (char *)NULL );
d488 1
a488 1
    Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
d651 1
a651 1
    return TCL_OK;
d667 1
d700 1
d772 1
a772 1
  }else if(comb){
@


11.26
log
@mods to cmd_get_comb and cmd_put_comb
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.25 1997/09/23 21:11:59 bparker Exp bparker $ (BRL)";
d296 1
a310 1
  char newline[] = "\n";
@


11.25
log
@2 new commands: get_comb and put_comb
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.24 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d43 5
a47 3
static char	red_tmpfil[] = "/tmp/GED.aXXXXX";
static char	red_tmpcomb[] = "red_tmp.aXXXXX";
static char	*delims = " \t/";	/* allowable delimiters */
d83 3
d129 1
a129 2
	if( editit( red_tmpfil ) )
	{
d138 7
a144 7
	  if( comb )
	  {
	  if( save_comb( dp ) ){ /* Save combination to a temp name */
	    Tcl_AppendResult(interp, "No changes made\n", (char *)NULL);
	    rt_comb_ifree( &intern );
	    (void)unlink( red_tmpfil );
	    return TCL_OK;
a145 1
	}
d147 1
a147 2
	  if( build_comb( comb, dp, node_count, argv[1] ) )
	  {
d150 4
a153 5
	    if( comb )
	    {
		    restore_comb( dp );
	    	    Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL );
		    rt_comb_ifree( &intern );
d155 1
d158 2
a159 4
	  }
	  else if( comb )
	  {
		/* eliminate the temporary combination */
d348 3
d358 3
d394 1
d430 2
d517 1
d524 2
a526 3
    struct bu_vls vls;

    bu_vls_init(&vls);
a535 2
    struct bu_vls vls;

d557 1
a557 2
      rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count,
							 sizeof( struct rt_tree_array ), "tree list" );
d559 9
a567 2
      if( actual_count > node_count )  bu_bomb("write_comb() array overflow!");
      if( actual_count < node_count )  bu_log("WARNING write_comb() array underflow! %d < %d", actual_count, node_count);
a572 1
    bu_vls_init(&vls);
d576 1
d589 1
a589 5
      Tcl_AppendElement(interp, "No");   /* REGION=No        */
      Tcl_AppendElement(interp, "");     /* REGION_ID=""     */
      Tcl_AppendElement(interp, "");     /* AIRCODE=""       */
      Tcl_AppendElement(interp, "");     /* GIFT_MATERIAL="" */
      Tcl_AppendElement(interp, "");     /* LOS=""           */
d597 1
a597 1
      Tcl_AppendElement(interp, "");                 /* COLOR=""        */
d639 14
a652 6
    Tcl_AppendElement(interp, argv[1]); /* NAME=argv[1]     */
    Tcl_AppendElement(interp, "No");    /* REGION=No        */
    Tcl_AppendElement(interp, "");      /* REGION_ID=""     */
    Tcl_AppendElement(interp, "");      /* AIRCODE=""       */
    Tcl_AppendElement(interp, "");      /* GIFT_MATERIAL="" */
    Tcl_AppendElement(interp, "");      /* LOS=""           */
d657 1
d674 1
d681 1
a681 1
  if(argc != 11){
d691 3
d734 31
a764 6
  comb->region_id = atoi(argv[3]);
  comb->aircode = atoi(argv[4]);
  comb->GIFTmater = atoi(argv[5]);
  comb->los = atoi(argv[6]);
  put_rgb_into_comb(comb, argv[7]);
  bu_vls_strcpy(&comb->shader, argv[8]);
d766 1
a766 1
  if(*argv[9] == 'y' || *argv[9] == 'Y')
d771 1
a771 1
  if(put_tree_into_comb(comb, dp, argv[1], new_name, argv[10]) == TCL_ERROR){
@


11.24
log
@mods to run without a database
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.23 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
d71 1
a71 1
	if(argc < 2 || 2 < argc){
d134 2
a135 2
	if( comb )
	{
d229 514
@


11.23
log
@modify calls to Tcl_Eval
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.22 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d66 3
d600 3
d961 3
d993 3
@


11.22
log
@mods so that commands check args internally
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.21 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d69 6
a74 1
	  Tcl_Eval(interp, "help red");
@


11.21
log
@Mods to support MGED's read-only mode.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.20 1997/03/20 14:47:18 bparker Exp jra $ (BRL)";
d68 2
a69 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d71 1
@


11.20
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.19 1997/03/04 19:29:35 jra Exp bparker $ (BRL)";
d65 2
@


11.19
log
@Fixed minor typo.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.18 1997/02/28 21:40:49 jra Exp jra $ (BRL)";
a335 1
				break;
@


11.18
log
@removed include of db.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.17 1997/02/27 15:46:03 jra Exp jra $ (BRL)";
d273 2
a274 2
		if( actual_count > node_count )  bu_bomb("rt_comb_v4_export() array overflow!");
		if( actual_count < node_count )  bu_log("WARNING rt_comb_v4_export() array underflow! %d < %d", actual_count, node_count);
@


11.17
log
@Allow "red" to edit regions with non-existing members.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.16 1997/02/20 21:45:31 jra Exp jra $ (BRL)";
a37 1
#include "db.h"
@


11.16
log
@converted to rt_tree_array instead of tree_list.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.15 1997/02/20 19:38:28 jra Exp jra $ (BRL)";
a548 6
		if( db_lookup( dbip , name , LOOKUP_NOISY ) == DIR_NULL )
		{
		  Tcl_AppendResult(interp, " ", name, " does not exist\n", (char *)NULL);
		  fclose( fp );
		  return( -1 );
		}
d795 2
a796 8
		if( (dp1=db_lookup( dbip , name , LOOKUP_NOISY )) == DIR_NULL )
		{
		  Tcl_AppendResult(interp, " ", name, " does not exist\n", (char *)NULL);
		  if( rt_tree_array )
			bu_free( (char *)rt_tree_array, "red: tree list" );
		  fclose( fp );
		  return( 1 );
		}
@


11.15
log
@Major rewrite. Converted to use comb import/export also generalized to do much more editing.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.14 1997/01/30 02:19:40 mike Exp jra $ (BRL)";
a43 9

/* XXXXX tree_list struct definition copied from db_comb.c, needs to be in raytrace.h */
struct tree_list {
        union tree *tl_tree;
        int     tl_op;
};
#define TREE_LIST_NULL  ((struct tree_list *)0)


d226 1
a226 1
	struct tree_list	*tree_list;
d271 3
a273 3
		tree_list = (struct tree_list *)bu_calloc( node_count,
			sizeof( struct tree_list ), "tree list" );
		actual_count = (struct tree_list *)db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
d279 1
a279 1
		tree_list = (struct tree_list *)NULL;
d321 1
a321 1
		switch( tree_list[i].tl_op )
d339 1
a339 1
		if( fprintf( fp , " %c %s" , op , tree_list[i].tl_tree->tr_l.tl_name ) <= 0 )
d346 1
a346 1
		print_matrix( fp, tree_list[i].tl_tree->tr_l.tl_mat );
d589 1
a589 1
	struct tree_list *tree_list;
d627 1
a627 1
		tree_list = (struct tree_list *)bu_calloc( node_count , sizeof( struct tree_list ) , "tree list" );
d629 1
a629 1
		tree_list = (struct tree_list *)NULL;
d804 2
a805 2
		  if( tree_list )
			bu_free( (char *)tree_list, "red: tree list" );
d828 2
a829 2
					if( tree_list )
						bu_free( (char *)tree_list, "red: tree list" );
d846 1
a846 1
				tree_list[tree_index].tl_op = OP_INTERSECT;
d849 1
a849 1
				tree_list[tree_index].tl_op = OP_SUBTRACT;
d855 1
a855 1
				tree_list[tree_index].tl_op = OP_UNION;
d859 1
a859 1
		tree_list[tree_index].tl_tree = tp;
d870 1
a870 1
		final_tree = (union tree *)db_mkgift_tree( tree_list, node_count, (struct db_tree_state *)NULL );
@


11.14
log
@Eliminated rt_get_comb
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.13 1997/01/29 01:56:52 mike Exp mike $ (BRL)";
d44 9
d55 1
a70 2

	union record record;
d72 3
d79 1
a79 5
	if( (dp=db_lookup( dbip , argv[1] , LOOKUP_NOISY )) == DIR_NULL )
	{
	  Tcl_AppendResult(interp, "Cannot edit: ", argv[1], "\n", (char *)NULL);
	  return TCL_ERROR;
	}
d81 1
a81 4
	if( db_get( dbip , dp , &record , 0 , 1 ) < 0 ) {
	  TCL_READ_ERR_return;
	}
	if( record.u_id != ID_COMB )	/* Not a combination */
d83 6
a88 4
	  Tcl_AppendResult(interp, argv[1],
			   " is not a combination, so cannot be edited this way\n", (char *)NULL);
	  return TCL_ERROR;
	}
d90 2
a91 3
	/* Save for later use in rebuilding */
	ident = record.c.c_regionid;
	air = record.c.c_aircode;
d93 1
d95 2
a96 2
	/* Make a file for the text editor */
	(void)mktemp( red_tmpfil );
d98 9
a106 2
	/* Write the combination components to the file */
	if( writecomb( dp ) )
d108 11
a118 3
	  Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
	  unlink( red_tmpfil );
	  return TCL_ERROR;
d124 1
a124 1
	  if( checkcomb() ){ /* Do some quick checking on the edited file */
d126 2
d131 3
d136 1
d140 12
a151 4
	  if( clear_comb( dp ) ){ /* Empty this combination */
	    Tcl_AppendResult(interp, "Unable to empty ", dp->d_namep,
			     ", original restored\n", (char *)NULL);
	    restore_comb( dp );
d155 3
a157 7
	  if( build_comb( dp ) ){ /* Use comb_add() to rebuild combination */
	    Tcl_AppendResult(interp, "Unable to construct new ", dp->d_namep,
			     ", original restored\n", (char *)NULL);
	    restore_comb( dp );
	    (void)unlink( red_tmpfil );
	    return TCL_ERROR;
	  }else{ /* eliminate the temporary combination */
d171 58
d230 3
a232 2
writecomb( dp )
struct directory *dp;
d235 8
a242 3
	union record record;
	FILE *fp;
	int offset,i;
d252 17
a268 2
	/* Get combo info and write it to file */
	for( offset=1 ; offset< dp->d_len ; offset++ )
d270 2
a271 1
		if( db_get( dbip , dp , &record , offset , 1 ) )
d273 2
a274 3
		  fclose( fp );
		  Tcl_AppendResult(interp, "Cannot get combination information\n", (char *)NULL);
		  return( 1 );
d276 49
d326 3
a328 7
		if( record.u_id != ID_MEMB )
		{
		  Tcl_AppendResult(interp, "This combination appears to be corrupted\n",
				   (char *)NULL);
		  fclose( fp );
		  return( 1 );
		}
d330 17
a346 9
		for( i=0 ; i<ELEMENTS_PER_MAT ; i++ ){
		  if( record.M.m_mat[i] != identity[i] ){
		    Tcl_AppendResult(interp, "Member `", record.M.m_instname,
				     "` has been object edited\n",
				     "\tCombination must be `pushed` before editing\n",
				     (char *)NULL);
		    fclose( fp );
		    return( 1 );
		  }
d348 1
a348 2

		if( fprintf( fp , " %c %s\n" , record.M.m_relation , record.M.m_instname ) <= 0 )
d355 2
d368 1
d374 5
d384 1
a384 1
	  return(1);
d414 105
d520 1
a520 1
		relation = line[i];
a526 3
		/* Skip more white space */
		while( isspace( line[++i] ));

d528 2
a529 1
		strncpy( name , &line[i] , NAMESIZE );
a536 18
		/* Skip over name */
		while( !isspace( line[++i] ) && line[i] != '\0' );

		if( line[i] != '\0' )
		{
		  /* Look for junk on the tail end of the line */
		  while( isspace( line[++i] ) );
		  if( line[i] != '\0' )
		    {
		      /* found some junk */
		      Tcl_AppendResult(interp, "Error in format of edited file\n",
				       "Must be just one operator and object per line\n",
				       (char *)NULL);
		      fclose( fp );
		      return( 1 );
		    }
		}

d546 1
a546 1
		  return( 1 );
d555 1
a555 1
		  return( 1 );
d562 1
a562 1
		  return( 1 );
d564 1
d569 1
a569 1
	if( nonsubs == 0 )
d573 1
a573 42
	  return( 1 );
	}
	return( 0 );
}

/*
 *  Returns -
 *	0 if OK
 *	1 on failure
 */
int clear_comb( dp )
struct directory *dp;
{
	register int i;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;

	if( dp == DIR_NULL )
		return( 1 );

	if( (dp->d_flags & DIR_COMB) == 0 )  {
		Tcl_AppendResult(interp, "clear_comb: ", dp->d_namep,
			" is not a combination\n", (char *)NULL );
		return 1;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
		Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
			") failure", (char *)NULL );
		return 1;
	}
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB(comb);

	if( comb->tree )  {
		db_free_tree( comb->tree );
		comb->tree = NULL;
	}

	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
		Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
		return 1;
d575 1
a575 1
	return 0;
d578 2
a579 1
int build_comb( dp )
d581 2
d590 1
d592 1
d598 12
d618 24
a641 3
	/* Will need to know whether this is a region later */
	if( dp->d_flags == DIR_REGION )
		region = 1;
d643 1
a643 1
		region = 0;
d666 125
d792 1
a792 1
		relation = line[i];
a798 3
		/* Skip more white space */
		while( isspace( line[++i] ));

d800 2
a801 1
		strncpy( name , &line[i] , NAMESIZE );
d813 3
d819 32
d852 82
a933 1
		if( combadd( dp1 , dp->d_namep , region , relation , ident , air ) == DIR_NULL )
d935 3
a937 1
		  Tcl_AppendResult(interp, " Error in rebuilding combination\n", (char *)NULL);
d940 13
d996 2
a997 2
	register struct directory *dp;
	union record		*rp;
d1002 2
a1003 7
	/* Following code is lifted from "f_copy()" and slightly modified */
	if( (rp = db_getmrec( dbip, dpold )) == (union record *)0 )
	{
	  Tcl_AppendResult(interp, "Cannot save copy of ", dpold->d_namep,
			   ", no changes made\n", (char *)NULL);
	  return( 1 );
	}
d1013 1
a1013 3
	/* All objects have name in the same place */
	NAMEMOVE( red_tmpcomb, rp->c.c_name );
	if( db_put( dbip, dp, rp, 0, dpold->d_len ) < 0 )
d1015 3
a1017 3
	  Tcl_AppendResult(interp, "Cannot save copy of ", dp->d_namep,
			   ", no changes made\n", (char *)NULL);
	  return( 1 );
d1019 1
a1019 2

	bu_free( (genptr_t)rp, "record" );
@


11.13
log
@Eliminated use of db_delrec().
Much other noxious stuff remains.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.12 1997/01/29 01:50:24 mike Exp mike $ (BRL)";
d343 2
a344 2
	if( rt_get_comb( &intern, dp, (mat_t *)NULL, dbip ) < 0 )  {
		Tcl_AppendResult(interp, "rt_get_comb(", dp->d_namep,
@


11.12
log
@Used string of variable name rather than contents of variable.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.11 1996/10/04 15:06:14 bparker Exp mike $ (BRL)";
d322 5
d330 3
a333 3
	register int i, rec;
	union record record;

d337 5
a341 1
	/* Delete all the Member records, one at a time */
d343 7
a349 9
	rec = dp->d_len;
	for( i = 1; i < rec; i++ )
	{
		if( db_get( dbip,  dp, &record, 1 , 1) < 0 )
		{
		  Tcl_AppendResult(interp, "Unable to clear ", dp->d_namep,
				   "\n", (char *)NULL);
		  return( 1 );
		}
d351 3
a353 5
		if( db_delrec( dbip, dp, 1 ) < 0 )
		{
		  Tcl_AppendResult(interp, "Error in deleting member.\n", (char *)NULL);
		  return( 1 );
		}
d355 6
a360 1
	return( 0 );
@


11.11
log
@cast bu_free's 1st argument to genptr_t
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.10 1996/10/03 20:51:25 bparker Exp bparker $ (BRL)";
d130 1
a130 1
	    av[1] = "red_tmpcomb";
@


11.10
log
@get rid of extra cmdline() uses
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.9 1996/09/25 12:37:19 jra Exp bparker $ (BRL)";
d510 1
a510 1
	bu_free( (char *)rp, "record" );
@


11.9
log
@Added a bit of error checking to f_red().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.8 1996/09/03 20:02:37 bparker Exp jra $ (BRL)";
d127 1
a127 1
	    struct bu_vls	v;
d129 4
a132 8
	    bu_vls_init( &v );
	    bu_vls_strcat( &v, "kill " );
	    bu_vls_strcat( &v , red_tmpcomb );
	    bu_vls_strcat( &v , "\n" );

	    cmdline( &v, FALSE );

	    bu_vls_free( &v );
d514 1
d519 2
a520 16
/* restore a combination that was saved in "red_tmpcomb" */
	struct bu_vls	v;
	char name[NAMESIZE];

	/* Save name of original combo */
	strcpy( name , dp->d_namep );

	/* Kill original combination */
	bu_vls_init(&v);
	bu_vls_strcat( &v , "kill " );
	bu_vls_strcat( &v , dp->d_namep );
	bu_vls_strcat( &v , "\n" );

	cmdline( &v, FALSE );

	bu_vls_free( &v );
d522 2
a523 6
	/* Move temp to original */
	bu_vls_strcat( &v , "mv " );
	bu_vls_strcat( &v , red_tmpcomb );
	bu_vls_strcat( &v , " " );
	bu_vls_strcat( &v , name );
	bu_vls_strcat( &v , "\n" );
d525 9
a533 1
	cmdline( &v, FALSE );
d535 1
a535 1
	bu_vls_free( &v );
@


11.8
log
@rt_list ---> bu_list
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.7 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d175 1
d185 1
d190 7
a196 1
		fprintf( fp , " %c %s\n" , record.M.m_relation , record.M.m_instname );
@


11.7
log
@now using libbu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.6 1996/07/15 20:35:25 bparker Exp bparker $ (BRL)";
d35 1
@


11.6
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.5 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d126 1
a126 1
	    struct rt_vls	v;
d128 4
a131 4
	    rt_vls_init( &v );
	    rt_vls_strcat( &v, "kill " );
	    rt_vls_strcat( &v , red_tmpcomb );
	    rt_vls_strcat( &v , "\n" );
d135 1
a135 1
	    rt_vls_free( &v );
d279 1
a279 1
		  struct rt_vls tmp_vls;
d281 4
a284 4
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, " %c is not a legal operator\n" , relation );
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d505 1
a505 1
	rt_free( (char *)rp, "record" );
d514 1
a514 1
	struct rt_vls	v;
d521 4
a524 4
	rt_vls_init(&v);
	rt_vls_strcat( &v , "kill " );
	rt_vls_strcat( &v , dp->d_namep );
	rt_vls_strcat( &v , "\n" );
d528 1
a528 1
	rt_vls_free( &v );
d531 5
a535 5
	rt_vls_strcat( &v , "mv " );
	rt_vls_strcat( &v , red_tmpcomb );
	rt_vls_strcat( &v , " " );
	rt_vls_strcat( &v , name );
	rt_vls_strcat( &v , "\n" );
d539 1
a539 1
	rt_vls_free( &v );
@


11.5
log
@convert commands to Tcl
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.4 1996/03/01 19:29:08 bparker Exp bparker $ (BRL)";
a74 1
	  return TCL_ERROR;
@


11.4
log
@remove unused XMGED stuff
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.3 1995/07/25 17:49:38 gdurf Exp bparker $ (BRL)";
d54 3
a56 1
f_red( argc , argv )
d64 2
a65 5
	if( argc != 2 )
	{
		rt_log( "Usage:\n\tred object_name\n" );
		return CMD_BAD;
	}
d69 2
a70 2
		rt_log( " Cannot edit: %s\n" , argv[1] );
		return CMD_BAD;
d74 2
a75 2
		READ_ERR;
		return CMD_BAD;
d79 3
a81 2
		rt_log( " %s is not a combination, so cannot be edited this way\n", argv[1] );
		return CMD_BAD;
d95 3
a97 3
		rt_log( "Unable to edit %s\n" , argv[1] );
		unlink( red_tmpfil );
		return CMD_BAD;
d103 30
a132 34
		if( checkcomb() ) /* Do some quick checking on the edited file */
		{
			rt_log( "Error in edited region, no changes made\n" );
			(void)unlink( red_tmpfil );
			return CMD_BAD;
		}
		if( save_comb( dp ) )	/* Save combination to a temp name */
		{
			rt_log( "No changes made\n" );
			(void)unlink( red_tmpfil );
			return CMD_OK;
		}
		if( clear_comb( dp ) )	/* Empty this combination */
		{
			rt_log( "Unable to empty %s, original restored\n" , dp->d_namep );
			restore_comb( dp );
			(void)unlink( red_tmpfil );
			return CMD_BAD;
		}
		if( build_comb( dp ) )	/* Use comb_add() to rebuild combination */
		{
			rt_log( "Unable to construct new %s, original restored\n" , dp->d_namep );
			restore_comb( dp );
			(void)unlink( red_tmpfil );
			return CMD_BAD;
		}
		else			/* eliminate the temporary combination */
		{
			struct rt_vls	v;

			rt_vls_init( &v );
			rt_vls_strcat( &v, "kill " );
			rt_vls_strcat( &v , red_tmpcomb );
			rt_vls_strcat( &v , "\n" );
d134 1
a134 1
			cmdline( &v, FALSE );
d136 2
a137 2
			rt_vls_free( &v );
		}
d141 1
a141 1
	return CMD_OK;
d156 3
a158 3
		rt_log( "Cannot open create file for editing\n" );
		perror( "MGED" );
		return(1);
d166 3
a168 3
			fclose( fp );
			rt_log( "Cannot get combination information\n" );
			return( 1 );
d173 3
a175 2
			rt_log( "This combination appears to be corrupted\n" );
			return( 1 );
d178 8
a185 8
		for( i=0 ; i<ELEMENTS_PER_MAT ; i++ )
		{
			if( record.M.m_mat[i] != identity[i] )
			{
				rt_log( "Member `%s` has been object edited\n" , record.M.m_instname );
				rt_log( "\tCombination must be `pushed` before editing\n" );
				return( 1 );
			}
d208 3
a210 3
		rt_log( "Cannot open create file for editing\n" );
		perror( "MGED" );
		return(1);
d230 2
a231 2
			rt_log( "Line too long in edited file\n" );
			return( 1 );
d265 11
a275 10
			/* Look for junk on the tail end of the line */
			while( isspace( line[++i] ) );
			if( line[i] != '\0' )
			{
				/* found some junk */
				rt_log( "Error in format of edited file\n" );
				rt_log( "Must be just one operator and object per line\n" );
				fclose( fp );
				return( 1 );
			}
d280 8
a287 3
			rt_log( " %c is not a legal operator\n" , relation );
			fclose( fp );
			return( 1 );
d294 3
a296 3
			rt_log( " operand name missing\n" );
			fclose( fp );
			return( 1 );
d301 3
a303 3
			rt_log( " %s does not exist\n" , name );
			fclose( fp );
			return( 1 );
d311 3
a313 2
		rt_log( "Cannot create a combination with all subtraction operators\n" );
		return( 1 );
d335 3
a337 2
			rt_log( "Unable to clear %s\n" , dp->d_namep );
			return( 1 );
d342 2
a343 2
			rt_log("Error in deleting member.\n");
			return( 1 );
d367 3
a369 2
		rt_log( " Cannot open edited file: %s\n" , red_tmpfil );
		return( 1 );
d422 2
a423 2
			rt_log( " %s does not exist\n" , name );
			return( 1 );
d429 2
a430 2
			rt_log( " Error in rebuilding combination\n" );
			return( 1 );
d484 3
a486 2
		rt_log( "Cannot save copy of %s, no changes made\n" , dpold->d_namep );
		return( 1 );
d492 3
a494 2
		rt_log( "Cannot save copy of %s, no changes made\n" , dp->d_namep );
		return( 1 );
d501 3
a503 2
		rt_log( "Cannot save copy of %s, no changes made\n" , dp->d_namep );
		return( 1 );
@


11.3
log
@2-arg cmdline()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 11.2 1995/01/17 13:04:58 bparker Exp gdurf $ (BRL)";
d222 1
a222 3
#ifdef XMGED
		while( (ch=mged_fgetc( fp )) != EOF && ch != '\n' && i<MAXLINE )
#else
a223 1
#endif
d377 1
a377 3
#ifdef XMGED
		while( (ch=mged_fgetc( fp )) != EOF && ch != '\n' && i<MAXLINE )
#else
a378 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/red.c,v 11.2 95/01/17 11:44:18 bparker Exp $ (BRL)";
d137 3
a139 5
#ifdef XMGED
			cmdline( &v, False );
#else
			cmdline( &v );
#endif
d523 3
a525 5
#ifdef Xmged
	cmdline( &v, False );
#else
	cmdline( &v );
#endif
d534 3
a536 5
#ifdef XMGED
	cmdline( &v, False );
#else
	cmdline( &v );
#endif
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.10 94/12/16 19:37:14 gdurf Exp $ (BRL)";
d137 3
d141 1
d224 3
d228 1
d382 3
d386 1
d525 3
d529 1
d538 3
a540 1

d542 1
@


1.10
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.9 1994/11/10 12:06:14 jra Exp gdurf $ (BRL)";
@


1.9
log
@Irix 6.0.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/red.c,v 1.8 1994/10/18 00:22:32 mike Exp jra $ (BRL)";
d64 1
a64 1
		(void)printf( "Usage:\n\tred object_name\n" );
d70 1
a70 1
		(void)printf( " Cannot edit: %s\n" , argv[1] );
d80 1
a80 1
		(void)printf( " %s is not a combination, so cannot be edited this way\n", argv[1] );
d95 1
a95 1
		(void)printf( "Unable to edit %s\n" , argv[1] );
d105 1
a105 1
			(void)printf( "Error in edited region, no changes made\n" );
d111 1
a111 1
			(void)printf( "No changes made\n" );
d117 1
a117 1
			(void)printf( "Unable to empty %s, original restored\n" , dp->d_namep );
d124 1
a124 1
			(void)printf( "Unable to construct new %s, original restored\n" , dp->d_namep );
d158 1
a158 1
		(void)printf( "Cannot open create file for editing\n" );
d169 1
a169 1
			(void)printf( "Cannot get combination information\n" );
d175 1
a175 1
			(void)printf( "This combination appears to be corrupted\n" );
d183 2
a184 2
				(void)printf( "Member `%s` has been object edited\n" , record.M.m_instname );
				(void)printf( "\tCombination must be `pushed` before editing\n" );
d209 1
a209 1
		(void)printf( "Cannot open create file for editing\n" );
d230 1
a230 1
			(void)printf( "Line too long in edited file\n" );
d270 2
a271 2
				(void)printf( "Error in format of edited file\n" );
				(void)printf( "Must be just one operator and object per line\n" );
d279 1
a279 1
			(void)printf( " %c is not a legal operator\n" , relation );
d288 1
a288 1
			(void)printf( " operand name missing\n" );
d295 1
a295 1
			(void)printf( " %s does not exist\n" , name );
d305 1
a305 1
		(void)printf( "Cannot create a combination with all subtraction operators\n" );
d328 1
a328 1
			(void)printf( "Unable to clear %s\n" , dp->d_namep );
d334 1
a334 1
			(void)printf("Error in deleting member.\n");
d359 1
a359 1
		(void)printf( " Cannot open edited file: %s\n" , red_tmpfil );
d412 1
a412 1
			(void)printf( " %s does not exist\n" , name );
d419 1
a419 1
			(void)printf( " Error in rebuilding combination\n" );
d474 1
a474 1
		(void)printf( "Cannot save copy of %s, no changes made\n" , dpold->d_namep );
d481 1
a481 1
		(void)printf( "Cannot save copy of %s, no changes made\n" , dp->d_namep );
d489 1
a489 1
		(void)printf( "Cannot save copy of %s, no changes made\n" , dp->d_namep );
@


1.8
log
@Solaris detected a legitimate bug.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.7 94/08/25 13:01:28 gdurf Exp Locker: mike $ (BRL)";
a152 1
	mat_t matrix;
a205 1
	struct directory *dp;
d293 1
a293 1
		if( (dp=db_lookup( dbip , name , LOOKUP_NOISY )) == DIR_NULL )
d355 1
a355 1
	struct directory *dp1,*dp2;
d417 1
a417 1
		if( (dp2=combadd( dp1 , dp->d_namep , region , relation , ident , air ) ) == DIR_NULL )
a433 1
	struct directory *dp;
d453 1
a453 1
		if( (dp=db_lookup( dbip , str , LOOKUP_QUIET )) == DIR_NULL )
@


1.7
log
@Fixed include ordering
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.6 1994/08/09 18:27:54 gdurf Exp gdurf $ (BRL)";
d477 1
a477 1
		(void)printf( "Cannot save copy of %s, no changes made\n" , dp->d_namep );
@


1.6
log
@Factored ifdefs
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.5 1994/07/11 20:48:09 gdurf Exp gdurf $ (BRL)";
d27 7
a41 7
#ifdef USE_STRING_H
#	include <string.h>
#else
#	include <strings.h>
#endif

extern int errno;
@


1.5
log
@Fixed missing return code
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.4 1994/06/13 19:01:23 gdurf Exp gdurf $ (BRL)";
d23 1
d35 2
a36 2
#ifdef SYSV
# include <string.h>
d38 1
a38 1
# include <strings.h>
@


1.4
log
@Corrected void return from function returning int
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.3 1994/06/01 17:16:28 gdurf Exp gdurf $ (BRL)";
d75 1
a75 1
		return;
@


1.3
log
@Converted f_red to use new command return codes.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.2 1993/04/30 18:54:51 mike Exp gdurf $ (BRL)";
d73 4
a76 1
	if( db_get( dbip , dp , &record , 0 , 1 ) < 0 ) READ_ERR_return;
@


1.2
log
@cmdline() interface expects an rt_vls now.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/red.c,v 1.1 92/05/04 14:12:20 mike Exp Locker: mike $ (BRL)";
d52 1
a52 1
void
d64 1
a64 1
		return;
d70 1
a70 1
		return;
d77 1
a77 1
		return;
d93 1
a93 1
		return;
d103 1
a103 1
			return;
d109 1
a109 1
			return;
d116 1
a116 1
			return;
d123 1
a123 1
			return;
d139 1
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d127 1
a127 1
			char linebuf[NAMESIZE + 7];
d129 6
a134 4
			strcpy( linebuf , "kill " );
			strcat( linebuf , red_tmpcomb );
			strcat( linebuf , "\n" );
			cmdline( linebuf );
d500 1
a500 2

	char linebuf[2*NAMESIZE + 8];
d507 6
a512 4
	strcpy( linebuf , "kill " );
	strcat( linebuf , dp->d_namep );
	strcat( linebuf , "\n" );
	cmdline( linebuf );
d515 5
a519 5
	strcpy( linebuf , "mv " );
	strcat( linebuf , red_tmpcomb );
	strcat( linebuf , " " );
	strcat( linebuf , name );
	strcat( linebuf , "\n" );
d521 2
a522 1
	cmdline( linebuf );
@
