head	11.30;
access;
symbols
	ansi-20040405-merged:11.26.2.2
	postmerge-20040405-ansi:11.28
	premerge-20040404-ansi:11.27
	postmerge-autoconf:11.27
	autoconf-freeze:11.26.10.2
	premerge-autoconf:11.27
	postmerge-20040315-windows:11.27
	premerge-20040315-windows:11.27
	windows-20040315-freeze:11.26.4.1
	autoconf-20031203:11.26
	autoconf-20031202:11.26
	autoconf-branch:11.26.0.10
	phong-branch:11.26.0.8
	photonmap-branch:11.26.0.6
	rel-6-1-DP:11.26
	windows-branch:11.26.0.4
	rel-6-0-2:11.24
	ansi-branch:11.26.0.2
	rel-6-0-1-branch:11.24.0.2
	hartley-6-0-post:11.25
	hartley-6-0-pre:11.24
	rel-6-0-1:11.24
	rel-6-0:11.24
	rel-5-4:11.19
	offsite-5-3-pre:11.20
	rel-5-3:11.19
	rel-5-2:11.19
	rel-5-1-branch:11.19.0.2
	rel-5-1:11.19
	rel-5-0:11.19
	rel-5-0-beta:11.19
	rel-4-5:11.18
	ctj-4-5-post:11.15
	ctj-4-5-pre:11.15
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.30
date	2004.05.21.17.47.52;	author morrison;	state dead;
branches;
next	11.29;

11.29
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.28;

11.28
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2004.02.02.17.39.36;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2002.08.20.17.08.26;	author jra;	state Exp;
branches
	11.26.2.1
	11.26.4.1
	11.26.10.1;
next	11.25;

11.25
date	2002.08.15.20.55.39;	author hartley;	state Exp;
branches;
next	11.24;

11.24
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	2001.06.01.19.23.26;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	2001.04.02.18.10.11;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2000.08.19.03.10.19;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	98.11.06.22.32.44;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.12.23.09.45.05;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	97.09.08.18.48.35;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.05.22.18.59.23;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.05.20.23.05.40;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	97.01.07.05.06.29;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.09.23.18.18.52;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	95.08.24.05.31.07;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.07.25.17.50.18;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	95.07.05.21.22.49;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.31;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.50;	author mike;	state Rel4_4;
branches;
next	1.11;

1.11
date	94.12.16.19.37.39;	author gdurf;	state Exp;
branches;
next	1.10;

1.10
date	94.08.24.19.08.29;	author gdurf;	state Exp;
branches;
next	1.9;

1.9
date	94.06.01.17.14.01;	author gdurf;	state Exp;
branches;
next	1.8;

1.8
date	92.11.11.00.36.49;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	92.09.03.19.19.04;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	92.08.19.15.52.03;	author gdurf;	state Exp;
branches;
next	1.5;

1.5
date	92.08.04.18.33.44;	author gdurf;	state Exp;
branches;
next	1.4;

1.4
date	92.06.05.15.19.51;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	92.04.18.02.45.21;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	92.04.16.23.36.14;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	92.04.16.04.02.07;	author mike;	state Exp;
branches;
next	;

11.26.2.1
date	2002.09.19.18.02.07;	author morrison;	state Exp;
branches;
next	11.26.2.2;

11.26.2.2
date	2004.03.17.21.22.05;	author morrison;	state Exp;
branches;
next	;

11.26.4.1
date	2004.03.11.23.46.37;	author morrison;	state Exp;
branches;
next	;

11.26.10.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	11.26.10.2;

11.26.10.2
date	2004.03.15.14.07.42;	author erikg;	state Exp;
branches;
next	;


desc
@Virtual Reality linkage
@


11.30
log
@moved to src/mged/
@
text
@/*
 *			V R L I N K . C
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1992-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/vrlink.c,v 11.29 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>

#include "tcl.h"

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"
#include "pkg.h"
#include "./ged.h"
#include "./mged_dm.h"

extern int		(*cmdline_hook)();	/* cmd.c */

#if 0
extern point_t		eye_pos_scr;		/* dozoom.c */
#endif

static struct pkg_conn	*vrmgr;			/* PKG connection to VR mgr */
static char		*vr_host = "None";	/* host running VR mgr */
static char		*tcp_port = "5555";	/* "gedd", remote mged */

#define VRMSG_ROLE	1	/* from MGED: Identify role of machine */
#define VRMSG_CMD	2	/* to MGED: Command to process */
#define VRMSG_EVENT	3	/* from MGED: device event */
#define VRMSG_POV	4	/* from MGED: point of view info */
#define VRMSG_VLIST	5	/* transfer binary vlist block */
#define VRMSG_CMD_REPLY	6	/* from MGED: reply to VRMSG_CMD */

void	ph_cmd(register struct pkg_conn *pc, char *buf);
void	ph_vlist(register struct pkg_conn *pc, unsigned char *buf);
static struct pkg_switch pkgswitch[] = {
	{ VRMSG_CMD,		ph_cmd,		"Command" },
	{ VRMSG_VLIST,		ph_vlist,	"Import vlist" },
	{ 0,			0,		(char *)0 }
};

#if 0
/*
 *			P K G _ S E N D _ V L S
 */
int
pkg_send_vls( type, vp, pc )
int		type;
struct bu_vls	*vp;
struct pkg_conn	*pc;
{
	BU_CK_VLS(vp);
	if(!pc)  {
		bu_log("pkg_send_vls:  NULL pointer\n");
		return -1;
	}
	return pkg_send( type, bu_vls_addr(vp), bu_vls_strlen(vp)+1, pc );
}
#endif

/*
 *  Called from cmdline() for now.
 *  Returns -
 *	!0	Print prompt for user.  Should always be this.
 *	 0	Don't print a prompt
 */
int
vr_event_hook(struct bu_vls *vp)
{
	BU_CK_VLS(vp);

	if( vrmgr == PKC_NULL )  {
		cmdline_hook = 0;	/* Relinquish this hook */
		return 1;
	}

	if( pkg_send_vls( VRMSG_EVENT, vp, vrmgr ) < 0 )  {
		bu_log("event: pkg_send VRMSG_EVENT failed, disconnecting\n");
		pkg_close(vrmgr);
		vrmgr = PKC_NULL;
		cmdline_hook = 0;	/* Relinquish this hook */
	}
	return 1;
}

/*
 *  Called from the Tk event handler
 */
void
vr_input_hook(void)
{
	int	val;

	val = pkg_suckin(vrmgr);
	if( val < 0 ) {
		bu_log("pkg_suckin() error\n");
	} else if( val == 0 )  {
		bu_log("vrmgr sent us an EOF\n");
	}
	if( val <= 0 )  {
		Tcl_DeleteFileHandler(vrmgr->pkc_fd);
		pkg_close(vrmgr);
		vrmgr = PKC_NULL;
		return;
	}
	if( pkg_process( vrmgr ) < 0 )
		bu_log("vrmgr:  pkg_process error encountered\n");
}

/*
 *  Called from ged.c refresh().
 */
void
vr_viewpoint_hook(void)
{
	struct bu_vls	str;
	static struct bu_vls	old_str;
	quat_t		orient;

	if( vrmgr == PKC_NULL )  {
		cmdline_hook = 0;	/* Relinquish this hook */
		return;
	}

	bu_vls_init_if_uninit(&old_str);
	bu_vls_init(&str);

	quat_mat2quat(orient, view_state->vs_vop->vo_rotation);

	/* Need to send current viewpoint to VR mgr */
	/* XXX more will be needed */
	/* Eye point, quaturnion for orientation */
	bu_vls_printf(&str, "pov {%e %e %e}   {%e %e %e %e}   %e   {%e %e %e}  %e\n", 
		      -view_state->vs_vop->vo_center[MDX],
		      -view_state->vs_vop->vo_center[MDY],
		      -view_state->vs_vop->vo_center[MDZ],
		      V4ARGS(orient),
		      view_state->vs_vop->vo_scale,
		      V3ARGS(view_state->vs_vop->vo_eye_pos),
		      view_state->vs_vop->vo_perspective);

	if( strcmp( bu_vls_addr(&old_str), bu_vls_addr(&str) ) == 0 )  {
		bu_vls_free( &str );
		return;
	}

	if( pkg_send_vls( VRMSG_POV, &str, vrmgr ) < 0 )  {
		bu_log("viewpoint: pkg_send VRMSG_POV failed, disconnecting\n");
		pkg_close(vrmgr);
		vrmgr = PKC_NULL;
		viewpoint_hook = 0;	/* Relinquish this hook */
	}
	bu_vls_trunc( &old_str, 0 );
	bu_vls_vlscat( &old_str, &str );
	bu_vls_free( &str );
}

/*
 *			F _ P O V
 *
 *  Process the "pov" command generated above.
 *  XXX this should move to chgview.c when finished.
 */
int
cmd_pov(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		*argv[])
{
	int	ret;

	if ((ret = vo_pov_cmd(view_state->vs_vop, interp, argc, argv)) != TCL_OK)
		return ret;

	mged_variables->mv_perspective = view_state->vs_vop->vo_perspective;
	return TCL_OK;
}

/*
 *			F _ V R M G R
 *
 *  Establish a network link to the VR manager, using libpkg.
 *
 *  Syntax:  vrmgr host role
 */
int
f_vrmgr(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls	str;
	char		*role;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help vrmgr");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init(&str);

	if( vrmgr != PKC_NULL )  {
	  Tcl_AppendResult(interp, "Closing link to VRmgr ",
			   vr_host, "\n", (char *)NULL);
		pkg_close( vrmgr );
		vrmgr = PKC_NULL;
		vr_host = "none";
	}

	vr_host = bu_strdup(argv[1]);
	role = argv[2];

	if( strcmp( role, "master" ) == 0 )  {
	} else if( strcmp( role, "slave" ) == 0 )  {
	} else if( strcmp( role, "overview" ) == 0 )  {
	} else {
	   Tcl_AppendResult(interp, "role '", role, "' unknown, must be master/slave/overview\n",
			    (char *)NULL);
	   return TCL_ERROR;
	}

	vrmgr = pkg_open( vr_host, tcp_port, "tcp", "", "",
		pkgswitch, NULL );
	if( vrmgr == PKC_ERROR )  {
	  Tcl_AppendResult(interp, "mged/f_vrmgr: unable to contact ", vr_host,
			   ", port ", tcp_port, "\n", (char *)NULL);
	  vrmgr = PKC_NULL;
	  return TCL_ERROR;
	}

	bu_vls_from_argv( &str, argc-2, argv+2 );

	/* Send initial message declaring our role */
	if( pkg_send_vls( VRMSG_ROLE, &str, vrmgr ) < 0 )  {
	  Tcl_AppendResult(interp, "pkg_send VRMSG_ROLE failed, disconnecting\n", (char *)NULL);
	  pkg_close(vrmgr);
	  vrmgr = NULL;
	  return TCL_ERROR;
	}

	/* Establish appropriate hooks */
	if( strcmp( role, "master" ) == 0 )  {
		viewpoint_hook = vr_viewpoint_hook;
	} else if( strcmp( role, "slave" ) == 0 )  {
		cmdline_hook = vr_event_hook;
	} else if( strcmp( role, "overview" ) == 0 )  {
		/* No hooks required, just listen */
	}
	Tcl_CreateFileHandler(vrmgr->pkc_fd, TCL_READABLE,
			     (Tcl_FileProc (*))vr_input_hook, (ClientData)NULL);
	bu_vls_free( &str );

	return TCL_OK;
}

/*
 *			P H _ C M D
 *
 *  Package handler for incomming commands.  Do whatever he says,
 *  and send a reply back.
 */
void
ph_cmd(register struct pkg_conn *pc, char *buf)
{
	int		status;

	status = Tcl_Eval(interp, buf);

	if( pkg_2send( VRMSG_CMD_REPLY,
		(status == TCL_OK) ? "Y" : "N", 1,
		interp->result, strlen(interp->result)+1, pc ) < 0 )  {
		bu_log("ph_cmd: pkg_2send reply to vrmgr failed, disconnecting\n");
		pkg_close(vrmgr);
		vrmgr = PKC_NULL;
		cmdline_hook = 0;	/* Relinquish this hook */
	}
	if(buf) (void)free(buf);
}

/*
 *			P H _ V L I S T
 *
 *  Package handler for incomming vlist.
 *  Install whatever phantom solids he wants.
 */
void
ph_vlist(register struct pkg_conn *pc, unsigned char *buf)
{
	struct bu_list	vhead;
	struct bu_vls	name;

	bu_vls_init(&name);

	BU_LIST_INIT( &vhead );

	rt_vlist_import( &vhead, &name, buf );

	invent_solid( bu_vls_addr(&name), &vhead, 0x0000FF00L, 0 );

	bu_vls_free( &name );
	if(buf) (void)free(buf);
}
@


11.29
log
@change conf.h to a wrapped config.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/vrlink.c,v 11.28 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.28
log
@merge of ansi-6-0-branch into HEAD
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d20 5
a24 1
#include "conf.h"
@


11.27
log
@update copyright to include span through 2003
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.26 2002/08/20 17:08:26 jra Exp $ (BRL)";
d59 2
a60 2
void	ph_cmd();
void	ph_vlist();
d93 1
a93 2
vr_event_hook(vp)
struct bu_vls	*vp;
d115 1
a115 1
vr_input_hook()
d139 1
a139 1
vr_viewpoint_hook()
d212 1
a212 5
f_vrmgr(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d290 1
a290 3
ph_cmd(pc, buf)
register struct pkg_conn *pc;
char			*buf;
d314 1
a314 3
ph_vlist(pc, buf)
register struct pkg_conn *pc;
unsigned char		*buf;
@


11.26
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1992 by the United States Army.
d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.24 2001/06/05 15:51:42 bparker Exp $ (BRL)";
@


11.26.4.1
log
@sync to HEAD...
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/vrlink.c,v 11.27 2004/02/02 17:39:36 morrison Exp $ (BRL)";
@


11.26.10.1
log
@merge from HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.27 2004/02/02 17:39:36 morrison Exp $ (BRL)";
@


11.26.10.2
log
@merge from head
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.26.10.1 2004/02/12 18:34:16 erikg Exp $ (BRL)";
@


11.26.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.26 2002/08/20 17:08:26 jra Exp $ (BRL)";
d59 2
a60 2
void	ph_cmd(register struct pkg_conn *pc, char *buf);
void	ph_vlist(register struct pkg_conn *pc, unsigned char *buf);
d93 2
a94 1
vr_event_hook(struct bu_vls *vp)
d116 1
a116 1
vr_input_hook(void)
d140 1
a140 1
vr_viewpoint_hook(void)
d213 5
a217 1
f_vrmgr(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d295 3
a297 1
ph_cmd(register struct pkg_conn *pc, char *buf)
d321 3
a323 1
ph_vlist(register struct pkg_conn *pc, unsigned char *buf)
@


11.26.2.2
log
@sync branch with HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.25
log
@Converted from K&R to ANSI C - RFH
@
text
@d59 2
a60 2
void	ph_cmd(register struct pkg_conn *pc, char *buf);
void	ph_vlist(register struct pkg_conn *pc, unsigned char *buf);
d93 2
a94 1
vr_event_hook(struct bu_vls *vp)
d116 1
a116 1
vr_input_hook(void)
d140 1
a140 1
vr_viewpoint_hook(void)
d213 5
a217 1
f_vrmgr(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d295 3
a297 1
ph_cmd(register struct pkg_conn *pc, char *buf)
d321 3
a323 1
ph_vlist(register struct pkg_conn *pc, unsigned char *buf)
@


11.24
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.23 2001/06/01 19:23:26 bparker Exp $ (BRL)";
d59 2
a60 2
void	ph_cmd();
void	ph_vlist();
d93 1
a93 2
vr_event_hook(vp)
struct bu_vls	*vp;
d115 1
a115 1
vr_input_hook()
d139 1
a139 1
vr_viewpoint_hook()
d212 1
a212 5
f_vrmgr(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d290 1
a290 3
ph_cmd(pc, buf)
register struct pkg_conn *pc;
char			*buf;
d314 1
a314 3
ph_vlist(pc, buf)
register struct pkg_conn *pc;
unsigned char		*buf;
@


11.23
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.22 2001/04/02 21:20:40 bparker Exp $ (BRL)";
d44 1
d46 1
a153 1
#ifdef MGED_USE_VIEW_OBJ
a154 3
#else
	quat_mat2quat( orient, view_state->vs_Viewrot );
#endif
d159 1
a159 2
#ifdef MGED_USE_VIEW_OBJ
	bu_vls_printf(&str, "pov %e %e %e   %e %e %e %e   %e   %e %e %e  %e\n", 
d165 2
a166 13
		      V3ARGS(eye_pos_scr),
		      mged_variables->mv_perspective);
#else
	bu_vls_printf( &str, "pov %e %e %e   %e %e %e %e   %e   %e %e %e  %e\n", 
		-view_state->vs_toViewcenter[MDX],
		-view_state->vs_toViewcenter[MDY],
		-view_state->vs_toViewcenter[MDZ],
		V4ARGS(orient),
		view_state->vs_Viewscale,
		V3ARGS(eye_pos_scr),
		mged_variables->mv_perspective
		);
#endif
d191 4
a194 5
f_pov(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d196 1
a196 4
	quat_t		orient;

	if(argc < 8){
	  struct bu_vls vls;
d198 2
a199 43
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help pov");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( argc < 1+3+4+1+3+1 )  {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "pov: insufficient args, only got %d\n", argc);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  return TCL_ERROR;
	}

#ifdef MGED_USE_VIEW_OBJ
	view_state->vs_vop->vo_center[MDX] = -atof(argv[1]);
	view_state->vs_vop->vo_center[MDY] = -atof(argv[2]);
	view_state->vs_vop->vo_center[MDZ] = -atof(argv[3]);
	orient[0] = atof(argv[4]);
	orient[1] = atof(argv[5]);
	orient[2] = atof(argv[6]);
	orient[3] = atof(argv[7]);
	quat_quat2mat(view_state->vs_vop->vo_rotation, orient);
	view_state->vs_vop->vo_scale = atof(argv[8]);
#else
	view_state->vs_toViewcenter[MDX] = -atof(argv[1]);
	view_state->vs_toViewcenter[MDY] = -atof(argv[2]);
	view_state->vs_toViewcenter[MDZ] = -atof(argv[3]);
	orient[0] = atof(argv[4]);
	orient[1] = atof(argv[5]);
	orient[2] = atof(argv[6]);
	orient[3] = atof(argv[7]);
	quat_quat2mat( view_state->vs_Viewrot, orient );
	view_state->vs_Viewscale = atof(argv[8]);
#endif
	eye_pos_scr[X] = atof(argv[9]);		/* interpreted in dozoom.c */
	eye_pos_scr[Y] = atof(argv[10]);
	eye_pos_scr[Z] = atof(argv[11]);
	mged_variables->mv_perspective = atof(argv[12]);
	new_mats();
d201 1
@


11.22
log
@*- remove Tk dependencies
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.21 2001/04/02 18:10:11 jra Exp $ (BRL)";
d152 3
d156 1
d161 10
d180 1
d233 11
d253 1
@


11.21
log
@Lint
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.20 2000/08/19 03:10:19 mike Exp $ (BRL)";
a25 1
#include "tk.h"
d125 1
a125 1
		Tk_DeleteFileHandler(vrmgr->pkc_fd);
d312 2
a313 2
	Tk_CreateFileHandler(vrmgr->pkc_fd, TK_READABLE,
			     (Tk_FileProc (*))vr_input_hook, (ClientData)NULL);
@


11.20
log
@
Reduced use of MAXARGS
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.19 1998/11/06 22:32:44 bparker Exp $ (BRL)";
d27 6
@


11.19
log
@*- use new structures
*- cleanup
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/vrlink.c,v 11.18 1997/12/23 09:45:05 mike Exp $ (BRL)";
d193 1
a193 1
	if(argc < 8 || MAXARGS < argc){
d248 1
a248 1
	if(argc < 3 || MAXARGS < argc){
@


11.18
log
@Added support to send back the results of a Tcl command
sent to MGED via the vrmgr link.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.17 1997/09/08 18:48:35 bparker Exp mike $ (BRL)";
d147 1
a147 1
	quat_mat2quat( orient, Viewrot );
d153 3
a155 3
		-toViewcenter[MDX],
		-toViewcenter[MDY],
		-toViewcenter[MDZ],
d157 1
a157 1
		Viewscale,
d159 1
a159 1
		mged_variables->perspective
d213 3
a215 3
	toViewcenter[MDX] = -atof(argv[1]);
	toViewcenter[MDY] = -atof(argv[2]);
	toViewcenter[MDZ] = -atof(argv[3]);
d220 2
a221 2
	quat_quat2mat( Viewrot, orient );
	Viewscale = atof(argv[8]);
d225 1
a225 1
	mged_variables->perspective = atof(argv[12]);
@


11.17
log
@mged_variables is now a pointer
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.16 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d50 1
d317 2
a318 1
 *  Package handler for incomming commands.  Do whatever he says.
d325 1
a325 1
	struct bu_vls	str;
d327 1
a327 1
	bu_vls_init(&str);
d329 8
a336 5
	bu_vls_strcpy( &str, buf );

	(void)cmdline( &str, FALSE );

	bu_vls_free( &str );
@


11.16
log
@mods to run without a database
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.15 1997/05/22 18:59:23 mike Exp bparker $ (BRL)";
d158 1
a158 1
		mged_variables.perspective
d224 1
a224 1
	mged_variables.perspective = atof(argv[12]);
@


11.15
log
@Improved robustitude.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.14 1997/05/20 23:05:40 mike Exp mike $ (BRL)";
d59 1
d76 1
@


11.14
log
@externs.h before raytrace.h
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.13 1997/04/24 18:03:58 bparker Exp mike $ (BRL)";
d69 4
d135 5
@


11.13
log
@modify calls to Tcl_Eval
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.12 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d29 1
a32 1
#include "externs.h"
@


11.12
log
@mods so that commands check args internally
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.11 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d182 6
a187 1
	  Tcl_Eval(interp, "help pov");
d237 6
a242 1
	  Tcl_Eval(interp, "help vrmgr");
@


11.11
log
@checkin for weekend
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.10 1997/01/07 05:06:29 mike Exp bparker $ (BRL)";
d181 2
a182 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d184 1
d231 2
a232 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d234 1
@


11.10
log
@Added "diffing" of pov strings; only send if different.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.9 1996/09/23 18:18:52 bparker Exp mike $ (BRL)";
a37 1
extern void		(*viewpoint_hook)();	/* ged.c */
@


11.9
log
@changed dm.h to mged_dm.h
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.8 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d130 1
d133 1
d151 5
d162 2
@


11.8
log
@rt_list ---> bu_list
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.7 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d35 1
a35 1
#include "./dm.h"
@


11.7
log
@now using libbu
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.6 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d30 1
a30 1
#include "rtstring.h"
d313 1
a313 1
	struct rt_list	vhead;
d318 1
a318 1
	RT_LIST_INIT( &vhead );
@


11.6
log
@convert commands to Tcl
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.5 1995/08/24 05:31:07 mike Exp bparker $ (BRL)";
d66 1
a66 1
struct rt_vls	*vp;
d69 2
a70 2
	RT_VLS_CHECK(vp);
	return pkg_send( type, rt_vls_addr(vp), rt_vls_strlen(vp)+1, pc );
d81 1
a81 1
struct rt_vls	*vp;
d83 1
a83 1
	RT_VLS_CHECK(vp);
d91 1
a91 1
		rt_log("event: pkg_send VRMSG_EVENT failed, disconnecting\n");
d109 1
a109 1
		rt_log("pkg_suckin() error\n");
d111 1
a111 1
		rt_log("vrmgr sent us an EOF\n");
d120 1
a120 1
		rt_log("vrmgr:  pkg_process error encountered\n");
d129 1
a129 1
	struct rt_vls	str;
d132 1
a132 1
	rt_vls_init(&str);
d139 1
a139 1
	rt_vls_printf( &str, "pov %e %e %e   %e %e %e %e   %e   %e %e %e  %e\n", 
d150 1
a150 1
		rt_log("viewpoint: pkg_send VRMSG_POV failed, disconnecting\n");
d155 1
a155 1
	rt_vls_free( &str );
d177 1
a177 1
	  struct rt_vls tmp_vls;
d179 4
a182 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "pov: insufficient args, only got %d\n", argc);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d218 1
a218 1
	struct rt_vls	str;
d224 1
a224 1
	rt_vls_init(&str);
d234 1
a234 1
	vr_host = rt_strdup(argv[1]);
d255 1
a255 1
	rt_vls_from_argv( &str, argc-2, argv+2 );
d275 1
a275 1
	rt_vls_free( &str );
d290 1
a290 1
	struct rt_vls	str;
d292 1
a292 1
	rt_vls_init(&str);
d294 1
a294 1
	rt_vls_strcpy( &str, buf );
d298 1
a298 1
	rt_vls_free( &str );
d314 1
a314 1
	struct rt_vls	name;
d316 1
a316 1
	rt_vls_init(&name);
d322 1
a322 1
	invent_solid( rt_vls_addr(&name), &vhead, 0x0000FF00L, 0 );
d324 1
a324 1
	rt_vls_free( &name );
@


11.5
log
@Send current perspective as well.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.4 1995/07/25 17:50:18 gdurf Exp mike $ (BRL)";
d165 3
a167 1
f_pov( argc, argv )
d173 3
d177 7
a183 2
		rt_log("pov: insufficient args, only got %d\n", argc);
		return CMD_BAD;
d185 1
d201 1
a201 1
	return CMD_OK;
d212 3
a214 1
f_vrmgr( argc, argv )
d221 3
d227 2
a228 1
		rt_log("Closing link to VRmgr %s\n", vr_host);
d241 3
a243 2
		rt_log("role '%s' unknown, must be master/slave/overview\n", role);
		return CMD_BAD;
d249 4
a252 4
		rt_log( "mged/f_vrmgr: unable to contact %s, port %s\n",
			vr_host, tcp_port);
		vrmgr = PKC_NULL;
		return CMD_BAD;
d259 4
a262 4
		rt_log("pkg_send VRMSG_ROLE failed, disconnecting\n");
		pkg_close(vrmgr);
		vrmgr = NULL;
		return CMD_BAD;
d277 1
a277 1
	return CMD_OK;
@


11.4
log
@2-arg cmdline().
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.3 1995/07/05 21:22:49 gdurf Exp gdurf $ (BRL)";
d139 1
a139 1
	rt_vls_printf( &str, "pov %e %e %e   %e %e %e %e   %e   %e %e %e\n", 
d145 3
a147 1
		V3ARGS(eye_pos_scr) );
d171 2
a172 2
	if( argc < 1+3+4+1+3 )  {
		rt_log("pov: insufficient args\n");
d187 1
@


11.3
log
@Tk changes
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 11.2 1995/01/17 13:05:31 bparker Exp gdurf $ (BRL)";
d275 1
a275 5
#ifdef XMGED
	(void)cmdline( &str, False );
#else
	(void)cmdline( &str );
#endif
@


11.2
log
@merging xmged sources
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/vrlink.c,v 11.2 95/01/17 11:44:55 bparker Exp $ (BRL)";
d25 3
a38 2
extern void		(*extrapoll_hook)();	/* ged.c */
extern int		extrapoll_fd;
d100 1
a100 1
 *  Called from ged.c event_check().
d114 1
a116 2
		extrapoll_fd = 0;
		extrapoll_hook = NULL;	/* Relinquish this hook */
d252 2
a253 2
	extrapoll_fd = vrmgr->pkc_fd;
	extrapoll_hook = vr_input_hook;
@


11.1
log
@Release_4.4
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.11 94/12/16 19:37:39 gdurf Exp $ (BRL)";
d275 3
d279 1
@


1.11
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.10 1994/08/24 19:08:29 gdurf Exp gdurf $ (BRL)";
@


1.10
log
@Added include of conf.h
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.9 1994/06/01 17:14:01 gdurf Exp gdurf $ (BRL)";
d90 1
a90 1
		fprintf(stderr,"event: pkg_send VRMSG_EVENT failed, disconnecting\n");
d148 1
a148 1
		fprintf(stderr,"viewpoint: pkg_send VRMSG_POV failed, disconnecting\n");
d170 1
a170 1
		printf("pov: insufficient args\n");
d208 1
a208 1
		fprintf(stderr,"Closing link to VRmgr %s\n", vr_host);
d221 1
a221 1
		fprintf(stderr,"role '%s' unknown, must be master/slave/overview\n", role);
d228 1
a228 1
		fprintf(stderr, "mged/f_vrmgr: unable to contact %s, port %s\n",
d238 1
a238 1
		printf("pkg_send VRMSG_ROLE failed, disconnecting\n");
@


1.9
log
@Converted f_pov and f_vrmgr to use new command return codes.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.8 1992/11/11 00:36:49 mike Exp gdurf $ (BRL)";
d20 2
d24 1
@


1.8
log
@unsigned char
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.7 92/09/03 19:19:04 mike Exp Locker: mike $ (BRL)";
d159 1
a159 1
void
d168 1
a168 1
		return;
d183 2
d194 1
a194 1
void
d219 1
a219 1
		return;
d228 1
a228 1
		return;
d238 1
a238 1
		return;
d252 2
@


1.7
log
@Added eye_pos_scr
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.6 92/08/19 15:52:03 gdurf Exp Locker: mike $ (BRL)";
d283 1
a283 1
char			*buf;
@


1.6
log
@added vanishing point to pov command (will be changed later)
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.5 92/08/04 18:33:44 gdurf Exp Locker: gdurf $ (BRL)";
d36 2
d142 1
a142 1
		V3ARGS(recip_vanishing_point) );
d179 3
a181 3
	recip_vanishing_point[X] = atof(argv[9]);
	recip_vanishing_point[Y] = atof(argv[10]);
	recip_vanishing_point[Z] = atof(argv[11]);
@


1.5
log
@fixed typo (missing parameter to printf)
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.4 92/06/05 15:19:51 mike Exp Locker: gdurf $ (BRL)";
d134 1
a134 1
	rt_vls_printf( &str, "pov %e %e %e   %e %e %e %e   %e\n", 
d139 2
a140 1
		Viewscale );
d164 1
a164 1
	if( argc < 1+3+4+1 )  {
d177 3
@


1.4
log
@Added parameter to nmg_vlblock_anim_upcall
(mged_vlblock_anim_upcall_handler) and invent_solid() to indicate don't
copy vlist, steal them, which matches current usage.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.3 92/04/18 02:45:21 mike Exp Locker: mike $ (BRL)";
d210 1
a210 1
		fprintf(stderr,"role '%s' unknown, must be master/slave/overview\n");
@


1.3
log
@Send along any extra args to the "vrmgr" command.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.2 92/04/16 23:36:14 mike Exp Locker: mike $ (BRL)";
d288 1
a288 1
	invent_solid( rt_vls_addr(&name), &vhead, 0x0000FF00L );
@


1.2
log
@Working "overview" support
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/vrlink.c,v 1.1 92/04/16 04:02:07 mike Exp Locker: mike $ (BRL)";
d191 2
a192 1
	char	*role;
d194 2
d223 2
d226 6
a231 1
	(void)pkg_send( VRMSG_ROLE, role, strlen(role)+1, vrmgr );
d243 1
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d44 1
d47 1
d50 1
d54 12
d84 1
a84 1
	if( pkg_send( VRMSG_EVENT, rt_vls_addr(vp), rt_vls_strlen(vp)+1, vrmgr ) < 0 )  {
d141 1
a141 1
	if( pkg_send( VRMSG_POV, rt_vls_addr(&str), rt_vls_strlen(&str)+1, vrmgr ) < 0 )  {
d254 27
@
