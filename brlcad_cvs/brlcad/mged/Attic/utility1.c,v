head	11.82;
access;
symbols
	ansi-20040405-merged:11.77.2.2
	postmerge-20040405-ansi:11.80
	premerge-20040404-ansi:11.79
	postmerge-autoconf:11.79
	autoconf-freeze:11.77.10.3
	premerge-autoconf:11.79
	postmerge-20040315-windows:11.79
	premerge-20040315-windows:11.78
	windows-20040315-freeze:11.77.4.2
	autoconf-20031203:11.77
	autoconf-20031202:11.77
	autoconf-branch:11.77.0.10
	phong-branch:11.77.0.8
	photonmap-branch:11.77.0.6
	rel-6-1-DP:11.77
	windows-branch:11.77.0.4
	rel-6-0-2:11.75
	ansi-branch:11.77.0.2
	rel-6-0-1-branch:11.75.0.2
	hartley-6-0-post:11.76
	hartley-6-0-pre:11.75
	rel-6-0-1:11.75
	rel-6-0:11.73
	rel-5-4:11.48.2.1
	offsite-5-3-pre:11.56
	rel-5-3:11.48.2.1
	rel-5-2:11.48
	rel-5-1-branch:11.48.0.2
	rel-5-1:11.48
	rel-5-0:11.40
	rel-5-0-beta:11.37
	rel-4-5:11.32
	ctj-4-5-post:11.29
	ctj-4-5-pre:11.29
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.82
date	2004.05.21.17.47.51;	author morrison;	state dead;
branches;
next	11.81;

11.81
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.80;

11.80
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.79;

11.79
date	2004.03.16.21.15.12;	author morrison;	state Exp;
branches;
next	11.78;

11.78
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.77;

11.77
date	2002.08.20.17.08.26;	author jra;	state Exp;
branches
	11.77.2.1
	11.77.4.1
	11.77.10.1;
next	11.76;

11.76
date	2002.08.15.20.55.39;	author hartley;	state Exp;
branches;
next	11.75;

11.75
date	2002.05.10.15.31.58;	author jra;	state Exp;
branches;
next	11.74;

11.74
date	2002.05.10.15.12.21;	author jra;	state Exp;
branches;
next	11.73;

11.73
date	2002.01.09.19.17.38;	author jra;	state Exp;
branches;
next	11.72;

11.72
date	2002.01.08.21.57.21;	author jra;	state Exp;
branches;
next	11.71;

11.71
date	2001.11.05.21.20.07;	author morrison;	state Exp;
branches;
next	11.70;

11.70
date	2001.11.01.22.01.23;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	2001.10.02.19.24.33;	author jra;	state Exp;
branches;
next	11.68;

11.68
date	2001.05.04.14.20.46;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	2001.04.20.20.01.48;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	2001.04.05.19.35.45;	author morrison;	state Exp;
branches;
next	11.65;

11.65
date	2001.04.03.19.01.59;	author bparker;	state Exp;
branches;
next	11.64;

11.64
date	2001.04.02.21.38.21;	author morrison;	state Exp;
branches;
next	11.63;

11.63
date	2001.03.30.21.39.12;	author jra;	state Exp;
branches;
next	11.62;

11.62
date	2001.03.23.22.05.36;	author jra;	state Exp;
branches;
next	11.61;

11.61
date	2001.03.22.18.13.21;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	2001.03.21.22.15.58;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	2001.03.21.20.11.08;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	2001.03.21.16.06.13;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	2001.03.19.22.20.02;	author butler;	state Exp;
branches;
next	11.56;

11.56
date	2001.01.08.17.11.10;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	2000.11.02.03.30.45;	author cjohnson;	state Exp;
branches;
next	11.54;

11.54
date	2000.10.24.19.05.09;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.09.09.04.30.56;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.09.08.05.55.49;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.08.24.04.32.09;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	2000.08.22.06.49.08;	author mike;	state Exp;
branches;
next	11.49;

11.49
date	2000.08.19.03.10.18;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	2000.03.31.18.14.18;	author bparker;	state Exp;
branches
	11.48.2.1;
next	11.47;

11.47
date	2000.03.30.19.02.45;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	2000.01.06.22.06.55;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	99.12.30.20.05.06;	author jra;	state Exp;
branches;
next	11.44;

11.44
date	99.12.29.23.23.27;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	99.12.28.19.43.10;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	99.11.26.23.03.33;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	99.11.24.14.26.42;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	99.09.01.18.55.12;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	99.08.05.20.04.21;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	99.08.05.13.32.45;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	99.02.02.18.09.23;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	99.02.01.19.28.24;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	98.10.22.18.51.14;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	98.09.08.13.55.56;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	98.03.20.22.55.36;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	97.12.18.06.39.24;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	97.11.24.15.56.02;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	97.05.23.18.46.28;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	97.05.23.18.30.18;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	97.03.20.14.42.51;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	97.02.28.21.21.03;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	97.02.24.21.34.14;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	97.01.30.02.21.44;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	97.01.29.16.39.46;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.10.25.16.51.53;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	96.10.17.17.27.29;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.10.10.20.12.41;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	96.10.04.15.06.55;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.10.03.20.31.46;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.08.22.20.48.05;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.08.14.18.11.36;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.07.25.18.57.05;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.07.15.20.33.41;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.04.18.20.29.27;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.03.01.19.24.25;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.03.10.20.47.07;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.05.24;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.47;	author mike;	state Rel4_4;
branches;
next	10.13;

10.13
date	95.01.03.22.05.36;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.12.23.23.48.25;	author gdurf;	state Exp;
branches;
next	10.11;

10.11
date	94.12.16.20.36.39;	author gdurf;	state Exp;
branches;
next	10.10;

10.10
date	94.12.16.19.37.35;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.11.05.04.08.25;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.09.14.13.06.14;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.08.09.19.02.12;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.06.03.17.34.39;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.06.01.16.05.38;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	93.07.02.08.35.14;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	92.02.05.13.35.38;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.12.18.06.38.57;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.26;	author mike;	state Rel4_0;
branches;
next	9.15;

9.15
date	91.07.09.01.43.04;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.30.21.16.42;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.02.27.21.54.33;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.01.12.08.24.48;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.12.13.03.52.16;	author butler;	state Exp;
branches;
next	9.10;

9.10
date	90.12.08.00.31.29;	author mike;	state Exp;
branches
	9.10.1.1;
next	9.9;

9.9
date	90.12.07.19.36.21;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.07.06.15.14;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.07.03.30.33;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.07.03.29.55;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.07.01.10.29;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.05.22.23.19.58;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.04.25.21.36.56;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.28.14.36.27;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.04.13;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.05.11.21.42.46;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.05.10.17.06.19;	author stay;	state Exp;
branches;
next	8.3;

8.3
date	89.04.06.19.27.43;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.02.35.54;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.38;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.21.02.34.01;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.15.23.05.29;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.11.05.07.09.21;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.07.26;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.02.22;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.05.54;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.22.48;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.02.13.00.13.32;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.11.05.38.19;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.23.36;	author mike;	state Rel1;
branches;
next	1.12;

1.12
date	86.12.01.06.46.19;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.10.11.05.24.09;	author reschly;	state Exp;
branches;
next	1.10;

1.10
date	86.10.11.05.01.25;	author reschly;	state Exp;
branches;
next	1.9;

1.9
date	86.09.23.17.42.21;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.08.13.19.11.48;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.00.09.14;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.12.06.51.27;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.07.17.18.23.19;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.05.28.00.29.21;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.05.28.00.14.15;	author reschly;	state Exp;
branches;
next	1.2;

1.2
date	86.03.14.20.42.29;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.03.10.21.43.26;	author mike;	state Exp;
branches;
next	;

9.10.1.1
date	90.12.13.04.11.23;	author butler;	state Exp;
branches;
next	;

11.48.2.1
date	2001.01.08.17.22.09;	author bparker;	state Exp;
branches;
next	;

11.77.2.1
date	2002.09.19.18.02.06;	author morrison;	state Exp;
branches;
next	11.77.2.2;

11.77.2.2
date	2004.03.17.21.22.05;	author morrison;	state Exp;
branches;
next	;

11.77.4.1
date	2002.09.26.23.04.13;	author morrison;	state Exp;
branches;
next	11.77.4.2;

11.77.4.2
date	2004.03.11.23.46.37;	author morrison;	state Exp;
branches;
next	;

11.77.10.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	11.77.10.2;

11.77.10.2
date	2004.03.15.14.07.42;	author erikg;	state Exp;
branches;
next	11.77.10.3;

11.77.10.3
date	2004.03.18.18.10.31;	author erikg;	state Exp;
branches;
next	;


desc
@Utility routines for blending GED databases, making summary tables.
@


11.82
log
@moved to src/mged/
@
text
@/*
 *			U T I L I T Y 1 . C
 *
 *  Functions -
 *	f_tables()	control routine for building ascii tables
 *	tables()	builds ascii summary tables
 *	f_edcodes()	control routine for editing region ident codes
 *	edcodes()	allows for easy editing of region ident codes
 *	f_which_id()	lists all regions with given ident number
 *
 *  Author -
 *	Keith A. Applin
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/utility1.c,v 11.81 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifndef WIN32
#include <pwd.h>
#endif
#include <signal.h>
#include <math.h>
#include <time.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./sedit.h"
#include "./cmd.h"

extern struct bn_tol    mged_tol;       /* from ged.c */

/* bu_getopt parameters */
extern int	bu_opterr;
extern int	bu_optind;
extern int	bu_optopt;
extern char	*bu_optarg;

int readcodes(), writecodes();
int loadcodes(), printcodes(FILE *fp, struct directory *dp, int pathpos);
void		tables(), edcodes(), changes(), prfield();

#define LINELEN 256
#define MAX_LEVELS 12
struct directory *path[MAX_LEVELS];

/* structure to distinguish new solids from existing (old) solids */
struct identt {
	int	i_index;
	char	i_name[NAMESIZE+1];
	mat_t	i_mat;
};
struct identt identt, idbuf;

#define ABORTED		-99
#define OLDSOLID	0
#define NEWSOLID	1
#define SOL_TABLE	1
#define REG_TABLE	2
#define ID_TABLE	3

/*
 *
 *	F _ T A B L E S :	control routine to build ascii tables
 *
 *
 */

char operate;
int regflag, numreg, lastmemb, numsol, old_or_new, oper_ok;
int idfd, rd_idfd;
int flag;	/* which type of table to make */
FILE	*tabptr;

char ctemp[7];

static char	tmpfil[17];
#ifndef WIN32
static char	*tmpfil_init = "/tmp/GED.aXXXXXX";
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif

static int
id_compare( const void *p1, const void *p2 )
{
	int id1, id2;

	id1 = atoi( *(char **)p1 );
	id2 = atoi( *(char **)p2 );

	return( id1 - id2 );
}

static int
reg_compare( const void *p1, const void *p2 )
{
	char *reg1, *reg2;

	reg1 = strchr( *(char **)p1, '/' );
	reg2 = strchr( *(char **)p2, '/' );

	return( strcmp( reg1, reg2 ) );
}

/*
 *
 *	F _ E D C O D E S ( )
 *
 *		control routine for editing region ident codes
 *
 *
 */
int
f_edcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int i;
  int status;
  int sort_by_ident=0;
  int sort_by_region=0;
  int c;
  char **av;

  CHECK_DBI_NULL;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help edcodes");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_optind = 1;
  while ((c = bu_getopt(argc, argv, "ir")) != EOF) {
	  switch( c ) {
		  case 'i':
			  sort_by_ident = 1;
			  break;
		  case 'r':
			  sort_by_region = 1;
			  break;
	  }
  }

  if( (sort_by_ident + sort_by_region) > 1 ) {
	  Tcl_AppendResult(interp, "edcodes: can only sort by region or ident, not both\n",
			   (char *)NULL );
	  return TCL_ERROR;
  }

  argc -= (bu_optind - 1);
  argv += (bu_optind - 1);

  strcpy(tmpfil, tmpfil_init);
#ifdef WIN32
  (void)mktemp(tmpfil);
  i=creat(tmpfil, 0600);
#else
  i = mkstemp(tmpfil);
#endif
  if( i < 0 ){
    perror(tmpfil);
    return TCL_ERROR;
  }

  (void)close(i);

  av = (char **)bu_malloc(sizeof(char *)*(argc + 2), "f_edcodes: av");
  av[0] = "wcodes";
  av[1] = tmpfil;
  for(i = 2; i < argc + 1; ++i)
    av[i] = argv[i-1];

  av[i] = NULL;

  if( f_wcodes(clientData, interp, argc + 1, av) == TCL_ERROR ){
    (void)unlink(tmpfil);
    bu_free((genptr_t)av, "f_edcodes: av");
    return TCL_ERROR;
  }

	if( regflag == ABORTED )
	{
		Tcl_AppendResult(interp, "f_edcodes: nesting is too deep\n", (char *)NULL );
		(void)unlink(tmpfil);
		return TCL_ERROR;
	}

	if( sort_by_ident || sort_by_region ) {
		char **line_array;
		char aline[256];
		FILE *f_srt;
		int line_count=0;
		int j;

		if( (f_srt=fopen( tmpfil, "r+" ) ) == NULL ) {
			Tcl_AppendResult(interp, "edcodes: Failed to open temp file for sorting\n",
					 (char *)NULL );
			unlink( tmpfil );
			return TCL_ERROR;
		}

		/* count lines */
		while( fgets( aline, 256, f_srt ) ) {
			line_count++;
		}

		/* build array of lines */
		line_array = (char **)bu_calloc( line_count, sizeof( char *), "edcodes line array" );

		/* read lines and save into the array */
		rewind( f_srt );
		line_count = 0;
		while( fgets( aline, 256, f_srt ) ) {
			line_array[line_count] = bu_strdup( aline );
			line_count++;
		}

		/* sort the array of lines */
		if( sort_by_ident ) {
			qsort( line_array, line_count, sizeof( char *), id_compare );
		} else {
			qsort( line_array, line_count, sizeof( char *), reg_compare );
		}

		/* rewrite the temp file using the sorted lines */
		rewind( f_srt );
		for( j=0 ; j<line_count ; j++ ) {
			fprintf( f_srt, "%s", line_array[j] );
			bu_free( line_array[j], "edcodes line array element" );
		}
		bu_free( (char *)line_array, "edcodes line array" );
		fclose( f_srt );
	}

  if( editit(tmpfil) ){
	  regflag = lastmemb = 0;

	  if (!dbip->dbi_read_only) {
		  av[0] = "rcodes";
		  av[2] = NULL;
		  status = f_rcodes(clientData, interp, 2, av);
	  } else {
		  Tcl_AppendResult(interp, "Because the database is READ-ONLY no changes were made.\n", (char *)NULL);
		  status = TCL_OK;
	  }
  }else
	  status = TCL_ERROR;

  (void)unlink(tmpfil);
  bu_free((genptr_t)av, "f_edcodes: av");
  return status;
}


/* write codes to a file */
int
f_wcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  register int i;
  int status;
  FILE *fp;
  register struct directory *dp;

  CHECK_DBI_NULL;

  if(argc < 3){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help wcodes");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if((fp = fopen(argv[1], "w")) == NULL){
    Tcl_AppendResult(interp, "f_wcodes: Failed to open file - ", argv[1], (char *)NULL);
    return TCL_ERROR;
  }

  regflag = lastmemb = 0;
  for(i = 2; i < argc; ++i){
    if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY)) != DIR_NULL ){
      status = printcodes(fp, dp, 0);

      if(status == TCL_ERROR){
	(void)fclose(fp);
	return TCL_ERROR;
      }
    }
  }

  (void)fclose(fp);
  return TCL_OK;
}

/* read codes from a file and load them into the database */
int
f_rcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int item, air, mat, los;
  char name[MAX_LEVELS * NAMESIZE];
  char line[LINELEN];
  char *cp;
  FILE *fp;
  register struct directory *dp;
  struct rt_db_internal intern;
  struct rt_comb_internal *comb;

  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  if(argc < 2 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help rcodes");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if((fp = fopen(argv[1], "r")) == NULL){
    Tcl_AppendResult(interp, "f_rcodes: Failed to read file - ", argv[1], (char *)NULL);
    return TCL_ERROR;
  }

  while(fgets( line , LINELEN, fp ) != NULL){
	  int changed;

    if(sscanf(line, "%d%d%d%d%s", &item, &air, &mat, &los, name) != 5)
      continue; /* not useful */

    /* skip over the path */
    if((cp = strrchr(name, (int)'/')) == NULL)
      cp = name;
    else
      ++cp;

    if(*cp == '\0')
      continue;

    if((dp = db_lookup( dbip, cp, LOOKUP_NOISY )) == DIR_NULL){
      Tcl_AppendResult(interp, "f_rcodes: Warning - ", cp, " not found in database.\n",
		       (char *)NULL);
      continue;
    }

  	if( !(dp->d_flags & DIR_REGION) )
  	{
  		Tcl_AppendResult(interp, "f_rcodes: Warning ", cp, " not a region\n", (char *)NULL );
  		continue;
  	}

  	if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) != ID_COMBINATION )
  	{
  		Tcl_AppendResult(interp, "f_rcodes: Warning ", cp, " not a region\n", (char *)NULL );
  		continue;
  	}

  	comb = (struct rt_comb_internal *)intern.idb_ptr;

  	/* make the changes */
	changed = 0;
	if( comb->region_id != item ) {
		comb->region_id = item;
		changed = 1;
	}
	if( comb->aircode != air ) {
		comb->aircode = air;
		changed = 1;
	}
	if( comb->GIFTmater != mat ) {
		comb->GIFTmater = mat;
		changed = 1;
	}
	if( comb->los != los ) {
		comb->los = los;
		changed = 1;
	}

	if( changed ) {
		/* write out all changes */
		if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) ) {
			Tcl_AppendResult(interp, "Database write error, aborting.\n",
					 (char *)NULL );
			TCL_ERROR_RECOVERY_SUGGESTION;
			rt_db_free_internal( &intern, &rt_uniresource );
			return TCL_ERROR;
		}
	}

  }

  return TCL_OK;
}

HIDDEN void
Do_printnode(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3)
{
	FILE *fp;
	int *pathpos;
	struct directory *nextdp;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	if( (nextdp=db_lookup( dbip, comb_leaf->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
		return;

	fp = (FILE *)user_ptr1;
	pathpos = (int *)user_ptr2;

	/* recurse on combinations */
	if( nextdp->d_flags & DIR_COMB )
		(void)printcodes( fp, nextdp, (*pathpos)+1 );
}

int
printcodes(FILE *fp, struct directory *dp, int pathpos)
{
	int i;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int id;

	CHECK_DBI_NULL;

	if(pathpos >= MAX_LEVELS)
	{
		regflag = ABORTED;
		return TCL_ERROR;
	}

	if( !(dp->d_flags & DIR_COMB) )
		return( 0 );

	if( (id=rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) ) < 0 )
	{
		Tcl_AppendResult(interp, "printcodes: Cannot get records for ",
			dp->d_namep, "\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( id != ID_COMBINATION )
		return TCL_OK;

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( comb->region_flag )
	{
		fprintf(fp, "%-6d %-3d %-3d %-4d  ",
			comb->region_id,
			comb->aircode,
			comb->GIFTmater,
			comb->los );
		for(i=0; i < pathpos; i++)
			fprintf(fp, "/%s",path[i]->d_namep);
		fprintf(fp, "/%s\n", dp->d_namep );
		rt_comb_ifree( &intern, &rt_uniresource );
		return TCL_OK;
	}

	if( comb->tree )
	{
		path[pathpos] = dp;
		db_tree_funcleaf( dbip, comb, comb->tree, Do_printnode,
			(genptr_t)fp, (genptr_t)&pathpos, (genptr_t)NULL );
	}

	rt_comb_ifree( &intern, &rt_uniresource );
	return TCL_OK;
}

/*    C H E C K      -     compares solids       returns 1 if they match
							 0 otherwise
 */

int
check(register char *a, register char *b)
{

	register int	c= sizeof( struct identt );

	while( c-- )	if( *a++ != *b++ ) return( 0 );	/* no match */
	return( 1 );	/* match */

}

struct id_names {
	struct bu_list l;
	struct bu_vls name;		/* name associated with region id */
};

struct id_to_names {
	struct bu_list l;
	int id;				/* starting id (i.e. region id or air code) */
	struct id_names headName;	/* head of list of names */
};

/*		F _ W H I C H _ S H A D E R
 *
 *	Finds all combinations using the given shaders
 */
int
f_which_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int	i,j;
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int sflag;
	int myArgc;
	char **myArgv;

	CHECK_DBI_NULL;

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	myArgc = argc;
	myArgv = argv;
	sflag = 0;

	if(myArgc > 1 && strcmp(myArgv[1], "-s") == 0){
	  --myArgc;
	  ++myArgv;
	  sflag = 1;
	}

	if(myArgc < 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help which_shader");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		(void)signal( SIGINT, SIG_IGN );
		return TCL_ERROR;
	}

	for( j=1; j<myArgc; j++) {

		if(!sflag)
		  Tcl_AppendResult(interp, "Combination[s] with shader ", myArgv[j],
				   ":\n", (char *)NULL);

		/* Examine all COMB nodes */
		for( i = 0; i < RT_DBNHASH; i++ )  {
			for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
				if( !(dp->d_flags & DIR_COMB) )
					continue;

				if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
					(void)signal( SIGINT, SIG_IGN );
					TCL_READ_ERR_return;
				}
				comb = (struct rt_comb_internal *)intern.idb_ptr;

				if( !strstr( bu_vls_addr( &comb->shader ), myArgv[j] ) )
					continue;

				if(sflag)
				  Tcl_AppendElement(interp, dp->d_namep);
				else
				  Tcl_AppendResult(interp, "   ", dp->d_namep,
						   "\n", (char *)NULL);
				rt_comb_ifree( &intern, &rt_uniresource );
			}
		}
	}

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}

/*		F _ D E C O M P O S E
 *
 *	decompose an NMG object into shells,
 *	making a new NMG object for each shell.
 *	This is not just copying each shell from the NMG object into a new
 *	object. The NMG object is actually disassembled and each face
 *	is placed into an appropriate shell so that the end product is a
 *	group of shell(s) that can be described as exterior shells and interior
 *	void shells.
 */

int
f_decompose(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int count;
	struct bu_vls solid_name;
	char *nmg_solid_name;
	char *prefix;
	char *def_prefix="sh";
	struct model *m;
	struct nmgregion *r;
	struct model *new_m;
	struct nmgregion *tmp_r;
	struct shell *kill_s;
	struct directory *dp;
	struct rt_db_internal nmg_intern;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help decompose");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	count = 0;
	nmg_solid_name = argv[1];

	if( argc > 2 )
	{
		prefix = argv[2];
		if( dbip->dbi_version < 5 && strlen( prefix ) >= (NAMESIZE-3) )
		{
			Tcl_AppendResult(interp, "Prefix ", prefix, " is too long", (char *)NULL );
			return TCL_ERROR;
		}
	}
	else
		prefix = def_prefix;;

	if( (dp=db_lookup( dbip, nmg_solid_name, LOOKUP_NOISY ) ) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &nmg_intern, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
		return TCL_ERROR;
	}

	if( nmg_intern.idb_type != ID_NMG )
	{
		Tcl_AppendResult(interp, nmg_solid_name, " is not an NMG solid!", (char *)NULL );
		return TCL_ERROR;
	}

	bu_vls_init( &solid_name );

	m = (struct model *)nmg_intern.idb_ptr;
	NMG_CK_MODEL(m);

	/* create temp region to hold duplicate shell */
	tmp_r = nmg_mrsv( m );	/* temp nmgregion to hold dup shells */
	kill_s = BU_LIST_FIRST( shell, &tmp_r->s_hd );
	(void)nmg_ks( kill_s );

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		struct shell *s;

		if( r == tmp_r )
			continue;

		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
		{
			struct shell *tmp_s;
			struct shell *decomp_s;
			long **trans_tbl;

			/* duplicate shell */
			tmp_s = (struct shell *)nmg_dup_shell( s, &trans_tbl, &mged_tol );
			bu_free( (char *)trans_tbl, "trans_tbl" );

			 /* move duplicate to temp region */
			(void) nmg_mv_shell_to_region( tmp_s, tmp_r );

			/* decompose this shell */
			(void) nmg_decompose_shell( tmp_s, &mged_tol );

			/* move each decomposed shell to yet another region */
			decomp_s = BU_LIST_FIRST( shell, &tmp_r->s_hd );
			while( BU_LIST_NOT_HEAD( &decomp_s->l, &tmp_r->s_hd ) )
			{
				struct shell *next_s;
				struct shell *new_s;
				struct rt_db_internal new_intern;
				struct directory *new_dp;
				struct nmgregion *decomp_r;
				char shell_no[32];
				int end_prefix;

				next_s = BU_LIST_NEXT( shell, &decomp_s->l );

				decomp_r = nmg_mrsv( m );
				kill_s = BU_LIST_FIRST( shell, &decomp_r->s_hd );
				(void)nmg_ks( kill_s );
				nmg_shell_a( decomp_s, &mged_tol );
				new_s = (struct shell *)nmg_dup_shell( decomp_s, &trans_tbl, &mged_tol );
				(void)nmg_mv_shell_to_region( new_s, decomp_r );

				/* move this region to a different model */
				new_m = (struct model *)nmg_mk_model_from_region( decomp_r, 1 );
				(void)nmg_rebound( new_m, &mged_tol );

				/* create name for this shell */
				count++;
				bu_vls_strcpy( &solid_name, prefix );
				sprintf( shell_no, "_%d", count );
				if( dbip->dbi_version < 5 ) {
					end_prefix = strlen( prefix );
					if( end_prefix + strlen( shell_no ) >= NAMESIZE )
						end_prefix = NAMESIZE - strlen( shell_no );
					bu_vls_trunc( &solid_name, end_prefix );
					bu_vls_strncat( &solid_name, shell_no, NAMESIZE-bu_vls_strlen(&solid_name)-1 );
				} else {
					bu_vls_strcat( &solid_name, shell_no );
				}

				if( db_lookup( dbip, bu_vls_addr( &solid_name ), LOOKUP_QUIET ) != DIR_NULL )
				{
					Tcl_AppendResult(interp, "decompose: cannot create unique solid name (",
							 bu_vls_addr( &solid_name ), ")", (char *)NULL );
					Tcl_AppendResult(interp, "decompose: failed" );
					return TCL_ERROR;
				}

				/* write this model as a seperate nmg solid */
				RT_INIT_DB_INTERNAL( &new_intern );
				new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
				new_intern.idb_type = ID_NMG;
				new_intern.idb_meth = &rt_functab[ID_NMG];
				new_intern.idb_ptr = (genptr_t)new_m;

				if( (new_dp=db_diradd( dbip, bu_vls_addr( &solid_name ), -1, 0, DIR_SOLID,
						       (genptr_t)&new_intern.idb_type)) == DIR_NULL ) {
					bu_vls_free( &solid_name );
					TCL_ALLOC_ERR;
					return TCL_ERROR;;
				}

				if( rt_db_put_internal( new_dp, dbip, &new_intern, &rt_uniresource ) < 0 )
				{
					(void)nmg_km( new_m );
					bu_vls_free( &solid_name );
					Tcl_AppendResult(interp, "rt_db_put_internal() failure\n", (char *)NULL);
					return TCL_ERROR;
				}

				(void)nmg_ks( decomp_s );
				decomp_s = next_s;
			}
		}
	}

	rt_db_free_internal( &nmg_intern, &rt_uniresource );
	bu_vls_free( &solid_name );

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}

HIDDEN int
sol_number(matp_t matrix, char *name, int *old)
{
	int i;
	struct identt idbuf1, idbuf2;

	bzero( &idbuf1, sizeof( struct identt ) );
	(void)strncpy(idbuf1.i_name, name, NAMESIZE);
	MAT_COPY(idbuf1.i_mat, matrix);

	for( i=0 ; i<numsol ; i++ )
	{
		(void)lseek(rd_idfd, i*(long)sizeof identt, 0);
		(void)read(rd_idfd, &idbuf2, sizeof identt);

		idbuf1.i_index = i + 1;

		if( check( (char *)&idbuf1, (char *)&idbuf2 ) == 1 )
		{
			*old = 1;
			return( idbuf2.i_index );
		}
	}
	numsol++;
	idbuf1.i_index = numsol;

	(void)lseek(idfd, (off_t)0L, 2);
	(void)write(idfd, &idbuf1, sizeof identt);

	*old = 0;
	return( idbuf1.i_index );
}

HIDDEN void
new_tables(struct directory *dp, struct bu_ptbl *cur_path, fastf_t *old_mat, int flag)
{
	struct rt_db_internal intern;	
	struct rt_comb_internal *comb;
	struct rt_tree_array *tree_list;
	int node_count;
	int actual_count;
	int i,k;

	if(dbip == DBI_NULL)
	  return;

	RT_CK_DIR( dp );
	BU_CK_PTBL( cur_path );

	if( !(dp->d_flags & DIR_COMB) )
		return;

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		READ_ERR_return;

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
	{
		db_non_union_push( comb->tree, &rt_uniresource );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL );
			rt_comb_ifree( &intern, &rt_uniresource );
			return;
		}
	}

	if( !comb->tree )
	{
		/* empty combination */
		rt_comb_ifree( &intern, &rt_uniresource );
		return;
	}

	node_count = db_tree_nleaves( comb->tree );
	tree_list = (struct rt_tree_array *)bu_calloc( node_count,
		sizeof( struct rt_tree_array ), "tree list" );

	/* flatten tree */
	actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list,
		comb->tree, OP_UNION, 0, &rt_uniresource ) - tree_list;
	BU_ASSERT_LONG( actual_count, ==, node_count );

	if( dp->d_flags & DIR_REGION )
	{
		numreg++;
		(void)fprintf( tabptr, " %-4d %4d %4d %4d %4d  ",
			numreg, comb->region_id, comb->aircode, comb->GIFTmater,
			comb->los );
		for( k=0 ; k<BU_PTBL_END( cur_path ) ; k++ )
		{
			struct directory *path_dp;

			path_dp = (struct directory *)BU_PTBL_GET( cur_path, k );
			RT_CK_DIR( path_dp );
			(void)fprintf( tabptr, "/%s", path_dp->d_namep );
		}
		(void)fprintf( tabptr, "/%s:\n", dp->d_namep );

		if( flag == ID_TABLE )
			goto out;

		for( i=0 ; i<actual_count ; i++ )
		{
			char op;
			int nsoltemp=0;
			struct rt_db_internal sol_intern;
			struct directory *sol_dp;
			mat_t temp_mat;
			struct bu_vls tmp_vls;
			int old;

			switch( tree_list[i].tl_op )
			{
				case OP_UNION:
					op = 'u';
					break;
				case OP_SUBTRACT:
					op = '-';
					break;
				case OP_INTERSECT:
					op = '+';
					break;
				default:
					bu_log( "unrecognized operation in region %s\n", dp->d_namep );
					op = '?';
					break;
			}

			if( (sol_dp=db_lookup( dbip, tree_list[i].tl_tree->tr_l.tl_name, LOOKUP_QUIET )) != DIR_NULL )
			{
				if( sol_dp->d_flags & DIR_COMB )
				{
					(void)fprintf(tabptr,"   RG %c %s\n",
						op, sol_dp->d_namep);
					continue;
				}
				else if( !(sol_dp->d_flags & DIR_SOLID) )
				{
					(void)fprintf( tabptr, "   ?? %c %s\n",
						op, sol_dp->d_namep);
					continue;
				}
				else
				{
					if( tree_list[i].tl_tree->tr_l.tl_mat )  {
						bn_mat_mul( temp_mat, old_mat,
							tree_list[i].tl_tree->tr_l.tl_mat );
					} else {
						MAT_COPY( temp_mat, old_mat );
					}
					if( rt_db_get_internal( &sol_intern, sol_dp, dbip, temp_mat, &rt_uniresource ) < 0 )
					{
						bu_log( "Could not import %s\n", tree_list[i].tl_tree->tr_l.tl_name );
						nsoltemp = 0;
					}
					nsoltemp = sol_number( temp_mat, tree_list[i].tl_tree->tr_l.tl_name, &old );
					(void)fprintf(tabptr,"   %c [%d] ", op, nsoltemp );
				}
			}
			else
			{
				nsoltemp = sol_number( old_mat, tree_list[i].tl_tree->tr_l.tl_name, &old );
				(void)fprintf(tabptr,"   %c [%d] ", op, nsoltemp );
				continue;
			}

			if( flag == REG_TABLE || old )
			{
				(void) fprintf( tabptr, "%s\n", tree_list[i].tl_tree->tr_l.tl_name );
				continue;
			}
			else
				(void) fprintf( tabptr, "%s:  ", tree_list[i].tl_tree->tr_l.tl_name );

			if( !old && (sol_dp->d_flags & DIR_SOLID) )
			{
				/* if we get here, we must be looking for a solid table */
				bu_vls_init_if_uninit( &tmp_vls );
				if( rt_functab[sol_intern.idb_type].ft_describe( &tmp_vls, &sol_intern, 1, base2local, &rt_uniresource, dbip ) < 0 )
				{
					Tcl_AppendResult(interp, tree_list[i].tl_tree->tr_l.tl_name,
						"describe error\n" , (char *)NULL );
				}
				(void)fprintf( tabptr, bu_vls_addr(&tmp_vls));
				bu_vls_free( &tmp_vls );
			}
			if( nsoltemp && (sol_dp->d_flags & DIR_SOLID) )
				rt_db_free_internal( &sol_intern, &rt_uniresource );
		}
	}
	else if( dp->d_flags & DIR_COMB )
	{
		int cur_length;

		bu_ptbl_ins( cur_path, (long *)dp );
		cur_length = BU_PTBL_END( cur_path );

		for( i=0 ; i<actual_count ; i++ )
		{
			struct directory *nextdp;
			mat_t new_mat;

			if( (nextdp=db_lookup( dbip, tree_list[i].tl_tree->tr_l.tl_name,
				 LOOKUP_NOISY )) == DIR_NULL )
			{
				Tcl_AppendResult(interp, "\tskipping this object\n", (char *)NULL );
				continue;
			}

			/* recurse */
			if( tree_list[i].tl_tree->tr_l.tl_mat )  {
				bn_mat_mul( new_mat, old_mat, tree_list[i].tl_tree->tr_l.tl_mat );
			} else {
				MAT_COPY( new_mat, old_mat );
			}
			new_tables( nextdp, cur_path, new_mat, flag );
			bu_ptbl_trunc( cur_path, cur_length );
		}
	}
	else
	{
		Tcl_AppendResult(interp, "Illegal flags for ", dp->d_namep,
			"skipping\n", (char *)NULL );
		return;
	}

out:
	bu_free( (char *)tree_list, "new_tables: tree_list" );
	rt_comb_ifree( &intern, &rt_uniresource );
	return;
}

int
f_tables(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	static const char sortcmd[] = "sort -n +1 -2 -o /tmp/ord_id ";
	static const char catcmd[] = "cat /tmp/ord_id >> ";
	struct bu_vls tmp_vls;
	struct bu_vls	cmd;
	struct bu_ptbl	cur_path;
	int status;
	char *timep;
	time_t now;
	int i;

	CHECK_DBI_NULL;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help %s", argv[0]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init(&tmp_vls);
	bu_vls_init( &cmd );
	bu_ptbl_init( &cur_path, 8, "f_tables: cur_path" );
	numreg = 0;
	numsol = 0;

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else{
	  bu_vls_free( &cmd );
	  bu_vls_free(&tmp_vls);
	  bu_ptbl_free( &cur_path );
	  return TCL_OK;
	}
	status = TCL_OK;

	/* find out which ascii table is desired */
	if( strcmp(argv[0], "solids") == 0 ) {
		/* complete summary - down to solids/paremeters */
		flag = SOL_TABLE;
	}
	else if( strcmp(argv[0], "regions") == 0 ) {
		/* summary down to solids as members of regions */
		flag = REG_TABLE;
	}
	else if( strcmp(argv[0], "idents") == 0 ) {
		/* summary down to regions */
		flag = ID_TABLE;
	}
	else {
		/* should never reach here */
	  Tcl_AppendResult(interp, "tables:  input error\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	/* open the file */
	if( (tabptr=fopen(argv[1], "w+")) == NULL ) {
	  Tcl_AppendResult(interp, "Can't open ", argv[1], "\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	if( flag == SOL_TABLE || flag == REG_TABLE ) {
		/* temp file for discrimination of solids */
		if( (idfd = creat("/tmp/mged_discr", 0600)) < 0 ) {
			perror( "/tmp/mged_discr" );
			status = TCL_ERROR;
			goto end;
		}
		rd_idfd = open( "/tmp/mged_discr", 2 );
	}

	(void)time( &now );
	timep = ctime( &now );
	timep[24] = '\0';
	(void)fprintf(tabptr,"1 -8    Summary Table {%s}  (written: %s)\n",argv[0],timep);
	(void)fprintf(tabptr,"2 -7         file name    : %s\n",dbip->dbi_filename);    
	(void)fprintf(tabptr,"3 -6         \n");
	(void)fprintf(tabptr,"4 -5         \n");
#ifndef WIN32
	(void)fprintf(tabptr,"5 -4         user         : %s\n",getpwuid(getuid())->pw_gecos);
#else
	{
	char uname[256]; 
	DWORD dwNumBytes = 256; 
	if(GetUserName(uname, &dwNumBytes))
		(void)fprintf(tabptr,"5 -4         user         : %s\n",uname);
	else
		(void)fprintf(tabptr,"5 -4         user         : UNKNOWN\n");
	}
#endif
	(void)fprintf(tabptr,"6 -3         target title : %s\n",cur_title);
	(void)fprintf(tabptr,"7 -2         target units : %s\n",
		bu_units_string(dbip->dbi_local2base) );
	(void)fprintf(tabptr,"8 -1         objects      :");
	for(i=2; i<argc; i++) {
		if( (i%8) == 0 )
			(void)fprintf(tabptr,"\n                           ");
		(void)fprintf(tabptr," %s",argv[i]);
	}
	(void)fprintf(tabptr,"\n\n");

	/* make the tables */
	for( i=2 ; i<argc ; i++ )
	{
		struct directory *dp;

		bu_ptbl_reset( &cur_path );
		if( (dp = db_lookup( dbip, argv[i],LOOKUP_NOISY)) != DIR_NULL )
			new_tables( dp, &cur_path, identity, flag);
		else
			Tcl_AppendResult(interp, " skip this object\n", (char *)NULL);
	}

	Tcl_AppendResult(interp, "Summary written in: ", argv[1], "\n", (char *)NULL);

	if( flag == SOL_TABLE || flag == REG_TABLE ) {
		(void)unlink( "/tmp/mged_discr\0" );
		(void)fprintf(tabptr,"\n\nNumber Primitives = %d  Number Regions = %d\n",
				numsol,numreg);

		bu_vls_printf(&tmp_vls, "Processed %d Primitives and %d Regions\n",
			      numsol,numreg);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);

		(void)fclose( tabptr );
	}

	else {
		(void)fprintf(tabptr,"* 9999999\n* 9999999\n* 9999999\n* 9999999\n* 9999999\n");
		(void)fclose( tabptr );

		bu_vls_printf(&tmp_vls, "Processed %d Regions\n",numreg);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);

		/* make ordered idents */
		bu_vls_strcpy( &cmd, sortcmd );
		bu_vls_strcat( &cmd, argv[1] );
		Tcl_AppendResult(interp, bu_vls_addr(&cmd), "\n", (char *)NULL);
		(void)system( bu_vls_addr(&cmd) );

		bu_vls_trunc( &cmd, 0 );
		bu_vls_strcpy( &cmd, catcmd );
		bu_vls_strcat( &cmd, argv[1] );
		Tcl_AppendResult(interp, bu_vls_addr(&cmd), "\n", (char *)NULL);
		(void)system( bu_vls_addr(&cmd) );

		(void)unlink( "/tmp/ord_id\0" );
	}

end:
	bu_vls_free( &cmd );
	bu_vls_free(&tmp_vls);
	bu_ptbl_free( &cur_path );
	(void)signal( SIGINT, SIG_IGN );
	return status;
}
@


11.81
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/utility1.c,v 11.80 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.80
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 5
a31 1
#include "conf.h"
@


11.79
log
@merge of windows-6-0-branch into head
@
text
@d62 1
a62 1
int loadcodes(), printcodes();
d137 1
a137 5
f_edcodes(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d283 1
a283 5
f_wcodes(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d325 1
a325 5
f_rcodes(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int		 argc;
char		*argv[];
d425 1
a425 5
Do_printnode( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
d446 1
a446 4
printcodes(fp, dp, pathpos)
FILE *fp;
struct directory *dp;
int pathpos;
d507 1
a507 2
check( a, b )
register char *a, *b;
d533 1
a533 5
f_which_shader(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d618 1
a618 5
f_decompose(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d797 1
a797 4
sol_number( matrix, name, old )
matp_t matrix;
char *name;
int *old;
d830 1
a830 5
new_tables( dp, cur_path, old_mat, flag)
struct directory *dp;
struct bu_ptbl *cur_path;
mat_t old_mat;
int flag;
d1032 1
a1032 5
f_tables(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.78
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.77 2002/08/20 17:08:26 jra Exp $ (BRL)";
d30 1
d32 1
d100 1
d102 3
d184 1
a184 1
#if 0
d1155 1
d1157 10
@


11.77
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1990 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.75 2002/05/10 15:31:58 jra Exp $ (BRL)";
@


11.77.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.78 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.77.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.77.10.1 2004/02/12 18:34:16 erikg Exp $ (BRL)";
@


11.77.10.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a29 1
#ifndef WIN32
a30 1
#endif
a97 1
#ifndef WIN32
a98 3
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d178 1
a178 1
#ifdef WIN32
a1148 1
#ifndef WIN32
a1149 10
#else
	{
	char uname[256]; 
	DWORD dwNumBytes = 256; 
	if(GetUserName(uname, &dwNumBytes))
		(void)fprintf(tabptr,"5 -4         user         : %s\n",uname);
	else
		(void)fprintf(tabptr,"5 -4         user         : UNKNOWN\n");
	}
#endif
@


11.77.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.77 2002/08/20 17:08:26 jra Exp $ (BRL)";
a29 1
#ifndef WIN32
a30 1
#endif
a97 1
#ifndef WIN32
a98 3
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d178 1
a178 1
#ifdef WIN32
a1148 1
#ifndef WIN32
a1149 10
#else
	{
	char uname[256]; 
	DWORD dwNumBytes = 256; 
	if(GetUserName(uname, &dwNumBytes))
		(void)fprintf(tabptr,"5 -4         user         : %s\n",uname);
	else
		(void)fprintf(tabptr,"5 -4         user         : UNKNOWN\n");
	}
#endif
@


11.77.4.2
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/utility1.c,v 11.77.4.1 2002/09/26 23:04:13 morrison Exp $ (BRL)";
@


11.77.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.77 2002/08/20 17:08:26 jra Exp $ (BRL)";
d60 1
a60 1
int loadcodes(), printcodes(FILE *fp, struct directory *dp, int pathpos);
d131 5
a135 1
f_edcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d281 5
a285 1
f_wcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d327 5
a331 1
f_rcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d431 5
a435 1
Do_printnode(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3)
d456 4
a459 1
printcodes(FILE *fp, struct directory *dp, int pathpos)
d520 2
a521 1
check(register char *a, register char *b)
d547 5
a551 1
f_which_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d636 5
a640 1
f_decompose(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d819 4
a822 1
sol_number(matp_t matrix, char *name, int *old)
d855 5
a859 1
new_tables(struct directory *dp, struct bu_ptbl *cur_path, fastf_t *old_mat, int flag)
d1061 5
a1065 1
f_tables(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.77.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a29 1
#ifndef WIN32
a30 1
#endif
a97 1
#ifndef WIN32
a98 3
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d174 1
a174 1
#ifdef WIN32
a1109 1
#ifndef WIN32
a1110 10
#else
	{
	char uname[256]; 
	DWORD dwNumBytes = 256; 
	if(GetUserName(uname, &dwNumBytes))
		(void)fprintf(tabptr,"5 -4         user         : %s\n",uname);
	else
		(void)fprintf(tabptr,"5 -4         user         : UNKNOWN\n");
	}
#endif
@


11.76
log
@Converted from K&R to ANSI C - RFH
@
text
@d60 1
a60 1
int loadcodes(), printcodes(FILE *fp, struct directory *dp, int pathpos);
d131 5
a135 1
f_edcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d281 5
a285 1
f_wcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d327 5
a331 1
f_rcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d431 5
a435 1
Do_printnode(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3)
d456 4
a459 1
printcodes(FILE *fp, struct directory *dp, int pathpos)
d520 2
a521 1
check(register char *a, register char *b)
d547 5
a551 1
f_which_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d636 5
a640 1
f_decompose(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d819 4
a822 1
sol_number(matp_t matrix, char *name, int *old)
d855 5
a859 1
new_tables(struct directory *dp, struct bu_ptbl *cur_path, fastf_t *old_mat, int flag)
d1061 5
a1065 1
f_tables(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.75
log
@f_rcodes() now only writes to the database if it needs to change something
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.74 2002/05/10 15:12:21 jra Exp $ (BRL)";
d60 1
a60 1
int loadcodes(), printcodes();
d131 1
a131 5
f_edcodes(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d277 1
a277 5
f_wcodes(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	*argv[];
d319 1
a319 5
f_rcodes(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int		 argc;
char		*argv[];
d419 1
a419 5
Do_printnode( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
d440 1
a440 4
printcodes(fp, dp, pathpos)
FILE *fp;
struct directory *dp;
int pathpos;
d501 1
a501 2
check( a, b )
register char *a, *b;
d527 1
a527 5
f_which_shader(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d612 1
a612 5
f_decompose(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d791 1
a791 4
sol_number( matrix, name, old )
matp_t matrix;
char *name;
int *old;
d824 1
a824 5
new_tables( dp, cur_path, old_mat, flag)
struct directory *dp;
struct bu_ptbl *cur_path;
mat_t old_mat;
int flag;
d1026 1
a1026 5
f_tables(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.74
log
@Added options to "edcodes" command to sort file before editing
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.73 2002/01/09 19:17:38 jra Exp $ (BRL)";
d361 2
d396 17
a412 4
  	comb->region_id = item;
  	comb->aircode = air;
  	comb->GIFTmater = mat;
  	comb->los = los;
d414 10
a423 8
  	/* write out all changes */
  	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) )
  	{
  		Tcl_AppendResult(interp, "Database write error, aborting.\n", (char *)NULL );
  		TCL_ERROR_RECOVERY_SUGGESTION;
  		rt_db_free_internal( &intern, &rt_uniresource );
  		return TCL_ERROR;
  	}
@


11.73
log
@Undo previous mod for long names (was not needed)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.72 2002/01/08 21:57:21 jra Exp $ (BRL)";
d53 6
d100 22
d139 3
d156 21
d210 47
@


11.72
log
@Corrections to handle long names
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.71 2001/11/05 21:20:07 morrison Exp $ (BRL)";
d674 5
a678 22
				if( dbip->dbi_version < 5 ) {
					if( (new_dp=db_diradd( dbip, bu_vls_addr( &solid_name ), -1, 0, DIR_SOLID,
							       (genptr_t)&new_intern.idb_type)) == DIR_NULL ) {
						bu_vls_free( &solid_name );
						TCL_ALLOC_ERR;
						return TCL_ERROR;;
					}
				} else {
					struct bu_attribute_value_set avs;

					bu_avs_init( &avs, 1, "avs" );
					if ((new_dp = db_diradd5(wdbp->dbip, bu_vls_addr( &solid_name ), -1L,
							     new_intern.idb_major_type, new_intern.idb_minor_type,
							     (unsigned char)'\0', 0, &avs )) == DIR_NULL)  {
						bu_avs_free( &avs );
						Tcl_AppendResult(interp, "An error has occured while adding '",
								 bu_vls_addr( &solid_name ), "' to the database.\n", (char *)NULL);
						bu_vls_free( &solid_name );
						TCL_ALLOC_ERR;
						return TCL_ERROR;
					}
					bu_avs_free( &avs );
@


11.71
log
@Solid to Primitive naming convention conversions
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.70 2001/11/01 22:01:23 bparker Exp $ (BRL)";
d527 1
a527 1
	char solid_name[NAMESIZE];
d563 1
a563 1
		if( strlen( prefix ) >= (NAMESIZE-3) )
d587 2
d647 1
a647 1
				strcpy( solid_name, prefix );
d649 9
a657 5
				end_prefix = strlen( prefix );
				if( end_prefix + strlen( shell_no ) >= NAMESIZE )
					end_prefix = NAMESIZE - strlen( shell_no );
				solid_name[end_prefix] = '\0';
				strncat( solid_name, shell_no, NAMESIZE-strlen(solid_name)-1 );
d659 1
a659 1
				if( db_lookup( dbip, solid_name, LOOKUP_QUIET ) != DIR_NULL )
d661 2
a662 1
					Tcl_AppendResult(interp, "decompose: cannot create unique solid name (", solid_name, ")", (char *)NULL );
d674 22
a695 4
				if( (new_dp=db_diradd( dbip, solid_name, -1, 0, DIR_SOLID, (genptr_t)&new_intern.idb_type)) == DIR_NULL )
				{
					TCL_ALLOC_ERR;
					return TCL_ERROR;;
d701 1
d713 1
@


11.70
log
@*- add "struct db_i *" parameter to ft_describe function calls
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.69 2001/10/02 19:24:33 jra Exp $ (BRL)";
d1051 1
a1051 1
		(void)fprintf(tabptr,"\n\nNumber Solids = %d  Number Regions = %d\n",
d1054 1
a1054 1
		bu_vls_printf(&tmp_vls, "Processed %d Solids and %d Regions\n",
@


11.69
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.68 2001/05/04 14:20:46 bparker Exp $ (BRL)";
d880 1
a880 1
				if( rt_functab[sol_intern.idb_type].ft_describe( &tmp_vls, &sol_intern, 1, base2local, &rt_uniresource ) < 0 )
@


11.68
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.67 2001/04/20 20:01:48 bparker Exp $ (BRL)";
d662 1
@


11.67
log
@*- replace invoke_db_wrapper with calls
   to the new C API's for wdb_obj.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.66 2001/04/05 19:35:45 morrison Exp $ (BRL)";
a113 3
#if 0
  CHECK_READ_ONLY;
#endif
a424 25

/*
 *      F _ W H I C H ( ) :	finds all regions with given region ids or air codes
 */
int
f_which(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int	argc;
     char	**argv;
{
	int		ret;

	CHECK_DBI_NULL;

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;

	ret = wdb_which_cmd(wdbp, interp, argc, argv);

	(void)signal(SIGINT, SIG_IGN);
	return ret;
}
@


11.66
log
@updated SIGNED to signed
updated CONST to const
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.65 2001/04/03 19:01:59 bparker Exp $ (BRL)";
d448 1
a448 1
	ret = invoke_db_wrapper(interp, argc, argv);
@


11.65
log
@*- get rid of warnings
*- use mkstemp instead of mktemp
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.64 2001/04/02 21:38:21 morrison Exp $ (BRL)";
d968 2
a969 2
	static CONST char sortcmd[] = "sort -n +1 -2 -o /tmp/ord_id ";
	static CONST char catcmd[] = "cat /tmp/ord_id >> ";
@


11.64
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.63 2001/03/30 21:39:12 jra Exp $ (BRL)";
d129 1
d132 3
@


11.63
log
@"solids" and "regions" commands now ignore objects that are not
solids or combinations.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.62 2001/03/23 22:05:36 jra Exp $ (BRL)";
d726 1
a726 1
	bn_mat_copy(idbuf1.i_mat, matrix);
d873 1
a873 1
						bn_mat_copy( temp_mat, old_mat );
d938 1
a938 1
				bn_mat_copy( new_mat, old_mat );
@


11.62
log
@Support for major and minor types in directory structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/utility1.c,v 11.61 2001/03/22 18:13:21 bparker Exp $ (BRL)";
d771 1
a771 1
	if( dp->d_flags & DIR_SOLID )
d861 6
d899 1
a899 1
			if( !old )
d911 1
a911 1
			if( nsoltemp )
@


11.61
log
@*- modify f_which to use invoke_db_wrapper
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/utility1.c,v 11.60 2001/03/21 22:15:58 bparker Exp $ (BRL)";
d685 6
a690 1
				if( (new_dp=db_diradd( dbip, solid_name, -1, 0, DIR_SOLID, NULL)) == DIR_NULL )
a694 5

				RT_INIT_DB_INTERNAL( &new_intern );
				new_intern.idb_type = ID_NMG;
				new_intern.idb_meth = &rt_functab[ID_NMG];
				new_intern.idb_ptr = (genptr_t)new_m;
@


11.60
log
@*- mods to use invoke_db_wrapper
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/utility1.c,v 11.59 2001/03/21 20:11:08 bparker Exp $ (BRL)";
a434 1
#if 1
a447 22
#else
	int		ret;
	struct bu_vls	vls;

	CHECK_DBI_NULL;

	bu_vls_init(&vls);
	bu_build_cmd_vls(&vls, MGED_DB_NAME, argc, argv);

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else {
		bu_vls_free(&vls);
		return TCL_OK;
	}

	ret = Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	(void)signal(SIGINT, SIG_IGN);
	return ret;
#endif
@


11.59
log
@*- use libbu's new bu_build_cmd_vls routine
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/utility1.c,v 11.58 2001/03/21 16:06:13 bparker Exp $ (BRL)";
d435 15
d470 1
@


11.58
log
@*- modify f_which to call librt's wdb_which_tcl method
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/utility1.c,v 11.57 2001/03/19 22:20:02 butler Exp $ (BRL)";
d435 2
a436 3
	register int i;
	int ret;
	struct bu_vls vls;
d441 1
a441 3
	bu_vls_strcpy(&vls, "db");
	for (i = 0; i < argc; ++i)
		bu_vls_printf(&vls, " %s", argv[i]);
@


11.57
log
@patches to merge 5.3 into 6.0
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/utility1.c,v 11.56 2001/01/08 17:11:10 bparker Exp $ (BRL)";
d430 4
a433 4
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d435 3
a437 11
	register int	i,j;
	register struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	register int sflag;
	struct id_to_names headIdName;
	struct id_to_names *itnp;
	struct id_names *inp;
	int isAir;
	int myArgc;
	char **myArgv;
a439 22
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	/*
	 * To avoid gcc -Wall: argument 'X' might be clobbered by `longjmp'
	 * or `vfork'
	 */
	myArgc = argc;
	myArgv = argv;

	if(myArgc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help %s", argv[0]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  (void)signal( SIGINT, SIG_IGN );
	  return TCL_ERROR;
	}
d441 10
a450 23
	if (!strcmp(myArgv[0], "whichair"))
	  isAir = 1;
	else
	  isAir = 0;

	if(strcmp(myArgv[1], "-s") == 0){
	  --myArgc;
	  ++myArgv;

	  if(myArgc < 2){
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "help %s", myArgv[-1]);
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    (void)signal( SIGINT, SIG_IGN );
	    return TCL_ERROR;
	  }

	  sflag = 1;
	} else {
	  sflag = 0;
d453 2
a454 49
	BU_LIST_INIT(&headIdName.l);

	/* Build list of id_to_names */
	for ( j=1; j<myArgc; j++ ) {
		int n;
		int start, end;
		int range;
		int k;

		n = sscanf(myArgv[j], "%d%*[:-]%d", &start, &end);
		switch(n) {
		case 1:
			for ( BU_LIST_FOR(itnp,id_to_names,&headIdName.l) )
				if (itnp->id == start)
					break;

			/* id not found */
			if (BU_LIST_IS_HEAD(itnp,&headIdName.l)) {
				BU_GETSTRUCT(itnp,id_to_names);
				itnp->id = start;
				BU_LIST_INSERT(&headIdName.l,&itnp->l);
				BU_LIST_INIT(&itnp->headName.l);
			}

			break;
		case 2:
			if (start < end)
				range = end - start + 1;
			else if (end < start) {
				range = start - end + 1;
				start = end;
			} else
				range = 1;

			for ( k = 0; k < range; ++k ) {
				int id = start + k;

				for ( BU_LIST_FOR(itnp,id_to_names,&headIdName.l) )
					if (itnp->id == id)
						break;

				/* id not found */
				if (BU_LIST_IS_HEAD(itnp,&headIdName.l)) {
					BU_GETSTRUCT(itnp,id_to_names);
					itnp->id = id;
					BU_LIST_INSERT(&headIdName.l,&itnp->l);
					BU_LIST_INIT(&itnp->headName.l);
				}
			}
d456 2
a457 69
			break;
		}
	}

	/* Examine all COMB nodes */
	for ( i = 0; i < RT_DBNHASH; i++ )  {
		for ( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if ( !(dp->d_flags & DIR_REGION) )
				continue;

			if ( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
			{
				(void)signal( SIGINT, SIG_IGN );
				TCL_READ_ERR_return;
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			if (comb->region_id != 0 && comb->aircode != 0 && !sflag) {
				Tcl_AppendResult(interp, "ERROR: ", dp->d_namep,
					" has id and aircode!!!\n", (char *)NULL );
				continue;
			}

			/* check to see if the region id or air code matches one in our list */
			for ( BU_LIST_FOR(itnp,id_to_names,&headIdName.l) ) {
				if ( (!isAir && comb->region_id == itnp->id) ||
				     (isAir && comb->aircode == itnp->id) ) {
					/* add region name to our name list for this region */
					BU_GETSTRUCT(inp,id_names);
					bu_vls_init(&inp->name);
					bu_vls_strcpy(&inp->name, dp->d_namep);
					BU_LIST_INSERT(&itnp->headName.l,&inp->l);
					break;
				}
			}

			rt_comb_ifree( &intern, &rt_uniresource );
		}
	}

	/* place data in interp and free memory */
	 while ( BU_LIST_WHILE(itnp,id_to_names,&headIdName.l) ) {
		if (!sflag) {
			struct bu_vls vls;

			bu_vls_init(&vls);
			bu_vls_printf(&vls, "Region[s] with %s %d:\n",
				      isAir ? "air code" : "ident", itnp->id);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
		}

		while ( BU_LIST_WHILE(inp,id_names,&itnp->headName.l) ) {
			if (sflag)
				Tcl_AppendElement(interp, bu_vls_addr(&inp->name));
			else
				Tcl_AppendResult(interp, "   ", bu_vls_addr(&inp->name),
							"\n", (char *)NULL);

			BU_LIST_DEQUEUE(&inp->l);
			bu_vls_free(&inp->name);
			bu_free((genptr_t)inp, "f_which: inp");
		}

		BU_LIST_DEQUEUE(&itnp->l);
		bu_free((genptr_t)itnp, "f_which: itnp");
	}

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
@


11.56
log
@*- Mods to edcodes and red to allow the user to view the info
   even if the database is READ_ONLY.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.55 2000/11/02 03:30:45 cjohnson Exp $ (BRL)";
d171 1
a171 1
    status = TCL_ERROR;
@


11.55
log
@Lint for
../mged/utility1.c:431: warning: variable `sflag' might be clobbered by `longjmp
' or `vfork'
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.54 2000/10/24 19:05:09 mike Exp $ (BRL)";
d114 1
d116 1
d160 10
a169 4
    regflag = lastmemb = 0;
    av[0] = "rcodes";
    av[2] = NULL;
    status = f_rcodes(clientData, interp, 2, av);
@


11.54
log
@
Fixed compiler lint, function declarations.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.53 2000/09/09 04:30:56 mike Exp $ (BRL)";
d431 1
a431 1
	register int sflag = 0;
d436 2
d440 11
d452 1
a452 1
	if(argc < 2){
d459 1
d463 1
a463 1
	if (!strcmp(argv[0], "whichair"))
d468 3
a470 3
	if(strcmp(argv[1], "-s") == 0){
	  --argc;
	  ++argv;
d472 1
a472 1
	  if(argc < 2){
d476 1
a476 1
	    bu_vls_printf(&vls, "help %s", argv[0]);
d479 1
d484 2
a487 5
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

d491 1
a491 1
	for ( j=1; j<argc; j++ ) {
d497 1
a497 1
		n = sscanf(argv[j], "%d%*[:-]%d", &start, &end);
d624 3
a626 1
	int sflag = 0;
d630 4
a633 2
	if(argc < 2){
	  struct bu_vls vls;
d635 8
a642 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help which_shader");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
d645 2
a646 3
	if(strcmp(argv[1], "-s") == 0){
	  --argc;
	  ++argv;
d648 6
a653 11
	  if(argc < 2){
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "help which_shader");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    return TCL_ERROR;
	  }

	  sflag = 1;
d656 1
a656 6
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	for( j=1; j<argc; j++) {
d659 1
a659 1
		  Tcl_AppendResult(interp, "Combination[s] with shader ", argv[j],
d674 1
a674 1
				if( !strstr( bu_vls_addr( &comb->shader ), argv[j] ) )
d709 1
a709 1
	int count=0;
d740 1
d1122 1
a1122 1
	int status = TCL_OK;
d1153 1
@


11.53
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.52 2000/09/08 05:55:49 mike Exp $ (BRL)";
d49 1
@


11.52
log
@
Tree routines now need resource structure.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.51 2000/08/24 04:32:09 mike Exp $ (BRL)";
d1046 1
a1046 1
				if( rt_functab[sol_intern.idb_type].ft_describe( &tmp_vls, &sol_intern, 1, base2local ) < 0 )
@


11.51
log
@
Somebody called the wrong free routine
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.50 2000/08/22 06:49:08 mike Exp $ (BRL)";
d276 1
a276 1
  	if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL ) != ID_COMBINATION )
d291 1
a291 1
  	if( rt_db_put_internal( dp, dbip, &intern ) )
d295 1
a295 1
  		rt_db_free_internal( &intern );
d351 1
a351 1
	if( (id=rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL ) ) < 0 )
d374 1
a374 1
		rt_comb_ifree( &intern );
d385 1
a385 1
	rt_comb_ifree( &intern );
d535 1
a535 1
			if ( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d560 1
a560 1
			rt_comb_ifree( &intern );
d659 1
a659 1
				if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d673 1
a673 1
				rt_comb_ifree( &intern );
d748 1
a748 1
	if( rt_db_get_internal( &nmg_intern, dp, dbip, bn_mat_identity ) < 0 )
d845 1
a845 1
				if( rt_db_put_internal( new_dp, dbip, &new_intern ) < 0 )
d858 1
a858 1
	rt_db_free_internal( &nmg_intern );
d923 1
a923 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d931 1
a931 1
		db_non_union_push( comb->tree );
d935 1
a935 1
			rt_comb_ifree( &intern );
d943 1
a943 1
		rt_comb_ifree( &intern );
d952 2
a953 1
	actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION, 0 ) - tree_list;
d1018 1
a1018 1
					if( rt_db_get_internal( &sol_intern, sol_dp, dbip, temp_mat ) < 0 )
d1055 1
a1055 1
				rt_db_free_internal( &sol_intern );
d1096 1
a1096 1
	rt_comb_ifree( &intern );
@


11.50
log
@
db_flatten_tree() got an additional argument, to prevent memory leaks.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.49 2000/08/19 03:10:18 mike Exp $ (BRL)";
d295 1
a295 1
  		rt_comb_ifree( comb );
d935 1
a935 1
			rt_comb_ifree( comb );
@


11.49
log
@
Reduced use of MAXARGS
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.48 2000/03/31 18:14:18 bparker Exp $ (BRL)";
d952 2
a953 3
	actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
	if( actual_count > node_count )  bu_bomb("combadd() array overflow!");
	if( actual_count < node_count )  bu_log("WARNING combadd() array underflow! %d", actual_count, node_count);
@


11.48
log
@*- mods to f_which to not print
   error messages about air/rid conflicts
   if sflag is set.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.47 2000/03/30 19:02:45 jra Exp $ (BRL)";
d84 1
a84 1
int discr[MAXARGS], idfd, rd_idfd;
d115 1
a115 1
  if(argc < 2 || MAXARGS < argc){
d185 1
a185 1
  if(argc < 3 || MAXARGS < argc){
d393 1
d438 1
a438 1
	if(argc < 2 || MAXARGS < argc){
d615 1
a615 1
	if(argc < 2 || MAXARGS < argc){
d1119 1
a1119 1
	if(argc < 3 || MAXARGS < argc){
@


11.48.2.1
log
@*- mods to edcodes and red to allow the user to view the info
   even if the database is READ_ONLY
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.48 2000/03/31 18:14:18 bparker Exp $ (BRL)";
a112 1
#if 0
a113 1
#endif
d157 4
a160 10
	  regflag = lastmemb = 0;

	  if (!dbip->dbi_read_only) {
		  av[0] = "rcodes";
		  av[2] = NULL;
		  status = f_rcodes(clientData, interp, 2, av);
	  } else {
		  Tcl_AppendResult(interp, "Because the database is READ-ONLY no changes were made.\n", (char *)NULL);
		  status = TCL_OK;
	  }
d162 1
a162 1
	  status = TCL_ERROR;
@


11.47
log
@
Fixed an incorrect parameter in a call to nmg_dup_shell()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.46 2000/01/06 22:06:55 mike Exp $ (BRL)";
d540 1
a540 2
			if( comb->region_id != 0 && comb->aircode != 0 )
			{
@


11.46
log
@
Changed uses of rt_units_* routines to bu_units_*
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.45 1999/12/30 20:05:06 jra Exp $ (BRL)";
d779 1
a779 1
			long *trans_tbl;
@


11.45
log
@Eliminated some unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.44 1999/12/29 23:23:27 mike Exp $ (BRL)";
d1191 1
a1191 1
		rt_units_string(dbip->dbi_local2base) );
@


11.44
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.43 1999/12/28 19:43:10 bparker Exp $ (BRL)";
a335 3
	int status;
	int nparts;
	struct directory *nextdp;
a428 1
	int		item;
a610 1
	int item;
a647 1
		item = atoi( argv[j] );
a869 1
	int ret_sol_no=0;
@


11.43
log
@*- mktemp requires six X's in the template; the template must also
   be declared as an array of char's
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.42 1999/11/26 23:03:33 mike Exp $ (BRL)";
d840 1
a840 1
				if( (new_dp=db_diradd( dbip, solid_name, -1, 0, DIR_SOLID)) == DIR_NULL )
@


11.42
log
@
Lint
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.41 1999/11/24 14:26:42 jra Exp $ (BRL)";
d89 4
a109 1
  char tmpfil[128];
d125 1
a125 2
  strcpy( tmpfil, "/tmp/GED.aXXXXX" );

@


11.41
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.40 1999/09/01 18:55:12 bparker Exp $ (BRL)";
d536 1
a536 1
			if ( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d663 1
a663 1
				if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
d928 1
a928 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
@


11.40
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.39 1999/08/05 20:04:21 mike Exp $ (BRL)";
d846 1
@


11.39
log
@
Fixed problem with mktemp() writing on read-only string.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.38 1999/08/05 13:32:45 jra Exp $ (BRL)";
d109 1
a109 3
  if(dbip == DBI_NULL)
    return TCL_OK;

d181 1
a181 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d231 1
a231 3
  if(dbip == DBI_NULL)
    return TCL_OK;

d341 1
a341 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d437 1
a437 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d616 1
a616 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d717 1
a717 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1121 1
a1121 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
@


11.38
log
@
Modified Printcodes() to add a space between fields.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.37 1999/02/02 18:09:23 bparker Exp $ (BRL)";
d106 1
a106 1
  char *tmpfil = "/tmp/GED.aXXXXX";
d123 2
@


11.37
log
@*- collapse f_which_id and f_which_air into f_which
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.36 1999/02/01 19:28:24 jra Exp $ (BRL)";
d371 1
a371 1
		fprintf(fp, "%-6d%-3d%-3d%-4d  ",
@


11.36
log
@whichair now complains about regions wih both an aircode and region_id.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.35 1998/10/22 18:51:14 bparker Exp $ (BRL)";
d416 1
a416 1
	int rid;			/* starting region id */
d421 1
a421 1
 *	F _ W H I C H _ I D ( ) :	finds all regions with given idents
d424 1
a424 1
f_which_id(clientData, interp, argc, argv )
d439 1
d441 1
a441 1
	if (dbip == DBI_NULL)
d444 1
a444 1
	if (argc < 2 || MAXARGS < argc){
d448 1
a448 1
	  bu_vls_printf(&vls, "help whichid");
d454 6
a459 1
	if (strcmp(argv[1], "-s") == 0){
d467 1
a467 1
	    bu_vls_printf(&vls, "help whichid");
d476 1
a476 1
	if ( setjmp( jmp_env ) == 0 )
d494 1
a494 1
				if (itnp->rid == start)
d497 1
a497 1
			/* rid not found */
d500 1
a500 1
				itnp->rid = start;
d516 1
a516 1
				int rid = start + k;
d519 1
a519 1
					if (itnp->rid == rid)
d522 1
a522 1
				/* rid not found */
d525 1
a525 1
					itnp->rid = rid;
d547 6
d554 1
a554 1
			/* check to see if region id matches one in our list */
d556 2
a557 1
				if ( comb->region_id == itnp->rid ) {
d577 2
a578 1
			bu_vls_printf(&vls, "Region[s] with ident %d:\n", itnp->rid);
d592 1
a592 1
			bu_free((genptr_t)inp, "f_which_id: inp");
d596 1
a596 1
		bu_free((genptr_t)itnp, "f_which_id: itnp");
a683 92
			}
		}
	}

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}

/*
 *	F _ W H I C H _ A I R ( ) :	finds all regions with given air codes
 */
int
f_which_air(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	register int	i,j;
	register struct directory *dp;
	int		item;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int sflag = 0;

	if(dbip == DBI_NULL)
	  return TCL_OK;

	if(argc < 2 || MAXARGS < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help whichair");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if(strcmp(argv[1], "-s") == 0){
	  --argc;
	  ++argv;

	  if(argc < 2){
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "help whichair");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    return TCL_ERROR;
	  }

	  sflag = 1;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
        else
	  return TCL_OK;

	for( j=1; j<argc; j++) {
		item = atoi( argv[j] );

		if(!sflag)
		  Tcl_AppendResult(interp, "Region[s] with air code ", argv[j],
				   ":\n", (char *)NULL);

		/* Examine all COMB nodes */
		for( i = 0; i < RT_DBNHASH; i++ )  {
			for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
				if( !(dp->d_flags & DIR_REGION) )
					continue;
				if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
				{
					(void)signal( SIGINT, SIG_IGN );
					TCL_READ_ERR_return;
				}
				comb = (struct rt_comb_internal *)intern.idb_ptr;
				if( comb->region_id != 0 && comb->aircode != 0 )
				{
					Tcl_AppendResult(interp, "ERROR: ", dp->d_namep,
						" has id and aircode!!!\n", (char *)NULL );
					continue;
				}
				if( comb->region_id != 0 || comb->aircode != item )
					continue;

				if(sflag)
				  Tcl_AppendElement(interp, dp->d_namep);
				else
				  Tcl_AppendResult(interp, "   ", dp->d_namep,
						   "\n", (char *)NULL);
@


11.35
log
@*-
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.34 1998/09/08 13:55:56 bparker Exp $ (BRL)";
d748 6
@


11.34
log
@*- rewrote whichid to loop through the database at most one time.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/utility1.c,v 11.33 1998/03/20 22:55:36 bparker Exp $ (BRL)";
d435 1
a435 1
	int sflag = 0;
@


11.33
log
@add -s option to whichid, whichair and which_shader
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.32 1997/12/18 06:39:24 mike Exp bparker $ (BRL)";
d409 11
d436 3
d440 1
a440 1
	if(dbip == DBI_NULL)
d443 1
a443 1
	if(argc < 2 || MAXARGS < argc){
d453 1
a453 1
	if(strcmp(argv[1], "-s") == 0){
d470 1
a470 1
	if( setjmp( jmp_env ) == 0 )
d475 23
a497 2
	for( j=1; j<argc; j++) {
		item = atoi( argv[j] );
d499 23
a521 13
		if(!sflag)
		  Tcl_AppendResult(interp, "Region[s] with ident ", argv[j],
				   ":\n", (char *)NULL);

		/* Examine all COMB nodes */
		for( i = 0; i < RT_DBNHASH; i++ )  {
			for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
				if( !(dp->d_flags & DIR_REGION) )
					continue;
				if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
				{
					(void)signal( SIGINT, SIG_IGN );
					TCL_READ_ERR_return;
d523 5
a527 9
				comb = (struct rt_comb_internal *)intern.idb_ptr;
				if( comb->region_id != item )
					continue;

				if(sflag)
				  Tcl_AppendElement(interp, dp->d_namep);
				else
				  Tcl_AppendResult(interp, "   ", dp->d_namep,
						   "\n", (char *)NULL);
d529 10
a538 1
				rt_comb_ifree( &intern );
d540 39
d580 3
d588 1
@


11.32
log
@tl_mat of NULL means identity matrix.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.31 1997/11/24 15:56:02 jra Exp mike $ (BRL)";
d424 1
d439 17
a462 2
		Tcl_AppendResult(interp, "Region[s] with ident ", argv[j],
				 ":\n", (char *)NULL);
d464 4
d482 5
a486 2
				Tcl_AppendResult(interp, "   ", dp->d_namep,
						 "\n", (char *)NULL);
d512 1
d527 17
d551 4
a554 2
		Tcl_AppendResult(interp, "Combination[s] with shader ", argv[j],
				 ":\n", (char *)NULL);
d571 5
a575 2
				Tcl_AppendResult(interp, "   ", dp->d_namep,
						 "\n", (char *)NULL);
d600 1
d615 17
d639 4
a642 2
		Tcl_AppendResult(interp, "Region[s] with air code ", argv[j],
				 ":\n", (char *)NULL);
d658 5
a662 2
				Tcl_AppendResult(interp, "   ", dp->d_namep,
						 "\n", (char *)NULL);
@


11.31
log
@fixed a bug in new_tables().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.30 1997/07/01 22:09:08 bparker Exp jra $ (BRL)";
d934 6
a939 2
					bn_mat_mul( temp_mat, old_mat,
						tree_list[i].tl_tree->tr_l.tl_mat );
d1000 5
a1004 1
			bn_mat_mul( new_mat, old_mat, tree_list[i].tl_tree->tr_l.tl_mat );
@


11.30
log
@mods to run without a database
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.29 1997/05/23 18:46:28 jra Exp bparker $ (BRL)";
d978 2
d981 1
d998 1
@


11.29
log
@fixed bug in f_whichid().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.28 1997/05/23 18:30:18 jra Exp jra $ (BRL)";
d109 3
d181 3
d232 3
d344 3
d425 3
d490 3
d555 3
d633 3
d836 3
d1026 3
@


11.28
log
@Fixed bugs in new_tables() and f_whichair().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.27 1997/04/24 18:03:58 bparker Exp jra $ (BRL)";
d436 1
a436 2
				if( (dp->d_flags & DIR_COMB|DIR_REGION) !=
				    (DIR_COMB|DIR_REGION) )
@


11.27
log
@modify calls to Tcl_Eval
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.26 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d561 1
a561 2
				if( (dp->d_flags & DIR_COMB|DIR_REGION) !=
				    (DIR_COMB|DIR_REGION) )
d834 7
@


11.26
log
@mods so that commands check args internally
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.25 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d112 6
a117 1
    Tcl_Eval(interp, "help edcodes");
d179 6
a184 1
    Tcl_Eval(interp, "help wcodes");
d229 6
a234 1
    Tcl_Eval(interp, "help rcodes");
d414 7
a420 2
	      Tcl_Eval(interp, "help whichid");
	          return TCL_ERROR;
d477 6
a482 1
	  Tcl_Eval(interp, "help which_shader");
d539 6
a544 1
	  Tcl_Eval(interp, "help whichair");
d617 6
a622 1
	  Tcl_Eval(interp, "help decompose");
@


11.25
log
@Mods to support MGED's read-only mode.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.24 1997/03/20 14:42:51 bparker Exp jra $ (BRL)";
d109 1
a109 1
	CHECK_READ_ONLY;
d111 2
a112 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d114 1
d173 2
a174 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d176 1
d207 8
a214 8
	int item, air, mat, los;
	char name[MAX_LEVELS * NAMESIZE];
	char line[LINELEN];
	char *cp;
	FILE *fp;
	register struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
d216 1
a216 1
	CHECK_READ_ONLY;
d218 2
a219 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d221 1
d398 4
a401 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d456 2
a457 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d459 1
d513 2
a514 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d516 1
d586 2
a587 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d589 1
d960 7
a966 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d968 2
@


11.24
log
@add type cast
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.23 1997/02/28 21:21:03 jra Exp bparker $ (BRL)";
d109 2
d212 2
d571 2
@


11.23
log
@removed NAMESIZE definition.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.22 1997/02/24 21:34:14 jra Exp jra $ (BRL)";
d729 1
a729 1
		if( check( &idbuf1, &idbuf2 ) == 1 )
@


11.22
log
@Convert to using combination import/export. (rewrote f_tables).
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.21 1997/01/30 02:21:44 mike Exp jra $ (BRL)";
a55 1
#define NAMESIZE	16	/* from db.h */
@


11.21
log
@Eliminated db_get_comb
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.20 1997/01/29 16:39:46 jra Exp mike $ (BRL)";
a44 1
#include "db.h"
d56 1
d64 1
a64 1
	char	i_name[NAMESIZE];
a68 2
static union record record;

a88 150
int
f_tables(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{

	register struct directory *dp;
	register int i;
	char *timep;
	time_t now;
	static CONST char sortcmd[] = "sort -n +1 -2 -o /tmp/ord_id ";
	static CONST char catcmd[] = "cat /tmp/ord_id >> ";
	int status = TCL_OK;
	struct bu_vls tmp_vls;
	struct bu_vls	cmd;


	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;

	bu_vls_init(&tmp_vls);
	bu_vls_init( &cmd );

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else{
	  bu_vls_free( &cmd );
	  bu_vls_free(&tmp_vls);
	  return TCL_OK;
	}

	/* find out which ascii table is desired */
	if( strcmp(argv[0], "solids") == 0 ) {
		/* complete summary - down to solids/paremeters */
		flag = SOL_TABLE;
	}
	else if( strcmp(argv[0], "regions") == 0 ) {
		/* summary down to solids as members of regions */
		flag = REG_TABLE;
	}
	else if( strcmp(argv[0], "idents") == 0 ) {
		/* summary down to regions */
		flag = ID_TABLE;
	}
	else {
		/* should never reach here */
	  Tcl_AppendResult(interp, "tables:  input error\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	regflag = numreg = lastmemb = numsol = 0;
	tabptr = NULL;

	/* open the file */
	if( (tabptr=fopen(argv[1], "w+")) == NULL ) {
	  Tcl_AppendResult(interp, "Can't open ", argv[1], "\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	if( flag == SOL_TABLE || flag == REG_TABLE ) {
		/* temp file for discrimination of solids */
		if( (idfd = creat("/tmp/mged_discr", 0600)) < 0 ) {
			perror( "/tmp/mged_discr" );
			status = TCL_ERROR;
			goto end;
		}
		rd_idfd = open( "/tmp/mged_discr", 2 );
	}

	(void)time( &now );
	timep = ctime( &now );
	timep[24] = '\0';
	(void)fprintf(tabptr,"1 -8    Summary Table {%s}  (written: %s)\n",argv[0],timep);
	(void)fprintf(tabptr,"2 -7         file name    : %s\n",dbip->dbi_filename);    
	(void)fprintf(tabptr,"3 -6         \n");
	(void)fprintf(tabptr,"4 -5         \n");
	(void)fprintf(tabptr,"5 -4         user         : %s\n",getpwuid(getuid())->pw_gecos);
	(void)fprintf(tabptr,"6 -3         target title : %s\n",cur_title);
	(void)fprintf(tabptr,"7 -2         target units : %s\n",
		rt_units_string(dbip->dbi_local2base) );
	(void)fprintf(tabptr,"8 -1         objects      :");
	for(i=2; i<argc; i++) {
		if( (i%8) == 0 )
			(void)fprintf(tabptr,"\n                           ");
		(void)fprintf(tabptr," %s",argv[i]);
	}
	(void)fprintf(tabptr,"\n\n");

	/* make table of the objects */
#if 0
	bn_mat_idn( identity );
#endif
	for(i=2; i<argc; i++) {
		if( (dp = db_lookup( dbip, argv[i],LOOKUP_NOISY)) != DIR_NULL )
			tables(dp, 0, identity, flag);
		else
		  Tcl_AppendResult(interp, " skip this object\n", (char *)NULL);
	}

	Tcl_AppendResult(interp, "Summary written in: ", argv[1], "\n", (char *)NULL);

	if( flag == SOL_TABLE || flag == REG_TABLE ) {
		/* remove the temp file */
		(void)unlink( "/tmp/mged_discr\0" );
		(void)fprintf(tabptr,"\n\nNumber Solids = %d  Number Regions = %d\n",
				numsol,numreg);

		bu_vls_printf(&tmp_vls, "Processed %d Solids and %d Regions\n",
			      numsol,numreg);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);

		(void)fclose( tabptr );
	}

	else {
		(void)fprintf(tabptr,"* 9999999\n* 9999999\n* 9999999\n* 9999999\n* 9999999\n");
		(void)fclose( tabptr );

		bu_vls_printf(&tmp_vls, "Processed %d Regions\n",numreg);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);

		/* make ordered idents */
		bu_vls_strcpy( &cmd, sortcmd );
		bu_vls_strcat( &cmd, argv[1] );
		Tcl_AppendResult(interp, bu_vls_addr(&cmd), "\n", (char *)NULL);
		(void)system( bu_vls_addr(&cmd) );

		bu_vls_trunc( &cmd, 0 );
		bu_vls_strcpy( &cmd, catcmd );
		bu_vls_strcat( &cmd, argv[1] );
		Tcl_AppendResult(interp, bu_vls_addr(&cmd), "\n", (char *)NULL);
		(void)system( bu_vls_addr(&cmd) );

		(void)unlink( "/tmp/ord_id\0" );
	}

end:
	bu_vls_free( &cmd );
	bu_vls_free(&tmp_vls);
	(void)signal( SIGINT, SIG_IGN );
	return status;
}




d136 7
d199 2
a200 2
int     argc;
char    *argv[];
d202 8
a209 6
  int item, air, mat, los;
  char name[MAX_LEVELS * NAMESIZE];
  char line[LINELEN];
  char *cp;
  FILE *fp;
  register struct directory *dp;
d212 1
a212 1
        return TCL_ERROR;
d238 28
a265 2
    if( db_get( dbip, dp, &record, 0, 1) < 0 )
      TCL_READ_ERR_return;
a266 13
    /* make the changes */
    record.c.c_regionid = item;
    record.c.c_aircode = air;
    record.c.c_material = mat;
    record.c.c_los = los;

    /* write out all changes */
    if( db_put( dbip, dp, &record, 0, 1 ) < 0 ){
      Tcl_AppendResult(interp, "Database write error, aborting.\n",
		       (char *)NULL);
      TCL_ERROR_RECOVERY_SUGGESTION;
      return TCL_ERROR;
    }
d272 6
a277 6

int
printcodes(fp, dp, pathpos)
FILE *fp;
struct directory *dp;
int pathpos;
d279 3
a281 4
  int i;
  int status;
  int nparts;
  struct directory *nextdp;
d283 2
a284 4
  if(pathpos >= MAX_LEVELS){
    regflag = ABORTED;
    return TCL_ERROR;
  }
d286 2
a287 37
  if( db_get( dbip, dp, &record, 0, 1) < 0 )
    return TCL_ERROR;

  if( record.u_id == ID_COMB ){
    if(regflag > 0){
      if(record.c.c_flags != 'R'){
	fprintf(fp, "**WARNING** group= %s is member of region= ",record.c.c_name);

	for(i=0; i < pathpos; i++)
	  fprintf(fp, "/%s",path[i]->d_namep);

	fprintf(fp, "\n");
      }

      if(lastmemb)
	regflag = lastmemb = 0;

      return TCL_OK;
    }

    regflag = 0;
    nparts = dp->d_len-1;
    if(record.c.c_flags == 'R'){
      /* first region in this path */
      regflag = 1;

      if( nparts == 0 )	/* dummy region */
	regflag = 0;

      fprintf(fp, "%-6d%-3d%-3d%-4d  ",record.c.c_regionid,record.c.c_aircode,
	      record.c.c_material,record.c.c_los);

      for(i=0; i < pathpos; i++)
	fprintf(fp, "/%s",path[i]->d_namep);

      fprintf(fp, "/%s%s\n", record.c.c_name, nparts==0 ? " **DUMMY REGION**" : "");
    }
d289 2
a290 4
    lastmemb = 0;
    for(i=1; i<=nparts; i++) {
      if(i == nparts)
	lastmemb = 1;
d292 3
a294 27
      if( db_get( dbip, dp, &record, i, 1) < 0 ){
	TCL_READ_ERR_return;
      }

      path[pathpos] = dp;
      if( (nextdp = db_lookup( dbip, record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
	continue;

      /* Recursive call */
      status = printcodes(fp, nextdp, pathpos+1);
      if(status == TCL_ERROR)
	return TCL_ERROR;
    }

    return TCL_OK;
  }      

  /* not a combination  -  should have a solid */

  /* last (bottom) position */
  path[pathpos] = dp;

  if( lastmemb ){
    regflag = lastmemb = 0;
  }

  return TCL_OK;
d297 4
a300 9
/*
 *
 *		T A B L E S ( ) :    builds ascii tables (summary)
 *
 *
 */
void
tables( dp, pathpos, old_xlate, flag)
register struct directory *dp;
a301 2
mat_t old_xlate;
int flag;
d303 3
a305 1

d307 3
a309 15
	mat_t new_xlate;
	int nparts, i, k;
	int	nsoltemp;
	int dchar = 0;
	struct bu_vls str;

	bu_vls_init( &str );

	if( pathpos >= MAX_LEVELS ) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "nesting exceeds %d levels\n",MAX_LEVELS);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
d311 4
a314 5
	  for(i=0; i<MAX_LEVELS; i++)
	    Tcl_AppendResult(interp, "/", path[i]->d_namep, (char *)NULL);

	  Tcl_AppendResult(interp, "\n", (char *)NULL);
	  return;
d317 2
a318 15
	if( db_get( dbip, dp, &record, 0, 1) < 0 )  READ_ERR_return;
	if( record.u_id == ID_COMB ) {
		if(regflag > 0) {
			/* this comb record is part of a region */
			if(record.c.c_flags == 'R') {
				oper_ok++;
				if(flag == SOL_TABLE || flag == REG_TABLE)
					(void)fprintf(tabptr,"   RG %c %s\n",operate,record.c.c_name);
			}
			else {
			  Tcl_AppendResult(interp, "**WARNING** group= ", record.c.c_name,
					   " is member of region= ", (char *)NULL);

			  for(k=0;k<pathpos;k++)
			    Tcl_AppendResult(interp, "/", path[k]->d_namep, (char *)NULL);
d320 5
a324 58
			  Tcl_AppendResult(interp, "\n", (char *)NULL);
			}
			if(lastmemb)
				regflag = lastmemb = 0;
			return;
		}
		regflag = 0;
		nparts = dp->d_len-1;
		if(record.c.c_flags == 'R') {
			/* first region in this path */
			numreg++;
			regflag = 1;

			if( nparts <= 0 )	/* dummy region */
				regflag = 0;

			oper_ok = 0;

			/*
			 * This format depends on %4d getting wider
			 * when the numbers exceeds 9999.
			 * MUVES *depends* on the fields being white-space
			 * separated, but doesn't care about field width.
			 * Lack of spaces also confuses the IDENT command's sort.
			 */
			(void)fprintf(tabptr,
				" %-4d %4d %4d %4d %4d  ",
				numreg,record.c.c_regionid,
				record.c.c_aircode,record.c.c_material,
				record.c.c_los);
			for(k=0;k<pathpos;k++) {
				(void)fprintf(tabptr,"/%s",path[k]->d_namep);
			}
			(void)fprintf(tabptr,"/%s:\n",record.c.c_name);
		}
		lastmemb = 0;
		for(i=1; i<=nparts; i++) {
			mat_t	xmat;

			if(i == nparts)
				lastmemb = 1;
			if( db_get( dbip, dp, &record, i, 1) < 0 )  READ_ERR_return;
			operate = record.M.m_relation;

			if(regflag && operate != SUBTRACT)
				oper_ok++;

			path[pathpos] = dp;
			if( (nextdp = db_lookup( dbip, record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
				continue;

			rt_mat_dbmat( xmat, record.M.m_mat );
			bn_mat_mul(new_xlate, old_xlate, xmat);

			/* Recursive call */
			tables(nextdp, pathpos+1, new_xlate, flag);
		}
		return;
d327 2
a328 1
	/* not a combination  -  should have a solid */
d330 2
a331 2
	/* last (bottom) position */
	path[pathpos] = dp;
d333 12
a344 9
	if(regflag == 0) {
	  /* have a solid that's not part of a region */
	  Tcl_AppendResult(interp, "**WARNING** following path (solid) has no region:\n",
			   (char *)NULL);

	  for(k=0;k<=pathpos;k++)
	    Tcl_AppendResult(interp, "/", path[k]->d_namep, (char *)NULL);

	  Tcl_AppendResult(interp, "\n", (char *)NULL);
d347 5
a351 8
	if( regflag && lastmemb && oper_ok == 0 ) {
	  Tcl_AppendResult(interp, "**WARNING** following region has only '-' oprations:\n",
			   (char *)NULL);

	  for(k=0; k<pathpos; k++)
	    Tcl_AppendResult(interp, "/", path[k]->d_namep, (char *)NULL);

	  Tcl_AppendResult(interp, "\n", (char *)NULL);
d354 2
a355 84
	if(flag == ID_TABLE) {
		if(lastmemb)
			regflag = lastmemb = 0;
		return;
	}

	/* check if this is a new or old solid */
	if(record.u_id == ID_SOLID) {
		(void)strncpy(identt.i_name, record.s.s_name, NAMESIZE);
	}
	else {
		(void)strncpy(identt.i_name, record.a.a_name, NAMESIZE);
	}
	bn_mat_copy(identt.i_mat, old_xlate);

	/* first (quick) look discriminator is based on name alone */
	dchar = 0;
	for(i=0; i<NAMESIZE; i++) {
		if(identt.i_name[i] == 0) 
			break;
		dchar += (identt.i_name[i] << (i&7));
	}

	/* now check if solid is an old one -- method:
		1.  check quick look method
		2.  if quick look match check long method
	 */
	nsoltemp = 0;
	for(i=0; i<numsol; i++) {
		if(dchar == discr[i]) {
			/* have a quick look match - check further */
			(void)lseek(rd_idfd, i*(long)sizeof identt, 0);
			(void)read(rd_idfd, &idbuf, sizeof identt);
			identt.i_index = i + 1;
			if( check(&identt, &idbuf) == 1 ) {
				/* really is old...number = i+1 */
				nsoltemp = i + 1;
				old_or_new = OLDSOLID;
				goto notnew;
			}
			/* false alarm - quick look match but the
			      	long check indicates is not really old
			 */
		}
	}

	/* Have a NEW solid */
	old_or_new = NEWSOLID;
	discr[numsol++] = dchar;
	identt.i_index = numsol;
	if(numsol > MAXARGS) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "tables: number of solids > max (%d)\n",MAXARGS);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);

	  exit(10);
	}
	(void)lseek(idfd, (off_t)0L, 2);
	(void)write(idfd, &identt, sizeof identt);
	nsoltemp = numsol;

	notnew:		/* sent here if solid is an old one */

	if( regflag == 0 ) {
		(void)fprintf(tabptr,"\n\n***** NO REGION for the following solid:\n");
	}

	(void)fprintf(tabptr,"   %c [%d] ",
		operate,nsoltemp);
	if(lastmemb) {
		regflag = 0;
		lastmemb = 0;
	}
	if(flag == REG_TABLE || old_or_new == OLDSOLID) {
		(void)fprintf(tabptr,"%s\n", dp->d_namep);
		return;
	}

	/* Pretty-print the solid */
	do_list( &str, dp, 1 );		/* verbose */
	fprintf(tabptr, bu_vls_addr(&str));
a357 1

a372 236



/*   E D I T L I N E :   allows the user to edit a line of region codes
 */

#define TAB		9
#define BLANK		32
#define BACKSPACE	8
#define CONTROLC	3
#define CRETURN		13
#define LINEFEED	10
#define RESTORE		82	/* R */
#define QUIT_q		113	/* q */

int item, air, mat, los;	/* temp values */

int
editline(dp)
struct directory	*dp;
{

	int	c;
	int field, lpos, eflag, i;
	int elflag, maxpos[4];
 	lpos = eflag = field = elflag = 0;

	/* field lengths */
	maxpos[0] = 6;
	maxpos[1] = maxpos[2] = 3;
	maxpos[3] = 4;

	item = record.c.c_regionid;
	air = record.c.c_aircode;
	mat = record.c.c_material;
	los = record.c.c_los;

	while( c = getchar() ) {
		switch( c )  {

			case TAB:
			case BLANK:
				/* record any changes to this field */
				if( elflag && lpos > 0 ) {
					ctemp[lpos] = c;
					changes( field );
					elflag = 0;
				}

				/* move cursor to beginning of next field */
				if(lpos == 0) 
					prfield(field);
				else {
				  for(i=0;i<(maxpos[field] - lpos); i++)
				    Tcl_AppendResult(interp, " ", (char *)NULL);
				}

				lpos = 0;
				if(++field > 3) {
				  Tcl_AppendResult(interp, "\r", (char *)NULL);
				  field = 0;
				}
			break;

			case BACKSPACE:
				if(lpos > 0) {
				  Tcl_AppendResult(interp, "\b", (char *)NULL);
				  lpos--;
				}
				else {
					/* go to beginning of previous field */
					if(elflag) {
						/* this field changed on screen
						 *   but change was not recorded.
						 *   Print out latest recorded
						 *   value.
						 */
						prfield(field);
						elflag = 0;
						for(i=0;i<maxpos[field];i++)
						  Tcl_AppendResult(interp, "\b", (char *)NULL);
					}
					if(field == 0)
						break;
					field--;
					for(i=0; i<maxpos[field]; i++)
					  Tcl_AppendResult(interp, "\b", (char *)NULL);
				}
			break;

			case CRETURN:
			  Tcl_AppendResult(interp, "\r\n", (char *)NULL);
			  if(eflag) {
			    if(elflag) {
			      /* change present field */
			      ctemp[lpos] = ' ';
			      elflag = 0;
			      changes( field );
			    }
			    /* update the record with changes */
			    record.c.c_regionid = item;
			    record.c.c_aircode = air;
			    record.c.c_material = mat;
			    record.c.c_los = los;
			    /* write out all changes */
			    if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  {
			      Tcl_AppendResult(interp, "Database write error, aborting.\n",
					       (char *)NULL);
			      TCL_ERROR_RECOVERY_SUGGESTION;
			      return(1);
			    }
			  }
			  /* get out of loop */
			  return(0);

			case QUIT_q:
				/* 'q' entered ==> quit the editing */
			case CONTROLC:
			  Tcl_AppendResult(interp, "\r\n", (char *)NULL);
			  return(1);

			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
			  /* integer was input */
			  eflag++;
			  if(lpos < maxpos[field]) {
			    struct bu_vls tmp_vls;

			    elflag++;
			    bu_vls_init(&tmp_vls);
			    bu_vls_printf(&tmp_vls, "%c", c );
			    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			    bu_vls_free(&tmp_vls);
			    ctemp[lpos++] = c;
			  }
			  else {
			    Tcl_AppendResult(interp, "\a\a", (char *)NULL);
			  }
			  break;

			case RESTORE:
			  /* 'R' was input - restore the line */
			  item = record.c.c_regionid;
			  air = record.c.c_aircode;
			  mat = record.c.c_material;
			  los = record.c.c_los;
			  lpos = field = eflag = elflag = 0;

			  {
			    struct bu_vls tmp_vls;

			    bu_vls_init(&tmp_vls);
			    bu_vls_printf(&tmp_vls, "\r%-6d%-3d%-3d%-4d\r",item,air,mat,los);
			    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			    bu_vls_free(&tmp_vls);
			  }

			  break;

			default:
			  Tcl_AppendResult(interp, "\a", (char *)NULL);

			  break;
		}	/* end of switch */
	}	/* end of while loop */
	return(1);	/* We should never get here */
}

/*
 *			C H A N G E S 
 */
void
changes( num )
int num;
{

	switch( num ) {

		case 0:
			item = atoi( ctemp );
		break;

		case 1:
			air = atoi( ctemp );
		break;

		case 2:
			mat = atoi( ctemp );
		break;

		case 3:
			los = atoi( ctemp );
		break;

	}
	return;
}

/*
 *			P R F I E L D
 */
void
prfield( num )
int num;
{
  struct bu_vls tmp_vls;

  bu_vls_init(&tmp_vls);
  switch( num ) {
  case 0:
    bu_vls_printf(&tmp_vls, "%-6d",item);
    break;
  case 1:
    bu_vls_printf(&tmp_vls, "%-3d",air);
    break;
  case 2:
    bu_vls_printf(&tmp_vls, "%-3d",mat);
    break;
  case 3:
    bu_vls_printf(&tmp_vls, "%-4d",los);
    break;
  }

  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
  return;
}

a382 1
	union record	rec;
d385 2
d408 4
a411 3
				if( db_get( dbip, dp, &rec, 0, 1 ) < 0 ) {
				  (void)signal( SIGINT, SIG_IGN );
				  TCL_READ_ERR_return;
d413 2
a414 1
				if( rec.c.c_regionid != item )
d417 1
a417 1
				Tcl_AppendResult(interp, "   ", rec.c.c_name,
d419 2
d443 1
d465 1
a493 1
	union record	rec;
d497 2
d519 4
a522 3
				if( db_get( dbip, dp, &rec, 0, 1 ) < 0 ) {
				  (void)signal( SIGINT, SIG_IGN );
				  TCL_READ_ERR_return;
d524 2
a525 1
				if( rec.c.c_regionid != 0 || rec.c.c_aircode != item )
d528 1
a528 1
				Tcl_AppendResult(interp, "   ", rec.c.c_name,
d707 361
@


11.20
log
@Added which_shader command.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.19 1997/01/02 19:35:05 bparker Exp jra $ (BRL)";
d1054 2
a1055 4
				if( rt_get_comb( &intern, dp, (mat_t *)NULL, dbip ) < 0 )  {
					Tcl_AppendResult(interp, "rt_get_comb(", dp->d_namep,
						") failure", (char *)NULL );
					return TCL_ERROR;
@


11.19
log
@mods to use libbn and libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.18 1996/10/25 16:51:53 jra Exp bparker $ (BRL)";
d1019 56
d1125 11
@


11.18
log
@Minor mods to account for changes in nmg_dup_shell().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.17 1996/10/17 17:27:29 bparker Exp jra $ (BRL)";
d43 1
d51 1
a51 1
extern struct rt_tol    mged_tol;       /* from ged.c */
d185 1
a185 1
	mat_idn( identity );
d597 1
a597 1
			mat_mul(new_xlate, old_xlate, xmat);
d644 1
a644 1
	mat_copy(identt.i_mat, old_xlate);
d1115 1
a1115 1
	if( rt_db_get_internal( &nmg_intern, dp, dbip, rt_identity ) < 0 )
@


11.17
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.16 1996/10/10 20:12:41 jra Exp bparker $ (BRL)";
d1120 6
d1138 3
d1148 1
a1148 1
			tmp_s = (struct shell *)nmg_dup_shell( s, &trans_tbl );
d1162 1
d1175 2
a1176 1
				(void)nmg_mv_shell_to_region( decomp_s, decomp_r );
d1179 1
a1179 2
				new_m = nmg_mm();
				(void)nmg_mv_region_to_model( decomp_r, new_m );
d1217 1
d1222 2
@


11.16
log
@Added f_decompose().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.15 1996/10/04 15:06:55 bparker Exp jra $ (BRL)";
d1140 1
a1140 1
			rt_free( (char *)trans_tbl, "trans_tbl" );
@


11.15
log
@cast bu_free's 1st argument to genptr_t
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.14 1996/10/03 20:31:46 bparker Exp bparker $ (BRL)";
d43 1
d50 2
d1061 147
@


11.14
log
@free allocated memory after interrupt
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.13 1996/10/01 17:26:29 bparker Exp bparker $ (BRL)";
d280 1
a280 1
    bu_free((char *)av, "f_edcodes: av");
d293 1
a293 1
  bu_free((char *)av, "f_edcodes: av");
@


11.13
log
@ignore SIGINT
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.12 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d102 2
d105 1
d109 3
d114 3
a116 1
	else
d118 1
a196 2
		{
		  struct bu_vls tmp_vls;
d198 3
a200 6
		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "Processed %d Solids and %d Regions\n",
				numsol,numreg);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
a205 2
		struct bu_vls	cmd;

d209 2
a210 8
		{
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "Processed %d Regions\n",numreg);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
a212 1
		bu_vls_init( &cmd );
a222 1
		bu_vls_free( &cmd );
d228 2
@


11.12
log
@rt_list ---> bu_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.11 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d101 1
d127 2
a128 1
	  return TCL_ERROR;
d137 2
a138 1
	  return TCL_ERROR;
d145 2
a146 1
			return TCL_ERROR;
d233 3
a235 1
	return TCL_OK;
d1004 1
d1015 2
d1054 1
d1065 2
@


11.11
log
@now using libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.10 1996/08/22 20:48:05 bparker Exp bparker $ (BRL)";
d41 1
@


11.10
log
@fix memory allocation bug in f_edcodes().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.9 1996/08/14 18:11:36 jra Exp bparker $ (BRL)";
d184 1
a184 1
		  struct rt_vls tmp_vls;
d186 2
a187 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "Processed %d Solids and %d Regions\n",
d189 2
a190 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d197 1
a197 1
		struct rt_vls	cmd;
d203 1
a203 1
		  struct rt_vls tmp_vls;
d205 4
a208 4
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "Processed %d Regions\n",numreg);
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d212 12
a223 12
		rt_vls_init( &cmd );
		rt_vls_strcpy( &cmd, sortcmd );
		rt_vls_strcat( &cmd, argv[1] );
		Tcl_AppendResult(interp, rt_vls_addr(&cmd), "\n", (char *)NULL);
		(void)system( rt_vls_addr(&cmd) );

		rt_vls_trunc( &cmd, 0 );
		rt_vls_strcpy( &cmd, catcmd );
		rt_vls_strcat( &cmd, argv[1] );
		Tcl_AppendResult(interp, rt_vls_addr(&cmd), "\n", (char *)NULL);
		(void)system( rt_vls_addr(&cmd) );
		rt_vls_free( &cmd );
d267 1
a267 1
  av = (char **)rt_malloc(sizeof(char *)*(argc + 2), "f_edcodes: av");
d277 1
a277 1
    rt_free((char *)av, "f_edcodes: av");
d290 1
a290 1
  rt_free((char *)av, "f_edcodes: av");
d503 1
a503 1
	struct rt_vls str;
d505 1
a505 1
	rt_vls_init( &str );
d508 1
a508 1
	  struct rt_vls tmp_vls;
d510 4
a513 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "nesting exceeds %d levels\n",MAX_LEVELS);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d675 1
a675 1
	  struct rt_vls tmp_vls;
d677 4
a680 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "tables: number of solids > max (%d)\n",MAXARGS);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d707 1
a707 1
	fprintf(tabptr, rt_vls_addr(&str));
d860 1
a860 1
			    struct rt_vls tmp_vls;
d863 4
a866 4
			    rt_vls_init(&tmp_vls);
			    rt_vls_printf(&tmp_vls, "%c", c );
			    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			    rt_vls_free(&tmp_vls);
d883 1
a883 1
			    struct rt_vls tmp_vls;
d885 4
a888 4
			    rt_vls_init(&tmp_vls);
			    rt_vls_printf(&tmp_vls, "\r%-6d%-3d%-3d%-4d\r",item,air,mat,los);
			    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			    rt_vls_free(&tmp_vls);
d939 1
a939 1
  struct rt_vls tmp_vls;
d941 1
a941 1
  rt_vls_init(&tmp_vls);
d944 1
a944 1
    rt_vls_printf(&tmp_vls, "%-6d",item);
d947 1
a947 1
    rt_vls_printf(&tmp_vls, "%-3d",air);
d950 1
a950 1
    rt_vls_printf(&tmp_vls, "%-3d",mat);
d953 1
a953 1
    rt_vls_printf(&tmp_vls, "%-4d",los);
d957 2
a958 2
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
@


11.9
log
@Added whichair command (similar to whichid).
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.8 1996/07/25 18:57:05 bparker Exp jra $ (BRL)";
d267 1
a267 1
  av = (char **)rt_malloc(sizeof(char *)*argc + 2, "f_edcodes: av");
@


11.8
log
@no need to keep initializing identity
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.7 1996/07/15 20:33:41 bparker Exp bparker $ (BRL)";
d1000 47
@


11.7
log
@hack to appease sun4's complaining about aggregate initialization
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.6 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d166 1
d168 1
@


11.6
log
@Still Tcl'ing the code
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.5 1996/04/18 20:29:27 bparker Exp bparker $ (BRL)";
d250 1
a250 1
  char tmpfil[] = "/tmp/GED.aXXXXX";
@


11.5
log
@convert commands to use Tcl
Also change edcodes to use a text editor
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.4 1996/03/01 19:24:25 bparker Exp bparker $ (BRL)";
d104 4
a107 1
	(void)signal( SIGINT, sig2 );		/* allow interrupts */
d246 1
a246 1
char	**argv;
d251 1
d265 9
a273 2
  regflag = lastmemb = 0;
  if( writecodes(tmpfil, argc, argv) == TCL_ERROR ){
d275 1
d281 3
a283 1
    status = readcodes(tmpfil, argc, argv);
d288 1
d293 1
d295 5
a299 4
writecodes(fname, argc, argv)
char *fname;
int argc;
char *argv[];
d306 7
a312 1
  fp = fopen(fname, "w");
d314 2
a315 1
  for(i = 1; i < argc; ++i){
d330 1
a330 1

d332 5
a336 4
readcodes(fname, argc, argv)
char *fname;
int argc;
char *argv[];
d338 4
a341 2
  register int i;
  int status;
d345 26
a370 1
  fp = fopen(fname, "r");
d372 2
a373 3
  for(i = 1; i < argc; ++i){
    if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY)) != DIR_NULL ){
      status = loadcodes(fp, dp, 0);
d375 12
a386 4
      if(status == TCL_ERROR){
	(void)fclose(fp);
	return TCL_ERROR;
      }
a389 1
  (void)fclose(fp);
a481 99

int
loadcodes(fp, dp, pathpos)
FILE *fp;
struct directory *dp;
int pathpos;
{
  int i;
  int status;
  int nparts;
  int item, air, mat, los;
  char line[LINELEN];
  struct directory *nextdp;

  if(pathpos >= MAX_LEVELS){
    regflag = ABORTED;
    return TCL_ERROR;
  }

  if( db_get( dbip, dp, &record, 0, 1) < 0 )
    return TCL_ERROR;

  if( record.u_id == ID_COMB ){
    if(regflag > 0){
      if(lastmemb)
	regflag = lastmemb = 0;

      return TCL_OK;
    }

    regflag = 0;
    nparts = dp->d_len-1;
    if(record.c.c_flags == 'R'){
      /* first region in this path */
      regflag = 1;

      if( nparts == 0 )	/* dummy region */
	regflag = 0;

      if( fgets( line , LINELEN, fp ) == NULL )
	return TCL_ERROR;

      sscanf(line, "%d%d%d%d", &item, &air, &mat, &los);
      record.c.c_regionid = item;
      record.c.c_aircode = air;
      record.c.c_material = mat;
      record.c.c_los = los;

      /* write out all changes */
      if( db_put( dbip, dp, &record, 0, 1 ) < 0 ){
	Tcl_AppendResult(interp, "Database write error, aborting.\n",
			 (char *)NULL);
	TCL_ERROR_RECOVERY_SUGGESTION;
	return TCL_ERROR;
      }
    }

    lastmemb = 0;
    for(i=1; i<=nparts; i++) {
      if(i == nparts)
	lastmemb = 1;

      if( db_get( dbip, dp, &record, i, 1) < 0 ){
	TCL_READ_ERR_return;
      }

      if( (nextdp = db_lookup( dbip, record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
	continue;

      /* Recursive call */
      status = loadcodes(fp, nextdp, pathpos+1);
      if(status == TCL_ERROR)
	return TCL_ERROR;
    }

    return TCL_OK;
  }      

  /* not a combination  -  should have a solid */
  if( lastmemb ){
    regflag = lastmemb = 0;
  }

  return TCL_OK;
}


/*
 *
 *	F _ D U P ( ) :	checks for dup names in preparation for cat'ing of files
 *
 *
 */
extern char new_name[NAMESIZE];	/* from concat.o */
extern char prestr[15];
extern int ncharadd;



a487 1

d978 4
a981 2
	/* allow interupts */
	(void)signal( SIGINT, sig2 );
@


11.4
log
@remove unused XMGED stuff
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.3 1995/03/10 20:47:07 mike Exp bparker $ (BRL)";
d48 2
d52 4
d87 3
a89 1
f_tables( argc, argv )
d101 3
d121 2
a122 2
		rt_log("tables:  input error\n");
		return CMD_BAD;
d130 2
a131 2
		(void)rt_log("Can't open %s\n",argv[1]);
		return CMD_BAD;
d138 1
a138 1
			return CMD_BAD;
d168 1
a168 1
			rt_log(" skip this object\n");
d171 1
a171 1
	rt_log("Summary written in: %s\n",argv[1]);
d178 10
a187 1
		rt_log("Processed %d Solids and %d Regions\n",numsol,numreg);
d196 3
a198 1
		rt_log("Processed %d Regions\n",numreg);
d200 6
d210 1
a210 1
		rt_log("%s\n", rt_vls_addr(&cmd) );
d216 1
a216 1
		rt_log("%s\n", rt_vls_addr(&cmd) );
d223 1
a223 1
	return CMD_OK;
d239 3
a241 1
f_edcodes( argc, argv )
d245 175
a419 2
	register struct directory *dp;
	register int i;
d421 2
a422 1
	(void)signal( SIGINT, sig2 );		/* allow interrupts */
a423 5
	/* need user interaction for this command */
	if( isatty(0) == 0 ) {
		rt_log("Need user interaction for the 'edcodes' command\n");
		return CMD_BAD;
	}
d425 24
d451 2
a452 10
	/* put terminal in raw mode  no echo */
	/* need "nice" way to do this */
	(void)system( "stty raw -echo" );

	for(i=1; i<argc; i++) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY)) != DIR_NULL )
			edcodes(dp, 0);
		else
			rt_log(" skip this object\n");
	}
d454 52
a505 2
	/* put terminal back in cooked mode  -  need "nice" way to do this */
	(void)system( "stty cooked echo" );
d507 1
a507 1
	return CMD_OK;
a529 3
#define MAX_LEVELS 12
struct directory *path[MAX_LEVELS];

d548 12
a559 5
		rt_log("nesting exceeds %d levels\n",MAX_LEVELS);
		for(i=0; i<MAX_LEVELS; i++)
			rt_log("/%s", path[i]->d_namep);
		rt_log("\n");
		return;
d572 7
a578 4
				rt_log("**WARNING** group= %s is member of region= ",record.c.c_name);
				for(k=0;k<pathpos;k++)
					rt_log("/%s",path[k]->d_namep);
				rt_log("\n");
d644 8
a651 5
		/* have a solid that's not part of a region */
		rt_log("**WARNING** following path (solid) has no region:\n");
		for(k=0;k<=pathpos;k++)
			rt_log("/%s",path[k]->d_namep);
		rt_log("\n");
d655 7
a661 4
		rt_log("**WARNING** following region has only '-' oprations:\n");
		for(k=0; k<pathpos; k++)
			rt_log("/%s",path[k]->d_namep);
		rt_log("\n");
d715 8
a722 2
		rt_log("tables: number of solids > max (%d)\n",MAXARGS);
		exit(10);
a750 107




/*
 *
 *		E D C O D E S ( ) :	edit region ident codes
 *
 *
 */
void
edcodes( dp, pathpos )
register struct directory *dp;
int pathpos;
{

	struct directory *nextdp;
	int nparts, i;

	if( regflag == ABORTED )
		return;

	if( pathpos >= MAX_LEVELS ) {
		rt_log("nesting exceeds %d levels\n",MAX_LEVELS);
		for(i=0; i<MAX_LEVELS; i++)
			rt_log("/%s", path[i]->d_namep);
		rt_log("\n");
		regflag = ABORTED;
		return;
	}

	if( db_get( dbip, dp, &record, 0, 1) < 0 )  READ_ERR_return;
	if( record.u_id == ID_COMB ) {
		if(regflag > 0) {
			/* this comb record is part of a region */
			if(record.c.c_flags == 'R') 
				oper_ok++;
			else {
				rt_log("**WARNING** group= %s is member of region= ",record.c.c_name);
				for(i=0;i<pathpos;i++)
					rt_log("/%s",path[i]->d_namep);
				rt_log("\n\r");
			}
			if(lastmemb)
				regflag = lastmemb = 0;
			return;
		}
		regflag = 0;
		nparts = dp->d_len-1;
		if(record.c.c_flags == 'R') {
			/* first region in this path */
			regflag = 1;

			if( nparts == 0 )	/* dummy region */
				regflag = 0;

			oper_ok = 0;

			(void)rt_log("%-6d%-3d%-3d%-4d  ",record.c.c_regionid,
					record.c.c_aircode,record.c.c_material,
					record.c.c_los);
			for(i=0;i<pathpos;i++) {
				(void)rt_log("/%s",path[i]->d_namep);
			}
			(void)rt_log("/%s%s\r",record.c.c_name,
					nparts==0 ? " **DUMMY REGION**" : "");
			/*edit this line */
			if( editline(dp) ) {
				rt_log("aborted\n");
				regflag = ABORTED;
				return;
			}
		}
		lastmemb = 0;
		for(i=1; i<=nparts; i++) {
			if(i == nparts)
				lastmemb = 1;
			if( db_get( dbip, dp, &record, i, 1) < 0 )  READ_ERR_return;
			operate = record.M.m_relation;

			if(regflag && operate != SUBTRACT)
				oper_ok++;

			path[pathpos] = dp;
			if( (nextdp = db_lookup( dbip, record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
				continue;
			/* Recursive call */
			edcodes(nextdp, pathpos+1);

		}
		return;
	}

	/* not a combination  -  should have a solid */

	/* last (bottom) position */
	path[pathpos] = dp;

	if( lastmemb )
		regflag = lastmemb = 0;

	return;
}




d819 2
a820 2
					for(i=0;i<(maxpos[field] - lpos); i++)
						rt_log(" ");
d825 2
a826 2
					rt_log("\r");
					field = 0;
d832 2
a833 2
					rt_log("\b");
					lpos--;
d846 1
a846 1
							rt_log("\b");
d852 1
a852 1
						rt_log("\b");
d857 23
a879 22
				rt_log("\r\n");
				if(eflag) {
					if(elflag) {
						/* change present field */
						ctemp[lpos] = ' ';
						elflag = 0;
						changes( field );
					}
					/* update the record with changes */
					record.c.c_regionid = item;
					record.c.c_aircode = air;
					record.c.c_material = mat;
					record.c.c_los = los;
					/* write out all changes */
					if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  {
						rt_log("Database write error, aborting.\n");
						ERROR_RECOVERY_SUGGESTION;
						return(1);
					}
				}
				/* get out of loop */
				return(0);
d884 2
a885 2
				rt_log("\r\n");
				return(1);
d897 16
a912 11
				/* integer was input */
				eflag++;
				if(lpos < maxpos[field]) {
					elflag++;
					rt_log( "%c", c );
					ctemp[lpos++] = c;
				}
				else {
					rt_log("\a\a");	/* bell */
				}
			break;
d915 15
a929 6
				/* 'R' was input - restore the line */
				item = record.c.c_regionid;
				air = record.c.c_aircode;
				mat = record.c.c_material;
				los = record.c.c_los;
				lpos = field = eflag = elflag = 0;
d931 1
a931 1
				rt_log("\r%-6d%-3d%-3d%-4d\r",item,air,mat,los);
d933 2
a934 1
			break;
d936 1
a936 3
			default:
				rt_log("\a"); 	/* ring bell */
			break;
d979 1
a979 10

	switch( num ) {

		case 0:
			(void)rt_log("%-6d",item);
		break;

		case 1:
			(void)rt_log("%-3d",air);
		break;
d981 19
a999 11
		case 2:
			(void)rt_log("%-3d",mat);
		break;

		case 3:
			(void)rt_log("%-4d",los);
		break;
	}

	return;

d1006 3
a1008 1
f_which_id( argc, argv )
d1017 3
d1025 2
a1026 1
		rt_log("Region[s] with ident %d:\n",item);
d1035 1
a1035 2
					READ_ERR;
					return CMD_BAD;
d1039 3
a1041 1
				rt_log("   %s\n",rec.c.c_name);
d1045 1
a1045 1
	return CMD_OK;
@


11.3
log
@Moved MAXARGS to ged.h, standardized on it's use, increased to 9000.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 11.2 95/01/17 13:05:24 bparker Exp Locker: mike $ (BRL)";
a57 4
#ifdef XMGED
int (*editline_hook)();
union record record;
#else
a58 1
#endif
a92 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );		/* allow interrupts */
#else
a93 1
#endif
a217 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );		/* allow interrupts */
#else
a218 1
#endif
a615 6
#ifdef XMGED
	if(editline_hook){
          return((*editline_hook)(dp));
        }
#endif

a825 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );
#else
a826 1
#endif
@


11.2
log
@merging xmged sources
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/utility1.c,v 11.2 95/01/17 11:44:46 bparker Exp $ (BRL)";
a65 1
#define MAXSOL 		2000
d81 1
a81 1
int discr[MAXSOL], idfd, rd_idfd;
d449 2
a450 2
	if(numsol > MAXSOL) {
		rt_log("tables: number of solids > max (%d)\n",MAXSOL);
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.13 95/01/03 22:05:36 mike Exp $ (BRL)";
d58 4
d63 1
d99 3
d103 1
d228 3
d232 1
d630 6
d846 3
d850 1
@


10.13
log
@Formatting fix from JRA.  Closes bug #255.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.12 94/12/23 23:48:25 gdurf Exp Locker: mike $ (BRL)";
@


10.12
log
@Converted to new do_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.11 94/12/16 20:36:39 gdurf Exp Locker: gdurf $ (BRL)";
d325 12
a336 3
			(void)fprintf(tabptr," %-4d%5d%5d%5d%5d  ",numreg,record.c.c_regionid,
					record.c.c_aircode,record.c.c_material,
					record.c.c_los);
@


10.11
log
@Converted putchar to rt_log
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.10 1994/12/16 19:37:35 gdurf Exp gdurf $ (BRL)";
d282 1
d284 2
d432 1
a432 1
	(void)lseek(idfd, 0L, 2);
d454 2
a455 1
	do_list( tabptr, dp, 1 );		/* verbose */
@


10.10
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.9 1994/11/05 04:08:25 mike Exp gdurf $ (BRL)";
d631 1
a631 1
						(void)putchar(' ');
d636 1
a636 1
					(void)putchar('\r');
d643 1
a643 1
					(void)putchar('\b');
d657 1
a657 1
							(void)putchar('\b');
d663 1
a663 1
						(void)putchar('\b');
d668 1
a668 2
				(void)putchar('\r');
				(void)putchar('\n');
d694 1
a694 2
				(void)putchar('\r');
				(void)putchar('\n');
d711 1
a711 1
					(void)putchar( c );
d715 1
a715 2
					(void)putchar(7);	/* bell */
					(void)putchar(7);	/* bell */
d727 1
a727 3
				(void)putchar('\r');
				(void)rt_log("%-6d%-3d%-3d%-4d",item,air,mat,los);
				(void)putchar('\r');
d732 1
a732 1
				(void)putchar(7); 	/* ring bell */
@


10.9
log
@Irix 6
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.8 94/09/14 13:06:14 mike Exp Locker: mike $ (BRL)";
d111 1
a111 1
		(void)printf("tables:  input error\n");
d120 1
a120 1
		(void)fprintf(stderr,"Can't open %s\n",argv[1]);
d158 1
a158 1
			(void)printf(" skip this object\n");
d161 1
a161 1
	(void)printf("Summary written in: %s\n",argv[1]);
d168 1
a168 1
		(void)printf("Processed %d Solids and %d Regions\n",numsol,numreg);
d177 1
a177 1
		(void)printf("Processed %d Regions\n",numreg);
d183 1
a183 1
		printf("%s\n", rt_vls_addr(&cmd) );
d189 1
a189 1
		printf("%s\n", rt_vls_addr(&cmd) );
d223 1
a223 1
		(void)printf("Need user interaction for the 'edcodes' command\n");
d237 1
a237 1
			(void)printf(" skip this object\n");
d284 1
a284 1
		(void)printf("nesting exceeds %d levels\n",MAX_LEVELS);
d286 2
a287 2
			(void)printf("/%s", path[i]->d_namep);
		(void)printf("\n");
d301 1
a301 1
				(void)printf("**WARNING** group= %s is member of region= ",record.c.c_name);
d303 2
a304 2
					(void)printf("/%s",path[k]->d_namep);
				(void)printf("\n");
d362 1
a362 1
		(void)printf("**WARNING** following path (solid) has no region:\n");
d364 2
a365 2
			(void)printf("/%s",path[k]->d_namep);
		(void)printf("\n");
d369 1
a369 1
		(void)printf("**WARNING** following region has only '-' oprations:\n");
d371 2
a372 2
			(void)printf("/%s",path[k]->d_namep);
		(void)printf("\n");
d426 1
a426 1
		(void)printf("tables: number of solids > max (%d)\n",MAXSOL);
d478 1
a478 1
		(void)printf("nesting exceeds %d levels\n",MAX_LEVELS);
d480 2
a481 2
			(void)printf("/%s", path[i]->d_namep);
		(void)printf("\n");
d493 1
a493 1
				(void)printf("**WARNING** group= %s is member of region= ",record.c.c_name);
d495 2
a496 2
					(void)printf("/%s",path[i]->d_namep);
				(void)printf("\n\r");
d513 1
a513 1
			(void)fprintf(stdout,"%-6d%-3d%-3d%-4d  ",record.c.c_regionid,
d517 1
a517 1
				(void)fprintf(stdout,"/%s",path[i]->d_namep);
d519 1
a519 1
			(void)fprintf(stdout,"/%s%s\r",record.c.c_name,
d523 1
a523 1
				(void)printf("aborted\n");
d684 1
a684 1
						(void)printf("Database write error, aborting.\n");
d731 1
a731 1
				(void)fprintf(stdout,"%-6d%-3d%-3d%-4d",item,air,mat,los);
d785 1
a785 1
			(void)fprintf(stdout,"%-6d",item);
d789 1
a789 1
			(void)fprintf(stdout,"%-3d",air);
d793 1
a793 1
			(void)fprintf(stdout,"%-3d",mat);
d797 1
a797 1
			(void)fprintf(stdout,"%-4d",los);
d823 1
a823 1
		(void)printf("Region[s] with ident %d:\n",item);
d837 1
a837 1
				(void)printf("   %s\n",rec.c.c_name);
@


10.8
log
@Fixed bug reported by Carl Moore -- idents command when used with
file name longer than 80 characters.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.7 94/08/09 19:02:12 gdurf Exp Locker: mike $ (BRL)";
d90 1
a90 1
	long now;
d279 2
a280 4
	int nparts, i, k, j;
	int	arslen;
	int	kk = 1;
	int	npt, n, nsoltemp;
a281 2
	vect_t	vertex;
	vect_t	vec;
@


10.7
log
@Factored ifdefs
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.6 1994/06/03 17:34:39 gdurf Exp gdurf $ (BRL)";
d91 2
a92 2
	static char sortcmd[80] = "sort -n +1 -2 -o /tmp/ord_id < ";
	static char catcmd[80] = "cat /tmp/ord_id >> ";
d173 2
d178 1
d180 13
a192 6
		sortcmd[31] = '\0';
		catcmd[19] = '\0';
		(void)strcat(sortcmd, argv[1]);
		(void)system( sortcmd );
		(void)strcat(catcmd, argv[1]);
		(void)system( catcmd );
@


10.6
log
@removed superfluous extern declaration
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.5 1994/06/01 16:05:38 gdurf Exp gdurf $ (BRL)";
d27 2
d34 3
a36 1
#ifdef BSD
a37 2
#else
#include <string.h>
@


10.5
log
@Converted f_ functions to use new command return codes.
./
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.4 1993/07/02 08:35:14 jra Exp gdurf $ (BRL)";
a44 2

extern void f_quit();
@


10.4
log
@removed check for solid in tables routine
added \r to warning printf in edcodes
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.3 92/02/05 13:35:38 mike Exp Locker: jra $ (BRL)";
d81 1
a81 1
void
d112 1
a112 1
		return;
d121 1
a121 1
		return;
d128 1
a128 1
			return;
d186 1
a186 1
	return;
d201 1
a201 1
void
d214 1
a214 1
		return;
d233 1
a233 1
	return;
d802 1
a802 1
void
d825 4
a828 2
				if( db_get( dbip, dp, &rec, 0, 1 ) < 0 )
					READ_ERR_return;
d835 1
@


10.3
log
@stdio.h must come before pwd.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.2 91/12/18 06:38:57 mike Exp Locker: mike $ (BRL)";
d490 1
a490 1
				(void)printf("\n");
a542 4
	if(record.u_id != ID_SOLID && record.u_id != ID_ARS_A) {
		(void)printf("bad record type '%c' should be 'S' or 'A'\n",record.u_id);
		return;
	}
@


10.2
log
@Changed to use do_list() routine, rather than built-in solid printer.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 10.1 91/10/12 06:44:26 mike Rel4_0 Locker: mike $ (BRL)";
d27 1
a29 1
#include <stdio.h>
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.15 91/07/09 01:43:04 mike Exp $ (BRL)";
a349 9
	/*
	 *
	 *	TO DO ..... include splines and polygons 
	 *
	 */
	if(record.u_id != ID_SOLID && record.u_id != ID_ARS_A) {
		(void)printf("bad record type '%c' should be 'S' or 'A'\n",record.u_id);
		return;
	}
d433 5
a437 53
	/*
	 *
	 *	TO DO ..... include splines and polygons 
	 *
	 */

	if(record.u_id == ID_SOLID) {
		(void)fprintf(tabptr,"   %c [%d] %s",operate,nsoltemp,record.s.s_name);
		if(lastmemb) {
			regflag = 0;
			lastmemb = 0;
		}

		if(flag == REG_TABLE || old_or_new == OLDSOLID) {
			(void)fprintf(tabptr,"\n");
			return;
		}

		if( old_or_new == NEWSOLID ) {
			MAT4X3PNT(vec, old_xlate, &record.s.s_values[0]);
			VMOVE( &record.s.s_values[0], vec );
			for(i=3; i<=21; i+=3) {
				MAT4X3VEC(	vec,
						old_xlate,
						&record.s.s_values[i]	);
				VMOVE( &record.s.s_values[i], vec );
			}
			(void)fprintf(tabptr,": %s",
				record.s.s_type==GENARB8 ? "GENARB8" :
				record.s.s_type==GENTGC ? "GENTGC" :
				record.s.s_type==GENELL ? "GENELL": "TOR" );

			if(record.s.s_type == GENARB8) {
				if( (i=record.s.s_cgtype) < 0 )
					i *= -1;
				(void)fprintf(tabptr," (%s)",i==ARB4 ? "ARB4" :
					i==ARB5 ? "ARB5" : i==ARB6 ? "ARB6" :
					i==ARB7 ? "ARB7" : i==RAW ? "ARB6" : "ARB8");
			}
			(void)fprintf(tabptr,"\n");

			/* put parameters in "nice" format and print */
			pr_solid( &record.s );
			for( i=0; i < es_nlines; i++ ) 
				(void)fprintf(tabptr,"%s\n",&es_display[ES_LINELEN*i]);

			/* If in solid edit, re-compute solid params */
			if(state == ST_S_EDIT)
				pr_solid(&es_rec.s);

		}

		return;
d439 2
a440 54

	if(record.u_id == ID_ARS_A) {
		n = record.a.a_n;
		(void)fprintf(tabptr,"   %c [%d] %s",operate,nsoltemp,record.a.a_name);
		if(flag == REG_TABLE || old_or_new == OLDSOLID) {
			if(lastmemb)
				regflag = lastmemb = 0;
			(void)fprintf(tabptr,"\n");
			return;
		}

		if(lastmemb) {
			regflag = lastmemb = 0;
		}

		if(old_or_new == OLDSOLID) 
			return;

		(void)fprintf(tabptr," ARS %7d curves%7d points/curve",record.a.a_m,n);
		arslen = record.a.a_totlen;
		for(i=1; i<=arslen; i++) {
			if( db_get( dbip, dp, &record, i, 1) < 0 )  READ_ERR_return;
			if( (npt = (n - ((record.b.b_ngranule-1)*8))) > 8 )
				npt = 8;
			if(i == 1) {
				/* vertex */
				MAT4X3PNT(	vertex,
						old_xlate,
						&record.b.b_values[0]	);
				VMOVE( &record.b.b_values[0], vertex );
				kk =1;
			}
			/* rest of vectors */
			for(k=kk; k<npt; k++) {
				MAT4X3VEC(	vec,
						old_xlate,
						&record.b.b_values[k*3]	);
				VADD2(	&record.b.b_values[k*3],
					vertex,
					vec );
			}
			kk = 0;
			/* print this granule */
			for(k=0; k<npt; k+=2) {
				(void)fprintf(tabptr,"\n              ");
				for(j=k*3; (j<(k+2)*3 && j<npt*3); j++) 
					(void)fprintf(tabptr," %10.4f",record.b.b_values[j]*base2local);
			}

		}
		(void)fprintf(tabptr,"\n");
		if(lastmemb)
			regflag = lastmemb = 0;

d444 2
@


9.15
log
@changed to extern
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.14 91/06/30 21:16:42 mike Exp $ (BRL)";
@


9.14
log
@Replaced local_unit[] with call to rt_units_string()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.13 91/02/27 21:54:33 mike Exp $ (BRL)";
d243 3
a245 3
char new_name[NAMESIZE];
char prestr[15];
int ncharadd;
@


9.13
log
@lint
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.12 91/01/12 08:24:48 mike Exp $ (BRL)";
a47 2
extern char	*local_unit[];

d142 2
a143 1
	(void)fprintf(tabptr,"7 -2         target units : %s\n",local_unit[localunit]);
@


9.12
log
@externs.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.11 90/12/13 03:52:16 butler Exp $ (BRL)";
d789 5
a793 2
					if( db_put( dbip, dp, &record, 0, 1 ) < 0 )
						WRITE_ERR_return;
@


9.11
log
@Added return(1) to function editline to make cc/lint happier
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: utility1.c,v 9.10 90/12/08 00:31:29 butler Locked $ (BRL)";
a49 2
extern struct passwd *getpwuid();

d81 1
a81 1
FILE *fopen(), *tabptr;
d700 1
d705 1
a705 1
	char c;
d720 2
a721 2
	while(1) {
		switch( (c = getchar()) ) {
@


9.10
log
@Added error checking around calls to db_*() routines
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.9 90/12/07 19:36:21 mike Exp $ (BRL)";
d845 1
@


9.10.1.1
log
@un-doing what I've done.  There's just no pleasing some compilers
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: utility1.c,v 9.10 90/12/08 00:31:29 butler Locked $ (BRL)";
@


9.9
log
@Fixed to not use lseek & write to update the database.
Used db_put() instead.
Along the way, this fixed Carl Moore's complaint that
EDCODES didn't give error messages when updating a
read-only database.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.8 90/12/07 06:15:14 mike Exp $ (BRL)";
d288 1
a288 1
	db_get( dbip, dp, &record, 0, 1);
d333 1
a333 1
			db_get( dbip, dp, &record, i, 1);
d520 1
a520 1
			db_get( dbip, dp, &record, i, 1);
d590 1
a590 1
	db_get( dbip, dp, &record, 0, 1);
d636 1
a636 1
			db_get( dbip, dp, &record, i, 1);
d790 2
a791 1
					(void)db_put( dbip, dp, &record, 0, 1 );
d935 1
a935 1
					continue;
@


9.8
log
@Eliminated cmd_args[]
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.7 90/12/07 03:30:33 mike Exp $ (BRL)";
d626 1
a626 1
			if( editline() ) {
d702 2
a703 1
editline()
d790 1
a790 2
					(void)lseek(dbip->dbi_fd, -(long)sizeof record, 1);
					(void)write(dbip->dbi_fd, (char *)&record, sizeof record);
@


9.7
log
@Neatness
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/utility1.c,v 9.6 90/12/07 03:29:55 mike Exp $ (BRL)";
a47 4
extern int	args;		/* total number of args available */
extern int	argcnt;		/* holder for number of args added later */

extern char	*cmd_args[];	/* array of pointers to args */
a49 3
extern void	exit(), perror();
extern char	 *strcpy(), *strncat();
extern long	time();
a919 3
	args = argc;
	argcnt = 0;

d923 2
a924 9
	/* get the ident code number(s) */
	while( args < 2 ) {
		(void)printf("Enter the region item code(s) sought: ");
		argcnt = getcmd(args);
		args += argcnt;
	}

	for( j=1; j<args; j++) {
		item = atoi( cmd_args[j] );
a941 2


@


9.6
log
@Replaced rec.c.c_length with dp->d_len-1;
Moved "dup" and "concat" commands to concat.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d614 1
a614 1
		nparts = dp->d_len-1;;
@


9.5
log
@lint
@
text
@d4 1
a4 1
 *
a8 2
 *	f_dup()		checks for dup names before cat'ing of two files
 *	f_concat()	routine to cat another GED file onto end of current file
d11 11
d23 3
d42 1
d59 1
a59 1
void		tables(), edcodes(), changes(), prfield(), prename();
a256 5
void
f_dup( argc, argv )
int	argc;
char	**argv;
{
a257 5
	register FILE *dupfp;
	register int i;
	int ndup;
	register struct directory *tmpdp;
	struct directory **dirp, **dirp0;
a258 156
	(void)signal( SIGINT, sig2 );		/* allow interrupts */

	/* save number of args entered initially */
	args = argc;
	argcnt = 0;

	/* get target file name */
	while( args < 2 ) {
		(void)printf("Enter the target file name: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
	}

	/* open the target file */
	if( (dupfp=fopen(cmd_args[1], "r")) == NULL ) {
		(void)fprintf(stderr,"Can't open %s\n",cmd_args[1]);
		return;
	}

	/* get any prefix */
	if( args < 3 ) {
		(void)printf("Enter prefix string or CR: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
		/* no prefix is acceptable */
		if(args == 2)
			cmd_args[2][0] = '\0';
	}

	ndup = 0;
	ncharadd = 0;
	(void)strcpy(prestr, cmd_args[2]);
	ncharadd = strlen( prestr );

	fread( (char *)&record, sizeof record, 1, dupfp );
	if(record.u_id != ID_IDENT) {
		(void)printf("%s: Not a correct GED data base - STOP\n",
				cmd_args[1]);
		(void)fclose( dupfp );
		return;
	}

	(void)printf("\n*** Comparing %s with %s for duplicate names\n",
		dbip->dbi_filename,cmd_args[1]);
	if( ncharadd ) {
		(void)printf("  For comparison, all names in %s prefixed with:  %s\n",
				cmd_args[1],prestr);
	}

	if( (dirp = dir_getspace(0)) == (struct directory **) 0) {
		(void) printf( "f_dup: unable to get memory\n");
		return;
	}
	dirp0 = dirp;

	while( fread( (char *)&record, sizeof record, 1, dupfp ) == 1 && ! feof(dupfp) ) {
		tmpdp = DIR_NULL;

		switch( record.u_id ) {

			case ID_IDENT:
			case ID_FREE:
			case ID_ARS_B:
			case ID_MEMB:
			case ID_P_DATA:
			case ID_MATERIAL:
				break;

			case ID_SOLID:
				if(record.s.s_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.s.s_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.s.s_name, LOOKUP_QUIET);
				break;

			case ID_ARS_A:
				if(record.a.a_name[0] == 0) 
					break;
				if( ncharadd ) {
					prename(record.a.a_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.a.a_name, LOOKUP_QUIET);
				break;

			case ID_COMB:
				if(record.c.c_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.c.c_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.c.c_name, LOOKUP_QUIET);
				break;

			case ID_BSOLID:
				if(record.B.B_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.B.B_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.B.B_name, LOOKUP_QUIET);
				break;

			case ID_BSURF:
				/* Need to skip over knots & mesh which follows! */
				(void)fseek( dupfp,
					(record.d.d_nknots+record.d.d_nctls) *
						(long)(sizeof(record)),
					1 );
				continue;

			case ID_P_HEAD:
				if(record.p.p_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.p.p_name);
					tmpdp = db_lookup( dbip, new_name, LOOKUP_QUIET);
				}
				else
					tmpdp = db_lookup( dbip, record.p.p_name, LOOKUP_QUIET);
				break;

			default:
				(void)printf("Unknown record type (%c) in %s\n",
						record.u_id,cmd_args[1]);
				break;

		}

		if(tmpdp != DIR_NULL) {
			/* have a duplicate name */
			ndup++;
			*dirp++ = tmpdp;
			tmpdp = DIR_NULL;
		}
	}
	col_pr4v( dirp0, (int)(dirp - dirp0));
	free( dirp0);
	(void)printf("\n -----  %d duplicate names found  -----\n",ndup);
	(void)fclose( dupfp );
	return;
}



a260 205
 *		F _ C O N C A T
 *
 *	concatenates another GED file onto end of current file
 */
void
f_concat( argc, argv )
int	argc;
char	**argv;
{
	FILE *catfp;
	int nskipped, i, length;
	register struct directory *dp;

	(void)signal( SIGINT, sig2 );		/* interrupts */

	/* save number of args entered initially */
	args = argc;
	argcnt = 0;

	/* get target file name */
	while( args < 2 ) {
		(void)printf("Enter the target file name: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
	}

	/* open the target file */
	if( (catfp=fopen(cmd_args[1], "r")) == NULL ) {
		(void)fprintf(stderr,"Can't open %s\n",cmd_args[1]);
		return;
	}

	/* get any prefix */
	if( args < 3 ) {
		(void)printf("Enter prefix string or CR: ");
		argcnt = getcmd(args);
		/* add any new args entered */
		args += argcnt;
		/* no prefix is acceptable */
		if(args == 2)
			cmd_args[2][0] = '\0';
	}

	ncharadd = nskipped = 0;
	(void)strcpy(prestr, cmd_args[2]);
	ncharadd = strlen( prestr );

	fread( (char *)&record, sizeof record, 1, catfp );
	if(record.u_id != ID_IDENT) {
		(void)printf("%s: Not a correct GED data base - STOP\n",
				cmd_args[1]);
		(void)fclose( catfp );
		return;
	}

	(void)signal( SIGINT, SIG_IGN );		/* NO interrupts */

	while( fread( (char *)&record, sizeof record, 1, catfp ) == 1 && ! feof(catfp) ) {

		switch( record.u_id ) {

			case ID_IDENT:
			case ID_FREE:
			case ID_ARS_B:
			case ID_MEMB:
			case ID_P_DATA:
				break;

			case ID_MATERIAL:
				rt_color_addrec( &record, -1 );
				break;

			case ID_SOLID:
				if(record.s.s_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.s.s_name);
					NAMEMOVE(new_name, record.s.s_name);
				}
				if( db_lookup( dbip, record.s.s_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("SOLID (%s) already exists in %s....will skip\n",
						record.s.s_name, dbip->dbi_filename);
					break;
				}
				/* add to the directory */
printf("adding solid \"%s\"\n", record.s.s_name);
				if( (dp = db_diradd( dbip, record.s.s_name, -1, 1, DIR_SOLID)) == DIR_NULL )
					return;
				/* add the record to the data base file */
				db_alloc( dbip, dp, 1 );
				db_put( dbip, dp, &record, 0, 1 );
				break;

			case ID_ARS_A:
				if( ncharadd ) {
					prename(record.a.a_name);
					NAMEMOVE(new_name, record.a.a_name);
				}
				if( db_lookup( dbip, record.a.a_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("ARS (%s) already exists in %s....will skip\n",
							record.a.a_name, dbip->dbi_filename);
					break;
				}
				/* add to the directory */
				length = record.a.a_totlen;
				if( (dp = db_diradd( dbip, record.a.a_name, -1, length+1, DIR_SOLID)) == DIR_NULL )
					return;
				/* add the record to the data base file */
				db_alloc( dbip, dp, length+1 );
				db_put( dbip, dp, &record, 0, 1 );
				/* get the b_records */
				for(i=1; i<=length; i++) {
					(void)fread( (char *)&record, sizeof record, 1, catfp );
					db_put( dbip, dp, &record, i, 1 );
				}
				break;

			case ID_COMB:
				if( ncharadd ) {
					prename(record.c.c_name);
					NAMEMOVE(new_name, record.c.c_name);
				}
				if( db_lookup( dbip, record.c.c_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("COMB (%s) already exists in %s....will skip\n",
							record.c.c_name, dbip->dbi_filename);
					break;
				}
				/* add to the directory */
				length = record.c.c_length;
printf("adding comb \"%s\"\n", record.c.c_name);
				if( (dp = db_diradd( dbip,  record.c.c_name, -1,
						length+1,
						record.c.c_flags == 'R' ?
						DIR_COMB|DIR_REGION : DIR_COMB
						) ) == DIR_NULL )
					return;
				/* add the record to the data base file */
				db_alloc( dbip, dp, length+1 );
				db_put( dbip, dp, &record, 0, 1 );
				/* get the member records */
				for(i=1; i<=length; i++) {
					(void)fread( (char *)&record, sizeof record, 1, catfp );
					if( record.M.m_brname[0] && ncharadd ) {
						prename(record.M.m_brname);
						NAMEMOVE(new_name, record.M.m_brname);
					}
					if( record.M.m_instname[0] && ncharadd ) {
						prename(record.M.m_instname);
						NAMEMOVE(new_name, record.M.m_instname);
					}
					db_put( dbip, dp, &record, i, 1 );
				}
				break;

			case ID_BSOLID:
				if( ncharadd ) {
					prename(record.B.B_name);
					NAMEMOVE(new_name, record.B.B_name);
				}
				if( db_lookup( dbip, record.B.B_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("SPLINE (%s) already exists in %s....will skip\n",
							record.B.B_name, dbip->dbi_filename);
					break;
				}
	printf("SPLINE not implemented yet, aborting!\n");
				/* Need to miss the knots and mesh */
				return;

			case ID_P_HEAD:
				if(record.p.p_name[0] == 0)
					break;
				if( ncharadd ) {
					prename(record.p.p_name);
					NAMEMOVE(new_name, record.p.p_name);
				}
				if( db_lookup( dbip, record.p.p_name, LOOKUP_QUIET) != DIR_NULL ) {
					nskipped++;
					(void)printf("POLYGON (%s) already exists in %s....will skip\n",
							record.p.p_name, dbip->dbi_filename);
					break;
				}
printf("POLYGONS not implemented yet.....SKIP %s\n",record.p.p_name);
				break;

			default:
				(void)printf("BAD record type (%c) in %s\n",
						record.u_id,cmd_args[1]);
				break;

		}

	}
}





/*
 *
d315 1
a315 1
		nparts = record.c.c_length;
d321 1
a321 1
			if( nparts == 0 )	/* dummy region */
d614 1
a614 1
		nparts = record.c.c_length;
a912 19


/*    P R E N A M E ( ): 	actually adds prefix to a name
 *				new_name[] = prestr[] + old_name[]
 */
void
prename( old_name )
char old_name[NAMESIZE];
{

	(void)strcpy(new_name, prestr);
	(void)strncat(new_name, old_name, NAMESIZE-1-ncharadd);
	if( ncharadd + strlen( old_name ) > NAMESIZE-1 ) {
		(void)printf("name truncated : %s + %s = %s\n",
			prestr,old_name,new_name);
	}
}


@


9.4
log
@nit
@
text
@d638 3
a640 1
	int arslen, kk, npt, n, nsoltemp;
@


9.3
log
@Replaced local unit_str[] with global local_unit[].
Switched to using argc/argv in some places
@
text
@d37 1
a37 1
extern int	numargs;	/* number of args */
@


9.2
log
@Changed f_cat to f_concat
@
text
@a36 1
extern int	newargs;	/* number of args from getcmd() */
d39 1
a57 10
static char *unit_str[] = {
	"NONE",
	"MILLIMETERS",
	"CENTIMETERS",
	"METERS",
	"INCHES",
	"FEET",
	"NONE"
};

d80 3
a82 1
f_tables()
d95 1
a95 1
	if( strcmp(cmd_args[0], "solids") == 0 ) {
d99 1
a99 1
	else if( strcmp(cmd_args[0], "regions") == 0 ) {
d103 1
a103 1
	else if( strcmp(cmd_args[0], "idents") == 0 ) {
d117 2
a118 2
	if( (tabptr=fopen(cmd_args[1], "w+")) == NULL ) {
		(void)fprintf(stderr,"Can't open %s\n",cmd_args[1]);
d134 1
a134 1
	(void)fprintf(tabptr,"1 -8    Summary Table {%s}  (written: %s)\n",cmd_args[0],timep);
d140 1
a140 1
	(void)fprintf(tabptr,"7 -2         target units : %s\n",unit_str[localunit]);
d142 1
a142 1
	for(i=2; i<numargs; i++) {
d145 1
a145 1
		(void)fprintf(tabptr," %s",cmd_args[i]);
d151 2
a152 2
	for(i=2; i<numargs; i++) {
		if( (dp = db_lookup( dbip, cmd_args[i],LOOKUP_NOISY)) != DIR_NULL )
d158 1
a158 1
	(void)printf("Summary written in: %s\n",cmd_args[1]);
d176 1
a176 1
		(void)strcat(sortcmd, cmd_args[1]);
d178 1
a178 1
		(void)strcat(catcmd, cmd_args[1]);
d199 3
a201 1
f_edcodes( )
d220 2
a221 2
	for(i=1; i<numargs; i++) {
		if( (dp = db_lookup( dbip, cmd_args[i], LOOKUP_NOISY)) != DIR_NULL )
d245 3
a247 1
f_dup( )
d259 1
a259 1
	args = numargs;
d419 3
a421 1
f_concat( )
d430 1
a430 1
	args = numargs;
d1293 3
a1295 1
f_which_id( )
d1302 1
a1302 1
	args = numargs;
@


9.1
log
@Release_3.5
@
text
@d10 1
a10 1
 *	f_cat()		routine to cat another GED file onto end of current file
d418 1
a418 1
 *		F _ C A T	cats another GED file onto end of current file
d420 1
a420 1
 *
d423 1
a423 1
f_cat( )
@


8.5
log
@db_diradd had the length and flags parameters backward
@
text
@@


8.4
log
@fixed whichid cmd so it printed out the found id code item.
@
text
@d503 2
a504 1
				if( (dp = db_diradd( dbip, record.s.s_name, -1, DIR_SOLID, 1)) == DIR_NULL )
d524 1
a524 1
				if( (dp = db_diradd( dbip, record.a.a_name, -1, DIR_SOLID, length+1)) == DIR_NULL )
d549 1
d551 1
d553 2
a554 2
						DIR_COMB|DIR_REGION : DIR_COMB,
						length+1) ) == DIR_NULL )
@


8.3
log
@removed MAXLINE (unused)
@
text
@d1326 1
a1326 1
				(void)printf("   %s\n",record.c.c_name);
@


8.2
log
@Converted to new db_*() routines.
@
text
@a67 1
#define MAXLINE		512	/* Maximum number of chars per line */
@


8.1
log
@Release_3.0
@
text
@d19 1
a20 1
#include <sys/time.h>	/* for struct timeval.  Includes <time.h> */
a22 1
#include <time.h>
d29 1
a31 1
#include "./objdir.h"
a45 3
extern int	objfd;
extern char	*filename;		/* data file name */

d144 1
a144 1
	(void)fprintf(tabptr,"2 -7         file name    : %s\n",filename);    
d161 1
a161 1
		if( (dp=lookup(cmd_args[i],LOOKUP_NOISY)) != DIR_NULL )
d228 1
a228 1
		if( (dp=lookup(cmd_args[i], LOOKUP_NOISY)) != DIR_NULL )
d305 2
a306 1
	(void)printf("\n*** Comparing %s with %s for duplicate names\n",filename,cmd_args[1]);
d336 1
a336 1
					tmpdp = lookup(new_name, LOOKUP_QUIET);
d339 1
a339 1
					tmpdp = lookup(record.s.s_name, LOOKUP_QUIET);
d347 1
a347 1
					tmpdp = lookup(new_name, LOOKUP_QUIET);
d350 1
a350 1
					tmpdp = lookup(record.a.a_name, LOOKUP_QUIET);
d358 1
a358 1
					tmpdp = lookup(new_name, LOOKUP_QUIET);
d361 1
a361 1
					tmpdp = lookup(record.c.c_name, LOOKUP_QUIET);
d369 1
a369 1
					tmpdp = lookup(new_name, LOOKUP_QUIET);
d372 1
a372 1
					tmpdp = lookup(record.B.B_name, LOOKUP_QUIET);
d388 1
a388 1
					tmpdp = lookup(new_name, LOOKUP_QUIET);
d391 1
a391 1
					tmpdp = lookup(record.p.p_name, LOOKUP_QUIET);
d487 1
a487 1
				color_addrec( &record, -1 );
d497 1
a497 1
				if( lookup(record.s.s_name, LOOKUP_QUIET) != DIR_NULL ) {
d500 1
a500 1
							record.s.s_name, filename);
d504 1
a504 1
				if( (dp = dir_add(record.s.s_name, -1, DIR_SOLID, 1)) == DIR_NULL )
d507 2
a508 2
				db_alloc( dp, 1 );
				db_putrec(dp, &record, 0);
d516 1
a516 1
				if( lookup(record.a.a_name, LOOKUP_QUIET) != DIR_NULL ) {
d519 1
a519 1
							record.a.a_name, filename);
d524 1
a524 1
				if( (dp = dir_add(record.a.a_name, -1, DIR_SOLID, length+1)) == DIR_NULL )
d527 2
a528 2
				db_alloc( dp, length+1 );
				db_putrec(dp, &record, 0);
d532 1
a532 1
					db_putrec(dp, &record, i);
d541 1
a541 1
				if( lookup(record.c.c_name, LOOKUP_QUIET) != DIR_NULL ) {
d544 1
a544 1
							record.c.c_name, filename);
d549 1
a549 1
				if( (dp = dir_add( record.c.c_name, -1,
d555 2
a556 2
				db_alloc( dp, length+1 );
				db_putrec(dp, &record, 0);
d568 1
a568 1
					db_putrec(dp, &record, i);
d577 1
a577 1
				if( lookup(record.B.B_name, LOOKUP_QUIET) != DIR_NULL ) {
d580 1
a580 1
							record.B.B_name, filename);
d594 1
a594 1
				if( lookup(record.p.p_name, LOOKUP_QUIET) != DIR_NULL ) {
d597 1
a597 1
							record.p.p_name, filename);
d651 1
a651 1
	db_getrec(dp, (char *)&record, 0);
d696 1
a696 1
			db_getrec(dp, (char *)&record, i);
d703 1
a703 1
			if( (nextdp = lookup(record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
d883 1
a883 1
			db_getrec(dp, (char *)&record, i);
d953 1
a953 1
	db_getrec(dp, (char *)&record, 0);
d999 1
a999 1
			db_getrec(dp, (char *)&record, i);
d1006 1
a1006 1
			if( (nextdp = lookup(record.M.m_instname, LOOKUP_NOISY)) == DIR_NULL )
d1152 2
a1153 2
					(void)lseek(objfd, -(long)sizeof record, 1);
					(void)write(objfd, (char *)&record, sizeof record);
d1295 4
a1299 3
	int item, i;
	FILE *fp;

d1303 1
a1303 1
	/* interupts */
d1308 1
a1308 1
		(void)printf("Enter the region item code(s): ");
d1313 2
a1314 8
	if( (fp = fopen( filename, "r" )) == NULL ) {
		(void)printf("f_which_id: fopen failed\n");
		return;
	}


	for(i=0; i<(args-1); i++) {
		item = atoi( cmd_args[i+1] );
d1317 10
a1326 6
		while(fread( (char *)&record, sizeof record, 1, fp ) == 1 &&
			!feof(fp)) {

			if(record.u_id == ID_COMB && record.c.c_flags == 'R' &&
				record.c.c_regionid == item ) {

a1328 1

a1329 1
		fseek(fp, 0, 0);	/* rewind */
a1330 1
	(void)fclose( fp );
@


7.5
log
@get atof() extern from math.h
@
text
@@


7.4
log
@lint fixes
@
text
@d18 1
a33 1
extern double atof();
@


7.3
log
@Changed to use rt_mat_dbmat and rt_dbmat_mat
to convert between database and internal formats.
@
text
@a32 1
void	aexists();
d50 2
d94 1
d211 1
d255 1
d426 1
d630 1
d935 1
a935 2


d1212 4
a1215 2


d1242 4
a1245 1

d1277 1
d1295 1
a1295 1

@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d689 2
d702 4
a706 2
			mat_mul(new_xlate, old_xlate, record.M.m_mat);

a707 1

@


7.1
log
@Release 2.3
@
text
@d26 1
a26 1
#include "./machine.h"	/* special copy */
d637 2
a638 2
	float vertex[3];
	float vec[3];
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@@


4.2
log
@Minor cleanups inspired by the Cray
@
text
@@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d37 3
a39 3
int		args;		/* total number of args available */
int		argcnt;		/* holder for number of args added later */
int		newargs;	/* number of args from getcmd() */
d42 4
a45 3
extern void exit(), perror();
extern char *strcpy(), *strncat();
extern long time();
a46 2
extern int objfd;
extern char *filename;		/* data file name */
d48 3
a99 1
	struct passwd *getpwuid();
@


1.12
log
@Fixed #include for time.h
@
text
@@


1.11
log
@And another one just like the last one....
@
text
@a14 1
#include <time.h>
d19 1
d22 1
@


1.10
log
@Corrected a problem where the pointer to the string rather than the string
was being zeroed -- caused core dumps on IRIS'.
@
text
@d454 1
a454 1
			cmd_args[2] = '\0';
@


1.9
log
@Minor cleanup for cray
@
text
@d287 1
a287 1
			cmd_args[2] = '\0';
@


1.8
log
@Removed file stating and various output nonsense.
@
text
@d19 1
d21 4
@


1.7
log
@Converted from BSD42 to BSD and SYSV defines to select UNIX type.
@
text
@a14 8
#ifdef BSD
# include <sys/types.h>
# include <sys/stat.h>
#endif
#ifdef SYSV
# include <stat.h>
#endif

a92 2
	int fstat();
	struct stat filest, *fbuf;
d128 1
a128 1
		if( (idfd = creat("/tmp/mged_discr", 0666)) < 0 ) {
d140 2
a141 10
	fbuf = &filest;
	if( fstat( objfd, fbuf ) == -1 ) {
		perror( "fstat()" );
		return;
	}
	timep = ctime(&fbuf->st_mtime);
	timep[24] = '\0';

	(void)fprintf(tabptr,"3 -6         file owner   : %s\n",getpwuid((int)fbuf->st_uid)->pw_gecos);
	(void)fprintf(tabptr,"4 -5         file last mod: %s\n",timep);
@


1.6
log
@Changed #includes for CC -I../h
@
text
@d15 1
a15 1
#ifdef BSD42
@


1.5
log
@Minor fix to please lint.
@
text
@d15 10
d29 5
a33 9
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "sedit.h"
#include "objdir.h"
#include <time.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/stat.h>
@


1.4
log
@Minor bug fix inspired by Keith
@
text
@d318 1
a318 1
		return(1);
@


1.3
log
@Changed to sort directory output listings
@
text
@a252 1

d323 1
@


1.2
log
@Added support for the new spline format.
@
text
@d263 1
a263 1
	int ndup, nchar, ncol;
d265 1
d298 1
a298 1
	ncol = ndup = 0;
d311 1
a311 1
	(void)printf("\n*** Comparing %s with %s for duplicate names:\n",filename,cmd_args[1]);
d313 1
a313 1
		(void)printf("  For comparison, all names in %s prefixed with %s\n",
d317 6
d408 1
a408 12
			nchar = strlen(tmpdp->d_namep);
			(void)printf("%s",tmpdp->d_namep);
			if(++ncol >= 4) {
				(void)printf("\n");
				ncol = 0;
			}
			else {
				if(nchar < 8)
					(void)printf("\t");
				if(nchar < 16)
					(void)printf("\t");
			}
d412 2
@


1.1
log
@Initial revision
@
text
@a324 2
			case ID_B_SPL_KV:
			case ID_B_SPL_CTL:
d326 1
a326 1
			break;
d337 1
a337 1
			break;
d348 1
a348 1
			break;
d359 1
a359 1
			break;
d361 2
a362 2
			case ID_B_SPL_HEAD:
				if(record.d.d_name[0] == 0)
d365 1
a365 1
					prename(record.d.d_name);
d369 2
a370 2
					tmpdp = lookup(record.d.d_name, LOOKUP_QUIET);
			break;
d372 8
d389 1
a389 1
			break;
d394 1
a394 1
			break;
d489 1
a489 3
			case ID_B_SPL_KV:
			case ID_B_SPL_CTL:
			break;
d493 1
a493 1
			break;
d514 1
a514 1
			break;
a516 2
				if(record.a.a_name[0] == 0) 
					break;
d539 1
a539 1
			break;
a541 2
				if(record.c.c_name[0] == 0)
					break;
d575 1
a575 1
			break;
d577 1
a577 3
			case ID_B_SPL_HEAD:
				if(record.d.d_name[0] == 0)
					break;
d579 2
a580 2
					prename(record.d.d_name);
					NAMEMOVE(new_name, record.d.d_name);
d582 1
a582 1
				if( lookup(record.d.d_name, LOOKUP_QUIET) != DIR_NULL ) {
d585 1
a585 1
							record.d.d_name, filename);
d588 3
a590 14
				/* add to the directory */
				length = record.d.d_totlen;
				if( (dp = dir_add( record.d.d_name, -1,
					DIR_SOLID, length+1) ) == DIR_NULL )
					return;
				/* add the record to the data base file */
				db_alloc( dp, length+1 );
				db_putrec(dp, &record, 0);
				/* get the other records (knot and control) */
				for(i=1; i<=length; i++) {
					(void)fread( (char *)&record, sizeof record, 1, catfp );
					db_putrec(dp, &record, i);
				}
			break;
d606 1
a606 1
			break;
d611 1
a611 1
			break;
@
