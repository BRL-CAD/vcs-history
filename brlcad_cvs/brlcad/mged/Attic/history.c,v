head	1.27;
access;
symbols
	ansi-20040405-merged:1.22.2.2
	postmerge-20040405-ansi:1.25
	premerge-20040404-ansi:1.24
	postmerge-autoconf:1.24
	autoconf-freeze:1.22.10.2
	premerge-autoconf:1.24
	postmerge-20040315-windows:1.24
	premerge-20040315-windows:1.23
	windows-20040315-freeze:1.22.4.2
	autoconf-20031203:1.22
	autoconf-20031202:1.22
	autoconf-branch:1.22.0.10
	phong-branch:1.22.0.8
	photonmap-branch:1.22.0.6
	rel-6-1-DP:1.22
	windows-branch:1.22.0.4
	rel-6-0-2:1.20
	ansi-branch:1.22.0.2
	rel-6-0-1-branch:1.20.0.2
	hartley-6-0-post:1.21
	hartley-6-0-pre:1.20
	rel-6-0-1:1.20
	rel-6-0:1.20
	rel-5-4:1.17
	offsite-5-3-pre:1.20
	rel-5-3:1.17
	rel-5-2:1.17
	rel-5-1-branch:1.17.0.2
	rel-5-1:1.17
	rel-5-0:1.17
	rel-5-0-beta:1.17
	rel-4-5:1.12
	ctj-4-5-post:1.12
	ctj-4-5-pre:1.12;
locks; strict;
comment	@ * @;


1.27
date	2004.05.21.17.47.44;	author morrison;	state dead;
branches;
next	1.26;

1.26
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.02.17.39.33;	author morrison;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.20.17.08.23;	author jra;	state Exp;
branches
	1.22.2.1
	1.22.4.1
	1.22.10.1;
next	1.21;

1.21
date	2002.08.15.20.55.35;	author hartley;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.24.19.05.06;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.19.21.26.45;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.19.21.26.02;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.01.27.20.31.29;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	99.01.21.18.31.20;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	98.11.06.22.32.41;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	98.09.14.15.59.19;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	98.04.01.18.08.36;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	97.03.20.14.50.09;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	97.01.30.05.40.16;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	96.11.19.21.03.21;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.04.01.22.15.35;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	95.08.02.21.32.55;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	95.07.25.17.52.08;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	95.06.28.13.20.02;	author gdurf;	state Exp;
branches;
next	;

1.22.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2004.03.17.21.21.59;	author morrison;	state Exp;
branches;
next	;

1.22.4.1
date	2002.09.26.23.04.11;	author morrison;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

1.22.10.1
date	2004.02.12.18.34.14;	author erikg;	state Exp;
branches;
next	1.22.10.2;

1.22.10.2
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Functions for history support
@


1.27
log
@moved to src/mged/
@
text
@/*
 *                           H I S T O R Y . C
 *
 *  Authors -
 *	Glenn Durfee
 *	Bob Parker
 *
 *  Functions -
 *      history_record - 
 *
 *  Source -
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <signal.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#ifndef WIN32
#include <sys/time.h>
#endif
#include <time.h>

#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./mgedtcl.h"

#if 0
struct mged_hist {
    struct bu_list l;
    struct bu_vls command;
    struct timeval start, finish;
    int status;
} mged_hist_head, *cur_hist;
#else
struct mged_hist mged_hist_head;
#endif

FILE *journalfp;
int firstjournal;
int journal_delay = 0;

void history_journalize(struct mged_hist *hptr);

/*
 *	H I S T O R Y _ R E C O R D
 *
 *	Stores the given command with start and finish times in the
 *	  history vls'es.
 */

void
history_record(
	struct bu_vls *cmdp,
	struct timeval *start,
	struct timeval *finish,
	int status)			   /* Either CMD_OK or CMD_BAD */
{
    struct mged_hist *new_hist;

    if (strcmp(bu_vls_addr(cmdp), "\n") == 0)
	return;

    new_hist = (struct mged_hist *)bu_malloc(sizeof(struct mged_hist),
					     "mged history");
    bu_vls_init(&(new_hist->mh_command));
    bu_vls_vlscat(&(new_hist->mh_command), cmdp);
    new_hist->mh_start = *start;
    new_hist->mh_finish = *finish;
    new_hist->mh_status = status;
    BU_LIST_INSERT(&(mged_hist_head.l), &(new_hist->l));

    /* As long as this isn't our first command to record after setting
       up the journal (which would be "journal", which we don't want
       recorded!)... */

    if (journalfp != NULL && !firstjournal)
	history_journalize(new_hist);

    curr_cmd_list->cl_cur_hist = &mged_hist_head;
    firstjournal = 0;
}

HIDDEN int
timediff(struct timeval *tvdiff, struct timeval *start, struct timeval *finish)
{
    if (finish->tv_sec == 0 && finish->tv_usec == 0)
	return -1;
    if (start->tv_sec == 0 && start->tv_usec == 0)
	return -1;
    
    tvdiff->tv_sec = finish->tv_sec - start->tv_sec;
    tvdiff->tv_usec = finish->tv_usec - start->tv_usec;
    if (tvdiff->tv_usec < 0) {
	--tvdiff->tv_sec;
	tvdiff->tv_usec += 1000000L;
    }

    return 0;
}

void
history_journalize(struct mged_hist *hptr)
{
    struct timeval tvdiff;
    struct mged_hist *lasthptr;

    lasthptr = BU_LIST_PREV(mged_hist, &(hptr->l));

    if (journal_delay && timediff(&tvdiff, &(lasthptr->mh_finish), &(hptr->mh_start)) >= 0)
	fprintf(journalfp, "delay %ld %ld\n", (long)tvdiff.tv_sec, (long)tvdiff.tv_usec);

    if (hptr->mh_status == CMD_BAD)
	fprintf(journalfp, "# ");
    fprintf(journalfp, "%s", bu_vls_addr(&hptr->mh_command));

    if (journal_delay)
      fprintf(journalfp, "mged_update 1\n");
}

/*
 *	F _ J O U R N A L
 *
 *	Opens the journal file, so each command and the time since the previous
 *	  one will be recorded.  Or, if called with no arguments, closes the
 *	  journal file.
 */

int
f_journal(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if(argc < 1 || 3 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help journal");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* close previously open journal file */
  if (journalfp != NULL) {
    fclose(journalfp);
    journalfp = NULL;
  }
  journal_delay = 0;

  if (argc < 2)
    return TCL_OK;

  if(argv[1][0] == '-' && argv[1][1] == 'd'){
    journal_delay = 1;
    ++argv;
    --argc;
  }

  if (argc < 2) {
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help journal");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  journalfp = fopen(argv[1], "a+");
  if (journalfp == NULL) {
    Tcl_AppendResult(interp, "Error opening ", argv[1],
		     " for appending\n", (char *)NULL);
    return TCL_ERROR;
  }
  firstjournal = 1;

  return TCL_OK;
}

/*
 *	F _ D E L A Y
 *
 * 	Uses select to delay for the specified amount of seconds and 
 *	  microseconds.
 */

int
f_delay(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    struct timeval tv;

    if(argc < 3 || 3 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help delay");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    tv.tv_sec = atoi(argv[1]);
    tv.tv_usec = atoi(argv[2]);
    select(0, NULL, NULL, NULL, &tv);

    return TCL_OK;
}

/*
 *	F _ H I S T O R Y
 *
 *	Prints out the command history, either to bu_log or to a file.
 */

int
f_history(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    FILE *fp;
    int with_delays = 0;
    struct mged_hist *hp, *hp_prev;
    struct bu_vls str;
    struct timeval tvdiff;

    if(argc < 1 || 4 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help history");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    fp = NULL;
    while( argc >= 2 ) {
	if( strcmp(argv[1], "-delays") == 0 )
	    with_delays = 1;
	else if( strcmp(argv[1], "-outfile") == 0 ) {
	    if( fp != NULL ) {
	      Tcl_AppendResult(interp, "history: -outfile option given more than once\n",
			       (char *)NULL);
	      return TCL_ERROR;
	    } else if( argc < 3 || strcmp(argv[2], "-delays") == 0 ) {
	      Tcl_AppendResult(interp, "history: I need a file name\n", (char *)NULL);
	      return TCL_ERROR;
	    } else {
		fp = fopen( argv[2], "a+" );
		if( fp == NULL ) {
		  Tcl_AppendResult(interp, "history: error opening file", (char *)NULL);
		  return TCL_ERROR;
		}
		--argc;
		++argv;
	    }
	} else {
	  Tcl_AppendResult(interp, "Invalid option ", argv[1], "\n", (char *)NULL);
	}
	--argc;
	++argv;
    }

    bu_vls_init(&str);
    for (BU_LIST_FOR(hp, mged_hist, &(mged_hist_head.l))) {
	bu_vls_trunc(&str, 0);
	hp_prev = BU_LIST_PREV(mged_hist, &(hp->l));
	if (with_delays && BU_LIST_NOT_HEAD(hp_prev, &(mged_hist_head.l))) {
	    if (timediff(&tvdiff, &(hp_prev->mh_finish), &(hp->mh_start)) >= 0)
		bu_vls_printf(&str, "delay %d %d\n", tvdiff.tv_sec,
			      tvdiff.tv_usec);
	}

	if (hp->mh_status == CMD_BAD)
	    bu_vls_printf(&str, "# ");
	bu_vls_vlscat(&str, &(hp->mh_command));

	if (fp != NULL)
	    bu_vls_fwrite(fp, &str);
	else
	  Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
    }

    if (fp != NULL)
	fclose(fp);

    return TCL_OK;
}

/*      H I S T O R Y _ P R E V
 */
struct bu_vls *
history_prev(void)
{
    struct mged_hist *hp;

    hp = BU_LIST_PREV(mged_hist, &(curr_cmd_list->cl_cur_hist->l));
    if (BU_LIST_IS_HEAD(hp, &(mged_hist_head.l)))
	return NULL;
    else {
	curr_cmd_list->cl_cur_hist = hp;
	return &(hp->mh_command);
    }
}

/*      H I S T O R Y _ C U R
 */
struct bu_vls *
history_cur(void)
{
    if (BU_LIST_IS_HEAD(curr_cmd_list->cl_cur_hist, &(mged_hist_head.l)))
	return NULL;
    else
	return &(curr_cmd_list->cl_cur_hist->mh_command);
}

/*      H I S T O R Y _ N E X T
 */
struct bu_vls *
history_next(void)
{
    struct mged_hist *hp;

    if (BU_LIST_IS_HEAD(curr_cmd_list->cl_cur_hist, &(mged_hist_head.l))) {
	return 0;
    }
    
    hp = BU_LIST_NEXT(mged_hist, &(curr_cmd_list->cl_cur_hist->l));
    if (BU_LIST_IS_HEAD(hp, &(mged_hist_head.l))) {
	curr_cmd_list->cl_cur_hist = hp;
	return 0;
    } else {
	curr_cmd_list->cl_cur_hist = hp;
	return &(hp->mh_command);
    }
}

int
cmd_hist(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct bu_vls *vp;
  struct bu_vls vls;

  bu_vls_init(&vls);

  if(argc < 2){
    bu_vls_printf(&vls, "helpdevel hist");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(strcmp(argv[1], "add") == 0){
    struct timeval zero;

    if(argc != 3){
      bu_vls_printf(&vls, "helpdevel hist");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    if (argv[2][0] == '\n' || argv[2][0] == '\0')
	return TCL_OK;

    bu_vls_strcpy(&vls, argv[2]);
    if (argv[2][strlen(argv[2])-1] != '\n')
	bu_vls_putc(&vls, '\n');

    zero.tv_sec = zero.tv_usec = 0L;
    history_record(&vls, &zero, &zero, CMD_OK);

    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(strcmp(argv[1], "next") == 0){
    if(argc != 2){
      bu_vls_printf(&vls, "helpdevel hist");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    vp = history_next();
    if (vp == NULL)
      return TCL_ERROR;

    Tcl_AppendResult(interp, bu_vls_addr(vp), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  if(strcmp(argv[1], "prev") == 0){
    if(argc != 2){
      bu_vls_printf(&vls, "helpdevel hist");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    vp = history_prev();
    if (vp == NULL)
      return TCL_ERROR;

    Tcl_AppendResult(interp, bu_vls_addr(vp), (char *)NULL);
    bu_vls_free(&vls);
    return TCL_OK;
  }

  bu_vls_printf(&vls, "helpdevel hist");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
  return TCL_ERROR;
}

void
history_setup(void)
{
    BU_LIST_INIT(&(mged_hist_head.l));
    curr_cmd_list->cl_cur_hist = &mged_hist_head;
    bu_vls_init(&(mged_hist_head.mh_command));
    mged_hist_head.mh_start.tv_sec = mged_hist_head.mh_start.tv_usec =
	mged_hist_head.mh_finish.tv_sec = mged_hist_head.mh_finish.tv_usec = 0L;
    mged_hist_head.mh_status = CMD_OK;
    journalfp = NULL;
}
@


1.26
log
@change conf.h to a wrapped config.h
@
text
@@


1.25
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 5
a29 1
#include "conf.h"
@


1.24
log
@merge of windows-6-0-branch into head
@
text
@d64 1
a64 1
void history_journalize();
d106 1
a106 2
timediff(tvdiff, start, finish)
struct timeval *tvdiff, *start, *finish;
d124 1
a124 2
history_journalize(hptr)
struct mged_hist *hptr;
d151 1
a151 5
f_journal(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d208 1
a208 5
f_delay(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d236 1
a236 5
f_history(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d311 1
a311 1
history_prev()
d327 1
a327 1
history_cur()
d338 1
a338 1
history_next()
d357 1
a357 5
cmd_hist(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
@


1.23
log
@update copyright to include span through 2003
@
text
@d34 1
d36 1
@


1.22
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1995 by the United States Army
@


1.22.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
@


1.22.10.2
log
@merge from head
@
text
@a33 1
#ifndef WIN32
a34 1
#endif
@


1.22.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a33 1
#ifndef WIN32
a34 1
#endif
@


1.22.4.2
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
@


1.22.2.1
log
@Initial ANSIfication
@
text
@d62 1
a62 1
void history_journalize(struct mged_hist *hptr);
d104 2
a105 1
timediff(struct timeval *tvdiff, struct timeval *start, struct timeval *finish)
d123 2
a124 1
history_journalize(struct mged_hist *hptr)
d151 5
a155 1
f_journal(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d212 5
a216 1
f_delay(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d244 5
a248 1
f_history(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d323 1
a323 1
history_prev(void)
d339 1
a339 1
history_cur(void)
d350 1
a350 1
history_next(void)
d369 5
a373 1
cmd_hist(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.22.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
a33 1
#ifndef WIN32
a34 1
#endif
@


1.21
log
@Converted from K&R to ANSI C - RFH
@
text
@d62 1
a62 1
void history_journalize(struct mged_hist *hptr);
d104 2
a105 1
timediff(struct timeval *tvdiff, struct timeval *start, struct timeval *finish)
d123 2
a124 1
history_journalize(struct mged_hist *hptr)
d151 5
a155 1
f_journal(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d212 5
a216 1
f_delay(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d244 5
a248 1
f_history(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d323 1
a323 1
history_prev(void)
d339 1
a339 1
history_cur(void)
d350 1
a350 1
history_next(void)
d369 5
a373 1
cmd_hist(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


1.20
log
@
Fixed compiler lint, function declarations.
@
text
@d62 1
a62 1
void history_journalize();
d104 1
a104 2
timediff(tvdiff, start, finish)
struct timeval *tvdiff, *start, *finish;
d122 1
a122 2
history_journalize(hptr)
struct mged_hist *hptr;
d149 1
a149 5
f_journal(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d206 1
a206 5
f_delay(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d234 1
a234 5
f_history(clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d309 1
a309 1
history_prev()
d325 1
a325 1
history_cur()
d336 1
a336 1
history_next()
d355 1
a355 5
cmd_hist(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
@


1.19
log
@
more lint
@
text
@d72 5
a76 4
history_record(cmdp, start, finish, status)
struct bu_vls *cmdp;
struct timeval *start, *finish;
int status;   /* Either CMD_OK or CMD_BAD */
d452 1
a452 1
history_setup()
@


1.18
log
@
lint
@
text
@d131 1
a131 1
	fprintf(journalfp, "delay %d %ld\n", tvdiff.tv_sec, (long)tvdiff.tv_usec);
@


1.17
log
@*- redo f_journal
*- collapse cmd_hist_add, cmd_prev and cmd_next into cmd_hist
@
text
@d131 1
a131 1
	fprintf(journalfp, "delay %d %ld\n", tvdiff.tv_sec, tvdiff.tv_usec);
@


1.16
log
@*- use helpdevel for help on developer commands
@
text
@d138 1
a138 1
      fprintf(journalfp, "mged_update\n");
d166 3
a168 3
  if (argc < 2) {
    if (journalfp != NULL)
      fclose(journalfp);
d170 4
a173 1
    journal_delay = 0;
d175 16
a190 5
  } else {
    if(argv[1][0] == '-' && argv[1][1] == 'd'){
      journal_delay = 1;
      ++argv;
    }
d192 5
a196 13
    if (journalfp != NULL) {
      Tcl_AppendResult(interp, "First shut off journaling with \"journal\" (no args)\n",
		       (char *)NULL);
      return TCL_ERROR;
    } else {
      journalfp = fopen(argv[1], "a+");
      if (journalfp == NULL) {
	Tcl_AppendResult(interp, "Error opening ", argv[1],
			 " for appending\n", (char *)NULL);
	return TCL_ERROR;
      }
      firstjournal = 1;
    }
d198 1
d200 1
a200 1
  return TCL_ERROR;
a366 6
/*
 *	C M D _ P R E V
 *
 *      Returns the previous command, looking through the history.
 */

d368 1
a368 1
cmd_prev(clientData, interp, argc, argv)
d374 11
a384 1
    struct bu_vls *vp;
d386 2
a387 2
    if(argc < 1 || 1 < argc){
      struct bu_vls vls;
d389 2
a390 2
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "helpdevel hist_prev");
d396 2
a397 3
    vp = history_prev();
    if (vp == NULL)
      return TCL_ERROR;
d399 3
a401 3
    Tcl_AppendResult(interp, bu_vls_addr(vp), (char *)NULL);
    return TCL_OK;
}
d403 2
a404 5
/*
 *	C M D _ N E X T
 *
 *      Returns the next command, looking through the history.
 */
d406 3
a408 11
int
cmd_next( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    struct bu_vls *vp;

    if(argc < 1 || 1 < argc){
      struct bu_vls vls;
d410 3
a412 2
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "helpdevel hist_next");
d423 1
d425 1
a425 12
}


int
cmd_hist_add(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    struct timeval zero;
    struct bu_vls vls;
d427 3
a429 5
    if(argc < 1 || 2 < argc){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "helpdevel hist_add");
d435 3
a437 2
    if (argc < 2)
	return TCL_OK;
d439 1
a439 11
    if (argv[1][0] == '\n')
	return TCL_OK;

    bu_vls_init(&vls);
    bu_vls_strcat(&vls, argv[1]);
    if (argv[1][strlen(argv[1])-1] != '\n')
	bu_vls_putc(&vls, '\n');

    zero.tv_sec = zero.tv_usec = 0L;
    history_record(&vls, &zero, &zero, CMD_OK);

d442 6
a460 1
    
@


1.15
log
@*- use new structures
*- cleanup
@
text
@d379 1
a379 1
      bu_vls_printf(&vls, "help hist_prev");
d412 1
a412 1
      bu_vls_printf(&vls, "help hist_next");
d441 1
a441 1
      bu_vls_printf(&vls, "help cmd_hist_add");
@


1.14
log
@*- fix typos
@
text
@d84 5
a88 5
    bu_vls_init(&(new_hist->command));
    bu_vls_vlscat(&(new_hist->command), cmdp);
    new_hist->start = *start;
    new_hist->finish = *finish;
    new_hist->status = status;
d98 1
a98 1
    curr_cmd_list->cur_hist = &mged_hist_head;
d130 1
a130 1
    if (journal_delay && timediff(&tvdiff, &(lasthptr->finish), &(hptr->start)) >= 0)
d133 1
a133 1
    if (hptr->status == CMD_BAD)
d135 1
a135 1
    fprintf(journalfp, "%s", bu_vls_addr(&hptr->command));
d291 1
a291 1
	    if (timediff(&tvdiff, &(hp_prev->finish), &(hp->start)) >= 0)
d296 1
a296 1
	if (hp->status == CMD_BAD)
d298 1
a298 1
	bu_vls_vlscat(&str, &(hp->command));
d319 1
a319 1
    hp = BU_LIST_PREV(mged_hist, &(curr_cmd_list->cur_hist->l));
d323 2
a324 2
	curr_cmd_list->cur_hist = hp;
	return &(hp->command);
d333 1
a333 1
    if (BU_LIST_IS_HEAD(curr_cmd_list->cur_hist, &(mged_hist_head.l)))
d336 1
a336 1
	return &(curr_cmd_list->cur_hist->command);
d346 1
a346 1
    if (BU_LIST_IS_HEAD(curr_cmd_list->cur_hist, &(mged_hist_head.l))) {
d350 1
a350 1
    hp = BU_LIST_NEXT(mged_hist, &(curr_cmd_list->cur_hist->l));
d352 1
a352 1
	curr_cmd_list->cur_hist = hp;
d355 2
a356 2
	curr_cmd_list->cur_hist = hp;
	return &(hp->command);
d469 5
a473 5
    curr_cmd_list->cur_hist = &mged_hist_head;
    bu_vls_init(&(mged_hist_head.command));
    mged_hist_head.start.tv_sec = mged_hist_head.start.tv_usec =
	mged_hist_head.finish.tv_sec = mged_hist_head.finish.tv_usec = 0L;
    mged_hist_head.status = CMD_OK;
@


1.13
log
@mods to cmd_prev() and cmd_next()
@
text
@d131 1
a131 1
	fprintf(journalfp, "delay %d %d\n", tvdiff.tv_sec, tvdiff.tv_usec);
@


1.12
log
@modify calls to Tcl_Eval
@
text
@d387 1
a387 1
	vp = &(curr_cmd_list->cur_hist->command);
d420 1
a420 1
	vp = &(curr_cmd_list->cur_hist->command);
@


1.11
log
@mods so that commands check args internally
@
text
@d157 6
a162 1
    Tcl_Eval(interp, "help journal");
d213 6
a218 1
      Tcl_Eval(interp, "help delay");
d249 6
a254 1
      Tcl_Eval(interp, "help history");
d376 6
a381 1
      Tcl_Eval(interp, "help hist_prev");
d409 6
a414 1
      Tcl_Eval(interp, "help hist_next");
d438 6
a443 1
      Tcl_Eval(interp, "help cmd_hist_add");
@


1.10
log
@*- add -d option to journal command
*- add call mged_update to journal command
@
text
@d156 2
a157 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d159 1
d207 2
a208 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d210 1
d238 2
a239 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d241 1
d360 2
a361 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d363 1
d388 2
a389 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d391 1
d412 2
a413 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d415 1
@


1.9
log
@Don't need db.h
@
text
@d60 1
d129 2
a130 1
    if (timediff(&tvdiff, &(lasthptr->finish), &(hptr->start)) >= 0)
d132 1
a132 1
    
d136 3
d163 1
d166 5
@


1.8
log
@fixed an oversight
@
text
@a41 1
#include "db.h"
@


1.7
log
@rt_list ---> bu_list
@
text
@d134 1
a134 1
    fprintf(journalfp, "%s", hptr->command);
@


1.6
log
@now using libbu
@
text
@d40 1
a43 2
#include "rtstring.h"
#include "rtlist.h"
d50 1
a50 1
    struct rt_list l;
d89 1
a89 1
    RT_LIST_INSERT(&(mged_hist_head.l), &(new_hist->l));
d128 1
a128 1
    lasthptr = RT_LIST_PREV(mged_hist, &(hptr->l));
d256 1
a256 1
    for (RT_LIST_FOR(hp, mged_hist, &(mged_hist_head.l))) {
d258 2
a259 2
	hp_prev = RT_LIST_PREV(mged_hist, &(hp->l));
	if (with_delays && RT_LIST_NOT_HEAD(hp_prev, &(mged_hist_head.l))) {
d288 2
a289 2
    hp = RT_LIST_PREV(mged_hist, &(curr_cmd_list->cur_hist->l));
    if (RT_LIST_IS_HEAD(hp, &(mged_hist_head.l)))
d302 1
a302 1
    if (RT_LIST_IS_HEAD(curr_cmd_list->cur_hist, &(mged_hist_head.l)))
d315 1
a315 1
    if (RT_LIST_IS_HEAD(curr_cmd_list->cur_hist, &(mged_hist_head.l))) {
d319 2
a320 2
    hp = RT_LIST_NEXT(mged_hist, &(curr_cmd_list->cur_hist->l));
    if (RT_LIST_IS_HEAD(hp, &(mged_hist_head.l))) {
d416 1
a416 1
    RT_LIST_INIT(&(mged_hist_head.l));
@


1.5
log
@convert commands to Tcl
@
text
@d52 1
a52 1
    struct rt_vls command;
d74 1
a74 1
struct rt_vls *cmdp;
d80 1
a80 1
    if (strcmp(rt_vls_addr(cmdp), "\n") == 0)
d83 1
a83 1
    new_hist = (struct mged_hist *)rt_malloc(sizeof(struct mged_hist),
d85 2
a86 2
    rt_vls_init(&(new_hist->command));
    rt_vls_vlscat(&(new_hist->command), cmdp);
d209 1
a209 1
 *	Prints out the command history, either to rt_log or to a file.
d222 1
a222 1
    struct rt_vls str;
d256 1
a256 1
    rt_vls_init(&str);
d258 1
a258 1
	rt_vls_trunc(&str, 0);
d262 1
a262 1
		rt_vls_printf(&str, "delay %d %d\n", tvdiff.tv_sec,
d267 2
a268 2
	    rt_vls_printf(&str, "# ");
	rt_vls_vlscat(&str, &(hp->command));
d271 1
a271 1
	    rt_vls_fwrite(fp, &str);
d273 1
a273 1
	  Tcl_AppendResult(interp, rt_vls_addr(&str), (char *)NULL);
d284 1
a284 1
struct rt_vls *
d300 1
a300 1
struct rt_vls *
d311 1
a311 1
struct rt_vls *
d343 1
a343 1
    struct rt_vls *vp;
d352 1
a352 1
    Tcl_AppendResult(interp, rt_vls_addr(vp), (char *)NULL);
d369 1
a369 1
    struct rt_vls *vp;
d378 1
a378 1
    Tcl_AppendResult(interp, rt_vls_addr(vp), (char *)NULL);
d391 1
a391 1
    struct rt_vls vls;
d402 2
a403 2
    rt_vls_init(&vls);
    rt_vls_strcat(&vls, argv[1]);
d405 1
a405 1
	rt_vls_putc(&vls, '\n');
d410 1
a410 1
    rt_vls_free(&vls);
d419 1
a419 1
    rt_vls_init(&(mged_hist_head.command));
@


1.4
log
@added code to help handle multiple command windows
@
text
@d147 3
a149 1
f_journal(argc, argv)
d153 13
a165 5
    if (argc < 2) {
	if (journalfp != NULL)
	    fclose(journalfp);
	journalfp = NULL;
	return CMD_OK;
d167 7
a173 11
	if (journalfp != NULL) {
	    rt_log("First shut off journaling with \"journal\" (no args)\n");
	    return CMD_BAD;
	} else {
	    journalfp = fopen(argv[1], "a+");
	    if (journalfp == NULL) {
		rt_log("Error opening %s for appending\n", argv[1]);
		return CMD_BAD;
	    }
	    firstjournal = 1;
	}
d175 3
a177 1
    return CMD_OK;
d188 3
a190 1
f_delay(argc, argv)
d196 3
d203 1
a203 1
    return CMD_OK;
d213 3
a215 1
f_history( argc, argv )
d224 4
a227 1
    
d234 3
a236 2
		rt_log( "history: -outfile option given more than once\n" );
		return CMD_BAD;
d238 2
a239 2
		rt_log( "history: I need a file name\n" );
		return CMD_BAD;
d243 2
a244 2
		    rt_log( "history: error opening file" );
		    return CMD_BAD;
d250 1
a250 1
	    rt_log( "Invalid option %s\n", argv[1] );
d273 1
a273 1
	    rt_log("%s", rt_vls_addr(&str));
d279 1
a279 1
    return CMD_OK;
d344 4
d352 1
a352 1
    Tcl_SetResult(interp, rt_vls_addr(vp), TCL_VOLATILE);
d370 4
d378 1
a378 1
    Tcl_SetResult(interp, rt_vls_addr(vp), TCL_VOLATILE);
d392 3
@


1.3
log
@Added cmd_hist_add
@
text
@d49 1
d56 3
d99 1
a99 1
    cur_hist = &mged_hist_head;
d270 1
a270 1
    hp = RT_LIST_PREV(mged_hist, &(cur_hist->l));
d274 1
a274 1
	cur_hist = hp;
d284 1
a284 1
    if (RT_LIST_IS_HEAD(cur_hist, &(mged_hist_head.l)))
d287 1
a287 1
	return &(cur_hist->command);
d297 1
a297 1
    if (RT_LIST_IS_HEAD(cur_hist, &(mged_hist_head.l))) {
d301 1
a301 1
    hp = RT_LIST_NEXT(mged_hist, &(cur_hist->l));
d303 1
a303 1
	cur_hist = hp;
d306 1
a306 1
	cur_hist = hp;
d327 1
a327 1
	vp = &(cur_hist->command);
d349 1
a349 1
	vp = &(cur_hist->command);
d388 1
a388 1
    cur_hist = &mged_hist_head;
@


1.2
log
@Added history_cur and Tcl versions
@
text
@a36 1
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
a37 1
#include "tk.h"
d47 1
d99 1
a99 1
HIDDEN void
d103 5
d114 2
d126 3
a128 3
    timediff(&tvdiff, &(lasthptr->finish), &(hptr->start));

    fprintf(journalfp, "delay %d %d\n", tvdiff.tv_sec, tvdiff.tv_usec);
d238 3
a240 3
	    timediff(&tvdiff, &(hp_prev->finish), &(hp->start));
	    rt_vls_printf(&str, "delay %d %d\n", tvdiff.tv_sec,
			  tvdiff.tv_usec);
d293 4
d352 28
d385 4
@


1.1
log
@Initial revision
@
text
@d46 1
d50 6
a55 4
struct rt_vls history;
struct rt_vls replay_history;
struct timeval lastfinish;
long int hist_index;
d60 2
d75 1
a75 3
    static int done = 0;
    struct rt_vls timing;
    struct rt_vls command;
d77 2
a78 9
    rt_vls_init(&timing);
    rt_vls_init(&command);
    
    if (status == CMD_BAD) {
	rt_vls_strcpy(&command, "# ");
	rt_vls_vlscat(&command, cmdp);
    } else {
	rt_vls_vlscat(&command, cmdp);
    }
d80 8
a87 11
    if (done != 0) {
	if (lastfinish.tv_usec > start->tv_usec) {
	    rt_vls_printf(&timing, "delay %ld %08ld\n",
			  start->tv_sec - lastfinish.tv_sec - 1,
			  start->tv_usec - lastfinish.tv_usec + 1000000L);
	} else {
	    rt_vls_printf(&timing, "delay %ld %08ld\n",
			  start->tv_sec - lastfinish.tv_sec,
			  start->tv_usec - lastfinish.tv_usec);
	}
    }		
d93 16
a108 3
    if (journalfp != NULL && !firstjournal) {
	rt_vls_fwrite(journalfp, &timing);
	rt_vls_fwrite(journalfp, &command);
d110 1
a110 3
    
    rt_vls_vlscat(&replay_history, &timing);
    rt_vls_vlscat(&replay_history, &command);
d112 6
a117 1
    rt_vls_vlscat(&history, &command);
d119 2
a120 4
    lastfinish.tv_sec = finish->tv_sec;
    lastfinish.tv_usec = finish->tv_usec;
    done = 1;
    firstjournal = 0;
d122 5
a126 2
    rt_vls_free(&command);
    rt_vls_free(&timing);
a127 3
    hist_index = rt_vls_strlen(&history) - 1;
}		

a158 1

d194 22
a215 31
	FILE *fp;
	struct rt_vls *which_history;

	fp = NULL;
	which_history = &history;

	while( argc >= 2 ) {
		if( strcmp(argv[1], "-delays") == 0 ) {
			if( which_history == &replay_history ) {
				rt_log( "history: -delays option given more than once\n" );
				return CMD_BAD;
			}
			which_history = &replay_history;
		} else if( strcmp(argv[1], "-outfile") == 0 ) {
			if( fp != NULL ) {
				rt_log( "history: -outfile option given more than once\n" );
				return CMD_BAD;
			} else if( argc < 3 || strcmp(argv[2], "-delays") == 0 ) {
				rt_log( "history: I need a file name\n" );
				return CMD_BAD;
			} else {
				fp = fopen( argv[2], "a+" );
				if( fp == NULL ) {
					rt_log( "history: error opening file" );
					return CMD_BAD;
				}
				--argc;
				++argv;
			}
		} else {
			rt_log( "Invalid option %s\n", argv[1] );
d219 3
d223 3
d227 8
a234 5
	if( fp == NULL ) {
		rt_log( "%s", rt_vls_addr(which_history) );
	} else {
		rt_vls_fwrite( fp, which_history );
		fclose( fp );
d237 58
a294 1
	return CMD_OK;
d310 4
a313 14
    struct rt_vls result;
    register char *cp;

    cp = rt_vls_addr(&history) + hist_index;

    do {
	--cp;
	--hist_index;
    } while (hist_index > 0 && *cp != '\n');

    rt_vls_init(&result);
    if (*cp == '\n') ++cp;
    while (*cp && *cp != '\n')
	rt_vls_putc(&result, (int)(*cp++));
d315 1
a315 3
    Tcl_SetResult(interp, rt_vls_addr(&result), TCL_VOLATILE);

    rt_vls_free(&result);
d332 7
a338 1
	return TCL_OK;
d345 2
a346 2
    rt_vls_init(&history);
    rt_vls_init(&replay_history);
a347 1
    hist_index = 0;
@
