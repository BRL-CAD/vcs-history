head	1.12;
access;
symbols
	ansi-20040405-merged:1.8.2.2
	postmerge-20040405-ansi:1.10
	premerge-20040404-ansi:1.9
	postmerge-autoconf:1.9
	autoconf-freeze:1.8.10.2
	premerge-autoconf:1.9
	postmerge-20040315-windows:1.9
	premerge-20040315-windows:1.9
	windows-20040315-freeze:1.8.4.1
	autoconf-20031203:1.8
	autoconf-20031202:1.8
	autoconf-branch:1.8.0.10
	phong-branch:1.8.0.8
	photonmap-branch:1.8.0.6
	rel-6-1-DP:1.8
	windows-branch:1.8.0.4
	rel-6-0-2:1.6
	ansi-branch:1.8.0.2
	rel-6-0-1-branch:1.6.0.2
	hartley-6-0-post:1.7
	hartley-6-0-pre:1.6
	rel-6-0-1:1.6
	rel-6-0:1.6
	rel-5-4:1.5
	offsite-5-3-pre:1.6
	rel-5-3:1.5
	rel-5-2:1.5
	rel-5-1-branch:1.5.0.2
	rel-5-1:1.5
	rel-5-0:1.5
	rel-5-0-beta:1.5
	rel-4-5:1.5
	ctj-4-5-post:1.5
	ctj-4-5-pre:1.5;
locks; strict;
comment	@ * @;


1.12
date	2004.05.21.17.47.35;	author morrison;	state dead;
branches;
next	1.11;

1.11
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.02.17.39.31;	author morrison;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	1.8.2.1
	1.8.4.1
	1.8.10.1;
next	1.7;

1.7
date	2002.08.15.20.55.31;	author hartley;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.19.03.10.41;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.20.26.00;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	95.08.10.21.09.03;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	95.06.23.20.19.37;	author pjt;	state Exp;
branches;
next	;

1.8.2.1
date	2002.09.19.18.01.59;	author morrison;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2004.03.17.21.21.55;	author morrison;	state Exp;
branches;
next	;

1.8.4.1
date	2004.03.11.23.46.33;	author morrison;	state Exp;
branches;
next	;

1.8.10.1
date	2004.02.12.18.34.12;	author erikg;	state Exp;
branches;
next	1.8.10.2;

1.8.10.2
date	2004.03.15.14.07.35;	author erikg;	state Exp;
branches;
next	;


desc
@     Conversion routines to mangle an arbitrary Boolean tree,
leaving it in GIFT-Boolean form.
@


1.12
log
@moved to src/mged/
@
text
@/*
 *			B O O L _ R E W R I T E . C
 *
 *	Conversion routines to mangle an arbitrary Boolean tree,
 *	leaving it in GIFT-Boolean form.
 *
 *  Author -
 *	Paul Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/bool_rewrite.c,v 1.11 2004/05/10 15:30:48 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./comb_bool.h"
#include "./ged.h"

/*
 *	A Boolean expression tree is in GIFT-Boolean form provided
 *	that
 *	    - every internal node is one of the operators
 *	      UNION, INTERSECTION, and DIFFERENCE;
 *	    - any UNION nodes occur consecutively, starting
 *	      at the root and proceeding leftward; and
 *	    - every INTERSECTION and DIFFERENCE node has
 *	      a leaf for a right child.
 *
 *	The conversion algorithm proceeds by performing a breadth-first
 *	traversal of the tree (actually a DAG), converting each internal
 *	node as necessary.  This conversion consists in distributing
 *	intersections and differences across unions, and generally
 *	adjusting the associativity and precedence of subexpressions.
 *	Specifically, the following nine graph-rewrite rules are applied:
 *
 *		1.  a U (b U c)  -->  (a U b) U c
 *		2.  (a U b) * c  -->  (a * c) U (b * c)
 *		3.  a * (b U c)  -->  (a * b) U (a * c)
 *		4.  (a U b) - c  -->  (a - c) U (b - c)
 *		5.  a - (b U c)  -->  (a - b) - c
 *		6.  a * (b * c)  -->  (a * b) * c
 *		7.  a - (b * c)  -->  (a - b) U (a - c)
 *		8.  a * (b - c)  -->  (a * b) - c
 *		9.  a - (b - c)  -->  (a - b) U (a * c)
 */

/*
 *	    F I N D _ B O O L _ T R E E _ R E W R I T E ( )
 *
 *	Find an applicable rewrite for the root of a Boolean tree
 *
 *	This function has one parameter:  a Boolean-tree node.
 *	Find_bool_tree_rewrite() compares the structure of the
 *	subtree rooted at the specified node to the LHS's of
 *	the rewrite rules and returns the number of the first
 *	match it finds.
 */
static int find_bool_tree_rewrite (struct bool_tree_node *rp)
{
    int		rule_nm;	/* An applicable rule */
    int		lop;		/* Left child's operation */
    int		rop;		/* Right   "        "     */
    
    BU_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");

    BU_CKMAG(bt_opd(rp, BT_LEFT), BOOL_TREE_NODE_MAGIC, "Boolean tree node");
    BU_CKMAG(bt_opd(rp, BT_RIGHT), BOOL_TREE_NODE_MAGIC, "Boolean tree node");
    lop = bt_opn(bt_opd(rp, BT_LEFT));
    rop = bt_opn(bt_opd(rp, BT_RIGHT));
    rule_nm = 0;

    switch (bt_opn(rp))
    {
	case OPN_UNION:
	    if (rop == OPN_UNION)
		rule_nm = 1;
	    break;
	case OPN_INTERSECTION:
	    if (lop == OPN_UNION)
		rule_nm = 2;
	    else
		switch (rop)
		{
		    case OPN_UNION:		rule_nm = 3; break;
		    case OPN_INTERSECTION:	rule_nm = 6; break;
		    case OPN_DIFFERENCE:	rule_nm = 8; break;
		}
	    break;
	case OPN_DIFFERENCE:
	    if (lop == OPN_UNION)
		rule_nm = 4;
	    else
		switch (rop)
		{
		    case OPN_UNION:		rule_nm = 5; break;
		    case OPN_INTERSECTION:	rule_nm = 7; break;
		    case OPN_DIFFERENCE:	rule_nm = 9; break;
		}
	    break;
	default:
	    bu_log("Reached %s:%d.  This shouldn't happen\n",
		    __FILE__, __LINE__);
	    exit (1);
    }

    return (rule_nm);
}

/*
 *		    D U P _ B O O L _ T R E E ( )
 *
 *			Duplicate a Boolean tree
 *
 *	This function has one parameter:  a Boolean-tree node.
 *	Dup_bool_tree() recursively copies the subtree rooted at
 *	the specified node and returns a pointer to the root of
 *	the copy.
 */
static struct bool_tree_node *dup_bool_tree (struct bool_tree_node *rp)
{
    BU_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");

    if (bt_is_leaf(rp))
	return (rp);
    else
	return (bt_create_internal(bt_opn(rp),
		    dup_bool_tree(bt_opd(rp, BT_LEFT)),
		    dup_bool_tree(bt_opd(rp, BT_RIGHT))));
}

/*
 *		D O _ B O O L _ T R E E _ R E W R I T E ( )
 *
 *	Perform one rewrite step on the root of a Boolean tree
 *
 *	This function has two parameters:  a Boolean-tree node and
 *	a rule number.  Do_bool_tree_rewrite() applies the specified
 *	rewrite rule to the subtree rooted at the specified node.
 */
static void do_bool_tree_rewrite (struct bool_tree_node *rp, int rule_nm)
{
    struct bool_tree_node	*left;		/* Left child of the root */
    struct bool_tree_node	*right;		/* Right  "   "   "   "   */
    struct bool_tree_node	*a, *b, *c;	/* Subtrees unchanged */

    BU_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");

    left = bt_opd(rp, BT_LEFT);
    right = bt_opd(rp, BT_RIGHT);
    BU_CKMAG(left, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
    BU_CKMAG(right, BOOL_TREE_NODE_MAGIC, "Boolean tree node");

    switch (rule_nm)
    {
	case 0:
	    return;
	case 1:		/*  a U (b U c)  :  (a U b) U c  */
	case 5:		/*  a - (b U c)  :  (a - b) - c  */
	case 6:		/*  a * (b * c)  :  (a * b) * c  */
	case 8:		/*  a * (b - c)  :  (a * b) - c  */
	    a = left;
	    b = bt_opd(right, BT_LEFT);
	    c = bt_opd(right, BT_RIGHT);
	    bt_opd(rp, BT_LEFT) = right;
	    bt_opd(bt_opd(rp, BT_LEFT), BT_LEFT) = a;
	    bt_opd(bt_opd(rp, BT_LEFT), BT_RIGHT) = b;
	    bt_opd(rp, BT_RIGHT) = c;
	    bt_opn(bt_opd(rp, BT_LEFT)) = bt_opn(rp);
	    if ((rule_nm == 5) || (rule_nm == 8))
	       bt_opn(rp) = OPN_DIFFERENCE;
	    break;
	case 2:		/*  (a U b) * c  :  (a * c) U (b * c)  */
	case 4:		/*  (a U b) - c  :  (a - c) U (b - c)  */
	    a = bt_opd(left, BT_LEFT);
	    b = bt_opd(left, BT_RIGHT);
	    c = right;
	    bt_opn(left) = bt_opn(rp);
	    bt_opd(left, BT_RIGHT) = dup_bool_tree(c);
	    bt_opn(rp) = OPN_UNION;
	    bt_opd(rp, BT_RIGHT) = bt_create_internal(bt_opn(left), b, c);
	    break;
	case 3:		/*  a * (b U c)  :  (a * b) U (a * c)  */
	case 7:		/*  a - (b * c)  :  (a - b) U (a - c)  */
	case 9:		/*  a - (b - c)  :  (a - b) U (a * c)  */
	    a = left;
	    b = bt_opd(right, BT_LEFT);
	    c = bt_opd(right, BT_RIGHT);
	    bt_opd(rp, BT_LEFT) = bt_create_internal(bt_opn(rp), a, b);
	    bt_opn(rp) = OPN_UNION;
	    bt_opn(right) = (rule_nm == 7) ? OPN_DIFFERENCE
					   : OPN_INTERSECTION;
	    bt_opd(right, BT_LEFT) = dup_bool_tree(a);
	    break;
	default:
	    bu_log("Reached %s:%d.  This shouldn't happen\n",
		    __FILE__, __LINE__);
	    exit (1);
    }
}

/*
 *		C O N V E R T _ O N E _ N O D E ( )
 *
 *	    Successively rewrite the root of a Boolean tree
 *
 *	This function has one parameter:  a Boolean-tree node.
 *	Convert_one_node() iteratively rewrites the subtree rooted
 *	at the specified node until it no longer matches the LHS
 *	of any of the rewrite rules.  It returns the number of
 *	times a rewrite rule was applied.
 */
static int convert_one_node (struct bool_tree_node *rp)
{
    int		lisp = 1;
    int		rule_nm;
    int		nm_rewrites;

    BU_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");

    for (nm_rewrites = 0; rule_nm = find_bool_tree_rewrite(rp); ++nm_rewrites)
	do_bool_tree_rewrite(rp, rule_nm);
    
    return (nm_rewrites);
}

/*
 *		_ C V T _ T O _ G I F T _ B O O L ( )
 *
 *	    Make one conversion pass through a Boolean tree
 *
 *	This function has one parameter:  a Boolean-tree node.
 *	_cvt_to_gift_bool() recursively rewrites the subtree rooted
 *	at the specified node.  It returns the number of times a
 *	rewrite rule was applied.
 */
static int _cvt_to_gift_bool (struct bool_tree_node *rp)
{
    int		nm_rewrites;

    BU_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");

    if (bt_is_leaf(rp))
	return (0);

    nm_rewrites = convert_one_node(rp);
    nm_rewrites += _cvt_to_gift_bool(bt_opd(rp, BT_LEFT));
    nm_rewrites += _cvt_to_gift_bool(bt_opd(rp, BT_RIGHT));

    return (nm_rewrites);
}

/*
 *		    C V T _ T O _ G I F T _ B O O L ( )
 *
 *		Convert a Boolean tree to GIFT-Boolean form.
 *
 *	This function has one parameter:  a Boolean-tree node.
 *	Cvt_to_gift_bool() recursively rewrites the subtree rooted
 *	at the specified node.  It returns the number of times a
 *	rewrite rule was applied.
 */
int cvt_to_gift_bool (struct bool_tree_node *rp)
{
    int		cnr;		/* Cumulative number of rewrites */
    int		nr;		/* Number of rewrites in this pass */

    BU_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");


    for (cnr = 0; nr = _cvt_to_gift_bool(rp); cnr += nr) {
	;
#if 0
	show_tree (rp, 1);
#endif
    }
    
    return (cnr);
}

/*
 *		    S H O W _ G I F T _ B O O L ( )
 *
 *		    Pretty print a GIFT-Boolean tree.
 *
 *	This function has two parameters:  a Boolean-tree node and
 *	a flag.  Show_gift_bool() prints the expression in GIFT format
 *	by performing an inorder traversal of the subtree rooted at
 *	the specified node.  If the flag is nonzero, it prints a
 *	final newline.
 */
void
show_gift_bool (struct bool_tree_node *rp, int new_line)
{
  BU_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");

  if (bt_is_leaf(rp))
    Tcl_AppendResult(interp, bt_leaf_name(rp), (char *)NULL);
  else{
    show_gift_bool(bt_opd(rp, BT_LEFT), 0);
    switch (bt_opn(rp)){
    case OPN_UNION:
      Tcl_AppendResult(interp, " u ", (char *)NULL);
      break;
    case OPN_DIFFERENCE:
      Tcl_AppendResult(interp, " - ", (char *)NULL);
      break;
    case OPN_INTERSECTION:
      Tcl_AppendResult(interp, " + ", (char *)NULL);
      break;
    default:
      {
	struct bu_vls tmp_vls;

	bu_vls_init(&tmp_vls);
	bu_vls_printf(&tmp_vls, "%s:%d: Illegal operation type: %d\n",
		      __FILE__, __LINE__, bt_opn(rp));
	Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	bu_vls_free(&tmp_vls);

	exit(1);
      }
    }

    show_gift_bool(bt_opd(rp, BT_RIGHT), 0);
  }

  if (new_line)
    Tcl_AppendResult(interp, "\n", (char *)NULL);
}
@


1.11
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/bool_rewrite.c,v 1.10 2004/04/05 09:09:11 morrison Exp $ (ARL)";
@


1.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d27 5
a31 1
#include "conf.h"
@


1.9
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bool_rewrite.c,v 1.8 2002/08/20 17:08:21 jra Exp $ (ARL)";
d76 1
a76 4
static int find_bool_tree_rewrite (rp)

struct bool_tree_node	*rp;

d137 1
a137 4
static struct bool_tree_node *dup_bool_tree (rp)

struct bool_tree_node	*rp;

d158 1
a158 5
static void do_bool_tree_rewrite (rp, rule_nm)

struct bool_tree_node	*rp;
int			rule_nm;

d230 1
a230 4
static int convert_one_node (rp)

struct bool_tree_node	*rp;

d254 1
a254 4
static int _cvt_to_gift_bool (rp)

struct bool_tree_node	*rp;

d280 1
a280 4
int cvt_to_gift_bool (rp)

struct bool_tree_node	*rp;

d310 1
a310 3
show_gift_bool (rp, new_line)
struct bool_tree_node	*rp;
int			new_line;
@


1.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1995 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bool_rewrite.c,v 1.6 2000/08/19 03:10:41 mike Exp $ (ARL)";
@


1.8.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/bool_rewrite.c,v 1.9 2004/02/02 17:39:31 morrison Exp $ (ARL)";
@


1.8.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bool_rewrite.c,v 1.9 2004/02/02 17:39:31 morrison Exp $ (ARL)";
@


1.8.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bool_rewrite.c,v 1.8.10.1 2004/02/12 18:34:12 erikg Exp $ (ARL)";
@


1.8.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bool_rewrite.c,v 1.8 2002/08/20 17:08:21 jra Exp $ (ARL)";
d76 4
a79 1
static int find_bool_tree_rewrite (struct bool_tree_node *rp)
d140 4
a143 1
static struct bool_tree_node *dup_bool_tree (struct bool_tree_node *rp)
d164 5
a168 1
static void do_bool_tree_rewrite (struct bool_tree_node *rp, int rule_nm)
d240 4
a243 1
static int convert_one_node (struct bool_tree_node *rp)
d267 4
a270 1
static int _cvt_to_gift_bool (struct bool_tree_node *rp)
d296 4
a299 1
int cvt_to_gift_bool (struct bool_tree_node *rp)
d329 3
a331 1
show_gift_bool (struct bool_tree_node *rp, int new_line)
@


1.8.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d76 4
a79 1
static int find_bool_tree_rewrite (struct bool_tree_node *rp)
d140 4
a143 1
static struct bool_tree_node *dup_bool_tree (struct bool_tree_node *rp)
d164 5
a168 1
static void do_bool_tree_rewrite (struct bool_tree_node *rp, int rule_nm)
d240 4
a243 1
static int convert_one_node (struct bool_tree_node *rp)
d267 4
a270 1
static int _cvt_to_gift_bool (struct bool_tree_node *rp)
d296 4
a299 1
int cvt_to_gift_bool (struct bool_tree_node *rp)
d329 3
a331 1
show_gift_bool (struct bool_tree_node *rp, int new_line)
@


1.6
log
@
const RCSid
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/bool_rewrite.c,v 1.5 1996/09/03 20:02:37 bparker Exp $ (ARL)";
d76 1
a76 4
static int find_bool_tree_rewrite (rp)

struct bool_tree_node	*rp;

d137 1
a137 4
static struct bool_tree_node *dup_bool_tree (rp)

struct bool_tree_node	*rp;

d158 1
a158 5
static void do_bool_tree_rewrite (rp, rule_nm)

struct bool_tree_node	*rp;
int			rule_nm;

d230 1
a230 4
static int convert_one_node (rp)

struct bool_tree_node	*rp;

d254 1
a254 4
static int _cvt_to_gift_bool (rp)

struct bool_tree_node	*rp;

d280 1
a280 4
int cvt_to_gift_bool (rp)

struct bool_tree_node	*rp;

d310 1
a310 3
show_gift_bool (rp, new_line)
struct bool_tree_node	*rp;
int			new_line;
@


1.5
log
@rt_list ---> bu_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/bool_rewrite.c,v 1.4 1996/08/27 20:30:05 bparker Exp bparker $ (ARL)";
@


1.4
log
@now using libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/bool_rewrite.c,v 1.3 1996/04/18 20:26:00 bparker Exp bparker $ (ARL)";
d31 1
@


1.3
log
@convert commands to Tcl
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/bool_rewrite.c,v 1.2 1995/08/10 21:09:03 gdurf Exp bparker $ (ARL)";
d84 1
a84 1
    RT_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d86 2
a87 2
    RT_CKMAG(bt_opd(rp, BT_LEFT), BOOL_TREE_NODE_MAGIC, "Boolean tree node");
    RT_CKMAG(bt_opd(rp, BT_RIGHT), BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d121 1
a121 1
	    rt_log("Reached %s:%d.  This shouldn't happen\n",
d144 1
a144 1
    RT_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d173 1
a173 1
    RT_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d177 2
a178 2
    RT_CKMAG(left, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
    RT_CKMAG(right, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d222 1
a222 1
	    rt_log("Reached %s:%d.  This shouldn't happen\n",
d248 1
a248 1
    RT_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d273 1
a273 1
    RT_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d303 1
a303 1
    RT_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d332 1
a332 1
  RT_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d350 1
a350 1
	struct rt_vls tmp_vls;
d352 2
a353 2
	rt_vls_init(&tmp_vls);
	rt_vls_printf(&tmp_vls, "%s:%d: Illegal operation type: %d\n",
d355 2
a356 2
	Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	rt_vls_free(&tmp_vls);
@


1.2
log
@Removed reference to show_tree
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/bool_rewrite.c,v 1.1 1995/06/23 20:19:37 pjt Exp gdurf $ (ARL)";
d34 1
d327 2
a328 2
void show_gift_bool (rp, new_line)

d331 2
d334 23
a356 2
{
    RT_CKMAG(rp, BOOL_TREE_NODE_MAGIC, "Boolean tree node");
d358 2
a359 16
    if (bt_is_leaf(rp))
	rt_log("%s", bt_leaf_name(rp));
    else
    {
	show_gift_bool(bt_opd(rp, BT_LEFT), 0);
	switch (bt_opn(rp))
	{
	    case OPN_UNION:		rt_log(" u "); break;
	    case OPN_DIFFERENCE:	rt_log(" - "); break;
	    case OPN_INTERSECTION:	rt_log(" + "); break;
	    default:
		rt_log("%s:%d: Illegal operation type: %d\n",
			__FILE__, __LINE__, bt_opn(rp));
		exit (1);
	}
	show_gift_bool(bt_opd(rp, BT_RIGHT), 0);
d362 5
a366 2
    if (new_line)
	(void) putchar('\n');
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /vld/pjt/regions/RCS/rewrite.c,v 1.4 1995/06/21 18:31:30 pjt Exp pjt $ (ARL)";
d304 4
a307 1
    for (cnr = 0; nr = _cvt_to_gift_bool(rp); cnr += nr)
d309 2
@
