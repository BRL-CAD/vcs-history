head	11.68;
access;
symbols
	ansi-20040405-merged:11.63.2.2
	postmerge-20040405-ansi:11.65
	premerge-20040404-ansi:11.64
	postmerge-autoconf:11.64
	autoconf-freeze:11.63.10.2
	premerge-autoconf:11.64
	postmerge-20040315-windows:11.64
	premerge-20040315-windows:11.64
	windows-20040315-freeze:11.63.4.1
	autoconf-20031203:11.63
	autoconf-20031202:11.63
	autoconf-branch:11.63.0.10
	phong-branch:11.63.0.8
	photonmap-branch:11.63.0.6
	rel-6-1-DP:11.63
	windows-branch:11.63.0.4
	rel-6-0-2:11.61
	ansi-branch:11.63.0.2
	rel-6-0-1-branch:11.61.0.2
	hartley-6-0-post:11.62
	hartley-6-0-pre:11.61
	rel-6-0-1:11.61
	rel-6-0:11.61
	rel-5-4:11.55.2.1
	offsite-5-3-pre:11.59
	rel-5-3:11.55.2.1
	rel-5-2:11.55
	rel-5-1-branch:11.55.0.2
	rel-5-1:11.55
	rel-5-0:11.55
	rel-5-0-beta:11.55
	rel-4-5:11.49
	ctj-4-5-post:11.41
	ctj-4-5-pre:11.41
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.68
date	2004.05.21.17.47.49;	author morrison;	state dead;
branches;
next	11.67;

11.67
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.66;

11.66
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	11.65;

11.65
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.64;

11.64
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	11.63;

11.63
date	2002.08.20.17.08.25;	author jra;	state Exp;
branches
	11.63.2.1
	11.63.4.1
	11.63.10.1;
next	11.62;

11.62
date	2002.08.15.20.55.38;	author hartley;	state Exp;
branches;
next	11.61;

11.61
date	2001.06.05.15.51.42;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	2001.02.16.22.43.43;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	2000.10.24.19.47.51;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	2000.10.24.19.05.08;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	2000.08.19.03.10.48;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	99.02.23.22.50.48;	author bparker;	state Exp;
branches
	11.55.2.1;
next	11.54;

11.54
date	99.02.08.21.51.05;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	98.11.06.22.32.43;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	98.10.21.17.00.41;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	98.06.12.19.46.22;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	98.03.19.18.13.40;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	98.02.06.22.13.02;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	98.01.28.16.15.55;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	97.12.23.14.18.12;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	97.11.06.20.01.50;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	97.11.03.15.17.26;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	97.09.08.18.34.33;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	97.07.25.20.47.05;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	97.06.24.21.32.21;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	97.05.29.14.09.12;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	97.04.23.18.30.43;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	97.03.06.14.04.15;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	97.02.06.22.03.11;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	97.01.30.22.35.10;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	97.01.24.21.01.11;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	97.01.10.22.00.22;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	97.01.08.21.52.48;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.12.23.22.39.47;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.12.17.22.41.55;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.12.13.23.10.54;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.12.12.22.10.09;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.12.04.21.17.33;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	96.11.19.21.48.39;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.10.03.20.24.07;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.10.01.17.23.59;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.09.23.18.20.37;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.09.17.21.14.48;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.08.22.20.57.03;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.06.25.20.59.07;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.06.21.16.05.46;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.06.14.20.06.47;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.05.24.18.53.38;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.05.16.20.59.26;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.03.22.18.32.55;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.01.26.15.47.19;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.01.22.22.50.28;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	95.12.11.22.50.27;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.08.09.13.01.51;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.08.03.21.48.11;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.33;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.24.00.38.34;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.12.05.15.31.02;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.12.05.14.55.50;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.11.01.29.51;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.08.09.18.28.36;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	91.11.05.00.03.00;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.16;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.03.46;	author mike;	state Rel3_5;
branches;
next	1.2;

1.2
date	89.04.22.05.45.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.04.21.04.45.48;	author mike;	state Exp;
branches;
next	;

11.55.2.1
date	2001.02.09.15.26.31;	author bparker;	state Exp;
branches;
next	;

11.63.2.1
date	2002.09.19.18.02.04;	author morrison;	state Exp;
branches;
next	11.63.2.2;

11.63.2.2
date	2004.03.17.21.22.04;	author morrison;	state Exp;
branches;
next	;

11.63.4.1
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

11.63.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.63.10.2;

11.63.10.2
date	2004.03.15.14.07.39;	author erikg;	state Exp;
branches;
next	;


desc
@Subroutines for "scroll-bar" support
@


11.68
log
@moved to src/mged/
@
text
@/*
 *			S C R O L L . C
 *
 * Functions -
 *	scroll_display		Add a list of items to the display list
 *	scroll_select		Called by usepen() for pointing
 *
 * Authors -
 *	Bill Mermagen Jr.
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/scroll.c,v 11.67 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <stdlib.h>

#include "tcl.h"

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./titles.h"
#include "./mged_dm.h"

#include "./mgedtcl.h"
#include "./sedit.h"

extern int mged_svbase(void);   /* defined in chgview.c */
extern void set_scroll(void);   /* defined in set.c */

/************************************************************************
 *									*
 *	First part:  scroll bar definitions				*
 *									*
 ************************************************************************/

static void sl_tol(register struct scroll_item *mptr, double val);
static void sl_atol(register struct scroll_item *mptr, double val);
static void sl_rrtol(register struct scroll_item *mptr, double val);
static void sl_artol(register struct scroll_item *mptr, double val);
static void sl_itol(register struct scroll_item *mptr, double val);
static void sl_adctol(register struct scroll_item *mptr, double val);

struct scroll_item sl_menu[] = {
	{ "xslew",	sl_tol,		0,	"X" },
	{ "yslew",	sl_tol,		1,	"Y" },
	{ "zslew",	sl_tol,		2,	"Z" },
	{ "scale",	sl_tol,		3,	"S" },
	{ "xrot",	sl_rrtol,	4,	"x" },
	{ "yrot",	sl_rrtol,	5,	"y" },
	{ "zrot",	sl_rrtol,	6,	"z" },
	{ "",		(void (*)())NULL, 0,	"" }
};

struct scroll_item sl_abs_menu[] = {
	{ "Xslew",	sl_atol,	0,	"aX" },
	{ "Yslew",	sl_atol,	1,	"aY" },
	{ "Zslew",	sl_atol,	2,	"aZ" },
	{ "Scale",	sl_tol,		3,	"aS" },
	{ "Xrot",	sl_artol,	4,	"ax" },
	{ "Yrot",	sl_artol,	5,	"ay" },
	{ "Zrot",	sl_artol,	6,	"az" },
	{ "",		(void (*)())NULL, 0,	"" }
};

struct scroll_item sl_adc_menu[] = {
	{ "xadc",	sl_itol,	0,	"xadc" },
	{ "yadc",	sl_itol,	1,	"yadc" },
	{ "ang 1",	sl_adctol,	2,	"ang1" },
	{ "ang 2",	sl_adctol,	3,	"ang2" },
	{ "tick",	sl_itol,	4,	"distadc" },
	{ "",		(void (*)())NULL, 0, "" }
};

/************************************************************************
 *									*
 *	Second part: Event Handlers called from menu items by buttons.c *
 *									*
 ************************************************************************/


/*
 *			S E T _ S C R O L L
 *
 * Set scroll_array.
 */
void
set_scroll(void)
{
  if (mged_variables->mv_sliders) {
    if(mged_variables->mv_rateknobs)
      scroll_array[0] = sl_menu;
    else
      scroll_array[0] = sl_abs_menu;

    if(adc_state->adc_draw)
      scroll_array[1] = sl_adc_menu;
    else
      scroll_array[1] = SCROLL_NULL;

  }else{
    scroll_array[0] = SCROLL_NULL;	
    scroll_array[1] = SCROLL_NULL;	
  }
}

/*
 *			S L _ H A L T _ S C R O L L
 *
 *  Reset all scroll bars to the zero position.
 */
void
sl_halt_scroll(void)
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob zero");
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}

/*
 *			S L _ T O G G L E _ S C R O L L
 */
void
sl_toggle_scroll(void)
{
  mged_variables->mv_sliders = mged_variables->mv_sliders ? 0 : 1;

  set_scroll_private();
}

/************************************************************************
 *									*
 *	Third part:  event handlers called from tables, above		*
 *									*
 *  Where the floating point value pointed to by scroll_val		*
 *  in the range -1.0 to +1.0 is the only desired result,		*
 *  everything can be handled by sl_tol().				*
 *									*
 ************************************************************************/

static void
sl_tol(register struct scroll_item *mptr, double val)
{
  struct bu_vls vls;

  if( val < -SL_TOL )   {
    val += SL_TOL;
  } else if( val > SL_TOL )   {
    val -= SL_TOL;
  } else {
    val = 0.0;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}

static void
sl_atol(register struct scroll_item *mptr, double val)
{
  struct bu_vls vls;

  if (dbip == DBI_NULL)
	  return;

  if( val < -SL_TOL )   {
    val += SL_TOL;
  } else if( val > SL_TOL )   {
    val -= SL_TOL;
  } else {
    val = 0.0;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val*view_state->vs_vop->vo_scale*base2local);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}

static void
sl_rrtol(register struct scroll_item *mptr, double val)
{
  struct bu_vls vls;

  if( val < -SL_TOL )   {
    val += SL_TOL;
  } else if( val > SL_TOL )   {
    val -= SL_TOL;
  } else {
    val = 0.0;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val * RATE_ROT_FACTOR);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}


static void
sl_artol(register struct scroll_item *mptr, double val)
{
  struct bu_vls vls;

  if( val < -SL_TOL )   {
    val += SL_TOL;
  } else if( val > SL_TOL )   {
    val -= SL_TOL;
  } else {
    val = 0.0;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val*ABS_ROT_FACTOR);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}


static void
sl_adctol(register struct scroll_item *mptr, double val)
{
  struct bu_vls vls;

  if( val < -SL_TOL )   {
    val += SL_TOL;
  } else if( val > SL_TOL )   {
    val -= SL_TOL;
  } else {
    val = 0.0;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, 45.0 - val*45.0);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}


static void
sl_itol(register struct scroll_item *mptr, double val)
{
  struct bu_vls vls;

  if( val < -SL_TOL )   {
    val += SL_TOL;
  } else if( val > SL_TOL )   {
    val -= SL_TOL;
  } else {
    val = 0.0;
  }

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val*GED_MAX);
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
}


/************************************************************************
 *									*
 *	Fourth part:  general-purpose interface mechanism		*
 *									*
 ************************************************************************/

/*
 *			S C R O L L _ D I S P L A Y
 *
 *  The parameter is the Y pixel address of the starting
 *  screen Y to be used, and the return value is the last screen Y
 *  position used.
 */
int
scroll_display( int y_top )
{ 
  register int		y;
  struct scroll_item	*mptr;
  struct scroll_item	**m;
  int		xpos;
  int second_menu = -1;
  fastf_t f = 0;

  scroll_top = y_top;
  y = y_top;

#if 1
  DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 0);
#else
  DM_SET_LINE_ATTR(dmp, 1, 0);  /* linewidth - 1, not dashed */
#endif

  for( m = &scroll_array[0]; *m != SCROLL_NULL; m++ )  {
    ++second_menu;
    for( mptr = *m; mptr->scroll_string[0] != '\0'; mptr++ )  {
      y += SCROLL_DY;		/* y is now bottom line pos */

      switch(mptr->scroll_val){
      case 0:
	if (second_menu) {
	  f = (double)adc_state->adc_dv_x * INV_GED;

	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_slider_text2[0],
			 color_scheme->cs_slider_text2[1],
			 color_scheme->cs_slider_text2[2], 1, 1.0);
	} else {
	  if(EDIT_TRAN && mged_variables->mv_transform == 'e'){
	    switch(mged_variables->mv_coords){
	    case 'm':
	    case 'o':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_model_tran[X];
	      else
		f = edit_absolute_model_tran[X];
	      break;
	    case 'v':
	    default:
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_view_tran[X];
	      else
		f = edit_absolute_view_tran[X];
	      break;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text1[0],
			   color_scheme->cs_slider_text1[1],
			   color_scheme->cs_slider_text1[2], 1, 1.0);
	  }else{
	    if(mged_variables->mv_rateknobs){
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_rate_model_tran[X];
	      else
		f = view_state->vs_rate_tran[X];
	    }else{
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_absolute_model_tran[X];
	      else
		f = view_state->vs_absolute_tran[X];
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text2[0],
			   color_scheme->cs_slider_text2[1],
			   color_scheme->cs_slider_text2[2], 1, 1.0);
	  }
	}
	break;
      case 1:
	if (second_menu) {
	  f = (double)adc_state->adc_dv_y * INV_GED;

	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_slider_text2[0],
			 color_scheme->cs_slider_text2[1],
			 color_scheme->cs_slider_text2[2], 1, 1.0);
	} else {
	  if(EDIT_TRAN && mged_variables->mv_transform == 'e'){
	    switch(mged_variables->mv_coords){
	    case 'm':
	    case 'o':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_model_tran[Y];
	      else
		f = edit_absolute_model_tran[Y];
	      break;
	    case 'v':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_view_tran[Y];
	      else
		f = edit_absolute_view_tran[Y];
	      break;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text1[0],
			   color_scheme->cs_slider_text1[1],
			   color_scheme->cs_slider_text1[2], 1, 1.0);
	  }else{
	    if(mged_variables->mv_rateknobs){
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_rate_model_tran[Y];
	      else
		f = view_state->vs_rate_tran[Y];
	    }else{
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_absolute_model_tran[Y];
	      else
		f = view_state->vs_absolute_tran[Y];
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text2[0],
			   color_scheme->cs_slider_text2[1],
			   color_scheme->cs_slider_text2[2], 1, 1.0);
	  }
	}
	break;
      case 2:
	if (second_menu) {
	  f = (double)adc_state->adc_dv_a1 * INV_GED;

	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_slider_text2[0],
			 color_scheme->cs_slider_text2[1],
			 color_scheme->cs_slider_text2[2], 1, 1.0);
	} else {
	  if(EDIT_TRAN && mged_variables->mv_transform == 'e'){
	    switch(mged_variables->mv_coords){
	    case 'm':
	    case 'o':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_model_tran[Z];
	      else
		f = edit_absolute_model_tran[Z];
	      break;
	    case 'v':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_view_tran[Z];
	      else
		f = edit_absolute_view_tran[Z];
	      break;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text1[0],
			   color_scheme->cs_slider_text1[1],
			   color_scheme->cs_slider_text1[2], 1, 1.0);
	  }else{
	    if(mged_variables->mv_rateknobs){
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_rate_model_tran[Z];
	      else
		f = view_state->vs_rate_tran[Z];
	    }else{
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_absolute_model_tran[Z];
	      else
		f = view_state->vs_absolute_tran[Z];
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text2[0],
			   color_scheme->cs_slider_text2[1],
			   color_scheme->cs_slider_text2[2], 1, 1.0);
	  }
	}
	break;
      case 3:
	if (second_menu) {
	  f = (double)adc_state->adc_dv_a2 * INV_GED;

	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_slider_text2[0],
			 color_scheme->cs_slider_text2[1],
			 color_scheme->cs_slider_text2[2], 1, 1.0);
	} else {
	  if(EDIT_SCALE && mged_variables->mv_transform == 'e'){
	    if(mged_variables->mv_rateknobs)
	      f = edit_rate_scale;
	    else
	      f = edit_absolute_scale;

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text1[0],
			   color_scheme->cs_slider_text1[1],
			   color_scheme->cs_slider_text1[2], 1, 1.0);
	  }else{
	    if(mged_variables->mv_rateknobs)
	      f = view_state->vs_rate_scale;
	    else
	      f = view_state->vs_absolute_scale;

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text2[0],
			   color_scheme->cs_slider_text2[1],
			   color_scheme->cs_slider_text2[2], 1, 1.0);
	  }
	}
	break;
      case 4:
	if (second_menu) {
	  f = (double)adc_state->adc_dv_dist * INV_GED;

	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_slider_text2[0],
			 color_scheme->cs_slider_text2[1],
			 color_scheme->cs_slider_text2[2], 1, 1.0);
	} else {
	  if(EDIT_ROTATE && mged_variables->mv_transform == 'e'){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_model_rotate[X] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_model_rotate[X] / ABS_ROT_FACTOR;
	      break;
	    case 'o':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_object_rotate[X] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_object_rotate[X] / ABS_ROT_FACTOR;
	      break;
	    case 'v':
	    default:
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_view_rotate[X] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_view_rotate[X] / ABS_ROT_FACTOR;
	      break;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text1[0],
			   color_scheme->cs_slider_text1[1],
			   color_scheme->cs_slider_text1[2], 1, 1.0);
	  }else{
	    if(mged_variables->mv_rateknobs){
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_rate_model_rotate[X] / RATE_ROT_FACTOR;
	      else
		f = view_state->vs_rate_rotate[X] / RATE_ROT_FACTOR;
	    }else{
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_absolute_model_rotate[X] / ABS_ROT_FACTOR;
	      else
		f = view_state->vs_absolute_rotate[X] / ABS_ROT_FACTOR;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text2[0],
			   color_scheme->cs_slider_text2[1],
			   color_scheme->cs_slider_text2[2], 1, 1.0);
	  }
	}
	break;
      case 5:
	if(second_menu)
	  Tcl_AppendResult(interp, "scroll_display: 2nd scroll menu is hosed\n",
			   (char *)NULL);
	else {
	  if(EDIT_ROTATE && mged_variables->mv_transform == 'e'){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_model_rotate[Y] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_model_rotate[Y] / ABS_ROT_FACTOR;
	      break;
	    case 'o':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_object_rotate[Y] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_object_rotate[Y] / ABS_ROT_FACTOR;
	      break;
	    case 'v':
	    default:
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_view_rotate[Y] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_view_rotate[Y] / ABS_ROT_FACTOR;
	      break;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text1[0],
			   color_scheme->cs_slider_text1[1],
			   color_scheme->cs_slider_text1[2], 1, 1.0);
	  }else{
	    if(mged_variables->mv_rateknobs){
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_rate_model_rotate[Y] / RATE_ROT_FACTOR;
	      else
		f = view_state->vs_rate_rotate[Y] / RATE_ROT_FACTOR;
	    }else{
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_absolute_model_rotate[Y] / ABS_ROT_FACTOR;
	      else
		f = view_state->vs_absolute_rotate[Y] / ABS_ROT_FACTOR;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text2[0],
			   color_scheme->cs_slider_text2[1],
			   color_scheme->cs_slider_text2[2], 1, 1.0);
	  }
	}
	break;
      case 6:
	if(second_menu)
	  Tcl_AppendResult(interp, "scroll_display: 2nd scroll menu is hosed\n",
			   (char *)NULL);
	else {
	  if(EDIT_ROTATE && mged_variables->mv_transform == 'e'){
	    switch(mged_variables->mv_coords){
	    case 'm':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_model_rotate[Z] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_model_rotate[Z] / ABS_ROT_FACTOR;
	      break;
	    case 'o':
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_object_rotate[Z] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_object_rotate[Z] / ABS_ROT_FACTOR;
	      break;
	    case 'v':
	    default:
	      if(mged_variables->mv_rateknobs)
		f = edit_rate_view_rotate[Z] / RATE_ROT_FACTOR;
	      else
		f = edit_absolute_view_rotate[Z] / ABS_ROT_FACTOR;
	      break;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text1[0],
			   color_scheme->cs_slider_text1[1],
			   color_scheme->cs_slider_text1[2], 1, 1.0);
	  }else{
	    if(mged_variables->mv_rateknobs){
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_rate_model_rotate[Z] / RATE_ROT_FACTOR;
	      else
		f = view_state->vs_rate_rotate[Z] / RATE_ROT_FACTOR;
	    }else{
	      if(mged_variables->mv_coords == 'm')
		f = view_state->vs_absolute_model_rotate[Z] / ABS_ROT_FACTOR;
	      else
		f = view_state->vs_absolute_rotate[Z] / ABS_ROT_FACTOR;
	    }

	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_slider_text2[0],
			   color_scheme->cs_slider_text2[1],
			   color_scheme->cs_slider_text2[2], 1, 1.0);
	  }
	}
	break;
      default:
	if(second_menu)
	  Tcl_AppendResult(interp, "scroll_display: 2nd scroll menu is hosed\n",
			   (char *)NULL);
	else
	  Tcl_AppendResult(interp, "scroll_display: first scroll menu is hosed\n",
			   (char *)NULL);
      }

      if(f > 0)
	xpos = (f + SL_TOL) * GED_MAX;
      else if(f < 0)
	xpos = (f - SL_TOL) * -MENUXLIM;
      else
	xpos = 0;

      DM_DRAW_STRING_2D( dmp, mptr->scroll_string,
			 GED2PM1(xpos), GED2PM1(y-SCROLL_DY/2), 0, 0 );
      DM_SET_FGCOLOR(dmp,
		     color_scheme->cs_slider_line[0],
		     color_scheme->cs_slider_line[1],
		     color_scheme->cs_slider_line[2], 1, 1.0);
      DM_DRAW_LINE_2D(dmp,
		      GED2PM1(XMAX), GED2PM1(y),
		      GED2PM1(MENUXLIM), GED2PM1(y));
    }
  }

  if( y != y_top )  {
    /* Sliders were drawn, so make left vert edge */
    DM_SET_FGCOLOR(dmp,
		   color_scheme->cs_slider_line[0],
		   color_scheme->cs_slider_line[1],
		   color_scheme->cs_slider_line[2], 1, 1.0);
    DM_DRAW_LINE_2D(dmp,
		    GED2PM1(MENUXLIM), GED2PM1(scroll_top-1),
		    GED2PM1(MENUXLIM), GED2PM1(y));
  }
  return( y );
}

/*
 *			S C R O L L _ S E L E C T
 *
 *  Called with Y coordinate of pen in menu area.
 *
 * Returns:	1 if menu claims these pen co-ordinates,
 *		0 if pen is BELOW scroll
 *		-1 if pen is ABOVE scroll	(error)
 */
int
scroll_select( int pen_x, int pen_y, int do_func )
{ 
	register int		yy;
	struct scroll_item	**m;
	register struct scroll_item     *mptr;

	if( !mged_variables->mv_sliders )  return(0);	/* not enabled */

	if( pen_y > scroll_top )
		return(-1);	/* pen above menu area */

	/*
	 * Start at the top of the list and see if the pen is
	 * above here.
	 */
	yy = scroll_top;
	for( m = &scroll_array[0]; *m != SCROLL_NULL; m++ )  {
		for( mptr = *m; mptr->scroll_string[0] != '\0'; mptr++ )  {
			fastf_t	val;
			yy += SCROLL_DY;	/* bottom line pos */
			if( pen_y < yy )
				continue;	/* pen below this item */

			/*
			 *  Record the location of scroll marker.
			 *  Note that the left side has less width than
			 *  the right side, due to the presence of the
			 *  menu text area on the left.
			 */
			if( pen_x >= 0 )  {
				val = pen_x * INV_GED;
			} else {
				val = pen_x/(double)(-MENUXLIM);
			}

			/* See if hooked function has been specified */
			if( mptr->scroll_func == ((void (*)())0) )  continue;

			if(do_func)
			  (*(mptr->scroll_func))(mptr, val);

			return( 1 );		/* scroll claims pen value */
		}
	}
	return( 0 );		/* pen below scroll area */
}
@


11.67
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/scroll.c,v 11.66 2004/05/10 15:25:28 morrison Exp $ (BRL)";
@


11.66
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.65 2004/04/05 09:09:12 morrison Exp $ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.65
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d326 1
a326 1
			 color_scheme->cs_slider_text2[2], 1);
d349 1
a349 1
			   color_scheme->cs_slider_text1[2], 1);
d366 1
a366 1
			   color_scheme->cs_slider_text2[2], 1);
d377 1
a377 1
			 color_scheme->cs_slider_text2[2], 1);
d399 1
a399 1
			   color_scheme->cs_slider_text1[2], 1);
d416 1
a416 1
			   color_scheme->cs_slider_text2[2], 1);
d427 1
a427 1
			 color_scheme->cs_slider_text2[2], 1);
d449 1
a449 1
			   color_scheme->cs_slider_text1[2], 1);
d466 1
a466 1
			   color_scheme->cs_slider_text2[2], 1);
d477 1
a477 1
			 color_scheme->cs_slider_text2[2], 1);
d488 1
a488 1
			   color_scheme->cs_slider_text1[2], 1);
d498 1
a498 1
			   color_scheme->cs_slider_text2[2], 1);
d509 1
a509 1
			 color_scheme->cs_slider_text2[2], 1);
d537 1
a537 1
			   color_scheme->cs_slider_text1[2], 1);
d554 1
a554 1
			   color_scheme->cs_slider_text2[2], 1);
d589 1
a589 1
			   color_scheme->cs_slider_text1[2], 1);
d606 1
a606 1
			   color_scheme->cs_slider_text2[2], 1);
d641 1
a641 1
			   color_scheme->cs_slider_text1[2], 1);
d658 1
a658 1
			   color_scheme->cs_slider_text2[2], 1);
d683 1
a683 1
		     color_scheme->cs_slider_line[2], 1);
d695 1
a695 1
		   color_scheme->cs_slider_line[2], 1);
@


11.64
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.63 2002/08/20 17:08:25 jra Exp $ (BRL)";
d44 2
a45 2
extern int mged_svbase();   /* defined in chgview.c */
extern void set_scroll();   /* defined in set.c */
d53 6
a58 6
static void sl_tol();
static void sl_atol();
static void sl_rrtol();
static void sl_artol();
static void sl_itol();
static void sl_adctol();
d129 1
a129 1
sl_halt_scroll()
d143 1
a143 1
sl_toggle_scroll()
d161 1
a161 3
sl_tol( mptr, val )
register struct scroll_item     *mptr;
double				val;
d180 1
a180 3
sl_atol( mptr, val )
register struct scroll_item     *mptr;
double				val;
d202 1
a202 3
sl_rrtol( mptr, val )
register struct scroll_item *mptr;
double val;
d222 1
a222 3
sl_artol( mptr, val )
register struct scroll_item *mptr;
double val;
d242 1
a242 3
sl_adctol( mptr, val )
register struct scroll_item     *mptr;
double				val;
d262 1
a262 3
sl_itol( mptr, val )
register struct scroll_item     *mptr;
double				val;
@


11.63
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.61 2001/06/05 15:51:42 bparker Exp $ (BRL)";
@


11.63.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/scroll.c,v 11.64 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.63.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.64 2004/02/02 17:39:35 morrison Exp $ (BRL)";
@


11.63.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.63.10.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.63.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.63 2002/08/20 17:08:25 jra Exp $ (BRL)";
d44 2
a45 2
extern int mged_svbase(void);   /* defined in chgview.c */
extern void set_scroll(void);   /* defined in set.c */
d53 6
a58 6
static void sl_tol(register struct scroll_item *mptr, double val);
static void sl_atol(register struct scroll_item *mptr, double val);
static void sl_rrtol(register struct scroll_item *mptr, double val);
static void sl_artol(register struct scroll_item *mptr, double val);
static void sl_itol(register struct scroll_item *mptr, double val);
static void sl_adctol(register struct scroll_item *mptr, double val);
d129 1
a129 1
sl_halt_scroll(void)
d143 1
a143 1
sl_toggle_scroll(void)
d161 3
a163 1
sl_tol(register struct scroll_item *mptr, double val)
d182 3
a184 1
sl_atol(register struct scroll_item *mptr, double val)
d206 3
a208 1
sl_rrtol(register struct scroll_item *mptr, double val)
d228 3
a230 1
sl_artol(register struct scroll_item *mptr, double val)
d250 3
a252 1
sl_adctol(register struct scroll_item *mptr, double val)
d272 3
a274 1
sl_itol(register struct scroll_item *mptr, double val)
@


11.63.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.62
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 2
a45 2
extern int mged_svbase(void);   /* defined in chgview.c */
extern void set_scroll(void);   /* defined in set.c */
d53 6
a58 6
static void sl_tol(register struct scroll_item *mptr, double val);
static void sl_atol(register struct scroll_item *mptr, double val);
static void sl_rrtol(register struct scroll_item *mptr, double val);
static void sl_artol(register struct scroll_item *mptr, double val);
static void sl_itol(register struct scroll_item *mptr, double val);
static void sl_adctol(register struct scroll_item *mptr, double val);
d129 1
a129 1
sl_halt_scroll(void)
d143 1
a143 1
sl_toggle_scroll(void)
d161 3
a163 1
sl_tol(register struct scroll_item *mptr, double val)
d182 3
a184 1
sl_atol(register struct scroll_item *mptr, double val)
d206 3
a208 1
sl_rrtol(register struct scroll_item *mptr, double val)
d228 3
a230 1
sl_artol(register struct scroll_item *mptr, double val)
d250 3
a252 1
sl_adctol(register struct scroll_item *mptr, double val)
d272 3
a274 1
sl_itol(register struct scroll_item *mptr, double val)
@


11.61
log
@*- got rid of "#ifdef MGED_USE_VIEW_OBJ"
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.60 2001/06/01 19:23:25 bparker Exp $ (BRL)";
d44 2
a45 2
extern int mged_svbase();   /* defined in chgview.c */
extern void set_scroll();   /* defined in set.c */
d53 6
a58 6
static void sl_tol();
static void sl_atol();
static void sl_rrtol();
static void sl_artol();
static void sl_itol();
static void sl_adctol();
d129 1
a129 1
sl_halt_scroll()
d143 1
a143 1
sl_toggle_scroll()
d161 1
a161 3
sl_tol( mptr, val )
register struct scroll_item     *mptr;
double				val;
d180 1
a180 3
sl_atol( mptr, val )
register struct scroll_item     *mptr;
double				val;
d202 1
a202 3
sl_rrtol( mptr, val )
register struct scroll_item *mptr;
double val;
d222 1
a222 3
sl_artol( mptr, val )
register struct scroll_item *mptr;
double val;
d242 1
a242 3
sl_adctol( mptr, val )
register struct scroll_item     *mptr;
double				val;
d262 1
a262 3
sl_itol( mptr, val )
register struct scroll_item     *mptr;
double				val;
@


11.60
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.59 2001/02/16 22:43:43 bparker Exp $ (BRL)";
a199 1
#ifdef MGED_USE_VIEW_OBJ
a200 3
#else
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val*view_state->vs_Viewscale*base2local);
#endif
@


11.59
log
@*- check if (dbip == DBI_NULL) before doing anything
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.58 2000/10/24 19:47:51 mike Exp $ (BRL)";
d200 3
d204 1
@


11.58
log
@
possible uninit
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.57 2000/10/24 19:05:08 mike Exp $ (BRL)";
d187 3
@


11.57
log
@
Fixed compiler lint, function declarations.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.56 2000/08/19 03:10:48 mike Exp $ (BRL)";
d311 1
a311 1
  fastf_t f;
@


11.56
log
@
const RCSid
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.55 1999/02/23 22:50:48 bparker Exp $ (BRL)";
d104 1
a104 1
set_scroll()
d304 1
a304 2
scroll_display( y_top )
int y_top;
d722 1
a722 4
scroll_select( pen_x, pen_y, do_func )
int		pen_x;
register int	pen_y;
int do_func;
@


11.55
log
@*- change slidersflag back to sliders
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.54 1999/02/08 21:51:05 bparker Exp $ (BRL)";
@


11.55.2.1
log
@Mods that check if dbip==DBI_NULL
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.55 1999/02/23 22:50:48 bparker Exp $ (BRL)";
a186 3

  if (dbip == DBI_NULL)
	  return;
@


11.54
log
@*- fixed typos --> missing break statements
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.53 1998/11/06 22:32:43 bparker Exp $ (BRL)";
d106 1
a106 1
  if (mged_variables->mv_slidersflag) {
d145 1
a145 1
  mged_variables->mv_slidersflag = mged_variables->mv_slidersflag ? 0 : 1;
d732 1
a732 1
	if( !mged_variables->mv_slidersflag )  return(0);	/* not enabled */
@


11.53
log
@*- use new structures
*- cleanup
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.52 1998/10/21 17:00:41 bparker Exp $ (BRL)";
d528 1
d534 1
@


11.52
log
@*- use new color scheme variables
*- use macros instead of literals
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/scroll.c,v 11.51 1998/06/12 19:46:22 bparker Exp $ (BRL)";
d99 25
d145 1
a145 26
  mged_variables->slidersflag = mged_variables->slidersflag ? 0 : 1;

  set_scroll();
}

/*
 *                      C M D _ S L I D E R S
 *
 * If no arguments are given, returns 1 if the sliders are displayed, and 0
 * if not.  If one argument is given, parses it as a boolean value and
 * turns on the sliders if it is 1, and turns them off it is 0.
 * Otherwise, returns an error;
 */

int
cmd_sliders(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct dm_list *dmlp;
  struct dm_list *save_cdmlp;

  if(argc < 1 || 2 < argc){
    struct bu_vls vls;
d147 1
a147 52
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help sliders");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (argc == 1) {
    Tcl_AppendResult(interp, mged_variables->slidersflag ? "1" : "0", (char *)NULL);
    return TCL_OK;
  }

  if (Tcl_GetBoolean(interp, argv[1], &mged_variables->slidersflag) == TCL_ERROR)
    return TCL_ERROR;

  save_cdmlp = curr_dm_list;
  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
    /* if sharing mged_variables or view */
    if(dmlp->_mged_variables == save_cdmlp->_mged_variables ||
       dmlp->s_info == save_cdmlp->s_info){
      curr_dm_list = dmlp;

      if (mged_variables->slidersflag) {
	if(mged_variables->rateknobs)
	  scroll_array[0] = sl_menu;
	else
	  scroll_array[0] = sl_abs_menu;

	if(adc_draw)
	  scroll_array[1] = sl_adc_menu;
	else
	  scroll_array[1] = SCROLL_NULL;

	if(mged_variables->faceplate && mged_variables->orig_gui){
	  /* zero slider variables */
	  if(mged_variables == save_cdmlp->_mged_variables)
	    mged_svbase();

	  dirty = 1;
	}
      }else{
	scroll_array[0] = SCROLL_NULL;	
	scroll_array[1] = SCROLL_NULL;	

	if(mged_variables->faceplate && mged_variables->orig_gui)
	  dirty = 1;
      }
    }
  }
  curr_dm_list = save_cdmlp;

  return TCL_OK;
a149 1

d197 1
a197 1
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val*Viewscale*base2local);
d318 1
a318 1
  DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
d331 1
a331 1
	  f = (double)dv_xadc * INV_GED;
d334 3
a336 3
			 color_scheme->fp_slider_text2[0],
			 color_scheme->fp_slider_text2[1],
			 color_scheme->fp_slider_text2[2], 1);
d338 2
a339 2
	  if(EDIT_TRAN && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
d342 1
a342 1
	      if(mged_variables->rateknobs)
d349 1
a349 1
	      if(mged_variables->rateknobs)
d357 3
a359 3
			   color_scheme->fp_slider_text1[0],
			   color_scheme->fp_slider_text1[1],
			   color_scheme->fp_slider_text1[2], 1);
d361 3
a363 3
	    if(mged_variables->rateknobs){
	      if(mged_variables->coords == 'm')
		f = rate_model_tran[X];
d365 1
a365 1
		f = rate_tran[X];
d367 2
a368 2
	      if(mged_variables->coords == 'm')
		f = absolute_model_tran[X];
d370 1
a370 1
		f = absolute_tran[X];
d374 3
a376 3
			   color_scheme->fp_slider_text2[0],
			   color_scheme->fp_slider_text2[1],
			   color_scheme->fp_slider_text2[2], 1);
d382 1
a382 1
	  f = (double)dv_yadc * INV_GED;
d385 3
a387 3
			 color_scheme->fp_slider_text2[0],
			 color_scheme->fp_slider_text2[1],
			 color_scheme->fp_slider_text2[2], 1);
d389 2
a390 2
	  if(EDIT_TRAN && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
d393 1
a393 1
	      if(mged_variables->rateknobs)
d399 1
a399 1
	      if(mged_variables->rateknobs)
d407 3
a409 3
			   color_scheme->fp_slider_text1[0],
			   color_scheme->fp_slider_text1[1],
			   color_scheme->fp_slider_text1[2], 1);
d411 3
a413 3
	    if(mged_variables->rateknobs){
	      if(mged_variables->coords == 'm')
		f = rate_model_tran[Y];
d415 1
a415 1
		f = rate_tran[Y];
d417 2
a418 2
	      if(mged_variables->coords == 'm')
		f = absolute_model_tran[Y];
d420 1
a420 1
		f = absolute_tran[Y];
d424 3
a426 3
			   color_scheme->fp_slider_text2[0],
			   color_scheme->fp_slider_text2[1],
			   color_scheme->fp_slider_text2[2], 1);
d432 1
a432 1
	  f = (double)dv_1adc * INV_GED;
d435 3
a437 3
			 color_scheme->fp_slider_text2[0],
			 color_scheme->fp_slider_text2[1],
			 color_scheme->fp_slider_text2[2], 1);
d439 2
a440 2
	  if(EDIT_TRAN && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
d443 1
a443 1
	      if(mged_variables->rateknobs)
d449 1
a449 1
	      if(mged_variables->rateknobs)
d457 3
a459 3
			   color_scheme->fp_slider_text1[0],
			   color_scheme->fp_slider_text1[1],
			   color_scheme->fp_slider_text1[2], 1);
d461 3
a463 3
	    if(mged_variables->rateknobs){
	      if(mged_variables->coords == 'm')
		f = rate_model_tran[Z];
d465 1
a465 1
		f = rate_tran[Z];
d467 2
a468 2
	      if(mged_variables->coords == 'm')
		f = absolute_model_tran[Z];
d470 1
a470 1
		f = absolute_tran[Z];
d474 3
a476 3
			   color_scheme->fp_slider_text2[0],
			   color_scheme->fp_slider_text2[1],
			   color_scheme->fp_slider_text2[2], 1);
d482 1
a482 1
	  f = (double)dv_2adc * INV_GED;
d485 3
a487 3
			 color_scheme->fp_slider_text2[0],
			 color_scheme->fp_slider_text2[1],
			 color_scheme->fp_slider_text2[2], 1);
d489 2
a490 2
	  if(EDIT_SCALE && mged_variables->transform == 'e'){
	    if(mged_variables->rateknobs)
d496 3
a498 3
			   color_scheme->fp_slider_text1[0],
			   color_scheme->fp_slider_text1[1],
			   color_scheme->fp_slider_text1[2], 1);
d500 2
a501 2
	    if(mged_variables->rateknobs)
	      f = rate_scale;
d503 1
a503 1
	      f = absolute_scale;
d506 3
a508 3
			   color_scheme->fp_slider_text2[0],
			   color_scheme->fp_slider_text2[1],
			   color_scheme->fp_slider_text2[2], 1);
d514 1
a514 1
	  f = (double)dv_distadc * INV_GED;
d517 3
a519 3
			 color_scheme->fp_slider_text2[0],
			 color_scheme->fp_slider_text2[1],
			 color_scheme->fp_slider_text2[2], 1);
d521 2
a522 2
	  if(EDIT_ROTATE && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
d524 1
a524 1
	      if(mged_variables->rateknobs)
d529 1
a529 1
	      if(mged_variables->rateknobs)
d535 1
a535 1
	      if(mged_variables->rateknobs)
d543 3
a545 3
			   color_scheme->fp_slider_text1[0],
			   color_scheme->fp_slider_text1[1],
			   color_scheme->fp_slider_text1[2], 1);
d547 3
a549 3
	    if(mged_variables->rateknobs){
	      if(mged_variables->coords == 'm')
		f = rate_model_rotate[X] / RATE_ROT_FACTOR;
d551 1
a551 1
		f = rate_rotate[X] / RATE_ROT_FACTOR;
d553 2
a554 2
	      if(mged_variables->coords == 'm')
		f = absolute_model_rotate[X] / ABS_ROT_FACTOR;
d556 1
a556 1
		f = absolute_rotate[X] / ABS_ROT_FACTOR;
d560 3
a562 3
			   color_scheme->fp_slider_text2[0],
			   color_scheme->fp_slider_text2[1],
			   color_scheme->fp_slider_text2[2], 1);
d571 2
a572 2
	  if(EDIT_ROTATE && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
d574 1
a574 1
	      if(mged_variables->rateknobs)
d580 1
a580 1
	      if(mged_variables->rateknobs)
d587 1
a587 1
	      if(mged_variables->rateknobs)
d595 3
a597 3
			   color_scheme->fp_slider_text1[0],
			   color_scheme->fp_slider_text1[1],
			   color_scheme->fp_slider_text1[2], 1);
d599 3
a601 3
	    if(mged_variables->rateknobs){
	      if(mged_variables->coords == 'm')
		f = rate_model_rotate[Y] / RATE_ROT_FACTOR;
d603 1
a603 1
		f = rate_rotate[Y] / RATE_ROT_FACTOR;
d605 2
a606 2
	      if(mged_variables->coords == 'm')
		f = absolute_model_rotate[Y] / ABS_ROT_FACTOR;
d608 1
a608 1
		f = absolute_rotate[Y] / ABS_ROT_FACTOR;
d612 3
a614 3
			   color_scheme->fp_slider_text2[0],
			   color_scheme->fp_slider_text2[1],
			   color_scheme->fp_slider_text2[2], 1);
d623 2
a624 2
	  if(EDIT_ROTATE && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
d626 1
a626 1
	      if(mged_variables->rateknobs)
d632 1
a632 1
	      if(mged_variables->rateknobs)
d639 1
a639 1
	      if(mged_variables->rateknobs)
d647 3
a649 3
			   color_scheme->fp_slider_text1[0],
			   color_scheme->fp_slider_text1[1],
			   color_scheme->fp_slider_text1[2], 1);
d651 3
a653 3
	    if(mged_variables->rateknobs){
	      if(mged_variables->coords == 'm')
		f = rate_model_rotate[Z] / RATE_ROT_FACTOR;
d655 1
a655 1
		f = rate_rotate[Z] / RATE_ROT_FACTOR;
d657 2
a658 2
	      if(mged_variables->coords == 'm')
		f = absolute_model_rotate[Z] / ABS_ROT_FACTOR;
d660 1
a660 1
		f = absolute_rotate[Z] / ABS_ROT_FACTOR;
d664 3
a666 3
			   color_scheme->fp_slider_text2[0],
			   color_scheme->fp_slider_text2[1],
			   color_scheme->fp_slider_text2[2], 1);
d689 3
a691 3
		     color_scheme->fp_slider_line[0],
		     color_scheme->fp_slider_line[1],
		     color_scheme->fp_slider_line[2], 1);
d701 3
a703 3
		   color_scheme->fp_slider_line[0],
		   color_scheme->fp_slider_line[1],
		   color_scheme->fp_slider_line[2], 1);
d730 1
a730 1
	if( !mged_variables->slidersflag )  return(0);	/* not enabled */
@


11.51
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/scroll.c,v 11.50 1998/03/19 18:13:40 bparker Exp $ (BRL)";
d336 1
a336 1
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val*2047.0);
d382 8
a389 3
	if(second_menu)
	  f = (double)dv_xadc / 2047.0;
	else {
d408 4
a411 1
	    DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d425 4
a428 1
	    DM_SET_FGCOLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d433 8
a440 3
	if(second_menu)
	  f = (double)dv_yadc / 2047.0;
	else {
d458 4
a461 1
	    DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d475 4
a478 1
	    DM_SET_FGCOLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d483 8
a490 3
	if(second_menu)
	  f = (double)dv_1adc / 2047.0;
	else {
d508 4
a511 1
	    DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d525 4
a528 1
	    DM_SET_FGCOLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d533 8
a540 3
	if(second_menu)
	  f = (double)dv_2adc / 2047.0;
	else {
d547 4
a550 1
	    DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d557 4
a560 1
	    DM_SET_FGCOLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d565 8
a572 3
	if(second_menu)
	  f = (double)dv_distadc / 2047.0;
	else {
d594 4
a597 1
	    DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d611 4
a614 1
	    DM_SET_FGCOLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d646 4
a649 1
	    DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d663 4
a666 1
	    DM_SET_FGCOLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d698 4
a701 1
	    DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d715 4
a718 1
	    DM_SET_FGCOLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d732 1
a732 1
	xpos = (f + SL_TOL) * 2047.0;
d740 4
a743 1
      DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d752 4
a755 1
    DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d806 1
a806 1
				val = pen_x/2047.0;
@


11.50
log
@ADC variables are no longer mged_variables
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.49 1998/02/06 22:13:02 bparker Exp bparker $ (BRL)";
d403 1
a403 1
	    DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d417 1
a417 1
	    DM_SET_COLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d442 1
a442 1
	    DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d456 1
a456 1
	    DM_SET_COLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d481 1
a481 1
	    DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d495 1
a495 1
	    DM_SET_COLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d509 1
a509 1
	    DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d516 1
a516 1
	    DM_SET_COLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d545 1
a545 1
	    DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d559 1
a559 1
	    DM_SET_COLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d591 1
a591 1
	    DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d605 1
a605 1
	    DM_SET_COLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d637 1
a637 1
	    DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d651 1
a651 1
	    DM_SET_COLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d673 1
a673 1
      DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d682 1
a682 1
    DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
@


11.49
log
@DM_DRAW_STRING_2D and DM_DRAW_STRING_2D now expect x,y values in the range +-1
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.48 1998/01/28 16:15:55 bparker Exp bparker $ (BRL)";
d175 1
a175 1
	if(mged_variables->adcflag)
@


11.48
log
@using coords instead of ecoords
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.47 1997/12/23 14:18:12 bparker Exp bparker $ (BRL)";
d672 1
a672 1
			    xpos, y-SCROLL_DY/2, 0, 0 );
d674 3
a676 1
      DM_DRAW_LINE_2D(dmp, XMAX, y, MENUXLIM, y);
d683 3
a685 1
    DM_DRAW_LINE_2D(dmp, MENUXLIM, scroll_top-1, MENUXLIM, y);
@


11.47
log
@mods to cmd_sliders()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.46 1997/11/06 20:01:50 bparker Exp bparker $ (BRL)";
d386 1
a386 1
	    switch(mged_variables->ecoords){
d426 1
a426 1
	    switch(mged_variables->ecoords){
d465 1
a465 1
	    switch(mged_variables->ecoords){
d525 1
a525 1
	    switch(mged_variables->ecoords){
d569 1
a569 1
	    switch(mged_variables->ecoords){
d615 1
a615 1
	    switch(mged_variables->ecoords){
@


11.46
log
@use new mged variable: ecoords
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.45 1997/11/03 15:17:26 bparker Exp bparker $ (BRL)";
d44 1
a45 1
extern void set_dirty_flag();
d121 1
d141 2
a142 1
  struct dm_list *p;
d162 33
a194 8
  if (mged_variables->slidersflag) {
    if(mged_variables->rateknobs)
      scroll_array[0] = sl_menu;
    else
      scroll_array[0] = sl_abs_menu;
  } else {
    scroll_array[0] = SCROLL_NULL;	
    scroll_array[1] = SCROLL_NULL;	
d196 1
a197 3
  if(mged_variables->faceplate && mged_variables->orig_gui)
    set_dirty_flag();

a364 6

  /* XXX this should be driven by the button event */
  if( mged_variables->adcflag && mged_variables->slidersflag )
    scroll_array[1] = sl_adc_menu;
  else
    scroll_array[1] = SCROLL_NULL;
@


11.45
log
@use LIBDM macros
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.44 1997/09/08 18:34:33 bparker Exp bparker $ (BRL)";
d367 1
a367 1
	    switch(mged_variables->coords){
d407 1
a407 1
	    switch(mged_variables->coords){
d446 1
a446 1
	    switch(mged_variables->coords){
d506 1
a506 1
	    switch(mged_variables->coords){
d550 1
a550 1
	    switch(mged_variables->coords){
d596 1
a596 1
	    switch(mged_variables->coords){
@


11.44
log
@mged_variables is now a pointer
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.43 1997/07/25 20:47:05 bparker Exp bparker $ (BRL)";
d351 1
a351 1
  dmp->dm_setLineAttr(dmp, mged_variables->linewidth, 0);
d353 1
a353 1
  dmp->dm_setLineAttr(dmp, 1, 0);  /* linewidth - 1, not dashed */
d384 1
a384 1
	    dmp->dm_setColor(dmp, DM_WHITE, 1);
d398 1
a398 1
	    dmp->dm_setColor(dmp, DM_RED, 1);
d423 1
a423 1
	    dmp->dm_setColor(dmp, DM_WHITE, 1);
d437 1
a437 1
	    dmp->dm_setColor(dmp, DM_RED, 1);
d462 1
a462 1
	    dmp->dm_setColor(dmp, DM_WHITE, 1);
d476 1
a476 1
	    dmp->dm_setColor(dmp, DM_RED, 1);
d490 1
a490 1
	    dmp->dm_setColor(dmp, DM_WHITE, 1);
d497 1
a497 1
	    dmp->dm_setColor(dmp, DM_RED, 1);
d526 1
a526 1
	    dmp->dm_setColor(dmp, DM_WHITE, 1);
d540 1
a540 1
	    dmp->dm_setColor(dmp, DM_RED, 1);
d572 1
a572 1
	    dmp->dm_setColor(dmp, DM_WHITE, 1);
d586 1
a586 1
	    dmp->dm_setColor(dmp, DM_RED, 1);
d618 1
a618 1
	    dmp->dm_setColor(dmp, DM_WHITE, 1);
d632 1
a632 1
	    dmp->dm_setColor(dmp, DM_RED, 1);
d652 1
a652 1
      dmp->dm_drawString2D( dmp, mptr->scroll_string,
d654 2
a655 2
      dmp->dm_setColor(dmp, DM_YELLOW, 1);
      dmp->dm_drawLine2D(dmp, XMAX, y, MENUXLIM, y);
d661 2
a662 3
    dmp->dm_setColor(dmp, DM_YELLOW, 1);
    dmp->dm_drawLine2D( dmp, MENUXLIM, scroll_top-1,
			MENUXLIM, y, 0, DM_YELLOW );
@


11.43
log
@*- mods to draw scroll bars with user specified linewidth
*- use new variables with scroll bars
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.42 1997/06/24 21:32:21 bparker Exp bparker $ (BRL)";
d45 1
d120 1
a120 1
  mged_variables.slidersflag = mged_variables.slidersflag ? 0 : 1;
d153 1
a153 1
    Tcl_AppendResult(interp, mged_variables.slidersflag ? "1" : "0", (char *)NULL);
d157 1
a157 1
  if (Tcl_GetBoolean(interp, argv[1], &mged_variables.slidersflag) == TCL_ERROR)
d160 2
a161 2
  if (mged_variables.slidersflag) {
    if(mged_variables.rateknobs)
d170 2
a171 2
  if(mged_variables.faceplate && mged_variables.orig_gui)
    dirty = 1;
d342 1
a342 1
  if( mged_variables.adcflag && mged_variables.slidersflag )
d351 1
a351 1
  dmp->dm_setLineAttr(dmp, mged_variables.linewidth, 0);
d366 2
a367 2
	  if(EDIT_TRAN && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d370 1
a370 1
	      if(mged_variables.rateknobs)
d377 1
a377 1
	      if(mged_variables.rateknobs)
d386 2
a387 2
	    if(mged_variables.rateknobs){
	      if(mged_variables.coords == 'm')
d392 1
a392 1
	      if(mged_variables.coords == 'm')
d406 2
a407 2
	  if(EDIT_TRAN && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d410 1
a410 1
	      if(mged_variables.rateknobs)
d416 1
a416 1
	      if(mged_variables.rateknobs)
d425 2
a426 2
	    if(mged_variables.rateknobs){
	      if(mged_variables.coords == 'm')
d431 1
a431 1
	      if(mged_variables.coords == 'm')
d445 2
a446 2
	  if(EDIT_TRAN && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d449 1
a449 1
	      if(mged_variables.rateknobs)
d455 1
a455 1
	      if(mged_variables.rateknobs)
d464 2
a465 2
	    if(mged_variables.rateknobs){
	      if(mged_variables.coords == 'm')
d470 1
a470 1
	      if(mged_variables.coords == 'm')
d484 2
a485 2
	  if(EDIT_SCALE && mged_variables.transform == 'e'){
	    if(mged_variables.rateknobs)
d492 1
a492 1
	    if(mged_variables.rateknobs)
d505 2
a506 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d508 1
a508 1
	      if(mged_variables.rateknobs)
d513 1
a513 1
	      if(mged_variables.rateknobs)
d519 1
a519 1
	      if(mged_variables.rateknobs)
d528 2
a529 2
	    if(mged_variables.rateknobs){
	      if(mged_variables.coords == 'm')
d534 1
a534 1
	      if(mged_variables.coords == 'm')
d549 2
a550 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d552 1
a552 1
	      if(mged_variables.rateknobs)
d558 1
a558 1
	      if(mged_variables.rateknobs)
d565 1
a565 1
	      if(mged_variables.rateknobs)
d574 2
a575 2
	    if(mged_variables.rateknobs){
	      if(mged_variables.coords == 'm')
d580 1
a580 1
	      if(mged_variables.coords == 'm')
d595 2
a596 2
	  if(EDIT_ROTATE && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d598 1
a598 1
	      if(mged_variables.rateknobs)
d604 1
a604 1
	      if(mged_variables.rateknobs)
d611 1
a611 1
	      if(mged_variables.rateknobs)
d620 2
a621 2
	    if(mged_variables.rateknobs){
	      if(mged_variables.coords == 'm')
d626 1
a626 1
	      if(mged_variables.coords == 'm')
d687 1
a687 1
	if( !mged_variables.slidersflag )  return(0);	/* not enabled */
@


11.42
log
@mods to accomodate changes to mged_variables
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.41 1997/05/29 14:09:12 bparker Exp bparker $ (BRL)";
d53 1
d71 3
a73 3
	{ "Xslew",	sl_tol,		0,	"aX" },
	{ "Yslew",	sl_tol,		1,	"aY" },
	{ "Zslew",	sl_tol,		2,	"aZ" },
d208 21
d349 3
d353 1
d366 16
a381 4
	    if(mged_variables.rateknobs)
	      f = edit_rate_tran[X];
	    else
	      f = edit_absolute_tran[X];
d406 15
a420 4
	    if(mged_variables.rateknobs)
	      f = edit_rate_tran[Y];
	    else
	      f = edit_absolute_tran[Y];
d445 15
a459 4
	    if(mged_variables.rateknobs)
	      f = edit_rate_tran[Z];
	    else
	      f = edit_absolute_tran[Z];
d492 1
a492 1
	      f = rate_zoom;
d494 1
a494 1
	      f = absolute_zoom;
d505 19
a523 4
	    if(mged_variables.rateknobs)
	      f = edit_rate_rotate[X] / RATE_ROT_FACTOR;
	    else
	      f = edit_absolute_rotate[X] / ABS_ROT_FACTOR;
d533 4
a536 1
	      f = absolute_rotate[X] / ABS_ROT_FACTOR;
d549 21
a569 4
	    if(mged_variables.rateknobs)
	      f = edit_rate_rotate[Y] / RATE_ROT_FACTOR;
	    else
	      f = edit_absolute_rotate[Y] / ABS_ROT_FACTOR;
d579 4
a582 1
	      f = absolute_rotate[Y] / ABS_ROT_FACTOR;
d595 21
a615 4
	    if(mged_variables.rateknobs)
	      f = edit_rate_rotate[Z] / RATE_ROT_FACTOR;
	    else
	      f = edit_absolute_rotate[Z] / ABS_ROT_FACTOR;
d625 4
a628 1
	      f = absolute_rotate[Z] / ABS_ROT_FACTOR;
@


11.41
log
@mods to handle azimuth slider
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.40 1997/04/24 18:03:58 bparker Exp bparker $ (BRL)";
a65 1
	{ "azim",	sl_rrtol,	7,	"azim" },
a76 1
	{ "Azim",	sl_artol,	7,	"aazim" },
d168 1
a168 1
  if(mged_variables.show_menu)
d339 1
a339 1
	  if(EDIT_TRAN && mged_variables.edit){
d347 11
a357 4
	    if(mged_variables.rateknobs)
	      f = rate_slew[X];
	    else
	      f = absolute_slew[X];
d367 1
a367 1
	  if(EDIT_TRAN && mged_variables.edit){
d375 11
a385 4
	    if(mged_variables.rateknobs)
	      f = rate_slew[Y];
	    else
	      f = absolute_slew[Y];
d395 1
a395 1
	  if(EDIT_TRAN && mged_variables.edit){
d403 11
a413 4
	    if(mged_variables.rateknobs)
	      f = rate_slew[Z];
	    else
	      f = absolute_slew[Z];
d423 1
a423 1
	  if(EDIT_SCALE && mged_variables.edit){
d444 1
a444 1
	  if(EDIT_ROTATE && mged_variables.edit){
d452 6
a457 3
	    if(mged_variables.rateknobs)
	      f = rate_rotate[X] / RATE_ROT_FACTOR;
	    else
d459 1
d470 1
a470 1
	  if(EDIT_ROTATE && mged_variables.edit){
d478 6
a483 3
	    if(mged_variables.rateknobs)
	      f = rate_rotate[Y] / RATE_ROT_FACTOR;
	    else
d485 1
d496 1
a496 1
	  if(EDIT_ROTATE && mged_variables.edit){
d504 6
a509 3
	    if(mged_variables.rateknobs)
	      f = rate_rotate[Z] / RATE_ROT_FACTOR;
	    else
d511 1
a516 32
      case 7:
	if(second_menu)
	  Tcl_AppendResult(interp, "scroll_display: 2nd scroll menu is hosed\n",
			   (char *)NULL);
	else {
	  if(mged_variables.rateknobs)
	    f = rate_azimuth / RATE_ROT_FACTOR;
	  else{
#if 0
	    if(NEAR_ZERO(curr_dm_list->s_info->elevation - 90.0,(fastf_t)0.005) ||
	       NEAR_ZERO(curr_dm_list->s_info->elevation + 90.0,(fastf_t)0.005))
	      f = curr_dm_list->s_info->azimuth / ABS_ROT_FACTOR;
	    else if(0.0 <= curr_dm_list->s_info->azimuth &&
		    curr_dm_list->s_info->azimuth <= 180.0)
	      f = curr_dm_list->s_info->azimuth / ABS_ROT_FACTOR;
	    else
	      f = (curr_dm_list->s_info->azimuth - 360.0) / ABS_ROT_FACTOR;
#else
#if 1
	    if(0.0 <= curr_dm_list->s_info->azimuth &&
	       curr_dm_list->s_info->azimuth <= 180.0)
	      f = curr_dm_list->s_info->azimuth / ABS_ROT_FACTOR;
	    else
	      f = (curr_dm_list->s_info->azimuth - 360.0) / ABS_ROT_FACTOR;
#else
	    f = curr_dm_list->s_info->azimuth / ABS_ROT_FACTOR;
#endif
#endif
	  }

	  dmp->dm_setColor(dmp, DM_RED, 1);
	}
@


11.40
log
@modify calls to Tcl_Eval
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.39 1997/04/23 18:30:43 bparker Exp bparker $ (BRL)";
d66 1
d78 1
d120 1
a120 1
  mged_variables.scroll_enabled = mged_variables.scroll_enabled ? 0 : 1;
d153 1
a153 1
    Tcl_AppendResult(interp, mged_variables.scroll_enabled ? "1" : "0", (char *)NULL);
d157 1
a157 1
  if (Tcl_GetBoolean(interp, argv[1], &mged_variables.scroll_enabled) == TCL_ERROR)
d160 1
a160 1
  if (mged_variables.scroll_enabled) {
d321 1
a321 1
  if( mged_variables.adcflag && mged_variables.scroll_enabled )
d486 32
d569 1
a569 1
	if( !mged_variables.scroll_enabled )  return(0);	/* not enabled */
@


11.39
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.38 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d104 6
a109 1
  Tcl_Eval( interp, "knob zero");
d141 6
a146 1
    Tcl_Eval(interp, "help sliders");
@


11.38
log
@mods so that commands check args internally
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.37 1997/03/06 14:04:15 bparker Exp bparker $ (BRL)";
a38 1
#include "./scroll.h"
@


11.37
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.36 1997/02/06 22:03:11 bparker Exp bparker $ (BRL)";
d136 2
a137 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d139 1
@


11.36
log
@mods to scroll_select to allow only a query
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.35 1997/01/30 22:35:10 bparker Exp bparker $ (BRL)";
d158 1
a158 1
    dmaflag++;
d558 1
a558 3
#if 0
			dmaflag = 1;
#endif
@


11.35
log
@mods due to changes in dm_drawString2D
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.34 1997/01/24 21:01:11 bparker Exp bparker $ (BRL)";
d515 1
a515 1
scroll_select( pen_x, pen_y )
d518 1
d556 2
a557 1
			(*(mptr->scroll_func))(mptr, val);
@


11.34
log
@mods to update Tcl/Tk sliders
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.33 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d490 1
a490 1
			    xpos, y-SCROLL_DY/2, 0 );
@


11.33
log
@checkin for weekend
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.32 1997/01/10 22:00:22 bparker Exp bparker $ (BRL)";
d45 2
d114 2
a115 4
  if( mged_variables.scroll_enabled == 0 )
    Tcl_Eval(interp, "sliders on");
  else
    Tcl_Eval(interp, "sliders off");
d136 10
a145 2
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
      return TCL_ERROR;
d147 9
a155 17
    if (argc == 1) {
	Tcl_AppendResult(interp, mged_variables.scroll_enabled ? "1" : "0", (char *)NULL);
	return TCL_OK;
    }

    if (Tcl_GetBoolean(interp, argv[1], &mged_variables.scroll_enabled) == TCL_ERROR)
	return TCL_ERROR;

    if (mged_variables.scroll_enabled) {
      if(mged_variables.rateknobs)
	scroll_array[0] = sl_menu;
      else
	scroll_array[0] = sl_abs_menu;
    } else {
	scroll_array[0] = SCROLL_NULL;	
	scroll_array[1] = SCROLL_NULL;	
    }
d157 2
a158 2
    if(mged_variables.show_menu)
      dmaflag++;
d160 1
a160 1
    return TCL_OK;
d162 1
@


11.32
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.31 1997/01/08 21:52:48 bparker Exp bparker $ (BRL)";
d113 1
a113 1
    Tcl_Eval( interp, "sliders on");
d115 1
a115 1
    Tcl_Eval( interp, "sliders off");
d134 2
@


11.31
log
@define RATE_ROT_FACTOR and ABS_ROT_FACTOR then put to use
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.30 1996/12/23 22:39:47 bparker Exp bparker $ (BRL)";
a43 3

#define RATE_ROT_FACTOR 6.0
#define ABS_ROT_FACTOR 180.0
@


11.30
log
@mods for handling adc angles
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.29 1996/12/17 22:41:55 bparker Exp bparker $ (BRL)";
d45 2
a46 1
#define RATE_ROT_MULT 6.0
d211 1
a211 1
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val * RATE_ROT_MULT);
d233 1
a233 1
  bu_vls_printf(&vls, "knob %s %f", mptr->scroll_cmd, val*180.0);
d414 1
a414 1
	      f = edit_rate_rotate[X] / RATE_ROT_MULT;
d416 1
a416 1
	      f = edit_absolute_rotate[X] / 180.0;
d421 1
a421 1
	      f = rate_rotate[X] / RATE_ROT_MULT;
d423 1
a423 1
	      f = absolute_rotate[X] / 180.0;
d436 1
a436 1
	      f = edit_rate_rotate[Y] / RATE_ROT_MULT;
d438 1
a438 1
	      f = edit_absolute_rotate[Y] / 180.0;
d443 1
a443 1
	      f = rate_rotate[Y] / RATE_ROT_MULT;
d445 1
a445 1
	      f = absolute_rotate[Y] / 180.0;
d458 1
a458 1
	      f = edit_rate_rotate[Z] / RATE_ROT_MULT;
d460 1
a460 1
	      f = edit_absolute_rotate[Z] / 180.0;
d465 1
a465 1
	      f = rate_rotate[Z] / RATE_ROT_MULT;
d467 1
a467 1
	      f = absolute_rotate[Z] / 180.0;
@


11.29
log
@mod's to rate rotation
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.28 1996/12/13 23:10:54 bparker Exp bparker $ (BRL)";
d57 1
d84 2
a85 2
	{ "ang 1",	sl_itol,	2,	"ang1" },
	{ "ang 2",	sl_itol,	3,	"ang2" },
d239 22
d276 1
a276 1
  bu_vls_printf(&vls, "knob %s %d", mptr->scroll_cmd, val*2047.0);
@


11.28
log
@weekend checkin
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.27 1996/12/12 22:10:09 bparker Exp bparker $ (BRL)";
d45 2
d54 1
d63 3
a65 3
	{ "xrot",	sl_tol,		4,	"x" },
	{ "yrot",	sl_tol,		5,	"y" },
	{ "zrot",	sl_tol,		6,	"z" },
d194 22
d390 1
a390 1
	      f = edit_rate_rotate[X];
d397 1
a397 1
	      f = rate_rotate[X];
d412 1
a412 1
	      f = edit_rate_rotate[Y];
d419 1
a419 1
	      f = rate_rotate[Y];
d434 1
a434 1
	      f = edit_rate_rotate[Z];
d441 1
a441 1
	      f = rate_rotate[Z];
@


11.27
log
@start of cleanup
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.26 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
a53 1
static double sld_xadc, sld_yadc, sld_1adc, sld_2adc, sld_distadc;
d55 1
a55 1
struct scroll_item scr_menu[] = {
d59 1
a59 1
	{ "zoom",	sl_tol,		3,	"S" },
d70 1
a70 1
	{ "Zoom",	sl_tol,		3,	"aS" },
d145 1
a145 1
	scroll_array[0] = scr_menu;
@


11.26
log
@experimentation
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.25 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d65 1
a65 1
      };
d68 4
a71 4
	{ "Xslew",	sl_tol,	0,	"aX" },
	{ "Yslew",	sl_tol,	1,	"aY" },
	{ "Zslew",	sl_tol,	2,	"aZ" },
	{ "Zoom",	sl_tol,	3,	"aS" },
a101 9
#if 0
  char *av[3];

  av[0] = "knob";
  av[1] = "zero";
  av[2] = NULL;

  (void)f_knob((ClientData)NULL, interp, 2, av);
#else
a102 1
#endif
a110 13
#if 0
  char *av[3];

  av[0] = "sliders";
  av[2] = NULL;

  if( mged_variables.scroll_enabled == 0 )
    av[1] = "on";
  else
    av[1] = "off";

  (void)cmd_sliders((ClientData)NULL, interp, 2, av);
#else
a114 1
#endif
a185 14

#if 0
  {
    char *av[4];

    av[0] = "knob";
    av[1] = mptr->scroll_cmd;
    av[3] = NULL;

    bu_vls_printf(&vls, "%f", val);
    av[2] = bu_vls_addr(&vls);
    (void)f_knob((ClientData)NULL, interp, 3, av);
  }
#else
a187 2
#endif

@


11.25
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.24 1996/12/04 21:17:33 bparker Exp bparker $ (BRL)";
d68 4
a71 4
	{ "Xslew",	sl_tol,		0,	"aX" },
	{ "Yslew",	sl_tol,		1,	"aY" },
	{ "Zslew",	sl_tol,		2,	"aZ" },
	{ "Zoom",	sl_tol,		3,	"aS" },
d320 1
a320 1
	  if(EDIT_TRAN){
d341 1
a341 1
	  if(EDIT_TRAN){
d362 1
a362 1
	  if(EDIT_TRAN){
d383 1
a383 1
	  if(EDIT_SCALE){
d404 1
a404 1
	  if(EDIT_ROTATE){
d426 1
a426 1
	  if(EDIT_ROTATE){
d448 1
a448 1
	  if(EDIT_ROTATE){
@


11.24
log
@*- add sl_artol()
*- other mods to deal with absolute_rotate
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.23 1996/11/19 21:48:39 bparker Exp bparker $ (BRL)";
d43 1
d292 117
a408 12
	register int		y;
	struct scroll_item	*mptr;
	struct scroll_item	**m;
	int		xpos;
	int second_menu = -1;
	fastf_t f;

	/* XXX this should be driven by the button event */
	if( mged_variables.adcflag && mged_variables.scroll_enabled )
		scroll_array[1] = sl_adc_menu;
	else
		scroll_array[1] = SCROLL_NULL;
d410 6
a415 2
	scroll_top = y_top;
	y = y_top;
d417 14
a430 1
	dmp->dm_setLineAttr(dmp, 1, 0);  /* linewidth - 1, not dashed */
d432 4
a435 91
	for( m = &scroll_array[0]; *m != SCROLL_NULL; m++ )  {
	  ++second_menu;
	  for( mptr = *m; mptr->scroll_string[0] != '\0'; mptr++ )  {
	    y += SCROLL_DY;		/* y is now bottom line pos */

	    switch(mptr->scroll_val){
	    case 0:
	      if(second_menu)
                f = (double)dv_xadc / 2047.0;
	      else {
		if(mged_variables.rateknobs)
		  f = rate_slew[X];
		else
		  f = absolute_slew[X];
	      }
	      break;
	    case 1:
	      if(second_menu)
		f = (double)dv_yadc / 2047.0;
	      else {
		if(mged_variables.rateknobs)
		  f = rate_slew[Y];
		else
		  f = absolute_slew[Y];
	      }
	      break;
	    case 2:
	      if(second_menu)
		f = (double)dv_1adc / 2047.0;
	      else {
		if(mged_variables.rateknobs)
		  f = rate_slew[Z];
		else
		  f = absolute_slew[Z];
	      }
	      break;
	    case 3:
	      if(second_menu)
		f = (double)dv_2adc / 2047.0;
	      else {
		if(mged_variables.rateknobs)
		  f = rate_zoom;
		else
		  f = absolute_zoom;
	      }
	      break;
	    case 4:
	      if(second_menu)
		f = (double)dv_distadc / 2047.0;
	      else {
		if(mged_variables.rateknobs)
		  f = rate_rotate[X];
		else
		  f = absolute_rotate[X] / 180.0;
	      }
	      break;
	    case 5:
	      if(second_menu)
		Tcl_AppendResult(interp, "scroll_display: 2nd scroll menu is hosed\n",
				 (char *)NULL);
	      else {
		if(mged_variables.rateknobs)
		  f = rate_rotate[Y];
		else
		  f = absolute_rotate[Y] / 180.0;
	      }
	      break;
	    case 6:
	      if(second_menu)
		Tcl_AppendResult(interp, "scroll_display: 2nd scroll menu is hosed\n",
				 (char *)NULL);
	      else {
		if(mged_variables.rateknobs)
		  f = rate_rotate[Z];
		else
		  f = absolute_rotate[Z] / 180.0;
	      }
	      break;
	    default:
	      if(second_menu)
		Tcl_AppendResult(interp, "scroll_display: 2nd scroll menu is hosed\n",
				 (char *)NULL);
	      else
		Tcl_AppendResult(interp, "scroll_display: first scroll menu is hosed\n",
				 (char *)NULL);
	    }

	    if(f > 0)
	      xpos = (f + SL_TOL) * 2047.0;
	    else if(f < 0)
	      xpos = (f - SL_TOL) * -MENUXLIM;
d437 1
a437 1
	      xpos = 0;
a439 4
	    dmp->dm_drawString2D( dmp, mptr->scroll_string,
			   xpos, y-SCROLL_DY/2, 0 );
	    dmp->dm_setColor(dmp, DM_YELLOW, 1);
	    dmp->dm_drawLine2D(dmp, XMAX, y, MENUXLIM, y);
d442 11
d454 6
d461 2
a462 5
	if( y != y_top )  {
	  /* Sliders were drawn, so make left vert edge */
	  dmp->dm_setColor(dmp, DM_YELLOW, 1);
	  dmp->dm_drawLine2D( dmp, MENUXLIM, scroll_top-1,
			      MENUXLIM, y, 0, DM_YELLOW );
d464 31
a494 1
	return( y );
@


11.23
log
@send calls to knob and sliders through Tcl interpreter
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.22 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d51 3
a53 2
static void	sl_itol();
static double	sld_xadc, sld_yadc, sld_1adc, sld_2adc, sld_distadc;
d60 4
a63 4
	{ "xrot",	sl_tol,		4,   "x" },
	{ "yrot",	sl_tol,		5,   "y" },
	{ "zrot",	sl_tol,		6,   "z" },
	{ "",		(void (*)())NULL, 0, "" }
d71 4
a74 4
	{ "Xrot",	sl_tol,		4,   "ax" },
	{ "Yrot",	sl_tol,		5,   "ay" },
	{ "Zrot",	sl_tol,		6,   "az" },
	{ "",		(void (*)())NULL, 0, "" }
d78 5
a82 5
	{ "xadc",	sl_itol,	0, "xadc" },
	{ "yadc",	sl_itol,	1, "yadc" },
	{ "ang 1",	sl_itol,	2, "ang1" },
	{ "ang 2",	sl_itol,	3, "ang2" },
	{ "tick",	sl_itol,	4, "distadc" },
d98 2
a99 1
void sl_halt_scroll()
d117 2
a118 1
void sl_toggle_scroll()
d189 1
a189 1
 *  everything can bel handled by sl_tol().				*
d193 2
a194 1
static void sl_tol( mptr, val )
d230 4
a233 3
static void sl_itol( mptr, val )
register struct scroll_item     *mptr;
double				val;
d246 4
a250 3
#if 0
  {
    char *av[4];
d252 6
a257 3
    av[0] = "knob";
    av[1] = mptr->scroll_cmd;
    av[3] = NULL;
d259 6
a264 3
    bu_vls_printf(&vls, "%d", (int)(val*2047.0));
    av[2] = bu_vls_addr(&vls);
    (void)f_knob((ClientData)NULL, interp, 3, av);
d266 2
a267 1
#else
a269 2
#endif

d362 1
a362 1
		  f = absolute_rotate[X];
d373 1
a373 1
		  f = absolute_rotate[Y];
d384 1
a384 1
		  f = absolute_rotate[Z];
@


11.22
log
@hacks to use latest libdm
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.21 1996/10/03 20:24:07 bparker Exp bparker $ (BRL)";
d99 1
d107 3
d117 1
d129 6
a193 1
  char *av[4];
a195 4
  av[0] = "knob";
  av[1] = mptr->scroll_cmd;
  av[3] = NULL;

d205 18
a222 3
  bu_vls_printf(&vls, "%f", val);
  av[2] = bu_vls_addr(&vls);
  (void)f_knob((ClientData)NULL, interp, 3, av);
a229 1
  char *av[4];
a231 4
  av[0] = "knob";
  av[1] = mptr->scroll_cmd;
  av[3] = NULL;

d241 18
a258 3
  bu_vls_printf(&vls, "%d", (int)(val*2047.0));
  av[2] = bu_vls_addr(&vls);
  (void)f_knob((ClientData)NULL, interp, 3, av);
@


11.21
log
@get rid of extra cmdline() uses
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.20 1996/10/01 17:23:59 bparker Exp bparker $ (BRL)";
d265 2
d361 5
a365 3
	    dmp->dmr_puts( dmp, mptr->scroll_string,
			   xpos, y-SCROLL_DY/2, 0, DM_RED );
	    dmp->dmr_2d_line(dmp, XMAX, y, MENUXLIM, y, 0);
d371 4
a374 3
		/* Sliders were drawn, so make left vert edge */
		dmp->dmr_2d_line( dmp, MENUXLIM, scroll_top-1,
			MENUXLIM, y, 0 );
@


11.20
log
@no longer using dm_values
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.19 1996/09/23 18:20:37 bparker Exp bparker $ (BRL)";
d55 7
a61 7
	{ "xslew",	sl_tol,		0,	"knob X" },
	{ "yslew",	sl_tol,		1,	"knob Y" },
	{ "zslew",	sl_tol,		2,	"knob Z" },
	{ "zoom",	sl_tol,		3,	"knob S" },
	{ "xrot",	sl_tol,		4,   "knob x" },
	{ "yrot",	sl_tol,		5,   "knob y" },
	{ "zrot",	sl_tol,		6,   "knob z" },
d66 7
a72 7
	{ "Xslew",	sl_tol,		0,	"knob aX" },
	{ "Yslew",	sl_tol,		1,	"knob aY" },
	{ "Zslew",	sl_tol,		2,	"knob aZ" },
	{ "Zoom",	sl_tol,		3,	"knob aS" },
	{ "Xrot",	sl_tol,		4,   "knob ax" },
	{ "Yrot",	sl_tol,		5,   "knob ay" },
	{ "Zrot",	sl_tol,		6,   "knob az" },
d77 5
a81 5
	{ "xadc",	sl_itol,	0, "knob xadc" },
	{ "yadc",	sl_itol,	1, "knob yadc" },
	{ "ang 1",	sl_itol,	2, "knob ang1" },
	{ "ang 2",	sl_itol,	3, "knob ang2" },
	{ "tick",	sl_itol,	4, "knob distadc" },
d99 1
a99 1
  struct bu_vls cmd;
d101 3
a103 1
  bu_vls_init(&cmd);
d105 1
a105 5
  /* The 'knob' command will zero the rate_slew[] array, etc. */
  bu_vls_strcpy(&cmd, "knob zero\n");
  (void)cmdline(&cmd, False);

  bu_vls_free(&cmd);
d113 1
a113 1
  struct bu_vls cmd;
d115 2
a116 1
  bu_vls_init(&cmd);
d119 1
a119 1
    bu_vls_strcpy( &cmd, "sliders on\n" );
d121 1
a121 3
    bu_vls_strcpy( &cmd, "sliders off\n" );

  (void)cmdline(&cmd, False);
d123 1
a123 1
  bu_vls_free(&cmd);
d183 2
a184 1
	struct bu_vls cmd;
d186 17
a202 12
	if( val < -SL_TOL )   {
		val += SL_TOL;
	} else if( val > SL_TOL )   {
		val -= SL_TOL;
	} else {
		val = 0.0;
	}

	bu_vls_init( &cmd );
	bu_vls_printf( &cmd, "%s %f\n", mptr->scroll_cmd, val );
	(void)cmdline( &cmd, FALSE );
	bu_vls_free(&cmd);
d209 2
a210 1
	struct bu_vls cmd;
d212 17
a228 12
	if( val < -SL_TOL )   {
		val += SL_TOL;
	} else if( val > SL_TOL )   {
		val -= SL_TOL;
	} else {
		val = 0.0;
	}

	bu_vls_init( &cmd );
	bu_vls_printf( &cmd, "%s %d\n", mptr->scroll_cmd, (int)(val * 2047.0) );
	(void)cmdline( &cmd, FALSE );
	bu_vls_free(&cmd);
@


11.19
log
@use LIBDM permanently
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.18 1996/09/17 21:14:48 bparker Exp bparker $ (BRL)";
d99 9
a107 2
	/* The 'knob' command will zero the rate_slew[] array, etc. */
	bu_vls_printf(&dm_values.dv_string, "knob zero\n");
@


11.18
log
@prepare to use libdm
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.17 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d40 1
a40 1
#include "./dm.h"
a342 1
#ifdef USE_LIBDM
a345 5
#else
	    dmp->dmr_puts( mptr->scroll_string,
			   xpos, y-SCROLL_DY/2, 0, DM_RED );
	    dmp->dmr_2d_line(XMAX, y, MENUXLIM, y, 0);
#endif
a351 1
#ifdef USE_LIBDM
a353 4
#else
		dmp->dmr_2d_line( MENUXLIM, scroll_top-1,
			MENUXLIM, y, 0 );
#endif
@


11.17
log
@rt_list ---> bu_list
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.16 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d343 5
d351 1
d358 4
d364 1
@


11.16
log
@now using libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.15 1996/08/22 20:57:03 bparker Exp bparker $ (BRL)";
d34 1
@


11.15
log
@changed scroll_val from (fastf_t *) to int.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.14 1996/06/25 20:59:07 bparker Exp bparker $ (BRL)";
d99 1
a99 1
	rt_vls_printf(&dm_values.dv_string, "knob zero\n");
d107 1
a107 1
  struct rt_vls cmd;
d109 1
a109 1
  rt_vls_init(&cmd);
d112 1
a112 1
    rt_vls_strcpy( &cmd, "sliders on\n" );
d114 1
a114 1
    rt_vls_strcpy( &cmd, "sliders off\n" );
d118 1
a118 1
  rt_vls_free(&cmd);
d178 1
a178 1
	struct rt_vls cmd;
d188 2
a189 2
	rt_vls_init( &cmd );
	rt_vls_printf( &cmd, "%s %f\n", mptr->scroll_cmd, val );
d191 1
a191 1
	rt_vls_free(&cmd);
d198 1
a198 1
	struct rt_vls cmd;
d208 2
a209 2
	rt_vls_init( &cmd );
	rt_vls_printf( &cmd, "%s %d\n", mptr->scroll_cmd, (int)(val * 2047.0) );
d211 1
a211 1
	rt_vls_free(&cmd);
@


11.14
log
@sl_itol now uses a tolerance
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.13 1996/06/21 16:05:46 bparker Exp bparker $ (BRL)";
d54 7
a60 7
	{ "xslew",	sl_tol,		(fastf_t *)0,	"knob X" },
	{ "yslew",	sl_tol,		(fastf_t *)1,	"knob Y" },
	{ "zslew",	sl_tol,		(fastf_t *)2,	"knob Z" },
	{ "zoom",	sl_tol,		(fastf_t *)3,	"knob S" },
	{ "xrot",	sl_tol,		(fastf_t *)4,   "knob x" },
	{ "yrot",	sl_tol,		(fastf_t *)5,   "knob y" },
	{ "zrot",	sl_tol,		(fastf_t *)6,   "knob z" },
d65 7
a71 7
	{ "Xslew",	sl_tol,		(fastf_t *)0,	"knob aX" },
	{ "Yslew",	sl_tol,		(fastf_t *)1,	"knob aY" },
	{ "Zslew",	sl_tol,		(fastf_t *)2,	"knob aZ" },
	{ "Zoom",	sl_tol,		(fastf_t *)3,	"knob aS" },
	{ "Xrot",	sl_tol,		(fastf_t *)4,   "knob ax" },
	{ "Yrot",	sl_tol,		(fastf_t *)5,   "knob ay" },
	{ "Zrot",	sl_tol,		(fastf_t *)6,   "knob az" },
d76 5
a80 5
	{ "xadc",	sl_itol,	(fastf_t *)0, "knob xadc" },
	{ "yadc",	sl_itol,	(fastf_t *)1, "knob yadc" },
	{ "ang 1",	sl_itol,	(fastf_t *)2, "knob ang1" },
	{ "ang 2",	sl_itol,	(fastf_t *)3, "knob ang2" },
	{ "tick",	sl_itol,	(fastf_t *)4, "knob distadc" },
d253 1
a253 1
	    switch((int)mptr->scroll_val){
@


11.13
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.12 1996/06/14 20:06:47 bparker Exp bparker $ (BRL)";
d199 8
@


11.12
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.11 1996/05/24 18:53:38 bparker Exp bparker $ (BRL)";
d107 12
a118 5
	if( scroll_enabled == 0 )  {
 	        rt_vls_printf( &dm_values.dv_string, "sliders on\n" );
        } else {
	        rt_vls_printf( &dm_values.dv_string, "sliders off\n" );
	}
d141 1
a141 1
	Tcl_AppendResult(interp, scroll_enabled ? "1" : "0", (char *)NULL);
d145 1
a145 1
    if (Tcl_GetBoolean(interp, argv[1], &scroll_enabled) == TCL_ERROR)
d148 1
a148 1
    if (scroll_enabled) {
d232 1
a232 1
	if( adcflag && scroll_enabled )
d283 1
a283 1
		  f = rate_zoom;
d367 1
a367 1
	if( !scroll_enabled )  return(0);	/* not enabled */
@


11.11
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.10 1996/05/16 20:59:26 bparker Exp bparker $ (BRL)";
d171 2
a172 1
#if 0
a179 2
#else
	struct rt_vls cmd;
a184 1
#endif
d320 3
a322 3
	    if(f > 0.000001)
	      xpos = (f + SL_TOL) * 2047;
	    else if(f < - 0.000001)
a325 1

@


11.10
log
@modifying sliders
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.9 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
a42 7
#if 0
static int	scroll_top;	/* screen loc of the first menu item */
static int	scroll_enabled = 0;

struct scroll_item *scroll_array[6];	/* Active scroll bar definitions */
#endif

d64 11
d142 1
d144 2
a165 1
#define SL_TOL	0.015625		/* size of dead spot, 0.015 = 32/2048 */
d179 7
a186 3

	rt_vls_printf( &dm_values.dv_string, "%s %f\n",
		mptr->scroll_cmd, val );
d193 6
a198 3
	rt_vls_printf(&dm_values.dv_string, "%s %d\n",
		mptr->scroll_cmd,
		(int)(val * 2047) );
d243 7
a249 3
		f = (double)dv_xadc / 2047.0;
	      else
		f = rate_slew[X];
d254 6
a259 2
	      else
		f = rate_slew[Y];
d264 6
a269 2
	      else
		f = rate_slew[Z];
d274 6
a279 2
	      else
		f = rate_zoom;
d284 6
a289 2
	      else
		f = rate_rotate[X];
d295 6
a300 2
	      else
		f = rate_rotate[Y];
d306 6
a311 2
	      else
		f = rate_rotate[Z];
d322 4
a325 4
	    if( f > 0 )
	      xpos = (f + SL_TOL - SL_TOL * f) * 2047;
	    else if(f < 0)
	      xpos = (f - SL_TOL - SL_TOL * f) * -MENUXLIM;
d396 1
d398 1
@


11.9
log
@Still Tcl'ing the code
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.8 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d159 1
a159 1
#define SL_TOL	0.015		/* size of dead spot, 0.015 = 32/2047 */
d165 1
d173 1
d281 4
a284 2
	    if( f >= 0 )
	      xpos = f * 2047;
d286 2
a287 1
	      xpos = f * -MENUXLIM;
@


11.8
log
@convert commands to Tcl
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.7 1996/03/22 18:32:55 bparker Exp bparker $ (BRL)";
d43 1
a44 1

d48 1
@


11.7
log
@cleanup
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.6 1996/01/26 15:47:19 bparker Exp bparker $ (BRL)";
d125 5
a129 8
    if (argc > 2) {
	Tcl_SetResult(interp, "too many arguments: should be \"sliders \
?onVal?\"", TCL_STATIC);
	return TCL_ERROR;
    }
    
    if (argc < 2) {
	Tcl_SetResult(interp, scroll_enabled ? "1" : "0", TCL_STATIC);
d257 2
a258 1
		rt_log("scroll_display: 2nd scroll menu is hosed\n");
d264 2
a265 1
		rt_log("scroll_display: 2nd scroll menu is hosed\n");
d271 2
a272 1
		rt_log("scroll_display: 2nd scroll menu is hosed\n");
d274 2
a275 1
		rt_log("scroll_display: first scroll menu is hosed\n");
@


11.6
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.5 1996/01/22 22:50:28 bparker Exp bparker $ (BRL)";
a58 1
#ifdef MULTI_ATTACH
a77 21
#else
struct scroll_item scr_menu[] = {
	{ "xslew",	sl_tol,		&rate_slew[X],	"knob X" },
	{ "yslew",	sl_tol,		&rate_slew[Y],	"knob Y" },
	{ "zslew",	sl_tol,		&rate_slew[Z],	"knob Z" },
	{ "zoom",	sl_tol,		&rate_zoom,	"knob S" },
	{ "xrot",	sl_tol,		&rate_rotate[X],"knob x" },
	{ "yrot",	sl_tol,		&rate_rotate[Y],"knob y" },
	{ "zrot",	sl_tol,		&rate_rotate[Z],"knob z" },
	{ "",		(void (*)())NULL, 0, "" }
};

struct scroll_item sl_adc_menu[] = {
	{ "xadc",	sl_itol,	&sld_xadc, "knob xadc" },
	{ "yadc",	sl_itol,	&sld_yadc, "knob yadc" },
	{ "ang 1",	sl_itol,	&sld_1adc, "knob ang1" },
	{ "ang 2",	sl_itol,	&sld_2adc, "knob ang2" },
	{ "tick",	sl_itol,	&sld_distadc, "knob distadc" },
	{ "",		(void (*)())NULL, 0, "" }
};
#endif
a174 3
#ifndef MULTI_ATTACH
	*(mptr->scroll_val) = val;
#endif
a182 3
#ifndef MULTI_ATTACH
	*(mptr->scroll_val) = val;
#endif
a209 1
#ifdef MULTI_ATTACH
a211 1
#endif
a222 1
#ifdef MULTI_ATTACH
a280 10
#else
		for( mptr = *m; mptr->scroll_string[0] != '\0'; mptr++ )  {
		        y += SCROLL_DY;		/* y is now bottom line pos */
			if( *(mptr->scroll_val) >= 0 )  {
			     	xpos = *(mptr->scroll_val) * 2047;
			} else {
				/* The menu gets in the way */
			     	xpos = *(mptr->scroll_val) * -MENUXLIM;
			}
#endif
d282 4
a285 4
			dmp->dmr_puts( mptr->scroll_string,
				xpos, y-SCROLL_DY/2, 0, DM_RED );
			dmp->dmr_2d_line(XMAX, y, MENUXLIM, y, 0);
		}
@


11.5
log
@*** empty log message ***
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.4 1995/12/11 22:50:27 bparker Exp bparker $ (BRL)";
d261 1
a261 1
		f = curs_x;
d267 1
a267 1
		f = curs_y;
d273 1
a273 1
		f = dv_1adc;
d279 1
a279 1
		f = dv_2adc;
d285 1
a285 1
		f = c_tdist;
@


11.4
log
@used ignore_scroll_and_menu variable to eliminate some unnecessary
drawing when activating the scrollbars
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.3 1995/08/09 13:01:51 gdurf Exp bparker $ (BRL)";
d56 14
d71 9
a90 3
static void	sl_itol();
static double	sld_xadc, sld_yadc, sld_1adc, sld_2adc, sld_distadc;

d99 1
a99 1

d168 1
a168 1
    if(!ignore_scroll_and_menu)
d196 2
d199 1
d208 1
d210 1
d238 4
d251 1
d253 60
d314 1
a314 1
		     	y += SCROLL_DY;		/* y is now bottom line pos */
d321 2
d328 2
@


11.3
log
@Added missing return
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.2 1995/08/03 21:48:11 gdurf Exp gdurf $ (BRL)";
d147 3
a149 1
    dmaflag++;
@


11.2
log
@Allowed support for GUI scrollbars
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 11.1 1995/01/04 10:03:33 mike Rel4_4 gdurf $ (BRL)";
d148 2
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 10.7 94/12/24 00:38:34 mike Exp $ (BRL)";
d28 4
d41 2
d104 15
d120 28
a147 8
	scroll_enabled = (scroll_enabled == 0) ? 1 : 0;
	if( scroll_enabled )  {
		scroll_array[0] = scr_menu;
	} else {
		scroll_array[0] = SCROLL_NULL;	
		scroll_array[1] = SCROLL_NULL;	
	}
	dmaflag++;
@


10.7
log
@Run though 'knob' command now.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 10.6 94/12/05 15:31:02 mike Exp Locker: mike $ (BRL)";
@


10.6
log
@Bug #222
mged on-screen sliders can't set full range of values
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 10.5 94/12/05 14:55:50 mike Exp Locker: mike $ (BRL)";
d52 8
a59 8
	{ "xslew",	sl_tol,		&rate_slew[X] },
	{ "yslew",	sl_tol,		&rate_slew[Y] },
	{ "zslew",	sl_tol,		&rate_slew[Z] },
	{ "zoom",	sl_tol,		&rate_zoom },
	{ "xrot",	sl_tol,		&rate_rotate[X] },
	{ "yrot",	sl_tol,		&rate_rotate[Y] },
	{ "zrot",	sl_tol,		&rate_rotate[Z] },
	{ "",		(void (*)())NULL, 0 }
d62 1
a62 1
static void	sl_xadc(), sl_yadc(), sl_1adc(), sl_2adc(), sl_distadc();
d66 6
a71 6
	{ "xadc",	sl_xadc,	&sld_xadc },
	{ "yadc",	sl_yadc,	&sld_yadc },
	{ "ang 1",	sl_1adc,	&sld_1adc },
	{ "ang 2",	sl_2adc,	&sld_2adc },
	{ "tick",	sl_distadc,	&sld_distadc },
	{ "",		(void (*)())NULL, 0 }
a115 2
 *  When conversion to integer is required, an individual handler	*
 *  is required for each slider.					*
d120 1
a120 1
static void sl_tol( mptr )
d122 1
d124 4
a127 5

	if( *mptr->scroll_val < -SL_TOL )   {
		*(mptr->scroll_val) += SL_TOL;
	} else if( *mptr->scroll_val > SL_TOL )   {
		*(mptr->scroll_val) -= SL_TOL;
d129 1
a129 1
		*(mptr->scroll_val) = 0.0;
d131 3
a133 1
	check_nonzero_rates();
d136 1
a136 1
static void sl_xadc( mptr )
d138 1
d140 4
a143 2
	rt_vls_printf(&dm_values.dv_string, "knob xadc %d\n",
		(int)(*(mptr->scroll_val) * 2047) );
a145 6
static void sl_yadc( mptr )
register struct scroll_item     *mptr;
{
	rt_vls_printf(&dm_values.dv_string, "knob yadc %d\n",
		(int)(*(mptr->scroll_val) * 2047) );
}
a146 22
static void sl_1adc( mptr )
register struct scroll_item     *mptr;
{
	rt_vls_printf(&dm_values.dv_string, "knob ang1 %d\n",
		(int)(*(mptr->scroll_val) * 2047) );
}

static void sl_2adc( mptr )
register struct scroll_item     *mptr;
{
	rt_vls_printf(&dm_values.dv_string, "knob ang2 %d\n",
		(int)(*(mptr->scroll_val) * 2047) );
}

static void sl_distadc( mptr )
register struct scroll_item     *mptr;
{
	rt_vls_printf(&dm_values.dv_string, "knob distadc %d\n",
		(int)(*(mptr->scroll_val) * 2047) );
}


d229 1
d241 1
a241 1
				*(mptr->scroll_val) = pen_x/2047.0;
d243 1
a243 1
				*(mptr->scroll_val) = pen_x/(double)(-MENUXLIM);
d249 1
a249 1
			(*(mptr->scroll_func))(mptr);
@


10.5
log
@Changed to new way of handling events.
Fixed bug #51
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 10.4 94/08/11 01:29:51 gdurf Exp Locker: mike $ (BRL)";
d205 6
a210 1
		     	xpos = *(mptr->scroll_val) * 2047;
d258 11
a268 2
			/* Record the location of scroll marker */
			*(mptr->scroll_val) = pen_x/2047.0;
@


10.4
log
@Added include of extern.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 10.3 1994/08/09 18:28:36 gdurf Exp gdurf $ (BRL)";
d89 2
a90 11
	struct scroll_item      **m;
	register struct scroll_item     *mptr;

	/* Re-init scrollers */
	for( m = &scroll_array[0]; *m != SCROLL_NULL; m++ )  {
		for( mptr = *m; mptr->scroll_string[0] != '\0'; mptr++ ){
			*(mptr->scroll_val) = 0.0;
		}
	}

	dmaflag = 1;
d139 2
a140 1
	dm_values.dv_xadc = *(mptr->scroll_val) * 2047;
d146 2
a147 1
	dm_values.dv_yadc = *(mptr->scroll_val) * 2047;
d153 2
a154 1
	dm_values.dv_1adc = *(mptr->scroll_val) * 2047;
d160 2
a161 1
	dm_values.dv_2adc = *(mptr->scroll_val) * 2047;
d167 2
a168 1
	dm_values.dv_distadc = *(mptr->scroll_val) * 2047;
@


10.3
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 10.2 1991/11/05 00:03:00 mike Exp gdurf $ (BRL)";
d29 1
@


10.2
log
@Modified for beginnings of new display manager interface.
Added zoom and "M" (mouse) command.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/scroll.c,v 10.1 91/10/12 06:44:16 mike Rel4_0 $ (BRL)";
d24 2
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: scroll.c,v 9.1 89/05/19 06:03:46 mike Rel3_5 $ (BRL)";
d49 7
a55 7
	{ "xslew",	sl_tol,		&dm_values.dv_xslew },
	{ "yslew",	sl_tol,		&dm_values.dv_yslew },
	{ "zslew",	sl_tol,		&dm_values.dv_zslew },
	{ "zoom",	sl_tol,		&dm_values.dv_zoom },
	{ "xrot",	sl_tol,		&dm_values.dv_xjoy },
	{ "yrot",	sl_tol,		&dm_values.dv_yjoy },
	{ "zrot",	sl_tol,		&dm_values.dv_zjoy },
d139 1
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: scroll.c,v 1.2 89/04/22 05:45:20 mike Exp $ (BRL)";
@


1.2
log
@Simplified scroll-bars Y layout slightly,
to prevent wrap-around on Megatek.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: scroll.c,v 1.1 89/04/21 04:45:48 mike Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: scroll.c,v 7.2 87/11/05 05:06:28 mike Exp $ (BRL)";
d181 3
a183 1
 *  
d185 1
a185 1
void
d200 1
a201 2
	scroll_top = y - SCROLL_DY / 2;

d203 7
a209 6
	   for( mptr = *m; mptr->scroll_string[0] != '\0';
	     mptr++, y += SCROLL_DY )  {
	     	xpos = *(mptr->scroll_val) * 2047;
		dmp->dmr_puts( mptr->scroll_string, xpos, y, 0, DM_RED );
		dmp->dmr_2d_line(XMAX, y+(SCROLL_DY/2), MENUXLIM, y+(SCROLL_DY/2), 0);
	     }
d211 6
a216 4
	if( y == y_top )  return;	/* no active menus */

	dmp->dmr_2d_line( MENUXLIM, scroll_top-1, MENUXLIM, y-(SCROLL_DY/2), 0 );
	dmp->dmr_2d_line( MENUXLIM, scroll_top, XMAX, scroll_top, 0 );
a246 1

d249 2
a250 2
			yy += SCROLL_DY;
			if( pen_y <= yy )
@
