head	11.5;
access;
symbols
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.5
date	98.10.23.15.12.07;	author bparker;	state dead;
branches;
next	11.4;

11.4
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.06.16.19.17.58;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.09.18.23.38;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.53;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	94.12.27.18.15.39;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.12.27.17.23.04;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.12.16.19.36.05;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.09.07.13.17.20;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.21.42.48;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.15.13.11;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.23;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.02.19;	author mike;	state Rel3_5;
branches;
next	1.3;

1.3
date	89.04.06.20.39.14;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.04.03.20.10.35;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	89.01.24.20.50.39;	author phil;	state Exp;
branches;
next	;


desc
@Hewlett Packard 2397a/2627a interface
@


11.5
log
@*- moved old display managers to dm_old
@
text
@/*
 *			D M - H P . C
 *
 *  Based on dm-tek4109.c
 *
 *  Author -
 *	Mark H. Bowden
 *  
 *  Source -
 *	Research Institute, RI E47
 *	University of Alabama in Huntsville
 *	Huntsville, AL  35899
 *	(205) 876-1089 Redstone Arsenal
 *	(205) 895-6467 Research Institute
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-hp.c,v 11.4 1996/08/27 20:30:05 bparker Exp bparker $ (ARL)";
#endif

#include "conf.h"

#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "mater.h"
#include "./ged.h"
#include "./dm.h"
#include "externs.h"
#include "./solid.h"

typedef unsigned char u_char;

/* Display Manager package interface */
 
#define HPBOUND	1000.0	/* Max magnification in Rot matrix */

int	HP_open();
void	HP_close();
MGED_EXTERN(void	HP_input, (fd_set *input, int noblock) );
void	HP_prolog(), HP_epilog();
void	HP_normal(), HP_newrot();
void	HP_update();
void	HP_puts(), HP_2d_line();
void	HP_light();
int	HP_object();
unsigned HP_cvtvecs(), HP_load();
void	HP_statechange(), HP_viewchange(), HP_colorchange();
void	HP_window(), HP_debug();

struct dm dm_Hp = {
	HP_open, HP_close,
	HP_input,
	HP_prolog, HP_epilog,
	HP_normal, HP_newrot,
	HP_update,
	HP_puts, HP_2d_line,
	HP_light,
	HP_object,
	HP_cvtvecs, HP_load,
	HP_statechange,
	HP_viewchange,
	HP_colorchange,
	HP_window, HP_debug,
	0,				/* no displaylist */
	0,				/* No frame buffer */
	HPBOUND,
	"HP", "Hewlett Packard 2397a",
	0,
	0
};

extern struct device_values dm_values;	/* values read from devices */

static vect_t clipmin, clipmax;		/* for vector clipping */
static int oloy = -1;
static int ohiy = -1;
static int ohix = -1;
static int oextra = -1;
static int curx, cury;

#define HP2397A		0
#define HP2627A		1
static char termtype;

#define ESC	'\033'          /* Escape */

static void HPmove(), HPcont();

/*
 * Display coordinate conversion
 */
 
#define XGED_TO_HP(x)   (((x)+2048) * 492 / 4096)
#define XHP_TO_GED(x)   (((x) * 4096 / 492) - 2048)
#define YGED_TO_HP(y)   (((y)+2048) * 25 / 256)
#define YHP_TO_GED(y)   (((y) * 256 / 25) - 2048)

/*
 * HP_open - Fire up the display manager, and the display processor.
 */

HP_open()
{
	char s[16];

	printf("\033*j1A");	/* set tablet on-line */
	printf("\033*s1^");	/* request terminal name */
	(void)fgets(s,16,stdin);	/* read name */
	if (!strcmp(s,"2627A\n")) {
	    termtype = HP2627A;
	    printf("\033*j1C");	/* asynchrous tablet mode */
	} else {
	    termtype = HP2397A;
	    printf("\033*j9F");	/* penpress reports F9 pressed */
	}
	bu_log("Terminal type: %s\n",s);
	printf("%c*da",ESC);	/* clear graphics memory */
	printf("%c*dc",ESC);	/* graphics display on */
	printf("%c*dk",ESC);	/* graphics cursor on */
	printf("%c*e0b",ESC);	/* background color */
	printf("%c*m6x",ESC);	/* line color */
	printf("%c*n3x",ESC);	/* text color */
	return(0);		/* OK */
}

/*
 *  HP_close - Gracefully release the display.
 */

void
HP_close()
{
	printf("%cH", ESC);	/* cursor home */
	printf("%cJ", ESC);	/* clear screen */
	printf("%c&w6S",ESC);	/* Set Dialog to 12 Lines */
	printf("%c*dD",ESC);	/* graphics off */
	printf("%c*dT",ESC);	/* graph text off */
	printf("%c*dE",ESC);	/* alpha on*/
	(void)fflush(stdout);
}

/*
 * HP_prolog - If something significant has happened, clear screen and redraw
 */

void
HP_prolog()
{
    if (dmaflag) {
	printf("%c*da",ESC);	/* clear graphics memory */
	(void)fflush(stdout);
	point( 0, 0 );			/* Put up the center point */
	printf("\033c");		/* disable keyboard */
    }
}

/*
 * HP_epilog - done drawing
 */

void
HP_epilog()
{
	HPmove(XHP_TO_GED(curx),YHP_TO_GED(cury));
	printf("\033b");			/* enable keyboard */
}

/*
 * HP_object
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */

/* ARGSUSED */
int
HP_object( sp, mat, ratio, white )
register struct solid *sp;
mat_t mat;
double ratio;
{
	static vect_t last;
	register struct vlist *vp;
	int color;
	int useful = 0;

	if(  sp->s_soldash )
		printf("%c*m4b",ESC);	/* Dot Dash */
	else	
		printf("%c*m1b",ESC);	/* Solid Line */

	color = sp->s_dmindex;
	printf("%c*m%1dx",ESC,color);
	
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		/* Viewing region is from -1.0 to +1.0 */
		if( vp->vl_draw == 0 )  {
			/* Move, not draw */
			MAT4X3PNT( last, mat, vp->vl_pnt );
		}  else  {
			static vect_t fin;
			static vect_t start;
			/* draw */
			MAT4X3PNT( fin, mat, vp->vl_pnt );
			VMOVE( start, last );
			VMOVE( last, fin );
			if(
				/* sqrt(1+1) */
				(ratio >= 0.7071)  &&
				vclip( start, fin, clipmin, clipmax ) == 0
			)  continue;

			HPmove(	(int)( start[0] * 2047 ),
				(int)( start[1] * 2047 ) );
			HPcont(	(int)( fin[0] * 2047 ),
				(int)( fin[1] * 2047 ) );
			useful = 1;
		}
	}
	printf("%c*m6x",ESC);
	return(useful);
}

/*
 * HP_puts - Output a string into the displaylist.
 */

void
HP_puts( str, x, y, size, color )
register u_char *str;
{
	HPmove(x,y - 29);
	printf("\033*l%s\n",str);
}

/*
 * HP_2d_line
 */

void
HP_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	if( dashed )
		linemod("dotdashed");
	else
		linemod("solid");
	HPmove(x1,y1);
	HPcont(x2,y2);
}

/*
 *			H P _ I N P U T
 *
 * The GED "generic input" structure is filled in.
 *
 * Read first character. If it is a penpress, get cursor position and return
 * indicating no command awaits. Otherwise, put character back on stdin and
 * return indicating that a command does await.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 *
 */
void
HP_input( input, noblock )
fd_set		*input;
int		noblock;
{
	int ch;
	int xpen, ypen;
	char str_buf[128];

	/* XXX No select() processing here */

	if ((ch = getchar()) == '\033') {	/* hp2397a penpress */
	    ch = getchar();			/* what kind of penpress ? */
	    fflush(stdin);
	    printf("\033*s3^");		/* ask terminal for cursor position */
	    scanf("%d,%d",&curx,&cury);
	    xpen     = XHP_TO_GED(curx);
	    ypen     = YHP_TO_GED(cury);
	    switch ( ch ) {
		case 'q':
	    		if( xpen )
	    		{
		    		sprintf( str_buf , "knob X %f\n" , (float)xpen/2048.0 );
	    			bu_vls_strcat( &dm_values.dv_string , str_buf );
	    		}
	    		if( ypen )
	    		{
		    		sprintf( str_buf , "knob Y %f\n" , (float)ypen/2048.0 );
	    			bu_vls_strcat( &dm_values.dv_string , str_buf );
	    		}
		    break;
		case 'r':
	    		bu_vls_strcat( &dm_values.dv_string , "zoom 0.5\n" );
		    break;
		case 's':
	    		bu_vls_strcat( &dm_values.dv_string , "zoom 2\n" );
		    break;
		default:
	    		sprintf( str_buf , "M 1 %d %d\n", xpen, ypen );
	    		bu_vls_strcat( &dm_values.dv_string , str_buf );
	    	    break;
	    }
		FD_CLR( fileno(stdin), input );
		return;
	} else if (ch == '+') {		/* hp2627a penpress */
	    scanf("%d,%d",&curx,&cury);
	    xpen     = XHP_TO_GED(curx);
	    ypen     = YHP_TO_GED(cury);
	    sprintf( str_buf , "M 1 %d %d\n", xpen, ypen );
	    bu_vls_strcat( &dm_values.dv_string , str_buf );
		FD_CLR( fileno(stdin), input );
		return;
	} else {			/* Not a penpress so */
	    ungetc(ch,stdin);		/* put character back on stdin. */
		FD_SET( fileno(stdin), input );
		return;
	}
/* NOTREACHED */
}

/*
 *  			H P _ C O L O R C H A N G E
 *  
 *  Go through the mater table and assign colors.
 *
 */
void
HP_colorchange()
{
	register struct mater *mp;

	for( mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw )
		HP_colorit( mp );

	color_soltab();		/* apply colors to the solid table */
}


int
HP_colorit( mp )
register struct mater *mp;
{
	static int i;

	i = (i % 7) + 1;
	mp->mt_dm_int = i;
}

/* Continue motion from last position */
static void
HPcont(x,y)
register int x,y;
{
	int ix,iy;

	ix = XGED_TO_HP(x);
	iy = YGED_TO_HP(y);
	printf("%c*d%d,%do",ESC,ix,iy);    /* move cursr */
	printf("%c*pc",ESC);               /* new point */
}

static void
HPmove(xi,yi)
{
	printf("%c*pa",ESC);	/* pen up */
	HPcont(xi,yi);
	printf("%c*pb",ESC);	/* pen down */
}

static linemod(s)
register char *s;
{
	char  c;

	switch(s[0]){
	case 'l':	
		c = '5';                         /* Long Dashed Line */
		break;
	case 'd':	
		if(s[3] != 'd')c='7';		/* Dot Line   NRTC */
		else c='4';			/* Dot-Dashed Line */
		break;
	case 's':
		if(s[5] != '\0')c='9';		/* Short Dash Line */
		else c='1';			/* Solid Line */
		break;
	default:		/* DAG -- added support for colors */
		c = '1';			/* Solid Line */
		break;
	}
	printf("%c*m%cb",ESC,c);		/* Set Line Mode */
}

static point(xi,yi){
        HPmove(xi,yi);
	HPcont(xi,yi);
}

void
HP_window(w)
register int w[];
{
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
}

/*
 * Stubs
 */

unsigned
HP_cvtvecs( sp )
struct solid *sp;
{
}

unsigned
HP_load( addr, count )
unsigned addr, count;
{
}

void
HP_statechange()
{
}

void
HP_viewchange()
{
}

void
HP_restart()
{
}

void
HP_newrot(mat)
mat_t mat;
{
}

void
HP_light( cmd, func )
int cmd;
int func;
{
}

void
HP_normal()
{
}

void
HP_update()
{
}

void
HP_debug(lvl)
{
}
@


11.4
log
@now using libbu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-hp.c,v 11.3 1995/06/16 19:17:58 gdurf Exp bparker $ (ARL)";
@


11.3
log
@Added missing dm_Hp structure elements
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-hp.c,v 11.2 1995/01/09 18:23:38 gdurf Exp gdurf $ (ARL)";
d119 1
a119 1
	rt_log("Terminal type: %s\n",s);
d297 1
a297 1
	    			rt_vls_strcat( &dm_values.dv_string , str_buf );
d302 1
a302 1
	    			rt_vls_strcat( &dm_values.dv_string , str_buf );
d306 1
a306 1
	    		rt_vls_strcat( &dm_values.dv_string , "zoom 0.5\n" );
d309 1
a309 1
	    		rt_vls_strcat( &dm_values.dv_string , "zoom 2\n" );
d313 1
a313 1
	    		rt_vls_strcat( &dm_values.dv_string , str_buf );
d323 1
a323 1
	    rt_vls_strcat( &dm_values.dv_string , str_buf );
@


11.2
log
@Converted a few rt_log()s back into printf()s
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-hp.c,v 11.1 95/01/04 10:02:53 mike Rel4_4 Locker: gdurf $ (ARL)";
d70 3
a72 1
	"HP", "Hewlett Packard 2397a"
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-hp.c,v 10.7 94/12/27 18:15:39 mike Exp $ (ARL)";
d107 2
a108 2
	rt_log("\033*j1A");	/* set tablet on-line */
	rt_log("\033*s1^");	/* request terminal name */
d112 1
a112 1
	    rt_log("\033*j1C");	/* asynchrous tablet mode */
d115 1
a115 1
	    rt_log("\033*j9F");	/* penpress reports F9 pressed */
d118 6
a123 6
	rt_log("%c*da",ESC);	/* clear graphics memory */
	rt_log("%c*dc",ESC);	/* graphics display on */
	rt_log("%c*dk",ESC);	/* graphics cursor on */
	rt_log("%c*e0b",ESC);	/* background color */
	rt_log("%c*m6x",ESC);	/* line color */
	rt_log("%c*n3x",ESC);	/* text color */
d134 6
a139 6
	rt_log("%cH", ESC);	/* cursor home */
	rt_log("%cJ", ESC);	/* clear screen */
	rt_log("%c&w6S",ESC);	/* Set Dialog to 12 Lines */
	rt_log("%c*dD",ESC);	/* graphics off */
	rt_log("%c*dT",ESC);	/* graph text off */
	rt_log("%c*dE",ESC);	/* alpha on*/
d151 1
a151 1
	rt_log("%c*da",ESC);	/* clear graphics memory */
d154 1
a154 1
	rt_log("\033c");		/* disable keyboard */
d166 1
a166 1
	rt_log("\033b");			/* enable keyboard */
d192 1
a192 1
		rt_log("%c*m4b",ESC);	/* Dot Dash */
d194 1
a194 1
		rt_log("%c*m1b",ESC);	/* Solid Line */
d197 1
a197 1
	rt_log("%c*m%1dx",ESC,color);
d224 1
a224 1
	rt_log("%c*m6x",ESC);
d237 1
a237 1
	rt_log("\033*l%s\n",str);
d286 1
a286 1
	    rt_log("\033*s3^");		/* ask terminal for cursor position */
d369 2
a370 2
	rt_log("%c*d%d,%do",ESC,ix,iy);    /* move cursr */
	rt_log("%c*pc",ESC);               /* new point */
d376 1
a376 1
	rt_log("%c*pa",ESC);	/* pen up */
d378 1
a378 1
	rt_log("%c*pb",ESC);	/* pen down */
d402 1
a402 1
	rt_log("%c*m%cb",ESC,c);		/* Set Line Mode */
@


10.7
log
@Added RCSid
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


10.6
log
@Bug 247, changed MaterHead to rt_material_head.
@
text
@d8 2
d15 3
d19 3
@


10.5
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d335 1
a335 1
	for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )
@


10.4
log
@Converted to use dm_values.dv_string instead of changing values directly.
@
text
@d99 2
a100 2
	(void)printf("\033*j1A");	/* set tablet on-line */
	(void)printf("\033*s1^");	/* request terminal name */
d104 1
a104 1
	    (void)printf("\033*j1C");	/* asynchrous tablet mode */
d107 1
a107 1
	    (void)printf("\033*j9F");	/* penpress reports F9 pressed */
d109 7
a115 7
	(void)printf("Terminal type: %s\n",s);
	(void)printf("%c*da",ESC);	/* clear graphics memory */
	(void)printf("%c*dc",ESC);	/* graphics display on */
	(void)printf("%c*dk",ESC);	/* graphics cursor on */
	(void)printf("%c*e0b",ESC);	/* background color */
	(void)printf("%c*m6x",ESC);	/* line color */
	(void)printf("%c*n3x",ESC);	/* text color */
d126 6
a131 6
	(void)printf("%cH", ESC);	/* cursor home */
	(void)printf("%cJ", ESC);	/* clear screen */
	(void)printf("%c&w6S",ESC);	/* Set Dialog to 12 Lines */
	(void)printf("%c*dD",ESC);	/* graphics off */
	(void)printf("%c*dT",ESC);	/* graph text off */
	(void)printf("%c*dE",ESC);	/* alpha on*/
d143 1
a143 1
	(void)printf("%c*da",ESC);	/* clear graphics memory */
d146 1
a146 1
	(void)printf("\033c");		/* disable keyboard */
d158 1
a158 1
	(void)printf("\033b");			/* enable keyboard */
d184 1
a184 1
		printf("%c*m4b",ESC);	/* Dot Dash */
d186 1
a186 1
		printf("%c*m1b",ESC);	/* Solid Line */
d189 1
a189 1
	printf("%c*m%1dx",ESC,color);
d216 1
a216 1
	(void)printf("%c*m6x",ESC);
d229 1
a229 1
	(void)printf("\033*l%s\n",str);
d278 1
a278 1
	    printf("\033*s3^");		/* ask terminal for cursor position */
d361 2
a362 2
	(void)printf("%c*d%d,%do",ESC,ix,iy);    /* move cursr */
	(void)printf("%c*pc",ESC);               /* new point */
d368 1
a368 1
	printf("%c*pa",ESC);	/* pen up */
d370 1
a370 1
	printf("%c*pb",ESC);	/* pen down */
d394 1
a394 1
	printf("%c*m%cb",ESC,c);		/* Set Line Mode */
@


10.3
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d270 2
d276 7
a282 1
	    switch ((ch = getchar())) {		/* what kind of penpress ? */
d284 10
a293 1
		    dm_values.dv_penpress = DV_SLEW;
d296 1
a296 1
		    dm_values.dv_penpress = DV_INZOOM;
d299 1
a299 1
		    dm_values.dv_penpress = DV_OUTZOOM;
d302 3
a304 1
		    dm_values.dv_penpress = DV_PICK;
a305 5
	    fflush(stdin);
	    printf("\033*s3^");		/* ask terminal for cursor position */
	    scanf("%d,%d",&curx,&cury);
	    dm_values.dv_xpen     = XHP_TO_GED(curx);
	    dm_values.dv_ypen     = YHP_TO_GED(cury);
d310 4
a313 3
	    dm_values.dv_xpen     = XHP_TO_GED(curx);
	    dm_values.dv_ypen     = YHP_TO_GED(cury);
	    dm_values.dv_penpress = DV_PICK;
a317 1
	    dm_values.dv_penpress = 0;
@


10.2
log
@Added include of conf.h
@
text
@d34 1
a34 1
int	HP_input();
d259 4
d264 4
a267 2

HP_input( cmd_fd, noblock )
d271 2
d292 2
a293 1
	    return(0);
d299 2
a300 1
	    return(0);
d304 2
a305 1
	    return(1);
@


10.1
log
@Release_4.0
@
text
@d15 2
@


9.1
log
@Release_3.5
@
text
@@


1.3
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@@


1.2
log
@Attempt to modify for current release (untested)
@
text
@d21 1
@


1.1
log
@As received from UA Huntsville (based on 2.3)
@
text
@d16 1
a16 1
#include "./machine.h"	/* special copy */
d18 1
a21 1
#include "./mater.h"
d57 1
d176 2
a177 2
	register struct veclist *vp;
	int nvec,color;
d185 1
a185 4
	if (sp->s_materp != NULL)
	    color = ((struct mater *)sp->s_materp)->mt_dm_int;
        else
	    color = 6;                          /* cyan */
d188 1
a188 2
	nvec = sp->s_vlen;
	for( vp = sp->s_vlist; nvec-- > 0; vp++ )  {
d190 1
a190 1
		if( vp->vl_pen == PEN_UP )  {
@
