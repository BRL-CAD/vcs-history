head	1.71;
access;
symbols
	rel-4-5:1.70
	ctj-4-5-post:1.59
	ctj-4-5-pre:1.59;
locks; strict;
comment	@ * @;


1.71
date	98.10.23.15.12.07;	author bparker;	state dead;
branches;
next	1.70;

1.70
date	98.01.16.22.07.58;	author bparker;	state Exp;
branches;
next	1.69;

1.69
date	97.12.23.14.08.52;	author bparker;	state Exp;
branches;
next	1.68;

1.68
date	97.11.14.15.11.09;	author bparker;	state Exp;
branches;
next	1.67;

1.67
date	97.11.06.20.02.27;	author bparker;	state Exp;
branches;
next	1.66;

1.66
date	97.10.27.19.22.05;	author bparker;	state Exp;
branches;
next	1.65;

1.65
date	97.10.10.21.08.01;	author bparker;	state Exp;
branches;
next	1.64;

1.64
date	97.10.10.16.58.35;	author bparker;	state Exp;
branches;
next	1.63;

1.63
date	97.09.08.18.52.49;	author bparker;	state Exp;
branches;
next	1.62;

1.62
date	97.09.03.14.33.57;	author bparker;	state Exp;
branches;
next	1.61;

1.61
date	97.08.01.21.15.02;	author bparker;	state Exp;
branches;
next	1.60;

1.60
date	97.07.25.20.44.02;	author bparker;	state Exp;
branches;
next	1.59;

1.59
date	97.05.29.14.18.01;	author bparker;	state Exp;
branches;
next	1.58;

1.58
date	97.05.22.19.19.07;	author bparker;	state Exp;
branches;
next	1.57;

1.57
date	97.05.21.12.50.05;	author bparker;	state Exp;
branches;
next	1.56;

1.56
date	97.05.08.14.36.51;	author bparker;	state Exp;
branches;
next	1.55;

1.55
date	97.03.20.22.14.58;	author bparker;	state Exp;
branches;
next	1.54;

1.54
date	97.03.07.21.38.12;	author bparker;	state Exp;
branches;
next	1.53;

1.53
date	97.03.06.14.06.06;	author bparker;	state Exp;
branches;
next	1.52;

1.52
date	97.02.28.21.35.47;	author bparker;	state Exp;
branches;
next	1.51;

1.51
date	97.02.24.22.08.02;	author bparker;	state Exp;
branches;
next	1.50;

1.50
date	97.02.06.22.02.12;	author bparker;	state Exp;
branches;
next	1.49;

1.49
date	97.01.29.23.13.32;	author bparker;	state Exp;
branches;
next	1.48;

1.48
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	1.47;

1.47
date	97.01.02.19.37.38;	author bparker;	state Exp;
branches;
next	1.46;

1.46
date	96.12.23.22.39.14;	author bparker;	state Exp;
branches;
next	1.45;

1.45
date	96.12.13.23.10.54;	author bparker;	state Exp;
branches;
next	1.44;

1.44
date	96.12.11.22.40.57;	author bparker;	state Exp;
branches;
next	1.43;

1.43
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	1.42;

1.42
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	1.41;

1.41
date	96.12.04.21.13.19;	author bparker;	state Exp;
branches;
next	1.40;

1.40
date	96.11.01.22.10.04;	author bparker;	state Exp;
branches;
next	1.39;

1.39
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	1.38;

1.38
date	96.10.18.14.05.43;	author bparker;	state Exp;
branches;
next	1.37;

1.37
date	96.10.04.20.37.54;	author bparker;	state Exp;
branches;
next	1.36;

1.36
date	96.10.03.20.52.10;	author bparker;	state Exp;
branches;
next	1.35;

1.35
date	96.09.30.19.42.58;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	96.09.26.20.38.22;	author bparker;	state Exp;
branches;
next	1.33;

1.33
date	96.09.25.20.04.58;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	96.09.23.18.41.43;	author bparker;	state Exp;
branches;
next	1.31;

1.31
date	96.09.17.21.21.19;	author bparker;	state Exp;
branches;
next	1.30;

1.30
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	1.29;

1.29
date	96.09.03.15.52.52;	author bparker;	state Exp;
branches;
next	1.28;

1.28
date	96.08.29.23.13.21;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	96.08.28.19.44.38;	author bparker;	state Exp;
branches;
next	1.26;

1.26
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	1.25;

1.25
date	96.08.14.20.28.30;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	96.08.02.18.13.18;	author bparker;	state Exp;
branches;
next	1.23;

1.23
date	96.07.25.17.47.03;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	96.07.19.20.51.38;	author bparker;	state Exp;
branches;
next	1.21;

1.21
date	96.06.25.21.04.16;	author bparker;	state Exp;
branches;
next	1.20;

1.20
date	96.06.21.16.00.05;	author bparker;	state Exp;
branches;
next	1.19;

1.19
date	96.06.11.17.13.20;	author bparker;	state Exp;
branches;
next	1.18;

1.18
date	96.05.24.18.44.16;	author bparker;	state Exp;
branches;
next	1.17;

1.17
date	96.05.16.20.59.26;	author bparker;	state Exp;
branches;
next	1.16;

1.16
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	1.14;

1.14
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	96.03.22.22.59.46;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	96.03.22.18.39.33;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	96.03.20.22.15.31;	author bparker;	state Exp;
branches;
next	1.10;

1.10
date	96.03.01.21.35.43;	author bparker;	state Exp;
branches;
next	1.9;

1.9
date	96.02.26.22.01.40;	author bparker;	state Exp;
branches;
next	1.8;

1.8
date	96.02.12.21.45.51;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	96.02.09.22.16.02;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	96.01.26.15.52.56;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	96.01.22.22.50.40;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	96.01.19.22.31.15;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	96.01.17.22.00.48;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	95.12.27.22.29.47;	author bparker;	state Exp;
branches;
next	;


desc
@Experimental display manager that uses
a glx widget with Tcl/Tk bindings
@


1.71
log
@*- moved old display managers to dm_old
@
text
@/*
 *			D M - G L X . C
 *
 *  This display manager started out with the guts from DM-4D which
 *  was modified to use mixed-mode (i.e. gl and X )
 *
 *  Authors -
 *      Robert G. Parker
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-glx.c,v 1.70 1998/01/16 22:07:58 bparker Exp bparker $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include <termio.h>
#undef VMIN		/* is used in vmath.h, too */
#include <ctype.h>

#include <X11/X.h>
#include <gl/glws.h>
#include "tk.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XInput.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>

#include <gl/gl.h>		/* SGI IRIS library */
#include <gl/device.h>		/* SGI IRIS library */
#include <gl/get.h>		/* SGI IRIS library */
#include <gl/cg2vme.h>		/* SGI IRIS, for DE_R1 defn on IRIX 3 */
#include <gl/addrs.h>		/* SGI IRIS, for DER1_STEREO defn on IRIX 3 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/invent.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_dm.h"
#include "./sedit.h"
#include "dm-glx.h"

extern void dm_var_init();
extern void mged_print_result();
extern point_t e_axes_pos;

static int      Glx_doevent();
static int      Glx_dm();
static void     Glx_colorchange();
static void     Glx_statechange();
static void     Glx_dbtext();
static void     establish_zbuffer();
static void     establish_lighting();
static void     dirty_hook();
static void     set_knob_offset();

struct bu_structparse Glx_vparse[] = {
	{"%d",	1, "depthcue",		Glx_MV_O(cueing_on),	Glx_colorchange },
	{"%d",  1, "zclip",		Glx_MV_O(zclipping_on),	dirty_hook },
	{"%d",  1, "zbuffer",		Glx_MV_O(zbuffer_on),	establish_zbuffer },
	{"%d",  1, "lighting",		Glx_MV_O(lighting_on),	establish_lighting },
	{"%d",  1, "debug",		Glx_MV_O(debug),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "has_zbuf",		Glx_MV_O(zbuf),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "has_rgb",		Glx_MV_O(rgb),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "has_doublebuffer",	Glx_MV_O(doublebuffer), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "min_scr_z",		Glx_MV_O(min_scr_z),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "max_scr_z",		Glx_MV_O(max_scr_z),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0,  (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
/* Inverse map for mapping MGED button functions to SGI button numbers */
static unsigned char invbmap[BV_MAXFUNC+1];

/* bit 0 == switchlight 0 */
static unsigned long lights;
#endif

#ifdef IR_KNOBS
/*
 *  Labels for knobs in help mode.
 */
static char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
static char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

static int GlxdoMotion = 0;

int
Glx_dm_init(o_dm_list, argc, argv)
struct dm_list *o_dm_list;
int argc;
char *argv[];
{
  int i;
  char **av;

  /* register application provided routines */
  cmd_hook = Glx_dm;
  state_hook = Glx_statechange;

  /* stuff in a default initialization script */
  av = (char **)bu_malloc(sizeof(char *)*(argc + 2), "Glx_dm_init: av");
  av[0] = "glx_open";
  av[1] = "-i";
  av[2] = "mged_bind_dm";

  /* copy the rest except last */
  for(i = 1; i < argc-1; ++i)
    av[i+2] = argv[i];

  av[i+2] = (char *)NULL;

  dm_var_init(o_dm_list);
  Tk_DeleteGenericHandler(doEvent, (ClientData)NULL);
  if((dmp = dm_open(DM_TYPE_GLX, argc+1, av)) == DM_NULL){
    bu_free(av, "Glx_dm_init: av");
    return TCL_ERROR;
  }

  bu_free(av, "Glx_dm_init: av");
  zclip_ptr = &((struct glx_vars *)dmp->dm_vars)->mvars.zclipping_on;
  eventHandler = Glx_doevent;
  curr_dm_list->s_info->opp = &pathName;
  Tk_CreateGenericHandler(doEvent, (ClientData)NULL);
  dm_configureWindowShape(dmp);

  return TCL_OK;
}

/*
   This routine is being called from doEvent().
   It does not handle mouse button or key events. The key
   events are being processed via the TCL/TK bind command or are being
   piped to ged.c/stdin_input(). Eventually, I'd also like to have the
   dials+buttons bindable. That would leave this routine to handle only
   events like Expose and ConfigureNotify.
*/
static int
Glx_doevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  static int button0  = 0;   /*  State of button 0 */
  static int knob_values[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  struct bu_vls cmd;
  int save_edflag = -1;

  GLXwinset(eventPtr->xany.display, eventPtr->xany.window);

  /* Forward key events to a command window */
  if(mged_variables->send_key && eventPtr->type == KeyPress){
    char buffer[2];
    KeySym keysym;
    struct dm_char_queue *dcqp;

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  &keysym, (XComposeStatus *)NULL);

    if(keysym == mged_variables->hot_key)
      return TCL_OK;

    BU_GETSTRUCT(dcqp, dm_char_queue);
    dcqp->dlp = curr_dm_list;
    BU_LIST_PUSH(&head_dm_char_queue.l, &dcqp->l);
    write(dm_pipe[1], buffer, 1);

    /* Use this so that these events won't propagate */
    return TCL_RETURN;
  }

  bu_vls_init(&cmd);
  if ( eventPtr->type == Expose && eventPtr->xexpose.count == 0 ) {
    glx_clearToBlack(dmp);
    dirty = 1;

    goto handled;
  } else if( eventPtr->type == ConfigureNotify ) {
    dm_configureWindowShape(dmp);
    dirty = 1;

    goto handled;
  } else if( eventPtr->type == MapNotify ){
    mapped = 1;

    goto handled;
  } else if( eventPtr->type == UnmapNotify ){
    mapped = 0;

    goto handled;
  } else if( eventPtr->type == MotionNotify ) {
    int mx, my;
    int dx, dy;
    fastf_t f;
    fastf_t fx, fy;
    fastf_t td;

    mx = eventPtr->xmotion.x;
    my = eventPtr->xmotion.y;
    dx = mx - ((struct glx_vars *)dmp->dm_vars)->omx;
    dy = my - ((struct glx_vars *)dmp->dm_vars)->omy;

    switch(am_mode){
    case AMM_IDLE:
      if(scroll_active && eventPtr->xmotion.state & ((struct glx_vars *)dmp->dm_vars)->mb_mask)
	bu_vls_printf( &cmd, "M 1 %d %d\n",
		       (int)(dm_Xx2Normal(dmp, mx, 0) * 2047.0),
		       (int)(dm_Xy2Normal(dmp, my) * 2047.0) );
      else if(GlxdoMotion)
	/* do the regular thing */
	/* Constant tracking (e.g. illuminate mode) bound to M mouse */
	bu_vls_printf( &cmd, "M 0 %d %d\n",
		       (int)(dm_Xx2Normal(dmp, mx, 1) * 2047.0),
		       (int)(dm_Xy2Normal(dmp, my) * 2047.0) );
      else /* not doing motion */
	goto handled;

      break;
    case AMM_ROT:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	char save_ecoords;

	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	if(mged_variables->rateknobs)
	  bu_vls_printf(&cmd, "knob -i x %lf y %lf\n",
			dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
			dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
	else
	  bu_vls_printf(&cmd, "knob -i ax %lf ay %lf\n",
			dy * 0.25, dx * 0.25);

	(void)Tcl_Eval(interp, bu_vls_addr(&cmd));

	mged_variables->ecoords = save_ecoords;
	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct glx_vars *)dmp->dm_vars)->omx = mx;
	((struct glx_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      if(mged_variables->rateknobs)
	bu_vls_printf(&cmd, "knob -i -v x %lf y %lf\n",
		      dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
		      dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
      else
	bu_vls_printf(&cmd, "knob -i -v ax %lf ay %lf\n",
		      dy * 0.25, dx * 0.25);

      break;
    case AMM_TRAN:
      fx = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      fy = -dy / (fastf_t)dmp->dm_height * 2.0;
      
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	char save_ecoords;

	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}

	if(mged_variables->rateknobs)
	  bu_vls_printf(&cmd, "knob -i X %lf Y %lf\n", fx, fy);
	else
	  bu_vls_printf(&cmd, "knob -i aX %lf aY %lf\n",
			fx*Viewscale*base2local, fy*Viewscale*base2local);

	(void)Tcl_Eval(interp, bu_vls_addr(&cmd));

	mged_variables->ecoords = save_ecoords;
	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct glx_vars *)dmp->dm_vars)->omx = mx;
	((struct glx_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      /* otherwise, drag to translate the view */
      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i -v X %lf Y %lf\n", fx, fy );
      else
	bu_vls_printf( &cmd, "knob -i -v aX %lf aY %lf\n",
		       fx*Viewscale*base2local, fy*Viewscale*base2local );

      break;
    case AMM_SCALE:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_SCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_ADC_ANG1:
      fx = dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc;
      bu_vls_printf(&cmd, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));

      break;
    case AMM_ADC_ANG2:
      fx = dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc;
      bu_vls_printf(&cmd, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));

      break;
    case AMM_ADC_TRAN:
      bu_vls_printf(&cmd, "adc hv %lf %lf\n",
		    dm_Xx2Normal(dmp, mx, 1) * Viewscale * base2local,
		    dm_Xy2Normal(dmp, my) * Viewscale * base2local);

      break;
    case AMM_ADC_DIST:
      fx = (dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc) * Viewscale * base2local / 2047.0;
      td = sqrt(fx * fx + fy * fy);
      bu_vls_printf(&cmd, "adc dst %lf\n", td);

      break;
    case AMM_CON_ROT_X:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i x %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i ax %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct glx_vars *)dmp->dm_vars)->omx = mx;
	((struct glx_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      break;
    case AMM_CON_ROT_Y:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i y %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i ay %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct glx_vars *)dmp->dm_vars)->omx = mx;
	((struct glx_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      break;
    case AMM_CON_ROT_Z:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i z %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i az %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct glx_vars *)dmp->dm_vars)->omx = mx;
	((struct glx_vars *)dmp->dm_vars)->omy = my;
	goto handled;
      }

      break;
    case AMM_CON_TRAN_X:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_X;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i X %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aX %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_TRAN_Y:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_Y;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i Y %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aY %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_TRAN_Z:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i Z %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aZ %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_SCALE_X:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_XSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_SCALE_Y:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_YSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_SCALE_Z:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_ZSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_XADC:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i xadc %f\n",
		     f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0 );
      break;
    case AMM_CON_YADC:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i yadc %f\n",
		     f / (fastf_t)dmp->dm_height * 4095.0 );

      break;
    case AMM_CON_ANG1:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i ang1 %f\n",
		     f / (fastf_t)dmp->dm_width * 90.0 );

      break;
    case AMM_CON_ANG2:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i ang2 %f\n",
		     f / (fastf_t)dmp->dm_width * 90.0 );

      break;
    case AMM_CON_DIST:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i distadc %f\n",
		     f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0 );

      break;
    }

    ((struct glx_vars *)dmp->dm_vars)->omx = mx;
    ((struct glx_vars *)dmp->dm_vars)->omy = my;
  }
#if IR_KNOBS
  else if( eventPtr->type == ((struct glx_vars *)dmp->dm_vars)->devmotionnotify ){
    XDeviceMotionEvent *M;
    int setting;
    fastf_t f;

    M = (XDeviceMotionEvent * ) eventPtr;

    if(button0){
      Glx_dbtext(
		(mged_variables->adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
      goto handled;
    }

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(mged_variables->adcflag) {
	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_1adc )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_1adc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob ang1 %f\n",
		       45.0 - 45.0*((double)setting)/2047.0);
      }else{
	if(mged_variables->rateknobs){
	  f = rate_model_rotate[Z];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	       M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob -m z %f\n", setting / 512.0 );
	}else{
	  f = absolute_model_rotate[Z];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob -m az %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL1:
      if(mged_variables->rateknobs){
	if(EDIT_SCALE && mged_variables->transform == 'e')
	  f = edit_rate_scale;
	else
	  f = rate_scale;

	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob S %f\n", setting / 512.0 );
      }else{
	if(EDIT_SCALE && mged_variables->transform == 'e')
	  f = edit_absolute_scale;
	else
	  f = absolute_scale;

	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob aS %f\n", setting / 512.0 );
      }
      break;
    case DIAL2:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_2adc )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_2adc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob ang2 %f\n",
		       45.0 - 45.0*((double)setting)/2047.0);
      }else {
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	      f = edit_rate_model_rotate[Z];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[Z];
	  else
	    f = rate_rotate[Z];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob z %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	      f = edit_absolute_model_rotate[Z];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[Z];
	  else
	    f = absolute_rotate[Z];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob az %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL3:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_distadc)
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_distadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob distadc %d\n", setting );
      }else {
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	    case 'o':
	      f = edit_rate_model_tran[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_tran[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_tran[Z];
	  else
	    f = rate_tran[Z];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob Z %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	    case 'o':
	      f = edit_absolute_model_tran[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_tran[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_tran[Z];
	  else
	    f = absolute_tran[Z];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf(&cmd, "knob aZ %f\n", setting / 512.0 * Viewscale * base2local);
	}
      }
      break;
    case DIAL4:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_yadc)
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_yadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob yadc %d\n", setting );
      }else{
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	      f = edit_rate_model_rotate[Y];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[Y];
	  else
	    f = rate_rotate[Y];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob y %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	      f = edit_absolute_model_rotate[Y];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[Y];
	  else
	    f = absolute_rotate[Y];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob ay %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL5:
      if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	    case 'o':
	      f = edit_rate_model_tran[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_tran[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_tran[Y];
	  else
	    f = rate_tran[Y];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob Y %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->ecoords){
	  case 'm':
	  case 'o':
	    f = edit_absolute_model_tran[Y];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_tran[Y];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_tran[Y];
	else
	  f = absolute_tran[Y];

	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] -
	    knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf(&cmd, "knob aY %f\n", setting / 512.0 * Viewscale * base2local);
      }
      break;
    case DIAL6:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_xadc)
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_xadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob xadc %d\n", setting );
      }else{
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	      f = edit_rate_model_rotate[X];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[X];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[X];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[X];
	  else
	    f = rate_rotate[X];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob x %f\n", setting / 512.0);
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->ecoords){
	    case 'm':
	      f = edit_absolute_model_rotate[X];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[X];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[X];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[X];
	  else
	    f = absolute_rotate[X];

	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob ax %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL7:
      if(mged_variables->rateknobs){
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->ecoords){
	  case 'm':
	  case 'o':
	    f = edit_rate_model_tran[X];
	    break;
	  case 'v':
	  default:
	    f = edit_rate_view_tran[X];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = rate_model_tran[X];
	else
	  f = rate_tran[X];

	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob X %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->ecoords){
	  case 'm':
	  case 'o':
	    f = edit_absolute_model_tran[X];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_tran[X];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_tran[X];
	else
	  f = absolute_tran[X];

	if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf(&cmd, "knob aX %f\n", setting / 512.0 * Viewscale * base2local);
      }
      break;
    default:
      break;
    }

    /* Keep track of the knob values */
    knob_values[M->first_axis] = M->axis_data[0];
  }
#endif
#if IR_BUTTONS
  else if( eventPtr->type == ((struct glx_vars *)dmp->dm_vars)->devbuttonpress ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      button0 = 1;
      goto handled;
    }

    if(button0){
      Glx_dbtext(label_button(bmap[B->button - 1]));
    }else if(B->button == 4){
      bu_vls_strcat(&cmd, "knob zero\n");
      set_knob_offset();
    }else
      bu_vls_printf(&cmd, "press %s\n",
		    label_button(bmap[B->button - 1]));
  }else if( eventPtr->type == ((struct glx_vars *)dmp->dm_vars)->devbuttonrelease ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1)
      button0 = 0;

    goto handled;
  }
#endif
  else if(eventPtr->type == KeyPress){
    /*XXX Hack to prevent Tk from choking on certain control sequences */
    if(eventPtr->xkey.state & ControlMask){
      char buffer[1];
      KeySym keysym;

      XLookupString(&(eventPtr->xkey), buffer, 1,
		    &keysym, (XComposeStatus *)NULL);

      if(keysym == XK_c || keysym == XK_t || keysym == XK_v ||
	 keysym == XK_w || keysym == XK_x || keysym == XK_y)
	goto handled;
    }

    /* let other KeyPress events get processed by Tcl/Tk */
    goto not_handled;
  }else{
    /* allow all other events to be handled by Tcl/Tk */
    goto not_handled;
  }

  (void)Tcl_Eval(interp, bu_vls_addr(&cmd));
  if(save_edflag != -1){
    if(SEDIT_TRAN || SEDIT_ROTATE || SEDIT_SCALE)
      es_edflag = save_edflag;
    else if(OEDIT_TRAN || OEDIT_ROTATE || OEDIT_SCALE)
      edobj = save_edflag;
  }

handled:
  bu_vls_free(&cmd);

  /* event handled here; prevent someone else from handling the event */
  return TCL_RETURN;

not_handled:
  bu_vls_free(&cmd);

  /* let someone else handle the event */
  return TCL_OK;
}

static void
Glx_statechange( a, b )
{
  if( ((struct glx_vars *)dmp->dm_vars)->mvars.debug ){
    struct bu_vls tmp_vls;

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "statechange %d %d\n", a, b );
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }

  /*
   *  Based upon new state, possibly do extra stuff,
   *  including enabling continuous tablet tracking,
   *  object highlighting
   */
 	switch( b )  {
	case ST_VIEW:
	  /* constant tracking OFF */
	  GlxdoMotion = 0;
	  break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	case ST_S_VPICK:
	  /* constant tracking ON */
	  GlxdoMotion = 1;
	  break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	  /* constant tracking OFF */
	  GlxdoMotion = 0;
	  break;
	default:
	  Tcl_AppendResult(interp, "Glx_statechange: unknown state ",
			   state_str[b], "\n", (char *)NULL);
	  break;
	}

#if 0
	Glx_viewchange( dmp, DM_CHGV_REDO, SOLID_NULL );
#endif

	++dmaflag;
}

/*
 *			G L X _ D M
 * 
 *  Implement display-manager specific commands, from MGED "dm" command.
 */
static int
Glx_dm(argc, argv)
int	argc;
char	**argv;
{
  struct bu_vls	vls;
  int status;
  char *av[6];
  char xstr[32];
  char ystr[32];

  if( !strcmp( argv[0], "set" )){
    struct bu_vls tmp_vls;

    bu_vls_init(&vls);
    bu_vls_init(&tmp_vls);
    start_catching_output(&tmp_vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      bu_struct_print("dm_4d internal variables", Glx_vparse, (CONST char *)&((struct glx_vars *)dmp->dm_vars)->mvars );
    } else if( argc == 2 ) {
      bu_vls_struct_item_named( &vls, Glx_vparse, argv[1], (CONST char *)&((struct glx_vars *)dmp->dm_vars)->mvars, ',');
      bu_log( "%s\n", bu_vls_addr(&vls) );
    } else {
      bu_vls_printf( &vls, "%s=\"", argv[1] );
      bu_vls_from_argv( &vls, argc-2, argv+2 );
      bu_vls_putc( &vls, '\"' );
      bu_struct_parse( &vls, Glx_vparse, (char *)&((struct glx_vars *)dmp->dm_vars)->mvars);
    }

    bu_vls_free(&vls);

    stop_catching_output(&tmp_vls);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
    return TCL_OK;
  }

  if(!strcmp(argv[0], "idle")){
    am_mode = AMM_IDLE;
    return TCL_OK;
  }

  if( !strcmp( argv[0], "m" )){
    scroll_active = 0;

    if( argc < 4){
      Tcl_AppendResult(interp, "dm m: need more parameters\n",
		       "m button xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    /* This assumes a 3-button mouse */
    switch(*argv[1]){
    case '1':
      ((struct glx_vars *)dmp->dm_vars)->mb_mask = Button1Mask;
      break;
    case '2':
      ((struct glx_vars *)dmp->dm_vars)->mb_mask = Button2Mask;
      break;
    case '3':
      ((struct glx_vars *)dmp->dm_vars)->mb_mask = Button3Mask;
      break;
    default:
      Tcl_AppendResult(interp, "dm m: bad button value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    {
      int x;
      int y;
      int old_orig_gui;
      int stolen = 0;

      old_orig_gui = mged_variables->orig_gui;

      x = dm_Xx2Normal(dmp, atoi(argv[2]), 0) * 2047.0;
      y = dm_Xy2Normal(dmp, atoi(argv[3])) * 2047.0;

      if(mged_variables->faceplate &&
	 mged_variables->orig_gui){
#define        MENUXLIM        (-1250)
	if(scroll_active){
	  stolen = 1;
	  goto end;
	}

	if(x >= MENUXLIM && scroll_select( x, y, 0 )){
	  stolen = 1;
	  goto end;
	}

	if(x < MENUXLIM && mmenu_select( y, 0)){
	  stolen = 1;
	  goto end;
	}
      }

      x = dm_Xx2Normal(dmp, atoi(argv[2]), 1) * 2047.0;
      mged_variables->orig_gui = 0;
end:
      bu_vls_init(&vls);
      if(mged_variables->mouse_behavior == 'n' && !stolen){
	point_t view_pt;
	point_t model_pt;
	fastf_t sf = 1.0/2047.0;

	VSET(view_pt, x, y, 2047.0);
	VSCALE(view_pt, view_pt, sf);
	MAT4X3PNT(model_pt, view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);
	if(*zclip_ptr)
	  bu_vls_printf(&vls, "nirt %lf %lf %lf",
			model_pt[X], model_pt[Y], model_pt[Z]);
	else
	  bu_vls_printf(&vls, "nirt -b %lf %lf %lf",
			model_pt[X], model_pt[Y], model_pt[Z]);
      }else
	bu_vls_printf(&vls, "M 1 %d %d", x, y);

      status = Tcl_Eval(interp, bu_vls_addr(&vls));
      mged_variables->orig_gui = old_orig_gui;
      bu_vls_free(&vls);

      return status;
    }
  }

  status = TCL_OK;
  if( !strcmp( argv[0], "am" )){
    scroll_active = 0;
    
    if( argc < 4){
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "am <r|t|s> xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct glx_vars *)dmp->dm_vars)->omx = atoi(argv[2]);
    ((struct glx_vars *)dmp->dm_vars)->omy = atoi(argv[3]);

    switch(*argv[1]){
    case 'r':
      am_mode = AMM_ROT;
      break;
    case 't':
      am_mode = AMM_TRAN;
      if(EDIT_TRAN && mged_variables->transform == 'e'){
	char save_ecoords;
	point_t mouse_view_pos;
	point_t ea_view_pos;
	point_t diff;

	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';

	MAT4X3PNT(ea_view_pos, model2view, e_axes_pos);
	mouse_view_pos[X] = dm_Xx2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1);
	mouse_view_pos[Y] = dm_Xy2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy);
	mouse_view_pos[Z] = ea_view_pos[Z];
	VSUB2(diff, mouse_view_pos, ea_view_pos);
	VSCALE(diff, diff, Viewscale * base2local);

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob aX %lf aY %lf\n", diff[X], diff[Y]);
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	mged_variables->ecoords = save_ecoords;
      }

      break;
    case 's':
      if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	 NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	acc_sc_sol = 1.0;
      else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	edit_absolute_scale = acc_sc_obj - 1.0;
	if(edit_absolute_scale > 0.0)
	  edit_absolute_scale /= 3.0;
      }

      am_mode = AMM_SCALE;
      break;
    default:
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "am <r|t|s> xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "adc")){
    fastf_t fx, fy;
    fastf_t td; /* tick distance */

    scroll_active = 0;

    if(argc < 4){
      Tcl_AppendResult(interp, "dm adc: need more parameters\n",
		       "dm adc 1|2|t|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct glx_vars *)dmp->dm_vars)->omx = atoi(argv[2]);
    ((struct glx_vars *)dmp->dm_vars)->omy = atoi(argv[3]);

    switch(*argv[1]){
    case '1':
      fx = dm_Xx2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_ANG1;
      break;
    case '2':
      fx = dm_Xx2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_ANG2;
      break;
    case 't':
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc hv %lf %lf\n",
		    dm_Xx2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) *
		    Viewscale * base2local,
		    dm_Xy2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) *
		    Viewscale * base2local);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_TRAN;
      break;
    case 'd':
      fx = (dm_Xx2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
	    dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Xy2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 -
	    dv_yadc) * Viewscale * base2local / 2047.0;
      td = sqrt(fx * fx + fy * fy);
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc dst %lf\n", td);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_DIST;
      break;
    default:
      Tcl_AppendResult(interp, "dm adc: unrecognized parameter - ", argv[1],
		       "\ndm adc 1|2|t|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "con")){
    scroll_active = 0;

    if(argc < 5){
      Tcl_AppendResult(interp, "dm con: need more parameters\n",
		       "dm con r|t|s x|y|z xpos ypos\n",
		       "dm con a x|y|1|2|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct glx_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct glx_vars *)dmp->dm_vars)->omy = atoi(argv[4]);

    switch(*argv[1]){
    case 'a':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_XADC;
	break;
      case 'y':
	am_mode = AMM_CON_YADC;
	break;
      case '1':
	am_mode = AMM_CON_ANG1;
	break;
      case '2':
	am_mode = AMM_CON_ANG2;
	break;
      case 'd':
	am_mode = AMM_CON_DIST;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con a x|y|1|2|d xpos ypos\n", (char *)NULL);
      }
      break;
    case 'r':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_ROT_X;
	break;
      case 'y':
	am_mode = AMM_CON_ROT_Y;
	break;
      case 'z':
	am_mode = AMM_CON_ROT_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    case 't':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_TRAN_X;
	break;
      case 'y':
	am_mode = AMM_CON_TRAN_Y;
	break;
      case 'z':
	am_mode = AMM_CON_TRAN_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    case 's':
      switch(*argv[2]){
      case 'x':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[0] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_X;
	break;
      case 'y':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[1] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_Y;
	break;
      case 'z':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[2] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    default:
      Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[1],
		       "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if( !strcmp( argv[0], "size" )){
    int width, height;

    /* get the window size */
    if( argc == 1 ){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d", dmp->dm_width, dmp->dm_height);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }

    /* set the window size */
    if( argc == 3 ){
      width = atoi( argv[1] );
      height = atoi( argv[2] );

      Tk_GeometryRequest(((struct glx_vars *)dmp->dm_vars)->xtkwin, width, height);

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "Usage: dm size [width height]\n", (char *)NULL);
    return TCL_ERROR;
  }

  Tcl_AppendResult(interp, "dm: bad command - ", argv[0], "\n", (char *)NULL);
  return TCL_ERROR;
}

/*
 *  I R _ D B T E X T
 *
 *  Used to call dbtext to print cute messages on the button box,
 *  if you have one.  Has to shift everythign to upper case
 *  since the box goes off the deep end with lower case.
 *
 *  Because not all SGI button boxes have text displays,
 *  this now needs to go to stdout in order to be useful.
 */

static void
Glx_dbtext(str)
register char *str;
{
#if IR_BUTTONS
	register i;
	char	buf[9];
	register char *cp;

	Tcl_AppendResult(interp, "dm-glx: You pressed Help key and '",
			 str, "'\n", (char *)NULL);
#else
	return;
#endif
}

static void
Glx_colorchange()
{
  color_soltab();
  if(((struct glx_vars *)dmp->dm_vars)->mvars.cueing_on) {
    depthcue(1);
  } else {
    depthcue(0);
  }

  ++dmaflag;
}

static void
establish_zbuffer()
{
  dm_zbuffer(dmp);
  ++dmaflag;
}

static void
establish_lighting()
{
  dm_lighting(dmp);
  ++dmaflag;
}

static void
dirty_hook()
{
  dirty = 1;
}

static void
set_knob_offset()
{
  int i;

  for(i = 0; i < 8; ++i)
    ((struct glx_vars *)dmp->dm_vars)->knobs[i] = 0;
}
@


1.70
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.69 1997/12/23 14:08:52 bparker Exp bparker $ (BRL)";
@


1.69
log
@call nirt from Glx_dm()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.68 1997/11/14 15:11:09 bparker Exp bparker $ (BRL)";
a54 1
#include "./mged_solid.h"
d248 2
a249 2
		       (int)(dm_X2Normal(dmp, mx, 0) * 2047.0),
		       (int)(dm_Y2Normal(dmp, my) * 2047.0) );
d254 2
a255 2
		       (int)(dm_X2Normal(dmp, mx, 1) * 2047.0),
		       (int)(dm_Y2Normal(dmp, my) * 2047.0) );
d378 2
a379 2
      fx = dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc;
d384 2
a385 2
      fx = dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc;
d391 2
a392 2
		    dm_X2Normal(dmp, mx, 1) * Viewscale * base2local,
		    dm_Y2Normal(dmp, my) * Viewscale * base2local);
d396 2
a397 2
      fx = (dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc) * Viewscale * base2local / 2047.0;
d1557 2
a1558 2
      x = dm_X2Normal(dmp, atoi(argv[2]), 0) * 2047.0;
      y = dm_Y2Normal(dmp, atoi(argv[3])) * 2047.0;
d1579 1
a1579 1
      x = dm_X2Normal(dmp, atoi(argv[2]), 1) * 2047.0;
d1583 1
a1583 1
      if(mged_variables->mouse_nirt && !stolen){
d1638 2
a1639 2
	mouse_view_pos[X] = dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1);
	mouse_view_pos[Y] = dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy);
d1690 2
a1691 2
      fx = dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
d1700 2
a1701 2
      fx = dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
d1712 1
a1712 1
		    dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) *
d1714 1
a1714 1
		    dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) *
d1722 1
a1722 1
      fx = (dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
d1724 1
a1724 1
      fy = (dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 -
@


1.68
log
@*- move perspective stuff to set.c
*- mods to reflect name changes in LIBDM
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.67 1997/11/06 20:02:27 bparker Exp bparker $ (BRL)";
d164 1
d197 1
d205 3
a209 2
    bu_vls_free(&cmd);

d1554 1
d1564 2
a1565 1
	if(scroll_active)
d1567 1
d1569 2
a1570 1
	if(x >= MENUXLIM && scroll_select( x, y, 0 ))
d1572 1
d1574 2
a1575 1
	if(x < MENUXLIM && mmenu_select( y, 0))
d1577 1
d1584 18
a1601 1
      bu_vls_printf(&vls, "M 1 %d %d", x, y);
@


1.67
log
@use new mged variable: ecoords
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.66 1997/10/27 19:22:05 bparker Exp bparker $ (BRL)";
a69 2
static void     establish_perspective();
static void     set_perspective();
a77 2
	{"%d",  1, "perspective",       Glx_MV_O(perspective_mode), establish_perspective },
	{"%d",  1, "set_perspective",Glx_MV_O(dummy_perspective),  set_perspective },
d167 1
a167 1
  glx_configure_window_shape(dmp);
d213 1
a213 1
    glx_clear_to_black(dmp);
d218 1
a218 1
    glx_configure_window_shape(dmp);
d1916 1
a1916 1
  glx_establish_zbuffer(dmp);
d1923 1
a1923 16
  glx_establish_lighting(dmp);
  color_soltab();
  ++dmaflag;
}

static void
establish_perspective()
{
  glx_establish_perspective(dmp);
  ++dmaflag;
}

static void
set_perspective()
{
  glx_set_perspective(dmp);
@


1.66
log
@mods to Glx_dm()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.65 1997/10/10 21:08:01 bparker Exp bparker $ (BRL)";
d265 1
a265 1
	char save_coords;
d267 2
a268 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d289 1
a289 1
	mged_variables->coords = save_coords;
d315 1
a315 1
	char save_coords;
d317 2
a318 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d337 1
a337 1
	mged_variables->coords = save_coords;
d824 1
a824 1
	    switch(mged_variables->coords){
d864 1
a864 1
	    switch(mged_variables->coords){
d921 1
a921 1
	    switch(mged_variables->coords){
d959 1
a959 1
	    switch(mged_variables->coords){
d1014 1
a1014 1
	    switch(mged_variables->coords){
d1054 1
a1054 1
	    switch(mged_variables->coords){
d1098 1
a1098 1
	    switch(mged_variables->coords){
d1136 1
a1136 1
	  switch(mged_variables->coords){
d1191 1
a1191 1
	    switch(mged_variables->coords){
d1231 1
a1231 1
	    switch(mged_variables->coords){
d1275 1
a1275 1
	  switch(mged_variables->coords){
d1313 1
a1313 1
	  switch(mged_variables->coords){
d1607 1
a1607 1
	char save_coords;
d1612 2
a1613 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d1626 1
a1626 1
	mged_variables->coords = save_coords;
d1913 1
a1913 3
#if 0
  dmp->dm_colorchange(dmp);
#endif
@


1.65
log
@set dirty instead of dmaflag when toggling zclipping
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.64 1997/10/10 16:58:35 bparker Exp bparker $ (BRL)";
d1521 5
d1529 1
a1529 1
    if( argc < 5){
d1531 1
a1531 1
		       "m button 1|0 xpos ypos\n", (char *)NULL);
d1558 2
a1559 2
      x = dm_X2Normal(dmp, atoi(argv[3]), 0) * 2047.0;
      y = dm_Y2Normal(dmp, atoi(argv[4])) * 2047.0;
d1562 1
a1562 2
	 mged_variables->orig_gui &&
	 *argv[2] == '1'){
d1565 1
a1565 1
	   goto end;
d1574 1
a1574 1
      x = dm_X2Normal(dmp, atoi(argv[3]), 1) * 2047.0;
d1578 1
a1578 1
      bu_vls_printf(&vls, "M %s %d %d", argv[2], x, y);
a1588 2
    int buttonpress;

d1591 1
a1591 1
    if( argc < 5){
d1593 1
a1593 1
		       "am <r|t|s> 1|0 xpos ypos\n", (char *)NULL);
d1597 17
a1613 3
    buttonpress = atoi(argv[2]);
    ((struct glx_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct glx_vars *)dmp->dm_vars)->omy = atoi(argv[4]);
d1615 6
a1620 36
    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	am_mode = AMM_ROT;
	break;
      case 't':
	am_mode = AMM_TRAN;
	if(EDIT_TRAN && mged_variables->transform == 'e'){
	  char save_coords;
	  point_t mouse_view_pos;
	  point_t ea_view_pos;
	  point_t diff;

	  save_coords = mged_variables->coords;
	  mged_variables->coords = 'v';

	  MAT4X3PNT(ea_view_pos, model2view, e_axes_pos);
#if 1
	  mouse_view_pos[X] = dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1);
	  mouse_view_pos[Y] = dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy);
#else
	  mouse_view_pos[X] = (((struct glx_vars *)dmp->dm_vars)->omx /
			       (fastf_t)dmp->dm_width - 0.5) / dmp->dm_aspect * 2.0;
	  mouse_view_pos[Y] = (0.5 - ((struct glx_vars *)dmp->dm_vars)->omy /
			       (fastf_t)dmp->dm_height) * 2.0;
#endif
	  mouse_view_pos[Z] = ea_view_pos[Z];
	  VSUB2(diff, mouse_view_pos, ea_view_pos);
	  VSCALE(diff, diff, Viewscale * base2local);

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "knob aX %lf aY %lf\n", diff[X], diff[Y]);
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  mged_variables->coords = save_coords;
	}
d1622 6
a1627 10
	break;
      case 's':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc_obj - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}
d1629 9
a1637 6
	am_mode = AMM_SCALE;
	break;
      default:
	Tcl_AppendResult(interp, "dm am: need more parameters\n",
			 "am <r|t|s> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
d1640 6
a1645 1
      return TCL_OK;
d1648 1
a1648 2
    am_mode = AMM_IDLE;
    return status;
a1651 1
    int buttonpress;
d1657 1
a1657 1
    if(argc < 5){
d1659 1
a1659 1
		       "dm adc 1|2|t|d 1|0 xpos ypos\n", (char *)NULL);
d1663 2
a1664 13
    buttonpress = atoi(argv[2]);
    ((struct glx_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct glx_vars *)dmp->dm_vars)->omy = atoi(argv[4]);

    if(buttonpress){
      switch(*argv[1]){
      case '1':
	fx = dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
	fy = dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1666 8
a1673 9
	am_mode = AMM_ADC_ANG1;
	break;
      case '2':
	fx = dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
	fy = dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1675 9
a1683 11
	am_mode = AMM_ADC_ANG2;
	break;
      case 't':
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc hv %lf %lf\n",
		      dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) *
		      Viewscale * base2local,
		      dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) *
		      Viewscale * base2local);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1685 11
a1695 12
	am_mode = AMM_ADC_TRAN;
	break;
      case 'd':
	fx = (dm_X2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
	      dv_xadc) * Viewscale * base2local / 2047.0;
	fy = (dm_Y2Normal(dmp, ((struct glx_vars *)dmp->dm_vars)->omy) * 2047.0 -
	      dv_yadc) * Viewscale * base2local / 2047.0;
	td = sqrt(fx * fx + fy * fy);
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc dst %lf\n", td);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1697 12
a1708 7
	am_mode = AMM_ADC_DIST;
	break;
      default:
	Tcl_AppendResult(interp, "dm adc: unrecognized parameter - ", argv[1],
			  "\ndm adc 1|2|t|d 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
d1710 6
a1715 1
      return TCL_OK;
a1717 1
    am_mode = AMM_IDLE;
a1721 2
    int buttonpress;

d1724 1
a1724 1
    if(argc < 6){
d1726 2
a1727 2
		       "dm con r|t|s x|y|z 1|0 xpos ypos\n",
		       "dm con a x|y|1|2|d 1|0 xpos ypos\n", (char *)NULL);
d1731 70
a1800 26
    buttonpress = atoi(argv[3]);
    ((struct glx_vars *)dmp->dm_vars)->omx = atoi(argv[4]);
    ((struct glx_vars *)dmp->dm_vars)->omy = atoi(argv[5]);

    if(buttonpress){
      switch(*argv[1]){
      case 'a':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_XADC;
	  break;
	case 'y':
	  am_mode = AMM_CON_YADC;
	  break;
	case '1':
	  am_mode = AMM_CON_ANG1;
	  break;
	case '2':
	  am_mode = AMM_CON_ANG2;
	  break;
	case 'd':
	  am_mode = AMM_CON_DIST;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			   "\ndm con a x|y|1|2|d 1|0 xpos ypos\n", (char *)NULL);
d1802 2
d1805 8
a1812 15
      case 'r':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_ROT_X;
	  break;
	case 'y':
	  am_mode = AMM_CON_ROT_Y;
	  break;
	case 'z':
	  am_mode = AMM_CON_ROT_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
d1814 2
d1817 8
a1824 15
      case 't':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_TRAN_X;
	  break;
	case 'y':
	  am_mode = AMM_CON_TRAN_Y;
	  break;
	case 'z':
	  am_mode = AMM_CON_TRAN_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
a1825 36
	break;
      case 's':
	switch(*argv[2]){
	case 'x':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[0] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }

	  am_mode = AMM_CON_SCALE_X;
	  break;
	case 'y':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[1] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }

	  am_mode = AMM_CON_SCALE_Y;
	  break;
	case 'z':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[2] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }
d1827 1
a1827 7
	  am_mode = AMM_CON_SCALE_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
	}
d1830 2
a1831 2
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[1],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1834 5
a1838 2

      return TCL_OK;
a1840 1
    am_mode = AMM_IDLE;
d1847 10
a1856 3
    if( argc < 3 ){
      Tcl_AppendResult(interp, "Usage: dm size width height\n", (char *)NULL);
      return TCL_ERROR;
d1859 4
a1862 2
    width = atoi( argv[1] );
    height = atoi( argv[2] );
d1864 1
a1864 1
    Tk_GeometryRequest(((struct glx_vars *)dmp->dm_vars)->xtkwin, width, height);
d1866 5
a1870 1
    return TCL_OK;
@


1.64
log
@*- mods to Glx_doevent
*- *- mods to support using only one registered event handler within MGED
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.63 1997/09/08 18:52:49 bparker Exp bparker $ (BRL)";
d72 1
a72 1
static void     refresh_hook();
d77 1
a77 1
	{"%d",  1, "zclip",		Glx_MV_O(zclipping_on),	refresh_hook },
d1962 1
a1962 1
refresh_hook()
d1964 1
a1964 1
  dmaflag = 1;
@


1.63
log
@mged_variables is now a pointer
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.62 1997/09/03 14:33:57 bparker Exp bparker $ (BRL)";
d161 2
a162 2
  Tk_DeleteGenericHandler(Glx_doevent, (ClientData)DM_TYPE_GLX);
  if((dmp = dm_open(DM_TYPE_GLX, DM_EVENT_HANDLER_NULL, argc+1, av)) == DM_NULL){
d168 1
a168 1
  dmp->dm_eventHandler = Glx_doevent;
d170 1
a170 1
  Tk_CreateGenericHandler(Glx_doevent, (ClientData)DM_TYPE_GLX);
d177 2
a178 1
   This routine does not handle mouse button or key events. The key
a191 3
  struct glx_vars *p;
  register struct dm_list *save_dm_list;
  int status = TCL_OK;
a193 12
  GET_DM(p, glx_vars, eventPtr->xany.window, &head_glx_vars.l);
  if(p == (struct glx_vars *)NULL || eventPtr->type == DestroyNotify)
    return TCL_OK;

  bu_vls_init(&cmd);
  save_dm_list = curr_dm_list;

  GET_DM_LIST(curr_dm_list, glx_vars, eventPtr->xany.window);

  if(curr_dm_list == DM_LIST_NULL)
    goto end;

d205 1
a205 1
      goto end;
a209 1
    curr_dm_list = save_dm_list;
d215 1
d218 1
d220 1
a220 2
    dirty = 1;
    goto end;
d223 1
d225 1
a225 2
    dirty = 1;
    goto end;
d228 2
a229 1
    goto end;
d232 2
a233 1
    goto end;
d259 1
a259 1
	goto end;
d297 1
a297 1
	goto end;
d345 1
a345 1
	goto end;
d436 1
a436 1
	goto end;
d472 1
a472 1
	goto end;
d508 1
a508 1
	goto end;
d715 1
a715 1
      goto end;
d1366 1
a1366 1
      goto end;
d1385 1
a1385 1
    goto end;
d1388 1
a1388 1
  else {
d1390 1
a1390 1
    if(eventPtr->type == KeyPress && eventPtr->xkey.state & ControlMask){
d1398 2
a1399 6
	 keysym == XK_w || keysym == XK_x || keysym == XK_y){
	bu_vls_free(&cmd);
	curr_dm_list = save_dm_list;

	return TCL_RETURN;
      }
d1402 5
a1406 1
    goto end;
d1409 1
a1409 1
  status = Tcl_Eval(interp, bu_vls_addr(&cmd));
d1416 2
a1417 1
end:
a1418 1
  curr_dm_list = save_dm_list;
d1420 8
a1427 1
  return status;
@


1.62
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.61 1997/08/01 21:15:02 bparker Exp bparker $ (BRL)";
d211 1
a211 1
  if(mged_variables.send_key && eventPtr->type == KeyPress){
d218 1
a218 1
    if(keysym == mged_variables.hot_key)
d276 1
a276 1
	 mged_variables.transform == 'e'){
d279 2
a280 2
	save_coords = mged_variables.coords;
	mged_variables.coords = 'v';
d291 1
a291 1
	if(mged_variables.rateknobs)
d301 1
a301 1
	mged_variables.coords = save_coords;
d312 1
a312 1
      if(mged_variables.rateknobs)
d326 1
a326 1
	 mged_variables.transform == 'e'){
d329 2
a330 2
	save_coords = mged_variables.coords;
	mged_variables.coords = 'v';
d341 1
a341 1
	if(mged_variables.rateknobs)
d349 1
a349 1
	mged_variables.coords = save_coords;
d361 1
a361 1
      if(mged_variables.rateknobs)
d370 1
a370 1
	 mged_variables.transform == 'e'){
d385 1
a385 1
      if(mged_variables.rateknobs)
d422 1
a422 1
      if(mged_variables.rateknobs)
d429 1
a429 1
	 mged_variables.transform == 'e'){
d458 1
a458 1
      if(mged_variables.rateknobs)
d465 1
a465 1
	 mged_variables.transform == 'e'){
d494 1
a494 1
      if(mged_variables.rateknobs)
d501 1
a501 1
	 mged_variables.transform == 'e'){
d526 1
a526 1
	 mged_variables.transform == 'e'){
d541 1
a541 1
      if(mged_variables.rateknobs)
d549 1
a549 1
	 mged_variables.transform == 'e'){
d564 1
a564 1
      if(mged_variables.rateknobs)
d572 1
a572 1
	 mged_variables.transform == 'e'){
d587 1
a587 1
      if(mged_variables.rateknobs)
d595 1
a595 1
	 mged_variables.transform == 'e'){
d610 1
a610 1
      if(mged_variables.rateknobs)
d618 1
a618 1
	 mged_variables.transform == 'e'){
d633 1
a633 1
      if(mged_variables.rateknobs)
d641 1
a641 1
	 mged_variables.transform == 'e'){
d656 1
a656 1
      if(mged_variables.rateknobs)
d726 1
a726 1
		(mged_variables.adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
d732 1
a732 1
      if(mged_variables.adcflag) {
d746 1
a746 1
	if(mged_variables.rateknobs){
d780 2
a781 2
      if(mged_variables.rateknobs){
	if(EDIT_SCALE && mged_variables.transform == 'e')
d799 1
a799 1
	if(EDIT_SCALE && mged_variables.transform == 'e')
d819 1
a819 1
      if(mged_variables.adcflag){
d833 1
a833 1
	if(mged_variables.rateknobs){
d835 2
a836 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d856 1
a856 1
	  }else if(mged_variables.coords == 'm')
d875 2
a876 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d896 1
a896 1
	  }else if(mged_variables.coords == 'm')
d917 1
a917 1
      if(mged_variables.adcflag){
d930 1
a930 1
	if(mged_variables.rateknobs){
d932 2
a933 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d951 1
a951 1
	  }else if(mged_variables.coords == 'm')
d970 2
a971 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d989 1
a989 1
	  }else if(mged_variables.coords == 'm')
d1010 1
a1010 1
      if(mged_variables.adcflag){
d1023 1
a1023 1
	if(mged_variables.rateknobs){
d1025 2
a1026 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1046 1
a1046 1
	  }else if(mged_variables.coords == 'm')
d1065 2
a1066 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1086 1
a1086 1
	  }else if(mged_variables.coords == 'm')
d1107 1
a1107 1
      if(mged_variables.rateknobs){
d1109 2
a1110 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1128 1
a1128 1
	  }else if(mged_variables.coords == 'm')
d1147 2
a1148 2
	   && mged_variables.transform == 'e'){
	  switch(mged_variables.coords){
d1166 1
a1166 1
	}else if(mged_variables.coords == 'm')
d1187 1
a1187 1
      if(mged_variables.adcflag){
d1200 1
a1200 1
	if(mged_variables.rateknobs){
d1202 2
a1203 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1223 1
a1223 1
	  }else if(mged_variables.coords == 'm')
d1242 2
a1243 2
	     && mged_variables.transform == 'e'){
	    switch(mged_variables.coords){
d1263 1
a1263 1
	  }else if(mged_variables.coords == 'm')
d1284 1
a1284 1
      if(mged_variables.rateknobs){
d1286 2
a1287 2
	   && mged_variables.transform == 'e'){
	  switch(mged_variables.coords){
d1305 1
a1305 1
	}else if(mged_variables.coords == 'm')
d1324 2
a1325 2
	   && mged_variables.transform == 'e'){
	  switch(mged_variables.coords){
d1343 1
a1343 1
	}else if(mged_variables.coords == 'm')
d1556 1
a1556 1
      old_orig_gui = mged_variables.orig_gui;
d1561 2
a1562 2
      if(mged_variables.faceplate &&
	 mged_variables.orig_gui &&
d1576 1
a1576 1
      mged_variables.orig_gui = 0;
d1581 1
a1581 1
      mged_variables.orig_gui = old_orig_gui;
d1611 1
a1611 1
	if(EDIT_TRAN && mged_variables.transform == 'e'){
d1617 2
a1618 2
	  save_coords = mged_variables.coords;
	  mged_variables.coords = 'v';
d1638 1
a1638 1
	  mged_variables.coords = save_coords;
d1643 1
a1643 1
	if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1646 1
a1646 1
	else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1821 1
a1821 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1824 1
a1824 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1833 1
a1833 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1836 1
a1836 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1845 1
a1845 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1848 1
a1848 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
@


1.61
log
@merge UI stuff from dm-ogl
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.60 1997/07/25 20:44:02 bparker Exp bparker $ (BRL)";
d262 2
a263 1
		       dm_X2Normal(dmp, mx, 0) * 2047.0, dm_Y2Normal(dmp, my) * 2047.0 );
d268 2
a269 1
		       dm_X2Normal(dmp, mx, 1) * 2047.0, dm_Y2Normal(dmp, my) * 2047.0 );
@


1.60
log
@copied dm-ogl's dial stuff
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.59 1997/05/29 14:18:01 bparker Exp bparker $ (BRL)";
d61 1
a188 1
  static int knobs_during_help[8] = {0, 0, 0, 0, 0, 0, 0, 0};
a189 1
  register struct dm_list *save_dm_list;
d192 1
a194 1
  fastf_t f;
d210 1
d212 1
a212 1
    char buffer[1];
d222 1
d230 1
a230 2
  /* Now getting X events */
  if(eventPtr->type == Expose && eventPtr->xexpose.count == 0){
d235 1
a235 2
  }else if( eventPtr->type == ConfigureNotify ){
    /* Window may have moved */
d246 1
a246 1
  }else if( eventPtr->type == MotionNotify ) {
d248 4
d255 2
d262 1
a262 1
		       glx_irisX2ged(dmp, mx, 0), glx_irisY2ged(dmp, my));
d267 2
a268 2
		       glx_irisX2ged(dmp, mx, 1), glx_irisY2ged(dmp, my));
      else
d273 45
a317 3
      bu_vls_printf( &cmd, "knob -i ax %f ay %f\n",
		     (my - ((struct glx_vars *)dmp->dm_vars)->omy) * 0.25,
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx) * 0.25 );
d320 26
a345 13
      if(EDIT_TRAN && mged_variables.transform == 'e'){
	vect_t view_pos;
#if 0
	view_pos[X] = (mx/(fastf_t)dmp->dm_width
		       - 0.5) * 2.0;
#else
	view_pos[X] = (mx /
		       (fastf_t)dmp->dm_width - 0.5) /
		       dmp->dm_aspect * 2.0;
#endif
	view_pos[Y] = (0.5 - my/
		       (fastf_t)dmp->dm_height) * 2.0;
	view_pos[Z] = 0.0;
d347 1
d349 1
a349 1
	  sedit_mouse(view_pos);
d351 1
a351 1
	  objedit_mouse(view_pos);
d353 2
d356 1
a356 2
      }else{
	fastf_t fx, fy;
d358 6
a363 10
#if 0
	fx = (mx - ((struct glx_vars *)dmp->dm_vars)->omx)/
	  (fastf_t)dmp->dm_width * 2.0;
#else
	fx = (mx - ((struct glx_vars *)dmp->dm_vars)->omx) /
             (fastf_t)dmp->dm_width /
	     dmp->dm_aspect * 2.0;
#endif
	fy = (((struct glx_vars *)dmp->dm_vars)->omy - my)/
	  (fastf_t)dmp->dm_height * 2.0;
d365 11
a375 1
	bu_vls_printf( &cmd, "knob -i aX %f aY %f\n", fx, fy );
d378 28
d407 6
a412 3
    case AMM_SCALE:
      bu_vls_printf( &cmd, "knob -i aS %f\n", (((struct glx_vars *)dmp->dm_vars)->omy - my)/
		     (fastf_t)dmp->dm_height);
d415 34
a448 2
      bu_vls_printf( &cmd, "knob -i ax %f\n",
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx) * 0.25 );
d451 34
a484 2
      bu_vls_printf( &cmd, "knob -i ay %f\n",
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx) * 0.25 );
d487 34
a520 2
      bu_vls_printf( &cmd, "knob -i az %f\n",
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx) * 0.25 );
d523 21
a543 3
      bu_vls_printf( &cmd, "knob -i aX %f\n",
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx) /
		     (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0 );
d546 21
a566 3
      bu_vls_printf( &cmd, "knob -i aY %f\n",
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx) /
		     (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0 );
d569 139
a707 3
      bu_vls_printf( &cmd, "knob -i aZ %f\n",
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx) /
		     (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0 );
a852 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a892 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a947 4
#if 0
	      save_movedir = movedir;
	      movedir = UARROW | RARROW;
#endif
a985 4
#if 0
	      save_movedir = movedir;
	      movedir = UARROW | RARROW;
#endif
a1042 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a1082 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a1124 4
#if 0
	      save_movedir = movedir;
	      movedir = UARROW | RARROW;
#endif
a1162 4
#if 0
	    save_movedir = movedir;
	    movedir = UARROW | RARROW;
#endif
a1219 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a1259 4
#if 0
	      save_movedir = movedir;
	      movedir = ROTARROW;
#endif
a1301 4
#if 0
	    save_movedir = movedir;
	    movedir = UARROW | RARROW;
#endif
a1339 4
#if 0
	    save_movedir = movedir;
	    movedir = UARROW | RARROW;
#endif
d1398 1
a1398 1
  else{
d1420 6
a1432 1

d1556 2
a1557 2
      x = glx_irisX2ged(dmp, atoi(argv[3]), 0);
      y = glx_irisY2ged(dmp, atoi(argv[4]));
d1573 1
a1573 1
      x = glx_irisX2ged(dmp, atoi(argv[3]), 1);
d1594 1
a1594 1
		       "am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d1610 12
a1621 6
	  vect_t view_pos;

#if 0
	  view_pos[X] = (((struct glx_vars *)dmp->dm_vars)->omx /
			 (fastf_t)dmp->dm_width -
			 0.5) * 2.0;
d1623 15
a1637 7
	  view_pos[X] = (((struct glx_vars *)dmp->dm_vars)->omx /
			(fastf_t)dmp->dm_width - 0.5) /
	                dmp->dm_aspect * 2.0;
#endif
	  view_pos[Y] = (0.5 - ((struct glx_vars *)dmp->dm_vars)->omy /
			 (fastf_t)dmp->dm_height) * 2.0;
	  view_pos[Z] = 0.0;
d1639 9
a1647 4
	  if(state == ST_S_EDIT)
	    sedit_mouse(view_pos);
	  else
	    objedit_mouse(view_pos);
a1649 2
	break;
      case 'z':
d1654 1
a1654 1
			 "am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d1657 3
a1659 2
    }else
      am_mode = AMM_IDLE;
d1661 1
d1665 77
d1747 1
a1747 1
    if( argc < 6){
d1749 2
a1750 1
		       "dm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1760 22
d1795 1
a1795 1
			 "\ndm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1812 45
a1856 1
			 "\ndm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1862 1
a1862 1
			 "\ndm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
@


1.59
log
@add azimuth knob
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.58 1997/05/22 19:19:07 bparker Exp bparker $ (BRL)";
a71 2
static void     set_linewidth();
static void     set_linestyle();
a74 2
	{"%d",  1, "linewidth",		Glx_MV_O(linewidth),	set_linewidth },
	{"%d",  1, "linestyle",		Glx_MV_O(linestyle),	set_linestyle },
d194 1
d254 1
a254 1
    case ALT_MOUSE_MODE_IDLE:
d267 1
a267 1
    case ALT_MOUSE_MODE_ROTATE:
d272 2
a273 2
    case ALT_MOUSE_MODE_TRANSLATE:
      if(EDIT_TRAN && mged_variables.edit){
d311 1
a311 1
    case ALT_MOUSE_MODE_ZOOM:
d315 27
d378 1
a378 1
	  f = rate_azimuth;
d391 1
a391 1
	  bu_vls_printf( &cmd, "knob azim %f\n", setting / 512.0 );
d393 1
a393 1
	  f = curr_dm_list->s_info->azimuth;
d403 1
a403 1
	       M->axis_data[0] - knob_values[M->first_axis];
d405 2
a406 2
	  f = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 1024.0;
	  bu_vls_printf( &cmd, "knob aazim %f\n", f * 360.0);
d412 1
a412 1
	if(EDIT_SCALE && mged_variables.edit)
d415 1
a415 1
	  f = rate_zoom;
d430 1
a430 1
	if(EDIT_SCALE && mged_variables.edit)
d433 1
a433 1
	  f = absolute_zoom;
d465 28
a492 2
	  if(EDIT_ROTATE && mged_variables.edit)
	    f = edit_rate_rotate[Z];
d509 28
a536 2
	  if(EDIT_ROTATE && mged_variables.edit)
	    f = edit_absolute_rotate[Z];
d570 26
a595 2
	  if(EDIT_TRAN && mged_variables.edit)
	    f = edit_rate_tran[Z];
d597 1
a597 1
	    f = rate_slew[Z];
d612 26
a637 2
	  if(EDIT_TRAN && mged_variables.edit)
	    f = edit_absolute_tran[Z];
d639 1
a639 1
	    f = absolute_slew[Z];
d652 1
a652 1
	  bu_vls_printf( &cmd, "knob aZ %f\n", setting / 512.0 );
d671 28
a698 2
	  if(EDIT_ROTATE && mged_variables.edit)
	    f = edit_rate_rotate[Y];
d715 28
a742 2
	  if(EDIT_ROTATE && mged_variables.edit)
	    f = edit_absolute_rotate[Y];
d763 26
a788 2
	  if(EDIT_TRAN && mged_variables.edit)
	    f = edit_rate_tran[Y];
d790 1
a790 1
	    f = rate_slew[Y];
d805 28
a832 4
	  if(EDIT_TRAN && mged_variables.edit)
	    f = edit_absolute_tran[Y];
	  else
	    f = absolute_slew[Y];
d834 10
a843 10
	  if(-NOISE <= ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] -
	      knob_values[M->first_axis];
	  else
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];
d845 2
a846 2
	  setting = dm_limit(((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob aY %f\n", setting / 512.0 );
d864 28
a891 2
	  if(EDIT_ROTATE && mged_variables.edit)
	    f = edit_rate_rotate[X];
d908 28
a935 2
	  if(EDIT_ROTATE && mged_variables.edit)
	    f = edit_absolute_rotate[X];
d956 26
a981 2
	if(EDIT_TRAN && mged_variables.edit)
	  f = edit_rate_tran[X];
d983 1
a983 1
	  f = rate_slew[X];
d998 26
a1023 2
	if(EDIT_TRAN && mged_variables.edit)
	  f = edit_absolute_tran[X];
d1025 1
a1025 1
	  f = absolute_slew[X];
d1038 1
a1038 1
	bu_vls_printf( &cmd, "knob aX %f\n", setting / 512.0 );
d1080 1
a1080 1
    /*XXX Hack to prevent Tk from choking on Ctrl-c */
d1088 2
a1089 1
      if(keysym == XK_c){
d1228 1
a1228 1
      int old_show_menu;
d1230 1
a1230 1
      old_show_menu = mged_variables.show_menu;
d1236 1
a1236 1
	 mged_variables.show_menu &&
d1250 1
a1250 1
      mged_variables.show_menu = 0;
d1255 1
a1255 1
      mged_variables.show_menu = old_show_menu;
d1281 1
a1281 1
	am_mode = ALT_MOUSE_MODE_ROTATE;
d1284 2
a1285 2
	am_mode = ALT_MOUSE_MODE_TRANSLATE;
	if(EDIT_TRAN && mged_variables.edit){
d1309 1
a1309 1
	am_mode = ALT_MOUSE_MODE_ZOOM;
d1317 1
a1317 1
      am_mode = ALT_MOUSE_MODE_IDLE;
d1322 64
a1473 18
  ++dmaflag;
}

static void
set_linewidth()
{
  dmp->dm_setLineAttr(dmp,
		      ((struct glx_vars *)dmp->dm_vars)->mvars.linewidth,
		      dmp->dm_lineStyle);
  ++dmaflag;
}

static void
set_linestyle()
{
  dmp->dm_setLineAttr(dmp,
		      dmp->dm_lineWidth,
		      ((struct glx_vars *)dmp->dm_vars)->mvars.linestyle);
@


1.58
log
@mods to the event handler
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.57 1997/05/21 12:50:05 bparker Exp bparker $ (BRL)";
d352 32
d471 1
a471 1
	      dm_unlimit((int)(2.85 * f)) +
d577 1
a577 1
	      dm_unlimit((int)(2.85 * f)) +
d670 1
a670 1
	      dm_unlimit((int)(2.85 * f)) +
@


1.57
log
@*- mods to Glx_dm_init
*- add set_linewidth() and set_linestyle()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.56 1997/05/08 14:36:51 bparker Exp bparker $ (BRL)";
d243 6
@


1.56
log
@*- changed Glx_ prefix to glx_
*- call generic dm_open
*- fixed bug in knob event handler
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.55 1997/03/20 22:14:58 bparker Exp bparker $ (BRL)";
d72 2
d77 2
a85 1
	{"%d",  1, "linewidth",		Glx_MV_O(linewidth),	refresh_hook },
d172 1
a172 1
  curr_dm_list->s_info->opp = &tkName;
d1047 18
@


1.55
log
@move default -i option to beginning of argv
@
text
@a1 23
   Just a note:

   These particular commands should not be used in
   mixed mode programming.

   qdevice
   blkqread
   qtest
   getbutton
   getvaluator
   setvaluator
   unqdevice
   mapcolor
   gconfig
   doublebuffer
   RGBmode
   winopen
   foreground
   noborder
   keepaspect
   prefposition
*/
/*
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.54 1997/03/07 21:38:12 bparker Exp bparker $ (BRL)";
d142 1
d148 9
a156 2
  for(i = argc-1; i-1; --i)
    argv[i] = argv[i-1];
d158 1
a158 2
  argv[0] = "-i";
  argv[1] = "mged_bind_dm";
d162 2
a163 1
  if((dmp = Glx_open(DM_EVENT_HANDLER_NULL, argc, argv)) == DM_NULL)
d165 1
d167 1
d171 1
a171 1
  Glx_configure_window_shape(dmp);
d231 1
a231 2
    /* Window may have moved */
    Glx_configure_window_shape(dmp);
d237 1
a237 1
    Glx_configure_window_shape(dmp);
d251 1
a251 1
		       Glx_irisX2ged(dmp, mx, 0), Glx_irisY2ged(dmp, my));
d256 1
a256 1
		       Glx_irisX2ged(dmp, mx, 1), Glx_irisY2ged(dmp, my));
d331 2
a332 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d352 2
a353 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d370 2
a371 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d386 2
a387 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d405 2
a406 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d423 2
a424 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d440 2
a441 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d458 2
a459 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d476 2
a477 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d493 2
a494 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d511 2
a512 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d529 2
a530 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d551 2
a552 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d569 2
a570 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d586 2
a587 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d604 2
a605 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d622 2
a623 2
	  if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d644 2
a645 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d662 2
a663 2
	if(-NOISE < ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE &&
d866 2
a867 2
      x = Glx_irisX2ged(dmp, atoi(argv[3]), 0);
      y = Glx_irisY2ged(dmp, atoi(argv[4]));
d883 1
a883 1
      x = Glx_irisX2ged(dmp, atoi(argv[3]), 1);
d1021 1
a1021 1
  Glx_establish_zbuffer(dmp);
d1028 1
a1028 1
  Glx_establish_lighting(dmp);
d1036 1
a1036 1
  Glx_establish_perspective(dmp);
d1043 1
a1043 1
  Glx_set_perspective(dmp);
@


1.54
log
@*** empty log message ***
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.53 1997/03/06 14:06:06 bparker Exp bparker $ (BRL)";
a164 2
#if 0
  char **av;
a165 17
  struct dm *glxdmp;

  /* register application provided routines */
  cmd_hook = Glx_dm;
  state_hook = Glx_statechange;

  av = (char **)bu_malloc(sizeof(char *) * (argc + 3), "Glx_dm_init: av");
  for(i = 0; i < argc; ++i)
    av[i] = argv[i];
  av[i + 1] = "-i";
  av[i + 2] = "mged_bind_dm";
  av[i + 3] = (char *)NULL;
  glxdmp = Glx_open(Glx_doevent, argc + 2, av);
  bu_free((genptr_t)av, "Glx_dm_init: av");

  return glxdmp;
#else
d170 2
a171 2
  for(i = 2; i < argc; ++i)
    argv[i-2] = argv[i-1];
d173 2
a174 2
  argv[i-2] = "-i";
  argv[i-1] = "mged_bind_dm";
a175 1
#if DO_NEW_LIBDM_OPEN
a186 5
#else
  dmp->dm_eventHandler = Glx_doevent;
  return Glx_open(dmp, argc, argv);
#endif
#endif
@


1.53
log
@fixed typo
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.52 1997/02/28 21:35:47 bparker Exp bparker $ (BRL)";
d60 1
d762 1
a762 1
      if(*buffer == 'c'){
@


1.52
log
@added dm size command
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.51 1997/02/24 22:08:02 bparker Exp bparker $ (BRL)";
d761 1
a761 1
      if(*buffer = 'c'){
@


1.51
log
@mods to Glx_doevent
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.50 1997/02/06 22:02:12 bparker Exp bparker $ (BRL)";
d992 16
@


1.50
log
@*-mods to use latest libdm
*-mods to accomadate non-square windows
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.49 1997/01/29 23:13:32 bparker Exp bparker $ (BRL)";
d201 1
a201 1
  curr_dm_list->s_info->opp = &pathName;
d203 1
d308 1
a308 1
	view_pos[X] = (mx/(fastf_t)((struct glx_vars *)dmp->dm_vars)->width
d312 2
a313 2
		       (fastf_t)((struct glx_vars *)dmp->dm_vars)->width - 0.5) /
		       ((struct glx_vars *)dmp->dm_vars)->aspect * 2.0;
d316 1
a316 1
		       (fastf_t)((struct glx_vars *)dmp->dm_vars)->height) * 2.0;
d330 1
a330 1
	  (fastf_t)((struct glx_vars *)dmp->dm_vars)->width * 2.0;
d333 2
a334 2
             (fastf_t)((struct glx_vars *)dmp->dm_vars)->width /
	     ((struct glx_vars *)dmp->dm_vars)->aspect * 2.0;
d337 1
a337 1
	  (fastf_t)((struct glx_vars *)dmp->dm_vars)->height * 2.0;
d345 1
a345 1
		     (fastf_t)((struct glx_vars *)dmp->dm_vars)->height);
d752 17
a768 1
  else
d770 1
d928 1
d962 1
a962 1
			 (fastf_t)((struct glx_vars *)dmp->dm_vars)->width -
d966 2
a967 2
			(fastf_t)((struct glx_vars *)dmp->dm_vars)->width - 0.5) /
	                ((struct glx_vars *)dmp->dm_vars)->aspect * 2.0;
d970 1
a970 1
			 (fastf_t)((struct glx_vars *)dmp->dm_vars)->height) * 2.0;
@


1.49
log
@experiment with libdm
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.48 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d81 1
a82 1
struct dm *Glx_dm_init();
d157 3
a159 2
struct dm *
Glx_dm_init(argc, argv)
d194 11
a204 2
#if 0
  return Glx_open(Glx_doevent, argc, argv);
d287 2
a288 1
	bu_vls_printf( &cmd, "M 1 %d %d\n", Glx_irisX2ged(dmp, mx), Glx_irisY2ged(dmp, my));
d292 2
a293 1
	bu_vls_printf( &cmd, "M 0 %d %d\n", Glx_irisX2ged(dmp, mx), Glx_irisY2ged(dmp, my));
d306 1
a306 1

d309 5
d327 1
d330 5
d337 1
d879 34
a912 9
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d", argv[2],
		  Glx_irisX2ged(dmp, atoi(argv[3])),
		  Glx_irisY2ged(dmp, atoi(argv[4])));
    status = Tcl_Eval(interp, bu_vls_addr(&vls));
#if 0
    mged_print_result(status);
#endif
    return status;
d941 1
d945 5
@


1.48
log
@checkin for weekend
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.47 1997/01/02 19:37:38 bparker Exp bparker $ (BRL)";
a74 1
#include "dm-glx.h"
d79 1
d82 1
a82 1
int Glx_dm_init();
d157 4
a160 2
int
Glx_dm_init()
d162 21
a183 1
  dmp->dm_eventHandler = Glx_doevent;
d187 13
a199 1
  return TCL_OK;
@


1.47
log
@mods to use libbn and libbu
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.46 1996/12/23 22:39:14 bparker Exp bparker $ (BRL)";
a226 1
    refresh();
d229 2
a230 2
      /* Window may have moved */
      Glx_configure_window_shape(dmp);
d232 2
a233 3
      dirty = 1;
      refresh();
      goto end;
@


1.46
log
@mods to event handler
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.45 1996/12/13 23:10:54 bparker Exp bparker $ (BRL)";
d103 1
a103 1
	{"%d",  1, "debug",		Glx_MV_O(debug),	FUNC_NULL },
d105 6
a110 6
	{"%d",  1, "has_zbuf",		Glx_MV_O(zbuf),		FUNC_NULL },
	{"%d",  1, "has_rgb",		Glx_MV_O(rgb),		FUNC_NULL },
	{"%d",  1, "has_doublebuffer",	Glx_MV_O(doublebuffer), FUNC_NULL },
	{"%d",  1, "min_scr_z",		Glx_MV_O(min_scr_z),	FUNC_NULL },
	{"%d",  1, "max_scr_z",		Glx_MV_O(max_scr_z),	FUNC_NULL },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
@


1.45
log
@weekend checkin
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.44 1996/12/11 22:40:57 bparker Exp bparker $ (BRL)";
d322 2
a323 1
	bu_vls_printf( &cmd, "knob ang1 %d\n", setting );
d377 2
a378 1
	bu_vls_printf( &cmd, "knob ang2 %d\n", setting );
@


1.44
log
@experimenting
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.43 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d187 1
d313 4
a316 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !dv_1adc )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d318 2
a319 2
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_1adc) +
	                  M->axis_data[0] - knob_values[M->first_axis];
d322 1
a322 2
	bu_vls_printf( &cmd, "knob ang1 %d\n",
		      setting );
d327 5
d333 4
a336 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !rate_zoom )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d339 1
a339 1
	    dm_unlimit((int)(512.5 * rate_zoom)) +
d343 1
a343 2
	bu_vls_printf( &cmd , "knob S %f\n",
		       setting / 512.0 );
d345 5
d351 4
a354 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !absolute_zoom )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d357 1
a357 1
	    dm_unlimit((int)(512.5 * absolute_zoom)) +
d361 1
a361 2
	bu_vls_printf( &cmd , "knob aS %f\n",
		       setting / 512.0 );
d367 4
a370 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !dv_2adc )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d372 2
a373 2
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_2adc) +
	                  M->axis_data[0] - knob_values[M->first_axis];
d376 1
a376 2
	bu_vls_printf( &cmd , "knob ang2 %d\n",
		      setting );
d379 5
d385 4
a388 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !rate_rotate[Z] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d391 1
a391 1
	      dm_unlimit((int)(512.5 * rate_rotate[Z])) +
d395 1
a395 2
	  bu_vls_printf( &cmd , "knob z %f\n",
		      setting / 512.0 );
d397 5
d403 4
a406 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !absolute_rotate[Z] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d409 1
a409 1
	      dm_unlimit((int)(2.85 * absolute_rotate[Z])) +
d413 1
a413 1
	  bu_vls_printf( &cmd , "knob az %f\n", dm_wrap(f) * 180.0);
d420 4
a423 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !dv_distadc)
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d425 2
a426 2
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_distadc) +
	    M->axis_data[0] - knob_values[M->first_axis];
d429 1
a429 2
	bu_vls_printf( &cmd , "knob distadc %d\n",
		      setting );
d432 5
d438 4
a441 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !rate_slew[Z] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d444 1
a444 1
	      dm_unlimit((int)(512.5 * rate_slew[Z])) +
d448 1
a448 2
	  bu_vls_printf( &cmd , "knob Z %f\n",
			 setting / 512.0 );
d450 5
d456 4
a459 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !absolute_slew[Z] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d462 1
a462 1
	      dm_unlimit((int)(512.5 * absolute_slew[Z])) +
d466 1
a466 2
	  bu_vls_printf( &cmd , "knob aZ %f\n",
			 setting / 512.0 );
d473 4
a476 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !dv_yadc)
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d478 2
a479 2
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_yadc) +
	    M->axis_data[0] - knob_values[M->first_axis];
d482 1
a482 2
	bu_vls_printf( &cmd , "knob yadc %d\n",
		      setting );
d485 5
d491 4
a494 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !rate_rotate[Y] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d497 1
a497 1
	      dm_unlimit((int)(512.5 * rate_rotate[Y])) +
d501 1
a501 2
	  bu_vls_printf( &cmd , "knob y %f\n",
			 setting / 512.0 );
d503 5
d509 4
a512 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !absolute_rotate[Y] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d515 1
a515 1
	      dm_unlimit((int)(2.85 * absolute_rotate[Y])) +
d519 1
a519 1
	  bu_vls_printf( &cmd , "knob ay %f\n", dm_wrap(f) * 180.0);
d525 5
d531 4
a534 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !rate_slew[Y] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d537 1
a537 1
	      dm_unlimit((int)(512.5 * rate_slew[Y])) +
d541 1
a541 2
	bu_vls_printf( &cmd , "knob Y %f\n",
		       setting / 512.0 );
d543 5
d549 4
a552 2
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !absolute_slew[Y] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d556 1
a556 1
	      dm_unlimit((int)(512.5 * absolute_slew[Y])) +
d560 1
a560 2
	bu_vls_printf( &cmd , "knob aY %f\n",
		       setting / 512.0 );
d566 4
a569 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !dv_xadc)
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d575 1
a575 2
	bu_vls_printf( &cmd , "knob xadc %d\n",
		      setting );
d578 5
d584 4
a587 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !rate_rotate[X] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d590 1
a590 1
	      dm_unlimit((int)(512.5 * rate_rotate[X])) +
d594 1
a594 2
	  bu_vls_printf( &cmd , "knob x %f\n",
			 setting / 512.0 );
d596 5
d602 4
a605 3
	     ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !absolute_rotate[X] )
	    ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	      knob_values[M->first_axis];
d608 1
a608 1
	      dm_unlimit((int)(2.85 * absolute_rotate[X])) +
d612 1
a612 1
	  bu_vls_printf( &cmd , "knob ax %f\n", dm_wrap(f) * 180.0);
d618 5
d624 4
a627 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !rate_slew[X] )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d630 1
a630 1
	    dm_unlimit((int)(512.5 * rate_slew[X])) +
d634 1
a634 2
	bu_vls_printf( &cmd , "knob X %f\n",
		       setting / 512.0 );
d636 5
d642 4
a645 3
	   ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] < NOISE && !absolute_slew[X] )
	  ((struct glx_vars *)dmp->dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
	    knob_values[M->first_axis];
d648 1
a648 1
	    dm_unlimit((int)(512.5 * absolute_slew[X])) +
d652 1
a652 2
	bu_vls_printf( &cmd , "knob aX %f\n",
		       setting / 512.0 );
@


1.43
log
@experimentation
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.42 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d259 16
a274 1
      {
d277 6
a282 3
	if(EDIT_TRAN && mged_variables.edit){
#if 1
	  vect_t view_pos;
a283 19
	  view_pos[X] = (mx/(fastf_t)((struct glx_vars *)dmp->dm_vars)->width
			 - 0.5) * 2.0;
	  view_pos[Y] = (0.5 - my/
			 (fastf_t)((struct glx_vars *)dmp->dm_vars)->height) * 2.0;
	  view_pos[Z] = 0.0;
	  aslewview(view_pos);
#else
	  fx = (mx/(fastf_t)((struct glx_vars *)dmp->dm_vars)->width - 0.5) * 2.0;
	  fy = (0.5 - my/(fastf_t)((struct glx_vars *)dmp->dm_vars)->height) * 2.0;
	  bu_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy );
#endif
	}else{
	  fx = (mx - ((struct glx_vars *)dmp->dm_vars)->omx)/
	    (fastf_t)((struct glx_vars *)dmp->dm_vars)->width * 2.0;
	  fy = (((struct glx_vars *)dmp->dm_vars)->omy - my)/
	    (fastf_t)((struct glx_vars *)dmp->dm_vars)->height * 2.0;
	  bu_vls_printf( &cmd, "knob -i aX %f aY %f\n", fx, fy );
	}
      }	     
a780 1
#if 1
d789 5
a793 11
	  aslewview(view_pos);
#else
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "knob aX %f aY %f\n",
			(((struct glx_vars *)dmp->dm_vars)->omx /
			 (fastf_t)((struct glx_vars *)dmp->dm_vars)->width - 0.5) * 2,
			(0.5 - ((struct glx_vars *)dmp->dm_vars)->omy /
			 (fastf_t)((struct glx_vars *)dmp->dm_vars)->height) * 2);
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
#endif
@


1.42
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.41 1996/12/04 21:13:19 bparker Exp bparker $ (BRL)";
d262 13
a274 3
	if(EDIT_TRAN){
	  fx = (mx/(fastf_t)((struct glx_vars *)dmp->dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)((struct glx_vars *)dmp->dm_vars)->height) * 2;
d276 1
d747 6
a752 9
    av[0] = "M";
    av[1] = argv[2];
    av[2] = xstr;
    av[3] = ystr;
    av[4] = NULL;

    sprintf(xstr, "%d", Glx_irisX2ged(dmp, atoi(argv[3])));
    sprintf(ystr, "%d", Glx_irisY2ged(dmp, atoi(argv[4])));
    status = f_mouse((ClientData)NULL, interp, 4, av);
d754 1
a754 1

d781 12
a792 1
	if(EDIT_TRAN){
d801 1
@


1.41
log
@*** empty log message ***
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.40 1996/11/01 22:10:04 bparker Exp bparker $ (BRL)";
d255 2
a256 2
		     (my - ((struct glx_vars *)dmp->dm_vars)->omy)/4.0,
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx)/4.0 );
d262 1
a262 2
	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	  (edobj || es_edflag > 0)){
d773 1
a773 3
	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
#if 1
a781 14
#else
	  av[0] = "knob";
	  av[1] = "aX";
	  av[2] = xstr;
	  av[3] = "aY";
	  av[4] = ystr;
	  av[5] = NULL;

	  sprintf(xstr, "%f", (((struct glx_vars *)dmp->dm_vars)->omx/
			       (fastf_t)((struct glx_vars *)dmp->dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - ((struct glx_vars *)dmp->dm_vars)->omy/
			       (fastf_t)((struct glx_vars *)dmp->dm_vars)->height) * 2);
	  status = f_knob((ClientData)NULL, interp, 5, av);
#endif
@


1.40
log
@change iknob to knob -1
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.39 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d158 1
a158 3
Glx_dm_init(argc, argv)
int argc;
char *argv[];
d165 1
a165 4
  if(dmp->dm_init(dmp, argc, argv) == TCL_ERROR)
    return TCL_ERROR;

  return dmp->dm_open(dmp);
d186 1
a186 1
  int status = CMD_OK;
d255 2
a256 2
		     (my - ((struct glx_vars *)dmp->dm_vars)->omy)/512.0,
		     (mx - ((struct glx_vars *)dmp->dm_vars)->omx)/512.0 );
d378 1
a378 1
	      dm_unlimit((int)(512.5 * absolute_rotate[Z])) +
d382 1
a382 1
	  bu_vls_printf( &cmd , "knob az %f\n", dm_wrap(f));
d463 1
a463 1
	      dm_unlimit((int)(512.5 * absolute_rotate[Y])) +
d467 1
a467 1
	  bu_vls_printf( &cmd , "knob ay %f\n", dm_wrap(f));
d534 1
a534 1
	      dm_unlimit((int)(512.5 * absolute_rotate[X])) +
d538 1
a538 1
	  bu_vls_printf( &cmd , "knob ax %f\n", dm_wrap(f));
d612 1
a612 1
  status = cmdline(&cmd, FALSE);
d617 1
a617 4
  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
d776 10
a785 1

d798 1
@


1.39
log
@hacks to use latest libdm
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.38 1996/10/18 14:05:43 bparker Exp bparker $ (BRL)";
d259 1
a259 1
      bu_vls_printf( &cmd, "iknob ax %f ay %f\n",
d277 1
a277 1
	  bu_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy );
d282 1
a282 1
      bu_vls_printf( &cmd, "iknob aS %f\n", (((struct glx_vars *)dmp->dm_vars)->omy - my)/
@


1.38
log
@call mged_print_result after calling f_mouse in case it had something to say
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.37 1996/10/04 20:37:54 bparker Exp bparker $ (BRL)";
d163 3
a165 3
  dmp->dmr_eventhandler = Glx_doevent;
  dmp->dmr_cmd = Glx_dm;
  dmp->dmr_statechange = Glx_statechange;
d167 1
a167 1
  if(dmp->dmr_init(dmp, argc, argv) == TCL_ERROR)
d170 1
a170 1
  return dmp->dmr_open(dmp);
d248 1
a248 1
      if(scroll_active && eventPtr->xmotion.state & ((struct glx_vars *)dm_vars)->mb_mask)
d260 2
a261 2
		     (my - ((struct glx_vars *)dm_vars)->omy)/512.0,
		     (mx - ((struct glx_vars *)dm_vars)->omx)/512.0 );
d269 2
a270 2
	  fx = (mx/(fastf_t)((struct glx_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)((struct glx_vars *)dm_vars)->height) * 2;
d273 4
a276 4
	  fx = (mx - ((struct glx_vars *)dm_vars)->omx)/
	    (fastf_t)((struct glx_vars *)dm_vars)->width * 2.0;
	  fy = (((struct glx_vars *)dm_vars)->omy - my)/
	    (fastf_t)((struct glx_vars *)dm_vars)->height * 2.0;
d282 2
a283 2
      bu_vls_printf( &cmd, "iknob aS %f\n", (((struct glx_vars *)dm_vars)->omy - my)/
		     (fastf_t)((struct glx_vars *)dm_vars)->height);
d287 2
a288 2
    ((struct glx_vars *)dm_vars)->omx = mx;
    ((struct glx_vars *)dm_vars)->omy = my;
d291 1
a291 1
  else if( eventPtr->type == ((struct glx_vars *)dm_vars)->devmotionnotify ){
d307 3
a309 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !dv_1adc )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d312 1
a312 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_1adc) +
d315 1
a315 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d322 3
a324 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !rate_zoom )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d327 1
a327 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d331 1
a331 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d335 3
a337 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !absolute_zoom )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d340 1
a340 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d344 1
a344 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d351 3
a353 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !dv_2adc )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d356 1
a356 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_2adc) +
d359 1
a359 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d364 3
a366 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !rate_rotate[Z] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d369 1
a369 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d373 1
a373 1
	  setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d377 3
a379 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !absolute_rotate[Z] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d382 1
a382 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d386 1
a386 1
	  f = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]) / 512.0;
d393 3
a395 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !dv_distadc)
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d398 1
a398 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_distadc) +
d401 1
a401 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d406 3
a408 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !rate_slew[Z] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d411 1
a411 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d415 1
a415 1
	  setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d419 3
a421 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !absolute_slew[Z] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d424 1
a424 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d428 1
a428 1
	  setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d436 3
a438 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !dv_yadc)
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d441 1
a441 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = dm_unlimit(dv_yadc) +
d444 1
a444 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d449 3
a451 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !rate_rotate[Y] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d454 1
a454 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d458 1
a458 1
	  setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d462 3
a464 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !absolute_rotate[Y] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d467 1
a467 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d471 1
a471 1
	  f = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]) / 512.0;
d478 3
a480 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !rate_slew[Y] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d483 1
a483 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d487 1
a487 1
	  setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d491 3
a493 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !absolute_slew[Y] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d496 1
a496 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d500 1
a500 1
	  setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d507 3
a509 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !dv_xadc)
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d512 1
a512 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d515 1
a515 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d520 3
a522 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !rate_rotate[X] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d525 1
a525 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d529 1
a529 1
	  setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d533 3
a535 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	     ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !absolute_rotate[X] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d538 1
a538 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d542 1
a542 1
	  f = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]) / 512.0;
d549 3
a551 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !rate_slew[X] )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d554 1
a554 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d558 1
a558 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d562 3
a564 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] &&
	   ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE && !absolute_slew[X] )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] -
d567 1
a567 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] =
d571 1
a571 1
	setting = dm_limit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d585 1
a585 1
  else if( eventPtr->type == ((struct glx_vars *)dm_vars)->devbuttonpress ){
d603 1
a603 1
  }else if( eventPtr->type == ((struct glx_vars *)dm_vars)->devbuttonrelease ){
d632 1
a632 1
  if( ((struct glx_vars *)dm_vars)->mvars.debug ){
d669 1
d671 1
d701 1
a701 1
      bu_struct_print("dm_4d internal variables", Glx_vparse, (CONST char *)&((struct glx_vars *)dm_vars)->mvars );
d703 1
a703 1
      bu_vls_struct_item_named( &vls, Glx_vparse, argv[1], (CONST char *)&((struct glx_vars *)dm_vars)->mvars, ',');
d709 1
a709 1
      bu_struct_parse( &vls, Glx_vparse, (char *)&((struct glx_vars *)dm_vars)->mvars);
d732 1
a732 1
      ((struct glx_vars *)dm_vars)->mb_mask = Button1Mask;
d735 1
a735 1
      ((struct glx_vars *)dm_vars)->mb_mask = Button2Mask;
d738 1
a738 1
      ((struct glx_vars *)dm_vars)->mb_mask = Button3Mask;
d772 2
a773 2
    ((struct glx_vars *)dm_vars)->omx = atoi(argv[3]);
    ((struct glx_vars *)dm_vars)->omy = atoi(argv[4]);
d792 4
a795 4
	  sprintf(xstr, "%f", (((struct glx_vars *)dm_vars)->omx/
			       (fastf_t)((struct glx_vars *)dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - ((struct glx_vars *)dm_vars)->omy/
			       (fastf_t)((struct glx_vars *)dm_vars)->height) * 2);
d849 8
a856 1
  dmp->dmr_colorchange(dmp);
d871 1
d901 1
a901 1
    ((struct glx_vars *)dm_vars)->knobs[i] = 0;
@


1.37
log
@- use dm_unlimit and dm_limit instead of Glx_add_tol and Glx_irlimit.
- use dm_wrap during absolute rotate
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.36 1996/10/03 20:52:10 bparker Exp bparker $ (BRL)";
d81 1
d752 1
d846 1
@


1.36
log
@get rid of extra cmdline() uses
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.35 1996/09/30 19:42:58 bparker Exp bparker $ (BRL)";
d259 2
a260 1
		     (my - ((struct glx_vars *)dm_vars)->omy)/512.0, (mx - ((struct glx_vars *)dm_vars)->omx)/512.0 );
d272 4
a275 2
	  fx = (mx - ((struct glx_vars *)dm_vars)->omx)/(fastf_t)((struct glx_vars *)dm_vars)->width * 2.0;
	  fy = (((struct glx_vars *)dm_vars)->omy - my)/(fastf_t)((struct glx_vars *)dm_vars)->height * 2.0;
d281 2
a282 1
      bu_vls_printf( &cmd, "iknob aS %f\n", (((struct glx_vars *)dm_vars)->omy - my)/(fastf_t)((struct glx_vars *)dm_vars)->height);
d293 1
d306 4
a309 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	                !dv_1adc )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d311 1
a311 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol(dv_1adc) +
d314 1
a314 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d321 4
a324 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	   !rate_zoom )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d326 2
a327 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_zoom)) +
d330 1
a330 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d334 4
a337 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	   !absolute_zoom )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d339 2
a340 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_zoom)) +
d343 1
a343 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d350 4
a353 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	                !dv_2adc )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d355 1
a355 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol(dv_2adc) +
d358 1
a358 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d363 4
a366 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !rate_rotate[Z] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d368 2
a369 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_rotate[Z])) +
d372 1
a372 1
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d376 4
a379 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[Z] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d381 2
a382 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_rotate[Z])) +
d385 2
a386 3
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob az %f\n",
			 setting / 512.0 );
d392 4
a395 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	   !dv_distadc)
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d397 1
a397 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol(dv_distadc) +
d400 1
a400 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d405 4
a408 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !rate_slew[Z] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d410 2
a411 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_slew[Z])) +
d414 1
a414 1
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d418 4
a421 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !absolute_slew[Z] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d423 2
a424 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_slew[Z])) +
d427 1
a427 1
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d435 4
a438 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	   !dv_yadc)
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d440 1
a440 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol(dv_yadc) +
d443 1
a443 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d448 4
a451 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !rate_rotate[Y] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d453 2
a454 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_rotate[Y])) +
d457 1
a457 1
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d461 4
a464 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[Y] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d466 2
a467 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_rotate[Y])) +
d470 2
a471 3
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob ay %f\n",
			 setting / 512.0 );
d477 4
a480 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !rate_slew[Y] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d482 2
a483 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_slew[Y])) +
d486 1
a486 1
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d490 4
a493 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !absolute_slew[Y] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d495 2
a496 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_slew[Y])) +
d499 1
a499 1
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d506 4
a509 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	   !dv_xadc)
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d511 2
a512 2
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol(dv_xadc) +
	    M->axis_data[0] - knob_values[M->first_axis];
d514 1
a514 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d519 4
a522 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !rate_rotate[X] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d524 2
a525 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_rotate[X])) +
d528 1
a528 1
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d532 4
a535 3
	  if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[X] )
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d537 2
a538 1
	    ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_rotate[X])) +
d541 2
a542 3
	  setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob ax %f\n",
			 setting / 512.0 );
d548 4
a551 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	   !rate_slew[X] )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d553 2
a554 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_slew[X])) +
d557 1
a557 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
d561 4
a564 3
	if(-NOISE < ((struct glx_vars *)dm_vars)->knobs[M->first_axis] && ((struct glx_vars *)dm_vars)->knobs[M->first_axis] < NOISE &&
	   !absolute_slew[X] )
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
d566 2
a567 1
	  ((struct glx_vars *)dm_vars)->knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_slew[X])) +
d570 1
a570 1
	setting = Glx_irlimit(((struct glx_vars *)dm_vars)->knobs[M->first_axis]);
@


1.35
log
@more pruning
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.34 1996/09/26 20:38:22 bparker Exp bparker $ (BRL)";
d650 1
a650 1
  char *av[4];
a652 1
  char zstr[32];
d707 9
a715 5
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d\n", argv[2],
		  Glx_irisX2ged(dmp, atoi(argv[3])), Glx_irisY2ged(dmp, atoi(argv[4])));
    status = cmdline(&vls, FALSE);
    bu_vls_free(&vls);
d717 1
a717 4
    if(status == CMD_OK)
      return TCL_OK;

    return TCL_ERROR;
a744 1
	  fastf_t fx, fy;
d746 12
a757 6
	  bu_vls_init(&vls);
	  fx = (((struct glx_vars *)dm_vars)->omx/(fastf_t)((struct glx_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - ((struct glx_vars *)dm_vars)->omy/(fastf_t)((struct glx_vars *)dm_vars)->height) * 2;
	  bu_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	  (void)cmdline(&vls, FALSE);
	  bu_vls_free(&vls);
@


1.34
log
@changed parameters to dmr_object
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.33 1996/09/25 20:04:58 bparker Exp bparker $ (BRL)";
a93 3
#if 0
static struct dm_list *get_dm_list();
#endif
a101 5
	{"%d",  1, "has_zbuf",		Glx_MV_O(zbuf),	refresh_hook },
	{"%d",  1, "has_rgb",		Glx_MV_O(rgb),	Glx_colorchange },
	{"%d",  1, "has_doublebuffer",	Glx_MV_O(doublebuffer), refresh_hook },
	{"%d",  1, "min_scr_z",		Glx_MV_O(min_scr_z),	refresh_hook },
	{"%d",  1, "max_scr_z",		Glx_MV_O(max_scr_z),	refresh_hook },
d104 5
a187 1
  register struct dm_list *p;
d189 1
d192 2
a193 1
  if(eventPtr->type == DestroyNotify)
a198 3
#if 0
  curr_dm_list = get_dm_list(eventPtr->xany.window);
#else
a199 1
#endif
d634 2
a801 9
set_knob_offset()
{
  int i;

  for(i = 0; i < 8; ++i)
    ((struct glx_vars *)dm_vars)->knobs[i] = 0;
}

static void
d805 1
d812 1
d819 1
d826 1
d833 1
d842 4
a845 13
#if 0
static struct dm_list *
get_dm_list(window)
Window window;
{
  register struct glx_vars *p;

  for( BU_LIST_FOR(p, glx_vars, &head_glx_vars.l) ){
    if(window == p->win){
      GLXwinset(p->dpy, p->win);
      return ((struct mged_glx_vars *)p->app_vars)->dm_list;
    }
  }
d847 2
a848 1
  return DM_LIST_NULL;
a849 1
#endif
@


1.33
log
@calling GET_DM_LIST macro instead of get_dm_list
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.32 1996/09/23 18:41:43 bparker Exp bparker $ (BRL)";
d82 1
a82 3
#if 0
int Glx_close();
#endif
a163 3
  if(dmp->dmr_init(dmp, argc, argv) == TCL_ERROR)
    return TCL_ERROR;

d168 3
a170 3
#if 0
  dmp->dmr_app_close = Glx_close;
#endif
a173 10

#if 0
static int
Glx_close(p)
genptr_t *p;
{
  bu_free(p, "mged_glx_vars");
  return TCL_OK;
}
#endif
@


1.32
log
@use LIBDM permanently
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.31 1996/09/17 21:21:19 bparker Exp bparker $ (BRL)";
d78 1
a78 1
#include "./solid.h"
a80 2
extern void color_soltab();

d96 1
d98 1
a98 7

#define GLX_APP_VARS ((struct mged_glx_vars *)((struct glx_vars *)dm_vars)->app_vars)
#define MVARS (OGL_APP_VARS->mvars)

struct mged_glx_vars {
  struct dm_list *dm_list;
};
d166 1
a166 1
  if(dmp->dmr_init(dmp, color_soltab) == TCL_ERROR)
a176 13
#if 0
  /*XXX This gets screwed up when tieing ---- needs fixing --- see also f_tie() */
  ((struct glx_vars *)dm_vars)->viewscale = &Viewscale;
#endif

  /* Allocate space for application specific Glx variables */
  ((struct glx_vars *)dm_vars)->app_vars =
    bu_malloc(sizeof(struct mged_glx_vars), "mged_glx_vars");
  bzero((void *)((struct glx_vars *)dm_vars)->app_vars,
	sizeof(struct mged_glx_vars));

  GLX_APP_VARS->dm_list = curr_dm_list;

d216 1
d218 3
d225 2
d865 1
a865 1

d881 1
@


1.31
log
@prepare to use libdm
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.30 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d71 1
d75 1
d77 1
a77 2
#include "./dm.h"
#include "externs.h"
a80 3
#ifdef USE_LIBDM
#include "dm-glx.h"

d169 3
a171 1
Glx_dm_init()
a894 2608
#else
#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

extern int dm_pipe[];

extern Tcl_Interp *interp;
extern Tk_Window tkwin;
extern inventory_t	*getinvent();

/* Display Manager package interface */

#define IRBOUND	4095.9	/* Max magnification in Rot matrix */

int	Glx_open();
void	Glx_close();
MGED_EXTERN(void	Glx_input, (fd_set *input, int noblock) );
void	Glx_prolog(), Glx_epilog();
void	Glx_normal(), Glx_newrot();
void	Glx_update();
void	Glx_puts(), Glx_2d_line(), Glx_light();
int	Glx_object();
unsigned Glx_cvtvecs(), Glx_load();
void	Glx_statechange(), Glx_viewchange(), Glx_colorchange();
void	Glx_window(), Glx_debug();
int	Glx_dm();

static int Glx_setup();
static void set_knob_offset();
static void   Glx_load_startup();
static struct dm_list *get_dm_list();
#ifdef USE_PROTOTYPES
static Tk_GenericProc Glx_doevent;
#else
static int Glx_doevent();
#endif
static void glx_var_init();

#define dpy (((struct glx_vars *)dm_vars)->_dpy)
#define win (((struct glx_vars *)dm_vars)->_win)
#define xtkwin (((struct glx_vars *)dm_vars)->_xtkwin)
#define vis (((struct glx_vars *)dm_vars)->_vis)
#define cmap (((struct glx_vars *)dm_vars)->_cmap)
#define deep (((struct glx_vars *)dm_vars)->_deep)
#define mb_mask (((struct glx_vars *)dm_vars)->_mb_mask)
#define win_l (((struct glx_vars *)dm_vars)->_win_l)
#define win_b (((struct glx_vars *)dm_vars)->_win_b)
#define win_r (((struct glx_vars *)dm_vars)->_win_r)
#define win_t (((struct glx_vars *)dm_vars)->_win_t)
#define winx_size (((struct glx_vars *)dm_vars)->_winx_size)
#define winy_size (((struct glx_vars *)dm_vars)->_winy_size)
#define omx (((struct glx_vars *)dm_vars)->_omx)
#define omy (((struct glx_vars *)dm_vars)->_omy)
#define perspective_angle (((struct glx_vars *)dm_vars)->_perspective_angle)
#define devmotionnotify (((struct glx_vars *)dm_vars)->_devmotionnotify)
#define devbuttonpress (((struct glx_vars *)dm_vars)->_devbuttonpress)
#define devbuttonrelease (((struct glx_vars *)dm_vars)->_devbuttonrelease)
#define knobs (((struct glx_vars *)dm_vars)->_knobs)
#define stereo_is_on (((struct glx_vars *)dm_vars)->_stereo_is_on)
#define glx_is_gt (((struct glx_vars *)dm_vars)->_glx_is_gt)
#define aspect (((struct glx_vars *)dm_vars)->_aspect)
#define mvars (((struct glx_vars *)dm_vars)->_mvars)

struct modifiable_glx_vars {
  int cueing_on;
  int zclipping_on;
  int zbuffer_on;
  int lighting_on;
  int perspective_mode;
  int dummy_perspective;
  int zbuf;
  int rgb;
  int doublebuffer;
  int min_scr_z;       /* based on getgdesc(GD_ZMIN) */
  int max_scr_z;       /* based on getgdesc(GD_ZMAX) */
  int debug;
  int linewidth;
};

struct glx_vars {
  struct bu_list l;
  struct dm_list *dm_list;
  Display *_dpy;
  Window _win;
  Tk_Window _xtkwin;
  Visual *_vis;
  Colormap _cmap;
  int _deep;
  unsigned int _mb_mask;
  long _win_l, _win_b, _win_r, _win_t;
  long _winx_size, _winy_size;
  int _omx, _omy;
  int _perspective_angle;
  int _devmotionnotify;
  int _devbuttonpress;
  int _devbuttonrelease;
  int _knobs[8];
  int _stereo_is_on;
  int _glx_is_gt;
  fastf_t _aspect;
  struct modifiable_glx_vars _mvars;
};

static struct glx_vars head_glx_vars;
static int GlxdoMotion = 0;
static GLXconfig glx_config_wish_list [] = {
  { GLX_NORMAL, GLX_WINDOW, GLX_NONE },
  { GLX_NORMAL, GLX_DOUBLE, TRUE },
  { GLX_NORMAL, GLX_RGB, TRUE },
  { GLX_NORMAL, GLX_ZSIZE, GLX_NOCONFIG },
  { 0, 0, 0 }
};
static int perspective_table[] = { 
	30, 45, 60, 90 };
static int ovec = -1;		/* Old color map entry number */
static int kblights();
static double	xlim_view = 1.0;	/* args for ortho() */
static double	ylim_view = 1.0;

void		glx_colorit();

#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
/* Inverse map for mapping MGED button functions to SGI button numbers */
static unsigned char invbmap[BV_MAXFUNC+1];

/* bit 0 == switchlight 0 */
static unsigned long lights;
#endif

#ifdef IR_KNOBS
static int irlimit();			/* provides knob dead spot */
static int Glx_add_tol();
#define NOISE 32		/* Size of dead spot on knob */
/*
 *  Labels for knobs in help mode.
 */
static char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
static char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

/*
 * SGI Color Map table
 */
#define NSLOTS		4080	/* The mostest possible - may be fewer */
static int glx_nslots=0;		/* how many we have, <= NSLOTS */
static int slotsused;		/* how many actually used */
static struct rgbtab {
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
} glx_rgbtab[NSLOTS];

struct dm dm_glx = {
	Glx_open, Glx_close,
	Glx_input,
	Glx_prolog, Glx_epilog,
	Glx_normal, Glx_newrot,
	Glx_update,
	Glx_puts, Glx_2d_line,
	Glx_light,
	Glx_object,
	Glx_cvtvecs, Glx_load,
	Glx_statechange,
	Glx_viewchange,
	Glx_colorchange,
	Glx_window, Glx_debug, Glx_dm, Glx_doevent,
	0,			/* no "displaylist", per. se. */
	0,			/* multi-window */
	IRBOUND,
	"glx", "SGI - mixed mode",
	0,			/* mem map */
	0,
	0,
	0
};

extern struct device_values dm_values;	/* values read from devices */

static void     establish_perspective();
static void     set_perspective();
static void	establish_lighting();
static void	establish_zbuffer();
static void     establish_am();
static void set_window();
static XVisualInfo *extract_visual();
static unsigned long extract_value();

static void
refresh_hook()
{
	dmaflag = 1;
}

#define GLX_MV_O(_m) offsetof(struct modifiable_glx_vars, _m)
struct bu_structparse Glx_vparse[] = {
	{"%d",	1, "depthcue",		GLX_MV_O(cueing_on),	Glx_colorchange },
	{"%d",  1, "zclip",		GLX_MV_O(zclipping_on),	refresh_hook },
	{"%d",  1, "zbuffer",		GLX_MV_O(zbuffer_on),	establish_zbuffer },
	{"%d",  1, "lighting",		GLX_MV_O(lighting_on),	establish_lighting },
	{"%d",  1, "perspective",       GLX_MV_O(perspective_mode), establish_perspective },
	{"%d",  1, "set_perspective",GLX_MV_O(dummy_perspective),  set_perspective },
	{"%d",  1, "has_zbuf",		GLX_MV_O(zbuf),	refresh_hook },
	{"%d",  1, "has_rgb",		GLX_MV_O(rgb),	Glx_colorchange },
	{"%d",  1, "has_doublebuffer",	GLX_MV_O(doublebuffer), refresh_hook },
	{"%d",  1, "min_scr_z",		GLX_MV_O(min_scr_z),	refresh_hook },
	{"%d",  1, "max_scr_z",		GLX_MV_O(max_scr_z),	refresh_hook },
	{"%d",  1, "debug",		GLX_MV_O(debug),	FUNC_NULL },
	{"%d",  1, "linewidth",		GLX_MV_O(linewidth),	refresh_hook },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
};

static int	glx_oldmonitor;		/* Old monitor type */
static long gr_id;

/* Map +/-2048 GED space into -1.0..+1.0 :: x/2048*/
#define GED2IRIS(x)	(((float)(x))*0.00048828125)

/*
 *  Mouse coordinates are in absolute screen space, not relative to
 *  the window they came from.  Convert to window-relative,
 *  then to MGED-style +/-2048 range.
 */
static int
irisX2ged(x)
register int x;
{
  return ((x/(double)winx_size - 0.5) * 4095);
}

static int
irisY2ged(y)
register int y;
{
  return ((0.5 - y/(double)winy_size) * 4095);
}

/* 
 *			I R _ C O N F I G U R E _ W I N D O W _ S H A P E
 *
 *  Either initially, or on resize/reshape of the window,
 *  sense the actual size of the window, and perform any
 *  other initializations of the window configuration.
 */
static void
Glx_configure_window_shape()
{
  int		npix;
  XWindowAttributes xwa;

  XGetWindowAttributes( dpy, win, &xwa );
  winx_size = xwa.width;
  winy_size = xwa.height;

  /* Write enable all the bloody bits after resize! */
  viewport(0, winx_size, 0, winy_size);

  if( mvars.zbuf )
    establish_zbuffer();

  establish_lighting();
	
  if( mvars.doublebuffer){
    /* Clear out image from windows underneath */
    frontbuffer(1);
    glx_clear_to_black();
    frontbuffer(0);
    glx_clear_to_black();
  } else
    glx_clear_to_black();

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
  aspect = (fastf_t)winy_size/(fastf_t)winx_size;
}

#define CMAP_BASE	32
#define CMAP_RAMP_WIDTH	16
#define MAP_ENTRY(x)	((mvars.cueing_on) ? \
			((x) * CMAP_RAMP_WIDTH + CMAP_BASE) : \
			((x) + CMAP_BASE) )


/*
 *			I R _ O P E N
 *
 *  Fire up the display manager, and the display processor. Note that
 *  this brain-damaged version of the MEX display manager gets terribly
 *  confused if you try to close your last window.  Tough. We go ahead
 *  and close the window.  Ignore the "ERR_CLOSEDLASTWINDOW" error
 *  message. It doesn't hurt anything.  Silly MEX.
 */
Glx_open()
{
#ifdef DM_OGL
  /* This is a hack to handle the fact that the sgi attach crashes
   * if a direct OpenGL context has been previously opened in the 
   * current mged session. This stops the attach before it crashes.
   */
  if (ogl_ogl_used){
    Tcl_AppendResult(interp, "Can't attach sgi, because a direct OpenGL context has\n",
		     "previously been opened in this session. To use sgi,\n",
		     "quit this session and reopen it.\n", (char *)NULL);
    return TCL_ERROR;
  }
  ogl_sgi_used = 1;
#endif /* DM_OGL */
  glx_var_init();
  return Glx_setup(dname);
}

static int
Glx_setup( name )
char *name;
{
  register int	i;
  static int count = 0;
  Matrix		m;
  inventory_t	*inv;
  int		win_size=1000;
  int		win_o_x=272;
  int		win_o_y=12;
  struct bu_vls str;
  int j, k;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  GLXconfig *p, *glx_config;
  XVisualInfo *visual_info;

  bu_vls_init(&str);

  /* Only need to do this once for this display manager */
  if(!count)
    Glx_load_startup();

  if(BU_LIST_IS_EMPTY(&head_glx_vars.l))
    Tk_CreateGenericHandler(Glx_doevent, (ClientData)NULL);

  BU_LIST_APPEND(&head_glx_vars.l, &((struct glx_vars *)dm_vars)->l);

  bu_vls_printf(&pathName, ".dm_glx%d", count++);
  xtkwin = Tk_CreateWindowFromPath(interp, tkwin, bu_vls_addr(&pathName), name);
  /*
   * Create the X drawing window by calling init_glx which
   * is defined in glxinit.tcl
   */
  bu_vls_strcpy(&str, "init_glx ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&pathName));

  if(cmdline(&str, FALSE) == CMD_BAD){
    bu_vls_free(&str);
    return -1;
  }

  bu_vls_free(&str);

  dpy = Tk_Display(xtkwin);
  winx_size = DisplayWidth(dpy, DefaultScreen(dpy)) - 20;
  winy_size = DisplayHeight(dpy, DefaultScreen(dpy)) - 20;

  /* Make window square */
  if( winy_size < winx_size )
    winx_size = winy_size;
  else /* we have a funky shaped monitor */ 
    winy_size = winx_size;

  Tk_GeometryRequest(xtkwin, winx_size, winy_size);

  glx_is_gt = 1;
  glx_config = GLXgetconfig(dpy, Tk_ScreenNumber(xtkwin), glx_config_wish_list);
  visual_info = extract_visual(GLX_NORMAL, glx_config);
  vis = visual_info->visual;
  deep = visual_info->depth;
  cmap = extract_value(GLX_NORMAL, GLX_COLORMAP, glx_config);
  Tk_SetWindowVisual(xtkwin, vis, deep, cmap);

  Tk_MakeWindowExist(xtkwin);
  win = Tk_WindowId(xtkwin);
  set_window(GLX_NORMAL, win, glx_config);

  /* Inform the GL that you intend to render GL into an X window */
  if(GLXlink(dpy, glx_config) < 0)
    return -1;

  GLXwinset(dpy, win);

  /* set configuration variables */
  for(p = glx_config; p->buffer; ++p){
    switch(p->buffer){
    case GLX_NORMAL:
      switch(p->mode){
      case GLX_ZSIZE:
	if(p->arg)
	  mvars.zbuf = 1;
	else
	  mvars.zbuf = 0;

	break;
      case GLX_RGB:
	if(p->arg)
	  mvars.rgb = 1;
	else
	  mvars.rgb = 0;
	
	break;
      case GLX_DOUBLE:
	if(p->arg)
	  mvars.doublebuffer = 1;
	else
	  mvars.doublebuffer = 0;

	break;
      case GLX_STEREOBUF:
	stereo_is_on = 1;

	break;
      case GLX_BUFSIZE:
      case GLX_STENSIZE:
      case GLX_ACSIZE:
      case GLX_VISUAL:
      case GLX_COLORMAP:
      case GLX_WINDOW:
      case GLX_MSSAMPLE:
      case GLX_MSZSIZE:
      case GLX_MSSSIZE:
      case GLX_RGBSIZE:
      default:
	break;
      }
    case GLX_OVERLAY:
    case GLX_POPUP:
    case GLX_UNDERLAY:
    default:
      break;
    }
  }

  free((void *)glx_config);
	
  if (mged_variables.sgi_win_size > 0)
    win_size = mged_variables.sgi_win_size;

  if (mged_variables.sgi_win_origin[0] != 0)
    win_o_x = mged_variables.sgi_win_origin[0];

  if (mged_variables.sgi_win_origin[1] != 0)
    win_o_y = mged_variables.sgi_win_origin[1];

  winconstraints();	/* remove constraints on the window size */

  /*
   * Establish GL library operating modes
   */
  /* Don't draw polygon edges */
  glcompat( GLC_OLDPOLYGON, 0 );

  /* Z-range mapping */
  /* Z range from getgdesc(GD_ZMIN)
   * to getgdesc(GD_ZMAX).
   * Hardware specific.
   */
  glcompat( GLC_ZRANGEMAP, 0 );

  /* Take off a smidgeon for wraparound, as suggested by SGI manual */

  mvars.min_scr_z = getgdesc(GD_ZMIN)+15;
  mvars.max_scr_z = getgdesc(GD_ZMAX)-15;

  Glx_configure_window_shape();

  /* Line style 0 is solid.  Program line style 1 as dot-dashed */
  deflinestyle( 1, 0xCF33 );
  setlinestyle( 0 );

  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  olist = list = (XDeviceInfoPtr) XListInputDevices (dpy, &ndevices);

  /* IRIX 4.0.5 bug workaround */
  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(dpy, list->id)) == (XDevice *)NULL){
	  Tcl_AppendResult(interp, "Glx_open: Couldn't open the dials+buttons\n",
			   (char *)NULL);
	  goto Done;
	}

	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
#if IR_BUTTONS
	  case ButtonClass:
	    DeviceButtonPress(dev, devbuttonpress, e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, devbuttonrelease, e_class[nclass]);
	    ++nclass;
#endif
	    break;
#if IR_KNOBS
	  case ValuatorClass:
	    DeviceMotionNotify(dev, devmotionnotify, e_class[nclass]);
	    ++nclass;
	    break;
#endif
	  default:
	    break;
	  }
	}

	XSelectExtensionEvent(dpy, win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);

  Tk_MapWindow(xtkwin);
  return(0);
}

/*XXX Just experimenting */
void
Glx_load_startup()
{
  char *filename;

  bzero((void *)&head_glx_vars, sizeof(struct glx_vars));
  BU_LIST_INIT( &head_glx_vars.l );

  if((filename = getenv("DM_GLX_RCFILE")) != (char *)NULL )
    Tcl_EvalFile(interp, filename);
}

/*
 *  			I R _ C L O S E
 *  
 *  Gracefully release the display.  Well, mostly gracefully -- see
 *  the comments in the open routine.
 */
void
Glx_close()
{
  if(ogl_ogl_used)
    return;

  if(xtkwin != NULL){
    if(mvars.cueing_on)
      depthcue(0);

    lampoff( 0xf );

    /* avoids error messages when reattaching */
    mmode(MVIEWING);	
    lmbind(LIGHT2,0);
    lmbind(LIGHT3,0);
    lmbind(LIGHT4,0);
    lmbind(LIGHT5,0);

    frontbuffer(1);
    glx_clear_to_black();
    frontbuffer(0);

    GLXunlink(dpy, win);
    Tk_DestroyWindow(xtkwin);
  }

  if(((struct glx_vars *)dm_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct glx_vars *)dm_vars)->l);

  bu_free(dm_vars, "Glx_close: dm_vars");

  if(BU_LIST_IS_EMPTY(&head_glx_vars.l))
    Tk_DeleteGenericHandler(Glx_doevent, (ClientData)NULL);
}

/*
 *			G L X _ P R O L O G
 *
 * Define the world, and include in it instances of all the
 * important things.  Most important of all is the object "faceplate",
 * which is built between dmr_normal() and dmr_epilog()
 * by dmr_puts and dmr_2d_line calls from adcursor() and dotitles().
 */
void
Glx_prolog()
{
  GLXwinset(dpy, win);

  if (mvars.debug)
    Tcl_AppendResult(interp, "Glx_prolog\n", (char *)NULL);

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );

  if( !mvars.doublebuffer ){
    glx_clear_to_black();
    return;
  }

  linewidth(mvars.linewidth);
}

/*
 *			I R _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
Glx_normal()
{
  if (mvars.debug)
    Tcl_AppendResult(interp, "Glx_normal\n", (char *)NULL);

  if( mvars.rgb )  {
    RGBcolor( (short)0, (short)0, (short)0 );
  } else {
    color(BLACK);
  }

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
}

/*
 *			I R _ E P I L O G
 */
void
Glx_epilog()
{
  if (mvars.debug)
    Tcl_AppendResult(interp, "Glx_epilog\n", (char *)NULL);

  /*
   * A Point, in the Center of the Screen.
   * This is drawn last, to always come out on top.
   */
  Glx_2d_line( 0, 0, 0, 0, 0 );
  /* End of faceplate */

  if(mvars.doublebuffer){
    swapbuffers();
    /* give Graphics pipe time to work */
    glx_clear_to_black();
  }
}

/*
 *  			I R _ N E W R O T
 *
 *  Load a new rotation matrix.  This will be followed by
 *  many calls to Glx_object().
 *
 *  IMPORTANT COORDINATE SYSTEM NOTE:
 *
 *  MGED uses a right handed coordinate system where +Z points OUT of
 *  the screen.  The Silicon Graphics uses a left handed coordinate
 *  system where +Z points INTO the screen.
 *  This difference in convention is handled here.
 *  The conversion is accomplished by concatenating a matrix multiply
 *  by
 *            (  1    0    0   0  )
 *            (  0    1    0   0  )
 *            (  0    0   -1   0  )
 *            (  0    0    0   1  )
 *
 *  However, this is actually implemented by straight-line code which
 *  flips the sign on the entire third row.
 *
 *  Note that through BRL-CAD Release 3.7 this was handled by flipping
 *  the direction of the shade ramps.  Now, with the Z-buffer being used,
 *  the correct solution is important.
 */
void
Glx_newrot(mat, which_eye)
mat_t	mat;
{
	register fastf_t *mptr;
	Matrix	gtmat;
	mat_t	newm;
	int	i;

	if (mvars.debug)
	  Tcl_AppendResult(interp, "Glx_newrot()\n", (char *)NULL);

	switch(which_eye)  {
	case 0:
		/* Non-stereo */
		break;
	case 1:
		/* R eye */
		viewport(0, XMAXSCREEN, 0, YSTEREO);
		Glx_puts( "R", 2020, 0, 0, DM_RED );
		break;
	case 2:
		/* L eye */
		viewport(0, XMAXSCREEN, 0+YOFFSET_LEFT, YSTEREO+YOFFSET_LEFT);
		break;
	}

	if( ! mvars.zclipping_on ) {
		mat_t	nozclip;

		mat_idn( nozclip );
		nozclip[10] = 1.0e-20;
		mat_mul( newm, nozclip, mat );
		mptr = newm;
	} else {
		mptr = mat;
	}

	gtmat[0][0] = *(mptr++) * aspect;
	gtmat[1][0] = *(mptr++) * aspect;
	gtmat[2][0] = *(mptr++) * aspect;
	gtmat[3][0] = *(mptr++) * aspect;

	gtmat[0][1] = *(mptr++);
	gtmat[1][1] = *(mptr++);
	gtmat[2][1] = *(mptr++);
	gtmat[3][1] = *(mptr++);

	gtmat[0][2] = *(mptr++);
	gtmat[1][2] = *(mptr++);
	gtmat[2][2] = *(mptr++);
	gtmat[3][2] = *(mptr++);

	gtmat[0][3] = *(mptr++);
	gtmat[1][3] = *(mptr++);
	gtmat[2][3] = *(mptr++);
	gtmat[3][3] = *(mptr++);

	/*
	 *  Convert between MGED's right handed coordinate system
	 *  where +Z comes out of the screen to the Silicon Graphics's
	 *  left handed coordinate system, where +Z goes INTO the screen.
	 */
	gtmat[0][2] = -gtmat[0][2];
	gtmat[1][2] = -gtmat[1][2];
	gtmat[2][2] = -gtmat[2][2];
	gtmat[3][2] = -gtmat[3][2];

	loadmatrix( gtmat );
}

static float material_objdef[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/*
 *  			I R _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.  Mat is model2view.
 *
 *  Returns -
 *	 0 if object could be drawn
 *	!0 if object was omitted.
 */
int
Glx_object( sp, m, ratio, white )
register struct solid *sp;
fastf_t		*m;
double		ratio;
int		white;
{
	register struct rt_vlist	*vp;
	register int nvec;
	register float	*gtvec;
	char	gtbuf[16+3*sizeof(double)];
	int first;
	int i,j;

	if (mvars.debug)
	  Tcl_AppendResult(interp, "Glx_Object()\n", (char *)NULL);

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

	/*
	 * IMPORTANT DEPTHCUEING NOTE
	 *
	 * Also note that the depthcueing shaderange() routine wanders
	 * outside it's allotted range due to roundoff errors.  A buffer
	 * entry is kept on each end of the shading curves, and the
	 * highlight mode uses the *next* to the brightest entry --
	 * otherwise it can (and does) fall off the shading ramp.
	 */
	if (sp->s_soldash)
		setlinestyle( 1 );		/* set dot-dash */

	if( mvars.rgb )  {
		register short	r, g, b;
		if( white )  {
			r = g = b = 230;
		} else {
			r = (short)sp->s_color[0];
			g = (short)sp->s_color[1];
			b = (short)sp->s_color[2];
		}
		if(mvars.cueing_on)  {
			lRGBrange(
			    r/10, g/10, b/10,
			    r, g, b,
			    mvars.min_scr_z, mvars.max_scr_z );
		} else
		if(mvars.lighting_on && glx_is_gt)
		{
			/* Ambient = .2, Diffuse = .6, Specular = .2 */

			/* Ambient */
			material_objdef[3] = 	.2 * ( r / 255.0);
			material_objdef[4] = 	.2 * ( g / 255.0);
			material_objdef[5] = 	.2 * ( b / 255.0);

			/* diffuse */
			material_objdef[7] = 	.6 * ( r / 255.0);
			material_objdef[8] = 	.6 * ( g / 255.0);
			material_objdef[9] = 	.6 * ( b / 255.0);

			/* Specular */
			material_objdef[11] = 	.2 * ( r / 255.0);
			material_objdef[12] = 	.2 * ( g / 255.0);
			material_objdef[13] = 	.2 * ( b / 255.0);

			lmdef(DEFMATERIAL, 21, 0, material_objdef);
			lmbind(MATERIAL, 21);

		} else

			RGBcolor( r, g, b );
	} else {
		if( white ) {
			ovec = nvec = MAP_ENTRY(DM_WHITE);
			/* Use the *next* to the brightest white entry */
			if(mvars.cueing_on)  {
				lshaderange(nvec+1, nvec+1,
				    mvars.min_scr_z, mvars.max_scr_z );
			}
			color( nvec );
		} else {
			if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
				/* Use only the middle 14 to allow for roundoff...
				 * Pity the poor fool who has defined a black object.
				 * The code will use the "reserved" color map entries
				 * to display it when in depthcued mode.
				 */
				if(mvars.cueing_on)  {
					lshaderange(nvec+1, nvec+14,
					    mvars.min_scr_z, mvars.max_scr_z );
				}
				color( nvec );
				ovec = nvec;
			}
		}
	}

	/* Viewing region is from -1.0 to +1.0 */
	first = 1;
	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					endline();
				first = 0;
				bgnline();
				v3d( *pt );
				break;
			case RT_VLIST_LINE_DRAW:
				/* Draw line */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					endline();
				/* concave(TRUE); */
				bgnpolygon();
				/* Set surface normal (vl_pnt points outward) */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			case RT_VLIST_POLY_MOVE:
				/* Polygon Move */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_DRAW:
				/* Polygon Draw */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				v3d( *pt );
				endpolygon();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			}
		}
	}
	if( first == 0 ) endline();

	if (sp->s_soldash)
		setlinestyle(0);		/* restore solid lines */

	return(1);	/* OK */
}

/*
 *			I R _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 * Last routine called in refresh cycle.
 */
void
Glx_update()
{
	if (mvars.debug)
	  Tcl_AppendResult(interp, "Glx_update()\n", (char *)NULL);

	return;
}

/*
 *			I R _ P U T S
 *
 * Output a string.
 * The starting position of the beam is as specified.
 */
void
Glx_puts( str, x, y, size, colour )
register char *str;
int x,y,size, colour;
{
	if (mvars.debug)
	  Tcl_AppendResult(interp, "Glx_puts()\n", (char *)NULL);

	cmov2( GED2IRIS(x), GED2IRIS(y));
	if( mvars.rgb )  {
		RGBcolor( (short)glx_rgbtab[colour].r,
		    (short)glx_rgbtab[colour].g,
		    (short)glx_rgbtab[colour].b );
	} else {
		color( MAP_ENTRY(colour) );
	}
	charstr( str );
}

/*
 *			I R _ 2 D _ L I N E
 *
 */
void
Glx_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	register int nvec;

	if (mvars.debug)
	  Tcl_AppendResult(interp, "Glx_2d_line()\n", (char *)NULL);

	if( mvars.rgb )  {
		/* Yellow */
		if(mvars.cueing_on)  {
			lRGBrange(
			    255, 255, 0,
			    255, 255, 0,
			    mvars.min_scr_z, mvars.max_scr_z );
		}
		RGBcolor( (short)255, (short)255, (short) 0 );
	} else {
		if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
			if(mvars.cueing_on) lshaderange(nvec, nvec,
			    mvars.min_scr_z, mvars.max_scr_z );
			color( nvec );
			ovec = nvec;
		}
	}

	if( dashed )
		setlinestyle(1);	/* into dot-dash */

	move2( GED2IRIS(x1), GED2IRIS(y1));
	draw2( GED2IRIS(x2), GED2IRIS(y2));

	if( dashed )
		setlinestyle(0);	/* restore to solid */
}

/*
 *			I R _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream, or a device event has
 * occured, unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
Glx_input( input, noblock )
fd_set		*input;
int		noblock;
{
  return;
}


/*
   This routine does not handle mouse button or key events. The key
   events are being processed via the TCL/TK bind command or are being
   piped to ged.c/stdin_input(). Eventually, I'd also like to have the
   dials+buttons bindable. That would leave this routine to handle only
   events like Expose and ConfigureNotify.
*/
int
Glx_doevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  static int button0  = 0;   /*  State of button 0 */
  static int knobs_during_help[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  static int knob_values[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  register struct dm_list *save_dm_list;
  register struct dm_list *p;
  struct bu_vls cmd;
  int status = CMD_OK;

  bu_vls_init(&cmd);
  save_dm_list = curr_dm_list;

  curr_dm_list = get_dm_list(eventPtr->xany.window);

  if(curr_dm_list == DM_LIST_NULL)
    goto end;

  if(mged_variables.send_key && eventPtr->type == KeyPress){
    char buffer[1];
    KeySym keysym;

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  &keysym, (XComposeStatus *)NULL);

    if(keysym == mged_variables.hot_key)
      goto end;

    write(dm_pipe[1], buffer, 1);
    bu_vls_free(&cmd);
    curr_dm_list = save_dm_list;

    /* Use this so that these events won't propagate */
    return TCL_RETURN;
  }

  /* Now getting X events */
  if(eventPtr->type == Expose && eventPtr->xexpose.count == 0){
    /* Window may have moved */
    Glx_configure_window_shape();

    dirty = 1;
    refresh();
    goto end;
  }else if( eventPtr->type == ConfigureNotify ){
      /* Window may have moved */
      Glx_configure_window_shape();

      dirty = 1;
      refresh();
      goto end;
  }else if( eventPtr->type == MotionNotify ) {
    int mx, my;

    mx = eventPtr->xmotion.x;
    my = eventPtr->xmotion.y;

    switch(am_mode){
    case ALT_MOUSE_MODE_IDLE:
      if(scroll_active && eventPtr->xmotion.state & mb_mask)
	bu_vls_printf( &cmd, "M 1 %d %d\n", irisX2ged(mx), irisY2ged(my));
      else if(GlxdoMotion)
	/* do the regular thing */
	/* Constant tracking (e.g. illuminate mode) bound to M mouse */
	bu_vls_printf( &cmd, "M 0 %d %d\n", irisX2ged(mx), irisY2ged(my));
      else
	goto end;

      break;
    case ALT_MOUSE_MODE_ROTATE:
      bu_vls_printf( &cmd, "iknob ax %f ay %f\n",
		     (my - omy)/512.0, (mx - omx)/512.0 );
      break;
    case ALT_MOUSE_MODE_TRANSLATE:
      {
	fastf_t fx, fy;

	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	  (edobj || es_edflag > 0)){
	  fx = (mx/(fastf_t)winx_size - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)winy_size) * 2;
	  bu_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy );
	}else{
	  fx = (mx - omx)/(fastf_t)winx_size * 2.0;
	  fy = (omy - my)/(fastf_t)winy_size * 2.0;
	  bu_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy );
	}
      }	     
      break;
    case ALT_MOUSE_MODE_ZOOM:
      bu_vls_printf( &cmd, "iknob aS %f\n", (omy - my)/(fastf_t)winy_size);
      break;
    }

    omx = mx;
    omy = my;
  }
#if IR_KNOBS
  else if( eventPtr->type == devmotionnotify ){
    XDeviceMotionEvent *M;
    int setting;

    M = (XDeviceMotionEvent * ) eventPtr;

    if(button0){
      glx_dbtext(
		(mged_variables.adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
      goto end;
    }

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(mged_variables.adcflag) {
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	                !dv_1adc )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol(dv_1adc) +
	                  M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob ang1 %d\n",
		      setting );
      }
      break;
    case DIAL1:
      if(mged_variables.rateknobs){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !rate_zoom )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_zoom)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob S %f\n",
		       setting / 512.0 );
      }else{
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !absolute_zoom )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_zoom)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob aS %f\n",
		       setting / 512.0 );
      }
      break;
    case DIAL2:
      if(mged_variables.adcflag){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	                !dv_2adc )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol(dv_2adc) +
	                  M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob ang2 %d\n",
		      setting );
      }else {
	if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_rotate[Z] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_rotate[Z])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob z %f\n",
		      setting / 512.0 );
	}else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[Z] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_rotate[Z])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob az %f\n",
			 setting / 512.0 );
	}
      }
      break;
    case DIAL3:
      if(mged_variables.adcflag){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !dv_distadc)
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol(dv_distadc) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob distadc %d\n",
		      setting );
      }else {
	if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_slew[Z] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_slew[Z])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob Z %f\n",
			 setting / 512.0 );
	}else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_slew[Z] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_slew[Z])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob aZ %f\n",
			 setting / 512.0 );
	}
      }
      break;
    case DIAL4:
      if(mged_variables.adcflag){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !dv_yadc)
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol(dv_yadc) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob yadc %d\n",
		      setting );
      }else{
	if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_rotate[Y] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_rotate[Y])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob y %f\n",
			 setting / 512.0 );
	}else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[Y] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_rotate[Y])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob ay %f\n",
			 setting / 512.0 );
	}
      }
      break;
    case DIAL5:
      if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_slew[Y] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_slew[Y])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob Y %f\n",
		       setting / 512.0 );
      }else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_slew[Y] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_slew[Y])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob aY %f\n",
		       setting / 512.0 );
      }
      break;
    case DIAL6:
      if(mged_variables.adcflag){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !dv_xadc)
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol(dv_xadc) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob xadc %d\n",
		      setting );
      }else{
	if(mged_variables.rateknobs){
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !rate_rotate[X] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_rotate[X])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob x %f\n",
			 setting / 512.0 );
	}else{
	  if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	     !absolute_rotate[X] )
	    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	  else
	    knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_rotate[X])) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = irlimit(knobs[M->first_axis]);
	  bu_vls_printf( &cmd , "knob ax %f\n",
			 setting / 512.0 );
	}
      }
      break;
    case DIAL7:
      if(mged_variables.rateknobs){
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !rate_slew[X] )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol((int)(512.5 * rate_slew[X])) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob X %f\n",
		       setting / 512.0 );
      }else{
	if(-NOISE < knobs[M->first_axis] && knobs[M->first_axis] < NOISE &&
	   !absolute_slew[X] )
	  knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
	else
	  knobs[M->first_axis] = Glx_add_tol((int)(512.5 * absolute_slew[X])) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = irlimit(knobs[M->first_axis]);
	bu_vls_printf( &cmd , "knob aX %f\n",
		       setting / 512.0 );
      }
      break;
    default:
      break;
    }

    /* Keep track of the knob values */
    knob_values[M->first_axis] = M->axis_data[0];
  }
#endif
#if IR_BUTTONS
  else if( eventPtr->type == devbuttonpress ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      button0 = 1;
      goto end;
    }

    if(button0){
      glx_dbtext(label_button(bmap[B->button - 1]));
    }else if(B->button == 4){
      bu_vls_strcat(&cmd, "knob zero\n");
      set_knob_offset();
    }else
      bu_vls_printf(&cmd, "press %s\n",
		    label_button(bmap[B->button - 1]));
  }else if( eventPtr->type == devbuttonrelease ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1)
      button0 = 0;

    goto end;
  }
#endif
  else
    goto end;

  status = cmdline(&cmd, FALSE);
end:
  bu_vls_free(&cmd);
  curr_dm_list = save_dm_list;

  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
}


/* 
 *			I R _ L I G H T
 *
 * This function must keep both the light hardware, and the software
 * copy of the lights up to date.  Note that requests for light changes
 * may not actually cause the lights to be changed, depending on
 * whether the buttons are being used for "view" or "edit" functions
 * (although this is not done in the present code).
 */
void
Glx_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	register unsigned short bit;
#ifdef IR_BUTTONS
	/* Check for BE_ function not assigned to a button */
	if( (bit = invbmap[func]) == 0 && cmd != LIGHT_RESET )
		return;
	switch( cmd )  {
	case LIGHT_RESET:
		lights = 0;
		break;
	case LIGHT_ON:
		lights |= 1<<bit;
		break;
	case LIGHT_OFF:
		lights &= ~(1<<bit);
		break;
	}

	/* Update the lights box. */
#if !defined(__sgi)	/* This bombs, on early Irix 4.0 releases */
	setdblights( lights );
#endif
#endif
}

/*
 *			I R _ C V T V E C S
 *
 */
unsigned
Glx_cvtvecs( sp )
register struct solid *sp;
{
	return( 0 );	/* No "displaylist" consumed */
}

/*
 * Loads displaylist from storage[]
 */
unsigned
Glx_load( addr, count )
unsigned addr, count;
{
	return( 0 );		/* FLAG:  error */
}

void
Glx_statechange( a, b )
{
  if( mvars.debug ){
    struct bu_vls tmp_vls;

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "statechange %d %d\n", a, b );
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }

  /*
   *  Based upon new state, possibly do extra stuff,
   *  including enabling continuous tablet tracking,
   *  object highlighting
   */
 	switch( b )  {
	case ST_VIEW:
	  /* constant tracking OFF */
	  GlxdoMotion = 0;
	  break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	case ST_S_VPICK:
	  /* constant tracking ON */
	  GlxdoMotion = 1;
	  break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	  /* constant tracking OFF */
	  GlxdoMotion = 0;
	  break;
	default:
	  Tcl_AppendResult(interp, "Glx_statechange: unknown state ",
			   state_str[b], "\n", (char *)NULL);
	  break;
	}

	Glx_viewchange( DM_CHGV_REDO, SOLID_NULL );
}

void
Glx_viewchange( cmd, sp )
register int cmd;
register struct solid *sp;
{
  if( mvars.debug ){
    struct bu_vls tmp_vls;

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "viewchange( %d, x%x )\n", cmd, sp );
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }

  switch( cmd ){
  case DM_CHGV_ADD:
    break;
  case DM_CHGV_REDO:
    break;
  case DM_CHGV_DEL:
    break;
  case DM_CHGV_REPL:
    return;
  case DM_CHGV_ILLUM:
    break;
  }
}

void
Glx_debug(lvl)
{
	mvars.debug = lvl;
}

void
Glx_window(w)
int w[];
{
}


/*
 *  			I R _ C O L O R C H A N G E
 *  
 *  Go through the solid table, and allocate color map slots.
 *	8 bit system gives 4 or 8,
 *	24 bit system gives 12 or 24.
 */
void
Glx_colorchange()
{
	register int i;
	register int nramp;

	if( mvars.debug )
	  Tcl_AppendResult(interp, "colorchange\n", (char *)NULL);

	/* Program the builtin colors */
	glx_rgbtab[0].r=0; 
	glx_rgbtab[0].g=0; 
	glx_rgbtab[0].b=0;/* Black */
	glx_rgbtab[1].r=255; 
	glx_rgbtab[1].g=0; 
	glx_rgbtab[1].b=0;/* Red */
	glx_rgbtab[2].r=0; 
	glx_rgbtab[2].g=0; 
	glx_rgbtab[2].b=255;/* Blue */
	glx_rgbtab[3].r=255; 
	glx_rgbtab[3].g=255;
	glx_rgbtab[3].b=0;/*Yellow */
	glx_rgbtab[4].r = glx_rgbtab[4].g = glx_rgbtab[4].b = 255; /* White */
	slotsused = 5;

	if( mvars.rgb )  {
		if(mvars.cueing_on) {
			depthcue(1);
		} else {
			depthcue(0);
		}

		RGBcolor( (short)255, (short)255, (short)255 );

		/* apply region-id based colors to the solid table */
		color_soltab();

		return;
	}

	glx_nslots = getplanes();
	if(mvars.cueing_on && (glx_nslots < 7)) {
	  Tcl_AppendResult(interp, "Too few bitplanes: depthcueing disabled\n", (char *)NULL);
	  mvars.cueing_on = 0;
	}
	glx_nslots = 1<<glx_nslots;
	if( glx_nslots > NSLOTS )  glx_nslots = NSLOTS;
	if(mvars.cueing_on) {
		/* peel off reserved ones */
		glx_nslots = (glx_nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
		depthcue(1);
	} else {
		glx_nslots -= CMAP_BASE;	/* peel off the reserved entries */
		depthcue(0);
	}

	ovec = -1;	/* Invalidate the old colormap entry */

	/* apply region-id based colors to the solid table */
	color_soltab();

	/* Map the colors in the solid table to colormap indices */
	glx_colorit();

	for( i=0; i < slotsused; i++ )  {
		glx_gen_color( i, glx_rgbtab[i].r, glx_rgbtab[i].g, glx_rgbtab[i].b);
	}

	color(WHITE);	/* undefinied after gconfig() */
}

void
glx_colorit()
{
	register struct solid	*sp;
	register struct rgbtab *rgb;
	register int i;
	register int r,g,b;

	if( mvars.rgb )  return;

	FOR_ALL_SOLIDS( sp )  {
		r = sp->s_color[0];
		g = sp->s_color[1];
		b = sp->s_color[2];
		if( (r == 255 && g == 255 && b == 255) ||
		    (r == 0 && g == 0 && b == 0) )  {
			sp->s_dmindex = DM_WHITE;
			continue;
		}

		/* First, see if this matches an existing color map entry */
		rgb = glx_rgbtab;
		for( i = 0; i < slotsused; i++, rgb++ )  {
			if( rgb->r == r && rgb->g == g && rgb->b == b )  {
				sp->s_dmindex = i;
				goto next;
			}
		}

		/* If slots left, create a new color map entry, first-come basis */
		if( slotsused < glx_nslots )  {
			rgb = &glx_rgbtab[i=(slotsused++)];
			rgb->r = r;
			rgb->g = g;
			rgb->b = b;
			sp->s_dmindex = i;
			continue;
		}
		sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		
		;
	}
}

/*
 *  I R _ D B T E X T
 *
 *  Used to call dbtext to print cute messages on the button box,
 *  if you have one.  Has to shift everythign to upper case
 *  since the box goes off the deep end with lower case.
 *
 *  Because not all SGI button boxes have text displays,
 *  this now needs to go to stdout in order to be useful.
 */

glx_dbtext(str)
register char *str;
{
#if IR_BUTTONS
	register i;
	char	buf[9];
	register char *cp;

	Tcl_AppendResult(interp, "dm-glx: You pressed Help key and '",
			 str, "'\n", (char *)NULL);
#else
	return;
#endif
}

#if IR_KNOBS
/*
 *			I R L I M I T
 *
 * Because the dials are so sensitive, setting them exactly to
 * zero is very difficult.  This function can be used to extend the
 * location of "zero" into "the dead zone".
 */
static int
irlimit(i)
int i;
{
	if( i > NOISE )
		return( i-NOISE );
	if( i < -NOISE )
		return( i+NOISE );
	return(0);
}

static int
Glx_add_tol(i)
int i;
{
  if( i > 0 )
    return( i + NOISE );
  if( i < 0 )
    return( i - NOISE );
  return(0);
}
#endif

/*			G E N _ C O L O R
 *
 *	maps a given color into the appropriate colormap entry
 *	for both depthcued and non-depthcued mode.  In depthcued mode,
 *	glx_gen_color also generates the colormap ramps.  Note that in depthcued
 *	mode, DM_BLACK uses map entry 0, and does not generate a ramp for it.
 *	Non depthcued mode skips the first CMAP_BASE colormap entries.
 *
 *	This routine is not called at all if mvars.rgb is set.
 */
glx_gen_color(c)
int c;
{
  return 0;
}

#ifdef never
/*
 *  Update the PF key lights.
 */
static int
kblights()
{
	char	lights;

	lights = (mvars.cueing_on)
	    | (mvars.zclipping_on << 1)
	    | (mvars.perspective_mode << 2)
	    | (mvars.zbuffer_on << 3);

	lampon(lights);
	lampoff(lights^0xf);
}
#endif

static void
establish_perspective()
{
  bu_vls_printf( &dm_values.dv_string,
		"set perspective %d\n",
		mvars.perspective_mode ?
		perspective_table[perspective_angle] :
		-1 );
  dmaflag = 1;
}

/*
   This routine will toggle the perspective_angle if the
   dummy_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (dummy_perspective - 1).
*/
static void
set_perspective()
{
  /* set perspective matrix */
  if(mvars.dummy_perspective > 0)
    perspective_angle = mvars.dummy_perspective <= 4 ? mvars.dummy_perspective - 1: 3;
  else if (--perspective_angle < 0) /* toggle perspective matrix */
    perspective_angle = 3;

  if(mvars.perspective_mode)
    bu_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[perspective_angle] );

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  mvars.dummy_perspective = 1;

  dmaflag = 1;
}

static void
establish_zbuffer()
{
	if( mvars.zbuf == 0 )  {
	  Tcl_AppendResult(interp, "dm-4d: This machine has no Zbuffer to enable\n",
			   (char *)NULL);
	  mvars.zbuffer_on = 0;
	}
	zbuffer( mvars.zbuffer_on );
	if( mvars.zbuffer_on)  {
	  /* Set screen coords of near and far clipping planes */
	  lsetdepth(mvars.min_scr_z, mvars.max_scr_z);
	}
	dmaflag = 1;
}

static void
establish_am()
{
  return;
}

glx_clear_to_black()
{
	/* Re-enable the full viewport */
	viewport(0, winx_size, 0, winy_size);

	if( mvars.zbuffer_on )  {
		zfunction( ZF_LEQUAL );
		if( mvars.rgb )  {
			czclear( 0x000000, mvars.max_scr_z );
		} else {
			czclear( BLACK, mvars.max_scr_z );
		}
	} else {
		if( mvars.rgb )  {
			RGBcolor( (short)0, (short)0, (short)0 );
		} else {
			color(BLACK);
		}
		clear();
	}
}

#if 0
/* Handy fakeouts when we don't want to link with -lmpc */
usinit()	{ 
	bu_log("usinit\n"); 
}
usnewlock()	{ 
	bu_log("usnewlock\n"); 
}
taskcreate()	{ 
	bu_log("taskcreate\n"); 
}
#endif

/*
 *  The struct_parse will change the value of the variable.
 *  Just implement it, here.
 */
static void
establish_lighting()
{
	if( !mvars.lighting_on )  {
		/* Turn it off */
		mmode(MVIEWING);
		lmbind(MATERIAL,0);
		lmbind(LMODEL,0);
		mmode(MSINGLE);
	} else {
		/* Turn it on */
		if( mvars.cueing_on )  {
			/* Has to be off for lighting */
			mvars.cueing_on = 0;
			Glx_colorchange();
		}

		mmode(MVIEWING);


		glx_make_materials();	/* Define material properties */

		lmbind(LMODEL, 2);	/* infinite */
		lmbind(LIGHT2,2);
		lmbind(LIGHT3,3);
		lmbind(LIGHT4,4);
		lmbind(LIGHT5,5);

		/* RGB color commands & lighting */
		lmcolor( LMC_COLOR );

		mmode(MSINGLE);
	}
	dmaflag = 1;
}

/*
 *  Some initial lighting model stuff
 *  Really, MGED needs to derrive it's lighting from the database,
 *  but for now, this hack will suffice.
 *
 *  For materials, the definitions are:
 *	ALPHA		opacity.  1.0=opaque
 *	AMBIENT		ambient reflectance of the material  0..1
 *	DIFFUSE		diffuse reflectance of the material  0..1
 *	SPECULAR	specular reflectance of the material  0..1
 *	EMISSION	emission color ???
 *	SHININESS	specular scattering exponent, integer 0..128
 */
static float material_default[] = {
	ALPHA,		1.0,
	AMBIENT,	0.2, 0.2, 0.2,
	DIFFUSE,	0.8, 0.8, 0.8,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	0.0,
	SPECULAR,	0.0, 0.0, 0.0,
	LMNULL   };

/* Something like the RT default phong material */
static float material_rtdefault[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/* This was the "default" material in the demo */
static float material_xdefault[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_brass[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_shinybrass[] = {
	AMBIENT, 0.25, 0.15, 0.0,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.9, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_pewter[] = {
	AMBIENT, 0.0, 0.0,  0.0,
	DIFFUSE, 0.6, 0.55 , 0.65,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 10.0,
	LMNULL   };

static float mat_silver[] = {
	AMBIENT, 0.4, 0.4,  0.4,
	DIFFUSE, 0.3, 0.3, 0.3,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 30.0,
	LMNULL   };

static float mat_gold[] = {
	AMBIENT, 0.4, 0.2, 0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.7, 0.7, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_shinygold[] = {
	AMBIENT, 0.4, 0.2,  0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.9, 0.9, 0.0,
	SHININESS, 20.0,
	LMNULL   };

static float mat_plaster[] = {
	AMBIENT, 0.2, 0.2,  0.2,
	DIFFUSE, 0.95, 0.95, 0.95,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL   };

static float mat_redplastic[] = {
	AMBIENT, 0.3, 0.1, 0.1,
	DIFFUSE, 0.5, 0.1, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenplastic[] = {
	AMBIENT, 0.1, 0.3, 0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_blueplastic[] = {
	AMBIENT, 0.1, 0.1, 0.3,
	DIFFUSE, 0.1, 0.1, 0.5,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenflat[] = {
	EMISSION,   0.0, 0.4, 0.0,
	AMBIENT,    0.0, 0.0, 0.0,
	DIFFUSE,    0.0, 0.0, 0.0,
	SPECULAR,   0.0, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_greenshiny[]= {
	EMISSION, 0.0, 0.4, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.25, 0.9, 0.25,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueflat[] = {
	EMISSION, 0.0, 0.0, 0.4,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.0, 0.5, 0.5,
	SPECULAR,  0.0, 0.0, 0.9,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueshiny[] = {
	EMISSION, 0.0, 0.0, 0.6,
	AMBIENT,  0.1, 0.25, 0.5,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_redflat[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL
};

static float mat_redshiny[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_beigeshiny[] = {
	EMISSION, 0.5, 0.5, 0.6,
	AMBIENT,  0.35, 0.35, 0.0,
	DIFFUSE,  0.5, 0.5, 0.0,
	SPECULAR,  0.5, 0.5, 0.0,
	SHININESS, 10.0,
	LMNULL
};

/*
 *  Meanings of the parameters:
 *	AMBIENT		ambient light associated with this source ???, 0..1
 *	LCOLOR		light color, 0..1
 *	POSITION	position of light.  w=0 for infinite lights
 */
static float default_light[] = {
	AMBIENT,	0.0, 0.0, 0.0, 
	LCOLOR,		1.0, 1.0, 1.0, 
	POSITION,	0.0, 0.0, 1.0, 0.0,
	LMNULL};


#if 1
# if 0
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, -200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, -100.0, -30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, 100.0, -20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, 100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, 200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, 100.0, 30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, -100.0, 20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, -100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# endif

#else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 10.0, 50.0, 50.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.5, 0.1, 0.1, 
	POSITION, -100.0, 0.0, 0.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.5, 0.1, 
	POSITION, 100.0, 50.0, 0.0, 0.0, 
	LMNULL};

static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.5, 
	POSITION, 0.0, -50.0, 0.0, 0.0, 
	LMNULL};

static float orange_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,	0.35, 0.175, 0.0, 
	POSITION, -50.0, 50.0, 10.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};


#endif




/*
 *  Lighting model parameters
 *	AMBIENT		amount of ambient light present in the scene, 0..1
 *	ATTENUATION	fixed and variable attenuation factor, 0..1
 *	LOCALVIEWER	1=eye at (0,0,0), 0=eye at (0,0,+inf)
 */
static float	default_lmodel[] = {
	AMBIENT,	0.2,  0.2,  0.2,
	ATTENUATION,	1.0, 0.0, 
	LOCALVIEWER,	0.0, 
	LMNULL};

static float infinite[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 0.0, 
	LMNULL};

static float local[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 1.0, 
	ATTENUATION, 1.0, 0.0, 
	LMNULL};


glx_make_materials()
{
	/* define material properties */
	lmdef (DEFMATERIAL, 1, 0, material_default);

	lmdef (DEFMATERIAL, 2, 0, mat_brass);
	lmdef (DEFMATERIAL, 3, 0, mat_shinybrass);
	lmdef (DEFMATERIAL, 4, 0, mat_pewter);
	lmdef (DEFMATERIAL, 5, 0, mat_silver);
	lmdef (DEFMATERIAL, 6, 0, mat_gold);
	lmdef (DEFMATERIAL, 7, 0, mat_shinygold);
	lmdef (DEFMATERIAL, 8, 0, mat_plaster);
	lmdef (DEFMATERIAL, 9, 0, mat_redplastic);
	lmdef (DEFMATERIAL, 10, 0, mat_greenplastic);
	lmdef (DEFMATERIAL, 11, 0, mat_blueplastic);

	lmdef (DEFMATERIAL, 12, 0, mat_greenflat);
	lmdef (DEFMATERIAL, 13, 0, mat_greenshiny);

	lmdef (DEFMATERIAL, 14, 0, mat_blueflat);
	lmdef (DEFMATERIAL, 15, 0, mat_blueshiny);

	lmdef (DEFMATERIAL, 16, 0, mat_redflat);
	lmdef (DEFMATERIAL, 17, 0, mat_redshiny);

	lmdef (DEFMATERIAL, 18, 0, mat_beigeshiny);

	lmdef( DEFMATERIAL, 19, 0, material_xdefault );
	lmdef( DEFMATERIAL, 20, 0, material_rtdefault );

	/*    lmdef (DEFLIGHT, 1, 0, default_light); */
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 2, 0, white_inf_light);
	lmdef (DEFLIGHT, 3, 0, red_inf_light);
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 5, 0, blue_inf_light);
	/*    lmdef (DEFLIGHT, 6, 0, orange_inf_light); */
	lmdef (DEFLIGHT, 7, 0, white_local_light);

	lmdef (DEFLMODEL, 1, 0, default_lmodel);
	lmdef (DEFLMODEL, 2, 0, infinite);
	lmdef (DEFLMODEL, 3, 0, local);


}

/*
 *  Check to see if setmonitor(STR_RECT) will work.
 *  Returns -
 *	> 0	If stereo is available
 *	0	If not
 */
int
glx_has_stereo()
{
#if !defined(__sgi) && !defined(__mips)
	/* IRIX 3 systems, test to see if DER1_STEREO bit is
	 * read/write (no hardware underneath), or
	 * read only (hardware underneath, which can't be read back.
	 */
	int	rw_orig, rw1, rw2;

	rw_orig = getvideo(DE_R1);
	rw1 = rw_orig ^ DER1_STEREO;	/* Toggle the bit */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	rw1 = rw1 ^ DER1_STEREO;	/* Toggle the bit, again */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	setvideo(DE_R1, rw_orig);	/* Restore original state */
	return 0;			/* Does not have stereo */
#else
	/* IRIX 4 systems */
	return getgdesc(GD_STEREO);
#endif
}

/*
 *			I R _ D M
 * 
 *  Implement display-manager specific commands, from MGED "dm" command.
 */
int
Glx_dm(argc, argv)
int	argc;
char	**argv;
{
  struct bu_vls	vls;
  int status;
  char *av[4];
  char xstr[32];
  char ystr[32];
  char zstr[32];

  if( !strcmp( argv[0], "set" )){
    struct bu_vls tmp_vls;

    bu_vls_init(&vls);
    bu_vls_init(&tmp_vls);
    start_catching_output(&tmp_vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      bu_struct_print("dm_4d internal variables", Glx_vparse, (CONST char *)&mvars );
    } else if( argc == 2 ) {
      bu_vls_struct_item_named( &vls, Glx_vparse, argv[1], (CONST char *)&mvars, ',');
      bu_log( "%s\n", bu_vls_addr(&vls) );
    } else {
      bu_vls_printf( &vls, "%s=\"", argv[1] );
      bu_vls_from_argv( &vls, argc-2, argv+2 );
      bu_vls_putc( &vls, '\"' );
      bu_struct_parse( &vls, Glx_vparse, (char *)&mvars);
    }

    bu_vls_free(&vls);

    stop_catching_output(&tmp_vls);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
    return TCL_OK;
  }

  if( !strcmp( argv[0], "m" )){
    scroll_active = 0;

    if( argc < 5){
      Tcl_AppendResult(interp, "dm m: need more parameters\n",
		       "m button 1|0 xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    /* This assumes a 3-button mouse */
    switch(*argv[1]){
    case '1':
      mb_mask = Button1Mask;
      break;
    case '2':
      mb_mask = Button2Mask;
      break;
    case '3':
      mb_mask = Button3Mask;
      break;
    default:
      Tcl_AppendResult(interp, "dm m: bad button value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d\n", argv[2],
		  irisX2ged(atoi(argv[3])), irisY2ged(atoi(argv[4])));
    status = cmdline(&vls, FALSE);
    bu_vls_free(&vls);

    if(status == CMD_OK)
      return TCL_OK;

    return TCL_ERROR;
  }

  status = TCL_OK;
  if( !strcmp( argv[0], "am" )){
    int buttonpress;

    scroll_active = 0;
    
    if( argc < 5){
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    buttonpress = atoi(argv[2]);
    omx = atoi(argv[3]);
    omy = atoi(argv[4]);

    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	am_mode = ALT_MOUSE_MODE_ROTATE;
	break;
      case 't':
	am_mode = ALT_MOUSE_MODE_TRANSLATE;
	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
	  fastf_t fx, fy;

	  bu_vls_init(&vls);
	  fx = (omx/(fastf_t)winx_size - 0.5) * 2;
	  fy = (0.5 - omy/(fastf_t)winy_size) * 2;
	  bu_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	  (void)cmdline(&vls, FALSE);
	  bu_vls_free(&vls);
	}

	break;
      case 'z':
	am_mode = ALT_MOUSE_MODE_ZOOM;
	break;
      default:
	Tcl_AppendResult(interp, "dm am: need more parameters\n",
			 "am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
    }else
      am_mode = ALT_MOUSE_MODE_IDLE;

    return status;
  }

  Tcl_AppendResult(interp, "dm: bad command - ", argv[0], "\n", (char *)NULL);
  return TCL_ERROR;
}

static void
set_knob_offset()
{
  int i;

  for(i = 0; i < 8; ++i)
    knobs[i] = 0;
}

static void
glx_var_init()
{
  dm_vars = bu_malloc(sizeof(struct glx_vars), "glx_var_init: glx_vars");
  bzero((void *)dm_vars, sizeof(struct glx_vars));
  devmotionnotify = LASTEvent;
  devbuttonpress = LASTEvent;
  devbuttonrelease = LASTEvent;
  ((struct glx_vars *)dm_vars)->dm_list = curr_dm_list;
  perspective_angle = 3;

  /* initialize the modifiable variables */
  mvars.cueing_on = 1;          /* Depth cueing flag - for colormap work */
  mvars.zclipping_on = 1;       /* Z Clipping flag */
  mvars.zbuffer_on = 1;         /* Hardware Z buffer is on */
  mvars.linewidth = 1;      /* Line drawing width */
  mvars.dummy_perspective = 1;
}


static struct dm_list *
get_dm_list(window)
Window window;
{
  register struct glx_vars *p;

  for( BU_LIST_FOR(p, glx_vars, &head_glx_vars.l) ){
    if(window == p->_win){
      GLXwinset(p->_dpy, p->_win);
      return p->dm_list;
    }
  }

  return DM_LIST_NULL;
}

static unsigned long
extract_value(buffer, mode, conf)
int buffer;
int mode;
GLXconfig *conf;
{
  int i;

  for (i = 0; conf[i].buffer; i++)
    if (conf[i].buffer == buffer && conf[i].mode == mode)
      return conf[i].arg;

  return 0;
}

/* Extract X visual information */
static XVisualInfo*
extract_visual(buffer, conf)
int buffer;
GLXconfig *conf;
{
  XVisualInfo template, *v;
  int n;

  template.screen = Tk_ScreenNumber(xtkwin);
  template.visualid = extract_value(buffer, GLX_VISUAL, conf);

  return XGetVisualInfo(dpy, VisualScreenMask|VisualIDMask, &template, &n);
}

/* 
 * Fill the configuration structure with the appropriately
 * created window
 */
static void
set_window(buffer, _win, conf)
int buffer;
Window _win;
GLXconfig *conf;
{
  int i;

  for (i = 0; conf[i].buffer; i++)
    if (conf[i].buffer == buffer && conf[i].mode == GLX_WINDOW)
      conf[i].arg = _win;
}
#endif
@


1.30
log
@rt_list ---> bu_list
@
text
@d28 1
a28 1
 *  was modified to use the glx widget.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.29 1996/09/03 15:52:52 bparker Exp bparker $ (BRL)";
d80 816
d999 1
a999 1
static int GLXdoMotion = 0;
d1086 1
a1086 1
	Glx_window, Glx_debug,
d1092 3
a1094 1
	Glx_dm
a1253 4
  /* Only need to do this once */
  if(tkwin == NULL)
    gui_setup();

d1261 1
a1261 1
  BU_LIST_APPEND(&head_glx_vars.l, &((struct glx_vars *)curr_dm_list->_dm_vars)->l);
d2032 1
a2032 1
      else if(GLXdoMotion)
d2455 1
a2455 1
	  GLXdoMotion = 0;
d2462 1
a2462 1
	  GLXdoMotion = 1;
d2467 1
a2467 1
	  GLXdoMotion = 0;
d3502 1
@


1.29
log
@check in Lee's changes
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.28 1996/08/29 23:13:21 butler Exp butler $ (BRL)";
d71 1
a72 1
#include "bu.h"
d159 1
a159 1
  struct rt_list l;
d444 1
a444 1
  if(RT_LIST_IS_EMPTY(&head_glx_vars.l))
d447 1
a447 1
  RT_LIST_APPEND(&head_glx_vars.l, &((struct glx_vars *)curr_dm_list->_dm_vars)->l);
d643 1
a643 1
  RT_LIST_INIT( &head_glx_vars.l );
d682 2
a683 2
  if(((struct glx_vars *)dm_vars)->l.forw != RT_LIST_NULL)
    RT_LIST_DEQUEUE(&((struct glx_vars *)dm_vars)->l);
d687 1
a687 1
  if(RT_LIST_IS_EMPTY(&head_glx_vars.l))
d985 1
a985 1
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d2632 1
a2632 1
  for( RT_LIST_FOR(p, glx_vars, &head_glx_vars.l) ){
@


1.28
log
@structparse moved to libbu
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.27 1996/08/28 19:44:38 bparker Exp butler $ (BRL)";
d2016 1
a2016 1
 *  The structparse will change the value of the variable.
d2487 1
a2487 1
      bu_structprint("dm_4d internal variables", Glx_vparse, (CONST char *)&mvars );
d2489 1
a2489 1
      bu_vls_name_print( &vls, Glx_vparse, argv[1], (CONST char *)&mvars );
d2495 1
a2495 1
      bu_structparse( &vls, Glx_vparse, (char *)&mvars);
@


1.27
log
@move alt_mouse_mode to dm.h and call it _am_mode
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.26 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d72 1
d297 1
a297 1
struct structparse Glx_vparse[] = {
d2487 1
a2487 1
      rt_structprint("dm_4d internal variables", Glx_vparse, (CONST char *)&mvars );
d2489 1
a2489 1
      rt_vls_name_print( &vls, Glx_vparse, argv[1], (CONST char *)&mvars );
d2495 1
a2495 1
      rt_structparse( &vls, Glx_vparse, (char *)&mvars);
@


1.26
log
@now using libbu
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.25 1996/08/14 20:28:30 bparker Exp bparker $ (BRL)";
a154 1
  int alt_mouse_mode;
a309 1
	{"%d",  1, "alt_mouse_mode",	GLX_MV_O(alt_mouse_mode),establish_am },
d1213 2
a1214 3
    switch(mvars.alt_mouse_mode){
    case ALT_MOUSE_MODE_OFF:
    case ALT_MOUSE_MODE_ON:
d2561 1
a2561 1
	mvars.alt_mouse_mode = ALT_MOUSE_MODE_ROTATE;
d2564 1
a2564 1
	mvars.alt_mouse_mode = ALT_MOUSE_MODE_TRANSLATE;
d2579 1
a2579 1
	mvars.alt_mouse_mode = ALT_MOUSE_MODE_ZOOM;
d2587 1
a2587 1
      mvars.alt_mouse_mode = ALT_MOUSE_MODE_ON;
a2621 1
  mvars.alt_mouse_mode = 1;
@


1.25
log
@modified to not use the tkglx widget
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.24 1996/08/02 18:13:18 bparker Exp bparker $ (BRL)";
d424 1
a424 1
  struct rt_vls str;
d435 1
a435 1
  rt_vls_init(&str);
d450 2
a451 2
  rt_vls_printf(&pathName, ".dm_glx%d", count++);
  xtkwin = Tk_CreateWindowFromPath(interp, tkwin, rt_vls_addr(&pathName), name);
d456 2
a457 2
  rt_vls_strcpy(&str, "init_glx ");
  rt_vls_printf(&str, "%s\n", rt_vls_addr(&pathName));
d460 1
a460 1
    rt_vls_free(&str);
d464 1
a464 1
  rt_vls_free(&str);
d686 1
a686 1
  rt_free(dm_vars, "Glx_close: dm_vars");
d1165 1
a1165 1
  struct rt_vls cmd;
d1168 1
a1168 1
  rt_vls_init(&cmd);
d1187 1
a1187 1
    rt_vls_free(&cmd);
d1219 1
a1219 1
	rt_vls_printf( &cmd, "M 1 %d %d\n", irisX2ged(mx), irisY2ged(my));
d1223 1
a1223 1
	rt_vls_printf( &cmd, "M 0 %d %d\n", irisX2ged(mx), irisY2ged(my));
d1229 1
a1229 1
      rt_vls_printf( &cmd, "iknob ax %f ay %f\n",
d1240 1
a1240 1
	  rt_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy );
d1244 1
a1244 1
	  rt_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy );
d1249 1
a1249 1
      rt_vls_printf( &cmd, "iknob aS %f\n", (omy - my)/(fastf_t)winy_size);
d1280 1
a1280 1
	rt_vls_printf( &cmd, "knob ang1 %d\n",
d1294 1
a1294 1
	rt_vls_printf( &cmd , "knob S %f\n",
d1305 1
a1305 1
	rt_vls_printf( &cmd , "knob aS %f\n",
d1319 1
a1319 1
	rt_vls_printf( &cmd , "knob ang2 %d\n",
d1331 1
a1331 1
	  rt_vls_printf( &cmd , "knob z %f\n",
d1342 1
a1342 1
	  rt_vls_printf( &cmd , "knob az %f\n",
d1357 1
a1357 1
	rt_vls_printf( &cmd , "knob distadc %d\n",
d1369 1
a1369 1
	  rt_vls_printf( &cmd , "knob Z %f\n",
d1380 1
a1380 1
	  rt_vls_printf( &cmd , "knob aZ %f\n",
d1395 1
a1395 1
	rt_vls_printf( &cmd , "knob yadc %d\n",
d1407 1
a1407 1
	  rt_vls_printf( &cmd , "knob y %f\n",
d1418 1
a1418 1
	  rt_vls_printf( &cmd , "knob ay %f\n",
d1433 1
a1433 1
	rt_vls_printf( &cmd , "knob Y %f\n",
d1444 1
a1444 1
	rt_vls_printf( &cmd , "knob aY %f\n",
d1458 1
a1458 1
	rt_vls_printf( &cmd , "knob xadc %d\n",
d1470 1
a1470 1
	  rt_vls_printf( &cmd , "knob x %f\n",
d1481 1
a1481 1
	  rt_vls_printf( &cmd , "knob ax %f\n",
d1496 1
a1496 1
	rt_vls_printf( &cmd , "knob X %f\n",
d1507 1
a1507 1
	rt_vls_printf( &cmd , "knob aX %f\n",
d1533 1
a1533 1
      rt_vls_strcat(&cmd, "knob zero\n");
d1536 1
a1536 1
      rt_vls_printf(&cmd, "press %s\n",
d1554 1
a1554 1
  rt_vls_free(&cmd);
d1627 1
a1627 1
    struct rt_vls tmp_vls;
d1629 4
a1632 4
    rt_vls_init(&tmp_vls);
    rt_vls_printf(&tmp_vls, "statechange %d %d\n", a, b );
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d1672 1
a1672 1
    struct rt_vls tmp_vls;
d1674 4
a1677 4
    rt_vls_init(&tmp_vls);
    rt_vls_printf(&tmp_vls, "viewchange( %d, x%x )\n", cmd, sp );
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d1924 1
a1924 1
  rt_vls_printf( &dm_values.dv_string,
d1947 1
a1947 1
    rt_vls_printf( &dm_values.dv_string,
d2007 1
a2007 1
	rt_log("usinit\n"); 
d2010 1
a2010 1
	rt_log("usnewlock\n"); 
d2013 1
a2013 1
	rt_log("taskcreate\n"); 
d2473 1
a2473 1
  struct rt_vls	vls;
d2481 1
a2481 1
    struct rt_vls tmp_vls;
d2483 2
a2484 2
    rt_vls_init(&vls);
    rt_vls_init(&tmp_vls);
d2492 1
a2492 1
      rt_log( "%s\n", rt_vls_addr(&vls) );
d2494 3
a2496 3
      rt_vls_printf( &vls, "%s=\"", argv[1] );
      rt_vls_from_argv( &vls, argc-2, argv+2 );
      rt_vls_putc( &vls, '\"' );
d2500 1
a2500 1
    rt_vls_free(&vls);
d2503 2
a2504 2
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d2533 2
a2534 2
    rt_vls_init(&vls);
    rt_vls_printf(&vls, "M %s %d %d\n", argv[2],
d2537 1
a2537 1
    rt_vls_free(&vls);
d2572 1
a2572 1
	  rt_vls_init(&vls);
d2575 1
a2575 1
	  rt_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
d2577 1
a2577 1
	  rt_vls_free(&vls);
d2611 1
a2611 1
  dm_vars = rt_malloc(sizeof(struct glx_vars), "glx_var_init: glx_vars");
@


1.24
log
@changed VIRTUAL_TRACKBALL to ALT_MOUSE_MODE
@
text
@a30 3
 *      Paul R. Stay
 *      Michael John Muuss
 *      Robert J. Reschly
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.23 1996/07/25 17:47:03 bparker Exp bparker $ (BRL)";
a59 1
#include "tkGLX.h"
d119 3
a136 1
#define ref (((struct glx_vars *)dm_vars)->_ref)
d164 3
a176 1
  char _ref[32];
d183 8
d286 3
d418 1
a418 1
  static int ref_count = 0;
d432 2
a433 2
  GLXconfig *glx_config, *p;
  Display *tmp_dpy;
d442 1
a442 2
  if(!ref_count){
    (void)TkGLX_Init(interp, tkwin);
a443 1
  }
d450 8
a457 3
  rt_vls_printf(&pathName, ".dm_glx%d", ref_count++);
  strcpy(ref, rt_vls_addr(&pathName));
  rt_vls_strcat(&pathName, ".win"); 
d459 1
a459 1
  if((tmp_dpy = XOpenDisplay(name)) == NULL){
d464 5
a468 2
  winx_size = DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  winy_size = DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
d476 1
a476 1
  XCloseDisplay(tmp_dpy);
d478 7
a484 12
  /*
   * Create the glx widget by calling create_glx which
   * is defined in glxinit.tk
   */
  rt_vls_strcpy(&str, "create_glx ");
  rt_vls_printf(&str, "%s %s %s %s %d %d true true\n", name,
		ref, rt_vls_addr(&pathName), ref, winx_size, winy_size);

  if(cmdline(&str, FALSE) == CMD_BAD){
    rt_vls_free(&str);
    return -1;
  }
a485 17
  rt_vls_free(&str);

  if(TkGLXwin_RefExists(ref)){
    xtkwin = TkGLXwin_RefGetTkwin(ref);
    if(xtkwin == NULL)
      return -1;

    dpy = Tk_Display(xtkwin);
  }else{
    Tcl_AppendResult(interp, "Glx_open: ref - ", ref,
		     " doesn't exist!!!\n", (char *)NULL);
    return -1;
  }

  /* Do this now to force a GLXlink */
  Tk_MapWindow(xtkwin);

d488 1
d490 3
a492 1
  glx_is_gt = 1;
d494 1
a494 1
  glx_config = TkGLXwin_RefGetConfig(ref);
d572 1
d606 1
d612 1
d614 1
d619 1
a631 4
#if 0
  Tk_CreateGenericHandler(Glx_doevent,
			  (ClientData)curr_dm_list);
#endif
d633 1
a633 4
  /* start with constant tracking ON */
  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
	       KeyPressMask|StructureNotifyMask|PointerMotionMask|ButtonMotionMask);

a662 1
#if 1
d678 3
a680 3
#endif
/*XXX*/
    Tk_DestroyWindow(Tk_Parent(xtkwin));
a687 3
#if 0
  Tk_DeleteGenericHandler(Glx_doevent, (ClientData)NULL);
#else
a689 1
#endif
d703 1
a703 1
  TkGLXwin_RefWinset(ref, GLX_NORMAL);
d1220 1
a1220 2
      else if(state == ST_S_PICK || state == ST_O_PICK ||
	      state == ST_S_VPICK || state == ST_O_PICK)
d1255 3
a1257 1
  }else if( eventPtr->type == devmotionnotify ){
a1268 1
#if 1
d1517 1
a1517 86
#else
    setting = M->axis_data[0] - knob_values[M->first_axis];
    knob_values[M->first_axis] = M->axis_data[0];

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(mged_variables.adcflag) {
	rt_vls_printf( &cmd, "iknob ang1 %d\n",
		      setting );
      }
      break;
    case DIAL1:
      rt_vls_printf( &cmd , "iknob S %f\n",
		    setting / 2048.0 );
      break;
    case DIAL2:
      if(mged_variables.adcflag)
	rt_vls_printf( &cmd , "iknob ang2 %d\n",
		      setting );
      else {
	if(mged_variables.rateknobs)
	  rt_vls_printf( &cmd , "iknob z %f\n",
		      setting / 2048.0 );
	else
	  rt_vls_printf( &cmd , "iknob az %f\n",
		      setting / 512.0 );
      }
      break;
    case DIAL3:
      if(mged_variables.adcflag)
	rt_vls_printf( &cmd , "iknob distadc %d\n",
		      setting );
      else {
	if(mged_variables.rateknobs)
	  rt_vls_printf( &cmd , "iknob Z %f\n",
			 setting / 2048.0 );
	else
	  rt_vls_printf( &cmd , "iknob aZ %f\n",
			 setting / 512.0 );
      }
      break;
    case DIAL4:
      if(mged_variables.adcflag)
	rt_vls_printf( &cmd , "iknob yadc %d\n",
		      setting );
      else {
	if(mged_variables.rateknobs)
	  rt_vls_printf( &cmd , "iknob y %f\n",
			 setting / 2048.0 );
	else
	  rt_vls_printf( &cmd , "iknob ay %f\n",
			 setting / 512.0 );
      }
      break;
    case DIAL5:
      if(mged_variables.rateknobs)
	rt_vls_printf( &cmd , "iknob Y %f\n",
		       setting / 2048.0 );
      else
	rt_vls_printf( &cmd , "iknob aY %f\n",
		       setting / 512.0 );
      break;
    case DIAL6:
      if(mged_variables.adcflag)
	rt_vls_printf( &cmd , "iknob xadc %d\n",
		      setting );
      else {
	if(mged_variables.rateknobs)
	  rt_vls_printf( &cmd , "iknob x %f\n",
			 setting / 2048.0 );
	else
	  rt_vls_printf( &cmd , "iknob ax %f\n",
			 setting / 512.0 );
      }
      break;
    case DIAL7:
      if(mged_variables.rateknobs)
	rt_vls_printf( &cmd , "iknob X %f\n",
		       setting / 2048.0 );
      else
	rt_vls_printf( &cmd , "iknob aX %f\n",
		       setting / 512.0 );
      break;
    default:
      break;
    }
d1519 2
a1520 1
  }else if( eventPtr->type == devbuttonpress ){
d1547 3
a1549 1
  }else
d1634 1
a1634 1
    
a1641 1
	  if(!mvars.alt_mouse_mode)
d1643 1
a1643 2
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
		       KeyPressMask|StructureNotifyMask);
d1650 1
a1650 2
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
		       KeyPressMask|StructureNotifyMask|PointerMotionMask|ButtonMotionMask);
a1653 1
	  if(!mvars.alt_mouse_mode)
d1655 1
a1655 2
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
		       KeyPressMask|StructureNotifyMask);
a1847 6
# if 0
	for(i = 0, cp = buf; i < 8 && *str; i++, cp++, str++)
		*cp = islower(*str) ?  toupper(*str) : *str;
	*cp = 0;
	dbtext(buf);
# else
a1849 1
# endif
d1979 1
a1979 14
  if(mvars.alt_mouse_mode){
    if(state != ST_S_PICK && state != ST_O_PICK &&
       state != ST_O_PATH && state != ST_S_VPICK)
      /* turn constant tracking ON */
      XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
		   KeyPressMask|StructureNotifyMask|PointerMotionMask|ButtonMotionMask);
  }else{
    if(state != ST_S_PICK && state != ST_O_PICK &&
       state != ST_O_PATH && state != ST_S_VPICK)

      /* turn constant tracking OFF */
      XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
		   KeyPressMask|StructureNotifyMask);
  }
d2637 1
a2637 1
      TkGLXwin_RefWinset(p->_ref, GLX_NORMAL);
d2643 47
@


1.23
log
@-now using autoloading
-modified the translate/slew interface
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.22 1996/07/19 20:51:38 bparker Exp bparker $ (BRL)";
d157 1
a157 1
  int virtual_trackball;
d277 1
a277 1
static void     establish_vtb();
d300 1
a300 1
	{"%d",  1, "virtual_trackball",	GLX_MV_O(virtual_trackball),establish_vtb },
d1224 3
a1226 3
    switch(mvars.virtual_trackball){
    case VIRTUAL_TRACKBALL_OFF:
    case VIRTUAL_TRACKBALL_ON:
d1238 1
a1238 1
    case VIRTUAL_TRACKBALL_ROTATE:
d1242 1
a1242 1
    case VIRTUAL_TRACKBALL_TRANSLATE:
d1258 1
a1258 1
    case VIRTUAL_TRACKBALL_ZOOM:
d1733 1
a1733 1
	  if(!mvars.virtual_trackball)
d1748 1
a1748 1
	  if(!mvars.virtual_trackball)
d2080 1
a2080 1
establish_vtb()
d2082 1
a2082 1
  if(mvars.virtual_trackball){
d2624 1
a2624 1
  if( !strcmp( argv[0], "mouse" )){
d2628 2
a2629 2
      Tcl_AppendResult(interp, "dm mouse: need more parameters\n",
		       "mouse mouse 1|0 xpos ypos\n", (char *)NULL);
d2645 1
a2645 1
      Tcl_AppendResult(interp, "dm mouse: bad button value - ", argv[1], "\n", (char *)NULL);
d2662 2
a2663 3
  if(mvars.virtual_trackball){
    if( !strcmp( argv[0], "vtb" )){
      int buttonpress;
d2665 1
a2665 1
      scroll_active = 0;
d2667 5
a2671 5
      if( argc < 5){
	Tcl_AppendResult(interp, "dm: need more parameters\n",
			 "vtb <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
d2673 14
a2686 22
      buttonpress = atoi(argv[2]);
      omx = atoi(argv[3]);
      omy = atoi(argv[4]);

      if(buttonpress){
	switch(*argv[1]){
	case 'r':
	  mvars.virtual_trackball = VIRTUAL_TRACKBALL_ROTATE;
	  break;
	case 't':
	  mvars.virtual_trackball = VIRTUAL_TRACKBALL_TRANSLATE;
	  if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	                (edobj || es_edflag > 0)){
	    fastf_t fx, fy;

	    rt_vls_init(&vls);
	    fx = (omx/(fastf_t)winx_size - 0.5) * 2;
	    fy = (0.5 - omy/(fastf_t)winy_size) * 2;
	    rt_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	    (void)cmdline(&vls, FALSE);
	    rt_vls_free(&vls);
	  }
d2688 6
a2693 8
	  break;
	case 'z':
	  mvars.virtual_trackball = VIRTUAL_TRACKBALL_ZOOM;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm: need more parameters\n",
			   "vtb <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
d2695 12
a2706 2
      }else
	mvars.virtual_trackball = VIRTUAL_TRACKBALL_ON;
a2707 3
      return status;
    }
  }else{
d2741 1
a2741 1
  mvars.virtual_trackball = 1;
@


1.22
log
@ calling gui_setup to initalize tk stuff
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.21 1996/06/25 21:04:16 bparker Exp bparker $ (BRL)";
a63 1
#include "./glxinit.h"
d81 1
d111 1
a111 1
static int   Glx_load_startup();
d427 1
a427 2
  if(tkwin == NULL){
#if 1
a428 13
#else
#if 0    
    rt_vls_printf(&str, "loadtk %s\n", name);
#else
    rt_vls_printf(&str, "loadtk\n");
#endif

    if(cmdline(&str, FALSE) == CMD_BAD){
      rt_vls_free(&str);
      return -1;
    }
#endif
  }
d433 1
a433 6

    /* Invoke script to load commands */
    if( Glx_load_startup() ){
      rt_vls_free(&str);
      return -1;
    }
d642 1
a642 1
int
a644 3
  FILE    *fp;
  struct rt_vls str;
  char *path;
a646 3
/*XXX*/
#define DM_GLX_RCFILE "glxinit.tk"

d650 2
a651 41
  /* Start with internal default */
  Tcl_Eval( interp, glx_init_str);

  rt_vls_init( &str );

  if((filename = getenv("DM_GLX_RCFILE")) == (char *)NULL )
    /* Use default file name */
    filename = DM_GLX_RCFILE;

  if((path = getenv("MGED_LIBRARY")) != (char *)NULL ){
    /* Use MGED_LIBRARY path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL ){
      fclose( fp );
      Tcl_EvalFile( interp, rt_vls_addr(&str) );
    }
  }

  if( (path = getenv("HOME")) != (char *)NULL )  {
    /* Use HOME path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL ){
      fclose( fp );
      Tcl_EvalFile( interp, rt_vls_addr(&str) );
    }
  }

  /* Check current directory */
  if( (fp = fopen( filename, "r" )) != NULL )  {
    fclose( fp );
    Tcl_EvalFile( interp, filename );
  }

  rt_vls_free(&str);
  return 0;
d1246 10
a1255 4
	fx = (mx/(fastf_t)winx_size - 0.5) * 2;
	fy = (0.5 - my/(fastf_t)winy_size) * 2;

	rt_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy );
d1259 1
a1259 1
      rt_vls_printf( &cmd, "iknob aS %f\n", (omy - my)/(double)winy_size);
d2685 2
a2686 1
	  {
d2696 1
@


1.21
log
@handling knobs differently
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.20 1996/06/21 16:00:05 bparker Exp bparker $ (BRL)";
d428 3
d441 1
@


1.20
log
@using multiple command capability of knob
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.19 1996/06/11 17:13:20 bparker Exp bparker $ (BRL)";
d109 1
a109 1
static int glx_setup();
d218 1
d399 1
a399 1
  return glx_setup(dname);
d403 1
a403 1
glx_setup( name )
d1331 250
d1666 1
a1666 1

d2020 2
a2021 2
static 
int irlimit(i)
d2029 11
@


1.19
log
@now loading all resource files
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.18 1996/05/24 18:44:16 bparker Exp bparker $ (BRL)";
a1238 1
#if 1
a1243 5
#else
  curr_dm_list = (struct dm_list *)clientData;
  TkGLXwin_RefWinset(ref, GLX_NORMAL);
#endif

a1285 6
#if 0
      if(state != ST_S_PICK && state != ST_O_PICK &&
	 state != ST_S_VPICK && state != ST_O_PATH)
	goto end;
#endif

d1298 1
a1298 1
      rt_vls_printf( &cmd, "iknob ax %f; iknob ay %f\n",
d1308 1
a1308 15
	if(fx > 0.000001)
	  fx += SL_TOL;
	else if(fx < 0.000001)
	  fx += -SL_TOL;
	else
	  fx = 0.0;

	if(fy > 0.000001)
	  fy += SL_TOL;
	else if(fy < 0.000001)
	  fy += -SL_TOL;
	else
	  fy = 0.0;

	rt_vls_printf( &cmd, "knob aX %f; knob aY %f\n", fx, fy );
d1312 1
a1312 1
      rt_vls_printf( &cmd, "zoom %lf\n", (omy - my)/(double)winy_size + 1.0);
d1326 1
a1326 1
		(adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
d1335 1
a1335 1
      if(adcflag) {
d1345 1
a1345 1
      if(adcflag)
d1358 1
a1358 1
      if(adcflag)
d1371 1
a1371 1
      if(adcflag)
d1392 1
a1392 1
      if(adcflag)
a2476 1
#if 1
d2483 1
a2483 16

	    if(fx > 0.000001)
	      fx += SL_TOL;
	    else if(fx < 0.000001)
	      fx += -SL_TOL;
	    else
	      fx = 0.0;

	    if(fy > 0.000001)
	      fy += SL_TOL;
	    else if(fy < 0.000001)
	      fy += -SL_TOL;
	    else
	      fy = 0.0;

	    rt_vls_printf( &vls, "knob aX %f; knob aY %f\n", fx, fy);
a2486 10
#else
	  sprintf(xstr, "%f", (omx/(double)winx_size - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - omy/(double)winy_size) * 2);
	  sprintf(zstr, "%f", tran_z);
	  av[0] = "tran";
	  av[1] = xstr;
	  av[2] = ystr;
	  av[3] = zstr;
	  status = f_tran((ClientData)NULL, interp, 4, av);
#endif
@


1.18
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.17 1996/05/16 20:59:26 bparker Exp bparker $ (BRL)";
a662 1
  int     found;
a666 1
#if 1
d669 3
a671 1
#endif
a672 1
  found = 0;
d685 4
a688 2
    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
d691 5
a695 11
  if(!found){
    if( (path = getenv("HOME")) != (char *)NULL )  {
      /* Use HOME path */
      rt_vls_strcpy( &str, path );
      rt_vls_strcat( &str, "/" );
      rt_vls_strcat( &str, filename );

      if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
	found = 1;
    }
  }
d697 3
a699 5
  if( !found ) {
    /* Check current directory */
    if( (fp = fopen( filename, "r" )) != NULL )  {
      rt_vls_strcpy( &str, filename );
      found = 1;
d703 4
a706 15
  if(!found){
    rt_vls_free(&str);

    /* Using default */
    if(Tcl_Eval( interp, glx_init_str ) == TCL_ERROR)
      return -1;

    return 0;
  }

  fclose( fp );

  if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
    rt_vls_free(&str);
    return -1;
@


1.17
log
@modifying sliders
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.16 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d1328 2
a1329 2
      rt_vls_printf( &cmd, "irot %f %f 0\n", (my - omy)/2.0,
		     (mx - omx)/2.0);
d1332 22
a1353 2
      rt_vls_printf( &cmd, "tran %f %f %f\n", (mx/(double)winx_size - 0.5) * 2,
		     (0.5 - my/(double)winy_size) * 2, tran_z);
d1374 1
a1374 2
    knobs[M->first_axis] += M->axis_data[0] - knob_values[M->first_axis];
    setting = irlimit(knobs[M->first_axis]);
d1380 1
a1380 1
	rt_vls_printf( &cmd, "knob ang1 %d\n",
d1385 1
a1385 1
      rt_vls_printf( &cmd , "knob S %f\n",
d1390 1
a1390 1
	rt_vls_printf( &cmd , "knob ang2 %d\n",
d1392 3
a1394 2
      else
	rt_vls_printf( &cmd , "knob z %f\n",
d1396 4
d1403 1
a1403 1
	rt_vls_printf( &cmd , "knob distadc %d\n",
d1405 8
a1412 3
      else
	rt_vls_printf( &cmd , "knob Z %f\n",
		      setting / 2048.0 );
d1416 1
a1416 1
	rt_vls_printf( &cmd , "knob yadc %d\n",
d1418 8
a1425 3
      else
	rt_vls_printf( &cmd , "knob y %f\n",
		      setting / 2048.0 );
d1428 6
a1433 2
      rt_vls_printf( &cmd , "knob Y %f\n",
		    setting / 2048.0 );
d1437 1
a1437 1
	rt_vls_printf( &cmd , "knob xadc %d\n",
d1439 8
a1446 3
      else
	rt_vls_printf( &cmd , "knob x %f\n",
		      setting / 2048.0 );
d1449 6
a1454 2
      rt_vls_printf( &cmd , "knob X %f\n",
		    setting / 2048.0 );
d2521 3
d2525 23
d2556 1
a2556 1

@


1.16
log
@Still Tcl'ing the code
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.15 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d123 1
d166 1
d1310 1
d1314 11
a1325 3
      /* do the regular thing */
      /* Constant tracking (e.g. illuminate mode) bound to M mouse */
      rt_vls_printf( &cmd, "M 0 %d %d\n", irisX2ged(mx), irisY2ged(my));
d2414 21
a2434 3
    if( argc < 4){
      Tcl_AppendResult(interp, "dm: need more parameters\n",
		       "mouse 1|0 xpos ypos\n", (char *)NULL);
d2439 2
a2440 2
    rt_vls_printf(&vls, "M %s %d %d\n", argv[1],
		  irisX2ged(atoi(argv[2])), irisY2ged(atoi(argv[3])));
d2455 2
@


1.15
log
@still tcl-converting
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.14 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d382 13
a395 1

d738 3
d1141 1
a1141 2
	if( !dmaflag )
		return;
d1314 1
a1314 2
      rt_vls_printf( &cmd, "M 0 %d %d\n", (mx/(double)winx_size - 0.5) * 4095,
		     (0.5 - my/(double)winy_size) * 4095);
a2383 1
      rt_log("%s", rt_vls_addr(&vls) );
a2408 10
#if 0
    sprintf(xstr, "%d", irisX2ged(atoi(argv[2])));
    sprintf(ystr, "%d", irisY2ged(atoi(argv[3])));

    av[0] = "M";
    av[1] = argv[1];
    av[2] = xstr;
    av[3] = ystr;
    return f_mouse((ClientData)NULL, interp, 4, av);
#else
a2418 1
#endif
@


1.14
log
@convert commands to Tcl
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.13 1996/03/22 22:59:46 bparker Exp bparker $ (BRL)";
a379 2

#if 1
a385 33
#else
Glx_open()
{
  char	line[82];
  char	hostname[80];
  char	display[82];
  char	*envp;

  glx_var_init();
  /* get or create the default display */
  if( (envp = getenv("DISPLAY")) == NULL ) {
    /* Env not set, use local host */
    gethostname( hostname, 80 );
    hostname[79] = '\0';
    (void)sprintf( display, "%s:0", hostname );
    envp = display;
  }

  rt_log("X Display [%s]? ", envp );
  (void)fgets( line, sizeof(line), stdin );
  line[strlen(line)-1] = '\0';		/* remove newline */
  if( feof(stdin) )  quit();
  if( line[0] != '\0' ) {
    if( glx_setup(line) )
      return(1);		/* BAD */
  } else {
    if( glx_setup(envp) )
      return(1);	/* BAD */
  }

  return(0);			/* OK */
}
#endif
d727 5
a731 3
#if 0
  if(mvars.cueing_on)
    depthcue(0);
d733 6
a738 1
  lampoff( 0xf );
d740 3
a742 10
  /* avoids error messages when reattaching */
  mmode(MVIEWING);	
  lmbind(LIGHT2,0);
  lmbind(LIGHT3,0);
  lmbind(LIGHT4,0);
  lmbind(LIGHT5,0);

  frontbuffer(1);
  glx_clear_to_black();
  frontbuffer(0);
d745 1
a745 1
  Tk_DestroyWindow(Tk_Parent(xtkwin));
a1274 3
#if 0
    dmaflag = 1;
#else
a1275 1
#endif
a1281 3
#if 0
      dmaflag = 1;
#else
a1282 1
#endif
d1294 4
a1298 3
      mx = (mx/(double)winx_size - 0.5) * 4095;
      my = (0.5 - my/(double)winy_size) * 4095;

d1300 2
a1301 1
      rt_vls_printf( &cmd, "M 0 %d %d\n", mx, my );
d1414 4
a1417 1
  }
d2486 1
a2486 2
  dm_vars = (char *)rt_malloc(sizeof(struct glx_vars),
					    "glx_var_init: glx_vars");
@


1.13
log
@modified the open routine to accommodate new attach command
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.12 1996/03/22 18:39:33 bparker Exp bparker $ (BRL)";
d174 1
a174 1
  char *_ref;
d382 1
a382 2
Glx_open(name)
char *name;
d386 1
a386 4
  if( glx_setup(name) )
    return(1);		/* BAD */

  return(0);			/* OK */
a444 1
  rt_vls_init(&pathName);
d448 1
d450 3
d477 1
a477 1
  ref = strdup(rt_vls_addr(&pathName));
d518 2
a519 1
    rt_log("Glx_open: ref - %s doesn't exist!!!\n", ref);
d634 2
a635 1
	  rt_log("Glx_open: Couldn't open the dials+buttons\n");
d735 1
a735 3
    if(Tcl_Eval( interp, glx_init_str ) == TCL_ERROR){
      rt_log("Glx_load_startup: Error interpreting glx_init_str.\n");
      rt_log("%s\n", interp->result);
a736 1
    }
a743 1
    rt_log("Error reading %s: %s\n", filename, interp->result);
d761 2
d778 1
a778 1

d781 1
d783 3
a785 1
  RT_LIST_DEQUEUE(&((struct glx_vars *)dm_vars)->l);
a786 2
  rt_vls_free(&pathName);
  free(ref);
d810 1
a810 1
    rt_log( "Glx_prolog\n");
d833 1
a833 1
    rt_log( "Glx_normal\n");
d851 1
a851 1
    rt_log( "Glx_epilog\n");
d903 1
a903 1
		rt_log( "Glx_newrot()\n");
d999 1
a999 1
		rt_log( "Glx_Object()\n");
d1159 2
a1160 1
		rt_log( "Glx_update()\n");
d1177 2
a1178 1
		rt_log( "Glx_puts()\n");
d1203 2
a1204 1
		rt_log( "Glx_2d_line()\n");
d1271 1
a1281 2
  if(mvars.debug)
    rt_log("curr_dm_list: %d\n", (int)curr_dm_list);
d1457 1
a1457 1
  (void)cmdline(&cmd, FALSE);
d1462 4
a1465 1
  return TCL_OK;
d1531 9
a1539 1
  if( mvars.debug ) rt_log("statechange %d %d\n", a, b );
d1568 3
a1570 2
		rt_log("Glx_statechange: unknown state %s\n", state_str[b]);
		break;
d1581 21
a1601 13
	if( mvars.debug ) rt_log("viewchange( %d, x%x )\n", cmd, sp );
	switch( cmd )  {
	case DM_CHGV_ADD:
		break;
	case DM_CHGV_REDO:
		break;
	case DM_CHGV_DEL:
		break;
	case DM_CHGV_REPL:
		return;
	case DM_CHGV_ILLUM:
		break;
	}
d1630 2
a1631 1
	if( mvars.debug )  rt_log("colorchange\n");
d1666 2
a1667 2
		rt_log("Too few bitplanes: depthcueing disabled\n");
		mvars.cueing_on = 0;
d1764 2
a1765 1
	rt_log("dm-4d: You pressed Help key and '%s'\n", str);
d1870 3
a1872 2
		rt_log("dm-4d: This machine has no Zbuffer to enable\n");
		mvars.zbuffer_on = 0;
d1876 2
a1877 2
		/* Set screen coords of near and far clipping planes */
		lsetdepth(mvars.min_scr_z, mvars.max_scr_z);
d2393 5
d2400 2
d2403 3
d2419 1
d2421 5
a2425 1
    return CMD_OK;
d2429 9
a2437 4
    {
      int buttonpress;
      int xpos;
      int ypos;
d2439 11
a2449 5
      if( argc < 4){
	rt_log("dm: need more parameters\n");
	rt_log("mouse 1|0 xpos ypos\n");
	return CMD_BAD;
      }
d2451 2
a2452 10
      buttonpress = atoi(argv[1]);
      xpos = atoi(argv[2]);
      ypos = atoi(argv[3]);

      rt_vls_init(&vls);
      rt_vls_printf(&vls, "M %d %d %d\n",
		    buttonpress, irisX2ged(xpos), irisY2ged(ypos));
      (void)cmdline(&vls, FALSE);
      rt_vls_free(&vls);
    }
d2454 2
a2455 1
    return CMD_OK;
d2458 1
d2460 2
a2461 2
  if( !strcmp( argv[0], "vtb" )){
    int buttonpress;
d2463 5
a2467 5
    if( argc < 5){
      rt_log("dm: need more parameters\n");
      rt_log("vtb <r|t|z> 1|0 xpos ypos\n");
      return CMD_BAD;
    }
d2469 10
a2478 11
    buttonpress = atoi(argv[2]);
    omx = atoi(argv[3]);
    omy = atoi(argv[4]);

    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	mvars.virtual_trackball = VIRTUAL_TRACKBALL_ROTATE;
	break;
      case 't':
	{
a2479 3
	  rt_vls_init(&vls);
	  rt_vls_printf( &vls, "tran %f %f %f\n", (omx/(double)winx_size - 0.5) * 2,
			 (0.5 - omy/(double)winy_size) * 2, tran_z);
d2481 17
a2497 2
	  (void)cmdline(&vls, FALSE);
	  rt_vls_free(&vls);
d2499 2
a2500 32
	break;
      case 'z':
	mvars.virtual_trackball = VIRTUAL_TRACKBALL_ZOOM;
	break;
      default:
	rt_log("dm: need more parameters\n");
	rt_log("vtb <r|t|z> 1|0 xpos ypos\n");
	return CMD_BAD;
      }

#if 0
/*XXX This doesn't work properly. The Xserver seems to be freezing the motion
      events while the mouse button is still depressed. Sooo, I've decided to
      just select motion events prior to using the virtual trackball stuff. This
      is done when explicity turning on the virtual trackball stuff
      (i.e. dm set virtual_trackball 1).
 */
      if(state != ST_S_PICK && state != ST_O_PICK &&
	 state != ST_O_PATH && state != ST_S_VPICK){

	/* turn constant tracking ON */
	XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
		     KeyPressMask|StructureNotifyMask|PointerMotionMask|ButtonMotionMask);

      }
#endif
    }else{
      mvars.virtual_trackball = VIRTUAL_TRACKBALL_ON;

#if 0
      if(state != ST_S_PICK && state != ST_O_PICK &&
	 state != ST_O_PATH && state != ST_S_VPICK){
d2502 1
a2502 5
	/* turn constant tracking OFF */
	XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
		     KeyPressMask|StructureNotifyMask);
      }
#endif
a2503 3

    return CMD_OK;
  }
d2505 1
a2505 1
    return CMD_OK;
d2508 2
a2509 2
  rt_log("dm: bad command - %s\n", argv[0]);
  return CMD_BAD;
@


1.12
log
@cleanup
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.11 1996/03/20 22:15:31 bparker Exp bparker $ (BRL)";
d381 12
d424 1
@


1.11
log
@*** empty log message ***
@
text
@a23 1
#ifdef MULTI_ATTACH
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.10 1996/03/01 21:35:43 bparker Exp bparker $ (BRL)";
a85 1
#ifdef SEND_KEY_DOWN_PIPE
a86 1
#endif
a128 1
#ifdef VIRTUAL_TRACKBALL
a130 1
#endif
a155 1
#ifdef VIRTUAL_TRACKBALL
a156 1
#endif
a166 1
#ifdef VIRTUAL_TRACKBALL
a167 1
#endif
a273 1
#ifdef VIRTUAL_TRACKBALL
a274 1
#endif
a275 1

a296 1
#ifdef VIRTUAL_TRACKBALL
a297 1
#endif
d767 1
a1271 1
#ifdef SEND_KEY_DOWN_PIPE
a1288 1
#endif
a1289 1

a1313 1
#ifdef VIRTUAL_TRACKBALL
a1343 8
#else
    int x, y;

    x = (eventPtr->xmotion.x/(double)winx_size - 0.5) * 4095;
    y = (0.5 - eventPtr->xmotion.y/(double)winy_size) * 4095;
    /* Constant tracking (e.g. illuminate mode) bound to M mouse */
    rt_vls_printf( &cmd, "M 0 %d %d\n", x, y );
#endif
a1520 1
#ifdef VIRTUAL_TRACKBALL
a1521 1
#endif
a1535 1
#ifdef VIRTUAL_TRACKBALL
a1536 1
#endif
a1843 1
#ifdef VIRTUAL_TRACKBALL
a1861 1
#endif
a2400 1
#ifdef VIRTUAL_TRACKBALL  
a2474 1
#endif
d2485 1
a2485 4
  for(i = 0; i < 8; ++i){
#if 0
    knobs_offset[i] = knobs[i];
#else
a2486 2
#endif
  }
a2514 10
#if 0
  register struct dm_list *p;

  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
    if(window == ((struct glx_vars *)p->_dm_vars)->_win){
      TkGLXwin_RefWinset(((struct glx_vars *)p->_dm_vars)->_ref, GLX_NORMAL);
      return p;
    }
  }
#else
a2522 1
#endif
a2525 2292
#else
/*
 *			D M - G L X . C
 *
 *  This display manager started out with the guts from DM-4D which
 *  was modified to use the glx widget.
 *
 *  Authors -
 *      Paul R. Stay
 *      Michael John Muuss
 *      Robert J. Reschly
 *      Robert G. Parker
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.10 1996/03/01 21:35:43 bparker Exp bparker $ (BRL)";
#endif

#include "conf.h"

/* Forwards compat with IRIX 5.0.1 */
#define class	inv_class	/* Map Irix 4 name into Irix 5 name */
#define type	inv_type	/* Map Irix 4 name into Irix 5 name */
#define state	inv_state	/* Map Irix 4 name into Irix 5 name */
#include <stdio.h>
#include <math.h>
#include <termio.h>
#undef VMIN		/* is used in vmath.h, too */
#include <ctype.h>

#include <X11/X.h>
#include <gl/glws.h>
#include "tk.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XInput.h>
#include <X11/Xutil.h>
#include "tkGLX.h"

#include <gl/gl.h>		/* SGI IRIS library */
#include <gl/device.h>		/* SGI IRIS library */
#include <gl/get.h>		/* SGI IRIS library */
#include <gl/cg2vme.h>		/* SGI IRIS, for DE_R1 defn on IRIX 3 */
#include <gl/addrs.h>		/* SGI IRIS, for DER1_STEREO defn on IRIX 3 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/invent.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./dm.h"
#include "externs.h"
#include "./solid.h"

#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

#ifdef SEND_KEY_DOWN_PIPE
extern int dm_pipe[];
#endif

extern Tcl_Interp *interp;
extern Tk_Window tkwin;

/* Display Manager package interface */

#define IRBOUND	4095.9	/* Max magnification in Rot matrix */

int	Glx_open();
void	Glx_close();
MGED_EXTERN(void	Glx_input, (fd_set *input, int noblock) );
void	Glx_prolog(), Glx_epilog();
void	Glx_normal(), Glx_newrot();
void	Glx_update();
void	Glx_puts(), Glx_2d_line(), Glx_light();
int	Glx_object();
unsigned Glx_cvtvecs(), Glx_load();
void	Glx_statechange(), Glx_viewchange(), Glx_colorchange();
void	Glx_window(), Glx_debug();
int	Glx_dm();

static void set_knob_offset();
static int   Glx_load_startup();
static struct dm_list *get_dm_list();
#ifdef USE_PROTOTYPES
static Tk_GenericProc Glx_doevent;
#else
static int Glx_doevent();
#endif

/*
 * These variables are visible and modifiable via a "dm set" command.
 */
static int	cueing_on = 1;		/* Depth cueing flag - for colormap work */
static int	zclipping_on = 1;	/* Z Clipping flag */
static int	zbuffer_on = 1;		/* Hardware Z buffer is on */
static int	lighting_on = 0;	/* Lighting model on */
static int	glx_debug;		/* 2 for basic, 3 for full */
static int	no_faceplate = 0;	/* Don't draw faceplate */
static int	glx_linewidth = 1;	/* Line drawing width */
static int      dummy_perspective = 1;
static int      perspective_mode = 0;	/* Perspective flag */
/*
 * These are derived from the hardware inventory -- user can change them,
 * but the results may not be pleasing.  Mostly, this allows them to be seen.
 */
static int    glx_is_gt;              /* 0 for non-GT machines */
static int    glx_has_zbuf;           /* 0 if no Z buffer */
static int    glx_has_rgb;            /* 0 if mapped mode must be used */
static int    glx_has_doublebuffer;   /* 0 if singlebuffer mode must be used */

static int	min_scr_z;		/* based on getgdesc(GD_ZMIN) */
static int	max_scr_z;		/* based on getgdesc(GD_ZMAX) */
/* End modifiable variables */

static int glx_setup();

static Tk_Window xtkwin;
static Display  *dpy;
static Window   win;
static long win_l, win_b, win_r, win_t;
static long winx_size, winy_size;
static int perspective_angle =3;	/* Angle of perspective */
static int devmotionnotify = LASTEvent;
static int devbuttonpress = LASTEvent;
static int devbuttonrelease = LASTEvent;
static int knobs[8] = {0, 0, 0, 0, 0, 0, 0, 0};
static int knobs_offset[8] = {0, 0, 0, 0, 0, 0, 0, 0};
static int	stereo_is_on = 0;

static int perspective_table[] = { 
	30, 45, 60, 90 };
static int ovec = -1;		/* Old color map entry number */
static int kblights();
static double	xlim_view = 1.0;	/* args for ortho() */
static double	ylim_view = 1.0;
static struct rt_vls pathName;
static char *ref;
static fastf_t aspect;

void		glx_colorit();

#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
/* Inverse map for mapping MGED button functions to SGI button numbers */
static unsigned char invbmap[BV_MAXFUNC+1];

/* bit 0 == switchlight 0 */
static unsigned long lights;
#endif

#ifdef IR_KNOBS
static int irlimit();			/* provides knob dead spot */
#define NOISE 32		/* Size of dead spot on knob */
/*
 *  Labels for knobs in help mode.
 */
static char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
static char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

/*
 * SGI Color Map table
 */
#define NSLOTS		4080	/* The mostest possible - may be fewer */
static int glx_nslots=0;		/* how many we have, <= NSLOTS */
static int slotsused;		/* how many actually used */
static struct rgbtab {
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
} glx_rgbtab[NSLOTS];

struct dm dm_glx = {
	Glx_open, Glx_close,
	Glx_input,
	Glx_prolog, Glx_epilog,
	Glx_normal, Glx_newrot,
	Glx_update,
	Glx_puts, Glx_2d_line,
	Glx_light,
	Glx_object,
	Glx_cvtvecs, Glx_load,
	Glx_statechange,
	Glx_viewchange,
	Glx_colorchange,
	Glx_window, Glx_debug,
	0,			/* no "displaylist", per. se. */
	0,			/* multi-window */
	IRBOUND,
	"glx", "SGI 4d",
	0,			/* mem map */
	Glx_dm
};

extern struct device_values dm_values;	/* values read from devices */

static void     establish_perspective();
static void     set_perspective();
static void	establish_lighting();
static void	establish_zbuffer();


static void
refresh_hook()
{
	dmaflag = 1;
}

struct structparse Glx_vparse[] = {
	{"%d",  1, "depthcue",		(int)&cueing_on,	Glx_colorchange },
	{"%d",  1, "zclip",		(int)&zclipping_on,	refresh_hook },
	{"%d",  1, "zbuffer",		(int)&zbuffer_on,	establish_zbuffer },
	{"%d",  1, "lighting",		(int)&lighting_on,	establish_lighting },
	{"%d",  1, "perspective",       (int)&perspective_mode, establish_perspective },
	{"%d",  1, "set_perspective",(int)&dummy_perspective,  set_perspective },
	{"%d",  1, "no_faceplate",	(int)&no_faceplate,	refresh_hook },
	{"%d",  1, "has_zbuf",		(int)&glx_has_zbuf,	refresh_hook },
	{"%d",  1, "has_rgb",		(int)&glx_has_rgb,	Glx_colorchange },
	{"%d",  1, "has_doublebuffer",	(int)&glx_has_doublebuffer, refresh_hook },
	{"%d",  1, "min_scr_z",		(int)&min_scr_z,	refresh_hook },
	{"%d",  1, "max_scr_z",		(int)&max_scr_z,	refresh_hook },
	{"%d",  1, "debug",		(int)&glx_debug,		FUNC_NULL },
	{"%d",  1, "linewidth",		(int)&glx_linewidth,	refresh_hook },
	{"",	0,  (char *)0,		0,			FUNC_NULL }
};

static int	glx_oldmonitor;		/* Old monitor type */
static long gr_id;

/* Map +/-2048 GED space into -1.0..+1.0 :: x/2048*/
#define GED2IRIS(x)	(((float)(x))*0.00048828125)

/*
 *  Mouse coordinates are in absolute screen space, not relative to
 *  the window they came from.  Convert to window-relative,
 *  then to MGED-style +/-2048 range.
 */
static int
irisX2ged(x)
register int x;
{
  return ((x/(double)winx_size - 0.5) * 4095);
}

static int
irisY2ged(y)
register int y;
{
  return ((0.5 - y/(double)winy_size) * 4095);
}

/* 
 *			I R _ C O N F I G U R E _ W I N D O W _ S H A P E
 *
 *  Either initially, or on resize/reshape of the window,
 *  sense the actual size of the window, and perform any
 *  other initializations of the window configuration.
 */
static void
Glx_configure_window_shape()
{
  int		npix;
  XWindowAttributes xwa;

  XGetWindowAttributes( dpy, win, &xwa );
  winx_size = xwa.width;
  winy_size = xwa.height;

  /* Write enable all the bloody bits after resize! */
  viewport(0, winx_size, 0, winy_size);

  if( glx_has_zbuf )
    establish_zbuffer();

  establish_lighting();
	
  if( glx_has_doublebuffer){
    /* Clear out image from windows underneath */
    frontbuffer(1);
    glx_clear_to_black();
    frontbuffer(0);
    glx_clear_to_black();
  } else
    glx_clear_to_black();

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
  aspect = (fastf_t)winy_size/(fastf_t)winx_size;
}

#define CMAP_BASE	32
#define CMAP_RAMP_WIDTH	16
#define MAP_ENTRY(x)	((cueing_on) ? \
			((x) * CMAP_RAMP_WIDTH + CMAP_BASE) : \
			((x) + CMAP_BASE) )


/*
 *			I R _ O P E N
 *
 *  Fire up the display manager, and the display processor. Note that
 *  this brain-damaged version of the MEX display manager gets terribly
 *  confused if you try to close your last window.  Tough. We go ahead
 *  and close the window.  Ignore the "ERR_CLOSEDLASTWINDOW" error
 *  message. It doesn't hurt anything.  Silly MEX.
 */

Glx_open()
{
  char	line[82];
  char	hostname[80];
  char	display[82];
  char	*envp;

  /* get or create the default display */
  if( (envp = getenv("DISPLAY")) == NULL ) {
    /* Env not set, use local host */
    gethostname( hostname, 80 );
    hostname[79] = '\0';
    (void)sprintf( display, "%s:0", hostname );
    envp = display;
  }

  rt_log("X Display [%s]? ", envp );
  (void)fgets( line, sizeof(line), stdin );
  line[strlen(line)-1] = '\0';		/* remove newline */
  if( feof(stdin) )  quit();
  if( line[0] != '\0' ) {
    if( glx_setup(line) )
      return(1);		/* BAD */
  } else {
    if( glx_setup(envp) )
      return(1);	/* BAD */
  }

  /* Ignore the old scrollbars and menus */
  mged_variables.show_menu = 0;

  knob_offset_hook = set_knob_offset;

  return(0);			/* OK */
}

static int
glx_setup( name )
char *name;
{
  register int	i;
  static int ref_count = 0;
  Matrix		m;
  inventory_t	*inv;
  int		win_size=1000;
  int		win_o_x=272;
  int		win_o_y=12;
  struct rt_vls str;
  int j, k;
  int ndevices;
  int nclass = 0;
  XDeviceInfoPtr olist, list;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
  XAnyClassPtr any;
  GLXconfig *glx_config, *p;
  Display *tmp_dpy;

  rt_vls_init(&str);

  /* Only need to do this once */
  if(tkwin == NULL){
    rt_vls_printf(&str, "loadtk %s\n", name);

    if(cmdline(&str, FALSE) == CMD_BAD){
      rt_vls_free(&str);
      return -1;
    }
  }

  /* Only need to do this once for this display manager */
  if(!ref_count){
    (void)TkGLX_Init(interp, tkwin);

    /* Invoke script to load commands */
    if( Glx_load_startup() ){
      rt_vls_free(&str);
      return -1;
    }
  }

  rt_vls_init(&pathName);
  rt_vls_printf(&pathName, ".dm_glx%d", ref_count++);
  ref = strdup(rt_vls_addr(&pathName));
  rt_vls_strcat(&pathName, ".win"); 

  if((tmp_dpy = XOpenDisplay(name)) == NULL){
    rt_vls_free(&str);
    return -1;
  }

  winx_size = DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  winy_size = DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;

  /* Make window square */
  if( winy_size < winx_size )
    winx_size = winy_size;
  else /* we have a funky shaped monitor */ 
    winy_size = winx_size;

  XCloseDisplay(tmp_dpy);

  /*
   * Create the glx widget by calling create_glx which
   * is defined in glxinit.tk
   */
  rt_vls_strcpy(&str, "create_glx ");
  rt_vls_printf(&str, "%s %s %s %s %d %d true true\n", name,
		ref, rt_vls_addr(&pathName), ref, winx_size, winy_size);

  if(cmdline(&str, FALSE) == CMD_BAD){
    rt_vls_free(&str);
    return -1;
  }

  rt_vls_free(&str);

  if(TkGLXwin_RefExists(ref)){
    xtkwin = TkGLXwin_RefGetTkwin(ref);
    if(xtkwin == NULL)
      return -1;

    dpy = Tk_Display(xtkwin);
  }else{
    rt_log("Glx_open: ref - %s doesn't exist!!!\n", ref);
    return -1;
  }

  /* Do this now to force a GLXlink */
  Tk_MapWindow(xtkwin);

  Tk_MakeWindowExist(xtkwin);
  win = Tk_WindowId(xtkwin);

  glx_is_gt = 1;

  glx_config = TkGLXwin_RefGetConfig(ref);

  /* set configuration variables */
  for(p = glx_config; p->buffer; ++p){
    switch(p->buffer){
    case GLX_NORMAL:
      switch(p->mode){
      case GLX_ZSIZE:
	if(p->arg)
	  glx_has_zbuf = 1;
	else
	  glx_has_zbuf = 0;

	break;
      case GLX_RGB:
	if(p->arg)
	  glx_has_rgb = 1;
	else
	  glx_has_rgb = 0;
	
	break;
      case GLX_DOUBLE:
	if(p->arg)
	  glx_has_doublebuffer = 1;
	else
	  glx_has_doublebuffer = 0;

	break;
      case GLX_STEREOBUF:
	stereo_is_on = 1;

	break;
      case GLX_BUFSIZE:
      case GLX_STENSIZE:
      case GLX_ACSIZE:
      case GLX_VISUAL:
      case GLX_COLORMAP:
      case GLX_WINDOW:
      case GLX_MSSAMPLE:
      case GLX_MSZSIZE:
      case GLX_MSSSIZE:
      case GLX_RGBSIZE:
      default:
	break;
      }
    case GLX_OVERLAY:
    case GLX_POPUP:
    case GLX_UNDERLAY:
    default:
      break;
    }
  }

  free((void *)glx_config);
	
  if (mged_variables.sgi_win_size > 0)
    win_size = mged_variables.sgi_win_size;

  if (mged_variables.sgi_win_origin[0] != 0)
    win_o_x = mged_variables.sgi_win_origin[0];

  if (mged_variables.sgi_win_origin[1] != 0)
    win_o_y = mged_variables.sgi_win_origin[1];

  winconstraints();	/* remove constraints on the window size */

  /*
   * Establish GL library operating modes
   */
  /* Don't draw polygon edges */
  glcompat( GLC_OLDPOLYGON, 0 );

  /* Z-range mapping */
  /* Z range from getgdesc(GD_ZMIN)
   * to getgdesc(GD_ZMAX).
   * Hardware specific.
   */
  glcompat( GLC_ZRANGEMAP, 0 );
  /* Take off a smidgeon for wraparound, as suggested by SGI manual */

  min_scr_z = getgdesc(GD_ZMIN)+15;
  max_scr_z = getgdesc(GD_ZMAX)-15;

  Glx_configure_window_shape();

  /* Line style 0 is solid.  Program line style 1 as dot-dashed */
  deflinestyle( 1, 0xCF33 );
  setlinestyle( 0 );

  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  olist = list = (XDeviceInfoPtr) XListInputDevices (dpy, &ndevices);

  /* IRIX 4.0.5 bug workaround */
  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(dpy, list->id)) == (XDevice *)NULL){
	  rt_log("Glx_open: Couldn't open the dials+buttons\n");
	  goto Done;
	}

	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
	  case ButtonClass:
	    DeviceButtonPress(dev, devbuttonpress, e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, devbuttonrelease, e_class[nclass]);
	    ++nclass;
	    break;
	  case ValuatorClass:
	    DeviceMotionNotify(dev, devmotionnotify, e_class[nclass]);
	    ++nclass;
	    break;
	  default:
	    break;
	  }
	}

	XSelectExtensionEvent(dpy, win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);
  Tk_CreateGenericHandler(Glx_doevent,
			  (ClientData)NULL);

  /* start with constant tracking OFF */
  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
	       KeyPressMask|StructureNotifyMask);

  return(0);
}

/*XXX Just experimenting */
int
Glx_load_startup()
{
  FILE    *fp;
  struct rt_vls str;
  char *path;
  char *filename;
  int     found;

/*XXX*/
#define DM_GLX_RCFILE "glxinit.tk"

  found = 0;
  rt_vls_init( &str );

  if((filename = getenv("DM_GLX_RCFILE")) == (char *)NULL )
    filename = DM_GLX_RCFILE;

  if((path = getenv("MGED_LIBRARY")) != (char *)NULL ){
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
  }

  if(!found){
    if( (path = getenv("HOME")) != (char *)NULL )  {
      rt_vls_strcpy( &str, path );
      rt_vls_strcat( &str, "/" );
      rt_vls_strcat( &str, filename );

      if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
	found = 1;
    }
  }

  if( !found ) {
    if( (fp = fopen( filename, "r" )) != NULL )  {
      rt_vls_strcpy( &str, filename );
      found = 1;
    }
  }

/*XXX Temporary, so things will work without knowledge of the new environment
      variables */
  if( !found ) {
    rt_vls_strcpy( &str, "/m/cad/mged/");
    rt_vls_strcat( &str, filename);

    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
  }

  if(!found){
    rt_vls_free(&str);
    return -1;
  }

  fclose( fp );

  if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
    rt_log("Error reading %s: %s\n", filename, interp->result);
    rt_vls_free(&str);
    return -1;
  }

  rt_vls_free(&str);
  return 0;
}

/*
 *  			I R _ C L O S E
 *  
 *  Gracefully release the display.  Well, mostly gracefully -- see
 *  the comments in the open routine.
 */
void
Glx_close()
{
  if(cueing_on)
    depthcue(0);

  lampoff( 0xf );

  /* avoids error messages when reattaching */
  mmode(MVIEWING);	
  lmbind(LIGHT2,0);
  lmbind(LIGHT3,0);
  lmbind(LIGHT4,0);
  lmbind(LIGHT5,0);


  frontbuffer(1);
  glx_clear_to_black();
  frontbuffer(0);

  Tk_DestroyWindow(Tk_Parent(xtkwin));
  Tk_DeleteGenericHandler(Glx_doevent, (ClientData)NULL);
  knob_offset_hook = NULL;
  rt_vls_free(&pathName);
  free(ref);
}

/*
 *			G L X _ P R O L O G
 *
 * Define the world, and include in it instances of all the
 * important things.  Most important of all is the object "faceplate",
 * which is built between dmr_normal() and dmr_epilog()
 * by dmr_puts and dmr_2d_line calls from adcursor() and dotitles().
 */
void
Glx_prolog()
{
  TkGLXwin_RefWinset(ref, GLX_NORMAL);

  if (glx_debug)
    rt_log( "Glx_prolog\n");

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );

  if( !glx_has_doublebuffer ){
    glx_clear_to_black();
    return;
  }

  linewidth(glx_linewidth);
}

/*
 *			I R _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
Glx_normal()
{
  if (glx_debug)
    rt_log( "Glx_normal\n");

  if( glx_has_rgb )  {
    RGBcolor( (short)0, (short)0, (short)0 );
  } else {
    color(BLACK);
  }

  ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
}

/*
 *			I R _ E P I L O G
 */
void
Glx_epilog()
{
  if (glx_debug)
    rt_log( "Glx_epilog\n");

  /*
   * A Point, in the Center of the Screen.
   * This is drawn last, to always come out on top.
   */
  Glx_2d_line( 0, 0, 0, 0, 0 );
  /* End of faceplate */

  if(glx_has_doublebuffer ){
    swapbuffers();
    /* give Graphics pipe time to work */
    glx_clear_to_black();
  }
}

/*
 *  			I R _ N E W R O T
 *
 *  Load a new rotation matrix.  This will be followed by
 *  many calls to Glx_object().
 *
 *  IMPORTANT COORDINATE SYSTEM NOTE:
 *
 *  MGED uses a right handed coordinate system where +Z points OUT of
 *  the screen.  The Silicon Graphics uses a left handed coordinate
 *  system where +Z points INTO the screen.
 *  This difference in convention is handled here.
 *  The conversion is accomplished by concatenating a matrix multiply
 *  by
 *            (  1    0    0   0  )
 *            (  0    1    0   0  )
 *            (  0    0   -1   0  )
 *            (  0    0    0   1  )
 *
 *  However, this is actually implemented by straight-line code which
 *  flips the sign on the entire third row.
 *
 *  Note that through BRL-CAD Release 3.7 this was handled by flipping
 *  the direction of the shade ramps.  Now, with the Z-buffer being used,
 *  the correct solution is important.
 */
void
Glx_newrot(mat, which_eye)
mat_t	mat;
{
	register fastf_t *mptr;
	Matrix	gtmat;
	mat_t	newm;
	int	i;

	if (glx_debug)
		rt_log( "Glx_newrot()\n");

	switch(which_eye)  {
	case 0:
		/* Non-stereo */
		break;
	case 1:
		/* R eye */
		viewport(0, XMAXSCREEN, 0, YSTEREO);
		Glx_puts( "R", 2020, 0, 0, DM_RED );
		break;
	case 2:
		/* L eye */
		viewport(0, XMAXSCREEN, 0+YOFFSET_LEFT, YSTEREO+YOFFSET_LEFT);
		break;
	}

	if( !zclipping_on ) {
		mat_t	nozclip;

		mat_idn( nozclip );
		nozclip[10] = 1.0e-20;
		mat_mul( newm, nozclip, mat );
		mptr = newm;
	} else {
		mptr = mat;
	}

	gtmat[0][0] = *(mptr++) * aspect;
	gtmat[1][0] = *(mptr++) * aspect;
	gtmat[2][0] = *(mptr++) * aspect;
	gtmat[3][0] = *(mptr++) * aspect;

	gtmat[0][1] = *(mptr++);
	gtmat[1][1] = *(mptr++);
	gtmat[2][1] = *(mptr++);
	gtmat[3][1] = *(mptr++);

	gtmat[0][2] = *(mptr++);
	gtmat[1][2] = *(mptr++);
	gtmat[2][2] = *(mptr++);
	gtmat[3][2] = *(mptr++);

	gtmat[0][3] = *(mptr++);
	gtmat[1][3] = *(mptr++);
	gtmat[2][3] = *(mptr++);
	gtmat[3][3] = *(mptr++);

	/*
	 *  Convert between MGED's right handed coordinate system
	 *  where +Z comes out of the screen to the Silicon Graphics's
	 *  left handed coordinate system, where +Z goes INTO the screen.
	 */
	gtmat[0][2] = -gtmat[0][2];
	gtmat[1][2] = -gtmat[1][2];
	gtmat[2][2] = -gtmat[2][2];
	gtmat[3][2] = -gtmat[3][2];

	loadmatrix( gtmat );
}

static float material_objdef[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/*
 *  			I R _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.  Mat is model2view.
 *
 *  Returns -
 *	 0 if object could be drawn
 *	!0 if object was omitted.
 */
int
Glx_object( sp, m, ratio, white )
register struct solid *sp;
fastf_t		*m;
double		ratio;
int		white;
{
	register struct rt_vlist	*vp;
	register int nvec;
	register float	*gtvec;
	char	gtbuf[16+3*sizeof(double)];
	int first;
	int i,j;

	if (glx_debug)
		rt_log( "Glx_Object()\n");

	/*
	 *  It is claimed that the "dancing vector disease" of the
	 *  4D GT processors is due to the array being passed to v3f()
	 *  not being quad-word aligned (16-byte boundary).
	 *  This hack ensures that the buffer has this alignment.
	 *  Note that this requires gtbuf to be 16 bytes longer than needed.
	 */
	gtvec = (float *)((((int)gtbuf)+15) & (~0xF));

	/*
	 * IMPORTANT DEPTHCUEING NOTE
	 *
	 * Also note that the depthcueing shaderange() routine wanders
	 * outside it's allotted range due to roundoff errors.  A buffer
	 * entry is kept on each end of the shading curves, and the
	 * highlight mode uses the *next* to the brightest entry --
	 * otherwise it can (and does) fall off the shading ramp.
	 */
	if (sp->s_soldash)
		setlinestyle( 1 );		/* set dot-dash */

	if( glx_has_rgb )  {
		register short	r, g, b;
		if( white )  {
			r = g = b = 230;
		} else {
			r = (short)sp->s_color[0];
			g = (short)sp->s_color[1];
			b = (short)sp->s_color[2];
		}
		if(cueing_on)  {
			lRGBrange(
			    r/10, g/10, b/10,
			    r, g, b,
			    min_scr_z, max_scr_z );
		} else
		if(lighting_on && glx_is_gt)
		{
			/* Ambient = .2, Diffuse = .6, Specular = .2 */

			/* Ambient */
			material_objdef[3] = 	.2 * ( r / 255.0);
			material_objdef[4] = 	.2 * ( g / 255.0);
			material_objdef[5] = 	.2 * ( b / 255.0);

			/* diffuse */
			material_objdef[7] = 	.6 * ( r / 255.0);
			material_objdef[8] = 	.6 * ( g / 255.0);
			material_objdef[9] = 	.6 * ( b / 255.0);

			/* Specular */
			material_objdef[11] = 	.2 * ( r / 255.0);
			material_objdef[12] = 	.2 * ( g / 255.0);
			material_objdef[13] = 	.2 * ( b / 255.0);

			lmdef(DEFMATERIAL, 21, 0, material_objdef);
			lmbind(MATERIAL, 21);

		} else

			RGBcolor( r, g, b );
	} else {
		if( white ) {
			ovec = nvec = MAP_ENTRY(DM_WHITE);
			/* Use the *next* to the brightest white entry */
			if(cueing_on)  {
				lshaderange(nvec+1, nvec+1,
				min_scr_z, max_scr_z );
			}
			color( nvec );
		} else {
			if( (nvec = MAP_ENTRY( sp->s_dmindex )) != ovec) {
				/* Use only the middle 14 to allow for roundoff...
				 * Pity the poor fool who has defined a black object.
				 * The code will use the "reserved" color map entries
				 * to display it when in depthcued mode.
				 */
				if(cueing_on)  {
					lshaderange(nvec+1, nvec+14,
					min_scr_z, max_scr_z );
				}
				color( nvec );
				ovec = nvec;
			}
		}
	}

	/* Viewing region is from -1.0 to +1.0 */
	first = 1;
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_LINE_MOVE:
				/* Move, start line */
				if( first == 0 )
					endline();
				first = 0;
				bgnline();
				v3d( *pt );
				break;
			case RT_VLIST_LINE_DRAW:
				/* Draw line */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_START:
				/* Start poly marker & normal */
				if( first == 0 )
					endline();
				/* concave(TRUE); */
				bgnpolygon();
				/* Set surface normal (vl_pnt points outward) */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			case RT_VLIST_POLY_MOVE:
				/* Polygon Move */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_DRAW:
				/* Polygon Draw */
				v3d( *pt );
				break;
			case RT_VLIST_POLY_END:
				/* Draw, End Polygon */
				v3d( *pt );
				endpolygon();
				first = 1;
				break;
			case RT_VLIST_POLY_VERTNORM:
				/* Set per-vertex normal.  Given before vert. */
				VMOVE( gtvec, *pt );
				n3f(gtvec);
				break;
			}
		}
	}
	if( first == 0 ) endline();

	if (sp->s_soldash)
		setlinestyle(0);		/* restore solid lines */

	return(1);	/* OK */
}

/*
 *			I R _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 * Last routine called in refresh cycle.
 */
void
Glx_update()
{
	if (glx_debug)
		rt_log( "Glx_update()\n");
	if( !dmaflag )
		return;
}

/*
 *			I R _ P U T S
 *
 * Output a string.
 * The starting position of the beam is as specified.
 */
void
Glx_puts( str, x, y, size, colour )
register char *str;
int x,y,size, colour;
{
	if (glx_debug)
		rt_log( "Glx_puts()\n");
	cmov2( GED2IRIS(x), GED2IRIS(y));
	if( glx_has_rgb )  {
		RGBcolor( (short)glx_rgbtab[colour].r,
		    (short)glx_rgbtab[colour].g,
		    (short)glx_rgbtab[colour].b );
	} else {
		color( MAP_ENTRY(colour) );
	}
	charstr( str );
}

/*
 *			I R _ 2 D _ L I N E
 *
 */
void
Glx_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	register int nvec;

	if (glx_debug)
		rt_log( "Glx_2d_line()\n");
	if( glx_has_rgb )  {
		/* Yellow */
		if(cueing_on)  {
			lRGBrange(
			    255, 255, 0,
			    255, 255, 0,
			    min_scr_z, max_scr_z );
		}
		RGBcolor( (short)255, (short)255, (short) 0 );
	} else {
		if((nvec = MAP_ENTRY(DM_YELLOW)) != ovec) {
			if(cueing_on) lshaderange(nvec, nvec,
			   min_scr_z, max_scr_z );
			color( nvec );
			ovec = nvec;
		}
	}

	if( dashed )
		setlinestyle(1);	/* into dot-dash */

	move2( GED2IRIS(x1), GED2IRIS(y1));
	draw2( GED2IRIS(x2), GED2IRIS(y2));

	if( dashed )
		setlinestyle(0);	/* restore to solid */
}

/*
 *			I R _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream, or a device event has
 * occured, unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
Glx_input( input, noblock )
fd_set		*input;
int		noblock;
{
  return;
}


/*
   This routine does not handle mouse button or key events. The key
   events are being processed via the TCL/TK bind command or are being
   piped to ged.c/stdin_input(). Eventually, I'd also like to have the
   dials+buttons bindable. That would leave this routine to handle only
   events like Expose and ConfigureNotify.
*/
int
Glx_doevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  XEvent event;
  static int button0  = 0;   /*  State of button 0 */
  static int knobs_during_help[8] = {0, 0, 0, 0, 0, 0, 0, 0};

/*XXX still drawing too much!!!
i.e. drawing 2 or more times when resizing the window to a larger size.
once for the Configure and once for the expose. This is especially
annoying when running remotely. */

  if(eventPtr->xany.window != win)
    goto end;

#ifdef SEND_KEY_DOWN_PIPE
  if(mged_variables.send_key && eventPtr->type == KeyPress){
    char buffer[1];

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  (KeySym *)NULL, (XComposeStatus *)NULL);

    write(dm_pipe[1], buffer, 1);
    goto end;
  }
#endif


  /* Now getting X events */
  if(eventPtr->type == Expose && eventPtr->xexpose.count == 0){
    /* Window may have moved */
    Glx_configure_window_shape();

    dmaflag = 1;
#if 0
    if( glx_has_doublebuffer) /* to fix back buffer */
#endif
      refresh();
  }else if( eventPtr->type == ConfigureNotify ){
      /* Window may have moved */
      Glx_configure_window_shape();

      dmaflag = 1;
#if 0
      if( glx_has_doublebuffer ) /* to fix back buffer */
#endif
	refresh();
  }else if( eventPtr->type == MotionNotify ) {
    int x, y;

    x = (eventPtr->xmotion.x/(double)winx_size - 0.5) * 4095;
    y = (0.5 - eventPtr->xmotion.y/(double)winy_size) * 4095;
    /* Constant tracking (e.g. illuminate mode) bound to M mouse */
    rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y );
  }else if( eventPtr->type == devmotionnotify ){
    XDeviceMotionEvent *M;
    int setting;

    M = (XDeviceMotionEvent * ) eventPtr;

    if(button0){
      knobs_during_help[M->first_axis] = M->axis_data[0];
      glx_dbtext(
		(adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
      goto end;
    }else{
      knobs[M->first_axis] = M->axis_data[0];
      setting = irlimit(knobs[M->first_axis] - knobs_offset[M->first_axis]);
    }

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(adcflag) {
	rt_vls_printf( &dm_values.dv_string, "knob ang1 %d\n",
		      setting );
      }
      break;
    case DIAL1:
      rt_vls_printf( &dm_values.dv_string , "knob S %f\n",
		    setting / 2048.0 );
      break;
    case DIAL2:
      if(adcflag)
	rt_vls_printf( &dm_values.dv_string , "knob ang2 %d\n",
		      setting );
      else
	rt_vls_printf( &dm_values.dv_string , "knob z %f\n",
		      setting / 2048.0 );
      break;
    case DIAL3:
      if(adcflag)
	rt_vls_printf( &dm_values.dv_string , "knob distadc %d\n",
		      setting );
      else
	rt_vls_printf( &dm_values.dv_string , "knob Z %f\n",
		      setting / 2048.0 );
      break;
    case DIAL4:
      if(adcflag)
	rt_vls_printf( &dm_values.dv_string , "knob yadc %d\n",
		      setting );
      else
	rt_vls_printf( &dm_values.dv_string , "knob y %f\n",
		      setting / 2048.0 );
      break;
    case DIAL5:
      rt_vls_printf( &dm_values.dv_string , "knob Y %f\n",
		    setting / 2048.0 );
      break;
    case DIAL6:
      if(adcflag)
	rt_vls_printf( &dm_values.dv_string , "knob xadc %d\n",
		      setting );
      else
	rt_vls_printf( &dm_values.dv_string , "knob x %f\n",
		      setting / 2048.0 );
      break;
    case DIAL7:
      rt_vls_printf( &dm_values.dv_string , "knob X %f\n",
		    setting / 2048.0 );
      break;
    default:
      break;
    }

  }else if( eventPtr->type == devbuttonpress ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      button0 = 1;
      goto end;
    }

    if(button0){
      glx_dbtext(label_button(bmap[B->button - 1]));
    }else if(B->button == 4){
      rt_vls_strcat(&dm_values.dv_string, "knob zero\n");
      set_knob_offset();
    }else
      rt_vls_printf(&dm_values.dv_string, "press %s\n",
		    label_button(bmap[B->button - 1]));
  }else if( eventPtr->type == devbuttonrelease ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      int i;

      button0 = 0;

      /* update the offset */
      for(i = 0; i < 8; ++i)
	knobs_offset[i] += knobs_during_help[i] - knobs[i];
    }
  }
end:

  return TCL_OK;
}


/* 
 *			I R _ L I G H T
 *
 * This function must keep both the light hardware, and the software
 * copy of the lights up to date.  Note that requests for light changes
 * may not actually cause the lights to be changed, depending on
 * whether the buttons are being used for "view" or "edit" functions
 * (although this is not done in the present code).
 */
void
Glx_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	register unsigned short bit;
#ifdef IR_BUTTONS
	/* Check for BE_ function not assigned to a button */
	if( (bit = invbmap[func]) == 0 && cmd != LIGHT_RESET )
		return;
	switch( cmd )  {
	case LIGHT_RESET:
		lights = 0;
		break;
	case LIGHT_ON:
		lights |= 1<<bit;
		break;
	case LIGHT_OFF:
		lights &= ~(1<<bit);
		break;
	}

	/* Update the lights box. */
#if !defined(__sgi)	/* This bombs, on early Irix 4.0 releases */
	setdblights( lights );
#endif
#endif
}

/*
 *			I R _ C V T V E C S
 *
 */
unsigned
Glx_cvtvecs( sp )
register struct solid *sp;
{
	return( 0 );	/* No "displaylist" consumed */
}

/*
 * Loads displaylist from storage[]
 */
unsigned
Glx_load( addr, count )
unsigned addr, count;
{
	return( 0 );		/* FLAG:  error */
}

void
Glx_statechange( a, b )
{
	if( glx_debug ) rt_log("statechange %d %d\n", a, b );
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
 	switch( b )  {
	case ST_VIEW:
	  /* constant tracking OFF */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask);
	  break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	  /* constant tracking ON */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask|PointerMotionMask);
	  break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	  /* constant tracking OFF */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask);
	  break;
	default:
		rt_log("Glx_statechange: unknown state %s\n", state_str[b]);
		break;
	}

	Glx_viewchange( DM_CHGV_REDO, SOLID_NULL );
}

void
Glx_viewchange( cmd, sp )
register int cmd;
register struct solid *sp;
{
	if( glx_debug ) rt_log("viewchange( %d, x%x )\n", cmd, sp );
	switch( cmd )  {
	case DM_CHGV_ADD:
		break;
	case DM_CHGV_REDO:
		break;
	case DM_CHGV_DEL:
		break;
	case DM_CHGV_REPL:
		return;
	case DM_CHGV_ILLUM:
		break;
	}
}

void
Glx_debug(lvl)
{
	glx_debug = lvl;
}

void
Glx_window(w)
int w[];
{
}


/*
 *  			I R _ C O L O R C H A N G E
 *  
 *  Go through the solid table, and allocate color map slots.
 *	8 bit system gives 4 or 8,
 *	24 bit system gives 12 or 24.
 */
void
Glx_colorchange()
{
	register int i;
	register int nramp;

	if( glx_debug )  rt_log("colorchange\n");

	/* Program the builtin colors */
	glx_rgbtab[0].r=0; 
	glx_rgbtab[0].g=0; 
	glx_rgbtab[0].b=0;/* Black */
	glx_rgbtab[1].r=255; 
	glx_rgbtab[1].g=0; 
	glx_rgbtab[1].b=0;/* Red */
	glx_rgbtab[2].r=0; 
	glx_rgbtab[2].g=0; 
	glx_rgbtab[2].b=255;/* Blue */
	glx_rgbtab[3].r=255; 
	glx_rgbtab[3].g=255;
	glx_rgbtab[3].b=0;/*Yellow */
	glx_rgbtab[4].r = glx_rgbtab[4].g = glx_rgbtab[4].b = 255; /* White */
	slotsused = 5;

	if( glx_has_rgb )  {
		if(cueing_on) {
			depthcue(1);
		} else {
			depthcue(0);
		}

		RGBcolor( (short)255, (short)255, (short)255 );

		/* apply region-id based colors to the solid table */
		color_soltab();

		return;
	}

	glx_nslots = getplanes();
	if(cueing_on && (glx_nslots < 7)) {
		rt_log("Too few bitplanes: depthcueing disabled\n");
		cueing_on = 0;
	}
	glx_nslots = 1<<glx_nslots;
	if( glx_nslots > NSLOTS )  glx_nslots = NSLOTS;
	if(cueing_on) {
		/* peel off reserved ones */
		glx_nslots = (glx_nslots - CMAP_BASE) / CMAP_RAMP_WIDTH;
		depthcue(1);
	} else {
		glx_nslots -= CMAP_BASE;	/* peel off the reserved entries */
		depthcue(0);
	}

	ovec = -1;	/* Invalidate the old colormap entry */

	/* apply region-id based colors to the solid table */
	color_soltab();

	/* Map the colors in the solid table to colormap indices */
	glx_colorit();

	for( i=0; i < slotsused; i++ )  {
		glx_gen_color( i, glx_rgbtab[i].r, glx_rgbtab[i].g, glx_rgbtab[i].b);
	}

	color(WHITE);	/* undefinied after gconfig() */
}

void
glx_colorit()
{
	register struct solid	*sp;
	register struct rgbtab *rgb;
	register int i;
	register int r,g,b;

	if( glx_has_rgb )  return;

	FOR_ALL_SOLIDS( sp )  {
		r = sp->s_color[0];
		g = sp->s_color[1];
		b = sp->s_color[2];
		if( (r == 255 && g == 255 && b == 255) ||
		    (r == 0 && g == 0 && b == 0) )  {
			sp->s_dmindex = DM_WHITE;
			continue;
		}

		/* First, see if this matches an existing color map entry */
		rgb = glx_rgbtab;
		for( i = 0; i < slotsused; i++, rgb++ )  {
			if( rgb->r == r && rgb->g == g && rgb->b == b )  {
				sp->s_dmindex = i;
				goto next;
			}
		}

		/* If slots left, create a new color map entry, first-come basis */
		if( slotsused < glx_nslots )  {
			rgb = &glx_rgbtab[i=(slotsused++)];
			rgb->r = r;
			rgb->g = g;
			rgb->b = b;
			sp->s_dmindex = i;
			continue;
		}
		sp->s_dmindex = DM_YELLOW;	/* Default color */
next:		
		;
	}
}

/*
 *  I R _ D B T E X T
 *
 *  Used to call dbtext to print cute messages on the button box,
 *  if you have one.  Has to shift everythign to upper case
 *  since the box goes off the deep end with lower case.
 *
 *  Because not all SGI button boxes have text displays,
 *  this now needs to go to stdout in order to be useful.
 */

glx_dbtext(str)
register char *str;
{
#if IR_BUTTONS
	register i;
	char	buf[9];
	register char *cp;

# if 0
	for(i = 0, cp = buf; i < 8 && *str; i++, cp++, str++)
		*cp = islower(*str) ?  toupper(*str) : *str;
	*cp = 0;
	dbtext(buf);
# else
	rt_log("dm-4d: You pressed Help key and '%s'\n", str);
# endif
#else
	return;
#endif
}

#if IR_KNOBS
/*
 *			I R L I M I T
 *
 * Because the dials are so sensitive, setting them exactly to
 * zero is very difficult.  This function can be used to extend the
 * location of "zero" into "the dead zone".
 */
static 
int irlimit(i)
int i;
{
	if( i > NOISE )
		return( i-NOISE );
	if( i < -NOISE )
		return( i+NOISE );
	return(0);
}
#endif

/*			G E N _ C O L O R
 *
 *	maps a given color into the appropriate colormap entry
 *	for both depthcued and non-depthcued mode.  In depthcued mode,
 *	glx_gen_color also generates the colormap ramps.  Note that in depthcued
 *	mode, DM_BLACK uses map entry 0, and does not generate a ramp for it.
 *	Non depthcued mode skips the first CMAP_BASE colormap entries.
 *
 *	This routine is not called at all if rgb is set.
 */
glx_gen_color(c)
int c;
{
  return 0;
}

#ifdef never
/*
 *  Update the PF key lights.
 */
static int
kblights()
{
	char	lights;

	lights = (cueing_on)
	    | (zclipping_on << 1)
	    | (perspective_mode << 2)
	    | (zbuffer_on << 3);

	lampon(lights);
	lampoff(lights^0xf);
}
#endif

static void
establish_perspective()
{
  rt_vls_printf( &dm_values.dv_string,
		"set perspective %d\n",
		perspective_mode ?
		perspective_table[perspective_angle] :
		-1 );
  dmaflag = 1;
}

/*
   This routine will toggle the perspective_angle if the
   dummy_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (dummy_perspective - 1).
*/
static void
set_perspective()
{
  /* set perspective matrix */
  if(dummy_perspective > 0)
    perspective_angle = dummy_perspective <= 4 ? dummy_perspective - 1: 3;
  else if (--perspective_angle < 0) /* toggle perspective matrix */
    perspective_angle = 3;

  if(perspective_mode)
    rt_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[perspective_angle] );

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  dummy_perspective = 1;

  dmaflag = 1;
}

static void
establish_zbuffer()
{
	if( glx_has_zbuf == 0 )  {
		rt_log("dm-4d: This machine has no Zbuffer to enable\n");
		zbuffer_on = 0;
	}
	zbuffer( zbuffer_on );
	if( zbuffer_on)  {
		/* Set screen coords of near and far clipping planes */
		lsetdepth(min_scr_z, max_scr_z);
	}
	dmaflag = 1;
}

glx_clear_to_black()
{
	/* Re-enable the full viewport */
	viewport(0, winx_size, 0, winy_size);

	if( zbuffer_on )  {
		zfunction( ZF_LEQUAL );
		if( glx_has_rgb )  {
			czclear( 0x000000, max_scr_z );
		} else {
			czclear( BLACK, max_scr_z );
		}
	} else {
		if( glx_has_rgb )  {
			RGBcolor( (short)0, (short)0, (short)0 );
		} else {
			color(BLACK);
		}
		clear();
	}
}

#if 0
/* Handy fakeouts when we don't want to link with -lmpc */
usinit()	{ 
	rt_log("usinit\n"); 
}
usnewlock()	{ 
	rt_log("usnewlock\n"); 
}
taskcreate()	{ 
	rt_log("taskcreate\n"); 
}
#endif

/*
 *  The structparse will change the value of the variable.
 *  Just implement it, here.
 */
static void
establish_lighting()
{
	if( !lighting_on )  {
		/* Turn it off */
		mmode(MVIEWING);
		lmbind(MATERIAL,0);
		lmbind(LMODEL,0);
		mmode(MSINGLE);
	} else {
		/* Turn it on */
		if( cueing_on )  {
			/* Has to be off for lighting */
			cueing_on = 0;
			Glx_colorchange();
		}

		mmode(MVIEWING);


		glx_make_materials();	/* Define material properties */

		lmbind(LMODEL, 2);	/* infinite */
		lmbind(LIGHT2,2);
		lmbind(LIGHT3,3);
		lmbind(LIGHT4,4);
		lmbind(LIGHT5,5);

		/* RGB color commands & lighting */
		lmcolor( LMC_COLOR );

		mmode(MSINGLE);
	}
	dmaflag = 1;
}

/*
 *  Some initial lighting model stuff
 *  Really, MGED needs to derrive it's lighting from the database,
 *  but for now, this hack will suffice.
 *
 *  For materials, the definitions are:
 *	ALPHA		opacity.  1.0=opaque
 *	AMBIENT		ambient reflectance of the material  0..1
 *	DIFFUSE		diffuse reflectance of the material  0..1
 *	SPECULAR	specular reflectance of the material  0..1
 *	EMISSION	emission color ???
 *	SHININESS	specular scattering exponent, integer 0..128
 */
static float material_default[] = {
	ALPHA,		1.0,
	AMBIENT,	0.2, 0.2, 0.2,
	DIFFUSE,	0.8, 0.8, 0.8,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	0.0,
	SPECULAR,	0.0, 0.0, 0.0,
	LMNULL   };

/* Something like the RT default phong material */
static float material_rtdefault[] = {
	ALPHA,		1.0,	
	AMBIENT,	0.2, 0.2, 0.2,	/* 0.4 in rt */
	DIFFUSE,	0.6, 0.6, 0.6,
	SPECULAR,	0.2, 0.2, 0.2,
	EMISSION,	0.0, 0.0, 0.0,
	SHININESS,	10.0,
	LMNULL   };

/* This was the "default" material in the demo */
static float material_xdefault[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_brass[] = {
	AMBIENT, 0.35, 0.25,  0.1,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 5.0,
	LMNULL   };

static float mat_shinybrass[] = {
	AMBIENT, 0.25, 0.15, 0.0,
	DIFFUSE, 0.65, 0.5, 0.35,
	SPECULAR, 0.9, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_pewter[] = {
	AMBIENT, 0.0, 0.0,  0.0,
	DIFFUSE, 0.6, 0.55 , 0.65,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 10.0,
	LMNULL   };

static float mat_silver[] = {
	AMBIENT, 0.4, 0.4,  0.4,
	DIFFUSE, 0.3, 0.3, 0.3,
	SPECULAR, 0.9, 0.9, 0.95,
	SHININESS, 30.0,
	LMNULL   };

static float mat_gold[] = {
	AMBIENT, 0.4, 0.2, 0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.7, 0.7, 0.0,
	SHININESS, 10.0,
	LMNULL   };

static float mat_shinygold[] = {
	AMBIENT, 0.4, 0.2,  0.0,
	DIFFUSE, 0.9, 0.5, 0.0,
	SPECULAR, 0.9, 0.9, 0.0,
	SHININESS, 20.0,
	LMNULL   };

static float mat_plaster[] = {
	AMBIENT, 0.2, 0.2,  0.2,
	DIFFUSE, 0.95, 0.95, 0.95,
	SPECULAR, 0.0, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL   };

static float mat_redplastic[] = {
	AMBIENT, 0.3, 0.1, 0.1,
	DIFFUSE, 0.5, 0.1, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenplastic[] = {
	AMBIENT, 0.1, 0.3, 0.1,
	DIFFUSE, 0.1, 0.5, 0.1,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_blueplastic[] = {
	AMBIENT, 0.1, 0.1, 0.3,
	DIFFUSE, 0.1, 0.1, 0.5,
	SPECULAR, 0.45, 0.45, 0.45,
	SHININESS, 30.0,
	LMNULL   };

static float mat_greenflat[] = {
	EMISSION,   0.0, 0.4, 0.0,
	AMBIENT,    0.0, 0.0, 0.0,
	DIFFUSE,    0.0, 0.0, 0.0,
	SPECULAR,   0.0, 0.6, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_greenshiny[]= {
	EMISSION, 0.0, 0.4, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.25, 0.9, 0.25,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueflat[] = {
	EMISSION, 0.0, 0.0, 0.4,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.0, 0.5, 0.5,
	SPECULAR,  0.0, 0.0, 0.9,
	SHININESS, 10.0,
	LMNULL
};

static float mat_blueshiny[] = {
	EMISSION, 0.0, 0.0, 0.6,
	AMBIENT,  0.1, 0.25, 0.5,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_redflat[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 1.0,
	LMNULL
};

static float mat_redshiny[] = {
	EMISSION, 0.60, 0.0, 0.0,
	AMBIENT,  0.1, 0.25, 0.1,
	DIFFUSE,  0.5, 0.5, 0.5,
	SPECULAR,  0.5, 0.0, 0.0,
	SHININESS, 10.0,
	LMNULL
};

static float mat_beigeshiny[] = {
	EMISSION, 0.5, 0.5, 0.6,
	AMBIENT,  0.35, 0.35, 0.0,
	DIFFUSE,  0.5, 0.5, 0.0,
	SPECULAR,  0.5, 0.5, 0.0,
	SHININESS, 10.0,
	LMNULL
};

/*
 *  Meanings of the parameters:
 *	AMBIENT		ambient light associated with this source ???, 0..1
 *	LCOLOR		light color, 0..1
 *	POSITION	position of light.  w=0 for infinite lights
 */
static float default_light[] = {
	AMBIENT,	0.0, 0.0, 0.0, 
	LCOLOR,		1.0, 1.0, 1.0, 
	POSITION,	0.0, 0.0, 1.0, 0.0,
	LMNULL};


#if 1
# if 0
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, -200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, -100.0, -30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, 100.0, -20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, 100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 100.0, 200.0, 100.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.6, 0.1, 0.1, 
	POSITION, 100.0, 30.0, 100.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.3, 0.1, 
	POSITION, -100.0, 20.0, 20.0, 0.0, 
	LMNULL};


static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.3, 
	POSITION, 0.0, -100.0, -100.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 1.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};
# endif

#else
static float white_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.70, 0.70, 0.70, 
	POSITION, 10.0, 50.0, 50.0, 0.0, 
	LMNULL};


static float red_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.5, 0.1, 0.1, 
	POSITION, -100.0, 0.0, 0.0, 0.0, 
	LMNULL};

static float green_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.5, 0.1, 
	POSITION, 100.0, 50.0, 0.0, 0.0, 
	LMNULL};

static float blue_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.1, 0.1, 0.5, 
	POSITION, 0.0, -50.0, 0.0, 0.0, 
	LMNULL};

static float orange_inf_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,	0.35, 0.175, 0.0, 
	POSITION, -50.0, 50.0, 10.0, 0.0, 
	LMNULL};

static float white_local_light[] = {
	AMBIENT, 0.0, 0.0, 0.0, 
	LCOLOR,   0.75, 0.75, 0.75, 
	POSITION, 0.0, 10.0, 10.0, 5.0, 
	LMNULL};


#endif




/*
 *  Lighting model parameters
 *	AMBIENT		amount of ambient light present in the scene, 0..1
 *	ATTENUATION	fixed and variable attenuation factor, 0..1
 *	LOCALVIEWER	1=eye at (0,0,0), 0=eye at (0,0,+inf)
 */
static float	default_lmodel[] = {
	AMBIENT,	0.2,  0.2,  0.2,
	ATTENUATION,	1.0, 0.0, 
	LOCALVIEWER,	0.0, 
	LMNULL};

static float infinite[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 0.0, 
	LMNULL};

static float local[] = {
	AMBIENT, 0.3,  0.3, 0.3, 
	LOCALVIEWER, 1.0, 
	ATTENUATION, 1.0, 0.0, 
	LMNULL};


glx_make_materials()
{
	/* define material properties */
	lmdef (DEFMATERIAL, 1, 0, material_default);

	lmdef (DEFMATERIAL, 2, 0, mat_brass);
	lmdef (DEFMATERIAL, 3, 0, mat_shinybrass);
	lmdef (DEFMATERIAL, 4, 0, mat_pewter);
	lmdef (DEFMATERIAL, 5, 0, mat_silver);
	lmdef (DEFMATERIAL, 6, 0, mat_gold);
	lmdef (DEFMATERIAL, 7, 0, mat_shinygold);
	lmdef (DEFMATERIAL, 8, 0, mat_plaster);
	lmdef (DEFMATERIAL, 9, 0, mat_redplastic);
	lmdef (DEFMATERIAL, 10, 0, mat_greenplastic);
	lmdef (DEFMATERIAL, 11, 0, mat_blueplastic);

	lmdef (DEFMATERIAL, 12, 0, mat_greenflat);
	lmdef (DEFMATERIAL, 13, 0, mat_greenshiny);

	lmdef (DEFMATERIAL, 14, 0, mat_blueflat);
	lmdef (DEFMATERIAL, 15, 0, mat_blueshiny);

	lmdef (DEFMATERIAL, 16, 0, mat_redflat);
	lmdef (DEFMATERIAL, 17, 0, mat_redshiny);

	lmdef (DEFMATERIAL, 18, 0, mat_beigeshiny);

	lmdef( DEFMATERIAL, 19, 0, material_xdefault );
	lmdef( DEFMATERIAL, 20, 0, material_rtdefault );

	/*    lmdef (DEFLIGHT, 1, 0, default_light); */
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 2, 0, white_inf_light);
	lmdef (DEFLIGHT, 3, 0, red_inf_light);
	lmdef (DEFLIGHT, 4, 0, green_inf_light);
	lmdef (DEFLIGHT, 5, 0, blue_inf_light);
	/*    lmdef (DEFLIGHT, 6, 0, orange_inf_light); */
	lmdef (DEFLIGHT, 7, 0, white_local_light);

	lmdef (DEFLMODEL, 1, 0, default_lmodel);
	lmdef (DEFLMODEL, 2, 0, infinite);
	lmdef (DEFLMODEL, 3, 0, local);


}

/*
 *  Check to see if setmonitor(STR_RECT) will work.
 *  Returns -
 *	> 0	If stereo is available
 *	0	If not
 */
int
glx_has_stereo()
{
#if !defined(__sgi) && !defined(__mips)
	/* IRIX 3 systems, test to see if DER1_STEREO bit is
	 * read/write (no hardware underneath), or
	 * read only (hardware underneath, which can't be read back.
	 */
	int	rw_orig, rw1, rw2;

	rw_orig = getvideo(DE_R1);
	rw1 = rw_orig ^ DER1_STEREO;	/* Toggle the bit */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	rw1 = rw1 ^ DER1_STEREO;	/* Toggle the bit, again */
	setvideo(DE_R1, rw1);
	rw2 = getvideo(DE_R1);
	if( rw1 != rw2 )  {
		setvideo(DE_R1, rw_orig);/* Restore original state */
		return 1;		/* Has stereo */
	}
	setvideo(DE_R1, rw_orig);	/* Restore original state */
	return 0;			/* Does not have stereo */
#else
	/* IRIX 4 systems */
	return getgdesc(GD_STEREO);
#endif
}

/*
 *			I R _ D M
 * 
 *  Implement display-manager specific commands, from MGED "dm" command.
 */
int
Glx_dm(argc, argv)
int	argc;
char	**argv;
{
  struct rt_vls	vls;

  if( !strcmp( argv[0], "set" )){
    rt_vls_init(&vls);
    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      rt_structprint("dm_4d internal variables", Glx_vparse, (char *)0 );
      rt_log("%s", rt_vls_addr(&vls) );
    } else if( argc == 2 ) {
      rt_vls_name_print( &vls, Glx_vparse, argv[1], (CONST char *)0 );
      rt_log( "%s\n", rt_vls_addr(&vls) );
    } else {
      rt_vls_printf( &vls, "%s=\"", argv[1] );
      rt_vls_from_argv( &vls, argc-2, argv+2 );
      rt_vls_putc( &vls, '\"' );
      rt_structparse( &vls, Glx_vparse, (char *)0 );
    }
    rt_vls_free(&vls);
    return CMD_OK;
  }

  if( !strcmp( argv[0], "mouse" )){
    int up;
    int xpos;
    int ypos;

    if( argc < 4){
      rt_log("dm: need more parameters\n");
      rt_log("mouse 1|0 xpos ypos\n");
      return CMD_BAD;
    }

    up = atoi(argv[1]);
    xpos = atoi(argv[2]);
    ypos = atoi(argv[3]);
    rt_vls_printf(&dm_values.dv_string, "M %d %d %d\n",
		  up, irisX2ged(xpos), irisY2ged(ypos));
    return CMD_OK;
  }
  
  rt_log("dm: bad command - %s\n", argv[0]);
  return CMD_BAD;
}

void
set_knob_offset()
{
  int i;

  for(i = 0; i < 8; ++i){
#if 0
    knobs_offset[i] = knobs[i];
#else
    knobs[i] = 0;
#endif
  }
}
#endif
@


1.10
log
@not done, just playing it safe
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.9 1996/02/26 22:01:40 bparker Exp bparker $ (BRL)";
a423 2
  knob_offset_hook = set_knob_offset;

d450 1
a477 1
  rt_vls_init(&pathName);
a782 1
  knob_offset_hook = NULL;
d1286 1
a1286 1
  if(curr_dm_list->_mged_variables.send_key && eventPtr->type == KeyPress){
d1311 1
d1313 3
d1322 1
d1324 3
d2598 1
a2598 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.9 1996/02/26 22:01:40 bparker Exp bparker $ (BRL)";
a2646 1
extern void (*knob_offset_hook)();
@


1.9
log
@*** empty log message ***
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.8 1996/02/12 21:45:51 bparker Exp bparker $ (BRL)";
a93 1
extern void (*knob_offset_hook)();
a122 1

d167 2
d189 1
a423 3
  /* Ignore the old scrollbars and menus */
  mged_variables.show_menu = 0;

d474 5
d666 1
d669 1
d671 1
a671 1
  /* start with constant tracking OFF */
d673 1
a673 1
	       KeyPressMask|StructureNotifyMask);
d691 5
d784 1
a784 1
  Tk_DeleteGenericHandler(Glx_doevent, (ClientData)NULL);
d786 1
d790 7
a1271 5
/*XXX still drawing too much!!!
i.e. drawing 2 or more times when resizing the window to a larger size.
once for the Configure and once for the expose. This is especially
annoying when running remotely. */

d1275 1
d1281 7
d1289 1
a1289 1
  if(mged_variables.send_key && eventPtr->type == KeyPress){
d1291 1
d1294 4
a1297 1
		  (KeySym *)NULL, (XComposeStatus *)NULL);
d2531 2
d2540 1
d2548 1
a2549 1
  struct rt_vls str;
d2557 10
d2593 1
a2593 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.8 1996/02/12 21:45:51 bparker Exp bparker $ (BRL)";
@


1.8
log
@*** empty log message ***
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.7 1996/02/09 22:16:02 bparker Exp bparker $ (BRL)";
d65 1
d122 1
d124 1
a188 2
void glx_var_init();

a449 1
  XAnyClassPtr any;
a480 9
  /* initialize the modifiable variables */
  mvars.cueing_on = 1;          /* Depth cueing flag - for colormap work */
  mvars.zclipping_on = 1;       /* Z Clipping flag */
  mvars.zbuffer_on = 1;         /* Hardware Z buffer is on */
  mvars.lighting_on = 0;        /* Lighting model on */
  mvars.linewidth = 1;      /* Line drawing width */
  mvars.dummy_perspective = 1;
  mvars.perspective_mode = 0;   /* Perspective flag */

d725 9
a733 1
    return -1;
a768 1

d774 1
a774 1
  Tk_DeleteGenericHandler(Glx_doevent, (ClientData)curr_dm_list);
d845 1
a845 1
  if(mvars.doublebuffer ){
a1246 1
  XEvent event;
d1308 1
d1317 2
a1318 2
      rt_vls_printf( &cmd, "irot %f %f 0\n", (double)(my - omy)/2.0,
		     (double)(mx - omx)/2.0);
d1321 2
a1322 2
      rt_vls_printf( &cmd, "tran %f %f %f", ((double)mx/winx_size - 0.5) * 2,
		     (0.5 - (double)my/winy_size) * 2, tran_z);
d1325 1
a1325 1
      rt_vls_printf( &cmd, "zoom %lf", (double)(omy - my)/winy_size + 1.0);
a1326 3
    case VIRTUAL_TRACKBALL_IGNORE:
    default:
      goto end;
d1514 2
d1517 1
a1517 1
  if(!mvars.virtual_trackball){
a1518 2
 	switch( b )  {
	case ST_VIEW:
d1520 2
a1521 2
	    XSelectInput(dpy, win, ExposureMask|ButtonPressMask|ButtonReleaseMask|
			 KeyPressMask|StructureNotifyMask);
d1526 1
d1533 3
d1544 1
a1544 3
#ifdef VIRTUAL_TRACKBALL
  }
#endif
d1849 1
a1849 2
       state != ST_O_PATH && state != ST_S_VPICK){

a1852 1
    }
d1855 1
a1855 1
       state != ST_O_PATH && state != ST_S_VPICK){
a1859 1
    }
d2391 3
a2393 1
      rt_vls_printf(&dm_values.dv_string, "M %d %d %d\n",
d2395 2
a2412 1

a2423 3
	  struct rt_vls cmd;
	  rt_vls_init(&cmd);

d2425 3
a2427 2
	  rt_vls_printf( &cmd, "tran %f %f %f", ((double)omx/winx_size - 0.5) * 2,
			 (0.5 - (double)omy/winy_size) * 2, tran_z);
d2429 2
a2430 1
	  (void)cmdline(&cmd, FALSE);
d2459 1
a2459 1
      mvars.virtual_trackball = VIRTUAL_TRACKBALL_IGNORE;
d2483 1
a2483 1
void
d2497 1
a2497 1
void
d2506 7
d2516 1
a2516 1
struct dm_list *
d2555 1
a2555 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.7 1996/02/09 22:16:02 bparker Exp bparker $ (BRL)";
a2603 1
extern inventory_t	*getinvent();
@


1.7
log
@adding virtual trackball stuff
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.6 1996/01/26 15:52:56 bparker Exp bparker $ (BRL)";
a49 3
/* Experimental */
#define TRY_PIPES 1

a82 8
#ifdef VIRTUAL_TRACKBALL
#define VIRTUAL_TRACKBALL_OFF 0
#define VIRTUAL_TRACKBALL_IGNORE 1 /* Ignore motion events */
#define VIRTUAL_TRACKBALL_ROTATE 2 
#define VIRTUAL_TRACKBALL_TRANSLATE 3
#define VIRTUAL_TRACKBALL_ZOOM 4
#endif

d86 2
a87 2
#if TRY_PIPES
extern int ged_pipe[];
d161 1
a161 1
        int     virtual_trackball;
d699 1
d703 1
d714 1
d725 1
a731 10
/*XXX Temporary, so things will work without knowledge of the new environment
      variables */
  if( !found ) {
    rt_vls_strcpy( &str, "/m/cad/mged/");
    rt_vls_strcat( &str, filename);

    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
  }

d1270 2
a1271 2
#if TRY_PIPES
  if(mged_variables.focus && eventPtr->type == KeyPress){
d1277 1
a1277 1
    write(ged_pipe[1], buffer, 1);
d1331 1
a1331 1
      break;
d1519 1
d1521 1
d1545 1
d1547 1
d1846 1
d1868 1
d2405 1
d2478 3
d2552 1
a2552 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.6 1996/01/26 15:52:56 bparker Exp bparker $ (BRL)";
a2554 3
/* Experimental */
#define TRY_PIPES 1

d2595 2
a2596 2
#if TRY_PIPES
extern int ged_pipe[];
d3735 2
a3736 2
#if TRY_PIPES
  if(mged_variables.focus && eventPtr->type == KeyPress){
d3742 1
a3742 1
    write(ged_pipe[1], buffer, 1);
@


1.6
log
@*** empty log message ***
@
text
@d24 1
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.5 1996/01/22 22:50:40 bparker Exp bparker $ (BRL)";
a54 5
/* Forwards compat with IRIX 5.0.1 */
#define class	inv_class	/* Map Irix 4 name into Irix 5 name */
#define type	inv_type	/* Map Irix 4 name into Irix 5 name */
#define state	inv_state	/* Map Irix 4 name into Irix 5 name */

d86 8
d123 1
a132 30
#ifndef MULTI_ATTACH
/*
 * These variables are visible and modifiable via a "dm set" command.
 */
static int	cueing_on = 1;		/* Depth cueing flag - for colormap work */
static int	zclipping_on = 1;	/* Z Clipping flag */
static int	zbuffer_on = 1;		/* Hardware Z buffer is on */
static int	lighting_on = 0;	/* Lighting model on */
static int	glx_debug;		/* 2 for basic, 3 for full */
static int	no_faceplate = 0;	/* Don't draw faceplate */
static int	glx_linewidth = 1;	/* Line drawing width */
static int      dummy_perspective = 1;
static int      perspective_mode = 0;	/* Perspective flag */
/*
 * These are derived from the hardware inventory -- user can change them,
 * but the results may not be pleasing.  Mostly, this allows them to be seen.
 */
static int    glx_is_gt;              /* 0 for non-GT machines */
static int    glx_has_zbuf;           /* 0 if no Z buffer */
static int    glx_has_rgb;            /* 0 if mapped mode must be used */
static int    glx_has_doublebuffer;   /* 0 if singlebuffer mode must be used */

static int	min_scr_z;		/* based on getgdesc(GD_ZMIN) */
static int	max_scr_z;		/* based on getgdesc(GD_ZMAX) */
/* End modifiable variables */
#endif

static int glx_setup();

#ifdef MULTI_ATTACH
d142 4
d171 3
d182 3
a197 14
#else
static Tk_Window xtkwin;
static Display  *dpy;
static Window   win;
static long win_l, win_b, win_r, win_t;
static long winx_size, winy_size;
static int perspective_angle =3;	/* Angle of perspective */
static int devmotionnotify = LASTEvent;
static int devbuttonpress = LASTEvent;
static int devbuttonrelease = LASTEvent;
static int knobs[8] = {0, 0, 0, 0, 0, 0, 0, 0};
static int knobs_offset[8] = {0, 0, 0, 0, 0, 0, 0, 0};
static int	stereo_is_on = 0;
#endif
d281 1
a281 1
	"glx", "SGI 4d",
d292 3
a302 1
#ifdef MULTI_ATTACH
d318 3
a320 18
	{"",	0,  (char *)0,		0,			FUNC_NULL }
};
#else
struct structparse Glx_vparse[] = {
	{"%d",  1, "depthcue",		(int)&cueing_on,	Glx_colorchange },
	{"%d",  1, "zclip",		(int)&zclipping_on,	refresh_hook },
	{"%d",  1, "zbuffer",		(int)&zbuffer_on,	establish_zbuffer },
	{"%d",  1, "lighting",		(int)&lighting_on,	establish_lighting },
	{"%d",  1, "perspective",       (int)&perspective_mode, establish_perspective },
	{"%d",  1, "set_perspective",(int)&dummy_perspective,  set_perspective },
	{"%d",  1, "no_faceplate",	(int)&no_faceplate,	refresh_hook },
	{"%d",  1, "has_zbuf",		(int)&glx_has_zbuf,	refresh_hook },
	{"%d",  1, "has_rgb",		(int)&glx_has_rgb,	Glx_colorchange },
	{"%d",  1, "has_doublebuffer",	(int)&glx_has_doublebuffer, refresh_hook },
	{"%d",  1, "min_scr_z",		(int)&min_scr_z,	refresh_hook },
	{"%d",  1, "max_scr_z",		(int)&max_scr_z,	refresh_hook },
	{"%d",  1, "debug",		(int)&glx_debug,		FUNC_NULL },
	{"%d",  1, "linewidth",		(int)&glx_linewidth,	refresh_hook },
a322 1
#endif
d687 1
a687 1
  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
a1268 1
#ifdef MULTI_ATTACH
d1320 34
d1360 1
d1463 1173
d2637 1099
d3764 3
a3766 1
    if( mvars.doublebuffer) /* to fix back buffer */
a3767 1
    dmaflag = 1;
d3773 3
a3775 1
      if( mvars.doublebuffer ) /* to fix back buffer */
a3776 1
      dmaflag = 1;
a3888 1
#endif
d3956 1
a3956 1
	if( mvars.debug ) rt_log("statechange %d %d\n", a, b );
d3994 1
a3994 1
	if( mvars.debug ) rt_log("viewchange( %d, x%x )\n", cmd, sp );
d4012 1
a4012 1
	mvars.debug = lvl;
d4035 1
a4035 1
	if( mvars.debug )  rt_log("colorchange\n");
d4053 2
a4054 2
	if( mvars.rgb )  {
		if(mvars.cueing_on) {
d4069 1
a4069 1
	if(mvars.cueing_on && (glx_nslots < 7)) {
d4071 1
a4071 1
		mvars.cueing_on = 0;
d4075 1
a4075 1
	if(mvars.cueing_on) {
d4107 1
a4107 1
	if( mvars.rgb )  return;
d4203 1
a4203 1
 *	This routine is not called at all if mvars.rgb is set.
d4220 4
a4223 4
	lights = (mvars.cueing_on)
	    | (mvars.zclipping_on << 1)
	    | (mvars.perspective_mode << 2)
	    | (mvars.zbuffer_on << 3);
d4235 1
a4235 1
		mvars.perspective_mode ?
d4250 2
a4251 2
  if(mvars.dummy_perspective > 0)
    perspective_angle = mvars.dummy_perspective <= 4 ? mvars.dummy_perspective - 1: 3;
d4255 1
a4255 1
  if(mvars.perspective_mode)
d4264 1
a4264 1
  mvars.dummy_perspective = 1;
d4272 1
a4272 1
	if( mvars.zbuf == 0 )  {
d4274 1
a4274 1
		mvars.zbuffer_on = 0;
d4276 2
a4277 2
	zbuffer( mvars.zbuffer_on );
	if( mvars.zbuffer_on)  {
d4279 1
a4279 1
		lsetdepth(mvars.min_scr_z, mvars.max_scr_z);
d4289 1
a4289 1
	if( mvars.zbuffer_on )  {
d4291 2
a4292 2
		if( mvars.rgb )  {
			czclear( 0x000000, mvars.max_scr_z );
d4294 1
a4294 1
			czclear( BLACK, mvars.max_scr_z );
d4297 1
a4297 1
		if( mvars.rgb )  {
d4326 1
a4326 1
	if( !mvars.lighting_on )  {
d4334 1
a4334 1
		if( mvars.cueing_on )  {
d4336 1
a4336 1
			mvars.cueing_on = 0;
a4780 3
#ifdef MULTI_ATTACH
      rt_structprint("dm_4d internal variables", Glx_vparse, (CONST char *)&mvars );
#else
a4781 1
#endif
d4784 1
a4784 1
      rt_vls_name_print( &vls, Glx_vparse, argv[1], (CONST char *)&mvars );
d4790 1
a4790 1
      rt_structparse( &vls, Glx_vparse, (char *)&mvars);
a4830 30
}

#ifdef MULTI_ATTACH
void
glx_var_init()
{
  dm_vars = (char *)rt_malloc(sizeof(struct glx_vars),
					    "glx_var_init: glx_vars");
  bzero((void *)dm_vars, sizeof(struct glx_vars));
  devmotionnotify = LASTEvent;
  devbuttonpress = LASTEvent;
  devbuttonrelease = LASTEvent;
}


struct dm_list *
get_dm_list(window)
Window window;
{
  register struct dm_list *p;
  struct rt_vls str;

  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
    if(window == ((struct glx_vars *)p->_dm_vars)->_win){
      TkGLXwin_RefWinset(((struct glx_vars *)p->_dm_vars)->_ref, GLX_NORMAL);
      return p;
    }
  }

  return DM_LIST_NULL;
@


1.5
log
@*** empty log message ***
@
text
@d31 3
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.4 1996/01/19 22:31:15 bparker Exp bparker $ (BRL)";
d125 1
a125 1
static int Glxcheckevents();
d727 1
a727 1
			  (ClientData)rt_vls_addr(&pathName));
d743 1
d747 1
a747 1
#define DM_GLX_RCFILE "glxinit2.tk"
d752 3
d758 1
a758 1
    rt_vls_strcat( &str, DM_GLX_RCFILE );
d768 1
a768 1
      rt_vls_strcat( &str, DM_GLX_RCFILE );
d776 2
a777 2
    if( (fp = fopen( DM_GLX_RCFILE, "r" )) != NULL )  {
      rt_vls_strcpy( &str, DM_GLX_RCFILE );
d786 1
a786 1
    rt_vls_strcat( &str, DM_GLX_RCFILE);
d800 1
a800 1
    rt_log("Error reading %s: %s\n", DM_GLX_RCFILE, interp->result);
d836 1
a836 2
  Tk_DeleteGenericHandler(Glx_doevent,
			  (ClientData)rt_vls_addr(&pathName));
d844 1
a844 1
 *			I R _ P R O L O G
d860 6
a865 1
  glx_clear_to_black();
d907 1
a907 1
  if(mvars.doublebuffer )
d909 3
a1314 1
  register struct dm_list *save_dm_list2;
d1325 1
@


1.4
log
@*** empty log message ***
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.3 1996/01/17 22:00:48 bparker Exp bparker $ (BRL)";
d466 1
a466 2
    if( glx_setup(line) ) {
      rt_free(dm_vars, "Glx_open: dm_vars");
a467 1
    }
d469 1
a469 2
    if( glx_setup(envp) ) {
      rt_free(dm_vars, "Glx_open: dm_vars");
a470 1
    }
@


1.3
log
@playing it safe
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.2 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
a97 1
void set_knob_offset();
d116 3
a118 1
int   Glx_loadGLX();
d120 1
a120 1
Tk_GenericProc Glx_checkevents;
d122 1
a122 1
int Glxcheckevents();
d152 1
a152 1
static int irsetup();
a209 1
static struct dm_list *get_dm_list();
d446 30
a475 28
        char	line[82];
        char	hostname[80];
	char	display[82];
	char	*envp;

	glx_var_init();
	/* get or create the default display */
	if( (envp = getenv("DISPLAY")) == NULL ) {
		/* Env not set, use local host */
		gethostname( hostname, 80 );
		hostname[79] = '\0';
		(void)sprintf( display, "%s:0", hostname );
		envp = display;
	}

	rt_log("X Display [%s]? ", envp );
	(void)fgets( line, sizeof(line), stdin );
	line[strlen(line)-1] = '\0';		/* remove newline */
	if( feof(stdin) )  quit();
	if( line[0] != '\0' ) {
		if( irsetup(line) ) {
			return(1);		/* BAD */
		}
	} else {
		if( irsetup(envp) ) {
			return(1);	/* BAD */
		}
	}
d477 2
a478 2
	/* Ignore the old scrollbars and menus */
	mged_variables.show_menu = 0;
d480 1
a480 1
	knob_offset_hook = set_knob_offset;
d482 1
a482 1
	return(0);			/* OK */
d486 1
a486 1
irsetup( name )
a490 1
  char tmp_str[64];
d505 1
a507 7
  sprintf(tmp_str, "%s%d", "mged", ref_count++);
  ref = strdup(tmp_str);

  rt_vls_init(&pathName);
  rt_vls_printf(&pathName, ".%s.glx", ref);

	  
a508 1
  rt_vls_printf(&str, "loadtk %s\n", name);
d510 1
d512 2
d519 11
a529 2
	
  (void)TkGLX_Init(interp, tkwin);
d531 4
a534 3
  /* Invoke script to create button and key bindings */
  if( Glx_loadGLX() )
    return -1;
d536 1
d545 2
a546 1
  if((tmp_dpy = XOpenDisplay(name)) == NULL)
d548 1
d566 2
a567 10
  rt_vls_printf(&str, "%s .%s glx %s %d %d true true\n", name,
		ref, ref, winx_size, winy_size);

#if 0
  /*
   * Call bindem to bind key and mouse events. Bindem is defined
   * in glxinit.tk
   */
  rt_vls_printf(&str, "bindem .%s\n", ref);
#endif
d595 1
a595 2
  {
    GLXconfig *glx_config, *p;
d597 50
a646 55
    glx_config = TkGLXwin_RefGetConfig(ref);

    /* set configuration variables */
    for(p = glx_config; p->buffer; ++p){
	    switch(p->buffer){
	    case GLX_NORMAL:
	      switch(p->mode){
	      case GLX_ZSIZE:
		if(p->arg)
		  mvars.zbuf = 1;
		else
		  mvars.zbuf = 0;

		break;
	      case GLX_RGB:
		if(p->arg)
		  mvars.rgb = 1;
		else
		  mvars.rgb = 0;

		break;
	      case GLX_DOUBLE:
		if(p->arg)
		  mvars.doublebuffer = 1;
		else
		  mvars.doublebuffer = 0;

		break;
	      case GLX_STEREOBUF:
		stereo_is_on = 1;

		break;
	      case GLX_BUFSIZE:
	      case GLX_STENSIZE:
	      case GLX_ACSIZE:
	      case GLX_VISUAL:
	      case GLX_COLORMAP:
	      case GLX_WINDOW:
	      case GLX_MSSAMPLE:
	      case GLX_MSZSIZE:
	      case GLX_MSSSIZE:
	      case GLX_RGBSIZE:
	      default:
		break;
	      }
	    case GLX_OVERLAY:
	    case GLX_POPUP:
	    case GLX_UNDERLAY:
	    default:
	      break;
	    }
	  }

	  free((void *)glx_config);
	}
d648 1
d650 2
a651 2
	if (mged_variables.sgi_win_size > 0)
		win_size = mged_variables.sgi_win_size;
d653 2
a654 2
	if (mged_variables.sgi_win_origin[0] != 0)
		win_o_x = mged_variables.sgi_win_origin[0];
d656 2
a657 10
	if (mged_variables.sgi_win_origin[1] != 0)
		win_o_y = mged_variables.sgi_win_origin[1];
#if 0
	prefposition( win_o_x, win_o_x+win_size, win_o_y, win_o_y+win_size);
#else
#endif
#if 0
	keepaspect(1,1);	/* enforce 1:1 aspect ratio */
#endif
	winconstraints();	/* remove constraints on the window size */
d659 1
a659 5
	/*
	 * Establish GL library operating modes
	 */
	/* Don't draw polygon edges */
	glcompat( GLC_OLDPOLYGON, 0 );
d661 5
a665 7
	/* Z-range mapping */
	/* Z range from getgdesc(GD_ZMIN)
	 * to getgdesc(GD_ZMAX).
	 * Hardware specific.
	 */
	glcompat( GLC_ZRANGEMAP, 0 );
	/* Take off a smidgeon for wraparound, as suggested by SGI manual */
d667 7
a673 2
	mvars.min_scr_z = getgdesc(GD_ZMIN)+15;
	mvars.max_scr_z = getgdesc(GD_ZMAX)-15;
d675 2
a676 1
	Glx_configure_window_shape();
d678 1
a678 3
	/* Line style 0 is solid.  Program line style 1 as dot-dashed */
	deflinestyle( 1, 0xCF33 );
	setlinestyle( 0 );
d680 3
a682 5
	/*
	 * Take a look at the available input devices. We're looking
	 * for "dial+buttons".
	 */
	olist = list = (XDeviceInfoPtr) XListInputDevices (dpy, &ndevices);
d684 5
a688 29
	/* IRIX 4.0.5 bug workaround */
	if( list == (XDeviceInfoPtr)NULL ||
	   list == (XDeviceInfoPtr)1 )  goto Done;

	for(j = 0; j < ndevices; ++j, list++){
	  if(list->use == IsXExtensionDevice){
	    if(!strcmp(list->name, "dial+buttons")){
	      if((dev = XOpenDevice(dpy, list->id)) == (XDevice *)NULL){
		rt_log("Glx_open: Couldn't open the dials+buttons\n");
		goto Done;
	      }

	      for(cip = dev->classes, k = 0; k < dev->num_classes;
		  ++k, ++cip){
		switch(cip->input_class){
		case ButtonClass:
		  DeviceButtonPress(dev, devbuttonpress, e_class[nclass]);
		  ++nclass;
		  DeviceButtonRelease(dev, devbuttonrelease, e_class[nclass]);
		  ++nclass;
		  break;
		case ValuatorClass:
		  DeviceMotionNotify(dev, devmotionnotify, e_class[nclass]);
		  ++nclass;
		  break;
		default:
		  break;
		}
	      }
d690 27
a716 3
	      XSelectExtensionEvent(dpy, win, e_class, nclass);
	      goto Done;
	    }
d719 6
d726 3
a728 5
	XFreeDeviceList(olist);
	Tk_CreateGenericHandler(Glx_checkevents,
				(ClientData)rt_vls_addr(&pathName));
	XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		     KeyPressMask|StructureNotifyMask);
d730 5
a734 1
	return(0);
d739 1
a739 1
Glx_loadGLX()
a744 1
  int bogus;
d753 5
a757 2
    if ((fp = fopen(path, "r")) != NULL ) {
      rt_vls_strcpy( &str, path );
a758 1
    }
d833 1
a833 1
  Tk_DeleteGenericHandler(Glx_checkevents,
d836 1
a836 1
  rt_free(dm_vars, "glx_close: dm_vars");
d1295 1
a1295 1
Glx_checkevents(clientData, eventPtr)
d2501 1
a2501 1
	struct rt_vls	vls;
d2503 4
a2506 4
	if( !strcmp( argv[0], "set" )){
	  rt_vls_init(&vls);
	  if( argc < 2 )  {
	    /* Bare set command, print out current settings */
d2508 1
a2508 1
	    rt_structprint("dm_4d internal variables", Glx_vparse, (CONST char *)&mvars );
d2510 1
a2510 1
	    rt_structprint("dm_4d internal variables", Glx_vparse, (char *)0 );
d2512 13
a2524 13
	    rt_log("%s", rt_vls_addr(&vls) );
	  } else if( argc == 2 ) {
	    rt_vls_name_print( &vls, Glx_vparse, argv[1], (CONST char *)&mvars );
	    rt_log( "%s\n", rt_vls_addr(&vls) );
	  } else {
	    rt_vls_printf( &vls, "%s=\"", argv[1] );
	    rt_vls_from_argv( &vls, argc-2, argv+2 );
	    rt_vls_putc( &vls, '\"' );
	    rt_structparse( &vls, Glx_vparse, (char *)&mvars);
	  }
	  rt_vls_free(&vls);
	  return CMD_OK;
	}
d2526 10
a2535 10
	if( !strcmp( argv[0], "mouse" )){
	  int up;
	  int xpos;
	  int ypos;

	  if( argc < 4){
	    rt_log("dm: need more parameters\n");
	    rt_log("mouse 1|0 xpos ypos\n");
	    return CMD_BAD;
	  }
d2537 10
a2546 10
	  up = atoi(argv[1]);
	  xpos = atoi(argv[2]);
	  ypos = atoi(argv[3]);
	  rt_vls_printf(&dm_values.dv_string, "M %d %d %d\n",
			up, irisX2ged(xpos), irisY2ged(ypos));
	  return CMD_OK;
	}

	rt_log("dm: bad command - %s\n", argv[0]);
	return CMD_BAD;
d2568 1
a2568 1
					    "glx_vars");
d2574 1
@


1.2
log
@Just playing it safe
@
text
@d4 2
a5 2
   DM-4D.C currently uses the commands below. These particular commands
   should not be used in mixed mode programming.
d27 2
a28 1
 *  This version for the SGI 4-D Iris, both regular and GT versions.
a29 2
 *  Uses library -lgl
 *
a30 3
 *	Paul R. Stay
 *	Michael John Muuss
 *	Robert J. Reschly
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-glx.c,v 1.1 1995/12/27 22:29:47 bparker Exp bparker $ (BRL)";
a46 1
#define MIXED_MODE 1
d116 1
a116 1
#if MIXED_MODE
a122 3
#else
void    Glx_checkevents();
#endif
d124 1
d141 5
a145 4
static int	glx_is_gt;		/* 0 for non-GT machines */
static int	glx_has_zbuf;		/* 0 if no Z buffer */
static int	glx_has_rgb;		/* 0 if mapped mode must be used */
static int	glx_has_doublebuffer;	/* 0 if singlebuffer mode must be used */
d149 1
a151 6
GLXconfig glxConfig [] = {
  { GLX_NORMAL, GLX_DOUBLE, TRUE },
  { GLX_NORMAL, GLX_RGB, TRUE },
  { GLX_NORMAL, GLX_ZSIZE, GLX_NOCONFIG },
  { 0, 0, 0 }
};
a167 1
#define knobs_offset (((struct glx_vars *)dm_vars)->_knobs_offset)
d170 19
d194 1
a194 1
  long _win_l, _win_b, _wind_r, _win_t;
a200 1
  int _knobs_offset[8];
d203 3
a224 2
static int	glx_fd;			/* GL file descriptor to select() on */
static CONST char glx_title[] = "BRL MGED";
a230 1
static mat_t	aspect_corr;
d325 20
d362 1
a363 1

d379 1
a379 12
#if MIXED_MODE
	x = (x/(double)winx_size - 0.5) * 4095;
#else
	if( x <= win_l )  return(-2048);
	if( x >= win_r )  return(2047);

	x -= win_l;
	x = ( x / (double)winx_size)*4096.0;
	x -= 2048;
#endif

	return(x);
d386 1
a386 13
#if MIXED_MODE
	y = (0.5 - y/(double)winy_size) * 4095;
#else
	if( y <= win_b )  return(-2048);
	if( y >= win_t )  return(2047);

	y -= win_b;
	if( stereo_is_on )  y = (y%512)<<1;
	y = ( y / (double)winy_size)*4096.0;
	y -= 2048;
#endif

	return(y);
d399 6
a404 4
	int		npix;
#if MIXED_MODE
	XWindowAttributes xwa;
#endif
d406 2
a407 11
	xlim_view = 1.0;
	ylim_view = 1.0;
	mat_idn(aspect_corr);

#if MIXED_MODE
	XGetWindowAttributes( dpy, win, &xwa );
	winx_size = xwa.width;
	winy_size = xwa.height;
#else
	getsize( &winx_size, &winy_size);
	getorigin( &win_l, & win_b );
d409 2
a410 5
	win_r = win_l + winx_size;
	win_t = win_b + winy_size;
#endif
	/* Write enable all the bloody bits after resize! */
	viewport(0, winx_size, 0, winy_size);
d412 1
a412 2
	if( glx_has_zbuf ) establish_zbuffer();
	establish_lighting();
d414 8
a421 69
	if( glx_has_doublebuffer)
	{
		/* Clear out image from windows underneath */
		frontbuffer(1);
		glx_clear_to_black();
		frontbuffer(0);
		glx_clear_to_black();
	} else
		glx_clear_to_black();

#if MIXED_MODE
#else
	switch( getmonitor() )  {
	default:
		break;
	case NTSC:
		/* Only use the central square part, due to overscan */
		npix = YMAX170-30;
		winx_size = npix * 4 / 3;	/* NTSC aspect ratio */
		winy_size = npix;
		win_l = (XMAX170 - winx_size)/2;
		win_r = win_l + winx_size;
		win_b = (YMAX170-winy_size)/2;
		win_t = win_b + winy_size;

		if( no_faceplate )  {
			/* Use the whole screen, for VR & visualization */
			viewport( 0, XMAX170, 0, YMAX170 );
		} else {
			/* Only use the central (square) faceplate area */
			/*
			 * XXX Does this viewport() call do anything?  (Write enable pixels maybe?)
			 * XXX (1) the first frame (only) is shrunken oddly in X, and
			 * XXX (2) the drawing overflows the boundaries.
			 * XXX Perhaps XY clipping could be used?
			 * At least the aspect ratio is right!
			 */
			/* XXXXX See page 8-9 in the manual.
			 * XXX The best way to do the masking in NTSC mode is to
			 * XXX just set a Z-buffer write mask of 0 on the parts we don't
			 * XXX want to have written.
			 */
			viewport( (XMAX170 - npix)/2, npix + (XMAX170 - npix)/2,
			    (YMAX170-npix)/2, npix + (YMAX170-npix)/2 );
		}
		/* Aspect ratio correction is needed either way */
		xlim_view = XMAX170 / (double)YMAX170;
		ylim_view = 1;	/* YMAX170 / YMAX170 */

		glx_linewidth = 3;
		blanktime(0);	/* don't screensave while recording video! */
		break;
	case PAL:
		/* Only use the central square part */
		npix = YMAXPAL-30;
		winx_size = npix;	/* What is PAL aspect ratio? */
		winy_size = npix;
		win_l = (XMAXPAL - winx_size)/2;
		win_r = win_l + winx_size;
		;
		win_b = (YMAXPAL-winy_size)/2;
		win_t = win_b + winy_size;
		viewport( (XMAXPAL - npix)/2, npix + (XMAXPAL - npix)/2,
		    (YMAXPAL-npix)/2, npix + (YMAXPAL-npix)/2 );
		glx_linewidth = 3;
		blanktime(0);	/* don't screensave while recording video! */
		break;
	}
#endif
d423 2
a424 4
	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
	/* The ortho() call really just makes this matrix: */
	aspect_corr[0] = 1/xlim_view;
	aspect_corr[5] = 1/ylim_view;
d429 1
a429 1
#define MAP_ENTRY(x)	((cueing_on) ? \
d476 1
a476 1
	ignore_scroll_and_menu = 1;
d513 2
a514 2
	rt_vls_init(&str);
	rt_vls_printf(&str, "loadtk %s\n", name);
d516 6
a521 6
	if(tkwin == NULL){
	  if(cmdline(&str, FALSE) == CMD_BAD){
	    rt_vls_free(&str);
	    return -1;
	  }
	}
d523 1
a523 1
	(void)TkGLX_Init(interp, tkwin);
d525 23
a547 3
	/* Invoke script to create button and key bindings */
	if( Glx_loadGLX() )
	  return -1;
d549 1
a549 7
#if 0
	dpy = Tk_Display(tkwin);
	winx_size = DisplayWidth(dpy, Tk_ScreenNumber(tkwin)) - 20;
	winy_size = DisplayHeight(dpy, Tk_ScreenNumber(tkwin)) - 20;
#else
	if((tmp_dpy = XOpenDisplay(name)) == NULL)
	  return -1;
d551 7
a557 2
	winx_size = DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
	winy_size = DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
a558 11
	XCloseDisplay(tmp_dpy);
#endif
	if(winx_size > winy_size)
	  winx_size = winy_size;
	else
	  winy_size = winx_size;

	rt_vls_strcpy(&str, "create_glx ");
	rt_vls_printf(&str, "%s .%s glx %s %d %d true true\n", name,
		      ref, ref, winx_size, winy_size);
	rt_vls_printf(&str, "bindem .%s\n", ref);
d560 5
a564 1
	rt_vls_printf(&str, "pack .%s -expand 1 -fill both\n", ref);
d566 5
a570 4
	if(cmdline(&str, FALSE) == CMD_BAD){
	  rt_vls_free(&str);
	  return -1;
	}
d572 1
a572 1
	rt_vls_free(&str);
d574 10
a583 4
	if(TkGLXwin_RefExists(ref)){
	  xtkwin = TkGLXwin_RefGetTkwin(ref);
	  if(xtkwin == NULL)
	    return -1;
d585 2
a586 5
	  dpy = Tk_Display(xtkwin);
	}else{
	  rt_log("Glx_open: ref - %s doesn't exist!!!\n", ref);
	  return -1;
	}
d588 2
a589 2
	/* Do this now to force a GLXlink */
	Tk_MapWindow(xtkwin);
d591 1
a591 2
	Tk_MakeWindowExist(xtkwin);
	win = Tk_WindowId(xtkwin);
d593 2
a594 1
	glx_is_gt = 1;
d596 1
a596 2
	{
	  GLXconfig *glx_config, *p;
d598 2
a599 3
	  glx_config = TkGLXwin_RefGetConfig(ref);
	
	  for(p = glx_config; p->buffer; ++p){
d605 1
a605 1
		  glx_has_zbuf = 1;
d607 1
a607 1
		  glx_has_zbuf = 0;
d612 1
a612 1
		  glx_has_rgb = 1;
d614 1
a614 1
		  glx_has_rgb = 0;
d619 1
a619 1
		  glx_has_doublebuffer = 1;
d621 1
a621 1
		  glx_has_doublebuffer = 0;
a651 5
#if 0
	/* Start out with the usual window */
/*XXX Not supposed to be using this guy in mixed mode. */
	foreground();
#endif
d683 3
a685 7
#if 1
	min_scr_z = getgdesc(GD_ZMIN)+15;
	max_scr_z = getgdesc(GD_ZMAX)-15;
#else
	min_scr_z = 0;
	max_scr_z = 0;
#endif
d693 4
a696 1
/* Take a look at the available input devices */
d736 2
a737 1
	Tk_CreateGenericHandler(Glx_checkevents, (ClientData)NULL);
d754 1
a754 1
#define DM_GLX_ENVRC "MGED_DM_GLX_RCFILE"
d760 1
a760 1
  if((path = getenv(DM_GLX_ENVRC)) != (char *)NULL ){
d821 2
a822 15
	if(cueing_on) depthcue(0);

	lampoff( 0xf );

	/* avoids error messages when reattaching */
	mmode(MVIEWING);	
	lmbind(LIGHT2,0);
	lmbind(LIGHT3,0);
	lmbind(LIGHT4,0);
	lmbind(LIGHT5,0);


	frontbuffer(1);
	glx_clear_to_black();
	frontbuffer(0);
d824 1
a824 8
#if MIXED_MODE
	Tk_DestroyWindow(xtkwin);
#else
	if( getmonitor() != glx_oldmonitor )
		setmonitor(glx_oldmonitor);

	winclose(gr_id);
#endif
d826 19
a844 7
	/* Stop ignoring the old scrollbars and menus */
	ignore_scroll_and_menu = 0;

	knob_offset_hook = NULL;
	rt_free(dm_vars, "dm_vars");
	rt_vls_free(&pathName);
	free(ref);
d858 1
a858 10
  struct rt_vls str;

  rt_vls_init(&str);
  rt_vls_printf(&str, "%s winset\n", rt_vls_addr(&pathName));

  if(cmdline(&str, FALSE) == CMD_BAD){
    rt_vls_free(&str);
    rt_log("Glx_prolog: winset failed\n");
    return;
  }
d860 2
a861 9
  rt_vls_free(&str);

	if (glx_debug)
		rt_log( "Glx_prolog\n");
#if 0
	ortho2( -1.0,1.0, -1.0,1.0);	/* L R Bot Top */
#else
	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
#endif
d863 3
a865 6
	if( dmaflag && !glx_has_doublebuffer )
	{
		glx_clear_to_black();
		return;
	}
	linewidth(glx_linewidth);
d878 2
a879 2
	if (glx_debug)
		rt_log( "Glx_normal\n");
d881 5
a885 5
	if( glx_has_rgb )  {
		RGBcolor( (short)0, (short)0, (short)0 );
	} else {
		color(BLACK);
	}
d887 1
a887 5
#if 0
	ortho2( -1.0,1.0, -1.0,1.0);	/* L R Bot Top */
#else
	ortho( -xlim_view, xlim_view, -ylim_view, ylim_view, -1.0, 1.0 );
#endif
d896 9
a904 8
	if (glx_debug)
		rt_log( "Glx_epilog\n");
	/*
	 * A Point, in the Center of the Screen.
	 * This is drawn last, to always come out on top.
	 */
	Glx_2d_line( 0, 0, 0, 0, 0 );
	/* End of faceplate */
d906 2
a907 6
	if(glx_has_doublebuffer )
	{
		swapbuffers();
		/* give Graphics pipe time to work */
		glx_clear_to_black();
	}
d945 1
a945 1
	if (glx_debug)
d963 1
a963 1
	if( ! zclipping_on ) {
d973 10
a982 17
#if 0
	for(i= 0; i < 4; i++) {
		gtmat[0][i] = *(mptr++);
		gtmat[1][i] = *(mptr++);
		gtmat[2][i] = *(mptr++);
		gtmat[3][i] = *(mptr++);
	}
#else
	gtmat[0][0] = *(mptr++) * aspect_corr[0];
	gtmat[1][0] = *(mptr++) * aspect_corr[0];
	gtmat[2][0] = *(mptr++) * aspect_corr[0];
	gtmat[3][0] = *(mptr++) * aspect_corr[0];

	gtmat[0][1] = *(mptr++) * aspect_corr[5];
	gtmat[1][1] = *(mptr++) * aspect_corr[5];
	gtmat[2][1] = *(mptr++) * aspect_corr[5];
	gtmat[3][1] = *(mptr++) * aspect_corr[5];
a992 1
#endif
d1041 1
a1041 1
	if (glx_debug)
d1065 1
a1065 1
	if( glx_has_rgb )  {
d1074 1
a1074 1
		if(cueing_on)  {
d1078 1
a1078 1
			    min_scr_z, max_scr_z );
d1080 1
a1080 1
		if(lighting_on && glx_is_gt)
d1109 1
a1109 1
			if(cueing_on)  {
d1111 1
a1111 1
				    min_scr_z, max_scr_z );
d1121 1
a1121 1
				if(cueing_on)  {
d1123 1
a1123 1
					    min_scr_z, max_scr_z );
d1201 1
a1201 1
	if (glx_debug)
d1218 1
a1218 1
	if (glx_debug)
d1221 1
a1221 1
	if( glx_has_rgb )  {
d1243 1
a1243 1
	if (glx_debug)
d1245 1
a1245 1
	if( glx_has_rgb )  {
d1247 1
a1247 1
		if(cueing_on)  {
d1251 1
a1251 1
			    min_scr_z, max_scr_z );
d1256 2
a1257 2
			if(cueing_on) lshaderange(nvec, nvec,
			    min_scr_z, max_scr_z );
d1289 1
a1289 67
	static int cnt;
	register int i;
	struct timeval	tv;
	fd_set		files;
	int		width;

#if MIXED_MODE
/* Don't need to do this because Glx_input never gets called anyway */
#else
	if (glx_debug)
		rt_log( "Glx_input()\n");
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
		width = 32;
	files = *input;		/* save, for restore on each loop */
	FD_SET( glx_fd, &files );

	/*
	 * Check for input on the keyboard or on the polled registers.
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  A change in peripheral status occurs
	 *  3)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which the peripherals (rate setting) may not be changed,
	 * but we still have to update the display,
	 * do not suspend execution.
	 */
	do  {
		cnt = 0;
		i = qtest();
		if( i != 0 )  {
			FD_ZERO( input );
			FD_SET( glx_fd, input );
			break;		/* There is device input */
		}
		*input = files;

		tv.tv_sec = 0;
		if( noblock )  {
			tv.tv_usec = 0;
		}  else {
			/* 1/20th second */
			tv.tv_usec = 50000;
		}
		cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
		if( cnt < 0 )  {
			perror("dm-4d.c/select");
			break;
		}
		if( noblock )  break;
		for( i=0; i<width; i++ )  {
			if( FD_ISSET(i, input) )  goto input_waiting;
		}
	} while( noblock == 0 );

input_waiting:
	/*
	 * Set device interface structure for GED to "rest" state.
	 * First, process any messages that came in.
	 */

	if( FD_ISSET( glx_fd, input ) )
		Glx_checkevents();
#endif
	return;
d1294 5
a1298 4
   This routine does not get key events. The key events are
   being processed via the TCL/TK bind command. Eventually, I'd also
   like to do the dials+buttons that way. That would leave this
   routine to handle only events like Expose and ConfigureNotify.
d1309 1
d1311 2
d1350 2
a1351 3
    if( glx_has_doublebuffer) /* to fix back buffer */
      refresh();
    dmaflag = 1;
a1355 3
      if (eventPtr->xany.window != win)
	goto end;

d1357 2
a1358 3
      if( glx_has_doublebuffer) /* to fix back buffer */
	refresh();
      dmaflag = 1;
a1372 1
      knobs_during_help[M->first_axis] = M->axis_data[0];
a1375 3
    }else{
      knobs[M->first_axis] = M->axis_data[0];
      setting = irlimit(knobs[M->first_axis] - knobs_offset[M->first_axis]);
d1378 4
d1460 1
a1460 3
    if(B->button == 1){
      int i;

a1461 5

      /* update the offset */
      for(i = 0; i < 8; ++i)
	knobs_offset[i] += knobs_during_help[i] - knobs[i];
    }
d1464 1
a1465 1
  (void)cmdline(&cmd, FALSE);
d1497 1
a1497 1
    if( glx_has_doublebuffer) /* to fix back buffer */
d1505 1
a1505 1
      if( glx_has_doublebuffer) /* to fix back buffer */
d1688 1
a1688 1
	if( glx_debug ) rt_log("statechange %d %d\n", a, b );
a1693 1
#if MIXED_MODE
a1712 19
#else
	switch( b )  {
	case ST_VIEW:
		unqdevice( MOUSEY );	/* constant tracking OFF */
		/* This should not affect the tie()'d MOUSEY events */
		break;

	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
		/*  Have all changes of MOUSEY generate an event */
		qdevice( MOUSEY );	/* constant tracking ON */
		break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	case ST_S_VPICK:
		unqdevice( MOUSEY );	/* constant tracking OFF */
		break;
#endif
d1726 1
a1726 1
	if( glx_debug ) rt_log("viewchange( %d, x%x )\n", cmd, sp );
d1744 1
a1744 1
	glx_debug = lvl;
d1767 1
a1767 1
	if( glx_debug )  rt_log("colorchange\n");
d1785 2
a1786 2
	if( glx_has_rgb )  {
		if(cueing_on) {
d1801 1
a1801 1
	if(cueing_on && (glx_nslots < 7)) {
d1803 1
a1803 1
		cueing_on = 0;
d1807 1
a1807 1
	if(cueing_on) {
d1839 1
a1839 1
	if( glx_has_rgb )  return;
d1935 1
a1935 1
 *	This routine is not called at all if glx_has_rgb is set.
d1940 1
a1940 33
#if MIXED_MODE
#else
	if(cueing_on) {

		/*  Not much sense in making a ramp for DM_BLACK.  Besides
		 *  which, doing so, would overwrite the bottom color
		 *  map entries, which is a no-no.
		 */
		if( c != DM_BLACK) {
			register int i;
			fastf_t r_inc, g_inc, b_inc;
			fastf_t red, green, blue;

			r_inc = glx_rgbtab[c].r/16;
			g_inc = glx_rgbtab[c].g/16;
			b_inc = glx_rgbtab[c].b/16;

			red = glx_rgbtab[c].r;
			green = glx_rgbtab[c].g;
			blue = glx_rgbtab[c].b;

			for(i = 15; i >= 0;
			    i--, red -= r_inc, green -= g_inc, blue -= b_inc)
				mapcolor( MAP_ENTRY(c) + i,
				    (short)red,
				    (short)green,
				    (short)blue );
		}
	} else {
		mapcolor(c+CMAP_BASE,
		    glx_rgbtab[c].r, glx_rgbtab[c].g, glx_rgbtab[c].b);
	}
#endif
d1952 4
a1955 4
	lights = (cueing_on)
	    | (zclipping_on << 1)
	    | (perspective_mode << 2)
	    | (zbuffer_on << 3);
d1967 1
a1967 1
		perspective_mode ?
d1982 2
a1983 2
  if(dummy_perspective > 0)
    perspective_angle = dummy_perspective <= 4 ? dummy_perspective - 1: 3;
d1987 1
a1987 1
  if(perspective_mode)
d1996 1
a1996 1
  dummy_perspective = 1;
d2004 1
a2004 1
	if( glx_has_zbuf == 0 )  {
d2006 1
a2006 1
		zbuffer_on = 0;
d2008 2
a2009 2
	zbuffer( zbuffer_on );
	if( zbuffer_on)  {
d2011 1
a2011 1
		lsetdepth(min_scr_z, max_scr_z);
d2021 1
a2021 1
	if( zbuffer_on )  {
d2023 2
a2024 2
		if( glx_has_rgb )  {
			czclear( 0x000000, max_scr_z );
d2026 1
a2026 1
			czclear( BLACK, max_scr_z );
d2029 1
a2029 1
		if( glx_has_rgb )  {
d2058 1
a2058 1
	if( !lighting_on )  {
d2066 1
a2066 1
		if( cueing_on )  {
d2068 1
a2068 1
			cueing_on = 0;
d2513 3
d2517 1
d2520 1
a2520 1
	    rt_vls_name_print( &vls, Glx_vparse, argv[1], (char *)0 );
d2526 1
a2526 1
	    rt_structparse( &vls, Glx_vparse, (char *)0 );
d2561 1
d2563 3
d2575 1
d2590 1
a2590 4
      rt_vls_init(&str);
      rt_vls_printf(&str, "%s winset\n", rt_vls_addr(&pathName));
      cmdline(&str, FALSE);
      rt_vls_free(&str);
@


1.1
log
@Initial revision
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-4d.c,v 11.19 1995/12/11 22:46:59 bparker Exp $ (BRL)";
a66 1
#if MIXED_MODE
a73 9
extern Tcl_Interp *interp;
extern Tk_Window tkwin;
static Tk_Window xtkwin;
static Display  *dpy;
static Window   win;
static int devmotionnotify = LASTEvent;
static int devbuttonpress = LASTEvent;
static int devbuttonrelease = LASTEvent;
#endif
d98 3
d102 2
a141 3
#if 0
static int      focus = 0;              /* send key events to the command window */
#endif
a155 1
#if MIXED_MODE
d163 51
a217 1
static int perspective_angle =3;	/* Angle of perspective */
a224 1
static int	stereo_is_on = 0;
a337 1
static char ref[] = "mged";
a339 2
static long win_l, win_b, win_r, win_t;
static long winx_size, winy_size;
d522 1
d549 2
d558 21
a578 15
	register int	i;
	Matrix		m;
	inventory_t	*inv;
	int		win_size=1000;
	int		win_o_x=272;
	int		win_o_y=12;
	struct rt_vls str;
	int j, k;
	int ndevices;
	int nclass = 0;
	XDeviceInfoPtr olist, list;
	XDevice *dev;
	XEventClass e_class[15];
	XInputClassInfo *cip;
	XAnyClassPtr any;
d580 4
d586 6
a591 3
	if(cmdline(&str, FALSE) == CMD_BAD){
	  rt_vls_free(&str);
	  return -1;
d600 1
d604 9
d619 4
a622 2
	rt_vls_printf(&str, ".%s %s %d %d true true\n", ref, ref,
		      winx_size, winy_size);
d624 1
d636 2
d910 5
d928 13
d1462 1
a1462 1
#if MIXED_MODE
a1475 2
  static int knobs[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  static int knobs_offset[8] = {0, 0, 0, 0, 0, 0, 0, 0};
d1477 3
d1486 3
a1488 2
  if (eventPtr->xany.window != win)
    return TCL_OK;
d1490 2
a1491 8
#if 0
if(eventPtr->type == Expose)
  rt_log("Glx_checkevents:%d\t%d\tevent type - %d\tcount - %d\n",
	 win, eventPtr->xany.window, eventPtr->type, eventPtr->xexpose.count);
else if( eventPtr->type == ConfigureNotify )
  rt_log("Glx_checkevents:%d\t%d\tevent type - %d\n",
	 win, eventPtr->xany.window, eventPtr->type, eventPtr->xexpose.count);
#endif
d1501 4
d1524 157
a1680 1
	return TCL_OK;
d1703 1
a1703 1
      return TCL_OK;
d1771 1
a1771 1
      return TCL_OK;
a1776 2
      int i;

d1778 1
a1778 10
      for(i = 0; i < 8; ++i){
#if 0 /* Not surprising that this really doesn't work. */
	/* Not supposed to use this in mixed mode; trying it anyway:-). */
	setvaluator(DIAL0+i, 0, -2048-NOISE, 2047+NOISE);

	knobs[i] = 0;
#else
	knobs_offset[i] = knobs[i];
#endif
      }
d1797 2
a1801 193
#else
/*
 *  C H E C K E V E N T S
 *
 *  Look at events to check for button, dial, and mouse movement.
 */
void
Glx_checkevents()  {
#define NVAL 48
	short values[NVAL];
	register short *valp;
	register int ret;
	register int n;
	static	button0  = 0;	/*  State of button 0 */
	static	knobs[8];	/*  Save values of dials  */
	static char	pending_button = 'M';
	static int	pending_val = 0;
	static	pending_x = 0;
	static	pending_y = 0;

	/*
	if (qtest() == 0)
	    return;
 */
	n = blkqread( values, NVAL );	/* n is # of shorts returned */
	if( glx_debug ) rt_log("blkqread gave %d\n", n);
	for( valp = values; n > 0; n -= 2, valp += 2 )  {

		ret = *valp;
		if( glx_debug ) rt_log("qread ret=%d, val=%d\n", ret, valp[1]);
#if IR_BUTTONS
		if((ret >= SWBASE && ret < SWBASE+IR_BUTTONS)
		    || (ret >= F1KEY && ret <= F12KEY)
		    ) {
			register int	i;

			/*
			 *  Switch 0 is help key.
			 *  Holding down key 0 and pushing another
			 *  button or turning the knob will display
			 *  what it is in the button box displya.
			 */
			if(ret == SW_HELP_KEY)  {
				button0 = valp[1];
#if IR_KNOBS
				/*
				 *  Save and restore dial settings
				 *  so that when the user twists them
				 *  while holding down button 0 he
				 *  really isn't changing them.
				 */
				for(i = 0; i < 8; i++)
					if(button0)
						knobs[i] =
						    getvaluator(DIAL0+i);
					else setvaluator(DIAL0+i,knobs[i],
					    -2048-NOISE, 2047+NOISE);
#endif
				if(button0)
					glx_dbtext("Help Key");
# if 0
else
	glx_dbtext(glx_title);
# endif
continue;

			}

#if IR_KNOBS
			/*
			 *  If button 1 is pressed, reset run away knobs.
			 */
			if(ret == SW_ZERO_KEY || ret == F12KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					glx_dbtext("ZeroKnob");
					continue;
				}
#if IR_KNOBS
				/* zap the knobs */
				for(i = 0; i < 8; i++)  {
					setvaluator(DIAL0+i, 0,
					    -2048-NOISE, 2047+NOISE);
					knobs[i] = 0;
				}
#endif
				rt_vls_printf(&dm_values.dv_string,
				    "knob zero\n");
				continue;
			}
#endif
			/*
			 *  If PFkey 1 is pressed, toggle depthcueing.
			 */
			if(ret == F1KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					glx_dbtext("Depthcue");
					continue;
				}
				/* toggle depthcueing and remake colormap */
				rt_vls_printf(&dm_values.dv_string,
				    "dm set depthcue !\n");
				continue;
			} else if(ret == F2KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					glx_dbtext("Z clip");
					continue;
				}
				/* toggle zclipping */
				rt_vls_printf(&dm_values.dv_string,
				    "dm set zclip !\n");
				continue;
			} else if(ret == F3KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					glx_dbtext("Perspect");
					continue;
				}
				perspective_mode = 1-perspective_mode;
				rt_vls_printf( &dm_values.dv_string,
				    "set perspective %d\n",
				    perspective_mode ?
				    perspective_table[perspective_angle] :
				    -1 );
				dmaflag = 1;
				continue;
			} else if(ret == F4KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					glx_dbtext("Zbuffing");
					continue;
				}
				/* toggle zbuffer status */
				rt_vls_printf(&dm_values.dv_string,
				    "dm set zbuffer !\n");
				continue;
			} else if(ret == F5KEY)  {
				if(!valp[1]) continue; /* Ignore release */
				/*  Help mode */
				if(button0)  {
					glx_dbtext("Lighting");
					continue;
				}
				/* toggle status */
				rt_vls_printf(&dm_values.dv_string,
				    "dm set lighting !\n");
				continue;
			} else if (ret == F6KEY) {
				if (!valp[1]) continue; /* Ignore release */
				/* Help mode */
				if (button0) {
					glx_dbtext("P-Angle");
					continue;
				}
				/* toggle perspective matrix */
				if (--perspective_angle < 0) perspective_angle = 3;
				if(perspective_mode) rt_vls_printf( &dm_values.dv_string,
				    "set perspective %d\n",
				    perspective_table[perspective_angle] );
				dmaflag = 1;
				continue;
			} else if (ret == F7KEY) {
				if (!valp[1]) continue; /* Ignore release */
				/* Help mode */
				if (button0) {
					glx_dbtext("NoFace");
					continue;
				}
				/* Toggle faceplate on/off */
				no_faceplate = !no_faceplate;
				rt_vls_strcat( &dm_values.dv_string,
				    no_faceplate ?
				    "set faceplate 0\n" :
				    "set faceplate 1\n" );
				Glx_configure_window_shape();
				dmaflag = 1;
				continue;
			}
			/*
			 * If button being depressed (as opposed to
			 * being released) either display the cute
			 * message or process the button depending
			 * on whether button0 is also being held down.
			 */
			i = bmap[ret - SWBASE];

a1803 164
			if(!valp[1]) continue;
			if(button0) {
				glx_dbtext(label_button(i));
			} else {
				/* An actual button press */
#				if 0
				/* old way -- an illegal upcall */
				button(i);
#				else
				/* better way -- queue a string command */
				rt_vls_strcat( &dm_values.dv_string,
				    "press " );
				rt_vls_strcat( &dm_values.dv_string,
				    label_button(i) );
				rt_vls_strcat( &dm_values.dv_string,
				    "\n" );
#				endif
			}
			continue;
		}
#endif
#if IR_KNOBS
		/*  KNOBS, uh...er...DIALS  */
		/*	6	7
		 *	4	5
		 *	2	3
		 *	0	1
		 */
		if(ret >= DIAL0 && ret <= DIAL8)  {
			int	setting;
			/*  Help MODE */
			if(button0)  {
				glx_dbtext(
				    (adcflag ? kn1_knobs:kn2_knobs)[ret-DIAL0]);
				continue;
			}
			/* Make a dead zone around 0 */
			setting = irlimit(valp[1]);
			switch(ret)  {
			case DIAL0:
				if(adcflag) {
					rt_vls_printf( &dm_values.dv_string, "knob ang1 %d\n",
							setting );
				}
				break;
			case DIAL1:
				rt_vls_printf( &dm_values.dv_string , "knob S %f\n",
							setting/2048.0 );
				break;
			case DIAL2:
				if(adcflag)
					rt_vls_printf( &dm_values.dv_string , "knob ang2 %d\n",
							setting );
				else
					rt_vls_printf( &dm_values.dv_string , "knob z %f\n",
							setting/2048.0 );
				break;
			case DIAL3:
				if(adcflag)
					rt_vls_printf( &dm_values.dv_string , "knob distadc %d\n",
							setting );
				else
					rt_vls_printf( &dm_values.dv_string , "knob Z %f\n",
							setting/2048.0 );
				break;
			case DIAL4:
				if(adcflag)
					rt_vls_printf( &dm_values.dv_string , "knob yadc %d\n",
							setting );
				else
					rt_vls_printf( &dm_values.dv_string , "knob y %f\n",
							setting/2048.0 );
				break;
			case DIAL5:
				rt_vls_printf( &dm_values.dv_string , "knob Y %f\n",
							setting/2048.0 );
				break;
			case DIAL6:
				if(adcflag)
					rt_vls_printf( &dm_values.dv_string , "knob xadc %d\n",
							setting );
				else
					rt_vls_printf( &dm_values.dv_string , "knob x %f\n",
							setting/2048.0 );
				break;
			case DIAL7:
				rt_vls_printf( &dm_values.dv_string , "knob X %f\n",
							setting/2048.0 );
				break;
			}
			continue;
		}
#endif
		switch( ret )  {
		case LEFTMOUSE:
			pending_button = 'L';
			pending_val = (int)valp[1] ? 1 : 0;
			break;
		case RIGHTMOUSE:
			pending_button = 'R';
			pending_val = (int)valp[1] ? 1 : 0;
			break;
		case MIDDLEMOUSE:
			/* Will be followed by MOUSEX and MOUSEY hits */
			pending_button = 'M';
			pending_val = (int)valp[1] ? 1 : 0;
			/* Don't signal DV_PICK until MOUSEY event */
			break;
		case MOUSEX:
			pending_x = irisX2ged( (int)valp[1] );
			if(glx_debug>1)printf("mousex %d\n", pending_x);
			break;
		case MOUSEY:
			pending_y = irisY2ged( (int)valp[1] );
			if(glx_debug>1)printf("mousey %d\n", pending_y);
			/*
			 *  Thanks to the tie() call, when a MIDDLEMOUSE
			 *  event is signalled, it will be (eventually)
			 *  followed by a MOUSEX and MOUSEY event.
			 *  The MOUSEY event may not be in the same
			 *  blkqread() buffer, owing to time delays in
			 *  the outputting of the tie()'ed events.
			 *  So, don't report the mouse event on MIDDLEMOUSE;
			 *  instead, the flag pending_val flag is set,
			 *  and the mouse event is signaled here, which
			 *  may need multiple trips through this subroutine.
			 *
			 *  MOUSEY may be queued all by itself to support
			 *  illuminate mode;  in those cases, pending_val
			 *  will be zero already, and we just parrot the last
			 *  X value.
			 */
			rt_vls_printf( &dm_values.dv_string, "%c %d %d %d\n",
			    pending_button,
			    pending_val,
			    pending_x, pending_y);
			pending_button = 'M';
			pending_val = 0;
			break;
		case REDRAW:
			/* Window may have moved */
			Glx_configure_window_shape();
			dmaflag = 1;
			if( glx_has_doublebuffer) /* to fix back buffer */
				refresh();
			dmaflag = 1;
			break;
		case INPUTCHANGE:
			/* Means we got or lost the keyboard.  Ignore */
			break;
		case WMREPLY:
			/* This guy speaks, but has nothing to say */
			break;
		case 0:
			/* These show up as a consequence of using qgetfd().  Most regrettable.  Ignore. */
			break;
		default:
			rt_log("IRIS device %d gave %d?\n", ret, valp[1]);
			break;
		}
	}
}
#endif

d2780 42
@
