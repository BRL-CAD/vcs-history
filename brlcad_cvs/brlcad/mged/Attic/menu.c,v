head	11.42;
access;
symbols
	ansi-20040405-merged:11.37.2.2
	postmerge-20040405-ansi:11.39
	premerge-20040404-ansi:11.38
	postmerge-autoconf:11.38
	autoconf-freeze:11.37.10.2
	premerge-autoconf:11.38
	postmerge-20040315-windows:11.38
	premerge-20040315-windows:11.38
	windows-20040315-freeze:11.37.4.1
	autoconf-20031203:11.37
	autoconf-20031202:11.37
	autoconf-branch:11.37.0.10
	phong-branch:11.37.0.8
	photonmap-branch:11.37.0.6
	rel-6-1-DP:11.37
	windows-branch:11.37.0.4
	rel-6-0-2:11.35
	ansi-branch:11.37.0.2
	rel-6-0-1-branch:11.35.0.2
	hartley-6-0-post:11.36
	hartley-6-0-pre:11.35
	rel-6-0-1:11.35
	rel-6-0:11.35
	rel-5-4:11.33
	offsite-5-3-pre:11.35
	rel-5-3:11.33
	rel-5-2:11.33
	rel-5-1-branch:11.33.0.2
	rel-5-1:11.33
	rel-5-0:11.32
	rel-5-0-beta:11.32
	rel-4-5:11.26
	ctj-4-5-post:11.19
	ctj-4-5-pre:11.19
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.5;
locks; strict;
comment	@ * @;


11.42
date	2004.05.21.17.47.45;	author morrison;	state dead;
branches;
next	11.41;

11.41
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.40;

11.40
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2004.02.02.17.39.33;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2002.08.20.17.08.24;	author jra;	state Exp;
branches
	11.37.2.1
	11.37.4.1
	11.37.10.1;
next	11.36;

11.36
date	2002.08.15.20.55.36;	author hartley;	state Exp;
branches;
next	11.35;

11.35
date	2000.09.07.02.58.52;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.08.19.03.10.47;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	99.12.30.19.39.01;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	99.02.17.19.40.26;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	99.01.21.18.31.20;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	98.11.06.22.32.41;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	98.10.21.17.02.16;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	98.08.13.12.27.38;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	98.06.12.19.46.21;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	98.02.09.15.45.46;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	98.02.06.22.12.33;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	97.11.03.15.21.44;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	97.09.11.13.34.42;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	97.09.08.18.47.32;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	97.07.25.20.52.11;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	97.06.25.13.46.16;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	97.04.29.12.36.18;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	97.04.23.18.30.43;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.02.28.21.37.27;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	97.02.04.22.16.23;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.01.30.22.34.43;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.01.02.21.55.00;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.12.30.22.39.13;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.09.23.18.24.33;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.09.17.21.18.34;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.04.18.20.25.25;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.03.22.18.36.05;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.03.20.22.16.25;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.01.17.22.01.58;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.08.03.21.46.18;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.18;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.12.23.14.21.00;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.11.10.16.32.08;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.01.30.11;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.15.23.10;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.48;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.03.25;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.21.04.55.22;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.39.28;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.04;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.17.02.35.20;	author reschly;	state Exp;
branches;
next	7.3;

7.3
date	88.07.22.02.03.00;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.28;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.01.23;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.38;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.21.30;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.08.13;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.22.21;	author mike;	state Rel1;
branches;
next	2.8;

2.8
date	86.09.23.17.41.45;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.09.10.01.35.50;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.08.12.06.50.12;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.08.07.05.19.22;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.29.23.17.30;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.05.10.00.54.43;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.05.03.01.58.28;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.56.34;	author mike;	state Prod;
branches;
next	1.2;

1.2
date	84.11.20.04.24.58;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.51.52;	author mike;	state Exp;
branches;
next	;

11.37.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	11.37.2.2;

11.37.2.2
date	2004.03.17.21.22.00;	author morrison;	state Exp;
branches;
next	;

11.37.4.1
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

11.37.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.37.10.2;

11.37.10.2
date	2004.03.15.14.07.39;	author erikg;	state Exp;
branches;
next	;


desc
@The Menu manager
@


11.42
log
@moved to src/mged/
@
text
@/*
 *			M E N U . C
 *
 * Functions -
 *	mmenu_init		Clear global menu data
 *	mmenu_display		Add a list of items to the display list
 *	mmenu_select		Called by usepen() for menu pointing
 *	mmenu_pntr		Reset the pointer to a menu item
 *
 * Authors -
 *	Bob Suckling
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/menu.c,v 11.41 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include "tcl.h"

#include <stdio.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./titles.h"
#include "./mged_dm.h"

#include "./mgedtcl.h"

extern struct menu_item second_menu[], sed_menu[];

void set_menucurrent();
int set_arrowloc();

int
cmd_mmenu_get(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    int index;
    
    if (argc > 2) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel mmenu_get");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if (argc == 2) {
	register struct menu_item **m, *mptr;

	if (Tcl_GetInt(interp, argv[1], &index) != TCL_OK)
	    return TCL_ERROR;

	if (index < 0 || NMENU <= index) {
	    Tcl_AppendResult(interp, "index out of range", (char *)NULL);
	    return TCL_ERROR;
	}

	m = menu_state->ms_menus+index;
	if (*m == MENU_NULL)
	    return TCL_OK;

	for (mptr = *m; mptr->menu_string[0] != '\0'; mptr++)
	    Tcl_AppendElement(interp, mptr->menu_string);
    } else {
	register struct menu_item **m;
	struct bu_vls result;
	int status;

	bu_vls_init(&result);
	bu_vls_strcat(&result, "list");
	for (m = menu_state->ms_menus; m - menu_state->ms_menus < NMENU; m++)
	    bu_vls_printf(&result, " [%s %d]", argv[0], m-menu_state->ms_menus);

	status = Tcl_Eval(interp, bu_vls_addr(&result));
	bu_vls_free(&result);

	return status;
    }

    return TCL_OK;
}


/*
 *			M M E N U _ I N I T
 *
 * Clear global data
 */
void
mmenu_init(void)
{
	menu_state->ms_flag = 0;
	menu_state->ms_menus[MENU_L1] = MENU_NULL;
	menu_state->ms_menus[MENU_L2] = MENU_NULL;
	menu_state->ms_menus[MENU_GEN] = MENU_NULL;
#if 0
	(void)Tcl_CreateCommand(interp, "mmenu_set", cmd_nop, (ClientData)NULL,
				(Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "mmenu_get", cmd_mmenu_get,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
#endif
}


/*
 *			M M E N U _ S E T
 */

void
mmenu_set(int index, struct menu_item *value)
{
    struct dm_list *dlp;

    Tcl_DString ds_menu;
    struct bu_vls menu_string;

    menu_state->ms_menus[index] = value;  /* Change the menu internally */

    bu_vls_init(&menu_string);
    Tcl_DStringInit(&ds_menu);

    bu_vls_printf(&menu_string, "mmenu_set %S %d ", &curr_cmd_list->cl_name, index);

    (void)Tcl_Eval(interp, bu_vls_addr(&menu_string));

    Tcl_DStringFree(&ds_menu);
    bu_vls_free(&menu_string);

    FOR_ALL_DISPLAYS(dlp, &head_dm_list.l){
      if(menu_state == dlp->dml_menu_state &&
	 dlp->dml_mged_variables->mv_faceplate &&
	 dlp->dml_mged_variables->mv_orig_gui)
	dlp->dml_dirty = 1;
    }
}

void
mmenu_set_all(int index, struct menu_item *value)
{
  struct dm_list *p;
  struct cmd_list *save_cmd_list;
  struct dm_list *save_dm_list;

  save_cmd_list = curr_cmd_list;
  save_dm_list = curr_dm_list;
  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
    if(p->dml_tie)
      curr_cmd_list = p->dml_tie;

    curr_dm_list = p;
    mmenu_set( index, value );
  }

  curr_cmd_list = save_cmd_list;
  curr_dm_list = save_dm_list;
}

void
mged_highlight_menu_item(struct menu_item *mptr, int y)
{
  switch(mptr->menu_arg){
  case BV_RATE_TOGGLE:
    if(mged_variables->mv_rateknobs){
      DM_SET_FGCOLOR(dmp,
		     color_scheme->cs_menu_text1[0],
		     color_scheme->cs_menu_text1[1],
		     color_scheme->cs_menu_text1[2], 1, 1.0);
      DM_DRAW_STRING_2D(dmp, "Rate",
			GED2PM1(MENUX), GED2PM1(y-15), 0, 0);
      DM_SET_FGCOLOR(dmp,
		     color_scheme->cs_menu_text2[0],
		     color_scheme->cs_menu_text2[1],
		     color_scheme->cs_menu_text2[2], 1, 1.0);
      DM_DRAW_STRING_2D(dmp, "/Abs",
			GED2PM1(MENUX+4*40), GED2PM1(y-15), 0, 0);
    }else{
      DM_SET_FGCOLOR(dmp,
		     color_scheme->cs_menu_text2[0],
		     color_scheme->cs_menu_text2[1],
		     color_scheme->cs_menu_text2[2], 1, 1.0);
      DM_DRAW_STRING_2D(dmp, "Rate/",
			GED2PM1(MENUX), GED2PM1(y-15), 0, 0);
      DM_SET_FGCOLOR(dmp,
		     color_scheme->cs_menu_text1[0],
		     color_scheme->cs_menu_text1[1],
		     color_scheme->cs_menu_text1[2], 1, 1.0);
      DM_DRAW_STRING_2D(dmp, "Abs",
			GED2PM1(MENUX+5*40), GED2PM1(y-15), 0, 0);
    }
    break;
  default:
    break;
  }
}

/*
 *			M M E N U _ D I S P L A Y
 *
 *  Draw one or more menus onto the display.
 *  If "menu_state->ms_flag" is non-zero, then the last selected
 *  menu item will be indicated with an arrow.
 */
void
mmenu_display(int y_top)
{ 
  static int menu, item;
  register struct menu_item	**m;
  register struct menu_item	*mptr;
  register int y = y_top;

  menu_state->ms_top = y - MENU_DY / 2;
  DM_SET_FGCOLOR(dmp,
		 color_scheme->cs_menu_line[0],
		 color_scheme->cs_menu_line[1],
		 color_scheme->cs_menu_line[2], 1, 1.0);
#if 1
  DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 0);
#else
  DM_SET_LINE_ATTR(dmp, 1, 0);
#endif
  DM_DRAW_LINE_2D(dmp,
		  GED2PM1(MENUXLIM), GED2PM1(menu_state->ms_top),
		  GED2PM1(XMIN), GED2PM1(menu_state->ms_top));

  for( menu=0, m = menu_state->ms_menus; m - menu_state->ms_menus < NMENU; m++,menu++ )  {
    if( *m == MENU_NULL )  continue;
    for( item=0, mptr = *m;
	 mptr->menu_string[0] != '\0' && y > TITLE_YBASE;
	 mptr++, y += MENU_DY, item++ )  {
#if 0
      if((*m == (struct menu_item *)second_menu && (mptr->menu_arg == BV_RATE_TOGGLE ||
				  mptr->menu_arg == BV_EDIT_TOGGLE))
	  || (*m == (struct menu_item *)sed_menu && mptr->menu_arg == BE_S_CONTEXT))
#else
      if((*m == (struct menu_item *)second_menu &&
	  (mptr->menu_arg == BV_RATE_TOGGLE ||
	   mptr->menu_arg == BV_EDIT_TOGGLE ||
	   mptr->menu_arg == BV_EYEROT_TOGGLE)))
#endif
	mged_highlight_menu_item(mptr, y);
      else{
	if(mptr == *m)
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_menu_title[0],
			 color_scheme->cs_menu_title[1],
			 color_scheme->cs_menu_title[2], 1, 1.0);
	else
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_menu_text2[0],
			 color_scheme->cs_menu_text2[1],
			 color_scheme->cs_menu_text2[2], 1, 1.0);
	DM_DRAW_STRING_2D(dmp, mptr->menu_string,
			  GED2PM1(MENUX), GED2PM1(y-15), 0, 0);
      }
      DM_SET_FGCOLOR(dmp,
		     color_scheme->cs_menu_line[0],
		     color_scheme->cs_menu_line[1],
		     color_scheme->cs_menu_line[2], 1, 1.0);
      DM_DRAW_LINE_2D(dmp,
		      GED2PM1(MENUXLIM), GED2PM1(y+(MENU_DY/2)),
		      GED2PM1(XMIN), GED2PM1(y+(MENU_DY/2)));
      if( menu_state->ms_cur_item == item && menu_state->ms_cur_menu == menu && menu_state->ms_flag )  {
	/* prefix item selected with "==>" */
	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_menu_arrow[0],
		       color_scheme->cs_menu_arrow[1],
		       color_scheme->cs_menu_arrow[2], 1, 1.0);
	DM_DRAW_STRING_2D(dmp, "==>",
			  GED2PM1(XMIN), GED2PM1(y-15), 0, 0);
      }
    }
  }

  if( y == y_top )
    return;	/* no active menus */

  DM_SET_FGCOLOR(dmp,
		 color_scheme->cs_menu_line[0],
		 color_scheme->cs_menu_line[1],
		 color_scheme->cs_menu_line[2], 1, 1.0);
#if 1
  DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 0);
#else
  DM_SET_LINE_ATTR(dmp, 1, 0);
#endif
  DM_DRAW_LINE_2D( dmp,
		   GED2PM1(MENUXLIM), GED2PM1(menu_state->ms_top-1),
		   GED2PM1(MENUXLIM), GED2PM1(y-(MENU_DY/2)) );
}

/*
 *			M M E N U _ S E L E C T
 *
 *  Called with Y coordinate of pen in menu area.
 *
 * Returns:	1 if menu claims these pen co-ordinates,
 *		0 if pen is BELOW menu
 *		-1 if pen is ABOVE menu	(error)
 */
int
mmenu_select( int pen_y, int do_func )
{ 
	static int menu, item;
	struct menu_item	**m;
	register struct menu_item	*mptr;
	register int			yy;

	if( pen_y > menu_state->ms_top )
		return(-1);	/* pen above menu area */

	/*
	 * Start at the top of the list and see if the pen is
	 * above here.
	 */
	yy = menu_state->ms_top;

	for( menu=0, m=menu_state->ms_menus; m - menu_state->ms_menus < NMENU; m++,menu++ )  {
		if( *m == MENU_NULL )  continue;
		for( item=0, mptr = *m;
		     mptr->menu_string[0] != '\0';
		     mptr++, item++ )  {
			yy += MENU_DY;
			if( pen_y <= yy )
				continue;	/* pen is below this item */
			menu_state->ms_cur_item = item;
			menu_state->ms_cur_menu = menu;
			menu_state->ms_flag = 1;
		     	/* It's up to the menu_func to set menu_state->ms_flag=0
		     	 * if no arrow is desired */
			if( do_func && mptr->menu_func != ((void (*)())0) )
				(*(mptr->menu_func))(mptr->menu_arg, menu, item);

			return( 1 );		/* menu claims pen value */
		}
	}
	return( 0 );		/* pen below menu area */
}

/*
 *			M M E N U _ P N T R
 *
 *  Routine to allow user to reset the arrow to any menu & item desired.
 *  Example:  menu_pntr( MENU_L1, 3 ).
 *  The arrow can always be eliminated by setting menu_state->ms_flag=0, view_state->flag=1.
 */
void
mmenu_pntr(int menu, int item)
{
	menu_state->ms_cur_menu = menu;
	menu_state->ms_cur_item = item;
	if( menu_state->ms_cur_menu >= 0 )
		menu_state->ms_flag = 1;
}
@


11.41
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/menu.c,v 11.40 2004/05/10 15:25:28 morrison Exp $ (BRL)";
@


11.40
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.39 2004/04/05 09:09:12 morrison Exp $ (BRL)";
d27 5
a31 1
#include "conf.h"
@


11.39
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d183 1
a183 1
		     color_scheme->cs_menu_text1[2], 1);
d189 1
a189 1
		     color_scheme->cs_menu_text2[2], 1);
d196 1
a196 1
		     color_scheme->cs_menu_text2[2], 1);
d202 1
a202 1
		     color_scheme->cs_menu_text1[2], 1);
d231 1
a231 1
		 color_scheme->cs_menu_line[2], 1);
d262 1
a262 1
			 color_scheme->cs_menu_title[2], 1);
d267 1
a267 1
			 color_scheme->cs_menu_text2[2], 1);
d274 1
a274 1
		     color_scheme->cs_menu_line[2], 1);
d283 1
a283 1
		       color_scheme->cs_menu_arrow[2], 1);
d296 1
a296 1
		 color_scheme->cs_menu_line[2], 1);
@


11.38
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.37 2002/08/20 17:08:24 jra Exp $ (BRL)";
d49 1
a49 5
cmd_mmenu_get(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d106 1
a106 1
mmenu_init()
d126 1
a126 3
mmenu_set( index, value )
int index;
struct menu_item *value;
d154 1
a154 3
mmenu_set_all( index, value )
int index;
struct menu_item *value;
d175 1
a175 3
mged_highlight_menu_item(mptr, y)
struct menu_item *mptr;
int y;
d220 1
a220 2
mmenu_display( y_top )
int y_top;
d363 1
a363 1
mmenu_pntr( menu, item )
@


11.37
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.35 2000/09/07 02:58:52 mike Exp $ (BRL)";
@


11.37.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/menu.c,v 11.38 2004/02/02 17:39:33 morrison Exp $ (BRL)";
@


11.37.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.38 2004/02/02 17:39:33 morrison Exp $ (BRL)";
@


11.37.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.37.10.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.37.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.37 2002/08/20 17:08:24 jra Exp $ (BRL)";
d49 5
a53 1
cmd_mmenu_get(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d110 1
a110 1
mmenu_init(void)
d130 3
a132 1
mmenu_set(int index, struct menu_item *value)
d160 3
a162 1
mmenu_set_all(int index, struct menu_item *value)
d183 3
a185 1
mged_highlight_menu_item(struct menu_item *mptr, int y)
d230 2
a231 1
mmenu_display(int y_top)
d374 1
a374 1
mmenu_pntr(int menu, int item)
@


11.37.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.36
log
@Converted from K&R to ANSI C - RFH
@
text
@d49 5
a53 1
cmd_mmenu_get(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d110 1
a110 1
mmenu_init(void)
d130 3
a132 1
mmenu_set(int index, struct menu_item *value)
d160 3
a162 1
mmenu_set_all(int index, struct menu_item *value)
d183 3
a185 1
mged_highlight_menu_item(struct menu_item *mptr, int y)
d230 2
a231 1
mmenu_display(int y_top)
d374 1
a374 1
mmenu_pntr(int menu, int item)
@


11.35
log
@
Added externs to ged.h to quiet down lint
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.34 2000/08/19 03:10:47 mike Exp $ (BRL)";
d49 1
a49 5
cmd_mmenu_get(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d106 1
a106 1
mmenu_init()
d126 1
a126 3
mmenu_set( index, value )
int index;
struct menu_item *value;
d154 1
a154 3
mmenu_set_all( index, value )
int index;
struct menu_item *value;
d175 1
a175 3
mged_highlight_menu_item(mptr, y)
struct menu_item *mptr;
int y;
d220 1
a220 2
mmenu_display( y_top )
int y_top;
d363 1
a363 1
mmenu_pntr( menu, item )
@


11.34
log
@
const RCSid
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.33 1999/12/30 19:39:01 jra Exp $ (BRL)";
d328 1
a328 3
mmenu_select( pen_y, do_func )
register int pen_y;
int do_func;
@


11.33
log
@Eliominated an unused variable
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.32 1999/02/17 19:40:26 bparker Exp $ (BRL)";
@


11.32
log
@*- mods to mmenu_set()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.31 1999/01/21 18:31:20 bparker Exp $ (BRL)";
a186 2
  char *cp;

@


11.31
log
@*- use helpdevel for help on developer commands
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.30 1998/11/06 22:32:41 bparker Exp $ (BRL)";
d144 1
a144 2
    bu_vls_printf(&menu_string, "mmenu_set .mmenu%S %S %d ",
		  &curr_cmd_list->cl_name, &curr_cmd_list->cl_name, index);
a145 7
    Tcl_DStringStartSublist(&ds_menu);
    if (value != MENU_NULL)
	for (; value->menu_string[0] != '\0'; value++)
	    (void)Tcl_DStringAppendElement(&ds_menu, value->menu_string);
    Tcl_DStringEndSublist(&ds_menu);

    bu_vls_strcat(&menu_string, Tcl_DStringValue(&ds_menu));
@


11.30
log
@*- use new structures
*- cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.29 1998/10/21 17:02:16 bparker Exp $ (BRL)";
d58 6
a63 2
	Tcl_AppendResult(interp, "wrong # args: must be \"mmenu_get ?index?\"",
			 (char *)NULL);
@


11.29
log
@*- use color scheme variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.28 1998/08/13 12:27:38 bparker Exp $ (BRL)";
a47 1

d74 1
a74 1
	m = menu_array+index;
d87 2
a88 2
	for (m = menu_array; m - menu_array < NMENU; m++)
	    bu_vls_printf(&result, " [%s %d]", argv[0], m-menu_array);
d108 4
a111 4
	menuflag = 0;
	menu_array[MENU_L1] = MENU_NULL;
	menu_array[MENU_L2] = MENU_NULL;
	menu_array[MENU_GEN] = MENU_NULL;
d135 1
a135 1
    menu_array[index] = value;  /* Change the menu internally */
d141 1
a141 1
		  &curr_cmd_list->name, &curr_cmd_list->name, index);
d156 4
a159 4
      if(curr_dm_list->menu_vars == dlp->menu_vars &&
	 dlp->_mged_variables->faceplate &&
	 dlp->_mged_variables->orig_gui)
	dlp->_dirty = 1;
d175 2
a176 2
    if(p->aim)
      curr_cmd_list = p->aim;
d195 1
a195 1
    if(mged_variables->rateknobs){
d197 3
a199 3
		     color_scheme->fp_menu_text1[0],
		     color_scheme->fp_menu_text1[1],
		     color_scheme->fp_menu_text1[2], 1);
d203 3
a205 3
		     color_scheme->fp_menu_text2[0],
		     color_scheme->fp_menu_text2[1],
		     color_scheme->fp_menu_text2[2], 1);
d210 3
a212 3
		     color_scheme->fp_menu_text2[0],
		     color_scheme->fp_menu_text2[1],
		     color_scheme->fp_menu_text2[2], 1);
d216 3
a218 3
		     color_scheme->fp_menu_text1[0],
		     color_scheme->fp_menu_text1[1],
		     color_scheme->fp_menu_text1[2], 1);
d232 1
a232 1
 *  If "menuflag" is non-zero, then the last selected
d244 1
a244 1
  menu_top = y - MENU_DY / 2;
d246 3
a248 3
		 color_scheme->fp_menu_line[0],
		 color_scheme->fp_menu_line[1],
		 color_scheme->fp_menu_line[2], 1);
d250 1
a250 1
  DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
d255 2
a256 2
		  GED2PM1(MENUXLIM), GED2PM1(menu_top),
		  GED2PM1(XMIN), GED2PM1(menu_top));
d258 1
a258 1
  for( menu=0, m = menu_array; m - menu_array < NMENU; m++,menu++ )  {
d277 3
a279 3
			 color_scheme->fp_menu_title[0],
			 color_scheme->fp_menu_title[1],
			 color_scheme->fp_menu_title[2], 1);
d282 3
a284 3
			 color_scheme->fp_menu_text2[0],
			 color_scheme->fp_menu_text2[1],
			 color_scheme->fp_menu_text2[2], 1);
d289 3
a291 3
		     color_scheme->fp_menu_line[0],
		     color_scheme->fp_menu_line[1],
		     color_scheme->fp_menu_line[2], 1);
d295 1
a295 1
      if( cur_item == item && cur_menu == menu && menuflag )  {
d298 3
a300 3
		       color_scheme->fp_menu_arrow[0],
		       color_scheme->fp_menu_arrow[1],
		       color_scheme->fp_menu_arrow[2], 1);
d311 3
a313 3
		 color_scheme->fp_menu_line[0],
		 color_scheme->fp_menu_line[1],
		 color_scheme->fp_menu_line[2], 1);
d315 1
a315 1
  DM_SET_LINE_ATTR(dmp, mged_variables->linewidth, 0);
d320 1
a320 1
		   GED2PM1(MENUXLIM), GED2PM1(menu_top-1),
d343 1
a343 1
	if( pen_y > menu_top )
d350 1
a350 1
	yy = menu_top;
d352 1
a352 1
	for( menu=0, m=menu_array; m - menu_array < NMENU; m++,menu++ )  {
d360 4
a363 4
			cur_item = item;
			cur_menu = menu;
			menuflag = 1;
		     	/* It's up to the menu_func to set menuflag=0
d379 1
a379 1
 *  The arrow can always be eliminated by setting menuflag=0, dmaflag=1.
d384 4
a387 107
	cur_menu = menu;
	cur_item = item;
	if( cur_menu >= 0 )
		menuflag = 1;
}

int
f_share_menu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct dm_list *dlp1, *dlp2, *dlp3;
  struct menu_vars *save_mvp;

  if(argc != 3){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help share_menu");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp1, &head_dm_list.l)
    if(!strcmp(argv[1], bu_vls_addr(&dlp1->_dmp->dm_pathName)))
      break;

  if(dlp1 == &head_dm_list){
     Tcl_AppendResult(interp, "f_share_menu: unrecognized pathName - ",
		      argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp2, &head_dm_list.l)
    if(!strcmp(argv[2], bu_vls_addr(&dlp2->_dmp->dm_pathName)))
      break;

  if(dlp2 == &head_dm_list){
     Tcl_AppendResult(interp, "f_share_menu: unrecognized pathName - ",
		      argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  if(dlp1 == dlp2)
    return TCL_OK;

  /* already sharing a menu */
  if(dlp1->menu_vars == dlp2->menu_vars)
    return TCL_OK;


  save_mvp = dlp2->menu_vars;
  dlp2->menu_vars = dlp1->menu_vars;

  /* check if save_mvp is being used elsewhere */
  FOR_ALL_DISPLAYS(dlp3, &head_dm_list.l)
    if(save_mvp == dlp3->menu_vars)
      break;

  /* save_mvp is not being used */
  if(dlp3 == &head_dm_list)
    bu_free((genptr_t)save_mvp, "f_share_menu: save_mvp");

  /* need to redraw this guy */
  dlp2->_dirty = 1;

  return TCL_OK;
}

int
f_unshare_menu(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
  struct dm_list *dlp1, *dlp2;

  if(argc != 2){
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp1, &head_dm_list.l)
    if(!strcmp(argv[1], bu_vls_addr(&dlp1->_dmp->dm_pathName)))
      break;

  if(dlp1 == &head_dm_list){
     Tcl_AppendResult(interp, "f_unshare_menu: unrecognized pathName - ",
		      argv[1], "\n", (char *)NULL);
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp2, &head_dm_list.l)
    if(dlp1 != dlp2 && dlp1->menu_vars == dlp2->menu_vars)
      break;

  /* not sharing a menu ---- nothing to do */
  if(dlp2 == &head_dm_list)
    return TCL_OK;

  BU_GETSTRUCT(dlp1->menu_vars, menu_vars);
  *dlp1->menu_vars = *dlp2->menu_vars;  /* struct copy */

  return TCL_OK;
@


11.28
log
@*- fixed some bad code
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/menu.c,v 11.27 1998/06/12 19:46:21 bparker Exp $ (BRL)";
d197 4
a200 1
      DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d203 4
a206 1
      DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d210 4
a213 1
      DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d216 4
a219 1
      DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d246 4
a249 1
  DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d277 4
a280 1
	  DM_SET_FGCOLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d282 4
a285 1
	  DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d289 4
a292 1
      DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d298 4
a301 1
	DM_SET_FGCOLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d311 4
a314 1
  DM_SET_FGCOLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
@


11.27
log
@*- change DM_SET_COLOR to DM_SET_FGCOLOR
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/menu.c,v 11.26 1998/02/09 15:45:46 bparker Exp $ (BRL)";
a44 9
#if 0
int	menuflag;	/* flag indicating if a menu item is selected */
struct menu_item *menu_array[NMENU];	/* base of array of menu items */

static int	menu_top;	/* screen loc of the first menu item */
int	cur_menu;	/* index of selected menu in list */
int	cur_item;	/* index of selected item in menu */
#endif

d70 1
a70 1
	if (index < 0 || index > NMENU) {
d244 1
a244 1
  for( menu=0, m = menu_array; m < &menu_array[NMENU]; m++,menu++ )  {
d323 1
a323 1
	for( menu=0, m=menu_array; m < &menu_array[NMENU]; m++,menu++ )  {
@


11.26
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.25 1998/02/06 22:12:33 bparker Exp bparker $ (BRL)";
d206 1
a206 1
      DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d209 1
a209 1
      DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d213 1
a213 1
      DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d216 1
a216 1
      DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d243 1
a243 1
  DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d271 1
a271 1
	  DM_SET_COLOR(dmp, DM_RED_R, DM_RED_G, DM_RED_B, 1);
d273 1
a273 1
	  DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d277 1
a277 1
      DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
d283 1
a283 1
	DM_SET_COLOR(dmp, DM_WHITE_R, DM_WHITE_G, DM_WHITE_B, 1);
d293 1
a293 1
  DM_SET_COLOR(dmp, DM_YELLOW_R, DM_YELLOW_G, DM_YELLOW_B, 1);
@


11.25
log
@DM_DRAW_STRING_2D and DM_DRAW_STRING_2D now expect x,y values in the range +-1
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.24 1997/11/03 15:21:44 bparker Exp bparker $ (BRL)";
d207 2
a208 2
      DM_DRAW_STRING_2D( dmp, "Rate",
			 GED2PM1(MENUX), GED2PM1(y-15), 0, 0 );
d210 2
a211 2
      DM_DRAW_STRING_2D( dmp, "/Abs",
			 GED2PM1(MENUX+4*40), GED2PM1(y-15), 0, 0 );
d214 2
a215 2
      DM_DRAW_STRING_2D( dmp, "Rate/",
			 GED2PM1(MENUX), GED2PM1(y-15), 0, 0 );
d217 2
a218 2
      DM_DRAW_STRING_2D( dmp, "Abs",
			 GED2PM1(MENUX+5*40), GED2PM1(y-15), 0, 0 );
d274 2
a275 2
	DM_DRAW_STRING_2D( dmp, mptr->menu_string,
			   GED2PM1(MENUX), GED2PM1(y-15), 0, 0 );
@


11.24
log
@use LIBDM macros
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.23 1997/09/11 13:34:42 bparker Exp bparker $ (BRL)";
d207 2
a208 1
      DM_DRAW_STRING_2D( dmp, "Rate", MENUX, y-15, 0, 0 );
d210 2
a211 1
      DM_DRAW_STRING_2D( dmp, "/Abs", MENUX+4*40, y-15, 0, 0 );
d214 2
a215 1
      DM_DRAW_STRING_2D( dmp, "Rate/", MENUX, y-15, 0, 0 );
d217 2
a218 1
      DM_DRAW_STRING_2D( dmp, "Abs", MENUX+5*40, y-15, 0, 0 );
d249 3
a251 1
  DM_DRAW_LINE_2D(dmp, MENUXLIM, menu_top, XMIN, menu_top);
d274 2
a275 1
	DM_DRAW_STRING_2D( dmp, mptr->menu_string, MENUX, y-15, 0, 0 );
d278 3
a280 2
      DM_DRAW_LINE_2D(dmp, MENUXLIM, y+(MENU_DY/2), XMIN,
			 y+(MENU_DY/2));
d284 2
a285 1
	DM_DRAW_STRING_2D(dmp, "==>", XMIN, y-15, 0, 0);
d299 3
a301 1
  DM_DRAW_LINE_2D( dmp, MENUXLIM, menu_top-1, MENUXLIM, y-(MENU_DY/2) );
@


11.23
log
@add help message to f_share_menu()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.22 1997/09/08 18:47:32 bparker Exp bparker $ (BRL)";
d206 4
a209 4
      dmp->dm_setColor(dmp, DM_WHITE, 1);
      dmp->dm_drawString2D( dmp, "Rate", MENUX, y-15, 0, 0 );
      dmp->dm_setColor(dmp, DM_YELLOW, 1);
      dmp->dm_drawString2D( dmp, "/Abs", MENUX+4*40, y-15, 0, 0 );
d211 4
a214 4
      dmp->dm_setColor(dmp, DM_YELLOW, 1);
      dmp->dm_drawString2D( dmp, "Rate/", MENUX, y-15, 0, 0 );
      dmp->dm_setColor(dmp, DM_WHITE, 1);
      dmp->dm_drawString2D( dmp, "Abs", MENUX+5*40, y-15, 0, 0 );
d239 1
a239 1
  dmp->dm_setColor(dmp, DM_YELLOW, 1);
d241 1
a241 1
  dmp->dm_setLineAttr(dmp, mged_variables->linewidth, 0);
d243 1
a243 1
  dmp->dm_setLineAttr(dmp, 1, 0);
d245 1
a245 1
  dmp->dm_drawLine2D(dmp, MENUXLIM, menu_top, XMIN, menu_top);
d265 1
a265 1
	  dmp->dm_setColor(dmp, DM_RED, 1);
d267 2
a268 2
	  dmp->dm_setColor(dmp, DM_YELLOW, 1);
	dmp->dm_drawString2D( dmp, mptr->menu_string, MENUX, y-15, 0, 0 );
d270 2
a271 2
      dmp->dm_setColor(dmp, DM_YELLOW, 1);
      dmp->dm_drawLine2D(dmp, MENUXLIM, y+(MENU_DY/2), XMIN,
d275 2
a276 2
	dmp->dm_setColor(dmp, DM_WHITE, 1);
	dmp->dm_drawString2D(dmp, "==>", XMIN, y-15, 0, 0);
d284 1
a284 1
  dmp->dm_setColor(dmp, DM_YELLOW, 1);
d286 1
a286 1
  dmp->dm_setLineAttr(dmp, mged_variables->linewidth, 0);
d288 1
a288 1
  dmp->dm_setLineAttr(dmp, 1, 0);
d290 1
a290 1
  dmp->dm_drawLine2D( dmp, MENUXLIM, menu_top-1, MENUXLIM, y-(MENU_DY/2) );
@


11.22
log
@*- new macro FOR_ALL_DISPLAYS
*- mged_variables is now a pointer
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.21 1997/07/25 20:52:11 bparker Exp bparker $ (BRL)";
d370 6
@


11.21
log
@mods to use user specified linewidth
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.20 1997/06/25 13:46:16 bparker Exp bparker $ (BRL)";
d165 1
a165 1
    for( BU_LIST_FOR(dlp, dm_list, &head_dm_list.l) ){
d167 2
a168 2
	 dlp->_mged_variables.faceplate &&
	 dlp->_mged_variables.orig_gui)
d184 1
a184 1
  for( BU_LIST_FOR(p, dm_list, &head_dm_list.l) ){
d205 1
a205 1
    if(mged_variables.rateknobs){
d241 1
a241 1
  dmp->dm_setLineAttr(dmp, mged_variables.linewidth, 0);
d286 1
a286 1
  dmp->dm_setLineAttr(dmp, mged_variables.linewidth, 0);
d373 1
a373 1
  for(BU_LIST_FOR(dlp1, dm_list, &head_dm_list.l))
d383 1
a383 1
  for(BU_LIST_FOR(dlp2, dm_list, &head_dm_list.l))
d405 1
a405 1
  for(BU_LIST_FOR(dlp3, dm_list, &head_dm_list.l))
d412 40
@


11.20
log
@mods to allow menu "state" to be shared among display managers
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.19 1997/04/29 12:36:18 bparker Exp bparker $ (BRL)";
d240 3
d244 1
d285 3
d289 1
@


11.19
log
@mods to mmenu_set_all()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.18 1997/04/23 18:30:43 bparker Exp bparker $ (BRL)";
d140 2
a149 3
#if 0
    bu_vls_printf(&menu_string, "mmenu_set %d ", index);
#else
a151 1
#endif
d165 6
a170 5
#if 0
    update_views = 1;
#else
    dirty = 1;
#endif
a216 30
  case BV_EDIT_TOGGLE:
    if(mged_variables.edit){
      dmp->dm_setColor(dmp, DM_WHITE, 1);
      dmp->dm_drawString2D( dmp, "Edit", MENUX, y-15, 0, 0 );
      dmp->dm_setColor(dmp, DM_YELLOW, 1);
      dmp->dm_drawString2D( dmp, "/View", MENUX+4*40, y-15, 0, 0 );
    }else{
      dmp->dm_setColor(dmp, DM_YELLOW, 1);
      dmp->dm_drawString2D( dmp, "Edit/", MENUX, y-15, 0, 0 );
      dmp->dm_setColor(dmp, DM_WHITE, 1);
      dmp->dm_drawString2D( dmp, "View", MENUX+5*40, y-15, 0, 0 );
    }
    break;
  case BV_EYEROT_TOGGLE:
    if(mged_variables.eyerot)
      dmp->dm_setColor(dmp, DM_WHITE, 1);
    else
      dmp->dm_setColor(dmp, DM_YELLOW, 1);

    dmp->dm_drawString2D( dmp, mptr->menu_string, MENUX, y-15, 0, 0 );
#if 0
  case BE_S_CONTEXT:
    if(mged_variables.context)
      dmp->dm_setColor(dmp, DM_WHITE, 1);
    else
      dmp->dm_setColor(dmp, DM_YELLOW, 1);

    dmp->dm_drawString2D( dmp, mptr->menu_string, MENUX, y-15, 0, 0 );
    break;
#endif
d349 57
@


11.18
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.17 1997/02/28 21:37:27 bparker Exp bparker $ (BRL)";
d180 1
d183 1
d186 3
d193 1
@


11.17
log
@define mmenu_set_all
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.16 1997/02/04 22:16:23 bparker Exp bparker $ (BRL)";
a38 1
#include "./menu.h"
@


11.16
log
@*- add menu item -- "Rotate About Eye"
*- mods to highlight new item when appropriate
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.15 1997/01/30 22:34:43 bparker Exp bparker $ (BRL)";
d45 2
d53 1
d123 1
d128 1
d149 1
d151 4
d168 1
d170 20
@


11.15
log
@mods due to changes in dm_drawString2D
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.14 1997/01/02 21:55:00 bparker Exp bparker $ (BRL)";
d195 7
d248 4
a251 2
      if((*m == (struct menu_item *)second_menu && (mptr->menu_arg == BV_RATE_TOGGLE ||
				  mptr->menu_arg == BV_EDIT_TOGGLE)))
d290 1
a290 1
mmenu_select( pen_y )
d292 1
d321 1
a321 1
			if( mptr->menu_func != ((void (*)())0) )
@


11.14
log
@mods to mged_highlight_menu_item()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.13 1996/12/30 22:39:13 bparker Exp bparker $ (BRL)";
d172 1
a172 1
      dmp->dm_drawString2D( dmp, "Rate", MENUX, y-15 );
d174 1
a174 1
      dmp->dm_drawString2D( dmp, "/Abs", MENUX+4*40, y-15 );
d177 1
a177 1
      dmp->dm_drawString2D( dmp, "Rate/", MENUX, y-15 );
d179 1
a179 1
      dmp->dm_drawString2D( dmp, "Abs", MENUX+5*40, y-15 );
d185 1
a185 1
      dmp->dm_drawString2D( dmp, "Edit", MENUX, y-15 );
d187 1
a187 1
      dmp->dm_drawString2D( dmp, "/View", MENUX+4*40, y-15 );
d190 1
a190 1
      dmp->dm_drawString2D( dmp, "Edit/", MENUX, y-15 );
d192 1
a192 1
      dmp->dm_drawString2D( dmp, "View", MENUX+5*40, y-15 );
d202 1
a202 1
    dmp->dm_drawString2D( dmp, mptr->menu_string, MENUX, y-15 );
d250 1
a250 1
	dmp->dm_drawString2D( dmp, mptr->menu_string, MENUX, y-15 );
d258 1
a258 1
	dmp->dm_drawString2D(dmp, "==>", XMIN, y-15);
@


11.13
log
@*- code to highlight a few menu items
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.12 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d174 1
a174 1
      dmp->dm_drawString2D( dmp, "/Abs", MENUX+4*35, y-15 );
d179 1
a179 1
      dmp->dm_drawString2D( dmp, "Abs", MENUX+5*35, y-15 );
d187 1
a187 1
      dmp->dm_drawString2D( dmp, "/View", MENUX+4*35, y-15 );
d192 1
a192 1
      dmp->dm_drawString2D( dmp, "View", MENUX+5*35, y-15 );
@


11.12
log
@hacks to use latest libdm
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.11 1996/09/23 18:24:33 bparker Exp bparker $ (BRL)";
d44 1
d161 49
d236 16
a251 5
      if(mptr == *m)
	dmp->dm_setColor(dmp, DM_RED, 1);
      else
	dmp->dm_setColor(dmp, DM_YELLOW, 1);
      dmp->dm_drawString2D( dmp, mptr->menu_string, MENUX, y-15 );
@


11.11
log
@use LIBDM permanently
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.10 1996/09/17 21:18:34 bparker Exp bparker $ (BRL)";
d171 37
a207 24
	static int menu, item;
	register struct menu_item	**m;
	register struct menu_item	*mptr;
	register int y = y_top;

	menu_top = y - MENU_DY / 2;
	dmp->dmr_2d_line(dmp, MENUXLIM, menu_top, XMIN, menu_top, 0);

	for( menu=0, m = menu_array; m < &menu_array[NMENU]; m++,menu++ )  {
		if( *m == MENU_NULL )  continue;
		for( item=0, mptr = *m;
		     mptr->menu_string[0] != '\0' && y > TITLE_YBASE;
		     mptr++, y += MENU_DY, item++ )  {
			dmp->dmr_puts( dmp, mptr->menu_string, MENUX, y-15, 0,
				mptr == *m ? DM_RED : DM_YELLOW );
			dmp->dmr_2d_line(dmp, MENUXLIM, y+(MENU_DY/2), XMIN, y+(MENU_DY/2), 0);
			if( cur_item == item && cur_menu == menu && menuflag )  {
				/* prefix item selected with "==>" */
				dmp->dmr_puts(dmp, "==>", XMIN, y-15, 0, DM_WHITE);
			}
		}
	}
	if( y == y_top )  return;	/* no active menus */
	dmp->dmr_2d_line( dmp, MENUXLIM, menu_top-1, MENUXLIM, y-(MENU_DY/2), 0 );
@


11.10
log
@prepare to use libdm
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.9 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d40 1
a40 1
#include "./dm.h"
a176 1
#ifdef USE_LIBDM
a177 3
#else
	dmp->dmr_2d_line(MENUXLIM, menu_top, XMIN, menu_top, 0);
#endif
a183 1
#ifdef USE_LIBDM
a186 5
#else
			dmp->dmr_puts( mptr->menu_string, MENUX, y-15, 0,
				mptr == *m ? DM_RED : DM_YELLOW );
			dmp->dmr_2d_line(MENUXLIM, y+(MENU_DY/2), XMIN, y+(MENU_DY/2), 0);
#endif
a188 1
#ifdef USE_LIBDM
a189 3
#else
				dmp->dmr_puts("==>", XMIN, y-15, 0, DM_WHITE);
#endif
a193 1
#ifdef USE_LIBDM
a194 3
#else
	dmp->dmr_2d_line( MENUXLIM, menu_top-1, MENUXLIM, y-(MENU_DY/2), 0 );
#endif
@


11.9
log
@rt_list ---> bu_list
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.8 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d177 3
d181 1
d188 5
d196 1
d199 3
d203 1
d208 3
a210 1

d212 1
@


11.8
log
@now using libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.7 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d34 1
a36 1
#include "rtstring.h"
@


11.7
log
@Still Tcl'ing the code
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.6 1996/04/18 20:25:25 bparker Exp bparker $ (BRL)";
d89 1
a89 1
	struct rt_vls result;
d92 2
a93 2
	rt_vls_init(&result);
	rt_vls_strcat(&result, "list");
d95 1
a95 1
	    rt_vls_printf(&result, " [%s %d]", argv[0], m-menu_array);
d97 2
a98 2
	status = Tcl_Eval(interp, rt_vls_addr(&result));
	rt_vls_free(&result);
d136 1
a136 1
    struct rt_vls menu_string;
d140 1
a140 1
    rt_vls_init(&menu_string);
d143 1
a143 1
    rt_vls_printf(&menu_string, "mmenu_set %d ", index);
d151 2
a152 2
    rt_vls_strcat(&menu_string, Tcl_DStringValue(&ds_menu));
    (void)Tcl_Eval(interp, rt_vls_addr(&menu_string));
d155 1
a155 1
    rt_vls_free(&menu_string);
@


11.6
log
@convert commands to Tcl
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.5 1996/03/22 18:36:05 bparker Exp bparker $ (BRL)";
d90 1
d97 4
a100 1
	return Tcl_Eval(interp, rt_vls_addr(&result));
@


11.5
log
@cleanup
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.4 1996/03/20 22:16:25 bparker Exp bparker $ (BRL)";
d65 2
a66 2
	Tcl_SetResult(interp, "wrong # args: must be \"mmenu_get ?index?\"",
		      TCL_STATIC);
d77 1
a77 1
	    Tcl_SetResult(interp, "index out of range", TCL_STATIC);
@


11.4
log
@*** empty log message ***
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.3 1996/01/17 22:01:58 bparker Exp bparker $ (BRL)";
d153 1
d236 1
a236 5
#ifdef MULTI_ATTACH
			update_views = 1;
#else
			dmaflag = 1;
#endif
@


11.3
log
@added update_views to synchronize the menus
in the other drawing windows
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.2 1995/08/03 21:46:18 gdurf Exp bparker $ (BRL)";
d237 2
a239 1
			dmaflag = 1;
@


11.2
log
@Added support for GUI menus
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 11.1 1995/01/04 10:03:18 mike Rel4_4 gdurf $ (BRL)";
d235 3
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 10.5 94/12/23 14:21:00 gdurf Exp $ (BRL)";
d29 2
d36 1
d42 2
d48 2
a49 2
static int	cur_menu;	/* index of selected menu in list */
static int	cur_item;	/* index of selected item in menu */
d54 49
d115 4
d121 1
d131 22
a152 1
	menu_array[index] = value;
@


10.5
log
@Added mmenu_set
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 10.4 94/11/10 16:32:08 jra Exp Locker: gdurf $ (BRL)";
@


10.4
log
@Adjusted menu strings down slightly fr a prettier display.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 10.3 94/08/11 01:30:11 gdurf Exp Locker: jra $ (BRL)";
d61 12
@


10.3
log
@Added include of externs.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 10.2 1994/08/09 15:23:10 gdurf Exp gdurf $ (BRL)";
d87 1
a87 1
			dmp->dmr_puts( mptr->menu_string, MENUX, y, 0,
d92 1
a92 1
				dmp->dmr_puts("==>", XMIN, y, 0, DM_WHITE);
@


10.2
log
@Added include of conf.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/menu.c,v 10.1 1991/10/12 06:43:48 mike Rel4_0 gdurf $ (BRL)";
d31 1
@


10.1
log
@Release_4.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: menu.c,v 9.1 89/05/19 06:03:25 mike Rel3_5 $ (BRL)";
d26 2
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: menu.c,v 8.3 89/04/21 04:55:22 mike Exp $ (BRL)";
@


8.3
log
@Faceplate screen locations moved to titles.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: menu.c,v 8.2 88/12/06 01:39:28 mike Locked $ (BRL)";
@


8.2
log
@used raytrace.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/menu.c,v 1.2 88/10/23 13:56:42 mike Exp $ (BRL)";
d32 1
@


8.1
log
@Release_3.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: menu.c,v 7.4 88/09/17 02:35:20 reschly Exp $ (BRL)";
d30 1
@


7.4
log
@added stdio include.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: menu.c,v 7.3 88/07/22 02:03:00 reschly Locked $ (BRL)";
@


7.3
log
@changed menu_ to mmenu_ do to clashes with SunView routines (sigh)
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: menu.c,v 7.2 87/11/05 05:06:28 phil Locked $ (BRL)";
d27 1
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d5 4
a8 3
 *	menu_init		Clear global menu data
 *	menu_display		Add a list of items to the display list
 *	menu_select		Called by usepen() for menu pointing
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: menu.c,v 7.1 87/11/03 00:01:23 mike Rel $ (BRL)";
d44 1
a44 1
 *			M E N U _ I N I T
d49 1
a49 1
menu_init()
d58 1
a58 1
 *			M E N U _ D I S P L A Y
d65 1
a65 1
menu_display( y_top )
d96 1
a96 1
 *			M E N U _ S E L E C T
d105 1
a105 1
menu_select( pen_y )
d145 1
a145 1
 *			M E N U _ A R R O W
d152 1
a152 1
menu_pntr( menu, item )
@


7.1
log
@Release 2.3
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 6.1 87/07/11 08:04:38 mike Rel $ (BRL)";
d26 1
a26 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 5.1 87/06/24 22:21:30 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 4.2 87/02/13 00:08:13 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 4.1 86/12/29 03:22:21 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 2.8 86/09/23 17:41:45 mike Exp $ (BRL)";
@


2.8
log
@Minor cleanup for cray
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 2.7 86/09/10 01:35:50 mike Exp $ (BRL)";
@


2.7
log
@General internal cleanup, with better external interface
for setting arrows, etc.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 2.6 86/08/12 06:50:12 mike Exp $ (BRL)";
d147 1
a147 1
 *  Example:  menu_arrow( MENU_L1, 3 ).
d151 1
a151 1
menu_arrow( menu, item )
@


2.6
log
@Changed #includes for CC -I../h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 2.5 85/08/07 05:19:22 mike Exp $ (BRL)";
a34 1
static int	menu_current;	/* y-location of selected menu item */
d36 2
d39 2
a40 1
/* MENU_INIT() ==== clear global data.*/
d42 5
d56 7
a62 2
/* MENU_DISPLAY(y) ==== Add a list of items to the display list. */

d67 1
d75 1
a75 1
	for( m = menu_array; m < &menu_array[NMENU]; m++ )  {
d77 1
a77 1
		for( mptr = *m;
d79 1
a79 1
		     mptr++, y += MENU_DY )  {
d83 4
a91 5

	/* prefix item selected with "==>" to let user know it is selected */
	if( menuflag ) {
		dmp->dmr_puts("==>", XMIN, menu_current, 0, DM_WHITE);
	}
d94 2
a95 1
/* MENU_SELECT(x,y)
d97 2
d107 1
d121 1
a121 1
	for( m = menu_array; m < &menu_array[NMENU]; m++ )  {
d123 1
a123 1
		for( mptr = *m;
d125 1
a125 1
		     mptr++ )  {
d129 5
a133 4
			if( mptr != *m )  {
				menu_current = yy - (MENU_DY / 2);
				menuflag = 1;	/* tag a non-title item */
			}
d135 1
a135 1
				(*(mptr->menu_func))(mptr->menu_arg);
d141 16
@


2.5
log
@Changed to use common ../h/vmath.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 2.4 85/05/29 23:17:30 mike Exp $ (BRL)";
d27 4
a30 4
#include "../h/vmath.h"
#include "ged.h"
#include "menu.h"
#include "dm.h"
@


2.4
log
@Added MENU_L2 menu for solid/object edit buttons,
moved menus to left side of screen.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 2.3 85/05/10 00:54:43 mike Exp $ (BRL)";
d26 5
a30 4
#include	"ged_types.h"
#include	"ged.h"
#include	"menu.h"
#include	"dm.h"
@


2.3
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 2.2 85/05/03 01:58:28 mike Exp $ (BRL)";
d59 1
d66 3
a68 2
			dmp->dmr_puts( mptr->menu_string, MENUX, y, 0, DM_YELLOW );
			dmp->dmr_2d_line(XLIM, y+(MENU_DY/2), 2047, y+(MENU_DY/2), 0);
d73 1
a73 1
	dmp->dmr_2d_line( XLIM, menu_top-1, XLIM, y-(MENU_DY/2), 0 );
d77 1
a77 1
		dmp->dmr_puts("==>", MENUX-114, menu_current, 0, DM_WHITE);
@


2.2
log
@Improved to box in each menu item.  Eliminated lots of
global variables, moved ===> functionality in here from
titles.c, made it possible to menu select the title of
a menu (for later extension to pop-up menus).
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: menu.c,v 2.1 85/03/11 23:56:34 mike Prod $ (BRL)";
d32 1
a32 2
int	menu_on;
struct menu_item *menu_list;	/* base of array of menu items */
a41 1
	menu_on = 0;
d43 3
a45 1
	menu_list = MENU_NULL;
d54 1
a57 3
	if( menu_list == MENU_NULL || menu_on == 0 )
		return;

d60 8
a67 5
	for( mptr = &menu_list[0];
	     mptr->menu_string[0] != '\0';
	     mptr++, y += MENU_DY )  {
		dmp->dmr_puts( mptr->menu_string, MENUX, y, 0, DM_YELLOW );
		dmp->dmr_2d_line(XLIM, y+(MENU_DY/2), 2047, y+(MENU_DY/2), 0);
d69 1
d71 1
a71 1
	dmp->dmr_2d_line( XLIM, menu_top, XLIM, y-(MENU_DY/2), 0 );
d81 3
a83 1
 * Returns: 1 if menu claims these pen co-ordinates, 0 otherwise.
d89 1
d94 1
a94 1
		return(0);	/* pen above menu area */
d101 17
a117 9
	for( mptr = &menu_list[0];
	     mptr->menu_string[0] != '\0';
	     mptr++ )  {
		yy += MENU_DY;
		if( pen_y <= yy )
			continue;	/* pen is below this item */
		if( mptr != &menu_list[0] )  {
			menu_current = yy - (MENU_DY / 2);
			menuflag = 1;	/* tag a non-title item */
a118 4
		if( mptr->menu_func != ((void (*)())0) )
			(*(mptr->menu_func))(mptr->menu_arg);
		dmaflag = 1;
		return( 1 );		/* menu claims pen value */
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d9 1
a9 1
 * Author -
d11 1
d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a30 1
int	menuyy;		/* y-location of selected menu item */
d32 2
a33 2
int	menu_on;	/* (User || Programmer) controlled by MENU_ON();*/
struct menu_item	*menu_list;	/* Pointer to the current menu list */
d35 2
a36 5
static int	i_menu_pen;
		/* Set in menu_pen() to index of menu item closest to pen. */
static int	menu_y;		/* VG tube space loc of the first menu item */
static int	x_old_menu;	/* Saves old pen loc.for debounce.*/
static int	y_old_menu;
d43 3
a45 10
	x_old_menu = 999999;
	y_old_menu = 999999;
	i_menu_pen = -1;	/* pen not close to menu list.
					NOTE, setting this fixes the problem 
					of calling usepen before the call
					to do zoom.  So do not worry.*/
	MENU_ON(FALSE);		/* do not display empty menu.*/
	MENU_INSTALL((struct menu_item *)NULL);	/* no menu list.*/
/**	init_ars();	/*ARS INPUT ONLY*/
	/* run the ARS menus.*/
d51 2
a52 2
menu_display( y )
int			y;	/*=== points @@ the tube. */
d54 2
a55 2
	register int	i;
	register char	*str;
d57 1
a57 1
	if( menu_list == (struct menu_item *)NULL )
d60 1
a60 3
	dmp->dmr_puts(menu_list->menu_string, XLIM, y, 0, DM_YELLOW );
	if( menu_on == FALSE )
		return;
d62 5
a66 11
	/* save the tube space location of the starting point of this menu. */
	menu_y = y + MENU_DY / 2;
	y += MENU_DY;		/* skip space for first item.*/
	for( i = 1; (str = (menu_list + i)->menu_string)[0] != '\0'; ++i )  {
		dmp->dmr_puts( str, MENUX, y, 0, DM_YELLOW );
		if( i == i_menu_pen )  {
			/* pen is near, intensify */
			dmp->dmr_puts(str,MENUX,y,0, DM_WHITE );
			dmp->dmr_puts(str,MENUX,y,0, DM_WHITE );
		}
		y += MENU_DY; /* skip space for next item.*/
d68 7
d77 1
a77 4
/* MENU_SELECT(x,y) ==== called in pen input area, to activate the 
 *	===	pen menu select function. This sets the I_menu_pen
 *	===	integer when the pen is not pushed, else the function
 *	===	in the menu list is activated.
d82 2
a83 4
menu_select( x, y, pressval )
int	x;
register int y;
int	pressval;
d85 2
a86 3
	struct menu_item	*mptr;
	int			yy;
	register int		i;
d88 2
a89 2
	if( x <= MENUX )
		return( 0 );		/* menu does not claim the pen */
a90 3

	yy = menu_y;		/* set a finger @@ the begining of the
					menu list on the tube.*/
a91 6
	 * The pen is within the menu
	 */
	i_menu_pen = -1;	/* non selected value!!*/
	dmaflag = 1;		/* activate dozoom!!*/

	/* Find the pen close location. that is...
d93 1
a93 5
	 * above here. The algorithim is ...
	 *	FOR all menu items DO probe next item
	 *	UNTIL selected item is found (i.e., selected
	 *	means pen is close to the item name)
	 *	THEN mark the item selected.
d95 10
a104 6
	for( i = 1; ((menu_list + i)->menu_string)[0] != '\0'; ++i )  {
		yy += MENU_DY;	/* skip an item space */
		if( y > yy )	/* UNTIL above here...*/
		{	
			i_menu_pen = i;	/* THEN select it.*/
			break;		/* EXIT FOR LOOP */
d106 4
d111 1
a111 18

	if(	pressval
	    &&	( i_menu_pen != -1 )		/* pen on menu item */
	    &&	( x != x_old_menu)		/* debounce x and y */
	    &&	( y != y_old_menu)		)
	{
		/* Save for debounce when pen is pushed to select.*/
		x_old_menu = x;		
		y_old_menu = y;
		/* get pointer to item[i_menu_pen].*/
		mptr  = menu_list + i_menu_pen;
		menuyy = yy - (MENU_DY / 2);
		menuflag = 1;
		/* CALL the function corresponding to the users
		   menu item selected, and pass in the argument.*/
		(*(mptr->menu_func))(mptr->menu_arg);
	}
	return( 1 );	/* menu claims the pen value */
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d9 1
a9 1
 * Authors -
d11 9
d21 3
d96 1
a96 1
menu_select( x, y, press )
d99 1
a99 1
int	press;
d134 1
a134 1
	if(	press
@


1.1
log
@Initial revision
@
text
@a0 1
/*	SCCSID	%W%	%E%	*/
d2 1
a2 1
 *			E 1 1 . C
a10 8
 *
 *		R E V I S I O N   H I S T O R Y
 *
 *	05/27/83  MJM	Adapted code to run on VAX;  numerous cleanups.
 *
 *	09-Sep-83 DAG	Overhauled.
 *
 *	11/02/83  MJM	Changed to use display manager.
d58 1
a58 1
	dm_puts(menu_list->menu_string, XLIM, y, 0, DM_YELLOW );
d66 1
a66 1
		dm_puts( str, MENUX, y, 0, DM_YELLOW );
d69 2
a70 2
			dm_puts(str,MENUX,y,0, DM_WHITE );
			dm_puts(str,MENUX,y,0, DM_WHITE );
@
