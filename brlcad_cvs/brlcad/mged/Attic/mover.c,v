head	11.37;
access;
symbols
	ansi-20040405-merged:11.33.2.2
	postmerge-20040405-ansi:11.35
	premerge-20040404-ansi:11.34
	postmerge-autoconf:11.34
	autoconf-freeze:11.33.10.2
	premerge-autoconf:11.34
	postmerge-20040315-windows:11.34
	premerge-20040315-windows:11.34
	windows-20040315-freeze:11.33.4.1
	autoconf-20031203:11.33
	autoconf-20031202:11.33
	autoconf-branch:11.33.0.10
	phong-branch:11.33.0.8
	photonmap-branch:11.33.0.6
	rel-6-1-DP:11.33
	windows-branch:11.33.0.4
	rel-6-0-2:11.31
	ansi-branch:11.33.0.2
	rel-6-0-1-branch:11.31.0.2
	hartley-6-0-post:11.32
	hartley-6-0-pre:11.31
	rel-6-0-1:11.31
	rel-6-0:11.31
	rel-5-4:11.22
	offsite-5-3-pre:11.30
	rel-5-3:11.22
	rel-5-2:11.22
	rel-5-1-branch:11.22.0.2
	rel-5-1:11.22
	rel-5-0:11.17
	rel-5-0-beta:11.17
	rel-4-5:11.15
	ctj-4-5-post:11.12
	ctj-4-5-pre:11.12
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.6;
locks; strict;
comment	@ * @;


11.37
date	2004.05.21.17.47.47;	author morrison;	state dead;
branches;
next	11.36;

11.36
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.35;

11.35
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2004.02.02.17.39.34;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2002.08.20.17.08.24;	author jra;	state Exp;
branches
	11.33.2.1
	11.33.4.1
	11.33.10.1;
next	11.32;

11.32
date	2002.08.15.20.55.36;	author hartley;	state Exp;
branches;
next	11.31;

11.31
date	2001.04.02.21.38.20;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2000.09.08.05.55.49;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.24.02.54.14;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.08.22.06.49.07;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.08.19.03.10.47;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.07.29.23.23.05;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.07.23.23.42.21;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.05.21.42.52;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.06.30.19.58.09;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.12.30.19.21.05;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	99.12.29.23.23.24;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.11.26.23.03.32;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.11.24.14.26.42;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	99.11.08.14.27.41;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	98.12.10.17.43.05;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	98.06.15.18.50.09;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.12.18.06.31.31;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.08.20.15.11.18;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	97.04.15.14.35.06;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.02.28.21.39.31;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	97.02.21.14.50.19;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	97.02.14.14.54.44;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	97.01.02.19.36.55;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.10.04.15.04.26;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.07.25.19.00.06;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	96.04.18.20.25.25;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.21;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.12.16.19.37.00;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.09.15.24.27;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.06.25.20.48.02;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.05.15.30.43;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.44.10;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.01.26.04.09.06;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.08.00.31.22;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.07.03.17.16;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.03.33;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.05.11.21.42.26;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.20.40.12;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.03.06.17.38.05;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.39.48;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.37.09;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.17.02.35.22;	author reschly;	state Exp;
branches;
next	7.3;

7.3
date	87.11.05.07.09.00;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.06.31;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.01.31;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.04.47;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.21.41;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.12.40;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.22.28;	author mike;	state Rel1;
branches;
next	2.10;

2.10
date	86.10.12.03.07.48;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.08.12.06.50.15;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.03.14.20.42.19;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.02.17.17.09.13;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.08.07.05.19.25;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.05.29.11.59.47;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.05.08.00.31.33;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.05.02.20.16.20;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.04.06.23;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.56.39;	author mike;	state Prod;
branches;
next	1.3;

1.3
date	85.01.16.01.58.19;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.04.25.04;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.51.59;	author mike;	state Exp;
branches;
next	;

11.33.2.1
date	2002.09.19.18.02.03;	author morrison;	state Exp;
branches;
next	11.33.2.2;

11.33.2.2
date	2004.03.17.21.22.01;	author morrison;	state Exp;
branches;
next	;

11.33.4.1
date	2004.03.11.23.46.35;	author morrison;	state Exp;
branches;
next	;

11.33.10.1
date	2004.02.12.18.34.15;	author erikg;	state Exp;
branches;
next	11.33.10.2;

11.33.10.2
date	2004.03.15.14.07.39;	author erikg;	state Exp;
branches;
next	;


desc
@Reflect displacement of objects into the database
@


11.37
log
@moved to src/mged/
@
text
@/*
 *			M O V E R . C
 *
 * Functions -
 *	moveHobj	used to update position of an object in objects file
 *	moveinstance	Given a COMB and an object, modify all the regerences
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/mover.c,v 11.36 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "wdb.h"
#include "./ged.h"
#include "./mged_solid.h"

/* default region ident codes */
int	item_default = 1000;	/* GIFT region ID */
int	air_default = 0;
int	mat_default = 1;	/* GIFT material code */
int	los_default = 100;	/* Line-of-sight estimate */

/*
 *			M O V E H O B J
 *
 * This routine is used when the object to be moved is
 * the top level in its reference path.
 * The object itself (solid or "leaf" combination) is relocated.
 */
void
moveHobj(register struct directory *dp, matp_t xlate)
{
	struct rt_db_internal	intern;

	if(dbip == DBI_NULL)
	  return;

    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_db_get_internal( &intern, dp, dbip, xlate, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "rt_db_get_internal() failed for ", dp->d_namep,
			(char *)NULL );
		rt_db_free_internal( &intern, &rt_uniresource );
		READ_ERR_return;
	}

	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "moveHobj(", dp->d_namep,
			   "):  solid export failure\n", (char *)NULL);
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR;
		return;
	}
}

/*
 *			M O V E H I N S T A N C E
 *
 * This routine is used when an instance of an object is to be
 * moved relative to a combination, as opposed to modifying the
 * co-ordinates of member solids.  Input is a pointer to a COMB,
 * a pointer to an object within the COMB, and modifications.
 */
void
moveHinstance(struct directory *cdp, struct directory *dp, matp_t xlate)
{
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;

	if(dbip == DBI_NULL)
	  return;

	if( rt_db_get_internal( &intern, cdp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		READ_ERR_return;

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	if( comb->tree )
	{
		union tree *tp;

		tp = (union tree *)db_find_named_leaf( comb->tree, dp->d_namep );
		if( tp != TREE_NULL )
		{
			if( tp->tr_l.tl_mat )
				bn_mat_mul2( xlate, tp->tr_l.tl_mat );
			else
			{
				tp->tr_l.tl_mat = (matp_t)bu_malloc( 16 * sizeof( fastf_t ), "tl_mat" );
				MAT_COPY( tp->tr_l.tl_mat, xlate );
			}
			if( rt_db_put_internal( cdp, dbip, &intern, &rt_uniresource ) < 0 )
			{
				Tcl_AppendResult(interp, "rt_db_put_internal failed for ",
					cdp->d_namep, "\n", (char *)NULL );
				rt_db_free_internal( &intern, &rt_uniresource );
			}
		}
		else
		{
			Tcl_AppendResult(interp, "moveHinst:  couldn't find ", cdp->d_namep,
				"/", dp->d_namep, "\n", (char *)NULL);
			rt_db_free_internal( &intern, &rt_uniresource );
		}
	}
}
@


11.36
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/mover.c,v 11.35 2004/04/05 09:09:12 morrison Exp $ (BRL)";
@


11.35
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.34
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.33 2002/08/20 17:08:24 jra Exp $ (BRL)";
d58 1
a58 3
moveHobj( dp, xlate )
register struct directory *dp;
matp_t xlate;
d93 1
a93 4
moveHinstance( cdp, dp, xlate )
struct directory *cdp;
struct directory *dp;
matp_t xlate;
@


11.33
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.31 2001/04/02 21:38:20 morrison Exp $ (BRL)";
@


11.33.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/mover.c,v 11.34 2004/02/02 17:39:34 morrison Exp $ (BRL)";
@


11.33.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.34 2004/02/02 17:39:34 morrison Exp $ (BRL)";
@


11.33.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.33.10.1 2004/02/12 18:34:15 erikg Exp $ (BRL)";
@


11.33.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.33 2002/08/20 17:08:24 jra Exp $ (BRL)";
d58 3
a60 1
moveHobj(register struct directory *dp, matp_t xlate)
d95 4
a98 1
moveHinstance(struct directory *cdp, struct directory *dp, matp_t xlate)
@


11.33.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.32
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 3
a60 1
moveHobj(register struct directory *dp, matp_t xlate)
d95 4
a98 1
moveHinstance(struct directory *cdp, struct directory *dp, matp_t xlate)
@


11.31
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.30 2000/09/08 05:55:49 mike Exp $ (BRL)";
d58 1
a58 3
moveHobj( dp, xlate )
register struct directory *dp;
matp_t xlate;
d93 1
a93 4
moveHinstance( cdp, dp, xlate )
struct directory *cdp;
struct directory *dp;
matp_t xlate;
@


11.30
log
@
Tree routines now need resource structure.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.29 2000/08/24 02:54:14 mike Exp $ (BRL)";
d122 1
a122 1
				bn_mat_copy( tp->tr_l.tl_mat, xlate );
@


11.29
log
@
Changed from combadd() to mk_comb().
Main benefit is not taking a trip to the database as we add each member
to the combination.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.28 2000/08/22 06:49:07 mike Exp $ (BRL)";
d68 1
a68 1
	if( rt_db_get_internal( &intern, dp, dbip, xlate ) < 0 )
d72 1
a72 1
		rt_db_free_internal( &intern );
d76 1
a76 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
d80 1
a80 1
		rt_db_free_internal( &intern );
d106 1
a106 1
	if( rt_db_get_internal( &intern, cdp, dbip, (fastf_t *)NULL ) < 0 )
d124 1
a124 1
			if( rt_db_put_internal( cdp, dbip, &intern ) < 0 )
d128 1
a128 1
				rt_db_free_internal( &intern );
d135 1
a135 1
			rt_db_free_internal( &intern );
@


11.28
log
@
db_flatten_tree() got an additional argument, to prevent memory leaks.
@
text
@a6 1
 *	combadd		Add an instance of an object to a combination
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.27 2000/08/19 03:10:47 mike Exp $ (BRL)";
d35 1
d40 1
a41 1
#include "externs.h"
d128 1
a128 1
				rt_comb_ifree( &intern );
d133 1
a133 1
			Tcl_AppendResult(interp, "moveinst:  couldn't find ", cdp->d_namep,
d135 1
a135 121
			rt_comb_ifree( &intern );
		}
			
	}
}

/*
 *			C O M B A D D
 *
 * Add an instance of object 'dp' to combination 'name'.
 * If the combination does not exist, it is created.
 * region_flag is 1 (region), or 0 (group).
 */
struct directory *
combadd( objp, combname, region_flag, relation, ident, air )
register struct directory *objp;
char *combname;
int region_flag;			/* true if adding region */
int relation;				/* = UNION, SUBTRACT, INTERSECT */
int ident;				/* "Region ID" */
int air;				/* Air code */
{
	register struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	union tree *tp;
	struct rt_tree_array *tree_list;
	int node_count;
	int actual_count;

	if(dbip == DBI_NULL)
	  return DIR_NULL;

	/*
	 * Check to see if we have to create a new combination
	 */
	if( (dp = db_lookup( dbip,  combname, LOOKUP_QUIET )) == DIR_NULL )  {
		int flags;

		if( region_flag )
			flags = DIR_REGION | DIR_COMB;
		else
			flags = DIR_COMB;

		/* Add to the in-core directory */
		if( (dp = db_diradd( dbip, combname, -1, 0, flags, NULL )) == DIR_NULL )  {
		  Tcl_AppendResult(interp, "An error has occured while adding '",
				   combname, "' to the database.\n", (char *)NULL);
		  TCL_ERROR_RECOVERY_SUGGESTION;
		  return DIR_NULL;
		}

		BU_GETSTRUCT( comb, rt_comb_internal );
		comb->magic = RT_COMB_MAGIC;
		bu_vls_init( &comb->shader );
		bu_vls_init( &comb->material );
		comb->region_id = -1;
		comb->tree = TREE_NULL;

		RT_INIT_DB_INTERNAL( &intern );
		intern.idb_type = ID_COMBINATION;
		intern.idb_meth = &rt_functab[ID_COMBINATION];
		intern.idb_ptr = (genptr_t)comb;

		if( region_flag )
		{
			struct bu_vls tmp_vls;

			comb->region_flag = 1;
			comb->region_id = ident;
			comb->aircode = air;
			comb->los = los_default;
			comb->GIFTmater = mat_default;
			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls,
				"Creating region id=%d, air=%d, GIFTmaterial=%d, los=%d\n",
				ident, air, mat_default, los_default );
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);
		}

		BU_GETUNION( tp, tree );
		tp->magic = RT_TREE_MAGIC;
		tp->tr_l.tl_op = OP_DB_LEAF;
		tp->tr_l.tl_name = bu_strdup( objp->d_namep );
		tp->tr_l.tl_mat = (matp_t)NULL;
		comb->tree = tp;

		if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
		{
			Tcl_AppendResult(interp, "Failed to write ", dp->d_namep, (char *)NULL );
			return( DIR_NULL );
		}
		return( dp );
	}

	/* combination exists, add a new member */
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
	{
		Tcl_AppendResult(interp, "read error, aborting\n", (char *)NULL);
		TCL_ERROR_RECOVERY_SUGGESTION;
		return DIR_NULL;
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( region_flag && !comb->region_flag )
	{
		Tcl_AppendResult(interp, combname, ": not a region\n", (char *)NULL);
		return DIR_NULL;
	}

	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
	{
		db_non_union_push( comb->tree );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL );
			rt_comb_ifree( comb );
			return DIR_NULL;
a137 52

	/* make space for an extra leaf */
	node_count = db_tree_nleaves( comb->tree ) + 1;
	tree_list = (struct rt_tree_array *)bu_calloc( node_count,
		sizeof( struct rt_tree_array ), "tree list" );

	/* flatten tree */
	if( comb->tree )
	{
		actual_count = 1 + (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION, 1 ) - tree_list;
		BU_ASSERT_LONG( actual_count, ==, node_count );
		comb->tree = TREE_NULL;
	}

	/* insert new member at end */
	switch( relation )
	{
		case '+':
			tree_list[node_count - 1].tl_op = OP_INTERSECT;
			break;
		case '-':
			tree_list[node_count - 1].tl_op = OP_SUBTRACT;
			break;
		default:
			Tcl_AppendResult(interp, "unrecognized relation (assume UNION)\n",
				(char *)NULL );
		case 'u':
			tree_list[node_count - 1].tl_op = OP_UNION;
			break;
	}

	/* make new leaf node, and insert at end of list */
	BU_GETUNION( tp, tree );
	tree_list[node_count-1].tl_tree = tp;
	tp->tr_l.magic = RT_TREE_MAGIC;
	tp->tr_l.tl_op = OP_DB_LEAF;
	tp->tr_l.tl_name = bu_strdup( objp->d_namep );
	tp->tr_l.tl_mat = (matp_t)NULL;

	/* rebuild the tree */
	comb->tree = (union tree *)db_mkgift_tree( tree_list, node_count, (struct db_tree_state *)NULL );

	/* and finally, write it out */
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )
	{
		Tcl_AppendResult(interp, "Failed to write ", dp->d_namep, (char *)NULL );
		return( DIR_NULL );
	}

	bu_free( (char *)tree_list, "combadd: tree_list" );

	return( dp );
@


11.27
log
@
const RCSid
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.26 2000/07/29 23:23:05 mike Exp $ (BRL)";
d267 3
a269 3
		actual_count = 1 + (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
		if( actual_count > node_count )  bu_bomb("combadd() array overflow!");
		if( actual_count < node_count )  bu_log("WARNING combadd() array underflow! %d", actual_count, node_count);
@


11.26
log
@
Removed old v4 db_grow() and db_trunc() internal interfaces.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.25 2000/07/23 23:42:21 mike Exp $ (BRL)";
@


11.25
log
@
Removed calls to db_alloc(), which are no longer necessary
with either v4 or v5 database interfaces
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.24 2000/07/05 21:42:52 mike Exp $ (BRL)";
a298 8

	/* increase the length of this record */
	if( db_grow( dbip, dp, 1 ) < 0 )
	{
		Tcl_AppendResult(interp, "db_grow error, aborting\n", (char *)NULL);
		TCL_ERROR_RECOVERY_SUGGESTION;
		return DIR_NULL;
	}
@


11.24
log
@
lint
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.23 2000/06/30 19:58:09 mike Exp $ (BRL)";
d179 2
a180 3
		/* Update the in-core directory */
		if( (dp = db_diradd( dbip, combname, -1, 2, flags, NULL )) == DIR_NULL ||
		    db_alloc( dbip, dp, 2 ) < 0 )  {
@


11.23
log
@
ft_ifree calls replaced properly
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.22 1999/12/30 19:21:05 jra Exp $ (BRL)";
a62 1
	int			id;
d68 1
a68 1
	if( (id=rt_db_get_internal( &intern, dp, dbip, xlate )) < 0 )
@


11.22
log
@Eliminated some unused variables
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.21 1999/12/29 23:23:24 mike Exp $ (BRL)";
d73 1
a73 1
		if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
d81 1
a81 1
		if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
@


11.21
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.20 1999/11/26 23:03:32 mike Exp $ (BRL)";
a61 1
	struct bu_external	ext;
a62 1
	register int		i;
a100 1
	register int i;
a102 2
	int found=0;
	mat_t temp, xmat;		/* Temporary for mat_mul */
a117 1
			found = 1;
@


11.20
log
@
Lint
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.19 1999/11/24 14:26:42 jra Exp $ (BRL)";
d187 1
a187 1
		if( (dp = db_diradd( dbip, combname, -1, 2, flags )) == DIR_NULL ||
@


11.19
log
@All solid/combination creation  routines needed values assigned to idb_meth
in the rt_db_internal struct
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.18 1999/11/08 14:27:41 jra Exp $ (BRL)";
d112 1
a112 1
	if( rt_db_get_internal( &intern, cdp, dbip, (mat_t *)NULL ) < 0 )
d240 1
a240 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
@


11.18
log
@
moveHinstance() was putting a pinter to local variable in the tree.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.17 1998/12/10 17:43:05 jra Exp $ (BRL)";
d204 1
@


11.17
log
@combadd() was calling db_flatten_tree for empty trees.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/mover.c,v 11.16 1998/06/15 18:50:09 bparker Exp $ (BRL)";
d127 4
a130 1
				tp->tr_l.tl_mat = xlate;
@


11.16
log
@*- modified moveHinstance()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/mover.c,v 11.15 1997/12/18 06:31:31 mike Exp $ (BRL)";
d269 6
a274 3
	actual_count = 1 + (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
	if( actual_count > node_count )  bu_bomb("combadd() array overflow!");
	if( actual_count < node_count )  bu_log("WARNING combadd() array underflow! %d", actual_count, node_count);
@


11.15
log
@tl_mat being null indicates identity matrix.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.14 1997/08/20 15:11:18 jra Exp mike $ (BRL)";
d126 2
@


11.14
log
@Changed order of output when creating region in combadd().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.13 1997/07/01 22:09:08 bparker Exp jra $ (BRL)";
d124 2
a125 1
			bn_mat_mul2( xlate, tp->tr_l.tl_mat );
@


11.13
log
@mods to run without a database
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.12 1997/04/15 14:35:06 jra Exp bparker $ (BRL)";
d211 2
a212 2
				"Creating region id=%d, air=%d, los=%d, GIFTmaterial=%d\n",
				ident, air, los_default, mat_default );
@


11.12
log
@Combadd() was not setting dp->d_flags correctly.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.11 1997/02/28 21:39:31 jra Exp jra $ (BRL)";
d67 3
d109 3
d165 3
@


11.11
log
@removed include of db.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.10 1997/02/21 14:50:19 jra Exp jra $ (BRL)";
d141 1
a141 1
 * Flag is 'r' (region), or 'g' (group).
d164 1
d166 5
d172 1
a172 1
		if( (dp = db_diradd( dbip, combname, -1, 2, DIR_COMB )) == DIR_NULL ||
@


11.10
log
@convert to using combination import/export.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.9 1997/02/14 14:54:44 jra Exp jra $ (BRL)";
a38 1
#include "db.h"
@


11.9
log
@Converted to use combination import/export (combadd still uses union records).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.8 1997/01/02 19:36:55 bparker Exp jra $ (BRL)";
d154 7
a160 4
	union record record;
#if 0
	mat_t	identity;
#endif
d175 22
a196 21
		/* Generate the disk record */
		record.c.c_id = ID_COMB;
		record.c.c_flags = record.c.c_aircode = 0;
		record.c.c_regionid = -1;
		record.c.c_material = 0;
		record.c.c_los = 0;
		record.c.c_override = 0;
		record.c.c_matname[0] = '\0';
		record.c.c_matparm[0] = '\0';
		NAMEMOVE( combname, record.c.c_name );
		if( region_flag ) {       /* creating a region */
		  struct bu_vls tmp_vls;

		  
		  record.c.c_flags = 'R';
		  record.c.c_regionid = ident;
		  record.c.c_aircode = air;
		  record.c.c_los = los_default;
		  record.c.c_material = mat_default;
		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls,
d199 2
a200 2
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
d203 6
a208 6
		/* finished with combination record - write it out */
		if( db_put( dbip,  dp, &record, 0, 1 ) < 0 )  {
		  Tcl_AppendResult(interp, "write error, aborting\n", (char *)NULL);
		  TCL_ERROR_RECOVERY_SUGGESTION;
		  return DIR_NULL;
		}
d210 4
a213 18
		/* create first member record */
		if( db_get( dbip,  dp, &record, 1, 1) < 0 )  {
		  Tcl_AppendResult(interp, "read error, aborting\n", (char *)NULL);
		  TCL_ERROR_RECOVERY_SUGGESTION;
		  return DIR_NULL;
		}
		(void)strcpy( record.M.m_instname, objp->d_namep );

		record.M.m_id = ID_MEMB;
		record.M.m_relation = relation;
#if 0
		bn_mat_idn( identity );
#endif
		rt_dbmat_mat( record.M.m_mat, identity );
		if( db_put( dbip,  dp, &record, 1, 1 ) < 0 )  {
		  Tcl_AppendResult(interp, "write error, aborting\n", (char *)NULL);
		  TCL_ERROR_RECOVERY_SUGGESTION;
		  return DIR_NULL;
d218 6
a223 8
	/*
	 * The named combination already exists.  Fetch the header record,
	 * and verify that this is a combination.
	 */
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 )  {
	  Tcl_AppendResult(interp, "read error, aborting\n", (char *)NULL);
	  TCL_ERROR_RECOVERY_SUGGESTION;
	  return DIR_NULL;
d225 8
a232 3
	if( record.u_id != ID_COMB )  {
	  Tcl_AppendResult(interp, combname, ":  not a combination\n", (char *)NULL);
	  return DIR_NULL;
d235 9
a243 5
	if( region_flag ) {
	  if( record.c.c_flags != 'R' ) {
	    Tcl_AppendResult(interp, combname, ": not a region\n", (char *)NULL);
	    return DIR_NULL;
	  }
d245 26
a270 4
	if( db_grow( dbip, dp, 1 ) < 0 )  {
	  Tcl_AppendResult(interp, "db_grow error, aborting\n", (char *)NULL);
	  TCL_ERROR_RECOVERY_SUGGESTION;
	  return DIR_NULL;
d273 17
a289 5
	/* Fill in new Member record */
	if( db_get( dbip,  dp, &record, dp->d_len-1, 1) < 0 )  {
	  Tcl_AppendResult(interp, "read error, aborting\n", (char *)NULL);
	  TCL_ERROR_RECOVERY_SUGGESTION;
	  return DIR_NULL;
d291 6
a296 11
	record.M.m_id = ID_MEMB;
	record.M.m_relation = relation;
	(void)strcpy( record.M.m_instname, objp->d_namep );
#if 0
	bn_mat_idn( identity );
#endif
	rt_dbmat_mat( record.M.m_mat, identity );
	if( db_put( dbip,  dp, &record, dp->d_len-1, 1 ) < 0 )  {
	  Tcl_AppendResult(interp, "write error, aborting\n", (char *)NULL);
	  TCL_ERROR_RECOVERY_SUGGESTION;
	  return DIR_NULL;
d298 3
@


11.8
log
@mods to use libbn and libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.7 1996/10/04 15:04:26 bparker Exp bparker $ (BRL)";
a65 1
	union record		*rec;
d68 6
a73 1
	if( db_get_external( &ext, dp, dbip ) < 0 )
a74 41

	rec = (union record *)ext.ext_buf;
	if( rec->u_id == ID_COMB )  {
		/*
		 * Move all the references within a combination
		 * XXX should use combination import/export routines here too!
		 */
		for( i=1; i < dp->d_len; i++ )  {
			static mat_t temp, xmat;

			rt_mat_dbmat( xmat, rec[i].M.m_mat );
			bn_mat_mul( temp, xlate, xmat );
			rt_dbmat_mat( rec[i].M.m_mat, temp );
		}
		if( db_put_external( &ext, dp, dbip ) < 0 )  {
		  db_free_external( &ext );
		  TCL_WRITE_ERR;
		  return;
		}
		db_free_external( &ext );
		return;				/* OK */
	}

	/*
	 *  Import the solid, applying the transform on the way in.
	 *  Then, export it, and re-write the database record.
	 *  Will work on all solids.
	 */
	if( (id = rt_id_solid( &ext )) == ID_NULL )  {
	  Tcl_AppendResult(interp, "moveHobj(", dp->d_namep,
			   ") unable to identify type\n", (char *)NULL);
	  return;				/* FAIL */
	}

    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, &ext, xlate ) < 0 )  {
	  Tcl_AppendResult(interp, "moveHobj(", dp->d_namep,
			   "):  solid import failure\n", (char *)NULL);
	  if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
	  db_free_external( &ext );
	  return;				/* FAIL */
a75 2
	RT_CK_DB_INTERNAL( &intern );
	db_free_external( &ext );
d77 3
a79 2
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
	  Tcl_AppendResult(interp, "moveHobj(", dp->d_namep,
d81 3
a83 3
	  if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
	  TCL_WRITE_ERR;
	  return;
a84 1
	return;					/* OK */
d102 3
a104 1
	union record	*rec;
d107 1
a107 1
	if( (rec = db_getmrec( dbip, cdp )) == (union record *)0 )
d109 25
a133 13
	for( i=1; i < cdp->d_len; i++ )  {
		/* Check for match */
		if( strcmp( dp->d_namep, rec[i].M.m_instname ) != 0 )
			continue;

		rt_mat_dbmat( xmat, rec[i].M.m_mat );
		bn_mat_mul(temp, xlate, xmat);
		rt_dbmat_mat( rec[i].M.m_mat, temp );

		if( db_put( dbip,  cdp, rec, 0, cdp->d_len ) < 0 )
			WRITE_ERR_return;
		bu_free( (genptr_t)rec, "union record");
		return;
a134 4
	bu_free( (genptr_t)rec, "union record");
	Tcl_AppendResult(interp, "moveinst:  couldn't find ", cdp->d_namep,
			 "/", dp->d_namep, "\n", (char *)NULL);
	return;				/* ERROR */
@


11.7
log
@cast bu_free's 1st argument to genptr_t
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.6 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d28 1
d38 1
d63 1
a63 1
	struct rt_external	ext;
d82 1
a82 1
			mat_mul( temp, xlate, xmat );
d152 1
a152 1
		mat_mul(temp, xlate, xmat);
d246 1
a246 1
		mat_idn( identity );
d293 1
a293 1
	mat_idn( identity );
@


11.6
log
@include mged_solid.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.5 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d155 1
a155 1
		bu_free( (char *)rec, "union record");
d158 1
a158 1
	bu_free( (char *)rec, "union record");
@


11.5
log
@rt_list ---> bu_list
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.4 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d41 1
a41 1
#include "./solid.h"
@


11.4
log
@now using libbu
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.3 1996/07/25 19:00:06 bparker Exp bparker $ (BRL)";
d35 1
@


11.3
log
@no need to keep initializing identity
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.2 1996/04/18 20:25:25 bparker Exp bparker $ (BRL)";
d154 1
a154 1
		rt_free( (char *)rec, "union record");
d157 1
a157 1
	rt_free( (char *)rec, "union record");
d209 1
a209 1
		  struct rt_vls tmp_vls;
d217 2
a218 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls,
d221 2
a222 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
@


11.2
log
@convert commands to Tcl
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 11.1 1995/01/04 10:03:21 mike Rel4_4 bparker $ (BRL)";
d181 1
d183 1
a183 1

d242 1
d244 1
d289 1
a289 1

d291 1
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 10.5 94/12/16 19:37:00 gdurf Exp $ (BRL)";
d83 3
a85 3
			db_free_external( &ext );
			ERROR_RECOVERY_SUGGESTION;
			WRITE_ERR_return;
d97 3
a99 3
		rt_log("moveHobj(%s) unable to identify type\n",
			dp->d_namep );
		return;				/* FAIL */
d104 5
a108 5
		rt_log("moveHobj(%s):  solid import failure\n",
			dp->d_namep );
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		db_free_external( &ext );
		return;				/* FAIL */
d114 5
a118 5
		rt_log("moveHobj(%s):  solid export failure\n",
			dp->d_namep );
		if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		ERROR_RECOVERY_SUGGESTION;
		WRITE_ERR_return;
d158 2
a159 2
	rt_log( "moveinst:  couldn't find %s/%s\n",
		cdp->d_namep, dp->d_namep );
d191 4
a194 4
			rt_log("An error has occured while adding '%s' to the database.\n",
				combname);
			ERROR_RECOVERY_SUGGESTION;
			return DIR_NULL;
d208 11
a218 6
			record.c.c_flags = 'R';
			record.c.c_regionid = ident;
			record.c.c_aircode = air;
			record.c.c_los = los_default;
			record.c.c_material = mat_default;
			rt_log("Creating region id=%d, air=%d, los=%d, GIFTmaterial=%d\n",
d220 2
d226 3
a228 3
			rt_log("write error, aborting\n");
			ERROR_RECOVERY_SUGGESTION;
			return DIR_NULL;
d233 3
a235 3
			rt_log("read error, aborting\n");
			ERROR_RECOVERY_SUGGESTION;
			return DIR_NULL;
d244 3
a246 3
			rt_log("write error, aborting\n");
			ERROR_RECOVERY_SUGGESTION;
			return DIR_NULL;
d256 3
a258 3
		rt_log("read error, aborting\n");
		ERROR_RECOVERY_SUGGESTION;
		return DIR_NULL;
d261 2
a262 2
		rt_log("%s:  not a combination\n", combname );
		return DIR_NULL;
d266 4
a269 4
		if( record.c.c_flags != 'R' ) {
			rt_log("%s: not a region\n",combname);
			return DIR_NULL;
		}
d272 3
a274 3
		rt_log("db_grow error, aborting\n");
		ERROR_RECOVERY_SUGGESTION;
		return DIR_NULL;
d279 3
a281 3
		rt_log("read error, aborting\n");
		ERROR_RECOVERY_SUGGESTION;
		return DIR_NULL;
d290 3
a292 3
		rt_log("write error, aborting\n");
		ERROR_RECOVERY_SUGGESTION;
		return DIR_NULL;
@


10.5
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 10.4 1994/08/09 15:24:27 gdurf Exp gdurf $ (BRL)";
@


10.4
log
@Factored ifdefs
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 10.3 1992/06/25 20:48:02 mike Exp gdurf $ (BRL)";
d97 1
a97 1
		(void)printf("moveHobj(%s) unable to identify type\n",
d158 1
a158 1
	(void)printf( "moveinst:  couldn't find %s/%s\n",
d191 1
a191 1
			(void)printf("An error has occured while adding '%s' to the database.\n",
d213 1
a213 1
			(void)printf("Creating region id=%d, air=%d, los=%d, GIFTmaterial=%d\n",
d219 1
a219 1
			printf("write error, aborting\n");
d226 1
a226 1
			printf("read error, aborting\n");
d237 1
a237 1
			printf("write error, aborting\n");
d249 1
a249 1
		printf("read error, aborting\n");
d254 1
a254 1
		(void)printf("%s:  not a combination\n", combname );
d260 1
a260 1
			(void)printf("%s: not a region\n",combname);
d265 1
a265 1
		printf("db_grow error, aborting\n");
d272 1
a272 1
		printf("read error, aborting\n");
d283 1
a283 1
		printf("write error, aborting\n");
@


10.3
log
@Changed to use rt_db_put_internal
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 10.2 92/02/05 15:30:43 mike Exp $ (BRL)";
d25 2
d28 3
a30 1
#ifdef BSD
a31 2
#else
#include <string.h>
@


10.2
log
@db_put_external() handles solid names by itself.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 10.1 91/10/12 06:44:10 mike Rel4_0 Locker: mike $ (BRL)";
d111 1
a111 2
	/* Scale change on export is 1.0 -- no change */
	if( rt_functab[id].ft_export( &ext, &intern, 1.0 ) < 0 )  {
a114 7
		db_free_external( &ext );
		return;				/* FAIL */
	}
	rt_functab[id].ft_ifree( &intern );

	if( db_put_external( &ext, dp, dbip ) < 0 )  {
		db_free_external( &ext );
a117 1
	db_free_external( &ext );
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 9.4 91/01/26 04:09:06 mike Exp $ (BRL)";
a62 1
	char			name[NAMESIZE+2];
a93 1
	NAMEMOVE( rec->s.s_name, name );	/* pun for name location */
a119 3

	rec = (union record *)ext.ext_buf;
	NAMEMOVE( name, rec->s.s_name );
@


9.4
log
@Modified to use new import/export routine.
moveHojb transformation takes place as part of the importation.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 9.3 90/12/08 00:31:22 mike Exp $ (BRL)";
@


9.3
log
@Added error checking around calls to db_*() routines
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 9.2 90/12/07 03:17:16 mike Exp $ (BRL)";
d50 2
a51 5
 * the top level in its reference path.  The object itself
 * is relocated.
 *
 * This routine really should just be a bunch of calls to
 * solid-specific routines.
d58 6
a63 5
	vect_t	work;
	register int i;
	register dbfloat_t *p;		/* -> to vector to be worked on */
	static dbfloat_t *area_end;	/* End of area to be processed */
	union record	*rec;
d65 1
a65 1
	if( (rec = db_getmrec( dbip, dp )) == (union record *)0 )
d68 2
a69 3
	switch( rec->u_id )  {

	case ID_ARS_A:
a70 82
		 * 1st B type record is special:  Vertex point
		 */
		/* displace the base vector */
		MAT4X3PNT( work, xlate, &rec[1].b.b_values[0] );
		VMOVE( &rec[1].b.b_values[0], work );

		/* Transform remaining vectors */
		for( p = &rec[1].b.b_values[1*3]; p < &rec[1].b.b_values[8*3];
								p += 3) {
			MAT4X3VEC( work, xlate, p );
			VMOVE( p, work );
		}

		/* Process all the remaining B records */
		for( i = 2; i < dp->d_len; i++ )  {
			/* Transform remaining vectors */
			for( p = &rec[i].b.b_values[0*3];
			     p < &rec[i].b.b_values[8*3]; p += 3) {
				MAT4X3VEC( work, xlate, p );
				VMOVE( p, work );
			}
		}
		if( db_put( dbip, dp, rec, 0, dp->d_len ) < 0 )
			WRITE_ERR_return;
		rt_free( (char *)rec, "union record");
		break;

	case ID_BSOLID:
		move_spline( rec, dp, xlate );
		rt_free( (char *)rec, "union record");
		break;

	case ID_SOLID:
		/* Displace the vertex (V) */
		MAT4X3PNT( work, xlate, &rec[0].s.s_values[0] );
		VMOVE( &rec[0].s.s_values[0], work );

		switch( rec[0].s.s_type )  {

		case GENARB8:
			if(rec[0].s.s_cgtype < 0)
				rec[0].s.s_cgtype = -rec[0].s.s_cgtype;
			area_end = &rec[0].s.s_values[8*3];
			goto common;

		case GENTGC:
			area_end = &rec[0].s.s_values[6*3];
			goto common;

		case GENELL:
			area_end = &rec[0].s.s_values[4*3];
			goto common;

		case TOR:
			area_end = &rec[0].s.s_values[8*3];
			/* Fall into COMMON section */

		common:
			/* Transform all the vectors */
			for( p = &rec[0].s.s_values[1*3]; p < area_end;
			     p += 3) {
				MAT4X3VEC( work, xlate, p );
				VMOVE( p, work );
			}
			break;

		default:
			(void)printf("moveobj:  can't move obj type %d\n",
				rec[0].s.s_type );
			return;		/* ERROR */
		}
		if( db_put( dbip, dp, rec, 0, dp->d_len ) < 0 )
			WRITE_ERR_return;
		rt_free( (char *)rec, "union record");
		break;

	default:
		(void)printf("MoveHobj -- bad disk record\n");
		return;			/* ERROR */

	case ID_COMB:
		/*
d72 1
d81 3
a83 1
		if( db_put( dbip,  dp, rec, 0, dp->d_len ) < 0 )
d85 3
a87 1
		rt_free( (char *)rec, "union record");
d89 44
a132 1
	return;
@


9.2
log
@Eliminated use of rec.c.c_length, using instead dp->d_len-1
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/mover.c,v 9.1 89/05/19 06:03:33 mike Rel3_5 $ (BRL)";
d65 1
a65 1
	union record record;
d67 2
a68 1
	db_get( dbip,  dp, &record, 0 , 1);
d70 1
a70 1
	switch( record.u_id )  {
d73 3
a75 3
		/* 1st B type record is special:  Vertex point */
		db_get( dbip,  dp, &record, 1 , 1);

d77 2
a78 2
		MAT4X3PNT( work, xlate, &record.b.b_values[0] );
		VMOVE( &record.b.b_values[0], work );
d81 1
a81 1
		for( p = &record.b.b_values[1*3]; p < &record.b.b_values[8*3];
a85 1
		db_put( dbip,  dp, &record, 1, 1 );
a88 1
			db_get( dbip,  dp, &record, i , 1);
d90 2
a91 2
			for( p = &record.b.b_values[0*3];
			     p < &record.b.b_values[8*3]; p += 3) {
a94 1
			db_put( dbip,  dp, &record, i, 1 );
d96 3
d102 2
a103 1
		move_spline( &record.B, dp, xlate );
d108 2
a109 2
		MAT4X3PNT( work, xlate, &record.s.s_values[0] );
		VMOVE( &record.s.s_values[0], work );
d111 1
a111 1
		switch( record.s.s_type )  {
d114 3
a116 3
			if(record.s.s_cgtype < 0)
				record.s.s_cgtype = -record.s.s_cgtype;
			area_end = &record.s.s_values[8*3];
d120 1
a120 1
			area_end = &record.s.s_values[6*3];
d124 1
a124 1
			area_end = &record.s.s_values[4*3];
d128 1
a128 1
			area_end = &record.s.s_values[8*3];
d133 1
a133 1
			for( p = &record.s.s_values[1*3]; p < area_end;
d142 1
a142 1
				record.s.s_type );
d145 3
a147 1
		db_put( dbip,  dp, &record, 0, 1 );
d161 1
a161 3
			db_get( dbip,  dp, &record, i , 1);
			rt_mat_dbmat( xmat, record.M.m_mat );

d163 1
a163 3

			rt_dbmat_mat( record.M.m_mat, temp );
			db_put( dbip,  dp, &record, i, 1 );
d165 3
d187 1
a187 1
	union record record;
d190 2
a192 2
		db_get( dbip,  cdp, &record, i , 1);

d194 1
a194 1
		if( strcmp( dp->d_namep, record.M.m_instname ) != 0 )
d197 1
a197 1
		rt_mat_dbmat( xmat, record.M.m_mat );
d199 1
d201 3
a203 2
		rt_dbmat_mat( record.M.m_mat, temp );
		db_put( dbip,  cdp, &record, i, 1 );
d206 1
d238 5
a242 2
		dp = db_diradd( dbip, combname, -1, 2, DIR_COMB );
		if( dp == DIR_NULL )
d244 1
a244 1
		db_alloc( dbip, dp, 2 );
d267 5
a271 1
		db_put( dbip,  dp, &record, 0, 1 );
d274 5
a278 1
		db_get( dbip,  dp, &record, 1, 1);
d285 5
a289 1
		db_put( dbip,  dp, &record, 1, 1 );
d297 5
a301 1
	db_get( dbip,  dp, &record, 0 , 1);
d313 5
a317 1
	db_grow( dbip, dp, 1 );
d320 5
a324 1
	db_get( dbip,  dp, &record, dp->d_len-1, 1);
d331 5
a335 1
	db_put( dbip,  dp, &record, dp->d_len-1, 1 );
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 8.5 89/05/11 21:42:26 phil Exp $ (BRL)";
a238 1
		record.c.c_length = 1;
a287 2
	record.c.c_length++;
	db_put( dbip, dp, &record, 0, 1 );
@


8.5
log
@db_diradd had the length and flags parameters backward
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 8.4 89/04/06 20:40:12 phil Locked $ (BRL)";
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 8.3 89/03/06 17:38:05 mike Locked $ (BRL)";
d232 1
a232 1
		dp = db_diradd( dbip, combname, -1, DIR_COMB, 2 );
@


8.3
log
@ansii
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 8.2 88/12/06 01:39:48 mike Locked $ (BRL)";
d37 1
@


8.2
log
@Converted to new db_*() routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/mover.c,v 1.2 88/10/23 13:56:43 mike Exp $ (BRL)";
a37 2

extern int	printf();
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 7.4 88/09/17 02:35:22 reschly Exp $ (BRL)";
d35 1
a36 1
#include "./objdir.h"
d68 1
a68 1
	db_getrec( dp, &record, 0 );
d74 1
a74 1
		db_getrec( dp, &record, 1 );
d86 1
a86 1
		db_putrec( dp, &record, 1 );
d90 1
a90 1
			db_getrec( dp, &record, i );
d97 1
a97 1
			db_putrec( dp, &record, i );
d144 1
a144 1
		db_putrec( dp, &record, 0 );
d158 1
a158 1
			db_getrec( dp, &record, i );
d164 1
a164 1
			db_putrec( dp, &record, i );
d189 1
a189 1
		db_getrec( cdp, &record, i );
d199 1
a199 1
		db_putrec( cdp, &record, i );
d230 1
a230 1
	if( (dp = lookup( combname, LOOKUP_QUIET )) == DIR_NULL )  {
d233 1
a233 1
		dp = dir_add( combname, -1, DIR_COMB, 2 );
d236 1
a236 1
		db_alloc( dp, 2 );
d260 1
a260 1
		db_putrec( dp, &record, 0 );
d263 1
a263 1
		db_getrec( dp, &record, 1);
d270 1
a270 1
		db_putrec( dp, &record, 1 );
d278 1
a278 1
	db_getrec( dp, &record, 0 );
d291 2
a292 2
	db_putrec( dp, &record, 0 );
	db_grow( dp, 1 );
d295 1
a295 1
	db_getrec( dp, &record, dp->d_len-1);
d302 1
a302 1
	db_putrec( dp, &record, dp->d_len-1 );
@


7.4
log
@added stdio include.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 7.3 87/11/05 07:09:00 reschly Locked $ (BRL)";
@


7.3
log
@Changed to use rt_mat_dbmat and rt_dbmat_mat
to convert between database and internal formats.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 7.2 87/11/05 05:06:31 mike Locked $ (BRL)";
d25 1
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 7.1 87/11/03 00:01:31 mike Rel $ (BRL)";
d155 1
a155 1
			static mat_t temp;
d158 5
a162 2
			mat_mul( temp, xlate, record.M.m_mat );
			mat_copy( record.M.m_mat, temp );
d185 1
a185 1
	mat_t temp;			/* Temporary for mat_mul */
d191 2
a192 4
		if( strcmp( dp->d_namep, record.M.m_instname ) == 0 )  {
			/* Apply the Homogeneous Transformation Matrix */
			mat_mul(temp, xlate, record.M.m_mat);
			mat_copy( record.M.m_mat, temp );
d194 6
a199 3
			db_putrec( cdp, &record, i );
			return;
		}
d224 1
d267 2
a268 2
		mat_idn( record.M.m_mat );

a296 1
	mat_idn( record.M.m_mat );
d299 2
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 6.1 87/07/11 08:04:47 mike Rel $ (BRL)";
d31 1
a31 1
#include "./machine.h"	/* special copy */
d61 1
a61 1
	vect_t	work;			/* Working vector */
d63 2
a64 2
	register float *p;		/* -> to vector to be worked on */
	static float *area_end;		/* End of area to be processed */
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 5.1 87/06/24 22:21:41 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 4.2 87/02/13 00:12:40 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 4.1 86/12/29 03:22:28 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.10 86/10/12 03:07:48 mike Exp $ (BRL)";
@


2.10
log
@strings.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.9 86/08/12 06:50:15 mike Locked $ (BRL)";
@


2.9
log
@Changed #includes for CC -I../h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.8 86/03/14 20:42:19 mike Exp $ (BRL)";
d25 6
a30 1
#include	<string.h>
@


2.8
log
@Added support for the new spline format.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.7 86/02/17 17:09:13 mike Exp $ (BRL)";
d27 5
a31 5
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "objdir.h"
#include "solid.h"
@


2.7
log
@Added initialization for c_matname[].
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.6 85/08/07 05:19:25 mike Exp $ (BRL)";
d47 3
d95 2
a96 12
	case ID_B_SPL_HEAD:
		for( i = 1; i < dp->d_len; i++) {
			db_getrec( dp, &record, i);
			if( record.u_id != ID_B_SPL_CTL )
				continue;
			for( p = &record.l.l_pts[0*3];
			     p < &record.l.l_pts[8*3]; p += 3) {
				MAT4X3VEC( work, xlate, p );
				VMOVE( p, work );
			}
			db_putrec( dp, &record, i);
		}
@


2.6
log
@Changed to use common ../h/vmath.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.5 85/05/29 11:59:47 mike Exp $ (BRL)";
d36 1
a36 1
int	item_default = 1000;
d38 2
a39 2
int	mat_default = 1;
int	los_default = 100;
d239 5
a243 1
		record.c.c_material = record.c.c_los = 0;
d249 1
d251 2
a252 3
			record.c.c_los = los_default;
			(void)printf("Creating region id=%d, air=%d, mat=%d, los=%d\n",
				ident, air, mat_default, los_default );
@


2.5
log
@combadd() changed to clear record.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.4 85/05/08 00:31:33 mike Exp $ (BRL)";
d26 2
a27 1
#include "ged_types.h"
a31 1
#include "../h/vmath.h"
@


2.4
log
@KAA added region code defaulting
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.3 85/05/02 20:16:20 mike Exp $ (BRL)";
d255 1
d287 1
@


2.3
log
@Eliminated silly M_brname stuff.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.2 85/03/12 04:06:23 mike Exp $ (BRL)";
d35 6
d245 4
@


2.2
log
@Paul Stay's Spline code
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: mover.c,v 2.1 85/03/11 23:56:39 mike Prod $ (BRL)";
d183 2
a184 3
		/* Check for match, including alias (branch name) */
		if( strcmp( dp->d_namep, record.M.m_instname ) == 0 ||
		    strcmp( dp->d_namep, record.M.m_brname ) == 0 )  {
d203 1
d206 1
a206 1
combadd( objp, combname, elementname, flag, relation, ident, air )
d208 2
a209 2
char *combname, *elementname;
int flag;				/* flag character */
a215 1
	int instf,regf,groupf;          /* instance, region, group flags */
a216 13
	if ( elementname == NULL )
		elementname = "";	/* safety first */

	instf = 1;
	regf = groupf = 0;

	if( flag == 'r' )
		regf = 1;
	if( flag == 'g' )
		groupf = 1;
	if( regf == 1 || groupf == 1 )
		instf = 0;

d235 1
a235 1
		if( regf ) {       /* creating a region */
a246 6
		if( instf )		/* creating an instance */
			/* Insert name of this branch */
			(void)strcpy( record.M.m_brname, elementname );
		else
			record.M.m_brname[0] = '\0';

d265 1
a265 1
	if( regf ) {
a279 6

	if( instf )
		/* Record the name of this branch */
		(void)strcpy( record.M.m_brname, elementname );
	else
		record.M.m_brname[0] = '\0';
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d5 1
a5 1
 *	moveobj		used to update position of an object in objects file
d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a46 2
	static int Nb_strsl;
	static int n;
d55 1
a55 2
	if( record.u_id == ID_ARS_A )  {
		Nb_strsl = record.a.a_totlen;
d57 2
a58 1
		/* 1st b type record  */
d73 3
a75 3
		/* process next (Nb_strcx * NX)-1  records  */
		for(n=2; n<=Nb_strsl; n++)  {
			db_getrec( dp, &record, n );
d78 1
a78 1
					p < &record.b.b_values[8*3]; p += 3) {
d82 1
a82 1
			db_putrec( dp, &record, n );
d84 1
a84 2
		return;
	}
d86 13
a98 1
	if( record.u_id == ID_SOLID )  {
d100 1
d128 1
a128 1
								p += 3) {
d135 2
a136 2
			(void)printf("moveobj:  cant move obj type %d\n",
					record.s.s_type );
d140 1
a140 2
		return;
	}
d142 1
a142 1
	if( record.u_id != ID_COMB )  {
a144 1
	}
d146 6
a151 5
	/*
	 * Move all the references within a combination
	 */
	for( i=1; i < dp->d_len; i++ )  {
		static mat_t temp;
d153 5
a157 4
		db_getrec( dp, &record, i );
		mat_mul( temp, xlate, record.M.m_mat );
		mat_copy( record.M.m_mat, temp );
		db_putrec( dp, &record, i );
d159 1
@


1.3
log
@pre-Keith version
@
text
@d9 11
a19 1
 * The U. S. Army Ballistic Research Laboratory
d21 3
d27 1
a27 1
#include "db.h"
d29 1
a29 1
#include "dir.h"
d31 1
a31 1
#include "vmath.h"
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d14 1
a14 1
#include "3d.h"
@


1.1
log
@Initial revision
@
text
@d210 1
a210 1
	if( (dp = lookup( combname, QUIET )) == DIR_NULL )  {
@
