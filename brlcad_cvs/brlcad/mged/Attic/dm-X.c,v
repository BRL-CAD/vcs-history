head	11.117;
access;
symbols
	ansi-20040405-merged:11.113.2.1
	postmerge-20040405-ansi:11.114
	premerge-20040404-ansi:11.113
	postmerge-autoconf:11.113
	autoconf-freeze:11.113
	premerge-autoconf:11.113
	postmerge-20040315-windows:11.113
	premerge-20040315-windows:11.113
	windows-20040315-freeze:11.113
	autoconf-20031203:11.113
	autoconf-20031202:11.113
	autoconf-branch:11.113.0.10
	phong-branch:11.113.0.8
	photonmap-branch:11.113.0.6
	rel-6-1-DP:11.113
	windows-branch:11.113.0.4
	rel-6-0-2:11.111
	ansi-branch:11.113.0.2
	rel-6-0-1-branch:11.111.0.2
	hartley-6-0-post:11.112
	hartley-6-0-pre:11.111
	rel-6-0-1:11.111
	rel-6-0:11.110
	rel-5-4:11.103.2.2
	offsite-5-3-pre:11.106
	rel-5-3:11.103.2.2
	rel-5-2:11.103.2.1
	rel-5-1-branch:11.103.0.2
	rel-5-1:11.103
	rel-5-0:11.97
	rel-5-0-beta:11.97
	rel-4-5:11.90
	ctj-4-5-post:11.77
	ctj-4-5-pre:11.77
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.117
date	2004.05.21.17.47.39;	author morrison;	state dead;
branches;
next	11.116;

11.116
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.115;

11.115
date	2004.05.10.15.25.28;	author morrison;	state Exp;
branches;
next	11.114;

11.114
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.113;

11.113
date	2002.08.20.17.08.22;	author jra;	state Exp;
branches
	11.113.2.1;
next	11.112;

11.112
date	2002.08.15.20.55.33;	author hartley;	state Exp;
branches;
next	11.111;

11.111
date	2002.07.13.17.49.46;	author jra;	state Exp;
branches;
next	11.110;

11.110
date	2001.08.14.18.34.51;	author bparker;	state Exp;
branches;
next	11.109;

11.109
date	2001.06.18.19.24.23;	author bparker;	state Exp;
branches;
next	11.108;

11.108
date	2001.04.05.19.35.43;	author morrison;	state Exp;
branches;
next	11.107;

11.107
date	2001.04.02.18.10.10;	author jra;	state Exp;
branches;
next	11.106;

11.106
date	2001.02.26.19.09.48;	author bparker;	state Exp;
branches;
next	11.105;

11.105
date	2000.08.31.18.13.02;	author bparker;	state Exp;
branches;
next	11.104;

11.104
date	2000.08.19.03.10.43;	author mike;	state Exp;
branches;
next	11.103;

11.103
date	2000.01.21.15.24.53;	author bparker;	state Exp;
branches
	11.103.2.1;
next	11.102;

11.102
date	99.12.30.20.21.36;	author jra;	state Exp;
branches;
next	11.101;

11.101
date	99.12.27.18.57.53;	author bparker;	state Exp;
branches;
next	11.100;

11.100
date	99.12.17.16.28.12;	author bparker;	state Exp;
branches;
next	11.99;

11.99
date	99.12.01.14.03.36;	author bparker;	state Exp;
branches;
next	11.98;

11.98
date	99.10.22.21.40.33;	author bparker;	state Exp;
branches;
next	11.97;

11.97
date	99.03.09.21.42.24;	author bparker;	state Exp;
branches;
next	11.96;

11.96
date	99.01.12.18.17.59;	author bparker;	state Exp;
branches;
next	11.95;

11.95
date	98.11.06.22.32.38;	author bparker;	state Exp;
branches;
next	11.94;

11.94
date	98.10.21.17.19.46;	author bparker;	state Exp;
branches;
next	11.93;

11.93
date	98.06.11.14.28.09;	author bparker;	state Exp;
branches;
next	11.92;

11.92
date	98.03.19.18.11.48;	author bparker;	state Exp;
branches;
next	11.91;

11.91
date	98.02.26.15.52.54;	author bparker;	state Exp;
branches;
next	11.90;

11.90
date	98.02.06.22.28.35;	author bparker;	state Exp;
branches;
next	11.89;

11.89
date	98.01.28.15.28.21;	author bparker;	state Exp;
branches;
next	11.88;

11.88
date	98.01.16.21.58.31;	author bparker;	state Exp;
branches;
next	11.87;

11.87
date	97.12.23.14.10.24;	author bparker;	state Exp;
branches;
next	11.86;

11.86
date	97.11.14.15.11.51;	author bparker;	state Exp;
branches;
next	11.85;

11.85
date	97.11.06.20.02.44;	author bparker;	state Exp;
branches;
next	11.84;

11.84
date	97.10.27.19.19.14;	author bparker;	state Exp;
branches;
next	11.83;

11.83
date	97.10.10.21.07.37;	author bparker;	state Exp;
branches;
next	11.82;

11.82
date	97.10.10.17.00.45;	author bparker;	state Exp;
branches;
next	11.81;

11.81
date	97.09.08.18.54.17;	author bparker;	state Exp;
branches;
next	11.80;

11.80
date	97.09.03.14.26.06;	author bparker;	state Exp;
branches;
next	11.79;

11.79
date	97.08.01.21.14.24;	author bparker;	state Exp;
branches;
next	11.78;

11.78
date	97.07.25.21.00.10;	author bparker;	state Exp;
branches;
next	11.77;

11.77
date	97.05.22.19.19.22;	author bparker;	state Exp;
branches;
next	11.76;

11.76
date	97.05.21.12.48.50;	author bparker;	state Exp;
branches;
next	11.75;

11.75
date	97.05.08.14.39.56;	author bparker;	state Exp;
branches;
next	11.74;

11.74
date	97.04.01.20.54.33;	author bparker;	state Exp;
branches;
next	11.73;

11.73
date	97.03.20.22.14.58;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	97.03.07.21.38.12;	author bparker;	state Exp;
branches;
next	11.71;

11.71
date	97.03.06.14.06.06;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	97.02.28.21.35.47;	author bparker;	state Exp;
branches;
next	11.69;

11.69
date	97.02.24.22.08.43;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	97.02.07.13.46.37;	author bparker;	state Exp;
branches;
next	11.67;

11.67
date	97.01.29.23.13.32;	author bparker;	state Exp;
branches;
next	11.66;

11.66
date	97.01.17.22.56.57;	author bparker;	state Exp;
branches;
next	11.65;

11.65
date	97.01.02.19.37.38;	author bparker;	state Exp;
branches;
next	11.64;

11.64
date	96.12.11.22.40.57;	author bparker;	state Exp;
branches;
next	11.63;

11.63
date	96.12.10.21.45.18;	author bparker;	state Exp;
branches;
next	11.62;

11.62
date	96.12.09.23.01.26;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	96.12.04.21.11.44;	author bparker;	state Exp;
branches;
next	11.60;

11.60
date	96.11.01.22.10.04;	author bparker;	state Exp;
branches;
next	11.59;

11.59
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	96.10.18.14.05.43;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	96.10.03.20.52.10;	author bparker;	state Exp;
branches;
next	11.56;

11.56
date	96.10.01.17.23.59;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	96.09.30.19.42.58;	author bparker;	state Exp;
branches;
next	11.54;

11.54
date	96.09.26.20.38.22;	author bparker;	state Exp;
branches;
next	11.53;

11.53
date	96.09.25.20.04.58;	author bparker;	state Exp;
branches;
next	11.52;

11.52
date	96.09.23.18.41.43;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	96.09.17.21.21.19;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	96.09.05.20.10.23;	author bparker;	state Exp;
branches;
next	11.49;

11.49
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	96.09.03.15.48.04;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	96.08.29.23.37.36;	author butler;	state Exp;
branches;
next	11.46;

11.46
date	96.08.29.23.10.07;	author butler;	state Exp;
branches;
next	11.45;

11.45
date	96.08.28.19.44.38;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	96.08.14.20.26.41;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	96.08.02.18.08.35;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	96.07.25.17.45.09;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	96.07.19.20.50.18;	author bparker;	state Exp;
branches;
next	11.39;

11.39
date	96.06.21.15.57.06;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	96.06.11.17.05.03;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	96.05.24.18.45.09;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	96.05.16.20.59.26;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	96.03.22.23.00.17;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	96.03.22.18.39.46;	author bparker;	state Exp;
branches;
next	11.30;

11.30
date	96.03.20.22.15.31;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	96.03.08.18.23.07;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	96.03.01.21.36.37;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	96.02.26.21.59.58;	author bparker;	state Exp;
branches;
next	11.26;

11.26
date	96.02.12.21.45.05;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	96.02.09.22.18.23;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	96.01.26.15.52.28;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	96.01.22.22.50.19;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.01.19.22.31.40;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.01.17.22.09.01;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.01.05.22.08.48;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	95.12.11.22.49.46;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	95.12.04.22.00.25;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	95.12.02.00.24.15;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	95.11.30.23.12.29;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	95.11.22.17.20.08;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	95.11.09.22.28.16;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	95.08.24.06.46.36;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.08.24.06.36.50;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.08.17.19.10.10;	author cnuzman;	state Exp;
branches;
next	11.10;

11.10
date	95.07.31.13.08.19;	author gdurf;	state Exp;
branches;
next	11.9;

11.9
date	95.07.20.13.20.10;	author gdurf;	state Exp;
branches;
next	11.8;

11.8
date	95.07.05.21.22.12;	author gdurf;	state Exp;
branches;
next	11.7;

11.7
date	95.06.27.20.08.11;	author gdurf;	state Exp;
branches;
next	11.6;

11.6
date	95.06.22.14.31.41;	author gdurf;	state Exp;
branches;
next	11.5;

11.5
date	95.06.16.21.32.21;	author gdurf;	state Exp;
branches;
next	11.4;

11.4
date	95.06.16.20.30.51;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	95.06.16.19.48.39;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.06.16.19.20.23;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.52;	author mike;	state Rel4_4;
branches;
next	10.24;

10.24
date	94.12.24.01.05.18;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	94.12.23.22.53.09;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	94.12.23.21.57.38;	author gdurf;	state Exp;
branches;
next	10.21;

10.21
date	94.12.22.00.46.53;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	94.12.19.18.00.19;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.12.16.19.36.03;	author gdurf;	state Exp;
branches;
next	10.18;

10.18
date	94.12.13.11.32.59;	author jehunt;	state Exp;
branches;
next	10.17;

10.17
date	94.11.19.03.50.14;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.11.05.03.56.21;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.10.18.13.55.03;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.10.17.23.22.53;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.10.14.17.06.54;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.10.14.16.06.26;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.09.06.16.11.37;	author jra;	state Exp;
branches;
next	10.10;

10.10
date	94.08.10.21.42.46;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.08.09.15.12.41;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.06.01.11.56.26;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.06.01.11.55.24;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	93.10.26.02.38.37;	author butler;	state Exp;
branches;
next	10.5;

10.5
date	93.10.26.02.00.48;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.10.26.01.05.13;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.08.20.16.37.11;	author jra;	state Exp;
branches;
next	10.2;

10.2
date	93.06.22.20.44.15;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.19;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.07.19.01.16.19;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.07.02.04.36.36;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.02.02.00.00.54;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.01.25.12.50.39;	author cjohnson;	state Exp;
branches;
next	9.4;

9.4
date	90.12.07.01.17.20;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.06.07.00.47.19;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.21.11.07.12;	author cjohnson;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.13;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.06.20.39.08;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.03.20.17.05;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.06.10;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.51;	author mike;	state Rel3_0;
branches;
next	1.3;

1.3
date	88.09.17.04.59.57;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	88.09.17.02.24.45;	author reschly;	state Exp;
branches;
next	1.1;

1.1
date	88.04.28.17.10.36;	author phil;	state Exp;
branches;
next	;

11.103.2.1
date	2000.09.01.17.31.46;	author bparker;	state Exp;
branches;
next	11.103.2.2;

11.103.2.2
date	2001.02.26.19.07.37;	author bparker;	state Exp;
branches;
next	;

11.113.2.1
date	2002.09.19.18.02.01;	author morrison;	state Exp;
branches;
next	;


desc
@X Window System Display Manager (X11)
@


11.117
log
@moved to src/mged/
@
text
@/*
 *			D M - X . C
 *
 *  Routines specific to MGED's use of LIBDM's X display manager.
 *
 *  Author -
 *	Robert G. Parker
 *
 *  Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/dm-X.c,v 11.116 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <math.h>
#include "tk.h"
#include <X11/Xutil.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "dm_xvars.h"
#include "dm-X.h"
#include "./ged.h"
#include "./sedit.h"
#include "./mged_dm.h"

extern int _X24_open_existing();	/* defined in libfb/if_ogl.c */
extern int common_dm();			/* defined in dm-generic.c */
extern void dm_var_init(struct dm_list *initial_dm_list);		/* defined in attach.c */

static int X_dm(int argc, char **argv);
static void dirty_hook(void);
static void zclip_hook(void);

#ifdef USE_PROTOTYPES
static Tk_GenericProc X_doevent;
#else
static int X_doevent();
#endif

struct bu_structparse X_vparse[] = {
  {"%f",  1, "bound",		 DM_O(dm_bound),	dirty_hook},
  {"%d",  1, "useBound",	 DM_O(dm_boundFlag),	dirty_hook},
  {"%d",  1, "zclip",		 DM_O(dm_zclip),	zclip_hook},
  {"%d",  1, "debug",		 DM_O(dm_debugLevel),	BU_STRUCTPARSE_FUNC_NULL},
  {"",	  0, (char *)0,		 0,			BU_STRUCTPARSE_FUNC_NULL}
};

int
X_dm_init(struct dm_list	*o_dm_list,
	  int			argc,
	  char			*argv[])
{
	struct bu_vls vls;

	dm_var_init(o_dm_list);

	/* register application provided routines */
	cmd_hook = X_dm;

	Tk_DeleteGenericHandler(doEvent, (ClientData)NULL);
	if ((dmp = dm_open(interp, DM_TYPE_X, argc-1, argv)) == DM_NULL)
		return TCL_ERROR;

	/* keep display manager in sync */
	dmp->dm_perspective = mged_variables->mv_perspective_mode;

	eventHandler = X_doevent;
	Tk_CreateGenericHandler(doEvent, (ClientData)NULL);
	(void)DM_CONFIGURE_WIN(dmp);

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "mged_bind_dm %s", bu_vls_addr(&pathName));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_OK;
}

void
X_fb_open(void)
{
	char *X_name = "/dev/X";

	if ((fbp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL) {
		Tcl_AppendResult(interp, "X_dm_init: failed to allocate framebuffer memory\n",
				 (char *)NULL);
		return;
	}

	*fbp = X24_interface; /* struct copy */
	fbp->if_name = malloc((unsigned)strlen(X_name) + 1);
	(void)strcpy(fbp->if_name, X_name);

	/* Mark OK by filling in magic number */
	fbp->if_magic = FB_MAGIC;

	_X24_open_existing(fbp,
			   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			   ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
			   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
			   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
			   ((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
			   dmp->dm_width, dmp->dm_height,
			   ((struct x_vars *)dmp->dm_vars.priv_vars)->gc);
}

/*
   This routine is being called from doEvent() to handle Expose events.
*/
static int
X_doevent(ClientData	clientData,
	  XEvent	*eventPtr)
{
	if (eventPtr->type == Expose && eventPtr->xexpose.count == 0) {
		dirty = 1;

		/* no further processing of this event */
		return TCL_RETURN;
	}

	/* allow further processing of this event */
	return TCL_OK;
}
	    
static int
X_dm(int	argc,
     char	*argv[])
{
	  if (!strcmp(argv[0], "set")) {
		  struct bu_vls	vls;

		  bu_vls_init(&vls);

		  if (argc < 2) {
			  /* Bare set command, print out current settings */
			  bu_vls_struct_print2(&vls, "dm_X internal variables", X_vparse, (const char *)dmp );
		  } else if (argc == 2) {
			  bu_vls_struct_item_named(&vls, X_vparse, argv[1], (const char *)dmp, ',');
		  } else {
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, "%s=\"", argv[1]);
			  bu_vls_from_argv(&tmp_vls, argc-2, argv+2);
			  bu_vls_putc(&tmp_vls, '\"');
			  bu_struct_parse(&tmp_vls, X_vparse, (char *)dmp);
			  bu_vls_free(&tmp_vls);
		  }

		  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		  bu_vls_free(&vls);

		  return TCL_OK;
	  }

	  return common_dm(argc, argv);
}

static void
dirty_hook(void)
{
	dirty = 1;
}

static void
zclip_hook(void)
{
	view_state->vs_vop->vo_zclip = dmp->dm_zclip;
	dirty_hook();
}
@


11.116
log
@change conf.h to a wrapped config.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/dm-X.c,v 11.115 2004/05/10 15:25:28 morrison Exp $ (BRL)";
@


11.115
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.114 2004/04/05 09:09:11 morrison Exp $ (BRL)";
d20 5
a24 1
#include "conf.h"
@


11.114
log
@merge of ansi-6-0-branch into HEAD
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a62 1
  {"%d",  1, "depthcue",         DM_O(dm_depthcue),	BU_STRUCTPARSE_FUNC_NULL},
@


11.113
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.111 2002/07/13 17:49:46 jra Exp $ (BRL)";
d46 1
a46 1
extern void dm_var_init();		/* defined in attach.c */
d48 3
a50 3
static int X_dm();
static void dirty_hook();
static void zclip_hook();
d99 1
a99 1
X_fb_open()
d179 1
a179 1
dirty_hook()
d185 1
a185 1
zclip_hook()
@


11.113.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.113 2002/08/20 17:08:22 jra Exp $ (BRL)";
d46 1
a46 1
extern void dm_var_init(struct dm_list *initial_dm_list);		/* defined in attach.c */
d48 3
a50 3
static int X_dm(int argc, char **argv);
static void dirty_hook(void);
static void zclip_hook(void);
d99 1
a99 1
X_fb_open(void)
d179 1
a179 1
dirty_hook(void)
d185 1
a185 1
zclip_hook(void)
@


11.112
log
@Converted from K&R to ANSI C - RFH
@
text
@d46 1
a46 1
extern void dm_var_init(struct dm_list *initial_dm_list);		/* defined in attach.c */
d48 3
a50 3
static int X_dm(int argc, char **argv);
static void dirty_hook(void);
static void zclip_hook(void);
d99 1
a99 1
X_fb_open(void)
d179 1
a179 1
dirty_hook(void)
d185 1
a185 1
zclip_hook(void)
@


11.111
log
@Added unused depthcue entry to avoid errors when attempting to do depthcueing under X
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.110 2001/08/14 18:34:51 bparker Exp $ (BRL)";
d46 1
a46 1
extern void dm_var_init();		/* defined in attach.c */
d48 3
a50 3
static int X_dm();
static void dirty_hook();
static void zclip_hook();
d99 1
a99 1
X_fb_open()
d179 1
a179 1
dirty_hook()
d185 1
a185 1
zclip_hook()
@


11.110
log
@*- keep vo_zclip in sync with dm_zclip
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.109 2001/06/18 19:24:23 bparker Exp $ (BRL)";
d63 1
@


11.109
log
@*- remove use of start/stop_catching_output().
   Use routines that write directly to a vls.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.108 2001/04/05 19:35:43 morrison Exp $ (BRL)";
d50 1
d61 1
a61 1
  {"%d",  1, "zclip",		 DM_O(dm_zclip),	dirty_hook},
d181 7
@


11.108
log
@updated SIGNED to signed
updated CONST to const
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.107 2001/04/02 18:10:10 jra Exp $ (BRL)";
d66 3
a68 4
X_dm_init(o_dm_list, argc, argv)
struct dm_list *o_dm_list;
int argc;
char *argv[];
d70 1
a70 1
  struct bu_vls vls;
d72 1
a72 1
  dm_var_init(o_dm_list);
d74 2
a75 2
  /* register application provided routines */
  cmd_hook = X_dm;
d77 3
a79 3
  Tk_DeleteGenericHandler(doEvent, (ClientData)NULL);
  if((dmp = dm_open(interp, DM_TYPE_X, argc-1, argv)) == DM_NULL)
    return TCL_ERROR;
d81 2
a82 2
  /* keep display manager in sync */
  dmp->dm_perspective = mged_variables->mv_perspective_mode;
d84 3
a86 3
  eventHandler = X_doevent;
  Tk_CreateGenericHandler(doEvent, (ClientData)NULL);
  (void)DM_CONFIGURE_WIN(dmp);
d88 4
a91 4
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "mged_bind_dm %s", bu_vls_addr(&pathName));
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d93 1
a93 1
  return TCL_OK;
d99 1
a99 1
  char *X_name = "/dev/X";
d101 21
a121 21
  if ((fbp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL) {
    Tcl_AppendResult(interp, "X_dm_init: failed to allocate framebuffer memory\n",
		     (char *)NULL);
    return;
  }

  *fbp = X24_interface; /* struct copy */
  fbp->if_name = malloc((unsigned)strlen(X_name) + 1);
  (void)strcpy(fbp->if_name, X_name);

  /* Mark OK by filling in magic number */
  fbp->if_magic = FB_MAGIC;

  _X24_open_existing(fbp,
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
		     dmp->dm_width, dmp->dm_height,
		     ((struct x_vars *)dmp->dm_vars.priv_vars)->gc);
d128 2
a129 3
X_doevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
d131 2
a132 2
  if (eventPtr->type == Expose && eventPtr->xexpose.count == 0){
    dirty = 1;
d134 3
a136 3
    /* no further processing of this event */
    return TCL_RETURN;
  }
d138 2
a139 2
  /* allow further processing of this event */
  return TCL_OK;
d143 2
a144 3
X_dm(argc, argv)
int argc;
char *argv[];
d146 2
a147 1
  struct bu_vls	vls;
d149 1
a149 2
  if( !strcmp( argv[0], "set" ) )  {
    struct bu_vls tmp_vls;
d151 15
a165 24
    bu_vls_init(&vls);
    bu_vls_init(&tmp_vls);
    start_catching_output(&tmp_vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      bu_struct_print("dm_X internal variables", X_vparse, (const char *)dmp );
    } else if( argc == 2 ) {
      bu_vls_struct_item_named( &vls, X_vparse, argv[1], (const char *)dmp, ',');
      bu_log( "%s", bu_vls_addr(&vls) );
    } else {
      bu_vls_printf( &vls, "%s=\"", argv[1] );
      bu_vls_from_argv( &vls, argc-2, argv+2 );
      bu_vls_putc( &vls, '\"' );
      bu_struct_parse( &vls, X_vparse, (char *)dmp );
    }

    bu_vls_free(&vls);

    stop_catching_output(&tmp_vls);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
    return TCL_OK;
  }
d167 7
a173 1
  return common_dm(argc, argv);
d179 1
a179 1
  dirty = 1;
@


11.107
log
@Lint
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.106 2001/02/26 19:09:48 bparker Exp $ (BRL)";
d160 1
a160 1
      bu_struct_print("dm_X internal variables", X_vparse, (CONST char *)dmp );
d162 1
a162 1
      bu_vls_struct_item_named( &vls, X_vparse, argv[1], (CONST char *)dmp, ',');
@


11.106
log
@*- mods to _X24_open_existing() to take an extra
   parameter (i.e. cwinp - cursor window's parent) to
   be used when creating a cursor window. This fixes a
   bug when using fbpoint with one of MGED's geometry/fbserv
   windows.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.105 2000/08/31 18:13:02 bparker Exp $ (BRL)";
d25 6
@


11.105
log
@signature for dm_open() changed to include interp
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.104 2000/08/19 03:10:43 mike Exp $ (BRL)";
d112 1
@


11.104
log
@
const RCSid
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.103 2000/01/21 15:24:53 bparker Exp $ (BRL)";
d73 1
a73 1
  if((dmp = dm_open(DM_TYPE_X, argc-1, argv)) == DM_NULL)
@


11.103
log
@*- mods to always have a framebuffer
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.102 1999/12/30 20:21:36 jra Exp $ (BRL)";
@


11.103.2.1
log
@dm_open has new signature (i.e. interp)
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.105 2000/08/31 18:13:02 bparker Exp $ (BRL)";
d73 1
a73 1
  if((dmp = dm_open(interp, DM_TYPE_X, argc-1, argv)) == DM_NULL)
@


11.103.2.2
log
@*- mods to _X24_open_existing() to take an extra
   parameter (i.e. cwinp - cursor window's parent) to
   be used when creating a cursor window.
   This fixes a bug when using fbpoint with one of MGED's
   geometry/fbserv windows
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.103.2.1 2000/09/01 17:31:46 bparker Exp $ (BRL)";
a111 1
		     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
@


11.102
log
@Eliminated some unused variables
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.101 1999/12/27 18:57:53 bparker Exp $ (BRL)";
d38 1
d94 1
a94 21
  int status;
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "fb_open_existing /dev/X %lu %lu %lu %lu %d %d %lu",
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		(unsigned long)((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
		dmp->dm_width, dmp->dm_height,
		(unsigned long)((struct x_vars *)dmp->dm_vars.priv_vars)->gc);
  status = Tcl_Eval(interp, bu_vls_addr(&vls));

  if(status == TCL_OK){
    if(sscanf(interp->result, "%lu", (unsigned long *)&fbp) != 1){
      fbp = (FBIO *)0;   /* sanity */
      Tcl_AppendResult(interp, "X_fb_open: failed to get framebuffer pointer\n",
		       (char *)NULL);
    }
  }else
    Tcl_AppendResult(interp, "X_fb_open: failed to get framebuffer\n", (char *)NULL);
d96 20
a115 1
  bu_vls_free(&vls);
@


11.101
log
@*- use DM_CONFIGURE_WIN
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.100 1999/12/17 16:28:12 bparker Exp $ (BRL)";
a63 1
  int i;
a142 4
  int status;
  char *av[6];
  char xstr[32];
  char ystr[32];
@


11.100
log
@*- perspective is now a member of struct dm
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.99 1999/12/01 14:03:36 bparker Exp $ (BRL)";
d81 1
a81 1
  dm_configureWindowShape(dmp);
@


11.99
log
@*- add display manager variables: bound, useBound
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.98 1999/10/22 21:40:33 bparker Exp $ (BRL)";
d75 3
@


11.98
log
@*- update comments for dm-specific event handling routines
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.97 1999/03/09 21:42:24 bparker Exp $ (BRL)";
d51 5
a55 3
  {"%d",  1, "zclip",             X_MV_O(zclip),            dirty_hook },
  {"%d",  1, "debug",             X_MV_O(debug),            BU_STRUCTPARSE_FUNC_NULL },
  {"",    0, (char *)0,           0,                        BU_STRUCTPARSE_FUNC_NULL }
a75 1
  zclip_ptr = &((struct x_vars *)dmp->dm_vars.priv_vars)->mvars.zclip;
d155 1
a155 1
      bu_struct_print("dm_X internal variables", X_vparse, (CONST char *)&((struct x_vars *)dmp->dm_vars.priv_vars)->mvars );
d157 1
a157 1
      bu_vls_struct_item_named( &vls, X_vparse, argv[1], (CONST char *)&((struct x_vars *)dmp->dm_vars.priv_vars)->mvars, ',');
d163 1
a163 1
      bu_struct_parse( &vls, X_vparse, (char *)&((struct x_vars *)dmp->dm_vars.priv_vars)->mvars );
@


11.97
log
@*- modified display manager specific dm command to return single
	values without a newline.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.96 1999/01/12 18:17:59 bparker Exp $ (BRL)";
d116 1
a116 6
   This routine is being called from doEvent().
   It does not handle mouse button or key events. The key
   events are being processed via the TCL/TK bind command or are being
   piped to ged.c/stdin_input(). Eventually, I'd also like to have the
   dials+buttons bindable. That would leave this routine to handle only
   events like Expose and ConfigureNotify.
@


11.96
log
@*- some cleanup
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.95 1998/11/06 22:32:38 bparker Exp $ (BRL)";
d162 1
a162 1
      bu_log( "%s\n", bu_vls_addr(&vls) );
@


11.95
log
@*- use new structures
*- cleanup
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.94 1998/10/21 17:19:46 bparker Exp $ (BRL)";
a82 16

#if 0
  /*XXX Experimenting */
  bu_vls_printf(&name_vls, "dm_info(%s)", bu_vls_addr(&dmp->dm_pathName));
  bu_vls_printf(&value_vls, "%lu %lu %lu %lu %d %d %lu",
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		(unsigned long)((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip,
		dmp->dm_width, dmp->dm_height,
		(unsigned long)((struct x_vars *)dmp->dm_vars.priv_vars)->gc);
  Tcl_SetVar(interp, bu_vls_addr(&name_vls), bu_vls_addr(&value_vls), TCL_GLOBAL_ONLY);
#endif

  /* initialize the background color */
  cs_set_bg();
@


11.94
log
@*- add call to cs_set_bg() to set the background color
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-X.c,v 11.93 1998/06/11 14:28:09 bparker Exp $ (BRL)";
d65 2
a69 1
  dm_var_init(o_dm_list);
a75 1
  curr_dm_list->s_info->opp = &pathName;
@


11.93
log
@*- remove the following ifdefs:
	USE_FRAMEBUFFER, DO_SNAP_TO_GRID, DO_RUBBER_BAND, USE_RT_ASPECT
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/CVS/brlcad/mged/dm-X.c,v 11.92 1998/03/19 18:11:48 bparker Exp $ (BRL)";
d38 2
a39 1
extern int common_dm();				/* defined in dm-generic.c */
a40 4
extern void X24_configureWindow();

extern void dm_var_init();

d96 3
@


11.92
log
@call init script after return from dm_open()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.91 1998/02/26 15:52:54 bparker Exp bparker $ (BRL)";
a39 1
#ifdef USE_FRAMEBUFFER
a40 1
#endif
a102 1
#ifdef USE_FRAMEBUFFER
a129 1
#endif
@


11.91
log
@*- using new dm_vars structure
*- using code common to display managers that connect to an X server
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.90 1998/02/06 22:28:35 bparker Exp bparker $ (BRL)";
d68 1
a68 2
  char **av;
  struct bu_vls name_vls, value_vls;
a72 12
  /* stuff in a default initialization script */
  av = (char **)bu_malloc(sizeof(char *)*(argc + 2), "X_dm_init: av");
  av[0] = "X_open";
  av[1] = "-i";
  av[2] = "mged_bind_dm";

  /* copy the rest except last */
  for(i = 1; i < argc-1; ++i)
    av[i+2] = argv[i];

  av[i+2] = (char *)NULL;

d75 1
a75 2
  if((dmp = dm_open(DM_TYPE_X, argc+1, av)) == DM_NULL){
    bu_free(av, "X_dm_init: av");
a76 1
  }
a77 1
  bu_free(av, "X_dm_init: av");
d84 6
a89 2
  bu_vls_init(&value_vls);
#if 1
a90 1
  bu_vls_init(&name_vls);
a99 2
  bu_vls_free(&name_vls);
  bu_vls_free(&value_vls);
@


11.90
log
@using grid_snap in X_dm()
@
text
@d4 1
a4 2
 *  An X Window System interface for MGED.
 *  X11R2.  Color support is yet to be implemented.
d7 2
a8 2
 *	Phillip Dykstra
 *  
d10 2
a11 2
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
d13 1
a13 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
d15 1
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.89 1998/01/28 15:28:21 bparker Exp bparker $ (BRL)";
a22 13
#include <sys/time.h>		/* for struct timeval */
#include <X11/X.h>
#if 0
#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif
#endif
#if defined(linux)
#	undef   X_NOT_STDC_ENV
#	undef   X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
a23 2
#include <X11/extensions/XI.h>
#include <X11/extensions/XInput.h>
a24 8
#include <X11/keysym.h>
#if IR_KNOBS
#include <gl/device.h>
#endif
#if 0
#include <X11/extensions/Xext.h>
#include <X11/extensions/multibuf.h>
#endif
d32 2
d35 1
a36 2
#include "./sedit.h"
#include "dm-X.h"
d38 1
a38 3
#ifdef DO_SNAP_TO_GRID
extern void snap_to_grid();
#endif
d44 1
a44 4
#ifdef DO_RUBBER_BAND
extern void rt_rect_area(); /* from rect.c */
extern void zoom_rect_area();
#endif
d46 2
a47 9
extern void dm_var_init();
extern void mged_print_result();
extern point_t e_axes_pos;
extern point_t curr_e_axes_pos;

static void	X_statechange();
static int     X_dm();
static void     dirty_hook();
static void     set_knob_offset();
a54 4
extern int dm_pipe[];
extern Tcl_Interp *interp;
extern Tk_Window tkwin;

a60 43
#if IR_KNOBS
void X_dbtext();
#endif

#ifdef IR_BUTTONS
/*
 * Map SGI Button numbers to MGED button functions.
 * The layout of this table is suggestive of the actual button box layout.
 */
#define SW_HELP_KEY	SW0
#define SW_ZERO_KEY	SW3
#define HELP_KEY	0
#define ZERO_KNOBS	0
static unsigned char bmap[IR_BUTTONS] = {
	HELP_KEY,    BV_ADCURSOR, BV_RESET,    ZERO_KNOBS,
	BE_O_SCALE,  BE_O_XSCALE, BE_O_YSCALE, BE_O_ZSCALE, 0,           BV_VSAVE,
	BE_O_X,      BE_O_Y,      BE_O_XY,     BE_O_ROTATE, 0,           BV_VRESTORE,
	BE_S_TRANS,  BE_S_ROTATE, BE_S_SCALE,  BE_MENU,     BE_O_ILLUMINATE, BE_S_ILLUMINATE,
	BE_REJECT,   BV_BOTTOM,   BV_TOP,      BV_REAR,     BV_45_45,    BE_ACCEPT,
	BV_RIGHT,    BV_FRONT,    BV_LEFT,     BV_35_25
};
#endif

#ifdef IR_KNOBS
/*
 *  Labels for knobs in help mode.
 */
static char	*kn1_knobs[] = {
	/* 0 */ "adc <1",	/* 1 */ "zoom", 
	/* 2 */ "adc <2",	/* 3 */ "adc dist",
	/* 4 */ "adc y",	/* 5 */ "y slew",
	/* 6 */ "adc x",	/* 7 */	"x slew"
};
static char	*kn2_knobs[] = {
	/* 0 */ "unused",	/* 1 */	"zoom",
	/* 2 */ "z rot",	/* 3 */ "z slew",
	/* 4 */ "y rot",	/* 5 */ "y slew",
	/* 6 */ "x rot",	/* 7 */	"x slew"
};
#endif

static int XdoMotion = 0;

a72 1
  state_hook = X_statechange;
d94 1
a94 1
  zclip_ptr = &((struct x_vars *)dmp->dm_vars)->mvars.zclip;
d106 4
a109 4
		(unsigned long)((struct x_vars *)dmp->dm_vars)->dpy,
		(unsigned long)((struct x_vars *)dmp->dm_vars)->win,
		(unsigned long)((struct x_vars *)dmp->dm_vars)->cmap,
		(unsigned long)((struct x_vars *)dmp->dm_vars)->vip,
d111 1
a111 1
		(unsigned long)((struct x_vars *)dmp->dm_vars)->gc);
d129 4
a132 4
		(unsigned long)((struct x_vars *)dmp->dm_vars)->dpy,
		(unsigned long)((struct x_vars *)dmp->dm_vars)->pix,
		(unsigned long)((struct x_vars *)dmp->dm_vars)->cmap,
		(unsigned long)((struct x_vars *)dmp->dm_vars)->vip,
d134 1
a134 1
		(unsigned long)((struct x_vars *)dmp->dm_vars)->gc);
a162 26
  static int button0  = 0;   /* State of button 0 */
  static int knob_values[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  struct bu_vls cmd;
  int save_edflag = -1;

  if(mged_variables->send_key && eventPtr->type == KeyPress){
    char buffer[2];
    KeySym keysym;
    struct dm_char_queue *dcqp;

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  &keysym, (XComposeStatus *)NULL);

    if(keysym == mged_variables->hot_key)
      return TCL_OK;

    BU_GETSTRUCT(dcqp, dm_char_queue);
    dcqp->dlp = curr_dm_list;
    BU_LIST_PUSH(&head_dm_char_queue.l, &dcqp->l);
    write(dm_pipe[1], buffer, 1);

    /* Use this so that these events won't propagate */
    return TCL_RETURN;
  }

  bu_vls_init(&cmd);
d166 2
a167 1227
    goto handled;
  }else if(eventPtr->type == ConfigureNotify){
    XConfigureEvent *conf = (XConfigureEvent *)eventPtr;

    dm_configureWindowShape(dmp);
    dirty = 1;

#ifdef USE_FRAMEBUFFER
    if(fbp)
      X24_configureWindow(fbp, conf->width, conf->height);
#endif

    goto handled;
  } else if( eventPtr->type == MapNotify ){
    mapped = 1;

    goto handled;
  } else if( eventPtr->type == UnmapNotify ){
    mapped = 0;

    goto handled;
  } else if( eventPtr->type == MotionNotify ) {
    int mx, my;
    int dx, dy;
    fastf_t f;
    fastf_t fx, fy;
    fastf_t td;

    mx = eventPtr->xmotion.x;
    my = eventPtr->xmotion.y;
    dx = mx - ((struct x_vars *)dmp->dm_vars)->omx;
    dy = my - ((struct x_vars *)dmp->dm_vars)->omy;

    switch(am_mode){
    case AMM_IDLE:
#if 1
      if(scroll_active)
#else
      if(scroll_active && eventPtr->xmotion.state & ((struct x_vars *)dmp->dm_vars)->mb_mask)
#endif
	bu_vls_printf( &cmd, "M 1 %d %d\n",
		       (int)(dm_Xx2Normal(dmp, mx, 0) * 2047.0),
		       (int)(dm_Xy2Normal(dmp, my) * 2047.0) );
#ifdef DO_RUBBER_BAND
#if 1
      else if(rubber_band_active){
#else
      else if(rubber_band_active && eventPtr->xmotion.state & ((struct x_vars *)dmp->dm_vars)->mb_mask){
#endif
	fastf_t x = dm_Xx2Normal(dmp, mx, 1);
	fastf_t y = dm_Xy2Normal(dmp, my);

	rect_width = x - rect_x;
	rect_height = y - rect_y;

	dirty = 1;
      }
#endif
      else if(XdoMotion)
	/* trackball not active so do the regular thing */
	/* Constant tracking (e.g. illuminate mode) bound to M mouse */
	bu_vls_printf( &cmd, "M 0 %d %d\n",
		       (int)(dm_Xx2Normal(dmp, mx, 1) * 2047.0),
		       (int)(dm_Xy2Normal(dmp, my) * 2047.0) );
      else
	goto handled;

      break;
    case AMM_ROT:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	char save_coords;

	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	if(mged_variables->rateknobs)
	  bu_vls_printf(&cmd, "knob -i x %lf y %lf\n",
			dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
			dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
	else
	  bu_vls_printf(&cmd, "knob -i ax %lf ay %lf\n",
			dy * 0.25, dx * 0.25);

	(void)Tcl_Eval(interp, bu_vls_addr(&cmd));

	mged_variables->coords = save_coords;
	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct x_vars *)dmp->dm_vars)->omx = mx;
	((struct x_vars *)dmp->dm_vars)->omy = my;

	goto handled;
      }

      if(mged_variables->rateknobs)
	bu_vls_printf(&cmd, "knob -i -v x %lf y %lf\n",
		      dy / (fastf_t)dmp->dm_height * RATE_ROT_FACTOR * 2.0,
		      dx / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0);
      else
	bu_vls_printf(&cmd, "knob -i -v ax %lf ay %lf\n",
		      dy * 0.25, dx * 0.25);

      break;
    case AMM_TRAN:
      fx = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      fy = -dy / (fastf_t)dmp->dm_height * 2.0;
      
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	char save_coords;

	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';

	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_TRAN)
	    es_edflag = STRANS;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}

	if(mged_variables->rateknobs)
	  bu_vls_printf(&cmd, "knob -i X %lf Y %lf\n", fx, fy);
	else
	  bu_vls_printf(&cmd, "knob -i aX %lf aY %lf\n",
			fx*Viewscale*base2local, fy*Viewscale*base2local);

	(void)Tcl_Eval(interp, bu_vls_addr(&cmd));

	mged_variables->coords = save_coords;
	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct x_vars *)dmp->dm_vars)->omx = mx;
	((struct x_vars *)dmp->dm_vars)->omy = my;

	goto handled;
      }

      /* otherwise, drag to translate the view */
      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i -v X %lf Y %lf\n", fx, fy );
      else
	bu_vls_printf( &cmd, "knob -i -v aX %lf aY %lf\n",
		       fx*Viewscale*base2local, fy*Viewscale*base2local );

      break;
    case AMM_SCALE:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_SCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_ADC_ANG1:
      fx = dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc;
      bu_vls_printf(&cmd, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));

      break;
    case AMM_ADC_ANG2:
      fx = dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc;
      bu_vls_printf(&cmd, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));

      break;
    case AMM_ADC_TRAN:
      bu_vls_printf(&cmd, "adc hv %lf %lf\n",
		    dm_Xx2Normal(dmp, mx, 1) * Viewscale * base2local,
		    dm_Xy2Normal(dmp, my) * Viewscale * base2local);

      break;
    case AMM_ADC_DIST:
      fx = (dm_Xx2Normal(dmp, mx, 1) * 2047.0 - dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Xy2Normal(dmp, my) * 2047.0 - dv_yadc) * Viewscale * base2local / 2047.0;
      td = sqrt(fx * fx + fy * fy);
      bu_vls_printf(&cmd, "adc dst %lf\n", td);

      break;
    case AMM_CON_ROT_X:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i x %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i ax %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct x_vars *)dmp->dm_vars)->omx = mx;
	((struct x_vars *)dmp->dm_vars)->omy = my;

	goto handled;
      }

      break;
    case AMM_CON_ROT_Y:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i y %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i ay %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct x_vars *)dmp->dm_vars)->omx = mx;
	((struct x_vars *)dmp->dm_vars)->omy = my;

	goto handled;
      }

      break;
    case AMM_CON_ROT_Z:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i z %f\n",
		       f / (fastf_t)dmp->dm_width * RATE_ROT_FACTOR * 2.0 );
      else
	bu_vls_printf( &cmd, "knob -i az %f\n", f * 0.25 );

      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT){
	  save_edflag = es_edflag;
	  if(!SEDIT_ROTATE)
	    es_edflag = SROT;
	}else{
	  save_edflag = edobj;
	  edobj = BE_O_ROTATE;
	}

	Tcl_Eval(interp, bu_vls_addr(&cmd));

	if(state == ST_S_EDIT)
	  es_edflag = save_edflag;
	else
	  edobj = save_edflag;

	((struct x_vars *)dmp->dm_vars)->omx = mx;
	((struct x_vars *)dmp->dm_vars)->omy = my;

	goto handled;
      }

      break;
    case AMM_CON_TRAN_X:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_X;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i X %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aX %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_TRAN_Y:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_Y;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i Y %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aY %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_TRAN_Z:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_TRAN){
	  save_edflag = es_edflag;
	  es_edflag = STRANS;
	}else if(state == ST_O_EDIT && !OEDIT_TRAN){
	  save_edflag = edobj;
	  edobj = BE_O_XY;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx / (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0;
      else
	f = -dy / (fastf_t)dmp->dm_height * 2.0;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i Z %f\n", f);
      else
	bu_vls_printf( &cmd, "knob -i aZ %f\n", f*Viewscale*base2local);

      break;
    case AMM_CON_SCALE_X:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_XSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_SCALE_Y:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_YSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_SCALE_Z:
      if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	 mged_variables->transform == 'e'){
	if(state == ST_S_EDIT && !SEDIT_SCALE){
	  save_edflag = es_edflag;
	  es_edflag = SSCALE;
	}else if(state == ST_O_EDIT && !OEDIT_SCALE){
	  save_edflag = edobj;
	  edobj = BE_O_ZSCALE;
	}
      }

      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      if(mged_variables->rateknobs)
	bu_vls_printf( &cmd, "knob -i S %f\n", f / (fastf_t)dmp->dm_height );
      else
	bu_vls_printf( &cmd, "knob -i aS %f\n", f / (fastf_t)dmp->dm_height );

      break;
    case AMM_CON_XADC:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i xadc %f\n",
		     f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0 );
      break;
    case AMM_CON_YADC:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i yadc %f\n",
		     f / (fastf_t)dmp->dm_height * 4095.0 );

      break;
    case AMM_CON_ANG1:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i ang1 %f\n",
		     f / (fastf_t)dmp->dm_width * 90.0 );

      break;
    case AMM_CON_ANG2:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i ang2 %f\n",
		     f / (fastf_t)dmp->dm_width * 90.0 );

      break;
    case AMM_CON_DIST:
      if(abs(dx) >= abs(dy))
	f = dx;
      else
	f = -dy;

      bu_vls_printf( &cmd, "knob -i distadc %f\n",
		     f / (fastf_t)dmp->dm_width / dmp->dm_aspect * 4095.0 );

      break;
    }

    ((struct x_vars *)dmp->dm_vars)->omx = mx;
    ((struct x_vars *)dmp->dm_vars)->omy = my;
  }
#if IR_KNOBS
  else if( eventPtr->type == ((struct x_vars *)dmp->dm_vars)->devmotionnotify ){
    XDeviceMotionEvent *M;
    int setting;
    fastf_t f;

    M = (XDeviceMotionEvent * ) eventPtr;

    if(button0){
      X_dbtext(
		(mged_variables->adcflag ? kn1_knobs:kn2_knobs)[M->first_axis]);
      goto handled;
    }

    switch(DIAL0 + M->first_axis){
    case DIAL0:
      if(mged_variables->adcflag) {
	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_1adc )
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_1adc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob ang1 %f\n",
		       45.0 - 45.0*((double)setting)/2047.0);
      }else{
	if(mged_variables->rateknobs){
	  f = rate_model_rotate[Z];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	       M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob -m z %f\n", setting / 512.0 );
	}else{
	  f = absolute_model_rotate[Z];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob -m az %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL1:
      if(mged_variables->rateknobs){
	if(EDIT_SCALE && mged_variables->transform == 'e')
	  f = edit_rate_scale;
	else
	  f = rate_scale;

	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob S %f\n", setting / 512.0 );
      }else{
	if(EDIT_SCALE && mged_variables->transform == 'e')
	  f = edit_absolute_scale;
	else
	  f = absolute_scale;

	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob aS %f\n", setting / 512.0 );
      }
      break;
    case DIAL2:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_2adc )
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_2adc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob ang2 %f\n",
		       45.0 - 45.0*((double)setting)/2047.0);
      }else {
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_rate_model_rotate[Z];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[Z];
	  else
	    f = rate_rotate[Z];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob z %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_absolute_model_rotate[Z];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[Z];
	  else
	    f = absolute_rotate[Z];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob az %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL3:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_distadc)
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_distadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob distadc %d\n", setting );
      }else {
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	    case 'o':
	      f = edit_rate_model_tran[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_tran[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_tran[Z];
	  else
	    f = rate_tran[Z];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob Z %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	    case 'o':
	      f = edit_absolute_model_tran[Z];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_tran[Z];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_tran[Z];
	  else
	    f = absolute_tran[Z];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf(&cmd, "knob aZ %f\n", setting / 512.0 * Viewscale * base2local);
	}
      }
      break;
    case DIAL4:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_yadc)
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_yadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob yadc %d\n", setting );
      }else{
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_rate_model_rotate[Y];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[Y];
	  else
	    f = rate_rotate[Y];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob y %f\n", setting / 512.0 );
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_absolute_model_rotate[Y];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[Y];
	  else
	    f = absolute_rotate[Y];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob ay %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL5:
      if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	    case 'o':
	      f = edit_rate_model_tran[Y];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_tran[Y];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_TRAN){
	      save_edflag = es_edflag;
	      es_edflag = STRANS;
	    }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	      save_edflag = edobj;
	      edobj = BE_O_XY;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_tran[Y];
	  else
	    f = rate_tran[Y];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob Y %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
	  case 'm':
	  case 'o':
	    f = edit_absolute_model_tran[Y];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_tran[Y];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_tran[Y];
	else
	  f = absolute_tran[Y];

	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] -
	    knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf(&cmd, "knob aY %f\n", setting / 512.0 * Viewscale * base2local);
      }
      break;
    case DIAL6:
      if(mged_variables->adcflag){
	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !dv_xadc)
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit(dv_xadc) + M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob xadc %d\n", setting );
      }else{
	if(mged_variables->rateknobs){
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_rate_model_rotate[X];
	      break;
	    case 'o':
	      f = edit_rate_object_rotate[X];
	      break;
	    case 'v':
	    default:
	      f = edit_rate_view_rotate[X];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = rate_model_rotate[X];
	  else
	    f = rate_rotate[X];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(512.5 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	  bu_vls_printf( &cmd, "knob x %f\n", setting / 512.0);
	}else{
	  if((state == ST_S_EDIT || state == ST_O_EDIT)
	     && mged_variables->transform == 'e'){
	    switch(mged_variables->coords){
	    case 'm':
	      f = edit_absolute_model_rotate[X];
	      break;
	    case 'o':
	      f = edit_absolute_object_rotate[X];
	      break;
	    case 'v':
	    default:
	      f = edit_absolute_view_rotate[X];
	      break;
	    }

	    if(state == ST_S_EDIT && !SEDIT_ROTATE){
	      save_edflag = es_edflag;
	      es_edflag = SROT;
	    }else if(state == ST_O_EDIT && !OEDIT_ROTATE){
	      save_edflag = edobj;
	      edobj = BE_O_ROTATE;
	    }
	  }else if(mged_variables->coords == 'm')
	    f = absolute_model_rotate[X];
	  else
	    f = absolute_rotate[X];

	  if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	     ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	     !f )
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	      M->axis_data[0] - knob_values[M->first_axis];
	  else
	    ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	      dm_unlimit((int)(2.847 * f)) +
	      M->axis_data[0] - knob_values[M->first_axis];

	  f = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]) / 512.0;
	  bu_vls_printf( &cmd, "knob ax %f\n", dm_wrap(f) * 180.0);
	}
      }
      break;
    case DIAL7:
      if(mged_variables->rateknobs){
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
	  case 'm':
	  case 'o':
	    f = edit_rate_model_tran[X];
	    break;
	  case 'v':
	  default:
	    f = edit_rate_view_tran[X];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = rate_model_tran[X];
	else
	  f = rate_tran[X];

	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf( &cmd, "knob X %f\n", setting / 512.0 );
      }else{
	if((state == ST_S_EDIT || state == ST_O_EDIT)
	   && mged_variables->transform == 'e'){
	  switch(mged_variables->coords){
	  case 'm':
	  case 'o':
	    f = edit_absolute_model_tran[X];
	    break;
	  case 'v':
	  default:
	    f = edit_absolute_view_tran[X];
	    break;
	  }

	  if(state == ST_S_EDIT && !SEDIT_TRAN){
	    save_edflag = es_edflag;
	    es_edflag = STRANS;
	  }else if(state == ST_O_EDIT && !OEDIT_TRAN){
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }
	}else if(mged_variables->coords == 'm')
	  f = absolute_model_tran[X];
	else
	  f = absolute_tran[X];

	if(-NOISE <= ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] &&
	   ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] <= NOISE &&
	   !f )
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] +=
	    M->axis_data[0] - knob_values[M->first_axis];
	else
	  ((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis] =
	    dm_unlimit((int)(512.5 * f)) +
	    M->axis_data[0] - knob_values[M->first_axis];

	setting = dm_limit(((struct x_vars *)dmp->dm_vars)->knobs[M->first_axis]);
	bu_vls_printf(&cmd, "knob aX %f\n", setting / 512.0 * Viewscale * base2local);
      }
      break;
    default:
      break;
    }

    /* Keep track of the knob values */
    knob_values[M->first_axis] = M->axis_data[0];
  }
#endif
#if IR_BUTTONS
  else if( eventPtr->type == ((struct x_vars *)dmp->dm_vars)->devbuttonpress ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1){
      button0 = 1;
      goto handled;
    }

    if(button0){
      X_dbtext(label_button(bmap[B->button - 1]));
    }else if(B->button == 4){
      bu_vls_strcat(&cmd, "knob zero\n");
      set_knob_offset();
    }else
      bu_vls_printf(&cmd, "press %s\n",
		    label_button(bmap[B->button - 1]));
  }else if( eventPtr->type == ((struct x_vars *)dmp->dm_vars)->devbuttonrelease ){
    XDeviceButtonEvent *B;

    B = (XDeviceButtonEvent * ) eventPtr;

    if(B->button == 1)
      button0 = 0;

    goto handled;
  }
#endif
  else if(eventPtr->type == KeyPress){
    /*XXX Hack to prevent Tk from choking on certain control sequences */
    if(eventPtr->xkey.state & ControlMask){
      char buffer[1];
      KeySym keysym;

      XLookupString(&(eventPtr->xkey), buffer, 1,
		    &keysym, (XComposeStatus *)NULL);

      if(keysym == XK_c || keysym == XK_t || keysym == XK_v ||
	 keysym == XK_w || keysym == XK_x || keysym == XK_y)
	goto handled;
    }

    /* let other KeyPress events get processed by Tcl/Tk */
    goto not_handled;
  }else{
    /* allow all other events to be handled by Tcl/Tk */
    goto not_handled;
  }

  (void)Tcl_Eval(interp, bu_vls_addr(&cmd));

  if(save_edflag != -1){
    if(SEDIT_TRAN || SEDIT_ROTATE || SEDIT_SCALE)
      es_edflag = save_edflag;
    else if(OEDIT_TRAN || OEDIT_ROTATE || OEDIT_SCALE)
      edobj = save_edflag;
d170 1
a170 10
handled:
  bu_vls_free(&cmd);

  /* event handled here; prevent someone else from handling the event */
  return TCL_RETURN;

not_handled:
  bu_vls_free(&cmd);

  /* let someone else handle the event */
a173 36
static void
X_statechange( a, b )
int	a, b;
{
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( b )  {
	case ST_VIEW:
	    /* constant tracking OFF */
	    XdoMotion = 0;
	    break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	case ST_S_VPICK:
	    /* constant tracking ON */
	    XdoMotion = 1;
	    break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	    /* constant tracking OFF */
	    XdoMotion = 0;
	    break;
	default:
	  Tcl_AppendResult(interp, "X_statechange: unknown state ",
			   state_str[b], "\n", (char *)NULL);
	  break;
	}

	/*X_viewchange( DM_CHGV_REDO, SOLID_NULL );*/
	++dmaflag;
}

d194 1
a194 1
      bu_struct_print("dm_X internal variables", X_vparse, (CONST char *)&((struct x_vars *)dmp->dm_vars)->mvars );
d196 1
a196 1
      bu_vls_struct_item_named( &vls, X_vparse, argv[1], (CONST char *)&((struct x_vars *)dmp->dm_vars)->mvars, ',');
d202 1
a202 1
      bu_struct_parse( &vls, X_vparse, (char *)&((struct x_vars *)dmp->dm_vars)->mvars );
d213 1
a213 477
  if(!strcmp(argv[0], "idle")){
    am_mode = AMM_IDLE;
    scroll_active = 0;
#ifdef DO_RUBBER_BAND
    if(rubber_band_active){
      rubber_band_active = 0;
      dirty = 1;

      if(mged_variables->mouse_behavior == 'r')
	rt_rect_area();
      else if(mged_variables->mouse_behavior == 'z')
	zoom_rect_area();
    }
#endif    

    return TCL_OK;
  }

  if( !strcmp( argv[0], "m" )){
    if( argc < 4){
      Tcl_AppendResult(interp, "dm m: need more parameters\n",
		       "dm m button xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    /* This assumes a 3-button mouse */
    switch(*argv[1]){
    case '1':
      ((struct x_vars *)dmp->dm_vars)->mb_mask = Button1Mask;
      break;
    case '2':
      ((struct x_vars *)dmp->dm_vars)->mb_mask = Button2Mask;
      break;
    case '3':
      ((struct x_vars *)dmp->dm_vars)->mb_mask = Button3Mask;
      break;
    default:
      Tcl_AppendResult(interp, "dm m: bad button value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    {
      int x;
      int y;
      int old_orig_gui;
      int stolen = 0;
      fastf_t fx, fy;

      old_orig_gui = mged_variables->orig_gui;

      fx = dm_Xx2Normal(dmp, atoi(argv[2]), 0);
      fy = dm_Xy2Normal(dmp, atoi(argv[3]));
      x = fx * 2047.0;
      y = fy * 2047.0;

      if(mged_variables->faceplate &&
	 mged_variables->orig_gui){
#define        MENUXLIM        (-1250)

#if 0
	if(scroll_active){
	  stolen = 1;
	  goto end;
	}
#endif

	if(x >= MENUXLIM && scroll_select( x, y, 0 )){
	  stolen = 1;
	  goto end;
	}

	if(x < MENUXLIM && mmenu_select( y, 0)){
	  stolen = 1;
	  goto end;
	}
      }

      mged_variables->orig_gui = 0;
      fx = dm_Xx2Normal(dmp, atoi(argv[2]), 1);
      x = fx * 2047.0;

end:
      bu_vls_init(&vls);
      if(mged_variables->mouse_behavior == 'q' && !stolen){
	point_t view_pt;
	point_t model_pt;

	VSET(view_pt, fx, fy, 1.0);
	MAT4X3PNT(model_pt, view2model, view_pt);
	VSCALE(model_pt, model_pt, base2local);
	if(*zclip_ptr)
	  bu_vls_printf(&vls, "nirt %lf %lf %lf",
			model_pt[X], model_pt[Y], model_pt[Z]);
	else
	  bu_vls_printf(&vls, "nirt -b %lf %lf %lf",
			model_pt[X], model_pt[Y], model_pt[Z]);
#ifdef DO_RUBBER_BAND
      }else if((mged_variables->mouse_behavior == 'p' ||
		mged_variables->mouse_behavior == 'r' ||
		mged_variables->mouse_behavior == 'z') && !stolen){
	rubber_band_active = 1;
	rect_x = fx;
	rect_y = fy;
	rect_width = 0.0;
	rect_height = 0.0;

	dirty = 1;
#endif
#ifdef DO_SNAP_TO_GRID
      }else if(mged_variables->grid_snap && !stolen &&
	       state != ST_S_PICK && state != ST_O_PICK &&
	       state != ST_O_PATH && !SEDIT_PICK){
	point_t view_pt;
	point_t model_pt;

	snap_to_grid(&fx, &fy);

	if((state == ST_S_EDIT || state == ST_O_EDIT) &&
	   mged_variables->transform == 'e'){
	  char save_coords;
	  int save_edflag = -1;

	  save_coords = mged_variables->coords;
	  mged_variables->coords = 'v';

	  if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_TRAN)
	      es_edflag = STRANS;
	  }else{
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	  }

	  MAT4X3PNT(view_pt, model2view, curr_e_axes_pos);
	  view_pt[X] = fx;
	  view_pt[Y] = fy;
	  MAT4X3PNT(model_pt, view2model, view_pt);
	  VSCALE(model_pt, model_pt, base2local);
	  bu_vls_printf(&vls, "p %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));

	  mged_variables->coords = save_coords;
	  if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	  else
	    edobj = save_edflag;

	  mged_variables->orig_gui = old_orig_gui;
	  bu_vls_free(&vls);
	  return status;
	}else{
	  point_t vcenter;

	  MAT_DELTAS_GET_NEG(vcenter, toViewcenter);
	  MAT4X3PNT(view_pt, model2view, vcenter);
	  view_pt[X] = fx;
	  view_pt[Y] = fy;
	  MAT4X3PNT(model_pt, view2model, view_pt);
	  VSCALE(model_pt, model_pt, base2local);
	  bu_vls_printf(&vls, "center %lf %lf %lf", model_pt[X], model_pt[Y], model_pt[Z]);
	}
#endif
      }else
	bu_vls_printf(&vls, "M 1 %d %d\n", x, y);

      status = Tcl_Eval(interp, bu_vls_addr(&vls));
      mged_variables->orig_gui = old_orig_gui;
      bu_vls_free(&vls);

      return status;
    }
  }

  if(!strcmp(argv[0], "am")){
#if 0
    scroll_active = 0;
#endif

    if( argc < 4){
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "dm am <r|t|s> xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct x_vars *)dmp->dm_vars)->omx = atoi(argv[2]);
    ((struct x_vars *)dmp->dm_vars)->omy = atoi(argv[3]);

    switch(*argv[1]){
    case 'r':
      am_mode = AMM_ROT;
      break;
    case 't':
      am_mode = AMM_TRAN;

      if(EDIT_TRAN && mged_variables->transform == 'e'){
	char save_coords;
	point_t mouse_view_pos;
	point_t ea_view_pos;
	point_t diff;

	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';

	MAT4X3PNT(ea_view_pos, model2view, e_axes_pos);
	mouse_view_pos[X] = dm_Xx2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1);
	mouse_view_pos[Y] = dm_Xy2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy);
	mouse_view_pos[Z] = ea_view_pos[Z];
	VSUB2(diff, mouse_view_pos, ea_view_pos);
	VSCALE(diff, diff, Viewscale * base2local);

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob aX %lf aY %lf\n", diff[X], diff[Y]);
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	mged_variables->coords = save_coords;
      }

      break;
    case 's':
      if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	 NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	acc_sc_sol = 1.0;
      else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	edit_absolute_scale = acc_sc_obj - 1.0;
	if(edit_absolute_scale > 0.0)
	  edit_absolute_scale /= 3.0;
      }

      am_mode = AMM_SCALE;
      break;
    default:
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "dm am <r|t|s> xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "adc")){
    fastf_t fx, fy;
    fastf_t td; /* tick distance */
#if 0
    scroll_active = 0;
#endif

    if(argc < 4){
      Tcl_AppendResult(interp, "dm adc: need more parameters\n",
		       "dm adc 1|2|t|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct x_vars *)dmp->dm_vars)->omx = atoi(argv[2]);
    ((struct x_vars *)dmp->dm_vars)->omy = atoi(argv[3]);

    switch(*argv[1]){
    case '1':
      fx = dm_Xx2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_ANG1;
      break;
    case '2':
      fx = dm_Xx2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Xy2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_ANG2;
      break;
    case 't':
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc hv %lf %lf\n",
		    dm_Xx2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) *
		    Viewscale * base2local,
		    dm_Xy2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) *
		    Viewscale * base2local);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_TRAN;
      break;
    case 'd':
      fx = (dm_Xx2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
	    dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Xy2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 -
	    dv_yadc) * Viewscale * base2local / 2047.0;

      td = sqrt(fx * fx + fy * fy);
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "adc dst %lf\n", td);
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      am_mode = AMM_ADC_DIST;
      break;
    default:
      Tcl_AppendResult(interp, "dm adc: unrecognized parameter - ", argv[1],
		       "\ndm adc 1|2|t|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if(!strcmp(argv[0], "con")){
#if 0
    scroll_active = 0;
#endif

    if(argc < 5){
      Tcl_AppendResult(interp, "dm con: need more parameters\n",
		       "dm con r|t|s x|y|z xpos ypos\n",
		       "dm con a x|y|1|2|d xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    ((struct x_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct x_vars *)dmp->dm_vars)->omy = atoi(argv[4]);

    switch(*argv[1]){
    case 'a':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_XADC;
	break;
      case 'y':
	am_mode = AMM_CON_YADC;
	break;
      case '1':
	am_mode = AMM_CON_ANG1;
	break;
      case '2':
	am_mode = AMM_CON_ANG2;
	break;
      case 'd':
	am_mode = AMM_CON_DIST;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con a x|y|1|2|d xpos ypos\n", (char *)NULL);
      }
      break;
    case 'r':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_ROT_X;
	break;
      case 'y':
	am_mode = AMM_CON_ROT_Y;
	break;
      case 'z':
	am_mode = AMM_CON_ROT_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    case 't':
      switch(*argv[2]){
      case 'x':
	am_mode = AMM_CON_TRAN_X;
	break;
      case 'y':
	am_mode = AMM_CON_TRAN_Y;
	break;
      case 'z':
	am_mode = AMM_CON_TRAN_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
      break;
    case 's':
      switch(*argv[2]){
      case 'x':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[0] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_X;
	break;
      case 'y':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[1] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_Y;
	break;
      case 'z':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc[2] - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}

	am_mode = AMM_CON_SCALE_Z;
	break;
      default:
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }

      break;
    default:
      Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[1],
		       "\ndm con r|t|s x|y|z xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    return TCL_OK;
  }

  if( !strcmp( argv[0], "size" )){
    int width, height;

    /* get the window size */
    if( argc == 1 ){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "%d %d", dmp->dm_width, dmp->dm_height);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);

      return TCL_OK;
    }

    /* set the window size */
    if( argc == 3 ){
      width = atoi( argv[1] );
      height = atoi( argv[2] );

      Tk_GeometryRequest(((struct x_vars *)dmp->dm_vars)->xtkwin, width, height);

      return TCL_OK;
    }

    Tcl_AppendResult(interp, "Usage: dm size [width height]\n", (char *)NULL);
    return TCL_ERROR;
  }

  Tcl_AppendResult(interp, "dm: bad command - ", argv[0], "\n", (char *)NULL);
  return TCL_ERROR;
}

#if IR_KNOBS
void
X_dbtext(str)
{
  Tcl_AppendResult(interp, "dm-X: You pressed Help key and '",
		   str, "'\n", (char *)NULL);
a214 1
#endif
a220 10

static void
set_knob_offset()
{
  int i;

  for(i = 0; i < 8; ++i)
    ((struct x_vars *)dmp->dm_vars)->knobs[i] = 0;
}

@


11.89
log
@*- added X_fb_open()
*- now using coords instead of ecoords
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.88 1998/01/16 21:58:31 bparker Exp bparker $ (BRL)";
d63 4
d79 1
d1701 55
@


11.88
log
@*- mods to use/implement MGED's new rubber band capability
*- mods to use MGED's new framebuffer capability
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.87 1997/12/23 14:10:24 bparker Exp bparker $ (BRL)";
a180 31
#ifdef USE_FRAMEBUFFER
  {
    int status;
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "fb_open_existing /dev/X %lu %lu %lu %lu %d %d %lu",
		  (unsigned long)((struct x_vars *)dmp->dm_vars)->dpy,
		  (unsigned long)((struct x_vars *)dmp->dm_vars)->pix,
		  (unsigned long)((struct x_vars *)dmp->dm_vars)->cmap,
		  (unsigned long)((struct x_vars *)dmp->dm_vars)->vip,
		  dmp->dm_width, dmp->dm_height,
		  (unsigned long)((struct x_vars *)dmp->dm_vars)->gc);
    status = Tcl_Eval(interp, bu_vls_addr(&vls));

    if(status == TCL_OK){
      if(sscanf(interp->result, "%lu", (unsigned long *)&fbp) != 1){
	fbp = (FBIO *)0;   /* sanity */
	Tcl_AppendResult(interp, "X_dm_init: failed to get framebuffer pointer\n",
			 (char *)NULL);
      }else
	bu_vls_printf(&value_vls, "%s ", interp->result);
    }else{
      Tcl_AppendResult(interp, "X_dm_init: failed to get framebuffer\n",
		       (char *)NULL);
    }

    bu_vls_free(&vls);
  }
#endif

d200 30
d280 2
a281 1
    X24_configureWindow(fbp, conf->width, conf->height);
d343 1
a343 1
	char save_ecoords;
d345 2
a346 2
	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';
d367 1
a367 1
	mged_variables->ecoords = save_ecoords;
d394 1
a394 1
	char save_ecoords;
d396 2
a397 2
	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';
d416 1
a416 1
	mged_variables->ecoords = save_ecoords;
d907 1
a907 1
	    switch(mged_variables->ecoords){
d947 1
a947 1
	    switch(mged_variables->ecoords){
d1004 1
a1004 1
	    switch(mged_variables->ecoords){
d1042 1
a1042 1
	    switch(mged_variables->ecoords){
d1097 1
a1097 1
	    switch(mged_variables->ecoords){
d1137 1
a1137 1
	    switch(mged_variables->ecoords){
d1181 1
a1181 1
	    switch(mged_variables->ecoords){
d1219 1
a1219 1
	  switch(mged_variables->ecoords){
d1274 1
a1274 1
	    switch(mged_variables->ecoords){
d1314 1
a1314 1
	    switch(mged_variables->ecoords){
d1358 1
a1358 1
	  switch(mged_variables->ecoords){
d1396 1
a1396 1
	  switch(mged_variables->ecoords){
d1730 1
a1730 1
	char save_ecoords;
d1735 2
a1736 2
	save_ecoords = mged_variables->ecoords;
	mged_variables->ecoords = 'v';
d1749 1
a1749 1
	mged_variables->ecoords = save_ecoords;
@


11.87
log
@call nirt from X_dm()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.86 1997/11/14 15:11:51 bparker Exp bparker $ (BRL)";
a58 1
#include "./mged_solid.h"
d63 9
d148 1
d180 48
d275 2
d280 4
d307 3
d311 1
d313 17
a329 2
		       (int)(dm_X2Normal(dmp, mx, 0) * 2047.0),
		       (int)(dm_Y2Normal(dmp, my) * 2047.0) );
d334 2
a335 2
		       (int)(dm_X2Normal(dmp, mx, 1) * 2047.0),
		       (int)(dm_Y2Normal(dmp, my) * 2047.0) );
d460 2
a461 2
      fx = dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc;
d466 2
a467 2
      fx = dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc;
d473 2
a474 2
		    dm_X2Normal(dmp, mx, 1) * Viewscale * base2local,
		    dm_Y2Normal(dmp, my) * Viewscale * base2local);
d478 2
a479 2
      fx = (dm_X2Normal(dmp, mx, 1) * 2047.0 - dv_xadc) * Viewscale * base2local / 2047.0;
      fy = (dm_Y2Normal(dmp, my) * 2047.0 - dv_yadc) * Viewscale * base2local / 2047.0;
d1591 13
a1607 2
    scroll_active = 0;

d1635 1
d1639 4
a1642 2
      x = dm_X2Normal(dmp, atoi(argv[2]), 0) * 2047.0;
      y = dm_Y2Normal(dmp, atoi(argv[3])) * 2047.0;
d1647 2
d1653 1
d1667 2
a1668 1
      x = dm_X2Normal(dmp, atoi(argv[2]), 1) * 2047.0;
d1672 1
a1672 1
      if(mged_variables->mouse_nirt && !stolen){
a1674 1
	fastf_t sf = 1.0/2047.0;
d1676 1
a1676 2
	VSET(view_pt, x, y, 2047.0);
	VSCALE(view_pt, view_pt, sf);
d1685 12
d1709 1
d1711 1
d1739 2
a1740 2
	mouse_view_pos[X] = dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1);
	mouse_view_pos[Y] = dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy);
d1777 1
a1777 1

d1779 1
d1792 2
a1793 2
      fx = dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
d1802 2
a1803 2
      fx = dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
      fy = dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
d1814 1
a1814 1
		    dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) *
d1816 1
a1816 1
		    dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) *
d1824 1
a1824 1
      fx = (dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
d1826 1
a1826 1
      fy = (dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 -
d1847 1
d1849 1
@


11.86
log
@*- move perspective stuff to set.c
*- mods to reflect changes in LIBDM
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.85 1997/11/06 20:02:44 bparker Exp bparker $ (BRL)";
d165 1
d195 1
d203 3
d1541 1
d1551 4
a1554 2
	if(scroll_active)
	   goto end;
d1556 2
a1557 1
	if(x >= MENUXLIM && scroll_select( x, y, 0 ))
d1559 1
d1561 2
a1562 1
	if(x < MENUXLIM && mmenu_select( y, 0))
d1564 1
d1572 18
a1589 1
      bu_vls_printf(&vls, "M 1 %d %d\n", x, y);
d1913 1
@


11.85
log
@*- use new mged variable: ecoords
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.84 1997/10/27 19:19:14 bparker Exp bparker $ (BRL)";
a69 2
static void     establish_perspective();
static void     set_perspective();
a84 2
  {"%d",  1, "perspective",       X_MV_O(perspective_mode), establish_perspective },
  {"%d",  1, "set_perspective",   X_MV_O(dummy_perspective),set_perspective },
d168 1
a168 1
  X_configure_window_shape(dmp);
d213 1
a213 1
    X_configure_window_shape(dmp);
a1858 14
}

static void
establish_perspective()
{
  X_establish_perspective(dmp);
  ++dmaflag;
}

static void
set_perspective()
{
  X_set_perspective(dmp);
  ++dmaflag;
@


11.84
log
@mods to X_dm()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.83 1997/10/10 21:07:37 bparker Exp bparker $ (BRL)";
d260 1
a260 1
	char save_coords;
d262 2
a263 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d284 1
a284 1
	mged_variables->coords = save_coords;
d311 1
a311 1
	char save_coords;
d313 2
a314 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d333 1
a333 1
	mged_variables->coords = save_coords;
d824 1
a824 1
	    switch(mged_variables->coords){
d864 1
a864 1
	    switch(mged_variables->coords){
d921 1
a921 1
	    switch(mged_variables->coords){
d959 1
a959 1
	    switch(mged_variables->coords){
d1014 1
a1014 1
	    switch(mged_variables->coords){
d1054 1
a1054 1
	    switch(mged_variables->coords){
d1098 1
a1098 1
	    switch(mged_variables->coords){
d1136 1
a1136 1
	  switch(mged_variables->coords){
d1191 1
a1191 1
	    switch(mged_variables->coords){
d1231 1
a1231 1
	    switch(mged_variables->coords){
d1275 1
a1275 1
	  switch(mged_variables->coords){
d1313 1
a1313 1
	  switch(mged_variables->coords){
d1593 1
a1593 1
	char save_coords;
d1598 2
a1599 2
	save_coords = mged_variables->coords;
	mged_variables->coords = 'v';
d1612 1
a1612 1
	mged_variables->coords = save_coords;
@


11.83
log
@mods to support zclipping
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.82 1997/10/10 17:00:45 bparker Exp bparker $ (BRL)";
d1506 5
d1514 1
a1514 1
    if( argc < 5){
d1516 1
a1516 1
		       "dm m button 1|0 xpos ypos\n", (char *)NULL);
d1543 2
a1544 2
      x = dm_X2Normal(dmp, atoi(argv[3]), 0) * 2047.0;
      y = dm_Y2Normal(dmp, atoi(argv[4])) * 2047.0;
d1547 1
a1547 2
	 mged_variables->orig_gui &&
	 *argv[2] == '1'){
d1560 1
a1560 1
      x = dm_X2Normal(dmp, atoi(argv[3]), 1) * 2047.0;
d1564 1
a1564 1
      bu_vls_printf(&vls, "M %s %d %d\n", argv[2], x, y);
a1573 2
    int buttonpress;

d1576 1
a1576 1
    if( argc < 5){
d1578 1
a1578 1
		       "dm am <r|t|s> 1|0 xpos ypos\n", (char *)NULL);
d1582 15
a1596 3
    buttonpress = atoi(argv[2]);
    ((struct x_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct x_vars *)dmp->dm_vars)->omy = atoi(argv[4]);
d1598 2
a1599 7
    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	am_mode = AMM_ROT;
	break;
      case 't':
	am_mode = AMM_TRAN;
d1601 6
a1606 24
	if(EDIT_TRAN && mged_variables->transform == 'e'){
	  char save_coords;
	  point_t mouse_view_pos;
	  point_t ea_view_pos;
	  point_t diff;

	  save_coords = mged_variables->coords;
	  mged_variables->coords = 'v';

	  MAT4X3PNT(ea_view_pos, model2view, e_axes_pos);
	  mouse_view_pos[X] = (((struct x_vars *)dmp->dm_vars)->omx /
			       (fastf_t)dmp->dm_width - 0.5) / dmp->dm_aspect * 2.0;
	  mouse_view_pos[Y] = (0.5 - ((struct x_vars *)dmp->dm_vars)->omy /
			       (fastf_t)dmp->dm_height) * 2.0;
	  mouse_view_pos[Z] = ea_view_pos[Z];
	  VSUB2(diff, mouse_view_pos, ea_view_pos);
	  VSCALE(diff, diff, Viewscale * base2local);

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "knob aX %lf aY %lf\n", diff[X], diff[Y]);
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  mged_variables->coords = save_coords;
	}
d1608 6
a1613 10
	break;
      case 's':
	if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	   NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	  acc_sc_sol = 1.0;
	else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	  edit_absolute_scale = acc_sc_obj - 1.0;
	  if(edit_absolute_scale > 0.0)
	    edit_absolute_scale /= 3.0;
	}
d1615 9
a1623 6
	am_mode = AMM_SCALE;
	break;
      default:
	Tcl_AppendResult(interp, "dm am: need more parameters\n",
			 "dm am <r|t|s> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
d1626 6
a1631 1
      return TCL_OK;
a1633 1
    am_mode = AMM_IDLE;
a1637 1
    int buttonpress;
d1643 1
a1643 1
    if(argc < 5){
d1645 1
a1645 1
		       "dm adc 1|2|t|d 1|0 xpos ypos\n", (char *)NULL);
d1649 2
a1650 3
    buttonpress = atoi(argv[2]);
    ((struct x_vars *)dmp->dm_vars)->omx = atoi(argv[3]);
    ((struct x_vars *)dmp->dm_vars)->omy = atoi(argv[4]);
d1652 8
a1659 9
    if(buttonpress){
      switch(*argv[1]){
      case '1':
	fx = dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
	fy = dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc a1 %lf\n", DEGRAD*atan2(fy, fx));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1661 9
a1669 9
	am_mode = AMM_ADC_ANG1;
	break;
      case '2':
	fx = dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 - dv_xadc;
	fy = dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 - dv_yadc;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc a2 %lf\n", DEGRAD*atan2(fy, fx));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1671 11
a1681 11
	am_mode = AMM_ADC_ANG2;
	break;
      case 't':
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc hv %lf %lf\n",
		      dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) *
		      Viewscale * base2local,
		      dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) *
		      Viewscale * base2local);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1683 7
a1689 7
	am_mode = AMM_ADC_TRAN;
	break;
      case 'd':
	fx = (dm_X2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omx, 1) * 2047.0 -
	      dv_xadc) * Viewscale * base2local / 2047.0;
	fy = (dm_Y2Normal(dmp, ((struct x_vars *)dmp->dm_vars)->omy) * 2047.0 -
	      dv_yadc) * Viewscale * base2local / 2047.0;
d1691 5
a1695 5
	td = sqrt(fx * fx + fy * fy);
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "adc dst %lf\n", td);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d1697 6
a1702 9
	am_mode = AMM_ADC_DIST;
	break;
      default:
	Tcl_AppendResult(interp, "dm adc: unrecognized parameter - ", argv[1],
			  "\ndm adc 1|2|t|d 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }

      return TCL_OK;
a1704 1
    am_mode = AMM_IDLE;
a1708 2
    int buttonpress;

d1711 1
a1711 1
    if(argc < 6){
d1713 2
a1714 2
		       "dm con r|t|s x|y|z 1|0 xpos ypos\n",
		       "dm con a x|y|1|2|d 1|0 xpos ypos\n", (char *)NULL);
d1718 70
a1787 26
    buttonpress = atoi(argv[3]);
    ((struct x_vars *)dmp->dm_vars)->omx = atoi(argv[4]);
    ((struct x_vars *)dmp->dm_vars)->omy = atoi(argv[5]);

    if(buttonpress){
      switch(*argv[1]){
      case 'a':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_XADC;
	  break;
	case 'y':
	  am_mode = AMM_CON_YADC;
	  break;
	case '1':
	  am_mode = AMM_CON_ANG1;
	  break;
	case '2':
	  am_mode = AMM_CON_ANG2;
	  break;
	case 'd':
	  am_mode = AMM_CON_DIST;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			   "\ndm con a x|y|1|2|d 1|0 xpos ypos\n", (char *)NULL);
d1789 2
d1792 8
a1799 15
      case 'r':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_ROT_X;
	  break;
	case 'y':
	  am_mode = AMM_CON_ROT_Y;
	  break;
	case 'z':
	  am_mode = AMM_CON_ROT_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
d1801 2
d1804 8
a1811 15
      case 't':
	switch(*argv[2]){
	case 'x':
	  am_mode = AMM_CON_TRAN_X;
	  break;
	case 'y':
	  am_mode = AMM_CON_TRAN_Y;
	  break;
	case 'z':
	  am_mode = AMM_CON_TRAN_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
a1812 36
	break;
      case 's':
	switch(*argv[2]){
	case 'x':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[0] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }

	  am_mode = AMM_CON_SCALE_X;
	  break;
	case 'y':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[1] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }

	  am_mode = AMM_CON_SCALE_Y;
	  break;
	case 'z':
	  if(state == ST_S_EDIT && mged_variables->transform == 'e' &&
	     NEAR_ZERO(acc_sc_sol, (fastf_t)SMALL_FASTF))
	    acc_sc_sol = 1.0;
	  else if(state == ST_O_EDIT && mged_variables->transform == 'e'){
	    edit_absolute_scale = acc_sc[2] - 1.0;
	    if(edit_absolute_scale > 0.0)
	      edit_absolute_scale /= 3.0;
	  }
d1814 1
a1814 7
	  am_mode = AMM_CON_SCALE_Z;
	  break;
	default:
	  Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[2],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
	  return TCL_ERROR;
	}
d1817 2
a1818 2
	Tcl_AppendResult(interp, "dm con: unrecognized parameter - ", argv[1],
			 "\ndm con r|t|s x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1822 5
a1826 1
      return TCL_OK;
a1828 1
    am_mode = AMM_IDLE;
d1835 10
a1844 3
    if( argc < 3 ){
      Tcl_AppendResult(interp, "Usage: dm size width height\n", (char *)NULL);
      return TCL_ERROR;
d1847 4
a1850 2
    width = atoi( argv[1] );
    height = atoi( argv[2] );
d1852 1
a1852 1
    Tk_GeometryRequest(((struct x_vars *)dmp->dm_vars)->xtkwin, width, height);
d1854 5
a1858 1
    return TCL_OK;
@


11.82
log
@*- mods to X_doevent including support for dials+buttons
*- mods to support using only one registered event handler within MGED
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.81 1997/09/08 18:54:17 bparker Exp bparker $ (BRL)";
d72 1
d86 1
d1894 6
@


11.81
log
@mged_variables is now a pointer.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.80 1997/09/03 14:26:06 bparker Exp bparker $ (BRL)";
d28 1
d33 1
d40 2
d43 5
d50 1
a50 1
#include <X11/keysym.h>
d91 41
d160 2
a161 2
  Tk_DeleteGenericHandler(X_doevent, (ClientData)DM_TYPE_X);
  if((dmp = dm_open(DM_TYPE_X, DM_EVENT_HANDLER_NULL, argc+1, av)) == DM_NULL){
d167 1
a167 1
  dmp->dm_eventHandler = X_doevent;
d169 1
a169 1
  Tk_CreateGenericHandler(X_doevent, (ClientData)DM_TYPE_X);
d175 8
d188 2
a189 5
  KeySym key;
  char keybuf[4];
  int cnt;
  XComposeStatus compose_stat;
  XWindowAttributes xwa;
a190 3
  struct x_vars *p;
  register struct dm_list *save_dm_list;
  int status = TCL_OK;
a192 12
  GET_DM(p, x_vars, eventPtr->xany.window, &head_x_vars.l);
  if(p == (struct x_vars *)NULL || eventPtr->type == DestroyNotify)
    return TCL_OK;

  bu_vls_init(&cmd);
  save_dm_list = curr_dm_list;

  GET_DM_LIST(curr_dm_list, x_vars, eventPtr->xany.window);

  if(curr_dm_list == DM_LIST_NULL)
    goto end;

d201 1
a201 1
      goto end;
a204 3
    bu_vls_free(&cmd);
    curr_dm_list = save_dm_list;

d209 1
d212 2
a213 1
    goto end;
d216 1
d218 1
a218 2
    dirty = 1;
    goto end;
d221 2
a222 1
    goto end;
d225 2
a226 1
    goto end;
d252 1
a252 1
	goto end;
d290 2
a291 1
	goto end;
d339 2
a340 1
	goto end;
d431 2
a432 1
	goto end;
d468 2
a469 1
	goto end;
d505 2
a506 1
	goto end;
d701 686
a1386 1
  } else {
d1388 1
a1388 1
    if(eventPtr->type == KeyPress && eventPtr->xkey.state & ControlMask){
d1396 2
a1397 5
	 keysym == XK_w || keysym == XK_x || keysym == XK_y){
	curr_dm_list = save_dm_list;

	return TCL_RETURN;
      }
d1400 5
a1404 7
#if 0
    XGetWindowAttributes( ((struct x_vars *)dmp->dm_vars)->dpy,
			  ((struct x_vars *)dmp->dm_vars)->win, &xwa);
    dmp->dm_height = xwa.height;
    dmp->dm_width = xwa.width;
#endif
    goto end;
d1407 2
a1408 1
  status = Tcl_Eval(interp, bu_vls_addr(&cmd));
d1415 8
a1422 1
end:
a1423 1
  curr_dm_list = save_dm_list;
d1425 2
a1426 1
  return status;
d1882 18
@


11.80
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.79 1997/08/01 21:14:24 bparker Exp bparker $ (BRL)";
d153 1
a153 1
  if(mged_variables.send_key && eventPtr->type == KeyPress){
d160 1
a160 1
    if(keysym == mged_variables.hot_key)
d216 1
a216 1
	 mged_variables.transform == 'e'){
d219 2
a220 2
	save_coords = mged_variables.coords;
	mged_variables.coords = 'v';
d231 1
a231 1
	if(mged_variables.rateknobs)
d241 1
a241 1
	mged_variables.coords = save_coords;
d252 1
a252 1
      if(mged_variables.rateknobs)
d266 1
a266 1
	 mged_variables.transform == 'e'){
d269 2
a270 2
	save_coords = mged_variables.coords;
	mged_variables.coords = 'v';
d281 1
a281 1
	if(mged_variables.rateknobs)
d289 1
a289 1
	mged_variables.coords = save_coords;
d301 1
a301 1
      if(mged_variables.rateknobs)
d310 1
a310 1
	 mged_variables.transform == 'e'){
d325 1
a325 1
      if(mged_variables.rateknobs)
d362 1
a362 1
      if(mged_variables.rateknobs)
d369 1
a369 1
	 mged_variables.transform == 'e'){
d398 1
a398 1
      if(mged_variables.rateknobs)
d405 1
a405 1
	 mged_variables.transform == 'e'){
d434 1
a434 1
      if(mged_variables.rateknobs)
d441 1
a441 1
	 mged_variables.transform == 'e'){
d466 1
a466 1
	 mged_variables.transform == 'e'){
d481 1
a481 1
      if(mged_variables.rateknobs)
d489 1
a489 1
	 mged_variables.transform == 'e'){
d504 1
a504 1
      if(mged_variables.rateknobs)
d512 1
a512 1
	 mged_variables.transform == 'e'){
d527 1
a527 1
      if(mged_variables.rateknobs)
d535 1
a535 1
	 mged_variables.transform == 'e'){
d550 1
a550 1
      if(mged_variables.rateknobs)
d558 1
a558 1
	 mged_variables.transform == 'e'){
d573 1
a573 1
      if(mged_variables.rateknobs)
d581 1
a581 1
	 mged_variables.transform == 'e'){
d596 1
a596 1
      if(mged_variables.rateknobs)
d800 1
a800 1
      old_orig_gui = mged_variables.orig_gui;
d805 2
a806 2
      if(mged_variables.faceplate &&
	 mged_variables.orig_gui &&
d819 1
a819 1
      mged_variables.orig_gui = 0;
d826 1
a826 1
      mged_variables.orig_gui = old_orig_gui;
d856 1
a856 1
	if(EDIT_TRAN && mged_variables.transform == 'e'){
d862 2
a863 2
	  save_coords = mged_variables.coords;
	  mged_variables.coords = 'v';
d878 1
a878 1
	  mged_variables.coords = save_coords;
d883 1
a883 1
	if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d886 1
a886 1
	else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1062 1
a1062 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1065 1
a1065 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1074 1
a1074 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1077 1
a1077 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
d1086 1
a1086 1
	  if(state == ST_S_EDIT && mged_variables.transform == 'e' &&
d1089 1
a1089 1
	  else if(state == ST_O_EDIT && mged_variables.transform == 'e'){
@


11.79
log
@merge UI stuff from dm-ogl
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.78 1997/07/25 21:00:10 bparker Exp bparker $ (BRL)";
d202 2
a203 1
		       dm_X2Normal(dmp, mx, 0) * 2047.0, dm_Y2Normal(dmp, my) * 2047.0 );
d208 2
a209 1
		       dm_X2Normal(dmp, mx, 1) * 2047.0, dm_Y2Normal(dmp, my) * 2047.0 );
@


11.78
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.77 1997/05/22 19:19:22 bparker Exp bparker $ (BRL)";
d25 1
d57 1
d139 1
d145 1
d147 1
d154 1
a154 1
    char buffer[1];
d164 2
d188 4
a192 1
    bu_vls_init(&cmd);
d195 2
d201 2
a202 1
	bu_vls_printf( &cmd, "M 1 %d %d\n", Xx_TO_GED(dmp, mx), Xy_TO_GED(dmp, my));
d207 1
a207 2
		       (int)(Xx_TO_GED(dmp, mx) / dmp->dm_aspect),
		       Xy_TO_GED(dmp, my));
d213 45
a257 3
       bu_vls_printf( &cmd, "knob -i ax %f ay %f\n",
		      (my - ((struct x_vars *)dmp->dm_vars)->omy) * 0.25,
		      (mx - ((struct x_vars *)dmp->dm_vars)->omx) * 0.25 );
d260 24
a283 7
      if(EDIT_TRAN && mged_variables.transform == 'e'){
	point_t view_pos;
	view_pos[X] = (mx/(fastf_t)dmp->dm_width - 0.5) /
	              dmp->dm_aspect * 2.0;
	view_pos[Y] = (0.5 - my/
		       (fastf_t)dmp->dm_height) * 2.0;
	view_pos[Z] = 0.0;
d285 3
d289 1
a289 1
	  sedit_mouse(view_pos);
d291 1
a291 1
	  objedit_mouse(view_pos);
d293 2
d296 8
a303 2
      }else{
	fastf_t fx, fy;
d305 11
a315 6
	fx = (mx - ((struct x_vars *)dmp->dm_vars)->omx) /
	  (fastf_t)dmp->dm_width /
	  dmp->dm_aspect * 2.0;
	fy = (((struct x_vars *)dmp->dm_vars)->omy - my) /
	  (fastf_t)dmp->dm_height * 2.0;
	bu_vls_printf( &cmd, "knob -i aX %f aY %f\n", fx, fy );
d318 28
d347 6
a352 4
    case AMM_SCALE:
      bu_vls_printf( &cmd, "knob -i aS %f\n",
		     (((struct x_vars *)dmp->dm_vars)->omy - my)/
		     (fastf_t)dmp->dm_height);
d355 34
a388 2
      bu_vls_printf( &cmd, "knob -i ax %f\n",
		     (mx - ((struct x_vars *)dmp->dm_vars)->omx) * 0.25 );
d391 34
a424 2
      bu_vls_printf( &cmd, "knob -i ay %f\n",
		     (mx - ((struct x_vars *)dmp->dm_vars)->omx) * 0.25 );
d427 34
a460 2
      bu_vls_printf( &cmd, "knob -i az %f\n",
		     (mx - ((struct x_vars *)dmp->dm_vars)->omx) * 0.25 );
d463 21
a483 3
      bu_vls_printf( &cmd, "knob -i aX %f\n",
		     (mx - ((struct x_vars *)dmp->dm_vars)->omx) /
		     (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0 );
d486 21
a506 3
      bu_vls_printf( &cmd, "knob -i aY %f\n",
		     (mx - ((struct x_vars *)dmp->dm_vars)->omx) /
		     (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0 );
d509 139
a647 3
      bu_vls_printf( &cmd, "knob -i aZ %f\n",
		     (mx - ((struct x_vars *)dmp->dm_vars)->omx) /
		     (fastf_t)dmp->dm_width / dmp->dm_aspect * 2.0 );
d680 7
a687 1
end:
d734 1
a734 1
  struct bu_vls   vls;
d740 1
a740 1
  if( !strcmp( argv[0], "set" )){
d749 1
a749 2
      bu_struct_print("dm_X internal variables", X_vparse,
		     (CONST char *)&((struct x_vars *)dmp->dm_vars)->mvars );
d751 1
a751 2
      bu_vls_struct_item_named( &vls, X_vparse, argv[1],
			 (CONST char *)&((struct x_vars *)dmp->dm_vars)->mvars, ',');
d757 1
a757 1
      bu_struct_parse( &vls, X_vparse, (char *)&((struct x_vars *)dmp->dm_vars)->mvars);
d768 1
a768 1
  if( !strcmp( argv[0], "m")){
a798 2
      x = Xx_TO_GED(dmp, atoi(argv[3]));
      y = Xy_TO_GED(dmp, atoi(argv[4]));
d800 3
d808 1
a808 1
	  goto end;
a816 1
      x = (int)(x / dmp->dm_aspect);
d818 2
d822 1
a822 1
      bu_vls_printf(&vls, "M %s %d %d", argv[2], x, y);
d835 1
a835 1
    
d838 1
a838 1
		       "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d855 76
a930 1
	  point_t view_pos;
d932 9
a940 5
	  view_pos[X] = (((struct x_vars *)dmp->dm_vars)->omx /
			(fastf_t)dmp->dm_width - 0.5) / dmp->dm_aspect * 2.0; 
	  view_pos[Y] = (0.5 - ((struct x_vars *)dmp->dm_vars)->omy /
			 (fastf_t)dmp->dm_height) * 2.0;
	  view_pos[Z] = 0.0;
d942 11
a952 5
	  if(state == ST_S_EDIT)
	    sedit_mouse(view_pos);
	  else
	    objedit_mouse(view_pos);
	}
d954 1
d956 13
a968 2
      case 'z':
	am_mode = AMM_SCALE;
d971 2
a972 2
	Tcl_AppendResult(interp, "dm am: unrecognized parameter - ", argv[1],
			 "\ndm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d988 1
a988 1
    if( argc < 6){
d990 2
a991 1
		       "dm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1001 22
d1036 1
a1036 1
			 "\ndm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1053 45
a1097 1
			 "\ndm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
d1103 1
a1103 1
			 "\ndm con type x|y|z 1|0 xpos ypos\n", (char *)NULL);
@


11.77
log
@mods to the event handler
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.76 1997/05/21 12:48:50 bparker Exp bparker $ (BRL)";
a60 2
static void     set_linewidth();
static void     set_linestyle();
a73 2
  {"%d",  1, "linewidth",	  X_MV_O(linewidth),	set_linewidth },
  {"%d",  1, "linestyle",	  X_MV_O(linestyle),	set_linestyle },
d187 1
a187 1
    case ALT_MOUSE_MODE_IDLE:
d200 1
a200 1
    case ALT_MOUSE_MODE_ROTATE:
d205 3
a207 7
    case ALT_MOUSE_MODE_TRANSLATE:
      if(EDIT_TRAN && mged_variables.edit){
	vect_t view_pos;
#if 0
	view_pos[X] = (mx/(fastf_t)dmp->dm_width
		       - 0.5) * 2.0;
#else
a209 1
#endif
a222 1
#if 0
a223 3
	  (fastf_t)dmp->dm_width * 2.0;
#else
	fx = (mx - ((struct x_vars *)dmp->dm_vars)->omx) /
a225 1
#endif
d232 1
a232 1
    case ALT_MOUSE_MODE_ZOOM:
d237 27
d269 1
a269 1
    /*XXX Hack to prevent Tk from choking on Ctrl-c */
d277 2
a278 1
      if(keysym == XK_c){
d407 1
a407 1
      int old_show_menu;
d409 1
a409 1
      old_show_menu = mged_variables.show_menu;
d414 1
a414 1
	 mged_variables.show_menu &&
d428 1
a428 1
      mged_variables.show_menu = 0;
d433 1
a433 1
      mged_variables.show_menu = old_show_menu;
d440 1
a440 3
  status = TCL_OK;

  if( !strcmp( argv[0], "am" )){
d458 1
a458 1
	am_mode = ALT_MOUSE_MODE_ROTATE;
d461 1
a461 1
	am_mode = ALT_MOUSE_MODE_TRANSLATE;
d463 2
a464 2
	if(EDIT_TRAN && mged_variables.edit){
	  vect_t view_pos;
a465 5
#if 0
	  view_pos[X] = (((struct x_vars *)dmp->dm_vars)->omx /
			 (fastf_t)dmp->dm_width -
			 0.5) * 2.0;
#else
d467 1
a467 3
			(fastf_t)dmp->dm_width - 0.5) /
	                dmp->dm_aspect * 2.0; 
#endif
d480 65
a544 1
	am_mode = ALT_MOUSE_MODE_ZOOM;
d547 2
a548 2
	Tcl_AppendResult(interp, "dm am: need more parameters\n",
			 "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
d551 2
a552 2
    }else{
      am_mode = ALT_MOUSE_MODE_IDLE;
d555 2
a556 1
    return status;
a589 17
  ++dmaflag;
}

static void
set_linewidth()
{
  dmp->dm_setLineAttr(dmp,
		      ((struct x_vars *)dmp->dm_vars)->mvars.linewidth,
		      dmp->dm_lineStyle);
  ++dmaflag;
}

static void
set_linestyle()
{
  dmp->dm_setLineAttr(dmp, dmp->dm_lineWidth,
		      ((struct x_vars *)dmp->dm_vars)->mvars.linestyle);
@


11.76
log
@*- mods to X_dm_init
*- add set_linewidth() and set_linestyle()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.75 1997/05/08 14:39:56 bparker Exp bparker $ (BRL)";
d176 6
@


11.75
log
@call generic dm_open
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.74 1997/04/01 20:54:33 bparker Exp bparker $ (BRL)";
d61 4
d76 2
d120 1
a120 1
  curr_dm_list->s_info->opp = &tkName;
d514 17
@


11.74
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.73 1997/03/20 22:14:58 bparker Exp bparker $ (BRL)";
d87 1
d93 9
a101 2
  for(i = argc-1; i-1; --i)
    argv[i] = argv[i-1];
d103 1
a103 2
  argv[0] = "-i";
  argv[1] = "mged_bind_dm";
d107 2
a108 1
  if((dmp = X_open(DM_EVENT_HANDLER_NULL, argc, argv)) == DM_NULL)
d110 1
d112 1
@


11.73
log
@move default -i option to beginning of argv
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.72 1997/03/07 21:38:12 bparker Exp bparker $ (BRL)";
d242 1
a242 2
      if(*buffer == 'c'){
	bu_vls_free(&cmd);
d249 1
d254 1
a254 1

@


11.72
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.71 1997/03/06 14:06:06 bparker Exp bparker $ (BRL)";
a86 3
#if 0
  struct dm *xdmp;
  char **av;
d92 2
a93 8
  av = (char **)bu_malloc(sizeof(char *) * (argc + 3), "X_dm_init: av");
  for(i = 0; i < argc; ++i)
    av[i] = argv[i];
  av[i + 1] = "-i";
  av[i + 2] = "mged_bind_dm";
  av[i + 3] = (char *)NULL;
  xdmp =  X_open(X_doevent, argc + 2, av);
  bu_free((genptr_t)av, "X_dm_init: av");
d95 2
a96 8
  return xdmp;
#else
  /* register application provided routines */
  cmd_hook = X_dm;
  state_hook = X_statechange;

  for(i = 2; i < argc; ++i)
    argv[i-2] = argv[i-1];
a97 4
  argv[i-2] = "-i";
  argv[i-1] = "mged_bind_dm";

#if DO_NEW_LIBDM_OPEN
a108 5
#else
  dmp->dm_eventHandler = X_doevent;
  return X_open(dmp, argc, argv);
#endif
#endif
@


11.71
log
@fixed typo
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.70 1997/02/28 21:35:47 bparker Exp bparker $ (BRL)";
d40 1
@


11.70
log
@added dm size command
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.69 1997/02/24 22:08:43 bparker Exp bparker $ (BRL)";
d265 1
a265 1
      if(*buffer = 'c'){
@


11.69
log
@mods to X_doevent

.,
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.68 1997/02/07 13:46:37 bparker Exp bparker $ (BRL)";
d488 16
@


11.68
log
@mods to use latest libdm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.67 1997/01/29 23:13:32 bparker Exp bparker $ (BRL)";
d122 1
a122 1
  curr_dm_list->s_info->opp = &pathName;
d198 3
a200 1
	bu_vls_printf( &cmd, "M 0 %d %d\n", Xx_TO_GED(dmp, mx), Xy_TO_GED(dmp, my));
d213 2
a214 2

	view_pos[X] = (mx/(fastf_t)((struct x_vars *)dmp->dm_vars)->width
d216 4
d221 1
a221 1
		       (fastf_t)((struct x_vars *)dmp->dm_vars)->height) * 2.0;
d233 4
d238 3
a240 1
	  (fastf_t)((struct x_vars *)dmp->dm_vars)->width * 2.0;
d242 1
a242 1
	  (fastf_t)((struct x_vars *)dmp->dm_vars)->height * 2.0;
d250 1
a250 1
		     (fastf_t)((struct x_vars *)dmp->dm_vars)->height);
d257 16
d275 2
a276 2
    ((struct x_vars *)dmp->dm_vars)->height = xwa.height;
    ((struct x_vars *)dmp->dm_vars)->width = xwa.width;
d391 34
a424 9
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d", argv[2],
		  Xx_TO_GED(dmp, atoi(argv[3])),
		  Xy_TO_GED(dmp, atoi(argv[4])));
    status = Tcl_Eval(interp, bu_vls_addr(&vls));
#if 0
    mged_print_result(status);
#endif
    return status;
d455 1
d457 1
a457 1
			 (fastf_t)((struct x_vars *)dmp->dm_vars)->width -
d459 5
d465 1
a465 1
			 (fastf_t)((struct x_vars *)dmp->dm_vars)->height) * 2.0;
@


11.67
log
@experiment with libdm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.66 1997/01/17 22:56:57 bparker Exp bparker $ (BRL)";
d53 1
a53 1

a54 1
struct dm     *X_dm_init();
d79 3
a81 2
struct dm *
X_dm_init(argc, argv)
d87 1
a88 1
  struct dm *xdmp;
d115 12
a126 2
#if 0
  return X_open(X_doevent, argc, argv);
@


11.66
log
@checkin for weekend
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.65 1997/01/02 19:37:38 bparker Exp bparker $ (BRL)";
a46 2
#include "dm-X.h"

d48 1
a49 1
#include "./mged_solid.h"
d51 1
d53 1
d55 1
a55 1
int     X_dm_init();
d80 4
a83 2
int
X_dm_init()
d85 20
a105 1
  dmp->dm_eventHandler = X_doevent;
d109 13
a121 1
  return TCL_OK;
@


11.65
log
@mods to use libbn and libbu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.64 1996/12/11 22:40:57 bparker Exp bparker $ (BRL)";
a134 1
    refresh();
a139 1
    refresh();
@


11.64
log
@experimenting
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.63 1996/12/10 21:45:18 bparker Exp bparker $ (BRL)";
d74 2
a75 2
  {"%d",  1, "debug",             X_MV_O(debug),            FUNC_NULL },
  {"",    0, (char *)0,           0,                        FUNC_NULL }
@


11.63
log
@experimentation
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.62 1996/12/09 23:01:26 bparker Exp bparker $ (BRL)";
d168 16
a183 1
      {
d186 5
a190 11
	if(EDIT_TRAN && mged_variables.edit){
	  fx = (mx/(fastf_t)((struct x_vars *)dmp->dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)((struct x_vars *)dmp->dm_vars)->height) * 2;
	  bu_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy );
	}else{
	  fx = (mx - ((struct x_vars *)dmp->dm_vars)->omx) /
	    (fastf_t)((struct x_vars *)dmp->dm_vars)->width * 2.0;
	  fy = (((struct x_vars *)dmp->dm_vars)->omy - my) /
	    (fastf_t)((struct x_vars *)dmp->dm_vars)->height * 2.0;
	  bu_vls_printf( &cmd, "knob -i aX %f aY %f\n", fx, fy );
	}
d192 1
d359 13
a371 8
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "knob aX %f aY %f\n",
			(((struct x_vars *)dmp->dm_vars)->omx /
			 (fastf_t)((struct x_vars *)dmp->dm_vars)->width - 0.5) * 2,
			(0.5 - ((struct x_vars *)dmp->dm_vars)->omy /
			 (fastf_t)((struct x_vars *)dmp->dm_vars)->height) * 2);
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
@


11.62
log
@mods to allow any kind of view manipulation at any time --- not quite done yet
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.61 1996/12/04 21:11:44 bparker Exp bparker $ (BRL)";
d171 1
a171 1
	if(EDIT_TRAN){
d312 6
a317 9
    av[0] = "M";
    av[1] = argv[2];
    av[2] = xstr;
    av[3] = ystr;
    av[4] = NULL;

    sprintf(xstr, "%d", Xx_TO_GED(dmp, atoi(argv[3])));
    sprintf(ystr, "%d", Xy_TO_GED(dmp, atoi(argv[4])));
    status = f_mouse((ClientData)NULL, interp, 4, av);
d319 1
d348 1
a348 1
	if(EDIT_TRAN){
@


11.61
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.60 1996/11/01 22:10:04 bparker Exp bparker $ (BRL)";
d164 2
a165 2
		      (my - ((struct x_vars *)dmp->dm_vars)->omy)/4.0,
		      (mx - ((struct x_vars *)dmp->dm_vars)->omx)/4.0 );
d171 1
a171 2
	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
d350 1
a350 3
	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
#if 1
a358 14
#else
	  av[0] = "knob";
	  av[1] = "aX";
	  av[2] = xstr;
	  av[3] = "aY";
	  av[4] = ystr;
	  av[5] = NULL;

	  sprintf(xstr, "%f", (((struct x_vars *)dmp->dm_vars)->omx/
			       (fastf_t)((struct x_vars *)dmp->dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - ((struct x_vars *)dmp->dm_vars)->omy/
			       (fastf_t)((struct x_vars *)dmp->dm_vars)->height) * 2);
	  status = f_knob((ClientData)NULL, interp, 5, av);
#endif
@


11.60
log
@change iknob to knob -1
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.59 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
d81 1
a81 3
X_dm_init(argc, argv)
int argc;
char *argv[];
d88 1
a88 4
  if(dmp->dm_init(dmp, argc, argv) == TCL_ERROR)
    return TCL_ERROR;

  return dmp->dm_open(dmp);
d104 1
a104 1
  int status = CMD_OK;
d164 2
a165 2
		      (my - ((struct x_vars *)dmp->dm_vars)->omy)/512.0,
		      (mx - ((struct x_vars *)dmp->dm_vars)->omx)/512.0 );
d203 1
a203 1
  status = cmdline(&cmd, FALSE);
d208 1
a208 4
  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
a322 1

d353 10
a362 1

d375 1
@


11.59
log
@hacks to use latest libdm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.58 1996/10/18 14:05:43 bparker Exp bparker $ (BRL)";
d168 1
a168 1
       bu_vls_printf( &cmd, "iknob ax %f ay %f\n",
d186 1
a186 1
	  bu_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy );
d191 1
a191 1
      bu_vls_printf( &cmd, "iknob aS %f\n",
@


11.58
log
@call mged_print_result after calling f_mouse in case it had something to say
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.57 1996/10/03 20:52:10 bparker Exp bparker $ (BRL)";
d86 3
a88 3
  dmp->dmr_eventhandler = X_doevent;
  dmp->dmr_cmd = X_dm;
  dmp->dmr_statechange = X_statechange;
d90 1
a90 1
  if(dmp->dmr_init(dmp, argc, argv) == TCL_ERROR)
d93 1
a93 1
  return dmp->dmr_open(dmp);
d157 1
a157 1
      if(scroll_active && eventPtr->xmotion.state & ((struct x_vars *)dm_vars)->mb_mask)
d169 2
a170 2
		      (my - ((struct x_vars *)dm_vars)->omy)/512.0,
		      (mx - ((struct x_vars *)dm_vars)->omx)/512.0 );
d178 2
a179 2
	  fx = (mx/(fastf_t)((struct x_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)((struct x_vars *)dm_vars)->height) * 2;
d182 4
a185 4
	  fx = (mx - ((struct x_vars *)dm_vars)->omx) /
	    (fastf_t)((struct x_vars *)dm_vars)->width * 2.0;
	  fy = (((struct x_vars *)dm_vars)->omy - my) /
	    (fastf_t)((struct x_vars *)dm_vars)->height * 2.0;
d192 2
a193 2
		     (((struct x_vars *)dm_vars)->omy - my)/
		     (fastf_t)((struct x_vars *)dm_vars)->height);
d197 2
a198 2
    ((struct x_vars *)dm_vars)->omx = mx;
    ((struct x_vars *)dm_vars)->omy = my;
d200 4
a203 4
    XGetWindowAttributes( ((struct x_vars *)dm_vars)->dpy,
			  ((struct x_vars *)dm_vars)->win, &xwa);
    ((struct x_vars *)dm_vars)->height = xwa.height;
    ((struct x_vars *)dm_vars)->width = xwa.width;
d276 1
a276 1
		     (CONST char *)&((struct x_vars *)dm_vars)->mvars );
d279 1
a279 1
			 (CONST char *)&((struct x_vars *)dm_vars)->mvars, ',');
d285 1
a285 1
      bu_struct_parse( &vls, X_vparse, (char *)&((struct x_vars *)dm_vars)->mvars);
d308 1
a308 1
      ((struct x_vars *)dm_vars)->mb_mask = Button1Mask;
d311 1
a311 1
      ((struct x_vars *)dm_vars)->mb_mask = Button2Mask;
d314 1
a314 1
      ((struct x_vars *)dm_vars)->mb_mask = Button3Mask;
d349 2
a350 2
    ((struct x_vars *)dm_vars)->omx = atoi(argv[3]);
    ((struct x_vars *)dm_vars)->omy = atoi(argv[4]);
d370 4
a373 4
	  sprintf(xstr, "%f", (((struct x_vars *)dm_vars)->omx/
			       (fastf_t)((struct x_vars *)dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - ((struct x_vars *)dm_vars)->omy/
			       (fastf_t)((struct x_vars *)dm_vars)->height) * 2);
@


11.57
log
@get rid of extra cmdline() uses
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.56 1996/10/01 17:23:59 bparker Exp bparker $ (BRL)";
d54 1
d330 1
@


11.56
log
@no longer using dm_values
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.55 1996/09/30 19:42:58 bparker Exp bparker $ (BRL)";
d261 1
a261 1
  char *av[4];
a263 1
  char zstr[32];
d320 9
a328 5
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d\n", argv[2],
		  Xx_TO_GED(dmp, atoi(argv[3])), Xy_TO_GED(dmp, atoi(argv[4])));
    status = cmdline(&vls, FALSE);
    bu_vls_free(&vls);
d330 1
a330 4
    if(status == CMD_OK)
      return TCL_OK;

    return TCL_ERROR;
a359 1
	  fastf_t fx, fy;
d361 12
a372 8
	  bu_vls_init(&vls);
	  fx = (((struct x_vars *)dm_vars)->omx/
		(fastf_t)((struct x_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - ((struct x_vars *)dm_vars)->omy/
		(fastf_t)((struct x_vars *)dm_vars)->height) * 2;
	  bu_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	  (void)cmdline(&vls, FALSE);
	  bu_vls_free(&vls);
@


11.55
log
@more pruning
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.54 1996/09/26 20:38:22 bparker Exp bparker $ (BRL)";
a66 1
extern struct device_values dm_values;	/* values read from devices */
@


11.54
log
@changed parameters to dmr_object
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.53 1996/09/25 20:04:58 bparker Exp bparker $ (BRL)";
a54 3
#if 0
struct dm_list *get_dm_list();
#endif
d107 1
d111 2
a112 1
  if(eventPtr->type == DestroyNotify)
a115 3
#if 0
  curr_dm_list = get_dm_list(eventPtr->xany.window);
#else
a116 1
#endif
d252 1
d397 1
d404 1
a404 16
}

#if 0
static struct dm_list *
get_dm_list(window)
Window window;
{
  register struct dm_list *p;

/*XXXX*/
  for(BU_LIST_FOR(p, dm_list, &head_dm_list.l)){
    if(window == p->win)
	return ((struct mged_x_vars *)p->app_vars)->dm_list;
  }

  return DM_LIST_NULL;
a405 1
#endif
@


11.53
log
@calling GET_DM_LIST macro instead of get_dm_list
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.52 1996/09/23 18:41:43 bparker Exp bparker $ (BRL)";
a87 3
  if(dmp->dmr_init(dmp, argc, argv) == TCL_ERROR)
    return TCL_ERROR;

d92 3
a94 3
#if 0
  dmp->dmr_app_close = X_close;
#endif
a97 10

#if 0
int
X_close(p)
genptr_t *p;
{
  bu_free(p, "mged_x_vars");
  return TCL_OK;
}
#endif
@


11.52
log
@use LIBDM permanently
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.51 1996/09/17 21:21:19 bparker Exp bparker $ (BRL)";
d51 1
a51 1
#include "./solid.h"
d54 4
a57 1
extern void color_soltab();
a58 1
int     X_dm_init();
a62 1
static struct dm_list *get_dm_list();
a73 5
struct mged_x_vars {
  struct dm_list *dm_list;
};

#define X_APP_VARS ((struct mged_x_vars *)(((struct x_vars *)dm_vars)->app_vars))
d88 1
a88 1
  if(dmp->dmr_init(dmp, color_soltab, argc, argv) == TCL_ERROR)
a98 6
  /* Allocate space for application specific X variables */
  ((struct x_vars *)dm_vars)->app_vars = bu_malloc(sizeof(struct mged_x_vars), "mged_x_vars");
  bzero((void *)((struct x_vars *)dm_vars)->app_vars, sizeof(struct mged_x_vars));

  X_APP_VARS->dm_list = curr_dm_list;

d130 1
d132 3
d422 1
d427 1
a427 1
  register struct x_vars *p;
d430 1
a430 1
  for( BU_LIST_FOR(p, x_vars, &head_x_vars.l) ){
d437 1
@


11.51
log
@prepare to use libdm
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.50 1996/09/05 20:10:23 bparker Exp bparker $ (BRL)";
d47 2
d50 1
a50 1
#include "./dm.h"
a53 3
#ifdef USE_LIBDM
#include "dm-X.h"

d88 3
a90 1
X_dm_init()
d92 1
a92 1
  if(dmp->dmr_init(dmp, color_soltab) == TCL_ERROR)
a441 1303

#else
static void	label();
static void	draw();
static int	X_setup();
static void     x_var_init();
static void     establish_perspective();
static void     set_perspective();
static void     X_configure_window_shape();
static void     establish_am();

/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
int	X_open();
void	X_close();
MGED_EXTERN(void	X_input, (fd_set *input, int noblock) );
void	X_prolog(), X_epilog();
void	X_normal(), X_newrot();
void	X_update();
void	X_puts(), X_2d_line(), X_light();
int	X_object();
unsigned X_cvtvecs(), X_load();
void	X_statechange(), X_viewchange(), X_colorchange();
void	X_window(), X_debug(), X_selectargs();
int     X_dm();

static void X_load_startup();
static struct dm_list *get_dm_list();
#ifdef USE_PROTOTYPES
static Tk_GenericProc X_doevent;
#else
static int X_doevent();
#endif

#define TRY_COLOR_CUBE 1
#if TRY_COLOR_CUBE
#define NUM_PIXELS  216
static unsigned long get_pixel();
static void get_color_slot();
static void allocate_color_cube();
#endif

struct dm dm_X = {
	X_open, X_close,
	X_input,
	X_prolog, X_epilog,
	X_normal, X_newrot,
	X_update,
	X_puts, X_2d_line,
	X_light,
	X_object,	X_cvtvecs, X_load,
	X_statechange,
	X_viewchange,
	X_colorchange,
	X_window, X_debug, X_dm, X_doevent,
	0,				/* no displaylist */
	0,				/* multi-window */
	PLOTBOUND,
	"X", "X Window System (X11)",
	0,
	0,
	0,
	0
};

extern int dm_pipe[];
extern struct device_values dm_values;	/* values read from devices */
extern Tcl_Interp *interp;
extern Tk_Window tkwin;

struct modifiable_x_vars {
  int perspective_mode;
  int dummy_perspective;
  int debug;
};

struct x_vars {
  struct bu_list l;
  struct dm_list *dm_list;
  Display *dpy;
  Tk_Window xtkwin;
  Window win;
  Pixmap pix;
  unsigned int mb_mask;
  int width;
  int height;
  int omx, omy;
  int perspective_angle;
  GC gc;
  XFontStruct *fontstruct;
  int is_monochrome;
  unsigned long black,gray,white,yellow,red,blue;
  unsigned long bd, bg, fg;   /* color of border, background, foreground */
#if TRY_COLOR_CUBE
  Colormap cmap;
  unsigned long   pixel[NUM_PIXELS];
#endif
  struct modifiable_x_vars mvars;
};

#define X_MV_O(_m) offsetof(struct modifiable_x_vars, _m)
struct bu_structparse X_vparse[] = {
  {"%d",  1, "perspective",       X_MV_O(perspective_mode), establish_perspective },
  {"%d",  1, "set_perspective",   X_MV_O(dummy_perspective),set_perspective },
  {"%d",  1, "debug",             X_MV_O(debug),            FUNC_NULL },
  {"",    0, (char *)0,           0,                        FUNC_NULL }
};

static int perspective_table[] = { 
	30, 45, 60, 90 };

static struct x_vars head_x_vars;
static int XdoMotion = 0;

/*
 * Display coordinate conversion:
 *  GED is using -2048..+2048,
 *  X is 0..width,0..height
 */
#define	GED_TO_Xx(x)	((int)((x/4096.0+0.5)*((struct x_vars *)dm_vars)->width))
#define	GED_TO_Xy(x)	((int)((0.5-x/4096.0)*((struct x_vars *)dm_vars)->height))
#define Xx_TO_GED(x)    ((int)((x/(double)((struct x_vars *)dm_vars)->width - 0.5) * 4095))
#define Xy_TO_GED(x)    ((int)((0.5 - x/(double)((struct x_vars *)dm_vars)->height) * 4095))

/*
 *			X _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
X_open()
{
  x_var_init();

  return X_setup(dname);
}

/*
 *  			X _ C L O S E
 *  
 *  Gracefully release the display.
 */
void
X_close()
{
  if(((struct x_vars *)dm_vars)->gc != 0)
    XFreeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc);

  if(((struct x_vars *)dm_vars)->pix != 0)
     Tk_FreePixmap(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->pix);

  if(((struct x_vars *)dm_vars)->xtkwin != 0)
    Tk_DestroyWindow(((struct x_vars *)dm_vars)->xtkwin);

  if(((struct x_vars *)dm_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct x_vars *)dm_vars)->l);

  bu_free(dm_vars, "X_close: dm_vars");

  if(BU_LIST_IS_EMPTY(&head_x_vars.l))
    Tk_DeleteGenericHandler(X_doevent, (ClientData)NULL);
}

/*
 *			X _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
void
X_prolog()
{
  XGCValues       gcv;

  gcv.foreground = ((struct x_vars *)dm_vars)->bg;
  XChangeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc,
	    GCForeground, &gcv);
  XFillRectangle(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->pix,
		 ((struct x_vars *)dm_vars)->gc, 0, 0, ((struct x_vars *)dm_vars)->width + 1,
		 ((struct x_vars *)dm_vars)->height + 1);
}

/*
 *			X _ E P I L O G
 */
void
X_epilog()
{
    /* Put the center point up last */
    draw( 0, 0, 0, 0 );

    XCopyArea(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->pix,
	      ((struct x_vars *)dm_vars)->win, ((struct x_vars *)dm_vars)->gc,
	      0, 0, ((struct x_vars *)dm_vars)->width, ((struct x_vars *)dm_vars)->height,
	      0, 0);

    /* Prevent lag between events and updates */
    XSync(((struct x_vars *)dm_vars)->dpy, 0);
}

/*
 *  			X _ N E W R O T
 *  Stub.
 */
/* ARGSUSED */
void
X_newrot(mat)
mat_t mat;
{
	return;
}

/*
 *  			X _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */

/* ARGSUSED */
int
X_object( sp, mat, ratio, white_flag )
register struct solid *sp;
mat_t mat;
double ratio;
int white_flag;
{
    static vect_t   pnt;
    register struct rt_vlist	*vp;
    int useful = 0;
    XSegment segbuf[1024];		/* XDrawSegments list */
    XSegment *segp;			/* current segment */
    XGCValues gcv;
    int	nseg;			        /* number of segments */
    int	x, y;
    int	lastx = 0;
    int	lasty = 0;
    int   line_width = 1;
    int   line_style = LineSolid;

#if TRY_COLOR_CUBE
    if(white_flag){    /* if highlighted */
      gcv.foreground = get_pixel(sp->s_color);

      /* if solid color is already the same as the highlight color use double line width */
      if(gcv.foreground == ((struct x_vars *)dm_vars)->white)
	line_width = 2;
      else
	gcv.foreground = ((struct x_vars *)dm_vars)->white;
    }else
      gcv.foreground = get_pixel(sp->s_color);
#else
    gcv.foreground = ((struct x_vars *)dm_vars)->fg;
#endif
    XChangeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc, GCForeground, &gcv);

    if( sp->s_soldash )
      line_style = LineOnOffDash;

    XSetLineAttributes( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc,
			line_width, line_style, CapButt, JoinMiter );

    nseg = 0;
    segp = segbuf;
    for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
	register int	i;
	register int	nused = vp->nused;
	register int	*cmd = vp->cmd;
	register point_t *pt = vp->pt;

	/* Viewing region is from -1.0 to +1.0 */
	/* 2^31 ~= 2e9 -- dynamic range of a long int */
	/* 2^(31-11) = 2^20 ~= 1e6 */
	/* Integerize and let the X server do the clipping */
	for( i = 0; i < nused; i++,cmd++,pt++ )  {
	    switch( *cmd )  {
	    case RT_VLIST_POLY_START:
	    case RT_VLIST_POLY_VERTNORM:
		continue;
	    case RT_VLIST_POLY_MOVE:
	    case RT_VLIST_LINE_MOVE:
		/* Move, not draw */
		MAT4X3PNT( pnt, mat, *pt );
		if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
		   pnt[1] < -1e6 || pnt[1] > 1e6 )
		    continue; /* omit this point (ugh) */
		pnt[0] *= 2047;
		pnt[1] *= 2047;
		x = GED_TO_Xx(pnt[0]);
		y = GED_TO_Xy(pnt[1]);
		lastx = x;
		lasty = y;
		continue;
	    case RT_VLIST_POLY_DRAW:
	    case RT_VLIST_POLY_END:
	    case RT_VLIST_LINE_DRAW:
		/* draw */
		MAT4X3PNT( pnt, mat, *pt );
		if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
		   pnt[1] < -1e6 || pnt[1] > 1e6 )
		    continue; /* omit this point (ugh) */
		/* Integerize and let the X server do the clipping */
		/*XXX Color */
#if !TRY_COLOR_CUBE
		gcv.foreground = ((struct x_vars *)dm_vars)->fg;
		if( white_flag && !((struct x_vars *)dm_vars)->is_monochrome ){
		    gcv.foreground = ((struct x_vars *)dm_vars)->white;
		}
		XChangeGC( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc, GCForeground, &gcv );
#endif
		pnt[0] *= 2047;
		pnt[1] *= 2047;
		x = GED_TO_Xx(pnt[0]);
		y = GED_TO_Xy(pnt[1]);

		segp->x1 = lastx;
		segp->y1 = lasty;
		segp->x2 = x;
		segp->y2 = y;
		nseg++;
		segp++;
		lastx = x;
		lasty = y;
		useful = 1;
		if( nseg == 1024 ) {
		    XDrawSegments( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->pix, ((struct x_vars *)dm_vars)->gc, segbuf, nseg );
		    /* Thicken the drawing, if monochrome */
		    if( white_flag && ((struct x_vars *)dm_vars)->is_monochrome ){
			int	i;
			/* XXX - width and height don't work on Sun! */
			/* Thus the following gross hack */
			segp = segbuf;
			for( i = 0; i < nseg; i++ ) {
			    segp->x1++;
			    segp->y1++;
			    segp->x2++;
			    segp->y2++;
			    segp++;
			}
			XDrawSegments( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->pix, ((struct x_vars *)dm_vars)->gc, segbuf, nseg );
		    }
		    nseg = 0;
		    segp = segbuf;
		}
		break;
	    }
	}
    }
    if( nseg ) {
	XDrawSegments( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->pix, ((struct x_vars *)dm_vars)->gc, segbuf, nseg );
	if( white_flag && ((struct x_vars *)dm_vars)->is_monochrome ){
	    int	i;
	    /* XXX - width and height don't work on Sun! */
	    /* Thus the following gross hack */
	    segp = segbuf;
	    for( i = 0; i < nseg; i++ ) {
		segp->x1++;
		segp->y1++;
		segp->x2++;
		segp->y2++;
		segp++;
	    }
	    XDrawSegments( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->pix, ((struct x_vars *)dm_vars)->gc, segbuf, nseg );
	}
    }

    return(useful);
}

/*
 *			X _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
X_normal()
{
	return;
}

/*
 *			X _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
void
X_update()
{
    XFlush(((struct x_vars *)dm_vars)->dpy);
}

/*
 *			X _ P U T S
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
void
X_puts( str, x, y, size, color )
register char *str;
{
	XGCValues gcv;
	unsigned long fg;

	switch( color )  {
	case DM_BLACK:
		fg = ((struct x_vars *)dm_vars)->black;
		break;
	case DM_RED:
		fg = ((struct x_vars *)dm_vars)->red;
		break;
	case DM_BLUE:
		fg = ((struct x_vars *)dm_vars)->blue;
		break;
	default:
	case DM_YELLOW:
		fg = ((struct x_vars *)dm_vars)->yellow;
		break;
	case DM_WHITE:
		fg = ((struct x_vars *)dm_vars)->gray;
		break;
	}
	gcv.foreground = fg;
	XChangeGC( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc, GCForeground, &gcv );
	label( (double)x, (double)y, str );
}

/*
 *			X _ 2 D _ G O T O
 *
 */
void
X_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
    XGCValues gcv;

    gcv.foreground = ((struct x_vars *)dm_vars)->yellow;
    XChangeGC( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc, GCForeground, &gcv );
    if( dashed ) {
	XSetLineAttributes(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc, 1, LineOnOffDash, CapButt, JoinMiter );
    } else {
	XSetLineAttributes(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc, 1, LineSolid, CapButt, JoinMiter );
    }
    draw( x1, y1, x2, y2 );
}

static int
X_doevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
  KeySym key;
  char keybuf[4];
  int cnt;
  XComposeStatus compose_stat;
  XWindowAttributes xwa;
  struct bu_vls cmd;
  register struct dm_list *save_dm_list;
  int status = CMD_OK;

  save_dm_list = curr_dm_list;
  curr_dm_list = get_dm_list(eventPtr->xany.window);

  if(curr_dm_list == DM_LIST_NULL)
    goto end;

  if(mged_variables.send_key && eventPtr->type == KeyPress){
    char buffer[1];
    KeySym keysym;

    XLookupString(&(eventPtr->xkey), buffer, 1,
		  &keysym, (XComposeStatus *)NULL);

    if(keysym == mged_variables.hot_key)
      goto end;

    write(dm_pipe[1], buffer, 1);
    curr_dm_list = save_dm_list;

    /* Use this so that these events won't propagate */
    return TCL_RETURN;
  }

  if (eventPtr->type == Expose && eventPtr->xexpose.count == 0){
    dirty = 1;
    refresh();
    goto end;
  }else if(eventPtr->type == ConfigureNotify){
    X_configure_window_shape();

    dirty = 1;
    refresh();
    goto end;
  } else if( eventPtr->type == MotionNotify ) {
    int mx, my;

    bu_vls_init(&cmd);
    mx = eventPtr->xmotion.x;
    my = eventPtr->xmotion.y;

    switch(am_mode){
    case ALT_MOUSE_MODE_IDLE:
      if(scroll_active && eventPtr->xmotion.state & ((struct x_vars *)dm_vars)->mb_mask)
	bu_vls_printf( &cmd, "M 1 %d %d\n", Xx_TO_GED(mx), Xy_TO_GED(my));
      else if(XdoMotion)
	/* trackball not active so do the regular thing */
	/* Constant tracking (e.g. illuminate mode) bound to M mouse */
	bu_vls_printf( &cmd, "M 0 %d %d\n", Xx_TO_GED(mx), Xy_TO_GED(my));
      else
	goto end;

      break;
    case ALT_MOUSE_MODE_ROTATE:
       bu_vls_printf( &cmd, "iknob ax %f ay %f\n",
		      (my - ((struct x_vars *)dm_vars)->omy)/512.0,
		      (mx - ((struct x_vars *)dm_vars)->omx)/512.0 );
      break;
    case ALT_MOUSE_MODE_TRANSLATE:
      {
	fastf_t fx, fy;

	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
	  fx = (mx/(fastf_t)((struct x_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - my/(fastf_t)((struct x_vars *)dm_vars)->height) * 2;
	  bu_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy );
	}else{
	  fx = (mx - ((struct x_vars *)dm_vars)->omx) /
	    (fastf_t)((struct x_vars *)dm_vars)->width * 2.0;
	  fy = (((struct x_vars *)dm_vars)->omy - my) /
	    (fastf_t)((struct x_vars *)dm_vars)->height * 2.0;
	  bu_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy );
	}
      }
      break;
    case ALT_MOUSE_MODE_ZOOM:
      bu_vls_printf( &cmd, "iknob aS %f\n",
		     (((struct x_vars *)dm_vars)->omy - my)/
		     (fastf_t)((struct x_vars *)dm_vars)->height);
      break;
    }

    ((struct x_vars *)dm_vars)->omx = mx;
    ((struct x_vars *)dm_vars)->omy = my;
  } else {
    XGetWindowAttributes( ((struct x_vars *)dm_vars)->dpy,
			  ((struct x_vars *)dm_vars)->win, &xwa);
    ((struct x_vars *)dm_vars)->height = xwa.height;
    ((struct x_vars *)dm_vars)->width = xwa.width;

    goto end;
  }

  status = cmdline(&cmd, FALSE);
  bu_vls_free(&cmd);
end:
  curr_dm_list = save_dm_list;

  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
}
	    
/*
 *			X _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 *
 * DEPRECATED 
 *
 */
/* ARGSUSED */
void
X_input( input, noblock )
fd_set		*input;
int		noblock;
{
    return;
}

/* 
 *			X _ L I G H T
 */
/* ARGSUSED */
void
X_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
  return;
}

/* ARGSUSED */
unsigned
X_cvtvecs( sp )
struct solid *sp;
{
  return 0;
}

/*
 * Loads displaylist
 */
unsigned
X_load( addr, count )
unsigned addr, count;
{
  return 0;
}

void
X_statechange( a, b )
int	a, b;
{
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
	switch( b )  {
	case ST_VIEW:
	    /* constant tracking OFF */
	    XdoMotion = 0;
	    break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	case ST_S_VPICK:
	    /* constant tracking ON */
	    XdoMotion = 1;
	    break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	    /* constant tracking OFF */
	    XdoMotion = 0;
	    break;
	default:
	  Tcl_AppendResult(interp, "X_statechange: unknown state ",
			   state_str[b], "\n", (char *)NULL);
	  break;
	}

	/*X_viewchange( DM_CHGV_REDO, SOLID_NULL );*/
}

void
X_viewchange()
{
}

/* ARGSUSED */
void
X_debug(lvl)
{
  XFlush(((struct x_vars *)dm_vars)->dpy);
  Tcl_AppendResult(interp, "flushed\n", (char *)NULL);
}

void
X_window(w)
register int w[];
{
#if 0
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
#endif
}

/*********XXX**********/
/*
 *  Called for 2d_line, and dot at center of screen.
 */
static void
draw( x1, y1, x2, y2 )
int	x1, y1;		/* from point */
int	x2, y2;		/* to point */
{
  int	sx1, sy1, sx2, sy2;

  sx1 = GED_TO_Xx( x1 );
  sy1 = GED_TO_Xy( y1 );
  sx2 = GED_TO_Xx( x2 );
  sy2 = GED_TO_Xy( y2 );

  if( sx1 == sx2 && sy1 == sy2 )
    XDrawPoint( ((struct x_vars *)dm_vars)->dpy,
		((struct x_vars *)dm_vars)->pix,
		((struct x_vars *)dm_vars)->gc, sx1, sy1 );
  else
    XDrawLine( ((struct x_vars *)dm_vars)->dpy,
	       ((struct x_vars *)dm_vars)->pix,
	       ((struct x_vars *)dm_vars)->gc, sx1, sy1, sx2, sy2 );
}

static void
label( x, y, str )
double	x, y;
char	*str;
{
  int	sx, sy;

  sx = GED_TO_Xx( x );
  sy = GED_TO_Xy( y );
  /* point is center of text? - seems like what MGED wants... */
  /* The following makes the menu look good, the rest bad */
  /*sy += ((struct x_vars *)dm_vars)->fontstruct->max_bounds.ascent + ((struct x_vars *)dm_vars)->fontstruct->max_bounds.descent/2);*/

  XDrawString( ((struct x_vars *)dm_vars)->dpy,
	       ((struct x_vars *)dm_vars)->pix,
	       ((struct x_vars *)dm_vars)->gc, sx, sy, str, strlen(str) );
}

#define FONTBACK	"-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1"
#define FONT5	"5x7"
#define FONT6	"6x10"
#define FONT7	"7x13"
#define FONT8	"8x13"
#define FONT9	"9x15"

static XWMHints xwmh = {
        StateHint,		        /* flags */
	0,				/* input */
	NormalState,			/* initial_state */
	0,				/* icon pixmap */
	0,				/* icon window */
	0, 0,				/* icon location */
	0,				/* icon mask */
	0				/* Window group */
};

static int
X_setup( name )
char	*name;
{
  static int count = 0;
  int first_event, first_error;
  char *cp;
  XGCValues gcv;
  XColor a_color;
  Visual *a_visual;
  int a_screen;
  Colormap  a_cmap;
  struct bu_vls str;
  Display *tmp_dpy;

  bu_vls_init(&str);

  /* Only need to do this once for this display manager */
  if(!count)
    X_load_startup();

  if(BU_LIST_IS_EMPTY(&head_x_vars.l))
    Tk_CreateGenericHandler(X_doevent, (ClientData)NULL);

  BU_LIST_APPEND(&head_x_vars.l, &((struct x_vars *)dm_vars)->l);

  bu_vls_printf(&pathName, ".dm_x%d", count++);

  /* Make xtkwin a toplevel window */
  ((struct x_vars *)dm_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
						       bu_vls_addr(&pathName), name);

  /*
   * Create the X drawing window by calling init_x which
   * is defined in xinit.tcl
   */
  bu_vls_strcpy(&str, "init_x ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&pathName));

  if(cmdline(&str, FALSE) == CMD_BAD){
    bu_vls_free(&str);
    return -1;
  }

  bu_vls_free(&str);

  ((struct x_vars *)dm_vars)->dpy = Tk_Display(((struct x_vars *)dm_vars)->xtkwin);
  ((struct x_vars *)dm_vars)->width =
    DisplayWidth(((struct x_vars *)dm_vars)->dpy,
		 DefaultScreen(((struct x_vars *)dm_vars)->dpy)) - 20;
  ((struct x_vars *)dm_vars)->height =
    DisplayHeight(((struct x_vars *)dm_vars)->dpy,
		  DefaultScreen(((struct x_vars *)dm_vars)->dpy)) - 20;

  /* Make window square */
  if(((struct x_vars *)dm_vars)->height < ((struct x_vars *)dm_vars)->width)
    ((struct x_vars *)dm_vars)->width = ((struct x_vars *)dm_vars)->height;
  else
    ((struct x_vars *)dm_vars)->height = ((struct x_vars *)dm_vars)->width;

  Tk_GeometryRequest(((struct x_vars *)dm_vars)->xtkwin,
		     ((struct x_vars *)dm_vars)->width, 
		     ((struct x_vars *)dm_vars)->height);

#if 0
  /*XXX*/
  XSynchronize(((struct x_vars *)dm_vars)->dpy, TRUE);
#endif

  Tk_MakeWindowExist(((struct x_vars *)dm_vars)->xtkwin);
  ((struct x_vars *)dm_vars)->win =
      Tk_WindowId(((struct x_vars *)dm_vars)->xtkwin);

  ((struct x_vars *)dm_vars)->pix = Tk_GetPixmap(((struct x_vars *)dm_vars)->dpy,
    DefaultRootWindow(((struct x_vars *)dm_vars)->dpy), ((struct x_vars *)dm_vars)->width,
    ((struct x_vars *)dm_vars)->height, Tk_Depth(((struct x_vars *)dm_vars)->xtkwin));

  a_screen = Tk_ScreenNumber(((struct x_vars *)dm_vars)->xtkwin);
  a_visual = Tk_Visual(((struct x_vars *)dm_vars)->xtkwin);

  /* Get color map indices for the colors we use. */
  ((struct x_vars *)dm_vars)->black = BlackPixel( ((struct x_vars *)dm_vars)->dpy, a_screen );
  ((struct x_vars *)dm_vars)->white = WhitePixel( ((struct x_vars *)dm_vars)->dpy, a_screen );

#if TRY_COLOR_CUBE
  ((struct x_vars *)dm_vars)->cmap = a_cmap = Tk_Colormap(((struct x_vars *)dm_vars)->xtkwin);
#else
  a_cmap = Tk_Colormap(((struct x_vars *)dm_vars)->xtkwin);
#endif
  a_color.red = 255<<8;
  a_color.green=0;
  a_color.blue=0;
  a_color.flags = DoRed | DoGreen| DoBlue;
  if ( ! XAllocColor(((struct x_vars *)dm_vars)->dpy, a_cmap, &a_color)) {
    Tcl_AppendResult(interp, "dm-X: Can't Allocate red\n", (char *)NULL);
    return -1;
  }
  ((struct x_vars *)dm_vars)->red = a_color.pixel;
    if ( ((struct x_vars *)dm_vars)->red == ((struct x_vars *)dm_vars)->white )
      ((struct x_vars *)dm_vars)->red = ((struct x_vars *)dm_vars)->black;

    a_color.red = 200<<8;
    a_color.green=200<<8;
    a_color.blue=0<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dm_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate yellow\n", (char *)NULL);
      return -1;
    }
    ((struct x_vars *)dm_vars)->yellow = a_color.pixel;
    if ( ((struct x_vars *)dm_vars)->yellow == ((struct x_vars *)dm_vars)->white )
      ((struct x_vars *)dm_vars)->yellow = ((struct x_vars *)dm_vars)->black;
    
    a_color.red = 0;
    a_color.green=0;
    a_color.blue=255<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dm_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate blue\n", (char *)NULL);
      return -1;
    }
    ((struct x_vars *)dm_vars)->blue = a_color.pixel;
    if ( ((struct x_vars *)dm_vars)->blue == ((struct x_vars *)dm_vars)->white )
      ((struct x_vars *)dm_vars)->blue = ((struct x_vars *)dm_vars)->black;

    a_color.red = 128<<8;
    a_color.green=128<<8;
    a_color.blue= 128<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct x_vars *)dm_vars)->dpy, a_cmap, &a_color)) {
      Tcl_AppendResult(interp, "dm-X: Can't Allocate gray\n", (char *)NULL);
      return -1;
    }
    ((struct x_vars *)dm_vars)->gray = a_color.pixel;
    if ( ((struct x_vars *)dm_vars)->gray == ((struct x_vars *)dm_vars)->white )
      ((struct x_vars *)dm_vars)->gray = ((struct x_vars *)dm_vars)->black;

    /* Select border, background, foreground colors,
     * and border width.
     */
    if( a_visual->class == GrayScale || a_visual->class == StaticGray ) {
	((struct x_vars *)dm_vars)->is_monochrome = 1;
	((struct x_vars *)dm_vars)->bd = BlackPixel( ((struct x_vars *)dm_vars)->dpy, a_screen );
	((struct x_vars *)dm_vars)->bg = WhitePixel( ((struct x_vars *)dm_vars)->dpy, a_screen );
	((struct x_vars *)dm_vars)->fg = BlackPixel( ((struct x_vars *)dm_vars)->dpy, a_screen );
    } else {
	/* Hey, it's a color server.  Ought to use 'em! */
	((struct x_vars *)dm_vars)->is_monochrome = 0;
	((struct x_vars *)dm_vars)->bd = WhitePixel( ((struct x_vars *)dm_vars)->dpy, a_screen );
	((struct x_vars *)dm_vars)->bg = BlackPixel( ((struct x_vars *)dm_vars)->dpy, a_screen );
	((struct x_vars *)dm_vars)->fg = WhitePixel( ((struct x_vars *)dm_vars)->dpy, a_screen );
    }

    if( !((struct x_vars *)dm_vars)->is_monochrome &&
	((struct x_vars *)dm_vars)->fg != ((struct x_vars *)dm_vars)->red &&
	((struct x_vars *)dm_vars)->red != ((struct x_vars *)dm_vars)->black )
      ((struct x_vars *)dm_vars)->fg = ((struct x_vars *)dm_vars)->red;

    gcv.foreground = ((struct x_vars *)dm_vars)->fg;
    gcv.background = ((struct x_vars *)dm_vars)->bg;
    ((struct x_vars *)dm_vars)->gc = XCreateGC(((struct x_vars *)dm_vars)->dpy,
					       ((struct x_vars *)dm_vars)->win,
					       (GCForeground|GCBackground),
					       &gcv);

#if TRY_COLOR_CUBE
    allocate_color_cube();
#endif

#ifndef CRAY2
    X_configure_window_shape();
#endif

    Tk_SetWindowBackground(((struct x_vars *)dm_vars)->xtkwin, ((struct x_vars *)dm_vars)->bg);
    Tk_MapWindow(((struct x_vars *)dm_vars)->xtkwin);

    return 0;
}

static void
X_configure_window_shape()
{
  XWindowAttributes xwa;
  XFontStruct     *newfontstruct;
  XGCValues       gcv;

  XGetWindowAttributes( ((struct x_vars *)dm_vars)->dpy,
			((struct x_vars *)dm_vars)->win, &xwa );
  ((struct x_vars *)dm_vars)->height = xwa.height;
  ((struct x_vars *)dm_vars)->width = xwa.width;

  /* First time through, load a font or quit */
  if (((struct x_vars *)dm_vars)->fontstruct == NULL) {
    if ((((struct x_vars *)dm_vars)->fontstruct = XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, FONT9)) == NULL ) {
      /* Try hardcoded backup font */
      if ((((struct x_vars *)dm_vars)->fontstruct = XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, FONTBACK)) == NULL) {
	Tcl_AppendResult(interp, "dm-X: Can't open font '", FONT9,
			 "' or '", FONTBACK, "'\n", (char *)NULL);
	return;
      }
    }

    gcv.font = ((struct x_vars *)dm_vars)->fontstruct->fid;
    XChangeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc,
	      GCFont, &gcv);
  }

  /* Always try to choose a the font that best fits the window size.
   */

  if (((struct x_vars *)dm_vars)->width < 582) {
    if (((struct x_vars *)dm_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, FONT5)) != NULL ) {
	XFreeFont(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->fontstruct);
	((struct x_vars *)dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc,
		  GCFont, &gcv);
      }
    }
  } else if (((struct x_vars *)dm_vars)->width < 679) {
    if (((struct x_vars *)dm_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, FONT6)) != NULL ) {
	XFreeFont(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->fontstruct);
	((struct x_vars *)dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc,
		  GCFont, &gcv);
      }
    }
  } else if (((struct x_vars *)dm_vars)->width < 776) {
    if (((struct x_vars *)dm_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, FONT7)) != NULL ) {
	XFreeFont(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->fontstruct);
	((struct x_vars *)dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc,
		  GCFont, &gcv);
      }
    }
  } else if (((struct x_vars *)dm_vars)->width < 873) {
    if (((struct x_vars *)dm_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, FONT8)) != NULL ) {
	XFreeFont(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->fontstruct);
	((struct x_vars *)dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc,
		  GCFont, &gcv);
      }
    }
  } else {
    if (((struct x_vars *)dm_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, FONT9)) != NULL ) {
	XFreeFont(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->fontstruct);
	((struct x_vars *)dm_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct x_vars *)dm_vars)->fontstruct->fid;
	XChangeGC(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc,
		  GCFont, &gcv);
      }
    }
  }
}

static void
establish_perspective()
{
  bu_vls_printf( &dm_values.dv_string,
		"set perspective %d\n",
		((struct x_vars *)dm_vars)->mvars.perspective_mode ?
		perspective_table[((struct x_vars *)dm_vars)->perspective_angle] : -1 );
  dmaflag = 1;
}

/*
   This routine will toggle the perspective_angle if the
   dummy_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (dummy_perspective - 1).
*/
static void
set_perspective()
{
  /* set perspective matrix */
  if(((struct x_vars *)dm_vars)->mvars.dummy_perspective > 0)
    ((struct x_vars *)dm_vars)->perspective_angle = ((struct x_vars *)dm_vars)->mvars.dummy_perspective <= 4 ?
    ((struct x_vars *)dm_vars)->mvars.dummy_perspective - 1: 3;
  else if (--((struct x_vars *)dm_vars)->perspective_angle < 0) /* toggle perspective matrix */
    ((struct x_vars *)dm_vars)->perspective_angle = 3;

  if(((struct x_vars *)dm_vars)->mvars.perspective_mode)
    bu_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[((struct x_vars *)dm_vars)->perspective_angle] );

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  ((struct x_vars *)dm_vars)->mvars.dummy_perspective = 1;

  dmaflag = 1;
}

static void
establish_am()
{
  return;
}

int
X_dm(argc, argv)
int argc;
char *argv[];
{
  struct bu_vls   vls;
  int status;
  char *av[4];
  char xstr[32];
  char ystr[32];
  char zstr[32];

  if( !strcmp( argv[0], "set" )){
    struct bu_vls tmp_vls;

    bu_vls_init(&vls);
    bu_vls_init(&tmp_vls);
    start_catching_output(&tmp_vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      bu_struct_print("dm_X internal variables", X_vparse,
		     (CONST char *)&((struct x_vars *)dm_vars)->mvars );
    } else if( argc == 2 ) {
      bu_vls_struct_item_named( &vls, X_vparse, argv[1],
			 (CONST char *)&((struct x_vars *)dm_vars)->mvars, ',');
      bu_log( "%s\n", bu_vls_addr(&vls) );
    } else {
      bu_vls_printf( &vls, "%s=\"", argv[1] );
      bu_vls_from_argv( &vls, argc-2, argv+2 );
      bu_vls_putc( &vls, '\"' );
      bu_struct_parse( &vls, X_vparse, (char *)&((struct x_vars *)dm_vars)->mvars);
    }

    bu_vls_free(&vls);

    stop_catching_output(&tmp_vls);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
    return TCL_OK;
  }

  if( !strcmp( argv[0], "m")){
    scroll_active = 0;

    if( argc < 5){
      Tcl_AppendResult(interp, "dm m: need more parameters\n",
		       "dm m button 1|0 xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    /* This assumes a 3-button mouse */
    switch(*argv[1]){
    case '1':
      ((struct x_vars *)dm_vars)->mb_mask = Button1Mask;
      break;
    case '2':
      ((struct x_vars *)dm_vars)->mb_mask = Button2Mask;
      break;
    case '3':
      ((struct x_vars *)dm_vars)->mb_mask = Button3Mask;
      break;
    default:
      Tcl_AppendResult(interp, "dm m: bad button value - ", argv[1], "\n", (char *)NULL);
      return TCL_ERROR;
    }

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "M %s %d %d\n", argv[2],
		  Xx_TO_GED(atoi(argv[3])), Xy_TO_GED(atoi(argv[4])));
    status = cmdline(&vls, FALSE);
    bu_vls_free(&vls);

    if(status == CMD_OK)
      return TCL_OK;

    return TCL_ERROR;
  }

  status = TCL_OK;

  if( !strcmp( argv[0], "am" )){
    int buttonpress;

    scroll_active = 0;
    
    if( argc < 5){
      Tcl_AppendResult(interp, "dm am: need more parameters\n",
		       "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
      return TCL_ERROR;
    }

    buttonpress = atoi(argv[2]);
    ((struct x_vars *)dm_vars)->omx = atoi(argv[3]);
    ((struct x_vars *)dm_vars)->omy = atoi(argv[4]);

    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	am_mode = ALT_MOUSE_MODE_ROTATE;
	break;
      case 't':
	am_mode = ALT_MOUSE_MODE_TRANSLATE;

	if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	   (edobj || es_edflag > 0)){
	  fastf_t fx, fy;

	  bu_vls_init(&vls);
	  fx = (((struct x_vars *)dm_vars)->omx/
		(fastf_t)((struct x_vars *)dm_vars)->width - 0.5) * 2;
	  fy = (0.5 - ((struct x_vars *)dm_vars)->omy/
		(fastf_t)((struct x_vars *)dm_vars)->height) * 2;
	  bu_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	  (void)cmdline(&vls, FALSE);
	  bu_vls_free(&vls);
	}

	break;
      case 'z':
	am_mode = ALT_MOUSE_MODE_ZOOM;
	break;
      default:
	Tcl_AppendResult(interp, "dm am: need more parameters\n",
			 "dm am <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
    }else{
      am_mode = ALT_MOUSE_MODE_IDLE;
    }

    return status;
  }

  Tcl_AppendResult(interp, "dm: bad command - ", argv[0], "\n", (char *)NULL);
  return TCL_ERROR;
}

static void
x_var_init()
{
  dm_vars = bu_malloc(sizeof(struct x_vars), "x_var_init: x_vars");
  bzero((void *)dm_vars, sizeof(struct x_vars));
  ((struct x_vars *)dm_vars)->dm_list = curr_dm_list;
  ((struct x_vars *)dm_vars)->perspective_angle = 3;

  /* initialize the modifiable variables */
  ((struct x_vars *)dm_vars)->mvars.dummy_perspective = 1;
}

static void
X_load_startup()
{
  char *filename;

  bzero((void *)&head_x_vars, sizeof(struct x_vars));
  BU_LIST_INIT( &head_x_vars.l );

  if((filename = getenv("DM_X_RCFILE")) != (char *)NULL )
    Tcl_EvalFile(interp, filename);
}


static struct dm_list *
get_dm_list(window)
Window window;
{
  register struct x_vars *p;

  for( BU_LIST_FOR(p, x_vars, &head_x_vars.l) ){
    if(window == p->win)
      return p->dm_list;
  }

  return DM_LIST_NULL;
}

#if TRY_COLOR_CUBE
/* Return the allocated pixel value that most closely represents
the color requested. */
static unsigned long
get_pixel(s_color)
unsigned char	*s_color;
{
  unsigned char	r, g, b;

  get_color_slot(s_color[0], &r);
  get_color_slot(s_color[1], &g);
  get_color_slot(s_color[2], &b);

  return(((struct x_vars *)dm_vars)->pixel[r * 36 + g * 6 + b]);
}

/* get color component value */
static void
get_color_slot(sc, c)
unsigned char sc;
unsigned char *c;
{
  if(sc < 42)
	*c = 0;
  else if(sc < 85)
	*c = 1;
  else if(sc < 127)
	*c = 2;
  else if(sc < 170)
	*c = 3;
  else if(sc < 212)
	*c = 4;
  else
	*c = 5;
}

/* Try to allocate 216 colors. If a color cannot be
allocated, the default foreground color will be used.*/
static void
allocate_color_cube()
{
  int	i = 0;
  XColor	color;

  int r, g, b;

  for(r = 0; r < 65026; r = r + 13005)
    for(g = 0; g < 65026; g = g + 13005)
      for(b = 0; b < 65026; b = b + 13005){
	color.red = (unsigned short)r;
	color.green = (unsigned short)g;
	color.blue = (unsigned short)b;
	if(XAllocColor(((struct x_vars *)dm_vars)->dpy,
		       ((struct x_vars *)dm_vars)->cmap, &color)){
	  if(color.pixel == ((struct x_vars *)dm_vars)->bg)
	    /* that is, if the allocated color is the same as
	       the background color */
	    ((struct x_vars *)dm_vars)->pixel[i++] = ((struct x_vars *)dm_vars)->fg;	/* default foreground color, which may not be black */
	  else
	    ((struct x_vars *)dm_vars)->pixel[i++] = color.pixel;
	}else	/* could not allocate a color */
	  ((struct x_vars *)dm_vars)->pixel[i++] = ((struct x_vars *)dm_vars)->fg;
      }
}
#endif
#endif /* USE_LIBDM */
@


11.50
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.49 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d52 391
a1107 6
void
X_colorchange()
{
	color_soltab();		/* apply colors to the solid table */
}

d1743 1
@


11.49
log
@rt_list ---> bu_list
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.48 1996/09/03 15:48:04 bparker Exp bparker $ (BRL)";
a51 2
extern int dm_pipe[];

d105 1
a105 1
	X_window, X_debug,
d111 3
a113 1
	X_dm
d116 1
a824 4
  /* Only need to do this once */
  if(tkwin == NULL)
    gui_setup();

d832 1
a832 1
  BU_LIST_APPEND(&head_x_vars.l, &((struct x_vars *)curr_dm_list->_dm_vars)->l);
d1257 1
a1257 1
  dm_vars = (char *)bu_malloc(sizeof(struct x_vars), "x_var_init: x_vars");
@


11.48
log
@check in Lee's changes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.47 1996/08/29 23:37:36 butler Exp butler $ (BRL)";
d43 1
a45 1
#include "bu.h"
d127 1
a127 1
  struct rt_list l;
d204 2
a205 2
  if(((struct x_vars *)dm_vars)->l.forw != RT_LIST_NULL)
    RT_LIST_DEQUEUE(&((struct x_vars *)dm_vars)->l);
d209 1
a209 1
  if(RT_LIST_IS_EMPTY(&head_x_vars.l))
d316 1
a316 1
    for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
d832 1
a832 1
  if(RT_LIST_IS_EMPTY(&head_x_vars.l))
d835 1
a835 1
  RT_LIST_APPEND(&head_x_vars.l, &((struct x_vars *)curr_dm_list->_dm_vars)->l);
d1275 1
a1275 1
  RT_LIST_INIT( &head_x_vars.l );
d1288 1
a1288 1
  for( RT_LIST_FOR(p, x_vars, &head_x_vars.l) ){
@


11.47
log
@structparse moved to libbu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.46 1996/08/29 23:10:07 butler Exp butler $ (BRL)";
d1140 1
a1140 1
      bu_structprint("dm_X internal variables", X_vparse,
d1143 2
a1144 2
      bu_vls_name_print( &vls, X_vparse, argv[1],
			 (CONST char *)&((struct x_vars *)dm_vars)->mvars);
d1150 1
a1150 1
      bu_structparse( &vls, X_vparse, (char *)&((struct x_vars *)dm_vars)->mvars);
@


11.46
log
@structparse moved to libbu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.45 1996/08/28 19:44:38 bparker Exp butler $ (BRL)";
d1143 1
a1143 1
      rt_vls_name_print( &vls, X_vparse, argv[1],
@


11.45
log
@move alt_mouse_mode to dm.h and call it _am_mode
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.44 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d45 1
d151 1
a151 1
struct structparse X_vparse[] = {
d1140 1
a1140 1
      rt_structprint("dm_X internal variables", X_vparse,
d1150 1
a1150 1
      rt_structparse( &vls, X_vparse, (char *)&((struct x_vars *)dm_vars)->mvars);
@


11.44
log
@now using libbu
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.43 1996/08/14 20:26:41 bparker Exp bparker $ (BRL)";
a121 1
  int alt_mouse_mode;
a152 1
  {"%d",  1, "alt_mouse_mode", X_MV_O(alt_mouse_mode),establish_am },
d557 2
a558 3
    switch(((struct x_vars *)dm_vars)->mvars.alt_mouse_mode){
    case ALT_MOUSE_MODE_OFF:
    case ALT_MOUSE_MODE_ON:
d1217 1
a1217 1
	((struct x_vars *)dm_vars)->mvars.alt_mouse_mode = ALT_MOUSE_MODE_ROTATE;
d1220 1
a1220 1
	((struct x_vars *)dm_vars)->mvars.alt_mouse_mode = ALT_MOUSE_MODE_TRANSLATE;
d1238 1
a1238 1
	((struct x_vars *)dm_vars)->mvars.alt_mouse_mode = ALT_MOUSE_MODE_ZOOM;
d1246 1
a1246 1
      ((struct x_vars *)dm_vars)->mvars.alt_mouse_mode = ALT_MOUSE_MODE_ON;
a1265 1
  ((struct x_vars *)dm_vars)->mvars.alt_mouse_mode = 1;
@


11.43
log
@more cleanup
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.42 1996/08/02 18:08:35 bparker Exp bparker $ (BRL)";
d208 1
a208 1
  rt_free(dm_vars, "X_close: dm_vars");
d515 1
a515 1
  struct rt_vls cmd;
d555 1
a555 1
    rt_vls_init(&cmd);
d563 1
a563 1
	rt_vls_printf( &cmd, "M 1 %d %d\n", Xx_TO_GED(mx), Xy_TO_GED(my));
d567 1
a567 1
	rt_vls_printf( &cmd, "M 0 %d %d\n", Xx_TO_GED(mx), Xy_TO_GED(my));
d573 1
a573 1
       rt_vls_printf( &cmd, "iknob ax %f ay %f\n",
d585 1
a585 1
	  rt_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy );
d591 1
a591 1
	  rt_vls_printf( &cmd, "iknob aX %f aY %f\n", fx, fy );
d596 1
a596 1
      rt_vls_printf( &cmd, "iknob aS %f\n",
d614 1
a614 1
  rt_vls_free(&cmd);
d821 1
a821 1
  struct rt_vls str;
d824 1
a824 1
  rt_vls_init(&str);
d839 1
a839 1
  rt_vls_printf(&pathName, ".dm_x%d", count++);
d843 1
a843 1
						       rt_vls_addr(&pathName), name);
d849 2
a850 2
  rt_vls_strcpy(&str, "init_x ");
  rt_vls_printf(&str, "%s\n", rt_vls_addr(&pathName));
d853 1
a853 1
    rt_vls_free(&str);
d857 1
a857 1
  rt_vls_free(&str);
d1079 1
a1079 1
  rt_vls_printf( &dm_values.dv_string,
d1102 1
a1102 1
    rt_vls_printf( &dm_values.dv_string,
d1126 1
a1126 1
  struct rt_vls   vls;
d1134 1
a1134 1
    struct rt_vls tmp_vls;
d1136 2
a1137 2
    rt_vls_init(&vls);
    rt_vls_init(&tmp_vls);
d1147 1
a1147 1
      rt_log( "%s\n", rt_vls_addr(&vls) );
d1149 3
a1151 3
      rt_vls_printf( &vls, "%s=\"", argv[1] );
      rt_vls_from_argv( &vls, argc-2, argv+2 );
      rt_vls_putc( &vls, '\"' );
d1155 1
a1155 1
    rt_vls_free(&vls);
d1158 2
a1159 2
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d1188 2
a1189 2
    rt_vls_init(&vls);
    rt_vls_printf(&vls, "M %s %d %d\n", argv[2],
d1192 1
a1192 1
    rt_vls_free(&vls);
d1229 1
a1229 1
	  rt_vls_init(&vls);
d1234 1
a1234 1
	  rt_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
d1236 1
a1236 1
	  rt_vls_free(&vls);
d1262 1
a1262 1
  dm_vars = (char *)rt_malloc(sizeof(struct x_vars), "x_var_init: x_vars");
@


11.42
log
@using a color cube to attempt to draw solids
using a color close to their desired color
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.41 1996/07/25 17:45:09 bparker Exp bparker $ (BRL)";
a209 3
#if 0
  Tk_DeleteGenericHandler(X_doevent, (ClientData)curr_dm_list);
#else
a211 1
#endif
a840 41
#if 0
  if((tmp_dpy = XOpenDisplay(name)) == NULL){
    rt_vls_free(&str);
    return -1;
  }

  ((struct x_vars *)dm_vars)->width =
      DisplayWidth(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;
  ((struct x_vars *)dm_vars)->height =
      DisplayHeight(tmp_dpy, DefaultScreen(tmp_dpy)) - 20;

  /* Make window square */
  if(((struct x_vars *)dm_vars)->height < ((struct x_vars *)dm_vars)->width)
    ((struct x_vars *)dm_vars)->width = ((struct x_vars *)dm_vars)->height;
  else
    ((struct x_vars *)dm_vars)->height = ((struct x_vars *)dm_vars)->width;

  XCloseDisplay(tmp_dpy);

  /*
   * Create the X drawing window by calling create_x which
   * is defined in xinit.tk
   */
  rt_vls_strcpy(&str, "create_x ");
  rt_vls_printf(&str, "%s %s %d %d\n", name, rt_vls_addr(&pathName),
		((struct x_vars *)dm_vars)->width,
		((struct x_vars *)dm_vars)->height);

  if(cmdline(&str, FALSE) == CMD_BAD){
    rt_vls_free(&str);
    return -1;
  }

  rt_vls_free(&str);

  ((struct x_vars *)dm_vars)->xtkwin = Tk_NameToWindow(interp,
						       rt_vls_addr(&pathName),
						       tkwin);
  ((struct x_vars *)dm_vars)->dpy = Tk_Display(((struct x_vars *)dm_vars)->xtkwin);

#else
d845 4
a849 3
#if 0
  rt_vls_printf(&str, "%s %d\n", rt_vls_addr(&pathName), ((struct x_vars *)dm_vars)->width);
#else
a850 1
#endif
a875 1
#endif
a897 1
#if 1
a899 4
  ((struct x_vars *)dm_vars)->cmap = a_cmap = DefaultColormap(((struct x_vars *)dm_vars)->dpy,
							      a_screen);
#endif
#else
a983 5
#endif

#if 0    
    /* Register the file descriptor with the Tk event handler */
    Tk_CreateGenericHandler(X_doevent, (ClientData)curr_dm_list);
@


11.41
log
@-now using autoloading
-modified the translate/slew interface
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.40 1996/07/19 20:50:18 bparker Exp bparker $ (BRL)";
d60 1
a60 1
static void     establish_vtb();
d86 8
d122 1
a122 1
  int virtual_trackball;
d143 4
d154 1
a154 1
  {"%d",  1, "virtual_trackball", X_MV_O(virtual_trackball),establish_vtb },
d294 2
d297 12
d310 1
d314 4
a317 3
	XSetLineAttributes( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc, 1, LineOnOffDash, CapButt, JoinMiter );
    else
	XSetLineAttributes( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->gc, 1, LineSolid, CapButt, JoinMiter );
d360 1
d366 1
a366 1
		
d563 3
a565 3
    switch(((struct x_vars *)dm_vars)->mvars.virtual_trackball){
    case VIRTUAL_TRACKBALL_OFF:
    case VIRTUAL_TRACKBALL_ON:
d576 1
a576 1
    case VIRTUAL_TRACKBALL_ROTATE:
d581 1
a581 1
    case VIRTUAL_TRACKBALL_TRANSLATE:
d599 1
a599 1
    case VIRTUAL_TRACKBALL_ZOOM:
a619 1
#if 1
d621 1
a621 1
#endif
d943 8
d952 1
d1029 4
d1172 1
a1172 1
establish_vtb()
d1219 1
a1219 1
  if( !strcmp( argv[0], "mouse")){
d1223 2
a1224 2
      Tcl_AppendResult(interp, "dm mouse: need more parameters\n",
		       "mouse button 1|0 xpos ypos\n", (char *)NULL);
d1240 1
a1240 1
      Tcl_AppendResult(interp, "dm mouse: bad button value - ", argv[1], "\n", (char *)NULL);
d1257 3
a1259 3
  if(((struct x_vars *)dm_vars)->mvars.virtual_trackball){
    if( !strcmp( argv[0], "vtb" )){
      int buttonpress;
d1261 1
a1261 1
      scroll_active = 0;
d1263 5
a1267 5
      if( argc < 5){
	Tcl_AppendResult(interp, "dm: need more parameters\n",
			 "vtb <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
	return TCL_ERROR;
      }
d1269 11
d1281 3
a1283 11
      buttonpress = atoi(argv[2]);
      ((struct x_vars *)dm_vars)->omx = atoi(argv[3]);
      ((struct x_vars *)dm_vars)->omy = atoi(argv[4]);

      if(buttonpress){
	switch(*argv[1]){
	case 'r':
	  ((struct x_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ROTATE;
	  break;
	case 't':
	  ((struct x_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_TRANSLATE;
d1285 9
a1293 13
	  if((state == ST_S_EDIT || state == ST_O_EDIT) && !EDIT_ROTATE &&
	                  (edobj || es_edflag > 0)){
	    fastf_t fx, fy;

	    rt_vls_init(&vls);
	    fx = (((struct x_vars *)dm_vars)->omx/
	      (fastf_t)((struct x_vars *)dm_vars)->width - 0.5) * 2;
	    fy = (0.5 - ((struct x_vars *)dm_vars)->omy/
		   (fastf_t)((struct x_vars *)dm_vars)->height) * 2;
	    rt_vls_printf( &vls, "knob aX %f aY %f\n", fx, fy);
	    (void)cmdline(&vls, FALSE);
	    rt_vls_free(&vls);
	  }
d1295 4
a1298 4
	  break;
	case 'z':
	  ((struct x_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ZOOM;
	  break;
d1300 2
a1301 2
	Tcl_AppendResult(interp, "dm: need more parameters\n",
			 "vtb <r|t|z> 1|0 xpos ypos\n", (char *)NULL);
a1302 3
	}
      }else{
	((struct x_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ON;
d1304 3
a1307 3
      return status;
    }
  }else{
d1325 1
a1325 1
  ((struct x_vars *)dm_vars)->mvars.virtual_trackball = 1;
d1354 66
@


11.40
log
@calling gui_setup to initalize tk stuff
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.39 1996/06/21 15:57:06 bparker Exp bparker $ (BRL)";
a39 1
#include "./xinit.h"
d49 1
d78 1
a78 1
static int   X_load_startup();
d556 12
a567 4
	fx = (mx/(fastf_t)((struct x_vars *)dm_vars)->width - 0.5) * 2;
	fy = (0.5 - my/(fastf_t)((struct x_vars *)dm_vars)->height) * 2;

	rt_vls_printf( &cmd, "knob aX %f aY %f\n", fx, fy );
d572 2
a573 2
		     ((double)((struct x_vars *)dm_vars)->omy - my)/
		     ((struct x_vars *)dm_vars)->height);
d803 1
a803 2
  if(tkwin == NULL){
#if 1
a804 9
#else
    rt_vls_printf(&str, "loadtk %s\n", name);

    if(cmdline(&str, FALSE) == CMD_BAD){
      rt_vls_free(&str);
      return -1;
    }
#endif
  }
a805 1

d807 2
a808 6
  if(!count){
    if( X_load_startup() ){
      rt_vls_free(&str);
      return -1;
    }
  }
d1240 3
a1242 1
	  {
d1254 1
d1291 1
a1291 1
static int
a1293 3
  FILE    *fp;
  struct rt_vls str;
  char *path;
a1295 2
#define DM_X_RCFILE "xinit.tk"

d1299 2
a1300 41
  /* Start with internal default */
  Tcl_Eval( interp, x_init_str );

  rt_vls_init( &str );

  if((filename = getenv("DM_X_RCFILE")) == (char *)NULL )
    /* Use default file name */
    filename = DM_X_RCFILE;

  if((path = getenv("MGED_LIBRARY")) != (char *)NULL ){
    /* Use MGED_LIBRARY path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL ){
      fclose(fp);
      (void)Tcl_EvalFile( interp, rt_vls_addr(&str) );
    }
  }

  if( (path = getenv("HOME")) != (char *)NULL )  {
    /* Use HOME path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL ){
	fclose(fp);
	(void)Tcl_EvalFile( interp, rt_vls_addr(&str) );
    }
  }

  /* Check current directory */
  if( (fp = fopen( filename, "r" )) != NULL )  {
    fclose(fp);
    (void)Tcl_EvalFile( interp, filename );
  }

  rt_vls_free(&str);
  return 0;
@


11.39
log
@using multiple command capability of knob
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.38 1996/06/11 17:05:03 bparker Exp bparker $ (BRL)";
d55 1
a55 1
static int	xsetup();
d173 1
a173 1
  return xsetup(dname);
d778 1
a778 1
xsetup( name )
d796 3
d805 1
@


11.38
log
@now loading all resource files
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.37 1996/05/24 18:45:09 bparker Exp bparker $ (BRL)";
d81 1
a81 1
static Tk_GenericProc Xdoevent;
d83 1
a83 1
static int Xdoevent();
d199 1
a199 1
  Tk_DeleteGenericHandler(Xdoevent, (ClientData)curr_dm_list);
d202 1
a202 1
    Tk_DeleteGenericHandler(Xdoevent, (ClientData)NULL);
d481 1
a481 1
Xdoevent(clientData, eventPtr)
a493 1
#if 1
a494 3
#endif

#if 1
a499 4
#else
  curr_dm_list = (struct dm_list *)clientData;
#endif

a529 6
#if 0
    if ( !XdoMotion &&
	 (VIRTUAL_TRACKBALL_NOT_ACTIVE(struct x_vars *, mvars.virtual_trackball)) )
      goto end;
#endif

d548 1
a548 1
       rt_vls_printf( &cmd, "iknob ax %f; iknob ay %f\n",
d559 1
a559 15
	if(fx > 0.000001)
	  fx += SL_TOL;
	else if(fx < 0.000001)
	  fx += -SL_TOL;
	else
	  fx = 0.0;

	if(fy > 0.000001)
	  fy += SL_TOL;
	else if(fy < 0.000001)
	  fy += -SL_TOL;
	else
	  fy = 0.0;

	rt_vls_printf( &cmd, "knob aX %f; knob aY %f\n", fx, fy );
d563 1
a563 1
      rt_vls_printf( &cmd, "zoom %lf",
d565 1
a565 1
		     ((struct x_vars *)dm_vars)->height + 1.0);
d814 1
a814 1
    Tk_CreateGenericHandler(Xdoevent, (ClientData)NULL);
d1001 1
a1001 1
    Tk_CreateGenericHandler(Xdoevent, (ClientData)curr_dm_list);
a1242 1
#if 1
d1251 1
a1251 16

	    if(fx > 0.000001)
	      fx += SL_TOL;
	    else if(fx < 0.000001)
	      fx += -SL_TOL;
	    else
	      fx = 0.0;

	    if(fy > 0.000001)
	      fy += SL_TOL;
	    else if(fy < 0.000001)
	      fy += -SL_TOL;
	    else
	      fy = 0.0;

	    rt_vls_printf( &vls, "knob aX %f; knob aY %f\n", fx, fy);
a1254 13
#else
	  sprintf(xstr, "%f", ((double)((struct x_vars *)dm_vars)->omx/
			       ((struct x_vars *)dm_vars)->width - 0.5) * 2);
	  sprintf(ystr, "%f", (0.5 - (double)((struct x_vars *)dm_vars)->omy/
			       ((struct x_vars *)dm_vars)->height) * 2);
	  sprintf(zstr, "%f", tran_z);

	  av[0] = "tran";
	  av[1] = xstr;
	  av[2] = ystr;
	  av[3] = zstr;
	  status = f_tran((ClientData)NULL, interp, 4, av);
#endif
@


11.37
log
@attempting to make commands/sliders/mouse-interactions
compatible.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.36 1996/05/16 20:59:26 bparker Exp bparker $ (BRL)";
a1354 1
  int     found;
d1361 3
a1363 1
  found = 0;
d1376 4
a1379 2
    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
d1382 5
a1386 6
  if(!found){
    if( (path = getenv("HOME")) != (char *)NULL )  {
      /* Use HOME path */
      rt_vls_strcpy( &str, path );
      rt_vls_strcat( &str, "/" );
      rt_vls_strcat( &str, filename );
d1388 3
a1390 2
      if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
	found = 1;
d1394 4
a1397 23
  if( !found ) {
    /* Check current directory */
    if( (fp = fopen( filename, "r" )) != NULL )  {
      rt_vls_strcpy( &str, filename );
      found = 1;
    }
  }

  if(!found){
    rt_vls_free(&str);

    /* Using default */
    if(Tcl_Eval( interp, x_init_str ) == TCL_ERROR)
      return -1;

    return 0;
  }

  fclose( fp );

  if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
    rt_vls_free(&str);
    return -1;
@


11.36
log
@modifying sliders
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.35 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d562 3
a564 3
      rt_vls_printf( &cmd, "irot %f %f 0\n",
		     (double)(my - ((struct x_vars *)dm_vars)->omy)/2.0,
		     (double)(mx - ((struct x_vars *)dm_vars)->omx)/2.0);
d567 22
a588 3
      rt_vls_printf( &cmd, "tran %f %f %f",
		     ((double)mx/((struct x_vars *)dm_vars)->width - 0.5) * 2,
		     (0.5 - (double)my/((struct x_vars *)dm_vars)->height) * 2, tran_z);
d1271 3
d1275 25
d1311 1
a1311 1

@


11.35
log
@Still Tcl'ing the code
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.34 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d125 1
d538 1
d542 1
d551 9
a559 3
      /* trackball not active so do the regular thing */
      /* Constant tracking (e.g. illuminate mode) bound to M mouse */
      rt_vls_printf( &cmd, "M 0 %d %d\n", Xx_TO_GED(mx), Xy_TO_GED(my));
d1191 21
a1211 3
    if( argc < 4){
      Tcl_AppendResult(interp, "dm: need more parameters\n",
		       "mouse 1|0 xpos ypos\n", (char *)NULL);
d1216 2
a1217 2
    rt_vls_printf(&vls, "M %s %d %d\n", argv[1],
		  Xx_TO_GED(atoi(argv[2])), Xy_TO_GED(atoi(argv[3])));
d1232 2
@


11.34
log
@still tcl-converting
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.33 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d550 1
a550 3
      rt_vls_printf( &cmd, "M 0 %d %d\n",
		     (mx/(double)((struct x_vars *)dm_vars)->width - 0.5) * 4095,
		     (0.5 - my/(double)((struct x_vars *)dm_vars)->height) * 4095);
a1161 1
      rt_log("%s", rt_vls_addr(&vls) );
a1186 3
#if 0
    sprintf(xstr, "%d", Xx_TO_GED(atoi(argv[2])));
    sprintf(ystr, "%d", Xy_TO_GED(atoi(argv[3])));
a1187 6
    av[0] = "M";
    av[1] = argv[1];
    av[2] = xstr;
    av[3] = ystr;
    return f_mouse((ClientData)NULL, interp, 4, av);
#else
a1197 1
#endif
@


11.33
log
@convert commands to Tcl
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.32 1996/03/22 23:00:17 bparker Exp bparker $ (BRL)";
a123 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a124 1
#endif
a167 1
#if 1
a173 31
#else
X_open()
{
  char	line[82];
  char	hostname[80];
  char	display[82];
  char	*envp;

  x_var_init();
  rt_vls_init(&pathName);

  /* get or create the default display */
  if( (envp = getenv("DISPLAY")) == NULL ) {
    /* Env not set, use local host */
    gethostname( hostname, 80 );
    hostname[79] = '\0';
    (void)sprintf( display, "%s:0", hostname );
    envp = display;
  }

  rt_log("X Display [%s]? ", envp );
  (void)fgets( line, sizeof(line), stdin );
  line[strlen(line)-1] = '\0';		/* remove newline */
  if( feof(stdin) )  quit();
  if( line[0] != '\0' ) {
    if( xsetup(line) )
      return(1);		/* BAD */
  } else {
    if( xsetup(envp) )
      return(1);	/* BAD */
  }
a174 3
  return(0);			/* OK */
}
#endif
a185 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a187 1
#endif
a212 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a220 3
#else
  XClearWindow(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win);
#endif
a231 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
d236 1
a236 1
#endif
a351 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a352 3
#else
		    XDrawSegments( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, ((struct x_vars *)dm_vars)->gc, segbuf, nseg );
#endif
a365 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a366 3
#else
			XDrawSegments( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, ((struct x_vars *)dm_vars)->gc, segbuf, nseg );
#endif
a375 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a376 3
#else
	XDrawSegments( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, ((struct x_vars *)dm_vars)->gc, segbuf, nseg );
#endif
a388 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a389 3
#else
	    XDrawSegments( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, ((struct x_vars *)dm_vars)->gc, segbuf, nseg );
#endif
a524 3
#if 0
    dmaflag = 1;
#else
a525 1
#endif
a528 4
#if 0
    ((struct x_vars *)dm_vars)->height = eventPtr->xconfigure.height;
    ((struct x_vars *)dm_vars)->width = eventPtr->xconfigure.width;
#endif
a530 3
#if 0
    dmaflag = 1;
#else
a531 1
#endif
a548 3
      mx = (mx/(double)((struct x_vars *)dm_vars)->width - 0.5) * 4095;
      my = (0.5 - my/(double)((struct x_vars *)dm_vars)->height) * 4095;

d550 3
a552 1
      rt_vls_printf( &cmd, "M 0 %d %d\n", mx, my );
d574 2
a575 1
    XGetWindowAttributes( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, &xwa);
a734 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a735 3
#else
		((struct x_vars *)dm_vars)->win,
#endif
a738 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a739 3
#else
	       ((struct x_vars *)dm_vars)->win,
#endif
a756 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a757 3
#else
	       ((struct x_vars *)dm_vars)->win,
#endif
a908 1
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
a911 1
#endif
@


11.32
log
@modified the open routine to accommodate new attach command\
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.31 1996/03/22 18:39:46 bparker Exp bparker $ (BRL)";
d171 1
a171 2
X_open(name)
char *name;
a173 4
  rt_vls_init(&pathName);

  if( xsetup(name) )
    return(1);		/* BAD */
d175 1
a175 1
  return(0);			/* OK */
d231 3
a233 1
  RT_LIST_DEQUEUE(&((struct x_vars *)dm_vars)->l);
d235 1
a235 1
  rt_vls_free(&pathName);
d551 1
a562 2
  if(((struct x_vars *)dm_vars)->mvars.debug)
    rt_log("curr_dm_list: %d\n", (int)curr_dm_list);
d654 1
a654 1
  (void)cmdline(&cmd, FALSE);
d660 4
a663 1
  return TCL_OK;
d699 1
a699 1
	return;
d707 1
a707 1
	return( 0 );
d717 1
a717 2
	rt_log("X_load(x%x, %d.)\n", addr, count );
	return( 0 );
d747 3
a749 2
	    rt_log("X_statechange: unknown state %s\n", state_str[b]);
	    break;
d770 2
a771 2
	XFlush(((struct x_vars *)dm_vars)->dpy);
	rt_log("flushed\n");
a955 1
  rt_log("pathname = %s\n", rt_vls_addr(&pathName));
a957 1

d1012 1
a1012 1
    rt_log( "dm-X: Can't Allocate red\n");
d1024 2
a1025 2
	rt_log( "dm-X: Can't Allocate yellow\n");
	return -1;
d1036 2
a1037 2
	rt_log( "dm-X: Can't Allocate blue\n");
	return -1;
d1048 2
a1049 2
	rt_log( "dm-X: Can't Allocate gray\n");
	return -1;
d1115 2
a1116 1
	rt_log( "dm-X: Can't open font '%s' or '%s'\n", FONT9, FONTBACK );
d1233 5
d1240 2
d1243 2
d1263 5
a1267 1
    return CMD_OK;
a1270 3
    int up;
    int xpos, ypos;

d1272 3
a1274 3
      rt_log("dm: need more parameters\n");
      rt_log("mouse 1|0 xpos ypos\n");
      return CMD_BAD;
d1276 18
d1295 2
a1296 7
    up = atoi(argv[1]);
    xpos = atoi(argv[2]);
    ypos = atoi(argv[3]);

    rt_vls_printf(&dm_values.dv_string, "M %d %d %d\n",
		  up, Xx_TO_GED(xpos), Xy_TO_GED(ypos));
    return CMD_OK;
d1299 1
d1301 2
a1302 2
  if( !strcmp( argv[0], "vtb" )){
    int buttonpress;
d1304 5
a1308 6
    if( argc < 5){
      rt_log("dm: need more parameters\n");
      rt_log("vtb <r|t|z> 1|0 xpos ypos\n");
      return CMD_BAD;
    }

a1309 13
    buttonpress = atoi(argv[2]);
    ((struct x_vars *)dm_vars)->omx = atoi(argv[3]);
    ((struct x_vars *)dm_vars)->omy = atoi(argv[4]);

    if(buttonpress){
      switch(*argv[1]){
      case 'r':
	((struct x_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ROTATE;
	break;
      case 't':
	{
	  struct rt_vls cmd;
	  rt_vls_init(&cmd);
d1311 10
a1321 5
	  rt_vls_printf( &cmd, "tran %f %f %f",
			 ((double)((struct x_vars *)dm_vars)->omx/
			  ((struct x_vars *)dm_vars)->width - 0.5) * 2,
			 (0.5 - (double)((struct x_vars *)dm_vars)->omy/
			  ((struct x_vars *)dm_vars)->height) * 2, tran_z);
d1323 20
a1342 1
	  (void)cmdline(&cmd, FALSE);
d1344 2
a1345 8
	break;
      case 'z':
	((struct x_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ZOOM;
	break;
      default:
	rt_log("dm: need more parameters\n");
	rt_log("vtb <r|t|z> 1|0 xpos ypos\n");
	return CMD_BAD;
d1347 2
a1348 2
    }else{
      ((struct x_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_ON;
a1349 3

    return CMD_OK;
  }
d1351 1
a1351 1
    return CMD_OK;
d1354 2
a1355 2
  rt_log("dm: bad command - %s\n", argv[0]);
  return CMD_BAD;
d1426 1
a1426 3
    if(Tcl_Eval( interp, x_init_str ) == TCL_ERROR){
      rt_log("X_load_startup: Error interpreting x_init_str.\n");
      rt_log("%s\n", interp->result);
a1427 1
    }
a1434 1
    rt_log("Error reading %s: %s\n", filename, interp->result);
@


11.31
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.30 1996/03/20 22:15:31 bparker Exp bparker $ (BRL)";
d170 13
d216 1
a216 1

@


11.30
log
@*** empty log message ***
@
text
@a0 1
#ifdef MULTI_ATTACH
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.29 1996/03/08 18:23:07 bparker Exp bparker $ (BRL)";
a50 1
#ifdef SEND_KEY_DOWN_PIPE
a51 1
#endif
a59 1
#ifdef VIRTUAL_TRACKBALL
a60 1
#endif
a113 1
#ifdef VIRTUAL_TRACKBALL
a114 1
#endif
a128 1
#ifdef VIRTUAL_TRACKBALL
a129 1
#endif
a142 1
#ifdef VIRTUAL_TRACKBALL
a143 1
#endif
a557 1
#ifdef SEND_KEY_DOWN_PIPE
a573 1
#endif
a597 1
#ifdef VIRTUAL_TRACKBALL
a636 12
#else
    int	x, y;

    if ( !XdoMotion )
      return TCL_OK;

    x = (eventPtr->xmotion.x/(double)((struct x_vars *)dm_vars)->width - 0.5) * 4095;
    y = (0.5 - eventPtr->xmotion.y/(double)((struct x_vars *)dm_vars)->height) * 4095;
    /* Constant tracking (e.g. illuminate mode) bound to M mouse */
    rt_vls_init(&cmd);
    rt_vls_printf( &cmd, "M 0 %d %d\n", x, y );
#endif
a1209 1
#ifdef VIRTUAL_TRACKBALL
a1214 1
#endif
a1264 1
#ifdef VIRTUAL_TRACKBALL  
a1316 1
#endif
a1415 8
#if 0
  register struct dm_list *p;

  for( RT_LIST_FOR(p, dm_list, &head_dm_list.l) ){
    if(window == ((struct x_vars *)p->_dm_vars)->win)
      return p;
  }
#else
a1421 1
#endif
a1424 1189
#else
/*
 *			D M - X . C
 *
 *  An X Window System interface for MGED.
 *  X11R2.  Color support is yet to be implemented.
 *
 *  Author -
 *	Phillip Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.29 1996/03/08 18:23:07 bparker Exp bparker $ (BRL)";
#endif

#define DO_XSELECTINPUT 1

#include "conf.h"

#include <sys/time.h>		/* for struct timeval */
#include <X11/X.h>
#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif
#if defined(linux)
#	undef   X_NOT_STDC_ENV
#	undef   X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */
#include "tk.h"
#include <X11/Xutil.h>


#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "./ged.h"
#include "./dm.h"
#include "./solid.h"

#ifdef SEND_KEY_DOWN_PIPE
extern int dm_pipe[];
#endif

static void	label();
static void	draw();
static int	xsetup();
static void     establish_perspective();
static void     set_perspective();

/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
int	X_open();
void	X_close();
MGED_EXTERN(void	X_input, (fd_set *input, int noblock) );
void	X_prolog(), X_epilog();
void	X_normal(), X_newrot();
void	X_update();
void	X_puts(), X_2d_line(), X_light();
int	X_object();
unsigned X_cvtvecs(), X_load();
void	X_statechange(), X_viewchange(), X_colorchange();
void	X_window(), X_debug(), X_selectargs();
static int     X_dm();
static int   X_load_startup();

struct dm dm_X = {
	X_open, X_close,
	X_input,
	X_prolog, X_epilog,
	X_normal, X_newrot,
	X_update,
	X_puts, X_2d_line,
	X_light,
	X_object,	X_cvtvecs, X_load,
	X_statechange,
	X_viewchange,
	X_colorchange,
	X_window, X_debug,
	0,				/* no displaylist */
	0,				/* multi-window */
	PLOTBOUND,
	"X", "X Window System (X11)",
	0,
	X_dm
};

extern struct device_values dm_values;	/* values read from devices */
extern Tcl_Interp *interp;
extern Tk_Window tkwin;

/*
 * These variables are visible and modifiable via a "dm set" command.
 */
static int      dummy_perspective = 1;
static int      perspective_mode = 0;	/* Perspective flag */
/* End modifiable variables */

static int perspective_angle = 3;	/* Angle of perspective */
static int perspective_table[] = { 
	30, 45, 60, 90 };

static int height, width;
static Tcl_Interp *xinterp;
static Tk_Window xtkwin;

#if !DO_XSELECTINPUT
static int XdoMotion = 0;
#endif

static Display	*dpy;			/* X display pointer */
static Window	win;			/* X window */
static unsigned long black,gray,white,yellow,red,blue;
static unsigned long bd, bg, fg;   /*color of border, background, foreground */

static GC	gc;			/* X Graphics Context */
static int	is_monochrome = 0;
static XFontStruct *fontstruct;		/* X Font */

static int	no_faceplate = 0;

struct structparse X_vparse[] = {
  {"%d",  1, "perspective",       (int)&perspective_mode, establish_perspective },
  {"%d",  1, "set_perspective",(int)&dummy_perspective,  set_perspective },
  {"",    0,  (char *)0,          0,                      FUNC_NULL }
};

/*
 * Display coordinate conversion:
 *  GED is using -2048..+2048,
 *  X is 0..width,0..height
 */
#define	GED_TO_Xx(x)	(((x)/4096.0+0.5)*width)
#define	GED_TO_Xy(x)	((0.5-(x)/4096.0)*height)
#define Xx_TO_GED(x)    ((int)(((x)/(double)width - 0.5) * 4095))
#define Xy_TO_GED(x)    ((int)((0.5 - (x)/(double)height) * 4095))

/*
 *			X _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
X_open()
{
        char	line[82];
        char	hostname[80];
	char	display[82];
	char	*envp;

	/* get or create the default display */
	if( (envp = getenv("DISPLAY")) == NULL ) {
		/* Env not set, use local host */
		gethostname( hostname, 80 );
		hostname[79] = '\0';
		(void)sprintf( display, "%s:0", hostname );
		envp = display;
	}

	rt_log("X Display [%s]? ", envp );
	(void)fgets( line, sizeof(line), stdin );
	line[strlen(line)-1] = '\0';		/* remove newline */
	if( feof(stdin) )  quit();
	if( line[0] != '\0' ) {
		if( xsetup(line) ) {
			return(1);		/* BAD */
		}
	} else {
		if( xsetup(envp) ) {
			return(1);	/* BAD */
		}
	}

	/* Ignore the old scrollbars and menus */
	mged_variables.show_menu = 0;

	return(0);			/* OK */
}

/*
 *  			X _ C L O S E
 *  
 *  Gracefully release the display.
 */
void
X_close()
{
    XFreeGC(dpy, gc);
    Tk_DestroyWindow(xtkwin);

#if 0
    Tcl_DeleteInterp(xinterp);
#endif

    /* to prevent events being processed after window destroyed */
    win = -1;
}

/*
 *			X _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
void
X_prolog()
{
    if( !dmaflag )
	return;

    XClearWindow(dpy, win);

    /* Put the center point up */
    draw( 0, 0, 0, 0 );
}

/*
 *			X _ E P I L O G
 */
void
X_epilog()
{
    /* Prevent lag between events and updates */
    XSync(dpy, 0);
    return;
}

/*
 *  			X _ N E W R O T
 *  Stub.
 */
/* ARGSUSED */
void
X_newrot(mat)
mat_t mat;
{
	return;
}

/*
 *  			X _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */

/* ARGSUSED */
int
X_object( sp, mat, ratio, white_flag )
register struct solid *sp;
mat_t mat;
double ratio;
int white_flag;
{
    static vect_t   pnt;
    register struct rt_vlist	*vp;
    int useful = 0;
    XSegment segbuf[1024];		/* XDrawSegments list */
    XSegment *segp;			/* current segment */
    XGCValues gcv;
    int	nseg;			        /* number of segments */
    int	x, y;
    int	lastx = 0;
    int	lasty = 0;

    XChangeGC(dpy, gc, GCForeground, &gcv);

    if( sp->s_soldash )
	XSetLineAttributes( dpy, gc, 1, LineOnOffDash, CapButt, JoinMiter );
    else
	XSetLineAttributes( dpy, gc, 1, LineSolid, CapButt, JoinMiter );

    nseg = 0;
    segp = segbuf;
    for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
	register int	i;
	register int	nused = vp->nused;
	register int	*cmd = vp->cmd;
	register point_t *pt = vp->pt;

	/* Viewing region is from -1.0 to +1.0 */
	/* 2^31 ~= 2e9 -- dynamic range of a long int */
	/* 2^(31-11) = 2^20 ~= 1e6 */
	/* Integerize and let the X server do the clipping */
	for( i = 0; i < nused; i++,cmd++,pt++ )  {
	    switch( *cmd )  {
	    case RT_VLIST_POLY_START:
	    case RT_VLIST_POLY_VERTNORM:
		continue;
	    case RT_VLIST_POLY_MOVE:
	    case RT_VLIST_LINE_MOVE:
		/* Move, not draw */
		MAT4X3PNT( pnt, mat, *pt );
		if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
		   pnt[1] < -1e6 || pnt[1] > 1e6 )
		    continue; /* omit this point (ugh) */
		pnt[0] *= 2047;
		pnt[1] *= 2047;
		x = GED_TO_Xx(pnt[0]);
		y = GED_TO_Xy(pnt[1]);
		lastx = x;
		lasty = y;
		continue;
	    case RT_VLIST_POLY_DRAW:
	    case RT_VLIST_POLY_END:
	    case RT_VLIST_LINE_DRAW:
		/* draw */
		MAT4X3PNT( pnt, mat, *pt );
		if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
		   pnt[1] < -1e6 || pnt[1] > 1e6 )
		    continue; /* omit this point (ugh) */
		/* Integerize and let the X server do the clipping */
		/*XXX Color */
		gcv.foreground = fg;
		if( white_flag && !is_monochrome )  {
		    gcv.foreground = white;
		}
		XChangeGC( dpy, gc, GCForeground, &gcv );
		
		pnt[0] *= 2047;
		pnt[1] *= 2047;
		x = GED_TO_Xx(pnt[0]);
		y = GED_TO_Xy(pnt[1]);

		segp->x1 = lastx;
		segp->y1 = lasty;
		segp->x2 = x;
		segp->y2 = y;
		nseg++;
		segp++;
		lastx = x;
		lasty = y;
		useful = 1;
		if( nseg == 1024 ) {
		    XDrawSegments( dpy, win, gc, segbuf, nseg );
		    /* Thicken the drawing, if monochrome */
		    if( white_flag && is_monochrome ) {
			int	i;
			/* XXX - width and height don't work on Sun! */
			/* Thus the following gross hack */
			segp = segbuf;
			for( i = 0; i < nseg; i++ ) {
			    segp->x1++;
			    segp->y1++;
			    segp->x2++;
			    segp->y2++;
			    segp++;
			}
			XDrawSegments( dpy, win, gc, segbuf, nseg );
		    }
		    nseg = 0;
		    segp = segbuf;
		}
		break;
	    }
	}
    }
    if( nseg ) {
	XDrawSegments( dpy, win, gc, segbuf, nseg );
	if( white_flag && is_monochrome ) {
	    int	i;
	    /* XXX - width and height don't work on Sun! */
	    /* Thus the following gross hack */
	    segp = segbuf;
	    for( i = 0; i < nseg; i++ ) {
		segp->x1++;
		segp->y1++;
		segp->x2++;
		segp->y2++;
		segp++;
	    }
	    XDrawSegments( dpy, win, gc, segbuf, nseg );
	}
    }

    return(useful);
}

/*
 *			X _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
X_normal()
{
	return;
}

/*
 *			X _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
void
X_update()
{
    XFlush(dpy);
}

/*
 *			X _ P U T S
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
void
X_puts( str, x, y, size, color )
register char *str;
{
	XGCValues gcv;
	unsigned long fg;

	switch( color )  {
	case DM_BLACK:
		fg = black;
		break;
	case DM_RED:
		fg = red;
		break;
	case DM_BLUE:
		fg = blue;
		break;
	default:
	case DM_YELLOW:
		fg = yellow;
		break;
	case DM_WHITE:
		fg = gray;
		break;
	}
	gcv.foreground = fg;
	XChangeGC( dpy, gc, GCForeground, &gcv );
	label( (double)x, (double)y, str );
}

/*
 *			X _ 2 D _ G O T O
 *
 */
void
X_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
    XGCValues gcv;

    gcv.foreground = yellow;
    XChangeGC( dpy, gc, GCForeground, &gcv );
    if( dashed ) {
	XSetLineAttributes(dpy, gc, 1, LineOnOffDash, CapButt, JoinMiter );
    } else {
	XSetLineAttributes(dpy, gc, 1, LineSolid, CapButt, JoinMiter );
    }
    draw( x1, y1, x2, y2 );
}

int
Xdoevent(clientData, eventPtr)
ClientData clientData;
XEvent *eventPtr;
{
    KeySym key;
    char keybuf[4];
    int cnt;
    XComposeStatus compose_stat;
    XWindowAttributes xwa;

    if (eventPtr->xany.window != win)
	return TCL_OK;

#ifdef SEND_KEY_DOWN_PIPE
    if(mged_variables.send_key && eventPtr->type == KeyPress){
      char buffer[1];

      XLookupString(&(eventPtr->xkey), buffer, 1,
		    (KeySym *)NULL, (XComposeStatus *)NULL);

      write(dm_pipe[1], buffer, 1);
      return TCL_RETURN;
    }
#endif

    if (eventPtr->type == Expose && eventPtr->xexpose.count == 0){
      XGetWindowAttributes( dpy, win, &xwa );
      height = xwa.height;
      width = xwa.width;
      rt_vls_printf( &dm_values.dv_string, "refresh\n" );
    }else if(eventPtr->type == ConfigureNotify){
      XGetWindowAttributes( dpy, win, &xwa );
      height = xwa.height;
      width = xwa.width;
      rt_vls_printf( &dm_values.dv_string, "refresh\n" );
    } else if( eventPtr->type == MotionNotify ) {
	int	x, y;

#if !DO_XSELECTINPUT
	if ( !XdoMotion )
	    return TCL_OK;
#endif

	x = (eventPtr->xmotion.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xmotion.y/(double)height) * 4095;
    	/* Constant tracking (e.g. illuminate mode) bound to M mouse */
	rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y );
    }
#if 0
    else if( eventPtr->type == ButtonPress ) {
	/* There may also be ButtonRelease events */
	int	x, y;
	/* In MGED this is a "penpress" */
	x = (eventPtr->xbutton.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xbutton.y/(double)height) * 4095;
	switch( eventPtr->xbutton.button ) {
	case Button1:
	    /* Left mouse */
	    rt_vls_printf( &dm_values.dv_string, "L 1 %d %d\n", x, y);
	    break;
	case Button2:
	    /* Middle mouse, up to down transition */
	    rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n", x, y);
	    break;
	case Button3:
	    /* Right mouse */
	    rt_vls_printf( &dm_values.dv_string, "R 1 %d %d\n", x, y);
	    break;
	}
    } else if( eventPtr->type == ButtonRelease ) {
	int	x, y;
	x = (eventPtr->xbutton.x/(double)width - 0.5) * 4095;
	y = (0.5 - eventPtr->xbutton.y/(double)height) * 4095;
	switch( eventPtr->xbutton.button ) {
	case Button1:
	    rt_vls_printf( &dm_values.dv_string, "L 0 %d %d\n", x, y);
	    break;
	case Button2:
	    /* Middle mouse, down to up transition */
	    rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y);
	    break;
	case Button3:
	    rt_vls_printf( &dm_values.dv_string, "R 0 %d %d\n", x, y);
	    break;
	}
    } else if( eventPtr->type == KeyPress ) {
	register int i;
	/* Turn these into MGED "buttonpress" or knob functions */
	
	cnt = XLookupString(&eventPtr->xkey, keybuf, sizeof(keybuf),
			    &key, &compose_stat);

	for(i=0 ; i < cnt ; i++){

	    switch( *keybuf ) {
	    case '?':
		rt_log( "\nKey Help Menu:\n\
0	Zero 'knobs'\n\
x	Increase xrot\n\
y	Increase yrot\n\
z	Increase zrot\n\
X	Increase Xslew\n\
Y	Increase Yslew\n\
Z	Increase Zslew\n\
f	Front view\n\
t	Top view\n\
b	Bottom view\n\
l	Left view\n\
r	Right view\n\
R	Rear view\n\
3	35,25 view\n\
4	45,45 view\n\
F	Toggle faceplate\n\
" );
		break;
	    case 'F':
		/* Toggle faceplate on/off */
		no_faceplate = !no_faceplate;
		rt_vls_strcat( &dm_values.dv_string,
			      no_faceplate ?
			      "set faceplate 0\n" :
			      "set faceplate 1\n" );
		break;
	    case '0':
		rt_vls_printf( &dm_values.dv_string, "knob zero\n" );
		break;
	    case 'x':
		/* 6 degrees per unit */
		rt_vls_printf( &dm_values.dv_string, "knob +x 0.1\n" );
		break;
	    case 'y':
		rt_vls_printf( &dm_values.dv_string, "knob +y 0.1\n" );
		break;
	    case 'z':
		rt_vls_printf( &dm_values.dv_string, "knob +z 0.1\n" );
		break;
	    case 'X':
		/* viewsize per unit */
		rt_vls_printf( &dm_values.dv_string, "knob +X 0.1\n" );
		break;
	    case 'Y':
		rt_vls_printf( &dm_values.dv_string, "knob +Y 0.1\n" );
		break;
	    case 'Z':
		rt_vls_printf( &dm_values.dv_string, "knob +Z 0.1\n" );
		break;
	    case 'f':
		rt_vls_strcat( &dm_values.dv_string, "press front\n");
		break;
	    case 't':
		rt_vls_strcat( &dm_values.dv_string, "press top\n");
		break;
	    case 'b':
		rt_vls_strcat( &dm_values.dv_string, "press bottom\n");
		break;
	    case 'l':
		rt_vls_strcat( &dm_values.dv_string, "press left\n");
		break;
	    case 'r':
		rt_vls_strcat( &dm_values.dv_string, "press right\n");
		break;
	    case 'R':
		rt_vls_strcat( &dm_values.dv_string, "press rear\n");
		break;
	    case '3':
		rt_vls_strcat( &dm_values.dv_string, "press 35,25\n");
		break;
	    case '4':
		rt_vls_strcat( &dm_values.dv_string, "press 45,45\n");
		break;
	    default:
		rt_log("dm-X: The key '%c' is not defined\n", key);
		break;
	    }
	}
    }
#endif
    else {
	XGetWindowAttributes( dpy, win, &xwa );
	height = xwa.height;
	width = xwa.width;
    }

    return TCL_OK;
}
	    
/*
 *			X _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 *
 * DEPRECATED 
 *
 */
/* ARGSUSED */
void
X_input( input, noblock )
fd_set		*input;
int		noblock;
{
    return;
}

/* 
 *			X _ L I G H T
 */
/* ARGSUSED */
void
X_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	return;
}

/* ARGSUSED */
unsigned
X_cvtvecs( sp )
struct solid *sp;
{
	return( 0 );
}

/*
 * Loads displaylist
 */
unsigned
X_load( addr, count )
unsigned addr, count;
{
	rt_log("X_load(x%x, %d.)\n", addr, count );
	return( 0 );
}

void
X_statechange( a, b )
int	a, b;
{
	/*
	 *  Based upon new state, possibly do extra stuff,
	 *  including enabling continuous tablet tracking,
	 *  object highlighting
	 */
#if DO_XSELECTINPUT
 	switch( b )  {
	case ST_VIEW:
	  /* constant tracking OFF */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask);
	  break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	  /* constant tracking ON */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask|PointerMotionMask);
	  break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	  /* constant tracking OFF */
	  XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask);
	  break;
#else
 	switch( b )  {
	case ST_VIEW:
	    /* constant tracking OFF */
	    XdoMotion = 0;
	    break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	    /* constant tracking ON */
	    XdoMotion = 1;
	    break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	    /* constant tracking OFF */
	    XdoMotion = 0;
	    break;
#endif
	default:
	    rt_log("X_statechange: unknown state %s\n", state_str[b]);
	    break;
	}

	/*X_viewchange( DM_CHGV_REDO, SOLID_NULL );*/
}

void
X_viewchange()
{
}

void
X_colorchange()
{
	color_soltab();		/* apply colors to the solid table */
}

/* ARGSUSED */
void
X_debug(lvl)
{
	XFlush(dpy);
	rt_log("flushed\n");
}

void
X_window(w)
register int w[];
{
#if 0
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
#endif
}

/*********XXX**********/
/*
 *  Called for 2d_line, and dot at center of screen.
 */
static void
draw( x1, y1, x2, y2 )
int	x1, y1;		/* from point */
int	x2, y2;		/* to point */
{
	int	sx1, sy1, sx2, sy2;

	sx1 = GED_TO_Xx( x1 );
	sy1 = GED_TO_Xy( y1 );
	sx2 = GED_TO_Xx( x2 );
	sy2 = GED_TO_Xy( y2 );

	if( sx1 == sx2 && sy1 == sy2 )
		XDrawPoint( dpy, win, gc, sx1, sy1 );
	else
		XDrawLine( dpy, win, gc, sx1, sy1, sx2, sy2 );
}

static void
label( x, y, str )
double	x, y;
char	*str;
{
	int	sx, sy;

	sx = GED_TO_Xx( x );
	sy = GED_TO_Xy( y );
	/* point is center of text? - seems like what MGED wants... */
	/* The following makes the menu look good, the rest bad */
	/*sy += (fontstruct->max_bounds.ascent + fontstruct->max_bounds.descent)/2;*/

	XDrawString( dpy, win, gc, sx, sy, str, strlen(str) );
}

#define	FONT	"6x10"
#define FONT2	"-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1"

static XWMHints xwmh = {
        StateHint,		        /* flags */
	0,				/* input */
	NormalState,			/* initial_state */
	0,				/* icon pixmap */
	0,				/* icon window */
	0, 0,				/* icon location */
	0,				/* icon mask */
	0				/* Window group */
};

static int
xsetup( name )
char	*name;
{
    char *cp;
    XGCValues gcv;
    XColor a_color;
    Visual *a_visual;
    int a_screen;
    Colormap  a_cmap;
    struct rt_vls str;

    width = height = 512;

#if 0
    xinterp = Tcl_CreateInterp(); /* Dummy interpreter */
    xtkwin = Tk_CreateMainWindow(xinterp, name, "MGED", "MGED");
#else
    rt_vls_init(&str);
    rt_vls_printf(&str, "loadtk %s\n", name);

    if(tkwin == NULL){
      if(cmdline(&str, FALSE) == CMD_BAD){
	rt_vls_free(&str);
	return -1;
      }
    }

    rt_vls_free(&str);

    /* Use interp with all its registered commands. */
#if 1
    /* Make xtkwin a toplevel window */
    xtkwin = Tk_CreateWindow(interp, tkwin, "mged", name);
#else
    /* Make xtkwin an internal window */
    xtkwin = Tk_CreateWindow(interp, tkwin, "mged", NULL);
#endif

#if 1
    if( X_load_startup() ){
      rt_log( "xsetup: Error loading startup file\n");
      return -1;
    }
#else
/*XXX* Temporary */
    Tcl_EvalFile(interp, "/m/cad/mged/sample_bindings");
#endif
#endif

    /* Open the display - XXX see what NULL does now */
    if( xtkwin == NULL ) {
	rt_log( "dm-X: Can't open X display\n" );
	return -1;
    }

    dpy = Tk_Display(xtkwin);
    
    Tk_GeometryRequest(xtkwin, width+10, height+10);
    Tk_MakeWindowExist(xtkwin);

    win = Tk_WindowId(xtkwin);

    /* Get colormap indices for the colors we use. */

    a_screen = Tk_ScreenNumber(xtkwin);
    a_visual = Tk_Visual(xtkwin);

    /* Get color map inddices for the colors we use. */
    black = BlackPixel( dpy, a_screen );
    white = WhitePixel( dpy, a_screen );

    a_cmap = Tk_Colormap(xtkwin);
    a_color.red = 255<<8;
    a_color.green=0;
    a_color.blue=0;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
	rt_log( "dm-X: Can't Allocate red\n");
	return -1;
    }
    red = a_color.pixel;
    if ( red == white ) red = black;

    a_color.red = 200<<8;
    a_color.green=200<<8;
    a_color.blue=0<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
	rt_log( "dm-X: Can't Allocate yellow\n");
	return -1;
    }
    yellow = a_color.pixel;
    if (yellow == white) yellow = black;
    
    a_color.red = 0;
    a_color.green=0;
    a_color.blue=255<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
	rt_log( "dm-X: Can't Allocate blue\n");
	return -1;
    }
    blue = a_color.pixel;
    if (blue == white) blue = black;

    a_color.red = 128<<8;
    a_color.green=128<<8;
    a_color.blue= 128<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
	rt_log( "dm-X: Can't Allocate gray\n");
	return -1;
    }
    gray = a_color.pixel;
    if (gray == white) gray = black;

    /* Select border, background, foreground colors,
     * and border width.
     */
    if( a_visual->class == GrayScale || a_visual->class == StaticGray )  {
	is_monochrome = 1;
	bd = BlackPixel( dpy, a_screen );
	bg = WhitePixel( dpy, a_screen );
	fg = BlackPixel( dpy, a_screen );
    } else {
	/* Hey, it's a color server.  Ought to use 'em! */
	is_monochrome = 0;
	bd = WhitePixel( dpy, a_screen );
	bg = BlackPixel( dpy, a_screen );
	fg = WhitePixel( dpy, a_screen );
    }

    if( !is_monochrome && fg != red && red != black )  fg = red;

    gcv.foreground = fg;
    gcv.background = bg;

#ifndef CRAY2
    cp = FONT;
    if ((fontstruct = XLoadQueryFont(dpy, cp)) == NULL ) {
	/* Try hardcoded backup font */
	if ((fontstruct = XLoadQueryFont(dpy, FONT2)) == NULL) {
	    rt_log( "dm-X: Can't open font '%s' or '%s'\n", cp, FONT2 );
	    return -1;
	}
    }
    gcv.font = fontstruct->fid;
    gc = XCreateGC(dpy, win, (GCFont|GCForeground|GCBackground), &gcv);
#else
    gc = XCreateGC(dpy, win, (GCForeground|GCBackground), &gcv);
#endif
    
    /* Register the file descriptor with the Tk event handler */
#if 0
    Tk_CreateEventHandler(xtkwin, ExposureMask|ButtonPressMask|KeyPressMask|
			  PointerMotionMask
/*			  |StructureNotifyMask|FocusChangeMask */,
			  (void (*)())Xdoevent, (ClientData)NULL);

#else
    Tk_CreateGenericHandler(Xdoevent, (ClientData)NULL);

#if DO_XSELECTINPUT
    /* start with constant tracking OFF */
    XSelectInput(dpy, win, ExposureMask|ButtonPressMask|
		 KeyPressMask|StructureNotifyMask);
#endif

#endif

    Tk_SetWindowBackground(xtkwin, bg);
    Tk_MapWindow(xtkwin);
    return 0;
}

static void
establish_perspective()
{
  rt_vls_printf( &dm_values.dv_string,
		"set perspective %d\n",
		perspective_mode ?
		perspective_table[perspective_angle] :
		-1 );
  dmaflag = 1;
}

/*
   This routine will toggle the perspective_angle if the
   dummy_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (dummy_perspective - 1).
*/
static void
set_perspective()
{
  /* set perspective matrix */
  if(dummy_perspective > 0)
    perspective_angle = dummy_perspective <= 4 ? dummy_perspective - 1: 3;
  else if (--perspective_angle < 0) /* toggle perspective matrix */
    perspective_angle = 3;

  if(perspective_mode)
    rt_vls_printf( &dm_values.dv_string,
		  "set perspective %d\n",
		  perspective_table[perspective_angle] );

  /*
     Just in case the "!" is used with the set command. This
     allows us to toggle through more than two values.
   */
  dummy_perspective = 1;

  dmaflag = 1;
}

static int
X_dm(argc, argv)
int argc;
char *argv[];
{
  struct rt_vls   vls;

  if( !strcmp( argv[0], "set" )){
    rt_vls_init(&vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      rt_structprint("dm_X internal variables", X_vparse, (char *)0 );
      rt_log("%s", rt_vls_addr(&vls) );
    } else if( argc == 2 ) {
      rt_vls_name_print( &vls, X_vparse, argv[1], (char *)0 );
      rt_log( "%s\n", rt_vls_addr(&vls) );
    } else {
      rt_vls_printf( &vls, "%s=\"", argv[1] );
      rt_vls_from_argv( &vls, argc-2, argv+2 );
      rt_vls_putc( &vls, '\"' );
      rt_structparse( &vls, X_vparse, (char *)0 );
    }

    rt_vls_free(&vls);
    return CMD_OK;
  }

  if( !strcmp( argv[0], "mouse")){
    int up;
    int xpos, ypos;

    if( argc < 4){
      rt_log("dm: need more parameters\n");
      rt_log("mouse 1|0 xpos ypos\n");
      return CMD_BAD;
    }

    up = atoi(argv[1]);
    xpos = atoi(argv[2]);
    ypos = atoi(argv[3]);

    rt_vls_printf(&dm_values.dv_string, "M %d %d %d\n",
		  up, Xx_TO_GED(xpos), Xy_TO_GED(ypos));
    return CMD_OK;
  }

  rt_log("dm: bad command - %s\n", argv[0]);
  return CMD_BAD;
}

static int
X_load_startup()
{
  FILE    *fp;
  struct rt_vls str;
  char *path;
  char *filename;
  int     found;

#define DM_X_RCFILE "sample_bindings"

  found = 0;
  rt_vls_init( &str );

  if((filename = getenv("DM_X_RCFILE")) == (char *)NULL )
    /* Use default file name */
    filename = DM_X_RCFILE;

  if((path = getenv("MGED_LIBRARY")) != (char *)NULL ){
    /* Use MGED_LIBRARY path */
    rt_vls_strcpy( &str, path );
    rt_vls_strcat( &str, "/" );
    rt_vls_strcat( &str, filename );

    if ((fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
  }

  if(!found){
    if( (path = getenv("HOME")) != (char *)NULL )  {
      /* Use HOME path */
      rt_vls_strcpy( &str, path );
      rt_vls_strcat( &str, "/" );
      rt_vls_strcat( &str, filename );

      if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
	found = 1;
    }
  }

  if( !found ) {
    /* Check current directory */
    if( (fp = fopen( filename, "r" )) != NULL )  {
      rt_vls_strcpy( &str, filename );
      found = 1;
    }
  }

  if(!found){
    rt_vls_free(&str);
    return -1;
  }

  fclose( fp );

  if (Tcl_EvalFile( interp, rt_vls_addr(&str) ) == TCL_ERROR) {
    rt_log("Error reading %s: %s\n", filename, interp->result);
    rt_vls_free(&str);
    return -1;
  }

  rt_vls_free(&str);
  return 0;
}
#endif
@


11.29
log
@added code to find an appropriate font for
the given window size. This approach was lifted
from dm-ogl.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.28 1996/03/01 21:36:37 bparker Exp bparker $ (BRL)";
d570 1
a570 1
  if(curr_dm_list->_mged_variables.send_key && eventPtr->type == KeyPress){
d589 1
d591 3
d602 2
d605 3
d1484 1
a1484 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.28 1996/03/01 21:36:37 bparker Exp bparker $ (BRL)";
@


11.28
log
@not done, just playing it safe
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.27 1996/02/26 21:59:58 bparker Exp bparker $ (BRL)";
d62 1
d189 2
d593 1
d596 2
a597 1

d850 6
a855 2
#define	FONT	"6x10"
#define FONT2	"-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1"
a883 1
  rt_vls_init(&pathName);
a1084 13

#ifndef CRAY2
    cp = FONT;
    if ( (((struct x_vars *)dm_vars)->fontstruct =
	 XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, cp)) == NULL ) {
      /* Try hardcoded backup font */
      if ( (((struct x_vars *)dm_vars)->fontstruct =
	    XLoadQueryFont(((struct x_vars *)dm_vars)->dpy, FONT2)) == NULL) {
	rt_log( "dm-X: Can't open font '%s' or '%s'\n", cp, FONT2 );
	return -1;
      }
    }
    gcv.font = ((struct x_vars *)dm_vars)->fontstruct->fid;
a1086 5
					       (GCFont|GCForeground|GCBackground),
						&gcv);
#else
    ((struct x_vars *)dm_vars)->gc = XCreateGC(((struct x_vars *)dm_vars)->dpy,
`					       ((struct x_vars *)dm_vars)->win,
d1089 3
d1106 83
a1366 1
#if 1
a1368 1
#endif
d1475 1
a1475 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.27 1996/02/26 21:59:58 bparker Exp bparker $ (BRL)";
@


11.27
log
@just a little clean up
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.25 1996/02/09 22:18:23 bparker Exp bparker $ (BRL)";
d121 1
d125 2
d138 1
d150 1
a150 1
  {"%d",  1, "set_perspective", X_MV_O(dummy_perspective),  set_perspective },
d154 2
a155 1
  {"",    0,  (char *)0,          0,                      FUNC_NULL }
a157 1
static int perspective_angle = 3;	/* Angle of perspective */
d161 1
d231 1
a231 2
#if 1
  Tk_DeleteGenericHandler(Xdoevent, (ClientData)curr_dm_list);
d234 2
d237 2
a238 2
  /* to prevent events being processed after window destroyed */
  win = -1;
d550 1
d552 1
d554 1
d560 4
a563 6
#if 0
  /* Not interested */
  if (eventPtr->xany.window != ((struct x_vars *)dm_vars)->win){
    curr_dm_list = save_dm_list;
    return TCL_OK;
  }
d567 1
a567 1
  if(mged_variables.send_key && eventPtr->type == KeyPress){
d569 1
d572 4
a575 1
		  (KeySym *)NULL, (XComposeStatus *)NULL);
d660 1
d662 1
d896 5
d1096 1
a1096 1
					       ((struct x_vars *)dm_vars)->win,
d1100 2
a1101 1
    
d1104 1
d1118 1
a1118 1
		perspective_table[perspective_angle] : -1 );
d1132 1
a1132 1
    perspective_angle = ((struct x_vars *)dm_vars)->mvars.dummy_perspective <= 4 ?
d1134 2
a1135 2
  else if (--perspective_angle < 0) /* toggle perspective matrix */
    perspective_angle = 3;
d1140 1
a1140 1
		  perspective_table[perspective_angle] );
d1272 2
d1275 1
d1277 1
d1291 5
d1363 1
a1364 1
  struct rt_vls str;
d1370 8
d1401 1
a1401 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.25 1996/02/09 22:18:23 bparker Exp bparker $ (BRL)";
@


11.26
log
@double buffering with pixmaps
virtual trackball
@
text
@a23 2
#define DO_XSELECTINPUT 0

d41 1
a41 1

a156 1
#if !DO_XSELECTINPUT
a157 1
#endif
a203 3
  /* Ignore the old scrollbars and menus */
  mged_variables.show_menu = 0;

a566 1

a574 4
    XGetWindowAttributes( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, &xwa);
    ((struct x_vars *)dm_vars)->height = xwa.height;
    ((struct x_vars *)dm_vars)->width = xwa.width;

d579 2
a580 3
    XGetWindowAttributes( ((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, &xwa);
    ((struct x_vars *)dm_vars)->height = xwa.height;
    ((struct x_vars *)dm_vars)->width = xwa.width;
d589 4
d599 2
a600 1
      /* do the regular thing */
a621 3
    case VIRTUAL_TRACKBALL_IGNORE:
    default:
      goto end;
a628 1
#if !DO_XSELECTINPUT
a630 1
#endif
d717 1
a717 25
#if DO_XSELECTINPUT
 	switch( b )  {
	case ST_VIEW:
	  /* constant tracking OFF */
	  XSelectInput(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask);
	  break;
	case ST_S_PICK:
	case ST_O_PICK:
	case ST_O_PATH:
	  /* constant tracking ON */
	  XSelectInput(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask|PointerMotionMask);
	  break;
	case ST_O_EDIT:
	case ST_S_EDIT:
	  /* constant tracking OFF */
	  XSelectInput(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win, ExposureMask|ButtonPressMask|
		       KeyPressMask|StructureNotifyMask);
	  break;
#else
#ifdef VIRTUAL_TRACKBALL
  if(!((struct x_vars *)dm_vars)->mvars.virtual_trackball){
#endif
 	switch( b )  {
d725 1
a733 1
#endif
a737 3
#ifdef VIRTUAL_TRACKBALL
  }
#endif
d862 1
d874 1
a882 1
  rt_vls_init(&pathName);
a884 4
  /* initialize the modifiable variables */
  ((struct x_vars *)dm_vars)->mvars.dummy_perspective = 1;
  ((struct x_vars *)dm_vars)->mvars.perspective_mode = 0;

a1085 7
#if DO_XSELECTINPUT
    /* start with constant tracking OFF */
    XSelectInput(((struct x_vars *)dm_vars)->dpy,
		 ((struct x_vars *)dm_vars)->win,
		 ExposureMask|ButtonPressMask|KeyPressMask|StructureNotifyMask);
#endif

d1135 1
a1135 15
  if(((struct x_vars *)dm_vars)->mvars.virtual_trackball){
    if(state != ST_S_PICK && state != ST_O_PICK &&
       state != ST_O_PATH && state != ST_S_VPICK){

      /* turn constant tracking ON */
      XdoMotion = 1;
    }
  }else{
    if(state != ST_S_PICK && state != ST_O_PICK &&
       state != ST_O_PATH && state != ST_S_VPICK){

      /* turn constant tracking OFF */
      XdoMotion = 0;
    }    
  }
d1233 1
a1233 1
      ((struct x_vars *)dm_vars)->mvars.virtual_trackball = VIRTUAL_TRACKBALL_IGNORE;
d1252 2
d1306 9
a1314 1
    return -1;
@


11.25
log
@Multibuffering experiment.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.24 1996/01/26 15:52:28 bparker Exp bparker $ (BRL)";
a24 2
#define TRY_PIPES 1
#define TRY_MULTIBUFFERING 0  /* Leave this off. The Multibuffering extension doesn't work */
d54 2
a55 2
#if TRY_PIPES
extern int ged_pipe[];
d64 3
d120 3
d129 2
a130 4
#if TRY_MULTIBUFFERING
  Multibuffer buffers[2];
  Multibuffer curr_buf;
  int doublebuffer;
d134 3
d149 3
d225 5
d251 9
a259 3
#if TRY_MULTIBUFFERING
  if(!((struct x_vars *)dm_vars)->doublebuffer)
    XClearWindow(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win);
d261 1
a261 1
    XClearWindow(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win);
d274 5
a278 11
#if TRY_MULTIBUFFERING
    if(((struct x_vars *)dm_vars)->doublebuffer){
      /* dpy, size of buffer array, buffer array, minimum delay, maximum delay */
      XmbufDisplayBuffers(((struct x_vars *)dm_vars)->dpy, 1,
			  &((struct x_vars *)dm_vars)->curr_buf, 0, 0);

      /* swap buffers */
      ((struct x_vars *)dm_vars)->curr_buf =
	((struct x_vars *)dm_vars)->curr_buf == ((struct x_vars *)dm_vars)->buffers[0] ?
	((struct x_vars *)dm_vars)->buffers[1] : ((struct x_vars *)dm_vars)->buffers[0];
    }
d325 1
d395 3
d399 1
d413 3
d417 1
d427 3
d431 1
d444 3
d448 1
d566 2
a567 2
#if TRY_PIPES
  if(mged_variables.focus && eventPtr->type == KeyPress){
d573 1
a573 1
    write(ged_pipe[1], buffer, 1);
d599 39
d650 1
d751 3
d775 3
d834 3
d838 1
d842 3
d846 1
d864 3
d868 1
d1017 4
a1020 24
#if TRY_MULTIBUFFERING
  if(!XmbufQueryExtension(((struct x_vars *)dm_vars)->dpy,
			  &first_event, &first_error)){
    ((struct x_vars *)dm_vars)->doublebuffer = 0;
    rt_log("xsetup: no multi-buffering extension available on %s\n", name);
  }else{
    int num;

    num = XmbufCreateBuffers(((struct x_vars *)dm_vars)->dpy,
			  ((struct x_vars *)dm_vars)->win, 2,
			  MultibufferUpdateActionBackground,
			  MultibufferUpdateHintFrequent,
			  ((struct x_vars *)dm_vars)->buffers);
    if(num != 2){
      if(num)
	XmbufDestroyBuffers(((struct x_vars *)dm_vars)->dpy,
			    ((struct x_vars *)dm_vars)->win);
      ((struct x_vars *)dm_vars)->doublebuffer = 0;
      rt_log("xsetup: failed to get 2 buffers\n");
    }else{
      ((struct x_vars *)dm_vars)->doublebuffer = 1;
      ((struct x_vars *)dm_vars)->curr_buf = ((struct x_vars *)dm_vars)->buffers[1];
    }
  }
d1181 22
d1252 55
d1333 2
a1334 1
        filename = DM_X_RCFILE;
d1337 1
d1348 1
d1359 1
a1365 10
/*XXX Temporary, so things will work without knowledge of the new environment
      variables */
  if( !found ) {
    rt_vls_strcpy( &str, "/m/cad/mged/");
    rt_vls_strcat( &str, filename);

    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
  }

d1418 1
a1418 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.24 1996/01/26 15:52:28 bparker Exp bparker $ (BRL)";
a1421 1
#define TRY_PIPES 1
d1449 2
a1450 2
#if TRY_PIPES
extern int ged_pipe[];
d1887 2
a1888 2
#if TRY_PIPES
    if(mged_variables.focus && eventPtr->type == KeyPress){
d1894 1
a1894 1
      write(ged_pipe[1], buffer, 1);
d2537 2
a2538 1
        filename = DM_X_RCFILE;
d2541 1
d2552 1
d2563 1
a2567 10
  }

/*XXX Temporary, so things will work without knowledge of the new environment
      variables */
  if( !found ) {
    rt_vls_strcpy( &str, "/m/cad/mged/");
    rt_vls_strcat( &str, filename);

    if( (fp = fopen(rt_vls_addr(&str), "r")) != NULL )
      found = 1;
@


11.24
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.23 1996/01/22 22:50:19 bparker Exp bparker $ (BRL)";
d26 1
d43 2
d125 5
d221 1
d223 1
a223 1
  Tk_DeleteGenericHandler(Xdoevent, (ClientData)curr_dm_list);
d238 6
a243 1
  XClearWindow(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win);
d255 12
d508 1
a508 1
int
d803 1
a884 4
  /*
   * Create the X drawing window by calling create_x which
   * is defined in xinit.tk
   */
d886 3
d890 3
d900 1
d915 3
d929 26
d1070 1
a1124 1
#ifdef MULTI_ATTACH
a1126 3
#else
      rt_structprint("dm_X internal variables", X_vparse, (char *)0 );
#endif
a1128 1
#ifdef MULTI_ATTACH
a1130 3
#else
      rt_vls_name_print( &vls, X_vparse, argv[1], (char *)0 );
#endif
a1135 1
#ifdef MULTI_ATTACH
a1136 3
#else
      rt_structparse( &vls, X_vparse, (char *)0 );
#endif
d1166 1
a1166 1
void
d1173 1
a1173 1
int
d1245 1
a1245 1
struct dm_list *
d1279 1
a1279 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.23 1996/01/22 22:50:19 bparker Exp bparker $ (BRL)";
d1335 2
a1336 1
int     X_dm();
d2157 6
d2166 1
d2333 1
a2333 1
int
d2382 71
@


11.23
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.22 1996/01/19 22:31:40 bparker Exp bparker $ (BRL)";
d214 1
a214 1
  Tk_DeleteGenericHandler(Xdoevent, (ClientData)rt_vls_addr(&pathName));
d496 1
d1000 1
a1000 2
    Tk_CreateGenericHandler(Xdoevent,
			    (ClientData)rt_vls_addr(&pathName));
d1065 4
d1070 1
d1073 4
d1078 1
d1084 3
d1088 1
d1131 1
d1139 3
d1145 1
a1145 1
    rt_vls_strcat( &str, DM_X_RCFILE );
d1155 1
a1155 1
      rt_vls_strcat( &str, DM_X_RCFILE );
d1163 2
a1164 2
    if( (fp = fopen( DM_X_RCFILE, "r" )) != NULL )  {
      rt_vls_strcpy( &str, DM_X_RCFILE );
d1173 1
a1173 1
    rt_vls_strcat( &str, DM_X_RCFILE);
d1187 1
a1187 1
    rt_log("Error reading %s: %s\n", DM_X_RCFILE, interp->result);
d1231 1
a1231 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.22 1996/01/19 22:31:40 bparker Exp bparker $ (BRL)";
@


11.22
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.21 1996/01/17 22:09:01 bparker Exp bparker $ (BRL)";
d24 1
a24 1
#define DO_XSELECTINPUT 1
d143 4
d185 1
a185 2
    if( xsetup(line) ) {
      rt_free(dm_vars, "X_open: dm_vars");
a186 1
    }
d188 1
a188 2
    if( xsetup(envp) ) {
      rt_free(dm_vars, "X_open: dm_vars");
a189 1
    }
d206 1
d208 2
a211 4
#if 0
    Tcl_DeleteInterp(xinterp);
#endif

d213 2
a214 2
    rt_free(dm_vars, "X_close: dm_vars");
    Tk_DeleteGenericHandler(Xdoevent, (ClientData)rt_vls_addr(&pathName));
d216 2
a217 2
    /* to prevent events being processed after window destroyed */
    win = -1;
d229 1
a229 1
    XClearWindow(((struct x_vars *)dm_vars)->dpy, ((struct x_vars *)dm_vars)->win);
d238 3
a242 3

    /* Put the center point up last */
    draw( 0, 0, 0, 0 );
d501 1
d507 1
d529 1
a529 1
#if 1
a532 4
#else
    rt_vls_init(&cmd);
    rt_vls_printf( &cmd, "refresh\n" );
#endif
d537 1
a537 1
#if 1
a540 4
#else
    rt_vls_init(&cmd);
    rt_vls_printf( &cmd, "refresh\n" );
#endif
d546 1
a546 1
      goto end;
a551 1
#if 1
a553 3
#else
    rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n", x, y );
#endif
a554 1
#if 1
d558 1
a558 1
#endif
d854 1
a854 1
  ((struct x_vars *)dm_vars)->xtkwin = Tk_CreateWindow(interp, tkwin,
d861 1
a861 1
  rt_vls_strcpy(&str, "create_x ");
d885 6
d1002 1
d1007 1
d1213 1
a1213 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.21 1996/01/17 22:09:01 bparker Exp bparker $ (BRL)";
@


11.21
log
@using mged_variables.show_menu instead of ignore_scroll_and_menu
@
text
@d1 1
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.20 1996/01/05 22:08:48 bparker Exp bparker $ (BRL)";
d60 1
d80 1195
d2313 1
@


11.20
log
@Just playing it safe
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.19 1995/12/11 22:49:46 bparker Exp bparker $ (BRL)";
d186 1
a186 1
	ignore_scroll_and_menu = 1;
a207 3

    /* Stop ignoring the old scrollbars and menus */
    ignore_scroll_and_menu = 0;
@


11.19
log
@added some error checking
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.18 1995/12/04 22:00:25 bparker Exp bparker $ (BRL)";
d882 5
a886 3
    if(cmdline(&str, FALSE) == CMD_BAD){
      rt_vls_free(&str);
      return -1;
d892 1
a892 1
#if 0
@


11.18
log
@removed focus from dm's set.
set ignore_scroll_and_menu to 1 so that I can ignore the
old menus and scrollbars.
Now using mged_variable.focus
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.17 1995/12/02 00:24:15 bparker Exp bparker $ (BRL)";
d881 6
a886 1
    (void)cmdline(&str, FALSE);
a896 1
#endif
d900 1
@


11.17
log
@added perspective stuff to dm's set command
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.16 1995/11/30 23:12:29 bparker Exp bparker $ (BRL)";
a105 1
static int focus = 0;        /* send key events to the command window */
a135 1
  {"%d",  1, "focus",             (int)&focus,            FUNC_NULL },
d185 3
d201 1
a203 2
#else
    Tcl_DeleteInterp(interp);
d205 6
a210 2
	/* to prevent events being processed after window destroyed */
	win = -1;
d493 1
a493 1
    if(focus && eventPtr->type == KeyPress){
@


11.16
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.15 1995/11/22 17:20:08 bparker Exp bparker $ (BRL)";
d59 2
d103 12
a131 1
static int focus = 0;        /* send key events to the command window */
d135 2
a804 51
int
X_dm(argc, argv)
int argc;
char *argv[];
{
  struct rt_vls   vls;

  if( !strcmp( argv[0], "set" )){
    rt_vls_init(&vls);

    if( argc < 2 )  {
      /* Bare set command, print out current settings */
      rt_structprint("dm_X internal variables", X_vparse, (char *)0 );
      rt_log("%s", rt_vls_addr(&vls) );
    } else if( argc == 2 ) {
      rt_vls_name_print( &vls, X_vparse, argv[1], (char *)0 );
      rt_log( "%s\n", rt_vls_addr(&vls) );
    } else {
      rt_vls_printf( &vls, "%s=\"", argv[1] );
      rt_vls_from_argv( &vls, argc-2, argv+2 );
      rt_vls_putc( &vls, '\"' );
      rt_structparse( &vls, X_vparse, (char *)0 );
    }

    rt_vls_free(&vls);
    return CMD_OK;
  }

  if( !strcmp( argv[0], "mouse")){
    int up;
    int xpos, ypos;

    if( argc < 4){
      rt_log("dm: need more parameters\n");
      rt_log("mouse 1|0 xpos ypos\n");
      return CMD_BAD;
    }

    up = atoi(argv[1]);
    xpos = atoi(argv[2]);
    ypos = atoi(argv[3]);

    rt_vls_printf(&dm_values.dv_string, "M %d %d %d\n",
		  up, Xx_TO_GED(xpos), Xy_TO_GED(ypos));
    return CMD_OK;
  }

  rt_log("dm: bad command - %s\n", argv[0]);
  return CMD_BAD;
}

d1017 90
@


11.15
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/mged/RCS/dm-X.c,v 11.14 1995/11/09 22:28:16 bparker Exp bparker $ (BRL)";
d23 3
d52 4
d104 2
d107 1
d118 1
d121 5
d133 2
a134 3
/*XXX
#define X_TO_GED(x)	(x)
*/
d471 8
a478 1
	return TCL_ERROR;
d480 5
d497 2
d501 2
d710 22
a731 1
	switch( b )  {
d747 1
d795 18
a812 1
/* Experimental */
d814 3
a816 1
  int x,y;
d818 9
a826 2
  if(argc < 3)
    return CMD_BAD;
d828 7
a834 22
  if(sscanf(argv[1], "%d", &x) != 1)
    return CMD_BAD;

  if(sscanf(argv[2], "%d", &y) != 1)
    return CMD_BAD;
  
  x = (x/(double)width - 0.5) * 4095;
  y = (0.5 - y/(double)height) * 4095;

  switch(*argv[0]){
  /* Buttonpress 1,2,3 */
  case '1':
    rt_vls_printf( &dm_values.dv_string, "L 1 %d %d\n", x, y);
    break;
  case '2':
    rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n", x, y);
    break;
  case '3':
    rt_vls_printf( &dm_values.dv_string, "R 1 %d %d\n", x, y);
    break;
  default:
    return CMD_BAD;
d837 2
a838 1
  return CMD_OK;
d912 1
a912 1
    rt_vls_strcpy(&str, "loadtk\n");
d916 3
d920 4
d926 3
d1041 7
@


11.14
log
@stole button and key events for tcl/tk binding
added X_dm for converting button events x,y into GED
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.13 1995/08/24 06:46:36 mike Exp bparker $ (BRL)";
d453 1
d456 1
a456 1
	return 0;
d458 10
a467 8
    if (eventPtr->type == Expose || eventPtr->type == ConfigureNotify) {
	if (eventPtr->xexpose.count == 0) {
            XWindowAttributes xwa;
            XGetWindowAttributes( dpy, win, &xwa );
            height = xwa.height;
            width = xwa.width;
	    rt_vls_printf( &dm_values.dv_string, "refresh\n" );
	}
d471 1
a471 1
	    return 1;
d476 3
a478 1
    } else if( eventPtr->type == ButtonPress ) {
d604 3
a606 2
    } else {
	XWindowAttributes xwa;
a609 1
	return 1;
d612 1
a612 1
    return 1;
d848 1
a848 1
    cmdline(&str, FALSE);
a964 1
#if 0
a965 5
#else
    Tk_CreateEventHandler(xtkwin, ExposureMask|PointerMotionMask|
			  StructureNotifyMask,
			  (void (*)())Xdoevent, (ClientData)NULL);
#endif
@


11.13
log
@Fixed stupid typo.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.12 1995/08/24 06:36:50 mike Exp mike $ (BRL)";
a24 1
#include <stdio.h>
d36 1
a36 1
#include <X11/Xlib.h>
a38 2
#include "tcl.h"
#include "tk.h"
d67 1
d87 1
a87 1
	0
d91 2
d170 1
d172 3
d732 39
d833 1
d837 1
d840 8
d960 1
d962 5
@


11.12
log
@Bound left and right mouse buttons to L and R commands.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.11 1995/08/17 19:10:10 cnuzman Exp mike $ (BRL)";
d478 1
a478 1
	    rt_vls_strcat( &dm_values.dv_string, "L 1 %d %d\n", x, y);
d486 1
a486 1
	    rt_vls_strcat( &dm_values.dv_string, "R 1 %d %d\n", x, y);
@


11.11
log
@fixed bug when releasing dm-X
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.10 1995/07/31 13:08:19 gdurf Exp cnuzman $ (BRL)";
d467 1
d477 2
a478 2
	    /* Left mouse: Zoom out */
	    rt_vls_strcat( &dm_values.dv_string, "zoom 0.5\n");
d485 2
a486 2
	    /* Right mouse: Zoom in */
	    rt_vls_strcat( &dm_values.dv_string, "zoom 2\n");
d495 1
a495 1
	    /* Left mouse: Zoom out.  Do nothing more */
d502 1
a502 1
	    /* Right mouse: Zoom in.  Do nothing more. */
@


11.10
log
@Fixed resize bug
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.9 1995/07/20 13:20:10 gdurf Exp gdurf $ (BRL)";
d171 2
@


11.9
log
@Converted to using Tk calls
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.8 1995/07/05 21:22:12 gdurf Exp gdurf $ (BRL)";
d453 4
a456 2
	    height = Tk_Height(xtkwin);
	    width = Tk_Width(xtkwin);
d593 4
@


11.8
log
@Started Tk changes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.7 1995/06/27 20:08:11 gdurf Exp gdurf $ (BRL)";
d99 4
a102 2
static XColor *black, *white, *yellow, *red, *blue, *gray;
static XColor *bd, *bg, *fg;
d168 1
a168 7
    Tk_FreeColor(gray);
    Tk_FreeColor(blue);
    Tk_FreeColor(yellow);
    Tk_FreeColor(red);
    Tk_FreeColor(white);
    Tk_FreeColor(black);
    XFreeGC(Tk_Display(xtkwin), gc);
d184 1
a184 1
    XClearWindow(Tk_Display(xtkwin), Tk_WindowId(xtkwin));
d197 1
a197 1
    XSync(Tk_Display(xtkwin), 0);
a240 2
    Display *dpy;
    Window win;
a241 3
    dpy = Tk_Display(xtkwin);
    win = Tk_WindowId(xtkwin);

d290 1
a290 1
		gcv.foreground = fg->pixel;
d292 1
a292 1
		    gcv.foreground = white->pixel;
d376 1
a376 2
    XSync(Tk_Display(xtkwin), 0);
/*    XFlush(Tk_Display(xtkwin));*/
d395 1
a395 1
		fg = black->pixel;
d398 1
a398 1
		fg = red->pixel;
d401 1
a401 1
		fg = blue->pixel;
d405 1
a405 1
		fg = yellow->pixel;
d408 1
a408 1
		fg = gray->pixel;
d412 1
a412 1
	XChangeGC( Tk_Display(xtkwin), gc, GCForeground, &gcv );
d428 2
a429 2
    gcv.foreground = yellow->pixel;
    XChangeGC( Tk_Display(xtkwin), gc, GCForeground, &gcv );
d431 1
a431 2
	XSetLineAttributes(Tk_Display(xtkwin),
			   gc, 1, LineOnOffDash, CapButt, JoinMiter );
d433 1
a433 2
	XSetLineAttributes(Tk_Display(xtkwin),
			   gc, 1, LineSolid, CapButt, JoinMiter );
d438 1
a438 1
void
a446 2
    Display *dpy;
    Window win;
d448 2
a449 2
    dpy = Tk_Display(xtkwin);
    win = Tk_WindowId(xtkwin);
d455 1
a455 1
	    rt_vls_printf( &dm_values.dv_string, "refresh\n");
d460 1
a460 1
	    return;
d591 1
a591 1
/* 	rt_log( "Unknown event type\n" ) */;
d593 2
d700 1
a700 1
	XFlush(Tk_Display(xtkwin));
d736 1
a736 2
		XDrawPoint(Tk_Display(xtkwin), Tk_WindowId(xtkwin),
			   gc, sx1, sy1 );
d738 1
a738 2
		XDrawLine(Tk_Display(xtkwin), Tk_WindowId(xtkwin),
			  gc, sx1, sy1, sx2, sy2 );
d754 1
a754 2
	XDrawString( Tk_Display(xtkwin), Tk_WindowId(xtkwin),
		    gc, sx, sy, str, strlen(str) );
d793 7
d801 19
a819 6
    black  = Tk_GetColor(xinterp, xtkwin, Tk_GetUid("black"));
    white  = Tk_GetColor(xinterp, xtkwin, Tk_GetUid("white"));
    red    = Tk_GetColor(xinterp, xtkwin, Tk_GetUid("red"));
    yellow = Tk_GetColor(xinterp, xtkwin, Tk_GetUid("yellow"));
    blue   = Tk_GetColor(xinterp, xtkwin, Tk_GetUid("blue"));
    gray   = Tk_GetColor(xinterp, xtkwin, Tk_GetUid("gray"));
d821 33
d857 1
a857 3

    if (Tk_Visual(xtkwin)->class == GrayScale ||
	Tk_Visual(xtkwin)->class == StaticGray)  {
d859 3
a861 3
	bd = black;
	bg = white;
	fg = black;
d865 3
a867 3
	bd = white;
	bg = black;
	fg = white;
d870 1
a870 1
    if (!is_monochrome && fg != red && red != black) fg = red;
d872 2
a873 3
    Tk_GeometryRequest(xtkwin, width+10, height+10);
    Tk_SetWindowBackground(xtkwin, black->pixel);
    Tk_MakeWindowExist(xtkwin);
a874 2
    gcv.foreground = fg->pixel;
    gcv.background = bg->pixel;
d877 1
a877 1
    if ((fontstruct = XLoadQueryFont(Tk_Display(xtkwin), cp)) == NULL ) {
d879 1
a879 1
	if ((fontstruct = XLoadQueryFont(Tk_Display(xtkwin), FONT2)) == NULL) {
d885 1
a885 2
    gc = XCreateGC(Tk_Display(xtkwin), Tk_WindowId(xtkwin),
		   (GCFont|GCForeground|GCBackground), &gcv );
d887 1
a887 2
    gc = XCreateGC(Tk_Display(xtkwin), Tk_WindowId(xtkwin),
		   (GCForeground|GCBackground), &gcv);
d891 11
a901 5
    Tk_CreateEventHandler(xtkwin,
			  ExposureMask|ButtonPressMask|KeyPressMask|
			  PointerMotionMask|StructureNotifyMask,
			  Xdoevent, (ClientData)NULL);
	
@


11.7
log
@Reordered includes (#define conflict)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.6 1995/06/22 14:31:41 gdurf Exp gdurf $ (BRL)";
d40 3
a53 1
static void	checkevents();
d69 1
a69 1
void	X_window(), X_debug();
d94 7
a100 1
static int	height, width;
a101 2
static Display	*dpy;			/* X display pointer */
static Window	win;			/* X window */
a102 2
static unsigned long	black,gray,white,yellow,red,blue;
static unsigned long	bd, bg, fg;	/* color of border, background, foreground */
d166 9
a174 1
	XCloseDisplay( dpy );
d185 2
a186 2
	if( !dmaflag )
		return;
d188 1
a188 1
	XClearWindow( dpy, win );
d190 2
a191 2
	/* Put the center point up */
	draw( 0, 0, 0, 0 );
d200 3
a202 2
	XSync( dpy, 0 );	/* Prevent lag between events and updates */
	return;
d226 1
d233 1
a233 1
int	white_flag;
d235 62
a296 30
	static vect_t   pnt;
	register struct rt_vlist	*vp;
	int useful = 0;
	XSegment segbuf[1024];		/* XDrawSegments list */
	XSegment *segp;			/* current segment */
	XGCValues gcv;
	int	nseg;			/* number of segments */
	int	x, y;
	int	lastx = 0;
	int	lasty = 0;

	XChangeGC( dpy, gc, GCForeground, &gcv );

	if( sp->s_soldash ) {
		XSetLineAttributes( dpy, gc, 1, LineOnOffDash, CapButt, JoinMiter );
	} else {
		XSetLineAttributes( dpy, gc, 1, LineSolid, CapButt, JoinMiter );
	}

	nseg = 0;
	segp = segbuf;
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;

		/* Viewing region is from -1.0 to +1.0 */
		/* 2^31 ~= 2e9 -- dynamic range of a long int */
		/* 2^(31-11) = 2^20 ~= 1e6 */
d298 25
a322 76
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_POLY_START:
			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				MAT4X3PNT( pnt, mat, *pt );
				if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
				    pnt[1] < -1e6 || pnt[1] > 1e6 )
					continue; /* omit this point (ugh) */
				pnt[0] *= 2047;
				pnt[1] *= 2047;
				x = GED_TO_Xx(pnt[0]);
				y = GED_TO_Xy(pnt[1]);
				lastx = x;
				lasty = y;
				continue;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				/* draw */
				MAT4X3PNT( pnt, mat, *pt );
				if( pnt[0] < -1e6 || pnt[0] > 1e6 ||
				    pnt[1] < -1e6 || pnt[1] > 1e6 )
					continue; /* omit this point (ugh) */
				/* Integerize and let the X server do the clipping */
				/*XXX Color */
				gcv.foreground = fg;
				if( white_flag && !is_monochrome )  {
					gcv.foreground = white;
				}
				XChangeGC( dpy, gc, GCForeground, &gcv );

				pnt[0] *= 2047;
				pnt[1] *= 2047;
				x = GED_TO_Xx(pnt[0]);
				y = GED_TO_Xy(pnt[1]);

				segp->x1 = lastx;
				segp->y1 = lasty;
				segp->x2 = x;
				segp->y2 = y;
				nseg++;
				segp++;
				lastx = x;
				lasty = y;
				useful = 1;
				if( nseg == 1024 ) {
					XDrawSegments( dpy, win, gc, segbuf, nseg );
					/* Thicken the drawing, if monochrome */
					if( white_flag && is_monochrome ) {
						int	i;
						/* XXX - width and height don't work on Sun! */
						/* Thus the following gross hack */
						segp = segbuf;
						for( i = 0; i < nseg; i++ ) {
							segp->x1++;
							segp->y1++;
							segp->x2++;
							segp->y2++;
							segp++;
						}
						XDrawSegments( dpy, win, gc, segbuf, nseg );
					}
					nseg = 0;
					segp = segbuf;
				}
				break;
			}
		}
	}
	if( nseg ) {
		XDrawSegments( dpy, win, gc, segbuf, nseg );
		if( white_flag && is_monochrome ) {
d328 5
a332 5
				segp->x1++;
				segp->y1++;
				segp->x2++;
				segp->y2++;
				segp++;
d335 3
d339 19
d359 1
d361 1
a361 1
	return(useful);
d385 2
a386 1
	XFlush( dpy );
d405 1
a405 1
		fg = black;
d408 1
a408 1
		fg = red;
d411 1
a411 1
		fg = blue;
d415 1
a415 1
		fg = yellow;
d418 1
a418 1
		fg = gray;
d422 1
a422 1
	XChangeGC( dpy, gc, GCForeground, &gcv );
d436 13
a448 1
	XGCValues gcv;
d450 153
a602 6
	gcv.foreground = yellow;
	XChangeGC( dpy, gc, GCForeground, &gcv );
	if( dashed ) {
		XSetLineAttributes( dpy, gc, 1, LineOnOffDash, CapButt, JoinMiter );
	} else {
		XSetLineAttributes( dpy, gc, 1, LineSolid, CapButt, JoinMiter );
d604 3
a606 1
	draw( x1, y1, x2, y2 );
d608 1
a608 1

d620 3
d624 1
d630 1
a630 61
	struct timeval	tv;
	fd_set		files;
	int		width;
	int		cnt;
	register int	i;

#if defined(_SC_OPEN_MAX)
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
#endif
		width = 32;

	files = *input;		/* save, for restore on each loop */
	FD_SET( dpy->fd, &files );	/* check X fd too */

	/*
	 * Check for input on the keyboard, mouse, or window system.
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  Mouse or Window input arrives
	 *  3)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which we still have to update the display,
	 * do not suspend execution.
	 */
	do {
		*input = files;
		i = XPending( dpy );
		if( i > 0 ) {
			/* Don't select if we have some input! */
			FD_ZERO( input );
			FD_SET( dpy->fd, input );
			goto input_waiting;
			/* Any other input will be found on next call */
		}

		tv.tv_sec = 0;
		if( noblock )  {
			tv.tv_usec = 0;
		}  else  {
			/* 1/20th second */
			tv.tv_usec = 50000;
		}
		cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
		if( cnt < 0 )  {
			perror("dm-X.c/select");
			break;
		}
		if( noblock )  break;
		for( i=0; i<width; i++ )  {
			if( FD_ISSET(i, input) )  goto input_waiting;
		}
	} while( noblock == 0 );

input_waiting:

	if( FD_ISSET( dpy->fd, input ) )
		checkevents();

	return;
d675 3
a677 3
		/* constant tracking OFF */
		XSelectInput( dpy, win, ExposureMask|ButtonPressMask|KeyPressMask );
		break;
d681 3
a683 3
		/* constant tracking ON */
		XSelectInput( dpy, win, PointerMotionMask|ExposureMask|ButtonPressMask|KeyPressMask );
		break;
d686 3
a688 3
		/* constant tracking OFF */
		XSelectInput( dpy, win, ExposureMask|ButtonPressMask|KeyPressMask );
		break;
d690 2
a691 2
		rt_log("X_statechange: unknown state %s\n", state_str[b]);
		break;
d693 1
d712 1
a712 1
	XFlush( dpy );
d748 2
a749 1
		XDrawPoint( dpy, win, gc, sx1, sy1 );
d751 2
a752 1
		XDrawLine( dpy, win, gc, sx1, sy1, sx2, sy2 );
d768 2
a769 1
	XDrawString( dpy, win, gc, sx, sy, str, strlen(str) );
d790 49
a838 144
	char	hostname[80];
	char	display[80];
	char	*envp, *cp;
	unsigned long	bw;		/* border width */
	XSizeHints xsh;
	XEvent	event;
	XGCValues gcv;
	XColor a_color;
	Visual	*a_visual;
	int a_screen;
	Colormap  a_cmap;

	width = height = 512;

	if( name == NULL || *name == '\0' ) {
		if( (envp = getenv("DISPLAY")) == NULL ) {
			/* Env not set, use local host */
			gethostname( hostname, 80 );
			sprintf( display, "%s:0", hostname );
			envp = display;
		}
	} else {
		envp = name;
	}

	/* Open the display - XXX see what NULL does now */
	if( (dpy = XOpenDisplay( envp )) == NULL ) {
		rt_log( "dm-X: Can't open X display\n" );
		return -1;
	}

#if 0
	/* Load the font to use */
	/* Answering this extra question all the time is irritating */
	rt_log("Font [6x10]? ");
	(void)fgets( line, sizeof(line), stdin );
	line[strlen(line)-1] = '\0';		/* remove newline */
	if( line[0] != NULL )
		cp = line;
	else
#endif
		cp = FONT;

#ifdef ultrix
	cp = FONT2;	/* XXX Is this still necessary? */
#endif

	if( (fontstruct = XLoadQueryFont(dpy, cp)) == NULL ) {
		/* Try hardcoded backup font */
		if( (fontstruct = XLoadQueryFont(dpy, FONT2)) == NULL ) {
			rt_log( "dm-X: Can't open font '%s' or '%s'\n", cp, FONT2 );
			return -1;
		}
	}

	a_screen = DefaultScreen(dpy);
	a_visual = DefaultVisual(dpy, a_screen);

	/* Get color map inddices for the colors we use. */
	black = BlackPixel( dpy, a_screen );
	white = WhitePixel( dpy, a_screen );

	a_cmap = DefaultColormap(dpy, a_screen);
	a_color.red = 255<<8;
	a_color.green=0;
	a_color.blue=0;
	a_color.flags = DoRed | DoGreen| DoBlue;
	if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
		rt_log( "dm-X: Can't Allocate red\n");
		return -1;
	}
	red = a_color.pixel;
	if ( red == white ) red = black;

	a_color.red = 200<<8;
	a_color.green=200<<8;
	a_color.blue=0<<8;
	a_color.flags = DoRed | DoGreen| DoBlue;
	if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
		rt_log( "dm-X: Can't Allocate yellow\n");
		return -1;
	}
	yellow = a_color.pixel;
	if (yellow == white) yellow = black;

	a_color.red = 0;
	a_color.green=0;
	a_color.blue=255<<8;
	a_color.flags = DoRed | DoGreen| DoBlue;
	if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
		rt_log( "dm-X: Can't Allocate blue\n");
		return -1;
	}
	blue = a_color.pixel;
	if (blue == white) blue = black;

	a_color.red = 128<<8;
	a_color.green=128<<8;
	a_color.blue= 128<<8;
	a_color.flags = DoRed | DoGreen| DoBlue;
	if ( ! XAllocColor(dpy, a_cmap, &a_color)) {
		rt_log( "dm-X: Can't Allocate gray\n");
		return -1;
	}
	gray = a_color.pixel;
	if (gray == white) gray = black;

	/* Select border, background, foreground colors,
	 * and border width.
	 */
	if( a_visual->class == GrayScale || a_visual->class == StaticGray )  {
		is_monochrome = 1;
		bd = BlackPixel( dpy, a_screen );
		bg = WhitePixel( dpy, a_screen );
		fg = BlackPixel( dpy, a_screen );
	} else {
		/* Hey, it's a color server.  Ought to use 'em! */
		is_monochrome = 0;
		bd = WhitePixel( dpy, a_screen );
		bg = BlackPixel( dpy, a_screen );
		fg = WhitePixel( dpy, a_screen );
	}
	if( !is_monochrome && fg != red && red != black )  fg = red;
	bw = 1;

	/* Fill in XSizeHints struct to inform window
	 * manager about initial size and location.
	 */
	xsh.flags = (PSize);
	xsh.height = height + 10;
	xsh.width = width + 10;
	xsh.x = xsh.y = 0;

	win = XCreateSimpleWindow( dpy, DefaultRootWindow(dpy),
		xsh.x, xsh.y, xsh.width, xsh.height,
		bw, bd, bg );
	if( win == 0 ) {
		rt_log( "dm-X: Can't create window\n" );
		return -1;
	}

	/* Set standard properties for Window Managers */
	XSetStandardProperties( dpy, win, "MGED", "MGED", None, NULL, 0, &xsh );
	XSetWMHints( dpy, win, &xwmh );
d840 2
a841 6
	/* Create a Graphics Context for drawing */
#ifndef CRAY2
	gcv.font = fontstruct->fid;
#endif
	gcv.foreground = fg;
	gcv.background = bg;
d843 11
a853 1
	gc = XCreateGC( dpy, win, (GCFont|GCForeground|GCBackground), &gcv );
d855 2
a856 1
	gc = XCreateGC( dpy, win, (GCForeground|GCBackground), &gcv );
d858 9
a866 198

	XSelectInput( dpy, win, ExposureMask|ButtonPressMask|KeyPressMask );
	XMapWindow( dpy, win );

	while( 1 ) {
		XNextEvent( dpy, &event );
		if( event.type == Expose && event.xexpose.count == 0 ) {
			XWindowAttributes xwa;

			/* remove other exposure events */
			while( XCheckTypedEvent(dpy, Expose, &event) ) ;

			if( XGetWindowAttributes( dpy, win, &xwa ) == 0 )
				break;

			width = xwa.width;
			height = xwa.height;
			break;
		}
	}
	return	0;
}

/*
 *  Only called when we *know* there is at least one event to process.
 *  (otherwise we would block in XNextEvent)
 */
static void
checkevents()
{
	XEvent	event;
	KeySym	key;
	char keybuf[4];
	int cnt;
	XComposeStatus compose_stat;

	while( XPending( dpy ) > 0 ) {
		XNextEvent( dpy, &event );
		if( event.type == Expose ) {
			if( event.xexpose.count == 0 ) {
				XWindowAttributes xwa;
				XGetWindowAttributes( dpy, win, &xwa );
				height = xwa.height;
				width = xwa.width;
				rt_vls_printf( &dm_values.dv_string, "refresh\n");
			}
		} else if( event.type == MotionNotify ) {
			int	x, y;
			x = (event.xmotion.x/(double)width - 0.5) * 4095;
			y = (0.5 - event.xmotion.y/(double)height) * 4095;
			rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
				x, y );
		} else if( event.type == ButtonPress ) {
			/* There may also be ButtonRelease events */
			int	x, y;
			/* In MGED this is a "penpress" */
			x = (event.xbutton.x/(double)width - 0.5) * 4095;
			y = (0.5 - event.xbutton.y/(double)height) * 4095;
			switch( event.xbutton.button ) {
			case Button1:
				/* Left mouse: Zoom out */
				rt_vls_strcat( &dm_values.dv_string, "zoom 0.5\n");
				break;
			case Button2:
				/* Middle mouse, up to down transition */
				rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n",
					x, y);
				break;
			case Button3:
				/* Right mouse: Zoom in */
				rt_vls_strcat( &dm_values.dv_string, "zoom 2\n");
				break;
			}
		} else if( event.type == ButtonRelease ) {
			int	x, y;
			x = (event.xbutton.x/(double)width - 0.5) * 4095;
			y = (0.5 - event.xbutton.y/(double)height) * 4095;
			switch( event.xbutton.button ) {
			case Button1:
				/* Left mouse: Zoom out.  Do nothing more */
				break;
			case Button2:
				/* Middle mouse, down to up transition */
				rt_vls_printf( &dm_values.dv_string, "M 0 %d %d\n",
					x, y);
				break;
			case Button3:
				/* Right mouse: Zoom in.  Do nothing more. */
				break;
			}
		} else if( event.type == KeyPress ) {
		    register int i;
			/* Turn these into MGED "buttonpress" or knob functions */

		    cnt = XLookupString(&event.xkey, keybuf, sizeof(keybuf),
						&key, &compose_stat);

		    for(i=0 ; i < cnt ; i++){

			switch( *keybuf ) {
			case '?':
				rt_log( "\nKey Help Menu:\n\
0	Zero 'knobs'\n\
x	Increase xrot\n\
y	Increase yrot\n\
z	Increase zrot\n\
X	Increase Xslew\n\
Y	Increase Yslew\n\
Z	Increase Zslew\n\
f	Front view\n\
t	Top view\n\
b	Bottom view\n\
l	Left view\n\
r	Right view\n\
R	Rear view\n\
3	35,25 view\n\
4	45,45 view\n\
F	Toggle faceplate\n\
" );
				break;
			case 'F':
				/* Toggle faceplate on/off */
				no_faceplate = !no_faceplate;
				rt_vls_strcat( &dm_values.dv_string,
					no_faceplate ?
					"set faceplate 0\n" :
					"set faceplate 1\n" );
				break;
			case '0':
				rt_vls_printf( &dm_values.dv_string,
					"knob zero\n" );
				break;
			case 'x':
				/* 6 degrees per unit */
				rt_vls_printf( &dm_values.dv_string,
					"knob +x 0.1\n" );
				break;
			case 'y':
				rt_vls_printf( &dm_values.dv_string,
					"knob +y 0.1\n" );
				break;
			case 'z':
				rt_vls_printf( &dm_values.dv_string,
					"knob +z 0.1\n" );
				break;
			case 'X':
				/* viewsize per unit */
				rt_vls_printf( &dm_values.dv_string,
					"knob +X 0.1\n" );
				break;
			case 'Y':
				rt_vls_printf( &dm_values.dv_string,
					"knob +Y 0.1\n" );
				break;
			case 'Z':
				rt_vls_printf( &dm_values.dv_string,
					"knob +Z 0.1\n" );
				break;
			case 'f':
				rt_vls_strcat( &dm_values.dv_string,
					"press front\n");
				break;
			case 't':
				rt_vls_strcat( &dm_values.dv_string,
					"press top\n");
				break;
			case 'b':
				rt_vls_strcat( &dm_values.dv_string,
					"press bottom\n");
				break;
			case 'l':
				rt_vls_strcat( &dm_values.dv_string,
					"press left\n");
				break;
			case 'r':
				rt_vls_strcat( &dm_values.dv_string,
					"press right\n");
				break;
			case 'R':
				rt_vls_strcat( &dm_values.dv_string,
					"press rear\n");
				break;
			case '3':
				rt_vls_strcat( &dm_values.dv_string,
					"press 35,25\n");
				break;
			case '4':
				rt_vls_strcat( &dm_values.dv_string,
					"press 45,45\n");
				break;
			default:
				rt_log("dm-X: The key '%c' is not defined\n", key);
				break;
			}
		    }
		} else
			rt_log( "Unknown event type\n" );
	}
@


11.6
log
@Changed hints to window manager
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.5 1995/06/16 21:32:21 gdurf Exp gdurf $ (BRL)";
a26 8
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "./ged.h"
#include "./dm.h"
#include "./solid.h"
d39 9
@


11.5
log
@Minor string fixen
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.4 1995/06/16 20:30:51 gdurf Exp gdurf $ (BRL)";
d647 2
a648 2
	(InputHint|StateHint),		/* flags */
	False,				/* input */
@


11.4
log
@*** empty log message ***
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.3 1995/06/16 19:48:39 gdurf Exp gdurf $ (BRL)";
a102 18
#if 0

struct X_vars {
    int no_faceplate;
    int linewidth;
    




struct structparse X_vparse[] = {
	{"%d",  1, "no_faceplate",	&no_faceplate,	refresh_hook },
	{"%d",  1, "linewidth",		&ir_linewidth,	refresh_hook },
	{"%s",  1, "foreground",        
	{"",	0,  (char *)0,		0,			FUNC_NULL }
};

#endif
d122 1
a122 1
        char	line[85];
d131 1
d137 1
a137 1
	(void)fgets( line, 82, stdin );
@


11.3
log
@Changed set call to match new style
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.2 1995/06/16 19:20:23 gdurf Exp gdurf $ (BRL)";
d103 18
d140 3
a142 3
	char	line[64];
	char	hostname[80];
	char	display[80];
d154 1
a154 1
	(void)fgets( line, sizeof(line), stdin );
a203 3
#if 0
	XFlush( dpy );
#else
a204 1
#endif
@


11.2
log
@Added missing struct dm elements
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 11.1 1995/01/04 10:02:52 mike Rel4_4 gdurf $ (BRL)";
d945 2
a946 2
					"set faceplate=0\n" :
					"set faceplate=1\n" );
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.24 94/12/24 01:05:18 mike Exp $ (BRL)";
d84 3
a86 1
	"X", "X Window System (X11)"
@


10.24
log
@Eliminated old dm_values.dv_* style "polled" device interface.
Everything is done by string commands now.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.23 94/12/23 22:53:09 mike Exp Locker: mike $ (BRL)";
@


10.23
log
@Added per vertex normal case.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.22 94/12/23 21:57:38 gdurf Exp Locker: mike $ (BRL)";
a501 4
	/* "rest" state */
	dm_values.dv_buttonpress = 0;
	dm_values.dv_flagadc = 0;
	dm_values.dv_penpress = 0;
@


10.22
log
@Added XSync()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.21 94/12/22 00:46:53 mike Exp $ (BRL)";
d255 1
@


10.21
log
@Changed to HAVE_XOSDEFS_H
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.20 94/12/19 18:00:19 mike Exp Locker: mike $ (BRL)";
d184 1
d186 3
@


10.20
log
@Linux fix.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.19 94/12/16 19:36:03 gdurf Exp Locker: mike $ (BRL)";
d36 1
a36 1
#ifndef CRAY2	/* not avaiable on CRAY2 */
d39 1
a39 1
#endif  /* CRAY2 */
@


10.19
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.18 1994/12/13 11:32:59 jehunt Exp gdurf $ (BRL)";
d36 4
@


10.18
log
@Linux port.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.17 94/11/19 03:50:14 mike Exp $ (BRL)";
d129 1
a129 1
	(void)printf("X Display [%s]? ", envp );
d531 1
a531 1
	(void)printf("X_load(x%x, %d.)\n", addr, count );
d561 1
a561 1
		(void)printf("X_statechange: unknown state %s\n", state_str[b]);
d583 1
a583 1
	printf("flushed\n");
d684 1
a684 1
		fprintf( stderr, "dm-X: Can't open X display\n" );
d691 1
a691 1
	(void)printf("Font [6x10]? ");
d707 1
a707 1
			fprintf( stderr, "dm-X: Can't open font '%s' or '%s'\n", cp, FONT2 );
d725 1
a725 1
		fprintf( stderr, "dm-X: Can't Allocate red\n");
d736 1
a736 1
		fprintf( stderr, "dm-X: Can't Allocate yellow\n");
d747 1
a747 1
		fprintf( stderr, "dm-X: Can't Allocate blue\n");
d758 1
a758 1
		fprintf( stderr, "dm-X: Can't Allocate gray\n");
d794 1
a794 1
		fprintf( stderr, "dm-X: Can't create window\n" );
d914 1
a914 1
				fprintf( stderr, "\nKey Help Menu:\n\
d1004 1
a1004 1
				printf("dm-X: The key '%c' is not defined\n", key);
d1009 1
a1009 1
			fprintf( stderr, "Unknown event type\n" );
@


10.17
log
@Added very limited color support,
to improve usability when not on monochrome displays.
Closes bug #201.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.16 94/11/05 03:56:21 mike Exp Locker: mike $ (BRL)";
d36 4
@


10.16
log
@Irix 6
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.15 94/10/18 13:55:03 mike Exp Locker: mike $ (BRL)";
d87 2
d203 1
a203 1
X_object( sp, mat, ratio, white )
d207 1
d220 2
d268 4
a271 1
				gcv.foreground = black;
d290 2
a291 1
					if( white ) {
d314 1
a314 1
		if( white ) {
d656 1
a656 1
	unsigned long	bd, bg, fg, bw;
d661 1
d708 3
d712 2
a713 2
	black = BlackPixel( dpy, DefaultScreen(dpy) );
	white = WhitePixel( dpy, DefaultScreen(dpy) );
a714 1
	a_screen = DefaultScreen(dpy);
d763 13
a775 3
	bd = BlackPixel( dpy, DefaultScreen(dpy) );
	bg = WhitePixel( dpy, DefaultScreen(dpy) );
	fg = BlackPixel( dpy, DefaultScreen(dpy) );
@


10.15
log
@Stupid typo around select() handling in X_input().
John's sharp (and non-bleary) eyes caught it.
Also closes bug #137 by Bill Laut.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.14 94/10/17 23:22:53 mike Exp Locker: mike $ (BRL)";
a80 1
static vect_t clipmin, clipmax;		/* for vector clipping */
a235 1
			static vect_t	start, fin;
d577 1
d585 1
a646 1
	char	line[80];
d739 1
a739 1
	a_color.blue=128<<8<<8;
@


10.14
log
@Added fallback to second font, at suggestion of Bill Laut.
Fixes bug #132.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.13 94/10/14 17:06:54 mike Exp Locker: mike $ (BRL)";
d434 1
a434 1
#else
a435 1
#endif
@


10.13
log
@#if defined(_SC_OPEN_MAX)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.12 94/10/14 16:06:26 mike Exp Locker: mike $ (BRL)";
d628 1
d687 5
a691 4
#ifndef CRAY2
/* The Cray2 never returns from this call.  sigh.
 * Use the default font until the Cray libX11 is fixed.
 */
d693 5
a697 2
		fprintf( stderr, "dm-X: Can't open font\n" );
		return -1;
a698 1
#endif
@


10.12
log
@Changed from getdtablesize() to sysconf(_SC_OPEN_MAX)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.11 94/09/06 16:11:37 jra Exp Locker: mike $ (BRL)";
d432 1
d434 1
d436 1
@


10.11
log
@Converted to use dm_values.dv_string rather than setting actual values.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.10 94/08/10 21:42:46 mike Exp Locker: jra $ (BRL)";
d432 1
a432 1
	if( (width = getdtablesize()) <= 0 )
@


10.10
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.9 94/08/09 15:12:41 gdurf Exp Locker: mike $ (BRL)";
d911 2
a912 6
				dm_values.dv_xjoy = 0;
				dm_values.dv_yjoy = 0;
				dm_values.dv_zjoy = 0;
				dm_values.dv_xslew = 0;
				dm_values.dv_yslew = 0;
				dm_values.dv_zslew = 0;
d916 2
a917 1
				dm_values.dv_xjoy += 0.1;
d920 2
a921 1
				dm_values.dv_yjoy += 0.1;
d924 2
a925 1
				dm_values.dv_zjoy += 0.1;
d929 2
a930 1
				dm_values.dv_xslew += 0.1;
d933 2
a934 1
				dm_values.dv_yslew += 0.1;
d937 2
a938 1
				dm_values.dv_zslew += 0.1;
@


10.9
log
@Added include of conf.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.8 1994/06/01 11:56:26 gdurf Exp gdurf $ (BRL)";
d26 1
d28 1
a33 1
#include "externs.h"
d50 1
a50 1
int	X_input();
d416 4
a419 3
 * Returns:
 *	0 if no command waiting to be read,
 *	1 if command is waiting to be read.
d421 4
a424 1
X_input( cmd_fd, noblock )
d426 4
a429 1
	register long readfds;
d432 6
d451 1
a451 1
		readfds = 0;
d455 16
d473 3
a475 5
		readfds = (1<<cmd_fd) | (1<<dpy->fd);
		if( noblock ) {
			readfds = bsdselect( readfds, 0, 0 );
		} else {
			readfds = bsdselect( readfds, 30*60, 0 );
a476 2
		if( readfds != 0 )
			break;
d479 1
d485 1
a485 1
	if( (i != 0) || (readfds & (1<<dpy->fd)) )
d488 1
a488 4
	if( readfds & (1<<cmd_fd) )
		return(1);		/* command awaits */
	else
		return(0);		/* just peripheral stuff */
@


10.8
log
@Replaced gets() with fgets()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.7 1994/06/01 11:55:24 gdurf Exp gdurf $ (BRL)";
d22 2
@


10.7
log
@Replaced gets() with fgets()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.6 1993/10/26 02:38:37 butler Exp $ (BRL)";
d650 2
a651 1
	(void)gets( line );		/* Null terminated */
@


10.6
log
@changed to call XLookupString instead of XLookupKeysym for processing
keyboard input.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.5 93/10/26 02:00:48 mike Exp Locker: butler $ (BRL)";
d122 2
a123 1
	(void)gets( line );		/* Null terminated */
a124 1

@


10.5
log
@Added new event handling.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.4 93/10/26 01:05:13 mike Exp Locker: mike $ (BRL)";
d786 4
a789 2
	XKeyEvent	keyevent;
	int	key;
d846 1
d848 7
a854 3
			key = XLookupKeysym( (XKeyEvent *) &event, 0 );
			switch( key ) {
			case '/':
d856 2
a857 2
				fprintf( stderr, "\nKey Help Menu:\
0	Zap 'knobs'\n\
d947 1
@


10.4
log
@"press sill" didn't cause illuminate mode to work.
The problem is actually in the event simulator in ged.c, but
rather than mess with that, I just upgraded the  MotionNotify code here
to use the new event interface.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.3 93/08/20 16:37:11 jra Exp Locker: mike $ (BRL)";
d32 2
d87 2
d806 2
d809 2
d813 2
a814 2
				if( dm_values.dv_penpress != DV_PICK )
					dm_values.dv_penpress = DV_OUTZOOM;
d817 3
a819 1
				dm_values.dv_penpress = DV_PICK;
d822 2
a823 2
				if( dm_values.dv_penpress != DV_PICK )
					dm_values.dv_penpress = DV_INZOOM;
d826 17
a842 2
			dm_values.dv_xpen = (event.xbutton.x/(double)width - 0.5) * 4095;
			dm_values.dv_ypen = (0.5 - event.xbutton.y/(double)height) * 4095;
d847 1
d849 18
a866 1
				fprintf( stderr, "\nKey Help Menu\n" );
d868 8
d905 2
a906 1
				dm_values.dv_buttonpress = BV_FRONT;
d909 2
a910 1
				dm_values.dv_buttonpress = BV_TOP;
d913 2
a914 1
				dm_values.dv_buttonpress = BV_BOTTOM;
d917 2
a918 1
				dm_values.dv_buttonpress = BV_LEFT;
d921 2
a922 1
				dm_values.dv_buttonpress = BV_RIGHT;
d925 2
a926 1
				dm_values.dv_buttonpress = BV_REAR;
d929 2
a930 1
				dm_values.dv_buttonpress = BV_35_25;
d933 5
a937 1
				dm_values.dv_buttonpress = BV_45_45;
@


10.3
log
@fixed limit of 1024 segs
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dm-X.c,v 10.2 93/06/22 20:44:15 gdurf Exp Locker: jra $ (BRL)";
d793 1
a793 2
				dmaflag = 1;
				refresh();
d796 5
a800 2
			dm_values.dv_xpen = (event.xmotion.x/(double)width - 0.5) * 4095;
			dm_values.dv_ypen = (0.5 - event.xmotion.y/(double)height) * 4095;
@


10.2
log
@fixed call to XLookupKeysym
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 10.1 1991/10/12 06:43:19 mike Rel4_0 gdurf $ (BRL)";
d270 1
a270 4
				if( ++nseg >= 1024 ) {
					(void) fprintf(stderr, "dm-X: nseg clipped to 1024\n" );
					break;
				}
d275 19
d298 15
a312 12
	XDrawSegments( dpy, win, gc, segbuf, nseg );
	if( white ) {
		int	i;
		/* XXX - width and height don't work on Sun! */
		/* Thus the following gross hack */
		segp = segbuf;
		for( i = 0; i < nseg; i++ ) {
			segp->x1++;
			segp->y1++;
			segp->x2++;
			segp->y2++;
			segp++;
a313 1
		XDrawSegments( dpy, win, gc, segbuf, nseg );
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 9.8 91/07/19 01:16:19 mike Exp $ (BRL)";
d63 1
a63 2
	X_object,
	X_cvtvecs, X_load,
d800 1
a800 1
			key = XLookupKeysym( &keyevent, 0 );
@


9.8
log
@IBM does not like NULL instead of '\0'
Don't use u_char on IBM
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 9.7 91/07/02 04:36:36 mike Exp $ (BRL)";
@


9.7
log
@Eliminated annoying font question
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 9.6 91/02/02 00:00:54 mike Exp $ (BRL)";
d335 1
a335 1
register u_char *str;
d608 1
a608 1
	if( name == NULL || *name == NULL ) {
@


9.6
log
@Modified for new rt_vlist structures
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 9.5 91/01/25 12:50:39 cjohnson Exp $ (BRL)";
d625 1
d627 1
d633 1
@


9.5
log
@Removed extern declerations of perror (not used) and getenv.  Both
exist in h/externs.h which is already included.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 9.4 90/12/07 01:17:20 mike Exp $ (BRL)";
d201 2
a202 2
	static vect_t   pt;
	register struct vlist *vp;
d220 6
a225 2
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		MAT4X3PNT( pt, mat, vp->vl_pnt );
a228 3
		if( pt[0] < -1e6 || pt[0] > 1e6 ||
		    pt[1] < -1e6 || pt[1] > 1e6 )
			continue;		/* omit this point (ugh) */
d230 31
a260 4
		/*vclip( start, fin, clipmin, clipmax ) == 0 continue;*/
		/*XXX Color */
		gcv.foreground = black;
		XChangeGC( dpy, gc, GCForeground, &gcv );
d262 4
a265 4
		pt[0] *= 2047;
		pt[1] *= 2047;
		x = GED_TO_Xx(pt[0]);
		y = GED_TO_Xy(pt[1]);
d267 12
a278 7
		if( vp->vl_draw ) {
			segp->x1 = lastx;
			segp->y1 = lasty;
			segp->x2 = x;
			segp->y2 = y;
			if( ++nseg >= 1024 ) {
				(void) fprintf(stderr, "dm-X: nseg clipped to 1024\n" );
a280 2
			segp++;
			useful = 1;
a281 3
		/* else move... */
		lastx = x;
		lasty = y;
@


9.4
log
@lint
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 9.3 90/06/07 00:47:19 mike Exp $ (BRL)";
a34 2
extern void	perror();
extern char	*getenv();
@


9.3
log
@lint
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-X.c,v 9.2 89/12/21 11:07:12 cjohnson Exp $ (BRL)";
d210 3
a212 1
	int	x, y, lastx, lasty;
d324 1
@


9.2
log
@Added X color support and turned on Phil's dashed line support.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 9.1 89/05/19 06:02:13 mike Rel3_5 $ (BRL)";
d733 1
d769 1
a769 1
			key = XLookupKeysym( &event, 0 );
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 8.4 89/04/06 20:39:08 mike Exp $ (BRL)";
d85 1
d208 1
a211 1
#ifdef SOMEDAY
a216 1
#endif
d231 2
d309 3
a311 1
#ifdef XXX
d314 1
a314 1
		pl_color( up_fp,  0, 0, 0 );
d317 1
a317 1
		pl_color( up_fp,  255, 0, 0 );
d320 1
a320 1
		pl_color( up_fp,  0, 255, 0 );
d323 1
a323 1
		pl_color( up_fp,  255, 255, 0 );
d326 1
a326 1
		pl_color( up_fp,  255, 255, 255 );
d329 2
a330 1
#endif
d344 4
a347 4
#ifdef XXX
	pl_color( up_fp,  255, 255, 0 );	/* Yellow */
#endif
#ifdef SOMEDAY
a352 1
#endif
d573 3
d612 50
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 8.3 89/04/03 20:17:05 mike Locked $ (BRL)";
@


8.3
log
@conflicts with X module in libfb.  made some things static.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 8.2 88/12/06 01:06:10 phil Locked $ (BRL)";
d30 1
@


8.2
log
@Added #include <raytrace.h> for vector list stuff
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/dm-X.c,v 1.2 88/10/23 13:55:54 mike Exp $ (BRL)";
d39 1
d545 1
a545 1
XWMHints xwmh = {
d556 1
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 1.3 88/09/17 04:59:57 phil Exp $ (BRL)";
d27 1
@


1.3
log
@added ifdefs to avoid broken Cray2 Font selection routine
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 1.2 88/09/17 02:24:45 phil Locked $ (BRL)";
@


1.2
log
@modified dm.h to add releasedisplay flag.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 1.1 88/04/28 17:10:36 reschly Locked $ (BRL)";
d71 1
a71 1
	"X", "X Window"
d388 1
a388 2
			/* 1/20th second */
			readfds = bsdselect( readfds, 0, 50000 );
d592 4
d600 1
d631 1
d633 1
d636 1
d638 3
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: dm-X.c,v 7.3 88/02/25 06:06:12 phil Exp $ (BRL)";
d69 1
@
