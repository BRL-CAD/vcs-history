head	1.19;
access;
symbols
	ansi-20040405-merged:1.15.2.2
	postmerge-20040405-ansi:1.17
	premerge-20040404-ansi:1.16
	postmerge-autoconf:1.16
	autoconf-freeze:1.15.10.1
	premerge-autoconf:1.16
	postmerge-20040315-windows:1.16
	premerge-20040315-windows:1.16
	windows-20040315-freeze:1.15.4.1
	autoconf-20031203:1.15
	autoconf-20031202:1.15
	autoconf-branch:1.15.0.10
	phong-branch:1.15.0.8
	photonmap-branch:1.15.0.6
	rel-6-1-DP:1.15
	windows-branch:1.15.0.4
	rel-6-0-2:1.13
	ansi-branch:1.15.0.2
	rel-6-0-1-branch:1.13.0.2
	hartley-6-0-post:1.14
	hartley-6-0-pre:1.13
	rel-6-0-1:1.13
	rel-6-0:1.13
	rel-5-4:1.9
	offsite-5-3-pre:1.10
	rel-5-3:1.9
	rel-5-2:1.9
	rel-5-1-branch:1.9.0.2
	rel-5-1:1.9
	rel-5-0:1.8
	rel-5-0-beta:1.8;
locks; strict;
comment	@ * @;


1.19
date	2004.05.21.17.47.50;	author morrison;	state dead;
branches;
next	1.18;

1.18
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.05.09.09.12;	author morrison;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.02.17.39.35;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.20.17.08.25;	author jra;	state Exp;
branches
	1.15.2.1
	1.15.4.1
	1.15.10.1;
next	1.14;

1.14
date	2002.08.15.20.55.38;	author hartley;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.01.19.23.25;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.05.19.35.45;	author morrison;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.02.18.10.11;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.24.19.05.09;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	99.12.30.20.29.19;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	99.02.17.19.39.15;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	99.01.21.18.31.20;	author bparker;	state Exp;
branches;
next	1.6;

1.6
date	99.01.19.22.20.50;	author bparker;	state Exp;
branches;
next	1.5;

1.5
date	99.01.12.18.00.01;	author bparker;	state Exp;
branches;
next	1.4;

1.4
date	98.12.29.20.32.15;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	98.12.18.22.06.49;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.11.06.22.32.43;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	98.11.06.22.21.36;	author bparker;	state Exp;
branches;
next	;

1.15.2.1
date	2002.09.19.18.02.04;	author morrison;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2004.03.17.21.22.04;	author morrison;	state Exp;
branches;
next	;

1.15.4.1
date	2004.03.11.23.46.36;	author morrison;	state Exp;
branches;
next	;

1.15.10.1
date	2004.02.12.18.34.16;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.19
log
@moved to src/mged/
@
text
@/*
 *				S H A R E . C
 *
 * Description -
 *	Routines for sharing resources among display managers.
 *
 * Functions -
 *	f_share				command to share/unshare resources
 *	f_rset				command to set resources
 *
 * Source -
 *      SLAD CAD Team
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005
 *
 * Author -
 *      Robert G. Parker
 *
 * Copyright Notice -
 *      This software is Copyright (C) 1998-2004 by the United States Army.
 *      All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <math.h>
#include <stdio.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

#define RESOURCE_TYPE_ADC		0
#define RESOURCE_TYPE_AXES		1
#define RESOURCE_TYPE_COLOR_SCHEMES	2
#define RESOURCE_TYPE_GRID		3
#define RESOURCE_TYPE_MENU		4
#define RESOURCE_TYPE_MGED_VARIABLES	5
#define RESOURCE_TYPE_RUBBER_BAND	6
#define RESOURCE_TYPE_VIEW		7

#define SHARE_RESOURCE(uflag,str,resource,rc,dlp1,dlp2,vls,error_msg) { \
    if (uflag) { \
      struct str *strp; \
\
      if (dlp1->resource->rc > 1) {   /* must be sharing this resource */ \
	--dlp1->resource->rc; \
	strp = dlp1->resource; \
	BU_GETSTRUCT(dlp1->resource, str); \
	*dlp1->resource = *strp;        /* struct copy */ \
	dlp1->resource->rc = 1; \
      } \
    } else { \
      /* must not be sharing this resource */ \
      if (dlp1->resource != dlp2->resource) { \
        if (!--dlp2->resource->rc) \
          bu_free((genptr_t)dlp2->resource, error_msg); \
\
          dlp2->resource = dlp1->resource; \
          ++dlp1->resource->rc; \
      } \
    } \
}

extern void mged_vls_struct_parse(struct bu_vls *vls, char *title, struct bu_structparse *how_to_parse, char *structp, int argc, char **argv); /* defined in vparse.c */
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */

extern struct bu_structparse axes_vparse[];
extern struct bu_structparse color_scheme_vparse[];
extern struct bu_structparse grid_vparse[];
extern struct bu_structparse rubber_band_vparse[];
extern struct bu_structparse mged_vparse[];

void free_all_resources(struct dm_list *dlp);

/*
 * SYNOPSIS
 *	share [-u] res p1 [p2]
 *
 * DESCRIPTION
 *	Provides a mechanism to (un)share resources among display managers.
 *	Currently, there are nine different resources that can be shared.
 *	They are:
 *		ADC AXES COLOR_SCHEMES DISPLAY_LISTS GRID MENU MGED_VARIABLES RUBBER_BAND VIEW
 *
 * EXAMPLES
 *	share res_type p1 p2	--->	causes 'p1' to share its resource of type 'res_type' with 'p2'
 *	share -u res_type p	--->	causes 'p' to no longer share resource of type 'res_type'
 */
int
f_share(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  register int uflag = 0;		/* unshare flag */
  struct dm_list *dlp1 = (struct dm_list *)NULL;
  struct dm_list *dlp2 = (struct dm_list *)NULL;
  struct bu_vls vls;

  bu_vls_init(&vls);

  if (argc != 4) {
    bu_vls_printf(&vls, "helpdevel share");
    Tcl_Eval(interp, bu_vls_addr(&vls));

    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (argv[1][0] == '-' && argv[1][1] == 'u') {
    uflag = 1;
    --argc;
    ++argv;
  }

  FOR_ALL_DISPLAYS(dlp1, &head_dm_list.l)
    if (!strcmp(argv[2], bu_vls_addr(&dlp1->dml_dmp->dm_pathName)))
      break;

  if (dlp1 == &head_dm_list) {
    Tcl_AppendResult(interp, "share: unrecognized pathName - ",
		     argv[2], "\n", (char *)NULL);

    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (!uflag) {
    FOR_ALL_DISPLAYS(dlp2, &head_dm_list.l)
      if (!strcmp(argv[3], bu_vls_addr(&dlp2->dml_dmp->dm_pathName)))
	break;

    if (dlp2 == &head_dm_list) {
      Tcl_AppendResult(interp, "share: unrecognized pathName - ",
		       argv[3], "\n", (char *)NULL);

      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    /* same display manager */
    if (dlp1 == dlp2) {
      bu_vls_free(&vls);
      return TCL_OK;
    }
  }

  switch (argv[1][0]) {
  case 'a':
  case 'A':
    if (argv[1][1] == 'd' || argv[1][1] == 'D')
      SHARE_RESOURCE(uflag,_adc_state,dml_adc_state,adc_rc,dlp1,dlp2,vls,"share: adc_state")
    else if (argv[1][1] == 'x' || argv[1][1] == 'X')
      SHARE_RESOURCE(uflag,_axes_state,dml_axes_state,ax_rc,dlp1,dlp2,vls,"share: axes_state")
    else {
      bu_vls_printf(&vls, "share: resource type '%s' unknown\n", argv[1]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

      bu_vls_free(&vls);
      return TCL_ERROR;
    }
    break;
  case 'c':
  case 'C':
    SHARE_RESOURCE(uflag,_color_scheme,dml_color_scheme,cs_rc,dlp1,dlp2,vls,"share: color_scheme")
    break;
  case 'd':
  case 'D':
    {
      struct dm *dmp1;
      struct dm *dmp2 = (struct dm *)NULL;

      dmp1 = dlp1->dml_dmp;
      if (dlp2 != (struct dm_list *)NULL)
	dmp2 = dlp2->dml_dmp;

      if (dm_share_dlist(dmp1, dmp2) == TCL_OK) {
	SHARE_RESOURCE(uflag,_dlist_state,dml_dlist_state,dl_rc,dlp1,dlp2,vls,"share: dlist_state");
	if (uflag) {
	  dlp1->dml_dlist_state->dl_active = dlp1->dml_mged_variables->mv_dlist;

	  if (dlp1->dml_mged_variables->mv_dlist) {
	    struct dm_list *save_dlp;

	    save_dlp = curr_dm_list;

	    curr_dm_list = dlp1;
	    createDLists(&dgop->dgo_headSolid);

	    /* restore */
	    curr_dm_list = save_dlp;
	  }

	  dlp1->dml_dirty = 1;
	} else {
	  dlp1->dml_dirty = dlp2->dml_dirty = 1;
	}
      }
    }
    break;
  case 'g':
  case 'G':
    SHARE_RESOURCE(uflag,_grid_state,dml_grid_state,gr_rc,dlp1,dlp2,vls,"share: grid_state")
    break;
  case 'm':
  case 'M':
    SHARE_RESOURCE(uflag,_menu_state,dml_menu_state,ms_rc,dlp1,dlp2,vls,"share: menu_state")
    break;
  case 'r':
  case 'R':
    SHARE_RESOURCE(uflag,_rubber_band,dml_rubber_band,rb_rc,dlp1,dlp2,vls,"share: rubber_band")
    break;
  case 'v':
  case 'V':
    if ((argv[1][1] == 'a' || argv[1][1] == 'A') &&
	(argv[1][2] == 'r' || argv[1][2] == 'R'))
      SHARE_RESOURCE(uflag,_mged_variables,dml_mged_variables,mv_rc,dlp1,dlp2,vls,"share: mged_variables")
    else if (argv[1][1] == 'i' || argv[1][1] == 'I') {
      if (uflag) {
	struct _view_state *ovsp;

	ovsp = dlp1->dml_view_state;
	SHARE_RESOURCE(uflag,_view_state,dml_view_state,vs_rc,dlp1,dlp2,vls,"share: view_state")

	/* initialize dlp1's view_state */
	if (ovsp != dlp1->dml_view_state)
	  view_ring_init(dlp1->dml_view_state, ovsp);
      } else {
	/* free dlp2's view_state resources if currently not sharing */
	if (dlp2->dml_view_state->vs_rc == 1)
	  view_ring_destroy(dlp2);

	SHARE_RESOURCE(uflag,_view_state,dml_view_state,vs_rc,dlp1,dlp2,vls,"share: view_state")
      }
    }else {
      bu_vls_printf(&vls, "share: resource type '%s' unknown\n", argv[1]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    break;
  default:
    bu_vls_printf(&vls, "share: resource type '%s' unknown\n", argv[1]);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (!uflag) 
    dlp2->dml_dirty = 1;	/* need to redraw this guy */

  bu_vls_free(&vls);
  return TCL_OK;
}

/*
 * SYNOPSIS
 *	rset [res_type [res [vals]]]
 *
 * DESCRIPTION
 *	Provides a mechanism to set resource values for some resource.
 *
 * EXAMPLES
 *	rset c bg 0 0 50	--->	sets the background color to dark blue
 */
int
f_rset (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct bu_vls vls;

  bu_vls_init(&vls);

  /* print values for all resources */
  if (argc == 1) {
    mged_vls_struct_parse(&vls, "Axes, res_type - ax", axes_vparse,
			  (const char *)axes_state, argc, argv);
    bu_vls_printf(&vls, "\n");
    mged_vls_struct_parse(&vls, "Color Schemes, res_type - c", color_scheme_vparse,
			  (const char *)color_scheme, argc, argv);
    bu_vls_printf(&vls, "\n");
    mged_vls_struct_parse(&vls, "Grid, res_type - g", grid_vparse,
			  (const char *)grid_state, argc, argv);
    bu_vls_printf(&vls, "\n");
    mged_vls_struct_parse(&vls, "Rubber Band, res_type - r", rubber_band_vparse,
			  (const char *)rubber_band, argc, argv);
    bu_vls_printf(&vls, "\n");
    mged_vls_struct_parse(&vls, "MGED Variables, res_type - var", mged_vparse,
			  (const char *)mged_variables, argc, argv);

    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_OK;
  }

  switch (argv[1][0]) {
  case 'a':
  case 'A':
    if (argv[1][1] == 'd' || argv[1][1] == 'D')
      bu_vls_printf(&vls, "rset: use the adc command for the 'adc' resource");
    else if (argv[1][1] == 'x' || argv[1][1] == 'X')
      mged_vls_struct_parse(&vls, "Axes", axes_vparse,
			    (const char *)axes_state, argc-1, argv+1);
    else {
      bu_vls_printf(&vls, "rset: resource type '%s' unknown\n", argv[1]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

      bu_vls_free(&vls);
      return TCL_ERROR;
    }
    break;
  case 'c':
  case 'C':
    mged_vls_struct_parse(&vls, "Color Schemes", color_scheme_vparse,
			  (const char *)color_scheme, argc-1, argv+1);
    break;
  case 'g':
  case 'G':
    mged_vls_struct_parse(&vls, "Grid", grid_vparse,
			  (const char *)grid_state, argc-1, argv+1);
    break;
  case 'r':
  case 'R':
    mged_vls_struct_parse(&vls, "Rubber Band", rubber_band_vparse,
			  (const char *)rubber_band, argc-1, argv+1);
    break;
  case 'v':
  case 'V':
    if ((argv[1][1] == 'a' || argv[1][1] == 'A') &&
	(argv[1][2] == 'r' || argv[1][2] == 'R'))
      mged_vls_struct_parse(&vls, "mged variables", mged_vparse,
				(const char *)mged_variables, argc-1, argv+1);
    else if (argv[1][1] == 'i' || argv[1][1] == 'I')
      bu_vls_printf(&vls, "rset: no support available for the 'view' resource");
    else {
      bu_vls_printf(&vls, "rset: resource type '%s' unknown\n", argv[1]);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    break;
  default:
    bu_vls_printf(&vls, "rset: resource type '%s' unknown\n", argv[1]);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);

    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);

  return TCL_OK;
}

/*
 * dlp1 takes control of dlp2's resources. dlp2 is
 * probably on its way out (i.e. being destroyed).
 */
void
usurp_all_resources(struct dm_list *dlp1, struct dm_list *dlp2)
{
  free_all_resources(dlp1);
  dlp1->dml_view_state = dlp2->dml_view_state;
  dlp1->dml_adc_state = dlp2->dml_adc_state;
  dlp1->dml_menu_state = dlp2->dml_menu_state;
  dlp1->dml_rubber_band = dlp2->dml_rubber_band;
  dlp1->dml_mged_variables = dlp2->dml_mged_variables;
  dlp1->dml_color_scheme = dlp2->dml_color_scheme;
  dlp1->dml_grid_state = dlp2->dml_grid_state;
  dlp1->dml_axes_state = dlp2->dml_axes_state;

  /* sanity */
  dlp2->dml_view_state = (struct _view_state *)NULL;
  dlp2->dml_adc_state = (struct _adc_state *)NULL;
  dlp2->dml_menu_state = (struct _menu_state *)NULL;
  dlp2->dml_rubber_band = (struct _rubber_band *)NULL;
  dlp2->dml_mged_variables = (struct _mged_variables *)NULL;
  dlp2->dml_color_scheme = (struct _color_scheme *)NULL;
  dlp2->dml_grid_state = (struct _grid_state *)NULL;
  dlp2->dml_axes_state = (struct _axes_state *)NULL;

  /* it doesn't make sense to save display list info */
  if(!--dlp2->dml_dlist_state->dl_rc)
    bu_free((genptr_t)curr_dm_list->dml_dlist_state, "usurp_all_resources: _dlist_state");
}

/*
 * - decrement the reference count of all resources
 * - free all resources that are not being used
 */
void
free_all_resources(struct dm_list *dlp)
{
  if(!--dlp->dml_view_state->vs_rc){
    view_ring_destroy(dlp);
    bu_free((genptr_t)dlp->dml_view_state, "free_all_resources: view_state");
  }

  if (!--dlp->dml_adc_state->adc_rc)
    bu_free((genptr_t)dlp->dml_adc_state, "free_all_resources: adc_state");

  if (!--dlp->dml_menu_state->ms_rc)
    bu_free((genptr_t)dlp->dml_menu_state, "free_all_resources: menu_state");

  if (!--dlp->dml_rubber_band->rb_rc)
    bu_free((genptr_t)dlp->dml_rubber_band, "free_all_resources: rubber_band");

  if (!--dlp->dml_mged_variables->mv_rc)
    bu_free((genptr_t)dlp->dml_mged_variables, "free_all_resources: mged_variables");

  if (!--dlp->dml_color_scheme->cs_rc)
    bu_free((genptr_t)dlp->dml_color_scheme, "free_all_resources: color_scheme");

  if (!--dlp->dml_grid_state->gr_rc)
    bu_free((genptr_t)dlp->dml_grid_state, "free_all_resources: grid_state");

  if (!--dlp->dml_axes_state->ax_rc)
    bu_free((genptr_t)dlp->dml_axes_state, "free_all_resources: axes_state");
}

void
share_dlist(struct dm_list *dlp2)
{
  struct dm_list *dlp1;

  if(!dlp2->dml_dmp->dm_displaylist)
    return;

  FOR_ALL_DISPLAYS(dlp1, &head_dm_list.l){
    if(dlp1 != dlp2 && 
       dlp1->dml_dmp->dm_type == dlp2->dml_dmp->dm_type &&
       !strcmp(bu_vls_addr(&dlp1->dml_dmp->dm_dName), bu_vls_addr(&dlp2->dml_dmp->dm_dName))){
      if (dm_share_dlist(dlp1->dml_dmp, dlp2->dml_dmp) == TCL_OK) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	SHARE_RESOURCE(0,_dlist_state,dml_dlist_state,dl_rc,dlp1,dlp2,vls,"share: dlist_state");
	dlp1->dml_dirty = dlp2->dml_dirty = 1;
	bu_vls_free(&vls);
      }
      
      break;
    }
  }
}
@


1.18
log
@change conf.h to a wrapped config.h
@
text
@@


1.17
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 5
a28 1
#include "conf.h"
@


1.16
log
@update copyright to include span through 2003
@
text
@d76 2
a77 2
extern void mged_vls_struct_parse(); /* defined in vparse.c */
extern void view_ring_init(); /* defined in chgview.c */
d85 1
a85 1
void free_all_resources();
d102 1
a102 5
f_share(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d279 1
a279 5
f_rset (clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d407 1
a407 2
free_all_resources(dlp)
struct dm_list *dlp;
d437 1
a437 2
share_dlist(dlp2)
struct dm_list *dlp2;
@


1.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *      This software is Copyright (C) 1998 by the United States Army.
@


1.15.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *      This software is Copyright (C) 1998-2004 by the United States Army.
@


1.15.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *      This software is Copyright (C) 1998-2004 by the United States Army.
@


1.15.2.1
log
@Initial ANSIfication
@
text
@d76 2
a77 2
extern void mged_vls_struct_parse(struct bu_vls *vls, char *title, struct bu_structparse *how_to_parse, char *structp, int argc, char **argv); /* defined in vparse.c */
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */
d85 1
a85 1
void free_all_resources(struct dm_list *dlp);
d102 5
a106 1
f_share(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d283 5
a287 1
f_rset (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d415 2
a416 1
free_all_resources(struct dm_list *dlp)
d446 2
a447 1
share_dlist(struct dm_list *dlp2)
@


1.15.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *      This software is Copyright (C) 1998-2004 by the United States Army.
@


1.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d76 2
a77 2
extern void mged_vls_struct_parse(struct bu_vls *vls, char *title, struct bu_structparse *how_to_parse, char *structp, int argc, char **argv); /* defined in vparse.c */
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */
d85 1
a85 1
void free_all_resources(struct dm_list *dlp);
d102 5
a106 1
f_share(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d283 5
a287 1
f_rset (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d415 2
a416 1
free_all_resources(struct dm_list *dlp)
d446 2
a447 1
share_dlist(struct dm_list *dlp2)
@


1.13
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d76 2
a77 2
extern void mged_vls_struct_parse(); /* defined in vparse.c */
extern void view_ring_init(); /* defined in chgview.c */
d85 1
a85 1
void free_all_resources();
d102 1
a102 5
f_share(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d279 1
a279 5
f_rset (clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int     argc;
char    **argv;
d407 1
a407 2
free_all_resources(dlp)
struct dm_list *dlp;
d437 1
a437 2
share_dlist(dlp2)
struct dm_list *dlp2;
@


1.12
log
@updated SIGNED to signed
updated CONST to const
@
text
@d201 1
a201 1
	    createDLists(&HeadSolid);
@


1.11
log
@Lint
@
text
@d296 1
a296 1
			  (CONST char *)axes_state, argc, argv);
d299 1
a299 1
			  (CONST char *)color_scheme, argc, argv);
d302 1
a302 1
			  (CONST char *)grid_state, argc, argv);
d305 1
a305 1
			  (CONST char *)rubber_band, argc, argv);
d308 1
a308 1
			  (CONST char *)mged_variables, argc, argv);
d323 1
a323 1
			    (CONST char *)axes_state, argc-1, argv+1);
d335 1
a335 1
			  (CONST char *)color_scheme, argc-1, argv+1);
d340 1
a340 1
			  (CONST char *)grid_state, argc-1, argv+1);
d345 1
a345 1
			  (CONST char *)rubber_band, argc-1, argv+1);
d352 1
a352 1
				(CONST char *)mged_variables, argc-1, argv+1);
@


1.10
log
@
Fixed compiler lint, function declarations.
@
text
@d27 7
@


1.9
log
@Eliminated an unused variable
@
text
@d376 1
a376 3
usurp_all_resources(dlp1, dlp2)
struct dm_list *dlp1;
struct dm_list *dlp2;
@


1.8
log
@*- mods to f_rset() and f_share()
@
text
@a281 1
  int rflag;
@


1.7
log
@*- use helpdevel for help on developer commands
@
text
@d86 3
a88 3
 *	Currently, there are eight different resources that can be shared.
 *	They are as follows:
 *		ADC AXES COLOR_SCHEMES GRID MENU MGED_VARIABLES RUBBER_BAND VIEW
d221 2
a222 1
    if (argv[1][1] == 'a' || argv[1][1] == 'A')
d289 1
a289 1
    mged_vls_struct_parse(&vls, "Axes", axes_vparse,
d292 1
a292 1
    mged_vls_struct_parse(&vls, "Color Schemes", color_scheme_vparse,
d295 1
a295 1
    mged_vls_struct_parse(&vls, "Grid", grid_vparse,
d298 1
a298 1
    mged_vls_struct_parse(&vls, "Rubber Band", rubber_band_vparse,
d301 1
a301 1
    mged_vls_struct_parse(&vls, "mged variables", mged_vparse,
a335 4
  case 'm':
  case 'M':
    bu_vls_printf(&vls, "rset: no support available for the 'menu' resource");
    break;
d343 2
a344 1
    if (argv[1][1] == 'a' || argv[1][1] == 'A')
@


1.6
log
@*- mods to f_share to print values of all resources
	if no arguments are given
@
text
@d109 1
a109 1
    bu_vls_printf(&vls, "help share");
@


1.5
log
@*- code to support sharing display lists
*- modified use of and definition of SHARE_RESOURCE
	(i.e. no longer doing a return from within SHARE_RESOURCE)
@
text
@d266 1
a266 1
 *	rset res_type res vals
d286 16
a301 3
  if (argc < 2) {
    bu_vls_printf(&vls, "help rset");
    Tcl_Eval(interp, bu_vls_addr(&vls));
d303 1
d305 2
a306 1
    return TCL_ERROR;
d313 1
a313 1
      bu_vls_printf(&vls, "rset: no support available for the 'adc' resource");
@


1.4
log
@*- mods to SHARE_RESOURCE
*- mods to f_share()
*- added usurp_all_resources() and free_all_resources()
@
text
@d34 1
d50 6
a55 3
      if (dlp1->resource->rc == 1) {   /* already not sharing */ \
	bu_vls_free(&vls); \
	return TCL_OK; \
d57 5
d63 2
a64 10
      --dlp1->resource->rc; \
      strp = dlp1->resource; \
      BU_GETSTRUCT(dlp1->resource, str); \
      *dlp1->resource = *strp;        /* struct copy */ \
      dlp1->resource->rc = 1; \
    } else { \
      /* already sharing this resource */ \
      if (dlp1->resource == dlp2->resource) { \
	bu_vls_free(&vls); \
	return TCL_OK; \
a65 6
\
      if (!--dlp2->resource->rc) \
	bu_free((genptr_t)dlp2->resource, error_msg); \
\
      dlp2->resource = dlp1->resource; \
      ++dlp1->resource->rc; \
d102 2
a103 1
  struct dm_list *dlp1, *dlp2;
d173 34
d231 2
a232 1
	view_ring_init(dlp1->dml_view_state, ovsp);
d387 4
d403 1
a403 1
    bu_free((genptr_t)dlp->dml_view_state, "release: view_state");
d407 1
a407 1
    bu_free((genptr_t)dlp->dml_adc_state, "release: adc_state");
d410 1
a410 1
    bu_free((genptr_t)dlp->dml_menu_state, "release: menu_state");
d413 1
a413 1
    bu_free((genptr_t)dlp->dml_rubber_band, "release: rubber_band");
d416 1
a416 1
    bu_free((genptr_t)dlp->dml_mged_variables, "release: mged_variables");
d419 1
a419 1
    bu_free((genptr_t)dlp->dml_color_scheme, "release: color_scheme");
d422 1
a422 1
    bu_free((genptr_t)dlp->dml_grid_state, "release: grid_state");
d425 28
a452 1
    bu_free((genptr_t)dlp->dml_axes_state, "release: axes_state");
@


1.3
log
@*- insignificant typo
@
text
@a35 8
extern void mged_vls_struct_parse();

extern struct bu_structparse axes_vparse[];
extern struct bu_structparse color_scheme_vparse[];
extern struct bu_structparse grid_vparse[];
extern struct bu_structparse rubber_band_vparse[];
extern struct bu_structparse mged_vparse[];

d58 1
d60 1
a60 1
      /* already sharing a menu */ \
d74 11
d193 17
a209 3
    else if (argv[1][1] == 'i' || argv[1][1] == 'I')
      SHARE_RESOURCE(uflag,_view_state,dml_view_state,vs_rc,dlp1,dlp2,vls,"share: view_state")
    else {
d326 65
@


1.2
log
@*- use new structures
*- cleanup
@
text
@d92 1
a92 1
 *	share res_type p1 p2	--->	causes 'p1' to share its' resource of type 'res_type' with 'p2'
@


1.1
log
@*- utilities for sharing resources among display managers
@
text
@d4 2
a5 1
 * Routines for sharing resources among display managers.
@
