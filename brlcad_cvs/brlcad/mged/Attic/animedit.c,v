head	11.49;
access;
symbols
	ansi-20040405-merged:11.45.2.1
	postmerge-20040405-ansi:11.47
	premerge-20040404-ansi:11.46
	postmerge-autoconf:11.46
	autoconf-freeze:11.45.10.1
	premerge-autoconf:11.46
	postmerge-20040315-windows:11.46
	premerge-20040315-windows:11.45
	windows-20040315-freeze:11.45.4.1
	autoconf-20031203:11.45
	autoconf-20031202:11.45
	autoconf-branch:11.45.0.10
	phong-branch:11.45.0.8
	photonmap-branch:11.45.0.6
	rel-6-1-DP:11.45
	windows-branch:11.45.0.4
	rel-6-0-2:11.43
	ansi-branch:11.45.0.2
	rel-6-0-1-branch:11.43.0.2
	hartley-6-0-post:11.44
	hartley-6-0-pre:11.43
	rel-6-0-1:11.43
	rel-6-0:11.43
	rel-5-4:11.25
	offsite-5-3-pre:11.35
	rel-5-3:11.25
	rel-5-2:11.25
	rel-5-1-branch:11.25.0.2
	rel-5-1:11.25
	rel-5-0:11.22
	rel-5-0-beta:11.21
	rel-4-5:11.19
	ctj-4-5-post:11.17
	ctj-4-5-pre:11.17
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.49
date	2004.05.21.17.47.34;	author morrison;	state dead;
branches;
next	11.48;

11.48
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.47;

11.47
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.46;

11.46
date	2004.03.16.21.15.10;	author morrison;	state Exp;
branches;
next	11.45;

11.45
date	2002.08.20.17.08.21;	author jra;	state Exp;
branches
	11.45.2.1
	11.45.4.1
	11.45.10.1;
next	11.44;

11.44
date	2002.08.15.20.55.31;	author hartley;	state Exp;
branches;
next	11.43;

11.43
date	2001.08.11.13.16.11;	author butler;	state Exp;
branches;
next	11.42;

11.42
date	2001.06.18.19.24.23;	author bparker;	state Exp;
branches;
next	11.41;

11.41
date	2001.06.01.19.23.22;	author bparker;	state Exp;
branches;
next	11.40;

11.40
date	2001.05.16.21.38.08;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2001.05.08.20.20.58;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2001.04.05.19.35.42;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2001.04.02.21.38.17;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2001.03.31.01.57.19;	author morrison;	state Exp;
branches;
next	11.35;

11.35
date	2000.11.01.21.19.29;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.10.24.19.05.04;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.10.24.15.34.12;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.10.24.15.19.27;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.09.09.04.30.54;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.09.08.05.55.47;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.08.19.03.10.10;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.06.29.18.57.07;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.06.28.17.03.33;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.06.28.16.11.06;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.05.16.20.31.43;	author cjohnson;	state Exp;
branches;
next	11.24;

11.24
date	2000.01.07.04.21.18;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.01.04.17.58.21;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	99.09.01.18.55.08;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	98.12.17.04.19.11;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	98.03.19.15.55.50;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	97.08.22.22.38.22;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	97.06.03.16.03.59;	author pjt;	state Exp;
branches;
next	11.16;

11.16
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.01.29.05.35.44;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.01.02.19.35.05;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.12.04.03.39.35;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.10.04.14.56.10;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	96.09.25.20.16.42;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	96.09.23.18.40.01;	author bparker;	state Exp;
branches;
next	11.7;

11.7
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.6;

11.6
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.08.22.20.54.17;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	95.12.27.22.35.08;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	95.03.10.20.46.54;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.34;	author mike;	state Rel4_4;
branches;
next	1.13;

1.13
date	94.12.20.16.46.48;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	94.11.19.00.58.31;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	94.11.10.12.05.58;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	94.10.22.05.56.46;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	94.10.21.19.42.04;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	94.09.23.18.57.13;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.08.09.14.35.23;	author gdurf;	state Exp;
branches;
next	1.6;

1.6
date	94.08.09.14.34.55;	author gdurf;	state Exp;
branches;
next	1.5;

1.5
date	94.07.12.21.59.56;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.07.12.21.56.57;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.06.03.12.27.39;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	94.06.01.16.52.24;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	94.03.24.16.15.09;	author cjohnson;	state Exp;
branches;
next	;

11.45.2.1
date	2002.09.19.18.01.59;	author morrison;	state Exp;
branches;
next	;

11.45.4.1
date	2002.09.26.23.04.07;	author morrison;	state Exp;
branches;
next	;

11.45.10.1
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Articulation/animation of mged models.
@


11.49
log
@moved to src/mged/
@
text
@/*
 *			A N I M E D I T . C
 *
 * Process all animation edit commands.
 *
 *  Function -
 *	f_joint	start the animation edit
 *
 *  Author -
 *	Christopher T. Johnson
 *
 *  Source -
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994 by Geometric Solutions, Inc.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/animedit.c,v 11.48 2004/05/10 15:30:47 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./joints.h"

extern struct db_i	*dbip;	/* database instance pointer */

static unsigned int joint_debug = 0;
#define DEBUG_J_MESH	0x00000001
#define DEBUG_J_LOAD	0x00000002
#define DEBUG_J_MOVE	0x00000004
#define DEBUG_J_SOLVE	0x00000008
#define DEBUG_J_EVAL	0x00000010
#define DEBUG_J_SYSTEM	0x00000020
#define DEBUG_J_PARSE	0x00000040
#define DEBUG_J_LEX	0x00000080
#define JOINT_DEBUG_FORMAT \
"\020\10LEX\7PARSE\6SYSTEM\5EVAL\4SOLVE\3MOVE\2LOAD\1MESH"

void joint_move(struct joint *jp);
void joint_clear(void);

static int f_jfhelp(int argc, char **argv);
int f_fhelp2(int argc, char **argv, struct funtab *functions);
static int f_jhelp(int argc, char **argv);
int f_help2(int argc, char **argv, struct funtab *functions);
int f_jmesh(int argc, char **argv);
int f_jdebug(int argc, char **argv);
int f_jload(int argc, char **argv);
int f_junload(int argc, char **argv);
int f_jmove(int argc, char **argv);
int f_jlist(int argc, char **argv);
int f_jaccept(int argc, char **argv);
int f_jreject(int argc, char **argv);
int f_jsave(int argc, char **argv);
int f_jhold(int argc, char **argv);
int f_jsolve(int argc, char **argv);
int f_jtest(int argc, char **argv);

static struct funtab joint_tab[] = {
{"joint ", "", "Joint command table",
	0, 0, 0, FALSE},
{"?", "[commands]", "summary of available joint commands",
	f_jfhelp, 0, MAXARGS, FALSE},
{"accept", "[joints]", "accept a series of moves",
	f_jaccept, 1, MAXARGS, FALSE},
{"debug", "[hex code]", "Show/set debuging bit vector for joints",
	f_jdebug, 1, 2, FALSE},
{"help", "[commands]", "give usage message for given joint commands",
	f_jhelp, 0, MAXARGS, FALSE},
{"holds","[names]", "list constraints",
	f_jhold, 1, MAXARGS, FALSE},
{"list", "[names]", "list joints.",
	f_jlist, 1, MAXARGS, FALSE},
{"load", "file_name", "load a joint/constraint file",
	f_jload, 2, MAXARGS, FALSE},
{"mesh", "", "Build the grip mesh",
	f_jmesh, 0, 1, FALSE},
{"move", "joint_name p1 [p2...p6]", "Manual adjust a joint",
	f_jmove, 3, 8, FALSE},
{"reject", "[joint_names]", "reject joint motions",
	f_jreject, 1, MAXARGS, FALSE},
{"save",	"file_name", "Save joints and constraints to disk",
	f_jsave, 2, 2, FALSE},
{"solve", "constraint", "Solve a or all constraints",
	f_jsolve, 1, MAXARGS, FALSE},
{"test", "file_name", "test use of bu_lex routine.",
	f_jtest, 2, 2, FALSE},
{"unload", "", "Unload any joint/constrants that have been loaded",
	f_junload, 1,1, FALSE},
{NULL, NULL, NULL,
	NULL,0,0, FALSE}
};

#define db_init_full_path(_fp) {\
	(_fp)->fp_len = (_fp)->fp_maxlen = 0; \
	(_fp)->magic = DB_FULL_PATH_MAGIC; }	
int
f_jdebug(int	argc,
	 char	**argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (argc >= 2) {
		sscanf(argv[1], "%x", &joint_debug);
	} else {
		bu_vls_printb(&vls, "possible flags", 0xffffffffL, JOINT_DEBUG_FORMAT );
		bu_vls_printf(&vls, "\n");
	}
	bu_vls_printb(&vls, "joint_debug", joint_debug, JOINT_DEBUG_FORMAT);
	bu_vls_printf(&vls, "\n");

	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return CMD_OK;
}
int
f_joint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int status;

  if(argc < 1){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help joint");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  argc--;
  argv++;

  status = mged_cmd(argc, argv, &joint_tab[0]);

  if(status == CMD_OK)
    return TCL_OK;

  return TCL_ERROR;
}

static int
f_jfhelp(int argc, char **argv)
{
  int status;

  status = f_fhelp2(argc, argv, &joint_tab[0]);

  if(status == TCL_OK)
    return CMD_OK;
  else
    return CMD_BAD;
}

static int
f_jhelp(int argc, char **argv)
{
  int status;

  status = f_help2(argc, argv, &joint_tab[0]);

  if(status == TCL_OK)
    return CMD_OK;
  else
    return CMD_BAD;
}
struct bu_list joint_head = {
	BU_LIST_HEAD_MAGIC,
	&joint_head, &joint_head
};
struct bu_list hold_head = {
	BU_LIST_HEAD_MAGIC,
	&hold_head, &hold_head
};
static struct joint *
joint_lookup(char *name)
{
	register struct joint *jp;

	for (BU_LIST_FOR(jp, joint, &joint_head)) {
		if (strcmp(jp->name, name) == 0) return jp;
	}
	return (struct joint *) 0;
}
static void
free_arc(struct arc *ap)
{
	register int i;
	if (!ap || ap->type == ARC_UNSET) return;
	for (i=0; i<=ap->arc_last; i++) {
		bu_free((genptr_t)ap->arc[i], "arc entry");
	}
	bu_free((genptr_t)ap->arc, "arc table");
	ap->arc = (char **)0;
	if (ap->type & ARC_BOTH) {
		for (i=0; i<=ap->arc_last; i++) {
			bu_free((genptr_t)ap->original[i], "arc entry");
		}
		bu_free((genptr_t)ap->original, "arc table");
	}
	ap->type=ARC_UNSET;
}
static void
free_joint(struct joint *jp)
{
	free_arc(&jp->path);
	if (jp->name) bu_free((genptr_t)jp->name, "joint name");
	bu_free((genptr_t)jp, "joint structure");
}

static void
free_hold(struct hold *hp)
{
	register struct jointH *jh;

	if (!hp || hp->l.magic != MAGIC_HOLD_STRUCT) return;
	if (hp->objective.type != ID_FIXED) {
		if (hp->objective.path.fp_maxlen) {
			db_free_full_path(&hp->objective.path);
		}
		free_arc(&hp->objective.arc);
	}
	if (hp->effector.type != ID_FIXED) {
		if (hp->effector.path.fp_maxlen) {
			db_free_full_path(&hp->effector.path);
		}
		free_arc(&hp->effector.arc);
	}
	while (BU_LIST_WHILE(jh, jointH, &hp->j_head)) {
		jh->p->uses--;
		BU_LIST_DEQUEUE(&jh->l);
		bu_free((genptr_t) jh, "joint handle");
	}
	if (hp->joint) bu_free((genptr_t)hp->joint, "hold joint name");
	if (hp->name) bu_free((genptr_t)hp->name, "hold name");
	bu_free((genptr_t)hp, "hold struct");
}
static void
hold_clear_flags(struct hold *hp)
{
	hp->effector.flag = hp->objective.flag = 0;
}
#if 0
static
read_hold_point(pp, name, fip)
struct hold_point *pp;
char *name;
FILE *fip;
{
	char			**arc;
	int			arc_last;
	char			text[TEXT_LEN];
	register int 		i;
	struct directory	*dp;
	struct joint		*jp;

	if (!get_line(text, TEXT_LEN, fip)) {
	  Tcl_AppendResult(interp, "joint load constraint: unable to read ",
			   name, " type\n", (char *)NULL);
	  return 0;
	}
	pp->type = atoi(text);
	if (pp->type == 1) pp->type = ID_GRIP;
	if (joint_debug & DEBUG_J_LOAD) {
		static char *names[] = {
			"FIXED",
			"GRIP",
			"JOINT",
			"UNKNOWN"};
		int t = pp->type;
		if (t < 0 || t > 3) t = 3;
		Tcl_AppendResult(interp, "joint load point: Type is ", names[t],
				 "\n", (char *)NULL); 
	}
	switch (pp->type) {
	case HOLD_PT_FIXED:
		if (!get_line(text, TEXT_LEN, fip)) {
		  Tcl_AppendResult(interp, "joint load constraint: unable to read ",
				   name, " 3space point\n", (char *)NULL);
		  return 0;
		}

		if (sscanf(text,"%lg %lg %lg", &pp->point[X], &pp->point[Y],
		    &pp->point[Z]) != 3) {
		  Tcl_AppendResult(interp, "joint load constraint: unable to read points for ",
				   name, ".\n", (char *)NULL);
		  return 0;
		}
		if (joint_debug & DEBUG_J_LOAD) {
		  struct bu_vls tmp_vls;
		  
		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "joint load point: (%g %g %g)\n", pp->point[X],
				pp->point[Y], pp->point[Z]);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
		return 1;
	case ID_GRIP:
/*
 * XXX - Final method will be top grip_name.  For now, we will just use "arc"
 */
		if (!get_line(text, TEXT_LEN, fip)) {
		  Tcl_AppendResult(interp, "joint load constraint: unable to read ",
				   name, " arc.\n", (char *)NULL);
		  return 0;
		}
		arc = parse_arc(&arc_last, text);
		/*
		 * we are now going to build a full_path from the arc.
		 */
		pp->path.fp_len=pp->path.fp_maxlen = arc_last+1;
		pp->path.fp_names = (struct directory **)
		    bu_malloc(sizeof(struct directory **)*pp->path.fp_maxlen,
		    "db full path");
		for (i=0; i<=arc_last; i++) {
			dp = db_lookup(dbip, arc[i], LOOKUP_NOISY);
			if (!dp) break;
			pp->path.fp_names[i] = dp;
		}
		if (!dp) {
		  Tcl_AppendResult(interp, "joint load constraint: arc '", text,
				   "' for ", name, " is bad.\n", (char *)NULL);
		  for (i=0; i<=arc_last; i++) {
		    bu_free((genptr_t)arc[i], "arc entry");
		  }
		  bu_free((genptr_t) arc, "arc table");
		  return 0;
		}
		pp->name = arc[arc_last];
		/*
		 * NOTE: we are not freeing the last entry which should be
		 * a grip as we save it's name in pp->name.
		 */
		for (i=0; i< arc_last; i++) {
			bu_free((genptr_t)arc[i], "arc entry");
		}
		bu_free((genptr_t) arc, "arc table");
		return 1;
	case HOLD_PT_JOINT:
/*
 * XXX - Final method will be top joint_name.  For now, we will just use "arc"
 */
		if (!get_line(text, TEXT_LEN, fip)) {
		  Tcl_AppendResult(interp, "joint load constraint: unable to read ",
				   name, " arc.\n", (char *)NULL);
		  return 0;
		}
		arc = parse_arc(&arc_last, text);
		/*
		 * we are now going to build a full_path from the arc.
		 */
		pp->path.fp_len=pp->path.fp_maxlen = arc_last+1;
		pp->path.fp_names = (struct directory **)
		    bu_malloc(sizeof(struct directory **)*pp->path.fp_maxlen,
		    "db full path");
		/*
		 * Except for the last entry which should be a joint name.
		 */
		for (i=0; i<arc_last; i++) {
			dp = db_lookup(dbip, arc[i], LOOKUP_NOISY);
			if (!dp) break;
			pp->path.fp_names[i] = dp;
		}
		if (dp) {
			jp = joint_lookup(arc[arc_last]);
			if (jp) {
				dp = db_lookup(dbip, jp->arc[jp->arc_last],
				    LOOKUP_NOISY);
				if (dp) {
					pp->path.fp_names[i] = dp;
				}
			} else {
			  Tcl_AppendResult(interp, "joint load constraint: ", name,
					   " gave bad joint name.\n", (char *)NULL);
			  dp = 0;
			}
		}
		if (!dp) {
		  Tcl_AppendResult(interp, "joint load constraint: arc '", text,
				   "' for ", name, " is bad.\n", (char *)NULL);
			for (i=0; i<arc_last; i++) {
				bu_free((genptr_t)arc[i], "arc entry");
			}
			bu_free((genptr_t) arc, "arc table");
			return 0;
		}
		pp->name = arc[arc_last];
		/*
		 * NOTE: we are not freeing the last entry which should be
		 * a joint as we save it's name in pp->name.
		 */
		for (i=0; i< arc_last; i++) {
			bu_free((genptr_t)arc[i], "arc entry");
		}
		bu_free((genptr_t) arc, "arc table");
		return 1;
	default:
	  {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "joint load constrain: Bad type (%d) for %s.\n",
			  pp->type, name);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }

	  pp->type = HOLD_PT_FIXED;
	  return 0;
	}
	/*NEVERREACHED*/
}
#endif /* 0 */
#if 0
	if (!read_hold_point(&hp->effector,"effector", fip)) {
		free_hold(hp);
		return (struct hold*)0;
	}
	/*
	 * objective.
	 */
	if (!read_hold_point(&hp->objective, "objective", fip)) {
		free_hold(hp);
		return (struct hold *)0;
	}
#endif /* 0 */

int
f_junload(int argc, char **argv)
{
	register struct joint *jp;
	register struct hold *hp;
	int joints, holds;

	CHECK_DBI_NULL;

	db_free_anim(dbip);
	holds = 0;
	while (BU_LIST_WHILE(hp, hold, &hold_head)) {
		holds++;
		BU_LIST_DEQUEUE(&hp->l);
		free_hold(hp);
	}
	joints = 0;
	while (BU_LIST_WHILE(jp, joint, &joint_head)) {
		joints++;
		BU_LIST_DEQUEUE(&(jp->l));
		if (joint_debug & DEBUG_J_LOAD) {
		  Tcl_AppendResult(interp, "joint unload: unloading '", 
				   jp->name, "'.\n", (char *)NULL);
		}
		free_joint(jp);
	}
	if (joint_debug & DEBUG_J_LOAD) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "joint unload: unloaded %d joints, %d constraints.\n",
			joints, holds);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	return CMD_OK;
}
#define	KEY_JOINT	1
#define KEY_CON		2
#define	KEY_ARC		3
#define KEY_LOC		4
#define KEY_TRANS	5
#define KEY_ROT		6
#define KEY_LIMIT	7
#define KEY_UP		8
#define KEY_LOW		9
#define KEY_CUR		10
#define KEY_ACC		11
#define KEY_DIR		12
#define KEY_UNITS	13
#define KEY_JOINTS	14
#define KEY_START	15
#define KEY_PATH	16
#define KEY_WEIGHT	17
#define KEY_PRI		18
#define KEY_EFF		19
#define KEY_POINT	20
#define KEY_EXCEPT	21
#define KEY_INF		22
#define KEY_VERTEX	23

static struct bu_lex_key keys[] = {
	{KEY_JOINT, "joint"},
	{KEY_CON,   "constraint"},
	{KEY_ARC,   "arc"},
	{KEY_LOC,   "location"},
	{KEY_TRANS, "translate"},
	{KEY_ROT,   "rotate"},
	{KEY_LIMIT, "limits"},
	{KEY_UP,    "upper"},
	{KEY_LOW,   "lower"},
	{KEY_CUR,   "current"},
	{KEY_ACC,   "accepted"},
	{KEY_DIR,   "direction"},
	{KEY_UNITS, "units"},
	{KEY_JOINTS,"joints"},
	{KEY_START, "start"},
	{KEY_PATH,  "path"},
	{KEY_WEIGHT,"weight"},
	{KEY_PRI,   "priority"},
	{KEY_EFF,   "effector"},
	{KEY_POINT, "point"},
	{KEY_EXCEPT,"except"},
	{KEY_INF,   "INF"},
	{KEY_VERTEX,"vertex"},
	{0,0}};

#define UNIT_INCH	1
#define UNIT_METER	2
#define UNIT_FEET	3
#define UNIT_CM		4
#define UNIT_MM		5

static struct bu_lex_key units[] = {
	{UNIT_INCH,	"inches"},
	{UNIT_INCH,	"in"},
	{UNIT_METER,	"m"},
	{UNIT_METER,	"meters"},
	{UNIT_FEET,	"ft"},
	{UNIT_FEET,	"feet"},
	{UNIT_CM,	"cm"},
	{UNIT_MM,	"mm"},
	{0,0}};

#define ID_FIXED	-1
static struct bu_lex_key lex_solids[] = {
	{ID_FIXED,	"fixed"},
	{ID_GRIP,	"grip"},
	{ID_SPH,	"sphere"},
	{ID_JOINT,	"joint"},
	{0,0}};

#define SYM_OP_GROUP	1
#define SYM_CL_GROUP	2
#define SYM_OP_PT	3
#define SYM_CL_PT	4
#define SYM_EQ		5
#define SYM_ARC		6
#define SYM_END		7
#define SYM_COMMA	8
#define SYM_MINUS	9
#define SYM_PLUS	10

static struct bu_lex_key syms[] = {
	{SYM_OP_GROUP,	"{"},
	{SYM_CL_GROUP,	"}"},
	{SYM_OP_PT,	"("},
	{SYM_CL_PT,	")"},
	{SYM_EQ,	"="},
	{SYM_ARC,	"/"},
	{SYM_END,	";"},
	{SYM_COMMA,	","},
	{SYM_MINUS,	"-"},
	{SYM_PLUS,	"+"},
	{0,0}};

static int lex_line;
static char *lex_name;
static double mm2base, base2mm;

static void
parse_error(struct bu_vls *str, char *error)
{
	char *text;
	int i;

	if (!str->vls_str) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "%s:%d %s\n",lex_name, lex_line,error);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  return;
	}
	text = bu_malloc(str->vls_offset+2, "error pointer");
	for (i=0; i<str->vls_offset; i++) {
		text[i]=(str->vls_str[i] == '\t')? '\t' : '-';
	}
	text[str->vls_offset] = '^';
	text[str->vls_offset+1] = '\0';

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "%s:%d %s\n%s\n%s\n",lex_name, lex_line,error,str->vls_str,text);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	bu_free(text, "error pointer");
}

int
get_token(union bu_lex_token *token, FILE *fip, struct bu_vls *str, struct bu_lex_key *keys, struct bu_lex_key *syms)
{
  int	used;
  for (;;) {
    used = bu_lex(token, str, keys, syms);
    if (used) break;
    bu_vls_free(str);
    lex_line++;
    used = bu_vls_gets(str,fip);
    if (used == EOF) return used;
  }

  bu_vls_nibble(str, used);

  {
    struct bu_vls tmp_vls;

    bu_vls_init(&tmp_vls);
    if (joint_debug & DEBUG_J_LEX) {
		register int i;
		switch (token->type) {
		case BU_LEX_KEYWORD:
			for (i=0; keys[i].tok_val != token->t_key.value; i++);
			bu_vls_printf(&tmp_vls,"lex: key(%d)='%s'\n", token->t_key.value,
			    keys[i].string);
			break;
		case BU_LEX_SYMBOL:
			for (i=0; syms[i].tok_val != token->t_key.value; i++);
			bu_vls_printf(&tmp_vls,"lex: symbol(%d)='%c'\n", token->t_key.value,
			    *(syms[i].string));
			break;
		case BU_LEX_DOUBLE:
			bu_vls_printf(&tmp_vls,"lex: double(%g)\n", token->t_dbl.value);
			break;
		case BU_LEX_INT:
			bu_vls_printf(&tmp_vls,"lex: int(%d)\n", token->t_int.value);
			break;
		case BU_LEX_IDENT:
			bu_vls_printf(&tmp_vls,"lex: id(%s)\n", token->t_id.value);
			break;
		}
    }

    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }
    return used;
}

static int
gobble_token(int type_wanted, int value_wanted, FILE *fip, struct bu_vls *str)
{
	static char *types[] = {
		"any",
		"integer",
		"double",
		"symbol",
		"keyword",
		"identifier",
		"number"};
	union bu_lex_token token;
	char error[160];

	if (get_token(&token, fip, str, keys, syms) == EOF) {
		sprintf(error,"parse: Unexpected EOF while getting %s",
		    types[type_wanted]);
		parse_error(str, error);
		return 0;
	}

	if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");

	switch (type_wanted) {
	case BU_LEX_ANY:
		 return 1;
	case BU_LEX_INT:
		return (token.type == BU_LEX_INT);
	case BU_LEX_DOUBLE:
		return (token.type == BU_LEX_DOUBLE);
	case BU_LEX_NUMBER:
		return (token.type == BU_LEX_INT || token.type == BU_LEX_DOUBLE);
	case BU_LEX_SYMBOL:
		return (token.type == BU_LEX_SYMBOL &&
		    value_wanted == token.t_key.value);
	case BU_LEX_KEYWORD:
		return (token.type == BU_LEX_KEYWORD &&
		    value_wanted == token.t_key.value);
	case BU_LEX_IDENT:
		return (token.type == BU_LEX_IDENT);
	}
	return 0;
}
static void
skip_group(FILE *fip, struct bu_vls *str)
{
	union bu_lex_token tok;
	int count = 1;
	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "skip_group: Skipping....\n", (char *)NULL);
	}

	while (count) {
		if (get_token(&tok, fip, str, keys,syms) == EOF) {
			parse_error(str,"skip_group: Unexpect EOF while searching for group end.");
			return;
		}
		if (tok.type == BU_LEX_IDENT) bu_free(tok.t_id.value, "unit token");
		if (tok.type != BU_LEX_SYMBOL) continue;
		if (tok.t_key.value == SYM_OP_GROUP) {
			count++;
		} else if (tok.t_key.value == SYM_CL_GROUP) {
			count--;
		}
	}
	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "skip_group: Done....\n", (char *)NULL);
	}

}
static int
parse_units(FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;

	if (get_token(&token,fip, str, units, syms) == EOF) {
		parse_error(str, "parse_units: Unexpect EOF reading units.");
		return 0;
	}
	if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");
	if (token.type != BU_LEX_KEYWORD) {
		parse_error(str, "parse_units: syntax error getting unit type.");
		return 0;
	}

	switch (token.t_key.value) {
	case UNIT_INCH:
		base2mm = 25.4; break;
	case UNIT_METER:
		base2mm = 1000.0; break;
	case UNIT_FEET:
		base2mm = 304.8; break;
	case UNIT_CM:
		base2mm = 10.0; break;
	case UNIT_MM:
		base2mm = 1; break;
	}
	mm2base = 1.0 / base2mm;
	(void) gobble_token(BU_LEX_SYMBOL, SYM_END, fip,str);
	return 1;
}
static int
parse_path(struct arc *ap, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	int max;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_path: open.\n", (char *)NULL);
	}
	/*
 	 * clear the arc if there is anything there.
	 */
	free_arc(ap);
	if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) return 0;
	max = 32;
	ap->arc = (char **)bu_malloc(sizeof(char *)*max, "arc table");
	ap->arc_last = -1;
	ap->type = ARC_PATH;
	for (;;) {
		if (get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
			parse_error(str,"parse_path: Unexpect EOF.");
			free_arc(ap);
			return 0;
		}
		if (token.type != BU_LEX_IDENT) {
			parse_error(str,"parse_path: syntax error. Missing identifier.");
			free_arc(ap);
			return 0;
		}
		if (++ap->arc_last >= max) {
			max +=32;
			ap->arc = (char **) bu_realloc((char *) ap->arc,
			    sizeof(char *)*max, "arc table");
		}
		ap->arc[ap->arc_last] = token.t_id.value;
		if (get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
			parse_error(str, "parse_path: Unexpect EOF while getting '/' or '-'");
			free_arc(ap);
			return 0;
		}
		if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");
		if (token.type != BU_LEX_SYMBOL) {
			parse_error(str, "parse_path: syntax error.");
			free_arc(ap);
			return 0;
		}
		if (token.t_key.value == SYM_ARC) {
			continue;
		}else if (token.t_key.value == SYM_MINUS) {
			break;
		} else {
			parse_error(str,"parse_path: syntax error.");
			free_arc(ap);
			return 0;
		}
	}
	/*
	 * Just got the '-' so this is the "destination" part.
	 */
	if (get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
		parse_error(str,"parse_path: Unexpected EOF while getting destination.");
		free_arc(ap);
		return 0;
	}
	if (token.type != BU_LEX_IDENT) {
		parse_error(str,"parse_path: syntax error, expecting destination.");
		free_arc(ap);
		return 0;
	}
	if (!gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str)) {
		free_arc(ap);
		return 0;
	}
	return 1;
}
static int
parse_list(struct arc *ap, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	int max;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_path: open.\n", (char *)NULL);
	}
	/*
 	 * clear the arc if there is anything there.
	 */
	free_arc(ap);

	if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) return 0;
	max = 32;
	ap->arc = (char **)bu_malloc(sizeof(char *)*max, "arc table");
	ap->arc_last = -1;
	ap->type = ARC_LIST;
	for (;;) {
		if (get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
			parse_error(str,"parse_path: Unexpect EOF.");
			free_arc(ap);
			return 0;
		}
		if (token.type != BU_LEX_IDENT) {
			parse_error(str,"parse_path: syntax error. Missing identifier.");
			free_arc(ap);
			return 0;
		}
		if (++ap->arc_last >= max) {
			max +=32;
			ap->arc = (char **) bu_realloc((char *) ap->arc,
			    sizeof(char *)*max, "arc table");
		}
		ap->arc[ap->arc_last] = token.t_id.value;
		if (get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
			parse_error(str, "parse_path: Unexpect EOF while getting ',' or ';'");
			free_arc(ap);
			return 0;
		}
		if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");
		if (token.type != BU_LEX_SYMBOL) {
			parse_error(str, "parse_path: syntax error.");
			free_arc(ap);
			return 0;
		}
		if (token.t_key.value == SYM_COMMA) {
			continue;
		}else if (token.t_key.value == SYM_END) {
			break;
		} else {
			parse_error(str,"parse_path: syntax error.");
			free_arc(ap);
			return 0;
		}
	}
	return 1;
}
static int
parse_ARC(struct arc *ap, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	int max;
	char *error;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_ARC: open.\n", (char *)NULL);
	}

	free_arc(ap);
	max = 32;
	if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) return 0;

	ap->arc = (char **) bu_malloc(sizeof(char *)*max, "arc table");
	ap->arc_last = -1;

	error = "parse_ARC: Unexpected EOF while getting arc.";
	while (get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) != EOF) {
		if (token.type != BU_LEX_IDENT) {
			error = "parse_ARC: syntax error. Missing identifier.";
			break;
		}
		if (++ap->arc_last >= max) {
			max+=32;
			ap->arc = (char **) bu_realloc((char *)ap->arc,
			    sizeof(char *)*max, "arc table");
		}
		ap->arc[ap->arc_last] = token.t_id.value;
		if (get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
			error = "parse_ARC: Unexpected EOF while getting '/' or ';'.";
			break;
		}
		if (token.type != BU_LEX_SYMBOL) {
			if (token.type == BU_LEX_IDENT) {
				bu_free(token.t_id.value, "unit token");
			}
			error = "parse_ARC: syntax error.  Expected '/' or ';'";
			break;
		}
		if (token.t_key.value == SYM_END) {
			if (joint_debug & DEBUG_J_PARSE) {
			  Tcl_AppendResult(interp, "parse_ARC: close.\n", (char *)NULL);
			}

			return 1;
		}
		if (token.t_key.value != SYM_ARC) {
			error = "parse_ARC: Syntax error.  Expecting ';' or '/'";
			break;
		}
		error = "parse_ARC: Unexpected EOF while getting arc.";
	}
	parse_error(str, error);
	free_arc(ap);
	return 0;
}
static int
parse_double(double *dbl, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	double sign;
	sign = 1.0;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_double: open\n", (char *)NULL);
	}

	if (get_token(&token, fip, str, keys, syms) == EOF) {
		parse_error(str, "parse_double: Unexpect EOF while getting number.");
		return 0;
	}
	if (token.type == BU_LEX_SYMBOL && token.t_key.value == SYM_MINUS) {
		sign = -1;
		if (get_token(&token, fip, str, keys, syms) == EOF) {
			parse_error(str,"parse_double: Unexpect EOF while getting number.");
			return 0;
		}
	}
	if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");

	if (token.type == BU_LEX_INT) {
		*dbl = token.t_int.value * sign;
	} else if (token.type == BU_LEX_DOUBLE) {
		*dbl = token.t_dbl.value * sign;
	} else if (token.type == BU_LEX_KEYWORD && token.t_key.value == KEY_INF) {
		*dbl = MAX_FASTF * sign;
	} else {
		parse_error(str,"parse_double: syntax error.  Expecting number.");
		return 0;
	}

	return 1;
}
static int
parse_assign(double *dbl, FILE *fip, struct bu_vls *str)
{
	if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
		skip_group(fip, str);
		return 0;
	}
	if (!parse_double(dbl, fip, str)) {
		skip_group(fip, str);
		return 0;
	}
	if (!gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str)) {
		skip_group(fip, str);
		return 0;
	}
	return 1;
}
static int
parse_vect(fastf_t *vect, FILE *fip, struct bu_vls *str)
{
	int i;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_vect: open.\n", (char *)NULL);
	}

	if (!gobble_token(BU_LEX_SYMBOL, SYM_OP_PT, fip, str)) return 0;
	for (i=0; i < 3; i++) {
		if (!parse_double(&vect[i], fip, str)) return 0;
		if (i < 2) {
			if (!gobble_token(BU_LEX_SYMBOL, SYM_COMMA, fip, str)) return 0;
		} else {
			if (!gobble_token(BU_LEX_SYMBOL, SYM_CL_PT, fip, str)) return 0;
		}
	}
	return 1;
}
static int
parse_trans(struct joint *jp, int index, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	int dirfound=0, upfound = 0, lowfound=0, curfound=0, accfound=0;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_trans: open\n", (char *)NULL);
	}

	if (index >= 3) {
		parse_error(str,"parse_trans: To many translations for this joint.");
		if (!gobble_token(BU_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0 ;
		skip_group(fip,str);
		return 0;
	}
	if (!gobble_token(BU_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0;

	while (get_token(&token, fip, str, keys, syms) != EOF) {
		if (token.type == BU_LEX_IDENT) {
			bu_free(token.t_id.value, "unit token");
		}
		if (token.type == BU_LEX_SYMBOL && 
		    token.t_key.value == SYM_CL_GROUP ) {
		    	if (joint_debug & DEBUG_J_PARSE) {
			  Tcl_AppendResult(interp, "parse_trans: closing.\n", (char *)NULL);
		    	}

		    	if (!dirfound) {
		    		parse_error(str,"parse_trans: Direction vector not given.");
		    		return 0;
		    	}
		    	VUNITIZE(jp->dirs[index].unitvec);
		    	if (!lowfound) {
		    		parse_error(str,"parse_trans: lower bound not given.");
		    		return 0;
		    	}
		    	if (!upfound) {
		    		parse_error(str,"parse_trans: upper bound not given.");
		    		return 0;
		    	}
		    	if (jp->dirs[index].lower > jp->dirs[index].upper) {
		    		double tmp;
		    		tmp = jp->dirs[index].lower;
		    		jp->dirs[index].lower = jp->dirs[index].upper;
		    		jp->dirs[index].upper = tmp;
		    		parse_error(str,"parse_trans: lower > upper, exchanging.");
		    	}
		    	if (!accfound) jp->dirs[index].accepted = 0.0;
		    	if (!curfound) jp->dirs[index].current = 0.0;
			jp->dirs[index].lower *= base2mm;
		    	jp->dirs[index].upper *= base2mm;
		    	jp->dirs[index].current *= base2mm;
		    	jp->dirs[index].accepted *= base2mm;

		    	if (jp->dirs[index].accepted < jp->dirs[index].lower) {
		    		jp->dirs[index].accepted = jp->dirs[index].lower;
		    	}
		    	if (jp->dirs[index].accepted > jp->dirs[index].upper) {
		    		jp->dirs[index].accepted = jp->dirs[index].upper;
		    	}
		    	if (jp->dirs[index].current < jp->dirs[index].lower) {
		    		jp->dirs[index].current = jp->dirs[index].lower;
		    	}
		    	if (jp->dirs[index].current > jp->dirs[index].upper) {
		    		jp->dirs[index].current = jp->dirs[index].upper;
		    	}
		    	return 1;
		}

		if (token.type != BU_LEX_KEYWORD) {
			parse_error(str,"parse_trans: Syntax error.");
			skip_group(fip,str);
			return 0;
		}
		switch (token.t_key.value) {
		case KEY_LIMIT:
			if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!parse_double(&jp->dirs[index].lower, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			lowfound = 1;
			if (!gobble_token(BU_LEX_SYMBOL, SYM_COMMA, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!parse_double(&jp->dirs[index].upper, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			upfound = 1;
			if (!gobble_token(BU_LEX_SYMBOL, SYM_COMMA, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!parse_double(&jp->dirs[index].current, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			curfound = 1;
			(void) gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str);
			break;
		case KEY_UP:
			if (!parse_assign(&jp->dirs[index].upper, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			upfound = 1;
			break;
		case KEY_LOW:
			if (!parse_assign(&jp->dirs[index].lower, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			lowfound = 1;
			break;
		case KEY_CUR:
			if (!parse_assign(&jp->dirs[index].current, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			curfound = 1;
			break;
		case KEY_ACC:
			if (!parse_assign(&jp->dirs[index].accepted, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			curfound = 1;
			break;
		case KEY_DIR:
			if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!parse_vect(jp->dirs[index].unitvec, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			dirfound = 1;
			break;
		default:
			parse_error(str,"parse_trans: syntax error.");
			skip_group(fip, str);
			return 0;
		}
	}
	parse_error(str,"parse_trans:Unexpected EOF.");
	return 0;
}
static int
parse_rots(struct joint *jp, int index, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	int dirfound=0, upfound = 0, lowfound=0, curfound=0, accfound=0;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_rots: open\n", (char *)NULL);
	}

	if (index >= 3) {
		parse_error(str,"parse_rot: To many rotations for this joint.");
		if (!gobble_token(BU_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0 ;
		skip_group(fip,str);
		return 0;
	}
	if (!gobble_token(BU_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0;

	while (get_token(&token, fip, str, keys, syms) != EOF) {
		if (token.type == BU_LEX_IDENT) {
			bu_free(token.t_id.value, "unit token");
		}
		if (token.type == BU_LEX_SYMBOL && 
		    token.t_key.value == SYM_CL_GROUP ) {
		    	if (joint_debug & DEBUG_J_PARSE) {
			  Tcl_AppendResult(interp, "parse_rots: closing.\n", (char *)NULL);
		    	}

		    	if (!dirfound) {
		    		parse_error(str,"parse_rots: Direction vector not given.");
		    		return 0;
		    	}
		    	VUNITIZE(jp->rots[index].quat);
		    	jp->rots[index].quat[W] = 0.0;
		    	if (!lowfound) {
		    		parse_error(str,"parse_rots: lower bound not given.");
		    		return 0;
		    	}
		    	if (!upfound) {
		    		parse_error(str,"parse_rots: upper bound not given.");
		    		return 0;
		    	}
		    	if (jp->rots[index].lower > jp->rots[index].upper) {
		    		double tmp;
		    		tmp = jp->rots[index].lower;
		    		jp->rots[index].lower = jp->rots[index].upper;
		    		jp->rots[index].upper = tmp;
		    		parse_error(str,"parse_rots: lower > upper, exchanging.");
		    	}
		    	if (!accfound) {
		    		jp->rots[index].accepted = 0.0;
		    	}
		    	if (jp->rots[index].accepted < jp->rots[index].lower) {
		    		jp->rots[index].accepted = jp->rots[index].lower;
		    	}
		    	if (jp->rots[index].accepted > jp->rots[index].upper) {
		    		jp->rots[index].accepted = jp->rots[index].upper;
		    	}
		    	if (!curfound) {
		    		jp->rots[index].current = 0.0;
		    	}
		    	if (jp->rots[index].current < jp->rots[index].lower) {
		    		jp->rots[index].current = jp->rots[index].lower;
		    	}
		    	if (jp->rots[index].current > jp->rots[index].upper) {
		    		jp->rots[index].current = jp->rots[index].upper;
		    	}
		    	return 1;
		}

		if (token.type != BU_LEX_KEYWORD) {
			parse_error(str,"parse_rots: Syntax error.");
			skip_group(fip,str);
			return 0;
		}
		switch (token.t_key.value) {
		case KEY_LIMIT:
			if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!parse_double(&jp->rots[index].lower, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			lowfound = 1;
			if (!gobble_token(BU_LEX_SYMBOL, SYM_COMMA, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!parse_double(&jp->rots[index].upper, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			upfound = 1;
			if (!gobble_token(BU_LEX_SYMBOL, SYM_COMMA, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!parse_double(&jp->rots[index].current, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			curfound = 1;
			(void) gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str);
			break;
		case KEY_UP:
			if (!parse_assign(&jp->rots[index].upper, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			upfound = 1;
			break;
		case KEY_LOW:
			if (!parse_assign(&jp->rots[index].lower, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			lowfound = 1;
			break;
		case KEY_CUR:
			if (!parse_assign(&jp->rots[index].current, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			curfound = 1;
			break;
		case KEY_ACC:
			if (!parse_assign(&jp->rots[index].accepted, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			curfound = 1;
			break;
		case KEY_DIR:
			if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!parse_vect(jp->rots[index].quat, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			if (!gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			dirfound = 1;
			break;
		default:
			parse_error(str,"parse_rots: syntax error.");
			skip_group(fip, str);
			return 0;
		}
	}
	parse_error(str,"parse_rots:Unexpected EOF.");
	return 0;
}
static int
parse_joint(FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	struct joint *jp;
	int trans;
	int rots;
	int arcfound, locfound;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_joint: reading joint.\n", (char *)NULL);
	}

	BU_GETSTRUCT(jp, joint);
	jp->l.magic = MAGIC_JOINT_STRUCT;
	jp->anim = (struct animate *) 0;
	jp->path.type = ARC_UNSET;
	jp->name = NULL;

	if (get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
		parse_error(str,"parse_joint: Unexpected EOF getting name.");
		free_joint(jp);
		return 0;
	}
	jp->name = token.t_id.value;	/* Name */
	if (!gobble_token(BU_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) {
		free_joint(jp);
		return 0;
	}
	/*
	 * With in the group, we need at least one rotate or translate,
	 * a location and an arc or path.
	 */
	arcfound = 0;
	locfound = 0;
	rots = trans = 0;
	for(;;) {
		if (get_token(&token, fip, str, keys, syms) == EOF) {
			parse_error(str,"parse_joint: Unexpected EOF getting joint contents.");
			skip_group(fip, str);
			free_joint(jp);
			return 0;
		}
		if (token.type == BU_LEX_SYMBOL &&
		    token.t_key.value == SYM_CL_GROUP) {
		    	if (joint_debug & DEBUG_J_PARSE) {
			  Tcl_AppendResult(interp, "parse_joint: closing.\n", (char *)NULL);
		    	}
		    	if (!arcfound) {
		    		parse_error(str,"parse_joint: Arc not defined.");
		    		free_joint(jp);
		    		return 0;
		    	}
		    	if (!locfound) {
		    		parse_error(str,"parse_joint: location not defined.");
		    		free_joint(jp);
		    		return 0;
		    	}
		    	if (trans + rots == 0) {
		    		parse_error(str,"parse_joint: no translations or rotations defined.");
		    		free_joint(jp);
		    		return 0;
		    	}
		    	for(;trans<3;trans++) {
		    		jp->dirs[trans].lower = -1.0;
		    		jp->dirs[trans].upper = -2.0;
		    		jp->dirs[trans].current = 0.0;
		    	}
		    	for(;rots<3;rots++) {
		    		jp->rots[rots].lower = -1.0;
		    		jp->rots[rots].upper = -2.0;
		    		jp->rots[rots].current = 0.0;
		    	}
		    	jp->location[X] *= base2mm;
		    	jp->location[Y] *= base2mm;
		    	jp->location[Z] *= base2mm;

		    	BU_LIST_INSERT(&joint_head, &(jp->l));
		    	gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str);
		    	return 1;
		}
		if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");

		if (token.type != BU_LEX_KEYWORD) {
			parse_error(str,"parse_joint: syntax error.");
			skip_group(fip, str);
			free_joint(jp);
			return 0;
		}
		switch (token.t_key.value) {
		case KEY_ARC: 
			if (arcfound) {
				parse_error(str,"parse_joint: more than one arc or path given");
			}
			if (!parse_ARC(&jp->path, fip, str)) {
				skip_group(fip,str);
				free_joint(jp);
				return 0;
			}
			arcfound = 1;
			break;
		case KEY_PATH:
			if (arcfound) {
				parse_error(str,"parse_joint: more than one arc or path given.");
			}
			if (!parse_path(&jp->path, fip, str)) {
				skip_group(fip,str);
				free_joint(jp);
				return 0;
			}
			arcfound = 1;
			break;
		case KEY_LOC: 
			if (locfound) {
				parse_error(str,"parse_joint: more than one location given.");
			}
			if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
				skip_group(fip,str);
				free_joint(jp);
				return 0;
			}
			if (!parse_vect(&jp->location[0], fip, str)) {
				skip_group(fip,str);
				free_joint(jp);
				return 0;
			}
			if (!gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str)) {
				skip_group(fip,str);
				free_joint(jp);
				return 0;
			}
			locfound=1;
			break;
		case KEY_TRANS:
			if (!parse_trans(jp, trans, fip, str)) {
				skip_group(fip,str);
				free_joint(jp);
				return 0;
			}
			trans++;
			break;
		case KEY_ROT:
			if (!parse_rots(jp, rots, fip, str)) {
				skip_group(fip, str);
				free_joint(jp);
				return 0;
			}
			rots++;
			break;
		default:
			parse_error(str,"parse_joint: syntax error.");
			skip_group(fip, str);
			free_joint(jp);
			return 0;
		}
	}
	/* NOTREACHED */
}
static int
parse_jset(struct hold *hp, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	int jointfound=0, listfound=0, arcfound=0, pathfound=0;

	if(joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_jset: open\n", (char *)NULL);
	}

	if (!gobble_token(BU_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0;

	for (;;) {
		if (get_token(&token, fip, str, keys, syms) == EOF) {
			parse_error(str, "parse_jset: Unexpect EOF getting contents of joint set");
			return 0;
		}
		if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");
		if (token.type == BU_LEX_SYMBOL && token.t_key.value == SYM_CL_GROUP) {
			if (!jointfound) hp->j_set.joint = 0;
			if (!listfound && !arcfound && !pathfound) {
				parse_error(str, "parse_jset: no list/arc/path given.");
				return 0;
			}
			if(joint_debug & DEBUG_J_PARSE) {
			  Tcl_AppendResult(interp, "parse_jset: close\n", (char *)NULL);
			}
 			return 1;
		}
		if (token.type != BU_LEX_KEYWORD) {
			parse_error(str, "parse_jset: syntax error.");
			return 0;
		}
		switch (token.t_key.value) {
		case KEY_START:
			if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			if (get_token(&token, fip, str, keys, syms) == EOF) {
				parse_error(str,"parse_jset: Unexpect EOF getting '='");
				return 0;
			}
			if (token.type != BU_LEX_IDENT) {
				parse_error(str,"parse_jset: syntax error, expecting joint name.");
				skip_group(fip,str);
				return 0;
			}
			hp->j_set.joint = token.t_id.value;
			if (!gobble_token(BU_LEX_SYMBOL, SYM_END, fip,str)) {
				skip_group(fip,str);
				return 0;
			}
			jointfound = 1;
			break;
		case KEY_ARC:
			if (!parse_ARC(&hp->j_set.path, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			arcfound = 1;
			break;
		case KEY_PATH:
			if (!parse_path(&hp->j_set.path, fip, str)) {
				skip_group(fip, str);
				return 0;
			}
			pathfound = 1;
			break;
		case KEY_JOINTS:
			if (!parse_list(&hp->j_set.path, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			listfound=1;
			break;
		case KEY_EXCEPT:
			if (!parse_list(&hp->j_set.exclude, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			break;
		default:
			parse_error(str,"parse_jset: syntax error.");
			skip_group(fip,str);
			return 0;
		}
	}
}
static int
parse_solid(struct hold_point *pp, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;
	int vertexfound = 0, arcfound = 0;
	double vertex;

	if(joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_solid: open\n", (char *)NULL);
	}

	if (!gobble_token(BU_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0;

	for (;;) {
		if (get_token(&token, fip, str, keys, syms) == EOF) {
			parse_error(str, "parse_solid: Unexpect EOF.");
			return 0;
		}
		if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");
		if (token.type == BU_LEX_SYMBOL && token.t_key.value == SYM_CL_GROUP) {
			if (!arcfound) {
				parse_error(str,"parse_solid: path/arc missing.");
				return 0;
			}
			if (!vertexfound) pp->vertex_number = 1;
			if(joint_debug & DEBUG_J_PARSE) {
			  Tcl_AppendResult(interp, "parse_solid: close\n", (char *)NULL);
			}

			return 1;
		}
		if (token.type != BU_LEX_KEYWORD) {
			parse_error(str, "parse_solid: syntax error getting solid information.");
			skip_group(fip,str);
			return 0;
		}
		switch (token.t_key.value) {
		case KEY_VERTEX:
			if (!parse_assign(&vertex, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			pp->vertex_number = vertex;	/* double to int */
			vertexfound = 1;
			break;
		case KEY_PATH:
			if (!parse_path(&pp->arc, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			arcfound = 1;
			break;
		case KEY_ARC:
			if (!parse_ARC(&pp->arc, fip, str)) {
				skip_group(fip,str);
				return 0;
			}
			arcfound =1 ;
			break;
		default:
			parse_error(str, "parse_solid: syntax error.");
		}
	}
}
static int
parse_point(struct hold_point *pp, FILE *fip, struct bu_vls *str)
{
	union bu_lex_token token;

	if (get_token(&token, fip, str, lex_solids, syms) == EOF) {
		parse_error(str, "parse_point: Unexpect EOF getting solid type.");
		return 0;
	}
	if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");
	if (token.type != BU_LEX_KEYWORD) {
		parse_error(str,"parse_point: syntax error getting solid type.");
		return 0;
	}
	switch (token.t_key.value) {
	case ID_FIXED:
		pp->type = ID_FIXED;
		if (!parse_vect(&pp->point[0], fip, str)) return 0;
		return gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str);
	case ID_SPH:
		pp->type = ID_SPH;
		break;
	case ID_GRIP:
		pp->type = ID_GRIP;
		break;
	case ID_JOINT:
		pp->type = ID_JOINT;
		break;
	default:
		parse_error(str, "parse_point: Syntax error-XXX.");
		skip_group(fip,str);
		return 0;
	}
	if (!parse_solid(pp, fip, str)) {
		skip_group(fip, str);
		return 0;
	}
	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_point: close.\n", (char *)NULL);
	}
	return 1;
}
static int
parse_hold(FILE *fip, struct bu_vls *str)
{
	struct hold *hp;
	union bu_lex_token token;
	int jsetfound = 0, efffound=0, goalfound=0, weightfound=0, prifound=0;

	if (joint_debug & DEBUG_J_PARSE) {
	  Tcl_AppendResult(interp, "parse_hold: reading constraint\n", (char *)NULL);
	}
	BU_GETSTRUCT(hp, hold);
	hp->l.magic = MAGIC_HOLD_STRUCT;
	hp->name = NULL;
	hp->joint = NULL;
	BU_LIST_INIT(&hp->j_head);
	hp->effector.type = ID_FIXED;
	hp->effector.arc.type = ARC_UNSET;
	db_init_full_path(&hp->effector.path);
	hp->effector.flag = 0;
	hp->objective.type = ID_FIXED;
	hp->objective.arc.type = ARC_UNSET;
	db_init_full_path(&hp->objective.path);
	hp->objective.flag = 0;
	hp->j_set.joint = NULL;
	hp->j_set.path.type = ARC_UNSET;
	hp->j_set.exclude.type = ARC_UNSET;

	if ( get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
		parse_error(str, "parse_hold: Unexpected EOF getting name.");
		free_hold(hp);
		return 0;
	}
	if (token.type == BU_LEX_IDENT) {
		hp->name = token.t_id.value;
		if ( get_token(&token, fip, str, (struct bu_lex_key *)NULL, syms) == EOF) {
			parse_error(str, "parse_hold: Unexpected EOF getting open group.");
			free_hold(hp);
			return 0;
		}
	}
	if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");
	if (token.type != BU_LEX_SYMBOL || token.t_key.value != SYM_OP_GROUP) {
		parse_error(str, "parse_hold: syntax error, expecting open group.");
		free_hold(hp);
		return 0;
	}
	
	for (;;) {
		if (get_token(&token, fip, str, keys, syms) == EOF) {
			parse_error(str, "parse_hold: Unexpected EOF getting constraint contents.");
			skip_group( fip, str);
			free_hold(hp);
		}
		if (token.type == BU_LEX_IDENT) bu_free(token.t_id.value, "unit token");

		if (token.type == BU_LEX_SYMBOL && token.t_key.value == SYM_CL_GROUP) {
			if (joint_debug & DEBUG_J_PARSE) {
			  Tcl_AppendResult(interp, "parse_hold: closing.\n", (char *)NULL);
			}

			if (!jsetfound) {
				parse_error(str,"parse_hold: no joint set given.");
				free_hold(hp);
				skip_group(fip, str);
				return 0;
			}
			if (!efffound) {
				parse_error(str, "parse_hold: no effector given.");
				free_hold(hp);
				skip_group(fip,str);
				return 0;
			}
			if (!goalfound) {
				parse_error(str, "parse_hold: no goal given.");
				free_hold(hp);
				skip_group(fip, str);
				return 0;
			}
			if (!weightfound) {
				hp->weight = 1.0;
			}
			if (!prifound) {
				hp->priority = 50;
			}
			BU_LIST_INSERT(&hold_head, &(hp->l));

			gobble_token(BU_LEX_SYMBOL, SYM_END, fip, str);
			return 1;
		}
		if (token.type != BU_LEX_KEYWORD) {
			parse_error(str, "parse_hold: syntax error");
			skip_group(fip, str);
			free_hold(hp);
			return 0;
		}

		switch (token.t_key.value) {
/* effector, goal */
		case KEY_WEIGHT:
			if (!parse_assign(&hp->weight, fip, str)) {
				free_hold(hp);
				skip_group(fip, str);
				return 0;
			}
			weightfound = 1;
			break;
		case KEY_PRI:
			if (!parse_assign((double *)&hp->priority, fip, str)) {
				free_hold(hp);
				skip_group(fip,str);
				return 0;
			}
			prifound=1;
			break;
		case KEY_JOINTS:
			if (jsetfound) {
				parse_error(str,"parse_hold: joint set redefined.");
				free_hold(hp);
				skip_group(fip,str);
				return 0;
			}
			if (!parse_jset(hp, fip, str)) {
				free_hold(hp);
				skip_group(fip,str);
				return 0;
			}
			jsetfound = 1;
			break;
		case KEY_EFF:
			if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
				skip_group(fip,str);
				free_hold(hp);
				return 0;
			}
			if (!parse_point(&hp->effector, fip, str)) {
				skip_group(fip, str);
				free_hold(hp);
				return 0;
			}
			efffound = 1;
			break;
		case KEY_POINT:
			if (!gobble_token(BU_LEX_SYMBOL, SYM_EQ, fip, str)) {
				skip_group(fip,str);
				free_hold(hp);
				return 0;
			}
			if (!parse_point(&hp->objective, fip, str)) {
				skip_group(fip, str);
				free_hold(hp);
				return 0;
			}
			goalfound=1;
			break;
		default:
			parse_error(str,"parse_hold: syntax error.");
			break;
		}
	}
	/* NOTREACHED */
}
static struct bu_list path_head;
int
f_jload(int argc, char **argv)
{
	FILE *fip;
	struct bu_vls	*instring;
	union bu_lex_token token;
	int	no_unload = 0, no_apply=0, no_mesh=0;
	int	c;
	struct	joint *jp;
	struct	hold *hp;

	CHECK_DBI_NULL;

	bu_optind = 1;
	while ((c=bu_getopt(argc,argv,"uam")) != EOF ) {
		switch (c) {
		case 'u': no_unload = 1;break;
		case 'a': no_apply = 1; break;
		case 'm': no_mesh = 1; break;
		default:
		  Tcl_AppendResult(interp, "Usage: joint load [-uam] file_name [files]\n", (char *)NULL);
		  break;
		}
	}
	argv += bu_optind;
	argc -= bu_optind;
	if (!no_unload) f_junload(0, (char **)0);

	base2mm = dbip->dbi_base2local;
	mm2base = dbip->dbi_local2base;

	BU_GETSTRUCT(instring,bu_vls);
	bu_vls_init(instring);

	while (argc) {
		fip = fopen(*argv, "r");
		if (fip == NULL) {
		  Tcl_AppendResult(interp, "joint load: unable to open '", *argv,
				   "'.\n", (char *)NULL);
		  ++argv;
		  --argc;
		  continue;
		}
		if (joint_debug & DEBUG_J_LOAD) {
		  Tcl_AppendResult(interp, "joint load: loading from '", *argv,
				   "'.\n", (char *)NULL);
		}
		lex_line = 0;
		lex_name = *argv;

		while (get_token(&token, fip, instring, keys, syms) != EOF ) {
			if (token.type == BU_LEX_KEYWORD) {
				if (token.t_key.value == KEY_JOINT ) {
					if (parse_joint(fip,instring)) {
						jp = BU_LIST_LAST(joint, &joint_head);
						if (!no_apply) joint_move(jp);
					}
				} else if (token.t_key.value == KEY_CON) {
					(void)parse_hold( fip, instring);
				} else if (token.t_key.value == KEY_UNITS) {
					(void)parse_units(fip, instring);
				} else {
					parse_error(instring,"joint load: syntax error.");
				}
			} else {
				parse_error(instring,"joint load: syntax error.");
			}
			if (token.type == BU_LEX_IDENT) {
				bu_free(token.t_id.value, "unit token");
			}
		}
		fclose(fip);
		argc--;
		argv++;
	}
/* CTJ */
	/*
	 * For each "struct arc" in joints or constraints, build a linked
	 * list of all ARC_PATHs and a control list of all unique tops.
	 */
	BU_LIST_INIT(&path_head);
	for (BU_LIST_FOR(jp, joint, &joint_head)) {
		if (jp->path.type == ARC_PATH) {
			BU_LIST_INSERT(&path_head, &(jp->path.l));
		}
	}
	for (BU_LIST_FOR(hp, hold, &hold_head)) {
		if (hp->j_set.path.type == ARC_PATH) {
			BU_LIST_INSERT(&path_head, &(hp->j_set.path.l));
		}
		if (hp->effector.arc.type == ARC_PATH) {
			BU_LIST_INSERT(&path_head, &(hp->effector.arc.l));
		}
		if (hp->objective.arc.type == ARC_PATH) {
			BU_LIST_INSERT(&path_head, &(hp->objective.arc.l));
		}
	}
	/*
	 * call the tree walker to search for these paths.
	 */
	/*
	 * All ARC_PATHS have been translated into ARC_ARC.
	 *
	 * Constraints need to have ARC_ARCs translated to ARC_LISTS, this
	 * can be done at a latter time, such as when the constraint is
	 * evaluated. ??? XXX
	 */
	for (BU_LIST_FOR(hp, hold, &hold_head)) {
		register struct directory *dp;
		register int i;

		if (hp->effector.arc.type == ARC_ARC) {
			db_init_full_path(&hp->effector.path);
			hp->effector.path.fp_len = hp->effector.arc.arc_last+1;
			hp->effector.path.fp_maxlen = hp->effector.arc.arc_last+1;
			hp->effector.path.fp_names = (struct directory **)
			    bu_malloc(sizeof(struct directory **) * hp->effector.path.fp_maxlen,
			    "full path");
			for (i=0; i<= hp->effector.arc.arc_last; i++) {
				dp = hp->effector.path.fp_names[i] = 
				    db_lookup(dbip, hp->effector.arc.arc[i], 
				    LOOKUP_NOISY);
				if (!dp) {
					hp->effector.path.fp_len = i;
					db_free_full_path(&hp->effector.path);
					break;
				}
			}
		}
		if (hp->objective.arc.type == ARC_ARC) {
			db_init_full_path(&hp->objective.path);
			hp->objective.path.fp_len = hp->objective.arc.arc_last+1;
			hp->objective.path.fp_maxlen = hp->objective.arc.arc_last+1;
			hp->objective.path.fp_names = (struct directory **)
			    bu_malloc(sizeof(struct directory **) * hp->objective.path.fp_maxlen,
			    "full path");
			for (i=0; i<= hp->objective.arc.arc_last; i++) {
				dp = hp->objective.path.fp_names[i] = 
				    db_lookup(dbip, hp->objective.arc.arc[i], 
				    LOOKUP_NOISY);
				if (!dp) {
					hp->objective.path.fp_len = i;
					db_free_full_path(&hp->objective.path);
					break;
				}
			}
		}
	}
	if (!no_mesh) (void) f_jmesh(0,0);
	return CMD_OK;
}
int
f_jtest(int argc, char **argv)
{
	return CMD_OK;
}
int
f_jsave(int argc, char **argv)
{
	register struct joint *jp;
	register int i;
	FILE *fop;

	CHECK_DBI_NULL;

	--argc;
	++argv;

	if (argc <1) {
	  Tcl_AppendResult(interp, "joint save: missing file name", (char *)NULL);
	  return CMD_BAD;
	}
	fop = fopen(*argv,"w");
	if (!fop) {
	  Tcl_AppendResult(interp, "joint save: unable to open '", *argv,
			   "' for writing.\n", (char *)NULL);
	  return CMD_BAD;
	}
	fprintf(fop,"# joints and constraints for '%s'\n",
	    dbip->dbi_title);

	/* Output the current editing units */
	fprintf(fop, "units %gmm;\n", dbip->dbi_local2base);

	mm2base = dbip->dbi_local2base;
	base2mm = dbip->dbi_base2local;

	for (BU_LIST_FOR(jp, joint, &joint_head)) {
		fprintf(fop,"joint %s {\n",jp->name);
		/* } for jove */
		if (jp->path.type == ARC_PATH) {
			fprintf(fop,"\tpath = %s",jp->path.arc[0]);
			for(i=1;i<jp->path.arc_last;i++) {
				fprintf(fop,"/%s",jp->path.arc[i]);
			}
			fprintf(fop,"-%s;\n",jp->path.arc[i]);
		} else if (jp->path.type & ARC_BOTH) {
			fprintf(fop,"\tpath = %s", jp->path.original[0]);
			for (i=1; i < jp->path.org_last; i++) {
				fprintf(fop,"/%s",jp->path.original[i]);
			}
			fprintf(fop,"-%s;\n",jp->path.original[i]);
		} else { /* ARC_ARC */
			fprintf(fop,"\tarc = %s", jp->path.arc[0]);
			for(i=1;i<jp->path.arc_last;i++) {
				fprintf(fop,"/%s", jp->path.arc[i]);
			}
			fprintf(fop,"/%s;\n", jp->path.arc[i]);
		}
		fprintf(fop,"\tlocation = (%.15e, %.15e, %.15e);\n", 
		    jp->location[X]*mm2base, jp->location[Y]*mm2base,
		    jp->location[Z]*mm2base);

		for (i=0;i<3;i++) {
			if (jp->rots[i].upper < jp->rots[i].lower) break;
			fprintf(fop,
"\trotate {\n\t\tdirection = (%.15e, %.15e, %.15e);\n\t\tlimits = %.15e, %.15e, %.15e;\n\t}\n",
			    jp->rots[i].quat[X], jp->rots[i].quat[Y],
			    jp->rots[i].quat[Z], 
			    jp->rots[i].lower, jp->rots[i].upper,
			    jp->rots[i].current);
		}
		for (i=0;i<3;i++) {
			if (jp->dirs[i].upper < jp->dirs[i].lower) break;
			fprintf(fop,
"\ttranslate {\n\t\tdirection = (%.15e, %.15e, %.15e);\n\t\tlimits = %.15e, %.15e, %.15e;\n\t}\n",
			    jp->dirs[i].unitvec[X], jp->dirs[i].unitvec[Y],
			    jp->dirs[i].unitvec[Z], jp->dirs[i].lower*mm2base,
			    jp->dirs[i].upper*mm2base, jp->dirs[i].current*mm2base);
		}
		fprintf(fop,"};\n");
	}
	fclose(fop);
	return CMD_OK;
}
int
f_jaccept(int argc, char **argv)
{
	register struct joint *jp;
	register int i;
	int c;
	int no_mesh = 0;

	bu_optind=1;
	while ( (c=bu_getopt(argc,argv, "m")) != EOF) {
		switch (c) {
		case 'm': no_mesh=1;break;
		default:
		  Tcl_AppendResult(interp, "Usage: joint accept [-m] [joint_names]\n", (char *)NULL);
		  break;
		}
	}
	argc -= bu_optind;
	argv += bu_optind;

	for (BU_LIST_FOR(jp, joint, &joint_head)) {
		if (argc) {
			for (i=0; i<argc; i++) {
				if (strcmp(argv[i], jp->name) == 0) break;
			}
			if (i>=argc) continue;
		}
		for(i=0; i<3; i++) {
			jp->dirs[i].accepted = jp->dirs[i].current;
			jp->rots[i].accepted = jp->rots[i].current;
		}
	}
	if (!no_mesh) f_jmesh(0,0);
	return CMD_OK;
}
int
f_jreject(int argc, char **argv)
{
	register struct joint *jp;
	register int i;
	int c;
	int no_mesh = 0;

	bu_optind=1;
	while ( (c=bu_getopt(argc,argv, "m")) != EOF) {
		switch (c) {
		case 'm': no_mesh=1;break;
		default:
		  Tcl_AppendResult(interp, "Usage: joint accept [-m] [joint_names]\n", (char *)NULL);
		  break;
		}
	}
	argc -= bu_optind;
	argv += bu_optind;

	for (BU_LIST_FOR(jp, joint, &joint_head)) {
		if (argc) {
			for (i=0; i<argc; i++) {
				if (strcmp(argv[i], jp->name) == 0) break;
			}
			if (i>=argc) continue;
		}

		for (i=0; i<3; i++) {
			jp->rots[i].current = jp->rots[i].accepted;
			jp->dirs[i].current = jp->dirs[i].accepted;
		}
		joint_move(jp);
	}
	if (!no_mesh) f_jmesh(0,0);
	return CMD_OK;
}
static int
hold_point_location(fastf_t *loc, struct hold_point *hp)
{
	mat_t mat;
	struct joint *jp;
	struct rt_grip_internal *gip;
	struct rt_db_internal	intern;

	if(dbip == DBI_NULL)
	  return 1;

	VSETALL(loc, 0.0);	/* default is the origin. */
	switch (hp->type) {
	case ID_FIXED:
		VMOVE(loc, hp->point);
		return 1;
	case ID_GRIP:
		if (hp->flag & HOLD_PT_GOOD) {
			db_path_to_mat(dbip, &hp->path, mat, hp->path.fp_len-2, &rt_uniresource);
			MAT4X3PNT(loc, mat, hp->point);
			return 1;
		}

		if( rt_db_get_internal( &intern, hp->path.fp_names[hp->path.fp_len-1], dbip, NULL, &rt_uniresource ) < 0 )
			return 0;

		RT_CK_DB_INTERNAL(&intern);
		if( intern.idb_type != ID_GRIP )  return 0;
		gip = (struct rt_grip_internal *)intern.idb_ptr;
		VMOVE(hp->point, gip->center);
		hp->flag |= HOLD_PT_GOOD;
		rt_db_free_internal( &intern, &rt_uniresource );

		db_path_to_mat(dbip, &hp->path, mat, hp->path.fp_len-2, &rt_uniresource);
		MAT4X3PNT(loc, mat, hp->point);
		return 1;
	case ID_JOINT:
		db_path_to_mat(dbip, &hp->path, mat, hp->path.fp_len-3, &rt_uniresource);
		if (hp->flag & HOLD_PT_GOOD) {
			MAT4X3VEC(loc, mat, hp->point);
			return 1;
		}
		jp = joint_lookup(hp->arc.arc[hp->arc.arc_last]);
		if (!jp) {
		  Tcl_AppendResult(interp, "hold_eval: Lost joint!  ",
				   hp->arc.arc[hp->arc.arc_last],
				   " not found!\n", (char *)NULL);
		  /* bu_bomb(); */
		  return 0;
		}
		VMOVE(hp->point, jp->location);
		hp->flag |= HOLD_PT_GOOD;
		MAT4X3VEC(loc, mat, hp->point);
		return 1;
	}
	/* NEVER REACHED */
	return 1;	/* For the picky compilers */
}
double
hold_eval(struct hold *hp)
{
	vect_t	e_loc, o_loc;
	double	value;

	/* 
	 * get the current location of the effector.
	 */
	if (!hold_point_location(e_loc, &hp->effector)) {
		if (joint_debug & DEBUG_J_EVAL) {
		  Tcl_AppendResult(interp, "hold_eval: unable to find location of effector for ",
				   hp->name, ".\n", (char *)NULL);
		}
		return 0.0;
	}
	if (!hold_point_location(o_loc, &hp->objective)) {
		if (joint_debug & DEBUG_J_EVAL) {
		  Tcl_AppendResult(interp, "hold_eval: unable to find location of objective for ",
				   hp->name, ".\n", (char *)NULL);
		}
		return 0.0;
	}
	value = hp->weight * DIST_PT_PT(e_loc, o_loc);
	if (joint_debug & DEBUG_J_EVAL) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "hold_eval: PT->PT of %s is %g\n", hp->name, value);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	return value;
}
struct solve_stack {
	struct bu_list	l;
	struct joint	*jp;
	int		freedom;
	double		old;
	double		new;
};
#define	SOLVE_STACK_MAGIC	0x76766767
struct bu_list solve_head = {
	BU_LIST_HEAD_MAGIC,
	&solve_head,
	&solve_head
};

void
joint_clear(void)
{
	register struct stack_solve *ssp;
	BU_LIST_POP(stack_solve, &solve_head, ssp);
	while (ssp) {
		bu_free((genptr_t)ssp, "struct stack_solve");
		BU_LIST_POP(stack_solve, &solve_head, ssp);
	}
}

int
part_solve(struct hold *hp, double limits, double tol)
{
	register struct joint *jp;
	double f0,f1,f2;
	double ax,bx,cx;
	double x0,x1,x2,x3;
	double besteval, bestvalue = 0, origvalue;
	int bestfreedom = -1;
	register struct joint *bestjoint;
	register struct jointH *jh;

	if (joint_debug & DEBUG_J_SOLVE) {
	  Tcl_AppendResult(interp, "part_solve: solving for ", hp->name,
			   ".\n", (char *)NULL);
	}

	if (BU_LIST_IS_EMPTY(&hp->j_head)) {
		register int i,j;
		int startjoint;
		startjoint = -1;
		if (joint_debug & DEBUG_J_SOLVE) {
		  Tcl_AppendResult(interp, "part_solve: looking for joints on arc.\n",
				   (char *)NULL);
		}
		for(BU_LIST_FOR(jp,joint,&joint_head)) {
			if (hp->j_set.path.type == ARC_LIST) {
				for (i=0; i<= hp->j_set.path.arc_last; i++) {
					if (strcmp(jp->name, hp->j_set.path.arc[i]) == 0) {
						BU_GETSTRUCT(jh, jointH);
						jh->l.magic = MAGIC_JOINT_HANDLE;
						jh->p = jp;
						jp->uses++;
						jh->arc_loc = -1;
						jh->flag = 0;
						BU_LIST_APPEND(&hp->j_head, &jh->l);
						break;
					}
				}
				continue;
			}
			for (i=0;i<hp->effector.path.fp_len; i++) {
				if (strcmp(jp->path.arc[0],
				    hp->effector.path.fp_names[i]->d_namep)==0) break;
			}
			if (i+jp->path.arc_last >= hp->effector.path.fp_len) continue;
			for (j=1; j<=jp->path.arc_last;j++){
				if (strcmp(jp->path.arc[j],
				    hp->effector.path.fp_names[i+j]->d_namep)
				    != 0) break;
			}
			if (j>jp->path.arc_last) {
				if (joint_debug & DEBUG_J_SOLVE) {
				  Tcl_AppendResult(interp, "part_solve: found ",
						   jp->name, "\n", (char *)NULL);
				}
				BU_GETSTRUCT(jh, jointH);
				jh->l.magic = MAGIC_JOINT_HANDLE;
				jh->p = jp;
				jp->uses++;
				jh->arc_loc = i+j-1;
				jh->flag = 0;
				BU_LIST_APPEND(&hp->j_head, &jh->l);
				if (strcmp(hp->joint, jp->name) == 0) {
					startjoint = jh->arc_loc;
				}
			}
		}
		if (startjoint < 0) {
		  Tcl_AppendResult(interp, "part_solve: ", hp->name,
				   ", joint ", hp->joint, " not on arc.\n", (char *)NULL);
		}
		for (BU_LIST_FOR(jh, jointH, &hp->j_head)) {
			/*
			 * XXX - Coming to a source module near you  RSN.
			 * Not only joint location, but drop joints that
			 * are "locked"
			 */
			if (jh->arc_loc < startjoint) {
				register struct jointH *hold;
				if (joint_debug & DEBUG_J_SOLVE) {
				  Tcl_AppendResult(interp, "part_solve: dequeuing ", jh->p->name,
						   " from ", hp->name, "\n", (char *)NULL);
				}
				hold=(struct jointH *)jh->l.back;
				BU_LIST_DEQUEUE(&jh->l);
				jh->p->uses--;
				jh=hold;
			}
		}
	}
	origvalue = besteval = hold_eval(hp);
	if (fabs(origvalue) < tol) {
		if (joint_debug & DEBUG_J_SOLVE) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "part_solve: solved, original(%g) < tol(%g)\n",
				origvalue, tol);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
		return 0;
	}
	bestjoint = (struct joint *)0;
	/*
	 * From here, we try each joint to try and find the best movement
	 * if any.
	 */
	for (BU_LIST_FOR(jh, jointH, &hp->j_head)) {
		register int i;
		double hold;
		jp= jh->p;
		for (i=0;i<3;i++) {
			if ( (jh->flag & (1<<i)) ||
			    jp->rots[i].upper < jp->rots[i].lower) {
			    	jh->flag |= (1<<i);
				continue;
			}
			hold = bx =jp->rots[i].current;
#define EPSI	1e-6
#define R	0.61803399
#define C	(1.0-R)
			/*
			 * find the min in the range ax-bx-cx where ax is
			 * bx-limits-0.001 or lower and cx = bx+limits+0.001
			 * or upper.
			 */
			ax=bx-limits-EPSI;
			if (ax < jp->rots[i].lower) ax=jp->rots[i].lower;
			cx=bx+limits+EPSI;
			if (cx > jp->rots[i].upper) cx=jp->rots[i].upper;
			x0=ax;
			x3=cx;
			if (fabs(cx-bx) > fabs(bx-ax)) {
				x1=bx;
				x2=bx+C*(cx-bx);
			} else {
				x2=bx;
				x1=bx-C*(bx-ax);
			}
			jp->rots[i].current = x1;
			joint_move(jp);
			f1=hold_eval(hp);
			jp->rots[i].current = x2;
			joint_move(jp);
			f2=hold_eval(hp);
			while (fabs(x3-x0) > EPSI*(fabs(x1)+fabs(x2))) {
				if (f2 < f1) {
					x0 = x1;
					x1 = x2;
					x2 = R*x1+C*x3;
					f1=f2;
					jp->rots[i].current = x2;
					joint_move(jp);
					f2=hold_eval(hp);
				} else {
					x3=x2;
					x2=x1;
					x1=R*x2+C*x0;
					f2=f1;
					jp->rots[i].current = x1;
					joint_move(jp);
					f1=hold_eval(hp);
				}
			}
			if (f1 < f2) {
				x0=x1;
				f0=f1;
			} else {
				x0=x2;
				f0=f2;
			}
			jp->rots[i].current = hold;
			joint_move(jp);
			if (f0 < besteval) {
				if (joint_debug & DEBUG_J_SOLVE) {
				  struct bu_vls tmp_vls;

				  bu_vls_init(&tmp_vls);
				  bu_vls_printf(&tmp_vls, "part_solve: NEW min %s(%d,%g) %g <%g\n",
					    jp->name, i, x0,f0, besteval);
				  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
				  bu_vls_free(&tmp_vls);
				}
				besteval = f0;
				bestjoint = jp;
				bestfreedom = i;
				bestvalue = x0;
			} else 	if (joint_debug & DEBUG_J_SOLVE) {
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, "part_solve: OLD min %s(%d,%g)%g >= %g\n",
					jp->name, i, x0, f0, besteval);
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			}
		}
		/*
		 * Now we do the same thing but for directional movements.
		 */
		for (i=0;i<3;i++) {
			if ( (jh->flag & (1<<(i+3))) ||
			    (jp->dirs[i].upper < jp->dirs[i].lower)) {
			    	jh->flag |= (1<<(i+3));
				continue;
			}
			hold = bx =jp->dirs[i].current;
			/*
			 * find the min in the range ax-bx-cx where ax is
			 * bx-limits-0.001 or lower and cx = bx+limits+0.001
			 * or upper.
			 */
			ax=bx-limits-EPSI;
			if (ax < jp->dirs[i].lower) ax=jp->dirs[i].lower;
			cx=bx+limits+EPSI;
			if (cx > jp->dirs[i].upper) cx=jp->dirs[i].upper;
			x0=ax;
			x3=cx;
			if (fabs(cx-bx) > fabs(bx-ax)) {
				x1=bx;
				x2=bx+C*(cx-bx);
			} else {
				x2=bx;
				x1=bx-C*(bx-ax);
			}
			jp->dirs[i].current = x1;
			joint_move(jp);
			f1=hold_eval(hp);
			jp->dirs[i].current = x2;
			joint_move(jp);
			f2=hold_eval(hp);
			while (fabs(x3-x0) > EPSI*(fabs(x1)+fabs(x2))) {
				if (f2 < f1) {
					x0 = x1;
					x1 = x2;
					x2 = R*x1+C*x3;
					f1=f2;
					jp->dirs[i].current = x2;
					joint_move(jp);
					f2=hold_eval(hp);
				} else {
					x3=x2;
					x2=x1;
					x1=R*x2+C*x0;
					f2=f1;
					jp->dirs[i].current = x1;
					joint_move(jp);
					f1=hold_eval(hp);
				}
			}
			if (f1 < f2) {
				x0=x1;
				f0=f1;
			} else {
				x0=x2;
				f0=f2;
			}
			jp->dirs[i].current = hold;
			joint_move(jp);
			if (f0 < besteval-SQRT_SMALL_FASTF) {
				if (joint_debug & DEBUG_J_SOLVE) {
				  struct bu_vls tmp_vls;

				  bu_vls_init(&tmp_vls);
				  bu_vls_printf(&tmp_vls, "part_solve: NEW min %s(%d,%g) %g <%g delta=%g\n",
					    jp->name, i+3, x0,f0, besteval, besteval-f0);
				  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
				  bu_vls_free(&tmp_vls);
				}
				besteval = f0;
				bestjoint = jp;
				bestfreedom = i + 3;
				bestvalue = x0;
			} else 	if (joint_debug & DEBUG_J_SOLVE) {
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, "part_solve: OLD min %s(%d,%g)%g >= %g\n",
					jp->name, i, x0, f0, besteval);
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			}

		}
	}
	/*
	 * Did we find a better joint?
	 */
	if (!bestjoint) {
		if (joint_debug & DEBUG_J_SOLVE) {
		  Tcl_AppendResult(interp, "part_solve: No joint configuration found to be better.\n", (char *)NULL);
		}
		return 0;
	}
	if (origvalue - besteval < (tol/100.0)) {
		if (joint_debug & DEBUG_J_SOLVE) {
		  Tcl_AppendResult(interp, "part_solve: No reasonable improvement found.\n", (char *)NULL);
		}
		return 0;
	}
	{
		struct solve_stack *ssp;
		BU_GETSTRUCT(ssp, solve_stack);
		ssp->jp = bestjoint;
		ssp->freedom = bestfreedom;
		ssp->old = (bestfreedom<3) ? bestjoint->rots[bestfreedom].current :
		    bestjoint->dirs[bestfreedom-3].current;
		ssp->new = bestvalue;
		BU_LIST_PUSH(&solve_head,ssp);
	}
	if (bestfreedom < 3 ) {
		bestjoint->rots[bestfreedom].current = bestvalue;
	} else {
		bestjoint->dirs[bestfreedom-3].current = bestvalue;
	}
	joint_move(bestjoint);
	return 1;
}
void
reject_move(void)
{
	register struct solve_stack *ssp;
	BU_LIST_POP(solve_stack, &solve_head, ssp);
	if (!ssp) return;
	if (joint_debug & DEBUG_J_SYSTEM) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "reject_move: rejecting %s(%d,%g)->%g\n", ssp->jp->name,
			ssp->freedom, ssp->new, ssp->old);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	if (ssp->freedom<3) { 
		ssp->jp->rots[ssp->freedom].current = ssp->old;
	} else {
		ssp->jp->dirs[ssp->freedom-3].current = ssp->old;
	}
	joint_move(ssp->jp);
	bu_free((genptr_t)ssp, "struct solve_stack");
}
/*	Constraint system solver.
 *
 * The basic idea is that we are called with some priority level.
 * We will attempted to solve all constraints at that level with out
 * permenently damaging a joint of a higher priority.
 *
 * Returns:
 *	-1	This system could not be made better without damage
 *		to a higher priority system.
 *	0	All systems at a higher priority stayed stable or
 *		got better and thise priority level got better.
 *	1	All systems at a higher priority stayed stable or
 *		got better and this system is at at min.
 * Method:
 *	while all constraints at this level are not solved:
 *		try to solve the select constraint.
 *		if joint change and this priority level got better then
 *			result = system_solve(current_priority - 1);
 *			if (result == worse) then
 *				reject this joint change
 *			fi
 *		else
 *			mark this constraint as "solved"
 *		fi
 *	endwhile
 */
#define SOLVE_MAX_PRIORITY	100
int
system_solve(int pri, double delta, double epsilon)
{
	double	pri_weights[SOLVE_MAX_PRIORITY+1];
	double	new_weights[SOLVE_MAX_PRIORITY+1];
	double	new_eval;
	register int i;
	int	j;
	register struct hold *hp;
	struct jointH *jh;
	struct solve_stack *ssp;
	struct hold *test_hold = NULL;

	if (pri < 0) return 1;

	for (i=0; i<=pri; i++) 	pri_weights[i]=0.0;
	for (BU_LIST_FOR(hp,hold,&hold_head)) {
		hp->eval = hold_eval(hp);
		pri_weights[hp->priority] += hp->eval;
	}

	if (joint_debug & DEBUG_J_SYSTEM) {
		for (i=0; i <= pri; i++ ) {
			if (pri_weights[i] > 0.0) {
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, "system_solve: priority %d has system weight of %g.\n",
					i, pri_weights[i]);
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			}
		}
	}
	/*
	 * sort constraints by priority then weight from the evaluation
	 * we just did.
	 */
	for (hp=(struct hold *)hold_head.forw; hp->l.forw != &hold_head;) {
		register struct hold *tmp;
		tmp = (struct hold *)hp->l.forw;

	    	if ((tmp->priority < hp->priority) ||
		    ((tmp->priority == hp->priority) &&
		     (tmp->eval > hp->eval))) {
		     	BU_LIST_DEQUEUE(&tmp->l);
		     	BU_LIST_INSERT(&hp->l,&tmp->l);
		     	if (tmp->l.back != &hold_head) {
		     		hp = (struct hold*)tmp->l.back;
		     	}
	     	} else {
	     		hp = (struct hold*)hp->l.forw;
		}
	}
Middle:
	/*
	 * now we find the constraint(s) we will be working with.
	 */
	for (; pri>=0 && pri_weights[pri] < epsilon; pri--);
	if (pri <0) {
		if (joint_debug & DEBUG_J_SYSTEM) {
		  Tcl_AppendResult(interp, "system_solve: returning 1\n", (char *)NULL);
		}
		return 1;	/* solved */
	}
	for (BU_LIST_FOR(hp,hold,&hold_head)) {
		if (hp->priority != pri) continue;
		if (hp->flag & HOLD_FLAG_TRIED) continue;
		if (part_solve(hp,delta,epsilon)==0) continue;
		test_hold = hp;
		break;
	}
	/*
	 * Now check to see if a) anything happened, b) that it was good
	 * for the entire system.
	 */
	if (hp==(struct hold*)&hold_head) {
		/*
		 * There was nothing we could do at this level.  Try
		 * again at a higher level.
		 */
		pri--;
		goto Middle;
	}
	/*
	 * We did something so lets re-evaluated and see if it got any
	 * better at THIS level only.  breaking things of lower priority
	 * does not bother us.  If things got worse at a lower priority
	 * we'll know that in a little bit.
	 */
	new_eval = 0.0;
	for (BU_LIST_FOR(hp,hold,&hold_head)) {
		if (hp->priority != pri) continue;
		new_eval += hold_eval(hp);
	}
	if (joint_debug & DEBUG_J_SYSTEM) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "system_solve: old eval = %g, new eval = %g\n",
			pri_weights[pri], new_eval);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	/*
	 * if the new evaluation is worse then the origianal, back off
	 * this modification, set the constraint such that this freedom
	 * of this joint won't be used next time through part_solve.
	 */
	if (new_eval > pri_weights[pri]+epsilon) {
		/*
		 * now we see if there is anything we can do with this
		 * constraint.
		 */
		ssp = (struct solve_stack *) solve_head.forw;

		i = (2<<6) - 1;		/* Six degrees of freedom */
		for (BU_LIST_FOR(jh,jointH, &test_hold->j_head)) {
			if (ssp->jp != jh->p) {
				i &= jh->flag;
				continue;
			}
			jh->flag |= (1 << ssp->freedom);
			i &= jh->flag;
		}
		if (i == ((2<<6)-1)) {	/* All joints, all freedoms */
			test_hold->flag |= HOLD_FLAG_TRIED;
		}
		reject_move();
		goto Middle;
	}
	/*
	 * Ok, we've got a constraint that makes this priority system
	 * better, now we've got to make sure all the constraints below
	 * this are better or solve also.
	 */
	ssp = (struct solve_stack *) solve_head.forw;
	for (j=0; (i = system_solve(pri-1, delta, epsilon)) == 0; j++);
	/*
	 * All constraints at a higher priority are stabilized.
	 *
	 * If system_solve() returned "1" then every thing higher is
	 * happy and we only have to worry about his one.  If -1 was
	 * returned then all higher priorities have to be check to
	 * make sure they did not get any worse.
	 */
	for (j=0; j<=pri; j++) new_weights[j] = 0.0;
	for (BU_LIST_FOR(hp, hold, &hold_head)) {
		new_weights[hp->priority] += hold_eval(hp);
	}
	for (j=0; j<=pri; j++) {
		if (new_weights[j] > pri_weights[j] + epsilon) break;
	}
	/*
	 * if j <= pri, then that priority got worse.  Since it is
	 * worse, we need to clean up what's been done before and
	 * exit out of here.
	 */
	if (j <= pri) {
		while (ssp != (struct solve_stack *) solve_head.forw) {
			reject_move();
		}
		i = (2 << 6) - 1;
		for (BU_LIST_FOR(jh, jointH, &test_hold->j_head)) {
			if (ssp->jp != jh->p) {
				i &= jh->flag;
				continue;
			}
			jh->flag |= (1 << ssp->freedom);
			i &= jh->flag;
		}
		if (i == ((2<<6) - 1)) {
			test_hold->flag |= HOLD_FLAG_TRIED;
		}
		reject_move();
		if (joint_debug & DEBUG_J_SYSTEM) {
		  Tcl_AppendResult(interp, "system_solve: returning -1\n", (char *)NULL);
		}
		return -1;
	}
	if (joint_debug & DEBUG_J_SYSTEM) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "system_solve: new_weights[%d] = %g, returning ", pri,
			new_weights[pri]);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
	if (new_weights[pri] < epsilon) {
		if (joint_debug & DEBUG_J_SYSTEM) {
		  Tcl_AppendResult(interp, "1\n", (char *)NULL);
		}
		return 1;
	}
	if (joint_debug & DEBUG_J_SYSTEM) {
	  Tcl_AppendResult(interp, "0\n", (char *)NULL);
	}
	return 0;

}
int
f_jsolve(int argc, char **argv)
{
	register struct hold *hp;
	int loops, count;
	double delta, epsilon;
	int	domesh;
	int	found;
	char **myargv;
	int myargc;
	int result = 0;

	/*
	 * because this routine calls "mesh" in the middle, the command
	 * arguements can be reused.  We cons up a new argv vector and
	 * copy all of the arguements before we do any processing.
	 */
	myargc = argc;
	myargv = (char **)bu_malloc(sizeof(char *)*argc, "param pointers");

	for (count=0; count<myargc; count++) {
		myargv[count] = (char *)bu_malloc(strlen(argv[count])+1,"param");
		strcpy(myargv[count], argv[count]);
	}

	argv=myargv;
	/* argc = myargc; */

	/*
	 * these are the defaults.  Domesh will change to not at a later
	 * time.
	 */
	loops = 20;
	delta = 5.0;
	epsilon = 0.1;
	domesh = 1;

	/*
	 * reset bu_getopt.
	 */
	bu_optind=1;
	while ((count=bu_getopt(argc,argv,"l:e:d:m")) != EOF) {
		switch (count) {
		case 'l': loops = atoi(bu_optarg);break;
		case 'e': epsilon = atof(bu_optarg);break;
		case 'd': delta =  atof(bu_optarg);break;
		case 'm': domesh = 1-domesh;
		}
	}

	/*
	 * skip the command and any options that bu_getopt ate.
	 */
	argc -= bu_optind;
	argv += bu_optind;

	for (BU_LIST_FOR(hp, hold, &hold_head)) hold_clear_flags(hp);
	found = -1;
	while (argc) {
	  found = 0;
	  for(BU_LIST_FOR(hp,hold,&hold_head)) {
	    if (strcmp(*argv, hp->name)==0) {
	      found = 1;
	      for (count=0; count<loops; count++) {
		if (!part_solve(hp,delta,epsilon)) break;
		if (domesh) {
		  f_jmesh(0,0);
		  refresh();
		}
		joint_clear();
	      }
	      
	      {
		struct bu_vls tmp_vls;
		
		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "joint solve: finished %d loops of %s.\n", 
			      count, hp->name);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
	      }

	      continue;
	    }
	  }
	  if (!found) {
	    Tcl_AppendResult(interp, "joint solve: constraint ", *argv,
			     " not found.\n", (char *)NULL);
	  }
	  --argc;
	  ++argv;
	}

	for (count=0; count<myargc; count++) {
		bu_free(myargv[count],"params");
	}
	bu_free((genptr_t)myargv,"param pointers");

	if (found >= 0) return CMD_BAD;

	/*
	 * solve the whole system of constraints.
	 */

	joint_clear();	/* make sure the system is empty. */

	for (count=0; count < loops; count++) {
		/*
		 * Clear all constrain flags.
		 */
		for (BU_LIST_FOR(hp,hold,&hold_head)) {
			register struct jointH *jh;
			hp->flag &= ~HOLD_FLAG_TRIED;
			hp->eval = hold_eval(hp);
			for (BU_LIST_FOR(jh, jointH, &hp->j_head)) {
				jh->flag = 0;
			}
		}
		result = system_solve(0,delta,epsilon);
		if (result == 1) {
			break;
		} else if (result == -1) {
			delta /= 2.0;
			if (joint_debug & DEBUG_J_SYSTEM) {
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, "joint solve: spliting delta (%g)\n",
					delta);
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			}
			if (delta < epsilon) break;
		}
		joint_clear();
		if (domesh) {
			f_jmesh(0,0);
			refresh();
		}
	}
	if (count < loops) {
		for(count = 0; count < loops; count++) {
			/*
			 * Clear all constrain flags.
			 */
			for (BU_LIST_FOR(hp,hold,&hold_head)) {
				register struct jointH *jh;
				hp->flag &= ~HOLD_FLAG_TRIED;
				hp->eval = hold_eval(hp);
				for (BU_LIST_FOR(jh, jointH, &hp->j_head)) {
					jh->flag = 0;
				}
			}
			result =system_solve(SOLVE_MAX_PRIORITY,delta,epsilon);
			if (result == 1) {
				break;
			} else if (result == -1) {
				delta /= 2.0;
				if (joint_debug & DEBUG_J_SYSTEM) {
				  struct bu_vls tmp_vls;

				  bu_vls_init(&tmp_vls);
				  bu_vls_printf(&tmp_vls, "joint solve: spliting delta (%g)\n",
						delta);
				  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
				                            bu_vls_free(&tmp_vls);
				}
				if (delta < epsilon) break;
			}
			joint_clear();
			if (domesh) {
				f_jmesh(0,0);
				refresh();
			}
		}
	}
	if (result == 1) {
	  Tcl_AppendResult(interp, "joint solve: system has convereged to a result.\n",
			   (char *)NULL);
	} else if (result == 0) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "joint solve: system has not converged in %d loops.\n",
			count);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	} else {
	  Tcl_AppendResult(interp, "joint solve: system will not converge.\n", (char *)NULL);
	}
	joint_clear();
	if (domesh) {
		f_jmesh(0,0);
		refresh();
	}
	return CMD_OK;
}
static char *
hold_point_to_string(struct hold_point *hp)
{
#define HOLD_POINT_TO_STRING_LEN	1024
	char *text = bu_malloc(HOLD_POINT_TO_STRING_LEN, "hold_point_to_string");
	char *path;
	vect_t loc;

	switch (hp->type) {
	case ID_FIXED:
		sprintf(text,"(%g %g %g)", hp->point[X],
		    hp->point[Y], hp->point[Z]);
		break;
	case ID_GRIP:
	case ID_JOINT:
		(void)hold_point_location(loc,hp);
		path = db_path_to_string(&hp->path);
		sprintf(text,"%s (%g %g %g)", path, loc[X], loc[Y], loc[Z]);
		bu_free(path, "full path");
		break;
	}
	if (strlen(text) > (unsigned)HOLD_POINT_TO_STRING_LEN) {
		bu_bomb("hold_point_to_string: over wrote memory!\n");
	}
	return text;
}
void
print_hold(struct hold *hp)
{
	char *t1, *t2;

	t1 = hold_point_to_string(&hp->effector);
	t2 = hold_point_to_string(&hp->objective);
	Tcl_AppendResult(interp, "holds:\t", (hp->name) ? hp->name : "UNNAMED",
			 " with ", hp->joint, "\n\tfrom:", t1, "\n\tto: ", t2, (char *)NULL);
	bu_free(t1, "hold_point_to_string");
	bu_free(t2, "hold_point_to_string");

	{
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls,"\n\twith a weight: %g, pull %g\n",
			hp->weight, hold_eval(hp) );
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}
}
int
f_jhold(int argc, char **argv)
{
	register struct hold *hp;
	++argv;
	--argc;
	for (BU_LIST_FOR(hp, hold, &hold_head)) {
		if (argc) {
			register int i;
			for (i=0; i<argc; i++) {
				if (strcmp(argv[i], hp->name) == 0) break;
			}
			if (i>=argc) continue;
		}
		hold_clear_flags(hp);
		print_hold(hp);
	}
	return CMD_OK;
}
int
f_jlist(int argc, char **argv)
{
  register struct joint *jp;
  struct bu_vls vls;

  bu_vls_init(&vls);
  for (BU_LIST_FOR(jp, joint, &joint_head)) {
    vls_col_item(&vls, jp->name);
  }
  vls_col_eol(&vls);

  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  bu_vls_free(&vls);
  return CMD_OK;
}
void
joint_move(struct joint *jp)
{
	register struct animate *anp;
	double tmp;
	mat_t	m1,m2;
	quat_t	q1;
	int i;

	if(dbip == DBI_NULL)
	  return;

	/*
	 * If no animate structure, cons one up.
	 */
	anp=jp->anim;
	if (!anp || anp->magic != ANIMATE_MAGIC) {
		char *sofar;
		struct directory *dp = NULL;
		BU_GETSTRUCT(anp, animate);
		anp->magic = ANIMATE_MAGIC;
		db_init_full_path(&anp->an_path);
		anp->an_path.fp_len = jp->path.arc_last+1;
		anp->an_path.fp_maxlen= jp->path.arc_last+1;
		anp->an_path.fp_names = (struct directory **)
		    bu_malloc(sizeof(struct directory **)*anp->an_path.fp_maxlen,
		    "full path");
		for (i=0; i<= jp->path.arc_last; i++) {
			dp = anp->an_path.fp_names[i] = db_lookup(dbip,
			    jp->path.arc[i], LOOKUP_NOISY);
			if (!dp) {
				anp->an_path.fp_len = i;
				db_free_full_path(&anp->an_path);
				bu_free((genptr_t)anp, "struct animate");
				return;
			}
		}
		jp->anim=anp;
		db_add_anim(dbip, anp, 0);
		if (joint_debug & DEBUG_J_MOVE) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  sofar = db_path_to_string(&jp->anim->an_path);
		  bu_vls_printf(&tmp_vls, "joint move: %s added animate %s to %s(0x%x)\n",
				jp->name, sofar, dp->d_namep, dp);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
	}


#define ANIM_MAT	(anp->an_u.anu_m.anm_mat)

	anp->an_type = RT_AN_MATRIX;
	anp->an_u.anu_m.anm_op = ANM_RMUL;

	/*
	 * Build the base matrix.  Ident with translate back to origin.
	 */
	MAT_IDN(ANIM_MAT);
	MAT_DELTAS_VEC_NEG(ANIM_MAT, jp->location);

	/*
	 * Do rotations.
	 */
	for (i=0; i<3; i++ ) {
		if (jp->rots[i].upper < jp->rots[i].lower) break;
		/*
		 * Build a quat from that.
		 */
		tmp = (jp->rots[i].current * bn_degtorad)/2.0;
		VMOVE(q1, jp->rots[i].quat);
		if (joint_debug & DEBUG_J_MOVE) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "joint move: rotating %g around (%g %g %g)\n",
				tmp*2*bn_radtodeg, q1[X], q1[Y], q1[Z]);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
		{register double srot = sin(tmp);
			q1[X] *= srot;
			q1[Y] *= srot;
			q1[Z] *= srot;
		}
		q1[W] = cos(tmp);

		/*
		 * Build matrix.
		 */
		quat_quat2mat(m2,q1);
		MAT_COPY(m1, ANIM_MAT);
		bn_mat_mul(ANIM_MAT, m2, m1);
		/*
		 * rmult matrix into the mat we are building.
		 */
	}
	/*
	 * do the translations.
	 */
	for (i=0; i<3; i++) {
		if (jp->dirs[i].upper < jp->dirs[i].lower) break;
		/*
		 * build matrix.
		 */
		tmp = jp->dirs[i].current;
		MAT_IDN(m2);
		MAT_DELTAS(m2, jp->dirs[i].unitvec[X]*tmp,
		    jp->dirs[i].unitvec[Y]*tmp,
		    jp->dirs[i].unitvec[Z]*tmp);

		if (joint_debug & DEBUG_J_MOVE) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "joint move: moving %g along (%g %g %g)\n",
				tmp*base2local, m2[3], m2[7], m2[11]);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
		MAT_COPY(m1, ANIM_MAT);
		bn_mat_mul(ANIM_MAT, m2, m1);
	}
	/*
	 * Now move the whole thing back to original location.
	 */
	MAT_IDN(m2);
	MAT_DELTAS_VEC(m2, jp->location);
	MAT_COPY(m1, ANIM_MAT);
	bn_mat_mul(ANIM_MAT,m2,m1);
	if (joint_debug & DEBUG_J_MOVE) {
		bn_mat_print("joint move: ANIM_MAT", ANIM_MAT);
	}
}
int
f_jmove(int argc, char **argv)
{
	struct joint *jp;
	int i;
	double tmp;

	if(dbip == DBI_NULL)
	  return CMD_OK;

	/*
	 * find the joint.
	 */
	argv++;
	argc--;

	jp = joint_lookup(*argv);
	if (!jp) {
	  Tcl_AppendResult(interp, "joint move: ", *argv, " not found\n", (char *)NULL);
	  return CMD_BAD;
	}

	argv++;
	argc--;
	for (i=0; i<3 && argc; i++) {
		if (jp->rots[i].upper < jp->rots[i].lower) break;
		/*
		 * Eat a parameter, translate it from degrees to rads.
		 */
		if ((*argv)[0] == '-' && (*argv)[1] == '\0') {
			++argv;
			--argc;
			continue;
		}
		tmp = atof(*argv);
		if (joint_debug & DEBUG_J_MOVE) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "joint move: %s rotate (%g %g %g) %g degrees.\n",
				jp->name, jp->rots[i].quat[X],
				jp->rots[i].quat[Y], jp->rots[i].quat[Z],
				tmp);
		  bu_vls_printf(&tmp_vls, "joint move: %s lower=%g, upper=%g\n",
				jp->name, jp->rots[i].lower, jp->rots[i].upper);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
		if (tmp <= jp->rots[i].upper &&
		    tmp >= jp->rots[i].lower) {
		    	jp->rots[i].current = tmp;
		} else {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "joint move: %s, rotation %d, %s out of range.\n",
				jp->name, i, *argv);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
		argv++;
		argc--;
	}
	for (i=0; i<3 && argc; i++) {
		if (jp->dirs[i].upper < jp->dirs[i].lower) break;
		/*
		 * eat a parameter.
		 */
		if ((*argv)[0] == '-' && (*argv)[1] == '\0') {
			++argv;
			--argc;
			continue;
		}
		tmp = atof(*argv) * local2base;
		if (tmp <= jp->dirs[i].upper &&
		    tmp >= jp->dirs[i].lower) {
		    	jp->dirs[i].current = tmp;
		} else {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "joint move: %s, vector %d, %s out of range.\n",
				jp->name, i, *argv);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
	}
	joint_move(jp);
	f_jmesh(0,0);
	return CMD_OK;
}

struct artic_grips {
	struct bu_list	l;
	vect_t		vert;
	struct directory *dir;
};
#define	MAGIC_A_GRIP	0x414752aa
struct artic_joints {
	struct bu_list	l;
	struct bu_list	head;
	struct joint	*joint;
};
#define MAGIC_A_JOINT	0x414A4F55

struct bu_list artic_head = {
	BU_LIST_HEAD_MAGIC,
	&artic_head, &artic_head
};

struct joint *
findjoint(struct db_full_path *pathp)
{
	register int i,j;
	register struct joint *jp;
	int best;
	struct joint *bestjp = NULL;

	if (joint_debug & DEBUG_J_MESH) {
	  char *sofar = db_path_to_string(pathp);

	  Tcl_AppendResult(interp, "joint mesh: PATH = '", sofar, "'\n", (char *)NULL);
	  bu_free(sofar, "path string");
	}

	best = -1;
	for (BU_LIST_FOR(jp, joint, &joint_head)) {
		for (i=0; i< pathp->fp_len; i++) {
			int good=1;
			if (jp->path.arc_last+i >= pathp->fp_len) break;
			for (j=0; j<=jp->path.arc_last;j++) {
				if ((*pathp->fp_names[i+j]->d_namep != *jp->path.arc[j]) ||
				    (strcmp(pathp->fp_names[i+j]->d_namep, jp->path.arc[j]) !=0)) {
				    	good=0;
				    	break;
				}
			}

			if (good && j>best) {
				best = j;
				bestjp = jp;
			}
		}
	}
	if (best > 0) {
	    	if (joint_debug & DEBUG_J_MESH) {
		  Tcl_AppendResult(interp, "joint mesh: returning joint '",
				   bestjp->name, "'\n", (char *)NULL);
	    	}
		return bestjp;
 	}

	if (joint_debug & DEBUG_J_MESH) {
	  Tcl_AppendResult(interp, "joint mesh: returning joint 'NULL'\n", (char *)NULL);
	}
	return (struct joint *) 0;
}

HIDDEN union tree *
mesh_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	struct rt_grip_internal *gip;
	struct	artic_joints	*newJoint;
	struct	artic_grips	*newGrip;
	struct	joint		*jp;
	union	tree		*curtree;
	struct	directory	*dp;

	RT_CK_FULL_PATH(pathp);
	RT_CK_DB_INTERNAL(ip);

	if (ip->idb_type != ID_GRIP) {
		return TREE_NULL;
	}

	BU_GETUNION(curtree, tree);
	curtree->tr_op = OP_SOLID;
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;
	dp = pathp->fp_names[pathp->fp_len-1];
/*
 * get the grip information.
 */
	gip = (struct rt_grip_internal *) ip->idb_ptr;
/*
 * find the joint that this grip belongs to.
 */
	jp = findjoint(pathp);
/*
 * Get the grip structure.
 */
	newGrip = (struct artic_grips *)bu_malloc(sizeof(struct artic_grips),
	    "artic_grip");
	newGrip->l.magic = MAGIC_A_GRIP;
	VMOVE(newGrip->vert, gip->center);
	newGrip->dir = dp;
	for (BU_LIST_FOR(newJoint, artic_joints, &artic_head)) {
		if (newJoint->joint == jp) {
			BU_LIST_APPEND(&newJoint->head, &(newGrip->l));
			return curtree;
		}
	}
/*
 * we need a new joint thingie.
 */
	newJoint = (struct artic_joints *)bu_malloc(sizeof(struct artic_joints),
	    "Artic Joint");
	newJoint->l.magic = MAGIC_A_JOINT;
	newJoint->joint = jp;
	BU_LIST_INIT(&newJoint->head);
	BU_LIST_APPEND(&artic_head, &(newJoint->l));
	BU_LIST_APPEND(&newJoint->head, &(newGrip->l));

	return curtree;
}
HIDDEN union tree *
mesh_end_region (register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
{
	return curtree;
}
static struct db_tree_state mesh_initial_tree_state = {
	RT_DBTS_MAGIC,		/* magic */
	0,			/* ts_dbip */
	0,			/* ts_sofar */
	0,0,0,			/* region, air, gmater */
	100,			/* GIFT los */
	{
		/* struct mater_info ts_mater */
		{1.0, 0.0, 0.0},	/* color, RGB */
		-1.0,		/* Temperature */
		0,		/* override */
		0,		/* color inherit */
		0,		/* mater inherit */
		(char *)NULL	/* shader */
	}
	,
	{1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0},
	REGION_NON_FASTGEN,		/* ts_is_fastgen */
	{
		/* attribute value set */
		BU_AVS_MAGIC,
		0,
		0,
		NULL,
		NULL,
		NULL
	}
	,
	0,				/* ts_stop_at_regions */
	NULL,				/* ts_region_start_func */
	NULL,				/* ts_region_end_func */
	NULL,				/* ts_leaf_func */
	NULL,				/* ts_ttol */
	NULL,				/* ts_tol */
	NULL,				/* ts_m */
	NULL,				/* ts_rtip */
	NULL				/* ts_resp */
};
int
f_jmesh(int argc, char **argv)
{
	char			*name;
	struct rt_vlblock	*vbp;
	register struct bu_list *vhead;
	struct artic_joints	*jp;
	struct artic_grips	*gp, *gpp;
	int i;
	char			*topv[2000];
	int			topc;

	if(dbip == DBI_NULL)
	  return CMD_OK;

	if( argc <= 2) {
		name = "_ANIM_";
	} else {
		name = argv[2];
	}

	topc = build_tops(topv, topv+2000);
	{
		register struct solid *sp;
		FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
			sp->s_iflag=DOWN;
		}
	}

	i = db_walk_tree(dbip, topc, (const char **)topv,
	    1,			/* Number of cpus */
	    &mesh_initial_tree_state,
	    0,			/* Begin region */
	    mesh_end_region,	/* End region */
	    mesh_leaf,		/* node */
	    (genptr_t)NULL);

	/*
	 * Now we draw the the overlays.  We do this by building a 
	 * mesh from each grip to every other grip in that list.
	 */
	vbp = rt_vlblock_init();
	vhead = rt_vlblock_find( vbp, 0x00, 0xff, 0xff);

	for (BU_LIST_FOR(jp, artic_joints, &artic_head)) {
		i=0;
		for (BU_LIST_FOR(gp, artic_grips, &jp->head)){
			i++;
			for (gpp=BU_LIST_NEXT(artic_grips, &(gp->l));
			    BU_LIST_NOT_HEAD(gpp, &(jp->head));
			    gpp=BU_LIST_NEXT(artic_grips, &(gpp->l))) {
				RT_ADD_VLIST( vhead, gp->vert, RT_VLIST_LINE_MOVE);
				RT_ADD_VLIST( vhead, gpp->vert, RT_VLIST_LINE_DRAW);
			}
		}
		if (joint_debug & DEBUG_J_MESH) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "joint mesh: %s has %d grips.\n",
				(jp->joint) ? jp->joint->name: "UNGROUPED",i);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		}
	}

	cvt_vlblock_to_solids(vbp, name, 0);
	rt_vlblock_free(vbp);
	while (BU_LIST_WHILE(jp, artic_joints, &artic_head)) {
		while (BU_LIST_WHILE(gp, artic_grips, &jp->head)) {
			BU_LIST_DEQUEUE(&gp->l);
			bu_free((genptr_t)gp,"artic_grip");
		}
		BU_LIST_DEQUEUE(&jp->l);
		bu_free((genptr_t)jp, "Artic Joint");
	}
	return CMD_OK;
}
@


11.48
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/animedit.c,v 11.47 2004/04/05 09:09:11 morrison Exp $";
@


11.47
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$";
d22 5
a26 1
#include "conf.h"
@


11.46
log
@merge of windows-6-0-branch into head
@
text
@d57 2
a58 2
void joint_move();
void joint_clear();
d60 16
a75 16
static int f_jfhelp();
int f_fhelp2();
static int f_jhelp();
int f_help2();
int f_jmesh();
int f_jdebug();
int f_jload();
int f_junload();
int f_jmove();
int f_jlist();
int f_jaccept();
int f_jreject();
int f_jsave();
int f_jhold();
int f_jsolve();
int f_jtest();
d138 1
a138 5
f_joint(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d164 1
a164 3
f_jfhelp(argc, argv)
int argc;
char **argv;
d177 1
a177 3
f_jhelp(argc, argv)
int argc;
char **argv;
d197 1
a197 2
joint_lookup(name)
char *name;
d207 1
a207 2
free_arc(ap)
struct arc *ap;
d225 1
a225 2
free_joint(jp)
struct joint *jp;
d233 1
a233 2
free_hold(hp)
struct hold *hp;
d260 1
a260 2
hold_clear_flags(hp)
struct hold *hp;
d451 1
a451 3
f_junload(argc, argv)
int argc;
char **argv;
d592 1
a592 3
parse_error(str, error)
struct bu_vls *str;
char *error;
d626 1
a626 6
get_token(token, fip, str, keys, syms)
union bu_lex_token *token;
FILE *fip;
struct bu_vls *str;
struct bu_lex_key *keys;
struct bu_lex_key *syms;
d676 1
a676 5
gobble_token(type_wanted, value_wanted, fip, str)
int type_wanted;
int value_wanted;
FILE *fip;
struct bu_vls *str;
d719 1
a719 3
skip_group(fip, str)
FILE * fip;
struct bu_vls *str;
d746 1
a746 3
parse_units(fip, str)
FILE *fip;
struct bu_vls *str;
d777 1
a777 4
parse_path(ap, fip, str)
struct arc *ap;
FILE *fip;
struct bu_vls *str;
d852 1
a852 4
parse_list(ap, fip, str)
struct arc *ap;
FILE *fip;
struct bu_vls *str;
d911 1
a911 4
parse_ARC(ap, fip, str)
struct arc *ap;
FILE *fip;
struct bu_vls *str;
d969 1
a969 4
parse_double(dbl, fip, str)
double *dbl;
FILE *fip;
struct bu_vls *str;
d1006 1
a1006 4
parse_assign(dbl, fip, str)
double *dbl;
FILE *fip;
struct bu_vls *str;
d1023 1
a1023 4
parse_vect(vect, fip, str)
vect_t vect;
FILE *fip;
struct bu_vls *str;
d1043 1
a1043 5
parse_trans(jp, index, fip, str)
struct joint *jp;
int index;
FILE *fip;
struct bu_vls *str;
d1201 1
a1201 5
parse_rots(jp, index, fip, str)
struct joint *jp;
int index;
FILE *fip;
struct bu_vls *str;
d1359 1
a1359 3
parse_joint(fip, str)
FILE *fip;
struct bu_vls *str;
d1517 1
a1517 4
parse_jset(hp,fip, str)
struct hold *hp;
FILE *fip;
struct bu_vls *str;
d1606 1
a1606 4
parse_solid(pp, fip, str)
struct hold_point *pp;
FILE *fip;
struct bu_vls *str;
d1670 1
a1670 4
parse_point(pp, fip, str)
struct hold_point *pp;
FILE *fip;
struct bu_vls *str;
d1712 1
a1712 3
parse_hold(fip, str)
FILE *fip;
struct bu_vls *str;
d1874 1
a1874 3
f_jload(argc, argv)
int argc;
char **argv;
d2025 1
a2025 3
f_jtest(argc, argv)
int argc;
char **argv;
d2030 1
a2030 3
f_jsave(argc, argv)
int argc;
char **argv;
d2109 1
a2109 3
f_jaccept(argc, argv)
int argc;
char **argv;
d2144 1
a2144 3
f_jreject(argc, argv)
int argc;
char **argv;
d2181 1
a2181 3
hold_point_location(loc, hp)
vect_t loc;
struct hold_point *hp;
d2239 1
a2239 2
hold_eval(hp)
struct hold *hp;
d2287 1
a2287 1
joint_clear()
d2298 1
a2298 4
part_solve(hp, limits, tol)
struct hold *hp;
double limits;
double tol;
d2618 1
a2618 1
reject_move()
d2668 1
a2668 4
system_solve(pri,delta, epsilon)
int pri;
double delta;
double epsilon;
d2869 1
a2869 3
f_jsolve(argc, argv)
int argc;
char **argv;
d3066 1
a3066 2
hold_point_to_string(hp)
struct hold_point *hp;
d3092 1
a3092 2
print_hold(hp)
struct hold *hp;
d3114 1
a3114 3
f_jhold(argc, argv)
int argc;
char **argv;
d3133 1
a3133 3
f_jlist(argc, argv)
int argc;
char **argv;
d3149 1
a3149 2
joint_move(jp)
struct joint *jp;
d3285 1
a3285 3
f_jmove(argc, argv)
int argc;
char **argv;
d3395 1
a3395 2
findjoint(pathp)
struct db_full_path	*pathp;
d3442 2
a3443 13
#ifndef WIN32
HIDDEN union tree *mesh_leaf( tsp, pathp, ip, client_data)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
#else
HIDDEN union tree *mesh_leaf(
struct db_tree_state	*tsp,
struct db_full_path	*pathp,
struct rt_db_internal	*ip,
genptr_t		client_data)
#endif
d3499 2
a3500 14

#ifndef WIN32
HIDDEN union tree *mesh_end_region (tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path		*pathp;
union tree			*curtree;
genptr_t			client_data;
#else
HIDDEN union tree *mesh_end_region (
register struct db_tree_state	*tsp,
struct db_full_path		*pathp,
union tree			*curtree,
genptr_t			client_data)
#endif
d3546 1
a3546 3
f_jmesh(argc, argv)
int argc;
char **argv;
@


11.45
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.43 2001/08/11 13:16:11 butler Exp $";
d3542 1
d3548 7
d3610 2
d3617 7
@


11.45.10.1
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$";
a3541 1
#ifndef WIN32
a3546 7
#else
HIDDEN union tree *mesh_leaf(
struct db_tree_state	*tsp,
struct db_full_path	*pathp,
struct rt_db_internal	*ip,
genptr_t		client_data)
#endif
a3601 2

#ifndef WIN32
a3606 7
#else
HIDDEN union tree *mesh_end_region (
register struct db_tree_state	*tsp,
struct db_full_path		*pathp,
union tree			*curtree,
genptr_t			client_data)
#endif
@


11.45.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.45 2002/08/20 17:08:21 jra Exp $";
a3541 1
#ifndef WIN32
a3546 7
#else
HIDDEN union tree *mesh_leaf(
struct db_tree_state	*tsp,
struct db_full_path	*pathp,
struct rt_db_internal	*ip,
genptr_t		client_data)
#endif
a3601 2

#ifndef WIN32
a3606 7
#else
HIDDEN union tree *mesh_end_region (
register struct db_tree_state	*tsp,
struct db_full_path		*pathp,
union tree			*curtree,
genptr_t			client_data)
#endif
@


11.45.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.45 2002/08/20 17:08:21 jra Exp $";
d57 2
a58 2
void joint_move(struct joint *jp);
void joint_clear(void);
d60 16
a75 16
static int f_jfhelp(int argc, char **argv);
int f_fhelp2(int argc, char **argv, struct funtab *functions);
static int f_jhelp(int argc, char **argv);
int f_help2(int argc, char **argv, struct funtab *functions);
int f_jmesh(int argc, char **argv);
int f_jdebug(int argc, char **argv);
int f_jload(int argc, char **argv);
int f_junload(int argc, char **argv);
int f_jmove(int argc, char **argv);
int f_jlist(int argc, char **argv);
int f_jaccept(int argc, char **argv);
int f_jreject(int argc, char **argv);
int f_jsave(int argc, char **argv);
int f_jhold(int argc, char **argv);
int f_jsolve(int argc, char **argv);
int f_jtest(int argc, char **argv);
d138 5
a142 1
f_joint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d168 3
a170 1
f_jfhelp(int argc, char **argv)
d183 3
a185 1
f_jhelp(int argc, char **argv)
d205 2
a206 1
joint_lookup(char *name)
d216 2
a217 1
free_arc(struct arc *ap)
d235 2
a236 1
free_joint(struct joint *jp)
d244 2
a245 1
free_hold(struct hold *hp)
d272 2
a273 1
hold_clear_flags(struct hold *hp)
d464 3
a466 1
f_junload(int argc, char **argv)
d607 3
a609 1
parse_error(struct bu_vls *str, char *error)
d643 6
a648 1
get_token(union bu_lex_token *token, FILE *fip, struct bu_vls *str, struct bu_lex_key *keys, struct bu_lex_key *syms)
d698 5
a702 1
gobble_token(int type_wanted, int value_wanted, FILE *fip, struct bu_vls *str)
d745 3
a747 1
skip_group(FILE *fip, struct bu_vls *str)
d774 3
a776 1
parse_units(FILE *fip, struct bu_vls *str)
d807 4
a810 1
parse_path(struct arc *ap, FILE *fip, struct bu_vls *str)
d885 4
a888 1
parse_list(struct arc *ap, FILE *fip, struct bu_vls *str)
d947 4
a950 1
parse_ARC(struct arc *ap, FILE *fip, struct bu_vls *str)
d1008 4
a1011 1
parse_double(double *dbl, FILE *fip, struct bu_vls *str)
d1048 4
a1051 1
parse_assign(double *dbl, FILE *fip, struct bu_vls *str)
d1068 4
a1071 1
parse_vect(fastf_t *vect, FILE *fip, struct bu_vls *str)
d1091 5
a1095 1
parse_trans(struct joint *jp, int index, FILE *fip, struct bu_vls *str)
d1253 5
a1257 1
parse_rots(struct joint *jp, int index, FILE *fip, struct bu_vls *str)
d1415 3
a1417 1
parse_joint(FILE *fip, struct bu_vls *str)
d1575 4
a1578 1
parse_jset(struct hold *hp, FILE *fip, struct bu_vls *str)
d1667 4
a1670 1
parse_solid(struct hold_point *pp, FILE *fip, struct bu_vls *str)
d1734 4
a1737 1
parse_point(struct hold_point *pp, FILE *fip, struct bu_vls *str)
d1779 3
a1781 1
parse_hold(FILE *fip, struct bu_vls *str)
d1943 3
a1945 1
f_jload(int argc, char **argv)
d2096 3
a2098 1
f_jtest(int argc, char **argv)
d2103 3
a2105 1
f_jsave(int argc, char **argv)
d2184 3
a2186 1
f_jaccept(int argc, char **argv)
d2221 3
a2223 1
f_jreject(int argc, char **argv)
d2260 3
a2262 1
hold_point_location(fastf_t *loc, struct hold_point *hp)
d2320 2
a2321 1
hold_eval(struct hold *hp)
d2369 1
a2369 1
joint_clear(void)
d2380 4
a2383 1
part_solve(struct hold *hp, double limits, double tol)
d2703 1
a2703 1
reject_move(void)
d2753 4
a2756 1
system_solve(int pri, double delta, double epsilon)
d2957 3
a2959 1
f_jsolve(int argc, char **argv)
d3156 2
a3157 1
hold_point_to_string(struct hold_point *hp)
d3183 2
a3184 1
print_hold(struct hold *hp)
d3206 3
a3208 1
f_jhold(int argc, char **argv)
d3227 3
a3229 1
f_jlist(int argc, char **argv)
d3245 2
a3246 1
joint_move(struct joint *jp)
d3382 3
a3384 1
f_jmove(int argc, char **argv)
d3494 2
a3495 1
findjoint(struct db_full_path *pathp)
d3542 5
a3546 1
HIDDEN union tree *mesh_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d3602 5
a3606 1
HIDDEN union tree *mesh_end_region (register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d3652 3
a3654 1
f_jmesh(int argc, char **argv)
@


11.44
log
@Converted from K&R to ANSI C - RFH
@
text
@d57 2
a58 2
void joint_move(struct joint *jp);
void joint_clear(void);
d60 16
a75 16
static int f_jfhelp(int argc, char **argv);
int f_fhelp2(int argc, char **argv, struct funtab *functions);
static int f_jhelp(int argc, char **argv);
int f_help2(int argc, char **argv, struct funtab *functions);
int f_jmesh(int argc, char **argv);
int f_jdebug(int argc, char **argv);
int f_jload(int argc, char **argv);
int f_junload(int argc, char **argv);
int f_jmove(int argc, char **argv);
int f_jlist(int argc, char **argv);
int f_jaccept(int argc, char **argv);
int f_jreject(int argc, char **argv);
int f_jsave(int argc, char **argv);
int f_jhold(int argc, char **argv);
int f_jsolve(int argc, char **argv);
int f_jtest(int argc, char **argv);
d138 5
a142 1
f_joint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d168 3
a170 1
f_jfhelp(int argc, char **argv)
d183 3
a185 1
f_jhelp(int argc, char **argv)
d205 2
a206 1
joint_lookup(char *name)
d216 2
a217 1
free_arc(struct arc *ap)
d235 2
a236 1
free_joint(struct joint *jp)
d244 2
a245 1
free_hold(struct hold *hp)
d272 2
a273 1
hold_clear_flags(struct hold *hp)
d464 3
a466 1
f_junload(int argc, char **argv)
d607 3
a609 1
parse_error(struct bu_vls *str, char *error)
d643 6
a648 1
get_token(union bu_lex_token *token, FILE *fip, struct bu_vls *str, struct bu_lex_key *keys, struct bu_lex_key *syms)
d698 5
a702 1
gobble_token(int type_wanted, int value_wanted, FILE *fip, struct bu_vls *str)
d745 3
a747 1
skip_group(FILE *fip, struct bu_vls *str)
d774 3
a776 1
parse_units(FILE *fip, struct bu_vls *str)
d807 4
a810 1
parse_path(struct arc *ap, FILE *fip, struct bu_vls *str)
d885 4
a888 1
parse_list(struct arc *ap, FILE *fip, struct bu_vls *str)
d947 4
a950 1
parse_ARC(struct arc *ap, FILE *fip, struct bu_vls *str)
d1008 4
a1011 1
parse_double(double *dbl, FILE *fip, struct bu_vls *str)
d1048 4
a1051 1
parse_assign(double *dbl, FILE *fip, struct bu_vls *str)
d1068 4
a1071 1
parse_vect(fastf_t *vect, FILE *fip, struct bu_vls *str)
d1091 5
a1095 1
parse_trans(struct joint *jp, int index, FILE *fip, struct bu_vls *str)
d1253 5
a1257 1
parse_rots(struct joint *jp, int index, FILE *fip, struct bu_vls *str)
d1415 3
a1417 1
parse_joint(FILE *fip, struct bu_vls *str)
d1575 4
a1578 1
parse_jset(struct hold *hp, FILE *fip, struct bu_vls *str)
d1667 4
a1670 1
parse_solid(struct hold_point *pp, FILE *fip, struct bu_vls *str)
d1734 4
a1737 1
parse_point(struct hold_point *pp, FILE *fip, struct bu_vls *str)
d1779 3
a1781 1
parse_hold(FILE *fip, struct bu_vls *str)
d1943 3
a1945 1
f_jload(int argc, char **argv)
d2096 3
a2098 1
f_jtest(int argc, char **argv)
d2103 3
a2105 1
f_jsave(int argc, char **argv)
d2184 3
a2186 1
f_jaccept(int argc, char **argv)
d2221 3
a2223 1
f_jreject(int argc, char **argv)
d2260 3
a2262 1
hold_point_location(fastf_t *loc, struct hold_point *hp)
d2320 2
a2321 1
hold_eval(struct hold *hp)
d2369 1
a2369 1
joint_clear(void)
d2380 4
a2383 1
part_solve(struct hold *hp, double limits, double tol)
d2703 1
a2703 1
reject_move(void)
d2753 4
a2756 1
system_solve(int pri, double delta, double epsilon)
d2957 3
a2959 1
f_jsolve(int argc, char **argv)
d3156 2
a3157 1
hold_point_to_string(struct hold_point *hp)
d3183 2
a3184 1
print_hold(struct hold *hp)
d3206 3
a3208 1
f_jhold(int argc, char **argv)
d3227 3
a3229 1
f_jlist(int argc, char **argv)
d3245 2
a3246 1
joint_move(struct joint *jp)
d3382 3
a3384 1
f_jmove(int argc, char **argv)
d3494 2
a3495 1
findjoint(struct db_full_path *pathp)
d3542 5
a3546 1
HIDDEN union tree *mesh_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d3602 5
a3606 1
HIDDEN union tree *mesh_end_region (register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data)
d3652 3
a3654 1
f_jmesh(int argc, char **argv)
@


11.43
log
@misc compiler warning changes
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.42 2001/06/18 19:24:23 bparker Exp $";
d57 2
a58 2
void joint_move();
void joint_clear();
d60 16
a75 16
static int f_jfhelp();
int f_fhelp2();
static int f_jhelp();
int f_help2();
int f_jmesh();
int f_jdebug();
int f_jload();
int f_junload();
int f_jmove();
int f_jlist();
int f_jaccept();
int f_jreject();
int f_jsave();
int f_jhold();
int f_jsolve();
int f_jtest();
d138 1
a138 5
f_joint(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d164 1
a164 3
f_jfhelp(argc, argv)
int argc;
char **argv;
d177 1
a177 3
f_jhelp(argc, argv)
int argc;
char **argv;
d197 1
a197 2
joint_lookup(name)
char *name;
d207 1
a207 2
free_arc(ap)
struct arc *ap;
d225 1
a225 2
free_joint(jp)
struct joint *jp;
d233 1
a233 2
free_hold(hp)
struct hold *hp;
d260 1
a260 2
hold_clear_flags(hp)
struct hold *hp;
d451 1
a451 3
f_junload(argc, argv)
int argc;
char **argv;
d592 1
a592 3
parse_error(str, error)
struct bu_vls *str;
char *error;
d626 1
a626 6
get_token(token, fip, str, keys, syms)
union bu_lex_token *token;
FILE *fip;
struct bu_vls *str;
struct bu_lex_key *keys;
struct bu_lex_key *syms;
d676 1
a676 5
gobble_token(type_wanted, value_wanted, fip, str)
int type_wanted;
int value_wanted;
FILE *fip;
struct bu_vls *str;
d719 1
a719 3
skip_group(fip, str)
FILE * fip;
struct bu_vls *str;
d746 1
a746 3
parse_units(fip, str)
FILE *fip;
struct bu_vls *str;
d777 1
a777 4
parse_path(ap, fip, str)
struct arc *ap;
FILE *fip;
struct bu_vls *str;
d852 1
a852 4
parse_list(ap, fip, str)
struct arc *ap;
FILE *fip;
struct bu_vls *str;
d911 1
a911 4
parse_ARC(ap, fip, str)
struct arc *ap;
FILE *fip;
struct bu_vls *str;
d969 1
a969 4
parse_double(dbl, fip, str)
double *dbl;
FILE *fip;
struct bu_vls *str;
d1006 1
a1006 4
parse_assign(dbl, fip, str)
double *dbl;
FILE *fip;
struct bu_vls *str;
d1023 1
a1023 4
parse_vect(vect, fip, str)
vect_t vect;
FILE *fip;
struct bu_vls *str;
d1043 1
a1043 5
parse_trans(jp, index, fip, str)
struct joint *jp;
int index;
FILE *fip;
struct bu_vls *str;
d1201 1
a1201 5
parse_rots(jp, index, fip, str)
struct joint *jp;
int index;
FILE *fip;
struct bu_vls *str;
d1359 1
a1359 3
parse_joint(fip, str)
FILE *fip;
struct bu_vls *str;
d1517 1
a1517 4
parse_jset(hp,fip, str)
struct hold *hp;
FILE *fip;
struct bu_vls *str;
d1606 1
a1606 4
parse_solid(pp, fip, str)
struct hold_point *pp;
FILE *fip;
struct bu_vls *str;
d1670 1
a1670 4
parse_point(pp, fip, str)
struct hold_point *pp;
FILE *fip;
struct bu_vls *str;
d1712 1
a1712 3
parse_hold(fip, str)
FILE *fip;
struct bu_vls *str;
d1874 1
a1874 3
f_jload(argc, argv)
int argc;
char **argv;
d2025 1
a2025 3
f_jtest(argc, argv)
int argc;
char **argv;
d2030 1
a2030 3
f_jsave(argc, argv)
int argc;
char **argv;
d2109 1
a2109 3
f_jaccept(argc, argv)
int argc;
char **argv;
d2144 1
a2144 3
f_jreject(argc, argv)
int argc;
char **argv;
d2181 1
a2181 3
hold_point_location(loc, hp)
vect_t loc;
struct hold_point *hp;
d2239 1
a2239 2
hold_eval(hp)
struct hold *hp;
d2287 1
a2287 1
joint_clear()
d2298 1
a2298 4
part_solve(hp, limits, tol)
struct hold *hp;
double limits;
double tol;
d2618 1
a2618 1
reject_move()
d2668 1
a2668 4
system_solve(pri,delta, epsilon)
int pri;
double delta;
double epsilon;
d2869 1
a2869 3
f_jsolve(argc, argv)
int argc;
char **argv;
d3066 1
a3066 2
hold_point_to_string(hp)
struct hold_point *hp;
d3092 1
a3092 2
print_hold(hp)
struct hold *hp;
d3114 1
a3114 3
f_jhold(argc, argv)
int argc;
char **argv;
d3133 1
a3133 3
f_jlist(argc, argv)
int argc;
char **argv;
d3149 1
a3149 2
joint_move(jp)
struct joint *jp;
d3285 1
a3285 3
f_jmove(argc, argv)
int argc;
char **argv;
d3395 1
a3395 2
findjoint(pathp)
struct db_full_path	*pathp;
d3442 1
a3442 5
HIDDEN union tree *mesh_leaf( tsp, pathp, ip, client_data)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d3498 1
a3498 5
HIDDEN union tree *mesh_end_region (tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path		*pathp;
union tree			*curtree;
genptr_t			client_data;
d3544 1
a3544 3
f_jmesh(argc, argv)
int argc;
char **argv;
@


11.42
log
@*- remove use of start/stop_catching_output().
   Use routines that write directly to a vls.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.41 2001/06/01 19:23:22 bparker Exp $";
d45 1
a45 1
static int joint_debug = 0;
@


11.41
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.40 2001/05/16 21:38:08 morrison Exp $";
d116 2
a117 3
f_jdebug(argc, argv)
int argc;
char **argv;
d119 1
a119 1
  struct bu_vls tmp_vls;
d121 1
a121 2
  bu_vls_init(&tmp_vls);
  start_catching_output(&tmp_vls);
d123 8
a130 12
  if (argc >= 2) {
    sscanf( argv[1], "%x", &joint_debug);
  } else {
    bu_printb( "possible flags", 0xffffffffL, JOINT_DEBUG_FORMAT );
    bu_log("\n");
  }
  bu_printb( "joint_debug", joint_debug, JOINT_DEBUG_FORMAT );
  bu_log("\n");

  stop_catching_output(&tmp_vls);
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);
d132 4
a135 1
  return CMD_OK;
@


11.40
log
@PRODUCTION optimizations
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.39 2001/05/08 20:20:58 jra Exp $";
d3680 1
a3680 1
		FOR_ALL_SOLIDS(sp, &HeadSolid.l) {
@


11.39
log
@Added initialization for the AVS structure in db_tree_state
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.38 2001/04/05 19:35:42 morrison Exp $";
a2766 1
	struct hold *test_hold;
d2769 1
@


11.38
log
@updated SIGNED to signed
updated CONST to const
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.37 2001/04/02 21:38:17 morrison Exp $";
d3634 10
@


11.37
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.36 2001/03/31 01:57:19 morrison Exp $";
d3675 1
a3675 1
	i = db_walk_tree(dbip, topc, (CONST char **)topv,
@


11.36
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.35 2000/11/01 21:19:29 mike Exp $";
d3341 1
a3341 1
		bn_mat_copy(m1, ANIM_MAT);
d3370 1
a3370 1
		bn_mat_copy(m1, ANIM_MAT);
d3378 1
a3378 1
	bn_mat_copy(m1, ANIM_MAT);
@


11.35
log
@
lint
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.34 2000/10/24 19:05:04 mike Exp $";
d3308 1
a3308 1
	bn_mat_idn(ANIM_MAT);
d3356 1
a3356 1
		bn_mat_idn(m2);
d3376 1
a3376 1
	bn_mat_idn(m2);
@


11.34
log
@
Fixed compiler lint, function declarations.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.33 2000/10/24 15:34:12 mike Exp $";
d2392 2
a2393 2
	double besteval, bestvalue, origvalue;
	int bestfreedom;
d2971 1
a2971 1
	int result;
d3266 1
a3266 1
		struct directory *dp;
d3503 1
a3503 1
	struct joint *bestjp;
@


11.33
log
@
rt_lex has become bu_lex
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.32 2000/10/24 15:19:27 mike Exp $";
d3655 1
a3655 1
	char			**topv[2000];
@


11.32
log
@
lint
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.31 2000/09/09 04:30:54 mike Exp $";
a38 1
#include "rtlex.h"
d104 1
a104 1
{"test", "file_name", "test use of rtlex routine.",
d530 1
a530 1
static struct rt_lex_key keys[] = {
d562 1
a562 1
static struct rt_lex_key units[] = {
d574 1
a574 1
static struct rt_lex_key lex_solids[] = {
d592 1
a592 1
static struct rt_lex_key syms[] = {
d647 1
a647 1
union rt_lex_token *token;
d650 2
a651 2
struct rt_lex_key *keys;
struct rt_lex_key *syms;
d655 1
a655 1
    used = rt_lex(token, str, keys, syms);
d672 1
a672 1
		case RT_LEX_KEYWORD:
d677 1
a677 1
		case RT_LEX_SYMBOL:
d682 1
a682 1
		case RT_LEX_DOUBLE:
d685 1
a685 1
		case RT_LEX_INT:
d688 1
a688 1
		case RT_LEX_IDENT:
d715 1
a715 1
	union rt_lex_token token;
d725 1
a725 1
	if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
d728 1
a728 1
	case RT_LEX_ANY:
d730 8
a737 8
	case RT_LEX_INT:
		return (token.type == RT_LEX_INT);
	case RT_LEX_DOUBLE:
		return (token.type == RT_LEX_DOUBLE);
	case RT_LEX_NUMBER:
		return (token.type == RT_LEX_INT || token.type == RT_LEX_DOUBLE);
	case RT_LEX_SYMBOL:
		return (token.type == RT_LEX_SYMBOL &&
d739 2
a740 2
	case RT_LEX_KEYWORD:
		return (token.type == RT_LEX_KEYWORD &&
d742 2
a743 2
	case RT_LEX_IDENT:
		return (token.type == RT_LEX_IDENT);
d752 1
a752 1
	union rt_lex_token tok;
d763 2
a764 2
		if (tok.type == RT_LEX_IDENT) bu_free(tok.t_id.value, "unit token");
		if (tok.type != RT_LEX_SYMBOL) continue;
d781 1
a781 1
	union rt_lex_token token;
d787 2
a788 2
	if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
	if (token.type != RT_LEX_KEYWORD) {
d806 1
a806 1
	(void) gobble_token(RT_LEX_SYMBOL, SYM_END, fip,str);
d815 1
a815 1
	union rt_lex_token token;
d825 1
a825 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) return 0;
d831 1
a831 1
		if (get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d836 1
a836 1
		if (token.type != RT_LEX_IDENT) {
d847 1
a847 1
		if (get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d852 2
a853 2
		if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
		if (token.type != RT_LEX_SYMBOL) {
d871 1
a871 1
	if (get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d876 1
a876 1
	if (token.type != RT_LEX_IDENT) {
d881 1
a881 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str)) {
d893 1
a893 1
	union rt_lex_token token;
d904 1
a904 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) return 0;
d910 1
a910 1
		if (get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d915 1
a915 1
		if (token.type != RT_LEX_IDENT) {
d926 1
a926 1
		if (get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d931 2
a932 2
		if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
		if (token.type != RT_LEX_SYMBOL) {
d955 1
a955 1
	union rt_lex_token token;
d965 1
a965 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) return 0;
d971 2
a972 2
	while (get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) != EOF) {
		if (token.type != RT_LEX_IDENT) {
d982 1
a982 1
		if (get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d986 2
a987 2
		if (token.type != RT_LEX_SYMBOL) {
			if (token.type == RT_LEX_IDENT) {
d1016 1
a1016 1
	union rt_lex_token token;
d1028 1
a1028 1
	if (token.type == RT_LEX_SYMBOL && token.t_key.value == SYM_MINUS) {
d1035 1
a1035 1
	if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
d1037 1
a1037 1
	if (token.type == RT_LEX_INT) {
d1039 1
a1039 1
	} else if (token.type == RT_LEX_DOUBLE) {
d1041 1
a1041 1
	} else if (token.type == RT_LEX_KEYWORD && token.t_key.value == KEY_INF) {
d1056 1
a1056 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1064 1
a1064 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str)) {
d1082 1
a1082 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_OP_PT, fip, str)) return 0;
d1086 1
a1086 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_COMMA, fip, str)) return 0;
d1088 1
a1088 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_CL_PT, fip, str)) return 0;
d1100 1
a1100 1
	union rt_lex_token token;
d1109 1
a1109 1
		if (!gobble_token(RT_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0 ;
d1113 1
a1113 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0;
d1116 1
a1116 1
		if (token.type == RT_LEX_IDENT) {
d1119 1
a1119 1
		if (token.type == RT_LEX_SYMBOL && 
d1167 1
a1167 1
		if (token.type != RT_LEX_KEYWORD) {
d1174 1
a1174 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1183 1
a1183 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_COMMA, fip, str)) {
d1192 1
a1192 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_COMMA, fip, str)) {
d1201 1
a1201 1
			(void) gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str);
d1232 1
a1232 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1240 1
a1240 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str)) {
d1262 1
a1262 1
	union rt_lex_token token;
d1271 1
a1271 1
		if (!gobble_token(RT_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0 ;
d1275 1
a1275 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0;
d1278 1
a1278 1
		if (token.type == RT_LEX_IDENT) {
d1281 1
a1281 1
		if (token.type == RT_LEX_SYMBOL && 
d1329 1
a1329 1
		if (token.type != RT_LEX_KEYWORD) {
d1336 1
a1336 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1345 1
a1345 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_COMMA, fip, str)) {
d1354 1
a1354 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_COMMA, fip, str)) {
d1363 1
a1363 1
			(void) gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str);
d1394 1
a1394 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1402 1
a1402 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str)) {
d1422 1
a1422 1
	union rt_lex_token token;
d1438 1
a1438 1
	if (get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d1444 1
a1444 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) {
d1462 1
a1462 1
		if (token.type == RT_LEX_SYMBOL &&
d1497 1
a1497 1
		    	gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str);
d1500 1
a1500 1
		if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
d1502 1
a1502 1
		if (token.type != RT_LEX_KEYWORD) {
d1535 1
a1535 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1545 1
a1545 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str)) {
d1583 1
a1583 1
	union rt_lex_token token;
d1590 1
a1590 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0;
d1597 2
a1598 2
		if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
		if (token.type == RT_LEX_SYMBOL && token.t_key.value == SYM_CL_GROUP) {
d1609 1
a1609 1
		if (token.type != RT_LEX_KEYWORD) {
d1615 1
a1615 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1623 1
a1623 1
			if (token.type != RT_LEX_IDENT) {
d1629 1
a1629 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_END, fip,str)) {
d1675 1
a1675 1
	union rt_lex_token token;
d1683 1
a1683 1
	if (!gobble_token(RT_LEX_SYMBOL, SYM_OP_GROUP, fip, str)) return 0;
d1690 2
a1691 2
		if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
		if (token.type == RT_LEX_SYMBOL && token.t_key.value == SYM_CL_GROUP) {
d1703 1
a1703 1
		if (token.type != RT_LEX_KEYWORD) {
d1742 1
a1742 1
	union rt_lex_token token;
d1748 2
a1749 2
	if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
	if (token.type != RT_LEX_KEYWORD) {
d1757 1
a1757 1
		return gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str);
d1787 1
a1787 1
	union rt_lex_token token;
d1810 1
a1810 1
	if ( get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d1815 1
a1815 1
	if (token.type == RT_LEX_IDENT) {
d1817 1
a1817 1
		if ( get_token(&token, fip, str, (struct rt_lex_key *)NULL, syms) == EOF) {
d1823 2
a1824 2
	if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
	if (token.type != RT_LEX_SYMBOL || token.t_key.value != SYM_OP_GROUP) {
d1836 1
a1836 1
		if (token.type == RT_LEX_IDENT) bu_free(token.t_id.value, "unit token");
d1838 1
a1838 1
		if (token.type == RT_LEX_SYMBOL && token.t_key.value == SYM_CL_GROUP) {
d1869 1
a1869 1
			gobble_token(RT_LEX_SYMBOL, SYM_END, fip, str);
d1872 1
a1872 1
		if (token.type != RT_LEX_KEYWORD) {
d1912 1
a1912 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1925 1
a1925 1
			if (!gobble_token(RT_LEX_SYMBOL, SYM_EQ, fip, str)) {
d1952 1
a1952 1
	union rt_lex_token token;
d1998 1
a1998 1
			if (token.type == RT_LEX_KEYWORD) {
d2014 1
a2014 1
			if (token.type == RT_LEX_IDENT) {
@


11.31
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.30 2000/09/08 05:55:47 mike Exp $";
d79 32
a110 32
"joint ", "", "Joint command table",
	0, 0, 0, FALSE,
"?", "[commands]", "summary of available joint commands",
	f_jfhelp, 0, MAXARGS, FALSE,
"accept", "[joints]", "accept a series of moves",
	f_jaccept, 1, MAXARGS, FALSE,
"debug", "[hex code]", "Show/set debuging bit vector for joints",
	f_jdebug, 1, 2, FALSE,
"help", "[commands]", "give usage message for given joint commands",
	f_jhelp, 0, MAXARGS, FALSE,
"holds","[names]", "list constraints",
	f_jhold, 1, MAXARGS, FALSE,
"list", "[names]", "list joints.",
	f_jlist, 1, MAXARGS, FALSE,
"load", "file_name", "load a joint/constraint file",
	f_jload, 2, MAXARGS, FALSE,
"mesh", "", "Build the grip mesh",
	f_jmesh, 0, 1, FALSE,
"move", "joint_name p1 [p2...p6]", "Manual adjust a joint",
	f_jmove, 3, 8, FALSE,
"reject", "[joint_names]", "reject joint motions",
	f_jreject, 1, MAXARGS, FALSE,
"save",	"file_name", "Save joints and constraints to disk",
	f_jsave, 2, 2, FALSE,
"solve", "constraint", "Solve a or all constraints",
	f_jsolve, 1, MAXARGS, FALSE,
"test", "file_name", "test use of rtlex routine.",
	f_jtest, 2, 2, FALSE,
"unload", "", "Unload any joint/constrants that have been loaded",
	f_junload, 1,1, FALSE,
0, 0, 0,
	0,0,0, FALSE
@


11.30
log
@
Tree routines now need resource structure.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.29 2000/08/19 03:10:10 mike Exp $";
d2283 1
a2283 1
			db_path_to_mat(dbip, &hp->path, mat, hp->path.fp_len-2);
d2298 1
a2298 1
		db_path_to_mat(dbip, &hp->path, mat, hp->path.fp_len-2);
d2302 1
a2302 1
		db_path_to_mat(dbip, &hp->path, mat, hp->path.fp_len-3);
d3615 1
d3634 10
@


11.29
log
@
Reduced use of MAXARGS
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.28 2000/06/29 18:57:07 mike Exp $";
d2288 1
a2288 1
		if( rt_db_get_internal( &intern, hp->path.fp_names[hp->path.fp_len-1], dbip, NULL ) < 0 )
d2296 1
a2296 1
		rt_db_free_internal( &intern );
@


11.28
log
@
Applied dp variable
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.27 2000/06/28 17:03:33 mike Exp $";
a77 10
#if 0
static struct funtab {
	char *ft_name;
	char *ft_parms;
	char *ft_comment;
	int (*ft_func)MGED_ARGS((int, char **));
	int  ft_min;
	int  ft_max;
} joint_tab[] = {
#else
a78 1
#endif
d150 1
a150 1
  if(argc < 1 || MAXARGS < argc){
a2271 1
	int id;
d2383 1
a3618 1
#if __STDC__
a3619 1
#endif
d3621 1
a3621 1
		1.0, 0.0, 0.0,	/* color, RGB */
a3626 1
#if __STDC__
a3627 1
#endif
d3629 1
a3629 1
	1.0, 0.0, 0.0, 0.0,
d3632 1
a3632 1
	0.0, 0.0, 0.0, 1.0,
@


11.27
log
@
Modified to use rt_db_get_internal().
Eliminated stray reference to es_ext
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.26 2000/06/28 16:11:06 mike Exp $";
d3597 1
a3597 1
	newGrip->dir = pathp->fp_names[pathp->fp_len-1];
@


11.26
log
@
db_walk_tree() leaf method calling sequence changed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.25 2000/05/16 20:31:43 cjohnson Exp $";
d2282 1
a2282 2
	struct bu_external	es_ext;
	struct rt_db_internal	es_int;
d2299 2
a2300 9
		bn_mat_idn(mat);
		BU_INIT_EXTERNAL(&es_ext);
		RT_INIT_DB_INTERNAL(&es_int);
		if (db_get_external( &es_ext,
		    hp->path.fp_names[hp->path.fp_len-1], dbip) < 0) return 0;
		id = rt_id_solid( &es_ext);
		if (id != ID_GRIP) return 0;
		if (rt_functab[id].ft_import( &es_int, &es_ext, mat, dbip) < 0) {
			db_free_external(&es_ext);
d2302 4
a2305 3
		}
		RT_CK_DB_INTERNAL(&es_int);
		gip = (struct rt_grip_internal *)es_int.idb_ptr;
d2308 2
a2309 2
		rt_functab[id].ft_ifree( &es_int);
		db_free_external(&es_ext);
@


11.25
log
@Update the tree walker in animedit to use new flags.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.24 2000/01/07 04:21:18 mike Exp $";
d3564 1
a3564 1
HIDDEN union tree *mesh_leaf( tsp, pathp, ep, id, client_data)
d3567 1
a3567 2
struct bu_external	*ep;
int			id;
a3569 1
	struct	rt_db_internal	internal;
d3577 2
d3580 1
a3580 1
	if (id != ID_GRIP) {
d3592 1
a3592 7
	RT_INIT_DB_INTERNAL(&internal);
	if ( rt_functab[id].ft_import( &internal, ep, tsp->ts_mat, dbip) < 0 ) {
	  Tcl_AppendResult(interp, dp->d_namep, ": solid import failure\n", (char *)NULL);
	  if (internal.idb_ptr) rt_functab[id].ft_ifree(&internal);
	  return curtree;
	}
	gip = (struct rt_grip_internal *) internal.idb_ptr;
a3599 2
	rt_functab[id].ft_ifree(&internal);

@


11.24
log
@
Eliminated dbi_localunit.  This is a v4 database anachronism.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.23 2000/01/04 17:58:21 bparker Exp $";
a3578 2
	BU_GETUNION(curtree, tree);
	curtree->tr_op = OP_SOLID;
d3581 1
a3581 1
		return curtree;
d3583 5
@


11.23
log
@*- add client_data to db_walk_tree
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.22 1999/09/01 18:55:08 bparker Exp $";
d2144 3
a2146 22
	switch (dbip->dbi_localunit) {
	case ID_UM_UNIT:
		fputs("units um;\n",fop); break;
	case ID_CM_UNIT:
		fputs("units cm;\n",fop); break;
	case ID_M_UNIT:
		fputs("units meters;\n",fop); break;
	case ID_KM_UNIT:
		fputs("units km;\n",fop); break;
	case ID_IN_UNIT:
		fputs("units inches;\n",fop); break;
	case ID_FT_UNIT:
		fputs("units feet;\n",fop); break;
	case ID_YD_UNIT:
		fputs("units yards;\n",fop); break;
	case ID_MI_UNIT:
		fputs("units miles;\n",fop); break;
	case ID_NO_UNIT:
	case ID_MM_UNIT:
	default:
		fputs("units mm;\n",fop);
	}
@


11.22
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.21 1998/12/17 04:19:11 mike Exp $";
d3583 1
a3583 1
HIDDEN union tree *mesh_leaf( tsp, pathp, ep, id)
d3588 1
d3648 1
a3648 1
HIDDEN union tree *mesh_end_region (tsp, pathp, curtree )
d3652 1
d3716 2
a3717 1
	    mesh_leaf);		/* node */
@


11.21
log
@Regions now have an associated temperature
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/animedit.c,v 11.20 1998/03/19 15:55:50 jra Exp $";
d487 1
a487 2
	if(dbip == DBI_NULL)
	  return CMD_OK;
d1970 1
a1970 2
	if(dbip == DBI_NULL)
	  return CMD_OK;
d2126 1
a2126 2
	if(dbip == DBI_NULL)
	  return CMD_OK;
@


11.20
log
@Changed rt_import and ft_export calls to new calling sequence.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.19 1997/08/22 22:38:22 mike Exp jra $";
d3667 1
@


11.19
log
@Made use of bu_getopt() explicit, rather than depending on
#define in bu.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.18 1997/07/01 22:09:08 bparker Exp mike $";
d2329 1
a2329 1
		if (rt_functab[id].ft_import( &es_int, &es_ext, mat) < 0) {
d3611 1
a3611 1
	if ( rt_functab[id].ft_import( &internal, ep, tsp->ts_mat) < 0 ) {
@


11.18
log
@mods to run without a database
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.17 1997/06/03 16:03:59 pjt Exp bparker $";
d1974 2
a1975 2
	optind = 1;
	while ((c=getopt(argc,argv,"uam")) != EOF ) {
d1985 2
a1986 2
	argv += optind;
	argc -= optind;
d2230 2
a2231 2
	optind=1;
	while ( (c=getopt(argc,argv, "m")) != EOF) {
d2239 2
a2240 2
	argc -= optind;
	argv += optind;
d2267 2
a2268 2
	optind=1;
	while ( (c=getopt(argc,argv, "m")) != EOF) {
d2276 2
a2277 2
	argc -= optind;
	argv += optind;
d3040 1
a3040 1
	 * reset getopt.
d3042 2
a3043 2
	optind=1;
	while ((count=getopt(argc,argv,"l:e:d:m")) != EOF) {
d3045 3
a3047 3
		case 'l': loops = atoi(optarg);break;
		case 'e': epsilon = atof(optarg);break;
		case 'd': delta =  atof(optarg);break;
d3053 1
a3053 1
	 * skip the command and any options that getopt ate.
d3055 2
a3056 2
	argc -= optind;
	argv += optind;
@


11.17
log
@Added units um, km, yd, mi, and other minor improvements
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.16 1997/04/24 18:03:58 bparker Exp $";
d487 3
d1971 3
d2128 3
d2308 3
d3298 3
d3434 3
d3693 3
@


11.16
log
@modify calls to Tcl_Eval
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.15 1997/04/16 20:23:49 bparker Exp bparker $";
d2139 2
d2145 2
d2151 4
@


11.15
log
@mods so that commands check args internally
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.14 1997/03/12 20:45:46 jra Exp bparker $";
d162 6
a167 1
    Tcl_Eval(interp, "help joint");
@


11.14
log
@removed dependencies on db.h.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.13 1997/01/29 05:35:44 mike Exp jra $";
d161 2
a162 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d164 1
@


11.13
log
@Notes on header files.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.12 1997/01/02 19:35:05 bparker Exp mike $";
a36 1
#include "db.h"		/* for ID_CM_UNIT, etc. */
d3635 3
a3637 3
		DB_INH_LOWER,	/* color inherit */
		DB_INH_LOWER,	/* mater inherit */
		""		/* shader */
@


11.12
log
@mods to use libbn and libbu
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.11 1996/12/04 03:39:35 mike Exp bparker $";
d37 1
a37 1
#include "db.h"
a42 2
#include "./sedit.h"	/* ??? */
#include "./mged_dm.h"	/* ??? */
@


11.11
log
@Changed ma_matparm stuff to ma_shader
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.10 1996/10/04 14:56:10 bparker Exp mike $";
d36 1
d2283 1
a2283 1
	struct rt_external	es_ext;
d2298 2
a2299 2
		mat_idn(mat);
		RT_INIT_EXTERNAL(&es_ext);
d3322 1
a3322 1
	mat_idn(ANIM_MAT);
d3333 1
a3333 1
		tmp = (jp->rots[i].current * rt_degtorad)/2.0;
d3340 1
a3340 1
				tmp*2*rt_radtodeg, q1[X], q1[Y], q1[Z]);
d3355 2
a3356 2
		mat_copy(m1, ANIM_MAT);
		mat_mul(ANIM_MAT, m2, m1);
d3370 1
a3370 1
		mat_idn(m2);
d3384 2
a3385 2
		mat_copy(m1, ANIM_MAT);
		mat_mul(ANIM_MAT, m2, m1);
d3390 1
a3390 1
	mat_idn(m2);
d3392 2
a3393 2
	mat_copy(m1, ANIM_MAT);
	mat_mul(ANIM_MAT,m2,m1);
d3395 1
a3395 1
		mat_print("joint move: ANIM_MAT", ANIM_MAT);
d3559 1
a3559 1
struct rt_external	*ep;
@


11.10
log
@-call vls_col_XXXX functions instead of col_XXXX.
-cast bu_free's 1st argument to genptr_t.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.9 1996/09/25 20:16:42 bparker Exp bparker $";
d3639 1
a3639 2
		"",		/* material name */
		""		/* material params */
@


11.9
log
@now using more generalized solid macros
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.8 1996/09/23 18:40:01 bparker Exp bparker $";
d232 1
a232 1
		bu_free(ap->arc[i], "arc entry");
d234 1
a234 1
	bu_free((char *)ap->arc, "arc table");
d238 1
a238 1
			bu_free(ap->original[i], "arc entry");
d240 1
a240 1
		bu_free((char *)ap->original, "arc table");
d249 2
a250 2
	if (jp->name) bu_free(jp->name, "joint name");
	bu_free((char *)jp, "joint structure");
d275 1
a275 1
		bu_free((char *) jh, "joint handle");
d277 3
a279 3
	if (hp->joint) bu_free(hp->joint, "hold joint name");
	if (hp->name) bu_free(hp->name, "hold name");
	bu_free((char *)hp, "hold struct");
d369 1
a369 1
		    bu_free(arc[i], "arc entry");
d371 1
a371 1
		  bu_free((char *) arc, "arc table");
d380 1
a380 1
			bu_free(arc[i], "arc entry");
d382 1
a382 1
		bu_free((char *) arc, "arc table");
d427 1
a427 1
				bu_free(arc[i], "arc entry");
d429 1
a429 1
			bu_free((char *) arc, "arc table");
d438 1
a438 1
			bu_free(arc[i], "arc entry");
d440 1
a440 1
		bu_free((char *) arc, "arc table");
d2394 1
a2394 1
		bu_free((char *)ssp, "struct stack_solve");
d2742 1
a2742 1
	bu_free((char *)ssp, "struct solve_stack");
d3073 1
a3073 1
	bu_free((char *)myargv,"param pointers");
d3250 12
a3261 6
	register struct joint *jp;
	for (BU_LIST_FOR(jp, joint, &joint_head)) {
		col_item(jp->name);
	}
	col_eol();
	return CMD_OK;
d3294 1
a3294 1
				bu_free((char *)anp, "struct animate");
d3719 1
a3719 1
			bu_free((char *)gp,"artic_grip");
d3722 1
a3722 1
		bu_free((char *)jp, "Artic Joint");
@


11.8
log
@changed dm.h to mged_dm.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.7 1996/09/03 20:02:37 bparker Exp bparker $";
d41 1
a41 1
#include "./solid.h"
d3667 1
a3667 1
		FOR_ALL_SOLIDS(sp) {
@


11.7
log
@rt_list ---> bu_list
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.6 1996/08/27 20:30:05 bparker Exp bparker $";
d43 1
a43 1
#include "./dm.h"	/* ??? */
@


11.6
log
@now using libbu
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.5 1996/08/22 20:54:17 bparker Exp bparker $";
d34 1
a36 1
#include "rtstring.h"
d206 2
a207 2
struct rt_list joint_head = {
	RT_LIST_HEAD_MAGIC,
d210 2
a211 2
struct rt_list hold_head = {
	RT_LIST_HEAD_MAGIC,
d220 1
a220 1
	for (RT_LIST_FOR(jp, joint, &joint_head)) {
d272 1
a272 1
	while (RT_LIST_WHILE(jh, jointH, &hp->j_head)) {
d274 1
a274 1
		RT_LIST_DEQUEUE(&jh->l);
d484 1
a484 1
	while (RT_LIST_WHILE(hp, hold, &hold_head)) {
d486 1
a486 1
		RT_LIST_DEQUEUE(&hp->l);
d490 1
a490 1
	while (RT_LIST_WHILE(jp, joint, &joint_head)) {
d492 1
a492 1
		RT_LIST_DEQUEUE(&(jp->l));
d1501 1
a1501 1
		    	RT_LIST_INSERT(&joint_head, &(jp->l));
d1802 1
a1802 1
	RT_LIST_INIT(&hp->j_head);
d1872 1
a1872 1
			RT_LIST_INSERT(&hold_head, &(hp->l));
d1949 1
a1949 1
static struct rt_list path_head;
d2004 1
a2004 1
						jp = RT_LIST_LAST(joint, &joint_head);
d2030 2
a2031 2
	RT_LIST_INIT(&path_head);
	for (RT_LIST_FOR(jp, joint, &joint_head)) {
d2033 1
a2033 1
			RT_LIST_INSERT(&path_head, &(jp->path.l));
d2036 1
a2036 1
	for (RT_LIST_FOR(hp, hold, &hold_head)) {
d2038 1
a2038 1
			RT_LIST_INSERT(&path_head, &(hp->j_set.path.l));
d2041 1
a2041 1
			RT_LIST_INSERT(&path_head, &(hp->effector.arc.l));
d2044 1
a2044 1
			RT_LIST_INSERT(&path_head, &(hp->objective.arc.l));
d2057 1
a2057 1
	for (RT_LIST_FOR(hp, hold, &hold_head)) {
d2150 1
a2150 1
	for (RT_LIST_FOR(jp, joint, &joint_head)) {
d2220 1
a2220 1
	for (RT_LIST_FOR(jp, joint, &joint_head)) {
d2257 1
a2257 1
	for (RT_LIST_FOR(jp, joint, &joint_head)) {
d2375 1
a2375 1
	struct rt_list	l;
d2382 2
a2383 2
struct rt_list solve_head = {
	RT_LIST_HEAD_MAGIC,
d2392 1
a2392 1
	RT_LIST_POP(stack_solve, &solve_head, ssp);
d2395 1
a2395 1
		RT_LIST_POP(stack_solve, &solve_head, ssp);
d2418 1
a2418 1
	if (RT_LIST_IS_EMPTY(&hp->j_head)) {
d2426 1
a2426 1
		for(RT_LIST_FOR(jp,joint,&joint_head)) {
d2436 1
a2436 1
						RT_LIST_APPEND(&hp->j_head, &jh->l);
d2463 1
a2463 1
				RT_LIST_APPEND(&hp->j_head, &jh->l);
d2473 1
a2473 1
		for (RT_LIST_FOR(jh, jointH, &hp->j_head)) {
d2486 1
a2486 1
				RT_LIST_DEQUEUE(&jh->l);
d2510 1
a2510 1
	for (RT_LIST_FOR(jh, jointH, &hp->j_head)) {
d2711 1
a2711 1
		RT_LIST_PUSH(&solve_head,ssp);
d2725 1
a2725 1
	RT_LIST_POP(solve_stack, &solve_head, ssp);
d2790 1
a2790 1
	for (RT_LIST_FOR(hp,hold,&hold_head)) {
d2819 2
a2820 2
		     	RT_LIST_DEQUEUE(&tmp->l);
		     	RT_LIST_INSERT(&hp->l,&tmp->l);
d2839 1
a2839 1
	for (RT_LIST_FOR(hp,hold,&hold_head)) {
d2865 1
a2865 1
	for (RT_LIST_FOR(hp,hold,&hold_head)) {
d2891 1
a2891 1
		for (RT_LIST_FOR(jh,jointH, &test_hold->j_head)) {
d2921 1
a2921 1
	for (RT_LIST_FOR(hp, hold, &hold_head)) {
d2937 1
a2937 1
		for (RT_LIST_FOR(jh, jointH, &test_hold->j_head)) {
d3033 1
a3033 1
	for (RT_LIST_FOR(hp, hold, &hold_head)) hold_clear_flags(hp);
d3037 1
a3037 1
	  for(RT_LIST_FOR(hp,hold,&hold_head)) {
d3087 1
a3087 1
		for (RT_LIST_FOR(hp,hold,&hold_head)) {
d3091 1
a3091 1
			for (RT_LIST_FOR(jh, jointH, &hp->j_head)) {
d3122 1
a3122 1
			for (RT_LIST_FOR(hp,hold,&hold_head)) {
d3126 1
a3126 1
				for (RT_LIST_FOR(jh, jointH, &hp->j_head)) {
d3232 1
a3232 1
	for (RT_LIST_FOR(hp, hold, &hold_head)) {
d3251 1
a3251 1
	for (RT_LIST_FOR(jp, joint, &joint_head)) {
d3483 1
a3483 1
	struct rt_list	l;
d3489 2
a3490 2
	struct rt_list	l;
	struct rt_list	head;
d3495 2
a3496 2
struct rt_list artic_head = {
	RT_LIST_HEAD_MAGIC,
d3517 1
a3517 1
	for (RT_LIST_FOR(jp, joint, &joint_head)) {
d3594 1
a3594 1
	for (RT_LIST_FOR(newJoint, artic_joints, &artic_head)) {
d3596 1
a3596 1
			RT_LIST_APPEND(&newJoint->head, &(newGrip->l));
d3607 3
a3609 3
	RT_LIST_INIT(&newJoint->head);
	RT_LIST_APPEND(&artic_head, &(newJoint->l));
	RT_LIST_APPEND(&newJoint->head, &(newGrip->l));
d3651 1
a3651 1
	register struct rt_list *vhead;
d3686 1
a3686 1
	for (RT_LIST_FOR(jp, artic_joints, &artic_head)) {
d3688 1
a3688 1
		for (RT_LIST_FOR(gp, artic_grips, &jp->head)){
d3690 3
a3692 3
			for (gpp=RT_LIST_NEXT(artic_grips, &(gp->l));
			    RT_LIST_NOT_HEAD(gpp, &(jp->head));
			    gpp=RT_LIST_NEXT(artic_grips, &(gpp->l))) {
d3710 3
a3712 3
	while (RT_LIST_WHILE(jp, artic_joints, &artic_head)) {
		while (RT_LIST_WHILE(gp, artic_grips, &jp->head)) {
			RT_LIST_DEQUEUE(&gp->l);
d3715 1
a3715 1
		RT_LIST_DEQUEUE(&jp->l);
@


11.5
log
@cast NULL to (struct rt_lex_key *) all over the place
to make compiler happy.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.4 1996/04/18 20:28:43 bparker Exp bparker $";
d134 1
a134 1
  struct rt_vls tmp_vls;
d136 1
a136 1
  rt_vls_init(&tmp_vls);
d142 2
a143 2
    rt_printb( "possible flags", 0xffffffffL, JOINT_DEBUG_FORMAT );
    rt_log("\n");
d145 2
a146 2
  rt_printb( "joint_debug", joint_debug, JOINT_DEBUG_FORMAT );
  rt_log("\n");
d149 2
a150 2
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
d232 1
a232 1
		rt_free(ap->arc[i], "arc entry");
d234 1
a234 1
	rt_free((char *)ap->arc, "arc table");
d238 1
a238 1
			rt_free(ap->original[i], "arc entry");
d240 1
a240 1
		rt_free((char *)ap->original, "arc table");
d249 2
a250 2
	if (jp->name) rt_free(jp->name, "joint name");
	rt_free((char *)jp, "joint structure");
d275 1
a275 1
		rt_free((char *) jh, "joint handle");
d277 3
a279 3
	if (hp->joint) rt_free(hp->joint, "hold joint name");
	if (hp->name) rt_free(hp->name, "hold name");
	rt_free((char *)hp, "hold struct");
d334 1
a334 1
		  struct rt_vls tmp_vls;
d336 2
a337 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "joint load point: (%g %g %g)\n", pp->point[X],
d339 2
a340 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d358 1
a358 1
		    rt_malloc(sizeof(struct directory **)*pp->path.fp_maxlen,
d369 1
a369 1
		    rt_free(arc[i], "arc entry");
d371 1
a371 1
		  rt_free((char *) arc, "arc table");
d380 1
a380 1
			rt_free(arc[i], "arc entry");
d382 1
a382 1
		rt_free((char *) arc, "arc table");
d399 1
a399 1
		    rt_malloc(sizeof(struct directory **)*pp->path.fp_maxlen,
d427 1
a427 1
				rt_free(arc[i], "arc entry");
d429 1
a429 1
			rt_free((char *) arc, "arc table");
d438 1
a438 1
			rt_free(arc[i], "arc entry");
d440 1
a440 1
		rt_free((char *) arc, "arc table");
d444 1
a444 1
	    struct rt_vls tmp_vls;
d446 2
a447 2
	    rt_vls_init(&tmp_vls);
	    rt_vls_printf(&tmp_vls, "joint load constrain: Bad type (%d) for %s.\n",
d449 2
a450 2
	    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	    rt_vls_free(&tmp_vls);
d500 1
a500 1
	  struct rt_vls tmp_vls;
d502 2
a503 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "joint unload: unloaded %d joints, %d constraints.\n",
d505 2
a506 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d616 1
a616 1
struct rt_vls *str;
d623 1
a623 1
	  struct rt_vls tmp_vls;
d625 4
a628 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "%s:%d %s\n",lex_name, lex_line,error);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d631 1
a631 1
	text = rt_malloc(str->vls_offset+2, "error pointer");
d639 1
a639 1
	  struct rt_vls tmp_vls;
d641 4
a644 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "%s:%d %s\n%s\n%s\n",lex_name, lex_line,error,str->vls_str,text);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d647 1
a647 1
	rt_free(text, "error pointer");
d654 1
a654 1
struct rt_vls *str;
d662 1
a662 1
    rt_vls_free(str);
d664 1
a664 1
    used = rt_vls_gets(str,fip);
d668 1
a668 1
  rt_vls_nibble(str, used);
d671 1
a671 1
    struct rt_vls tmp_vls;
d673 1
a673 1
    rt_vls_init(&tmp_vls);
d679 1
a679 1
			rt_vls_printf(&tmp_vls,"lex: key(%d)='%s'\n", token->t_key.value,
d684 1
a684 1
			rt_vls_printf(&tmp_vls,"lex: symbol(%d)='%c'\n", token->t_key.value,
d688 1
a688 1
			rt_vls_printf(&tmp_vls,"lex: double(%g)\n", token->t_dbl.value);
d691 1
a691 1
			rt_vls_printf(&tmp_vls,"lex: int(%d)\n", token->t_int.value);
d694 1
a694 1
			rt_vls_printf(&tmp_vls,"lex: id(%s)\n", token->t_id.value);
d699 2
a700 2
    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
    rt_vls_free(&tmp_vls);
d710 1
a710 1
struct rt_vls *str;
d730 1
a730 1
	if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d755 1
a755 1
struct rt_vls *str;
d768 1
a768 1
		if (tok.type == RT_LEX_IDENT) rt_free(tok.t_id.value, "unit token");
d784 1
a784 1
struct rt_vls *str;
d792 1
a792 1
	if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d818 1
a818 1
struct rt_vls *str;
d832 1
a832 1
	ap->arc = (char **)rt_malloc(sizeof(char *)*max, "arc table");
d848 1
a848 1
			ap->arc = (char **) rt_realloc((char *) ap->arc,
d857 1
a857 1
		if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d896 1
a896 1
struct rt_vls *str;
d911 1
a911 1
	ap->arc = (char **)rt_malloc(sizeof(char *)*max, "arc table");
d927 1
a927 1
			ap->arc = (char **) rt_realloc((char *) ap->arc,
d936 1
a936 1
		if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d958 1
a958 1
struct rt_vls *str;
d972 1
a972 1
	ap->arc = (char **) rt_malloc(sizeof(char *)*max, "arc table");
d983 1
a983 1
			ap->arc = (char **) rt_realloc((char *)ap->arc,
d993 1
a993 1
				rt_free(token.t_id.value, "unit token");
d1019 1
a1019 1
struct rt_vls *str;
d1040 1
a1040 1
	if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d1059 1
a1059 1
struct rt_vls *str;
d1079 1
a1079 1
struct rt_vls *str;
d1103 1
a1103 1
struct rt_vls *str;
d1122 1
a1122 1
			rt_free(token.t_id.value, "unit token");
d1265 1
a1265 1
struct rt_vls *str;
d1284 1
a1284 1
			rt_free(token.t_id.value, "unit token");
d1425 1
a1425 1
struct rt_vls *str;
d1437 1
a1437 1
	GETSTRUCT(jp, joint);
d1505 1
a1505 1
		if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d1586 1
a1586 1
struct rt_vls *str;
d1602 1
a1602 1
		if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d1678 1
a1678 1
struct rt_vls *str;
d1695 1
a1695 1
		if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d1745 1
a1745 1
struct rt_vls *str;
d1753 1
a1753 1
	if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d1789 1
a1789 1
struct rt_vls *str;
d1798 1
a1798 1
	GETSTRUCT(hp, hold);
d1828 1
a1828 1
	if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d1841 1
a1841 1
		if (token.type == RT_LEX_IDENT) rt_free(token.t_id.value, "unit token");
d1956 1
a1956 1
	struct rt_vls	*instring;
d1981 2
a1982 2
	GETSTRUCT(instring,rt_vls);
	rt_vls_init(instring);
d2018 1
a2018 1
				rt_free(token.t_id.value, "unit token");
d2066 1
a2066 1
			    rt_malloc(sizeof(struct directory **) * hp->effector.path.fp_maxlen,
d2084 1
a2084 1
			    rt_malloc(sizeof(struct directory **) * hp->objective.path.fp_maxlen,
d2328 1
a2328 1
		  /* rt_bomb(); */
d2365 1
a2365 1
	  struct rt_vls tmp_vls;
d2367 4
a2370 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "hold_eval: PT->PT of %s is %g\n", hp->name, value);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d2394 1
a2394 1
		rt_free((char *)ssp, "struct stack_solve");
d2430 1
a2430 1
						GETSTRUCT(jh, jointH);
d2457 1
a2457 1
				GETSTRUCT(jh, jointH);
d2495 1
a2495 1
		  struct rt_vls tmp_vls;
d2497 2
a2498 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "part_solve: solved, original(%g) < tol(%g)\n",
d2500 2
a2501 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d2578 1
a2578 1
				  struct rt_vls tmp_vls;
d2580 2
a2581 2
				  rt_vls_init(&tmp_vls);
				  rt_vls_printf(&tmp_vls, "part_solve: NEW min %s(%d,%g) %g <%g\n",
d2583 2
a2584 2
				  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
				  rt_vls_free(&tmp_vls);
d2591 1
a2591 1
			  struct rt_vls tmp_vls;
d2593 2
a2594 2
			  rt_vls_init(&tmp_vls);
			  rt_vls_printf(&tmp_vls, "part_solve: OLD min %s(%d,%g)%g >= %g\n",
d2596 2
a2597 2
			  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			  rt_vls_free(&tmp_vls);
d2664 1
a2664 1
				  struct rt_vls tmp_vls;
d2666 2
a2667 2
				  rt_vls_init(&tmp_vls);
				  rt_vls_printf(&tmp_vls, "part_solve: NEW min %s(%d,%g) %g <%g delta=%g\n",
d2669 2
a2670 2
				  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
				  rt_vls_free(&tmp_vls);
d2677 1
a2677 1
			  struct rt_vls tmp_vls;
d2679 2
a2680 2
			  rt_vls_init(&tmp_vls);
			  rt_vls_printf(&tmp_vls, "part_solve: OLD min %s(%d,%g)%g >= %g\n",
d2682 2
a2683 2
			  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			  rt_vls_free(&tmp_vls);
d2705 1
a2705 1
		GETSTRUCT(ssp, solve_stack);
d2728 1
a2728 1
	  struct rt_vls tmp_vls;
d2730 2
a2731 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "reject_move: rejecting %s(%d,%g)->%g\n", ssp->jp->name,
d2733 2
a2734 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d2742 1
a2742 1
	rt_free((char *)ssp, "struct solve_stack");
d2798 1
a2798 1
			  struct rt_vls tmp_vls;
d2800 2
a2801 2
			  rt_vls_init(&tmp_vls);
			  rt_vls_printf(&tmp_vls, "system_solve: priority %d has system weight of %g.\n",
d2803 2
a2804 2
			  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			  rt_vls_free(&tmp_vls);
d2870 1
a2870 1
	  struct rt_vls tmp_vls;
d2872 2
a2873 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "system_solve: old eval = %g, new eval = %g\n",
d2875 2
a2876 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d2955 1
a2955 1
	  struct rt_vls tmp_vls;
d2957 2
a2958 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "system_solve: new_weights[%d] = %g, returning ", pri,
d2960 2
a2961 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d2995 1
a2995 1
	myargv = (char **)rt_malloc(sizeof(char *)*argc, "param pointers");
d2998 1
a2998 1
		myargv[count] = (char *)rt_malloc(strlen(argv[count])+1,"param");
d3050 1
a3050 1
		struct rt_vls tmp_vls;
d3052 2
a3053 2
		rt_vls_init(&tmp_vls);
		rt_vls_printf(&tmp_vls, "joint solve: finished %d loops of %s.\n", 
d3055 2
a3056 2
		Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		rt_vls_free(&tmp_vls);
d3071 1
a3071 1
		rt_free(myargv[count],"params");
d3073 1
a3073 1
	rt_free((char *)myargv,"param pointers");
d3101 1
a3101 1
			  struct rt_vls tmp_vls;
d3103 2
a3104 2
			  rt_vls_init(&tmp_vls);
			  rt_vls_printf(&tmp_vls, "joint solve: spliting delta (%g)\n",
d3106 2
a3107 2
			  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			  rt_vls_free(&tmp_vls);
d3136 1
a3136 1
				  struct rt_vls tmp_vls;
d3138 2
a3139 2
				  rt_vls_init(&tmp_vls);
				  rt_vls_printf(&tmp_vls, "joint solve: spliting delta (%g)\n",
d3141 2
a3142 2
				  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
				                            rt_vls_free(&tmp_vls);
d3157 1
a3157 1
	  struct rt_vls tmp_vls;
d3159 2
a3160 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "joint solve: system has not converged in %d loops.\n",
d3162 2
a3163 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d3179 1
a3179 1
	char *text = rt_malloc(HOLD_POINT_TO_STRING_LEN, "hold_point_to_string");
d3193 1
a3193 1
		rt_free(path, "full path");
d3197 1
a3197 1
		rt_bomb("hold_point_to_string: over wrote memory!\n");
d3211 2
a3212 2
	rt_free(t1, "hold_point_to_string");
	rt_free(t2, "hold_point_to_string");
d3215 1
a3215 1
	  struct rt_vls tmp_vls;
d3217 2
a3218 2
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls,"\n\twith a weight: %g, pull %g\n",
d3220 2
a3221 2
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d3274 1
a3274 1
		GETSTRUCT(anp, animate);
d3280 1
a3280 1
		    rt_malloc(sizeof(struct directory **)*anp->an_path.fp_maxlen,
d3288 1
a3288 1
				rt_free((char *)anp, "struct animate");
d3295 1
a3295 1
		  struct rt_vls tmp_vls;
d3297 1
a3297 1
		  rt_vls_init(&tmp_vls);
d3299 1
a3299 1
		  rt_vls_printf(&tmp_vls, "joint move: %s added animate %s to %s(0x%x)\n",
d3301 2
a3302 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d3329 1
a3329 1
		  struct rt_vls tmp_vls;
d3331 2
a3332 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "joint move: rotating %g around (%g %g %g)\n",
d3334 2
a3335 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d3369 1
a3369 1
		  struct rt_vls tmp_vls;
d3371 2
a3372 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "joint move: moving %g along (%g %g %g)\n",
d3374 2
a3375 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d3426 1
a3426 1
		  struct rt_vls tmp_vls;
d3428 2
a3429 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "joint move: %s rotate (%g %g %g) %g degrees.\n",
d3433 1
a3433 1
		  rt_vls_printf(&tmp_vls, "joint move: %s lower=%g, upper=%g\n",
d3435 2
a3436 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d3442 1
a3442 1
		  struct rt_vls tmp_vls;
d3444 2
a3445 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "joint move: %s, rotation %d, %s out of range.\n",
d3447 2
a3448 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d3468 1
a3468 1
		  struct rt_vls tmp_vls;
d3470 2
a3471 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "joint move: %s, vector %d, %s out of range.\n",
d3473 2
a3474 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d3513 1
a3513 1
	  rt_free(sofar, "path string");
d3563 1
a3563 1
	GETUNION(curtree, tree);
d3589 1
a3589 1
	newGrip = (struct artic_grips *)rt_malloc(sizeof(struct artic_grips),
d3603 1
a3603 1
	newJoint = (struct artic_joints *)rt_malloc(sizeof(struct artic_joints),
d3698 1
a3698 1
		  struct rt_vls tmp_vls;
d3700 2
a3701 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "joint mesh: %s has %d grips.\n",
d3703 2
a3704 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d3713 1
a3713 1
			rt_free((char *)gp,"artic_grip");
d3716 1
a3716 1
		rt_free((char *)jp, "Artic Joint");
@


11.4
log
@convert commands to Tcl
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.3 1995/12/27 22:35:08 bparker Exp bparker $";
d48 1
a48 1
static joint_debug = 0;
d61 1
d836 1
a836 1
		if (get_token(&token, fip, str, 0, syms) == EOF) {
d852 1
a852 1
		if (get_token(&token, fip, str, 0, syms) == EOF) {
d876 1
a876 1
	if (get_token(&token, fip, str, 0, syms) == EOF) {
d915 1
a915 1
		if (get_token(&token, fip, str, 0, syms) == EOF) {
d931 1
a931 1
		if (get_token(&token, fip, str, 0, syms) == EOF) {
d976 1
a976 1
	while (get_token(&token, fip, str, 0, syms) != EOF) {
d987 1
a987 1
		if (get_token(&token, fip, str, 0, syms) == EOF) {
d1443 1
a1443 1
	if (get_token(&token, fip, str, 0, syms) == EOF) {
d1815 1
a1815 1
	if ( get_token(&token, fip, str, 0, syms) == EOF) {
d1822 1
a1822 1
		if ( get_token(&token, fip, str, 0, syms) == EOF) {
d1976 1
a1976 1
	if (!no_unload) f_junload(0,0);
d2388 1
@


11.3
log
@*** empty log message ***
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.2 1995/03/10 20:46:54 mike Exp bparker $";
d79 1
d88 3
a90 1

d92 1
a92 1
	0, 0, 0,
d94 1
a94 1
	f_jfhelp, 0, MAXARGS,
d96 1
a96 1
	f_jaccept, 1, MAXARGS,
d98 1
a98 1
	f_jdebug, 1, 2,
d100 1
a100 1
	f_jhelp, 0, MAXARGS,
d102 1
a102 1
	f_jhold, 1, MAXARGS,
d104 1
a104 1
	f_jlist, 1, MAXARGS,
d106 1
a106 1
	f_jload, 2, MAXARGS,
d108 1
a108 1
	f_jmesh, 0, 1,
d110 1
a110 1
	f_jmove, 3, 8,
d112 1
a112 1
	f_jreject, 1, MAXARGS,
d114 1
a114 1
	f_jsave, 2, 2,
d116 1
a116 1
	f_jsolve, 1, MAXARGS,
d118 1
a118 1
	f_jtest, 2, 2,
d120 1
a120 1
	f_junload, 1,1,
d122 1
a122 1
	0,0,0
d133 19
a151 9
	if (argc >= 2) {
		sscanf( argv[1], "%x", &joint_debug);
	} else {
		rt_printb( "possible flags", 0xffffffffL, JOINT_DEBUG_FORMAT );
		rt_log("\n");
	}
	rt_printb( "joint_debug", joint_debug, JOINT_DEBUG_FORMAT );
	rt_log("\n");
	return CMD_OK;
d154 3
a156 1
f_joint( argc, argv )
d160 12
a171 2
	argc--;
	argv++;
d173 1
a173 1
	return mged_cmd(argc, argv, &joint_tab[0]);
d181 8
a188 1
	return f_fhelp2(argc, argv, &joint_tab[0]);
d196 8
a203 1
	return f_help2(argc, argv, &joint_tab[0]);
d301 3
a303 3
		rt_log("joint load constraint: unable to read %s type\n",
		    name);
		return 0;
d315 2
a316 1
		rt_log("joint load point: Type is %s\n", names[t]);
d321 3
a323 3
			rt_log("joint load constraint: unable to read %s 3space point\n",
			    name);
			return 0;
d328 3
a330 3
		    	rt_log("joint load constraint: unable to read points for %s.\n",
		    	    name);
		    	return 0;
d333 7
a339 2
			rt_log("joint load point: (%g %g %g)\n", pp->point[X],
			    pp->point[Y], pp->point[Z]);
d347 3
a349 3
			rt_log("joint load constraint: unable to read %s arc.\n",
			    name);
			return 0;
d365 7
a371 7
			rt_log("joint load constraint: arc '%s' for %s is bad.\n",
			    text, name);
			for (i=0; i<=arc_last; i++) {
				rt_free(arc[i], "arc entry");
			}
			rt_free((char *) arc, "arc table");
			return 0;
d388 3
a390 3
			rt_log("joint load constraint: unable to read %s arc.\n",
			    name);
			return 0;
d417 3
a419 3
				rt_log("joint load constraint: %s gave bad joint name.\n",
				    name);
				dp = 0;
d423 2
a424 2
			rt_log("joint load constraint: arc '%s' for %s is bad.\n",
			    text, name);
d442 12
a453 4
		rt_log("joint load constrain: Bad type (%d) for %s.\n",
		    pp->type, name);
		pp->type = HOLD_PT_FIXED;
		return 0;
d493 2
a494 1
			rt_log("joint unload: unloading '%s'.\n", jp->name);
d499 7
a505 2
		rt_log("joint unload: unloaded %d joints, %d constraints.\n",
		    joints, holds);
d507 1
d622 7
a628 2
		rt_log("%s:%d %s\n",lex_name, lex_line,error);
		return;
d637 9
a645 1
	rt_log("%s:%d %s\n%s\n%s\n",lex_name, lex_line,error,str->vls_str,text);
d657 11
a667 9
	int	used;
	for (;;) {
		used = rt_lex(token, str, keys, syms);
		if (used) break;
		rt_vls_free(str);
		lex_line++;
		used = rt_vls_gets(str,fip);
		if (used == EOF) return used;
	}
d669 2
a670 1
	rt_vls_nibble(str, used);
d672 2
a673 1
	if (joint_debug & DEBUG_J_LEX) {
d678 1
a678 1
			rt_log("lex: key(%d)='%s'\n", token->t_key.value,
d683 1
a683 1
			rt_log("lex: symbol(%d)='%c'\n", token->t_key.value,
d687 1
a687 1
			rt_log("lex: double(%g)\n", token->t_dbl.value);
d690 1
a690 1
			rt_log("lex: int(%d)\n", token->t_int.value);
d693 1
a693 1
			rt_log("lex: id(%s)\n", token->t_id.value);
d696 1
a696 1
	}
d698 4
a701 1
	return used;
d703 1
d759 1
a759 1
		rt_log("skip_group: Skipping....\n");
d776 1
a776 1
		rt_log("skip_group: Done....\n");
d823 1
a823 1
		rt_log("parse_path: open.\n");
d901 1
a901 1
		rt_log("parse_path: open.\n");
d964 1
a964 1
		rt_log("parse_ARC: open.\n");
d999 1
a999 1
				rt_log("parse_ARC: close.\n");
d1025 1
a1025 1
		rt_log("parse_double: open\n");
d1083 1
a1083 1
		rt_log("parse_vect: open.\n");
d1108 1
a1108 1
		rt_log("parse_trans: open\n");
d1126 1
a1126 1
		    		rt_log("parse_trans: closing.\n");
d1270 1
a1270 1
		rt_log("parse_rots: open\n");
d1288 1
a1288 1
		    		rt_log("parse_rots: closing.\n");
d1433 1
a1433 1
		rt_log("parse_joint: reading joint.\n");
d1469 1
a1469 1
		    		rt_log("parse_joint: closing.\n");
d1591 1
a1591 1
		rt_log("parse_jset: open\n");
d1609 1
a1609 1
				rt_log("parse_jset: close\n");
d1684 1
a1684 1
		rt_log("parse_solid: open\n");
d1702 1
a1702 1
				rt_log("parse_solid: close\n");
d1781 1
a1781 1
		rt_log("parse_point: close.\n");
d1795 1
a1795 1
		rt_log("parse_hold: reading constraint\n");
d1844 1
a1844 1
				rt_log("parse_hold: closing.\n");
d1969 2
a1970 2
			rt_log("Usage: joint load [-uam] file_name [files]\n");
			break;
d1986 5
a1990 4
			rt_log("joint load: unable to open '%s'.\n", *argv);
			++argv;
			--argc;
			continue;
d1993 2
a1994 1
			rt_log("joint load: loading from '%s'.\n", *argv);
d2120 2
a2121 2
		rt_log("joint save: missing file name");
		return CMD_BAD;
d2125 3
a2127 3
		rt_log("joint save: unable to open '%s' for writing.\n",
		    *argv);
		return CMD_BAD;
d2212 2
a2213 2
			rt_log("Usage: joint accept [-m] [joint_names]\n");
			break;
d2249 2
a2250 2
			rt_log("Usage: joint accept [-m] [joint_names]\n");
			break;
d2324 5
a2328 4
			rt_log("hold_eval: Lost joint!  %s not found!\n",
			    hp->arc.arc[hp->arc.arc_last]);
			/* rt_bomb(); */
			return 0;
d2350 2
a2351 2
			rt_log("hold_eval: unable to find location of effector for %s.\n",
			    hp->name);
d2357 2
a2358 2
			rt_log("hold_eval: unable to find location of objective for %s.\n",
			    hp->name);
d2364 6
a2369 1
		rt_log("hold_eval: PT->PT of %s is %g\n", hp->name, value);
d2412 2
a2413 1
		rt_log("part_solve: solving for %s.\n", hp->name);
d2421 2
a2422 1
			rt_log("part_solve: looking for joints on arc.\n");
d2452 2
a2453 2
					rt_log("part_solve: found %s\n",
					    jp->name);
d2468 2
a2469 2
			rt_log("part_solve: %s, joint %s not on arc.\n",
			    hp->name, hp->joint);
d2480 2
a2481 2
					rt_log("part_solve: dequeuing %s from %s\n",
					    jh->p->name, hp->name);
d2493 7
a2499 2
			rt_log("part_solve: solved, original(%g) < tol(%g)\n",
			    origvalue, tol);
d2576 4
a2579 1
					rt_log("part_solve: NEW min %s(%d,%g) %g <%g\n",
d2581 2
d2589 7
a2595 2
				rt_log("part_solve: OLD min %s(%d,%g)%g >= %g\n",
				    jp->name, i, x0, f0, besteval);
d2662 4
a2665 1
					rt_log("part_solve: NEW min %s(%d,%g) %g <%g delta=%g\n",
d2667 2
d2675 7
a2681 2
				rt_log("part_solve: OLD min %s(%d,%g)%g >= %g\n",
				    jp->name, i, x0, f0, besteval);
d2691 1
a2691 1
			rt_log("part_solve: No joint configuration found to be better.\n");
d2697 1
a2697 1
			rt_log("part_solve: No reasonable improvement found.\n");
d2726 7
a2732 2
		rt_log("reject_move: rejecting %s(%d,%g)->%g\n", ssp->jp->name,
		    ssp->freedom, ssp->new, ssp->old);
d2796 7
a2802 2
				rt_log("system_solve: priority %d has system weight of %g.\n",
				    i, pri_weights[i]);
d2833 1
a2833 1
			rt_log("system_solve: returning 1\n");
d2868 7
a2874 2
		rt_log("system_solve: old eval = %g, new eval = %g\n",
		    pri_weights[pri], new_eval);
d2948 1
a2948 1
			rt_log("system_solve: returning -1\n");
d2953 7
a2959 2
		rt_log("system_solve: new_weights[%d] = %g, returning ", pri,
		    new_weights[pri]);
d2963 1
a2963 1
			rt_log("1\n");
d2968 1
a2968 1
		rt_log("0\n");
d3034 9
a3042 16
		found = 0;
		for(RT_LIST_FOR(hp,hold,&hold_head)) {
			if (strcmp(*argv, hp->name)==0) {
				found = 1;
				for (count=0; count<loops; count++) {
					if (!part_solve(hp,delta,epsilon)) break;
					if (domesh) {
						f_jmesh(0,0);
						refresh();
					}
					joint_clear();
				}
				rt_log("joint solve: finished %d loops of %s.\n",
				    count, hp->name);
				continue;
			}
d3044 22
a3065 6
		if (!found) {
			rt_log("joint solve: constraint %s not found.\n",
				*argv);
		}
		--argc;
		++argv;
d3099 7
a3105 2
				rt_log("joint solve: spliting delta (%g)\n",
				    delta);
d3134 7
a3140 2
					rt_log("joint solve: spliting delta (%g)\n",
					    delta);
d3152 2
a3153 1
		rt_log("joint solve: system has convereged to a result.\n");
d3155 7
a3161 2
		rt_log("joint solve: system has not converged in %d loops.\n",
		    count);
d3163 1
a3163 1
		rt_log("joint solve: system will not converge.\n");
d3207 2
a3208 3
	rt_log("holds:\t%s with %s\n\tfrom:%s\n\tto: %s", (hp->name) ?
	    hp->name : "UNNAMED", hp->joint,
	    t1,t2);
d3211 10
a3220 2
	rt_log("\n\twith a weight: %g, pull %g\n",
	    hp->weight, hold_eval(hp) );
d3293 8
a3300 3
			sofar = db_path_to_string(&jp->anim->an_path);
			rt_log("joint move: %s added animate %s to %s(0x%x)\n",
			    jp->name, sofar, dp->d_namep, dp);
d3327 7
a3333 2
			rt_log("joint move: rotating %g around (%g %g %g)\n",
			    tmp*2*rt_radtodeg, q1[X], q1[Y], q1[Z]);
d3367 7
a3373 2
			rt_log("joint move: moving %g along (%g %g %g)\n",
			    tmp*base2local, m2[3], m2[7], m2[11]);
d3406 2
a3407 2
		rt_log("joint move: %s not found\n", *argv);
		return CMD_BAD;
d3424 11
a3434 6
			rt_log("joint move: %s rotate (%g %g %g) %g degrees.\n",
			    jp->name, jp->rots[i].quat[X],
			    jp->rots[i].quat[Y], jp->rots[i].quat[Z],
			    tmp);
			rt_log("joint move: %s lower=%g, upper=%g\n",
			    jp->name, jp->rots[i].lower, jp->rots[i].upper);
d3440 7
a3446 2
			rt_log("joint move: %s, rotation %d, %s out of range.\n",
			    jp->name, i, *argv);
d3466 7
a3472 2
			rt_log("joint move: %s, vector %d, %s out of range.\n",
			    jp->name, i, *argv);
d3508 4
a3511 3
		char *sofar = db_path_to_string(pathp);
		rt_log("joint mesh: PATH = '%s'\n",sofar);
		rt_free(sofar, "path string");
d3535 2
a3536 2
			rt_log("joint mesh: returning joint '%s'\n",
			    bestjp->name);
d3542 1
a3542 1
		rt_log("joint mesh: returning joint 'NULL'\n");
d3573 3
a3575 4
		rt_log("%s: solid import failure\n",
		    dp->d_namep);
		if (internal.idb_ptr) rt_functab[id].ft_ifree(&internal);
		return curtree;
d3696 7
a3702 2
			rt_log("joint mesh: %s has %d grips.\n",
			    (jp->joint) ? jp->joint->name: "UNGROUPED",i);
@


11.2
log
@Moved MAXARGS to ged.h, standardized on it's use, increased to 9000.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 11.1 95/01/04 10:02:34 mike Rel4_4 Locker: mike $";
a45 1
extern int	dmaflag;
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.13 94/12/20 16:46:48 jra Exp $";
d40 1
a40 1
#include "./ged.h"	/* ??? */
a79 1
#define MAXARGS	2000
@


1.13
log
@Mod for CRAY.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.12 1994/11/19 00:58:31 mike Exp $";
@


1.12
log
@Changed to returning proper MGED command return codes.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.11 94/11/10 12:05:58 jra Exp Locker: mike $";
d1815 1
a1815 1
			if (!parse_assign(&hp->priority, fip, str)) {
@


1.11
log
@Irix 6.0.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/animedit.c,v 1.10 1994/10/22 05:56:46 mike Exp jra $";
d63 16
a78 16
static void f_jfhelp();
void f_fhelp2();
static void f_jhelp();
void f_help2();
void f_jmesh();
void f_jdebug();
void f_jload();
void f_junload();
void f_jmove();
void f_jlist();
void f_jaccept();
void f_jreject();
void f_jsave();
void f_jhold();
void f_jsolve();
void f_jtest();
d85 1
a85 1
	void (*ft_func)MGED_ARGS((int, char **));
d127 1
a127 1
void
d140 1
d150 1
a150 2
	mged_cmd(argc, argv, &joint_tab[0]);
	return CMD_OK;
d153 1
a153 1
static void
d158 1
a158 1
	f_fhelp2(argc, argv, &joint_tab[0]);
d161 1
a161 1
static void
d166 1
a166 1
	f_help2(argc, argv, &joint_tab[0]);
d421 1
a421 1
void
d450 1
d1870 1
a1870 1
void
d2017 1
a2017 1
	return;
d2019 1
a2019 1
void
d2024 1
d2026 1
a2026 1
void
d2040 1
a2040 1
		return;
d2046 1
a2046 1
		return;
d2114 1
d2116 1
a2116 1
void
d2151 1
d2153 1
a2153 1
void
d2190 1
d2839 1
a2839 1
void
d2930 1
a2930 1
	if (found >= 0) return;
d3011 1
a3011 2

	return;
d3056 1
a3056 1
void
d3075 1
d3077 1
a3077 1
void
d3087 1
a3087 1
	return;
d3208 1
a3208 1
void
d3226 1
a3226 1
		return;
d3281 1
d3446 1
a3446 1
void
d3515 1
@


1.10
log
@typo
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.9 94/10/21 19:42:04 mike Exp Locker: mike $";
d135 1
a135 1
		rt_printb( "possible flags", -1, JOINT_DEBUG_FORMAT );
a209 1
	int i;
a218 1
	register int i;
d220 1
a427 1
	register struct jointH *jh;
a739 1
	register int i;
a817 1
	register int i;
a879 1
	register int i;
d971 2
a999 1
	union rt_lex_token token;
a1681 1
		break;
a1876 1
	int used;
a2192 1
	vect_t startloc;
d2249 1
d2311 1
a2311 1
	double f0,f1,f2,f3;
d2662 1
a2662 1
Top:
a2845 1
	register int i;
a3039 1
	int i;
a3207 1
	register struct animate *anp;
@


1.9
log
@strlen() is unsigned.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.8 94/09/23 18:57:13 mike Exp Locker: mike $";
d3021 1
a3021 1
	char text = rt_malloc(HOLD_POINT_TO_STRING_LEN, "hold_point_to_string");
@


1.8
log
@notreached
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.7 94/08/09 14:35:23 gdurf Exp Locker: mike $";
d3020 2
a3021 1
	char *text = rt_malloc(1000, "hold_point_to_string");
d3038 1
a3038 1
	if (strlen(text) > 1000) {
@


1.7
log
@Added missing #include "conf.h"
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.6 1994/08/09 14:34:55 gdurf Exp gdurf $";
d1503 1
a1503 1
	return 0;
d1871 1
a1871 1
	return 0;
@


1.6
log
@Factored ifdefs
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.5 1994/07/12 21:59:56 mike Exp gdurf $";
d21 2
@


1.5
log
@Fixed for non-ANSI compilers.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.4 94/07/12 21:56:57 mike Exp Locker: mike $";
d23 3
a25 1
#ifdef BSD
a26 2
#else
#include <string.h>
@


1.4
log
@First big version from Chris at GSI
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/animedit.c,v 1.36 1994/05/12 19:58:31 cjohnson Exp cjohnson $";
d83 1
a83 1
	void (*ft_func)(int, char **);
d1466 1
a1466 1
			if (!parse_vect(&jp->location, fip, str)) {
d1682 1
a1682 1
		if (!parse_vect(&pp->point, fip, str)) return 0;
@


1.3
log
@added necessary #includes
@
text
@d1 21
d23 7
d31 1
d33 2
d36 7
a42 1
#include "./ged.h"
d44 95
d144 3371
a3514 2
	rt_log("joint: Command(s) not yet ready for use.\n");
	return CMD_BAD;
@


1.2
log
@Converted f_joint to use new command return codes.
@
text
@d1 6
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
void
d7 1
a7 1
	return;
@
