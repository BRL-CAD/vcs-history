head	11.86;
access;
symbols
	ansi-20040405-merged:11.81.2.2
	postmerge-20040405-ansi:11.84
	premerge-20040404-ansi:11.83
	postmerge-autoconf:11.83
	autoconf-freeze:11.81.10.3
	premerge-autoconf:11.83
	postmerge-20040315-windows:11.83
	premerge-20040315-windows:11.82
	windows-20040315-freeze:11.81.4.2
	autoconf-20031203:11.81
	autoconf-20031202:11.81
	autoconf-branch:11.81.0.10
	phong-branch:11.81.0.8
	photonmap-branch:11.81.0.6
	rel-6-1-DP:11.81
	windows-branch:11.81.0.4
	rel-6-0-2:11.79
	ansi-branch:11.81.0.2
	rel-6-0-1-branch:11.79.0.2
	hartley-6-0-post:11.80
	hartley-6-0-pre:11.79
	rel-6-0-1:11.79
	rel-6-0:11.79
	rel-5-4:11.60.2.1
	offsite-5-3-pre:11.70
	rel-5-3:11.60.2.1
	rel-5-2:11.60
	rel-5-1-branch:11.60.0.2
	rel-5-1:11.60
	rel-5-0:11.52
	rel-5-0-beta:11.49
	rel-4-5:11.45
	ctj-4-5-post:11.40
	ctj-4-5-pre:11.40
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.15;
locks; strict;
comment	@ * @;


11.86
date	2004.05.21.17.47.39;	author morrison;	state dead;
branches;
next	11.85;

11.85
date	2004.05.10.15.30.48;	author erikg;	state Exp;
branches;
next	11.84;

11.84
date	2004.04.05.09.09.11;	author morrison;	state Exp;
branches;
next	11.83;

11.83
date	2004.03.16.21.15.11;	author morrison;	state Exp;
branches;
next	11.82;

11.82
date	2004.02.02.17.39.32;	author morrison;	state Exp;
branches;
next	11.81;

11.81
date	2002.08.20.17.08.22;	author jra;	state Exp;
branches
	11.81.2.1
	11.81.4.1
	11.81.10.1;
next	11.80;

11.80
date	2002.08.15.20.55.33;	author hartley;	state Exp;
branches;
next	11.79;

11.79
date	2001.06.01.19.23.23;	author bparker;	state Exp;
branches;
next	11.78;

11.78
date	2001.05.04.14.20.46;	author bparker;	state Exp;
branches;
next	11.77;

11.77
date	2001.05.02.17.14.00;	author bparker;	state Exp;
branches;
next	11.76;

11.76
date	2001.04.02.21.20.40;	author bparker;	state Exp;
branches;
next	11.75;

11.75
date	2001.03.23.22.02.10;	author jra;	state Exp;
branches;
next	11.74;

11.74
date	2001.03.22.19.36.24;	author jra;	state Exp;
branches;
next	11.73;

11.73
date	2001.03.22.18.51.34;	author bparker;	state Exp;
branches;
next	11.72;

11.72
date	2001.03.21.22.15.58;	author bparker;	state Exp;
branches;
next	11.71;

11.71
date	2001.03.21.20.18.19;	author bparker;	state Exp;
branches;
next	11.70;

11.70
date	2001.01.17.21.23.32;	author jra;	state Exp;
branches;
next	11.69;

11.69
date	2000.12.15.21.29.20;	author bparker;	state Exp;
branches;
next	11.68;

11.68
date	2000.10.24.19.49.00;	author mike;	state Exp;
branches;
next	11.67;

11.67
date	2000.10.20.20.35.24;	author jra;	state Exp;
branches;
next	11.66;

11.66
date	2000.09.08.05.55.48;	author mike;	state Exp;
branches;
next	11.65;

11.65
date	2000.09.07.02.43.20;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	2000.08.22.06.49.07;	author mike;	state Exp;
branches;
next	11.63;

11.63
date	2000.08.19.03.10.13;	author mike;	state Exp;
branches;
next	11.62;

11.62
date	2000.07.13.01.27.12;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	2000.07.07.03.28.39;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	2000.06.07.19.30.11;	author bparker;	state Exp;
branches
	11.60.2.1;
next	11.59;

11.59
date	2000.05.26.16.09.51;	author bparker;	state Exp;
branches;
next	11.58;

11.58
date	2000.05.26.14.00.42;	author bparker;	state Exp;
branches;
next	11.57;

11.57
date	2000.03.31.02.55.14;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	2000.01.07.04.21.19;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	99.12.30.19.19.24;	author jra;	state Exp;
branches;
next	11.54;

11.54
date	99.12.29.21.09.46;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	99.11.26.23.03.31;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	99.09.08.15.39.39;	author bparker;	state Exp;
branches;
next	11.51;

11.51
date	99.09.01.18.55.09;	author bparker;	state Exp;
branches;
next	11.50;

11.50
date	99.06.25.18.55.13;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	99.04.16.18.00.01;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	99.01.12.18.18.11;	author bparker;	state Exp;
branches;
next	11.47;

11.47
date	98.11.06.22.32.38;	author bparker;	state Exp;
branches;
next	11.46;

11.46
date	98.10.22.18.50.24;	author bparker;	state Exp;
branches;
next	11.45;

11.45
date	97.09.08.18.54.49;	author bparker;	state Exp;
branches;
next	11.44;

11.44
date	97.09.03.14.19.08;	author bparker;	state Exp;
branches;
next	11.43;

11.43
date	97.07.01.22.09.08;	author bparker;	state Exp;
branches;
next	11.42;

11.42
date	97.06.26.20.18.24;	author gdurf;	state Exp;
branches;
next	11.41;

11.41
date	97.06.14.03.12.26;	author gdurf;	state Exp;
branches;
next	11.40;

11.40
date	97.06.03.16.03.59;	author pjt;	state Exp;
branches;
next	11.39;

11.39
date	97.04.24.18.03.58;	author bparker;	state Exp;
branches;
next	11.38;

11.38
date	97.04.16.20.23.49;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	97.04.14.12.30.08;	author bparker;	state Exp;
branches;
next	11.36;

11.36
date	97.03.25.14.43.44;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	97.03.20.14.47.30;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	97.03.12.20.45.46;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	97.02.20.21.45.02;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	97.02.14.13.13.12;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	97.02.06.15.38.04;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	97.01.31.16.27.50;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	97.01.31.05.35.12;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	97.01.31.05.00.07;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	97.01.31.04.56.04;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	97.01.30.02.18.36;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	97.01.29.01.43.59;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	97.01.29.01.13.08;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.22;

11.22
date	96.10.04.15.01.21;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	96.10.03.20.50.43;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	96.10.01.17.26.29;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	96.09.25.20.10.14;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	96.09.23.18.32.00;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.16;

11.16
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.08.22.21.04.50;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	96.07.15.20.36.49;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	96.04.18.20.28.43;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	96.03.01.19.32.07;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	95.09.22.02.51.01;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.09.22.02.17.40;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.09.09.02.02.45;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	95.08.03.02.39.33;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.08.02.21.31.56;	author gdurf;	state Exp;
branches;
next	11.4;

11.4
date	95.07.26.13.22.34;	author gdurf;	state Exp;
branches;
next	11.3;

11.3
date	95.06.22.14.37.54;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.01.17.13.04.30;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.49;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.27.16.58.48;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.12.23.21.57.14;	author gdurf;	state Exp;
branches;
next	10.9;

10.9
date	94.12.16.20.32.47;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.12.16.19.35.53;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.11.05.03.48.07;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.23.18.25.24;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.08.09.15.04.40;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.06.13.19.05.39;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.06.03.12.26.57;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.06.01.16.00.44;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.16;	author mike;	state Rel4_0;
branches;
next	9.13;

9.13
date	91.08.30.17.14.36;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.07.08.23.02.00;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.07.08.22.57.37;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.07.03.15.09.48;	author stay;	state Exp;
branches;
next	9.9;

9.9
date	91.07.01.02.06.03;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.15.01.39.14;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.08.00.31.12;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.07.19.58.51;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.10.10.19.10.14;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.05.22.23.17.26;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.28.16.10.50;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.12.28.15.53.53;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.07;	author mike;	state Rel3_5;
branches;
next	8.7;

8.7
date	89.05.11.21.38.10;	author phil;	state Exp;
branches;
next	8.6;

8.6
date	89.05.11.04.40.23;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.05.08.21.44.44;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.06.20.39.03;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.03.06.23.59.11;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.01.01;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.35.45;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.08.24.07.48.12;	author reschly;	state Exp;
branches;
next	7.6;

7.6
date	88.05.15.23.04.53;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.01.27.10.32.42;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.01.13.16.37.47;	author stay;	state Exp;
branches;
next	7.3;

7.3
date	87.11.14.05.01.29;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.04.17;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.59.06;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.02.22;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.18.35;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.06.13.07.14.35;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.06.05;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.19.48;	author mike;	state Rel1;
branches;
next	2.31;

2.31
date	86.10.12.03.03.39;	author mike;	state Exp;
branches;
next	2.30;

2.30
date	86.09.23.17.49.06;	author mike;	state Exp;
branches;
next	2.29;

2.29
date	86.09.23.17.40.12;	author mike;	state Exp;
branches;
next	2.28;

2.28
date	86.09.10.03.01.59;	author mike;	state Exp;
branches;
next	2.27;

2.27
date	86.09.10.02.42.36;	author mike;	state Exp;
branches;
next	2.26;

2.26
date	86.08.12.06.47.34;	author mike;	state Exp;
branches;
next	2.25;

2.25
date	86.06.20.01.31.24;	author mike;	state Exp;
branches;
next	2.24;

2.24
date	86.06.12.00.11.42;	author mike;	state Exp;
branches;
next	2.23;

2.23
date	86.05.28.01.47.04;	author mike;	state Exp;
branches;
next	2.22;

2.22
date	86.05.28.01.00.45;	author mike;	state Exp;
branches;
next	2.21;

2.21
date	86.05.28.00.11.59;	author reschly;	state Exp;
branches;
next	2.20;

2.20
date	86.03.14.20.42.57;	author mike;	state Exp;
branches;
next	2.19;

2.19
date	86.03.11.00.11.18;	author mike;	state Exp;
branches;
next	2.18;

2.18
date	85.09.27.19.11.06;	author mike;	state Exp;
branches;
next	2.17;

2.17
date	85.09.14.05.34.55;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	85.09.12.00.49.55;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	85.08.29.14.55.42;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	85.08.07.05.17.20;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	85.06.05.15.37.48;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	85.05.29.16.05.57;	author mike;	state Exp;
branches;
next	2.11;

2.11
date	85.05.29.14.56.38;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	85.05.28.16.30.58;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	85.05.02.20.16.07;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	85.03.29.00.13.28;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	85.03.22.10.52.23;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.03.15.05.03.29;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.03.14.05.04.13;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.03.13.06.09.20;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.03.12.05.22.11;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.12.04.05.49;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.54.28;	author mike;	state Prod;
branches;
next	1.10;

1.10
date	85.02.14.00.31.00;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.02.08.01.29.20;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.02.05.04.17.31;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.02.02.01.40.29;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.02.01.03.24.52;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.02.01.00.50.19;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.01.16.01.56.54;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.22.06.55.57;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.04.23.06;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.16.19.49.32;	author mike;	state Exp;
branches;
next	;

11.60.2.1
date	2000.12.15.21.26.09;	author bparker;	state Exp;
branches;
next	;

11.81.2.1
date	2002.09.19.18.02.01;	author morrison;	state Exp;
branches;
next	11.81.2.2;

11.81.2.2
date	2004.03.17.21.21.56;	author morrison;	state Exp;
branches;
next	;

11.81.4.1
date	2002.09.26.23.04.09;	author morrison;	state Exp;
branches;
next	11.81.4.2;

11.81.4.2
date	2004.03.11.23.46.34;	author morrison;	state Exp;
branches;
next	;

11.81.10.1
date	2004.02.12.18.34.13;	author erikg;	state Exp;
branches;
next	11.81.10.2;

11.81.10.2
date	2004.03.15.14.07.36;	author erikg;	state Exp;
branches;
next	11.81.10.3;

11.81.10.3
date	2004.03.18.18.10.30;	author erikg;	state Exp;
branches;
next	;


desc
@Build and Manage the in-core GED directory
@


11.86
log
@moved to src/mged/
@
text
@/*
 *			D I R . C
 *
 * Functions -
 *	f_memprint	Debug, print memory & db free maps
 *	dir_nref	Count number of times each db element referenced
 *	dir_summary	Summarize contents of directory by categories
 *	f_tops		Prints top level items in database
 *	cmd_glob	Does regular expression expansion
 *	f_prefix	Prefix each occurence of a specified object name
 *	f_keep		Save named objects in specified file
 *	f_tree		Print out a tree of all members of an object
 *
 *  Authors -
 *	Michael John Muuss
 *	Keith A. Applin
 *	Richard Romanelli
 *	Robert Jon Reschly Jr.
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/mged/dir.c,v 11.85 2004/05/10 15:30:48 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <fcntl.h>
#include <stdio.h>
#include <signal.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "tcl.h"

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "wdb.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./mgedtcl.h"

#define BAD_EOF	(-1L)			/* eof_addr not set yet */

void	killtree(struct db_i *dbip, struct directory *dp, genptr_t ptr);

/*
 *			F _ M E M P R I N T
 *  
 *  Debugging aid:  dump memory maps
 */
int
f_memprint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  CHECK_DBI_NULL;

  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help memprint");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

#if 0
  Tcl_AppendResult(interp, "Display manager free map:\n", (char *)NULL);
  rt_memprint( &(dmp->dm_map) );
#endif

  bu_log("Database free-storage map:\n");
  rt_memprint( &(dbip->dbi_freep) );

  return TCL_OK;
}

/*
 *			C M D _ G L O B
 *  
 *  Assist routine for command processor.  If the current word in
 *  the argv[] array contains '*', '?', '[', or '\' then this word
 *  is potentially a regular expression, and we will tromp through the
 *  entire in-core directory searching for a match. If no match is
 *  found, the original word remains untouched and this routine was an
 *  expensive no-op.  If any match is found, it replaces the original
 *  word. Escape processing is also done done in this module.  If there
 *  are no matches, but there are escapes, the current word is modified.
 *  All matches are sought for, up to the limit of the argv[] array.
 *
 *  Returns 0 if no expansion happened, !0 if we matched something.
 */
int
cmd_glob(int *argcp, char **argv, int maxargs)
{
	static char word[64];
	register char *pattern;
	register struct directory	*dp;
	register int i;
	int escaped = 0;
	int orig_numargs = *argcp;

	if(dbip == DBI_NULL)
	  return 0;

	strncpy( word, argv[*argcp], sizeof(word)-1 );
	/* If * ? [ or \ are present, this is a regular expression */
	pattern = word;
	do {
		if( *pattern == '\0' )
			return(0);		/* nothing to do */
		if( *pattern == '*' ||
		    *pattern == '?' ||
		    *pattern == '[' ||
		    *pattern == '\\' )
			break;
	} while( *pattern++);

	/* Note if there are any escapes */
	for( pattern = word; *pattern; pattern++)
		if( *pattern == '\\') {
			escaped++;
			break;
		}

	/* Search for pattern matches.
	 * First, save the pattern (in word), and remove it from
	 * argv, as it will be overwritten by the expansions.
	 * If any matches are found, we do not have to worry about
	 * '\' escapes since the match coming from dp->d_namep is placed
	 * into argv.  Only in the case of no matches do we have
	 * to do escape crunching.
	 */

	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if( !db_regexp_match( word, dp->d_namep ) )
				continue;
			/* Successful match */
			/* See if already over the limit */
			if( *argcp >= maxargs )  {
				bu_log("%s: expansion stopped after %d matches (%d args)\n",
					word, *argcp-orig_numargs, maxargs);
				break;
			}
			argv[(*argcp)++] = dp->d_namep;
		}
	}
	/* If one or matches occurred, decrement final argc,
	 * otherwise, do escape processing if needed.
	 */

	if( *argcp > orig_numargs )  {
		(*argcp)--;
		return(1);
	} else if(escaped) {
		char *temp;
		temp = pattern = argv[*argcp];
		do {
			if(*pattern != '\\') {
				*temp = *pattern;
				temp++;
			} else if(*(pattern + 1) == '\\') {
				*temp = *pattern;
				pattern++;
				temp++;
			}
		} while(*pattern++);

		/* Elide the rare pattern which becomes null ("\<NULL>") */
		if(*(argv[*argcp]) == '\0')
			(*argcp)--;
	}
	return(0);		/* found nothing */
}

HIDDEN void
Do_prefix(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t prefix_ptr, genptr_t obj_ptr, genptr_t user_ptr3)
{
	char *prefix,*obj;
	char tempstring_v4[NAMESIZE+2];

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	prefix = (char *)prefix_ptr;
	obj = (char *)obj_ptr;

	if( strcmp( comb_leaf->tr_l.tl_name, obj ) )
		return;

	bu_free( comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name" );
	if( dbip->dbi_version < 5 ) {
		(void)strcpy( tempstring_v4, prefix);
		(void)strcat( tempstring_v4, obj);
		comb_leaf->tr_l.tl_name = bu_strdup( tempstring_v4 );
	} else {
		comb_leaf->tr_l.tl_name = (char *)bu_malloc( strlen( prefix ) + strlen( obj ) + 1,
							     "Adding prefix" );
		(void)strcpy( comb_leaf->tr_l.tl_name , prefix);
		(void)strcat( comb_leaf->tr_l.tl_name , obj );
	}
}

/*
 *			F _ P R E F I X
 *
 *  Prefix each occurence of a specified object name, both
 *  when defining the object, and when referencing it.
 */
int
f_prefix(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int	i,k;	
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal *comb;
	char tempstring_v4[NAMESIZE+2];
	struct bu_vls tempstring_v5;
	char *tempstring;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help prefix");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init( &tempstring_v5 );

	/* First, check validity, and change node names */
	for( i = 2; i < argc; i++) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY )) == DIR_NULL) {
			argv[i] = "";
			continue;
		}

		if( dbip->dbi_version < 5 && (int)(strlen(argv[1]) + strlen(argv[i])) > NAMESIZE) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "'%s%s' too long, must be less than %d characters.\n",
				argv[1], argv[i], NAMESIZE);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);

		  argv[i] = "";
		  continue;
		}

		if( dbip->dbi_version < 5 ) {
			(void) strcpy( tempstring_v4, argv[1]);
			(void) strcat( tempstring_v4, argv[i]);
			tempstring = tempstring_v4;
		} else {
			bu_vls_trunc( &tempstring_v5, 0 );
			bu_vls_strcpy( &tempstring_v5, argv[1] );
			bu_vls_strcat( &tempstring_v5, argv[i] );
			tempstring = bu_vls_addr( &tempstring_v5 );
		}

		if( db_lookup( dbip, tempstring, LOOKUP_QUIET ) != DIR_NULL ) {
			aexists( tempstring );
			argv[i] = "";
			continue;
		}
		/*  Change object name in the directory. */
		if( db_rename( dbip, dp, tempstring ) < 0 )  {
			bu_vls_free( &tempstring_v5 );
		  Tcl_AppendResult(interp, "error in rename to ", tempstring,
				   ", aborting\n", (char *)NULL);
		  TCL_ERROR_RECOVERY_SUGGESTION;
		  return TCL_ERROR;
		}
	}

	bu_vls_free( &tempstring_v5 );

	/* Examine all COMB nodes */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if( !(dp->d_flags & DIR_COMB) )
				continue;

			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
				TCL_READ_ERR_return;
			comb = (struct rt_comb_internal *)intern.idb_ptr;

			for( k=2; k<argc; k++ )
				db_tree_funcleaf( dbip, comb, comb->tree, Do_prefix,
					(genptr_t)argv[1], (genptr_t)argv[k], (genptr_t)NULL );
			if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) )
				TCL_WRITE_ERR_return;
		}
	}
	return TCL_OK;
}

HIDDEN void
Change_name(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t old_ptr, genptr_t new_ptr)
{
	char	*old_name, *new_name;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	old_name = (char *)old_ptr;
	new_name = (char *)new_ptr;

	if( strcmp( comb_leaf->tr_l.tl_name, old_name ) )
		return;

	bu_free( comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name" );
	comb_leaf->tr_l.tl_name = bu_strdup( new_name );
}

/*	F _ K I L L A L L
 *
 *	kill object[s] and
 *	remove all references to the object[s]
 *	format:	killall obj1 ... objn
 *
 */
int
cmd_killall(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
#if 0
	CHECK_DBI_NULL;

	return wdb_killall_cmd(wdbp, interp, argc, argv);
#else
	register int	i,k;
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int			ret;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help killall");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
		(void)signal( SIGINT, sig3);  /* allow interupts */
	else{
		/* Free intern? */
		return TCL_OK;
	}

	ret = TCL_OK;

	/* Examine all COMB nodes */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if( !(dp->d_flags & DIR_COMB) )
				continue;

			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
				Tcl_AppendResult(interp, "rt_db_get_internal(", dp->d_namep,
					") failure", (char *)NULL );
				ret = TCL_ERROR;
				continue;
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			RT_CK_COMB(comb);

			for( k=1; k<argc; k++ )  {
				int	code;

				code = db_tree_del_dbleaf( &(comb->tree), argv[k], &rt_uniresource );
				if( code == -1 )  continue;	/* not found */
				if( code == -2 )  continue;	/* empty tree */
				if( code < 0 )  {
					Tcl_AppendResult(interp, "  ERROR_deleting ",
						dp->d_namep, "/", argv[k],
						"\n", (char *)NULL);
					ret = TCL_ERROR;
				} else {
					Tcl_AppendResult(interp, "deleted ",
						dp->d_namep, "/", argv[k],
						"\n", (char *)NULL);
				}
			}

			if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )  {
				Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
				ret = TCL_ERROR;
				continue;
			}
		}
	}

	if( ret != TCL_OK )  {
		Tcl_AppendResult(interp, "KILL skipped because of earlier errors.\n", (char *)NULL);
		return ret;
	}

	/* ALL references removed...now KILL the object[s] */
	/* reuse argv[] */
	argv[0] = "kill";
	(void)signal( SIGINT, SIG_IGN );
	return cmd_kill( clientData, interp, argc, argv );
#endif
}


/*		F _ K I L L T R E E ( )
 *
 *	Kill ALL paths belonging to an object
 *
 */
int
cmd_killtree(ClientData	clientData,
	     Tcl_Interp *interp,
	     int	argc,
	     char	**argv)
{
#if 0
	CHECK_DBI_NULL;

	return wdb_kill_cmd(wdbp, interp, argc, argv);
#else
	register struct directory *dp;
	register int i;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help killtree");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	      else
	  return TCL_OK;

	for(i=1; i<argc; i++) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY) ) == DIR_NULL )
			continue;
		db_functree( dbip, dp, killtree, killtree, &rt_uniresource, (genptr_t)interp );
	}

	(void)signal( SIGINT, SIG_IGN );
	solid_list_callback();
	return TCL_OK;
#endif
}

/*
 *			K I L L T R E E
 */
void
killtree(struct db_i *dbip, struct directory *dp, genptr_t ptr)
{
	Tcl_Interp		*interp = (Tcl_Interp *)ptr;
	struct directory	*dpp[2] = {DIR_NULL, DIR_NULL};

	if (dbip == DBI_NULL)
		return;

	Tcl_AppendResult(interp, "KILL ", (dp->d_flags & DIR_COMB) ? "COMB" : "Solid",
			 ":  ", dp->d_namep, "\n", (char *)NULL);

	dpp[0] = dp;
	eraseobjall(dpp);

	if (db_delete(dbip, dp) < 0 || db_dirdelete(dbip, dp) < 0) {
		TCL_DELETE_ERR("");
	}
}

int
f_debugdir(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  CHECK_DBI_NULL;

  if(argc < 1 || 1 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help debugdir");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  db_pr_dir( dbip );
  return TCL_OK;
}
@


11.85
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/dir.c,v 11.84 2004/04/05 09:09:11 morrison Exp $ (BRL)";
@


11.84
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d33 5
a37 1
#include "conf.h"
@


11.83
log
@merge of windows-6-0-branch into head
@
text
@d59 1
a59 5
#ifndef WIN32
void	killtree();
#else
void	killtree(struct db_i *dbip,struct directory *dp,genptr_t ptr);
#endif
d67 1
a67 5
f_memprint(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d108 1
a108 4
cmd_glob(argcp, argv, maxargs)
int  *argcp;
char *argv[];
int   maxargs;
d192 1
a192 5
Do_prefix( dbip, comb, comb_leaf, prefix_ptr, obj_ptr, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		prefix_ptr, obj_ptr, user_ptr3;
d226 1
a226 5
f_prefix(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d320 1
a320 5
Change_name( dbip, comb, comb_leaf, old_ptr, new_ptr )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		old_ptr, new_ptr;
d491 1
a491 4
killtree(dbip, dp, ptr)
struct db_i	*dbip;
struct directory *dp;
genptr_t	ptr;
d511 1
a511 5
f_debugdir(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.82
log
@update copyright to include span through 2003
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.81 2002/08/20 17:08:22 jra Exp $ (BRL)";
d59 1
d61 3
@


11.81
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1985 by the United States Army.
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.79 2001/06/01 19:23:23 bparker Exp $ (BRL)";
@


11.81.10.1
log
@merge from HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.82 2004/02/02 17:39:32 morrison Exp $ (BRL)";
@


11.81.10.2
log
@merge from head
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.81.10.1 2004/02/12 18:34:13 erikg Exp $ (BRL)";
@


11.81.10.3
log
@merge from head
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a58 1
#ifndef WIN32
a59 3
#else
void	killtree(struct db_i *dbip,struct directory *dp,genptr_t ptr);
#endif
@


11.81.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.81 2002/08/20 17:08:22 jra Exp $ (BRL)";
a58 1
#ifndef WIN32
a59 3
#else
void	killtree(struct db_i *dbip,struct directory *dp,genptr_t ptr);
#endif
@


11.81.4.2
log
@sync to HEAD...
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/mged/dir.c,v 11.81.4.1 2002/09/26 23:04:09 morrison Exp $ (BRL)";
@


11.81.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.81 2002/08/20 17:08:22 jra Exp $ (BRL)";
d59 1
a59 1
void	killtree(struct db_i *dbip, struct directory *dp, genptr_t ptr);
d67 5
a71 1
f_memprint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d112 4
a115 1
cmd_glob(int *argcp, char **argv, int maxargs)
d199 5
a203 1
Do_prefix(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t prefix_ptr, genptr_t obj_ptr, genptr_t user_ptr3)
d237 5
a241 1
f_prefix(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d335 5
a339 1
Change_name(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t old_ptr, genptr_t new_ptr)
d510 4
a513 1
killtree(struct db_i *dbip, struct directory *dp, genptr_t ptr)
d533 5
a537 1
f_debugdir(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.81.2.2
log
@sync branch with HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.80
log
@Converted from K&R to ANSI C - RFH
@
text
@d59 1
a59 1
void	killtree(struct db_i *dbip, struct directory *dp, genptr_t ptr);
d67 5
a71 1
f_memprint(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d112 4
a115 1
cmd_glob(int *argcp, char **argv, int maxargs)
d199 5
a203 1
Do_prefix(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t prefix_ptr, genptr_t obj_ptr, genptr_t user_ptr3)
d237 5
a241 1
f_prefix(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d335 5
a339 1
Change_name(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t old_ptr, genptr_t new_ptr)
d510 4
a513 1
killtree(struct db_i *dbip, struct directory *dp, genptr_t ptr)
d533 5
a537 1
f_debugdir(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
@


11.79
log
@*- mods that reflect MGED's use of drawable geometry
   objects, database objects and view objects
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.78 2001/05/04 14:20:46 bparker Exp $ (BRL)";
d59 1
a59 1
void	killtree();
d67 1
a67 5
f_memprint(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d108 1
a108 4
cmd_glob(argcp, argv, maxargs)
int  *argcp;
char *argv[];
int   maxargs;
d192 1
a192 5
Do_prefix( dbip, comb, comb_leaf, prefix_ptr, obj_ptr, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		prefix_ptr, obj_ptr, user_ptr3;
d226 1
a226 5
f_prefix(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d320 1
a320 5
Change_name( dbip, comb, comb_leaf, old_ptr, new_ptr )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		old_ptr, new_ptr;
d491 1
a491 4
killtree(dbip, dp, ptr)
struct db_i	*dbip;
struct directory *dp;
genptr_t	ptr;
d511 1
a511 5
f_debugdir(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.78
log
@*- export more commands out of mged and into librt
*- modify mged to use the librt routines
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.77 2001/05/02 17:14:00 bparker Exp $ (BRL)";
a333 98
/*
 *			F _ K E E P
 *
 *  	Save named objects in specified file.
 *	Good for pulling parts out of one model for use elsewhere.
 */
BU_EXTERN(void node_write, (struct db_i *dbip, struct directory *dp, genptr_t ptr));

void
node_write( dbip, dp, ptr )
struct db_i	*dbip;
register struct directory *dp;
genptr_t	ptr;
{
	struct rt_wdb	*keepfp = (struct rt_wdb *)ptr;
	struct bu_external	ext;

	RT_CK_WDB(keepfp);

	if( dp->d_nref++ > 0 )
		return;		/* already written */

	if( db_get_external( &ext, dp, dbip ) < 0 )
		READ_ERR_return;
	if( wdb_export_external( keepfp, &ext, dp->d_namep, dp->d_flags, dp->d_minor_type ) < 0 )
		WRITE_ERR_return;
}

int
f_keep(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	struct rt_wdb		*keepfp;
	register struct directory *dp;
	struct bu_vls		title;
	register int		i;
	struct db_i		*new_dbip;

	CHECK_DBI_NULL;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help keep");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* First, clear any existing counts */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )
			dp->d_nref = 0;
	}

	/* Alert user if named file already exists */
	if( (new_dbip = db_open( argv[1], "w" )) !=  DBI_NULL  &&
	    (keepfp = wdb_dbopen( new_dbip, RT_WDB_TYPE_DB_DISK ) ) != NULL )  {
		Tcl_AppendResult(interp, "keep:  appending to '", argv[1],
			   "'\n", (char *)NULL);
	} else {
		/* Create a new database */
		if( (keepfp = wdb_fopen( argv[1] ) ) == NULL )  {
			perror( argv[1] );
			return TCL_ERROR;
		}
	}
	
	/* ident record */
	bu_vls_init( &title );
	bu_vls_strcat( &title, "Parts of: " );
	bu_vls_strcat( &title, dbip->dbi_title );

	if( db_update_ident( keepfp->dbip, bu_vls_addr(&title), dbip->dbi_local2base ) < 0 )  {
		perror("fwrite");
		Tcl_AppendResult(interp, "db_update_ident() failed\n", (char *)NULL);
		wdb_close(keepfp);
		bu_vls_free( &title );
		return TCL_ERROR;
	}
	bu_vls_free( &title );

	for(i = 2; i < argc; i++) {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL )
			continue;
		db_functree( dbip, dp, node_write, node_write, &rt_uniresource, (genptr_t)keepfp );
	}

	wdb_close(keepfp);

	return TCL_OK;
}


d364 4
a367 5
f_killall(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
d369 5
d452 2
a453 1
	return f_kill( clientData, interp, argc, argv );
d463 4
a466 5
f_killtree(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
d468 5
d503 1
@


11.77
log
@*- modified commands to use new librt routines
@
text
@a4 2
 *	dir_getspace	Allocate memory for table of directory entry pointers
 *	dir_print	Print table-of-contents of object file
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.76 2001/04/02 21:20:40 bparker Exp $ (BRL)";
a61 156
 *			D I R _ G E T S P A C E
 *
 * This routine walks through the directory entry list and mallocs enough
 * space for pointers to hold:
 *  a) all of the entries if called with an argument of 0, or
 *  b) the number of entries specified by the argument if > 0.
 */
struct directory **
dir_getspace(num_entries)
register int num_entries;
{
	register struct directory *dp;
	register int i;
	register struct directory **dir_basep;

	if(dbip == DBI_NULL)
	  return (struct directory **) 0;

	if( num_entries < 0) {
		bu_log( "dir_getspace: was passed %d, used 0\n",
		  num_entries);
		num_entries = 0;
	}
	if( num_entries == 0)  {
		/* Set num_entries to the number of entries */
		for( i = 0; i < RT_DBNHASH; i++)
			for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
				num_entries++;
	}

	/* Allocate and cast num_entries worth of pointers */
	dir_basep = (struct directory **) bu_malloc(
		(num_entries+1) * sizeof(struct directory *),
		"dir_getspace *dir[]" );
	return(dir_basep);
}

/*
 *			D I R _ P R I N T
 *
 * This routine lists the names of all the objects accessible
 * in the object file.
 */
int
dir_print(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp	*interp;
int	argc;
char	**argv;
{
  register struct directory *dp;
  register int i;
  int c;
  int aflag = 0;		/* print all objects without formatting */
  int cflag = 0;		/* print combinations */
  int rflag = 0;		/* print regions */
  int sflag = 0;		/* print solids */
  int lflag = 0;		/* use long format */
  struct directory **dirp;
  struct directory **dirp0 = (struct directory **)NULL;
  struct bu_vls vls;

  CHECK_DBI_NULL;

  if(argc < 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_optind = 1;	/* re-init bu_getopt() */
  while ((c = bu_getopt(argc, argv, "acgrsl")) != EOF) {
    switch (c) {
    case 'a':
      aflag = 1;
      break;
    case 'c':
      cflag = 1;
      break;
    case 'r':
      rflag = 1;
      break;
    case 's':
      sflag = 1;
      break;
    case 'l':
      lflag = 1;
      break;
    default:
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "Unrecognized option - %c\n", c);
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
  }
  argc -= (bu_optind - 1);
  argv += (bu_optind - 1);

  bu_vls_init(&vls);
  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3);	/* allow interupts */
  else{
    if(dirp0)
      bu_free( (genptr_t)dirp0, "dir_getspace dp[]" );
    bu_vls_free(&vls);

    return TCL_OK;
  }

  if (argc > 1) {
    /* Just list specified names */
    dirp = dir_getspace( argc-1 );
    dirp0 = dirp;
    /*
     * Verify the names, and add pointers to them to the array.
     */
    for( i = 1; i < argc; i++ )  {
      if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY)) ==
	  DIR_NULL )
	continue;
      *dirp++ = dp;
    }
  } else {
    /* Full table of contents */
    dirp = dir_getspace(0);		/* Enough for all */
    dirp0 = dirp;
    /*
     * Walk the directory list adding pointers (to the directory
     * entries) to the array.
     */
    for( i = 0; i < RT_DBNHASH; i++)
	    for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw) {
		    if( aflag || !(dp->d_flags & DIR_HIDDEN) )
			    *dirp++ = dp;
	    }
  }

  if( lflag )
    vls_long_dpp( &vls, dirp0, (int)(dirp - dirp0), aflag, cflag, rflag, sflag );
  else if (aflag || cflag || rflag || sflag)
    vls_line_dpp(&vls, dirp0, (int)(dirp - dirp0),
		 aflag, cflag, rflag, sflag);
  else
    vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0));

  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
  (void)signal( SIGINT, SIG_IGN );
  bu_vls_free(&vls);
  bu_free( (genptr_t)dirp0, "dir_getspace dp[]" );
  return TCL_OK;
}

/*
a96 103
 *  			D I R _ S U M M A R Y
 *
 * Summarize the contents of the directory by categories
 * (solid, comb, region).  If flag is != 0, it is interpreted
 * as a request to print all the names in that category (eg, DIR_SOLID).
 */
void
dir_summary(int flag)
{
	register struct directory *dp;
	register int i;
	static int sol, comb, reg;
	struct directory **dirp;
	struct directory **dirp0 = (struct directory **)NULL;
	struct bu_vls vls;

	if(dbip == DBI_NULL)
	  return;

	bu_vls_init(&vls);
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);	/* allow interupts */
	else{
	  if(dirp0)
	    bu_free( (genptr_t)dirp0, "dir_getspace" );
	  bu_vls_free(&vls);

	  return;
	}	  

	sol = comb = reg = 0;
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if( dp->d_flags & DIR_SOLID )
				sol++;
			if( dp->d_flags & DIR_COMB )  {
				if( dp->d_flags & DIR_REGION )
					reg++;
				else
					comb++;
			}
		}
	}
	bu_log("Summary:\n");
	bu_log("  %5d solids\n", sol);
	bu_log("  %5d region; %d non-region combinations\n", reg, comb);
	bu_log("  %5d total objects\n\n", sol+reg+comb );

	if( flag == 0 ){
	  (void)signal( SIGINT, SIG_IGN );
	  return;
	}

	/* Print all names matching the flags parameter */
	/* THIS MIGHT WANT TO BE SEPARATED OUT BY CATEGORY */
	
	dirp = dir_getspace(0);
	dirp0 = dirp;
	/*
	 * Walk the directory list adding pointers (to the directory entries
	 * of interest) to the array
	 */
	for( i = 0; i < RT_DBNHASH; i++)
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
			if( dp->d_flags & flag )
				*dirp++ = dp;

	vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0));
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	(void)signal( SIGINT, SIG_IGN );
	bu_vls_free(&vls);
	bu_free( (genptr_t)dirp0, "dir_getspace" );
}

/*
 *  			F _ T O P S
 *  
 *  Find all top level objects.
 *  TODO:  Perhaps print all objects, sorted by use count, as an option?
 */
int
f_tops(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
	int		ret;

	CHECK_DBI_NULL;

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
        else
		return TCL_OK;

	ret = wdb_tops_cmd(wdbp, interp, argc, argv);

	(void)signal(SIGINT, SIG_IGN);
	return ret;
}

/*
a197 217
void
scrape_escapes_AppendResult( interp, str )
Tcl_Interp *interp;
char *str;
{
    char buf[2];
    buf[1] = '\0';
    
    while ( *str ) {
	buf[0] = *str;
	if ( *str != '\\' ) {
	    Tcl_AppendResult( interp, buf, NULL );
	} else if( *(str+1) == '\\' ) {
	    Tcl_AppendResult( interp, buf, NULL );
	    ++str;
	}
	if( *str == '\0' )
	    break;
	++str;
    }
}

/*
 *                C M D _ E X P A N D
 *
 * Performs wildcard expansion (matched to the database elements)
 * on its given arguments.  The result is returned in interp->result.
 */

int
cmd_expand( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    register char *pattern;
    register struct directory *dp;
    register int i, whicharg;
    int regexp, nummatch, thismatch, backslashed;

    CHECK_DBI_NULL;

    if(argc < 1){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help expand");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    nummatch = 0;
    backslashed = 0;
    for ( whicharg = 1; whicharg < argc; whicharg++ ) {
	/* If * ? or [ are present, this is a regular expression */
	pattern = argv[whicharg];
	regexp = 0;
	do {
	    if( (*pattern == '*' || *pattern == '?' || *pattern == '[') &&
	        !backslashed ) {
		regexp = 1;
		break;
	    }
	    if( *pattern == '\\' && !backslashed )
		backslashed = 1;
	    else
		backslashed = 0;
	} while( *pattern++ );

	/* If it isn't a regexp, copy directly and continue */
	if( regexp == 0 ) {
	    if( nummatch > 0 )
		Tcl_AppendResult( interp, " ", NULL );
	    scrape_escapes_AppendResult( interp, argv[whicharg] );
	    ++nummatch;
	    continue;
	}
	
	/* Search for pattern matches.
	 * If any matches are found, we do not have to worry about
	 * '\' escapes since the match coming from dp->d_namep will be
	 * clean. In the case of no matches, just copy the argument
	 * directly.
	 */

	pattern = argv[whicharg];
	thismatch = 0;
	for( i = 0; i < RT_DBNHASH; i++ )  {
	    for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
	        if( !db_regexp_match( pattern, dp->d_namep ) )
		    continue;
		/* Successful match */
		if( nummatch == 0 )
		    Tcl_AppendResult( interp, dp->d_namep, NULL );
		else 
		    Tcl_AppendResult( interp, " ", dp->d_namep, NULL );
		++nummatch;
		++thismatch;
	    }
	}
	if( thismatch == 0 ) {
	    if( nummatch > 0 )
		Tcl_AppendResult( interp, " ", NULL );
	    scrape_escapes_AppendResult( interp, argv[whicharg] );
	}
    }

    return TCL_OK;
}

HIDDEN void
Find_ref( dbip, comb, comb_leaf, object, comb_name_ptr, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal	*comb;
union tree		*comb_leaf;
genptr_t		object;
genptr_t		comb_name_ptr;
genptr_t		user_ptr3;
{
	char *obj_name;
	char *comb_name;
	register int sflag = (int)(((long)user_ptr3) & 0xFFFF);	/* only need lsb */

	RT_CK_TREE( comb_leaf );

	obj_name = (char *)object;
	if( strcmp( comb_leaf->tr_l.tl_name, obj_name ) )
		return;

	comb_name = (char *)comb_name_ptr;

	if (sflag)
	  Tcl_AppendElement(interp, comb_name);
	else
	  Tcl_AppendResult(interp, obj_name, ":  member of ", comb_name, "\n", (char *)NULL );
}

/*
 *  			F _ F I N D
 *  
 *  Find all references to the named objects.
 */
int
f_find(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
{
  register int	i,k;
  register int sflag = 0;
  register struct directory *dp;
  struct rt_db_internal intern;
  register struct rt_comb_internal *comb=(struct rt_comb_internal *)NULL;

  CHECK_DBI_NULL;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if (strcmp(argv[1], "-s") == 0) {
    --argc;
    ++argv;

    if(argc < 2){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help find");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    sflag = 1;
  }

  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3);	/* allow interupts */
  else{
    if( comb )
  	rt_comb_ifree( &intern, &rt_uniresource );
    return TCL_OK;
  }

  /* Examine all COMB nodes */
  for( i = 0; i < RT_DBNHASH; i++ )  {
    for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
      if( !(dp->d_flags & DIR_COMB) )
	continue;

    	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	{
		(void)signal( SIGINT, SIG_IGN );
		TCL_READ_ERR_return;
	}
    	comb = (struct rt_comb_internal *)intern.idb_ptr;
	for( k=0; k<argc; k++ )
	    	db_tree_funcleaf( dbip, comb, comb->tree, Find_ref, (genptr_t)argv[k], (genptr_t)dp->d_namep, (genptr_t)sflag );

    	rt_comb_ifree( &intern, &rt_uniresource );
    }
  }

  (void)signal( SIGINT, SIG_IGN );
  return TCL_OK;
}

a431 31
/*
 *			F _ T R E E
 *
 *	Print out a list of all members and submembers of an object.
 */
int
f_tree(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	int		ret;

	CHECK_DBI_NULL;

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
	else
		return TCL_OK;

	/*
	 * The tree command is wrapped by tclscripts/tree.tcl and calls this
	 * routine with the name _mged_tree. So, we put back the original name.
	 */ 
	argv[0] = "tree";
	ret = wdb_tree_cmd(wdbp, interp, argc, argv);

	(void)signal(SIGINT, SIG_IGN);
	return ret;
}

a451 18
}

/*	F _ M V A L L
 *
 *	rename all occurences of an object
 *	format:	mvall oldname newname
 *
 */
int
f_mvall(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	return wdb_move_all_cmd(wdbp, interp, argc, argv);
@


11.76
log
@*- remove Tk dependencies
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.75 2001/03/23 22:02:10 jra Exp $ (BRL)";
d351 1
a351 1
	ret = invoke_db_wrapper(interp, argc, argv);
d916 4
a919 5
f_tree(clientData, interp, argc, argv)
     ClientData	clientData;
     Tcl_Interp	*interp;
     int	argc;
     char	**argv;
d935 1
a935 1
	ret = invoke_db_wrapper(interp, argc, argv);
d970 4
a973 5
f_mvall(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
a974 6
	register int	i;
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal *comb;
	struct bu_ptbl		stack;

d978 1
a978 106
	if(argc < 3 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help mvall");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( dbip->dbi_version < 5 && (int)strlen(argv[2]) > NAMESIZE ) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "ERROR: name length limited to %d characters in v4 databases\n", NAMESIZE);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  return TCL_ERROR;
	}

	/* rename the record itself */
	if( (dp = db_lookup( dbip, argv[1], LOOKUP_NOISY )) == DIR_NULL)
	  return TCL_ERROR;
	if( db_lookup( dbip, argv[2], LOOKUP_QUIET ) != DIR_NULL ) {
	  aexists( argv[2]);
	  return TCL_ERROR;
	}
	/*  Change object name in the directory. */
	if( db_rename( dbip, dp, argv[2] ) < 0 )  {
	  Tcl_AppendResult(interp, "error in rename to ", argv[2],
			   ", aborting\n", (char *)NULL);
	  TCL_ERROR_RECOVERY_SUGGESTION;
	  return TCL_ERROR;
	}

	/* Change name in the file */
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		TCL_READ_ERR_return;
	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 ) {
		TCL_WRITE_ERR_return;
	}

	bu_ptbl_init( &stack, 64, "combination stack for f_mvall" );

	/* Examine all COMB nodes */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			union tree	*comb_leaf;
			int		done=0;
			int		changed=0;

			if( !(dp->d_flags & DIR_COMB) )
				continue;

			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
				continue;
			comb = (struct rt_comb_internal *)intern.idb_ptr;

			bu_ptbl_reset( &stack );
			/* visit each leaf in the combination */
			comb_leaf = comb->tree;
			if( comb_leaf )
			{
				while( !done )
				{
					while( comb_leaf->tr_op != OP_DB_LEAF )
					{
						bu_ptbl_ins( &stack, (long *)comb_leaf );
						comb_leaf = comb_leaf->tr_b.tb_left;
					}
					if( !strcmp( comb_leaf->tr_l.tl_name, argv[1] ) )
					{
						bu_free( comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name" );
						comb_leaf->tr_l.tl_name = bu_strdup( argv[2] );
						changed = 1;
					}

					if( BU_PTBL_END( &stack ) < 1 )
					{
						done = 1;
						break;
					}
					comb_leaf = (union tree *)BU_PTBL_GET( &stack, BU_PTBL_END( &stack )-1 );
					if( comb_leaf->tr_op != OP_DB_LEAF )
					{
						bu_ptbl_rm( &stack, (long *)comb_leaf );
						comb_leaf = comb_leaf->tr_b.tb_right;
					}
				}
			}

			if( changed )
			{
				if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) )
				{
					bu_ptbl_free( &stack );
					rt_comb_ifree( &intern, &rt_uniresource );
					TCL_WRITE_ERR_return;
				}
			}
			else
				rt_comb_ifree( &intern, &rt_uniresource );
		}
	}
	bu_ptbl_free( &stack );
	return TCL_OK;
@


11.75
log
@Added -l option to ls
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/dir.c,v 11.74 2001/03/22 19:36:24 jra Exp $ (BRL)";
d46 1
a46 1
#include "tk.h"
@


11.74
log
@"ls" command now does not show "hidden" objects
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/dir.c,v 11.73 2001/03/22 18:51:34 bparker Exp $ (BRL)";
d121 1
d137 1
a137 1
  while ((c = bu_getopt(argc, argv, "acgrs")) != EOF) {
d151 3
d204 3
a206 1
  if (aflag || cflag || rflag || sflag)
d836 1
a836 1
	if( wdb_export_external( keepfp, &ext, dp->d_namep, dp->d_flags ) < 0 )
@


11.73
log
@*- modified f_tops to use LIBRT's wdb_tops_tcl method
*- remove old code from f_tree
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/dir.c,v 11.72 2001/03/21 22:15:58 bparker Exp $ (BRL)";
d194 4
a197 2
      for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
	*dirp++ = dp;
@


11.72
log
@*- mods to use invoke_db_wrapper
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/dir.c,v 11.71 2001/03/21 20:18:19 bparker Exp $ (BRL)";
d334 1
a334 7
#if 0
#else
	register struct directory *dp;
	register int i;
	struct directory **dirp;
	struct directory **dirp0 = (struct directory **)NULL;
	struct bu_vls vls;
d338 4
a341 2
	if(argc < 1 || 1 < argc){
	  struct bu_vls vls;
d343 1
a343 17
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help tops");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init(&vls);
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);	/* allow interupts */
	else{
	  if(dirp0)
	    bu_free( (genptr_t)dirp0, "dir_getspace" );
	  bu_vls_free(&vls);

	  return TCL_OK;
	}
d345 2
a346 26
	db_update_nref( dbip, &rt_uniresource );
	/*
	 * Find number of possible entries and allocate memory
	 */
	dirp = dir_getspace(0);
	dirp0 = dirp;
	/*
	 * Walk the directory list adding pointers (to the directory entries
	 * which are the tops of their respective trees) to the array
	 */
	for( i = 0; i < RT_DBNHASH; i++)
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
			if( dp->d_nref > 0) {
				/* Object not member of any combination */
				continue;
			} else {
				*dirp++ = dp;
			}

	vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0));
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	(void)signal( SIGINT, SIG_IGN );
	bu_vls_free(&vls);
	bu_free( (genptr_t)dirp0, "dir_getspace" );
	return TCL_OK;
#endif
d919 1
a919 1
		(void)signal( SIGINT, sig3);  /* allow interupts */
a927 2

#if 1
a928 7
#else
	bu_vls_init(&vls);
	bu_build_cmd_vls(&vls, MGED_DB_NAME, argc, argv);

	ret = Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
#endif
@


11.71
log
@*- modify f_tree to use LIBRT's wdb_tree_tcl method
*- remove printnode
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/mged/dir.c,v 11.70 2001/01/17 21:23:32 jra Exp $ (BRL)";
a45 1
#include "tcl.h"
d334 2
d390 1
a958 1
	struct bu_vls	vls;
d961 5
a965 1
	bu_vls_init(&vls);
d972 5
a978 7
	if (setjmp(jmp_env) == 0)
		(void)signal( SIGINT, sig3);  /* allow interupts */
	else {
		bu_vls_free(&vls);
		return TCL_OK;
	}

d981 1
@


11.70
log
@Mods for unlimited name lengths
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.69 2000/12/15 21:29:20 bparker Exp $ (BRL)";
a63 2
static void printnode();

d956 2
a957 3
	register struct directory	*dp;
	register int			j;
	int				cflag = 0;
d960 1
d962 6
a967 9
	if (argc < 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help tree");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d971 2
a972 1
	else
a973 5

	if (argv[1][0] == '-' && argv[1][1] == 'c') {
		cflag = 1;
		--argc;
		++argv;
d976 2
a977 7
	for (j = 1; j < argc; j++) {
		if (j > 1)
			Tcl_AppendResult(interp, "\n", (char *)NULL);
		if ((dp = db_lookup(dbip, argv[j], LOOKUP_NOISY)) == DIR_NULL)
			continue;
		printnode(dp, 0, 0, cflag);
	}
d980 1
a980 120
	return TCL_OK;
}

/*
 *			P R I N T N O D E
 */
static void
printnode(dp, pathpos, prefix, cflag)
     register struct directory	*dp;
     int			pathpos;
     char			prefix;
     int			cflag;
{	
	register int			i;
	register struct directory	*nextdp;
	struct rt_db_internal		intern;
	struct rt_comb_internal		*comb;

	if (dbip == DBI_NULL)
		return;

	if (cflag && !(dp->d_flags & DIR_COMB))
		return;

	for (i=0; i<pathpos; i++) 
		Tcl_AppendResult(interp, "\t", (char *)NULL);

	if (prefix) {
		struct bu_vls	tmp_vls;

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, "%c ", prefix);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		bu_vls_free(&tmp_vls);
	}

	Tcl_AppendResult(interp, dp->d_namep, (char *)NULL);
	/* Output Comb and Region flags (-F?) */
	if (dp->d_flags & DIR_COMB)
		Tcl_AppendResult(interp, "/", (char *)NULL);
	if (dp->d_flags & DIR_REGION)
		Tcl_AppendResult(interp, "R", (char *)NULL);

	Tcl_AppendResult(interp, "\n", (char *)NULL);

	if (!(dp->d_flags & DIR_COMB))
		return;

	/*
	 *  This node is a combination (eg, a directory).
	 *  Process all the arcs (eg, directory members).
	 */

	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
		READ_ERR_return;
	comb = (struct rt_comb_internal *)intern.idb_ptr;

	if (comb->tree) {
		int			node_count;
		int			actual_count = 0;
		struct rt_tree_array	*rt_tree_array = NULL;

		if (comb->tree && db_ck_v4gift_tree(comb->tree) < 0) {
			db_non_union_push( comb->tree, &rt_uniresource );
			if (db_ck_v4gift_tree(comb->tree) < 0) {
				Tcl_AppendResult(interp, "Cannot flatten tree for listing\n", (char *)NULL );
				return;
			}
		}
		node_count = db_tree_nleaves(comb->tree);
		if (node_count > 0) {
			rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count,
									   sizeof( struct rt_tree_array ), "tree list" );
			actual_count = (struct rt_tree_array *)db_flatten_tree(
				rt_tree_array, comb->tree, OP_UNION, 0,
				&rt_uniresource ) - rt_tree_array;
			if (actual_count > node_count)
				bu_bomb("rt_comb_v4_export() array overflow!");
			if (actual_count < node_count)
				bu_log("WARNING rt_comb_v4_export() array underflow! %d < %d", actual_count, node_count);
		}

		for (i=0 ; i<actual_count ; i++) {
			char op;

			switch (rt_tree_array[i].tl_op) {
			case OP_UNION:
				op = 'u';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			default:
				op = '?';
				break;
			}

			if ((nextdp = db_lookup(dbip, rt_tree_array[i].tl_tree->tr_l.tl_name, LOOKUP_NOISY)) == DIR_NULL) {
				int j;
				struct bu_vls tmp_vls;

				for (j=0; j<pathpos+1; j++) 
					Tcl_AppendResult(interp, "\t", (char *)NULL);

				bu_vls_init(&tmp_vls);
				bu_vls_printf(&tmp_vls, "%c ", op);
				Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
				bu_vls_free(&tmp_vls);

				Tcl_AppendResult(interp, rt_tree_array[i].tl_tree->tr_l.tl_name, "\n", (char *)NULL);
			} else
				printnode(nextdp, pathpos+1, op, cflag);
		}
		bu_free((char *)rt_tree_array, "printnode: rt_tree_array");
	}

	rt_comb_ifree( &intern, &rt_uniresource );
a981 1

@


11.69
log
@Change find to dbfind.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.68 2000/10/24 19:49:00 mike Exp $ (BRL)";
d720 1
a720 1
	char tempstring[NAMESIZE+2];
d728 1
a728 1
	if( strncmp( comb_leaf->tr_l.tl_name, obj, NAMESIZE ) )
a730 2
	(void)strcpy( tempstring, prefix);
	(void)strcat( tempstring, obj);
d732 10
a741 1
	comb_leaf->tr_l.tl_name = bu_strdup( tempstring );
d761 3
a763 1
	char		tempstring[NAMESIZE+2];
d778 2
d787 1
a787 1
		if( (int)(strlen(argv[1]) + strlen(argv[i])) > NAMESIZE) {
d800 10
a809 2
		(void) strcpy( tempstring, argv[1]);
		(void) strcat( tempstring, argv[i]);
d818 1
d826 2
d1132 1
a1132 1
	if( strncmp( comb_leaf->tr_l.tl_name, old_name, NAMESIZE ) )
d1171 1
a1171 1
	if( (int)strlen(argv[2]) > NAMESIZE ) {
d1175 1
a1175 1
	  bu_vls_printf(&tmp_vls, "ERROR: name length limited to %d characters\n", NAMESIZE);
d1231 1
a1231 1
					if( !strncmp( comb_leaf->tr_l.tl_name, argv[1], NAMESIZE ) )
@


11.68
log
@
Possible uninit
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.67 2000/10/20 20:35:24 jra Exp $ (BRL)";
d658 1
a658 1
    bu_vls_printf(&vls, "help find");
@


11.67
log
@Added needed resource pointer to db_functree calss
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.66 2000/09/08 05:55:48 mike Exp $ (BRL)";
d1031 2
a1032 2
		int			actual_count;
		struct rt_tree_array	*rt_tree_array;
@


11.66
log
@
Tree routines now need resource structure.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.65 2000/09/07 02:43:20 mike Exp $ (BRL)";
d915 1
a915 1
		db_functree( dbip, dp, node_write, node_write, (genptr_t)keepfp );
d1379 1
a1379 1
		db_functree( dbip, dp, killtree, killtree, (genptr_t)interp );
@


11.65
log
@
More externs to ged.h to silence lint
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.64 2000/08/22 06:49:07 mike Exp $ (BRL)";
d366 1
a366 1
	db_update_nref( dbip );
d685 1
a685 1
  	rt_comb_ifree( &intern );
d695 1
a695 1
    	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d704 1
a704 1
    	rt_comb_ifree( &intern );
d812 1
a812 1
			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d819 1
a819 1
			if( rt_db_put_internal( dp, dbip, &intern ) )
d1025 1
a1025 1
	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL) < 0)
d1035 1
a1035 1
			db_non_union_push(comb->tree);
d1045 3
a1047 1
			actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION, 0 ) - rt_tree_array;
d1091 1
a1091 1
	rt_comb_ifree( &intern );
d1175 1
a1175 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d1177 1
a1177 1
	if( rt_db_put_internal( dp, dbip, &intern ) < 0 ) {
d1193 1
a1193 1
			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d1232 1
a1232 1
				if( rt_db_put_internal( dp, dbip, &intern ) )
d1235 1
a1235 1
					rt_comb_ifree( &intern );
d1240 1
a1240 1
				rt_comb_ifree( &intern );
d1295 1
a1295 1
			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )  {
d1307 1
a1307 1
				code = db_tree_del_dbleaf( &(comb->tree), argv[k] );
d1322 1
a1322 1
			if( rt_db_put_internal( dp, dbip, &intern ) < 0 )  {
@


11.64
log
@
db_flatten_tree() got an additional argument, to prevent memory leaks.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.63 2000/08/19 03:10:13 mike Exp $ (BRL)";
d257 1
a257 1
dir_summary(flag)
d1253 5
a1257 5
f_killall(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d1347 5
a1351 5
f_killtree(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
@


11.63
log
@
Reduced use of MAXARGS
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.62 2000/07/13 01:27:12 mike Exp $ (BRL)";
d1045 1
a1045 1
			actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION ) - rt_tree_array;
@


11.62
log
@
Changed to use db_update_ident()
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.61 2000/07/07 03:28:39 mike Exp $ (BRL)";
d130 1
a130 1
  if(argc < 1 || MAXARGS < argc){
d538 1
a538 1
    if(argc < 1 || MAXARGS < argc){
d654 1
a654 1
  if(argc < 2 || MAXARGS < argc){
d759 1
a759 1
	if(argc < 3 || MAXARGS < argc){
d869 1
a869 1
	if(argc < 3 || MAXARGS < argc){
d942 1
a942 1
	if (argc < 2 || MAXARGS < argc) {
d1268 1
a1268 1
	if(argc < 2 || MAXARGS < argc){
d1359 1
a1359 1
	if(argc < 2 || MAXARGS < argc){
@


11.61
log
@
Made title of map precede the body of the memory map.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.60 2000/06/07 19:30:11 bparker Exp $ (BRL)";
d50 1
d54 1
a54 1
#include "externs.h"
d285 1
a285 1
			if( dp->d_flags & DIR_COMB )
d290 1
d840 4
a843 2
	FILE		*keepfp = (FILE *)ptr;
	struct rt_db_internal	intern;
d848 1
a848 1
	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
d850 1
a850 1
	if( mk_export_fwrite( keepfp, dp->d_namep, intern.idb_ptr, intern.idb_type ) )
d861 1
a861 1
	FILE			*keepfp;
a863 1
	struct bu_vls		units;
d865 1
d886 3
a888 2
	if( (keepfp = fopen( argv[1], "r" ) ) != NULL )  {
	  Tcl_AppendResult(interp, "keep:  appending to '", argv[1],
d890 6
a895 6
	  fclose(keepfp);
	}

	if( (keepfp = fopen( argv[1], "a" ) ) == NULL )  {
		perror( argv[1] );
		return TCL_ERROR;
d903 1
a903 3
	bu_vls_init( &units);
	
	if( db_fwrite_ident( keepfp, bu_vls_addr(&title), dbip->dbi_local2base ) < 0 )  {
d905 2
a906 2
		Tcl_AppendResult(interp, "db_fwrite_ident() failed\n", (char *)NULL);
		fclose(keepfp);
a907 1
		bu_vls_free( &units );
d910 1
d918 1
a918 3
	fclose(keepfp);
	bu_vls_free( &title );
	bu_vls_free( &units );
a1088 1
end:
@


11.60
log
@Add -c option to f_tree to print only combinations.
Formatted f_tree and printnodes.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.59 2000/05/26 16:09:51 bparker Exp $ (BRL)";
d241 2
a242 1
  Tcl_AppendResult(interp, "Database free granule map:\n", (char *)NULL);
@


11.60.2.1
log
@Change find to dbfind.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.60 2000/06/07 19:30:11 bparker Exp $ (BRL)";
d655 1
a655 1
    bu_vls_printf(&vls, "help %s", argv[0]);
@


11.59
log
@*- forgot to do this last time
(i.e. the dpp argument to eraseobj and eraseobjall
needs to be a NULL terminated array)
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.58 2000/05/26 14:00:42 bparker Exp $ (BRL)";
d929 4
a932 4
ClientData clientData;
Tcl_Interp *interp;
int	argc;
char	**argv;
d934 5
a938 2
  register struct directory *dp;
  register int j;
d940 2
a941 1
  CHECK_DBI_NULL;
d943 6
a948 2
  if(argc < 2 || MAXARGS < argc){
    struct bu_vls vls;
d950 4
a953 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help tree");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d955 5
a959 4
  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3);  /* allow interupts */
  else
    return TCL_OK;
d961 7
a967 7
  for ( j = 1; j < argc; j++) {
    if( j > 1 )
      Tcl_AppendResult(interp, "\n", (char *)NULL);
    if( (dp = db_lookup( dbip, argv[j], LOOKUP_NOISY )) == DIR_NULL )
      continue;
    printnode(dp, 0, 0);
  }
d969 2
a970 2
  (void)signal( SIGINT, SIG_IGN );
  return TCL_OK;
d977 5
a981 4
printnode( dp, pathpos, prefix )
register struct directory *dp;
int pathpos;
char prefix;
d983 16
a998 4
  register int	i;
  register struct directory *nextdp;
  struct rt_db_internal intern;
  struct rt_comb_internal *comb;
d1000 5
a1004 2
  if(dbip == DBI_NULL)
    return;
d1006 6
a1011 2
  for( i=0; i<pathpos; i++) 
    Tcl_AppendResult(interp, "\t", (char *)NULL);
d1013 1
a1013 2
  if( prefix ) {
    struct bu_vls tmp_vls;
d1015 7
a1021 5
    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "%c ", prefix);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
  }
d1023 3
a1025 26
  Tcl_AppendResult(interp, dp->d_namep, (char *)NULL);
  /* Output Comb and Region flags (-F?) */
  if( dp->d_flags & DIR_COMB )
    Tcl_AppendResult(interp, "/", (char *)NULL);
  if( dp->d_flags & DIR_REGION )
    Tcl_AppendResult(interp, "R", (char *)NULL);

  Tcl_AppendResult(interp, "\n", (char *)NULL);

  if( !(dp->d_flags & DIR_COMB) )
    return;

  /*
   *  This node is a combination (eg, a directory).
   *  Process all the arcs (eg, directory members).
   */

  if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL ) < 0 )
	READ_ERR_return;
  comb = (struct rt_comb_internal *)intern.idb_ptr;

  if( comb->tree )
  {
  	int node_count;
  	int actual_count;
  	struct rt_tree_array *rt_tree_array;
d1027 21
a1047 7
	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
	{
		db_non_union_push( comb->tree );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			Tcl_AppendResult(interp, "Cannot flatten tree for listing\n", (char *)NULL );
			return;
a1048 10
	}
	node_count = db_tree_nleaves( comb->tree );
	if( node_count > 0 )
	{
		rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count,
			sizeof( struct rt_tree_array ), "tree list" );
		actual_count = (struct rt_tree_array *)db_flatten_tree( rt_tree_array, comb->tree, OP_UNION ) - rt_tree_array;
		if( actual_count > node_count )  bu_bomb("rt_comb_v4_export() array overflow!");
		if( actual_count < node_count )  bu_log("WARNING rt_comb_v4_export() array underflow! %d < %d", actual_count, node_count);
	}
d1050 2
a1051 3
  	for( i=0 ; i<actual_count ; i++ )
  	{
  		char op;
d1053 1
a1053 2
		switch( rt_tree_array[i].tl_op )
		{
d1066 17
d1084 2
d1087 2
a1088 21
  		if( (nextdp = db_lookup( dbip, rt_tree_array[i].tl_tree->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
  		{
  			int j;
			struct bu_vls tmp_vls;
  			
			for( j=0; j<pathpos+1; j++) 
				Tcl_AppendResult(interp, "\t", (char *)NULL);

			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls, "%c ", op);
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);

			Tcl_AppendResult(interp, rt_tree_array[i].tl_tree->tr_l.tl_name, "\n", (char *)NULL);
		}
  		else
			printnode( nextdp, pathpos+1, op );
  	}
	bu_free( (char *)rt_tree_array, "printnode: rt_tree_array" );
  }
  rt_comb_ifree( &intern );
@


11.58
log
@*- mods that reflect parameter changes to
   eraseobj and eraseobjall
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.57 2000/03/31 02:55:14 mike Exp $ (BRL)";
d1386 2
a1387 1
  Tcl_Interp	*interp = (Tcl_Interp *)ptr;
d1389 2
a1390 2
  if(dbip == DBI_NULL)
    return;
d1392 2
a1393 2
  Tcl_AppendResult(interp, "KILL ", (dp->d_flags & DIR_COMB) ? "COMB" : "Solid",
		   ":  ", dp->d_namep, "\n", (char *)NULL);
d1395 2
a1396 1
  eraseobjall(&dp);
d1398 3
a1400 3
  if( db_delete( dbip, dp) < 0 || db_dirdelete( dbip, dp ) < 0 ){
    TCL_DELETE_ERR("");
  }
@


11.57
log
@
Silenced compiler warning message.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.56 2000/01/07 04:21:19 mike Exp $ (BRL)";
d1381 1
a1381 1
killtree( dbip, dp, ptr )
d1383 1
a1383 1
register struct directory *dp;
d1394 1
a1394 1
  eraseobjall( dp );
@


11.56
log
@
Eliminated dbi_localunit.  This is a v4 database anachronism.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.55 1999/12/30 19:19:24 jra Exp $ (BRL)";
d615 1
a615 1
	register int sflag = (int)user_ptr3;
@


11.55
log
@Eliminated some unused variables
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.54 1999/12/29 21:09:46 mike Exp $ (BRL)";
d899 1
a899 24
	switch (localunit)
	{
	    case ID_NO_UNIT:
		bu_vls_strcat( &units, "none"); break;
	    case ID_UM_UNIT:
		bu_vls_strcat( &units, "um"); break;
	    case ID_MM_UNIT:
		bu_vls_strcat( &units, "mm"); break;
	    case ID_CM_UNIT:
		bu_vls_strcat( &units, "cm"); break;
	    case ID_M_UNIT:
		bu_vls_strcat( &units, "m"); break;
	    case ID_KM_UNIT:
		bu_vls_strcat( &units, "km"); break;
	    case ID_IN_UNIT:
		bu_vls_strcat( &units, "in"); break;
	    case ID_FT_UNIT:
		bu_vls_strcat( &units, "ft"); break;
	    case ID_YD_UNIT:
		bu_vls_strcat( &units, "yd"); break;
	    case ID_MI_UNIT:
		bu_vls_strcat( &units, "mi"); break;
	}
	if( mk_id_units( keepfp, bu_vls_addr(&title), bu_vls_addr(&units) ) < 0 )  {
d901 1
a901 1
		Tcl_AppendResult(interp, "mk_id_units() failed\n", (char *)NULL);
@


11.54
log
@Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.53 1999/11/26 23:03:31 mike Exp $ (BRL)";
d643 1
a643 1
  register int	i,j,k;
d747 1
a747 1
	register int	i,j,k;	
d1143 1
a1143 1
	register int	i,j,k;	
a1409 2
  register struct dm_list *dmlp;
  register struct dm_list *save_dmlp;
@


11.53
log
@
Lint
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.52 1999/09/08 15:39:39 bparker Exp $ (BRL)";
d829 1
a829 1
static FILE	*keepfp;
d832 1
a832 1
node_write( dbip, dp )
d835 1
d837 1
a838 1
	int			want;
d856 1
d934 1
a934 1
		db_functree( dbip, dp, node_write, node_write );
d1392 1
a1392 1
		db_functree( dbip, dp, killtree, killtree );
d1404 1
a1404 1
killtree( dbip, dp )
d1407 1
d1409 1
@


11.52
log
@*- add a,c,r and s options to dir_print
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.51 1999/09/01 18:55:09 bparker Exp $ (BRL)";
d692 1
a692 1
    	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d809 1
a809 1
			if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d842 1
a842 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d1033 1
a1033 1
  if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d1186 1
a1186 1
	if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d1204 1
a1204 1
			if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
d1306 1
a1306 1
			if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )  {
@


11.51
log
@*- mods to squak when a database is not open and a user
   tries to perform an operation that needs a valid dbip.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.50 1999/06/25 18:55:13 jra Exp $ (BRL)";
d118 5
a129 2
    struct bu_vls vls;

d137 26
d174 1
a174 1
  if( argc > 1) {
d200 6
a205 1
  vls_col_pr4v(&vls, dirp0, (int)(dirp - dirp0));
@


11.50
log
@f_mvall was dumping core on empty combinations.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.49 1999/04/16 18:00:01 bparker Exp $ (BRL)";
d122 1
a122 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d191 1
a191 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d306 1
a306 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d499 1
a499 2
    if(dbip == DBI_NULL)
      return TCL_OK;
d615 1
a615 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d719 1
a719 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d826 1
a826 2
	if(dbip == DBI_NULL)
	  return TCL_OK;
d924 1
a924 2
  if(dbip == DBI_NULL)
    return TCL_OK;
d1113 1
a1113 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1244 1
a1244 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1335 1
a1335 3
	if(dbip == DBI_NULL)
	  return TCL_OK;

d1395 1
a1395 2
  if(dbip == DBI_NULL)
    return TCL_OK;
@


11.49
log
@*- call solid_list_callback whenever the solid
   list gets changed.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.48 1999/01/12 18:18:11 bparker Exp $ (BRL)";
d1188 1
a1188 1
			while( !done )
d1190 1
a1190 1
				while( comb_leaf->tr_op != OP_DB_LEAF )
d1192 23
a1214 20
					bu_ptbl_ins( &stack, (long *)comb_leaf );
					comb_leaf = comb_leaf->tr_b.tb_left;
				}
				if( !strncmp( comb_leaf->tr_l.tl_name, argv[1], NAMESIZE ) )
				{
					bu_free( comb_leaf->tr_l.tl_name, "comb_leaf->tr_l.tl_name" );
					comb_leaf->tr_l.tl_name = bu_strdup( argv[2] );
					changed = 1;
				}

				if( BU_PTBL_END( &stack ) < 1 )
				{
					done = 1;
					break;
				}
				comb_leaf = (union tree *)BU_PTBL_GET( &stack, BU_PTBL_END( &stack )-1 );
				if( comb_leaf->tr_op != OP_DB_LEAF )
				{
					bu_ptbl_rm( &stack, (long *)comb_leaf );
					comb_leaf = comb_leaf->tr_b.tb_right;
@


11.48
log
@*- some cleanup
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.47 1998/11/06 22:32:38 bparker Exp $ (BRL)";
d1372 1
@


11.47
log
@*- use new structures
*- cleanup
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.46 1998/10/22 18:50:24 bparker Exp $ (BRL)";
a1392 11

#ifdef DO_SINGLE_DISPLAY_LIST
  FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
    if(dmlp->dml_dmp->dm_displaylist && dmlp->dml_mged_variables->mv_dlist){
      save_dmlp = curr_dm_list;
      curr_dm_list = dmlp;
      createDList(&HeadSolid);
      curr_dm_list = save_dmlp;
    }
  }
#endif
@


11.46
log
@*- add -s option to the "find" command
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dir.c,v 11.45 1997/09/08 18:54:49 bparker Exp $ (BRL)";
d1396 1
a1396 1
    if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables->dlist){
@


11.45
log
@new macro --> FOR_ALL_DISPLAYS
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.44 1997/09/03 14:19:08 bparker Exp bparker $ (BRL)";
d585 1
d595 4
a598 1
	Tcl_AppendResult(interp, obj_name, ":  member of ", comb_name, "\n", (char *)NULL );
d614 1
d622 1
a622 1
  if(argc < 1 || MAXARGS < argc){
d632 17
d670 1
a670 1
	    	db_tree_funcleaf( dbip, comb, comb->tree, Find_ref, (genptr_t)argv[k], (genptr_t)dp->d_namep, (genptr_t)NULL );
@


11.44
log
@mods to implement new display lists
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.43 1997/07/01 22:09:08 bparker Exp bparker $ (BRL)";
d1373 2
a1374 2
  for( BU_LIST_FOR(dmlp, dm_list, &head_dm_list.l) ){
    if(dmlp->_dmp->dm_displaylist && dmlp->_mged_variables.dlist){
@


11.43
log
@mods to run without a database
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.42 1997/06/26 20:18:24 gdurf Exp bparker $ (BRL)";
d205 1
d208 1
d1361 5
a1365 2
	if(dbip == DBI_NULL)
	  return;
d1367 1
a1367 1
	Tcl_AppendResult(interp, "KILL ", (dp->d_flags & DIR_COMB) ? "COMB" : "Solid",
d1370 1
a1370 1
	eraseobjall( dp );
d1372 14
a1385 3
	if( db_delete( dbip, dp) < 0 || db_dirdelete( dbip, dp ) < 0 ){
	  TCL_DELETE_ERR("");
	}
@


11.42
log
@Moved the reference-counting code to ../librt/db_match.c (perhaps it needs
its own file?)
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.41 1997/06/14 03:12:26 gdurf Exp gdurf $ (BRL)";
d74 1
a74 1
dir_getspace( num_entries)
d81 3
d122 3
d192 3
d230 3
d306 3
d385 3
d500 3
d612 3
d700 3
d809 3
d908 3
d952 3
d1098 3
d1228 3
d1321 3
d1359 3
d1379 3
@


11.41
log
@Extracted regexp_match to put into librt (as db_regexp_match)
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.40 1997/06/03 16:03:59 pjt Exp gdurf $ (BRL)";
a203 51
HIDDEN void
Count_refs( dbip, comb, comb_leaf, user_ptr1, user_ptr2, user_ptr3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		user_ptr1, user_ptr2, user_ptr3;
{
	struct directory *dp;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	if( (dp = db_lookup( dbip, comb_leaf->tr_l.tl_name, LOOKUP_QUIET)) != DIR_NULL )
		dp->d_nref++;
}

/*
 *			D I R _ N R E F
 *
 * Count the number of time each directory member is referenced
 * by a COMBination record.
 */
void
dir_nref( )
{
	register int		i,j;
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal *comb;

	/* First, clear any existing counts */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )
			dp->d_nref = 0;
	}

	/* Examine all COMB nodes */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if( !(dp->d_flags & DIR_COMB) )
				continue;

			if( rt_db_get_internal( &intern, dp, dbip, (mat_t *)NULL ) < 0 )
				continue;
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			db_tree_funcleaf( dbip, comb, comb->tree, Count_refs, (genptr_t)NULL, (genptr_t)NULL, (genptr_t)NULL );
			rt_comb_ifree( &intern );
		}
	}
}

d315 1
a315 1
	dir_nref();
@


11.40
log
@Added units um, km, yd, mi, and other minor improvements
@
text
@a8 1
 *	regexp_match	Does regular exp match given string?
d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.39 1997/04/24 18:03:58 bparker Exp $ (BRL)";
a255 104
 *			R E G E X P _ M A T C H
 *
 *	If string matches pattern, return 1, else return 0
 *
 *	special characters:
 *		*	Matches any string including the null string.
 *		?	Matches any single character.
 *		[...]	Matches any one of the characters enclosed.
 *		-	May be used inside brackets to specify range
 *			(i.e. str[1-58] matches str1, str2, ... str5, str8)
 *		\	Escapes special characters.
 */
int
regexp_match( pattern, string )
register char *pattern, *string;
{
    do {
	switch( *pattern ) {
	case '*':
	    /* match any string including null string */
	    ++pattern;
	    do {
		if( regexp_match( pattern, string ) )
		    return( 1 );
	    } while( *string++ != '\0' );
	    return( 0 );
	case '?':
	    /* match any character  */
	    if( *string == '\0' )
		return( 0 );
	    break;
	case '[':
	    /* try to match one of the characters in brackets */
	    ++pattern;
	    if( *pattern == '\0' )
		return( 0 );
	    while( *pattern != *string ) {
		if( pattern[0] == '-' && pattern[-1] != '\\')
		    if(	pattern[-1] <= *string &&
		        pattern[-1] != '[' &&
		       	pattern[ 1] >= *string &&
		        pattern[ 1] != ']' )
			break;
		++pattern;
		if( *pattern == '\0' || *pattern == ']' )
		    return( 0 );
	    }
	    /* skip to next character after closing bracket */
	    while( *pattern != '\0' && *pattern != ']' )
		++pattern;
	    break;
	case '\\':
	    /* escape special character */
	    ++pattern;
	    /* compare characters */
	    if( *pattern != *string )
		return( 0 );
	    break;
	default:
	    /* compare characters */
	    if( *pattern != *string )
		return( 0 );
	}
	++string;
    } while( *pattern++ != '\0' );
    return( 1 );
}

/*
 *			R E G E X P _ M A T C H _ A L L
 *
 * Appends a list of all database matches to the given vls, or the pattern
 * itself if no matches are found.
 * Returns the number of matches.
 *
 */
 
int
regexp_match_all( dest, pattern )
struct bu_vls *dest;
char *pattern;
{
    register int i, num;
    register struct directory *dp;

    for( i = num = 0; i < RT_DBNHASH; i++ )  {
	for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw ){
	    if( !regexp_match( pattern, dp->d_namep ) )
		continue;
	    if( num == 0 )
		bu_vls_strcat( dest, dp->d_namep );
	    else {
		bu_vls_strcat( dest, " " );
		bu_vls_strcat( dest, dp->d_namep );
	    }
	    ++num;
	}
    }

    return num;
}


/*
d452 1
a452 1
			if( !regexp_match( word, dp->d_namep ) )
d581 1
a581 1
	        if( !regexp_match( pattern, dp->d_namep ) )
@


11.39
log
@modify calls to Tcl_Eval
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.38 1997/04/16 20:23:49 bparker Exp bparker $ (BRL)";
d973 23
a995 18
	if( localunit == ID_NO_UNIT)
		bu_vls_strcat( &units, "none");

	if( localunit == ID_MM_UNIT)
		bu_vls_strcat( &units, "mm");

	if( localunit == ID_CM_UNIT)
		bu_vls_strcat( &units, "cm");

	if( localunit == ID_M_UNIT)
		bu_vls_strcat( &units, "m");

	if( localunit == ID_IN_UNIT)
		bu_vls_strcat( &units, "in");

	if( localunit == ID_FT_UNIT)
		bu_vls_strcat( &units, "ft");

@


11.38
log
@mods so that commands check args internally
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.37 1997/04/14 12:30:08 bparker Exp bparker $ (BRL)";
d188 6
a193 1
    Tcl_Eval(interp, "help memprint");
d451 6
a456 1
	  Tcl_Eval(interp, "help tops");
d639 6
a644 1
      Tcl_Eval(interp, "help expand");
d748 6
a753 1
    Tcl_Eval(interp, "help find");
d835 6
a840 1
	  Tcl_Eval(interp, "help prefix");
d939 6
a944 1
	  Tcl_Eval(interp, "help keep");
d1030 6
a1035 1
    Tcl_Eval(interp, "help tree");
d1216 6
a1221 1
	  Tcl_Eval(interp, "help mvall");
d1343 6
a1348 1
	  Tcl_Eval(interp, "help killall");
d1433 6
a1438 1
	  Tcl_Eval(interp, "help killtree");
d1483 6
a1488 1
    Tcl_Eval(interp, "help debugdir");
@


11.37
log
@now calling eraseobjall()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.36 1997/03/25 14:43:44 jra Exp bparker $ (BRL)";
d120 7
a126 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d128 1
d187 2
a188 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d190 1
d445 2
a446 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d448 1
d628 2
a629 1
    if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d631 1
d732 2
a733 1
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d735 1
d814 2
a815 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d817 1
d913 2
a914 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d916 1
d999 5
d1180 2
a1181 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1183 1
d1302 4
a1305 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
		return TCL_ERROR;
d1387 2
a1388 1
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
d1390 1
d1432 4
a1435 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d1437 2
a1438 2
	db_pr_dir( dbip );
	return TCL_OK;
@


11.36
log
@Mods to support MGED's read-only mode.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.35 1997/03/20 14:47:30 bparker Exp jra $ (BRL)";
d1388 1
a1388 1
	eraseobj( dp );
@


11.35
log
@*** empty log message ***
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.34 1997/03/12 20:45:46 jra Exp bparker $ (BRL)";
d797 2
d1154 2
d1274 2
d1356 2
@


11.34
log
@removed dependencies on db.h.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.33 1997/02/20 21:45:02 jra Exp jra $ (BRL)";
d716 1
a716 1
  register struct rt_db_internal intern;
@


11.33
log
@converted to using comb import/export.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.32 1997/02/14 13:13:12 jra Exp jra $ (BRL)";
a52 1
#include "db.h"
@


11.32
log
@Mods for db_tree_funcleaf() using 3 user pointers. And use bu_strdup() to assign values to tr_l.tl_nam.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.31 1997/02/06 15:38:04 jra Exp jra $ (BRL)";
a1004 1
  union record	*rp;
d1007 2
a1009 5
  if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ){
    TCL_READ_ERR;
    return;
  }

d1031 1
a1031 2
  if( !(dp->d_flags & DIR_COMB) )  {
    bu_free( (genptr_t)rp, "printnode recs");
a1032 1
  }
d1038 62
a1099 6
  for( i=1; i < dp->d_len; i++ )  {
    if( (nextdp = db_lookup( dbip, rp[i].M.m_instname, LOOKUP_NOISY ))
	== DIR_NULL )
  	/* XXX It's legit to refer to a leaf which hasn't been defined yet. */
  	/* XXX Just print the name here without grumbling.  Maybe note it with a special suffix.  -Mike */
      continue;
d1101 6
a1106 2
    prefix = rp[i].M.m_relation;
    printnode ( nextdp, pathpos+1, prefix );
d1108 1
a1108 1
  bu_free( (genptr_t)rp, "printnode recs");
d1357 1
a1357 1
        else
d1378 1
a1378 1
  Tcl_AppendResult(interp, "KILL ", (dp->d_flags & DIR_COMB) ? "COMB" : "Solid",
d1381 1
a1381 1
  eraseobj( dp );
d1383 3
a1385 3
  if( db_delete( dbip, dp) < 0 || db_dirdelete( dbip, dp ) < 0 ){
    TCL_DELETE_ERR("");
  }
d1395 2
a1396 2
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;
d1398 2
a1399 2
  db_pr_dir( dbip );
  return TCL_OK;
@


11.31
log
@More changes to using combination import/export (printnode still needs changing).
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.30 1997/01/31 16:27:50 jra Exp jra $ (BRL)";
d193 1
a193 1
Count_refs( dbip, comb, comb_leaf, user_ptr1, user_ptr2 )
d197 1
a197 1
genptr_t		user_ptr1, user_ptr2;
d237 1
a237 1
			db_tree_funcleaf( dbip, comb, comb->tree, Count_refs, (genptr_t)NULL, (genptr_t)NULL );
d681 1
a681 1
Find_ref( dbip, comb, comb_leaf, object, comb_name_ptr )
d687 1
d744 1
a744 1
	    	db_tree_funcleaf( dbip, comb, comb->tree, Find_ref, (genptr_t)argv[k], dp->d_namep );
d755 1
a755 1
Do_prefix( dbip, comb, comb_leaf, prefix_ptr, obj_ptr )
d759 1
a759 1
genptr_t		prefix_ptr, obj_ptr;
d775 2
a776 1
	(void)strncpy( comb_leaf->tr_l.tl_name, tempstring, NAMESIZE );
d850 1
a850 1
					(genptr_t)argv[1], (genptr_t)argv[k] );
d1076 2
a1077 1
	strncpy( comb_leaf->tr_l.tl_name, new_name, NAMESIZE );
d1162 2
a1163 1
					strncpy( comb_leaf->tr_l.tl_name, argv[2], NAMESIZE );
@


11.30
log
@Converted "prefix" and "keep" commands to using import/export for combinations.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.29 1997/01/31 05:35:12 mike Exp jra $ (BRL)";
d1056 21
a1090 1
	register union record *rp;
d1092 3
a1094 1
	union record	record;
d1125 4
a1128 2
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 ) {
	  TCL_READ_ERR_return;
d1130 2
a1131 4
	NAMEMOVE( argv[2], record.c.c_name );
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 ) {
	  TCL_WRITE_ERR_return;
	}
d1136 4
d1142 32
a1173 2
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ) {
			  TCL_READ_ERR_return;
d1175 8
a1182 13
			/* [0] is COMB, [1..n] are MEMBERs */
			for( j=1; j < dp->d_len; j++ )  {
				if( rp[j].M.m_instname[0] == '\0' )
					continue;
				for( k=2; k<argc; k++ )  {
					if( strncmp( rp[j].M.m_instname,
					    argv[1], NAMESIZE) != 0 )
						continue;
					(void)strncpy(rp[j].M.m_instname,
						argv[2], NAMESIZE);
					if( db_put( dbip, dp, rp, 0, dp->d_len ) < 0 ) {
					  TCL_WRITE_ERR_return;
					}
d1185 2
a1186 1
			bu_free( (genptr_t)rp, "dir_nref recs" );
d1189 1
@


11.29
log
@Added note
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.28 1997/01/31 05:00:07 mike Exp mike $ (BRL)";
d753 24
a790 1
	register union record *rp;
d792 2
d841 10
a850 21
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ) {
			  TCL_READ_ERR_return;
			}
			/* [0] is COMB, [1..n] are MEMBERs */
			for( j=1; j < dp->d_len; j++ )  {
				if( rp[j].M.m_instname[0] == '\0' )
					continue;
				for( k=2; k<argc; k++ )  {
					if( strncmp( rp[j].M.m_instname,
					    argv[k], NAMESIZE) != 0 )
						continue;
					(void)strcpy( tempstring, argv[1]);
					(void)strcat( tempstring, argv[k]);
					(void)strncpy(rp[j].M.m_instname,
						tempstring, NAMESIZE);
					if( db_put( dbip, dp, rp, 0, dp->d_len ) < 0 ) {
					  TCL_WRITE_ERR_return;
					}
				}
			}
			bu_free( (genptr_t)rp, "dir_nref recs" );
d869 1
a869 1
	register union record	*rp;
d875 1
a875 1
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
d877 2
a878 4
	want = dp->d_len*sizeof(union record);
	if( fwrite( (char *)rp, want, 1, keepfp ) != 1 )
		perror("keep fwrite");
	bu_free( (genptr_t)rp, "keep rec[]" );
@


11.28
log
@renamed comb_functree() to db_tree_funcleaf().
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.27 1997/01/31 04:56:04 mike Exp mike $ (BRL)";
d1033 2
@


11.27
log
@JRA conversion to new import/export routines.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.26 1997/01/30 02:18:36 mike Exp jra $ (BRL)";
d237 1
a237 1
			comb_functree( dbip, comb, comb->tree, Count_refs, (genptr_t)NULL, (genptr_t)NULL );
d743 1
a743 1
	    	comb_functree( dbip, comb, comb->tree, Find_ref, (genptr_t)argv[k], dp->d_namep );
@


11.26
log
@Eliminated rt_get_comb
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.25 1997/01/29 01:43:59 mike Exp mike $ (BRL)";
d192 16
d217 1
a217 2
	register int		j;
	register union record	*rp;
d219 2
a220 2
	register struct directory *newdp;
	register int		i;
d233 6
a238 11
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
				READ_ERR_return;
			/* [0] is COMB, [1..n] are MEMBERs */
			for( j=1; j < dp->d_len; j++ )  {
				if( rp[j].M.m_instname[0] == '\0' )
					continue;
				if( (newdp = db_lookup( dbip, rp[j].M.m_instname,
				    LOOKUP_QUIET)) != DIR_NULL )
					newdp->d_nref++;
			}
			bu_free( (genptr_t)rp, "dir_nref recs" );
d680 22
d716 2
a717 1
  register union record	*rp = (union record *)NULL;
d725 2
a726 3
    if(rp)
      bu_free( (genptr_t)rp, "dir_nref recs" );

d735 11
a745 18
      if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ) {
	(void)signal( SIGINT, SIG_IGN );
	TCL_READ_ERR_return;
      }
      /* [0] is COMB, [1..n] are MEMBERs */
      for( j=1; j < dp->d_len; j++ )  {
	if( rp[j].M.m_instname[0] == '\0' )
	  continue;
	for( k=0; k<argc; k++ )  {
	  if( strncmp( rp[j].M.m_instname,
		       argv[k], NAMESIZE) != 0 )
	    continue;
	  Tcl_AppendResult(interp, rp[j].M.m_instname,
			   ":  member of ", rp[0].c.c_name,
			   "\n", (char *)NULL);
	}
      }
      bu_free( (genptr_t)rp, "dir_nref recs" );
@


11.25
log
@Converted "killall" command over to new import/export routines.
No longer uses db_delrec()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.24 1997/01/29 01:13:08 mike Exp mike $ (BRL)";
d1139 2
a1140 2
			if( rt_get_comb( &intern, dp, (mat_t *)NULL, dbip ) < 0 )  {
				Tcl_AppendResult(interp, "rt_get_comb(", dp->d_namep,
@


11.24
log
@Ran CB on function I'm about to edit.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.23 1996/10/22 21:10:18 bparker Exp mike $ (BRL)";
d1115 1
a1115 2
	register int	i,j,k;
	register union record *rp = (union record *)NULL;
d1117 3
d1127 1
a1127 3
		if(rp)
			bu_free( (genptr_t)rp, "dir_nref recs" );

d1131 2
d1138 6
a1143 4
again:
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ) {
				(void)signal( SIGINT, SIG_IGN );
				TCL_READ_ERR_return;
d1145 2
a1146 8
			/* [0] is COMB, [1..n] are MEMBERs */
			for( j=1; j < dp->d_len; j++ )  {
				if( rp[j].M.m_instname[0] == '\0' )
					continue;
				for( k=1; k<argc; k++ )  {
					if( strncmp( rp[j].M.m_instname,
					    argv[k], NAMESIZE) != 0 )
						continue;
d1148 15
a1162 11
					/* Remove this reference */
					if( db_delrec( dbip, dp, j ) < 0 )  {
						Tcl_AppendResult(interp, "error in killing reference to '",
						    argv[k], "', exit MGED and retry\n", (char *)NULL);
						TCL_ERROR_RECOVERY_SUGGESTION;
						(void)signal( SIGINT, SIG_IGN );
						bu_free( (genptr_t)rp, "dir_nref recs" );
						return TCL_ERROR;
					}
					bu_free( (genptr_t)rp, "dir_nref recs" );
					goto again;
d1165 6
a1170 1
			bu_free( (genptr_t)rp, "dir_nref recs" );
d1172 5
@


11.23
log
@hacks to use latest libdm
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.22 1996/10/04 15:01:21 bparker Exp $ (BRL)";
d1115 3
a1117 3
  register int	i,j,k;
  register union record *rp = (union record *)NULL;
  register struct directory *dp;
d1119 2
a1120 2
  if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
    return TCL_ERROR;
d1122 5
a1126 5
  if( setjmp( jmp_env ) == 0 )
    (void)signal( SIGINT, sig3);  /* allow interupts */
  else{
    if(rp)
      bu_free( (genptr_t)rp, "dir_nref recs" );
d1128 2
a1129 2
    return TCL_OK;
  }
d1131 5
a1135 5
  /* Examine all COMB nodes */
  for( i = 0; i < RT_DBNHASH; i++ )  {
    for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
      if( !(dp->d_flags & DIR_COMB) )
	continue;
d1137 12
a1148 12
      if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ) {
	(void)signal( SIGINT, SIG_IGN );
	TCL_READ_ERR_return;
      }
      /* [0] is COMB, [1..n] are MEMBERs */
      for( j=1; j < dp->d_len; j++ )  {
	if( rp[j].M.m_instname[0] == '\0' )
	  continue;
	for( k=1; k<argc; k++ )  {
	  if( strncmp( rp[j].M.m_instname,
		       argv[k], NAMESIZE) != 0 )
	    continue;
d1150 15
a1164 11
	  /* Remove this reference */
	  if( db_delrec( dbip, dp, j ) < 0 )  {
	    Tcl_AppendResult(interp, "error in killing reference to '",
			     argv[k], "', exit MGED and retry\n", (char *)NULL);
	    TCL_ERROR_RECOVERY_SUGGESTION;
	    (void)signal( SIGINT, SIG_IGN );
	    bu_free( (genptr_t)rp, "dir_nref recs" );
	    return TCL_ERROR;
	  }
	  bu_free( (genptr_t)rp, "dir_nref recs" );
	  goto again;
a1165 4
      }
      bu_free( (genptr_t)rp, "dir_nref recs" );
    }
  }
d1167 5
a1171 5
  /* ALL references removed...now KILL the object[s] */
  /* reuse argv[] */
  argv[0] = "kill";
  (void)signal( SIGINT, SIG_IGN );
  return f_kill( clientData, interp, argc, argv );
@


11.22
log
@-call vls_col_pr4v() instead of col_pr4v.
-cast bu_free's 1st argument to genptr_t.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.21 1996/10/03 20:50:43 bparker Exp bparker $ (BRL)";
d185 1
a185 1
  rt_memprint( &(dmp->dmr_map) );
@


11.21
log
@free allocated memory after interrupt
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.20 1996/10/01 17:26:29 bparker Exp bparker $ (BRL)";
d119 1
d124 1
d130 1
d161 4
a164 1
  col_pr4v( dirp0, (int)(dirp - dirp0));
a165 1
  (void)signal( SIGINT, SIG_IGN );
d228 1
a228 1
			bu_free( (char *)rp, "dir_nref recs" );
d352 1
d354 1
d360 1
d400 3
a402 2
	col_pr4v( dirp0, (int)(dirp - dirp0));
	bu_free( (char *)dirp0, "dir_getspace" );
d404 2
d425 1
d430 1
d435 2
a436 1
	    bu_free( (char *)dirp0, "dir_getspace" );
a458 2
	col_pr4v( dirp0, (int)(dirp - dirp0));
	bu_free( (char *)dirp0, "dir_getspace" );
d460 2
d463 2
d693 1
a693 1
      bu_free( (char *)rp, "dir_nref recs" );
d720 1
a720 1
      bu_free( (char *)rp, "dir_nref recs" );
d811 1
a811 1
			bu_free( (char *)rp, "dir_nref recs" );
d841 1
a841 1
	bu_free( (char *)rp, "keep rec[]" );
d997 1
a997 1
    bu_free( (char *)rp, "printnode recs");
d1013 1
a1013 1
  bu_free( (char *)rp, "printnode recs");
d1095 1
a1095 1
			bu_free( (char *)rp, "dir_nref recs" );
@


11.20
log
@ignore SIGINT
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.19 1996/09/25 20:10:14 bparker Exp bparker $ (BRL)";
d115 4
a118 4
	register struct directory *dp;
	register int i;
	struct directory **dirp, **dirp0;
	struct bu_vls	str;
d120 2
a121 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d123 5
a127 4
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);	/* allow interupts */
	else
	  return TCL_OK;
d129 2
a130 28
	if( argc > 1) {
		/* Just list specified names */
		dirp = dir_getspace( argc-1 );
		dirp0 = dirp;
		/*
		 * Verify the names, and add pointers to them to the array.
		 */
		for( i = 1; i < argc; i++ )  {
			if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY)) ==
			  DIR_NULL )
				continue;
			*dirp++ = dp;
		}
	} else {
		/* Full table of contents */
		dirp = dir_getspace(0);		/* Enough for all */
		dirp0 = dirp;
		/*
		 * Walk the directory list adding pointers (to the directory
		 * entries) to the array.
		 */
		for( i = 0; i < RT_DBNHASH; i++)
			for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
				*dirp++ = dp;
	}
	bu_vls_init( &str );
	vls_col_pr4v( &str, dirp0, (int)(dirp - dirp0));
	bu_free( (char *)dirp0, "dir_getspace dp[]" );
d132 30
a161 3
	Tcl_AppendResult(interp, bu_vls_strgrab(&str), (char *)NULL);
	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
d345 2
a346 1
	struct directory **dirp, **dirp0;
d350 4
a353 1
	else
d355 1
d374 5
a378 2
	if( flag == 0 )
		return;
d412 2
a413 1
	struct directory **dirp, **dirp0;
d420 4
a423 1
	else
d425 1
d666 6
a671 3
	register int	i,j,k;
	register struct directory *dp;
	register union record	*rp;
d673 5
a677 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d679 2
a680 4
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);	/* allow interupts */
	else
	  return TCL_OK;
d682 20
a701 23
	/* Examine all COMB nodes */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if( !(dp->d_flags & DIR_COMB) )
				continue;
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ) {
			  TCL_READ_ERR_return;
			}
			/* [0] is COMB, [1..n] are MEMBERs */
			for( j=1; j < dp->d_len; j++ )  {
				if( rp[j].M.m_instname[0] == '\0' )
					continue;
				for( k=0; k<argc; k++ )  {
					if( strncmp( rp[j].M.m_instname,
					    argv[k], NAMESIZE) != 0 )
						continue;
					Tcl_AppendResult(interp, rp[j].M.m_instname,
							 ":  member of ", rp[0].c.c_name,
							 "\n", (char *)NULL);
				}
			}
			bu_free( (char *)rp, "dir_nref recs" );
		}
d703 4
d708 2
a709 2
	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
a907 77
#ifdef OLD
/*
 *			F _ T R E E
 *
 *	Print out a list of all members and submembers of an object.
 */
void
f_tree(argc, argv)
int	argc;
char	**argv;
{
	register struct directory *dp;
	register int j;

	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;


	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;

	for ( j = 1; j < argc; j++) {
		if( j > 1 )
			bu_log( "\n" );
		if( (dp = db_lookup( dbip, argv[j], LOOKUP_NOISY )) == DIR_NULL )
			continue;
		printnode(dp, 0, 0);
	}

	(void)signal( SIGINT, SIG_IGN );
}

/*
 *			P R I N T N O D E
 */
static void
printnode( dp, pathpos, cont )
register struct directory *dp;
int pathpos;
int cont;		/* non-zero when continuing partly printed line */
{	
	union record	*rp;
	register int	i;
	register struct directory *nextdp;

	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
		READ_ERR_return;

	if( !cont ) {
		for( i=0; i<(pathpos*(NAMESIZE+2)); i++) 
			bu_putchar(' ');
		cont = 1;
	}
	bu_log("| %s", dp->d_namep);
	if( !(dp->d_flags & DIR_COMB) )  {
		bu_log( "\n" );
		return;
	}


	/*
	 *  This node is a combination (eg, a directory).
	 *  Process all the arcs (eg, directory members).
	 */
	i = NAMESIZE - strlen(dp->d_namep);
	while( i-- > 0 )
		bu_putchar('_');

	if( dp->d_len <= 1 )
		bu_log("\n");		/* empty combination */

	for( i=1; i < dp->d_len; i++ )  {
		if( (nextdp = db_lookup( dbip, rp[i].M.m_instname, LOOKUP_NOISY ))
		    == DIR_NULL )
			continue;
a908 6
		printnode ( nextdp, pathpos+1, cont );
		cont = 0;
	}
	bu_free( (char *)rp, "printnode recs");
}
#else
d921 2
a922 2
	register struct directory *dp;
	register int j;
d924 4
a927 5
	
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;
d929 7
a935 7
	for ( j = 1; j < argc; j++) {
		if( j > 1 )
		  Tcl_AppendResult(interp, "\n", (char *)NULL);
		if( (dp = db_lookup( dbip, argv[j], LOOKUP_NOISY )) == DIR_NULL )
			continue;
		printnode(dp, 0, 0);
	}
d937 2
a938 2
	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
d950 49
a998 29
	union record	*rp;
	register int	i;
	register struct directory *nextdp;

	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ){
	  TCL_READ_ERR;
	  return;
	}

	for( i=0; i<pathpos; i++) 
	  Tcl_AppendResult(interp, "\t", (char *)NULL);

	if( prefix ) {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "%c ", prefix);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	}

	Tcl_AppendResult(interp, dp->d_namep, (char *)NULL);
	/* Output Comb and Region flags (-F?) */
	if( dp->d_flags & DIR_COMB )
	  Tcl_AppendResult(interp, "/", (char *)NULL);
	if( dp->d_flags & DIR_REGION )
	  Tcl_AppendResult(interp, "R", (char *)NULL);

	Tcl_AppendResult(interp, "\n", (char *)NULL);
a999 19
	if( !(dp->d_flags & DIR_COMB) )  {
		return;
	}

	/*
	 *  This node is a combination (eg, a directory).
	 *  Process all the arcs (eg, directory members).
	 */
	for( i=1; i < dp->d_len; i++ )  {
		if( (nextdp = db_lookup( dbip, rp[i].M.m_instname, LOOKUP_NOISY ))
		    == DIR_NULL )
			continue;

		prefix = rp[i].M.m_relation;
		printnode ( nextdp, pathpos+1, prefix );
	}
	bu_free( (char *)rp, "printnode recs");
}
#endif
d1099 6
a1104 3
	register int	i,j,k;
	register union record *rp;
	register struct directory *dp;
d1106 5
a1110 2
	if(mged_cmd_arg_check(argc, argv, (struct funtab *)NULL))
	  return TCL_ERROR;
d1112 2
a1113 4
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;
d1115 5
a1119 5
	/* Examine all COMB nodes */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if( !(dp->d_flags & DIR_COMB) )
				continue;
d1121 12
a1132 12
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 ) {
			  (void)signal( SIGINT, SIG_IGN );
			  TCL_READ_ERR_return;
			}
			/* [0] is COMB, [1..n] are MEMBERs */
			for( j=1; j < dp->d_len; j++ )  {
				if( rp[j].M.m_instname[0] == '\0' )
					continue;
				for( k=1; k<argc; k++ )  {
					if( strncmp( rp[j].M.m_instname,
					    argv[k], NAMESIZE) != 0 )
						continue;
d1134 11
a1144 13
					/* Remove this reference */
					if( db_delrec( dbip, dp, j ) < 0 )  {
					  Tcl_AppendResult(interp, "error in killing reference to '", argv[k], "', exit MGED and retry\n", (char *)NULL);
					  TCL_ERROR_RECOVERY_SUGGESTION;
					  (void)signal( SIGINT, SIG_IGN );
					  return TCL_ERROR;
					}
					bu_free( (char *)rp, "dir_nref recs" );
					goto again;
				}
			}
			bu_free( (char *)rp, "dir_nref recs" );
		}
d1146 4
d1151 5
a1155 5
	/* ALL references removed...now KILL the object[s] */
	/* reuse argv[] */
	argv[0] = "kill";
	(void)signal( SIGINT, SIG_IGN );
	return f_kill( clientData, interp, argc, argv );
@


11.19
log
@include mged_solid.h
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.18 1996/09/23 18:32:00 bparker Exp bparker $ (BRL)";
d158 1
d384 1
d433 1
d687 2
d918 2
d1001 1
d1181 1
d1197 1
d1211 1
d1245 1
@


11.18
log
@changed dm.h to mged_dm.h
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.17 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
d57 1
a57 1
#include "./solid.h"
@


11.17
log
@rt_list ---> bu_list
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.16 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d58 1
a58 1
#include "./dm.h"
@


11.16
log
@now using libbu
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.15 1996/08/22 21:04:50 bparker Exp bparker $ (BRL)";
d51 1
a53 1
#include "rtstring.h"
@


11.15
log
@now calling regexp_match with two parameters instead of three.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.14 1996/07/15 20:36:49 bparker Exp bparker $ (BRL)";
d84 1
a84 1
		rt_log( "dir_getspace: was passed %d, used 0\n",
d96 1
a96 1
	dir_basep = (struct directory **) rt_malloc(
d118 1
a118 1
	struct rt_vls	str;
d153 1
a153 1
	rt_vls_init( &str );
d155 1
a155 1
	rt_free( (char *)dirp0, "dir_getspace dp[]" );
d157 1
a157 1
	Tcl_AppendResult(interp, rt_vls_strgrab(&str), (char *)NULL);
d220 1
a220 1
			rt_free( (char *)rp, "dir_nref recs" );
d305 1
a305 1
struct rt_vls *dest;
d316 1
a316 1
		rt_vls_strcat( dest, dp->d_namep );
d318 2
a319 2
		rt_vls_strcat( dest, " " );
		rt_vls_strcat( dest, dp->d_namep );
d361 4
a364 4
	rt_log("Summary:\n");
	rt_log("  %5d solids\n", sol);
	rt_log("  %5d region; %d non-region combinations\n", reg, comb);
	rt_log("  %5d total objects\n\n", sol+reg+comb );
d382 1
a382 1
	rt_free( (char *)dirp0, "dir_getspace" );
d429 1
a429 1
	rt_free( (char *)dirp0, "dir_getspace" );
d498 1
a498 1
				rt_log("%s: expansion stopped after %d matches (%d args)\n",
d681 1
a681 1
			rt_free( (char *)rp, "dir_nref recs" );
d716 1
a716 1
		  struct rt_vls tmp_vls;
d718 2
a719 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "'%s%s' too long, must be less than %d characters.\n",
d721 2
a722 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d770 1
a770 1
			rt_free( (char *)rp, "dir_nref recs" );
d800 1
a800 1
	rt_free( (char *)rp, "keep rec[]" );
d811 2
a812 2
	struct rt_vls		title;
	struct rt_vls		units;
d837 3
a839 3
	rt_vls_init( &title );
	rt_vls_strcat( &title, "Parts of: " );
	rt_vls_strcat( &title, dbip->dbi_title );
d841 1
a841 1
	rt_vls_init( &units);
d844 1
a844 1
		rt_vls_strcat( &units, "none");
d847 1
a847 1
		rt_vls_strcat( &units, "mm");
d850 1
a850 1
		rt_vls_strcat( &units, "cm");
d853 1
a853 1
		rt_vls_strcat( &units, "m");
d856 1
a856 1
		rt_vls_strcat( &units, "in");
d859 1
a859 1
		rt_vls_strcat( &units, "ft");
d861 1
a861 1
	if( mk_id_units( keepfp, rt_vls_addr(&title), rt_vls_addr(&units) ) < 0 )  {
d865 2
a866 2
		rt_vls_free( &title );
		rt_vls_free( &units );
d877 2
a878 2
	rt_vls_free( &title );
	rt_vls_free( &units );
d908 1
a908 1
			rt_log( "\n" );
d933 1
a933 1
			rt_putchar(' ');
d936 1
a936 1
	rt_log("| %s", dp->d_namep);
d938 1
a938 1
		rt_log( "\n" );
d949 1
a949 1
		rt_putchar('_');
d952 1
a952 1
		rt_log("\n");		/* empty combination */
d962 1
a962 1
	rt_free( (char *)rp, "printnode recs");
d1019 1
a1019 1
	  struct rt_vls tmp_vls;
d1021 4
a1024 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "%c ", prefix);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d1052 1
a1052 1
	rt_free( (char *)rp, "printnode recs");
d1078 1
a1078 1
	  struct rt_vls tmp_vls;
d1080 4
a1083 4
	  rt_vls_init(&tmp_vls);
	  rt_vls_printf(&tmp_vls, "ERROR: name length limited to %d characters\n", NAMESIZE);
	  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
	  rt_vls_free(&tmp_vls);
d1134 1
a1134 1
			rt_free( (char *)rp, "dir_nref recs" );
d1190 1
a1190 1
					rt_free( (char *)rp, "dir_nref recs" );
d1194 1
a1194 1
			rt_free( (char *)rp, "dir_nref recs" );
@


11.14
log
@*** empty log message ***
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.13 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d615 1
a615 1
		if( !regexp_match( pattern, dp->d_namep, "*?[]" ) )
@


11.13
log
@Still Tcl'ing the code
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.12 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
a1104 1
	  return TCL_ERROR;
a1108 1
	  return TCL_ERROR;
a1130 1
					  return TCL_ERROR;
@


11.12
log
@still tcl-converting
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.11 1996/04/18 20:28:43 bparker Exp bparker $ (BRL)";
d123 4
a126 1
	(void)signal( SIGINT, sig2);	/* allow interupts */
d344 4
a347 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
d405 4
a408 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
d655 4
a658 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
d900 5
a904 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
d980 5
a984 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
d1164 4
a1167 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
d1226 4
a1229 1
	(void)signal( SIGINT, sig2);    /* allow interupts */
@


11.11
log
@convert commands to Tcl
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.10 1996/03/01 19:32:07 bparker Exp bparker $ (BRL)";
d1180 1
@


11.10
log
@remove unused XMGED stuff
./
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.9 1995/09/22 02:51:01 mike Exp bparker $ (BRL)";
d120 3
d154 1
a154 1
	Tcl_SetResult(interp, rt_vls_strgrab(&str), TCL_DYNAMIC );
d164 3
a166 1
f_memprint(argc, argv)
d170 7
a176 4
	rt_log("Display manager free map:\n");
	rt_memprint( &(dmp->dmr_map) );
	rt_log("Database free granule map:\n");
	rt_memprint( &(dbip->dbi_freep) );
d178 1
a178 1
	return CMD_OK;
d386 3
a388 1
f_tops(argc, argv)
d396 3
d422 1
a422 1
	return CMD_OK;
d565 3
d633 3
a635 1
f_find(argc, argv)
d643 3
d654 1
a654 2
				READ_ERR;
				return CMD_BAD;
d664 3
a666 3
					rt_log("%s:  member of %s\n",
						rp[j].M.m_instname,
						rp[0].c.c_name );
d672 1
a672 1
	return CMD_OK;
d682 3
a684 1
f_prefix(argc, argv)
d693 3
d704 10
a713 5
			rt_log("'%s%s' too long, must be less than %d characters.\n",
				argv[1], argv[i],
				NAMESIZE);
			argv[i] = "";
			continue;
d726 4
a729 3
			rt_log("error in rename to %s, aborting\n", tempstring );
			ERROR_RECOVERY_SUGGESTION;
			return CMD_BAD;
d739 1
a739 2
				READ_ERR;
				return CMD_BAD;
d754 1
a754 2
						WRITE_ERR;
						return CMD_BAD;
d761 1
a761 1
	return CMD_OK;
d792 3
a794 1
f_keep(argc, argv)
d803 3
d814 3
a816 2
		rt_log("keep:  appending to '%s'\n", argv[1] );
		fclose(keepfp);
d821 1
a821 1
		return CMD_BAD;
d851 1
a851 1
		rt_log("mk_id_units() failed\n");
d855 1
a855 1
		return CMD_BAD;
d868 1
a868 1
	return CMD_OK;
d885 3
d955 3
a957 1
f_tree(argc, argv)
d968 1
a968 1
			rt_log( "\n" );
d974 1
a974 1
	return CMD_OK;
d990 4
a993 2
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
		READ_ERR_return;
d996 2
a997 1
		rt_putchar('\t');
d999 6
a1004 2
		rt_putchar(prefix);
		rt_putchar(' ');
d1007 1
a1007 1
	rt_log("%s", dp->d_namep);
d1010 1
a1010 1
		rt_putchar('/');
d1012 1
a1012 2
		rt_putchar('R');
	rt_log("\n");
d1014 2
d1043 3
a1045 1
f_mvall(argc, argv)
d1054 3
d1058 7
a1064 3
		rt_log("ERROR: name length limited to %d characters\n",
				NAMESIZE);
		return CMD_BAD;
d1069 1
a1069 1
		return CMD_BAD;
d1071 2
a1072 2
		aexists( argv[2]);
		return CMD_BAD;
d1076 4
a1079 3
		rt_log("error in rename to %s, aborting\n", argv[2] );
		ERROR_RECOVERY_SUGGESTION;
		return CMD_BAD;
d1084 2
a1085 2
		READ_ERR;
		return CMD_BAD;
d1089 2
a1090 2
		WRITE_ERR;
		return CMD_BAD;
d1099 1
a1099 2
				READ_ERR;
				return CMD_BAD;
d1112 2
a1113 2
						WRITE_ERR;
						return CMD_BAD;
d1120 1
a1120 1
	return CMD_OK;
d1131 3
a1133 1
f_killall(argc, argv)
d1141 3
d1153 1
a1153 2
				READ_ERR;
				return CMD_BAD;
d1166 3
a1168 4
						rt_log("error in killing reference to '%s', exit MGED and retry\n",
							argv[k]);
						ERROR_RECOVERY_SUGGESTION;
						return CMD_BAD;
d1180 1
a1180 1
	return f_kill( argc, argv );
d1190 3
a1192 1
f_killtree(argc, argv)
d1199 3
d1210 1
a1210 1
	return CMD_OK;
d1221 8
a1228 6
	rt_log("KILL %s:  %s\n",
		(dp->d_flags & DIR_COMB) ? "COMB" : "Solid",
		dp->d_namep );
	eraseobj( dp );
	if( db_delete( dbip, dp) < 0 || db_dirdelete( dbip, dp ) < 0 )
		DELETE_ERR_return("");
d1232 3
a1234 1
f_debugdir( argc, argv )
d1238 5
a1242 2
	db_pr_dir( dbip );
	return CMD_OK;
@


11.9
log
@Changed to set TCL return properly.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dir.c,v 11.8 1995/09/22 02:17:40 mike Exp mike $ (BRL)";
a119 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint);	/* allow interupts */
#else
a120 1
#endif
a332 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );	/* allow interupts */
#else
a333 1
#endif
a385 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );	/* allow interupts */
#else
a386 1
#endif
a624 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );	/* allow interupts */
#else
a625 1
#endif
a849 3
#ifdef XMGED
	(void) signal( SIGINT, cur_sigint);  /* Allow interrupts */
#else
a850 1
#endif
a923 3
#ifdef XMGED
	(void) signal( SIGINT, cur_sigint);  /* Allow interrupts */
#else
a924 1
#endif
a1081 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );	/* allow interupts */
#else
a1082 1
#endif
a1136 3
#ifdef XMGED
	(void)signal( SIGINT, cur_sigint );	/* allow interupts */
#else
a1137 1
#endif
@


11.8
log
@Finished converting dir_print() over to TCL.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dir.c,v 11.7 1995/09/09 02:02:45 butler Exp mike $ (BRL)";
d155 1
a155 1
	Tcl_SetResult(interp, rt_vls_addr(&str), TCL_VOLATILE );
@


11.7
log
@Converted f_list to cmd_list with TCL interface.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dir.c,v 11.6 1995/08/03 02:39:33 mike Exp butler $ (BRL)";
d118 1
d151 2
a152 1
	col_pr4v( dirp0, (int)(dirp - dirp0));
d155 2
a156 1
	return CMD_OK;
@


11.6
log
@Wrong args to regexp_match().
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dir.c,v 11.5 1995/08/02 21:31:56 gdurf Exp mike $ (BRL)";
d48 1
d109 3
a111 1
dir_print(argc, argv)
@


11.5
log
@Added include of mgedtcl.h
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.4 1995/07/26 13:22:34 gdurf Exp gdurf $ (BRL)";
d596 1
a596 1
		if( !regexp_match( pattern, dp->d_namep, '*', '?', '[', ']' ) )
@


11.4
log
@Removed #ifndef XMGED wrappers
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.3 1995/06/22 14:37:54 gdurf Exp gdurf $ (BRL)";
d47 2
d54 1
a55 1
#include "externs.h"
d58 1
a58 2

#include "tcl.h"
@


11.3
log
@Fixed expand command
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 11.2 1995/01/17 13:04:30 bparker Exp gdurf $ (BRL)";
a56 1
#ifndef XMGED
a57 2
#endif

a515 1
#ifndef XMGED
a614 2

#endif
@


11.2
log
@merging xmged sources
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/xmged/RCS/dir.c,v 11.2 95/01/17 11:42:11 bparker Exp $ (BRL)";
d57 5
d228 2
a229 2
regexp_match(	 pattern, string )
register char	*pattern, *string;
d231 26
a256 15
	do {
		switch( *pattern ) {
		case '*': /*
			   * match any string including null string
			   */
			++pattern;
			do {
				if( regexp_match( pattern, string ) )
					 return( 1 );
			} while( *string++ != '\0' );
			return( 0 );
		case '?': /*
			   * match any character
			   */
			if( *string == '\0' )	return( 0 );
d258 55
a312 14
		case '[': /*
			   * try to match one of the characters in brackets
			   */
			++pattern;
			while( *pattern != *string ) {
				if(	pattern[ 0] == '-'
				    &&	pattern[-1] != '\\'
				)	if(	pattern[-1] <= *string
					    &&	pattern[-1] != '['
					    &&	pattern[ 1] >= *string
					    &&	pattern[ 1] != ']'
					)	break;
				if( *++pattern == ']' )	return( 0 );
			}
d314 1
a314 18
			/* skip to next character after closing bracket
			 */
			while( *++pattern != ']' );
			break;
		case '\\': /*
			    * escape special character
			    */
			++pattern;
			/* WARNING: falls through to default case */
		default:  /*
			   * compare characters
			   */
			if( *pattern != *string )	return( 0 );
			break;
		}
		++string;
	} while( *pattern++ != '\0' );
	return( 1 );
d317 1
d424 1
a424 1
 *  the argv[] array contains "*", "?", "[", or "\" then this word
d518 103
@


11.1
log
@Release_4.4
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.11 94/12/27 16:58:48 mike Exp $ (BRL)";
d113 3
d117 1
d292 5
a296 1
	(void)signal( SIGINT, sig2 );	/* allow interupts */
d349 5
a353 1
	(void)signal( SIGINT, sig2 );	/* allow interupts */
d492 5
a496 1
	(void)signal( SIGINT, sig2 );	/* allow interupts */
d721 5
a725 1
	(void) signal( SIGINT, sig2);  /* Allow interrupts */
d799 5
a803 1
	(void) signal( SIGINT, sig2);  /* Allow interrupts */
d961 5
a965 1
	(void)signal( SIGINT, sig2 );	/* allow interupts */
d1020 5
a1024 1
	(void)signal( SIGINT, sig2 );	/* allow interupts */
@


10.11
log
@Fixed bug #247, added rt_ prefix to memalloc(), etc.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.10 94/12/23 21:57:14 gdurf Exp Locker: mike $ (BRL)";
@


10.10
log
@Added support for rt_putchar
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.9 1994/12/16 20:32:47 gdurf Exp gdurf $ (BRL)";
d157 1
a157 1
	memprint( &(dmp->dmr_map) );
d159 1
a159 1
	memprint( &(dbip->dbi_freep) );
@


10.9
log
@Converted putchar to rt_log
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.8 1994/12/16 19:35:53 gdurf Exp gdurf $ (BRL)";
d734 1
a734 1
			rt_log(" ");
d750 1
a750 1
		rt_log("_");
d809 1
a809 1
		rt_log("\t");
d811 2
a812 2
		rt_log("%c", prefix);
		rt_log(" ");
d818 1
a818 1
		rt_log("/");
d820 1
a820 1
		rt_log("R");
@


10.8
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.7 1994/11/05 03:48:07 mike Exp gdurf $ (BRL)";
d709 1
a709 1
			putchar( '\n' );
d734 1
a734 1
			putchar(' ');
d739 1
a739 1
		putchar( '\n' );
d750 1
a750 1
		putchar('_');
d753 1
a753 1
		putchar('\n');		/* empty combination */
d783 1
a783 1
			putchar( '\n' );
d809 1
a809 1
		putchar('\t');
d811 2
a812 2
		putchar(prefix);
		putchar(' ');
d818 1
a818 1
		putchar('/');
d820 2
a821 2
		putchar('R');
	putchar('\n');
@


10.7
log
@Irix 6
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.6 94/08/23 18:25:24 gdurf Exp Locker: mike $ (BRL)";
d80 1
a80 1
		(void) printf( "dir_getspace: was passed %d, used 0\n",
d156 1
a156 1
	(void)printf("Display manager free map:\n");
d158 1
a158 1
	(void)printf("Database free granule map:\n");
d302 4
a305 4
	(void)printf("Summary:\n");
	(void)printf("  %5d solids\n", sol);
	(void)printf("  %5d region; %d non-region combinations\n", reg, comb);
	(void)printf("  %5d total objects\n\n", sol+reg+comb );
d431 1
a431 1
				(void)printf("%s: expansion stopped after %d matches (%d args)\n",
d499 1
a499 1
					(void)printf("%s:  member of %s\n",
d534 1
a534 1
			printf("'%s%s' too long, must be less than %d characters.\n",
d551 1
a551 1
			printf("error in rename to %s, aborting\n", tempstring );
d635 1
a635 1
		(void)printf("keep:  appending to '%s'\n", argv[1] );
d671 1
a671 1
		(void)printf("mk_id_units() failed\n");
d737 1
a737 1
	printf("| %s", dp->d_namep);
d815 1
a815 1
	printf("%s", dp->d_namep);
d860 1
a860 1
		(void)printf("ERROR: name length limited to %d characters\n",
d874 1
a874 1
		printf("error in rename to %s, aborting\n", argv[2] );
d960 1
a960 1
						printf("error in killing reference to '%s', exit MGED and retry\n",
d1011 1
a1011 1
	(void)printf("KILL %s:  %s\n",
@


10.6
log
@Added missing return
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.5 1994/08/09 15:04:40 gdurf Exp gdurf $ (BRL)";
a935 2
	char combname[NAMESIZE+2];
	int len;
@


10.5
log
@Factored ifdefs
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.4 1994/06/13 19:05:39 gdurf Exp gdurf $ (BRL)";
d918 1
@


10.4
log
@Expunged cmd_args[] and numargs
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.3 1994/06/03 12:26:57 gdurf Exp gdurf $ (BRL)";
d36 2
d41 3
a43 1
#ifdef BSD
a44 2
#else
#include <string.h>
@


10.3
log
@a few bug fixes
@
text
@d12 1
a12 1
 *	cmd_glob	Does regular expression expansion on cmd_args[]
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.2 1994/06/01 16:00:44 gdurf Exp gdurf $ (BRL)";
d369 1
a369 1
 *  the cmd_args[] array contains "*", "?", "[", or "\" then this word
d376 1
a376 1
 *  All matches are sought for, up to the limit of the cmd_args[] array.
d381 4
a384 1
cmd_glob()
a385 2
	extern int numargs, maxargs;		/* defined in cmd.c */
	extern char *cmd_args[];		/* defined in cmd.c */
d391 1
a391 1
	int orig_numargs = numargs;
d393 1
a393 1
	strncpy( word, cmd_args[numargs], sizeof(word)-1 );
d415 1
a415 1
	 * cmd_args, as it will be overwritten by the expansions.
d418 1
a418 1
	 * into cmd_args.  Only in the case of no matches do we have
d428 1
a428 1
			if( numargs >= maxargs )  {
d430 1
a430 1
					word, numargs-orig_numargs, maxargs);
d433 1
a433 1
			cmd_args[numargs++] = dp->d_namep;
d436 1
a436 1
	/* If one or matches occurred, decrement final numargs,
d440 2
a441 2
	if( numargs > orig_numargs )  {
		numargs--;
d445 1
a445 1
		temp = pattern = cmd_args[numargs];
d458 2
a459 2
		if(*(cmd_args[numargs]) == '\0')
			numargs--;
@


10.2
log
@Converted f_ functions to use new command return codes.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 10.1 1991/10/12 06:43:16 mike Rel4_0 gdurf $ (BRL)";
d102 1
a102 1
void
d140 2
@


10.1
log
@Release_4.0
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.13 91/08/30 17:14:36 mike Exp $ (BRL)";
d147 1
a147 1
void
d156 2
d328 1
a328 1
void
d359 2
d466 1
a466 1
void
d482 4
a485 2
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
				READ_ERR_return;
d502 1
d511 1
a511 1
void
d548 1
a548 1
			return;
d557 4
a560 2
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
				READ_ERR_return;
d573 4
a576 2
					if( db_put( dbip, dp, rp, 0, dp->d_len ) < 0 )
						WRITE_ERR_return;
d582 1
d612 1
a612 1
void
d636 1
a636 1
		return;
d670 1
a670 1
		return;
d683 1
d766 1
a766 1
void
d783 2
d844 1
a844 1
void
d857 1
a857 1
		return;
d862 1
a862 1
		return;
d865 1
a865 1
		return;
d871 1
a871 1
		return;
d875 4
a878 1
	if( db_get( dbip,  dp, &record, 0 , 1) < 0 )  READ_ERR_return;
d880 4
a883 1
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  WRITE_ERR_return;
d890 4
a893 2
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
				READ_ERR_return;
d904 4
a907 2
					if( db_put( dbip, dp, rp, 0, dp->d_len ) < 0 )
						WRITE_ERR_return;
d922 1
a922 1
void
d941 4
a944 2
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
				READ_ERR_return;
d959 1
a959 1
						return;
d971 1
a971 1
	f_kill( argc, argv );
d980 1
a980 1
void
d995 2
d1015 1
a1015 1
void
d1021 1
@


9.13
log
@strlen returns unsigned
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.12 91/07/08 23:02:00 mike Exp $ (BRL)";
@


9.12
log
@Modified keep command to warn when appending.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.11 91/07/08 22:57:37 mike Exp $ (BRL)";
d521 1
a521 1
		if( strlen(argv[1]) + strlen(argv[i]) > NAMESIZE) {
d839 1
a839 1
	if( strlen(argv[2]) > NAMESIZE ) {
@


9.11
log
@global variable cleanup
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.10 91/07/03 15:09:48 stay Exp $ (BRL)";
d614 6
@


9.10
log
@fixed problem with a call to mk_id_units which required a string.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/mged/RCS/dir.c,v 9.9 91/07/01 02:06:03 mike Exp Locker: stay $ (BRL)";
a56 3
union record	record;
static union record zapper;		/* Zeros, for erasing records */

d831 1
@


9.9
log
@Changed "keep" command to use rt_vls to prevent buffer overflows,
and changed to use LIBWDB routines to make new ID record.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.8 91/01/15 01:39:14 mike Exp $ (BRL)";
d610 1
d628 22
a649 1
	if( mk_id_units( keepfp, rt_vls_addr(&title), localunit ) < 0 )  {
d654 1
d663 1
d666 2
@


9.8
log
@The "Keep" command now appends to the named database, rather
than deleting it and making a new one.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.7 90/12/08 00:31:12 mike Exp $ (BRL)";
d48 1
d609 1
d624 6
a629 6
	record.i.i_id = ID_IDENT;
	record.i.i_units = localunit;
	strcpy(record.i.i_version, ID_VERSION);
	sprintf(record.i.i_title, "Parts of: %s", cur_title);	/* XXX len */
	if( fwrite( (char *)&record, sizeof(record), 1, keepfp ) != 1 )  {
		perror("keep fwrite (ident)");
d631 1
d641 1
@


9.7
log
@Added error checking around calls to db_*() routines
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.6 90/12/07 19:58:51 mike Exp $ (BRL)";
d581 1
a581 1
static int	keepfd;
d597 3
a599 2
	if( write( keepfd, (char *)rp, want ) != want )
		perror("keep write");
d616 1
a616 1
	if( (keepfd = creat( argv[1], 0644 )) < 0 )  {
a621 1
	(void)lseek(keepfd, 0L, 0);
d626 5
a630 1
	(void)write(keepfd, (char *)&record, sizeof record);
d637 1
a637 1
	(void) close(keepfd);
@


9.6
log
@Modified to check error returns from db_put().
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.5 90/10/10 19:10:14 mike Exp $ (BRL)";
d187 1
a187 1
				continue;
d481 1
a481 1
				continue;
d542 1
d553 1
a553 1
				continue;
d566 2
a567 4
					if( db_put( dbip, dp, rp, 0, dp->d_len ) < 0 )  {
						printf("db_put error, aborting\n");
						return;
					}
d595 1
a595 1
		return;
d675 1
a675 1
		return;
d749 1
a749 1
		return;
d817 2
d822 1
a822 1
	(void)db_get( dbip,  dp, &record, 0 , 1);
d824 1
a824 4
	if( db_put( dbip, dp, &record, 0, 1 ) < 0 )  {
		printf("unable to update name, aborting\n");
		return;
	}
d832 1
a832 1
				continue;
d843 2
a844 4
					if( db_put( dbip, dp, rp, 0, dp->d_len ) < 0 )  {
						printf("db_put failure, aborting\n");
						return;
					}
d879 1
a879 1
				continue;
d891 3
a893 1
						printf("aborting\n");
d944 2
a945 2
	db_delete( dbip, dp);
	db_dirdelete( dbip, dp );
@


9.5
log
@Added "debugdir" command.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.4 90/05/22 23:17:26 mike Exp $ (BRL)";
d540 4
a543 2
		if( db_rename( dbip, dp, tempstring ) < 0 )
			printf("error in rename to %s\n", tempstring );
d565 4
a568 1
					(void)db_put( dbip, dp, rp, 0, dp->d_len );
d816 3
a818 2
	if( db_rename( dbip, dp, argv[2] ) < 0 )
		printf("error in rename to %s\n", argv[2] );
d823 4
a826 1
	(void)db_put( dbip, dp, &record, 0, 1 );
d845 4
a848 1
					(void)db_put( dbip, dp, rp, 0, dp->d_len );
d894 4
a897 1
					(void)db_delrec( dbip, dp, j );
@


9.4
log
@Fixed bug in killall.
Changed to argc/argv
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dir.c,v 9.3 89/12/28 16:10:50 mike Exp $ (BRL)";
d933 8
@


9.3
log
@Made MAXARGS local to cmd.c, global 'maxargs' is used to learn of size.
Improved error checking in command globbing.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: dir.c,v 9.2 89/12/28 15:53:53 mike Locked $ (BRL)";
a62 3
extern int numargs, maxargs;		/* defined in cmd.c */
extern char *cmd_args[];		/* defined in cmd.c */

d92 3
a94 4
	if( (dir_basep = (struct directory **) malloc( num_entries *
	  sizeof(dp))) == (struct directory **) 0) {
	  	(void) printf( "dir_getspace:  unable to allocate memory");
	}
d105 4
a108 1
dir_print() {
d115 1
a115 8
	/* Get some memory */
	if( (dirp = dir_getspace( numargs - 1)) == (struct directory **) 0) {
	  	(void) printf( "dir_print:  unable to get memory");
	  	return;
	}
	dirp0 = dirp;

	if( numargs > 1) {
d117 2
d122 2
a123 2
		for( i = 1; i < numargs; i++ )  {
			if( (dp = db_lookup( dbip, cmd_args[i], LOOKUP_NOISY)) ==
d130 2
d141 1
a141 1
	free( dirp0);
d150 3
a152 1
f_memprint()
d308 1
a308 4
	if( (dirp = dir_getspace(0)) == (struct directory **) 0) {
	  	(void) printf( "dir_summary:  unable to get memory");
	  	return;
	}
d319 1
a319 1
	free( dirp0);
d329 3
a331 1
f_tops()
d343 1
a343 4
	if( (dirp = dir_getspace(0)) == (struct directory **) 0) {
	  	(void) printf( "f_tops:  unable to get memory");
	  	return;
	}
d358 1
a358 1
	free( dirp0);
d379 2
d465 3
a467 1
f_find()
d486 1
a486 1
				for( k=0; k<numargs; k++ )  {
d488 1
a488 1
					    cmd_args[k], NAMESIZE) != 0 )
d507 3
a509 1
f_prefix()
d517 3
a519 3
	for( i = 2; i < numargs; i++) {
		if( (dp = db_lookup( dbip, cmd_args[i], LOOKUP_NOISY )) == DIR_NULL) {
			cmd_args[i] = "";
d523 1
a523 1
		if( strlen(cmd_args[1]) + strlen(cmd_args[i]) > NAMESIZE) {
d525 1
a525 1
				cmd_args[1], cmd_args[i],
d527 1
a527 1
			cmd_args[i] = "";
d531 2
a532 2
		(void) strcpy( tempstring, cmd_args[1]);
		(void) strcat( tempstring, cmd_args[i]);
d536 1
a536 1
			cmd_args[i] = "";
d555 1
a555 1
				for( k=2; k<numargs; k++ )  {
d557 1
a557 1
					    cmd_args[k], NAMESIZE) != 0 )
d559 2
a560 2
					(void)strcpy( tempstring, cmd_args[1]);
					(void)strcat( tempstring, cmd_args[k]);
d598 4
a601 1
f_keep() {
d611 2
a612 2
	if( (keepfd = creat( cmd_args[1], 0644 )) < 0 )  {
		perror( cmd_args[1] );
d624 2
a625 2
	for(i = 2; i < numargs; i++) {
		if( (dp = db_lookup( dbip, cmd_args[i], LOOKUP_NOISY)) == DIR_NULL )
d639 4
a642 1
f_tree() {
d648 1
a648 1
	for ( j = 1; j < numargs; j++) {
d651 1
a651 1
		if( (dp = db_lookup( dbip, cmd_args[j], LOOKUP_NOISY )) == DIR_NULL )
d713 4
a716 1
f_tree() {
d722 1
a722 1
	for ( j = 1; j < numargs; j++) {
d725 1
a725 1
		if( (dp = db_lookup( dbip, cmd_args[j], LOOKUP_NOISY )) == DIR_NULL )
d789 3
a791 1
f_mvall()
d797 1
a797 1
	if( strlen(cmd_args[2]) > NAMESIZE ) {
d804 1
a804 1
	if( (dp = db_lookup( dbip, cmd_args[1], LOOKUP_NOISY )) == DIR_NULL)
d806 2
a807 2
	if( db_lookup( dbip, cmd_args[2], LOOKUP_QUIET ) != DIR_NULL ) {
		aexists( cmd_args[2]);
d811 2
a812 2
	if( db_rename( dbip, dp, cmd_args[2] ) < 0 )
		printf("error in rename to %s\n", cmd_args[2] );
d816 1
a816 1
	NAMEMOVE( cmd_args[2], record.c.c_name );
d830 1
a830 1
				for( k=2; k<numargs; k++ )  {
d832 1
a832 1
					    cmd_args[1], NAMESIZE) != 0 )
d835 1
a835 1
						cmd_args[2], NAMESIZE);
d852 3
a854 1
f_killall()
d876 1
a876 1
				for( k=1; k<numargs; k++ )  {
d878 1
a878 1
					    cmd_args[k], NAMESIZE) != 0 )
d892 2
a893 2
	/* reuse cmd_args[] */
	f_kill();
d903 3
a905 1
f_killtree()
d912 2
a913 2
	for(i=1; i<numargs; i++) {
		if( (dp = db_lookup( dbip, cmd_args[i], LOOKUP_NOISY) ) == DIR_NULL )
@


9.2
log
@Added new "tree" command.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: dir.c,v 9.1 89/05/19 06:02:07 phil Locked $ (BRL)";
d426 1
a426 1
			cmd_args[numargs++] = dp->d_namep;
d428 2
a429 1
				(void)printf("%s: expansion stopped after %d matches\n", word, maxargs);
d432 1
@


9.1
log
@Release_3.5
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: dir.c,v 8.7 89/05/11 21:38:10 phil Exp $ (BRL)";
d627 1
d641 2
a645 1
		putchar( '\n' );
d685 3
d698 10
d709 1
d711 59
@


8.7
log
@removed local conversions(), now db_conversions()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: dir.c,v 8.6 89/05/11 04:40:23 phil Locked $ (BRL)";
@


8.6
log
@the "keep" function wasn't updating and testing d_nref counts so
solids were being output multiple times
@
text
@a7 1
 *	conversions	Builds conversion factors given a local unit
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: dir.c,v 8.5 89/05/08 21:44:44 phil Locked $ (BRL)";
a159 51
}



/*	builds conversion factors given the local unit
 */
void
conversions( local )
int local;
{

	/* Base unit is MM */
	switch( local ) {

	case ID_NO_UNIT:
		/* no local unit specified ... use the base unit */
		localunit = record.i.i_units = ID_MM_UNIT;
		local2base = 1.0;
		break;

	case ID_MM_UNIT:
		/* local unit is mm */
		local2base = 1.0;
		break;

	case ID_CM_UNIT:
		/* local unit is cm */
		local2base = 10.0;		/* CM to MM */
		break;

	case ID_M_UNIT:
		/* local unit is meters */
		local2base = 1000.0;		/* M to MM */
		break;

	case ID_IN_UNIT:
		/* local unit is inches */
		local2base = 25.4;		/* IN to MM */
		break;

	case ID_FT_UNIT:
		/* local unit is feet */
		local2base = 304.8;		/* FT to MM */
		break;

	default:
		local2base = 1.0;
		localunit = 6;
		break;
	}
	base2local = 1.0 / local2base;
@


8.5
log
@removed some unused stuff
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: dir.c,v 8.4 89/04/06 20:39:03 phil Locked $ (BRL)";
d636 3
@


8.4
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@a4 1
 *	dir_build	Build directory of object file
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: dir.c,v 8.3 89/03/06 23:59:11 mike Locked $ (BRL)";
a59 11
static char *units_str[] = {
	"none",
	"mm",
	"cm",
	"meters",
	"inches",
	"feet",
	"extra"
};

void	conversions();
@


8.3
log
@ansii
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: dir.c,v 8.2 88/12/06 01:01:01 mike Locked $ (BRL)";
d52 1
a54 5

extern int	read(), strcmp();
extern long	lseek();
extern char	*malloc();
extern void	exit(), free(), perror();
@


8.2
log
@Converted to new db_*() routines.
@
text
@d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/dir.c,v 1.4 88/10/30 00:35:42 mike Exp $ (BRL)";
a77 1
static void file_put();
d712 3
d892 3
@


8.1
log
@Release_3.0
@
text
@a4 1
 *	db_open		Open the database
a7 12
 *	lookup		Convert an object name into directory pointer
 *	dir_add		Add entry to the directory
 *	strdup		Duplicate a string in dynamic memory
 *	dir_delete	Delete entry from directory
 *	db_delete	Delete entry from database
 *	db_getrec	Get a record from database
 *	db_getmany	Retrieve several records from database
 *	db_putrec	Put record to database
 *	db_alloc	Find a contiguous block of database storage
 *	db_grow		Increase size of existing database entry
 *	db_trunc	Decrease size of existing entry, from it's end
 *	db_delrec	Delete a specific record from database entry
a9 2
 *	dir_units	Changes the local unit
 *	dir_title	Change the target title
d35 1
a35 1
static char RCSid[] = "@@(#)$Header: dir.c,v 7.7 88/08/24 07:48:12 reschly Exp $ (BRL)";
d50 1
a52 1
#include "./objdir.h"
a59 17
/*
 *  The directory is organized as forward linked lists hanging off of
 *  one of NHASH headers.  The function dir_hash() returns a pointer
 *  to the correct header.
 */
#define	NHASH		128	/* size of hash table */

#if	((NHASH)&((NHASH)-1)) != 0
#define	HASH(sum)	((unsigned)(sum) % (NHASH))
#else
#define	HASH(sum)	((unsigned)(sum) & ((NHASH)-1))
#endif

static struct directory *DirHead[NHASH];

static struct mem_map *dbfreep = MAP_NULL; /* map of free granules */

a60 2
static long	eof_addr = BAD_EOF;	/* End+1 position of object file */
int		objfd;			/* FD of object file */
a64 2
double	local2base, base2local;		/* unit conversion factors */
int	localunit;			/* local unit currently in effect */
a74 4
char	cur_title[128];			/* current target title */

char	*filename;			/* Name of database file */
int	read_only = 0;			/* non-zero when read-only */
a75 1
void	rm_membs();
a80 1
extern void color_addrec();
a84 236
 *  			D B _ O P E N
 *
 *  Returns:
 *	-1	error
 *	+1	success
 */
int
db_open( name )
char *name;
{
	if( (objfd = open( name, O_RDWR )) < 0 )  {
		if( (objfd = open( name, O_RDONLY )) < 0 )  {
			perror( name );
			return(-1);
		}  else  {
			(void)printf("%s: READ ONLY\n", name);
			read_only = 1;
		}
	}
	filename = name;
	return(1);
}

/*
 *			D B _ C R E A T E
 *
 *  Create a new database containing just an IDENT record
 *  Returns:
 *	-1 on error,
 *	+1 on success.
 */
int
db_create( name )
char *name;
{
	union record new;

	if( (objfd = creat(name, 0644)) < 0 )  {
		perror(name);
		return(-1);
	}
	bzero( (char *)&new, sizeof(new) );
	new.i.i_id = ID_IDENT;
	new.i.i_units = ID_MM_UNIT;
	strncpy( new.i.i_version, ID_VERSION, sizeof(new.i.i_version) );
	strcpy( new.i.i_title, "Untitled MGED Database" );
	(void)write( objfd, (char *)&new, sizeof(new) );
	(void)close(objfd);

	if( db_open( name ) < 0 )
		return(-1);
	return(1);
}

/*
 *			D I R _ H A S H
 *  
 *  Internal function to return pointer to head of hash chain
 *  corresponding to the given string.
 */
static
struct directory **
dir_hash(str)
char *str;
{
	register unsigned char *s = (unsigned char *)str;
	register long sum;
	register int i;

	sum = 0;
	/* namei hashing starts i=0, discarding first char.  ??? */
	for( i=1; *s; )
		sum += *s++ * i++;

	return( &DirHead[HASH(sum)] );
}

/*
 *			D I R _ B U I L D
 *
 * This routine reads through the 3d object file and
 * builds a directory of the object names, to allow rapid
 * named access to objects.
 */
void
dir_build()  {
	register FILE *fp;
	register long addr;

	(void)lseek( objfd, 0L, 0 );
	if( read( objfd, (char *)&record, sizeof record ) != sizeof record ) {
		(void)printf("dir_build:  database header read error\n");
		mged_finish(5);
		return;
	}
	if( record.u_id != ID_IDENT )  {
		(void)printf("ERROR:  %s looks nothing like a GED database\n",
			filename);
		mged_finish(6);
		return;
	}
	if( strcmp( record.i.i_version, ID_VERSION) != 0 )  {
		(void)printf("File is Version %s, Program is version %s\n",
			record.i.i_version, ID_VERSION );
		(void)printf("This database should be converted before further use.\n");
		localunit = 0;
		local2base = base2local = 1.0;
	} else {
		/* get the unit conversion factors */
		localunit = record.i.i_units;
		conversions( record.i.i_units );
	}
	/* save the title */
	cur_title[0] = '\0';
	(void)strcat(cur_title, record.i.i_title);

	if( (fp = fopen( filename, "r" )) == NULL )  {
		(void)printf("dir_build: fopen failed\n");
		return;
	}

	addr = -1;
	while(1)  {
		if( (addr = ftell(fp)) == EOF )
			printf("dir_build:  ftell() failure\n");
		if( fread( (char *)&record, sizeof record, 1, fp ) != 1
		    || feof(fp) )
			break;

	switch( record.u_id )  {

	case ID_COMB:
		(void)dir_add( record.c.c_name, addr,
			record.c.c_flags == 'R' ?
				DIR_COMB|DIR_REGION : DIR_COMB,
			record.c.c_length+1 );
		continue;

	case ID_MEMB:
		continue;

	case ID_ARS_A:
		(void)dir_add( record.a.a_name, addr,
			DIR_SOLID, record.a.a_totlen+1 );
		continue;

	case ID_ARS_B:
		continue;

	case ID_BSOLID:
		{
			static union record rec;
			register long start_addr;

			start_addr = addr;
			addr += (long)(sizeof(record));
			while( fread((char *)&rec, sizeof(rec), 1, fp) == 1 &&
			    !feof(fp)  &&
			    rec.u_id == ID_BSURF )  {
				addr += (rec.d.d_nknots+rec.d.d_nctls+1) *
					(long)(sizeof(record));
				(void)fseek( fp, addr, 0 );
			}
			(void)dir_add( record.B.B_name, start_addr,
				DIR_SOLID, (addr-start_addr)/sizeof(record) );
			(void)fseek( fp, addr, 0 );	/* to reread */
			continue;
		}

	case ID_BSURF:
		(void)printf("Unattached B-spline surface record?\n");
		/* Need to skip over knots & mesh which follows! */
		addr += (record.d.d_nknots + record.d.d_nctls + 1) *
			(long)(sizeof(record));
		(void)fseek( fp, addr, 0 );
		continue;

	case ID_P_HEAD:
		{
			union record rec;
			register int nrec;

			nrec = 1;
			while( fread((char *)&rec, sizeof(rec), 1, fp) == 1 &&
			    !feof(fp)  &&
			    rec.u_id == ID_P_DATA )
				nrec++;
			(void)dir_add( record.p.p_name, addr, DIR_SOLID, nrec );
			addr += (long)nrec * (long)sizeof(record);
			(void)fseek( fp, addr, 0 );
			continue;
		}

	case ID_IDENT:
		(void)printf("%s (units=%s)\n",
			record.i.i_title,
			units_str[record.i.i_units] );
		continue;

	case ID_FREE:
		/* Inform db manager of avail. space */
		memfree( &dbfreep, 1, addr/sizeof(union record) );
		continue;

	case ID_SOLID:
		(void)dir_add( record.s.s_name, addr, DIR_SOLID, 1 );
		continue;

	case ID_MATERIAL:
		color_addrec( &record, addr );
		continue;

	default:
		(void)printf( "dir_build:  unknown record %d=%c (0%o) addr=x%x\n",
			addr/sizeof(union record),
			record.u_id, record.u_id,
			addr );
#ifdef CLEANUP_DB
		if( !read_only )  {
			/* zap this record and put in free map */
			zapper.u_id = ID_FREE;	/* The rest will be zeros */
			(void)lseek( objfd, addr, 0 );
			(void)write(objfd, (char *)&zapper, sizeof(zapper));
		}
		memfree( &dbfreep, 1, addr/(sizeof(union record)) );
#endif
		continue;
	}
	}

	/* Record current end of objects file */
	eof_addr = addr;
	(void)fclose(fp);
}

/*
d107 2
a108 2
		for( i = 0; i < NHASH; i++)
			for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw)
d147 1
a147 1
			if( (dp = lookup( cmd_args[i], LOOKUP_NOISY)) ==
d158 2
a159 2
		for( i = 0; i < NHASH; i++)
			for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw)
a166 478
 *			D I R _ L O O K U P
 *
 * This routine takes a name, trims to NAMESIZE, and looks it up in the
 * directory table.  If the name is present, a pointer to
 * the directory struct element is returned, otherwise
 * NULL is returned.
 *
 * If noisy is non-zero, a print occurs, else only
 * the return code indicates failure.
 */
struct directory *
lookup( name, noisy )
register char *name;
{
	register struct directory *dp;
	static char local[NAMESIZE+2];
	register int i;

	if( (i=strlen(name)) > NAMESIZE )  {
		(void)strncpy( local, name, NAMESIZE );	/* Trim the name */
		local[NAMESIZE] = '\0';			/* ensure null termination */
		name = local;
	}
	for( dp = *dir_hash(name); dp != DIR_NULL; dp=dp->d_forw )  {
		if(
			name[0] == dp->d_namep[0]  &&	/* speed */
			name[1] == dp->d_namep[1]  &&	/* speed */
			strcmp( name, dp->d_namep ) == 0
		)
			return(dp);
	}

	if( noisy )
		(void)printf("dir_lookup:  could not find '%s'\n", name );
	return( DIR_NULL );
}

/*
 *			D I R _ A D D
 *
 * Add an entry to the directory
 */
struct directory *
dir_add( name, laddr, flags, len )
register char *name;
long laddr;
{
	register struct directory **headp;
	register struct directory *dp;
	char local[NAMESIZE+2];

	GETSTRUCT( dp, directory );
	if( dp == DIR_NULL )
		return( DIR_NULL );
	(void)strncpy( local, name, NAMESIZE );	/* Trim the name */
	local[NAMESIZE] = '\0';			/* ensure null termination */
	dp->d_namep = strdup( local );
	dp->d_addr = laddr;
	dp->d_flags = flags;
	dp->d_len = len;
	headp = dir_hash( local );
	dp->d_forw = *headp;
	*headp = dp;
	return( dp );
}

/*
 *			S T R D U P
 *
 * Given a string, allocate enough memory to hold it using malloc(),
 * duplicate the strings, returns a pointer to the new string.
 */
char *
strdup( cp )
register char *cp;
{
	register char	*base;
	register char	*current;

	if( (base = malloc( (unsigned)(strlen(cp)+1) )) == (char *)0 )  {
		(void)printf("strdup:  unable to allocate memory");
		return( (char *) 0);
	}

	current = base;
	do  {
		*current++ = *cp;
	}  while( *cp++ != '\0' );

	return(base);
}

/*
 *  			D I R _ D E L E T E
 *
 *  Given a pointer to a directory entry, remove it from the
 *  linked list, and free the associated memory.
 */
void
dir_delete( dp )
register struct directory *dp;
{
	register struct directory *findp;
	register struct directory **headp;

	headp = dir_hash( dp->d_namep );
	if( *headp == dp )  {
		free( dp->d_namep );
		*headp = dp->d_forw;
		free( dp );
		return;
	}
	for( findp = *headp; findp != DIR_NULL; findp = findp->d_forw )  {
		if( findp->d_forw != dp )
			continue;
		free( dp->d_namep );
		findp->d_forw = dp->d_forw;
		free( dp );
		return;
	}
	(void)printf("dir_delete:  unable to find %s\n", dp->d_namep );
}

/*
 *  			D B _ D E L E T E
 *  
 *  Delete the indicated database record(s).
 *  Mark all records with ID_FREE.
 */
void
db_delete( dp )
struct directory *dp;
{
	register int i;

	zapper.u_id = ID_FREE;	/* The rest will be zeros */

	for( i=0; i < dp->d_len; i++ )
		db_putrec( dp, &zapper, i );
	memfree( &dbfreep, (unsigned)dp->d_len, dp->d_addr/(sizeof(union record)) );
	dp->d_len = 0;
	dp->d_addr = -1;
}

/*
 *  			D B _ G E T R E C
 *
 *  Retrieve a record from the database,
 *  "offset" granules into this entry.
 */
void
db_getrec( dp, where, offset )
struct directory *dp;
union record *where;
{
	register int i;

	if( offset < 0 || offset >= dp->d_len )  {
		(void)printf("db_getrec(%s):  offset %d exceeds %d\n",
			dp->d_namep, offset, dp->d_len );
		where->u_id = '\0';	/* undefined id */
		return;
	}
	(void)lseek( objfd, (long)(dp->d_addr + offset * sizeof(union record)), 0 );
	i = read( objfd, (char *)where, sizeof(union record) );
	if( i != sizeof(union record) )  {
		perror("db_getrec");
		(void)printf("db_getrec(%s,%d):  read error.  Wanted %d, got %d\n",
			dp->d_namep, offset, sizeof(union record), i );
		where->u_id = '\0';	/* undefined id */
	}
}

/*
 *  			D B _ G E T M R E C
 *
 *  Retrieve all records in the database pertaining to an object,
 *  and place them in malloc()'ed storage, which the caller is
 *  responsible for free()'ing.
 */
union record *
db_getmrec( dp )
struct directory *dp;
{
	union record *where;
	int	want;
	int	got;

	want = dp->d_len * sizeof(union record);
	if( (where = (union record *)malloc(want)) == (union record *)0 )  {
		perror("db_getmrec malloc");
		return( (union record *)0 );	/* VERY BAD */
	}
	(void)lseek( objfd, (long)(dp->d_addr), 0 );
	got = read( objfd, (char *)where, want );
	if( got != want )  {
		perror("db_getmrec");
		(void)printf("db_getmrec(%s):  read error.  Wanted %d, got %d bytes\n",
			dp->d_namep, want, got );
		free( (char *)where );
		return( (union record *)0 );	/* VERY BAD */
	}
	return( where );
}

/*
 *  			D B _ G E T M A N Y
 *
 *  Retrieve several records from the database,
 *  "offset" granules into this entry.
 */
void
db_getmany( dp, where, offset, len )
struct directory *dp;
union record *where;
{
	register int i;

	if( offset < 0 || offset+len > dp->d_len )  {
		(void)printf("db_getmany(%s):  xfer %d..%x exceeds 0..%d\n",
			dp->d_namep, offset, offset+len, dp->d_len );
		where->u_id = '\0';	/* undefined id */
		return;
	}
	(void)lseek( objfd, (long)(dp->d_addr + offset * sizeof(union record)), 0 );
	i = read( objfd, (char *)where, len * sizeof(union record) );
	if( i != len * sizeof(union record) )  {
		perror("db_getmany");
		(void)printf("db_getmany(%s):  read error.  Wanted %d, got %d\n",
			dp->d_namep, len * sizeof(union record), i );
		where->u_id = '\0';	/* undefined id */
	}
}

/*
 *  			D B _ P U T R E C
 *
 *  Store a single record in the database,
 *  "offset" granules into this entry.
 */
void
db_putrec( dp, where, offset )
register struct directory *dp;
union record *where;
int offset;
{
	register int i;

	if( read_only )  {
		(void)printf("db_putrec on READ-ONLY file\n");
		return;
	}
	if( offset < 0 || offset >= dp->d_len )  {
		(void)printf("db_putrec(%s):  offset %d exceeds %d\n",
			dp->d_namep, offset, dp->d_len );
		return;
	}
	(void)lseek( objfd, (long)(dp->d_addr + offset * sizeof(union record)), 0 );
	i = write( objfd, (char *)where, sizeof(union record) );
	if( i != sizeof(union record) )  {
		perror("db_putrec");
		(void)printf("db_putrec(%s):  write error\n", dp->d_namep );
	}
}

/*
 *  			D B _ P U T M A N Y
 *
 *  Store several records to the database,
 *  "offset" granules into this entry.
 */
void
db_putmany( dp, where, offset, len )
struct directory *dp;
union record *where;
{
	register int i;

	if( read_only )  {
		(void)printf("db_putrec on READ-ONLY file\n");
		return;
	}
	if( offset < 0 || offset+len > dp->d_len )  {
		(void)printf("db_putmany(%s):  xfer %d..%x exceeds 0..%d\n",
			dp->d_namep, offset, offset+len, dp->d_len );
		return;
	}
	(void)lseek( objfd, (long)(dp->d_addr + offset * sizeof(union record)), 0 );
	i = write( objfd, (char *)where, len * sizeof(union record) );
	if( i != len * sizeof(union record) )  {
		perror("db_putmany");
		(void)printf("db_putmany(%s):  write error.  Wanted %d, got %d\n",
			dp->d_namep, len * sizeof(union record), i );
	}
}

/*
 *  			D B _ A L L O C
 *  
 *  Find a block of database storage of "count" granules.
 */
void
db_alloc( dp, count )
register struct directory *dp;
int count;
{
	register int i;
	unsigned long addr;
	union record rec;

	if( read_only )  {
		(void)printf("db_alloc on READ-ONLY file\n");
		return;
	}
	if( count <= 0 )  {
		(void)printf("db_alloc(0)\n");
		return;
	}
top:
	if( (addr = memalloc( &dbfreep, (unsigned)count )) == 0L )  {
		/* No contiguous free block, append to file */
		if( (dp->d_addr = eof_addr) == BAD_EOF )  {
			(void)printf("db_alloc while reading database?\n");
			return;
		}
		dp->d_len = count;
		eof_addr += count * sizeof(union record);

		/* Clear out the granules, for safety */
		zapper.u_id = ID_FREE;	/* The rest will be zeros */
		for( i=0; i < dp->d_len; i++ )
			db_putrec( dp, &zapper, i );
		return;
	}
	dp->d_addr = addr * sizeof(union record);
	dp->d_len = count;
	db_getrec( dp, &rec, 0 );
	if( rec.u_id != ID_FREE )  {
		(void)printf("db_alloc():  addr %ld non-FREE (id %d), skipping\n",
			addr, rec.u_id );
		goto top;
	}

	/* Clear out the granules, for safety */
	zapper.u_id = ID_FREE;	/* The rest will be zeros */
	for( i=0; i < dp->d_len; i++ )
		db_putrec( dp, &zapper, i );
}

/*
 *  			D B _ G R O W
 *  
 *  Increase the database size of an object by "count",
 *  by duplicating in a new area if necessary.
 *  Returns:
 *	-1	on error
 *	0	on success
 */
int
db_grow( dp, count )
register struct directory *dp;
int count;
{
	register int i;
	union record rec;
	struct directory olddir;
	int extra_start;

	if( read_only )  {
		(void)printf("db_grow on READ-ONLY file\n");
		return(-1);
	}

	/* Easy case -- see if at end-of-file */
	extra_start = dp->d_addr + dp->d_len * sizeof(union record);
	if( extra_start == eof_addr )  {
		eof_addr += count * sizeof(union record);
		dp->d_len += count;
clean:
		(void)lseek( objfd, extra_start, 0 );
		zapper.u_id = ID_FREE;	/* The rest will be zeros */
		for( i = 0; i < count; i++ )  {
			if( write( objfd, (char *)&zapper, sizeof(zapper) ) != sizeof(zapper) )  {
				perror("db_grow: write");
				return(-1);
			}
		}
		return(0);
	}

	/* Try to extend into free space immediately following current obj */
	if( memget( &dbfreep, (unsigned)count, (unsigned long)(dp->d_addr/sizeof(union record)) ) == 0L )
		goto hard;

	/* Check to see if granules are all really availible (sanity check) */
	for( i=0; i < count; i++ )  {
		(void)lseek( objfd, (long)(dp->d_addr +
			((dp->d_len + i) * sizeof(union record))), 0 );
		(void)read( objfd, (char *)&rec, sizeof(union record) );
		if( rec.u_id != ID_FREE )  {
			(void)printf("db_grow:  FREE record wasn't?! (id%d)\n",
				rec.u_id);
			goto hard;
		}
	}
	dp->d_len += count;
	goto clean;
hard:
	/* Sigh, got to duplicate it in some new space */
	olddir = *dp;				/* struct copy */
	db_alloc( dp, dp->d_len + count );	/* fixes addr & len */
	/* TODO:  malloc, db_getmany, db_putmany, free.  Whack. */
	for( i=0; i < olddir.d_len; i++ )  {
		db_getrec( &olddir, &rec, i );
		db_putrec( dp, &rec, i );
	}
	/* Release space that original copy consumed */
	db_delete( &olddir );
	return(0);
}

/*
 *  			D B _ T R U N C
 *  
 *  Remove "count" granules from the indicated database entry.
 *  Stomp on them with ID_FREE's.
 *  Later, we will add them to a freelist.
 */
void
db_trunc( dp, count )
register struct directory *dp;
int count;
{
	register int i;

	if( read_only )  {
		(void)printf("db_trunc on READ-ONLY file\n");
		return;
	}
	zapper.u_id = ID_FREE;	/* The rest will be zeros */

	for( i = 0; i < count; i++ )
		db_putrec( dp, &zapper, (dp->d_len - 1) - i );
	dp->d_len -= count;
}

/*
 *			D B _ D E L R E C
 *
 *  Delete a specific record from database entry
 */
void
db_delrec( dp, recnum )
register struct directory *dp;
int recnum;
{
	register int i;
	auto union record rec;

	if( read_only )  {
		(void)printf("db_delrec on READ-ONLY file\n");
		return;
	}
	/* If deleting last member, just truncate */
	if( recnum == dp->d_len-1 )  {
		db_trunc( dp, 1 );
		return;
	}

	/* "Ripple up" the rest of the entry */
	for( i = recnum+1; i < dp->d_len; i++ )  {
		db_getrec( dp, &rec, i );
		db_putrec( dp, &rec, i-1 );
	}
	db_trunc( dp, 1 );
}

/*
d177 1
a177 1
	memprint( &dbfreep );
a230 52
/* change the local unit of the description */
void
dir_units( new_unit )
int new_unit;
{
	conversions( new_unit );	/* Change local unit first */

	if( read_only ) {
		(void)printf("Read only file\n");
		return;
	}

	(void)lseek(objfd, 0L, 0);
	(void)read(objfd, (char *)&record, sizeof record);

	if(record.u_id != ID_IDENT) {
		(void)printf("NOT a proper GED file\n");
		return;
	}

	(void)lseek(objfd, 0L, 0);
	record.i.i_units = new_unit;
	(void)write(objfd, (char *)&record, sizeof record);
}

/* change the title of the description */
void
dir_title( )
{

	if( read_only ) {
		(void)printf("Read only file\n");
		return;
	}

	(void)lseek(objfd, 0L, 0);
	(void)read(objfd, (char *)&record, sizeof record);

	if(record.u_id != ID_IDENT) {
		(void)printf("NOT a proper GED file\n");
		return;
	}

	(void)lseek(objfd, 0L, 0);

	record.i.i_title[0] = '\0';

	(void)strcat(record.i.i_title, cur_title);

	(void)write(objfd, (char *)&record, sizeof record);
}

d240 2
d243 2
a244 2
	register FILE *fp;
	register int i;
d247 2
a248 2
	for( i = 0; i < NHASH; i++ )  {
		for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw )
d252 17
a268 4
	/* Read through the whole database, looking only at MEMBER records */
	if( (fp = fopen( filename, "r" )) == NULL )  {
		(void)printf("dir_nref: fopen failed\n");
		return;
a269 9
	while(fread( (char *)&record, sizeof(record), 1, fp ) == 1 &&
	     !feof(fp))  {
		if( record.u_id != ID_MEMB )
			continue;
		if( record.M.m_instname[0] != '\0' &&
		    (dp = lookup(record.M.m_instname, LOOKUP_QUIET)) != DIR_NULL )
			dp->d_nref++;
	}
	(void)fclose(fp);
d286 1
a286 1
regexp_match(	 pattern,  string )
d352 1
a352 1
	static int sol, comb, reg, br;
d357 3
a359 3
	sol = comb = reg = br = 0;
	for( i = 0; i < NHASH; i++ )  {
		for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw )  {
a366 2
			if( dp->d_flags & DIR_BRANCH )
				br++;
a371 1
	(void)printf("  %5d branch names\n", br);
d388 2
a389 2
	for( i = 0; i < NHASH; i++)
		for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw)
d424 2
a425 2
	for( i = 0; i < NHASH; i++)
		for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw)
d490 2
a491 2
	for( i = 0; i < NHASH; i++ )  {
		for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw )  {
d538 3
a540 3
	register FILE *fp;
	register int i;
	char lastname[NAMESIZE];
a542 13
	/* Read whole database, looking only at MEMBER + COMB records */
	if( (fp = fopen( filename, "r" )) == NULL )  {
		(void)printf("f_find: fopen failed\n");
		return;
	}
	while(fread( (char *)&record, sizeof(record), 1, fp ) == 1 &&
	     !feof(fp))  {
		if( record.u_id == ID_COMB )  {
			strncpy( lastname, record.c.c_name, NAMESIZE );
			continue;
		}
		if( record.u_id != ID_MEMB )
			continue;
d544 4
a547 4
		if( record.M.m_instname[0] == '\0' )
			continue;
		for( i=1; i < numargs; i++ )  {
			if( strncmp( record.M.m_instname, cmd_args[i], NAMESIZE ) != 0 )
d549 16
a564 2
			(void)printf("%s:  member of %s\n",
				record.M.m_instname, lastname );
a566 1
	(void)fclose(fp);
d578 2
d581 1
a581 5
	register FILE *fp;
	long	seekptr = 0;
	long	laddr;
	char	tempstring[NAMESIZE+2];
	int 	flags, len, i;
d583 1
a583 5
	if( (fp = fopen(filename, "r+")) == NULL) {
		(void) printf("f_prefix: fopen failed\n");
		return;
	}

d585 4
a588 2
		if( (dp = lookup( cmd_args[i], LOOKUP_NOISY )) == DIR_NULL) 
			return;
d591 2
a592 1
			printf("Prefix too long, names must be less than %d characters.\n",
d594 2
a595 1
			return;
d601 1
a601 1
		if( lookup( tempstring, LOOKUP_QUIET ) != DIR_NULL ) {
d603 2
a604 1
			return;
d606 4
a609 5
		/*  Change object name in the directory.
		    Due to hashing, need to delete and add it back. */
		laddr = dp->d_addr;
		flags = dp->d_flags;
		len = dp->d_len;
d611 10
a620 11
		dir_delete( dp );
		dp = dir_add( tempstring, laddr, flags, len );

		/* Read whole database, looking at each object name. */
		for( ; fread( (char*)&record, sizeof(record), 1, fp ) == 1 &&
		     ! feof(fp);
		    seekptr += sizeof(record) )  {

			switch( record.u_id ) {
			case ID_COMB:
				if( strcmp(cmd_args[i],record.c.c_name) != 0 )
d622 10
a631 62
				(void) strcpy(record.c.c_name,tempstring);
				(void) fseek( fp, seekptr, 0);
				fwrite((char*)&record, sizeof(record), 1, fp);
				(void) fseek( fp, seekptr+sizeof(record), 0);
	 			break;

			case ID_BSOLID:
				if( strcmp(cmd_args[i],record.B.B_name) != 0 )
					continue;
				(void) strcpy(record.B.B_name,tempstring);
				(void) fseek( fp, seekptr, 0);
				fwrite((char*)&record, sizeof(record), 1, fp);
				(void) fseek( fp, seekptr+sizeof(record), 0);
		 		break;

			case ID_BSURF:
				/* No names here, just lots of granules to
				 * skip with no ID fields...
				 */
				seekptr += (record.d.d_nknots+record.d.d_nctls) *
					sizeof(record);
				(void) fseek( fp, seekptr+sizeof(record), 0);
		 		break;

			case ID_ARS_A:
				if( strcmp(cmd_args[i],record.a.a_name) != 0 )
					continue;
				(void) strcpy(record.a.a_name,tempstring);
				(void) fseek( fp, seekptr, 0);
				fwrite((char*)&record, sizeof(record), 1, fp);
				(void) fseek( fp, seekptr+sizeof(record), 0);
	 			break;

			case ID_P_HEAD:
				if( strcmp(cmd_args[i],record.p.p_name) != 0 )
					continue;
				(void) strcpy(record.p.p_name,tempstring);
				(void) fseek( fp, seekptr, 0);
				fwrite((char*)&record, sizeof(record), 1, fp);
				(void) fseek( fp, seekptr+sizeof(record), 0);
	 			break;

			case ID_SOLID:
				if( strcmp(cmd_args[i],record.s.s_name) != 0 )
					continue;
				(void) strcpy(record.s.s_name,tempstring);
				(void) fseek( fp, seekptr, 0);
				fwrite((char*)&record, sizeof(record), 1, fp);
				(void) fseek( fp, seekptr+sizeof(record), 0);
	 			break;

			case ID_MEMB:
				if( strcmp(cmd_args[i],record.M.m_instname) != 0 )
					continue;
				(void) strcpy(record.M.m_instname,tempstring);
				(void) fseek( fp, seekptr, 0);
				fwrite((char*)&record, sizeof(record), 1, fp);
				(void) fseek( fp, seekptr+sizeof(record), 0);
 				break;

			default:
				;
d633 1
d635 1
a635 4
		seekptr = 0;
		fseek(fp,0,0);  /* Rewind the file for next pass.*/
	}  
	(void) fclose(fp);
d641 2
a642 2
 *  	Saves named objects in specified file.
 *	Good for pulling parts out of a description.
a643 3

#define MAX_KEEPCOUNT	  2000
static char	*keep_names[MAX_KEEPCOUNT];
a644 1
static int	keep_count;
d647 15
d664 1
a664 1
	int i;
d666 6
d682 1
a682 1
	sprintf(record.i.i_title, "Parts of: %s", cur_title);
a684 1
	keep_count = 0;
d686 3
a688 6
		if( (dp = lookup(cmd_args[i], LOOKUP_NOISY)) != DIR_NULL )
			file_put(dp);
		if( keep_count >= MAX_KEEPCOUNT ) {
			(void)printf("ERROR: exceeded MAX objects to keep, %d objects kept\n",MAX_KEEPCOUNT);
			break;
		}
a693 49
 *  Saves all objects in hierarchy of an object.
 */
static void
file_put( dp )
register struct directory *dp;
{
	register struct directory *nextdp;
	register int i;

	/* If this object already sent to keep file, just return */
	for( i=0; i<keep_count; i++) {
		if(keep_names[i] == dp->d_namep)
			return;
	}

	/* write this record to the keep file if new object */
	keep_names[keep_count++] = dp->d_namep;

	if( keep_count >= MAX_KEEPCOUNT ) 
		return;

	db_getrec (dp, (char *)&record, 0);
	(void)write(keepfd, (char *)&record, sizeof record);

	if(record.u_id == ID_COMB) {
		/* write out all member records */
		for( i=1; i<dp->d_len; i++ )  {
			db_getrec( dp, &record, i );
			(void)write(keepfd, (char *)&record, sizeof record);
		}
		/* recurse on all member records */
		for( i=1; i<dp->d_len; i++ )  {
			db_getrec( dp, &record, i );
			nextdp = lookup(record.M.m_instname,LOOKUP_NOISY);
			if( nextdp == DIR_NULL )
				continue;
			file_put( nextdp );
		}
		return;
	}

	/* Whatever it is, we must write all granules */
	for( i=1; i<dp->d_len; i++ )  {
		db_getrec( dp, &record, i );
		(void)write(keepfd, (char *)&record, sizeof record);
	}
}

/*
d706 1
a706 1
		if( (dp = lookup( cmd_args[j], LOOKUP_NOISY )) == DIR_NULL )
d719 1
a719 1
	union record rec;
d721 1
d723 2
a724 4
	/*
	 * Load the record into local record buffer
	 */
	db_getrec( dp, &rec, 0 );
d732 1
a732 2

	if( rec.u_id != ID_COMB )  {
a735 3
	i = NAMESIZE - strlen(dp->d_namep);
	while( i-- > 0 )
		putchar('_');
d737 1
d742 4
d747 2
a748 4
		register struct directory *nextdp;	/* temporary */

		db_getrec( dp, &rec, i );
		if( (nextdp = lookup( rec.M.m_instname, LOOKUP_NOISY )) == DIR_NULL )
d754 1
d768 3
a770 2
	register FILE *fp;
	long seekptr;
d778 2
a779 2
	if( (fp = fopen(filename, "r+")) == NULL ) {
		(void)printf("f_mvall: fopen failed\n");
d781 3
d785 3
d789 4
a792 2
	/* no interupts */
	(void)signal( SIGINT, SIG_IGN );
d794 19
a812 16
	/* rename the record itself */
	f_name();

	/* rename all member records with this name */
	seekptr = 0;
	for( ; fread( (char*)&record, sizeof(record), 1, fp ) == 1 &&
	     ! feof(fp);
	    seekptr += sizeof(record) )  {

		if( record.u_id == ID_MEMB ) {
			if( strcmp( cmd_args[1], record.M.m_instname ) == 0 ) {
				/* match -- change this name */
				(void)strcpy(record.M.m_instname, cmd_args[2]);
				(void)fseek( fp, seekptr, 0 );
				fwrite( (char *)&record.M, sizeof(record), 1, fp );
				(void)fseek(fp, seekptr+sizeof(record), 0);
d814 1
a816 2

	(void)fclose(fp);
d822 1
a822 1
 *	remove all occurences of object[s]
d828 4
a831 2
																		{
	register FILE *fp;
d835 1
a835 2
	/* no interupts */
	(void)signal( SIGINT, SIG_IGN );
d837 4
a840 18
	if( (fp = fopen(filename, "r")) == NULL ) {
		(void)printf("f_killall: fopen failed\n");
		return;
	}

	/* hunt for all combinations with matching member records */
	while( fread( (char*)&record, sizeof(record), 1, fp ) == 1 &&
	     ! feof(fp) )  {
		if( record.u_id != ID_COMB )
	     		continue;
		if( (len = record.c.c_length) == 0)
			continue;
		/* save the combination name */
	     	NAMEMOVE( record.c.c_name, combname );
		while( len-- ) {	/* each member */
			register int i;
			fread( (char *)&record, sizeof(record), 1, fp );
			if( record.u_id != ID_MEMB )
d842 6
a847 2
			for(i=1; i<numargs; i++) {
				if(strcmp(cmd_args[i], record.M.m_instname) != 0)
d849 10
a858 3
				/* match ... must remove at least one member */
				rm_membs( combname );
				break;
d860 1
d863 1
a863 1
	(void)fclose(fp);
a868 14
/*
 *			R M _ M E M B S
 *
 *  Hack:  re-uses cmd_args[]
 *  Note that the buffering of fread() may occasionally cause
 *  odd interactions...
 */
void
rm_membs( name )
char *name;
{
	register struct directory *dp;
	register int i, rec, num_deleted;
	union record record;
a869 30
	if( (dp = lookup( name, LOOKUP_QUIET )) == DIR_NULL )
		return;
	(void)printf("%s: ",name);

	/* Examine all the Member records, one at a time */
	num_deleted = 0;
top:
	for( rec = 1; rec < dp->d_len; rec++ )  {
		db_getrec( dp, &record, rec );
		/* Compare this member to each command arg */
		for( i = 1; i < numargs; i++ )  {
			if( strcmp( cmd_args[i], record.M.m_instname ) != 0 )
				continue;
			(void)printf("deleting member %s\n", cmd_args[i] );
			num_deleted++;
			db_delrec( dp, rec );
			goto top;
		}
	}
	/* go back and undate the header record */
	if( num_deleted ) {
		db_getrec(dp, &record, 0);
		record.c.c_length -= num_deleted;
		db_putrec(dp, &record, 0);
	}
}




d881 2
a882 3
	/* no interupts */
	(void)signal( SIGINT, SIG_IGN );
	
d884 1
a884 1
		if( (dp = lookup(cmd_args[i], LOOKUP_NOISY) ) == DIR_NULL )
d886 1
a886 1
		killtree( dp );
d891 2
a892 1
killtree( dp )
d895 6
a900 36

	struct directory *nextdp;
	int nparts, i;

	db_getrec(dp, (char *)&record, 0);

	if( record.u_id == ID_COMB ) {
		nparts = record.c.c_length;

		for(i=1; i<=nparts; i++) {
			/* get ith member */
			db_getrec(dp, (char *)&record, i);

			if( (nextdp = lookup(record.M.m_instname, LOOKUP_QUIET)) == DIR_NULL )
				continue;
			killtree( nextdp );
		}
		/* finished killing all members....kill this comb */
		(void)printf("KILL COMB :  %s\n",dp->d_namep);
		eraseobj( dp );
		db_delete( dp);
		dir_delete( dp );
		return;
	}

	/* NOT a comb, if solid, ars, spline, or polygon -> kill */
	if( record.u_id == ID_SOLID ||
		record.u_id == ID_ARS_A ||
		record.u_id == ID_P_HEAD ||
		record.u_id == ID_BSOLID ) {

		(void)printf("KILL SOLID:  %s\n",dp->d_namep);
		eraseobj( dp );
		db_delete( dp );
		dir_delete( dp );
	}
a901 10



#ifdef SYSV
#undef bzero
bzero( str, n )
{
	memset( str, '\0', n );
}
#endif
@


7.7
log
@modified cmd_glob to make regular expression handling and metacharacter
escaping more correct.  Still does not address things like 'fo\ of'.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 7.6 88/05/15 23:04:53 reschly Locked $ (BRL)";
@


7.6
log
@lint fixes
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 7.5 88/01/27 10:32:42 mike Locked $ (BRL)";
d1244 9
a1252 8
 *  Assist routine for command processor.  If the current word
 *  in the cmd_args[] array contains "*", "?" or "[", then this
 *  word is potentially a regular expression, and we will tromp
 *  through the entire in-core directory searching for a match.
 *  If no match is found, the original word remains untouched
 *  and this routine was an expensive no-op.  If any match is
 *  found, it replaces the original word.  All matches are sought
 *  for, up to the limit of the cmd_args[] array.
d1263 1
d1266 2
a1267 2
	strncpy( word, cmd_args[numargs-1], sizeof(word)-1 );
	/* If * ? or [ are present, this is a regular expression */
d1269 2
a1270 4
	while( *pattern )  {
		if( *pattern == '\n' ||
		    *pattern == ' '  ||
		    *pattern == '\t' )
d1274 2
a1275 12
		    *pattern++ == '[' )
			goto hard;
	}
	return(0);				/* nothing to do */
hard:
	/* First, null terminate (sigh) */
	pattern = &word[-1];
	while( *++pattern )  {
		if( *pattern == '\n' ||
		    *pattern == ' '  ||
		    *pattern == '\t' )  {
			*pattern = '\0';
d1277 9
a1285 3
		    }
	}
			
d1287 6
a1292 2
	 * First, save the pattern, and remove it from cmd_args,
	 * as it will be overwritten by the expansions.
d1294 1
a1294 1
	numargs--;
d1303 1
a1303 1
				return(1);	/* limited success */
d1307 24
a1330 5
	/* If we failed to do any expansion, leave the word untouched */
	if( numargs == orig_numargs-1 )  {
		(void)printf("%s: no match\n", word);
		numargs++;
		return(0);		/* found nothing */
d1332 1
a1332 1
	return(1);			/* success */
@


7.5
log
@Removed definition for bcopy.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 7.4 88/01/13 16:37:47 mike Locked $ (BRL)";
d116 2
d799 3
d803 1
d815 1
a815 1
		return;
d826 7
a832 3
		for( i = 0; i < count; i++ )
			(void)write( objfd, (char *)&zapper, sizeof(zapper) );
		return;
d863 1
d1746 1
d1805 1
a1805 3



@


7.4
log
@added a call to mged_finish
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 7.3 87/11/14 05:01:29 stay Locked $ (BRL)";
d1840 1
a1843 3
}
bcopy(from, to, count)  {
	memcpy( to, from, count );
@


7.3
log
@Added dir_getmrec() to get all records for an item,
using malloc.
Added total path matrix as explicit arg to redraw().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 7.3 87/11/14 04:46:44 mike Locked $ (BRL)";
d217 1
a217 1
		finish(5);
d223 1
a223 1
		finish(6);
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 7.1 87/11/02 23:59:06 mike Rel $ (BRL)";
d614 32
@


7.1
log
@Release 2.3
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 6.1 87/07/11 08:02:22 mike Rel $ (BRL)";
d62 1
a62 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 5.1 87/06/24 22:18:35 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 4.3 87/06/13 07:14:35 mike Exp $ (BRL)";
@


4.3
log
@Improved (but not yet fully portable) handling of database reading.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 4.2 87/02/13 00:06:05 mike Locked $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 4.1 86/12/29 03:19:48 mike Rel1 $ (BRL)";
d246 7
a252 5
	addr = 0L;		/* Addr of record read at top of loop */
	while(
	    fread( (char *)&record, sizeof(record), 1, fp ) == 1  &&
	    !feof(fp)
	)  switch( record.u_id )  {
d254 2
a260 2
		addr += (long)(record.c.c_length+1) * (long)sizeof record;
		(void)fseek( fp, addr, 0 );
d263 3
a268 2
		addr += (long)(record.a.a_totlen+1) * (long)(sizeof record);
		(void)fseek( fp, addr, 0 );
d271 3
a321 1
		addr += sizeof(record);
a326 1
		addr += sizeof(record);
a330 1
		addr += sizeof(record);
a334 1
		addr += sizeof(record);
d338 4
a341 2
		(void)printf( "dir_build:  unknown record %c (0%o) erased\n",
			record.u_id, record.u_id );
a350 1
		addr += sizeof(record);
d352 1
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.31 86/10/12 03:03:39 mike Exp $ (BRL)";
@


2.31
log
@strings.h
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.30 86/09/23 17:49:06 mike Locked $ (BRL)";
@


2.30
log
@fix
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.29 86/09/23 17:40:12 mike Exp $ (BRL)";
d57 2
a59 2
#else
#include <strings.h>
@


2.29
log
@Minor cleanup for cray
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.28 86/09/10 03:01:59 mike Exp $ (BRL)";
d58 1
a58 1
#endif
@


2.28
log
@Updated rm_memb() to use db_delrec() also.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.27 86/09/10 02:42:36 mike Exp $ (BRL)";
d55 2
d58 4
a61 1
#include <signal.h>
d1803 9
@


2.27
log
@Added new routine db_delrec(), to delete a specific
record of a database element.  When the record is deleted,
the other records are "rippled up" to preserve relative ordering.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.26 86/08/12 06:47:34 mike Exp $ (BRL)";
d1645 1
a1645 1
{
d1647 1
a1647 1
	char combname[NAMESIZE];
d1661 10
a1670 2
		if( record.u_id == ID_COMB ) {
			if( (len = record.c.c_length) == 0)
d1672 6
a1677 14
			/* save the combination name */
			strcpy(combname, record.c.c_name);
			while( len-- ) {	/* each member */
				fread( (char *)&record, sizeof(record), 1, fp );
				if( record.u_id == ID_MEMB ) {
					register int i;
					for(i=1; i<numargs; i++) {
						if(strcmp(cmd_args[i], record.M.m_instname) == 0) {
							/* match ... must remove at least one member */
							rm_membs( combname );
							break;
						}
					}
				}
d1691 2
d1707 1
a1709 1
top:
d1716 1
a1716 10

			/* If deleting last member, just truncate */
			if( rec == dp->d_len-1 ) {
				db_trunc(dp, 1);
				continue;
			}

			db_getrec( dp, &record, dp->d_len-1 );	/* last one */
			db_putrec( dp, &record, rec );		/* xch */
			db_trunc( dp, 1 );
@


2.26
log
@Changed #includes for CC -I../h
@
text
@d20 1
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.25 86/06/20 01:31:24 mike Exp $ (BRL)";
d837 31
@


2.25
log
@Added ability to create a new database if given name
does not exist.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.24 86/06/12 00:11:42 mike Exp $ (BRL)";
d57 6
a62 6
#include "../h/vmath.h"
#include "../h/db.h"
#include "ged.h"
#include "solid.h"
#include "objdir.h"
#include "dm.h"
@


2.24
log
@Keith added "killtree" command.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.23 86/05/28 01:47:04 mike Exp $ (BRL)";
d120 4
d125 1
a125 1
void
d132 4
a135 1
			exit(2);		/* NOT finish */
a136 2
		(void)printf("%s: READ ONLY\n", name);
		read_only = 1;
d139 32
@


2.23
log
@Changed lookup() to silently trim names to NAMESIZE length.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.22 86/05/28 01:00:45 mike Exp $ (BRL)";
d1564 1
d1579 1
d1593 1
a1593 1
			if(record.c.c_length == 0)
d1597 10
a1606 8
			fread( (char *)&record, sizeof(record), 1, fp );
			if( record.u_id == ID_MEMB ) {
				register int i;
				for(i=1; i<numargs; i++) {
					if(strcmp(cmd_args[i], record.M.m_instname) == 0) {
						/* match ... must remove at least one member */
						rm_membs( combname );
						break;
d1612 1
a1612 1
	fclose(fp);
d1665 71
@


2.22
log
@f_killall() from Keith
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.21 86/05/28 00:11:59 reschly Exp $ (BRL)";
d398 1
a398 1
 * This routine takes a name, and looks it up in the
d407 2
a408 2
lookup( str, noisy )
register char *str;
d411 2
d414 6
a419 1
	for( dp = *dir_hash(str); dp != DIR_NULL; dp=dp->d_forw )  {
d421 3
a423 3
			str[0] == dp->d_namep[0]  &&	/* speed */
			str[1] == dp->d_namep[1]  &&	/* speed */
			strcmp( str, dp->d_namep ) == 0
d429 1
a429 1
		(void)printf("dir_lookup:  could not find '%s'\n", str );
@


2.21
log
@Added dir_getspace() in support of sorted directory listings.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.20 86/03/14 20:42:57 mike Exp $ (BRL)";
d1557 96
@


2.20
log
@Added support for new spline format.
Added db_putmany() routine.
@
text
@d7 1
d37 1
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.19 86/03/11 00:11:18 mike Exp $ (BRL)";
d64 1
a64 1
extern int	read();
d314 36
d356 2
a357 2
dir_print()  {
	register struct directory	*dp;
d359 1
d361 10
a370 2
	(void)signal( SIGINT, sig2 );	/* allow interupts */
	if( numargs > 1 ) {
d372 3
d376 2
a377 1
			if( (dp = lookup( cmd_args[i], LOOKUP_NOISY )) == DIR_NULL )
d379 1
a379 5
			col_item( dp->d_namep );
			if( dp->d_flags & DIR_COMB )
				col_putchar( '/' );
			if( dp->d_flags & DIR_REGION )
				col_putchar( 'R' );
d381 9
a389 2
		col_eol();
		return;
d391 2
a392 11
	/* Full table of contents */
	for( i = 0; i < NHASH; i++ )  {
		for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			col_item( dp->d_namep );
			if( dp->d_flags & DIR_COMB )
				col_putchar( '/' );
			if( dp->d_flags & DIR_REGION )
				col_putchar( 'R' );
		}
	}
	col_eol();
d1027 1
d1030 1
d1047 1
a1047 1
	(void)printf("  %5d regions, %d non-region combinations\n", reg, comb);
d1049 1
a1049 1
	(void)printf("  %5d total objects\n", sol+reg+comb );
d1055 12
a1066 2
	for( i = 0; i < NHASH; i++ )  {
		for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw )  {
d1068 3
a1070 4
				col_item(dp->d_namep);
		}
	}
	col_eol();
d1084 1
d1087 1
d1089 16
a1104 3
	for( i = 0; i < NHASH; i++ )  {
		for( dp = DirHead[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			if( dp->d_nref > 0 )
d1106 5
a1110 5
			/* Object is not a member of any combination */
			col_item(dp->d_namep);
		}
	}
	col_eol();
a1557 3



@


2.19
log
@Minor bug fix to db_getmany()
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.18 85/09/27 19:11:06 mike Exp $ (BRL)";
d223 25
a247 4
	case ID_B_SPL_HEAD:
		dir_add( record.d.d_name, addr,
			DIR_SOLID, record.d.d_totlen+1 );
		addr += (long)(record.d.d_totlen+1) * (long)(sizeof(record));
a250 5
	case ID_B_SPL_CTL:
		(void)printf("Unattached control mesh record?\n");
		addr += (long)(sizeof(record));
		continue;

d293 1
d301 1
d511 2
a512 2
		(void)printf("db_getrec(%s):  read error.  Wanted %d, got %d\n",
			dp->d_namep, sizeof(union record), i );
d578 31
d1218 2
a1219 2
			case ID_B_SPL_HEAD:
				if( strcmp(cmd_args[i],record.d.d_name) != 0 )
d1221 1
a1221 1
				(void) strcpy(record.d.d_name,tempstring);
d1224 9
@


2.18
log
@KAA added f_mvall(), improved KEEP handling.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.17 85/09/14 05:34:55 mike Exp $ (BRL)";
d512 1
a512 1
	if( offset < 0 || offset+len >= dp->d_len )  {
@


2.17
log
@Lint-inspired cleanup.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.16 85/09/12 00:49:55 mike Exp $ (BRL)";
d1231 1
a1231 1
#define MAX_KEEPCOUNT	  500
d1258 4
d1285 3
d1379 53
@


2.16
log
@Tightened integrity checking.
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.15 85/08/29 14:55:42 mike Exp $ (BRL)";
d1269 1
a1269 2
	register struct member *mp;
	struct directory *nextdp;
@


2.15
log
@Added prefix, keep, and tree comands.
(From Romanelli).
@
text
@d47 1
a47 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.14 85/08/07 05:17:20 mike Exp $ (BRL)";
d170 5
a174 1
	(void)read( objfd, (char *)&record, sizeof record );
d176 8
a183 1
		(void)printf("Warning:  File is not a proper GED database\n");
d188 3
a190 14
		if( strcmp( record.i.i_version, ID_VERSION) != 0 )  {
			(void)printf("File is Version %s, Program is version %s\n",
				record.i.i_version, ID_VERSION );
			(void)printf("This database should be converted before further use.\n");
			localunit = 0;
			local2base = base2local = 1.0;
		} else {
			/* get the unit conversion factors */
			localunit = record.i.i_units;
			conversions( record.i.i_units );
		}
		/* save the title */
		cur_title[0] = '\0';
		(void)strcat(cur_title, record.i.i_title);
d192 3
@


2.14
log
@Changed to use common ../h/vmath.h
@
text
@d28 3
d35 1
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.13 85/06/05 15:37:48 mike Exp $ (BRL)";
d109 3
d1102 267
@


2.13
log
@Clears past EOF on db_alloc().
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.12 85/05/29 16:05:57 mike Exp $ (BRL)";
d46 6
a51 5
#include	<fcntl.h>
#include	<stdio.h>
#include	<string.h>
#include	<signal.h>
#include "ged_types.h"
a55 1
#include "../h/vmath.h"
@


2.12
log
@More improvements to name trimming in dir_add.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.11 85/05/29 14:56:38 mike Exp $ (BRL)";
d580 5
@


2.11
log
@changed dir_add to trim new names to NAMESIZE
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.10 85/05/28 16:30:58 mike Exp $ (BRL)";
d365 1
a365 1
	char local[NAMESIZE];
d370 2
a371 1
	(void)strncpy( local, name, NAMESIZE );		/* Trim the name */
d376 1
a376 1
	headp = dir_hash( name );
@


2.10
log
@Zero out entire granules when allocated.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.9 85/05/02 20:16:07 mike Exp $ (BRL)";
d365 1
d370 2
a371 1
	dp->d_namep = strdup( name );
@


2.9
log
@Eliminated silly M_brname stuff.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.8 85/03/29 00:13:28 mike Exp $ (BRL)";
d556 1
d587 5
d607 1
d615 2
a616 1
	if( dp->d_addr + dp->d_len * sizeof(union record) == eof_addr )  {
d619 5
d643 1
a643 1
	return;
@


2.8
log
@Added f_find.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.7 85/03/22 10:52:23 mike Exp $ (BRL)";
a813 3
		if( record.M.m_brname[0] != '\0' &&
		    (dp = lookup(record.M.m_brname, LOOKUP_QUIET)) != DIR_NULL )
			dp->d_nref++;
@


2.7
log
@Fixed globbing bug
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.6 85/03/15 05:03:29 mike Exp $ (BRL)";
d1038 39
@


2.6
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.5 85/03/14 05:04:13 mike Exp $ (BRL)";
d988 1
a988 1
	strncpy( word, cmd_args[numargs-1], sizeof(word) );
d991 5
a995 1
	while( *pattern )
d1000 1
@


2.5
log
@Various support for mater.c
@
text
@d27 1
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.4 85/03/13 06:09:20 mike Exp $ (BRL)";
d102 1
a102 1
static int read_only = 0;		/* non-zero when read-only */
d106 2
d295 15
d963 70
@


2.4
log
@Changed from linear search for name lookups to hashing
strategy to index array of linked lists.
Improved "tops" command execution from 3600 cpu seconds to 30.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.3 85/03/12 05:22:11 mike Exp $ (BRL)";
d79 2
a80 1
static long	objfdend;		/* End+1 position of object file */
d104 2
d256 5
d276 1
a276 3
	objfdend = ftell(fp);
	if( objfdend != addr )
		(void)printf("ftell=%d, addr=%d\n", objfdend, addr);
d552 4
a555 1
		dp->d_addr = objfdend;
d557 1
a557 1
		objfdend += count * sizeof(union record);
d590 2
a591 2
	if( dp->d_addr + dp->d_len * sizeof(union record) == objfdend )  {
		objfdend += count * sizeof(union record);
d617 1
@


2.3
log
@Improved speed of initial file reading.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: dir.c,v 2.1 85/03/11 23:54:28 mike Prod $ (BRL)";
d62 6
a67 1
static struct directory *DirHead = DIR_NULL;
d69 8
d122 23
d214 5
d283 1
d286 8
a293 6
	for( dp = DirHead; dp != DIR_NULL; dp = dp->d_forw )  {
		col_item( dp->d_namep );
		if( dp->d_flags & DIR_COMB )
			col_putchar( '/' );
		if( dp->d_flags & DIR_REGION )
			col_putchar( 'R' );
d315 1
a315 1
	for( dp = DirHead; dp != DIR_NULL; dp=dp->d_forw )  {
d318 1
d339 1
d349 3
a351 2
	dp->d_forw = DirHead;
	DirHead = dp;
d392 1
d394 2
a395 1
	if( DirHead == dp )  {
d397 1
a397 1
		DirHead = dp->d_forw;
d401 1
a401 1
	for( findp = DirHead; findp != DIR_NULL; findp = findp->d_forw )  {
d769 1
a769 1
	union record rec;
d772 4
a775 2
	for( dp = DirHead; dp != DIR_NULL; dp = dp->d_forw )
		dp->d_nref = 0;
d782 3
a784 2
	while(fread( (char *)&rec, sizeof(rec), 1, fp ) == 1 && !feof(fp))  {
		if( rec.u_id != ID_MEMB )
d786 2
a787 2
		if( rec.M.m_brname[0] != '\0' &&
		    (dp = lookup(rec.M.m_brname, LOOKUP_QUIET)) != DIR_NULL )
d789 2
a790 2
		if( rec.M.m_instname[0] != '\0' &&
		    (dp = lookup(rec.M.m_instname, LOOKUP_QUIET)) != DIR_NULL )
d875 1
d880 12
a891 10
	for( dp = DirHead; dp != DIR_NULL; dp = dp->d_forw )  {
		if( dp->d_flags & DIR_SOLID )
			sol++;
		if( dp->d_flags & DIR_COMB )
			if( dp->d_flags & DIR_REGION )
				reg++;
			else
				comb++;
		if( dp->d_flags & DIR_BRANCH )
			br++;
d903 5
a907 3
	for( dp = DirHead; dp != DIR_NULL; dp = dp->d_forw )  {
		if( dp->d_flags & flag )
			col_item(dp->d_namep);
d922 1
d926 7
a932 5
	for( dp = DirHead; dp != DIR_NULL; dp = dp->d_forw )  {
		if( dp->d_nref > 0 )
			continue;
		/* Object is not a member of any combination */
		col_item(dp->d_namep);
@


2.2
log
@Paul Stay's Spline code
@
text
@d118 1
a118 1
	static long	addr;
d149 5
a153 5
	while(1)  {
		addr = lseek( objfd, 0L, 1 );
		if( (unsigned)read( objfd, (char *)&record, sizeof record )
				!= sizeof record )
			break;
d155 8
a162 13
		if( record.u_id == ID_IDENT )  {
			(void)printf("%s (units=%s)\n",
				record.i.i_title,
				units_str[record.i.i_units] );
			continue;
		}
		if( record.u_id == ID_FREE )  {
			/* Inform db manager of avail. space */
			memfree( &dbfreep, 1, addr/sizeof(union record) );
			continue;
		}
		if( record.u_id == ID_ARS_A )  {
			(void)dir_add( record.a.a_name, addr, DIR_SOLID, record.a.a_totlen+1 );
d164 16
a179 21
			/* Skip remaining B type records.	*/
			(void)lseek( objfd,
				(long)(record.a.a_totlen) *
				(long)(sizeof record),
				1 );
			continue;
		}
		if( record.u_id == ID_B_SPL_HEAD ) {
			dir_add( record.d.d_name, addr, DIR_SOLID, record.d.d_totlen+1 );
			/* Skip remaining B-spline records.    */
			(void)lseek( objfd,
				(long)(record.d.d_totlen+1) *
				(long)(sizeof( record )),
				1 );
			continue;
		}
		if( record.u_id == ID_SOLID )  {
			(void)dir_add( record.s.s_name, addr, DIR_SOLID, 1 );
			continue;
		}
		if( record.u_id == ID_P_HEAD )  {
d182 1
a182 1
			register int j;
d184 3
a186 8
			while(1) {
				j = read( objfd, (char *)&rec, sizeof(rec) );
				if( j != sizeof(rec) )
					break;
				if( rec.u_id != ID_P_DATA )  {
					(void)lseek( objfd, -(sizeof(rec)), 1 );
					break;
				}
a187 1
			}
d189 2
d193 23
a215 3
		if( record.u_id != ID_COMB )  {
			(void)printf( "dir_build:  unknown record %c (0%o)\n",
				record.u_id, record.u_id );
d219 1
a219 4
			if( !read_only )
				(void)write(objfd, (char *)&zapper, sizeof(zapper));
			memfree( &dbfreep, 1, addr/(sizeof(union record)) );
			continue;
d221 3
a223 10

		(void)dir_add( record.c.c_name,
			addr,
			record.c.c_flags == 'R' ?
				DIR_COMB|DIR_REGION : DIR_COMB,
			record.c.c_length+1 );
		/* Skip over member records */
		(void)lseek( objfd,
			(long)record.c.c_length * (long)sizeof record,
			1 );
d227 4
a230 1
	objfdend = lseek( objfd, 0L, 1 );
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.10 85/02/14 00:31:00 mike Exp $ (BRL)";
d117 1
d144 4
a147 1
	(void)lseek( objfd, 0L, 0 );
a148 1

d162 1
a162 1
			/* Ought to inform db manager of avail. space */
d176 9
a184 1

d273 4
a276 1
		if ( strcmp( str, dp->d_namep ) == 0 )
d729 1
a729 1
		(void)printf("dir_nref: fdopen failed\n");
@


1.10
log
@Allowed certain commands to be interrupted with SIGINT.
@
text
@d14 1
d25 1
d28 5
a32 1
 * Source -
d36 4
d42 1
a42 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.9 85/02/08 01:29:20 mike Exp $ (BRL)";
d50 1
a50 1
#include "db.h"
d53 2
a54 2
#include "dir.h"
#include "vmath.h"
d60 1
d88 1
d93 1
d140 1
a140 1
		strcat(cur_title, record.i.i_title);
d164 1
a164 1
			dir_add( record.a.a_name, addr, DIR_SOLID, record.a.a_totlen+1 );
d175 1
a175 1
			dir_add( record.s.s_name, addr, DIR_SOLID, 1 );
d188 1
a188 1
					lseek( objfd, -(sizeof(rec)), 1 );
d193 1
a193 1
			dir_add( record.p.p_name, addr, DIR_SOLID, nrec );
d208 1
a208 1
		dir_add( record.c.c_name,
a231 1
	register char	*cp;		/* -> name char to output */
d308 1
a308 1
	if( (base = malloc( strlen(cp)+1 )) == (char *)0 )  {
d366 1
a366 1
	memfree( &dbfreep, dp->d_len, dp->d_addr/(sizeof(union record)) );
d390 1
a390 1
	(void)lseek( objfd, dp->d_addr + offset * sizeof(union record), 0 );
d419 1
a419 1
	(void)lseek( objfd, dp->d_addr + offset * sizeof(union record), 0 );
d452 1
a452 1
	(void)lseek( objfd, dp->d_addr + offset * sizeof(union record), 0 );
d482 1
a482 1
	if( (addr = memalloc( &dbfreep, count )) == 0L )  {
a511 1
	unsigned long addr;
d526 1
a526 1
	if( memget( &dbfreep, count, dp->d_addr/sizeof(union record) ) == 0L )
d531 2
a532 2
		(void)lseek( objfd, dp->d_addr +
			((dp->d_len + i) * sizeof(union record)), 0 );
d597 1
d645 1
d670 1
d691 1
a691 1
	strcat(record.i.i_title, cur_title);
d702 1
d705 3
a707 3
	register struct directory *dp, *tdp;
	register int i;
	union record record;
d713 7
a719 2
	for( dp = DirHead; dp != DIR_NULL; dp = dp->d_forw )  {
		if( !(dp->d_flags&DIR_COMB) )
d721 6
a726 9
		for( i=1; i < dp->d_len; i++ )  {
			db_getrec( dp, &record, i );
			if( record.M.m_brname[0] != '\0' &&
			    (tdp = lookup(record.M.m_brname, LOOKUP_QUIET)) != DIR_NULL )
				tdp->d_nref++;
			if( record.M.m_instname[0] != '\0' &&
			    (tdp = lookup(record.M.m_instname, LOOKUP_QUIET)) != DIR_NULL )
				tdp->d_nref++;
		}
d728 1
d744 1
d825 5
a829 5
	printf("Summary:\n");
	printf("  %5d solids\n", sol);
	printf("  %5d regions, %d non-region combinations\n", reg, comb);
	printf("  %5d branch names\n", br);
	printf("  %5d total objects\n", sol+reg+comb );
@


1.9
log
@Allowed changes of local unit, even if file is read-only.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.8 85/02/05 04:17:31 mike Exp $ (BRL)";
d38 1
d221 1
d793 1
d834 1
@


1.8
log
@dir_nref, regexp_match, f_tops, dir_summary all added.
column support moved to columns.c
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.7 85/02/02 01:40:29 mike Exp $ (BRL)";
d634 1
a649 1

a650 2
	conversions( new_unit );

a651 1

a652 2


@


1.7
log
@Reclaim space from unknown records.
@
text
@d22 3
d32 1
a32 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.6 85/02/01 03:24:52 mike Exp $ (BRL)";
d217 1
a217 1
	struct directory	*dp;
a218 2
	register int	count;		/* names listed on current line */
	register int	len;		/* length of previous name */
a219 4
#define	COLUMNS	((80 + NAMESIZE - 1) / NAMESIZE)

	count = 0;
	len = 0;
d221 5
a225 29
		if ( (cp = dp->d_namep)[0] == '\0' )
			continue;	/* empty slot */

		/* Tab to start column. */
		if ( count != 0 )
			do
				(void)putchar( '\t' );
			while ( (len += 8) < NAMESIZE );

		/* Output name and save length for next tab. */
		len = 0;
		do {
			(void)putchar( *cp++ );
			++len;
		}  while ( *cp != '\0' );
		if( dp->d_flags & DIR_COMB )  {
			(void)putchar( '/' );
			++len;
		}
		if( dp->d_flags & DIR_REGION )  {
			(void)putchar( 'R' );
			++len;
		}

		/* Output newline if last column printed. */
		if ( ++count == COLUMNS )  {	/* line now full */
			(void)putchar( '\n' );
			count = 0;
		}
d227 1
a227 4
	/* No more names. */
	if ( count != 0 )		/* partial line */
		(void)putchar( '\n' );
#undef	COLUMNS
d683 161
@


1.6
log
@Default units are now MM.
Made more liberal with accepting databases with wrong versions.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.5 85/02/01 00:50:19 mike Exp $ (BRL)";
d55 1
d182 6
a187 1
			/* skip this record */
a371 2
static union record zapper;

@


1.5
log
@Keith's global/local units additions
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: dir.c,v 1.4 85/01/16 01:56:54 mike Exp $ (BRL)";
d108 12
a119 6
	}
	else {
		/* have ID record - set up the unit conversion factors */
		localunit = record.i.i_units;
		conversions( record.i.i_units );

a122 1

a134 5
			if( strcmp( record.i.i_version, ID_VERSION) != 0 )  {
				(void)printf("File is Version %s, Program is version %s\n",
					record.i.i_version, ID_VERSION );
				finish(8);
			}
d614 1
a614 2
	/*	This routine assumes the base unit == inches
	 */
d617 4
a620 4
		case ID_NO_UNIT:
			/* no local unit specified ... use the base unit(inches) */
			localunit = record.i.i_units = ID_IN_UNIT;
			local2base = base2local = 1.0;
d623 3
a625 4
		case ID_MM_UNIT:
			/* local unit is mm */
			local2base = 1.0 / 25.4;
			base2local = 25.4;
d628 3
a630 4
		case ID_CM_UNIT:
			/* local unit is cm */
			local2base = 1.0 / 2.54;
			base2local = 2.54;
d633 3
a635 4
		case ID_M_UNIT:
			/* local unit is meters */
			local2base = 1.0 / .0254;
			base2local = .0254;
d638 3
a640 3
		case ID_IN_UNIT:
			/* local unit is inches */
			local2base = base2local = 1.0;
d643 3
a645 4
		case ID_FT_UNIT:
			/* local unit is feet */
			base2local = 1.0 / 12.0;
			local2base = 12.0;
d648 3
a650 3
		default:
			local2base = base2local = 1.0;
			localunit = 6;
a651 1

d653 1
a653 1

a655 3



a708 1

a709 1

@


1.4
log
@pre-Keith version
@
text
@d19 3
d29 1
a29 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d56 2
d67 3
d106 2
d109 11
d121 2
d605 116
@


1.3
log
@Multiple simultaneous display manager support
@
text
@d5 1
d7 1
a7 2
 *	toc		Print table-of-contents of object file
 *	eraseobj	Drop an object from the visible list
a8 1
 *	pr_solids	Print info about visible list
d15 9
d25 3
d33 1
a33 1
#include "3d.h"
d46 2
d63 1
d77 1
d119 1
a231 29
 *			E R A S E O B J
 *
 * This routine goes through the solid table and deletes all displays
 * which contain the specified object in their 'path'
 */
void
eraseobj( dp )
register struct directory *dp;
{
	register struct solid *sp;
	static struct solid *nsp;
	register int i;

	sp=HeadSolid.s_forw;
	while( sp != &HeadSolid )  {
		nsp = sp->s_forw;
		for( i=0; i<=sp->s_last; i++ )  {
			if( sp->s_path[i] == dp )  {
				memfree( &(dmp->dmr_map), sp->s_addr, sp->s_bytes );
				DEQUEUE_SOLID( sp );
				FREE_SOLID( sp );
				break;
			}
		}
		sp = nsp;
	}
}

/*
a258 29
 *			P R _ S O L I D S
 *
 *  Given a pointer to a member of the circularly linked list of solids
 *  (typically the head), chase the list and print out the information
 *  about each solid structure.
 */
void
pr_solids( startp )
struct solid *startp;
{
	register struct solid *sp;
	register int i;

	sp = startp->s_forw;
	while( sp != startp )  {
		for( i=0; i <= sp->s_last; i++ )
			(void)printf("/%s", sp->s_path[i]->d_namep);
		(void)printf("  %s", sp->s_flag == UP ? "VIEW":"-NO-" );
		if( sp->s_iflag == UP )
			(void)printf(" ILL");
		(void)printf(" [%f,%f,%f] size %f",
			sp->s_center[X], sp->s_center[Y], sp->s_center[Z],
			sp->s_size);
		(void)putchar('\n');
		sp = sp->s_forw;
	}
}

/*
a319 1
printf("dir_delete(%s)\n", dp->d_namep);
d334 1
a334 1
	printf("dir_delete:  unable to find %s\n", dp->d_namep );
a350 1
printf("db_delete(%s) len=%d\n", dp->d_namep, dp->d_len);
d355 1
d383 1
a383 1
		printf("db_getrec(%s):  read error.  Wanted %d, got %d\n",
d390 29
d432 4
d445 1
a445 1
		printf("db_putrec(%s):  write error\n", dp->d_namep );
d459 20
a478 2
	/* For now, a dumb algorithm. */
	dp->d_addr = objfdend;
d480 6
a485 1
	objfdend += count * sizeof(union record);
d501 1
d503 5
d514 6
a519 2
printf("db_grow(%s, %d) ", dp->d_namep, count );
	/* Next, check to see if granules are all availible */
d524 3
a526 1
		if( rec.u_id != ID_FREE )
d528 1
a529 1
printf("easy -- following records were free\n");
a534 1
printf("hard -- make copy\n");
d558 4
a561 1
printf("db_trunc(%s, %d)\n", dp->d_namep, count );
d567 14
@


1.2
log
@Vector lists saved, multiple display managers supported.
@
text
@d27 1
d234 1
a234 1
				freevgcore( sp->s_addr, sp->s_bytes );
@


1.1
log
@Initial revision
@
text
@d18 1
d35 1
a35 1
extern int	objfd;			/* FD of object file */
d48 1
d51 17
a67 1
 *			B U I L D D I R
@
