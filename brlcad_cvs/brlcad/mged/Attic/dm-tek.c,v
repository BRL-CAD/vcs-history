head	11.7;
access;
symbols
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.5;
locks; strict;
comment	@ * @;


11.7
date	98.10.23.15.12.07;	author bparker;	state dead;
branches;
next	11.6;

11.6
date	96.10.22.21.10.18;	author bparker;	state Exp;
branches;
next	11.5;

11.5
date	96.09.03.20.02.37;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	96.08.27.20.30.05;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	96.05.02.21.33.02;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	96.04.24.16.20.56;	author bparker;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.02.58;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.24.01.05.23;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.12.23.22.59.51;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.12.16.19.36.16;	author gdurf;	state Exp;
branches;
next	10.8;

10.8
date	94.11.05.03.53.41;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.10.14.17.07.04;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.10.14.16.06.31;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.09.06.17.18.37;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.09.06.17.15.01;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.21.42.55;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.15.15.34;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.43.33;	author mike;	state Rel4_0;
branches;
next	9.7;

9.7
date	91.08.30.03.01.05;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.07.19.01.14.05;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.02.02.00.01.08;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.01.12.08.25.35;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.01.03.22.52.20;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.12.13.04.17.19;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.02.48;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.21.04.55.35;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.06.20.39.44;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.06.01.07.05;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.36.35;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.15.21.03.09;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.05.15.23.05.01;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.25.06.06.51;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.11.05.05.05.19;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.00.12;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.03.24;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.19.58;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.07.04;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.20.57;	author mike;	state Rel1;
branches;
next	2.8;

2.8
date	86.08.14.22.22.02;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.08.12.06.48.53;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	85.09.14.05.35.54;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.08.07.05.18.22;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.06.03.16.49.05;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.05.10.00.53.20;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.03.15.05.04.41;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.03.11.23.55.22;	author mike;	state Prod;
branches;
next	1.4;

1.4
date	85.03.08.20.51.10;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.02.02.01.39.04;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.01.19.03.56.55;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.01.17.07.20.24;	author mike;	state Exp;
branches;
next	;


desc
@Tektronix 4014 display manager.
Especially good for 2-windows on a BLIT
@


11.7
log
@*- moved old display managers to dm_old
@
text
@/*
 *			D M - T E K . C
 *
 * An unsatisfying (but useful) hack to allow GED to display
 * its images on Tektronix 4014 compatible displays.
 * Mostly, a precursor for BLIT and RasterTek code.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/dm-tek.c,v 11.6 1996/10/22 21:10:18 bparker Exp bparker $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <sys/time.h>		/* for struct timeval */
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "./ged.h"
#include "./titles.h"
#include "./dm.h"
#include "./solid.h"

/* Display Manager package interface */

#define TEKBOUND	1000.0	/* Max magnification in Rot matrix */
int	Tek_init();
int	Tek_open();
void	Tek_close();
MGED_EXTERN(void	Tek_input, (fd_set *input, int noblock) );
void	Tek_prolog(), Tek_epilog();
void	Tek_normal(), Tek_newrot();
void	Tek_update();
void	Tek_puts(), Tek_2d_line(), Tek_light();
int	Tek_object();
unsigned Tek_cvtvecs(), Tek_load();
void	Tek_statechange(), Tek_viewchange(), Tek_colorchange();
void	Tek_window(), Tek_debug();
int     Tek_dm();

struct dm dm_Tek = {
  Tek_init,
  Tek_open, Tek_close,
  Tek_input,
  Tek_prolog, Tek_epilog,
  Tek_normal, Tek_newrot,
  Tek_update,
  Tek_puts, Tek_2d_line,
  Tek_light,
  Tek_object,
  Tek_cvtvecs, Tek_load,
  Tek_statechange,
  Tek_viewchange,
  Tek_colorchange,
  Tek_window, Tek_debug, Tek_dm, 0,
  0,				/* no displaylist */
  0,				/* can't rt to this */
  TEKBOUND,
  "tek", "Tektronix 4014",
  0,
  0,
  0,
  0
};

extern struct device_values dm_values;	/* values read from devices */
static int tek_count = 0;
static vect_t clipmin, clipmax;		/* for vector clipping */

#define BELL	007
#define	FF	014
#define SUB	032		/* Turn on graphics cursor */
#define GS	035		/* Enter Graphics Mode (1st vec dark) */
#define ESC	033
#define US	037		/* Enter Alpha Mode */

static int second_fd;		/* fd of Tektronix if not /dev/tty */
static FILE *outfp;		/* Tektronix device to output on */
static char ttybuf[BUFSIZ];
static int blit_emulator=0;	/* boolean: tek emulation on blit */

static void	tekmove(), tekcont(), get_cursor(), tekerase();
static void	teklabel(), teklinemod(), tekpoint();

/*
 * Display coordinate conversion:
 *  Tektronix is using 0..4096
 *  GED is using -2048..+2048
 */
#define	GED_TO_TEK(x)	(((x)+2048) * 780 / 1024)
#define TEK_TO_GED(x)	(((x) * 1024 / 780) - 2048)

Tek_init()
{
  return TCL_OK;
}

/*
 *			T E K _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
Tek_open()
{
  char line[64], line2[64];
  char *p;

  if(tek_count){
    ++tek_count;
    Tcl_AppendResult(interp, "Tek_open: tek is already open\n", (char *)NULL);
    return TCL_ERROR;
  }

  (void)sprintf(line, "%s", dname);

  /* check for blit emulator flag */
  if (p=strchr(line, ' ')){
    *p++ = '\0';
    while (*p && *p != '-') ++p;
    if (*p && p[1] == 'b') blit_emulator = 1;
  }

  if( (outfp = fopen(line, "r+w")) == NULL ) {
    (void)sprintf(line2, "/dev/tty%s%c", line, '\0' );
    if( (outfp = fopen(line2, "r+w")) == NULL ){
      if( (outfp = fopen("/dev/tty","r+w")) == NULL ){
	Tcl_AppendResult(interp, "Tek_open: failed to open ", dname,
			 ", ", line, " and /dev/tty", (char *)NULL);
	return TCL_ERROR;
      }else 
	second_fd = 0;          /* no second filedes */
    }else
      second_fd = fileno(outfp);
  }else
    second_fd = fileno(outfp);

  setbuf( outfp, ttybuf );

  bu_vls_printf(&pathName, ".dm_tek");

  if(second_fd)
    Tk_CreateFileHandler(second_fd, 1, get_cursor, (ClientData)NULL);

  tek_count = 1;
  return TCL_OK;
}

/*
 *  			T E K _ C L O S E
 *  
 *  Gracefully release the display.
 */
void
Tek_close()
{
  if(tek_count > 1){
    --tek_count;
    return;
  }
  
  (void)putc(US,outfp);
    (void)fflush(outfp);
    fclose(outfp);
    tek_count = 0;
}

/*
 *			T E K _ R E S T A R T
 *
 * Used when the display processor wanders off.
 */
void
Tek_restart()
{
  Tcl_AppendResult(interp, "Tek_restart\n", (char *)NULL);
}

/*
 *			T E K _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
void
Tek_prolog()
{
	/* If something significant has happened, clear screen and redraw */
	tekerase();
	/* Miniature typeface */
	(void)putc(ESC,outfp);
	(void)putc(';',outfp);

	/* Put the center point up */
	tekpoint( 0, 0 );
}

/*
 *			T E K _ E P I L O G
 */
void
Tek_epilog()
{
	tekmove( TITLE_XBASE, SOLID_YBASE );
	(void)putc(US,outfp);
	(void)fflush(outfp);
}

/*
 *  			T E K _ N E W R O T
 *  Stub.
 */
/* ARGSUSED */
void
Tek_newrot(mat)
mat_t mat;
{
	return;
}

/*
 *  			T E K _ O B J E C T
 *  
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */
/* ARGSUSED */
int
Tek_object( sp, mat, ratio, white )
register struct solid *sp;
mat_t mat;
double ratio;
{
	static vect_t			last;
	register struct rt_vlist	*vp;
	int				useful = 0;

	if(  sp->s_soldash )
		(void)putc('b',outfp);	/* Dot dash */
	else
		(void)putc('`',outfp);	/* Solid */

	for( BU_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			static vect_t	start, fin;
			switch( *cmd )  {
			case RT_VLIST_POLY_START:
			case RT_VLIST_POLY_VERTNORM:
				continue;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				MAT4X3PNT( last, model2view, *pt );
				continue;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				/* draw */
				MAT4X3PNT( fin, model2view, *pt );
				VMOVE( start, last );
				VMOVE( last, fin );
				break;
			}
			if(
				vclip( start, fin, clipmin, clipmax ) == 0
			)  continue;
			tekmove(	(int)( start[0] * 2047 ),
				(int)( start[1] * 2047 ) );
			tekcont(	(int)( fin[0] * 2047 ),
				(int)( fin[1] * 2047 ) );
			useful = 1;
		}
	}
	return(useful);
}

/*
 *			T E K _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
void
Tek_normal()
{
	return;
}

/*
 *			T E K _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
void
Tek_update()
{
	if( second_fd )  {
		/* put up graphics cursor */
		(void)putc(ESC,outfp);
		(void)putc(SUB,outfp);
	} else
		(void)putc(US,outfp);		/* Alpha mode */
	(void)fflush(outfp);
}

/*
 *			T E K _ P U T S
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
void
Tek_puts( str, x, y, size, color )
register char *str;
{
	tekmove(x,y);
	teklabel(str);
}

/*
 *			T E K _ 2 D _ G O T O
 *
 */
void
Tek_2d_line( x1, y1, x2, y2, dashed )
int x1, y1;
int x2, y2;
int dashed;
{
	if( dashed )
		teklinemod("dotdashed");
	else
		teklinemod("solid");
	tekmove(x1,y1);
	tekcont(x2,y2);
}

/*
 *			G E T _ C U R S O R
 *  
 *  Read the Tektronix cursor.  The Tektronix sends
 *  6 bytes:  The key the user struck, 4 bytes of
 *  encoded position, and a return (newline).
 *  Note this is is complicated if the user types
 *  a return or linefeed.
 *  (The terminal is assumed to be in cooked mode)
 */
static void
get_cursor(clientData, mask)
ClientData clientData;
int mask;
{
	register char *cp;
	char ibuf[64];
	register int i;
	int hix, hiy, lox, loy;
	int xpen, ypen;

	if ( blit_emulator ) {
		i = read( second_fd, ibuf, sizeof(ibuf) );
		if (i < 4) {
			register int j;
			Tcl_AppendResult(interp, "Short Blit read\n", (char *)NULL);
			for (j=0 ; j < i ; ++j){
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, "%c(%x)\n", ibuf[j], ibuf[j]);
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			}
			return;
		}
		cp = &ibuf[i-6];
		if ( i > 4 && (cp[4] != '\n' || cp[5] != 4 )) {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "saw:%c(%x) %c(%x) %c(%x) %c(%x) %c(%x) %c(%x)\n",
				cp[0], cp[0], cp[1], cp[1], cp[2], cp[2],
				cp[3], cp[3], cp[4], cp[4], cp[5], cp[5] );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  return;
		}
		hix = ((int)cp[0]&037)<<7;
		lox = ((int)cp[1]&037)<<2;
		hiy = ((int)cp[2]&037)<<7;
		loy = ((int)cp[3]&037)<<2;
/*		bu_log("mouse: %d,%d\n",
			TEK_TO_GED(hix|lox), TEK_TO_GED(hiy|loy)); */

		xpen = TEK_TO_GED(hix|lox);
		ypen = TEK_TO_GED(hiy|loy);
		if( xpen < -2048 || xpen > 2048 )
			xpen = 0;
		if( ypen < -2048 || ypen > 2048 )
			ypen = 0;

		bu_vls_printf( &dm_values.dv_string , "M 1 %d %d\n", xpen, ypen );

		return;
	} else {
		/* ASSUMPTION:  Input is line buffered (tty cooked) */
		i = read( second_fd, ibuf, sizeof(ibuf) );
		/* The LAST 6 chars are the string from the tektronix */
		if( i < 6 )  {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls, "short read of %d\n", i);
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  bu_vls_free(&tmp_vls);
		  return;		/* Fails if he hits RETURN */
			
		}
		cp = &ibuf[i-6];
		if( cp[5] != '\n' )  {
		  struct bu_vls tmp_vls;

		  bu_vls_init(&tmp_vls);
		  bu_vls_printf(&tmp_vls,
				"cursor synch?\nsaw:%c(%x) %c(%x) %c(%x) %c(%x) %c(%x) %c(%x)\n",
				cp[0], cp[0], cp[1], cp[1], cp[2], cp[2],
				cp[3], cp[3], cp[4], cp[4], cp[5], cp[5] );
		  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		  return;
		}

		/* cp[0] is what user typed, followed by 4pos + NL */
		hix = ((int)cp[1]&037)<<7;
		lox = ((int)cp[2]&037)<<2;
		hiy = ((int)cp[3]&037)<<7;
		loy = ((int)cp[4]&037)<<2;
		/* Tek positioning is 0..4096,
		 * The desired range is -2048 <= x,y <= +2048.
		 */
		xpen = TEK_TO_GED(hix|lox);
		ypen = TEK_TO_GED(hiy|loy);
		if( xpen < -2048 || xpen > 2048 )
			xpen = 0;
		if( ypen < -2048 || ypen > 2048 )
			ypen = 0;
		
		switch(cp[0])  {
		case 'Z':
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "x=%d,y=%d\n", xpen, ypen);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		  }
		  break;		/* NOP */
		case 'b':
			bu_vls_strcat( &dm_values.dv_string, "zoom 2\n");
			break;
		case 's':
			bu_vls_strcat( &dm_values.dv_string, "zoom 0.5\n");
			break;
		case '.':
			bu_vls_printf( &dm_values.dv_string, "M 1 %d %d\n", xpen, ypen );
			break;
		default:
		  Tcl_AppendResult(interp, "s=smaller, b=bigger, .=slew, space=pick/slew\n",
				   (char *)NULL);
		  return;
		case ' ':
			bu_vls_printf( &dm_values.dv_string, "M 1 %d %d\n", xpen, ypen );
			break;
		}
	}
}

/*
 *			T E K _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream, or a device event has
 * occured, unless "noblock" is set.
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 */
void
Tek_input( input, noblock )
fd_set		*input;
int		noblock;
{
	struct timeval	tv;
	int		width;
	int		cnt;
#if 0
#if defined(_SC_OPEN_MAX)
	if( (width = sysconf(_SC_OPEN_MAX)) <= 0 )
#endif
		width = 32;

	if( second_fd )  FD_SET( second_fd, input );

	/*
	 * Check for input on the keyboard
	 *
	 * Suspend execution until either
	 *  1)  User types a full line
	 *  2)  The timelimit on SELECT has expired
	 *
	 * If a RATE operation is in progress (zoom, rotate, slew)
	 * in which we still have to update the display,
	 * do not suspend execution.
	 */
	tv.tv_sec = 0;
	if( noblock )  {
		tv.tv_usec = 0;
	}  else  {
		/* 1/20th second */
		tv.tv_usec = 50000;
	}
	cnt = select( width, input, (fd_set *)0,  (fd_set *)0, &tv );
	if( cnt < 0 )  {
		perror("dm-tek/select");
	}

	if( second_fd && FD_ISSET(second_fd, input) )
		get_cursor();
#endif
}

/* 
 *			T E K _ L I G H T
 */
/* ARGSUSED */
void
Tek_light( cmd, func )
int cmd;
int func;			/* BE_ or BV_ function */
{
	return;
}

/* ARGSUSED */
unsigned
Tek_cvtvecs( sp )
struct solid *sp;
{
	return( 0 );
}

/*
 * Loads displaylist
 */
unsigned
Tek_load( addr, count )
unsigned addr, count;
{
  struct bu_vls tmp_vls;

  bu_vls_init(&tmp_vls);
  bu_vls_printf(&tmp_vls, "Tek_load(x%x, %d.)\n", addr, count );
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
  bu_vls_free(&tmp_vls);

  return( 0 );
}

void
Tek_statechange()
{
}

void
Tek_viewchange()
{
}

void
Tek_colorchange()
{
}

/*
 * Perform the interface functions
 * for the Tektronix 4014-1 with Extended Graphics Option.
 * The Extended Graphics Option makes available a field of
 * 10 inches vertical, and 14 inches horizontal, with a resolution
 * of 287 points per inch.
 *
 * The Tektronix is Quadrant I, 4096x4096 (not all visible).
 */
static int oloy = -1;
static int ohiy = -1;
static int ohix = -1;
static int oextra = -1;

/* The input we see is -2048..+2047 */
/* Continue motion from last position */
static void
tekcont(x,y)
register int x,y;
{
	int hix,hiy,lox,loy,extra;
	int n;

	x = GED_TO_TEK(x);
	y = GED_TO_TEK(y);

	hix=(x>>7) & 037;
	hiy=(y>>7) & 037;
	lox = (x>>2)&037;
	loy=(y>>2)&037;
	extra=x&03+(y<<2)&014;
	n = (abs(hix-ohix) + abs(hiy-ohiy) + 6) / 12;
	if(hiy != ohiy){
		(void)putc(hiy|040,outfp);
		ohiy=hiy;
	}
	if(hix != ohix) {
		if(extra != oextra) {
			(void)putc(extra|0140,outfp);
			oextra=extra;
		}
		(void)putc(loy|0140,outfp);
		(void)putc(hix|040,outfp);
		ohix=hix;
		oloy=loy;
	} else {
		if(extra != oextra) {
			(void)putc(extra|0140,outfp);
			(void)putc(loy|0140,outfp);
			oextra=extra;
			oloy=loy;
		} else if(loy != oloy) {
			(void)putc(loy|0140,outfp);
			oloy=loy;
		}
	}
	(void)putc(lox|0100,outfp);
	while(n--)
		(void)putc(0,outfp);
}

static void
tekmove(xi,yi)
{
	(void)putc(GS,outfp);			/* Next vector blank */
	tekcont(xi,yi);
}

static void
tekerase()
{
	extern unsigned sleep();	/* DAG -- was missing */

	(void)putc(ESC,outfp);
	(void)putc(FF,outfp);
	ohix = ohiy = oloy = oextra = -1;
	(void)fflush(outfp);

	/* If 2 FD's, it's probably a BLIT, otherwise assume real Tek */
#ifdef BLIT
	if( !second_fd )
#endif
		(void)sleep(3);
}

static void
teklabel(s)
register char *s;
{
	(void)putc(US,outfp);
	for( ; *s; s++ )
		(void)putc(*s,outfp);
	ohix = ohiy = oloy = oextra = -1;
}

static void
teklinemod(s)
register char *s;
{
	register int c;				/* DAG -- was char */

	(void)putc(ESC,outfp);
	switch(s[0]){
	case 'l':	
		c = 'd';
		break;
	case 'd':	
		if(s[3] != 'd')c='a';
		else c='b';
		break;
	case 's':
		if(s[5] != '\0')c='c';
		else c='`';
		break;
	default:			/* DAG -- added support for colors */
		c = '`';
		break;
	}
	(void)putc(c,outfp);
}

static void
tekpoint(xi,yi){
	tekmove(xi,yi);
	tekcont(xi,yi);
}

/* ARGSUSED */
void
Tek_debug(lvl)
{
}

void
Tek_window(w)
register int w[];
{
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
}

int
Tek_dm(argc, argv)
int argc;
char *argv[];
{
  return TCL_OK;
}
@


11.6
log
@hacks to use latest libdm
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 11.5 1996/09/03 20:02:37 bparker Exp bparker $ (BRL)";
@


11.5
log
@rt_list ---> bu_list
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 11.4 1996/08/27 20:30:05 bparker Exp bparker $ (BRL)";
d46 1
d58 1
d61 22
a82 17
	Tek_open, Tek_close,
	Tek_input,
	Tek_prolog, Tek_epilog,
	Tek_normal, Tek_newrot,
	Tek_update,
	Tek_puts, Tek_2d_line,
	Tek_light,
	Tek_object,
	Tek_cvtvecs, Tek_load,
	Tek_statechange,
	Tek_viewchange,
	Tek_colorchange,
	Tek_window, Tek_debug,
	0,				/* no displaylist */
	0,				/* can't rt to this */
	TEKBOUND,
	"tek", "Tektronix 4014"
d112 5
d754 8
@


11.4
log
@now using libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 11.3 1996/05/02 21:33:02 bparker Exp bparker $ (BRL)";
d34 1
d252 1
a252 1
	for( RT_LIST_FOR( vp, rt_vlist, &(sp->s_vlist) ) )  {
@


11.3
log
@Still Tcl'ing the code
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 11.2 1996/04/24 16:20:56 bparker Exp bparker $ (BRL)";
d146 1
a146 1
  rt_vls_printf(&pathName, ".dm_tek");
d379 1
a379 1
			  struct rt_vls tmp_vls;
d381 4
a384 4
			  rt_vls_init(&tmp_vls);
			  rt_vls_printf(&tmp_vls, "%c(%x)\n", ibuf[j], ibuf[j]);
			  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
			  rt_vls_free(&tmp_vls);
d390 1
a390 1
		  struct rt_vls tmp_vls;
d392 2
a393 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "saw:%c(%x) %c(%x) %c(%x) %c(%x) %c(%x) %c(%x)\n",
d396 2
a397 2
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d404 1
a404 1
/*		rt_log("mouse: %d,%d\n",
d414 1
a414 1
		rt_vls_printf( &dm_values.dv_string , "M 1 %d %d\n", xpen, ypen );
d422 1
a422 1
		  struct rt_vls tmp_vls;
d424 4
a427 4
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls, "short read of %d\n", i);
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		  rt_vls_free(&tmp_vls);
d433 1
a433 1
		  struct rt_vls tmp_vls;
d435 2
a436 2
		  rt_vls_init(&tmp_vls);
		  rt_vls_printf(&tmp_vls,
d440 1
a440 1
		  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
d462 1
a462 1
		    struct rt_vls tmp_vls;
d464 4
a467 4
		    rt_vls_init(&tmp_vls);
		    rt_vls_printf(&tmp_vls, "x=%d,y=%d\n", xpen, ypen);
		    Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
		    rt_vls_free(&tmp_vls);
d471 1
a471 1
			rt_vls_strcat( &dm_values.dv_string, "zoom 2\n");
d474 1
a474 1
			rt_vls_strcat( &dm_values.dv_string, "zoom 0.5\n");
d477 1
a477 1
			rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n", xpen, ypen );
d484 1
a484 1
			rt_vls_printf( &dm_values.dv_string, "M 1 %d %d\n", xpen, ypen );
d572 1
a572 1
  struct rt_vls tmp_vls;
d574 4
a577 4
  rt_vls_init(&tmp_vls);
  rt_vls_printf(&tmp_vls, "Tek_load(x%x, %d.)\n", addr, count );
  Tcl_AppendResult(interp, rt_vls_addr(&tmp_vls), (char *)NULL);
  rt_vls_free(&tmp_vls);
@


11.2
log
@still tcl-converting
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 11.1 1995/01/04 10:02:58 mike Rel4_4 bparker $ (BRL)";
d113 1
d121 12
a132 4
#if 1
  if( (outfp = fopen(dname, "r+w")) == NULL ) {
    (void)sprintf(line, "/dev/tty%s%c", dname, '\0' );
    if( (outfp = fopen(line, "r+w")) == NULL ){
d143 4
a146 14
#else
	rt_log("Output tty [stdout]? ");
	(void)fgets( line, sizeof(line), stdin );	/* \n, Null terminated */
	line[strlen(line)-1] = '\0';			/* remove newline */
	if( feof(stdin) )  quit();
	if( line[0] != '\0' )  {
		char *p;

		/* check for blit emualtor flag */
		if (p=strchr(line, ' ')) {
			*p++ = '\0';
			while (*p && *p != '-') ++p;
			if (*p && p[1] == 'b') blit_emulator = 1;
		}
d148 2
a149 15
		if( (outfp = fopen(line,"r+w")) == NULL )  {
			(void)sprintf( line2, "/dev/tty%s%c", line, '\0' );
			if( (outfp = fopen(line2,"r+w")) == NULL )  {
				perror(line);
				return(1);		/* BAD */
			}
		}
		second_fd = fileno(outfp);
	} else {
		if( (outfp = fopen("/dev/tty","r+w")) == NULL )
			return(1);	/* BAD */
		second_fd = 0;		/* no second filedes */
	}
#endif
	setbuf( outfp, ttybuf );
d151 2
a152 3
	tek_count = 1;
	rt_vls_printf(&pathName, ".dm_tek");
	return(0);			/* OK */
d182 1
a182 1
	rt_log("Tek_restart\n");
a192 3
	if( !dmaflag )
		return;

a208 2
	if( !dmaflag )
		return;
d363 3
a365 1
get_cursor()
d377 9
a385 3
			rt_log("Short Blit read\n");
			for (j=0 ; j < i ; ++j)
				rt_log("%c(%x)\n", ibuf[j], ibuf[j]);
d390 4
a393 1
			rt_log("saw:%c(%x) %c(%x) %c(%x) %c(%x) %c(%x) %c(%x)\n",
d396 3
a398 1
			return;
d422 7
a428 2
			rt_log("short read of %d\n", i);
			return;		/* Fails if he hits RETURN */
d433 5
a437 2
			rt_log("cursor synch?\n");
			rt_log("saw:%c(%x) %c(%x) %c(%x) %c(%x) %c(%x) %c(%x)\n",
d440 2
a441 1
			return;
d461 9
a469 2
			rt_log("x=%d,y=%d\n", xpen, ypen);
			break;		/* NOP */
d480 3
a482 2
			rt_log("s=smaller, b=bigger, .=slew, space=pick/slew\n");
			return;
d509 1
a509 1

d542 1
d572 8
a579 2
	rt_log("Tek_load(x%x, %d.)\n", addr, count );
	return( 0 );
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.11 94/12/24 01:05:23 mike Exp $ (BRL)";
d78 1
a78 1

d112 1
a112 1
	char line[64], line2[64];
d114 21
d162 1
d164 3
d178 9
a186 3
	(void)putc(US,outfp);
	(void)fflush(outfp);
	fclose(outfp);
d231 1
@


10.11
log
@Eliminated old dm_values.dv_* style "polled" device interface.
Everything is done by string commands now.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.10 94/12/23 22:59:51 mike Exp Locker: mike $ (BRL)";
@


10.10
log
@Added code to skip per-vertex normals.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.9 94/12/16 19:36:16 gdurf Exp Locker: mike $ (BRL)";
a496 2

	dm_values.dv_penpress = 0;
@


10.9
log
@Converted printf(...) and fprintf(stdout, ...) to rt_log(...).
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.8 1994/11/05 03:53:41 mike Exp gdurf $ (BRL)";
d248 1
@


10.8
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.7 94/10/14 17:07:04 mike Exp Locker: mike $ (BRL)";
d114 1
a114 1
	(void)printf("Output tty [stdout]? ");
d166 1
a166 1
	(void)printf("Tek_restart\n");
d362 1
a362 1
			(void)printf("Short Blit read\n");
d364 1
a364 1
				(void)printf("%c(%x)\n", ibuf[j], ibuf[j]);
d369 1
a369 1
			(void)printf("saw:%c(%x) %c(%x) %c(%x) %c(%x) %c(%x) %c(%x)\n",
d378 1
a378 1
/*		(void)printf("mouse: %d,%d\n",
d396 1
a396 1
			(void)printf("short read of %d\n", i);
d402 2
a403 2
			(void)printf("cursor synch?\n");
			(void)printf("saw:%c(%x) %c(%x) %c(%x) %c(%x) %c(%x) %c(%x)\n",
d426 1
a426 1
			(void)printf("x=%d,y=%d\n", xpen, ypen);
d438 1
a438 1
			(void)printf("s=smaller, b=bigger, .=slew, space=pick/slew\n");
d530 1
a530 1
	(void)printf("Tek_load(x%x, %d.)\n", addr, count );
@


10.7
log
@#if defined(_SC_OPEN_MAX)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.6 94/10/14 16:06:31 mike Exp Locker: mike $ (BRL)";
a112 1
	int i;
@


10.6
log
@Changed from getdtablesize() to sysconf(_SC_OPEN_MAX)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.5 94/09/06 17:18:37 jra Exp Locker: mike $ (BRL)";
d468 1
d470 1
@


10.5
log
@Fixed bug in get_cursor.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.4 94/09/06 17:15:01 jra Exp Locker: jra $ (BRL)";
d468 1
a468 1
	if( (width = getdtablesize()) <= 0 )
@


10.4
log
@Converted to use vls strings instead of changing dm_values.XXXX.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.3 94/08/10 21:42:55 mike Exp Locker: jra $ (BRL)";
d436 1
a436 1
			rt_vls_strcat( &dm_values.dv_string, "M 1 %d %d\n", xpen, ypen );
d442 1
a442 1
			rt_vls_strcat( &dm_values.dv_string, "M 1 %d %d\n", xpen, ypen );
@


10.3
log
@Changed calling sequence to dmr_input(), to pass an fd_set rather
than a single file descriptor.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.2 94/08/09 15:15:34 gdurf Exp Locker: mike $ (BRL)";
d357 1
d382 6
a387 6
		dm_values.dv_xpen = TEK_TO_GED(hix|lox);
		dm_values.dv_ypen = TEK_TO_GED(hiy|loy);
		if( dm_values.dv_xpen < -2048 || dm_values.dv_xpen > 2048 )
			dm_values.dv_xpen = 0;
		if( dm_values.dv_ypen < -2048 || dm_values.dv_ypen > 2048 )
			dm_values.dv_ypen = 0;
d389 2
a390 4
		if (dm_values.dv_xpen < MENUXLIM )
			dm_values.dv_penpress = DV_PICK;
		else
			dm_values.dv_penpress = DV_SLEW;
d418 6
a423 6
		dm_values.dv_xpen = TEK_TO_GED(hix|lox);
		dm_values.dv_ypen = TEK_TO_GED(hiy|loy);
		if( dm_values.dv_xpen < -2048 || dm_values.dv_xpen > 2048 )
			dm_values.dv_xpen = 0;
		if( dm_values.dv_ypen < -2048 || dm_values.dv_ypen > 2048 )
			dm_values.dv_ypen = 0;
d427 1
a427 1
			(void)printf("x=%d,y=%d\n", dm_values.dv_xpen, dm_values.dv_ypen);
d430 1
a430 1
			dm_values.dv_penpress = DV_INZOOM;
d433 1
a433 1
			dm_values.dv_penpress = DV_OUTZOOM;
d436 1
a436 1
			dm_values.dv_penpress = DV_SLEW;
d442 1
a442 1
			dm_values.dv_penpress = DV_PICK;
@


10.2
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 10.1 1991/10/12 06:43:33 mike Rel4_0 gdurf $ (BRL)";
d27 1
d47 1
a47 1
int	Tek_input();
d456 3
a458 5
 * The GED "generic input" structure is filled in.
 *
 * Returns:
 *	0 if no command waiting to be read,
 *	1 if command is waiting to be read.
d460 4
a463 1
Tek_input( cmd_fd, noblock )
d465 3
a467 1
	static long readfds;
d469 5
d475 1
a475 1
	 * Check for input on the keyboard or on the polled registers.
d479 1
a479 2
	 *  2)  A change in peripheral status occurs
	 *  3)  The timelimit on SELECT has expired
d482 1
a482 2
	 * in which the peripherals (rate setting) may not be changed,
	 * but we still have to update the display,
d485 11
a495 3
	readfds = (1<<cmd_fd);
	if( second_fd )
		readfds |= (1<<second_fd);
d497 1
a497 4
	if( noblock )
		readfds = bsdselect( readfds, 0, 0 );
	else
		readfds = bsdselect( readfds, 30*60, 0 );
d499 1
a499 2
	dm_values.dv_penpress = 0;
	if( second_fd && readfds & (1<<second_fd) )
a500 5

	if( readfds & (1<<cmd_fd) )
		return(1);		/* command awaits */
	else
		return(0);		/* just peripheral stuff */
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 9.7 91/08/30 03:01:05 mike Exp $ (BRL)";
d24 2
d27 3
a29 1
#ifdef BSD
a30 2
#else
#include <string.h>
@


9.7
log
@strings.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 9.6 91/07/19 01:14:05 mike Exp $ (BRL)";
@


9.6
log
@IBM does not like u_char
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 9.5 91/02/02 00:01:08 mike Exp $ (BRL)";
d25 5
@


9.5
log
@Modified for new rt_vlist structures
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 9.4 91/01/12 08:25:35 mike Exp $ (BRL)";
a33 2
typedef unsigned char u_char;

d308 1
a308 1
register u_char *str;
@


9.4
log
@externs.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 9.3 91/01/03 22:52:20 butler Exp $ (BRL)";
d225 3
a227 3
	static vect_t last;
	register struct vlist *vp;
	int useful = 0;
d234 24
a257 12
	for( vp = sp->s_vlist; vp != VL_NULL; vp = vp->vl_forw )  {
		/* Viewing region is from -1.0 to +1.0 */
		if( vp->vl_draw == 0 )  {
			/* Move, not draw */
			MAT4X3PNT( last, mat, vp->vl_pnt );
		}  else  {
			static vect_t fin;
			static vect_t start;
			/* draw */
			MAT4X3PNT( fin, mat, vp->vl_pnt );
			VMOVE( start, last );
			VMOVE( last, fin );
a258 4
#ifdef later
				/* sqrt(1+1) */
				(ratio >= 0.7071)  &&
#endif
a260 1

@


9.3
log
@added mods to support tek mode windows on ATT 5620 through "-b" flag
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 9.2 90/12/13 04:17:19 butler Locked $ (BRL)";
a33 2
extern void	perror();

d114 1
a114 1
		char *p, *strchr();
@


9.2
log
@trying to un-do file ownership
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/mged/RCS/dm-tek.c,v 9.1 89/05/19 06:02:48 mike Rel3_5 $ (BRL)";
d347 22
a368 6
	/* ASSUMPTION:  Input is line buffered (tty cooked) */
	i = read( second_fd, ibuf, sizeof(ibuf) );
	/* The LAST 6 chars are the string from the tektronix */
	if( i < 6 )  {
		(void)printf("short read of %d\n", i);
		return;		/* Fails if he hits RETURN */
d370 11
a380 7
	}
	cp = &ibuf[i-6];
	if( cp[5] != '\n' )  {
		(void)printf("cursor synch?\n");
		(void)printf("saw:%c(%x) %c(%x) %c(%x) %c(%x) %c(%x) %c(%x)\n",
			cp[0], cp[0], cp[1], cp[1], cp[2], cp[2],
			cp[3], cp[3], cp[4], cp[4], cp[5], cp[5] );
d382 17
a398 1
	}
d400 35
a434 35
	/* cp[0] is what user typed, followed by 4pos + NL */
	hix = ((int)cp[1]&037)<<7;
	lox = ((int)cp[2]&037)<<2;
	hiy = ((int)cp[3]&037)<<7;
	loy = ((int)cp[4]&037)<<2;

	/* Tek positioning is 0..4096,
	 * The desired range is -2048 <= x,y <= +2048.
	 */
	dm_values.dv_xpen = TEK_TO_GED(hix|lox);
	dm_values.dv_ypen = TEK_TO_GED(hiy|loy);
	if( dm_values.dv_xpen < -2048 || dm_values.dv_xpen > 2048 )
		dm_values.dv_xpen = 0;
	if( dm_values.dv_ypen < -2048 || dm_values.dv_ypen > 2048 )
		dm_values.dv_ypen = 0;

	switch(cp[0])  {
	case 'Z':
		(void)printf("x=%d,y=%d\n", dm_values.dv_xpen, dm_values.dv_ypen);
		break;		/* NOP */
	case 'b':
		dm_values.dv_penpress = DV_INZOOM;
		break;
	case 's':
		dm_values.dv_penpress = DV_OUTZOOM;
		break;
	case '.':
		dm_values.dv_penpress = DV_SLEW;
		break;
	default:
		(void)printf("s=smaller, b=bigger, .=slew, space=pick/slew\n");
		return;
	case ' ':
		dm_values.dv_penpress = DV_PICK;
		break;
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 8.4 89/04/21 04:55:35 mike Exp $ (BRL)";
d87 1
d109 1
d112 2
a113 1
	(void)gets( line );		/* Null terminated */
d116 9
d353 1
d358 3
a360 2
		(void)printf("saw:%c%c%c%c%c%c\n",
			cp[0], cp[1], cp[2], cp[3], cp[4], cp[5] );
@


8.4
log
@Faceplate screen locations moved to titles.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 8.3 89/04/06 20:39:44 mike Locked $ (BRL)";
@


8.3
log
@Extern function declarations that used to be local to this module
and in solid.h are now in "externs.h"
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 8.2 88/12/06 01:07:05 mike Locked $ (BRL)";
d28 1
d30 1
a31 1
#include "externs.h"
@


8.2
log
@Added #include <raytrace.h> for vector list stuff
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/mged/RCS/dm-tek.c,v 1.2 88/10/23 13:56:19 mike Exp $ (BRL)";
d30 1
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 7.5 88/09/15 21:03:09 phil Exp $ (BRL)";
d27 1
@


7.5
log
@added release display flag
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 7.4 88/05/15 23:05:01 phil Locked $ (BRL)";
@


7.4
log
@lint fixes
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 7.3 88/02/25 06:06:51 mike Locked $ (BRL)";
d65 1
@


7.3
log
@Modified for new vector lists
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 7.2 87/11/05 05:05:19 mike Locked $ (BRL)";
d84 2
a85 1
static void tekmove(), tekcont();
d162 1
a162 1
	erase();
d168 1
a168 1
	point( 0, 0 );
d292 1
a292 1
	label(str);
d306 1
a306 1
		linemod("dotdashed");
d308 1
a308 1
		linemod("solid");
d323 2
a324 1
static get_cursor()
d488 4
a491 4
int oloy = -1;
int ohiy = -1;
int ohix = -1;
int oextra = -1;
d547 2
a548 1
erase()
d564 2
a565 1
label(s)
d574 2
a575 1
linemod(s)
d600 2
a601 1
point(xi,yi){
@


7.2
log
@Eliminated local machine.h, converted to fastf_t, now link with librt.a
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 7.1 87/11/03 00:00:12 mike Rel $ (BRL)";
d211 1
a211 2
	register struct veclist *vp;
	int nvec;
d219 1
a219 2
	nvec = sp->s_vlen;
	for( vp = sp->s_vlist; nvec-- > 0; vp++ )  {
d221 1
a221 1
		if( vp->vl_pen == PEN_UP )  {
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 6.1 87/07/11 08:03:24 mike Rel $ (BRL)";
d25 1
a25 1
#include "./machine.h"	/* special copy */
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 5.1 87/06/24 22:19:58 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 4.2 87/02/13 00:07:04 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 4.1 86/12/29 03:20:57 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 2.8 86/08/14 22:22:02 mike Exp $ (BRL)";
@


2.8
log
@Changed attach() to bsdattach() to provide better insulation.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 2.7 86/08/12 06:48:53 mike Exp $ (BRL)";
@


2.7
log
@Changed #includes for CC -I../h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 2.6 85/09/14 05:35:54 mike Exp $ (BRL)";
a68 6
struct timeval	{			/* needed for select() */
	long	tv_sec;			/* seconds */
	long	tv_usec;		/* microseconds */
};


a399 1
	static struct timeval timeout;
a413 6
	if( noblock )
		timeout.tv_sec = 0;
	else
		timeout.tv_sec = 30*60;		/* 30 MINUTES for Tek */
	timeout.tv_usec = 0;

d417 5
a421 1
	(void)select( 32, &readfds, 0L, 0L, &timeout );
@


2.6
log
@Lint-inspired cleanup.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 2.5 85/08/07 05:18:22 mike Exp $ (BRL)";
d26 4
a29 4
#include "../h/vmath.h"
#include "ged.h"
#include "dm.h"
#include "solid.h"
@


2.5
log
@Changed to use common ../h/vmath.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 2.4 85/06/03 16:49:05 mike Exp $ (BRL)";
d611 1
@


2.4
log
@Fixes to allow compilation on System V on the IRIS.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 2.3 85/05/10 00:53:20 mike Exp $ (BRL)";
d25 2
a26 1
#include "ged_types.h"
a28 1
#include "../h/vmath.h"
@


2.3
log
@Added multi-menu capability, added dmr_window and dmr_debug,
deleted dmr_restart.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 2.2 85/03/15 05:04:41 mike Exp $ (BRL)";
d90 2
d184 1
a184 1
	move( TITLE_XBASE, SOLID_YBASE );
d247 1
a247 1
			move(	(int)( start[0] * 2047 ),
d249 1
a249 1
			cont(	(int)( fin[0] * 2047 ),
d298 1
a298 1
	move(x,y);
d316 2
a317 2
	move(x1,y1);
	cont(x2,y2);
d504 2
a505 1
cont(x,y)
d549 2
a550 1
move(xi,yi)
d553 1
a553 1
	cont(xi,yi);
d607 2
a608 2
	move(xi,yi);
	cont(xi,yi);
@


2.2
log
@Added mapping between region ID and color + database handle.
Reorganized to support regular expressions on the command line.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 2.1 85/03/11 23:55:22 mike Prod $ (BRL)";
d39 1
a39 1
void	Tek_close(), Tek_restart();
d48 1
d51 1
a51 1
	Tek_open, Tek_close, Tek_restart,
d63 1
a76 13
/**** Begin global display information, used by dm.c *******/
extern int	inten_offset;		/* Intensity offset */
extern int	inten_scale;		/* Intensity scale */
extern int	xcross;
extern int	ycross;			/* tracking cross position */
extern int	windowbounds[6];	/* X hi,lo;  Y hi,lo;  Z hi,lo */
/**** End global display information ******/

/**** Global mode information ****/
extern int	regdebug;		/* toggled by "X" command */
extern int	adcflag;		/* A/D cursor on/off */
/**** End Global mode information ****/

a171 8

	/* Compute the clipping bounds */
	clipmin[0] = windowbounds[1] / 2048.;
	clipmin[1] = windowbounds[3] / 2048.;
	clipmin[2] = windowbounds[5] / 2048.;
	clipmax[0] = windowbounds[0] / 2047.;
	clipmax[1] = windowbounds[2] / 2047.;
	clipmax[2] = windowbounds[4] / 2047.;
d605 18
@


2.1
log
@First production release.
Includes lint cleanups from Gwyn.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 1.4 85/03/08 20:51:10 mike Exp $ (BRL)";
d47 1
a47 1
void	Tek_statechange(), Tek_viewchange();
d61 1
d497 5
@


1.4
log
@Added statechange, viewchange, and displaylist hooks.
@
text
@d5 1
a5 1
 * it's images on Tektronix 4014 compatible displays.
d8 2
a9 1
 * Mike Muuss, BRL, 16-Jan-85.
d11 1
a11 1
 * Source -
d15 4
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 1.3 85/02/02 01:39:04 mike Exp $ (BRL)";
d28 1
a28 1
#include "vmath.h"
d31 2
d66 1
a66 1
struct timeval	{			/* needed for _select() */
a78 1
extern mat_t	rot;			/* viewing rotation */
d118 1
a118 1
	printf("Output tty [stdout]? ");
d123 1
a123 1
			sprintf( line2, "/dev/tty%s%c", line, '\0' );
d147 2
a148 2
	putc(US,outfp);
	fflush(outfp);
d160 1
a160 1
	printf("Tek_restart\n");
a170 2
	register int i;

d177 2
a178 2
	putc(ESC,outfp);
	putc(';',outfp);
a182 14
#ifdef never
	/* Draw the tracking cross */
#define CLIP(v)	if(v < -2048) v = -2048; else if(v > 2047) v = 2047;
	i = xcross-75;  CLIP(i);
	move( i, ycross );
	i = xcross+75;  CLIP(i);
	cont(i, ycross );

	i = ycross-75;  CLIP(i);
	move( xcross, i );
	i = ycross+75;  CLIP(i);
	cont( xcross, i );
#undef CLIP
#endif
d201 1
a201 1
	putc(US,outfp);
d208 1
d225 1
d238 1
a238 1
		putc('b',outfp);	/* Dot dash */
d240 1
a240 1
		putc('`',outfp);	/* Solid */
d249 1
a249 1
			static vect_t finish;
d252 1
a252 1
			MAT4X3PNT( finish, mat, vp->vl_pnt );
d254 1
a254 1
			VMOVE( last, finish );
d260 1
a260 1
				vclip( start, finish, clipmin, clipmax ) == 0
d265 2
a266 2
			cont(	(int)( finish[0] * 2047 ),
				(int)( finish[1] * 2047 ) );
d296 2
a297 2
		putc(ESC,outfp);
		putc(SUB,outfp);
d299 2
a300 2
		putc(US,outfp);		/* Alpha mode */
	fflush(outfp);
d309 1
d357 1
a357 1
		printf("short read of %d\n", i);
d362 2
a363 2
		printf("cursor synch?\n");
		printf("saw:%c%c%c%c%c%c\n",
d386 1
a386 1
		printf("x=%d,y=%d\n", dm_values.dv_xpen, dm_values.dv_ypen);
d398 1
a398 1
		printf("s=smaller, b=bigger, .=slew, space=pick/slew\n");
a422 1
	register int i, j;
d446 1
a446 1
	(void)_select( 32, &readfds, 0L, 0L, &timeout );
d461 1
d470 1
d473 1
a473 1
register struct solid *sp;
d485 1
a485 1
	printf("Tek_load(x%x, %d.)\n", addr, count );
d500 1
a500 1
 *	This program performs the interpretation function
a501 3
 * The device independant requests which the TIG-PACK routines
 * output are mapped by this program into 4014 commands.
 *
a507 10
/*** pilfered, for now *** */
/*	@@(#)subr.c	1.1	*/
float obotx = 0.;
float oboty = 0.;
float botx = 0.;
float boty = 0.;
float scalex = 1.;
float scaley = 1.;
int scaleflag;

d514 1
a523 4
#ifdef never
	x = (x-obotx)*scalex + botx;
	y = (y-oboty)*scaley + boty;
#endif
d531 1
a531 1
		putc(hiy|040,outfp);
d534 3
a536 3
	if(hix != ohix){
		if(extra != oextra){
			putc(extra|0140,outfp);
d539 2
a540 2
		putc(loy|0140,outfp);
		putc(hix|040,outfp);
d543 4
a546 5
	}
	else{
		if(extra != oextra){
			putc(extra|0140,outfp);
			putc(loy|0140,outfp);
d549 2
a550 3
		}
		else if(loy != oloy){
			putc(loy|0140,outfp);
d554 1
a554 1
	putc(lox|0100,outfp);
d556 1
a556 1
		putc(0,outfp);
d559 3
a561 3
move(xi,yi){

	putc(GS,outfp);			/* Next vector blank */
d565 2
a566 1
erase(){
d568 3
a570 2
	putc(ESC,outfp);
	putc(FF,outfp);
d572 1
a572 1
	fflush(outfp);
d578 1
a578 1
		sleep(3);
d584 1
a584 1
	putc(US,outfp);
d586 1
a586 1
		putc(*s,outfp);
d591 1
a591 1
char *s;
d593 3
a595 2
	int c;				/* DAG -- was char */
	putc(ESC,outfp);
d612 1
a612 1
	putc(c,outfp);
@


1.3
log
@dmr_open routines now return success/fail indication
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 1.2 85/01/19 03:56:55 mike Exp $ (BRL)";
d40 1
d52 3
d494 11
d597 1
d599 2
a600 1
		sleep(2);
@


1.2
log
@Improved version.
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header: dm-tek.c,v 1.1 85/01/17 07:20:24 mike Exp $ (BRL)";
d31 2
a32 1
void	Tek_open(), Tek_close(), Tek_restart();
a103 1
void
d116 1
a116 1
				outfp = fopen("/dev/null","r+w");
d121 2
a122 1
		outfp = fopen("/dev/tty","r+w");
d126 1
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d485 2
a486 1
	return( count );
d619 1
a619 1
	cont(xi+1,yi+1);
@
